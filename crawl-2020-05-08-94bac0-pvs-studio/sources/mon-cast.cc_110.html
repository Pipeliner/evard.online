
<html>
<head>

  <meta http-equiv="Content-Type" content="text/html; charset=US-ASCII" />
  <title>mon-cast.cc</title>

  <link rel="stylesheet" href="../style.css"/>
  <script src="../jquery-3.2.1.min.js"></script>
</head>
<body>

<pre><code class = "cpp">
<a name="ln1">/**</a>
<a name="ln2"> * @file</a>
<a name="ln3"> * @brief Monster spell casting.</a>
<a name="ln4">**/</a>
<a name="ln5"> </a>
<a name="ln6">#include &quot;AppHdr.h&quot;</a>
<a name="ln7"> </a>
<a name="ln8">#include &quot;mon-cast.h&quot;</a>
<a name="ln9"> </a>
<a name="ln10">#include &lt;algorithm&gt;</a>
<a name="ln11">#include &lt;cmath&gt;</a>
<a name="ln12">#include &lt;functional&gt;</a>
<a name="ln13">#include &lt;unordered_set&gt;</a>
<a name="ln14"> </a>
<a name="ln15">#include &quot;act-iter.h&quot;</a>
<a name="ln16">#include &quot;areas.h&quot;</a>
<a name="ln17">#include &quot;attack.h&quot;</a>
<a name="ln18">#include &quot;bloodspatter.h&quot;</a>
<a name="ln19">#include &quot;branch.h&quot;</a>
<a name="ln20">#include &quot;cleansing-flame-source-type.h&quot;</a>
<a name="ln21">#include &quot;cloud.h&quot;</a>
<a name="ln22">#include &quot;colour.h&quot;</a>
<a name="ln23">#include &quot;coordit.h&quot;</a>
<a name="ln24">#include &quot;database.h&quot;</a>
<a name="ln25">#include &quot;delay.h&quot;</a>
<a name="ln26">#include &quot;directn.h&quot;</a>
<a name="ln27">#include &quot;english.h&quot;</a>
<a name="ln28">#include &quot;env.h&quot;</a>
<a name="ln29">#include &quot;evoke.h&quot;</a>
<a name="ln30">#include &quot;exclude.h&quot;</a>
<a name="ln31">#include &quot;fight.h&quot;</a>
<a name="ln32">#include &quot;fprop.h&quot;</a>
<a name="ln33">#include &quot;god-passive.h&quot;</a>
<a name="ln34">#include &quot;items.h&quot;</a>
<a name="ln35">#include &quot;level-state-type.h&quot;</a>
<a name="ln36">#include &quot;libutil.h&quot;</a>
<a name="ln37">#include &quot;losglobal.h&quot;</a>
<a name="ln38">#include &quot;mapmark.h&quot;</a>
<a name="ln39">#include &quot;message.h&quot;</a>
<a name="ln40">#include &quot;misc.h&quot;</a>
<a name="ln41">#include &quot;mon-act.h&quot;</a>
<a name="ln42">#include &quot;mon-behv.h&quot;</a>
<a name="ln43">#include &quot;mon-clone.h&quot;</a>
<a name="ln44">#include &quot;mon-death.h&quot;</a>
<a name="ln45">#include &quot;mon-gear.h&quot;</a>
<a name="ln46">#include &quot;mon-pathfind.h&quot;</a>
<a name="ln47">#include &quot;mon-pick.h&quot;</a>
<a name="ln48">#include &quot;mon-place.h&quot;</a>
<a name="ln49">#include &quot;mon-project.h&quot;</a>
<a name="ln50">#include &quot;mon-speak.h&quot;</a>
<a name="ln51">#include &quot;mon-tentacle.h&quot;</a>
<a name="ln52">#include &quot;mutation.h&quot;</a>
<a name="ln53">#include &quot;player-stats.h&quot;</a>
<a name="ln54">#include &quot;random.h&quot;</a>
<a name="ln55">#include &quot;religion.h&quot;</a>
<a name="ln56">#include &quot;shout.h&quot;</a>
<a name="ln57">#include &quot;spl-clouds.h&quot;</a>
<a name="ln58">#include &quot;spl-damage.h&quot;</a>
<a name="ln59">#include &quot;spl-goditem.h&quot;</a>
<a name="ln60">#include &quot;spl-monench.h&quot;</a>
<a name="ln61">#include &quot;spl-summoning.h&quot;</a>
<a name="ln62">#include &quot;spl-transloc.h&quot;</a>
<a name="ln63">#include &quot;spl-util.h&quot;</a>
<a name="ln64">#include &quot;spl-zap.h&quot; // spell_to_zap</a>
<a name="ln65">#include &quot;state.h&quot;</a>
<a name="ln66">#include &quot;stepdown.h&quot;</a>
<a name="ln67">#include &quot;stringutil.h&quot;</a>
<a name="ln68">#include &quot;target.h&quot;</a>
<a name="ln69">#include &quot;teleport.h&quot;</a>
<a name="ln70">#include &quot;terrain.h&quot;</a>
<a name="ln71">#ifdef USE_TILE</a>
<a name="ln72">#include &quot;rltiles/tiledef-dngn.h&quot;</a>
<a name="ln73">#endif</a>
<a name="ln74">#include &quot;timed-effects.h&quot;</a>
<a name="ln75">#include &quot;traps.h&quot;</a>
<a name="ln76">#include &quot;travel.h&quot;</a>
<a name="ln77">#include &quot;unwind.h&quot;</a>
<a name="ln78">#include &quot;view.h&quot;</a>
<a name="ln79">#include &quot;viewchar.h&quot;</a>
<a name="ln80">#include &quot;xom.h&quot;</a>
<a name="ln81"> </a>
<a name="ln82">static bool _valid_mon_spells[NUM_SPELLS];</a>
<a name="ln83"> </a>
<a name="ln84">static const string MIRROR_RECAST_KEY = &quot;mirror_recast_time&quot;;</a>
<a name="ln85"> </a>
<a name="ln86">static god_type _find_god(const monster &amp;mons, mon_spell_slot_flags flags);</a>
<a name="ln87">static monster* _get_allied_target(const monster &amp;caster, bolt &amp;tracer);</a>
<a name="ln88">static void _fire_simple_beam(monster &amp;caster, mon_spell_slot, bolt &amp;beam);</a>
<a name="ln89">static void _fire_direct_explosion(monster &amp;caster, mon_spell_slot, bolt &amp;beam);</a>
<a name="ln90">static int  _mons_mesmerise(monster* mons, bool actual = true);</a>
<a name="ln91">static int  _mons_cause_fear(monster* mons, bool actual = true);</a>
<a name="ln92">static int  _mons_mass_confuse(monster* mons, bool actual = true);</a>
<a name="ln93">static coord_def _mons_fragment_target(const monster &amp;mons);</a>
<a name="ln94">static coord_def _mons_awaken_earth_target(const monster&amp; mon);</a>
<a name="ln95">static void _maybe_throw_ally(const monster &amp;mons);</a>
<a name="ln96">static void _siren_sing(monster* mons, bool avatar);</a>
<a name="ln97">static void _doom_howl(monster &amp;mon);</a>
<a name="ln98">static void _mons_awaken_earth(monster &amp;mon, const coord_def &amp;target);</a>
<a name="ln99">static bool _ms_waste_of_time(monster* mon, mon_spell_slot slot);</a>
<a name="ln100">static string _god_name(god_type god);</a>
<a name="ln101">static bool _mons_can_bind_soul(monster* binder, monster* bound);</a>
<a name="ln102">static coord_def _mons_ghostly_sacrifice_target(const monster &amp;caster,</a>
<a name="ln103">                                                bolt tracer);</a>
<a name="ln104">static function&lt;void(bolt&amp;, const monster&amp;, int)&gt;</a>
<a name="ln105">    _selfench_beam_setup(beam_type flavour);</a>
<a name="ln106">static function&lt;void(bolt&amp;, const monster&amp;, int)&gt;</a>
<a name="ln107">    _zap_setup(spell_type spell);</a>
<a name="ln108">static function&lt;void(bolt&amp;, const monster&amp;, int)&gt;</a>
<a name="ln109">    _buff_beam_setup(beam_type flavour);</a>
<a name="ln110">static function&lt;void(bolt&amp;, const monster&amp;, int)&gt;</a>
<a name="ln111">    _target_beam_setup(function&lt;coord_def(const monster&amp;)&gt; targeter);</a>
<a name="ln112">static void _setup_minor_healing(bolt &amp;beam, const monster &amp;caster,</a>
<a name="ln113">                                 int = -1);</a>
<a name="ln114">static void _setup_heal_other(bolt &amp;beam, const monster &amp;caster, int = -1);</a>
<a name="ln115">static bool _foe_should_res_negative_energy(const actor* foe);</a>
<a name="ln116">static bool _caster_sees_foe(const monster &amp;caster);</a>
<a name="ln117">static bool _foe_can_sleep(const monster &amp;caster);</a>
<a name="ln118">static bool _foe_not_teleporting(const monster &amp;caster);</a>
<a name="ln119">static bool _foe_not_mr_vulnerable(const monster &amp;caster);</a>
<a name="ln120">static bool _should_still_winds(const monster &amp;caster);</a>
<a name="ln121">static void _mons_vampiric_drain(monster &amp;mons, mon_spell_slot, bolt&amp;);</a>
<a name="ln122">static void _cast_cantrip(monster &amp;mons, mon_spell_slot, bolt&amp;);</a>
<a name="ln123">static void _cast_injury_mirror(monster &amp;mons, mon_spell_slot, bolt&amp;);</a>
<a name="ln124">static void _cast_smiting(monster &amp;mons, mon_spell_slot slot, bolt&amp;);</a>
<a name="ln125">static void _cast_resonance_strike(monster &amp;mons, mon_spell_slot, bolt&amp;);</a>
<a name="ln126">static void _cast_flay(monster &amp;caster, mon_spell_slot, bolt&amp;);</a>
<a name="ln127">static void _cast_still_winds(monster &amp;caster, mon_spell_slot, bolt&amp;);</a>
<a name="ln128">static void _mons_summon_elemental(monster &amp;caster, mon_spell_slot, bolt&amp;);</a>
<a name="ln129">static bool _los_spell_worthwhile(const monster &amp;caster, spell_type spell);</a>
<a name="ln130">static void _setup_fake_beam(bolt&amp; beam, const monster&amp;, int = -1);</a>
<a name="ln131">static void _branch_summon(monster &amp;caster, mon_spell_slot slot, bolt&amp;);</a>
<a name="ln132">static void _branch_summon_helper(monster* mons, spell_type spell_cast);</a>
<a name="ln133">static bool _prepare_ghostly_sacrifice(monster &amp;caster, bolt &amp;beam);</a>
<a name="ln134">static void _setup_ghostly_beam(bolt &amp;beam, int power, int dice);</a>
<a name="ln135">static void _setup_ghostly_sacrifice_beam(bolt&amp; beam, const monster&amp; caster,</a>
<a name="ln136">                                          int power);</a>
<a name="ln137">static function&lt;bool(const monster&amp;)&gt; _setup_hex_check(spell_type spell);</a>
<a name="ln138">static bool _worth_hexing(const monster &amp;caster, spell_type spell);</a>
<a name="ln139">static bool _torment_vulnerable(actor* victim);</a>
<a name="ln140">static function&lt;bool(const monster&amp;)&gt; _should_selfench(enchant_type ench);</a>
<a name="ln141">static void _cast_grasping_roots(monster &amp;caster, mon_spell_slot, bolt&amp;);</a>
<a name="ln142">static int _monster_abjuration(const monster&amp; caster, bool actual);</a>
<a name="ln143">static bool _mons_will_abjure(const monster&amp; mons);</a>
<a name="ln144"> </a>
<a name="ln145">enum spell_logic_flag</a>
<a name="ln146">{</a>
<a name="ln147">    MSPELL_NO_AUTO_NOISE = 1 &lt;&lt; 0, ///&lt; silent, or noise generated specially</a>
<a name="ln148">};</a>
<a name="ln149"> </a>
<a name="ln150">DEF_BITFIELD(spell_logic_flags, spell_logic_flag);</a>
<a name="ln151">constexpr spell_logic_flags MSPELL_LOGIC_NONE{};</a>
<a name="ln152"> </a>
<a name="ln153">struct mons_spell_logic</a>
<a name="ln154">{</a>
<a name="ln155">    /// Can casting this spell right now accomplish anything useful?</a>
<a name="ln156">    function&lt;bool(const monster&amp;)&gt; worthwhile;</a>
<a name="ln157">    /// Actually cast the given spell.</a>
<a name="ln158">    function&lt;void(monster&amp;, mon_spell_slot, bolt&amp;)&gt; cast;</a>
<a name="ln159">    /// Setup a targeting/effect beam for the given spell, if applicable.</a>
<a name="ln160">    function&lt;void(bolt&amp;, const monster&amp;, int)&gt; setup_beam;</a>
<a name="ln161">    /// What special behaviors does this spell have for monsters?</a>
<a name="ln162">    spell_logic_flags flags;</a>
<a name="ln163">    /// How much 'power' is this spell cast with per caster HD? If 0, ignore</a>
<a name="ln164">    int power_hd_factor;</a>
<a name="ln165">};</a>
<a name="ln166"> </a>
<a name="ln167">static bool _always_worthwhile(const monster &amp;/*caster*/) { return true; }</a>
<a name="ln168">static bool _caster_has_foe(const monster &amp;caster) { return caster.foe != 0; }</a>
<a name="ln169">static mons_spell_logic _conjuration_logic(spell_type spell);</a>
<a name="ln170">static mons_spell_logic _hex_logic(spell_type spell,</a>
<a name="ln171">                                   function&lt;bool(const monster&amp;)&gt; extra_logic</a>
<a name="ln172">                                   = nullptr,</a>
<a name="ln173">                                   int power_hd_factor = 0);</a>
<a name="ln174"> </a>
<a name="ln175"> </a>
<a name="ln176">/// How do monsters go about casting spells?</a>
<a name="ln177">static const map&lt;spell_type, mons_spell_logic&gt; spell_to_logic = {</a>
<a name="ln178">    { SPELL_MIGHT, {</a>
<a name="ln179">        _should_selfench(ENCH_MIGHT),</a>
<a name="ln180">        _fire_simple_beam,</a>
<a name="ln181">        _selfench_beam_setup(BEAM_MIGHT),</a>
<a name="ln182">    } },</a>
<a name="ln183">    { SPELL_INVISIBILITY, {</a>
<a name="ln184">        _should_selfench(ENCH_INVIS),</a>
<a name="ln185">        _fire_simple_beam,</a>
<a name="ln186">        _selfench_beam_setup(BEAM_INVISIBILITY),</a>
<a name="ln187">    } },</a>
<a name="ln188">    { SPELL_HASTE, {</a>
<a name="ln189">        _should_selfench(ENCH_HASTE),</a>
<a name="ln190">        _fire_simple_beam,</a>
<a name="ln191">        _selfench_beam_setup(BEAM_HASTE),</a>
<a name="ln192">    } },</a>
<a name="ln193">    { SPELL_MINOR_HEALING, {</a>
<a name="ln194">        [](const monster &amp;caster) {</a>
<a name="ln195">            return caster.hit_points &lt;= caster.max_hit_points / 2;</a>
<a name="ln196">        },</a>
<a name="ln197">        _fire_simple_beam,</a>
<a name="ln198">        _setup_minor_healing,</a>
<a name="ln199">    } },</a>
<a name="ln200">    { SPELL_TELEPORT_SELF, {</a>
<a name="ln201">        [](const monster &amp;caster)</a>
<a name="ln202">        {</a>
<a name="ln203">            // Monsters aren't smart enough to know when to cancel teleport.</a>
<a name="ln204">            return !caster.has_ench(ENCH_TP) &amp;&amp; !caster.no_tele(true, false);</a>
<a name="ln205">        },</a>
<a name="ln206">        _fire_simple_beam,</a>
<a name="ln207">        _selfench_beam_setup(BEAM_TELEPORT),</a>
<a name="ln208">    } },</a>
<a name="ln209">    { SPELL_SLUG_DART, _conjuration_logic(SPELL_SLUG_DART) },</a>
<a name="ln210">    { SPELL_VAMPIRIC_DRAINING, {</a>
<a name="ln211">        [](const monster &amp;caster)</a>
<a name="ln212">        {</a>
<a name="ln213">            const actor* foe = caster.get_foe();</a>
<a name="ln214">            // always cast at &lt; 1/3rd hp, never at &gt; 2/3rd hp</a>
<a name="ln215">            const bool low_hp = x_chance_in_y(caster.max_hit_points * 2 / 3</a>
<a name="ln216">                                                - caster.hit_points,</a>
<a name="ln217">                                              caster.max_hit_points / 3);</a>
<a name="ln218">            return foe</a>
<a name="ln219">                   &amp;&amp; adjacent(caster.pos(), foe-&gt;pos())</a>
<a name="ln220">                   &amp;&amp; !_foe_should_res_negative_energy(foe)</a>
<a name="ln221">                   &amp;&amp; low_hp;</a>
<a name="ln222">        },</a>
<a name="ln223">        _mons_vampiric_drain,</a>
<a name="ln224">        nullptr,</a>
<a name="ln225">        MSPELL_NO_AUTO_NOISE,</a>
<a name="ln226">    } },</a>
<a name="ln227">    { SPELL_CANTRIP, {</a>
<a name="ln228">        [](const monster &amp;caster) { return caster.get_foe(); },</a>
<a name="ln229">        _cast_cantrip,</a>
<a name="ln230">        nullptr,</a>
<a name="ln231">        MSPELL_NO_AUTO_NOISE,</a>
<a name="ln232">    } },</a>
<a name="ln233">    { SPELL_INJURY_MIRROR, {</a>
<a name="ln234">        [](const monster &amp;caster) {</a>
<a name="ln235">            return !caster.has_ench(ENCH_MIRROR_DAMAGE)</a>
<a name="ln236">                    &amp;&amp; (!caster.props.exists(MIRROR_RECAST_KEY)</a>
<a name="ln237">                        || you.elapsed_time &gt;=</a>
<a name="ln238">                           caster.props[MIRROR_RECAST_KEY].get_int());</a>
<a name="ln239">        },</a>
<a name="ln240">        _cast_injury_mirror,</a>
<a name="ln241">        nullptr,</a>
<a name="ln242">        MSPELL_NO_AUTO_NOISE,</a>
<a name="ln243">    } },</a>
<a name="ln244">    { SPELL_DRAIN_LIFE, {</a>
<a name="ln245">        [](const monster &amp;caster) {</a>
<a name="ln246">            return _los_spell_worthwhile(caster, SPELL_DRAIN_LIFE)</a>
<a name="ln247">                   &amp;&amp; (!caster.friendly()</a>
<a name="ln248">                       || !you.visible_to(&amp;caster)</a>
<a name="ln249">                       || player_prot_life(false) &gt;= 3);</a>
<a name="ln250">        },</a>
<a name="ln251">        [](monster &amp;caster, mon_spell_slot slot, bolt&amp;) {</a>
<a name="ln252">            const int splpow = mons_spellpower(caster, slot.spell);</a>
<a name="ln253"> </a>
<a name="ln254">            int damage = 0;</a>
<a name="ln255">            fire_los_attack_spell(slot.spell, splpow, &amp;caster, false, &amp;damage);</a>
<a name="ln256">            if (damage &gt; 0 &amp;&amp; caster.heal(damage))</a>
<a name="ln257">                simple_monster_message(caster, &quot; is healed.&quot;);</a>
<a name="ln258">        },</a>
<a name="ln259">        nullptr,</a>
<a name="ln260">        MSPELL_NO_AUTO_NOISE,</a>
<a name="ln261">        1,</a>
<a name="ln262">    } },</a>
<a name="ln263">    { SPELL_OZOCUBUS_REFRIGERATION, {</a>
<a name="ln264">        [](const monster &amp;caster) {</a>
<a name="ln265">            return _los_spell_worthwhile(caster, SPELL_OZOCUBUS_REFRIGERATION)</a>
<a name="ln266">                   &amp;&amp; (!caster.friendly() || !you.visible_to(&amp;caster));</a>
<a name="ln267">        },</a>
<a name="ln268">        [](monster &amp;caster, mon_spell_slot slot, bolt&amp;) {</a>
<a name="ln269">            const int splpow = mons_spellpower(caster, slot.spell);</a>
<a name="ln270">            fire_los_attack_spell(slot.spell, splpow, &amp;caster, false);</a>
<a name="ln271">        },</a>
<a name="ln272">        nullptr,</a>
<a name="ln273">        MSPELL_LOGIC_NONE,</a>
<a name="ln274">        5,</a>
<a name="ln275">    } },</a>
<a name="ln276">    { SPELL_TROGS_HAND, {</a>
<a name="ln277">        [](const monster &amp;caster) {</a>
<a name="ln278">            return !caster.has_ench(ENCH_RAISED_MR)</a>
<a name="ln279">                &amp;&amp; !caster.has_ench(ENCH_REGENERATION);</a>
<a name="ln280">        },</a>
<a name="ln281">        [](monster &amp;caster, mon_spell_slot, bolt&amp;) {</a>
<a name="ln282">            const string god = apostrophise(god_name(caster.god));</a>
<a name="ln283">            const string msg = make_stringf(&quot; invokes %s protection!&quot;,</a>
<a name="ln284">                                            god.c_str());</a>
<a name="ln285">            simple_monster_message(caster, msg.c_str(), MSGCH_MONSTER_SPELL);</a>
<a name="ln286">            // Not spell_hd(spell_cast); this is an invocation</a>
<a name="ln287">            const int dur = BASELINE_DELAY</a>
<a name="ln288">                * min(5 + roll_dice(2, (caster.get_hit_dice() * 10) / 3 + 1),</a>
<a name="ln289">                      100);</a>
<a name="ln290">            caster.add_ench(mon_enchant(ENCH_RAISED_MR, 0, &amp;caster, dur));</a>
<a name="ln291">            caster.add_ench(mon_enchant(ENCH_REGENERATION, 0, &amp;caster, dur));</a>
<a name="ln292">            dprf(&quot;Trog's Hand cast (dur: %d aut)&quot;, dur);</a>
<a name="ln293">        },</a>
<a name="ln294">        nullptr,</a>
<a name="ln295">        MSPELL_NO_AUTO_NOISE,</a>
<a name="ln296">    } },</a>
<a name="ln297">    { SPELL_LEDAS_LIQUEFACTION, {</a>
<a name="ln298">        [](const monster &amp;caster) {</a>
<a name="ln299">            return !caster.has_ench(ENCH_LIQUEFYING);</a>
<a name="ln300">        },</a>
<a name="ln301">        [](monster &amp;caster, mon_spell_slot, bolt&amp;) {</a>
<a name="ln302">            if (you.can_see(caster))</a>
<a name="ln303">            {</a>
<a name="ln304">                mprf(&quot;%s liquefies the ground around %s!&quot;,</a>
<a name="ln305">                     caster.name(DESC_THE).c_str(),</a>
<a name="ln306">                     caster.pronoun(PRONOUN_REFLEXIVE).c_str());</a>
<a name="ln307">                flash_view_delay(UA_MONSTER, BROWN, 80);</a>
<a name="ln308">            }</a>
<a name="ln309"> </a>
<a name="ln310">            caster.add_ench(ENCH_LIQUEFYING);</a>
<a name="ln311">            invalidate_agrid(true);</a>
<a name="ln312">        },</a>
<a name="ln313">        nullptr,</a>
<a name="ln314">        MSPELL_NO_AUTO_NOISE,</a>
<a name="ln315">    } },</a>
<a name="ln316">    { SPELL_FORCEFUL_INVITATION, {</a>
<a name="ln317">        _always_worthwhile,</a>
<a name="ln318">        _branch_summon,</a>
<a name="ln319">        nullptr,</a>
<a name="ln320">        MSPELL_NO_AUTO_NOISE,</a>
<a name="ln321">    } },</a>
<a name="ln322">    { SPELL_PLANEREND, {</a>
<a name="ln323">        _always_worthwhile,</a>
<a name="ln324">        _branch_summon,</a>
<a name="ln325">        nullptr,</a>
<a name="ln326">        MSPELL_NO_AUTO_NOISE,</a>
<a name="ln327">    } },</a>
<a name="ln328">    { SPELL_STILL_WINDS, { _should_still_winds, _cast_still_winds } },</a>
<a name="ln329">    { SPELL_SMITING, { _caster_has_foe, _cast_smiting, } },</a>
<a name="ln330">    { SPELL_RESONANCE_STRIKE, { _caster_has_foe, _cast_resonance_strike, } },</a>
<a name="ln331">    { SPELL_FLAY, {</a>
<a name="ln332">        [](const monster &amp;caster) {</a>
<a name="ln333">            const actor* foe = caster.get_foe(); // XXX: check vis?</a>
<a name="ln334">            return foe &amp;&amp; (foe-&gt;holiness() &amp; MH_NATURAL);</a>
<a name="ln335">        },</a>
<a name="ln336">        _cast_flay,</a>
<a name="ln337">    } },</a>
<a name="ln338">    { SPELL_PARALYSIS_GAZE, {</a>
<a name="ln339">        _caster_sees_foe,</a>
<a name="ln340">        [](monster &amp;caster, mon_spell_slot, bolt&amp;) {</a>
<a name="ln341">            caster.get_foe()-&gt;paralyse(&amp;caster, 2 + random2(3));</a>
<a name="ln342">        },</a>
<a name="ln343">    } },</a>
<a name="ln344">    { SPELL_DRAINING_GAZE, {</a>
<a name="ln345">        _caster_sees_foe,</a>
<a name="ln346">        [](monster &amp;caster, mon_spell_slot slot, bolt&amp;) {</a>
<a name="ln347">            enchant_actor_with_flavour(caster.get_foe(), &amp;caster,</a>
<a name="ln348">                                       BEAM_DRAIN_MAGIC,</a>
<a name="ln349">                                       mons_spellpower(caster, slot.spell));</a>
<a name="ln350">        },</a>
<a name="ln351">    } },</a>
<a name="ln352">    { SPELL_WATER_ELEMENTALS, { _always_worthwhile, _mons_summon_elemental } },</a>
<a name="ln353">    { SPELL_EARTH_ELEMENTALS, { _always_worthwhile, _mons_summon_elemental } },</a>
<a name="ln354">    { SPELL_AIR_ELEMENTALS, { _always_worthwhile, _mons_summon_elemental } },</a>
<a name="ln355">    { SPELL_FIRE_ELEMENTALS, { _always_worthwhile, _mons_summon_elemental } },</a>
<a name="ln356">    { SPELL_HASTE_OTHER, {</a>
<a name="ln357">        _always_worthwhile,</a>
<a name="ln358">        _fire_simple_beam,</a>
<a name="ln359">        _buff_beam_setup(BEAM_HASTE)</a>
<a name="ln360">    } },</a>
<a name="ln361">    { SPELL_MIGHT_OTHER, {</a>
<a name="ln362">        _always_worthwhile,</a>
<a name="ln363">        _fire_simple_beam,</a>
<a name="ln364">        _buff_beam_setup(BEAM_MIGHT)</a>
<a name="ln365">    } },</a>
<a name="ln366">    { SPELL_INVISIBILITY_OTHER, {</a>
<a name="ln367">        _always_worthwhile,</a>
<a name="ln368">        _fire_simple_beam,</a>
<a name="ln369">        _buff_beam_setup(BEAM_INVISIBILITY)</a>
<a name="ln370">    } },</a>
<a name="ln371">    { SPELL_HEAL_OTHER, {</a>
<a name="ln372">        _always_worthwhile,</a>
<a name="ln373">        _fire_simple_beam,</a>
<a name="ln374">        _setup_heal_other,</a>
<a name="ln375">    } },</a>
<a name="ln376">    { SPELL_LRD, {</a>
<a name="ln377">        _always_worthwhile,</a>
<a name="ln378">        [](monster &amp;caster, mon_spell_slot slot, bolt&amp; pbolt) {</a>
<a name="ln379">            const int splpow = mons_spellpower(caster, slot.spell);</a>
<a name="ln380">            cast_fragmentation(splpow, &amp;caster, pbolt.target, false);</a>
<a name="ln381">        },</a>
<a name="ln382">        _target_beam_setup(_mons_fragment_target),</a>
<a name="ln383">        MSPELL_LOGIC_NONE, 6</a>
<a name="ln384">    } },</a>
<a name="ln385">    { SPELL_AWAKEN_EARTH, {</a>
<a name="ln386">        _always_worthwhile,</a>
<a name="ln387">        [](monster &amp;caster, mon_spell_slot, bolt&amp; pbolt) {</a>
<a name="ln388">            _mons_awaken_earth(caster, pbolt.target);</a>
<a name="ln389">        },</a>
<a name="ln390">        _target_beam_setup(_mons_awaken_earth_target),</a>
<a name="ln391">    } },</a>
<a name="ln392">    { SPELL_GHOSTLY_SACRIFICE, {</a>
<a name="ln393">        _always_worthwhile,</a>
<a name="ln394">        [](monster &amp;caster, mon_spell_slot slot, bolt&amp; pbolt) {</a>
<a name="ln395">            if (_prepare_ghostly_sacrifice(caster, pbolt))</a>
<a name="ln396">                _fire_direct_explosion(caster, slot, pbolt);</a>
<a name="ln397">            else if (you.can_see(caster))</a>
<a name="ln398">                canned_msg(MSG_NOTHING_HAPPENS);</a>
<a name="ln399">        },</a>
<a name="ln400">        _setup_ghostly_sacrifice_beam,</a>
<a name="ln401">    } },</a>
<a name="ln402">    { SPELL_SLOW, _hex_logic(SPELL_SLOW) },</a>
<a name="ln403">    { SPELL_CONFUSE, _hex_logic(SPELL_CONFUSE) },</a>
<a name="ln404">    { SPELL_BANISHMENT, _hex_logic(SPELL_BANISHMENT) },</a>
<a name="ln405">    { SPELL_PARALYSE, _hex_logic(SPELL_PARALYSE) },</a>
<a name="ln406">    { SPELL_PETRIFY, _hex_logic(SPELL_PETRIFY) },</a>
<a name="ln407">    { SPELL_PAIN, _hex_logic(SPELL_PAIN, [](const monster&amp; caster) {</a>
<a name="ln408">            return _torment_vulnerable(caster.get_foe());</a>
<a name="ln409">    }) },</a>
<a name="ln410">    { SPELL_DISINTEGRATE, _hex_logic(SPELL_DISINTEGRATE) },</a>
<a name="ln411">    { SPELL_CORONA, _hex_logic(SPELL_CORONA, [](const monster&amp; caster) {</a>
<a name="ln412">            return !caster.get_foe()-&gt;backlit();</a>
<a name="ln413">    }) },</a>
<a name="ln414">    { SPELL_POLYMORPH, _hex_logic(SPELL_POLYMORPH, [](const monster&amp; caster) {</a>
<a name="ln415">        return !caster.friendly(); // too dangerous to let allies use</a>
<a name="ln416">    }) },</a>
<a name="ln417">    { SPELL_SLEEP, _hex_logic(SPELL_SLEEP, _foe_can_sleep, 6) },</a>
<a name="ln418">    { SPELL_HIBERNATION, _hex_logic(SPELL_HIBERNATION, _foe_can_sleep) },</a>
<a name="ln419">    { SPELL_TELEPORT_OTHER, _hex_logic(SPELL_TELEPORT_OTHER,</a>
<a name="ln420">                                         _foe_not_teleporting) },</a>
<a name="ln421">    { SPELL_DIMENSION_ANCHOR, _hex_logic(SPELL_DIMENSION_ANCHOR, nullptr, 6)},</a>
<a name="ln422">    { SPELL_AGONY_RANGE, _hex_logic(SPELL_AGONY_RANGE, [](const monster &amp;caster) {</a>
<a name="ln423">            return _torment_vulnerable(caster.get_foe());</a>
<a name="ln424">        }, 6)</a>
<a name="ln425">    },</a>
<a name="ln426">    { SPELL_STRIP_RESISTANCE,</a>
<a name="ln427">        _hex_logic(SPELL_STRIP_RESISTANCE, _foe_not_mr_vulnerable, 6)</a>
<a name="ln428">    },</a>
<a name="ln429">    { SPELL_SENTINEL_MARK, _hex_logic(SPELL_SENTINEL_MARK, nullptr, 16) },</a>
<a name="ln430">    { SPELL_SAP_MAGIC, {</a>
<a name="ln431">        _always_worthwhile, _fire_simple_beam, _zap_setup(SPELL_SAP_MAGIC),</a>
<a name="ln432">        MSPELL_LOGIC_NONE, 10,</a>
<a name="ln433">    } },</a>
<a name="ln434">    { SPELL_DRAIN_MAGIC, _hex_logic(SPELL_DRAIN_MAGIC, nullptr, 6) },</a>
<a name="ln435">    { SPELL_VIRULENCE, _hex_logic(SPELL_VIRULENCE, [](const monster &amp;caster) {</a>
<a name="ln436">        return caster.get_foe()-&gt;res_poison(false) &lt; 3;</a>
<a name="ln437">    }, 6) },</a>
<a name="ln438">    { SPELL_RING_OF_THUNDER, { _should_selfench(ENCH_RING_OF_THUNDER),</a>
<a name="ln439">        [](monster &amp;caster, mon_spell_slot, bolt&amp;) {</a>
<a name="ln440">            caster.add_ench(ENCH_RING_OF_THUNDER);</a>
<a name="ln441">    } } },</a>
<a name="ln442">    { SPELL_GRASPING_ROOTS, {</a>
<a name="ln443">        [](const monster &amp;caster)</a>
<a name="ln444">        {</a>
<a name="ln445">            const actor* foe = caster.get_foe();</a>
<a name="ln446">            return foe &amp;&amp; caster.can_constrict(foe, false);</a>
<a name="ln447">        }, _cast_grasping_roots, } },</a>
<a name="ln448">    { SPELL_ABJURATION, {</a>
<a name="ln449">        _mons_will_abjure,</a>
<a name="ln450">        [] (const monster &amp;caster, mon_spell_slot /*slot*/, bolt&amp; /*beem*/) {</a>
<a name="ln451">            _monster_abjuration(caster, true);</a>
<a name="ln452">        }, nullptr, MSPELL_LOGIC_NONE, 20, } },</a>
<a name="ln453">};</a>
<a name="ln454"> </a>
<a name="ln455">/// Is the 'monster' actually a proxy for the player?</a>
<a name="ln456">static bool _caster_is_player_shadow(const monster &amp;mons)</a>
<a name="ln457">{</a>
<a name="ln458">    return mons.type == MONS_PLAYER_SHADOW;</a>
<a name="ln459">}</a>
<a name="ln460"> </a>
<a name="ln461">/// Create the appropriate casting logic for a simple conjuration.</a>
<a name="ln462">static mons_spell_logic _conjuration_logic(spell_type spell)</a>
<a name="ln463">{</a>
<a name="ln464">    return { _always_worthwhile, _fire_simple_beam, _zap_setup(spell), };</a>
<a name="ln465">}</a>
<a name="ln466"> </a>
<a name="ln467">/**</a>
<a name="ln468"> * Create the appropriate casting logic for a simple mr-checking hex.</a>
<a name="ln469"> *</a>
<a name="ln470"> * @param spell             The hex in question; e.g. SPELL_CORONA.</a>
<a name="ln471"> * @param extra_logic       An additional pre-casting condition, beyond the</a>
<a name="ln472"> *                          normal hex logic.</a>
<a name="ln473"> * @param power_hd_factor   If nonzero, how much spellpower the spell has per</a>
<a name="ln474"> *                          caster HD.</a>
<a name="ln475"> */</a>
<a name="ln476">static mons_spell_logic _hex_logic(spell_type spell,</a>
<a name="ln477">                                   function&lt;bool(const monster&amp;)&gt; extra_logic,</a>
<a name="ln478">                                   int power_hd_factor)</a>
<a name="ln479">{</a>
<a name="ln480">    function&lt;bool(const monster&amp;)&gt; worthwhile = nullptr;</a>
<a name="ln481">    if (!extra_logic)</a>
<a name="ln482">        worthwhile = _setup_hex_check(spell);</a>
<a name="ln483">    else</a>
<a name="ln484">    {</a>
<a name="ln485">        worthwhile = [spell, extra_logic](const monster&amp; caster) {</a>
<a name="ln486">            return _worth_hexing(caster, spell) &amp;&amp; extra_logic(caster);</a>
<a name="ln487">        };</a>
<a name="ln488">    }</a>
<a name="ln489">    return { worthwhile, _fire_simple_beam, _zap_setup(spell),</a>
<a name="ln490">             MSPELL_LOGIC_NONE, power_hd_factor * ENCH_POW_FACTOR };</a>
<a name="ln491">}</a>
<a name="ln492"> </a>
<a name="ln493">/**</a>
<a name="ln494"> * Take the given beam and fire it, handling screen-refresh issues in the</a>
<a name="ln495"> * process.</a>
<a name="ln496"> *</a>
<a name="ln497"> * @param caster    The monster casting the spell that produced the beam.</a>
<a name="ln498"> * @param pbolt     A pre-setup &amp; aimed spell beam. (For e.g. FIREBALL.)</a>
<a name="ln499"> */</a>
<a name="ln500">static void _fire_simple_beam(monster &amp;/*caster*/, mon_spell_slot, bolt &amp;pbolt)</a>
<a name="ln501">{</a>
<a name="ln502">    // If a monster just came into view and immediately cast a spell,</a>
<a name="ln503">    // we need to refresh the screen before drawing the beam.</a>
<a name="ln504">    viewwindow();</a>
<a name="ln505">    pbolt.fire();</a>
<a name="ln506">}</a>
<a name="ln507"> </a>
<a name="ln508">/**</a>
<a name="ln509"> * Take the given explosion and fire it, handling screen-refresh issues in the</a>
<a name="ln510"> * process.</a>
<a name="ln511"> *</a>
<a name="ln512"> * @param caster    The monster casting the spell that produced the beam.</a>
<a name="ln513"> * @param pbolt     A pre-setup &amp; aimed spell beam. (For e.g. FIRE_STORM.)</a>
<a name="ln514"> */</a>
<a name="ln515">static void _fire_direct_explosion(monster &amp;caster, mon_spell_slot, bolt &amp;pbolt)</a>
<a name="ln516">{</a>
<a name="ln517">    // If a monster just came into view and immediately cast a spell,</a>
<a name="ln518">    // we need to refresh the screen before drawing the beam.</a>
<a name="ln519">    viewwindow();</a>
<a name="ln520">    const actor* foe = caster.get_foe();</a>
<a name="ln521">    const bool need_more = foe &amp;&amp; (foe-&gt;is_player()</a>
<a name="ln522">                                   || you.see_cell(foe-&gt;pos()));</a>
<a name="ln523">    pbolt.in_explosion_phase = false;</a>
<a name="ln524">    pbolt.refine_for_explosion();</a>
<a name="ln525">    pbolt.explode(need_more);</a>
<a name="ln526">}</a>
<a name="ln527"> </a>
<a name="ln528">static bool _caster_sees_foe(const monster &amp;caster)</a>
<a name="ln529">{</a>
<a name="ln530">    const actor* foe = caster.get_foe();</a>
<a name="ln531">    return foe &amp;&amp; caster.can_see(*foe);</a>
<a name="ln532">}</a>
<a name="ln533"> </a>
<a name="ln534">static bool _foe_can_sleep(const monster &amp;caster)</a>
<a name="ln535">{</a>
<a name="ln536">    const actor* foe = caster.get_foe();</a>
<a name="ln537">    return foe &amp;&amp; foe-&gt;can_sleep();</a>
<a name="ln538">}</a>
<a name="ln539"> </a>
<a name="ln540">static bool _foe_not_teleporting(const monster &amp;caster)</a>
<a name="ln541">{</a>
<a name="ln542">    const actor* foe = caster.get_foe();</a>
<a name="ln543">    ASSERT(foe);</a>
<a name="ln544">    if (foe-&gt;is_player())</a>
<a name="ln545">        return !you.duration[DUR_TELEPORT];</a>
<a name="ln546">    return !foe-&gt;as_monster()-&gt;has_ench(ENCH_TP);</a>
<a name="ln547">}</a>
<a name="ln548"> </a>
<a name="ln549">static bool _foe_not_mr_vulnerable(const monster &amp;caster)</a>
<a name="ln550">{</a>
<a name="ln551">    const actor* foe = caster.get_foe();</a>
<a name="ln552">    ASSERT(foe);</a>
<a name="ln553">    if (foe-&gt;is_player())</a>
<a name="ln554">        return !you.duration[DUR_LOWERED_MR];</a>
<a name="ln555">    return !foe-&gt;as_monster()-&gt;has_ench(ENCH_LOWERED_MR);</a>
<a name="ln556">}</a>
<a name="ln557"> </a>
<a name="ln558">/**</a>
<a name="ln559"> * Build a function to set up a beam to buff the caster.</a>
<a name="ln560"> *</a>
<a name="ln561"> * @param flavour   The flavour to buff a caster with.</a>
<a name="ln562"> * @return          A function that sets up a beam to buff its caster with</a>
<a name="ln563"> *                  the given flavour.</a>
<a name="ln564"> */</a>
<a name="ln565">static function&lt;void(bolt&amp;, const monster&amp;, int)&gt;</a>
<a name="ln566">    _selfench_beam_setup(beam_type flavour)</a>
<a name="ln567">{</a>
<a name="ln568">    return [flavour](bolt &amp;beam, const monster &amp;caster, int)</a>
<a name="ln569">    {</a>
<a name="ln570">        beam.flavour = flavour;</a>
<a name="ln571">        if (!_caster_is_player_shadow(caster))</a>
<a name="ln572">            beam.target = caster.pos();</a>
<a name="ln573">    };</a>
<a name="ln574">}</a>
<a name="ln575"> </a>
<a name="ln576">/**</a>
<a name="ln577"> * Build a function that tests whether it's worth casting a buff spell that</a>
<a name="ln578"> * applies the given enchantment to the caster.</a>
<a name="ln579"> */</a>
<a name="ln580">static function&lt;bool(const monster&amp;)&gt; _should_selfench(enchant_type ench)</a>
<a name="ln581">{</a>
<a name="ln582">    return [ench](const monster &amp;caster)</a>
<a name="ln583">    {</a>
<a name="ln584">        // keep non-summoned pals with haste from spamming constantly</a>
<a name="ln585">        if (caster.friendly() &amp;&amp; !caster.get_foe() &amp;&amp; !caster.is_summoned())</a>
<a name="ln586">            return false;</a>
<a name="ln587">        return !caster.has_ench(ench);</a>
<a name="ln588">    };</a>
<a name="ln589">}</a>
<a name="ln590"> </a>
<a name="ln591">/**</a>
<a name="ln592"> * Build a function that sets up and targets a buffing beam at one of the</a>
<a name="ln593"> * caster's allies. If the function fails to find an ally, the beam will be</a>
<a name="ln594"> * targeted at an out-of-bounds tile to signal failure.</a>
<a name="ln595"> *</a>
<a name="ln596"> * @param flavour   The flavour to buff an ally with.</a>
<a name="ln597"> * @return          A function that sets up a single-target buff beam.</a>
<a name="ln598"> */</a>
<a name="ln599">static function&lt;void(bolt&amp;, const monster&amp;, int)&gt;</a>
<a name="ln600">    _buff_beam_setup(beam_type flavour)</a>
<a name="ln601">{</a>
<a name="ln602">    return [flavour](bolt &amp;beam, const monster &amp;caster, int)</a>
<a name="ln603">    {</a>
<a name="ln604">        beam.flavour = flavour;</a>
<a name="ln605">        const monster* target = _get_allied_target(caster, beam);</a>
<a name="ln606">        beam.target = target ? target-&gt;pos() : coord_def(GXM+1, GYM+1);</a>
<a name="ln607">    };</a>
<a name="ln608">}</a>
<a name="ln609"> </a>
<a name="ln610">/**</a>
<a name="ln611"> * Build a function to set up a beam with spl-to-zap.</a>
<a name="ln612"> *</a>
<a name="ln613"> * @param spell     The spell for which beams will be set up.</a>
<a name="ln614"> * @return          A function that sets up a beam to zap the given spell.</a>
<a name="ln615"> */</a>
<a name="ln616">static function&lt;void(bolt&amp;, const monster&amp;, int)&gt; _zap_setup(spell_type spell)</a>
<a name="ln617">{</a>
<a name="ln618">    return [spell](bolt &amp;beam, const monster &amp;, int power)</a>
<a name="ln619">    {</a>
<a name="ln620">        zappy(spell_to_zap(spell), power, true, beam);</a>
<a name="ln621">    };</a>
<a name="ln622">}</a>
<a name="ln623"> </a>
<a name="ln624">static void _setup_healing_beam(bolt &amp;beam, const monster &amp;caster)</a>
<a name="ln625">{</a>
<a name="ln626">    beam.damage   = dice_def(2, caster.spell_hd(SPELL_MINOR_HEALING) / 2);</a>
<a name="ln627">    beam.flavour  = BEAM_HEALING;</a>
<a name="ln628">}</a>
<a name="ln629"> </a>
<a name="ln630">static void _setup_minor_healing(bolt &amp;beam, const monster &amp;caster, int)</a>
<a name="ln631">{</a>
<a name="ln632">    _setup_healing_beam(beam, caster);</a>
<a name="ln633">    if (!_caster_is_player_shadow(caster))</a>
<a name="ln634">        beam.target = caster.pos();</a>
<a name="ln635">}</a>
<a name="ln636"> </a>
<a name="ln637">static void _setup_heal_other(bolt &amp;beam, const monster &amp;caster, int)</a>
<a name="ln638">{</a>
<a name="ln639">    _setup_healing_beam(beam, caster);</a>
<a name="ln640">    const monster* target = _get_allied_target(caster, beam);</a>
<a name="ln641">    beam.target = target ? target-&gt;pos() : coord_def(GXM+1, GYM+1);</a>
<a name="ln642">}</a>
<a name="ln643"> </a>
<a name="ln644">/**</a>
<a name="ln645"> * Build a function that sets up a fake beam for targeting special spells.</a>
<a name="ln646"> *</a>
<a name="ln647"> * @param targeter     A function that finds a target for the given spell.</a>
<a name="ln648"> *                      Expected to return an out-of-bounds coord on failure.</a>
<a name="ln649"> * @return              A function that initializes a fake targetting beam.</a>
<a name="ln650"> */</a>
<a name="ln651">static function&lt;void(bolt&amp;, const monster&amp;, int)&gt;</a>
<a name="ln652">    _target_beam_setup(function&lt;coord_def(const monster&amp;)&gt; targeter)</a>
<a name="ln653">{</a>
<a name="ln654">    return [targeter](bolt&amp; beam, const monster&amp; caster, int)</a>
<a name="ln655">    {</a>
<a name="ln656">        _setup_fake_beam(beam, caster);</a>
<a name="ln657">        // Your shadow keeps your targetting.</a>
<a name="ln658">        if (_caster_is_player_shadow(caster))</a>
<a name="ln659">            return;</a>
<a name="ln660">        beam.target = targeter(caster);</a>
<a name="ln661">        beam.aimed_at_spot = true;  // to get noise to work properly</a>
<a name="ln662">    };</a>
<a name="ln663">}</a>
<a name="ln664"> </a>
<a name="ln665">/// Returns true if a message referring to the player's legs makes sense.</a>
<a name="ln666">static bool _legs_msg_applicable()</a>
<a name="ln667">{</a>
<a name="ln668">    return you.species != SP_NAGA &amp;&amp; !you.fishtail;</a>
<a name="ln669">}</a>
<a name="ln670"> </a>
<a name="ln671">// Monster spell of uselessness, just prints a message.</a>
<a name="ln672">// This spell exists so that some monsters with really strong</a>
<a name="ln673">// spells (ie orc priest) can be toned down a bit. -- bwr</a>
<a name="ln674">static void _cast_cantrip(monster &amp;mons, mon_spell_slot slot, bolt&amp; pbolt)</a>
<a name="ln675">{</a>
<a name="ln676">    // only messaging; don't bother if you can't see anything anyway.</a>
<a name="ln677">    if (!you.see_cell(mons.pos()))</a>
<a name="ln678">        return;</a>
<a name="ln679"> </a>
<a name="ln680">    const bool friendly  = mons.friendly();</a>
<a name="ln681">    const bool buff_only = !friendly &amp;&amp; is_sanctuary(you.pos());</a>
<a name="ln682">    const msg_channel_type channel = (friendly) ? MSGCH_FRIEND_ENCHANT</a>
<a name="ln683">                                                : MSGCH_MONSTER_ENCHANT;</a>
<a name="ln684"> </a>
<a name="ln685">    if (mons.type != MONS_GASTRONOK)</a>
<a name="ln686">    {</a>
<a name="ln687">        const char* msgs[] =</a>
<a name="ln688">        {</a>
<a name="ln689">            &quot; casts a cantrip, but nothing happens.&quot;,</a>
<a name="ln690">            &quot; begins to cast a cantrip, but forgets the words!&quot;,</a>
<a name="ln691">            &quot; miscasts a cantrip.&quot;,</a>
<a name="ln692">            &quot; looks braver for a moment.&quot;,</a>
<a name="ln693">            &quot; looks encouraged for a moment.&quot;,</a>
<a name="ln694">            &quot; looks satisfied for a moment.&quot;,</a>
<a name="ln695">        };</a>
<a name="ln696"> </a>
<a name="ln697">        simple_monster_message(mons, RANDOM_ELEMENT(msgs), channel);</a>
<a name="ln698">        return;</a>
<a name="ln699">    }</a>
<a name="ln700"> </a>
<a name="ln701">    bool has_mon_foe = !invalid_monster_index(mons.foe);</a>
<a name="ln702">    if (buff_only</a>
<a name="ln703">        || crawl_state.game_is_arena() &amp;&amp; !has_mon_foe</a>
<a name="ln704">        || friendly &amp;&amp; !has_mon_foe</a>
<a name="ln705">        || coinflip())</a>
<a name="ln706">    {</a>
<a name="ln707">        string slugform = getSpeakString(&quot;gastronok_self_buff&quot;);</a>
<a name="ln708">        if (!slugform.empty())</a>
<a name="ln709">        {</a>
<a name="ln710">            slugform = replace_all(slugform, &quot;@The_monster@&quot;,</a>
<a name="ln711">                                   mons.name(DESC_THE));</a>
<a name="ln712">            mprf(channel, &quot;%s&quot;, slugform.c_str());</a>
<a name="ln713">        }</a>
<a name="ln714">    }</a>
<a name="ln715">    else if (!friendly &amp;&amp; !has_mon_foe)</a>
<a name="ln716">    {</a>
<a name="ln717">        mons_cast_noise(&amp;mons, pbolt, slot.spell, slot.flags);</a>
<a name="ln718"> </a>
<a name="ln719">        // &quot;Enchant&quot; the player.</a>
<a name="ln720">        const string slugform = getSpeakString(&quot;gastronok_debuff&quot;);</a>
<a name="ln721">        if (!slugform.empty()</a>
<a name="ln722">            &amp;&amp; (slugform.find(&quot;legs&quot;) == string::npos</a>
<a name="ln723">                || _legs_msg_applicable()))</a>
<a name="ln724">        {</a>
<a name="ln725">            mpr(slugform);</a>
<a name="ln726">        }</a>
<a name="ln727">    }</a>
<a name="ln728">    else</a>
<a name="ln729">    {</a>
<a name="ln730">        // &quot;Enchant&quot; another monster.</a>
<a name="ln731">        string slugform = getSpeakString(&quot;gastronok_other_buff&quot;);</a>
<a name="ln732">        if (!slugform.empty())</a>
<a name="ln733">        {</a>
<a name="ln734">            slugform = replace_all(slugform, &quot;@The_monster@&quot;,</a>
<a name="ln735">                                   mons.get_foe()-&gt;name(DESC_THE));</a>
<a name="ln736">            mprf(channel, &quot;%s&quot;, slugform.c_str());</a>
<a name="ln737">        }</a>
<a name="ln738">    }</a>
<a name="ln739">}</a>
<a name="ln740"> </a>
<a name="ln741">static void _cast_injury_mirror(monster &amp;mons, mon_spell_slot /*slot*/, bolt&amp;)</a>
<a name="ln742">{</a>
<a name="ln743">    const string msg</a>
<a name="ln744">        = make_stringf(&quot; offers %s to %s, and fills with unholy energy.&quot;,</a>
<a name="ln745">                       mons.pronoun(PRONOUN_REFLEXIVE).c_str(),</a>
<a name="ln746">                       god_name(mons.god).c_str());</a>
<a name="ln747">    simple_monster_message(mons, msg.c_str(), MSGCH_MONSTER_SPELL);</a>
<a name="ln748">    mons.add_ench(mon_enchant(ENCH_MIRROR_DAMAGE, 0, &amp;mons,</a>
<a name="ln749">                              random_range(7, 9) * BASELINE_DELAY));</a>
<a name="ln750">    mons.props[MIRROR_RECAST_KEY].get_int()</a>
<a name="ln751">        = you.elapsed_time + 150 + random2(60);</a>
<a name="ln752">}</a>
<a name="ln753"> </a>
<a name="ln754">static void _cast_smiting(monster &amp;caster, mon_spell_slot slot, bolt&amp;)</a>
<a name="ln755">{</a>
<a name="ln756">    const god_type god = _find_god(caster, slot.flags);</a>
<a name="ln757">    actor* foe = caster.get_foe();</a>
<a name="ln758">    ASSERT(foe);</a>
<a name="ln759"> </a>
<a name="ln760">    if (foe-&gt;is_player())</a>
<a name="ln761">        mprf(&quot;%s smites you!&quot;, _god_name(god).c_str());</a>
<a name="ln762">    else</a>
<a name="ln763">        simple_monster_message(*foe-&gt;as_monster(), &quot; is smitten.&quot;);</a>
<a name="ln764"> </a>
<a name="ln765">    foe-&gt;hurt(&amp;caster, 7 + random2avg(11, 2), BEAM_MISSILE, KILLED_BY_BEAM,</a>
<a name="ln766">              &quot;&quot;, &quot;by divine providence&quot;);</a>
<a name="ln767">}</a>
<a name="ln768"> </a>
<a name="ln769">static void _cast_grasping_roots(monster &amp;caster, mon_spell_slot, bolt&amp;)</a>
<a name="ln770">{</a>
<a name="ln771">    actor* foe = caster.get_foe();</a>
<a name="ln772">    ASSERT(foe);</a>
<a name="ln773"> </a>
<a name="ln774">    const int turns = 4 + random2avg(div_rand_round(</a>
<a name="ln775">                mons_spellpower(caster, SPELL_GRASPING_ROOTS), 10), 2);</a>
<a name="ln776">    dprf(&quot;Grasping roots turns: %d&quot;, turns);</a>
<a name="ln777">    mpr(&quot;Roots burst forth from the earth!&quot;);</a>
<a name="ln778">    if (foe-&gt;is_player())</a>
<a name="ln779">    {</a>
<a name="ln780">        you.increase_duration(DUR_GRASPING_ROOTS, turns);</a>
<a name="ln781">        caster.start_constricting(you);</a>
<a name="ln782">        mprf(MSGCH_WARN, &quot;The grasping roots grab you!&quot;);</a>
<a name="ln783">    }</a>
<a name="ln784">    else</a>
<a name="ln785">    {</a>
<a name="ln786">        foe-&gt;as_monster()-&gt;add_ench(mon_enchant(ENCH_GRASPING_ROOTS, 0, &amp;caster,</a>
<a name="ln787">                    turns * BASELINE_DELAY));</a>
<a name="ln788">    }</a>
<a name="ln789">}</a>
<a name="ln790"> </a>
<a name="ln791">/// Is the given full-LOS attack spell worth casting for the given monster?</a>
<a name="ln792">static bool _los_spell_worthwhile(const monster &amp;mons, spell_type spell)</a>
<a name="ln793">{</a>
<a name="ln794">    return trace_los_attack_spell(spell, mons_spellpower(mons, spell), &amp;mons)</a>
<a name="ln795">           == spret::success;</a>
<a name="ln796">}</a>
<a name="ln797"> </a>
<a name="ln798">/// Set up a fake beam, for noise-generating purposes (?)</a>
<a name="ln799">static void _setup_fake_beam(bolt&amp; beam, const monster&amp;, int)</a>
<a name="ln800">{</a>
<a name="ln801">    beam.flavour  = BEAM_DEVASTATION;</a>
<a name="ln802">    beam.pierce   = true;</a>
<a name="ln803">    // Doesn't take distance into account, but this is just a tracer so</a>
<a name="ln804">    // we'll ignore that. We need some damage on the tracer so the monster</a>
<a name="ln805">    // doesn't think the spell is useless against other monsters.</a>
<a name="ln806">    beam.damage   = CONVENIENT_NONZERO_DAMAGE;</a>
<a name="ln807">    beam.range    = LOS_RADIUS;</a>
<a name="ln808">}</a>
<a name="ln809"> </a>
<a name="ln810">/**</a>
<a name="ln811"> * Create a summoned monster.</a>
<a name="ln812"> *</a>
<a name="ln813"> * @param summoner      The monster doing the summoning.</a>
<a name="ln814"> * @param mtyp          The type of monster to summon.</a>
<a name="ln815"> * @param dur           The duration for which the monster should last.</a>
<a name="ln816"> *                      Not in aut or turns; nonlinear. Sorry!</a>
<a name="ln817"> * @param slot          The spell &amp; slot flags.</a>
<a name="ln818"> * @return              The summoned creature, if any.</a>
<a name="ln819"> */</a>
<a name="ln820"> </a>
<a name="ln821">static monster* _summon(const monster &amp;summoner, monster_type mtyp, int dur,</a>
<a name="ln822">                        mon_spell_slot slot)</a>
<a name="ln823">{</a>
<a name="ln824">    const god_type god = _find_god(summoner, slot.flags);</a>
<a name="ln825">    return create_monster(</a>
<a name="ln826">            mgen_data(mtyp, SAME_ATTITUDE((&amp;summoner)), summoner.pos(),</a>
<a name="ln827">                      summoner.foe)</a>
<a name="ln828">            .set_summoned(&amp;summoner, dur, slot.spell, god));</a>
<a name="ln829">}</a>
<a name="ln830"> </a>
<a name="ln831">void init_mons_spells()</a>
<a name="ln832">{</a>
<a name="ln833">    monster fake_mon;</a>
<a name="ln834">    fake_mon.type       = MONS_BLACK_DRACONIAN;</a>
<a name="ln835">    fake_mon.hit_points = 1;</a>
<a name="ln836">    fake_mon.mid = MID_NOBODY; // used indirectly, through _mon_special_name</a>
<a name="ln837"> </a>
<a name="ln838">    bolt pbolt;</a>
<a name="ln839"> </a>
<a name="ln840">    for (int i = 0; i &lt; NUM_SPELLS; i++)</a>
<a name="ln841">    {</a>
<a name="ln842">        spell_type spell = (spell_type) i;</a>
<a name="ln843"> </a>
<a name="ln844">        _valid_mon_spells[i] = false;</a>
<a name="ln845"> </a>
<a name="ln846">        if (!is_valid_spell(spell))</a>
<a name="ln847">            continue;</a>
<a name="ln848"> </a>
<a name="ln849">        if (setup_mons_cast(&amp;fake_mon, pbolt, spell, false, true))</a>
<a name="ln850">            _valid_mon_spells[i] = true;</a>
<a name="ln851">    }</a>
<a name="ln852">}</a>
<a name="ln853"> </a>
<a name="ln854">bool is_valid_mon_spell(spell_type spell)</a>
<a name="ln855">{</a>
<a name="ln856">    if (spell &lt; 0 || spell &gt;= NUM_SPELLS)</a>
<a name="ln857">        return false;</a>
<a name="ln858"> </a>
<a name="ln859">    return _valid_mon_spells[spell];</a>
<a name="ln860">}</a>
<a name="ln861"> </a>
<a name="ln862">/// Is the current spell being cast via player wizmode &amp;z by a dummy mons?</a>
<a name="ln863">static bool _is_wiz_cast()</a>
<a name="ln864">{</a>
<a name="ln865">#ifdef WIZARD</a>
<a name="ln866">    // iffy logic but might be right enough</a>
<a name="ln867">    return crawl_state.prev_cmd == CMD_WIZARD;</a>
<a name="ln868">#else</a>
<a name="ln869">    return false;</a>
<a name="ln870">#endif</a>
<a name="ln871">}</a>
<a name="ln872"> </a>
<a name="ln873">static bool _flavour_benefits_monster(beam_type flavour, monster&amp; monster)</a>
<a name="ln874">{</a>
<a name="ln875">    switch (flavour)</a>
<a name="ln876">    {</a>
<a name="ln877">    case BEAM_HASTE:</a>
<a name="ln878">        return !monster.has_ench(ENCH_HASTE);</a>
<a name="ln879"> </a>
<a name="ln880">    case BEAM_MIGHT:</a>
<a name="ln881">        return !monster.has_ench(ENCH_MIGHT);</a>
<a name="ln882"> </a>
<a name="ln883">    case BEAM_INVISIBILITY:</a>
<a name="ln884">        return !monster.has_ench(ENCH_INVIS);</a>
<a name="ln885"> </a>
<a name="ln886">    case BEAM_HEALING:</a>
<a name="ln887">        return monster.hit_points != monster.max_hit_points;</a>
<a name="ln888"> </a>
<a name="ln889">    case BEAM_AGILITY:</a>
<a name="ln890">        return !monster.has_ench(ENCH_AGILE);</a>
<a name="ln891"> </a>
<a name="ln892">    case BEAM_RESISTANCE:</a>
<a name="ln893">        return !monster.has_ench(ENCH_RESISTANCE);</a>
<a name="ln894"> </a>
<a name="ln895">    default:</a>
<a name="ln896">        return false;</a>
<a name="ln897">    }</a>
<a name="ln898">}</a>
<a name="ln899"> </a>
<a name="ln900">/**</a>
<a name="ln901"> * Will the given monster consider buffing the given target? (Are they close</a>
<a name="ln902"> * enough in type, genus, attitude, etc?)</a>
<a name="ln903"> *</a>
<a name="ln904"> * @param caster    The monster casting a targeted buff spell.</a>
<a name="ln905"> * @param targ      The monster to be buffed.</a>
<a name="ln906"> * @return          Whether the monsters are similar enough.</a>
<a name="ln907"> */</a>
<a name="ln908">static bool _monster_will_buff(const monster &amp;caster, const monster &amp;targ)</a>
<a name="ln909">{</a>
<a name="ln910">    if (mons_is_firewood(targ))</a>
<a name="ln911">        return false;</a>
<a name="ln912"> </a>
<a name="ln913">    if (!mons_aligned(&amp;targ, &amp;caster))</a>
<a name="ln914">        return false;</a>
<a name="ln915"> </a>
<a name="ln916">    // don't buff only temporarily-aligned pals (charmed, hexed)</a>
<a name="ln917">    if (!mons_atts_aligned(caster.temp_attitude(), targ.real_attitude()))</a>
<a name="ln918">        return false;</a>
<a name="ln919"> </a>
<a name="ln920">    if (caster.type == MONS_IRONBRAND_CONVOKER || mons_enslaved_soul(caster))</a>
<a name="ln921">        return true; // will buff any ally</a>
<a name="ln922"> </a>
<a name="ln923">    if (targ.is_holy() &amp;&amp; caster.is_holy())</a>
<a name="ln924">        return true;</a>
<a name="ln925"> </a>
<a name="ln926">    const monster_type caster_genus = mons_genus(caster.type);</a>
<a name="ln927">    return mons_genus(targ.type) == caster_genus</a>
<a name="ln928">           || mons_genus(targ.base_monster) == caster_genus;</a>
<a name="ln929">}</a>
<a name="ln930"> </a>
<a name="ln931">/// Find an allied monster to cast a beneficial beam spell at.</a>
<a name="ln932">static monster* _get_allied_target(const monster &amp;caster, bolt &amp;tracer)</a>
<a name="ln933">{</a>
<a name="ln934">    monster* selected_target = nullptr;</a>
<a name="ln935">    int min_distance = tracer.range;</a>
<a name="ln936"> </a>
<a name="ln937">    for (monster_near_iterator targ(&amp;caster, LOS_NO_TRANS); targ; ++targ)</a>
<a name="ln938">    {</a>
<a name="ln939">        if (*targ == &amp;caster</a>
<a name="ln940">            || !_monster_will_buff(caster, **targ)</a>
<a name="ln941">            || !_flavour_benefits_monster(tracer.flavour, **targ))</a>
<a name="ln942">        {</a>
<a name="ln943">            continue;</a>
<a name="ln944">        }</a>
<a name="ln945"> </a>
<a name="ln946">        // prefer the closest ally we can find (why?)</a>
<a name="ln947">        const int targ_distance = grid_distance(targ-&gt;pos(), caster.pos());</a>
<a name="ln948">        if (targ_distance &lt; min_distance)</a>
<a name="ln949">        {</a>
<a name="ln950">            // Make sure we won't hit someone other than we're aiming at.</a>
<a name="ln951">            tracer.target = targ-&gt;pos();</a>
<a name="ln952">            fire_tracer(&amp;caster, tracer);</a>
<a name="ln953">            if (!mons_should_fire(tracer)</a>
<a name="ln954">                || tracer.path_taken.back() != tracer.target)</a>
<a name="ln955">            {</a>
<a name="ln956">                continue;</a>
<a name="ln957">            }</a>
<a name="ln958"> </a>
<a name="ln959">            min_distance = targ_distance;</a>
<a name="ln960">            selected_target = *targ;</a>
<a name="ln961">        }</a>
<a name="ln962">    }</a>
<a name="ln963"> </a>
<a name="ln964">    return selected_target;</a>
<a name="ln965">}</a>
<a name="ln966"> </a>
<a name="ln967">// Find an ally of the target to cast a hex at.</a>
<a name="ln968">// Note that this deliberately does not target the player.</a>
<a name="ln969">static bool _set_hex_target(monster* caster, bolt&amp; pbolt)</a>
<a name="ln970">{</a>
<a name="ln971">    monster* selected_target = nullptr;</a>
<a name="ln972">    int min_distance = INT_MAX;</a>
<a name="ln973"> </a>
<a name="ln974">    if (!caster-&gt;get_foe())</a>
<a name="ln975">        return false;</a>
<a name="ln976"> </a>
<a name="ln977">    const actor *foe = caster-&gt;get_foe();</a>
<a name="ln978"> </a>
<a name="ln979">    for (monster_near_iterator targ(caster, LOS_NO_TRANS); targ; ++targ)</a>
<a name="ln980">    {</a>
<a name="ln981">        if (*targ == caster)</a>
<a name="ln982">            continue;</a>
<a name="ln983"> </a>
<a name="ln984">        const int targ_distance = grid_distance(targ-&gt;pos(), foe-&gt;pos());</a>
<a name="ln985"> </a>
<a name="ln986">        bool got_target = false;</a>
<a name="ln987"> </a>
<a name="ln988">        if (mons_aligned(*targ, foe)</a>
<a name="ln989">            &amp;&amp; !targ-&gt;has_ench(ENCH_CHARM)</a>
<a name="ln990">            &amp;&amp; !targ-&gt;has_ench(ENCH_HEXED)</a>
<a name="ln991">            &amp;&amp; !mons_is_firewood(**targ)</a>
<a name="ln992">            &amp;&amp; !_flavour_benefits_monster(pbolt.flavour, **targ))</a>
<a name="ln993">        {</a>
<a name="ln994">            got_target = true;</a>
<a name="ln995">        }</a>
<a name="ln996"> </a>
<a name="ln997">        if (got_target &amp;&amp; targ_distance &lt; min_distance</a>
<a name="ln998">            &amp;&amp; targ_distance &lt; pbolt.range)</a>
<a name="ln999">        {</a>
<a name="ln1000">            // Make sure we won't hit an invalid target with this aim.</a>
<a name="ln1001">            pbolt.target = targ-&gt;pos();</a>
<a name="ln1002">            fire_tracer(caster, pbolt);</a>
<a name="ln1003">            if (!mons_should_fire(pbolt)</a>
<a name="ln1004">                || pbolt.path_taken.back() != pbolt.target)</a>
<a name="ln1005">            {</a>
<a name="ln1006">                continue;</a>
<a name="ln1007">            }</a>
<a name="ln1008"> </a>
<a name="ln1009">            min_distance = targ_distance;</a>
<a name="ln1010">            selected_target = *targ;</a>
<a name="ln1011">        }</a>
<a name="ln1012">    }</a>
<a name="ln1013"> </a>
<a name="ln1014">    if (selected_target)</a>
<a name="ln1015">    {</a>
<a name="ln1016">        pbolt.target = selected_target-&gt;pos();</a>
<a name="ln1017">        return true;</a>
<a name="ln1018">    }</a>
<a name="ln1019"> </a>
<a name="ln1020">    // Didn't find a target.</a>
<a name="ln1021">    return false;</a>
<a name="ln1022">}</a>
<a name="ln1023"> </a>
<a name="ln1024">/**</a>
<a name="ln1025"> * What value do monsters multiply their hd with to get spellpower, for the</a>
<a name="ln1026"> * given spell?</a>
<a name="ln1027"> *</a>
<a name="ln1028"> * XXX: everything could be trivially exported to data.</a>
<a name="ln1029"> *</a>
<a name="ln1030"> * @param spell     The spell in question.</a>
<a name="ln1031"> * @return          A multiplier to HD for spellpower.</a>
<a name="ln1032"> *                  Value may exceed 200.</a>
<a name="ln1033"> */</a>
<a name="ln1034">static int _mons_power_hd_factor(spell_type spell)</a>
<a name="ln1035">{</a>
<a name="ln1036">    const mons_spell_logic* logic = map_find(spell_to_logic, spell);</a>
<a name="ln1037">    if (logic &amp;&amp; logic-&gt;power_hd_factor)</a>
<a name="ln1038">        return logic-&gt;power_hd_factor;</a>
<a name="ln1039"> </a>
<a name="ln1040">    switch (spell)</a>
<a name="ln1041">    {</a>
<a name="ln1042">        case SPELL_CONFUSION_GAZE:</a>
<a name="ln1043">            return 8 * ENCH_POW_FACTOR;</a>
<a name="ln1044"> </a>
<a name="ln1045">        case SPELL_CAUSE_FEAR:</a>
<a name="ln1046">            return 18 * ENCH_POW_FACTOR;</a>
<a name="ln1047"> </a>
<a name="ln1048">        case SPELL_MESMERISE:</a>
<a name="ln1049">            return 10 * ENCH_POW_FACTOR;</a>
<a name="ln1050"> </a>
<a name="ln1051">        case SPELL_SIREN_SONG:</a>
<a name="ln1052">        case SPELL_AVATAR_SONG:</a>
<a name="ln1053">            return 9 * ENCH_POW_FACTOR;</a>
<a name="ln1054"> </a>
<a name="ln1055">        case SPELL_MASS_CONFUSION:</a>
<a name="ln1056">            return 8 * ENCH_POW_FACTOR;</a>
<a name="ln1057"> </a>
<a name="ln1058">        case SPELL_OLGREBS_TOXIC_RADIANCE:</a>
<a name="ln1059">            return 8;</a>
<a name="ln1060"> </a>
<a name="ln1061">        case SPELL_MONSTROUS_MENAGERIE:</a>
<a name="ln1062">        case SPELL_BATTLESPHERE:</a>
<a name="ln1063">        case SPELL_SPECTRAL_WEAPON:</a>
<a name="ln1064">        case SPELL_IGNITE_POISON:</a>
<a name="ln1065">        case SPELL_IOOD:</a>
<a name="ln1066">            return 6;</a>
<a name="ln1067"> </a>
<a name="ln1068">        case SPELL_SUMMON_DRAGON:</a>
<a name="ln1069">        case SPELL_SUMMON_HYDRA:</a>
<a name="ln1070">            return 5;</a>
<a name="ln1071"> </a>
<a name="ln1072">        case SPELL_CHAIN_LIGHTNING:</a>
<a name="ln1073">        case SPELL_CHAIN_OF_CHAOS:</a>
<a name="ln1074">            return 4;</a>
<a name="ln1075"> </a>
<a name="ln1076">        default:</a>
<a name="ln1077">            return 12;</a>
<a name="ln1078">    }</a>
<a name="ln1079">}</a>
<a name="ln1080"> </a>
<a name="ln1081"> </a>
<a name="ln1082">/**</a>
<a name="ln1083"> * What spellpower does a monster with the given spell_hd cast the given spell</a>
<a name="ln1084"> * at?</a>
<a name="ln1085"> *</a>
<a name="ln1086"> * @param spell     The spell in question.</a>
<a name="ln1087"> * @param hd        The spell_hd of the given monster.</a>
<a name="ln1088"> * @return          A spellpower value for the spell.</a>
<a name="ln1089"> */</a>
<a name="ln1090">int mons_power_for_hd(spell_type spell, int hd)</a>
<a name="ln1091">{</a>
<a name="ln1092">    const int power = hd * _mons_power_hd_factor(spell);</a>
<a name="ln1093">    if (spell == SPELL_PAIN)</a>
<a name="ln1094">        return max(50 * ENCH_POW_FACTOR, power);</a>
<a name="ln1095">    return power;</a>
<a name="ln1096">}</a>
<a name="ln1097"> </a>
<a name="ln1098">/**</a>
<a name="ln1099"> * What power does the given monster cast the given spell with?</a>
<a name="ln1100"> *</a>
<a name="ln1101"> * @param spell     The spell in question.</a>
<a name="ln1102"> * @param mons      The monster in question.</a>
<a name="ln1103"> * @return          A spellpower value for the spell.</a>
<a name="ln1104"> *                  May vary from call to call for certain weird spells.</a>
<a name="ln1105"> */</a>
<a name="ln1106">int mons_spellpower(const monster &amp;mons, spell_type spell)</a>
<a name="ln1107">{</a>
<a name="ln1108">    return mons_power_for_hd(spell, mons.spell_hd(spell));</a>
<a name="ln1109">}</a>
<a name="ln1110"> </a>
<a name="ln1111">/**</a>
<a name="ln1112"> * What power does the given monster cast the given enchantment with?</a>
<a name="ln1113"> *</a>
<a name="ln1114"> * @param spell     The spell in question.</a>
<a name="ln1115"> * @param mons      The monster in question.</a>
<a name="ln1116"> * @param cap       The maximum power of the spell.</a>
<a name="ln1117"> * @return          A spellpower value for the spell, with ENCH_POW_FACTOR</a>
<a name="ln1118"> *                  removed &amp; capped at maximum spellpower.</a>
<a name="ln1119"> */</a>
<a name="ln1120">static int _ench_power(spell_type spell, const monster &amp;mons)</a>
<a name="ln1121">{</a>
<a name="ln1122">    const int cap = 200;</a>
<a name="ln1123">    return min(cap, mons_spellpower(mons, spell) / ENCH_POW_FACTOR);</a>
<a name="ln1124">}</a>
<a name="ln1125"> </a>
<a name="ln1126">static int _mons_spell_range(const monster &amp;mons, spell_type spell)</a>
<a name="ln1127">{</a>
<a name="ln1128">    return mons_spell_range_for_hd(spell, mons.spell_hd());</a>
<a name="ln1129">}</a>
<a name="ln1130"> </a>
<a name="ln1131">/**</a>
<a name="ln1132"> * How much range does a monster of the given spell HD have with the given</a>
<a name="ln1133"> * spell?</a>
<a name="ln1134"> *</a>
<a name="ln1135"> * @param spell     The spell in question.</a>
<a name="ln1136"> * @param hd        The monster's effective HD for spellcasting purposes.</a>
<a name="ln1137"> * @return          -1 if the spell has an undefined range; else its range.</a>
<a name="ln1138"> */</a>
<a name="ln1139">int mons_spell_range_for_hd(spell_type spell, int hd)</a>
<a name="ln1140">{</a>
<a name="ln1141">    switch (spell)</a>
<a name="ln1142">    {</a>
<a name="ln1143">        case SPELL_FLAME_TONGUE:</a>
<a name="ln1144">            // HD:1 monsters would get range 2, HD:2 -- 3, other 4, let's</a>
<a name="ln1145">            // use the mighty Throw Flame for big ranges.</a>
<a name="ln1146">            return min(2, hd);</a>
<a name="ln1147">        default:</a>
<a name="ln1148">            break;</a>
<a name="ln1149">    }</a>
<a name="ln1150"> </a>
<a name="ln1151">    const int power = mons_power_for_hd(spell, hd);</a>
<a name="ln1152">    return spell_range(spell, power, false);</a>
<a name="ln1153">}</a>
<a name="ln1154"> </a>
<a name="ln1155">/**</a>
<a name="ln1156"> * What god is responsible for a spell cast by the given monster with the</a>
<a name="ln1157"> * given flags?</a>
<a name="ln1158"> *</a>
<a name="ln1159"> * Relevant for Smite messages &amp; summons, sometimes.</a>
<a name="ln1160"> *</a>
<a name="ln1161"> * @param mons      The monster casting the spell.</a>
<a name="ln1162"> * @param flags     The slot flags;</a>
<a name="ln1163"> *                  e.g. MON_SPELL_NATURAL | MON_SPELL_NO_SILENT.</a>
<a name="ln1164"> * @return          The god that is responsible for the spell.</a>
<a name="ln1165"> */</a>
<a name="ln1166">static god_type _find_god(const monster &amp;mons, mon_spell_slot_flags flags)</a>
<a name="ln1167">{</a>
<a name="ln1168">    // Permanent wizard summons of Yred should have the same god even</a>
<a name="ln1169">    // though they aren't priests. This is so that e.g. the zombies of</a>
<a name="ln1170">    // Yred's enslaved souls will properly turn on you if you abandon</a>
<a name="ln1171">    // Yred.</a>
<a name="ln1172">    if (mons.god == GOD_YREDELEMNUL)</a>
<a name="ln1173">        return mons.god;</a>
<a name="ln1174"> </a>
<a name="ln1175">    // If this is a wizard spell, summons won't necessarily have the</a>
<a name="ln1176">    // same god. But intrinsic/priestly summons should.</a>
<a name="ln1177">    return flags &amp; MON_SPELL_WIZARD ? GOD_NO_GOD : mons.god;</a>
<a name="ln1178">}</a>
<a name="ln1179"> </a>
<a name="ln1180">static spell_type _random_bolt_spell()</a>
<a name="ln1181">{</a>
<a name="ln1182">    return random_choose(SPELL_VENOM_BOLT,</a>
<a name="ln1183">                         SPELL_BOLT_OF_DRAINING,</a>
<a name="ln1184">                         SPELL_BOLT_OF_FIRE,</a>
<a name="ln1185">                         SPELL_LIGHTNING_BOLT,</a>
<a name="ln1186">                         SPELL_QUICKSILVER_BOLT,</a>
<a name="ln1187">                         SPELL_CORROSIVE_BOLT);</a>
<a name="ln1188">}</a>
<a name="ln1189"> </a>
<a name="ln1190">static spell_type _major_destruction_spell()</a>
<a name="ln1191">{</a>
<a name="ln1192">    return random_choose(SPELL_BOLT_OF_FIRE,</a>
<a name="ln1193">                         SPELL_FIREBALL,</a>
<a name="ln1194">                         SPELL_LIGHTNING_BOLT,</a>
<a name="ln1195">                         SPELL_STICKY_FLAME,</a>
<a name="ln1196">                         SPELL_IRON_SHOT,</a>
<a name="ln1197">                         SPELL_BOLT_OF_DRAINING,</a>
<a name="ln1198">                         SPELL_ORB_OF_ELECTRICITY);</a>
<a name="ln1199">}</a>
<a name="ln1200"> </a>
<a name="ln1201">static spell_type _legendary_destruction_spell()</a>
<a name="ln1202">{</a>
<a name="ln1203">    return random_choose_weighted(25, SPELL_FIREBALL,</a>
<a name="ln1204">                                  20, SPELL_ICEBLAST,</a>
<a name="ln1205">                                  15, SPELL_GHOSTLY_FIREBALL);</a>
<a name="ln1206">}</a>
<a name="ln1207"> </a>
<a name="ln1208">// TODO: documentme</a>
<a name="ln1209">// NOTE: usually doesn't set target, but if set, should take precedence</a>
<a name="ln1210">bolt mons_spell_beam(const monster* mons, spell_type spell_cast, int power,</a>
<a name="ln1211">                     bool check_validity)</a>
<a name="ln1212">{</a>
<a name="ln1213">    ASSERT(power &gt; 0);</a>
<a name="ln1214"> </a>
<a name="ln1215">    bolt beam;</a>
<a name="ln1216"> </a>
<a name="ln1217">    // Initialise to some bogus values so we can catch problems.</a>
<a name="ln1218">    beam.name         = &quot;****&quot;;</a>
<a name="ln1219">    beam.colour       = 255;</a>
<a name="ln1220">    beam.hit          = -1;</a>
<a name="ln1221">    beam.damage       = dice_def(1, 0);</a>
<a name="ln1222">    beam.ench_power   = max(1, power / ENCH_POW_FACTOR); // U G H</a>
<a name="ln1223">    beam.glyph        = 0;</a>
<a name="ln1224">    beam.flavour      = BEAM_NONE;</a>
<a name="ln1225">    beam.thrower      = KILL_MISC;</a>
<a name="ln1226">    beam.pierce       = false;</a>
<a name="ln1227">    beam.is_explosion = false;</a>
<a name="ln1228">    beam.attitude     = mons_attitude(*mons);</a>
<a name="ln1229"> </a>
<a name="ln1230">    beam.range = _mons_spell_range(*mons, spell_cast);</a>
<a name="ln1231"> </a>
<a name="ln1232">    spell_type real_spell = spell_cast;</a>
<a name="ln1233"> </a>
<a name="ln1234">    if (spell_cast == SPELL_RANDOM_BOLT)</a>
<a name="ln1235">        real_spell = _random_bolt_spell();</a>
<a name="ln1236">    else if (spell_cast == SPELL_MAJOR_DESTRUCTION)</a>
<a name="ln1237">        real_spell = _major_destruction_spell();</a>
<a name="ln1238">    else if (spell_cast == SPELL_LEGENDARY_DESTRUCTION)</a>
<a name="ln1239">    {</a>
<a name="ln1240">        // ones with ranges too small are fixed in setup_mons_cast</a>
<a name="ln1241">        real_spell = _legendary_destruction_spell();</a>
<a name="ln1242">    }</a>
<a name="ln1243">    else if (spell_is_soh_breath(spell_cast))</a>
<a name="ln1244">    {</a>
<a name="ln1245">        // this will be fixed up later in mons_cast</a>
<a name="ln1246">        // XXX: is this necessary?</a>
<a name="ln1247">        real_spell = SPELL_FIRE_BREATH;</a>
<a name="ln1248">    }</a>
<a name="ln1249">    beam.glyph = dchar_glyph(DCHAR_FIRED_ZAP); // default</a>
<a name="ln1250">    beam.thrower = KILL_MON_MISSILE;</a>
<a name="ln1251">    beam.origin_spell = real_spell;</a>
<a name="ln1252">    beam.source_id = mons-&gt;mid;</a>
<a name="ln1253">    beam.source_name = mons-&gt;name(DESC_A, true);</a>
<a name="ln1254"> </a>
<a name="ln1255">    const mons_spell_logic* logic = map_find(spell_to_logic, spell_cast);</a>
<a name="ln1256">    if (logic &amp;&amp; logic-&gt;setup_beam)</a>
<a name="ln1257">        logic-&gt;setup_beam(beam, *mons, power);</a>
<a name="ln1258"> </a>
<a name="ln1259">    // FIXME: more of these should use the zap_data[] struct from beam.cc!</a>
<a name="ln1260">    switch (real_spell)</a>
<a name="ln1261">    {</a>
<a name="ln1262">    case SPELL_ORB_OF_ELECTRICITY:</a>
<a name="ln1263">        beam.foe_ratio      = random_range(40, 55); // ...</a>
<a name="ln1264">        // fallthrough to other zaps</a>
<a name="ln1265">    case SPELL_MAGIC_DART:</a>
<a name="ln1266">    case SPELL_THROW_FLAME:</a>
<a name="ln1267">    case SPELL_THROW_FROST:</a>
<a name="ln1268">    case SPELL_FLAME_TONGUE:</a>
<a name="ln1269">    case SPELL_VENOM_BOLT:</a>
<a name="ln1270">    case SPELL_POISON_ARROW:</a>
<a name="ln1271">    case SPELL_BOLT_OF_MAGMA:</a>
<a name="ln1272">    case SPELL_BOLT_OF_FIRE:</a>
<a name="ln1273">    case SPELL_BOLT_OF_COLD:</a>
<a name="ln1274">    case SPELL_THROW_ICICLE:</a>
<a name="ln1275">    case SPELL_SHOCK:</a>
<a name="ln1276">    case SPELL_LIGHTNING_BOLT:</a>
<a name="ln1277">    case SPELL_FIREBALL:</a>
<a name="ln1278">    case SPELL_ICEBLAST:</a>
<a name="ln1279">    case SPELL_LEHUDIBS_CRYSTAL_SPEAR:</a>
<a name="ln1280">    case SPELL_BOLT_OF_DRAINING:</a>
<a name="ln1281">    case SPELL_STICKY_FLAME:</a>
<a name="ln1282">    case SPELL_STICKY_FLAME_RANGE:</a>
<a name="ln1283">    case SPELL_STING:</a>
<a name="ln1284">    case SPELL_IRON_SHOT:</a>
<a name="ln1285">    case SPELL_STONE_ARROW:</a>
<a name="ln1286">    case SPELL_FORCE_LANCE:</a>
<a name="ln1287">    case SPELL_CORROSIVE_BOLT:</a>
<a name="ln1288">    case SPELL_HIBERNATION:</a>
<a name="ln1289">    case SPELL_SLEEP:</a>
<a name="ln1290">    case SPELL_DIG:</a>
<a name="ln1291">    case SPELL_ENSLAVEMENT:</a>
<a name="ln1292">    case SPELL_QUICKSILVER_BOLT:</a>
<a name="ln1293">    case SPELL_PRIMAL_WAVE:</a>
<a name="ln1294">    case SPELL_BLINKBOLT:</a>
<a name="ln1295">    case SPELL_STEAM_BALL:</a>
<a name="ln1296">    case SPELL_TELEPORT_OTHER:</a>
<a name="ln1297">    case SPELL_SANDBLAST:</a>
<a name="ln1298">    case SPELL_HARPOON_SHOT:</a>
<a name="ln1299">    case SPELL_THROW_PIE:</a>
<a name="ln1300">        zappy(spell_to_zap(real_spell), power, true, beam);</a>
<a name="ln1301">        break;</a>
<a name="ln1302"> </a>
<a name="ln1303">    case SPELL_FREEZING_CLOUD: // battlesphere special-case</a>
<a name="ln1304">        zappy(ZAP_FREEZING_BLAST, power, true, beam);</a>
<a name="ln1305">        break;</a>
<a name="ln1306"> </a>
<a name="ln1307">    case SPELL_DISPEL_UNDEAD_RANGE:</a>
<a name="ln1308">        beam.flavour  = BEAM_DISPEL_UNDEAD;</a>
<a name="ln1309">        beam.damage   = dice_def(3, min(6 + power / 10, 40));</a>
<a name="ln1310">        break;</a>
<a name="ln1311"> </a>
<a name="ln1312">    case SPELL_MALMUTATE:</a>
<a name="ln1313">        beam.flavour  = BEAM_MALMUTATE;</a>
<a name="ln1314">        break;</a>
<a name="ln1315"> </a>
<a name="ln1316">    case SPELL_FIRE_STORM:</a>
<a name="ln1317">        setup_fire_storm(mons, power / 2, beam);</a>
<a name="ln1318">        beam.foe_ratio = random_range(40, 55);</a>
<a name="ln1319">        break;</a>
<a name="ln1320"> </a>
<a name="ln1321">    case SPELL_CALL_DOWN_DAMNATION:</a>
<a name="ln1322">        beam.aux_source   = &quot;damnation&quot;;</a>
<a name="ln1323">        beam.name         = &quot;damnation&quot;;</a>
<a name="ln1324">        beam.ex_size      = 1;</a>
<a name="ln1325">        beam.flavour      = BEAM_DAMNATION;</a>
<a name="ln1326">        beam.is_explosion = true;</a>
<a name="ln1327">        beam.colour       = LIGHTRED;</a>
<a name="ln1328">        beam.aux_source.clear();</a>
<a name="ln1329">        beam.is_tracer    = false;</a>
<a name="ln1330">        beam.hit          = 20;</a>
<a name="ln1331">        beam.damage       = dice_def(3, 15);</a>
<a name="ln1332">        break;</a>
<a name="ln1333"> </a>
<a name="ln1334">    case SPELL_NOXIOUS_CLOUD:</a>
<a name="ln1335">        beam.name     = &quot;noxious blast&quot;;</a>
<a name="ln1336">        beam.damage   = dice_def(1, 0);</a>
<a name="ln1337">        beam.colour   = GREEN;</a>
<a name="ln1338">        beam.flavour  = BEAM_MEPHITIC;</a>
<a name="ln1339">        beam.hit      = 18 + power / 25;</a>
<a name="ln1340">        beam.pierce   = true;</a>
<a name="ln1341">        break;</a>
<a name="ln1342"> </a>
<a name="ln1343">    case SPELL_POISONOUS_CLOUD:</a>
<a name="ln1344">        beam.name     = &quot;blast of poison&quot;;</a>
<a name="ln1345">        beam.damage   = dice_def(3, 3 + power / 25);</a>
<a name="ln1346">        beam.colour   = LIGHTGREEN;</a>
<a name="ln1347">        beam.flavour  = BEAM_POISON;</a>
<a name="ln1348">        beam.hit      = 18 + power / 25;</a>
<a name="ln1349">        beam.pierce   = true;</a>
<a name="ln1350">        break;</a>
<a name="ln1351"> </a>
<a name="ln1352">    case SPELL_ENERGY_BOLT:        // eye of devastation</a>
<a name="ln1353">        beam.colour     = YELLOW;</a>
<a name="ln1354">        beam.name       = &quot;bolt of energy&quot;;</a>
<a name="ln1355">        beam.short_name = &quot;energy&quot;;</a>
<a name="ln1356">        beam.damage     = dice_def(3, 20);</a>
<a name="ln1357">        beam.hit        = 15 + power / 30;</a>
<a name="ln1358">        beam.flavour    = BEAM_DEVASTATION; // DEVASTATION is BEAM_MMISSILE</a>
<a name="ln1359">        beam.pierce     = true;             // (except bloodier)</a>
<a name="ln1360">        break;</a>
<a name="ln1361"> </a>
<a name="ln1362">    case SPELL_SPIT_POISON:</a>
<a name="ln1363">        beam.colour   = GREEN;</a>
<a name="ln1364">        beam.name     = &quot;splash of poison&quot;;</a>
<a name="ln1365">        beam.damage   = dice_def(1, 4 + power / 10);</a>
<a name="ln1366">        beam.hit      = 16 + power / 20;</a>
<a name="ln1367">        beam.flavour  = BEAM_POISON;</a>
<a name="ln1368">        break;</a>
<a name="ln1369"> </a>
<a name="ln1370">    case SPELL_SPIT_ACID:</a>
<a name="ln1371">        beam.colour   = YELLOW;</a>
<a name="ln1372">        beam.name     = &quot;splash of acid&quot;;</a>
<a name="ln1373">        beam.damage   = dice_def(3, 7);</a>
<a name="ln1374"> </a>
<a name="ln1375">        // Natural ability, so don't use spell_hd here</a>
<a name="ln1376">        beam.hit      = 20 + (3 * mons-&gt;get_hit_dice());</a>
<a name="ln1377">        beam.flavour  = BEAM_ACID;</a>
<a name="ln1378">        break;</a>
<a name="ln1379"> </a>
<a name="ln1380">    case SPELL_ACID_SPLASH:      // yellow draconian</a>
<a name="ln1381">        beam.colour   = YELLOW;</a>
<a name="ln1382">        beam.name     = &quot;glob of acid&quot;;</a>
<a name="ln1383">        beam.damage   = dice_def(3, 7);</a>
<a name="ln1384"> </a>
<a name="ln1385">        // Natural ability, so don't use spell_hd here</a>
<a name="ln1386">        beam.hit      = 20 + (3 * mons-&gt;get_hit_dice());</a>
<a name="ln1387">        beam.flavour  = BEAM_ACID;</a>
<a name="ln1388">        break;</a>
<a name="ln1389"> </a>
<a name="ln1390">    case SPELL_MEPHITIC_CLOUD:</a>
<a name="ln1391">        beam.name     = &quot;stinking cloud&quot;;</a>
<a name="ln1392">        beam.damage   = dice_def(1, 0);</a>
<a name="ln1393">        beam.colour   = GREEN;</a>
<a name="ln1394">        beam.flavour  = BEAM_MEPHITIC;</a>
<a name="ln1395">        beam.hit      = 14 + power / 30;</a>
<a name="ln1396">        beam.is_explosion = true;</a>
<a name="ln1397">        break;</a>
<a name="ln1398"> </a>
<a name="ln1399">    case SPELL_MIASMA_BREATH:      // death drake</a>
<a name="ln1400">        beam.name     = &quot;foul vapour&quot;;</a>
<a name="ln1401">        beam.damage   = dice_def(3, 5 + power / 24);</a>
<a name="ln1402">        beam.colour   = DARKGREY;</a>
<a name="ln1403">        beam.flavour  = BEAM_MIASMA;</a>
<a name="ln1404">        beam.hit      = 17 + power / 20;</a>
<a name="ln1405">        beam.pierce   = true;</a>
<a name="ln1406">        break;</a>
<a name="ln1407"> </a>
<a name="ln1408">    case SPELL_HURL_DAMNATION:           // fiend's damnation</a>
<a name="ln1409">        beam.name         = &quot;damnation&quot;;</a>
<a name="ln1410">        beam.aux_source   = &quot;damnation&quot;;</a>
<a name="ln1411">        beam.colour       = LIGHTRED;</a>
<a name="ln1412">        beam.damage       = dice_def(3, 20);</a>
<a name="ln1413">        beam.hit          = 24;</a>
<a name="ln1414">        beam.flavour      = BEAM_DAMNATION;</a>
<a name="ln1415">        beam.pierce       = true; // needed?</a>
<a name="ln1416">        beam.is_explosion = true;</a>
<a name="ln1417">        break;</a>
<a name="ln1418"> </a>
<a name="ln1419">    case SPELL_METAL_SPLINTERS:</a>
<a name="ln1420">        beam.name       = &quot;spray of metal splinters&quot;;</a>
<a name="ln1421">        beam.short_name = &quot;metal splinters&quot;;</a>
<a name="ln1422">        beam.damage     = dice_def(3, 20 + power / 20);</a>
<a name="ln1423">        beam.colour     = CYAN;</a>
<a name="ln1424">        beam.flavour    = BEAM_FRAG;</a>
<a name="ln1425">        beam.hit        = 19 + power / 30;</a>
<a name="ln1426">        beam.pierce     = true;</a>
<a name="ln1427">        break;</a>
<a name="ln1428"> </a>
<a name="ln1429">    case SPELL_BLINK_OTHER:</a>
<a name="ln1430">        beam.flavour    = BEAM_BLINK;</a>
<a name="ln1431">        break;</a>
<a name="ln1432"> </a>
<a name="ln1433">    case SPELL_BLINK_OTHER_CLOSE:</a>
<a name="ln1434">        beam.flavour    = BEAM_BLINK_CLOSE;</a>
<a name="ln1435">        break;</a>
<a name="ln1436"> </a>
<a name="ln1437">    case SPELL_FIRE_BREATH:</a>
<a name="ln1438">    case SPELL_SEARING_BREATH:</a>
<a name="ln1439">        beam.name       = &quot;blast of flame&quot;;</a>
<a name="ln1440">        beam.aux_source = &quot;blast of fiery breath&quot;;</a>
<a name="ln1441">        beam.short_name = &quot;flames&quot;;</a>
<a name="ln1442">        beam.damage     = dice_def(3, (mons-&gt;get_hit_dice() * 2));</a>
<a name="ln1443">        beam.colour     = RED;</a>
<a name="ln1444">        beam.hit        = 30;</a>
<a name="ln1445">        beam.flavour    = BEAM_FIRE;</a>
<a name="ln1446">        beam.pierce     = true;</a>
<a name="ln1447">        if (real_spell == SPELL_SEARING_BREATH)</a>
<a name="ln1448">        {</a>
<a name="ln1449">            beam.name        = &quot;searing blast&quot;;</a>
<a name="ln1450">            beam.aux_source  = &quot;blast of searing breath&quot;;</a>
<a name="ln1451">            if (mons-&gt;type != MONS_XTAHUA)</a>
<a name="ln1452">                beam.damage.size = 65 * beam.damage.size / 100;</a>
<a name="ln1453">        }</a>
<a name="ln1454">        break;</a>
<a name="ln1455"> </a>
<a name="ln1456">    case SPELL_CHAOS_BREATH:</a>
<a name="ln1457">        beam.name         = &quot;blast of chaos&quot;;</a>
<a name="ln1458">        beam.aux_source   = &quot;blast of chaotic breath&quot;;</a>
<a name="ln1459">        beam.damage       = dice_def(1, 3 * mons-&gt;get_hit_dice() / 2);</a>
<a name="ln1460">        beam.colour       = ETC_RANDOM;</a>
<a name="ln1461">        beam.hit          = 30;</a>
<a name="ln1462">        beam.flavour      = BEAM_CHAOS;</a>
<a name="ln1463">        beam.pierce       = true;</a>
<a name="ln1464">        break;</a>
<a name="ln1465"> </a>
<a name="ln1466">    case SPELL_CHILLING_BREATH:</a>
<a name="ln1467">    case SPELL_COLD_BREATH:</a>
<a name="ln1468">        beam.name       = &quot;blast of cold&quot;;</a>
<a name="ln1469">        beam.aux_source = &quot;blast of icy breath&quot;;</a>
<a name="ln1470">        beam.short_name = &quot;frost&quot;;</a>
<a name="ln1471">        beam.damage     = dice_def(3, (mons-&gt;get_hit_dice() * 2));</a>
<a name="ln1472">        beam.colour     = WHITE;</a>
<a name="ln1473">        beam.hit        = 30;</a>
<a name="ln1474">        beam.flavour    = BEAM_COLD;</a>
<a name="ln1475">        beam.pierce     = true;</a>
<a name="ln1476">        if (real_spell == SPELL_CHILLING_BREATH)</a>
<a name="ln1477">        {</a>
<a name="ln1478">            beam.name        = &quot;chilling blast&quot;;</a>
<a name="ln1479">            beam.aux_source  = &quot;blast of chilling breath&quot;;</a>
<a name="ln1480">            beam.short_name  = &quot;frost&quot;;</a>
<a name="ln1481">            beam.damage.size = 65 * beam.damage.size / 100;</a>
<a name="ln1482">        }</a>
<a name="ln1483">        break;</a>
<a name="ln1484"> </a>
<a name="ln1485">    case SPELL_HOLY_BREATH:</a>
<a name="ln1486">        beam.name     = &quot;blast of cleansing flame&quot;;</a>
<a name="ln1487">        beam.damage   = dice_def(3, mons-&gt;get_hit_dice());</a>
<a name="ln1488">        beam.colour   = ETC_HOLY;</a>
<a name="ln1489">        beam.flavour  = BEAM_HOLY;</a>
<a name="ln1490">        beam.hit      = 18 + power / 25;</a>
<a name="ln1491">        beam.pierce   = true;</a>
<a name="ln1492">        break;</a>
<a name="ln1493"> </a>
<a name="ln1494">    case SPELL_PORKALATOR:</a>
<a name="ln1495">        beam.name     = &quot;porkalator&quot;;</a>
<a name="ln1496">        beam.glyph    = 0;</a>
<a name="ln1497">        beam.flavour  = BEAM_PORKALATOR;</a>
<a name="ln1498">        beam.thrower  = KILL_MON_MISSILE;</a>
<a name="ln1499">        break;</a>
<a name="ln1500"> </a>
<a name="ln1501">    case SPELL_IOOD:                  // tracer only</a>
<a name="ln1502">    case SPELL_PORTAL_PROJECTILE:     // for noise generation purposes</a>
<a name="ln1503">    case SPELL_GLACIATE:              // ditto</a>
<a name="ln1504">    case SPELL_CLOUD_CONE:            // ditto</a>
<a name="ln1505">    case SPELL_SCATTERSHOT:           // ditto</a>
<a name="ln1506">        _setup_fake_beam(beam, *mons);</a>
<a name="ln1507">        break;</a>
<a name="ln1508"> </a>
<a name="ln1509">    case SPELL_PETRIFYING_CLOUD:</a>
<a name="ln1510">        beam.name     = &quot;blast of calcifying dust&quot;;</a>
<a name="ln1511">        beam.colour   = WHITE;</a>
<a name="ln1512">        beam.damage   = dice_def(2, 6);</a>
<a name="ln1513">        beam.hit      = AUTOMATIC_HIT;</a>
<a name="ln1514">        beam.flavour  = BEAM_PETRIFYING_CLOUD;</a>
<a name="ln1515">        beam.foe_ratio = 30;</a>
<a name="ln1516">        beam.pierce   = true;</a>
<a name="ln1517">        break;</a>
<a name="ln1518"> </a>
<a name="ln1519">    case SPELL_ENSNARE:</a>
<a name="ln1520">        beam.name     = &quot;stream of webbing&quot;;</a>
<a name="ln1521">        beam.colour   = WHITE;</a>
<a name="ln1522">        beam.glyph    = dchar_glyph(DCHAR_FIRED_MISSILE);</a>
<a name="ln1523">        beam.flavour  = BEAM_ENSNARE;</a>
<a name="ln1524">        beam.hit      = 22 + power / 20;</a>
<a name="ln1525">        break;</a>
<a name="ln1526"> </a>
<a name="ln1527">    case SPELL_SPECTRAL_CLOUD:</a>
<a name="ln1528">        beam.name     = &quot;spectral mist&quot;;</a>
<a name="ln1529">        beam.damage   = dice_def(0, 1);</a>
<a name="ln1530">        beam.colour   = CYAN;</a>
<a name="ln1531">        beam.flavour  = BEAM_MMISSILE;</a>
<a name="ln1532">        beam.hit      = AUTOMATIC_HIT;</a>
<a name="ln1533">        beam.pierce   = true;</a>
<a name="ln1534">        break;</a>
<a name="ln1535"> </a>
<a name="ln1536">    case SPELL_GHOSTLY_FIREBALL:</a>
<a name="ln1537">        _setup_ghostly_beam(beam, power, 3);</a>
<a name="ln1538">        break;</a>
<a name="ln1539"> </a>
<a name="ln1540">    case SPELL_DIMENSION_ANCHOR:</a>
<a name="ln1541">        beam.flavour    = BEAM_DIMENSION_ANCHOR;</a>
<a name="ln1542">        break;</a>
<a name="ln1543"> </a>
<a name="ln1544">    case SPELL_THORN_VOLLEY:</a>
<a name="ln1545">        beam.colour   = BROWN;</a>
<a name="ln1546">        beam.name     = &quot;volley of thorns&quot;;</a>
<a name="ln1547">        beam.damage   = dice_def(3, 5 + (power / 13));</a>
<a name="ln1548">        beam.hit      = 20 + power / 15;</a>
<a name="ln1549">        beam.flavour  = BEAM_MMISSILE;</a>
<a name="ln1550">        break;</a>
<a name="ln1551"> </a>
<a name="ln1552">    // XXX: This seems needed to give proper spellcasting messages, even though</a>
<a name="ln1553">    //      damage is done via another means</a>
<a name="ln1554">    case SPELL_FREEZE:</a>
<a name="ln1555">        beam.flavour    = BEAM_COLD;</a>
<a name="ln1556">        break;</a>
<a name="ln1557"> </a>
<a name="ln1558">    case SPELL_MALIGN_OFFERING:</a>
<a name="ln1559">        beam.flavour    = BEAM_MALIGN_OFFERING;</a>
<a name="ln1560">        beam.damage     = dice_def(2, 7 + (power / 13));</a>
<a name="ln1561">        break;</a>
<a name="ln1562"> </a>
<a name="ln1563">    case SPELL_FLASH_FREEZE:</a>
<a name="ln1564">        beam.name     = &quot;flash freeze&quot;;</a>
<a name="ln1565">        beam.damage   = dice_def(3, 7 + (power / 12));</a>
<a name="ln1566">        beam.colour   = WHITE;</a>
<a name="ln1567">        beam.flavour  = BEAM_ICE;</a>
<a name="ln1568">        beam.hit      = 5 + power / 3;</a>
<a name="ln1569">        break;</a>
<a name="ln1570"> </a>
<a name="ln1571">    case SPELL_SHADOW_BOLT:</a>
<a name="ln1572">        beam.name     = &quot;shadow bolt&quot;;</a>
<a name="ln1573">        beam.pierce   = true;</a>
<a name="ln1574">        // deliberate fall-through</a>
<a name="ln1575">    case SPELL_SHADOW_SHARD:</a>
<a name="ln1576">        if (real_spell == SPELL_SHADOW_SHARD)</a>
<a name="ln1577">            beam.name  = &quot;shadow shard&quot;;</a>
<a name="ln1578">        beam.damage   = dice_def(3, 8 + power / 11);</a>
<a name="ln1579">        beam.colour   = MAGENTA;</a>
<a name="ln1580">        beam.flavour  = BEAM_MMISSILE;</a>
<a name="ln1581">        beam.hit      = 17 + power / 25;</a>
<a name="ln1582">        break;</a>
<a name="ln1583"> </a>
<a name="ln1584">    case SPELL_CRYSTAL_BOLT:</a>
<a name="ln1585">        beam.name     = &quot;crystal bolt&quot;;</a>
<a name="ln1586">        beam.damage   = dice_def(3, 8 + power / 11);</a>
<a name="ln1587">        beam.colour   = GREEN;</a>
<a name="ln1588">        beam.flavour  = BEAM_CRYSTAL;</a>
<a name="ln1589">        beam.hit      = 17 + power / 25;</a>
<a name="ln1590">        beam.pierce   = true;</a>
<a name="ln1591">        break;</a>
<a name="ln1592"> </a>
<a name="ln1593">    case SPELL_SPIT_LAVA:</a>
<a name="ln1594">        beam.name        = &quot;glob of lava&quot;;</a>
<a name="ln1595">        beam.damage      = dice_def(3, 10);</a>
<a name="ln1596">        beam.hit         = 20;</a>
<a name="ln1597">        beam.colour      = RED;</a>
<a name="ln1598">        beam.glyph       = dchar_glyph(DCHAR_FIRED_ZAP);</a>
<a name="ln1599">        beam.flavour     = BEAM_LAVA;</a>
<a name="ln1600">        break;</a>
<a name="ln1601"> </a>
<a name="ln1602">    case SPELL_ELECTRICAL_BOLT:</a>
<a name="ln1603">        beam.name        = &quot;bolt of electricity&quot;;</a>
<a name="ln1604">        beam.damage      = dice_def(3, 3 + mons-&gt;get_hit_dice());</a>
<a name="ln1605">        beam.hit         = 35;</a>
<a name="ln1606">        beam.colour      = LIGHTCYAN;</a>
<a name="ln1607">        beam.glyph       = dchar_glyph(DCHAR_FIRED_ZAP);</a>
<a name="ln1608">        beam.flavour     = BEAM_ELECTRICITY;</a>
<a name="ln1609">        beam.pierce      = true;</a>
<a name="ln1610">        break;</a>
<a name="ln1611"> </a>
<a name="ln1612">    case SPELL_FLAMING_CLOUD:</a>
<a name="ln1613">        beam.name         = &quot;blast of flame&quot;;</a>
<a name="ln1614">        beam.aux_source   = &quot;blast of fiery breath&quot;;</a>
<a name="ln1615">        beam.short_name   = &quot;flames&quot;;</a>
<a name="ln1616">        beam.damage       = dice_def(1, 3 * mons-&gt;get_hit_dice() / 2);</a>
<a name="ln1617">        beam.colour       = RED;</a>
<a name="ln1618">        beam.hit          = 30;</a>
<a name="ln1619">        beam.flavour      = BEAM_FIRE;</a>
<a name="ln1620">        beam.pierce       = true;</a>
<a name="ln1621">        break;</a>
<a name="ln1622"> </a>
<a name="ln1623">    case SPELL_THROW_BARBS:</a>
<a name="ln1624">        beam.name        = &quot;volley of spikes&quot;;</a>
<a name="ln1625">        beam.aux_source  = &quot;volley of spikes&quot;;</a>
<a name="ln1626">        beam.hit_verb    = &quot;skewers&quot;;</a>
<a name="ln1627">        beam.hit         = 27;</a>
<a name="ln1628">        beam.damage      = dice_def(2, 13);</a>
<a name="ln1629">        beam.glyph       = dchar_glyph(DCHAR_FIRED_MISSILE);</a>
<a name="ln1630">        beam.colour      = LIGHTGREY;</a>
<a name="ln1631">        beam.flavour     = BEAM_MISSILE;</a>
<a name="ln1632">        break;</a>
<a name="ln1633"> </a>
<a name="ln1634">    case SPELL_DEATH_RATTLE:</a>
<a name="ln1635">        beam.name     = &quot;vile air&quot;;</a>
<a name="ln1636">        beam.colour   = DARKGREY;</a>
<a name="ln1637">        beam.damage   = dice_def(2, 4);</a>
<a name="ln1638">        beam.hit      = AUTOMATIC_HIT;</a>
<a name="ln1639">        beam.flavour  = BEAM_DEATH_RATTLE;</a>
<a name="ln1640">        beam.foe_ratio = 30;</a>
<a name="ln1641">        beam.pierce   = true;</a>
<a name="ln1642">        break;</a>
<a name="ln1643"> </a>
<a name="ln1644">    // Special behaviour handled in _mons_upheaval</a>
<a name="ln1645">    // Hack so beam.cc allows us to correctly use that function</a>
<a name="ln1646">    case SPELL_UPHEAVAL:</a>
<a name="ln1647">        beam.flavour     = BEAM_RANDOM;</a>
<a name="ln1648">        beam.damage      = dice_def(3, 24);</a>
<a name="ln1649">        beam.hit         = AUTOMATIC_HIT;</a>
<a name="ln1650">        beam.glyph       = dchar_glyph(DCHAR_EXPLOSION);</a>
<a name="ln1651">        beam.ex_size     = 2;</a>
<a name="ln1652">        break;</a>
<a name="ln1653"> </a>
<a name="ln1654">    default:</a>
<a name="ln1655">        if (logic &amp;&amp; logic-&gt;setup_beam) // already setup</a>
<a name="ln1656">            break;</a>
<a name="ln1657"> </a>
<a name="ln1658">        if (check_validity)</a>
<a name="ln1659">        {</a>
<a name="ln1660">            beam.flavour = NUM_BEAMS;</a>
<a name="ln1661">            return beam;</a>
<a name="ln1662">        }</a>
<a name="ln1663"> </a>
<a name="ln1664">        if (!is_valid_spell(real_spell))</a>
<a name="ln1665">        {</a>
<a name="ln1666">            die(&quot;Invalid spell #%d cast by %s&quot;, (int) real_spell,</a>
<a name="ln1667">                     mons-&gt;name(DESC_PLAIN, true).c_str());</a>
<a name="ln1668">        }</a>
<a name="ln1669"> </a>
<a name="ln1670">        die(&quot;Unknown monster spell '%s' cast by %s&quot;,</a>
<a name="ln1671">                 spell_title(real_spell),</a>
<a name="ln1672">                 mons-&gt;name(DESC_PLAIN, true).c_str());</a>
<a name="ln1673">    }</a>
<a name="ln1674"> </a>
<a name="ln1675">    if (beam.is_enchantment())</a>
<a name="ln1676">    {</a>
<a name="ln1677">        beam.hit = AUTOMATIC_HIT;</a>
<a name="ln1678">        beam.glyph = 0;</a>
<a name="ln1679">        beam.name = &quot;&quot;;</a>
<a name="ln1680">    }</a>
<a name="ln1681"> </a>
<a name="ln1682">    return beam;</a>
<a name="ln1683">}</a>
<a name="ln1684"> </a>
<a name="ln1685">// Set up bolt structure for monster spell casting.</a>
<a name="ln1686">bool setup_mons_cast(const monster* mons, bolt &amp;pbolt, spell_type spell_cast,</a>
<a name="ln1687">                     bool evoke,</a>
<a name="ln1688">                     bool check_validity)</a>
<a name="ln1689">{</a>
<a name="ln1690">    // always set these -- used by things other than fire_beam()</a>
<a name="ln1691"> </a>
<a name="ln1692">    pbolt.source_id = mons-&gt;mid;</a>
<a name="ln1693"> </a>
<a name="ln1694">    // Convenience for the hapless innocent who assumes that this</a>
<a name="ln1695">    // damn function does all possible setup. [ds]</a>
<a name="ln1696">    if (pbolt.target.origin())</a>
<a name="ln1697">        pbolt.target = mons-&gt;target;</a>
<a name="ln1698"> </a>
<a name="ln1699">    // Set bolt type and range.</a>
<a name="ln1700">    if (spell_is_direct_explosion(spell_cast))</a>
<a name="ln1701">    {</a>
<a name="ln1702">        pbolt.range = 0;</a>
<a name="ln1703">        pbolt.glyph = 0;</a>
<a name="ln1704">    }</a>
<a name="ln1705"> </a>
<a name="ln1706">    // The below are no-ops since they don't involve fire_tracer or beams.</a>
<a name="ln1707">    switch (spell_cast)</a>
<a name="ln1708">    {</a>
<a name="ln1709">    case SPELL_STICKS_TO_SNAKES:</a>
<a name="ln1710">    case SPELL_SUMMON_SMALL_MAMMAL:</a>
<a name="ln1711">    case SPELL_VAMPIRIC_DRAINING:</a>
<a name="ln1712">    case SPELL_MAJOR_HEALING:</a>
<a name="ln1713">    case SPELL_SHADOW_CREATURES:       // summon anything appropriate for level</a>
<a name="ln1714">    case SPELL_FAKE_MARA_SUMMON:</a>
<a name="ln1715">    case SPELL_SUMMON_ILLUSION:</a>
<a name="ln1716">    case SPELL_SUMMON_DEMON:</a>
<a name="ln1717">    case SPELL_MONSTROUS_MENAGERIE:</a>
<a name="ln1718">#if TAG_MAJOR_VERSION == 34</a>
<a name="ln1719">    case SPELL_ANIMATE_DEAD:</a>
<a name="ln1720">#endif</a>
<a name="ln1721">    case SPELL_TWISTED_RESURRECTION:</a>
<a name="ln1722">#if TAG_MAJOR_VERSION == 34</a>
<a name="ln1723">    case SPELL_SIMULACRUM:</a>
<a name="ln1724">#endif</a>
<a name="ln1725">    case SPELL_CALL_IMP:</a>
<a name="ln1726">    case SPELL_SUMMON_MINOR_DEMON:</a>
<a name="ln1727">    case SPELL_SUMMON_SWARM:</a>
<a name="ln1728">    case SPELL_SUMMON_UFETUBUS:</a>
<a name="ln1729">    case SPELL_SUMMON_HELL_BEAST:  // Geryon</a>
<a name="ln1730">    case SPELL_SUMMON_UNDEAD:</a>
<a name="ln1731">    case SPELL_SUMMON_ICE_BEAST:</a>
<a name="ln1732">    case SPELL_SUMMON_MUSHROOMS:</a>
<a name="ln1733">    case SPELL_CONJURE_BALL_LIGHTNING:</a>
<a name="ln1734">    case SPELL_SUMMON_DRAKES:</a>
<a name="ln1735">    case SPELL_SUMMON_HORRIBLE_THINGS:</a>
<a name="ln1736">    case SPELL_MALIGN_GATEWAY:</a>
<a name="ln1737">    case SPELL_SYMBOL_OF_TORMENT:</a>
<a name="ln1738">    case SPELL_CAUSE_FEAR:</a>
<a name="ln1739">    case SPELL_MESMERISE:</a>
<a name="ln1740">    case SPELL_SUMMON_GREATER_DEMON:</a>
<a name="ln1741">    case SPELL_BROTHERS_IN_ARMS:</a>
<a name="ln1742">    case SPELL_BERSERKER_RAGE:</a>
<a name="ln1743">    case SPELL_SPRINT:</a>
<a name="ln1744">#if TAG_MAJOR_VERSION == 34</a>
<a name="ln1745">    case SPELL_SWIFTNESS:</a>
<a name="ln1746">#endif</a>
<a name="ln1747">    case SPELL_CREATE_TENTACLES:</a>
<a name="ln1748">    case SPELL_BLINK:</a>
<a name="ln1749">    case SPELL_CONTROLLED_BLINK:</a>
<a name="ln1750">    case SPELL_BLINK_RANGE:</a>
<a name="ln1751">    case SPELL_BLINK_AWAY:</a>
<a name="ln1752">    case SPELL_BLINK_CLOSE:</a>
<a name="ln1753">    case SPELL_TOMB_OF_DOROKLOHE:</a>
<a name="ln1754">    case SPELL_CHAIN_LIGHTNING:    // the only user is reckless</a>
<a name="ln1755">    case SPELL_SUMMON_EYEBALLS:</a>
<a name="ln1756">    case SPELL_SUMMON_BUTTERFLIES:</a>
<a name="ln1757">    case SPELL_CALL_TIDE:</a>
<a name="ln1758">    case SPELL_INK_CLOUD:</a>
<a name="ln1759">    case SPELL_SILENCE:</a>
<a name="ln1760">    case SPELL_AWAKEN_FOREST:</a>
<a name="ln1761">    case SPELL_DRUIDS_CALL:</a>
<a name="ln1762">    case SPELL_SUMMON_HOLIES:</a>
<a name="ln1763">    case SPELL_CORPSE_ROT:</a>
<a name="ln1764">    case SPELL_SUMMON_DRAGON:</a>
<a name="ln1765">    case SPELL_SUMMON_HYDRA:</a>
<a name="ln1766">    case SPELL_FIRE_SUMMON:</a>
<a name="ln1767">#if TAG_MAJOR_VERSION == 34</a>
<a name="ln1768">    case SPELL_DEATHS_DOOR:</a>
<a name="ln1769">#endif</a>
<a name="ln1770">    case SPELL_OZOCUBUS_ARMOUR:</a>
<a name="ln1771">    case SPELL_OLGREBS_TOXIC_RADIANCE:</a>
<a name="ln1772">    case SPELL_SHATTER:</a>
<a name="ln1773">    case SPELL_BATTLESPHERE:</a>
<a name="ln1774">    case SPELL_SPECTRAL_WEAPON:</a>
<a name="ln1775">    case SPELL_WORD_OF_RECALL:</a>
<a name="ln1776">    case SPELL_INJURY_BOND:</a>
<a name="ln1777">    case SPELL_CALL_LOST_SOUL:</a>
<a name="ln1778">    case SPELL_BLINK_ALLIES_ENCIRCLE:</a>
<a name="ln1779">    case SPELL_MASS_CONFUSION:</a>
<a name="ln1780">    case SPELL_ENGLACIATION:</a>
<a name="ln1781">    case SPELL_AWAKEN_VINES:</a>
<a name="ln1782">    case SPELL_WALL_OF_BRAMBLES:</a>
<a name="ln1783">    case SPELL_WIND_BLAST:</a>
<a name="ln1784">    case SPELL_SUMMON_VERMIN:</a>
<a name="ln1785">    case SPELL_TORNADO:</a>
<a name="ln1786">    case SPELL_VORTEX:</a>
<a name="ln1787">    case SPELL_DISCHARGE:</a>
<a name="ln1788">    case SPELL_IGNITE_POISON:</a>
<a name="ln1789">    case SPELL_BLACK_MARK:</a>
<a name="ln1790">    case SPELL_BLINK_ALLIES_AWAY:</a>
<a name="ln1791">    case SPELL_SHROUD_OF_GOLUBRIA:</a>
<a name="ln1792">    case SPELL_PHANTOM_MIRROR:</a>
<a name="ln1793">    case SPELL_SUMMON_MANA_VIPER:</a>
<a name="ln1794">    case SPELL_SUMMON_EMPEROR_SCORPIONS:</a>
<a name="ln1795">    case SPELL_BATTLECRY:</a>
<a name="ln1796">    case SPELL_WARNING_CRY:</a>
<a name="ln1797">    case SPELL_SEAL_DOORS:</a>
<a name="ln1798">    case SPELL_BERSERK_OTHER:</a>
<a name="ln1799">    case SPELL_SPELLFORGED_SERVITOR:</a>
<a name="ln1800">    case SPELL_THROW_ALLY:</a>
<a name="ln1801">    case SPELL_CORRUPTING_PULSE:</a>
<a name="ln1802">    case SPELL_SIREN_SONG:</a>
<a name="ln1803">    case SPELL_AVATAR_SONG:</a>
<a name="ln1804">    case SPELL_REPEL_MISSILES:</a>
<a name="ln1805">    case SPELL_SUMMON_SCARABS:</a>
<a name="ln1806">    case SPELL_CLEANSING_FLAME:</a>
<a name="ln1807">    case SPELL_DRAINING_GAZE:</a>
<a name="ln1808">    case SPELL_CONFUSION_GAZE:</a>
<a name="ln1809">    case SPELL_HAUNT:</a>
<a name="ln1810">    case SPELL_SUMMON_SPECTRAL_ORCS:</a>
<a name="ln1811">    case SPELL_BRAIN_FEED:</a>
<a name="ln1812">    case SPELL_HOLY_FLAMES:</a>
<a name="ln1813">    case SPELL_CALL_OF_CHAOS:</a>
<a name="ln1814">    case SPELL_AIRSTRIKE:</a>
<a name="ln1815">    case SPELL_WATERSTRIKE:</a>
<a name="ln1816">    case SPELL_GRAVITAS:</a>
<a name="ln1817">    case SPELL_ENTROPIC_WEAVE:</a>
<a name="ln1818">    case SPELL_SUMMON_EXECUTIONERS:</a>
<a name="ln1819">    case SPELL_DOOM_HOWL:</a>
<a name="ln1820">    case SPELL_AURA_OF_BRILLIANCE:</a>
<a name="ln1821">    case SPELL_GREATER_SERVANT_MAKHLEB:</a>
<a name="ln1822">    case SPELL_BIND_SOULS:</a>
<a name="ln1823">    case SPELL_DREAM_DUST:</a>
<a name="ln1824">    case SPELL_SPORULATE:</a>
<a name="ln1825">        pbolt.range = 0;</a>
<a name="ln1826">        pbolt.glyph = 0;</a>
<a name="ln1827">        return true;</a>
<a name="ln1828">    default:</a>
<a name="ln1829">    {</a>
<a name="ln1830">        const mons_spell_logic* logic = map_find(spell_to_logic, spell_cast);</a>
<a name="ln1831">        if (logic &amp;&amp; logic-&gt;setup_beam == nullptr)</a>
<a name="ln1832">        {</a>
<a name="ln1833">            pbolt.range = 0;</a>
<a name="ln1834">            pbolt.glyph = 0;</a>
<a name="ln1835">            return true;</a>
<a name="ln1836">        }</a>
<a name="ln1837"> </a>
<a name="ln1838">        if (check_validity)</a>
<a name="ln1839">        {</a>
<a name="ln1840">            bolt beam = mons_spell_beam(mons, spell_cast, 1, true);</a>
<a name="ln1841">            return beam.flavour != NUM_BEAMS;</a>
<a name="ln1842">        }</a>
<a name="ln1843">        break;</a>
<a name="ln1844">    }</a>
<a name="ln1845">    }</a>
<a name="ln1846"> </a>
<a name="ln1847">    const int power = evoke ? 30 + mons-&gt;get_hit_dice()</a>
<a name="ln1848">                            : mons_spellpower(*mons, spell_cast);</a>
<a name="ln1849"> </a>
<a name="ln1850">    bolt theBeam = mons_spell_beam(mons, spell_cast, power);</a>
<a name="ln1851"> </a>
<a name="ln1852">    bolt_parent_init(theBeam, pbolt);</a>
<a name="ln1853">    if (!theBeam.target.origin())</a>
<a name="ln1854">        pbolt.target = theBeam.target;</a>
<a name="ln1855">    pbolt.source = mons-&gt;pos();</a>
<a name="ln1856">    pbolt.is_tracer = false;</a>
<a name="ln1857">    if (!pbolt.is_enchantment())</a>
<a name="ln1858">        pbolt.aux_source = pbolt.name;</a>
<a name="ln1859">    else</a>
<a name="ln1860">        pbolt.aux_source.clear();</a>
<a name="ln1861"> </a>
<a name="ln1862">    return true;</a>
<a name="ln1863">}</a>
<a name="ln1864"> </a>
<a name="ln1865">/// Can 'binder' bind 'bound's soul with BIND_SOUL?</a>
<a name="ln1866">static bool _mons_can_bind_soul(monster* binder, monster* bound)</a>
<a name="ln1867">{</a>
<a name="ln1868">    return bound-&gt;holiness() &amp; MH_NATURAL</a>
<a name="ln1869">            &amp;&amp; mons_can_be_zombified(*bound)</a>
<a name="ln1870">            &amp;&amp; !bound-&gt;has_ench(ENCH_BOUND_SOUL)</a>
<a name="ln1871">            &amp;&amp; mons_aligned(binder, bound);</a>
<a name="ln1872">}</a>
<a name="ln1873"> </a>
<a name="ln1874">// Function should return false if friendlies shouldn't animate any dead.</a>
<a name="ln1875">// Currently, this only happens if the player is in the middle of butchering</a>
<a name="ln1876">// a corpse (infuriating), or if they are less than satiated. Only applies</a>
<a name="ln1877">// to friendly corpse animators. {due}</a>
<a name="ln1878">static bool _animate_dead_okay(spell_type spell)</a>
<a name="ln1879">{</a>
<a name="ln1880">    // It's always okay in the arena.</a>
<a name="ln1881">    if (crawl_state.game_is_arena())</a>
<a name="ln1882">        return true;</a>
<a name="ln1883"> </a>
<a name="ln1884">    if (you_are_delayed() &amp;&amp; current_delay()-&gt;is_butcher()</a>
<a name="ln1885">        || is_vampire_feeding()</a>
<a name="ln1886">        || you.hunger_state &lt; HS_SATIATED</a>
<a name="ln1887">           &amp;&amp; you.get_base_mutation_level(MUT_HERBIVOROUS) == 0</a>
<a name="ln1888">        || god_hates_spell(spell, you.religion)</a>
<a name="ln1889">        || will_have_passive(passive_t::convert_orcs))</a>
<a name="ln1890">    {</a>
<a name="ln1891">        return false;</a>
<a name="ln1892">    }</a>
<a name="ln1893"> </a>
<a name="ln1894">    return true;</a>
<a name="ln1895">}</a>
<a name="ln1896"> </a>
<a name="ln1897">// Returns true if the spell is something you wouldn't want done if</a>
<a name="ln1898">// you had a friendly target... only returns a meaningful value for</a>
<a name="ln1899">// non-beam spells.</a>
<a name="ln1900">static bool _ms_direct_nasty(spell_type monspell)</a>
<a name="ln1901">{</a>
<a name="ln1902">    return !(get_spell_flags(monspell) &amp; spflag::utility</a>
<a name="ln1903">             || spell_typematch(monspell, spschool::summoning));</a>
<a name="ln1904">}</a>
<a name="ln1905"> </a>
<a name="ln1906">// Checks if the foe *appears* to be immune to negative energy. We</a>
<a name="ln1907">// can't just use foe-&gt;res_negative_energy(), because that'll mean</a>
<a name="ln1908">// monsters will just &quot;know&quot; whether a player is fully life-protected.</a>
<a name="ln1909">static bool _foe_should_res_negative_energy(const actor* foe)</a>
<a name="ln1910">{</a>
<a name="ln1911">    if (foe-&gt;is_player())</a>
<a name="ln1912">    {</a>
<a name="ln1913">        switch (you.undead_state())</a>
<a name="ln1914">        {</a>
<a name="ln1915">        case US_ALIVE:</a>
<a name="ln1916">            // Demonspawn are not demons, and statue form grants only</a>
<a name="ln1917">            // partial resistance.</a>
<a name="ln1918">            return false;</a>
<a name="ln1919">        case US_SEMI_UNDEAD:</a>
<a name="ln1920">            // Non-bloodless vampires do not appear immune.</a>
<a name="ln1921">            return you.hunger_state &lt;= HS_STARVING;</a>
<a name="ln1922">        default:</a>
<a name="ln1923">            return true;</a>
<a name="ln1924">        }</a>
<a name="ln1925">    }</a>
<a name="ln1926"> </a>
<a name="ln1927">    return !(foe-&gt;holiness() &amp; MH_NATURAL);</a>
<a name="ln1928">}</a>
<a name="ln1929"> </a>
<a name="ln1930">static bool _valid_blink_ally(const monster* caster, const monster* target)</a>
<a name="ln1931">{</a>
<a name="ln1932">    return mons_aligned(caster, target) &amp;&amp; caster != target</a>
<a name="ln1933">           &amp;&amp; !target-&gt;no_tele(true, false, true);</a>
<a name="ln1934">}</a>
<a name="ln1935"> </a>
<a name="ln1936">static bool _valid_encircle_ally(const monster* caster, const monster* target,</a>
<a name="ln1937">                                 const coord_def foepos)</a>
<a name="ln1938">{</a>
<a name="ln1939">    return _valid_blink_ally(caster, target)</a>
<a name="ln1940">           &amp;&amp; target-&gt;pos().distance_from(foepos) &gt; 1;</a>
<a name="ln1941">}</a>
<a name="ln1942"> </a>
<a name="ln1943">static bool _valid_blink_away_ally(const monster* caster, const monster* target,</a>
<a name="ln1944">                                   const coord_def foepos)</a>
<a name="ln1945">{</a>
<a name="ln1946">    return _valid_blink_ally(caster, target)</a>
<a name="ln1947">           &amp;&amp; target-&gt;pos().distance_from(foepos) &lt; 3;</a>
<a name="ln1948">}</a>
<a name="ln1949"> </a>
<a name="ln1950">static bool _valid_druids_call_target(const monster* caller, const monster* callee)</a>
<a name="ln1951">{</a>
<a name="ln1952">    return mons_aligned(caller, callee) &amp;&amp; mons_is_beast(callee-&gt;type)</a>
<a name="ln1953">           &amp;&amp; callee-&gt;get_experience_level() &lt;= 20</a>
<a name="ln1954">           &amp;&amp; !callee-&gt;is_shapeshifter()</a>
<a name="ln1955">           &amp;&amp; !caller-&gt;see_cell(callee-&gt;pos())</a>
<a name="ln1956">           &amp;&amp; mons_habitat(*callee) != HT_WATER</a>
<a name="ln1957">           &amp;&amp; mons_habitat(*callee) != HT_LAVA</a>
<a name="ln1958">           &amp;&amp; !callee-&gt;is_travelling();</a>
<a name="ln1959">}</a>
<a name="ln1960"> </a>
<a name="ln1961">static bool _mirrorable(const monster* agent, const monster* mon)</a>
<a name="ln1962">{</a>
<a name="ln1963">    return mon != agent</a>
<a name="ln1964">           &amp;&amp; mons_aligned(mon, agent)</a>
<a name="ln1965">           &amp;&amp; !mon-&gt;is_stationary()</a>
<a name="ln1966">           &amp;&amp; !mon-&gt;is_summoned()</a>
<a name="ln1967">           &amp;&amp; !mons_is_conjured(mon-&gt;type)</a>
<a name="ln1968">           &amp;&amp; !mons_is_unique(mon-&gt;type);</a>
<a name="ln1969">}</a>
<a name="ln1970"> </a>
<a name="ln1971">static bool _valid_aura_of_brilliance_ally(const monster* caster,</a>
<a name="ln1972">                                           const monster* target)</a>
<a name="ln1973">{</a>
<a name="ln1974">    return mons_aligned(caster, target) &amp;&amp; caster != target</a>
<a name="ln1975">           &amp;&amp; target-&gt;is_actual_spellcaster();</a>
<a name="ln1976">}</a>
<a name="ln1977"> </a>
<a name="ln1978"> </a>
<a name="ln1979">/**</a>
<a name="ln1980"> * Print the message that the player sees after a battlecry goes off.</a>
<a name="ln1981"> *</a>
<a name="ln1982"> * @param chief             The monster letting out the battlecry.</a>
<a name="ln1983"> * @param seen_affected     The affected monsters that are visible to the</a>
<a name="ln1984"> *                          player.</a>
<a name="ln1985"> */</a>
<a name="ln1986">static void _print_battlecry_announcement(const monster&amp; chief,</a>
<a name="ln1987">                                          vector&lt;monster*&gt; &amp;seen_affected)</a>
<a name="ln1988">{</a>
<a name="ln1989">    // Disabling detailed frenzy announcement because it's so spammy.</a>
<a name="ln1990">    const msg_channel_type channel = chief.friendly() ? MSGCH_MONSTER_ENCHANT</a>
<a name="ln1991">                                                      : MSGCH_FRIEND_ENCHANT;</a>
<a name="ln1992"> </a>
<a name="ln1993">    if (seen_affected.size() == 1)</a>
<a name="ln1994">    {</a>
<a name="ln1995">        mprf(channel, &quot;%s goes into a battle-frenzy!&quot;,</a>
<a name="ln1996">             seen_affected[0]-&gt;name(DESC_THE).c_str());</a>
<a name="ln1997">        return;</a>
<a name="ln1998">    }</a>
<a name="ln1999"> </a>
<a name="ln2000">    // refer to the group by the most specific name possible. If they're all</a>
<a name="ln2001">    // one monster type; use that name; otherwise, use the genus name (since</a>
<a name="ln2002">    // we restrict this by genus).</a>
<a name="ln2003">    // Note: If we stop restricting by genus, use &quot;foo's allies&quot; instead.</a>
<a name="ln2004">    monster_type first_type = seen_affected[0]-&gt;type;</a>
<a name="ln2005">    const bool generic = any_of(</a>
<a name="ln2006">                                begin(seen_affected), end(seen_affected),</a>
<a name="ln2007">                                [=](const monster *m)</a>
<a name="ln2008">                                { return m-&gt;type != first_type; });</a>
<a name="ln2009">    monster_type group_type = generic ? mons_genus(chief.type) : first_type;</a>
<a name="ln2010"> </a>
<a name="ln2011">    const string ally_desc</a>
<a name="ln2012">        = pluralise_monster(mons_type_name(group_type, DESC_PLAIN));</a>
<a name="ln2013">    mprf(channel, &quot;%s %s go into a battle-frenzy!&quot;,</a>
<a name="ln2014">         chief.friendly() ? &quot;Your&quot; : &quot;The&quot;, ally_desc.c_str());</a>
<a name="ln2015">}</a>
<a name="ln2016"> </a>
<a name="ln2017">/**</a>
<a name="ln2018"> * Let loose a mighty battlecry, inspiring &amp; strengthening nearby foes!</a>
<a name="ln2019"> *</a>
<a name="ln2020"> * @param chief         The monster letting out the battlecry.</a>
<a name="ln2021"> * @param check_only    Whether to perform a 'dry run', only checking whether</a>
<a name="ln2022"> *                      any monsters are potentially affected.</a>
<a name="ln2023"> * @return              Whether any monsters are (or would be) affected.</a>
<a name="ln2024"> */</a>
<a name="ln2025">static bool _battle_cry(const monster&amp; chief, bool check_only = false)</a>
<a name="ln2026">{</a>
<a name="ln2027">    const actor *foe = chief.get_foe();</a>
<a name="ln2028"> </a>
<a name="ln2029">    // Only let loose a battlecry if you have a valid target.</a>
<a name="ln2030">    if (!foe</a>
<a name="ln2031">        || foe-&gt;is_player() &amp;&amp; chief.friendly()</a>
<a name="ln2032">        || !chief.see_cell_no_trans(foe-&gt;pos()))</a>
<a name="ln2033">    {</a>
<a name="ln2034">        return false;</a>
<a name="ln2035">    }</a>
<a name="ln2036"> </a>
<a name="ln2037">    // Don't try to make noise when silent.</a>
<a name="ln2038">    if (chief.is_silenced())</a>
<a name="ln2039">        return false;</a>
<a name="ln2040"> </a>
<a name="ln2041">    int affected = 0;</a>
<a name="ln2042"> </a>
<a name="ln2043">    vector&lt;monster* &gt; seen_affected;</a>
<a name="ln2044">    for (monster_near_iterator mi(chief.pos(), LOS_NO_TRANS); mi; ++mi)</a>
<a name="ln2045">    {</a>
<a name="ln2046">        const monster *mons = *mi;</a>
<a name="ln2047">        // can't buff yourself</a>
<a name="ln2048">        if (mons == &amp;chief)</a>
<a name="ln2049">            continue;</a>
<a name="ln2050"> </a>
<a name="ln2051">        // only buff allies</a>
<a name="ln2052">        if (!mons_aligned(&amp;chief, mons))</a>
<a name="ln2053">            continue;</a>
<a name="ln2054"> </a>
<a name="ln2055">        // no buffing confused/paralysed mons</a>
<a name="ln2056">        if (mons-&gt;berserk_or_insane()</a>
<a name="ln2057">            || mons-&gt;confused()</a>
<a name="ln2058">            || mons-&gt;cannot_move())</a>
<a name="ln2059">        {</a>
<a name="ln2060">            continue;</a>
<a name="ln2061">        }</a>
<a name="ln2062"> </a>
<a name="ln2063">        // already buffed</a>
<a name="ln2064">        if (mons-&gt;has_ench(ENCH_MIGHT))</a>
<a name="ln2065">            continue;</a>
<a name="ln2066"> </a>
<a name="ln2067">        // invalid battlecry target (wrong genus)</a>
<a name="ln2068">        if (mons_genus(mons-&gt;type) != mons_genus(chief.type))</a>
<a name="ln2069">            continue;</a>
<a name="ln2070"> </a>
<a name="ln2071">        if (check_only)</a>
<a name="ln2072">            return true; // just need to check</a>
<a name="ln2073"> </a>
<a name="ln2074">        const int dur = random_range(12, 20) * speed_to_duration(mi-&gt;speed);</a>
<a name="ln2075"> </a>
<a name="ln2076">        mi-&gt;add_ench(mon_enchant(ENCH_MIGHT, 1, &amp;chief, dur));</a>
<a name="ln2077"> </a>
<a name="ln2078">        affected++;</a>
<a name="ln2079">        if (you.can_see(**mi))</a>
<a name="ln2080">            seen_affected.push_back(*mi);</a>
<a name="ln2081"> </a>
<a name="ln2082">        if (mi-&gt;asleep())</a>
<a name="ln2083">            behaviour_event(*mi, ME_DISTURB, 0, chief.pos());</a>
<a name="ln2084">    }</a>
<a name="ln2085"> </a>
<a name="ln2086">    if (affected == 0)</a>
<a name="ln2087">        return false;</a>
<a name="ln2088"> </a>
<a name="ln2089">    // The yell happens whether you happen to see it or not.</a>
<a name="ln2090">    noisy(LOS_DEFAULT_RANGE, chief.pos(), chief.mid);</a>
<a name="ln2091"> </a>
<a name="ln2092">    if (!seen_affected.empty())</a>
<a name="ln2093">        _print_battlecry_announcement(chief, seen_affected);</a>
<a name="ln2094"> </a>
<a name="ln2095">    return true;</a>
<a name="ln2096">}</a>
<a name="ln2097"> </a>
<a name="ln2098">/**</a>
<a name="ln2099"> * Call upon the powers of chaos, applying mostly positive effects to nearby</a>
<a name="ln2100"> * allies!</a>
<a name="ln2101"> *</a>
<a name="ln2102"> * @param mons          The monster carrying out the call of chaos.</a>
<a name="ln2103"> * @param check_only    Whether to perform a 'dry run', only checking whether</a>
<a name="ln2104"> *                      any monsters are potentially affected.</a>
<a name="ln2105"> * @return              Whether any monsters are (or would be) affected.</a>
<a name="ln2106"> */</a>
<a name="ln2107">static bool _mons_call_of_chaos(const monster&amp; mon, bool check_only = false)</a>
<a name="ln2108">{</a>
<a name="ln2109">    const actor *foe = mon.get_foe();</a>
<a name="ln2110"> </a>
<a name="ln2111">    if (!foe</a>
<a name="ln2112">        || foe-&gt;is_player() &amp;&amp; mon.friendly()</a>
<a name="ln2113">        || !mon.see_cell_no_trans(foe-&gt;pos()))</a>
<a name="ln2114">    {</a>
<a name="ln2115">        return false;</a>
<a name="ln2116">    }</a>
<a name="ln2117"> </a>
<a name="ln2118">    int affected = 0;</a>
<a name="ln2119"> </a>
<a name="ln2120">    vector&lt;monster* &gt; seen_affected;</a>
<a name="ln2121">    for (monster_near_iterator mi(mon.pos(), LOS_NO_TRANS); mi; ++mi)</a>
<a name="ln2122">    {</a>
<a name="ln2123">        const monster *mons = *mi;</a>
<a name="ln2124">        // can't buff yourself</a>
<a name="ln2125">        if (mons == &amp;mon)</a>
<a name="ln2126">            continue;</a>
<a name="ln2127"> </a>
<a name="ln2128">        // only buff allies</a>
<a name="ln2129">        if (!mons_aligned(&amp;mon, mons))</a>
<a name="ln2130">            continue;</a>
<a name="ln2131"> </a>
<a name="ln2132">        if (mons_is_firewood(*mons))</a>
<a name="ln2133">            continue;</a>
<a name="ln2134"> </a>
<a name="ln2135">        if (check_only)</a>
<a name="ln2136">            return true; // just need to check</a>
<a name="ln2137"> </a>
<a name="ln2138">        if (mi-&gt;asleep())</a>
<a name="ln2139">            behaviour_event(*mi, ME_DISTURB, 0, mon.pos());</a>
<a name="ln2140"> </a>
<a name="ln2141">        beam_type flavour = random_choose_weighted(150, BEAM_HASTE,</a>
<a name="ln2142">                                                   150, BEAM_MIGHT,</a>
<a name="ln2143">                                                   150, BEAM_BERSERK,</a>
<a name="ln2144">                                                   150, BEAM_AGILITY,</a>
<a name="ln2145">                                                   150, BEAM_RESISTANCE,</a>
<a name="ln2146">                                                   150, BEAM_BLINK_CLOSE,</a>
<a name="ln2147">                                                    15, BEAM_BLINK,</a>
<a name="ln2148">                                                    15, BEAM_SLOW,</a>
<a name="ln2149">                                                    15, BEAM_VULNERABILITY,</a>
<a name="ln2150">                                                    15, BEAM_MALMUTATE,</a>
<a name="ln2151">                                                    15, BEAM_POLYMORPH,</a>
<a name="ln2152">                                                    15, BEAM_INNER_FLAME);</a>
<a name="ln2153"> </a>
<a name="ln2154">        enchant_actor_with_flavour(*mi,</a>
<a name="ln2155">                                   flavour == BEAM_BLINK_CLOSE</a>
<a name="ln2156">                                   ? foe</a>
<a name="ln2157">                                   : &amp;mon,</a>
<a name="ln2158">                                   flavour);</a>
<a name="ln2159"> </a>
<a name="ln2160">        affected++;</a>
<a name="ln2161">        if (you.can_see(**mi))</a>
<a name="ln2162">            seen_affected.push_back(*mi);</a>
<a name="ln2163">    }</a>
<a name="ln2164"> </a>
<a name="ln2165">    if (affected == 0)</a>
<a name="ln2166">        return false;</a>
<a name="ln2167"> </a>
<a name="ln2168">    return true;</a>
<a name="ln2169">}</a>
<a name="ln2170"> </a>
<a name="ln2171">static void _set_door(set&lt;coord_def&gt; door, dungeon_feature_type feat)</a>
<a name="ln2172">{</a>
<a name="ln2173">    for (const auto &amp;dc : door)</a>
<a name="ln2174">    {</a>
<a name="ln2175">        grd(dc) = feat;</a>
<a name="ln2176">        set_terrain_changed(dc);</a>
<a name="ln2177">    }</a>
<a name="ln2178">}</a>
<a name="ln2179"> </a>
<a name="ln2180">static int _tension_door_closed(set&lt;coord_def&gt; door,</a>
<a name="ln2181">                                dungeon_feature_type old_feat)</a>
<a name="ln2182">{</a>
<a name="ln2183">    // this unwind is a bit heavy, but because out-of-los clouds dissipate</a>
<a name="ln2184">    // instantly, they can be wiped out by these door tests.</a>
<a name="ln2185">    unwind_var&lt;map&lt;coord_def, cloud_struct&gt;&gt; cloud_state(env.cloud);</a>
<a name="ln2186">    _set_door(door, DNGN_CLOSED_DOOR);</a>
<a name="ln2187">    const int new_tension = get_tension(GOD_NO_GOD);</a>
<a name="ln2188">    _set_door(door, old_feat);</a>
<a name="ln2189">    return new_tension;</a>
<a name="ln2190">}</a>
<a name="ln2191"> </a>
<a name="ln2192">/**</a>
<a name="ln2193"> * Can any actors and items be pushed out of a doorway? An actor can be pushed</a>
<a name="ln2194"> * for purposes of this check if there is a habitable target location and the</a>
<a name="ln2195"> * actor is either the player or non-hostile. Items can be moved if there is</a>
<a name="ln2196"> * any free space.</a>
<a name="ln2197"> *</a>
<a name="ln2198"> * @param door the door position</a>
<a name="ln2199"> *</a>
<a name="ln2200"> * @return true if any actors and items can be pushed out of the door.</a>
<a name="ln2201"> */</a>
<a name="ln2202">static bool _can_force_door_shut(const coord_def&amp; door)</a>
<a name="ln2203">{</a>
<a name="ln2204">    if (!feat_is_open_door(grd(door)))</a>
<a name="ln2205">        return false;</a>
<a name="ln2206"> </a>
<a name="ln2207">    set&lt;coord_def&gt; all_door;</a>
<a name="ln2208">    find_connected_identical(door, all_door);</a>
<a name="ln2209">    auto veto_spots = vector&lt;coord_def&gt;(all_door.begin(), all_door.end());</a>
<a name="ln2210">    auto door_spots = veto_spots;</a>
<a name="ln2211"> </a>
<a name="ln2212">    for (const auto &amp;dc : all_door)</a>
<a name="ln2213">    {</a>
<a name="ln2214">        // Only attempt to push players and non-hostile monsters out of</a>
<a name="ln2215">        // doorways</a>
<a name="ln2216">        actor* act = actor_at(dc);</a>
<a name="ln2217">        if (act)</a>
<a name="ln2218">        {</a>
<a name="ln2219">            if (act-&gt;is_player()</a>
<a name="ln2220">                || act-&gt;is_monster()</a>
<a name="ln2221">                    &amp;&amp; act-&gt;as_monster()-&gt;attitude != ATT_HOSTILE)</a>
<a name="ln2222">            {</a>
<a name="ln2223">                vector&lt;coord_def&gt; targets = get_push_spaces(dc, true, &amp;veto_spots);</a>
<a name="ln2224">                if (targets.empty())</a>
<a name="ln2225">                    return false;</a>
<a name="ln2226">                veto_spots.push_back(targets.front());</a>
<a name="ln2227">            }</a>
<a name="ln2228">            else</a>
<a name="ln2229">                return false;</a>
<a name="ln2230">        }</a>
<a name="ln2231">        // If there are items in the way, see if there's room to push them</a>
<a name="ln2232">        // out of the way. Having push space for an actor doesn't guarantee</a>
<a name="ln2233">        // push space for items (e.g. with a flying actor over lava).</a>
<a name="ln2234">        if (igrd(dc) != NON_ITEM)</a>
<a name="ln2235">        {</a>
<a name="ln2236">            if (!has_push_spaces(dc, false, &amp;door_spots))</a>
<a name="ln2237">                return false;</a>
<a name="ln2238">        }</a>
<a name="ln2239">    }</a>
<a name="ln2240"> </a>
<a name="ln2241">    // Didn't find any actors or items we couldn't displace</a>
<a name="ln2242">    return true;</a>
<a name="ln2243">}</a>
<a name="ln2244"> </a>
<a name="ln2245">/**</a>
<a name="ln2246"> * Get push spaces for an actor that maximize tension. If there are any push</a>
<a name="ln2247"> * spaces at all, this function is guaranteed to return something.</a>
<a name="ln2248"> *</a>
<a name="ln2249"> * @param pos the position of the actor</a>
<a name="ln2250"> * @param excluded a set of pre-excluded spots</a>
<a name="ln2251"> *</a>
<a name="ln2252"> * @return a vector of coordinates, empty if there are no push spaces at all.</a>
<a name="ln2253"> */</a>
<a name="ln2254">static vector&lt;coord_def&gt; _get_push_spaces_max_tension(const coord_def&amp; pos,</a>
<a name="ln2255">                                            const vector&lt;coord_def&gt;* excluded)</a>
<a name="ln2256">{</a>
<a name="ln2257">    vector&lt;coord_def&gt; possible_spaces = get_push_spaces(pos, true, excluded);</a>
<a name="ln2258">    if (possible_spaces.empty())</a>
<a name="ln2259">        return possible_spaces;</a>
<a name="ln2260">    vector&lt;coord_def&gt; best;</a>
<a name="ln2261">    int max_tension = -1;</a>
<a name="ln2262">    actor *act = actor_at(pos);</a>
<a name="ln2263">    ASSERT(act);</a>
<a name="ln2264"> </a>
<a name="ln2265">    for (auto c : possible_spaces)</a>
<a name="ln2266">    {</a>
<a name="ln2267">        set&lt;coord_def&gt; all_door;</a>
<a name="ln2268">        find_connected_identical(pos, all_door);</a>
<a name="ln2269">        dungeon_feature_type old_feat = grd(pos);</a>
<a name="ln2270"> </a>
<a name="ln2271">        act-&gt;move_to_pos(c);</a>
<a name="ln2272">        int new_tension = _tension_door_closed(all_door, old_feat);</a>
<a name="ln2273">        act-&gt;move_to_pos(pos);</a>
<a name="ln2274"> </a>
<a name="ln2275">        if (new_tension == max_tension)</a>
<a name="ln2276">            best.push_back(c);</a>
<a name="ln2277">        else if (new_tension &gt; max_tension)</a>
<a name="ln2278">        {</a>
<a name="ln2279">            max_tension = new_tension;</a>
<a name="ln2280">            best.clear();</a>
<a name="ln2281">            best.push_back(c);</a>
<a name="ln2282">        }</a>
<a name="ln2283">    }</a>
<a name="ln2284">    return best;</a>
<a name="ln2285">}</a>
<a name="ln2286"> </a>
<a name="ln2287">/**</a>
<a name="ln2288"> * Would forcing a door shut (possibly pushing the player) lower tension too</a>
<a name="ln2289"> * much?</a>
<a name="ln2290"> *</a>
<a name="ln2291"> * @param door the door to check</a>
<a name="ln2292"> *</a>
<a name="ln2293"> * @return true iff forcing the door shut won't lower tension by more than 1/3.</a>
<a name="ln2294"> */</a>
<a name="ln2295">static bool _should_force_door_shut(const coord_def&amp; door)</a>
<a name="ln2296">{</a>
<a name="ln2297">    if (!feat_is_open_door(grd(door)))</a>
<a name="ln2298">        return false;</a>
<a name="ln2299"> </a>
<a name="ln2300">    dungeon_feature_type old_feat = grd(door);</a>
<a name="ln2301"> </a>
<a name="ln2302">    set&lt;coord_def&gt; all_door;</a>
<a name="ln2303">    find_connected_identical(door, all_door);</a>
<a name="ln2304">    auto veto_spots = vector&lt;coord_def&gt;(all_door.begin(), all_door.end());</a>
<a name="ln2305"> </a>
<a name="ln2306">    bool player_in_door = false;</a>
<a name="ln2307">    for (const auto &amp;dc : all_door)</a>
<a name="ln2308">    {</a>
<a name="ln2309">        if (you.pos() == dc)</a>
<a name="ln2310">        {</a>
<a name="ln2311">            player_in_door = true;</a>
<a name="ln2312">            break;</a>
<a name="ln2313">        }</a>
<a name="ln2314">    }</a>
<a name="ln2315"> </a>
<a name="ln2316">    const int cur_tension = get_tension(GOD_NO_GOD);</a>
<a name="ln2317">    coord_def oldpos = you.pos();</a>
<a name="ln2318"> </a>
<a name="ln2319">    if (player_in_door)</a>
<a name="ln2320">    {</a>
<a name="ln2321">        coord_def newpos =</a>
<a name="ln2322">                _get_push_spaces_max_tension(you.pos(), &amp;veto_spots).front();</a>
<a name="ln2323">        you.move_to_pos(newpos);</a>
<a name="ln2324">    }</a>
<a name="ln2325"> </a>
<a name="ln2326">    const int new_tension = _tension_door_closed(all_door, old_feat);</a>
<a name="ln2327"> </a>
<a name="ln2328">    if (player_in_door)</a>
<a name="ln2329">        you.move_to_pos(oldpos);</a>
<a name="ln2330"> </a>
<a name="ln2331">    // If closing the door would reduce player tension by too much, probably</a>
<a name="ln2332">    // it is scarier for the player to leave it open and thus it should be left</a>
<a name="ln2333">    // open</a>
<a name="ln2334"> </a>
<a name="ln2335">    // Currently won't allow tension to be lowered by more than 33%</a>
<a name="ln2336">    return ((cur_tension - new_tension) * 3) &lt;= cur_tension;</a>
<a name="ln2337">}</a>
<a name="ln2338"> </a>
<a name="ln2339">static bool _seal_doors_and_stairs(const monster* warden,</a>
<a name="ln2340">                                   bool check_only = false)</a>
<a name="ln2341">{</a>
<a name="ln2342">    ASSERT(warden);</a>
<a name="ln2343"> </a>
<a name="ln2344">    int num_closed = 0;</a>
<a name="ln2345">    int seal_duration = 80 + random2(80);</a>
<a name="ln2346">    bool player_pushed = false;</a>
<a name="ln2347">    bool had_effect = false;</a>
<a name="ln2348"> </a>
<a name="ln2349">    // Friendly wardens are already excluded by _ms_waste_of_time()</a>
<a name="ln2350">    if (!warden-&gt;can_see(you) || warden-&gt;foe != MHITYOU)</a>
<a name="ln2351">        return false;</a>
<a name="ln2352"> </a>
<a name="ln2353">    // Greedy iteration through doors/stairs that you can see.</a>
<a name="ln2354">    for (radius_iterator ri(you.pos(), LOS_RADIUS, C_SQUARE);</a>
<a name="ln2355">                 ri; ++ri)</a>
<a name="ln2356">    {</a>
<a name="ln2357">        if (feat_is_open_door(grd(*ri)))</a>
<a name="ln2358">        {</a>
<a name="ln2359">            if (!_can_force_door_shut(*ri))</a>
<a name="ln2360">                continue;</a>
<a name="ln2361"> </a>
<a name="ln2362">            // If it's scarier to leave this door open, do so</a>
<a name="ln2363">            if (!_should_force_door_shut(*ri))</a>
<a name="ln2364">                continue;</a>
<a name="ln2365"> </a>
<a name="ln2366">            if (check_only)</a>
<a name="ln2367">                return true;</a>
<a name="ln2368"> </a>
<a name="ln2369">            set&lt;coord_def&gt; all_door;</a>
<a name="ln2370">            find_connected_identical(*ri, all_door);</a>
<a name="ln2371">            auto veto_spots = vector&lt;coord_def&gt;(all_door.begin(), all_door.end());</a>
<a name="ln2372">            auto door_spots = veto_spots;</a>
<a name="ln2373"> </a>
<a name="ln2374">            for (const auto &amp;dc : all_door)</a>
<a name="ln2375">            {</a>
<a name="ln2376">                // If there are things in the way, push them aside</a>
<a name="ln2377">                // This is only reached for the player or non-hostile actors</a>
<a name="ln2378">                actor* act = actor_at(dc);</a>
<a name="ln2379">                if (act)</a>
<a name="ln2380">                {</a>
<a name="ln2381">                    vector&lt;coord_def&gt; targets =</a>
<a name="ln2382">                                _get_push_spaces_max_tension(dc, &amp;veto_spots);</a>
<a name="ln2383">                    // at this point, _can_force_door_shut should have</a>
<a name="ln2384">                    // indicated that the door can be shut.</a>
<a name="ln2385">                    ASSERTM(!targets.empty(), &quot;No push space from (%d,%d)&quot;,</a>
<a name="ln2386">                                                                dc.x, dc.y);</a>
<a name="ln2387">                    coord_def newpos = targets.front();</a>
<a name="ln2388"> </a>
<a name="ln2389">                    actor_at(dc)-&gt;move_to_pos(newpos);</a>
<a name="ln2390">                    if (act-&gt;is_player())</a>
<a name="ln2391">                    {</a>
<a name="ln2392">                        stop_delay(true);</a>
<a name="ln2393">                        player_pushed = true;</a>
<a name="ln2394">                    }</a>
<a name="ln2395">                    veto_spots.push_back(newpos);</a>
<a name="ln2396">                }</a>
<a name="ln2397">                push_items_from(dc, &amp;door_spots);</a>
<a name="ln2398">            }</a>
<a name="ln2399"> </a>
<a name="ln2400">            // Close the door</a>
<a name="ln2401">            bool seen = false;</a>
<a name="ln2402">            vector&lt;coord_def&gt; excludes;</a>
<a name="ln2403">            for (const auto &amp;dc : all_door)</a>
<a name="ln2404">            {</a>
<a name="ln2405">                grd(dc) = DNGN_CLOSED_DOOR;</a>
<a name="ln2406">                set_terrain_changed(dc);</a>
<a name="ln2407">                dungeon_events.fire_position_event(DET_DOOR_CLOSED, dc);</a>
<a name="ln2408"> </a>
<a name="ln2409">                if (is_excluded(dc))</a>
<a name="ln2410">                    excludes.push_back(dc);</a>
<a name="ln2411"> </a>
<a name="ln2412">                if (you.see_cell(dc))</a>
<a name="ln2413">                    seen = true;</a>
<a name="ln2414"> </a>
<a name="ln2415">                had_effect = true;</a>
<a name="ln2416">            }</a>
<a name="ln2417"> </a>
<a name="ln2418">            if (seen)</a>
<a name="ln2419">            {</a>
<a name="ln2420">                for (const auto &amp;dc : all_door)</a>
<a name="ln2421">                {</a>
<a name="ln2422">                    if (env.map_knowledge(dc).seen())</a>
<a name="ln2423">                    {</a>
<a name="ln2424">                        env.map_knowledge(dc).set_feature(DNGN_CLOSED_DOOR);</a>
<a name="ln2425">#ifdef USE_TILE</a>
<a name="ln2426">                        env.tile_bk_bg(dc) = TILE_DNGN_CLOSED_DOOR;</a>
<a name="ln2427">#endif</a>
<a name="ln2428">                    }</a>
<a name="ln2429">                }</a>
<a name="ln2430"> </a>
<a name="ln2431">                update_exclusion_los(excludes);</a>
<a name="ln2432">                ++num_closed;</a>
<a name="ln2433">            }</a>
<a name="ln2434">        }</a>
<a name="ln2435"> </a>
<a name="ln2436">        // Try to seal the door</a>
<a name="ln2437">        if (feat_is_closed_door(grd(*ri)) &amp;&amp; !feat_is_sealed(grd(*ri)))</a>
<a name="ln2438">        {</a>
<a name="ln2439">            if (check_only)</a>
<a name="ln2440">                return true;</a>
<a name="ln2441"> </a>
<a name="ln2442">            set&lt;coord_def&gt; all_door;</a>
<a name="ln2443">            find_connected_identical(*ri, all_door);</a>
<a name="ln2444">            const dungeon_feature_type sealed_feat =</a>
<a name="ln2445">                opc_default(*ri) == OPC_CLEAR ? DNGN_SEALED_CLEAR_DOOR</a>
<a name="ln2446">                                              : DNGN_SEALED_DOOR;</a>
<a name="ln2447">            for (const auto &amp;dc : all_door)</a>
<a name="ln2448">            {</a>
<a name="ln2449">                temp_change_terrain(dc, sealed_feat, seal_duration,</a>
<a name="ln2450">                                    TERRAIN_CHANGE_DOOR_SEAL, warden);</a>
<a name="ln2451">                had_effect = true;</a>
<a name="ln2452">            }</a>
<a name="ln2453">        }</a>
<a name="ln2454">        else if (feat_is_travelable_stair(grd(*ri)))</a>
<a name="ln2455">        {</a>
<a name="ln2456">            if (check_only)</a>
<a name="ln2457">                return true;</a>
<a name="ln2458"> </a>
<a name="ln2459">            dungeon_feature_type stype;</a>
<a name="ln2460">            if (feat_stair_direction(grd(*ri)) == CMD_GO_UPSTAIRS)</a>
<a name="ln2461">                stype = DNGN_SEALED_STAIRS_UP;</a>
<a name="ln2462">            else</a>
<a name="ln2463">                stype = DNGN_SEALED_STAIRS_DOWN;</a>
<a name="ln2464"> </a>
<a name="ln2465">            temp_change_terrain(*ri, stype, seal_duration,</a>
<a name="ln2466">                                TERRAIN_CHANGE_DOOR_SEAL, warden);</a>
<a name="ln2467">            had_effect = true;</a>
<a name="ln2468">        }</a>
<a name="ln2469">    }</a>
<a name="ln2470"> </a>
<a name="ln2471">    if (had_effect)</a>
<a name="ln2472">    {</a>
<a name="ln2473">        ASSERT(!check_only);</a>
<a name="ln2474">        mprf(MSGCH_MONSTER_SPELL, &quot;%s activates a sealing rune.&quot;,</a>
<a name="ln2475">                (warden-&gt;visible_to(&amp;you) ? warden-&gt;name(DESC_THE, true).c_str()</a>
<a name="ln2476">                                          : &quot;Someone&quot;));</a>
<a name="ln2477">        if (num_closed &gt; 1)</a>
<a name="ln2478">            mpr(&quot;The doors slam shut!&quot;);</a>
<a name="ln2479">        else if (num_closed == 1)</a>
<a name="ln2480">            mpr(&quot;A door slams shut!&quot;);</a>
<a name="ln2481"> </a>
<a name="ln2482">        if (player_pushed)</a>
<a name="ln2483">            mpr(&quot;You are pushed out of the doorway!&quot;);</a>
<a name="ln2484"> </a>
<a name="ln2485">        return true;</a>
<a name="ln2486">    }</a>
<a name="ln2487"> </a>
<a name="ln2488">    return false;</a>
<a name="ln2489">}</a>
<a name="ln2490"> </a>
<a name="ln2491">/// Should the given monster cast Still Winds?</a>
<a name="ln2492">static bool _should_still_winds(const monster &amp;caster)</a>
<a name="ln2493">{</a>
<a name="ln2494">    // if it's already running, don't start it again.</a>
<a name="ln2495">    if (env.level_state &amp; LSTATE_STILL_WINDS)</a>
<a name="ln2496">        return false;</a>
<a name="ln2497"> </a>
<a name="ln2498">    // just gonna annoy the player most of the time. don't try to be clever</a>
<a name="ln2499">    if (caster.wont_attack())</a>
<a name="ln2500">        return false;</a>
<a name="ln2501"> </a>
<a name="ln2502">    for (radius_iterator ri(caster.pos(), LOS_NO_TRANS); ri; ++ri)</a>
<a name="ln2503">    {</a>
<a name="ln2504">        const cloud_struct *cloud = cloud_at(*ri);</a>
<a name="ln2505">        if (!cloud)</a>
<a name="ln2506">            continue;</a>
<a name="ln2507"> </a>
<a name="ln2508">        // clouds the player might hide in are worrying.</a>
<a name="ln2509">        if (grid_distance(*ri, you.pos()) &lt;= 3 // decent margin</a>
<a name="ln2510">            &amp;&amp; is_opaque_cloud(cloud-&gt;type)</a>
<a name="ln2511">            &amp;&amp; actor_cloud_immune(you, *cloud))</a>
<a name="ln2512">        {</a>
<a name="ln2513">            return true;</a>
<a name="ln2514">        }</a>
<a name="ln2515"> </a>
<a name="ln2516">        // so are hazardous clouds on allies.</a>
<a name="ln2517">        const monster* mon = monster_at(*ri);</a>
<a name="ln2518">        if (mon &amp;&amp; !actor_cloud_immune(*mon, *cloud))</a>
<a name="ln2519">            return true;</a>
<a name="ln2520">    }</a>
<a name="ln2521"> </a>
<a name="ln2522">    // let's give a pass otherwise.</a>
<a name="ln2523">    return false;</a>
<a name="ln2524">}</a>
<a name="ln2525"> </a>
<a name="ln2526">/// Cast the spell Still Winds, disabling clouds across the level temporarily.</a>
<a name="ln2527">static void _cast_still_winds(monster &amp;caster, mon_spell_slot, bolt&amp;)</a>
<a name="ln2528">{</a>
<a name="ln2529">    ASSERT(!(env.level_state &amp; LSTATE_STILL_WINDS));</a>
<a name="ln2530">    caster.add_ench(ENCH_STILL_WINDS);</a>
<a name="ln2531">}</a>
<a name="ln2532"> </a>
<a name="ln2533">static bool _make_monster_angry(const monster* mon, monster* targ, bool actual)</a>
<a name="ln2534">{</a>
<a name="ln2535">    ASSERT(mon); // XXX: change to const monster &amp;mon</a>
<a name="ln2536">    ASSERT(targ); // XXX: change to monster &amp;targ</a>
<a name="ln2537">    if (mon-&gt;friendly() != targ-&gt;friendly())</a>
<a name="ln2538">        return false;</a>
<a name="ln2539"> </a>
<a name="ln2540">    // targ is guaranteed to have a foe (needs_berserk checks this).</a>
<a name="ln2541">    // Now targ needs to be closer to *its* foe than mon is (otherwise</a>
<a name="ln2542">    // mon might be in the way).</a>
<a name="ln2543"> </a>
<a name="ln2544">    coord_def victim;</a>
<a name="ln2545">    if (targ-&gt;foe == MHITYOU)</a>
<a name="ln2546">        victim = you.pos();</a>
<a name="ln2547">    else if (targ-&gt;foe != MHITNOT)</a>
<a name="ln2548">    {</a>
<a name="ln2549">        const monster* vmons = &amp;menv[targ-&gt;foe];</a>
<a name="ln2550">        if (!vmons-&gt;alive())</a>
<a name="ln2551">            return false;</a>
<a name="ln2552">        victim = vmons-&gt;pos();</a>
<a name="ln2553">    }</a>
<a name="ln2554">    else</a>
<a name="ln2555">    {</a>
<a name="ln2556">        // Should be impossible. needs_berserk should find this case.</a>
<a name="ln2557">        die(&quot;angered by no foe&quot;);</a>
<a name="ln2558">    }</a>
<a name="ln2559"> </a>
<a name="ln2560">    // If mon may be blocking targ from its victim, don't try.</a>
<a name="ln2561">    if (victim.distance_from(targ-&gt;pos()) &gt; victim.distance_from(mon-&gt;pos()))</a>
<a name="ln2562">        return false;</a>
<a name="ln2563"> </a>
<a name="ln2564">    if (!actual)</a>
<a name="ln2565">        return true;</a>
<a name="ln2566"> </a>
<a name="ln2567">    if (you.can_see(*mon))</a>
<a name="ln2568">    {</a>
<a name="ln2569">        if (mon-&gt;type == MONS_QUEEN_BEE &amp;&amp; (targ-&gt;type == MONS_KILLER_BEE ||</a>
<a name="ln2570">                                            targ-&gt;type == MONS_MELIAI))</a>
<a name="ln2571">        {</a>
<a name="ln2572">            mprf(&quot;%s calls on %s to defend %s!&quot;,</a>
<a name="ln2573">                mon-&gt;name(DESC_THE).c_str(),</a>
<a name="ln2574">                targ-&gt;name(DESC_THE).c_str(),</a>
<a name="ln2575">                mon-&gt;pronoun(PRONOUN_OBJECTIVE).c_str());</a>
<a name="ln2576">        }</a>
<a name="ln2577">        else</a>
<a name="ln2578">            mprf(&quot;%s goads %s on!&quot;, mon-&gt;name(DESC_THE).c_str(),</a>
<a name="ln2579">                 targ-&gt;name(DESC_THE).c_str());</a>
<a name="ln2580">    }</a>
<a name="ln2581"> </a>
<a name="ln2582">    targ-&gt;go_berserk(false);</a>
<a name="ln2583"> </a>
<a name="ln2584">    return true;</a>
<a name="ln2585">}</a>
<a name="ln2586"> </a>
<a name="ln2587">static bool _incite_monsters(const monster* mon, bool actual)</a>
<a name="ln2588">{</a>
<a name="ln2589">    if (is_sanctuary(you.pos()) || is_sanctuary(mon-&gt;pos()))</a>
<a name="ln2590">        return false;</a>
<a name="ln2591"> </a>
<a name="ln2592">    // Only things both in LOS of the inciter and within radius 3.</a>
<a name="ln2593">    const int radius = 3;</a>
<a name="ln2594">    int goaded = 0;</a>
<a name="ln2595">    for (monster_near_iterator mi(mon-&gt;pos(), LOS_NO_TRANS); mi; ++mi)</a>
<a name="ln2596">    {</a>
<a name="ln2597">        // XXX: Ugly hack to skip the spellcaster rules for meliai.</a>
<a name="ln2598">        if (*mi == mon || !mi-&gt;needs_berserk(mon-&gt;type != MONS_QUEEN_BEE))</a>
<a name="ln2599">            continue;</a>
<a name="ln2600"> </a>
<a name="ln2601">        if (is_sanctuary(mi-&gt;pos()))</a>
<a name="ln2602">            continue;</a>
<a name="ln2603"> </a>
<a name="ln2604">        // Cannot goad other moths of wrath!</a>
<a name="ln2605">        if (mon-&gt;type == MONS_MOTH_OF_WRATH</a>
<a name="ln2606">            &amp;&amp; mi-&gt;type == MONS_MOTH_OF_WRATH</a>
<a name="ln2607">        // Queen bees can only incite bees.</a>
<a name="ln2608">            || mon-&gt;type == MONS_QUEEN_BEE</a>
<a name="ln2609">               &amp;&amp; mi-&gt;type != MONS_KILLER_BEE &amp;&amp;</a>
<a name="ln2610">                  mi-&gt;type != MONS_MELIAI)</a>
<a name="ln2611">        {</a>
<a name="ln2612">            continue;</a>
<a name="ln2613">        }</a>
<a name="ln2614"> </a>
<a name="ln2615">        if (grid_distance(mon-&gt;pos(), mi-&gt;pos()) &gt; radius)</a>
<a name="ln2616">            continue;</a>
<a name="ln2617"> </a>
<a name="ln2618">        const bool worked = _make_monster_angry(mon, *mi, actual);</a>
<a name="ln2619">        if (worked &amp;&amp; (!actual || !one_chance_in(3 * ++goaded)))</a>
<a name="ln2620">            return true;</a>
<a name="ln2621">    }</a>
<a name="ln2622"> </a>
<a name="ln2623">    return goaded &gt; 0;</a>
<a name="ln2624">}</a>
<a name="ln2625"> </a>
<a name="ln2626">// Spells for a quick get-away.</a>
<a name="ln2627">// Currently only used to get out of a net.</a>
<a name="ln2628">static bool _ms_quick_get_away(spell_type monspell)</a>
<a name="ln2629">{</a>
<a name="ln2630">    switch (monspell)</a>
<a name="ln2631">    {</a>
<a name="ln2632">    case SPELL_TELEPORT_SELF:</a>
<a name="ln2633">    case SPELL_BLINK:</a>
<a name="ln2634">        return true;</a>
<a name="ln2635">    default:</a>
<a name="ln2636">        return false;</a>
<a name="ln2637">    }</a>
<a name="ln2638">}</a>
<a name="ln2639"> </a>
<a name="ln2640">// Is it worth bothering to invoke recall? (Currently defined by there being at</a>
<a name="ln2641">// least 3 things we could actually recall, and then with a probability inversely</a>
<a name="ln2642">// proportional to how many HD of allies are current nearby)</a>
<a name="ln2643">static bool _should_recall(monster* caller)</a>
<a name="ln2644">{</a>
<a name="ln2645">    ASSERT(caller); // XXX: change to monster &amp;caller</a>
<a name="ln2646">    // It's a long recitation - if we're winded, we can't use it.</a>
<a name="ln2647">    if (caller-&gt;has_ench(ENCH_BREATH_WEAPON))</a>
<a name="ln2648">        return false;</a>
<a name="ln2649"> </a>
<a name="ln2650">    int num = 0;</a>
<a name="ln2651">    for (monster_iterator mi; mi; ++mi)</a>
<a name="ln2652">    {</a>
<a name="ln2653">        if (mons_is_recallable(caller, **mi)</a>
<a name="ln2654">            &amp;&amp; !caller-&gt;see_cell_no_trans((*mi)-&gt;pos()))</a>
<a name="ln2655">        {</a>
<a name="ln2656">            ++num;</a>
<a name="ln2657">        }</a>
<a name="ln2658">    }</a>
<a name="ln2659"> </a>
<a name="ln2660">    // Since there are reinforcements we could recall, do we think we need them?</a>
<a name="ln2661">    if (num &gt; 2)</a>
<a name="ln2662">    {</a>
<a name="ln2663">        int ally_hd = 0;</a>
<a name="ln2664">        for (monster_near_iterator mi(caller-&gt;pos(), LOS_NO_TRANS); mi; ++mi)</a>
<a name="ln2665">        {</a>
<a name="ln2666">            if (*mi != caller &amp;&amp; caller-&gt;can_see(**mi)</a>
<a name="ln2667">                &amp;&amp; mons_aligned(caller, *mi)</a>
<a name="ln2668">                &amp;&amp; !mons_is_firewood(**mi))</a>
<a name="ln2669">            {</a>
<a name="ln2670">                ally_hd += mi-&gt;get_experience_level();</a>
<a name="ln2671">            }</a>
<a name="ln2672">        }</a>
<a name="ln2673">        return 25 + roll_dice(2, 22) &gt; ally_hd;</a>
<a name="ln2674">    }</a>
<a name="ln2675">    else</a>
<a name="ln2676">        return false;</a>
<a name="ln2677">}</a>
<a name="ln2678"> </a>
<a name="ln2679">/**</a>
<a name="ln2680"> * Recall a bunch of monsters!</a>
<a name="ln2681"> *</a>
<a name="ln2682"> * @param mons[in] the monster doing the recall</a>
<a name="ln2683"> * @param recall_target the max number of monsters to recall.</a>
<a name="ln2684"> * @returns whether anything was recalled.</a>
<a name="ln2685"> */</a>
<a name="ln2686">bool mons_word_of_recall(monster* mons, int recall_target)</a>
<a name="ln2687">{</a>
<a name="ln2688">    unsigned short num_recalled = 0;</a>
<a name="ln2689">    vector&lt;monster* &gt; mon_list;</a>
<a name="ln2690"> </a>
<a name="ln2691">    // Build the list of recallable monsters and randomize</a>
<a name="ln2692">    for (monster_iterator mi; mi; ++mi)</a>
<a name="ln2693">    {</a>
<a name="ln2694">        // Don't recall ourselves</a>
<a name="ln2695">        if (*mi == mons)</a>
<a name="ln2696">            continue;</a>
<a name="ln2697"> </a>
<a name="ln2698">        if (!mons_is_recallable(mons, **mi))</a>
<a name="ln2699">            continue;</a>
<a name="ln2700"> </a>
<a name="ln2701">        // Don't recall things that are already close to us</a>
<a name="ln2702">        if ((mons &amp;&amp; mons-&gt;see_cell_no_trans((*mi)-&gt;pos()))</a>
<a name="ln2703">            || (!mons &amp;&amp; you.see_cell_no_trans((*mi)-&gt;pos())))</a>
<a name="ln2704">        {</a>
<a name="ln2705">            continue;</a>
<a name="ln2706">        }</a>
<a name="ln2707"> </a>
<a name="ln2708">        mon_list.push_back(*mi);</a>
<a name="ln2709">    }</a>
<a name="ln2710">    shuffle_array(mon_list);</a>
<a name="ln2711"> </a>
<a name="ln2712">    const coord_def target   = (mons) ? mons-&gt;pos() : you.pos();</a>
<a name="ln2713">    const unsigned short foe = (mons) ? mons-&gt;foe   : short{MHITYOU};</a>
<a name="ln2714"> </a>
<a name="ln2715">    // Now actually recall things</a>
<a name="ln2716">    for (monster *mon : mon_list)</a>
<a name="ln2717">    {</a>
<a name="ln2718">        coord_def empty;</a>
<a name="ln2719">        if (find_habitable_spot_near(target, mons_base_type(*mon),</a>
<a name="ln2720">                                     3, false, empty)</a>
<a name="ln2721">            &amp;&amp; mon-&gt;move_to_pos(empty))</a>
<a name="ln2722">        {</a>
<a name="ln2723">            mon-&gt;behaviour = BEH_SEEK;</a>
<a name="ln2724">            mon-&gt;foe = foe;</a>
<a name="ln2725">            ++num_recalled;</a>
<a name="ln2726">            simple_monster_message(*mon, &quot; is recalled.&quot;);</a>
<a name="ln2727">        }</a>
<a name="ln2728">        // Can only recall a couple things at once</a>
<a name="ln2729">        if (num_recalled == recall_target)</a>
<a name="ln2730">            break;</a>
<a name="ln2731">    }</a>
<a name="ln2732">    return num_recalled;</a>
<a name="ln2733">}</a>
<a name="ln2734"> </a>
<a name="ln2735">static bool _valid_vine_spot(coord_def p)</a>
<a name="ln2736">{</a>
<a name="ln2737">    if (actor_at(p) || !monster_habitable_grid(MONS_PLANT, grd(p)))</a>
<a name="ln2738">        return false;</a>
<a name="ln2739"> </a>
<a name="ln2740">    int num_trees = 0;</a>
<a name="ln2741">    bool valid_trees = false;</a>
<a name="ln2742">    for (adjacent_iterator ai(p); ai; ++ai)</a>
<a name="ln2743">    {</a>
<a name="ln2744">        if (feat_is_tree(grd(*ai)))</a>
<a name="ln2745">        {</a>
<a name="ln2746">            // Make sure this spot is not on a diagonal to its only adjacent</a>
<a name="ln2747">            // tree (so that the vines can pull back against the tree properly)</a>
<a name="ln2748">            if (num_trees || !((*ai-p).sgn().x != 0 &amp;&amp; (*ai-p).sgn().y != 0))</a>
<a name="ln2749">            {</a>
<a name="ln2750">                valid_trees = true;</a>
<a name="ln2751">                break;</a>
<a name="ln2752">            }</a>
<a name="ln2753">            else</a>
<a name="ln2754">                ++num_trees;</a>
<a name="ln2755">        }</a>
<a name="ln2756">    }</a>
<a name="ln2757"> </a>
<a name="ln2758">    if (!valid_trees)</a>
<a name="ln2759">        return false;</a>
<a name="ln2760"> </a>
<a name="ln2761">    // Now the connectivity check</a>
<a name="ln2762">    return !plant_forbidden_at(p, true);</a>
<a name="ln2763">}</a>
<a name="ln2764"> </a>
<a name="ln2765">static bool _awaken_vines(monster* mon, bool test_only = false)</a>
<a name="ln2766">{</a>
<a name="ln2767">    if (_is_wiz_cast())</a>
<a name="ln2768">    {</a>
<a name="ln2769">        mprf(&quot;Sorry, this spell isn't supported for dummies!&quot;); //mons dummy</a>
<a name="ln2770">        return false;</a>
<a name="ln2771">    }</a>
<a name="ln2772"> </a>
<a name="ln2773">    vector&lt;coord_def&gt; spots;</a>
<a name="ln2774">    for (radius_iterator ri(mon-&gt;pos(), LOS_NO_TRANS); ri; ++ri)</a>
<a name="ln2775">    {</a>
<a name="ln2776">        if (_valid_vine_spot(*ri))</a>
<a name="ln2777">            spots.push_back(*ri);</a>
<a name="ln2778">    }</a>
<a name="ln2779"> </a>
<a name="ln2780">    shuffle_array(spots);</a>
<a name="ln2781"> </a>
<a name="ln2782">    actor* foe = mon-&gt;get_foe();</a>
<a name="ln2783">    ASSERT(foe);</a>
<a name="ln2784"> </a>
<a name="ln2785">    int num_vines = 1 + random2(3);</a>
<a name="ln2786">    if (mon-&gt;props.exists(&quot;vines_awakened&quot;))</a>
<a name="ln2787">        num_vines = min(num_vines, 3 - mon-&gt;props[&quot;vines_awakened&quot;].get_int());</a>
<a name="ln2788">    bool seen = false;</a>
<a name="ln2789"> </a>
<a name="ln2790">    for (coord_def spot : spots)</a>
<a name="ln2791">    {</a>
<a name="ln2792">        // Don't place vines where they can't see our target</a>
<a name="ln2793">        if (!cell_see_cell(spot, foe-&gt;pos(), LOS_NO_TRANS))</a>
<a name="ln2794">            continue;</a>
<a name="ln2795"> </a>
<a name="ln2796">        // Don't place a vine too near to another existing one</a>
<a name="ln2797">        bool too_close = false;</a>
<a name="ln2798">        for (distance_iterator di(spot, false, true, 3); di; ++di)</a>
<a name="ln2799">        {</a>
<a name="ln2800">            monster* m = monster_at(*di);</a>
<a name="ln2801">            if (m &amp;&amp; m-&gt;type == MONS_SNAPLASHER_VINE)</a>
<a name="ln2802">            {</a>
<a name="ln2803">                too_close = true;</a>
<a name="ln2804">                break;</a>
<a name="ln2805">            }</a>
<a name="ln2806">        }</a>
<a name="ln2807">        if (too_close)</a>
<a name="ln2808">            continue;</a>
<a name="ln2809"> </a>
<a name="ln2810">        // We've found at least one valid spot, so the spell should be castable</a>
<a name="ln2811">        if (test_only)</a>
<a name="ln2812">            return true;</a>
<a name="ln2813"> </a>
<a name="ln2814">        // Actually place the vine and update properties</a>
<a name="ln2815">        if (monster* vine = create_monster(</a>
<a name="ln2816">            mgen_data(MONS_SNAPLASHER_VINE, SAME_ATTITUDE(mon), spot, mon-&gt;foe,</a>
<a name="ln2817">                        MG_FORCE_PLACE)</a>
<a name="ln2818">            .set_summoned(mon, 0, SPELL_AWAKEN_VINES, mon-&gt;god)))</a>
<a name="ln2819">        {</a>
<a name="ln2820">            vine-&gt;props[&quot;vine_awakener&quot;].get_int() = mon-&gt;mid;</a>
<a name="ln2821">            mon-&gt;props[&quot;vines_awakened&quot;].get_int()++;</a>
<a name="ln2822">            mon-&gt;add_ench(mon_enchant(ENCH_AWAKEN_VINES, 1, nullptr, 200));</a>
<a name="ln2823">            --num_vines;</a>
<a name="ln2824">            if (you.can_see(*vine))</a>
<a name="ln2825">                seen = true;</a>
<a name="ln2826">        }</a>
<a name="ln2827"> </a>
<a name="ln2828">        // We've finished placing all our vines</a>
<a name="ln2829">        if (num_vines == 0)</a>
<a name="ln2830">            break;</a>
<a name="ln2831">    }</a>
<a name="ln2832"> </a>
<a name="ln2833">    if (test_only)</a>
<a name="ln2834">        return false;</a>
<a name="ln2835">    else</a>
<a name="ln2836">    {</a>
<a name="ln2837">        if (seen)</a>
<a name="ln2838">            mpr(&quot;Vines fly forth from the trees!&quot;);</a>
<a name="ln2839">        return true;</a>
<a name="ln2840">    }</a>
<a name="ln2841">}</a>
<a name="ln2842"> </a>
<a name="ln2843">static bool _place_druids_call_beast(const monster* druid, monster* beast,</a>
<a name="ln2844">                                     const actor* target)</a>
<a name="ln2845">{</a>
<a name="ln2846">    for (int t = 0; t &lt; 20; ++t)</a>
<a name="ln2847">    {</a>
<a name="ln2848">        // Attempt to find some random spot out of the target's los to place</a>
<a name="ln2849">        // the beast (but not too far away).</a>
<a name="ln2850">        coord_def area_rnd;</a>
<a name="ln2851">        area_rnd.x = random_range(-11, 11);</a>
<a name="ln2852">        area_rnd.y = random_range(-11, 11);</a>
<a name="ln2853">        coord_def area = clamp_in_bounds(target-&gt;pos() + area_rnd);</a>
<a name="ln2854">        if (cell_see_cell(target-&gt;pos(), area, LOS_DEFAULT))</a>
<a name="ln2855">            continue;</a>
<a name="ln2856"> </a>
<a name="ln2857">        coord_def base_spot;</a>
<a name="ln2858">        int tries = 0;</a>
<a name="ln2859">        while (tries &lt; 10 &amp;&amp; base_spot.origin())</a>
<a name="ln2860">        {</a>
<a name="ln2861">            find_habitable_spot_near(area, mons_base_type(*beast), 3, false, base_spot);</a>
<a name="ln2862">            if (cell_see_cell(target-&gt;pos(), base_spot, LOS_DEFAULT))</a>
<a name="ln2863">                base_spot.reset();</a>
<a name="ln2864">            ++tries;</a>
<a name="ln2865">        }</a>
<a name="ln2866"> </a>
<a name="ln2867">        if (base_spot.origin())</a>
<a name="ln2868">            continue;</a>
<a name="ln2869"> </a>
<a name="ln2870">        beast-&gt;move_to_pos(base_spot);</a>
<a name="ln2871"> </a>
<a name="ln2872">        // Wake the beast up and calculate a path to the druid's target.</a>
<a name="ln2873">        // (Note that both BEH_WANDER and MTRAV_PATROL are necessary for it</a>
<a name="ln2874">        // to follow the given path and also not randomly wander off instead)</a>
<a name="ln2875">        beast-&gt;behaviour = BEH_WANDER;</a>
<a name="ln2876">        beast-&gt;foe = druid-&gt;foe;</a>
<a name="ln2877"> </a>
<a name="ln2878">        monster_pathfind mp;</a>
<a name="ln2879">        if (mp.init_pathfind(beast, target-&gt;pos()))</a>
<a name="ln2880">        {</a>
<a name="ln2881">            beast-&gt;travel_path = mp.calc_waypoints();</a>
<a name="ln2882">            if (!beast-&gt;travel_path.empty())</a>
<a name="ln2883">            {</a>
<a name="ln2884">                beast-&gt;target = beast-&gt;travel_path[0];</a>
<a name="ln2885">                beast-&gt;travel_target = MTRAV_PATROL;</a>
<a name="ln2886">            }</a>
<a name="ln2887">        }</a>
<a name="ln2888"> </a>
<a name="ln2889">        // Assign blame (for statistical purposes, mostly)</a>
<a name="ln2890">        mons_add_blame(beast, &quot;called by &quot; + druid-&gt;name(DESC_A, true));</a>
<a name="ln2891"> </a>
<a name="ln2892">        return true;</a>
<a name="ln2893">    }</a>
<a name="ln2894"> </a>
<a name="ln2895">    return false;</a>
<a name="ln2896">}</a>
<a name="ln2897"> </a>
<a name="ln2898">static void _cast_druids_call(const monster* mon)</a>
<a name="ln2899">{</a>
<a name="ln2900">    vector&lt;monster*&gt; mon_list;</a>
<a name="ln2901">    for (monster_iterator mi; mi; ++mi)</a>
<a name="ln2902">    {</a>
<a name="ln2903">        if (_valid_druids_call_target(mon, *mi))</a>
<a name="ln2904">            mon_list.push_back(*mi);</a>
<a name="ln2905">    }</a>
<a name="ln2906"> </a>
<a name="ln2907">    shuffle_array(mon_list);</a>
<a name="ln2908"> </a>
<a name="ln2909">    const actor* target = mon-&gt;get_foe();</a>
<a name="ln2910">    const int num = min((int)mon_list.size(),</a>
<a name="ln2911">                        mon-&gt;get_experience_level() &gt; 10 ? random_range(2, 3)</a>
<a name="ln2912">                                                      : random_range(1, 2));</a>
<a name="ln2913"> </a>
<a name="ln2914">    for (int i = 0; i &lt; num; ++i)</a>
<a name="ln2915">        _place_druids_call_beast(mon, mon_list[i], target);</a>
<a name="ln2916">}</a>
<a name="ln2917"> </a>
<a name="ln2918">static double _angle_between(coord_def origin, coord_def p1, coord_def p2)</a>
<a name="ln2919">{</a>
<a name="ln2920">    double ang0 = atan2(p1.x - origin.x, p1.y - origin.y);</a>
<a name="ln2921">    double ang  = atan2(p2.x - origin.x, p2.y - origin.y);</a>
<a name="ln2922">    return min(fabs(ang - ang0), fabs(ang - ang0 + 2 * PI));</a>
<a name="ln2923">}</a>
<a name="ln2924"> </a>
<a name="ln2925">// Does there already appear to be a bramble wall in this direction?</a>
<a name="ln2926">// We approximate this by seeing if there are at least two briar patches in</a>
<a name="ln2927">// a ray between us and our target, which turns out to be a pretty decent</a>
<a name="ln2928">// metric in practice.</a>
<a name="ln2929">static bool _already_bramble_wall(const monster* mons, coord_def targ)</a>
<a name="ln2930">{</a>
<a name="ln2931">    bolt tracer;</a>
<a name="ln2932">    tracer.source    = mons-&gt;pos();</a>
<a name="ln2933">    tracer.target    = targ;</a>
<a name="ln2934">    tracer.range     = 12;</a>
<a name="ln2935">    tracer.is_tracer = true;</a>
<a name="ln2936">    tracer.pierce    = true;</a>
<a name="ln2937">    tracer.fire();</a>
<a name="ln2938"> </a>
<a name="ln2939">    int briar_count = 0;</a>
<a name="ln2940">    bool targ_reached = false;</a>
<a name="ln2941">    for (coord_def p : tracer.path_taken)</a>
<a name="ln2942">    {</a>
<a name="ln2943">        if (!targ_reached &amp;&amp; p == targ)</a>
<a name="ln2944">            targ_reached = true;</a>
<a name="ln2945">        else if (!targ_reached)</a>
<a name="ln2946">            continue;</a>
<a name="ln2947"> </a>
<a name="ln2948">        if (monster_at(p) &amp;&amp; monster_at(p)-&gt;type == MONS_BRIAR_PATCH)</a>
<a name="ln2949">            ++briar_count;</a>
<a name="ln2950">    }</a>
<a name="ln2951"> </a>
<a name="ln2952">    return briar_count &gt; 1;</a>
<a name="ln2953">}</a>
<a name="ln2954"> </a>
<a name="ln2955">static bool _wall_of_brambles(monster* mons)</a>
<a name="ln2956">{</a>
<a name="ln2957">    mgen_data briar_mg = mgen_data(MONS_BRIAR_PATCH, SAME_ATTITUDE(mons),</a>
<a name="ln2958">                                   coord_def(-1, -1), MHITNOT, MG_FORCE_PLACE);</a>
<a name="ln2959">    briar_mg.set_summoned(mons, 0, 0);</a>
<a name="ln2960"> </a>
<a name="ln2961">    // We want to raise a defensive wall if we think our foe is moving to attack</a>
<a name="ln2962">    // us, and otherwise raise a wall further away to block off their escape.</a>
<a name="ln2963">    // (Each wall type uses different parameters)</a>
<a name="ln2964">    bool defensive = mons-&gt;props[&quot;foe_approaching&quot;].get_bool();</a>
<a name="ln2965"> </a>
<a name="ln2966">    coord_def aim_pos = you.pos();</a>
<a name="ln2967">    coord_def targ_pos = mons-&gt;pos();</a>
<a name="ln2968"> </a>
<a name="ln2969">    // A defensive wall cannot provide any cover if our target is already</a>
<a name="ln2970">    // adjacent, so don't bother creating one.</a>
<a name="ln2971">    if (defensive &amp;&amp; mons-&gt;pos().distance_from(aim_pos) == 1)</a>
<a name="ln2972">        return false;</a>
<a name="ln2973"> </a>
<a name="ln2974">    // Don't raise a non-defensive wall if it looks like there's an existing one</a>
<a name="ln2975">    // in the same direction already (this looks rather silly to see walls</a>
<a name="ln2976">    // springing up in the distance behind already-closed paths, and probably</a>
<a name="ln2977">    // is more likely to aid the player than the monster)</a>
<a name="ln2978">    if (!defensive)</a>
<a name="ln2979">    {</a>
<a name="ln2980">        if (_already_bramble_wall(mons, aim_pos))</a>
<a name="ln2981">            return false;</a>
<a name="ln2982">    }</a>
<a name="ln2983"> </a>
<a name="ln2984">    // Select a random radius for the circle used draw an arc from (affects</a>
<a name="ln2985">    // both shape and distance of the resulting wall)</a>
<a name="ln2986">    int rad = (defensive ? random_range(3, 5)</a>
<a name="ln2987">                         : min(11, mons-&gt;pos().distance_from(you.pos()) + 6));</a>
<a name="ln2988"> </a>
<a name="ln2989">    // Adjust the center of the circle used to draw the arc of the wall if</a>
<a name="ln2990">    // we're raising one defensively, based on both its radius and foe distance.</a>
<a name="ln2991">    // (The idea is the ensure that our foe will end up on the other side of it</a>
<a name="ln2992">    // without always raising the wall in exactly the same shape and position)</a>
<a name="ln2993">    if (defensive)</a>
<a name="ln2994">    {</a>
<a name="ln2995">        coord_def adjust = (targ_pos - aim_pos).sgn();</a>
<a name="ln2996"> </a>
<a name="ln2997">        targ_pos += adjust;</a>
<a name="ln2998">        if (rad == 5)</a>
<a name="ln2999">            targ_pos += adjust;</a>
<a name="ln3000">        if (mons-&gt;pos().distance_from(aim_pos) == 2)</a>
<a name="ln3001">            targ_pos += adjust;</a>
<a name="ln3002">    }</a>
<a name="ln3003"> </a>
<a name="ln3004">    // XXX: There is almost certainly a better way to calculate the points</a>
<a name="ln3005">    //      along the desired arcs, though this code produces the proper look.</a>
<a name="ln3006">    vector&lt;coord_def&gt; points;</a>
<a name="ln3007">    for (distance_iterator di(targ_pos, false, false, rad); di; ++di)</a>
<a name="ln3008">    {</a>
<a name="ln3009">        if (di.radius() == rad || di.radius() == rad - 1)</a>
<a name="ln3010">        {</a>
<a name="ln3011">            if (!actor_at(*di) &amp;&amp; !cell_is_solid(*di))</a>
<a name="ln3012">            {</a>
<a name="ln3013">                if (defensive &amp;&amp; _angle_between(targ_pos, aim_pos, *di) &lt;= PI/4.0</a>
<a name="ln3014">                    || (!defensive</a>
<a name="ln3015">                        &amp;&amp; _angle_between(targ_pos, aim_pos, *di) &lt;= PI/(4.2 + rad/6.0)))</a>
<a name="ln3016">                {</a>
<a name="ln3017">                    points.push_back(*di);</a>
<a name="ln3018">                }</a>
<a name="ln3019">            }</a>
<a name="ln3020">        }</a>
<a name="ln3021">    }</a>
<a name="ln3022"> </a>
<a name="ln3023">    bool seen = false;</a>
<a name="ln3024">    for (coord_def point : points)</a>
<a name="ln3025">    {</a>
<a name="ln3026">        briar_mg.pos = point;</a>
<a name="ln3027">        monster* briar = create_monster(briar_mg, false);</a>
<a name="ln3028">        if (briar)</a>
<a name="ln3029">        {</a>
<a name="ln3030">            briar-&gt;add_ench(mon_enchant(ENCH_SHORT_LIVED, 1, nullptr, 80 + random2(100)));</a>
<a name="ln3031">            if (you.can_see(*briar))</a>
<a name="ln3032">                seen = true;</a>
<a name="ln3033">        }</a>
<a name="ln3034">    }</a>
<a name="ln3035"> </a>
<a name="ln3036">    if (seen)</a>
<a name="ln3037">        mpr(&quot;Thorny briars emerge from the ground!&quot;);</a>
<a name="ln3038"> </a>
<a name="ln3039">    return true;</a>
<a name="ln3040">}</a>
<a name="ln3041"> </a>
<a name="ln3042">/**</a>
<a name="ln3043"> * Make the given monster cast the spell &quot;Corrupting Pulse&quot;, corrupting</a>
<a name="ln3044"> * (temporarily malmutating) all creatures in LOS.</a>
<a name="ln3045"> *</a>
<a name="ln3046"> * @param mons  The monster in question.</a>
<a name="ln3047"> */</a>
<a name="ln3048">static void _corrupting_pulse(monster *mons)</a>
<a name="ln3049">{</a>
<a name="ln3050">    if (cell_see_cell(you.pos(), mons-&gt;pos(), LOS_DEFAULT))</a>
<a name="ln3051">    {</a>
<a name="ln3052">        targeter_radius hitfunc(mons, LOS_SOLID);</a>
<a name="ln3053">        flash_view_delay(UA_MONSTER, MAGENTA, 300, &amp;hitfunc);</a>
<a name="ln3054"> </a>
<a name="ln3055">        if (!is_sanctuary(you.pos())</a>
<a name="ln3056">            &amp;&amp; cell_see_cell(you.pos(), mons-&gt;pos(), LOS_SOLID))</a>
<a name="ln3057">        {</a>
<a name="ln3058">            int num_mutations = one_chance_in(4) ? 2 : 1;</a>
<a name="ln3059">            for (int i = 0; i &lt; num_mutations; ++i)</a>
<a name="ln3060">                temp_mutate(RANDOM_CORRUPT_MUTATION, &quot;wretched star&quot;);</a>
<a name="ln3061">        }</a>
<a name="ln3062">    }</a>
<a name="ln3063"> </a>
<a name="ln3064">    for (radius_iterator ri(mons-&gt;pos(), LOS_RADIUS, C_SQUARE); ri; ++ri)</a>
<a name="ln3065">    {</a>
<a name="ln3066">        monster *m = monster_at(*ri);</a>
<a name="ln3067">        if (m &amp;&amp; cell_see_cell(mons-&gt;pos(), *ri, LOS_SOLID_SEE)</a>
<a name="ln3068">            &amp;&amp; !mons_aligned(mons, m))</a>
<a name="ln3069">        {</a>
<a name="ln3070">            m-&gt;corrupt();</a>
<a name="ln3071">        }</a>
<a name="ln3072">    }</a>
<a name="ln3073">}</a>
<a name="ln3074"> </a>
<a name="ln3075">// Returns the clone just created (null otherwise)</a>
<a name="ln3076">monster* cast_phantom_mirror(monster* mons, monster* targ, int hp_perc, int summ_type)</a>
<a name="ln3077">{</a>
<a name="ln3078">    // Create clone.</a>
<a name="ln3079">    monster *mirror = clone_mons(targ, true);</a>
<a name="ln3080"> </a>
<a name="ln3081">    // Abort if we failed to place the monster for some reason.</a>
<a name="ln3082">    if (!mirror)</a>
<a name="ln3083">        return nullptr;</a>
<a name="ln3084"> </a>
<a name="ln3085">    // Unentangle the real monster.</a>
<a name="ln3086">    if (mons-&gt;is_constricted())</a>
<a name="ln3087">        mons-&gt;stop_being_constricted();</a>
<a name="ln3088"> </a>
<a name="ln3089">    mons_clear_trapping_net(mons);</a>
<a name="ln3090"> </a>
<a name="ln3091">    // Don't leak the real one with the targeting interface.</a>
<a name="ln3092">    if (you.prev_targ == mons-&gt;mindex())</a>
<a name="ln3093">    {</a>
<a name="ln3094">        you.prev_targ = MHITNOT;</a>
<a name="ln3095">        crawl_state.cancel_cmd_repeat();</a>
<a name="ln3096">    }</a>
<a name="ln3097">    mons-&gt;reset_client_id();</a>
<a name="ln3098"> </a>
<a name="ln3099">    mirror-&gt;mark_summoned(5, true, summ_type);</a>
<a name="ln3100">    mirror-&gt;add_ench(ENCH_PHANTOM_MIRROR);</a>
<a name="ln3101">    mirror-&gt;summoner = mons-&gt;mid;</a>
<a name="ln3102">    mirror-&gt;hit_points = max(mirror-&gt;hit_points * hp_perc / 100, 1);</a>
<a name="ln3103">    mirror-&gt;max_hit_points = max(mirror-&gt;max_hit_points * hp_perc / 100, 1);</a>
<a name="ln3104"> </a>
<a name="ln3105">    // Sometimes swap the two monsters, so as to disguise the original and the</a>
<a name="ln3106">    // copy.</a>
<a name="ln3107">    if (coinflip())</a>
<a name="ln3108">        targ-&gt;swap_with(mirror);</a>
<a name="ln3109"> </a>
<a name="ln3110">    return mirror;</a>
<a name="ln3111">}</a>
<a name="ln3112"> </a>
<a name="ln3113">static bool _trace_los(monster* agent, bool (*vulnerable)(actor*))</a>
<a name="ln3114">{</a>
<a name="ln3115">    bolt tracer;</a>
<a name="ln3116">    tracer.foe_ratio = 0;</a>
<a name="ln3117">    for (actor_near_iterator ai(agent, LOS_NO_TRANS); ai; ++ai)</a>
<a name="ln3118">    {</a>
<a name="ln3119">        if (agent == *ai || !vulnerable(*ai))</a>
<a name="ln3120">            continue;</a>
<a name="ln3121"> </a>
<a name="ln3122">        if (mons_aligned(agent, *ai))</a>
<a name="ln3123">        {</a>
<a name="ln3124">            tracer.friend_info.count++;</a>
<a name="ln3125">            tracer.friend_info.power +=</a>
<a name="ln3126">                    ai-&gt;is_player() ? you.experience_level</a>
<a name="ln3127">                                    : ai-&gt;as_monster()-&gt;get_experience_level();</a>
<a name="ln3128">        }</a>
<a name="ln3129">        else</a>
<a name="ln3130">        {</a>
<a name="ln3131">            tracer.foe_info.count++;</a>
<a name="ln3132">            tracer.foe_info.power +=</a>
<a name="ln3133">                    ai-&gt;is_player() ? you.experience_level</a>
<a name="ln3134">                                    : ai-&gt;as_monster()-&gt;get_experience_level();</a>
<a name="ln3135">        }</a>
<a name="ln3136">    }</a>
<a name="ln3137">    return mons_should_fire(tracer);</a>
<a name="ln3138">}</a>
<a name="ln3139"> </a>
<a name="ln3140">static bool _tornado_vulnerable(actor* victim)</a>
<a name="ln3141">{</a>
<a name="ln3142">    return !victim-&gt;res_tornado();</a>
<a name="ln3143">}</a>
<a name="ln3144"> </a>
<a name="ln3145">static bool _torment_vulnerable(actor* victim)</a>
<a name="ln3146">{</a>
<a name="ln3147">    if (victim-&gt;is_player())</a>
<a name="ln3148">        return !player_res_torment(false);</a>
<a name="ln3149"> </a>
<a name="ln3150">    return !victim-&gt;res_torment();</a>
<a name="ln3151">}</a>
<a name="ln3152"> </a>
<a name="ln3153">static bool _elec_vulnerable(actor* victim)</a>
<a name="ln3154">{</a>
<a name="ln3155">    return victim-&gt;res_elec() &lt; 3;</a>
<a name="ln3156">}</a>
<a name="ln3157"> </a>
<a name="ln3158">static bool _mutation_vulnerable(actor* victim)</a>
<a name="ln3159">{</a>
<a name="ln3160">    return victim-&gt;can_mutate();</a>
<a name="ln3161">}</a>
<a name="ln3162"> </a>
<a name="ln3163">static void _cast_black_mark(monster* agent)</a>
<a name="ln3164">{</a>
<a name="ln3165">    for (actor_near_iterator ai(agent, LOS_NO_TRANS); ai; ++ai)</a>
<a name="ln3166">    {</a>
<a name="ln3167">        if (ai-&gt;is_player() || !mons_aligned(*ai, agent))</a>
<a name="ln3168">            continue;</a>
<a name="ln3169">        monster* mon = ai-&gt;as_monster();</a>
<a name="ln3170"> </a>
<a name="ln3171">        if (!mon-&gt;has_ench(ENCH_BLACK_MARK)</a>
<a name="ln3172">            &amp;&amp; mons_has_attacks(*mon))</a>
<a name="ln3173">        {</a>
<a name="ln3174">            mon-&gt;add_ench(ENCH_BLACK_MARK);</a>
<a name="ln3175">            simple_monster_message(*mon, &quot; begins absorbing vital energies!&quot;);</a>
<a name="ln3176">        }</a>
<a name="ln3177">    }</a>
<a name="ln3178">}</a>
<a name="ln3179"> </a>
<a name="ln3180">void aura_of_brilliance(monster* agent)</a>
<a name="ln3181">{</a>
<a name="ln3182">    bool did_something = false;</a>
<a name="ln3183">    for (actor_near_iterator ai(agent, LOS_NO_TRANS); ai; ++ai)</a>
<a name="ln3184">    {</a>
<a name="ln3185">        if (ai-&gt;is_player() || !mons_aligned(*ai, agent))</a>
<a name="ln3186">            continue;</a>
<a name="ln3187">        monster* mon = ai-&gt;as_monster();</a>
<a name="ln3188">        if (_valid_aura_of_brilliance_ally(agent, mon))</a>
<a name="ln3189">        {</a>
<a name="ln3190">            if (!mon-&gt;has_ench(ENCH_EMPOWERED_SPELLS) &amp;&amp; you.can_see(*mon))</a>
<a name="ln3191">            {</a>
<a name="ln3192">               mprf(&quot;%s is empowered by %s aura!&quot;,</a>
<a name="ln3193">                    mon-&gt;name(DESC_THE).c_str(),</a>
<a name="ln3194">                    apostrophise(agent-&gt;name(DESC_THE)).c_str());</a>
<a name="ln3195">            }</a>
<a name="ln3196"> </a>
<a name="ln3197">            mon_enchant ench = mon-&gt;get_ench(ENCH_EMPOWERED_SPELLS);</a>
<a name="ln3198">            if (ench.ench != ENCH_NONE)</a>
<a name="ln3199">                mon-&gt;update_ench(ench);</a>
<a name="ln3200">            else</a>
<a name="ln3201">                mon-&gt;add_ench(mon_enchant(ENCH_EMPOWERED_SPELLS, 1, agent));</a>
<a name="ln3202"> </a>
<a name="ln3203">            did_something = true;</a>
<a name="ln3204">        }</a>
<a name="ln3205">    }</a>
<a name="ln3206"> </a>
<a name="ln3207">    if (!did_something)</a>
<a name="ln3208">        agent-&gt;del_ench(ENCH_BRILLIANCE_AURA);</a>
<a name="ln3209">}</a>
<a name="ln3210"> </a>
<a name="ln3211">static bool _glaciate_tracer(monster *caster, int pow, coord_def aim)</a>
<a name="ln3212">{</a>
<a name="ln3213">    targeter_cone hitfunc(caster, spell_range(SPELL_GLACIATE, pow));</a>
<a name="ln3214">    hitfunc.set_aim(aim);</a>
<a name="ln3215"> </a>
<a name="ln3216">    mon_attitude_type castatt = caster-&gt;temp_attitude();</a>
<a name="ln3217">    int friendly = 0, enemy = 0;</a>
<a name="ln3218"> </a>
<a name="ln3219">    for (const auto &amp;entry : hitfunc.zapped)</a>
<a name="ln3220">    {</a>
<a name="ln3221">        if (entry.second &lt;= 0)</a>
<a name="ln3222">            continue;</a>
<a name="ln3223"> </a>
<a name="ln3224">        const actor *victim = actor_at(entry.first);</a>
<a name="ln3225">        if (!victim)</a>
<a name="ln3226">            continue;</a>
<a name="ln3227"> </a>
<a name="ln3228">        if (mons_atts_aligned(castatt, victim-&gt;temp_attitude()))</a>
<a name="ln3229">        {</a>
<a name="ln3230">            if (victim-&gt;is_player() &amp;&amp; !(caster-&gt;holiness() &amp; MH_DEMONIC))</a>
<a name="ln3231">                return false; // never glaciate the player! except demons</a>
<a name="ln3232">            friendly += victim-&gt;get_experience_level();</a>
<a name="ln3233">        }</a>
<a name="ln3234">        else</a>
<a name="ln3235">            enemy += victim-&gt;get_experience_level();</a>
<a name="ln3236">    }</a>
<a name="ln3237"> </a>
<a name="ln3238">    return enemy &gt; friendly;</a>
<a name="ln3239">}</a>
<a name="ln3240"> </a>
<a name="ln3241">bool mons_should_cloud_cone(monster* agent, int power, const coord_def pos)</a>
<a name="ln3242">{</a>
<a name="ln3243">    targeter_shotgun hitfunc(agent, CLOUD_CONE_BEAM_COUNT,</a>
<a name="ln3244">                              spell_range(SPELL_CLOUD_CONE, power));</a>
<a name="ln3245"> </a>
<a name="ln3246">    hitfunc.set_aim(pos);</a>
<a name="ln3247"> </a>
<a name="ln3248">    bolt tracer;</a>
<a name="ln3249">    tracer.foe_ratio = 80;</a>
<a name="ln3250">    tracer.source_id = agent-&gt;mid;</a>
<a name="ln3251">    tracer.target = pos;</a>
<a name="ln3252">    for (actor_near_iterator ai(agent, LOS_NO_TRANS); ai; ++ai)</a>
<a name="ln3253">    {</a>
<a name="ln3254">        if (hitfunc.is_affected(ai-&gt;pos()) == AFF_NO)</a>
<a name="ln3255">            continue;</a>
<a name="ln3256"> </a>
<a name="ln3257">        if (mons_aligned(agent, *ai))</a>
<a name="ln3258">        {</a>
<a name="ln3259">            tracer.friend_info.count++;</a>
<a name="ln3260">            tracer.friend_info.power += ai-&gt;get_experience_level();</a>
<a name="ln3261">        }</a>
<a name="ln3262">        else</a>
<a name="ln3263">        {</a>
<a name="ln3264">            tracer.foe_info.count++;</a>
<a name="ln3265">            tracer.foe_info.power += ai-&gt;get_experience_level();</a>
<a name="ln3266">        }</a>
<a name="ln3267">    }</a>
<a name="ln3268"> </a>
<a name="ln3269">    return mons_should_fire(tracer);</a>
<a name="ln3270">}</a>
<a name="ln3271"> </a>
<a name="ln3272">/**</a>
<a name="ln3273"> * Is this a feature that we can Awaken?</a>
<a name="ln3274"> *</a>
<a name="ln3275"> * @param   feat The feature type.</a>
<a name="ln3276"> * @returns If the feature is a valid feature that we can Awaken Earth on.</a>
<a name="ln3277"> */</a>
<a name="ln3278">static bool _feat_is_awakenable(dungeon_feature_type feat)</a>
<a name="ln3279">{</a>
<a name="ln3280">    return feat == DNGN_ROCK_WALL || feat == DNGN_CLEAR_ROCK_WALL;</a>
<a name="ln3281">}</a>
<a name="ln3282"> </a>
<a name="ln3283">/**</a>
<a name="ln3284"> * Pick a target for Awaken Earth.</a>
<a name="ln3285"> *</a>
<a name="ln3286"> *  @param  mon       The monster casting</a>
<a name="ln3287"> *  @return The target square - out of bounds if no target was found.</a>
<a name="ln3288"> */</a>
<a name="ln3289">static coord_def _mons_awaken_earth_target(const monster &amp;mon)</a>
<a name="ln3290">{</a>
<a name="ln3291">    coord_def pos = mon.target;</a>
<a name="ln3292"> </a>
<a name="ln3293">    // First up, see if we can see our target, and if they're in a good spot</a>
<a name="ln3294">    // to pick on them. If so, do that.</a>
<a name="ln3295">    if (in_bounds(pos) &amp;&amp; mon.see_cell(pos)</a>
<a name="ln3296">        &amp;&amp; count_neighbours_with_func(pos, &amp;_feat_is_awakenable) &gt; 0)</a>
<a name="ln3297">    {</a>
<a name="ln3298">        return pos;</a>
<a name="ln3299">    }</a>
<a name="ln3300"> </a>
<a name="ln3301">    // Either we can't see our target, or they're not adjacent to walls.</a>
<a name="ln3302">    // Step back towards the caster from the target, and see if we can find</a>
<a name="ln3303">    // a better wall for this.</a>
<a name="ln3304">    const coord_def start_pos = mon.pos();</a>
<a name="ln3305"> </a>
<a name="ln3306">    ray_def ray;</a>
<a name="ln3307">    fallback_ray(pos, start_pos, ray); // straight line from them to mon</a>
<a name="ln3308"> </a>
<a name="ln3309">    unordered_set&lt;coord_def&gt; candidates;</a>
<a name="ln3310"> </a>
<a name="ln3311">    // Candidates: everything on or adjacent to a straight line to the target.</a>
<a name="ln3312">    // Strongly prefer cells where we can get lots of elementals.</a>
<a name="ln3313">    while (in_bounds(pos) &amp;&amp; pos != start_pos)</a>
<a name="ln3314">    {</a>
<a name="ln3315">        for (adjacent_iterator ai(pos, false); ai; ++ai)</a>
<a name="ln3316">            if (mon.see_cell(pos))</a>
<a name="ln3317">                candidates.insert(*ai);</a>
<a name="ln3318"> </a>
<a name="ln3319">        ray.advance();</a>
<a name="ln3320">        pos = ray.pos();</a>
<a name="ln3321">    }</a>
<a name="ln3322"> </a>
<a name="ln3323">    vector&lt;coord_weight&gt; targets;</a>
<a name="ln3324">    for (coord_def candidate : candidates)</a>
<a name="ln3325">    {</a>
<a name="ln3326">        int neighbours = count_neighbours_with_func(candidate,</a>
<a name="ln3327">                                                    &amp;_feat_is_awakenable);</a>
<a name="ln3328"> </a>
<a name="ln3329">        // We can target solid cells, which themselves will awaken, so count</a>
<a name="ln3330">        // those as well.</a>
<a name="ln3331">        if (_feat_is_awakenable(grd(candidate)))</a>
<a name="ln3332">            neighbours++;</a>
<a name="ln3333"> </a>
<a name="ln3334">        if (neighbours &gt; 0)</a>
<a name="ln3335">            targets.emplace_back(candidate, neighbours * neighbours);</a>
<a name="ln3336">    }</a>
<a name="ln3337"> </a>
<a name="ln3338">    coord_def* choice = random_choose_weighted(targets);</a>
<a name="ln3339">    return choice ? *choice : coord_def(GXM+1, GYM+1);</a>
<a name="ln3340">}</a>
<a name="ln3341"> </a>
<a name="ln3342">/**</a>
<a name="ln3343"> * Get the fraction of damage done by the given beam that's to enemies,</a>
<a name="ln3344"> * multiplied by the given scale.</a>
<a name="ln3345"> */</a>
<a name="ln3346">static int _get_dam_fraction(const bolt &amp;tracer, int scale)</a>
<a name="ln3347">{</a>
<a name="ln3348">    if (!tracer.foe_info.power)</a>
<a name="ln3349">        return 0;</a>
<a name="ln3350">    return tracer.foe_info.power * scale</a>
<a name="ln3351">            / (tracer.foe_info.power + tracer.friend_info.power);</a>
<a name="ln3352">}</a>
<a name="ln3353"> </a>
<a name="ln3354">/**</a>
<a name="ln3355"> * Pick a target for Ghostly Sacrifice.</a>
<a name="ln3356"> *</a>
<a name="ln3357"> *  @param  caster       The monster casting the spell.</a>
<a name="ln3358"> *                      TODO: constify (requires mon_spell_beam param const</a>
<a name="ln3359"> *  @return The target square, or an out of bounds coord if none was found.</a>
<a name="ln3360"> */</a>
<a name="ln3361">static coord_def _mons_ghostly_sacrifice_target(const monster &amp;caster,</a>
<a name="ln3362">                                                bolt tracer)</a>
<a name="ln3363">{</a>
<a name="ln3364">    const int dam_scale = 1000;</a>
<a name="ln3365">    int best_dam_fraction = dam_scale / 2;</a>
<a name="ln3366">    coord_def best_target = coord_def(GXM+1, GYM+1); // initially out of bounds</a>
<a name="ln3367">    tracer.ex_size = 1;</a>
<a name="ln3368"> </a>
<a name="ln3369">    for (monster_near_iterator mi(&amp;caster, LOS_NO_TRANS); mi; ++mi)</a>
<a name="ln3370">    {</a>
<a name="ln3371">        if (*mi == &amp;caster)</a>
<a name="ln3372">            continue; // don't blow yourself up!</a>
<a name="ln3373"> </a>
<a name="ln3374">        if (!mons_aligned(&amp;caster, *mi))</a>
<a name="ln3375">            continue; // can only blow up allies ;)</a>
<a name="ln3376"> </a>
<a name="ln3377">        tracer.target = mi-&gt;pos();</a>
<a name="ln3378">        fire_tracer(&amp;caster, tracer, true, true);</a>
<a name="ln3379">        if (mons_is_threatening(**mi)) // only care about sacrificing real mons</a>
<a name="ln3380">            tracer.friend_info.power += mi-&gt;get_experience_level() * 2;</a>
<a name="ln3381"> </a>
<a name="ln3382">        const int dam_fraction = _get_dam_fraction(tracer, dam_scale);</a>
<a name="ln3383">        dprf(&quot;if sacrificing %s (at %d,%d): ratio %d/%d&quot;,</a>
<a name="ln3384">             mi-&gt;name(DESC_A, true).c_str(),</a>
<a name="ln3385">             best_target.x, best_target.y, dam_fraction, dam_scale);</a>
<a name="ln3386">        if (dam_fraction &gt; best_dam_fraction)</a>
<a name="ln3387">        {</a>
<a name="ln3388">            best_target = mi-&gt;pos();</a>
<a name="ln3389">            best_dam_fraction = dam_fraction;</a>
<a name="ln3390">            dprf(&quot;setting best target&quot;);</a>
<a name="ln3391">        }</a>
<a name="ln3392">    }</a>
<a name="ln3393"> </a>
<a name="ln3394">    return best_target;</a>
<a name="ln3395">}</a>
<a name="ln3396"> </a>
<a name="ln3397">/// Everything short of the actual explosion. Returns whether to explode.</a>
<a name="ln3398">static bool _prepare_ghostly_sacrifice(monster &amp;caster, bolt &amp;beam)</a>
<a name="ln3399">{</a>
<a name="ln3400">    if (!in_bounds(beam.target))</a>
<a name="ln3401">        return false; // assert?</a>
<a name="ln3402"> </a>
<a name="ln3403">    monster* victim = monster_at(beam.target);</a>
<a name="ln3404">    if (!victim)</a>
<a name="ln3405">        return false; // assert?</a>
<a name="ln3406"> </a>
<a name="ln3407">    if (you.see_cell(victim-&gt;pos()))</a>
<a name="ln3408">    {</a>
<a name="ln3409">        mprf(&quot;%s animating energy erupts into ghostly fire!&quot;,</a>
<a name="ln3410">             apostrophise(victim-&gt;name(DESC_THE)).c_str());</a>
<a name="ln3411">    }</a>
<a name="ln3412">    monster_die(*victim, &amp;caster, true);</a>
<a name="ln3413">    return true;</a>
<a name="ln3414">}</a>
<a name="ln3415"> </a>
<a name="ln3416">/// Setup a negative energy explosion.</a>
<a name="ln3417">static void _setup_ghostly_beam(bolt &amp;beam, int power, int dice)</a>
<a name="ln3418">{</a>
<a name="ln3419">    beam.colour   = CYAN;</a>
<a name="ln3420">    beam.name     = &quot;ghostly fireball&quot;;</a>
<a name="ln3421">    beam.damage   = dice_def(dice, 6 + power / 13);</a>
<a name="ln3422">    beam.hit      = 40;</a>
<a name="ln3423">    beam.flavour  = BEAM_NEG;</a>
<a name="ln3424">    beam.is_explosion = true;</a>
<a name="ln3425">}</a>
<a name="ln3426"> </a>
<a name="ln3427">/// Setup and target a ghostly sacrifice explosion.</a>
<a name="ln3428">static void _setup_ghostly_sacrifice_beam(bolt&amp; beam, const monster&amp; caster,</a>
<a name="ln3429">                                          int power)</a>
<a name="ln3430">{</a>
<a name="ln3431">    _setup_ghostly_beam(beam, power, 5);</a>
<a name="ln3432">    // Future-proofing: your shadow keeps your targetting.</a>
<a name="ln3433">    if (_caster_is_player_shadow(caster))</a>
<a name="ln3434">        return;</a>
<a name="ln3435"> </a>
<a name="ln3436">    beam.target = _mons_ghostly_sacrifice_target(caster, beam);</a>
<a name="ln3437">    beam.aimed_at_spot = true;  // to get noise to work properly</a>
<a name="ln3438">}</a>
<a name="ln3439"> </a>
<a name="ln3440">static function&lt;bool(const monster&amp;)&gt; _setup_hex_check(spell_type spell)</a>
<a name="ln3441">{</a>
<a name="ln3442">    return [spell](const monster&amp; caster) {</a>
<a name="ln3443">        return _worth_hexing(caster, spell);</a>
<a name="ln3444">    };</a>
<a name="ln3445">}</a>
<a name="ln3446"> </a>
<a name="ln3447">/**</a>
<a name="ln3448"> * Does the given monster think it's worth casting the given hex at its current</a>
<a name="ln3449"> * target?</a>
<a name="ln3450"> *</a>
<a name="ln3451"> * XXX: very strongly consider removing this logic!</a>
<a name="ln3452"> *</a>
<a name="ln3453"> * @param caster    The monster casting the hex.</a>
<a name="ln3454"> * @param spell     The spell to cast; e.g. SPELL_DIMENSIONAL_ANCHOR.</a>
<a name="ln3455"> * @return          Whether the monster thinks it's worth trying to beat the</a>
<a name="ln3456"> *                  defender's magic resistance.</a>
<a name="ln3457"> */</a>
<a name="ln3458">static bool _worth_hexing(const monster &amp;caster, spell_type spell)</a>
<a name="ln3459">{</a>
<a name="ln3460">    const actor* foe = caster.get_foe();</a>
<a name="ln3461">    if (!foe)</a>
<a name="ln3462">        return false; // simplifies later checks</a>
<a name="ln3463"> </a>
<a name="ln3464">    // Occasionally we don't estimate... just fire and see.</a>
<a name="ln3465">    if (one_chance_in(5))</a>
<a name="ln3466">        return true;</a>
<a name="ln3467"> </a>
<a name="ln3468">    // Only intelligent monsters estimate.</a>
<a name="ln3469">    if (mons_intel(caster) &lt; I_HUMAN)</a>
<a name="ln3470">        return true;</a>
<a name="ln3471"> </a>
<a name="ln3472">    // Simulate Strip Resistance's 1/3 chance of ignoring MR</a>
<a name="ln3473">    if (spell == SPELL_STRIP_RESISTANCE &amp;&amp; one_chance_in(3))</a>
<a name="ln3474">        return true;</a>
<a name="ln3475"> </a>
<a name="ln3476">    // We'll estimate the target's resistance to magic, by first getting</a>
<a name="ln3477">    // the actual value and then randomising it.</a>
<a name="ln3478">    const int est_magic_resist = foe-&gt;res_magic() + random2(60) - 30; // +-30</a>
<a name="ln3479">    const int power = ench_power_stepdown(mons_spellpower(caster, spell));</a>
<a name="ln3480"> </a>
<a name="ln3481">    // Determine the amount of chance allowed by the benefit from</a>
<a name="ln3482">    // the spell. The estimated difficulty is the probability</a>
<a name="ln3483">    // of rolling over 100 + diff on 2d100. -- bwr</a>
<a name="ln3484">    int diff = (spell == SPELL_PAIN</a>
<a name="ln3485">                || spell == SPELL_SLOW</a>
<a name="ln3486">                || spell == SPELL_CONFUSE) ? 0 : 50;</a>
<a name="ln3487"> </a>
<a name="ln3488">    return est_magic_resist - power &lt;= diff;</a>
<a name="ln3489">}</a>
<a name="ln3490"> </a>
<a name="ln3491">bool scattershot_tracer(monster *caster, int pow, coord_def aim)</a>
<a name="ln3492">{</a>
<a name="ln3493">    targeter_shotgun hitfunc(caster, shotgun_beam_count(pow),</a>
<a name="ln3494">                              spell_range(SPELL_SCATTERSHOT, pow));</a>
<a name="ln3495">    hitfunc.set_aim(aim);</a>
<a name="ln3496"> </a>
<a name="ln3497">    mon_attitude_type castatt = caster-&gt;temp_attitude();</a>
<a name="ln3498">    int friendly = 0, enemy = 0;</a>
<a name="ln3499"> </a>
<a name="ln3500">    for (const auto &amp;entry : hitfunc.zapped)</a>
<a name="ln3501">    {</a>
<a name="ln3502">        if (entry.second &lt;= 0)</a>
<a name="ln3503">            continue;</a>
<a name="ln3504"> </a>
<a name="ln3505">        const actor *victim = actor_at(entry.first);</a>
<a name="ln3506">        if (!victim)</a>
<a name="ln3507">            continue;</a>
<a name="ln3508"> </a>
<a name="ln3509">        if (mons_atts_aligned(castatt, victim-&gt;temp_attitude()))</a>
<a name="ln3510">            friendly += victim-&gt;get_experience_level();</a>
<a name="ln3511">        else</a>
<a name="ln3512">            enemy += victim-&gt;get_experience_level();</a>
<a name="ln3513">    }</a>
<a name="ln3514"> </a>
<a name="ln3515">    return enemy &gt; friendly;</a>
<a name="ln3516">}</a>
<a name="ln3517"> </a>
<a name="ln3518">/** Chooses a matching spell from this spell list, based on frequency.</a>
<a name="ln3519"> *</a>
<a name="ln3520"> *  @param[in]  spells     the monster spell list to search</a>
<a name="ln3521"> *  @param[in]  flag       what spflag the spell should match</a>
<a name="ln3522"> *  @return The spell chosen, or a slot containing SPELL_NO_SPELL and</a>
<a name="ln3523"> *          MON_SPELL_NO_FLAGS if no spell was chosen.</a>
<a name="ln3524"> */</a>
<a name="ln3525">static mon_spell_slot _pick_spell_from_list(const monster_spells &amp;spells,</a>
<a name="ln3526">                                            spflag flag)</a>
<a name="ln3527">{</a>
<a name="ln3528">    spell_type spell_cast = SPELL_NO_SPELL;</a>
<a name="ln3529">    mon_spell_slot_flags slot_flags = MON_SPELL_NO_FLAGS;</a>
<a name="ln3530">    int weight = 0;</a>
<a name="ln3531">    for (const mon_spell_slot &amp;slot : spells)</a>
<a name="ln3532">    {</a>
<a name="ln3533">        spell_flags flags = get_spell_flags(slot.spell);</a>
<a name="ln3534">        if (!(flags &amp; flag))</a>
<a name="ln3535">            continue;</a>
<a name="ln3536"> </a>
<a name="ln3537">        weight += slot.freq;</a>
<a name="ln3538">        if (x_chance_in_y(slot.freq, weight))</a>
<a name="ln3539">        {</a>
<a name="ln3540">            spell_cast = slot.spell;</a>
<a name="ln3541">            slot_flags = slot.flags;</a>
<a name="ln3542">        }</a>
<a name="ln3543">    }</a>
<a name="ln3544"> </a>
<a name="ln3545">    return { spell_cast, 0, slot_flags };</a>
<a name="ln3546">}</a>
<a name="ln3547"> </a>
<a name="ln3548">/**</a>
<a name="ln3549"> * Are we a short distance from our target?</a>
<a name="ln3550"> *</a>
<a name="ln3551"> * @param  mons The monster checking distance from its target.</a>
<a name="ln3552"> * @return true if we have a target and are within LOS_DEFAULT_RANGE / 2 of that</a>
<a name="ln3553"> *         target, or false otherwise.</a>
<a name="ln3554"> */</a>
<a name="ln3555">static bool _short_target_range(const monster *mons)</a>
<a name="ln3556">{</a>
<a name="ln3557">    return mons-&gt;get_foe()</a>
<a name="ln3558">           &amp;&amp; mons-&gt;pos().distance_from(mons-&gt;get_foe()-&gt;pos())</a>
<a name="ln3559">              &lt; LOS_DEFAULT_RANGE / 2;</a>
<a name="ln3560">}</a>
<a name="ln3561"> </a>
<a name="ln3562">/**</a>
<a name="ln3563"> * Are we a long distance from our target?</a>
<a name="ln3564"> *</a>
<a name="ln3565"> * @param  mons The monster checking distance from its target.</a>
<a name="ln3566"> * @return true if we have a target and are outside LOS_DEFAULT_RANGE / 2 of</a>
<a name="ln3567"> *          that target, or false otherwise.</a>
<a name="ln3568"> */</a>
<a name="ln3569">static bool _long_target_range(const monster *mons)</a>
<a name="ln3570">{</a>
<a name="ln3571">    return mons-&gt;get_foe()</a>
<a name="ln3572">           &amp;&amp; mons-&gt;pos().distance_from(mons-&gt;get_foe()-&gt;pos())</a>
<a name="ln3573">              &gt; LOS_DEFAULT_RANGE / 2;</a>
<a name="ln3574">}</a>
<a name="ln3575"> </a>
<a name="ln3576">/// Does the given monster think it's in an emergency situation?</a>
<a name="ln3577">static bool _mons_in_emergency(const monster &amp;mons)</a>
<a name="ln3578">{</a>
<a name="ln3579">    return mons.hit_points &lt; mons.max_hit_points / 3;</a>
<a name="ln3580">}</a>
<a name="ln3581"> </a>
<a name="ln3582">/**</a>
<a name="ln3583"> * Choose a spell for the given monster to consider casting.</a>
<a name="ln3584"> *</a>
<a name="ln3585"> * @param mons              The monster considering casting a spell/</a>
<a name="ln3586"> * @param hspell_pass       The set of spells to choose from.</a>
<a name="ln3587"> * @param prefer_selfench   Whether to prefer self-enchantment spells, which</a>
<a name="ln3588"> *                          are more likely to be castable.</a>
<a name="ln3589"> * @return                  A spell to cast, or { SPELL_NO_SPELL }.</a>
<a name="ln3590"> */</a>
<a name="ln3591">static mon_spell_slot _find_spell_prospect(const monster &amp;mons,</a>
<a name="ln3592">                                           const monster_spells &amp;hspell_pass,</a>
<a name="ln3593">                                           bool prefer_selfench)</a>
<a name="ln3594">{</a>
<a name="ln3595"> </a>
<a name="ln3596">    // Setup spell.</a>
<a name="ln3597">    // If we didn't find a spell on the first pass, try a</a>
<a name="ln3598">    // self-enchantment.</a>
<a name="ln3599">    if (prefer_selfench)</a>
<a name="ln3600">        return _pick_spell_from_list(hspell_pass, spflag::selfench);</a>
<a name="ln3601"> </a>
<a name="ln3602">    // Monsters that are fleeing or pacified and leaving the</a>
<a name="ln3603">    // level will always try to choose an emergency spell.</a>
<a name="ln3604">    if (mons_is_fleeing(mons) || mons.pacified())</a>
<a name="ln3605">    {</a>
<a name="ln3606">        const mon_spell_slot spell = _pick_spell_from_list(hspell_pass,</a>
<a name="ln3607">                                                           spflag::emergency);</a>
<a name="ln3608">        // Pacified monsters leaving the level will only</a>
<a name="ln3609">        // try and cast escape spells.</a>
<a name="ln3610">        if (spell.spell != SPELL_NO_SPELL</a>
<a name="ln3611">            &amp;&amp; mons.pacified()</a>
<a name="ln3612">            &amp;&amp; !testbits(get_spell_flags(spell.spell), spflag::escape))</a>
<a name="ln3613">        {</a>
<a name="ln3614">            return { SPELL_NO_SPELL, 0, MON_SPELL_NO_FLAGS };</a>
<a name="ln3615">        }</a>
<a name="ln3616"> </a>
<a name="ln3617">        return spell;</a>
<a name="ln3618">    }</a>
<a name="ln3619"> </a>
<a name="ln3620">    unsigned what = random2(200);</a>
<a name="ln3621">    unsigned int i = 0;</a>
<a name="ln3622">    for (; i &lt; hspell_pass.size(); i++)</a>
<a name="ln3623">    {</a>
<a name="ln3624">        if ((hspell_pass[i].flags &amp; MON_SPELL_EMERGENCY</a>
<a name="ln3625">             &amp;&amp; !_mons_in_emergency(mons))</a>
<a name="ln3626">            || (hspell_pass[i].flags &amp; MON_SPELL_SHORT_RANGE</a>
<a name="ln3627">                &amp;&amp; !_short_target_range(&amp;mons))</a>
<a name="ln3628">            || (hspell_pass[i].flags &amp; MON_SPELL_LONG_RANGE</a>
<a name="ln3629">                &amp;&amp; !_long_target_range(&amp;mons)))</a>
<a name="ln3630">        {</a>
<a name="ln3631">            continue;</a>
<a name="ln3632">        }</a>
<a name="ln3633"> </a>
<a name="ln3634">        if (hspell_pass[i].freq &gt;= what)</a>
<a name="ln3635">            break;</a>
<a name="ln3636">        what -= hspell_pass[i].freq;</a>
<a name="ln3637">    }</a>
<a name="ln3638"> </a>
<a name="ln3639">    // If we roll above the weight of the spell list,</a>
<a name="ln3640">    // don't cast a spell at all.</a>
<a name="ln3641">    if (i == hspell_pass.size())</a>
<a name="ln3642">        return { SPELL_NO_SPELL, 0, MON_SPELL_NO_FLAGS };</a>
<a name="ln3643"> </a>
<a name="ln3644">    return hspell_pass[i];</a>
<a name="ln3645">}</a>
<a name="ln3646"> </a>
<a name="ln3647">/**</a>
<a name="ln3648"> * Would it be a good idea for the given monster to cast the given spell?</a>
<a name="ln3649"> *</a>
<a name="ln3650"> * @param mons      The monster casting the spell.</a>
<a name="ln3651"> * @param spell     The spell in question; e.g. SPELL_FIREBALL.</a>
<a name="ln3652"> * @param beem      A beam with the spell loaded into it; used as a tracer.</a>
<a name="ln3653"> * @param ignore_good_idea      Whether to be almost completely indiscriminate</a>
<a name="ln3654"> *                              with beam spells. XXX: refactor this out?</a>
<a name="ln3655"> */</a>
<a name="ln3656">static bool _should_cast_spell(const monster &amp;mons, spell_type spell,</a>
<a name="ln3657">                               bolt &amp;beem, bool ignore_good_idea)</a>
<a name="ln3658">{</a>
<a name="ln3659">    // beam-type spells requiring tracers</a>
<a name="ln3660">    if (get_spell_flags(spell) &amp; spflag::needs_tracer)</a>
<a name="ln3661">    {</a>
<a name="ln3662">        const bool explode = spell_is_direct_explosion(spell);</a>
<a name="ln3663">        fire_tracer(&amp;mons, beem, explode);</a>
<a name="ln3664">        // Good idea?</a>
<a name="ln3665">        return mons_should_fire(beem, ignore_good_idea);</a>
<a name="ln3666">    }</a>
<a name="ln3667"> </a>
<a name="ln3668">    // All direct-effect/summoning/self-enchantments/etc.</a>
<a name="ln3669">    const actor *foe = mons.get_foe();</a>
<a name="ln3670">    if (_ms_direct_nasty(spell)</a>
<a name="ln3671">        &amp;&amp; mons_aligned(&amp;mons, (mons.foe == MHITYOU) ?</a>
<a name="ln3672">                        &amp;you : foe)) // foe=get_foe() is nullptr for friendlies</a>
<a name="ln3673">    {                                // targeting you, which is bad here.</a>
<a name="ln3674">        return false;</a>
<a name="ln3675">    }</a>
<a name="ln3676"> </a>
<a name="ln3677">    // Don't use blinking spells in sight of a trap the player can see if we're</a>
<a name="ln3678">    // allied with the player; this might do more harm than good to the player</a>
<a name="ln3679">    // restrict to the ones the player can see to avoid an information leak</a>
<a name="ln3680">    if (mons_aligned(&amp;mons, &amp;you)</a>
<a name="ln3681">        &amp;&amp; (spell == SPELL_BLINK || spell == SPELL_BLINK_OTHER</a>
<a name="ln3682">            || spell == SPELL_BLINK_OTHER_CLOSE || spell == SPELL_BLINK_CLOSE</a>
<a name="ln3683">            || spell == SPELL_BLINK_RANGE || spell == SPELL_BLINK_AWAY</a>
<a name="ln3684">            || spell == SPELL_BLINK_ALLIES_ENCIRCLE || spell == SPELL_BLINKBOLT</a>
<a name="ln3685">            || spell == SPELL_BLINK_ALLIES_AWAY))</a>
<a name="ln3686">    {</a>
<a name="ln3687">        for (auto ri = radius_iterator(mons.pos(), LOS_NO_TRANS); ri; ++ri)</a>
<a name="ln3688">            if (feat_is_trap(grd(*ri)) &amp;&amp; you.see_cell(*ri))</a>
<a name="ln3689">                return false;</a>
<a name="ln3690">    }</a>
<a name="ln3691"> </a>
<a name="ln3692"> </a>
<a name="ln3693">    if (mons.foe == MHITYOU || mons.foe == MHITNOT)</a>
<a name="ln3694">    {</a>
<a name="ln3695">        // XXX: Note the crude hack so that monsters can</a>
<a name="ln3696">        // use ME_ALERT to target (we should really have</a>
<a name="ln3697">        // a measure of time instead of peeking to see</a>
<a name="ln3698">        // if the player is still there). -- bwr</a>
<a name="ln3699">        return you.visible_to(&amp;mons)</a>
<a name="ln3700">               || mons.target == you.pos() &amp;&amp; coinflip();</a>
<a name="ln3701">    }</a>
<a name="ln3702"> </a>
<a name="ln3703">    ASSERT(foe);</a>
<a name="ln3704">    if (!mons.can_see(*foe))</a>
<a name="ln3705">        return false;</a>
<a name="ln3706"> </a>
<a name="ln3707">    return true;</a>
<a name="ln3708">}</a>
<a name="ln3709"> </a>
<a name="ln3710">/// How does Ru describe stopping the given monster casting a spell?</a>
<a name="ln3711">static string _ru_spell_stop_desc(monster &amp;mons)</a>
<a name="ln3712">{</a>
<a name="ln3713">    if (mons.is_actual_spellcaster())</a>
<a name="ln3714">        return &quot;cast a spell&quot;;</a>
<a name="ln3715">    if (mons.is_priest())</a>
<a name="ln3716">        return &quot;pray&quot;;</a>
<a name="ln3717">    return &quot;attack&quot;;</a>
<a name="ln3718">}</a>
<a name="ln3719"> </a>
<a name="ln3720">/// What spells can the given monster currently use?</a>
<a name="ln3721">static monster_spells _find_usable_spells(monster &amp;mons)</a>
<a name="ln3722">{</a>
<a name="ln3723">    // TODO: make mons param const (requires waste_of_time param to be const)</a>
<a name="ln3724"> </a>
<a name="ln3725">    monster_spells hspell_pass(mons.spells);</a>
<a name="ln3726"> </a>
<a name="ln3727">    if (mons.is_silenced() || mons.is_shapeshifter())</a>
<a name="ln3728">    {</a>
<a name="ln3729">        erase_if(hspell_pass, [](const mon_spell_slot &amp;t) {</a>
<a name="ln3730">            return t.flags &amp; MON_SPELL_SILENCE_MASK;</a>
<a name="ln3731">        });</a>
<a name="ln3732">    }</a>
<a name="ln3733"> </a>
<a name="ln3734">    // Remove currently useless spells.</a>
<a name="ln3735">    erase_if(hspell_pass, [&amp;](const mon_spell_slot &amp;t) {</a>
<a name="ln3736">        return _ms_waste_of_time(&amp;mons, t)</a>
<a name="ln3737">        // Should monster not have selected dig by now,</a>
<a name="ln3738">        // it never will.</a>
<a name="ln3739">        || t.spell == SPELL_DIG;</a>
<a name="ln3740">    });</a>
<a name="ln3741"> </a>
<a name="ln3742">    return hspell_pass;</a>
<a name="ln3743">}</a>
<a name="ln3744"> </a>
<a name="ln3745">/**</a>
<a name="ln3746"> * For the given spell and monster, try to find a target for the spell, and</a>
<a name="ln3747"> * and then see if it's a good idea to actually cast the spell at that target.</a>
<a name="ln3748"> * Return whether we succeeded in both.</a>
<a name="ln3749"> *</a>
<a name="ln3750"> * @param mons            The monster casting the spell. XXX: should be const</a>
<a name="ln3751"> * @param beem[in,out]    A targeting beam. Has a very few params already set.</a>
<a name="ln3752"> *                        (from setup_targetting_beam())</a>
<a name="ln3753"> * @param spell           The spell to be targetted and cast.</a>
<a name="ln3754"> * @param ignore_good_idea  Whether to ignore most targeting constraints (ru)</a>
<a name="ln3755"> */</a>
<a name="ln3756">static bool _target_and_justify_spell(monster &amp;mons,</a>
<a name="ln3757">                                      bolt &amp;beem,</a>
<a name="ln3758">                                      spell_type spell,</a>
<a name="ln3759">                                      bool ignore_good_idea)</a>
<a name="ln3760">{</a>
<a name="ln3761">    // Setup the spell.</a>
<a name="ln3762">    setup_mons_cast(&amp;mons, beem, spell);</a>
<a name="ln3763"> </a>
<a name="ln3764">    switch (spell)</a>
<a name="ln3765">    {</a>
<a name="ln3766">        case SPELL_ENSLAVEMENT:</a>
<a name="ln3767">            // Try to find an ally of the player to hex if we are</a>
<a name="ln3768">            // hexing the player.</a>
<a name="ln3769">            if (mons.foe == MHITYOU &amp;&amp; !_set_hex_target(&amp;mons, beem))</a>
<a name="ln3770">                return false;</a>
<a name="ln3771">            break;</a>
<a name="ln3772">        default:</a>
<a name="ln3773">            break;</a>
<a name="ln3774">    }</a>
<a name="ln3775"> </a>
<a name="ln3776">    // special beam targeting sets the beam's target to an out-of-bounds coord</a>
<a name="ln3777">    // if no valid target was found.</a>
<a name="ln3778">    const mons_spell_logic* logic = map_find(spell_to_logic, spell);</a>
<a name="ln3779">    if (logic &amp;&amp; logic-&gt;setup_beam &amp;&amp; !in_bounds(beem.target))</a>
<a name="ln3780">        return false;</a>
<a name="ln3781"> </a>
<a name="ln3782">    // Don't knockback something we're trying to constrict.</a>
<a name="ln3783">    const actor *victim = actor_at(beem.target);</a>
<a name="ln3784">    if (victim &amp;&amp;</a>
<a name="ln3785">        beem.can_knockback(*victim)</a>
<a name="ln3786">        &amp;&amp; mons.is_constricting()</a>
<a name="ln3787">        &amp;&amp; mons.constricting-&gt;count(victim-&gt;mid))</a>
<a name="ln3788">    {</a>
<a name="ln3789">        return false;</a>
<a name="ln3790">    }</a>
<a name="ln3791"> </a>
<a name="ln3792">    return _should_cast_spell(mons, spell, beem, ignore_good_idea);</a>
<a name="ln3793">}</a>
<a name="ln3794"> </a>
<a name="ln3795">/**</a>
<a name="ln3796"> * Let a monster choose a spell to cast; may be SPELL_NO_SPELL.</a>
<a name="ln3797"> *</a>
<a name="ln3798"> * @param mons          The monster doing the casting, potentially.</a>
<a name="ln3799"> *                      TODO: should be const (requires _ms_low_hitpoint_cast</a>
<a name="ln3800">                        param to be const)</a>
<a name="ln3801"> * @param orig_beem[in,out]     A beam. Has a very few params already set.</a>
<a name="ln3802"> *                              (from setup_targetting_beam())</a>
<a name="ln3803"> *                              TODO: split out targeting into another func</a>
<a name="ln3804"> * @param hspell_pass   A list of valid spells to consider casting.</a>
<a name="ln3805"> * @param ignore_good_idea      Whether to be almost completely indiscriminate</a>
<a name="ln3806"> *                              with beam spells. XXX: refactor this out?</a>
<a name="ln3807"> * @return              A spell to cast, or SPELL_NO_SPELL.</a>
<a name="ln3808"> */</a>
<a name="ln3809">static mon_spell_slot _choose_spell_to_cast(monster &amp;mons,</a>
<a name="ln3810">                                            bolt &amp;beem,</a>
<a name="ln3811">                                            const monster_spells &amp;hspell_pass,</a>
<a name="ln3812">                                            bool ignore_good_idea)</a>
<a name="ln3813">{</a>
<a name="ln3814">    // Monsters caught in a net try to get away.</a>
<a name="ln3815">    // This is only urgent if enemies are around.</a>
<a name="ln3816">    if (mon_enemies_around(&amp;mons) &amp;&amp; mons.caught() &amp;&amp; one_chance_in(15))</a>
<a name="ln3817">        for (const mon_spell_slot &amp;slot : hspell_pass)</a>
<a name="ln3818">            if (_ms_quick_get_away(slot.spell))</a>
<a name="ln3819">                return slot;</a>
<a name="ln3820"> </a>
<a name="ln3821">    bolt orig_beem = beem;</a>
<a name="ln3822"> </a>
<a name="ln3823">    // Promote the casting of useful spells for low-HP monsters.</a>
<a name="ln3824">    // (kraken should always cast their escape spell of inky).</a>
<a name="ln3825">    if (_mons_in_emergency(mons)</a>
<a name="ln3826">        &amp;&amp; one_chance_in(mons.type == MONS_KRAKEN ? 4 : 8))</a>
<a name="ln3827">    {</a>
<a name="ln3828">        // Note: There should always be at least some chance we don't</a>
<a name="ln3829">        // get here... even if the monster is on its last HP. That</a>
<a name="ln3830">        // way we don't have to worry about monsters infinitely casting</a>
<a name="ln3831">        // Healing on themselves (e.g. orc high priests).</a>
<a name="ln3832">        int found_spell = 0;</a>
<a name="ln3833">        mon_spell_slot chosen_slot = { SPELL_NO_SPELL, 0, MON_SPELL_NO_FLAGS };</a>
<a name="ln3834">        for (const mon_spell_slot &amp;slot : hspell_pass)</a>
<a name="ln3835">        {</a>
<a name="ln3836">            bolt targ_beam = orig_beem;</a>
<a name="ln3837">            if (_target_and_justify_spell(mons, targ_beam, slot.spell,</a>
<a name="ln3838">                                          ignore_good_idea)</a>
<a name="ln3839">                &amp;&amp; one_chance_in(++found_spell))</a>
<a name="ln3840">            {</a>
<a name="ln3841">                chosen_slot = slot;</a>
<a name="ln3842">                beem = targ_beam;</a>
<a name="ln3843">            }</a>
<a name="ln3844">        }</a>
<a name="ln3845"> </a>
<a name="ln3846">        if (chosen_slot.spell != SPELL_NO_SPELL)</a>
<a name="ln3847">            return chosen_slot;</a>
<a name="ln3848">    }</a>
<a name="ln3849"> </a>
<a name="ln3850">    // If nothing found by now, safe friendlies and good</a>
<a name="ln3851">    // neutrals will rarely cast.</a>
<a name="ln3852">    if (mons.wont_attack() &amp;&amp; !mon_enemies_around(&amp;mons) &amp;&amp; !one_chance_in(10))</a>
<a name="ln3853">        return { SPELL_NO_SPELL, 0, MON_SPELL_NO_FLAGS };</a>
<a name="ln3854"> </a>
<a name="ln3855">    bool reroll = mons.has_ench(ENCH_EMPOWERED_SPELLS);</a>
<a name="ln3856">    for (int attempt = 0; attempt &lt; 2; attempt++)</a>
<a name="ln3857">    {</a>
<a name="ln3858">        const bool prefer_selfench = attempt &gt; 0 &amp;&amp; coinflip();</a>
<a name="ln3859">        mon_spell_slot chosen_slot</a>
<a name="ln3860">            = _find_spell_prospect(mons, hspell_pass, prefer_selfench);</a>
<a name="ln3861"> </a>
<a name="ln3862">        // aura of brilliance gives monsters a bonus cast chance.</a>
<a name="ln3863">        if (chosen_slot.spell == SPELL_NO_SPELL &amp;&amp; reroll)</a>
<a name="ln3864">        {</a>
<a name="ln3865">            chosen_slot = _find_spell_prospect(mons, hspell_pass,</a>
<a name="ln3866">                                               prefer_selfench);</a>
<a name="ln3867">            reroll = false;</a>
<a name="ln3868">        }</a>
<a name="ln3869"> </a>
<a name="ln3870">        // if we didn't roll a spell, don't make another attempt; bail.</a>
<a name="ln3871">        // (only give multiple attempts for targetting issues.)</a>
<a name="ln3872">        if (chosen_slot.spell == SPELL_NO_SPELL)</a>
<a name="ln3873">            return chosen_slot;</a>
<a name="ln3874"> </a>
<a name="ln3875">        // reset the beam</a>
<a name="ln3876">        beem = orig_beem;</a>
<a name="ln3877"> </a>
<a name="ln3878">        if (_target_and_justify_spell(mons, beem, chosen_slot.spell,</a>
<a name="ln3879">                                       ignore_good_idea))</a>
<a name="ln3880">        {</a>
<a name="ln3881">            ASSERT(chosen_slot.spell != SPELL_NO_SPELL);</a>
<a name="ln3882">            return chosen_slot;</a>
<a name="ln3883">        }</a>
<a name="ln3884">    }</a>
<a name="ln3885"> </a>
<a name="ln3886">    return { SPELL_NO_SPELL, 0, MON_SPELL_NO_FLAGS };</a>
<a name="ln3887">}</a>
<a name="ln3888"> </a>
<a name="ln3889">/**</a>
<a name="ln3890"> * Give a monster a chance to cast a spell.</a>
<a name="ln3891"> *</a>
<a name="ln3892"> * @param mons the monster that might cast.</a>
<a name="ln3893"> * @param return whether a spell was cast.</a>
<a name="ln3894"> */</a>
<a name="ln3895">bool handle_mon_spell(monster* mons)</a>
<a name="ln3896">{</a>
<a name="ln3897">    ASSERT(mons);</a>
<a name="ln3898"> </a>
<a name="ln3899">    if (is_sanctuary(mons-&gt;pos()) &amp;&amp; !mons-&gt;wont_attack())</a>
<a name="ln3900">        return false;</a>
<a name="ln3901"> </a>
<a name="ln3902">    // Yes, there is a logic to this ordering {dlb}:</a>
<a name="ln3903">    // .. berserk check is necessary for out-of-sequence actions like emergency</a>
<a name="ln3904">    // slot spells {blue}</a>
<a name="ln3905">    if (mons-&gt;asleep()</a>
<a name="ln3906">        || mons-&gt;submerged()</a>
<a name="ln3907">        || mons-&gt;berserk_or_insane()</a>
<a name="ln3908">        || mons_is_confused(*mons, false)</a>
<a name="ln3909">        || !mons-&gt;has_spells())</a>
<a name="ln3910">    {</a>
<a name="ln3911">        return false;</a>
<a name="ln3912">    }</a>
<a name="ln3913"> </a>
<a name="ln3914">    const monster_spells hspell_pass = _find_usable_spells(*mons);</a>
<a name="ln3915"> </a>
<a name="ln3916">    // If no useful spells... cast no spell.</a>
<a name="ln3917">    if (!hspell_pass.size())</a>
<a name="ln3918">        return false;</a>
<a name="ln3919"> </a>
<a name="ln3920">    bolt beem = setup_targetting_beam(*mons);</a>
<a name="ln3921"> </a>
<a name="ln3922">    bool ignore_good_idea = false;</a>
<a name="ln3923">    if (does_ru_wanna_redirect(mons))</a>
<a name="ln3924">    {</a>
<a name="ln3925">        ru_interference interference = get_ru_attack_interference_level();</a>
<a name="ln3926">        if (interference == DO_BLOCK_ATTACK)</a>
<a name="ln3927">        {</a>
<a name="ln3928">            const string message</a>
<a name="ln3929">                = make_stringf(&quot; begins to %s, but is stunned by your will!&quot;,</a>
<a name="ln3930">                               _ru_spell_stop_desc(*mons).c_str());</a>
<a name="ln3931">            simple_monster_message(*mons, message.c_str(), MSGCH_GOD);</a>
<a name="ln3932">            mons-&gt;lose_energy(EUT_SPELL);</a>
<a name="ln3933">            return true;</a>
<a name="ln3934">        }</a>
<a name="ln3935">        if (interference == DO_REDIRECT_ATTACK)</a>
<a name="ln3936">        {</a>
<a name="ln3937">            int pfound = 0;</a>
<a name="ln3938">            for (radius_iterator ri(you.pos(),</a>
<a name="ln3939">                                    LOS_DEFAULT); ri; ++ri)</a>
<a name="ln3940">            {</a>
<a name="ln3941">                monster* new_target = monster_at(*ri);</a>
<a name="ln3942"> </a>
<a name="ln3943">                if (new_target == nullptr</a>
<a name="ln3944">                    || mons_is_projectile(new_target-&gt;type)</a>
<a name="ln3945">                    || mons_is_firewood(*new_target)</a>
<a name="ln3946">                    || new_target-&gt;friendly())</a>
<a name="ln3947">                {</a>
<a name="ln3948">                    continue;</a>
<a name="ln3949">                }</a>
<a name="ln3950"> </a>
<a name="ln3951">                ASSERT(new_target);</a>
<a name="ln3952"> </a>
<a name="ln3953">                if (one_chance_in(++pfound))</a>
<a name="ln3954">                {</a>
<a name="ln3955">                    mons-&gt;target = new_target-&gt;pos();</a>
<a name="ln3956">                    mons-&gt;foe = new_target-&gt;mindex();</a>
<a name="ln3957">                    beem.target = mons-&gt;target;</a>
<a name="ln3958">                    ignore_good_idea = true;</a>
<a name="ln3959">                }</a>
<a name="ln3960">            }</a>
<a name="ln3961"> </a>
<a name="ln3962">            if (ignore_good_idea)</a>
<a name="ln3963">            {</a>
<a name="ln3964">                mprf(MSGCH_GOD, &quot;You redirect %s's attack!&quot;,</a>
<a name="ln3965">                     mons-&gt;name(DESC_THE).c_str());</a>
<a name="ln3966">            }</a>
<a name="ln3967">        }</a>
<a name="ln3968">    }</a>
<a name="ln3969"> </a>
<a name="ln3970">    const mon_spell_slot spell_slot</a>
<a name="ln3971">        = _choose_spell_to_cast(*mons, beem, hspell_pass, ignore_good_idea);</a>
<a name="ln3972">    const spell_type spell_cast = spell_slot.spell;</a>
<a name="ln3973">    const mon_spell_slot_flags flags = spell_slot.flags;</a>
<a name="ln3974"> </a>
<a name="ln3975">    // Should the monster *still* not have a spell, well, too bad {dlb}:</a>
<a name="ln3976">    if (spell_cast == SPELL_NO_SPELL)</a>
<a name="ln3977">        return false;</a>
<a name="ln3978"> </a>
<a name="ln3979">    // Check for antimagic if casting a spell spell.</a>
<a name="ln3980">    if (mons-&gt;has_ench(ENCH_ANTIMAGIC) &amp;&amp; flags &amp; MON_SPELL_ANTIMAGIC_MASK</a>
<a name="ln3981">        &amp;&amp; !x_chance_in_y(4 * BASELINE_DELAY,</a>
<a name="ln3982">                          4 * BASELINE_DELAY</a>
<a name="ln3983">                          + mons-&gt;get_ench(ENCH_ANTIMAGIC).duration))</a>
<a name="ln3984">    {</a>
<a name="ln3985">        // This may be a bad idea -- if we decide monsters shouldn't</a>
<a name="ln3986">        // lose a turn like players do not, please make this just return.</a>
<a name="ln3987">        simple_monster_message(*mons, &quot; falters for a moment.&quot;);</a>
<a name="ln3988">        mons-&gt;lose_energy(EUT_SPELL);</a>
<a name="ln3989">        return true;</a>
<a name="ln3990">    }</a>
<a name="ln3991"> </a>
<a name="ln3992">    // Dragons now have a time-out on their breath weapons, draconians too!</a>
<a name="ln3993">    if (flags &amp; MON_SPELL_BREATH)</a>
<a name="ln3994">        setup_breath_timeout(mons);</a>
<a name="ln3995"> </a>
<a name="ln3996">    // FINALLY! determine primary spell effects {dlb}:</a>
<a name="ln3997">    if (spell_cast == SPELL_BLINK || spell_cast == SPELL_CONTROLLED_BLINK)</a>
<a name="ln3998">    {</a>
<a name="ln3999">        // Why only cast blink if nearby? {dlb}</a>
<a name="ln4000">        if (mons-&gt;can_see(you))</a>
<a name="ln4001">        {</a>
<a name="ln4002">            mons_cast_noise(mons, beem, spell_cast, flags);</a>
<a name="ln4003">            monster_blink(mons);</a>
<a name="ln4004">        }</a>
<a name="ln4005">        else</a>
<a name="ln4006">            return false;</a>
<a name="ln4007">    }</a>
<a name="ln4008">    else if (spell_cast == SPELL_BLINK_RANGE)</a>
<a name="ln4009">        blink_range(mons);</a>
<a name="ln4010">    else if (spell_cast == SPELL_BLINK_AWAY)</a>
<a name="ln4011">        blink_away(mons, true);</a>
<a name="ln4012">    else if (spell_cast == SPELL_BLINK_CLOSE)</a>
<a name="ln4013">        blink_close(mons);</a>
<a name="ln4014">    else</a>
<a name="ln4015">    {</a>
<a name="ln4016">        const bool battlesphere = mons-&gt;props.exists(&quot;battlesphere&quot;);</a>
<a name="ln4017">        if (!(get_spell_flags(spell_cast) &amp; spflag::utility))</a>
<a name="ln4018">            make_mons_stop_fleeing(mons);</a>
<a name="ln4019"> </a>
<a name="ln4020">        if (battlesphere)</a>
<a name="ln4021">            aim_battlesphere(mons, spell_cast, beem.ench_power, beem);</a>
<a name="ln4022">        const bool was_visible = you.can_see(*mons);</a>
<a name="ln4023">        mons_cast(mons, beem, spell_cast, flags);</a>
<a name="ln4024">        if ((was_visible || you.can_see(*mons)) &amp;&amp; mons-&gt;alive())</a>
<a name="ln4025">            mons-&gt;note_spell_cast(spell_cast);</a>
<a name="ln4026">        if (battlesphere)</a>
<a name="ln4027">            trigger_battlesphere(mons, beem);</a>
<a name="ln4028">        if (flags &amp; MON_SPELL_WIZARD &amp;&amp; mons-&gt;has_ench(ENCH_SAP_MAGIC))</a>
<a name="ln4029">        {</a>
<a name="ln4030">            mons-&gt;add_ench(mon_enchant(ENCH_ANTIMAGIC, 0,</a>
<a name="ln4031">                                       mons-&gt;get_ench(ENCH_SAP_MAGIC).agent(),</a>
<a name="ln4032">                                       6 * BASELINE_DELAY));</a>
<a name="ln4033">        }</a>
<a name="ln4034">        // Wellsprings &quot;cast&quot; from their own hp.</a>
<a name="ln4035">        if (spell_cast == SPELL_PRIMAL_WAVE</a>
<a name="ln4036">            &amp;&amp; mons-&gt;type == MONS_ELEMENTAL_WELLSPRING)</a>
<a name="ln4037">        {</a>
<a name="ln4038">            mons-&gt;hurt(mons, 5 + random2(15));</a>
<a name="ln4039">            if (mons-&gt;alive())</a>
<a name="ln4040">                _summon(*mons, MONS_WATER_ELEMENTAL, 3, spell_slot);</a>
<a name="ln4041">        }</a>
<a name="ln4042">    }</a>
<a name="ln4043"> </a>
<a name="ln4044">    // Reflection, fireballs, wellspring self-damage, etc.</a>
<a name="ln4045">    if (!mons-&gt;alive())</a>
<a name="ln4046">        return true;</a>
<a name="ln4047"> </a>
<a name="ln4048">    if (!(flags &amp; MON_SPELL_INSTANT))</a>
<a name="ln4049">    {</a>
<a name="ln4050">        mons-&gt;lose_energy(EUT_SPELL);</a>
<a name="ln4051">        return true;</a>
<a name="ln4052">    }</a>
<a name="ln4053"> </a>
<a name="ln4054">    return false; // to let them do something else</a>
<a name="ln4055">}</a>
<a name="ln4056"> </a>
<a name="ln4057">static int _monster_abjure_target(monster* target, int pow, bool actual)</a>
<a name="ln4058">{</a>
<a name="ln4059">    int duration;</a>
<a name="ln4060"> </a>
<a name="ln4061">    if (!target-&gt;is_summoned(&amp;duration))</a>
<a name="ln4062">        return 0;</a>
<a name="ln4063"> </a>
<a name="ln4064">    pow = max(20, fuzz_value(pow, 40, 25));</a>
<a name="ln4065"> </a>
<a name="ln4066">    if (!actual)</a>
<a name="ln4067">        return pow &gt; 40 || pow &gt;= duration;</a>
<a name="ln4068"> </a>
<a name="ln4069">    // TSO and Trog's abjuration protection.</a>
<a name="ln4070">    bool shielded = false;</a>
<a name="ln4071">    if (have_passive(passive_t::abjuration_protection_hd))</a>
<a name="ln4072">    {</a>
<a name="ln4073">        pow = pow * (30 - target-&gt;get_hit_dice()) / 30;</a>
<a name="ln4074">        if (pow &lt; duration)</a>
<a name="ln4075">        {</a>
<a name="ln4076">            simple_god_message(&quot; protects your fellow warrior from evil &quot;</a>
<a name="ln4077">                               &quot;magic!&quot;);</a>
<a name="ln4078">            shielded = true;</a>
<a name="ln4079">        }</a>
<a name="ln4080">    }</a>
<a name="ln4081">    else if (have_passive(passive_t::abjuration_protection))</a>
<a name="ln4082">    {</a>
<a name="ln4083">        pow = pow / 2;</a>
<a name="ln4084">        if (pow &lt; duration)</a>
<a name="ln4085">        {</a>
<a name="ln4086">            simple_god_message(&quot; shields your ally from puny magic!&quot;);</a>
<a name="ln4087">            shielded = true;</a>
<a name="ln4088">        }</a>
<a name="ln4089">    }</a>
<a name="ln4090">    else if (is_sanctuary(target-&gt;pos()))</a>
<a name="ln4091">    {</a>
<a name="ln4092">        pow = 0;</a>
<a name="ln4093">        mprf(MSGCH_GOD, &quot;Zin's power protects your fellow warrior from evil magic!&quot;);</a>
<a name="ln4094">        shielded = true;</a>
<a name="ln4095">    }</a>
<a name="ln4096"> </a>
<a name="ln4097">    dprf(&quot;Abj: dur: %d, pow: %d, ndur: %d&quot;, duration, pow, duration - pow);</a>
<a name="ln4098"> </a>
<a name="ln4099">    mon_enchant abj = target-&gt;get_ench(ENCH_ABJ);</a>
<a name="ln4100">    if (!target-&gt;lose_ench_duration(abj, pow))</a>
<a name="ln4101">    {</a>
<a name="ln4102">        if (!shielded)</a>
<a name="ln4103">            simple_monster_message(*target, &quot; shudders.&quot;);</a>
<a name="ln4104">        return 1;</a>
<a name="ln4105">    }</a>
<a name="ln4106"> </a>
<a name="ln4107">    return 0;</a>
<a name="ln4108">}</a>
<a name="ln4109"> </a>
<a name="ln4110">static int _monster_abjuration(const monster&amp; caster, bool actual)</a>
<a name="ln4111">{</a>
<a name="ln4112">    int maffected = 0;</a>
<a name="ln4113"> </a>
<a name="ln4114">    if (actual)</a>
<a name="ln4115">        mpr(&quot;Send 'em back where they came from!&quot;);</a>
<a name="ln4116"> </a>
<a name="ln4117">    const int pow = mons_spellpower(caster, SPELL_ABJURATION);</a>
<a name="ln4118"> </a>
<a name="ln4119">    for (monster_near_iterator mi(caster.pos(), LOS_NO_TRANS); mi; ++mi)</a>
<a name="ln4120">    {</a>
<a name="ln4121">        if (!mons_aligned(&amp;caster, *mi))</a>
<a name="ln4122">            maffected += _monster_abjure_target(*mi, pow, actual);</a>
<a name="ln4123">    }</a>
<a name="ln4124"> </a>
<a name="ln4125">    return maffected;</a>
<a name="ln4126">}</a>
<a name="ln4127"> </a>
<a name="ln4128">static bool _mons_will_abjure(const monster&amp; mons)</a>
<a name="ln4129">{</a>
<a name="ln4130">    return _monster_abjuration(mons, false) &gt; 0;</a>
<a name="ln4131">}</a>
<a name="ln4132"> </a>
<a name="ln4133">static void _haunt_fixup(monster* summon, coord_def pos)</a>
<a name="ln4134">{</a>
<a name="ln4135">    actor* victim = actor_at(pos);</a>
<a name="ln4136">    if (victim &amp;&amp; victim != summon)</a>
<a name="ln4137">    {</a>
<a name="ln4138">        summon-&gt;add_ench(mon_enchant(ENCH_HAUNTING, 1, victim,</a>
<a name="ln4139">                                     INFINITE_DURATION));</a>
<a name="ln4140">        summon-&gt;foe = victim-&gt;mindex();</a>
<a name="ln4141">    }</a>
<a name="ln4142">}</a>
<a name="ln4143"> </a>
<a name="ln4144">static monster_type _pick_horrible_thing()</a>
<a name="ln4145">{</a>
<a name="ln4146">    return one_chance_in(4) ? MONS_TENTACLED_MONSTROSITY</a>
<a name="ln4147">                            : MONS_ABOMINATION_LARGE;</a>
<a name="ln4148">}</a>
<a name="ln4149"> </a>
<a name="ln4150">static monster_type _pick_undead_summon()</a>
<a name="ln4151">{</a>
<a name="ln4152">    static monster_type undead[] =</a>
<a name="ln4153">    {</a>
<a name="ln4154">        MONS_NECROPHAGE, MONS_JIANGSHI, MONS_HUNGRY_GHOST, MONS_FLAYED_GHOST,</a>
<a name="ln4155">        MONS_ZOMBIE, MONS_SKELETON, MONS_SIMULACRUM, MONS_SPECTRAL_THING,</a>
<a name="ln4156">        MONS_FLYING_SKULL, MONS_MUMMY, MONS_VAMPIRE, MONS_WIGHT, MONS_WRAITH,</a>
<a name="ln4157">        MONS_SHADOW_WRAITH, MONS_FREEZING_WRAITH, MONS_PHANTASMAL_WARRIOR, MONS_SHADOW</a>
<a name="ln4158">    };</a>
<a name="ln4159"> </a>
<a name="ln4160">    return RANDOM_ELEMENT(undead);</a>
<a name="ln4161">}</a>
<a name="ln4162"> </a>
<a name="ln4163">static monster_type _pick_vermin()</a>
<a name="ln4164">{</a>
<a name="ln4165">    return random_choose_weighted(8, MONS_HELL_RAT,</a>
<a name="ln4166">                                  5, MONS_REDBACK,</a>
<a name="ln4167">                                  2, MONS_TARANTELLA,</a>
<a name="ln4168">                                  2, MONS_JUMPING_SPIDER,</a>
<a name="ln4169">                                  3, MONS_DEMONIC_CRAWLER);</a>
<a name="ln4170">}</a>
<a name="ln4171"> </a>
<a name="ln4172">static monster_type _pick_drake()</a>
<a name="ln4173">{</a>
<a name="ln4174">    return random_choose_weighted(5, MONS_SWAMP_DRAKE,</a>
<a name="ln4175">                                  5, MONS_KOMODO_DRAGON,</a>
<a name="ln4176">                                  5, MONS_WIND_DRAKE,</a>
<a name="ln4177">                                  6, MONS_RIME_DRAKE,</a>
<a name="ln4178">                                  6, MONS_DEATH_DRAKE,</a>
<a name="ln4179">                                  3, MONS_LINDWURM);</a>
<a name="ln4180">}</a>
<a name="ln4181"> </a>
<a name="ln4182">static void _do_high_level_summon(monster* mons, spell_type spell_cast,</a>
<a name="ln4183">                                  monster_type (*mpicker)(), int nsummons,</a>
<a name="ln4184">                                  god_type god, const coord_def *target = nullptr,</a>
<a name="ln4185">                                  void (*post_hook)(monster*, coord_def)</a>
<a name="ln4186">                                      = nullptr)</a>
<a name="ln4187">{</a>
<a name="ln4188">    const int duration = min(2 + mons-&gt;spell_hd(spell_cast) / 5, 6);</a>
<a name="ln4189"> </a>
<a name="ln4190">    for (int i = 0; i &lt; nsummons; ++i)</a>
<a name="ln4191">    {</a>
<a name="ln4192">        monster_type which_mons = mpicker();</a>
<a name="ln4193"> </a>
<a name="ln4194">        if (which_mons == MONS_NO_MONSTER)</a>
<a name="ln4195">            continue;</a>
<a name="ln4196"> </a>
<a name="ln4197">        monster* summon = create_monster(</a>
<a name="ln4198">            mgen_data(which_mons, SAME_ATTITUDE(mons),</a>
<a name="ln4199">                      target ? *target : mons-&gt;pos(), mons-&gt;foe)</a>
<a name="ln4200">            .set_summoned(mons, duration, spell_cast, god));</a>
<a name="ln4201">        if (summon &amp;&amp; post_hook)</a>
<a name="ln4202">            post_hook(summon, target ? *target : mons-&gt;pos());</a>
<a name="ln4203">    }</a>
<a name="ln4204">}</a>
<a name="ln4205"> </a>
<a name="ln4206"> </a>
<a name="ln4207">static void _mons_summon_elemental(monster &amp;mons, mon_spell_slot slot, bolt&amp;)</a>
<a name="ln4208">{</a>
<a name="ln4209">    static const map&lt;spell_type, monster_type&gt; elemental_types = {</a>
<a name="ln4210">        { SPELL_WATER_ELEMENTALS, MONS_WATER_ELEMENTAL },</a>
<a name="ln4211">        { SPELL_FIRE_ELEMENTALS, MONS_FIRE_ELEMENTAL },</a>
<a name="ln4212">        { SPELL_EARTH_ELEMENTALS, MONS_EARTH_ELEMENTAL },</a>
<a name="ln4213">        { SPELL_AIR_ELEMENTALS, MONS_AIR_ELEMENTAL },</a>
<a name="ln4214">    };</a>
<a name="ln4215"> </a>
<a name="ln4216">    const monster_type* mtyp = map_find(elemental_types, slot.spell);</a>
<a name="ln4217">    ASSERT(mtyp);</a>
<a name="ln4218"> </a>
<a name="ln4219">    const int spell_hd = mons.spell_hd(slot.spell);</a>
<a name="ln4220">    const int count = 1 + (spell_hd &gt; 15) + random2(spell_hd / 7 + 1);</a>
<a name="ln4221"> </a>
<a name="ln4222">    for (int i = 0; i &lt; count; i++)</a>
<a name="ln4223">        _summon(mons, *mtyp, 3, slot);</a>
<a name="ln4224">}</a>
<a name="ln4225"> </a>
<a name="ln4226">static void _mons_cast_haunt(monster* mons)</a>
<a name="ln4227">{</a>
<a name="ln4228">    ASSERT(mons-&gt;get_foe());</a>
<a name="ln4229">    const coord_def fpos = mons-&gt;get_foe()-&gt;pos();</a>
<a name="ln4230"> </a>
<a name="ln4231">    _do_high_level_summon(mons, SPELL_HAUNT, pick_random_wraith,</a>
<a name="ln4232">                          random_range(2, 3), GOD_NO_GOD, &amp;fpos, _haunt_fixup);</a>
<a name="ln4233">}</a>
<a name="ln4234"> </a>
<a name="ln4235">static void _mons_cast_summon_illusion(monster* mons, spell_type spell)</a>
<a name="ln4236">{</a>
<a name="ln4237">    actor *foe = mons-&gt;get_foe();</a>
<a name="ln4238">    if (!foe || !actor_is_illusion_cloneable(foe))</a>
<a name="ln4239">        return;</a>
<a name="ln4240"> </a>
<a name="ln4241">    mons_summon_illusion_from(mons, foe, spell);</a>
<a name="ln4242">}</a>
<a name="ln4243"> </a>
<a name="ln4244">static void _mons_cast_spectral_orcs(monster* mons)</a>
<a name="ln4245">{</a>
<a name="ln4246">    ASSERT(mons-&gt;get_foe());</a>
<a name="ln4247">    const coord_def fpos = mons-&gt;get_foe()-&gt;pos();</a>
<a name="ln4248"> </a>
<a name="ln4249">    const int abj = 3;</a>
<a name="ln4250"> </a>
<a name="ln4251">    for (int i = random2(3) + 1; i &gt; 0; --i)</a>
<a name="ln4252">    {</a>
<a name="ln4253">        monster_type mon = MONS_ORC;</a>
<a name="ln4254">        if (coinflip())</a>
<a name="ln4255">            mon = MONS_ORC_WARRIOR;</a>
<a name="ln4256">        else if (one_chance_in(3))</a>
<a name="ln4257">            mon = MONS_ORC_KNIGHT;</a>
<a name="ln4258">        else if (one_chance_in(10))</a>
<a name="ln4259">            mon = MONS_ORC_WARLORD;</a>
<a name="ln4260"> </a>
<a name="ln4261">        // Use the original monster type as the zombified type here, to</a>
<a name="ln4262">        // get the proper stats from it.</a>
<a name="ln4263">        if (monster *orc = create_monster(</a>
<a name="ln4264">                mgen_data(MONS_SPECTRAL_THING, SAME_ATTITUDE(mons), fpos,</a>
<a name="ln4265">                          mons-&gt;foe)</a>
<a name="ln4266">                .set_summoned(mons, abj, SPELL_SUMMON_SPECTRAL_ORCS, mons-&gt;god)</a>
<a name="ln4267">                .set_base(mon)))</a>
<a name="ln4268">        {</a>
<a name="ln4269">            // set which base type this orc is pretending to be for gear</a>
<a name="ln4270">            // purposes</a>
<a name="ln4271">            if (mon != MONS_ORC)</a>
<a name="ln4272">            {</a>
<a name="ln4273">                orc-&gt;mname = mons_type_name(mon, DESC_PLAIN);</a>
<a name="ln4274">                orc-&gt;flags |= MF_NAME_REPLACE | MF_NAME_DESCRIPTOR;</a>
<a name="ln4275">            }</a>
<a name="ln4276"> </a>
<a name="ln4277">            // give gear using the base type</a>
<a name="ln4278">            const int lvl = env.absdepth0;</a>
<a name="ln4279">            give_specific_item(orc, make_mons_weapon(orc-&gt;base_monster, lvl));</a>
<a name="ln4280">            give_specific_item(orc, make_mons_armour(orc-&gt;base_monster, lvl));</a>
<a name="ln4281">            // XXX: and a shield, for warlords...? (wasn't included before)</a>
<a name="ln4282"> </a>
<a name="ln4283">            // set gear as summoned</a>
<a name="ln4284">            orc-&gt;mark_summoned(abj, true, SPELL_SUMMON_SPECTRAL_ORCS);</a>
<a name="ln4285">        }</a>
<a name="ln4286">    }</a>
<a name="ln4287">}</a>
<a name="ln4288"> </a>
<a name="ln4289">static void _mons_vampiric_drain(monster &amp;mons, mon_spell_slot slot, bolt&amp;)</a>
<a name="ln4290">{</a>
<a name="ln4291">    actor *target = mons.get_foe();</a>
<a name="ln4292">    if (!target)</a>
<a name="ln4293">        return;</a>
<a name="ln4294">    if (grid_distance(mons.pos(), target-&gt;pos()) &gt; 1)</a>
<a name="ln4295">        return;</a>
<a name="ln4296"> </a>
<a name="ln4297">    const int pow = mons_spellpower(mons, slot.spell);</a>
<a name="ln4298">    int hp_cost = 3 + random2avg(9, 2) + 1;</a>
<a name="ln4299">    hp_cost += random2(pow) / 7; // force a sequence point between random calls</a>
<a name="ln4300"> </a>
<a name="ln4301">    hp_cost = min(hp_cost, target-&gt;stat_hp());</a>
<a name="ln4302">    hp_cost = min(hp_cost, mons.max_hit_points - mons.hit_points);</a>
<a name="ln4303"> </a>
<a name="ln4304">    hp_cost = resist_adjust_damage(target, BEAM_NEG, hp_cost);</a>
<a name="ln4305"> </a>
<a name="ln4306">    if (!hp_cost)</a>
<a name="ln4307">    {</a>
<a name="ln4308">        simple_monster_message(mons,</a>
<a name="ln4309">                               &quot; is infused with unholy energy, but nothing happens.&quot;,</a>
<a name="ln4310">                               MSGCH_MONSTER_SPELL);</a>
<a name="ln4311">        return;</a>
<a name="ln4312">    }</a>
<a name="ln4313"> </a>
<a name="ln4314">    dprf(&quot;vamp draining: %d damage, %d healing&quot;, hp_cost, hp_cost/2);</a>
<a name="ln4315"> </a>
<a name="ln4316">    if (you.can_see(mons))</a>
<a name="ln4317">    {</a>
<a name="ln4318">        simple_monster_message(mons,</a>
<a name="ln4319">                               &quot; is infused with unholy energy.&quot;,</a>
<a name="ln4320">                               MSGCH_MONSTER_SPELL);</a>
<a name="ln4321">    }</a>
<a name="ln4322">    else</a>
<a name="ln4323">        mpr(&quot;Unholy energy fills the air.&quot;);</a>
<a name="ln4324"> </a>
<a name="ln4325">    if (target-&gt;is_player())</a>
<a name="ln4326">    {</a>
<a name="ln4327">        ouch(hp_cost, KILLED_BY_BEAM, mons.mid, &quot;by vampiric draining&quot;);</a>
<a name="ln4328">        if (mons.heal(hp_cost * 2 / 3))</a>
<a name="ln4329">        {</a>
<a name="ln4330">            simple_monster_message(mons,</a>
<a name="ln4331">                &quot; draws life force from you and is healed!&quot;);</a>
<a name="ln4332">        }</a>
<a name="ln4333">    }</a>
<a name="ln4334">    else</a>
<a name="ln4335">    {</a>
<a name="ln4336">        monster* mtarget = target-&gt;as_monster();</a>
<a name="ln4337">        const string targname = mtarget-&gt;name(DESC_THE);</a>
<a name="ln4338">        mtarget-&gt;hurt(&amp;mons, hp_cost);</a>
<a name="ln4339">        if (mtarget-&gt;is_summoned())</a>
<a name="ln4340">        {</a>
<a name="ln4341">            simple_monster_message(mons,</a>
<a name="ln4342">                                   make_stringf(&quot; draws life force from %s!&quot;,</a>
<a name="ln4343">                                                targname.c_str()).c_str());</a>
<a name="ln4344">        }</a>
<a name="ln4345">        else if (mons.heal(hp_cost * 2 / 3))</a>
<a name="ln4346">        {</a>
<a name="ln4347">            simple_monster_message(mons,</a>
<a name="ln4348">                make_stringf(&quot; draws life force from %s and is healed!&quot;,</a>
<a name="ln4349">                targname.c_str()).c_str());</a>
<a name="ln4350">        }</a>
<a name="ln4351">        if (mtarget-&gt;alive())</a>
<a name="ln4352">            print_wounds(*mtarget);</a>
<a name="ln4353">    }</a>
<a name="ln4354">}</a>
<a name="ln4355"> </a>
<a name="ln4356">static bool _mons_cast_freeze(monster* mons)</a>
<a name="ln4357">{</a>
<a name="ln4358">    actor *target = mons-&gt;get_foe();</a>
<a name="ln4359">    if (!target)</a>
<a name="ln4360">        return false;</a>
<a name="ln4361">    if (grid_distance(mons-&gt;pos(), target-&gt;pos()) &gt; 1)</a>
<a name="ln4362">        return false;</a>
<a name="ln4363"> </a>
<a name="ln4364">    const int pow = mons_spellpower(*mons, SPELL_FREEZE);</a>
<a name="ln4365"> </a>
<a name="ln4366">    const int base_damage = roll_dice(1, 3 + pow / 6);</a>
<a name="ln4367">    int damage = 0;</a>
<a name="ln4368"> </a>
<a name="ln4369">    if (target-&gt;is_player())</a>
<a name="ln4370">        damage = resist_adjust_damage(&amp;you, BEAM_COLD, base_damage);</a>
<a name="ln4371">    else</a>
<a name="ln4372">    {</a>
<a name="ln4373">        bolt beam;</a>
<a name="ln4374">        beam.flavour = BEAM_COLD;</a>
<a name="ln4375">        damage = mons_adjust_flavoured(target-&gt;as_monster(), beam, base_damage);</a>
<a name="ln4376">    }</a>
<a name="ln4377"> </a>
<a name="ln4378">    if (you.can_see(*target))</a>
<a name="ln4379">    {</a>
<a name="ln4380">        mprf(&quot;%s %s frozen.&quot;, target-&gt;name(DESC_THE).c_str(),</a>
<a name="ln4381">                              target-&gt;conj_verb(&quot;are&quot;).c_str());</a>
<a name="ln4382">    }</a>
<a name="ln4383"> </a>
<a name="ln4384">    target-&gt;hurt(mons, damage, BEAM_COLD, KILLED_BY_BEAM, &quot;&quot;, &quot;by Freeze&quot;);</a>
<a name="ln4385"> </a>
<a name="ln4386">    if (target-&gt;alive())</a>
<a name="ln4387">    {</a>
<a name="ln4388">        target-&gt;expose_to_element(BEAM_COLD, damage);</a>
<a name="ln4389"> </a>
<a name="ln4390">        if (target-&gt;is_monster() &amp;&amp; target-&gt;res_cold() &lt;= 0)</a>
<a name="ln4391">        {</a>
<a name="ln4392">            const int stun = (1 - target-&gt;res_cold())</a>
<a name="ln4393">                             * random2(min(7, 2 + pow/24));</a>
<a name="ln4394">            target-&gt;as_monster()-&gt;speed_increment -= stun;</a>
<a name="ln4395">        }</a>
<a name="ln4396">    }</a>
<a name="ln4397"> </a>
<a name="ln4398">    return true;</a>
<a name="ln4399">}</a>
<a name="ln4400"> </a>
<a name="ln4401">void setup_breath_timeout(monster* mons)</a>
<a name="ln4402">{</a>
<a name="ln4403">    if (mons-&gt;has_ench(ENCH_BREATH_WEAPON))</a>
<a name="ln4404">        return;</a>
<a name="ln4405"> </a>
<a name="ln4406">    int timeout = roll_dice(1, 5);</a>
<a name="ln4407"> </a>
<a name="ln4408">    dprf(&quot;breath timeout: %d&quot;, timeout);</a>
<a name="ln4409"> </a>
<a name="ln4410">    mon_enchant breath_timeout = mon_enchant(ENCH_BREATH_WEAPON, 1, mons,</a>
<a name="ln4411">                                             timeout * BASELINE_DELAY);</a>
<a name="ln4412">    mons-&gt;add_ench(breath_timeout);</a>
<a name="ln4413">}</a>
<a name="ln4414"> </a>
<a name="ln4415">/**</a>
<a name="ln4416"> * Maybe mesmerise the player.</a>
<a name="ln4417"> *</a>
<a name="ln4418"> * This function decides whether or not it is possible for the player to become</a>
<a name="ln4419"> * mesmerised by mons. It will return a variety of values depending on whether</a>
<a name="ln4420"> * or not this can succeed or has succeeded; finally, it will add mons to the</a>
<a name="ln4421"> * player's list of beholders.</a>
<a name="ln4422"> *</a>
<a name="ln4423"> * @param mons      The monster doing the mesmerisation.</a>
<a name="ln4424"> * @param actual    Whether or not we are actually casting the spell. If false,</a>
<a name="ln4425"> *                  no messages are emitted.</a>
<a name="ln4426"> * @return          0 if the player could be mesmerised but wasn't, 1 if the</a>
<a name="ln4427"> *                  player was mesmerised, -1 if the player couldn't be</a>
<a name="ln4428"> *                  mesmerised.</a>
<a name="ln4429">**/</a>
<a name="ln4430">static int _mons_mesmerise(monster* mons, bool actual)</a>
<a name="ln4431">{</a>
<a name="ln4432">    ASSERT(mons); // XXX: change to monster &amp;mons</a>
<a name="ln4433">    bool already_mesmerised = you.beheld_by(*mons);</a>
<a name="ln4434"> </a>
<a name="ln4435">    if (!you.visible_to(mons)             // Don't mesmerise while invisible.</a>
<a name="ln4436">        || (!you.can_see(*mons)           // Or if we are, and you're aren't</a>
<a name="ln4437">            &amp;&amp; !already_mesmerised)       // already mesmerised by us.</a>
<a name="ln4438">        || !player_can_hear(mons-&gt;pos())  // Or if you're silenced, or we are.</a>
<a name="ln4439">        || you.berserk()                  // Or if you're berserk.</a>
<a name="ln4440">        || mons-&gt;has_ench(ENCH_CONFUSION) // Or we're confused,</a>
<a name="ln4441">        || mons_is_fleeing(*mons)          // fleeing,</a>
<a name="ln4442">        || mons-&gt;pacified()               // pacified,</a>
<a name="ln4443">        || mons-&gt;friendly())              // or friendly!</a>
<a name="ln4444">    {</a>
<a name="ln4445">        return -1;</a>
<a name="ln4446">    }</a>
<a name="ln4447"> </a>
<a name="ln4448">    if (actual)</a>
<a name="ln4449">    {</a>
<a name="ln4450">        if (!already_mesmerised)</a>
<a name="ln4451">        {</a>
<a name="ln4452">            simple_monster_message(*mons, &quot; attempts to bespell you!&quot;);</a>
<a name="ln4453">            flash_view(UA_MONSTER, LIGHTMAGENTA);</a>
<a name="ln4454">        }</a>
<a name="ln4455">        else</a>
<a name="ln4456">        {</a>
<a name="ln4457">            mprf(&quot;%s draws you further into %s thrall.&quot;,</a>
<a name="ln4458">                    mons-&gt;name(DESC_THE).c_str(),</a>
<a name="ln4459">                    mons-&gt;pronoun(PRONOUN_POSSESSIVE).c_str());</a>
<a name="ln4460">        }</a>
<a name="ln4461">    }</a>
<a name="ln4462"> </a>
<a name="ln4463">    const int pow = _ench_power(SPELL_MESMERISE, *mons);</a>
<a name="ln4464">    const int res_magic = you.check_res_magic(pow);</a>
<a name="ln4465"> </a>
<a name="ln4466">    // Don't mesmerise if you pass an MR check or have clarity.</a>
<a name="ln4467">    // If you're already mesmerised, you cannot resist further.</a>
<a name="ln4468">    if ((res_magic &gt; 0 || you.clarity()</a>
<a name="ln4469">         || you.duration[DUR_MESMERISE_IMMUNE]) &amp;&amp; !already_mesmerised)</a>
<a name="ln4470">    {</a>
<a name="ln4471">        if (actual)</a>
<a name="ln4472">        {</a>
<a name="ln4473">            if (you.clarity())</a>
<a name="ln4474">                canned_msg(MSG_YOU_UNAFFECTED);</a>
<a name="ln4475">            else if (you.duration[DUR_MESMERISE_IMMUNE] &amp;&amp; !already_mesmerised)</a>
<a name="ln4476">                canned_msg(MSG_YOU_RESIST);</a>
<a name="ln4477">            else</a>
<a name="ln4478">                mprf(&quot;You%s&quot;, you.resist_margin_phrase(res_magic).c_str());</a>
<a name="ln4479">        }</a>
<a name="ln4480"> </a>
<a name="ln4481">        return 0;</a>
<a name="ln4482">    }</a>
<a name="ln4483"> </a>
<a name="ln4484">    you.add_beholder(*mons);</a>
<a name="ln4485"> </a>
<a name="ln4486">    return 1;</a>
<a name="ln4487">}</a>
<a name="ln4488"> </a>
<a name="ln4489">// Check whether targets might be scared.</a>
<a name="ln4490">// Returns 0, if targets can be scared but the attempt failed or wasn't made.</a>
<a name="ln4491">// Returns 1, if targets are scared.</a>
<a name="ln4492">// Returns -1, if targets can never be scared.</a>
<a name="ln4493">static int _mons_cause_fear(monster* mons, bool actual)</a>
<a name="ln4494">{</a>
<a name="ln4495">    if (actual)</a>
<a name="ln4496">    {</a>
<a name="ln4497">        if (you.can_see(*mons))</a>
<a name="ln4498">            simple_monster_message(*mons, &quot; radiates an aura of fear!&quot;);</a>
<a name="ln4499">        else if (you.see_cell(mons-&gt;pos()))</a>
<a name="ln4500">            mpr(&quot;An aura of fear fills the air!&quot;);</a>
<a name="ln4501">    }</a>
<a name="ln4502"> </a>
<a name="ln4503">    int retval = -1;</a>
<a name="ln4504"> </a>
<a name="ln4505">    const int pow = _ench_power(SPELL_CAUSE_FEAR, *mons);</a>
<a name="ln4506"> </a>
<a name="ln4507">    if (mons-&gt;see_cell_no_trans(you.pos())</a>
<a name="ln4508">        &amp;&amp; mons-&gt;can_see(you)</a>
<a name="ln4509">        &amp;&amp; !mons-&gt;wont_attack()</a>
<a name="ln4510">        &amp;&amp; !you.afraid_of(mons))</a>
<a name="ln4511">    {</a>
<a name="ln4512">        if (!(you.holiness() &amp; MH_NATURAL))</a>
<a name="ln4513">        {</a>
<a name="ln4514">            if (actual)</a>
<a name="ln4515">                canned_msg(MSG_YOU_UNAFFECTED);</a>
<a name="ln4516">        }</a>
<a name="ln4517">        else if (!actual)</a>
<a name="ln4518">            retval = 0;</a>
<a name="ln4519">        else</a>
<a name="ln4520">        {</a>
<a name="ln4521">            const int res_margin = you.check_res_magic(pow);</a>
<a name="ln4522">            if (you.clarity())</a>
<a name="ln4523">                canned_msg(MSG_YOU_UNAFFECTED);</a>
<a name="ln4524">            else if (res_margin &gt; 0)</a>
<a name="ln4525">                mprf(&quot;You%s&quot;, you.resist_margin_phrase(res_margin).c_str());</a>
<a name="ln4526">            else if (you.add_fearmonger(mons))</a>
<a name="ln4527">            {</a>
<a name="ln4528">                retval = 1;</a>
<a name="ln4529"> </a>
<a name="ln4530">                you.increase_duration(DUR_AFRAID, 10 + random2avg(pow / 10, 4));</a>
<a name="ln4531"> </a>
<a name="ln4532">                if (!mons-&gt;has_ench(ENCH_FEAR_INSPIRING))</a>
<a name="ln4533">                    mons-&gt;add_ench(ENCH_FEAR_INSPIRING);</a>
<a name="ln4534">            }</a>
<a name="ln4535">        }</a>
<a name="ln4536">    }</a>
<a name="ln4537"> </a>
<a name="ln4538">    for (monster_near_iterator mi(mons-&gt;pos(), LOS_NO_TRANS); mi; ++mi)</a>
<a name="ln4539">    {</a>
<a name="ln4540">        if (*mi == mons)</a>
<a name="ln4541">            continue;</a>
<a name="ln4542"> </a>
<a name="ln4543">        // Magic-immune, unnatural and &quot;firewood&quot; monsters are</a>
<a name="ln4544">        // immune to being scared. Same-aligned monsters are</a>
<a name="ln4545">        // never affected, even though they aren't immune.</a>
<a name="ln4546">        // Will not further scare a monster that is already afraid.</a>
<a name="ln4547">        if (mons_immune_magic(**mi)</a>
<a name="ln4548">            || !(mi-&gt;holiness() &amp; MH_NATURAL)</a>
<a name="ln4549">            || mons_is_firewood(**mi)</a>
<a name="ln4550">            || mons_atts_aligned(mi-&gt;attitude, mons-&gt;attitude)</a>
<a name="ln4551">            || mi-&gt;has_ench(ENCH_FEAR))</a>
<a name="ln4552">        {</a>
<a name="ln4553">            continue;</a>
<a name="ln4554">        }</a>
<a name="ln4555"> </a>
<a name="ln4556">        retval = max(retval, 0);</a>
<a name="ln4557"> </a>
<a name="ln4558">        if (!actual)</a>
<a name="ln4559">            continue;</a>
<a name="ln4560"> </a>
<a name="ln4561">        // It's possible to scare this monster. If its magic</a>
<a name="ln4562">        // resistance fails, do so.</a>
<a name="ln4563">        int res_margin = mi-&gt;check_res_magic(pow);</a>
<a name="ln4564">        if (res_margin &gt; 0)</a>
<a name="ln4565">        {</a>
<a name="ln4566">            simple_monster_message(**mi,</a>
<a name="ln4567">                mi-&gt;resist_margin_phrase(res_margin).c_str());</a>
<a name="ln4568">            continue;</a>
<a name="ln4569">        }</a>
<a name="ln4570"> </a>
<a name="ln4571">        if (mi-&gt;add_ench(mon_enchant(ENCH_FEAR, 0, mons)))</a>
<a name="ln4572">        {</a>
<a name="ln4573">            retval = 1;</a>
<a name="ln4574"> </a>
<a name="ln4575">            if (you.can_see(**mi))</a>
<a name="ln4576">                simple_monster_message(**mi, &quot; looks frightened!&quot;);</a>
<a name="ln4577"> </a>
<a name="ln4578">            behaviour_event(*mi, ME_SCARE, mons);</a>
<a name="ln4579"> </a>
<a name="ln4580">            if (!mons-&gt;has_ench(ENCH_FEAR_INSPIRING))</a>
<a name="ln4581">                mons-&gt;add_ench(ENCH_FEAR_INSPIRING);</a>
<a name="ln4582">        }</a>
<a name="ln4583">    }</a>
<a name="ln4584"> </a>
<a name="ln4585">    if (actual &amp;&amp; retval == 1 &amp;&amp; you.see_cell(mons-&gt;pos()))</a>
<a name="ln4586">        flash_view_delay(UA_MONSTER, DARKGREY, 300);</a>
<a name="ln4587"> </a>
<a name="ln4588">    return retval;</a>
<a name="ln4589">}</a>
<a name="ln4590"> </a>
<a name="ln4591">static int _mons_mass_confuse(monster* mons, bool actual)</a>
<a name="ln4592">{</a>
<a name="ln4593">    int retval = -1;</a>
<a name="ln4594"> </a>
<a name="ln4595">    const int pow = _ench_power(SPELL_MASS_CONFUSION, *mons);</a>
<a name="ln4596"> </a>
<a name="ln4597">    if (mons-&gt;see_cell_no_trans(you.pos())</a>
<a name="ln4598">        &amp;&amp; mons-&gt;can_see(you)</a>
<a name="ln4599">        &amp;&amp; !mons-&gt;wont_attack())</a>
<a name="ln4600">    {</a>
<a name="ln4601">        retval = 0;</a>
<a name="ln4602"> </a>
<a name="ln4603">        if (actual)</a>
<a name="ln4604">        {</a>
<a name="ln4605">            const int res_magic = you.check_res_magic(pow);</a>
<a name="ln4606">            if (res_magic &gt; 0)</a>
<a name="ln4607">                mprf(&quot;You%s&quot;, you.resist_margin_phrase(res_magic).c_str());</a>
<a name="ln4608">            else</a>
<a name="ln4609">            {</a>
<a name="ln4610">                you.confuse(mons, 5 + random2(3));</a>
<a name="ln4611">                retval = 1;</a>
<a name="ln4612">            }</a>
<a name="ln4613">        }</a>
<a name="ln4614">    }</a>
<a name="ln4615"> </a>
<a name="ln4616">    for (monster_near_iterator mi(mons-&gt;pos(), LOS_NO_TRANS); mi; ++mi)</a>
<a name="ln4617">    {</a>
<a name="ln4618">        if (*mi == mons)</a>
<a name="ln4619">            continue;</a>
<a name="ln4620"> </a>
<a name="ln4621">        if (mons_immune_magic(**mi)</a>
<a name="ln4622">            || mons_is_firewood(**mi)</a>
<a name="ln4623">            || mons_atts_aligned(mi-&gt;attitude, mons-&gt;attitude)</a>
<a name="ln4624">            || mons-&gt;has_ench(ENCH_HEXED))</a>
<a name="ln4625">        {</a>
<a name="ln4626">            continue;</a>
<a name="ln4627">        }</a>
<a name="ln4628"> </a>
<a name="ln4629">        retval = max(retval, 0);</a>
<a name="ln4630"> </a>
<a name="ln4631">        int res_margin = mi-&gt;check_res_magic(pow);</a>
<a name="ln4632">        if (res_margin &gt; 0)</a>
<a name="ln4633">        {</a>
<a name="ln4634">            if (actual)</a>
<a name="ln4635">            {</a>
<a name="ln4636">                simple_monster_message(**mi,</a>
<a name="ln4637">                    mi-&gt;resist_margin_phrase(res_margin).c_str());</a>
<a name="ln4638">            }</a>
<a name="ln4639">            continue;</a>
<a name="ln4640">        }</a>
<a name="ln4641">        if (actual)</a>
<a name="ln4642">        {</a>
<a name="ln4643">            retval = 1;</a>
<a name="ln4644">            mi-&gt;confuse(mons, 5 + random2(3));</a>
<a name="ln4645">        }</a>
<a name="ln4646">    }</a>
<a name="ln4647"> </a>
<a name="ln4648">    return retval;</a>
<a name="ln4649">}</a>
<a name="ln4650"> </a>
<a name="ln4651">static coord_def _mons_fragment_target(const monster &amp;mon)</a>
<a name="ln4652">{</a>
<a name="ln4653">    coord_def target(GXM+1, GYM+1);</a>
<a name="ln4654">    const monster *mons = &amp;mon; // TODO: rewriteme</a>
<a name="ln4655">    const int pow = mons_spellpower(*mons, SPELL_LRD);</a>
<a name="ln4656"> </a>
<a name="ln4657">    // Shadow casting should try to affect the same tile as the player.</a>
<a name="ln4658">    if (mons_is_player_shadow(*mons))</a>
<a name="ln4659">    {</a>
<a name="ln4660">        bool temp;</a>
<a name="ln4661">        bolt beam;</a>
<a name="ln4662">        if (!setup_fragmentation_beam(beam, pow, mons, mons-&gt;target, true,</a>
<a name="ln4663">                                      nullptr, temp))</a>
<a name="ln4664">        {</a>
<a name="ln4665">            return target;</a>
<a name="ln4666">        }</a>
<a name="ln4667">        return mons-&gt;target;</a>
<a name="ln4668">    }</a>
<a name="ln4669"> </a>
<a name="ln4670">    const int range = _mons_spell_range(*mons, SPELL_LRD);</a>
<a name="ln4671">    int maxpower = 0;</a>
<a name="ln4672">    for (distance_iterator di(mons-&gt;pos(), true, true, range); di; ++di)</a>
<a name="ln4673">    {</a>
<a name="ln4674">        bool temp;</a>
<a name="ln4675"> </a>
<a name="ln4676">        if (!cell_see_cell(mons-&gt;pos(), *di, LOS_SOLID))</a>
<a name="ln4677">            continue;</a>
<a name="ln4678"> </a>
<a name="ln4679">        bolt beam;</a>
<a name="ln4680">        if (!setup_fragmentation_beam(beam, pow, mons, *di, true, nullptr,</a>
<a name="ln4681">                                      temp))</a>
<a name="ln4682">        {</a>
<a name="ln4683">            continue;</a>
<a name="ln4684">        }</a>
<a name="ln4685"> </a>
<a name="ln4686">        beam.range = range;</a>
<a name="ln4687">        fire_tracer(mons, beam, true);</a>
<a name="ln4688">        if (!mons_should_fire(beam))</a>
<a name="ln4689">            continue;</a>
<a name="ln4690"> </a>
<a name="ln4691">        if (beam.foe_info.count &gt; 0</a>
<a name="ln4692">            &amp;&amp; beam.foe_info.power &gt; maxpower)</a>
<a name="ln4693">        {</a>
<a name="ln4694">            maxpower = beam.foe_info.power;</a>
<a name="ln4695">            target = *di;</a>
<a name="ln4696">        }</a>
<a name="ln4697">    }</a>
<a name="ln4698"> </a>
<a name="ln4699">    return target;</a>
<a name="ln4700">}</a>
<a name="ln4701"> </a>
<a name="ln4702">static void _blink_allies_encircle(const monster* mon)</a>
<a name="ln4703">{</a>
<a name="ln4704">    vector&lt;monster*&gt; allies;</a>
<a name="ln4705">    const coord_def foepos = mon-&gt;get_foe()-&gt;pos();</a>
<a name="ln4706"> </a>
<a name="ln4707">    for (monster_near_iterator mi(mon, LOS_NO_TRANS); mi; ++mi)</a>
<a name="ln4708">    {</a>
<a name="ln4709">        if (_valid_encircle_ally(mon, *mi, foepos))</a>
<a name="ln4710">            allies.push_back(*mi);</a>
<a name="ln4711">    }</a>
<a name="ln4712">    shuffle_array(allies);</a>
<a name="ln4713"> </a>
<a name="ln4714">    int count = max(1, mon-&gt;spell_hd(SPELL_BLINK_ALLIES_ENCIRCLE) / 8</a>
<a name="ln4715">                       + random2(mon-&gt;spell_hd(SPELL_BLINK_ALLIES_ENCIRCLE) / 4));</a>
<a name="ln4716"> </a>
<a name="ln4717">    for (monster *ally : allies)</a>
<a name="ln4718">    {</a>
<a name="ln4719">        coord_def empty;</a>
<a name="ln4720">        if (find_habitable_spot_near(foepos, mons_base_type(*ally), 1, false, empty))</a>
<a name="ln4721">        {</a>
<a name="ln4722">            if (ally-&gt;blink_to(empty))</a>
<a name="ln4723">            {</a>
<a name="ln4724">                // XXX: This seems an awkward way to give a message for something</a>
<a name="ln4725">                // blinking from out of sight into sight. Probably could use a</a>
<a name="ln4726">                // more general solution.</a>
<a name="ln4727">                if (!(ally-&gt;flags &amp; MF_WAS_IN_VIEW)</a>
<a name="ln4728">                    &amp;&amp; ally-&gt;flags &amp; MF_SEEN)</a>
<a name="ln4729">                {</a>
<a name="ln4730">                    simple_monster_message(*ally, &quot; blinks into view!&quot;);</a>
<a name="ln4731">                }</a>
<a name="ln4732">                ally-&gt;behaviour = BEH_SEEK;</a>
<a name="ln4733">                ally-&gt;foe = mon-&gt;foe;</a>
<a name="ln4734">                count--;</a>
<a name="ln4735">            }</a>
<a name="ln4736">        }</a>
<a name="ln4737">    }</a>
<a name="ln4738">}</a>
<a name="ln4739"> </a>
<a name="ln4740">static void _blink_allies_away(const monster* mon)</a>
<a name="ln4741">{</a>
<a name="ln4742">    vector&lt;monster*&gt; allies;</a>
<a name="ln4743">    const coord_def foepos = mon-&gt;get_foe()-&gt;pos();</a>
<a name="ln4744"> </a>
<a name="ln4745">    for (monster_near_iterator mi(mon, LOS_NO_TRANS); mi; ++mi)</a>
<a name="ln4746">    {</a>
<a name="ln4747">        if (_valid_blink_away_ally(mon, *mi, foepos))</a>
<a name="ln4748">            allies.push_back(*mi);</a>
<a name="ln4749">    }</a>
<a name="ln4750">    shuffle_array(allies);</a>
<a name="ln4751"> </a>
<a name="ln4752">    int count = max(1, mon-&gt;spell_hd(SPELL_BLINK_ALLIES_AWAY) / 8</a>
<a name="ln4753">                       + random2(mon-&gt;spell_hd(SPELL_BLINK_ALLIES_AWAY) / 4));</a>
<a name="ln4754"> </a>
<a name="ln4755">    for (unsigned int i = 0; i &lt; allies.size() &amp;&amp; count; ++i)</a>
<a name="ln4756">    {</a>
<a name="ln4757">        if (blink_away(allies[i], &amp;you, false))</a>
<a name="ln4758">            count--;</a>
<a name="ln4759">    }</a>
<a name="ln4760">}</a>
<a name="ln4761"> </a>
<a name="ln4762">struct branch_summon_pair</a>
<a name="ln4763">{</a>
<a name="ln4764">    branch_type     origin;</a>
<a name="ln4765">    const pop_entry *pop;</a>
<a name="ln4766">};</a>
<a name="ln4767"> </a>
<a name="ln4768">static const pop_entry _invitation_lair[] =</a>
<a name="ln4769">{ // Lair enemies</a>
<a name="ln4770">  {  1,   1,   60, FLAT, MONS_BLINK_FROG },</a>
<a name="ln4771">  {  1,   1,   40, FLAT, MONS_DREAM_SHEEP },</a>
<a name="ln4772">  {  1,   1,   20, FLAT, MONS_SPINY_FROG },</a>
<a name="ln4773">  { 0,0,0,FLAT,MONS_0 }</a>
<a name="ln4774">};</a>
<a name="ln4775"> </a>
<a name="ln4776">static const pop_entry _invitation_snake[] =</a>
<a name="ln4777">{ // Snake enemies</a>
<a name="ln4778">  {  1,   1,   80, FLAT, MONS_NAGA },</a>
<a name="ln4779">  {  1,   1,   40, FLAT, MONS_BLACK_MAMBA },</a>
<a name="ln4780">  {  1,   1,   20, FLAT, MONS_MANA_VIPER },</a>
<a name="ln4781">  { 0,0,0,FLAT,MONS_0 }</a>
<a name="ln4782">};</a>
<a name="ln4783"> </a>
<a name="ln4784">static const pop_entry _invitation_spider[] =</a>
<a name="ln4785">{ // Spider enemies</a>
<a name="ln4786">  {  1,   1,   60, FLAT, MONS_TARANTELLA },</a>
<a name="ln4787">  {  1,   1,   80, FLAT, MONS_JUMPING_SPIDER },</a>
<a name="ln4788">  {  1,   1,   20, FLAT, MONS_ORB_SPIDER },</a>
<a name="ln4789">  { 0,0,0,FLAT,MONS_0 }</a>
<a name="ln4790">};</a>
<a name="ln4791"> </a>
<a name="ln4792">static const pop_entry _invitation_swamp[] =</a>
<a name="ln4793">{ // Swamp enemies</a>
<a name="ln4794">  {  1,   1,   80, FLAT, MONS_VAMPIRE_MOSQUITO },</a>
<a name="ln4795">  {  1,   1,   60, FLAT, MONS_INSUBSTANTIAL_WISP },</a>
<a name="ln4796">  {  1,   1,   40, FLAT, MONS_SWAMP_DRAKE },</a>
<a name="ln4797">  { 0,0,0,FLAT,MONS_0 }</a>
<a name="ln4798">};</a>
<a name="ln4799"> </a>
<a name="ln4800">static const pop_entry _invitation_shoals[] =</a>
<a name="ln4801">{ // Swamp enemies</a>
<a name="ln4802">  {  1,   1,   60, FLAT, MONS_MERFOLK_SIREN },</a>
<a name="ln4803">  {  1,   1,   40, FLAT, MONS_MANTICORE },</a>
<a name="ln4804">  {  1,   1,   20, FLAT, MONS_WIND_DRAKE },</a>
<a name="ln4805">  { 0,0,0,FLAT,MONS_0 }</a>
<a name="ln4806">};</a>
<a name="ln4807"> </a>
<a name="ln4808">static const pop_entry _invitation_orc[] =</a>
<a name="ln4809">{ // Orc enemies</a>
<a name="ln4810">  {  1,   1,   80, FLAT, MONS_ORC_PRIEST },</a>
<a name="ln4811">  {  1,   1,   40, FLAT, MONS_WARG },</a>
<a name="ln4812">  {  1,   1,   20, FLAT, MONS_TROLL },</a>
<a name="ln4813">  { 0,0,0,FLAT,MONS_0 }</a>
<a name="ln4814">};</a>
<a name="ln4815"> </a>
<a name="ln4816">static const pop_entry _invitation_elf[] =</a>
<a name="ln4817">{ // Elf enemies</a>
<a name="ln4818">  {  1,   1,  100, FLAT, MONS_DEEP_ELF_MAGE },</a>
<a name="ln4819">  {  1,   1,   40, FLAT, MONS_DEEP_ELF_KNIGHT },</a>
<a name="ln4820">  {  1,   1,   40, FLAT, MONS_DEEP_ELF_ARCHER },</a>
<a name="ln4821">  { 0,0,0,FLAT,MONS_0 }</a>
<a name="ln4822">};</a>
<a name="ln4823"> </a>
<a name="ln4824">static const pop_entry _invitation_vaults[] =</a>
<a name="ln4825">{ // Vaults enemies</a>
<a name="ln4826">  {  1,   1,   60, FLAT, MONS_YAKTAUR },</a>
<a name="ln4827">  {  1,   1,   40, FLAT, MONS_IRONHEART_PRESERVER },</a>
<a name="ln4828">  {  1,   1,   20, FLAT, MONS_VAULT_SENTINEL },</a>
<a name="ln4829">  { 0,0,0,FLAT,MONS_0 }</a>
<a name="ln4830">};</a>
<a name="ln4831"> </a>
<a name="ln4832">static const pop_entry _invitation_crypt[] =</a>
<a name="ln4833">{ // Crypt enemies</a>
<a name="ln4834">  {  1,   1,   80, FLAT, MONS_WRAITH },</a>
<a name="ln4835">  {  1,   1,   60, FLAT, MONS_SHADOW },</a>
<a name="ln4836">  {  1,   1,   20, FLAT, MONS_NECROMANCER },</a>
<a name="ln4837">  { 0,0,0,FLAT,MONS_0 }</a>
<a name="ln4838">};</a>
<a name="ln4839"> </a>
<a name="ln4840">static branch_summon_pair _invitation_summons[] =</a>
<a name="ln4841">{</a>
<a name="ln4842">  { BRANCH_LAIR,   _invitation_lair },</a>
<a name="ln4843">  { BRANCH_SNAKE,  _invitation_snake },</a>
<a name="ln4844">  { BRANCH_SPIDER, _invitation_spider },</a>
<a name="ln4845">  { BRANCH_SWAMP,  _invitation_swamp },</a>
<a name="ln4846">  { BRANCH_SHOALS, _invitation_shoals },</a>
<a name="ln4847">  { BRANCH_ORC,    _invitation_orc },</a>
<a name="ln4848">  { BRANCH_ELF,    _invitation_elf },</a>
<a name="ln4849">  { BRANCH_VAULTS, _invitation_vaults },</a>
<a name="ln4850">  { BRANCH_CRYPT,  _invitation_crypt }</a>
<a name="ln4851">};</a>
<a name="ln4852"> </a>
<a name="ln4853">static const pop_entry _planerend_snake[] =</a>
<a name="ln4854">{ // Snake enemies</a>
<a name="ln4855">  {  1,   1,   40, FLAT, MONS_ANACONDA },</a>
<a name="ln4856">  {  1,   1,  100, FLAT, MONS_GUARDIAN_SERPENT },</a>
<a name="ln4857">  {  1,   1,  100, FLAT, MONS_NAGARAJA },</a>
<a name="ln4858">  { 0,0,0,FLAT,MONS_0 }</a>
<a name="ln4859">};</a>
<a name="ln4860"> </a>
<a name="ln4861">static const pop_entry _planerend_spider[] =</a>
<a name="ln4862">{ // Spider enemies</a>
<a name="ln4863">  {  1,   1,  100, FLAT, MONS_EMPEROR_SCORPION },</a>
<a name="ln4864">  {  1,   1,   80, FLAT, MONS_TORPOR_SNAIL },</a>
<a name="ln4865">  {  1,   1,  100, FLAT, MONS_GHOST_MOTH },</a>
<a name="ln4866">  { 0,0,0,FLAT,MONS_0 }</a>
<a name="ln4867">};</a>
<a name="ln4868"> </a>
<a name="ln4869">static const pop_entry _planerend_swamp[] =</a>
<a name="ln4870">{ // Swamp enemies</a>
<a name="ln4871">  {  1,   1,  100, FLAT, MONS_SWAMP_DRAGON },</a>
<a name="ln4872">  {  1,   1,   80, FLAT, MONS_SHAMBLING_MANGROVE },</a>
<a name="ln4873">  {  1,   1,   40, FLAT, MONS_THORN_HUNTER },</a>
<a name="ln4874">  { 0,0,0,FLAT,MONS_0 }</a>
<a name="ln4875">};</a>
<a name="ln4876"> </a>
<a name="ln4877">static const pop_entry _planerend_shoals[] =</a>
<a name="ln4878">{ // Shoals enemies</a>
<a name="ln4879">  {  1,   1,   80, FLAT, MONS_ALLIGATOR_SNAPPING_TURTLE },</a>
<a name="ln4880">  {  1,   1,   40, FLAT, MONS_WATER_NYMPH },</a>
<a name="ln4881">  {  1,   1,  100, FLAT, MONS_MERFOLK_JAVELINEER },</a>
<a name="ln4882">  { 0,0,0,FLAT,MONS_0 }</a>
<a name="ln4883">};</a>
<a name="ln4884"> </a>
<a name="ln4885">static const pop_entry _planerend_slime[] =</a>
<a name="ln4886">{ // Slime enemies</a>
<a name="ln4887">  {  1,   1,   80, FLAT, MONS_SLIME_CREATURE }, // changed to titanic below</a>
<a name="ln4888">  {  1,   1,  100, FLAT, MONS_AZURE_JELLY },</a>
<a name="ln4889">  {  1,   1,  100, FLAT, MONS_ACID_BLOB },</a>
<a name="ln4890">  { 0,0,0,FLAT,MONS_0 }</a>
<a name="ln4891">};</a>
<a name="ln4892"> </a>
<a name="ln4893">static const pop_entry _planerend_elf[] =</a>
<a name="ln4894">{ // Elf enemies</a>
<a name="ln4895">  {  1,   1,  100, FLAT, MONS_DEEP_ELF_SORCERER },</a>
<a name="ln4896">  {  1,   1,  100, FLAT, MONS_DEEP_ELF_HIGH_PRIEST },</a>
<a name="ln4897">  {  1,   1,   60, FLAT, MONS_DEEP_ELF_BLADEMASTER },</a>
<a name="ln4898">  { 0,0,0,FLAT,MONS_0 }</a>
<a name="ln4899">};</a>
<a name="ln4900"> </a>
<a name="ln4901">static const pop_entry _planerend_vaults[] =</a>
<a name="ln4902">{ // Vaults enemies</a>
<a name="ln4903">  {  1,   1,   80, FLAT, MONS_VAULT_SENTINEL },</a>
<a name="ln4904">  {  1,   1,   40, FLAT, MONS_IRONBRAND_CONVOKER },</a>
<a name="ln4905">  {  1,   1,  100, FLAT, MONS_WAR_GARGOYLE },</a>
<a name="ln4906">  { 0,0,0,FLAT,MONS_0 }</a>
<a name="ln4907">};</a>
<a name="ln4908"> </a>
<a name="ln4909">static const pop_entry _planerend_crypt[] =</a>
<a name="ln4910">{ // Crypt enemies</a>
<a name="ln4911">  {  1,   1,  100, FLAT, MONS_VAMPIRE_KNIGHT },</a>
<a name="ln4912">  {  1,   1,  100, FLAT, MONS_FLAYED_GHOST },</a>
<a name="ln4913">  {  1,   1,   80, FLAT, MONS_REVENANT },</a>
<a name="ln4914">  { 0,0,0,FLAT,MONS_0 }</a>
<a name="ln4915">};</a>
<a name="ln4916"> </a>
<a name="ln4917">static const pop_entry _planerend_tomb[] =</a>
<a name="ln4918">{ // Tomb enemies</a>
<a name="ln4919">  {  1,   1,   60, FLAT, MONS_ANCIENT_CHAMPION },</a>
<a name="ln4920">  {  1,   1,  100, FLAT, MONS_SPHINX },</a>
<a name="ln4921">  {  1,   1,  100, FLAT, MONS_MUMMY_PRIEST },</a>
<a name="ln4922">  { 0,0,0,FLAT,MONS_0 }</a>
<a name="ln4923">};</a>
<a name="ln4924"> </a>
<a name="ln4925">static const pop_entry _planerend_abyss[] =</a>
<a name="ln4926">{ // Abyss enemies</a>
<a name="ln4927">  {  1,   1,   80, FLAT, MONS_APOCALYPSE_CRAB },</a>
<a name="ln4928">  {  1,   1,  100, FLAT, MONS_STARCURSED_MASS },</a>
<a name="ln4929">  {  1,   1,   40, FLAT, MONS_WRETCHED_STAR },</a>
<a name="ln4930">  { 0,0,0,FLAT,MONS_0 }</a>
<a name="ln4931">};</a>
<a name="ln4932"> </a>
<a name="ln4933">static const pop_entry _planerend_zot[] =</a>
<a name="ln4934">{ // Zot enemies</a>
<a name="ln4935">  {  1,   1,   40, FLAT, MONS_DRACONIAN_STORMCALLER },</a>
<a name="ln4936">  {  1,   1,  100, FLAT, MONS_GOLDEN_DRAGON },</a>
<a name="ln4937">  {  1,   1,   80, FLAT, MONS_MOTH_OF_WRATH },</a>
<a name="ln4938">  { 0,0,0,FLAT,MONS_0 }</a>
<a name="ln4939">};</a>
<a name="ln4940"> </a>
<a name="ln4941">static branch_summon_pair _planerend_summons[] =</a>
<a name="ln4942">{</a>
<a name="ln4943">  { BRANCH_SNAKE,  _planerend_snake },</a>
<a name="ln4944">  { BRANCH_SPIDER, _planerend_spider },</a>
<a name="ln4945">  { BRANCH_SWAMP,  _planerend_swamp },</a>
<a name="ln4946">  { BRANCH_SHOALS, _planerend_shoals },</a>
<a name="ln4947">  { BRANCH_SLIME,  _planerend_slime },</a>
<a name="ln4948">  { BRANCH_ELF,    _planerend_elf },</a>
<a name="ln4949">  { BRANCH_VAULTS, _planerend_vaults },</a>
<a name="ln4950">  { BRANCH_CRYPT,  _planerend_crypt },</a>
<a name="ln4951">  { BRANCH_TOMB,   _planerend_tomb },</a>
<a name="ln4952">  { BRANCH_ABYSS,  _planerend_abyss },</a>
<a name="ln4953">  { BRANCH_ZOT,    _planerend_zot }</a>
<a name="ln4954">};</a>
<a name="ln4955"> </a>
<a name="ln4956">static void _branch_summon(monster &amp;mons, mon_spell_slot slot, bolt&amp;)</a>
<a name="ln4957">{</a>
<a name="ln4958">    _branch_summon_helper(&amp;mons, slot.spell);</a>
<a name="ln4959">}</a>
<a name="ln4960"> </a>
<a name="ln4961">static void _branch_summon_helper(monster* mons, spell_type spell_cast)</a>
<a name="ln4962">{</a>
<a name="ln4963">    // TODO: rewrite me! (should use maps, vectors, const monster&amp;...)</a>
<a name="ln4964">    branch_summon_pair *summon_list;</a>
<a name="ln4965">    size_t list_size;</a>
<a name="ln4966">    int which_branch;</a>
<a name="ln4967">    static const string INVITATION_KEY = &quot;invitation_branch&quot;;</a>
<a name="ln4968"> </a>
<a name="ln4969">    switch (spell_cast)</a>
<a name="ln4970">    {</a>
<a name="ln4971">        case SPELL_FORCEFUL_INVITATION:</a>
<a name="ln4972">            summon_list = _invitation_summons;</a>
<a name="ln4973">            list_size = ARRAYSZ(_invitation_summons);</a>
<a name="ln4974">            if (!mons-&gt;props.exists(INVITATION_KEY))</a>
<a name="ln4975">                mons-&gt;props[INVITATION_KEY].get_byte() = random2(list_size);</a>
<a name="ln4976">            which_branch = mons-&gt;props[INVITATION_KEY].get_byte();</a>
<a name="ln4977">            break;</a>
<a name="ln4978">        case SPELL_PLANEREND:</a>
<a name="ln4979">            summon_list = _planerend_summons;</a>
<a name="ln4980">            list_size = ARRAYSZ(_planerend_summons);</a>
<a name="ln4981">            which_branch = random2(list_size);</a>
<a name="ln4982">            break;</a>
<a name="ln4983">        default:</a>
<a name="ln4984">            die(&quot;Unsupported branch summon spell %s!&quot;,</a>
<a name="ln4985">                 spell_title(spell_cast));</a>
<a name="ln4986">    }</a>
<a name="ln4987">    const int num_summons = random_range(1, 3);</a>
<a name="ln4988"> </a>
<a name="ln4989">    if (you.see_cell(mons-&gt;pos()))</a>
<a name="ln4990">    {</a>
<a name="ln4991">        string msg = getSpeakString(&quot;branch summon cast prefix&quot;);</a>
<a name="ln4992">        if (!msg.empty())</a>
<a name="ln4993">        {</a>
<a name="ln4994">            msg  = replace_all(msg, &quot;@The_monster@&quot;, mons-&gt;name(DESC_THE));</a>
<a name="ln4995">            msg += &quot; &quot;;</a>
<a name="ln4996">            msg += branches[summon_list[which_branch].origin].longname;</a>
<a name="ln4997">            msg += &quot;!&quot;;</a>
<a name="ln4998">            mprf(mons-&gt;wont_attack() ? MSGCH_FRIEND_ENCHANT</a>
<a name="ln4999">                                     : MSGCH_MONSTER_ENCHANT,</a>
<a name="ln5000">                 &quot;%s&quot;, msg.c_str());</a>
<a name="ln5001">        }</a>
<a name="ln5002">    }</a>
<a name="ln5003"> </a>
<a name="ln5004">    for (int i = 0; i &lt; num_summons; i++)</a>
<a name="ln5005">    {</a>
<a name="ln5006">        monster_type type = pick_monster_from(summon_list[which_branch].pop, 1);</a>
<a name="ln5007">        if (type == MONS_NO_MONSTER)</a>
<a name="ln5008">            continue;</a>
<a name="ln5009"> </a>
<a name="ln5010">        mgen_data mg(type, SAME_ATTITUDE(mons), mons-&gt;pos(), mons-&gt;foe);</a>
<a name="ln5011">        mg.set_summoned(mons, 1, spell_cast);</a>
<a name="ln5012">        if (type == MONS_SLIME_CREATURE)</a>
<a name="ln5013">            mg.props[MGEN_BLOB_SIZE] = 5;</a>
<a name="ln5014">        create_monster(mg);</a>
<a name="ln5015">    }</a>
<a name="ln5016">}</a>
<a name="ln5017"> </a>
<a name="ln5018">static void _cast_flay(monster &amp;caster, mon_spell_slot, bolt&amp;)</a>
<a name="ln5019">{</a>
<a name="ln5020">    actor* defender = caster.get_foe();</a>
<a name="ln5021">    ASSERT(defender);</a>
<a name="ln5022"> </a>
<a name="ln5023">    int damage_taken = 0;</a>
<a name="ln5024">    if (defender-&gt;is_player())</a>
<a name="ln5025">    {</a>
<a name="ln5026">        damage_taken = (6 + (you.hp * 18 / you.hp_max)) * you.hp_max / 100;</a>
<a name="ln5027">        damage_taken = min(damage_taken,</a>
<a name="ln5028">                           max(0, you.hp - 25 - random2(15)));</a>
<a name="ln5029">    }</a>
<a name="ln5030">    else</a>
<a name="ln5031">    {</a>
<a name="ln5032">        monster* mon = defender-&gt;as_monster();</a>
<a name="ln5033"> </a>
<a name="ln5034">        damage_taken = (6 + (mon-&gt;hit_points * 18 / mon-&gt;max_hit_points))</a>
<a name="ln5035">                       * mon-&gt;max_hit_points / 100;</a>
<a name="ln5036">        damage_taken = min(damage_taken,</a>
<a name="ln5037">                           max(0, mon-&gt;hit_points - 25 - random2(15)));</a>
<a name="ln5038">    }</a>
<a name="ln5039"> </a>
<a name="ln5040">    flay(caster, *defender, damage_taken);</a>
<a name="ln5041">}</a>
<a name="ln5042"> </a>
<a name="ln5043">/**</a>
<a name="ln5044"> * Attempt to flay the given target, dealing 'temporary' damage that heals when</a>
<a name="ln5045"> * a flayed ghost nearby dies.</a>
<a name="ln5046"> *</a>
<a name="ln5047"> * @param caster    The flayed ghost doing the flaying. (Mostly irrelevant.)</a>
<a name="ln5048"> * @param defender  The thing being flayed.</a>
<a name="ln5049"> * @param damage    How much flaying damage to do.</a>
<a name="ln5050"> */</a>
<a name="ln5051">void flay(const monster &amp;caster, actor &amp;defender, int damage)</a>
<a name="ln5052">{</a>
<a name="ln5053">    if (damage &lt; 10)</a>
<a name="ln5054">        return;</a>
<a name="ln5055"> </a>
<a name="ln5056">    bool was_flayed = false;</a>
<a name="ln5057"> </a>
<a name="ln5058">    if (defender.is_player())</a>
<a name="ln5059">    {</a>
<a name="ln5060">        if (you.duration[DUR_FLAYED])</a>
<a name="ln5061">            was_flayed = true;</a>
<a name="ln5062"> </a>
<a name="ln5063">        you.duration[DUR_FLAYED] = max(you.duration[DUR_FLAYED],</a>
<a name="ln5064">                                       55 + random2(66));</a>
<a name="ln5065">    }</a>
<a name="ln5066">    else</a>
<a name="ln5067">    {</a>
<a name="ln5068">        monster* mon = defender.as_monster();</a>
<a name="ln5069">        const int added_dur = 30 + random2(50);</a>
<a name="ln5070"> </a>
<a name="ln5071">        if (mon-&gt;has_ench(ENCH_FLAYED))</a>
<a name="ln5072">        {</a>
<a name="ln5073">            was_flayed = true;</a>
<a name="ln5074">            mon_enchant flayed = mon-&gt;get_ench(ENCH_FLAYED);</a>
<a name="ln5075">            flayed.duration = min(flayed.duration + added_dur, 150);</a>
<a name="ln5076">            mon-&gt;update_ench(flayed);</a>
<a name="ln5077">        }</a>
<a name="ln5078">        else</a>
<a name="ln5079">        {</a>
<a name="ln5080">            mon_enchant flayed(ENCH_FLAYED, 1, &amp;caster, added_dur);</a>
<a name="ln5081">            mon-&gt;add_ench(flayed);</a>
<a name="ln5082">        }</a>
<a name="ln5083">    }</a>
<a name="ln5084"> </a>
<a name="ln5085">    if (you.can_see(defender))</a>
<a name="ln5086">    {</a>
<a name="ln5087">        if (was_flayed)</a>
<a name="ln5088">        {</a>
<a name="ln5089">            mprf(&quot;Terrible wounds spread across more of %s body!&quot;,</a>
<a name="ln5090">                 defender.name(DESC_ITS).c_str());</a>
<a name="ln5091">        }</a>
<a name="ln5092">        else</a>
<a name="ln5093">        {</a>
<a name="ln5094">            mprf(&quot;Terrible wounds open up all over %s body!&quot;,</a>
<a name="ln5095">                 defender.name(DESC_ITS).c_str());</a>
<a name="ln5096">        }</a>
<a name="ln5097">    }</a>
<a name="ln5098"> </a>
<a name="ln5099">    // Due to Deep Dwarf damage shaving, the player may take less than the intended</a>
<a name="ln5100">    // amount of damage. Keep track of the actual amount of damage done by comparing</a>
<a name="ln5101">    // hp before and after the player is hurt; use this as the actual value for</a>
<a name="ln5102">    // flay damage to prevent the player from regaining extra hp when it wears off</a>
<a name="ln5103"> </a>
<a name="ln5104">    const int orig_hp = defender.stat_hp();</a>
<a name="ln5105"> </a>
<a name="ln5106">    defender.hurt(&amp;caster, damage, BEAM_NONE,</a>
<a name="ln5107">                  KILLED_BY_MONSTER, &quot;&quot;, &quot;flay_damage&quot;, true);</a>
<a name="ln5108">    defender.props[&quot;flay_damage&quot;].get_int() += orig_hp - defender.stat_hp();</a>
<a name="ln5109"> </a>
<a name="ln5110">    vector&lt;coord_def&gt; old_blood;</a>
<a name="ln5111">    CrawlVector &amp;new_blood = defender.props[&quot;flay_blood&quot;].get_vector();</a>
<a name="ln5112"> </a>
<a name="ln5113">    // Find current blood spatters</a>
<a name="ln5114">    for (radius_iterator ri(defender.pos(), LOS_SOLID); ri; ++ri)</a>
<a name="ln5115">    {</a>
<a name="ln5116">        if (env.pgrid(*ri) &amp; FPROP_BLOODY)</a>
<a name="ln5117">            old_blood.push_back(*ri);</a>
<a name="ln5118">    }</a>
<a name="ln5119"> </a>
<a name="ln5120">    blood_spray(defender.pos(), defender.type, 20);</a>
<a name="ln5121"> </a>
<a name="ln5122">    // Compute and store new blood spatters</a>
<a name="ln5123">    unsigned int i = 0;</a>
<a name="ln5124">    for (radius_iterator ri(defender.pos(), LOS_SOLID); ri; ++ri)</a>
<a name="ln5125">    {</a>
<a name="ln5126">        if (env.pgrid(*ri) &amp; FPROP_BLOODY)</a>
<a name="ln5127">        {</a>
<a name="ln5128">            if (i &lt; old_blood.size() &amp;&amp; old_blood[i] == *ri)</a>
<a name="ln5129">                ++i;</a>
<a name="ln5130">            else</a>
<a name="ln5131">                new_blood.push_back(*ri);</a>
<a name="ln5132">        }</a>
<a name="ln5133">    }</a>
<a name="ln5134">}</a>
<a name="ln5135"> </a>
<a name="ln5136">/// What nonliving creatures are adjacent to the given location?</a>
<a name="ln5137">static vector&lt;const actor*&gt; _find_nearby_constructs(const monster &amp;caster,</a>
<a name="ln5138">                                                    coord_def pos)</a>
<a name="ln5139">{</a>
<a name="ln5140">    vector&lt;const actor*&gt; nearby_constructs;</a>
<a name="ln5141">    for (adjacent_iterator ai(pos); ai; ++ai)</a>
<a name="ln5142">    {</a>
<a name="ln5143">        const actor* act = actor_at(*ai);</a>
<a name="ln5144">        if (act &amp;&amp; act-&gt;holiness() &amp; MH_NONLIVING &amp;&amp; mons_aligned(&amp;caster, act))</a>
<a name="ln5145">            nearby_constructs.push_back(act);</a>
<a name="ln5146">    }</a>
<a name="ln5147">    return nearby_constructs;</a>
<a name="ln5148">}</a>
<a name="ln5149"> </a>
<a name="ln5150">/// How many nonliving creatures are adjacent to the given location?</a>
<a name="ln5151">static int _count_nearby_constructs(const monster &amp;caster, coord_def pos)</a>
<a name="ln5152">{</a>
<a name="ln5153">    return _find_nearby_constructs(caster, pos).size();</a>
<a name="ln5154">}</a>
<a name="ln5155"> </a>
<a name="ln5156">/// What's a good description of nonliving creatures adjacent to the given point?</a>
<a name="ln5157">static string _describe_nearby_constructs(const monster &amp;caster, coord_def pos)</a>
<a name="ln5158">{</a>
<a name="ln5159">    const vector&lt;const actor*&gt; nearby_constructs</a>
<a name="ln5160">        = _find_nearby_constructs(caster, pos);</a>
<a name="ln5161">    if (!nearby_constructs.size())</a>
<a name="ln5162">        return &quot;&quot;;</a>
<a name="ln5163"> </a>
<a name="ln5164">    const string name = nearby_constructs.back()-&gt;name(DESC_THE);</a>
<a name="ln5165">    if (nearby_constructs.size() == 1)</a>
<a name="ln5166">        return make_stringf(&quot; and %s&quot;, name.c_str());</a>
<a name="ln5167"> </a>
<a name="ln5168">    for (auto act : nearby_constructs)</a>
<a name="ln5169">        if (act-&gt;name(DESC_THE) != name)</a>
<a name="ln5170">            return &quot; and the adjacent constructs&quot;;</a>
<a name="ln5171">    return make_stringf(&quot; and %s&quot;, pluralise_monster(name).c_str());</a>
<a name="ln5172">}</a>
<a name="ln5173"> </a>
<a name="ln5174">/// Cast Resonance Strike, blasting the caster's target with smitey damage.</a>
<a name="ln5175">static void _cast_resonance_strike(monster &amp;caster, mon_spell_slot, bolt&amp;)</a>
<a name="ln5176">{</a>
<a name="ln5177">    actor* target = caster.get_foe();</a>
<a name="ln5178">    if (!target)</a>
<a name="ln5179">        return;</a>
<a name="ln5180"> </a>
<a name="ln5181">    const int constructs = _count_nearby_constructs(caster, target-&gt;pos());</a>
<a name="ln5182">    // base damage 3d(spell hd) (probably 3d12)</a>
<a name="ln5183">    // + 1 die for every 2 adjacent constructs (so at 4 constructs, 5dhd)</a>
<a name="ln5184">    dice_def dice = resonance_strike_base_damage(caster);</a>
<a name="ln5185">    dice.num += div_rand_round(constructs, 2);</a>
<a name="ln5186">    const int dam = target-&gt;apply_ac(dice.roll());</a>
<a name="ln5187">    const string constructs_desc</a>
<a name="ln5188">        = _describe_nearby_constructs(caster, target-&gt;pos());</a>
<a name="ln5189"> </a>
<a name="ln5190">    if (you.see_cell(target-&gt;pos()))</a>
<a name="ln5191">    {</a>
<a name="ln5192">        mprf(&quot;A blast of power from the earth%s strikes %s!&quot;,</a>
<a name="ln5193">             constructs_desc.c_str(),</a>
<a name="ln5194">             target-&gt;name(DESC_THE).c_str());</a>
<a name="ln5195">    }</a>
<a name="ln5196">    target-&gt;hurt(&amp;caster, dam, BEAM_MISSILE, KILLED_BY_BEAM,</a>
<a name="ln5197">                 &quot;&quot;, &quot;by a resonance strike&quot;);</a>
<a name="ln5198">}</a>
<a name="ln5199"> </a>
<a name="ln5200">static bool _spell_charged(monster *mons)</a>
<a name="ln5201">{</a>
<a name="ln5202">    mon_enchant ench = mons-&gt;get_ench(ENCH_SPELL_CHARGED);</a>
<a name="ln5203">    if (ench.ench == ENCH_NONE || ench.degree &lt; max_mons_charge(mons-&gt;type))</a>
<a name="ln5204">    {</a>
<a name="ln5205">        if (ench.ench == ENCH_NONE)</a>
<a name="ln5206">        {</a>
<a name="ln5207">            mons-&gt;add_ench(mon_enchant(ENCH_SPELL_CHARGED, 1, mons,</a>
<a name="ln5208">                                       INFINITE_DURATION));</a>
<a name="ln5209">        }</a>
<a name="ln5210">        else</a>
<a name="ln5211">        {</a>
<a name="ln5212">            ench.degree++;</a>
<a name="ln5213">            mons-&gt;update_ench(ench);</a>
<a name="ln5214">        }</a>
<a name="ln5215"> </a>
<a name="ln5216">        if (!you.can_see(*mons))</a>
<a name="ln5217">            return false;</a>
<a name="ln5218">        string msg =</a>
<a name="ln5219">            getSpeakString(make_stringf(&quot;%s charge&quot;,</a>
<a name="ln5220">                                        mons-&gt;name(DESC_PLAIN, true).c_str())</a>
<a name="ln5221">                           .c_str());</a>
<a name="ln5222">        if (!msg.empty())</a>
<a name="ln5223">        {</a>
<a name="ln5224">            msg = do_mon_str_replacements(msg, *mons);</a>
<a name="ln5225">            mprf(mons-&gt;wont_attack() ? MSGCH_FRIEND_ENCHANT</a>
<a name="ln5226">                 : MSGCH_MONSTER_ENCHANT, &quot;%s&quot;, msg.c_str());</a>
<a name="ln5227">        }</a>
<a name="ln5228">        return false;</a>
<a name="ln5229">    }</a>
<a name="ln5230">    mons-&gt;del_ench(ENCH_SPELL_CHARGED);</a>
<a name="ln5231">    return true;</a>
<a name="ln5232">}</a>
<a name="ln5233"> </a>
<a name="ln5234">/// How much damage does the given monster do when casting Waterstrike?</a>
<a name="ln5235">dice_def waterstrike_damage(const monster &amp;mons)</a>
<a name="ln5236">{</a>
<a name="ln5237">    return dice_def(3, 7 + mons.spell_hd(SPELL_WATERSTRIKE));</a>
<a name="ln5238">}</a>
<a name="ln5239"> </a>
<a name="ln5240">/**</a>
<a name="ln5241"> * How much damage does the given monster do when casting Resonance Strike,</a>
<a name="ln5242"> * assuming no allied constructs are boosting damage?</a>
<a name="ln5243"> */</a>
<a name="ln5244">dice_def resonance_strike_base_damage(const monster &amp;mons)</a>
<a name="ln5245">{</a>
<a name="ln5246">    return dice_def(3, mons.spell_hd(SPELL_RESONANCE_STRIKE));</a>
<a name="ln5247">}</a>
<a name="ln5248"> </a>
<a name="ln5249">static const int MIN_DREAM_SUCCESS_POWER = 25;</a>
<a name="ln5250"> </a>
<a name="ln5251">static void _sheep_message(int num_sheep, int sleep_pow, actor&amp; foe)</a>
<a name="ln5252">{</a>
<a name="ln5253">    string message;</a>
<a name="ln5254"> </a>
<a name="ln5255">    // Determine messaging based on sleep strength.</a>
<a name="ln5256">    if (sleep_pow &gt;= 125)</a>
<a name="ln5257">        message = &quot;You are overwhelmed by glittering dream dust!&quot;;</a>
<a name="ln5258">    else if (sleep_pow &gt;= 75)</a>
<a name="ln5259">        message = &quot;The dream sheep are wreathed in dream dust.&quot;;</a>
<a name="ln5260">    else if (sleep_pow &gt;= MIN_DREAM_SUCCESS_POWER)</a>
<a name="ln5261">    {</a>
<a name="ln5262">        message = make_stringf(&quot;The dream sheep shake%s wool and sparkle%s.&quot;,</a>
<a name="ln5263">                               num_sheep == 1 ? &quot;s its&quot; : &quot; their&quot;,</a>
<a name="ln5264">                               num_sheep == 1 ? &quot;s&quot;: &quot;&quot;);</a>
<a name="ln5265">    }</a>
<a name="ln5266">    else // if sleep fails</a>
<a name="ln5267">    {</a>
<a name="ln5268">        message = make_stringf(&quot;The dream sheep ruffle%s wool and motes of &quot;</a>
<a name="ln5269">                               &quot;dream dust sparkle, to no effect.&quot;,</a>
<a name="ln5270">                               num_sheep == 1 ? &quot;s its&quot; : &quot; their&quot;);</a>
<a name="ln5271">    }</a>
<a name="ln5272"> </a>
<a name="ln5273">    // Messaging for non-player targets</a>
<a name="ln5274">    if (!foe.is_player() &amp;&amp; you.see_cell(foe.pos()))</a>
<a name="ln5275">    {</a>
<a name="ln5276">        const char* pluralize = num_sheep == 1 ? &quot;s&quot;: &quot;&quot;;</a>
<a name="ln5277">        const string foe_name = foe.name(DESC_THE);</a>
<a name="ln5278">        if (sleep_pow)</a>
<a name="ln5279">        {</a>
<a name="ln5280">            mprf(foe.as_monster()-&gt;friendly() ? MSGCH_FRIEND_SPELL</a>
<a name="ln5281">                                              : MSGCH_MONSTER_SPELL,</a>
<a name="ln5282">                 &quot;As the sheep sparkle%s and sway%s, %s falls asleep.&quot;,</a>
<a name="ln5283">                 pluralize,</a>
<a name="ln5284">                 pluralize,</a>
<a name="ln5285">                 foe_name.c_str());</a>
<a name="ln5286">        }</a>
<a name="ln5287">        else // if dust strength failure for non-player</a>
<a name="ln5288">        {</a>
<a name="ln5289">            mprf(foe.as_monster()-&gt;friendly() ? MSGCH_FRIEND_SPELL</a>
<a name="ln5290">                                              : MSGCH_MONSTER_SPELL,</a>
<a name="ln5291">                 &quot;The dream sheep attempt%s to lull %s to sleep.&quot;,</a>
<a name="ln5292">                 pluralize,</a>
<a name="ln5293">                 foe_name.c_str());</a>
<a name="ln5294">            mprf(&quot;%s is unaffected.&quot;, foe_name.c_str());</a>
<a name="ln5295">        }</a>
<a name="ln5296">    }</a>
<a name="ln5297">    else if (foe.is_player())</a>
<a name="ln5298">    {</a>
<a name="ln5299">        mprf(MSGCH_MONSTER_SPELL, &quot;%s%s&quot;, message.c_str(),</a>
<a name="ln5300">             sleep_pow ? &quot; You feel drowsy...&quot; : &quot;&quot;);</a>
<a name="ln5301">    }</a>
<a name="ln5302">}</a>
<a name="ln5303"> </a>
<a name="ln5304">static void _dream_sheep_sleep(monster&amp; mons, actor&amp; foe)</a>
<a name="ln5305">{</a>
<a name="ln5306">    // Shepherd the dream sheep.</a>
<a name="ln5307">    int num_sheep = 0;</a>
<a name="ln5308">    for (monster_near_iterator mi(foe.pos(), LOS_NO_TRANS); mi; ++mi)</a>
<a name="ln5309">        if (mi-&gt;type == MONS_DREAM_SHEEP)</a>
<a name="ln5310">            num_sheep++;</a>
<a name="ln5311"> </a>
<a name="ln5312">    // The correlation between amount of sheep and duration of</a>
<a name="ln5313">    // sleep is randomised, but bounds are 5 to 20 turns of sleep.</a>
<a name="ln5314">    // More dream sheep are both more likely to succeed and to have a</a>
<a name="ln5315">    // stronger effect. Too-weak attempts get blanked.</a>
<a name="ln5316">    // Special note: a single sheep has a 1 in 25 chance to succeed.</a>
<a name="ln5317">    int sleep_pow = min(150, random2(num_sheep * 25) + 1);</a>
<a name="ln5318">    if (sleep_pow &lt; MIN_DREAM_SUCCESS_POWER)</a>
<a name="ln5319">        sleep_pow = 0;</a>
<a name="ln5320"> </a>
<a name="ln5321">    // Communicate with the player.</a>
<a name="ln5322">    _sheep_message(num_sheep, sleep_pow, foe);</a>
<a name="ln5323"> </a>
<a name="ln5324">    // Put the player to sleep.</a>
<a name="ln5325">    if (sleep_pow)</a>
<a name="ln5326">        foe.put_to_sleep(&amp;mons, sleep_pow, false);</a>
<a name="ln5327">}</a>
<a name="ln5328"> </a>
<a name="ln5329">// Draconian stormcaller upheaval. Simplified compared to the player version.</a>
<a name="ln5330">// Noisy! Causes terrain changes. Destroys doors/walls.</a>
<a name="ln5331">// TODO: Could use further simplification.</a>
<a name="ln5332">static void _mons_upheaval(monster&amp; mons, actor&amp; /*foe*/)</a>
<a name="ln5333">{</a>
<a name="ln5334">    bolt beam;</a>
<a name="ln5335">    beam.source_id   = mons.mid;</a>
<a name="ln5336">    beam.source_name = mons.name(DESC_THE).c_str();</a>
<a name="ln5337">    beam.thrower     = KILL_MON_MISSILE;</a>
<a name="ln5338">    beam.range       = LOS_RADIUS;</a>
<a name="ln5339">    beam.damage      = dice_def(3, 24);</a>
<a name="ln5340">    beam.foe_ratio   = random_range(20, 30);</a>
<a name="ln5341">    beam.hit         = AUTOMATIC_HIT;</a>
<a name="ln5342">    beam.glyph       = dchar_glyph(DCHAR_EXPLOSION);</a>
<a name="ln5343">    beam.loudness    = 10;</a>
<a name="ln5344">#ifdef USE_TILE</a>
<a name="ln5345">    beam.tile_beam   = -1;</a>
<a name="ln5346">#endif</a>
<a name="ln5347">    beam.draw_delay  = 0;</a>
<a name="ln5348">    beam.target = mons.target;</a>
<a name="ln5349">    string message = &quot;&quot;;</a>
<a name="ln5350"> </a>
<a name="ln5351">    switch (random2(4))</a>
<a name="ln5352">    {</a>
<a name="ln5353">        case 0:</a>
<a name="ln5354">            beam.name     = &quot;blast of magma&quot;;</a>
<a name="ln5355">            beam.flavour  = BEAM_LAVA;</a>
<a name="ln5356">            beam.colour   = RED;</a>
<a name="ln5357">            beam.hit_verb = &quot;engulfs&quot;;</a>
<a name="ln5358">            message       = &quot;Magma suddenly erupts from the ground!&quot;;</a>
<a name="ln5359">            break;</a>
<a name="ln5360">        case 1:</a>
<a name="ln5361">            beam.name    = &quot;blast of ice&quot;;</a>
<a name="ln5362">            beam.flavour = BEAM_ICE;</a>
<a name="ln5363">            beam.colour  = WHITE;</a>
<a name="ln5364">            message      = &quot;A blizzard blasts the area with ice!&quot;;</a>
<a name="ln5365">            break;</a>
<a name="ln5366">        case 2:</a>
<a name="ln5367">            beam.name    = &quot;cutting wind&quot;;</a>
<a name="ln5368">            beam.flavour = BEAM_AIR;</a>
<a name="ln5369">            beam.colour  = LIGHTGRAY;</a>
<a name="ln5370">            message      = &quot;A storm cloud blasts the area with cutting wind!&quot;;</a>
<a name="ln5371">            break;</a>
<a name="ln5372">        case 3:</a>
<a name="ln5373">            beam.name    = &quot;blast of rubble&quot;;</a>
<a name="ln5374">            beam.flavour = BEAM_FRAG;</a>
<a name="ln5375">            beam.colour  = BROWN;</a>
<a name="ln5376">            message      = &quot;The ground shakes violently, spewing rubble!&quot;;</a>
<a name="ln5377">            break;</a>
<a name="ln5378">        default:</a>
<a name="ln5379">            break;</a>
<a name="ln5380">    }</a>
<a name="ln5381"> </a>
<a name="ln5382">    vector&lt;coord_def&gt; affected;</a>
<a name="ln5383">    affected.push_back(beam.target);</a>
<a name="ln5384"> </a>
<a name="ln5385">    const int radius = 2;</a>
<a name="ln5386">    for (radius_iterator ri(beam.target, radius, C_SQUARE, LOS_SOLID, true);</a>
<a name="ln5387">         ri; ++ri)</a>
<a name="ln5388">    {</a>
<a name="ln5389">        if (!in_bounds(*ri) || cell_is_solid(*ri))</a>
<a name="ln5390">            continue;</a>
<a name="ln5391"> </a>
<a name="ln5392">        bool splash = true;</a>
<a name="ln5393">        bool adj = adjacent(beam.target, *ri);</a>
<a name="ln5394">        if (!adj)</a>
<a name="ln5395">            splash = false;</a>
<a name="ln5396">        if (adj || splash)</a>
<a name="ln5397">        {</a>
<a name="ln5398">            if (beam.flavour == BEAM_FRAG || !cell_is_solid(*ri))</a>
<a name="ln5399">                affected.push_back(*ri);</a>
<a name="ln5400">        }</a>
<a name="ln5401">    }</a>
<a name="ln5402"> </a>
<a name="ln5403">    for (coord_def pos : affected)</a>
<a name="ln5404">    {</a>
<a name="ln5405">        beam.draw(pos);</a>
<a name="ln5406">        scaled_delay(25);</a>
<a name="ln5407">    }</a>
<a name="ln5408"> </a>
<a name="ln5409">    for (coord_def pos : affected)</a>
<a name="ln5410">    {</a>
<a name="ln5411">        beam.source = pos;</a>
<a name="ln5412">        beam.target = pos;</a>
<a name="ln5413">        beam.fire();</a>
<a name="ln5414"> </a>
<a name="ln5415">        switch (beam.flavour)</a>
<a name="ln5416">        {</a>
<a name="ln5417">            case BEAM_LAVA:</a>
<a name="ln5418">                if (grd(pos) == DNGN_FLOOR &amp;&amp; !actor_at(pos) &amp;&amp; coinflip())</a>
<a name="ln5419">                {</a>
<a name="ln5420">                    temp_change_terrain(</a>
<a name="ln5421">                        pos, DNGN_LAVA,</a>
<a name="ln5422">                        random2(14) * BASELINE_DELAY,</a>
<a name="ln5423">                        TERRAIN_CHANGE_FLOOD);</a>
<a name="ln5424">                }</a>
<a name="ln5425">                break;</a>
<a name="ln5426">            case BEAM_AIR:</a>
<a name="ln5427">                if (!cell_is_solid(pos) &amp;&amp; !cloud_at(pos) &amp;&amp; coinflip())</a>
<a name="ln5428">                    place_cloud(CLOUD_STORM, pos, random2(7), &amp;mons);</a>
<a name="ln5429">                break;</a>
<a name="ln5430">            case BEAM_FRAG:</a>
<a name="ln5431">                if (((grd(pos) == DNGN_ROCK_WALL</a>
<a name="ln5432">                     || grd(pos) == DNGN_CLEAR_ROCK_WALL</a>
<a name="ln5433">                     || grd(pos) == DNGN_SLIMY_WALL)</a>
<a name="ln5434">                     &amp;&amp; x_chance_in_y(1, 4)</a>
<a name="ln5435">                     || feat_is_door(grd(pos))</a>
<a name="ln5436">                     || grd(pos) == DNGN_GRATE))</a>
<a name="ln5437">                {</a>
<a name="ln5438">                    noisy(30, pos);</a>
<a name="ln5439">                    destroy_wall(pos);</a>
<a name="ln5440">                }</a>
<a name="ln5441">                break;</a>
<a name="ln5442">            default:</a>
<a name="ln5443">                break;</a>
<a name="ln5444">        }</a>
<a name="ln5445">    }</a>
<a name="ln5446">}</a>
<a name="ln5447"> </a>
<a name="ln5448">static void _mons_tornado(monster *mons, bool is_vortex = false)</a>
<a name="ln5449">{</a>
<a name="ln5450">    const int dur = is_vortex ? 30 : 60;</a>
<a name="ln5451">    const string desc = is_vortex ? &quot;vortex&quot; : &quot;great vortex&quot;;</a>
<a name="ln5452">    const string prop = is_vortex ? &quot;vortex_since&quot; : &quot;tornado_since&quot;;</a>
<a name="ln5453">    const enchant_type ench = is_vortex ? ENCH_VORTEX : ENCH_TORNADO;</a>
<a name="ln5454"> </a>
<a name="ln5455">    if (you.can_see(*mons))</a>
<a name="ln5456">    {</a>
<a name="ln5457">        bool flying = mons-&gt;airborne();</a>
<a name="ln5458">        mprf(&quot;A %s of raging winds appears %s%s%s!&quot;,</a>
<a name="ln5459">             desc.c_str(),</a>
<a name="ln5460">             flying ? &quot;around &quot; : &quot;and lifts &quot;,</a>
<a name="ln5461">             mons-&gt;name(DESC_THE).c_str(),</a>
<a name="ln5462">             flying ? &quot;&quot; : &quot; up!&quot;);</a>
<a name="ln5463">    }</a>
<a name="ln5464">    else if (you.see_cell(mons-&gt;pos()))</a>
<a name="ln5465">        mprf(&quot;A %s of raging winds appears out of thin air!&quot;, desc.c_str());</a>
<a name="ln5466"> </a>
<a name="ln5467">    mons-&gt;props[prop.c_str()].get_int() = you.elapsed_time;</a>
<a name="ln5468">    mon_enchant me(ench, 0, mons, dur);</a>
<a name="ln5469">    mons-&gt;add_ench(me);</a>
<a name="ln5470"> </a>
<a name="ln5471">    if (mons-&gt;has_ench(ENCH_FLIGHT))</a>
<a name="ln5472">    {</a>
<a name="ln5473">        mon_enchant me2 = mons-&gt;get_ench(ENCH_FLIGHT);</a>
<a name="ln5474">        me2.duration = me.duration;</a>
<a name="ln5475">        mons-&gt;update_ench(me2);</a>
<a name="ln5476">    }</a>
<a name="ln5477">    else</a>
<a name="ln5478">        mons-&gt;add_ench(mon_enchant(ENCH_FLIGHT, 0, mons, dur));</a>
<a name="ln5479">}</a>
<a name="ln5480"> </a>
<a name="ln5481">/**</a>
<a name="ln5482"> *  Make this monster cast a spell</a>
<a name="ln5483"> *</a>
<a name="ln5484"> *  @param mons       The monster casting</a>
<a name="ln5485"> *  @param pbolt      The beam, possibly containing pre-done setup, to use</a>
<a name="ln5486"> *                    for the spell. Not a reference because this function</a>
<a name="ln5487">                      shouldn't affect the original copy.</a>
<a name="ln5488"> *  @param spell_cast The spell to be cast.</a>
<a name="ln5489"> *  @param slot_flags The spell slot flags in mons-&gt;spells (is it an</a>
<a name="ln5490"> *                    invocation, natural, shouty, etc.?)</a>
<a name="ln5491"> *  @param do_noise   Whether to make noise (including casting messages).</a>
<a name="ln5492"> */</a>
<a name="ln5493">void mons_cast(monster* mons, bolt pbolt, spell_type spell_cast,</a>
<a name="ln5494">               mon_spell_slot_flags slot_flags, bool do_noise)</a>
<a name="ln5495">{</a>
<a name="ln5496">    // check sputtercast state for e.g. orb spiders. assumption: all</a>
<a name="ln5497">    // sputtercasting monsters have one charge status and use it for all of</a>
<a name="ln5498">    // their spells.</a>
<a name="ln5499">    if (max_mons_charge(mons-&gt;type) &gt; 0 &amp;&amp; !_spell_charged(mons))</a>
<a name="ln5500">        return;</a>
<a name="ln5501"> </a>
<a name="ln5502">    if (spell_is_soh_breath(spell_cast))</a>
<a name="ln5503">    {</a>
<a name="ln5504">        const vector&lt;spell_type&gt; *breaths = soh_breath_spells(spell_cast);</a>
<a name="ln5505">        ASSERT(breaths);</a>
<a name="ln5506">        ASSERT(mons-&gt;heads() == (int)breaths-&gt;size());</a>
<a name="ln5507"> </a>
<a name="ln5508">        for (spell_type head_spell : *breaths)</a>
<a name="ln5509">        {</a>
<a name="ln5510">            if (!mons-&gt;get_foe())</a>
<a name="ln5511">                return;</a>
<a name="ln5512">            setup_mons_cast(mons, pbolt, head_spell);</a>
<a name="ln5513">            mons_cast(mons, pbolt, head_spell, slot_flags, do_noise);</a>
<a name="ln5514">        }</a>
<a name="ln5515"> </a>
<a name="ln5516">        return;</a>
<a name="ln5517">    }</a>
<a name="ln5518"> </a>
<a name="ln5519">    if (spell_cast == SPELL_LEGENDARY_DESTRUCTION)</a>
<a name="ln5520">    {</a>
<a name="ln5521">        if (do_noise)</a>
<a name="ln5522">        {</a>
<a name="ln5523">            mons_cast_noise(mons, pbolt, SPELL_LEGENDARY_DESTRUCTION,</a>
<a name="ln5524">                            slot_flags);</a>
<a name="ln5525">        }</a>
<a name="ln5526"> </a>
<a name="ln5527">        setup_mons_cast(mons, pbolt, SPELL_LEGENDARY_DESTRUCTION);</a>
<a name="ln5528">        mons_cast(mons, pbolt, _legendary_destruction_spell(), slot_flags,</a>
<a name="ln5529">                  false);</a>
<a name="ln5530">        if (!mons-&gt;get_foe())</a>
<a name="ln5531">            return;</a>
<a name="ln5532">        setup_mons_cast(mons, pbolt, SPELL_LEGENDARY_DESTRUCTION);</a>
<a name="ln5533">        mons_cast(mons, pbolt, _legendary_destruction_spell(), slot_flags,</a>
<a name="ln5534">                  false);</a>
<a name="ln5535">        return;</a>
<a name="ln5536">    }</a>
<a name="ln5537"> </a>
<a name="ln5538">    // Maybe cast abjuration instead of certain summoning spells.</a>
<a name="ln5539">    if (mons-&gt;can_see(you) &amp;&amp;</a>
<a name="ln5540">        get_spell_flags(spell_cast) &amp; spflag::mons_abjure &amp;&amp; one_chance_in(3)</a>
<a name="ln5541">        &amp;&amp; _mons_will_abjure(*mons))</a>
<a name="ln5542">    {</a>
<a name="ln5543">        mons_cast(mons, pbolt, SPELL_ABJURATION, slot_flags, do_noise);</a>
<a name="ln5544">        return;</a>
<a name="ln5545">    }</a>
<a name="ln5546"> </a>
<a name="ln5547">    bool evoke {slot_flags &amp; MON_SPELL_EVOKE};</a>
<a name="ln5548">    // Always do setup. It might be done already, but it doesn't hurt</a>
<a name="ln5549">    // to do it again (cheap).</a>
<a name="ln5550">    setup_mons_cast(mons, pbolt, spell_cast, evoke);</a>
<a name="ln5551"> </a>
<a name="ln5552">    // single calculation permissible {dlb}</a>
<a name="ln5553">    const spell_flags flags = get_spell_flags(spell_cast);</a>
<a name="ln5554">    actor* const foe = mons-&gt;get_foe();</a>
<a name="ln5555">    const mons_spell_logic* logic = map_find(spell_to_logic, spell_cast);</a>
<a name="ln5556">    const mon_spell_slot slot = {spell_cast, 0, slot_flags};</a>
<a name="ln5557"> </a>
<a name="ln5558">    int sumcount = 0;</a>
<a name="ln5559">    int sumcount2;</a>
<a name="ln5560">    int duration = 0;</a>
<a name="ln5561"> </a>
<a name="ln5562">    dprf(&quot;Mon #%d casts %s (#%d)&quot;,</a>
<a name="ln5563">         mons-&gt;mindex(), spell_title(spell_cast), spell_cast);</a>
<a name="ln5564">    ASSERT(!(flags &amp; spflag::testing));</a>
<a name="ln5565">    // Targeted spells need a valid target.</a>
<a name="ln5566">    // Wizard-mode cast monster spells may target the boundary (shift-dir).</a>
<a name="ln5567">    ASSERT(map_bounds(pbolt.target) || !(flags &amp; spflag::targeting_mask));</a>
<a name="ln5568"> </a>
<a name="ln5569">    if (spell_cast == SPELL_PORTAL_PROJECTILE</a>
<a name="ln5570">        || logic &amp;&amp; (logic-&gt;flags &amp; MSPELL_NO_AUTO_NOISE))</a>
<a name="ln5571">    {</a>
<a name="ln5572">        do_noise = false;       // Spell itself does the messaging.</a>
<a name="ln5573">    }</a>
<a name="ln5574"> </a>
<a name="ln5575">    if (do_noise)</a>
<a name="ln5576">        mons_cast_noise(mons, pbolt, spell_cast, slot_flags);</a>
<a name="ln5577"> </a>
<a name="ln5578">    if (logic &amp;&amp; logic-&gt;cast)</a>
<a name="ln5579">    {</a>
<a name="ln5580">        logic-&gt;cast(*mons, slot, pbolt);</a>
<a name="ln5581">        return;</a>
<a name="ln5582">    }</a>
<a name="ln5583"> </a>
<a name="ln5584">    const god_type god = _find_god(*mons, slot_flags);</a>
<a name="ln5585">    const int splpow = evoke ? 30 + mons-&gt;get_hit_dice()</a>
<a name="ln5586">                             : mons_spellpower(*mons, spell_cast);</a>
<a name="ln5587"> </a>
<a name="ln5588">    switch (spell_cast)</a>
<a name="ln5589">    {</a>
<a name="ln5590">    default:</a>
<a name="ln5591">        break;</a>
<a name="ln5592"> </a>
<a name="ln5593">    case SPELL_WATERSTRIKE:</a>
<a name="ln5594">    {</a>
<a name="ln5595">        pbolt.flavour    = BEAM_WATER;</a>
<a name="ln5596"> </a>
<a name="ln5597">        int damage_taken = waterstrike_damage(*mons).roll();</a>
<a name="ln5598">        damage_taken = foe-&gt;beam_resists(pbolt, damage_taken, false);</a>
<a name="ln5599">        damage_taken = foe-&gt;apply_ac(damage_taken);</a>
<a name="ln5600"> </a>
<a name="ln5601">        if (you.can_see(*foe))</a>
<a name="ln5602">        {</a>
<a name="ln5603">                mprf(&quot;The water %s and strikes %s%s&quot;,</a>
<a name="ln5604">                        foe-&gt;airborne() ? &quot;rises up&quot; : &quot;swirls&quot;,</a>
<a name="ln5605">                        foe-&gt;name(DESC_THE).c_str(),</a>
<a name="ln5606">                        attack_strength_punctuation(damage_taken).c_str());</a>
<a name="ln5607">        }</a>
<a name="ln5608"> </a>
<a name="ln5609">        foe-&gt;hurt(mons, damage_taken, BEAM_MISSILE, KILLED_BY_BEAM,</a>
<a name="ln5610">                      &quot;&quot;, &quot;by the raging water&quot;);</a>
<a name="ln5611">        return;</a>
<a name="ln5612">    }</a>
<a name="ln5613"> </a>
<a name="ln5614">    case SPELL_AIRSTRIKE:</a>
<a name="ln5615">    {</a>
<a name="ln5616">        pbolt.flavour = BEAM_AIR;</a>
<a name="ln5617"> </a>
<a name="ln5618">        int empty_space = 0;</a>
<a name="ln5619">        for (adjacent_iterator ai(foe-&gt;pos()); ai; ++ai)</a>
<a name="ln5620">            if (!monster_at(*ai) &amp;&amp; !cell_is_solid(*ai))</a>
<a name="ln5621">                empty_space++;</a>
<a name="ln5622"> </a>
<a name="ln5623">        empty_space = max(3, empty_space);</a>
<a name="ln5624"> </a>
<a name="ln5625">        int damage_taken = 5 + empty_space</a>
<a name="ln5626">                         + random2avg(2 + div_rand_round(splpow, 7),</a>
<a name="ln5627">                                      empty_space);</a>
<a name="ln5628">        damage_taken = foe-&gt;beam_resists(pbolt, damage_taken, false);</a>
<a name="ln5629"> </a>
<a name="ln5630">        damage_taken = foe-&gt;apply_ac(damage_taken);</a>
<a name="ln5631"> </a>
<a name="ln5632">        if (you.can_see(*foe))</a>
<a name="ln5633">        {</a>
<a name="ln5634">                mprf(&quot;The air twists around and %sstrikes %s%s%s&quot;,</a>
<a name="ln5635">                        foe-&gt;airborne() ? &quot;violently &quot; : &quot;&quot;,</a>
<a name="ln5636">                        foe-&gt;name(DESC_THE).c_str(),</a>
<a name="ln5637">                        foe-&gt;airborne() ? &quot; in flight&quot; : &quot;&quot;,</a>
<a name="ln5638">                        attack_strength_punctuation(damage_taken).c_str());</a>
<a name="ln5639">        }</a>
<a name="ln5640"> </a>
<a name="ln5641">        foe-&gt;hurt(mons, damage_taken, BEAM_MISSILE, KILLED_BY_BEAM,</a>
<a name="ln5642">                  &quot;&quot;, &quot;by the air&quot;);</a>
<a name="ln5643">        return;</a>
<a name="ln5644">    }</a>
<a name="ln5645"> </a>
<a name="ln5646">    case SPELL_HOLY_FLAMES:</a>
<a name="ln5647">        holy_flames(mons, foe);</a>
<a name="ln5648">        return;</a>
<a name="ln5649">    case SPELL_BRAIN_FEED:</a>
<a name="ln5650">        if (one_chance_in(3)</a>
<a name="ln5651">            &amp;&amp; lose_stat(STAT_INT, 1 + random2(3)))</a>
<a name="ln5652">        {</a>
<a name="ln5653">            mpr(&quot;Something feeds on your intellect!&quot;);</a>
<a name="ln5654">            xom_is_stimulated(50);</a>
<a name="ln5655">        }</a>
<a name="ln5656">        else</a>
<a name="ln5657">            mpr(&quot;Something tries to feed on your intellect!&quot;);</a>
<a name="ln5658">        return;</a>
<a name="ln5659"> </a>
<a name="ln5660">    case SPELL_SUMMON_SPECTRAL_ORCS:</a>
<a name="ln5661">        if (foe-&gt;is_player())</a>
<a name="ln5662">            mpr(&quot;Orcish apparitions take form around you.&quot;);</a>
<a name="ln5663">        else</a>
<a name="ln5664">            simple_monster_message(*foe-&gt;as_monster(), &quot; is surrounded by Orcish apparitions.&quot;);</a>
<a name="ln5665">        _mons_cast_spectral_orcs(mons);</a>
<a name="ln5666">        return;</a>
<a name="ln5667"> </a>
<a name="ln5668">    case SPELL_HAUNT:</a>
<a name="ln5669">        if (foe-&gt;is_player())</a>
<a name="ln5670">            mpr(&quot;You feel haunted.&quot;);</a>
<a name="ln5671">        else</a>
<a name="ln5672">            mpr(&quot;You sense an evil presence.&quot;);</a>
<a name="ln5673">        _mons_cast_haunt(mons);</a>
<a name="ln5674">        return;</a>
<a name="ln5675"> </a>
<a name="ln5676">    // SPELL_SLEEP_GAZE ;)</a>
<a name="ln5677">    case SPELL_DREAM_DUST:</a>
<a name="ln5678">        _dream_sheep_sleep(*mons, *foe);</a>
<a name="ln5679">        return;</a>
<a name="ln5680"> </a>
<a name="ln5681">    case SPELL_CONFUSION_GAZE:</a>
<a name="ln5682">    {</a>
<a name="ln5683">        const int res_margin = foe-&gt;check_res_magic(splpow / ENCH_POW_FACTOR);</a>
<a name="ln5684">        if (res_margin &gt; 0)</a>
<a name="ln5685">        {</a>
<a name="ln5686">            if (you.can_see(*foe))</a>
<a name="ln5687">            {</a>
<a name="ln5688">                mprf(&quot;%s%s&quot;,</a>
<a name="ln5689">                     foe-&gt;name(DESC_THE).c_str(),</a>
<a name="ln5690">                     foe-&gt;resist_margin_phrase(res_margin).c_str());</a>
<a name="ln5691">            }</a>
<a name="ln5692">            return;</a>
<a name="ln5693">        }</a>
<a name="ln5694"> </a>
<a name="ln5695">        foe-&gt;confuse(mons, 5 + random2(3));</a>
<a name="ln5696">        return;</a>
<a name="ln5697">    }</a>
<a name="ln5698"> </a>
<a name="ln5699">    case SPELL_MAJOR_HEALING:</a>
<a name="ln5700">        if (mons-&gt;heal(50 + random2avg(mons-&gt;spell_hd(spell_cast) * 10, 2)))</a>
<a name="ln5701">            simple_monster_message(*mons, &quot; is healed.&quot;);</a>
<a name="ln5702">        return;</a>
<a name="ln5703"> </a>
<a name="ln5704">    case SPELL_BERSERKER_RAGE:</a>
<a name="ln5705">        mons-&gt;props.erase(&quot;brothers_count&quot;);</a>
<a name="ln5706">        mons-&gt;go_berserk(true);</a>
<a name="ln5707">        return;</a>
<a name="ln5708"> </a>
<a name="ln5709">#if TAG_MAJOR_VERSION == 34</a>
<a name="ln5710">    // Replaced with monster-specific version.</a>
<a name="ln5711">    case SPELL_SWIFTNESS:</a>
<a name="ln5712">#endif</a>
<a name="ln5713">    case SPELL_SPRINT:</a>
<a name="ln5714">        mons-&gt;add_ench(ENCH_SWIFT);</a>
<a name="ln5715">        simple_monster_message(*mons, &quot; puts on a burst of speed!&quot;);</a>
<a name="ln5716">        return;</a>
<a name="ln5717"> </a>
<a name="ln5718">    case SPELL_SILENCE:</a>
<a name="ln5719">        mons-&gt;add_ench(ENCH_SILENCE);</a>
<a name="ln5720">        invalidate_agrid(true);</a>
<a name="ln5721">        simple_monster_message(*mons, &quot;'s surroundings become eerily quiet.&quot;);</a>
<a name="ln5722">        return;</a>
<a name="ln5723"> </a>
<a name="ln5724">    case SPELL_CALL_TIDE:</a>
<a name="ln5725">        if (player_in_branch(BRANCH_SHOALS))</a>
<a name="ln5726">        {</a>
<a name="ln5727">            const int tide_duration = BASELINE_DELAY</a>
<a name="ln5728">                * random_range(80, 200, 2);</a>
<a name="ln5729">            mons-&gt;add_ench(mon_enchant(ENCH_TIDE, 0, mons,</a>
<a name="ln5730">                                       tide_duration));</a>
<a name="ln5731">            mons-&gt;props[TIDE_CALL_TURN].get_int() = you.num_turns;</a>
<a name="ln5732">            if (simple_monster_message(*</a>
<a name="ln5733">                    mons,</a>
<a name="ln5734">                    &quot; sings a water chant to call the tide!&quot;))</a>
<a name="ln5735">            {</a>
<a name="ln5736">                flash_view_delay(UA_MONSTER, ETC_WATER, 300);</a>
<a name="ln5737">            }</a>
<a name="ln5738">        }</a>
<a name="ln5739">        return;</a>
<a name="ln5740"> </a>
<a name="ln5741">    case SPELL_INK_CLOUD:</a>
<a name="ln5742">        if (!feat_is_watery(grd(mons-&gt;pos())))</a>
<a name="ln5743">            return;</a>
<a name="ln5744"> </a>
<a name="ln5745">        big_cloud(CLOUD_INK, mons, mons-&gt;pos(), 30, 30);</a>
<a name="ln5746"> </a>
<a name="ln5747">        simple_monster_message(*</a>
<a name="ln5748">            mons,</a>
<a name="ln5749">            &quot; squirts a massive cloud of ink into the water!&quot;);</a>
<a name="ln5750">        return;</a>
<a name="ln5751"> </a>
<a name="ln5752">    case SPELL_SUMMON_SMALL_MAMMAL:</a>
<a name="ln5753">        sumcount2 = 1 + random2(3);</a>
<a name="ln5754"> </a>
<a name="ln5755">        for (sumcount = 0; sumcount &lt; sumcount2; ++sumcount)</a>
<a name="ln5756">        {</a>
<a name="ln5757">            monster_type rats[] = { MONS_QUOKKA, MONS_RIVER_RAT, MONS_RAT };</a>
<a name="ln5758"> </a>
<a name="ln5759">            const monster_type mon = (one_chance_in(3) ? MONS_BAT</a>
<a name="ln5760">                                                       : RANDOM_ELEMENT(rats));</a>
<a name="ln5761">            create_monster(</a>
<a name="ln5762">                mgen_data(mon, SAME_ATTITUDE(mons), mons-&gt;pos(), mons-&gt;foe)</a>
<a name="ln5763">                .set_summoned(mons, 5, spell_cast, god));</a>
<a name="ln5764">        }</a>
<a name="ln5765">        return;</a>
<a name="ln5766"> </a>
<a name="ln5767">    case SPELL_STICKS_TO_SNAKES:</a>
<a name="ln5768">    {</a>
<a name="ln5769">        const int pow = (mons-&gt;spell_hd(spell_cast) * 15) / 10;</a>
<a name="ln5770">        int cnt = 1 + random2(1 + pow / 4);</a>
<a name="ln5771">        monster_type sum;</a>
<a name="ln5772">        for (int i = 0; i &lt; cnt; i++)</a>
<a name="ln5773">        {</a>
<a name="ln5774">            if (random2(mons-&gt;spell_hd(spell_cast)) &gt; 27</a>
<a name="ln5775">                || one_chance_in(5 - min(4, div_rand_round(pow * 2, 25))))</a>
<a name="ln5776">            {</a>
<a name="ln5777">                sum = x_chance_in_y(pow / 3, 100) ? MONS_WATER_MOCCASIN</a>
<a name="ln5778">                                                  : MONS_ADDER;</a>
<a name="ln5779">            }</a>
<a name="ln5780">            else</a>
<a name="ln5781">                sum = MONS_BALL_PYTHON;</a>
<a name="ln5782"> </a>
<a name="ln5783">            if (create_monster(</a>
<a name="ln5784">                    mgen_data(sum, SAME_ATTITUDE(mons), mons-&gt;pos(), mons-&gt;foe)</a>
<a name="ln5785">                    .set_summoned(mons, 5, spell_cast, god)))</a>
<a name="ln5786">            {</a>
<a name="ln5787">                i++;</a>
<a name="ln5788">            }</a>
<a name="ln5789">        }</a>
<a name="ln5790">        return;</a>
<a name="ln5791">    }</a>
<a name="ln5792"> </a>
<a name="ln5793">    case SPELL_SHADOW_CREATURES:       // summon anything appropriate for level</a>
<a name="ln5794">    {</a>
<a name="ln5795">        level_id place = level_id::current();</a>
<a name="ln5796"> </a>
<a name="ln5797">        sumcount2 = 1 + random2(mons-&gt;spell_hd(spell_cast) / 5 + 1);</a>
<a name="ln5798"> </a>
<a name="ln5799">        for (sumcount = 0; sumcount &lt; sumcount2; ++sumcount)</a>
<a name="ln5800">        {</a>
<a name="ln5801">            create_monster(</a>
<a name="ln5802">                mgen_data(RANDOM_MOBILE_MONSTER, SAME_ATTITUDE(mons),</a>
<a name="ln5803">                          mons-&gt;pos(), mons-&gt;foe)</a>
<a name="ln5804">                          .set_summoned(mons, 5, spell_cast, god)</a>
<a name="ln5805">                          .set_place(place));</a>
<a name="ln5806">        }</a>
<a name="ln5807">        return;</a>
<a name="ln5808">    }</a>
<a name="ln5809"> </a>
<a name="ln5810">    case SPELL_SUMMON_ILLUSION:</a>
<a name="ln5811">        _mons_cast_summon_illusion(mons, spell_cast);</a>
<a name="ln5812">        return;</a>
<a name="ln5813"> </a>
<a name="ln5814">    case SPELL_CREATE_TENTACLES:</a>
<a name="ln5815">        mons_create_tentacles(mons);</a>
<a name="ln5816">        return;</a>
<a name="ln5817"> </a>
<a name="ln5818">    case SPELL_FAKE_MARA_SUMMON:</a>
<a name="ln5819">        // We only want there to be two fakes, which, plus Mara, means</a>
<a name="ln5820">        // a total of three Maras; if we already have two, give up, otherwise</a>
<a name="ln5821">        // we want to summon either one more or two more.</a>
<a name="ln5822">        sumcount2 = 2 - count_summons(mons, SPELL_FAKE_MARA_SUMMON);</a>
<a name="ln5823">        if (sumcount2 &lt;= 0)</a>
<a name="ln5824">            return;</a>
<a name="ln5825"> </a>
<a name="ln5826">        for (sumcount = 0; sumcount &lt; sumcount2; sumcount++)</a>
<a name="ln5827">            cast_phantom_mirror(mons, mons, 50, SPELL_FAKE_MARA_SUMMON);</a>
<a name="ln5828"> </a>
<a name="ln5829">        if (you.can_see(*mons))</a>
<a name="ln5830">        {</a>
<a name="ln5831">            mprf(&quot;%s shimmers and seems to become %s!&quot;, mons-&gt;name(DESC_THE).c_str(),</a>
<a name="ln5832">                                                        sumcount2 == 1 ? &quot;two&quot;</a>
<a name="ln5833">                                                                       : &quot;three&quot;);</a>
<a name="ln5834">        }</a>
<a name="ln5835"> </a>
<a name="ln5836">        return;</a>
<a name="ln5837"> </a>
<a name="ln5838">    case SPELL_SUMMON_DEMON: // class 3-4 demons</a>
<a name="ln5839">        // if you change this, please update art-func.h:_DEMON_AXE_melee_effects</a>
<a name="ln5840">        sumcount2 = 1 + random2(mons-&gt;spell_hd(spell_cast) / 10 + 1);</a>
<a name="ln5841"> </a>
<a name="ln5842">        duration  = min(2 + mons-&gt;spell_hd(spell_cast) / 10, 6);</a>
<a name="ln5843">        for (sumcount = 0; sumcount &lt; sumcount2; sumcount++)</a>
<a name="ln5844">        {</a>
<a name="ln5845">            create_monster(</a>
<a name="ln5846">                mgen_data(summon_any_demon(RANDOM_DEMON_COMMON, true),</a>
<a name="ln5847">                          SAME_ATTITUDE(mons), mons-&gt;pos(), mons-&gt;foe)</a>
<a name="ln5848">                .set_summoned(mons, duration, spell_cast, god));</a>
<a name="ln5849">        }</a>
<a name="ln5850">        return;</a>
<a name="ln5851"> </a>
<a name="ln5852">    case SPELL_MONSTROUS_MENAGERIE:</a>
<a name="ln5853">        cast_monstrous_menagerie(mons, splpow, mons-&gt;god);</a>
<a name="ln5854">        return;</a>
<a name="ln5855"> </a>
<a name="ln5856">    case SPELL_TWISTED_RESURRECTION:</a>
<a name="ln5857">        // Double efficiency compared to maxed out player spell: one</a>
<a name="ln5858">        // elf corpse gives 4.5 HD.</a>
<a name="ln5859">        twisted_resurrection(mons, 500, SAME_ATTITUDE(mons),</a>
<a name="ln5860">                             mons-&gt;foe, god);</a>
<a name="ln5861">        return;</a>
<a name="ln5862"> </a>
<a name="ln5863">    case SPELL_CALL_IMP:</a>
<a name="ln5864">        duration  = min(2 + mons-&gt;spell_hd(spell_cast) / 5, 6);</a>
<a name="ln5865">        create_monster(</a>
<a name="ln5866">            mgen_data(random_choose_weighted(</a>
<a name="ln5867">                        1, MONS_IRON_IMP,</a>
<a name="ln5868">                        2, MONS_SHADOW_IMP,</a>
<a name="ln5869">                        2, MONS_WHITE_IMP,</a>
<a name="ln5870">                        4, MONS_CRIMSON_IMP),</a>
<a name="ln5871">                      SAME_ATTITUDE(mons), mons-&gt;pos(), mons-&gt;foe)</a>
<a name="ln5872">            .set_summoned(mons, duration, spell_cast, god));</a>
<a name="ln5873">        return;</a>
<a name="ln5874"> </a>
<a name="ln5875">    case SPELL_SUMMON_MINOR_DEMON: // class 5 demons</a>
<a name="ln5876">        sumcount2 = 1 + random2(3);</a>
<a name="ln5877"> </a>
<a name="ln5878">        duration  = min(2 + mons-&gt;spell_hd(spell_cast) / 5, 6);</a>
<a name="ln5879">        for (sumcount = 0; sumcount &lt; sumcount2; ++sumcount)</a>
<a name="ln5880">        {</a>
<a name="ln5881">            create_monster(</a>
<a name="ln5882">                mgen_data(summon_any_demon(RANDOM_DEMON_LESSER, true),</a>
<a name="ln5883">                          SAME_ATTITUDE(mons), mons-&gt;pos(), mons-&gt;foe)</a>
<a name="ln5884">                .set_summoned(mons, duration, spell_cast, god));</a>
<a name="ln5885">        }</a>
<a name="ln5886">        return;</a>
<a name="ln5887"> </a>
<a name="ln5888">    case SPELL_SUMMON_UFETUBUS:</a>
<a name="ln5889">        sumcount2 = 2 + random2(2);</a>
<a name="ln5890"> </a>
<a name="ln5891">        duration  = min(2 + mons-&gt;spell_hd(spell_cast) / 5, 6);</a>
<a name="ln5892"> </a>
<a name="ln5893">        for (sumcount = 0; sumcount &lt; sumcount2; ++sumcount)</a>
<a name="ln5894">        {</a>
<a name="ln5895">            create_monster(</a>
<a name="ln5896">                mgen_data(MONS_UFETUBUS, SAME_ATTITUDE(mons), mons-&gt;pos(),</a>
<a name="ln5897">                          mons-&gt;foe)</a>
<a name="ln5898">                .set_summoned(mons, duration, spell_cast, god));</a>
<a name="ln5899">        }</a>
<a name="ln5900">        return;</a>
<a name="ln5901"> </a>
<a name="ln5902">    case SPELL_SUMMON_HELL_BEAST:  // Geryon</a>
<a name="ln5903">        create_monster(</a>
<a name="ln5904">            mgen_data(MONS_HELL_BEAST, SAME_ATTITUDE(mons), mons-&gt;pos(),</a>
<a name="ln5905">                      mons-&gt;foe).set_summoned(mons, 4, spell_cast, god));</a>
<a name="ln5906">        return;</a>
<a name="ln5907"> </a>
<a name="ln5908">    case SPELL_SUMMON_ICE_BEAST:</a>
<a name="ln5909">        _summon(*mons, MONS_ICE_BEAST, 5, slot);</a>
<a name="ln5910">        return;</a>
<a name="ln5911"> </a>
<a name="ln5912">    case SPELL_SUMMON_MUSHROOMS:   // Summon a ring of icky crawling fungi.</a>
<a name="ln5913">        sumcount2 = 2 + random2(mons-&gt;spell_hd(spell_cast) / 4 + 1);</a>
<a name="ln5914">        duration  = min(2 + mons-&gt;spell_hd(spell_cast) / 5, 6);</a>
<a name="ln5915">        for (int i = 0; i &lt; sumcount2; ++i)</a>
<a name="ln5916">        {</a>
<a name="ln5917">            // Attempt to place adjacent to target first, and only at a wider</a>
<a name="ln5918">            // radius if no adjacent spots can be found</a>
<a name="ln5919">            coord_def empty;</a>
<a name="ln5920">            find_habitable_spot_near(mons-&gt;get_foe()-&gt;pos(),</a>
<a name="ln5921">                                     MONS_WANDERING_MUSHROOM, 1, false, empty);</a>
<a name="ln5922">            if (empty.origin())</a>
<a name="ln5923">            {</a>
<a name="ln5924">                find_habitable_spot_near(mons-&gt;get_foe()-&gt;pos(),</a>
<a name="ln5925">                                         MONS_WANDERING_MUSHROOM, 2, false, empty);</a>
<a name="ln5926">            }</a>
<a name="ln5927"> </a>
<a name="ln5928">            // Can't find any room, so stop trying</a>
<a name="ln5929">            if (empty.origin())</a>
<a name="ln5930">                return;</a>
<a name="ln5931"> </a>
<a name="ln5932">            create_monster(</a>
<a name="ln5933">                mgen_data(one_chance_in(3) ? MONS_DEATHCAP</a>
<a name="ln5934">                                           : MONS_WANDERING_MUSHROOM,</a>
<a name="ln5935">                          SAME_ATTITUDE(mons), empty, mons-&gt;foe, MG_FORCE_PLACE)</a>
<a name="ln5936">                .set_summoned(mons, duration, spell_cast, god));</a>
<a name="ln5937">        }</a>
<a name="ln5938">        return;</a>
<a name="ln5939"> </a>
<a name="ln5940">    case SPELL_SUMMON_HORRIBLE_THINGS:</a>
<a name="ln5941">        _do_high_level_summon(mons, spell_cast, _pick_horrible_thing,</a>
<a name="ln5942">                              random_range(3, 5), god);</a>
<a name="ln5943">        return;</a>
<a name="ln5944"> </a>
<a name="ln5945">    case SPELL_MALIGN_GATEWAY:</a>
<a name="ln5946">        if (!can_cast_malign_gateway())</a>
<a name="ln5947">        {</a>
<a name="ln5948">            dprf(&quot;ERROR: %s can't cast malign gateway, but is casting anyway! &quot;</a>
<a name="ln5949">                 &quot;Counted %d gateways.&quot;, mons-&gt;name(DESC_THE).c_str(),</a>
<a name="ln5950">                 count_malign_gateways());</a>
<a name="ln5951">        }</a>
<a name="ln5952">        cast_malign_gateway(mons, 200);</a>
<a name="ln5953">        return;</a>
<a name="ln5954"> </a>
<a name="ln5955">    case SPELL_CONJURE_BALL_LIGHTNING:</a>
<a name="ln5956">    {</a>
<a name="ln5957">        const int n = min(8, 2 + random2avg(mons-&gt;spell_hd(spell_cast) / 4, 2));</a>
<a name="ln5958">        for (int i = 0; i &lt; n; ++i)</a>
<a name="ln5959">        {</a>
<a name="ln5960">            if (monster *ball = create_monster(</a>
<a name="ln5961">                    mgen_data(MONS_BALL_LIGHTNING, SAME_ATTITUDE(mons),</a>
<a name="ln5962">                              mons-&gt;pos(), mons-&gt;foe)</a>
<a name="ln5963">                    .set_summoned(mons, 0, spell_cast, god)))</a>
<a name="ln5964">            {</a>
<a name="ln5965">                ball-&gt;add_ench(ENCH_SHORT_LIVED);</a>
<a name="ln5966">            }</a>
<a name="ln5967">        }</a>
<a name="ln5968">        return;</a>
<a name="ln5969">    }</a>
<a name="ln5970"> </a>
<a name="ln5971">    case SPELL_SUMMON_UNDEAD:</a>
<a name="ln5972">        _do_high_level_summon(mons, spell_cast, _pick_undead_summon,</a>
<a name="ln5973">                              2 + random2(mons-&gt;spell_hd(spell_cast) / 5 + 1),</a>
<a name="ln5974">                              god);</a>
<a name="ln5975">        return;</a>
<a name="ln5976"> </a>
<a name="ln5977">    case SPELL_BROTHERS_IN_ARMS:</a>
<a name="ln5978">    {</a>
<a name="ln5979">        // Invocation; don't use spell_hd</a>
<a name="ln5980">        int power = (mons-&gt;get_hit_dice() * 20)</a>
<a name="ln5981">                          + random2(mons-&gt;get_hit_dice() * 5);</a>
<a name="ln5982">        power -= random2(mons-&gt;get_hit_dice() * 5); // force a sequence point</a>
<a name="ln5983">        monster_type to_summon;</a>
<a name="ln5984"> </a>
<a name="ln5985">        if (mons-&gt;type == MONS_SPRIGGAN_BERSERKER)</a>
<a name="ln5986">        {</a>
<a name="ln5987">            monster_type berserkers[] = { MONS_POLAR_BEAR, MONS_ELEPHANT,</a>
<a name="ln5988">                                          MONS_DEATH_YAK };</a>
<a name="ln5989">            to_summon = RANDOM_ELEMENT(berserkers);</a>
<a name="ln5990">        }</a>
<a name="ln5991">        else</a>
<a name="ln5992">        {</a>
<a name="ln5993">            monster_type berserkers[] = { MONS_BLACK_BEAR, MONS_OGRE, MONS_TROLL,</a>
<a name="ln5994">                                           MONS_TWO_HEADED_OGRE, MONS_DEEP_TROLL };</a>
<a name="ln5995">            to_summon = RANDOM_ELEMENT(berserkers);</a>
<a name="ln5996">        }</a>
<a name="ln5997"> </a>
<a name="ln5998">        summon_berserker(power, mons, to_summon);</a>
<a name="ln5999">        mons-&gt;props[&quot;brothers_count&quot;].get_int()++;</a>
<a name="ln6000">        return;</a>
<a name="ln6001">    }</a>
<a name="ln6002"> </a>
<a name="ln6003">    case SPELL_SYMBOL_OF_TORMENT:</a>
<a name="ln6004">        torment(mons, TORMENT_SPELL, mons-&gt;pos());</a>
<a name="ln6005">        return;</a>
<a name="ln6006"> </a>
<a name="ln6007">    case SPELL_MESMERISE:</a>
<a name="ln6008">        _mons_mesmerise(mons);</a>
<a name="ln6009">        return;</a>
<a name="ln6010"> </a>
<a name="ln6011">    case SPELL_CAUSE_FEAR:</a>
<a name="ln6012">        _mons_cause_fear(mons);</a>
<a name="ln6013">        return;</a>
<a name="ln6014"> </a>
<a name="ln6015">    case SPELL_OLGREBS_TOXIC_RADIANCE:</a>
<a name="ln6016">        cast_toxic_radiance(mons, splpow);</a>
<a name="ln6017">        return;</a>
<a name="ln6018"> </a>
<a name="ln6019">    case SPELL_SHATTER:</a>
<a name="ln6020">        mons_shatter(mons);</a>
<a name="ln6021">        return;</a>
<a name="ln6022"> </a>
<a name="ln6023">    case SPELL_CORPSE_ROT:</a>
<a name="ln6024">        corpse_rot(mons);</a>
<a name="ln6025">        return;</a>
<a name="ln6026"> </a>
<a name="ln6027">    case SPELL_SUMMON_GREATER_DEMON:</a>
<a name="ln6028">        duration  = min(2 + mons-&gt;spell_hd(spell_cast) / 10, 6);</a>
<a name="ln6029"> </a>
<a name="ln6030">        create_monster(</a>
<a name="ln6031">            mgen_data(summon_any_demon(RANDOM_DEMON_GREATER, true),</a>
<a name="ln6032">                      SAME_ATTITUDE(mons), mons-&gt;pos(), mons-&gt;foe)</a>
<a name="ln6033">            .set_summoned(mons, duration, spell_cast, god));</a>
<a name="ln6034">        return;</a>
<a name="ln6035"> </a>
<a name="ln6036">    // Journey -- Added in Summon Lizards</a>
<a name="ln6037">    case SPELL_SUMMON_DRAKES:</a>
<a name="ln6038">        sumcount2 = 1 + random2(mons-&gt;spell_hd(spell_cast) / 5 + 1);</a>
<a name="ln6039"> </a>
<a name="ln6040">        duration  = min(2 + mons-&gt;spell_hd(spell_cast) / 10, 6);</a>
<a name="ln6041"> </a>
<a name="ln6042">        {</a>
<a name="ln6043">            vector&lt;monster_type&gt; monsters;</a>
<a name="ln6044"> </a>
<a name="ln6045">            for (sumcount = 0; sumcount &lt; sumcount2; ++sumcount)</a>
<a name="ln6046">            {</a>
<a name="ln6047">                monster_type mon = _pick_drake();</a>
<a name="ln6048">                monsters.push_back(mon);</a>
<a name="ln6049">            }</a>
<a name="ln6050"> </a>
<a name="ln6051">            for (monster_type type : monsters)</a>
<a name="ln6052">            {</a>
<a name="ln6053">                create_monster(</a>
<a name="ln6054">                    mgen_data(type, SAME_ATTITUDE(mons), mons-&gt;pos(),</a>
<a name="ln6055">                              mons-&gt;foe)</a>
<a name="ln6056">                    .set_summoned(mons, duration, spell_cast, god));</a>
<a name="ln6057">            }</a>
<a name="ln6058">        }</a>
<a name="ln6059">        return;</a>
<a name="ln6060"> </a>
<a name="ln6061">    case SPELL_DRUIDS_CALL:</a>
<a name="ln6062">        _cast_druids_call(mons);</a>
<a name="ln6063">        return;</a>
<a name="ln6064"> </a>
<a name="ln6065">    case SPELL_BATTLESPHERE:</a>
<a name="ln6066">        cast_battlesphere(mons, min(splpow, 200), mons-&gt;god, false);</a>
<a name="ln6067">        return;</a>
<a name="ln6068"> </a>
<a name="ln6069">    case SPELL_SPECTRAL_WEAPON:</a>
<a name="ln6070">        cast_spectral_weapon(mons, min(splpow, 200), mons-&gt;god, false);</a>
<a name="ln6071">        return;</a>
<a name="ln6072"> </a>
<a name="ln6073">    case SPELL_TORNADO:</a>
<a name="ln6074">    {</a>
<a name="ln6075">        _mons_tornado(mons);</a>
<a name="ln6076">        return;</a>
<a name="ln6077">    }</a>
<a name="ln6078"> </a>
<a name="ln6079">    case SPELL_VORTEX:</a>
<a name="ln6080">    {</a>
<a name="ln6081">        _mons_tornado(mons, true);</a>
<a name="ln6082">        return;</a>
<a name="ln6083">    }</a>
<a name="ln6084"> </a>
<a name="ln6085">    case SPELL_SUMMON_HOLIES: // Holy monsters.</a>
<a name="ln6086">        sumcount2 = 1 + random2(2); // sequence point</a>
<a name="ln6087">        sumcount2 += random2(mons-&gt;spell_hd(spell_cast) / 4 + 1);</a>
<a name="ln6088"> </a>
<a name="ln6089">        duration  = min(2 + mons-&gt;spell_hd(spell_cast) / 5, 6);</a>
<a name="ln6090">        for (int i = 0; i &lt; sumcount2; ++i)</a>
<a name="ln6091">        {</a>
<a name="ln6092">            create_monster(</a>
<a name="ln6093">                mgen_data(random_choose_weighted(</a>
<a name="ln6094">                            100, MONS_ANGEL,     80,  MONS_CHERUB,</a>
<a name="ln6095">                            50,  MONS_DAEVA,      1,  MONS_OPHAN),</a>
<a name="ln6096">                          SAME_ATTITUDE(mons), mons-&gt;pos(), mons-&gt;foe)</a>
<a name="ln6097">                .set_summoned(mons, duration, spell_cast, god));</a>
<a name="ln6098">        }</a>
<a name="ln6099">        return;</a>
<a name="ln6100"> </a>
<a name="ln6101">    case SPELL_BLINK_OTHER:</a>
<a name="ln6102">    {</a>
<a name="ln6103">        // Allow the caster to comment on moving the foe.</a>
<a name="ln6104">        string msg = getSpeakString(mons-&gt;name(DESC_PLAIN) + &quot; blink_other&quot;);</a>
<a name="ln6105">        if (!msg.empty() &amp;&amp; msg != &quot;__NONE&quot;)</a>
<a name="ln6106">        {</a>
<a name="ln6107">            mons_speaks_msg(mons, msg, MSGCH_TALK,</a>
<a name="ln6108">                            silenced(you.pos()) || silenced(mons-&gt;pos()));</a>
<a name="ln6109">        }</a>
<a name="ln6110">        break;</a>
<a name="ln6111">    }</a>
<a name="ln6112"> </a>
<a name="ln6113">    case SPELL_BLINK_OTHER_CLOSE:</a>
<a name="ln6114">    {</a>
<a name="ln6115">        // Allow the caster to comment on moving the foe.</a>
<a name="ln6116">        string msg = getSpeakString(mons-&gt;name(DESC_PLAIN)</a>
<a name="ln6117">                                    + &quot; blink_other_close&quot;);</a>
<a name="ln6118">        if (!msg.empty() &amp;&amp; msg != &quot;__NONE&quot;)</a>
<a name="ln6119">        {</a>
<a name="ln6120">            mons_speaks_msg(mons, msg, MSGCH_TALK,</a>
<a name="ln6121">                            silenced(you.pos()) || silenced(mons-&gt;pos()));</a>
<a name="ln6122">        }</a>
<a name="ln6123">        break;</a>
<a name="ln6124">    }</a>
<a name="ln6125"> </a>
<a name="ln6126">    case SPELL_TOMB_OF_DOROKLOHE:</a>
<a name="ln6127">    {</a>
<a name="ln6128">        sumcount = 0;</a>
<a name="ln6129"> </a>
<a name="ln6130">        const int hp_lost = mons-&gt;max_hit_points - mons-&gt;hit_points;</a>
<a name="ln6131"> </a>
<a name="ln6132">        if (!hp_lost)</a>
<a name="ln6133">            sumcount++;</a>
<a name="ln6134"> </a>
<a name="ln6135">        static const set&lt;dungeon_feature_type&gt; safe_tiles =</a>
<a name="ln6136">        {</a>
<a name="ln6137">            DNGN_SHALLOW_WATER, DNGN_FLOOR, DNGN_OPEN_DOOR,</a>
<a name="ln6138">            DNGN_OPEN_CLEAR_DOOR</a>
<a name="ln6139">        };</a>
<a name="ln6140"> </a>
<a name="ln6141">        for (adjacent_iterator ai(mons-&gt;pos()); ai; ++ai)</a>
<a name="ln6142">        {</a>
<a name="ln6143">            const actor* act = actor_at(*ai);</a>
<a name="ln6144"> </a>
<a name="ln6145">            // We can blink away the crowd, but only our allies.</a>
<a name="ln6146">            if (act</a>
<a name="ln6147">                &amp;&amp; (act-&gt;is_player()</a>
<a name="ln6148">                    || (act-&gt;is_monster()</a>
<a name="ln6149">                        &amp;&amp; act-&gt;as_monster()-&gt;attitude != mons-&gt;attitude)))</a>
<a name="ln6150">            {</a>
<a name="ln6151">                sumcount++;</a>
<a name="ln6152">            }</a>
<a name="ln6153"> </a>
<a name="ln6154">            // Make sure we have a legitimate tile.</a>
<a name="ln6155">            if (!safe_tiles.count(grd(*ai)) &amp;&amp; !feat_is_trap(grd(*ai))</a>
<a name="ln6156">                &amp;&amp; feat_is_reachable_past(grd(*ai)))</a>
<a name="ln6157">            {</a>
<a name="ln6158">                sumcount++;</a>
<a name="ln6159">            }</a>
<a name="ln6160">        }</a>
<a name="ln6161"> </a>
<a name="ln6162">        if (sumcount)</a>
<a name="ln6163">        {</a>
<a name="ln6164">            mons-&gt;blink();</a>
<a name="ln6165">            return;</a>
<a name="ln6166">        }</a>
<a name="ln6167"> </a>
<a name="ln6168">        sumcount = 0;</a>
<a name="ln6169">        for (adjacent_iterator ai(mons-&gt;pos()); ai; ++ai)</a>
<a name="ln6170">        {</a>
<a name="ln6171">            if (monster_at(*ai))</a>
<a name="ln6172">            {</a>
<a name="ln6173">                monster_at(*ai)-&gt;blink();</a>
<a name="ln6174">                if (monster_at(*ai))</a>
<a name="ln6175">                {</a>
<a name="ln6176">                    monster_at(*ai)-&gt;teleport(true);</a>
<a name="ln6177">                    if (monster_at(*ai))</a>
<a name="ln6178">                        continue;</a>
<a name="ln6179">                }</a>
<a name="ln6180">            }</a>
<a name="ln6181"> </a>
<a name="ln6182">            // Make sure we have a legitimate tile.</a>
<a name="ln6183">            if (safe_tiles.count(grd(*ai)) || feat_is_trap(grd(*ai)))</a>
<a name="ln6184">            {</a>
<a name="ln6185">                // All items are moved inside.</a>
<a name="ln6186">                if (igrd(*ai) != NON_ITEM)</a>
<a name="ln6187">                    move_items(*ai, mons-&gt;pos());</a>
<a name="ln6188"> </a>
<a name="ln6189">                // All clouds are destroyed.</a>
<a name="ln6190">                delete_cloud(*ai);</a>
<a name="ln6191"> </a>
<a name="ln6192">                // All traps are destroyed.</a>
<a name="ln6193">                if (trap_def *ptrap = trap_at(*ai))</a>
<a name="ln6194">                    ptrap-&gt;destroy();</a>
<a name="ln6195"> </a>
<a name="ln6196">                // Actually place the wall.</a>
<a name="ln6197">                temp_change_terrain(*ai, DNGN_ROCK_WALL, INFINITE_DURATION,</a>
<a name="ln6198">                                    TERRAIN_CHANGE_TOMB, mons);</a>
<a name="ln6199">                sumcount++;</a>
<a name="ln6200">            }</a>
<a name="ln6201">        }</a>
<a name="ln6202"> </a>
<a name="ln6203">        if (sumcount)</a>
<a name="ln6204">        {</a>
<a name="ln6205">            mpr(&quot;Walls emerge from the floor!&quot;);</a>
<a name="ln6206"> </a>
<a name="ln6207">            // XXX: Assume that the entombed monster can regenerate.</a>
<a name="ln6208">            // Also, base the regeneration rate on HD to avoid</a>
<a name="ln6209">            // randomness.</a>
<a name="ln6210">            const int tomb_duration = BASELINE_DELAY</a>
<a name="ln6211">                * hp_lost * max(1, mons-&gt;spell_hd(spell_cast) / 3);</a>
<a name="ln6212">            int mon_index = mons-&gt;mindex();</a>
<a name="ln6213">            env.markers.add(new map_tomb_marker(mons-&gt;pos(),</a>
<a name="ln6214">                                                tomb_duration,</a>
<a name="ln6215">                                                mon_index,</a>
<a name="ln6216">                                                mon_index));</a>
<a name="ln6217">            env.markers.clear_need_activate(); // doesn't need activation</a>
<a name="ln6218">        }</a>
<a name="ln6219">        return;</a>
<a name="ln6220">    }</a>
<a name="ln6221"> </a>
<a name="ln6222">    case SPELL_CHAIN_LIGHTNING:</a>
<a name="ln6223">        cast_chain_spell(spell_cast, splpow, mons);</a>
<a name="ln6224">        return;</a>
<a name="ln6225"> </a>
<a name="ln6226">    case SPELL_SUMMON_EYEBALLS:</a>
<a name="ln6227">        sumcount2 = 1 + random2(mons-&gt;spell_hd(spell_cast) / 7 + 1);</a>
<a name="ln6228"> </a>
<a name="ln6229">        duration = min(2 + mons-&gt;spell_hd(spell_cast) / 10, 6);</a>
<a name="ln6230"> </a>
<a name="ln6231">        for (sumcount = 0; sumcount &lt; sumcount2; sumcount++)</a>
<a name="ln6232">        {</a>
<a name="ln6233">            const monster_type mon = random_choose_weighted(</a>
<a name="ln6234">                                       100, MONS_FLOATING_EYE,</a>
<a name="ln6235">                                        80, MONS_EYE_OF_DRAINING,</a>
<a name="ln6236">                                        60, MONS_GOLDEN_EYE,</a>
<a name="ln6237">                                        40, MONS_SHINING_EYE,</a>
<a name="ln6238">                                        20, MONS_GREAT_ORB_OF_EYES,</a>
<a name="ln6239">                                        10, MONS_EYE_OF_DEVASTATION);</a>
<a name="ln6240"> </a>
<a name="ln6241">            create_monster(</a>
<a name="ln6242">                mgen_data(mon, SAME_ATTITUDE(mons), mons-&gt;pos(), mons-&gt;foe)</a>
<a name="ln6243">                .set_summoned(mons, duration, spell_cast, god));</a>
<a name="ln6244">        }</a>
<a name="ln6245">        return;</a>
<a name="ln6246"> </a>
<a name="ln6247">    case SPELL_SUMMON_BUTTERFLIES:</a>
<a name="ln6248">        duration = min(2 + mons-&gt;spell_hd(spell_cast) / 5, 6);</a>
<a name="ln6249">        for (int i = 0; i &lt; 10; ++i)</a>
<a name="ln6250">        {</a>
<a name="ln6251">            create_monster(</a>
<a name="ln6252">                mgen_data(MONS_BUTTERFLY, SAME_ATTITUDE(mons),</a>
<a name="ln6253">                          mons-&gt;pos(), mons-&gt;foe)</a>
<a name="ln6254">                .set_summoned(mons, duration, spell_cast, god));</a>
<a name="ln6255">        }</a>
<a name="ln6256">        return;</a>
<a name="ln6257"> </a>
<a name="ln6258">    case SPELL_IOOD:</a>
<a name="ln6259">        cast_iood(mons, 6 * mons-&gt;spell_hd(spell_cast), &amp;pbolt);</a>
<a name="ln6260">        return;</a>
<a name="ln6261"> </a>
<a name="ln6262">    case SPELL_AWAKEN_FOREST:</a>
<a name="ln6263">        if (!mons-&gt;friendly() &amp;&amp; have_passive(passive_t::friendly_plants))</a>
<a name="ln6264">        {</a>
<a name="ln6265">            if (you.can_see(*mons))</a>
<a name="ln6266">            {</a>
<a name="ln6267">                mprf(&quot;%s commands the forest to attack, but nothing happens.&quot;,</a>
<a name="ln6268">                     mons-&gt;name(DESC_THE).c_str());</a>
<a name="ln6269">            }</a>
<a name="ln6270">            return;</a>
<a name="ln6271">        }</a>
<a name="ln6272"> </a>
<a name="ln6273">        duration = 50 + random2(mons-&gt;spell_hd(spell_cast) * 20);</a>
<a name="ln6274"> </a>
<a name="ln6275">        mons-&gt;add_ench(mon_enchant(ENCH_AWAKEN_FOREST, 0, mons, duration));</a>
<a name="ln6276">        // Actually, it's a boolean marker... save for a sanity check.</a>
<a name="ln6277">        env.forest_awoken_until = you.elapsed_time + duration;</a>
<a name="ln6278"> </a>
<a name="ln6279">        // You may be unable to see the monster, but notice an affected tree.</a>
<a name="ln6280">        forest_message(mons-&gt;pos(), &quot;The forest starts to sway and rumble!&quot;);</a>
<a name="ln6281">        return;</a>
<a name="ln6282"> </a>
<a name="ln6283">    case SPELL_SUMMON_DRAGON:</a>
<a name="ln6284">        cast_summon_dragon(mons, splpow, god);</a>
<a name="ln6285">        return;</a>
<a name="ln6286"> </a>
<a name="ln6287">    case SPELL_SUMMON_HYDRA:</a>
<a name="ln6288">        cast_summon_hydra(mons, splpow, god);</a>
<a name="ln6289">        return;</a>
<a name="ln6290"> </a>
<a name="ln6291">    case SPELL_FIRE_SUMMON:</a>
<a name="ln6292">        sumcount2 = 1 + random2(mons-&gt;spell_hd(spell_cast) / 5 + 1);</a>
<a name="ln6293"> </a>
<a name="ln6294">        duration = min(2 + mons-&gt;spell_hd(spell_cast) / 10, 6);</a>
<a name="ln6295"> </a>
<a name="ln6296">        for (sumcount = 0; sumcount &lt; sumcount2; sumcount++)</a>
<a name="ln6297">        {</a>
<a name="ln6298">            const monster_type mon = random_choose_weighted(</a>
<a name="ln6299">                                       3, MONS_EFREET,</a>
<a name="ln6300">                                       3, MONS_SUN_DEMON,</a>
<a name="ln6301">                                       3, MONS_BALRUG,</a>
<a name="ln6302">                                       2, MONS_HELLION,</a>
<a name="ln6303">                                       1, MONS_BRIMSTONE_FIEND);</a>
<a name="ln6304"> </a>
<a name="ln6305">            create_monster(</a>
<a name="ln6306">                mgen_data(mon, SAME_ATTITUDE(mons), mons-&gt;pos(), mons-&gt;foe)</a>
<a name="ln6307">                .set_summoned(mons, duration, spell_cast, god));</a>
<a name="ln6308">        }</a>
<a name="ln6309">        return;</a>
<a name="ln6310"> </a>
<a name="ln6311">    case SPELL_OZOCUBUS_ARMOUR:</a>
<a name="ln6312">    {</a>
<a name="ln6313">        if (you.can_see(*mons))</a>
<a name="ln6314">        {</a>
<a name="ln6315">            mprf(&quot;A film of ice covers %s body!&quot;,</a>
<a name="ln6316">                 apostrophise(mons-&gt;name(DESC_THE)).c_str());</a>
<a name="ln6317">        }</a>
<a name="ln6318">        const int power = (mons-&gt;spell_hd(spell_cast) * 15) / 10;</a>
<a name="ln6319">        const int rnd_power = random2(power); // sequence point</a>
<a name="ln6320">        const int two_rnd_powers = rnd_power + random2(power);</a>
<a name="ln6321">        mons-&gt;add_ench(mon_enchant(ENCH_OZOCUBUS_ARMOUR,</a>
<a name="ln6322">                                   20 + two_rnd_powers,</a>
<a name="ln6323">                                   mons));</a>
<a name="ln6324"> </a>
<a name="ln6325">        return;</a>
<a name="ln6326">    }</a>
<a name="ln6327"> </a>
<a name="ln6328">    case SPELL_WORD_OF_RECALL:</a>
<a name="ln6329">    {</a>
<a name="ln6330">        mon_enchant chant_timer = mon_enchant(ENCH_WORD_OF_RECALL, 1, mons, 30);</a>
<a name="ln6331">        mons-&gt;add_ench(chant_timer);</a>
<a name="ln6332">        mons-&gt;speed_increment -= 30;</a>
<a name="ln6333">        return;</a>
<a name="ln6334">    }</a>
<a name="ln6335"> </a>
<a name="ln6336">    case SPELL_INJURY_BOND:</a>
<a name="ln6337">    {</a>
<a name="ln6338">        simple_monster_message(*mons,</a>
<a name="ln6339">            make_stringf(&quot; begins to accept %s allies' injuries.&quot;,</a>
<a name="ln6340">                         mons-&gt;pronoun(PRONOUN_POSSESSIVE).c_str()).c_str());</a>
<a name="ln6341">        // FIXME: allies preservers vs the player</a>
<a name="ln6342">        for (monster_near_iterator mi(mons, LOS_NO_TRANS); mi; ++mi)</a>
<a name="ln6343">        {</a>
<a name="ln6344">            if (mons_aligned(mons, *mi) &amp;&amp; !mi-&gt;has_ench(ENCH_CHARM)</a>
<a name="ln6345">                &amp;&amp; !mi-&gt;has_ench(ENCH_HEXED) &amp;&amp; *mi != mons)</a>
<a name="ln6346">            {</a>
<a name="ln6347">                mon_enchant bond = mon_enchant(ENCH_INJURY_BOND, 1, mons,</a>
<a name="ln6348">                                               40 + random2(80));</a>
<a name="ln6349">                mi-&gt;add_ench(bond);</a>
<a name="ln6350">            }</a>
<a name="ln6351">        }</a>
<a name="ln6352"> </a>
<a name="ln6353">        return;</a>
<a name="ln6354">    }</a>
<a name="ln6355"> </a>
<a name="ln6356">    case SPELL_CALL_LOST_SOUL:</a>
<a name="ln6357">        create_monster(mgen_data(MONS_LOST_SOUL, SAME_ATTITUDE(mons),</a>
<a name="ln6358">                                 mons-&gt;pos(), mons-&gt;foe)</a>
<a name="ln6359">                       .set_summoned(mons, 2, spell_cast, god));</a>
<a name="ln6360">        return;</a>
<a name="ln6361"> </a>
<a name="ln6362">    case SPELL_BLINK_ALLIES_ENCIRCLE:</a>
<a name="ln6363">        _blink_allies_encircle(mons);</a>
<a name="ln6364">        return;</a>
<a name="ln6365"> </a>
<a name="ln6366">    case SPELL_MASS_CONFUSION:</a>
<a name="ln6367">        _mons_mass_confuse(mons);</a>
<a name="ln6368">        return;</a>
<a name="ln6369"> </a>
<a name="ln6370">    case SPELL_ENGLACIATION:</a>
<a name="ln6371">        if (you.can_see(*mons))</a>
<a name="ln6372">            simple_monster_message(*mons, &quot; radiates an aura of cold.&quot;);</a>
<a name="ln6373">        else if (mons-&gt;see_cell_no_trans(you.pos()))</a>
<a name="ln6374">            mpr(&quot;A wave of cold passes over you.&quot;);</a>
<a name="ln6375">        apply_area_visible([splpow, mons] (coord_def where) {</a>
<a name="ln6376">            return englaciate(where, min(splpow, 200), mons);</a>
<a name="ln6377">        }, mons-&gt;pos());</a>
<a name="ln6378">        return;</a>
<a name="ln6379"> </a>
<a name="ln6380">    case SPELL_AWAKEN_VINES:</a>
<a name="ln6381">        _awaken_vines(mons);</a>
<a name="ln6382">        return;</a>
<a name="ln6383"> </a>
<a name="ln6384">    case SPELL_WALL_OF_BRAMBLES:</a>
<a name="ln6385">        // If we can't cast this for some reason (can be expensive to determine</a>
<a name="ln6386">        // at every call to _ms_waste_of_time), refund the energy for it so that</a>
<a name="ln6387">        // the caster can do something else</a>
<a name="ln6388">        if (!_wall_of_brambles(mons))</a>
<a name="ln6389">        {</a>
<a name="ln6390">            mons-&gt;speed_increment +=</a>
<a name="ln6391">                get_monster_data(mons-&gt;type)-&gt;energy_usage.spell;</a>
<a name="ln6392">        }</a>
<a name="ln6393">        return;</a>
<a name="ln6394"> </a>
<a name="ln6395">    case SPELL_WIND_BLAST:</a>
<a name="ln6396">    {</a>
<a name="ln6397">        // Wind blast is stopped by FFT_SOLID features.</a>
<a name="ln6398">        if (foe &amp;&amp; cell_see_cell(mons-&gt;pos(), foe-&gt;pos(), LOS_SOLID))</a>
<a name="ln6399">            wind_blast(mons, splpow, foe-&gt;pos());</a>
<a name="ln6400">        return;</a>
<a name="ln6401">    }</a>
<a name="ln6402"> </a>
<a name="ln6403">    case SPELL_FREEZE:</a>
<a name="ln6404">        _mons_cast_freeze(mons);</a>
<a name="ln6405">        return;</a>
<a name="ln6406"> </a>
<a name="ln6407">    case SPELL_SUMMON_VERMIN:</a>
<a name="ln6408">        _do_high_level_summon(mons, spell_cast, _pick_vermin,</a>
<a name="ln6409">                              one_chance_in(4) ? 3 : 2 , god);</a>
<a name="ln6410">        return;</a>
<a name="ln6411"> </a>
<a name="ln6412">    case SPELL_DISCHARGE:</a>
<a name="ln6413">        cast_discharge(min(200, splpow), *mons);</a>
<a name="ln6414">        return;</a>
<a name="ln6415"> </a>
<a name="ln6416">    case SPELL_PORTAL_PROJECTILE:</a>
<a name="ln6417">    {</a>
<a name="ln6418">        // Swap weapons if necessary so that that happens before the spell</a>
<a name="ln6419">        // casting message.</a>
<a name="ln6420">        item_def *launcher = nullptr;</a>
<a name="ln6421">        mons_usable_missile(mons, &amp;launcher);</a>
<a name="ln6422">        const item_def *weapon = mons-&gt;mslot_item(MSLOT_WEAPON);</a>
<a name="ln6423">        if (launcher &amp;&amp; launcher != weapon)</a>
<a name="ln6424">            mons-&gt;swap_weapons();</a>
<a name="ln6425">        mons_cast_noise(mons, pbolt, spell_cast, slot_flags);</a>
<a name="ln6426">        handle_throw(mons, pbolt, true, false);</a>
<a name="ln6427">        return;</a>
<a name="ln6428">    }</a>
<a name="ln6429"> </a>
<a name="ln6430">    case SPELL_IGNITE_POISON:</a>
<a name="ln6431">        cast_ignite_poison(mons, splpow, false);</a>
<a name="ln6432">        return;</a>
<a name="ln6433"> </a>
<a name="ln6434">    case SPELL_BLACK_MARK:</a>
<a name="ln6435">        _cast_black_mark(mons);</a>
<a name="ln6436">        return;</a>
<a name="ln6437"> </a>
<a name="ln6438">    case SPELL_BLINK_ALLIES_AWAY:</a>
<a name="ln6439">        _blink_allies_away(mons);</a>
<a name="ln6440">        return;</a>
<a name="ln6441"> </a>
<a name="ln6442">    case SPELL_SHROUD_OF_GOLUBRIA:</a>
<a name="ln6443">        if (you.can_see(*mons))</a>
<a name="ln6444">        {</a>
<a name="ln6445">            mprf(&quot;Space distorts along a thin shroud covering %s %s.&quot;,</a>
<a name="ln6446">                 apostrophise(mons-&gt;name(DESC_THE)).c_str(),</a>
<a name="ln6447">                 mons-&gt;is_insubstantial() ? &quot;form&quot; : &quot;body&quot;);</a>
<a name="ln6448">        }</a>
<a name="ln6449">        mons-&gt;add_ench(mon_enchant(ENCH_SHROUD));</a>
<a name="ln6450">        return;</a>
<a name="ln6451"> </a>
<a name="ln6452">    case SPELL_GLACIATE:</a>
<a name="ln6453">    {</a>
<a name="ln6454">        ASSERT(foe);</a>
<a name="ln6455">        cast_glaciate(mons, splpow, foe-&gt;pos());</a>
<a name="ln6456">        return;</a>
<a name="ln6457">    }</a>
<a name="ln6458"> </a>
<a name="ln6459">    case SPELL_CLOUD_CONE:</a>
<a name="ln6460">    {</a>
<a name="ln6461">        ASSERT(mons-&gt;get_foe());</a>
<a name="ln6462">        cast_cloud_cone(mons, splpow, mons-&gt;get_foe()-&gt;pos());</a>
<a name="ln6463">        return;</a>
<a name="ln6464">    }</a>
<a name="ln6465"> </a>
<a name="ln6466">    case SPELL_PHANTOM_MIRROR:</a>
<a name="ln6467">    {</a>
<a name="ln6468">        // Find appropriate ally to clone.</a>
<a name="ln6469">        vector&lt;monster*&gt; targets;</a>
<a name="ln6470">        for (monster_near_iterator mi(mons); mi; ++mi)</a>
<a name="ln6471">        {</a>
<a name="ln6472">            if (_mirrorable(mons, *mi))</a>
<a name="ln6473">                targets.push_back(*mi);</a>
<a name="ln6474">        }</a>
<a name="ln6475"> </a>
<a name="ln6476">        // If we've found something, mirror it.</a>
<a name="ln6477">        if (targets.size())</a>
<a name="ln6478">        {</a>
<a name="ln6479">            monster* targ = targets[random2(targets.size())];</a>
<a name="ln6480">            if (cast_phantom_mirror(mons, targ))</a>
<a name="ln6481">                simple_monster_message(*targ, &quot; shimmers and seems to become two!&quot;);</a>
<a name="ln6482">        }</a>
<a name="ln6483">        return;</a>
<a name="ln6484">    }</a>
<a name="ln6485"> </a>
<a name="ln6486">    case SPELL_SUMMON_MANA_VIPER:</a>
<a name="ln6487">    {</a>
<a name="ln6488">        const int num_vipers = 1 + random2(mons-&gt;spell_hd(spell_cast) / 5 + 1);</a>
<a name="ln6489">        for (int i = 0; i &lt; num_vipers; ++i)</a>
<a name="ln6490">            _summon(*mons, MONS_MANA_VIPER, 2, slot);</a>
<a name="ln6491">        return;</a>
<a name="ln6492">    }</a>
<a name="ln6493"> </a>
<a name="ln6494">    case SPELL_SUMMON_EMPEROR_SCORPIONS:</a>
<a name="ln6495">    {</a>
<a name="ln6496">        const int num_scorps = 1 + random2(mons-&gt;spell_hd(spell_cast) / 5 + 1);</a>
<a name="ln6497">        for (int i = 0; i &lt; num_scorps; ++i)</a>
<a name="ln6498">            _summon(*mons, MONS_EMPEROR_SCORPION, 5, slot);</a>
<a name="ln6499">        return;</a>
<a name="ln6500">    }</a>
<a name="ln6501"> </a>
<a name="ln6502">    case SPELL_BATTLECRY:</a>
<a name="ln6503">        _battle_cry(*mons);</a>
<a name="ln6504">        return;</a>
<a name="ln6505"> </a>
<a name="ln6506">    case SPELL_WARNING_CRY:</a>
<a name="ln6507">        return; // the entire point is the noise, handled elsewhere</a>
<a name="ln6508"> </a>
<a name="ln6509">    case SPELL_SEAL_DOORS:</a>
<a name="ln6510">        _seal_doors_and_stairs(mons);</a>
<a name="ln6511">        return;</a>
<a name="ln6512"> </a>
<a name="ln6513">    case SPELL_BERSERK_OTHER:</a>
<a name="ln6514">        _incite_monsters(mons, true);</a>
<a name="ln6515">        return;</a>
<a name="ln6516"> </a>
<a name="ln6517">    case SPELL_SPELLFORGED_SERVITOR:</a>
<a name="ln6518">    {</a>
<a name="ln6519">        monster* servitor = _summon(*mons, MONS_SPELLFORGED_SERVITOR, 4, slot);</a>
<a name="ln6520">        if (servitor)</a>
<a name="ln6521">            init_servitor(servitor, mons);</a>
<a name="ln6522">        else if (you.can_see(*mons))</a>
<a name="ln6523">            canned_msg(MSG_NOTHING_HAPPENS);</a>
<a name="ln6524">        return;</a>
<a name="ln6525">    }</a>
<a name="ln6526"> </a>
<a name="ln6527">    case SPELL_CORRUPTING_PULSE:</a>
<a name="ln6528">        _corrupting_pulse(mons);</a>
<a name="ln6529">        return;</a>
<a name="ln6530"> </a>
<a name="ln6531">    case SPELL_THROW_ALLY:</a>
<a name="ln6532">        _maybe_throw_ally(*mons);</a>
<a name="ln6533">        return;</a>
<a name="ln6534"> </a>
<a name="ln6535">    case SPELL_SIREN_SONG:</a>
<a name="ln6536">        _siren_sing(mons, false);</a>
<a name="ln6537">        return;</a>
<a name="ln6538"> </a>
<a name="ln6539">    case SPELL_AVATAR_SONG:</a>
<a name="ln6540">        _siren_sing(mons, true);</a>
<a name="ln6541">        return;</a>
<a name="ln6542"> </a>
<a name="ln6543">    case SPELL_REPEL_MISSILES:</a>
<a name="ln6544">        simple_monster_message(*mons, &quot; begins repelling missiles!&quot;);</a>
<a name="ln6545">        mons-&gt;add_ench(mon_enchant(ENCH_REPEL_MISSILES));</a>
<a name="ln6546">        return;</a>
<a name="ln6547"> </a>
<a name="ln6548">    case SPELL_SUMMON_SCARABS:</a>
<a name="ln6549">    {</a>
<a name="ln6550">        const int num_scarabs = 1 + random2(mons-&gt;spell_hd(spell_cast) / 5 + 1);</a>
<a name="ln6551">        for (int i = 0; i &lt; num_scarabs; ++i)</a>
<a name="ln6552">            _summon(*mons, MONS_DEATH_SCARAB, 2, slot);</a>
<a name="ln6553">        return;</a>
<a name="ln6554">    }</a>
<a name="ln6555"> </a>
<a name="ln6556">    case SPELL_SCATTERSHOT:</a>
<a name="ln6557">    {</a>
<a name="ln6558">        ASSERT(foe);</a>
<a name="ln6559">        cast_scattershot(mons, splpow, foe-&gt;pos());</a>
<a name="ln6560">        return;</a>
<a name="ln6561">    }</a>
<a name="ln6562"> </a>
<a name="ln6563">    case SPELL_CLEANSING_FLAME:</a>
<a name="ln6564">        simple_monster_message(*mons, &quot; channels a blast of cleansing flame!&quot;);</a>
<a name="ln6565">        cleansing_flame(5 + (5 * mons-&gt;spell_hd(spell_cast) / 12),</a>
<a name="ln6566">                        cleansing_flame_source::spell, mons-&gt;pos(), mons);</a>
<a name="ln6567">        return;</a>
<a name="ln6568"> </a>
<a name="ln6569">    case SPELL_GRAVITAS:</a>
<a name="ln6570">        fatal_attraction(foe-&gt;pos(), mons, splpow);</a>
<a name="ln6571">        return;</a>
<a name="ln6572"> </a>
<a name="ln6573">    case SPELL_ENTROPIC_WEAVE:</a>
<a name="ln6574">        foe-&gt;corrode_equipment(&quot;the entropic weave&quot;);</a>
<a name="ln6575">        return;</a>
<a name="ln6576"> </a>
<a name="ln6577">    case SPELL_SUMMON_EXECUTIONERS:</a>
<a name="ln6578">    {</a>
<a name="ln6579">        const int num_exec = 1 + random2(mons-&gt;spell_hd(spell_cast) / 5 + 1);</a>
<a name="ln6580">        duration = min(2 + mons-&gt;spell_hd(spell_cast) / 10, 6);</a>
<a name="ln6581">        for (int i = 0; i &lt; num_exec; ++i)</a>
<a name="ln6582">            _summon(*mons, MONS_EXECUTIONER, duration, slot);</a>
<a name="ln6583">        return;</a>
<a name="ln6584">    }</a>
<a name="ln6585"> </a>
<a name="ln6586">    case SPELL_DOOM_HOWL:</a>
<a name="ln6587">        _doom_howl(*mons);</a>
<a name="ln6588">        break;</a>
<a name="ln6589"> </a>
<a name="ln6590">    case SPELL_CALL_OF_CHAOS:</a>
<a name="ln6591">        _mons_call_of_chaos(*mons);</a>
<a name="ln6592">        return;</a>
<a name="ln6593"> </a>
<a name="ln6594">    case SPELL_AURA_OF_BRILLIANCE:</a>
<a name="ln6595">        simple_monster_message(*mons, &quot; begins emitting a brilliant aura!&quot;);</a>
<a name="ln6596">        mons-&gt;add_ench(ENCH_BRILLIANCE_AURA);</a>
<a name="ln6597">        aura_of_brilliance(mons);</a>
<a name="ln6598">        return;</a>
<a name="ln6599"> </a>
<a name="ln6600">    case SPELL_BIND_SOULS:</a>
<a name="ln6601">        simple_monster_message(*mons, &quot; binds the souls of nearby monsters.&quot;);</a>
<a name="ln6602">        for (monster_near_iterator mi(mons, LOS_NO_TRANS); mi; ++mi)</a>
<a name="ln6603">        {</a>
<a name="ln6604">            if (*mi == mons)</a>
<a name="ln6605">                continue;</a>
<a name="ln6606">            if (_mons_can_bind_soul(mons, *mi))</a>
<a name="ln6607">            {</a>
<a name="ln6608">                mi-&gt;add_ench(</a>
<a name="ln6609">                    mon_enchant(ENCH_BOUND_SOUL, 0, mons,</a>
<a name="ln6610">                                random_range(10, 30) * BASELINE_DELAY));</a>
<a name="ln6611">            }</a>
<a name="ln6612">        }</a>
<a name="ln6613">        return;</a>
<a name="ln6614"> </a>
<a name="ln6615"> </a>
<a name="ln6616">    case SPELL_GREATER_SERVANT_MAKHLEB:</a>
<a name="ln6617">    {</a>
<a name="ln6618">        const monster_type servants[] = { MONS_EXECUTIONER, MONS_GREEN_DEATH,</a>
<a name="ln6619">                                          MONS_BLIZZARD_DEMON, MONS_BALRUG,</a>
<a name="ln6620">                                          MONS_CACODEMON };</a>
<a name="ln6621">        _summon(*mons, RANDOM_ELEMENT(servants), 5, slot);</a>
<a name="ln6622">        return;</a>
<a name="ln6623">    }</a>
<a name="ln6624"> </a>
<a name="ln6625">    case SPELL_UPHEAVAL:</a>
<a name="ln6626">        _mons_upheaval(*mons, *foe);</a>
<a name="ln6627">        return;</a>
<a name="ln6628"> </a>
<a name="ln6629">    case SPELL_SPORULATE:</a>
<a name="ln6630">    {</a>
<a name="ln6631">        mgen_data mgen (MONS_BALLISTOMYCETE_SPORE,</a>
<a name="ln6632">                mons-&gt;friendly() ? BEH_FRIENDLY : BEH_HOSTILE, mons-&gt;pos(),</a>
<a name="ln6633">                mons-&gt;foe);</a>
<a name="ln6634">        mgen.set_summoned(mons, 0, SPELL_SPORULATE);</a>
<a name="ln6635">        // Add 1HD to the spore for each additional HD the spawner has.</a>
<a name="ln6636">        mgen.hd = mons_class_hit_dice(MONS_BALLISTOMYCETE_SPORE) +</a>
<a name="ln6637">            max(0, mons-&gt;spell_hd() - mons_class_hit_dice(mons-&gt;type));</a>
<a name="ln6638"> </a>
<a name="ln6639">        if (monster* const spore = create_monster(mgen))</a>
<a name="ln6640">            spore-&gt;add_ench(ENCH_SHORT_LIVED);</a>
<a name="ln6641"> </a>
<a name="ln6642">        return;</a>
<a name="ln6643">    }</a>
<a name="ln6644"> </a>
<a name="ln6645">    }</a>
<a name="ln6646"> </a>
<a name="ln6647">    if (spell_is_direct_explosion(spell_cast))</a>
<a name="ln6648">        _fire_direct_explosion(*mons, slot, pbolt);</a>
<a name="ln6649">    else</a>
<a name="ln6650">        _fire_simple_beam(*mons, slot, pbolt);</a>
<a name="ln6651">}</a>
<a name="ln6652"> </a>
<a name="ln6653">static int _noise_level(const monster* mons, spell_type spell,</a>
<a name="ln6654">                        bool silent, mon_spell_slot_flags slot_flags)</a>
<a name="ln6655">{</a>
<a name="ln6656">    const spell_flags flags = get_spell_flags(spell);</a>
<a name="ln6657"> </a>
<a name="ln6658">    int noise;</a>
<a name="ln6659"> </a>
<a name="ln6660">    if (silent</a>
<a name="ln6661">        || (slot_flags &amp; MON_SPELL_INNATE_MASK</a>
<a name="ln6662">            &amp;&amp; !(slot_flags &amp; MON_SPELL_NOISY)</a>
<a name="ln6663">            &amp;&amp; !(flags &amp; spflag::noisy)))</a>
<a name="ln6664">    {</a>
<a name="ln6665">        noise = 0;</a>
<a name="ln6666">    }</a>
<a name="ln6667">    else if (mons_genus(mons-&gt;type) == MONS_DRAGON)</a>
<a name="ln6668">        noise = get_shout_noise_level(S_LOUD_ROAR);</a>
<a name="ln6669">    else</a>
<a name="ln6670">        noise = spell_noise(spell);</a>
<a name="ln6671"> </a>
<a name="ln6672">    return noise;</a>
<a name="ln6673">}</a>
<a name="ln6674"> </a>
<a name="ln6675">static void _speech_keys(vector&lt;string&gt;&amp; key_list,</a>
<a name="ln6676">                         const monster* mons, const bolt&amp; pbolt,</a>
<a name="ln6677">                         spell_type spell, mon_spell_slot_flags slot_flags,</a>
<a name="ln6678">                         bool targeted)</a>
<a name="ln6679">{</a>
<a name="ln6680">    const string cast_str = &quot; cast&quot;;</a>
<a name="ln6681"> </a>
<a name="ln6682">    // Can't use copy-initialization 'wizard = slot_flags &amp; ...' here,</a>
<a name="ln6683">    // because the bitfield-to-bool conversion is not implicit.</a>
<a name="ln6684">    const bool wizard  {slot_flags &amp; MON_SPELL_WIZARD};</a>
<a name="ln6685">    const bool priest  {slot_flags &amp; MON_SPELL_PRIEST};</a>
<a name="ln6686">    const bool natural {slot_flags &amp; MON_SPELL_NATURAL};</a>
<a name="ln6687">    const bool magical {slot_flags &amp; MON_SPELL_MAGICAL};</a>
<a name="ln6688"> </a>
<a name="ln6689">    const mon_body_shape shape = get_mon_shape(*mons);</a>
<a name="ln6690">    const string    spell_name = spell_title(spell);</a>
<a name="ln6691">    const bool      real_spell = priest || wizard;</a>
<a name="ln6692"> </a>
<a name="ln6693">    // Before just using generic per-spell and per-monster casts, try</a>
<a name="ln6694">    // per-monster, per-spell, with the monster type name, then the</a>
<a name="ln6695">    // species name, then the genus name, then wizard/priest/magical/natural.</a>
<a name="ln6696">    // We don't include &quot;real&quot; or &quot;gestures&quot; here since that can be</a>
<a name="ln6697">    // be determined from the monster type; or &quot;targeted&quot; since that</a>
<a name="ln6698">    // can be determined from the spell.</a>
<a name="ln6699">    key_list.push_back(spell_name + &quot; &quot;</a>
<a name="ln6700">                       + mons_type_name(mons-&gt;type, DESC_PLAIN) + cast_str);</a>
<a name="ln6701">    key_list.push_back(spell_name + &quot; &quot;</a>
<a name="ln6702">                       + mons_type_name(mons_species(mons-&gt;type), DESC_PLAIN)</a>
<a name="ln6703">                       + cast_str);</a>
<a name="ln6704">    key_list.push_back(spell_name + &quot; &quot;</a>
<a name="ln6705">                       + mons_type_name(mons_genus(mons-&gt;type), DESC_PLAIN)</a>
<a name="ln6706">                       + cast_str);</a>
<a name="ln6707">    if (wizard)</a>
<a name="ln6708">    {</a>
<a name="ln6709">        key_list.push_back(make_stringf(&quot;%s %swizard%s&quot;,</a>
<a name="ln6710">                               spell_name.c_str(),</a>
<a name="ln6711">                               mon_shape_is_humanoid(shape) ? &quot;&quot;</a>
<a name="ln6712">                                                            : &quot;non-humanoid &quot;,</a>
<a name="ln6713">                               cast_str.c_str()));</a>
<a name="ln6714">    }</a>
<a name="ln6715">    else if (priest)</a>
<a name="ln6716">        key_list.push_back(spell_name + &quot; priest&quot; + cast_str);</a>
<a name="ln6717">    else if (magical)</a>
<a name="ln6718">        key_list.push_back(spell_name + &quot; magical&quot; + cast_str);</a>
<a name="ln6719">    else if (natural)</a>
<a name="ln6720">        key_list.push_back(spell_name + &quot; natural&quot; + cast_str);</a>
<a name="ln6721"> </a>
<a name="ln6722"> </a>
<a name="ln6723">    // Now try just the spell's name.</a>
<a name="ln6724">    if (mon_shape_is_humanoid(shape))</a>
<a name="ln6725">    {</a>
<a name="ln6726">        if (real_spell)</a>
<a name="ln6727">            key_list.push_back(spell_name + cast_str + &quot; real&quot;);</a>
<a name="ln6728">        if (mons_intel(*mons) &gt;= I_HUMAN)</a>
<a name="ln6729">            key_list.push_back(spell_name + cast_str + &quot; gestures&quot;);</a>
<a name="ln6730">    }</a>
<a name="ln6731"> </a>
<a name="ln6732">    key_list.push_back(spell_name + cast_str);</a>
<a name="ln6733"> </a>
<a name="ln6734">    // Only postfix &quot;targeted&quot; after this point.</a>
<a name="ln6735">    const unsigned int num_spell_keys = key_list.size();</a>
<a name="ln6736"> </a>
<a name="ln6737">    // Next the monster type name, then species name, then genus name.</a>
<a name="ln6738">    key_list.push_back(mons_type_name(mons-&gt;type, DESC_PLAIN) + cast_str);</a>
<a name="ln6739">    key_list.push_back(mons_type_name(mons_species(mons-&gt;type), DESC_PLAIN)</a>
<a name="ln6740">                       + cast_str);</a>
<a name="ln6741">    key_list.push_back(mons_type_name(mons_genus(mons-&gt;type), DESC_PLAIN)</a>
<a name="ln6742">                       + cast_str);</a>
<a name="ln6743"> </a>
<a name="ln6744">    // Last, generic wizard, priest or magical.</a>
<a name="ln6745">    if (wizard)</a>
<a name="ln6746">    {</a>
<a name="ln6747">        key_list.push_back(make_stringf(&quot;%swizard%s&quot;,</a>
<a name="ln6748">                               mon_shape_is_humanoid(shape) ? &quot;&quot;</a>
<a name="ln6749">                                                            : &quot;non-humanoid &quot;,</a>
<a name="ln6750">                               cast_str.c_str()));</a>
<a name="ln6751">    }</a>
<a name="ln6752">    else if (priest)</a>
<a name="ln6753">        key_list.push_back(&quot;priest&quot; + cast_str);</a>
<a name="ln6754">    else if (magical)</a>
<a name="ln6755">        key_list.push_back(&quot;magical&quot; + cast_str);</a>
<a name="ln6756"> </a>
<a name="ln6757">    if (targeted)</a>
<a name="ln6758">    {</a>
<a name="ln6759">        // For targeted spells, try with the targeted suffix first.</a>
<a name="ln6760">        for (unsigned int i = key_list.size() - 1; i &gt;= num_spell_keys; i--)</a>
<a name="ln6761">        {</a>
<a name="ln6762">            string str = key_list[i] + &quot; targeted&quot;;</a>
<a name="ln6763">            key_list.insert(key_list.begin() + i, str);</a>
<a name="ln6764">        }</a>
<a name="ln6765"> </a>
<a name="ln6766">        // Generic beam messages.</a>
<a name="ln6767">        if (pbolt.visible())</a>
<a name="ln6768">        {</a>
<a name="ln6769">            key_list.push_back(pbolt.get_short_name() + &quot; beam &quot; + cast_str);</a>
<a name="ln6770">            key_list.emplace_back(&quot;beam catchall cast&quot;);</a>
<a name="ln6771">        }</a>
<a name="ln6772">    }</a>
<a name="ln6773">}</a>
<a name="ln6774"> </a>
<a name="ln6775">static string _speech_message(const vector&lt;string&gt;&amp; key_list,</a>
<a name="ln6776">                              bool silent, bool unseen)</a>
<a name="ln6777">{</a>
<a name="ln6778">    string prefix;</a>
<a name="ln6779">    if (silent)</a>
<a name="ln6780">        prefix = &quot;silent &quot;;</a>
<a name="ln6781">    else if (unseen)</a>
<a name="ln6782">        prefix = &quot;unseen &quot;;</a>
<a name="ln6783"> </a>
<a name="ln6784">    string msg;</a>
<a name="ln6785">    for (const string &amp;key : key_list)</a>
<a name="ln6786">    {</a>
<a name="ln6787">#ifdef DEBUG_MONSPEAK</a>
<a name="ln6788">        dprf(DIAG_SPEECH, &quot;monster casting lookup: %s%s&quot;,</a>
<a name="ln6789">             prefix.c_str(), key.c_str());</a>
<a name="ln6790">#endif</a>
<a name="ln6791"> </a>
<a name="ln6792">        msg = getSpeakString(prefix + key);</a>
<a name="ln6793">        if (msg == &quot;__NONE&quot;)</a>
<a name="ln6794">        {</a>
<a name="ln6795">            msg = &quot;&quot;;</a>
<a name="ln6796">            break;</a>
<a name="ln6797">        }</a>
<a name="ln6798">        else if (!msg.empty())</a>
<a name="ln6799">            break;</a>
<a name="ln6800"> </a>
<a name="ln6801">        // If we got no message and we're using the silent prefix, then</a>
<a name="ln6802">        // try again without the prefix.</a>
<a name="ln6803">        if (prefix != &quot;silent &quot;)</a>
<a name="ln6804">            continue;</a>
<a name="ln6805"> </a>
<a name="ln6806">        msg = getSpeakString(key);</a>
<a name="ln6807">        if (msg == &quot;__NONE&quot;)</a>
<a name="ln6808">        {</a>
<a name="ln6809">            msg = &quot;&quot;;</a>
<a name="ln6810">            break;</a>
<a name="ln6811">        }</a>
<a name="ln6812">        else if (!msg.empty())</a>
<a name="ln6813">            break;</a>
<a name="ln6814">    }</a>
<a name="ln6815"> </a>
<a name="ln6816">    return msg;</a>
<a name="ln6817">}</a>
<a name="ln6818"> </a>
<a name="ln6819">static void _speech_fill_target(string&amp; targ_prep, string&amp; target,</a>
<a name="ln6820">                                const monster* mons, const bolt&amp; pbolt,</a>
<a name="ln6821">                                bool gestured)</a>
<a name="ln6822">{</a>
<a name="ln6823">    targ_prep = &quot;at&quot;;</a>
<a name="ln6824">    target    = &quot;nothing&quot;;</a>
<a name="ln6825"> </a>
<a name="ln6826">    bolt tracer = pbolt;</a>
<a name="ln6827">    // For a targeted but rangeless spell make the range positive so that</a>
<a name="ln6828">    // fire_tracer() will fill out path_taken.</a>
<a name="ln6829">    if (pbolt.range == 0 &amp;&amp; pbolt.target != mons-&gt;pos())</a>
<a name="ln6830">        tracer.range = ENV_SHOW_DIAMETER;</a>
<a name="ln6831">    fire_tracer(mons, tracer);</a>
<a name="ln6832"> </a>
<a name="ln6833">    if (pbolt.target == you.pos())</a>
<a name="ln6834">        target = &quot;you&quot;;</a>
<a name="ln6835">    else if (pbolt.target == mons-&gt;pos())</a>
<a name="ln6836">        target = mons-&gt;pronoun(PRONOUN_REFLEXIVE);</a>
<a name="ln6837">    // Monsters should only use targeted spells while foe == MHITNOT</a>
<a name="ln6838">    // if they're targeting themselves.</a>
<a name="ln6839">    else if (mons-&gt;foe == MHITNOT &amp;&amp; !mons_is_confused(*mons, true))</a>
<a name="ln6840">        target = &quot;NONEXISTENT FOE&quot;;</a>
<a name="ln6841">    else if (!invalid_monster_index(mons-&gt;foe)</a>
<a name="ln6842">             &amp;&amp; menv[mons-&gt;foe].type == MONS_NO_MONSTER)</a>
<a name="ln6843">    {</a>
<a name="ln6844">        target = &quot;DEAD FOE&quot;;</a>
<a name="ln6845">    }</a>
<a name="ln6846">    else if (in_bounds(pbolt.target) &amp;&amp; you.see_cell(pbolt.target))</a>
<a name="ln6847">    {</a>
<a name="ln6848">        if (const monster* mtarg = monster_at(pbolt.target))</a>
<a name="ln6849">        {</a>
<a name="ln6850">            if (you.can_see(*mtarg))</a>
<a name="ln6851">                target = mtarg-&gt;name(DESC_THE);</a>
<a name="ln6852">        }</a>
<a name="ln6853">    }</a>
<a name="ln6854"> </a>
<a name="ln6855">    const bool visible_path      = pbolt.visible() || gestured;</a>
<a name="ln6856"> </a>
<a name="ln6857">    // Monster might be aiming past the real target, or maybe some fuzz has</a>
<a name="ln6858">    // been applied because the target is invisible.</a>
<a name="ln6859">    if (target == &quot;nothing&quot;)</a>
<a name="ln6860">    {</a>
<a name="ln6861">        if (pbolt.aimed_at_spot || pbolt.origin_spell == SPELL_DIG)</a>
<a name="ln6862">        {</a>
<a name="ln6863">            int count = 0;</a>
<a name="ln6864">            for (adjacent_iterator ai(pbolt.target); ai; ++ai)</a>
<a name="ln6865">            {</a>
<a name="ln6866">                const actor* act = actor_at(*ai);</a>
<a name="ln6867">                if (act &amp;&amp; act != mons &amp;&amp; you.can_see(*act))</a>
<a name="ln6868">                {</a>
<a name="ln6869">                    targ_prep = &quot;next to&quot;;</a>
<a name="ln6870"> </a>
<a name="ln6871">                    if (act-&gt;is_player() || one_chance_in(++count))</a>
<a name="ln6872">                        target = act-&gt;name(DESC_THE);</a>
<a name="ln6873"> </a>
<a name="ln6874">                    if (act-&gt;is_player())</a>
<a name="ln6875">                        break;</a>
<a name="ln6876">                }</a>
<a name="ln6877">            }</a>
<a name="ln6878"> </a>
<a name="ln6879">            if (targ_prep == &quot;at&quot;)</a>
<a name="ln6880">            {</a>
<a name="ln6881">                if (grd(pbolt.target) != DNGN_FLOOR)</a>
<a name="ln6882">                {</a>
<a name="ln6883">                    target = feature_description(grd(pbolt.target),</a>
<a name="ln6884">                                                 NUM_TRAPS, &quot;&quot;, DESC_THE);</a>
<a name="ln6885">                }</a>
<a name="ln6886">                else</a>
<a name="ln6887">                    target = &quot;thin air&quot;;</a>
<a name="ln6888">            }</a>
<a name="ln6889"> </a>
<a name="ln6890">            return;</a>
<a name="ln6891">        }</a>
<a name="ln6892"> </a>
<a name="ln6893">        bool mons_targ_aligned = false;</a>
<a name="ln6894"> </a>
<a name="ln6895">        for (const coord_def pos : tracer.path_taken)</a>
<a name="ln6896">        {</a>
<a name="ln6897">            if (pos == mons-&gt;pos())</a>
<a name="ln6898">                continue;</a>
<a name="ln6899"> </a>
<a name="ln6900">            const monster* m = monster_at(pos);</a>
<a name="ln6901">            if (pos == you.pos())</a>
<a name="ln6902">            {</a>
<a name="ln6903">                // Be egotistical and assume that the monster is aiming at</a>
<a name="ln6904">                // the player, rather than the player being in the path of</a>
<a name="ln6905">                // a beam aimed at an ally.</a>
<a name="ln6906">                if (!mons-&gt;wont_attack())</a>
<a name="ln6907">                {</a>
<a name="ln6908">                    targ_prep = &quot;at&quot;;</a>
<a name="ln6909">                    target    = &quot;you&quot;;</a>
<a name="ln6910">                    break;</a>
<a name="ln6911">                }</a>
<a name="ln6912">                // If the ally is confused or aiming at an invisible enemy,</a>
<a name="ln6913">                // with the player in the path, act like it's targeted at</a>
<a name="ln6914">                // the player if there isn't any visible target earlier</a>
<a name="ln6915">                // in the path.</a>
<a name="ln6916">                else if (target == &quot;nothing&quot;)</a>
<a name="ln6917">                {</a>
<a name="ln6918">                    targ_prep         = &quot;at&quot;;</a>
<a name="ln6919">                    target            = &quot;you&quot;;</a>
<a name="ln6920">                    mons_targ_aligned = true;</a>
<a name="ln6921">                }</a>
<a name="ln6922">            }</a>
<a name="ln6923">            else if (visible_path &amp;&amp; m &amp;&amp; you.can_see(*m))</a>
<a name="ln6924">            {</a>
<a name="ln6925">                bool is_aligned  = mons_aligned(m, mons);</a>
<a name="ln6926">                string name = m-&gt;name(DESC_THE);</a>
<a name="ln6927"> </a>
<a name="ln6928">                if (target == &quot;nothing&quot;)</a>
<a name="ln6929">                {</a>
<a name="ln6930">                    mons_targ_aligned = is_aligned;</a>
<a name="ln6931">                    target            = name;</a>
<a name="ln6932">                }</a>
<a name="ln6933">                // If the first target was aligned with the beam source then</a>
<a name="ln6934">                // the first subsequent non-aligned monster in the path will</a>
<a name="ln6935">                // take it's place.</a>
<a name="ln6936">                else if (mons_targ_aligned &amp;&amp; !is_aligned)</a>
<a name="ln6937">                {</a>
<a name="ln6938">                    mons_targ_aligned = false;</a>
<a name="ln6939">                    target            = name;</a>
<a name="ln6940">                }</a>
<a name="ln6941">                targ_prep = &quot;at&quot;;</a>
<a name="ln6942">            }</a>
<a name="ln6943">            else if (visible_path &amp;&amp; target == &quot;nothing&quot;)</a>
<a name="ln6944">            {</a>
<a name="ln6945">                int count = 0;</a>
<a name="ln6946">                for (adjacent_iterator ai(pbolt.target); ai; ++ai)</a>
<a name="ln6947">                {</a>
<a name="ln6948">                    const actor* act = monster_at(*ai);</a>
<a name="ln6949">                    if (act &amp;&amp; act != mons &amp;&amp; you.can_see(*act))</a>
<a name="ln6950">                    {</a>
<a name="ln6951">                        targ_prep = &quot;past&quot;;</a>
<a name="ln6952">                        if (act-&gt;is_player()</a>
<a name="ln6953">                            || one_chance_in(++count))</a>
<a name="ln6954">                        {</a>
<a name="ln6955">                            target = act-&gt;name(DESC_THE);</a>
<a name="ln6956">                        }</a>
<a name="ln6957"> </a>
<a name="ln6958">                        if (act-&gt;is_player())</a>
<a name="ln6959">                            break;</a>
<a name="ln6960">                    }</a>
<a name="ln6961">                }</a>
<a name="ln6962">            }</a>
<a name="ln6963">        } // for (const coord_def pos : path)</a>
<a name="ln6964">    } // if (target == &quot;nothing&quot; &amp;&amp; targeted)</a>
<a name="ln6965"> </a>
<a name="ln6966">    const actor* foe = mons-&gt;get_foe();</a>
<a name="ln6967"> </a>
<a name="ln6968">    // If we still can't find what appears to be the target, and the</a>
<a name="ln6969">    // monster isn't just throwing the spell in a random direction,</a>
<a name="ln6970">    // we should be able to tell what the monster was aiming for if</a>
<a name="ln6971">    // we can see the monster's foe and the beam (or the beam path</a>
<a name="ln6972">    // implied by gesturing). But only if the beam didn't actually hit</a>
<a name="ln6973">    // anything (but if it did hit something, why didn't that monster</a>
<a name="ln6974">    // show up in the beam's path?)</a>
<a name="ln6975">    if (target == &quot;nothing&quot;</a>
<a name="ln6976">        &amp;&amp; (tracer.foe_info.count + tracer.friend_info.count) == 0</a>
<a name="ln6977">        &amp;&amp; foe != nullptr</a>
<a name="ln6978">        &amp;&amp; you.can_see(*foe)</a>
<a name="ln6979">        &amp;&amp; !mons-&gt;confused()</a>
<a name="ln6980">        &amp;&amp; visible_path)</a>
<a name="ln6981">    {</a>
<a name="ln6982">        target = foe-&gt;name(DESC_THE);</a>
<a name="ln6983">        targ_prep = (pbolt.aimed_at_spot ? &quot;next to&quot; : &quot;past&quot;);</a>
<a name="ln6984">    }</a>
<a name="ln6985"> </a>
<a name="ln6986">    // If the monster gestures to create an invisible beam then</a>
<a name="ln6987">    // assume that anything close to the beam is the intended target.</a>
<a name="ln6988">    // Also, if the monster gestures to create a visible beam but it</a>
<a name="ln6989">    // misses still say that the monster gestured &quot;at&quot; the target,</a>
<a name="ln6990">    // rather than &quot;past&quot;.</a>
<a name="ln6991">    if (gestured || target == &quot;nothing&quot;)</a>
<a name="ln6992">        targ_prep = &quot;at&quot;;</a>
<a name="ln6993"> </a>
<a name="ln6994">    // &quot;throws whatever at something&quot; is better than &quot;at nothing&quot;</a>
<a name="ln6995">    if (target == &quot;nothing&quot;)</a>
<a name="ln6996">        target = &quot;something&quot;;</a>
<a name="ln6997">}</a>
<a name="ln6998"> </a>
<a name="ln6999">void mons_cast_noise(monster* mons, const bolt &amp;pbolt,</a>
<a name="ln7000">                     spell_type spell_cast, mon_spell_slot_flags slot_flags)</a>
<a name="ln7001">{</a>
<a name="ln7002">    bool force_silent = false;</a>
<a name="ln7003"> </a>
<a name="ln7004">    if (mons-&gt;type == MONS_SHADOW_DRAGON)</a>
<a name="ln7005">        // Draining breath is silent.</a>
<a name="ln7006">        force_silent = true;</a>
<a name="ln7007"> </a>
<a name="ln7008">    const bool unseen    = !you.can_see(*mons);</a>
<a name="ln7009">    const bool silent    = silenced(mons-&gt;pos()) || force_silent;</a>
<a name="ln7010"> </a>
<a name="ln7011">    if (unseen &amp;&amp; silent)</a>
<a name="ln7012">        return;</a>
<a name="ln7013"> </a>
<a name="ln7014">    int noise = _noise_level(mons, spell_cast, silent, slot_flags);</a>
<a name="ln7015"> </a>
<a name="ln7016">    const spell_flags spflags = get_spell_flags(spell_cast);</a>
<a name="ln7017">    const bool targeted = (spflags &amp; spflag::targeting_mask)</a>
<a name="ln7018">                           &amp;&amp; (pbolt.target != mons-&gt;pos()</a>
<a name="ln7019">                               || pbolt.visible());</a>
<a name="ln7020"> </a>
<a name="ln7021">    vector&lt;string&gt; key_list;</a>
<a name="ln7022">    _speech_keys(key_list, mons, pbolt, spell_cast, slot_flags, targeted);</a>
<a name="ln7023"> </a>
<a name="ln7024">    string msg = _speech_message(key_list, silent, unseen);</a>
<a name="ln7025"> </a>
<a name="ln7026">    if (msg.empty())</a>
<a name="ln7027">    {</a>
<a name="ln7028">        if (silent)</a>
<a name="ln7029">            return;</a>
<a name="ln7030"> </a>
<a name="ln7031">        noisy(noise, mons-&gt;pos(), mons-&gt;mid);</a>
<a name="ln7032">        return;</a>
<a name="ln7033">    }</a>
<a name="ln7034"> </a>
<a name="ln7035">    // FIXME: we should not need to look at the message text.</a>
<a name="ln7036">    const bool gestured = msg.find(&quot;Gesture&quot;) != string::npos</a>
<a name="ln7037">                          || msg.find(&quot; gesture&quot;) != string::npos</a>
<a name="ln7038">                          || msg.find(&quot;Point&quot;) != string::npos</a>
<a name="ln7039">                          || msg.find(&quot; point&quot;) != string::npos;</a>
<a name="ln7040"> </a>
<a name="ln7041">    string targ_prep = &quot;at&quot;;</a>
<a name="ln7042">    string target    = &quot;NO_TARGET&quot;;</a>
<a name="ln7043"> </a>
<a name="ln7044">    if (targeted)</a>
<a name="ln7045">        _speech_fill_target(targ_prep, target, mons, pbolt, gestured);</a>
<a name="ln7046"> </a>
<a name="ln7047">    msg = replace_all(msg, &quot;@at@&quot;,     targ_prep);</a>
<a name="ln7048">    msg = replace_all(msg, &quot;@target@&quot;, target);</a>
<a name="ln7049"> </a>
<a name="ln7050">    string beam_name;</a>
<a name="ln7051">    if (!targeted)</a>
<a name="ln7052">        beam_name = &quot;NON TARGETED BEAM&quot;;</a>
<a name="ln7053">    else if (pbolt.name.empty())</a>
<a name="ln7054">        beam_name = &quot;INVALID BEAM&quot;;</a>
<a name="ln7055">    else</a>
<a name="ln7056">        beam_name = pbolt.get_short_name();</a>
<a name="ln7057"> </a>
<a name="ln7058">    msg = replace_all(msg, &quot;@beam@&quot;, beam_name);</a>
<a name="ln7059"> </a>
<a name="ln7060">    const msg_channel_type chan =</a>
<a name="ln7061">        (unseen              ? MSGCH_SOUND :</a>
<a name="ln7062">         mons-&gt;friendly()    ? MSGCH_FRIEND_SPELL</a>
<a name="ln7063">                             : MSGCH_MONSTER_SPELL);</a>
<a name="ln7064"> </a>
<a name="ln7065">    if (silent || noise == 0)</a>
<a name="ln7066">        mons_speaks_msg(mons, msg, chan, true);</a>
<a name="ln7067">    else if (noisy(noise, mons-&gt;pos(), mons-&gt;mid) || !unseen)</a>
<a name="ln7068">    {</a>
<a name="ln7069">        // noisy() returns true if the player heard the noise.</a>
<a name="ln7070">        mons_speaks_msg(mons, msg, chan);</a>
<a name="ln7071">    }</a>
<a name="ln7072">}</a>
<a name="ln7073"> </a>
<a name="ln7074">static const int MIN_THROW_DIST = 2;</a>
<a name="ln7075"> </a>
<a name="ln7076">static bool _valid_throw_dest(const actor &amp;thrower, const actor &amp;victim,</a>
<a name="ln7077">                              const coord_def pos)</a>
<a name="ln7078">{</a>
<a name="ln7079">    return thrower.pos().distance_from(pos) &gt;= MIN_THROW_DIST</a>
<a name="ln7080">           &amp;&amp; !actor_at(pos)</a>
<a name="ln7081">           &amp;&amp; victim.is_habitable(pos)</a>
<a name="ln7082">           &amp;&amp; thrower.see_cell(pos);</a>
<a name="ln7083">}</a>
<a name="ln7084"> </a>
<a name="ln7085">/**</a>
<a name="ln7086"> * Choose a landing site for a monster that is throwing someone.</a>
<a name="ln7087"> *</a>
<a name="ln7088"> * @param thrower      The monster performing the toss.</a>
<a name="ln7089"> * @param victim       The actor being thrown.</a>
<a name="ln7090"> * @param rater        A function that takes thrower, victim, and an arbitrary</a>
<a name="ln7091"> *                     coord_def and determines how good the throw is; a higher</a>
<a name="ln7092"> *                     number is better.</a>
<a name="ln7093"> * @return             The coord_def of one of the best (as determined by rater)</a>
<a name="ln7094"> *                     possible landing sites for a toss.</a>
<a name="ln7095"> *                     If no valid site is found, returns the origin (0,0).</a>
<a name="ln7096"> */</a>
<a name="ln7097">static coord_def _choose_throwing_target(const monster &amp;thrower,</a>
<a name="ln7098">                            const actor &amp;victim,</a>
<a name="ln7099">                            function&lt;int (const monster&amp;, const actor&amp;,</a>
<a name="ln7100">                                          coord_def)&gt; rater)</a>
<a name="ln7101">{</a>
<a name="ln7102">    int best_site_score = -1;</a>
<a name="ln7103">    vector&lt;coord_def&gt; best_sites;</a>
<a name="ln7104"> </a>
<a name="ln7105">    for (distance_iterator di(thrower.pos(), true, true, LOS_RADIUS); di; ++di)</a>
<a name="ln7106">    {</a>
<a name="ln7107">        ray_def ray;</a>
<a name="ln7108">        // Unusable landing sites.</a>
<a name="ln7109">        if (!_valid_throw_dest(thrower, victim, *di)</a>
<a name="ln7110">            || !find_ray(thrower.pos(), *di, ray, opc_solid_see))</a>
<a name="ln7111">        {</a>
<a name="ln7112">            continue;</a>
<a name="ln7113">        }</a>
<a name="ln7114"> </a>
<a name="ln7115">        const int site_score = rater(thrower, victim, *di);</a>
<a name="ln7116">        if (site_score &gt; best_site_score)</a>
<a name="ln7117">        {</a>
<a name="ln7118">            best_site_score = site_score;</a>
<a name="ln7119">            best_sites.clear();</a>
<a name="ln7120">        }</a>
<a name="ln7121">        if (site_score == best_site_score)</a>
<a name="ln7122">            best_sites.push_back(*di);</a>
<a name="ln7123">    }</a>
<a name="ln7124"> </a>
<a name="ln7125">    // No valid landing site found.</a>
<a name="ln7126">    if (!best_sites.size())</a>
<a name="ln7127">        return coord_def(0,0);</a>
<a name="ln7128"> </a>
<a name="ln7129">    const coord_def best_site = best_sites[random2(best_sites.size())];</a>
<a name="ln7130">    return best_site;</a>
<a name="ln7131">}</a>
<a name="ln7132"> </a>
<a name="ln7133">static bool _will_throw_ally(const monster&amp; thrower, const monster&amp; throwee)</a>
<a name="ln7134">{</a>
<a name="ln7135">    switch (thrower.type)</a>
<a name="ln7136">    {</a>
<a name="ln7137">    case MONS_ROBIN:</a>
<a name="ln7138">        return throwee.mons_species() == MONS_GOBLIN;</a>
<a name="ln7139">    case MONS_POLYPHEMUS:</a>
<a name="ln7140">        return mons_genus(throwee.type) == MONS_YAK;</a>
<a name="ln7141">    case MONS_IRON_GIANT:</a>
<a name="ln7142">        return !mons_is_conjured(throwee.type);</a>
<a name="ln7143">    default:</a>
<a name="ln7144">        return false;</a>
<a name="ln7145">    }</a>
<a name="ln7146">}</a>
<a name="ln7147"> </a>
<a name="ln7148">static monster* _find_ally_to_throw(const monster &amp;mons)</a>
<a name="ln7149">{</a>
<a name="ln7150">    const actor *foe = mons.get_foe();</a>
<a name="ln7151">    if (!foe)</a>
<a name="ln7152">        return nullptr;</a>
<a name="ln7153"> </a>
<a name="ln7154">    int furthest_dist = -1;</a>
<a name="ln7155"> </a>
<a name="ln7156">    monster* best = nullptr;</a>
<a name="ln7157">    for (fair_adjacent_iterator ai(mons.pos(), true); ai; ++ai)</a>
<a name="ln7158">    {</a>
<a name="ln7159">        monster* throwee = monster_at(*ai);</a>
<a name="ln7160"> </a>
<a name="ln7161">        if (!throwee || !throwee-&gt;alive() || !mons_aligned(&amp;mons, throwee)</a>
<a name="ln7162">            || !_will_throw_ally(mons, *throwee))</a>
<a name="ln7163">        {</a>
<a name="ln7164">            continue;</a>
<a name="ln7165">        }</a>
<a name="ln7166"> </a>
<a name="ln7167">        // Don't try to throw anything constricted.</a>
<a name="ln7168">        if (throwee-&gt;is_constricted())</a>
<a name="ln7169">            continue;</a>
<a name="ln7170"> </a>
<a name="ln7171">        // otherwise throw whoever's furthest from our target.</a>
<a name="ln7172">        const int dist = grid_distance(throwee-&gt;pos(), foe-&gt;pos());</a>
<a name="ln7173">        if (dist &gt; furthest_dist)</a>
<a name="ln7174">        {</a>
<a name="ln7175">            best = throwee;</a>
<a name="ln7176">            furthest_dist = dist;</a>
<a name="ln7177">        }</a>
<a name="ln7178">    }</a>
<a name="ln7179"> </a>
<a name="ln7180">    if (best != nullptr)</a>
<a name="ln7181">        dprf(&quot;found a monster to toss&quot;);</a>
<a name="ln7182">    else</a>
<a name="ln7183">        dprf(&quot;couldn't find anyone to toss&quot;);</a>
<a name="ln7184">    return best;</a>
<a name="ln7185">}</a>
<a name="ln7186"> </a>
<a name="ln7187">/**</a>
<a name="ln7188"> * Toss an ally at the monster's foe, landing them in the given square after</a>
<a name="ln7189"> * maybe dealing a pittance of damage.</a>
<a name="ln7190"> *</a>
<a name="ln7191"> * XXX: some duplication with tentacle toss code</a>
<a name="ln7192"> *</a>
<a name="ln7193"> * @param thrower       The monster doing the throwing.</a>
<a name="ln7194"> * @param throwee       The monster being tossed.</a>
<a name="ln7195"> * @param chosen_dest   The location of the square throwee should land on.</a>
<a name="ln7196"> */</a>
<a name="ln7197">static void _throw_ally_to(const monster &amp;thrower, monster &amp;throwee,</a>
<a name="ln7198">                           const coord_def chosen_dest)</a>
<a name="ln7199">{</a>
<a name="ln7200">    ASSERT_IN_BOUNDS(chosen_dest);</a>
<a name="ln7201">    ASSERT(!throwee.is_constricted());</a>
<a name="ln7202"> </a>
<a name="ln7203">    actor* foe = thrower.get_foe();</a>
<a name="ln7204">    ASSERT(foe);</a>
<a name="ln7205"> </a>
<a name="ln7206">    const coord_def old_pos = throwee.pos();</a>
<a name="ln7207">    const bool thrower_seen = you.can_see(thrower);</a>
<a name="ln7208">    const bool throwee_was_seen = you.can_see(throwee);</a>
<a name="ln7209">    const bool throwee_will_be_seen = throwee.visible_to(&amp;you)</a>
<a name="ln7210">                                      &amp;&amp; you.see_cell(chosen_dest);</a>
<a name="ln7211">    const bool throwee_seen = throwee_was_seen || throwee_will_be_seen;</a>
<a name="ln7212"> </a>
<a name="ln7213">    if (!(throwee.flags &amp; MF_WAS_IN_VIEW))</a>
<a name="ln7214">        throwee.seen_context = SC_THROWN_IN;</a>
<a name="ln7215"> </a>
<a name="ln7216">    if (thrower_seen || throwee_seen)</a>
<a name="ln7217">    {</a>
<a name="ln7218">        const string destination = you.can_see(*foe) ?</a>
<a name="ln7219">                                   make_stringf(&quot;at %s&quot;,</a>
<a name="ln7220">                                                foe-&gt;name(DESC_THE).c_str()) :</a>
<a name="ln7221">                                   &quot;out of sight&quot;;</a>
<a name="ln7222"> </a>
<a name="ln7223">        mprf(&quot;%s throws %s %s!&quot;,</a>
<a name="ln7224">             (thrower_seen ? thrower.name(DESC_THE).c_str() : &quot;Something&quot;),</a>
<a name="ln7225">             (throwee_seen ? throwee.name(DESC_THE, true).c_str() : &quot;something&quot;),</a>
<a name="ln7226">             destination.c_str());</a>
<a name="ln7227"> </a>
<a name="ln7228">        bolt beam;</a>
<a name="ln7229">        beam.range   = INFINITE_DISTANCE;</a>
<a name="ln7230">        beam.hit     = AUTOMATIC_HIT;</a>
<a name="ln7231">        beam.flavour = BEAM_VISUAL;</a>
<a name="ln7232">        beam.source  = thrower.pos();</a>
<a name="ln7233">        beam.target  = chosen_dest;</a>
<a name="ln7234">        beam.glyph   = mons_char(throwee.type);</a>
<a name="ln7235">        const monster_info mi(&amp;throwee);</a>
<a name="ln7236">        beam.colour  = mi.colour();</a>
<a name="ln7237"> </a>
<a name="ln7238">        beam.draw_delay = 30; // Make beam animation somewhat slower than normal.</a>
<a name="ln7239">        beam.aimed_at_spot = true;</a>
<a name="ln7240">        beam.fire();</a>
<a name="ln7241">    }</a>
<a name="ln7242"> </a>
<a name="ln7243">    throwee.move_to_pos(chosen_dest);</a>
<a name="ln7244">    throwee.apply_location_effects(old_pos);</a>
<a name="ln7245">    throwee.check_redraw(old_pos);</a>
<a name="ln7246"> </a>
<a name="ln7247">    const string killed_by = make_stringf(&quot;Hit by %s thrown by %s&quot;,</a>
<a name="ln7248">                                          throwee.name(DESC_A, true).c_str(),</a>
<a name="ln7249">                                          thrower.name(DESC_PLAIN, true).c_str());</a>
<a name="ln7250">    const int dam = foe-&gt;apply_ac(random2(thrower.get_hit_dice() * 2));</a>
<a name="ln7251">    foe-&gt;hurt(&amp;thrower, dam, BEAM_NONE, KILLED_BY_BEAM, &quot;&quot;, killed_by, true);</a>
<a name="ln7252"> </a>
<a name="ln7253">    // wake sleepy goblins</a>
<a name="ln7254">    behaviour_event(&amp;throwee, ME_DISTURB, &amp;thrower, throwee.pos());</a>
<a name="ln7255">}</a>
<a name="ln7256"> </a>
<a name="ln7257">static int _throw_ally_site_score(const monster&amp; thrower, const actor&amp; /*throwee*/,</a>
<a name="ln7258">                                  coord_def pos)</a>
<a name="ln7259">{</a>
<a name="ln7260">    const actor *foe = thrower.get_foe();</a>
<a name="ln7261">    if (!foe || !adjacent(foe-&gt;pos(), pos))</a>
<a name="ln7262">        return -2;</a>
<a name="ln7263">    return grid_distance(thrower.pos(), pos);</a>
<a name="ln7264">}</a>
<a name="ln7265"> </a>
<a name="ln7266">static void _maybe_throw_ally(const monster &amp;mons)</a>
<a name="ln7267">{</a>
<a name="ln7268">    monster* throwee = _find_ally_to_throw(mons);</a>
<a name="ln7269">    if (!throwee)</a>
<a name="ln7270">        return;</a>
<a name="ln7271"> </a>
<a name="ln7272">    const coord_def toss_target =</a>
<a name="ln7273">        _choose_throwing_target(mons, *static_cast&lt;actor*&gt;(throwee),</a>
<a name="ln7274">                                _throw_ally_site_score);</a>
<a name="ln7275"> </a>
<a name="ln7276">    if (toss_target.origin())</a>
<a name="ln7277">        return;</a>
<a name="ln7278"> </a>
<a name="ln7279">    _throw_ally_to(mons, *throwee, toss_target);</a>
<a name="ln7280">}</a>
<a name="ln7281"> </a>
<a name="ln7282">/**</a>
<a name="ln7283"> * Check if a siren or merfolk avatar should sing its song.</a>
<a name="ln7284"> *</a>
<a name="ln7285"> * @param mons   The singing monster.</a>
<a name="ln7286"> * @param avatar Whether to use the more powerful &quot;avatar song&quot;.</a>
<a name="ln7287"> * @return       Whether the song should be sung.</a>
<a name="ln7288"> */</a>
<a name="ln7289">static bool _should_siren_sing(monster* mons, bool avatar)</a>
<a name="ln7290">{</a>
<a name="ln7291">    // Don't behold observer in the arena.</a>
<a name="ln7292">    if (crawl_state.game_is_arena())</a>
<a name="ln7293">        return false;</a>
<a name="ln7294"> </a>
<a name="ln7295">    // Don't behold player already half down or up the stairs.</a>
<a name="ln7296">    if (player_stair_delay())</a>
<a name="ln7297">    {</a>
<a name="ln7298">        dprf(&quot;Taking stairs, don't mesmerise.&quot;);</a>
<a name="ln7299">        return false;</a>
<a name="ln7300">    }</a>
<a name="ln7301"> </a>
<a name="ln7302">    // Won't sing if either of you silenced, or it's friendly,</a>
<a name="ln7303">    // confused, fleeing, or leaving the level.</a>
<a name="ln7304">    if (mons-&gt;has_ench(ENCH_CONFUSION)</a>
<a name="ln7305">        || mons_is_fleeing(*mons)</a>
<a name="ln7306">        || mons-&gt;pacified()</a>
<a name="ln7307">        || mons-&gt;friendly()</a>
<a name="ln7308">        || !player_can_hear(mons-&gt;pos()))</a>
<a name="ln7309">    {</a>
<a name="ln7310">        return false;</a>
<a name="ln7311">    }</a>
<a name="ln7312"> </a>
<a name="ln7313">    // Don't even try on berserkers. Sirens know their limits.</a>
<a name="ln7314">    // (merfolk avatars should still sing since their song has other effects)</a>
<a name="ln7315">    if (!avatar &amp;&amp; you.berserk())</a>
<a name="ln7316">        return false;</a>
<a name="ln7317"> </a>
<a name="ln7318">    // If the mer is trying to mesmerise you anew, only sing half as often.</a>
<a name="ln7319">    if (!you.beheld_by(*mons) &amp;&amp; mons-&gt;foe == MHITYOU &amp;&amp; you.can_see(*mons)</a>
<a name="ln7320">        &amp;&amp; coinflip())</a>
<a name="ln7321">    {</a>
<a name="ln7322">        return false;</a>
<a name="ln7323">    }</a>
<a name="ln7324"> </a>
<a name="ln7325">    // We can do it!</a>
<a name="ln7326">    return true;</a>
<a name="ln7327">}</a>
<a name="ln7328"> </a>
<a name="ln7329">/**</a>
<a name="ln7330"> * Have a monster attempt to cast Doom Howl.</a>
<a name="ln7331"> *</a>
<a name="ln7332"> * @param mon   The howling monster.</a>
<a name="ln7333"> */</a>
<a name="ln7334">static void _doom_howl(monster &amp;mon)</a>
<a name="ln7335">{</a>
<a name="ln7336">    mprf(&quot;%s unleashes a %s howl, and it begins to echo in your mind!&quot;,</a>
<a name="ln7337">         mon.name(DESC_THE).c_str(),</a>
<a name="ln7338">         silenced(mon.pos()) ? &quot;silent&quot; : &quot;terrible&quot;);</a>
<a name="ln7339">    you.duration[DUR_DOOM_HOWL] = random_range(120, 180);</a>
<a name="ln7340">    mon.props[DOOM_HOUND_HOWLED_KEY] = true;</a>
<a name="ln7341">}</a>
<a name="ln7342"> </a>
<a name="ln7343">/**</a>
<a name="ln7344"> * Have a monster cast Awaken Earth.</a>
<a name="ln7345"> *</a>
<a name="ln7346"> * @param mon    The monster casting the spell.</a>
<a name="ln7347"> * @param target The target cell.</a>
<a name="ln7348"> */</a>
<a name="ln7349">static void _mons_awaken_earth(monster &amp;mon, const coord_def &amp;target)</a>
<a name="ln7350">{</a>
<a name="ln7351">    if (!in_bounds(target))</a>
<a name="ln7352">    {</a>
<a name="ln7353">        if (you.can_see(mon))</a>
<a name="ln7354">            canned_msg(MSG_NOTHING_HAPPENS);</a>
<a name="ln7355">        return;</a>
<a name="ln7356">    }</a>
<a name="ln7357"> </a>
<a name="ln7358">    bool seen = false;</a>
<a name="ln7359">    int count = 0;</a>
<a name="ln7360">    const int max = 1 + (mon.spell_hd(SPELL_AWAKEN_EARTH) &gt; 15)</a>
<a name="ln7361">                      + random2(mon.spell_hd(SPELL_AWAKEN_EARTH) / 7 + 1);</a>
<a name="ln7362"> </a>
<a name="ln7363">    for (fair_adjacent_iterator ai(target, false); ai; ++ai)</a>
<a name="ln7364">    {</a>
<a name="ln7365">        if (!_feat_is_awakenable(grd(*ai))</a>
<a name="ln7366">            || env.markers.property_at(*ai, MAT_ANY, &quot;veto_dig&quot;)</a>
<a name="ln7367">               == &quot;veto&quot;)</a>
<a name="ln7368">        {</a>
<a name="ln7369">            continue;</a>
<a name="ln7370">        }</a>
<a name="ln7371"> </a>
<a name="ln7372">        destroy_wall(*ai);</a>
<a name="ln7373">        if (you.see_cell(*ai))</a>
<a name="ln7374">            seen = true;</a>
<a name="ln7375"> </a>
<a name="ln7376">        if (create_monster(mgen_data(</a>
<a name="ln7377">                MONS_EARTH_ELEMENTAL, SAME_ATTITUDE((&amp;mon)), *ai, mon.foe)</a>
<a name="ln7378">                .set_summoned(&amp;mon, 2, SPELL_AWAKEN_EARTH, mon.god)))</a>
<a name="ln7379">        {</a>
<a name="ln7380">            count++;</a>
<a name="ln7381">        }</a>
<a name="ln7382"> </a>
<a name="ln7383">        if (count &gt;= max)</a>
<a name="ln7384">            break;</a>
<a name="ln7385">    }</a>
<a name="ln7386"> </a>
<a name="ln7387">    if (seen)</a>
<a name="ln7388">    {</a>
<a name="ln7389">        noisy(20, target);</a>
<a name="ln7390">        mprf(&quot;Some walls %s!&quot;,</a>
<a name="ln7391">             count &gt; 0 ? &quot;begin to move on their own&quot;</a>
<a name="ln7392">                       : &quot;crumble away&quot;);</a>
<a name="ln7393">    }</a>
<a name="ln7394">    else</a>
<a name="ln7395">        noisy(20, target, &quot;You hear rumbling.&quot;);</a>
<a name="ln7396"> </a>
<a name="ln7397">    if (!seen &amp;&amp; !count &amp;&amp; you.can_see(mon))</a>
<a name="ln7398">        canned_msg(MSG_NOTHING_HAPPENS);</a>
<a name="ln7399">}</a>
<a name="ln7400"> </a>
<a name="ln7401">/**</a>
<a name="ln7402"> * Have a siren or merfolk avatar attempt to mesmerize the player.</a>
<a name="ln7403"> *</a>
<a name="ln7404"> * @param mons   The singing monster.</a>
<a name="ln7405"> * @param avatar Whether to use the more powerful &quot;avatar song&quot;.</a>
<a name="ln7406"> */</a>
<a name="ln7407">static void _siren_sing(monster* mons, bool avatar)</a>
<a name="ln7408">{</a>
<a name="ln7409">    const msg_channel_type spl = (mons-&gt;friendly() ? MSGCH_FRIEND_SPELL</a>
<a name="ln7410">                                                       : MSGCH_MONSTER_SPELL);</a>
<a name="ln7411">    const bool already_mesmerised = you.beheld_by(*mons);</a>
<a name="ln7412"> </a>
<a name="ln7413">    noisy(LOS_DEFAULT_RANGE, mons-&gt;pos(), mons-&gt;mid);</a>
<a name="ln7414"> </a>
<a name="ln7415">    if (avatar &amp;&amp; !mons-&gt;has_ench(ENCH_MERFOLK_AVATAR_SONG))</a>
<a name="ln7416">        mons-&gt;add_ench(mon_enchant(ENCH_MERFOLK_AVATAR_SONG, 0, mons, 70));</a>
<a name="ln7417"> </a>
<a name="ln7418">    if (you.can_see(*mons))</a>
<a name="ln7419">    {</a>
<a name="ln7420">        const char * const song_adj = already_mesmerised ? &quot;its luring&quot;</a>
<a name="ln7421">                                                         : &quot;a haunting&quot;;</a>
<a name="ln7422">        const string song_desc = make_stringf(&quot; chants %s song.&quot;, song_adj);</a>
<a name="ln7423">        simple_monster_message(*mons, song_desc.c_str(), spl);</a>
<a name="ln7424">    }</a>
<a name="ln7425">    else</a>
<a name="ln7426">    {</a>
<a name="ln7427">        mprf(MSGCH_SOUND, &quot;You hear %s.&quot;,</a>
<a name="ln7428">                          already_mesmerised ? &quot;a luring song&quot; :</a>
<a name="ln7429">                          coinflip()         ? &quot;a haunting song&quot;</a>
<a name="ln7430">                                             : &quot;an eerie melody&quot;);</a>
<a name="ln7431"> </a>
<a name="ln7432">        // If you're already mesmerised by an invisible siren, it</a>
<a name="ln7433">        // can still prolong the enchantment.</a>
<a name="ln7434">        if (!already_mesmerised)</a>
<a name="ln7435">            return;</a>
<a name="ln7436">    }</a>
<a name="ln7437"> </a>
<a name="ln7438">    // power is the same for siren &amp; avatar song, so just use siren</a>
<a name="ln7439">    const int pow = _ench_power(SPELL_SIREN_SONG, *mons);</a>
<a name="ln7440">    const int res_magic = you.check_res_magic(pow);</a>
<a name="ln7441"> </a>
<a name="ln7442">    // Once mesmerised by a particular monster, you cannot resist anymore.</a>
<a name="ln7443">    if (you.duration[DUR_MESMERISE_IMMUNE]</a>
<a name="ln7444">        || !already_mesmerised</a>
<a name="ln7445">           &amp;&amp; (res_magic &gt; 0 || you.clarity()))</a>
<a name="ln7446">    {</a>
<a name="ln7447">        if (you.clarity())</a>
<a name="ln7448">            canned_msg(MSG_YOU_UNAFFECTED);</a>
<a name="ln7449">        else if (you.duration[DUR_MESMERISE_IMMUNE] &amp;&amp; !already_mesmerised)</a>
<a name="ln7450">            canned_msg(MSG_YOU_RESIST);</a>
<a name="ln7451">        else</a>
<a name="ln7452">            mprf(&quot;You%s&quot;, you.resist_margin_phrase(res_magic).c_str());</a>
<a name="ln7453">        return;</a>
<a name="ln7454">    }</a>
<a name="ln7455"> </a>
<a name="ln7456">    you.add_beholder(*mons);</a>
<a name="ln7457">}</a>
<a name="ln7458"> </a>
<a name="ln7459">// Checks to see if a particular spell is worth casting in the first place.</a>
<a name="ln7460">static bool _ms_waste_of_time(monster* mon, mon_spell_slot slot)</a>
<a name="ln7461">{</a>
<a name="ln7462">    spell_type monspell = slot.spell;</a>
<a name="ln7463">    actor *foe = mon-&gt;get_foe();</a>
<a name="ln7464">    const bool friendly = mon-&gt;friendly();</a>
<a name="ln7465"> </a>
<a name="ln7466">    // Keep friendly summoners from spamming summons constantly.</a>
<a name="ln7467">    if (friendly &amp;&amp; !foe &amp;&amp; spell_typematch(monspell, spschool::summoning))</a>
<a name="ln7468">        return true;</a>
<a name="ln7469"> </a>
<a name="ln7470">    // Don't try to cast spells at players who are stepped from time.</a>
<a name="ln7471">    if (foe &amp;&amp; foe-&gt;is_player() &amp;&amp; you.duration[DUR_TIME_STEP])</a>
<a name="ln7472">        return true;</a>
<a name="ln7473"> </a>
<a name="ln7474">    if (!mon-&gt;wont_attack())</a>
<a name="ln7475">    {</a>
<a name="ln7476">        if (spell_harms_area(monspell) &amp;&amp; env.sanctuary_time &gt; 0)</a>
<a name="ln7477">            return true;</a>
<a name="ln7478"> </a>
<a name="ln7479">        if (spell_harms_target(monspell) &amp;&amp; is_sanctuary(mon-&gt;target))</a>
<a name="ln7480">            return true;</a>
<a name="ln7481">    }</a>
<a name="ln7482"> </a>
<a name="ln7483">    if (slot.flags &amp; MON_SPELL_BREATH &amp;&amp; mon-&gt;has_ench(ENCH_BREATH_WEAPON))</a>
<a name="ln7484">        return true;</a>
<a name="ln7485"> </a>
<a name="ln7486">    // Don't bother casting a summon spell if we're already at its cap</a>
<a name="ln7487">    if (summons_are_capped(monspell)</a>
<a name="ln7488">        &amp;&amp; count_summons(mon, monspell) &gt;= summons_limit(monspell))</a>
<a name="ln7489">    {</a>
<a name="ln7490">        return true;</a>
<a name="ln7491">    }</a>
<a name="ln7492"> </a>
<a name="ln7493">    const mons_spell_logic* logic = map_find(spell_to_logic, monspell);</a>
<a name="ln7494">    if (logic &amp;&amp; logic-&gt;worthwhile)</a>
<a name="ln7495">        return !logic-&gt;worthwhile(*mon);</a>
<a name="ln7496"> </a>
<a name="ln7497">    const bool no_clouds = env.level_state &amp; LSTATE_STILL_WINDS;</a>
<a name="ln7498"> </a>
<a name="ln7499">    // Eventually, we'll probably want to be able to have monsters</a>
<a name="ln7500">    // learn which of their elemental bolts were resisted and have those</a>
<a name="ln7501">    // handled here as well. - bwr</a>
<a name="ln7502">    switch (monspell)</a>
<a name="ln7503">    {</a>
<a name="ln7504">    case SPELL_CALL_TIDE:</a>
<a name="ln7505">        return !player_in_branch(BRANCH_SHOALS)</a>
<a name="ln7506">               || mon-&gt;has_ench(ENCH_TIDE)</a>
<a name="ln7507">               || !foe</a>
<a name="ln7508">               || (grd(mon-&gt;pos()) == DNGN_DEEP_WATER</a>
<a name="ln7509">                   &amp;&amp; grd(foe-&gt;pos()) == DNGN_DEEP_WATER);</a>
<a name="ln7510"> </a>
<a name="ln7511">    case SPELL_BRAIN_FEED:</a>
<a name="ln7512">        return !foe || !foe-&gt;is_player();</a>
<a name="ln7513"> </a>
<a name="ln7514">    case SPELL_BOLT_OF_DRAINING:</a>
<a name="ln7515">    case SPELL_MALIGN_OFFERING:</a>
<a name="ln7516">    case SPELL_GHOSTLY_FIREBALL:</a>
<a name="ln7517">        return !foe || _foe_should_res_negative_energy(foe);</a>
<a name="ln7518"> </a>
<a name="ln7519">    case SPELL_DEATH_RATTLE:</a>
<a name="ln7520">    case SPELL_MIASMA_BREATH:</a>
<a name="ln7521">        return !foe || foe-&gt;res_rotting() || no_clouds;</a>
<a name="ln7522"> </a>
<a name="ln7523">    case SPELL_DISPEL_UNDEAD_RANGE:</a>
<a name="ln7524">        // [ds] How is dispel undead intended to interact with vampires?</a>
<a name="ln7525">        // Currently if the vampire's undead state returns MH_UNDEAD it</a>
<a name="ln7526">        // affects the player.</a>
<a name="ln7527">        return !foe || !(foe-&gt;holiness() &amp; MH_UNDEAD);</a>
<a name="ln7528"> </a>
<a name="ln7529">    case SPELL_BERSERKER_RAGE:</a>
<a name="ln7530">        return !mon-&gt;needs_berserk(false);</a>
<a name="ln7531"> </a>
<a name="ln7532">#if TAG_MAJOR_VERSION == 34</a>
<a name="ln7533">    case SPELL_SWIFTNESS:</a>
<a name="ln7534">#endif</a>
<a name="ln7535">    case SPELL_SPRINT:</a>
<a name="ln7536">        return mon-&gt;has_ench(ENCH_SWIFT);</a>
<a name="ln7537"> </a>
<a name="ln7538">    case SPELL_MAJOR_HEALING:</a>
<a name="ln7539">        return mon-&gt;hit_points &gt; mon-&gt;max_hit_points / 2;</a>
<a name="ln7540"> </a>
<a name="ln7541">    case SPELL_BLINK_CLOSE:</a>
<a name="ln7542">        if (!foe || adjacent(mon-&gt;pos(), foe-&gt;pos()))</a>
<a name="ln7543">            return true;</a>
<a name="ln7544">        // intentional fall-through</a>
<a name="ln7545">    case SPELL_BLINK:</a>
<a name="ln7546">    case SPELL_CONTROLLED_BLINK:</a>
<a name="ln7547">    case SPELL_BLINK_RANGE:</a>
<a name="ln7548">    case SPELL_BLINK_AWAY:</a>
<a name="ln7549">        // Prefer to keep a tornado going rather than blink.</a>
<a name="ln7550">        return mon-&gt;no_tele(true, false)</a>
<a name="ln7551">               || mon-&gt;has_ench(ENCH_TORNADO)</a>
<a name="ln7552">               || mon-&gt;has_ench(ENCH_VORTEX);</a>
<a name="ln7553"> </a>
<a name="ln7554">    case SPELL_BLINK_OTHER:</a>
<a name="ln7555">    case SPELL_BLINK_OTHER_CLOSE:</a>
<a name="ln7556">        return !foe</a>
<a name="ln7557">                || foe-&gt;is_monster()</a>
<a name="ln7558">                    &amp;&amp; foe-&gt;as_monster()-&gt;has_ench(ENCH_DIMENSION_ANCHOR)</a>
<a name="ln7559">                || foe-&gt;is_player()</a>
<a name="ln7560">                    &amp;&amp; you.duration[DUR_DIMENSION_ANCHOR];</a>
<a name="ln7561"> </a>
<a name="ln7562">    case SPELL_DREAM_DUST:</a>
<a name="ln7563">        return !_foe_can_sleep(*mon);</a>
<a name="ln7564"> </a>
<a name="ln7565">    // Mara shouldn't cast player ghost if he can't see the player</a>
<a name="ln7566">    case SPELL_SUMMON_ILLUSION:</a>
<a name="ln7567">        return !foe</a>
<a name="ln7568">               || !mon-&gt;see_cell_no_trans(foe-&gt;pos())</a>
<a name="ln7569">               || !mon-&gt;can_see(*foe)</a>
<a name="ln7570">               || !actor_is_illusion_cloneable(foe);</a>
<a name="ln7571"> </a>
<a name="ln7572">    case SPELL_AWAKEN_FOREST:</a>
<a name="ln7573">        return mon-&gt;has_ench(ENCH_AWAKEN_FOREST)</a>
<a name="ln7574">               || env.forest_awoken_until &gt; you.elapsed_time</a>
<a name="ln7575">               || !forest_near_enemy(mon);</a>
<a name="ln7576"> </a>
<a name="ln7577">    case SPELL_OZOCUBUS_ARMOUR:</a>
<a name="ln7578">        return mon-&gt;is_insubstantial() || mon-&gt;has_ench(ENCH_OZOCUBUS_ARMOUR);</a>
<a name="ln7579"> </a>
<a name="ln7580">    case SPELL_BATTLESPHERE:</a>
<a name="ln7581">        return find_battlesphere(mon);</a>
<a name="ln7582"> </a>
<a name="ln7583">    case SPELL_SPECTRAL_WEAPON:</a>
<a name="ln7584">        return find_spectral_weapon(mon)</a>
<a name="ln7585">            || !weapon_can_be_spectral(mon-&gt;weapon())</a>
<a name="ln7586">            || !foe</a>
<a name="ln7587">            // Don't cast unless the caster is at or close to melee range for</a>
<a name="ln7588">            // its target. Casting spectral weapon at distance is bad since it</a>
<a name="ln7589">            // generally helps the caster's target maintain distance, also</a>
<a name="ln7590">            // letting the target exploit the spectral's damage sharing.</a>
<a name="ln7591">            || grid_distance(mon-&gt;pos(), foe-&gt;pos()) &gt; 2;</a>
<a name="ln7592"> </a>
<a name="ln7593">    case SPELL_INJURY_BOND:</a>
<a name="ln7594">        for (monster_iterator mi; mi; ++mi)</a>
<a name="ln7595">        {</a>
<a name="ln7596">            if (mons_aligned(mon, *mi) &amp;&amp; !mi-&gt;has_ench(ENCH_CHARM)</a>
<a name="ln7597">                &amp;&amp; !mi-&gt;has_ench(ENCH_HEXED)</a>
<a name="ln7598">                &amp;&amp; *mi != mon &amp;&amp; mon-&gt;see_cell_no_trans(mi-&gt;pos())</a>
<a name="ln7599">                &amp;&amp; !mi-&gt;has_ench(ENCH_INJURY_BOND))</a>
<a name="ln7600">            {</a>
<a name="ln7601">                return false; // We found at least one target; that's enough.</a>
<a name="ln7602">            }</a>
<a name="ln7603">        }</a>
<a name="ln7604">        return true;</a>
<a name="ln7605"> </a>
<a name="ln7606">    case SPELL_BLINK_ALLIES_ENCIRCLE:</a>
<a name="ln7607">        if (!foe || !mon-&gt;see_cell_no_trans(foe-&gt;pos()) || !mon-&gt;can_see(*foe))</a>
<a name="ln7608">            return true;</a>
<a name="ln7609"> </a>
<a name="ln7610">        for (monster_near_iterator mi(mon, LOS_NO_TRANS); mi; ++mi)</a>
<a name="ln7611">            if (_valid_encircle_ally(mon, *mi, foe-&gt;pos()))</a>
<a name="ln7612">                return false; // We found at least one valid ally; that's enough.</a>
<a name="ln7613">        return true;</a>
<a name="ln7614"> </a>
<a name="ln7615">    case SPELL_AWAKEN_VINES:</a>
<a name="ln7616">        return !foe</a>
<a name="ln7617">               || mon-&gt;has_ench(ENCH_AWAKEN_VINES)</a>
<a name="ln7618">                   &amp;&amp; mon-&gt;props[&quot;vines_awakened&quot;].get_int() &gt;= 3</a>
<a name="ln7619">               || !_awaken_vines(mon, true);</a>
<a name="ln7620"> </a>
<a name="ln7621">    case SPELL_WATERSTRIKE:</a>
<a name="ln7622">        return !foe || !feat_is_watery(grd(foe-&gt;pos()));</a>
<a name="ln7623"> </a>
<a name="ln7624">    // Don't use unless our foe is close to us and there are no allies already</a>
<a name="ln7625">    // between the two of us</a>
<a name="ln7626">    case SPELL_WIND_BLAST:</a>
<a name="ln7627">        if (foe &amp;&amp; foe-&gt;pos().distance_from(mon-&gt;pos()) &lt; 4)</a>
<a name="ln7628">        {</a>
<a name="ln7629">            bolt tracer;</a>
<a name="ln7630">            tracer.target = foe-&gt;pos();</a>
<a name="ln7631">            tracer.range  = LOS_RADIUS;</a>
<a name="ln7632">            tracer.hit    = AUTOMATIC_HIT;</a>
<a name="ln7633">            fire_tracer(mon, tracer);</a>
<a name="ln7634"> </a>
<a name="ln7635">            actor* act = actor_at(tracer.path_taken.back());</a>
<a name="ln7636">            if (act &amp;&amp; mons_aligned(mon, act))</a>
<a name="ln7637">                return true;</a>
<a name="ln7638">            else</a>
<a name="ln7639">                return false;</a>
<a name="ln7640">        }</a>
<a name="ln7641">        else</a>
<a name="ln7642">            return true;</a>
<a name="ln7643"> </a>
<a name="ln7644">    case SPELL_BROTHERS_IN_ARMS:</a>
<a name="ln7645">        return mon-&gt;props.exists(&quot;brothers_count&quot;)</a>
<a name="ln7646">               &amp;&amp; mon-&gt;props[&quot;brothers_count&quot;].get_int() &gt;= 2;</a>
<a name="ln7647"> </a>
<a name="ln7648">    case SPELL_HAUNT:</a>
<a name="ln7649">    case SPELL_SUMMON_SPECTRAL_ORCS:</a>
<a name="ln7650">    case SPELL_SUMMON_MUSHROOMS:</a>
<a name="ln7651">    case SPELL_ENTROPIC_WEAVE:</a>
<a name="ln7652">    case SPELL_AIRSTRIKE:</a>
<a name="ln7653">        return !foe;</a>
<a name="ln7654"> </a>
<a name="ln7655">    case SPELL_HOLY_FLAMES:</a>
<a name="ln7656">        return !foe || no_clouds;</a>
<a name="ln7657"> </a>
<a name="ln7658">    case SPELL_FREEZE:</a>
<a name="ln7659">        return !foe || !adjacent(mon-&gt;pos(), foe-&gt;pos());</a>
<a name="ln7660"> </a>
<a name="ln7661">    case SPELL_DRUIDS_CALL:</a>
<a name="ln7662">        // Don't cast unless there's at least one valid target</a>
<a name="ln7663">        for (monster_iterator mi; mi; ++mi)</a>
<a name="ln7664">            if (_valid_druids_call_target(mon, *mi))</a>
<a name="ln7665">                return false;</a>
<a name="ln7666">        return true;</a>
<a name="ln7667"> </a>
<a name="ln7668">    // Don't spam mesmerisation if you're already mesmerised</a>
<a name="ln7669">    case SPELL_MESMERISE:</a>
<a name="ln7670">        return you.beheld_by(*mon) &amp;&amp; coinflip();</a>
<a name="ln7671"> </a>
<a name="ln7672">    case SPELL_DISCHARGE:</a>
<a name="ln7673">        // TODO: possibly check for friendlies nearby?</a>
<a name="ln7674">        // Perhaps it will be used recklessly like chain lightning...</a>
<a name="ln7675">        return !foe || !adjacent(foe-&gt;pos(), mon-&gt;pos());</a>
<a name="ln7676"> </a>
<a name="ln7677">    case SPELL_PORTAL_PROJECTILE:</a>
<a name="ln7678">    {</a>
<a name="ln7679">        bolt beam;</a>
<a name="ln7680">        beam.source    = mon-&gt;pos();</a>
<a name="ln7681">        beam.target    = mon-&gt;target;</a>
<a name="ln7682">        beam.source_id = mon-&gt;mid;</a>
<a name="ln7683">        return !handle_throw(mon, beam, true, true);</a>
<a name="ln7684">    }</a>
<a name="ln7685"> </a>
<a name="ln7686">    case SPELL_FLASH_FREEZE:</a>
<a name="ln7687">        return !foe</a>
<a name="ln7688">               || foe-&gt;is_player() &amp;&amp; you.duration[DUR_FROZEN]</a>
<a name="ln7689">               || foe-&gt;is_monster()</a>
<a name="ln7690">                  &amp;&amp; foe-&gt;as_monster()-&gt;has_ench(ENCH_FROZEN);</a>
<a name="ln7691"> </a>
<a name="ln7692">    case SPELL_LEGENDARY_DESTRUCTION:</a>
<a name="ln7693">        return !foe;</a>
<a name="ln7694"> </a>
<a name="ln7695">    case SPELL_BLACK_MARK:</a>
<a name="ln7696">        return mon-&gt;has_ench(ENCH_BLACK_MARK);</a>
<a name="ln7697"> </a>
<a name="ln7698">    case SPELL_BLINK_ALLIES_AWAY:</a>
<a name="ln7699">        if (!foe || !mon-&gt;see_cell_no_trans(foe-&gt;pos()) &amp;&amp; !mon-&gt;can_see(*foe))</a>
<a name="ln7700">            return true;</a>
<a name="ln7701"> </a>
<a name="ln7702">        for (monster_near_iterator mi(mon, LOS_NO_TRANS); mi; ++mi)</a>
<a name="ln7703">            if (_valid_blink_away_ally(mon, *mi, foe-&gt;pos()))</a>
<a name="ln7704">                return false;</a>
<a name="ln7705">        return true;</a>
<a name="ln7706"> </a>
<a name="ln7707">    case SPELL_SHROUD_OF_GOLUBRIA:</a>
<a name="ln7708">        return mon-&gt;has_ench(ENCH_SHROUD);</a>
<a name="ln7709"> </a>
<a name="ln7710">    // Don't let clones duplicate anything, to prevent exponential explosion</a>
<a name="ln7711">    case SPELL_FAKE_MARA_SUMMON:</a>
<a name="ln7712">        return mon-&gt;has_ench(ENCH_PHANTOM_MIRROR);</a>
<a name="ln7713"> </a>
<a name="ln7714">    case SPELL_PHANTOM_MIRROR:</a>
<a name="ln7715">        if (!mon-&gt;has_ench(ENCH_PHANTOM_MIRROR))</a>
<a name="ln7716">        {</a>
<a name="ln7717">            for (monster_near_iterator mi(mon); mi; ++mi)</a>
<a name="ln7718">            {</a>
<a name="ln7719">                // A single valid target is enough.</a>
<a name="ln7720">                if (_mirrorable(mon, *mi))</a>
<a name="ln7721">                    return false;</a>
<a name="ln7722">            }</a>
<a name="ln7723">        }</a>
<a name="ln7724">        return true;</a>
<a name="ln7725"> </a>
<a name="ln7726">    case SPELL_THROW_BARBS:</a>
<a name="ln7727">    case SPELL_HARPOON_SHOT:</a>
<a name="ln7728">        // Don't fire barbs in melee range.</a>
<a name="ln7729">        return !foe || adjacent(mon-&gt;pos(), foe-&gt;pos());</a>
<a name="ln7730"> </a>
<a name="ln7731">    case SPELL_BATTLECRY:</a>
<a name="ln7732">        return !_battle_cry(*mon, true);</a>
<a name="ln7733"> </a>
<a name="ln7734">    case SPELL_WARNING_CRY:</a>
<a name="ln7735">        return friendly;</a>
<a name="ln7736"> </a>
<a name="ln7737">    case SPELL_CONJURE_BALL_LIGHTNING:</a>
<a name="ln7738">        return friendly</a>
<a name="ln7739">               &amp;&amp; (you.res_elec() &lt;= 0 || you.hp &lt;= 50)</a>
<a name="ln7740">               &amp;&amp; !(mon-&gt;holiness() &amp; MH_DEMONIC); // rude demons</a>
<a name="ln7741"> </a>
<a name="ln7742">    case SPELL_SEAL_DOORS:</a>
<a name="ln7743">        return friendly || !_seal_doors_and_stairs(mon, true);</a>
<a name="ln7744"> </a>
<a name="ln7745">    case SPELL_TWISTED_RESURRECTION:</a>
<a name="ln7746">        if (friendly &amp;&amp; !_animate_dead_okay(monspell))</a>
<a name="ln7747">            return true;</a>
<a name="ln7748"> </a>
<a name="ln7749">        if (mon-&gt;is_summoned() || mons_enslaved_soul(*mon))</a>
<a name="ln7750">            return true;</a>
<a name="ln7751"> </a>
<a name="ln7752">        return !twisted_resurrection(mon, 500, SAME_ATTITUDE(mon), mon-&gt;foe,</a>
<a name="ln7753">                                     mon-&gt;god, false);</a>
<a name="ln7754"> </a>
<a name="ln7755">    //XXX: unify with the other SPELL_FOO_OTHER spells?</a>
<a name="ln7756">    case SPELL_BERSERK_OTHER:</a>
<a name="ln7757">        return !_incite_monsters(mon, false);</a>
<a name="ln7758"> </a>
<a name="ln7759">    case SPELL_CAUSE_FEAR:</a>
<a name="ln7760">        return _mons_cause_fear(mon, false) &lt; 0;</a>
<a name="ln7761"> </a>
<a name="ln7762">    case SPELL_MASS_CONFUSION:</a>
<a name="ln7763">        return _mons_mass_confuse(mon, false) &lt; 0;</a>
<a name="ln7764"> </a>
<a name="ln7765">    case SPELL_THROW_ALLY:</a>
<a name="ln7766">        return !_find_ally_to_throw(*mon);</a>
<a name="ln7767"> </a>
<a name="ln7768">    case SPELL_CREATE_TENTACLES:</a>
<a name="ln7769">        return !mons_available_tentacles(mon);</a>
<a name="ln7770"> </a>
<a name="ln7771">    case SPELL_WORD_OF_RECALL:</a>
<a name="ln7772">        return !_should_recall(mon);</a>
<a name="ln7773"> </a>
<a name="ln7774">    case SPELL_SHATTER:</a>
<a name="ln7775">        return friendly || !mons_shatter(mon, false);</a>
<a name="ln7776"> </a>
<a name="ln7777">    case SPELL_SYMBOL_OF_TORMENT:</a>
<a name="ln7778">        return !_trace_los(mon, _torment_vulnerable)</a>
<a name="ln7779">               || you.visible_to(mon)</a>
<a name="ln7780">                  &amp;&amp; friendly</a>
<a name="ln7781">                  &amp;&amp; !player_res_torment(false)</a>
<a name="ln7782">                  &amp;&amp; !player_kiku_res_torment();</a>
<a name="ln7783">    case SPELL_CHAIN_LIGHTNING:</a>
<a name="ln7784">        return !_trace_los(mon, _elec_vulnerable)</a>
<a name="ln7785">                || you.visible_to(mon) &amp;&amp; friendly; // don't zap player</a>
<a name="ln7786">    case SPELL_CORRUPTING_PULSE:</a>
<a name="ln7787">        return !_trace_los(mon, _mutation_vulnerable)</a>
<a name="ln7788">               || you.visible_to(mon)</a>
<a name="ln7789">                  &amp;&amp; friendly;</a>
<a name="ln7790">    case SPELL_TORNADO:</a>
<a name="ln7791">        return mon-&gt;has_ench(ENCH_TORNADO)</a>
<a name="ln7792">               || mon-&gt;has_ench(ENCH_TORNADO_COOLDOWN)</a>
<a name="ln7793">               || !_trace_los(mon, _tornado_vulnerable)</a>
<a name="ln7794">               || you.visible_to(mon) &amp;&amp; friendly // don't cast near the player</a>
<a name="ln7795">                  &amp;&amp; !(mon-&gt;holiness() &amp; MH_DEMONIC); // demons are rude</a>
<a name="ln7796"> </a>
<a name="ln7797">    case SPELL_VORTEX:</a>
<a name="ln7798">        return mon-&gt;has_ench(ENCH_VORTEX)</a>
<a name="ln7799">               || mon-&gt;has_ench(ENCH_VORTEX_COOLDOWN)</a>
<a name="ln7800">               || !_trace_los(mon, _tornado_vulnerable)</a>
<a name="ln7801">               || you.visible_to(mon) &amp;&amp; friendly</a>
<a name="ln7802">                  &amp;&amp; !(mon-&gt;holiness() &amp; MH_DEMONIC);</a>
<a name="ln7803"> </a>
<a name="ln7804">    case SPELL_ENGLACIATION:</a>
<a name="ln7805">        return !foe</a>
<a name="ln7806">               || !mon-&gt;see_cell_no_trans(foe-&gt;pos())</a>
<a name="ln7807">               || foe-&gt;res_cold() &gt; 0;</a>
<a name="ln7808"> </a>
<a name="ln7809">    case SPELL_OLGREBS_TOXIC_RADIANCE:</a>
<a name="ln7810">        return mon-&gt;has_ench(ENCH_TOXIC_RADIANCE)</a>
<a name="ln7811">               || cast_toxic_radiance(mon, 100, false, true) != spret::success;</a>
<a name="ln7812">    case SPELL_IGNITE_POISON:</a>
<a name="ln7813">        return cast_ignite_poison(mon, 0, false, true) != spret::success;</a>
<a name="ln7814"> </a>
<a name="ln7815">    case SPELL_GLACIATE:</a>
<a name="ln7816">        return !foe</a>
<a name="ln7817">               || !_glaciate_tracer(mon, mons_spellpower(*mon, monspell),</a>
<a name="ln7818">                                    foe-&gt;pos());</a>
<a name="ln7819"> </a>
<a name="ln7820">    case SPELL_CLOUD_CONE:</a>
<a name="ln7821">        return !foe || no_clouds</a>
<a name="ln7822">               || !mons_should_cloud_cone(mon, mons_spellpower(*mon, monspell),</a>
<a name="ln7823">                                          foe-&gt;pos());</a>
<a name="ln7824"> </a>
<a name="ln7825">    case SPELL_MALIGN_GATEWAY:</a>
<a name="ln7826">        return !can_cast_malign_gateway();</a>
<a name="ln7827"> </a>
<a name="ln7828">    case SPELL_SIREN_SONG:</a>
<a name="ln7829">        return !_should_siren_sing(mon, false);</a>
<a name="ln7830"> </a>
<a name="ln7831">    case SPELL_AVATAR_SONG:</a>
<a name="ln7832">        return !_should_siren_sing(mon, true);</a>
<a name="ln7833"> </a>
<a name="ln7834">    case SPELL_REPEL_MISSILES:</a>
<a name="ln7835">        return mon-&gt;has_ench(ENCH_REPEL_MISSILES);</a>
<a name="ln7836"> </a>
<a name="ln7837">    case SPELL_CONFUSION_GAZE:</a>
<a name="ln7838">        return !foe || !mon-&gt;can_see(*foe);</a>
<a name="ln7839"> </a>
<a name="ln7840">    case SPELL_SCATTERSHOT:</a>
<a name="ln7841">        return !foe</a>
<a name="ln7842">               || !scattershot_tracer(mon, mons_spellpower(*mon, monspell),</a>
<a name="ln7843">                                      foe-&gt;pos());</a>
<a name="ln7844"> </a>
<a name="ln7845">    case SPELL_CLEANSING_FLAME:</a>
<a name="ln7846">    {</a>
<a name="ln7847">        bolt tracer;</a>
<a name="ln7848">        setup_cleansing_flame_beam(tracer,</a>
<a name="ln7849">                                   5 + (7 * mon-&gt;spell_hd(monspell)) / 12,</a>
<a name="ln7850">                                   cleansing_flame_source::spell,</a>
<a name="ln7851">                                   mon-&gt;pos(), mon);</a>
<a name="ln7852">        fire_tracer(mon, tracer, true);</a>
<a name="ln7853">        return !mons_should_fire(tracer);</a>
<a name="ln7854">    }</a>
<a name="ln7855"> </a>
<a name="ln7856">    case SPELL_GRAVITAS:</a>
<a name="ln7857">        if (!foe)</a>
<a name="ln7858">            return true;</a>
<a name="ln7859"> </a>
<a name="ln7860">        for (actor_near_iterator ai(foe-&gt;pos(), LOS_SOLID); ai; ++ai)</a>
<a name="ln7861">            if (*ai != mon &amp;&amp; *ai != foe &amp;&amp; !ai-&gt;is_stationary()</a>
<a name="ln7862">                &amp;&amp; mon-&gt;can_see(**ai))</a>
<a name="ln7863">            {</a>
<a name="ln7864">                return false;</a>
<a name="ln7865">            }</a>
<a name="ln7866"> </a>
<a name="ln7867">        return true;</a>
<a name="ln7868"> </a>
<a name="ln7869">    case SPELL_DOOM_HOWL:</a>
<a name="ln7870">        return !foe || !foe-&gt;is_player() || you.duration[DUR_DOOM_HOWL]</a>
<a name="ln7871">                || mon-&gt;props[DOOM_HOUND_HOWLED_KEY]</a>
<a name="ln7872">                || mon-&gt;is_summoned();</a>
<a name="ln7873"> </a>
<a name="ln7874">    case SPELL_CALL_OF_CHAOS:</a>
<a name="ln7875">        return !_mons_call_of_chaos(*mon, true);</a>
<a name="ln7876"> </a>
<a name="ln7877">    case SPELL_AURA_OF_BRILLIANCE:</a>
<a name="ln7878">        if (mon-&gt;has_ench(ENCH_BRILLIANCE_AURA) || !foe || !mon-&gt;can_see(*foe))</a>
<a name="ln7879">            return true;</a>
<a name="ln7880"> </a>
<a name="ln7881">        for (monster_near_iterator mi(mon, LOS_NO_TRANS); mi; ++mi)</a>
<a name="ln7882">            if (_valid_aura_of_brilliance_ally(mon, *mi))</a>
<a name="ln7883">                return false;</a>
<a name="ln7884">        return true;</a>
<a name="ln7885"> </a>
<a name="ln7886">    case SPELL_BIND_SOULS:</a>
<a name="ln7887">        for (monster_near_iterator mi(mon, LOS_NO_TRANS); mi; ++mi)</a>
<a name="ln7888">            if (_mons_can_bind_soul(mon, *mi))</a>
<a name="ln7889">                return false;</a>
<a name="ln7890">        return true;</a>
<a name="ln7891"> </a>
<a name="ln7892">    case SPELL_CORPSE_ROT:</a>
<a name="ln7893">    case SPELL_POISONOUS_CLOUD:</a>
<a name="ln7894">    case SPELL_FREEZING_CLOUD:</a>
<a name="ln7895">    case SPELL_MEPHITIC_CLOUD:</a>
<a name="ln7896">    case SPELL_NOXIOUS_CLOUD:</a>
<a name="ln7897">    case SPELL_SPECTRAL_CLOUD:</a>
<a name="ln7898">    case SPELL_FLAMING_CLOUD:</a>
<a name="ln7899">    case SPELL_CHAOS_BREATH:</a>
<a name="ln7900">        return no_clouds;</a>
<a name="ln7901"> </a>
<a name="ln7902">    case SPELL_SUMMON_SWARM:</a>
<a name="ln7903">#if TAG_MAJOR_VERSION == 34</a>
<a name="ln7904">    case SPELL_INNER_FLAME:</a>
<a name="ln7905">    case SPELL_ANIMATE_DEAD:</a>
<a name="ln7906">    case SPELL_SIMULACRUM:</a>
<a name="ln7907">    case SPELL_DEATHS_DOOR:</a>
<a name="ln7908">    case SPELL_FULMINANT_PRISM:</a>
<a name="ln7909">    case SPELL_DAZZLING_FLASH:</a>
<a name="ln7910">#endif</a>
<a name="ln7911">    case SPELL_NO_SPELL:</a>
<a name="ln7912">        return true;</a>
<a name="ln7913"> </a>
<a name="ln7914">    default:</a>
<a name="ln7915">        return false;</a>
<a name="ln7916">    }</a>
<a name="ln7917">}</a>
<a name="ln7918"> </a>
<a name="ln7919">static string _god_name(god_type god)</a>
<a name="ln7920">{</a>
<a name="ln7921">    return god_has_name(god) ? god_name(god) : &quot;Something&quot;;</a>
<a name="ln7922">}</a>

</code></pre>
<div class="balloon" rel="703"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v648/" target="_blank">V648</a> Priority of the '&&' operation is higher than that of the '||' operation.</p></div>
<div class="balloon" rel="1225"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v1048/" target="_blank">V1048</a> The 'beam.thrower' variable was assigned the same value.</p></div>
<div class="balloon" rel="1226"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v1048/" target="_blank">V1048</a> The 'beam.pierce' variable was assigned the same value.</p></div>
<div class="balloon" rel="1227"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v1048/" target="_blank">V1048</a> The 'beam.is_explosion' variable was assigned the same value.</p></div>
<div class="balloon" rel="1249"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v519/" target="_blank">V519</a> The 'beam.glyph' variable is assigned values twice successively. Perhaps this is a mistake. Check lines: 1223, 1249.</p></div>
<div class="balloon" rel="1250"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v519/" target="_blank">V519</a> The 'beam.thrower' variable is assigned values twice successively. Perhaps this is a mistake. Check lines: 1225, 1250.</p></div>
<div class="balloon" rel="1886"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v648/" target="_blank">V648</a> Priority of the '&&' operation is higher than that of the '||' operation.</p></div>
<div class="balloon" rel="2031"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v648/" target="_blank">V648</a> Priority of the '&&' operation is higher than that of the '||' operation.</p></div>
<div class="balloon" rel="2112"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v648/" target="_blank">V648</a> Priority of the '&&' operation is higher than that of the '||' operation.</p></div>
<div class="balloon" rel="2220"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v648/" target="_blank">V648</a> Priority of the '&&' operation is higher than that of the '||' operation.</p></div>
<div class="balloon" rel="3116"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v1048/" target="_blank">V1048</a> The 'tracer.foe_ratio' variable was assigned the same value.</p></div>
<div class="balloon" rel="3700"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v648/" target="_blank">V648</a> Priority of the '&&' operation is higher than that of the '||' operation.</p></div>
<div class="balloon" rel="4220"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v602/" target="_blank">V602</a> Consider inspecting the '(spell_hd > 15)' expression. '>' possibly should be replaced with '>>'.</p></div>
<div class="balloon" rel="4475"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v560/" target="_blank">V560</a> A part of conditional expression is always true: !already_mesmerised.</p></div>
<div class="balloon" rel="7360"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v602/" target="_blank">V602</a> Consider inspecting the '(mon.spell_hd(SPELL_AWAKEN_EARTH) > 15)' expression. '>' possibly should be replaced with '>>'.</p></div>
<div class="balloon" rel="7444"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v648/" target="_blank">V648</a> Priority of the '&&' operation is higher than that of the '||' operation.</p></div>
<div class="balloon" rel="7557"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v648/" target="_blank">V648</a> Priority of the '&&' operation is higher than that of the '||' operation.</p></div>
<div class="balloon" rel="7617"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v648/" target="_blank">V648</a> Priority of the '&&' operation is higher than that of the '||' operation.</p></div>
<div class="balloon" rel="7688"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v648/" target="_blank">V648</a> Priority of the '&&' operation is higher than that of the '||' operation.</p></div>
<div class="balloon" rel="7699"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v648/" target="_blank">V648</a> Priority of the '&&' operation is higher than that of the '||' operation.</p></div>
<div class="balloon" rel="7785"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v648/" target="_blank">V648</a> Priority of the '&&' operation is higher than that of the '||' operation.</p></div>
<div class="balloon" rel="7788"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v648/" target="_blank">V648</a> Priority of the '&&' operation is higher than that of the '||' operation.</p></div>

<link rel="stylesheet" href="highlight.css">
<script src="highlight.pack.js"></script>
<script src="highlightjs-line-numbers.js"></script>
<script>hljs.initHighlightingOnLoad();</script>
<script>hljs.initLineNumbersOnLoad();</script>
<script>
  $(document).ready(function() {
      $('.balloon').each(function () {
          var bl = $(this);
          var line = bl.attr('rel');
          var text = $('a[name="ln'+line+'"]').text();

          var space_count = 0;
          for(var i = 0; i<text.length; i++){
              var char = text[i];
              if((char !== ' ')&&(char !== '\t'))break;
              if(char === '\t')space_count++;
              space_count++;
          }

          bl.css('margin-left', space_count*8);
          $('a[name="ln'+line+'"]').after(bl);
      });

      window.location = window.location;
  });
</script>
</body>
</html>
