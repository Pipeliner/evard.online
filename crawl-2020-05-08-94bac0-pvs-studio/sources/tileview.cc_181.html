
<html>
<head>

  <meta http-equiv="Content-Type" content="text/html; charset=US-ASCII" />
  <title>tileview.cc</title>

  <link rel="stylesheet" href="../style.css"/>
  <script src="../jquery-3.2.1.min.js"></script>
</head>
<body>

<pre><code class = "cpp">
<a name="ln1">#include &quot;AppHdr.h&quot;</a>
<a name="ln2"> </a>
<a name="ln3">#include &quot;tileview.h&quot;</a>
<a name="ln4"> </a>
<a name="ln5">#include &quot;areas.h&quot;</a>
<a name="ln6">#include &quot;branch.h&quot;</a>
<a name="ln7">#include &quot;cloud.h&quot;</a>
<a name="ln8">#include &quot;colour.h&quot;</a>
<a name="ln9">#include &quot;coord.h&quot;</a>
<a name="ln10">#include &quot;coordit.h&quot;</a>
<a name="ln11">#include &quot;domino.h&quot;</a>
<a name="ln12">#include &quot;domino-data.h&quot;</a>
<a name="ln13">#include &quot;dungeon.h&quot;</a>
<a name="ln14">#include &quot;env.h&quot;</a>
<a name="ln15">#include &quot;fprop.h&quot;</a>
<a name="ln16">#include &quot;items.h&quot;</a>
<a name="ln17">#include &quot;kills.h&quot;</a>
<a name="ln18">#include &quot;mon-util.h&quot;</a>
<a name="ln19">#include &quot;options.h&quot;</a>
<a name="ln20">#include &quot;pcg.h&quot;</a>
<a name="ln21">#include &quot;player.h&quot;</a>
<a name="ln22">#include &quot;state.h&quot;</a>
<a name="ln23">#include &quot;terrain.h&quot;</a>
<a name="ln24">#include &quot;tile-flags.h&quot;</a>
<a name="ln25">#include &quot;rltiles/tiledef-dngn.h&quot;</a>
<a name="ln26">#include &quot;rltiles/tiledef-player.h&quot;</a>
<a name="ln27">#include &quot;tilemcache.h&quot;</a>
<a name="ln28">#include &quot;tilepick.h&quot;</a>
<a name="ln29">#include &quot;tiles-build-specific.h&quot;</a>
<a name="ln30">#include &quot;traps.h&quot;</a>
<a name="ln31">#include &quot;travel.h&quot;</a>
<a name="ln32">#include &quot;viewgeom.h&quot;</a>
<a name="ln33"> </a>
<a name="ln34">void tile_new_level(bool first_time, bool init_unseen)</a>
<a name="ln35">{</a>
<a name="ln36">    if (first_time)</a>
<a name="ln37">        tile_init_flavour();</a>
<a name="ln38"> </a>
<a name="ln39">#ifdef USE_TILE</a>
<a name="ln40">    if (init_unseen)</a>
<a name="ln41">    {</a>
<a name="ln42">        for (unsigned int x = 0; x &lt; GXM; x++)</a>
<a name="ln43">            for (unsigned int y = 0; y &lt; GYM; y++)</a>
<a name="ln44">            {</a>
<a name="ln45">                env.tile_bk_fg[x][y] = 0;</a>
<a name="ln46">                env.tile_bk_bg[x][y] = TILE_DNGN_UNSEEN;</a>
<a name="ln47">                env.tile_bk_cloud[x][y] = 0;</a>
<a name="ln48">            }</a>
<a name="ln49">    }</a>
<a name="ln50"> </a>
<a name="ln51">    // Fix up stair markers. The travel information isn't hooked up</a>
<a name="ln52">    // until after we change levels. So, look through all of the stairs</a>
<a name="ln53">    // on this level and check if they still need the stair flag.</a>
<a name="ln54">    for (unsigned int x = 0; x &lt; GXM; x++)</a>
<a name="ln55">        for (unsigned int y = 0; y &lt; GYM; y++)</a>
<a name="ln56">        {</a>
<a name="ln57">            unsigned int tile = env.tile_bk_bg[x][y];</a>
<a name="ln58">            if ((tile &amp; TILE_FLAG_NEW_STAIR)</a>
<a name="ln59">                &amp;&amp; !is_unknown_stair(coord_def(x,y)))</a>
<a name="ln60">            {</a>
<a name="ln61">                env.tile_bk_bg[x][y] &amp;= ~TILE_FLAG_NEW_STAIR;</a>
<a name="ln62">            }</a>
<a name="ln63">            else if ((tile &amp; TILE_FLAG_NEW_TRANSPORTER)</a>
<a name="ln64">                     &amp;&amp; !is_unknown_transporter(coord_def(x,y)))</a>
<a name="ln65">                env.tile_bk_bg[x][y] &amp;= ~TILE_FLAG_NEW_TRANSPORTER;</a>
<a name="ln66">        }</a>
<a name="ln67"> </a>
<a name="ln68">    tiles.clear_minimap();</a>
<a name="ln69"> </a>
<a name="ln70">    for (unsigned int x = 0; x &lt; GXM; x++)</a>
<a name="ln71">        for (unsigned int y = 0; y &lt; GYM; y++)</a>
<a name="ln72">            tiles.update_minimap(coord_def(x, y));</a>
<a name="ln73">#else</a>
<a name="ln74">    UNUSED(init_unseen);</a>
<a name="ln75">#endif</a>
<a name="ln76">}</a>
<a name="ln77"> </a>
<a name="ln78">void tile_init_default_flavour()</a>
<a name="ln79">{</a>
<a name="ln80">    tile_default_flv(you.where_are_you, env.tile_default);</a>
<a name="ln81">}</a>
<a name="ln82"> </a>
<a name="ln83">void tile_default_flv(branch_type br, tile_flavour &amp;flv)</a>
<a name="ln84">{</a>
<a name="ln85">    flv.wall    = TILE_WALL_NORMAL;</a>
<a name="ln86">    flv.floor   = TILE_FLOOR_NORMAL;</a>
<a name="ln87">    flv.special = 0;</a>
<a name="ln88"> </a>
<a name="ln89">    flv.wall_idx = 0;</a>
<a name="ln90">    flv.floor_idx = 0;</a>
<a name="ln91"> </a>
<a name="ln92">    switch (br)</a>
<a name="ln93">    {</a>
<a name="ln94">    case BRANCH_DUNGEON:</a>
<a name="ln95">        flv.wall  = TILE_WALL_NORMAL;</a>
<a name="ln96">        flv.floor = TILE_FLOOR_NORMAL;</a>
<a name="ln97">        return;</a>
<a name="ln98"> </a>
<a name="ln99">    case BRANCH_DEPTHS:</a>
<a name="ln100">        flv.wall  = TILE_WALL_NORMAL;</a>
<a name="ln101">        flv.floor = TILE_FLOOR_GREY_DIRT_B;</a>
<a name="ln102">        return;</a>
<a name="ln103"> </a>
<a name="ln104">    case BRANCH_VAULTS:</a>
<a name="ln105">        flv.wall  = TILE_WALL_VAULT;</a>
<a name="ln106">        flv.floor = TILE_FLOOR_VAULT;</a>
<a name="ln107">        return;</a>
<a name="ln108"> </a>
<a name="ln109">    case BRANCH_TEMPLE:</a>
<a name="ln110">        flv.wall  = TILE_WALL_VINES;</a>
<a name="ln111">        flv.floor = TILE_FLOOR_VINES;</a>
<a name="ln112">        return;</a>
<a name="ln113"> </a>
<a name="ln114">#if TAG_MAJOR_VERSION == 34</a>
<a name="ln115">    case BRANCH_DWARF:</a>
<a name="ln116">        flv.wall  = TILE_WALL_HALL;</a>
<a name="ln117">        flv.floor = TILE_FLOOR_LIMESTONE;</a>
<a name="ln118">        return;</a>
<a name="ln119">#endif</a>
<a name="ln120"> </a>
<a name="ln121">#if TAG_MAJOR_VERSION == 34</a>
<a name="ln122">    case BRANCH_BLADE:</a>
<a name="ln123">#endif</a>
<a name="ln124">    case BRANCH_ELF:</a>
<a name="ln125">        flv.wall  = TILE_WALL_HALL;</a>
<a name="ln126">        flv.floor = TILE_FLOOR_HALL;</a>
<a name="ln127">        return;</a>
<a name="ln128"> </a>
<a name="ln129">    case BRANCH_TARTARUS:</a>
<a name="ln130">        flv.wall  = TILE_WALL_COBALT_ROCK;</a>
<a name="ln131">        flv.floor = TILE_FLOOR_BLACK_COBALT;</a>
<a name="ln132">        return;</a>
<a name="ln133"> </a>
<a name="ln134">    case BRANCH_CRYPT:</a>
<a name="ln135">        flv.wall  = TILE_WALL_BRICK_GRAY;</a>
<a name="ln136">        flv.floor = TILE_FLOOR_CRYPT;</a>
<a name="ln137">        return;</a>
<a name="ln138"> </a>
<a name="ln139">    case BRANCH_TOMB:</a>
<a name="ln140">        flv.wall  = TILE_WALL_UNDEAD;</a>
<a name="ln141">        flv.floor = TILE_FLOOR_TOMB;</a>
<a name="ln142">        return;</a>
<a name="ln143"> </a>
<a name="ln144">    case BRANCH_VESTIBULE:</a>
<a name="ln145">        flv.wall  = TILE_WALL_HELL;</a>
<a name="ln146">        flv.floor = TILE_FLOOR_CAGE;</a>
<a name="ln147">        return;</a>
<a name="ln148"> </a>
<a name="ln149">    case BRANCH_DIS:</a>
<a name="ln150">        flv.wall  = TILE_WALL_ZOT_CYAN;</a>
<a name="ln151">        flv.floor = TILE_FLOOR_IRON;</a>
<a name="ln152">        return;</a>
<a name="ln153"> </a>
<a name="ln154">    case BRANCH_GEHENNA:</a>
<a name="ln155">        flv.wall  = TILE_WALL_ZOT_RED;</a>
<a name="ln156">        flv.floor = TILE_FLOOR_ROUGH_RED;</a>
<a name="ln157">        return;</a>
<a name="ln158"> </a>
<a name="ln159">    case BRANCH_COCYTUS:</a>
<a name="ln160">        flv.wall  = TILE_WALL_ICE;</a>
<a name="ln161">        flv.floor = TILE_FLOOR_FROZEN;</a>
<a name="ln162">        return;</a>
<a name="ln163"> </a>
<a name="ln164">    case BRANCH_ORC:</a>
<a name="ln165">        flv.wall  = TILE_WALL_ORC;</a>
<a name="ln166">        flv.floor = TILE_FLOOR_ORC;</a>
<a name="ln167">        return;</a>
<a name="ln168"> </a>
<a name="ln169">    case BRANCH_LAIR:</a>
<a name="ln170">        flv.wall  = TILE_WALL_LAIR;</a>
<a name="ln171">        flv.floor = TILE_FLOOR_LAIR;</a>
<a name="ln172">        return;</a>
<a name="ln173"> </a>
<a name="ln174">    case BRANCH_SLIME:</a>
<a name="ln175">        flv.wall  = TILE_WALL_SLIME;</a>
<a name="ln176">        flv.floor = TILE_FLOOR_SLIME;</a>
<a name="ln177">        return;</a>
<a name="ln178"> </a>
<a name="ln179">    case BRANCH_SNAKE:</a>
<a name="ln180">        flv.wall  = TILE_WALL_SNAKE;</a>
<a name="ln181">        flv.floor = TILE_FLOOR_MOSAIC;</a>
<a name="ln182">        return;</a>
<a name="ln183"> </a>
<a name="ln184">    case BRANCH_SWAMP:</a>
<a name="ln185">        flv.wall  = TILE_WALL_SWAMP;</a>
<a name="ln186">        flv.floor = TILE_FLOOR_SWAMP;</a>
<a name="ln187">        return;</a>
<a name="ln188"> </a>
<a name="ln189">    case BRANCH_SHOALS:</a>
<a name="ln190">        flv.wall  = TILE_WALL_SHOALS;</a>
<a name="ln191">        flv.floor = TILE_FLOOR_SAND;</a>
<a name="ln192">        return;</a>
<a name="ln193"> </a>
<a name="ln194">    case BRANCH_SPIDER:</a>
<a name="ln195">        flv.wall  = TILE_WALL_SPIDER;</a>
<a name="ln196">        flv.floor = TILE_FLOOR_SPIDER;</a>
<a name="ln197">        return;</a>
<a name="ln198"> </a>
<a name="ln199">    case BRANCH_ZOT:</a>
<a name="ln200">        flv.wall  = TILE_WALL_ZOT_YELLOW;</a>
<a name="ln201">        flv.floor = TILE_FLOOR_TOMB;</a>
<a name="ln202">        return;</a>
<a name="ln203"> </a>
<a name="ln204">#if TAG_MAJOR_VERSION == 34</a>
<a name="ln205">    case BRANCH_FOREST:</a>
<a name="ln206">        flv.wall  = TILE_WALL_LAIR;</a>
<a name="ln207">        flv.floor = TILE_FLOOR_GRASS;</a>
<a name="ln208">        return;</a>
<a name="ln209">#endif</a>
<a name="ln210">    case BRANCH_ABYSS:</a>
<a name="ln211">        flv.floor = tile_dngn_coloured(TILE_FLOOR_NERVES, env.floor_colour);</a>
<a name="ln212">        switch (random2(6))</a>
<a name="ln213">        {</a>
<a name="ln214">        default:</a>
<a name="ln215">        case 0:</a>
<a name="ln216">        case 1:</a>
<a name="ln217">        case 2:</a>
<a name="ln218">            flv.wall = tile_dngn_coloured(TILE_WALL_ABYSS, env.rock_colour);</a>
<a name="ln219">            break;</a>
<a name="ln220">        case 3:</a>
<a name="ln221">            flv.wall = tile_dngn_coloured(TILE_WALL_PEBBLE, env.rock_colour);</a>
<a name="ln222">            break;</a>
<a name="ln223">        case 4:</a>
<a name="ln224">            flv.wall = tile_dngn_coloured(TILE_WALL_HALL, env.rock_colour);</a>
<a name="ln225">            break;</a>
<a name="ln226">        case 5:</a>
<a name="ln227">            flv.wall = tile_dngn_coloured(TILE_WALL_UNDEAD, env.rock_colour);</a>
<a name="ln228">            break;</a>
<a name="ln229">        }</a>
<a name="ln230">        return;</a>
<a name="ln231"> </a>
<a name="ln232">    case BRANCH_PANDEMONIUM:</a>
<a name="ln233">        flv.floor = tile_dngn_coloured(TILE_FLOOR_DEMONIC, env.floor_colour);</a>
<a name="ln234">        if (env.rock_colour == LIGHTRED)</a>
<a name="ln235">            flv.wall = TILE_WALL_FLESH;</a>
<a name="ln236">        else</a>
<a name="ln237">            flv.wall = tile_dngn_coloured(TILE_WALL_BARS, env.rock_colour);</a>
<a name="ln238">        break;</a>
<a name="ln239"> </a>
<a name="ln240">    case BRANCH_ZIGGURAT:</a>
<a name="ln241">    case BRANCH_BAZAAR:</a>
<a name="ln242">    case BRANCH_TROVE:</a>
<a name="ln243">        flv.wall  = TILE_WALL_VAULT;</a>
<a name="ln244">        flv.floor = TILE_FLOOR_VAULT;</a>
<a name="ln245">        return;</a>
<a name="ln246"> </a>
<a name="ln247">#if TAG_MAJOR_VERSION == 34</a>
<a name="ln248">    case BRANCH_LABYRINTH:</a>
<a name="ln249">#endif</a>
<a name="ln250">    case BRANCH_GAUNTLET:</a>
<a name="ln251">        flv.wall  = TILE_WALL_LAB_ROCK;</a>
<a name="ln252">        flv.floor = TILE_FLOOR_GAUNTLET;</a>
<a name="ln253">        return;</a>
<a name="ln254"> </a>
<a name="ln255">    case BRANCH_SEWER:</a>
<a name="ln256">        flv.wall  = TILE_WALL_PEBBLE_GREEN;</a>
<a name="ln257">        flv.floor = TILE_FLOOR_SLIME;</a>
<a name="ln258">        return;</a>
<a name="ln259"> </a>
<a name="ln260">    case BRANCH_OSSUARY:</a>
<a name="ln261">        flv.wall  = TILE_WALL_SANDSTONE;</a>
<a name="ln262">        flv.floor = TILE_FLOOR_SANDSTONE;</a>
<a name="ln263">        return;</a>
<a name="ln264"> </a>
<a name="ln265">    case BRANCH_BAILEY:</a>
<a name="ln266">        flv.wall  = TILE_WALL_BRICK_BROWN;</a>
<a name="ln267">        flv.floor = TILE_FLOOR_COBBLE_BLOOD;</a>
<a name="ln268">        return;</a>
<a name="ln269"> </a>
<a name="ln270">    case BRANCH_ICE_CAVE:</a>
<a name="ln271">        flv.wall  = TILE_WALL_ICE_BLOCK;</a>
<a name="ln272">        flv.floor = TILE_FLOOR_ICE;</a>
<a name="ln273">        return;</a>
<a name="ln274"> </a>
<a name="ln275">    case BRANCH_VOLCANO:</a>
<a name="ln276">        flv.wall  = TILE_WALL_VOLCANIC;</a>
<a name="ln277">        flv.floor = TILE_FLOOR_ROUGH_RED;</a>
<a name="ln278">        return;</a>
<a name="ln279"> </a>
<a name="ln280">    case BRANCH_WIZLAB:</a>
<a name="ln281">        flv.wall  = TILE_WALL_NORMAL;</a>
<a name="ln282">        flv.floor = TILE_FLOOR_NORMAL;</a>
<a name="ln283">        return;</a>
<a name="ln284"> </a>
<a name="ln285">    case BRANCH_DESOLATION:</a>
<a name="ln286">        flv.floor = TILE_FLOOR_SALT;</a>
<a name="ln287">        flv.wall = TILE_WALL_DESOLATION;</a>
<a name="ln288">        return;</a>
<a name="ln289"> </a>
<a name="ln290">    case NUM_BRANCHES:</a>
<a name="ln291">    case GLOBAL_BRANCH_INFO:</a>
<a name="ln292">        break;</a>
<a name="ln293">    }</a>
<a name="ln294">}</a>
<a name="ln295"> </a>
<a name="ln296">void tile_clear_flavour(const coord_def &amp;p)</a>
<a name="ln297">{</a>
<a name="ln298">    env.tile_flv(p).floor     = 0;</a>
<a name="ln299">    env.tile_flv(p).wall      = 0;</a>
<a name="ln300">    env.tile_flv(p).feat      = 0;</a>
<a name="ln301">    env.tile_flv(p).floor_idx = 0;</a>
<a name="ln302">    env.tile_flv(p).wall_idx  = 0;</a>
<a name="ln303">    env.tile_flv(p).feat_idx  = 0;</a>
<a name="ln304">    env.tile_flv(p).special   = 0;</a>
<a name="ln305">}</a>
<a name="ln306"> </a>
<a name="ln307">void tile_clear_flavour()</a>
<a name="ln308">{</a>
<a name="ln309">    for (rectangle_iterator ri(0); ri; ++ri)</a>
<a name="ln310">        tile_clear_flavour(*ri);</a>
<a name="ln311">}</a>
<a name="ln312"> </a>
<a name="ln313">static bool _level_uses_dominoes()</a>
<a name="ln314">{</a>
<a name="ln315">    return you.where_are_you == BRANCH_CRYPT;</a>
<a name="ln316">}</a>
<a name="ln317"> </a>
<a name="ln318">// For floors and walls that have not already been set to a particular tile,</a>
<a name="ln319">// set them to a random instance of the default floor and wall tileset.</a>
<a name="ln320">void tile_init_flavour()</a>
<a name="ln321">{</a>
<a name="ln322">    if (_level_uses_dominoes())</a>
<a name="ln323">    {</a>
<a name="ln324">        vector&lt;unsigned int&gt; output;</a>
<a name="ln325"> </a>
<a name="ln326">        {</a>
<a name="ln327">            rng::subgenerator sub_rng(</a>
<a name="ln328">                static_cast&lt;uint64_t&gt;(you.where_are_you ^ you.game_seed),</a>
<a name="ln329">                static_cast&lt;uint64_t&gt;(you.depth));</a>
<a name="ln330">            output.reserve(X_WIDTH * Y_WIDTH);</a>
<a name="ln331">            domino::DominoSet&lt;domino::EdgeDomino&gt; dominoes(domino::cohen_set, 8);</a>
<a name="ln332">            // TODO: don't pass a PcgRNG object</a>
<a name="ln333">            dominoes.Generate(X_WIDTH, Y_WIDTH, output,</a>
<a name="ln334">                                                    rng::current_generator());</a>
<a name="ln335">        }</a>
<a name="ln336"> </a>
<a name="ln337">        for (rectangle_iterator ri(0); ri; ++ri)</a>
<a name="ln338">            tile_init_flavour(*ri, output[ri-&gt;x + ri-&gt;y * GXM]);</a>
<a name="ln339">    }</a>
<a name="ln340">    else</a>
<a name="ln341">        for (rectangle_iterator ri(0); ri; ++ri)</a>
<a name="ln342">            tile_init_flavour(*ri, 0);</a>
<a name="ln343">}</a>
<a name="ln344"> </a>
<a name="ln345">// 11111333333   55555555</a>
<a name="ln346">//   222222444444   6666666666</a>
<a name="ln347">static void _get_dungeon_wall_tiles_by_depth(int depth, vector&lt;tileidx_t&gt;&amp; t)</a>
<a name="ln348">{</a>
<a name="ln349">    if (crawl_state.game_is_sprint() || crawl_state.game_is_arena())</a>
<a name="ln350">    {</a>
<a name="ln351">        t.push_back(TILE_WALL_CATACOMBS);</a>
<a name="ln352">        return;</a>
<a name="ln353">    }</a>
<a name="ln354">    if (depth &lt;= 5)</a>
<a name="ln355">        t.push_back(TILE_WALL_BRICK_DARK_1);</a>
<a name="ln356">    if (depth &gt; 2 &amp;&amp; depth &lt;= 8)</a>
<a name="ln357">    {</a>
<a name="ln358">        t.push_back(TILE_WALL_BRICK_DARK_2);</a>
<a name="ln359">        t.push_back(TILE_WALL_BRICK_DARK_2_TORCH);</a>
<a name="ln360">    }</a>
<a name="ln361">    if (depth &gt; 5 &amp;&amp; depth &lt;= 11)</a>
<a name="ln362">        t.push_back(TILE_WALL_BRICK_DARK_3);</a>
<a name="ln363">    if (depth &gt; 8)</a>
<a name="ln364">    {</a>
<a name="ln365">        t.push_back(TILE_WALL_BRICK_DARK_4);</a>
<a name="ln366">        t.push_back(TILE_WALL_BRICK_DARK_4_TORCH);</a>
<a name="ln367">    }</a>
<a name="ln368">    if (depth == brdepth[BRANCH_DUNGEON])</a>
<a name="ln369">        t.push_back(TILE_WALL_BRICK_DARK_4_TORCH);  // torches are more common on D:14...</a>
<a name="ln370">}</a>
<a name="ln371"> </a>
<a name="ln372">static void _get_depths_wall_tiles_by_depth(int depth, vector&lt;tileidx_t&gt;&amp; t)</a>
<a name="ln373">{</a>
<a name="ln374">    t.push_back(TILE_WALL_BRICK_DARK_6_TORCH);</a>
<a name="ln375">    if (depth &lt;= 3)</a>
<a name="ln376">        t.push_back(TILE_WALL_BRICK_DARK_5);</a>
<a name="ln377">    if (depth &gt; 3)</a>
<a name="ln378">        t.push_back(TILE_WALL_BRICK_DARK_6);</a>
<a name="ln379">    if (depth == brdepth[BRANCH_DEPTHS])</a>
<a name="ln380">        t.push_back(TILE_WALL_BRICK_DARK_6_TORCH);  // ...and on Depths:$</a>
<a name="ln381">}</a>
<a name="ln382"> </a>
<a name="ln383">static int _find_variants(tileidx_t idx, int variant, vector&lt;int&gt; &amp;out)</a>
<a name="ln384">{</a>
<a name="ln385">    const int count = tile_dngn_count(idx);</a>
<a name="ln386">    out.reserve(count);</a>
<a name="ln387">    if (count == 1)</a>
<a name="ln388">    {</a>
<a name="ln389">        out.push_back(1);</a>
<a name="ln390">        return 1;</a>
<a name="ln391">    }</a>
<a name="ln392"> </a>
<a name="ln393">    int total = 0;</a>
<a name="ln394">    int curr_prob = 0;</a>
<a name="ln395">    for (int i = 0; i &lt; count; ++i)</a>
<a name="ln396">    {</a>
<a name="ln397">        int last_prob = curr_prob;</a>
<a name="ln398">        curr_prob = tile_dngn_probs(idx + i);</a>
<a name="ln399">        if (tile_dngn_dominoes(idx + i) == variant)</a>
<a name="ln400">        {</a>
<a name="ln401">            int weight = curr_prob - last_prob;</a>
<a name="ln402">            total += weight;</a>
<a name="ln403">            out.push_back(weight);</a>
<a name="ln404">        }</a>
<a name="ln405">        else</a>
<a name="ln406">            out.push_back(0);</a>
<a name="ln407">    }</a>
<a name="ln408">    if (!total)</a>
<a name="ln409">    {</a>
<a name="ln410">        out.clear();</a>
<a name="ln411">        out.push_back(tile_dngn_probs(idx));</a>
<a name="ln412">        for (int i = 1; i &lt; count; ++i)</a>
<a name="ln413">            out.push_back(tile_dngn_probs(idx + i) - tile_dngn_probs(idx + i - 1));</a>
<a name="ln414">        return tile_dngn_probs(idx + count - 1);</a>
<a name="ln415">    }</a>
<a name="ln416">    return total;</a>
<a name="ln417">}</a>
<a name="ln418"> </a>
<a name="ln419">tileidx_t pick_dngn_tile(tileidx_t idx, int value, int domino)</a>
<a name="ln420">{</a>
<a name="ln421">    ASSERT_LESS(idx, TILE_DNGN_MAX);</a>
<a name="ln422">    static vector&lt;int&gt; weights;</a>
<a name="ln423">    weights.clear();</a>
<a name="ln424"> </a>
<a name="ln425">    int total = _find_variants(idx, domino, weights);</a>
<a name="ln426">    if (weights.size() == 1)</a>
<a name="ln427">        return idx;</a>
<a name="ln428">    int rand = value % total;</a>
<a name="ln429"> </a>
<a name="ln430">    for (size_t i = 0; i &lt; weights.size(); ++i)</a>
<a name="ln431">    {</a>
<a name="ln432">        rand -= weights[i];</a>
<a name="ln433">        if (rand &lt; 0) return idx + i;</a>
<a name="ln434">    }</a>
<a name="ln435"> </a>
<a name="ln436">    return idx;</a>
<a name="ln437">}</a>
<a name="ln438"> </a>
<a name="ln439">static tileidx_t _pick_dngn_tile_multi(vector&lt;tileidx_t&gt; candidates, int value)</a>
<a name="ln440">{</a>
<a name="ln441">    ASSERT(!candidates.empty());</a>
<a name="ln442"> </a>
<a name="ln443">    int total = 0;</a>
<a name="ln444">    for (tileidx_t tidx : candidates)</a>
<a name="ln445">    {</a>
<a name="ln446">        const unsigned int count = tile_dngn_count(tidx);</a>
<a name="ln447">        total += tile_dngn_probs(tidx + count - 1);</a>
<a name="ln448">    }</a>
<a name="ln449">    int rand = value % total;</a>
<a name="ln450"> </a>
<a name="ln451">    for (tileidx_t tidx : candidates)</a>
<a name="ln452">    {</a>
<a name="ln453">        const unsigned int count = tile_dngn_count(tidx);</a>
<a name="ln454">        for (unsigned int j = 0; j &lt; count; ++j)</a>
<a name="ln455">        {</a>
<a name="ln456">            if (rand &lt; tile_dngn_probs(tidx + j))</a>
<a name="ln457">                return tidx + j;</a>
<a name="ln458">        }</a>
<a name="ln459">        rand -= tile_dngn_probs(tidx + count - 1);</a>
<a name="ln460">    }</a>
<a name="ln461"> </a>
<a name="ln462">    // Should never reach this place</a>
<a name="ln463">    ASSERT(false);</a>
<a name="ln464">}</a>
<a name="ln465"> </a>
<a name="ln466">static bool _same_door_at(dungeon_feature_type feat, const coord_def &amp;gc)</a>
<a name="ln467">{</a>
<a name="ln468">    const dungeon_feature_type door = grd(gc);</a>
<a name="ln469"> </a>
<a name="ln470">    return door == feat</a>
<a name="ln471">#if TAG_MAJOR_VERSION == 34</a>
<a name="ln472">        || map_masked(gc, MMT_WAS_DOOR_MIMIC)</a>
<a name="ln473">#endif</a>
<a name="ln474">        || feat_is_closed_door(door)</a>
<a name="ln475">           &amp;&amp; feat_is_opaque(feat) == feat_is_opaque(door)</a>
<a name="ln476">           &amp;&amp; (feat_is_sealed(feat) || feat_is_sealed(door));</a>
<a name="ln477">}</a>
<a name="ln478"> </a>
<a name="ln479">void tile_init_flavour(const coord_def &amp;gc, const int domino)</a>
<a name="ln480">{</a>
<a name="ln481">    if (!map_bounds(gc))</a>
<a name="ln482">        return;</a>
<a name="ln483"> </a>
<a name="ln484">    uint32_t seed = you.birth_time + you.where_are_you +</a>
<a name="ln485">        (you.depth &lt;&lt; 8) + (gc.x &lt;&lt; 16) + (gc.y &lt;&lt; 24);</a>
<a name="ln486"> </a>
<a name="ln487">    int rand1 = hash_with_seed(INT_MAX, seed, 0);</a>
<a name="ln488">    int rand2 = hash_with_seed(INT_MAX, seed, 1);</a>
<a name="ln489"> </a>
<a name="ln490">    if (!env.tile_flv(gc).floor)</a>
<a name="ln491">    {</a>
<a name="ln492">        tileidx_t floor_base = env.tile_default.floor;</a>
<a name="ln493">        int colour = env.grid_colours(gc);</a>
<a name="ln494">        if (colour)</a>
<a name="ln495">            floor_base = tile_dngn_coloured(floor_base, colour);</a>
<a name="ln496">        env.tile_flv(gc).floor = pick_dngn_tile(floor_base, rand1, domino);</a>
<a name="ln497">    }</a>
<a name="ln498">    else if (env.tile_flv(gc).floor != TILE_HALO_GRASS</a>
<a name="ln499">             &amp;&amp; env.tile_flv(gc).floor != TILE_HALO_GRASS2</a>
<a name="ln500">             &amp;&amp; env.tile_flv(gc).floor != TILE_HALO_VAULT</a>
<a name="ln501">             &amp;&amp; env.tile_flv(gc).floor != TILE_HALO_DIRT)</a>
<a name="ln502">    {</a>
<a name="ln503">        env.tile_flv(gc).floor = pick_dngn_tile(env.tile_flv(gc).floor, rand1);</a>
<a name="ln504">    }</a>
<a name="ln505"> </a>
<a name="ln506">    if (!env.tile_flv(gc).wall)</a>
<a name="ln507">    {</a>
<a name="ln508">        if ((player_in_branch(BRANCH_DUNGEON) || player_in_branch(BRANCH_DEPTHS))</a>
<a name="ln509">            &amp;&amp; env.tile_default.wall == TILE_WALL_NORMAL)</a>
<a name="ln510">        {</a>
<a name="ln511">            vector&lt;tileidx_t&gt; tile_candidates;</a>
<a name="ln512">            if (player_in_branch(BRANCH_DEPTHS))</a>
<a name="ln513">                _get_depths_wall_tiles_by_depth(you.depth, tile_candidates);</a>
<a name="ln514">            else</a>
<a name="ln515">                _get_dungeon_wall_tiles_by_depth(you.depth, tile_candidates);</a>
<a name="ln516">            env.tile_flv(gc).wall = _pick_dngn_tile_multi(tile_candidates, rand2);</a>
<a name="ln517">        }</a>
<a name="ln518">        else</a>
<a name="ln519">        {</a>
<a name="ln520">            tileidx_t wall_base = env.tile_default.wall;</a>
<a name="ln521">            int colour = env.grid_colours(gc);</a>
<a name="ln522">            if (colour)</a>
<a name="ln523">                wall_base = tile_dngn_coloured(wall_base, colour);</a>
<a name="ln524">            env.tile_flv(gc).wall = pick_dngn_tile(wall_base, rand2);</a>
<a name="ln525">        }</a>
<a name="ln526">    }</a>
<a name="ln527">    else</a>
<a name="ln528">        env.tile_flv(gc).wall = pick_dngn_tile(env.tile_flv(gc).wall, rand2);</a>
<a name="ln529"> </a>
<a name="ln530">    if (feat_is_stone_stair(grd(gc)) &amp;&amp; player_in_branch(BRANCH_SHOALS))</a>
<a name="ln531">    {</a>
<a name="ln532">        const bool up = feat_stair_direction(grd(gc)) == CMD_GO_UPSTAIRS;</a>
<a name="ln533">        env.tile_flv(gc).feat = up ? TILE_DNGN_SHOALS_STAIRS_UP</a>
<a name="ln534">                                   : TILE_DNGN_SHOALS_STAIRS_DOWN;</a>
<a name="ln535">    }</a>
<a name="ln536"> </a>
<a name="ln537">    if (feat_is_escape_hatch(grd(gc)) &amp;&amp; player_in_branch(BRANCH_TOMB))</a>
<a name="ln538">    {</a>
<a name="ln539">        const bool up = feat_stair_direction(grd(gc)) == CMD_GO_UPSTAIRS;</a>
<a name="ln540">        env.tile_flv(gc).feat = up ? TILE_DNGN_ONE_WAY_STAIRS_UP</a>
<a name="ln541">                                   : TILE_DNGN_ONE_WAY_STAIRS_DOWN;</a>
<a name="ln542">    }</a>
<a name="ln543"> </a>
<a name="ln544">    if (feat_is_door(grd(gc)))</a>
<a name="ln545">    {</a>
<a name="ln546">        // Check for gates.</a>
<a name="ln547">        bool door_left  = _same_door_at(grd(gc), coord_def(gc.x - 1, gc.y));</a>
<a name="ln548">        bool door_right = _same_door_at(grd(gc), coord_def(gc.x + 1, gc.y));</a>
<a name="ln549">        bool door_up    = _same_door_at(grd(gc), coord_def(gc.x, gc.y - 1));</a>
<a name="ln550">        bool door_down  = _same_door_at(grd(gc), coord_def(gc.x, gc.y + 1));</a>
<a name="ln551"> </a>
<a name="ln552">        if (door_left || door_right || door_up || door_down)</a>
<a name="ln553">        {</a>
<a name="ln554">            tileidx_t target;</a>
<a name="ln555">            if (door_left &amp;&amp; door_right)</a>
<a name="ln556">                target = TILE_DNGN_GATE_CLOSED_MIDDLE;</a>
<a name="ln557">            else if (door_up &amp;&amp; door_down)</a>
<a name="ln558">                target = TILE_DNGN_VGATE_CLOSED_MIDDLE;</a>
<a name="ln559">            else if (door_left)</a>
<a name="ln560">                target = TILE_DNGN_GATE_CLOSED_RIGHT;</a>
<a name="ln561">            else if (door_right)</a>
<a name="ln562">                target = TILE_DNGN_GATE_CLOSED_LEFT;</a>
<a name="ln563">            else if (door_up)</a>
<a name="ln564">                target = TILE_DNGN_VGATE_CLOSED_DOWN;</a>
<a name="ln565">            else</a>
<a name="ln566">                target = TILE_DNGN_VGATE_CLOSED_UP;</a>
<a name="ln567"> </a>
<a name="ln568">            // NOTE: This requires that closed gates and open gates</a>
<a name="ln569">            // are positioned in the tile set relative to their</a>
<a name="ln570">            // door counterpart.</a>
<a name="ln571">            env.tile_flv(gc).special = target - TILE_DNGN_CLOSED_DOOR;</a>
<a name="ln572">        }</a>
<a name="ln573">        else</a>
<a name="ln574">            env.tile_flv(gc).special = 0;</a>
<a name="ln575">    }</a>
<a name="ln576">    else if (!env.tile_flv(gc).special)</a>
<a name="ln577">        env.tile_flv(gc).special = hash_with_seed(256, seed, 10);</a>
<a name="ln578">}</a>
<a name="ln579"> </a>
<a name="ln580">enum SpecialIdx</a>
<a name="ln581">{</a>
<a name="ln582">    SPECIAL_N    = 0,</a>
<a name="ln583">    SPECIAL_NE   = 1,</a>
<a name="ln584">    SPECIAL_E    = 2,</a>
<a name="ln585">    SPECIAL_SE   = 3,</a>
<a name="ln586">    SPECIAL_S    = 4,</a>
<a name="ln587">    SPECIAL_SW   = 5,</a>
<a name="ln588">    SPECIAL_W    = 6,</a>
<a name="ln589">    SPECIAL_NW   = 7,</a>
<a name="ln590">    SPECIAL_FULL = 8,</a>
<a name="ln591">};</a>
<a name="ln592"> </a>
<a name="ln593">static int _jitter(SpecialIdx i)</a>
<a name="ln594">{</a>
<a name="ln595">    return (i + random_range(-1, 1) + 8) % 8;</a>
<a name="ln596">}</a>
<a name="ln597"> </a>
<a name="ln598">static bool _adjacent_target(dungeon_feature_type target, int x, int y)</a>
<a name="ln599">{</a>
<a name="ln600">    for (adjacent_iterator ai(coord_def(x, y), false); ai; ++ai)</a>
<a name="ln601">    {</a>
<a name="ln602">        if (!map_bounds(*ai))</a>
<a name="ln603">            continue;</a>
<a name="ln604">        if (grd(*ai) == target)</a>
<a name="ln605">            return true;</a>
<a name="ln606">    }</a>
<a name="ln607"> </a>
<a name="ln608">    return false;</a>
<a name="ln609">}</a>
<a name="ln610"> </a>
<a name="ln611">void tile_floor_halo(dungeon_feature_type target, tileidx_t tile)</a>
<a name="ln612">{</a>
<a name="ln613">    for (int x = 0; x &lt; GXM; x++)</a>
<a name="ln614">    {</a>
<a name="ln615">        for (int y = 0; y &lt; GYM; y++)</a>
<a name="ln616">        {</a>
<a name="ln617">            if (!feat_has_dry_floor(grd[x][y]))</a>
<a name="ln618">                continue;</a>
<a name="ln619">            if (!_adjacent_target(target, x, y))</a>
<a name="ln620">                continue;</a>
<a name="ln621"> </a>
<a name="ln622">            bool l_flr = (x &gt; 0 &amp;&amp; feat_has_dry_floor(grd[x-1][y]));</a>
<a name="ln623">            bool r_flr = (x &lt; GXM - 1 &amp;&amp; feat_has_dry_floor(grd[x+1][y]));</a>
<a name="ln624">            bool u_flr = (y &gt; 0 &amp;&amp; feat_has_dry_floor(grd[x][y-1]));</a>
<a name="ln625">            bool d_flr = (y &lt; GYM - 1 &amp;&amp; feat_has_dry_floor(grd[x][y+1]));</a>
<a name="ln626"> </a>
<a name="ln627">            bool l_target = _adjacent_target(target, x-1, y);</a>
<a name="ln628">            bool r_target = _adjacent_target(target, x+1, y);</a>
<a name="ln629">            bool u_target = _adjacent_target(target, x, y-1);</a>
<a name="ln630">            bool d_target = _adjacent_target(target, x, y+1);</a>
<a name="ln631"> </a>
<a name="ln632">            // The special tiles contains part floor and part special, so</a>
<a name="ln633">            // if there are adjacent floor or special tiles, we should</a>
<a name="ln634">            // do our best to &quot;connect&quot; them appropriately. If there are</a>
<a name="ln635">            // are other tiles there (walls, doors, whatever...) then it</a>
<a name="ln636">            // doesn't matter.</a>
<a name="ln637">            bool l_nrm = (l_flr &amp;&amp; !l_target);</a>
<a name="ln638">            bool r_nrm = (r_flr &amp;&amp; !r_target);</a>
<a name="ln639">            bool u_nrm = (u_flr &amp;&amp; !u_target);</a>
<a name="ln640">            bool d_nrm = (d_flr &amp;&amp; !d_target);</a>
<a name="ln641"> </a>
<a name="ln642">            bool l_spc = (l_flr &amp;&amp; l_target);</a>
<a name="ln643">            bool r_spc = (r_flr &amp;&amp; r_target);</a>
<a name="ln644">            bool u_spc = (u_flr &amp;&amp; u_target);</a>
<a name="ln645">            bool d_spc = (d_flr &amp;&amp; d_target);</a>
<a name="ln646"> </a>
<a name="ln647">            if (l_nrm &amp;&amp; r_nrm || u_nrm &amp;&amp; d_nrm)</a>
<a name="ln648">            {</a>
<a name="ln649">                // Not much to do here...</a>
<a name="ln650">                env.tile_flv[x][y].floor = tile + SPECIAL_FULL;</a>
<a name="ln651">            }</a>
<a name="ln652">            else if (l_nrm)</a>
<a name="ln653">            {</a>
<a name="ln654">                if (u_nrm)</a>
<a name="ln655">                    env.tile_flv[x][y].floor = tile + SPECIAL_NW;</a>
<a name="ln656">                else if (d_nrm)</a>
<a name="ln657">                    env.tile_flv[x][y].floor = tile + SPECIAL_SW;</a>
<a name="ln658">                else if (u_spc &amp;&amp; d_spc)</a>
<a name="ln659">                    env.tile_flv[x][y].floor = tile + SPECIAL_W;</a>
<a name="ln660">                else if (u_spc &amp;&amp; r_spc)</a>
<a name="ln661">                    env.tile_flv[x][y].floor = tile + SPECIAL_SW;</a>
<a name="ln662">                else if (d_spc &amp;&amp; r_spc)</a>
<a name="ln663">                    env.tile_flv[x][y].floor = tile + SPECIAL_NW;</a>
<a name="ln664">                else if (u_spc)</a>
<a name="ln665">                {</a>
<a name="ln666">                    env.tile_flv[x][y].floor = tile + (coinflip() ?</a>
<a name="ln667">                        SPECIAL_W : SPECIAL_SW);</a>
<a name="ln668">                }</a>
<a name="ln669">                else if (d_spc)</a>
<a name="ln670">                {</a>
<a name="ln671">                    env.tile_flv[x][y].floor = tile + (coinflip() ?</a>
<a name="ln672">                        SPECIAL_W : SPECIAL_NW);</a>
<a name="ln673">                }</a>
<a name="ln674">                else</a>
<a name="ln675">                    env.tile_flv[x][y].floor = tile + _jitter(SPECIAL_W);</a>
<a name="ln676">            }</a>
<a name="ln677">            else if (r_nrm)</a>
<a name="ln678">            {</a>
<a name="ln679">                if (u_nrm)</a>
<a name="ln680">                    env.tile_flv[x][y].floor = tile + SPECIAL_NE;</a>
<a name="ln681">                else if (d_nrm)</a>
<a name="ln682">                    env.tile_flv[x][y].floor = tile + SPECIAL_SE;</a>
<a name="ln683">                else if (u_spc &amp;&amp; d_spc)</a>
<a name="ln684">                    env.tile_flv[x][y].floor = tile + SPECIAL_E;</a>
<a name="ln685">                else if (u_spc &amp;&amp; l_spc)</a>
<a name="ln686">                    env.tile_flv[x][y].floor = tile + SPECIAL_SE;</a>
<a name="ln687">                else if (d_spc &amp;&amp; l_spc)</a>
<a name="ln688">                    env.tile_flv[x][y].floor = tile + SPECIAL_NE;</a>
<a name="ln689">                else if (u_spc)</a>
<a name="ln690">                    env.tile_flv[x][y].floor = tile + (coinflip() ?</a>
<a name="ln691">                        SPECIAL_E : SPECIAL_SE);</a>
<a name="ln692">                else if (d_spc)</a>
<a name="ln693">                    env.tile_flv[x][y].floor = tile + (coinflip() ?</a>
<a name="ln694">                        SPECIAL_E : SPECIAL_NE);</a>
<a name="ln695">                else</a>
<a name="ln696">                    env.tile_flv[x][y].floor = tile + _jitter(SPECIAL_E);</a>
<a name="ln697">            }</a>
<a name="ln698">            else if (u_nrm)</a>
<a name="ln699">            {</a>
<a name="ln700">                if (r_spc &amp;&amp; l_spc)</a>
<a name="ln701">                    env.tile_flv[x][y].floor = tile + SPECIAL_N;</a>
<a name="ln702">                else if (r_spc &amp;&amp; d_spc)</a>
<a name="ln703">                    env.tile_flv[x][y].floor = tile + SPECIAL_NW;</a>
<a name="ln704">                else if (l_spc &amp;&amp; d_spc)</a>
<a name="ln705">                    env.tile_flv[x][y].floor = tile + SPECIAL_NE;</a>
<a name="ln706">                else if (r_spc)</a>
<a name="ln707">                {</a>
<a name="ln708">                    env.tile_flv[x][y].floor = tile + (coinflip() ?</a>
<a name="ln709">                        SPECIAL_N : SPECIAL_NW);</a>
<a name="ln710">                }</a>
<a name="ln711">                else if (l_spc)</a>
<a name="ln712">                {</a>
<a name="ln713">                    env.tile_flv[x][y].floor = tile + (coinflip() ?</a>
<a name="ln714">                        SPECIAL_N : SPECIAL_NE);</a>
<a name="ln715">                }</a>
<a name="ln716">                else</a>
<a name="ln717">                    env.tile_flv[x][y].floor = tile + _jitter(SPECIAL_N);</a>
<a name="ln718">            }</a>
<a name="ln719">            else if (d_nrm)</a>
<a name="ln720">            {</a>
<a name="ln721">                if (r_spc &amp;&amp; l_spc)</a>
<a name="ln722">                    env.tile_flv[x][y].floor = tile + SPECIAL_S;</a>
<a name="ln723">                else if (r_spc &amp;&amp; u_spc)</a>
<a name="ln724">                    env.tile_flv[x][y].floor = tile + SPECIAL_SW;</a>
<a name="ln725">                else if (l_spc &amp;&amp; u_spc)</a>
<a name="ln726">                    env.tile_flv[x][y].floor = tile + SPECIAL_SE;</a>
<a name="ln727">                else if (r_spc)</a>
<a name="ln728">                {</a>
<a name="ln729">                    env.tile_flv[x][y].floor = tile + (coinflip() ?</a>
<a name="ln730">                        SPECIAL_S : SPECIAL_SW);</a>
<a name="ln731">                }</a>
<a name="ln732">                else if (l_spc)</a>
<a name="ln733">                {</a>
<a name="ln734">                    env.tile_flv[x][y].floor = tile + (coinflip() ?</a>
<a name="ln735">                        SPECIAL_S : SPECIAL_SE);</a>
<a name="ln736">                }</a>
<a name="ln737">                else</a>
<a name="ln738">                    env.tile_flv[x][y].floor = tile + _jitter(SPECIAL_S);</a>
<a name="ln739">            }</a>
<a name="ln740">            else if (u_spc &amp;&amp; d_spc)</a>
<a name="ln741">            {</a>
<a name="ln742">                // We know this value is already initialised and</a>
<a name="ln743">                // is necessarily in bounds.</a>
<a name="ln744">                tileidx_t t = env.tile_flv[x][y-1].floor - tile;</a>
<a name="ln745">                if (t == SPECIAL_NE || t == SPECIAL_E)</a>
<a name="ln746">                    env.tile_flv[x][y].floor = tile + SPECIAL_E;</a>
<a name="ln747">                else if (t == SPECIAL_NW || t == SPECIAL_W)</a>
<a name="ln748">                    env.tile_flv[x][y].floor = tile + SPECIAL_W;</a>
<a name="ln749">                else</a>
<a name="ln750">                    env.tile_flv[x][y].floor = tile + SPECIAL_FULL;</a>
<a name="ln751">            }</a>
<a name="ln752">            else if (r_spc &amp;&amp; l_spc)</a>
<a name="ln753">            {</a>
<a name="ln754">                // We know this value is already initialised and</a>
<a name="ln755">                // is necessarily in bounds.</a>
<a name="ln756">                tileidx_t t = env.tile_flv[x-1][y].floor - tile;</a>
<a name="ln757">                if (t == SPECIAL_NW || t == SPECIAL_N)</a>
<a name="ln758">                    env.tile_flv[x][y].floor = tile + SPECIAL_N;</a>
<a name="ln759">                else if (t == SPECIAL_SW || t == SPECIAL_S)</a>
<a name="ln760">                    env.tile_flv[x][y].floor = tile + SPECIAL_S;</a>
<a name="ln761">                else</a>
<a name="ln762">                    env.tile_flv[x][y].floor = tile + SPECIAL_FULL;</a>
<a name="ln763">            }</a>
<a name="ln764">            else if (u_spc &amp;&amp; l_spc)</a>
<a name="ln765">                env.tile_flv[x][y].floor = tile + SPECIAL_SE;</a>
<a name="ln766">            else if (u_spc &amp;&amp; r_spc)</a>
<a name="ln767">                env.tile_flv[x][y].floor = tile + SPECIAL_SW;</a>
<a name="ln768">            else if (d_spc &amp;&amp; l_spc)</a>
<a name="ln769">                env.tile_flv[x][y].floor = tile + SPECIAL_NE;</a>
<a name="ln770">            else if (d_spc &amp;&amp; r_spc)</a>
<a name="ln771">                env.tile_flv[x][y].floor = tile + SPECIAL_NW;</a>
<a name="ln772">            else</a>
<a name="ln773">                env.tile_flv[x][y].floor = tile + SPECIAL_FULL;</a>
<a name="ln774">        }</a>
<a name="ln775">    }</a>
<a name="ln776"> </a>
<a name="ln777">    // Second pass for clean up. The only bad part about the above</a>
<a name="ln778">    // algorithm is that it could turn a block of floor like this:</a>
<a name="ln779">    //</a>
<a name="ln780">    // N4NN</a>
<a name="ln781">    // 3125</a>
<a name="ln782">    // NN6N</a>
<a name="ln783">    //</a>
<a name="ln784">    // (KEY: N = normal floor, # = special floor)</a>
<a name="ln785">    //</a>
<a name="ln786">    // Into these flavours:</a>
<a name="ln787">    // 1 - SPECIAL_S</a>
<a name="ln788">    // 2 - SPECIAL_N</a>
<a name="ln789">    // 3-6, not important</a>
<a name="ln790">    //</a>
<a name="ln791">    // Generally the tiles don't fit with a north to the right or left</a>
<a name="ln792">    // of a south tile. What we really want to do is to separate the</a>
<a name="ln793">    // two regions, by making 1 a SPECIAL_SE and 2 a SPECIAL_NW tile.</a>
<a name="ln794">    for (int y = 0; y &lt; GYM - 1; ++y)</a>
<a name="ln795">        for (int x = 0; x &lt; GXM - 1; ++x)</a>
<a name="ln796">        {</a>
<a name="ln797">            int this_spc = env.tile_flv[x][y].floor - tile;</a>
<a name="ln798">            if (this_spc &lt; 0 || this_spc &gt; 8)</a>
<a name="ln799">                continue;</a>
<a name="ln800"> </a>
<a name="ln801">            if (this_spc != SPECIAL_N &amp;&amp; this_spc != SPECIAL_S</a>
<a name="ln802">                &amp;&amp; this_spc != SPECIAL_E &amp;&amp; this_spc != SPECIAL_W)</a>
<a name="ln803">            {</a>
<a name="ln804">                continue;</a>
<a name="ln805">            }</a>
<a name="ln806"> </a>
<a name="ln807">            // TODO: these conditions are guaranteed?</a>
<a name="ln808">            int right_spc = x &lt; GXM - 1 ? env.tile_flv[x+1][y].floor - tile</a>
<a name="ln809">                                        : int{SPECIAL_FULL};</a>
<a name="ln810">            int down_spc  = y &lt; GYM - 1 ? env.tile_flv[x][y+1].floor - tile</a>
<a name="ln811">                                        : int{SPECIAL_FULL};</a>
<a name="ln812"> </a>
<a name="ln813">            if (this_spc == SPECIAL_N &amp;&amp; right_spc == SPECIAL_S)</a>
<a name="ln814">            {</a>
<a name="ln815">                env.tile_flv[x][y].floor = tile + SPECIAL_NE;</a>
<a name="ln816">                env.tile_flv[x+1][y].floor = tile + SPECIAL_SW;</a>
<a name="ln817">            }</a>
<a name="ln818">            else if (this_spc == SPECIAL_S &amp;&amp; right_spc == SPECIAL_N)</a>
<a name="ln819">            {</a>
<a name="ln820">                env.tile_flv[x][y].floor = tile + SPECIAL_SE;</a>
<a name="ln821">                env.tile_flv[x+1][y].floor = tile + SPECIAL_NW;</a>
<a name="ln822">            }</a>
<a name="ln823">            else if (this_spc == SPECIAL_E &amp;&amp; down_spc == SPECIAL_W)</a>
<a name="ln824">            {</a>
<a name="ln825">                env.tile_flv[x][y].floor = tile + SPECIAL_SE;</a>
<a name="ln826">                env.tile_flv[x][y+1].floor = tile + SPECIAL_NW;</a>
<a name="ln827">            }</a>
<a name="ln828">            else if (this_spc == SPECIAL_W &amp;&amp; down_spc == SPECIAL_E)</a>
<a name="ln829">            {</a>
<a name="ln830">                env.tile_flv[x][y].floor = tile + SPECIAL_NE;</a>
<a name="ln831">                env.tile_flv[x][y+1].floor = tile + SPECIAL_SW;</a>
<a name="ln832">            }</a>
<a name="ln833">        }</a>
<a name="ln834">}</a>
<a name="ln835"> </a>
<a name="ln836">#ifdef USE_TILE</a>
<a name="ln837">static tileidx_t _get_floor_bg(const coord_def&amp; gc)</a>
<a name="ln838">{</a>
<a name="ln839">    tileidx_t bg = TILE_DNGN_UNSEEN | tileidx_unseen_flag(gc);</a>
<a name="ln840"> </a>
<a name="ln841">    if (map_bounds(gc))</a>
<a name="ln842">    {</a>
<a name="ln843">        bg = tileidx_feature(gc);</a>
<a name="ln844"> </a>
<a name="ln845">        if (is_unknown_stair(gc)</a>
<a name="ln846">            &amp;&amp; env.map_knowledge(gc).feat() != DNGN_ENTER_ZOT</a>
<a name="ln847">            &amp;&amp; !(player_in_hell()</a>
<a name="ln848">                 &amp;&amp; env.map_knowledge(gc).feat() == DNGN_ENTER_HELL))</a>
<a name="ln849">        {</a>
<a name="ln850">            bg |= TILE_FLAG_NEW_STAIR;</a>
<a name="ln851">        }</a>
<a name="ln852">        else if (is_unknown_transporter(gc))</a>
<a name="ln853">            bg |= TILE_FLAG_NEW_TRANSPORTER;</a>
<a name="ln854">    }</a>
<a name="ln855"> </a>
<a name="ln856">    return bg;</a>
<a name="ln857">}</a>
<a name="ln858"> </a>
<a name="ln859">void tile_draw_floor()</a>
<a name="ln860">{</a>
<a name="ln861">    for (int cy = 0; cy &lt; env.tile_fg.height(); cy++)</a>
<a name="ln862">        for (int cx = 0; cx &lt; env.tile_fg.width(); cx++)</a>
<a name="ln863">        {</a>
<a name="ln864">            const coord_def ep(cx, cy);</a>
<a name="ln865">            const coord_def gc = show2grid(ep);</a>
<a name="ln866"> </a>
<a name="ln867">            tileidx_t bg = _get_floor_bg(gc);</a>
<a name="ln868"> </a>
<a name="ln869">            // init tiles</a>
<a name="ln870">            env.tile_bg(ep) = bg;</a>
<a name="ln871">            env.tile_fg(ep) = 0;</a>
<a name="ln872">            env.tile_cloud(ep) = 0;</a>
<a name="ln873">        }</a>
<a name="ln874">}</a>
<a name="ln875"> </a>
<a name="ln876">void tile_clear_map(const coord_def&amp; gc)</a>
<a name="ln877">{</a>
<a name="ln878">    env.tile_bk_fg(gc) = 0;</a>
<a name="ln879">    env.tile_bk_cloud(gc) = 0;</a>
<a name="ln880">    tiles.update_minimap(gc);</a>
<a name="ln881">}</a>
<a name="ln882"> </a>
<a name="ln883">void tile_forget_map(const coord_def &amp;gc)</a>
<a name="ln884">{</a>
<a name="ln885">    env.tile_bk_fg(gc) = 0;</a>
<a name="ln886">    env.tile_bk_bg(gc) = 0;</a>
<a name="ln887">    env.tile_bk_cloud(gc) = 0;</a>
<a name="ln888">    // This may have changed the explore horizon, so update adjacent minimap</a>
<a name="ln889">    // squares as well.</a>
<a name="ln890">    for (adjacent_iterator ai(gc, false); ai; ++ai)</a>
<a name="ln891">        tiles.update_minimap(*ai);</a>
<a name="ln892">}</a>
<a name="ln893"> </a>
<a name="ln894">static void _tile_place_item(const coord_def &amp;gc, const item_info &amp;item,</a>
<a name="ln895">                             bool more_items)</a>
<a name="ln896">{</a>
<a name="ln897">    tileidx_t t = tileidx_item(item);</a>
<a name="ln898">    if (more_items)</a>
<a name="ln899">        t |= TILE_FLAG_S_UNDER;</a>
<a name="ln900"> </a>
<a name="ln901">    if (you.see_cell(gc))</a>
<a name="ln902">    {</a>
<a name="ln903">        const coord_def ep = crawl_view.grid2show(gc);</a>
<a name="ln904">        if (env.tile_fg(ep))</a>
<a name="ln905">            return;</a>
<a name="ln906"> </a>
<a name="ln907">        env.tile_fg(ep) = t;</a>
<a name="ln908"> </a>
<a name="ln909">        if (item_needs_autopickup(item))</a>
<a name="ln910">            env.tile_bg(ep) |= TILE_FLAG_CURSOR3;</a>
<a name="ln911">    }</a>
<a name="ln912">    else</a>
<a name="ln913">    {</a>
<a name="ln914">        env.tile_bk_fg(gc) = t;</a>
<a name="ln915"> </a>
<a name="ln916">        if (item_needs_autopickup(item))</a>
<a name="ln917">            env.tile_bk_bg(gc) |= TILE_FLAG_CURSOR3;</a>
<a name="ln918">    }</a>
<a name="ln919">}</a>
<a name="ln920"> </a>
<a name="ln921">static void _tile_place_item_marker(const coord_def &amp;gc, const item_def &amp;item)</a>
<a name="ln922">{</a>
<a name="ln923">    if (you.see_cell(gc))</a>
<a name="ln924">    {</a>
<a name="ln925">        const coord_def ep = crawl_view.grid2show(gc);</a>
<a name="ln926">        env.tile_fg(ep) |= TILE_FLAG_S_UNDER;</a>
<a name="ln927"> </a>
<a name="ln928">        if (item_needs_autopickup(item))</a>
<a name="ln929">            env.tile_bg(ep) |= TILE_FLAG_CURSOR3;</a>
<a name="ln930">    }</a>
<a name="ln931">    else</a>
<a name="ln932">    {</a>
<a name="ln933">        env.tile_bk_fg(gc) = ((tileidx_t) env.tile_bk_fg(gc)) | TILE_FLAG_S_UNDER;</a>
<a name="ln934"> </a>
<a name="ln935">        if (item_needs_autopickup(item))</a>
<a name="ln936">            env.tile_bk_bg(gc) |= TILE_FLAG_CURSOR3;</a>
<a name="ln937">    }</a>
<a name="ln938">}</a>
<a name="ln939"> </a>
<a name="ln940">/**</a>
<a name="ln941"> * Place the tile for an unseen monster's disturbance.</a>
<a name="ln942"> *</a>
<a name="ln943"> * @param gc    The disturbance's map position.</a>
<a name="ln944">**/</a>
<a name="ln945">static void _tile_place_invisible_monster(const coord_def &amp;gc)</a>
<a name="ln946">{</a>
<a name="ln947">    const coord_def ep = grid2show(gc);</a>
<a name="ln948">    const map_cell&amp; cell = env.map_knowledge(gc);</a>
<a name="ln949"> </a>
<a name="ln950">    // Shallow water has its own modified tile for disturbances</a>
<a name="ln951">    // see tileidx_feature</a>
<a name="ln952">    // That tile is hidden by clouds though</a>
<a name="ln953">    if (cell.feat() != DNGN_SHALLOW_WATER || cell.cloud() != CLOUD_NONE)</a>
<a name="ln954">    {</a>
<a name="ln955">        if (you.see_cell(gc))</a>
<a name="ln956">            env.tile_fg(ep) = TILE_UNSEEN_MONSTER;</a>
<a name="ln957">        else</a>
<a name="ln958">            env.tile_bk_fg(gc) = TILE_UNSEEN_MONSTER;</a>
<a name="ln959">    }</a>
<a name="ln960"> </a>
<a name="ln961">    if (env.map_knowledge(gc).item())</a>
<a name="ln962">        _tile_place_item_marker(gc, *env.map_knowledge(gc).item());</a>
<a name="ln963">}</a>
<a name="ln964"> </a>
<a name="ln965">static void _tile_place_monster(const coord_def &amp;gc, const monster_info&amp; mon)</a>
<a name="ln966">{</a>
<a name="ln967">    const coord_def ep = grid2show(gc);</a>
<a name="ln968"> </a>
<a name="ln969">    tileidx_t t    = tileidx_monster(mon);</a>
<a name="ln970">    tileidx_t t0   = t &amp; TILE_FLAG_MASK;</a>
<a name="ln971">    tileidx_t flag = t &amp; (~TILE_FLAG_MASK);</a>
<a name="ln972"> </a>
<a name="ln973">    if (mons_class_is_stationary(mon.type)</a>
<a name="ln974">        &amp;&amp; mon.type != MONS_TRAINING_DUMMY)</a>
<a name="ln975">    {</a>
<a name="ln976">        // If necessary add item brand.</a>
<a name="ln977">        if (env.map_knowledge(gc).item())</a>
<a name="ln978">        {</a>
<a name="ln979">            t |= TILE_FLAG_S_UNDER;</a>
<a name="ln980"> </a>
<a name="ln981">            if (item_needs_autopickup(*env.map_knowledge(gc).item()))</a>
<a name="ln982">            {</a>
<a name="ln983">                if (you.see_cell(gc))</a>
<a name="ln984">                    env.tile_bg(ep) |= TILE_FLAG_CURSOR3;</a>
<a name="ln985">                else</a>
<a name="ln986">                    env.tile_bk_bg(gc) |= TILE_FLAG_CURSOR3;</a>
<a name="ln987">            }</a>
<a name="ln988">        }</a>
<a name="ln989">    }</a>
<a name="ln990">    else</a>
<a name="ln991">    {</a>
<a name="ln992">        tileidx_t mcache_idx = mcache.register_monster(mon);</a>
<a name="ln993">        t = flag | (mcache_idx ? mcache_idx : t0);</a>
<a name="ln994">    }</a>
<a name="ln995"> </a>
<a name="ln996">    if (!you.see_cell(gc))</a>
<a name="ln997">    {</a>
<a name="ln998">        env.tile_bk_fg(gc) = t;</a>
<a name="ln999">        return;</a>
<a name="ln1000">    }</a>
<a name="ln1001">    env.tile_fg(ep) = t;</a>
<a name="ln1002"> </a>
<a name="ln1003">    // Add name tags.</a>
<a name="ln1004">    if (!mons_class_gives_xp(mon.type))</a>
<a name="ln1005">        return;</a>
<a name="ln1006"> </a>
<a name="ln1007">    const tag_pref pref = Options.tile_tag_pref;</a>
<a name="ln1008">    if (pref == TAGPREF_NONE)</a>
<a name="ln1009">        return;</a>
<a name="ln1010">    else if (pref == TAGPREF_TUTORIAL)</a>
<a name="ln1011">    {</a>
<a name="ln1012">        const int kills = you.kills.num_kills(mon);</a>
<a name="ln1013">        const int limit  = 0;</a>
<a name="ln1014"> </a>
<a name="ln1015">        if (!mon.is_named() &amp;&amp; kills &gt; limit)</a>
<a name="ln1016">            return;</a>
<a name="ln1017">    }</a>
<a name="ln1018">    else if (!mon.is_named())</a>
<a name="ln1019">        return;</a>
<a name="ln1020"> </a>
<a name="ln1021">    if (pref != TAGPREF_NAMED &amp;&amp; mon.attitude == ATT_FRIENDLY)</a>
<a name="ln1022">        return;</a>
<a name="ln1023"> </a>
<a name="ln1024">    tiles.add_text_tag(TAG_NAMED_MONSTER, mon);</a>
<a name="ln1025">}</a>
<a name="ln1026"> </a>
<a name="ln1027">void tile_reset_fg(const coord_def &amp;gc)</a>
<a name="ln1028">{</a>
<a name="ln1029">    // remove autopickup cursor, it will be added back if necessary</a>
<a name="ln1030">    env.tile_bk_bg(gc) &amp;= ~TILE_FLAG_CURSOR3;</a>
<a name="ln1031">    tile_draw_map_cell(gc, true);</a>
<a name="ln1032">    tiles.update_minimap(gc);</a>
<a name="ln1033">}</a>
<a name="ln1034"> </a>
<a name="ln1035">void tile_reset_feat(const coord_def &amp;gc)</a>
<a name="ln1036">{</a>
<a name="ln1037">    env.tile_bk_bg(gc) = tileidx_feature(gc);</a>
<a name="ln1038">}</a>
<a name="ln1039"> </a>
<a name="ln1040">static void _tile_place_cloud(const coord_def &amp;gc, const cloud_info &amp;cl)</a>
<a name="ln1041">{</a>
<a name="ln1042">    if (you.see_cell(gc))</a>
<a name="ln1043">    {</a>
<a name="ln1044">        const coord_def ep = grid2show(gc);</a>
<a name="ln1045">        env.tile_cloud(ep) = tileidx_cloud(cl);</a>
<a name="ln1046">    }</a>
<a name="ln1047">    else</a>
<a name="ln1048">        env.tile_bk_cloud(gc) = tileidx_cloud(cl);</a>
<a name="ln1049">}</a>
<a name="ln1050"> </a>
<a name="ln1051">unsigned int num_tile_rays = 0;</a>
<a name="ln1052">struct tile_ray</a>
<a name="ln1053">{</a>
<a name="ln1054">    coord_def ep;</a>
<a name="ln1055">    aff_type in_range;</a>
<a name="ln1056">};</a>
<a name="ln1057">// Allow the rays to fill the whole visible area if necessary. The size is</a>
<a name="ln1058">// about 4/pi times larger than it needs to be, but this way supports squarelos</a>
<a name="ln1059">// as well.</a>
<a name="ln1060">FixedVector&lt;tile_ray, ENV_SHOW_DIAMETER * ENV_SHOW_DIAMETER&gt; tile_ray_vec;</a>
<a name="ln1061"> </a>
<a name="ln1062">void tile_place_ray(const coord_def &amp;gc, aff_type in_range)</a>
<a name="ln1063">{</a>
<a name="ln1064">    // Record rays for later. The curses version just applies</a>
<a name="ln1065">    // rays directly to the screen. The tiles version doesn't have</a>
<a name="ln1066">    // (nor want) such direct access. So, it batches up all of the</a>
<a name="ln1067">    // rays and applies them in viewwindow(...).</a>
<a name="ln1068">    ASSERT(num_tile_rays &lt; tile_ray_vec.size() - 1);</a>
<a name="ln1069">    tile_ray_vec[num_tile_rays].in_range = in_range;</a>
<a name="ln1070">    tile_ray_vec[num_tile_rays++].ep = grid2show(gc);</a>
<a name="ln1071">}</a>
<a name="ln1072"> </a>
<a name="ln1073">void tile_draw_rays(bool reset_count)</a>
<a name="ln1074">{</a>
<a name="ln1075">    tileidx_t flag = 0;</a>
<a name="ln1076"> </a>
<a name="ln1077">    for (unsigned int i = 0; i &lt; num_tile_rays; i++)</a>
<a name="ln1078">    {</a>
<a name="ln1079">        if (tile_ray_vec[i].in_range &lt; AFF_YES)</a>
<a name="ln1080">            flag = TILE_FLAG_RAY_OOR;</a>
<a name="ln1081">        else if (tile_ray_vec[i].in_range == AFF_YES)</a>
<a name="ln1082">            flag = TILE_FLAG_RAY;</a>
<a name="ln1083">        else if (tile_ray_vec[i].in_range == AFF_LANDING)</a>
<a name="ln1084">            flag = TILE_FLAG_LANDING;</a>
<a name="ln1085">        else if (tile_ray_vec[i].in_range == AFF_MULTIPLE)</a>
<a name="ln1086">            flag = TILE_FLAG_RAY_MULTI;</a>
<a name="ln1087">        env.tile_bg(tile_ray_vec[i].ep) |= flag;</a>
<a name="ln1088">    }</a>
<a name="ln1089"> </a>
<a name="ln1090">    if (reset_count)</a>
<a name="ln1091">        num_tile_rays = 0;</a>
<a name="ln1092">}</a>
<a name="ln1093"> </a>
<a name="ln1094">void tile_draw_map_cell(const coord_def&amp; gc, bool foreground_only)</a>
<a name="ln1095">{</a>
<a name="ln1096">    if (!foreground_only)</a>
<a name="ln1097">        env.tile_bk_bg(gc) = _get_floor_bg(gc);</a>
<a name="ln1098"> </a>
<a name="ln1099">    if (you.see_cell(gc))</a>
<a name="ln1100">    {</a>
<a name="ln1101">        env.tile_fg(grid2show(gc)) = 0;</a>
<a name="ln1102">        env.tile_cloud(grid2show(gc)) = 0;</a>
<a name="ln1103">    }</a>
<a name="ln1104"> </a>
<a name="ln1105">    const map_cell&amp; cell = env.map_knowledge(gc);</a>
<a name="ln1106"> </a>
<a name="ln1107">    if (cell.invisible_monster())</a>
<a name="ln1108">        _tile_place_invisible_monster(gc);</a>
<a name="ln1109">    else if (cell.monsterinfo())</a>
<a name="ln1110">        _tile_place_monster(gc, *cell.monsterinfo());</a>
<a name="ln1111">    else if (cell.item())</a>
<a name="ln1112">    {</a>
<a name="ln1113">        if (feat_is_stair(cell.feat()))</a>
<a name="ln1114">            _tile_place_item_marker(gc, *cell.item());</a>
<a name="ln1115">        else</a>
<a name="ln1116">            _tile_place_item(gc, *cell.item(), (cell.flags &amp; MAP_MORE_ITEMS) != 0);</a>
<a name="ln1117">    }</a>
<a name="ln1118">    else</a>
<a name="ln1119">        env.tile_bk_fg(gc) = 0;</a>
<a name="ln1120"> </a>
<a name="ln1121">    // Always place clouds now they have their own layer</a>
<a name="ln1122">    if (cell.cloud() != CLOUD_NONE)</a>
<a name="ln1123">        _tile_place_cloud(gc, *cell.cloudinfo());</a>
<a name="ln1124">    else</a>
<a name="ln1125">        env.tile_bk_cloud(gc) = 0;</a>
<a name="ln1126">}</a>
<a name="ln1127"> </a>
<a name="ln1128">void tile_wizmap_terrain(const coord_def &amp;gc)</a>
<a name="ln1129">{</a>
<a name="ln1130">    env.tile_bk_bg(gc) = tileidx_feature(gc);</a>
<a name="ln1131">}</a>
<a name="ln1132"> </a>
<a name="ln1133">static bool _is_torch(tileidx_t basetile)</a>
<a name="ln1134">{</a>
<a name="ln1135">    return basetile == TILE_WALL_BRICK_DARK_2_TORCH</a>
<a name="ln1136">           || basetile == TILE_WALL_BRICK_DARK_4_TORCH</a>
<a name="ln1137">           || basetile == TILE_WALL_BRICK_DARK_6_TORCH;</a>
<a name="ln1138">}</a>
<a name="ln1139"> </a>
<a name="ln1140">// Updates the &quot;flavour&quot; of tiles that are animated.</a>
<a name="ln1141">// Unfortunately, these are all hard-coded for now.</a>
<a name="ln1142">void tile_apply_animations(tileidx_t bg, tile_flavour *flv)</a>
<a name="ln1143">{</a>
<a name="ln1144">#ifndef USE_TILE_WEB</a>
<a name="ln1145">    tileidx_t bg_idx = bg &amp; TILE_FLAG_MASK;</a>
<a name="ln1146">    if (bg_idx == TILE_DNGN_PORTAL_WIZARD_LAB &amp;&amp; Options.tile_misc_anim)</a>
<a name="ln1147">        flv-&gt;special = (flv-&gt;special + 1) % tile_dngn_count(bg_idx);</a>
<a name="ln1148">    else if (bg_idx == TILE_DNGN_LAVA &amp;&amp; Options.tile_water_anim)</a>
<a name="ln1149">    {</a>
<a name="ln1150">        // Lava tiles are four sets of four tiles (the second and fourth</a>
<a name="ln1151">        // sets are the same). This cycles between the four sets, picking</a>
<a name="ln1152">        // a random element from each set.</a>
<a name="ln1153">        flv-&gt;special = ((flv-&gt;special - ((flv-&gt;special % 4)))</a>
<a name="ln1154">                        + 4 + random2(4)) % tile_dngn_count(bg_idx);</a>
<a name="ln1155">    }</a>
<a name="ln1156">    else if (bg_idx &gt; TILE_DNGN_LAVA &amp;&amp; bg_idx &lt; TILE_FLOOR_MAX</a>
<a name="ln1157">             &amp;&amp; Options.tile_water_anim)</a>
<a name="ln1158">    {</a>
<a name="ln1159">        flv-&gt;special = random2(256);</a>
<a name="ln1160">    }</a>
<a name="ln1161">    else if (bg_idx &gt;= TILE_DNGN_ENTER_ZOT_CLOSED &amp;&amp; bg_idx &lt; TILE_BLOOD</a>
<a name="ln1162">             &amp;&amp; Options.tile_misc_anim)</a>
<a name="ln1163">    {</a>
<a name="ln1164">        flv-&gt;special = random2(256);</a>
<a name="ln1165">    }</a>
<a name="ln1166">    else if (bg_idx == TILE_WALL_NORMAL &amp;&amp; Options.tile_misc_anim)</a>
<a name="ln1167">    {</a>
<a name="ln1168">        tileidx_t basetile = tile_dngn_basetile(flv-&gt;wall);</a>
<a name="ln1169">        if (_is_torch(basetile))</a>
<a name="ln1170">            flv-&gt;wall = basetile + (flv-&gt;wall - basetile + 1) % tile_dngn_count(basetile);</a>
<a name="ln1171">    }</a>
<a name="ln1172">#else</a>
<a name="ln1173">    UNUSED(bg, flv);</a>
<a name="ln1174">#endif</a>
<a name="ln1175">}</a>
<a name="ln1176"> </a>
<a name="ln1177">static bool _suppress_blood(const map_cell&amp; mc)</a>
<a name="ln1178">{</a>
<a name="ln1179">    const dungeon_feature_type feat = mc.feat();</a>
<a name="ln1180">    if (feat_is_tree(feat))</a>
<a name="ln1181">        return true;</a>
<a name="ln1182"> </a>
<a name="ln1183">    if (feat == DNGN_DRY_FOUNTAIN)</a>
<a name="ln1184">        return true;</a>
<a name="ln1185"> </a>
<a name="ln1186">    if (feat_is_altar(feat))</a>
<a name="ln1187">        return true;</a>
<a name="ln1188"> </a>
<a name="ln1189">    if (feat_stair_direction(feat) != CMD_NO_CMD)</a>
<a name="ln1190">        return true;</a>
<a name="ln1191"> </a>
<a name="ln1192">    if (feat == DNGN_MALIGN_GATEWAY)</a>
<a name="ln1193">        return true;</a>
<a name="ln1194"> </a>
<a name="ln1195">    if (mc.trap() == TRAP_SHAFT)</a>
<a name="ln1196">        return true;</a>
<a name="ln1197"> </a>
<a name="ln1198">    return false;</a>
<a name="ln1199">}</a>
<a name="ln1200"> </a>
<a name="ln1201">static bool _suppress_blood(tileidx_t bg_idx)</a>
<a name="ln1202">{</a>
<a name="ln1203">    tileidx_t basetile = tile_dngn_basetile(bg_idx);</a>
<a name="ln1204">    return _is_torch(basetile);</a>
<a name="ln1205">}</a>
<a name="ln1206"> </a>
<a name="ln1207">// Specifically for vault-overwritten doors. We have three &quot;sets&quot; of tiles that</a>
<a name="ln1208">// can be dealt with. The tile sets should have size 2, 3, 8, or 9. They are:</a>
<a name="ln1209">//  2. Closed, open.</a>
<a name="ln1210">//  3. Runed, closed, open.</a>
<a name="ln1211">//  8. Closed, open, gate left closed, gate middle closed, gate right closed,</a>
<a name="ln1212">//     gate left open, gate middle open, gate right open.</a>
<a name="ln1213">//  9. Runed, closed, open, gate left closed, gate middle closed, gate right</a>
<a name="ln1214">//     closed, gate left open, gate middle open, gate right open.</a>
<a name="ln1215">static int _get_door_offset(tileidx_t base_tile, bool opened, bool runed,</a>
<a name="ln1216">                            int gateway_type)</a>
<a name="ln1217">{</a>
<a name="ln1218">    int count = tile_dngn_count(base_tile);</a>
<a name="ln1219">    if (count == 1)</a>
<a name="ln1220">        return 0;</a>
<a name="ln1221"> </a>
<a name="ln1222">    // The location of the default &quot;closed&quot; tile.</a>
<a name="ln1223">    int offset = 0;</a>
<a name="ln1224"> </a>
<a name="ln1225">    switch (count)</a>
<a name="ln1226">    {</a>
<a name="ln1227">    case 2:</a>
<a name="ln1228">        ASSERT(!runed);</a>
<a name="ln1229">        return opened ? 1: 0;</a>
<a name="ln1230">    case 3:</a>
<a name="ln1231">        if (opened)</a>
<a name="ln1232">            return 2;</a>
<a name="ln1233">        else if (runed)</a>
<a name="ln1234">            return 0;</a>
<a name="ln1235">        else</a>
<a name="ln1236">            return 1;</a>
<a name="ln1237">    case 8:</a>
<a name="ln1238">        ASSERT(!runed);</a>
<a name="ln1239">        // The closed door is at BASE_TILE for sets without runed doors</a>
<a name="ln1240">        offset = 0;</a>
<a name="ln1241">        break;</a>
<a name="ln1242">    case 9:</a>
<a name="ln1243">        // But is at BASE_TILE+1 for sets with them.</a>
<a name="ln1244">        offset = 1;</a>
<a name="ln1245">        break;</a>
<a name="ln1246">    default:</a>
<a name="ln1247">        // Passed a non-door tile base, pig out now.</a>
<a name="ln1248">        die(&quot;non-door tile&quot;);</a>
<a name="ln1249">    }</a>
<a name="ln1250"> </a>
<a name="ln1251">    // If we've reached this point, we're dealing with a gate.</a>
<a name="ln1252">    if (runed)</a>
<a name="ln1253">        return 0;</a>
<a name="ln1254"> </a>
<a name="ln1255">    if (!opened &amp;&amp; !runed &amp;&amp; gateway_type == 0)</a>
<a name="ln1256">        return 0;</a>
<a name="ln1257"> </a>
<a name="ln1258">    return offset + gateway_type;</a>
<a name="ln1259">}</a>
<a name="ln1260"> </a>
<a name="ln1261">void apply_variations(const tile_flavour &amp;flv, tileidx_t *bg,</a>
<a name="ln1262">                      const coord_def &amp;gc)</a>
<a name="ln1263">{</a>
<a name="ln1264">    tileidx_t orig = (*bg) &amp; TILE_FLAG_MASK;</a>
<a name="ln1265">    tileidx_t flag = (*bg) &amp; (~TILE_FLAG_MASK);</a>
<a name="ln1266"> </a>
<a name="ln1267">    // TODO: allow the stone type to be set in a cleaner way.</a>
<a name="ln1268">    if (player_in_branch(BRANCH_GAUNTLET))</a>
<a name="ln1269">    {</a>
<a name="ln1270">        if (orig == TILE_DNGN_STONE_WALL)</a>
<a name="ln1271">            orig = TILE_WALL_LAB_STONE;</a>
<a name="ln1272">        else if (orig == TILE_DNGN_METAL_WALL)</a>
<a name="ln1273">            orig = TILE_WALL_LAB_METAL;</a>
<a name="ln1274">        else if (orig == TILE_WALL_PERMAROCK)</a>
<a name="ln1275">            orig = TILE_WALL_PERMAROCK_BROWN;</a>
<a name="ln1276">    }</a>
<a name="ln1277">    else if (player_in_branch(BRANCH_CRYPT))</a>
<a name="ln1278">    {</a>
<a name="ln1279">        if (orig == TILE_DNGN_STONE_WALL)</a>
<a name="ln1280">            orig = TILE_WALL_CRYPT;</a>
<a name="ln1281">        else if (orig == TILE_DNGN_METAL_WALL)</a>
<a name="ln1282">            orig = TILE_WALL_CRYPT_METAL;</a>
<a name="ln1283">        else if (orig == TILE_DNGN_OPEN_DOOR)</a>
<a name="ln1284">            orig = TILE_DNGN_OPEN_DOOR_CRYPT;</a>
<a name="ln1285">        else if (orig == TILE_DNGN_CLOSED_DOOR)</a>
<a name="ln1286">            orig = TILE_DNGN_CLOSED_DOOR_CRYPT;</a>
<a name="ln1287">    }</a>
<a name="ln1288">    else if (player_in_branch(BRANCH_TOMB))</a>
<a name="ln1289">    {</a>
<a name="ln1290">        if (orig == TILE_DNGN_STONE_WALL)</a>
<a name="ln1291">            orig = TILE_WALL_TOMB;</a>
<a name="ln1292">    }</a>
<a name="ln1293">    else if (player_in_branch(BRANCH_DIS))</a>
<a name="ln1294">    {</a>
<a name="ln1295">        if (orig == TILE_DNGN_METAL_WALL)</a>
<a name="ln1296">            orig = TILE_DNGN_METAL_IRON;</a>
<a name="ln1297">        else if (orig == TILE_DNGN_CRYSTAL)</a>
<a name="ln1298">            orig = TILE_WALL_EMERALD;</a>
<a name="ln1299">    }</a>
<a name="ln1300">    else if (player_in_branch(BRANCH_COCYTUS))</a>
<a name="ln1301">    {</a>
<a name="ln1302">        if (orig == TILE_DNGN_STONE_WALL)</a>
<a name="ln1303">            orig = TILE_WALL_ICY_STONE;</a>
<a name="ln1304">    }</a>
<a name="ln1305">    else if (player_in_branch(BRANCH_TARTARUS))</a>
<a name="ln1306">    {</a>
<a name="ln1307">        if (orig == TILE_DNGN_STONE_WALL)</a>
<a name="ln1308">            orig = TILE_WALL_COBALT_STONE;</a>
<a name="ln1309">        else if (orig == TILE_DNGN_CRYSTAL)</a>
<a name="ln1310">            orig = TILE_WALL_EMERALD;</a>
<a name="ln1311">        else if (orig == TILE_DNGN_METAL_WALL)</a>
<a name="ln1312">            orig = TILE_DNGN_METAL_WALL_DARKGRAY;</a>
<a name="ln1313">    }</a>
<a name="ln1314">    else if (player_in_branch(BRANCH_GEHENNA))</a>
<a name="ln1315">    {</a>
<a name="ln1316">        if (orig == TILE_DNGN_STONE_WALL)</a>
<a name="ln1317">            orig = TILE_DNGN_STONE_WALL_RED;</a>
<a name="ln1318">        if (orig == TILE_DNGN_METAL_WALL)</a>
<a name="ln1319">            orig = TILE_DNGN_METAL_WALL_RED;</a>
<a name="ln1320">    }</a>
<a name="ln1321">    else if (player_in_branch(BRANCH_BAILEY))</a>
<a name="ln1322">    {</a>
<a name="ln1323">        if (orig == TILE_DNGN_STONE_WALL)</a>
<a name="ln1324">            orig = TILE_WALL_STONE_SMOOTH;</a>
<a name="ln1325">    }</a>
<a name="ln1326">    else if (player_in_branch(BRANCH_OSSUARY))</a>
<a name="ln1327">    {</a>
<a name="ln1328">        if (orig == TILE_DNGN_STONE_WALL)</a>
<a name="ln1329">            orig = TILE_DNGN_STONE_WALL_BROWN;</a>
<a name="ln1330">    }</a>
<a name="ln1331">    else if (player_in_branch(BRANCH_SLIME))</a>
<a name="ln1332">    {</a>
<a name="ln1333">        if (orig == TILE_DNGN_STONE_WALL)</a>
<a name="ln1334">            orig = TILE_STONE_WALL_SLIME;</a>
<a name="ln1335">    }</a>
<a name="ln1336">    else if (player_in_branch(BRANCH_VAULTS))</a>
<a name="ln1337">    {</a>
<a name="ln1338">        if (orig == TILE_DNGN_STONE_WALL)</a>
<a name="ln1339">            orig = TILE_STONE_WALL_VAULT;</a>
<a name="ln1340">    }</a>
<a name="ln1341"> </a>
<a name="ln1342">    if (orig == TILE_FLOOR_NORMAL)</a>
<a name="ln1343">        *bg = flv.floor;</a>
<a name="ln1344">    else if (orig == TILE_WALL_NORMAL)</a>
<a name="ln1345">        *bg = flv.wall;</a>
<a name="ln1346">    else if (orig == TILE_DNGN_STONE_WALL</a>
<a name="ln1347">             || orig == TILE_DNGN_CRYSTAL_WALL</a>
<a name="ln1348">             || orig == TILE_WALL_PERMAROCK</a>
<a name="ln1349">             || orig == TILE_WALL_PERMAROCK_CLEAR)</a>
<a name="ln1350">    {</a>
<a name="ln1351">        *bg = pick_dngn_tile(tile_dngn_coloured(orig, env.grid_colours(gc)),</a>
<a name="ln1352">                             flv.special);</a>
<a name="ln1353">    }</a>
<a name="ln1354">    else if (is_door_tile(orig))</a>
<a name="ln1355">    {</a>
<a name="ln1356">        tileidx_t override = flv.feat;</a>
<a name="ln1357">        // For vaults overriding door tiles, like Cigotuvi's Fleshworks.</a>
<a name="ln1358">        if (is_door_tile(override))</a>
<a name="ln1359">        {</a>
<a name="ln1360">            bool opened = (orig == TILE_DNGN_OPEN_DOOR);</a>
<a name="ln1361">            bool runed = (orig == TILE_DNGN_RUNED_DOOR);</a>
<a name="ln1362">            int offset = _get_door_offset(override, opened, runed, flv.special);</a>
<a name="ln1363">            *bg = override + offset;</a>
<a name="ln1364">        }</a>
<a name="ln1365">        else</a>
<a name="ln1366">            *bg = orig + min((int)flv.special, 6);</a>
<a name="ln1367">    }</a>
<a name="ln1368">    else if (orig == TILE_DNGN_PORTAL_WIZARD_LAB)</a>
<a name="ln1369">        *bg = orig + flv.special % tile_dngn_count(orig);</a>
<a name="ln1370">    else if ((orig == TILE_SHOALS_SHALLOW_WATER</a>
<a name="ln1371">              || orig == TILE_SHOALS_DEEP_WATER)</a>
<a name="ln1372">             &amp;&amp; element_colour(ETC_WAVES, 0, gc) == LIGHTCYAN)</a>
<a name="ln1373">    {</a>
<a name="ln1374">        *bg = orig + 6 + flv.special % 6;</a>
<a name="ln1375">    }</a>
<a name="ln1376">    else if (orig &lt; TILE_DNGN_MAX)</a>
<a name="ln1377">        *bg = pick_dngn_tile(orig, flv.special);</a>
<a name="ln1378"> </a>
<a name="ln1379">    *bg |= flag;</a>
<a name="ln1380">}</a>
<a name="ln1381"> </a>
<a name="ln1382">// If the top tile is a corpse, don't draw blood underneath.</a>
<a name="ln1383">static bool _top_item_is_corpse(const map_cell&amp; mc)</a>
<a name="ln1384">{</a>
<a name="ln1385">    const item_info* item = mc.item();</a>
<a name="ln1386">    return item &amp;&amp; item-&gt;is_type(OBJ_CORPSES, CORPSE_BODY);</a>
<a name="ln1387">}</a>
<a name="ln1388"> </a>
<a name="ln1389">static uint8_t _get_direction_index(const coord_def&amp; delta)</a>
<a name="ln1390">{</a>
<a name="ln1391">    if (delta.x ==  0 &amp;&amp; delta.y ==  1) return 1;</a>
<a name="ln1392">    if (delta.x == -1 &amp;&amp; delta.y ==  1) return 2;</a>
<a name="ln1393">    if (delta.x == -1 &amp;&amp; delta.y ==  0) return 3;</a>
<a name="ln1394">    if (delta.x == -1 &amp;&amp; delta.y == -1) return 4;</a>
<a name="ln1395">    if (delta.x ==  0 &amp;&amp; delta.y == -1) return 5;</a>
<a name="ln1396">    if (delta.x ==  1 &amp;&amp; delta.y == -1) return 6;</a>
<a name="ln1397">    if (delta.x ==  1 &amp;&amp; delta.y ==  0) return 7;</a>
<a name="ln1398">    if (delta.x ==  1 &amp;&amp; delta.y ==  1) return 8;</a>
<a name="ln1399">    return 0;</a>
<a name="ln1400">}</a>
<a name="ln1401"> </a>
<a name="ln1402">void tile_apply_properties(const coord_def &amp;gc, packed_cell &amp;cell)</a>
<a name="ln1403">{</a>
<a name="ln1404">    if (is_excluded(gc))</a>
<a name="ln1405">    {</a>
<a name="ln1406">        if (is_exclude_root(gc))</a>
<a name="ln1407">            cell.bg |= TILE_FLAG_EXCL_CTR;</a>
<a name="ln1408">        else</a>
<a name="ln1409">            cell.bg |= TILE_FLAG_TRAV_EXCL;</a>
<a name="ln1410">    }</a>
<a name="ln1411"> </a>
<a name="ln1412">    if (!map_bounds(gc))</a>
<a name="ln1413">        return;</a>
<a name="ln1414"> </a>
<a name="ln1415">    apply_variations(env.tile_flv(gc), &amp;cell.bg, gc);</a>
<a name="ln1416"> </a>
<a name="ln1417">    const map_cell&amp; mc = env.map_knowledge(gc);</a>
<a name="ln1418"> </a>
<a name="ln1419">    bool print_blood = true;</a>
<a name="ln1420">    if (mc.flags &amp; MAP_UMBRAED)</a>
<a name="ln1421">        cell.halo = HALO_UMBRA;</a>
<a name="ln1422">    else if (mc.flags &amp; MAP_HALOED)</a>
<a name="ln1423">        cell.halo = HALO_RANGE;</a>
<a name="ln1424">    else</a>
<a name="ln1425">        cell.halo = HALO_NONE;</a>
<a name="ln1426"> </a>
<a name="ln1427">    if (mc.monsterinfo() &amp;&amp; mc.monsterinfo()-&gt;is(MB_HIGHLIGHTED_SUMMONER))</a>
<a name="ln1428">        cell.is_highlighted_summoner = true;</a>
<a name="ln1429"> </a>
<a name="ln1430">    if (mc.flags &amp; MAP_LIQUEFIED)</a>
<a name="ln1431">        cell.is_liquefied = true;</a>
<a name="ln1432">    else if (print_blood &amp;&amp; (_suppress_blood(mc)</a>
<a name="ln1433">                             || _suppress_blood((cell.bg) &amp; TILE_FLAG_MASK)))</a>
<a name="ln1434">    {</a>
<a name="ln1435">        print_blood = false;</a>
<a name="ln1436">    }</a>
<a name="ln1437"> </a>
<a name="ln1438">    if (print_blood)</a>
<a name="ln1439">    {</a>
<a name="ln1440">        // Corpses have a blood puddle of their own.</a>
<a name="ln1441">        if (mc.flags &amp; MAP_BLOODY &amp;&amp; !_top_item_is_corpse(mc))</a>
<a name="ln1442">        {</a>
<a name="ln1443">            cell.is_bloody = true;</a>
<a name="ln1444">            cell.blood_rotation = blood_rotation(gc);</a>
<a name="ln1445">            cell.old_blood = bool(env.pgrid(gc) &amp; FPROP_OLD_BLOOD);</a>
<a name="ln1446">        }</a>
<a name="ln1447">    }</a>
<a name="ln1448"> </a>
<a name="ln1449">    const dungeon_feature_type feat = mc.feat();</a>
<a name="ln1450">    if (feat_is_water(feat) || feat == DNGN_LAVA)</a>
<a name="ln1451">        cell.bg |= TILE_FLAG_WATER;</a>
<a name="ln1452"> </a>
<a name="ln1453">    if ((mc.flags &amp; MAP_SANCTUARY_1) || (mc.flags &amp; MAP_SANCTUARY_2))</a>
<a name="ln1454">        cell.is_sanctuary = true;</a>
<a name="ln1455"> </a>
<a name="ln1456">    if (mc.flags &amp; MAP_SILENCED)</a>
<a name="ln1457">        cell.is_silenced = true;</a>
<a name="ln1458"> </a>
<a name="ln1459">    if (feat == DNGN_TREE &amp;&amp; player_in_branch(BRANCH_SWAMP))</a>
<a name="ln1460">        cell.mangrove_water = true;</a>
<a name="ln1461">    cell.awakened_forest = feat_is_tree(feat) &amp;&amp; env.forest_awoken_until;</a>
<a name="ln1462"> </a>
<a name="ln1463">    if (mc.flags &amp; MAP_ORB_HALOED)</a>
<a name="ln1464">        cell.orb_glow = get_orb_phase(gc) ? 2 : 1;</a>
<a name="ln1465"> </a>
<a name="ln1466">#if TAG_MAJOR_VERSION == 34</a>
<a name="ln1467">    if (mc.flags &amp; MAP_HOT)</a>
<a name="ln1468">        cell.heat_aura = 1 + random2(3);</a>
<a name="ln1469">#endif</a>
<a name="ln1470"> </a>
<a name="ln1471">    if (mc.flags &amp; MAP_QUAD_HALOED)</a>
<a name="ln1472">        cell.quad_glow = true;</a>
<a name="ln1473"> </a>
<a name="ln1474">    if (mc.flags &amp; MAP_DISJUNCT)</a>
<a name="ln1475">        cell.disjunct = get_disjunct_phase(gc);</a>
<a name="ln1476"> </a>
<a name="ln1477">    if (Options.show_travel_trail)</a>
<a name="ln1478">    {</a>
<a name="ln1479">        int tt_idx = travel_trail_index(gc);</a>
<a name="ln1480">        if (tt_idx &gt;= 0 &amp;&amp; tt_idx &lt; (int) env.travel_trail.size() - 1)</a>
<a name="ln1481">        {</a>
<a name="ln1482">            if (tt_idx &gt; 0)</a>
<a name="ln1483">            {</a>
<a name="ln1484">                coord_def delta = gc - env.travel_trail[tt_idx-1];</a>
<a name="ln1485">                cell.travel_trail = _get_direction_index(delta);</a>
<a name="ln1486">            }</a>
<a name="ln1487">            if (tt_idx &lt; (int) env.travel_trail.size() - 1)</a>
<a name="ln1488">            {</a>
<a name="ln1489">                coord_def delta = gc - env.travel_trail[tt_idx+1];</a>
<a name="ln1490">                cell.travel_trail |= _get_direction_index(delta) &lt;&lt; 4;</a>
<a name="ln1491">            }</a>
<a name="ln1492">        }</a>
<a name="ln1493">    }</a>
<a name="ln1494"> </a>
<a name="ln1495">    cell.flv = env.tile_flv(gc);</a>
<a name="ln1496">}</a>
<a name="ln1497">#endif</a>

</code></pre>
<div class="balloon" rel="95"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v1037/" target="_blank">V1037</a> Two or more case-branches perform the same actions. Check lines: 95, 281</p></div>
<div class="balloon" rel="105"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v1037/" target="_blank">V1037</a> Two or more case-branches perform the same actions. Check lines: 105, 243</p></div>
<div class="balloon" rel="808"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v547/" target="_blank">V547</a> Expression 'x < 80 - 1' is always true.</p></div>
<div class="balloon" rel="810"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v547/" target="_blank">V547</a> Expression 'y < 70 - 1' is always true.</p></div>
<div class="balloon" rel="1255"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v560/" target="_blank">V560</a> A part of conditional expression is always true: !runed.</p></div>

<link rel="stylesheet" href="highlight.css">
<script src="highlight.pack.js"></script>
<script src="highlightjs-line-numbers.js"></script>
<script>hljs.initHighlightingOnLoad();</script>
<script>hljs.initLineNumbersOnLoad();</script>
<script>
  $(document).ready(function() {
      $('.balloon').each(function () {
          var bl = $(this);
          var line = bl.attr('rel');
          var text = $('a[name="ln'+line+'"]').text();

          var space_count = 0;
          for(var i = 0; i<text.length; i++){
              var char = text[i];
              if((char !== ' ')&&(char !== '\t'))break;
              if(char === '\t')space_count++;
              space_count++;
          }

          bl.css('margin-left', space_count*8);
          $('a[name="ln'+line+'"]').after(bl);
      });

      window.location = window.location;
  });
</script>
</body>
</html>
