
<html>
<head>

  <meta http-equiv="Content-Type" content="text/html; charset=US-ASCII" />
  <title>mon-util.cc</title>

  <link rel="stylesheet" href="../style.css"/>
  <script src="../jquery-3.2.1.min.js"></script>
</head>
<body>

<pre><code class = "cpp">
<a name="ln1">/**</a>
<a name="ln2"> * @file</a>
<a name="ln3"> * @brief Misc monster related functions.</a>
<a name="ln4">**/</a>
<a name="ln5"> </a>
<a name="ln6">#include &quot;AppHdr.h&quot;</a>
<a name="ln7"> </a>
<a name="ln8">#include &quot;mon-util.h&quot;</a>
<a name="ln9"> </a>
<a name="ln10">#include &lt;algorithm&gt;</a>
<a name="ln11">#include &lt;cmath&gt;</a>
<a name="ln12">#include &lt;sstream&gt;</a>
<a name="ln13"> </a>
<a name="ln14">#include &quot;act-iter.h&quot;</a>
<a name="ln15">#include &quot;areas.h&quot;</a>
<a name="ln16">#include &quot;artefact.h&quot;</a>
<a name="ln17">#include &quot;attitude-change.h&quot;</a>
<a name="ln18">#include &quot;beam.h&quot;</a>
<a name="ln19">#include &quot;cloud.h&quot;</a>
<a name="ln20">#include &quot;colour.h&quot;</a>
<a name="ln21">#include &quot;coordit.h&quot;</a>
<a name="ln22">#include &quot;database.h&quot;</a>
<a name="ln23">#include &quot;delay.h&quot;</a>
<a name="ln24">#include &quot;dgn-overview.h&quot;</a>
<a name="ln25">#include &quot;directn.h&quot;</a>
<a name="ln26">#include &quot;dungeon.h&quot;</a>
<a name="ln27">#include &quot;english.h&quot;</a>
<a name="ln28">#include &quot;env.h&quot;</a>
<a name="ln29">#include &quot;errors.h&quot;</a>
<a name="ln30">#include &quot;fight.h&quot;</a>
<a name="ln31">#include &quot;files.h&quot;</a>
<a name="ln32">#include &quot;food.h&quot;</a>
<a name="ln33">#include &quot;fprop.h&quot;</a>
<a name="ln34">#include &quot;ghost.h&quot;</a>
<a name="ln35">#include &quot;god-item.h&quot;</a>
<a name="ln36">#include &quot;god-passive.h&quot;</a>
<a name="ln37">#include &quot;item-name.h&quot;</a>
<a name="ln38">#include &quot;item-prop.h&quot;</a>
<a name="ln39">#include &quot;items.h&quot;</a>
<a name="ln40">#include &quot;libutil.h&quot;</a>
<a name="ln41">#include &quot;mapmark.h&quot;</a>
<a name="ln42">#include &quot;message.h&quot;</a>
<a name="ln43">#include &quot;mgen-data.h&quot;</a>
<a name="ln44">#include &quot;mon-abil.h&quot;</a>
<a name="ln45">#include &quot;mon-behv.h&quot;</a>
<a name="ln46">#include &quot;mon-book.h&quot;</a>
<a name="ln47">#include &quot;mon-death.h&quot;</a>
<a name="ln48">#include &quot;mon-place.h&quot;</a>
<a name="ln49">#include &quot;mon-poly.h&quot;</a>
<a name="ln50">#include &quot;mon-tentacle.h&quot;</a>
<a name="ln51">#include &quot;mutant-beast.h&quot;</a>
<a name="ln52">#include &quot;notes.h&quot;</a>
<a name="ln53">#include &quot;options.h&quot;</a>
<a name="ln54">#include &quot;random.h&quot;</a>
<a name="ln55">#include &quot;reach-type.h&quot;</a>
<a name="ln56">#include &quot;religion.h&quot;</a>
<a name="ln57">#include &quot;showsymb.h&quot;</a>
<a name="ln58">#include &quot;species.h&quot;</a>
<a name="ln59">#include &quot;spl-util.h&quot;</a>
<a name="ln60">#include &quot;state.h&quot;</a>
<a name="ln61">#include &quot;stringutil.h&quot;</a>
<a name="ln62">#include &quot;terrain.h&quot;</a>
<a name="ln63">#include &quot;rltiles/tiledef-player.h&quot;</a>
<a name="ln64">#include &quot;tilepick.h&quot;</a>
<a name="ln65">#include &quot;tileview.h&quot;</a>
<a name="ln66">#include &quot;timed-effects.h&quot;</a>
<a name="ln67">#include &quot;traps.h&quot;</a>
<a name="ln68">#include &quot;unicode.h&quot;</a>
<a name="ln69">#include &quot;unwind.h&quot;</a>
<a name="ln70"> </a>
<a name="ln71">static FixedVector &lt; int, NUM_MONSTERS &gt; mon_entry;</a>
<a name="ln72"> </a>
<a name="ln73">struct mon_display</a>
<a name="ln74">{</a>
<a name="ln75">    char32_t glyph;</a>
<a name="ln76">    colour_t colour;</a>
<a name="ln77"> </a>
<a name="ln78">    mon_display(unsigned gly = 0, unsigned col = 0)</a>
<a name="ln79">       : glyph(gly), colour(col) { }</a>
<a name="ln80">};</a>
<a name="ln81"> </a>
<a name="ln82">static mon_display monster_symbols[NUM_MONSTERS];</a>
<a name="ln83"> </a>
<a name="ln84">static bool initialised_randmons = false;</a>
<a name="ln85">static vector&lt;monster_type&gt; monsters_by_habitat[NUM_HABITATS];</a>
<a name="ln86">static vector&lt;monster_type&gt; species_by_habitat[NUM_HABITATS];</a>
<a name="ln87"> </a>
<a name="ln88">#include &quot;mon-spell.h&quot;</a>
<a name="ln89">#include &quot;mon-data.h&quot;</a>
<a name="ln90"> </a>
<a name="ln91">#define MONDATASIZE ARRAYSZ(mondata)</a>
<a name="ln92"> </a>
<a name="ln93">static int _mons_exp_mod(monster_type mclass);</a>
<a name="ln94"> </a>
<a name="ln95">// Macro that saves some typing, nothing more.</a>
<a name="ln96">#define smc get_monster_data(mc)</a>
<a name="ln97">// ASSERT(smc) was getting really old</a>
<a name="ln98">#define ASSERT_smc()                                                    \</a>
<a name="ln99">    do {                                                                \</a>
<a name="ln100">        if (!get_monster_data(mc))                                      \</a>
<a name="ln101">            die(&quot;bogus mc (no monster data): %s (%d)&quot;,                  \</a>
<a name="ln102">                mons_type_name(mc, DESC_PLAIN).c_str(), mc);            \</a>
<a name="ln103">    } while (false)</a>
<a name="ln104"> </a>
<a name="ln105">/* ******************** BEGIN PUBLIC FUNCTIONS ******************** */</a>
<a name="ln106"> </a>
<a name="ln107">static habitat_type _grid2habitat(dungeon_feature_type grid)</a>
<a name="ln108">{</a>
<a name="ln109">    if (feat_is_watery(grid))</a>
<a name="ln110">        return HT_WATER;</a>
<a name="ln111"> </a>
<a name="ln112">    switch (grid)</a>
<a name="ln113">    {</a>
<a name="ln114">    case DNGN_LAVA:</a>
<a name="ln115">        return HT_LAVA;</a>
<a name="ln116">    case DNGN_FLOOR:</a>
<a name="ln117">    default:</a>
<a name="ln118">        return HT_LAND;</a>
<a name="ln119">    }</a>
<a name="ln120">}</a>
<a name="ln121"> </a>
<a name="ln122">dungeon_feature_type habitat2grid(habitat_type ht)</a>
<a name="ln123">{</a>
<a name="ln124">    switch (ht)</a>
<a name="ln125">    {</a>
<a name="ln126">    case HT_WATER:</a>
<a name="ln127">        return DNGN_DEEP_WATER;</a>
<a name="ln128">    case HT_LAVA:</a>
<a name="ln129">        return DNGN_LAVA;</a>
<a name="ln130">    case HT_LAND:</a>
<a name="ln131">    case HT_AMPHIBIOUS:</a>
<a name="ln132">    case HT_AMPHIBIOUS_LAVA:</a>
<a name="ln133">    default:</a>
<a name="ln134">        return DNGN_FLOOR;</a>
<a name="ln135">    }</a>
<a name="ln136">}</a>
<a name="ln137"> </a>
<a name="ln138">static void _initialise_randmons()</a>
<a name="ln139">{</a>
<a name="ln140">    for (int i = 0; i &lt; NUM_HABITATS; ++i)</a>
<a name="ln141">    {</a>
<a name="ln142">        set&lt;monster_type&gt; tmp_species;</a>
<a name="ln143">        const dungeon_feature_type grid = habitat2grid(habitat_type(i));</a>
<a name="ln144"> </a>
<a name="ln145">        for (monster_type mt = MONS_0; mt &lt; NUM_MONSTERS; ++mt)</a>
<a name="ln146">        {</a>
<a name="ln147">            if (invalid_monster_type(mt))</a>
<a name="ln148">                continue;</a>
<a name="ln149"> </a>
<a name="ln150">            if (monster_habitable_grid(mt, grid))</a>
<a name="ln151">                monsters_by_habitat[i].push_back(mt);</a>
<a name="ln152"> </a>
<a name="ln153">            const monster_type species = mons_species(mt);</a>
<a name="ln154">            if (monster_habitable_grid(species, grid))</a>
<a name="ln155">                tmp_species.insert(species);</a>
<a name="ln156"> </a>
<a name="ln157">        }</a>
<a name="ln158"> </a>
<a name="ln159">        for (auto type : tmp_species)</a>
<a name="ln160">            species_by_habitat[i].push_back(type);</a>
<a name="ln161">    }</a>
<a name="ln162">    initialised_randmons = true;</a>
<a name="ln163">}</a>
<a name="ln164"> </a>
<a name="ln165">monster_type random_monster_at_grid(const coord_def&amp; p, bool species)</a>
<a name="ln166">{</a>
<a name="ln167">    if (!initialised_randmons)</a>
<a name="ln168">        _initialise_randmons();</a>
<a name="ln169"> </a>
<a name="ln170">    const habitat_type ht = _grid2habitat(grd(p));</a>
<a name="ln171">    const vector&lt;monster_type&gt; &amp;valid_mons = species ? species_by_habitat[ht]</a>
<a name="ln172">                                                     : monsters_by_habitat[ht];</a>
<a name="ln173"> </a>
<a name="ln174">    ASSERT(!valid_mons.empty());</a>
<a name="ln175">    return valid_mons.empty() ? MONS_PROGRAM_BUG</a>
<a name="ln176">                              : valid_mons[ random2(valid_mons.size()) ];</a>
<a name="ln177">}</a>
<a name="ln178"> </a>
<a name="ln179">typedef map&lt;string, monster_type&gt; mon_name_map;</a>
<a name="ln180">static mon_name_map Mon_Name_Cache;</a>
<a name="ln181"> </a>
<a name="ln182">void init_mon_name_cache()</a>
<a name="ln183">{</a>
<a name="ln184">    if (!Mon_Name_Cache.empty())</a>
<a name="ln185">        return;</a>
<a name="ln186"> </a>
<a name="ln187">    for (const monsterentry &amp;me : mondata)</a>
<a name="ln188">    {</a>
<a name="ln189">        string name = me.name;</a>
<a name="ln190">        lowercase(name);</a>
<a name="ln191"> </a>
<a name="ln192">        const int          mtype = me.mc;</a>
<a name="ln193">        const monster_type mon   = monster_type(mtype);</a>
<a name="ln194"> </a>
<a name="ln195">        // Deal sensibly with duplicate entries; refuse or allow the</a>
<a name="ln196">        // insert, depending on which should take precedence. Some</a>
<a name="ln197">        // uniques of multiple forms can get away with this, though.</a>
<a name="ln198">        if (Mon_Name_Cache.count(name))</a>
<a name="ln199">        {</a>
<a name="ln200">            if (mon == MONS_PLAYER_SHADOW</a>
<a name="ln201">                || mon == MONS_BAI_SUZHEN_DRAGON</a>
<a name="ln202">                || mon != MONS_SERPENT_OF_HELL</a>
<a name="ln203">                   &amp;&amp; mons_species(mon) == MONS_SERPENT_OF_HELL)</a>
<a name="ln204">            {</a>
<a name="ln205">                // Keep previous entry.</a>
<a name="ln206">                continue;</a>
<a name="ln207">            }</a>
<a name="ln208">            else</a>
<a name="ln209">                die(&quot;Un-handled duplicate monster name: %s&quot;, name.c_str());</a>
<a name="ln210">        }</a>
<a name="ln211"> </a>
<a name="ln212">        Mon_Name_Cache[name] = mon;</a>
<a name="ln213">    }</a>
<a name="ln214">}</a>
<a name="ln215"> </a>
<a name="ln216">static const char *_mon_entry_name(size_t idx)</a>
<a name="ln217">{</a>
<a name="ln218">    return mondata[idx].name;</a>
<a name="ln219">}</a>
<a name="ln220"> </a>
<a name="ln221">monster_type get_monster_by_name(string name, bool substring)</a>
<a name="ln222">{</a>
<a name="ln223">    if (name.empty())</a>
<a name="ln224">        return MONS_PROGRAM_BUG;</a>
<a name="ln225"> </a>
<a name="ln226">    lowercase(name);</a>
<a name="ln227"> </a>
<a name="ln228">    if (!substring)</a>
<a name="ln229">    {</a>
<a name="ln230">        if (monster_type *mc = map_find(Mon_Name_Cache, name))</a>
<a name="ln231">            return *mc;</a>
<a name="ln232">        return MONS_PROGRAM_BUG;</a>
<a name="ln233">    }</a>
<a name="ln234"> </a>
<a name="ln235">    size_t idx = find_earliest_match(name, (size_t) 0, ARRAYSZ(mondata),</a>
<a name="ln236">                                     always_true&lt;size_t&gt;, _mon_entry_name);</a>
<a name="ln237">    return idx == ARRAYSZ(mondata) ? MONS_PROGRAM_BUG</a>
<a name="ln238">                                   : (monster_type) mondata[idx].mc;</a>
<a name="ln239">}</a>
<a name="ln240"> </a>
<a name="ln241">void init_monsters()</a>
<a name="ln242">{</a>
<a name="ln243">    // First, fill static array with dummy values. {dlb}</a>
<a name="ln244">    mon_entry.init(-1);</a>
<a name="ln245"> </a>
<a name="ln246">    // Next, fill static array with location of entry in mondata[]. {dlb}:</a>
<a name="ln247">    for (unsigned int i = 0; i &lt; MONDATASIZE; ++i)</a>
<a name="ln248">        mon_entry[mondata[i].mc] = i;</a>
<a name="ln249"> </a>
<a name="ln250">    // Finally, monsters yet with dummy entries point to TTTSNB(tm). {dlb}:</a>
<a name="ln251">    for (int &amp;entry : mon_entry)</a>
<a name="ln252">        if (entry == -1)</a>
<a name="ln253">            entry = mon_entry[MONS_PROGRAM_BUG];</a>
<a name="ln254"> </a>
<a name="ln255">    init_monster_symbols();</a>
<a name="ln256">}</a>
<a name="ln257"> </a>
<a name="ln258">void init_monster_symbols()</a>
<a name="ln259">{</a>
<a name="ln260">    map&lt;unsigned, monster_type&gt; base_mons;</a>
<a name="ln261">    for (monster_type mc = MONS_0; mc &lt; NUM_MONSTERS; ++mc)</a>
<a name="ln262">    {</a>
<a name="ln263">        mon_display &amp;md = monster_symbols[mc];</a>
<a name="ln264">        if (const monsterentry *me = get_monster_data(mc))</a>
<a name="ln265">        {</a>
<a name="ln266">            md.glyph  = me-&gt;basechar;</a>
<a name="ln267">            md.colour = me-&gt;colour;</a>
<a name="ln268">            auto it = base_mons.find(md.glyph);</a>
<a name="ln269">            if (it == base_mons.end() || it-&gt;first == MONS_PROGRAM_BUG)</a>
<a name="ln270">                base_mons[md.glyph] = mc;</a>
<a name="ln271">        }</a>
<a name="ln272">    }</a>
<a name="ln273"> </a>
<a name="ln274">    // Let those follow the feature settings, unless specifically overridden.</a>
<a name="ln275">    monster_symbols[MONS_ANIMATED_TREE].glyph = get_feat_symbol(DNGN_TREE);</a>
<a name="ln276">    for (monster_type mc = MONS_0; mc &lt; NUM_MONSTERS; ++mc)</a>
<a name="ln277">        if (get_monster_data(mc)-&gt;genus == MONS_STATUE)</a>
<a name="ln278">            monster_symbols[mc].glyph = get_feat_symbol(DNGN_GRANITE_STATUE);</a>
<a name="ln279"> </a>
<a name="ln280">    // Validate all glyphs, even those which didn't come from an override.</a>
<a name="ln281">    for (monster_type i = MONS_PROGRAM_BUG; i &lt; NUM_MONSTERS; ++i)</a>
<a name="ln282">        if (wcwidth(monster_symbols[i].glyph) != 1)</a>
<a name="ln283">            monster_symbols[i].glyph = mons_base_char(i);</a>
<a name="ln284">}</a>
<a name="ln285"> </a>
<a name="ln286">void set_resist(resists_t &amp;all, mon_resist_flags res, int lev)</a>
<a name="ln287">{</a>
<a name="ln288">    if (res &gt; MR_LAST_MULTI)</a>
<a name="ln289">    {</a>
<a name="ln290">        ASSERT_RANGE(lev, 0, 2);</a>
<a name="ln291">        if (lev)</a>
<a name="ln292">            all |= res;</a>
<a name="ln293">        else</a>
<a name="ln294">            all &amp;= ~res;</a>
<a name="ln295">        return;</a>
<a name="ln296">    }</a>
<a name="ln297"> </a>
<a name="ln298">    ASSERT_RANGE(lev, -3, 5);</a>
<a name="ln299">    all = (all &amp; ~(res * 7)) | (res * (lev &amp; 7));</a>
<a name="ln300">}</a>
<a name="ln301"> </a>
<a name="ln302">int get_mons_class_ac(monster_type mc)</a>
<a name="ln303">{</a>
<a name="ln304">    const monsterentry *me = get_monster_data(mc);</a>
<a name="ln305">    return me ? me-&gt;AC : get_monster_data(MONS_PROGRAM_BUG)-&gt;AC;</a>
<a name="ln306">}</a>
<a name="ln307"> </a>
<a name="ln308">int get_mons_class_ev(monster_type mc)</a>
<a name="ln309">{</a>
<a name="ln310">    const monsterentry *me = get_monster_data(mc);</a>
<a name="ln311">    return me ? me-&gt;ev : get_monster_data(MONS_PROGRAM_BUG)-&gt;ev;</a>
<a name="ln312">}</a>
<a name="ln313"> </a>
<a name="ln314">static resists_t _apply_holiness_resists(resists_t resists, mon_holy_type mh)</a>
<a name="ln315">{</a>
<a name="ln316">    // Undead and non-living beings get full poison resistance.</a>
<a name="ln317">    if (mh &amp; (MH_UNDEAD | MH_NONLIVING))</a>
<a name="ln318">        resists = (resists &amp; ~(MR_RES_POISON * 7)) | (MR_RES_POISON * 3);</a>
<a name="ln319"> </a>
<a name="ln320">    // Everything but natural creatures have full rNeg. Set here for the</a>
<a name="ln321">    // benefit of the monster_info constructor. If you change this, also</a>
<a name="ln322">    // change monster::res_negative_energy.</a>
<a name="ln323">    if (!(mh &amp; MH_NATURAL))</a>
<a name="ln324">        resists = (resists &amp; ~(MR_RES_NEG * 7)) | (MR_RES_NEG * 3);</a>
<a name="ln325"> </a>
<a name="ln326">    return resists;</a>
<a name="ln327">}</a>
<a name="ln328"> </a>
<a name="ln329">/**</a>
<a name="ln330"> * What special resistances does the given mutant beast facet provide?</a>
<a name="ln331"> *</a>
<a name="ln332"> * @param facet     The beast_facet in question, e.g. BF_FIRE.</a>
<a name="ln333"> * @return          A bitfield of resists corresponding to the given facet;</a>
<a name="ln334"> *                  e.g. MR_RES_FIRE for BF_FIRE.</a>
<a name="ln335"> */</a>
<a name="ln336">static resists_t _beast_facet_resists(beast_facet facet)</a>
<a name="ln337">{</a>
<a name="ln338">    static const map&lt;beast_facet, resists_t&gt; resists = {</a>
<a name="ln339">        { BF_STING, MR_RES_POISON },</a>
<a name="ln340">        { BF_FIRE,  MR_RES_FIRE },</a>
<a name="ln341">        { BF_SHOCK, MR_RES_ELEC },</a>
<a name="ln342">        { BF_OX,    MR_RES_COLD },</a>
<a name="ln343">    };</a>
<a name="ln344"> </a>
<a name="ln345">    return lookup(resists, facet, 0);</a>
<a name="ln346">}</a>
<a name="ln347"> </a>
<a name="ln348">resists_t get_mons_class_resists(monster_type mc)</a>
<a name="ln349">{</a>
<a name="ln350">    const monsterentry *me = get_monster_data(mc);</a>
<a name="ln351">    const resists_t resists = me ? me-&gt;resists</a>
<a name="ln352">                                 : get_monster_data(MONS_PROGRAM_BUG)-&gt;resists;</a>
<a name="ln353">    // Don't apply fake holiness resists.</a>
<a name="ln354">    if (mons_is_sensed(mc))</a>
<a name="ln355">        return resists;</a>
<a name="ln356"> </a>
<a name="ln357">    // Assumes that, when a monster's holiness differs from other monsters</a>
<a name="ln358">    // of the same type, that only adds resistances, never removes them.</a>
<a name="ln359">    // Currently the only such case is MF_FAKE_UNDEAD.</a>
<a name="ln360">    return _apply_holiness_resists(resists, mons_class_holiness(mc));</a>
<a name="ln361">}</a>
<a name="ln362"> </a>
<a name="ln363">resists_t get_mons_resists(const monster&amp; m)</a>
<a name="ln364">{</a>
<a name="ln365">    const monster&amp; mon = get_tentacle_head(m);</a>
<a name="ln366"> </a>
<a name="ln367">    resists_t resists = get_mons_class_resists(mon.type);</a>
<a name="ln368"> </a>
<a name="ln369">    if (mons_is_ghost_demon(mon.type))</a>
<a name="ln370">        resists |= mon.ghost-&gt;resists;</a>
<a name="ln371"> </a>
<a name="ln372">    if (mons_genus(mon.type) == MONS_DRACONIAN</a>
<a name="ln373">            &amp;&amp; mon.type != MONS_DRACONIAN</a>
<a name="ln374">        || mon.type == MONS_TIAMAT</a>
<a name="ln375">        || mons_genus(mon.type) == MONS_DEMONSPAWN</a>
<a name="ln376">            &amp;&amp; mon.type != MONS_DEMONSPAWN)</a>
<a name="ln377">    {</a>
<a name="ln378">        monster_type subspecies = draco_or_demonspawn_subspecies(mon);</a>
<a name="ln379">        if (subspecies != mon.type)</a>
<a name="ln380">            resists |= get_mons_class_resists(subspecies);</a>
<a name="ln381">    }</a>
<a name="ln382"> </a>
<a name="ln383">    if (mon.props.exists(MUTANT_BEAST_FACETS))</a>
<a name="ln384">        for (auto facet : mon.props[MUTANT_BEAST_FACETS].get_vector())</a>
<a name="ln385">            resists |= _beast_facet_resists((beast_facet)facet.get_int());</a>
<a name="ln386"> </a>
<a name="ln387">    // This is set from here in case they're undead due to the</a>
<a name="ln388">    // MF_FAKE_UNDEAD flag. See the comment in get_mons_class_resists.</a>
<a name="ln389">    return _apply_holiness_resists(resists, mon.holiness());</a>
<a name="ln390">}</a>
<a name="ln391"> </a>
<a name="ln392">int get_mons_resist(const monster&amp; mon, mon_resist_flags res)</a>
<a name="ln393">{</a>
<a name="ln394">    return get_resist(get_mons_resists(mon), res);</a>
<a name="ln395">}</a>
<a name="ln396"> </a>
<a name="ln397">// Returns true if the monster successfully resists this attempt to poison it.</a>
<a name="ln398">bool monster_resists_this_poison(const monster&amp; mons, bool force)</a>
<a name="ln399">{</a>
<a name="ln400">    const int res = mons.res_poison();</a>
<a name="ln401">    if (res &gt;= 3)</a>
<a name="ln402">        return true;</a>
<a name="ln403">    if (!force &amp;&amp; res &gt;= 1 &amp;&amp; x_chance_in_y(2, 3))</a>
<a name="ln404">        return true;</a>
<a name="ln405">    return false;</a>
<a name="ln406">}</a>
<a name="ln407"> </a>
<a name="ln408">monster* monster_at(const coord_def &amp;pos)</a>
<a name="ln409">{</a>
<a name="ln410">    if (!in_bounds(pos))</a>
<a name="ln411">        return nullptr;</a>
<a name="ln412"> </a>
<a name="ln413">    const int mindex = mgrd(pos);</a>
<a name="ln414">    if (mindex == NON_MONSTER)</a>
<a name="ln415">        return nullptr;</a>
<a name="ln416"> </a>
<a name="ln417">    ASSERT(mindex &lt;= MAX_MONSTERS);</a>
<a name="ln418">    return &amp;menv[mindex];</a>
<a name="ln419">}</a>
<a name="ln420"> </a>
<a name="ln421">/// Are any of the bits set?</a>
<a name="ln422">bool mons_class_flag(monster_type mc, monclass_flags_t bits)</a>
<a name="ln423">{</a>
<a name="ln424">    const monsterentry * const me = get_monster_data(mc);</a>
<a name="ln425">    return me &amp;&amp; (me-&gt;bitfields &amp; bits);</a>
<a name="ln426">}</a>
<a name="ln427"> </a>
<a name="ln428">int monster::wearing(equipment_type slot, int sub_type, bool calc_unid) const</a>
<a name="ln429">{</a>
<a name="ln430">    int ret = 0;</a>
<a name="ln431">    const item_def *item = 0;</a>
<a name="ln432"> </a>
<a name="ln433">    if (!alive())</a>
<a name="ln434">        return 0;</a>
<a name="ln435"> </a>
<a name="ln436">    switch (slot)</a>
<a name="ln437">    {</a>
<a name="ln438">    case EQ_WEAPON:</a>
<a name="ln439">    case EQ_STAFF:</a>
<a name="ln440">        {</a>
<a name="ln441">            const mon_inv_type end = mons_wields_two_weapons(*this)</a>
<a name="ln442">                                     ? MSLOT_ALT_WEAPON : MSLOT_WEAPON;</a>
<a name="ln443"> </a>
<a name="ln444">            for (int i = MSLOT_WEAPON; i &lt;= end; i = i + 1)</a>
<a name="ln445">            {</a>
<a name="ln446">                item = mslot_item((mon_inv_type) i);</a>
<a name="ln447">                if (item &amp;&amp; item-&gt;base_type == (slot == EQ_WEAPON ? OBJ_WEAPONS</a>
<a name="ln448">                                                                  : OBJ_STAVES)</a>
<a name="ln449">                    &amp;&amp; item-&gt;sub_type == sub_type</a>
<a name="ln450">                    // Weapon subtypes are always known, staves not.</a>
<a name="ln451">                    &amp;&amp; (slot == EQ_WEAPON || calc_unid</a>
<a name="ln452">                        || item_type_known(*item)))</a>
<a name="ln453">                {</a>
<a name="ln454">                    ret++;</a>
<a name="ln455">                }</a>
<a name="ln456">            }</a>
<a name="ln457">        }</a>
<a name="ln458">        break;</a>
<a name="ln459"> </a>
<a name="ln460">    case EQ_ALL_ARMOUR:</a>
<a name="ln461">    case EQ_CLOAK:</a>
<a name="ln462">    case EQ_HELMET:</a>
<a name="ln463">    case EQ_GLOVES:</a>
<a name="ln464">    case EQ_BOOTS:</a>
<a name="ln465">    case EQ_SHIELD:</a>
<a name="ln466">        item = mslot_item(MSLOT_SHIELD);</a>
<a name="ln467">        if (item &amp;&amp; item-&gt;is_type(OBJ_ARMOUR, sub_type))</a>
<a name="ln468">            ret++;</a>
<a name="ln469">        // Don't check MSLOT_ARMOUR for EQ_SHIELD</a>
<a name="ln470">        if (slot == EQ_SHIELD)</a>
<a name="ln471">            break;</a>
<a name="ln472">        // intentional fall-through</a>
<a name="ln473">    case EQ_BODY_ARMOUR:</a>
<a name="ln474">        item = mslot_item(MSLOT_ARMOUR);</a>
<a name="ln475">        if (item &amp;&amp; item-&gt;is_type(OBJ_ARMOUR, sub_type))</a>
<a name="ln476">            ret++;</a>
<a name="ln477">        break;</a>
<a name="ln478"> </a>
<a name="ln479">    case EQ_AMULET:</a>
<a name="ln480">    case EQ_AMULET_PLUS:</a>
<a name="ln481">    case EQ_RINGS:</a>
<a name="ln482">    case EQ_RINGS_PLUS:</a>
<a name="ln483">        item = mslot_item(MSLOT_JEWELLERY);</a>
<a name="ln484">        if (item &amp;&amp; item-&gt;is_type(OBJ_JEWELLERY, sub_type)</a>
<a name="ln485">            &amp;&amp; (calc_unid || item_type_known(*item)))</a>
<a name="ln486">        {</a>
<a name="ln487">            if (slot == EQ_RINGS_PLUS || slot == EQ_AMULET_PLUS)</a>
<a name="ln488">                ret += item-&gt;plus;</a>
<a name="ln489">            else</a>
<a name="ln490">                ret++;</a>
<a name="ln491">        }</a>
<a name="ln492">        break;</a>
<a name="ln493">    default:</a>
<a name="ln494">        die(&quot;invalid slot %d for monster::wearing()&quot;, slot);</a>
<a name="ln495">    }</a>
<a name="ln496">    return ret;</a>
<a name="ln497">}</a>
<a name="ln498"> </a>
<a name="ln499">int monster::wearing_ego(equipment_type slot, int special, bool calc_unid) const</a>
<a name="ln500">{</a>
<a name="ln501">    int ret = 0;</a>
<a name="ln502">    const item_def *item = 0;</a>
<a name="ln503"> </a>
<a name="ln504">    if (!alive())</a>
<a name="ln505">        return 0;</a>
<a name="ln506"> </a>
<a name="ln507">    switch (slot)</a>
<a name="ln508">    {</a>
<a name="ln509">    case EQ_WEAPON:</a>
<a name="ln510">        {</a>
<a name="ln511">            const mon_inv_type end = mons_wields_two_weapons(*this)</a>
<a name="ln512">                                     ? MSLOT_ALT_WEAPON : MSLOT_WEAPON;</a>
<a name="ln513"> </a>
<a name="ln514">            for (int i = MSLOT_WEAPON; i &lt;= end; i++)</a>
<a name="ln515">            {</a>
<a name="ln516">                item = mslot_item((mon_inv_type) i);</a>
<a name="ln517">                if (item &amp;&amp; item-&gt;base_type == OBJ_WEAPONS</a>
<a name="ln518">                    &amp;&amp; get_weapon_brand(*item) == special</a>
<a name="ln519">                    &amp;&amp; (calc_unid || item_type_known(*item)))</a>
<a name="ln520">                {</a>
<a name="ln521">                    ret++;</a>
<a name="ln522">                }</a>
<a name="ln523">            }</a>
<a name="ln524">        }</a>
<a name="ln525">        break;</a>
<a name="ln526"> </a>
<a name="ln527">    case EQ_ALL_ARMOUR:</a>
<a name="ln528">    case EQ_CLOAK:</a>
<a name="ln529">    case EQ_HELMET:</a>
<a name="ln530">    case EQ_GLOVES:</a>
<a name="ln531">    case EQ_BOOTS:</a>
<a name="ln532">    case EQ_SHIELD:</a>
<a name="ln533">        item = mslot_item(MSLOT_SHIELD);</a>
<a name="ln534">        if (item &amp;&amp; item-&gt;base_type == OBJ_ARMOUR</a>
<a name="ln535">            &amp;&amp; get_armour_ego_type(*item) == special</a>
<a name="ln536">            &amp;&amp; (calc_unid || item_type_known(*item)))</a>
<a name="ln537">        {</a>
<a name="ln538">            ret++;</a>
<a name="ln539">        }</a>
<a name="ln540">        // Don't check MSLOT_ARMOUR for EQ_SHIELD</a>
<a name="ln541">        if (slot == EQ_SHIELD)</a>
<a name="ln542">            break;</a>
<a name="ln543">        // intentional fall-through</a>
<a name="ln544">    case EQ_BODY_ARMOUR:</a>
<a name="ln545">        item = mslot_item(MSLOT_ARMOUR);</a>
<a name="ln546">        if (item &amp;&amp; item-&gt;base_type == OBJ_ARMOUR</a>
<a name="ln547">            &amp;&amp; get_armour_ego_type(*item) == special</a>
<a name="ln548">            &amp;&amp; (calc_unid || item_type_known(*item)))</a>
<a name="ln549">        {</a>
<a name="ln550">            ret++;</a>
<a name="ln551">        }</a>
<a name="ln552">        break;</a>
<a name="ln553"> </a>
<a name="ln554">    case EQ_AMULET:</a>
<a name="ln555">    case EQ_STAFF:</a>
<a name="ln556">    case EQ_RINGS:</a>
<a name="ln557">    case EQ_RINGS_PLUS:</a>
<a name="ln558">        // No egos.</a>
<a name="ln559">        break;</a>
<a name="ln560"> </a>
<a name="ln561">    default:</a>
<a name="ln562">        die(&quot;invalid slot %d for monster::wearing_ego()&quot;, slot);</a>
<a name="ln563">    }</a>
<a name="ln564">    return ret;</a>
<a name="ln565">}</a>
<a name="ln566"> </a>
<a name="ln567">int monster::scan_artefacts(artefact_prop_type ra_prop, bool /*calc_unid*/,</a>
<a name="ln568">                            vector&lt;const item_def *&gt; *matches) const</a>
<a name="ln569">{</a>
<a name="ln570">    UNUSED(matches); //TODO: implement this when it will be required somewhere</a>
<a name="ln571"> </a>
<a name="ln572">    if (!alive())</a>
<a name="ln573">        return 0;</a>
<a name="ln574"> </a>
<a name="ln575">    int ret = 0;</a>
<a name="ln576"> </a>
<a name="ln577">    // TODO: do we really want to prevent randarts from working for zombies?</a>
<a name="ln578">    if (mons_itemuse(*this) &gt;= MONUSE_STARTING_EQUIPMENT)</a>
<a name="ln579">    {</a>
<a name="ln580">        const int weap      = inv[MSLOT_WEAPON];</a>
<a name="ln581">        const int second    = inv[MSLOT_ALT_WEAPON]; // Two-headed ogres, etc.</a>
<a name="ln582">        const int armour    = inv[MSLOT_ARMOUR];</a>
<a name="ln583">        const int shld      = inv[MSLOT_SHIELD];</a>
<a name="ln584">        const int jewellery = inv[MSLOT_JEWELLERY];</a>
<a name="ln585"> </a>
<a name="ln586">        if (weap != NON_ITEM &amp;&amp; mitm[weap].base_type == OBJ_WEAPONS</a>
<a name="ln587">            &amp;&amp; is_artefact(mitm[weap]))</a>
<a name="ln588">        {</a>
<a name="ln589">            ret += artefact_property(mitm[weap], ra_prop);</a>
<a name="ln590">        }</a>
<a name="ln591"> </a>
<a name="ln592">        if (second != NON_ITEM &amp;&amp; mitm[second].base_type == OBJ_WEAPONS</a>
<a name="ln593">            &amp;&amp; is_artefact(mitm[second]) &amp;&amp; mons_wields_two_weapons(*this))</a>
<a name="ln594">        {</a>
<a name="ln595">            ret += artefact_property(mitm[second], ra_prop);</a>
<a name="ln596">        }</a>
<a name="ln597"> </a>
<a name="ln598">        if (armour != NON_ITEM &amp;&amp; mitm[armour].base_type == OBJ_ARMOUR</a>
<a name="ln599">            &amp;&amp; is_artefact(mitm[armour]))</a>
<a name="ln600">        {</a>
<a name="ln601">            ret += artefact_property(mitm[armour], ra_prop);</a>
<a name="ln602">        }</a>
<a name="ln603"> </a>
<a name="ln604">        if (shld != NON_ITEM &amp;&amp; mitm[shld].base_type == OBJ_ARMOUR</a>
<a name="ln605">            &amp;&amp; is_artefact(mitm[shld]))</a>
<a name="ln606">        {</a>
<a name="ln607">            ret += artefact_property(mitm[shld], ra_prop);</a>
<a name="ln608">        }</a>
<a name="ln609"> </a>
<a name="ln610">        if (jewellery != NON_ITEM &amp;&amp; mitm[jewellery].base_type == OBJ_JEWELLERY</a>
<a name="ln611">            &amp;&amp; is_artefact(mitm[jewellery]))</a>
<a name="ln612">        {</a>
<a name="ln613">            ret += artefact_property(mitm[jewellery], ra_prop);</a>
<a name="ln614">        }</a>
<a name="ln615">    }</a>
<a name="ln616"> </a>
<a name="ln617">    return ret;</a>
<a name="ln618">}</a>
<a name="ln619"> </a>
<a name="ln620">mon_holy_type holiness_by_name(string name)</a>
<a name="ln621">{</a>
<a name="ln622">    lowercase(name);</a>
<a name="ln623">    for (const auto bit : mon_holy_type::range())</a>
<a name="ln624">    {</a>
<a name="ln625">        if (name == holiness_name(mon_holy_type::exponent(bit)))</a>
<a name="ln626">            return mon_holy_type::exponent(bit);</a>
<a name="ln627">    }</a>
<a name="ln628">    return MH_NONE;</a>
<a name="ln629">}</a>
<a name="ln630"> </a>
<a name="ln631">const char * holiness_name(mon_holy_type_flags which_holiness)</a>
<a name="ln632">{</a>
<a name="ln633">    switch (which_holiness)</a>
<a name="ln634">    {</a>
<a name="ln635">    case MH_HOLY:</a>
<a name="ln636">        return &quot;holy&quot;;</a>
<a name="ln637">    case MH_NATURAL:</a>
<a name="ln638">        return &quot;natural&quot;;</a>
<a name="ln639">    case MH_UNDEAD:</a>
<a name="ln640">        return &quot;undead&quot;;</a>
<a name="ln641">    case MH_DEMONIC:</a>
<a name="ln642">        return &quot;demonic&quot;;</a>
<a name="ln643">    case MH_NONLIVING:</a>
<a name="ln644">        return &quot;nonliving&quot;;</a>
<a name="ln645">    case MH_PLANT:</a>
<a name="ln646">        return &quot;plant&quot;;</a>
<a name="ln647">    case MH_EVIL:</a>
<a name="ln648">        return &quot;evil&quot;;</a>
<a name="ln649">    default:</a>
<a name="ln650">        return &quot;bug&quot;;</a>
<a name="ln651">    }</a>
<a name="ln652">}</a>
<a name="ln653"> </a>
<a name="ln654">string holiness_description(mon_holy_type holiness)</a>
<a name="ln655">{</a>
<a name="ln656">    string description = &quot;&quot;;</a>
<a name="ln657">    for (const auto bit : mon_holy_type::range())</a>
<a name="ln658">    {</a>
<a name="ln659">        if (holiness &amp; bit)</a>
<a name="ln660">        {</a>
<a name="ln661">            if (!description.empty())</a>
<a name="ln662">                description += &quot;,&quot;;</a>
<a name="ln663">            description += holiness_name(bit);</a>
<a name="ln664">        }</a>
<a name="ln665">    }</a>
<a name="ln666">    return description;</a>
<a name="ln667">}</a>
<a name="ln668"> </a>
<a name="ln669">mon_holy_type mons_class_holiness(monster_type mc)</a>
<a name="ln670">{</a>
<a name="ln671">    ASSERT_smc();</a>
<a name="ln672">    return smc-&gt;holiness;</a>
<a name="ln673">}</a>
<a name="ln674"> </a>
<a name="ln675">bool mons_class_is_stationary(monster_type mc)</a>
<a name="ln676">{</a>
<a name="ln677">    return mons_class_flag(mc, M_STATIONARY);</a>
<a name="ln678">}</a>
<a name="ln679"> </a>
<a name="ln680">/**</a>
<a name="ln681"> * Can killing this class of monster ever reward xp?</a>
<a name="ln682"> *</a>
<a name="ln683"> * This answers whether any agent could receive XP for killing a monster of</a>
<a name="ln684"> * this class. Monsters that fail this have M_NO_EXP_GAIN set.</a>
<a name="ln685"> * @param mc       The monster type</a>
<a name="ln686"> * @param indirect If true this will count monsters that are parts of a parent</a>
<a name="ln687"> *                 monster as xp rewarding even if the parts themselves don't</a>
<a name="ln688"> *                 reward xp (e.g. tentacles).</a>
<a name="ln689"> * @returns True if killing a monster of this class could reward xp, false</a>
<a name="ln690"> * otherwise.</a>
<a name="ln691"> */</a>
<a name="ln692">bool mons_class_gives_xp(monster_type mc, bool indirect)</a>
<a name="ln693">{</a>
<a name="ln694">    return !mons_class_flag(mc, M_NO_EXP_GAIN)</a>
<a name="ln695">        || (indirect &amp;&amp; mons_is_tentacle_or_tentacle_segment(mc));</a>
<a name="ln696">}</a>
<a name="ln697"> </a>
<a name="ln698">/**</a>
<a name="ln699"> * Can killing this monster reward xp to the given actor?</a>
<a name="ln700"> *</a>
<a name="ln701"> * This answers whether the player or a monster could ever receive XP for</a>
<a name="ln702"> * killing the monster, assuming an appropriate kill_type.</a>
<a name="ln703"> * @param mon      The monster.</a>
<a name="ln704"> * @param agent    The actor who would be responsible for the kill.</a>
<a name="ln705"> * @returns True if killing the monster will reward the agent with xp, false</a>
<a name="ln706"> * otherwise.</a>
<a name="ln707"> */</a>
<a name="ln708">bool mons_gives_xp(const monster&amp; victim, const actor&amp; agent)</a>
<a name="ln709">{</a>
<a name="ln710">    const bool mon_killed_friend</a>
<a name="ln711">        = agent.is_monster() &amp;&amp; mons_aligned(&amp;victim, &amp;agent);</a>
<a name="ln712">    return !victim.is_summoned()                   // no summons</a>
<a name="ln713">        &amp;&amp; !victim.has_ench(ENCH_ABJ)              // not-really-summons</a>
<a name="ln714">        &amp;&amp; !victim.has_ench(ENCH_FAKE_ABJURATION)  // no animated remains</a>
<a name="ln715">        &amp;&amp; mons_class_gives_xp(victim.type)        // class must reward xp</a>
<a name="ln716">        &amp;&amp; !testbits(victim.flags, MF_WAS_NEUTRAL) // no neutral monsters</a>
<a name="ln717">        &amp;&amp; !testbits(victim.flags, MF_NO_REWARD)   // no reward for no_reward</a>
<a name="ln718">        &amp;&amp; !mon_killed_friend;</a>
<a name="ln719">}</a>
<a name="ln720"> </a>
<a name="ln721">bool mons_class_is_threatening(monster_type mo)</a>
<a name="ln722">{</a>
<a name="ln723">    return !mons_class_flag(mo, M_NO_THREAT);</a>
<a name="ln724">}</a>
<a name="ln725"> </a>
<a name="ln726">bool mons_is_threatening(const monster&amp; mons)</a>
<a name="ln727">{</a>
<a name="ln728">    return mons_class_is_threatening(mons.type) || mons_is_active_ballisto(mons);</a>
<a name="ln729">}</a>
<a name="ln730"> </a>
<a name="ln731">/**</a>
<a name="ln732"> * Is this an active ballistomycete?</a>
<a name="ln733"> *</a>
<a name="ln734"> * @param mon             The monster</a>
<a name="ln735"> * @returns True if the monster is an active ballistomycete, false otherwise.</a>
<a name="ln736"> */</a>
<a name="ln737">bool mons_is_active_ballisto(const monster&amp; mon)</a>
<a name="ln738">{</a>
<a name="ln739">    return mon.type == MONS_BALLISTOMYCETE &amp;&amp; mon.ballisto_activity;</a>
<a name="ln740">}</a>
<a name="ln741"> </a>
<a name="ln742">/**</a>
<a name="ln743"> * Is this monster class firewood?</a>
<a name="ln744"> *</a>
<a name="ln745"> * Firewood monsters are harmless stationary monsters than don't give xp. These</a>
<a name="ln746"> * are worthless obstacles: not to be attacked by default, but may be cut down</a>
<a name="ln747"> * to get to target even if coaligned.</a>
<a name="ln748"> * @param mc The monster type</a>
<a name="ln749"> * @returns True if the monster class is firewood, false otherwise.</a>
<a name="ln750"> */</a>
<a name="ln751">bool mons_class_is_firewood(monster_type mc)</a>
<a name="ln752">{</a>
<a name="ln753">    return mons_class_is_stationary(mc)</a>
<a name="ln754">           &amp;&amp; mc != MONS_TEST_STATUE</a>
<a name="ln755">           &amp;&amp; mons_class_flag(mc, M_NO_THREAT)</a>
<a name="ln756">           &amp;&amp; !mons_is_tentacle_or_tentacle_segment(mc);</a>
<a name="ln757">}</a>
<a name="ln758"> </a>
<a name="ln759">/**</a>
<a name="ln760"> * Is this monster firewood?</a>
<a name="ln761"> *</a>
<a name="ln762"> * Firewood monsters are stationary monsters than don't give xp.</a>
<a name="ln763"> * @param mon             The monster</a>
<a name="ln764"> * @returns True if the monster is firewood, false otherwise.</a>
<a name="ln765"> */</a>
<a name="ln766">bool mons_is_firewood(const monster&amp; mon)</a>
<a name="ln767">{</a>
<a name="ln768">    return mons_class_is_firewood(mon.type);</a>
<a name="ln769">}</a>
<a name="ln770"> </a>
<a name="ln771">// &quot;body&quot; in a purely grammatical sense.</a>
<a name="ln772">bool mons_has_body(const monster&amp; mon)</a>
<a name="ln773">{</a>
<a name="ln774">    if (mon.type == MONS_FLYING_SKULL</a>
<a name="ln775">        || mon.type == MONS_CURSE_SKULL</a>
<a name="ln776">        || mon.type == MONS_CURSE_TOE</a>
<a name="ln777">        || mons_class_is_animated_weapon(mon.type))</a>
<a name="ln778">    {</a>
<a name="ln779">        return false;</a>
<a name="ln780">    }</a>
<a name="ln781"> </a>
<a name="ln782">    switch (mons_base_char(mon.type))</a>
<a name="ln783">    {</a>
<a name="ln784">    case 'P':</a>
<a name="ln785">    case 'v':</a>
<a name="ln786">    case 'G':</a>
<a name="ln787">    case '*':</a>
<a name="ln788">    case '%':</a>
<a name="ln789">    case 'J':</a>
<a name="ln790">        return false;</a>
<a name="ln791">    }</a>
<a name="ln792"> </a>
<a name="ln793">    return true;</a>
<a name="ln794">}</a>
<a name="ln795"> </a>
<a name="ln796">bool mons_has_flesh(const monster&amp; mon)</a>
<a name="ln797">{</a>
<a name="ln798">    if (mon.is_skeletal() || mon.is_insubstantial())</a>
<a name="ln799">        return false;</a>
<a name="ln800"> </a>
<a name="ln801">    // Dictionary says:</a>
<a name="ln802">    // 1. (12) flesh -- (the soft tissue of the body of a vertebrate:</a>
<a name="ln803">    //    mainly muscle tissue and fat)</a>
<a name="ln804">    // 3. pulp, flesh -- (a soft moist part of a fruit)</a>
<a name="ln805">    // yet I exclude sense 3 anyway but include arthropods and molluscs.</a>
<a name="ln806">    return !(mon.holiness() &amp; (MH_PLANT | MH_NONLIVING))</a>
<a name="ln807">           &amp;&amp; mons_genus(mon.type) != MONS_FLOATING_EYE</a>
<a name="ln808">           &amp;&amp; mons_genus(mon.type) != MONS_GLOWING_ORANGE_BRAIN</a>
<a name="ln809">           &amp;&amp; mons_genus(mon.type) != MONS_JELLY</a>
<a name="ln810">           &amp;&amp; mon.type != MONS_DEATH_COB; // plant!</a>
<a name="ln811">}</a>
<a name="ln812"> </a>
<a name="ln813">// Difference in speed between monster and the player for Cheibriados'</a>
<a name="ln814">// purposes. This is the speed difference disregarding the player's</a>
<a name="ln815">// slow status.</a>
<a name="ln816">int cheibriados_monster_player_speed_delta(const monster&amp; mon)</a>
<a name="ln817">{</a>
<a name="ln818">    // Ignore the Slow effect.</a>
<a name="ln819">    unwind_var&lt;int&gt; ignore_slow(you.duration[DUR_SLOW], 0);</a>
<a name="ln820">    const int pspeed = 1000 / (player_movement_speed() * player_speed());</a>
<a name="ln821">    dprf(&quot;Your delay: %d, your speed: %d, mon speed: %d&quot;,</a>
<a name="ln822">        player_movement_speed(), pspeed, mon.speed);</a>
<a name="ln823">    return mon.speed - pspeed;</a>
<a name="ln824">}</a>
<a name="ln825"> </a>
<a name="ln826">bool cheibriados_thinks_mons_is_fast(const monster&amp; mon)</a>
<a name="ln827">{</a>
<a name="ln828">    return cheibriados_monster_player_speed_delta(mon) &gt; 0;</a>
<a name="ln829">}</a>
<a name="ln830"> </a>
<a name="ln831">bool mons_is_projectile(monster_type mc)</a>
<a name="ln832">{</a>
<a name="ln833">    return mons_class_flag(mc, M_PROJECTILE);</a>
<a name="ln834">}</a>
<a name="ln835"> </a>
<a name="ln836">bool mons_is_projectile(const monster&amp; mon)</a>
<a name="ln837">{</a>
<a name="ln838">    return mons_is_projectile(mon.type);</a>
<a name="ln839">}</a>
<a name="ln840"> </a>
<a name="ln841">// Conjuration or Hexes. Summoning and Necromancy make the monster a creature</a>
<a name="ln842">// at least in some degree, golems have a chem granting them that.</a>
<a name="ln843">bool mons_is_object(monster_type mc)</a>
<a name="ln844">{</a>
<a name="ln845">    return mons_is_conjured(mc)</a>
<a name="ln846">           || mc == MONS_TWISTER</a>
<a name="ln847">           // unloading seeds helps the species</a>
<a name="ln848">           || mc == MONS_BALLISTOMYCETE_SPORE</a>
<a name="ln849">           || mc == MONS_LURKING_HORROR</a>
<a name="ln850">           || mc == MONS_DANCING_WEAPON</a>
<a name="ln851">           || mc == MONS_LIGHTNING_SPIRE;</a>
<a name="ln852">}</a>
<a name="ln853"> </a>
<a name="ln854">bool mons_has_blood(monster_type mc)</a>
<a name="ln855">{</a>
<a name="ln856">    return mons_class_flag(mc, M_COLD_BLOOD)</a>
<a name="ln857">           || mons_class_flag(mc, M_WARM_BLOOD);</a>
<a name="ln858">}</a>
<a name="ln859"> </a>
<a name="ln860">bool mons_is_sensed(monster_type mc)</a>
<a name="ln861">{</a>
<a name="ln862">    return mc == MONS_SENSED</a>
<a name="ln863">           || mc == MONS_SENSED_FRIENDLY</a>
<a name="ln864">           || mc == MONS_SENSED_TRIVIAL</a>
<a name="ln865">           || mc == MONS_SENSED_EASY</a>
<a name="ln866">           || mc == MONS_SENSED_TOUGH</a>
<a name="ln867">           || mc == MONS_SENSED_NASTY;</a>
<a name="ln868">}</a>
<a name="ln869"> </a>
<a name="ln870">bool mons_allows_beogh(const monster&amp; mon)</a>
<a name="ln871">{</a>
<a name="ln872">    if (!species_is_orcish(you.species) || you_worship(GOD_BEOGH))</a>
<a name="ln873">        return false; // no one else gives a damn</a>
<a name="ln874"> </a>
<a name="ln875">    return mons_genus(mon.type) == MONS_ORC</a>
<a name="ln876">           &amp;&amp; mon.is_priest() &amp;&amp; mon.god == GOD_BEOGH;</a>
<a name="ln877">}</a>
<a name="ln878"> </a>
<a name="ln879">bool mons_allows_beogh_now(const monster&amp; mon)</a>
<a name="ln880">{</a>
<a name="ln881">    // Do the expensive LOS check last.</a>
<a name="ln882">    return mons_allows_beogh(mon)</a>
<a name="ln883">               &amp;&amp; !mon.is_summoned() &amp;&amp; !mon.friendly()</a>
<a name="ln884">               &amp;&amp; !silenced(mon.pos()) &amp;&amp; !mon.has_ench(ENCH_MUTE)</a>
<a name="ln885">               &amp;&amp; !mons_is_confused(mon) &amp;&amp; mons_is_seeking(mon)</a>
<a name="ln886">               &amp;&amp; mon.foe == MHITYOU &amp;&amp; !mons_is_immotile(mon)</a>
<a name="ln887">               &amp;&amp; you.visible_to(&amp;mon) &amp;&amp; you.can_see(mon);</a>
<a name="ln888">}</a>
<a name="ln889"> </a>
<a name="ln890">// Returns true for monsters that obviously (to the player) feel</a>
<a name="ln891">// &quot;thematically at home&quot; in a branch. Currently used for native</a>
<a name="ln892">// monsters recognising traps and patrolling branch entrances.</a>
<a name="ln893">bool mons_is_native_in_branch(const monster&amp; mons,</a>
<a name="ln894">                              const branch_type branch)</a>
<a name="ln895">{</a>
<a name="ln896">    switch (branch)</a>
<a name="ln897">    {</a>
<a name="ln898">    case BRANCH_ELF:</a>
<a name="ln899">        return mons_genus(mons.type) == MONS_ELF;</a>
<a name="ln900"> </a>
<a name="ln901">    case BRANCH_ORC:</a>
<a name="ln902">        return mons_genus(mons.type) == MONS_ORC;</a>
<a name="ln903"> </a>
<a name="ln904">    case BRANCH_SHOALS:</a>
<a name="ln905">        return mons_species(mons.type) == MONS_CYCLOPS</a>
<a name="ln906">               || mons_species(mons.type) == MONS_MERFOLK</a>
<a name="ln907">               || mons.type == MONS_HARPY;</a>
<a name="ln908"> </a>
<a name="ln909">    case BRANCH_SLIME:</a>
<a name="ln910">        return mons_is_slime(mons);</a>
<a name="ln911"> </a>
<a name="ln912">    case BRANCH_SNAKE:</a>
<a name="ln913">        return mons_genus(mons.type) == MONS_NAGA</a>
<a name="ln914">               || mons_genus(mons.type) == MONS_SALAMANDER</a>
<a name="ln915">               || mons_genus(mons.type) == MONS_SNAKE;</a>
<a name="ln916"> </a>
<a name="ln917">    case BRANCH_ZOT:</a>
<a name="ln918">        return mons_genus(mons.type) == MONS_DRACONIAN</a>
<a name="ln919">               || mons.type == MONS_ORB_GUARDIAN</a>
<a name="ln920">               || mons.type == MONS_ORB_OF_FIRE</a>
<a name="ln921">               || mons.type == MONS_DEATH_COB</a>
<a name="ln922">               || mons.type == MONS_KILLER_KLOWN;</a>
<a name="ln923"> </a>
<a name="ln924">    case BRANCH_VAULTS:</a>
<a name="ln925">        return mons_genus(mons.type) == MONS_HUMAN;</a>
<a name="ln926"> </a>
<a name="ln927">    case BRANCH_CRYPT:</a>
<a name="ln928">        return mons.holiness() == MH_UNDEAD;</a>
<a name="ln929"> </a>
<a name="ln930">    case BRANCH_TOMB:</a>
<a name="ln931">        return mons_genus(mons.type) == MONS_MUMMY</a>
<a name="ln932">              || mons.type == MONS_USHABTI</a>
<a name="ln933">              || mons.type == MONS_DEATH_SCARAB;</a>
<a name="ln934"> </a>
<a name="ln935">    case BRANCH_SPIDER:</a>
<a name="ln936">        return mons_genus(mons.type) == MONS_SPIDER;</a>
<a name="ln937"> </a>
<a name="ln938">    case BRANCH_ABYSS:</a>
<a name="ln939">        return mons_is_abyssal_only(mons.type)</a>
<a name="ln940">               || mons.type == MONS_ABOMINATION_LARGE</a>
<a name="ln941">               || mons.type == MONS_ABOMINATION_SMALL</a>
<a name="ln942">               || mons.type == MONS_TENTACLED_MONSTROSITY</a>
<a name="ln943">               || mons.type == MONS_TENTACLED_STARSPAWN</a>
<a name="ln944">               || mons.type == MONS_THRASHING_HORROR</a>
<a name="ln945">               || mons.type == MONS_UNSEEN_HORROR</a>
<a name="ln946">               || mons.type == MONS_WORLDBINDER;</a>
<a name="ln947"> </a>
<a name="ln948">    default:</a>
<a name="ln949">        return false;</a>
<a name="ln950">    }</a>
<a name="ln951">}</a>
<a name="ln952"> </a>
<a name="ln953">bool mons_is_abyssal_only(monster_type mc)</a>
<a name="ln954">{</a>
<a name="ln955">    switch (mc)</a>
<a name="ln956">    {</a>
<a name="ln957">    case MONS_ANCIENT_ZYME:</a>
<a name="ln958">    case MONS_ELDRITCH_TENTACLE:</a>
<a name="ln959">    case MONS_ELDRITCH_TENTACLE_SEGMENT:</a>
<a name="ln960">    case MONS_LURKING_HORROR:</a>
<a name="ln961">    case MONS_WRETCHED_STAR:</a>
<a name="ln962">        return true;</a>
<a name="ln963">    default:</a>
<a name="ln964">        return false;</a>
<a name="ln965">    }</a>
<a name="ln966">}</a>
<a name="ln967"> </a>
<a name="ln968">// Monsters considered as &quot;slime&quot; for Jiyva.</a>
<a name="ln969">bool mons_class_is_slime(monster_type mc)</a>
<a name="ln970">{</a>
<a name="ln971">    return mons_genus(mc) == MONS_JELLY</a>
<a name="ln972">           || mons_genus(mc) == MONS_FLOATING_EYE</a>
<a name="ln973">           || mons_genus(mc) == MONS_GLOWING_ORANGE_BRAIN;</a>
<a name="ln974">}</a>
<a name="ln975"> </a>
<a name="ln976">bool mons_is_slime(const monster&amp; mon)</a>
<a name="ln977">{</a>
<a name="ln978">    return mons_class_is_slime(mon.type);</a>
<a name="ln979">}</a>
<a name="ln980"> </a>
<a name="ln981">bool herd_monster(const monster&amp; mon)</a>
<a name="ln982">{</a>
<a name="ln983">    return mons_class_flag(mon.type, M_HERD);</a>
<a name="ln984">}</a>
<a name="ln985"> </a>
<a name="ln986">// Plant or fungus or really anything with</a>
<a name="ln987">// permanent plant holiness</a>
<a name="ln988">bool mons_class_is_plant(monster_type mc)</a>
<a name="ln989">{</a>
<a name="ln990">    return bool(mons_class_holiness(mc) &amp; MH_PLANT);</a>
<a name="ln991">}</a>
<a name="ln992"> </a>
<a name="ln993">bool mons_is_plant(const monster&amp; mon)</a>
<a name="ln994">{</a>
<a name="ln995">    return mons_class_is_plant(mon.type);</a>
<a name="ln996">}</a>
<a name="ln997"> </a>
<a name="ln998">bool mons_eats_items(const monster&amp; mon)</a>
<a name="ln999">{</a>
<a name="ln1000">    return mons_is_slime(mon) &amp;&amp; have_passive(passive_t::jelly_eating);</a>
<a name="ln1001">}</a>
<a name="ln1002"> </a>
<a name="ln1003">/* Is the actor susceptible to vampirism?</a>
<a name="ln1004"> *</a>
<a name="ln1005"> * Undead actors and summoned, temporary, or ghostified monsters are all not</a>
<a name="ln1006"> * susceptible.</a>
<a name="ln1007"> * @param act The actor.</a>
<a name="ln1008"> * @returns True if the actor is susceptible to vampirism, false otherwise.</a>
<a name="ln1009"> */</a>
<a name="ln1010">bool actor_is_susceptible_to_vampirism(const actor&amp; act)</a>
<a name="ln1011">{</a>
<a name="ln1012">    if (!(act.holiness() &amp; MH_NATURAL) || act.is_summoned())</a>
<a name="ln1013">        return false;</a>
<a name="ln1014"> </a>
<a name="ln1015">    if (act.is_player())</a>
<a name="ln1016">        return true;</a>
<a name="ln1017"> </a>
<a name="ln1018">    const monster *mon = act.as_monster();</a>
<a name="ln1019">    // Don't allow HP draining from temporary monsters such as those created by</a>
<a name="ln1020">    // Sticks to Snakes.</a>
<a name="ln1021">    return !mon-&gt;has_ench(ENCH_FAKE_ABJURATION)</a>
<a name="ln1022">           // Nor from now-ghostly monsters.</a>
<a name="ln1023">           &amp;&amp; !testbits(mon-&gt;flags, MF_SPECTRALISED);</a>
<a name="ln1024">}</a>
<a name="ln1025"> </a>
<a name="ln1026">bool invalid_monster(const monster* mon)</a>
<a name="ln1027">{</a>
<a name="ln1028">    return !mon || invalid_monster_type(mon-&gt;type);</a>
<a name="ln1029">}</a>
<a name="ln1030"> </a>
<a name="ln1031">bool invalid_monster_type(monster_type mt)</a>
<a name="ln1032">{</a>
<a name="ln1033">    return mt &lt; 0 || mt &gt;= NUM_MONSTERS</a>
<a name="ln1034">           || mon_entry[mt] == mon_entry[MONS_PROGRAM_BUG];</a>
<a name="ln1035">}</a>
<a name="ln1036"> </a>
<a name="ln1037">bool invalid_monster_index(int i)</a>
<a name="ln1038">{</a>
<a name="ln1039">    return i &lt; 0 || i &gt;= MAX_MONSTERS;</a>
<a name="ln1040">}</a>
<a name="ln1041"> </a>
<a name="ln1042">bool mons_is_statue(monster_type mc)</a>
<a name="ln1043">{</a>
<a name="ln1044">    return mc == MONS_ORANGE_STATUE</a>
<a name="ln1045">           || mc == MONS_OBSIDIAN_STATUE</a>
<a name="ln1046">           || mc == MONS_ICE_STATUE</a>
<a name="ln1047">           || mc == MONS_ROXANNE;</a>
<a name="ln1048">}</a>
<a name="ln1049"> </a>
<a name="ln1050">/**</a>
<a name="ln1051"> * The mimic [(cackles|chortles...) and ]vanishes in[ a puff of smoke]!</a>
<a name="ln1052"> *</a>
<a name="ln1053"> * @param pos       The mimic's location.</a>
<a name="ln1054"> * @param name      The mimic's name.</a>
<a name="ln1055"> */</a>
<a name="ln1056">static void _mimic_vanish(const coord_def&amp; pos, const string&amp; name)</a>
<a name="ln1057">{</a>
<a name="ln1058">    const bool can_place_smoke = !cloud_at(pos);</a>
<a name="ln1059">    if (can_place_smoke)</a>
<a name="ln1060">        place_cloud(CLOUD_BLACK_SMOKE, pos, 2 + random2(2), nullptr);</a>
<a name="ln1061">    if (!you.see_cell(pos))</a>
<a name="ln1062">        return;</a>
<a name="ln1063"> </a>
<a name="ln1064">    const char* const smoke_str = can_place_smoke ? &quot; in a puff of smoke&quot; : &quot;&quot;;</a>
<a name="ln1065"> </a>
<a name="ln1066">    const bool can_cackle = !silenced(pos) &amp;&amp; !silenced(you.pos());</a>
<a name="ln1067">    const string cackle = can_cackle ? getSpeakString(&quot;_laughs_&quot;) + &quot; and &quot; : &quot;&quot;;</a>
<a name="ln1068"> </a>
<a name="ln1069">    mprf(&quot;The %s mimic %svanishes%s!&quot;,</a>
<a name="ln1070">         name.c_str(), cackle.c_str(), smoke_str);</a>
<a name="ln1071">    interrupt_activity(activity_interrupt::mimic);</a>
<a name="ln1072">}</a>
<a name="ln1073"> </a>
<a name="ln1074">/**</a>
<a name="ln1075"> * Clean up a &quot;feature&quot; that a mimic was pretending to be.</a>
<a name="ln1076"> *</a>
<a name="ln1077"> * @param pos   The location of the 'feature'.</a>
<a name="ln1078"> */</a>
<a name="ln1079">static void _destroy_mimic_feature(const coord_def &amp;pos)</a>
<a name="ln1080">{</a>
<a name="ln1081">#if TAG_MAJOR_VERSION == 34</a>
<a name="ln1082">    const dungeon_feature_type feat = grd(pos);</a>
<a name="ln1083">#endif</a>
<a name="ln1084"> </a>
<a name="ln1085">    unnotice_feature(level_pos(level_id::current(), pos));</a>
<a name="ln1086">    grd(pos) = DNGN_FLOOR;</a>
<a name="ln1087">    env.level_map_mask(pos) &amp;= ~MMT_MIMIC;</a>
<a name="ln1088">    set_terrain_changed(pos);</a>
<a name="ln1089">    remove_markers_and_listeners_at(pos);</a>
<a name="ln1090"> </a>
<a name="ln1091">#if TAG_MAJOR_VERSION == 34</a>
<a name="ln1092">    if (feat_is_door(feat))</a>
<a name="ln1093">        env.level_map_mask(pos) |= MMT_WAS_DOOR_MIMIC;</a>
<a name="ln1094">#endif</a>
<a name="ln1095">}</a>
<a name="ln1096"> </a>
<a name="ln1097">void discover_mimic(const coord_def&amp; pos)</a>
<a name="ln1098">{</a>
<a name="ln1099">    item_def* item = item_mimic_at(pos);</a>
<a name="ln1100">    const bool feature_mimic = !item &amp;&amp; feature_mimic_at(pos);</a>
<a name="ln1101">    // Is there really a mimic here?</a>
<a name="ln1102">    if (!item &amp;&amp; !feature_mimic)</a>
<a name="ln1103">        return;</a>
<a name="ln1104"> </a>
<a name="ln1105">    const dungeon_feature_type feat = grd(pos);</a>
<a name="ln1106"> </a>
<a name="ln1107">    // If the feature has been destroyed, don't create a floor mimic.</a>
<a name="ln1108">    if (feature_mimic &amp;&amp; !feat_is_mimicable(feat, false))</a>
<a name="ln1109">    {</a>
<a name="ln1110">        env.level_map_mask(pos) &amp;= ~MMT_MIMIC;</a>
<a name="ln1111">        return;</a>
<a name="ln1112">    }</a>
<a name="ln1113"> </a>
<a name="ln1114">    const string name = feature_mimic ? &quot;the &quot; + string(feat_type_name(feat))</a>
<a name="ln1115">                                      : item-&gt;name(DESC_THE, false, false,</a>
<a name="ln1116">                                                             false, true);</a>
<a name="ln1117">    const bool plural = feature_mimic ? false : item-&gt;quantity &gt; 1;</a>
<a name="ln1118"> </a>
<a name="ln1119">#ifdef USE_TILE</a>
<a name="ln1120">    tileidx_t tile = tileidx_feature(pos);</a>
<a name="ln1121">    apply_variations(env.tile_flv(pos), &amp;tile, pos);</a>
<a name="ln1122">#endif</a>
<a name="ln1123"> </a>
<a name="ln1124">    if (you.see_cell(pos))</a>
<a name="ln1125">        mprf(&quot;%s %s a mimic!&quot;, name.c_str(), plural ? &quot;are&quot; : &quot;is&quot;);</a>
<a name="ln1126"> </a>
<a name="ln1127">    const string shortname = feature_mimic ? feat_type_name(feat)</a>
<a name="ln1128">                                           : item-&gt;name(DESC_BASENAME);</a>
<a name="ln1129">    if (item)</a>
<a name="ln1130">        destroy_item(item-&gt;index(), true);</a>
<a name="ln1131">    else</a>
<a name="ln1132">        _destroy_mimic_feature(pos);</a>
<a name="ln1133">    _mimic_vanish(pos, shortname);</a>
<a name="ln1134"> </a>
<a name="ln1135">    // Just in case there's another one.</a>
<a name="ln1136">    if (mimic_at(pos))</a>
<a name="ln1137">        discover_mimic(pos);</a>
<a name="ln1138">}</a>
<a name="ln1139"> </a>
<a name="ln1140">void discover_shifter(monster&amp; shifter)</a>
<a name="ln1141">{</a>
<a name="ln1142">    shifter.flags |= MF_KNOWN_SHIFTER;</a>
<a name="ln1143">}</a>
<a name="ln1144"> </a>
<a name="ln1145">bool mons_is_demon(monster_type mc)</a>
<a name="ln1146">{</a>
<a name="ln1147">    return mons_class_holiness(mc) &amp; MH_DEMONIC</a>
<a name="ln1148">             &amp;&amp; (mons_demon_tier(mc) != 0 &amp;&amp; mc != MONS_ANTAEUS</a>
<a name="ln1149">                 || mons_species(mc) == MONS_RAKSHASA);</a>
<a name="ln1150">}</a>
<a name="ln1151"> </a>
<a name="ln1152">int mons_demon_tier(monster_type mc)</a>
<a name="ln1153">{</a>
<a name="ln1154">    switch (mons_base_char(mc))</a>
<a name="ln1155">    {</a>
<a name="ln1156">    case 'C':</a>
<a name="ln1157">        if (mc != MONS_ANTAEUS)</a>
<a name="ln1158">            return 0;</a>
<a name="ln1159">        // intentional fall-through for Antaeus</a>
<a name="ln1160">    case '&amp;':</a>
<a name="ln1161">        return -1;</a>
<a name="ln1162">    case '1':</a>
<a name="ln1163">        return 1;</a>
<a name="ln1164">    case '2':</a>
<a name="ln1165">        return 2;</a>
<a name="ln1166">    case '3':</a>
<a name="ln1167">        return 3;</a>
<a name="ln1168">    case '4':</a>
<a name="ln1169">        return 4;</a>
<a name="ln1170">    case '5':</a>
<a name="ln1171">        return 5;</a>
<a name="ln1172">    default:</a>
<a name="ln1173">        return 0;</a>
<a name="ln1174">    }</a>
<a name="ln1175">}</a>
<a name="ln1176"> </a>
<a name="ln1177">// Beware; returns false for Tiamat!</a>
<a name="ln1178">bool mons_is_draconian(monster_type mc)</a>
<a name="ln1179">{</a>
<a name="ln1180">    return mc &gt;= MONS_FIRST_DRACONIAN &amp;&amp; mc &lt;= MONS_LAST_DRACONIAN;</a>
<a name="ln1181">}</a>
<a name="ln1182"> </a>
<a name="ln1183">bool mons_is_base_draconian(monster_type mc)</a>
<a name="ln1184">{</a>
<a name="ln1185">    return mc &gt;= MONS_FIRST_DRACONIAN &amp;&amp; mc &lt;= MONS_LAST_BASE_DRACONIAN;</a>
<a name="ln1186">}</a>
<a name="ln1187"> </a>
<a name="ln1188">bool mons_is_demonspawn(monster_type mc)</a>
<a name="ln1189">{</a>
<a name="ln1190">    return</a>
<a name="ln1191">#if TAG_MAJOR_VERSION == 34</a>
<a name="ln1192">        mc == MONS_DEMONSPAWN ||</a>
<a name="ln1193">#endif</a>
<a name="ln1194">        mc &gt;= MONS_FIRST_DEMONSPAWN &amp;&amp; mc &lt;= MONS_LAST_DEMONSPAWN;</a>
<a name="ln1195">}</a>
<a name="ln1196"> </a>
<a name="ln1197">// Conjured (as opposed to summoned) monsters are actually here, even</a>
<a name="ln1198">// though they're typically volatile (like, made of real fire). As such,</a>
<a name="ln1199">// they should be immune to Abjuration or Recall. Also, they count as</a>
<a name="ln1200">// things rather than beings.</a>
<a name="ln1201">bool mons_is_conjured(monster_type mc)</a>
<a name="ln1202">{</a>
<a name="ln1203">    return mons_is_projectile(mc)</a>
<a name="ln1204">           || mons_is_avatar(mc)</a>
<a name="ln1205">           || mons_class_flag(mc, M_CONJURED);</a>
<a name="ln1206">}</a>
<a name="ln1207"> </a>
<a name="ln1208">size_type mons_class_body_size(monster_type mc)</a>
<a name="ln1209">{</a>
<a name="ln1210">    // Should pass base_type to get the right size for zombies, skeletons &amp;c.</a>
<a name="ln1211">    // For normal monsters, base_type is set to type in the constructor.</a>
<a name="ln1212">    const monsterentry *e = get_monster_data(mc);</a>
<a name="ln1213">    return e ? e-&gt;size : SIZE_MEDIUM;</a>
<a name="ln1214">}</a>
<a name="ln1215"> </a>
<a name="ln1216">int max_corpse_chunks(monster_type mc)</a>
<a name="ln1217">{</a>
<a name="ln1218">    switch (mons_class_body_size(mc))</a>
<a name="ln1219">    {</a>
<a name="ln1220">    case SIZE_TINY:</a>
<a name="ln1221">        return 1;</a>
<a name="ln1222">    case SIZE_LITTLE:</a>
<a name="ln1223">        return 2;</a>
<a name="ln1224">    case SIZE_SMALL:</a>
<a name="ln1225">        return 3;</a>
<a name="ln1226">    case SIZE_MEDIUM:</a>
<a name="ln1227">        return 4;</a>
<a name="ln1228">    case SIZE_LARGE:</a>
<a name="ln1229">        return 9;</a>
<a name="ln1230">    case SIZE_BIG:</a>
<a name="ln1231">        return 10;</a>
<a name="ln1232">    case SIZE_GIANT:</a>
<a name="ln1233">        return 12;</a>
<a name="ln1234">    default:</a>
<a name="ln1235">        return 0;</a>
<a name="ln1236">    }</a>
<a name="ln1237">}</a>
<a name="ln1238"> </a>
<a name="ln1239">corpse_effect_type mons_corpse_effect(monster_type mc)</a>
<a name="ln1240">{</a>
<a name="ln1241">    ASSERT_smc();</a>
<a name="ln1242">    return smc-&gt;corpse_thingy;</a>
<a name="ln1243">}</a>
<a name="ln1244"> </a>
<a name="ln1245">int derived_undead_avg_hp(monster_type mtype, int hd, int scale)</a>
<a name="ln1246">{</a>
<a name="ln1247">    static const map&lt;monster_type, int&gt; hp_per_hd_by_type = {</a>
<a name="ln1248">        { MONS_ZOMBIE,          85 },</a>
<a name="ln1249">        { MONS_SKELETON,        70 },</a>
<a name="ln1250">        { MONS_SPECTRAL_THING,  60 },</a>
<a name="ln1251">        // Simulacra aren't tough, but you can create piles of them. - bwr</a>
<a name="ln1252">        { MONS_SIMULACRUM,      30 },</a>
<a name="ln1253">    };</a>
<a name="ln1254"> </a>
<a name="ln1255">    const int* hp_per_hd = map_find(hp_per_hd_by_type, mtype);</a>
<a name="ln1256">    ASSERT(hp_per_hd);</a>
<a name="ln1257">    return *hp_per_hd * hd * scale / 10;</a>
<a name="ln1258">}</a>
<a name="ln1259"> </a>
<a name="ln1260">monster_type mons_genus(monster_type mc)</a>
<a name="ln1261">{</a>
<a name="ln1262">    if (mc == RANDOM_DRACONIAN || mc == RANDOM_BASE_DRACONIAN</a>
<a name="ln1263">        || mc == RANDOM_NONBASE_DRACONIAN</a>
<a name="ln1264">        || (mc == MONS_PLAYER_ILLUSION &amp;&amp; species_is_draconian(you.species)))</a>
<a name="ln1265">    {</a>
<a name="ln1266">        return MONS_DRACONIAN;</a>
<a name="ln1267">    }</a>
<a name="ln1268"> </a>
<a name="ln1269">    if (mc == RANDOM_DEMONSPAWN || mc == RANDOM_BASE_DEMONSPAWN</a>
<a name="ln1270">        || mc == RANDOM_NONBASE_DEMONSPAWN)</a>
<a name="ln1271">    {</a>
<a name="ln1272">        return MONS_DEMONSPAWN;</a>
<a name="ln1273">    }</a>
<a name="ln1274"> </a>
<a name="ln1275">    if (mc == MONS_NO_MONSTER)</a>
<a name="ln1276">        return MONS_NO_MONSTER;</a>
<a name="ln1277"> </a>
<a name="ln1278">    ASSERT_smc();</a>
<a name="ln1279">    return smc-&gt;genus;</a>
<a name="ln1280">}</a>
<a name="ln1281"> </a>
<a name="ln1282">monster_type mons_species(monster_type mc)</a>
<a name="ln1283">{</a>
<a name="ln1284">    const monsterentry *me = get_monster_data(mc);</a>
<a name="ln1285">    return me ? me-&gt;species : MONS_PROGRAM_BUG;</a>
<a name="ln1286">}</a>
<a name="ln1287"> </a>
<a name="ln1288">monster_type draco_or_demonspawn_subspecies(monster_type type,</a>
<a name="ln1289">                                            monster_type base)</a>
<a name="ln1290">{</a>
<a name="ln1291">    const monster_type species = mons_species(type);</a>
<a name="ln1292"> </a>
<a name="ln1293">    if ((species == MONS_DRACONIAN || species == MONS_DEMONSPAWN)</a>
<a name="ln1294">        &amp;&amp; type != species)</a>
<a name="ln1295">    {</a>
<a name="ln1296">        return base;</a>
<a name="ln1297">    }</a>
<a name="ln1298"> </a>
<a name="ln1299">    return species;</a>
<a name="ln1300">}</a>
<a name="ln1301"> </a>
<a name="ln1302">monster_type draco_or_demonspawn_subspecies(const monster&amp; mon)</a>
<a name="ln1303">{</a>
<a name="ln1304">    ASSERT(mons_genus(mon.type) == MONS_DRACONIAN</a>
<a name="ln1305">           || mons_genus(mon.type) == MONS_DEMONSPAWN);</a>
<a name="ln1306"> </a>
<a name="ln1307">    if (mon.type == MONS_PLAYER_ILLUSION</a>
<a name="ln1308">        &amp;&amp; mons_genus(mon.type) == MONS_DRACONIAN)</a>
<a name="ln1309">    {</a>
<a name="ln1310">        return player_species_to_mons_species(mon.ghost-&gt;species);</a>
<a name="ln1311">    }</a>
<a name="ln1312"> </a>
<a name="ln1313">    return draco_or_demonspawn_subspecies(mon.type, mon.base_monster);</a>
<a name="ln1314">}</a>
<a name="ln1315"> </a>
<a name="ln1316">monster_type mons_detected_base(monster_type mc)</a>
<a name="ln1317">{</a>
<a name="ln1318">    return mons_genus(mc);</a>
<a name="ln1319">}</a>
<a name="ln1320"> </a>
<a name="ln1321">/** Does a monster of this type behold opponents like a siren?</a>
<a name="ln1322"> */</a>
<a name="ln1323">bool mons_is_siren_beholder(monster_type mc)</a>
<a name="ln1324">{</a>
<a name="ln1325">    return mc == MONS_MERFOLK_SIREN || mc == MONS_MERFOLK_AVATAR;</a>
<a name="ln1326">}</a>
<a name="ln1327"> </a>
<a name="ln1328">/** Does this monster behold opponents like a siren?</a>
<a name="ln1329"> *  Ignores any disabilities, checking only the monster's type.</a>
<a name="ln1330"> */</a>
<a name="ln1331">bool mons_is_siren_beholder(const monster&amp; mons)</a>
<a name="ln1332">{</a>
<a name="ln1333">    return mons_is_siren_beholder(mons.type);</a>
<a name="ln1334">}</a>
<a name="ln1335"> </a>
<a name="ln1336">int get_shout_noise_level(const shout_type shout)</a>
<a name="ln1337">{</a>
<a name="ln1338">    switch (shout)</a>
<a name="ln1339">    {</a>
<a name="ln1340">    case S_SILENT:</a>
<a name="ln1341">        return 0;</a>
<a name="ln1342">    case S_HISS:</a>
<a name="ln1343">    case S_VERY_SOFT:</a>
<a name="ln1344">        return 4;</a>
<a name="ln1345">    case S_SOFT:</a>
<a name="ln1346">        return 6;</a>
<a name="ln1347">    case S_LOUD:</a>
<a name="ln1348">        return 10;</a>
<a name="ln1349">    case S_LOUD_ROAR:</a>
<a name="ln1350">    case S_VERY_LOUD:</a>
<a name="ln1351">        return 12;</a>
<a name="ln1352"> </a>
<a name="ln1353">    default:</a>
<a name="ln1354">        return 8;</a>
<a name="ln1355">    }</a>
<a name="ln1356">}</a>
<a name="ln1357"> </a>
<a name="ln1358">// Only beasts and chaos spawns use S_RANDOM for noise type.</a>
<a name="ln1359">// Pandemonium lords can also get here, but this is mostly used for the</a>
<a name="ln1360">// &quot;says&quot; verb used for insults.</a>
<a name="ln1361">static bool _shout_fits_monster(monster_type mc, int shout)</a>
<a name="ln1362">{</a>
<a name="ln1363">    if (shout == NUM_SHOUTS || shout &gt;= NUM_LOUDNESS || shout == S_SILENT)</a>
<a name="ln1364">        return false;</a>
<a name="ln1365"> </a>
<a name="ln1366">    // Chaos spawns can do anything but demon taunts, since they're</a>
<a name="ln1367">    // not coherent enough to actually say words.</a>
<a name="ln1368">    if (mc == MONS_CHAOS_SPAWN)</a>
<a name="ln1369">        return shout != S_DEMON_TAUNT;</a>
<a name="ln1370"> </a>
<a name="ln1371">    // For Pandemonium lords, almost everything is fair game. It's only</a>
<a name="ln1372">    // used for the shouting verb (&quot;say&quot;, &quot;bellow&quot;, &quot;roar&quot;, etc.) anyway.</a>
<a name="ln1373">    if (mc != MONS_HELL_BEAST &amp;&amp; mc != MONS_MUTANT_BEAST)</a>
<a name="ln1374">        return true;</a>
<a name="ln1375"> </a>
<a name="ln1376">    switch (shout)</a>
<a name="ln1377">    {</a>
<a name="ln1378">    // Bees, cherubs and two-headed ogres never fit.</a>
<a name="ln1379">    case S_SHOUT2:</a>
<a name="ln1380">    case S_BUZZ:</a>
<a name="ln1381">    case S_CHERUB:</a>
<a name="ln1382">    // The beast cannot speak.</a>
<a name="ln1383">    case S_DEMON_TAUNT:</a>
<a name="ln1384">        return false;</a>
<a name="ln1385">    default:</a>
<a name="ln1386">        return true;</a>
<a name="ln1387">    }</a>
<a name="ln1388">}</a>
<a name="ln1389"> </a>
<a name="ln1390">// If demon_shout is true, we're trying to find a random verb and</a>
<a name="ln1391">// loudness for a Pandemonium lord trying to shout.</a>
<a name="ln1392">shout_type mons_shouts(monster_type mc, bool demon_shout)</a>
<a name="ln1393">{</a>
<a name="ln1394">    ASSERT_smc();</a>
<a name="ln1395">    shout_type u = smc-&gt;shouts;</a>
<a name="ln1396"> </a>
<a name="ln1397">    // Pandemonium lords use this to get the noises.</a>
<a name="ln1398">    if (u == S_RANDOM || demon_shout &amp;&amp; u == S_DEMON_TAUNT)</a>
<a name="ln1399">    {</a>
<a name="ln1400">        const int max_shout = (u == S_RANDOM ? NUM_SHOUTS : NUM_LOUDNESS);</a>
<a name="ln1401">        do</a>
<a name="ln1402">        {</a>
<a name="ln1403">            u = static_cast&lt;shout_type&gt;(random2(max_shout));</a>
<a name="ln1404">        }</a>
<a name="ln1405">        while (!_shout_fits_monster(mc, u));</a>
<a name="ln1406">    }</a>
<a name="ln1407"> </a>
<a name="ln1408">    return u;</a>
<a name="ln1409">}</a>
<a name="ln1410"> </a>
<a name="ln1411">/// Is the given monster type ever capable of shouting?</a>
<a name="ln1412">bool mons_can_shout(monster_type mc)</a>
<a name="ln1413">{</a>
<a name="ln1414">    // don't use mons_shouts() to avoid S_RANDOM randomization.</a>
<a name="ln1415">    ASSERT_smc();</a>
<a name="ln1416">    return smc-&gt;shouts != S_SILENT;</a>
<a name="ln1417">}</a>
<a name="ln1418"> </a>
<a name="ln1419">bool mons_is_ghost_demon(monster_type mc)</a>
<a name="ln1420">{</a>
<a name="ln1421">    return mons_class_flag(mc, M_GHOST_DEMON);</a>
<a name="ln1422">}</a>
<a name="ln1423"> </a>
<a name="ln1424">bool mons_is_pghost(monster_type mc)</a>
<a name="ln1425">{</a>
<a name="ln1426">    return mc == MONS_PLAYER_GHOST || mc == MONS_PLAYER_ILLUSION;</a>
<a name="ln1427">}</a>
<a name="ln1428"> </a>
<a name="ln1429">/**</a>
<a name="ln1430"> * What mutant beast tier does the given XL (base HD) correspond to?</a>
<a name="ln1431"> *</a>
<a name="ln1432"> * If the given value is between tiers, choose the higher possibility.</a>
<a name="ln1433"> *</a>
<a name="ln1434"> * @param xl    The XL (HD) of the mutant beast in question.</a>
<a name="ln1435"> * @return      The corresponding mutant beast tier (e.g. BT_MATURE).</a>
<a name="ln1436"> */</a>
<a name="ln1437">int mutant_beast_tier(int xl)</a>
<a name="ln1438">{</a>
<a name="ln1439">    for (int bt = BT_FIRST; bt &lt; NUM_BEAST_TIERS; ++bt)</a>
<a name="ln1440">        if (xl &lt;= beast_tiers[bt])</a>
<a name="ln1441">            return bt;</a>
<a name="ln1442">    return BT_NONE; // buggy</a>
<a name="ln1443">}</a>
<a name="ln1444"> </a>
<a name="ln1445">/**</a>
<a name="ln1446"> * Is the provided monster_type a demonspawn job type? (Not just any</a>
<a name="ln1447"> * demonspawn, but specifically one with a job! Or the job itself, depending</a>
<a name="ln1448"> * how you think about it.)</a>
<a name="ln1449"> *</a>
<a name="ln1450"> * @param mc    The monster type in question.</a>
<a name="ln1451"> * @return      Whether that monster type is a demonspawn job.</a>
<a name="ln1452"> **/</a>
<a name="ln1453">bool mons_is_demonspawn_job(monster_type mc)</a>
<a name="ln1454">{</a>
<a name="ln1455">    return mc &gt;= MONS_FIRST_NONBASE_DEMONSPAWN</a>
<a name="ln1456">           &amp;&amp; mc &lt;= MONS_LAST_NONBASE_DEMONSPAWN;</a>
<a name="ln1457">}</a>
<a name="ln1458"> </a>
<a name="ln1459">/**</a>
<a name="ln1460"> * Is the provided monster_type a draconian job type? (Not just any draconian,</a>
<a name="ln1461"> * but specifically one with a job! Or the job itself, depending how you think</a>
<a name="ln1462"> * about it.)</a>
<a name="ln1463"> *</a>
<a name="ln1464"> * @param mc    The monster type in question.</a>
<a name="ln1465"> * @return      Whether that monster type is a draconian job.</a>
<a name="ln1466"> **/</a>
<a name="ln1467">bool mons_is_draconian_job(monster_type mc)</a>
<a name="ln1468">{</a>
<a name="ln1469">    return mc &gt;= MONS_FIRST_NONBASE_DRACONIAN</a>
<a name="ln1470">           &amp;&amp; mc &lt;= MONS_LAST_NONBASE_DRACONIAN;</a>
<a name="ln1471">}</a>
<a name="ln1472"> </a>
<a name="ln1473">/**</a>
<a name="ln1474"> * Is the provided monster_type a job? (E.g. black sun, draconian knight)</a>
<a name="ln1475"> *</a>
<a name="ln1476"> * @param mc    The monster type in question.</a>
<a name="ln1477"> * @return      Whether that monster type is a job.</a>
<a name="ln1478"> **/</a>
<a name="ln1479">bool mons_is_job(monster_type mc)</a>
<a name="ln1480">{</a>
<a name="ln1481">    return mons_is_draconian_job(mc) || mons_is_demonspawn_job(mc);</a>
<a name="ln1482">}</a>
<a name="ln1483"> </a>
<a name="ln1484">bool mons_is_unique(monster_type mc)</a>
<a name="ln1485">{</a>
<a name="ln1486">    return mons_class_flag(mc, M_UNIQUE);</a>
<a name="ln1487">}</a>
<a name="ln1488"> </a>
<a name="ln1489">bool mons_is_or_was_unique(const monster&amp; mon)</a>
<a name="ln1490">{</a>
<a name="ln1491">    return mons_is_unique(mon.type)</a>
<a name="ln1492">           || mon.props.exists(ORIGINAL_TYPE_KEY)</a>
<a name="ln1493">              &amp;&amp; mons_is_unique((monster_type) mon.props[ORIGINAL_TYPE_KEY].get_int());</a>
<a name="ln1494">}</a>
<a name="ln1495"> </a>
<a name="ln1496">/**</a>
<a name="ln1497"> * Is the given type one of Hepliaklqana's granted ancestors?</a>
<a name="ln1498"> *</a>
<a name="ln1499"> * @param mc    The type of monster in question.</a>
<a name="ln1500"> * @return      Whether that monster is a player ancestor.</a>
<a name="ln1501"> */</a>
<a name="ln1502">bool mons_is_hepliaklqana_ancestor(monster_type mc)</a>
<a name="ln1503">{</a>
<a name="ln1504">    return mons_class_flag(mc, M_ANCESTOR);</a>
<a name="ln1505">}</a>
<a name="ln1506"> </a>
<a name="ln1507">/**</a>
<a name="ln1508"> * Can this type of monster be blinded?</a>
<a name="ln1509"> *</a>
<a name="ln1510"> * Certain monsters, e.g. those with a powerful sense of smell, echolocation,</a>
<a name="ln1511"> * or no eyes, are completely immune to blinding.</a>
<a name="ln1512"> *</a>
<a name="ln1513"> * Note that 'dazzling' (from dazzling spray) has additional restrictions above</a>
<a name="ln1514"> * this.</a>
<a name="ln1515"> *</a>
<a name="ln1516"> * @param mc    The class of monster in question.</a>
<a name="ln1517"> * @return      Whether monsters of this type can get ENCH_BLIND.</a>
<a name="ln1518"> */</a>
<a name="ln1519">bool mons_can_be_blinded(monster_type mc)</a>
<a name="ln1520">{</a>
<a name="ln1521">    return !mons_class_flag(mc, M_UNBLINDABLE);</a>
<a name="ln1522">}</a>
<a name="ln1523"> </a>
<a name="ln1524"> </a>
<a name="ln1525">/**</a>
<a name="ln1526"> * Can this kind of monster be dazzled?</a>
<a name="ln1527"> *</a>
<a name="ln1528"> * The undead, nonliving, vegetative, or unblindable cannot be dazzled.</a>
<a name="ln1529"> *</a>
<a name="ln1530"> * @param mc    The class of monster in question.</a>
<a name="ln1531"> * @return      Whether monsters of this type can get ENCH_BLIND from Dazzling</a>
<a name="ln1532"> *              Spray.</a>
<a name="ln1533"> */</a>
<a name="ln1534">bool mons_can_be_dazzled(monster_type mc)</a>
<a name="ln1535">{</a>
<a name="ln1536">    // This was implemented by checking type so that we could use it in</a>
<a name="ln1537">    // monster descriptions (which only have mon_info structs); not sure if</a>
<a name="ln1538">    // that's useful</a>
<a name="ln1539"> </a>
<a name="ln1540">    const mon_holy_type holiness = mons_class_holiness(mc);</a>
<a name="ln1541">    return !(holiness &amp; (MH_UNDEAD | MH_NONLIVING | MH_PLANT))</a>
<a name="ln1542">        &amp;&amp; mons_can_be_blinded(mc);</a>
<a name="ln1543">}</a>
<a name="ln1544"> </a>
<a name="ln1545">char32_t mons_char(monster_type mc)</a>
<a name="ln1546">{</a>
<a name="ln1547">    if (Options.mon_glyph_overrides.count(mc)</a>
<a name="ln1548">        &amp;&amp; Options.mon_glyph_overrides[mc].ch)</a>
<a name="ln1549">    {</a>
<a name="ln1550">        return Options.mon_glyph_overrides[mc].ch;</a>
<a name="ln1551">    }</a>
<a name="ln1552">    else</a>
<a name="ln1553">        return monster_symbols[mc].glyph;</a>
<a name="ln1554">}</a>
<a name="ln1555"> </a>
<a name="ln1556">char mons_base_char(monster_type mc)</a>
<a name="ln1557">{</a>
<a name="ln1558">    const monsterentry *me = get_monster_data(mc);</a>
<a name="ln1559">    return me ? me-&gt;basechar : 0;</a>
<a name="ln1560">}</a>
<a name="ln1561"> </a>
<a name="ln1562">mon_itemuse_type mons_class_itemuse(monster_type mc)</a>
<a name="ln1563">{</a>
<a name="ln1564">    ASSERT_smc();</a>
<a name="ln1565">    return smc-&gt;gmon_use;</a>
<a name="ln1566">}</a>
<a name="ln1567"> </a>
<a name="ln1568">mon_itemuse_type mons_itemuse(const monster&amp; mon)</a>
<a name="ln1569">{</a>
<a name="ln1570">    if (mons_enslaved_soul(mon))</a>
<a name="ln1571">        return mons_class_itemuse(mons_zombie_base(mon));</a>
<a name="ln1572"> </a>
<a name="ln1573">    return mons_class_itemuse(mon.type);</a>
<a name="ln1574">}</a>
<a name="ln1575"> </a>
<a name="ln1576">int mons_class_colour(monster_type mc)</a>
<a name="ln1577">{</a>
<a name="ln1578">    ASSERT_smc();</a>
<a name="ln1579">    // Player monster is a dummy monster used only for display purposes, so</a>
<a name="ln1580">    // it's ok to override it here.</a>
<a name="ln1581">    if (mc == MONS_PLAYER</a>
<a name="ln1582">        &amp;&amp; Options.mon_glyph_overrides.count(MONS_PLAYER)</a>
<a name="ln1583">        &amp;&amp; Options.mon_glyph_overrides[MONS_PLAYER].col)</a>
<a name="ln1584">    {</a>
<a name="ln1585">        return Options.mon_glyph_overrides[MONS_PLAYER].col;</a>
<a name="ln1586">    }</a>
<a name="ln1587">    else</a>
<a name="ln1588">        return monster_symbols[mc].colour;</a>
<a name="ln1589">}</a>
<a name="ln1590"> </a>
<a name="ln1591">bool mons_class_can_regenerate(monster_type mc)</a>
<a name="ln1592">{</a>
<a name="ln1593">    return !mons_class_flag(mc, M_NO_REGEN);</a>
<a name="ln1594">}</a>
<a name="ln1595"> </a>
<a name="ln1596">bool mons_can_regenerate(const monster&amp; m)</a>
<a name="ln1597">{</a>
<a name="ln1598">    const monster&amp; mon = get_tentacle_head(m);</a>
<a name="ln1599"> </a>
<a name="ln1600">    if (testbits(mon.flags, MF_NO_REGEN))</a>
<a name="ln1601">        return false;</a>
<a name="ln1602"> </a>
<a name="ln1603">    return mons_class_can_regenerate(mon.type);</a>
<a name="ln1604">}</a>
<a name="ln1605"> </a>
<a name="ln1606">bool mons_class_fast_regen(monster_type mc)</a>
<a name="ln1607">{</a>
<a name="ln1608">    return mons_class_flag(mc, M_FAST_REGEN);</a>
<a name="ln1609">}</a>
<a name="ln1610"> </a>
<a name="ln1611">/**</a>
<a name="ln1612"> * Do monsters of the given type ever leave a hide?</a>
<a name="ln1613"> *</a>
<a name="ln1614"> * @param mc      The class of monster in question.</a>
<a name="ln1615"> * @return        Whether the monster has a chance of dropping a hide when</a>
<a name="ln1616"> *                butchered.</a>
<a name="ln1617"> */</a>
<a name="ln1618">bool mons_class_leaves_hide(monster_type mc)</a>
<a name="ln1619">{</a>
<a name="ln1620">    return hide_for_monster(mc) != NUM_ARMOURS;</a>
<a name="ln1621">}</a>
<a name="ln1622"> </a>
<a name="ln1623">int mons_zombie_size(monster_type mc)</a>
<a name="ln1624">{</a>
<a name="ln1625">    mc = mons_species(mc);</a>
<a name="ln1626">    if (!mons_class_can_be_zombified(mc))</a>
<a name="ln1627">        return Z_NOZOMBIE;</a>
<a name="ln1628"> </a>
<a name="ln1629">    ASSERT_smc();</a>
<a name="ln1630">    return smc-&gt;size &gt; SIZE_MEDIUM ? Z_BIG : Z_SMALL;</a>
<a name="ln1631">}</a>
<a name="ln1632"> </a>
<a name="ln1633">monster_type mons_zombie_base(const monster&amp; mon)</a>
<a name="ln1634">{</a>
<a name="ln1635">    return mons_species(mon.base_monster);</a>
<a name="ln1636">}</a>
<a name="ln1637"> </a>
<a name="ln1638">bool mons_class_is_zombified(monster_type mc)</a>
<a name="ln1639">{</a>
<a name="ln1640">#if TAG_MAJOR_VERSION == 34</a>
<a name="ln1641">    switch (mc)</a>
<a name="ln1642">    {</a>
<a name="ln1643">        case MONS_ZOMBIE_SMALL:     case MONS_ZOMBIE_LARGE:</a>
<a name="ln1644">        case MONS_SKELETON_SMALL:   case MONS_SKELETON_LARGE:</a>
<a name="ln1645">        case MONS_SIMULACRUM_SMALL: case MONS_SIMULACRUM_LARGE:</a>
<a name="ln1646">            return true;</a>
<a name="ln1647">        default:</a>
<a name="ln1648">            break;</a>
<a name="ln1649">    }</a>
<a name="ln1650">#endif</a>
<a name="ln1651"> </a>
<a name="ln1652">    return mc == MONS_ZOMBIE</a>
<a name="ln1653">        || mc == MONS_SKELETON</a>
<a name="ln1654">        || mc == MONS_SIMULACRUM</a>
<a name="ln1655">        || mc == MONS_SPECTRAL_THING;</a>
<a name="ln1656">}</a>
<a name="ln1657"> </a>
<a name="ln1658">bool mons_class_is_hybrid(monster_type mc)</a>
<a name="ln1659">{</a>
<a name="ln1660">    return mons_class_flag(mc, M_HYBRID);</a>
<a name="ln1661">}</a>
<a name="ln1662"> </a>
<a name="ln1663">bool mons_class_is_animated_weapon(monster_type type)</a>
<a name="ln1664">{</a>
<a name="ln1665">    return type == MONS_DANCING_WEAPON || type == MONS_SPECTRAL_WEAPON;</a>
<a name="ln1666">}</a>
<a name="ln1667"> </a>
<a name="ln1668">bool mons_is_zombified(const monster&amp; mon)</a>
<a name="ln1669">{</a>
<a name="ln1670">    return mons_class_is_zombified(mon.type);</a>
<a name="ln1671">}</a>
<a name="ln1672"> </a>
<a name="ln1673">monster_type mons_base_type(const monster&amp; mon)</a>
<a name="ln1674">{</a>
<a name="ln1675">    if (mons_class_is_zombified(mon.type))</a>
<a name="ln1676">        return mons_species(mon.base_monster);</a>
<a name="ln1677">    return mon.type;</a>
<a name="ln1678">}</a>
<a name="ln1679"> </a>
<a name="ln1680">bool mons_class_can_leave_corpse(monster_type mc)</a>
<a name="ln1681">{</a>
<a name="ln1682">    return mons_corpse_effect(mc) != CE_NOCORPSE;</a>
<a name="ln1683">}</a>
<a name="ln1684"> </a>
<a name="ln1685">bool mons_class_can_be_zombified(monster_type mc)</a>
<a name="ln1686">{</a>
<a name="ln1687">    monster_type ms = mons_species(mc);</a>
<a name="ln1688">    return !invalid_monster_type(ms)</a>
<a name="ln1689">           &amp;&amp; mons_class_can_leave_corpse(ms);</a>
<a name="ln1690">}</a>
<a name="ln1691"> </a>
<a name="ln1692">bool mons_can_be_zombified(const monster&amp; mon)</a>
<a name="ln1693">{</a>
<a name="ln1694">    return mons_class_can_be_zombified(mon.type)</a>
<a name="ln1695">           &amp;&amp; !mon.is_summoned()</a>
<a name="ln1696">           &amp;&amp; !mons_enslaved_body_and_soul(mon);</a>
<a name="ln1697">}</a>
<a name="ln1698"> </a>
<a name="ln1699">bool mons_class_can_use_stairs(monster_type mc)</a>
<a name="ln1700">{</a>
<a name="ln1701">    return (!mons_class_is_zombified(mc) || mc == MONS_SPECTRAL_THING)</a>
<a name="ln1702">           &amp;&amp; !mons_is_tentacle_or_tentacle_segment(mc)</a>
<a name="ln1703">           &amp;&amp; mc != MONS_SILENT_SPECTRE</a>
<a name="ln1704">           &amp;&amp; mc != MONS_GERYON</a>
<a name="ln1705">           &amp;&amp; mc != MONS_ROYAL_JELLY</a>
<a name="ln1706">           &amp;&amp; mc != MONS_BALL_LIGHTNING</a>
<a name="ln1707">           &amp;&amp; mc != MONS_FOXFIRE;</a>
<a name="ln1708">}</a>
<a name="ln1709"> </a>
<a name="ln1710">bool mons_class_can_use_transporter(monster_type mc)</a>
<a name="ln1711">{</a>
<a name="ln1712">    return !mons_is_tentacle_or_tentacle_segment(mc);</a>
<a name="ln1713">}</a>
<a name="ln1714"> </a>
<a name="ln1715">bool mons_can_use_stairs(const monster&amp; mon, dungeon_feature_type stair)</a>
<a name="ln1716">{</a>
<a name="ln1717">    if (!mons_class_can_use_stairs(mon.type))</a>
<a name="ln1718">        return false;</a>
<a name="ln1719"> </a>
<a name="ln1720">    // Summons can't use stairs.</a>
<a name="ln1721">    if (mon.has_ench(ENCH_ABJ) || mon.has_ench(ENCH_FAKE_ABJURATION))</a>
<a name="ln1722">        return false;</a>
<a name="ln1723"> </a>
<a name="ln1724">    if (mon.has_ench(ENCH_FRIENDLY_BRIBED)</a>
<a name="ln1725">        &amp;&amp; (feat_is_branch_entrance(stair) || feat_is_branch_exit(stair)</a>
<a name="ln1726">            || stair == DNGN_ENTER_HELL || stair == DNGN_EXIT_HELL))</a>
<a name="ln1727">    {</a>
<a name="ln1728">        return false;</a>
<a name="ln1729">    }</a>
<a name="ln1730"> </a>
<a name="ln1731">    // Everything else is fine</a>
<a name="ln1732">    return true;</a>
<a name="ln1733">}</a>
<a name="ln1734"> </a>
<a name="ln1735">bool mons_enslaved_body_and_soul(const monster&amp; mon)</a>
<a name="ln1736">{</a>
<a name="ln1737">    return mon.has_ench(ENCH_SOUL_RIPE);</a>
<a name="ln1738">}</a>
<a name="ln1739"> </a>
<a name="ln1740">bool mons_enslaved_soul(const monster&amp; mon)</a>
<a name="ln1741">{</a>
<a name="ln1742">    return testbits(mon.flags, MF_ENSLAVED_SOUL);</a>
<a name="ln1743">}</a>
<a name="ln1744"> </a>
<a name="ln1745">void name_zombie(monster&amp; mon, monster_type mc, const string &amp;mon_name)</a>
<a name="ln1746">{</a>
<a name="ln1747">    mon.mname = mon_name;</a>
<a name="ln1748"> </a>
<a name="ln1749">    // Special case for Blork the orc: shorten his name to &quot;Blork&quot; to</a>
<a name="ln1750">    // avoid mentions of &quot;Blork the orc the orc zombie&quot;.</a>
<a name="ln1751">    if (mc == MONS_BLORK_THE_ORC)</a>
<a name="ln1752">        mon.mname = &quot;Blork&quot;;</a>
<a name="ln1753">    // Also for the Lernaean hydra: treat Lernaean as an adjective to</a>
<a name="ln1754">    // avoid mentions of &quot;the Lernaean hydra the X-headed hydra zombie&quot;.</a>
<a name="ln1755">    else if (mc == MONS_LERNAEAN_HYDRA)</a>
<a name="ln1756">    {</a>
<a name="ln1757">        mon.mname = &quot;Lernaean&quot;;</a>
<a name="ln1758">        mon.flags |= MF_NAME_ADJECTIVE;</a>
<a name="ln1759">    }</a>
<a name="ln1760">    // Also for the Enchantress: treat Enchantress as an adjective to</a>
<a name="ln1761">    // avoid mentions of &quot;the Enchantress the spriggan zombie&quot;.</a>
<a name="ln1762">    else if (mc == MONS_THE_ENCHANTRESS)</a>
<a name="ln1763">    {</a>
<a name="ln1764">        mon.mname = &quot;Enchantress&quot;;</a>
<a name="ln1765">        mon.flags |= MF_NAME_ADJECTIVE;</a>
<a name="ln1766">    }</a>
<a name="ln1767">    else if (mons_species(mc) == MONS_SERPENT_OF_HELL)</a>
<a name="ln1768">        mon.mname = &quot;&quot;;</a>
<a name="ln1769"> </a>
<a name="ln1770">    if (starts_with(mon.mname, &quot;shaped &quot;))</a>
<a name="ln1771">        mon.flags |= MF_NAME_SUFFIX;</a>
<a name="ln1772"> </a>
<a name="ln1773">    // It's unlikely there's a desc for &quot;Duvessa the elf skeleton&quot;, but</a>
<a name="ln1774">    // we still want to allow it if overridden.</a>
<a name="ln1775">    if (!mon.props.exists(&quot;dbname&quot;))</a>
<a name="ln1776">        mon.props[&quot;dbname&quot;] = mons_class_name(mon.type);</a>
<a name="ln1777">}</a>
<a name="ln1778"> </a>
<a name="ln1779">void name_zombie(monster&amp; mon, const monster&amp; orig)</a>
<a name="ln1780">{</a>
<a name="ln1781">    if (!mons_is_unique(orig.type) &amp;&amp; orig.mname.empty())</a>
<a name="ln1782">        return;</a>
<a name="ln1783"> </a>
<a name="ln1784">    string name;</a>
<a name="ln1785"> </a>
<a name="ln1786">    if (!orig.mname.empty())</a>
<a name="ln1787">        name = orig.mname;</a>
<a name="ln1788">    else</a>
<a name="ln1789">        name = mons_type_name(orig.type, DESC_PLAIN);</a>
<a name="ln1790"> </a>
<a name="ln1791">    name_zombie(mon, orig.type, name);</a>
<a name="ln1792">    mon.flags |= orig.flags &amp; (MF_NAME_SUFFIX</a>
<a name="ln1793">                                 | MF_NAME_ADJECTIVE</a>
<a name="ln1794">                                 | MF_NAME_DESCRIPTOR);</a>
<a name="ln1795">}</a>
<a name="ln1796"> </a>
<a name="ln1797">// Derived undead deal 80% of the damage of the base form.</a>
<a name="ln1798">static int _downscale_zombie_damage(int damage)</a>
<a name="ln1799">{</a>
<a name="ln1800">    return max(1, 4 * damage / 5);</a>
<a name="ln1801">}</a>
<a name="ln1802"> </a>
<a name="ln1803">static mon_attack_def _downscale_zombie_attack(const monster&amp; mons,</a>
<a name="ln1804">                                               mon_attack_def attk,</a>
<a name="ln1805">                                               bool random)</a>
<a name="ln1806">{</a>
<a name="ln1807">    switch (attk.type)</a>
<a name="ln1808">    {</a>
<a name="ln1809">    case AT_STING: case AT_SPORE:</a>
<a name="ln1810">    case AT_TOUCH: case AT_ENGULF:</a>
<a name="ln1811">        attk.type = AT_HIT;</a>
<a name="ln1812">        break;</a>
<a name="ln1813">    default:</a>
<a name="ln1814">        break;</a>
<a name="ln1815">    }</a>
<a name="ln1816"> </a>
<a name="ln1817">    if (mons.type == MONS_SIMULACRUM)</a>
<a name="ln1818">        attk.flavour = AF_COLD;</a>
<a name="ln1819">    else if (mons.type == MONS_SPECTRAL_THING &amp;&amp; (!random || coinflip()))</a>
<a name="ln1820">        attk.flavour = AF_DRAIN_XP;</a>
<a name="ln1821">    else if (attk.flavour != AF_REACH &amp;&amp; attk.flavour != AF_CRUSH)</a>
<a name="ln1822">        attk.flavour = AF_PLAIN;</a>
<a name="ln1823"> </a>
<a name="ln1824">    attk.damage = _downscale_zombie_damage(attk.damage);</a>
<a name="ln1825"> </a>
<a name="ln1826">    return attk;</a>
<a name="ln1827">}</a>
<a name="ln1828"> </a>
<a name="ln1829">/**</a>
<a name="ln1830"> * What attack does the given mutant beast facet provide?</a>
<a name="ln1831"> *</a>
<a name="ln1832"> * @param facet     The facet in question; e.g. BF_STING.</a>
<a name="ln1833"> * @param tier      The tier of the mutant beast; e.g.</a>
<a name="ln1834"> * @return          The attack corresponding to the given facet; e.g. BT_LARVAL</a>
<a name="ln1835"> *                  { AT_STING, AF_REACH_STING, 10 }. Scales with HD.</a>
<a name="ln1836"> *                  For facets that don't provide an attack, is { }.</a>
<a name="ln1837"> */</a>
<a name="ln1838">static mon_attack_def _mutant_beast_facet_attack(int facet, int tier)</a>
<a name="ln1839">{</a>
<a name="ln1840">    const int dam = tier * 5;</a>
<a name="ln1841">    switch (facet)</a>
<a name="ln1842">    {</a>
<a name="ln1843">        case BF_STING:</a>
<a name="ln1844">            return { AT_STING, AF_REACH_STING, dam };</a>
<a name="ln1845">        case BF_OX:</a>
<a name="ln1846">            return { AT_TRAMPLE, AF_TRAMPLE, dam };</a>
<a name="ln1847">        case BF_WEIRD:</a>
<a name="ln1848">            return { AT_CONSTRICT, AF_CRUSH, dam };</a>
<a name="ln1849">        default:</a>
<a name="ln1850">            return { };</a>
<a name="ln1851">    }</a>
<a name="ln1852">}</a>
<a name="ln1853"> </a>
<a name="ln1854">/**</a>
<a name="ln1855"> * Get the attack type, attack flavour and damage for the given attack of a</a>
<a name="ln1856"> * mutant beast.</a>
<a name="ln1857"> *</a>
<a name="ln1858"> * @param mon           The monster in question.</a>
<a name="ln1859"> * @param attk_number   Which attack number to get.</a>
<a name="ln1860"> * @return              A mon_attack_def for the specified attack.</a>
<a name="ln1861"> */</a>
<a name="ln1862">static mon_attack_def _mutant_beast_attack(const monster &amp;mon, int attk_number)</a>
<a name="ln1863">{</a>
<a name="ln1864">    const int tier = mutant_beast_tier(mon.get_experience_level());</a>
<a name="ln1865">    if (attk_number == 0)</a>
<a name="ln1866">        return { AT_HIT, AF_PLAIN, tier * 7 + 5 };</a>
<a name="ln1867"> </a>
<a name="ln1868">    if (!mon.props.exists(MUTANT_BEAST_FACETS))</a>
<a name="ln1869">        return { };</a>
<a name="ln1870"> </a>
<a name="ln1871">    int cur_attk = 1;</a>
<a name="ln1872">    for (auto facet : mon.props[MUTANT_BEAST_FACETS].get_vector())</a>
<a name="ln1873">    {</a>
<a name="ln1874">        const mon_attack_def atk = _mutant_beast_facet_attack(facet.get_int(),</a>
<a name="ln1875">                                                              tier);</a>
<a name="ln1876">        if (atk.type == AT_NONE)</a>
<a name="ln1877">            continue;</a>
<a name="ln1878"> </a>
<a name="ln1879">        if (cur_attk == attk_number)</a>
<a name="ln1880">            return atk;</a>
<a name="ln1881"> </a>
<a name="ln1882">        ++cur_attk;</a>
<a name="ln1883">    }</a>
<a name="ln1884"> </a>
<a name="ln1885">    return { };</a>
<a name="ln1886">}</a>
<a name="ln1887"> </a>
<a name="ln1888">/**</a>
<a name="ln1889"> * Get the attack type, attack flavour and damage for the given attack of an</a>
<a name="ln1890"> * ancestor granted by Hepliaklqana_ancestor_attack.</a>
<a name="ln1891"> *</a>
<a name="ln1892"> * @param mon           The monster in question.</a>
<a name="ln1893"> * @param attk_number   Which attack number to get.</a>
<a name="ln1894"> * @return              A mon_attack_def for the specified attack.</a>
<a name="ln1895"> */</a>
<a name="ln1896">static mon_attack_def _hepliaklqana_ancestor_attack(const monster &amp;mon,</a>
<a name="ln1897">                                                     int attk_number)</a>
<a name="ln1898">{</a>
<a name="ln1899">    if (attk_number != 0)</a>
<a name="ln1900">        return { };</a>
<a name="ln1901"> </a>
<a name="ln1902">    const int HD = mon.get_experience_level();</a>
<a name="ln1903">    const int dam = HD + 3; // 4 at 1 HD, 21 at 18 HD (max)</a>
<a name="ln1904">    // battlemages do double base melee damage (+25-50% including their weapon)</a>
<a name="ln1905">    const int dam_mult = mon.type == MONS_ANCESTOR_BATTLEMAGE ? 2 : 1;</a>
<a name="ln1906"> </a>
<a name="ln1907">    return { AT_HIT, AF_PLAIN, dam * dam_mult };</a>
<a name="ln1908">}</a>
<a name="ln1909"> </a>
<a name="ln1910">/** Get the attack type, attack flavour and damage for a monster attack.</a>
<a name="ln1911"> *</a>
<a name="ln1912"> * @param mon The monster to look at.</a>
<a name="ln1913"> * @param attk_number Which attack number to get.</a>
<a name="ln1914"> * @param base_flavour If true, attack flavours that are randomised on every attack</a>
<a name="ln1915"> *                     will have their base flavour returned instead of one of the</a>
<a name="ln1916"> *                     random flavours.</a>
<a name="ln1917"> * @return  A mon_attack_def for the specified attack.</a>
<a name="ln1918"> */</a>
<a name="ln1919">mon_attack_def mons_attack_spec(const monster&amp; m, int attk_number,</a>
<a name="ln1920">                                bool base_flavour)</a>
<a name="ln1921">{</a>
<a name="ln1922">    monster_type mc = m.type;</a>
<a name="ln1923"> </a>
<a name="ln1924">    const monster&amp; mon = get_tentacle_head(m);</a>
<a name="ln1925"> </a>
<a name="ln1926">    const bool zombified = mons_is_zombified(mon);</a>
<a name="ln1927"> </a>
<a name="ln1928">    if (mon.has_hydra_multi_attack())</a>
<a name="ln1929">        attk_number -= mon.heads() - 1;</a>
<a name="ln1930"> </a>
<a name="ln1931">    if (attk_number &lt; 0 || attk_number &gt;= MAX_NUM_ATTACKS)</a>
<a name="ln1932">        attk_number = 0;</a>
<a name="ln1933"> </a>
<a name="ln1934">    if (mons_is_ghost_demon(mc))</a>
<a name="ln1935">    {</a>
<a name="ln1936">        if (attk_number == 0 &amp;&amp; mon.ghost)</a>
<a name="ln1937">        {</a>
<a name="ln1938">            return { mon.ghost-&gt;att_type, mon.ghost-&gt;att_flav,</a>
<a name="ln1939">                     mon.ghost-&gt;damage };</a>
<a name="ln1940">        }</a>
<a name="ln1941"> </a>
<a name="ln1942">        return { AT_NONE, AF_PLAIN, 0 };</a>
<a name="ln1943">    }</a>
<a name="ln1944">    else if (mc == MONS_MUTANT_BEAST)</a>
<a name="ln1945">        return _mutant_beast_attack(mon, attk_number);</a>
<a name="ln1946">    else if (mons_is_hepliaklqana_ancestor(mc))</a>
<a name="ln1947">        return _hepliaklqana_ancestor_attack(mon, attk_number);</a>
<a name="ln1948">    else if (mons_is_demonspawn(mc) &amp;&amp; attk_number != 0)</a>
<a name="ln1949">        mc = draco_or_demonspawn_subspecies(mon);</a>
<a name="ln1950"> </a>
<a name="ln1951">    if (zombified &amp;&amp; mc != MONS_KRAKEN_TENTACLE)</a>
<a name="ln1952">        mc = mons_zombie_base(mon);</a>
<a name="ln1953"> </a>
<a name="ln1954">    ASSERT_smc();</a>
<a name="ln1955">    mon_attack_def attk = smc-&gt;attack[attk_number];</a>
<a name="ln1956"> </a>
<a name="ln1957">    if (mons_is_demonspawn(mon.type) &amp;&amp; attk_number == 0)</a>
<a name="ln1958">    {</a>
<a name="ln1959">        const monsterentry* mbase =</a>
<a name="ln1960">            get_monster_data (draco_or_demonspawn_subspecies(mon));</a>
<a name="ln1961">        ASSERT(mbase);</a>
<a name="ln1962">        attk.flavour = mbase-&gt;attack[0].flavour;</a>
<a name="ln1963">        return attk;</a>
<a name="ln1964">    }</a>
<a name="ln1965"> </a>
<a name="ln1966">    // Nonbase draconians inherit aux attacks from their base type.</a>
<a name="ln1967">    // Implicit assumption: base draconian types only get one aux</a>
<a name="ln1968">    // attack, and it's in their second attack slot.</a>
<a name="ln1969">    // If that changes this code will need to be changed.</a>
<a name="ln1970">    if (mons_species(mon.type) == MONS_DRACONIAN</a>
<a name="ln1971">        &amp;&amp; mon.type != MONS_DRACONIAN</a>
<a name="ln1972">        &amp;&amp; attk.type == AT_NONE</a>
<a name="ln1973">        &amp;&amp; attk_number &gt; 0</a>
<a name="ln1974">        &amp;&amp; smc-&gt;attack[attk_number - 1].type != AT_NONE)</a>
<a name="ln1975">    {</a>
<a name="ln1976">        const monsterentry* mbase =</a>
<a name="ln1977">            get_monster_data (draco_or_demonspawn_subspecies(mon));</a>
<a name="ln1978">        ASSERT(mbase);</a>
<a name="ln1979">        return mbase-&gt;attack[1];</a>
<a name="ln1980">    }</a>
<a name="ln1981"> </a>
<a name="ln1982">    if (mon.type == MONS_PLAYER_SHADOW &amp;&amp; attk_number == 0)</a>
<a name="ln1983">    {</a>
<a name="ln1984">        if (!you.weapon())</a>
<a name="ln1985">            attk.damage = max(1, you.skill_rdiv(SK_UNARMED_COMBAT, 10, 20));</a>
<a name="ln1986">    }</a>
<a name="ln1987"> </a>
<a name="ln1988">    // summoning miscast monster; hd scaled with miscast severity</a>
<a name="ln1989">    if (mon.type == MONS_NAMELESS &amp;&amp; attk_number == 0)</a>
<a name="ln1990">        attk.damage = mon.get_hit_dice() * 2;</a>
<a name="ln1991"> </a>
<a name="ln1992">    if (!base_flavour)</a>
<a name="ln1993">    {</a>
<a name="ln1994">        // TODO: randomization here is not the greatest way of doing any of</a>
<a name="ln1995">        // these...</a>
<a name="ln1996">        if (attk.type == AT_RANDOM)</a>
<a name="ln1997">            attk.type = random_choose(AT_HIT, AT_GORE);</a>
<a name="ln1998"> </a>
<a name="ln1999">        if (attk.type == AT_CHERUB)</a>
<a name="ln2000">            attk.type = random_choose(AT_HIT, AT_BITE, AT_PECK, AT_GORE);</a>
<a name="ln2001"> </a>
<a name="ln2002">        if (attk.flavour == AF_DRAIN_STAT)</a>
<a name="ln2003">            attk.flavour = random_choose(AF_DRAIN_STR, AF_DRAIN_INT,AF_DRAIN_DEX);</a>
<a name="ln2004">    }</a>
<a name="ln2005"> </a>
<a name="ln2006">    // Slime creature attacks are multiplied by the number merged.</a>
<a name="ln2007">    if (mon.type == MONS_SLIME_CREATURE &amp;&amp; mon.blob_size &gt; 1)</a>
<a name="ln2008">        attk.damage *= mon.blob_size;</a>
<a name="ln2009"> </a>
<a name="ln2010">    return zombified ? _downscale_zombie_attack(mon, attk, !base_flavour) : attk;</a>
<a name="ln2011">}</a>
<a name="ln2012"> </a>
<a name="ln2013">static int _mons_damage(monster_type mc, int rt)</a>
<a name="ln2014">{</a>
<a name="ln2015">    if (rt &lt; 0 || rt &gt; 3)</a>
<a name="ln2016">        rt = 0;</a>
<a name="ln2017">    ASSERT_smc();</a>
<a name="ln2018">    return smc-&gt;attack[rt].damage;</a>
<a name="ln2019">}</a>
<a name="ln2020"> </a>
<a name="ln2021">/**</a>
<a name="ln2022"> * A short description of the given monster attack type.</a>
<a name="ln2023"> *</a>
<a name="ln2024"> * @param attack      The attack to be described; e.g. AT_HIT, AT_SPORE.</a>
<a name="ln2025"> * @param with_object Is the description being used with an object/target?</a>
<a name="ln2026"> *                    True results in e.g. &quot;pounce on&quot;; false, just &quot;pounce&quot;.</a>
<a name="ln2027"> *                    Optional parameter, default true.</a>
<a name="ln2028"> * @return            A short description; e.g. &quot;hit&quot;, &quot;release spores at&quot;.</a>
<a name="ln2029"> */</a>
<a name="ln2030">string mon_attack_name(attack_type attack, bool with_object)</a>
<a name="ln2031">{</a>
<a name="ln2032">    static const char *attack_types[] =</a>
<a name="ln2033">    {</a>
<a name="ln2034">        &quot;hit&quot;,         // including weapon attacks</a>
<a name="ln2035">        &quot;bite&quot;,</a>
<a name="ln2036">        &quot;sting&quot;,</a>
<a name="ln2037"> </a>
<a name="ln2038">        // spore</a>
<a name="ln2039">        &quot;release spores at&quot;,</a>
<a name="ln2040"> </a>
<a name="ln2041">        &quot;touch&quot;,</a>
<a name="ln2042">        &quot;engulf&quot;,</a>
<a name="ln2043">        &quot;claw&quot;,</a>
<a name="ln2044">        &quot;peck&quot;,</a>
<a name="ln2045">        &quot;headbutt&quot;,</a>
<a name="ln2046">        &quot;punch&quot;,</a>
<a name="ln2047">        &quot;kick&quot;,</a>
<a name="ln2048">        &quot;tentacle-slap&quot;,</a>
<a name="ln2049">        &quot;tail-slap&quot;,</a>
<a name="ln2050">        &quot;gore&quot;,</a>
<a name="ln2051">        &quot;constrict&quot;,</a>
<a name="ln2052">        &quot;trample&quot;,</a>
<a name="ln2053">        &quot;trunk-slap&quot;,</a>
<a name="ln2054">#if TAG_MAJOR_VERSION == 34</a>
<a name="ln2055">        &quot;snap closed at&quot;,</a>
<a name="ln2056">        &quot;splash&quot;,</a>
<a name="ln2057">#endif</a>
<a name="ln2058">        &quot;pounce on&quot;,</a>
<a name="ln2059">#if TAG_MAJOR_VERSION == 34</a>
<a name="ln2060">        &quot;sting&quot;,</a>
<a name="ln2061">#endif</a>
<a name="ln2062">        &quot;hit, bite, peck, or gore&quot;, // AT_CHERUB</a>
<a name="ln2063">#if TAG_MAJOR_VERSION == 34</a>
<a name="ln2064">        &quot;hit&quot;, // AT_SHOOT</a>
<a name="ln2065">#endif</a>
<a name="ln2066">        &quot;hit&quot;, // AT_WEAP_ONLY,</a>
<a name="ln2067">        &quot;hit or gore&quot;, // AT_RANDOM</a>
<a name="ln2068">    };</a>
<a name="ln2069">    COMPILE_CHECK(ARRAYSZ(attack_types) == NUM_ATTACK_TYPES - AT_FIRST_ATTACK);</a>
<a name="ln2070"> </a>
<a name="ln2071">    const int verb_index = attack - AT_FIRST_ATTACK;</a>
<a name="ln2072">    dprf(&quot;verb index: %d&quot;, verb_index);</a>
<a name="ln2073">    ASSERT(verb_index &lt; (int)ARRAYSZ(attack_types));</a>
<a name="ln2074"> </a>
<a name="ln2075">    if (with_object)</a>
<a name="ln2076">        return attack_types[verb_index];</a>
<a name="ln2077">    else</a>
<a name="ln2078">    {</a>
<a name="ln2079">        return replace_all(replace_all(attack_types[verb_index], &quot; at&quot;, &quot;&quot;),</a>
<a name="ln2080">                                                                 &quot; on&quot;, &quot;&quot;);</a>
<a name="ln2081">    }</a>
<a name="ln2082">}</a>
<a name="ln2083"> </a>
<a name="ln2084">/**</a>
<a name="ln2085"> * Does this monster attack flavour trigger even if the base attack does no</a>
<a name="ln2086"> * damage?</a>
<a name="ln2087"> *</a>
<a name="ln2088"> * @param flavour   The attack flavour in question; e.g. AF_COLD.</a>
<a name="ln2089"> * @return          Whether the flavour attack triggers on a successful hit</a>
<a name="ln2090"> *                  regardless of damage done.</a>
<a name="ln2091"> */</a>
<a name="ln2092">bool flavour_triggers_damageless(attack_flavour flavour)</a>
<a name="ln2093">{</a>
<a name="ln2094">    return flavour == AF_CRUSH</a>
<a name="ln2095">        || flavour == AF_ENGULF</a>
<a name="ln2096">        || flavour == AF_PURE_FIRE</a>
<a name="ln2097">        || flavour == AF_SHADOWSTAB</a>
<a name="ln2098">        || flavour == AF_DROWN</a>
<a name="ln2099">        || flavour == AF_CORRODE</a>
<a name="ln2100">        || flavour == AF_HUNGER;</a>
<a name="ln2101">}</a>
<a name="ln2102"> </a>
<a name="ln2103">/**</a>
<a name="ln2104"> * How much special damage does the given attack flavour do for an attack from</a>
<a name="ln2105"> * a monster of the given hit dice?</a>
<a name="ln2106"> *</a>
<a name="ln2107"> * Various effects (e.g. acid) currently go through more complex codepaths. :(</a>
<a name="ln2108"> *</a>
<a name="ln2109"> * @param flavour       The attack flavour in question; e.g. AF_FIRE.</a>
<a name="ln2110"> * @param HD            The HD to calculate damage for.</a>
<a name="ln2111"> * @param random        Whether to roll damage, or (if false) just return</a>
<a name="ln2112"> *                      the top of the range.</a>
<a name="ln2113"> * @return              The damage that the given attack flavour does, before</a>
<a name="ln2114"> *                      resists and other effects are applied.</a>
<a name="ln2115"> */</a>
<a name="ln2116">int flavour_damage(attack_flavour flavour, int HD, bool random)</a>
<a name="ln2117">{</a>
<a name="ln2118">    switch (flavour)</a>
<a name="ln2119">    {</a>
<a name="ln2120">        case AF_FIRE:</a>
<a name="ln2121">            if (random)</a>
<a name="ln2122">                return HD + random2(HD);</a>
<a name="ln2123">            return HD * 2;</a>
<a name="ln2124">        case AF_COLD:</a>
<a name="ln2125">            if (random)</a>
<a name="ln2126">                return HD + random2(HD*2);</a>
<a name="ln2127">            return HD * 3;</a>
<a name="ln2128">        case AF_ELEC:</a>
<a name="ln2129">            if (random)</a>
<a name="ln2130">                return HD + random2(HD/2);</a>
<a name="ln2131">            return HD * 3 / 2;</a>
<a name="ln2132">        case AF_PURE_FIRE:</a>
<a name="ln2133">            if (random)</a>
<a name="ln2134">                return HD * 3 / 2 + random2(HD);</a>
<a name="ln2135">            return HD * 5 / 2;</a>
<a name="ln2136">        default:</a>
<a name="ln2137">            return 0;</a>
<a name="ln2138">    }</a>
<a name="ln2139">}</a>
<a name="ln2140"> </a>
<a name="ln2141">bool mons_immune_magic(const monster&amp; mon)</a>
<a name="ln2142">{</a>
<a name="ln2143">    return get_monster_data(mon.type)-&gt;resist_magic == MAG_IMMUNE;</a>
<a name="ln2144">}</a>
<a name="ln2145"> </a>
<a name="ln2146">bool mons_skeleton(monster_type mc)</a>
<a name="ln2147">{</a>
<a name="ln2148">    return !mons_class_flag(mc, M_NO_SKELETON);</a>
<a name="ln2149">}</a>
<a name="ln2150"> </a>
<a name="ln2151">bool mons_zombifiable(monster_type mc)</a>
<a name="ln2152">{</a>
<a name="ln2153">    return !mons_class_flag(mc, M_NO_ZOMBIE) &amp;&amp; mons_zombie_size(mc);</a>
<a name="ln2154">}</a>
<a name="ln2155"> </a>
<a name="ln2156">bool mons_flattens_trees(const monster&amp; mon)</a>
<a name="ln2157">{</a>
<a name="ln2158">    return mons_base_type(mon) == MONS_LERNAEAN_HYDRA;</a>
<a name="ln2159">}</a>
<a name="ln2160"> </a>
<a name="ln2161">bool mons_class_res_tornado(monster_type mc)</a>
<a name="ln2162">{</a>
<a name="ln2163">    return get_resist(get_mons_class_resists(mc), MR_RES_TORNADO);</a>
<a name="ln2164">}</a>
<a name="ln2165"> </a>
<a name="ln2166">/**</a>
<a name="ln2167"> * Given an average max HP value for a given monster type, what should a given</a>
<a name="ln2168"> * monster have?</a>
<a name="ln2169"> *</a>
<a name="ln2170"> * @param avg_hp    The mean hp.</a>
<a name="ln2171"> * @param scale     A scale that the input avg_hp are multiplied by.</a>
<a name="ln2172"> * @return          A max HP value; no more than +-33% from the given average,</a>
<a name="ln2173"> *                  and within about +-10% of the average 95% of the time.</a>
<a name="ln2174"> *                  This value is not multiplied by the scale - it's an actual</a>
<a name="ln2175"> *                  hp value, regardless of the scale on the input.</a>
<a name="ln2176"> *                  If avg_hp is nonzero, always returns at least 1.</a>
<a name="ln2177"> */</a>
<a name="ln2178">int hit_points(int avg_hp, int scale)</a>
<a name="ln2179">{</a>
<a name="ln2180">    if (!avg_hp)</a>
<a name="ln2181">        return 0;</a>
<a name="ln2182"> </a>
<a name="ln2183">    const int min_perc = 33;</a>
<a name="ln2184">    const int hp_variance = div_rand_round(avg_hp * min_perc, 100);</a>
<a name="ln2185">    const int min_hp = avg_hp - hp_variance;</a>
<a name="ln2186">    const int hp = min_hp + random2avg(hp_variance * 2, 8);</a>
<a name="ln2187">    return max(1, div_rand_round(hp, scale));</a>
<a name="ln2188">}</a>
<a name="ln2189"> </a>
<a name="ln2190">// This function returns the standard number of hit dice for a type of</a>
<a name="ln2191">// monster, not a particular monster's current hit dice. - bwr</a>
<a name="ln2192">int mons_class_hit_dice(monster_type mc)</a>
<a name="ln2193">{</a>
<a name="ln2194">    const monsterentry *me = get_monster_data(mc);</a>
<a name="ln2195">    return me ? me-&gt;HD : 0;</a>
<a name="ln2196">}</a>
<a name="ln2197"> </a>
<a name="ln2198">/**</a>
<a name="ln2199"> * What base MR does a monster of the given type have?</a>
<a name="ln2200"> *</a>
<a name="ln2201"> * @param type    The monster type in question.</a>
<a name="ln2202"> * @param base    The base type of the monster. (For e.g. draconians.)</a>
<a name="ln2203"> * @return        The MR of a normal monster of that type.</a>
<a name="ln2204"> */</a>
<a name="ln2205">int mons_class_res_magic(monster_type type, monster_type base)</a>
<a name="ln2206">{</a>
<a name="ln2207">    const monster_type base_type =</a>
<a name="ln2208">        base != MONS_NO_MONSTER &amp;&amp;</a>
<a name="ln2209">        (mons_is_draconian(type) || mons_is_demonspawn(type))</a>
<a name="ln2210">            ? draco_or_demonspawn_subspecies(type, base)</a>
<a name="ln2211">            : type;</a>
<a name="ln2212"> </a>
<a name="ln2213">    const int type_mr = (get_monster_data(base_type))-&gt;resist_magic;</a>
<a name="ln2214"> </a>
<a name="ln2215">    // Negative values get multiplied with monster hit dice.</a>
<a name="ln2216">    if (type_mr &gt;= 0)</a>
<a name="ln2217">        return type_mr;</a>
<a name="ln2218">    return mons_class_hit_dice(base_type) * -type_mr * 4 / 3;</a>
<a name="ln2219">}</a>
<a name="ln2220"> </a>
<a name="ln2221">/**</a>
<a name="ln2222"> * Can a monster of the given type see invisible creatures?</a>
<a name="ln2223"> *</a>
<a name="ln2224"> * @param type    The monster type in question.</a>
<a name="ln2225"> * @param base    The base type of the monster. (For e.g. draconians.)</a>
<a name="ln2226"> * @return        Whether a normal monster of that type can see invisible</a>
<a name="ln2227"> *                things.</a>
<a name="ln2228"> */</a>
<a name="ln2229">bool mons_class_sees_invis(monster_type type, monster_type base)</a>
<a name="ln2230">{</a>
<a name="ln2231">    if (mons_class_flag(type, M_SEE_INVIS))</a>
<a name="ln2232">        return true;</a>
<a name="ln2233"> </a>
<a name="ln2234">    if (base != MONS_NO_MONSTER &amp;&amp; mons_is_demonspawn(type) // XXX: add dracs here? latent bug otherwise</a>
<a name="ln2235">        &amp;&amp; mons_class_flag(draco_or_demonspawn_subspecies(type, base),</a>
<a name="ln2236">                           M_SEE_INVIS))</a>
<a name="ln2237">    {</a>
<a name="ln2238">        return true;</a>
<a name="ln2239">    }</a>
<a name="ln2240"> </a>
<a name="ln2241">    return false;</a>
<a name="ln2242">}</a>
<a name="ln2243"> </a>
<a name="ln2244">/**</a>
<a name="ln2245"> * What's the average hp for a given type of monster?</a>
<a name="ln2246"> *</a>
<a name="ln2247"> * @param mc        The type of monster in question.</a>
<a name="ln2248"> * @return          The average hp for that monster; rounds down.</a>
<a name="ln2249"> */</a>
<a name="ln2250">int mons_avg_hp(monster_type mc)</a>
<a name="ln2251">{</a>
<a name="ln2252">    const monsterentry* me = get_monster_data(mc);</a>
<a name="ln2253"> </a>
<a name="ln2254">    if (!me)</a>
<a name="ln2255">        return 0;</a>
<a name="ln2256"> </a>
<a name="ln2257">    // Hack for nonbase demonspawn: pretend it's a basic demonspawn with</a>
<a name="ln2258">    // a job.</a>
<a name="ln2259">    if (mons_is_demonspawn(mc)</a>
<a name="ln2260">        &amp;&amp; mc != MONS_DEMONSPAWN</a>
<a name="ln2261">        &amp;&amp; mons_species(mc) == MONS_DEMONSPAWN)</a>
<a name="ln2262">    {</a>
<a name="ln2263">        const monsterentry* mbase = get_monster_data(MONS_DEMONSPAWN);</a>
<a name="ln2264">        return (mbase-&gt;avg_hp_10x + me-&gt;avg_hp_10x) / 10;</a>
<a name="ln2265">    }</a>
<a name="ln2266"> </a>
<a name="ln2267">    return me-&gt;avg_hp_10x / 10;</a>
<a name="ln2268">}</a>
<a name="ln2269"> </a>
<a name="ln2270">/**</a>
<a name="ln2271"> * What's the maximum hp for a given type of monster?</a>
<a name="ln2272"> *</a>
<a name="ln2273"> * @param mc        The type of monster in question.</a>
<a name="ln2274"> * @param mbase     The type of the base monster, if applicable (for classed</a>
<a name="ln2275"> *                  monsters).</a>
<a name="ln2276"> * @return          The maximum hp for that monster; rounds down.</a>
<a name="ln2277"> */</a>
<a name="ln2278">int mons_max_hp(monster_type mc, monster_type mbase_type)</a>
<a name="ln2279">{</a>
<a name="ln2280">    const monsterentry* me = get_monster_data(mc);</a>
<a name="ln2281"> </a>
<a name="ln2282">    if (!me)</a>
<a name="ln2283">        return 0;</a>
<a name="ln2284"> </a>
<a name="ln2285">    // TODO: merge the 133% with their use in hit_points()</a>
<a name="ln2286"> </a>
<a name="ln2287">    // Hack for nonbase demonspawn: pretend it's a basic demonspawn with</a>
<a name="ln2288">    // a job.</a>
<a name="ln2289">    if (mons_is_demonspawn(mc)</a>
<a name="ln2290">        &amp;&amp; mc != MONS_DEMONSPAWN</a>
<a name="ln2291">        &amp;&amp; mons_species(mc) == MONS_DEMONSPAWN)</a>
<a name="ln2292">    {</a>
<a name="ln2293">        const monsterentry* mbase =</a>
<a name="ln2294">            get_monster_data(mbase_type != MONS_NO_MONSTER ? mbase_type</a>
<a name="ln2295">                                                           : MONS_DEMONSPAWN);</a>
<a name="ln2296">        return (mbase-&gt;avg_hp_10x + me-&gt;avg_hp_10x) * 133 / 1000;</a>
<a name="ln2297">    }</a>
<a name="ln2298"> </a>
<a name="ln2299">    return me-&gt;avg_hp_10x * 133 / 1000;</a>
<a name="ln2300">}</a>
<a name="ln2301"> </a>
<a name="ln2302">int exper_value(const monster&amp; mon, bool real)</a>
<a name="ln2303">{</a>
<a name="ln2304">    int x_val = 0;</a>
<a name="ln2305"> </a>
<a name="ln2306">    // These four are the original arguments.</a>
<a name="ln2307">    const monster_type mc = mon.type;</a>
<a name="ln2308">    int hd                = mon.get_experience_level();</a>
<a name="ln2309">    int maxhp             = mon.max_hit_points;</a>
<a name="ln2310"> </a>
<a name="ln2311">    // pghosts and pillusions have no reasonable base values, and you can look</a>
<a name="ln2312">    // up the exact value anyway. Especially for pillusions.</a>
<a name="ln2313">    if (real || mon.type == MONS_PLAYER_GHOST || mon.type == MONS_PLAYER_ILLUSION)</a>
<a name="ln2314">    {</a>
<a name="ln2315">        // A berserking monster is much harder, but the xp value shouldn't</a>
<a name="ln2316">        // depend on whether it was berserk at the moment of death.</a>
<a name="ln2317">        if (mon.has_ench(ENCH_BERSERK))</a>
<a name="ln2318">            maxhp = (maxhp * 2 + 1) / 3;</a>
<a name="ln2319">    }</a>
<a name="ln2320">    else</a>
<a name="ln2321">    {</a>
<a name="ln2322">        const monsterentry *m = get_monster_data(mons_base_type(mon));</a>
<a name="ln2323">        ASSERT(m);</a>
<a name="ln2324"> </a>
<a name="ln2325">        // Use real hd, zombies would use the basic species and lose</a>
<a name="ln2326">        // information known to the player (&quot;orc warrior zombie&quot;). Monsters</a>
<a name="ln2327">        // levelling up is visible (although it may happen off-screen), so</a>
<a name="ln2328">        // this is hardly ever a leak. Only Pan lords are unknown in the</a>
<a name="ln2329">        // general.</a>
<a name="ln2330">        if (m-&gt;mc == MONS_PANDEMONIUM_LORD)</a>
<a name="ln2331">            hd = m-&gt;HD;</a>
<a name="ln2332">        maxhp = mons_max_hp(mc);</a>
<a name="ln2333">    }</a>
<a name="ln2334"> </a>
<a name="ln2335">    // Hacks to make merged slime creatures not worth so much exp. We</a>
<a name="ln2336">    // will calculate the experience we would get for 1 blob, and then</a>
<a name="ln2337">    // just multiply it so that exp is linear with blobs merged. -cao</a>
<a name="ln2338">    if (mon.type == MONS_SLIME_CREATURE &amp;&amp; mon.blob_size &gt; 1)</a>
<a name="ln2339">        maxhp /= mon.blob_size;</a>
<a name="ln2340"> </a>
<a name="ln2341">    // These are some values we care about.</a>
<a name="ln2342">    const int speed       = mons_base_speed(mon);</a>
<a name="ln2343">    const int modifier    = _mons_exp_mod(mc);</a>
<a name="ln2344">    const int item_usage  = mons_itemuse(mon);</a>
<a name="ln2345"> </a>
<a name="ln2346">    // XXX: Shapeshifters can qualify here, even though they can't cast.</a>
<a name="ln2347">    const bool spellcaster = mon.has_spells();</a>
<a name="ln2348"> </a>
<a name="ln2349">    // Early out for no XP monsters.</a>
<a name="ln2350">    if (!mons_class_gives_xp(mc))</a>
<a name="ln2351">        return 0;</a>
<a name="ln2352"> </a>
<a name="ln2353">    x_val = (16 + maxhp) * hd * hd / 10;</a>
<a name="ln2354"> </a>
<a name="ln2355">    // Let's calculate a simple difficulty modifier. - bwr</a>
<a name="ln2356">    int diff = 0;</a>
<a name="ln2357"> </a>
<a name="ln2358">    // Let's look for big spells.</a>
<a name="ln2359">    if (spellcaster)</a>
<a name="ln2360">    {</a>
<a name="ln2361">        for (const mon_spell_slot &amp;slot : mon.spells)</a>
<a name="ln2362">        {</a>
<a name="ln2363">            switch (slot.spell)</a>
<a name="ln2364">            {</a>
<a name="ln2365">            case SPELL_PARALYSE:</a>
<a name="ln2366">            case SPELL_SMITING:</a>
<a name="ln2367">            case SPELL_SUMMON_EYEBALLS:</a>
<a name="ln2368">            case SPELL_CALL_DOWN_DAMNATION:</a>
<a name="ln2369">            case SPELL_HURL_DAMNATION:</a>
<a name="ln2370">            case SPELL_SYMBOL_OF_TORMENT:</a>
<a name="ln2371">            case SPELL_GLACIATE:</a>
<a name="ln2372">            case SPELL_FIRE_STORM:</a>
<a name="ln2373">            case SPELL_SHATTER:</a>
<a name="ln2374">            case SPELL_CHAIN_LIGHTNING:</a>
<a name="ln2375">            case SPELL_TORNADO:</a>
<a name="ln2376">            case SPELL_LEGENDARY_DESTRUCTION:</a>
<a name="ln2377">            case SPELL_SUMMON_ILLUSION:</a>
<a name="ln2378">            case SPELL_SPELLFORGED_SERVITOR:</a>
<a name="ln2379">                diff += 25;</a>
<a name="ln2380">                break;</a>
<a name="ln2381"> </a>
<a name="ln2382">            case SPELL_SUMMON_GREATER_DEMON:</a>
<a name="ln2383">            case SPELL_HASTE:</a>
<a name="ln2384">            case SPELL_BLINK_RANGE:</a>
<a name="ln2385">            case SPELL_PETRIFY:</a>
<a name="ln2386">                diff += 20;</a>
<a name="ln2387">                break;</a>
<a name="ln2388"> </a>
<a name="ln2389">            case SPELL_LIGHTNING_BOLT:</a>
<a name="ln2390">            case SPELL_STICKY_FLAME_RANGE:</a>
<a name="ln2391">            case SPELL_DISINTEGRATE:</a>
<a name="ln2392">            case SPELL_BANISHMENT:</a>
<a name="ln2393">            case SPELL_LEHUDIBS_CRYSTAL_SPEAR:</a>
<a name="ln2394">            case SPELL_IRON_SHOT:</a>
<a name="ln2395">            case SPELL_IOOD:</a>
<a name="ln2396">            case SPELL_FIREBALL:</a>
<a name="ln2397">            case SPELL_AGONY_RANGE:</a>
<a name="ln2398">            case SPELL_LRD:</a>
<a name="ln2399">            case SPELL_DIG:</a>
<a name="ln2400">            case SPELL_FAKE_MARA_SUMMON:</a>
<a name="ln2401">                diff += 10;</a>
<a name="ln2402">                break;</a>
<a name="ln2403"> </a>
<a name="ln2404">            case SPELL_HAUNT:</a>
<a name="ln2405">            case SPELL_SUMMON_DRAGON:</a>
<a name="ln2406">            case SPELL_SUMMON_HORRIBLE_THINGS:</a>
<a name="ln2407">            case SPELL_PLANEREND:</a>
<a name="ln2408">            case SPELL_SUMMON_EMPEROR_SCORPIONS:</a>
<a name="ln2409">                diff += 7;</a>
<a name="ln2410">                break;</a>
<a name="ln2411"> </a>
<a name="ln2412">            default:</a>
<a name="ln2413">                break;</a>
<a name="ln2414">            }</a>
<a name="ln2415">        }</a>
<a name="ln2416">    }</a>
<a name="ln2417"> </a>
<a name="ln2418">    // Let's look at regeneration.</a>
<a name="ln2419">    if (mons_class_fast_regen(mc))</a>
<a name="ln2420">        diff += 15;</a>
<a name="ln2421"> </a>
<a name="ln2422">    // Monsters at normal or fast speed with big melee damage.</a>
<a name="ln2423">    if (speed &gt;= 10)</a>
<a name="ln2424">    {</a>
<a name="ln2425">        int max_melee = 0;</a>
<a name="ln2426">        for (int i = 0; i &lt; 4; ++i)</a>
<a name="ln2427">            max_melee += _mons_damage(mc, i);</a>
<a name="ln2428"> </a>
<a name="ln2429">        if (max_melee &gt; 30)</a>
<a name="ln2430">            diff += (max_melee / ((speed == 10) ? 2 : 1));</a>
<a name="ln2431">    }</a>
<a name="ln2432"> </a>
<a name="ln2433">    // Monsters who can use equipment (even if only the equipment</a>
<a name="ln2434">    // they are given) can be considerably enhanced because of</a>
<a name="ln2435">    // the way weapons work for monsters. - bwr</a>
<a name="ln2436">    if (item_usage &gt;= MONUSE_STARTING_EQUIPMENT)</a>
<a name="ln2437">        diff += 30;</a>
<a name="ln2438"> </a>
<a name="ln2439">    // Set a reasonable range on the difficulty modifier...</a>
<a name="ln2440">    // Currently 70% - 200%. - bwr</a>
<a name="ln2441">    if (diff &gt; 100)</a>
<a name="ln2442">        diff = 100;</a>
<a name="ln2443">    else if (diff &lt; -30)</a>
<a name="ln2444">        diff = -30;</a>
<a name="ln2445"> </a>
<a name="ln2446">    // Apply difficulty.</a>
<a name="ln2447">    x_val *= (100 + diff);</a>
<a name="ln2448">    x_val /= 100;</a>
<a name="ln2449"> </a>
<a name="ln2450">    // Basic speed modification.</a>
<a name="ln2451">    if (speed &gt; 0)</a>
<a name="ln2452">    {</a>
<a name="ln2453">        x_val *= speed;</a>
<a name="ln2454">        x_val /= 10;</a>
<a name="ln2455">    }</a>
<a name="ln2456"> </a>
<a name="ln2457">    // Slow monsters without spells and items often have big HD which</a>
<a name="ln2458">    // cause the experience value to be overly large... this tries</a>
<a name="ln2459">    // to reduce the inappropriate amount of XP that results. - bwr</a>
<a name="ln2460">    if (speed &lt; 10 &amp;&amp; !spellcaster &amp;&amp; item_usage &lt; MONUSE_STARTING_EQUIPMENT)</a>
<a name="ln2461">        x_val /= 2;</a>
<a name="ln2462"> </a>
<a name="ln2463">    // Apply the modifier in the monster's definition.</a>
<a name="ln2464">    if (modifier &gt; 0)</a>
<a name="ln2465">    {</a>
<a name="ln2466">        x_val *= modifier;</a>
<a name="ln2467">        x_val /= 10;</a>
<a name="ln2468">    }</a>
<a name="ln2469"> </a>
<a name="ln2470">    // Scale starcursed mass exp by what percentage of the whole it represents</a>
<a name="ln2471">    if (mon.type == MONS_STARCURSED_MASS)</a>
<a name="ln2472">        x_val = (x_val * mon.blob_size) / 12;</a>
<a name="ln2473"> </a>
<a name="ln2474">    // Further reduce xp from zombies</a>
<a name="ln2475">    if (mons_is_zombified(mon))</a>
<a name="ln2476">        x_val /= 2;</a>
<a name="ln2477"> </a>
<a name="ln2478">    // Reductions for big values. - bwr</a>
<a name="ln2479">    if (x_val &gt; 100)</a>
<a name="ln2480">        x_val = 100 + ((x_val - 100) * 3) / 4;</a>
<a name="ln2481">    if (x_val &gt; 750)</a>
<a name="ln2482">        x_val = 750 + (x_val - 750) / 3;</a>
<a name="ln2483"> </a>
<a name="ln2484">    // Slime creature exp hack part 2: Scale exp back up by the number</a>
<a name="ln2485">    // of blobs merged. -cao</a>
<a name="ln2486">    // Has to be after the stepdown to prevent issues with 4-5 merged slime</a>
<a name="ln2487">    // creatures. -pf</a>
<a name="ln2488">    if (mon.type == MONS_SLIME_CREATURE &amp;&amp; mon.blob_size &gt; 1)</a>
<a name="ln2489">        x_val *= mon.blob_size;</a>
<a name="ln2490"> </a>
<a name="ln2491">    // Guarantee the value is within limits.</a>
<a name="ln2492">    if (x_val &lt;= 0)</a>
<a name="ln2493">        x_val = 1;</a>
<a name="ln2494"> </a>
<a name="ln2495">    return x_val;</a>
<a name="ln2496">}</a>
<a name="ln2497"> </a>
<a name="ln2498">static monster_type _random_mons_between(monster_type min, monster_type max)</a>
<a name="ln2499">{</a>
<a name="ln2500">    monster_type mc = MONS_PROGRAM_BUG;</a>
<a name="ln2501"> </a>
<a name="ln2502">    do // skip removed monsters</a>
<a name="ln2503">    {</a>
<a name="ln2504">        mc = static_cast&lt;monster_type&gt;(random_range(min, max));</a>
<a name="ln2505">    }</a>
<a name="ln2506">    while (mons_is_removed(mc));</a>
<a name="ln2507"> </a>
<a name="ln2508">    return mc;</a>
<a name="ln2509">}</a>
<a name="ln2510"> </a>
<a name="ln2511">monster_type random_draconian_monster_species()</a>
<a name="ln2512">{</a>
<a name="ln2513">    return _random_mons_between(MONS_FIRST_BASE_DRACONIAN,</a>
<a name="ln2514">                                MONS_LAST_SPAWNED_DRACONIAN);</a>
<a name="ln2515">}</a>
<a name="ln2516"> </a>
<a name="ln2517">monster_type random_draconian_job()</a>
<a name="ln2518">{</a>
<a name="ln2519">    return _random_mons_between(MONS_FIRST_NONBASE_DRACONIAN,</a>
<a name="ln2520">                                MONS_LAST_NONBASE_DRACONIAN);</a>
<a name="ln2521">}</a>
<a name="ln2522"> </a>
<a name="ln2523">monster_type random_demonspawn_monster_species()</a>
<a name="ln2524">{</a>
<a name="ln2525">    return _random_mons_between(MONS_FIRST_BASE_DEMONSPAWN,</a>
<a name="ln2526">                                MONS_LAST_BASE_DEMONSPAWN);</a>
<a name="ln2527">}</a>
<a name="ln2528"> </a>
<a name="ln2529">monster_type random_demonspawn_job()</a>
<a name="ln2530">{</a>
<a name="ln2531">    return _random_mons_between(MONS_FIRST_NONBASE_DEMONSPAWN,</a>
<a name="ln2532">                                MONS_LAST_NONBASE_DEMONSPAWN);</a>
<a name="ln2533">}</a>
<a name="ln2534"> </a>
<a name="ln2535">// Note: For consistent behaviour in player_will_anger_monster(), all</a>
<a name="ln2536">// spellbooks a given monster can get here should produce the same</a>
<a name="ln2537">// return values in the following:</a>
<a name="ln2538">//</a>
<a name="ln2539">//     is_evil_spell()</a>
<a name="ln2540">//</a>
<a name="ln2541">//     (is_unclean_spell() || is_chaotic_spell())</a>
<a name="ln2542">//</a>
<a name="ln2543">// FIXME: This is not true for one set of spellbooks; MST_WIZARD_IV</a>
<a name="ln2544">// contains the unholy and chaotic Banishment spell, but the other</a>
<a name="ln2545">// MST_WIZARD-type spellbooks contain no unholy, evil, unclean or</a>
<a name="ln2546">// chaotic spells.</a>
<a name="ln2547">//</a>
<a name="ln2548">// If a monster has only one spellbook, it is specified in mon-data.h.</a>
<a name="ln2549">// If it has multiple books, mon-data.h sets the book to MST_NO_SPELLS,</a>
<a name="ln2550">// and the books are accounted for here.</a>
<a name="ln2551">static vector&lt;mon_spellbook_type&gt; _mons_spellbook_list(monster_type mon_type)</a>
<a name="ln2552">{</a>
<a name="ln2553">    switch (mon_type)</a>
<a name="ln2554">    {</a>
<a name="ln2555">    case MONS_HELL_KNIGHT:</a>
<a name="ln2556">        return { MST_HELL_KNIGHT_I, MST_HELL_KNIGHT_II };</a>
<a name="ln2557"> </a>
<a name="ln2558">    case MONS_NECROMANCER:</a>
<a name="ln2559">        return { MST_NECROMANCER_I, MST_NECROMANCER_II };</a>
<a name="ln2560"> </a>
<a name="ln2561">    case MONS_ORC_WIZARD:</a>
<a name="ln2562">        return { MST_ORC_WIZARD_I, MST_ORC_WIZARD_II, MST_ORC_WIZARD_III };</a>
<a name="ln2563"> </a>
<a name="ln2564">    case MONS_WIZARD:</a>
<a name="ln2565">    case MONS_EROLCHA:</a>
<a name="ln2566">        return { MST_WIZARD_I, MST_WIZARD_II, MST_WIZARD_III };</a>
<a name="ln2567"> </a>
<a name="ln2568">    case MONS_OGRE_MAGE:</a>
<a name="ln2569">        return { MST_OGRE_MAGE_I, MST_OGRE_MAGE_II, MST_OGRE_MAGE_III };</a>
<a name="ln2570"> </a>
<a name="ln2571">    case MONS_ANCIENT_CHAMPION:</a>
<a name="ln2572">        return { MST_ANCIENT_CHAMPION_I, MST_ANCIENT_CHAMPION_II };</a>
<a name="ln2573"> </a>
<a name="ln2574">    case MONS_TENGU_CONJURER:</a>
<a name="ln2575">        return { MST_TENGU_CONJURER_I, MST_TENGU_CONJURER_II,</a>
<a name="ln2576">                 MST_TENGU_CONJURER_III, MST_TENGU_CONJURER_IV };</a>
<a name="ln2577"> </a>
<a name="ln2578">    case MONS_TENGU_REAVER:</a>
<a name="ln2579">        return { MST_TENGU_REAVER_I, MST_TENGU_REAVER_II,</a>
<a name="ln2580">                 MST_TENGU_REAVER_III };</a>
<a name="ln2581"> </a>
<a name="ln2582">    case MONS_DEEP_ELF_MAGE:</a>
<a name="ln2583">        return { MST_DEEP_ELF_MAGE_I, MST_DEEP_ELF_MAGE_II,</a>
<a name="ln2584">                 MST_DEEP_ELF_MAGE_III, MST_DEEP_ELF_MAGE_IV,</a>
<a name="ln2585">                 MST_DEEP_ELF_MAGE_V, MST_DEEP_ELF_MAGE_VI };</a>
<a name="ln2586"> </a>
<a name="ln2587">    case MONS_FAUN:</a>
<a name="ln2588">        return { MST_FAUN_I, MST_FAUN_II };</a>
<a name="ln2589"> </a>
<a name="ln2590">    case MONS_GREATER_MUMMY:</a>
<a name="ln2591">        return { MST_GREATER_MUMMY_I, MST_GREATER_MUMMY_II,</a>
<a name="ln2592">                 MST_GREATER_MUMMY_III, MST_GREATER_MUMMY_IV };</a>
<a name="ln2593"> </a>
<a name="ln2594">    case MONS_DEEP_ELF_KNIGHT:</a>
<a name="ln2595">        return { MST_DEEP_ELF_KNIGHT_I, MST_DEEP_ELF_KNIGHT_II };</a>
<a name="ln2596"> </a>
<a name="ln2597">    case MONS_LICH:</a>
<a name="ln2598">    case MONS_ANCIENT_LICH:</a>
<a name="ln2599">        return { MST_LICH_I, MST_LICH_II, MST_LICH_III,</a>
<a name="ln2600">                 MST_LICH_IV, MST_LICH_V, };</a>
<a name="ln2601"> </a>
<a name="ln2602">    default:</a>
<a name="ln2603">        return { static_cast&lt;mon_spellbook_type&gt;(</a>
<a name="ln2604">                     get_monster_data(mon_type)-&gt;sec) };</a>
<a name="ln2605">    }</a>
<a name="ln2606">}</a>
<a name="ln2607"> </a>
<a name="ln2608">vector&lt;mon_spellbook_type&gt; get_spellbooks(const monster_info &amp;mon)</a>
<a name="ln2609">{</a>
<a name="ln2610">    // special case for vault monsters: if they have a custom book,</a>
<a name="ln2611">    // treat it as MST_GHOST</a>
<a name="ln2612">    if (mon.props.exists(CUSTOM_SPELLS_KEY))</a>
<a name="ln2613">        return { MST_GHOST };</a>
<a name="ln2614">    else</a>
<a name="ln2615">        return _mons_spellbook_list(mon.type);</a>
<a name="ln2616">}</a>
<a name="ln2617"> </a>
<a name="ln2618">// Get a list of unique spells from a monster's preset spellbooks</a>
<a name="ln2619">// or in the case of ghosts their actual spells.</a>
<a name="ln2620">// If flags is non-zero, it returns only spells that match those flags.</a>
<a name="ln2621">unique_books get_unique_spells(const monster_info &amp;mi,</a>
<a name="ln2622">                               mon_spell_slot_flags flags)</a>
<a name="ln2623">{</a>
<a name="ln2624">    // No entry for MST_GHOST</a>
<a name="ln2625">    COMPILE_CHECK(ARRAYSZ(mspell_list) == NUM_MSTYPES - 1);</a>
<a name="ln2626"> </a>
<a name="ln2627">    const vector&lt;mon_spellbook_type&gt; books = get_spellbooks(mi);</a>
<a name="ln2628">    const size_t num_books = books.size();</a>
<a name="ln2629"> </a>
<a name="ln2630">    unique_books result;</a>
<a name="ln2631">    for (size_t i = 0; i &lt; num_books; ++i)</a>
<a name="ln2632">    {</a>
<a name="ln2633">        const mon_spellbook_type book = books[i];</a>
<a name="ln2634">        // TODO: should we build an index to speed this reverse lookup?</a>
<a name="ln2635">        unsigned int msidx;</a>
<a name="ln2636">        for (msidx = 0; msidx &lt; ARRAYSZ(mspell_list); ++msidx)</a>
<a name="ln2637">            if (mspell_list[msidx].type == book)</a>
<a name="ln2638">                break;</a>
<a name="ln2639"> </a>
<a name="ln2640">        vector&lt;mon_spell_slot&gt; slots;</a>
<a name="ln2641"> </a>
<a name="ln2642">        // Only prepend the first time; might be misleading if a draconian</a>
<a name="ln2643">        // ever gets multiple sets of natural abilities.</a>
<a name="ln2644">        if (mons_genus(mi.type) == MONS_DRACONIAN &amp;&amp; i == 0)</a>
<a name="ln2645">        {</a>
<a name="ln2646">            const mon_spell_slot breath =</a>
<a name="ln2647">                drac_breath(mi.draco_or_demonspawn_subspecies());</a>
<a name="ln2648">            if (breath.flags &amp; flags &amp;&amp; breath.spell != SPELL_NO_SPELL)</a>
<a name="ln2649">                slots.push_back(breath);</a>
<a name="ln2650">            // No other spells; quit right away.</a>
<a name="ln2651">            if (book == MST_NO_SPELLS)</a>
<a name="ln2652">            {</a>
<a name="ln2653">                if (slots.size())</a>
<a name="ln2654">                    result.push_back(slots);</a>
<a name="ln2655">                return result;</a>
<a name="ln2656">            }</a>
<a name="ln2657">        }</a>
<a name="ln2658"> </a>
<a name="ln2659">        if (book != MST_GHOST)</a>
<a name="ln2660">            ASSERT(msidx &lt; ARRAYSZ(mspell_list));</a>
<a name="ln2661">        for (const mon_spell_slot &amp;slot : (book == MST_GHOST</a>
<a name="ln2662">                                           ? mi.spells</a>
<a name="ln2663">                                           : mspell_list[msidx].spells))</a>
<a name="ln2664">        {</a>
<a name="ln2665">            if (flags != MON_SPELL_NO_FLAGS &amp;&amp; !(slot.flags &amp; flags))</a>
<a name="ln2666">                continue;</a>
<a name="ln2667"> </a>
<a name="ln2668">            if (none_of(slots.begin(), slots.end(),</a>
<a name="ln2669">                [&amp;](const mon_spell_slot&amp; oldslot)</a>
<a name="ln2670">                {</a>
<a name="ln2671">                    return oldslot.spell == slot.spell;</a>
<a name="ln2672">                }))</a>
<a name="ln2673">            {</a>
<a name="ln2674">                slots.push_back(slot);</a>
<a name="ln2675">            }</a>
<a name="ln2676">        }</a>
<a name="ln2677"> </a>
<a name="ln2678">        if (slots.size() == 0)</a>
<a name="ln2679">            continue;</a>
<a name="ln2680"> </a>
<a name="ln2681">        result.push_back(slots);</a>
<a name="ln2682">    }</a>
<a name="ln2683"> </a>
<a name="ln2684">    return result;</a>
<a name="ln2685">}</a>
<a name="ln2686"> </a>
<a name="ln2687">mon_spell_slot drac_breath(monster_type drac_type)</a>
<a name="ln2688">{</a>
<a name="ln2689">    spell_type sp;</a>
<a name="ln2690">    switch (drac_type)</a>
<a name="ln2691">    {</a>
<a name="ln2692">    case MONS_BLACK_DRACONIAN:   sp = SPELL_LIGHTNING_BOLT; break;</a>
<a name="ln2693">    case MONS_YELLOW_DRACONIAN:  sp = SPELL_ACID_SPLASH; break;</a>
<a name="ln2694">    case MONS_GREEN_DRACONIAN:   sp = SPELL_POISONOUS_CLOUD; break;</a>
<a name="ln2695">    case MONS_PURPLE_DRACONIAN:  sp = SPELL_QUICKSILVER_BOLT; break;</a>
<a name="ln2696">    case MONS_RED_DRACONIAN:     sp = SPELL_SEARING_BREATH; break;</a>
<a name="ln2697">    case MONS_WHITE_DRACONIAN:   sp = SPELL_CHILLING_BREATH; break;</a>
<a name="ln2698">    case MONS_DRACONIAN:</a>
<a name="ln2699">    case MONS_GREY_DRACONIAN:    sp = SPELL_NO_SPELL; break;</a>
<a name="ln2700">    case MONS_PALE_DRACONIAN:    sp = SPELL_STEAM_BALL; break;</a>
<a name="ln2701"> </a>
<a name="ln2702">    default:</a>
<a name="ln2703">        die(&quot;Invalid draconian subrace: %d&quot;, drac_type);</a>
<a name="ln2704">    }</a>
<a name="ln2705"> </a>
<a name="ln2706">    mon_spell_slot slot;</a>
<a name="ln2707">    slot.spell = sp;</a>
<a name="ln2708">    slot.freq = 62;</a>
<a name="ln2709">    slot.flags = MON_SPELL_NATURAL | MON_SPELL_BREATH;</a>
<a name="ln2710">    return slot;</a>
<a name="ln2711">}</a>
<a name="ln2712"> </a>
<a name="ln2713">void mons_load_spells(monster&amp; mon)</a>
<a name="ln2714">{</a>
<a name="ln2715">    vector&lt;mon_spellbook_type&gt; books = _mons_spellbook_list(mon.type);</a>
<a name="ln2716">    const mon_spellbook_type book = books[random2(books.size())];</a>
<a name="ln2717"> </a>
<a name="ln2718">    if (book == MST_GHOST)</a>
<a name="ln2719">        return mon.load_ghost_spells();</a>
<a name="ln2720"> </a>
<a name="ln2721">    mon.spells.clear();</a>
<a name="ln2722">    if (mons_genus(mon.type) == MONS_DRACONIAN)</a>
<a name="ln2723">    {</a>
<a name="ln2724">        mon_spell_slot breath = drac_breath(draco_or_demonspawn_subspecies(mon));</a>
<a name="ln2725">        if (breath.spell != SPELL_NO_SPELL)</a>
<a name="ln2726">            mon.spells.push_back(breath);</a>
<a name="ln2727">    }</a>
<a name="ln2728"> </a>
<a name="ln2729">    if (book == MST_NO_SPELLS)</a>
<a name="ln2730">        return;</a>
<a name="ln2731"> </a>
<a name="ln2732">    dprf(DIAG_MONPLACE, &quot;%s: loading spellbook #%d&quot;,</a>
<a name="ln2733">         mon.name(DESC_PLAIN, true).c_str(), static_cast&lt;int&gt;(book));</a>
<a name="ln2734"> </a>
<a name="ln2735">    for (const mon_spellbook &amp;spbook : mspell_list)</a>
<a name="ln2736">        if (spbook.type == book)</a>
<a name="ln2737">        {</a>
<a name="ln2738">            mon.spells = spbook.spells;</a>
<a name="ln2739">            break;</a>
<a name="ln2740">        }</a>
<a name="ln2741">}</a>
<a name="ln2742"> </a>
<a name="ln2743">// Never hand out DARKGREY as a monster colour, even if it is randomly</a>
<a name="ln2744">// chosen.</a>
<a name="ln2745">colour_t random_monster_colour()</a>
<a name="ln2746">{</a>
<a name="ln2747">    colour_t col = DARKGREY;</a>
<a name="ln2748">    while (col == DARKGREY)</a>
<a name="ln2749">        col = random_colour();</a>
<a name="ln2750"> </a>
<a name="ln2751">    return col;</a>
<a name="ln2752">}</a>
<a name="ln2753"> </a>
<a name="ln2754">bool init_abomination(monster&amp; mon, int hd)</a>
<a name="ln2755">{</a>
<a name="ln2756">    if (mon.type == MONS_CRAWLING_CORPSE</a>
<a name="ln2757">        || mon.type == MONS_MACABRE_MASS)</a>
<a name="ln2758">    {</a>
<a name="ln2759">        mon.set_hit_dice(mon.hit_points = mon.max_hit_points = hd);</a>
<a name="ln2760">        return true;</a>
<a name="ln2761">    }</a>
<a name="ln2762">    else if (mon.type != MONS_ABOMINATION_LARGE</a>
<a name="ln2763">             &amp;&amp; mon.type != MONS_ABOMINATION_SMALL)</a>
<a name="ln2764">    {</a>
<a name="ln2765">        return false;</a>
<a name="ln2766">    }</a>
<a name="ln2767"> </a>
<a name="ln2768">    const int max_hd = mon.type == MONS_ABOMINATION_LARGE ? 30 : 15;</a>
<a name="ln2769"> </a>
<a name="ln2770">    mon.set_hit_dice(min(max_hd, hd));</a>
<a name="ln2771"> </a>
<a name="ln2772">    const monsterentry *m = get_monster_data(mon.type);</a>
<a name="ln2773">    const int hp = hit_points(div_rand_round(hd * m-&gt;avg_hp_10x, m-&gt;HD));</a>
<a name="ln2774"> </a>
<a name="ln2775">    mon.max_hit_points = hp;</a>
<a name="ln2776">    mon.hit_points     = hp;</a>
<a name="ln2777"> </a>
<a name="ln2778">    return true;</a>
<a name="ln2779">}</a>
<a name="ln2780"> </a>
<a name="ln2781">// Generate a shiny, new and unscarred monster.</a>
<a name="ln2782">void define_monster(monster&amp; mons)</a>
<a name="ln2783">{</a>
<a name="ln2784">    monster_type mcls         = mons.type;</a>
<a name="ln2785">    ASSERT(!mons_class_is_zombified(mcls)); // should have called define_zombie</a>
<a name="ln2786"> </a>
<a name="ln2787">    monster_type monbase      = mons.base_monster;</a>
<a name="ln2788">    const monsterentry *m     = get_monster_data(mcls);</a>
<a name="ln2789">    int col                   = mons_class_colour(mcls);</a>
<a name="ln2790">    int hd                    = mons_class_hit_dice(mcls);</a>
<a name="ln2791">    int hp = 0;</a>
<a name="ln2792"> </a>
<a name="ln2793">    mons.mname.clear();</a>
<a name="ln2794"> </a>
<a name="ln2795">    // misc</a>
<a name="ln2796">    mons.god = GOD_NO_GOD;</a>
<a name="ln2797"> </a>
<a name="ln2798">    switch (mcls)</a>
<a name="ln2799">    {</a>
<a name="ln2800">    case MONS_ABOMINATION_SMALL:</a>
<a name="ln2801">        hd = 4 + random2(4);</a>
<a name="ln2802">        mons.props[MON_SPEED_KEY] = 7 + random2avg(9, 2);</a>
<a name="ln2803">        init_abomination(mons, hd);</a>
<a name="ln2804">        break;</a>
<a name="ln2805"> </a>
<a name="ln2806">    case MONS_ABOMINATION_LARGE:</a>
<a name="ln2807">        hd = 8 + random2(4);</a>
<a name="ln2808">        mons.props[MON_SPEED_KEY] = 6 + random2avg(7, 2);</a>
<a name="ln2809">        init_abomination(mons, hd);</a>
<a name="ln2810">        break;</a>
<a name="ln2811"> </a>
<a name="ln2812">    case MONS_SLIME_CREATURE:</a>
<a name="ln2813">        // Slime creatures start off as only single un-merged blobs.</a>
<a name="ln2814">        mons.blob_size = 1;</a>
<a name="ln2815">        break;</a>
<a name="ln2816"> </a>
<a name="ln2817">    case MONS_HYDRA:</a>
<a name="ln2818">        // Hydras start off with 4 to 8 heads.</a>
<a name="ln2819">        mons.num_heads = random_range(4, 8);</a>
<a name="ln2820">        break;</a>
<a name="ln2821"> </a>
<a name="ln2822">    case MONS_LERNAEAN_HYDRA:</a>
<a name="ln2823">        // The Lernaean hydra starts off with 27 heads.</a>
<a name="ln2824">        mons.num_heads = 27;</a>
<a name="ln2825">        break;</a>
<a name="ln2826"> </a>
<a name="ln2827">    case MONS_TIAMAT:</a>
<a name="ln2828">        // Initialise to a random draconian type.</a>
<a name="ln2829">        draconian_change_colour(&amp;mons);</a>
<a name="ln2830">        monbase = mons.base_monster;</a>
<a name="ln2831">        col = mons.colour;</a>
<a name="ln2832">        break;</a>
<a name="ln2833"> </a>
<a name="ln2834">    case MONS_STARCURSED_MASS:</a>
<a name="ln2835">        mons.blob_size = 12;</a>
<a name="ln2836">        break;</a>
<a name="ln2837"> </a>
<a name="ln2838">    // Randomize starting speed burst clock</a>
<a name="ln2839">    case MONS_SIXFIRHY:</a>
<a name="ln2840">    case MONS_JIANGSHI:</a>
<a name="ln2841">        mons.move_spurt = random2(360);</a>
<a name="ln2842">        break;</a>
<a name="ln2843"> </a>
<a name="ln2844">    case MONS_SHAMBLING_MANGROVE:</a>
<a name="ln2845">        mons.mangrove_pests = x_chance_in_y(3, 5) ? random_range(2, 3) : 0;</a>
<a name="ln2846">        break;</a>
<a name="ln2847"> </a>
<a name="ln2848">    case MONS_SERPENT_OF_HELL:</a>
<a name="ln2849">    case MONS_SERPENT_OF_HELL_COCYTUS:</a>
<a name="ln2850">    case MONS_SERPENT_OF_HELL_DIS:</a>
<a name="ln2851">    case MONS_SERPENT_OF_HELL_TARTARUS:</a>
<a name="ln2852">        mons.num_heads = 3;</a>
<a name="ln2853">        break;</a>
<a name="ln2854"> </a>
<a name="ln2855">    default:</a>
<a name="ln2856">        break;</a>
<a name="ln2857">    }</a>
<a name="ln2858"> </a>
<a name="ln2859">    if (mons_is_draconian_job(mcls))</a>
<a name="ln2860">    {</a>
<a name="ln2861">        // Professional draconians still have a base draconian type.</a>
<a name="ln2862">        // White draconians will never be draconian scorchers, but</a>
<a name="ln2863">        // apart from that, anything goes.</a>
<a name="ln2864">        do</a>
<a name="ln2865">        {</a>
<a name="ln2866">            monbase = random_draconian_monster_species();</a>
<a name="ln2867">        }</a>
<a name="ln2868">        while (drac_colour_incompatible(mcls, monbase));</a>
<a name="ln2869">    }</a>
<a name="ln2870"> </a>
<a name="ln2871">    if (mons_is_demonspawn_job(mcls))</a>
<a name="ln2872">    {</a>
<a name="ln2873">        // Some base demonspawn have more or less HP, AC, EV than their</a>
<a name="ln2874">        // brethren; those should be based on the base monster,</a>
<a name="ln2875">        // with modifiers taken from the job.</a>
<a name="ln2876"> </a>
<a name="ln2877">        monbase = (mons.base_monster == MONS_NO_MONSTER</a>
<a name="ln2878">                   || mons.base_monster == MONS_PROGRAM_BUG) // zombie gen</a>
<a name="ln2879">                  ? random_demonspawn_monster_species()</a>
<a name="ln2880">                  : mons.base_monster;</a>
<a name="ln2881"> </a>
<a name="ln2882">        const monsterentry* mbase = get_monster_data(monbase);</a>
<a name="ln2883">        hp = hit_points(mbase-&gt;avg_hp_10x + m-&gt;avg_hp_10x);</a>
<a name="ln2884">    }</a>
<a name="ln2885"> </a>
<a name="ln2886">    if (col == COLOUR_UNDEF) // but never give out darkgrey to monsters</a>
<a name="ln2887">        col = random_monster_colour();</a>
<a name="ln2888"> </a>
<a name="ln2889">    // Some calculations.</a>
<a name="ln2890">    if (hp == 0)</a>
<a name="ln2891">        hp = hit_points(m-&gt;avg_hp_10x);</a>
<a name="ln2892">    const int hp_max = hp;</a>
<a name="ln2893"> </a>
<a name="ln2894">    // So let it be written, so let it be done.</a>
<a name="ln2895">    mons.set_hit_dice(hd);</a>
<a name="ln2896">    mons.hit_points      = hp;</a>
<a name="ln2897">    mons.max_hit_points  = hp_max;</a>
<a name="ln2898">    mons.speed_increment = 70;</a>
<a name="ln2899"> </a>
<a name="ln2900">    if (mons.base_monster == MONS_NO_MONSTER</a>
<a name="ln2901">        || mons.base_monster == MONS_PROGRAM_BUG) // latter is zombie gen</a>
<a name="ln2902">    {</a>
<a name="ln2903">        mons.base_monster = monbase;</a>
<a name="ln2904">    }</a>
<a name="ln2905"> </a>
<a name="ln2906">    mons.flags      = MF_NO_FLAGS;</a>
<a name="ln2907">    mons.experience = 0;</a>
<a name="ln2908">    mons.colour     = col;</a>
<a name="ln2909"> </a>
<a name="ln2910">    mons.bind_melee_flags();</a>
<a name="ln2911"> </a>
<a name="ln2912">    mons_load_spells(mons);</a>
<a name="ln2913">    mons.bind_spell_flags();</a>
<a name="ln2914"> </a>
<a name="ln2915">    // Reset monster enchantments.</a>
<a name="ln2916">    mons.enchantments.clear();</a>
<a name="ln2917">    mons.ench_cache.reset();</a>
<a name="ln2918">    mons.ench_countdown = 0;</a>
<a name="ln2919"> </a>
<a name="ln2920">    switch (mcls)</a>
<a name="ln2921">    {</a>
<a name="ln2922">    case MONS_PANDEMONIUM_LORD:</a>
<a name="ln2923">    {</a>
<a name="ln2924">        ghost_demon ghost;</a>
<a name="ln2925">        ghost.init_pandemonium_lord();</a>
<a name="ln2926">        mons.set_ghost(ghost);</a>
<a name="ln2927">        mons.ghost_demon_init();</a>
<a name="ln2928">        mons.bind_melee_flags();</a>
<a name="ln2929">        mons.bind_spell_flags();</a>
<a name="ln2930">        break;</a>
<a name="ln2931">    }</a>
<a name="ln2932"> </a>
<a name="ln2933">    case MONS_PLAYER_GHOST:</a>
<a name="ln2934">    {</a>
<a name="ln2935">        if (define_ghost_from_bones(mons))</a>
<a name="ln2936">            break;</a>
<a name="ln2937">        dprf(&quot;No ghosts found in bones, falling back on mirrored player&quot;);</a>
<a name="ln2938">        // intentional fallthrough -- fall back on mirroring the player</a>
<a name="ln2939">    }</a>
<a name="ln2940">    case MONS_PLAYER_ILLUSION:</a>
<a name="ln2941">    {</a>
<a name="ln2942">        ghost_demon ghost;</a>
<a name="ln2943">        ghost.init_player_ghost();</a>
<a name="ln2944">        if (mcls == MONS_PLAYER_GHOST)</a>
<a name="ln2945">        {</a>
<a name="ln2946">            // still don't allow undead ghosts, even mirrored</a>
<a name="ln2947">            if (you.undead_state(false) != US_ALIVE)</a>
<a name="ln2948">                ghost.species = SP_HUMAN;</a>
<a name="ln2949">            mons.props[MIRRORED_GHOST_KEY] = true;</a>
<a name="ln2950">        }</a>
<a name="ln2951">        mons.set_ghost(ghost);</a>
<a name="ln2952">        mons.ghost_init(!mons.props.exists(&quot;fake&quot;));</a>
<a name="ln2953">        break;</a>
<a name="ln2954">    }</a>
<a name="ln2955"> </a>
<a name="ln2956">    case MONS_UGLY_THING:</a>
<a name="ln2957">    case MONS_VERY_UGLY_THING:</a>
<a name="ln2958">    {</a>
<a name="ln2959">        ghost_demon ghost;</a>
<a name="ln2960">        ghost.init_ugly_thing(mcls == MONS_VERY_UGLY_THING);</a>
<a name="ln2961">        mons.set_ghost(ghost);</a>
<a name="ln2962">        mons.uglything_init();</a>
<a name="ln2963">        break;</a>
<a name="ln2964">    }</a>
<a name="ln2965"> </a>
<a name="ln2966">    // Load with dummy values so certain monster properties can be queried</a>
<a name="ln2967">    // before placement without crashing (proper setup is done later here)</a>
<a name="ln2968">    case MONS_DANCING_WEAPON:</a>
<a name="ln2969">    case MONS_SPECTRAL_WEAPON:</a>
<a name="ln2970">    {</a>
<a name="ln2971">        ghost_demon ghost;</a>
<a name="ln2972">        mons.set_ghost(ghost);</a>
<a name="ln2973">        break;</a>
<a name="ln2974">    }</a>
<a name="ln2975"> </a>
<a name="ln2976">    default:</a>
<a name="ln2977">        break;</a>
<a name="ln2978">    }</a>
<a name="ln2979"> </a>
<a name="ln2980">    mons.calc_speed();</a>
<a name="ln2981"> </a>
<a name="ln2982">    // When all is said and done, this monster had better have some hit</a>
<a name="ln2983">    // points, or it will be dead on arrival</a>
<a name="ln2984">    ASSERT(mons.hit_points &gt; 0);</a>
<a name="ln2985">    ASSERT(mons.max_hit_points &gt; 0);</a>
<a name="ln2986">}</a>
<a name="ln2987"> </a>
<a name="ln2988">static const char *ugly_colour_names[] =</a>
<a name="ln2989">{</a>
<a name="ln2990">    &quot;red&quot;, &quot;brown&quot;, &quot;green&quot;, &quot;cyan&quot;, &quot;purple&quot;, &quot;white&quot;</a>
<a name="ln2991">};</a>
<a name="ln2992"> </a>
<a name="ln2993">string ugly_thing_colour_name(colour_t colour)</a>
<a name="ln2994">{</a>
<a name="ln2995">    int colour_offset = ugly_thing_colour_offset(colour);</a>
<a name="ln2996"> </a>
<a name="ln2997">    if (colour_offset == -1)</a>
<a name="ln2998">        return &quot;buggy&quot;;</a>
<a name="ln2999"> </a>
<a name="ln3000">    return ugly_colour_names[colour_offset];</a>
<a name="ln3001">}</a>
<a name="ln3002"> </a>
<a name="ln3003">static const colour_t ugly_colour_values[] =</a>
<a name="ln3004">{</a>
<a name="ln3005">    RED, BROWN, GREEN, CYAN, MAGENTA, LIGHTGREY</a>
<a name="ln3006">};</a>
<a name="ln3007"> </a>
<a name="ln3008">colour_t ugly_thing_random_colour()</a>
<a name="ln3009">{</a>
<a name="ln3010">    return RANDOM_ELEMENT(ugly_colour_values);</a>
<a name="ln3011">}</a>
<a name="ln3012"> </a>
<a name="ln3013">int str_to_ugly_thing_colour(const string &amp;s)</a>
<a name="ln3014">{</a>
<a name="ln3015">    COMPILE_CHECK(ARRAYSZ(ugly_colour_values) == ARRAYSZ(ugly_colour_names));</a>
<a name="ln3016">    for (int i = 0, size = ARRAYSZ(ugly_colour_values); i &lt; size; ++i)</a>
<a name="ln3017">        if (s == ugly_colour_names[i])</a>
<a name="ln3018">            return ugly_colour_values[i];</a>
<a name="ln3019">    return BLACK;</a>
<a name="ln3020">}</a>
<a name="ln3021"> </a>
<a name="ln3022">int ugly_thing_colour_offset(colour_t colour)</a>
<a name="ln3023">{</a>
<a name="ln3024">    for (unsigned i = 0; i &lt; ARRAYSZ(ugly_colour_values); ++i)</a>
<a name="ln3025">    {</a>
<a name="ln3026">        if (make_low_colour(colour) == ugly_colour_values[i])</a>
<a name="ln3027">            return i;</a>
<a name="ln3028">    }</a>
<a name="ln3029"> </a>
<a name="ln3030">    return -1;</a>
<a name="ln3031">}</a>
<a name="ln3032"> </a>
<a name="ln3033">void ugly_thing_apply_uniform_band_colour(mgen_data &amp;mg,</a>
<a name="ln3034">    const monster_type *band_monsters, size_t num_monsters_in_band)</a>
<a name="ln3035">{</a>
<a name="ln3036">    // Verify that the whole band is ugly.</a>
<a name="ln3037">    for (size_t i = 0; i &lt; num_monsters_in_band; i++)</a>
<a name="ln3038">    {</a>
<a name="ln3039">        if (!(band_monsters[i] == MONS_UGLY_THING</a>
<a name="ln3040">            || band_monsters[i] == MONS_VERY_UGLY_THING))</a>
<a name="ln3041">        {</a>
<a name="ln3042">            return;</a>
<a name="ln3043">        }</a>
<a name="ln3044">    }</a>
<a name="ln3045"> </a>
<a name="ln3046">    // Apply a uniform colour to a fully-ugly band.</a>
<a name="ln3047">    if (ugly_thing_colour_offset(mg.colour) == -1)</a>
<a name="ln3048">        mg.colour = ugly_thing_random_colour();</a>
<a name="ln3049">}</a>
<a name="ln3050"> </a>
<a name="ln3051">static const char *drac_colour_names[] =</a>
<a name="ln3052">{</a>
<a name="ln3053">    &quot;black&quot;,</a>
<a name="ln3054">#if TAG_MAJOR_VERSION == 34</a>
<a name="ln3055">    &quot;&quot;,</a>
<a name="ln3056">#endif</a>
<a name="ln3057">    &quot;yellow&quot;, &quot;green&quot;, &quot;purple&quot;, &quot;red&quot;, &quot;white&quot;, &quot;grey&quot;, &quot;pale&quot;</a>
<a name="ln3058">};</a>
<a name="ln3059"> </a>
<a name="ln3060">string draconian_colour_name(monster_type mon_type)</a>
<a name="ln3061">{</a>
<a name="ln3062">    COMPILE_CHECK(ARRAYSZ(drac_colour_names) ==</a>
<a name="ln3063">                  MONS_LAST_BASE_DRACONIAN - MONS_DRACONIAN);</a>
<a name="ln3064"> </a>
<a name="ln3065">    if (!mons_is_base_draconian(mon_type) || mon_type == MONS_DRACONIAN)</a>
<a name="ln3066">        return &quot;buggy&quot;;</a>
<a name="ln3067"> </a>
<a name="ln3068">    return drac_colour_names[mon_type - MONS_FIRST_BASE_DRACONIAN];</a>
<a name="ln3069">}</a>
<a name="ln3070"> </a>
<a name="ln3071">monster_type draconian_colour_by_name(const string &amp;name)</a>
<a name="ln3072">{</a>
<a name="ln3073">    COMPILE_CHECK(ARRAYSZ(drac_colour_names)</a>
<a name="ln3074">                  == (MONS_LAST_BASE_DRACONIAN - MONS_DRACONIAN));</a>
<a name="ln3075"> </a>
<a name="ln3076">    for (unsigned i = 0; i &lt; ARRAYSZ(drac_colour_names); ++i)</a>
<a name="ln3077">    {</a>
<a name="ln3078">        if (name == drac_colour_names[i])</a>
<a name="ln3079">            return static_cast&lt;monster_type&gt;(i + MONS_FIRST_BASE_DRACONIAN);</a>
<a name="ln3080">    }</a>
<a name="ln3081"> </a>
<a name="ln3082">    return MONS_PROGRAM_BUG;</a>
<a name="ln3083">}</a>
<a name="ln3084"> </a>
<a name="ln3085">// TODO: Remove &quot;putrid&quot; when TAG_MAJOR_VERSION &gt; 34</a>
<a name="ln3086">static const char *demonspawn_base_names[] =</a>
<a name="ln3087">{</a>
<a name="ln3088">    &quot;monstrous&quot;, &quot;gelid&quot;, &quot;infernal&quot;,</a>
<a name="ln3089">#if TAG_MAJOR_VERSION == 34</a>
<a name="ln3090">    &quot;putrid&quot;,</a>
<a name="ln3091">#endif</a>
<a name="ln3092">    &quot;torturous&quot;,</a>
<a name="ln3093">};</a>
<a name="ln3094"> </a>
<a name="ln3095">string demonspawn_base_name(monster_type mon_type)</a>
<a name="ln3096">{</a>
<a name="ln3097">    COMPILE_CHECK(ARRAYSZ(demonspawn_base_names) ==</a>
<a name="ln3098">                  MONS_LAST_BASE_DEMONSPAWN - MONS_FIRST_BASE_DEMONSPAWN + 1);</a>
<a name="ln3099"> </a>
<a name="ln3100">    if (mon_type &lt; MONS_FIRST_BASE_DEMONSPAWN</a>
<a name="ln3101">        || mon_type &gt; MONS_LAST_BASE_DEMONSPAWN)</a>
<a name="ln3102">    {</a>
<a name="ln3103">        return &quot;buggy&quot;;</a>
<a name="ln3104">    }</a>
<a name="ln3105"> </a>
<a name="ln3106">    return demonspawn_base_names[mon_type - MONS_FIRST_BASE_DEMONSPAWN];</a>
<a name="ln3107">}</a>
<a name="ln3108"> </a>
<a name="ln3109">monster_type demonspawn_base_by_name(const string &amp;name)</a>
<a name="ln3110">{</a>
<a name="ln3111">    COMPILE_CHECK(ARRAYSZ(demonspawn_base_names) ==</a>
<a name="ln3112">                  MONS_LAST_BASE_DEMONSPAWN - MONS_FIRST_BASE_DEMONSPAWN + 1);</a>
<a name="ln3113"> </a>
<a name="ln3114">    for (unsigned i = 0; i &lt; ARRAYSZ(demonspawn_base_names); ++i)</a>
<a name="ln3115">    {</a>
<a name="ln3116">        if (name == demonspawn_base_names[i])</a>
<a name="ln3117">            return static_cast&lt;monster_type&gt;(i + MONS_FIRST_BASE_DEMONSPAWN);</a>
<a name="ln3118">    }</a>
<a name="ln3119"> </a>
<a name="ln3120">    return MONS_PROGRAM_BUG;</a>
<a name="ln3121">}</a>
<a name="ln3122"> </a>
<a name="ln3123">string mons_type_name(monster_type mc, description_level_type desc)</a>
<a name="ln3124">{</a>
<a name="ln3125">    string result;</a>
<a name="ln3126"> </a>
<a name="ln3127">    if (!mons_is_unique(mc))</a>
<a name="ln3128">    {</a>
<a name="ln3129">        switch (desc)</a>
<a name="ln3130">        {</a>
<a name="ln3131">        case DESC_THE:       result = &quot;the &quot;; break;</a>
<a name="ln3132">        case DESC_A:         result = &quot;a &quot;;   break;</a>
<a name="ln3133">        case DESC_PLAIN: default:             break;</a>
<a name="ln3134">        }</a>
<a name="ln3135">    }</a>
<a name="ln3136"> </a>
<a name="ln3137">    switch (mc)</a>
<a name="ln3138">    {</a>
<a name="ln3139">    case RANDOM_MONSTER:</a>
<a name="ln3140">        result += &quot;random monster&quot;;</a>
<a name="ln3141">        return result;</a>
<a name="ln3142">    case RANDOM_DRACONIAN:</a>
<a name="ln3143">        result += &quot;random draconian&quot;;</a>
<a name="ln3144">        return result;</a>
<a name="ln3145">    case RANDOM_BASE_DRACONIAN:</a>
<a name="ln3146">        result += &quot;random base draconian&quot;;</a>
<a name="ln3147">        return result;</a>
<a name="ln3148">    case RANDOM_NONBASE_DRACONIAN:</a>
<a name="ln3149">        result += &quot;random nonbase draconian&quot;;</a>
<a name="ln3150">        return result;</a>
<a name="ln3151">    case RANDOM_DEMONSPAWN:</a>
<a name="ln3152">        result += &quot;random demonspawn&quot;;</a>
<a name="ln3153">        return result;</a>
<a name="ln3154">    case RANDOM_BASE_DEMONSPAWN:</a>
<a name="ln3155">        result += &quot;random base demonspawn&quot;;</a>
<a name="ln3156">        return result;</a>
<a name="ln3157">    case RANDOM_NONBASE_DEMONSPAWN:</a>
<a name="ln3158">        result += &quot;random nonbase demonspawn&quot;;</a>
<a name="ln3159">        return result;</a>
<a name="ln3160">    case WANDERING_MONSTER:</a>
<a name="ln3161">        result += &quot;wandering monster&quot;;</a>
<a name="ln3162">        return result;</a>
<a name="ln3163">    default: ;</a>
<a name="ln3164">    }</a>
<a name="ln3165"> </a>
<a name="ln3166">    const monsterentry *me = get_monster_data(mc);</a>
<a name="ln3167">    if (me == nullptr)</a>
<a name="ln3168">    {</a>
<a name="ln3169">        result += make_stringf(&quot;invalid monster_type %d&quot;, mc);</a>
<a name="ln3170">        return result;</a>
<a name="ln3171">    }</a>
<a name="ln3172"> </a>
<a name="ln3173">    result += me-&gt;name;</a>
<a name="ln3174"> </a>
<a name="ln3175">    // Vowel fix: Change 'a orc' to 'an orc'..</a>
<a name="ln3176">    if (result.length() &gt;= 3</a>
<a name="ln3177">        &amp;&amp; (result[0] == 'a' || result[0] == 'A')</a>
<a name="ln3178">        &amp;&amp; result[1] == ' '</a>
<a name="ln3179">        &amp;&amp; is_vowel(result[2])</a>
<a name="ln3180">        // XXX: Hack</a>
<a name="ln3181">        &amp;&amp; !starts_with(&amp;result[2], &quot;one-&quot;))</a>
<a name="ln3182">    {</a>
<a name="ln3183">        result.insert(1, &quot;n&quot;);</a>
<a name="ln3184">    }</a>
<a name="ln3185"> </a>
<a name="ln3186">    return result;</a>
<a name="ln3187">}</a>
<a name="ln3188"> </a>
<a name="ln3189">static string _get_proper_monster_name(const monster&amp; mon)</a>
<a name="ln3190">{</a>
<a name="ln3191">    const monsterentry *me = mon.find_monsterentry();</a>
<a name="ln3192">    if (!me)</a>
<a name="ln3193">        return &quot;&quot;;</a>
<a name="ln3194"> </a>
<a name="ln3195">    string name = getRandNameString(me-&gt;name, &quot; name&quot;);</a>
<a name="ln3196">    if (!name.empty())</a>
<a name="ln3197">        return name;</a>
<a name="ln3198"> </a>
<a name="ln3199">    return getRandNameString(get_monster_data(mons_genus(mon.type))-&gt;name,</a>
<a name="ln3200">                             &quot; name&quot;);</a>
<a name="ln3201">}</a>
<a name="ln3202"> </a>
<a name="ln3203">// Names a previously unnamed monster.</a>
<a name="ln3204">bool give_monster_proper_name(monster&amp; mon, bool orcs_only)</a>
<a name="ln3205">{</a>
<a name="ln3206">    // Already has a unique name.</a>
<a name="ln3207">    if (mon.is_named())</a>
<a name="ln3208">        return false;</a>
<a name="ln3209"> </a>
<a name="ln3210">    // Since this is called from the various divine blessing routines,</a>
<a name="ln3211">    // don't bless non-orcs, and normally don't bless plain orcs, either.</a>
<a name="ln3212">    if (orcs_only)</a>
<a name="ln3213">    {</a>
<a name="ln3214">        if (mons_genus(mon.type) != MONS_ORC</a>
<a name="ln3215">            || mon.type == MONS_ORC &amp;&amp; !one_chance_in(8))</a>
<a name="ln3216">        {</a>
<a name="ln3217">            return false;</a>
<a name="ln3218">        }</a>
<a name="ln3219">    }</a>
<a name="ln3220"> </a>
<a name="ln3221">    mon.mname = _get_proper_monster_name(mon);</a>
<a name="ln3222">    if (!mon.props.exists(&quot;dbname&quot;))</a>
<a name="ln3223">        mon.props[&quot;dbname&quot;] = mons_class_name(mon.type);</a>
<a name="ln3224"> </a>
<a name="ln3225">    if (mon.friendly())</a>
<a name="ln3226">        take_note(Note(NOTE_NAMED_ALLY, 0, 0, mon.mname));</a>
<a name="ln3227"> </a>
<a name="ln3228">    return mon.is_named();</a>
<a name="ln3229">}</a>
<a name="ln3230"> </a>
<a name="ln3231">// See mons_init for initialization of mon_entry array.</a>
<a name="ln3232">monsterentry *get_monster_data(monster_type mc)</a>
<a name="ln3233">{</a>
<a name="ln3234">    if (mc &gt;= 0 &amp;&amp; mc &lt; NUM_MONSTERS)</a>
<a name="ln3235">        return &amp;mondata[mon_entry[mc]];</a>
<a name="ln3236">    else</a>
<a name="ln3237">        return nullptr;</a>
<a name="ln3238">}</a>
<a name="ln3239"> </a>
<a name="ln3240">static int _mons_exp_mod(monster_type mc)</a>
<a name="ln3241">{</a>
<a name="ln3242">    ASSERT_smc();</a>
<a name="ln3243">    return smc-&gt;exp_mod;</a>
<a name="ln3244">}</a>
<a name="ln3245"> </a>
<a name="ln3246">int mons_class_base_speed(monster_type mc)</a>
<a name="ln3247">{</a>
<a name="ln3248">    ASSERT_smc();</a>
<a name="ln3249">    return smc-&gt;speed;</a>
<a name="ln3250">}</a>
<a name="ln3251"> </a>
<a name="ln3252">mon_energy_usage mons_class_energy(monster_type mc)</a>
<a name="ln3253">{</a>
<a name="ln3254">    ASSERT_smc();</a>
<a name="ln3255">    return smc-&gt;energy_usage;</a>
<a name="ln3256">}</a>
<a name="ln3257"> </a>
<a name="ln3258">mon_energy_usage mons_energy(const monster&amp; mon)</a>
<a name="ln3259">{</a>
<a name="ln3260">    mon_energy_usage meu = mons_class_energy(mons_base_type(mon));</a>
<a name="ln3261">    if (mon.ghost)</a>
<a name="ln3262">        meu.move = meu.swim = mon.ghost-&gt;move_energy;</a>
<a name="ln3263">    return meu;</a>
<a name="ln3264">}</a>
<a name="ln3265"> </a>
<a name="ln3266">int mons_class_zombie_base_speed(monster_type zombie_base_mc)</a>
<a name="ln3267">{</a>
<a name="ln3268">    return max(3, mons_class_base_speed(zombie_base_mc) - 2);</a>
<a name="ln3269">}</a>
<a name="ln3270"> </a>
<a name="ln3271">/**</a>
<a name="ln3272"> * What's this monster's base speed, before temporary effects are applied?</a>
<a name="ln3273"> *</a>
<a name="ln3274"> * @param mon       The monster in question.</a>
<a name="ln3275"> * @param known     Whether to include only information the player knows about,</a>
<a name="ln3276"> *                  i.e. not the speed of certain monsters with varying speeds</a>
<a name="ln3277"> *                  (abominations, hell beasts)</a>
<a name="ln3278"> * @return          The speed of the monster.</a>
<a name="ln3279"> */</a>
<a name="ln3280">int mons_base_speed(const monster&amp; mon, bool known)</a>
<a name="ln3281">{</a>
<a name="ln3282">    if (mon.ghost)</a>
<a name="ln3283">        return mon.ghost-&gt;speed;</a>
<a name="ln3284"> </a>
<a name="ln3285">    if (mon.props.exists(MON_SPEED_KEY)</a>
<a name="ln3286">        &amp;&amp; (!known || mon.type == MONS_MUTANT_BEAST))</a>
<a name="ln3287">    {</a>
<a name="ln3288">        return mon.props[MON_SPEED_KEY];</a>
<a name="ln3289">    }</a>
<a name="ln3290"> </a>
<a name="ln3291">    if (mon.type == MONS_SPECTRAL_THING)</a>
<a name="ln3292">        return mons_class_base_speed(mons_zombie_base(mon));</a>
<a name="ln3293"> </a>
<a name="ln3294">    return mons_is_zombified(mon) ? mons_class_zombie_base_speed(mons_zombie_base(mon))</a>
<a name="ln3295">                                  : mons_class_base_speed(mon.type);</a>
<a name="ln3296">}</a>
<a name="ln3297"> </a>
<a name="ln3298">mon_intel_type mons_class_intel(monster_type mc)</a>
<a name="ln3299">{</a>
<a name="ln3300">    ASSERT_smc();</a>
<a name="ln3301">    return smc-&gt;intel;</a>
<a name="ln3302">}</a>
<a name="ln3303"> </a>
<a name="ln3304">mon_intel_type mons_intel(const monster&amp; m)</a>
<a name="ln3305">{</a>
<a name="ln3306">    const monster&amp; mon = get_tentacle_head(m);</a>
<a name="ln3307"> </a>
<a name="ln3308">    if (mons_enslaved_soul(mon))</a>
<a name="ln3309">        return mons_class_intel(mons_zombie_base(mon));</a>
<a name="ln3310"> </a>
<a name="ln3311">    return mons_class_intel(mon.type);</a>
<a name="ln3312">}</a>
<a name="ln3313"> </a>
<a name="ln3314">static habitat_type _mons_class_habitat(monster_type mc,</a>
<a name="ln3315">                                        bool real_amphibious = false)</a>
<a name="ln3316">{</a>
<a name="ln3317">    const monsterentry *me = get_monster_data(mc);</a>
<a name="ln3318">    habitat_type ht = (me ? me-&gt;habitat</a>
<a name="ln3319">                          : get_monster_data(MONS_PROGRAM_BUG)-&gt;habitat);</a>
<a name="ln3320">    if (!real_amphibious)</a>
<a name="ln3321">    {</a>
<a name="ln3322">        // XXX: No class equivalent of monster::body_size(PSIZE_BODY)!</a>
<a name="ln3323">        size_type st = (me ? me-&gt;size</a>
<a name="ln3324">                           : get_monster_data(MONS_PROGRAM_BUG)-&gt;size);</a>
<a name="ln3325">        if (ht == HT_LAND &amp;&amp; st &gt;= SIZE_GIANT || mc == MONS_GREY_DRACONIAN)</a>
<a name="ln3326">            ht = HT_AMPHIBIOUS;</a>
<a name="ln3327">    }</a>
<a name="ln3328">    return ht;</a>
<a name="ln3329">}</a>
<a name="ln3330"> </a>
<a name="ln3331">habitat_type mons_habitat(const monster&amp; mon, bool real_amphibious)</a>
<a name="ln3332">{</a>
<a name="ln3333">    return _mons_class_habitat(fixup_zombie_type(mon.type,</a>
<a name="ln3334">                                                 mons_base_type(mon)),</a>
<a name="ln3335">                               real_amphibious);</a>
<a name="ln3336">}</a>
<a name="ln3337"> </a>
<a name="ln3338">habitat_type mons_class_primary_habitat(monster_type mc)</a>
<a name="ln3339">{</a>
<a name="ln3340">    habitat_type ht = _mons_class_habitat(mc);</a>
<a name="ln3341">    if (ht == HT_AMPHIBIOUS || ht == HT_AMPHIBIOUS_LAVA)</a>
<a name="ln3342">        ht = HT_LAND;</a>
<a name="ln3343">    return ht;</a>
<a name="ln3344">}</a>
<a name="ln3345"> </a>
<a name="ln3346">habitat_type mons_primary_habitat(const monster&amp; mon)</a>
<a name="ln3347">{</a>
<a name="ln3348">    return mons_class_primary_habitat(mons_base_type(mon));</a>
<a name="ln3349">}</a>
<a name="ln3350"> </a>
<a name="ln3351">habitat_type mons_class_secondary_habitat(monster_type mc)</a>
<a name="ln3352">{</a>
<a name="ln3353">    habitat_type ht = _mons_class_habitat(mc);</a>
<a name="ln3354">    if (ht == HT_AMPHIBIOUS)</a>
<a name="ln3355">        ht = HT_WATER;</a>
<a name="ln3356">    if (ht == HT_AMPHIBIOUS_LAVA)</a>
<a name="ln3357">        ht = HT_LAVA;</a>
<a name="ln3358">    return ht;</a>
<a name="ln3359">}</a>
<a name="ln3360"> </a>
<a name="ln3361">habitat_type mons_secondary_habitat(const monster&amp; mon)</a>
<a name="ln3362">{</a>
<a name="ln3363">    return mons_class_secondary_habitat(mons_base_type(mon));</a>
<a name="ln3364">}</a>
<a name="ln3365"> </a>
<a name="ln3366">bool intelligent_ally(const monster&amp; mon)</a>
<a name="ln3367">{</a>
<a name="ln3368">    return mon.attitude == ATT_FRIENDLY &amp;&amp; mons_intel(mon) &gt;= I_HUMAN;</a>
<a name="ln3369">}</a>
<a name="ln3370"> </a>
<a name="ln3371">int mons_power(monster_type mc)</a>
<a name="ln3372">{</a>
<a name="ln3373">    // For now, just return monster hit dice.</a>
<a name="ln3374">    ASSERT_smc();</a>
<a name="ln3375">    return mons_class_hit_dice(mc);</a>
<a name="ln3376">}</a>
<a name="ln3377"> </a>
<a name="ln3378">/// Are two actors 'aligned'? (Will they refuse to attack each-other?)</a>
<a name="ln3379">bool mons_aligned(const actor *m1, const actor *m2)</a>
<a name="ln3380">{</a>
<a name="ln3381">    if (!m1 || !m2)</a>
<a name="ln3382">        return true;</a>
<a name="ln3383"> </a>
<a name="ln3384">    if (mons_is_projectile(m1-&gt;type) || mons_is_projectile(m2-&gt;type))</a>
<a name="ln3385">        return true; // they won't directly attack each-other, anyway</a>
<a name="ln3386"> </a>
<a name="ln3387">    return mons_atts_aligned(m1-&gt;temp_attitude(), m2-&gt;temp_attitude());</a>
<a name="ln3388">}</a>
<a name="ln3389"> </a>
<a name="ln3390">bool mons_atts_aligned(mon_attitude_type fr1, mon_attitude_type fr2)</a>
<a name="ln3391">{</a>
<a name="ln3392">    if (mons_att_wont_attack(fr1) &amp;&amp; mons_att_wont_attack(fr2))</a>
<a name="ln3393">        return true;</a>
<a name="ln3394"> </a>
<a name="ln3395">    return fr1 == fr2;</a>
<a name="ln3396">}</a>
<a name="ln3397"> </a>
<a name="ln3398">bool mons_class_wields_two_weapons(monster_type mc)</a>
<a name="ln3399">{</a>
<a name="ln3400">    return mons_class_flag(mc, M_TWO_WEAPONS);</a>
<a name="ln3401">}</a>
<a name="ln3402"> </a>
<a name="ln3403">bool mons_wields_two_weapons(const monster&amp; mon)</a>
<a name="ln3404">{</a>
<a name="ln3405">    if (testbits(mon.flags, MF_TWO_WEAPONS))</a>
<a name="ln3406">        return true;</a>
<a name="ln3407"> </a>
<a name="ln3408">    return mons_class_wields_two_weapons(mons_base_type(mon));</a>
<a name="ln3409">}</a>
<a name="ln3410"> </a>
<a name="ln3411">bool mons_self_destructs(const monster&amp; m)</a>
<a name="ln3412">{</a>
<a name="ln3413">    return m.type == MONS_BALLISTOMYCETE_SPORE</a>
<a name="ln3414">        || m.type == MONS_BALL_LIGHTNING</a>
<a name="ln3415">        || m.type == MONS_LURKING_HORROR</a>
<a name="ln3416">        || m.type == MONS_ORB_OF_DESTRUCTION</a>
<a name="ln3417">        || m.type == MONS_FULMINANT_PRISM;</a>
<a name="ln3418">}</a>
<a name="ln3419"> </a>
<a name="ln3420">bool mons_att_wont_attack(mon_attitude_type fr)</a>
<a name="ln3421">{</a>
<a name="ln3422">    return fr == ATT_FRIENDLY || fr == ATT_GOOD_NEUTRAL</a>
<a name="ln3423">           || fr == ATT_STRICT_NEUTRAL;</a>
<a name="ln3424">}</a>
<a name="ln3425"> </a>
<a name="ln3426">mon_attitude_type mons_attitude(const monster&amp; m)</a>
<a name="ln3427">{</a>
<a name="ln3428">    return m.temp_attitude();</a>
<a name="ln3429">}</a>
<a name="ln3430"> </a>
<a name="ln3431">bool mons_is_confused(const monster&amp; m, bool class_too)</a>
<a name="ln3432">{</a>
<a name="ln3433">    return (m.has_ench(ENCH_CONFUSION) || m.has_ench(ENCH_MAD))</a>
<a name="ln3434">           &amp;&amp; (class_too || !mons_class_flag(m.type, M_CONFUSED));</a>
<a name="ln3435">}</a>
<a name="ln3436"> </a>
<a name="ln3437">bool mons_is_wandering(const monster&amp; m)</a>
<a name="ln3438">{</a>
<a name="ln3439">    return m.behaviour == BEH_WANDER;</a>
<a name="ln3440">}</a>
<a name="ln3441"> </a>
<a name="ln3442">bool mons_is_seeking(const monster&amp; m)</a>
<a name="ln3443">{</a>
<a name="ln3444">    return m.behaviour == BEH_SEEK;</a>
<a name="ln3445">}</a>
<a name="ln3446"> </a>
<a name="ln3447">bool mons_is_unbreathing(monster_type mc)</a>
<a name="ln3448">{</a>
<a name="ln3449">    const mon_holy_type holi = mons_class_holiness(mc);</a>
<a name="ln3450"> </a>
<a name="ln3451">    if (holi &amp; (MH_UNDEAD | MH_NONLIVING | MH_PLANT))</a>
<a name="ln3452">        return true;</a>
<a name="ln3453"> </a>
<a name="ln3454">    if (mons_class_is_slime(mc))</a>
<a name="ln3455">        return true;</a>
<a name="ln3456"> </a>
<a name="ln3457">    return mons_class_flag(mc, M_UNBREATHING);</a>
<a name="ln3458">}</a>
<a name="ln3459"> </a>
<a name="ln3460">// Either running in fear, or trapped and unable to do so (but still wishing to)</a>
<a name="ln3461">bool mons_is_fleeing(const monster&amp; m)</a>
<a name="ln3462">{</a>
<a name="ln3463">    return m.behaviour == BEH_FLEE || mons_is_cornered(m);</a>
<a name="ln3464">}</a>
<a name="ln3465"> </a>
<a name="ln3466">// Can be either an orderly withdrawal (from which the monster can stop at will)</a>
<a name="ln3467">// or running in fear (from which they cannot)</a>
<a name="ln3468">bool mons_is_retreating(const monster&amp; m)</a>
<a name="ln3469">{</a>
<a name="ln3470">    return m.behaviour == BEH_RETREAT || mons_is_fleeing(m);</a>
<a name="ln3471">}</a>
<a name="ln3472"> </a>
<a name="ln3473">bool mons_is_cornered(const monster&amp; m)</a>
<a name="ln3474">{</a>
<a name="ln3475">    return m.behaviour == BEH_CORNERED;</a>
<a name="ln3476">}</a>
<a name="ln3477"> </a>
<a name="ln3478">bool mons_is_influenced_by_sanctuary(const monster&amp; m)</a>
<a name="ln3479">{</a>
<a name="ln3480">    return !m.wont_attack() &amp;&amp; !m.is_stationary();</a>
<a name="ln3481">}</a>
<a name="ln3482"> </a>
<a name="ln3483">bool mons_is_fleeing_sanctuary(const monster&amp; m)</a>
<a name="ln3484">{</a>
<a name="ln3485">    return sanctuary_exists()</a>
<a name="ln3486">           &amp;&amp; (m.flags &amp; MF_FLEEING_FROM_SANCTUARY)</a>
<a name="ln3487">           &amp;&amp; mons_is_influenced_by_sanctuary(m);</a>
<a name="ln3488">}</a>
<a name="ln3489"> </a>
<a name="ln3490">bool mons_just_slept(const monster&amp; m)</a>
<a name="ln3491">{</a>
<a name="ln3492">    return bool(m.flags &amp; MF_JUST_SLEPT);</a>
<a name="ln3493">}</a>
<a name="ln3494"> </a>
<a name="ln3495">// Moving body parts, turning oklob flowers and so on counts as motile here.</a>
<a name="ln3496">// So does preparing resurrect, struggling against a net, etc.</a>
<a name="ln3497">bool mons_is_immotile(const monster&amp; mons)</a>
<a name="ln3498">{</a>
<a name="ln3499">    return mons_is_firewood(mons)</a>
<a name="ln3500">        || mons.petrified()</a>
<a name="ln3501">        || mons.asleep()</a>
<a name="ln3502">        || mons.paralysed();</a>
<a name="ln3503">}</a>
<a name="ln3504"> </a>
<a name="ln3505">bool mons_is_batty(const monster&amp; m)</a>
<a name="ln3506">{</a>
<a name="ln3507">    return mons_class_flag(m.type, M_BATTY) || m.has_facet(BF_BAT);</a>
<a name="ln3508">}</a>
<a name="ln3509"> </a>
<a name="ln3510">bool mons_is_removed(monster_type mc)</a>
<a name="ln3511">{</a>
<a name="ln3512">    return mc != MONS_PROGRAM_BUG &amp;&amp; mons_species(mc) == MONS_PROGRAM_BUG;</a>
<a name="ln3513">}</a>
<a name="ln3514"> </a>
<a name="ln3515">bool mons_looks_stabbable(const monster&amp; m)</a>
<a name="ln3516">{</a>
<a name="ln3517">    const stab_type st = find_stab_type(&amp;you, m, false);</a>
<a name="ln3518">    return !m.friendly() &amp;&amp; stab_bonus_denom(st) == 1; // top-tier stab</a>
<a name="ln3519">}</a>
<a name="ln3520"> </a>
<a name="ln3521">bool mons_looks_distracted(const monster&amp; m)</a>
<a name="ln3522">{</a>
<a name="ln3523">    const stab_type st = find_stab_type(&amp;you, m, false);</a>
<a name="ln3524">    return !m.friendly()</a>
<a name="ln3525">           &amp;&amp; st != STAB_NO_STAB</a>
<a name="ln3526">           &amp;&amp; !mons_looks_stabbable(m);</a>
<a name="ln3527">}</a>
<a name="ln3528"> </a>
<a name="ln3529">void mons_start_fleeing_from_sanctuary(monster&amp; mons)</a>
<a name="ln3530">{</a>
<a name="ln3531">    mons.flags |= MF_FLEEING_FROM_SANCTUARY;</a>
<a name="ln3532">    mons.target = env.sanctuary_pos;</a>
<a name="ln3533">    behaviour_event(&amp;mons, ME_SCARE, 0, env.sanctuary_pos);</a>
<a name="ln3534">}</a>
<a name="ln3535"> </a>
<a name="ln3536">void mons_stop_fleeing_from_sanctuary(monster&amp; mons)</a>
<a name="ln3537">{</a>
<a name="ln3538">    const bool had_flag {mons.flags &amp; MF_FLEEING_FROM_SANCTUARY};</a>
<a name="ln3539">    mons.flags &amp;= (~MF_FLEEING_FROM_SANCTUARY);</a>
<a name="ln3540">    if (had_flag)</a>
<a name="ln3541">        behaviour_event(&amp;mons, ME_EVAL, &amp;you);</a>
<a name="ln3542">}</a>
<a name="ln3543"> </a>
<a name="ln3544">void mons_pacify(monster&amp; mon, mon_attitude_type att, bool no_xp)</a>
<a name="ln3545">{</a>
<a name="ln3546">    // If the _real_ (non-charmed) attitude is already that or better,</a>
<a name="ln3547">    // don't degrade it. This can happen, for example, with a high-power</a>
<a name="ln3548">    // Crusade card on Pikel's slaves who would then go down from friendly</a>
<a name="ln3549">    // to good_neutral when you kill Pikel.</a>
<a name="ln3550">    if (mon.attitude &gt;= att)</a>
<a name="ln3551">        return;</a>
<a name="ln3552"> </a>
<a name="ln3553">    // Must be done before attitude change, so that proper targets are affected</a>
<a name="ln3554">    if (mon.type == MONS_FLAYED_GHOST)</a>
<a name="ln3555">        end_flayed_effect(&amp;mon);</a>
<a name="ln3556"> </a>
<a name="ln3557">    // Make the monster permanently neutral.</a>
<a name="ln3558">    mon.attitude = att;</a>
<a name="ln3559">    mon.flags |= MF_WAS_NEUTRAL;</a>
<a name="ln3560"> </a>
<a name="ln3561">    if (!testbits(mon.flags, MF_PACIFIED) // Don't allow repeatedly pacifying.</a>
<a name="ln3562">        &amp;&amp; !no_xp</a>
<a name="ln3563">        &amp;&amp; !mon.is_summoned()</a>
<a name="ln3564">        &amp;&amp; !testbits(mon.flags, MF_NO_REWARD))</a>
<a name="ln3565">    {</a>
<a name="ln3566">        // Give the player half of the monster's XP.</a>
<a name="ln3567">        gain_exp((exper_value(mon) + 1) / 2);</a>
<a name="ln3568">    }</a>
<a name="ln3569">    mon.flags |= MF_PACIFIED;</a>
<a name="ln3570"> </a>
<a name="ln3571">    if (mon.type == MONS_GERYON)</a>
<a name="ln3572">    {</a>
<a name="ln3573">        simple_monster_message(mon,</a>
<a name="ln3574">            make_stringf(&quot; discards %s horn.&quot;,</a>
<a name="ln3575">                         mon.pronoun(PRONOUN_POSSESSIVE).c_str()).c_str());</a>
<a name="ln3576">        monster_drop_things(&amp;mon, false, item_is_horn_of_geryon);</a>
<a name="ln3577">    }</a>
<a name="ln3578"> </a>
<a name="ln3579">    // End constriction.</a>
<a name="ln3580">    mon.stop_constricting_all();</a>
<a name="ln3581">    mon.stop_being_constricted();</a>
<a name="ln3582"> </a>
<a name="ln3583">    // Cancel fleeing and such.</a>
<a name="ln3584">    mon.behaviour = BEH_WANDER;</a>
<a name="ln3585"> </a>
<a name="ln3586">    // Remove haunting, which would otherwise cause monster to continue attacking</a>
<a name="ln3587">    mon.del_ench(ENCH_HAUNTING, true, true);</a>
<a name="ln3588"> </a>
<a name="ln3589">    // Remove level annotation.</a>
<a name="ln3590">    mon.props[&quot;no_annotate&quot;] = true;</a>
<a name="ln3591">    remove_unique_annotation(&amp;mon);</a>
<a name="ln3592"> </a>
<a name="ln3593">    // Make the monster begin leaving the level.</a>
<a name="ln3594">    behaviour_event(&amp;mon, ME_EVAL);</a>
<a name="ln3595"> </a>
<a name="ln3596">    if (mons_is_mons_class(&amp;mon, MONS_PIKEL))</a>
<a name="ln3597">        pikel_band_neutralise();</a>
<a name="ln3598">    if (mons_is_elven_twin(&amp;mon))</a>
<a name="ln3599">        elven_twins_pacify(&amp;mon);</a>
<a name="ln3600">    if (mons_is_mons_class(&amp;mon, MONS_KIRKE))</a>
<a name="ln3601">        hogs_to_humans();</a>
<a name="ln3602">    if (mon.type == MONS_VAULT_WARDEN)</a>
<a name="ln3603">        timeout_terrain_changes(0, true);</a>
<a name="ln3604"> </a>
<a name="ln3605">    mons_att_changed(&amp;mon);</a>
<a name="ln3606">}</a>
<a name="ln3607"> </a>
<a name="ln3608">static bool _mons_should_fire_beneficial(bolt &amp;beam)</a>
<a name="ln3609">{</a>
<a name="ln3610">    // Should monster heal other, haste other or might other be able to</a>
<a name="ln3611">    // target the player? Saying no for now. -cao</a>
<a name="ln3612">    if (beam.target == you.pos())</a>
<a name="ln3613">        return false;</a>
<a name="ln3614"> </a>
<a name="ln3615">    // Assuming all beneficial beams are enchantments if a foe is in</a>
<a name="ln3616">    // the path the beam will definitely hit them so we shouldn't fire</a>
<a name="ln3617">    // in that case.</a>
<a name="ln3618">    if (beam.friend_info.count == 0</a>
<a name="ln3619">        || beam.foe_info.count != 0)</a>
<a name="ln3620">    {</a>
<a name="ln3621">        return false;</a>
<a name="ln3622">    }</a>
<a name="ln3623"> </a>
<a name="ln3624">    // Should beneficial monster enchantment beams be allowed in a</a>
<a name="ln3625">    // sanctuary? -cao</a>
<a name="ln3626">    if (is_sanctuary(you.pos()) || is_sanctuary(beam.source))</a>
<a name="ln3627">        return false;</a>
<a name="ln3628"> </a>
<a name="ln3629">    return true;</a>
<a name="ln3630">}</a>
<a name="ln3631"> </a>
<a name="ln3632">static bool _beneficial_beam_flavour(beam_type flavour)</a>
<a name="ln3633">{</a>
<a name="ln3634">    switch (flavour)</a>
<a name="ln3635">    {</a>
<a name="ln3636">    case BEAM_HASTE:</a>
<a name="ln3637">    case BEAM_HEALING:</a>
<a name="ln3638">    case BEAM_INVISIBILITY:</a>
<a name="ln3639">    case BEAM_MIGHT:</a>
<a name="ln3640">    case BEAM_AGILITY:</a>
<a name="ln3641">    case BEAM_RESISTANCE:</a>
<a name="ln3642">        return true;</a>
<a name="ln3643"> </a>
<a name="ln3644">    default:</a>
<a name="ln3645">        return false;</a>
<a name="ln3646">    }</a>
<a name="ln3647">}</a>
<a name="ln3648"> </a>
<a name="ln3649">bool mons_should_fire(bolt &amp;beam, bool ignore_good_idea)</a>
<a name="ln3650">{</a>
<a name="ln3651">    dprf(&quot;tracer: foes %d (pow: %d), friends %d (pow: %d), &quot;</a>
<a name="ln3652">         &quot;foe_ratio: %d&quot;,</a>
<a name="ln3653">         beam.foe_info.count, beam.foe_info.power,</a>
<a name="ln3654">         beam.friend_info.count, beam.friend_info.power,</a>
<a name="ln3655">         beam.foe_ratio);</a>
<a name="ln3656"> </a>
<a name="ln3657">    // Use different evaluation criteria if the beam is a beneficial</a>
<a name="ln3658">    // enchantment (haste other).</a>
<a name="ln3659">    if (_beneficial_beam_flavour(beam.flavour))</a>
<a name="ln3660">        return _mons_should_fire_beneficial(beam);</a>
<a name="ln3661"> </a>
<a name="ln3662">    if (is_sanctuary(you.pos()) || is_sanctuary(beam.source))</a>
<a name="ln3663">        return false;</a>
<a name="ln3664"> </a>
<a name="ln3665">    if (ignore_good_idea)</a>
<a name="ln3666">        return true;</a>
<a name="ln3667">    // After this point, safety/self-interest checks only.</a>
<a name="ln3668"> </a>
<a name="ln3669"> </a>
<a name="ln3670">    // Friendly monsters shouldn't be targeting you: this will happen</a>
<a name="ln3671">    // often because the default behaviour for charmed monsters is to</a>
<a name="ln3672">    // have you as a target. While foe_ratio will handle this, we</a>
<a name="ln3673">    // don't want a situation where a friendly dragon breathes through</a>
<a name="ln3674">    // you to hit other creatures... it should target the other</a>
<a name="ln3675">    // creatures, and coincidentally hit you.</a>
<a name="ln3676">    //</a>
<a name="ln3677">    // FIXME: this can cause problems with reflection, bounces, etc.</a>
<a name="ln3678">    // It would be better to have the monster fire logic never reach</a>
<a name="ln3679">    // this point for friendlies.</a>
<a name="ln3680">    if (monster_by_mid(beam.source_id))</a>
<a name="ln3681">    {</a>
<a name="ln3682">        monster* m = monster_by_mid(beam.source_id);</a>
<a name="ln3683">        if (m-&gt;alive() &amp;&amp; m-&gt;friendly() &amp;&amp; beam.target == you.pos())</a>
<a name="ln3684">            return false;</a>
<a name="ln3685">    }</a>
<a name="ln3686"> </a>
<a name="ln3687">    // Use of foeRatio:</a>
<a name="ln3688">    // The higher this number, the more monsters will _avoid_ collateral</a>
<a name="ln3689">    // damage to their friends.</a>
<a name="ln3690">    // Setting this to zero will in fact have all monsters ignore their</a>
<a name="ln3691">    // friends when considering collateral damage.</a>
<a name="ln3692"> </a>
<a name="ln3693">    // Quick check - did we in fact get any foes?</a>
<a name="ln3694">    if (beam.foe_info.count == 0)</a>
<a name="ln3695">        return false;</a>
<a name="ln3696"> </a>
<a name="ln3697">    // If we hit no friends, fire away.</a>
<a name="ln3698">    if (beam.friend_info.count == 0)</a>
<a name="ln3699">        return true;</a>
<a name="ln3700"> </a>
<a name="ln3701">    // Only fire if they do acceptably low collateral damage.</a>
<a name="ln3702">    return beam.foe_info.power &gt;=</a>
<a name="ln3703">           div_round_up(beam.foe_ratio *</a>
<a name="ln3704">                        (beam.foe_info.power + beam.friend_info.power),</a>
<a name="ln3705">                        100);</a>
<a name="ln3706">}</a>
<a name="ln3707"> </a>
<a name="ln3708">/**</a>
<a name="ln3709"> * Can monsters use the given spell effectively from range? (If a monster has</a>
<a name="ln3710"> * the given spell, should it try to keep its distance from its enemies?)</a>
<a name="ln3711"> *</a>
<a name="ln3712"> * @param monspell      The spell in question.</a>
<a name="ln3713"> * @param attack_only   Whether to only count spells which directly harm</a>
<a name="ln3714"> *                      enemies (damage or stat drain). Overrides ench_too.</a>
<a name="ln3715"> * @param ench_too      Whether to count temporary debilitating effects (Slow,</a>
<a name="ln3716"> *                      etc).</a>
<a name="ln3717"> * @return              Whether the given spell should be considered 'ranged'.</a>
<a name="ln3718"> */</a>
<a name="ln3719">static bool _ms_ranged_spell(spell_type monspell, bool attack_only = false,</a>
<a name="ln3720">                             bool ench_too = true)</a>
<a name="ln3721">{</a>
<a name="ln3722">    // summoning spells are usable from ranged, but not direct attacks.</a>
<a name="ln3723">    if (spell_typematch(monspell, spschool::summoning)</a>
<a name="ln3724">        || monspell == SPELL_CONJURE_BALL_LIGHTNING)</a>
<a name="ln3725">    {</a>
<a name="ln3726">        return !attack_only;</a>
<a name="ln3727">    }</a>
<a name="ln3728"> </a>
<a name="ln3729">    const spell_flags flags = get_spell_flags(monspell);</a>
<a name="ln3730"> </a>
<a name="ln3731">    // buffs &amp; escape spells aren't considered 'ranged'.</a>
<a name="ln3732">    if (testbits(flags, spflag::selfench)</a>
<a name="ln3733">        || spell_typematch(monspell, spschool::charms)</a>
<a name="ln3734">        || testbits(flags, spflag::escape)</a>
<a name="ln3735">        || monspell == SPELL_BLINK_OTHER_CLOSE)</a>
<a name="ln3736">    {</a>
<a name="ln3737">        return false;</a>
<a name="ln3738">    }</a>
<a name="ln3739"> </a>
<a name="ln3740">    // conjurations are attacks.</a>
<a name="ln3741">    if (spell_typematch(monspell, spschool::conjuration))</a>
<a name="ln3742">        return true;</a>
<a name="ln3743"> </a>
<a name="ln3744">    // hexes that aren't conjurations or summons are enchantments.</a>
<a name="ln3745">    if (spell_typematch(monspell, spschool::hexes))</a>
<a name="ln3746">        return !attack_only &amp;&amp; ench_too;</a>
<a name="ln3747"> </a>
<a name="ln3748">    switch (monspell)</a>
<a name="ln3749">    {</a>
<a name="ln3750">    case SPELL_NO_SPELL:</a>
<a name="ln3751">    case SPELL_CANTRIP:</a>
<a name="ln3752">    case SPELL_BLINK_CLOSE:</a>
<a name="ln3753">        return false;</a>
<a name="ln3754"> </a>
<a name="ln3755">    default:</a>
<a name="ln3756">        // Everything else is probably some kind of attack, hopefully.</a>
<a name="ln3757">        return true;</a>
<a name="ln3758">    }</a>
<a name="ln3759">}</a>
<a name="ln3760"> </a>
<a name="ln3761">// Returns true if the monster has an ability that can affect the target</a>
<a name="ln3762">// anywhere in LOS_DEFAULT; i.e., even through glass.</a>
<a name="ln3763">bool mons_has_los_ability(monster_type mon_type)</a>
<a name="ln3764">{</a>
<a name="ln3765">    return mons_is_siren_beholder(mon_type)</a>
<a name="ln3766">           || mon_type == MONS_STARCURSED_MASS;</a>
<a name="ln3767">}</a>
<a name="ln3768"> </a>
<a name="ln3769">bool mons_has_ranged_spell(const monster&amp; mon, bool attack_only,</a>
<a name="ln3770">                           bool ench_too)</a>
<a name="ln3771">{</a>
<a name="ln3772">    // Monsters may have spell-like abilities.</a>
<a name="ln3773">    if (mons_has_los_ability(mon.type))</a>
<a name="ln3774">        return true;</a>
<a name="ln3775"> </a>
<a name="ln3776">    for (const mon_spell_slot &amp;slot : mon.spells)</a>
<a name="ln3777">        if (_ms_ranged_spell(slot.spell, attack_only, ench_too))</a>
<a name="ln3778">            return true;</a>
<a name="ln3779"> </a>
<a name="ln3780">    return false;</a>
<a name="ln3781">}</a>
<a name="ln3782"> </a>
<a name="ln3783">// Returns whether the monster has a spell which is theoretically capable of</a>
<a name="ln3784">// causing an incapacitation state in the target foe (ie: it can cast sleep</a>
<a name="ln3785">// and the foe is not immune to being put to sleep)</a>
<a name="ln3786">//</a>
<a name="ln3787">// Note that this only current checks for inherent obvious immunity (ie: sleep</a>
<a name="ln3788">// immunity from being undead) and not immunity that might be granted by gear</a>
<a name="ln3789">// (such as clarity or stasis)</a>
<a name="ln3790">bool mons_has_incapacitating_spell(const monster&amp; mon, const actor&amp; foe)</a>
<a name="ln3791">{</a>
<a name="ln3792">    for (const mon_spell_slot &amp;slot : mon.spells)</a>
<a name="ln3793">    {</a>
<a name="ln3794">        switch (slot.spell)</a>
<a name="ln3795">        {</a>
<a name="ln3796">        case SPELL_SLEEP:</a>
<a name="ln3797">            if (foe.can_sleep())</a>
<a name="ln3798">                return true;</a>
<a name="ln3799">            break;</a>
<a name="ln3800"> </a>
<a name="ln3801">        case SPELL_HIBERNATION:</a>
<a name="ln3802">            if (foe.can_hibernate(false, true))</a>
<a name="ln3803">                return true;</a>
<a name="ln3804">            break;</a>
<a name="ln3805"> </a>
<a name="ln3806">        case SPELL_CONFUSE:</a>
<a name="ln3807">        case SPELL_MASS_CONFUSION:</a>
<a name="ln3808">        case SPELL_PARALYSE:</a>
<a name="ln3809">            return true;</a>
<a name="ln3810"> </a>
<a name="ln3811">        case SPELL_PETRIFY:</a>
<a name="ln3812">            if (foe.res_petrify())</a>
<a name="ln3813">                return true;</a>
<a name="ln3814">            break;</a>
<a name="ln3815"> </a>
<a name="ln3816">        default:</a>
<a name="ln3817">            break;</a>
<a name="ln3818">        }</a>
<a name="ln3819">    }</a>
<a name="ln3820"> </a>
<a name="ln3821">    return false;</a>
<a name="ln3822">}</a>
<a name="ln3823"> </a>
<a name="ln3824">static bool _mons_has_usable_ranged_weapon(const monster* mon)</a>
<a name="ln3825">{</a>
<a name="ln3826">    // Ugh.</a>
<a name="ln3827">    const item_def *weapon  = mon-&gt;launcher();</a>
<a name="ln3828">    const item_def *primary = mon-&gt;mslot_item(MSLOT_WEAPON);</a>
<a name="ln3829">    const item_def *missile = mon-&gt;missiles();</a>
<a name="ln3830"> </a>
<a name="ln3831">    // We don't have a usable ranged weapon if a different cursed weapon</a>
<a name="ln3832">    // is presently equipped.</a>
<a name="ln3833">    if (weapon != primary &amp;&amp; primary &amp;&amp; primary-&gt;cursed())</a>
<a name="ln3834">        return false;</a>
<a name="ln3835"> </a>
<a name="ln3836">    if (!missile)</a>
<a name="ln3837">        return false;</a>
<a name="ln3838"> </a>
<a name="ln3839">    return is_launched(mon, weapon, *missile) != launch_retval::FUMBLED;</a>
<a name="ln3840">}</a>
<a name="ln3841"> </a>
<a name="ln3842">static bool _mons_has_attack_wand(const monster&amp; mon)</a>
<a name="ln3843">{</a>
<a name="ln3844">    const item_def *wand = mon.mslot_item(MSLOT_WAND);</a>
<a name="ln3845"> </a>
<a name="ln3846">    return wand &amp;&amp; is_offensive_wand(*wand);</a>
<a name="ln3847">}</a>
<a name="ln3848"> </a>
<a name="ln3849">bool mons_has_ranged_attack(const monster&amp; mon)</a>
<a name="ln3850">{</a>
<a name="ln3851">    return mons_has_ranged_spell(mon, true)</a>
<a name="ln3852">           || _mons_has_usable_ranged_weapon(&amp;mon)</a>
<a name="ln3853">           || mon.reach_range() != REACH_NONE</a>
<a name="ln3854">           || _mons_has_attack_wand(mon);</a>
<a name="ln3855">}</a>
<a name="ln3856"> </a>
<a name="ln3857">bool mons_has_incapacitating_ranged_attack(const monster&amp; mon, const actor&amp; foe)</a>
<a name="ln3858">{</a>
<a name="ln3859">    if (!_mons_has_usable_ranged_weapon(&amp;mon))</a>
<a name="ln3860">        return false;</a>
<a name="ln3861"> </a>
<a name="ln3862">    const item_def *missile = mon.missiles();</a>
<a name="ln3863"> </a>
<a name="ln3864">    if (missile &amp;&amp; missile-&gt;sub_type == MI_THROWING_NET)</a>
<a name="ln3865">        return true;</a>
<a name="ln3866">    else if (missile &amp;&amp; missile-&gt;sub_type == MI_DART)</a>
<a name="ln3867">    {</a>
<a name="ln3868">        switch (get_ammo_brand(*missile))</a>
<a name="ln3869">        {</a>
<a name="ln3870">        // Not actually incapacitating, but marked as such so that</a>
<a name="ln3871">        // assassins will prefer using it while ammo remains</a>
<a name="ln3872">        case SPMSL_CURARE:</a>
<a name="ln3873">            if (foe.res_poison() &lt;= 0)</a>
<a name="ln3874">                return true;</a>
<a name="ln3875">            break;</a>
<a name="ln3876"> </a>
<a name="ln3877">        case SPMSL_BLINDING:</a>
<a name="ln3878">#if TAG_MAJOR_VERSION == 34</a>
<a name="ln3879">        case SPMSL_CONFUSION:</a>
<a name="ln3880">        case SPMSL_PARALYSIS:</a>
<a name="ln3881">#endif</a>
<a name="ln3882">            return true;</a>
<a name="ln3883"> </a>
<a name="ln3884">        default:</a>
<a name="ln3885">            break;</a>
<a name="ln3886">        }</a>
<a name="ln3887">    }</a>
<a name="ln3888"> </a>
<a name="ln3889">    return false;</a>
<a name="ln3890">}</a>
<a name="ln3891"> </a>
<a name="ln3892">bool mons_can_attack(const monster&amp; mon)</a>
<a name="ln3893">{</a>
<a name="ln3894">    const actor* foe = mon.get_foe();</a>
<a name="ln3895">    if (!foe || !mon.can_see(*foe))</a>
<a name="ln3896">        return false;</a>
<a name="ln3897"> </a>
<a name="ln3898">    if (mons_has_ranged_attack(mon) &amp;&amp; mon.see_cell_no_trans(foe-&gt;pos()))</a>
<a name="ln3899">        return true;</a>
<a name="ln3900"> </a>
<a name="ln3901">    return adjacent(mon.pos(), foe-&gt;pos());</a>
<a name="ln3902">}</a>
<a name="ln3903"> </a>
<a name="ln3904">/**</a>
<a name="ln3905"> * What gender are monsters of the given class?</a>
<a name="ln3906"> *</a>
<a name="ln3907"> * Used for pronoun selection.</a>
<a name="ln3908"> *</a>
<a name="ln3909"> * @param mc        The type of monster in question</a>
<a name="ln3910"> * @return          GENDER_NEUTER, _NEUTRAL, _FEMALE, or _MALE.</a>
<a name="ln3911"> */</a>
<a name="ln3912">gender_type mons_class_gender(monster_type mc)</a>
<a name="ln3913">{</a>
<a name="ln3914">    const bool female = mons_class_flag(mc, M_FEMALE);</a>
<a name="ln3915">    const bool male = mons_class_flag(mc, M_MALE);</a>
<a name="ln3916">    const bool neutral = mons_class_flag(mc, M_GENDER_NEUTRAL);</a>
<a name="ln3917">    ASSERT(male + female + neutral &lt;= 1);</a>
<a name="ln3918">    return male ? GENDER_MALE :</a>
<a name="ln3919">         female ? GENDER_FEMALE :</a>
<a name="ln3920">        neutral ? GENDER_NEUTRAL :</a>
<a name="ln3921">                  GENDER_NEUTER;</a>
<a name="ln3922">}</a>
<a name="ln3923"> </a>
<a name="ln3924">// Use of variant (upper-/lowercase is irrelevant here):</a>
<a name="ln3925">// PRONOUN_SUBJECTIVE : _She_ is tap dancing.</a>
<a name="ln3926">// PRONOUN_POSSESSIVE : _Its_ sword explodes!</a>
<a name="ln3927">// PRONOUN_REFLEXIVE  : The wizard mumbles to _herself_.</a>
<a name="ln3928">// PRONOUN_OBJECTIVE  : You miss _him_.</a>
<a name="ln3929">const char *mons_pronoun(monster_type mon_type, pronoun_type variant,</a>
<a name="ln3930">                         bool visible)</a>
<a name="ln3931">{</a>
<a name="ln3932">    const gender_type gender = !visible ? GENDER_NEUTER</a>
<a name="ln3933">                                        : mons_class_gender(mon_type);</a>
<a name="ln3934">    return decline_pronoun(gender, variant);</a>
<a name="ln3935">}</a>
<a name="ln3936"> </a>
<a name="ln3937">// XXX: this is awful and should not exist</a>
<a name="ln3938">static const spell_type smitey_spells[] = {</a>
<a name="ln3939">    SPELL_SMITING,</a>
<a name="ln3940">    SPELL_AIRSTRIKE,</a>
<a name="ln3941">    SPELL_SYMBOL_OF_TORMENT,</a>
<a name="ln3942">    SPELL_CALL_DOWN_DAMNATION,</a>
<a name="ln3943">    SPELL_FIRE_STORM,</a>
<a name="ln3944">    SPELL_SHATTER,</a>
<a name="ln3945">    SPELL_TORNADO,          // dubious</a>
<a name="ln3946">    SPELL_GLACIATE,         // dubious</a>
<a name="ln3947">    SPELL_OZOCUBUS_REFRIGERATION,</a>
<a name="ln3948">    SPELL_MASS_CONFUSION,</a>
<a name="ln3949">    SPELL_ENTROPIC_WEAVE,</a>
<a name="ln3950">};</a>
<a name="ln3951"> </a>
<a name="ln3952">/**</a>
<a name="ln3953"> * Does the given monster have spells that can damage without requiring LOF?</a>
<a name="ln3954"> *</a>
<a name="ln3955"> * Smitey (smite, airstrike), full-LOS (torment, refrigeration)...</a>
<a name="ln3956"> *</a>
<a name="ln3957"> * @param mon   The monster in question.</a>
<a name="ln3958"> * @return      Whether the given monster has 'smitey' effects.</a>
<a name="ln3959"> */</a>
<a name="ln3960">static bool _mons_has_smite_attack(const monster* mons)</a>
<a name="ln3961">{</a>
<a name="ln3962">    return any_of(begin(smitey_spells), end(smitey_spells),</a>
<a name="ln3963">                  [=] (spell_type sp) { return mons-&gt;has_spell(sp); });</a>
<a name="ln3964">}</a>
<a name="ln3965"> </a>
<a name="ln3966">/**</a>
<a name="ln3967"> * Is the given monster smart and pushy enough to displace other</a>
<a name="ln3968"> * monsters?</a>
<a name="ln3969"> *</a>
<a name="ln3970"> * A shover should not cause damage to the shovee by</a>
<a name="ln3971"> * displacing it, so monsters that trail clouds of badness are</a>
<a name="ln3972"> * ineligible. The shover should also benefit from shoving, so monsters</a>
<a name="ln3973"> * that can smite/torment are ineligible.</a>
<a name="ln3974"> *</a>
<a name="ln3975"> * @param m     The monster in question.</a>
<a name="ln3976"> * @return      Whether that monster is ever allowed to 'push' other monsters.</a>
<a name="ln3977"> */</a>
<a name="ln3978">bool monster_shover(const monster&amp; m)</a>
<a name="ln3979">{</a>
<a name="ln3980">    // Efreet and fire elementals are disqualified because they leave behind</a>
<a name="ln3981">    // clouds of flame. Curse toes are disqualified because they trail</a>
<a name="ln3982">    // clouds of miasma.</a>
<a name="ln3983">    if (mons_genus(m.type) == MONS_EFREET || m.type == MONS_FIRE_ELEMENTAL</a>
<a name="ln3984">        || m.type == MONS_CURSE_TOE)</a>
<a name="ln3985">    {</a>
<a name="ln3986">        return false;</a>
<a name="ln3987">    }</a>
<a name="ln3988"> </a>
<a name="ln3989">    // Monsters too stupid to use stairs (e.g. non-spectral zombified undead)</a>
<a name="ln3990">    // are also disqualified.</a>
<a name="ln3991">    // However, summons *can* push past pals &amp; cause trouble.</a>
<a name="ln3992">    // XXX: redundant with intelligence check?</a>
<a name="ln3993">    if (!mons_can_use_stairs(m) &amp;&amp; !m.is_summoned())</a>
<a name="ln3994">        return false;</a>
<a name="ln3995"> </a>
<a name="ln3996">    // Geryon really profits from *not* pushing past hell beasts.</a>
<a name="ln3997">    if (m.type == MONS_GERYON)</a>
<a name="ln3998">        return false;</a>
<a name="ln3999">    // Likewise, Robin and her mob.</a>
<a name="ln4000">    if (m.type == MONS_ROBIN)</a>
<a name="ln4001">        return false;</a>
<a name="ln4002"> </a>
<a name="ln4003">    // no mindless creatures pushing, aside from jellies, which just kind of ooze.</a>
<a name="ln4004">    return mons_intel(m) &gt; I_BRAINLESS || mons_genus(m.type) == MONS_JELLY;</a>
<a name="ln4005">}</a>
<a name="ln4006"> </a>
<a name="ln4007">/**</a>
<a name="ln4008"> * Is the first monster considered 'senior' to the second; that is, can it</a>
<a name="ln4009"> * 'push' (swap with) the latter?</a>
<a name="ln4010"> *</a>
<a name="ln4011"> * Generally, this is true if m1 and m2 are related, and m1 is higher up the</a>
<a name="ln4012"> * totem pole than m2.</a>
<a name="ln4013"> *</a>
<a name="ln4014"> * Not guaranteed to be transitive or symmetric, though it probably should be.</a>
<a name="ln4015"> *</a>
<a name="ln4016"> * @param m1        The potentially senior monster.</a>
<a name="ln4017"> * @param m2        The potentially junior monster.</a>
<a name="ln4018"> * @param fleeing   Whether the first monster is running away; relevant for</a>
<a name="ln4019"> *                  smiters pushing melee monsters out of the way.</a>
<a name="ln4020"> * @return          Whether m1 can push m2.</a>
<a name="ln4021"> */</a>
<a name="ln4022">bool monster_senior(const monster&amp; m1, const monster&amp; m2, bool fleeing)</a>
<a name="ln4023">{</a>
<a name="ln4024">    // non-fleeing smiters won't push past anything.</a>
<a name="ln4025">    if (_mons_has_smite_attack(&amp;m1) &amp;&amp; !fleeing)</a>
<a name="ln4026">        return false;</a>
<a name="ln4027"> </a>
<a name="ln4028">    // Fannar's ice beasts can push past Fannar, who benefits from this.</a>
<a name="ln4029">    if (m1.type == MONS_ICE_BEAST &amp;&amp; m2.type == MONS_FANNAR)</a>
<a name="ln4030">        return true;</a>
<a name="ln4031"> </a>
<a name="ln4032">    // Special-case spectral things to push past things that summon them</a>
<a name="ln4033">    // (revenants, ghost crabs).</a>
<a name="ln4034">    // XXX: unify this logic with Fannar's &amp; Geryon's? (summon-buddies?)</a>
<a name="ln4035">    if (m1.type == MONS_SPECTRAL_THING</a>
<a name="ln4036">        &amp;&amp; (m2.type == MONS_REVENANT || m2.type == MONS_GHOST_CRAB))</a>
<a name="ln4037">    {</a>
<a name="ln4038">        return true;</a>
<a name="ln4039">    }</a>
<a name="ln4040"> </a>
<a name="ln4041">    // Band leaders can displace followers regardless of type considerations.</a>
<a name="ln4042">    // -cao</a>
<a name="ln4043">    if (m2.props.exists(&quot;band_leader&quot;))</a>
<a name="ln4044">    {</a>
<a name="ln4045">        unsigned leader_mid = m2.props[&quot;band_leader&quot;].get_int();</a>
<a name="ln4046">        if (leader_mid == m1.mid)</a>
<a name="ln4047">            return true;</a>
<a name="ln4048">    }</a>
<a name="ln4049">    // And prevent followers to displace the leader to avoid constant swapping.</a>
<a name="ln4050">    else if (m1.props.exists(&quot;band_leader&quot;))</a>
<a name="ln4051">    {</a>
<a name="ln4052">        unsigned leader_mid = m1.props[&quot;band_leader&quot;].get_int();</a>
<a name="ln4053">        if (leader_mid == m2.mid)</a>
<a name="ln4054">            return false;</a>
<a name="ln4055">    }</a>
<a name="ln4056"> </a>
<a name="ln4057">    // Monsters smart enough to use stairs can push past monsters too stupid</a>
<a name="ln4058">    // to use stairs (so that e.g. non-zombified or spectral zombified undead</a>
<a name="ln4059">    // can push past non-spectral zombified undead).</a>
<a name="ln4060">    if (mons_class_can_use_stairs(m1.type)</a>
<a name="ln4061">        &amp;&amp; !mons_class_can_use_stairs(m2.type))</a>
<a name="ln4062">    {</a>
<a name="ln4063">        return true;</a>
<a name="ln4064">    }</a>
<a name="ln4065">    // This check assumes that demonicness is always carried at the monster type</a>
<a name="ln4066">    // level; this is because a full holiness check in such an often-called</a>
<a name="ln4067">    // function is costly.</a>
<a name="ln4068">    const bool related = mons_genus(m1.type) == mons_genus(m2.type)</a>
<a name="ln4069">                            || (   mons_class_holiness(m1.type) &amp; MH_DEMONIC</a>
<a name="ln4070">                                &amp;&amp; mons_class_holiness(m2.type) &amp; MH_DEMONIC);</a>
<a name="ln4071"> </a>
<a name="ln4072">    // Let all related monsters (all demons are 'related') push past ones that</a>
<a name="ln4073">    // are weaker at all. Unrelated ones have to be quite a bit stronger, to</a>
<a name="ln4074">    // reduce excessive swapping and because HD correlates only weakly with</a>
<a name="ln4075">    // monster strength.</a>
<a name="ln4076">    return related &amp;&amp; fleeing</a>
<a name="ln4077">           || related &amp;&amp; m1.get_hit_dice() &gt; m2.get_hit_dice()</a>
<a name="ln4078">           || m1.get_hit_dice() &gt; m2.get_hit_dice() + 5;</a>
<a name="ln4079">}</a>
<a name="ln4080"> </a>
<a name="ln4081">bool mons_class_can_pass(monster_type mc, const dungeon_feature_type grid)</a>
<a name="ln4082">{</a>
<a name="ln4083">    if (grid == DNGN_MALIGN_GATEWAY)</a>
<a name="ln4084">    {</a>
<a name="ln4085">        return mc == MONS_ELDRITCH_TENTACLE</a>
<a name="ln4086">               || mc == MONS_ELDRITCH_TENTACLE_SEGMENT;</a>
<a name="ln4087">    }</a>
<a name="ln4088"> </a>
<a name="ln4089">    return !feat_is_solid(grid);</a>
<a name="ln4090">}</a>
<a name="ln4091"> </a>
<a name="ln4092">static bool _mons_can_open_doors(const monster* mon)</a>
<a name="ln4093">{</a>
<a name="ln4094">    return mons_itemuse(*mon) &gt;= MONUSE_OPEN_DOORS;</a>
<a name="ln4095">}</a>
<a name="ln4096"> </a>
<a name="ln4097">// Some functions that check whether a monster can open/eat/pass a</a>
<a name="ln4098">// given door. These all return false if there's no closed door there.</a>
<a name="ln4099">bool mons_can_open_door(const monster&amp; mon, const coord_def&amp; pos)</a>
<a name="ln4100">{</a>
<a name="ln4101">    if (!_mons_can_open_doors(&amp;mon))</a>
<a name="ln4102">        return false;</a>
<a name="ln4103"> </a>
<a name="ln4104">    // Creatures allied with the player can't open doors.</a>
<a name="ln4105">    // (to prevent sabotaging the player accidentally.)</a>
<a name="ln4106">    if (mon.friendly())</a>
<a name="ln4107">        return false;</a>
<a name="ln4108"> </a>
<a name="ln4109">    if (env.markers.property_at(pos, MAT_ANY, &quot;door_restrict&quot;) == &quot;veto&quot;)</a>
<a name="ln4110">        return false;</a>
<a name="ln4111"> </a>
<a name="ln4112">    return true;</a>
<a name="ln4113">}</a>
<a name="ln4114"> </a>
<a name="ln4115">bool mons_can_eat_door(const monster&amp; mon, const coord_def&amp; pos)</a>
<a name="ln4116">{</a>
<a name="ln4117">    if (env.markers.property_at(pos, MAT_ANY, &quot;door_restrict&quot;) == &quot;veto&quot;)</a>
<a name="ln4118">        return false;</a>
<a name="ln4119"> </a>
<a name="ln4120">    return mons_eats_items(mon)</a>
<a name="ln4121">           || mons_class_flag(mons_base_type(mon), M_EAT_DOORS);</a>
<a name="ln4122">}</a>
<a name="ln4123"> </a>
<a name="ln4124">bool mons_can_destroy_door(const monster&amp; mon, const coord_def&amp; pos)</a>
<a name="ln4125">{</a>
<a name="ln4126">    if (!mons_class_flag(mons_base_type(mon), M_CRASH_DOORS))</a>
<a name="ln4127">        return false;</a>
<a name="ln4128"> </a>
<a name="ln4129">    if (env.markers.property_at(pos, MAT_ANY, &quot;door_restrict&quot;) == &quot;veto&quot;)</a>
<a name="ln4130">        return false;</a>
<a name="ln4131"> </a>
<a name="ln4132">    return true;</a>
<a name="ln4133">}</a>
<a name="ln4134"> </a>
<a name="ln4135">static bool _mons_can_pass_door(const monster* mon, const coord_def&amp; pos)</a>
<a name="ln4136">{</a>
<a name="ln4137">    return mon-&gt;can_pass_through_feat(DNGN_FLOOR)</a>
<a name="ln4138">           &amp;&amp; (mons_can_open_door(*mon, pos)</a>
<a name="ln4139">               || mons_can_eat_door(*mon, pos)</a>
<a name="ln4140">               || mons_can_destroy_door(*mon, pos));</a>
<a name="ln4141">}</a>
<a name="ln4142"> </a>
<a name="ln4143">bool mons_can_traverse(const monster&amp; mon, const coord_def&amp; p,</a>
<a name="ln4144">                       bool only_in_sight, bool checktraps)</a>
<a name="ln4145">{</a>
<a name="ln4146">    // Friendly summons should avoid pathing out of the player's sight</a>
<a name="ln4147">    // (especially as attempting this may make them ignore valid, but longer</a>
<a name="ln4148">    // paths).</a>
<a name="ln4149">    if (only_in_sight &amp;&amp; !you.see_cell_no_trans(p))</a>
<a name="ln4150">        return false;</a>
<a name="ln4151"> </a>
<a name="ln4152">    if (cell_is_runed(p))</a>
<a name="ln4153">        return false;</a>
<a name="ln4154"> </a>
<a name="ln4155">    // Includes sealed doors.</a>
<a name="ln4156">    if (feat_is_closed_door(grd(p)) &amp;&amp; _mons_can_pass_door(&amp;mon, p))</a>
<a name="ln4157">        return true;</a>
<a name="ln4158"> </a>
<a name="ln4159">    if (!mon.is_habitable(p))</a>
<a name="ln4160">        return false;</a>
<a name="ln4161"> </a>
<a name="ln4162">    return !checktraps || mon.is_trap_safe(p);</a>
<a name="ln4163">}</a>
<a name="ln4164"> </a>
<a name="ln4165">void mons_remove_from_grid(const monster&amp; mon)</a>
<a name="ln4166">{</a>
<a name="ln4167">    const coord_def pos = mon.pos();</a>
<a name="ln4168">    if (map_bounds(pos) &amp;&amp; mgrd(pos) == mon.mindex())</a>
<a name="ln4169">        mgrd(pos) = NON_MONSTER;</a>
<a name="ln4170">}</a>
<a name="ln4171"> </a>
<a name="ln4172">mon_inv_type equip_slot_to_mslot(equipment_type eq)</a>
<a name="ln4173">{</a>
<a name="ln4174">    switch (eq)</a>
<a name="ln4175">    {</a>
<a name="ln4176">    case EQ_WEAPON:      return MSLOT_WEAPON;</a>
<a name="ln4177">    case EQ_BODY_ARMOUR: return MSLOT_ARMOUR;</a>
<a name="ln4178">    case EQ_SHIELD:      return MSLOT_SHIELD;</a>
<a name="ln4179">    case EQ_RINGS:</a>
<a name="ln4180">    case EQ_AMULET:      return MSLOT_JEWELLERY;</a>
<a name="ln4181">    default: return NUM_MONSTER_SLOTS;</a>
<a name="ln4182">    }</a>
<a name="ln4183">}</a>
<a name="ln4184"> </a>
<a name="ln4185">mon_inv_type item_to_mslot(const item_def &amp;item)</a>
<a name="ln4186">{</a>
<a name="ln4187">    switch (item.base_type)</a>
<a name="ln4188">    {</a>
<a name="ln4189">    case OBJ_WEAPONS:</a>
<a name="ln4190">    case OBJ_STAVES:</a>
<a name="ln4191">#if TAG_MAJOR_VERSION == 34</a>
<a name="ln4192">    case OBJ_RODS:</a>
<a name="ln4193">#endif</a>
<a name="ln4194">        return MSLOT_WEAPON;</a>
<a name="ln4195">    case OBJ_MISSILES:</a>
<a name="ln4196">        return MSLOT_MISSILE;</a>
<a name="ln4197">    case OBJ_ARMOUR:</a>
<a name="ln4198">        return equip_slot_to_mslot(get_armour_slot(item));</a>
<a name="ln4199">    case OBJ_JEWELLERY:</a>
<a name="ln4200">        return MSLOT_JEWELLERY;</a>
<a name="ln4201">    case OBJ_WANDS:</a>
<a name="ln4202">        return MSLOT_WAND;</a>
<a name="ln4203">    case OBJ_BOOKS:</a>
<a name="ln4204">    case OBJ_SCROLLS:</a>
<a name="ln4205">        return MSLOT_SCROLL;</a>
<a name="ln4206">    case OBJ_POTIONS:</a>
<a name="ln4207">        return MSLOT_POTION;</a>
<a name="ln4208">    case OBJ_MISCELLANY:</a>
<a name="ln4209">        return MSLOT_MISCELLANY;</a>
<a name="ln4210">    case OBJ_GOLD:</a>
<a name="ln4211">        return MSLOT_GOLD;</a>
<a name="ln4212">    default:</a>
<a name="ln4213">        return NUM_MONSTER_SLOTS;</a>
<a name="ln4214">    }</a>
<a name="ln4215">}</a>
<a name="ln4216"> </a>
<a name="ln4217">monster_type royal_jelly_ejectable_monster()</a>
<a name="ln4218">{</a>
<a name="ln4219">    return random_choose(MONS_ACID_BLOB, MONS_AZURE_JELLY, MONS_DEATH_OOZE);</a>
<a name="ln4220">}</a>
<a name="ln4221"> </a>
<a name="ln4222">// Replaces @foe_god@ and @god_is@ with foe's god name.</a>
<a name="ln4223">//</a>
<a name="ln4224">// Atheists get &quot;You&quot;/&quot;you&quot;, and worshippers of nameless gods get &quot;Your</a>
<a name="ln4225">// god&quot;/&quot;your god&quot;.</a>
<a name="ln4226">static string _replace_god_name(god_type god, bool need_verb = false,</a>
<a name="ln4227">                                bool capital = false)</a>
<a name="ln4228">{</a>
<a name="ln4229">    string result;</a>
<a name="ln4230"> </a>
<a name="ln4231">    if (god == GOD_NO_GOD)</a>
<a name="ln4232">        result = capital ? &quot;You&quot; : &quot;you&quot;;</a>
<a name="ln4233">    else if (god == GOD_NAMELESS)</a>
<a name="ln4234">        result = capital ? &quot;Your god&quot; : &quot;your god&quot;;</a>
<a name="ln4235">    else</a>
<a name="ln4236">    {</a>
<a name="ln4237">        const string godname = god_name(god, false);</a>
<a name="ln4238">        result = capital ? uppercase_first(godname) : godname;</a>
<a name="ln4239">    }</a>
<a name="ln4240"> </a>
<a name="ln4241">    if (need_verb)</a>
<a name="ln4242">    {</a>
<a name="ln4243">        result += ' ';</a>
<a name="ln4244">        result += conjugate_verb(&quot;be&quot;, god == GOD_NO_GOD);</a>
<a name="ln4245">    }</a>
<a name="ln4246"> </a>
<a name="ln4247">    return result;</a>
<a name="ln4248">}</a>
<a name="ln4249"> </a>
<a name="ln4250">static string _get_species_insult(const string &amp;species, const string &amp;type)</a>
<a name="ln4251">{</a>
<a name="ln4252">    string insult;</a>
<a name="ln4253">    string lookup;</a>
<a name="ln4254"> </a>
<a name="ln4255">    // Get species genus.</a>
<a name="ln4256">    if (!species.empty())</a>
<a name="ln4257">    {</a>
<a name="ln4258">        lookup  = &quot;insult &quot;;</a>
<a name="ln4259">        lookup += species;</a>
<a name="ln4260">        lookup += &quot; &quot;;</a>
<a name="ln4261">        lookup += type;</a>
<a name="ln4262"> </a>
<a name="ln4263">        insult  = getSpeakString(lowercase(lookup));</a>
<a name="ln4264">    }</a>
<a name="ln4265"> </a>
<a name="ln4266">    if (insult.empty()) // Species too specific?</a>
<a name="ln4267">    {</a>
<a name="ln4268">        lookup  = &quot;insult general &quot;;</a>
<a name="ln4269">        lookup += type;</a>
<a name="ln4270"> </a>
<a name="ln4271">        insult  = getSpeakString(lookup);</a>
<a name="ln4272">    }</a>
<a name="ln4273"> </a>
<a name="ln4274">    return insult;</a>
<a name="ln4275">}</a>
<a name="ln4276"> </a>
<a name="ln4277">// From should be of the form &quot;prefix @tag@&quot;. Replaces all substrings</a>
<a name="ln4278">// of the form &quot;prefix @tag@&quot; with to, and all strings of the form</a>
<a name="ln4279">// &quot;prefix @tag/alt@&quot; with either to (if nonempty) or &quot;prefix alt&quot;.</a>
<a name="ln4280">static string _replace_speech_tag(string msg, string from, const string &amp;to)</a>
<a name="ln4281">{</a>
<a name="ln4282">    if (from.empty())</a>
<a name="ln4283">        return msg;</a>
<a name="ln4284">    msg = replace_all(msg, from, to);</a>
<a name="ln4285"> </a>
<a name="ln4286">    // Change the @ to a / for the next search</a>
<a name="ln4287">    from[from.size() - 1] = '/';</a>
<a name="ln4288"> </a>
<a name="ln4289">    // @tag/alternative@</a>
<a name="ln4290">    size_t pos = 0;</a>
<a name="ln4291">    while ((pos = msg.find(from, pos)) != string::npos)</a>
<a name="ln4292">    {</a>
<a name="ln4293">        // beginning of tag</a>
<a name="ln4294">        const size_t at_pos = msg.find('@', pos);</a>
<a name="ln4295">        // beginning of alternative</a>
<a name="ln4296">        const size_t alt_pos = pos + from.size();</a>
<a name="ln4297">        // end of tag (one-past-the-end of alternative)</a>
<a name="ln4298">        const size_t alt_end = msg.find('@', alt_pos);</a>
<a name="ln4299"> </a>
<a name="ln4300">        // unclosed @tag/alt, or &quot;from&quot; has no @: leave it alone.</a>
<a name="ln4301">        if (alt_end == string::npos || at_pos == string::npos)</a>
<a name="ln4302">            break;</a>
<a name="ln4303"> </a>
<a name="ln4304">        if (to.empty())</a>
<a name="ln4305">        {</a>
<a name="ln4306">            // Replace only the @...@ part.</a>
<a name="ln4307">            msg.replace(at_pos, alt_end - at_pos + 1,</a>
<a name="ln4308">                        msg.substr(alt_pos, alt_end - alt_pos));</a>
<a name="ln4309">            pos = at_pos + (alt_end - alt_pos);</a>
<a name="ln4310">        }</a>
<a name="ln4311">        else</a>
<a name="ln4312">        {</a>
<a name="ln4313">            // Replace the whole from string, up to the second @</a>
<a name="ln4314">            msg.replace(pos, alt_end - pos + 1, to);</a>
<a name="ln4315">            pos += to.size();</a>
<a name="ln4316">        }</a>
<a name="ln4317">    }</a>
<a name="ln4318">    return msg;</a>
<a name="ln4319">}</a>
<a name="ln4320"> </a>
<a name="ln4321">// Replaces the &quot;@foo@&quot; strings in monster shout and monster speak</a>
<a name="ln4322">// definitions.</a>
<a name="ln4323">string do_mon_str_replacements(const string &amp;in_msg, const monster&amp; mons,</a>
<a name="ln4324">                               int s_type)</a>
<a name="ln4325">{</a>
<a name="ln4326">    string msg = in_msg;</a>
<a name="ln4327"> </a>
<a name="ln4328">    const actor* foe = (mons.wont_attack()</a>
<a name="ln4329">                          &amp;&amp; invalid_monster_index(mons.foe)) ?</a>
<a name="ln4330">                             &amp;you : mons.get_foe();</a>
<a name="ln4331"> </a>
<a name="ln4332">    if (s_type &lt; 0 || s_type &gt;= NUM_LOUDNESS || s_type == NUM_SHOUTS)</a>
<a name="ln4333">        s_type = mons_shouts(mons.type);</a>
<a name="ln4334"> </a>
<a name="ln4335">    msg = maybe_pick_random_substring(msg);</a>
<a name="ln4336"> </a>
<a name="ln4337">    // FIXME: Handle player_genus in case it was not generalised to foe_genus.</a>
<a name="ln4338">    msg = replace_all(msg, &quot;@a_player_genus@&quot;,</a>
<a name="ln4339">                      article_a(species_name(you.species, SPNAME_GENUS)));</a>
<a name="ln4340">    msg = replace_all(msg, &quot;@player_genus@&quot;, species_name(you.species, SPNAME_GENUS));</a>
<a name="ln4341">    msg = replace_all(msg, &quot;@player_genus_plural@&quot;, pluralise(species_name(you.species, SPNAME_GENUS)));</a>
<a name="ln4342"> </a>
<a name="ln4343">    string foe_genus;</a>
<a name="ln4344"> </a>
<a name="ln4345">    if (foe == nullptr)</a>
<a name="ln4346">        ;</a>
<a name="ln4347">    else if (foe-&gt;is_player())</a>
<a name="ln4348">    {</a>
<a name="ln4349">        foe_genus = species_name(you.species, SPNAME_GENUS);</a>
<a name="ln4350"> </a>
<a name="ln4351">        msg = _replace_speech_tag(msg, &quot; @to_foe@&quot;, &quot;&quot;);</a>
<a name="ln4352">        msg = _replace_speech_tag(msg, &quot; @at_foe@&quot;, &quot;&quot;);</a>
<a name="ln4353"> </a>
<a name="ln4354">        msg = _replace_speech_tag(msg, &quot; @to_foe@&quot;, &quot;&quot;);</a>
<a name="ln4355">        msg = _replace_speech_tag(msg, &quot; @at_foe@&quot;, &quot;&quot;);</a>
<a name="ln4356"> </a>
<a name="ln4357">        msg = replace_all(msg, &quot;@player_only@&quot;, &quot;&quot;);</a>
<a name="ln4358">        msg = replace_all(msg, &quot; @foe,@&quot;, &quot;,&quot;);</a>
<a name="ln4359"> </a>
<a name="ln4360">        msg = replace_all(msg, &quot;@player&quot;, &quot;@foe&quot;);</a>
<a name="ln4361">        msg = replace_all(msg, &quot;@Player&quot;, &quot;@Foe&quot;);</a>
<a name="ln4362"> </a>
<a name="ln4363">        msg = replace_all(msg, &quot;@foe_possessive@&quot;, &quot;your&quot;);</a>
<a name="ln4364">        msg = replace_all(msg, &quot;@foe@&quot;, &quot;you&quot;);</a>
<a name="ln4365">        msg = replace_all(msg, &quot;@Foe@&quot;, &quot;You&quot;);</a>
<a name="ln4366"> </a>
<a name="ln4367">        msg = replace_all(msg, &quot;@foe_name@&quot;, you.your_name);</a>
<a name="ln4368">        msg = replace_all(msg, &quot;@foe_species@&quot;, species_name(you.species));</a>
<a name="ln4369">        msg = replace_all(msg, &quot;@foe_genus@&quot;, foe_genus);</a>
<a name="ln4370">        msg = replace_all(msg, &quot;@Foe_genus@&quot;, uppercase_first(foe_genus));</a>
<a name="ln4371">        msg = replace_all(msg, &quot;@foe_genus_plural@&quot;,</a>
<a name="ln4372">                          pluralise(foe_genus));</a>
<a name="ln4373">    }</a>
<a name="ln4374">    else</a>
<a name="ln4375">    {</a>
<a name="ln4376">        string foe_name;</a>
<a name="ln4377">        const monster* m_foe = foe-&gt;as_monster();</a>
<a name="ln4378">        if (m_foe-&gt;attitude == ATT_FRIENDLY</a>
<a name="ln4379">            &amp;&amp; !mons_is_unique(m_foe-&gt;type)</a>
<a name="ln4380">            &amp;&amp; !crawl_state.game_is_arena())</a>
<a name="ln4381">        {</a>
<a name="ln4382">            foe_name = foe-&gt;name(DESC_YOUR);</a>
<a name="ln4383">            const string::size_type pos = foe_name.find(&quot;'&quot;);</a>
<a name="ln4384">            if (pos != string::npos)</a>
<a name="ln4385">                foe_name = foe_name.substr(0, pos);</a>
<a name="ln4386">        }</a>
<a name="ln4387">        else</a>
<a name="ln4388">            foe_name = foe-&gt;name(DESC_THE);</a>
<a name="ln4389"> </a>
<a name="ln4390">        string prep = &quot;at&quot;;</a>
<a name="ln4391">        if (s_type == S_SILENT || s_type == S_SHOUT || s_type == S_NORMAL)</a>
<a name="ln4392">            prep = &quot;to&quot;;</a>
<a name="ln4393">        msg = replace_all(msg, &quot;@says@ @to_foe@&quot;, &quot;@says@ &quot; + prep + &quot; @foe@&quot;);</a>
<a name="ln4394"> </a>
<a name="ln4395">        msg = _replace_speech_tag(msg, &quot; @to_foe@&quot;, &quot; to @foe@&quot;);</a>
<a name="ln4396">        msg = _replace_speech_tag(msg, &quot; @at_foe@&quot;, &quot; at @foe@&quot;);</a>
<a name="ln4397"> </a>
<a name="ln4398">        msg = replace_all(msg, &quot;@foe,@&quot;, &quot;@foe@,&quot;);</a>
<a name="ln4399">        msg = replace_all(msg, &quot;@foe_possessive@&quot;, &quot;@foe@'s&quot;);</a>
<a name="ln4400">        msg = replace_all(msg, &quot;@foe@&quot;, foe_name);</a>
<a name="ln4401">        msg = replace_all(msg, &quot;@Foe@&quot;, uppercase_first(foe_name));</a>
<a name="ln4402"> </a>
<a name="ln4403">        if (m_foe-&gt;is_named())</a>
<a name="ln4404">            msg = replace_all(msg, &quot;@foe_name@&quot;, foe-&gt;name(DESC_PLAIN, true));</a>
<a name="ln4405"> </a>
<a name="ln4406">        string species = mons_type_name(mons_species(m_foe-&gt;type), DESC_PLAIN);</a>
<a name="ln4407"> </a>
<a name="ln4408">        msg = replace_all(msg, &quot;@foe_species@&quot;, species);</a>
<a name="ln4409"> </a>
<a name="ln4410">        foe_genus = mons_type_name(mons_genus(m_foe-&gt;type), DESC_PLAIN);</a>
<a name="ln4411"> </a>
<a name="ln4412">        msg = replace_all(msg, &quot;@foe_genus@&quot;, foe_genus);</a>
<a name="ln4413">        msg = replace_all(msg, &quot;@Foe_genus@&quot;, uppercase_first(foe_genus));</a>
<a name="ln4414">        msg = replace_all(msg, &quot;@foe_genus_plural@&quot;, pluralise(foe_genus));</a>
<a name="ln4415">    }</a>
<a name="ln4416"> </a>
<a name="ln4417">    description_level_type nocap = DESC_THE, cap = DESC_THE;</a>
<a name="ln4418"> </a>
<a name="ln4419">    if (mons.is_named() &amp;&amp; you.can_see(mons))</a>
<a name="ln4420">    {</a>
<a name="ln4421">        const string name = mons.name(DESC_THE);</a>
<a name="ln4422"> </a>
<a name="ln4423">        msg = replace_all(msg, &quot;@the_something@&quot;, name);</a>
<a name="ln4424">        msg = replace_all(msg, &quot;@The_something@&quot;, name);</a>
<a name="ln4425">        msg = replace_all(msg, &quot;@the_monster@&quot;,   name);</a>
<a name="ln4426">        msg = replace_all(msg, &quot;@The_monster@&quot;,   name);</a>
<a name="ln4427">    }</a>
<a name="ln4428">    else if (mons.attitude == ATT_FRIENDLY</a>
<a name="ln4429">             &amp;&amp; !mons_is_unique(mons.type)</a>
<a name="ln4430">             &amp;&amp; !crawl_state.game_is_arena()</a>
<a name="ln4431">             &amp;&amp; you.can_see(mons))</a>
<a name="ln4432">    {</a>
<a name="ln4433">        nocap = DESC_PLAIN;</a>
<a name="ln4434">        cap   = DESC_PLAIN;</a>
<a name="ln4435"> </a>
<a name="ln4436">        msg = replace_all(msg, &quot;@the_something@&quot;, &quot;your @the_something@&quot;);</a>
<a name="ln4437">        msg = replace_all(msg, &quot;@The_something@&quot;, &quot;Your @The_something@&quot;);</a>
<a name="ln4438">        msg = replace_all(msg, &quot;@the_monster@&quot;,   &quot;your @the_monster@&quot;);</a>
<a name="ln4439">        msg = replace_all(msg, &quot;@The_monster@&quot;,   &quot;Your @the_monster@&quot;);</a>
<a name="ln4440">    }</a>
<a name="ln4441"> </a>
<a name="ln4442">    if (you.see_cell(mons.pos()))</a>
<a name="ln4443">    {</a>
<a name="ln4444">        dungeon_feature_type feat = grd(mons.pos());</a>
<a name="ln4445">        if (feat_is_solid(feat) || feat &gt;= NUM_FEATURES)</a>
<a name="ln4446">            msg = replace_all(msg, &quot;@surface@&quot;, &quot;buggy surface&quot;);</a>
<a name="ln4447">        else if (feat == DNGN_LAVA)</a>
<a name="ln4448">            msg = replace_all(msg, &quot;@surface@&quot;, &quot;lava&quot;);</a>
<a name="ln4449">        else if (feat_is_water(feat))</a>
<a name="ln4450">            msg = replace_all(msg, &quot;@surface@&quot;, &quot;water&quot;);</a>
<a name="ln4451">        else if (feat_is_altar(feat))</a>
<a name="ln4452">            msg = replace_all(msg, &quot;@surface@&quot;, &quot;altar&quot;);</a>
<a name="ln4453">        else</a>
<a name="ln4454">            msg = replace_all(msg, &quot;@surface@&quot;, &quot;ground&quot;);</a>
<a name="ln4455"> </a>
<a name="ln4456">        msg = replace_all(msg, &quot;@feature@&quot;, raw_feature_description(mons.pos()));</a>
<a name="ln4457">    }</a>
<a name="ln4458">    else</a>
<a name="ln4459">    {</a>
<a name="ln4460">        msg = replace_all(msg, &quot;@surface@&quot;, &quot;buggy unseen surface&quot;);</a>
<a name="ln4461">        msg = replace_all(msg, &quot;@feature@&quot;, &quot;buggy unseen feature&quot;);</a>
<a name="ln4462">    }</a>
<a name="ln4463"> </a>
<a name="ln4464">    string something = mons.name(DESC_PLAIN);</a>
<a name="ln4465">    msg = replace_all(msg, &quot;@something@&quot;,   something);</a>
<a name="ln4466">    msg = replace_all(msg, &quot;@a_something@&quot;, mons.name(DESC_A));</a>
<a name="ln4467">    msg = replace_all(msg, &quot;@the_something@&quot;, mons.name(nocap));</a>
<a name="ln4468"> </a>
<a name="ln4469">    something[0] = toupper_safe(something[0]);</a>
<a name="ln4470">    msg = replace_all(msg, &quot;@Something@&quot;,   something);</a>
<a name="ln4471">    msg = replace_all(msg, &quot;@A_something@&quot;, mons.name(DESC_A));</a>
<a name="ln4472">    msg = replace_all(msg, &quot;@The_something@&quot;, mons.name(cap));</a>
<a name="ln4473"> </a>
<a name="ln4474">    // Player name.</a>
<a name="ln4475">    msg = replace_all(msg, &quot;@player_name@&quot;, you.your_name);</a>
<a name="ln4476"> </a>
<a name="ln4477">    string plain = mons.name(DESC_PLAIN);</a>
<a name="ln4478">    msg = replace_all(msg, &quot;@monster@&quot;,     plain);</a>
<a name="ln4479">    msg = replace_all(msg, &quot;@a_monster@&quot;,   mons.name(DESC_A));</a>
<a name="ln4480">    msg = replace_all(msg, &quot;@the_monster@&quot;, mons.name(nocap));</a>
<a name="ln4481"> </a>
<a name="ln4482">    plain[0] = toupper_safe(plain[0]);</a>
<a name="ln4483">    msg = replace_all(msg, &quot;@Monster@&quot;,     plain);</a>
<a name="ln4484">    msg = replace_all(msg, &quot;@A_monster@&quot;,   mons.name(DESC_A));</a>
<a name="ln4485">    msg = replace_all(msg, &quot;@The_monster@&quot;, mons.name(cap));</a>
<a name="ln4486"> </a>
<a name="ln4487">    msg = replace_all(msg, &quot;@Subjective@&quot;,</a>
<a name="ln4488">                      mons.pronoun(PRONOUN_SUBJECTIVE));</a>
<a name="ln4489">    msg = replace_all(msg, &quot;@subjective@&quot;,</a>
<a name="ln4490">                      mons.pronoun(PRONOUN_SUBJECTIVE));</a>
<a name="ln4491">    msg = replace_all(msg, &quot;@Possessive@&quot;,</a>
<a name="ln4492">                      mons.pronoun(PRONOUN_POSSESSIVE));</a>
<a name="ln4493">    msg = replace_all(msg, &quot;@possessive@&quot;,</a>
<a name="ln4494">                      mons.pronoun(PRONOUN_POSSESSIVE));</a>
<a name="ln4495">    msg = replace_all(msg, &quot;@reflexive@&quot;,</a>
<a name="ln4496">                      mons.pronoun(PRONOUN_REFLEXIVE));</a>
<a name="ln4497">    msg = replace_all(msg, &quot;@objective@&quot;,</a>
<a name="ln4498">                      mons.pronoun(PRONOUN_OBJECTIVE));</a>
<a name="ln4499"> </a>
<a name="ln4500">    // Body parts.</a>
<a name="ln4501">    bool   can_plural = false;</a>
<a name="ln4502">    string part_str   = mons.hand_name(false, &amp;can_plural);</a>
<a name="ln4503"> </a>
<a name="ln4504">    msg = replace_all(msg, &quot;@hand@&quot;, part_str);</a>
<a name="ln4505">    msg = replace_all(msg, &quot;@Hand@&quot;, uppercase_first(part_str));</a>
<a name="ln4506"> </a>
<a name="ln4507">    if (!can_plural)</a>
<a name="ln4508">        part_str = &quot;NO PLURAL HANDS&quot;;</a>
<a name="ln4509">    else</a>
<a name="ln4510">        part_str = mons.hand_name(true);</a>
<a name="ln4511"> </a>
<a name="ln4512">    msg = replace_all(msg, &quot;@hands@&quot;, part_str);</a>
<a name="ln4513">    msg = replace_all(msg, &quot;@Hands@&quot;, uppercase_first(part_str));</a>
<a name="ln4514"> </a>
<a name="ln4515">    can_plural = false;</a>
<a name="ln4516">    part_str   = mons.arm_name(false, &amp;can_plural);</a>
<a name="ln4517"> </a>
<a name="ln4518">    msg = replace_all(msg, &quot;@arm@&quot;, part_str);</a>
<a name="ln4519">    msg = replace_all(msg, &quot;@Arm@&quot;, uppercase_first(part_str));</a>
<a name="ln4520"> </a>
<a name="ln4521">    if (!can_plural)</a>
<a name="ln4522">        part_str = &quot;NO PLURAL ARMS&quot;;</a>
<a name="ln4523">    else</a>
<a name="ln4524">        part_str = mons.arm_name(true);</a>
<a name="ln4525"> </a>
<a name="ln4526">    msg = replace_all(msg, &quot;@arms@&quot;, part_str);</a>
<a name="ln4527">    msg = replace_all(msg, &quot;@Arms@&quot;, uppercase_first(part_str));</a>
<a name="ln4528"> </a>
<a name="ln4529">    can_plural = false;</a>
<a name="ln4530">    part_str   = mons.foot_name(false, &amp;can_plural);</a>
<a name="ln4531"> </a>
<a name="ln4532">    msg = replace_all(msg, &quot;@foot@&quot;, part_str);</a>
<a name="ln4533">    msg = replace_all(msg, &quot;@Foot@&quot;, uppercase_first(part_str));</a>
<a name="ln4534"> </a>
<a name="ln4535">    if (!can_plural)</a>
<a name="ln4536">        part_str = &quot;NO PLURAL FEET&quot;;</a>
<a name="ln4537">    else</a>
<a name="ln4538">        part_str = mons.foot_name(true);</a>
<a name="ln4539"> </a>
<a name="ln4540">    msg = replace_all(msg, &quot;@feet@&quot;, part_str);</a>
<a name="ln4541">    msg = replace_all(msg, &quot;@Feet@&quot;, uppercase_first(part_str));</a>
<a name="ln4542"> </a>
<a name="ln4543">    if (foe != nullptr)</a>
<a name="ln4544">    {</a>
<a name="ln4545">        const god_type god = foe-&gt;deity();</a>
<a name="ln4546"> </a>
<a name="ln4547">        // Replace with &quot;you are&quot; for atheists.</a>
<a name="ln4548">        msg = replace_all(msg, &quot;@god_is@&quot;,</a>
<a name="ln4549">                          _replace_god_name(god, true, false));</a>
<a name="ln4550">        msg = replace_all(msg, &quot;@God_is@&quot;, _replace_god_name(god, true, true));</a>
<a name="ln4551"> </a>
<a name="ln4552">        // No verb needed.</a>
<a name="ln4553">        msg = replace_all(msg, &quot;@foe_god@&quot;,</a>
<a name="ln4554">                          _replace_god_name(god, false, false));</a>
<a name="ln4555">        msg = replace_all(msg, &quot;@Foe_god@&quot;,</a>
<a name="ln4556">                          _replace_god_name(god, false, true));</a>
<a name="ln4557">    }</a>
<a name="ln4558"> </a>
<a name="ln4559">    // The monster's god, not the player's. Atheists get</a>
<a name="ln4560">    // &quot;NO GOD&quot;/&quot;NO GOD&quot;/&quot;NO_GOD&quot;/&quot;NO_GOD&quot;, and worshippers of nameless</a>
<a name="ln4561">    // gods get &quot;a god&quot;/&quot;its god/my God/My God&quot;.</a>
<a name="ln4562">    //</a>
<a name="ln4563">    // XXX: Crawl currently has no first-person possessive pronoun;</a>
<a name="ln4564">    // if it gets one, it should be used for the last two entries.</a>
<a name="ln4565">    if (mons.god == GOD_NO_GOD)</a>
<a name="ln4566">    {</a>
<a name="ln4567">        msg = replace_all(msg, &quot;@a_God@&quot;, &quot;NO GOD&quot;);</a>
<a name="ln4568">        msg = replace_all(msg, &quot;@A_God@&quot;, &quot;NO GOD&quot;);</a>
<a name="ln4569">        msg = replace_all(msg, &quot;@possessive_God@&quot;, &quot;NO GOD&quot;);</a>
<a name="ln4570">        msg = replace_all(msg, &quot;@Possessive_God@&quot;, &quot;NO GOD&quot;);</a>
<a name="ln4571"> </a>
<a name="ln4572">        msg = replace_all(msg, &quot;@my_God@&quot;, &quot;NO GOD&quot;);</a>
<a name="ln4573">        msg = replace_all(msg, &quot;@My_God@&quot;, &quot;NO GOD&quot;);</a>
<a name="ln4574">    }</a>
<a name="ln4575">    else if (mons.god == GOD_NAMELESS)</a>
<a name="ln4576">    {</a>
<a name="ln4577">        msg = replace_all(msg, &quot;@a_God@&quot;, &quot;a god&quot;);</a>
<a name="ln4578">        msg = replace_all(msg, &quot;@A_God@&quot;, &quot;A god&quot;);</a>
<a name="ln4579">        const string possessive = mons.pronoun(PRONOUN_POSSESSIVE) + &quot; god&quot;;</a>
<a name="ln4580">        msg = replace_all(msg, &quot;@possessive_God@&quot;, possessive);</a>
<a name="ln4581">        msg = replace_all(msg, &quot;@Possessive_God@&quot;, uppercase_first(possessive));</a>
<a name="ln4582"> </a>
<a name="ln4583">        msg = replace_all(msg, &quot;@my_God@&quot;, &quot;my God&quot;);</a>
<a name="ln4584">        msg = replace_all(msg, &quot;@My_God@&quot;, &quot;My God&quot;);</a>
<a name="ln4585">    }</a>
<a name="ln4586">    else</a>
<a name="ln4587">    {</a>
<a name="ln4588">        const string godname = god_name(mons.god);</a>
<a name="ln4589">        const string godcap = uppercase_first(godname);</a>
<a name="ln4590">        msg = replace_all(msg, &quot;@a_God@&quot;, godname);</a>
<a name="ln4591">        msg = replace_all(msg, &quot;@A_God@&quot;, godcap);</a>
<a name="ln4592">        msg = replace_all(msg, &quot;@possessive_God@&quot;, godname);</a>
<a name="ln4593">        msg = replace_all(msg, &quot;@Possessive_God@&quot;, godcap);</a>
<a name="ln4594"> </a>
<a name="ln4595">        msg = replace_all(msg, &quot;@my_God@&quot;, godname);</a>
<a name="ln4596">        msg = replace_all(msg, &quot;@My_God@&quot;, godcap);</a>
<a name="ln4597">    }</a>
<a name="ln4598"> </a>
<a name="ln4599">    // Replace with species specific insults.</a>
<a name="ln4600">    if (msg.find(&quot;@species_insult_&quot;) != string::npos)</a>
<a name="ln4601">    {</a>
<a name="ln4602">        msg = replace_all(msg, &quot;@species_insult_adj1@&quot;,</a>
<a name="ln4603">                               _get_species_insult(foe_genus, &quot;adj1&quot;));</a>
<a name="ln4604">        msg = replace_all(msg, &quot;@species_insult_adj2@&quot;,</a>
<a name="ln4605">                               _get_species_insult(foe_genus, &quot;adj2&quot;));</a>
<a name="ln4606">        msg = replace_all(msg, &quot;@species_insult_noun@&quot;,</a>
<a name="ln4607">                               _get_species_insult(foe_genus, &quot;noun&quot;));</a>
<a name="ln4608">    }</a>
<a name="ln4609"> </a>
<a name="ln4610">    static const char * sound_list[] =</a>
<a name="ln4611">    {</a>
<a name="ln4612">        &quot;says&quot;,         // actually S_SILENT</a>
<a name="ln4613">        &quot;shouts&quot;,</a>
<a name="ln4614">        &quot;barks&quot;,</a>
<a name="ln4615">        &quot;howls&quot;,</a>
<a name="ln4616">        &quot;shouts&quot;,</a>
<a name="ln4617">        &quot;roars&quot;,</a>
<a name="ln4618">        &quot;screams&quot;,</a>
<a name="ln4619">        &quot;bellows&quot;,</a>
<a name="ln4620">        &quot;bleats&quot;,</a>
<a name="ln4621">        &quot;trumpets&quot;,</a>
<a name="ln4622">        &quot;screeches&quot;,</a>
<a name="ln4623">        &quot;buzzes&quot;,</a>
<a name="ln4624">        &quot;moans&quot;,</a>
<a name="ln4625">        &quot;gurgles&quot;,</a>
<a name="ln4626">        &quot;croaks&quot;,</a>
<a name="ln4627">        &quot;growls&quot;,</a>
<a name="ln4628">        &quot;hisses&quot;,</a>
<a name="ln4629">        &quot;sneers&quot;,       // S_DEMON_TAUNT</a>
<a name="ln4630">        &quot;says&quot;,         // S_CHERUB -- they just speak normally.</a>
<a name="ln4631">        &quot;squeals&quot;,</a>
<a name="ln4632">        &quot;roars&quot;,</a>
<a name="ln4633">        &quot;buggily says&quot;, // NUM_SHOUTS</a>
<a name="ln4634">        &quot;breathes&quot;,     // S_VERY_SOFT</a>
<a name="ln4635">        &quot;whispers&quot;,     // S_SOFT</a>
<a name="ln4636">        &quot;says&quot;,         // S_NORMAL</a>
<a name="ln4637">        &quot;shouts&quot;,       // S_LOUD</a>
<a name="ln4638">        &quot;screams&quot;,      // S_VERY_LOUD</a>
<a name="ln4639">    };</a>
<a name="ln4640">    COMPILE_CHECK(ARRAYSZ(sound_list) == NUM_LOUDNESS);</a>
<a name="ln4641"> </a>
<a name="ln4642">    if (s_type &lt; 0 || s_type &gt;= NUM_LOUDNESS || s_type == NUM_SHOUTS)</a>
<a name="ln4643">    {</a>
<a name="ln4644">        mprf(MSGCH_DIAGNOSTICS, &quot;Invalid @says@ type.&quot;);</a>
<a name="ln4645">        msg = replace_all(msg, &quot;@says@&quot;, &quot;buggily says&quot;);</a>
<a name="ln4646">    }</a>
<a name="ln4647">    else</a>
<a name="ln4648">        msg = replace_all(msg, &quot;@says@&quot;, sound_list[s_type]);</a>
<a name="ln4649"> </a>
<a name="ln4650">    msg = maybe_capitalise_substring(msg);</a>
<a name="ln4651"> </a>
<a name="ln4652">    return msg;</a>
<a name="ln4653">}</a>
<a name="ln4654"> </a>
<a name="ln4655">/**</a>
<a name="ln4656"> * Get the monster body shape of the given monster.</a>
<a name="ln4657"> * @param mon  The monster in question.</a>
<a name="ln4658"> * @return     The mon_body_shape type of this monster.</a>
<a name="ln4659"> */</a>
<a name="ln4660">mon_body_shape get_mon_shape(const monster&amp; mon)</a>
<a name="ln4661">{</a>
<a name="ln4662">    monster_type base_type;</a>
<a name="ln4663">    if (mons_is_pghost(mon.type))</a>
<a name="ln4664">        base_type = player_species_to_mons_species(mon.ghost-&gt;species);</a>
<a name="ln4665">    else if (mons_is_zombified(mon))</a>
<a name="ln4666">        base_type = mon.base_monster;</a>
<a name="ln4667">    else</a>
<a name="ln4668">        base_type = mon.type;</a>
<a name="ln4669">    return get_mon_shape(base_type);</a>
<a name="ln4670">}</a>
<a name="ln4671"> </a>
<a name="ln4672">/**</a>
<a name="ln4673"> * Get the monster body shape of the given monster type.</a>
<a name="ln4674"> * @param mc  The monster type in question.</a>
<a name="ln4675"> * @return     The mon_body_shape type of this monster type.</a>
<a name="ln4676"> */</a>
<a name="ln4677">mon_body_shape get_mon_shape(const monster_type mc)</a>
<a name="ln4678">{</a>
<a name="ln4679">    if (mc == MONS_CHAOS_SPAWN)</a>
<a name="ln4680">    {</a>
<a name="ln4681">        return static_cast&lt;mon_body_shape&gt;(random_range(MON_SHAPE_HUMANOID,</a>
<a name="ln4682">                                                        MON_SHAPE_MISC));</a>
<a name="ln4683">    }</a>
<a name="ln4684"> </a>
<a name="ln4685">    ASSERT_smc();</a>
<a name="ln4686">    return smc-&gt;shape;</a>
<a name="ln4687">}</a>
<a name="ln4688"> </a>
<a name="ln4689">/**</a>
<a name="ln4690"> * What's the normal tile for a given monster type?</a>
<a name="ln4691"> *</a>
<a name="ln4692"> * @param mc    The monster type in question.</a>
<a name="ln4693"> * @return      The tile for that monster, or TILEP_MONS_PROGRAM_BUG for mons</a>
<a name="ln4694"> *              with variable tiles (e.g. merfolk, hydras, slime creatures).</a>
<a name="ln4695"> */</a>
<a name="ln4696">tileidx_t get_mon_base_tile(monster_type mc)</a>
<a name="ln4697">{</a>
<a name="ln4698">    ASSERT_smc();</a>
<a name="ln4699">    return smc-&gt;tile.base;</a>
<a name="ln4700">}</a>
<a name="ln4701"> </a>
<a name="ln4702">/**</a>
<a name="ln4703"> * How should a given monster type's tile vary?</a>
<a name="ln4704"> *</a>
<a name="ln4705"> * @param mc    The monster type in question.</a>
<a name="ln4706"> * @return      An enum describing how display of the monster should vary</a>
<a name="ln4707"> *              (by individual monster instance, or whether they're in water,</a>
<a name="ln4708"> *              etc)</a>
<a name="ln4709"> */</a>
<a name="ln4710">mon_type_tile_variation get_mon_tile_variation(monster_type mc)</a>
<a name="ln4711">{</a>
<a name="ln4712">    ASSERT_smc();</a>
<a name="ln4713">    return smc-&gt;tile.variation;</a>
<a name="ln4714">}</a>
<a name="ln4715"> </a>
<a name="ln4716">/**</a>
<a name="ln4717"> * What's the normal tile for corpses of a given monster type?</a>
<a name="ln4718"> *</a>
<a name="ln4719"> * @param mc    The monster type in question.</a>
<a name="ln4720"> * @return      The tile for that monster's corpse; may be varied slightly</a>
<a name="ln4721"> *              further in some special cases (ugly things, klowns).</a>
<a name="ln4722"> */</a>
<a name="ln4723">tileidx_t get_mon_base_corpse_tile(monster_type mc)</a>
<a name="ln4724">{</a>
<a name="ln4725">    ASSERT_smc();</a>
<a name="ln4726">    return smc-&gt;corpse_tile;</a>
<a name="ln4727">}</a>
<a name="ln4728"> </a>
<a name="ln4729"> </a>
<a name="ln4730">/**</a>
<a name="ln4731"> * Get a DB lookup string for the given monster body shape.</a>
<a name="ln4732"> * @param mon  The monster body shape type in question.</a>
<a name="ln4733"> * @return     A DB lookup string for the monster body shape.</a>
<a name="ln4734"> */</a>
<a name="ln4735">string get_mon_shape_str(const mon_body_shape shape)</a>
<a name="ln4736">{</a>
<a name="ln4737">    ASSERT_RANGE(shape, MON_SHAPE_HUMANOID, MON_SHAPE_MISC + 1);</a>
<a name="ln4738"> </a>
<a name="ln4739">    static const char *shape_names[] =</a>
<a name="ln4740">    {</a>
<a name="ln4741">        &quot;bug&quot;, &quot;humanoid&quot;, &quot;winged humanoid&quot;, &quot;tailed humanoid&quot;,</a>
<a name="ln4742">        &quot;winged tailed humanoid&quot;, &quot;centaur&quot;, &quot;naga&quot;,</a>
<a name="ln4743">        &quot;quadruped&quot;, &quot;tailless quadruped&quot;, &quot;winged quadruped&quot;,</a>
<a name="ln4744">        &quot;bat&quot;, &quot;bird&quot;, &quot;snake&quot;, &quot;fish&quot;,  &quot;insect&quot;, &quot;winged insect&quot;,</a>
<a name="ln4745">        &quot;arachnid&quot;, &quot;centipede&quot;, &quot;snail&quot;, &quot;plant&quot;, &quot;fungus&quot;, &quot;orb&quot;,</a>
<a name="ln4746">        &quot;blob&quot;, &quot;misc&quot;</a>
<a name="ln4747">    };</a>
<a name="ln4748"> </a>
<a name="ln4749">    COMPILE_CHECK(ARRAYSZ(shape_names) == MON_SHAPE_MISC + 1);</a>
<a name="ln4750">    return shape_names[shape];</a>
<a name="ln4751">}</a>
<a name="ln4752"> </a>
<a name="ln4753">/** Is this body shape partially humanoid (i.e. does it at least have a</a>
<a name="ln4754"> *  humanoid upper body)?</a>
<a name="ln4755"> *  @param shape  The body shape in question.</a>
<a name="ln4756"> *  @returns      Whether this body shape is partially humanoid.</a>
<a name="ln4757"> */</a>
<a name="ln4758">bool mon_shape_is_humanoid(mon_body_shape shape)</a>
<a name="ln4759">{</a>
<a name="ln4760">    return shape &gt;= MON_SHAPE_FIRST_HUMANOID</a>
<a name="ln4761">           &amp;&amp; shape &lt;= MON_SHAPE_LAST_HUMANOID;</a>
<a name="ln4762">}</a>
<a name="ln4763"> </a>
<a name="ln4764">bool player_or_mon_in_sanct(const monster&amp; mons)</a>
<a name="ln4765">{</a>
<a name="ln4766">    return is_sanctuary(you.pos()) || is_sanctuary(mons.pos());</a>
<a name="ln4767">}</a>
<a name="ln4768"> </a>
<a name="ln4769">int get_dist_to_nearest_monster()</a>
<a name="ln4770">{</a>
<a name="ln4771">    int minRange = LOS_RADIUS + 1;</a>
<a name="ln4772">    for (radius_iterator ri(you.pos(), LOS_NO_TRANS, true); ri; ++ri)</a>
<a name="ln4773">    {</a>
<a name="ln4774">        const monster* mon = monster_at(*ri);</a>
<a name="ln4775">        if (mon == nullptr)</a>
<a name="ln4776">            continue;</a>
<a name="ln4777"> </a>
<a name="ln4778">        if (!mon-&gt;visible_to(&amp;you))</a>
<a name="ln4779">            continue;</a>
<a name="ln4780"> </a>
<a name="ln4781">        // Plants/fungi don't count.</a>
<a name="ln4782">        if (!mons_is_threatening(*mon))</a>
<a name="ln4783">            continue;</a>
<a name="ln4784"> </a>
<a name="ln4785">        if (mon-&gt;wont_attack())</a>
<a name="ln4786">            continue;</a>
<a name="ln4787"> </a>
<a name="ln4788">        int dist = grid_distance(you.pos(), *ri);</a>
<a name="ln4789">        if (dist &lt; minRange)</a>
<a name="ln4790">            minRange = dist;</a>
<a name="ln4791">    }</a>
<a name="ln4792">    return minRange;</a>
<a name="ln4793">}</a>
<a name="ln4794"> </a>
<a name="ln4795">bool monster_nearby()</a>
<a name="ln4796">{</a>
<a name="ln4797">    for (radius_iterator ri(you.pos(), LOS_DEFAULT); ri; ++ri)</a>
<a name="ln4798">        if (monster_at(*ri))</a>
<a name="ln4799">            return true;</a>
<a name="ln4800">    return false;</a>
<a name="ln4801">}</a>
<a name="ln4802"> </a>
<a name="ln4803">actor *actor_by_mid(mid_t m, bool require_valid)</a>
<a name="ln4804">{</a>
<a name="ln4805">    if (m == MID_PLAYER)</a>
<a name="ln4806">        return &amp;you;</a>
<a name="ln4807">    return monster_by_mid(m, require_valid);</a>
<a name="ln4808">}</a>
<a name="ln4809"> </a>
<a name="ln4810">monster *monster_by_mid(mid_t m, bool require_valid)</a>
<a name="ln4811">{</a>
<a name="ln4812">    if (!require_valid)</a>
<a name="ln4813">    {</a>
<a name="ln4814">        if (m == MID_ANON_FRIEND)</a>
<a name="ln4815">            return &amp;menv[ANON_FRIENDLY_MONSTER];</a>
<a name="ln4816">        if (m == MID_YOU_FAULTLESS)</a>
<a name="ln4817">            return &amp;menv[YOU_FAULTLESS];</a>
<a name="ln4818">    }</a>
<a name="ln4819"> </a>
<a name="ln4820">    if (unsigned short *mc = map_find(env.mid_cache, m))</a>
<a name="ln4821">        return &amp;menv[*mc];</a>
<a name="ln4822">    return 0;</a>
<a name="ln4823">}</a>
<a name="ln4824"> </a>
<a name="ln4825">void init_anon()</a>
<a name="ln4826">{</a>
<a name="ln4827">    monster &amp;mon = menv[ANON_FRIENDLY_MONSTER];</a>
<a name="ln4828">    mon.reset();</a>
<a name="ln4829">    mon.type = MONS_PROGRAM_BUG;</a>
<a name="ln4830">    mon.mid = MID_ANON_FRIEND;</a>
<a name="ln4831">    mon.attitude = ATT_FRIENDLY;</a>
<a name="ln4832">    mon.hit_points = mon.max_hit_points = 1000;</a>
<a name="ln4833"> </a>
<a name="ln4834">    monster &amp;yf = menv[YOU_FAULTLESS];</a>
<a name="ln4835">    yf.reset();</a>
<a name="ln4836">    yf.type = MONS_PROGRAM_BUG;</a>
<a name="ln4837">    yf.mid = MID_YOU_FAULTLESS;</a>
<a name="ln4838">    yf.attitude = ATT_FRIENDLY; // higher than this, actually</a>
<a name="ln4839">    yf.hit_points = mon.max_hit_points = 1000;</a>
<a name="ln4840">}</a>
<a name="ln4841"> </a>
<a name="ln4842">actor *find_agent(mid_t m, kill_category kc)</a>
<a name="ln4843">{</a>
<a name="ln4844">    actor *agent = actor_by_mid(m);</a>
<a name="ln4845">    if (agent)</a>
<a name="ln4846">        return agent;</a>
<a name="ln4847">    switch (kc)</a>
<a name="ln4848">    {</a>
<a name="ln4849">    case KC_YOU:</a>
<a name="ln4850">        // shouldn't happen, there ought to be a valid mid</a>
<a name="ln4851">        return &amp;you;</a>
<a name="ln4852">    case KC_FRIENDLY:</a>
<a name="ln4853">        return &amp;menv[ANON_FRIENDLY_MONSTER];</a>
<a name="ln4854">    case KC_OTHER:</a>
<a name="ln4855">        // currently hostile dead/gone monsters are no different from env</a>
<a name="ln4856">        return 0;</a>
<a name="ln4857">    case KC_NCATEGORIES:</a>
<a name="ln4858">    default:</a>
<a name="ln4859">        die(&quot;invalid kill category&quot;);</a>
<a name="ln4860">    }</a>
<a name="ln4861">}</a>
<a name="ln4862"> </a>
<a name="ln4863">const char* mons_class_name(monster_type mc)</a>
<a name="ln4864">{</a>
<a name="ln4865">    // Usually, all invalids return &quot;program bug&quot;, but since it has value of 0,</a>
<a name="ln4866">    // it's good to tell them apart in error messages.</a>
<a name="ln4867">    if (invalid_monster_type(mc) &amp;&amp; mc != MONS_PROGRAM_BUG)</a>
<a name="ln4868">        return &quot;INVALID&quot;;</a>
<a name="ln4869"> </a>
<a name="ln4870">    return get_monster_data(mc)-&gt;name;</a>
<a name="ln4871">}</a>
<a name="ln4872"> </a>
<a name="ln4873">mon_threat_level_type mons_threat_level(const monster &amp;mon, bool real)</a>
<a name="ln4874">{</a>
<a name="ln4875">    const monster&amp; threat = get_tentacle_head(mon);</a>
<a name="ln4876">    const double factor = sqrt(exp_needed(you.experience_level) / 30.0);</a>
<a name="ln4877">    const int tension = exper_value(threat, real) / (1 + factor);</a>
<a name="ln4878"> </a>
<a name="ln4879">    if (tension &lt;= 0)</a>
<a name="ln4880">    {</a>
<a name="ln4881">        // Conjurators use melee to conserve mana, MDFis switch plates...</a>
<a name="ln4882">        return MTHRT_TRIVIAL;</a>
<a name="ln4883">    }</a>
<a name="ln4884">    else if (tension &lt;= 5)</a>
<a name="ln4885">    {</a>
<a name="ln4886">        // An easy fight but not ignorable.</a>
<a name="ln4887">        return MTHRT_EASY;</a>
<a name="ln4888">    }</a>
<a name="ln4889">    else if (tension &lt;= 32)</a>
<a name="ln4890">    {</a>
<a name="ln4891">        // Hard but reasonable.</a>
<a name="ln4892">        return MTHRT_TOUGH;</a>
<a name="ln4893">    }</a>
<a name="ln4894">    else</a>
<a name="ln4895">    {</a>
<a name="ln4896">        // Check all wands/jewels several times, wear brown pants...</a>
<a name="ln4897">        return MTHRT_NASTY;</a>
<a name="ln4898">    }</a>
<a name="ln4899">}</a>
<a name="ln4900"> </a>
<a name="ln4901">bool mons_foe_is_marked(const monster&amp; mon)</a>
<a name="ln4902">{</a>
<a name="ln4903">    if (mon.foe == MHITYOU)</a>
<a name="ln4904">        return you.duration[DUR_SENTINEL_MARK];</a>
<a name="ln4905">    else</a>
<a name="ln4906">        return false;</a>
<a name="ln4907">}</a>
<a name="ln4908"> </a>
<a name="ln4909">void debug_mondata()</a>
<a name="ln4910">{</a>
<a name="ln4911">    string fails;</a>
<a name="ln4912"> </a>
<a name="ln4913">    for (monster_type mc = MONS_0; mc &lt; NUM_MONSTERS; ++mc)</a>
<a name="ln4914">    {</a>
<a name="ln4915">        if (invalid_monster_type(mc))</a>
<a name="ln4916">            continue;</a>
<a name="ln4917">        const char* name = mons_class_name(mc);</a>
<a name="ln4918">        if (!name)</a>
<a name="ln4919">        {</a>
<a name="ln4920">            fails += make_stringf(&quot;Monster %d has no name\n&quot;, mc);</a>
<a name="ln4921">            continue;</a>
<a name="ln4922">        }</a>
<a name="ln4923"> </a>
<a name="ln4924">        const monsterentry *md = get_monster_data(mc);</a>
<a name="ln4925"> </a>
<a name="ln4926">        int MR = md-&gt;resist_magic;</a>
<a name="ln4927">        if (MR &lt; 0)</a>
<a name="ln4928">            MR = md-&gt;HD * -MR * 4 / 3;</a>
<a name="ln4929">        if (md-&gt;resist_magic &gt; 200 &amp;&amp; md-&gt;resist_magic != MAG_IMMUNE)</a>
<a name="ln4930">            fails += make_stringf(&quot;%s has MR %d &gt; 200\n&quot;, name, MR);</a>
<a name="ln4931">        if (get_resist(md-&gt;resists, MR_RES_POISON) == 2)</a>
<a name="ln4932">            fails += make_stringf(&quot;%s has rPois++\n&quot;, name);</a>
<a name="ln4933">        if (get_resist(md-&gt;resists, MR_RES_ELEC) == 2)</a>
<a name="ln4934">            fails += make_stringf(&quot;%s has rElec++\n&quot;, name);</a>
<a name="ln4935"> </a>
<a name="ln4936">        // Tests below apply only to real monsters.</a>
<a name="ln4937">        if (md-&gt;bitfields &amp; M_CANT_SPAWN)</a>
<a name="ln4938">            continue;</a>
<a name="ln4939"> </a>
<a name="ln4940">        if (!md-&gt;HD &amp;&amp; md-&gt;basechar != 'Z') // derived undead...</a>
<a name="ln4941">            fails += make_stringf(&quot;%s has 0 HD: %d\n&quot;, name, md-&gt;HD);</a>
<a name="ln4942">        if (md-&gt;avg_hp_10x &lt;= 0 &amp;&amp; md-&gt;basechar != 'Z')</a>
<a name="ln4943">            fails += make_stringf(&quot;%s has &lt;= 0 HP: %d&quot;, name, md-&gt;avg_hp_10x);</a>
<a name="ln4944"> </a>
<a name="ln4945">        if (md-&gt;basechar == ' ')</a>
<a name="ln4946">            fails += make_stringf(&quot;%s has an empty glyph\n&quot;, name);</a>
<a name="ln4947"> </a>
<a name="ln4948">        if (md-&gt;AC &lt; 0 &amp;&amp; !mons_is_job(mc))</a>
<a name="ln4949">            fails += make_stringf(&quot;%s has negative AC\n&quot;, name);</a>
<a name="ln4950">        if (md-&gt;ev &lt; 0 &amp;&amp; !mons_is_job(mc))</a>
<a name="ln4951">            fails += make_stringf(&quot;%s has negative EV\n&quot;, name);</a>
<a name="ln4952">        if (md-&gt;exp_mod &lt; 0)</a>
<a name="ln4953">            fails += make_stringf(&quot;%s has negative xp mod\n&quot;, name);</a>
<a name="ln4954"> </a>
<a name="ln4955">        if (md-&gt;speed &lt; 0)</a>
<a name="ln4956">            fails += make_stringf(&quot;%s has 0 speed\n&quot;, name);</a>
<a name="ln4957">        else if (md-&gt;speed == 0 &amp;&amp; !mons_class_is_firewood(mc))</a>
<a name="ln4958">            fails += make_stringf(&quot;%s has 0 speed\n&quot;, name);</a>
<a name="ln4959"> </a>
<a name="ln4960">        const bool male = mons_class_flag(mc, M_MALE);</a>
<a name="ln4961">        const bool female = mons_class_flag(mc, M_FEMALE);</a>
<a name="ln4962">        const bool neutral = mons_class_flag(mc, M_GENDER_NEUTRAL);</a>
<a name="ln4963">        if (male + female + neutral &gt; 1)</a>
<a name="ln4964">            fails += make_stringf(&quot;%s has too many genders\n&quot;, name);</a>
<a name="ln4965"> </a>
<a name="ln4966">        if (md-&gt;shape == MON_SHAPE_BUGGY)</a>
<a name="ln4967">            fails += make_stringf(&quot;%s has no defined shape\n&quot;, name);</a>
<a name="ln4968"> </a>
<a name="ln4969">        const bool has_corpse_tile = md-&gt;corpse_tile</a>
<a name="ln4970">                                     &amp;&amp; md-&gt;corpse_tile != TILE_ERROR;</a>
<a name="ln4971">        if (md-&gt;species != mc)</a>
<a name="ln4972">        {</a>
<a name="ln4973">            if (has_corpse_tile)</a>
<a name="ln4974">            {</a>
<a name="ln4975">                fails +=</a>
<a name="ln4976">                    make_stringf(&quot;%s isn't a species but has a corpse tile\n&quot;,</a>
<a name="ln4977">                                 name);</a>
<a name="ln4978">            }</a>
<a name="ln4979">        }</a>
<a name="ln4980">        else if (md-&gt;corpse_thingy == CE_NOCORPSE)</a>
<a name="ln4981">        {</a>
<a name="ln4982">            if (has_corpse_tile)</a>
<a name="ln4983">            {</a>
<a name="ln4984">                fails += make_stringf(&quot;%s has a corpse tile &amp; no corpse\n&quot;,</a>
<a name="ln4985">                                      name);</a>
<a name="ln4986">            }</a>
<a name="ln4987">        }</a>
<a name="ln4988">        else if (!has_corpse_tile)</a>
<a name="ln4989">            fails += make_stringf(&quot;%s has a corpse but no corpse tile\n&quot;, name);</a>
<a name="ln4990">    }</a>
<a name="ln4991"> </a>
<a name="ln4992">    dump_test_fails(fails, &quot;mon-data&quot;);</a>
<a name="ln4993">}</a>
<a name="ln4994"> </a>
<a name="ln4995">/**</a>
<a name="ln4996"> * Iterate over mspell_list (mon-spell.h) and look for anything that seems</a>
<a name="ln4997"> * incorrect. Dump the output to a text file &amp; print its location to the</a>
<a name="ln4998"> * console.</a>
<a name="ln4999"> */</a>
<a name="ln5000">void debug_monspells()</a>
<a name="ln5001">{</a>
<a name="ln5002">    string fails;</a>
<a name="ln5003"> </a>
<a name="ln5004">    // first, build a map from spellbooks to the first monster that uses them</a>
<a name="ln5005">    // (zero-initialised, where 0 == MONS_PROGRAM_BUG).</a>
<a name="ln5006">    monster_type mon_book_map[NUM_MSTYPES] = { };</a>
<a name="ln5007">    for (monster_type mc = MONS_0; mc &lt; NUM_MONSTERS; ++mc)</a>
<a name="ln5008">        if (!invalid_monster_type(mc))</a>
<a name="ln5009">            for (mon_spellbook_type mon_book : _mons_spellbook_list(mc))</a>
<a name="ln5010">                if (mon_book &lt; ARRAYSZ(mon_book_map) &amp;&amp; !mon_book_map[mon_book])</a>
<a name="ln5011">                    mon_book_map[mon_book] = mc;</a>
<a name="ln5012"> </a>
<a name="ln5013">    // then, check every spellbook for errors.</a>
<a name="ln5014"> </a>
<a name="ln5015">    for (const mon_spellbook &amp;spbook : mspell_list)</a>
<a name="ln5016">    {</a>
<a name="ln5017">        string book_name;</a>
<a name="ln5018">        const monster_type sample_mons = mon_book_map[spbook.type];</a>
<a name="ln5019">        if (!sample_mons)</a>
<a name="ln5020">        {</a>
<a name="ln5021">            string spells;</a>
<a name="ln5022">            if (spbook.spells.empty())</a>
<a name="ln5023">                spells = &quot;no spells&quot;;</a>
<a name="ln5024">            else</a>
<a name="ln5025">                for (const mon_spell_slot &amp;spslot : spbook.spells)</a>
<a name="ln5026">                    if (is_valid_spell(spslot.spell))</a>
<a name="ln5027">                        spells += make_stringf(&quot;,%s&quot;, spell_title(spslot.spell));</a>
<a name="ln5028"> </a>
<a name="ln5029">            fails += make_stringf(&quot;Book #%d is unused (%s)\n&quot;, spbook.type,</a>
<a name="ln5030">                                  spells.c_str());</a>
<a name="ln5031">            book_name = make_stringf(&quot;#%d&quot;, spbook.type);</a>
<a name="ln5032">        }</a>
<a name="ln5033">        else</a>
<a name="ln5034">        {</a>
<a name="ln5035">            const vector&lt;mon_spellbook_type&gt; mons_books</a>
<a name="ln5036">                = _mons_spellbook_list(sample_mons);</a>
<a name="ln5037">            const char * const mons_name = get_monster_data(sample_mons)-&gt;name;</a>
<a name="ln5038">            if (mons_books.size() &gt; 1)</a>
<a name="ln5039">            {</a>
<a name="ln5040">                auto it = find(begin(mons_books), end(mons_books), spbook.type);</a>
<a name="ln5041">                ASSERT(it != end(mons_books));</a>
<a name="ln5042">                book_name = make_stringf(&quot;%s-%d&quot;, mons_name,</a>
<a name="ln5043">                                         (int) (it - begin(mons_books)));</a>
<a name="ln5044">            }</a>
<a name="ln5045">            else</a>
<a name="ln5046">                book_name = mons_name;</a>
<a name="ln5047">        }</a>
<a name="ln5048"> </a>
<a name="ln5049">        const char * const bknm = book_name.c_str();</a>
<a name="ln5050"> </a>
<a name="ln5051">        if (!spbook.spells.size())</a>
<a name="ln5052">            fails += make_stringf(&quot;Empty book %s\n&quot;, bknm);</a>
<a name="ln5053"> </a>
<a name="ln5054">        for (const mon_spell_slot &amp;spslot : spbook.spells)</a>
<a name="ln5055">        {</a>
<a name="ln5056">            string spell_name;</a>
<a name="ln5057">            if (!is_valid_spell(spslot.spell))</a>
<a name="ln5058">            {</a>
<a name="ln5059">                fails += make_stringf(&quot;Book %s contains invalid spell %d\n&quot;,</a>
<a name="ln5060">                                      bknm, spslot.spell);</a>
<a name="ln5061">                spell_name = to_string(spslot.spell);</a>
<a name="ln5062">            }</a>
<a name="ln5063">            else</a>
<a name="ln5064">                spell_name = spell_title(spslot.spell);</a>
<a name="ln5065"> </a>
<a name="ln5066">            // TODO: export this value somewhere</a>
<a name="ln5067">            const int max_freq = 200;</a>
<a name="ln5068">            if (spslot.freq &gt; max_freq)</a>
<a name="ln5069">            {</a>
<a name="ln5070">                fails += make_stringf(&quot;Spellbook %s has spell %s at freq %d &quot;</a>
<a name="ln5071">                                      &quot;(greater than max freq %d)\n&quot;,</a>
<a name="ln5072">                                      bknm, spell_name.c_str(),</a>
<a name="ln5073">                                      spslot.freq, max_freq);</a>
<a name="ln5074">            }</a>
<a name="ln5075"> </a>
<a name="ln5076">            mon_spell_slot_flag category = MON_SPELL_NO_FLAGS;</a>
<a name="ln5077">            for (const auto flag : mon_spell_slot_flags::range())</a>
<a name="ln5078">            {</a>
<a name="ln5079">                if (!(spslot.flags &amp; flag))</a>
<a name="ln5080">                    continue;</a>
<a name="ln5081"> </a>
<a name="ln5082">                if (flag &gt;= MON_SPELL_FIRST_CATEGORY</a>
<a name="ln5083">                    &amp;&amp; flag &lt;= MON_SPELL_LAST_CATEGORY)</a>
<a name="ln5084">                {</a>
<a name="ln5085">                    if (category == MON_SPELL_NO_FLAGS)</a>
<a name="ln5086">                        category = flag;</a>
<a name="ln5087">                    else</a>
<a name="ln5088">                    {</a>
<a name="ln5089">                        fails += make_stringf(&quot;Spellbook %s has spell %s in &quot;</a>
<a name="ln5090">                                              &quot;multiple categories (%d and %d)\n&quot;,</a>
<a name="ln5091">                                              bknm, spell_name.c_str(),</a>
<a name="ln5092">                                              category, flag);</a>
<a name="ln5093">                    }</a>
<a name="ln5094">                }</a>
<a name="ln5095"> </a>
<a name="ln5096">                COMPILE_CHECK(MON_SPELL_NO_SILENT &gt; MON_SPELL_LAST_CATEGORY);</a>
<a name="ln5097">                static auto NO_SILENT_CATEGORIES =</a>
<a name="ln5098">                    MON_SPELL_SILENCE_MASK &amp; ~MON_SPELL_NO_SILENT;</a>
<a name="ln5099">                if (flag == MON_SPELL_NO_SILENT</a>
<a name="ln5100">                    &amp;&amp; (category &amp; NO_SILENT_CATEGORIES))</a>
<a name="ln5101">                {</a>
<a name="ln5102">                    fails += make_stringf(&quot;Spellbook %s has spell %s marked &quot;</a>
<a name="ln5103">                                          &quot;MON_SPELL_NO_SILENT redundantly\n&quot;,</a>
<a name="ln5104">                                          bknm, spell_name.c_str());</a>
<a name="ln5105">                }</a>
<a name="ln5106"> </a>
<a name="ln5107">                COMPILE_CHECK(MON_SPELL_NOISY &gt; MON_SPELL_LAST_CATEGORY);</a>
<a name="ln5108">                if (flag == MON_SPELL_NOISY</a>
<a name="ln5109">                    &amp;&amp; category &amp;&amp; !(category &amp; MON_SPELL_INNATE_MASK))</a>
<a name="ln5110">                {</a>
<a name="ln5111">                    fails += make_stringf(&quot;Spellbook %s has spell %s marked &quot;</a>
<a name="ln5112">                                          &quot;MON_SPELL_NOISY redundantly\n&quot;,</a>
<a name="ln5113">                                          bknm, spell_name.c_str());</a>
<a name="ln5114">                }</a>
<a name="ln5115">            }</a>
<a name="ln5116"> </a>
<a name="ln5117">            if (category == MON_SPELL_NO_FLAGS)</a>
<a name="ln5118">            {</a>
<a name="ln5119">                fails += make_stringf(&quot;Spellbook %s has spell %s with no &quot;</a>
<a name="ln5120">                                      &quot;category\n&quot;, bknm, spell_name.c_str());</a>
<a name="ln5121">            }</a>
<a name="ln5122">        }</a>
<a name="ln5123">    }</a>
<a name="ln5124"> </a>
<a name="ln5125">    dump_test_fails(fails, &quot;mon-spell&quot;);</a>
<a name="ln5126">}</a>
<a name="ln5127"> </a>
<a name="ln5128">// Used when clearing level data, to ensure any additional reset quirks</a>
<a name="ln5129">// are handled properly.</a>
<a name="ln5130">void reset_all_monsters()</a>
<a name="ln5131">{</a>
<a name="ln5132">    for (auto &amp;mons : menv_real)</a>
<a name="ln5133">    {</a>
<a name="ln5134">        // The monsters here have already been saved or discarded, so this</a>
<a name="ln5135">        // is the only place when a constricting monster can legitimately</a>
<a name="ln5136">        // be reset. Thus, clear constriction manually.</a>
<a name="ln5137">        if (!invalid_monster(&amp;mons))</a>
<a name="ln5138">        {</a>
<a name="ln5139">            delete mons.constricting;</a>
<a name="ln5140">            mons.constricting = nullptr;</a>
<a name="ln5141">        }</a>
<a name="ln5142">        mons.reset();</a>
<a name="ln5143">    }</a>
<a name="ln5144"> </a>
<a name="ln5145">    env.mid_cache.clear();</a>
<a name="ln5146">}</a>
<a name="ln5147"> </a>
<a name="ln5148">bool mons_is_recallable(const actor* caller, const monster&amp; targ)</a>
<a name="ln5149">{</a>
<a name="ln5150">    // For player, only recall friendly monsters</a>
<a name="ln5151">    if (caller == &amp;you)</a>
<a name="ln5152">    {</a>
<a name="ln5153">        if (!targ.friendly())</a>
<a name="ln5154">            return false;</a>
<a name="ln5155">    }</a>
<a name="ln5156">    // Monster recall requires same attitude and at least normal intelligence</a>
<a name="ln5157">    else if (mons_intel(targ) &lt; I_HUMAN</a>
<a name="ln5158">             || (!caller &amp;&amp; targ.friendly())</a>
<a name="ln5159">             || (caller &amp;&amp; !mons_aligned(&amp;targ, caller-&gt;as_monster()))</a>
<a name="ln5160">             || targ.type == MONS_PLAYER_GHOST)</a>
<a name="ln5161">    {</a>
<a name="ln5162">        return false;</a>
<a name="ln5163">    }</a>
<a name="ln5164"> </a>
<a name="ln5165">    return targ.alive()</a>
<a name="ln5166">           &amp;&amp; !mons_class_is_stationary(targ.type)</a>
<a name="ln5167">           &amp;&amp; !mons_is_conjured(targ.type);</a>
<a name="ln5168">}</a>
<a name="ln5169"> </a>
<a name="ln5170">vector&lt;monster* &gt; get_on_level_followers()</a>
<a name="ln5171">{</a>
<a name="ln5172">    vector&lt;monster* &gt; mon_list;</a>
<a name="ln5173">    for (monster_iterator mi; mi; ++mi)</a>
<a name="ln5174">        if (mons_is_recallable(&amp;you, **mi) &amp;&amp; mi-&gt;foe == MHITYOU)</a>
<a name="ln5175">            mon_list.push_back(*mi);</a>
<a name="ln5176"> </a>
<a name="ln5177">    return mon_list;</a>
<a name="ln5178">}</a>
<a name="ln5179"> </a>
<a name="ln5180">// Return the number of monsters of the specified type.</a>
<a name="ln5181">// If friendly_only is true, only count friendly</a>
<a name="ln5182">// monsters, otherwise all of them</a>
<a name="ln5183">int count_monsters(monster_type mtyp, bool friendly_only)</a>
<a name="ln5184">{</a>
<a name="ln5185">    return count_if(begin(menv), end(menv),</a>
<a name="ln5186">                    [=] (const monster &amp;mons) -&gt; bool</a>
<a name="ln5187">                    {</a>
<a name="ln5188">                        return mons.alive() &amp;&amp; mons.type == mtyp</a>
<a name="ln5189">                            &amp;&amp; (!friendly_only || mons.friendly());</a>
<a name="ln5190">                    });</a>
<a name="ln5191">}</a>
<a name="ln5192"> </a>
<a name="ln5193">int count_allies()</a>
<a name="ln5194">{</a>
<a name="ln5195">    return count_if(begin(menv), end(menv),</a>
<a name="ln5196">                    [] (const monster &amp;mons) -&gt; bool</a>
<a name="ln5197">                    {</a>
<a name="ln5198">                        return mons.alive() &amp;&amp; mons.friendly();</a>
<a name="ln5199">                    });</a>
<a name="ln5200">}</a>
<a name="ln5201"> </a>
<a name="ln5202">bool mons_stores_tracking_data(const monster&amp; mons)</a>
<a name="ln5203">{</a>
<a name="ln5204">    return mons.type == MONS_THORN_HUNTER</a>
<a name="ln5205">           || mons.type == MONS_MERFOLK_AVATAR;</a>
<a name="ln5206">}</a>
<a name="ln5207"> </a>
<a name="ln5208">bool mons_is_beast(monster_type mc)</a>
<a name="ln5209">{</a>
<a name="ln5210">    if (!(mons_class_holiness(mc) &amp; MH_NATURAL)</a>
<a name="ln5211">        || mons_class_intel(mc) != I_ANIMAL)</a>
<a name="ln5212">    {</a>
<a name="ln5213">        return false;</a>
<a name="ln5214">    }</a>
<a name="ln5215">    else if ((mons_genus(mc) == MONS_DRAGON</a>
<a name="ln5216">              &amp;&amp; mc != MONS_SWAMP_DRAGON)</a>
<a name="ln5217">             || mons_genus(mc) == MONS_UGLY_THING</a>
<a name="ln5218">             || mc == MONS_ICE_BEAST</a>
<a name="ln5219">             || mc == MONS_SKY_BEAST</a>
<a name="ln5220">             || mc == MONS_BUTTERFLY)</a>
<a name="ln5221">    {</a>
<a name="ln5222">        return false;</a>
<a name="ln5223">    }</a>
<a name="ln5224">    else</a>
<a name="ln5225">        return true;</a>
<a name="ln5226">}</a>
<a name="ln5227"> </a>
<a name="ln5228">bool mons_is_avatar(monster_type mc)</a>
<a name="ln5229">{</a>
<a name="ln5230">    return mons_class_flag(mc, M_AVATAR);</a>
<a name="ln5231">}</a>
<a name="ln5232"> </a>
<a name="ln5233">bool mons_is_player_shadow(const monster&amp; mon)</a>
<a name="ln5234">{</a>
<a name="ln5235">    return mon.type == MONS_PLAYER_SHADOW;</a>
<a name="ln5236">}</a>
<a name="ln5237"> </a>
<a name="ln5238">bool mons_has_attacks(const monster&amp; mon)</a>
<a name="ln5239">{</a>
<a name="ln5240">    const mon_attack_def attk = mons_attack_spec(mon, 0);</a>
<a name="ln5241">    return attk.type != AT_NONE &amp;&amp; attk.damage &gt; 0;</a>
<a name="ln5242">}</a>
<a name="ln5243"> </a>
<a name="ln5244">// The default suitable() function for choose_random_nearby_monster().</a>
<a name="ln5245">bool choose_any_monster(const monster&amp; mon)</a>
<a name="ln5246">{</a>
<a name="ln5247">    return !mons_is_projectile(mon.type);</a>
<a name="ln5248">}</a>
<a name="ln5249"> </a>
<a name="ln5250">// Find a nearby monster and return its index, including you as a</a>
<a name="ln5251">// possibility with probability weight. suitable() should return true</a>
<a name="ln5252">// for the type of monster wanted.</a>
<a name="ln5253">// If prefer_named is true, named monsters (including uniques) are twice</a>
<a name="ln5254">// as likely to get chosen compared to non-named ones.</a>
<a name="ln5255">// If prefer_priest is true, priestly monsters (including uniques) are</a>
<a name="ln5256">// twice as likely to get chosen compared to non-priestly ones.</a>
<a name="ln5257">monster* choose_random_nearby_monster(int weight,</a>
<a name="ln5258">                                      bool (*suitable)(const monster&amp; mon),</a>
<a name="ln5259">                                      bool prefer_named_or_priest)</a>
<a name="ln5260">{</a>
<a name="ln5261">    monster* chosen = nullptr;</a>
<a name="ln5262">    for (radius_iterator ri(you.pos(), LOS_NO_TRANS); ri; ++ri)</a>
<a name="ln5263">    {</a>
<a name="ln5264">        monster* mon = monster_at(*ri);</a>
<a name="ln5265">        if (!mon || !suitable(*mon))</a>
<a name="ln5266">            continue;</a>
<a name="ln5267"> </a>
<a name="ln5268">        // FIXME: if the intent is to favour monsters</a>
<a name="ln5269">        // named by $DEITY, we should set a flag on the</a>
<a name="ln5270">        // monster (something like MF_DEITY_PREFERRED) and</a>
<a name="ln5271">        // use that instead of checking the name, given</a>
<a name="ln5272">        // that other monsters can also have names.</a>
<a name="ln5273"> </a>
<a name="ln5274">        // True, but it's currently only used for orcs, and</a>
<a name="ln5275">        // Blork and Urug also being preferred to non-named orcs</a>
<a name="ln5276">        // is fine, I think. Once more gods name followers (and</a>
<a name="ln5277">        // prefer them) that should be changed, of course. (jpeg)</a>
<a name="ln5278">        int mon_weight = 1;</a>
<a name="ln5279"> </a>
<a name="ln5280">        if (prefer_named_or_priest)</a>
<a name="ln5281">            mon_weight += mon-&gt;is_named() + mon-&gt;is_priest();</a>
<a name="ln5282"> </a>
<a name="ln5283">        if (x_chance_in_y(mon_weight, weight += mon_weight))</a>
<a name="ln5284">            chosen = mon;</a>
<a name="ln5285">    }</a>
<a name="ln5286"> </a>
<a name="ln5287">    return chosen;</a>
<a name="ln5288">}</a>
<a name="ln5289"> </a>
<a name="ln5290">monster* choose_random_monster_on_level(int weight,</a>
<a name="ln5291">                                        bool (*suitable)(const monster&amp; mon),</a>
<a name="ln5292">                                        bool prefer_named_or_priest)</a>
<a name="ln5293">{</a>
<a name="ln5294">    monster* chosen = nullptr;</a>
<a name="ln5295"> </a>
<a name="ln5296">    for (rectangle_iterator ri(1); ri; ++ri)</a>
<a name="ln5297">    {</a>
<a name="ln5298">        monster* mon = monster_at(*ri);</a>
<a name="ln5299">        if (!mon || !suitable(*mon))</a>
<a name="ln5300">            continue;</a>
<a name="ln5301"> </a>
<a name="ln5302">        int mon_weight = 1;</a>
<a name="ln5303"> </a>
<a name="ln5304">        if (prefer_named_or_priest)</a>
<a name="ln5305">            mon_weight += mon-&gt;is_named() + mon-&gt;is_priest();</a>
<a name="ln5306"> </a>
<a name="ln5307">        if (x_chance_in_y(mon_weight, weight += mon_weight))</a>
<a name="ln5308">            chosen = mon;</a>
<a name="ln5309">    }</a>
<a name="ln5310"> </a>
<a name="ln5311">    return chosen;</a>
<a name="ln5312">}</a>
<a name="ln5313"> </a>
<a name="ln5314">void update_monster_symbol(monster_type mtype, cglyph_t md)</a>
<a name="ln5315">{</a>
<a name="ln5316">    ASSERT(mtype != MONS_0);</a>
<a name="ln5317"> </a>
<a name="ln5318">    if (md.ch)</a>
<a name="ln5319">        monster_symbols[mtype].glyph = get_glyph_override(md.ch);</a>
<a name="ln5320">    if (md.col)</a>
<a name="ln5321">        monster_symbols[mtype].colour = md.col;</a>
<a name="ln5322">}</a>
<a name="ln5323"> </a>
<a name="ln5324">int spell_freq_for_hd(int hd)</a>
<a name="ln5325">{</a>
<a name="ln5326">    return hd + 50;</a>
<a name="ln5327">}</a>
<a name="ln5328"> </a>
<a name="ln5329">void normalize_spell_freq(monster_spells &amp;spells, int total_freq)</a>
<a name="ln5330">{</a>
<a name="ln5331">    // Not using std::accumulate because slot.freq is only a uint8_t.</a>
<a name="ln5332">    unsigned int total_given_freq = 0;</a>
<a name="ln5333">    for (const auto &amp;slot : spells)</a>
<a name="ln5334">        total_given_freq += slot.freq;</a>
<a name="ln5335"> </a>
<a name="ln5336">    if (total_given_freq &gt; 0)</a>
<a name="ln5337">    {</a>
<a name="ln5338">        for (auto &amp;slot : spells)</a>
<a name="ln5339">            slot.freq = total_freq * slot.freq / total_given_freq;</a>
<a name="ln5340">    }</a>
<a name="ln5341">    else</a>
<a name="ln5342">    {</a>
<a name="ln5343">        const size_t numspells = spells.size();</a>
<a name="ln5344">        for (auto &amp;slot : spells)</a>
<a name="ln5345">            slot.freq = total_freq / numspells;</a>
<a name="ln5346">    }</a>
<a name="ln5347">}</a>
<a name="ln5348"> </a>
<a name="ln5349">/// Rounded to player-visible approximations, how hurt is this monster?</a>
<a name="ln5350">mon_dam_level_type mons_get_damage_level(const monster&amp; mons)</a>
<a name="ln5351">{</a>
<a name="ln5352">    if (mons.hit_points &lt;= mons.max_hit_points / 5)</a>
<a name="ln5353">        return MDAM_ALMOST_DEAD;</a>
<a name="ln5354">    else if (mons.hit_points &lt;= mons.max_hit_points * 2 / 5)</a>
<a name="ln5355">        return MDAM_SEVERELY_DAMAGED;</a>
<a name="ln5356">    else if (mons.hit_points &lt;= mons.max_hit_points * 3 / 5)</a>
<a name="ln5357">        return MDAM_HEAVILY_DAMAGED;</a>
<a name="ln5358">    else if (mons.hit_points &lt;= mons.max_hit_points * 4 / 5)</a>
<a name="ln5359">        return MDAM_MODERATELY_DAMAGED;</a>
<a name="ln5360">    else if (mons.hit_points &lt; mons.max_hit_points)</a>
<a name="ln5361">        return MDAM_LIGHTLY_DAMAGED;</a>
<a name="ln5362">    else</a>
<a name="ln5363">        return MDAM_OKAY;</a>
<a name="ln5364">}</a>
<a name="ln5365"> </a>
<a name="ln5366">string get_damage_level_string(mon_holy_type holi, mon_dam_level_type mdam)</a>
<a name="ln5367">{</a>
<a name="ln5368">    ostringstream ss;</a>
<a name="ln5369">    switch (mdam)</a>
<a name="ln5370">    {</a>
<a name="ln5371">    case MDAM_ALMOST_DEAD:</a>
<a name="ln5372">        ss &lt;&lt; &quot;almost&quot;;</a>
<a name="ln5373">        ss &lt;&lt; (wounded_damaged(holi) ? &quot; destroyed&quot; : &quot; dead&quot;);</a>
<a name="ln5374">        return ss.str();</a>
<a name="ln5375">    case MDAM_SEVERELY_DAMAGED:</a>
<a name="ln5376">        ss &lt;&lt; &quot;severely&quot;;</a>
<a name="ln5377">        break;</a>
<a name="ln5378">    case MDAM_HEAVILY_DAMAGED:</a>
<a name="ln5379">        ss &lt;&lt; &quot;heavily&quot;;</a>
<a name="ln5380">        break;</a>
<a name="ln5381">    case MDAM_MODERATELY_DAMAGED:</a>
<a name="ln5382">        ss &lt;&lt; &quot;moderately&quot;;</a>
<a name="ln5383">        break;</a>
<a name="ln5384">    case MDAM_LIGHTLY_DAMAGED:</a>
<a name="ln5385">        ss &lt;&lt; &quot;lightly&quot;;</a>
<a name="ln5386">        break;</a>
<a name="ln5387">    case MDAM_OKAY:</a>
<a name="ln5388">    default:</a>
<a name="ln5389">        ss &lt;&lt; &quot;not&quot;;</a>
<a name="ln5390">        break;</a>
<a name="ln5391">    }</a>
<a name="ln5392">    ss &lt;&lt; (wounded_damaged(holi) ? &quot; damaged&quot; : &quot; wounded&quot;);</a>
<a name="ln5393">    return ss.str();</a>
<a name="ln5394">}</a>
<a name="ln5395"> </a>
<a name="ln5396">void print_wounds(const monster&amp; mons)</a>
<a name="ln5397">{</a>
<a name="ln5398">    if (!mons.alive() || mons.hit_points == mons.max_hit_points)</a>
<a name="ln5399">        return;</a>
<a name="ln5400"> </a>
<a name="ln5401">    mon_dam_level_type dam_level = mons_get_damage_level(mons);</a>
<a name="ln5402">    string desc = get_damage_level_string(mons.holiness(), dam_level);</a>
<a name="ln5403"> </a>
<a name="ln5404">    desc.insert(0, &quot; is &quot;);</a>
<a name="ln5405">    desc += &quot;.&quot;;</a>
<a name="ln5406">    simple_monster_message(mons, desc.c_str(), MSGCH_MONSTER_DAMAGE,</a>
<a name="ln5407">                           dam_level);</a>
<a name="ln5408">}</a>
<a name="ln5409"> </a>
<a name="ln5410">// (true == 'damaged') [constructs, undead, etc.]</a>
<a name="ln5411">// and (false == 'wounded') [living creatures, etc.] {dlb}</a>
<a name="ln5412">bool wounded_damaged(mon_holy_type holi)</a>
<a name="ln5413">{</a>
<a name="ln5414">    // this schema needs to be abstracted into real categories {dlb}:</a>
<a name="ln5415">    return bool(holi &amp; (MH_UNDEAD | MH_NONLIVING | MH_PLANT));</a>
<a name="ln5416">}</a>
<a name="ln5417"> </a>
<a name="ln5418">// Is this monster interesting enough to make notes about?</a>
<a name="ln5419">bool mons_is_notable(const monster&amp; mons)</a>
<a name="ln5420">{</a>
<a name="ln5421">    if (crawl_state.game_is_arena())</a>
<a name="ln5422">        return false;</a>
<a name="ln5423"> </a>
<a name="ln5424">    // (Ex-)Unique monsters are always interesting</a>
<a name="ln5425">    if (mons_is_or_was_unique(mons))</a>
<a name="ln5426">        return true;</a>
<a name="ln5427">    // If it's never going to attack us, then not interesting</a>
<a name="ln5428">    if (mons.friendly())</a>
<a name="ln5429">        return false;</a>
<a name="ln5430">    // tentacles aren't real monsters.</a>
<a name="ln5431">    if (mons_is_tentacle_or_tentacle_segment(mons.type))</a>
<a name="ln5432">        return false;</a>
<a name="ln5433">    // Hostile ghosts and illusions are always interesting.</a>
<a name="ln5434">    if (mons.type == MONS_PLAYER_GHOST</a>
<a name="ln5435">        || mons.type == MONS_PLAYER_ILLUSION</a>
<a name="ln5436">        || mons.type == MONS_PANDEMONIUM_LORD)</a>
<a name="ln5437">    {</a>
<a name="ln5438">        return true;</a>
<a name="ln5439">    }</a>
<a name="ln5440">    // Jellies are never interesting to Jiyva.</a>
<a name="ln5441">    if (mons.type == MONS_JELLY &amp;&amp; have_passive(passive_t::jellies_army))</a>
<a name="ln5442">        return false;</a>
<a name="ln5443">    if (mons_threat_level(mons) == MTHRT_NASTY)</a>
<a name="ln5444">        return true;</a>
<a name="ln5445">    const auto &amp;nm = Options.note_monsters;</a>
<a name="ln5446">    // Don't waste time on moname() if user isn't using this option</a>
<a name="ln5447">    if (!nm.empty())</a>
<a name="ln5448">    {</a>
<a name="ln5449">        const string iname = mons_type_name(mons.type, DESC_A);</a>
<a name="ln5450">        return any_of(begin(nm), end(nm), [&amp;](const text_pattern &amp;pat) -&gt; bool</a>
<a name="ln5451">                                          { return pat.matches(iname); });</a>
<a name="ln5452">    }</a>
<a name="ln5453"> </a>
<a name="ln5454">    return false;</a>
<a name="ln5455">}</a>
<a name="ln5456"> </a>
<a name="ln5457">/**</a>
<a name="ln5458"> * Set up fields for mutant beasts that vary by tier &amp; facets (that is, that</a>
<a name="ln5459"> * vary between individual beasts).</a>
<a name="ln5460"> *</a>
<a name="ln5461"> * @param mons          The beast to be initialized.</a>
<a name="ln5462"> * @param HD            The beast's HD. If 0, default to mon-data's version.</a>
<a name="ln5463"> * @param beast_facets  The beast's facets (e.g. fire, bat).</a>
<a name="ln5464"> *                      If empty, chooses two distinct facets at random.</a>
<a name="ln5465"> */</a>
<a name="ln5466">void init_mutant_beast(monster &amp;mons, short HD, vector&lt;int&gt; beast_facets)</a>
<a name="ln5467">{</a>
<a name="ln5468">    if (!HD)</a>
<a name="ln5469">        HD = mons.get_experience_level();</a>
<a name="ln5470"> </a>
<a name="ln5471">    // MUTANT_BEAST_TIER is to make it visible for mon-info</a>
<a name="ln5472">    mons.props[MUTANT_BEAST_TIER] = HD;</a>
<a name="ln5473"> </a>
<a name="ln5474">    if (beast_facets.empty())</a>
<a name="ln5475">    {</a>
<a name="ln5476">        vector&lt;int&gt; available_facets;</a>
<a name="ln5477">        for (int f = BF_FIRST; f &lt;= BF_LAST; ++f)</a>
<a name="ln5478">            available_facets.insert(available_facets.end(), f);</a>
<a name="ln5479"> </a>
<a name="ln5480">        ASSERT(available_facets.size() &gt;= 2);</a>
<a name="ln5481"> </a>
<a name="ln5482">        shuffle_array(available_facets);</a>
<a name="ln5483">        beast_facets.push_back(available_facets[0]);</a>
<a name="ln5484">        beast_facets.push_back(available_facets[1]);</a>
<a name="ln5485"> </a>
<a name="ln5486">        ASSERT(beast_facets.size() == 2);</a>
<a name="ln5487">        ASSERT(beast_facets[0] != beast_facets[1]);</a>
<a name="ln5488">    }</a>
<a name="ln5489"> </a>
<a name="ln5490">    for (auto facet : beast_facets)</a>
<a name="ln5491">    {</a>
<a name="ln5492">        mons.props[MUTANT_BEAST_FACETS].get_vector().push_back(facet);</a>
<a name="ln5493"> </a>
<a name="ln5494">        switch (facet)</a>
<a name="ln5495">        {</a>
<a name="ln5496">            case BF_BAT:</a>
<a name="ln5497">                mons.props[MON_SPEED_KEY] = mons.speed * 2;</a>
<a name="ln5498">                mons.calc_speed();</a>
<a name="ln5499">                break;</a>
<a name="ln5500">            case BF_FIRE:</a>
<a name="ln5501">                mons.spells.emplace_back(SPELL_FIRE_BREATH, 60,</a>
<a name="ln5502">                                         MON_SPELL_NATURAL | MON_SPELL_BREATH);</a>
<a name="ln5503">                mons.props[CUSTOM_SPELLS_KEY] = true;</a>
<a name="ln5504">                break;</a>
<a name="ln5505">            case BF_SHOCK:</a>
<a name="ln5506">                mons.spells.emplace_back(SPELL_BLINKBOLT, 60,</a>
<a name="ln5507">                                         MON_SPELL_NATURAL);</a>
<a name="ln5508">                mons.props[CUSTOM_SPELLS_KEY] = true;</a>
<a name="ln5509">                break;</a>
<a name="ln5510">            default:</a>
<a name="ln5511">                break;</a>
<a name="ln5512">        }</a>
<a name="ln5513">    }</a>
<a name="ln5514">}</a>
<a name="ln5515"> </a>
<a name="ln5516">/**</a>
<a name="ln5517"> * If a monster needs to charge up to cast a spell (by 'casting' the spell</a>
<a name="ln5518"> * repeatedly), how many charges does it need until it can actually set the</a>
<a name="ln5519"> * spell off?</a>
<a name="ln5520"> *</a>
<a name="ln5521"> * @param m     The type of monster in question.</a>
<a name="ln5522"> * @return      The required number of charges.</a>
<a name="ln5523"> */</a>
<a name="ln5524">int max_mons_charge(monster_type m)</a>
<a name="ln5525">{</a>
<a name="ln5526">    switch (m)</a>
<a name="ln5527">    {</a>
<a name="ln5528">        case MONS_ORB_SPIDER:</a>
<a name="ln5529">        case MONS_FLOATING_EYE:</a>
<a name="ln5530">            return 1;</a>
<a name="ln5531">        default:</a>
<a name="ln5532">            return 0;</a>
<a name="ln5533">    }</a>
<a name="ln5534">}</a>
<a name="ln5535"> </a>
<a name="ln5536">// Deal out damage to nearby pain-bonded monsters based on the distance between them.</a>
<a name="ln5537">void radiate_pain_bond(const monster&amp; mon, int damage, const monster* original_target)</a>
<a name="ln5538">{</a>
<a name="ln5539">    for (actor_near_iterator ai(mon.pos(), LOS_NO_TRANS); ai; ++ai)</a>
<a name="ln5540">    {</a>
<a name="ln5541">        if (!ai-&gt;is_monster())</a>
<a name="ln5542">            continue;</a>
<a name="ln5543"> </a>
<a name="ln5544">        monster* target = ai-&gt;as_monster();</a>
<a name="ln5545"> </a>
<a name="ln5546">        if (&amp;mon == target) // no self-sharing</a>
<a name="ln5547">            continue;</a>
<a name="ln5548"> </a>
<a name="ln5549">        // Only other pain-bonded monsters are affected.</a>
<a name="ln5550">        if (!target-&gt;has_ench(ENCH_PAIN_BOND))</a>
<a name="ln5551">            continue;</a>
<a name="ln5552"> </a>
<a name="ln5553">        int distance = target-&gt;pos().distance_from(mon.pos());</a>
<a name="ln5554">        if (distance &gt; 3)</a>
<a name="ln5555">            continue;</a>
<a name="ln5556"> </a>
<a name="ln5557">        damage = max(0, div_rand_round(damage * (4 - distance), 5));</a>
<a name="ln5558"> </a>
<a name="ln5559">        if (damage &gt; 0)</a>
<a name="ln5560">        {</a>
<a name="ln5561">            behaviour_event(target, ME_ANNOY, &amp;you, you.pos());</a>
<a name="ln5562"> </a>
<a name="ln5563">            // save any potential cleanup of the original target for later</a>
<a name="ln5564">            // (in `monster::hurt`).</a>
<a name="ln5565">            if (target == original_target)</a>
<a name="ln5566">                damage = target-&gt;hurt(&amp;you, damage, BEAM_SHARED_PAIN, KILLED_BY_MONSTER, &quot;&quot;, &quot;&quot;, false);</a>
<a name="ln5567">            else</a>
<a name="ln5568">                damage = target-&gt;hurt(&amp;you, damage, BEAM_SHARED_PAIN);</a>
<a name="ln5569"> </a>
<a name="ln5570">            if (damage &gt; 0)</a>
<a name="ln5571">                radiate_pain_bond(*target, damage, original_target);</a>
<a name="ln5572">        }</a>
<a name="ln5573">    }</a>
<a name="ln5574">}</a>
<a name="ln5575"> </a>
<a name="ln5576">// When a monster explodes violently, add some spice</a>
<a name="ln5577">void throw_monster_bits(const monster&amp; mon)</a>
<a name="ln5578">{</a>
<a name="ln5579">    for (actor_near_iterator ai(mon.pos(), LOS_NO_TRANS); ai; ++ai)</a>
<a name="ln5580">    {</a>
<a name="ln5581">        if (!ai-&gt;is_monster())</a>
<a name="ln5582">            continue;</a>
<a name="ln5583"> </a>
<a name="ln5584">        monster* target = ai-&gt;as_monster();</a>
<a name="ln5585"> </a>
<a name="ln5586">        if (&amp;mon == target) // can't throw chunks of something at itself.</a>
<a name="ln5587">            continue;</a>
<a name="ln5588"> </a>
<a name="ln5589">        int distance = target-&gt;pos().distance_from(mon.pos());</a>
<a name="ln5590">        if (!one_chance_in(distance + 4)) // generally gonna miss</a>
<a name="ln5591">            continue;</a>
<a name="ln5592"> </a>
<a name="ln5593">        int damage = 1 + random2(mon.get_hit_dice());</a>
<a name="ln5594"> </a>
<a name="ln5595">        mprf(&quot;%s is hit by a flying piece of %s!&quot;,</a>
<a name="ln5596">                target-&gt;name(DESC_THE, false).c_str(),</a>
<a name="ln5597">                mon.name(DESC_THE, false).c_str());</a>
<a name="ln5598"> </a>
<a name="ln5599">        // Because someone will get a kick out of this some day.</a>
<a name="ln5600">        if (mons_class_flag(mons_base_type(mon), M_ACID_SPLASH))</a>
<a name="ln5601">            target-&gt;corrode_equipment(&quot;a flying bit&quot;, 1);</a>
<a name="ln5602"> </a>
<a name="ln5603">        behaviour_event(target, ME_ANNOY, &amp;you, you.pos());</a>
<a name="ln5604">        target-&gt;hurt(&amp;you, damage);</a>
<a name="ln5605">    }</a>
<a name="ln5606">}</a>
<a name="ln5607"> </a>
<a name="ln5608">/// Add an ancestor spell to the given list.</a>
<a name="ln5609">static void _add_ancestor_spell(monster_spells &amp;spells, spell_type spell)</a>
<a name="ln5610">{</a>
<a name="ln5611">    spells.emplace_back(spell, 25, MON_SPELL_WIZARD);</a>
<a name="ln5612">}</a>
<a name="ln5613"> </a>
<a name="ln5614">/**</a>
<a name="ln5615"> * Set the correct spells for a given ancestor, corresponding to their HD and</a>
<a name="ln5616"> * type.</a>
<a name="ln5617"> *</a>
<a name="ln5618"> * @param ancestor      The ancestor in question.</a>
<a name="ln5619"> * @param notify        Whether to print messages if anything changes.</a>
<a name="ln5620"> */</a>
<a name="ln5621">void set_ancestor_spells(monster &amp;ancestor, bool notify)</a>
<a name="ln5622">{</a>
<a name="ln5623">    ASSERT(mons_is_hepliaklqana_ancestor(ancestor.type));</a>
<a name="ln5624"> </a>
<a name="ln5625">    vector&lt;spell_type&gt; old_spells;</a>
<a name="ln5626">    for (auto spellslot : ancestor.spells)</a>
<a name="ln5627">        old_spells.emplace_back(spellslot.spell);</a>
<a name="ln5628"> </a>
<a name="ln5629">    ancestor.spells = {};</a>
<a name="ln5630">    const int HD = ancestor.get_experience_level();</a>
<a name="ln5631">    switch (ancestor.type)</a>
<a name="ln5632">    {</a>
<a name="ln5633">    case MONS_ANCESTOR_BATTLEMAGE:</a>
<a name="ln5634">        _add_ancestor_spell(ancestor.spells, HD &gt;= 10 ?</a>
<a name="ln5635">                                             SPELL_BOLT_OF_MAGMA :</a>
<a name="ln5636">                                             SPELL_THROW_FROST);</a>
<a name="ln5637">        _add_ancestor_spell(ancestor.spells, HD &gt;= 16 ?</a>
<a name="ln5638">                                             SPELL_LEHUDIBS_CRYSTAL_SPEAR :</a>
<a name="ln5639">                                             SPELL_STONE_ARROW);</a>
<a name="ln5640">        break;</a>
<a name="ln5641">    case MONS_ANCESTOR_HEXER:</a>
<a name="ln5642">        _add_ancestor_spell(ancestor.spells, HD &gt;= 10 ? SPELL_PARALYSE</a>
<a name="ln5643">                                                      : SPELL_SLOW);</a>
<a name="ln5644">        _add_ancestor_spell(ancestor.spells, HD &gt;= 13 ? SPELL_MASS_CONFUSION</a>
<a name="ln5645">                                                      : SPELL_CONFUSE);</a>
<a name="ln5646">        break;</a>
<a name="ln5647">    default:</a>
<a name="ln5648">        break;</a>
<a name="ln5649">    }</a>
<a name="ln5650"> </a>
<a name="ln5651">    if (HD &gt;= 13)</a>
<a name="ln5652">        ancestor.spells.emplace_back(SPELL_HASTE, 25, MON_SPELL_WIZARD);</a>
<a name="ln5653"> </a>
<a name="ln5654">    if (ancestor.spells.size())</a>
<a name="ln5655">        ancestor.props[CUSTOM_SPELLS_KEY] = true;</a>
<a name="ln5656"> </a>
<a name="ln5657">    if (!notify)</a>
<a name="ln5658">        return;</a>
<a name="ln5659"> </a>
<a name="ln5660">    for (auto spellslot : ancestor.spells)</a>
<a name="ln5661">    {</a>
<a name="ln5662">        if (find(old_spells.begin(), old_spells.end(), spellslot.spell)</a>
<a name="ln5663">            == old_spells.end())</a>
<a name="ln5664">        {</a>
<a name="ln5665">            mprf(&quot;%s regains %s memory of %s.&quot;,</a>
<a name="ln5666">                 ancestor.name(DESC_YOUR, true).c_str(),</a>
<a name="ln5667">                 ancestor.pronoun(PRONOUN_POSSESSIVE, true).c_str(),</a>
<a name="ln5668">                 spell_title(spellslot.spell));</a>
<a name="ln5669">        }</a>
<a name="ln5670">    }</a>
<a name="ln5671">}</a>
<a name="ln5672"> </a>
<a name="ln5673">static bool _apply_to_monsters(monster_func f, radius_iterator&amp;&amp; ri)</a>
<a name="ln5674">{</a>
<a name="ln5675">    bool affected_any = false;</a>
<a name="ln5676">    for (; ri; ri++)</a>
<a name="ln5677">    {</a>
<a name="ln5678">        monster* mons = monster_at(*ri);</a>
<a name="ln5679">        if (!invalid_monster(mons))</a>
<a name="ln5680">            affected_any = f(*mons) || affected_any;</a>
<a name="ln5681">    }</a>
<a name="ln5682"> </a>
<a name="ln5683">    return affected_any;</a>
<a name="ln5684">}</a>
<a name="ln5685"> </a>
<a name="ln5686">bool apply_monsters_around_square(monster_func f, const coord_def&amp; where,</a>
<a name="ln5687">                                  int radius)</a>
<a name="ln5688">{</a>
<a name="ln5689">    return _apply_to_monsters(f, radius_iterator(where, radius, C_SQUARE,</a>
<a name="ln5690">                                                 LOS_NO_TRANS, true));</a>
<a name="ln5691">}</a>
<a name="ln5692"> </a>
<a name="ln5693">bool apply_visible_monsters(monster_func f, const coord_def&amp; where, los_type los)</a>
<a name="ln5694">{</a>
<a name="ln5695">    return _apply_to_monsters(f, radius_iterator(where, los, true));</a>
<a name="ln5696">}</a>

</code></pre>
<div class="balloon" rel="175"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v547/" target="_blank">V547</a> Expression 'valid_mons.empty()' is always false.</p></div>
<div class="balloon" rel="202"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v648/" target="_blank">V648</a> Priority of the '&&' operation is higher than that of the '||' operation.</p></div>
<div class="balloon" rel="375"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v648/" target="_blank">V648</a> Priority of the '&&' operation is higher than that of the '||' operation.</p></div>
<div class="balloon" rel="1115"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v595/" target="_blank">V595</a> The 'item' pointer was utilized before it was verified against nullptr. Check lines: 1115, 1129.</p></div>
<div class="balloon" rel="1194"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v648/" target="_blank">V648</a> Priority of the '&&' operation is higher than that of the '||' operation.</p></div>
<div class="balloon" rel="1398"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v648/" target="_blank">V648</a> Priority of the '&&' operation is higher than that of the '||' operation.</p></div>
<div class="balloon" rel="1492"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v648/" target="_blank">V648</a> Priority of the '&&' operation is higher than that of the '||' operation.</p></div>
<div class="balloon" rel="3215"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v648/" target="_blank">V648</a> Priority of the '&&' operation is higher than that of the '||' operation.</p></div>
<div class="balloon" rel="4642"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v560/" target="_blank">V560</a> A part of conditional expression is always false: s_type < 0.</p></div>
<div class="balloon" rel="4839"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v1048/" target="_blank">V1048</a> The 'mon.max_hit_points' variable was assigned the same value.</p></div>

<link rel="stylesheet" href="highlight.css">
<script src="highlight.pack.js"></script>
<script src="highlightjs-line-numbers.js"></script>
<script>hljs.initHighlightingOnLoad();</script>
<script>hljs.initLineNumbersOnLoad();</script>
<script>
  $(document).ready(function() {
      $('.balloon').each(function () {
          var bl = $(this);
          var line = bl.attr('rel');
          var text = $('a[name="ln'+line+'"]').text();

          var space_count = 0;
          for(var i = 0; i<text.length; i++){
              var char = text[i];
              if((char !== ' ')&&(char !== '\t'))break;
              if(char === '\t')space_count++;
              space_count++;
          }

          bl.css('margin-left', space_count*8);
          $('a[name="ln'+line+'"]').after(bl);
      });

      window.location = window.location;
  });
</script>
</body>
</html>
