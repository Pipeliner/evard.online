
<html>
<head>

  <meta http-equiv="Content-Type" content="text/html; charset=US-ASCII" />
  <title>mapdef.cc</title>

  <link rel="stylesheet" href="../style.css"/>
  <script src="../jquery-3.2.1.min.js"></script>
</head>
<body>

<pre><code class = "cpp">
<a name="ln1">/**</a>
<a name="ln2"> * @file</a>
<a name="ln3"> * @brief Support code for Crawl des files.</a>
<a name="ln4">**/</a>
<a name="ln5"> </a>
<a name="ln6">#include &quot;AppHdr.h&quot;</a>
<a name="ln7"> </a>
<a name="ln8">#include &quot;mapdef.h&quot;</a>
<a name="ln9"> </a>
<a name="ln10">#include &lt;algorithm&gt;</a>
<a name="ln11">#include &lt;cctype&gt;</a>
<a name="ln12">#include &lt;cstdarg&gt;</a>
<a name="ln13">#include &lt;cstdio&gt;</a>
<a name="ln14">#include &lt;cstdlib&gt;</a>
<a name="ln15">#include &lt;iostream&gt;</a>
<a name="ln16"> </a>
<a name="ln17">#include &quot;abyss.h&quot;</a>
<a name="ln18">#include &quot;artefact.h&quot;</a>
<a name="ln19">#include &quot;branch.h&quot;</a>
<a name="ln20">#include &quot;cluautil.h&quot;</a>
<a name="ln21">#include &quot;colour.h&quot;</a>
<a name="ln22">#include &quot;coordit.h&quot;</a>
<a name="ln23">#include &quot;describe.h&quot;</a>
<a name="ln24">#include &quot;dgn-height.h&quot;</a>
<a name="ln25">#include &quot;dungeon.h&quot;</a>
<a name="ln26">#include &quot;end.h&quot;</a>
<a name="ln27">#include &quot;english.h&quot;</a>
<a name="ln28">#include &quot;files.h&quot;</a>
<a name="ln29">#include &quot;initfile.h&quot;</a>
<a name="ln30">#include &quot;item-status-flag-type.h&quot;</a>
<a name="ln31">#include &quot;invent.h&quot;</a>
<a name="ln32">#include &quot;libutil.h&quot;</a>
<a name="ln33">#include &quot;mapmark.h&quot;</a>
<a name="ln34">#include &quot;maps.h&quot;</a>
<a name="ln35">#include &quot;mon-cast.h&quot;</a>
<a name="ln36">#include &quot;mon-place.h&quot;</a>
<a name="ln37">#include &quot;mutant-beast.h&quot;</a>
<a name="ln38">#include &quot;place.h&quot;</a>
<a name="ln39">#include &quot;random.h&quot;</a>
<a name="ln40">#include &quot;religion.h&quot;</a>
<a name="ln41">#include &quot;shopping.h&quot;</a>
<a name="ln42">#include &quot;spl-book.h&quot;</a>
<a name="ln43">#include &quot;spl-util.h&quot;</a>
<a name="ln44">#include &quot;stringutil.h&quot;</a>
<a name="ln45">#include &quot;terrain.h&quot;</a>
<a name="ln46">#include &quot;rltiles/tiledef-dngn.h&quot;</a>
<a name="ln47">#include &quot;rltiles/tiledef-player.h&quot;</a>
<a name="ln48"> </a>
<a name="ln49">#ifdef DEBUG_TAG_PROFILING</a>
<a name="ln50">static map&lt;string,int&gt; _tag_profile;</a>
<a name="ln51"> </a>
<a name="ln52">static void _profile_inc_tag(const string &amp;tag)</a>
<a name="ln53">{</a>
<a name="ln54">    if (!_tag_profile.count(tag))</a>
<a name="ln55">        _tag_profile[tag] = 0;</a>
<a name="ln56">    _tag_profile[tag]++;</a>
<a name="ln57">}</a>
<a name="ln58"> </a>
<a name="ln59">void tag_profile_out()</a>
<a name="ln60">{</a>
<a name="ln61">    long total = 0;</a>
<a name="ln62">    vector&lt;pair&lt;int, string&gt;&gt; resort;</a>
<a name="ln63">    fprintf(stderr, &quot;\nTag hits:\n&quot;);</a>
<a name="ln64">    for (auto k : _tag_profile)</a>
<a name="ln65">    {</a>
<a name="ln66">        resort.emplace_back(k.second, k.first);</a>
<a name="ln67">        total += k.second;</a>
<a name="ln68">    }</a>
<a name="ln69">    sort(resort.begin(), resort.end());</a>
<a name="ln70">    for (auto p : resort)</a>
<a name="ln71">    {</a>
<a name="ln72">        long percent = ((long) p.first) * 100 / total;</a>
<a name="ln73">        fprintf(stderr, &quot;%8d (%2ld%%): %s\n&quot;, p.first, percent, p.second.c_str());</a>
<a name="ln74">    }</a>
<a name="ln75">    fprintf(stderr, &quot;Total: %ld\n&quot;, total);</a>
<a name="ln76">}</a>
<a name="ln77">#endif</a>
<a name="ln78"> </a>
<a name="ln79">static const char *map_section_names[] =</a>
<a name="ln80">{</a>
<a name="ln81">    &quot;&quot;,</a>
<a name="ln82">    &quot;north&quot;,</a>
<a name="ln83">    &quot;south&quot;,</a>
<a name="ln84">    &quot;east&quot;,</a>
<a name="ln85">    &quot;west&quot;,</a>
<a name="ln86">    &quot;northwest&quot;,</a>
<a name="ln87">    &quot;northeast&quot;,</a>
<a name="ln88">    &quot;southwest&quot;,</a>
<a name="ln89">    &quot;southeast&quot;,</a>
<a name="ln90">    &quot;encompass&quot;,</a>
<a name="ln91">    &quot;float&quot;,</a>
<a name="ln92">    &quot;centre&quot;,</a>
<a name="ln93">};</a>
<a name="ln94"> </a>
<a name="ln95">static string_set Map_Flag_Names;</a>
<a name="ln96"> </a>
<a name="ln97">const char *traversable_glyphs =</a>
<a name="ln98">    &quot;.+=w@{}()[]&lt;&gt;BC^TUVY$%*|Odefghijk0123456789&quot;;</a>
<a name="ln99"> </a>
<a name="ln100">// atoi that rejects strings containing non-numeric trailing characters.</a>
<a name="ln101">// returns defval for invalid input.</a>
<a name="ln102">template &lt;typename V&gt;</a>
<a name="ln103">static V strict_aton(const char *s, V defval = 0)</a>
<a name="ln104">{</a>
<a name="ln105">    char *end;</a>
<a name="ln106">    const V res = strtol(s, &amp;end, 10);</a>
<a name="ln107">    return (!*s || *end) ? defval : res;</a>
<a name="ln108">}</a>
<a name="ln109"> </a>
<a name="ln110">const char *map_section_name(int msect)</a>
<a name="ln111">{</a>
<a name="ln112">    if (msect &lt; 0 || msect &gt;= MAP_NUM_SECTION_TYPES)</a>
<a name="ln113">        return &quot;&quot;;</a>
<a name="ln114"> </a>
<a name="ln115">    return map_section_names[msect];</a>
<a name="ln116">}</a>
<a name="ln117"> </a>
<a name="ln118">static int find_weight(string &amp;s, int defweight = TAG_UNFOUND)</a>
<a name="ln119">{</a>
<a name="ln120">    int weight = strip_number_tag(s, &quot;weight:&quot;);</a>
<a name="ln121">    if (weight == TAG_UNFOUND)</a>
<a name="ln122">        weight = strip_number_tag(s, &quot;w:&quot;);</a>
<a name="ln123">    return weight == TAG_UNFOUND ? defweight : weight;</a>
<a name="ln124">}</a>
<a name="ln125"> </a>
<a name="ln126">void clear_subvault_stack()</a>
<a name="ln127">{</a>
<a name="ln128">    env.new_subvault_names.clear();</a>
<a name="ln129">    env.new_subvault_tags.clear();</a>
<a name="ln130">    env.new_used_subvault_names.clear();</a>
<a name="ln131">    env.new_used_subvault_tags.clear();</a>
<a name="ln132">}</a>
<a name="ln133"> </a>
<a name="ln134">void map_register_flag(const string &amp;flag)</a>
<a name="ln135">{</a>
<a name="ln136">    Map_Flag_Names.insert(flag);</a>
<a name="ln137">}</a>
<a name="ln138"> </a>
<a name="ln139">static bool _map_tag_is_selectable(const string &amp;tag)</a>
<a name="ln140">{</a>
<a name="ln141">    return !Map_Flag_Names.count(tag)</a>
<a name="ln142">           &amp;&amp; tag.find(&quot;luniq_&quot;) != 0</a>
<a name="ln143">           &amp;&amp; tag.find(&quot;uniq_&quot;) != 0</a>
<a name="ln144">           &amp;&amp; tag.find(&quot;ruin_&quot;) != 0</a>
<a name="ln145">           &amp;&amp; tag.find(&quot;chance_&quot;) != 0;</a>
<a name="ln146">}</a>
<a name="ln147"> </a>
<a name="ln148">string mapdef_split_key_item(const string &amp;s, string *key, int *separator,</a>
<a name="ln149">                             string *arg, int key_max_len)</a>
<a name="ln150">{</a>
<a name="ln151">    string::size_type</a>
<a name="ln152">        norm = s.find(&quot;=&quot;, 1),</a>
<a name="ln153">        fixe = s.find(&quot;:&quot;, 1);</a>
<a name="ln154"> </a>
<a name="ln155">    const string::size_type sep = norm &lt; fixe? norm : fixe;</a>
<a name="ln156">    if (sep == string::npos)</a>
<a name="ln157">    {</a>
<a name="ln158">        return make_stringf(&quot;malformed declaration - must use = or : in '%s'&quot;,</a>
<a name="ln159">                            s.c_str());</a>
<a name="ln160">    }</a>
<a name="ln161"> </a>
<a name="ln162">    *key = trimmed_string(s.substr(0, sep));</a>
<a name="ln163">    string substitute = trimmed_string(s.substr(sep + 1));</a>
<a name="ln164"> </a>
<a name="ln165">    if (key-&gt;empty()</a>
<a name="ln166">        || (key_max_len != -1 &amp;&amp; (int) key-&gt;length() &gt; key_max_len))</a>
<a name="ln167">    {</a>
<a name="ln168">        return make_stringf(</a>
<a name="ln169">            &quot;selector '%s' must be &lt;= %d characters in '%s'&quot;,</a>
<a name="ln170">            key-&gt;c_str(), key_max_len, s.c_str());</a>
<a name="ln171">    }</a>
<a name="ln172"> </a>
<a name="ln173">    if (substitute.empty())</a>
<a name="ln174">    {</a>
<a name="ln175">        return make_stringf(&quot;no substitute defined in '%s'&quot;,</a>
<a name="ln176">                            s.c_str());</a>
<a name="ln177">    }</a>
<a name="ln178"> </a>
<a name="ln179">    *arg = substitute;</a>
<a name="ln180">    *separator = s[sep];</a>
<a name="ln181"> </a>
<a name="ln182">    return &quot;&quot;;</a>
<a name="ln183">}</a>
<a name="ln184"> </a>
<a name="ln185">int store_tilename_get_index(const string&amp; tilename)</a>
<a name="ln186">{</a>
<a name="ln187">    if (tilename.empty())</a>
<a name="ln188">        return 0;</a>
<a name="ln189"> </a>
<a name="ln190">    // Increase index by 1 to distinguish between first entry and none.</a>
<a name="ln191">    unsigned int i;</a>
<a name="ln192">    for (i = 0; i &lt; env.tile_names.size(); ++i)</a>
<a name="ln193">        if (tilename == env.tile_names[i])</a>
<a name="ln194">            return i+1;</a>
<a name="ln195"> </a>
<a name="ln196">#ifdef DEBUG_TILE_NAMES</a>
<a name="ln197">    mprf(&quot;adding %s on index %d (%d)&quot;, tilename.c_str(), i, i+1);</a>
<a name="ln198">#endif</a>
<a name="ln199">    // If not found, add tile name to vector.</a>
<a name="ln200">    env.tile_names.push_back(tilename);</a>
<a name="ln201">    return i+1;</a>
<a name="ln202">}</a>
<a name="ln203"> </a>
<a name="ln204">///////////////////////////////////////////////</a>
<a name="ln205">// subvault_place</a>
<a name="ln206">//</a>
<a name="ln207"> </a>
<a name="ln208">subvault_place::subvault_place()</a>
<a name="ln209">    : tl(), br(), subvault()</a>
<a name="ln210">{</a>
<a name="ln211">}</a>
<a name="ln212"> </a>
<a name="ln213">subvault_place::subvault_place(const coord_def &amp;_tl,</a>
<a name="ln214">                               const coord_def &amp;_br,</a>
<a name="ln215">                               const map_def &amp;_subvault)</a>
<a name="ln216">    : tl(_tl), br(_br), subvault(new map_def(_subvault))</a>
<a name="ln217">{</a>
<a name="ln218">}</a>
<a name="ln219"> </a>
<a name="ln220">subvault_place::subvault_place(const subvault_place &amp;place)</a>
<a name="ln221">    : tl(place.tl), br(place.br),</a>
<a name="ln222">      subvault(place.subvault ? new map_def(*place.subvault) : nullptr)</a>
<a name="ln223">{</a>
<a name="ln224">}</a>
<a name="ln225"> </a>
<a name="ln226">subvault_place &amp;subvault_place::operator = (const subvault_place &amp;place)</a>
<a name="ln227">{</a>
<a name="ln228">    tl = place.tl;</a>
<a name="ln229">    br = place.br;</a>
<a name="ln230">    subvault.reset(place.subvault ? new map_def(*place.subvault)</a>
<a name="ln231">                                        : nullptr);</a>
<a name="ln232">    return *this;</a>
<a name="ln233">}</a>
<a name="ln234"> </a>
<a name="ln235">void subvault_place::set_subvault(const map_def &amp;_subvault)</a>
<a name="ln236">{</a>
<a name="ln237">    subvault.reset(new map_def(_subvault));</a>
<a name="ln238">}</a>
<a name="ln239"> </a>
<a name="ln240">///////////////////////////////////////////////</a>
<a name="ln241">// level_range</a>
<a name="ln242">//</a>
<a name="ln243"> </a>
<a name="ln244">level_range::level_range(branch_type br, int s, int d)</a>
<a name="ln245">    : branch(br), shallowest(), deepest(), deny(false)</a>
<a name="ln246">{</a>
<a name="ln247">    set(s, d);</a>
<a name="ln248">}</a>
<a name="ln249"> </a>
<a name="ln250">level_range::level_range(const raw_range &amp;r)</a>
<a name="ln251">    : branch(r.branch), shallowest(r.shallowest), deepest(r.deepest),</a>
<a name="ln252">      deny(r.deny)</a>
<a name="ln253">{</a>
<a name="ln254">}</a>
<a name="ln255"> </a>
<a name="ln256">void level_range::write(writer&amp; outf) const</a>
<a name="ln257">{</a>
<a name="ln258">    marshallShort(outf, branch);</a>
<a name="ln259">    marshallShort(outf, shallowest);</a>
<a name="ln260">    marshallShort(outf, deepest);</a>
<a name="ln261">    marshallBoolean(outf, deny);</a>
<a name="ln262">}</a>
<a name="ln263"> </a>
<a name="ln264">void level_range::read(reader&amp; inf)</a>
<a name="ln265">{</a>
<a name="ln266">    branch     = static_cast&lt;branch_type&gt;(unmarshallShort(inf));</a>
<a name="ln267">    shallowest = unmarshallShort(inf);</a>
<a name="ln268">    deepest    = unmarshallShort(inf);</a>
<a name="ln269">    deny       = unmarshallBoolean(inf);</a>
<a name="ln270">}</a>
<a name="ln271"> </a>
<a name="ln272">string level_range::str_depth_range() const</a>
<a name="ln273">{</a>
<a name="ln274">    if (shallowest == -1)</a>
<a name="ln275">        return &quot;:??&quot;;</a>
<a name="ln276"> </a>
<a name="ln277">    if (shallowest == BRANCH_END)</a>
<a name="ln278">        return &quot;:$&quot;;</a>
<a name="ln279"> </a>
<a name="ln280">    if (deepest == BRANCH_END)</a>
<a name="ln281">        return shallowest == 1? &quot;&quot; : make_stringf(&quot;%d-&quot;, shallowest);</a>
<a name="ln282"> </a>
<a name="ln283">    if (shallowest == deepest)</a>
<a name="ln284">        return make_stringf(&quot;:%d&quot;, shallowest);</a>
<a name="ln285"> </a>
<a name="ln286">    return make_stringf(&quot;:%d-%d&quot;, shallowest, deepest);</a>
<a name="ln287">}</a>
<a name="ln288"> </a>
<a name="ln289">string level_range::describe() const</a>
<a name="ln290">{</a>
<a name="ln291">    return make_stringf(&quot;%s%s%s&quot;,</a>
<a name="ln292">                        deny? &quot;!&quot; : &quot;&quot;,</a>
<a name="ln293">                        branch == NUM_BRANCHES ? &quot;Any&quot; :</a>
<a name="ln294">                        branches[branch].abbrevname,</a>
<a name="ln295">                        str_depth_range().c_str());</a>
<a name="ln296">}</a>
<a name="ln297"> </a>
<a name="ln298">level_range::operator raw_range () const</a>
<a name="ln299">{</a>
<a name="ln300">    raw_range r;</a>
<a name="ln301">    r.branch     = branch;</a>
<a name="ln302">    r.shallowest = shallowest;</a>
<a name="ln303">    r.deepest    = deepest;</a>
<a name="ln304">    r.deny       = deny;</a>
<a name="ln305">    return r;</a>
<a name="ln306">}</a>
<a name="ln307"> </a>
<a name="ln308">void level_range::set(const string &amp;br, int s, int d)</a>
<a name="ln309">{</a>
<a name="ln310">    if (br == &quot;any&quot; || br == &quot;Any&quot;)</a>
<a name="ln311">        branch = NUM_BRANCHES;</a>
<a name="ln312">    else if ((branch = branch_by_abbrevname(br)) == NUM_BRANCHES)</a>
<a name="ln313">        throw bad_level_id_f(&quot;Unknown branch: '%s'&quot;, br.c_str());</a>
<a name="ln314"> </a>
<a name="ln315">    shallowest = s;</a>
<a name="ln316">    deepest    = d;</a>
<a name="ln317"> </a>
<a name="ln318">    if (deepest &lt; shallowest || deepest &lt;= 0)</a>
<a name="ln319">    {</a>
<a name="ln320">        throw bad_level_id_f(&quot;Level-range %s:%d-%d is malformed&quot;,</a>
<a name="ln321">                             br.c_str(), s, d);</a>
<a name="ln322">    }</a>
<a name="ln323">}</a>
<a name="ln324"> </a>
<a name="ln325">level_range level_range::parse(string s)</a>
<a name="ln326">{</a>
<a name="ln327">    level_range lr;</a>
<a name="ln328">    trim_string(s);</a>
<a name="ln329"> </a>
<a name="ln330">    if (s == &quot;*&quot;)</a>
<a name="ln331">    {</a>
<a name="ln332">        lr.set(&quot;any&quot;, 0, BRANCH_END);</a>
<a name="ln333">        return lr;</a>
<a name="ln334">    }</a>
<a name="ln335"> </a>
<a name="ln336">    if (s[0] == '!')</a>
<a name="ln337">    {</a>
<a name="ln338">        lr.deny = true;</a>
<a name="ln339">        s = trimmed_string(s.substr(1));</a>
<a name="ln340">    }</a>
<a name="ln341"> </a>
<a name="ln342">    string::size_type cpos = s.find(':');</a>
<a name="ln343">    if (cpos == string::npos)</a>
<a name="ln344">        parse_partial(lr, s);</a>
<a name="ln345">    else</a>
<a name="ln346">    {</a>
<a name="ln347">        string br    = trimmed_string(s.substr(0, cpos));</a>
<a name="ln348">        string depth = trimmed_string(s.substr(cpos + 1));</a>
<a name="ln349">        parse_depth_range(depth, &amp;lr.shallowest, &amp;lr.deepest);</a>
<a name="ln350"> </a>
<a name="ln351">        lr.set(br, lr.shallowest, lr.deepest);</a>
<a name="ln352">    }</a>
<a name="ln353"> </a>
<a name="ln354">    return lr;</a>
<a name="ln355">}</a>
<a name="ln356"> </a>
<a name="ln357">void level_range::parse_partial(level_range &amp;lr, const string &amp;s)</a>
<a name="ln358">{</a>
<a name="ln359">    if (isadigit(s[0]))</a>
<a name="ln360">    {</a>
<a name="ln361">        lr.branch = NUM_BRANCHES;</a>
<a name="ln362">        parse_depth_range(s, &amp;lr.shallowest, &amp;lr.deepest);</a>
<a name="ln363">    }</a>
<a name="ln364">    else</a>
<a name="ln365">        lr.set(s, 1, BRANCH_END);</a>
<a name="ln366">}</a>
<a name="ln367"> </a>
<a name="ln368">void level_range::parse_depth_range(const string &amp;s, int *l, int *h)</a>
<a name="ln369">{</a>
<a name="ln370">    if (s == &quot;*&quot;)</a>
<a name="ln371">    {</a>
<a name="ln372">        *l = 1;</a>
<a name="ln373">        *h = BRANCH_END;</a>
<a name="ln374">        return;</a>
<a name="ln375">    }</a>
<a name="ln376"> </a>
<a name="ln377">    if (s == &quot;$&quot;)</a>
<a name="ln378">    {</a>
<a name="ln379">        *l = BRANCH_END;</a>
<a name="ln380">        *h = BRANCH_END;</a>
<a name="ln381">        return;</a>
<a name="ln382">    }</a>
<a name="ln383"> </a>
<a name="ln384">    string::size_type hy = s.find('-');</a>
<a name="ln385">    if (hy == string::npos)</a>
<a name="ln386">    {</a>
<a name="ln387">        *l = *h = strict_aton&lt;int&gt;(s.c_str());</a>
<a name="ln388">        if (!*l)</a>
<a name="ln389">            throw bad_level_id(&quot;Bad depth: &quot; + s);</a>
<a name="ln390">    }</a>
<a name="ln391">    else</a>
<a name="ln392">    {</a>
<a name="ln393">        *l = strict_aton&lt;int&gt;(s.substr(0, hy).c_str());</a>
<a name="ln394"> </a>
<a name="ln395">        string tail = s.substr(hy + 1);</a>
<a name="ln396">        if (tail.empty() || tail == &quot;$&quot;)</a>
<a name="ln397">            *h = BRANCH_END;</a>
<a name="ln398">        else</a>
<a name="ln399">            *h = strict_aton&lt;int&gt;(tail.c_str());</a>
<a name="ln400"> </a>
<a name="ln401">        if (!*l || !*h || *l &gt; *h)</a>
<a name="ln402">            throw bad_level_id(&quot;Bad depth: &quot; + s);</a>
<a name="ln403">    }</a>
<a name="ln404">}</a>
<a name="ln405"> </a>
<a name="ln406">void level_range::set(int s, int d)</a>
<a name="ln407">{</a>
<a name="ln408">    shallowest = s;</a>
<a name="ln409">    deepest    = d;</a>
<a name="ln410"> </a>
<a name="ln411">    if (deepest == -1)</a>
<a name="ln412">        deepest = shallowest;</a>
<a name="ln413"> </a>
<a name="ln414">    if (deepest &lt; shallowest)</a>
<a name="ln415">        throw bad_level_id_f(&quot;Bad depth range: %d-%d&quot;, shallowest, deepest);</a>
<a name="ln416">}</a>
<a name="ln417"> </a>
<a name="ln418">void level_range::reset()</a>
<a name="ln419">{</a>
<a name="ln420">    deepest = shallowest = -1;</a>
<a name="ln421">    branch  = NUM_BRANCHES;</a>
<a name="ln422">}</a>
<a name="ln423"> </a>
<a name="ln424">bool level_range::matches(const level_id &amp;lid) const</a>
<a name="ln425">{</a>
<a name="ln426">    if (branch == NUM_BRANCHES)</a>
<a name="ln427">        return matches(absdungeon_depth(lid.branch, lid.depth));</a>
<a name="ln428">    else</a>
<a name="ln429">    {</a>
<a name="ln430">        return branch == lid.branch</a>
<a name="ln431">               &amp;&amp; (lid.depth &gt;= shallowest</a>
<a name="ln432">                   || shallowest == BRANCH_END &amp;&amp; lid.depth == brdepth[branch])</a>
<a name="ln433">               &amp;&amp; lid.depth &lt;= deepest;</a>
<a name="ln434">    }</a>
<a name="ln435">}</a>
<a name="ln436"> </a>
<a name="ln437">bool level_range::matches(int x) const</a>
<a name="ln438">{</a>
<a name="ln439">    // [ds] The level ranges used by the game are zero-based, adjust for that.</a>
<a name="ln440">    ++x;</a>
<a name="ln441">    return x &gt;= shallowest &amp;&amp; x &lt;= deepest;</a>
<a name="ln442">}</a>
<a name="ln443"> </a>
<a name="ln444">bool level_range::operator == (const level_range &amp;lr) const</a>
<a name="ln445">{</a>
<a name="ln446">    return deny == lr.deny</a>
<a name="ln447">           &amp;&amp; shallowest == lr.shallowest</a>
<a name="ln448">           &amp;&amp; deepest == lr.deepest</a>
<a name="ln449">           &amp;&amp; branch == lr.branch;</a>
<a name="ln450">}</a>
<a name="ln451"> </a>
<a name="ln452">bool level_range::valid() const</a>
<a name="ln453">{</a>
<a name="ln454">    return shallowest &gt; 0 &amp;&amp; deepest &gt;= shallowest;</a>
<a name="ln455">}</a>
<a name="ln456"> </a>
<a name="ln457">////////////////////////////////////////////////////////////////////////</a>
<a name="ln458">// map_lines</a>
<a name="ln459"> </a>
<a name="ln460">map_lines::map_lines()</a>
<a name="ln461">    : markers(), lines(), overlay(),</a>
<a name="ln462">      map_width(0), solid_north(false), solid_east(false),</a>
<a name="ln463">      solid_south(false), solid_west(false), solid_checked(false)</a>
<a name="ln464">{</a>
<a name="ln465">}</a>
<a name="ln466"> </a>
<a name="ln467">map_lines::map_lines(const map_lines &amp;map)</a>
<a name="ln468">{</a>
<a name="ln469">    init_from(map);</a>
<a name="ln470">}</a>
<a name="ln471"> </a>
<a name="ln472">void map_lines::write_maplines(writer &amp;outf) const</a>
<a name="ln473">{</a>
<a name="ln474">    const int h = height();</a>
<a name="ln475">    marshallShort(outf, h);</a>
<a name="ln476">    for (int i = 0; i &lt; h; ++i)</a>
<a name="ln477">        marshallString(outf, lines[i]);</a>
<a name="ln478">}</a>
<a name="ln479"> </a>
<a name="ln480">void map_lines::read_maplines(reader &amp;inf)</a>
<a name="ln481">{</a>
<a name="ln482">    clear();</a>
<a name="ln483">    const int h = unmarshallShort(inf);</a>
<a name="ln484">    ASSERT_RANGE(h, 0, GYM + 1);</a>
<a name="ln485"> </a>
<a name="ln486">    for (int i = 0; i &lt; h; ++i)</a>
<a name="ln487">        add_line(unmarshallString(inf));</a>
<a name="ln488">}</a>
<a name="ln489"> </a>
<a name="ln490">rectangle_iterator map_lines::get_iter() const</a>
<a name="ln491">{</a>
<a name="ln492">    ASSERT(width() &gt; 0);</a>
<a name="ln493">    ASSERT(height() &gt; 0);</a>
<a name="ln494"> </a>
<a name="ln495">    coord_def tl(0, 0);</a>
<a name="ln496">    coord_def br(width() - 1, height() - 1);</a>
<a name="ln497">    return rectangle_iterator(tl, br);</a>
<a name="ln498">}</a>
<a name="ln499"> </a>
<a name="ln500">char map_lines::operator () (const coord_def &amp;c) const</a>
<a name="ln501">{</a>
<a name="ln502">    return lines[c.y][c.x];</a>
<a name="ln503">}</a>
<a name="ln504"> </a>
<a name="ln505">char&amp; map_lines::operator () (const coord_def &amp;c)</a>
<a name="ln506">{</a>
<a name="ln507">    return lines[c.y][c.x];</a>
<a name="ln508">}</a>
<a name="ln509"> </a>
<a name="ln510">char map_lines::operator () (int x, int y) const</a>
<a name="ln511">{</a>
<a name="ln512">    return lines[y][x];</a>
<a name="ln513">}</a>
<a name="ln514"> </a>
<a name="ln515">char&amp; map_lines::operator () (int x, int y)</a>
<a name="ln516">{</a>
<a name="ln517">    return lines[y][x];</a>
<a name="ln518">}</a>
<a name="ln519"> </a>
<a name="ln520">bool map_lines::in_bounds(const coord_def &amp;c) const</a>
<a name="ln521">{</a>
<a name="ln522">    return c.x &gt;= 0 &amp;&amp; c.y &gt;= 0 &amp;&amp; c.x &lt; width() &amp;&amp; c.y &lt; height();</a>
<a name="ln523">}</a>
<a name="ln524"> </a>
<a name="ln525">bool map_lines::in_map(const coord_def &amp;c) const</a>
<a name="ln526">{</a>
<a name="ln527">    return in_bounds(c) &amp;&amp; lines[c.y][c.x] != ' ';</a>
<a name="ln528">}</a>
<a name="ln529"> </a>
<a name="ln530">map_lines &amp;map_lines::operator = (const map_lines &amp;map)</a>
<a name="ln531">{</a>
<a name="ln532">    if (this != &amp;map)</a>
<a name="ln533">        init_from(map);</a>
<a name="ln534">    return *this;</a>
<a name="ln535">}</a>
<a name="ln536"> </a>
<a name="ln537">map_lines::~map_lines()</a>
<a name="ln538">{</a>
<a name="ln539">    clear_markers();</a>
<a name="ln540">}</a>
<a name="ln541"> </a>
<a name="ln542">void map_lines::init_from(const map_lines &amp;map)</a>
<a name="ln543">{</a>
<a name="ln544">    // Markers have to be regenerated, they will not be copied.</a>
<a name="ln545">    clear_markers();</a>
<a name="ln546">    overlay.reset(nullptr);</a>
<a name="ln547">    lines            = map.lines;</a>
<a name="ln548">    map_width        = map.map_width;</a>
<a name="ln549">    solid_north      = map.solid_north;</a>
<a name="ln550">    solid_east       = map.solid_east;</a>
<a name="ln551">    solid_south      = map.solid_south;</a>
<a name="ln552">    solid_west       = map.solid_west;</a>
<a name="ln553">    solid_checked    = map.solid_checked;</a>
<a name="ln554">}</a>
<a name="ln555"> </a>
<a name="ln556">void map_lines::clear_markers()</a>
<a name="ln557">{</a>
<a name="ln558">    deleteAll(markers);</a>
<a name="ln559">}</a>
<a name="ln560"> </a>
<a name="ln561">void map_lines::add_marker(map_marker *marker)</a>
<a name="ln562">{</a>
<a name="ln563">    markers.push_back(marker);</a>
<a name="ln564">}</a>
<a name="ln565"> </a>
<a name="ln566">string map_lines::add_feature_marker(const string &amp;s)</a>
<a name="ln567">{</a>
<a name="ln568">    string key, arg;</a>
<a name="ln569">    int sep = 0;</a>
<a name="ln570">    string err = mapdef_split_key_item(s, &amp;key, &amp;sep, &amp;arg, -1);</a>
<a name="ln571">    if (!err.empty())</a>
<a name="ln572">        return err;</a>
<a name="ln573"> </a>
<a name="ln574">    map_marker_spec spec(key, arg);</a>
<a name="ln575">    spec.apply_transform(*this);</a>
<a name="ln576"> </a>
<a name="ln577">    return &quot;&quot;;</a>
<a name="ln578">}</a>
<a name="ln579"> </a>
<a name="ln580">string map_lines::add_lua_marker(const string &amp;key, const lua_datum &amp;function)</a>
<a name="ln581">{</a>
<a name="ln582">    map_marker_spec spec(key, function);</a>
<a name="ln583">    spec.apply_transform(*this);</a>
<a name="ln584">    return &quot;&quot;;</a>
<a name="ln585">}</a>
<a name="ln586"> </a>
<a name="ln587">void map_lines::apply_markers(const coord_def &amp;c)</a>
<a name="ln588">{</a>
<a name="ln589">    for (map_marker *marker : markers)</a>
<a name="ln590">    {</a>
<a name="ln591">        marker-&gt;pos += c;</a>
<a name="ln592">        env.markers.add(marker);</a>
<a name="ln593">    }</a>
<a name="ln594">    // *not* clear_markers() since we've offloaded marker ownership to</a>
<a name="ln595">    // the crawl env.</a>
<a name="ln596">    markers.clear();</a>
<a name="ln597">}</a>
<a name="ln598"> </a>
<a name="ln599">void map_lines::apply_grid_overlay(const coord_def &amp;c, bool is_layout)</a>
<a name="ln600">{</a>
<a name="ln601">    if (!overlay)</a>
<a name="ln602">        return;</a>
<a name="ln603"> </a>
<a name="ln604">    for (int y = height() - 1; y &gt;= 0; --y)</a>
<a name="ln605">        for (int x = width() - 1; x &gt;= 0; --x)</a>
<a name="ln606">        {</a>
<a name="ln607">            coord_def gc(c.x + x, c.y + y);</a>
<a name="ln608">            if (is_layout &amp;&amp; map_masked(gc, MMT_VAULT))</a>
<a name="ln609">                continue;</a>
<a name="ln610"> </a>
<a name="ln611">            const int colour = (*overlay)(x, y).colour;</a>
<a name="ln612">            if (colour)</a>
<a name="ln613">                dgn_set_grid_colour_at(gc, colour);</a>
<a name="ln614"> </a>
<a name="ln615">            const terrain_property_t property = (*overlay)(x, y).property;</a>
<a name="ln616">            if (property.flags &gt;= FPROP_BLOODY)</a>
<a name="ln617">            {</a>
<a name="ln618">                 // Over-ride whatever property is already there.</a>
<a name="ln619">                env.pgrid(gc) |= property;</a>
<a name="ln620">            }</a>
<a name="ln621"> </a>
<a name="ln622">            const int fheight = (*overlay)(x, y).height;</a>
<a name="ln623">            if (fheight != INVALID_HEIGHT)</a>
<a name="ln624">            {</a>
<a name="ln625">                if (!env.heightmap)</a>
<a name="ln626">                    dgn_initialise_heightmap();</a>
<a name="ln627">                dgn_height_at(gc) = fheight;</a>
<a name="ln628">            }</a>
<a name="ln629"> </a>
<a name="ln630">            bool has_floor = false, has_rock = false;</a>
<a name="ln631">            string name = (*overlay)(x, y).floortile;</a>
<a name="ln632">            if (!name.empty() &amp;&amp; name != &quot;none&quot;)</a>
<a name="ln633">            {</a>
<a name="ln634">                env.tile_flv(gc).floor_idx =</a>
<a name="ln635">                    store_tilename_get_index(name);</a>
<a name="ln636"> </a>
<a name="ln637">                tileidx_t floor;</a>
<a name="ln638">                tile_dngn_index(name.c_str(), &amp;floor);</a>
<a name="ln639">                if (colour)</a>
<a name="ln640">                    floor = tile_dngn_coloured(floor, colour);</a>
<a name="ln641">                int offset = random2(tile_dngn_count(floor));</a>
<a name="ln642">                env.tile_flv(gc).floor = floor + offset;</a>
<a name="ln643">                has_floor = true;</a>
<a name="ln644">            }</a>
<a name="ln645"> </a>
<a name="ln646">            name = (*overlay)(x, y).rocktile;</a>
<a name="ln647">            if (!name.empty() &amp;&amp; name != &quot;none&quot;)</a>
<a name="ln648">            {</a>
<a name="ln649">                env.tile_flv(gc).wall_idx =</a>
<a name="ln650">                    store_tilename_get_index(name);</a>
<a name="ln651"> </a>
<a name="ln652">                tileidx_t rock;</a>
<a name="ln653">                tile_dngn_index(name.c_str(), &amp;rock);</a>
<a name="ln654">                if (colour)</a>
<a name="ln655">                    rock = tile_dngn_coloured(rock, colour);</a>
<a name="ln656">                int offset = random2(tile_dngn_count(rock));</a>
<a name="ln657">                env.tile_flv(gc).wall = rock + offset;</a>
<a name="ln658">                has_rock = true;</a>
<a name="ln659">            }</a>
<a name="ln660"> </a>
<a name="ln661">            name = (*overlay)(x, y).tile;</a>
<a name="ln662">            if (!name.empty() &amp;&amp; name != &quot;none&quot;)</a>
<a name="ln663">            {</a>
<a name="ln664">                env.tile_flv(gc).feat_idx =</a>
<a name="ln665">                    store_tilename_get_index(name);</a>
<a name="ln666"> </a>
<a name="ln667">                tileidx_t feat;</a>
<a name="ln668">                tile_dngn_index(name.c_str(), &amp;feat);</a>
<a name="ln669"> </a>
<a name="ln670">                if (colour)</a>
<a name="ln671">                    feat = tile_dngn_coloured(feat, colour);</a>
<a name="ln672"> </a>
<a name="ln673">                int offset = 0;</a>
<a name="ln674">                if ((*overlay)(x, y).last_tile)</a>
<a name="ln675">                    offset = tile_dngn_count(feat) - 1;</a>
<a name="ln676">                else</a>
<a name="ln677">                    offset = random2(tile_dngn_count(feat));</a>
<a name="ln678"> </a>
<a name="ln679">                if (!has_floor &amp;&amp; grd(gc) == DNGN_FLOOR)</a>
<a name="ln680">                    env.tile_flv(gc).floor = feat + offset;</a>
<a name="ln681">                else if (!has_rock &amp;&amp; grd(gc) == DNGN_ROCK_WALL)</a>
<a name="ln682">                    env.tile_flv(gc).wall = feat + offset;</a>
<a name="ln683">                else</a>
<a name="ln684">                {</a>
<a name="ln685">                    if ((*overlay)(x, y).no_random)</a>
<a name="ln686">                        offset = 0;</a>
<a name="ln687">                    env.tile_flv(gc).feat = feat + offset;</a>
<a name="ln688">                }</a>
<a name="ln689">            }</a>
<a name="ln690">        }</a>
<a name="ln691">}</a>
<a name="ln692"> </a>
<a name="ln693">void map_lines::apply_overlays(const coord_def &amp;c, bool is_layout)</a>
<a name="ln694">{</a>
<a name="ln695">    apply_markers(c);</a>
<a name="ln696">    apply_grid_overlay(c, is_layout);</a>
<a name="ln697">}</a>
<a name="ln698"> </a>
<a name="ln699">const vector&lt;string&gt; &amp;map_lines::get_lines() const</a>
<a name="ln700">{</a>
<a name="ln701">    return lines;</a>
<a name="ln702">}</a>
<a name="ln703"> </a>
<a name="ln704">vector&lt;string&gt; &amp;map_lines::get_lines()</a>
<a name="ln705">{</a>
<a name="ln706">    return lines;</a>
<a name="ln707">}</a>
<a name="ln708"> </a>
<a name="ln709">void map_lines::add_line(const string &amp;s)</a>
<a name="ln710">{</a>
<a name="ln711">    lines.push_back(s);</a>
<a name="ln712">    if (static_cast&lt;int&gt;(s.length()) &gt; map_width)</a>
<a name="ln713">        map_width = s.length();</a>
<a name="ln714">}</a>
<a name="ln715"> </a>
<a name="ln716">string map_lines::clean_shuffle(string s)</a>
<a name="ln717">{</a>
<a name="ln718">    return replace_all_of(s, &quot; \t&quot;, &quot;&quot;);</a>
<a name="ln719">}</a>
<a name="ln720"> </a>
<a name="ln721">string map_lines::check_block_shuffle(const string &amp;s)</a>
<a name="ln722">{</a>
<a name="ln723">    const vector&lt;string&gt; segs = split_string(&quot;/&quot;, s);</a>
<a name="ln724">    const unsigned seglen = segs[0].length();</a>
<a name="ln725"> </a>
<a name="ln726">    for (const string &amp;seg : segs)</a>
<a name="ln727">    {</a>
<a name="ln728">        if (seglen != seg.length())</a>
<a name="ln729">            return &quot;block shuffle segment length mismatch&quot;;</a>
<a name="ln730">    }</a>
<a name="ln731"> </a>
<a name="ln732">    return &quot;&quot;;</a>
<a name="ln733">}</a>
<a name="ln734"> </a>
<a name="ln735">string map_lines::check_shuffle(string &amp;s)</a>
<a name="ln736">{</a>
<a name="ln737">    if (s.find(',') != string::npos)</a>
<a name="ln738">        return &quot;use / for block shuffle, or multiple SHUFFLE: lines&quot;;</a>
<a name="ln739"> </a>
<a name="ln740">    s = clean_shuffle(s);</a>
<a name="ln741"> </a>
<a name="ln742">    if (s.find('/') != string::npos)</a>
<a name="ln743">        return check_block_shuffle(s);</a>
<a name="ln744"> </a>
<a name="ln745">    return &quot;&quot;;</a>
<a name="ln746">}</a>
<a name="ln747"> </a>
<a name="ln748">string map_lines::check_clear(string &amp;s)</a>
<a name="ln749">{</a>
<a name="ln750">    s = clean_shuffle(s);</a>
<a name="ln751"> </a>
<a name="ln752">    if (!s.length())</a>
<a name="ln753">        return &quot;no glyphs specified for clearing&quot;;</a>
<a name="ln754"> </a>
<a name="ln755">    return &quot;&quot;;</a>
<a name="ln756">}</a>
<a name="ln757"> </a>
<a name="ln758">string map_lines::parse_glyph_replacements(string s, glyph_replacements_t &amp;gly)</a>
<a name="ln759">{</a>
<a name="ln760">    s = replace_all_of(s, &quot;\t&quot;, &quot; &quot;);</a>
<a name="ln761">    for (const string &amp;is : split_string(&quot; &quot;, s))</a>
<a name="ln762">    {</a>
<a name="ln763">        if (is.length() &gt; 2 &amp;&amp; is[1] == ':')</a>
<a name="ln764">        {</a>
<a name="ln765">            const int glych = is[0];</a>
<a name="ln766">            int weight;</a>
<a name="ln767">            if (!parse_int(is.substr(2).c_str(), weight) || weight &lt; 1)</a>
<a name="ln768">                return &quot;Invalid weight specifier in \&quot;&quot; + s + &quot;\&quot;&quot;;</a>
<a name="ln769">            else</a>
<a name="ln770">                gly.emplace_back(glych, weight);</a>
<a name="ln771">        }</a>
<a name="ln772">        else</a>
<a name="ln773">        {</a>
<a name="ln774">            for (int c = 0, cs = is.length(); c &lt; cs; ++c)</a>
<a name="ln775">                gly.emplace_back(is[c], 10);</a>
<a name="ln776">        }</a>
<a name="ln777">    }</a>
<a name="ln778"> </a>
<a name="ln779">    return &quot;&quot;;</a>
<a name="ln780">}</a>
<a name="ln781"> </a>
<a name="ln782">template&lt;class T&gt;</a>
<a name="ln783">static string _parse_weighted_str(const string &amp;spec, T &amp;list)</a>
<a name="ln784">{</a>
<a name="ln785">    for (string val : split_string(&quot;/&quot;, spec))</a>
<a name="ln786">    {</a>
<a name="ln787">        lowercase(val);</a>
<a name="ln788"> </a>
<a name="ln789">        int weight = find_weight(val);</a>
<a name="ln790">        if (weight == TAG_UNFOUND)</a>
<a name="ln791">        {</a>
<a name="ln792">            weight = 10;</a>
<a name="ln793">            // :number suffix?</a>
<a name="ln794">            string::size_type cpos = val.find(':');</a>
<a name="ln795">            if (cpos != string::npos)</a>
<a name="ln796">            {</a>
<a name="ln797">                if (!parse_int(val.substr(cpos + 1).c_str(), weight) || weight &lt;= 0)</a>
<a name="ln798">                    return &quot;Invalid weight specifier in \&quot;&quot; + spec + &quot;\&quot;&quot;;</a>
<a name="ln799">                val.erase(cpos);</a>
<a name="ln800">                trim_string(val);</a>
<a name="ln801">            }</a>
<a name="ln802">        }</a>
<a name="ln803"> </a>
<a name="ln804">        if (!list.parse(val, weight))</a>
<a name="ln805">        {</a>
<a name="ln806">            return make_stringf(&quot;bad spec: '%s' in '%s'&quot;,</a>
<a name="ln807">                                val.c_str(), spec.c_str());</a>
<a name="ln808">        }</a>
<a name="ln809">    }</a>
<a name="ln810">    return &quot;&quot;;</a>
<a name="ln811">}</a>
<a name="ln812"> </a>
<a name="ln813">bool map_colour_list::parse(const string &amp;col, int weight)</a>
<a name="ln814">{</a>
<a name="ln815">    const int colour = col == &quot;none&quot; ? BLACK : str_to_colour(col, -1, false, true);</a>
<a name="ln816">    if (colour == -1)</a>
<a name="ln817">        return false;</a>
<a name="ln818"> </a>
<a name="ln819">    emplace_back(colour, weight);</a>
<a name="ln820">    return true;</a>
<a name="ln821">}</a>
<a name="ln822"> </a>
<a name="ln823">string map_lines::add_colour(const string &amp;sub)</a>
<a name="ln824">{</a>
<a name="ln825">    string s = trimmed_string(sub);</a>
<a name="ln826"> </a>
<a name="ln827">    if (s.empty())</a>
<a name="ln828">        return &quot;&quot;;</a>
<a name="ln829"> </a>
<a name="ln830">    int sep = 0;</a>
<a name="ln831">    string key;</a>
<a name="ln832">    string substitute;</a>
<a name="ln833"> </a>
<a name="ln834">    string err = mapdef_split_key_item(sub, &amp;key, &amp;sep, &amp;substitute, -1);</a>
<a name="ln835">    if (!err.empty())</a>
<a name="ln836">        return err;</a>
<a name="ln837"> </a>
<a name="ln838">    map_colour_list colours;</a>
<a name="ln839">    err = _parse_weighted_str&lt;map_colour_list&gt;(substitute, colours);</a>
<a name="ln840">    if (!err.empty())</a>
<a name="ln841">        return err;</a>
<a name="ln842"> </a>
<a name="ln843">    colour_spec spec(key, sep == ':', colours);</a>
<a name="ln844">    overlay_colours(spec);</a>
<a name="ln845"> </a>
<a name="ln846">    return &quot;&quot;;</a>
<a name="ln847">}</a>
<a name="ln848"> </a>
<a name="ln849">bool map_fprop_list::parse(const string &amp;fp, int weight)</a>
<a name="ln850">{</a>
<a name="ln851">    feature_property_type fprop;</a>
<a name="ln852"> </a>
<a name="ln853">    if (fp == &quot;nothing&quot;)</a>
<a name="ln854">        fprop = FPROP_NONE;</a>
<a name="ln855">    else if (fp.empty())</a>
<a name="ln856">        return false;</a>
<a name="ln857">    else if (str_to_fprop(fp) == FPROP_NONE)</a>
<a name="ln858">        return false;</a>
<a name="ln859">    else</a>
<a name="ln860">        fprop = str_to_fprop(fp);</a>
<a name="ln861"> </a>
<a name="ln862">    emplace_back(fprop, weight);</a>
<a name="ln863">    return true;</a>
<a name="ln864">}</a>
<a name="ln865"> </a>
<a name="ln866">bool map_featheight_list::parse(const string &amp;fp, int weight)</a>
<a name="ln867">{</a>
<a name="ln868">    const int thisheight = strict_aton(fp.c_str(), INVALID_HEIGHT);</a>
<a name="ln869">    if (thisheight == INVALID_HEIGHT)</a>
<a name="ln870">        return false;</a>
<a name="ln871">    emplace_back(thisheight, weight);</a>
<a name="ln872">    return true;</a>
<a name="ln873">}</a>
<a name="ln874"> </a>
<a name="ln875">string map_lines::add_fproperty(const string &amp;sub)</a>
<a name="ln876">{</a>
<a name="ln877">    string s = trimmed_string(sub);</a>
<a name="ln878"> </a>
<a name="ln879">    if (s.empty())</a>
<a name="ln880">        return &quot;&quot;;</a>
<a name="ln881"> </a>
<a name="ln882">    int sep = 0;</a>
<a name="ln883">    string key;</a>
<a name="ln884">    string substitute;</a>
<a name="ln885"> </a>
<a name="ln886">    string err = mapdef_split_key_item(sub, &amp;key, &amp;sep, &amp;substitute, -1);</a>
<a name="ln887">    if (!err.empty())</a>
<a name="ln888">        return err;</a>
<a name="ln889"> </a>
<a name="ln890">    map_fprop_list fprops;</a>
<a name="ln891">    err = _parse_weighted_str&lt;map_fprop_list&gt;(substitute, fprops);</a>
<a name="ln892">    if (!err.empty())</a>
<a name="ln893">        return err;</a>
<a name="ln894"> </a>
<a name="ln895">    fprop_spec spec(key, sep == ':', fprops);</a>
<a name="ln896">    overlay_fprops(spec);</a>
<a name="ln897"> </a>
<a name="ln898">    return &quot;&quot;;</a>
<a name="ln899">}</a>
<a name="ln900"> </a>
<a name="ln901">string map_lines::add_fheight(const string &amp;sub)</a>
<a name="ln902">{</a>
<a name="ln903">    string s = trimmed_string(sub);</a>
<a name="ln904">    if (s.empty())</a>
<a name="ln905">        return &quot;&quot;;</a>
<a name="ln906"> </a>
<a name="ln907">    int sep = 0;</a>
<a name="ln908">    string key;</a>
<a name="ln909">    string substitute;</a>
<a name="ln910"> </a>
<a name="ln911">    string err = mapdef_split_key_item(sub, &amp;key, &amp;sep, &amp;substitute, -1);</a>
<a name="ln912">    if (!err.empty())</a>
<a name="ln913">        return err;</a>
<a name="ln914"> </a>
<a name="ln915">    map_featheight_list fheights;</a>
<a name="ln916">    err = _parse_weighted_str(substitute, fheights);</a>
<a name="ln917">    if (!err.empty())</a>
<a name="ln918">        return err;</a>
<a name="ln919"> </a>
<a name="ln920">    fheight_spec spec(key, sep == ':', fheights);</a>
<a name="ln921">    overlay_fheights(spec);</a>
<a name="ln922"> </a>
<a name="ln923">    return &quot;&quot;;</a>
<a name="ln924">}</a>
<a name="ln925"> </a>
<a name="ln926">bool map_string_list::parse(const string &amp;fp, int weight)</a>
<a name="ln927">{</a>
<a name="ln928">    emplace_back(fp, weight);</a>
<a name="ln929">    return !fp.empty();</a>
<a name="ln930">}</a>
<a name="ln931"> </a>
<a name="ln932">string map_lines::add_subst(const string &amp;sub)</a>
<a name="ln933">{</a>
<a name="ln934">    string s = trimmed_string(sub);</a>
<a name="ln935"> </a>
<a name="ln936">    if (s.empty())</a>
<a name="ln937">        return &quot;&quot;;</a>
<a name="ln938"> </a>
<a name="ln939">    int sep = 0;</a>
<a name="ln940">    string key;</a>
<a name="ln941">    string substitute;</a>
<a name="ln942"> </a>
<a name="ln943">    string err = mapdef_split_key_item(sub, &amp;key, &amp;sep, &amp;substitute, -1);</a>
<a name="ln944">    if (!err.empty())</a>
<a name="ln945">        return err;</a>
<a name="ln946"> </a>
<a name="ln947">    glyph_replacements_t repl;</a>
<a name="ln948">    err = parse_glyph_replacements(substitute, repl);</a>
<a name="ln949">    if (!err.empty())</a>
<a name="ln950">        return err;</a>
<a name="ln951"> </a>
<a name="ln952">    subst_spec spec(key, sep == ':', repl);</a>
<a name="ln953">    subst(spec);</a>
<a name="ln954"> </a>
<a name="ln955">    return &quot;&quot;;</a>
<a name="ln956">}</a>
<a name="ln957"> </a>
<a name="ln958">string map_lines::parse_nsubst_spec(const string &amp;s, subst_spec &amp;spec)</a>
<a name="ln959">{</a>
<a name="ln960">    string key, arg;</a>
<a name="ln961">    int sep;</a>
<a name="ln962">    string err = mapdef_split_key_item(s, &amp;key, &amp;sep, &amp;arg, -1);</a>
<a name="ln963">    if (!err.empty())</a>
<a name="ln964">        return err;</a>
<a name="ln965">    int count = 0;</a>
<a name="ln966">    if (key == &quot;*&quot;)</a>
<a name="ln967">        count = -1;</a>
<a name="ln968">    else</a>
<a name="ln969">        parse_int(key.c_str(), count);</a>
<a name="ln970">    if (!count)</a>
<a name="ln971">        return make_stringf(&quot;Illegal spec: %s&quot;, s.c_str());</a>
<a name="ln972"> </a>
<a name="ln973">    glyph_replacements_t repl;</a>
<a name="ln974">    err = parse_glyph_replacements(arg, repl);</a>
<a name="ln975">    if (!err.empty())</a>
<a name="ln976">        return err;</a>
<a name="ln977"> </a>
<a name="ln978">    spec = subst_spec(count, sep == ':', repl);</a>
<a name="ln979">    return &quot;&quot;;</a>
<a name="ln980">}</a>
<a name="ln981"> </a>
<a name="ln982">string map_lines::add_nsubst(const string &amp;s)</a>
<a name="ln983">{</a>
<a name="ln984">    vector&lt;subst_spec&gt; substs;</a>
<a name="ln985"> </a>
<a name="ln986">    int sep;</a>
<a name="ln987">    string key, arg;</a>
<a name="ln988"> </a>
<a name="ln989">    string err = mapdef_split_key_item(s, &amp;key, &amp;sep, &amp;arg, -1);</a>
<a name="ln990">    if (!err.empty())</a>
<a name="ln991">        return err;</a>
<a name="ln992"> </a>
<a name="ln993">    vector&lt;string&gt; segs = split_string(&quot;/&quot;, arg);</a>
<a name="ln994">    for (int i = 0, vsize = segs.size(); i &lt; vsize; ++i)</a>
<a name="ln995">    {</a>
<a name="ln996">        string &amp;ns = segs[i];</a>
<a name="ln997">        if (ns.find('=') == string::npos &amp;&amp; ns.find(':') == string::npos)</a>
<a name="ln998">        {</a>
<a name="ln999">            if (i &lt; vsize - 1)</a>
<a name="ln1000">                ns = &quot;1=&quot; + ns;</a>
<a name="ln1001">            else</a>
<a name="ln1002">                ns = &quot;*=&quot; + ns;</a>
<a name="ln1003">        }</a>
<a name="ln1004">        subst_spec spec;</a>
<a name="ln1005">        err = parse_nsubst_spec(ns, spec);</a>
<a name="ln1006">        if (!err.empty())</a>
<a name="ln1007">        {</a>
<a name="ln1008">            return make_stringf(&quot;Bad NSUBST spec: %s (%s)&quot;,</a>
<a name="ln1009">                                s.c_str(), err.c_str());</a>
<a name="ln1010">        }</a>
<a name="ln1011">        substs.push_back(spec);</a>
<a name="ln1012">    }</a>
<a name="ln1013"> </a>
<a name="ln1014">    nsubst_spec spec(key, substs);</a>
<a name="ln1015">    nsubst(spec);</a>
<a name="ln1016"> </a>
<a name="ln1017">    return &quot;&quot;;</a>
<a name="ln1018">}</a>
<a name="ln1019"> </a>
<a name="ln1020">string map_lines::add_shuffle(const string &amp;raws)</a>
<a name="ln1021">{</a>
<a name="ln1022">    string s = raws;</a>
<a name="ln1023">    const string err = check_shuffle(s);</a>
<a name="ln1024"> </a>
<a name="ln1025">    if (err.empty())</a>
<a name="ln1026">        resolve_shuffle(s);</a>
<a name="ln1027"> </a>
<a name="ln1028">    return err;</a>
<a name="ln1029">}</a>
<a name="ln1030"> </a>
<a name="ln1031">string map_lines::add_clear(const string &amp;raws)</a>
<a name="ln1032">{</a>
<a name="ln1033">    string s = raws;</a>
<a name="ln1034">    const string err = check_clear(s);</a>
<a name="ln1035"> </a>
<a name="ln1036">    if (err.empty())</a>
<a name="ln1037">        clear(s);</a>
<a name="ln1038"> </a>
<a name="ln1039">    return err;</a>
<a name="ln1040">}</a>
<a name="ln1041"> </a>
<a name="ln1042">int map_lines::width() const</a>
<a name="ln1043">{</a>
<a name="ln1044">    return map_width;</a>
<a name="ln1045">}</a>
<a name="ln1046"> </a>
<a name="ln1047">int map_lines::height() const</a>
<a name="ln1048">{</a>
<a name="ln1049">    return lines.size();</a>
<a name="ln1050">}</a>
<a name="ln1051"> </a>
<a name="ln1052">void map_lines::extend(int min_width, int min_height, char fill)</a>
<a name="ln1053">{</a>
<a name="ln1054">    min_width = max(1, min_width);</a>
<a name="ln1055">    min_height = max(1, min_height);</a>
<a name="ln1056"> </a>
<a name="ln1057">    bool dirty = false;</a>
<a name="ln1058">    int old_width = width();</a>
<a name="ln1059">    int old_height = height();</a>
<a name="ln1060"> </a>
<a name="ln1061">    if (static_cast&lt;int&gt;(lines.size()) &lt; min_height)</a>
<a name="ln1062">    {</a>
<a name="ln1063">        dirty = true;</a>
<a name="ln1064">        while (static_cast&lt;int&gt;(lines.size()) &lt; min_height)</a>
<a name="ln1065">            add_line(string(min_width, fill));</a>
<a name="ln1066">    }</a>
<a name="ln1067"> </a>
<a name="ln1068">    if (width() &lt; min_width)</a>
<a name="ln1069">    {</a>
<a name="ln1070">        dirty = true;</a>
<a name="ln1071">        lines[0] += string(min_width - width(), fill);</a>
<a name="ln1072">        map_width = max(map_width, min_width);</a>
<a name="ln1073">    }</a>
<a name="ln1074"> </a>
<a name="ln1075">    if (!dirty)</a>
<a name="ln1076">        return;</a>
<a name="ln1077"> </a>
<a name="ln1078">    normalise(fill);</a>
<a name="ln1079"> </a>
<a name="ln1080">    // Extend overlay matrix as well.</a>
<a name="ln1081">    if (overlay)</a>
<a name="ln1082">    {</a>
<a name="ln1083">        auto new_overlay = make_unique&lt;overlay_matrix&gt;(width(), height());</a>
<a name="ln1084"> </a>
<a name="ln1085">        for (int y = 0; y &lt; old_height; ++y)</a>
<a name="ln1086">            for (int x = 0; x &lt; old_width; ++x)</a>
<a name="ln1087">                (*new_overlay)(x, y) = (*overlay)(x, y);</a>
<a name="ln1088"> </a>
<a name="ln1089">        overlay = move(new_overlay);</a>
<a name="ln1090">    }</a>
<a name="ln1091">}</a>
<a name="ln1092"> </a>
<a name="ln1093">coord_def map_lines::size() const</a>
<a name="ln1094">{</a>
<a name="ln1095">    return coord_def(width(), height());</a>
<a name="ln1096">}</a>
<a name="ln1097"> </a>
<a name="ln1098">int map_lines::glyph(int x, int y) const</a>
<a name="ln1099">{</a>
<a name="ln1100">    return lines[y][x];</a>
<a name="ln1101">}</a>
<a name="ln1102"> </a>
<a name="ln1103">int map_lines::glyph(const coord_def &amp;c) const</a>
<a name="ln1104">{</a>
<a name="ln1105">    return glyph(c.x, c.y);</a>
<a name="ln1106">}</a>
<a name="ln1107"> </a>
<a name="ln1108">bool map_lines::is_solid(int gly) const</a>
<a name="ln1109">{</a>
<a name="ln1110">    return gly == 'x' || gly == 'c' || gly == 'b' || gly == 'v' || gly == 't'</a>
<a name="ln1111">           || gly == 'X';</a>
<a name="ln1112">}</a>
<a name="ln1113"> </a>
<a name="ln1114">void map_lines::check_borders()</a>
<a name="ln1115">{</a>
<a name="ln1116">    if (solid_checked)</a>
<a name="ln1117">        return;</a>
<a name="ln1118"> </a>
<a name="ln1119">    const int wide = width(), high = height();</a>
<a name="ln1120"> </a>
<a name="ln1121">    solid_north = solid_south = true;</a>
<a name="ln1122">    for (int x = 0; x &lt; wide &amp;&amp; (solid_north || solid_south); ++x)</a>
<a name="ln1123">    {</a>
<a name="ln1124">        if (solid_north &amp;&amp; !is_solid(glyph(x, 0)))</a>
<a name="ln1125">            solid_north = false;</a>
<a name="ln1126">        if (solid_south &amp;&amp; !is_solid(glyph(x, high - 1)))</a>
<a name="ln1127">            solid_south = false;</a>
<a name="ln1128">    }</a>
<a name="ln1129"> </a>
<a name="ln1130">    solid_east = solid_west = true;</a>
<a name="ln1131">    for (int y = 0; y &lt; high &amp;&amp; (solid_east || solid_west); ++y)</a>
<a name="ln1132">    {</a>
<a name="ln1133">        if (solid_west &amp;&amp; !is_solid(glyph(0, y)))</a>
<a name="ln1134">            solid_west = false;</a>
<a name="ln1135">        if (solid_east &amp;&amp; !is_solid(glyph(wide - 1, y)))</a>
<a name="ln1136">            solid_east = false;</a>
<a name="ln1137">    }</a>
<a name="ln1138"> </a>
<a name="ln1139">    solid_checked = true;</a>
<a name="ln1140">}</a>
<a name="ln1141"> </a>
<a name="ln1142">bool map_lines::solid_borders(map_section_type border)</a>
<a name="ln1143">{</a>
<a name="ln1144">    check_borders();</a>
<a name="ln1145">    switch (border)</a>
<a name="ln1146">    {</a>
<a name="ln1147">    case MAP_NORTH: return solid_north;</a>
<a name="ln1148">    case MAP_SOUTH: return solid_south;</a>
<a name="ln1149">    case MAP_EAST:  return solid_east;</a>
<a name="ln1150">    case MAP_WEST:  return solid_west;</a>
<a name="ln1151">    case MAP_NORTHEAST: return solid_north &amp;&amp; solid_east;</a>
<a name="ln1152">    case MAP_NORTHWEST: return solid_north &amp;&amp; solid_west;</a>
<a name="ln1153">    case MAP_SOUTHEAST: return solid_south &amp;&amp; solid_east;</a>
<a name="ln1154">    case MAP_SOUTHWEST: return solid_south &amp;&amp; solid_west;</a>
<a name="ln1155">    default: return false;</a>
<a name="ln1156">    }</a>
<a name="ln1157">}</a>
<a name="ln1158"> </a>
<a name="ln1159">void map_lines::clear()</a>
<a name="ln1160">{</a>
<a name="ln1161">    clear_markers();</a>
<a name="ln1162">    lines.clear();</a>
<a name="ln1163">    keyspecs.clear();</a>
<a name="ln1164">    overlay.reset(nullptr);</a>
<a name="ln1165">    map_width = 0;</a>
<a name="ln1166">    solid_checked = false;</a>
<a name="ln1167"> </a>
<a name="ln1168">    // First non-legal character.</a>
<a name="ln1169">    next_keyspec_idx = 256;</a>
<a name="ln1170">}</a>
<a name="ln1171"> </a>
<a name="ln1172">void map_lines::subst(string &amp;s, subst_spec &amp;spec)</a>
<a name="ln1173">{</a>
<a name="ln1174">    string::size_type pos = 0;</a>
<a name="ln1175">    while ((pos = s.find_first_of(spec.key, pos)) != string::npos)</a>
<a name="ln1176">        s[pos++] = spec.value();</a>
<a name="ln1177">}</a>
<a name="ln1178"> </a>
<a name="ln1179">void map_lines::subst(subst_spec &amp;spec)</a>
<a name="ln1180">{</a>
<a name="ln1181">    ASSERT(!spec.key.empty());</a>
<a name="ln1182">    for (string &amp;line : lines)</a>
<a name="ln1183">        subst(line, spec);</a>
<a name="ln1184">}</a>
<a name="ln1185"> </a>
<a name="ln1186">void map_lines::bind_overlay()</a>
<a name="ln1187">{</a>
<a name="ln1188">    if (!overlay)</a>
<a name="ln1189">        overlay.reset(new overlay_matrix(width(), height()));</a>
<a name="ln1190">}</a>
<a name="ln1191"> </a>
<a name="ln1192">void map_lines::overlay_colours(colour_spec &amp;spec)</a>
<a name="ln1193">{</a>
<a name="ln1194">    bind_overlay();</a>
<a name="ln1195">    for (iterator mi(*this, spec.key); mi; ++mi)</a>
<a name="ln1196">        (*overlay)(*mi).colour = spec.get_colour();</a>
<a name="ln1197">}</a>
<a name="ln1198"> </a>
<a name="ln1199">void map_lines::overlay_fprops(fprop_spec &amp;spec)</a>
<a name="ln1200">{</a>
<a name="ln1201">    bind_overlay();</a>
<a name="ln1202">    for (iterator mi(*this, spec.key); mi; ++mi)</a>
<a name="ln1203">        (*overlay)(*mi).property |= spec.get_property();</a>
<a name="ln1204">}</a>
<a name="ln1205"> </a>
<a name="ln1206">void map_lines::overlay_fheights(fheight_spec &amp;spec)</a>
<a name="ln1207">{</a>
<a name="ln1208">    bind_overlay();</a>
<a name="ln1209">    for (iterator mi(*this, spec.key); mi; ++mi)</a>
<a name="ln1210">        (*overlay)(*mi).height = spec.get_height();</a>
<a name="ln1211">}</a>
<a name="ln1212"> </a>
<a name="ln1213">void map_lines::fill_mask_matrix(const string &amp;glyphs,</a>
<a name="ln1214">                                 const coord_def &amp;tl,</a>
<a name="ln1215">                                 const coord_def &amp;br,</a>
<a name="ln1216">                                 Matrix&lt;bool&gt; &amp;flags)</a>
<a name="ln1217">{</a>
<a name="ln1218">    ASSERT(tl.x &gt;= 0);</a>
<a name="ln1219">    ASSERT(tl.y &gt;= 0);</a>
<a name="ln1220">    ASSERT(br.x &lt; width());</a>
<a name="ln1221">    ASSERT(br.y &lt; height());</a>
<a name="ln1222">    ASSERT(tl.x &lt;= br.x);</a>
<a name="ln1223">    ASSERT(tl.y &lt;= br.y);</a>
<a name="ln1224"> </a>
<a name="ln1225">    for (int y = tl.y; y &lt;= br.y; ++y)</a>
<a name="ln1226">        for (int x = tl.x; x &lt;= br.x; ++x)</a>
<a name="ln1227">        {</a>
<a name="ln1228">            int ox = x - tl.x;</a>
<a name="ln1229">            int oy = y - tl.y;</a>
<a name="ln1230">            flags(ox, oy) = (strchr(glyphs.c_str(), (*this)(x, y)) != nullptr);</a>
<a name="ln1231">        }</a>
<a name="ln1232">}</a>
<a name="ln1233"> </a>
<a name="ln1234">map_corner_t map_lines::merge_subvault(const coord_def &amp;mtl,</a>
<a name="ln1235">                                       const coord_def &amp;mbr,</a>
<a name="ln1236">                                       const Matrix&lt;bool&gt; &amp;mask,</a>
<a name="ln1237">                                       const map_def &amp;vmap)</a>
<a name="ln1238">{</a>
<a name="ln1239">    const map_lines &amp;vlines = vmap.map;</a>
<a name="ln1240"> </a>
<a name="ln1241">    // If vault is bigger than the mask region (mtl, mbr), then it gets</a>
<a name="ln1242">    // randomly centered. (vtl, vbr) stores the vault's region.</a>
<a name="ln1243">    coord_def vtl = mtl;</a>
<a name="ln1244">    coord_def vbr = mbr;</a>
<a name="ln1245"> </a>
<a name="ln1246">    int width_diff = (mbr.x - mtl.x + 1) - vlines.width();</a>
<a name="ln1247">    int height_diff = (mbr.y - mtl.y + 1) - vlines.height();</a>
<a name="ln1248"> </a>
<a name="ln1249">    // Adjust vault coords with a random offset.</a>
<a name="ln1250">    int ox = random2(width_diff + 1);</a>
<a name="ln1251">    int oy = random2(height_diff + 1);</a>
<a name="ln1252">    vtl.x += ox;</a>
<a name="ln1253">    vtl.y += oy;</a>
<a name="ln1254">    vbr.x -= (width_diff - ox);</a>
<a name="ln1255">    vbr.y -= (height_diff - oy);</a>
<a name="ln1256"> </a>
<a name="ln1257">    if (!overlay)</a>
<a name="ln1258">        overlay.reset(new overlay_matrix(width(), height()));</a>
<a name="ln1259"> </a>
<a name="ln1260">    // Clear any markers in the vault's grid</a>
<a name="ln1261">    for (size_t i = 0; i &lt; markers.size(); ++i)</a>
<a name="ln1262">    {</a>
<a name="ln1263">        map_marker *mm = markers[i];</a>
<a name="ln1264">        if (mm-&gt;pos.x &gt;= vtl.x &amp;&amp; mm-&gt;pos.x &lt;= vbr.x</a>
<a name="ln1265">            &amp;&amp; mm-&gt;pos.y &gt;= vtl.y &amp;&amp; mm-&gt;pos.y &lt;= vbr.y)</a>
<a name="ln1266">        {</a>
<a name="ln1267">            const coord_def maskc = mm-&gt;pos - mtl;</a>
<a name="ln1268">            if (!mask(maskc.x, maskc.y))</a>
<a name="ln1269">                continue;</a>
<a name="ln1270"> </a>
<a name="ln1271">            // Erase this marker.</a>
<a name="ln1272">            markers[i] = markers[markers.size() - 1];</a>
<a name="ln1273">            markers.resize(markers.size() - 1);</a>
<a name="ln1274">            i--;</a>
<a name="ln1275">        }</a>
<a name="ln1276">    }</a>
<a name="ln1277"> </a>
<a name="ln1278">    // Copy markers and update locations.</a>
<a name="ln1279">    for (map_marker *mm : vlines.markers)</a>
<a name="ln1280">    {</a>
<a name="ln1281">        coord_def mapc = mm-&gt;pos + vtl;</a>
<a name="ln1282">        coord_def maskc = mapc - mtl;</a>
<a name="ln1283"> </a>
<a name="ln1284">        if (!mask(maskc.x, maskc.y))</a>
<a name="ln1285">            continue;</a>
<a name="ln1286"> </a>
<a name="ln1287">        map_marker *clone = mm-&gt;clone();</a>
<a name="ln1288">        clone-&gt;pos = mapc;</a>
<a name="ln1289">        add_marker(clone);</a>
<a name="ln1290">    }</a>
<a name="ln1291"> </a>
<a name="ln1292">    unsigned mask_tags = 0;</a>
<a name="ln1293"> </a>
<a name="ln1294">    // TODO: merge the matching of tags to MMTs into a function that is</a>
<a name="ln1295">    // called from both here and dungeon.cc::dgn_register_place.</a>
<a name="ln1296">    if (vmap.has_tag(&quot;no_monster_gen&quot;))</a>
<a name="ln1297">        mask_tags |= MMT_NO_MONS;</a>
<a name="ln1298">    if (vmap.has_tag(&quot;no_item_gen&quot;))</a>
<a name="ln1299">        mask_tags |= MMT_NO_ITEM;</a>
<a name="ln1300">    if (vmap.has_tag(&quot;no_pool_fixup&quot;))</a>
<a name="ln1301">        mask_tags |= MMT_NO_POOL;</a>
<a name="ln1302">    if (vmap.has_tag(&quot;no_wall_fixup&quot;))</a>
<a name="ln1303">        mask_tags |= MMT_NO_WALL;</a>
<a name="ln1304">    if (vmap.has_tag(&quot;no_trap_gen&quot;))</a>
<a name="ln1305">        mask_tags |= MMT_NO_TRAP;</a>
<a name="ln1306"> </a>
<a name="ln1307">    // Cache keyspecs we've already pushed into the extended keyspec space.</a>
<a name="ln1308">    // If !ksmap[key], then we haven't seen the 'key' glyph before.</a>
<a name="ln1309">    keyspec_map ksmap(0);</a>
<a name="ln1310"> </a>
<a name="ln1311">    for (int y = mtl.y; y &lt;= mbr.y; ++y)</a>
<a name="ln1312">        for (int x = mtl.x; x &lt;= mbr.x; ++x)</a>
<a name="ln1313">        {</a>
<a name="ln1314">            int mx = x - mtl.x;</a>
<a name="ln1315">            int my = y - mtl.y;</a>
<a name="ln1316">            if (!mask(mx, my))</a>
<a name="ln1317">                continue;</a>
<a name="ln1318"> </a>
<a name="ln1319">            // Outside subvault?</a>
<a name="ln1320">            if (x &lt; vtl.x || x &gt; vbr.x || y &lt; vtl.y || y &gt; vbr.y)</a>
<a name="ln1321">                continue;</a>
<a name="ln1322"> </a>
<a name="ln1323">            int vx = x - vtl.x;</a>
<a name="ln1324">            int vy = y - vtl.y;</a>
<a name="ln1325">            coord_def vc(vx, vy);</a>
<a name="ln1326"> </a>
<a name="ln1327">            char c = vlines(vc);</a>
<a name="ln1328">            if (c == ' ')</a>
<a name="ln1329">                continue;</a>
<a name="ln1330"> </a>
<a name="ln1331">            // Merge keyspecs.</a>
<a name="ln1332">            // Push vault keyspecs into extended keyspecs.</a>
<a name="ln1333">            // Push MONS/ITEM into KMONS/KITEM keyspecs.</a>
<a name="ln1334">            // Generate KFEAT keyspecs for any normal glyphs.</a>
<a name="ln1335">            int idx;</a>
<a name="ln1336">            if (ksmap[c])</a>
<a name="ln1337">            {</a>
<a name="ln1338">                // Already generated this keyed_pmapspec.</a>
<a name="ln1339">                idx = ksmap[c];</a>
<a name="ln1340">            }</a>
<a name="ln1341">            else</a>
<a name="ln1342">            {</a>
<a name="ln1343">                idx = next_keyspec_idx++;</a>
<a name="ln1344">                ASSERT(idx &gt; 0);</a>
<a name="ln1345"> </a>
<a name="ln1346">                if (c != SUBVAULT_GLYPH)</a>
<a name="ln1347">                    ksmap[c] = idx;</a>
<a name="ln1348"> </a>
<a name="ln1349">                const keyed_mapspec *kspec = vlines.mapspec_at(vc);</a>
<a name="ln1350"> </a>
<a name="ln1351">                // If c is a SUBVAULT_GLYPH, it came from a sub-subvault.</a>
<a name="ln1352">                // Sub-subvaults should always have mapspecs at this point.</a>
<a name="ln1353">                ASSERT(c != SUBVAULT_GLYPH || kspec);</a>
<a name="ln1354"> </a>
<a name="ln1355">                if (kspec)</a>
<a name="ln1356">                {</a>
<a name="ln1357">                    // Copy vault keyspec into the extended keyspecs.</a>
<a name="ln1358">                    keyspecs[idx] = *kspec;</a>
<a name="ln1359">                    keyspecs[idx].key_glyph = SUBVAULT_GLYPH;</a>
<a name="ln1360">                }</a>
<a name="ln1361">                else if (map_def::valid_monster_array_glyph(c))</a>
<a name="ln1362">                {</a>
<a name="ln1363">                    // Translate monster array into keyed_mapspec</a>
<a name="ln1364">                    keyed_mapspec &amp;km = keyspecs[idx];</a>
<a name="ln1365">                    km.key_glyph = SUBVAULT_GLYPH;</a>
<a name="ln1366"> </a>
<a name="ln1367">                    km.feat.feats.clear();</a>
<a name="ln1368">                    feature_spec spec(-1);</a>
<a name="ln1369">                    spec.glyph = '.';</a>
<a name="ln1370">                    km.feat.feats.insert(km.feat.feats.begin(), spec);</a>
<a name="ln1371"> </a>
<a name="ln1372">                    int slot = map_def::monster_array_glyph_to_slot(c);</a>
<a name="ln1373">                    km.mons.set_from_slot(vmap.mons, slot);</a>
<a name="ln1374">                }</a>
<a name="ln1375">                else if (map_def::valid_item_array_glyph(c))</a>
<a name="ln1376">                {</a>
<a name="ln1377">                    // Translate item array into keyed_mapspec</a>
<a name="ln1378">                    keyed_mapspec &amp;km = keyspecs[idx];</a>
<a name="ln1379">                    km.key_glyph = SUBVAULT_GLYPH;</a>
<a name="ln1380"> </a>
<a name="ln1381">                    km.feat.feats.clear();</a>
<a name="ln1382">                    feature_spec spec(-1);</a>
<a name="ln1383">                    spec.glyph = '.';</a>
<a name="ln1384">                    km.feat.feats.insert(km.feat.feats.begin(), spec);</a>
<a name="ln1385"> </a>
<a name="ln1386">                    int slot = map_def::item_array_glyph_to_slot(c);</a>
<a name="ln1387">                    km.item.set_from_slot(vmap.items, slot);</a>
<a name="ln1388">                }</a>
<a name="ln1389">                else</a>
<a name="ln1390">                {</a>
<a name="ln1391">                    // Normal glyph. Turn into a feature keyspec.</a>
<a name="ln1392">                    // This is valid for non-array items and monsters</a>
<a name="ln1393">                    // as well, e.g. '$' and '8'.</a>
<a name="ln1394">                    keyed_mapspec &amp;km = keyspecs[idx];</a>
<a name="ln1395">                    km.key_glyph = SUBVAULT_GLYPH;</a>
<a name="ln1396">                    km.feat.feats.clear();</a>
<a name="ln1397"> </a>
<a name="ln1398">                    feature_spec spec(-1);</a>
<a name="ln1399">                    spec.glyph = c;</a>
<a name="ln1400">                    km.feat.feats.insert(km.feat.feats.begin(), spec);</a>
<a name="ln1401">                }</a>
<a name="ln1402"> </a>
<a name="ln1403">                // Add overall tags to the keyspec.</a>
<a name="ln1404">                keyspecs[idx].map_mask.flags_set</a>
<a name="ln1405">                    |= (mask_tags &amp; ~keyspecs[idx].map_mask.flags_unset);</a>
<a name="ln1406">            }</a>
<a name="ln1407"> </a>
<a name="ln1408">            // Finally, handle merging the cell itself.</a>
<a name="ln1409"> </a>
<a name="ln1410">            // Glyph becomes SUBVAULT_GLYPH. (The old glyph gets merged into a</a>
<a name="ln1411">            // keyspec, above). This is so that the glyphs that are included</a>
<a name="ln1412">            // from a subvault are immutable by the parent vault. Otherwise,</a>
<a name="ln1413">            // latent transformations (like KMONS or KITEM) from the parent</a>
<a name="ln1414">            // vault might confusingly modify a glyph from the subvault.</a>
<a name="ln1415">            //</a>
<a name="ln1416">            // NOTE: It'd be possible to allow subvaults to be modified by the</a>
<a name="ln1417">            // parent vault, but KMONS/KITEM/KFEAT/MONS/ITEM would have to</a>
<a name="ln1418">            // apply immediately instead of latently. They would also then</a>
<a name="ln1419">            // need to be stored per-coord, rather than per-glyph.</a>
<a name="ln1420">            (*this)(x, y) = SUBVAULT_GLYPH;</a>
<a name="ln1421"> </a>
<a name="ln1422">            // Merge overlays</a>
<a name="ln1423">            if (vlines.overlay)</a>
<a name="ln1424">                (*overlay)(x, y) = (*vlines.overlay)(vx, vy);</a>
<a name="ln1425">            else</a>
<a name="ln1426">            {</a>
<a name="ln1427">                // Erase any existing overlay, as the vault's doesn't exist.</a>
<a name="ln1428">                (*overlay)(x, y) = overlay_def();</a>
<a name="ln1429">            }</a>
<a name="ln1430"> </a>
<a name="ln1431">            // Set keyspec index for this subvault.</a>
<a name="ln1432">            (*overlay)(x, y).keyspec_idx = idx;</a>
<a name="ln1433">        }</a>
<a name="ln1434"> </a>
<a name="ln1435">    return map_corner_t(vtl, vbr);</a>
<a name="ln1436">}</a>
<a name="ln1437"> </a>
<a name="ln1438">void map_lines::overlay_tiles(tile_spec &amp;spec)</a>
<a name="ln1439">{</a>
<a name="ln1440">    if (!overlay)</a>
<a name="ln1441">        overlay.reset(new overlay_matrix(width(), height()));</a>
<a name="ln1442"> </a>
<a name="ln1443">    for (int y = 0, ysize = lines.size(); y &lt; ysize; ++y)</a>
<a name="ln1444">    {</a>
<a name="ln1445">        string::size_type pos = 0;</a>
<a name="ln1446">        while ((pos = lines[y].find_first_of(spec.key, pos)) != string::npos)</a>
<a name="ln1447">        {</a>
<a name="ln1448">            if (spec.floor)</a>
<a name="ln1449">                (*overlay)(pos, y).floortile = spec.get_tile();</a>
<a name="ln1450">            else if (spec.feat)</a>
<a name="ln1451">                (*overlay)(pos, y).tile      = spec.get_tile();</a>
<a name="ln1452">            else</a>
<a name="ln1453">                (*overlay)(pos, y).rocktile  = spec.get_tile();</a>
<a name="ln1454"> </a>
<a name="ln1455">            (*overlay)(pos, y).no_random = spec.no_random;</a>
<a name="ln1456">            (*overlay)(pos, y).last_tile = spec.last_tile;</a>
<a name="ln1457">            ++pos;</a>
<a name="ln1458">        }</a>
<a name="ln1459">    }</a>
<a name="ln1460">}</a>
<a name="ln1461"> </a>
<a name="ln1462">void map_lines::nsubst(nsubst_spec &amp;spec)</a>
<a name="ln1463">{</a>
<a name="ln1464">    vector&lt;coord_def&gt; positions;</a>
<a name="ln1465">    for (int y = 0, ysize = lines.size(); y &lt; ysize; ++y)</a>
<a name="ln1466">    {</a>
<a name="ln1467">        string::size_type pos = 0;</a>
<a name="ln1468">        while ((pos = lines[y].find_first_of(spec.key, pos)) != string::npos)</a>
<a name="ln1469">            positions.emplace_back(pos++, y);</a>
<a name="ln1470">    }</a>
<a name="ln1471">    shuffle_array(positions);</a>
<a name="ln1472"> </a>
<a name="ln1473">    int pcount = 0;</a>
<a name="ln1474">    const int psize = positions.size();</a>
<a name="ln1475">    for (int i = 0, vsize = spec.specs.size();</a>
<a name="ln1476">         i &lt; vsize &amp;&amp; pcount &lt; psize; ++i)</a>
<a name="ln1477">    {</a>
<a name="ln1478">        const int nsubsts = spec.specs[i].count;</a>
<a name="ln1479">        pcount += apply_nsubst(positions, pcount, nsubsts, spec.specs[i]);</a>
<a name="ln1480">    }</a>
<a name="ln1481">}</a>
<a name="ln1482"> </a>
<a name="ln1483">int map_lines::apply_nsubst(vector&lt;coord_def&gt; &amp;pos, int start, int nsub,</a>
<a name="ln1484">                            subst_spec &amp;spec)</a>
<a name="ln1485">{</a>
<a name="ln1486">    if (nsub == -1)</a>
<a name="ln1487">        nsub = pos.size();</a>
<a name="ln1488">    const int end = min(start + nsub, (int) pos.size());</a>
<a name="ln1489">    int substituted = 0;</a>
<a name="ln1490">    for (int i = start; i &lt; end; ++i)</a>
<a name="ln1491">    {</a>
<a name="ln1492">        const int val = spec.value();</a>
<a name="ln1493">        const coord_def &amp;c = pos[i];</a>
<a name="ln1494">        lines[c.y][c.x] = val;</a>
<a name="ln1495">        ++substituted;</a>
<a name="ln1496">    }</a>
<a name="ln1497">    return substituted;</a>
<a name="ln1498">}</a>
<a name="ln1499"> </a>
<a name="ln1500">string map_lines::block_shuffle(const string &amp;s)</a>
<a name="ln1501">{</a>
<a name="ln1502">    vector&lt;string&gt; segs = split_string(&quot;/&quot;, s);</a>
<a name="ln1503">    shuffle_array(segs);</a>
<a name="ln1504">    return comma_separated_line(segs.begin(), segs.end(), &quot;/&quot;, &quot;/&quot;);</a>
<a name="ln1505">}</a>
<a name="ln1506"> </a>
<a name="ln1507">string map_lines::shuffle(string s)</a>
<a name="ln1508">{</a>
<a name="ln1509">    string result;</a>
<a name="ln1510"> </a>
<a name="ln1511">    if (s.find('/') != string::npos)</a>
<a name="ln1512">        return block_shuffle(s);</a>
<a name="ln1513"> </a>
<a name="ln1514">    // Inefficient brute-force shuffle.</a>
<a name="ln1515">    while (!s.empty())</a>
<a name="ln1516">    {</a>
<a name="ln1517">        const int c = random2(s.length());</a>
<a name="ln1518">        result += s[c];</a>
<a name="ln1519">        s.erase(c, 1);</a>
<a name="ln1520">    }</a>
<a name="ln1521"> </a>
<a name="ln1522">    return result;</a>
<a name="ln1523">}</a>
<a name="ln1524"> </a>
<a name="ln1525">void map_lines::resolve_shuffle(const string &amp;shufflage)</a>
<a name="ln1526">{</a>
<a name="ln1527">    string toshuffle = shufflage;</a>
<a name="ln1528">    string shuffled = shuffle(toshuffle);</a>
<a name="ln1529"> </a>
<a name="ln1530">    if (toshuffle.empty() || shuffled.empty())</a>
<a name="ln1531">        return;</a>
<a name="ln1532"> </a>
<a name="ln1533">    for (string &amp;s : lines)</a>
<a name="ln1534">    {</a>
<a name="ln1535">        for (char &amp;c : s)</a>
<a name="ln1536">        {</a>
<a name="ln1537">            string::size_type pos = toshuffle.find(c);</a>
<a name="ln1538">            if (pos != string::npos)</a>
<a name="ln1539">                c = shuffled[pos];</a>
<a name="ln1540">        }</a>
<a name="ln1541">    }</a>
<a name="ln1542">}</a>
<a name="ln1543"> </a>
<a name="ln1544">void map_lines::clear(const string &amp;clearchars)</a>
<a name="ln1545">{</a>
<a name="ln1546">    for (string &amp;s : lines)</a>
<a name="ln1547">    {</a>
<a name="ln1548">        for (char &amp;c : s)</a>
<a name="ln1549">        {</a>
<a name="ln1550">            string::size_type pos = clearchars.find(c);</a>
<a name="ln1551">            if (pos != string::npos)</a>
<a name="ln1552">                c = ' ';</a>
<a name="ln1553">        }</a>
<a name="ln1554">    }</a>
<a name="ln1555">}</a>
<a name="ln1556"> </a>
<a name="ln1557">void map_lines::normalise(char fillch)</a>
<a name="ln1558">{</a>
<a name="ln1559">    for (string &amp;s : lines)</a>
<a name="ln1560">        if (static_cast&lt;int&gt;(s.length()) &lt; map_width)</a>
<a name="ln1561">            s += string(map_width - s.length(), fillch);</a>
<a name="ln1562">}</a>
<a name="ln1563"> </a>
<a name="ln1564">// Should never be attempted if the map has a defined orientation, or if one</a>
<a name="ln1565">// of the dimensions is greater than the lesser of GXM,GYM.</a>
<a name="ln1566">void map_lines::rotate(bool clockwise)</a>
<a name="ln1567">{</a>
<a name="ln1568">    vector&lt;string&gt; newlines;</a>
<a name="ln1569"> </a>
<a name="ln1570">    // normalise() first for convenience.</a>
<a name="ln1571">    normalise();</a>
<a name="ln1572"> </a>
<a name="ln1573">    const int xs = clockwise? 0 : map_width - 1,</a>
<a name="ln1574">              xe = clockwise? map_width : -1,</a>
<a name="ln1575">              xi = clockwise? 1 : -1;</a>
<a name="ln1576"> </a>
<a name="ln1577">    const int ys = clockwise? (int) lines.size() - 1 : 0,</a>
<a name="ln1578">              ye = clockwise? -1 : (int) lines.size(),</a>
<a name="ln1579">              yi = clockwise? -1 : 1;</a>
<a name="ln1580"> </a>
<a name="ln1581">    for (int i = xs; i != xe; i += xi)</a>
<a name="ln1582">    {</a>
<a name="ln1583">        string line;</a>
<a name="ln1584"> </a>
<a name="ln1585">        for (int j = ys; j != ye; j += yi)</a>
<a name="ln1586">            line += lines[j][i];</a>
<a name="ln1587"> </a>
<a name="ln1588">        newlines.push_back(line);</a>
<a name="ln1589">    }</a>
<a name="ln1590"> </a>
<a name="ln1591">    if (overlay)</a>
<a name="ln1592">    {</a>
<a name="ln1593">        auto new_overlay = make_unique&lt;overlay_matrix&gt;(lines.size(), map_width);</a>
<a name="ln1594">        for (int i = xs, y = 0; i != xe; i += xi, ++y)</a>
<a name="ln1595">            for (int j = ys, x = 0; j != ye; j += yi, ++x)</a>
<a name="ln1596">                (*new_overlay)(x, y) = (*overlay)(i, j);</a>
<a name="ln1597">        overlay = move(new_overlay);</a>
<a name="ln1598">    }</a>
<a name="ln1599"> </a>
<a name="ln1600">    map_width = lines.size();</a>
<a name="ln1601">    lines     = newlines;</a>
<a name="ln1602">    rotate_markers(clockwise);</a>
<a name="ln1603">    solid_checked = false;</a>
<a name="ln1604">}</a>
<a name="ln1605"> </a>
<a name="ln1606">void map_lines::translate_marker(</a>
<a name="ln1607">    void (map_lines::*xform)(map_marker *, int),</a>
<a name="ln1608">    int par)</a>
<a name="ln1609">{</a>
<a name="ln1610">    for (map_marker *marker : markers)</a>
<a name="ln1611">        (this-&gt;*xform)(marker, par);</a>
<a name="ln1612">}</a>
<a name="ln1613"> </a>
<a name="ln1614">void map_lines::vmirror_marker(map_marker *marker, int)</a>
<a name="ln1615">{</a>
<a name="ln1616">    marker-&gt;pos.y = height() - 1 - marker-&gt;pos.y;</a>
<a name="ln1617">}</a>
<a name="ln1618"> </a>
<a name="ln1619">void map_lines::hmirror_marker(map_marker *marker, int)</a>
<a name="ln1620">{</a>
<a name="ln1621">    marker-&gt;pos.x = width() - 1 - marker-&gt;pos.x;</a>
<a name="ln1622">}</a>
<a name="ln1623"> </a>
<a name="ln1624">void map_lines::rotate_marker(map_marker *marker, int clockwise)</a>
<a name="ln1625">{</a>
<a name="ln1626">    const coord_def c = marker-&gt;pos;</a>
<a name="ln1627">    if (clockwise)</a>
<a name="ln1628">        marker-&gt;pos = coord_def(width() - 1 - c.y, c.x);</a>
<a name="ln1629">    else</a>
<a name="ln1630">        marker-&gt;pos = coord_def(c.y, height() - 1 - c.x);</a>
<a name="ln1631">}</a>
<a name="ln1632"> </a>
<a name="ln1633">void map_lines::vmirror_markers()</a>
<a name="ln1634">{</a>
<a name="ln1635">    translate_marker(&amp;map_lines::vmirror_marker);</a>
<a name="ln1636">}</a>
<a name="ln1637"> </a>
<a name="ln1638">void map_lines::hmirror_markers()</a>
<a name="ln1639">{</a>
<a name="ln1640">    translate_marker(&amp;map_lines::hmirror_marker);</a>
<a name="ln1641">}</a>
<a name="ln1642"> </a>
<a name="ln1643">void map_lines::rotate_markers(bool clock)</a>
<a name="ln1644">{</a>
<a name="ln1645">    translate_marker(&amp;map_lines::rotate_marker, clock);</a>
<a name="ln1646">}</a>
<a name="ln1647"> </a>
<a name="ln1648">void map_lines::vmirror()</a>
<a name="ln1649">{</a>
<a name="ln1650">    const int vsize = lines.size();</a>
<a name="ln1651">    const int midpoint = vsize / 2;</a>
<a name="ln1652"> </a>
<a name="ln1653">    for (int i = 0; i &lt; midpoint; ++i)</a>
<a name="ln1654">    {</a>
<a name="ln1655">        string temp = lines[i];</a>
<a name="ln1656">        lines[i] = lines[vsize - 1 - i];</a>
<a name="ln1657">        lines[vsize - 1 - i] = temp;</a>
<a name="ln1658">    }</a>
<a name="ln1659"> </a>
<a name="ln1660">    if (overlay)</a>
<a name="ln1661">    {</a>
<a name="ln1662">        for (int i = 0; i &lt; midpoint; ++i)</a>
<a name="ln1663">            for (int j = 0, wide = width(); j &lt; wide; ++j)</a>
<a name="ln1664">                swap((*overlay)(j, i), (*overlay)(j, vsize - 1 - i));</a>
<a name="ln1665">    }</a>
<a name="ln1666"> </a>
<a name="ln1667">    vmirror_markers();</a>
<a name="ln1668">    solid_checked = false;</a>
<a name="ln1669">}</a>
<a name="ln1670"> </a>
<a name="ln1671">void map_lines::hmirror()</a>
<a name="ln1672">{</a>
<a name="ln1673">    const int midpoint = map_width / 2;</a>
<a name="ln1674">    for (string &amp;s : lines)</a>
<a name="ln1675">        for (int j = 0; j &lt; midpoint; ++j)</a>
<a name="ln1676">            swap(s[j], s[map_width - 1 - j]);</a>
<a name="ln1677"> </a>
<a name="ln1678">    if (overlay)</a>
<a name="ln1679">    {</a>
<a name="ln1680">        for (int i = 0, vsize = lines.size(); i &lt; vsize; ++i)</a>
<a name="ln1681">            for (int j = 0; j &lt; midpoint; ++j)</a>
<a name="ln1682">                swap((*overlay)(j, i), (*overlay)(map_width - 1 - j, i));</a>
<a name="ln1683">    }</a>
<a name="ln1684"> </a>
<a name="ln1685">    hmirror_markers();</a>
<a name="ln1686">    solid_checked = false;</a>
<a name="ln1687">}</a>
<a name="ln1688"> </a>
<a name="ln1689">keyed_mapspec *map_lines::mapspec_for_key(int key)</a>
<a name="ln1690">{</a>
<a name="ln1691">    return map_find(keyspecs, key);</a>
<a name="ln1692">}</a>
<a name="ln1693"> </a>
<a name="ln1694">const keyed_mapspec *map_lines::mapspec_for_key(int key) const</a>
<a name="ln1695">{</a>
<a name="ln1696">    return map_find(keyspecs, key);</a>
<a name="ln1697">}</a>
<a name="ln1698"> </a>
<a name="ln1699">keyed_mapspec *map_lines::mapspec_at(const coord_def &amp;c)</a>
<a name="ln1700">{</a>
<a name="ln1701">    int key = (*this)(c);</a>
<a name="ln1702"> </a>
<a name="ln1703">    if (key == SUBVAULT_GLYPH)</a>
<a name="ln1704">    {</a>
<a name="ln1705">        // Any subvault should create the overlay.</a>
<a name="ln1706">        ASSERT(overlay);</a>
<a name="ln1707">        if (!overlay)</a>
<a name="ln1708">            return nullptr;</a>
<a name="ln1709"> </a>
<a name="ln1710">        key = (*overlay)(c.x, c.y).keyspec_idx;</a>
<a name="ln1711">        ASSERT(key);</a>
<a name="ln1712">        if (!key)</a>
<a name="ln1713">            return nullptr;</a>
<a name="ln1714">    }</a>
<a name="ln1715"> </a>
<a name="ln1716">    return mapspec_for_key(key);</a>
<a name="ln1717">}</a>
<a name="ln1718"> </a>
<a name="ln1719">const keyed_mapspec *map_lines::mapspec_at(const coord_def &amp;c) const</a>
<a name="ln1720">{</a>
<a name="ln1721">    int key = (*this)(c);</a>
<a name="ln1722"> </a>
<a name="ln1723">    if (key == SUBVAULT_GLYPH)</a>
<a name="ln1724">    {</a>
<a name="ln1725">        // Any subvault should create the overlay and set the keyspec idx.</a>
<a name="ln1726">        ASSERT(overlay);</a>
<a name="ln1727">        if (!overlay)</a>
<a name="ln1728">            return nullptr;</a>
<a name="ln1729"> </a>
<a name="ln1730">        key = (*overlay)(c.x, c.y).keyspec_idx;</a>
<a name="ln1731">        ASSERT(key);</a>
<a name="ln1732">        if (!key)</a>
<a name="ln1733">            return nullptr;</a>
<a name="ln1734">    }</a>
<a name="ln1735"> </a>
<a name="ln1736">    return mapspec_for_key(key);</a>
<a name="ln1737">}</a>
<a name="ln1738"> </a>
<a name="ln1739">string map_lines::add_key_field(</a>
<a name="ln1740">    const string &amp;s,</a>
<a name="ln1741">    string (keyed_mapspec::*set_field)(const string &amp;s, bool fixed),</a>
<a name="ln1742">    void (keyed_mapspec::*copy_field)(const keyed_mapspec &amp;spec))</a>
<a name="ln1743">{</a>
<a name="ln1744">    int separator = 0;</a>
<a name="ln1745">    string key, arg;</a>
<a name="ln1746"> </a>
<a name="ln1747">    string err = mapdef_split_key_item(s, &amp;key, &amp;separator, &amp;arg, -1);</a>
<a name="ln1748">    if (!err.empty())</a>
<a name="ln1749">        return err;</a>
<a name="ln1750"> </a>
<a name="ln1751">    keyed_mapspec &amp;kmbase = keyspecs[key[0]];</a>
<a name="ln1752">    kmbase.key_glyph = key[0];</a>
<a name="ln1753">    err = ((kmbase.*set_field)(arg, separator == ':'));</a>
<a name="ln1754">    if (!err.empty())</a>
<a name="ln1755">        return err;</a>
<a name="ln1756"> </a>
<a name="ln1757">    size_t len = key.length();</a>
<a name="ln1758">    for (size_t i = 1; i &lt; len; i++)</a>
<a name="ln1759">    {</a>
<a name="ln1760">        keyed_mapspec &amp;km = keyspecs[key[i]];</a>
<a name="ln1761">        km.key_glyph = key[i];</a>
<a name="ln1762">        ((km.*copy_field)(kmbase));</a>
<a name="ln1763">    }</a>
<a name="ln1764"> </a>
<a name="ln1765">    return err;</a>
<a name="ln1766">}</a>
<a name="ln1767"> </a>
<a name="ln1768">string map_lines::add_key_item(const string &amp;s)</a>
<a name="ln1769">{</a>
<a name="ln1770">    return add_key_field(s, &amp;keyed_mapspec::set_item,</a>
<a name="ln1771">                         &amp;keyed_mapspec::copy_item);</a>
<a name="ln1772">}</a>
<a name="ln1773"> </a>
<a name="ln1774">string map_lines::add_key_feat(const string &amp;s)</a>
<a name="ln1775">{</a>
<a name="ln1776">    return add_key_field(s, &amp;keyed_mapspec::set_feat,</a>
<a name="ln1777">                         &amp;keyed_mapspec::copy_feat);</a>
<a name="ln1778">}</a>
<a name="ln1779"> </a>
<a name="ln1780">string map_lines::add_key_mons(const string &amp;s)</a>
<a name="ln1781">{</a>
<a name="ln1782">    return add_key_field(s, &amp;keyed_mapspec::set_mons,</a>
<a name="ln1783">                         &amp;keyed_mapspec::copy_mons);</a>
<a name="ln1784">}</a>
<a name="ln1785"> </a>
<a name="ln1786">string map_lines::add_key_mask(const string &amp;s)</a>
<a name="ln1787">{</a>
<a name="ln1788">    return add_key_field(s, &amp;keyed_mapspec::set_mask,</a>
<a name="ln1789">                         &amp;keyed_mapspec::copy_mask);</a>
<a name="ln1790">}</a>
<a name="ln1791"> </a>
<a name="ln1792">vector&lt;coord_def&gt; map_lines::find_glyph(int gly) const</a>
<a name="ln1793">{</a>
<a name="ln1794">    vector&lt;coord_def&gt; points;</a>
<a name="ln1795">    for (int y = height() - 1; y &gt;= 0; --y)</a>
<a name="ln1796">    {</a>
<a name="ln1797">        for (int x = width() - 1; x &gt;= 0; --x)</a>
<a name="ln1798">        {</a>
<a name="ln1799">            const coord_def c(x, y);</a>
<a name="ln1800">            if ((*this)(c) == gly)</a>
<a name="ln1801">                points.push_back(c);</a>
<a name="ln1802">        }</a>
<a name="ln1803">    }</a>
<a name="ln1804">    return points;</a>
<a name="ln1805">}</a>
<a name="ln1806"> </a>
<a name="ln1807">vector&lt;coord_def&gt; map_lines::find_glyph(const string &amp;glyphs) const</a>
<a name="ln1808">{</a>
<a name="ln1809">    vector&lt;coord_def&gt; points;</a>
<a name="ln1810">    for (int y = height() - 1; y &gt;= 0; --y)</a>
<a name="ln1811">    {</a>
<a name="ln1812">        for (int x = width() - 1; x &gt;= 0; --x)</a>
<a name="ln1813">        {</a>
<a name="ln1814">            const coord_def c(x, y);</a>
<a name="ln1815">            if (glyphs.find((*this)(c)) != string::npos)</a>
<a name="ln1816">                points.push_back(c);</a>
<a name="ln1817">        }</a>
<a name="ln1818">    }</a>
<a name="ln1819">    return points;</a>
<a name="ln1820">}</a>
<a name="ln1821"> </a>
<a name="ln1822">coord_def map_lines::find_first_glyph(int gly) const</a>
<a name="ln1823">{</a>
<a name="ln1824">    for (int y = 0, h = height(); y &lt; h; ++y)</a>
<a name="ln1825">    {</a>
<a name="ln1826">        string::size_type pos = lines[y].find(gly);</a>
<a name="ln1827">        if (pos != string::npos)</a>
<a name="ln1828">            return coord_def(pos, y);</a>
<a name="ln1829">    }</a>
<a name="ln1830"> </a>
<a name="ln1831">    return coord_def(-1, -1);</a>
<a name="ln1832">}</a>
<a name="ln1833"> </a>
<a name="ln1834">coord_def map_lines::find_first_glyph(const string &amp;glyphs) const</a>
<a name="ln1835">{</a>
<a name="ln1836">    for (int y = 0, h = height(); y &lt; h; ++y)</a>
<a name="ln1837">    {</a>
<a name="ln1838">        string::size_type pos = lines[y].find_first_of(glyphs);</a>
<a name="ln1839">        if (pos != string::npos)</a>
<a name="ln1840">            return coord_def(pos, y);</a>
<a name="ln1841">    }</a>
<a name="ln1842">    return coord_def(-1, -1);</a>
<a name="ln1843">}</a>
<a name="ln1844"> </a>
<a name="ln1845">bool map_lines::find_bounds(int gly, coord_def &amp;tl, coord_def &amp;br) const</a>
<a name="ln1846">{</a>
<a name="ln1847">    tl = coord_def(width(), height());</a>
<a name="ln1848">    br = coord_def(-1, -1);</a>
<a name="ln1849"> </a>
<a name="ln1850">    if (width() == 0 || height() == 0)</a>
<a name="ln1851">        return false;</a>
<a name="ln1852"> </a>
<a name="ln1853">    for (rectangle_iterator ri(get_iter()); ri; ++ri)</a>
<a name="ln1854">    {</a>
<a name="ln1855">        const coord_def mc = *ri;</a>
<a name="ln1856">        if ((*this)(mc) != gly)</a>
<a name="ln1857">            continue;</a>
<a name="ln1858"> </a>
<a name="ln1859">        tl.x = min(tl.x, mc.x);</a>
<a name="ln1860">        tl.y = min(tl.y, mc.y);</a>
<a name="ln1861">        br.x = max(br.x, mc.x);</a>
<a name="ln1862">        br.y = max(br.y, mc.y);</a>
<a name="ln1863">    }</a>
<a name="ln1864"> </a>
<a name="ln1865">    return br.x &gt;= 0;</a>
<a name="ln1866">}</a>
<a name="ln1867"> </a>
<a name="ln1868">bool map_lines::find_bounds(const char *str, coord_def &amp;tl, coord_def &amp;br) const</a>
<a name="ln1869">{</a>
<a name="ln1870">    tl = coord_def(width(), height());</a>
<a name="ln1871">    br = coord_def(-1, -1);</a>
<a name="ln1872"> </a>
<a name="ln1873">    if (width() == 0 || height() == 0)</a>
<a name="ln1874">        return false;</a>
<a name="ln1875"> </a>
<a name="ln1876">    for (rectangle_iterator ri(get_iter()); ri; ++ri)</a>
<a name="ln1877">    {</a>
<a name="ln1878">        ASSERT(ri);</a>
<a name="ln1879">        const coord_def &amp;mc = *ri;</a>
<a name="ln1880">        const size_t len = strlen(str);</a>
<a name="ln1881">        for (size_t i = 0; i &lt; len; ++i)</a>
<a name="ln1882">        {</a>
<a name="ln1883">            if ((*this)(mc) == str[i])</a>
<a name="ln1884">            {</a>
<a name="ln1885">                tl.x = min(tl.x, mc.x);</a>
<a name="ln1886">                tl.y = min(tl.y, mc.y);</a>
<a name="ln1887">                br.x = max(br.x, mc.x);</a>
<a name="ln1888">                br.y = max(br.y, mc.y);</a>
<a name="ln1889">                break;</a>
<a name="ln1890">            }</a>
<a name="ln1891">        }</a>
<a name="ln1892">    }</a>
<a name="ln1893"> </a>
<a name="ln1894">    return br.x &gt;= 0;</a>
<a name="ln1895">}</a>
<a name="ln1896"> </a>
<a name="ln1897">bool map_lines::fill_zone(travel_distance_grid_t &amp;tpd, const coord_def &amp;start,</a>
<a name="ln1898">                          const coord_def &amp;tl, const coord_def &amp;br, int zone,</a>
<a name="ln1899">                          const char *wanted, const char *passable) const</a>
<a name="ln1900">{</a>
<a name="ln1901">    // This is the map_lines equivalent of _dgn_fill_zone.</a>
<a name="ln1902">    // It's unfortunately extremely similar, but not close enough to combine.</a>
<a name="ln1903"> </a>
<a name="ln1904">    bool ret = false;</a>
<a name="ln1905">    list&lt;coord_def&gt; points[2];</a>
<a name="ln1906">    int cur = 0;</a>
<a name="ln1907"> </a>
<a name="ln1908">    for (points[cur].push_back(start); !points[cur].empty();)</a>
<a name="ln1909">    {</a>
<a name="ln1910">        for (const auto &amp;c : points[cur])</a>
<a name="ln1911">        {</a>
<a name="ln1912">            tpd[c.x][c.y] = zone;</a>
<a name="ln1913"> </a>
<a name="ln1914">            ret |= (wanted &amp;&amp; strchr(wanted, (*this)(c)) != nullptr);</a>
<a name="ln1915"> </a>
<a name="ln1916">            for (int yi = -1; yi &lt;= 1; ++yi)</a>
<a name="ln1917">                for (int xi = -1; xi &lt;= 1; ++xi)</a>
<a name="ln1918">                {</a>
<a name="ln1919">                    if (!xi &amp;&amp; !yi)</a>
<a name="ln1920">                        continue;</a>
<a name="ln1921"> </a>
<a name="ln1922">                    const coord_def cp(c.x + xi, c.y + yi);</a>
<a name="ln1923">                    if (cp.x &lt; tl.x || cp.x &gt; br.x</a>
<a name="ln1924">                        || cp.y &lt; tl.y || cp.y &gt; br.y</a>
<a name="ln1925">                        || !in_bounds(cp) || tpd[cp.x][cp.y]</a>
<a name="ln1926">                        || passable &amp;&amp; !strchr(passable, (*this)(cp)))</a>
<a name="ln1927">                    {</a>
<a name="ln1928">                        continue;</a>
<a name="ln1929">                    }</a>
<a name="ln1930"> </a>
<a name="ln1931">                    tpd[cp.x][cp.y] = zone;</a>
<a name="ln1932">                    points[!cur].push_back(cp);</a>
<a name="ln1933">                }</a>
<a name="ln1934">        }</a>
<a name="ln1935"> </a>
<a name="ln1936">        points[cur].clear();</a>
<a name="ln1937">        cur = !cur;</a>
<a name="ln1938">    }</a>
<a name="ln1939">    return ret;</a>
<a name="ln1940">}</a>
<a name="ln1941"> </a>
<a name="ln1942">int map_lines::count_feature_in_box(const coord_def &amp;tl, const coord_def &amp;br,</a>
<a name="ln1943">                                    const char *feat) const</a>
<a name="ln1944">{</a>
<a name="ln1945">    int result = 0;</a>
<a name="ln1946">    for (rectangle_iterator ri(tl, br); ri; ++ri)</a>
<a name="ln1947">    {</a>
<a name="ln1948">        if (strchr(feat, (*this)(*ri)))</a>
<a name="ln1949">            result++;</a>
<a name="ln1950">    }</a>
<a name="ln1951"> </a>
<a name="ln1952">    return result;</a>
<a name="ln1953">}</a>
<a name="ln1954"> </a>
<a name="ln1955">bool map_tile_list::parse(const string &amp;s, int weight)</a>
<a name="ln1956">{</a>
<a name="ln1957">    tileidx_t idx = 0;</a>
<a name="ln1958">    if (s != &quot;none&quot; &amp;&amp; !tile_dngn_index(s.c_str(), &amp;idx))</a>
<a name="ln1959">        return false;</a>
<a name="ln1960"> </a>
<a name="ln1961">    emplace_back(s, weight);</a>
<a name="ln1962">    return true;</a>
<a name="ln1963">}</a>
<a name="ln1964"> </a>
<a name="ln1965">string map_lines::add_tile(const string &amp;sub, bool is_floor, bool is_feat)</a>
<a name="ln1966">{</a>
<a name="ln1967">    string s = trimmed_string(sub);</a>
<a name="ln1968"> </a>
<a name="ln1969">    if (s.empty())</a>
<a name="ln1970">        return &quot;&quot;;</a>
<a name="ln1971"> </a>
<a name="ln1972">    bool no_random = strip_tag(s, &quot;no_random&quot;);</a>
<a name="ln1973">    bool last_tile = strip_tag(s, &quot;last_tile&quot;);</a>
<a name="ln1974"> </a>
<a name="ln1975">    int sep = 0;</a>
<a name="ln1976">    string key;</a>
<a name="ln1977">    string substitute;</a>
<a name="ln1978"> </a>
<a name="ln1979">    string err = mapdef_split_key_item(s, &amp;key, &amp;sep, &amp;substitute, -1);</a>
<a name="ln1980">    if (!err.empty())</a>
<a name="ln1981">        return err;</a>
<a name="ln1982"> </a>
<a name="ln1983">    map_tile_list list;</a>
<a name="ln1984">    err = _parse_weighted_str&lt;map_tile_list&gt;(substitute, list);</a>
<a name="ln1985">    if (!err.empty())</a>
<a name="ln1986">        return err;</a>
<a name="ln1987"> </a>
<a name="ln1988">    tile_spec spec(key, sep == ':', no_random, last_tile, is_floor, is_feat, list);</a>
<a name="ln1989">    overlay_tiles(spec);</a>
<a name="ln1990"> </a>
<a name="ln1991">    return &quot;&quot;;</a>
<a name="ln1992">}</a>
<a name="ln1993"> </a>
<a name="ln1994">string map_lines::add_rocktile(const string &amp;sub)</a>
<a name="ln1995">{</a>
<a name="ln1996">    return add_tile(sub, false, false);</a>
<a name="ln1997">}</a>
<a name="ln1998"> </a>
<a name="ln1999">string map_lines::add_floortile(const string &amp;sub)</a>
<a name="ln2000">{</a>
<a name="ln2001">    return add_tile(sub, true, false);</a>
<a name="ln2002">}</a>
<a name="ln2003"> </a>
<a name="ln2004">string map_lines::add_spec_tile(const string &amp;sub)</a>
<a name="ln2005">{</a>
<a name="ln2006">    return add_tile(sub, false, true);</a>
<a name="ln2007">}</a>
<a name="ln2008"> </a>
<a name="ln2009">//////////////////////////////////////////////////////////////////////////</a>
<a name="ln2010">// tile_spec</a>
<a name="ln2011"> </a>
<a name="ln2012">string tile_spec::get_tile()</a>
<a name="ln2013">{</a>
<a name="ln2014">    if (chose_fixed)</a>
<a name="ln2015">        return fixed_tile;</a>
<a name="ln2016"> </a>
<a name="ln2017">    string chosen = &quot;&quot;;</a>
<a name="ln2018">    int cweight = 0;</a>
<a name="ln2019">    for (const map_weighted_tile &amp;tile : tiles)</a>
<a name="ln2020">        if (x_chance_in_y(tile.second, cweight += tile.second))</a>
<a name="ln2021">            chosen = tile.first;</a>
<a name="ln2022"> </a>
<a name="ln2023">    if (fix)</a>
<a name="ln2024">    {</a>
<a name="ln2025">        chose_fixed = true;</a>
<a name="ln2026">        fixed_tile  = chosen;</a>
<a name="ln2027">    }</a>
<a name="ln2028">    return chosen;</a>
<a name="ln2029">}</a>
<a name="ln2030"> </a>
<a name="ln2031">//////////////////////////////////////////////////////////////////////////</a>
<a name="ln2032">// map_lines::iterator</a>
<a name="ln2033"> </a>
<a name="ln2034">map_lines::iterator::iterator(map_lines &amp;_maplines, const string &amp;_key)</a>
<a name="ln2035">    : maplines(_maplines), key(_key), p(0, 0)</a>
<a name="ln2036">{</a>
<a name="ln2037">    advance();</a>
<a name="ln2038">}</a>
<a name="ln2039"> </a>
<a name="ln2040">void map_lines::iterator::advance()</a>
<a name="ln2041">{</a>
<a name="ln2042">    const int height = maplines.height();</a>
<a name="ln2043">    while (p.y &lt; height)</a>
<a name="ln2044">    {</a>
<a name="ln2045">        string::size_type place = p.x;</a>
<a name="ln2046">        if (place &lt; maplines.lines[p.y].length())</a>
<a name="ln2047">        {</a>
<a name="ln2048">            place = maplines.lines[p.y].find_first_of(key, place);</a>
<a name="ln2049">            if (place != string::npos)</a>
<a name="ln2050">            {</a>
<a name="ln2051">                p.x = place;</a>
<a name="ln2052">                break;</a>
<a name="ln2053">            }</a>
<a name="ln2054">        }</a>
<a name="ln2055">        ++p.y;</a>
<a name="ln2056">        p.x = 0;</a>
<a name="ln2057">    }</a>
<a name="ln2058">}</a>
<a name="ln2059"> </a>
<a name="ln2060">map_lines::iterator::operator bool() const</a>
<a name="ln2061">{</a>
<a name="ln2062">    return p.y &lt; maplines.height();</a>
<a name="ln2063">}</a>
<a name="ln2064"> </a>
<a name="ln2065">coord_def map_lines::iterator::operator *() const</a>
<a name="ln2066">{</a>
<a name="ln2067">    return p;</a>
<a name="ln2068">}</a>
<a name="ln2069"> </a>
<a name="ln2070">coord_def map_lines::iterator::operator ++ ()</a>
<a name="ln2071">{</a>
<a name="ln2072">    p.x++;</a>
<a name="ln2073">    advance();</a>
<a name="ln2074">    return **this;</a>
<a name="ln2075">}</a>
<a name="ln2076"> </a>
<a name="ln2077">coord_def map_lines::iterator::operator ++ (int)</a>
<a name="ln2078">{</a>
<a name="ln2079">    coord_def here(**this);</a>
<a name="ln2080">    ++*this;</a>
<a name="ln2081">    return here;</a>
<a name="ln2082">}</a>
<a name="ln2083"> </a>
<a name="ln2084">///////////////////////////////////////////////</a>
<a name="ln2085">// dlua_set_map</a>
<a name="ln2086"> </a>
<a name="ln2087">dlua_set_map::dlua_set_map(map_def *map)</a>
<a name="ln2088">{</a>
<a name="ln2089">    clua_push_map(dlua, map);</a>
<a name="ln2090">    if (!dlua.callfn(&quot;dgn_set_map&quot;, 1, 1))</a>
<a name="ln2091">    {</a>
<a name="ln2092">        mprf(MSGCH_ERROR, &quot;dgn_set_map failed for '%s': %s&quot;,</a>
<a name="ln2093">             map-&gt;name.c_str(), dlua.error.c_str());</a>
<a name="ln2094">    }</a>
<a name="ln2095">    // Save the returned map as a lua_datum</a>
<a name="ln2096">    old_map.reset(new lua_datum(dlua));</a>
<a name="ln2097">}</a>
<a name="ln2098"> </a>
<a name="ln2099">dlua_set_map::~dlua_set_map()</a>
<a name="ln2100">{</a>
<a name="ln2101">    old_map-&gt;push();</a>
<a name="ln2102">    if (!dlua.callfn(&quot;dgn_set_map&quot;, 1, 0))</a>
<a name="ln2103">        mprf(MSGCH_ERROR, &quot;dgn_set_map failed: %s&quot;, dlua.error.c_str());</a>
<a name="ln2104">}</a>
<a name="ln2105"> </a>
<a name="ln2106">///////////////////////////////////////////////</a>
<a name="ln2107">// map_chance</a>
<a name="ln2108"> </a>
<a name="ln2109">string map_chance::describe() const</a>
<a name="ln2110">{</a>
<a name="ln2111">    return make_stringf(&quot;%d&quot;, chance);</a>
<a name="ln2112">}</a>
<a name="ln2113"> </a>
<a name="ln2114">bool map_chance::roll() const</a>
<a name="ln2115">{</a>
<a name="ln2116">    return random2(CHANCE_ROLL) &lt; chance;</a>
<a name="ln2117">}</a>
<a name="ln2118"> </a>
<a name="ln2119">void map_chance::write(writer &amp;outf) const</a>
<a name="ln2120">{</a>
<a name="ln2121">    marshallInt(outf, chance);</a>
<a name="ln2122">}</a>
<a name="ln2123"> </a>
<a name="ln2124">void map_chance::read(reader &amp;inf)</a>
<a name="ln2125">{</a>
<a name="ln2126">#if TAG_MAJOR_VERSION == 34</a>
<a name="ln2127">    if (inf.getMinorVersion() &lt; TAG_MINOR_NO_PRIORITY)</a>
<a name="ln2128">        unmarshallInt(inf); // was chance_priority</a>
<a name="ln2129">#endif</a>
<a name="ln2130">    chance = unmarshallInt(inf);</a>
<a name="ln2131">}</a>
<a name="ln2132"> </a>
<a name="ln2133">///////////////////////////////////////////////</a>
<a name="ln2134">// depth_ranges</a>
<a name="ln2135"> </a>
<a name="ln2136">void depth_ranges::write(writer&amp; outf) const</a>
<a name="ln2137">{</a>
<a name="ln2138">    marshallShort(outf, depths.size());</a>
<a name="ln2139">    for (const level_range &amp;depth : depths)</a>
<a name="ln2140">        depth.write(outf);</a>
<a name="ln2141">}</a>
<a name="ln2142"> </a>
<a name="ln2143">void depth_ranges::read(reader &amp;inf)</a>
<a name="ln2144">{</a>
<a name="ln2145">    depths.clear();</a>
<a name="ln2146">    const int nranges = unmarshallShort(inf);</a>
<a name="ln2147">    for (int i = 0; i &lt; nranges; ++i)</a>
<a name="ln2148">    {</a>
<a name="ln2149">        level_range lr;</a>
<a name="ln2150">        lr.read(inf);</a>
<a name="ln2151">        depths.push_back(lr);</a>
<a name="ln2152">    }</a>
<a name="ln2153">}</a>
<a name="ln2154"> </a>
<a name="ln2155">depth_ranges depth_ranges::parse_depth_ranges(const string &amp;depth_range_string)</a>
<a name="ln2156">{</a>
<a name="ln2157">    depth_ranges ranges;</a>
<a name="ln2158">    for (const string &amp;frag : split_string(&quot;,&quot;, depth_range_string))</a>
<a name="ln2159">        ranges.depths.push_back(level_range::parse(frag));</a>
<a name="ln2160">    return ranges;</a>
<a name="ln2161">}</a>
<a name="ln2162"> </a>
<a name="ln2163">bool depth_ranges::is_usable_in(const level_id &amp;lid) const</a>
<a name="ln2164">{</a>
<a name="ln2165">    bool any_matched = false;</a>
<a name="ln2166">    for (const level_range &amp;lr : depths)</a>
<a name="ln2167">    {</a>
<a name="ln2168">        if (lr.matches(lid))</a>
<a name="ln2169">        {</a>
<a name="ln2170">            if (lr.deny)</a>
<a name="ln2171">                return false;</a>
<a name="ln2172">            any_matched = true;</a>
<a name="ln2173">        }</a>
<a name="ln2174">    }</a>
<a name="ln2175">    return any_matched;</a>
<a name="ln2176">}</a>
<a name="ln2177"> </a>
<a name="ln2178">void depth_ranges::add_depths(const depth_ranges &amp;other_depths)</a>
<a name="ln2179">{</a>
<a name="ln2180">    depths.insert(depths.end(),</a>
<a name="ln2181">                  other_depths.depths.begin(),</a>
<a name="ln2182">                  other_depths.depths.end());</a>
<a name="ln2183">}</a>
<a name="ln2184"> </a>
<a name="ln2185">string depth_ranges::describe() const</a>
<a name="ln2186">{</a>
<a name="ln2187">    return comma_separated_line(depths.begin(), depths.end(), &quot;, &quot;, &quot;, &quot;);</a>
<a name="ln2188">}</a>
<a name="ln2189"> </a>
<a name="ln2190">///////////////////////////////////////////////</a>
<a name="ln2191">// map_def</a>
<a name="ln2192">//</a>
<a name="ln2193"> </a>
<a name="ln2194">const int DEFAULT_MAP_WEIGHT = 10;</a>
<a name="ln2195">map_def::map_def()</a>
<a name="ln2196">    : name(), description(), order(INT_MAX), place(), depths(),</a>
<a name="ln2197">      orient(), _chance(), _weight(DEFAULT_MAP_WEIGHT),</a>
<a name="ln2198">      map(), mons(), items(), random_mons(),</a>
<a name="ln2199">      prelude(&quot;dlprelude&quot;), mapchunk(&quot;dlmapchunk&quot;), main(&quot;dlmain&quot;),</a>
<a name="ln2200">      validate(&quot;dlvalidate&quot;), veto(&quot;dlveto&quot;), epilogue(&quot;dlepilogue&quot;),</a>
<a name="ln2201">      rock_colour(BLACK), floor_colour(BLACK), rock_tile(&quot;&quot;),</a>
<a name="ln2202">      floor_tile(&quot;&quot;), border_fill_type(DNGN_ROCK_WALL),</a>
<a name="ln2203">      tags(),</a>
<a name="ln2204">      index_only(false), cache_offset(0L), validating_map_flag(false),</a>
<a name="ln2205">      cache_minivault(false), cache_overwritable(false), cache_extra(false)</a>
<a name="ln2206">{</a>
<a name="ln2207">    init();</a>
<a name="ln2208">}</a>
<a name="ln2209"> </a>
<a name="ln2210">void map_def::init()</a>
<a name="ln2211">{</a>
<a name="ln2212">    orient = MAP_NONE;</a>
<a name="ln2213">    name.clear();</a>
<a name="ln2214">    description.clear();</a>
<a name="ln2215">    order = INT_MAX;</a>
<a name="ln2216">    tags.clear();</a>
<a name="ln2217">    place.clear();</a>
<a name="ln2218">    depths.clear();</a>
<a name="ln2219">    prelude.clear();</a>
<a name="ln2220">    mapchunk.clear();</a>
<a name="ln2221">    main.clear();</a>
<a name="ln2222">    validate.clear();</a>
<a name="ln2223">    veto.clear();</a>
<a name="ln2224">    epilogue.clear();</a>
<a name="ln2225">    place_loaded_from.clear();</a>
<a name="ln2226">    reinit();</a>
<a name="ln2227"> </a>
<a name="ln2228">    // Subvault mask set and cleared externally.</a>
<a name="ln2229">    // It should *not* be in reinit.</a>
<a name="ln2230">    svmask = nullptr;</a>
<a name="ln2231">}</a>
<a name="ln2232"> </a>
<a name="ln2233">void map_def::reinit()</a>
<a name="ln2234">{</a>
<a name="ln2235">    description.clear();</a>
<a name="ln2236">    order = INT_MAX;</a>
<a name="ln2237">    items.clear();</a>
<a name="ln2238">    random_mons.clear();</a>
<a name="ln2239"> </a>
<a name="ln2240">    rock_colour = floor_colour = BLACK;</a>
<a name="ln2241">    rock_tile = floor_tile = &quot;&quot;;</a>
<a name="ln2242">    border_fill_type = DNGN_ROCK_WALL;</a>
<a name="ln2243"> </a>
<a name="ln2244">    // Chance of using this level. Nonzero chance should be used</a>
<a name="ln2245">    // sparingly. When selecting vaults for a place, first those</a>
<a name="ln2246">    // vaults with chance &gt; 0 are considered, in the order they were</a>
<a name="ln2247">    // loaded (which is arbitrary). If random2(100) &lt; chance, the</a>
<a name="ln2248">    // vault is picked, and all other vaults are ignored for that</a>
<a name="ln2249">    // random selection. weight is ignored if the vault is chosen</a>
<a name="ln2250">    // based on its chance.</a>
<a name="ln2251">    _chance.clear();</a>
<a name="ln2252"> </a>
<a name="ln2253">    // Weight for this map. When selecting a map, if no map with a</a>
<a name="ln2254">    // nonzero chance is picked, one of the other eligible vaults is</a>
<a name="ln2255">    // picked with a probability of weight / (sum of weights of all</a>
<a name="ln2256">    // eligible vaults).</a>
<a name="ln2257">    _weight.clear(DEFAULT_MAP_WEIGHT);</a>
<a name="ln2258"> </a>
<a name="ln2259">    // Clearing the map also zaps map transforms.</a>
<a name="ln2260">    map.clear();</a>
<a name="ln2261">    mons.clear();</a>
<a name="ln2262">    feat_renames.clear();</a>
<a name="ln2263">    subvault_places.clear();</a>
<a name="ln2264">    update_cached_tags();</a>
<a name="ln2265">}</a>
<a name="ln2266"> </a>
<a name="ln2267">void map_def::reload_epilogue()</a>
<a name="ln2268">{</a>
<a name="ln2269">    // reload the epilogue from the current .des cache; this is because it</a>
<a name="ln2270">    // isn't serialized but with pregen orderings could need to be run after</a>
<a name="ln2271">    // vaults have been generated, saved, and reloaded. This can be a tricky</a>
<a name="ln2272">    // situation in save-compat terms, but is exactly the same as how lua code</a>
<a name="ln2273">    // triggered by markers is currently handled.</a>
<a name="ln2274">    const map_def *cache_version = find_map_by_name(name);</a>
<a name="ln2275">    if (cache_version)</a>
<a name="ln2276">        epilogue = cache_version-&gt;epilogue;</a>
<a name="ln2277">    // for save compat reasons, fail silently if the map is no longer around.</a>
<a name="ln2278">    // Probably shouldn't do anything really crucial in the epilogue that you</a>
<a name="ln2279">    // aren't prepared to deal with save compat for somehow...</a>
<a name="ln2280">}</a>
<a name="ln2281"> </a>
<a name="ln2282">bool map_def::map_already_used() const</a>
<a name="ln2283">{</a>
<a name="ln2284">    return get_uniq_map_names().count(name)</a>
<a name="ln2285">           || env.level_uniq_maps.find(name) !=</a>
<a name="ln2286">               env.level_uniq_maps.end()</a>
<a name="ln2287">           || env.new_used_subvault_names.find(name) !=</a>
<a name="ln2288">               env.new_used_subvault_names.end()</a>
<a name="ln2289">           || has_any_tag(get_uniq_map_tags().begin(),</a>
<a name="ln2290">                          get_uniq_map_tags().end())</a>
<a name="ln2291">           || has_any_tag(env.level_uniq_map_tags.begin(),</a>
<a name="ln2292">                          env.level_uniq_map_tags.end())</a>
<a name="ln2293">           || has_any_tag(env.new_used_subvault_tags.begin(),</a>
<a name="ln2294">                          env.new_used_subvault_tags.end());</a>
<a name="ln2295">}</a>
<a name="ln2296"> </a>
<a name="ln2297">bool map_def::valid_item_array_glyph(int gly)</a>
<a name="ln2298">{</a>
<a name="ln2299">    return gly &gt;= 'd' &amp;&amp; gly &lt;= 'k';</a>
<a name="ln2300">}</a>
<a name="ln2301"> </a>
<a name="ln2302">int map_def::item_array_glyph_to_slot(int gly)</a>
<a name="ln2303">{</a>
<a name="ln2304">    ASSERT(map_def::valid_item_array_glyph(gly));</a>
<a name="ln2305">    return gly - 'd';</a>
<a name="ln2306">}</a>
<a name="ln2307"> </a>
<a name="ln2308">bool map_def::valid_monster_glyph(int gly)</a>
<a name="ln2309">{</a>
<a name="ln2310">    return gly &gt;= '0' &amp;&amp; gly &lt;= '9';</a>
<a name="ln2311">}</a>
<a name="ln2312"> </a>
<a name="ln2313">bool map_def::valid_monster_array_glyph(int gly)</a>
<a name="ln2314">{</a>
<a name="ln2315">    return gly &gt;= '1' &amp;&amp; gly &lt;= '7';</a>
<a name="ln2316">}</a>
<a name="ln2317"> </a>
<a name="ln2318">int map_def::monster_array_glyph_to_slot(int gly)</a>
<a name="ln2319">{</a>
<a name="ln2320">    ASSERT(map_def::valid_monster_array_glyph(gly));</a>
<a name="ln2321">    return gly - '1';</a>
<a name="ln2322">}</a>
<a name="ln2323"> </a>
<a name="ln2324">bool map_def::in_map(const coord_def &amp;c) const</a>
<a name="ln2325">{</a>
<a name="ln2326">    return map.in_map(c);</a>
<a name="ln2327">}</a>
<a name="ln2328"> </a>
<a name="ln2329">int map_def::glyph_at(const coord_def &amp;c) const</a>
<a name="ln2330">{</a>
<a name="ln2331">    return map(c);</a>
<a name="ln2332">}</a>
<a name="ln2333"> </a>
<a name="ln2334">string map_def::name_at(const coord_def &amp;c) const</a>
<a name="ln2335">{</a>
<a name="ln2336">    vector&lt;string&gt; names;</a>
<a name="ln2337">    names.push_back(name);</a>
<a name="ln2338">    for (const subvault_place&amp; subvault : subvault_places)</a>
<a name="ln2339">    {</a>
<a name="ln2340">        if (c.x &gt;= subvault.tl.x &amp;&amp; c.x &lt;= subvault.br.x &amp;&amp;</a>
<a name="ln2341">            c.y &gt;= subvault.tl.y &amp;&amp; c.y &lt;= subvault.br.y &amp;&amp;</a>
<a name="ln2342">            subvault.subvault-&gt;in_map(c - subvault.tl))</a>
<a name="ln2343">        {</a>
<a name="ln2344">            names.push_back(subvault.subvault-&gt;name_at(c - subvault.tl));</a>
<a name="ln2345">        }</a>
<a name="ln2346">    }</a>
<a name="ln2347">    return comma_separated_line(names.begin(), names.end(), &quot;, &quot;, &quot;, &quot;);</a>
<a name="ln2348">}</a>
<a name="ln2349"> </a>
<a name="ln2350">string map_def::desc_or_name() const</a>
<a name="ln2351">{</a>
<a name="ln2352">    return description.empty()? name : description;</a>
<a name="ln2353">}</a>
<a name="ln2354"> </a>
<a name="ln2355">void map_def::write_full(writer&amp; outf) const</a>
<a name="ln2356">{</a>
<a name="ln2357">    cache_offset = outf.tell();</a>
<a name="ln2358">    write_save_version(outf, save_version::current());</a>
<a name="ln2359">    marshallString4(outf, name);</a>
<a name="ln2360">    prelude.write(outf);</a>
<a name="ln2361">    mapchunk.write(outf);</a>
<a name="ln2362">    main.write(outf);</a>
<a name="ln2363">    validate.write(outf);</a>
<a name="ln2364">    veto.write(outf);</a>
<a name="ln2365">    epilogue.write(outf);</a>
<a name="ln2366">}</a>
<a name="ln2367"> </a>
<a name="ln2368">void map_def::read_full(reader&amp; inf)</a>
<a name="ln2369">{</a>
<a name="ln2370">    // There's a potential race-condition here:</a>
<a name="ln2371">    // - If someone modifies a .des file while there are games in progress,</a>
<a name="ln2372">    // - a new Crawl process will overwrite the .dsc.</a>
<a name="ln2373">    // - older Crawl processes trying to reading the new .dsc will be hosed.</a>
<a name="ln2374">    // We could try to recover from the condition (by locking and</a>
<a name="ln2375">    // reloading the index), but it's easier to save the game at this</a>
<a name="ln2376">    // point and let the player reload.</a>
<a name="ln2377"> </a>
<a name="ln2378">    const auto version = get_save_version(inf);</a>
<a name="ln2379">    const auto major = version.major, minor = version.minor;</a>
<a name="ln2380"> </a>
<a name="ln2381">    if (major != TAG_MAJOR_VERSION || minor &gt; TAG_MINOR_VERSION)</a>
<a name="ln2382">    {</a>
<a name="ln2383">        throw map_load_exception(make_stringf(</a>
<a name="ln2384">            &quot;Map was built for a different version of Crawl (%s) &quot;</a>
<a name="ln2385">            &quot;(map: %d.%d us: %d.%d)&quot;,</a>
<a name="ln2386">            name.c_str(), int(major), int(minor),</a>
<a name="ln2387">            TAG_MAJOR_VERSION, TAG_MINOR_VERSION));</a>
<a name="ln2388">    }</a>
<a name="ln2389"> </a>
<a name="ln2390">    string fp_name;</a>
<a name="ln2391">    unmarshallString4(inf, fp_name);</a>
<a name="ln2392"> </a>
<a name="ln2393">    if (fp_name != name)</a>
<a name="ln2394">    {</a>
<a name="ln2395">        throw map_load_exception(make_stringf(</a>
<a name="ln2396">            &quot;Map fp_name (%s) != name (%s)!&quot;,</a>
<a name="ln2397">            fp_name.c_str(), name.c_str()));</a>
<a name="ln2398">    }</a>
<a name="ln2399"> </a>
<a name="ln2400">    prelude.read(inf);</a>
<a name="ln2401">    mapchunk.read(inf);</a>
<a name="ln2402">    main.read(inf);</a>
<a name="ln2403">    validate.read(inf);</a>
<a name="ln2404">    veto.read(inf);</a>
<a name="ln2405">    epilogue.read(inf);</a>
<a name="ln2406">}</a>
<a name="ln2407"> </a>
<a name="ln2408">int map_def::weight(const level_id &amp;lid) const</a>
<a name="ln2409">{</a>
<a name="ln2410">    return _weight.depth_value(lid);</a>
<a name="ln2411">}</a>
<a name="ln2412"> </a>
<a name="ln2413">map_chance map_def::chance(const level_id &amp;lid) const</a>
<a name="ln2414">{</a>
<a name="ln2415">    return _chance.depth_value(lid);</a>
<a name="ln2416">}</a>
<a name="ln2417"> </a>
<a name="ln2418">string map_def::describe() const</a>
<a name="ln2419">{</a>
<a name="ln2420">    return make_stringf(&quot;Map: %s\n%s%s%s%s%s%s&quot;,</a>
<a name="ln2421">                        name.c_str(),</a>
<a name="ln2422">                        prelude.describe(&quot;prelude&quot;).c_str(),</a>
<a name="ln2423">                        mapchunk.describe(&quot;mapchunk&quot;).c_str(),</a>
<a name="ln2424">                        main.describe(&quot;main&quot;).c_str(),</a>
<a name="ln2425">                        validate.describe(&quot;validate&quot;).c_str(),</a>
<a name="ln2426">                        veto.describe(&quot;veto&quot;).c_str(),</a>
<a name="ln2427">                        epilogue.describe(&quot;epilogue&quot;).c_str());</a>
<a name="ln2428">}</a>
<a name="ln2429"> </a>
<a name="ln2430">void map_def::strip()</a>
<a name="ln2431">{</a>
<a name="ln2432">    if (index_only)</a>
<a name="ln2433">        return;</a>
<a name="ln2434"> </a>
<a name="ln2435">    index_only = true;</a>
<a name="ln2436">    map.clear();</a>
<a name="ln2437">    mons.clear();</a>
<a name="ln2438">    items.clear();</a>
<a name="ln2439">    random_mons.clear();</a>
<a name="ln2440">    prelude.clear();</a>
<a name="ln2441">    mapchunk.clear();</a>
<a name="ln2442">    main.clear();</a>
<a name="ln2443">    validate.clear();</a>
<a name="ln2444">    veto.clear();</a>
<a name="ln2445">    // don't clear epilogues: this may still be needed when reloading a vault</a>
<a name="ln2446">    // on a level that the player hasn't visited yet.</a>
<a name="ln2447">    feat_renames.clear();</a>
<a name="ln2448">}</a>
<a name="ln2449"> </a>
<a name="ln2450">void map_def::load()</a>
<a name="ln2451">{</a>
<a name="ln2452">    if (!index_only)</a>
<a name="ln2453">        return;</a>
<a name="ln2454"> </a>
<a name="ln2455">    const string descache_base = get_descache_path(cache_name, &quot;&quot;);</a>
<a name="ln2456">    file_lock deslock(descache_base + &quot;.lk&quot;, &quot;rb&quot;, false);</a>
<a name="ln2457">    const string loadfile = descache_base + &quot;.dsc&quot;;</a>
<a name="ln2458"> </a>
<a name="ln2459">    reader inf(loadfile, TAG_MINOR_VERSION);</a>
<a name="ln2460">    if (!inf.valid())</a>
<a name="ln2461">    {</a>
<a name="ln2462">        throw map_load_exception(</a>
<a name="ln2463">                make_stringf(&quot;Map inf is invalid: %s&quot;, name.c_str()));</a>
<a name="ln2464">    }</a>
<a name="ln2465">    inf.advance(cache_offset);</a>
<a name="ln2466">    read_full(inf);</a>
<a name="ln2467"> </a>
<a name="ln2468">    index_only = false;</a>
<a name="ln2469">}</a>
<a name="ln2470"> </a>
<a name="ln2471">vector&lt;coord_def&gt; map_def::find_glyph(int glyph) const</a>
<a name="ln2472">{</a>
<a name="ln2473">    return map.find_glyph(glyph);</a>
<a name="ln2474">}</a>
<a name="ln2475"> </a>
<a name="ln2476">coord_def map_def::find_first_glyph(int glyph) const</a>
<a name="ln2477">{</a>
<a name="ln2478">    return map.find_first_glyph(glyph);</a>
<a name="ln2479">}</a>
<a name="ln2480"> </a>
<a name="ln2481">coord_def map_def::find_first_glyph(const string &amp;s) const</a>
<a name="ln2482">{</a>
<a name="ln2483">    return map.find_first_glyph(s);</a>
<a name="ln2484">}</a>
<a name="ln2485"> </a>
<a name="ln2486">void map_def::write_maplines(writer &amp;outf) const</a>
<a name="ln2487">{</a>
<a name="ln2488">    map.write_maplines(outf);</a>
<a name="ln2489">}</a>
<a name="ln2490"> </a>
<a name="ln2491">static void _marshall_map_chance(writer &amp;th, const map_chance &amp;chance)</a>
<a name="ln2492">{</a>
<a name="ln2493">    chance.write(th);</a>
<a name="ln2494">}</a>
<a name="ln2495"> </a>
<a name="ln2496">static map_chance _unmarshall_map_chance(reader &amp;th)</a>
<a name="ln2497">{</a>
<a name="ln2498">    map_chance chance;</a>
<a name="ln2499">    chance.read(th);</a>
<a name="ln2500">    return chance;</a>
<a name="ln2501">}</a>
<a name="ln2502"> </a>
<a name="ln2503">void map_def::write_index(writer&amp; outf) const</a>
<a name="ln2504">{</a>
<a name="ln2505">    if (!cache_offset)</a>
<a name="ln2506">    {</a>
<a name="ln2507">        end(1, false, &quot;Map %s: can't write index - cache offset not set!&quot;,</a>
<a name="ln2508">            name.c_str());</a>
<a name="ln2509">    }</a>
<a name="ln2510">    marshallString4(outf, name);</a>
<a name="ln2511">    marshallString4(outf, place_loaded_from.filename);</a>
<a name="ln2512">    marshallInt(outf, place_loaded_from.lineno);</a>
<a name="ln2513">    marshallShort(outf, orient);</a>
<a name="ln2514">    // XXX: This is a hack. See the comment in l-dgn.cc.</a>
<a name="ln2515">    marshallShort(outf, static_cast&lt;short&gt;(border_fill_type));</a>
<a name="ln2516">    _chance.write(outf, _marshall_map_chance);</a>
<a name="ln2517">    _weight.write(outf, marshallInt);</a>
<a name="ln2518">    marshallInt(outf, cache_offset);</a>
<a name="ln2519">    marshallString4(outf, tags_string());</a>
<a name="ln2520">    place.write(outf);</a>
<a name="ln2521">    depths.write(outf);</a>
<a name="ln2522">    prelude.write(outf);</a>
<a name="ln2523">}</a>
<a name="ln2524"> </a>
<a name="ln2525">void map_def::read_maplines(reader &amp;inf)</a>
<a name="ln2526">{</a>
<a name="ln2527">    map.read_maplines(inf);</a>
<a name="ln2528">}</a>
<a name="ln2529"> </a>
<a name="ln2530">void map_def::read_index(reader&amp; inf)</a>
<a name="ln2531">{</a>
<a name="ln2532">    unmarshallString4(inf, name);</a>
<a name="ln2533">    unmarshallString4(inf, place_loaded_from.filename);</a>
<a name="ln2534">    place_loaded_from.lineno = unmarshallInt(inf);</a>
<a name="ln2535">    orient = static_cast&lt;map_section_type&gt;(unmarshallShort(inf));</a>
<a name="ln2536">    // XXX: Hack. See the comment in l-dgn.cc.</a>
<a name="ln2537">    border_fill_type =</a>
<a name="ln2538">        static_cast&lt;dungeon_feature_type&gt;(unmarshallShort(inf));</a>
<a name="ln2539"> </a>
<a name="ln2540">    _chance = range_chance_t::read(inf, _unmarshall_map_chance);</a>
<a name="ln2541">    _weight = range_weight_t::read(inf, unmarshallInt);</a>
<a name="ln2542">    cache_offset = unmarshallInt(inf);</a>
<a name="ln2543">    string read_tags;</a>
<a name="ln2544">    unmarshallString4(inf, read_tags);</a>
<a name="ln2545">    set_tags(read_tags);</a>
<a name="ln2546">    place.read(inf);</a>
<a name="ln2547">    depths.read(inf);</a>
<a name="ln2548">    prelude.read(inf);</a>
<a name="ln2549">    index_only = true;</a>
<a name="ln2550">}</a>
<a name="ln2551"> </a>
<a name="ln2552">void map_def::set_file(const string &amp;s)</a>
<a name="ln2553">{</a>
<a name="ln2554">    prelude.set_file(s);</a>
<a name="ln2555">    mapchunk.set_file(s);</a>
<a name="ln2556">    main.set_file(s);</a>
<a name="ln2557">    validate.set_file(s);</a>
<a name="ln2558">    veto.set_file(s);</a>
<a name="ln2559">    epilogue.set_file(s);</a>
<a name="ln2560">    file = get_base_filename(s);</a>
<a name="ln2561">    cache_name = get_cache_name(s);</a>
<a name="ln2562">}</a>
<a name="ln2563"> </a>
<a name="ln2564">string map_def::run_lua(bool run_main)</a>
<a name="ln2565">{</a>
<a name="ln2566">    dlua_set_map mset(this);</a>
<a name="ln2567"> </a>
<a name="ln2568">    int err = prelude.load(dlua);</a>
<a name="ln2569">    if (err == E_CHUNK_LOAD_FAILURE)</a>
<a name="ln2570">        lua_pushnil(dlua);</a>
<a name="ln2571">    else if (err)</a>
<a name="ln2572">        return prelude.orig_error();</a>
<a name="ln2573">    if (!dlua.callfn(&quot;dgn_run_map&quot;, 1, 0))</a>
<a name="ln2574">        return rewrite_chunk_errors(dlua.error);</a>
<a name="ln2575"> </a>
<a name="ln2576">    if (run_main)</a>
<a name="ln2577">    {</a>
<a name="ln2578">        // Run the map chunk to set up the vault's map grid.</a>
<a name="ln2579">        err = mapchunk.load(dlua);</a>
<a name="ln2580">        if (err == E_CHUNK_LOAD_FAILURE)</a>
<a name="ln2581">            lua_pushnil(dlua);</a>
<a name="ln2582">        else if (err)</a>
<a name="ln2583">            return mapchunk.orig_error();</a>
<a name="ln2584">        if (!dlua.callfn(&quot;dgn_run_map&quot;, 1, 0))</a>
<a name="ln2585">            return rewrite_chunk_errors(dlua.error);</a>
<a name="ln2586"> </a>
<a name="ln2587">        // The vault may be non-rectangular with a ragged-right edge; for</a>
<a name="ln2588">        // transforms to work right at this point, we must pad out the right</a>
<a name="ln2589">        // edge with spaces, so run normalise:</a>
<a name="ln2590">        normalise();</a>
<a name="ln2591"> </a>
<a name="ln2592">        // Run the main Lua chunk to set up the rest of the vault</a>
<a name="ln2593">        run_hook(&quot;pre_main&quot;);</a>
<a name="ln2594">        err = main.load(dlua);</a>
<a name="ln2595">        if (err == E_CHUNK_LOAD_FAILURE)</a>
<a name="ln2596">            lua_pushnil(dlua);</a>
<a name="ln2597">        else if (err)</a>
<a name="ln2598">            return main.orig_error();</a>
<a name="ln2599">        if (!dlua.callfn(&quot;dgn_run_map&quot;, 1, 0))</a>
<a name="ln2600">            return rewrite_chunk_errors(dlua.error);</a>
<a name="ln2601">        run_hook(&quot;post_main&quot;);</a>
<a name="ln2602">    }</a>
<a name="ln2603"> </a>
<a name="ln2604">    return dlua.error;</a>
<a name="ln2605">}</a>
<a name="ln2606"> </a>
<a name="ln2607">void map_def::copy_hooks_from(const map_def &amp;other_map, const string &amp;hook_name)</a>
<a name="ln2608">{</a>
<a name="ln2609">    const dlua_set_map mset(this);</a>
<a name="ln2610">    if (!dlua.callfn(&quot;dgn_map_copy_hooks_from&quot;, &quot;ss&quot;,</a>
<a name="ln2611">                     other_map.name.c_str(), hook_name.c_str()))</a>
<a name="ln2612">    {</a>
<a name="ln2613">        mprf(MSGCH_ERROR, &quot;Lua error copying hook (%s) from '%s' to '%s': %s&quot;,</a>
<a name="ln2614">             hook_name.c_str(), other_map.name.c_str(),</a>
<a name="ln2615">             name.c_str(), dlua.error.c_str());</a>
<a name="ln2616">    }</a>
<a name="ln2617">}</a>
<a name="ln2618"> </a>
<a name="ln2619">// Runs Lua hooks registered by the map's Lua code, if any. Returns true if</a>
<a name="ln2620">// no errors occurred while running hooks.</a>
<a name="ln2621">bool map_def::run_hook(const string &amp;hook_name, bool die_on_lua_error)</a>
<a name="ln2622">{</a>
<a name="ln2623">    const dlua_set_map mset(this);</a>
<a name="ln2624">    if (!dlua.callfn(&quot;dgn_map_run_hook&quot;, &quot;s&quot;, hook_name.c_str()))</a>
<a name="ln2625">    {</a>
<a name="ln2626">        const string error = rewrite_chunk_errors(dlua.error);</a>
<a name="ln2627">        // only show the error message if this isn't a hook map-placement</a>
<a name="ln2628">        // failure, which should just lead to a silent veto.</a>
<a name="ln2629">        if (error.find(&quot;Failed to place map&quot;) == string::npos)</a>
<a name="ln2630">        {</a>
<a name="ln2631">            if (die_on_lua_error)</a>
<a name="ln2632">            {</a>
<a name="ln2633">                end(1, false, &quot;Lua error running hook '%s' on map '%s': %s&quot;,</a>
<a name="ln2634">                    hook_name.c_str(), name.c_str(), error.c_str());</a>
<a name="ln2635">            }</a>
<a name="ln2636">            else</a>
<a name="ln2637">            {</a>
<a name="ln2638">                mprf(MSGCH_ERROR, &quot;Lua error running hook '%s' on map '%s': %s&quot;,</a>
<a name="ln2639">                     hook_name.c_str(), name.c_str(), error.c_str());</a>
<a name="ln2640">            }</a>
<a name="ln2641">        }</a>
<a name="ln2642">        return false;</a>
<a name="ln2643">    }</a>
<a name="ln2644">    return true;</a>
<a name="ln2645">}</a>
<a name="ln2646"> </a>
<a name="ln2647">bool map_def::run_postplace_hook(bool die_on_lua_error)</a>
<a name="ln2648">{</a>
<a name="ln2649">    return run_hook(&quot;post_place&quot;, die_on_lua_error);</a>
<a name="ln2650">}</a>
<a name="ln2651"> </a>
<a name="ln2652">bool map_def::test_lua_boolchunk(dlua_chunk &amp;chunk, bool defval,</a>
<a name="ln2653">                                 bool die_on_lua_error)</a>
<a name="ln2654">{</a>
<a name="ln2655">    bool result = defval;</a>
<a name="ln2656">    dlua_set_map mset(this);</a>
<a name="ln2657"> </a>
<a name="ln2658">    int err = chunk.load(dlua);</a>
<a name="ln2659">    if (err == E_CHUNK_LOAD_FAILURE)</a>
<a name="ln2660">        return result;</a>
<a name="ln2661">    else if (err)</a>
<a name="ln2662">    {</a>
<a name="ln2663">        if (die_on_lua_error)</a>
<a name="ln2664">            end(1, false, &quot;Lua error: %s&quot;, chunk.orig_error().c_str());</a>
<a name="ln2665">        else</a>
<a name="ln2666">            mprf(MSGCH_ERROR, &quot;Lua error: %s&quot;, chunk.orig_error().c_str());</a>
<a name="ln2667">        return result;</a>
<a name="ln2668">    }</a>
<a name="ln2669">    if (dlua.callfn(&quot;dgn_run_map&quot;, 1, 1))</a>
<a name="ln2670">        dlua.fnreturns(&quot;&gt;b&quot;, &amp;result);</a>
<a name="ln2671">    else</a>
<a name="ln2672">    {</a>
<a name="ln2673">        if (die_on_lua_error)</a>
<a name="ln2674">        {</a>
<a name="ln2675">            end(1, false, &quot;Lua error: %s&quot;,</a>
<a name="ln2676">                rewrite_chunk_errors(dlua.error).c_str());</a>
<a name="ln2677">        }</a>
<a name="ln2678">        else</a>
<a name="ln2679">        {</a>
<a name="ln2680">            mprf(MSGCH_ERROR, &quot;Lua error: %s&quot;,</a>
<a name="ln2681">                 rewrite_chunk_errors(dlua.error).c_str());</a>
<a name="ln2682">        }</a>
<a name="ln2683">    }</a>
<a name="ln2684">    return result;</a>
<a name="ln2685">}</a>
<a name="ln2686"> </a>
<a name="ln2687">bool map_def::test_lua_validate(bool croak)</a>
<a name="ln2688">{</a>
<a name="ln2689">    return validate.empty() || test_lua_boolchunk(validate, false, croak);</a>
<a name="ln2690">}</a>
<a name="ln2691"> </a>
<a name="ln2692">bool map_def::test_lua_veto()</a>
<a name="ln2693">{</a>
<a name="ln2694">    return !veto.empty() &amp;&amp; test_lua_boolchunk(veto, true);</a>
<a name="ln2695">}</a>
<a name="ln2696"> </a>
<a name="ln2697">bool map_def::run_lua_epilogue(bool die_on_lua_error)</a>
<a name="ln2698">{</a>
<a name="ln2699">    run_hook(&quot;pre_epilogue&quot;, die_on_lua_error);</a>
<a name="ln2700">    const bool epilogue_result =</a>
<a name="ln2701">        !epilogue.empty() &amp;&amp; test_lua_boolchunk(epilogue, false,</a>
<a name="ln2702">                                                die_on_lua_error);</a>
<a name="ln2703">    run_hook(&quot;post_epilogue&quot;, die_on_lua_error);</a>
<a name="ln2704">    return epilogue_result;</a>
<a name="ln2705">}</a>
<a name="ln2706"> </a>
<a name="ln2707">string map_def::rewrite_chunk_errors(const string &amp;s) const</a>
<a name="ln2708">{</a>
<a name="ln2709">    string res = s;</a>
<a name="ln2710">    if (prelude.rewrite_chunk_errors(res))</a>
<a name="ln2711">        return res;</a>
<a name="ln2712">    if (mapchunk.rewrite_chunk_errors(res))</a>
<a name="ln2713">        return res;</a>
<a name="ln2714">    if (main.rewrite_chunk_errors(res))</a>
<a name="ln2715">        return res;</a>
<a name="ln2716">    if (validate.rewrite_chunk_errors(res))</a>
<a name="ln2717">        return res;</a>
<a name="ln2718">    if (veto.rewrite_chunk_errors(res))</a>
<a name="ln2719">        return res;</a>
<a name="ln2720">    epilogue.rewrite_chunk_errors(res);</a>
<a name="ln2721">    return res;</a>
<a name="ln2722">}</a>
<a name="ln2723"> </a>
<a name="ln2724">string map_def::validate_temple_map()</a>
<a name="ln2725">{</a>
<a name="ln2726">    vector&lt;coord_def&gt; altars = find_glyph('B');</a>
<a name="ln2727"> </a>
<a name="ln2728">    if (has_tag_prefix(&quot;temple_overflow_&quot;))</a>
<a name="ln2729">    {</a>
<a name="ln2730">        if (has_tag_prefix(&quot;temple_overflow_generic_&quot;))</a>
<a name="ln2731">        {</a>
<a name="ln2732">            string matching_tag = make_stringf(&quot;temple_overflow_generic_%u&quot;,</a>
<a name="ln2733">                (unsigned int) altars.size());</a>
<a name="ln2734">            if (!has_tag(matching_tag))</a>
<a name="ln2735">            {</a>
<a name="ln2736">                return make_stringf(</a>
<a name="ln2737">                    &quot;Temple ('%s') has %u altars and a &quot;</a>
<a name="ln2738">                    &quot;'temple_overflow_generic_' tag, but does not match the &quot;</a>
<a name="ln2739">                    &quot;number of altars: should have at least '%s'.&quot;,</a>
<a name="ln2740">                                    tags_string().c_str(),</a>
<a name="ln2741">                                    (unsigned int) altars.size(),</a>
<a name="ln2742">                                    matching_tag.c_str());</a>
<a name="ln2743">            }</a>
<a name="ln2744">        }</a>
<a name="ln2745">        else</a>
<a name="ln2746">        {</a>
<a name="ln2747">            // Assume specialised altar vaults are set up correctly.</a>
<a name="ln2748">            return &quot;&quot;;</a>
<a name="ln2749">        }</a>
<a name="ln2750">    }</a>
<a name="ln2751"> </a>
<a name="ln2752">    if (altars.empty())</a>
<a name="ln2753">        return &quot;Temple vault must contain at least one altar.&quot;;</a>
<a name="ln2754"> </a>
<a name="ln2755">    // TODO: check for substitutions and shuffles</a>
<a name="ln2756"> </a>
<a name="ln2757">    vector&lt;coord_def&gt; b_glyphs = map.find_glyph('B');</a>
<a name="ln2758">    for (auto c : b_glyphs)</a>
<a name="ln2759">    {</a>
<a name="ln2760">        const keyed_mapspec *spec = map.mapspec_at(c);</a>
<a name="ln2761">        if (spec != nullptr &amp;&amp; !spec-&gt;feat.feats.empty())</a>
<a name="ln2762">            return &quot;Can't change feat 'B' in temple (KFEAT)&quot;;</a>
<a name="ln2763">    }</a>
<a name="ln2764"> </a>
<a name="ln2765">    vector&lt;god_type&gt; god_list = temple_god_list();</a>
<a name="ln2766"> </a>
<a name="ln2767">    if (altars.size() &gt; god_list.size())</a>
<a name="ln2768">        return &quot;Temple vault has too many altars&quot;;</a>
<a name="ln2769"> </a>
<a name="ln2770">    return &quot;&quot;;</a>
<a name="ln2771">}</a>
<a name="ln2772"> </a>
<a name="ln2773">string map_def::validate_map_placeable()</a>
<a name="ln2774">{</a>
<a name="ln2775">    if (has_depth() || !place.empty())</a>
<a name="ln2776">        return &quot;&quot;;</a>
<a name="ln2777"> </a>
<a name="ln2778">    // Ok, the map wants to be placed by tag. In this case it should have</a>
<a name="ln2779">    // at least one tag that's not a map flag.</a>
<a name="ln2780">    bool has_selectable_tag = false;</a>
<a name="ln2781">    for (const string &amp;piece : tags)</a>
<a name="ln2782">    {</a>
<a name="ln2783">        if (_map_tag_is_selectable(piece))</a>
<a name="ln2784">        {</a>
<a name="ln2785">            has_selectable_tag = true;</a>
<a name="ln2786">            break;</a>
<a name="ln2787">        }</a>
<a name="ln2788">    }</a>
<a name="ln2789"> </a>
<a name="ln2790">    return has_selectable_tag? &quot;&quot; :</a>
<a name="ln2791">           make_stringf(&quot;Map '%s' has no DEPTH, no PLACE and no &quot;</a>
<a name="ln2792">                        &quot;selectable tag in '%s'&quot;,</a>
<a name="ln2793">                        name.c_str(), tags_string().c_str());</a>
<a name="ln2794">}</a>
<a name="ln2795"> </a>
<a name="ln2796">/**</a>
<a name="ln2797"> * Check to see if the vault can connect normally to the rest of the dungeon.</a>
<a name="ln2798"> */</a>
<a name="ln2799">bool map_def::has_exit() const</a>
<a name="ln2800">{</a>
<a name="ln2801">    map_def dup = *this;</a>
<a name="ln2802">    for (int y = 0, cheight = map.height(); y &lt; cheight; ++y)</a>
<a name="ln2803">        for (int x = 0, cwidth = map.width(); x &lt; cwidth; ++x)</a>
<a name="ln2804">        {</a>
<a name="ln2805">            if (!map.in_map(coord_def(x, y)))</a>
<a name="ln2806">                continue;</a>
<a name="ln2807">            const char glyph = map.glyph(x, y);</a>
<a name="ln2808">            dungeon_feature_type feat =</a>
<a name="ln2809">                map_feature_at(&amp;dup, coord_def(x, y), -1);</a>
<a name="ln2810">            // If we have a stair, assume the vault can be disconnected.</a>
<a name="ln2811">            if (feat_is_stair(feat) &amp;&amp; !feat_is_escape_hatch(feat))</a>
<a name="ln2812">                return true;</a>
<a name="ln2813">            const bool non_floating =</a>
<a name="ln2814">                glyph == '@' || glyph == '=' || glyph == '+';</a>
<a name="ln2815">            if (non_floating</a>
<a name="ln2816">                || !feat_is_solid(feat) || feat_is_closed_door(feat))</a>
<a name="ln2817">            {</a>
<a name="ln2818">                if (x == 0 || x == cwidth - 1 || y == 0 || y == cheight - 1)</a>
<a name="ln2819">                    return true;</a>
<a name="ln2820">                for (orth_adjacent_iterator ai(coord_def(x, y)); ai; ++ai)</a>
<a name="ln2821">                    if (!map.in_map(*ai))</a>
<a name="ln2822">                        return true;</a>
<a name="ln2823">            }</a>
<a name="ln2824">        }</a>
<a name="ln2825"> </a>
<a name="ln2826">    return false;</a>
<a name="ln2827">}</a>
<a name="ln2828"> </a>
<a name="ln2829">string map_def::validate_map_def(const depth_ranges &amp;default_depths)</a>
<a name="ln2830">{</a>
<a name="ln2831">    UNUSED(default_depths);</a>
<a name="ln2832"> </a>
<a name="ln2833">    unwind_bool valid_flag(validating_map_flag, true);</a>
<a name="ln2834"> </a>
<a name="ln2835">    string err = run_lua(true);</a>
<a name="ln2836">    if (!err.empty())</a>
<a name="ln2837">        return err;</a>
<a name="ln2838"> </a>
<a name="ln2839">    fixup();</a>
<a name="ln2840">    resolve();</a>
<a name="ln2841">    test_lua_validate(true);</a>
<a name="ln2842">    run_lua_epilogue(true);</a>
<a name="ln2843"> </a>
<a name="ln2844">    if (!has_depth() &amp;&amp; !lc_default_depths.empty())</a>
<a name="ln2845">        depths.add_depths(lc_default_depths);</a>
<a name="ln2846"> </a>
<a name="ln2847">    if (place.is_usable_in(level_id(BRANCH_TEMPLE))</a>
<a name="ln2848">        || has_tag_prefix(&quot;temple_overflow_&quot;))</a>
<a name="ln2849">    {</a>
<a name="ln2850">        err = validate_temple_map();</a>
<a name="ln2851">        if (!err.empty())</a>
<a name="ln2852">            return err;</a>
<a name="ln2853">    }</a>
<a name="ln2854"> </a>
<a name="ln2855">    if (has_tag(&quot;overwrite_floor_cell&quot;) &amp;&amp; (map.width() != 1 || map.height() != 1))</a>
<a name="ln2856">        return &quot;Map tagged 'overwrite_floor_cell' must be 1x1&quot;;</a>
<a name="ln2857"> </a>
<a name="ln2858">    // Abyssal vaults have additional size and orientation restrictions.</a>
<a name="ln2859">    if (has_tag(&quot;abyss&quot;) || has_tag(&quot;abyss_rune&quot;))</a>
<a name="ln2860">    {</a>
<a name="ln2861">        if (orient == MAP_ENCOMPASS)</a>
<a name="ln2862">        {</a>
<a name="ln2863">            return make_stringf(</a>
<a name="ln2864">                &quot;Map '%s' cannot use 'encompass' orientation in the abyss&quot;,</a>
<a name="ln2865">                name.c_str());</a>
<a name="ln2866">        }</a>
<a name="ln2867"> </a>
<a name="ln2868">        const int max_abyss_map_width =</a>
<a name="ln2869">            GXM / 2 - MAPGEN_BORDER - ABYSS_AREA_SHIFT_RADIUS;</a>
<a name="ln2870">        const int max_abyss_map_height =</a>
<a name="ln2871">            GYM / 2 - MAPGEN_BORDER - ABYSS_AREA_SHIFT_RADIUS;</a>
<a name="ln2872"> </a>
<a name="ln2873">        if (map.width() &gt; max_abyss_map_width</a>
<a name="ln2874">            || map.height() &gt; max_abyss_map_height)</a>
<a name="ln2875">        {</a>
<a name="ln2876">            return make_stringf(</a>
<a name="ln2877">                &quot;Map '%s' is too big for the Abyss: %dx%d - max %dx%d&quot;,</a>
<a name="ln2878">                name.c_str(),</a>
<a name="ln2879">                map.width(), map.height(),</a>
<a name="ln2880">                max_abyss_map_width, max_abyss_map_height);</a>
<a name="ln2881">        }</a>
<a name="ln2882"> </a>
<a name="ln2883">        // Unless both height and width fit in the smaller dimension,</a>
<a name="ln2884">        // map rotation will be disallowed.</a>
<a name="ln2885">        const int dimension_lower_bound =</a>
<a name="ln2886">            min(max_abyss_map_height, max_abyss_map_width);</a>
<a name="ln2887">        if ((map.width() &gt; dimension_lower_bound</a>
<a name="ln2888">             || map.height() &gt; dimension_lower_bound)</a>
<a name="ln2889">            &amp;&amp; !has_tag(&quot;no_rotate&quot;))</a>
<a name="ln2890">        {</a>
<a name="ln2891">            add_tags(&quot;no_rotate&quot;);</a>
<a name="ln2892">        }</a>
<a name="ln2893">    }</a>
<a name="ln2894"> </a>
<a name="ln2895">    if (orient == MAP_FLOAT || is_minivault())</a>
<a name="ln2896">    {</a>
<a name="ln2897">        if (map.width() &gt; GXM - MAPGEN_BORDER * 2</a>
<a name="ln2898">            || map.height() &gt; GYM - MAPGEN_BORDER * 2)</a>
<a name="ln2899">        {</a>
<a name="ln2900">            return make_stringf(</a>
<a name="ln2901">                     &quot;%s '%s' is too big: %dx%d - max %dx%d&quot;,</a>
<a name="ln2902">                     is_minivault()? &quot;Minivault&quot; : &quot;Float&quot;,</a>
<a name="ln2903">                     name.c_str(),</a>
<a name="ln2904">                     map.width(), map.height(),</a>
<a name="ln2905">                     GXM - MAPGEN_BORDER * 2,</a>
<a name="ln2906">                     GYM - MAPGEN_BORDER * 2);</a>
<a name="ln2907">        }</a>
<a name="ln2908">    }</a>
<a name="ln2909">    else</a>
<a name="ln2910">    {</a>
<a name="ln2911">        if (map.width() &gt; GXM || map.height() &gt; GYM)</a>
<a name="ln2912">        {</a>
<a name="ln2913">            return make_stringf(</a>
<a name="ln2914">                     &quot;Map '%s' is too big: %dx%d - max %dx%d&quot;,</a>
<a name="ln2915">                     name.c_str(),</a>
<a name="ln2916">                     map.width(), map.height(),</a>
<a name="ln2917">                     GXM, GYM);</a>
<a name="ln2918">        }</a>
<a name="ln2919">    }</a>
<a name="ln2920"> </a>
<a name="ln2921">    switch (orient)</a>
<a name="ln2922">    {</a>
<a name="ln2923">    case MAP_NORTH: case MAP_SOUTH:</a>
<a name="ln2924">        if (map.height() &gt; GYM * 2 / 3)</a>
<a name="ln2925">        {</a>
<a name="ln2926">            return make_stringf(&quot;Map too large - height %d (max %d)&quot;,</a>
<a name="ln2927">                                map.height(), GYM * 2 / 3);</a>
<a name="ln2928">        }</a>
<a name="ln2929">        break;</a>
<a name="ln2930">    case MAP_EAST: case MAP_WEST:</a>
<a name="ln2931">        if (map.width() &gt; GXM * 2 / 3)</a>
<a name="ln2932">        {</a>
<a name="ln2933">            return make_stringf(&quot;Map too large - width %d (max %d)&quot;,</a>
<a name="ln2934">                                map.width(), GXM * 2 / 3);</a>
<a name="ln2935">        }</a>
<a name="ln2936">        break;</a>
<a name="ln2937">    case MAP_NORTHEAST: case MAP_SOUTHEAST:</a>
<a name="ln2938">    case MAP_NORTHWEST: case MAP_SOUTHWEST:</a>
<a name="ln2939">    case MAP_FLOAT:     case MAP_CENTRE:</a>
<a name="ln2940">        if (map.width() &gt; GXM * 2 / 3 || map.height() &gt; GYM * 2 / 3)</a>
<a name="ln2941">        {</a>
<a name="ln2942">            return make_stringf(&quot;Map too large - %dx%d (max %dx%d)&quot;,</a>
<a name="ln2943">                                map.width(), map.height(),</a>
<a name="ln2944">                                GXM * 2 / 3, GYM * 2 / 3);</a>
<a name="ln2945">        }</a>
<a name="ln2946">        break;</a>
<a name="ln2947">    default:</a>
<a name="ln2948">        break;</a>
<a name="ln2949">    }</a>
<a name="ln2950"> </a>
<a name="ln2951">    // Encompass vaults, pure subvaults, and dummy vaults are exempt from</a>
<a name="ln2952">    // exit-checking.</a>
<a name="ln2953">    if (orient != MAP_ENCOMPASS &amp;&amp; !has_tag(&quot;unrand&quot;) &amp;&amp; !has_tag(&quot;dummy&quot;)</a>
<a name="ln2954">        &amp;&amp; !has_tag(&quot;no_exits&quot;) &amp;&amp; map.width() &gt; 0 &amp;&amp; map.height() &gt; 0)</a>
<a name="ln2955">    {</a>
<a name="ln2956">        if (!has_exit())</a>
<a name="ln2957">        {</a>
<a name="ln2958">            return make_stringf(</a>
<a name="ln2959">                &quot;Map '%s' has no (possible) exits; use TAGS: no_exits if &quot;</a>
<a name="ln2960">                &quot;this is intentional&quot;,</a>
<a name="ln2961">                name.c_str());</a>
<a name="ln2962">        }</a>
<a name="ln2963">    }</a>
<a name="ln2964"> </a>
<a name="ln2965">    dlua_set_map dl(this);</a>
<a name="ln2966">    return validate_map_placeable();</a>
<a name="ln2967">}</a>
<a name="ln2968"> </a>
<a name="ln2969">bool map_def::is_usable_in(const level_id &amp;lid) const</a>
<a name="ln2970">{</a>
<a name="ln2971">    return depths.is_usable_in(lid);</a>
<a name="ln2972">}</a>
<a name="ln2973"> </a>
<a name="ln2974">void map_def::add_depth(const level_range &amp;range)</a>
<a name="ln2975">{</a>
<a name="ln2976">    depths.add_depth(range);</a>
<a name="ln2977">}</a>
<a name="ln2978"> </a>
<a name="ln2979">bool map_def::has_depth() const</a>
<a name="ln2980">{</a>
<a name="ln2981">    return !depths.empty();</a>
<a name="ln2982">}</a>
<a name="ln2983"> </a>
<a name="ln2984">void map_def::update_cached_tags()</a>
<a name="ln2985">{</a>
<a name="ln2986">    cache_minivault = has_tag(&quot;minivault&quot;);</a>
<a name="ln2987">    cache_overwritable = has_tag(&quot;overwritable&quot;);</a>
<a name="ln2988">    cache_extra = has_tag(&quot;extra&quot;);</a>
<a name="ln2989">}</a>
<a name="ln2990"> </a>
<a name="ln2991">bool map_def::is_minivault() const</a>
<a name="ln2992">{</a>
<a name="ln2993">#ifdef DEBUG_TAG_PROFILING</a>
<a name="ln2994">    ASSERT(cache_minivault == has_tag(&quot;minivault&quot;));</a>
<a name="ln2995">#endif</a>
<a name="ln2996">    return cache_minivault;</a>
<a name="ln2997">}</a>
<a name="ln2998"> </a>
<a name="ln2999">// Returns true if the map is a layout that allows other vaults to be</a>
<a name="ln3000">// built on it.</a>
<a name="ln3001">bool map_def::is_overwritable_layout() const</a>
<a name="ln3002">{</a>
<a name="ln3003">#ifdef DEBUG_TAG_PROFILING</a>
<a name="ln3004">    ASSERT(cache_overwritable == has_tag(&quot;overwritable&quot;));</a>
<a name="ln3005">#endif</a>
<a name="ln3006">    return cache_overwritable;</a>
<a name="ln3007">}</a>
<a name="ln3008"> </a>
<a name="ln3009">bool map_def::is_extra_vault() const</a>
<a name="ln3010">{</a>
<a name="ln3011">#ifdef DEBUG_TAG_PROFILING</a>
<a name="ln3012">    ASSERT(cache_extra == has_tag(&quot;extra&quot;));</a>
<a name="ln3013">#endif</a>
<a name="ln3014">    return cache_extra;</a>
<a name="ln3015">}</a>
<a name="ln3016"> </a>
<a name="ln3017">// Tries to dock a floating vault - push it to one edge of the level.</a>
<a name="ln3018">// Docking will only succeed if two contiguous edges are all x/c/b/v</a>
<a name="ln3019">// (other walls prevent docking). If the vault's width is &gt; GXM*2/3,</a>
<a name="ln3020">// it's also eligible for north/south docking, and if the height &gt;</a>
<a name="ln3021">// GYM*2/3, it's eligible for east/west docking. Although docking is</a>
<a name="ln3022">// similar to setting the orientation, it doesn't affect 'orient'.</a>
<a name="ln3023">coord_def map_def::float_dock()</a>
<a name="ln3024">{</a>
<a name="ln3025">    const map_section_type orients[] =</a>
<a name="ln3026">        { MAP_NORTH, MAP_SOUTH, MAP_EAST, MAP_WEST,</a>
<a name="ln3027">          MAP_NORTHEAST, MAP_SOUTHEAST, MAP_NORTHWEST, MAP_SOUTHWEST };</a>
<a name="ln3028">    map_section_type which_orient = MAP_NONE;</a>
<a name="ln3029">    int norients = 0;</a>
<a name="ln3030"> </a>
<a name="ln3031">    for (map_section_type sec : orients)</a>
<a name="ln3032">    {</a>
<a name="ln3033">        if (map.solid_borders(sec) &amp;&amp; can_dock(sec)</a>
<a name="ln3034">            &amp;&amp; one_chance_in(++norients))</a>
<a name="ln3035">        {</a>
<a name="ln3036">            which_orient = sec;</a>
<a name="ln3037">        }</a>
<a name="ln3038">    }</a>
<a name="ln3039"> </a>
<a name="ln3040">    if (which_orient == MAP_NONE || which_orient == MAP_FLOAT)</a>
<a name="ln3041">        return coord_def(-1, -1);</a>
<a name="ln3042"> </a>
<a name="ln3043">    dprf(DIAG_DNGN, &quot;Docking floating vault to %s&quot;,</a>
<a name="ln3044">         map_section_name(which_orient));</a>
<a name="ln3045"> </a>
<a name="ln3046">    return dock_pos(which_orient);</a>
<a name="ln3047">}</a>
<a name="ln3048"> </a>
<a name="ln3049">coord_def map_def::dock_pos(map_section_type norient) const</a>
<a name="ln3050">{</a>
<a name="ln3051">    const int minborder = 6;</a>
<a name="ln3052"> </a>
<a name="ln3053">    switch (norient)</a>
<a name="ln3054">    {</a>
<a name="ln3055">    case MAP_NORTH:</a>
<a name="ln3056">        return coord_def((GXM - map.width()) / 2, minborder);</a>
<a name="ln3057">    case MAP_SOUTH:</a>
<a name="ln3058">        return coord_def((GXM - map.width()) / 2,</a>
<a name="ln3059">                          GYM - minborder - map.height());</a>
<a name="ln3060">    case MAP_EAST:</a>
<a name="ln3061">        return coord_def(GXM - minborder - map.width(),</a>
<a name="ln3062">                          (GYM - map.height()) / 2);</a>
<a name="ln3063">    case MAP_WEST:</a>
<a name="ln3064">        return coord_def(minborder,</a>
<a name="ln3065">                          (GYM - map.height()) / 2);</a>
<a name="ln3066">    case MAP_NORTHEAST:</a>
<a name="ln3067">        return coord_def(GXM - minborder - map.width(), minborder);</a>
<a name="ln3068">    case MAP_NORTHWEST:</a>
<a name="ln3069">        return coord_def(minborder, minborder);</a>
<a name="ln3070">    case MAP_SOUTHEAST:</a>
<a name="ln3071">        return coord_def(GXM - minborder - map.width(),</a>
<a name="ln3072">                          GYM - minborder - map.height());</a>
<a name="ln3073">    case MAP_SOUTHWEST:</a>
<a name="ln3074">        return coord_def(minborder,</a>
<a name="ln3075">                          GYM - minborder - map.height());</a>
<a name="ln3076">    case MAP_CENTRE:</a>
<a name="ln3077">        return coord_def((GXM - map.width())  / 2,</a>
<a name="ln3078">                         (GYM - map.height()) / 2);</a>
<a name="ln3079">    default:</a>
<a name="ln3080">        return coord_def(-1, -1);</a>
<a name="ln3081">    }</a>
<a name="ln3082">}</a>
<a name="ln3083"> </a>
<a name="ln3084">bool map_def::can_dock(map_section_type norient) const</a>
<a name="ln3085">{</a>
<a name="ln3086">    switch (norient)</a>
<a name="ln3087">    {</a>
<a name="ln3088">    case MAP_NORTH: case MAP_SOUTH:</a>
<a name="ln3089">        return map.width() &gt; GXM * 2 / 3;</a>
<a name="ln3090">    case MAP_EAST: case MAP_WEST:</a>
<a name="ln3091">        return map.height() &gt; GYM * 2 / 3;</a>
<a name="ln3092">    default:</a>
<a name="ln3093">        return true;</a>
<a name="ln3094">    }</a>
<a name="ln3095">}</a>
<a name="ln3096"> </a>
<a name="ln3097">coord_def map_def::float_random_place() const</a>
<a name="ln3098">{</a>
<a name="ln3099">    // Try to leave enough around the float for roomification.</a>
<a name="ln3100">    int minhborder = MAPGEN_BORDER + 11,</a>
<a name="ln3101">        minvborder = minhborder;</a>
<a name="ln3102"> </a>
<a name="ln3103">    if (GXM - 2 * minhborder &lt; map.width())</a>
<a name="ln3104">        minhborder = (GXM - map.width()) / 2 - 1;</a>
<a name="ln3105"> </a>
<a name="ln3106">    if (GYM - 2 * minvborder &lt; map.height())</a>
<a name="ln3107">        minvborder = (GYM - map.height()) / 2 - 1;</a>
<a name="ln3108"> </a>
<a name="ln3109">    coord_def result;</a>
<a name="ln3110">    result.x = random_range(minhborder, GXM - minhborder - map.width());</a>
<a name="ln3111">    result.y = random_range(minvborder, GYM - minvborder - map.height());</a>
<a name="ln3112">    return result;</a>
<a name="ln3113">}</a>
<a name="ln3114"> </a>
<a name="ln3115">point_vector map_def::anchor_points() const</a>
<a name="ln3116">{</a>
<a name="ln3117">    point_vector points;</a>
<a name="ln3118">    for (int y = 0, cheight = map.height(); y &lt; cheight; ++y)</a>
<a name="ln3119">        for (int x = 0, cwidth = map.width(); x &lt; cwidth; ++x)</a>
<a name="ln3120">            if (map.glyph(x, y) == '@')</a>
<a name="ln3121">                points.emplace_back(x, y);</a>
<a name="ln3122">    return points;</a>
<a name="ln3123">}</a>
<a name="ln3124"> </a>
<a name="ln3125">coord_def map_def::float_aligned_place() const</a>
<a name="ln3126">{</a>
<a name="ln3127">    const point_vector our_anchors = anchor_points();</a>
<a name="ln3128">    const coord_def fail(-1, -1);</a>
<a name="ln3129"> </a>
<a name="ln3130">    dprf(DIAG_DNGN, &quot;Aligning floating vault with %u points vs %u&quot;</a>
<a name="ln3131">                    &quot; reference points&quot;,</a>
<a name="ln3132">                    (unsigned int)our_anchors.size(),</a>
<a name="ln3133">                    (unsigned int)map_anchor_points.size());</a>
<a name="ln3134"> </a>
<a name="ln3135">    // Mismatch in the number of points we have to align, bail.</a>
<a name="ln3136">    if (our_anchors.size() != map_anchor_points.size())</a>
<a name="ln3137">        return fail;</a>
<a name="ln3138"> </a>
<a name="ln3139">    // Align first point of both vectors, then check that the others match.</a>
<a name="ln3140">    const coord_def pos = map_anchor_points[0] - our_anchors[0];</a>
<a name="ln3141"> </a>
<a name="ln3142">    for (int i = 1, psize = map_anchor_points.size(); i &lt; psize; ++i)</a>
<a name="ln3143">        if (pos + our_anchors[i] != map_anchor_points[i])</a>
<a name="ln3144">            return fail;</a>
<a name="ln3145"> </a>
<a name="ln3146">    // Looking good, check bounds.</a>
<a name="ln3147">    if (!map_bounds(pos) || !map_bounds(pos + size() - 1))</a>
<a name="ln3148">        return fail;</a>
<a name="ln3149"> </a>
<a name="ln3150">    // Go us!</a>
<a name="ln3151">    return pos;</a>
<a name="ln3152">}</a>
<a name="ln3153"> </a>
<a name="ln3154">coord_def map_def::float_place()</a>
<a name="ln3155">{</a>
<a name="ln3156">    ASSERT(orient == MAP_FLOAT);</a>
<a name="ln3157"> </a>
<a name="ln3158">    coord_def pos(-1, -1);</a>
<a name="ln3159"> </a>
<a name="ln3160">    if (!map_anchor_points.empty())</a>
<a name="ln3161">        pos = float_aligned_place();</a>
<a name="ln3162">    else</a>
<a name="ln3163">    {</a>
<a name="ln3164">        if (coinflip())</a>
<a name="ln3165">            pos = float_dock();</a>
<a name="ln3166"> </a>
<a name="ln3167">        if (pos.x == -1)</a>
<a name="ln3168">            pos = float_random_place();</a>
<a name="ln3169">    }</a>
<a name="ln3170"> </a>
<a name="ln3171">    return pos;</a>
<a name="ln3172">}</a>
<a name="ln3173"> </a>
<a name="ln3174">void map_def::hmirror()</a>
<a name="ln3175">{</a>
<a name="ln3176">    if (has_tag(&quot;no_hmirror&quot;))</a>
<a name="ln3177">        return;</a>
<a name="ln3178"> </a>
<a name="ln3179">    dprf(DIAG_DNGN, &quot;Mirroring %s horizontally.&quot;, name.c_str());</a>
<a name="ln3180">    map.hmirror();</a>
<a name="ln3181"> </a>
<a name="ln3182">    switch (orient)</a>
<a name="ln3183">    {</a>
<a name="ln3184">    case MAP_EAST:      orient = MAP_WEST; break;</a>
<a name="ln3185">    case MAP_NORTHEAST: orient = MAP_NORTHWEST; break;</a>
<a name="ln3186">    case MAP_SOUTHEAST: orient = MAP_SOUTHWEST; break;</a>
<a name="ln3187">    case MAP_WEST:      orient = MAP_EAST; break;</a>
<a name="ln3188">    case MAP_NORTHWEST: orient = MAP_NORTHEAST; break;</a>
<a name="ln3189">    case MAP_SOUTHWEST: orient = MAP_SOUTHEAST; break;</a>
<a name="ln3190">    default: break;</a>
<a name="ln3191">    }</a>
<a name="ln3192"> </a>
<a name="ln3193">    for (subvault_place &amp;sv : subvault_places)</a>
<a name="ln3194">    {</a>
<a name="ln3195"> </a>
<a name="ln3196">        coord_def old_tl = sv.tl;</a>
<a name="ln3197">        coord_def old_br = sv.br;</a>
<a name="ln3198">        sv.tl.x = map.width() - 1 - old_br.x;</a>
<a name="ln3199">        sv.br.x = map.width() - 1 - old_tl.x;</a>
<a name="ln3200"> </a>
<a name="ln3201">        sv.subvault-&gt;map.hmirror();</a>
<a name="ln3202">    }</a>
<a name="ln3203">}</a>
<a name="ln3204"> </a>
<a name="ln3205">void map_def::vmirror()</a>
<a name="ln3206">{</a>
<a name="ln3207">    if (has_tag(&quot;no_vmirror&quot;))</a>
<a name="ln3208">        return;</a>
<a name="ln3209"> </a>
<a name="ln3210">    dprf(DIAG_DNGN, &quot;Mirroring %s vertically.&quot;, name.c_str());</a>
<a name="ln3211">    map.vmirror();</a>
<a name="ln3212"> </a>
<a name="ln3213">    switch (orient)</a>
<a name="ln3214">    {</a>
<a name="ln3215">    case MAP_NORTH:     orient = MAP_SOUTH; break;</a>
<a name="ln3216">    case MAP_NORTHEAST: orient = MAP_SOUTHEAST; break;</a>
<a name="ln3217">    case MAP_NORTHWEST: orient = MAP_SOUTHWEST; break;</a>
<a name="ln3218"> </a>
<a name="ln3219">    case MAP_SOUTH:     orient = MAP_NORTH; break;</a>
<a name="ln3220">    case MAP_SOUTHEAST: orient = MAP_NORTHEAST; break;</a>
<a name="ln3221">    case MAP_SOUTHWEST: orient = MAP_NORTHWEST; break;</a>
<a name="ln3222">    default: break;</a>
<a name="ln3223">    }</a>
<a name="ln3224"> </a>
<a name="ln3225">    for (subvault_place&amp; sv : subvault_places)</a>
<a name="ln3226">    {</a>
<a name="ln3227">        coord_def old_tl = sv.tl;</a>
<a name="ln3228">        coord_def old_br = sv.br;</a>
<a name="ln3229">        sv.tl.y = map.height() - 1 - old_br.y;</a>
<a name="ln3230">        sv.br.y = map.height() - 1 - old_tl.y;</a>
<a name="ln3231"> </a>
<a name="ln3232">        sv.subvault-&gt;map.vmirror();</a>
<a name="ln3233">    }</a>
<a name="ln3234">}</a>
<a name="ln3235"> </a>
<a name="ln3236">void map_def::rotate(bool clock)</a>
<a name="ln3237">{</a>
<a name="ln3238">    if (has_tag(&quot;no_rotate&quot;))</a>
<a name="ln3239">        return;</a>
<a name="ln3240"> </a>
<a name="ln3241">#define GMINM ((GXM) &lt; (GYM)? (GXM) : (GYM))</a>
<a name="ln3242">    // Make sure the largest dimension fits in the smaller map bound.</a>
<a name="ln3243">    if (map.width() &lt;= GMINM &amp;&amp; map.height() &lt;= GMINM)</a>
<a name="ln3244">    {</a>
<a name="ln3245">        dprf(DIAG_DNGN, &quot;Rotating %s %sclockwise.&quot;,</a>
<a name="ln3246">             name.c_str(), !clock? &quot;anti-&quot; : &quot;&quot;);</a>
<a name="ln3247">        map.rotate(clock);</a>
<a name="ln3248"> </a>
<a name="ln3249">        // Orientation shifts for clockwise rotation:</a>
<a name="ln3250">        const map_section_type clockrotate_orients[][2] =</a>
<a name="ln3251">        {</a>
<a name="ln3252">            { MAP_NORTH,        MAP_EAST        },</a>
<a name="ln3253">            { MAP_NORTHEAST,    MAP_SOUTHEAST   },</a>
<a name="ln3254">            { MAP_EAST,         MAP_SOUTH       },</a>
<a name="ln3255">            { MAP_SOUTHEAST,    MAP_SOUTHWEST   },</a>
<a name="ln3256">            { MAP_SOUTH,        MAP_WEST        },</a>
<a name="ln3257">            { MAP_SOUTHWEST,    MAP_NORTHWEST   },</a>
<a name="ln3258">            { MAP_WEST,         MAP_NORTH       },</a>
<a name="ln3259">            { MAP_NORTHWEST,    MAP_NORTHEAST   },</a>
<a name="ln3260">        };</a>
<a name="ln3261">        const int nrots = ARRAYSZ(clockrotate_orients);</a>
<a name="ln3262"> </a>
<a name="ln3263">        const int refindex = !clock;</a>
<a name="ln3264">        for (int i = 0; i &lt; nrots; ++i)</a>
<a name="ln3265">            if (orient == clockrotate_orients[i][refindex])</a>
<a name="ln3266">            {</a>
<a name="ln3267">                orient = clockrotate_orients[i][!refindex];</a>
<a name="ln3268">                break;</a>
<a name="ln3269">            }</a>
<a name="ln3270"> </a>
<a name="ln3271">        for (subvault_place&amp; sv : subvault_places)</a>
<a name="ln3272">        {</a>
<a name="ln3273">            coord_def p1, p2;</a>
<a name="ln3274">            if (clock) //Clockwise</a>
<a name="ln3275">            {</a>
<a name="ln3276">                p1 = coord_def(map.width() - 1 - sv.tl.y, sv.tl.x);</a>
<a name="ln3277">                p2 = coord_def(map.width() - 1 - sv.br.y, sv.br.x);</a>
<a name="ln3278">            }</a>
<a name="ln3279">            else</a>
<a name="ln3280">            {</a>
<a name="ln3281">                p1 = coord_def(sv.tl.y, map.height() - 1 - sv.tl.x);</a>
<a name="ln3282">                p2 = coord_def(sv.br.y, map.height() - 1 - sv.br.x);</a>
<a name="ln3283">            }</a>
<a name="ln3284"> </a>
<a name="ln3285">            sv.tl = coord_def(min(p1.x, p2.x), min(p1.y, p2.y));</a>
<a name="ln3286">            sv.br = coord_def(max(p1.x, p2.x), max(p1.y, p2.y));</a>
<a name="ln3287"> </a>
<a name="ln3288">            sv.subvault-&gt;map.rotate(clock);</a>
<a name="ln3289">        }</a>
<a name="ln3290">    }</a>
<a name="ln3291">}</a>
<a name="ln3292"> </a>
<a name="ln3293">void map_def::normalise()</a>
<a name="ln3294">{</a>
<a name="ln3295">    // Pad out lines that are shorter than max.</a>
<a name="ln3296">    map.normalise(' ');</a>
<a name="ln3297">}</a>
<a name="ln3298"> </a>
<a name="ln3299">string map_def::resolve()</a>
<a name="ln3300">{</a>
<a name="ln3301">    dlua_set_map dl(this);</a>
<a name="ln3302">    return &quot;&quot;;</a>
<a name="ln3303">}</a>
<a name="ln3304"> </a>
<a name="ln3305">void map_def::fixup()</a>
<a name="ln3306">{</a>
<a name="ln3307">    normalise();</a>
<a name="ln3308"> </a>
<a name="ln3309">    // Fixup minivaults into floating vaults tagged &quot;minivault&quot;.</a>
<a name="ln3310">    if (orient == MAP_NONE)</a>
<a name="ln3311">    {</a>
<a name="ln3312">        orient = MAP_FLOAT;</a>
<a name="ln3313">        add_tags(&quot;minivault&quot;);</a>
<a name="ln3314">    }</a>
<a name="ln3315">}</a>
<a name="ln3316"> </a>
<a name="ln3317">bool map_def::has_all_tags(const string &amp;tagswanted) const</a>
<a name="ln3318">{</a>
<a name="ln3319">    const auto &amp;tags_set = parse_tags(tagswanted);</a>
<a name="ln3320">    return has_all_tags(tags_set.begin(), tags_set.end());</a>
<a name="ln3321">}</a>
<a name="ln3322"> </a>
<a name="ln3323">bool map_def::has_tag(const string &amp;tagwanted) const</a>
<a name="ln3324">{</a>
<a name="ln3325">#ifdef DEBUG_TAG_PROFILING</a>
<a name="ln3326">    _profile_inc_tag(tagwanted);</a>
<a name="ln3327">#endif</a>
<a name="ln3328">    return tags.count(tagwanted) &gt; 0;</a>
<a name="ln3329">}</a>
<a name="ln3330"> </a>
<a name="ln3331">bool map_def::has_tag_prefix(const string &amp;prefix) const</a>
<a name="ln3332">{</a>
<a name="ln3333">    if (prefix.empty())</a>
<a name="ln3334">        return false;</a>
<a name="ln3335">    for (const auto &amp;tag : tags)</a>
<a name="ln3336">        if (starts_with(tag, prefix))</a>
<a name="ln3337">            return true;</a>
<a name="ln3338">    return false;</a>
<a name="ln3339">}</a>
<a name="ln3340"> </a>
<a name="ln3341">bool map_def::has_tag_suffix(const string &amp;suffix) const</a>
<a name="ln3342">{</a>
<a name="ln3343">    if (suffix.empty())</a>
<a name="ln3344">        return false;</a>
<a name="ln3345">    for (const auto &amp;tag : tags)</a>
<a name="ln3346">        if (ends_with(tag, suffix))</a>
<a name="ln3347">            return true;</a>
<a name="ln3348">    return false;</a>
<a name="ln3349">}</a>
<a name="ln3350"> </a>
<a name="ln3351">const unordered_set&lt;string&gt; map_def::get_tags_unsorted() const</a>
<a name="ln3352">{</a>
<a name="ln3353">    return tags;</a>
<a name="ln3354">}</a>
<a name="ln3355"> </a>
<a name="ln3356">const vector&lt;string&gt; map_def::get_tags() const</a>
<a name="ln3357">{</a>
<a name="ln3358">    // this might seem inefficient, but get_tags is not called very much; the</a>
<a name="ln3359">    // hotspot revealed by profiling is actually has_tag checks.</a>
<a name="ln3360">    vector&lt;string&gt; result(tags.begin(), tags.end());</a>
<a name="ln3361">    sort(result.begin(), result.end());</a>
<a name="ln3362">    return result;</a>
<a name="ln3363">}</a>
<a name="ln3364"> </a>
<a name="ln3365">void map_def::add_tags(const string &amp;tag)</a>
<a name="ln3366">{</a>
<a name="ln3367">    auto parsed_tags = parse_tags(tag);</a>
<a name="ln3368">    tags.insert(parsed_tags.begin(), parsed_tags.end());</a>
<a name="ln3369">    update_cached_tags();</a>
<a name="ln3370">}</a>
<a name="ln3371"> </a>
<a name="ln3372">bool map_def::remove_tags(const string &amp;tag)</a>
<a name="ln3373">{</a>
<a name="ln3374">    bool removed = false;</a>
<a name="ln3375">    auto parsed_tags = parse_tags(tag);</a>
<a name="ln3376">    for (auto &amp;t : parsed_tags)</a>
<a name="ln3377">        removed = tags.erase(t) || removed; // would iterator overload be ok?</a>
<a name="ln3378">    update_cached_tags();</a>
<a name="ln3379">    return removed;</a>
<a name="ln3380">}</a>
<a name="ln3381"> </a>
<a name="ln3382">void map_def::clear_tags()</a>
<a name="ln3383">{</a>
<a name="ln3384">    tags.clear();</a>
<a name="ln3385">    update_cached_tags();</a>
<a name="ln3386">}</a>
<a name="ln3387"> </a>
<a name="ln3388">void map_def::set_tags(const string &amp;tag)</a>
<a name="ln3389">{</a>
<a name="ln3390">    clear_tags();</a>
<a name="ln3391">    add_tags(tag);</a>
<a name="ln3392">    update_cached_tags();</a>
<a name="ln3393">}</a>
<a name="ln3394"> </a>
<a name="ln3395">string map_def::tags_string() const</a>
<a name="ln3396">{</a>
<a name="ln3397">    auto sorted_tags = get_tags();</a>
<a name="ln3398">    return join_strings(sorted_tags.begin(), sorted_tags.end());</a>
<a name="ln3399">}</a>
<a name="ln3400"> </a>
<a name="ln3401">keyed_mapspec *map_def::mapspec_at(const coord_def &amp;c)</a>
<a name="ln3402">{</a>
<a name="ln3403">    return map.mapspec_at(c);</a>
<a name="ln3404">}</a>
<a name="ln3405"> </a>
<a name="ln3406">const keyed_mapspec *map_def::mapspec_at(const coord_def &amp;c) const</a>
<a name="ln3407">{</a>
<a name="ln3408">    return map.mapspec_at(c);</a>
<a name="ln3409">}</a>
<a name="ln3410"> </a>
<a name="ln3411">string map_def::subvault_from_tagstring(const string &amp;sub)</a>
<a name="ln3412">{</a>
<a name="ln3413">    string s = trimmed_string(sub);</a>
<a name="ln3414"> </a>
<a name="ln3415">    if (s.empty())</a>
<a name="ln3416">        return &quot;&quot;;</a>
<a name="ln3417"> </a>
<a name="ln3418">    int sep = 0;</a>
<a name="ln3419">    string key;</a>
<a name="ln3420">    string substitute;</a>
<a name="ln3421"> </a>
<a name="ln3422">    string err = mapdef_split_key_item(sub, &amp;key, &amp;sep, &amp;substitute, -1);</a>
<a name="ln3423">    if (!err.empty())</a>
<a name="ln3424">        return err;</a>
<a name="ln3425"> </a>
<a name="ln3426">    // Randomly picking a different vault per-glyph is not supported.</a>
<a name="ln3427">    if (sep != ':')</a>
<a name="ln3428">        return &quot;SUBVAULT does not support '='. Use ':' instead.&quot;;</a>
<a name="ln3429"> </a>
<a name="ln3430">    map_string_list vlist;</a>
<a name="ln3431">    err = _parse_weighted_str&lt;map_string_list&gt;(substitute, vlist);</a>
<a name="ln3432">    if (!err.empty())</a>
<a name="ln3433">        return err;</a>
<a name="ln3434"> </a>
<a name="ln3435">    bool fix = false;</a>
<a name="ln3436">    string_spec spec(key, fix, vlist);</a>
<a name="ln3437"> </a>
<a name="ln3438">    // Although it's unfortunate to not be able to validate subvaults except a</a>
<a name="ln3439">    // run-time, this allows subvaults to reference maps by tag that may not</a>
<a name="ln3440">    // have been loaded yet.</a>
<a name="ln3441">    if (!is_validating())</a>
<a name="ln3442">        err = apply_subvault(spec);</a>
<a name="ln3443"> </a>
<a name="ln3444">    if (!err.empty())</a>
<a name="ln3445">        return err;</a>
<a name="ln3446"> </a>
<a name="ln3447">    return &quot;&quot;;</a>
<a name="ln3448">}</a>
<a name="ln3449"> </a>
<a name="ln3450">static void _register_subvault(const string &amp;name, const string &amp;spaced_tags)</a>
<a name="ln3451">{</a>
<a name="ln3452">    auto parsed_tags = parse_tags(spaced_tags);</a>
<a name="ln3453">    if (!parsed_tags.count(&quot;allow_dup&quot;) || parsed_tags.count(&quot;luniq&quot;))</a>
<a name="ln3454">        env.new_used_subvault_names.insert(name);</a>
<a name="ln3455"> </a>
<a name="ln3456">    for (const string &amp;tag : parsed_tags)</a>
<a name="ln3457">        if (starts_with(tag, &quot;uniq_&quot;) || starts_with(tag, &quot;luniq_&quot;))</a>
<a name="ln3458">            env.new_used_subvault_tags.insert(tag);</a>
<a name="ln3459">}</a>
<a name="ln3460"> </a>
<a name="ln3461">static void _reset_subvault_stack(const int reg_stack)</a>
<a name="ln3462">{</a>
<a name="ln3463">    env.new_subvault_names.resize(reg_stack);</a>
<a name="ln3464">    env.new_subvault_tags.resize(reg_stack);</a>
<a name="ln3465"> </a>
<a name="ln3466">    env.new_used_subvault_names.clear();</a>
<a name="ln3467">    env.new_used_subvault_tags.clear();</a>
<a name="ln3468">    for (int i = 0; i &lt; reg_stack; i++)</a>
<a name="ln3469">    {</a>
<a name="ln3470">        _register_subvault(env.new_subvault_names[i],</a>
<a name="ln3471">                           env.new_subvault_tags[i]);</a>
<a name="ln3472">    }</a>
<a name="ln3473">}</a>
<a name="ln3474"> </a>
<a name="ln3475">string map_def::apply_subvault(string_spec &amp;spec)</a>
<a name="ln3476">{</a>
<a name="ln3477">    // Find bounding box for key glyphs</a>
<a name="ln3478">    coord_def tl, br;</a>
<a name="ln3479">    if (!map.find_bounds(spec.key.c_str(), tl, br))</a>
<a name="ln3480">    {</a>
<a name="ln3481">        // No glyphs, so do nothing.</a>
<a name="ln3482">        return &quot;&quot;;</a>
<a name="ln3483">    }</a>
<a name="ln3484"> </a>
<a name="ln3485">    int vwidth = br.x - tl.x + 1;</a>
<a name="ln3486">    int vheight = br.y - tl.y + 1;</a>
<a name="ln3487">    Matrix&lt;bool&gt; flags(vwidth, vheight);</a>
<a name="ln3488">    map.fill_mask_matrix(spec.key, tl, br, flags);</a>
<a name="ln3489"> </a>
<a name="ln3490">    // Remember the subvault registration pointer, so we can clear it.</a>
<a name="ln3491">    const int reg_stack = env.new_subvault_names.size();</a>
<a name="ln3492">    ASSERT(reg_stack == (int)env.new_subvault_tags.size());</a>
<a name="ln3493">    ASSERT(reg_stack &gt;= (int)env.new_used_subvault_names.size());</a>
<a name="ln3494"> </a>
<a name="ln3495">    const int max_tries = 100;</a>
<a name="ln3496">    int ntries = 0;</a>
<a name="ln3497"> </a>
<a name="ln3498">    string tag = spec.get_property();</a>
<a name="ln3499">    while (++ntries &lt;= max_tries)</a>
<a name="ln3500">    {</a>
<a name="ln3501">        // Each iteration, restore tags and names. This is because this vault</a>
<a name="ln3502">        // may successfully load a subvault (registering its tag and name), but</a>
<a name="ln3503">        // then itself fail.</a>
<a name="ln3504">        _reset_subvault_stack(reg_stack);</a>
<a name="ln3505"> </a>
<a name="ln3506">        const map_def *orig = random_map_for_tag(tag, true);</a>
<a name="ln3507">        if (!orig)</a>
<a name="ln3508">            return make_stringf(&quot;No vault found for tag '%s'&quot;, tag.c_str());</a>
<a name="ln3509"> </a>
<a name="ln3510">        map_def vault = *orig;</a>
<a name="ln3511"> </a>
<a name="ln3512">        vault.load();</a>
<a name="ln3513"> </a>
<a name="ln3514">        // Temporarily set the subvault mask so this subvault can know</a>
<a name="ln3515">        // that it is being generated as a subvault.</a>
<a name="ln3516">        vault.svmask = &amp;flags;</a>
<a name="ln3517"> </a>
<a name="ln3518">        if (!resolve_subvault(vault))</a>
<a name="ln3519">            continue;</a>
<a name="ln3520"> </a>
<a name="ln3521">        ASSERT(vault.map.width() &lt;= vwidth);</a>
<a name="ln3522">        ASSERT(vault.map.height() &lt;= vheight);</a>
<a name="ln3523"> </a>
<a name="ln3524">        const map_corner_t subvault_corners =</a>
<a name="ln3525">            map.merge_subvault(tl, br, flags, vault);</a>
<a name="ln3526"> </a>
<a name="ln3527">        copy_hooks_from(vault, &quot;post_place&quot;);</a>
<a name="ln3528">        env.new_subvault_names.push_back(vault.name);</a>
<a name="ln3529">        const string vault_tags = vault.tags_string();</a>
<a name="ln3530">        env.new_subvault_tags.push_back(vault_tags);</a>
<a name="ln3531">        _register_subvault(vault.name, vault_tags);</a>
<a name="ln3532">        subvault_places.emplace_back(subvault_corners.first,</a>
<a name="ln3533">                                     subvault_corners.second, vault);</a>
<a name="ln3534"> </a>
<a name="ln3535">        return &quot;&quot;;</a>
<a name="ln3536">    }</a>
<a name="ln3537"> </a>
<a name="ln3538">    // Failure, drop subvault registrations.</a>
<a name="ln3539">    _reset_subvault_stack(reg_stack);</a>
<a name="ln3540"> </a>
<a name="ln3541">    return make_stringf(&quot;Could not fit '%s' in (%d,%d) to (%d, %d).&quot;,</a>
<a name="ln3542">                        tag.c_str(), tl.x, tl.y, br.x, br.y);</a>
<a name="ln3543">}</a>
<a name="ln3544"> </a>
<a name="ln3545">bool map_def::is_subvault() const</a>
<a name="ln3546">{</a>
<a name="ln3547">    return svmask != nullptr;</a>
<a name="ln3548">}</a>
<a name="ln3549"> </a>
<a name="ln3550">void map_def::apply_subvault_mask()</a>
<a name="ln3551">{</a>
<a name="ln3552">    if (!svmask)</a>
<a name="ln3553">        return;</a>
<a name="ln3554"> </a>
<a name="ln3555">    map.clear();</a>
<a name="ln3556">    map.extend(subvault_width(), subvault_height(), ' ');</a>
<a name="ln3557"> </a>
<a name="ln3558">    for (rectangle_iterator ri(map.get_iter()); ri; ++ri)</a>
<a name="ln3559">    {</a>
<a name="ln3560">        const coord_def mc = *ri;</a>
<a name="ln3561">        if (subvault_cell_valid(mc))</a>
<a name="ln3562">            map(mc) = '.';</a>
<a name="ln3563">        else</a>
<a name="ln3564">            map(mc) = ' ';</a>
<a name="ln3565">    }</a>
<a name="ln3566">}</a>
<a name="ln3567"> </a>
<a name="ln3568">bool map_def::subvault_cell_valid(const coord_def &amp;c) const</a>
<a name="ln3569">{</a>
<a name="ln3570">    if (!svmask)</a>
<a name="ln3571">        return false;</a>
<a name="ln3572"> </a>
<a name="ln3573">    if (c.x &lt; 0 || c.x &gt;= subvault_width()</a>
<a name="ln3574">        || c.y &lt; 0 || c.y &gt;= subvault_height())</a>
<a name="ln3575">    {</a>
<a name="ln3576">        return false;</a>
<a name="ln3577">    }</a>
<a name="ln3578"> </a>
<a name="ln3579">    return (*svmask)(c.x, c.y);</a>
<a name="ln3580">}</a>
<a name="ln3581"> </a>
<a name="ln3582">int map_def::subvault_width() const</a>
<a name="ln3583">{</a>
<a name="ln3584">    if (!svmask)</a>
<a name="ln3585">        return 0;</a>
<a name="ln3586"> </a>
<a name="ln3587">    return svmask-&gt;width();</a>
<a name="ln3588">}</a>
<a name="ln3589"> </a>
<a name="ln3590">int map_def::subvault_height() const</a>
<a name="ln3591">{</a>
<a name="ln3592">    if (!svmask)</a>
<a name="ln3593">        return 0;</a>
<a name="ln3594"> </a>
<a name="ln3595">    return svmask-&gt;height();</a>
<a name="ln3596">}</a>
<a name="ln3597"> </a>
<a name="ln3598">int map_def::subvault_mismatch_count(const coord_def &amp;offset) const</a>
<a name="ln3599">{</a>
<a name="ln3600">    int count = 0;</a>
<a name="ln3601">    if (!is_subvault())</a>
<a name="ln3602">        return count;</a>
<a name="ln3603"> </a>
<a name="ln3604">    for (rectangle_iterator ri(map.get_iter()); ri; ++ri)</a>
<a name="ln3605">    {</a>
<a name="ln3606">        // Coordinate in the subvault</a>
<a name="ln3607">        const coord_def sc = *ri;</a>
<a name="ln3608">        // Coordinate in the mask</a>
<a name="ln3609">        const coord_def mc = sc + offset;</a>
<a name="ln3610"> </a>
<a name="ln3611">        bool valid_subvault_cell = (map(sc) != ' ');</a>
<a name="ln3612">        bool valid_mask = (*svmask)(mc.x, mc.y);</a>
<a name="ln3613"> </a>
<a name="ln3614">        if (valid_subvault_cell &amp;&amp; !valid_mask)</a>
<a name="ln3615">            count++;</a>
<a name="ln3616">    }</a>
<a name="ln3617"> </a>
<a name="ln3618">    return count;</a>
<a name="ln3619">}</a>
<a name="ln3620"> </a>
<a name="ln3621">///////////////////////////////////////////////////////////////////</a>
<a name="ln3622">// mons_list</a>
<a name="ln3623">//</a>
<a name="ln3624"> </a>
<a name="ln3625">mons_list::mons_list() : mons()</a>
<a name="ln3626">{</a>
<a name="ln3627">}</a>
<a name="ln3628"> </a>
<a name="ln3629">mons_spec mons_list::pick_monster(mons_spec_slot &amp;slot)</a>
<a name="ln3630">{</a>
<a name="ln3631">    int totweight = 0;</a>
<a name="ln3632">    mons_spec pick;</a>
<a name="ln3633"> </a>
<a name="ln3634">    for (const auto &amp;spec : slot.mlist)</a>
<a name="ln3635">    {</a>
<a name="ln3636">        const int weight = spec.genweight;</a>
<a name="ln3637">        if (x_chance_in_y(weight, totweight += weight))</a>
<a name="ln3638">            pick = spec;</a>
<a name="ln3639">    }</a>
<a name="ln3640"> </a>
<a name="ln3641">#if TAG_MAJOR_VERSION == 34</a>
<a name="ln3642">    // Force rebuild of the des cache to drop this check.</a>
<a name="ln3643">    if ((int)pick.type &lt; -1)</a>
<a name="ln3644">        pick = (monster_type)(-100 - (int)pick.type);</a>
<a name="ln3645">#endif</a>
<a name="ln3646"> </a>
<a name="ln3647">    if (slot.fix_slot)</a>
<a name="ln3648">    {</a>
<a name="ln3649">        slot.mlist.clear();</a>
<a name="ln3650">        slot.mlist.push_back(pick);</a>
<a name="ln3651">        slot.fix_slot = false;</a>
<a name="ln3652">    }</a>
<a name="ln3653"> </a>
<a name="ln3654">    return pick;</a>
<a name="ln3655">}</a>
<a name="ln3656"> </a>
<a name="ln3657">mons_spec mons_list::get_monster(int index)</a>
<a name="ln3658">{</a>
<a name="ln3659">    if (index &lt; 0 || index &gt;= (int)mons.size())</a>
<a name="ln3660">        return mons_spec(RANDOM_MONSTER);</a>
<a name="ln3661"> </a>
<a name="ln3662">    return pick_monster(mons[index]);</a>
<a name="ln3663">}</a>
<a name="ln3664"> </a>
<a name="ln3665">mons_spec mons_list::get_monster(int slot_index, int list_index) const</a>
<a name="ln3666">{</a>
<a name="ln3667">    if (slot_index &lt; 0 || slot_index &gt;= (int)mons.size())</a>
<a name="ln3668">        return mons_spec(RANDOM_MONSTER);</a>
<a name="ln3669"> </a>
<a name="ln3670">    const mons_spec_list &amp;list = mons[slot_index].mlist;</a>
<a name="ln3671"> </a>
<a name="ln3672">    if (list_index &lt; 0 || list_index &gt;= (int)list.size())</a>
<a name="ln3673">        return mons_spec(RANDOM_MONSTER);</a>
<a name="ln3674"> </a>
<a name="ln3675">    return list[list_index];</a>
<a name="ln3676">}</a>
<a name="ln3677"> </a>
<a name="ln3678">void mons_list::clear()</a>
<a name="ln3679">{</a>
<a name="ln3680">    mons.clear();</a>
<a name="ln3681">}</a>
<a name="ln3682"> </a>
<a name="ln3683">void mons_list::set_from_slot(const mons_list &amp;list, int slot_index)</a>
<a name="ln3684">{</a>
<a name="ln3685">    clear();</a>
<a name="ln3686"> </a>
<a name="ln3687">    // Don't set anything if an invalid index.</a>
<a name="ln3688">    // Future calls to get_monster will just return a random monster.</a>
<a name="ln3689">    if (slot_index &lt; 0 || (size_t)slot_index &gt;= list.mons.size())</a>
<a name="ln3690">        return;</a>
<a name="ln3691"> </a>
<a name="ln3692">    mons.push_back(list.mons[slot_index]);</a>
<a name="ln3693">}</a>
<a name="ln3694"> </a>
<a name="ln3695">void mons_list::parse_mons_spells(mons_spec &amp;spec, vector&lt;string&gt; &amp;spells)</a>
<a name="ln3696">{</a>
<a name="ln3697">    spec.explicit_spells = true;</a>
<a name="ln3698"> </a>
<a name="ln3699">    for (const string &amp;slotspec : spells)</a>
<a name="ln3700">    {</a>
<a name="ln3701">        monster_spells cur_spells;</a>
<a name="ln3702"> </a>
<a name="ln3703">        const vector&lt;string&gt; spell_names(split_string(&quot;;&quot;, slotspec));</a>
<a name="ln3704"> </a>
<a name="ln3705">        for (unsigned i = 0, ssize = spell_names.size(); i &lt; ssize; ++i)</a>
<a name="ln3706">        {</a>
<a name="ln3707">            cur_spells.emplace_back();</a>
<a name="ln3708">            const string spname(</a>
<a name="ln3709">                lowercase_string(replace_all_of(spell_names[i], &quot;_&quot;, &quot; &quot;)));</a>
<a name="ln3710">            if (spname.empty() || spname == &quot;.&quot; || spname == &quot;none&quot;</a>
<a name="ln3711">                || spname == &quot;no spell&quot;)</a>
<a name="ln3712">            {</a>
<a name="ln3713">                cur_spells[i].spell = SPELL_NO_SPELL;</a>
<a name="ln3714">            }</a>
<a name="ln3715">            else</a>
<a name="ln3716">            {</a>
<a name="ln3717">                const vector&lt;string&gt; slot_vals = split_string(&quot;.&quot;, spname);</a>
<a name="ln3718">                if (slot_vals.size() &lt; 2)</a>
<a name="ln3719">                {</a>
<a name="ln3720">                    error = make_stringf(</a>
<a name="ln3721">                        &quot;Invalid spell slot format: '%s' in '%s'&quot;,</a>
<a name="ln3722">                        spname.c_str(), slotspec.c_str());</a>
<a name="ln3723">                    return;</a>
<a name="ln3724">                }</a>
<a name="ln3725">                const spell_type sp(spell_by_name(slot_vals[0]));</a>
<a name="ln3726">                if (sp == SPELL_NO_SPELL)</a>
<a name="ln3727">                {</a>
<a name="ln3728">                    error = make_stringf(&quot;Unknown spell name: '%s' in '%s'&quot;,</a>
<a name="ln3729">                                         slot_vals[0].c_str(),</a>
<a name="ln3730">                                         slotspec.c_str());</a>
<a name="ln3731">                    return;</a>
<a name="ln3732">                }</a>
<a name="ln3733">                if (!is_valid_mon_spell(sp))</a>
<a name="ln3734">                {</a>
<a name="ln3735">                    error = make_stringf(&quot;Not a monster spell: '%s'&quot;,</a>
<a name="ln3736">                                         slot_vals[0].c_str());</a>
<a name="ln3737">                    return;</a>
<a name="ln3738">                }</a>
<a name="ln3739">                cur_spells[i].spell = sp;</a>
<a name="ln3740">                const int freq = atoi(slot_vals[1].c_str());</a>
<a name="ln3741">                if (freq &lt;= 0)</a>
<a name="ln3742">                {</a>
<a name="ln3743">                    error = make_stringf(&quot;Need a positive spell frequency;&quot;</a>
<a name="ln3744">                                         &quot;got '%s' in '%s'&quot;,</a>
<a name="ln3745">                                         slot_vals[1].c_str(),</a>
<a name="ln3746">                                         spname.c_str());</a>
<a name="ln3747">                    return;</a>
<a name="ln3748">                }</a>
<a name="ln3749">                cur_spells[i].freq = freq;</a>
<a name="ln3750">                for (size_t j = 2; j &lt; slot_vals.size(); j++)</a>
<a name="ln3751">                {</a>
<a name="ln3752">                    if (slot_vals[j] == &quot;emergency&quot;)</a>
<a name="ln3753">                        cur_spells[i].flags |= MON_SPELL_EMERGENCY;</a>
<a name="ln3754">                    if (slot_vals[j] == &quot;natural&quot;)</a>
<a name="ln3755">                        cur_spells[i].flags |= MON_SPELL_NATURAL;</a>
<a name="ln3756">                    if (slot_vals[j] == &quot;magical&quot;)</a>
<a name="ln3757">                        cur_spells[i].flags |= MON_SPELL_MAGICAL;</a>
<a name="ln3758">                    if (slot_vals[j] == &quot;wizard&quot;)</a>
<a name="ln3759">                        cur_spells[i].flags |= MON_SPELL_WIZARD;</a>
<a name="ln3760">                    if (slot_vals[j] == &quot;priest&quot;)</a>
<a name="ln3761">                        cur_spells[i].flags |= MON_SPELL_PRIEST;</a>
<a name="ln3762">                    if (slot_vals[j] == &quot;breath&quot;)</a>
<a name="ln3763">                        cur_spells[i].flags |= MON_SPELL_BREATH;</a>
<a name="ln3764">                    if (slot_vals[j] == &quot;no silent&quot;)</a>
<a name="ln3765">                        cur_spells[i].flags |= MON_SPELL_NO_SILENT;</a>
<a name="ln3766">                    if (slot_vals[j] == &quot;instant&quot;)</a>
<a name="ln3767">                        cur_spells[i].flags |= MON_SPELL_INSTANT;</a>
<a name="ln3768">                    if (slot_vals[j] == &quot;noisy&quot;)</a>
<a name="ln3769">                        cur_spells[i].flags |= MON_SPELL_NOISY;</a>
<a name="ln3770">                    if (slot_vals[j] == &quot;short range&quot;)</a>
<a name="ln3771">                        cur_spells[i].flags |= MON_SPELL_SHORT_RANGE;</a>
<a name="ln3772">                    if (slot_vals[j] == &quot;long range&quot;)</a>
<a name="ln3773">                        cur_spells[i].flags |= MON_SPELL_LONG_RANGE;</a>
<a name="ln3774">                }</a>
<a name="ln3775">                if (!(cur_spells[i].flags &amp; MON_SPELL_TYPE_MASK))</a>
<a name="ln3776">                {</a>
<a name="ln3777">                    error = make_stringf(</a>
<a name="ln3778">                        &quot;Spell slot '%s' missing a casting type&quot;,</a>
<a name="ln3779">                        spname.c_str());</a>
<a name="ln3780">                    return;</a>
<a name="ln3781">                }</a>
<a name="ln3782">            }</a>
<a name="ln3783">        }</a>
<a name="ln3784"> </a>
<a name="ln3785">        spec.spells.push_back(cur_spells);</a>
<a name="ln3786">    }</a>
<a name="ln3787">}</a>
<a name="ln3788"> </a>
<a name="ln3789">mon_enchant mons_list::parse_ench(string &amp;ench_str, bool perm)</a>
<a name="ln3790">{</a>
<a name="ln3791">    vector&lt;string&gt; ep = split_string(&quot;:&quot;, ench_str);</a>
<a name="ln3792">    if (ep.size() &gt; (perm ? 2 : 3))</a>
<a name="ln3793">    {</a>
<a name="ln3794">        error = make_stringf(&quot;bad %sench specifier: \&quot;%s\&quot;&quot;,</a>
<a name="ln3795">                             perm ? &quot;perm_&quot; : &quot;&quot;,</a>
<a name="ln3796">                             ench_str.c_str());</a>
<a name="ln3797">        return mon_enchant();</a>
<a name="ln3798">    }</a>
<a name="ln3799"> </a>
<a name="ln3800">    enchant_type et = name_to_ench(ep[0].c_str());</a>
<a name="ln3801">    if (et == ENCH_NONE)</a>
<a name="ln3802">    {</a>
<a name="ln3803">        error = make_stringf(&quot;unknown ench: \&quot;%s\&quot;&quot;, ep[0].c_str());</a>
<a name="ln3804">        return mon_enchant();</a>
<a name="ln3805">    }</a>
<a name="ln3806"> </a>
<a name="ln3807">    int deg = 0, dur = perm ? INFINITE_DURATION : 0;</a>
<a name="ln3808">    if (ep.size() &gt; 1 &amp;&amp; !ep[1].empty())</a>
<a name="ln3809">        if (!parse_int(ep[1].c_str(), deg))</a>
<a name="ln3810">        {</a>
<a name="ln3811">            error = make_stringf(&quot;invalid deg in ench specifier \&quot;%s\&quot;&quot;,</a>
<a name="ln3812">                                 ench_str.c_str());</a>
<a name="ln3813">            return mon_enchant();</a>
<a name="ln3814">        }</a>
<a name="ln3815">    if (ep.size() &gt; 2 &amp;&amp; !ep[2].empty())</a>
<a name="ln3816">        if (!parse_int(ep[2].c_str(), dur))</a>
<a name="ln3817">        {</a>
<a name="ln3818">            error = make_stringf(&quot;invalid dur in ench specifier \&quot;%s\&quot;&quot;,</a>
<a name="ln3819">                                 ench_str.c_str());</a>
<a name="ln3820">            return mon_enchant();</a>
<a name="ln3821">        }</a>
<a name="ln3822">    return mon_enchant(et, deg, 0, dur);</a>
<a name="ln3823">}</a>
<a name="ln3824"> </a>
<a name="ln3825">mons_list::mons_spec_slot mons_list::parse_mons_spec(string spec)</a>
<a name="ln3826">{</a>
<a name="ln3827">    mons_spec_slot slot;</a>
<a name="ln3828"> </a>
<a name="ln3829">    slot.fix_slot = strip_tag(spec, &quot;fix_slot&quot;);</a>
<a name="ln3830"> </a>
<a name="ln3831">    vector&lt;string&gt; specs = split_string(&quot;/&quot;, spec);</a>
<a name="ln3832"> </a>
<a name="ln3833">    for (const string &amp;monspec : specs)</a>
<a name="ln3834">    {</a>
<a name="ln3835">        string s(monspec);</a>
<a name="ln3836">        mons_spec mspec;</a>
<a name="ln3837"> </a>
<a name="ln3838">        vector&lt;string&gt; spells(strip_multiple_tag_prefix(s, &quot;spells:&quot;));</a>
<a name="ln3839">        if (!spells.empty())</a>
<a name="ln3840">        {</a>
<a name="ln3841">            parse_mons_spells(mspec, spells);</a>
<a name="ln3842">            if (!error.empty())</a>
<a name="ln3843">                return slot;</a>
<a name="ln3844">        }</a>
<a name="ln3845"> </a>
<a name="ln3846">        vector&lt;string&gt; parts = split_string(&quot;;&quot;, s);</a>
<a name="ln3847"> </a>
<a name="ln3848">        if (parts.size() == 0)</a>
<a name="ln3849">        {</a>
<a name="ln3850">            error = make_stringf(&quot;Not enough non-semicolons for '%s' spec.&quot;,</a>
<a name="ln3851">                                 s.c_str());</a>
<a name="ln3852">            return slot;</a>
<a name="ln3853">        }</a>
<a name="ln3854"> </a>
<a name="ln3855">        string mon_str = parts[0];</a>
<a name="ln3856"> </a>
<a name="ln3857">        if (parts.size() &gt; 2)</a>
<a name="ln3858">        {</a>
<a name="ln3859">            error = make_stringf(&quot;Too many semi-colons for '%s' spec.&quot;,</a>
<a name="ln3860">                                 mon_str.c_str());</a>
<a name="ln3861">            return slot;</a>
<a name="ln3862">        }</a>
<a name="ln3863">        else if (parts.size() == 2)</a>
<a name="ln3864">        {</a>
<a name="ln3865">            // TODO: Allow for a &quot;fix_slot&quot; type tag which will cause</a>
<a name="ln3866">            // all monsters generated from this spec to have the</a>
<a name="ln3867">            // exact same equipment.</a>
<a name="ln3868">            string items_str = parts[1];</a>
<a name="ln3869">            items_str = replace_all(items_str, &quot;|&quot;, &quot;/&quot;);</a>
<a name="ln3870"> </a>
<a name="ln3871">            vector&lt;string&gt; segs = split_string(&quot;.&quot;, items_str);</a>
<a name="ln3872"> </a>
<a name="ln3873">            if (segs.size() &gt; NUM_MONSTER_SLOTS)</a>
<a name="ln3874">            {</a>
<a name="ln3875">                error = make_stringf(&quot;More items than monster item slots &quot;</a>
<a name="ln3876">                                     &quot;for '%s'.&quot;, mon_str.c_str());</a>
<a name="ln3877">                return slot;</a>
<a name="ln3878">            }</a>
<a name="ln3879"> </a>
<a name="ln3880">            for (const string &amp;seg : segs)</a>
<a name="ln3881">            {</a>
<a name="ln3882">                error = mspec.items.add_item(seg, false);</a>
<a name="ln3883">                if (!error.empty())</a>
<a name="ln3884">                    return slot;</a>
<a name="ln3885">            }</a>
<a name="ln3886">        }</a>
<a name="ln3887"> </a>
<a name="ln3888">        mspec.genweight = find_weight(mon_str);</a>
<a name="ln3889">        if (mspec.genweight == TAG_UNFOUND || mspec.genweight &lt;= 0)</a>
<a name="ln3890">            mspec.genweight = 10;</a>
<a name="ln3891"> </a>
<a name="ln3892">        mspec.generate_awake = strip_tag(mon_str, &quot;generate_awake&quot;);</a>
<a name="ln3893">        mspec.patrolling     = strip_tag(mon_str, &quot;patrolling&quot;);</a>
<a name="ln3894">        mspec.band           = strip_tag(mon_str, &quot;band&quot;);</a>
<a name="ln3895"> </a>
<a name="ln3896">        const string att = strip_tag_prefix(mon_str, &quot;att:&quot;);</a>
<a name="ln3897">        if (att.empty() || att == &quot;hostile&quot;)</a>
<a name="ln3898">            mspec.attitude = ATT_HOSTILE;</a>
<a name="ln3899">        else if (att == &quot;friendly&quot;)</a>
<a name="ln3900">            mspec.attitude = ATT_FRIENDLY;</a>
<a name="ln3901">        else if (att == &quot;good_neutral&quot;)</a>
<a name="ln3902">            mspec.attitude = ATT_GOOD_NEUTRAL;</a>
<a name="ln3903">        else if (att == &quot;fellow_slime&quot; || att == &quot;strict_neutral&quot;)</a>
<a name="ln3904">            mspec.attitude = ATT_STRICT_NEUTRAL;</a>
<a name="ln3905">        else if (att == &quot;neutral&quot;)</a>
<a name="ln3906">            mspec.attitude = ATT_NEUTRAL;</a>
<a name="ln3907"> </a>
<a name="ln3908">        // Useful for summoned monsters.</a>
<a name="ln3909">        if (strip_tag(mon_str, &quot;seen&quot;))</a>
<a name="ln3910">            mspec.extra_monster_flags |= MF_SEEN;</a>
<a name="ln3911"> </a>
<a name="ln3912">        if (strip_tag(mon_str, &quot;always_corpse&quot;))</a>
<a name="ln3913">            mspec.props[&quot;always_corpse&quot;] = true;</a>
<a name="ln3914"> </a>
<a name="ln3915">        if (strip_tag(mon_str, NEVER_CORPSE_KEY))</a>
<a name="ln3916">            mspec.props[NEVER_CORPSE_KEY] = true;</a>
<a name="ln3917"> </a>
<a name="ln3918">        if (!mon_str.empty() &amp;&amp; isadigit(mon_str[0]))</a>
<a name="ln3919">        {</a>
<a name="ln3920">            // Look for space after initial digits.</a>
<a name="ln3921">            string::size_type pos = mon_str.find_first_not_of(&quot;0123456789&quot;);</a>
<a name="ln3922">            if (pos != string::npos &amp;&amp; mon_str[pos] == ' ')</a>
<a name="ln3923">            {</a>
<a name="ln3924">                const string mcount = mon_str.substr(0, pos);</a>
<a name="ln3925">                const int count = atoi(mcount.c_str()); // safe atoi()</a>
<a name="ln3926">                if (count &gt;= 1 &amp;&amp; count &lt;= 99)</a>
<a name="ln3927">                    mspec.quantity = count;</a>
<a name="ln3928"> </a>
<a name="ln3929">                mon_str = mon_str.substr(pos);</a>
<a name="ln3930">            }</a>
<a name="ln3931">        }</a>
<a name="ln3932"> </a>
<a name="ln3933">        // place:Elf:$ to choose monsters appropriate for that level,</a>
<a name="ln3934">        // for example.</a>
<a name="ln3935">        const string place = strip_tag_prefix(mon_str, &quot;place:&quot;);</a>
<a name="ln3936">        if (!place.empty())</a>
<a name="ln3937">        {</a>
<a name="ln3938">            try</a>
<a name="ln3939">            {</a>
<a name="ln3940">                mspec.place = level_id::parse_level_id(place);</a>
<a name="ln3941">            }</a>
<a name="ln3942">            catch (const bad_level_id &amp;err)</a>
<a name="ln3943">            {</a>
<a name="ln3944">                error = err.what();</a>
<a name="ln3945">                return slot;</a>
<a name="ln3946">            }</a>
<a name="ln3947">        }</a>
<a name="ln3948"> </a>
<a name="ln3949">        mspec.hd = min(100, strip_number_tag(mon_str, &quot;hd:&quot;));</a>
<a name="ln3950">        if (mspec.hd == TAG_UNFOUND)</a>
<a name="ln3951">            mspec.hd = 0;</a>
<a name="ln3952"> </a>
<a name="ln3953">        mspec.hp = strip_number_tag(mon_str, &quot;hp:&quot;);</a>
<a name="ln3954">        if (mspec.hp == TAG_UNFOUND)</a>
<a name="ln3955">            mspec.hp = 0;</a>
<a name="ln3956"> </a>
<a name="ln3957">        int dur = strip_number_tag(mon_str, &quot;dur:&quot;);</a>
<a name="ln3958">        if (dur == TAG_UNFOUND)</a>
<a name="ln3959">            dur = 0;</a>
<a name="ln3960">        else if (dur &lt; 1 || dur &gt; 6)</a>
<a name="ln3961">            dur = 0;</a>
<a name="ln3962"> </a>
<a name="ln3963">        mspec.abjuration_duration = dur;</a>
<a name="ln3964"> </a>
<a name="ln3965">        string shifter_name = replace_all_of(strip_tag_prefix(mon_str, &quot;shifter:&quot;), &quot;_&quot;, &quot; &quot;);</a>
<a name="ln3966"> </a>
<a name="ln3967">        if (!shifter_name.empty())</a>
<a name="ln3968">        {</a>
<a name="ln3969">            mspec.initial_shifter = get_monster_by_name(shifter_name);</a>
<a name="ln3970">            if (mspec.initial_shifter == MONS_PROGRAM_BUG)</a>
<a name="ln3971">                mspec.initial_shifter = RANDOM_MONSTER;</a>
<a name="ln3972">        }</a>
<a name="ln3973"> </a>
<a name="ln3974">        int summon_type = 0;</a>
<a name="ln3975">        string s_type = strip_tag_prefix(mon_str, &quot;sum:&quot;);</a>
<a name="ln3976">        if (!s_type.empty())</a>
<a name="ln3977">        {</a>
<a name="ln3978">            // In case of spells!</a>
<a name="ln3979">            s_type = replace_all_of(s_type, &quot;_&quot;, &quot; &quot;);</a>
<a name="ln3980">            summon_type = static_cast&lt;int&gt;(str_to_summon_type(s_type));</a>
<a name="ln3981">            if (summon_type == SPELL_NO_SPELL)</a>
<a name="ln3982">            {</a>
<a name="ln3983">                error = make_stringf(&quot;bad monster summon type: \&quot;%s\&quot;&quot;,</a>
<a name="ln3984">                                s_type.c_str());</a>
<a name="ln3985">                return slot;</a>
<a name="ln3986">            }</a>
<a name="ln3987">            if (mspec.abjuration_duration == 0)</a>
<a name="ln3988">            {</a>
<a name="ln3989">                error = &quot;marked summon with no duration&quot;;</a>
<a name="ln3990">                return slot;</a>
<a name="ln3991">            }</a>
<a name="ln3992">        }</a>
<a name="ln3993"> </a>
<a name="ln3994">        mspec.summon_type = summon_type;</a>
<a name="ln3995"> </a>
<a name="ln3996">        string non_actor_summoner = strip_tag_prefix(mon_str, &quot;nas:&quot;);</a>
<a name="ln3997">        if (!non_actor_summoner.empty())</a>
<a name="ln3998">        {</a>
<a name="ln3999">            non_actor_summoner = replace_all_of(non_actor_summoner, &quot;_&quot;, &quot; &quot;);</a>
<a name="ln4000">            mspec.non_actor_summoner = non_actor_summoner;</a>
<a name="ln4001">            if (mspec.abjuration_duration == 0)</a>
<a name="ln4002">            {</a>
<a name="ln4003">                error = &quot;marked summon with no duration&quot;;</a>
<a name="ln4004">                return slot;</a>
<a name="ln4005">            }</a>
<a name="ln4006">        }</a>
<a name="ln4007"> </a>
<a name="ln4008">        string colour = strip_tag_prefix(mon_str, &quot;col:&quot;);</a>
<a name="ln4009">        if (!colour.empty())</a>
<a name="ln4010">        {</a>
<a name="ln4011">            if (colour == &quot;any&quot;)</a>
<a name="ln4012">                mspec.colour = COLOUR_UNDEF;</a>
<a name="ln4013">            else</a>
<a name="ln4014">            {</a>
<a name="ln4015">                mspec.colour = str_to_colour(colour, COLOUR_UNDEF, false, true);</a>
<a name="ln4016">                if (mspec.colour == COLOUR_UNDEF)</a>
<a name="ln4017">                {</a>
<a name="ln4018">                    error = make_stringf(&quot;bad monster colour \&quot;%s\&quot; in \&quot;%s\&quot;&quot;,</a>
<a name="ln4019">                                         colour.c_str(), monspec.c_str());</a>
<a name="ln4020">                    return slot;</a>
<a name="ln4021">                }</a>
<a name="ln4022">            }</a>
<a name="ln4023">        }</a>
<a name="ln4024"> </a>
<a name="ln4025">        string mongod = strip_tag_prefix(mon_str, &quot;god:&quot;);</a>
<a name="ln4026">        if (!mongod.empty())</a>
<a name="ln4027">        {</a>
<a name="ln4028">            const string god_name(replace_all_of(mongod, &quot;_&quot;, &quot; &quot;));</a>
<a name="ln4029"> </a>
<a name="ln4030">            mspec.god = str_to_god(god_name);</a>
<a name="ln4031"> </a>
<a name="ln4032">            if (mspec.god == GOD_NO_GOD)</a>
<a name="ln4033">            {</a>
<a name="ln4034">                error = make_stringf(&quot;bad monster god: \&quot;%s\&quot;&quot;,</a>
<a name="ln4035">                                     god_name.c_str());</a>
<a name="ln4036">                return slot;</a>
<a name="ln4037">            }</a>
<a name="ln4038"> </a>
<a name="ln4039">            if (strip_tag(mon_str, &quot;god_gift&quot;))</a>
<a name="ln4040">                mspec.god_gift = true;</a>
<a name="ln4041">        }</a>
<a name="ln4042"> </a>
<a name="ln4043">        string tile = strip_tag_prefix(mon_str, &quot;tile:&quot;);</a>
<a name="ln4044">        if (!tile.empty())</a>
<a name="ln4045">        {</a>
<a name="ln4046">            tileidx_t index;</a>
<a name="ln4047">            if (!tile_player_index(tile.c_str(), &amp;index))</a>
<a name="ln4048">            {</a>
<a name="ln4049">                error = make_stringf(&quot;bad tile name: \&quot;%s\&quot;.&quot;, tile.c_str());</a>
<a name="ln4050">                return slot;</a>
<a name="ln4051">            }</a>
<a name="ln4052">            // Store name along with the tile.</a>
<a name="ln4053">            mspec.props[&quot;monster_tile_name&quot;].get_string() = tile;</a>
<a name="ln4054">            mspec.props[&quot;monster_tile&quot;] = short(index);</a>
<a name="ln4055">        }</a>
<a name="ln4056"> </a>
<a name="ln4057">        string dbname = strip_tag_prefix(mon_str, &quot;dbname:&quot;);</a>
<a name="ln4058">        if (!dbname.empty())</a>
<a name="ln4059">        {</a>
<a name="ln4060">            dbname = replace_all_of(dbname, &quot;_&quot;, &quot; &quot;);</a>
<a name="ln4061">            mspec.props[&quot;dbname&quot;].get_string() = dbname;</a>
<a name="ln4062">        }</a>
<a name="ln4063"> </a>
<a name="ln4064">        string name = strip_tag_prefix(mon_str, &quot;name:&quot;);</a>
<a name="ln4065">        if (!name.empty())</a>
<a name="ln4066">        {</a>
<a name="ln4067">            name = replace_all_of(name, &quot;_&quot;, &quot; &quot;);</a>
<a name="ln4068">            mspec.monname = name;</a>
<a name="ln4069"> </a>
<a name="ln4070">            if (strip_tag(mon_str, &quot;name_suffix&quot;)</a>
<a name="ln4071">                || strip_tag(mon_str, &quot;n_suf&quot;))</a>
<a name="ln4072">            {</a>
<a name="ln4073">                mspec.extra_monster_flags |= MF_NAME_SUFFIX;</a>
<a name="ln4074">            }</a>
<a name="ln4075">            else if (strip_tag(mon_str, &quot;name_adjective&quot;)</a>
<a name="ln4076">                     || strip_tag(mon_str, &quot;n_adj&quot;))</a>
<a name="ln4077">            {</a>
<a name="ln4078">                mspec.extra_monster_flags |= MF_NAME_ADJECTIVE;</a>
<a name="ln4079">            }</a>
<a name="ln4080">            else if (strip_tag(mon_str, &quot;name_replace&quot;)</a>
<a name="ln4081">                     || strip_tag(mon_str, &quot;n_rpl&quot;))</a>
<a name="ln4082">            {</a>
<a name="ln4083">                mspec.extra_monster_flags |= MF_NAME_REPLACE;</a>
<a name="ln4084">            }</a>
<a name="ln4085"> </a>
<a name="ln4086">            if (strip_tag(mon_str, &quot;name_definite&quot;)</a>
<a name="ln4087">                || strip_tag(mon_str, &quot;n_the&quot;))</a>
<a name="ln4088">            {</a>
<a name="ln4089">                mspec.extra_monster_flags |= MF_NAME_DEFINITE;</a>
<a name="ln4090">            }</a>
<a name="ln4091"> </a>
<a name="ln4092">            // Reasoning for setting more than one flag: suffixes and</a>
<a name="ln4093">            // adjectives need NAME_DESCRIPTOR to get proper grammar,</a>
<a name="ln4094">            // and definite names do nothing with the description unless</a>
<a name="ln4095">            // NAME_DESCRIPTOR is also set.</a>
<a name="ln4096">            const auto name_flags = mspec.extra_monster_flags &amp; MF_NAME_MASK;</a>
<a name="ln4097">            const bool need_name_desc =</a>
<a name="ln4098">                name_flags == MF_NAME_SUFFIX</a>
<a name="ln4099">                   || name_flags == MF_NAME_ADJECTIVE</a>
<a name="ln4100">                   || (mspec.extra_monster_flags &amp; MF_NAME_DEFINITE);</a>
<a name="ln4101"> </a>
<a name="ln4102">            if (strip_tag(mon_str, &quot;name_descriptor&quot;)</a>
<a name="ln4103">                || strip_tag(mon_str, &quot;n_des&quot;)</a>
<a name="ln4104">                || need_name_desc)</a>
<a name="ln4105">            {</a>
<a name="ln4106">                mspec.extra_monster_flags |= MF_NAME_DESCRIPTOR;</a>
<a name="ln4107">            }</a>
<a name="ln4108"> </a>
<a name="ln4109">            if (strip_tag(mon_str, &quot;name_species&quot;)</a>
<a name="ln4110">                || strip_tag(mon_str, &quot;n_spe&quot;))</a>
<a name="ln4111">            {</a>
<a name="ln4112">                mspec.extra_monster_flags |= MF_NAME_SPECIES;</a>
<a name="ln4113">            }</a>
<a name="ln4114"> </a>
<a name="ln4115">            if (strip_tag(mon_str, &quot;name_zombie&quot;)</a>
<a name="ln4116">                || strip_tag(mon_str, &quot;n_zom&quot;))</a>
<a name="ln4117">            {</a>
<a name="ln4118">                mspec.extra_monster_flags |= MF_NAME_ZOMBIE;</a>
<a name="ln4119">            }</a>
<a name="ln4120">            if (strip_tag(mon_str, &quot;name_nocorpse&quot;)</a>
<a name="ln4121">                || strip_tag(mon_str, &quot;n_noc&quot;))</a>
<a name="ln4122">            {</a>
<a name="ln4123">                mspec.extra_monster_flags |= MF_NAME_NOCORPSE;</a>
<a name="ln4124">            }</a>
<a name="ln4125">        }</a>
<a name="ln4126"> </a>
<a name="ln4127">        string ench_str;</a>
<a name="ln4128">        while (!(ench_str = strip_tag_prefix(mon_str, &quot;ench:&quot;)).empty())</a>
<a name="ln4129">        {</a>
<a name="ln4130">            mspec.ench.push_back(parse_ench(ench_str, false));</a>
<a name="ln4131">            if (!error.empty())</a>
<a name="ln4132">                return slot;</a>
<a name="ln4133">        }</a>
<a name="ln4134">        while (!(ench_str = strip_tag_prefix(mon_str, &quot;perm_ench:&quot;)).empty())</a>
<a name="ln4135">        {</a>
<a name="ln4136">            mspec.ench.push_back(parse_ench(ench_str, true));</a>
<a name="ln4137">            if (!error.empty())</a>
<a name="ln4138">                return slot;</a>
<a name="ln4139">        }</a>
<a name="ln4140"> </a>
<a name="ln4141">        trim_string(mon_str);</a>
<a name="ln4142"> </a>
<a name="ln4143">        if (mon_str == &quot;8&quot;)</a>
<a name="ln4144">            mspec.type = RANDOM_SUPER_OOD;</a>
<a name="ln4145">        else if (mon_str == &quot;9&quot;)</a>
<a name="ln4146">            mspec.type = RANDOM_MODERATE_OOD;</a>
<a name="ln4147">        else if (mspec.place.is_valid())</a>
<a name="ln4148">        {</a>
<a name="ln4149">            // For monster specs such as place:Orc:4 zombie, we may</a>
<a name="ln4150">            // have a monster modifier, in which case we set the</a>
<a name="ln4151">            // modifier in monbase.</a>
<a name="ln4152">            const mons_spec nspec = mons_by_name(&quot;orc &quot; + mon_str);</a>
<a name="ln4153">            if (nspec.type != MONS_PROGRAM_BUG)</a>
<a name="ln4154">            {</a>
<a name="ln4155">                // Is this a modified monster?</a>
<a name="ln4156">                if (nspec.monbase != MONS_PROGRAM_BUG</a>
<a name="ln4157">                    &amp;&amp; mons_class_is_zombified(static_cast&lt;monster_type&gt;(nspec.type)))</a>
<a name="ln4158">                {</a>
<a name="ln4159">                    mspec.monbase = static_cast&lt;monster_type&gt;(nspec.type);</a>
<a name="ln4160">                }</a>
<a name="ln4161">            }</a>
<a name="ln4162">        }</a>
<a name="ln4163">        else if (mon_str != &quot;0&quot;)</a>
<a name="ln4164">        {</a>
<a name="ln4165">            const mons_spec nspec = mons_by_name(mon_str);</a>
<a name="ln4166"> </a>
<a name="ln4167">            if (nspec.type == MONS_PROGRAM_BUG)</a>
<a name="ln4168">            {</a>
<a name="ln4169">                error = make_stringf(&quot;unknown monster: \&quot;%s\&quot;&quot;,</a>
<a name="ln4170">                                     mon_str.c_str());</a>
<a name="ln4171">                return slot;</a>
<a name="ln4172">            }</a>
<a name="ln4173"> </a>
<a name="ln4174">            if (mons_class_flag(nspec.type, M_CANT_SPAWN))</a>
<a name="ln4175">            {</a>
<a name="ln4176">                error = make_stringf(&quot;can't place dummy monster: \&quot;%s\&quot;&quot;,</a>
<a name="ln4177">                                     mon_str.c_str());</a>
<a name="ln4178">                return slot;</a>
<a name="ln4179">            }</a>
<a name="ln4180"> </a>
<a name="ln4181">            mspec.type    = nspec.type;</a>
<a name="ln4182">            mspec.monbase = nspec.monbase;</a>
<a name="ln4183">            if (nspec.colour &gt; COLOUR_UNDEF &amp;&amp; mspec.colour &lt;= COLOUR_UNDEF)</a>
<a name="ln4184">                mspec.colour = nspec.colour;</a>
<a name="ln4185">            if (nspec.hd != 0)</a>
<a name="ln4186">                mspec.hd = nspec.hd;</a>
<a name="ln4187">#define MAYBE_COPY(x) \</a>
<a name="ln4188">            if (nspec.props.exists((x))) \</a>
<a name="ln4189">            { \</a>
<a name="ln4190">                mspec.props[(x)] \</a>
<a name="ln4191">                    = nspec.props[(x)]; \</a>
<a name="ln4192">            }</a>
<a name="ln4193">            MAYBE_COPY(MUTANT_BEAST_FACETS);</a>
<a name="ln4194">            MAYBE_COPY(MGEN_BLOB_SIZE);</a>
<a name="ln4195">            MAYBE_COPY(MGEN_NUM_HEADS);</a>
<a name="ln4196">            MAYBE_COPY(MGEN_NO_AUTO_CRUMBLE);</a>
<a name="ln4197">#undef MAYBE_COPY</a>
<a name="ln4198">        }</a>
<a name="ln4199"> </a>
<a name="ln4200">        if (!mspec.items.empty())</a>
<a name="ln4201">        {</a>
<a name="ln4202">            monster_type type = (monster_type)mspec.type;</a>
<a name="ln4203">            if (type == RANDOM_DRACONIAN</a>
<a name="ln4204">                || type == RANDOM_BASE_DRACONIAN</a>
<a name="ln4205">                || type == RANDOM_NONBASE_DRACONIAN)</a>
<a name="ln4206">            {</a>
<a name="ln4207">                type = MONS_DRACONIAN;</a>
<a name="ln4208">            }</a>
<a name="ln4209"> </a>
<a name="ln4210">            if (type &gt;= NUM_MONSTERS)</a>
<a name="ln4211">            {</a>
<a name="ln4212">                error = &quot;Can't give spec items to a random monster.&quot;;</a>
<a name="ln4213">                return slot;</a>
<a name="ln4214">            }</a>
<a name="ln4215">            else if (mons_class_itemuse(type) &lt; MONUSE_STARTING_EQUIPMENT</a>
<a name="ln4216">                     &amp;&amp; (!mons_class_is_animated_weapon(type)</a>
<a name="ln4217">                         || mspec.items.size() &gt; 1)</a>
<a name="ln4218">                     &amp;&amp; (type != MONS_ZOMBIE &amp;&amp; type != MONS_SKELETON</a>
<a name="ln4219">                         || invalid_monster_type(mspec.monbase)</a>
<a name="ln4220">                         || mons_class_itemuse(mspec.monbase)</a>
<a name="ln4221">                            &lt; MONUSE_STARTING_EQUIPMENT))</a>
<a name="ln4222">            {</a>
<a name="ln4223">                error = make_stringf(&quot;Monster '%s' can't use items.&quot;,</a>
<a name="ln4224">                    mon_str.c_str());</a>
<a name="ln4225">            }</a>
<a name="ln4226">        }</a>
<a name="ln4227"> </a>
<a name="ln4228">        slot.mlist.push_back(mspec);</a>
<a name="ln4229">    }</a>
<a name="ln4230"> </a>
<a name="ln4231">    return slot;</a>
<a name="ln4232">}</a>
<a name="ln4233"> </a>
<a name="ln4234">string mons_list::add_mons(const string &amp;s, bool fix)</a>
<a name="ln4235">{</a>
<a name="ln4236">    error.clear();</a>
<a name="ln4237"> </a>
<a name="ln4238">    mons_spec_slot slotmons = parse_mons_spec(s);</a>
<a name="ln4239">    if (!error.empty())</a>
<a name="ln4240">        return error;</a>
<a name="ln4241"> </a>
<a name="ln4242">    if (fix)</a>
<a name="ln4243">    {</a>
<a name="ln4244">        slotmons.fix_slot = true;</a>
<a name="ln4245">        pick_monster(slotmons);</a>
<a name="ln4246">    }</a>
<a name="ln4247"> </a>
<a name="ln4248">    mons.push_back(slotmons);</a>
<a name="ln4249"> </a>
<a name="ln4250">    return error;</a>
<a name="ln4251">}</a>
<a name="ln4252"> </a>
<a name="ln4253">string mons_list::set_mons(int index, const string &amp;s)</a>
<a name="ln4254">{</a>
<a name="ln4255">    error.clear();</a>
<a name="ln4256"> </a>
<a name="ln4257">    if (index &lt; 0)</a>
<a name="ln4258">        return error = make_stringf(&quot;Index out of range: %d&quot;, index);</a>
<a name="ln4259"> </a>
<a name="ln4260">    mons_spec_slot slotmons = parse_mons_spec(s);</a>
<a name="ln4261">    if (!error.empty())</a>
<a name="ln4262">        return error;</a>
<a name="ln4263"> </a>
<a name="ln4264">    if (index &gt;= (int) mons.size())</a>
<a name="ln4265">    {</a>
<a name="ln4266">        mons.reserve(index + 1);</a>
<a name="ln4267">        mons.resize(index + 1, mons_spec_slot());</a>
<a name="ln4268">    }</a>
<a name="ln4269">    mons[index] = slotmons;</a>
<a name="ln4270">    return error;</a>
<a name="ln4271">}</a>
<a name="ln4272"> </a>
<a name="ln4273">static monster_type _fixup_mon_type(monster_type orig)</a>
<a name="ln4274">{</a>
<a name="ln4275">    if (mons_class_flag(orig, M_CANT_SPAWN))</a>
<a name="ln4276">        return MONS_PROGRAM_BUG;</a>
<a name="ln4277"> </a>
<a name="ln4278">    if (orig &lt; 0)</a>
<a name="ln4279">        orig = MONS_PROGRAM_BUG;</a>
<a name="ln4280"> </a>
<a name="ln4281">    monster_type dummy_mons = MONS_PROGRAM_BUG;</a>
<a name="ln4282">    coord_def dummy_pos;</a>
<a name="ln4283">    level_id place = level_id::current();</a>
<a name="ln4284">    return resolve_monster_type(orig, dummy_mons, PROX_ANYWHERE, &amp;dummy_pos, 0,</a>
<a name="ln4285">                                &amp;place);</a>
<a name="ln4286">}</a>
<a name="ln4287"> </a>
<a name="ln4288">void mons_list::get_zombie_type(string s, mons_spec &amp;spec) const</a>
<a name="ln4289">{</a>
<a name="ln4290">    static const char *zombie_types[] =</a>
<a name="ln4291">    {</a>
<a name="ln4292">        &quot; zombie&quot;, &quot; skeleton&quot;, &quot; simulacrum&quot;, &quot; spectre&quot;, nullptr</a>
<a name="ln4293">    };</a>
<a name="ln4294"> </a>
<a name="ln4295">    // This order must match zombie_types, indexed from one.</a>
<a name="ln4296">    static const monster_type zombie_montypes[] =</a>
<a name="ln4297">    {</a>
<a name="ln4298">        MONS_PROGRAM_BUG, MONS_ZOMBIE, MONS_SKELETON, MONS_SIMULACRUM,</a>
<a name="ln4299">        MONS_SPECTRAL_THING,</a>
<a name="ln4300">    };</a>
<a name="ln4301"> </a>
<a name="ln4302">    int mod = ends_with(s, zombie_types);</a>
<a name="ln4303">    if (!mod)</a>
<a name="ln4304">    {</a>
<a name="ln4305">        if (starts_with(s, &quot;spectral &quot;))</a>
<a name="ln4306">        {</a>
<a name="ln4307">            mod = ends_with(&quot; spectre&quot;, zombie_types);</a>
<a name="ln4308">            s = s.substr(9); // strlen(&quot;spectral &quot;)</a>
<a name="ln4309">        }</a>
<a name="ln4310">        else</a>
<a name="ln4311">        {</a>
<a name="ln4312">            spec.type = MONS_PROGRAM_BUG;</a>
<a name="ln4313">            return;</a>
<a name="ln4314">        }</a>
<a name="ln4315">    }</a>
<a name="ln4316">    else</a>
<a name="ln4317">        s = s.substr(0, s.length() - strlen(zombie_types[mod - 1]));</a>
<a name="ln4318"> </a>
<a name="ln4319">    trim_string(s);</a>
<a name="ln4320"> </a>
<a name="ln4321">    mons_spec base_monster = mons_by_name(s);</a>
<a name="ln4322">    base_monster.type = _fixup_mon_type(base_monster.type);</a>
<a name="ln4323">    if (base_monster.type == MONS_PROGRAM_BUG)</a>
<a name="ln4324">    {</a>
<a name="ln4325">        spec.type = MONS_PROGRAM_BUG;</a>
<a name="ln4326">        return;</a>
<a name="ln4327">    }</a>
<a name="ln4328"> </a>
<a name="ln4329">    spec.monbase = static_cast&lt;monster_type&gt;(base_monster.type);</a>
<a name="ln4330">    if (base_monster.props.exists(MGEN_NUM_HEADS))</a>
<a name="ln4331">        spec.props[MGEN_NUM_HEADS] = base_monster.props[MGEN_NUM_HEADS];</a>
<a name="ln4332"> </a>
<a name="ln4333">    const int zombie_size = mons_zombie_size(spec.monbase);</a>
<a name="ln4334">    if (!zombie_size)</a>
<a name="ln4335">    {</a>
<a name="ln4336">        spec.type = MONS_PROGRAM_BUG;</a>
<a name="ln4337">        return;</a>
<a name="ln4338">    }</a>
<a name="ln4339">    if (mod == 1 &amp;&amp; mons_class_flag(spec.monbase, M_NO_ZOMBIE))</a>
<a name="ln4340">    {</a>
<a name="ln4341">        spec.type = MONS_PROGRAM_BUG;</a>
<a name="ln4342">        return;</a>
<a name="ln4343">    }</a>
<a name="ln4344">    if (mod == 2 &amp;&amp; mons_class_flag(spec.monbase, M_NO_SKELETON))</a>
<a name="ln4345">    {</a>
<a name="ln4346">        spec.type = MONS_PROGRAM_BUG;</a>
<a name="ln4347">        return;</a>
<a name="ln4348">    }</a>
<a name="ln4349"> </a>
<a name="ln4350">    spec.type = zombie_montypes[mod];</a>
<a name="ln4351">}</a>
<a name="ln4352"> </a>
<a name="ln4353">mons_spec mons_list::get_hydra_spec(const string &amp;name) const</a>
<a name="ln4354">{</a>
<a name="ln4355">    string prefix = name.substr(0, name.find(&quot;-&quot;));</a>
<a name="ln4356"> </a>
<a name="ln4357">    int nheads = atoi(prefix.c_str());</a>
<a name="ln4358">    if (nheads != 0)</a>
<a name="ln4359">        ;</a>
<a name="ln4360">    else if (prefix == &quot;0&quot;)</a>
<a name="ln4361">        nheads = 0;</a>
<a name="ln4362">    else</a>
<a name="ln4363">    {</a>
<a name="ln4364">        // Might be &quot;two-headed hydra&quot; type string.</a>
<a name="ln4365">        for (int i = 0; i &lt;= 20; ++i)</a>
<a name="ln4366">            if (number_in_words(i) == prefix)</a>
<a name="ln4367">            {</a>
<a name="ln4368">                nheads = i;</a>
<a name="ln4369">                break;</a>
<a name="ln4370">            }</a>
<a name="ln4371">    }</a>
<a name="ln4372"> </a>
<a name="ln4373">    if (nheads &lt; 1)</a>
<a name="ln4374">        nheads = 27;  // What can I say? :P</a>
<a name="ln4375">    else if (nheads &gt; 20)</a>
<a name="ln4376">    {</a>
<a name="ln4377">#if defined(DEBUG) || defined(DEBUG_DIAGNOSTICS)</a>
<a name="ln4378">        mprf(MSGCH_DIAGNOSTICS, &quot;Hydra spec wants %d heads, clamping to 20.&quot;,</a>
<a name="ln4379">             nheads);</a>
<a name="ln4380">#endif</a>
<a name="ln4381">        nheads = 20;</a>
<a name="ln4382">    }</a>
<a name="ln4383"> </a>
<a name="ln4384">    mons_spec spec(MONS_HYDRA);</a>
<a name="ln4385">    spec.props[MGEN_NUM_HEADS] = nheads;</a>
<a name="ln4386">    return spec;</a>
<a name="ln4387">}</a>
<a name="ln4388"> </a>
<a name="ln4389">mons_spec mons_list::get_slime_spec(const string &amp;name) const</a>
<a name="ln4390">{</a>
<a name="ln4391">    string prefix = name.substr(0, name.find(&quot; slime creature&quot;));</a>
<a name="ln4392"> </a>
<a name="ln4393">    int slime_size = 1;</a>
<a name="ln4394"> </a>
<a name="ln4395">    if (prefix == &quot;large&quot;)</a>
<a name="ln4396">        slime_size = 2;</a>
<a name="ln4397">    else if (prefix == &quot;very large&quot;)</a>
<a name="ln4398">        slime_size = 3;</a>
<a name="ln4399">    else if (prefix == &quot;enormous&quot;)</a>
<a name="ln4400">        slime_size = 4;</a>
<a name="ln4401">    else if (prefix == &quot;titanic&quot;)</a>
<a name="ln4402">        slime_size = 5;</a>
<a name="ln4403">    else</a>
<a name="ln4404">    {</a>
<a name="ln4405">#if defined(DEBUG) || defined(DEBUG_DIAGNOSTICS)</a>
<a name="ln4406">        mprf(MSGCH_DIAGNOSTICS, &quot;Slime spec wants invalid size '%s'&quot;,</a>
<a name="ln4407">             prefix.c_str());</a>
<a name="ln4408">#endif</a>
<a name="ln4409">    }</a>
<a name="ln4410"> </a>
<a name="ln4411">    mons_spec spec(MONS_SLIME_CREATURE);</a>
<a name="ln4412">    spec.props[MGEN_BLOB_SIZE] = slime_size;</a>
<a name="ln4413">    return spec;</a>
<a name="ln4414">}</a>
<a name="ln4415"> </a>
<a name="ln4416">/**</a>
<a name="ln4417"> * Build a monster specification for a specified pillar of salt. The pillar of</a>
<a name="ln4418"> * salt won't crumble over time, since that seems unuseful for any version of</a>
<a name="ln4419"> * this function.</a>
<a name="ln4420"> *</a>
<a name="ln4421"> * @param name      The description of the pillar of salt; e.g.</a>
<a name="ln4422"> *                  &quot;human-shaped pillar of salt&quot;,</a>
<a name="ln4423"> *                  &quot;titanic slime creature-shaped pillar of salt.&quot;</a>
<a name="ln4424"> *                  XXX: doesn't currently work with zombie specifiers</a>
<a name="ln4425"> *                  e.g. &quot;zombie-shaped...&quot; (does this matter?)</a>
<a name="ln4426"> * @return          A specifier for a pillar of salt.</a>
<a name="ln4427"> */</a>
<a name="ln4428">mons_spec mons_list::get_salt_spec(const string &amp;name) const</a>
<a name="ln4429">{</a>
<a name="ln4430">    const string prefix = name.substr(0, name.find(&quot;-shaped pillar of salt&quot;));</a>
<a name="ln4431">    mons_spec base_mon = mons_by_name(prefix);</a>
<a name="ln4432">    if (base_mon.type == MONS_PROGRAM_BUG)</a>
<a name="ln4433">        return base_mon; // invalid specifier</a>
<a name="ln4434"> </a>
<a name="ln4435">    mons_spec spec(MONS_PILLAR_OF_SALT);</a>
<a name="ln4436">    spec.monbase = _fixup_mon_type(base_mon.type);</a>
<a name="ln4437">    spec.props[MGEN_NO_AUTO_CRUMBLE] = true;</a>
<a name="ln4438">    return spec;</a>
<a name="ln4439">}</a>
<a name="ln4440"> </a>
<a name="ln4441">// Handle draconians specified as:</a>
<a name="ln4442">// Exactly as in mon-data.h:</a>
<a name="ln4443">//    yellow draconian or draconian knight - the monster specified.</a>
<a name="ln4444">//</a>
<a name="ln4445">// Others:</a>
<a name="ln4446">//    any draconian =&gt; any random draconain</a>
<a name="ln4447">//    any base draconian =&gt; any unspecialised coloured draconian.</a>
<a name="ln4448">//    any nonbase draconian =&gt; any specialised coloured draconian.</a>
<a name="ln4449">//    any &lt;colour&gt; draconian =&gt; any draconian of the colour.</a>
<a name="ln4450">//    any nonbase &lt;colour&gt; draconian =&gt; any specialised drac of the colour.</a>
<a name="ln4451">//</a>
<a name="ln4452">mons_spec mons_list::drac_monspec(string name) const</a>
<a name="ln4453">{</a>
<a name="ln4454">    mons_spec spec;</a>
<a name="ln4455"> </a>
<a name="ln4456">    spec.type = get_monster_by_name(name);</a>
<a name="ln4457"> </a>
<a name="ln4458">    // Check if it's a simple drac name, we're done.</a>
<a name="ln4459">    if (spec.type != MONS_PROGRAM_BUG)</a>
<a name="ln4460">        return spec;</a>
<a name="ln4461"> </a>
<a name="ln4462">    spec.type = RANDOM_DRACONIAN;</a>
<a name="ln4463"> </a>
<a name="ln4464">    // Request for any draconian?</a>
<a name="ln4465">    if (starts_with(name, &quot;any &quot;))</a>
<a name="ln4466">        name = name.substr(4); // Strip &quot;any &quot;</a>
<a name="ln4467"> </a>
<a name="ln4468">    if (starts_with(name, &quot;base &quot;))</a>
<a name="ln4469">    {</a>
<a name="ln4470">        // Base dracs need no further work.</a>
<a name="ln4471">        return RANDOM_BASE_DRACONIAN;</a>
<a name="ln4472">    }</a>
<a name="ln4473">    else if (starts_with(name, &quot;nonbase &quot;))</a>
<a name="ln4474">    {</a>
<a name="ln4475">        spec.type = RANDOM_NONBASE_DRACONIAN;</a>
<a name="ln4476">        name = name.substr(8);</a>
<a name="ln4477">    }</a>
<a name="ln4478"> </a>
<a name="ln4479">    trim_string(name);</a>
<a name="ln4480"> </a>
<a name="ln4481">    // Match &quot;any draconian&quot;</a>
<a name="ln4482">    if (name == &quot;draconian&quot;)</a>
<a name="ln4483">        return spec;</a>
<a name="ln4484"> </a>
<a name="ln4485">    // Check for recognition again to match any (nonbase) &lt;colour&gt; draconian.</a>
<a name="ln4486">    const monster_type colour = get_monster_by_name(name);</a>
<a name="ln4487">    if (colour != MONS_PROGRAM_BUG)</a>
<a name="ln4488">    {</a>
<a name="ln4489">        spec.monbase = colour;</a>
<a name="ln4490">        return spec;</a>
<a name="ln4491">    }</a>
<a name="ln4492"> </a>
<a name="ln4493">    // Only legal possibility left is &lt;colour&gt; boss drac.</a>
<a name="ln4494">    string::size_type wordend = name.find(' ');</a>
<a name="ln4495">    if (wordend == string::npos)</a>
<a name="ln4496">        return MONS_PROGRAM_BUG;</a>
<a name="ln4497"> </a>
<a name="ln4498">    string scolour = name.substr(0, wordend);</a>
<a name="ln4499">    if ((spec.monbase = draconian_colour_by_name(scolour)) == MONS_PROGRAM_BUG)</a>
<a name="ln4500">        return MONS_PROGRAM_BUG;</a>
<a name="ln4501"> </a>
<a name="ln4502">    name = trimmed_string(name.substr(wordend + 1));</a>
<a name="ln4503">    spec.type = get_monster_by_name(name);</a>
<a name="ln4504"> </a>
<a name="ln4505">    // We should have a non-base draconian here.</a>
<a name="ln4506">    if (spec.type == MONS_PROGRAM_BUG</a>
<a name="ln4507">        || mons_genus(static_cast&lt;monster_type&gt;(spec.type)) != MONS_DRACONIAN</a>
<a name="ln4508">        || mons_is_base_draconian(spec.type))</a>
<a name="ln4509">    {</a>
<a name="ln4510">        return MONS_PROGRAM_BUG;</a>
<a name="ln4511">    }</a>
<a name="ln4512"> </a>
<a name="ln4513">    return spec;</a>
<a name="ln4514">}</a>
<a name="ln4515"> </a>
<a name="ln4516">// As with draconians, so with demonspawn.</a>
<a name="ln4517">mons_spec mons_list::demonspawn_monspec(string name) const</a>
<a name="ln4518">{</a>
<a name="ln4519">    mons_spec spec;</a>
<a name="ln4520"> </a>
<a name="ln4521">    spec.type = get_monster_by_name(name);</a>
<a name="ln4522"> </a>
<a name="ln4523">    // Check if it's a simple demonspawn name, we're done.</a>
<a name="ln4524">    if (spec.type != MONS_PROGRAM_BUG)</a>
<a name="ln4525">        return spec;</a>
<a name="ln4526"> </a>
<a name="ln4527">    spec.type = RANDOM_DEMONSPAWN;</a>
<a name="ln4528"> </a>
<a name="ln4529">    // Request for any demonspawn?</a>
<a name="ln4530">    if (starts_with(name, &quot;any &quot;))</a>
<a name="ln4531">        name = name.substr(4); // Strip &quot;any &quot;</a>
<a name="ln4532"> </a>
<a name="ln4533">    if (starts_with(name, &quot;base &quot;))</a>
<a name="ln4534">    {</a>
<a name="ln4535">        // Base demonspawn need no further work.</a>
<a name="ln4536">        return RANDOM_BASE_DEMONSPAWN;</a>
<a name="ln4537">    }</a>
<a name="ln4538">    else if (starts_with(name, &quot;nonbase &quot;))</a>
<a name="ln4539">    {</a>
<a name="ln4540">        spec.type = RANDOM_NONBASE_DEMONSPAWN;</a>
<a name="ln4541">        name = name.substr(8);</a>
<a name="ln4542">    }</a>
<a name="ln4543"> </a>
<a name="ln4544">    trim_string(name);</a>
<a name="ln4545"> </a>
<a name="ln4546">    // Match &quot;any demonspawn&quot;</a>
<a name="ln4547">    if (name == &quot;demonspawn&quot;)</a>
<a name="ln4548">        return spec;</a>
<a name="ln4549"> </a>
<a name="ln4550">    // Check for recognition again to match any (nonbase) &lt;base&gt; demonspawn.</a>
<a name="ln4551">    const monster_type base = get_monster_by_name(name);</a>
<a name="ln4552">    if (base != MONS_PROGRAM_BUG)</a>
<a name="ln4553">    {</a>
<a name="ln4554">        spec.monbase = base;</a>
<a name="ln4555">        return spec;</a>
<a name="ln4556">    }</a>
<a name="ln4557"> </a>
<a name="ln4558">    // Only legal possibility left is &lt;base&gt; boss demonspawn.</a>
<a name="ln4559">    string::size_type wordend = name.find(' ');</a>
<a name="ln4560">    if (wordend == string::npos)</a>
<a name="ln4561">        return MONS_PROGRAM_BUG;</a>
<a name="ln4562"> </a>
<a name="ln4563">    string sbase = name.substr(0, wordend);</a>
<a name="ln4564">    if ((spec.monbase = demonspawn_base_by_name(sbase)) == MONS_PROGRAM_BUG)</a>
<a name="ln4565">        return MONS_PROGRAM_BUG;</a>
<a name="ln4566"> </a>
<a name="ln4567">    name = trimmed_string(name.substr(wordend + 1));</a>
<a name="ln4568">    spec.type = get_monster_by_name(name);</a>
<a name="ln4569"> </a>
<a name="ln4570">    // We should have a non-base demonspawn here.</a>
<a name="ln4571">    if (spec.type == MONS_PROGRAM_BUG</a>
<a name="ln4572">        || mons_genus(static_cast&lt;monster_type&gt;(spec.type)) != MONS_DEMONSPAWN</a>
<a name="ln4573">        || spec.type == MONS_DEMONSPAWN</a>
<a name="ln4574">        || (spec.type &gt;= MONS_FIRST_BASE_DEMONSPAWN</a>
<a name="ln4575">            &amp;&amp; spec.type &lt;= MONS_LAST_BASE_DEMONSPAWN))</a>
<a name="ln4576">    {</a>
<a name="ln4577">        return MONS_PROGRAM_BUG;</a>
<a name="ln4578">    }</a>
<a name="ln4579"> </a>
<a name="ln4580">    return spec;</a>
<a name="ln4581">}</a>
<a name="ln4582"> </a>
<a name="ln4583">mons_spec mons_list::soh_monspec(string name) const</a>
<a name="ln4584">{</a>
<a name="ln4585">    // &quot;serpent of hell &quot; is 16 characters</a>
<a name="ln4586">    name = name.substr(16);</a>
<a name="ln4587">    string abbrev =</a>
<a name="ln4588">        uppercase_first(lowercase(name)).substr(0, 3);</a>
<a name="ln4589">    switch (branch_by_abbrevname(abbrev))</a>
<a name="ln4590">    {</a>
<a name="ln4591">        case BRANCH_GEHENNA:</a>
<a name="ln4592">            return MONS_SERPENT_OF_HELL;</a>
<a name="ln4593">        case BRANCH_COCYTUS:</a>
<a name="ln4594">            return MONS_SERPENT_OF_HELL_COCYTUS;</a>
<a name="ln4595">        case BRANCH_DIS:</a>
<a name="ln4596">            return MONS_SERPENT_OF_HELL_DIS;</a>
<a name="ln4597">        case BRANCH_TARTARUS:</a>
<a name="ln4598">            return MONS_SERPENT_OF_HELL_TARTARUS;</a>
<a name="ln4599">        default:</a>
<a name="ln4600">            return MONS_PROGRAM_BUG;</a>
<a name="ln4601">    }</a>
<a name="ln4602">}</a>
<a name="ln4603"> </a>
<a name="ln4604">/**</a>
<a name="ln4605"> * What mutant beast facet corresponds to the given name?</a>
<a name="ln4606"> *</a>
<a name="ln4607"> * @param name      The name in question (e.g. 'bat')</a>
<a name="ln4608"> * @return          The corresponding facet (e.g. BF_BAT), or BF_NONE.</a>
<a name="ln4609"> */</a>
<a name="ln4610">static int _beast_facet_by_name(const string &amp;name)</a>
<a name="ln4611">{</a>
<a name="ln4612">    for (int bf = BF_FIRST; bf &lt; NUM_BEAST_FACETS; ++bf)</a>
<a name="ln4613">        if (mutant_beast_facet_names[bf] == lowercase_string(name))</a>
<a name="ln4614">            return bf;</a>
<a name="ln4615">    return BF_NONE;</a>
<a name="ln4616">}</a>
<a name="ln4617"> </a>
<a name="ln4618">/**</a>
<a name="ln4619"> * What HD corresponds to the given mutant beast tier name?</a>
<a name="ln4620"> *</a>
<a name="ln4621"> * XXX: refactor this together with _beast_facet_by_name()?</a>
<a name="ln4622"> *</a>
<a name="ln4623"> * @param tier      The name in question (e.g. 'juvenile')</a>
<a name="ln4624"> * @return          The corresponding tier XL (e.g. 9), or 0 if none is valid.</a>
<a name="ln4625"> */</a>
<a name="ln4626">static int _mutant_beast_xl(const string &amp;tier)</a>
<a name="ln4627">{</a>
<a name="ln4628">    for (int bt = BT_FIRST; bt &lt; NUM_BEAST_TIERS; ++bt)</a>
<a name="ln4629">        if (mutant_beast_tier_names[bt] == lowercase_string(tier))</a>
<a name="ln4630">            return beast_tiers[bt];</a>
<a name="ln4631">    return 0;</a>
<a name="ln4632">}</a>
<a name="ln4633"> </a>
<a name="ln4634">mons_spec mons_list::mons_by_name(string name) const</a>
<a name="ln4635">{</a>
<a name="ln4636">    name = replace_all_of(name, &quot;_&quot;, &quot; &quot;);</a>
<a name="ln4637">    name = replace_all(name, &quot;random&quot;, &quot;any&quot;);</a>
<a name="ln4638"> </a>
<a name="ln4639">    if (name == &quot;nothing&quot;)</a>
<a name="ln4640">        return MONS_NO_MONSTER;</a>
<a name="ln4641"> </a>
<a name="ln4642">    // Special casery:</a>
<a name="ln4643">    if (name == &quot;pandemonium lord&quot;)</a>
<a name="ln4644">        return MONS_PANDEMONIUM_LORD;</a>
<a name="ln4645"> </a>
<a name="ln4646">    if (name == &quot;any&quot; || name == &quot;any monster&quot;)</a>
<a name="ln4647">        return RANDOM_MONSTER;</a>
<a name="ln4648"> </a>
<a name="ln4649">    if (name == &quot;any demon&quot;)</a>
<a name="ln4650">        return RANDOM_DEMON;</a>
<a name="ln4651"> </a>
<a name="ln4652">    if (name == &quot;any lesser demon&quot; || name == &quot;lesser demon&quot;)</a>
<a name="ln4653">        return RANDOM_DEMON_LESSER;</a>
<a name="ln4654"> </a>
<a name="ln4655">    if (name == &quot;any common demon&quot; || name == &quot;common demon&quot;)</a>
<a name="ln4656">        return RANDOM_DEMON_COMMON;</a>
<a name="ln4657"> </a>
<a name="ln4658">    if (name == &quot;any greater demon&quot; || name == &quot;greater demon&quot;)</a>
<a name="ln4659">        return RANDOM_DEMON_GREATER;</a>
<a name="ln4660"> </a>
<a name="ln4661">    if (name == &quot;small zombie&quot; || name == &quot;large zombie&quot;</a>
<a name="ln4662">        || name == &quot;small skeleton&quot; || name == &quot;large skeleton&quot;</a>
<a name="ln4663">        || name == &quot;small simulacrum&quot; || name == &quot;large simulacrum&quot;)</a>
<a name="ln4664">    {</a>
<a name="ln4665">        return MONS_PROGRAM_BUG;</a>
<a name="ln4666">    }</a>
<a name="ln4667"> </a>
<a name="ln4668">    if (name == &quot;small abomination&quot;)</a>
<a name="ln4669">        return MONS_ABOMINATION_SMALL;</a>
<a name="ln4670">    if (name == &quot;large abomination&quot;)</a>
<a name="ln4671">        return MONS_ABOMINATION_LARGE;</a>
<a name="ln4672"> </a>
<a name="ln4673">    if (ends_with(name, &quot;-headed hydra&quot;) &amp;&amp; !starts_with(name, &quot;spectral &quot;))</a>
<a name="ln4674">        return get_hydra_spec(name);</a>
<a name="ln4675"> </a>
<a name="ln4676">    if (ends_with(name, &quot; slime creature&quot;))</a>
<a name="ln4677">        return get_slime_spec(name);</a>
<a name="ln4678"> </a>
<a name="ln4679">    if (ends_with(name, &quot;-shaped pillar of salt&quot;))</a>
<a name="ln4680">        return get_salt_spec(name);</a>
<a name="ln4681"> </a>
<a name="ln4682">    const auto m_index = name.find(&quot; mutant beast&quot;);</a>
<a name="ln4683">    if (m_index != string::npos)</a>
<a name="ln4684">    {</a>
<a name="ln4685">        mons_spec spec = MONS_MUTANT_BEAST;</a>
<a name="ln4686"> </a>
<a name="ln4687">        const string trimmed = name.substr(0, m_index);</a>
<a name="ln4688">        const vector&lt;string&gt; segments = split_string(&quot; &quot;, trimmed);</a>
<a name="ln4689">        if (segments.size() &gt; 2)</a>
<a name="ln4690">            return MONS_PROGRAM_BUG; // too many words</a>
<a name="ln4691"> </a>
<a name="ln4692">        const bool fully_specified = segments.size() == 2;</a>
<a name="ln4693">        spec.hd = _mutant_beast_xl(segments[0]);</a>
<a name="ln4694">        if (spec.hd == 0 &amp;&amp; fully_specified)</a>
<a name="ln4695">            return MONS_PROGRAM_BUG; // gave invalid tier spec</a>
<a name="ln4696"> </a>
<a name="ln4697">        if (spec.hd == 0 || fully_specified)</a>
<a name="ln4698">        {</a>
<a name="ln4699">            const int seg = segments.size() - 1;</a>
<a name="ln4700">            const vector&lt;string&gt; facet_names</a>
<a name="ln4701">                = split_string(&quot;-&quot;, segments[seg]);</a>
<a name="ln4702">            for (const string &amp;facet_name : facet_names)</a>
<a name="ln4703">            {</a>
<a name="ln4704">                const int facet = _beast_facet_by_name(facet_name);</a>
<a name="ln4705">                if (facet == BF_NONE)</a>
<a name="ln4706">                    return MONS_PROGRAM_BUG; // invalid facet</a>
<a name="ln4707">                spec.props[MUTANT_BEAST_FACETS].get_vector().push_back(facet);</a>
<a name="ln4708">            }</a>
<a name="ln4709">        }</a>
<a name="ln4710"> </a>
<a name="ln4711">        return spec;</a>
<a name="ln4712">    }</a>
<a name="ln4713"> </a>
<a name="ln4714">    mons_spec spec;</a>
<a name="ln4715">    if (name.find(&quot; ugly thing&quot;) != string::npos)</a>
<a name="ln4716">    {</a>
<a name="ln4717">        const string::size_type wordend = name.find(' ');</a>
<a name="ln4718">        const string first_word = name.substr(0, wordend);</a>
<a name="ln4719"> </a>
<a name="ln4720">        const int colour = str_to_ugly_thing_colour(first_word);</a>
<a name="ln4721">        if (colour)</a>
<a name="ln4722">        {</a>
<a name="ln4723">            spec = mons_by_name(name.substr(wordend + 1));</a>
<a name="ln4724">            spec.colour = colour;</a>
<a name="ln4725">            return spec;</a>
<a name="ln4726">        }</a>
<a name="ln4727">    }</a>
<a name="ln4728"> </a>
<a name="ln4729">    get_zombie_type(name, spec);</a>
<a name="ln4730">    if (spec.type != MONS_PROGRAM_BUG)</a>
<a name="ln4731">        return spec;</a>
<a name="ln4732"> </a>
<a name="ln4733">    if (name.find(&quot;draconian&quot;) != string::npos)</a>
<a name="ln4734">        return drac_monspec(name);</a>
<a name="ln4735"> </a>
<a name="ln4736">    // FIXME: cleaner way to do this?</a>
<a name="ln4737">    if (name.find(&quot;demonspawn&quot;) != string::npos</a>
<a name="ln4738">        || name.find(&quot;black sun&quot;) != string::npos</a>
<a name="ln4739">        || name.find(&quot;blood saint&quot;) != string::npos</a>
<a name="ln4740">        || name.find(&quot;corrupter&quot;) != string::npos</a>
<a name="ln4741">        || name.find(&quot;warmonger&quot;) != string::npos)</a>
<a name="ln4742">    {</a>
<a name="ln4743">        return demonspawn_monspec(name);</a>
<a name="ln4744">    }</a>
<a name="ln4745"> </a>
<a name="ln4746">    // The space is important - it indicates a flavour is being specified.</a>
<a name="ln4747">    if (name.find(&quot;serpent of hell &quot;) != string::npos)</a>
<a name="ln4748">        return soh_monspec(name);</a>
<a name="ln4749"> </a>
<a name="ln4750">    // Allow access to her second form, which shares display names.</a>
<a name="ln4751">    if (name == &quot;bai suzhen dragon&quot;)</a>
<a name="ln4752">        return MONS_BAI_SUZHEN_DRAGON;</a>
<a name="ln4753"> </a>
<a name="ln4754">    return get_monster_by_name(name);</a>
<a name="ln4755">}</a>
<a name="ln4756"> </a>
<a name="ln4757">//////////////////////////////////////////////////////////////////////</a>
<a name="ln4758">// item_list</a>
<a name="ln4759"> </a>
<a name="ln4760">item_spec::item_spec(const item_spec &amp;other)</a>
<a name="ln4761">    : _corpse_monster_spec(nullptr)</a>
<a name="ln4762">{</a>
<a name="ln4763">    *this = other;</a>
<a name="ln4764">}</a>
<a name="ln4765"> </a>
<a name="ln4766">item_spec &amp;item_spec::operator = (const item_spec &amp;other)</a>
<a name="ln4767">{</a>
<a name="ln4768">    if (this != &amp;other)</a>
<a name="ln4769">    {</a>
<a name="ln4770">        genweight = other.genweight;</a>
<a name="ln4771">        base_type = other.base_type;</a>
<a name="ln4772">        sub_type  = other.sub_type;</a>
<a name="ln4773">        plus = other.plus;</a>
<a name="ln4774">        plus2 = other.plus2;</a>
<a name="ln4775">        ego = other.ego;</a>
<a name="ln4776">        allow_uniques = other.allow_uniques;</a>
<a name="ln4777">        level = other.level;</a>
<a name="ln4778">        item_special = other.item_special;</a>
<a name="ln4779">        qty = other.qty;</a>
<a name="ln4780">        acquirement_source = other.acquirement_source;</a>
<a name="ln4781">        place = other.place;</a>
<a name="ln4782">        props = other.props;</a>
<a name="ln4783"> </a>
<a name="ln4784">        release_corpse_monster_spec();</a>
<a name="ln4785">        if (other._corpse_monster_spec)</a>
<a name="ln4786">            set_corpse_monster_spec(other.corpse_monster_spec());</a>
<a name="ln4787">    }</a>
<a name="ln4788">    return *this;</a>
<a name="ln4789">}</a>
<a name="ln4790"> </a>
<a name="ln4791">item_spec::~item_spec()</a>
<a name="ln4792">{</a>
<a name="ln4793">    release_corpse_monster_spec();</a>
<a name="ln4794">}</a>
<a name="ln4795"> </a>
<a name="ln4796">void item_spec::release_corpse_monster_spec()</a>
<a name="ln4797">{</a>
<a name="ln4798">    delete _corpse_monster_spec;</a>
<a name="ln4799">    _corpse_monster_spec = nullptr;</a>
<a name="ln4800">}</a>
<a name="ln4801"> </a>
<a name="ln4802">bool item_spec::corpselike() const</a>
<a name="ln4803">{</a>
<a name="ln4804">    return base_type == OBJ_CORPSES &amp;&amp; (sub_type == CORPSE_BODY</a>
<a name="ln4805">                                        || sub_type == CORPSE_SKELETON)</a>
<a name="ln4806">           || base_type == OBJ_FOOD &amp;&amp; sub_type == FOOD_CHUNK;</a>
<a name="ln4807">}</a>
<a name="ln4808"> </a>
<a name="ln4809">const mons_spec &amp;item_spec::corpse_monster_spec() const</a>
<a name="ln4810">{</a>
<a name="ln4811">    ASSERT(_corpse_monster_spec);</a>
<a name="ln4812">    return *_corpse_monster_spec;</a>
<a name="ln4813">}</a>
<a name="ln4814"> </a>
<a name="ln4815">void item_spec::set_corpse_monster_spec(const mons_spec &amp;spec)</a>
<a name="ln4816">{</a>
<a name="ln4817">    if (&amp;spec != _corpse_monster_spec)</a>
<a name="ln4818">    {</a>
<a name="ln4819">        release_corpse_monster_spec();</a>
<a name="ln4820">        _corpse_monster_spec = new mons_spec(spec);</a>
<a name="ln4821">    }</a>
<a name="ln4822">}</a>
<a name="ln4823"> </a>
<a name="ln4824">void item_list::clear()</a>
<a name="ln4825">{</a>
<a name="ln4826">    items.clear();</a>
<a name="ln4827">}</a>
<a name="ln4828"> </a>
<a name="ln4829">item_spec item_list::random_item()</a>
<a name="ln4830">{</a>
<a name="ln4831">    if (items.empty())</a>
<a name="ln4832">    {</a>
<a name="ln4833">        const item_spec none;</a>
<a name="ln4834">        return none;</a>
<a name="ln4835">    }</a>
<a name="ln4836"> </a>
<a name="ln4837">    return get_item(random2(size()));</a>
<a name="ln4838">}</a>
<a name="ln4839"> </a>
<a name="ln4840">typedef pair&lt;item_spec, int&gt; item_pair;</a>
<a name="ln4841"> </a>
<a name="ln4842">item_spec item_list::random_item_weighted()</a>
<a name="ln4843">{</a>
<a name="ln4844">    const item_spec none;</a>
<a name="ln4845"> </a>
<a name="ln4846">    vector&lt;item_pair&gt; pairs;</a>
<a name="ln4847">    for (int i = 0, sz = size(); i &lt; sz; ++i)</a>
<a name="ln4848">    {</a>
<a name="ln4849">        item_spec item = get_item(i);</a>
<a name="ln4850">        pairs.emplace_back(item, item.genweight);</a>
<a name="ln4851">    }</a>
<a name="ln4852"> </a>
<a name="ln4853">    item_spec* rn_item = random_choose_weighted(pairs);</a>
<a name="ln4854">    if (rn_item)</a>
<a name="ln4855">        return *rn_item;</a>
<a name="ln4856"> </a>
<a name="ln4857">    return none;</a>
<a name="ln4858">}</a>
<a name="ln4859"> </a>
<a name="ln4860">item_spec item_list::pick_item(item_spec_slot &amp;slot)</a>
<a name="ln4861">{</a>
<a name="ln4862">    int cumulative = 0;</a>
<a name="ln4863">    item_spec pick;</a>
<a name="ln4864">    for (const auto &amp;spec : slot.ilist)</a>
<a name="ln4865">    {</a>
<a name="ln4866">        const int weight = spec.genweight;</a>
<a name="ln4867">        if (x_chance_in_y(weight, cumulative += weight))</a>
<a name="ln4868">            pick = spec;</a>
<a name="ln4869">    }</a>
<a name="ln4870"> </a>
<a name="ln4871">    if (slot.fix_slot)</a>
<a name="ln4872">    {</a>
<a name="ln4873">        slot.ilist.clear();</a>
<a name="ln4874">        slot.ilist.push_back(pick);</a>
<a name="ln4875">        slot.fix_slot = false;</a>
<a name="ln4876">    }</a>
<a name="ln4877"> </a>
<a name="ln4878">    return pick;</a>
<a name="ln4879">}</a>
<a name="ln4880"> </a>
<a name="ln4881">item_spec item_list::get_item(int index)</a>
<a name="ln4882">{</a>
<a name="ln4883">    if (index &lt; 0 || index &gt;= (int) items.size())</a>
<a name="ln4884">    {</a>
<a name="ln4885">        const item_spec none;</a>
<a name="ln4886">        return none;</a>
<a name="ln4887">    }</a>
<a name="ln4888"> </a>
<a name="ln4889">    return pick_item(items[index]);</a>
<a name="ln4890">}</a>
<a name="ln4891"> </a>
<a name="ln4892">string item_list::add_item(const string &amp;spec, bool fix)</a>
<a name="ln4893">{</a>
<a name="ln4894">    error.clear();</a>
<a name="ln4895"> </a>
<a name="ln4896">    item_spec_slot sp = parse_item_spec(spec);</a>
<a name="ln4897">    if (error.empty())</a>
<a name="ln4898">    {</a>
<a name="ln4899">        if (fix)</a>
<a name="ln4900">        {</a>
<a name="ln4901">            sp.fix_slot = true;</a>
<a name="ln4902">            pick_item(sp);</a>
<a name="ln4903">        }</a>
<a name="ln4904"> </a>
<a name="ln4905">        items.push_back(sp);</a>
<a name="ln4906">    }</a>
<a name="ln4907"> </a>
<a name="ln4908">    return error;</a>
<a name="ln4909">}</a>
<a name="ln4910"> </a>
<a name="ln4911">string item_list::set_item(int index, const string &amp;spec)</a>
<a name="ln4912">{</a>
<a name="ln4913">    error.clear();</a>
<a name="ln4914">    if (index &lt; 0)</a>
<a name="ln4915">        return error = make_stringf(&quot;Index %d out of range&quot;, index);</a>
<a name="ln4916"> </a>
<a name="ln4917">    item_spec_slot sp = parse_item_spec(spec);</a>
<a name="ln4918">    if (error.empty())</a>
<a name="ln4919">    {</a>
<a name="ln4920">        if (index &gt;= (int) items.size())</a>
<a name="ln4921">        {</a>
<a name="ln4922">            items.reserve(index + 1);</a>
<a name="ln4923">            items.resize(index + 1, item_spec_slot());</a>
<a name="ln4924">        }</a>
<a name="ln4925">        items.push_back(sp);</a>
<a name="ln4926">    }</a>
<a name="ln4927"> </a>
<a name="ln4928">    return error;</a>
<a name="ln4929">}</a>
<a name="ln4930"> </a>
<a name="ln4931">void item_list::set_from_slot(const item_list &amp;list, int slot_index)</a>
<a name="ln4932">{</a>
<a name="ln4933">    clear();</a>
<a name="ln4934"> </a>
<a name="ln4935">    // Don't set anything if an invalid index.</a>
<a name="ln4936">    // Future calls to get_item will just return no item.</a>
<a name="ln4937">    if (slot_index &lt; 0 || (size_t)slot_index &gt;= list.items.size())</a>
<a name="ln4938">        return;</a>
<a name="ln4939"> </a>
<a name="ln4940">    items.push_back(list.items[slot_index]);</a>
<a name="ln4941">}</a>
<a name="ln4942"> </a>
<a name="ln4943">// TODO: More checking for inappropriate combinations, like the holy</a>
<a name="ln4944">// wrath brand on a demonic weapon or the running ego on a helmet.</a>
<a name="ln4945">// NOTE: Be sure to update the reference in syntax.txt if this gets moved!</a>
<a name="ln4946">int str_to_ego(object_class_type item_type, string ego_str)</a>
<a name="ln4947">{</a>
<a name="ln4948">    const char* armour_egos[] =</a>
<a name="ln4949">    {</a>
<a name="ln4950">        &quot;running&quot;,</a>
<a name="ln4951">        &quot;fire_resistance&quot;,</a>
<a name="ln4952">        &quot;cold_resistance&quot;,</a>
<a name="ln4953">        &quot;poison_resistance&quot;,</a>
<a name="ln4954">        &quot;see_invisible&quot;,</a>
<a name="ln4955">        &quot;invisibility&quot;,</a>
<a name="ln4956">        &quot;strength&quot;,</a>
<a name="ln4957">        &quot;dexterity&quot;,</a>
<a name="ln4958">        &quot;intelligence&quot;,</a>
<a name="ln4959">        &quot;ponderousness&quot;,</a>
<a name="ln4960">        &quot;flying&quot;,</a>
<a name="ln4961">        &quot;magic_resistance&quot;,</a>
<a name="ln4962">        &quot;protection&quot;,</a>
<a name="ln4963">        &quot;stealth&quot;,</a>
<a name="ln4964">        &quot;resistance&quot;,</a>
<a name="ln4965">        &quot;positive_energy&quot;,</a>
<a name="ln4966">        &quot;archmagi&quot;,</a>
<a name="ln4967">#if TAG_MAJOR_VERSION == 34</a>
<a name="ln4968">        &quot;preservation&quot;,</a>
<a name="ln4969">#endif</a>
<a name="ln4970">        &quot;reflection&quot;,</a>
<a name="ln4971">        &quot;spirit_shield&quot;,</a>
<a name="ln4972">        &quot;archery&quot;,</a>
<a name="ln4973">#if TAG_MAJOR_VERSION == 34</a>
<a name="ln4974">        &quot;jumping&quot;,</a>
<a name="ln4975">#endif</a>
<a name="ln4976">        &quot;repulsion&quot;,</a>
<a name="ln4977">        &quot;cloud_immunity&quot;,</a>
<a name="ln4978">        nullptr</a>
<a name="ln4979">    };</a>
<a name="ln4980">    COMPILE_CHECK(ARRAYSZ(armour_egos) == NUM_REAL_SPECIAL_ARMOURS);</a>
<a name="ln4981"> </a>
<a name="ln4982">    const char* weapon_brands[] =</a>
<a name="ln4983">    {</a>
<a name="ln4984">        &quot;flaming&quot;,</a>
<a name="ln4985">        &quot;freezing&quot;,</a>
<a name="ln4986">        &quot;holy_wrath&quot;,</a>
<a name="ln4987">        &quot;electrocution&quot;,</a>
<a name="ln4988">#if TAG_MAJOR_VERSION == 34</a>
<a name="ln4989">        &quot;orc_slaying&quot;,</a>
<a name="ln4990">        &quot;dragon_slaying&quot;,</a>
<a name="ln4991">#endif</a>
<a name="ln4992">        &quot;venom&quot;,</a>
<a name="ln4993">        &quot;protection&quot;,</a>
<a name="ln4994">        &quot;draining&quot;,</a>
<a name="ln4995">        &quot;speed&quot;,</a>
<a name="ln4996">        &quot;vorpal&quot;,</a>
<a name="ln4997">#if TAG_MAJOR_VERSION == 34</a>
<a name="ln4998">        &quot;flame&quot;,</a>
<a name="ln4999">        &quot;frost&quot;,</a>
<a name="ln5000">#endif</a>
<a name="ln5001">        &quot;vampirism&quot;,</a>
<a name="ln5002">        &quot;pain&quot;,</a>
<a name="ln5003">        &quot;antimagic&quot;,</a>
<a name="ln5004">        &quot;distortion&quot;,</a>
<a name="ln5005">#if TAG_MAJOR_VERSION == 34</a>
<a name="ln5006">        &quot;reaching&quot;,</a>
<a name="ln5007">        &quot;returning&quot;,</a>
<a name="ln5008">#endif</a>
<a name="ln5009">        &quot;chaos&quot;,</a>
<a name="ln5010">#if TAG_MAJOR_VERSION == 34</a>
<a name="ln5011">        &quot;evasion&quot;,</a>
<a name="ln5012">        &quot;confuse&quot;,</a>
<a name="ln5013">#endif</a>
<a name="ln5014">        &quot;penetration&quot;,</a>
<a name="ln5015">        &quot;reaping&quot;,</a>
<a name="ln5016">        nullptr</a>
<a name="ln5017">    };</a>
<a name="ln5018">    COMPILE_CHECK(ARRAYSZ(weapon_brands) == NUM_REAL_SPECIAL_WEAPONS);</a>
<a name="ln5019"> </a>
<a name="ln5020">    const char* missile_brands[] =</a>
<a name="ln5021">    {</a>
<a name="ln5022">        &quot;flame&quot;,</a>
<a name="ln5023">        &quot;frost&quot;,</a>
<a name="ln5024">        &quot;poisoned&quot;,</a>
<a name="ln5025">        &quot;curare&quot;,</a>
<a name="ln5026">#if TAG_MAJOR_VERSION == 34</a>
<a name="ln5027">        &quot;returning&quot;,</a>
<a name="ln5028">#endif</a>
<a name="ln5029">        &quot;chaos&quot;,</a>
<a name="ln5030">#if TAG_MAJOR_VERSION == 34</a>
<a name="ln5031">        &quot;penetration&quot;,</a>
<a name="ln5032">#endif</a>
<a name="ln5033">        &quot;dispersal&quot;,</a>
<a name="ln5034">        &quot;exploding&quot;,</a>
<a name="ln5035">#if TAG_MAJOR_VERSION == 34</a>
<a name="ln5036">        &quot;steel&quot;,</a>
<a name="ln5037">#endif</a>
<a name="ln5038">        &quot;silver&quot;,</a>
<a name="ln5039">#if TAG_MAJOR_VERSION == 34</a>
<a name="ln5040">        &quot;paralysis&quot;,</a>
<a name="ln5041">        &quot;slow&quot;,</a>
<a name="ln5042">        &quot;sleep&quot;,</a>
<a name="ln5043">        &quot;confusion&quot;,</a>
<a name="ln5044">        &quot;sickness&quot;,</a>
<a name="ln5045">#endif</a>
<a name="ln5046">        &quot;datura&quot;,</a>
<a name="ln5047">        &quot;atropa&quot;,</a>
<a name="ln5048">        nullptr</a>
<a name="ln5049">    };</a>
<a name="ln5050">    COMPILE_CHECK(ARRAYSZ(missile_brands) == NUM_REAL_SPECIAL_MISSILES);</a>
<a name="ln5051"> </a>
<a name="ln5052">    const char** name_lists[3] = {armour_egos, weapon_brands, missile_brands};</a>
<a name="ln5053"> </a>
<a name="ln5054">    int armour_order[3]  = {0, 1, 2};</a>
<a name="ln5055">    int weapon_order[3]  = {1, 0, 2};</a>
<a name="ln5056">    int missile_order[3] = {2, 0, 1};</a>
<a name="ln5057"> </a>
<a name="ln5058">    int *order;</a>
<a name="ln5059"> </a>
<a name="ln5060">    switch (item_type)</a>
<a name="ln5061">    {</a>
<a name="ln5062">    case OBJ_ARMOUR:</a>
<a name="ln5063">        order = armour_order;</a>
<a name="ln5064">        break;</a>
<a name="ln5065"> </a>
<a name="ln5066">    case OBJ_WEAPONS:</a>
<a name="ln5067">        order = weapon_order;</a>
<a name="ln5068">        break;</a>
<a name="ln5069"> </a>
<a name="ln5070">    case OBJ_MISSILES:</a>
<a name="ln5071">#if TAG_MAJOR_VERSION == 34</a>
<a name="ln5072">        // HACK to get an old save to load; remove me soon?</a>
<a name="ln5073">        if (ego_str == &quot;sleeping&quot;)</a>
<a name="ln5074">            return SPMSL_SLEEP;</a>
<a name="ln5075">#endif</a>
<a name="ln5076">        order = missile_order;</a>
<a name="ln5077">        break;</a>
<a name="ln5078"> </a>
<a name="ln5079">    default:</a>
<a name="ln5080">        die(&quot;Bad base_type for ego'd item.&quot;);</a>
<a name="ln5081">        return 0;</a>
<a name="ln5082">    }</a>
<a name="ln5083"> </a>
<a name="ln5084">    const char** allowed = name_lists[order[0]];</a>
<a name="ln5085"> </a>
<a name="ln5086">    for (int i = 0; allowed[i] != nullptr; i++)</a>
<a name="ln5087">    {</a>
<a name="ln5088">        if (ego_str == allowed[i])</a>
<a name="ln5089">            return i + 1;</a>
<a name="ln5090">    }</a>
<a name="ln5091"> </a>
<a name="ln5092">    // Incompatible or non-existent ego type</a>
<a name="ln5093">    for (int i = 1; i &lt;= 2; i++)</a>
<a name="ln5094">    {</a>
<a name="ln5095">        const char** list = name_lists[order[i]];</a>
<a name="ln5096"> </a>
<a name="ln5097">        for (int j = 0; list[j] != nullptr; j++)</a>
<a name="ln5098">            if (ego_str == list[j])</a>
<a name="ln5099">                // Ego incompatible with base type.</a>
<a name="ln5100">                return -1;</a>
<a name="ln5101">    }</a>
<a name="ln5102"> </a>
<a name="ln5103">    // Non-existent ego</a>
<a name="ln5104">    return 0;</a>
<a name="ln5105">}</a>
<a name="ln5106"> </a>
<a name="ln5107">int item_list::parse_acquirement_source(const string &amp;source)</a>
<a name="ln5108">{</a>
<a name="ln5109">    const string god_name(replace_all_of(source, &quot;_&quot;, &quot; &quot;));</a>
<a name="ln5110">    const god_type god(str_to_god(god_name));</a>
<a name="ln5111">    if (god == GOD_NO_GOD)</a>
<a name="ln5112">        error = make_stringf(&quot;unknown god name: '%s'&quot;, god_name.c_str());</a>
<a name="ln5113">    return god;</a>
<a name="ln5114">}</a>
<a name="ln5115"> </a>
<a name="ln5116">bool item_list::monster_corpse_is_valid(monster_type *mons,</a>
<a name="ln5117">                                        const string &amp;name,</a>
<a name="ln5118">                                        bool skeleton)</a>
<a name="ln5119">{</a>
<a name="ln5120">    if (*mons == RANDOM_NONBASE_DRACONIAN || *mons == RANDOM_NONBASE_DEMONSPAWN)</a>
<a name="ln5121">    {</a>
<a name="ln5122">        error = &quot;Can't use non-base monster for corpse/chunk items&quot;;</a>
<a name="ln5123">        return false;</a>
<a name="ln5124">    }</a>
<a name="ln5125"> </a>
<a name="ln5126">    // Accept randomised types without further checks:</a>
<a name="ln5127">    if (*mons &gt;= NUM_MONSTERS)</a>
<a name="ln5128">        return true;</a>
<a name="ln5129"> </a>
<a name="ln5130">    // Convert to the monster species:</a>
<a name="ln5131">    *mons = mons_species(*mons);</a>
<a name="ln5132"> </a>
<a name="ln5133">    if (!mons_class_can_leave_corpse(*mons))</a>
<a name="ln5134">    {</a>
<a name="ln5135">        error = make_stringf(&quot;'%s' cannot leave corpses&quot;, name.c_str());</a>
<a name="ln5136">        return false;</a>
<a name="ln5137">    }</a>
<a name="ln5138"> </a>
<a name="ln5139">    if (skeleton &amp;&amp; !mons_skeleton(*mons))</a>
<a name="ln5140">    {</a>
<a name="ln5141">        error = make_stringf(&quot;'%s' has no skeleton&quot;, name.c_str());</a>
<a name="ln5142">        return false;</a>
<a name="ln5143">    }</a>
<a name="ln5144"> </a>
<a name="ln5145">    // We're ok.</a>
<a name="ln5146">    return true;</a>
<a name="ln5147">}</a>
<a name="ln5148"> </a>
<a name="ln5149">bool item_list::parse_corpse_spec(item_spec &amp;result, string s)</a>
<a name="ln5150">{</a>
<a name="ln5151">    const bool never_decay = strip_tag(s, &quot;never_decay&quot;);</a>
<a name="ln5152"> </a>
<a name="ln5153">    if (never_decay)</a>
<a name="ln5154">        result.props[CORPSE_NEVER_DECAYS].get_bool() = true;</a>
<a name="ln5155"> </a>
<a name="ln5156">    const bool corpse = strip_suffix(s, &quot;corpse&quot;);</a>
<a name="ln5157">    const bool skeleton = !corpse &amp;&amp; strip_suffix(s, &quot;skeleton&quot;);</a>
<a name="ln5158">    const bool chunk = !corpse &amp;&amp; !skeleton &amp;&amp; strip_suffix(s, &quot;chunk&quot;);</a>
<a name="ln5159"> </a>
<a name="ln5160">    result.base_type = chunk ? OBJ_FOOD : OBJ_CORPSES;</a>
<a name="ln5161">    result.sub_type  = (chunk ? static_cast&lt;int&gt;(FOOD_CHUNK) :</a>
<a name="ln5162">                        static_cast&lt;int&gt;(corpse ? CORPSE_BODY :</a>
<a name="ln5163">                                         CORPSE_SKELETON));</a>
<a name="ln5164"> </a>
<a name="ln5165">    // The caller wants a specific monster, no doubt with the best of</a>
<a name="ln5166">    // motives. Let's indulge them:</a>
<a name="ln5167">    mons_list mlist;</a>
<a name="ln5168">    const string mons_parse_err = mlist.add_mons(s, true);</a>
<a name="ln5169">    if (!mons_parse_err.empty())</a>
<a name="ln5170">    {</a>
<a name="ln5171">        error = mons_parse_err;</a>
<a name="ln5172">        return false;</a>
<a name="ln5173">    }</a>
<a name="ln5174"> </a>
<a name="ln5175">    // Get the actual monster spec:</a>
<a name="ln5176">    mons_spec spec = mlist.get_monster(0);</a>
<a name="ln5177">    monster_type mtype = static_cast&lt;monster_type&gt;(spec.type);</a>
<a name="ln5178">    if (!monster_corpse_is_valid(&amp;mtype, s, skeleton))</a>
<a name="ln5179">    {</a>
<a name="ln5180">        error = make_stringf(&quot;Requested corpse '%s' is invalid&quot;,</a>
<a name="ln5181">                             s.c_str());</a>
<a name="ln5182">        return false;</a>
<a name="ln5183">    }</a>
<a name="ln5184"> </a>
<a name="ln5185">    // Ok, looking good, the caller can have their requested toy.</a>
<a name="ln5186">    result.set_corpse_monster_spec(spec);</a>
<a name="ln5187">    return true;</a>
<a name="ln5188">}</a>
<a name="ln5189"> </a>
<a name="ln5190">bool item_list::parse_single_spec(item_spec&amp; result, string s)</a>
<a name="ln5191">{</a>
<a name="ln5192">    // If there's a colon, this must be a generation weight.</a>
<a name="ln5193">    int weight = find_weight(s);</a>
<a name="ln5194">    if (weight != TAG_UNFOUND)</a>
<a name="ln5195">    {</a>
<a name="ln5196">        result.genweight = weight;</a>
<a name="ln5197">        if (result.genweight &lt;= 0)</a>
<a name="ln5198">        {</a>
<a name="ln5199">            error = make_stringf(&quot;Bad item generation weight: '%d'&quot;,</a>
<a name="ln5200">                                 result.genweight);</a>
<a name="ln5201">            return false;</a>
<a name="ln5202">        }</a>
<a name="ln5203">    }</a>
<a name="ln5204"> </a>
<a name="ln5205">    const int qty = strip_number_tag(s, &quot;q:&quot;);</a>
<a name="ln5206">    if (qty != TAG_UNFOUND)</a>
<a name="ln5207">        result.qty = qty;</a>
<a name="ln5208"> </a>
<a name="ln5209">    const int fresh = strip_number_tag(s, &quot;fresh:&quot;);</a>
<a name="ln5210">    if (fresh != TAG_UNFOUND)</a>
<a name="ln5211">        result.item_special = fresh;</a>
<a name="ln5212">    const int special = strip_number_tag(s, &quot;special:&quot;);</a>
<a name="ln5213">    if (special != TAG_UNFOUND)</a>
<a name="ln5214">        result.item_special = special;</a>
<a name="ln5215"> </a>
<a name="ln5216">    // When placing corpses, use place:Elf:$ to choose monsters</a>
<a name="ln5217">    // appropriate for that level, as an example.</a>
<a name="ln5218">    const string place = strip_tag_prefix(s, &quot;place:&quot;);</a>
<a name="ln5219">    if (!place.empty())</a>
<a name="ln5220">    {</a>
<a name="ln5221">        try</a>
<a name="ln5222">        {</a>
<a name="ln5223">            result.place = level_id::parse_level_id(place);</a>
<a name="ln5224">        }</a>
<a name="ln5225">        catch (const bad_level_id &amp;err)</a>
<a name="ln5226">        {</a>
<a name="ln5227">            error = err.what();</a>
<a name="ln5228">            return false;</a>
<a name="ln5229">        }</a>
<a name="ln5230">    }</a>
<a name="ln5231"> </a>
<a name="ln5232">    // Damaged + cursed, but allow other specs to override the former.</a>
<a name="ln5233">    if (strip_tag(s, &quot;cursed&quot;))</a>
<a name="ln5234">    {</a>
<a name="ln5235">        result.level = ISPEC_BAD;</a>
<a name="ln5236">        result.props[&quot;cursed&quot;] = bool(true);</a>
<a name="ln5237">    }</a>
<a name="ln5238"> </a>
<a name="ln5239">    const string acquirement_source = strip_tag_prefix(s, &quot;acquire:&quot;);</a>
<a name="ln5240">    if (!acquirement_source.empty() || strip_tag(s, &quot;acquire&quot;))</a>
<a name="ln5241">    {</a>
<a name="ln5242">        if (!acquirement_source.empty())</a>
<a name="ln5243">        {</a>
<a name="ln5244">            result.acquirement_source =</a>
<a name="ln5245">                parse_acquirement_source(acquirement_source);</a>
<a name="ln5246">        }</a>
<a name="ln5247">        // If requesting acquirement, must specify item base type or</a>
<a name="ln5248">        // &quot;any&quot;.</a>
<a name="ln5249">        result.level = ISPEC_ACQUIREMENT;</a>
<a name="ln5250">        if (s == &quot;any&quot;)</a>
<a name="ln5251">            result.base_type = OBJ_RANDOM;</a>
<a name="ln5252">        else</a>
<a name="ln5253">            parse_random_by_class(s, result);</a>
<a name="ln5254">        return true;</a>
<a name="ln5255">    }</a>
<a name="ln5256"> </a>
<a name="ln5257">    string ego_str  = strip_tag_prefix(s, &quot;ego:&quot;);</a>
<a name="ln5258"> </a>
<a name="ln5259">    string id_str = strip_tag_prefix(s, &quot;ident:&quot;);</a>
<a name="ln5260">    if (id_str == &quot;all&quot;)</a>
<a name="ln5261">        result.props[&quot;ident&quot;].get_int() = ISFLAG_IDENT_MASK;</a>
<a name="ln5262">    else if (!id_str.empty())</a>
<a name="ln5263">    {</a>
<a name="ln5264">        vector&lt;string&gt; ids = split_string(&quot;|&quot;, id_str);</a>
<a name="ln5265">        int id = 0;</a>
<a name="ln5266">        for (const auto &amp;is : ids)</a>
<a name="ln5267">        {</a>
<a name="ln5268">            if (is == &quot;curse&quot;)</a>
<a name="ln5269">                id |= ISFLAG_KNOW_CURSE;</a>
<a name="ln5270">            else if (is == &quot;type&quot;)</a>
<a name="ln5271">                id |= ISFLAG_KNOW_TYPE;</a>
<a name="ln5272">            else if (is == &quot;pluses&quot;)</a>
<a name="ln5273">                id |= ISFLAG_KNOW_PLUSES;</a>
<a name="ln5274">            else if (is == &quot;properties&quot;)</a>
<a name="ln5275">                id |= ISFLAG_KNOW_PROPERTIES;</a>
<a name="ln5276">            else</a>
<a name="ln5277">            {</a>
<a name="ln5278">                error = make_stringf(&quot;Bad identify status: %s&quot;, id_str.c_str());</a>
<a name="ln5279">                return false;</a>
<a name="ln5280">            }</a>
<a name="ln5281">        }</a>
<a name="ln5282">        result.props[&quot;ident&quot;].get_int() = id;</a>
<a name="ln5283">    }</a>
<a name="ln5284"> </a>
<a name="ln5285">    if (strip_tag(s, &quot;good_item&quot;))</a>
<a name="ln5286">        result.level = ISPEC_GOOD_ITEM;</a>
<a name="ln5287">    else</a>
<a name="ln5288">    {</a>
<a name="ln5289">        int number = strip_number_tag(s, &quot;level:&quot;);</a>
<a name="ln5290">        if (number != TAG_UNFOUND)</a>
<a name="ln5291">        {</a>
<a name="ln5292">            if (number &lt;= 0 &amp;&amp; number != ISPEC_STAR &amp;&amp; number != ISPEC_SUPERB</a>
<a name="ln5293">                &amp;&amp; number != ISPEC_DAMAGED &amp;&amp; number != ISPEC_BAD)</a>
<a name="ln5294">            {</a>
<a name="ln5295">                error = make_stringf(&quot;Bad item level: %d&quot;, number);</a>
<a name="ln5296">                return false;</a>
<a name="ln5297">            }</a>
<a name="ln5298"> </a>
<a name="ln5299">            result.level = number;</a>
<a name="ln5300">        }</a>
<a name="ln5301">    }</a>
<a name="ln5302"> </a>
<a name="ln5303">    if (strip_tag(s, &quot;mundane&quot;))</a>
<a name="ln5304">    {</a>
<a name="ln5305">        result.level = ISPEC_MUNDANE;</a>
<a name="ln5306">        result.ego   = -1;</a>
<a name="ln5307">    }</a>
<a name="ln5308">    if (strip_tag(s, &quot;damaged&quot;))</a>
<a name="ln5309">        result.level = ISPEC_DAMAGED;</a>
<a name="ln5310">    if (strip_tag(s, &quot;randart&quot;))</a>
<a name="ln5311">        result.level = ISPEC_RANDART;</a>
<a name="ln5312">    if (strip_tag(s, &quot;not_cursed&quot;))</a>
<a name="ln5313">        result.props[&quot;uncursed&quot;] = bool(true);</a>
<a name="ln5314">    if (strip_tag(s, &quot;useful&quot;))</a>
<a name="ln5315">        result.props[&quot;useful&quot;] = bool(true);</a>
<a name="ln5316">    if (strip_tag(s, &quot;unobtainable&quot;))</a>
<a name="ln5317">        result.props[&quot;unobtainable&quot;] = true;</a>
<a name="ln5318"> </a>
<a name="ln5319">    const int mimic = strip_number_tag(s, &quot;mimic:&quot;);</a>
<a name="ln5320">    if (mimic != TAG_UNFOUND)</a>
<a name="ln5321">        result.props[&quot;mimic&quot;] = mimic;</a>
<a name="ln5322">    if (strip_tag(s, &quot;mimic&quot;))</a>
<a name="ln5323">        result.props[&quot;mimic&quot;] = 1;</a>
<a name="ln5324"> </a>
<a name="ln5325">    if (strip_tag(s, &quot;no_pickup&quot;))</a>
<a name="ln5326">        result.props[&quot;no_pickup&quot;] = true;</a>
<a name="ln5327"> </a>
<a name="ln5328">    const short charges = strip_number_tag(s, &quot;charges:&quot;);</a>
<a name="ln5329">    if (charges &gt;= 0)</a>
<a name="ln5330">        result.props[&quot;charges&quot;].get_int() = charges;</a>
<a name="ln5331"> </a>
<a name="ln5332">    const int plus = strip_number_tag(s, &quot;plus:&quot;);</a>
<a name="ln5333">    if (plus != TAG_UNFOUND)</a>
<a name="ln5334">        result.props[&quot;plus&quot;].get_int() = plus;</a>
<a name="ln5335">    const int plus2 = strip_number_tag(s, &quot;plus2:&quot;);</a>
<a name="ln5336">    if (plus2 != TAG_UNFOUND)</a>
<a name="ln5337">        result.props[&quot;plus2&quot;].get_int() = plus2;</a>
<a name="ln5338"> </a>
<a name="ln5339">    if (strip_tag(s, &quot;no_uniq&quot;))</a>
<a name="ln5340">        result.allow_uniques = 0;</a>
<a name="ln5341">    if (strip_tag(s, &quot;allow_uniq&quot;))</a>
<a name="ln5342">        result.allow_uniques = 1;</a>
<a name="ln5343">    else</a>
<a name="ln5344">    {</a>
<a name="ln5345">        int uniq = strip_number_tag(s, &quot;uniq:&quot;);</a>
<a name="ln5346">        if (uniq != TAG_UNFOUND)</a>
<a name="ln5347">        {</a>
<a name="ln5348">            if (uniq &lt;= 0)</a>
<a name="ln5349">            {</a>
<a name="ln5350">                error = make_stringf(&quot;Bad uniq level: %d&quot;, uniq);</a>
<a name="ln5351">                return false;</a>
<a name="ln5352">            }</a>
<a name="ln5353">            result.allow_uniques = uniq;</a>
<a name="ln5354">        }</a>
<a name="ln5355">    }</a>
<a name="ln5356"> </a>
<a name="ln5357">    // XXX: This is nice-ish now, but could probably do with being improved.</a>
<a name="ln5358">    if (strip_tag(s, &quot;randbook&quot;))</a>
<a name="ln5359">    {</a>
<a name="ln5360">        result.props[&quot;build_themed_book&quot;] = true;</a>
<a name="ln5361">        // build_themed_book requires the following properties:</a>
<a name="ln5362">        // disc: &lt;first discipline&gt;, disc2: &lt;optional second discipline&gt;</a>
<a name="ln5363">        // numspells: &lt;total number of spells&gt;, slevels: &lt;maximum levels&gt;</a>
<a name="ln5364">        // spell: &lt;include this spell&gt;, owner:&lt;name of owner&gt;</a>
<a name="ln5365">        // None of these are required, but if you don't intend on using any</a>
<a name="ln5366">        // of them, use &quot;any fixed theme book&quot; instead.</a>
<a name="ln5367">        spschool disc1 = spschool::none;</a>
<a name="ln5368">        spschool disc2 = spschool::none;</a>
<a name="ln5369"> </a>
<a name="ln5370">        string st_disc1 = strip_tag_prefix(s, &quot;disc:&quot;);</a>
<a name="ln5371">        if (!st_disc1.empty())</a>
<a name="ln5372">        {</a>
<a name="ln5373">            disc1 = school_by_name(st_disc1);</a>
<a name="ln5374">            if (disc1 == spschool::none)</a>
<a name="ln5375">            {</a>
<a name="ln5376">                error = make_stringf(&quot;Bad spell school: %s&quot;, st_disc1.c_str());</a>
<a name="ln5377">                return false;</a>
<a name="ln5378">            }</a>
<a name="ln5379">        }</a>
<a name="ln5380"> </a>
<a name="ln5381">        string st_disc2 = strip_tag_prefix(s, &quot;disc2:&quot;);</a>
<a name="ln5382">        if (!st_disc2.empty())</a>
<a name="ln5383">        {</a>
<a name="ln5384">            disc2 = school_by_name(st_disc2);</a>
<a name="ln5385">            if (disc2 == spschool::none)</a>
<a name="ln5386">            {</a>
<a name="ln5387">                error = make_stringf(&quot;Bad spell school: %s&quot;, st_disc2.c_str());</a>
<a name="ln5388">                return false;</a>
<a name="ln5389">            }</a>
<a name="ln5390">        }</a>
<a name="ln5391"> </a>
<a name="ln5392">        if (disc1 == spschool::none &amp;&amp; disc2 != spschool::none)</a>
<a name="ln5393">        {</a>
<a name="ln5394">            // Don't fail, just quietly swap. Any errors in disc1's syntax will</a>
<a name="ln5395">            // have been caught above, anyway.</a>
<a name="ln5396">            swap(disc1, disc2);</a>
<a name="ln5397">        }</a>
<a name="ln5398"> </a>
<a name="ln5399">        short num_spells = strip_number_tag(s, &quot;numspells:&quot;);</a>
<a name="ln5400">        if (num_spells == TAG_UNFOUND)</a>
<a name="ln5401">            num_spells = -1;</a>
<a name="ln5402">        else if (num_spells &lt;= 0 || num_spells &gt; RANDBOOK_SIZE)</a>
<a name="ln5403">        {</a>
<a name="ln5404">            error = make_stringf(&quot;Bad spellbook size: %d&quot;, num_spells);</a>
<a name="ln5405">            return false;</a>
<a name="ln5406">        }</a>
<a name="ln5407"> </a>
<a name="ln5408">        short slevels = strip_number_tag(s, &quot;slevels:&quot;);</a>
<a name="ln5409">        if (slevels == TAG_UNFOUND)</a>
<a name="ln5410">            slevels = -1;</a>
<a name="ln5411">        else if (slevels == 0)</a>
<a name="ln5412">        {</a>
<a name="ln5413">            error = make_stringf(&quot;Bad slevels: %d.&quot;, slevels);</a>
<a name="ln5414">            return false;</a>
<a name="ln5415">        }</a>
<a name="ln5416"> </a>
<a name="ln5417">        const string title = replace_all_of(strip_tag_prefix(s, &quot;title:&quot;),</a>
<a name="ln5418">                                            &quot;_&quot;, &quot; &quot;);</a>
<a name="ln5419"> </a>
<a name="ln5420">        const string spells = strip_tag_prefix(s, &quot;spells:&quot;);</a>
<a name="ln5421"> </a>
<a name="ln5422">        vector&lt;string&gt; spell_list = split_string(&quot;&amp;&quot;, spells);</a>
<a name="ln5423">        CrawlVector &amp;incl_spells</a>
<a name="ln5424">            = result.props[RANDBK_SPELLS_KEY].new_vector(SV_INT);</a>
<a name="ln5425"> </a>
<a name="ln5426">        for (const string &amp;spnam : spell_list)</a>
<a name="ln5427">        {</a>
<a name="ln5428">            string spell_name = replace_all_of(spnam, &quot;_&quot;, &quot; &quot;);</a>
<a name="ln5429">            spell_type spell = spell_by_name(spell_name);</a>
<a name="ln5430">            if (spell == SPELL_NO_SPELL)</a>
<a name="ln5431">            {</a>
<a name="ln5432">                error = make_stringf(&quot;Bad spell: %s&quot;, spnam.c_str());</a>
<a name="ln5433">                return false;</a>
<a name="ln5434">            }</a>
<a name="ln5435">            incl_spells.push_back(spell);</a>
<a name="ln5436">        }</a>
<a name="ln5437"> </a>
<a name="ln5438">        const string owner = replace_all_of(strip_tag_prefix(s, &quot;owner:&quot;),</a>
<a name="ln5439">                                            &quot;_&quot;, &quot; &quot;);</a>
<a name="ln5440"> </a>
<a name="ln5441">        result.props[RANDBK_DISC1_KEY].get_short() = static_cast&lt;short&gt;(disc1);</a>
<a name="ln5442">        result.props[RANDBK_DISC2_KEY].get_short() = static_cast&lt;short&gt;(disc2);</a>
<a name="ln5443">        result.props[RANDBK_NSPELLS_KEY] = num_spells;</a>
<a name="ln5444">        result.props[RANDBK_SLVLS_KEY] = slevels;</a>
<a name="ln5445">        result.props[RANDBK_TITLE_KEY] = title;</a>
<a name="ln5446">        result.props[RANDBK_OWNER_KEY] = owner;</a>
<a name="ln5447"> </a>
<a name="ln5448">        result.base_type = OBJ_BOOKS;</a>
<a name="ln5449">        // This is changed in build_themed_book().</a>
<a name="ln5450">        result.sub_type = BOOK_MINOR_MAGIC;</a>
<a name="ln5451">        result.plus = -1;</a>
<a name="ln5452"> </a>
<a name="ln5453">        return true;</a>
<a name="ln5454">    }</a>
<a name="ln5455"> </a>
<a name="ln5456">    if (s.find(&quot;deck&quot;) != string::npos)</a>
<a name="ln5457">    {</a>
<a name="ln5458">        error = make_stringf(&quot;removed deck: \&quot;%s\&quot;.&quot;, s.c_str());</a>
<a name="ln5459">        return false;</a>
<a name="ln5460">    }</a>
<a name="ln5461"> </a>
<a name="ln5462">    string tile = strip_tag_prefix(s, &quot;tile:&quot;);</a>
<a name="ln5463">    if (!tile.empty())</a>
<a name="ln5464">    {</a>
<a name="ln5465">        tileidx_t index;</a>
<a name="ln5466">        if (!tile_main_index(tile.c_str(), &amp;index))</a>
<a name="ln5467">        {</a>
<a name="ln5468">            error = make_stringf(&quot;bad tile name: \&quot;%s\&quot;.&quot;, tile.c_str());</a>
<a name="ln5469">            return false;</a>
<a name="ln5470">        }</a>
<a name="ln5471">        result.props[&quot;item_tile_name&quot;].get_string() = tile;</a>
<a name="ln5472">    }</a>
<a name="ln5473"> </a>
<a name="ln5474">    tile = strip_tag_prefix(s, &quot;wtile:&quot;);</a>
<a name="ln5475">    if (!tile.empty())</a>
<a name="ln5476">    {</a>
<a name="ln5477">        tileidx_t index;</a>
<a name="ln5478">        if (!tile_player_index(tile.c_str(), &amp;index))</a>
<a name="ln5479">        {</a>
<a name="ln5480">            error = make_stringf(&quot;bad tile name: \&quot;%s\&quot;.&quot;, tile.c_str());</a>
<a name="ln5481">            return false;</a>
<a name="ln5482">        }</a>
<a name="ln5483">        result.props[&quot;worn_tile_name&quot;].get_string() = tile;</a>
<a name="ln5484">    }</a>
<a name="ln5485"> </a>
<a name="ln5486">    // Clean up after any tag brain damage.</a>
<a name="ln5487">    trim_string(s);</a>
<a name="ln5488"> </a>
<a name="ln5489">    if (!ego_str.empty())</a>
<a name="ln5490">        error = &quot;Can't set an ego for random items.&quot;;</a>
<a name="ln5491"> </a>
<a name="ln5492">    // Completely random?</a>
<a name="ln5493">    if (s == &quot;random&quot; || s == &quot;any&quot; || s == &quot;%&quot;)</a>
<a name="ln5494">        return true;</a>
<a name="ln5495"> </a>
<a name="ln5496">    if (s == &quot;*&quot; || s == &quot;star_item&quot;)</a>
<a name="ln5497">    {</a>
<a name="ln5498">        result.level = ISPEC_STAR;</a>
<a name="ln5499">        return true;</a>
<a name="ln5500">    }</a>
<a name="ln5501">    else if (s == &quot;|&quot; || s == &quot;superb_item&quot;)</a>
<a name="ln5502">    {</a>
<a name="ln5503">        result.level = ISPEC_SUPERB;</a>
<a name="ln5504">        return true;</a>
<a name="ln5505">    }</a>
<a name="ln5506">    else if (s == &quot;$&quot; || s == &quot;gold&quot;)</a>
<a name="ln5507">    {</a>
<a name="ln5508">        if (!ego_str.empty())</a>
<a name="ln5509">        {</a>
<a name="ln5510">            error = &quot;Can't set an ego for gold.&quot;;</a>
<a name="ln5511">            return false;</a>
<a name="ln5512">        }</a>
<a name="ln5513"> </a>
<a name="ln5514">        result.base_type = OBJ_GOLD;</a>
<a name="ln5515">        result.sub_type  = OBJ_RANDOM;</a>
<a name="ln5516">        return true;</a>
<a name="ln5517">    }</a>
<a name="ln5518"> </a>
<a name="ln5519">    if (s == &quot;nothing&quot;)</a>
<a name="ln5520">    {</a>
<a name="ln5521">        error.clear();</a>
<a name="ln5522">        result.base_type = OBJ_UNASSIGNED;</a>
<a name="ln5523">        return true;</a>
<a name="ln5524">    }</a>
<a name="ln5525"> </a>
<a name="ln5526">    error.clear();</a>
<a name="ln5527"> </a>
<a name="ln5528">    // Look for corpses, chunks, skeletons:</a>
<a name="ln5529">    if (ends_with(s, &quot;corpse&quot;) || ends_with(s, &quot;chunk&quot;)</a>
<a name="ln5530">        || ends_with(s, &quot;skeleton&quot;))</a>
<a name="ln5531">    {</a>
<a name="ln5532">        return parse_corpse_spec(result, s);</a>
<a name="ln5533">    }</a>
<a name="ln5534"> </a>
<a name="ln5535">    const int unrand_id = get_unrandart_num(s.c_str());</a>
<a name="ln5536">    if (unrand_id)</a>
<a name="ln5537">    {</a>
<a name="ln5538">        result.ego = -unrand_id; // lol</a>
<a name="ln5539">        return true;</a>
<a name="ln5540">    }</a>
<a name="ln5541"> </a>
<a name="ln5542">    // Check for &quot;any objclass&quot;</a>
<a name="ln5543">    if (starts_with(s, &quot;any &quot;))</a>
<a name="ln5544">        parse_random_by_class(s.substr(4), result);</a>
<a name="ln5545">    else if (starts_with(s, &quot;random &quot;))</a>
<a name="ln5546">        parse_random_by_class(s.substr(7), result);</a>
<a name="ln5547">    // Check for actual item names.</a>
<a name="ln5548">    else</a>
<a name="ln5549">        parse_raw_name(s, result);</a>
<a name="ln5550"> </a>
<a name="ln5551">    if (!error.empty())</a>
<a name="ln5552">        return false;</a>
<a name="ln5553"> </a>
<a name="ln5554">    if (ego_str.empty())</a>
<a name="ln5555">        return true;</a>
<a name="ln5556"> </a>
<a name="ln5557">    if (result.base_type != OBJ_WEAPONS</a>
<a name="ln5558">        &amp;&amp; result.base_type != OBJ_MISSILES</a>
<a name="ln5559">        &amp;&amp; result.base_type != OBJ_ARMOUR)</a>
<a name="ln5560">    {</a>
<a name="ln5561">        error = &quot;An ego can only be applied to a weapon, missile or &quot;</a>
<a name="ln5562">            &quot;armour.&quot;;</a>
<a name="ln5563">        return false;</a>
<a name="ln5564">    }</a>
<a name="ln5565"> </a>
<a name="ln5566">    if (ego_str == &quot;none&quot;)</a>
<a name="ln5567">    {</a>
<a name="ln5568">        result.ego = -1;</a>
<a name="ln5569">        return true;</a>
<a name="ln5570">    }</a>
<a name="ln5571"> </a>
<a name="ln5572">    const int ego = str_to_ego(result.base_type, ego_str);</a>
<a name="ln5573"> </a>
<a name="ln5574">    if (ego == 0)</a>
<a name="ln5575">    {</a>
<a name="ln5576">        error = make_stringf(&quot;No such ego as: %s&quot;, ego_str.c_str());</a>
<a name="ln5577">        return false;</a>
<a name="ln5578">    }</a>
<a name="ln5579">    else if (ego == -1)</a>
<a name="ln5580">    {</a>
<a name="ln5581">        error = make_stringf(&quot;Ego '%s' is invalid for item '%s'.&quot;,</a>
<a name="ln5582">                             ego_str.c_str(), s.c_str());</a>
<a name="ln5583">        return false;</a>
<a name="ln5584">    }</a>
<a name="ln5585">    else if (result.sub_type == OBJ_RANDOM)</a>
<a name="ln5586">    {</a>
<a name="ln5587">        // it will be assigned among appropriate ones later</a>
<a name="ln5588">    }</a>
<a name="ln5589">    else if (result.base_type == OBJ_WEAPONS</a>
<a name="ln5590">                &amp;&amp; !is_weapon_brand_ok(result.sub_type, ego, false)</a>
<a name="ln5591">             || result.base_type == OBJ_ARMOUR</a>
<a name="ln5592">                &amp;&amp; !is_armour_brand_ok(result.sub_type, ego, false)</a>
<a name="ln5593">             || result.base_type == OBJ_MISSILES</a>
<a name="ln5594">                &amp;&amp; !is_missile_brand_ok(result.sub_type, ego, false))</a>
<a name="ln5595">    {</a>
<a name="ln5596">        error = make_stringf(&quot;Ego '%s' is incompatible with item '%s'.&quot;,</a>
<a name="ln5597">                             ego_str.c_str(), s.c_str());</a>
<a name="ln5598">        return false;</a>
<a name="ln5599">    }</a>
<a name="ln5600">    result.ego = ego;</a>
<a name="ln5601">    return true;</a>
<a name="ln5602">}</a>
<a name="ln5603"> </a>
<a name="ln5604">void item_list::parse_random_by_class(string c, item_spec &amp;spec)</a>
<a name="ln5605">{</a>
<a name="ln5606">    trim_string(c);</a>
<a name="ln5607">    if (c == &quot;?&quot; || c.empty())</a>
<a name="ln5608">    {</a>
<a name="ln5609">        error = make_stringf(&quot;Bad item class: '%s'&quot;, c.c_str());</a>
<a name="ln5610">        return;</a>
<a name="ln5611">    }</a>
<a name="ln5612"> </a>
<a name="ln5613">    for (int type = OBJ_WEAPONS; type &lt; NUM_OBJECT_CLASSES; ++type)</a>
<a name="ln5614">    {</a>
<a name="ln5615">        if (c == item_class_name(type, true))</a>
<a name="ln5616">        {</a>
<a name="ln5617">            spec.base_type = static_cast&lt;object_class_type&gt;(type);</a>
<a name="ln5618">            return;</a>
<a name="ln5619">        }</a>
<a name="ln5620">    }</a>
<a name="ln5621"> </a>
<a name="ln5622">    // Random manual?</a>
<a name="ln5623">    if (c == &quot;manual&quot;)</a>
<a name="ln5624">    {</a>
<a name="ln5625">        spec.base_type = OBJ_BOOKS;</a>
<a name="ln5626">        spec.sub_type  = BOOK_MANUAL;</a>
<a name="ln5627">        spec.plus      = -1;</a>
<a name="ln5628">        return;</a>
<a name="ln5629">    }</a>
<a name="ln5630">    else if (c == &quot;fixed theme book&quot;)</a>
<a name="ln5631">    {</a>
<a name="ln5632">        spec.base_type = OBJ_BOOKS;</a>
<a name="ln5633">        spec.sub_type  = BOOK_RANDART_THEME;</a>
<a name="ln5634">        spec.plus      = -1;</a>
<a name="ln5635">        return;</a>
<a name="ln5636">    }</a>
<a name="ln5637">    else if (c == &quot;fixed level book&quot;)</a>
<a name="ln5638">    {</a>
<a name="ln5639">        spec.base_type = OBJ_BOOKS;</a>
<a name="ln5640">        spec.sub_type  = BOOK_RANDART_LEVEL;</a>
<a name="ln5641">        spec.plus      = -1;</a>
<a name="ln5642">        return;</a>
<a name="ln5643">    }</a>
<a name="ln5644">    else if (c == &quot;ring&quot;)</a>
<a name="ln5645">    {</a>
<a name="ln5646">        spec.base_type = OBJ_JEWELLERY;</a>
<a name="ln5647">        spec.sub_type = NUM_RINGS;</a>
<a name="ln5648">        return;</a>
<a name="ln5649">    }</a>
<a name="ln5650">    else if (c == &quot;amulet&quot;)</a>
<a name="ln5651">    {</a>
<a name="ln5652">        spec.base_type = OBJ_JEWELLERY;</a>
<a name="ln5653">        spec.sub_type = NUM_JEWELLERY;</a>
<a name="ln5654">        return;</a>
<a name="ln5655">    }</a>
<a name="ln5656"> </a>
<a name="ln5657">    error = make_stringf(&quot;Bad item class: '%s'&quot;, c.c_str());</a>
<a name="ln5658">}</a>
<a name="ln5659"> </a>
<a name="ln5660">void item_list::parse_raw_name(string name, item_spec &amp;spec)</a>
<a name="ln5661">{</a>
<a name="ln5662">    trim_string(name);</a>
<a name="ln5663">    if (name.empty())</a>
<a name="ln5664">    {</a>
<a name="ln5665">        error = make_stringf(&quot;Bad item name: '%s'&quot;, name.c_str());</a>
<a name="ln5666">        return ;</a>
<a name="ln5667">    }</a>
<a name="ln5668"> </a>
<a name="ln5669">    item_kind parsed = item_kind_by_name(name);</a>
<a name="ln5670">    if (parsed.base_type != OBJ_UNASSIGNED)</a>
<a name="ln5671">    {</a>
<a name="ln5672">        spec.base_type = parsed.base_type;</a>
<a name="ln5673">        spec.sub_type  = parsed.sub_type;</a>
<a name="ln5674">        spec.plus      = parsed.plus;</a>
<a name="ln5675">        spec.plus2     = parsed.plus2;</a>
<a name="ln5676">        return;</a>
<a name="ln5677">    }</a>
<a name="ln5678"> </a>
<a name="ln5679">    error = make_stringf(&quot;Bad item name: '%s'&quot;, name.c_str());</a>
<a name="ln5680">}</a>
<a name="ln5681"> </a>
<a name="ln5682">item_list::item_spec_slot item_list::parse_item_spec(string spec)</a>
<a name="ln5683">{</a>
<a name="ln5684">    // lowercase(spec);</a>
<a name="ln5685"> </a>
<a name="ln5686">    item_spec_slot list;</a>
<a name="ln5687"> </a>
<a name="ln5688">    list.fix_slot = strip_tag(spec, &quot;fix_slot&quot;);</a>
<a name="ln5689"> </a>
<a name="ln5690">    for (const string &amp;specifier : split_string(&quot;/&quot;, spec))</a>
<a name="ln5691">    {</a>
<a name="ln5692">        item_spec result;</a>
<a name="ln5693">        if (parse_single_spec(result, specifier))</a>
<a name="ln5694">            list.ilist.push_back(result);</a>
<a name="ln5695">        else</a>
<a name="ln5696">            dprf(DIAG_DNGN, &quot;Failed to parse: %s&quot;, specifier.c_str());</a>
<a name="ln5697">    }</a>
<a name="ln5698"> </a>
<a name="ln5699">    return list;</a>
<a name="ln5700">}</a>
<a name="ln5701"> </a>
<a name="ln5702">/////////////////////////////////////////////////////////////////////////</a>
<a name="ln5703">// subst_spec</a>
<a name="ln5704"> </a>
<a name="ln5705">subst_spec::subst_spec(string _k, bool _f, const glyph_replacements_t &amp;g)</a>
<a name="ln5706">    : key(_k), count(-1), fix(_f), frozen_value(0), repl(g)</a>
<a name="ln5707">{</a>
<a name="ln5708">}</a>
<a name="ln5709"> </a>
<a name="ln5710">subst_spec::subst_spec(int _count, bool dofix, const glyph_replacements_t &amp;g)</a>
<a name="ln5711">    : key(&quot;&quot;), count(_count), fix(dofix), frozen_value(0), repl(g)</a>
<a name="ln5712">{</a>
<a name="ln5713">}</a>
<a name="ln5714"> </a>
<a name="ln5715">int subst_spec::value()</a>
<a name="ln5716">{</a>
<a name="ln5717">    if (frozen_value)</a>
<a name="ln5718">        return frozen_value;</a>
<a name="ln5719"> </a>
<a name="ln5720">    int cumulative = 0;</a>
<a name="ln5721">    int chosen = 0;</a>
<a name="ln5722">    for (glyph_weighted_replacement_t rep : repl)</a>
<a name="ln5723">        if (x_chance_in_y(rep.second, cumulative += rep.second))</a>
<a name="ln5724">            chosen = rep.first;</a>
<a name="ln5725"> </a>
<a name="ln5726">    if (fix)</a>
<a name="ln5727">        frozen_value = chosen;</a>
<a name="ln5728"> </a>
<a name="ln5729">    return chosen;</a>
<a name="ln5730">}</a>
<a name="ln5731"> </a>
<a name="ln5732">//////////////////////////////////////////////////////////////////////////</a>
<a name="ln5733">// nsubst_spec</a>
<a name="ln5734"> </a>
<a name="ln5735">nsubst_spec::nsubst_spec(string _key, const vector&lt;subst_spec&gt; &amp;_specs)</a>
<a name="ln5736">    : key(_key), specs(_specs)</a>
<a name="ln5737">{</a>
<a name="ln5738">}</a>
<a name="ln5739"> </a>
<a name="ln5740">//////////////////////////////////////////////////////////////////////////</a>
<a name="ln5741">// colour_spec</a>
<a name="ln5742"> </a>
<a name="ln5743">int colour_spec::get_colour()</a>
<a name="ln5744">{</a>
<a name="ln5745">    if (fixed_colour != BLACK)</a>
<a name="ln5746">        return fixed_colour;</a>
<a name="ln5747"> </a>
<a name="ln5748">    int chosen = BLACK;</a>
<a name="ln5749">    int cweight = 0;</a>
<a name="ln5750">    for (map_weighted_colour col : colours)</a>
<a name="ln5751">        if (x_chance_in_y(col.second, cweight += col.second))</a>
<a name="ln5752">            chosen = col.first;</a>
<a name="ln5753">    if (fix)</a>
<a name="ln5754">        fixed_colour = chosen;</a>
<a name="ln5755">    return chosen;</a>
<a name="ln5756">}</a>
<a name="ln5757"> </a>
<a name="ln5758">//////////////////////////////////////////////////////////////////////////</a>
<a name="ln5759">// fprop_spec</a>
<a name="ln5760"> </a>
<a name="ln5761">feature_property_type fprop_spec::get_property()</a>
<a name="ln5762">{</a>
<a name="ln5763">    if (fixed_prop != FPROP_NONE)</a>
<a name="ln5764">        return fixed_prop;</a>
<a name="ln5765"> </a>
<a name="ln5766">    feature_property_type chosen = FPROP_NONE;</a>
<a name="ln5767">    int cweight = 0;</a>
<a name="ln5768">    for (map_weighted_fprop fprop : fprops)</a>
<a name="ln5769">        if (x_chance_in_y(fprop.second, cweight += fprop.second))</a>
<a name="ln5770">            chosen = fprop.first;</a>
<a name="ln5771">    if (fix)</a>
<a name="ln5772">        fixed_prop = chosen;</a>
<a name="ln5773">    return chosen;</a>
<a name="ln5774">}</a>
<a name="ln5775"> </a>
<a name="ln5776">//////////////////////////////////////////////////////////////////////////</a>
<a name="ln5777">// fheight_spec</a>
<a name="ln5778"> </a>
<a name="ln5779">int fheight_spec::get_height()</a>
<a name="ln5780">{</a>
<a name="ln5781">    if (fixed_height != INVALID_HEIGHT)</a>
<a name="ln5782">        return fixed_height;</a>
<a name="ln5783"> </a>
<a name="ln5784">    int chosen = INVALID_HEIGHT;</a>
<a name="ln5785">    int cweight = 0;</a>
<a name="ln5786">    for (map_weighted_fheight fh : fheights)</a>
<a name="ln5787">        if (x_chance_in_y(fh.second, cweight += fh.second))</a>
<a name="ln5788">            chosen = fh.first;</a>
<a name="ln5789">    if (fix)</a>
<a name="ln5790">        fixed_height = chosen;</a>
<a name="ln5791">    return chosen;</a>
<a name="ln5792">}</a>
<a name="ln5793"> </a>
<a name="ln5794">//////////////////////////////////////////////////////////////////////////</a>
<a name="ln5795">// string_spec</a>
<a name="ln5796"> </a>
<a name="ln5797">string string_spec::get_property()</a>
<a name="ln5798">{</a>
<a name="ln5799">    if (!fixed_str.empty())</a>
<a name="ln5800">        return fixed_str;</a>
<a name="ln5801"> </a>
<a name="ln5802">    string chosen = &quot;&quot;;</a>
<a name="ln5803">    int cweight = 0;</a>
<a name="ln5804">    for (const map_weighted_string &amp;str : strlist)</a>
<a name="ln5805">        if (x_chance_in_y(str.second, cweight += str.second))</a>
<a name="ln5806">            chosen = str.first;</a>
<a name="ln5807">    if (fix)</a>
<a name="ln5808">        fixed_str = chosen;</a>
<a name="ln5809">    return chosen;</a>
<a name="ln5810">}</a>
<a name="ln5811"> </a>
<a name="ln5812">//////////////////////////////////////////////////////////////////////////</a>
<a name="ln5813">// map_marker_spec</a>
<a name="ln5814"> </a>
<a name="ln5815">string map_marker_spec::apply_transform(map_lines &amp;map)</a>
<a name="ln5816">{</a>
<a name="ln5817">    vector&lt;coord_def&gt; positions = map.find_glyph(key);</a>
<a name="ln5818"> </a>
<a name="ln5819">    // Markers with no key are not an error.</a>
<a name="ln5820">    if (positions.empty())</a>
<a name="ln5821">        return &quot;&quot;;</a>
<a name="ln5822"> </a>
<a name="ln5823">    for (coord_def p : positions)</a>
<a name="ln5824">    {</a>
<a name="ln5825">        try</a>
<a name="ln5826">        {</a>
<a name="ln5827">            map_marker *mark = create_marker();</a>
<a name="ln5828">            if (!mark)</a>
<a name="ln5829">            {</a>
<a name="ln5830">                return make_stringf(&quot;Unable to parse marker from %s&quot;,</a>
<a name="ln5831">                                    marker.c_str());</a>
<a name="ln5832">            }</a>
<a name="ln5833">            mark-&gt;pos = p;</a>
<a name="ln5834">            map.add_marker(mark);</a>
<a name="ln5835">        }</a>
<a name="ln5836">        catch (const bad_map_marker &amp;err)</a>
<a name="ln5837">        {</a>
<a name="ln5838">            return err.what();</a>
<a name="ln5839">        }</a>
<a name="ln5840">    }</a>
<a name="ln5841">    return &quot;&quot;;</a>
<a name="ln5842">}</a>
<a name="ln5843"> </a>
<a name="ln5844">map_marker *map_marker_spec::create_marker()</a>
<a name="ln5845">{</a>
<a name="ln5846">    return lua_fn</a>
<a name="ln5847">        ? new map_lua_marker(*lua_fn)</a>
<a name="ln5848">        : map_marker::parse_marker(marker);</a>
<a name="ln5849">}</a>
<a name="ln5850"> </a>
<a name="ln5851">//////////////////////////////////////////////////////////////////////////</a>
<a name="ln5852">// map_flags</a>
<a name="ln5853">map_flags::map_flags()</a>
<a name="ln5854">    : flags_set(0), flags_unset(0)</a>
<a name="ln5855">{</a>
<a name="ln5856">}</a>
<a name="ln5857"> </a>
<a name="ln5858">void map_flags::clear()</a>
<a name="ln5859">{</a>
<a name="ln5860">    flags_set = flags_unset = 0;</a>
<a name="ln5861">}</a>
<a name="ln5862"> </a>
<a name="ln5863">map_flags &amp;map_flags::operator |= (const map_flags &amp;o)</a>
<a name="ln5864">{</a>
<a name="ln5865">    flags_set |= o.flags_set;</a>
<a name="ln5866">    flags_unset |= o.flags_unset;</a>
<a name="ln5867"> </a>
<a name="ln5868">    // In the event of conflict, the later flag set (o here) wins.</a>
<a name="ln5869">    flags_set &amp;= ~o.flags_unset;</a>
<a name="ln5870">    flags_unset &amp;= ~o.flags_set;</a>
<a name="ln5871"> </a>
<a name="ln5872">    return *this;</a>
<a name="ln5873">}</a>
<a name="ln5874">typedef map&lt;string, unsigned long&gt; flag_map;</a>
<a name="ln5875"> </a>
<a name="ln5876">map_flags map_flags::parse(const string flag_list[], const string &amp;s)</a>
<a name="ln5877">{</a>
<a name="ln5878">    map_flags mf;</a>
<a name="ln5879"> </a>
<a name="ln5880">    const vector&lt;string&gt; segs = split_string(&quot;/&quot;, s);</a>
<a name="ln5881"> </a>
<a name="ln5882">    flag_map flag_vals;</a>
<a name="ln5883">    for (int i = 0; !flag_list[i].empty(); i++)</a>
<a name="ln5884">        flag_vals[flag_list[i]] = 1 &lt;&lt; i;</a>
<a name="ln5885"> </a>
<a name="ln5886">    for (string flag: segs)</a>
<a name="ln5887">    {</a>
<a name="ln5888">        bool negate = false;</a>
<a name="ln5889"> </a>
<a name="ln5890">        if (flag[0] == '!')</a>
<a name="ln5891">        {</a>
<a name="ln5892">            flag   = flag.substr(1);</a>
<a name="ln5893">            negate = true;</a>
<a name="ln5894">        }</a>
<a name="ln5895"> </a>
<a name="ln5896">        if (unsigned long *val = map_find(flag_vals, flag))</a>
<a name="ln5897">        {</a>
<a name="ln5898">            if (negate)</a>
<a name="ln5899">                mf.flags_unset |= *val;</a>
<a name="ln5900">            else</a>
<a name="ln5901">                mf.flags_set |= *val;</a>
<a name="ln5902">        }</a>
<a name="ln5903">        else</a>
<a name="ln5904">            throw bad_map_flag(flag);</a>
<a name="ln5905">    }</a>
<a name="ln5906"> </a>
<a name="ln5907">    return mf;</a>
<a name="ln5908">}</a>
<a name="ln5909"> </a>
<a name="ln5910">//////////////////////////////////////////////////////////////////////////</a>
<a name="ln5911">// keyed_mapspec</a>
<a name="ln5912"> </a>
<a name="ln5913">keyed_mapspec::keyed_mapspec()</a>
<a name="ln5914">    :  key_glyph(-1), feat(), item(), mons()</a>
<a name="ln5915">{</a>
<a name="ln5916">}</a>
<a name="ln5917"> </a>
<a name="ln5918">string keyed_mapspec::set_feat(const string &amp;s, bool fix)</a>
<a name="ln5919">{</a>
<a name="ln5920">    err.clear();</a>
<a name="ln5921">    parse_features(s);</a>
<a name="ln5922">    feat.fix_slot = fix;</a>
<a name="ln5923"> </a>
<a name="ln5924">    // Fix this feature.</a>
<a name="ln5925">    if (fix)</a>
<a name="ln5926">        get_feat();</a>
<a name="ln5927"> </a>
<a name="ln5928">    return err;</a>
<a name="ln5929">}</a>
<a name="ln5930"> </a>
<a name="ln5931">void keyed_mapspec::copy_feat(const keyed_mapspec &amp;spec)</a>
<a name="ln5932">{</a>
<a name="ln5933">    feat = spec.feat;</a>
<a name="ln5934">}</a>
<a name="ln5935"> </a>
<a name="ln5936">void keyed_mapspec::parse_features(const string &amp;s)</a>
<a name="ln5937">{</a>
<a name="ln5938">    feat.feats.clear();</a>
<a name="ln5939">    for (const string &amp;spec : split_string(&quot;/&quot;, s))</a>
<a name="ln5940">    {</a>
<a name="ln5941">        feature_spec_list feats = parse_feature(spec);</a>
<a name="ln5942">        if (!err.empty())</a>
<a name="ln5943">            return;</a>
<a name="ln5944">        feat.feats.insert(feat.feats.end(),</a>
<a name="ln5945">                           feats.begin(),</a>
<a name="ln5946">                           feats.end());</a>
<a name="ln5947">    }</a>
<a name="ln5948">}</a>
<a name="ln5949"> </a>
<a name="ln5950">/**</a>
<a name="ln5951"> * Convert a trap string into a trap_spec.</a>
<a name="ln5952"> *</a>
<a name="ln5953"> * This function converts an incoming trap specification string from a vault</a>
<a name="ln5954"> * into a trap_spec.</a>
<a name="ln5955"> *</a>
<a name="ln5956"> * @param s       The string to be parsed.</a>
<a name="ln5957"> * @param weight  The weight of this string.</a>
<a name="ln5958"> * @return        A feature_spec with the contained, parsed trap_spec stored via</a>
<a name="ln5959"> *                unique_ptr as feature_spec-&gt;trap.</a>
<a name="ln5960">**/</a>
<a name="ln5961">feature_spec keyed_mapspec::parse_trap(string s, int weight)</a>
<a name="ln5962">{</a>
<a name="ln5963">    strip_tag(s, &quot;trap&quot;);</a>
<a name="ln5964">    // All traps are known, strip this tag for compatibility</a>
<a name="ln5965">    strip_tag(s, &quot;known&quot;);</a>
<a name="ln5966"> </a>
<a name="ln5967">    trim_string(s);</a>
<a name="ln5968">    lowercase(s);</a>
<a name="ln5969"> </a>
<a name="ln5970">    const int trap = str_to_trap(s);</a>
<a name="ln5971">    if (trap == -1)</a>
<a name="ln5972">        err = make_stringf(&quot;bad trap name: '%s'&quot;, s.c_str());</a>
<a name="ln5973"> </a>
<a name="ln5974">    feature_spec fspec(1, weight);</a>
<a name="ln5975">    fspec.trap.reset(new trap_spec(static_cast&lt;trap_type&gt;(trap)));</a>
<a name="ln5976">    return fspec;</a>
<a name="ln5977">}</a>
<a name="ln5978"> </a>
<a name="ln5979">/**</a>
<a name="ln5980"> * Convert a shop string into a shop_spec.</a>
<a name="ln5981"> *</a>
<a name="ln5982"> * This function converts an incoming shop specification string from a vault</a>
<a name="ln5983"> * into a shop_spec.</a>
<a name="ln5984"> *</a>
<a name="ln5985"> * @param s        The string to be parsed.</a>
<a name="ln5986"> * @param weight   The weight of this string.</a>
<a name="ln5987"> * @param mimic    What kind of mimic (if any) to set for this shop.</a>
<a name="ln5988"> * @param no_mimic Whether to prohibit mimics altogether for this shop.</a>
<a name="ln5989"> * @return         A feature_spec with the contained, parsed shop_spec stored</a>
<a name="ln5990"> *                 via unique_ptr as feature_spec-&gt;shop.</a>
<a name="ln5991">**/</a>
<a name="ln5992">feature_spec keyed_mapspec::parse_shop(string s, int weight, int mimic,</a>
<a name="ln5993">                                       bool no_mimic)</a>
<a name="ln5994">{</a>
<a name="ln5995">    string orig(s);</a>
<a name="ln5996"> </a>
<a name="ln5997">    strip_tag(s, &quot;shop&quot;);</a>
<a name="ln5998">    trim_string(s);</a>
<a name="ln5999"> </a>
<a name="ln6000">    bool use_all = strip_tag(s, &quot;use_all&quot;);</a>
<a name="ln6001"> </a>
<a name="ln6002">    const bool gozag = strip_tag(s, &quot;gozag&quot;);</a>
<a name="ln6003"> </a>
<a name="ln6004">    string shop_name = replace_all_of(strip_tag_prefix(s, &quot;name:&quot;), &quot;_&quot;, &quot; &quot;);</a>
<a name="ln6005">    string shop_type_name = replace_all_of(strip_tag_prefix(s, &quot;type:&quot;),</a>
<a name="ln6006">                                           &quot;_&quot;, &quot; &quot;);</a>
<a name="ln6007">    string shop_suffix_name = replace_all_of(strip_tag_prefix(s, &quot;suffix:&quot;),</a>
<a name="ln6008">                                             &quot;_&quot;, &quot; &quot;);</a>
<a name="ln6009"> </a>
<a name="ln6010">    int num_items = min(20, strip_number_tag(s, &quot;count:&quot;));</a>
<a name="ln6011">    if (num_items == TAG_UNFOUND)</a>
<a name="ln6012">        num_items = -1;</a>
<a name="ln6013"> </a>
<a name="ln6014">    int greed = strip_number_tag(s, &quot;greed:&quot;);</a>
<a name="ln6015">    if (greed == TAG_UNFOUND)</a>
<a name="ln6016">        greed = -1;</a>
<a name="ln6017"> </a>
<a name="ln6018">    vector&lt;string&gt; parts = split_string(&quot;;&quot;, s);</a>
<a name="ln6019">    string main_part = parts[0];</a>
<a name="ln6020"> </a>
<a name="ln6021">    const shop_type shop = str_to_shoptype(main_part);</a>
<a name="ln6022">    if (shop == SHOP_UNASSIGNED)</a>
<a name="ln6023">        err = make_stringf(&quot;bad shop type: '%s'&quot;, s.c_str());</a>
<a name="ln6024"> </a>
<a name="ln6025">    if (parts.size() &gt; 2)</a>
<a name="ln6026">        err = make_stringf(&quot;too many semi-colons for '%s' spec&quot;, orig.c_str());</a>
<a name="ln6027"> </a>
<a name="ln6028">    item_list items;</a>
<a name="ln6029">    if (err.empty() &amp;&amp; parts.size() == 2)</a>
<a name="ln6030">    {</a>
<a name="ln6031">        string item_list = parts[1];</a>
<a name="ln6032">        vector&lt;string&gt; str_items = split_string(&quot;|&quot;, item_list);</a>
<a name="ln6033">        for (const string &amp;si : str_items)</a>
<a name="ln6034">        {</a>
<a name="ln6035">            err = items.add_item(si);</a>
<a name="ln6036">            if (!err.empty())</a>
<a name="ln6037">                break;</a>
<a name="ln6038">        }</a>
<a name="ln6039">    }</a>
<a name="ln6040"> </a>
<a name="ln6041">    feature_spec fspec(-1, weight, mimic, no_mimic);</a>
<a name="ln6042">    fspec.shop.reset(new shop_spec(shop, shop_name, shop_type_name,</a>
<a name="ln6043">                                   shop_suffix_name, greed,</a>
<a name="ln6044">                                   num_items, use_all, gozag));</a>
<a name="ln6045">    fspec.shop-&gt;items = items;</a>
<a name="ln6046">    return fspec;</a>
<a name="ln6047">}</a>
<a name="ln6048"> </a>
<a name="ln6049">feature_spec_list keyed_mapspec::parse_feature(const string &amp;str)</a>
<a name="ln6050">{</a>
<a name="ln6051">    string s = str;</a>
<a name="ln6052">    int weight = find_weight(s);</a>
<a name="ln6053">    if (weight == TAG_UNFOUND || weight &lt;= 0)</a>
<a name="ln6054">        weight = 10;</a>
<a name="ln6055"> </a>
<a name="ln6056">    int mimic = strip_number_tag(s, &quot;mimic:&quot;);</a>
<a name="ln6057">    if (mimic == TAG_UNFOUND &amp;&amp; strip_tag(s, &quot;mimic&quot;))</a>
<a name="ln6058">        mimic = 1;</a>
<a name="ln6059">    const bool no_mimic = strip_tag(s, &quot;no_mimic&quot;);</a>
<a name="ln6060"> </a>
<a name="ln6061">    trim_string(s);</a>
<a name="ln6062"> </a>
<a name="ln6063">    feature_spec_list list;</a>
<a name="ln6064">    if (s.length() == 1)</a>
<a name="ln6065">    {</a>
<a name="ln6066">        feature_spec fsp(-1, weight, mimic, no_mimic);</a>
<a name="ln6067">        fsp.glyph = s[0];</a>
<a name="ln6068">        list.push_back(fsp);</a>
<a name="ln6069">    }</a>
<a name="ln6070">    else if (strip_tag(s, &quot;trap&quot;) || s == &quot;web&quot;)</a>
<a name="ln6071">        list.push_back(parse_trap(s, weight));</a>
<a name="ln6072">    else if (strip_tag(s, &quot;shop&quot;))</a>
<a name="ln6073">        list.push_back(parse_shop(s, weight, mimic, no_mimic));</a>
<a name="ln6074">    else if (auto ftype = dungeon_feature_by_name(s)) // DNGN_UNSEEN == 0</a>
<a name="ln6075">        list.emplace_back(ftype, weight, mimic, no_mimic);</a>
<a name="ln6076">    else</a>
<a name="ln6077">        err = make_stringf(&quot;no features matching \&quot;%s\&quot;&quot;, str.c_str());</a>
<a name="ln6078"> </a>
<a name="ln6079">    return list;</a>
<a name="ln6080">}</a>
<a name="ln6081"> </a>
<a name="ln6082">string keyed_mapspec::set_mons(const string &amp;s, bool fix)</a>
<a name="ln6083">{</a>
<a name="ln6084">    err.clear();</a>
<a name="ln6085">    mons.clear();</a>
<a name="ln6086"> </a>
<a name="ln6087">    for (const string &amp;segment : split_string(&quot;,&quot;, s))</a>
<a name="ln6088">    {</a>
<a name="ln6089">        const string error = mons.add_mons(segment, fix);</a>
<a name="ln6090">        if (!error.empty())</a>
<a name="ln6091">            return error;</a>
<a name="ln6092">    }</a>
<a name="ln6093"> </a>
<a name="ln6094">    return &quot;&quot;;</a>
<a name="ln6095">}</a>
<a name="ln6096"> </a>
<a name="ln6097">string keyed_mapspec::set_item(const string &amp;s, bool fix)</a>
<a name="ln6098">{</a>
<a name="ln6099">    err.clear();</a>
<a name="ln6100">    item.clear();</a>
<a name="ln6101"> </a>
<a name="ln6102">    for (const string &amp;seg : split_string(&quot;,&quot;, s))</a>
<a name="ln6103">    {</a>
<a name="ln6104">        err = item.add_item(seg, fix);</a>
<a name="ln6105">        if (!err.empty())</a>
<a name="ln6106">            return err;</a>
<a name="ln6107">    }</a>
<a name="ln6108"> </a>
<a name="ln6109">    return err;</a>
<a name="ln6110">}</a>
<a name="ln6111"> </a>
<a name="ln6112">string keyed_mapspec::set_mask(const string &amp;s, bool /*garbage*/)</a>
<a name="ln6113">{</a>
<a name="ln6114">    err.clear();</a>
<a name="ln6115"> </a>
<a name="ln6116">    try</a>
<a name="ln6117">    {</a>
<a name="ln6118">        // Be sure to change the order of map_mask_type to match!</a>
<a name="ln6119">        static string flag_list[] =</a>
<a name="ln6120">            {&quot;vault&quot;, &quot;no_item_gen&quot;, &quot;no_monster_gen&quot;, &quot;no_pool_fixup&quot;,</a>
<a name="ln6121">             &quot;UNUSED&quot;,</a>
<a name="ln6122">             &quot;no_wall_fixup&quot;, &quot;opaque&quot;, &quot;no_trap_gen&quot;, &quot;&quot;};</a>
<a name="ln6123">        map_mask |= map_flags::parse(flag_list, s);</a>
<a name="ln6124">    }</a>
<a name="ln6125">    catch (const bad_map_flag &amp;error)</a>
<a name="ln6126">    {</a>
<a name="ln6127">        err = make_stringf(&quot;Unknown flag: '%s'&quot;, error.what());</a>
<a name="ln6128">    }</a>
<a name="ln6129"> </a>
<a name="ln6130">    return err;</a>
<a name="ln6131">}</a>
<a name="ln6132"> </a>
<a name="ln6133">void keyed_mapspec::copy_mons(const keyed_mapspec &amp;spec)</a>
<a name="ln6134">{</a>
<a name="ln6135">    mons = spec.mons;</a>
<a name="ln6136">}</a>
<a name="ln6137"> </a>
<a name="ln6138">void keyed_mapspec::copy_item(const keyed_mapspec &amp;spec)</a>
<a name="ln6139">{</a>
<a name="ln6140">    item = spec.item;</a>
<a name="ln6141">}</a>
<a name="ln6142"> </a>
<a name="ln6143">void keyed_mapspec::copy_mask(const keyed_mapspec &amp;spec)</a>
<a name="ln6144">{</a>
<a name="ln6145">    map_mask = spec.map_mask;</a>
<a name="ln6146">}</a>
<a name="ln6147"> </a>
<a name="ln6148">feature_spec keyed_mapspec::get_feat()</a>
<a name="ln6149">{</a>
<a name="ln6150">    return feat.get_feat('.');</a>
<a name="ln6151">}</a>
<a name="ln6152"> </a>
<a name="ln6153">mons_list &amp;keyed_mapspec::get_monsters()</a>
<a name="ln6154">{</a>
<a name="ln6155">    return mons;</a>
<a name="ln6156">}</a>
<a name="ln6157"> </a>
<a name="ln6158">item_list &amp;keyed_mapspec::get_items()</a>
<a name="ln6159">{</a>
<a name="ln6160">    return item;</a>
<a name="ln6161">}</a>
<a name="ln6162"> </a>
<a name="ln6163">map_flags &amp;keyed_mapspec::get_mask()</a>
<a name="ln6164">{</a>
<a name="ln6165">    return map_mask;</a>
<a name="ln6166">}</a>
<a name="ln6167"> </a>
<a name="ln6168">bool keyed_mapspec::replaces_glyph()</a>
<a name="ln6169">{</a>
<a name="ln6170">    return !(mons.empty() &amp;&amp; item.empty() &amp;&amp; feat.feats.empty());</a>
<a name="ln6171">}</a>
<a name="ln6172"> </a>
<a name="ln6173">//////////////////////////////////////////////////////////////////////////</a>
<a name="ln6174">// feature_spec and feature_slot</a>
<a name="ln6175"> </a>
<a name="ln6176">feature_spec::feature_spec()</a>
<a name="ln6177">{</a>
<a name="ln6178">    genweight = 0;</a>
<a name="ln6179">    feat = 0;</a>
<a name="ln6180">    glyph = -1;</a>
<a name="ln6181">    shop.reset(nullptr);</a>
<a name="ln6182">    trap.reset(nullptr);</a>
<a name="ln6183">    mimic = 0;</a>
<a name="ln6184">    no_mimic = false;</a>
<a name="ln6185">}</a>
<a name="ln6186"> </a>
<a name="ln6187">feature_spec::feature_spec(int f, int wt, int _mimic, bool _no_mimic)</a>
<a name="ln6188">{</a>
<a name="ln6189">    genweight = wt;</a>
<a name="ln6190">    feat = f;</a>
<a name="ln6191">    glyph = -1;</a>
<a name="ln6192">    shop.reset(nullptr);</a>
<a name="ln6193">    trap.reset(nullptr);</a>
<a name="ln6194">    mimic = _mimic;</a>
<a name="ln6195">    no_mimic = _no_mimic;</a>
<a name="ln6196">}</a>
<a name="ln6197"> </a>
<a name="ln6198">feature_spec::feature_spec(const feature_spec &amp;other)</a>
<a name="ln6199">{</a>
<a name="ln6200">    init_with(other);</a>
<a name="ln6201">}</a>
<a name="ln6202"> </a>
<a name="ln6203">feature_spec&amp; feature_spec::operator = (const feature_spec&amp; other)</a>
<a name="ln6204">{</a>
<a name="ln6205">    if (this != &amp;other)</a>
<a name="ln6206">        init_with(other);</a>
<a name="ln6207">    return *this;</a>
<a name="ln6208">}</a>
<a name="ln6209"> </a>
<a name="ln6210">void feature_spec::init_with(const feature_spec&amp; other)</a>
<a name="ln6211">{</a>
<a name="ln6212">    genweight = other.genweight;</a>
<a name="ln6213">    feat = other.feat;</a>
<a name="ln6214">    glyph = other.glyph;</a>
<a name="ln6215">    mimic = other.mimic;</a>
<a name="ln6216">    no_mimic = other.no_mimic;</a>
<a name="ln6217"> </a>
<a name="ln6218">    if (other.trap)</a>
<a name="ln6219">        trap.reset(new trap_spec(*other.trap));</a>
<a name="ln6220">    else</a>
<a name="ln6221">        trap.reset(nullptr);</a>
<a name="ln6222"> </a>
<a name="ln6223">    if (other.shop)</a>
<a name="ln6224">        shop.reset(new shop_spec(*other.shop));</a>
<a name="ln6225">    else</a>
<a name="ln6226">        shop.reset(nullptr);</a>
<a name="ln6227">}</a>
<a name="ln6228"> </a>
<a name="ln6229">feature_slot::feature_slot() : feats(), fix_slot(false)</a>
<a name="ln6230">{</a>
<a name="ln6231">}</a>
<a name="ln6232"> </a>
<a name="ln6233">feature_spec feature_slot::get_feat(int def_glyph)</a>
<a name="ln6234">{</a>
<a name="ln6235">    int tweight = 0;</a>
<a name="ln6236">    feature_spec chosen_feat = feature_spec(DNGN_FLOOR);</a>
<a name="ln6237"> </a>
<a name="ln6238">    if (def_glyph != -1)</a>
<a name="ln6239">    {</a>
<a name="ln6240">        chosen_feat.feat = -1;</a>
<a name="ln6241">        chosen_feat.glyph = def_glyph;</a>
<a name="ln6242">    }</a>
<a name="ln6243"> </a>
<a name="ln6244">    for (const feature_spec &amp;feat : feats)</a>
<a name="ln6245">        if (x_chance_in_y(feat.genweight, tweight += feat.genweight))</a>
<a name="ln6246">            chosen_feat = feat;</a>
<a name="ln6247"> </a>
<a name="ln6248">    if (fix_slot)</a>
<a name="ln6249">    {</a>
<a name="ln6250">        feats.clear();</a>
<a name="ln6251">        feats.push_back(chosen_feat);</a>
<a name="ln6252">    }</a>
<a name="ln6253">    return chosen_feat;</a>
<a name="ln6254">}</a>

</code></pre>
<div class="balloon" rel="227"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v794/" target="_blank">V794</a> The assignment operator should be protected from the case of 'this == &place'.</p></div>
<div class="balloon" rel="432"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v648/" target="_blank">V648</a> Priority of the '&&' operation is higher than that of the '||' operation.</p></div>
<div class="balloon" rel="1707"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v547/" target="_blank">V547</a> Expression '!overlay' is always false.</p></div>
<div class="balloon" rel="1712"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v547/" target="_blank">V547</a> Expression '!key' is always false.</p></div>
<div class="balloon" rel="1727"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v547/" target="_blank">V547</a> Expression '!overlay' is always false.</p></div>
<div class="balloon" rel="1732"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v547/" target="_blank">V547</a> Expression '!key' is always false.</p></div>
<div class="balloon" rel="4361"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v1048/" target="_blank">V1048</a> The 'nheads' variable was assigned the same value.</p></div>
<div class="balloon" rel="5884"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v629/" target="_blank">V629</a> Consider inspecting the '1 << i' expression. Bit shifting of the 32-bit value with a subsequent expansion to the 64-bit type.</p></div>
<div class="balloon" rel="460"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v730/" target="_blank">V730</a> Not all members of a class are initialized inside the constructor. Consider inspecting: next_keyspec_idx.</p></div>
<div class="balloon" rel="467"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v730/" target="_blank">V730</a> It is possible that not all members of a class are initialized inside the constructor. Consider inspecting: next_keyspec_idx.</p></div>
<div class="balloon" rel="2195"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v730/" target="_blank">V730</a> It is possible that not all members of a class are initialized inside the constructor. Consider inspecting: original.</p></div>

<link rel="stylesheet" href="highlight.css">
<script src="highlight.pack.js"></script>
<script src="highlightjs-line-numbers.js"></script>
<script>hljs.initHighlightingOnLoad();</script>
<script>hljs.initLineNumbersOnLoad();</script>
<script>
  $(document).ready(function() {
      $('.balloon').each(function () {
          var bl = $(this);
          var line = bl.attr('rel');
          var text = $('a[name="ln'+line+'"]').text();

          var space_count = 0;
          for(var i = 0; i<text.length; i++){
              var char = text[i];
              if((char !== ' ')&&(char !== '\t'))break;
              if(char === '\t')space_count++;
              space_count++;
          }

          bl.css('margin-left', space_count*8);
          $('a[name="ln'+line+'"]').after(bl);
      });

      window.location = window.location;
  });
</script>
</body>
</html>
