
<html>
<head>

  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
  <title>describe.cc</title>

  <link rel="stylesheet" href="../style.css"/>
  <script src="../jquery-3.2.1.min.js"></script>
</head>
<body>

<pre><code class = "cpp">
<a name="ln1">/**</a>
<a name="ln2"> * @file</a>
<a name="ln3"> * @brief Functions used to print information about various game objects.</a>
<a name="ln4">**/</a>
<a name="ln5"> </a>
<a name="ln6">#include &quot;AppHdr.h&quot;</a>
<a name="ln7"> </a>
<a name="ln8">#include &quot;describe.h&quot;</a>
<a name="ln9"> </a>
<a name="ln10">#include &lt;algorithm&gt;</a>
<a name="ln11">#include &lt;cstdio&gt;</a>
<a name="ln12">#include &lt;cmath&gt;</a>
<a name="ln13">#include &lt;iomanip&gt;</a>
<a name="ln14">#include &lt;numeric&gt;</a>
<a name="ln15">#include &lt;set&gt;</a>
<a name="ln16">#include &lt;sstream&gt;</a>
<a name="ln17">#include &lt;string&gt;</a>
<a name="ln18"> </a>
<a name="ln19">#include &quot;ability.h&quot;</a>
<a name="ln20">#include &quot;adjust.h&quot;</a>
<a name="ln21">#include &quot;areas.h&quot;</a>
<a name="ln22">#include &quot;art-enum.h&quot;</a>
<a name="ln23">#include &quot;artefact.h&quot;</a>
<a name="ln24">#include &quot;branch.h&quot;</a>
<a name="ln25">#include &quot;cloud.h&quot; // cloud_type_name</a>
<a name="ln26">#include &quot;clua.h&quot;</a>
<a name="ln27">#include &quot;colour.h&quot;</a>
<a name="ln28">#include &quot;database.h&quot;</a>
<a name="ln29">#include &quot;dbg-util.h&quot;</a>
<a name="ln30">#include &quot;decks.h&quot;</a>
<a name="ln31">#include &quot;delay.h&quot;</a>
<a name="ln32">#include &quot;describe-spells.h&quot;</a>
<a name="ln33">#include &quot;directn.h&quot;</a>
<a name="ln34">#include &quot;english.h&quot;</a>
<a name="ln35">#include &quot;env.h&quot;</a>
<a name="ln36">#include &quot;evoke.h&quot;</a>
<a name="ln37">#include &quot;fight.h&quot;</a>
<a name="ln38">#include &quot;food.h&quot;</a>
<a name="ln39">#include &quot;ghost.h&quot;</a>
<a name="ln40">#include &quot;god-abil.h&quot;</a>
<a name="ln41">#include &quot;god-item.h&quot;</a>
<a name="ln42">#include &quot;hints.h&quot;</a>
<a name="ln43">#include &quot;invent.h&quot;</a>
<a name="ln44">#include &quot;item-prop.h&quot;</a>
<a name="ln45">#include &quot;item-status-flag-type.h&quot;</a>
<a name="ln46">#include &quot;items.h&quot;</a>
<a name="ln47">#include &quot;item-use.h&quot;</a>
<a name="ln48">#include &quot;jobs.h&quot;</a>
<a name="ln49">#include &quot;lang-fake.h&quot;</a>
<a name="ln50">#include &quot;libutil.h&quot;</a>
<a name="ln51">#include &quot;macro.h&quot;</a>
<a name="ln52">#include &quot;message.h&quot;</a>
<a name="ln53">#include &quot;mon-cast.h&quot; // mons_spell_range</a>
<a name="ln54">#include &quot;mon-death.h&quot;</a>
<a name="ln55">#include &quot;mon-tentacle.h&quot;</a>
<a name="ln56">#include &quot;output.h&quot;</a>
<a name="ln57">#include &quot;religion.h&quot;</a>
<a name="ln58">#include &quot;skills.h&quot;</a>
<a name="ln59">#include &quot;species.h&quot;</a>
<a name="ln60">#include &quot;spl-cast.h&quot;</a>
<a name="ln61">#include &quot;spl-book.h&quot;</a>
<a name="ln62">#include &quot;spl-miscast.h&quot;</a>
<a name="ln63">#include &quot;spl-summoning.h&quot;</a>
<a name="ln64">#include &quot;spl-util.h&quot;</a>
<a name="ln65">#include &quot;spl-wpnench.h&quot;</a>
<a name="ln66">#include &quot;stash.h&quot;</a>
<a name="ln67">#include &quot;state.h&quot;</a>
<a name="ln68">#include &quot;stringutil.h&quot; // to_string on Cygwin</a>
<a name="ln69">#include &quot;terrain.h&quot;</a>
<a name="ln70">#ifdef USE_TILE_LOCAL</a>
<a name="ln71"> #include &quot;tilereg-crt.h&quot;</a>
<a name="ln72"> #include &quot;rltiles/tiledef-dngn.h&quot;</a>
<a name="ln73">#endif</a>
<a name="ln74">#ifdef USE_TILE</a>
<a name="ln75"> #include &quot;rltiles/tiledef-feat.h&quot;</a>
<a name="ln76"> #include &quot;tilepick.h&quot;</a>
<a name="ln77"> #include &quot;tileview.h&quot;</a>
<a name="ln78"> #include &quot;tile-flags.h&quot;</a>
<a name="ln79">#endif</a>
<a name="ln80">#include &quot;transform.h&quot;</a>
<a name="ln81">#include &quot;unicode.h&quot;</a>
<a name="ln82"> </a>
<a name="ln83">using namespace ui;</a>
<a name="ln84"> </a>
<a name="ln85">int count_desc_lines(const string &amp;_desc, const int width)</a>
<a name="ln86">{</a>
<a name="ln87">    string desc = get_linebreak_string(_desc, width);</a>
<a name="ln88">    return count(begin(desc), end(desc), '\n');</a>
<a name="ln89">}</a>
<a name="ln90"> </a>
<a name="ln91">int show_description(const string &amp;body, const tile_def *tile)</a>
<a name="ln92">{</a>
<a name="ln93">    describe_info inf;</a>
<a name="ln94">    inf.body &lt;&lt; body;</a>
<a name="ln95">    return show_description(inf, tile);</a>
<a name="ln96">}</a>
<a name="ln97"> </a>
<a name="ln98">int show_description(const describe_info &amp;inf, const tile_def *tile)</a>
<a name="ln99">{</a>
<a name="ln100">    auto vbox = make_shared&lt;Box&gt;(Widget::VERT);</a>
<a name="ln101"> </a>
<a name="ln102">    if (!inf.title.empty())</a>
<a name="ln103">    {</a>
<a name="ln104">        auto title_hbox = make_shared&lt;Box&gt;(Widget::HORZ);</a>
<a name="ln105"> </a>
<a name="ln106">#ifdef USE_TILE</a>
<a name="ln107">        if (tile)</a>
<a name="ln108">        {</a>
<a name="ln109">            auto icon = make_shared&lt;Image&gt;();</a>
<a name="ln110">            icon-&gt;set_tile(*tile);</a>
<a name="ln111">            icon-&gt;set_margin_for_sdl(0, 10, 0, 0);</a>
<a name="ln112">            title_hbox-&gt;add_child(move(icon));</a>
<a name="ln113">        }</a>
<a name="ln114">#else</a>
<a name="ln115">        UNUSED(tile);</a>
<a name="ln116">#endif</a>
<a name="ln117"> </a>
<a name="ln118">        auto title = make_shared&lt;Text&gt;(inf.title);</a>
<a name="ln119">        title_hbox-&gt;add_child(move(title));</a>
<a name="ln120"> </a>
<a name="ln121">        title_hbox-&gt;set_cross_alignment(Widget::CENTER);</a>
<a name="ln122">        title_hbox-&gt;set_margin_for_sdl(0, 0, 20, 0);</a>
<a name="ln123">        title_hbox-&gt;set_margin_for_crt(0, 0, 1, 0);</a>
<a name="ln124">        vbox-&gt;add_child(move(title_hbox));</a>
<a name="ln125">    }</a>
<a name="ln126"> </a>
<a name="ln127">    auto desc_sw = make_shared&lt;Switcher&gt;();</a>
<a name="ln128">    auto more_sw = make_shared&lt;Switcher&gt;();</a>
<a name="ln129">    desc_sw-&gt;current() = 0;</a>
<a name="ln130">    more_sw-&gt;current() = 0;</a>
<a name="ln131"> </a>
<a name="ln132">    const string descs[2] =  {</a>
<a name="ln133">        trimmed_string(process_description(inf, false)),</a>
<a name="ln134">        trimmed_string(inf.quote),</a>
<a name="ln135">    };</a>
<a name="ln136"> </a>
<a name="ln137">#ifdef USE_TILE_LOCAL</a>
<a name="ln138"># define MORE_PREFIX &quot;[&lt;w&gt;!&lt;/w&gt;&quot; &quot;|&lt;w&gt;Right-click&lt;/w&gt;&quot; &quot;]: &quot;</a>
<a name="ln139">#else</a>
<a name="ln140"># define MORE_PREFIX &quot;[&lt;w&gt;!&lt;/w&gt;&quot; &quot;]: &quot;</a>
<a name="ln141">#endif</a>
<a name="ln142"> </a>
<a name="ln143">    const char* mores[2] = {</a>
<a name="ln144">        MORE_PREFIX &quot;&lt;w&gt;Description&lt;/w&gt;|Quote&quot;,</a>
<a name="ln145">        MORE_PREFIX &quot;Description|&lt;w&gt;Quote&lt;/w&gt;&quot;,</a>
<a name="ln146">    };</a>
<a name="ln147"> </a>
<a name="ln148">    for (int i = 0; i &lt; (inf.quote.empty() ? 1 : 2); i++)</a>
<a name="ln149">    {</a>
<a name="ln150">        const auto &amp;desc = descs[static_cast&lt;int&gt;(i)];</a>
<a name="ln151">        auto scroller = make_shared&lt;Scroller&gt;();</a>
<a name="ln152">        auto fs = formatted_string::parse_string(trimmed_string(desc));</a>
<a name="ln153">        auto text = make_shared&lt;Text&gt;(fs);</a>
<a name="ln154">        text-&gt;set_wrap_text(true);</a>
<a name="ln155">        scroller-&gt;set_child(text);</a>
<a name="ln156">        desc_sw-&gt;add_child(move(scroller));</a>
<a name="ln157">        more_sw-&gt;add_child(make_shared&lt;Text&gt;(</a>
<a name="ln158">                formatted_string::parse_string(mores[i])));</a>
<a name="ln159">    }</a>
<a name="ln160"> </a>
<a name="ln161">    more_sw-&gt;set_margin_for_sdl(20, 0, 0, 0);</a>
<a name="ln162">    more_sw-&gt;set_margin_for_crt(1, 0, 0, 0);</a>
<a name="ln163">    desc_sw-&gt;expand_h = false;</a>
<a name="ln164">    desc_sw-&gt;align_x = Widget::STRETCH;</a>
<a name="ln165">    vbox-&gt;add_child(desc_sw);</a>
<a name="ln166">    if (!inf.quote.empty())</a>
<a name="ln167">        vbox-&gt;add_child(more_sw);</a>
<a name="ln168"> </a>
<a name="ln169">#ifdef USE_TILE_LOCAL</a>
<a name="ln170">    vbox-&gt;max_size().width = tiles.get_crt_font()-&gt;char_width()*80;</a>
<a name="ln171">#endif</a>
<a name="ln172"> </a>
<a name="ln173">    auto popup = make_shared&lt;ui::Popup&gt;(vbox);</a>
<a name="ln174"> </a>
<a name="ln175">    bool done = false;</a>
<a name="ln176">    int lastch;</a>
<a name="ln177">    popup-&gt;on_keydown_event([&amp;](const KeyEvent&amp; ev) {</a>
<a name="ln178">        lastch = ev.key();</a>
<a name="ln179">        if (!inf.quote.empty() &amp;&amp; (lastch == '!' || lastch == CK_MOUSE_CMD || lastch == '^'))</a>
<a name="ln180">            desc_sw-&gt;current() = more_sw-&gt;current() = 1 - desc_sw-&gt;current();</a>
<a name="ln181">        else</a>
<a name="ln182">            done = !desc_sw-&gt;current_widget()-&gt;on_event(ev);</a>
<a name="ln183">        return true;</a>
<a name="ln184">    });</a>
<a name="ln185"> </a>
<a name="ln186">#ifdef USE_TILE_WEB</a>
<a name="ln187">    tiles.json_open_object();</a>
<a name="ln188">    if (tile)</a>
<a name="ln189">    {</a>
<a name="ln190">        tiles.json_open_object(&quot;tile&quot;);</a>
<a name="ln191">        tiles.json_write_int(&quot;t&quot;, tile-&gt;tile);</a>
<a name="ln192">        tiles.json_write_int(&quot;tex&quot;, tile-&gt;tex);</a>
<a name="ln193">        if (tile-&gt;ymax != TILE_Y)</a>
<a name="ln194">            tiles.json_write_int(&quot;ymax&quot;, tile-&gt;ymax);</a>
<a name="ln195">        tiles.json_close_object();</a>
<a name="ln196">    }</a>
<a name="ln197">    tiles.json_write_string(&quot;title&quot;, inf.title);</a>
<a name="ln198">    tiles.json_write_string(&quot;prefix&quot;, inf.prefix);</a>
<a name="ln199">    tiles.json_write_string(&quot;suffix&quot;, inf.suffix);</a>
<a name="ln200">    tiles.json_write_string(&quot;footer&quot;, inf.footer);</a>
<a name="ln201">    tiles.json_write_string(&quot;quote&quot;, inf.quote);</a>
<a name="ln202">    tiles.json_write_string(&quot;body&quot;, inf.body.str());</a>
<a name="ln203">    tiles.push_ui_layout(&quot;describe-generic&quot;, 0);</a>
<a name="ln204">    popup-&gt;on_layout_pop([](){ tiles.pop_ui_layout(); });</a>
<a name="ln205">#endif</a>
<a name="ln206"> </a>
<a name="ln207">    ui::run_layout(move(popup), done);</a>
<a name="ln208"> </a>
<a name="ln209">    return lastch;</a>
<a name="ln210">}</a>
<a name="ln211"> </a>
<a name="ln212">string process_description(const describe_info &amp;inf, bool include_title)</a>
<a name="ln213">{</a>
<a name="ln214">    string desc;</a>
<a name="ln215">    if (!inf.prefix.empty())</a>
<a name="ln216">        desc += &quot;\n\n&quot; + trimmed_string(filtered_lang(inf.prefix));</a>
<a name="ln217">    if (!inf.title.empty() &amp;&amp; include_title)</a>
<a name="ln218">        desc += &quot;\n\n&quot; + trimmed_string(filtered_lang(inf.title));</a>
<a name="ln219">    desc += &quot;\n\n&quot; + trimmed_string(filtered_lang(inf.body.str()));</a>
<a name="ln220">    if (!inf.suffix.empty())</a>
<a name="ln221">        desc += &quot;\n\n&quot; + trimmed_string(filtered_lang(inf.suffix));</a>
<a name="ln222">    if (!inf.footer.empty())</a>
<a name="ln223">        desc += &quot;\n\n&quot; + trimmed_string(filtered_lang(inf.footer));</a>
<a name="ln224">    trim_string(desc);</a>
<a name="ln225">    return desc;</a>
<a name="ln226">}</a>
<a name="ln227"> </a>
<a name="ln228">const char* jewellery_base_ability_string(int subtype)</a>
<a name="ln229">{</a>
<a name="ln230">    switch (subtype)</a>
<a name="ln231">    {</a>
<a name="ln232">#if TAG_MAJOR_VERSION == 34</a>
<a name="ln233">    case RING_SUSTAIN_ATTRIBUTES: return &quot;SustAt&quot;;</a>
<a name="ln234">#endif</a>
<a name="ln235">    case RING_WIZARDRY:           return &quot;Wiz&quot;;</a>
<a name="ln236">    case RING_FIRE:               return &quot;Fire&quot;;</a>
<a name="ln237">    case RING_ICE:                return &quot;Ice&quot;;</a>
<a name="ln238">    case RING_TELEPORTATION:      return &quot;*Tele&quot;;</a>
<a name="ln239">#if TAG_MAJOR_VERSION == 34</a>
<a name="ln240">    case RING_TELEPORT_CONTROL:   return &quot;+cTele&quot;;</a>
<a name="ln241">#endif</a>
<a name="ln242">    case AMU_HARM:                return &quot;Harm&quot;;</a>
<a name="ln243">    case AMU_MANA_REGENERATION:   return &quot;RegenMP&quot;;</a>
<a name="ln244">    case AMU_THE_GOURMAND:        return &quot;Gourm&quot;;</a>
<a name="ln245">    case AMU_ACROBAT:             return &quot;Acrobat&quot;;</a>
<a name="ln246">#if TAG_MAJOR_VERSION == 34</a>
<a name="ln247">    case AMU_CONSERVATION:        return &quot;Cons&quot;;</a>
<a name="ln248">    case AMU_CONTROLLED_FLIGHT:   return &quot;cFly&quot;;</a>
<a name="ln249">#endif</a>
<a name="ln250">    case AMU_GUARDIAN_SPIRIT:     return &quot;Spirit&quot;;</a>
<a name="ln251">    case AMU_FAITH:               return &quot;Faith&quot;;</a>
<a name="ln252">    case AMU_REFLECTION:          return &quot;Reflect&quot;;</a>
<a name="ln253">    case AMU_INACCURACY:          return &quot;Inacc&quot;;</a>
<a name="ln254">    }</a>
<a name="ln255">    return &quot;&quot;;</a>
<a name="ln256">}</a>
<a name="ln257"> </a>
<a name="ln258">#define known_proprt(prop) (proprt[(prop)] &amp;&amp; known[(prop)])</a>
<a name="ln259"> </a>
<a name="ln260">/// How to display props of a given type?</a>
<a name="ln261">enum class prop_note</a>
<a name="ln262">{</a>
<a name="ln263">    /// The raw numeral; e.g &quot;Slay+3&quot;, &quot;Int-1&quot;</a>
<a name="ln264">    numeral,</a>
<a name="ln265">    /// Plusses and minuses; &quot;rF-&quot;, &quot;rC++&quot;</a>
<a name="ln266">    symbolic,</a>
<a name="ln267">    /// Don't note the number; e.g. &quot;rMut&quot;</a>
<a name="ln268">    plain,</a>
<a name="ln269">};</a>
<a name="ln270"> </a>
<a name="ln271">struct property_annotators</a>
<a name="ln272">{</a>
<a name="ln273">    artefact_prop_type prop;</a>
<a name="ln274">    prop_note spell_out;</a>
<a name="ln275">};</a>
<a name="ln276"> </a>
<a name="ln277">static vector&lt;string&gt; _randart_propnames(const item_def&amp; item,</a>
<a name="ln278">                                         bool no_comma = false)</a>
<a name="ln279">{</a>
<a name="ln280">    artefact_properties_t  proprt;</a>
<a name="ln281">    artefact_known_props_t known;</a>
<a name="ln282">    artefact_desc_properties(item, proprt, known);</a>
<a name="ln283"> </a>
<a name="ln284">    vector&lt;string&gt; propnames;</a>
<a name="ln285"> </a>
<a name="ln286">    // list the following in rough order of importance</a>
<a name="ln287">    const property_annotators propanns[] =</a>
<a name="ln288">    {</a>
<a name="ln289">        // (Generally) negative attributes</a>
<a name="ln290">        // These come first, so they don't get chopped off!</a>
<a name="ln291">        { ARTP_PREVENT_SPELLCASTING,  prop_note::plain },</a>
<a name="ln292">        { ARTP_PREVENT_TELEPORTATION, prop_note::plain },</a>
<a name="ln293">        { ARTP_CONTAM,                prop_note::plain },</a>
<a name="ln294">        { ARTP_ANGRY,                 prop_note::plain },</a>
<a name="ln295">        { ARTP_CAUSE_TELEPORTATION,   prop_note::plain },</a>
<a name="ln296">        { ARTP_NOISE,                 prop_note::plain },</a>
<a name="ln297">        { ARTP_HARM,                  prop_note::plain },</a>
<a name="ln298">        { ARTP_CORRODE,               prop_note::plain },</a>
<a name="ln299">        { ARTP_DRAIN,                 prop_note::plain },</a>
<a name="ln300">        { ARTP_SLOW,                  prop_note::plain },</a>
<a name="ln301">        { ARTP_FRAGILE,               prop_note::plain },</a>
<a name="ln302"> </a>
<a name="ln303">        // Evokable abilities come second</a>
<a name="ln304">        { ARTP_BLINK,                 prop_note::plain },</a>
<a name="ln305">        { ARTP_BERSERK,               prop_note::plain },</a>
<a name="ln306">        { ARTP_INVISIBLE,             prop_note::plain },</a>
<a name="ln307">        { ARTP_FLY,                   prop_note::plain },</a>
<a name="ln308"> </a>
<a name="ln309">        // Resists, also really important</a>
<a name="ln310">        { ARTP_ELECTRICITY,           prop_note::plain },</a>
<a name="ln311">        { ARTP_POISON,                prop_note::plain },</a>
<a name="ln312">        { ARTP_FIRE,                  prop_note::symbolic },</a>
<a name="ln313">        { ARTP_COLD,                  prop_note::symbolic },</a>
<a name="ln314">        { ARTP_NEGATIVE_ENERGY,       prop_note::symbolic },</a>
<a name="ln315">        { ARTP_MAGIC_RESISTANCE,      prop_note::symbolic },</a>
<a name="ln316">        { ARTP_REGENERATION,          prop_note::symbolic },</a>
<a name="ln317">        { ARTP_RMUT,                  prop_note::plain },</a>
<a name="ln318">        { ARTP_RCORR,                 prop_note::plain },</a>
<a name="ln319"> </a>
<a name="ln320">        // Quantitative attributes</a>
<a name="ln321">        { ARTP_HP,                    prop_note::numeral },</a>
<a name="ln322">        { ARTP_MAGICAL_POWER,         prop_note::numeral },</a>
<a name="ln323">        { ARTP_AC,                    prop_note::numeral },</a>
<a name="ln324">        { ARTP_EVASION,               prop_note::numeral },</a>
<a name="ln325">        { ARTP_STRENGTH,              prop_note::numeral },</a>
<a name="ln326">        { ARTP_INTELLIGENCE,          prop_note::numeral },</a>
<a name="ln327">        { ARTP_DEXTERITY,             prop_note::numeral },</a>
<a name="ln328">        { ARTP_SLAYING,               prop_note::numeral },</a>
<a name="ln329">        { ARTP_SHIELDING,             prop_note::numeral },</a>
<a name="ln330"> </a>
<a name="ln331">        // Qualitative attributes (and Stealth)</a>
<a name="ln332">        { ARTP_SEE_INVISIBLE,         prop_note::plain },</a>
<a name="ln333">        { ARTP_STEALTH,               prop_note::symbolic },</a>
<a name="ln334">        { ARTP_CURSE,                 prop_note::plain },</a>
<a name="ln335">        { ARTP_CLARITY,               prop_note::plain },</a>
<a name="ln336">        { ARTP_RMSL,                  prop_note::plain },</a>
<a name="ln337">    };</a>
<a name="ln338"> </a>
<a name="ln339">    const unrandart_entry *entry = nullptr;</a>
<a name="ln340">    if (is_unrandom_artefact(item))</a>
<a name="ln341">        entry = get_unrand_entry(item.unrand_idx);</a>
<a name="ln342"> </a>
<a name="ln343">    // For randart jewellery, note the base jewellery type if it's not</a>
<a name="ln344">    // covered by artefact_desc_properties()</a>
<a name="ln345">    if (item.base_type == OBJ_JEWELLERY</a>
<a name="ln346">        &amp;&amp; (item_ident(item, ISFLAG_KNOW_TYPE)))</a>
<a name="ln347">    {</a>
<a name="ln348">        const char* type = jewellery_base_ability_string(item.sub_type);</a>
<a name="ln349">        if (*type)</a>
<a name="ln350">            propnames.push_back(type);</a>
<a name="ln351">    }</a>
<a name="ln352">    else if (item_brand_known(item)</a>
<a name="ln353">             &amp;&amp; !(is_unrandom_artefact(item) &amp;&amp; entry</a>
<a name="ln354">                  &amp;&amp; entry-&gt;flags &amp; UNRAND_FLAG_SKIP_EGO))</a>
<a name="ln355">    {</a>
<a name="ln356">        string ego;</a>
<a name="ln357">        if (item.base_type == OBJ_WEAPONS)</a>
<a name="ln358">            ego = weapon_brand_name(item, true);</a>
<a name="ln359">        else if (item.base_type == OBJ_ARMOUR)</a>
<a name="ln360">            ego = armour_ego_name(item, true);</a>
<a name="ln361">        if (!ego.empty())</a>
<a name="ln362">        {</a>
<a name="ln363">            // XXX: Ugly hack for adding a comma if needed.</a>
<a name="ln364">            bool extra_props = false;</a>
<a name="ln365">            for (const property_annotators &amp;ann : propanns)</a>
<a name="ln366">                if (known_proprt(ann.prop) &amp;&amp; ann.prop != ARTP_BRAND)</a>
<a name="ln367">                {</a>
<a name="ln368">                    extra_props = true;</a>
<a name="ln369">                    break;</a>
<a name="ln370">                }</a>
<a name="ln371"> </a>
<a name="ln372">            if (!no_comma &amp;&amp; extra_props</a>
<a name="ln373">                || is_unrandom_artefact(item)</a>
<a name="ln374">                   &amp;&amp; entry &amp;&amp; entry-&gt;inscrip != nullptr)</a>
<a name="ln375">            {</a>
<a name="ln376">                ego += &quot;,&quot;;</a>
<a name="ln377">            }</a>
<a name="ln378"> </a>
<a name="ln379">            propnames.push_back(ego);</a>
<a name="ln380">        }</a>
<a name="ln381">    }</a>
<a name="ln382"> </a>
<a name="ln383">    if (is_unrandom_artefact(item) &amp;&amp; entry &amp;&amp; entry-&gt;inscrip != nullptr)</a>
<a name="ln384">        propnames.push_back(entry-&gt;inscrip);</a>
<a name="ln385"> </a>
<a name="ln386">    for (const property_annotators &amp;ann : propanns)</a>
<a name="ln387">    {</a>
<a name="ln388">        if (known_proprt(ann.prop))</a>
<a name="ln389">        {</a>
<a name="ln390">            const int val = proprt[ann.prop];</a>
<a name="ln391"> </a>
<a name="ln392">            // Don't show rF+/rC- for =Fire, or vice versa for =Ice.</a>
<a name="ln393">            if (item.base_type == OBJ_JEWELLERY)</a>
<a name="ln394">            {</a>
<a name="ln395">                if (item.sub_type == RING_FIRE</a>
<a name="ln396">                    &amp;&amp; (ann.prop == ARTP_FIRE &amp;&amp; val == 1</a>
<a name="ln397">                        || ann.prop == ARTP_COLD &amp;&amp; val == -1))</a>
<a name="ln398">                {</a>
<a name="ln399">                    continue;</a>
<a name="ln400">                }</a>
<a name="ln401">                if (item.sub_type == RING_ICE</a>
<a name="ln402">                    &amp;&amp; (ann.prop == ARTP_COLD &amp;&amp; val == 1</a>
<a name="ln403">                        || ann.prop == ARTP_FIRE &amp;&amp; val == -1))</a>
<a name="ln404">                {</a>
<a name="ln405">                    continue;</a>
<a name="ln406">                }</a>
<a name="ln407">            }</a>
<a name="ln408"> </a>
<a name="ln409">            ostringstream work;</a>
<a name="ln410">            switch (ann.spell_out)</a>
<a name="ln411">            {</a>
<a name="ln412">            case prop_note::numeral: // e.g. AC+4</a>
<a name="ln413">                work &lt;&lt; showpos &lt;&lt; artp_name(ann.prop) &lt;&lt; val;</a>
<a name="ln414">                break;</a>
<a name="ln415">            case prop_note::symbolic: // e.g. F++</a>
<a name="ln416">            {</a>
<a name="ln417">                work &lt;&lt; artp_name(ann.prop);</a>
<a name="ln418"> </a>
<a name="ln419">                char symbol = val &gt; 0 ? '+' : '-';</a>
<a name="ln420">                const int sval = abs(val);</a>
<a name="ln421">                if (sval &gt; 4)</a>
<a name="ln422">                    work &lt;&lt; symbol &lt;&lt; sval;</a>
<a name="ln423">                else</a>
<a name="ln424">                    work &lt;&lt; string(sval, symbol);</a>
<a name="ln425"> </a>
<a name="ln426">                break;</a>
<a name="ln427">            }</a>
<a name="ln428">            case prop_note::plain: // e.g. rPois or SInv</a>
<a name="ln429">                work &lt;&lt; artp_name(ann.prop);</a>
<a name="ln430">                break;</a>
<a name="ln431">            }</a>
<a name="ln432">            propnames.push_back(work.str());</a>
<a name="ln433">        }</a>
<a name="ln434">    }</a>
<a name="ln435"> </a>
<a name="ln436">    return propnames;</a>
<a name="ln437">}</a>
<a name="ln438"> </a>
<a name="ln439">string artefact_inscription(const item_def&amp; item)</a>
<a name="ln440">{</a>
<a name="ln441">    if (item.base_type == OBJ_BOOKS)</a>
<a name="ln442">        return &quot;&quot;;</a>
<a name="ln443"> </a>
<a name="ln444">    const vector&lt;string&gt; propnames = _randart_propnames(item);</a>
<a name="ln445"> </a>
<a name="ln446">    string insc = comma_separated_line(propnames.begin(), propnames.end(),</a>
<a name="ln447">                                       &quot; &quot;, &quot; &quot;);</a>
<a name="ln448">    if (!insc.empty() &amp;&amp; insc[insc.length() - 1] == ',')</a>
<a name="ln449">        insc.erase(insc.length() - 1);</a>
<a name="ln450">    return insc;</a>
<a name="ln451">}</a>
<a name="ln452"> </a>
<a name="ln453">void add_inscription(item_def &amp;item, string inscrip)</a>
<a name="ln454">{</a>
<a name="ln455">    if (!item.inscription.empty())</a>
<a name="ln456">    {</a>
<a name="ln457">        if (ends_with(item.inscription, &quot;,&quot;))</a>
<a name="ln458">            item.inscription += &quot; &quot;;</a>
<a name="ln459">        else</a>
<a name="ln460">            item.inscription += &quot;, &quot;;</a>
<a name="ln461">    }</a>
<a name="ln462"> </a>
<a name="ln463">    item.inscription += inscrip;</a>
<a name="ln464">}</a>
<a name="ln465"> </a>
<a name="ln466">static const char* _jewellery_base_ability_description(int subtype)</a>
<a name="ln467">{</a>
<a name="ln468">    switch (subtype)</a>
<a name="ln469">    {</a>
<a name="ln470">#if TAG_MAJOR_VERSION == 34</a>
<a name="ln471">    case RING_SUSTAIN_ATTRIBUTES:</a>
<a name="ln472">        return &quot;It sustains your strength, intelligence and dexterity.&quot;;</a>
<a name="ln473">#endif</a>
<a name="ln474">    case RING_WIZARDRY:</a>
<a name="ln475">        return &quot;It improves your spell success rate.&quot;;</a>
<a name="ln476">    case RING_FIRE:</a>
<a name="ln477">        return &quot;It enhances your fire magic.&quot;;</a>
<a name="ln478">    case RING_ICE:</a>
<a name="ln479">        return &quot;It enhances your ice magic.&quot;;</a>
<a name="ln480">    case RING_TELEPORTATION:</a>
<a name="ln481">        return &quot;It may teleport you next to monsters.&quot;;</a>
<a name="ln482">#if TAG_MAJOR_VERSION == 34</a>
<a name="ln483">    case RING_TELEPORT_CONTROL:</a>
<a name="ln484">        return &quot;It can be evoked for teleport control.&quot;;</a>
<a name="ln485">#endif</a>
<a name="ln486">    case AMU_HARM:</a>
<a name="ln487">        return &quot;It increases damage dealt and taken.&quot;;</a>
<a name="ln488">    case AMU_MANA_REGENERATION:</a>
<a name="ln489">        return &quot;It increases your magic regeneration.&quot;;</a>
<a name="ln490">    case AMU_THE_GOURMAND:</a>
<a name="ln491">        return &quot;It allows you to eat raw meat even when not hungry.&quot;;</a>
<a name="ln492">    case AMU_ACROBAT:</a>
<a name="ln493">        return &quot;It helps you evade while moving and waiting.&quot;;</a>
<a name="ln494">#if TAG_MAJOR_VERSION == 34</a>
<a name="ln495">    case AMU_CONSERVATION:</a>
<a name="ln496">        return &quot;It protects your inventory from destruction.&quot;;</a>
<a name="ln497">#endif</a>
<a name="ln498">    case AMU_GUARDIAN_SPIRIT:</a>
<a name="ln499">        return &quot;It causes incoming damage to be split between your health and &quot;</a>
<a name="ln500">               &quot;magic.&quot;;</a>
<a name="ln501">    case AMU_FAITH:</a>
<a name="ln502">        return &quot;It allows you to gain divine favour quickly.&quot;;</a>
<a name="ln503">    case AMU_REFLECTION:</a>
<a name="ln504">        return &quot;It shields you and reflects attacks.&quot;;</a>
<a name="ln505">    case AMU_INACCURACY:</a>
<a name="ln506">        return &quot;It reduces the accuracy of all your attacks.&quot;;</a>
<a name="ln507">    }</a>
<a name="ln508">    return &quot;&quot;;</a>
<a name="ln509">}</a>
<a name="ln510"> </a>
<a name="ln511">struct property_descriptor</a>
<a name="ln512">{</a>
<a name="ln513">    artefact_prop_type property;</a>
<a name="ln514">    const char* desc;           // If it contains %d, will be replaced by value.</a>
<a name="ln515">    bool is_graded_resist;</a>
<a name="ln516">};</a>
<a name="ln517"> </a>
<a name="ln518">static string _randart_descrip(const item_def &amp;item)</a>
<a name="ln519">{</a>
<a name="ln520">    string description;</a>
<a name="ln521"> </a>
<a name="ln522">    artefact_properties_t  proprt;</a>
<a name="ln523">    artefact_known_props_t known;</a>
<a name="ln524">    artefact_desc_properties(item, proprt, known);</a>
<a name="ln525"> </a>
<a name="ln526">    const property_descriptor propdescs[] =</a>
<a name="ln527">    {</a>
<a name="ln528">        { ARTP_AC, &quot;It affects your AC (%d).&quot;, false },</a>
<a name="ln529">        { ARTP_EVASION, &quot;It affects your evasion (%d).&quot;, false},</a>
<a name="ln530">        { ARTP_STRENGTH, &quot;It affects your strength (%d).&quot;, false},</a>
<a name="ln531">        { ARTP_INTELLIGENCE, &quot;It affects your intelligence (%d).&quot;, false},</a>
<a name="ln532">        { ARTP_DEXTERITY, &quot;It affects your dexterity (%d).&quot;, false},</a>
<a name="ln533">        { ARTP_SLAYING, &quot;It affects your accuracy and damage with ranged &quot;</a>
<a name="ln534">                        &quot;weapons and melee attacks (%d).&quot;, false},</a>
<a name="ln535">        { ARTP_FIRE, &quot;fire&quot;, true},</a>
<a name="ln536">        { ARTP_COLD, &quot;cold&quot;, true},</a>
<a name="ln537">        { ARTP_ELECTRICITY, &quot;It insulates you from electricity.&quot;, false},</a>
<a name="ln538">        { ARTP_POISON, &quot;poison&quot;, true},</a>
<a name="ln539">        { ARTP_NEGATIVE_ENERGY, &quot;negative energy&quot;, true},</a>
<a name="ln540">        { ARTP_MAGIC_RESISTANCE, &quot;It affects your resistance to hostile &quot;</a>
<a name="ln541">                                 &quot;enchantments.&quot;, false},</a>
<a name="ln542">        { ARTP_HP, &quot;It affects your health (%d).&quot;, false},</a>
<a name="ln543">        { ARTP_MAGICAL_POWER, &quot;It affects your magic capacity (%d).&quot;, false},</a>
<a name="ln544">        { ARTP_SEE_INVISIBLE, &quot;It lets you see invisible.&quot;, false},</a>
<a name="ln545">        { ARTP_INVISIBLE, &quot;It lets you turn invisible.&quot;, false},</a>
<a name="ln546">        { ARTP_FLY, &quot;It lets you fly.&quot;, false},</a>
<a name="ln547">        { ARTP_BLINK, &quot;It lets you blink.&quot;, false},</a>
<a name="ln548">        { ARTP_BERSERK, &quot;It lets you go berserk.&quot;, false},</a>
<a name="ln549">        { ARTP_NOISE, &quot;It may make noises in combat.&quot;, false},</a>
<a name="ln550">        { ARTP_PREVENT_SPELLCASTING, &quot;It prevents spellcasting.&quot;, false},</a>
<a name="ln551">        { ARTP_CAUSE_TELEPORTATION, &quot;It may teleport you next to monsters.&quot;, false},</a>
<a name="ln552">        { ARTP_PREVENT_TELEPORTATION, &quot;It prevents most forms of teleportation.&quot;,</a>
<a name="ln553">          false},</a>
<a name="ln554">        { ARTP_ANGRY,  &quot;It may make you go berserk in combat.&quot;, false},</a>
<a name="ln555">        { ARTP_CURSE, &quot;It curses itself when equipped.&quot;, false},</a>
<a name="ln556">        { ARTP_CLARITY, &quot;It protects you against confusion.&quot;, false},</a>
<a name="ln557">        { ARTP_CONTAM, &quot;It causes magical contamination when unequipped.&quot;, false},</a>
<a name="ln558">        { ARTP_RMSL, &quot;It protects you from missiles.&quot;, false},</a>
<a name="ln559">        { ARTP_REGENERATION, &quot;It increases your rate of regeneration.&quot;, false},</a>
<a name="ln560">        { ARTP_RCORR, &quot;It provides partial protection from all sources of acid and corrosion.&quot;,</a>
<a name="ln561">          false},</a>
<a name="ln562">        { ARTP_RMUT, &quot;It protects you from mutation.&quot;, false},</a>
<a name="ln563">        { ARTP_CORRODE, &quot;It may corrode you when you take damage.&quot;, false},</a>
<a name="ln564">        { ARTP_DRAIN, &quot;It causes draining when unequipped.&quot;, false},</a>
<a name="ln565">        { ARTP_SLOW, &quot;It may slow you when you take damage.&quot;, false},</a>
<a name="ln566">        { ARTP_FRAGILE, &quot;It will be destroyed if unequipped.&quot;, false },</a>
<a name="ln567">        { ARTP_SHIELDING, &quot;It affects your SH (%d).&quot;, false},</a>
<a name="ln568">        { ARTP_HARM, &quot;It increases damage dealt and taken.&quot;, false},</a>
<a name="ln569">    };</a>
<a name="ln570"> </a>
<a name="ln571">    // Give a short description of the base type, for base types with no</a>
<a name="ln572">    // corresponding ARTP.</a>
<a name="ln573">    if (item.base_type == OBJ_JEWELLERY</a>
<a name="ln574">        &amp;&amp; (item_ident(item, ISFLAG_KNOW_TYPE)))</a>
<a name="ln575">    {</a>
<a name="ln576">        const char* type = _jewellery_base_ability_description(item.sub_type);</a>
<a name="ln577">        if (*type)</a>
<a name="ln578">        {</a>
<a name="ln579">            description += &quot;\n&quot;;</a>
<a name="ln580">            description += type;</a>
<a name="ln581">        }</a>
<a name="ln582">    }</a>
<a name="ln583"> </a>
<a name="ln584">    for (const property_descriptor &amp;desc : propdescs)</a>
<a name="ln585">    {</a>
<a name="ln586">        if (known_proprt(desc.property))</a>
<a name="ln587">        {</a>
<a name="ln588">            string sdesc = desc.desc;</a>
<a name="ln589"> </a>
<a name="ln590">            // FIXME Not the nicest hack.</a>
<a name="ln591">            char buf[80];</a>
<a name="ln592">            snprintf(buf, sizeof buf, &quot;%+d&quot;, proprt[desc.property]);</a>
<a name="ln593">            sdesc = replace_all(sdesc, &quot;%d&quot;, buf);</a>
<a name="ln594"> </a>
<a name="ln595">            if (desc.is_graded_resist)</a>
<a name="ln596">            {</a>
<a name="ln597">                int idx = proprt[desc.property] + 3;</a>
<a name="ln598">                idx = min(idx, 6);</a>
<a name="ln599">                idx = max(idx, 0);</a>
<a name="ln600"> </a>
<a name="ln601">                const char* prefixes[] =</a>
<a name="ln602">                {</a>
<a name="ln603">                    &quot;It makes you extremely vulnerable to &quot;,</a>
<a name="ln604">                    &quot;It makes you very vulnerable to &quot;,</a>
<a name="ln605">                    &quot;It makes you vulnerable to &quot;,</a>
<a name="ln606">                    &quot;Buggy descriptor!&quot;,</a>
<a name="ln607">                    &quot;It protects you from &quot;,</a>
<a name="ln608">                    &quot;It greatly protects you from &quot;,</a>
<a name="ln609">                    &quot;It renders you almost immune to &quot;</a>
<a name="ln610">                };</a>
<a name="ln611">                sdesc = prefixes[idx] + sdesc + '.';</a>
<a name="ln612">            }</a>
<a name="ln613"> </a>
<a name="ln614">            description += '\n';</a>
<a name="ln615">            description += sdesc;</a>
<a name="ln616">        }</a>
<a name="ln617">    }</a>
<a name="ln618"> </a>
<a name="ln619">    if (known_proprt(ARTP_STEALTH))</a>
<a name="ln620">    {</a>
<a name="ln621">        const int stval = proprt[ARTP_STEALTH];</a>
<a name="ln622">        char buf[80];</a>
<a name="ln623">        snprintf(buf, sizeof buf, &quot;\nIt makes you %s%s stealthy.&quot;,</a>
<a name="ln624">                 (stval &lt; -1 || stval &gt; 1) ? &quot;much &quot; : &quot;&quot;,</a>
<a name="ln625">                 (stval &lt; 0) ? &quot;less&quot; : &quot;more&quot;);</a>
<a name="ln626">        description += buf;</a>
<a name="ln627">    }</a>
<a name="ln628"> </a>
<a name="ln629">    return description;</a>
<a name="ln630">}</a>
<a name="ln631">#undef known_proprt</a>
<a name="ln632"> </a>
<a name="ln633">static const char *trap_names[] =</a>
<a name="ln634">{</a>
<a name="ln635">    &quot;dart&quot;,</a>
<a name="ln636">    &quot;arrow&quot;, &quot;spear&quot;,</a>
<a name="ln637">#if TAG_MAJOR_VERSION &gt; 34</a>
<a name="ln638">    &quot;dispersal&quot;,</a>
<a name="ln639">    &quot;teleport&quot;,</a>
<a name="ln640">#endif</a>
<a name="ln641">    &quot;permanent teleport&quot;,</a>
<a name="ln642">    &quot;alarm&quot;, &quot;blade&quot;,</a>
<a name="ln643">    &quot;bolt&quot;, &quot;net&quot;, &quot;Zot&quot;,</a>
<a name="ln644">#if TAG_MAJOR_VERSION == 34</a>
<a name="ln645">    &quot;needle&quot;,</a>
<a name="ln646">#endif</a>
<a name="ln647">    &quot;shaft&quot;, &quot;passage&quot;, &quot;pressure plate&quot;, &quot;web&quot;,</a>
<a name="ln648">#if TAG_MAJOR_VERSION == 34</a>
<a name="ln649">    &quot;gas&quot;, &quot;teleport&quot;,</a>
<a name="ln650">    &quot;shadow&quot;, &quot;dormant shadow&quot;, &quot;dispersal&quot;</a>
<a name="ln651">#endif</a>
<a name="ln652">};</a>
<a name="ln653"> </a>
<a name="ln654">string trap_name(trap_type trap)</a>
<a name="ln655">{</a>
<a name="ln656">    COMPILE_CHECK(ARRAYSZ(trap_names) == NUM_TRAPS);</a>
<a name="ln657"> </a>
<a name="ln658">    if (trap &gt;= 0 &amp;&amp; trap &lt; NUM_TRAPS)</a>
<a name="ln659">        return trap_names[trap];</a>
<a name="ln660">    return &quot;&quot;;</a>
<a name="ln661">}</a>
<a name="ln662"> </a>
<a name="ln663">string full_trap_name(trap_type trap)</a>
<a name="ln664">{</a>
<a name="ln665">    string basename = trap_name(trap);</a>
<a name="ln666">    switch (trap)</a>
<a name="ln667">    {</a>
<a name="ln668">    case TRAP_GOLUBRIA:</a>
<a name="ln669">        return basename + &quot; of Golubria&quot;;</a>
<a name="ln670">    case TRAP_PLATE:</a>
<a name="ln671">    case TRAP_WEB:</a>
<a name="ln672">    case TRAP_SHAFT:</a>
<a name="ln673">        return basename;</a>
<a name="ln674">    default:</a>
<a name="ln675">        return basename + &quot; trap&quot;;</a>
<a name="ln676">    }</a>
<a name="ln677">}</a>
<a name="ln678"> </a>
<a name="ln679">int str_to_trap(const string &amp;s)</a>
<a name="ln680">{</a>
<a name="ln681">    // &quot;Zot trap&quot; is capitalised in trap_names[], but the other trap</a>
<a name="ln682">    // names aren't.</a>
<a name="ln683">    const string tspec = lowercase_string(s);</a>
<a name="ln684"> </a>
<a name="ln685">    // allow a couple of synonyms</a>
<a name="ln686">    if (tspec == &quot;random&quot; || tspec == &quot;any&quot;)</a>
<a name="ln687">        return TRAP_RANDOM;</a>
<a name="ln688"> </a>
<a name="ln689">    for (int i = 0; i &lt; NUM_TRAPS; ++i)</a>
<a name="ln690">        if (tspec == lowercase_string(trap_names[i]))</a>
<a name="ln691">            return i;</a>
<a name="ln692"> </a>
<a name="ln693">    return -1;</a>
<a name="ln694">}</a>
<a name="ln695"> </a>
<a name="ln696">/**</a>
<a name="ln697"> * How should this panlord be described?</a>
<a name="ln698"> *</a>
<a name="ln699"> * @param name   The panlord's name; used as a seed for its appearance.</a>
<a name="ln700"> * @param flying Whether the panlord can fly.</a>
<a name="ln701"> * @returns a string including a description of its head, its body, its flight</a>
<a name="ln702"> *          mode (if any), and how it smells or looks.</a>
<a name="ln703"> */</a>
<a name="ln704">static string _describe_demon(const string&amp; name, bool flying)</a>
<a name="ln705">{</a>
<a name="ln706">    const uint32_t seed = hash32(&amp;name[0], name.size());</a>
<a name="ln707">    #define HRANDOM_ELEMENT(arr, id) arr[hash_with_seed(ARRAYSZ(arr), seed, id)]</a>
<a name="ln708"> </a>
<a name="ln709">    static const char* body_types[] =</a>
<a name="ln710">    {</a>
<a name="ln711">        &quot;armoured&quot;,</a>
<a name="ln712">        &quot;vast, spindly&quot;,</a>
<a name="ln713">        &quot;fat&quot;,</a>
<a name="ln714">        &quot;obese&quot;,</a>
<a name="ln715">        &quot;muscular&quot;,</a>
<a name="ln716">        &quot;spiked&quot;,</a>
<a name="ln717">        &quot;splotchy&quot;,</a>
<a name="ln718">        &quot;slender&quot;,</a>
<a name="ln719">        &quot;tentacled&quot;,</a>
<a name="ln720">        &quot;emaciated&quot;,</a>
<a name="ln721">        &quot;bug-like&quot;,</a>
<a name="ln722">        &quot;skeletal&quot;,</a>
<a name="ln723">        &quot;mantis&quot;,</a>
<a name="ln724">    };</a>
<a name="ln725"> </a>
<a name="ln726">    static const char* wing_names[] =</a>
<a name="ln727">    {</a>
<a name="ln728">        &quot;with small, bat-like wings&quot;,</a>
<a name="ln729">        &quot;with bony wings&quot;,</a>
<a name="ln730">        &quot;with sharp, metallic wings&quot;,</a>
<a name="ln731">        &quot;with the wings of a moth&quot;,</a>
<a name="ln732">        &quot;with thin, membranous wings&quot;,</a>
<a name="ln733">        &quot;with dragonfly wings&quot;,</a>
<a name="ln734">        &quot;with large, powerful wings&quot;,</a>
<a name="ln735">        &quot;with fluttering wings&quot;,</a>
<a name="ln736">        &quot;with great, sinister wings&quot;,</a>
<a name="ln737">        &quot;with hideous, tattered wings&quot;,</a>
<a name="ln738">        &quot;with sparrow-like wings&quot;,</a>
<a name="ln739">        &quot;with hooked wings&quot;,</a>
<a name="ln740">        &quot;with strange knobs attached&quot;,</a>
<a name="ln741">        &quot;which hovers in mid-air&quot;,</a>
<a name="ln742">        &quot;with sacs of gas hanging from its back&quot;,</a>
<a name="ln743">    };</a>
<a name="ln744"> </a>
<a name="ln745">    const char* head_names[] =</a>
<a name="ln746">    {</a>
<a name="ln747">        &quot;a cubic structure in place of a head&quot;,</a>
<a name="ln748">        &quot;a brain for a head&quot;,</a>
<a name="ln749">        &quot;a hideous tangle of tentacles for a mouth&quot;,</a>
<a name="ln750">        &quot;the head of an elephant&quot;,</a>
<a name="ln751">        &quot;an eyeball for a head&quot;,</a>
<a name="ln752">        &quot;wears a helmet over its head&quot;,</a>
<a name="ln753">        &quot;a horn in place of a head&quot;,</a>
<a name="ln754">        &quot;a thick, horned head&quot;,</a>
<a name="ln755">        &quot;the head of a horse&quot;,</a>
<a name="ln756">        &quot;a vicious glare&quot;,</a>
<a name="ln757">        &quot;snakes for hair&quot;,</a>
<a name="ln758">        &quot;the face of a baboon&quot;,</a>
<a name="ln759">        &quot;the head of a mouse&quot;,</a>
<a name="ln760">        &quot;a ram's head&quot;,</a>
<a name="ln761">        &quot;the head of a rhino&quot;,</a>
<a name="ln762">        &quot;eerily human features&quot;,</a>
<a name="ln763">        &quot;a gigantic mouth&quot;,</a>
<a name="ln764">        &quot;a mass of tentacles growing from its neck&quot;,</a>
<a name="ln765">        &quot;a thin, worm-like head&quot;,</a>
<a name="ln766">        &quot;huge, compound eyes&quot;,</a>
<a name="ln767">        &quot;the head of a frog&quot;,</a>
<a name="ln768">        &quot;an insectoid head&quot;,</a>
<a name="ln769">        &quot;a great mass of hair&quot;,</a>
<a name="ln770">        &quot;a skull for a head&quot;,</a>
<a name="ln771">        &quot;a cow's skull for a head&quot;,</a>
<a name="ln772">        &quot;the head of a bird&quot;,</a>
<a name="ln773">        &quot;a large fungus growing from its neck&quot;,</a>
<a name="ln774">    };</a>
<a name="ln775"> </a>
<a name="ln776">    static const char* misc_descs[] =</a>
<a name="ln777">    {</a>
<a name="ln778">        &quot; It seethes with hatred of the living.&quot;,</a>
<a name="ln779">        &quot; Tiny orange flames dance around it.&quot;,</a>
<a name="ln780">        &quot; Tiny purple flames dance around it.&quot;,</a>
<a name="ln781">        &quot; It is surrounded by a weird haze.&quot;,</a>
<a name="ln782">        &quot; It glows with a malevolent light.&quot;,</a>
<a name="ln783">        &quot; It looks incredibly angry.&quot;,</a>
<a name="ln784">        &quot; It oozes with slime.&quot;,</a>
<a name="ln785">        &quot; It dribbles constantly.&quot;,</a>
<a name="ln786">        &quot; Mould grows all over it.&quot;,</a>
<a name="ln787">        &quot; Its body is covered in fungus.&quot;,</a>
<a name="ln788">        &quot; It is covered with lank hair.&quot;,</a>
<a name="ln789">        &quot; It looks diseased.&quot;,</a>
<a name="ln790">        &quot; It looks as frightened of you as you are of it.&quot;,</a>
<a name="ln791">        &quot; It moves in a series of hideous convulsions.&quot;,</a>
<a name="ln792">        &quot; It moves with an unearthly grace.&quot;,</a>
<a name="ln793">        &quot; It leaves a glistening oily trail.&quot;,</a>
<a name="ln794">        &quot; It shimmers before your eyes.&quot;,</a>
<a name="ln795">        &quot; It is surrounded by a brilliant glow.&quot;,</a>
<a name="ln796">        &quot; It radiates an aura of extreme power.&quot;,</a>
<a name="ln797">        &quot; It seems utterly heartbroken.&quot;,</a>
<a name="ln798">        &quot; It seems filled with irrepressible glee.&quot;,</a>
<a name="ln799">        &quot; It constantly shivers and twitches.&quot;,</a>
<a name="ln800">        &quot; Blue sparks crawl across its body.&quot;,</a>
<a name="ln801">        &quot; It seems uncertain.&quot;,</a>
<a name="ln802">        &quot; A cloud of flies swarms around it.&quot;,</a>
<a name="ln803">        &quot; The air around it ripples with heat.&quot;,</a>
<a name="ln804">        &quot; Crystalline structures grow on everything near it.&quot;,</a>
<a name="ln805">        &quot; It appears supremely confident.&quot;,</a>
<a name="ln806">        &quot; Its skin is covered in a network of cracks.&quot;,</a>
<a name="ln807">        &quot; Its skin has a disgusting oily sheen.&quot;,</a>
<a name="ln808">        &quot; It seems somehow familiar.&quot;,</a>
<a name="ln809">        &quot; It is somehow always in shadow.&quot;,</a>
<a name="ln810">        &quot; It is difficult to look away.&quot;,</a>
<a name="ln811">        &quot; It is constantly speaking in tongues.&quot;,</a>
<a name="ln812">        &quot; It babbles unendingly.&quot;,</a>
<a name="ln813">        &quot; Its body is scourged by damnation.&quot;,</a>
<a name="ln814">        &quot; Its body is extensively scarred.&quot;,</a>
<a name="ln815">        &quot; You find it difficult to look away.&quot;,</a>
<a name="ln816">    };</a>
<a name="ln817"> </a>
<a name="ln818">    static const char* smell_descs[] =</a>
<a name="ln819">    {</a>
<a name="ln820">        &quot; It smells of brimstone.&quot;,</a>
<a name="ln821">        &quot; It is surrounded by a sickening stench.&quot;,</a>
<a name="ln822">        &quot; It smells of rotting flesh.&quot;,</a>
<a name="ln823">        &quot; It stinks of death.&quot;,</a>
<a name="ln824">        &quot; It stinks of decay.&quot;,</a>
<a name="ln825">        &quot; It smells delicious!&quot;,</a>
<a name="ln826">    };</a>
<a name="ln827"> </a>
<a name="ln828">    ostringstream description;</a>
<a name="ln829">    description &lt;&lt; &quot;One of the many lords of Pandemonium, &quot; &lt;&lt; name &lt;&lt; &quot; has &quot;;</a>
<a name="ln830"> </a>
<a name="ln831">    description &lt;&lt; article_a(HRANDOM_ELEMENT(body_types, 2));</a>
<a name="ln832">    description &lt;&lt; &quot; body &quot;;</a>
<a name="ln833"> </a>
<a name="ln834">    if (flying)</a>
<a name="ln835">    {</a>
<a name="ln836">        description &lt;&lt; HRANDOM_ELEMENT(wing_names, 3);</a>
<a name="ln837">        description &lt;&lt; &quot; &quot;;</a>
<a name="ln838">    }</a>
<a name="ln839"> </a>
<a name="ln840">    description &lt;&lt; &quot;and &quot;;</a>
<a name="ln841">    description &lt;&lt; HRANDOM_ELEMENT(head_names, 1) &lt;&lt; &quot;.&quot;;</a>
<a name="ln842"> </a>
<a name="ln843">    if (!hash_with_seed(5, seed, 4) &amp;&amp; you.can_smell()) // 20%</a>
<a name="ln844">        description &lt;&lt; HRANDOM_ELEMENT(smell_descs, 5);</a>
<a name="ln845"> </a>
<a name="ln846">    if (hash_with_seed(2, seed, 6)) // 50%</a>
<a name="ln847">        description &lt;&lt; HRANDOM_ELEMENT(misc_descs, 6);</a>
<a name="ln848"> </a>
<a name="ln849">    return description.str();</a>
<a name="ln850">}</a>
<a name="ln851"> </a>
<a name="ln852">/**</a>
<a name="ln853"> * Describe a given mutant beast's tier.</a>
<a name="ln854"> *</a>
<a name="ln855"> * @param tier      The mutant_beast_tier of the beast in question.</a>
<a name="ln856"> * @return          A string describing the tier; e.g.</a>
<a name="ln857"> *              &quot;It is a juvenile, out of the larval stage but still below its</a>
<a name="ln858"> *              mature strength.&quot;</a>
<a name="ln859"> */</a>
<a name="ln860">static string _describe_mutant_beast_tier(int tier)</a>
<a name="ln861">{</a>
<a name="ln862">    static const string tier_descs[] = {</a>
<a name="ln863">        &quot;It is of an unusually buggy age.&quot;,</a>
<a name="ln864">        &quot;It is larval and weak, freshly emerged from its mother's pouch.&quot;,</a>
<a name="ln865">        &quot;It is a juvenile, no longer larval but below its mature strength.&quot;,</a>
<a name="ln866">        &quot;It is mature, stronger than a juvenile but weaker than its elders.&quot;,</a>
<a name="ln867">        &quot;It is an elder, stronger than mature beasts.&quot;,</a>
<a name="ln868">        &quot;It is a primal beast, the most powerful of its kind.&quot;,</a>
<a name="ln869">    };</a>
<a name="ln870">    COMPILE_CHECK(ARRAYSZ(tier_descs) == NUM_BEAST_TIERS);</a>
<a name="ln871"> </a>
<a name="ln872">    ASSERT_RANGE(tier, 0, NUM_BEAST_TIERS);</a>
<a name="ln873">    return tier_descs[tier];</a>
<a name="ln874">}</a>
<a name="ln875"> </a>
<a name="ln876"> </a>
<a name="ln877">/**</a>
<a name="ln878"> * Describe a given mutant beast's facets.</a>
<a name="ln879"> *</a>
<a name="ln880"> * @param facets    A vector of the mutant_beast_facets in question.</a>
<a name="ln881"> * @return          A string describing the facets; e.g.</a>
<a name="ln882"> *              &quot;It flies and flits around unpredictably, and its breath</a>
<a name="ln883"> *               smoulders ominously.&quot;</a>
<a name="ln884"> */</a>
<a name="ln885">static string _describe_mutant_beast_facets(const CrawlVector &amp;facets)</a>
<a name="ln886">{</a>
<a name="ln887">    static const string facet_descs[] = {</a>
<a name="ln888">        &quot; seems unusually buggy.&quot;,</a>
<a name="ln889">        &quot; sports a set of venomous tails&quot;,</a>
<a name="ln890">        &quot; flies swiftly and unpredictably&quot;,</a>
<a name="ln891">        &quot;s breath smoulders ominously&quot;,</a>
<a name="ln892">        &quot; is covered with eyes and tentacles&quot;,</a>
<a name="ln893">        &quot; flickers and crackles with electricity&quot;,</a>
<a name="ln894">        &quot; is covered in dense fur and muscle&quot;,</a>
<a name="ln895">    };</a>
<a name="ln896">    COMPILE_CHECK(ARRAYSZ(facet_descs) == NUM_BEAST_FACETS);</a>
<a name="ln897"> </a>
<a name="ln898">    if (facets.size() == 0)</a>
<a name="ln899">        return &quot;&quot;;</a>
<a name="ln900"> </a>
<a name="ln901">    return &quot;It&quot; + comma_separated_fn(begin(facets), end(facets),</a>
<a name="ln902">                      [] (const CrawlStoreValue &amp;sv) -&gt; string {</a>
<a name="ln903">                          const int facet = sv.get_int();</a>
<a name="ln904">                          ASSERT_RANGE(facet, 0, NUM_BEAST_FACETS);</a>
<a name="ln905">                          return facet_descs[facet];</a>
<a name="ln906">                      }, &quot;, and it&quot;, &quot;, it&quot;)</a>
<a name="ln907">           + &quot;.&quot;;</a>
<a name="ln908"> </a>
<a name="ln909">}</a>
<a name="ln910"> </a>
<a name="ln911">/**</a>
<a name="ln912"> * Describe a given mutant beast's special characteristics: its tier &amp; facets.</a>
<a name="ln913"> *</a>
<a name="ln914"> * @param mi    The player-visible information about the monster in question.</a>
<a name="ln915"> * @return      A string describing the monster; e.g.</a>
<a name="ln916"> *              &quot;It is a juvenile, out of the larval stage but still below its</a>
<a name="ln917"> *              mature strength. It flies and flits around unpredictably, and</a>
<a name="ln918"> *              its breath has a tendency to ignite when angered.&quot;</a>
<a name="ln919"> */</a>
<a name="ln920">static string _describe_mutant_beast(const monster_info &amp;mi)</a>
<a name="ln921">{</a>
<a name="ln922">    const int xl = mi.props[MUTANT_BEAST_TIER].get_short();</a>
<a name="ln923">    const int tier = mutant_beast_tier(xl);</a>
<a name="ln924">    const CrawlVector facets = mi.props[MUTANT_BEAST_FACETS].get_vector();</a>
<a name="ln925">    return _describe_mutant_beast_facets(facets)</a>
<a name="ln926">           + &quot; &quot; + _describe_mutant_beast_tier(tier);</a>
<a name="ln927">}</a>
<a name="ln928"> </a>
<a name="ln929">/**</a>
<a name="ln930"> * Is the item associated with some specific training goal?  (E.g. mindelay)</a>
<a name="ln931"> *</a>
<a name="ln932"> * @return the goal, or 0 if there is none, scaled by 10.</a>
<a name="ln933"> */</a>
<a name="ln934">static int _item_training_target(const item_def &amp;item)</a>
<a name="ln935">{</a>
<a name="ln936">    const int throw_dam = property(item, PWPN_DAMAGE);</a>
<a name="ln937">    if (item.base_type == OBJ_WEAPONS || item.base_type == OBJ_STAVES)</a>
<a name="ln938">        return weapon_min_delay_skill(item) * 10;</a>
<a name="ln939">    else if (is_shield(item))</a>
<a name="ln940">        return round(you.get_shield_skill_to_offset_penalty(item) * 10);</a>
<a name="ln941">    else if (item.base_type == OBJ_MISSILES &amp;&amp; is_throwable(&amp;you, item, false))</a>
<a name="ln942">        return (((10 + throw_dam / 2) - FASTEST_PLAYER_THROWING_SPEED) * 2) * 10;</a>
<a name="ln943">    else</a>
<a name="ln944">        return 0;</a>
<a name="ln945">}</a>
<a name="ln946"> </a>
<a name="ln947">/**</a>
<a name="ln948"> * Does an item improve with training some skill?</a>
<a name="ln949"> *</a>
<a name="ln950"> * @return the skill, or SK_NONE if there is none. Note: SK_NONE is *not* 0.</a>
<a name="ln951"> */</a>
<a name="ln952">static skill_type _item_training_skill(const item_def &amp;item)</a>
<a name="ln953">{</a>
<a name="ln954">    if (item.base_type == OBJ_WEAPONS || item.base_type == OBJ_STAVES)</a>
<a name="ln955">        return item_attack_skill(item);</a>
<a name="ln956">    else if (is_shield(item))</a>
<a name="ln957">        return SK_SHIELDS; // shields are armour, so do shields before armour</a>
<a name="ln958">    else if (item.base_type == OBJ_ARMOUR)</a>
<a name="ln959">        return SK_ARMOUR;</a>
<a name="ln960">    else if (item.base_type == OBJ_MISSILES &amp;&amp; is_throwable(&amp;you, item, false))</a>
<a name="ln961">        return SK_THROWING;</a>
<a name="ln962">    else if (item_is_evokable(item)) // not very accurate</a>
<a name="ln963">        return SK_EVOCATIONS;</a>
<a name="ln964">    else</a>
<a name="ln965">        return SK_NONE;</a>
<a name="ln966">}</a>
<a name="ln967"> </a>
<a name="ln968">/**</a>
<a name="ln969"> * Whether it would make sense to set a training target for an item.</a>
<a name="ln970"> *</a>
<a name="ln971"> * @param item the item to check.</a>
<a name="ln972"> * @param ignore_current whether to ignore any current training targets (e.g. if there is a higher target, it might not make sense to set a lower one).</a>
<a name="ln973"> */</a>
<a name="ln974">static bool _could_set_training_target(const item_def &amp;item, bool ignore_current)</a>
<a name="ln975">{</a>
<a name="ln976">    if (!crawl_state.need_save || is_useless_item(item) || you.species == SP_GNOLL)</a>
<a name="ln977">        return false;</a>
<a name="ln978"> </a>
<a name="ln979">    const skill_type skill = _item_training_skill(item);</a>
<a name="ln980">    if (skill == SK_NONE)</a>
<a name="ln981">        return false;</a>
<a name="ln982"> </a>
<a name="ln983">    const int target = min(_item_training_target(item), 270);</a>
<a name="ln984"> </a>
<a name="ln985">    return target &amp;&amp; !is_useless_skill(skill)</a>
<a name="ln986">       &amp;&amp; you.skill(skill, 10, false, false, false) &lt; target</a>
<a name="ln987">       &amp;&amp; (ignore_current || you.get_training_target(skill) &lt; target);</a>
<a name="ln988">}</a>
<a name="ln989"> </a>
<a name="ln990">/**</a>
<a name="ln991"> * Produce the &quot;Your skill:&quot; line for item descriptions where specific skill targets</a>
<a name="ln992"> * are relevant (weapons, missiles, shields)</a>
<a name="ln993"> *</a>
<a name="ln994"> * @param skill the skill to look at.</a>
<a name="ln995"> * @param show_target_button whether to show the button for setting a skill target.</a>
<a name="ln996"> * @param scaled_target a target, scaled by 10, to use when describing the button.</a>
<a name="ln997"> */</a>
<a name="ln998">static string _your_skill_desc(skill_type skill, bool show_target_button, int scaled_target)</a>
<a name="ln999">{</a>
<a name="ln1000">    if (!crawl_state.need_save || skill == SK_NONE)</a>
<a name="ln1001">        return &quot;&quot;;</a>
<a name="ln1002">    string target_button_desc = &quot;&quot;;</a>
<a name="ln1003">    int min_scaled_target = min(scaled_target, 270);</a>
<a name="ln1004">    if (show_target_button &amp;&amp;</a>
<a name="ln1005">            you.get_training_target(skill) &lt; min_scaled_target)</a>
<a name="ln1006">    {</a>
<a name="ln1007">        target_button_desc = make_stringf(</a>
<a name="ln1008">            &quot;; use &lt;white&gt;(s)&lt;/white&gt; to set %d.%d as a target for %s.&quot;,</a>
<a name="ln1009">                                min_scaled_target / 10, min_scaled_target % 10,</a>
<a name="ln1010">                                skill_name(skill));</a>
<a name="ln1011">    }</a>
<a name="ln1012">    int you_skill_temp = you.skill(skill, 10, false, true, true);</a>
<a name="ln1013">    int you_skill = you.skill(skill, 10, false, false, false);</a>
<a name="ln1014"> </a>
<a name="ln1015">    return make_stringf(&quot;Your %sskill: %d.%d%s&quot;,</a>
<a name="ln1016">                            (you_skill_temp != you_skill ? &quot;(base) &quot; : &quot;&quot;),</a>
<a name="ln1017">                            you_skill / 10, you_skill % 10,</a>
<a name="ln1018">                            target_button_desc.c_str());</a>
<a name="ln1019">}</a>
<a name="ln1020"> </a>
<a name="ln1021">/**</a>
<a name="ln1022"> * Produce a description of a skill target for items where specific targets are</a>
<a name="ln1023"> * relevant.</a>
<a name="ln1024"> *</a>
<a name="ln1025"> * @param skill the skill to look at.</a>
<a name="ln1026"> * @param scaled_target a skill level target, scaled by 10.</a>
<a name="ln1027"> * @param training a training value, from 0 to 100. Need not be the actual training</a>
<a name="ln1028"> * value.</a>
<a name="ln1029"> */</a>
<a name="ln1030">static string _skill_target_desc(skill_type skill, int scaled_target,</a>
<a name="ln1031">                                        unsigned int training)</a>
<a name="ln1032">{</a>
<a name="ln1033">    string description = &quot;&quot;;</a>
<a name="ln1034">    scaled_target = min(scaled_target, 270);</a>
<a name="ln1035"> </a>
<a name="ln1036">    const bool max_training = (training == 100);</a>
<a name="ln1037">    const bool hypothetical = !crawl_state.need_save ||</a>
<a name="ln1038">                                    (training != you.training[skill]);</a>
<a name="ln1039"> </a>
<a name="ln1040">    const skill_diff diffs = skill_level_to_diffs(skill,</a>
<a name="ln1041">                                (double) scaled_target / 10, training, false);</a>
<a name="ln1042">    const int level_diff = xp_to_level_diff(diffs.experience / 10, 10);</a>
<a name="ln1043"> </a>
<a name="ln1044">    if (max_training)</a>
<a name="ln1045">        description += &quot;At 100% training &quot;;</a>
<a name="ln1046">    else if (!hypothetical)</a>
<a name="ln1047">    {</a>
<a name="ln1048">        description += make_stringf(&quot;At current training (%d%%) &quot;,</a>
<a name="ln1049">                                        you.training[skill]);</a>
<a name="ln1050">    }</a>
<a name="ln1051">    else</a>
<a name="ln1052">        description += make_stringf(&quot;At a training level of %d%% &quot;, training);</a>
<a name="ln1053"> </a>
<a name="ln1054">    description += make_stringf(</a>
<a name="ln1055">        &quot;you %s reach %d.%d in %s %d.%d XLs.&quot;,</a>
<a name="ln1056">            hypothetical ? &quot;would&quot; : &quot;will&quot;,</a>
<a name="ln1057">            scaled_target / 10, scaled_target % 10,</a>
<a name="ln1058">            (you.experience_level + (level_diff + 9) / 10) &gt; 27</a>
<a name="ln1059">                                ? &quot;the equivalent of&quot; : &quot;about&quot;,</a>
<a name="ln1060">            level_diff / 10, level_diff % 10);</a>
<a name="ln1061">    if (you.wizard)</a>
<a name="ln1062">    {</a>
<a name="ln1063">        description += make_stringf(&quot;\n    (%d xp, %d skp)&quot;,</a>
<a name="ln1064">                                    diffs.experience, diffs.skill_points);</a>
<a name="ln1065">    }</a>
<a name="ln1066">    return description;</a>
<a name="ln1067">}</a>
<a name="ln1068"> </a>
<a name="ln1069">/**</a>
<a name="ln1070"> * Append two skill target descriptions: one for 100%, and one for the</a>
<a name="ln1071"> * current training rate.</a>
<a name="ln1072"> */</a>
<a name="ln1073">static void _append_skill_target_desc(string &amp;description, skill_type skill,</a>
<a name="ln1074">                                        int scaled_target)</a>
<a name="ln1075">{</a>
<a name="ln1076">    if (you.species != SP_GNOLL)</a>
<a name="ln1077">        description += &quot;\n    &quot; + _skill_target_desc(skill, scaled_target, 100);</a>
<a name="ln1078">    if (you.training[skill] &gt; 0 &amp;&amp; you.training[skill] &lt; 100)</a>
<a name="ln1079">    {</a>
<a name="ln1080">        description += &quot;\n    &quot; + _skill_target_desc(skill, scaled_target,</a>
<a name="ln1081">                                                    you.training[skill]);</a>
<a name="ln1082">    }</a>
<a name="ln1083">}</a>
<a name="ln1084"> </a>
<a name="ln1085">static void _append_weapon_stats(string &amp;description, const item_def &amp;item)</a>
<a name="ln1086">{</a>
<a name="ln1087">    const int base_dam = property(item, PWPN_DAMAGE);</a>
<a name="ln1088">    const int ammo_type = fires_ammo_type(item);</a>
<a name="ln1089">    const int ammo_dam = ammo_type == MI_NONE ? 0 :</a>
<a name="ln1090">                                                ammo_type_damage(ammo_type);</a>
<a name="ln1091">    const skill_type skill = _item_training_skill(item);</a>
<a name="ln1092">    const int mindelay_skill = _item_training_target(item);</a>
<a name="ln1093"> </a>
<a name="ln1094">    const bool could_set_target = _could_set_training_target(item, true);</a>
<a name="ln1095"> </a>
<a name="ln1096">    if (skill == SK_SLINGS)</a>
<a name="ln1097">    {</a>
<a name="ln1098">        description += make_stringf(&quot;\nFiring bullets:    Base damage: %d&quot;,</a>
<a name="ln1099">                                    base_dam +</a>
<a name="ln1100">                                    ammo_type_damage(MI_SLING_BULLET));</a>
<a name="ln1101">    }</a>
<a name="ln1102"> </a>
<a name="ln1103">    description += make_stringf(</a>
<a name="ln1104">    &quot;\nBase accuracy: %+d  Base damage: %d  Base attack delay: %.1f&quot;</a>
<a name="ln1105">    &quot;\nThis weapon's minimum attack delay (%.1f) is reached at skill level %d.&quot;,</a>
<a name="ln1106">        property(item, PWPN_HIT),</a>
<a name="ln1107">        base_dam + ammo_dam,</a>
<a name="ln1108">        (float) property(item, PWPN_SPEED) / 10,</a>
<a name="ln1109">        (float) weapon_min_delay(item, item_brand_known(item)) / 10,</a>
<a name="ln1110">        mindelay_skill / 10);</a>
<a name="ln1111"> </a>
<a name="ln1112">    if (!is_useless_item(item))</a>
<a name="ln1113">    {</a>
<a name="ln1114">        description += &quot;\n    &quot; + _your_skill_desc(skill,</a>
<a name="ln1115">                    could_set_target &amp;&amp; in_inventory(item), mindelay_skill);</a>
<a name="ln1116">    }</a>
<a name="ln1117"> </a>
<a name="ln1118">    if (could_set_target)</a>
<a name="ln1119">        _append_skill_target_desc(description, skill, mindelay_skill);</a>
<a name="ln1120">}</a>
<a name="ln1121"> </a>
<a name="ln1122">static string _handedness_string(const item_def &amp;item)</a>
<a name="ln1123">{</a>
<a name="ln1124">    string description;</a>
<a name="ln1125"> </a>
<a name="ln1126">    switch (you.hands_reqd(item))</a>
<a name="ln1127">    {</a>
<a name="ln1128">    case HANDS_ONE:</a>
<a name="ln1129">        if (you.species == SP_FORMICID)</a>
<a name="ln1130">            description += &quot;It is a weapon for one hand-pair.&quot;;</a>
<a name="ln1131">        else</a>
<a name="ln1132">            description += &quot;It is a one handed weapon.&quot;;</a>
<a name="ln1133">        break;</a>
<a name="ln1134">    case HANDS_TWO:</a>
<a name="ln1135">        description += &quot;It is a two handed weapon.&quot;;</a>
<a name="ln1136">        break;</a>
<a name="ln1137">    }</a>
<a name="ln1138"> </a>
<a name="ln1139">    return description;</a>
<a name="ln1140">}</a>
<a name="ln1141"> </a>
<a name="ln1142">static string _describe_weapon(const item_def &amp;item, bool verbose)</a>
<a name="ln1143">{</a>
<a name="ln1144">    string description;</a>
<a name="ln1145"> </a>
<a name="ln1146">    description.reserve(200);</a>
<a name="ln1147"> </a>
<a name="ln1148">    description = &quot;&quot;;</a>
<a name="ln1149"> </a>
<a name="ln1150">    if (verbose)</a>
<a name="ln1151">    {</a>
<a name="ln1152">        description += &quot;\n&quot;;</a>
<a name="ln1153">        _append_weapon_stats(description, item);</a>
<a name="ln1154">    }</a>
<a name="ln1155"> </a>
<a name="ln1156">    const int spec_ench = (is_artefact(item) || verbose)</a>
<a name="ln1157">                          ? get_weapon_brand(item) : SPWPN_NORMAL;</a>
<a name="ln1158">    const int damtype = get_vorpal_type(item);</a>
<a name="ln1159"> </a>
<a name="ln1160">    if (verbose)</a>
<a name="ln1161">    {</a>
<a name="ln1162">        switch (item_attack_skill(item))</a>
<a name="ln1163">        {</a>
<a name="ln1164">        case SK_POLEARMS:</a>
<a name="ln1165">            description += &quot;\n\nIt can be evoked to extend its reach.&quot;;</a>
<a name="ln1166">            break;</a>
<a name="ln1167">        case SK_AXES:</a>
<a name="ln1168">            description += &quot;\n\nIt hits all enemies adjacent to the wielder, &quot;</a>
<a name="ln1169">                           &quot;dealing less damage to those not targeted.&quot;;</a>
<a name="ln1170">            break;</a>
<a name="ln1171">        case SK_LONG_BLADES:</a>
<a name="ln1172">            description += &quot;\n\nIt can be used to riposte, swiftly &quot;</a>
<a name="ln1173">                           &quot;retaliating against a missed attack.&quot;;</a>
<a name="ln1174">            break;</a>
<a name="ln1175">        case SK_SHORT_BLADES:</a>
<a name="ln1176">            {</a>
<a name="ln1177">                string adj = (item.sub_type == WPN_DAGGER) ? &quot;extremely&quot;</a>
<a name="ln1178">                                                           : &quot;particularly&quot;;</a>
<a name="ln1179">                description += &quot;\n\nIt is &quot; + adj + &quot; good for stabbing&quot;</a>
<a name="ln1180">                               &quot; unaware enemies.&quot;;</a>
<a name="ln1181">            }</a>
<a name="ln1182">            break;</a>
<a name="ln1183">        default:</a>
<a name="ln1184">            break;</a>
<a name="ln1185">        }</a>
<a name="ln1186">    }</a>
<a name="ln1187"> </a>
<a name="ln1188">    // ident known &amp; no brand but still glowing</a>
<a name="ln1189">    // TODO: deduplicate this with the code in item-name.cc</a>
<a name="ln1190">    const bool enchanted = get_equip_desc(item) &amp;&amp; spec_ench == SPWPN_NORMAL</a>
<a name="ln1191">                           &amp;&amp; !item_ident(item, ISFLAG_KNOW_PLUSES);</a>
<a name="ln1192"> </a>
<a name="ln1193">    // special weapon descrip</a>
<a name="ln1194">    if (item_type_known(item) &amp;&amp; (spec_ench != SPWPN_NORMAL || enchanted))</a>
<a name="ln1195">    {</a>
<a name="ln1196">        description += &quot;\n\n&quot;;</a>
<a name="ln1197"> </a>
<a name="ln1198">        switch (spec_ench)</a>
<a name="ln1199">        {</a>
<a name="ln1200">        case SPWPN_FLAMING:</a>
<a name="ln1201">            if (is_range_weapon(item))</a>
<a name="ln1202">            {</a>
<a name="ln1203">                description += &quot;It causes projectiles fired from it to burn &quot;</a>
<a name="ln1204">                    &quot;those they strike,&quot;;</a>
<a name="ln1205">            }</a>
<a name="ln1206">            else</a>
<a name="ln1207">            {</a>
<a name="ln1208">                description += &quot;It has been specially enchanted to burn &quot;</a>
<a name="ln1209">                    &quot;those struck by it,&quot;;</a>
<a name="ln1210">            }</a>
<a name="ln1211">            description += &quot; causing extra injury to most foes and up to half &quot;</a>
<a name="ln1212">                           &quot;again as much damage against particularly &quot;</a>
<a name="ln1213">                           &quot;susceptible opponents.&quot;;</a>
<a name="ln1214">            if (!is_range_weapon(item) &amp;&amp;</a>
<a name="ln1215">                (damtype == DVORP_SLICING || damtype == DVORP_CHOPPING))</a>
<a name="ln1216">            {</a>
<a name="ln1217">                description += &quot; Big, fiery blades are also staple &quot;</a>
<a name="ln1218">                    &quot;armaments of hydra-hunters.&quot;;</a>
<a name="ln1219">            }</a>
<a name="ln1220">            break;</a>
<a name="ln1221">        case SPWPN_FREEZING:</a>
<a name="ln1222">            if (is_range_weapon(item))</a>
<a name="ln1223">            {</a>
<a name="ln1224">                description += &quot;It causes projectiles fired from it to freeze &quot;</a>
<a name="ln1225">                    &quot;those they strike,&quot;;</a>
<a name="ln1226">            }</a>
<a name="ln1227">            else</a>
<a name="ln1228">            {</a>
<a name="ln1229">                description += &quot;It has been specially enchanted to freeze &quot;</a>
<a name="ln1230">                    &quot;those struck by it,&quot;;</a>
<a name="ln1231">            }</a>
<a name="ln1232">            description += &quot; causing extra injury to most foes &quot;</a>
<a name="ln1233">                    &quot;and up to half again as much damage against particularly &quot;</a>
<a name="ln1234">                    &quot;susceptible opponents.&quot;;</a>
<a name="ln1235">            if (is_range_weapon(item))</a>
<a name="ln1236">                description += &quot; They&quot;;</a>
<a name="ln1237">            else</a>
<a name="ln1238">                description += &quot; It&quot;;</a>
<a name="ln1239">            description += &quot; can also slow down cold-blooded creatures.&quot;;</a>
<a name="ln1240">            break;</a>
<a name="ln1241">        case SPWPN_HOLY_WRATH:</a>
<a name="ln1242">            description += &quot;It has been blessed by the Shining One&quot;;</a>
<a name="ln1243">            if (is_range_weapon(item))</a>
<a name="ln1244">            {</a>
<a name="ln1245">                description += &quot;, and any &quot;;</a>
<a name="ln1246">                description += ammo_name(item);</a>
<a name="ln1247">                description += &quot; fired from it will&quot;;</a>
<a name="ln1248">            }</a>
<a name="ln1249">            else</a>
<a name="ln1250">                description += &quot; to&quot;;</a>
<a name="ln1251">            description += &quot; cause great damage to the undead and demons.&quot;;</a>
<a name="ln1252">            break;</a>
<a name="ln1253">        case SPWPN_ELECTROCUTION:</a>
<a name="ln1254">            if (is_range_weapon(item))</a>
<a name="ln1255">            {</a>
<a name="ln1256">                description += &quot;It charges the ammunition it shoots with &quot;</a>
<a name="ln1257">                    &quot;electricity; occasionally upon a hit, such missiles &quot;</a>
<a name="ln1258">                    &quot;may discharge and cause terrible harm.&quot;;</a>
<a name="ln1259">            }</a>
<a name="ln1260">            else</a>
<a name="ln1261">            {</a>
<a name="ln1262">                description += &quot;Occasionally, upon striking a foe, it will &quot;</a>
<a name="ln1263">                    &quot;discharge some electrical energy and cause terrible &quot;</a>
<a name="ln1264">                    &quot;harm.&quot;;</a>
<a name="ln1265">            }</a>
<a name="ln1266">            break;</a>
<a name="ln1267">        case SPWPN_VENOM:</a>
<a name="ln1268">            if (is_range_weapon(item))</a>
<a name="ln1269">                description += &quot;It poisons the ammo it fires.&quot;;</a>
<a name="ln1270">            else</a>
<a name="ln1271">                description += &quot;It poisons the flesh of those it strikes.&quot;;</a>
<a name="ln1272">            break;</a>
<a name="ln1273">        case SPWPN_PROTECTION:</a>
<a name="ln1274">            description += &quot;It grants its wielder temporary protection when &quot;</a>
<a name="ln1275">                &quot;it strikes (+7 to AC).&quot;;</a>
<a name="ln1276">            break;</a>
<a name="ln1277">        case SPWPN_DRAINING:</a>
<a name="ln1278">            description += &quot;A truly terrible weapon, it drains the &quot;</a>
<a name="ln1279">                &quot;life of those it strikes.&quot;;</a>
<a name="ln1280">            break;</a>
<a name="ln1281">        case SPWPN_SPEED:</a>
<a name="ln1282">            description += &quot;Attacks with this weapon are significantly faster.&quot;;</a>
<a name="ln1283">            break;</a>
<a name="ln1284">        case SPWPN_VORPAL:</a>
<a name="ln1285">            if (is_range_weapon(item))</a>
<a name="ln1286">            {</a>
<a name="ln1287">                description += &quot;Any &quot;;</a>
<a name="ln1288">                description += ammo_name(item);</a>
<a name="ln1289">                description += &quot; fired from it inflicts extra damage.&quot;;</a>
<a name="ln1290">            }</a>
<a name="ln1291">            else</a>
<a name="ln1292">            {</a>
<a name="ln1293">                description += &quot;It inflicts extra damage upon your &quot;</a>
<a name="ln1294">                    &quot;enemies.&quot;;</a>
<a name="ln1295">            }</a>
<a name="ln1296">            break;</a>
<a name="ln1297">        case SPWPN_CHAOS:</a>
<a name="ln1298">            if (is_range_weapon(item))</a>
<a name="ln1299">            {</a>
<a name="ln1300">                description += &quot;Each projectile launched from it has a &quot;</a>
<a name="ln1301">                               &quot;different, random effect.&quot;;</a>
<a name="ln1302">            }</a>
<a name="ln1303">            else</a>
<a name="ln1304">            {</a>
<a name="ln1305">                description += &quot;Each time it hits an enemy it has a &quot;</a>
<a name="ln1306">                    &quot;different, random effect.&quot;;</a>
<a name="ln1307">            }</a>
<a name="ln1308">            break;</a>
<a name="ln1309">        case SPWPN_VAMPIRISM:</a>
<a name="ln1310">            description += &quot;It inflicts no extra harm, but heals &quot;</a>
<a name="ln1311">                &quot;its wielder when it wounds a living foe.&quot;;</a>
<a name="ln1312">            break;</a>
<a name="ln1313">        case SPWPN_PAIN:</a>
<a name="ln1314">            description += &quot;In the hands of one skilled in necromantic &quot;</a>
<a name="ln1315">                &quot;magic, it inflicts extra damage on living creatures.&quot;;</a>
<a name="ln1316">            break;</a>
<a name="ln1317">        case SPWPN_DISTORTION:</a>
<a name="ln1318">            description += &quot;It warps and distorts space around it. &quot;</a>
<a name="ln1319">                &quot;Unwielding it can cause banishment or high damage.&quot;;</a>
<a name="ln1320">            break;</a>
<a name="ln1321">        case SPWPN_PENETRATION:</a>
<a name="ln1322">            description += &quot;Ammo fired by it will pass through the &quot;</a>
<a name="ln1323">                &quot;targets it hits, potentially hitting all targets in &quot;</a>
<a name="ln1324">                &quot;its path until it reaches maximum range.&quot;;</a>
<a name="ln1325">            break;</a>
<a name="ln1326">        case SPWPN_REAPING:</a>
<a name="ln1327">            description += &quot;If a monster killed with it leaves a &quot;</a>
<a name="ln1328">                &quot;corpse in good enough shape, the corpse will be &quot;</a>
<a name="ln1329">                &quot;animated as a zombie friendly to the killer.&quot;;</a>
<a name="ln1330">            break;</a>
<a name="ln1331">        case SPWPN_ANTIMAGIC:</a>
<a name="ln1332">            description += &quot;It reduces the magical energy of the wielder, &quot;</a>
<a name="ln1333">                    &quot;and disrupts the spells and magical abilities of those &quot;</a>
<a name="ln1334">                    &quot;hit. Natural abilities and divine invocations are not &quot;</a>
<a name="ln1335">                    &quot;affected.&quot;;</a>
<a name="ln1336">            break;</a>
<a name="ln1337">        case SPWPN_NORMAL:</a>
<a name="ln1338">            ASSERT(enchanted);</a>
<a name="ln1339">            description += &quot;It has no special brand (it is not flaming, &quot;</a>
<a name="ln1340">                    &quot;freezing, etc), but is still enchanted in some way - &quot;</a>
<a name="ln1341">                    &quot;positive or negative.&quot;;</a>
<a name="ln1342">            break;</a>
<a name="ln1343">        }</a>
<a name="ln1344">    }</a>
<a name="ln1345"> </a>
<a name="ln1346">    if (is_unrandom_artefact(item, UNRAND_STORM_BOW))</a>
<a name="ln1347">    {</a>
<a name="ln1348">        description += &quot;\n\nAmmo fired by it will pass through the &quot;</a>
<a name="ln1349">            &quot;targets it hits, potentially hitting all targets in &quot;</a>
<a name="ln1350">            &quot;its path until it reaches maximum range.&quot;;</a>
<a name="ln1351">    }</a>
<a name="ln1352">    else if (is_unrandom_artefact(item, UNRAND_THERMIC_ENGINE))</a>
<a name="ln1353">    {</a>
<a name="ln1354">        description += &quot;\n\nIt has been specially enchanted to freeze &quot;</a>
<a name="ln1355">            &quot;those struck by it, causing extra injury to most foes &quot;</a>
<a name="ln1356">            &quot;and up to half again as much damage against particularly &quot;</a>
<a name="ln1357">            &quot;susceptible opponents.&quot;;</a>
<a name="ln1358">    }</a>
<a name="ln1359">    else if (is_unrandom_artefact(item, UNRAND_OLGREB))</a>
<a name="ln1360">        description += &quot;\n\nIt grants immunity to poison.&quot;;</a>
<a name="ln1361"> </a>
<a name="ln1362">    if (you.duration[DUR_EXCRUCIATING_WOUNDS] &amp;&amp; &amp;item == you.weapon())</a>
<a name="ln1363">    {</a>
<a name="ln1364">        description += &quot;\nIt is temporarily rebranded; it is actually &quot;;</a>
<a name="ln1365">        if ((int) you.props[ORIGINAL_BRAND_KEY] == SPWPN_NORMAL)</a>
<a name="ln1366">            description += &quot;an unbranded weapon.&quot;;</a>
<a name="ln1367">        else</a>
<a name="ln1368">        {</a>
<a name="ln1369">            brand_type original = static_cast&lt;brand_type&gt;(</a>
<a name="ln1370">                you.props[ORIGINAL_BRAND_KEY].get_int());</a>
<a name="ln1371">            description += article_a(</a>
<a name="ln1372">                weapon_brand_desc(&quot;weapon&quot;, item, false, original) + &quot;.&quot;, true);</a>
<a name="ln1373">        }</a>
<a name="ln1374">    }</a>
<a name="ln1375"> </a>
<a name="ln1376">    if (is_artefact(item))</a>
<a name="ln1377">    {</a>
<a name="ln1378">        string rand_desc = _randart_descrip(item);</a>
<a name="ln1379">        if (!rand_desc.empty())</a>
<a name="ln1380">        {</a>
<a name="ln1381">            description += &quot;\n&quot;;</a>
<a name="ln1382">            description += rand_desc;</a>
<a name="ln1383">        }</a>
<a name="ln1384"> </a>
<a name="ln1385">        // XXX: Can't happen, right?</a>
<a name="ln1386">        if (!item_ident(item, ISFLAG_KNOW_PROPERTIES)</a>
<a name="ln1387">            &amp;&amp; item_type_known(item))</a>
<a name="ln1388">        {</a>
<a name="ln1389">            description += &quot;\nThis weapon may have some hidden properties.&quot;;</a>
<a name="ln1390">        }</a>
<a name="ln1391">    }</a>
<a name="ln1392"> </a>
<a name="ln1393">    if (verbose)</a>
<a name="ln1394">    {</a>
<a name="ln1395">        description += &quot;\n\nThis &quot;;</a>
<a name="ln1396">        if (is_unrandom_artefact(item))</a>
<a name="ln1397">            description += get_artefact_base_name(item);</a>
<a name="ln1398">        else</a>
<a name="ln1399">            description += &quot;weapon&quot;;</a>
<a name="ln1400">        description += &quot; falls into the&quot;;</a>
<a name="ln1401"> </a>
<a name="ln1402">        const skill_type skill = item_attack_skill(item);</a>
<a name="ln1403"> </a>
<a name="ln1404">        description +=</a>
<a name="ln1405">            make_stringf(&quot; '%s' category. &quot;,</a>
<a name="ln1406">                         skill == SK_FIGHTING ? &quot;buggy&quot; : skill_name(skill));</a>
<a name="ln1407"> </a>
<a name="ln1408">        description += _handedness_string(item);</a>
<a name="ln1409"> </a>
<a name="ln1410">        if (!you.could_wield(item, true) &amp;&amp; crawl_state.need_save)</a>
<a name="ln1411">            description += &quot;\nIt is too large for you to wield.&quot;;</a>
<a name="ln1412">    }</a>
<a name="ln1413"> </a>
<a name="ln1414">    if (!is_artefact(item))</a>
<a name="ln1415">    {</a>
<a name="ln1416">        if (item_ident(item, ISFLAG_KNOW_PLUSES) &amp;&amp; item.plus &gt;= MAX_WPN_ENCHANT)</a>
<a name="ln1417">            description += &quot;\nIt cannot be enchanted further.&quot;;</a>
<a name="ln1418">        else</a>
<a name="ln1419">        {</a>
<a name="ln1420">            description += &quot;\nIt can be maximally enchanted to +&quot;</a>
<a name="ln1421">                           + to_string(MAX_WPN_ENCHANT) + &quot;.&quot;;</a>
<a name="ln1422">        }</a>
<a name="ln1423">    }</a>
<a name="ln1424"> </a>
<a name="ln1425">    return description;</a>
<a name="ln1426">}</a>
<a name="ln1427"> </a>
<a name="ln1428">static string _describe_ammo(const item_def &amp;item)</a>
<a name="ln1429">{</a>
<a name="ln1430">    string description;</a>
<a name="ln1431"> </a>
<a name="ln1432">    description.reserve(64);</a>
<a name="ln1433"> </a>
<a name="ln1434">    const bool can_launch = has_launcher(item);</a>
<a name="ln1435">    const bool can_throw  = is_throwable(&amp;you, item, true);</a>
<a name="ln1436"> </a>
<a name="ln1437">    if (item.brand &amp;&amp; item_type_known(item))</a>
<a name="ln1438">    {</a>
<a name="ln1439">        description += &quot;\n\n&quot;;</a>
<a name="ln1440"> </a>
<a name="ln1441">        string threw_or_fired;</a>
<a name="ln1442">        if (can_throw)</a>
<a name="ln1443">        {</a>
<a name="ln1444">            threw_or_fired += &quot;threw&quot;;</a>
<a name="ln1445">            if (can_launch)</a>
<a name="ln1446">                threw_or_fired += &quot; or &quot;;</a>
<a name="ln1447">        }</a>
<a name="ln1448">        if (can_launch)</a>
<a name="ln1449">            threw_or_fired += &quot;fired&quot;;</a>
<a name="ln1450"> </a>
<a name="ln1451">        switch (item.brand)</a>
<a name="ln1452">        {</a>
<a name="ln1453">#if TAG_MAJOR_VERSION == 34</a>
<a name="ln1454">        case SPMSL_FLAME:</a>
<a name="ln1455">            description += &quot;It burns those it strikes, causing extra injury &quot;</a>
<a name="ln1456">                    &quot;to most foes and up to half again as much damage against &quot;</a>
<a name="ln1457">                    &quot;particularly susceptible opponents. Compared to normal &quot;</a>
<a name="ln1458">                    &quot;ammo, it is twice as likely to be destroyed on impact.&quot;;</a>
<a name="ln1459">            break;</a>
<a name="ln1460">        case SPMSL_FROST:</a>
<a name="ln1461">            description += &quot;It freezes those it strikes, causing extra injury &quot;</a>
<a name="ln1462">                    &quot;to most foes and up to half again as much damage against &quot;</a>
<a name="ln1463">                    &quot;particularly susceptible opponents. It can also slow down &quot;</a>
<a name="ln1464">                    &quot;cold-blooded creatures. Compared to normal ammo, it is &quot;</a>
<a name="ln1465">                    &quot;twice as likely to be destroyed on impact.&quot;;</a>
<a name="ln1466">            break;</a>
<a name="ln1467">#endif</a>
<a name="ln1468">        case SPMSL_CHAOS:</a>
<a name="ln1469">            description += &quot;When &quot;;</a>
<a name="ln1470"> </a>
<a name="ln1471">            if (can_throw)</a>
<a name="ln1472">            {</a>
<a name="ln1473">                description += &quot;thrown, &quot;;</a>
<a name="ln1474">                if (can_launch)</a>
<a name="ln1475">                    description += &quot;or &quot;;</a>
<a name="ln1476">            }</a>
<a name="ln1477"> </a>
<a name="ln1478">            if (can_launch)</a>
<a name="ln1479">                description += &quot;fired from an appropriate launcher, &quot;;</a>
<a name="ln1480"> </a>
<a name="ln1481">            description += &quot;it has a random effect.&quot;;</a>
<a name="ln1482">            break;</a>
<a name="ln1483">        case SPMSL_POISONED:</a>
<a name="ln1484">            description += &quot;It is coated with poison.&quot;;</a>
<a name="ln1485">            break;</a>
<a name="ln1486">        case SPMSL_CURARE:</a>
<a name="ln1487">            description += &quot;It is tipped with a substance that causes &quot;</a>
<a name="ln1488">                           &quot;asphyxiation, dealing direct damage as well as &quot;</a>
<a name="ln1489">                           &quot;poisoning and slowing those it strikes.\n&quot;</a>
<a name="ln1490">                           &quot;It is twice as likely to be destroyed on impact as &quot;</a>
<a name="ln1491">                           &quot;other darts.&quot;;</a>
<a name="ln1492">            break;</a>
<a name="ln1493">        case SPMSL_FRENZY:</a>
<a name="ln1494">            description += &quot;It is tipped with a substance that sends those it &quot;</a>
<a name="ln1495">                           &quot;hits into a mindless rage, attacking friend and &quot;</a>
<a name="ln1496">                           &quot;foe alike.&quot;;</a>
<a name="ln1497">            break;</a>
<a name="ln1498">        case SPMSL_BLINDING:</a>
<a name="ln1499">            description += &quot;It is tipped with a substance that causes &quot;</a>
<a name="ln1500">                           &quot;blindness and brief confusion.&quot;;</a>
<a name="ln1501">            break;</a>
<a name="ln1502">        case SPMSL_DISPERSAL:</a>
<a name="ln1503">            description += &quot;It will cause any target it hits to blink, with a &quot;</a>
<a name="ln1504">                           &quot;tendency towards blinking further away from the &quot;</a>
<a name="ln1505">                           &quot;one who &quot; + threw_or_fired + &quot; it.&quot;;</a>
<a name="ln1506">            break;</a>
<a name="ln1507">        case SPMSL_SILVER:</a>
<a name="ln1508">            description += &quot;It deals increased damage compared to normal ammo &quot;</a>
<a name="ln1509">                           &quot;and substantially increased damage to chaotic &quot;</a>
<a name="ln1510">                           &quot;and magically transformed beings. It also inflicts &quot;</a>
<a name="ln1511">                           &quot;extra damage against mutated beings, according to &quot;</a>
<a name="ln1512">                           &quot;how mutated they are.&quot;;</a>
<a name="ln1513">            break;</a>
<a name="ln1514">        }</a>
<a name="ln1515">    }</a>
<a name="ln1516"> </a>
<a name="ln1517">    const int dam = property(item, PWPN_DAMAGE);</a>
<a name="ln1518">    const bool player_throwable = is_throwable(&amp;you, item, false);</a>
<a name="ln1519">    if (player_throwable)</a>
<a name="ln1520">    {</a>
<a name="ln1521">        const int throw_delay = (10 + dam / 2);</a>
<a name="ln1522">        const int target_skill = _item_training_target(item);</a>
<a name="ln1523">        const bool could_set_target = _could_set_training_target(item, true);</a>
<a name="ln1524"> </a>
<a name="ln1525">        description += make_stringf(</a>
<a name="ln1526">            &quot;\nBase damage: %d  Base attack delay: %.1f&quot;</a>
<a name="ln1527">            &quot;\nThis projectile's minimum attack delay (%.1f) &quot;</a>
<a name="ln1528">                &quot;is reached at skill level %d.&quot;,</a>
<a name="ln1529">            dam,</a>
<a name="ln1530">            (float) throw_delay / 10,</a>
<a name="ln1531">            (float) FASTEST_PLAYER_THROWING_SPEED / 10,</a>
<a name="ln1532">            target_skill / 10</a>
<a name="ln1533">        );</a>
<a name="ln1534"> </a>
<a name="ln1535">        if (!is_useless_item(item))</a>
<a name="ln1536">        {</a>
<a name="ln1537">            description += &quot;\n    &quot; +</a>
<a name="ln1538">                    _your_skill_desc(SK_THROWING,</a>
<a name="ln1539">                        could_set_target &amp;&amp; in_inventory(item), target_skill);</a>
<a name="ln1540">        }</a>
<a name="ln1541">        if (could_set_target)</a>
<a name="ln1542">            _append_skill_target_desc(description, SK_THROWING, target_skill);</a>
<a name="ln1543">    }</a>
<a name="ln1544"> </a>
<a name="ln1545">    if (ammo_always_destroyed(item))</a>
<a name="ln1546">        description += &quot;\n\nIt will always be destroyed on impact.&quot;;</a>
<a name="ln1547">    else if (!ammo_never_destroyed(item))</a>
<a name="ln1548">        description += &quot;\n\nIt may be destroyed on impact.&quot;;</a>
<a name="ln1549"> </a>
<a name="ln1550">    return description;</a>
<a name="ln1551">}</a>
<a name="ln1552"> </a>
<a name="ln1553">static string _warlock_mirror_reflect_desc()</a>
<a name="ln1554">{</a>
<a name="ln1555">    const int SH = crawl_state.need_save ? player_shield_class() : 0;</a>
<a name="ln1556">    const int reflect_chance = 100 * SH / omnireflect_chance_denom(SH);</a>
<a name="ln1557">    return &quot;\n\nWith your current SH, it has a &quot; + to_string(reflect_chance) +</a>
<a name="ln1558">           &quot;% chance to reflect enchantments and other normally unblockable &quot;</a>
<a name="ln1559">           &quot;effects.&quot;;</a>
<a name="ln1560">}</a>
<a name="ln1561"> </a>
<a name="ln1562">static string _describe_point_change(int points)</a>
<a name="ln1563">{</a>
<a name="ln1564">    string point_diff_description;</a>
<a name="ln1565"> </a>
<a name="ln1566">    point_diff_description += make_stringf(&quot;%s by %d&quot;,</a>
<a name="ln1567">                                           points &gt; 0 ? &quot;increase&quot; : &quot;decrease&quot;,</a>
<a name="ln1568">                                           abs(points));</a>
<a name="ln1569"> </a>
<a name="ln1570">    return point_diff_description;</a>
<a name="ln1571">}</a>
<a name="ln1572"> </a>
<a name="ln1573">static string _describe_point_diff(int original,</a>
<a name="ln1574">                                   int changed)</a>
<a name="ln1575">{</a>
<a name="ln1576">    string description;</a>
<a name="ln1577"> </a>
<a name="ln1578">    int difference = changed - original;</a>
<a name="ln1579"> </a>
<a name="ln1580">    if (difference == 0)</a>
<a name="ln1581">        return &quot;remain unchanged.&quot;;</a>
<a name="ln1582"> </a>
<a name="ln1583">    description += _describe_point_change(difference);</a>
<a name="ln1584">    description += &quot; (&quot;;</a>
<a name="ln1585">    description += to_string(original);</a>
<a name="ln1586">    description += &quot; -&gt; &quot;;</a>
<a name="ln1587">    description += to_string(changed);</a>
<a name="ln1588">    description += &quot;).&quot;;</a>
<a name="ln1589"> </a>
<a name="ln1590">    return description;</a>
<a name="ln1591">}</a>
<a name="ln1592"> </a>
<a name="ln1593">static string _armour_ac_sub_change_description(const item_def &amp;item)</a>
<a name="ln1594">{</a>
<a name="ln1595">    string description;</a>
<a name="ln1596"> </a>
<a name="ln1597">    description.reserve(100);</a>
<a name="ln1598"> </a>
<a name="ln1599"> </a>
<a name="ln1600">    description += &quot;\n\nIf you switch to wearing this armour,&quot;</a>
<a name="ln1601">                        &quot; your AC will &quot;;</a>
<a name="ln1602"> </a>
<a name="ln1603">    int you_ac_with_this_item =</a>
<a name="ln1604">                 you.armour_class_with_one_sub(item);</a>
<a name="ln1605"> </a>
<a name="ln1606">    description += _describe_point_diff(you.armour_class(),</a>
<a name="ln1607">                                        you_ac_with_this_item);</a>
<a name="ln1608"> </a>
<a name="ln1609">    return description;</a>
<a name="ln1610">}</a>
<a name="ln1611"> </a>
<a name="ln1612">static string _armour_ac_remove_change_description(const item_def &amp;item)</a>
<a name="ln1613">{</a>
<a name="ln1614">    string description;</a>
<a name="ln1615"> </a>
<a name="ln1616">    description += &quot;\n\nIf you remove this armour,&quot;</a>
<a name="ln1617">                        &quot; your AC will &quot;;</a>
<a name="ln1618"> </a>
<a name="ln1619">    int you_ac_without_item =</a>
<a name="ln1620">                 you.armour_class_with_one_removal(item);</a>
<a name="ln1621"> </a>
<a name="ln1622">    description += _describe_point_diff(you.armour_class(),</a>
<a name="ln1623">                                        you_ac_without_item);</a>
<a name="ln1624"> </a>
<a name="ln1625">    return description;</a>
<a name="ln1626">}</a>
<a name="ln1627"> </a>
<a name="ln1628">static bool _you_are_wearing_item(const item_def &amp;item)</a>
<a name="ln1629">{</a>
<a name="ln1630">    return get_equip_slot(&amp;item) != EQ_NONE;</a>
<a name="ln1631">}</a>
<a name="ln1632"> </a>
<a name="ln1633">static string _armour_ac_change(const item_def &amp;item)</a>
<a name="ln1634">{</a>
<a name="ln1635">    string description;</a>
<a name="ln1636"> </a>
<a name="ln1637">    if (!_you_are_wearing_item(item))</a>
<a name="ln1638">        description = _armour_ac_sub_change_description(item);</a>
<a name="ln1639">    else</a>
<a name="ln1640">        description = _armour_ac_remove_change_description(item);</a>
<a name="ln1641"> </a>
<a name="ln1642">    return description;</a>
<a name="ln1643">}</a>
<a name="ln1644"> </a>
<a name="ln1645">static string _describe_armour(const item_def &amp;item, bool verbose)</a>
<a name="ln1646">{</a>
<a name="ln1647">    string description;</a>
<a name="ln1648"> </a>
<a name="ln1649">    description.reserve(300);</a>
<a name="ln1650"> </a>
<a name="ln1651">    if (verbose)</a>
<a name="ln1652">    {</a>
<a name="ln1653">        if (is_shield(item))</a>
<a name="ln1654">        {</a>
<a name="ln1655">            const int target_skill = _item_training_target(item);</a>
<a name="ln1656">            description += &quot;\n&quot;;</a>
<a name="ln1657">            description += &quot;\nBase shield rating: &quot;</a>
<a name="ln1658">                        + to_string(property(item, PARM_AC));</a>
<a name="ln1659">            const bool could_set_target = _could_set_training_target(item, true);</a>
<a name="ln1660"> </a>
<a name="ln1661">            if (!is_useless_item(item))</a>
<a name="ln1662">            {</a>
<a name="ln1663">                description += &quot;       Skill to remove penalty: &quot;</a>
<a name="ln1664">                            + make_stringf(&quot;%d.%d&quot;, target_skill / 10,</a>
<a name="ln1665">                                                target_skill % 10);</a>
<a name="ln1666"> </a>
<a name="ln1667">                if (crawl_state.need_save)</a>
<a name="ln1668">                {</a>
<a name="ln1669">                    description += &quot;\n                            &quot;</a>
<a name="ln1670">                        + _your_skill_desc(SK_SHIELDS,</a>
<a name="ln1671">                          could_set_target &amp;&amp; in_inventory(item), target_skill);</a>
<a name="ln1672">                }</a>
<a name="ln1673">                else</a>
<a name="ln1674">                    description += &quot;\n&quot;;</a>
<a name="ln1675">                if (could_set_target)</a>
<a name="ln1676">                {</a>
<a name="ln1677">                    _append_skill_target_desc(description, SK_SHIELDS,</a>
<a name="ln1678">                                                                target_skill);</a>
<a name="ln1679">                }</a>
<a name="ln1680">            }</a>
<a name="ln1681"> </a>
<a name="ln1682">            if (is_unrandom_artefact(item, UNRAND_WARLOCK_MIRROR))</a>
<a name="ln1683">                description += _warlock_mirror_reflect_desc();</a>
<a name="ln1684">        }</a>
<a name="ln1685">        else</a>
<a name="ln1686">        {</a>
<a name="ln1687">            const int evp = property(item, PARM_EVASION);</a>
<a name="ln1688">            description += &quot;\n\nBase armour rating: &quot;</a>
<a name="ln1689">                        + to_string(property(item, PARM_AC));</a>
<a name="ln1690">            if (get_armour_slot(item) == EQ_BODY_ARMOUR)</a>
<a name="ln1691">            {</a>
<a name="ln1692">                description += &quot;       Encumbrance rating: &quot;</a>
<a name="ln1693">                            + to_string(-evp / 10);</a>
<a name="ln1694">            }</a>
<a name="ln1695">            // Bardings reduce evasion by a fixed amount, and don't have any of</a>
<a name="ln1696">            // the other effects of encumbrance.</a>
<a name="ln1697">            else if (evp)</a>
<a name="ln1698">            {</a>
<a name="ln1699">                description += &quot;       Evasion: &quot;</a>
<a name="ln1700">                            + to_string(evp / 30);</a>
<a name="ln1701">            }</a>
<a name="ln1702">        }</a>
<a name="ln1703">    }</a>
<a name="ln1704"> </a>
<a name="ln1705">    const int ego = get_armour_ego_type(item);</a>
<a name="ln1706">    const bool enchanted = get_equip_desc(item) &amp;&amp; ego == SPARM_NORMAL</a>
<a name="ln1707">                           &amp;&amp; !item_ident(item, ISFLAG_KNOW_PLUSES);</a>
<a name="ln1708"> </a>
<a name="ln1709">    if ((ego != SPARM_NORMAL || enchanted) &amp;&amp; item_type_known(item) &amp;&amp; verbose)</a>
<a name="ln1710">    {</a>
<a name="ln1711">        description += &quot;\n\n&quot;;</a>
<a name="ln1712"> </a>
<a name="ln1713">        switch (ego)</a>
<a name="ln1714">        {</a>
<a name="ln1715">        case SPARM_RUNNING:</a>
<a name="ln1716">            if (item.sub_type == ARM_NAGA_BARDING)</a>
<a name="ln1717">                description += &quot;It allows its wearer to slither at a great speed.&quot;;</a>
<a name="ln1718">            else</a>
<a name="ln1719">                description += &quot;It allows its wearer to run at a great speed.&quot;;</a>
<a name="ln1720">            break;</a>
<a name="ln1721">        case SPARM_FIRE_RESISTANCE:</a>
<a name="ln1722">            description += &quot;It protects its wearer from heat.&quot;;</a>
<a name="ln1723">            break;</a>
<a name="ln1724">        case SPARM_COLD_RESISTANCE:</a>
<a name="ln1725">            description += &quot;It protects its wearer from cold.&quot;;</a>
<a name="ln1726">            break;</a>
<a name="ln1727">        case SPARM_POISON_RESISTANCE:</a>
<a name="ln1728">            description += &quot;It protects its wearer from poison.&quot;;</a>
<a name="ln1729">            break;</a>
<a name="ln1730">        case SPARM_SEE_INVISIBLE:</a>
<a name="ln1731">            description += &quot;It allows its wearer to see invisible things.&quot;;</a>
<a name="ln1732">            break;</a>
<a name="ln1733">        case SPARM_INVISIBILITY:</a>
<a name="ln1734">            description += &quot;When activated it hides its wearer from &quot;</a>
<a name="ln1735">                &quot;the sight of others, but also increases &quot;</a>
<a name="ln1736">                &quot;their metabolic rate by a large amount.&quot;;</a>
<a name="ln1737">            break;</a>
<a name="ln1738">        case SPARM_STRENGTH:</a>
<a name="ln1739">            description += &quot;It increases the physical power of its wearer (+3 to strength).&quot;;</a>
<a name="ln1740">            break;</a>
<a name="ln1741">        case SPARM_DEXTERITY:</a>
<a name="ln1742">            description += &quot;It increases the dexterity of its wearer (+3 to dexterity).&quot;;</a>
<a name="ln1743">            break;</a>
<a name="ln1744">        case SPARM_INTELLIGENCE:</a>
<a name="ln1745">            description += &quot;It makes you more clever (+3 to intelligence).&quot;;</a>
<a name="ln1746">            break;</a>
<a name="ln1747">        case SPARM_PONDEROUSNESS:</a>
<a name="ln1748">            description += &quot;It is very cumbersome, thus slowing your movement.&quot;;</a>
<a name="ln1749">            break;</a>
<a name="ln1750">        case SPARM_FLYING:</a>
<a name="ln1751">            description += &quot;It can be activated to allow its wearer to &quot;</a>
<a name="ln1752">                &quot;fly indefinitely.&quot;;</a>
<a name="ln1753">            break;</a>
<a name="ln1754">        case SPARM_MAGIC_RESISTANCE:</a>
<a name="ln1755">            description += &quot;It increases its wearer's resistance &quot;</a>
<a name="ln1756">                &quot;to enchantments.&quot;;</a>
<a name="ln1757">            break;</a>
<a name="ln1758">        case SPARM_PROTECTION:</a>
<a name="ln1759">            description += &quot;It protects its wearer from harm (+3 to AC).&quot;;</a>
<a name="ln1760">            break;</a>
<a name="ln1761">        case SPARM_STEALTH:</a>
<a name="ln1762">            description += &quot;It enhances the stealth of its wearer.&quot;;</a>
<a name="ln1763">            break;</a>
<a name="ln1764">        case SPARM_RESISTANCE:</a>
<a name="ln1765">            description += &quot;It protects its wearer from the effects &quot;</a>
<a name="ln1766">                &quot;of both cold and heat.&quot;;</a>
<a name="ln1767">            break;</a>
<a name="ln1768">        case SPARM_POSITIVE_ENERGY:</a>
<a name="ln1769">            description += &quot;It protects its wearer from &quot;</a>
<a name="ln1770">                &quot;the effects of negative energy.&quot;;</a>
<a name="ln1771">            break;</a>
<a name="ln1772"> </a>
<a name="ln1773">        // This is only for robes.</a>
<a name="ln1774">        case SPARM_ARCHMAGI:</a>
<a name="ln1775">            description += &quot;It increases the power of its wearer's &quot;</a>
<a name="ln1776">                &quot;magical spells.&quot;;</a>
<a name="ln1777">            break;</a>
<a name="ln1778">#if TAG_MAJOR_VERSION == 34</a>
<a name="ln1779">        case SPARM_PRESERVATION:</a>
<a name="ln1780">            description += &quot;It does nothing special.&quot;;</a>
<a name="ln1781">            break;</a>
<a name="ln1782">#endif</a>
<a name="ln1783">        case SPARM_REFLECTION:</a>
<a name="ln1784">            description += &quot;It reflects blocked things back in the &quot;</a>
<a name="ln1785">                &quot;direction they came from.&quot;;</a>
<a name="ln1786">            break;</a>
<a name="ln1787"> </a>
<a name="ln1788">        case SPARM_SPIRIT_SHIELD:</a>
<a name="ln1789">            description += &quot;It shields its wearer from harm at the cost &quot;</a>
<a name="ln1790">                &quot;of magical power.&quot;;</a>
<a name="ln1791">            break;</a>
<a name="ln1792"> </a>
<a name="ln1793">        case SPARM_NORMAL:</a>
<a name="ln1794">            ASSERT(enchanted);</a>
<a name="ln1795">            description += &quot;It has no special ego (it is not resistant to &quot;</a>
<a name="ln1796">                           &quot;fire, etc), but is still enchanted in some way - &quot;</a>
<a name="ln1797">                           &quot;positive or negative.&quot;;</a>
<a name="ln1798"> </a>
<a name="ln1799">            break;</a>
<a name="ln1800"> </a>
<a name="ln1801">        // This is only for gloves.</a>
<a name="ln1802">        case SPARM_ARCHERY:</a>
<a name="ln1803">            description += &quot;It improves your effectiveness with ranged &quot;</a>
<a name="ln1804">                           &quot;weaponry, such as bows and javelins (Slay+4).&quot;;</a>
<a name="ln1805">            break;</a>
<a name="ln1806"> </a>
<a name="ln1807">        // These are only for scarves.</a>
<a name="ln1808">        case SPARM_REPULSION:</a>
<a name="ln1809">            description += &quot;It protects its wearer by repelling missiles.&quot;;</a>
<a name="ln1810">            break;</a>
<a name="ln1811"> </a>
<a name="ln1812">        case SPARM_CLOUD_IMMUNE:</a>
<a name="ln1813">            description += &quot;It completely protects its wearer from the effects of clouds.&quot;;</a>
<a name="ln1814">            break;</a>
<a name="ln1815">        }</a>
<a name="ln1816">    }</a>
<a name="ln1817"> </a>
<a name="ln1818">    if (is_artefact(item))</a>
<a name="ln1819">    {</a>
<a name="ln1820">        string rand_desc = _randart_descrip(item);</a>
<a name="ln1821">        if (!rand_desc.empty())</a>
<a name="ln1822">        {</a>
<a name="ln1823">            description += &quot;\n&quot;;</a>
<a name="ln1824">            description += rand_desc;</a>
<a name="ln1825">        }</a>
<a name="ln1826"> </a>
<a name="ln1827">        // Can't happen, right? (XXX)</a>
<a name="ln1828">        if (!item_ident(item, ISFLAG_KNOW_PROPERTIES) &amp;&amp; item_type_known(item))</a>
<a name="ln1829">            description += &quot;\nThis armour may have some hidden properties.&quot;;</a>
<a name="ln1830">    }</a>
<a name="ln1831">    else</a>
<a name="ln1832">    {</a>
<a name="ln1833">        const int max_ench = armour_max_enchant(item);</a>
<a name="ln1834">        if (item.plus &lt; max_ench || !item_ident(item, ISFLAG_KNOW_PLUSES))</a>
<a name="ln1835">        {</a>
<a name="ln1836">            description += &quot;\n\nIt can be maximally enchanted to +&quot;</a>
<a name="ln1837">                           + to_string(max_ench) + &quot;.&quot;;</a>
<a name="ln1838">        }</a>
<a name="ln1839">        else</a>
<a name="ln1840">            description += &quot;\n\nIt cannot be enchanted further.&quot;;</a>
<a name="ln1841"> </a>
<a name="ln1842">    }</a>
<a name="ln1843"> </a>
<a name="ln1844">    // Only displayed if the player exists (not for item lookup from the menu).</a>
<a name="ln1845">    if (crawl_state.need_save</a>
<a name="ln1846">        &amp;&amp; can_wear_armour(item, false, true)</a>
<a name="ln1847">        &amp;&amp; item_ident(item, ISFLAG_KNOW_PLUSES)</a>
<a name="ln1848">        &amp;&amp; !is_shield(item))</a>
<a name="ln1849">    {</a>
<a name="ln1850">        description += _armour_ac_change(item);</a>
<a name="ln1851">    }</a>
<a name="ln1852"> </a>
<a name="ln1853">    return description;</a>
<a name="ln1854">}</a>
<a name="ln1855"> </a>
<a name="ln1856">static string _describe_lignify_ac()</a>
<a name="ln1857">{</a>
<a name="ln1858">    const Form* tree_form = get_form(transformation::tree);</a>
<a name="ln1859">    vector&lt;const item_def *&gt; treeform_items;</a>
<a name="ln1860"> </a>
<a name="ln1861">    for (auto item : you.get_armour_items())</a>
<a name="ln1862">        if (tree_form-&gt;slot_available(get_equip_slot(item)))</a>
<a name="ln1863">            treeform_items.push_back(item);</a>
<a name="ln1864"> </a>
<a name="ln1865">    const int treeform_ac =</a>
<a name="ln1866">        (you.base_ac_with_specific_items(100, treeform_items)</a>
<a name="ln1867">         - you.racial_ac(true) - you.ac_changes_from_mutations()</a>
<a name="ln1868">         - get_form()-&gt;get_ac_bonus() + tree_form-&gt;get_ac_bonus()) / 100;</a>
<a name="ln1869"> </a>
<a name="ln1870">    return make_stringf(&quot;If you quaff this potion your AC will be %d.&quot;,</a>
<a name="ln1871">                        treeform_ac);</a>
<a name="ln1872">}</a>
<a name="ln1873"> </a>
<a name="ln1874">static string _describe_jewellery(const item_def &amp;item, bool verbose)</a>
<a name="ln1875">{</a>
<a name="ln1876">    string description;</a>
<a name="ln1877"> </a>
<a name="ln1878">    description.reserve(200);</a>
<a name="ln1879"> </a>
<a name="ln1880">    if (verbose &amp;&amp; !is_artefact(item)</a>
<a name="ln1881">        &amp;&amp; item_ident(item, ISFLAG_KNOW_PLUSES))</a>
<a name="ln1882">    {</a>
<a name="ln1883">        // Explicit description of ring power.</a>
<a name="ln1884">        if (item.plus != 0)</a>
<a name="ln1885">        {</a>
<a name="ln1886">            switch (item.sub_type)</a>
<a name="ln1887">            {</a>
<a name="ln1888">            case RING_PROTECTION:</a>
<a name="ln1889">                description += make_stringf(&quot;\nIt affects your AC (%+d).&quot;,</a>
<a name="ln1890">                                            item.plus);</a>
<a name="ln1891">                break;</a>
<a name="ln1892"> </a>
<a name="ln1893">            case RING_EVASION:</a>
<a name="ln1894">                description += make_stringf(&quot;\nIt affects your evasion (%+d).&quot;,</a>
<a name="ln1895">                                            item.plus);</a>
<a name="ln1896">                break;</a>
<a name="ln1897"> </a>
<a name="ln1898">            case RING_STRENGTH:</a>
<a name="ln1899">                description += make_stringf(&quot;\nIt affects your strength (%+d).&quot;,</a>
<a name="ln1900">                                            item.plus);</a>
<a name="ln1901">                break;</a>
<a name="ln1902"> </a>
<a name="ln1903">            case RING_INTELLIGENCE:</a>
<a name="ln1904">                description += make_stringf(&quot;\nIt affects your intelligence (%+d).&quot;,</a>
<a name="ln1905">                                            item.plus);</a>
<a name="ln1906">                break;</a>
<a name="ln1907"> </a>
<a name="ln1908">            case RING_DEXTERITY:</a>
<a name="ln1909">                description += make_stringf(&quot;\nIt affects your dexterity (%+d).&quot;,</a>
<a name="ln1910">                                            item.plus);</a>
<a name="ln1911">                break;</a>
<a name="ln1912"> </a>
<a name="ln1913">            case RING_SLAYING:</a>
<a name="ln1914">                description += make_stringf(&quot;\nIt affects your accuracy and&quot;</a>
<a name="ln1915">                      &quot; damage with ranged weapons and melee attacks (%+d).&quot;,</a>
<a name="ln1916">                      item.plus);</a>
<a name="ln1917">                break;</a>
<a name="ln1918"> </a>
<a name="ln1919">            case AMU_REFLECTION:</a>
<a name="ln1920">                description += make_stringf(&quot;\nIt affects your shielding (%+d).&quot;,</a>
<a name="ln1921">                                            item.plus);</a>
<a name="ln1922">                break;</a>
<a name="ln1923"> </a>
<a name="ln1924">            default:</a>
<a name="ln1925">                break;</a>
<a name="ln1926">            }</a>
<a name="ln1927">        }</a>
<a name="ln1928">    }</a>
<a name="ln1929"> </a>
<a name="ln1930">    // Artefact properties.</a>
<a name="ln1931">    if (is_artefact(item))</a>
<a name="ln1932">    {</a>
<a name="ln1933">        string rand_desc = _randart_descrip(item);</a>
<a name="ln1934">        if (!rand_desc.empty())</a>
<a name="ln1935">        {</a>
<a name="ln1936">            description += &quot;\n&quot;;</a>
<a name="ln1937">            description += rand_desc;</a>
<a name="ln1938">        }</a>
<a name="ln1939">        if (!item_ident(item, ISFLAG_KNOW_PROPERTIES) ||</a>
<a name="ln1940">            !item_ident(item, ISFLAG_KNOW_TYPE))</a>
<a name="ln1941">        {</a>
<a name="ln1942">            description += &quot;\nThis &quot;;</a>
<a name="ln1943">            description += (jewellery_is_amulet(item) ? &quot;amulet&quot; : &quot;ring&quot;);</a>
<a name="ln1944">            description += &quot; may have hidden properties.&quot;;</a>
<a name="ln1945">        }</a>
<a name="ln1946">    }</a>
<a name="ln1947"> </a>
<a name="ln1948">    return description;</a>
<a name="ln1949">}</a>
<a name="ln1950"> </a>
<a name="ln1951">bool is_dumpable_artefact(const item_def &amp;item)</a>
<a name="ln1952">{</a>
<a name="ln1953">    return is_known_artefact(item) &amp;&amp; item_ident(item, ISFLAG_KNOW_PROPERTIES);</a>
<a name="ln1954">}</a>
<a name="ln1955"> </a>
<a name="ln1956">/**</a>
<a name="ln1957"> * Describe a specified item.</a>
<a name="ln1958"> *</a>
<a name="ln1959"> * @param item    The specified item.</a>
<a name="ln1960"> * @param verbose Controls various switches for the length of the description.</a>
<a name="ln1961"> * @param dump    This controls which style the name is shown in.</a>
<a name="ln1962"> * @param lookup  If true, the name is not shown at all.</a>
<a name="ln1963"> *   If either of those two are true, the DB description is not shown.</a>
<a name="ln1964"> * @return a string with the name, db desc, and some other data.</a>
<a name="ln1965"> */</a>
<a name="ln1966">string get_item_description(const item_def &amp;item, bool verbose,</a>
<a name="ln1967">                            bool dump, bool lookup)</a>
<a name="ln1968">{</a>
<a name="ln1969">    ostringstream description;</a>
<a name="ln1970"> </a>
<a name="ln1971">#ifdef DEBUG_DIAGNOSTICS</a>
<a name="ln1972">    if (!dump &amp;&amp; !you.suppress_wizard)</a>
<a name="ln1973">    {</a>
<a name="ln1974">        description &lt;&lt; setfill('0');</a>
<a name="ln1975">        description &lt;&lt; &quot;\n\n&quot;</a>
<a name="ln1976">                    &lt;&lt; &quot;base: &quot; &lt;&lt; static_cast&lt;int&gt;(item.base_type)</a>
<a name="ln1977">                    &lt;&lt; &quot; sub: &quot; &lt;&lt; static_cast&lt;int&gt;(item.sub_type)</a>
<a name="ln1978">                    &lt;&lt; &quot; plus: &quot; &lt;&lt; item.plus &lt;&lt; &quot; plus2: &quot; &lt;&lt; item.plus2</a>
<a name="ln1979">                    &lt;&lt; &quot; special: &quot; &lt;&lt; item.special</a>
<a name="ln1980">                    &lt;&lt; &quot;\n&quot;</a>
<a name="ln1981">                    &lt;&lt; &quot;quant: &quot; &lt;&lt; item.quantity</a>
<a name="ln1982">                    &lt;&lt; &quot; rnd?: &quot; &lt;&lt; static_cast&lt;int&gt;(item.rnd)</a>
<a name="ln1983">                    &lt;&lt; &quot; flags: &quot; &lt;&lt; hex &lt;&lt; setw(8) &lt;&lt; item.flags</a>
<a name="ln1984">                    &lt;&lt; dec &lt;&lt; &quot;\n&quot;</a>
<a name="ln1985">                    &lt;&lt; &quot;x: &quot; &lt;&lt; item.pos.x &lt;&lt; &quot; y: &quot; &lt;&lt; item.pos.y</a>
<a name="ln1986">                    &lt;&lt; &quot; link: &quot; &lt;&lt; item.link</a>
<a name="ln1987">                    &lt;&lt; &quot; slot: &quot; &lt;&lt; item.slot</a>
<a name="ln1988">                    &lt;&lt; &quot; ident_type: &quot;</a>
<a name="ln1989">                    &lt;&lt; get_ident_type(item)</a>
<a name="ln1990">                    &lt;&lt; &quot;\nannotate: &quot;</a>
<a name="ln1991">                    &lt;&lt; stash_annotate_item(STASH_LUA_SEARCH_ANNOTATE, &amp;item);</a>
<a name="ln1992">    }</a>
<a name="ln1993">#endif</a>
<a name="ln1994"> </a>
<a name="ln1995">    if (verbose || (item.base_type != OBJ_WEAPONS</a>
<a name="ln1996">                    &amp;&amp; item.base_type != OBJ_ARMOUR</a>
<a name="ln1997">                    &amp;&amp; item.base_type != OBJ_BOOKS))</a>
<a name="ln1998">    {</a>
<a name="ln1999">        description &lt;&lt; &quot;\n\n&quot;;</a>
<a name="ln2000"> </a>
<a name="ln2001">        bool need_base_desc = !lookup;</a>
<a name="ln2002"> </a>
<a name="ln2003">        if (dump)</a>
<a name="ln2004">        {</a>
<a name="ln2005">            description &lt;&lt; &quot;[&quot;</a>
<a name="ln2006">                        &lt;&lt; item.name(DESC_DBNAME, true, false, false)</a>
<a name="ln2007">                        &lt;&lt; &quot;]&quot;;</a>
<a name="ln2008">            need_base_desc = false;</a>
<a name="ln2009">        }</a>
<a name="ln2010">        else if (is_unrandom_artefact(item) &amp;&amp; item_type_known(item))</a>
<a name="ln2011">        {</a>
<a name="ln2012">            const string desc = getLongDescription(get_artefact_name(item));</a>
<a name="ln2013">            if (!desc.empty())</a>
<a name="ln2014">            {</a>
<a name="ln2015">                description &lt;&lt; desc;</a>
<a name="ln2016">                need_base_desc = false;</a>
<a name="ln2017">                description.seekp((streamoff)-1, ios_base::cur);</a>
<a name="ln2018">                description &lt;&lt; &quot; &quot;;</a>
<a name="ln2019">            }</a>
<a name="ln2020">        }</a>
<a name="ln2021">        // Randart jewellery properties will be listed later,</a>
<a name="ln2022">        // just describe artefact status here.</a>
<a name="ln2023">        else if (is_artefact(item) &amp;&amp; item_type_known(item)</a>
<a name="ln2024">                 &amp;&amp; item.base_type == OBJ_JEWELLERY)</a>
<a name="ln2025">        {</a>
<a name="ln2026">            description &lt;&lt; &quot;It is an ancient artefact.&quot;;</a>
<a name="ln2027">            need_base_desc = false;</a>
<a name="ln2028">        }</a>
<a name="ln2029"> </a>
<a name="ln2030">        if (need_base_desc)</a>
<a name="ln2031">        {</a>
<a name="ln2032">            string db_name = item.name(DESC_DBNAME, true, false, false);</a>
<a name="ln2033">            string db_desc = getLongDescription(db_name);</a>
<a name="ln2034"> </a>
<a name="ln2035">            if (db_desc.empty())</a>
<a name="ln2036">            {</a>
<a name="ln2037">                if (item_type_known(item))</a>
<a name="ln2038">                {</a>
<a name="ln2039">                    description &lt;&lt; &quot;[ERROR: no desc for item name '&quot; &lt;&lt; db_name</a>
<a name="ln2040">                                &lt;&lt; &quot;']. Perhaps this item has been removed?\n&quot;;</a>
<a name="ln2041">                }</a>
<a name="ln2042">                else</a>
<a name="ln2043">                {</a>
<a name="ln2044">                    description &lt;&lt; uppercase_first(item.name(DESC_A, true,</a>
<a name="ln2045">                                                             false, false));</a>
<a name="ln2046">                    description &lt;&lt; &quot;.\n&quot;;</a>
<a name="ln2047">                }</a>
<a name="ln2048">            }</a>
<a name="ln2049">            else</a>
<a name="ln2050">                description &lt;&lt; db_desc;</a>
<a name="ln2051"> </a>
<a name="ln2052">            // Get rid of newline at end of description; in most cases we</a>
<a name="ln2053">            // will be adding &quot;\n\n&quot; immediately, and we want only one,</a>
<a name="ln2054">            // not two, blank lines. This allow allows the &quot;unpleasant&quot;</a>
<a name="ln2055">            // message for chunks to appear on the same line.</a>
<a name="ln2056">            description.seekp((streamoff)-1, ios_base::cur);</a>
<a name="ln2057">            description &lt;&lt; &quot; &quot;;</a>
<a name="ln2058">        }</a>
<a name="ln2059">    }</a>
<a name="ln2060"> </a>
<a name="ln2061">    bool need_extra_line = true;</a>
<a name="ln2062">    string desc;</a>
<a name="ln2063">    switch (item.base_type)</a>
<a name="ln2064">    {</a>
<a name="ln2065">    // Weapons, armour, jewellery, books might be artefacts.</a>
<a name="ln2066">    case OBJ_WEAPONS:</a>
<a name="ln2067">        desc = _describe_weapon(item, verbose);</a>
<a name="ln2068">        if (desc.empty())</a>
<a name="ln2069">            need_extra_line = false;</a>
<a name="ln2070">        else</a>
<a name="ln2071">            description &lt;&lt; desc;</a>
<a name="ln2072">        break;</a>
<a name="ln2073"> </a>
<a name="ln2074">    case OBJ_ARMOUR:</a>
<a name="ln2075">        desc = _describe_armour(item, verbose);</a>
<a name="ln2076">        if (desc.empty())</a>
<a name="ln2077">            need_extra_line = false;</a>
<a name="ln2078">        else</a>
<a name="ln2079">            description &lt;&lt; desc;</a>
<a name="ln2080">        break;</a>
<a name="ln2081"> </a>
<a name="ln2082">    case OBJ_JEWELLERY:</a>
<a name="ln2083">        desc = _describe_jewellery(item, verbose);</a>
<a name="ln2084">        if (desc.empty())</a>
<a name="ln2085">            need_extra_line = false;</a>
<a name="ln2086">        else</a>
<a name="ln2087">            description &lt;&lt; desc;</a>
<a name="ln2088">        break;</a>
<a name="ln2089"> </a>
<a name="ln2090">    case OBJ_BOOKS:</a>
<a name="ln2091">        if (!verbose &amp;&amp; is_random_artefact(item))</a>
<a name="ln2092">        {</a>
<a name="ln2093">            desc += describe_item_spells(item);</a>
<a name="ln2094">            if (desc.empty())</a>
<a name="ln2095">                need_extra_line = false;</a>
<a name="ln2096">            else</a>
<a name="ln2097">                description &lt;&lt; desc;</a>
<a name="ln2098">        }</a>
<a name="ln2099">        break;</a>
<a name="ln2100"> </a>
<a name="ln2101">    case OBJ_MISSILES:</a>
<a name="ln2102">        description &lt;&lt; _describe_ammo(item);</a>
<a name="ln2103">        break;</a>
<a name="ln2104"> </a>
<a name="ln2105">    case OBJ_CORPSES:</a>
<a name="ln2106">        if (item.sub_type == CORPSE_SKELETON)</a>
<a name="ln2107">            break;</a>
<a name="ln2108"> </a>
<a name="ln2109">        // intentional fall-through</a>
<a name="ln2110">    case OBJ_FOOD:</a>
<a name="ln2111">        if (item.base_type == OBJ_CORPSES || item.sub_type == FOOD_CHUNK)</a>
<a name="ln2112">        {</a>
<a name="ln2113">            switch (determine_chunk_effect(item))</a>
<a name="ln2114">            {</a>
<a name="ln2115">            case CE_NOXIOUS:</a>
<a name="ln2116">                description &lt;&lt; &quot;\n\nThis meat is toxic.&quot;;</a>
<a name="ln2117">                break;</a>
<a name="ln2118">            default:</a>
<a name="ln2119">                break;</a>
<a name="ln2120">            }</a>
<a name="ln2121">        }</a>
<a name="ln2122">        break;</a>
<a name="ln2123"> </a>
<a name="ln2124">    case OBJ_STAVES:</a>
<a name="ln2125">        {</a>
<a name="ln2126">            string stats = &quot;\n&quot;;</a>
<a name="ln2127">            _append_weapon_stats(stats, item);</a>
<a name="ln2128">            description &lt;&lt; stats;</a>
<a name="ln2129">        }</a>
<a name="ln2130">        description &lt;&lt; &quot;\n\nIt falls into the 'Staves' category. &quot;;</a>
<a name="ln2131">        description &lt;&lt; _handedness_string(item);</a>
<a name="ln2132">        break;</a>
<a name="ln2133"> </a>
<a name="ln2134">    case OBJ_MISCELLANY:</a>
<a name="ln2135">        if (item.sub_type == MISC_ZIGGURAT &amp;&amp; you.zigs_completed)</a>
<a name="ln2136">        {</a>
<a name="ln2137">            const int zigs = you.zigs_completed;</a>
<a name="ln2138">            description &lt;&lt; &quot;\n\nIt is surrounded by a &quot;</a>
<a name="ln2139">                        &lt;&lt; (zigs &gt;= 27 ? &quot;blinding &quot; : // just plain silly</a>
<a name="ln2140">                            zigs &gt;=  9 ? &quot;dazzling &quot; :</a>
<a name="ln2141">                            zigs &gt;=  3 ? &quot;bright &quot; :</a>
<a name="ln2142">                                         &quot;gentle &quot;)</a>
<a name="ln2143">                        &lt;&lt; &quot;glow.&quot;;</a>
<a name="ln2144">        }</a>
<a name="ln2145">        if (is_xp_evoker(item))</a>
<a name="ln2146">        {</a>
<a name="ln2147">            description &lt;&lt; &quot;\n\nOnce &quot;</a>
<a name="ln2148">                        &lt;&lt; (item.sub_type == MISC_LIGHTNING_ROD</a>
<a name="ln2149">                            ? &quot;all charges have been used&quot;</a>
<a name="ln2150">                            : &quot;activated&quot;)</a>
<a name="ln2151">                        &lt;&lt; &quot;, this device &quot;</a>
<a name="ln2152">                        &lt;&lt; (!item_is_horn_of_geryon(item) ?</a>
<a name="ln2153">                           &quot;and all other devices of its kind &quot; : &quot;&quot;)</a>
<a name="ln2154">                        &lt;&lt; &quot;will be rendered temporarily inert. However, &quot;</a>
<a name="ln2155">                        &lt;&lt; (!item_is_horn_of_geryon(item) ? &quot;they &quot; : &quot;it &quot;)</a>
<a name="ln2156">                        &lt;&lt; &quot;will recharge as you gain experience.&quot;</a>
<a name="ln2157">                        &lt;&lt; (!evoker_charges(item.sub_type) ?</a>
<a name="ln2158">                           &quot; The device is presently inert.&quot; : &quot;&quot;);</a>
<a name="ln2159">        }</a>
<a name="ln2160">        break;</a>
<a name="ln2161"> </a>
<a name="ln2162">    case OBJ_POTIONS:</a>
<a name="ln2163">        if (item.sub_type == POT_LIGNIFY &amp;&amp; verbose)</a>
<a name="ln2164">            description &lt;&lt; &quot;\n\n&quot; + _describe_lignify_ac();</a>
<a name="ln2165">        break;</a>
<a name="ln2166"> </a>
<a name="ln2167">    case OBJ_SCROLLS:</a>
<a name="ln2168">    case OBJ_ORBS:</a>
<a name="ln2169">    case OBJ_GOLD:</a>
<a name="ln2170">    case OBJ_RUNES:</a>
<a name="ln2171">    case OBJ_WANDS:</a>
<a name="ln2172">#if TAG_MAJOR_VERSION == 34</a>
<a name="ln2173">    case OBJ_RODS:</a>
<a name="ln2174">#endif</a>
<a name="ln2175">        // No extra processing needed for these item types.</a>
<a name="ln2176">        break;</a>
<a name="ln2177"> </a>
<a name="ln2178">    default:</a>
<a name="ln2179">        die(&quot;Bad item class&quot;);</a>
<a name="ln2180">    }</a>
<a name="ln2181"> </a>
<a name="ln2182">    if (!verbose &amp;&amp; item_known_cursed(item))</a>
<a name="ln2183">        description &lt;&lt; &quot;\nIt has a curse placed upon it.&quot;;</a>
<a name="ln2184">    else</a>
<a name="ln2185">    {</a>
<a name="ln2186">        if (verbose)</a>
<a name="ln2187">        {</a>
<a name="ln2188">            if (need_extra_line)</a>
<a name="ln2189">                description &lt;&lt; &quot;\n&quot;;</a>
<a name="ln2190">            if (item_known_cursed(item))</a>
<a name="ln2191">                description &lt;&lt; &quot;\nIt has a curse placed upon it.&quot;;</a>
<a name="ln2192"> </a>
<a name="ln2193">            if (is_artefact(item))</a>
<a name="ln2194">            {</a>
<a name="ln2195">                if (item.base_type == OBJ_ARMOUR</a>
<a name="ln2196">                    || item.base_type == OBJ_WEAPONS)</a>
<a name="ln2197">                {</a>
<a name="ln2198">                    description &lt;&lt; &quot;\nThis ancient artefact cannot be changed &quot;</a>
<a name="ln2199">                        &quot;by magic or mundane means.&quot;;</a>
<a name="ln2200">                }</a>
<a name="ln2201">                // Randart jewellery has already displayed this line.</a>
<a name="ln2202">                else if (item.base_type != OBJ_JEWELLERY</a>
<a name="ln2203">                         || (item_type_known(item) &amp;&amp; is_unrandom_artefact(item)))</a>
<a name="ln2204">                {</a>
<a name="ln2205">                    description &lt;&lt; &quot;\nIt is an ancient artefact.&quot;;</a>
<a name="ln2206">                }</a>
<a name="ln2207">            }</a>
<a name="ln2208">        }</a>
<a name="ln2209">    }</a>
<a name="ln2210"> </a>
<a name="ln2211">    if (god_hates_item(item))</a>
<a name="ln2212">    {</a>
<a name="ln2213">        description &lt;&lt; &quot;\n\n&quot; &lt;&lt; uppercase_first(god_name(you.religion))</a>
<a name="ln2214">                    &lt;&lt; &quot; disapproves of the use of such an item.&quot;;</a>
<a name="ln2215">    }</a>
<a name="ln2216"> </a>
<a name="ln2217">    if (verbose &amp;&amp; origin_describable(item))</a>
<a name="ln2218">        description &lt;&lt; &quot;\n&quot; &lt;&lt; origin_desc(item) &lt;&lt; &quot;.&quot;;</a>
<a name="ln2219"> </a>
<a name="ln2220">    // This information is obscure and differs per-item, so looking it up in</a>
<a name="ln2221">    // a docs file you don't know to exist is tedious.</a>
<a name="ln2222">    if (verbose)</a>
<a name="ln2223">    {</a>
<a name="ln2224">        description &lt;&lt; &quot;\n\n&quot; &lt;&lt; &quot;Stash search prefixes: &quot;</a>
<a name="ln2225">                    &lt;&lt; userdef_annotate_item(STASH_LUA_SEARCH_ANNOTATE, &amp;item);</a>
<a name="ln2226">        string menu_prefix = item_prefix(item, false);</a>
<a name="ln2227">        if (!menu_prefix.empty())</a>
<a name="ln2228">            description &lt;&lt; &quot;\nMenu/colouring prefixes: &quot; &lt;&lt; menu_prefix;</a>
<a name="ln2229">    }</a>
<a name="ln2230"> </a>
<a name="ln2231">    return description.str();</a>
<a name="ln2232">}</a>
<a name="ln2233"> </a>
<a name="ln2234">string get_cloud_desc(cloud_type cloud, bool include_title)</a>
<a name="ln2235">{</a>
<a name="ln2236">    if (cloud == CLOUD_NONE)</a>
<a name="ln2237">        return &quot;&quot;;</a>
<a name="ln2238">    const string cl_name = cloud_type_name(cloud);</a>
<a name="ln2239">    const string cl_desc = getLongDescription(cl_name + &quot; cloud&quot;);</a>
<a name="ln2240"> </a>
<a name="ln2241">    string ret;</a>
<a name="ln2242">    if (include_title)</a>
<a name="ln2243">        ret = &quot;A cloud of &quot; + cl_name + (cl_desc.empty() ? &quot;.&quot; : &quot;.\n\n&quot;);</a>
<a name="ln2244">    ret += cl_desc + extra_cloud_info(cloud);</a>
<a name="ln2245">    return ret;</a>
<a name="ln2246">}</a>
<a name="ln2247"> </a>
<a name="ln2248">static vector&lt;pair&lt;string,string&gt;&gt; _get_feature_extra_descs(const coord_def &amp;pos)</a>
<a name="ln2249">{</a>
<a name="ln2250">    vector&lt;pair&lt;string,string&gt;&gt; ret;</a>
<a name="ln2251">    dungeon_feature_type feat = env.map_knowledge(pos).feat();</a>
<a name="ln2252">    if (feat_is_wall(feat) &amp;&amp; env.map_knowledge(pos).flags &amp; MAP_ICY)</a>
<a name="ln2253">    {</a>
<a name="ln2254">        ret.emplace_back(pair&lt;string,string&gt;(&quot;A covering of ice.&quot;,</a>
<a name="ln2255">                    getLongDescription(&quot;ice covered&quot;)));</a>
<a name="ln2256">    }</a>
<a name="ln2257">    else if (!feat_is_solid(feat))</a>
<a name="ln2258">    {</a>
<a name="ln2259">        if (haloed(pos) &amp;&amp; !umbraed(pos))</a>
<a name="ln2260">        {</a>
<a name="ln2261">            ret.emplace_back(pair&lt;string,string&gt;(</a>
<a name="ln2262">                    &quot;A halo.&quot;, getLongDescription(&quot;haloed&quot;)));</a>
<a name="ln2263">        }</a>
<a name="ln2264">        if (umbraed(pos) &amp;&amp; !haloed(pos))</a>
<a name="ln2265">        {</a>
<a name="ln2266">            ret.emplace_back(pair&lt;string,string&gt;(</a>
<a name="ln2267">                    &quot;An umbra.&quot;, getLongDescription(&quot;umbraed&quot;)));</a>
<a name="ln2268">        }</a>
<a name="ln2269">        if (liquefied(pos))</a>
<a name="ln2270">        {</a>
<a name="ln2271">            ret.emplace_back(pair&lt;string,string&gt;(</a>
<a name="ln2272">                    &quot;Liquefied ground.&quot;, getLongDescription(&quot;liquefied&quot;)));</a>
<a name="ln2273">        }</a>
<a name="ln2274">        if (disjunction_haloed(pos))</a>
<a name="ln2275">        {</a>
<a name="ln2276">            ret.emplace_back(pair&lt;string,string&gt;(</a>
<a name="ln2277">                    &quot;Translocational energy.&quot;, getLongDescription(&quot;disjunction haloed&quot;)));</a>
<a name="ln2278">        }</a>
<a name="ln2279">    }</a>
<a name="ln2280">    if (const cloud_type cloud = env.map_knowledge(pos).cloud())</a>
<a name="ln2281">    {</a>
<a name="ln2282">        ret.emplace_back(pair&lt;string,string&gt;(</a>
<a name="ln2283">                    &quot;A cloud of &quot;+cloud_type_name(cloud)+&quot;.&quot;, get_cloud_desc(cloud, false)));</a>
<a name="ln2284">    }</a>
<a name="ln2285">    return ret;</a>
<a name="ln2286">}</a>
<a name="ln2287"> </a>
<a name="ln2288">void get_feature_desc(const coord_def &amp;pos, describe_info &amp;inf, bool include_extra)</a>
<a name="ln2289">{</a>
<a name="ln2290">    dungeon_feature_type feat = env.map_knowledge(pos).feat();</a>
<a name="ln2291"> </a>
<a name="ln2292">    string desc      = feature_description_at(pos, false, DESC_A);</a>
<a name="ln2293">    string db_name   = feat == DNGN_ENTER_SHOP ? &quot;a shop&quot; : desc;</a>
<a name="ln2294">    strip_suffix(db_name, &quot; (summoned)&quot;);</a>
<a name="ln2295">    string long_desc = getLongDescription(db_name);</a>
<a name="ln2296"> </a>
<a name="ln2297">    inf.title = uppercase_first(desc);</a>
<a name="ln2298">    if (!ends_with(desc, &quot;.&quot;) &amp;&amp; !ends_with(desc, &quot;!&quot;)</a>
<a name="ln2299">        &amp;&amp; !ends_with(desc, &quot;?&quot;))</a>
<a name="ln2300">    {</a>
<a name="ln2301">        inf.title += &quot;.&quot;;</a>
<a name="ln2302">    }</a>
<a name="ln2303"> </a>
<a name="ln2304">    const string marker_desc =</a>
<a name="ln2305">        env.markers.property_at(pos, MAT_ANY, &quot;feature_description_long&quot;);</a>
<a name="ln2306"> </a>
<a name="ln2307">    // suppress this if the feature changed out of view</a>
<a name="ln2308">    if (!marker_desc.empty() &amp;&amp; grd(pos) == feat)</a>
<a name="ln2309">        long_desc += marker_desc;</a>
<a name="ln2310"> </a>
<a name="ln2311">    // Display branch descriptions on the entries to those branches.</a>
<a name="ln2312">    if (feat_is_stair(feat))</a>
<a name="ln2313">    {</a>
<a name="ln2314">        for (branch_iterator it; it; ++it)</a>
<a name="ln2315">        {</a>
<a name="ln2316">            if (it-&gt;entry_stairs == feat)</a>
<a name="ln2317">            {</a>
<a name="ln2318">                long_desc += &quot;\n&quot;;</a>
<a name="ln2319">                long_desc += getLongDescription(it-&gt;shortname);</a>
<a name="ln2320">                break;</a>
<a name="ln2321">            }</a>
<a name="ln2322">        }</a>
<a name="ln2323">    }</a>
<a name="ln2324"> </a>
<a name="ln2325">    // mention the ability to pray at altars</a>
<a name="ln2326">    if (feat_is_altar(feat))</a>
<a name="ln2327">    {</a>
<a name="ln2328">        long_desc +=</a>
<a name="ln2329">            make_stringf(&quot;\n(Pray here with '%s' to learn more.)\n&quot;,</a>
<a name="ln2330">                         command_to_string(CMD_GO_DOWNSTAIRS).c_str());</a>
<a name="ln2331">    }</a>
<a name="ln2332"> </a>
<a name="ln2333">    // mention that permanent trees are usually flammable</a>
<a name="ln2334">    // (expect for autumnal trees in Wucad Mu's Monastery)</a>
<a name="ln2335">    if (feat_is_tree(feat) &amp;&amp; !is_temp_terrain(pos)</a>
<a name="ln2336">        &amp;&amp; env.markers.property_at(pos, MAT_ANY, &quot;veto_fire&quot;) != &quot;veto&quot;)</a>
<a name="ln2337">    {</a>
<a name="ln2338">        long_desc += &quot;\nIt is susceptible to bolts of lightning&quot;;</a>
<a name="ln2339">        long_desc += &quot; and to sufficiently intense sources of fire.&quot;;</a>
<a name="ln2340">    }</a>
<a name="ln2341"> </a>
<a name="ln2342">    inf.body &lt;&lt; long_desc;</a>
<a name="ln2343"> </a>
<a name="ln2344">    if (include_extra)</a>
<a name="ln2345">    {</a>
<a name="ln2346">        auto extra_descs = _get_feature_extra_descs(pos);</a>
<a name="ln2347">        for (const auto &amp;d : extra_descs)</a>
<a name="ln2348">            inf.body &lt;&lt; (d == extra_descs.back() ? &quot;&quot; : &quot;\n&quot;) &lt;&lt; d.second;</a>
<a name="ln2349">    }</a>
<a name="ln2350"> </a>
<a name="ln2351">    inf.quote = getQuoteString(db_name);</a>
<a name="ln2352">}</a>
<a name="ln2353"> </a>
<a name="ln2354">void describe_feature_wide(const coord_def&amp; pos)</a>
<a name="ln2355">{</a>
<a name="ln2356">    typedef struct {</a>
<a name="ln2357">        string title, body, quote;</a>
<a name="ln2358">        tile_def tile;</a>
<a name="ln2359">    } feat_info;</a>
<a name="ln2360"> </a>
<a name="ln2361">    vector&lt;feat_info&gt; feats;</a>
<a name="ln2362"> </a>
<a name="ln2363">    {</a>
<a name="ln2364">        describe_info inf;</a>
<a name="ln2365">        get_feature_desc(pos, inf, false);</a>
<a name="ln2366">        feat_info f = { &quot;&quot;, &quot;&quot;, &quot;&quot;, tile_def(TILEG_TODO, TEX_GUI)};</a>
<a name="ln2367">        f.title = inf.title;</a>
<a name="ln2368">        f.body = trimmed_string(inf.body.str());</a>
<a name="ln2369">#ifdef USE_TILE</a>
<a name="ln2370">        tileidx_t tile = tileidx_feature(pos);</a>
<a name="ln2371">        apply_variations(env.tile_flv(pos), &amp;tile, pos);</a>
<a name="ln2372">        f.tile = tile_def(tile, get_dngn_tex(tile));</a>
<a name="ln2373">#endif</a>
<a name="ln2374">        f.quote = trimmed_string(inf.quote);</a>
<a name="ln2375">        feats.emplace_back(f);</a>
<a name="ln2376">    }</a>
<a name="ln2377">    auto extra_descs = _get_feature_extra_descs(pos);</a>
<a name="ln2378">    for (const auto &amp;desc : extra_descs)</a>
<a name="ln2379">    {</a>
<a name="ln2380">        feat_info f = { &quot;&quot;, &quot;&quot;, &quot;&quot;, tile_def(TILEG_TODO, TEX_GUI)};</a>
<a name="ln2381">        f.title = desc.first;</a>
<a name="ln2382">        f.body = trimmed_string(desc.second);</a>
<a name="ln2383">#ifdef USE_TILE</a>
<a name="ln2384">        if (desc.first == &quot;A halo.&quot;)</a>
<a name="ln2385">            f.tile = tile_def(TILE_HALO_RANGE, TEX_FEAT);</a>
<a name="ln2386">        else if (desc.first == &quot;An umbra.&quot;)</a>
<a name="ln2387">            f.tile = tile_def(TILE_UMBRA, TEX_FEAT);</a>
<a name="ln2388">        else if  (desc.first == &quot;Liquefied ground.&quot;)</a>
<a name="ln2389">            f.tile = tile_def(TILE_LIQUEFACTION, TEX_FLOOR);</a>
<a name="ln2390">        else if (desc.first == &quot;A covering of ice.&quot;)</a>
<a name="ln2391">            f.tile = tile_def(TILE_FLOOR_ICY, TEX_FLOOR);</a>
<a name="ln2392">        else</a>
<a name="ln2393">            f.tile = tile_def(env.tile_bk_cloud(pos) &amp; ~TILE_FLAG_FLYING, TEX_DEFAULT);</a>
<a name="ln2394">#endif</a>
<a name="ln2395">        feats.emplace_back(f);</a>
<a name="ln2396">    }</a>
<a name="ln2397">    if (crawl_state.game_is_hints())</a>
<a name="ln2398">    {</a>
<a name="ln2399">        string hint_text = trimmed_string(hints_describe_pos(pos.x, pos.y));</a>
<a name="ln2400">        if (!hint_text.empty())</a>
<a name="ln2401">        {</a>
<a name="ln2402">            feat_info f = { &quot;&quot;, &quot;&quot;, &quot;&quot;, tile_def(TILEG_TODO, TEX_GUI)};</a>
<a name="ln2403">            f.title = &quot;Hints.&quot;;</a>
<a name="ln2404">            f.body = hint_text;</a>
<a name="ln2405">            f.tile = tile_def(TILEG_STARTUP_HINTS, TEX_GUI);</a>
<a name="ln2406">            feats.emplace_back(f);</a>
<a name="ln2407">        }</a>
<a name="ln2408">    }</a>
<a name="ln2409"> </a>
<a name="ln2410">    auto scroller = make_shared&lt;Scroller&gt;();</a>
<a name="ln2411">    auto vbox = make_shared&lt;Box&gt;(Widget::VERT);</a>
<a name="ln2412"> </a>
<a name="ln2413">    for (const auto &amp;feat : feats)</a>
<a name="ln2414">    {</a>
<a name="ln2415">        auto title_hbox = make_shared&lt;Box&gt;(Widget::HORZ);</a>
<a name="ln2416">#ifdef USE_TILE</a>
<a name="ln2417">        auto icon = make_shared&lt;Image&gt;();</a>
<a name="ln2418">        icon-&gt;set_tile(feat.tile);</a>
<a name="ln2419">        title_hbox-&gt;add_child(move(icon));</a>
<a name="ln2420">#endif</a>
<a name="ln2421">        auto title = make_shared&lt;Text&gt;(feat.title);</a>
<a name="ln2422">        title-&gt;set_margin_for_sdl(0, 0, 0, 10);</a>
<a name="ln2423">        title_hbox-&gt;add_child(move(title));</a>
<a name="ln2424">        title_hbox-&gt;set_cross_alignment(Widget::CENTER);</a>
<a name="ln2425"> </a>
<a name="ln2426">        const bool has_desc = feat.body != feat.title &amp;&amp; feat.body != &quot;&quot;;</a>
<a name="ln2427"> </a>
<a name="ln2428">        if (has_desc || &amp;feat != &amp;feats.back())</a>
<a name="ln2429">        {</a>
<a name="ln2430">            title_hbox-&gt;set_margin_for_crt(0, 0, 1, 0);</a>
<a name="ln2431">            title_hbox-&gt;set_margin_for_sdl(0, 0, 20, 0);</a>
<a name="ln2432">        }</a>
<a name="ln2433">        vbox-&gt;add_child(move(title_hbox));</a>
<a name="ln2434"> </a>
<a name="ln2435">        if (has_desc)</a>
<a name="ln2436">        {</a>
<a name="ln2437">            formatted_string desc_text = formatted_string::parse_string(feat.body);</a>
<a name="ln2438">            if (!feat.quote.empty())</a>
<a name="ln2439">            {</a>
<a name="ln2440">                desc_text.cprintf(&quot;\n\n&quot;);</a>
<a name="ln2441">                desc_text += formatted_string::parse_string(feat.quote);</a>
<a name="ln2442">            }</a>
<a name="ln2443">            auto text = make_shared&lt;Text&gt;(desc_text);</a>
<a name="ln2444">            if (&amp;feat != &amp;feats.back())</a>
<a name="ln2445">            {</a>
<a name="ln2446">                text-&gt;set_margin_for_sdl(0, 0, 20, 0);</a>
<a name="ln2447">                text-&gt;set_margin_for_crt(0, 0, 1, 0);</a>
<a name="ln2448">            }</a>
<a name="ln2449">            text-&gt;set_wrap_text(true);</a>
<a name="ln2450">            vbox-&gt;add_child(text);</a>
<a name="ln2451">        }</a>
<a name="ln2452">    }</a>
<a name="ln2453">#ifdef USE_TILE_LOCAL</a>
<a name="ln2454">    vbox-&gt;max_size().width = tiles.get_crt_font()-&gt;char_width()*80;</a>
<a name="ln2455">#endif</a>
<a name="ln2456">    scroller-&gt;set_child(move(vbox));</a>
<a name="ln2457"> </a>
<a name="ln2458">    auto popup = make_shared&lt;ui::Popup&gt;(scroller);</a>
<a name="ln2459"> </a>
<a name="ln2460">    bool done = false;</a>
<a name="ln2461">    popup-&gt;on_keydown_event([&amp;](const KeyEvent&amp; ev) {</a>
<a name="ln2462">        done = !scroller-&gt;on_event(ev);</a>
<a name="ln2463">        return true;</a>
<a name="ln2464">    });</a>
<a name="ln2465"> </a>
<a name="ln2466">#ifdef USE_TILE_WEB</a>
<a name="ln2467">    tiles.json_open_object();</a>
<a name="ln2468">    tiles.json_open_array(&quot;feats&quot;);</a>
<a name="ln2469">    for (const auto &amp;feat : feats)</a>
<a name="ln2470">    {</a>
<a name="ln2471">        tiles.json_open_object();</a>
<a name="ln2472">        tiles.json_write_string(&quot;title&quot;, feat.title);</a>
<a name="ln2473">        tiles.json_write_string(&quot;body&quot;, trimmed_string(feat.body));</a>
<a name="ln2474">        tiles.json_write_string(&quot;quote&quot;, trimmed_string(feat.quote));</a>
<a name="ln2475">        tiles.json_open_object(&quot;tile&quot;);</a>
<a name="ln2476">        tiles.json_write_int(&quot;t&quot;, feat.tile.tile);</a>
<a name="ln2477">        tiles.json_write_int(&quot;tex&quot;, feat.tile.tex);</a>
<a name="ln2478">        if (feat.tile.ymax != TILE_Y)</a>
<a name="ln2479">            tiles.json_write_int(&quot;ymax&quot;, feat.tile.ymax);</a>
<a name="ln2480">        tiles.json_close_object();</a>
<a name="ln2481">        tiles.json_close_object();</a>
<a name="ln2482">    }</a>
<a name="ln2483">    tiles.json_close_array();</a>
<a name="ln2484">    tiles.push_ui_layout(&quot;describe-feature-wide&quot;, 0);</a>
<a name="ln2485">    popup-&gt;on_layout_pop([](){ tiles.pop_ui_layout(); });</a>
<a name="ln2486">#endif</a>
<a name="ln2487"> </a>
<a name="ln2488">    ui::run_layout(move(popup), done);</a>
<a name="ln2489">}</a>
<a name="ln2490"> </a>
<a name="ln2491">void describe_feature_type(dungeon_feature_type feat)</a>
<a name="ln2492">{</a>
<a name="ln2493">    describe_info inf;</a>
<a name="ln2494">    string name = feature_description(feat, NUM_TRAPS, &quot;&quot;, DESC_A);</a>
<a name="ln2495">    string title = uppercase_first(name);</a>
<a name="ln2496">    if (!ends_with(title, &quot;.&quot;) &amp;&amp; !ends_with(title, &quot;!&quot;) &amp;&amp; !ends_with(title, &quot;?&quot;))</a>
<a name="ln2497">        title += &quot;.&quot;;</a>
<a name="ln2498">    inf.title = title;</a>
<a name="ln2499">    inf.body &lt;&lt; getLongDescription(name);</a>
<a name="ln2500">#ifdef USE_TILE</a>
<a name="ln2501">    const tileidx_t idx = tileidx_feature_base(feat);</a>
<a name="ln2502">    tile_def tile = tile_def(idx, get_dngn_tex(idx));</a>
<a name="ln2503">    show_description(inf, &amp;tile);</a>
<a name="ln2504">#else</a>
<a name="ln2505">    show_description(inf);</a>
<a name="ln2506">#endif</a>
<a name="ln2507">}</a>
<a name="ln2508"> </a>
<a name="ln2509">void get_item_desc(const item_def &amp;item, describe_info &amp;inf)</a>
<a name="ln2510">{</a>
<a name="ln2511">    // Don't use verbose descriptions if the item contains spells,</a>
<a name="ln2512">    // so we can actually output these spells if space is scarce.</a>
<a name="ln2513">    const bool verbose = !item.has_spells();</a>
<a name="ln2514">    string name = item.name(DESC_INVENTORY_EQUIP) + &quot;.&quot;;</a>
<a name="ln2515">    if (!in_inventory(item))</a>
<a name="ln2516">        name = uppercase_first(name);</a>
<a name="ln2517">    inf.body &lt;&lt; name &lt;&lt; get_item_description(item, verbose);</a>
<a name="ln2518">}</a>
<a name="ln2519"> </a>
<a name="ln2520">static vector&lt;command_type&gt; _allowed_actions(const item_def&amp; item)</a>
<a name="ln2521">{</a>
<a name="ln2522">    vector&lt;command_type&gt; actions;</a>
<a name="ln2523">    actions.push_back(CMD_ADJUST_INVENTORY);</a>
<a name="ln2524">    if (item_equip_slot(item) == EQ_WEAPON)</a>
<a name="ln2525">        actions.push_back(CMD_UNWIELD_WEAPON);</a>
<a name="ln2526">    switch (item.base_type)</a>
<a name="ln2527">    {</a>
<a name="ln2528">    case OBJ_WEAPONS:</a>
<a name="ln2529">    case OBJ_STAVES:</a>
<a name="ln2530">        if (_could_set_training_target(item, false))</a>
<a name="ln2531">            actions.push_back(CMD_SET_SKILL_TARGET);</a>
<a name="ln2532">        // intentional fallthrough</a>
<a name="ln2533">    case OBJ_MISCELLANY:</a>
<a name="ln2534">        if (!item_is_equipped(item))</a>
<a name="ln2535">        {</a>
<a name="ln2536">            if (item_is_wieldable(item))</a>
<a name="ln2537">                actions.push_back(CMD_WIELD_WEAPON);</a>
<a name="ln2538">            if (is_throwable(&amp;you, item))</a>
<a name="ln2539">                actions.push_back(CMD_QUIVER_ITEM);</a>
<a name="ln2540">        }</a>
<a name="ln2541">        break;</a>
<a name="ln2542">    case OBJ_MISSILES:</a>
<a name="ln2543">        if (_could_set_training_target(item, false))</a>
<a name="ln2544">            actions.push_back(CMD_SET_SKILL_TARGET);</a>
<a name="ln2545">        if (you.species != SP_FELID)</a>
<a name="ln2546">            actions.push_back(CMD_QUIVER_ITEM);</a>
<a name="ln2547">        break;</a>
<a name="ln2548">    case OBJ_ARMOUR:</a>
<a name="ln2549">        if (_could_set_training_target(item, false))</a>
<a name="ln2550">            actions.push_back(CMD_SET_SKILL_TARGET);</a>
<a name="ln2551">        if (item_is_equipped(item))</a>
<a name="ln2552">            actions.push_back(CMD_REMOVE_ARMOUR);</a>
<a name="ln2553">        else</a>
<a name="ln2554">            actions.push_back(CMD_WEAR_ARMOUR);</a>
<a name="ln2555">        break;</a>
<a name="ln2556">    case OBJ_FOOD:</a>
<a name="ln2557">        if (can_eat(item, true, false))</a>
<a name="ln2558">            actions.push_back(CMD_EAT);</a>
<a name="ln2559">        break;</a>
<a name="ln2560">    case OBJ_SCROLLS:</a>
<a name="ln2561">    //case OBJ_BOOKS: these are handled differently</a>
<a name="ln2562">        actions.push_back(CMD_READ);</a>
<a name="ln2563">        break;</a>
<a name="ln2564">    case OBJ_JEWELLERY:</a>
<a name="ln2565">        if (item_is_equipped(item))</a>
<a name="ln2566">            actions.push_back(CMD_REMOVE_JEWELLERY);</a>
<a name="ln2567">        else</a>
<a name="ln2568">            actions.push_back(CMD_WEAR_JEWELLERY);</a>
<a name="ln2569">        break;</a>
<a name="ln2570">    case OBJ_POTIONS:</a>
<a name="ln2571">        if (!you_foodless()) // mummies and lich form forbidden</a>
<a name="ln2572">            actions.push_back(CMD_QUAFF);</a>
<a name="ln2573">        break;</a>
<a name="ln2574">    default:</a>
<a name="ln2575">        ;</a>
<a name="ln2576">    }</a>
<a name="ln2577">#if defined(CLUA_BINDINGS)</a>
<a name="ln2578">    if (clua.callbooleanfn(false, &quot;ch_item_wieldable&quot;, &quot;i&quot;, &amp;item))</a>
<a name="ln2579">        actions.push_back(CMD_WIELD_WEAPON);</a>
<a name="ln2580">#endif</a>
<a name="ln2581"> </a>
<a name="ln2582">    if (item_is_evokable(item))</a>
<a name="ln2583">        actions.push_back(CMD_EVOKE);</a>
<a name="ln2584"> </a>
<a name="ln2585">    actions.push_back(CMD_DROP);</a>
<a name="ln2586"> </a>
<a name="ln2587">    if (!crawl_state.game_is_tutorial())</a>
<a name="ln2588">        actions.push_back(CMD_INSCRIBE_ITEM);</a>
<a name="ln2589"> </a>
<a name="ln2590">    return actions;</a>
<a name="ln2591">}</a>
<a name="ln2592"> </a>
<a name="ln2593">static string _actions_desc(const vector&lt;command_type&gt;&amp; actions, const item_def&amp; item)</a>
<a name="ln2594">{</a>
<a name="ln2595">    static const map&lt;command_type, string&gt; act_str =</a>
<a name="ln2596">    {</a>
<a name="ln2597">        { CMD_WIELD_WEAPON, &quot;(w)ield&quot; },</a>
<a name="ln2598">        { CMD_UNWIELD_WEAPON, &quot;(u)nwield&quot; },</a>
<a name="ln2599">        { CMD_QUIVER_ITEM, &quot;(q)uiver&quot; },</a>
<a name="ln2600">        { CMD_WEAR_ARMOUR, &quot;(w)ear&quot; },</a>
<a name="ln2601">        { CMD_REMOVE_ARMOUR, &quot;(t)ake off&quot; },</a>
<a name="ln2602">        { CMD_EVOKE, &quot;e(v)oke&quot; },</a>
<a name="ln2603">        { CMD_EAT, &quot;(e)at&quot; },</a>
<a name="ln2604">        { CMD_READ, &quot;(r)ead&quot; },</a>
<a name="ln2605">        { CMD_WEAR_JEWELLERY, &quot;(p)ut on&quot; },</a>
<a name="ln2606">        { CMD_REMOVE_JEWELLERY, &quot;(r)emove&quot; },</a>
<a name="ln2607">        { CMD_QUAFF, &quot;(q)uaff&quot; },</a>
<a name="ln2608">        { CMD_DROP, &quot;(d)rop&quot; },</a>
<a name="ln2609">        { CMD_INSCRIBE_ITEM, &quot;(i)nscribe&quot; },</a>
<a name="ln2610">        { CMD_ADJUST_INVENTORY, &quot;(=)adjust&quot; },</a>
<a name="ln2611">        { CMD_SET_SKILL_TARGET, &quot;(s)kill&quot; },</a>
<a name="ln2612">    };</a>
<a name="ln2613">    return comma_separated_fn(begin(actions), end(actions),</a>
<a name="ln2614">                                [] (command_type cmd)</a>
<a name="ln2615">                                {</a>
<a name="ln2616">                                    return act_str.at(cmd);</a>
<a name="ln2617">                                },</a>
<a name="ln2618">                                &quot;, or &quot;)</a>
<a name="ln2619">           + &quot; the &quot; + item.name(DESC_BASENAME) + &quot;.&quot;;</a>
<a name="ln2620">}</a>
<a name="ln2621"> </a>
<a name="ln2622">// Take a key and a list of commands and return the command from the list</a>
<a name="ln2623">// that corresponds to the key. Note that some keys are overloaded (but with</a>
<a name="ln2624">// mutually-exclusive actions), so it's not just a simple lookup.</a>
<a name="ln2625">static command_type _get_action(int key, vector&lt;command_type&gt; actions)</a>
<a name="ln2626">{</a>
<a name="ln2627">    static const map&lt;command_type, int&gt; act_key =</a>
<a name="ln2628">    {</a>
<a name="ln2629">        { CMD_WIELD_WEAPON,     'w' },</a>
<a name="ln2630">        { CMD_UNWIELD_WEAPON,   'u' },</a>
<a name="ln2631">        { CMD_QUIVER_ITEM,      'q' },</a>
<a name="ln2632">        { CMD_WEAR_ARMOUR,      'w' },</a>
<a name="ln2633">        { CMD_REMOVE_ARMOUR,    't' },</a>
<a name="ln2634">        { CMD_EVOKE,            'v' },</a>
<a name="ln2635">        { CMD_EAT,              'e' },</a>
<a name="ln2636">        { CMD_READ,             'r' },</a>
<a name="ln2637">        { CMD_WEAR_JEWELLERY,   'p' },</a>
<a name="ln2638">        { CMD_REMOVE_JEWELLERY, 'r' },</a>
<a name="ln2639">        { CMD_QUAFF,            'q' },</a>
<a name="ln2640">        { CMD_DROP,             'd' },</a>
<a name="ln2641">        { CMD_INSCRIBE_ITEM,    'i' },</a>
<a name="ln2642">        { CMD_ADJUST_INVENTORY, '=' },</a>
<a name="ln2643">        { CMD_SET_SKILL_TARGET, 's' },</a>
<a name="ln2644">    };</a>
<a name="ln2645"> </a>
<a name="ln2646">    key = tolower_safe(key);</a>
<a name="ln2647"> </a>
<a name="ln2648">    for (auto cmd : actions)</a>
<a name="ln2649">        if (key == act_key.at(cmd))</a>
<a name="ln2650">            return cmd;</a>
<a name="ln2651"> </a>
<a name="ln2652">    return CMD_NO_CMD;</a>
<a name="ln2653">}</a>
<a name="ln2654"> </a>
<a name="ln2655">/**</a>
<a name="ln2656"> * Do the specified action on the specified item.</a>
<a name="ln2657"> *</a>
<a name="ln2658"> * @param item    the item to have actions done on</a>
<a name="ln2659"> * @param action  the action to do</a>
<a name="ln2660"> * @return whether to stay in the inventory menu afterwards</a>
<a name="ln2661"> */</a>
<a name="ln2662">static bool _do_action(item_def &amp;item, const command_type action)</a>
<a name="ln2663">{</a>
<a name="ln2664">    if (action == CMD_NO_CMD)</a>
<a name="ln2665">        return true;</a>
<a name="ln2666"> </a>
<a name="ln2667">    const int slot = item.link;</a>
<a name="ln2668">    ASSERT_RANGE(slot, 0, ENDOFPACK);</a>
<a name="ln2669"> </a>
<a name="ln2670">    switch (action)</a>
<a name="ln2671">    {</a>
<a name="ln2672">    case CMD_WIELD_WEAPON:     wield_weapon(true, slot);            break;</a>
<a name="ln2673">    case CMD_UNWIELD_WEAPON:   wield_weapon(true, SLOT_BARE_HANDS); break;</a>
<a name="ln2674">    case CMD_QUIVER_ITEM:      quiver_item(slot);                   break;</a>
<a name="ln2675">    case CMD_WEAR_ARMOUR:      wear_armour(slot);                   break;</a>
<a name="ln2676">    case CMD_REMOVE_ARMOUR:    takeoff_armour(slot);                break;</a>
<a name="ln2677">    case CMD_EAT:              eat_food(slot);                      break;</a>
<a name="ln2678">    case CMD_READ:             read(&amp;item);                         break;</a>
<a name="ln2679">    case CMD_WEAR_JEWELLERY:   puton_ring(slot);                    break;</a>
<a name="ln2680">    case CMD_REMOVE_JEWELLERY: remove_ring(slot, true);             break;</a>
<a name="ln2681">    case CMD_QUAFF:            drink(&amp;item);                        break;</a>
<a name="ln2682">    case CMD_DROP:             drop_item(slot, item.quantity);      break;</a>
<a name="ln2683">    case CMD_INSCRIBE_ITEM:    inscribe_item(item);                 break;</a>
<a name="ln2684">    case CMD_ADJUST_INVENTORY: adjust_item(slot);                   break;</a>
<a name="ln2685">    case CMD_SET_SKILL_TARGET: target_item(item);                   break;</a>
<a name="ln2686">    case CMD_EVOKE:</a>
<a name="ln2687">#ifndef USE_TILE_LOCAL</a>
<a name="ln2688">        redraw_console_sidebar();</a>
<a name="ln2689">#endif</a>
<a name="ln2690">        evoke_item(slot);</a>
<a name="ln2691">        break;</a>
<a name="ln2692">    default:</a>
<a name="ln2693">        die(&quot;illegal inventory cmd %d&quot;, action);</a>
<a name="ln2694">    }</a>
<a name="ln2695">    return false;</a>
<a name="ln2696">}</a>
<a name="ln2697"> </a>
<a name="ln2698">void target_item(item_def &amp;item)</a>
<a name="ln2699">{</a>
<a name="ln2700">    const skill_type skill = _item_training_skill(item);</a>
<a name="ln2701">    if (skill == SK_NONE)</a>
<a name="ln2702">        return;</a>
<a name="ln2703"> </a>
<a name="ln2704">    const int target = _item_training_target(item);</a>
<a name="ln2705">    if (target == 0)</a>
<a name="ln2706">        return;</a>
<a name="ln2707"> </a>
<a name="ln2708">    you.set_training_target(skill, target, true);</a>
<a name="ln2709">    // ensure that the skill is at least enabled</a>
<a name="ln2710">    if (you.train[skill] == TRAINING_DISABLED)</a>
<a name="ln2711">        you.train[skill] = TRAINING_ENABLED;</a>
<a name="ln2712">    you.train_alt[skill] = you.train[skill];</a>
<a name="ln2713">    reset_training();</a>
<a name="ln2714">}</a>
<a name="ln2715"> </a>
<a name="ln2716">/**</a>
<a name="ln2717"> *  Describe any item in the game.</a>
<a name="ln2718"> *</a>
<a name="ln2719"> *  @param item       the item to be described.</a>
<a name="ln2720"> *  @param fixup_desc a function (possibly null) to modify the</a>
<a name="ln2721"> *                    description before it's displayed.</a>
<a name="ln2722"> *  @return whether to stay in the inventory menu afterwards.</a>
<a name="ln2723"> */</a>
<a name="ln2724">bool describe_item(item_def &amp;item, function&lt;void (string&amp;)&gt; fixup_desc)</a>
<a name="ln2725">{</a>
<a name="ln2726">    if (!item.defined())</a>
<a name="ln2727">        return true;</a>
<a name="ln2728"> </a>
<a name="ln2729">    string name = item.name(DESC_INVENTORY_EQUIP) + &quot;.&quot;;</a>
<a name="ln2730">    if (!in_inventory(item))</a>
<a name="ln2731">        name = uppercase_first(name);</a>
<a name="ln2732"> </a>
<a name="ln2733">    string desc = get_item_description(item, true, false);</a>
<a name="ln2734"> </a>
<a name="ln2735">    string quote;</a>
<a name="ln2736">    if (is_unrandom_artefact(item) &amp;&amp; item_type_known(item))</a>
<a name="ln2737">        quote = getQuoteString(get_artefact_name(item));</a>
<a name="ln2738">    else</a>
<a name="ln2739">        quote = getQuoteString(item.name(DESC_DBNAME, true, false, false));</a>
<a name="ln2740"> </a>
<a name="ln2741">    if (!(crawl_state.game_is_hints_tutorial()</a>
<a name="ln2742">          || quote.empty()))</a>
<a name="ln2743">    {</a>
<a name="ln2744">        desc += &quot;\n\n&quot; + quote;</a>
<a name="ln2745">    }</a>
<a name="ln2746"> </a>
<a name="ln2747">    if (crawl_state.game_is_hints())</a>
<a name="ln2748">        desc += &quot;\n\n&quot; + hints_describe_item(item);</a>
<a name="ln2749"> </a>
<a name="ln2750">    if (fixup_desc)</a>
<a name="ln2751">        fixup_desc(desc);</a>
<a name="ln2752"> </a>
<a name="ln2753">    formatted_string fs_desc = formatted_string::parse_string(desc);</a>
<a name="ln2754"> </a>
<a name="ln2755">    spellset spells = item_spellset(item);</a>
<a name="ln2756">    formatted_string spells_desc;</a>
<a name="ln2757">    describe_spellset(spells, &amp;item, spells_desc, nullptr);</a>
<a name="ln2758">#ifdef USE_TILE_WEB</a>
<a name="ln2759">    string desc_without_spells = fs_desc.to_colour_string();</a>
<a name="ln2760">#endif</a>
<a name="ln2761">    fs_desc += spells_desc;</a>
<a name="ln2762"> </a>
<a name="ln2763">    const bool do_actions = in_inventory(item) // Dead men use no items.</a>
<a name="ln2764">            &amp;&amp; !(you.pending_revival || crawl_state.updating_scores);</a>
<a name="ln2765"> </a>
<a name="ln2766">    vector&lt;command_type&gt; actions;</a>
<a name="ln2767">    if (do_actions)</a>
<a name="ln2768">        actions = _allowed_actions(item);</a>
<a name="ln2769"> </a>
<a name="ln2770">    auto vbox = make_shared&lt;Box&gt;(Widget::VERT);</a>
<a name="ln2771">    auto title_hbox = make_shared&lt;Box&gt;(Widget::HORZ);</a>
<a name="ln2772"> </a>
<a name="ln2773">#ifdef USE_TILE</a>
<a name="ln2774">    vector&lt;tile_def&gt; item_tiles;</a>
<a name="ln2775">    get_tiles_for_item(item, item_tiles, true);</a>
<a name="ln2776">    if (item_tiles.size() &gt; 0)</a>
<a name="ln2777">    {</a>
<a name="ln2778">        auto tiles_stack = make_shared&lt;Stack&gt;();</a>
<a name="ln2779">        for (const auto &amp;tile : item_tiles)</a>
<a name="ln2780">        {</a>
<a name="ln2781">            auto icon = make_shared&lt;Image&gt;();</a>
<a name="ln2782">            icon-&gt;set_tile(tile);</a>
<a name="ln2783">            tiles_stack-&gt;add_child(move(icon));</a>
<a name="ln2784">        }</a>
<a name="ln2785">        title_hbox-&gt;add_child(move(tiles_stack));</a>
<a name="ln2786">    }</a>
<a name="ln2787">#endif</a>
<a name="ln2788"> </a>
<a name="ln2789">    auto title = make_shared&lt;Text&gt;(name);</a>
<a name="ln2790">    title-&gt;set_margin_for_sdl(0, 0, 0, 10);</a>
<a name="ln2791">    title_hbox-&gt;add_child(move(title));</a>
<a name="ln2792"> </a>
<a name="ln2793">    title_hbox-&gt;set_cross_alignment(Widget::CENTER);</a>
<a name="ln2794">    title_hbox-&gt;set_margin_for_crt(0, 0, 1, 0);</a>
<a name="ln2795">    title_hbox-&gt;set_margin_for_sdl(0, 0, 20, 0);</a>
<a name="ln2796">    vbox-&gt;add_child(move(title_hbox));</a>
<a name="ln2797"> </a>
<a name="ln2798">    auto scroller = make_shared&lt;Scroller&gt;();</a>
<a name="ln2799">    auto text = make_shared&lt;Text&gt;(fs_desc.trim());</a>
<a name="ln2800">    text-&gt;set_wrap_text(true);</a>
<a name="ln2801">    scroller-&gt;set_child(text);</a>
<a name="ln2802">    vbox-&gt;add_child(scroller);</a>
<a name="ln2803"> </a>
<a name="ln2804">    formatted_string footer_text(&quot;&quot;, CYAN);</a>
<a name="ln2805">    if (!actions.empty())</a>
<a name="ln2806">    {</a>
<a name="ln2807">        if (!spells.empty())</a>
<a name="ln2808">            footer_text.cprintf(&quot;Select a spell, or &quot;);</a>
<a name="ln2809">        footer_text += formatted_string(_actions_desc(actions, item));</a>
<a name="ln2810">        auto footer = make_shared&lt;Text&gt;();</a>
<a name="ln2811">        footer-&gt;set_text(footer_text);</a>
<a name="ln2812">        footer-&gt;set_margin_for_crt(1, 0, 0, 0);</a>
<a name="ln2813">        footer-&gt;set_margin_for_sdl(20, 0, 0, 0);</a>
<a name="ln2814">        vbox-&gt;add_child(move(footer));</a>
<a name="ln2815">    }</a>
<a name="ln2816"> </a>
<a name="ln2817">#ifdef USE_TILE_LOCAL</a>
<a name="ln2818">    vbox-&gt;max_size().width = tiles.get_crt_font()-&gt;char_width()*80;</a>
<a name="ln2819">#endif</a>
<a name="ln2820"> </a>
<a name="ln2821">    auto popup = make_shared&lt;ui::Popup&gt;(move(vbox));</a>
<a name="ln2822"> </a>
<a name="ln2823">    bool done = false;</a>
<a name="ln2824">    command_type action;</a>
<a name="ln2825">    int lastch;</a>
<a name="ln2826">    popup-&gt;on_keydown_event([&amp;](const KeyEvent&amp; ev) {</a>
<a name="ln2827">        const auto key = ev.key() == '{' ? 'i' : ev.key();</a>
<a name="ln2828">        lastch = key;</a>
<a name="ln2829">        action = _get_action(key, actions);</a>
<a name="ln2830">        if (action != CMD_NO_CMD)</a>
<a name="ln2831">            done = true;</a>
<a name="ln2832">        else if (key == ' ' || key == CK_ESCAPE)</a>
<a name="ln2833">            done = true;</a>
<a name="ln2834">        else if (scroller-&gt;on_event(ev))</a>
<a name="ln2835">            return true;</a>
<a name="ln2836">        const vector&lt;pair&lt;spell_type,char&gt;&gt; spell_map = map_chars_to_spells(spells, &amp;item);</a>
<a name="ln2837">        auto entry = find_if(spell_map.begin(), spell_map.end(),</a>
<a name="ln2838">                [key](const pair&lt;spell_type,char&gt;&amp; e) { return e.second == key; });</a>
<a name="ln2839">        if (entry == spell_map.end())</a>
<a name="ln2840">            return false;</a>
<a name="ln2841">        describe_spell(entry-&gt;first, nullptr, &amp;item);</a>
<a name="ln2842">        done = already_learning_spell();</a>
<a name="ln2843">        return true;</a>
<a name="ln2844">    });</a>
<a name="ln2845"> </a>
<a name="ln2846">#ifdef USE_TILE_WEB</a>
<a name="ln2847">    tiles.json_open_object();</a>
<a name="ln2848">    tiles.json_write_string(&quot;title&quot;, name);</a>
<a name="ln2849">    desc_without_spells += &quot;SPELLSET_PLACEHOLDER&quot;;</a>
<a name="ln2850">    trim_string(desc_without_spells);</a>
<a name="ln2851">    tiles.json_write_string(&quot;body&quot;, desc_without_spells);</a>
<a name="ln2852">    write_spellset(spells, &amp;item, nullptr);</a>
<a name="ln2853"> </a>
<a name="ln2854">    tiles.json_write_string(&quot;actions&quot;, footer_text.tostring());</a>
<a name="ln2855">    tiles.json_open_array(&quot;tiles&quot;);</a>
<a name="ln2856">    for (const auto &amp;tile : item_tiles)</a>
<a name="ln2857">    {</a>
<a name="ln2858">        tiles.json_open_object();</a>
<a name="ln2859">        tiles.json_write_int(&quot;t&quot;, tile.tile);</a>
<a name="ln2860">        tiles.json_write_int(&quot;tex&quot;, tile.tex);</a>
<a name="ln2861">        if (tile.ymax != TILE_Y)</a>
<a name="ln2862">            tiles.json_write_int(&quot;ymax&quot;, tile.ymax);</a>
<a name="ln2863">        tiles.json_close_object();</a>
<a name="ln2864">    }</a>
<a name="ln2865">    tiles.json_close_array();</a>
<a name="ln2866">    tiles.push_ui_layout(&quot;describe-item&quot;, 0);</a>
<a name="ln2867">    popup-&gt;on_layout_pop([](){ tiles.pop_ui_layout(); });</a>
<a name="ln2868">#endif</a>
<a name="ln2869"> </a>
<a name="ln2870">    ui::run_layout(move(popup), done);</a>
<a name="ln2871"> </a>
<a name="ln2872">    return _do_action(item, action);</a>
<a name="ln2873">}</a>
<a name="ln2874"> </a>
<a name="ln2875">void inscribe_item(item_def &amp;item)</a>
<a name="ln2876">{</a>
<a name="ln2877">    mprf_nocap(MSGCH_EQUIPMENT, &quot;%s&quot;, item.name(DESC_INVENTORY).c_str());</a>
<a name="ln2878"> </a>
<a name="ln2879">    const bool is_inscribed = !item.inscription.empty();</a>
<a name="ln2880">    string prompt = is_inscribed ? &quot;Replace inscription with what? &quot;</a>
<a name="ln2881">                                 : &quot;Inscribe with what? &quot;;</a>
<a name="ln2882"> </a>
<a name="ln2883">    char buf[79];</a>
<a name="ln2884">    int ret = msgwin_get_line(prompt, buf, sizeof buf, nullptr,</a>
<a name="ln2885">                              item.inscription);</a>
<a name="ln2886">    if (ret)</a>
<a name="ln2887">    {</a>
<a name="ln2888">        canned_msg(MSG_OK);</a>
<a name="ln2889">        return;</a>
<a name="ln2890">    }</a>
<a name="ln2891"> </a>
<a name="ln2892">    string new_inscrip = buf;</a>
<a name="ln2893">    trim_string_right(new_inscrip);</a>
<a name="ln2894"> </a>
<a name="ln2895">    if (item.inscription == new_inscrip)</a>
<a name="ln2896">    {</a>
<a name="ln2897">        canned_msg(MSG_OK);</a>
<a name="ln2898">        return;</a>
<a name="ln2899">    }</a>
<a name="ln2900"> </a>
<a name="ln2901">    item.inscription = new_inscrip;</a>
<a name="ln2902"> </a>
<a name="ln2903">    mprf_nocap(MSGCH_EQUIPMENT, &quot;%s&quot;, item.name(DESC_INVENTORY).c_str());</a>
<a name="ln2904">    you.wield_change  = true;</a>
<a name="ln2905">    you.redraw_quiver = true;</a>
<a name="ln2906">}</a>
<a name="ln2907"> </a>
<a name="ln2908">/**</a>
<a name="ln2909"> * List the simple calculated stats of a given spell, when cast by the player</a>
<a name="ln2910"> * in their current condition.</a>
<a name="ln2911"> *</a>
<a name="ln2912"> * @param spell     The spell in question.</a>
<a name="ln2913"> */</a>
<a name="ln2914">static string _player_spell_stats(const spell_type spell)</a>
<a name="ln2915">{</a>
<a name="ln2916">    string description;</a>
<a name="ln2917">    description += make_stringf(&quot;\nLevel: %d&quot;, spell_difficulty(spell));</a>
<a name="ln2918"> </a>
<a name="ln2919">    const string schools = spell_schools_string(spell);</a>
<a name="ln2920">    description +=</a>
<a name="ln2921">        make_stringf(&quot;        School%s: %s&quot;,</a>
<a name="ln2922">                     schools.find(&quot;/&quot;) != string::npos ? &quot;s&quot; : &quot;&quot;,</a>
<a name="ln2923">                     schools.c_str());</a>
<a name="ln2924"> </a>
<a name="ln2925">    if (!crawl_state.need_save</a>
<a name="ln2926">        || (get_spell_flags(spell) &amp; spflag::monster))</a>
<a name="ln2927">    {</a>
<a name="ln2928">        return description; // all other info is player-dependent</a>
<a name="ln2929">    }</a>
<a name="ln2930"> </a>
<a name="ln2931"> </a>
<a name="ln2932">    string failure;</a>
<a name="ln2933">    if (you.divine_exegesis)</a>
<a name="ln2934">        failure = &quot;0%&quot;;</a>
<a name="ln2935">    else</a>
<a name="ln2936">        failure = failure_rate_to_string(raw_spell_fail(spell));</a>
<a name="ln2937">    description += make_stringf(&quot;        Fail: %s&quot;, failure.c_str());</a>
<a name="ln2938"> </a>
<a name="ln2939">    description += &quot;\n\nPower : &quot;;</a>
<a name="ln2940">    description += spell_power_string(spell);</a>
<a name="ln2941">    description += &quot;\nRange : &quot;;</a>
<a name="ln2942">    description += spell_range_string(spell);</a>
<a name="ln2943">    description += &quot;\nHunger: &quot;;</a>
<a name="ln2944">    description += spell_hunger_string(spell);</a>
<a name="ln2945">    description += &quot;\nNoise : &quot;;</a>
<a name="ln2946">    description += spell_noise_string(spell);</a>
<a name="ln2947">    description += &quot;\n&quot;;</a>
<a name="ln2948">    return description;</a>
<a name="ln2949">}</a>
<a name="ln2950"> </a>
<a name="ln2951">string get_skill_description(skill_type skill, bool need_title)</a>
<a name="ln2952">{</a>
<a name="ln2953">    string lookup = skill_name(skill);</a>
<a name="ln2954">    string result = &quot;&quot;;</a>
<a name="ln2955"> </a>
<a name="ln2956">    if (need_title)</a>
<a name="ln2957">    {</a>
<a name="ln2958">        result = lookup;</a>
<a name="ln2959">        result += &quot;\n\n&quot;;</a>
<a name="ln2960">    }</a>
<a name="ln2961"> </a>
<a name="ln2962">    result += getLongDescription(lookup);</a>
<a name="ln2963"> </a>
<a name="ln2964">    switch (skill)</a>
<a name="ln2965">    {</a>
<a name="ln2966">        case SK_INVOCATIONS:</a>
<a name="ln2967">            if (you.species == SP_DEMIGOD)</a>
<a name="ln2968">            {</a>
<a name="ln2969">                result += &quot;\n&quot;;</a>
<a name="ln2970">                result += &quot;How on earth did you manage to pick this up?&quot;;</a>
<a name="ln2971">            }</a>
<a name="ln2972">            else if (you_worship(GOD_TROG))</a>
<a name="ln2973">            {</a>
<a name="ln2974">                result += &quot;\n&quot;;</a>
<a name="ln2975">                result += &quot;Note that Trog doesn't use Invocations, due to its &quot;</a>
<a name="ln2976">                          &quot;close connection to magic.&quot;;</a>
<a name="ln2977">            }</a>
<a name="ln2978">            break;</a>
<a name="ln2979"> </a>
<a name="ln2980">        case SK_SPELLCASTING:</a>
<a name="ln2981">            if (you_worship(GOD_TROG))</a>
<a name="ln2982">            {</a>
<a name="ln2983">                result += &quot;\n&quot;;</a>
<a name="ln2984">                result += &quot;Keep in mind, though, that Trog will greatly &quot;</a>
<a name="ln2985">                          &quot;disapprove of this.&quot;;</a>
<a name="ln2986">            }</a>
<a name="ln2987">            break;</a>
<a name="ln2988">        default:</a>
<a name="ln2989">            // No further information.</a>
<a name="ln2990">            break;</a>
<a name="ln2991">    }</a>
<a name="ln2992"> </a>
<a name="ln2993">    return result;</a>
<a name="ln2994">}</a>
<a name="ln2995"> </a>
<a name="ln2996">/// How much power do we think the given monster casts this spell with?</a>
<a name="ln2997">static int _hex_pow(const spell_type spell, const int hd)</a>
<a name="ln2998">{</a>
<a name="ln2999">    const int cap = 200;</a>
<a name="ln3000">    const int pow = mons_power_for_hd(spell, hd) / ENCH_POW_FACTOR;</a>
<a name="ln3001">    return min(cap, pow);</a>
<a name="ln3002">}</a>
<a name="ln3003"> </a>
<a name="ln3004">/**</a>
<a name="ln3005"> * What are the odds of the given spell, cast by a monster with the given</a>
<a name="ln3006"> * spell_hd, affecting the player?</a>
<a name="ln3007"> */</a>
<a name="ln3008">int hex_chance(const spell_type spell, const int hd)</a>
<a name="ln3009">{</a>
<a name="ln3010">    const int capped_pow = _hex_pow(spell, hd);</a>
<a name="ln3011">    const int chance = hex_success_chance(you.res_magic(), capped_pow,</a>
<a name="ln3012">                                          100, true);</a>
<a name="ln3013">    if (spell == SPELL_STRIP_RESISTANCE)</a>
<a name="ln3014">        return chance + (100 - chance) / 3; // ignores mr 1/3rd of the time</a>
<a name="ln3015">    return chance;</a>
<a name="ln3016">}</a>
<a name="ln3017"> </a>
<a name="ln3018">/**</a>
<a name="ln3019"> * Describe miscast effects from a spell</a>
<a name="ln3020"> *</a>
<a name="ln3021"> * @param spell</a>
<a name="ln3022"> */</a>
<a name="ln3023">static string _miscast_damage_string(spell_type spell)</a>
<a name="ln3024">{</a>
<a name="ln3025">    const map &lt;spschool, string&gt; damage_flavor = {</a>
<a name="ln3026">        { spschool::conjuration, &quot;irresistible&quot; },</a>
<a name="ln3027">        { spschool::necromancy, &quot;draining&quot; },</a>
<a name="ln3028">        { spschool::fire, &quot;fire&quot; },</a>
<a name="ln3029">        { spschool::ice, &quot;cold&quot; },</a>
<a name="ln3030">        { spschool::air, &quot;electric&quot; },</a>
<a name="ln3031">        { spschool::earth, &quot;fragmentation&quot; },</a>
<a name="ln3032">        { spschool::poison, &quot;poison&quot; },</a>
<a name="ln3033">    };</a>
<a name="ln3034"> </a>
<a name="ln3035">    const map &lt;spschool, string&gt; special_flavor = {</a>
<a name="ln3036">        { spschool::summoning, &quot;summon a nameless horror&quot; },</a>
<a name="ln3037">        { spschool::transmutation, &quot;polymorph you&quot; },</a>
<a name="ln3038">        { spschool::translocation, &quot;dimensionally anchor you&quot; },</a>
<a name="ln3039">    };</a>
<a name="ln3040"> </a>
<a name="ln3041">    spschools_type disciplines = get_spell_disciplines(spell);</a>
<a name="ln3042">    vector &lt;string&gt; descs;</a>
<a name="ln3043"> </a>
<a name="ln3044">    for (const auto flav : special_flavor)</a>
<a name="ln3045">        if (disciplines &amp; flav.first)</a>
<a name="ln3046">            descs.push_back(flav.second);</a>
<a name="ln3047"> </a>
<a name="ln3048">    if (disciplines &amp; (spschool::charms | spschool::hexes))</a>
<a name="ln3049">        descs.push_back(&quot;debuff and slow you&quot;);</a>
<a name="ln3050"> </a>
<a name="ln3051">    int dam = max_miscast_damage(spell);</a>
<a name="ln3052">    vector &lt;string&gt; dam_flavors;</a>
<a name="ln3053">    for (const auto flav : damage_flavor)</a>
<a name="ln3054">        if (disciplines &amp; flav.first)</a>
<a name="ln3055">            dam_flavors.push_back(flav.second);</a>
<a name="ln3056"> </a>
<a name="ln3057">    if (!dam_flavors.empty())</a>
<a name="ln3058">    {</a>
<a name="ln3059">        descs.push_back(make_stringf(&quot;deal up to %d %s damage&quot;, dam,</a>
<a name="ln3060">                                     comma_separated_line(dam_flavors.begin(),</a>
<a name="ln3061">                                                         dam_flavors.end(),</a>
<a name="ln3062">                                                         &quot; or &quot;).c_str()));</a>
<a name="ln3063">    }</a>
<a name="ln3064"> </a>
<a name="ln3065">    return (descs.size() &gt; 1 ? &quot;either &quot; : &quot;&quot;)</a>
<a name="ln3066">         + comma_separated_line(descs.begin(), descs.end(), &quot; or &quot;, &quot;; &quot;);</a>
<a name="ln3067">}</a>
<a name="ln3068"> </a>
<a name="ln3069">/**</a>
<a name="ln3070"> * Describe mostly non-numeric player-specific information about a spell.</a>
<a name="ln3071"> *</a>
<a name="ln3072"> * (E.g., your god's opinion of it, whether it's in a high-level book that</a>
<a name="ln3073"> * you can't memorise from, whether it's currently useless for whatever</a>
<a name="ln3074"> * reason...)</a>
<a name="ln3075"> *</a>
<a name="ln3076"> * @param spell     The spell in question.</a>
<a name="ln3077"> */</a>
<a name="ln3078">static string _player_spell_desc(spell_type spell)</a>
<a name="ln3079">{</a>
<a name="ln3080">    if (!crawl_state.need_save || (get_spell_flags(spell) &amp; spflag::monster))</a>
<a name="ln3081">        return &quot;&quot;; // all info is player-dependent</a>
<a name="ln3082"> </a>
<a name="ln3083">    ostringstream description;</a>
<a name="ln3084"> </a>
<a name="ln3085">    description &lt;&lt; &quot;Miscasting this spell will cause magic contamination&quot;</a>
<a name="ln3086">                &lt;&lt; (fail_severity(spell) ?</a>
<a name="ln3087">                    &quot; and also &quot; + _miscast_damage_string(spell) : &quot;&quot;)</a>
<a name="ln3088">                &lt;&lt; &quot;.\n&quot;;</a>
<a name="ln3089"> </a>
<a name="ln3090">    if (spell == SPELL_SPELLFORGED_SERVITOR)</a>
<a name="ln3091">    {</a>
<a name="ln3092">        spell_type servitor_spell = player_servitor_spell();</a>
<a name="ln3093">        description &lt;&lt; &quot;Your servitor&quot;;</a>
<a name="ln3094">        if (servitor_spell == SPELL_NO_SPELL)</a>
<a name="ln3095">            description &lt;&lt; &quot; would be unable to mimic any of your spells&quot;;</a>
<a name="ln3096">        else</a>
<a name="ln3097">        {</a>
<a name="ln3098">            description &lt;&lt; &quot; will cast &quot;</a>
<a name="ln3099">                        &lt;&lt; spell_title(player_servitor_spell());</a>
<a name="ln3100">        }</a>
<a name="ln3101">        description &lt;&lt; &quot;.\n&quot;;</a>
<a name="ln3102">    }</a>
<a name="ln3103"> </a>
<a name="ln3104">    // Report summon cap</a>
<a name="ln3105">    const int limit = summons_limit(spell);</a>
<a name="ln3106">    if (limit)</a>
<a name="ln3107">    {</a>
<a name="ln3108">        description &lt;&lt; &quot;You can sustain at most &quot; + number_in_words(limit)</a>
<a name="ln3109">                    &lt;&lt; &quot; creature&quot; &lt;&lt; (limit &gt; 1 ? &quot;s&quot; : &quot;&quot;)</a>
<a name="ln3110">                    &lt;&lt; &quot; summoned by this spell.\n&quot;;</a>
<a name="ln3111">    }</a>
<a name="ln3112"> </a>
<a name="ln3113">    if (god_hates_spell(spell, you.religion))</a>
<a name="ln3114">    {</a>
<a name="ln3115">        description &lt;&lt; uppercase_first(god_name(you.religion))</a>
<a name="ln3116">                    &lt;&lt; &quot; frowns upon the use of this spell.\n&quot;;</a>
<a name="ln3117">        if (god_loathes_spell(spell, you.religion))</a>
<a name="ln3118">            description &lt;&lt; &quot;You'd be excommunicated if you dared to cast it!\n&quot;;</a>
<a name="ln3119">    }</a>
<a name="ln3120">    else if (god_likes_spell(spell, you.religion))</a>
<a name="ln3121">    {</a>
<a name="ln3122">        description &lt;&lt; uppercase_first(god_name(you.religion))</a>
<a name="ln3123">                    &lt;&lt; &quot; supports the use of this spell.\n&quot;;</a>
<a name="ln3124">    }</a>
<a name="ln3125"> </a>
<a name="ln3126">    if (!you_can_memorise(spell))</a>
<a name="ln3127">    {</a>
<a name="ln3128">        description &lt;&lt; &quot;\nYou cannot &quot;</a>
<a name="ln3129">                    &lt;&lt; (you.has_spell(spell) ? &quot;cast&quot; : &quot;memorise&quot;)</a>
<a name="ln3130">                    &lt;&lt; &quot; this spell because &quot;</a>
<a name="ln3131">                    &lt;&lt; desc_cannot_memorise_reason(spell)</a>
<a name="ln3132">                    &lt;&lt; &quot;\n&quot;;</a>
<a name="ln3133">    }</a>
<a name="ln3134">    else if (spell_is_useless(spell, true, false))</a>
<a name="ln3135">    {</a>
<a name="ln3136">        description &lt;&lt; &quot;\nThis spell will have no effect right now because &quot;</a>
<a name="ln3137">                    &lt;&lt; spell_uselessness_reason(spell, true, false)</a>
<a name="ln3138">                    &lt;&lt; &quot;\n&quot;;</a>
<a name="ln3139">    }</a>
<a name="ln3140"> </a>
<a name="ln3141">    return description.str();</a>
<a name="ln3142">}</a>
<a name="ln3143"> </a>
<a name="ln3144"> </a>
<a name="ln3145">/**</a>
<a name="ln3146"> * Describe a spell, as cast by the player.</a>
<a name="ln3147"> *</a>
<a name="ln3148"> * @param spell     The spell in question.</a>
<a name="ln3149"> * @return          Information about the spell; does not include the title or</a>
<a name="ln3150"> *                  db description, but does include level, range, etc.</a>
<a name="ln3151"> */</a>
<a name="ln3152">string player_spell_desc(spell_type spell)</a>
<a name="ln3153">{</a>
<a name="ln3154">    return _player_spell_stats(spell) + _player_spell_desc(spell);</a>
<a name="ln3155">}</a>
<a name="ln3156"> </a>
<a name="ln3157">/**</a>
<a name="ln3158"> * Examine a given spell. Set the given string to its description, stats, &amp;c.</a>
<a name="ln3159"> * If it's a book in a spell that the player is holding, mention the option to</a>
<a name="ln3160"> * memorise it.</a>
<a name="ln3161"> *</a>
<a name="ln3162"> * @param spell         The spell in question.</a>
<a name="ln3163"> * @param mon_owner     If this spell is being examined from a monster's</a>
<a name="ln3164"> *                      description, 'spell' is that monster. Else, null.</a>
<a name="ln3165"> * @param description   Set to the description &amp; details of the spell.</a>
<a name="ln3166"> * @param item          The item holding the spell, if any.</a>
<a name="ln3167"> * @return              Whether you can memorise the spell.</a>
<a name="ln3168"> */</a>
<a name="ln3169">static bool _get_spell_description(const spell_type spell,</a>
<a name="ln3170">                                  const monster_info *mon_owner,</a>
<a name="ln3171">                                  string &amp;description,</a>
<a name="ln3172">                                  const item_def* item = nullptr)</a>
<a name="ln3173">{</a>
<a name="ln3174">    description.reserve(500);</a>
<a name="ln3175"> </a>
<a name="ln3176">    const string long_descrip = getLongDescription(string(spell_title(spell))</a>
<a name="ln3177">                                                   + &quot; spell&quot;);</a>
<a name="ln3178"> </a>
<a name="ln3179">    if (!long_descrip.empty())</a>
<a name="ln3180">        description += long_descrip;</a>
<a name="ln3181">    else</a>
<a name="ln3182">    {</a>
<a name="ln3183">        description += &quot;This spell has no description. &quot;</a>
<a name="ln3184">                       &quot;Casting it may therefore be unwise. &quot;</a>
<a name="ln3185">#ifdef DEBUG</a>
<a name="ln3186">                       &quot;Instead, go fix it. &quot;;</a>
<a name="ln3187">#else</a>
<a name="ln3188">                       &quot;Please file a bug report.&quot;;</a>
<a name="ln3189">#endif</a>
<a name="ln3190">    }</a>
<a name="ln3191"> </a>
<a name="ln3192">    if (mon_owner)</a>
<a name="ln3193">    {</a>
<a name="ln3194">        const int hd = mon_owner-&gt;spell_hd();</a>
<a name="ln3195">        const int range = mons_spell_range_for_hd(spell, hd);</a>
<a name="ln3196">        description += &quot;\nRange : &quot;</a>
<a name="ln3197">                       + range_string(range, range, mons_char(mon_owner-&gt;type))</a>
<a name="ln3198">                       + &quot;\n&quot;;</a>
<a name="ln3199"> </a>
<a name="ln3200">        // only display this if the player exists (not in the main menu)</a>
<a name="ln3201">        if (crawl_state.need_save &amp;&amp; (get_spell_flags(spell) &amp; spflag::MR_check)</a>
<a name="ln3202">#ifndef DEBUG_DIAGNOSTICS</a>
<a name="ln3203">            &amp;&amp; mon_owner-&gt;attitude != ATT_FRIENDLY</a>
<a name="ln3204">#endif</a>
<a name="ln3205">            )</a>
<a name="ln3206">        {</a>
<a name="ln3207">            string wiz_info;</a>
<a name="ln3208">#ifdef WIZARD</a>
<a name="ln3209">            if (you.wizard)</a>
<a name="ln3210">                wiz_info += make_stringf(&quot; (pow %d)&quot;, _hex_pow(spell, hd));</a>
<a name="ln3211">#endif</a>
<a name="ln3212">            description += you.immune_to_hex(spell)</a>
<a name="ln3213">                ? make_stringf(&quot;You cannot be affected by this &quot;</a>
<a name="ln3214">                               &quot;spell right now. %s\n&quot;,</a>
<a name="ln3215">                               wiz_info.c_str())</a>
<a name="ln3216">                : make_stringf(&quot;Chance to beat your MR: %d%%%s\n&quot;,</a>
<a name="ln3217">                               hex_chance(spell, hd),</a>
<a name="ln3218">                               wiz_info.c_str());</a>
<a name="ln3219">        }</a>
<a name="ln3220"> </a>
<a name="ln3221">    }</a>
<a name="ln3222">    else</a>
<a name="ln3223">        description += player_spell_desc(spell);</a>
<a name="ln3224"> </a>
<a name="ln3225">    // Don't allow memorisation after death.</a>
<a name="ln3226">    // (In the post-game inventory screen.)</a>
<a name="ln3227">    if (crawl_state.player_is_dead())</a>
<a name="ln3228">        return false;</a>
<a name="ln3229"> </a>
<a name="ln3230">    const string quote = getQuoteString(string(spell_title(spell)) + &quot; spell&quot;);</a>
<a name="ln3231">    if (!quote.empty())</a>
<a name="ln3232">        description += &quot;\n&quot; + quote;</a>
<a name="ln3233"> </a>
<a name="ln3234">    if (item &amp;&amp; item-&gt;base_type == OBJ_BOOKS</a>
<a name="ln3235">        &amp;&amp; (in_inventory(*item)</a>
<a name="ln3236">            || item-&gt;pos == you.pos() &amp;&amp; !is_shop_item(*item))</a>
<a name="ln3237">        &amp;&amp; !you.has_spell(spell) &amp;&amp; you_can_memorise(spell))</a>
<a name="ln3238">    {</a>
<a name="ln3239">        return true;</a>
<a name="ln3240">    }</a>
<a name="ln3241"> </a>
<a name="ln3242">    return false;</a>
<a name="ln3243">}</a>
<a name="ln3244"> </a>
<a name="ln3245">/**</a>
<a name="ln3246"> * Make a list of all books that contain a given spell.</a>
<a name="ln3247"> *</a>
<a name="ln3248"> * @param spell_type spell      The spell in question.</a>
<a name="ln3249"> * @return                      A formatted list of books containing</a>
<a name="ln3250"> *                              the spell, e.g.:</a>
<a name="ln3251"> *    \n\nThis spell can be found in the following books: dreams, burglary.</a>
<a name="ln3252"> *    or</a>
<a name="ln3253"> *    \n\nThis spell is not found in any books.</a>
<a name="ln3254"> */</a>
<a name="ln3255">static string _spell_sources(const spell_type spell)</a>
<a name="ln3256">{</a>
<a name="ln3257">    item_def item;</a>
<a name="ln3258">    set_ident_flags(item, ISFLAG_IDENT_MASK);</a>
<a name="ln3259">    vector&lt;string&gt; books;</a>
<a name="ln3260"> </a>
<a name="ln3261">    item.base_type = OBJ_BOOKS;</a>
<a name="ln3262">    for (int i = 0; i &lt; NUM_FIXED_BOOKS; i++)</a>
<a name="ln3263">    {</a>
<a name="ln3264">        if (item_type_removed(OBJ_BOOKS, i))</a>
<a name="ln3265">            continue;</a>
<a name="ln3266">        for (spell_type sp : spellbook_template(static_cast&lt;book_type&gt;(i)))</a>
<a name="ln3267">            if (sp == spell)</a>
<a name="ln3268">            {</a>
<a name="ln3269">                item.sub_type = i;</a>
<a name="ln3270">                books.push_back(item.name(DESC_PLAIN));</a>
<a name="ln3271">            }</a>
<a name="ln3272">    }</a>
<a name="ln3273"> </a>
<a name="ln3274">    if (books.empty())</a>
<a name="ln3275">        return &quot;\nThis spell is not found in any books.&quot;;</a>
<a name="ln3276"> </a>
<a name="ln3277">    string desc;</a>
<a name="ln3278"> </a>
<a name="ln3279">    desc += &quot;\nThis spell can be found in the following book&quot;;</a>
<a name="ln3280">    if (books.size() &gt; 1)</a>
<a name="ln3281">        desc += &quot;s&quot;;</a>
<a name="ln3282">    desc += &quot;:\n &quot;;</a>
<a name="ln3283">    desc += comma_separated_line(books.begin(), books.end(), &quot;\n &quot;, &quot;\n &quot;);</a>
<a name="ln3284"> </a>
<a name="ln3285">    return desc;</a>
<a name="ln3286">}</a>
<a name="ln3287"> </a>
<a name="ln3288">/**</a>
<a name="ln3289"> * Provide the text description of a given spell.</a>
<a name="ln3290"> *</a>
<a name="ln3291"> * @param spell     The spell in question.</a>
<a name="ln3292"> * @param inf[out]  The spell's description is concatenated onto the end of</a>
<a name="ln3293"> *                  inf.body.</a>
<a name="ln3294"> */</a>
<a name="ln3295">void get_spell_desc(const spell_type spell, describe_info &amp;inf)</a>
<a name="ln3296">{</a>
<a name="ln3297">    string desc;</a>
<a name="ln3298">    _get_spell_description(spell, nullptr, desc);</a>
<a name="ln3299">    inf.body &lt;&lt; desc;</a>
<a name="ln3300">}</a>
<a name="ln3301"> </a>
<a name="ln3302">/**</a>
<a name="ln3303"> * Examine a given spell. List its description and details, and handle</a>
<a name="ln3304"> * memorising the spell in question, if the player is able &amp; chooses to do so.</a>
<a name="ln3305"> *</a>
<a name="ln3306"> * @param spelled   The spell in question.</a>
<a name="ln3307"> * @param mon_owner If this spell is being examined from a monster's</a>
<a name="ln3308"> *                  description, 'mon_owner' is that monster. Else, null.</a>
<a name="ln3309"> * @param item      The item holding the spell, if any.</a>
<a name="ln3310"> */</a>
<a name="ln3311">void describe_spell(spell_type spell, const monster_info *mon_owner,</a>
<a name="ln3312">                    const item_def* item, bool show_booklist)</a>
<a name="ln3313">{</a>
<a name="ln3314">    string desc;</a>
<a name="ln3315">    const bool can_mem = _get_spell_description(spell, mon_owner, desc, item);</a>
<a name="ln3316">    if (show_booklist)</a>
<a name="ln3317">        desc += _spell_sources(spell);</a>
<a name="ln3318"> </a>
<a name="ln3319">    auto vbox = make_shared&lt;Box&gt;(Widget::VERT);</a>
<a name="ln3320">#ifdef USE_TILE_LOCAL</a>
<a name="ln3321">    vbox-&gt;max_size().width = tiles.get_crt_font()-&gt;char_width()*80;</a>
<a name="ln3322">#endif</a>
<a name="ln3323"> </a>
<a name="ln3324">    auto title_hbox = make_shared&lt;Box&gt;(Widget::HORZ);</a>
<a name="ln3325">#ifdef USE_TILE</a>
<a name="ln3326">    auto spell_icon = make_shared&lt;Image&gt;();</a>
<a name="ln3327">    spell_icon-&gt;set_tile(tile_def(tileidx_spell(spell), TEX_GUI));</a>
<a name="ln3328">    title_hbox-&gt;add_child(move(spell_icon));</a>
<a name="ln3329">#endif</a>
<a name="ln3330"> </a>
<a name="ln3331">    string spl_title = spell_title(spell);</a>
<a name="ln3332">    trim_string(desc);</a>
<a name="ln3333"> </a>
<a name="ln3334">    auto title = make_shared&lt;Text&gt;();</a>
<a name="ln3335">    title-&gt;set_text(spl_title);</a>
<a name="ln3336">    title-&gt;set_margin_for_sdl(0, 0, 0, 10);</a>
<a name="ln3337">    title_hbox-&gt;add_child(move(title));</a>
<a name="ln3338"> </a>
<a name="ln3339">    title_hbox-&gt;set_cross_alignment(Widget::CENTER);</a>
<a name="ln3340">    title_hbox-&gt;set_margin_for_crt(0, 0, 1, 0);</a>
<a name="ln3341">    title_hbox-&gt;set_margin_for_sdl(0, 0, 20, 0);</a>
<a name="ln3342">    vbox-&gt;add_child(move(title_hbox));</a>
<a name="ln3343"> </a>
<a name="ln3344">    auto scroller = make_shared&lt;Scroller&gt;();</a>
<a name="ln3345">    auto text = make_shared&lt;Text&gt;();</a>
<a name="ln3346">    text-&gt;set_text(formatted_string::parse_string(desc));</a>
<a name="ln3347">    text-&gt;set_wrap_text(true);</a>
<a name="ln3348">    scroller-&gt;set_child(move(text));</a>
<a name="ln3349">    vbox-&gt;add_child(scroller);</a>
<a name="ln3350"> </a>
<a name="ln3351">    if (can_mem)</a>
<a name="ln3352">    {</a>
<a name="ln3353">        auto more = make_shared&lt;Text&gt;();</a>
<a name="ln3354">        more-&gt;set_text(formatted_string(&quot;(M)emorise this spell.&quot;, CYAN));</a>
<a name="ln3355">        more-&gt;set_margin_for_crt(1, 0, 0, 0);</a>
<a name="ln3356">        more-&gt;set_margin_for_sdl(20, 0, 0, 0);</a>
<a name="ln3357">        vbox-&gt;add_child(move(more));</a>
<a name="ln3358">    }</a>
<a name="ln3359"> </a>
<a name="ln3360">    auto popup = make_shared&lt;ui::Popup&gt;(move(vbox));</a>
<a name="ln3361"> </a>
<a name="ln3362">    bool done = false;</a>
<a name="ln3363">    int lastch;</a>
<a name="ln3364">    popup-&gt;on_keydown_event([&amp;](const KeyEvent&amp; ev) {</a>
<a name="ln3365">        lastch = ev.key();</a>
<a name="ln3366">        done = (toupper_safe(lastch) == 'M' &amp;&amp; can_mem || lastch == CK_ESCAPE</a>
<a name="ln3367">            || lastch == CK_ENTER || lastch == ' ');</a>
<a name="ln3368">        if (scroller-&gt;on_event(ev))</a>
<a name="ln3369">            return true;</a>
<a name="ln3370">        return done;</a>
<a name="ln3371">    });</a>
<a name="ln3372"> </a>
<a name="ln3373">#ifdef USE_TILE_WEB</a>
<a name="ln3374">    tiles.json_open_object();</a>
<a name="ln3375">    auto tile = tile_def(tileidx_spell(spell), TEX_GUI);</a>
<a name="ln3376">    tiles.json_open_object(&quot;tile&quot;);</a>
<a name="ln3377">    tiles.json_write_int(&quot;t&quot;, tile.tile);</a>
<a name="ln3378">    tiles.json_write_int(&quot;tex&quot;, tile.tex);</a>
<a name="ln3379">    if (tile.ymax != TILE_Y)</a>
<a name="ln3380">        tiles.json_write_int(&quot;ymax&quot;, tile.ymax);</a>
<a name="ln3381">    tiles.json_close_object();</a>
<a name="ln3382">    tiles.json_write_string(&quot;title&quot;, spl_title);</a>
<a name="ln3383">    tiles.json_write_string(&quot;desc&quot;, desc);</a>
<a name="ln3384">    tiles.json_write_bool(&quot;can_mem&quot;, can_mem);</a>
<a name="ln3385">    tiles.push_ui_layout(&quot;describe-spell&quot;, 0);</a>
<a name="ln3386">    popup-&gt;on_layout_pop([](){ tiles.pop_ui_layout(); });</a>
<a name="ln3387">#endif</a>
<a name="ln3388"> </a>
<a name="ln3389">    ui::run_layout(move(popup), done);</a>
<a name="ln3390"> </a>
<a name="ln3391">    if (toupper_safe(lastch) == 'M' &amp;&amp; can_mem)</a>
<a name="ln3392">    {</a>
<a name="ln3393">        redraw_screen(); // necessary to ensure stats is redrawn (!?)</a>
<a name="ln3394">        if (!learn_spell(spell) || !you.turn_is_over)</a>
<a name="ln3395">            more();</a>
<a name="ln3396">    }</a>
<a name="ln3397">}</a>
<a name="ln3398"> </a>
<a name="ln3399">/**</a>
<a name="ln3400"> * Examine a given ability. List its description and details.</a>
<a name="ln3401"> *</a>
<a name="ln3402"> * @param ability   The ability in question.</a>
<a name="ln3403"> */</a>
<a name="ln3404">void describe_ability(ability_type ability)</a>
<a name="ln3405">{</a>
<a name="ln3406">    describe_info inf;</a>
<a name="ln3407">    inf.title = ability_name(ability);</a>
<a name="ln3408">    inf.body &lt;&lt; get_ability_desc(ability, false);</a>
<a name="ln3409">#ifdef USE_TILE</a>
<a name="ln3410">    tile_def tile = tile_def(tileidx_ability(ability), TEX_GUI);</a>
<a name="ln3411">    show_description(inf, &amp;tile);</a>
<a name="ln3412">#else</a>
<a name="ln3413">    show_description(inf);</a>
<a name="ln3414">#endif</a>
<a name="ln3415">}</a>
<a name="ln3416"> </a>
<a name="ln3417">/**</a>
<a name="ln3418"> * Examine a given deck.</a>
<a name="ln3419"> */</a>
<a name="ln3420">void describe_deck(deck_type deck)</a>
<a name="ln3421">{</a>
<a name="ln3422">    describe_info inf;</a>
<a name="ln3423"> </a>
<a name="ln3424">    if (deck == DECK_STACK)</a>
<a name="ln3425">        inf.title = &quot;A stacked deck&quot;;</a>
<a name="ln3426">    else</a>
<a name="ln3427">        inf.title = &quot;The &quot; + deck_name(deck);</a>
<a name="ln3428"> </a>
<a name="ln3429">    inf.body &lt;&lt; deck_description(deck);</a>
<a name="ln3430"> </a>
<a name="ln3431">    show_description(inf);</a>
<a name="ln3432">}</a>
<a name="ln3433"> </a>
<a name="ln3434">static string _describe_draconian(const monster_info&amp; mi)</a>
<a name="ln3435">{</a>
<a name="ln3436">    string description;</a>
<a name="ln3437">    const int subsp = mi.draco_or_demonspawn_subspecies();</a>
<a name="ln3438"> </a>
<a name="ln3439">    if (subsp != mi.type)</a>
<a name="ln3440">    {</a>
<a name="ln3441">        description += &quot;It has &quot;;</a>
<a name="ln3442"> </a>
<a name="ln3443">        switch (subsp)</a>
<a name="ln3444">        {</a>
<a name="ln3445">        case MONS_BLACK_DRACONIAN:      description += &quot;black &quot;;   break;</a>
<a name="ln3446">        case MONS_YELLOW_DRACONIAN:     description += &quot;yellow &quot;;  break;</a>
<a name="ln3447">        case MONS_GREEN_DRACONIAN:      description += &quot;green &quot;;   break;</a>
<a name="ln3448">        case MONS_PURPLE_DRACONIAN:     description += &quot;purple &quot;;  break;</a>
<a name="ln3449">        case MONS_RED_DRACONIAN:        description += &quot;red &quot;;     break;</a>
<a name="ln3450">        case MONS_WHITE_DRACONIAN:      description += &quot;white &quot;;   break;</a>
<a name="ln3451">        case MONS_GREY_DRACONIAN:       description += &quot;grey &quot;;    break;</a>
<a name="ln3452">        case MONS_PALE_DRACONIAN:       description += &quot;pale &quot;;    break;</a>
<a name="ln3453">        default:</a>
<a name="ln3454">            break;</a>
<a name="ln3455">        }</a>
<a name="ln3456"> </a>
<a name="ln3457">        description += &quot;scales. &quot;;</a>
<a name="ln3458">    }</a>
<a name="ln3459"> </a>
<a name="ln3460">    switch (subsp)</a>
<a name="ln3461">    {</a>
<a name="ln3462">    case MONS_BLACK_DRACONIAN:</a>
<a name="ln3463">        description += &quot;Sparks flare out of its mouth and nostrils.&quot;;</a>
<a name="ln3464">        break;</a>
<a name="ln3465">    case MONS_YELLOW_DRACONIAN:</a>
<a name="ln3466">        description += &quot;Acidic fumes swirl around it.&quot;;</a>
<a name="ln3467">        break;</a>
<a name="ln3468">    case MONS_GREEN_DRACONIAN:</a>
<a name="ln3469">        description += &quot;Venom drips from its jaws.&quot;;</a>
<a name="ln3470">        break;</a>
<a name="ln3471">    case MONS_PURPLE_DRACONIAN:</a>
<a name="ln3472">        description += &quot;Its outline shimmers with magical energy.&quot;;</a>
<a name="ln3473">        break;</a>
<a name="ln3474">    case MONS_RED_DRACONIAN:</a>
<a name="ln3475">        description += &quot;Smoke pours from its nostrils.&quot;;</a>
<a name="ln3476">        break;</a>
<a name="ln3477">    case MONS_WHITE_DRACONIAN:</a>
<a name="ln3478">        description += &quot;Frost pours from its nostrils.&quot;;</a>
<a name="ln3479">        break;</a>
<a name="ln3480">    case MONS_GREY_DRACONIAN:</a>
<a name="ln3481">        description += &quot;Its scales and tail are adapted to the water.&quot;;</a>
<a name="ln3482">        break;</a>
<a name="ln3483">    case MONS_PALE_DRACONIAN:</a>
<a name="ln3484">        description += &quot;It is cloaked in a pall of superheated steam.&quot;;</a>
<a name="ln3485">        break;</a>
<a name="ln3486">    default:</a>
<a name="ln3487">        break;</a>
<a name="ln3488">    }</a>
<a name="ln3489"> </a>
<a name="ln3490">    return description;</a>
<a name="ln3491">}</a>
<a name="ln3492"> </a>
<a name="ln3493">static string _describe_demonspawn_role(monster_type type)</a>
<a name="ln3494">{</a>
<a name="ln3495">    switch (type)</a>
<a name="ln3496">    {</a>
<a name="ln3497">    case MONS_BLOOD_SAINT:</a>
<a name="ln3498">        return &quot;It weaves powerful and unpredictable spells of devastation.&quot;;</a>
<a name="ln3499">    case MONS_WARMONGER:</a>
<a name="ln3500">        return &quot;It is devoted to combat, disrupting the magic of its foes as &quot;</a>
<a name="ln3501">               &quot;it battles endlessly.&quot;;</a>
<a name="ln3502">    case MONS_CORRUPTER:</a>
<a name="ln3503">        return &quot;It corrupts space around itself, and can twist even the very &quot;</a>
<a name="ln3504">               &quot;flesh of its opponents.&quot;;</a>
<a name="ln3505">    case MONS_BLACK_SUN:</a>
<a name="ln3506">        return &quot;It shines with an unholy radiance, and wields powers of &quot;</a>
<a name="ln3507">               &quot;darkness from its devotion to the deities of death.&quot;;</a>
<a name="ln3508">    default:</a>
<a name="ln3509">        return &quot;&quot;;</a>
<a name="ln3510">    }</a>
<a name="ln3511">}</a>
<a name="ln3512"> </a>
<a name="ln3513">static string _describe_demonspawn_base(int species)</a>
<a name="ln3514">{</a>
<a name="ln3515">    switch (species)</a>
<a name="ln3516">    {</a>
<a name="ln3517">    case MONS_MONSTROUS_DEMONSPAWN:</a>
<a name="ln3518">        return &quot;It is more beast now than whatever species it is descended from.&quot;;</a>
<a name="ln3519">    case MONS_GELID_DEMONSPAWN:</a>
<a name="ln3520">        return &quot;It is covered in icy armour.&quot;;</a>
<a name="ln3521">    case MONS_INFERNAL_DEMONSPAWN:</a>
<a name="ln3522">        return &quot;It gives off an intense heat.&quot;;</a>
<a name="ln3523">    case MONS_TORTUROUS_DEMONSPAWN:</a>
<a name="ln3524">        return &quot;It menaces with bony spines.&quot;;</a>
<a name="ln3525">    }</a>
<a name="ln3526">    return &quot;&quot;;</a>
<a name="ln3527">}</a>
<a name="ln3528"> </a>
<a name="ln3529">static string _describe_demonspawn(const monster_info&amp; mi)</a>
<a name="ln3530">{</a>
<a name="ln3531">    string description;</a>
<a name="ln3532">    const int subsp = mi.draco_or_demonspawn_subspecies();</a>
<a name="ln3533"> </a>
<a name="ln3534">    description += _describe_demonspawn_base(subsp);</a>
<a name="ln3535"> </a>
<a name="ln3536">    if (subsp != mi.type)</a>
<a name="ln3537">    {</a>
<a name="ln3538">        const string demonspawn_role = _describe_demonspawn_role(mi.type);</a>
<a name="ln3539">        if (!demonspawn_role.empty())</a>
<a name="ln3540">            description += &quot; &quot; + demonspawn_role;</a>
<a name="ln3541">    }</a>
<a name="ln3542"> </a>
<a name="ln3543">    return description;</a>
<a name="ln3544">}</a>
<a name="ln3545"> </a>
<a name="ln3546">static const char* _get_resist_name(mon_resist_flags res_type)</a>
<a name="ln3547">{</a>
<a name="ln3548">    switch (res_type)</a>
<a name="ln3549">    {</a>
<a name="ln3550">    case MR_RES_ELEC:</a>
<a name="ln3551">        return &quot;electricity&quot;;</a>
<a name="ln3552">    case MR_RES_POISON:</a>
<a name="ln3553">        return &quot;poison&quot;;</a>
<a name="ln3554">    case MR_RES_FIRE:</a>
<a name="ln3555">        return &quot;fire&quot;;</a>
<a name="ln3556">    case MR_RES_STEAM:</a>
<a name="ln3557">        return &quot;steam&quot;;</a>
<a name="ln3558">    case MR_RES_COLD:</a>
<a name="ln3559">        return &quot;cold&quot;;</a>
<a name="ln3560">    case MR_RES_ACID:</a>
<a name="ln3561">        return &quot;acid&quot;;</a>
<a name="ln3562">    case MR_RES_ROTTING:</a>
<a name="ln3563">        return &quot;rotting&quot;;</a>
<a name="ln3564">    case MR_RES_NEG:</a>
<a name="ln3565">        return &quot;negative energy&quot;;</a>
<a name="ln3566">    case MR_RES_DAMNATION:</a>
<a name="ln3567">        return &quot;damnation&quot;;</a>
<a name="ln3568">    case MR_RES_TORNADO:</a>
<a name="ln3569">        return &quot;tornadoes&quot;;</a>
<a name="ln3570">    default:</a>
<a name="ln3571">        return &quot;buggy resistance&quot;;</a>
<a name="ln3572">    }</a>
<a name="ln3573">}</a>
<a name="ln3574"> </a>
<a name="ln3575">static const char* _get_threat_desc(mon_threat_level_type threat)</a>
<a name="ln3576">{</a>
<a name="ln3577">    switch (threat)</a>
<a name="ln3578">    {</a>
<a name="ln3579">    case MTHRT_TRIVIAL: return &quot;harmless&quot;;</a>
<a name="ln3580">    case MTHRT_EASY:    return &quot;easy&quot;;</a>
<a name="ln3581">    case MTHRT_TOUGH:   return &quot;dangerous&quot;;</a>
<a name="ln3582">    case MTHRT_NASTY:   return &quot;extremely dangerous&quot;;</a>
<a name="ln3583">    case MTHRT_UNDEF:</a>
<a name="ln3584">    default:            return &quot;buggily threatening&quot;;</a>
<a name="ln3585">    }</a>
<a name="ln3586">}</a>
<a name="ln3587"> </a>
<a name="ln3588">/**</a>
<a name="ln3589"> * Describe monster attack 'flavours' that trigger before the attack.</a>
<a name="ln3590"> *</a>
<a name="ln3591"> * @param flavour   The flavour in question; e.g. AF_SWOOP.</a>
<a name="ln3592"> * @return          A description of anything that happens 'before' an attack</a>
<a name="ln3593"> *                  with the given flavour;</a>
<a name="ln3594"> *                  e.g. &quot;swoop behind its target and &quot;.</a>
<a name="ln3595"> */</a>
<a name="ln3596">static const char* _special_flavour_prefix(attack_flavour flavour)</a>
<a name="ln3597">{</a>
<a name="ln3598">    switch (flavour)</a>
<a name="ln3599">    {</a>
<a name="ln3600">        case AF_KITE:</a>
<a name="ln3601">            return &quot;retreat from adjacent foes and &quot;;</a>
<a name="ln3602">        case AF_SWOOP:</a>
<a name="ln3603">            return &quot;swoop behind its foe and &quot;;</a>
<a name="ln3604">        default:</a>
<a name="ln3605">            return &quot;&quot;;</a>
<a name="ln3606">    }</a>
<a name="ln3607">}</a>
<a name="ln3608"> </a>
<a name="ln3609">/**</a>
<a name="ln3610"> * Describe monster attack 'flavours' that have extra range.</a>
<a name="ln3611"> *</a>
<a name="ln3612"> * @param flavour   The flavour in question; e.g. AF_REACH_STING.</a>
<a name="ln3613"> * @return          If the flavour has extra-long range, say so. E.g.,</a>
<a name="ln3614"> *                  &quot; from a distance&quot;. (Else &quot;&quot;).</a>
<a name="ln3615"> */</a>
<a name="ln3616">static const char* _flavour_range_desc(attack_flavour flavour)</a>
<a name="ln3617">{</a>
<a name="ln3618">    if (flavour == AF_REACH || flavour == AF_REACH_STING)</a>
<a name="ln3619">        return &quot; from a distance&quot;;</a>
<a name="ln3620">    return &quot;&quot;;</a>
<a name="ln3621">}</a>
<a name="ln3622"> </a>
<a name="ln3623">static string _flavour_base_desc(attack_flavour flavour)</a>
<a name="ln3624">{</a>
<a name="ln3625">    static const map&lt;attack_flavour, string&gt; base_descs = {</a>
<a name="ln3626">        { AF_ACID,              &quot;deal extra acid damage&quot;},</a>
<a name="ln3627">        { AF_BLINK,             &quot;blink itself&quot; },</a>
<a name="ln3628">        { AF_COLD,              &quot;deal up to %d extra cold damage&quot; },</a>
<a name="ln3629">        { AF_CONFUSE,           &quot;cause confusion&quot; },</a>
<a name="ln3630">        { AF_DRAIN_STR,         &quot;drain strength&quot; },</a>
<a name="ln3631">        { AF_DRAIN_INT,         &quot;drain intelligence&quot; },</a>
<a name="ln3632">        { AF_DRAIN_DEX,         &quot;drain dexterity&quot; },</a>
<a name="ln3633">        { AF_DRAIN_STAT,        &quot;drain strength, intelligence or dexterity&quot; },</a>
<a name="ln3634">        { AF_DRAIN_XP,          &quot;drain skills&quot; },</a>
<a name="ln3635">        { AF_ELEC,              &quot;deal up to %d extra electric damage&quot; },</a>
<a name="ln3636">        { AF_FIRE,              &quot;deal up to %d extra fire damage&quot; },</a>
<a name="ln3637">        { AF_HUNGER,            &quot;cause hunger&quot; },</a>
<a name="ln3638">        { AF_MUTATE,            &quot;cause mutations&quot; },</a>
<a name="ln3639">        { AF_POISON_PARALYSE,   &quot;poison and cause paralysis or slowing&quot; },</a>
<a name="ln3640">        { AF_POISON,            &quot;cause poisoning&quot; },</a>
<a name="ln3641">        { AF_POISON_STRONG,     &quot;cause strong poisoning&quot; },</a>
<a name="ln3642">        { AF_ROT,               &quot;cause rotting&quot; },</a>
<a name="ln3643">        { AF_VAMPIRIC,          &quot;drain health from the living&quot; },</a>
<a name="ln3644">#if TAG_MAJOR_VERSION == 34</a>
<a name="ln3645">        { AF_KLOWN,             &quot;cause random powerful effects&quot; },</a>
<a name="ln3646">#endif</a>
<a name="ln3647">        { AF_DISTORT,           &quot;cause wild translocation effects&quot; },</a>
<a name="ln3648">        { AF_RAGE,              &quot;cause berserking&quot; },</a>
<a name="ln3649">        { AF_STICKY_FLAME,      &quot;apply sticky flame&quot; },</a>
<a name="ln3650">        { AF_CHAOTIC,           &quot;cause unpredictable effects&quot; },</a>
<a name="ln3651">        { AF_STEAL,             &quot;steal items&quot; },</a>
<a name="ln3652">        { AF_CRUSH,             &quot;begin ongoing constriction&quot; },</a>
<a name="ln3653">        { AF_REACH,             &quot;&quot; },</a>
<a name="ln3654">        { AF_HOLY,              &quot;deal extra damage to undead and demons&quot; },</a>
<a name="ln3655">        { AF_ANTIMAGIC,         &quot;drain magic&quot; },</a>
<a name="ln3656">        { AF_PAIN,              &quot;cause pain to the living&quot; },</a>
<a name="ln3657">        { AF_ENSNARE,           &quot;ensnare with webbing&quot; },</a>
<a name="ln3658">        { AF_ENGULF,            &quot;engulf with water&quot; },</a>
<a name="ln3659">        { AF_PURE_FIRE,         &quot;&quot; },</a>
<a name="ln3660">        { AF_DRAIN_SPEED,       &quot;drain speed&quot; },</a>
<a name="ln3661">        { AF_VULN,              &quot;reduce resistance to hostile enchantments&quot; },</a>
<a name="ln3662">        { AF_SHADOWSTAB,        &quot;deal increased damage when unseen&quot; },</a>
<a name="ln3663">        { AF_DROWN,             &quot;deal drowning damage&quot; },</a>
<a name="ln3664">        { AF_CORRODE,           &quot;cause corrosion&quot; },</a>
<a name="ln3665">        { AF_SCARAB,            &quot;drain speed and drain health&quot; },</a>
<a name="ln3666">        { AF_TRAMPLE,           &quot;knock back the defender&quot; },</a>
<a name="ln3667">        { AF_REACH_STING,       &quot;cause poisoning&quot; },</a>
<a name="ln3668">        { AF_WEAKNESS,          &quot;cause weakness&quot; },</a>
<a name="ln3669">        { AF_KITE,              &quot;&quot; },</a>
<a name="ln3670">        { AF_SWOOP,             &quot;&quot; },</a>
<a name="ln3671">        { AF_PLAIN,             &quot;&quot; },</a>
<a name="ln3672">    };</a>
<a name="ln3673"> </a>
<a name="ln3674">    const string* desc = map_find(base_descs, flavour);</a>
<a name="ln3675">    ASSERT(desc);</a>
<a name="ln3676">    return *desc;</a>
<a name="ln3677">}</a>
<a name="ln3678"> </a>
<a name="ln3679">/**</a>
<a name="ln3680"> * Provide a short, and-prefixed flavour description of the given attack</a>
<a name="ln3681"> * flavour, if any.</a>
<a name="ln3682"> *</a>
<a name="ln3683"> * @param flavour  E.g. AF_COLD, AF_PLAIN.</a>
<a name="ln3684"> * @param HD       The hit dice of the monster using the flavour.</a>
<a name="ln3685"> * @return         &quot;&quot; if AF_PLAIN; else &quot; &lt;desc&gt;&quot;, e.g.</a>
<a name="ln3686"> *                 &quot; to deal up to 27 extra cold damage if any damage is dealt&quot;.</a>
<a name="ln3687"> */</a>
<a name="ln3688">static string _flavour_effect(attack_flavour flavour, int HD)</a>
<a name="ln3689">{</a>
<a name="ln3690">    const string base_desc = _flavour_base_desc(flavour);</a>
<a name="ln3691">    if (base_desc.empty())</a>
<a name="ln3692">        return base_desc;</a>
<a name="ln3693"> </a>
<a name="ln3694">    const int flavour_dam = flavour_damage(flavour, HD, false);</a>
<a name="ln3695">    const string flavour_desc = make_stringf(base_desc.c_str(), flavour_dam);</a>
<a name="ln3696"> </a>
<a name="ln3697">    if (!flavour_triggers_damageless(flavour)</a>
<a name="ln3698">        &amp;&amp; flavour != AF_KITE &amp;&amp; flavour != AF_SWOOP)</a>
<a name="ln3699">    {</a>
<a name="ln3700">        return &quot; to &quot; + flavour_desc + &quot; if any damage is dealt&quot;;</a>
<a name="ln3701">    }</a>
<a name="ln3702"> </a>
<a name="ln3703">    return &quot; to &quot; + flavour_desc;</a>
<a name="ln3704">}</a>
<a name="ln3705"> </a>
<a name="ln3706">struct mon_attack_info</a>
<a name="ln3707">{</a>
<a name="ln3708">    mon_attack_def definition;</a>
<a name="ln3709">    const item_def* weapon;</a>
<a name="ln3710">    bool operator &lt; (const mon_attack_info &amp;other) const</a>
<a name="ln3711">    {</a>
<a name="ln3712">        return std::tie(definition.type, definition.flavour,</a>
<a name="ln3713">                        definition.damage, weapon)</a>
<a name="ln3714">             &lt; std::tie(other.definition.type, other.definition.flavour,</a>
<a name="ln3715">                        other.definition.damage, other.weapon);</a>
<a name="ln3716">    }</a>
<a name="ln3717">};</a>
<a name="ln3718"> </a>
<a name="ln3719">/**</a>
<a name="ln3720"> * What weapon is the given monster using for the given attack, if any?</a>
<a name="ln3721"> *</a>
<a name="ln3722"> * @param mi        The monster in question.</a>
<a name="ln3723"> * @param atk       The attack number. (E.g. 0, 1, 2...)</a>
<a name="ln3724"> * @return          The melee weapon being used by the monster for the given</a>
<a name="ln3725"> *                  attack, if any.</a>
<a name="ln3726"> */</a>
<a name="ln3727">static const item_def* _weapon_for_attack(const monster_info&amp; mi, int atk)</a>
<a name="ln3728">{</a>
<a name="ln3729">    const item_def* weapon</a>
<a name="ln3730">       = atk == 0 ? mi.inv[MSLOT_WEAPON].get() :</a>
<a name="ln3731">         atk == 1 &amp;&amp; mi.wields_two_weapons() ? mi.inv[MSLOT_ALT_WEAPON].get() :</a>
<a name="ln3732">         nullptr;</a>
<a name="ln3733"> </a>
<a name="ln3734">    if (weapon &amp;&amp; is_weapon(*weapon))</a>
<a name="ln3735">        return weapon;</a>
<a name="ln3736">    return nullptr;</a>
<a name="ln3737">}</a>
<a name="ln3738"> </a>
<a name="ln3739">static string _monster_attacks_description(const monster_info&amp; mi)</a>
<a name="ln3740">{</a>
<a name="ln3741">    ostringstream result;</a>
<a name="ln3742">    map&lt;mon_attack_info, int&gt; attack_counts;</a>
<a name="ln3743">    brand_type special_flavour = SPWPN_NORMAL;</a>
<a name="ln3744"> </a>
<a name="ln3745">    if (mi.props.exists(SPECIAL_WEAPON_KEY))</a>
<a name="ln3746">    {</a>
<a name="ln3747">        ASSERT(mi.type == MONS_PANDEMONIUM_LORD || mons_is_pghost(mi.type));</a>
<a name="ln3748">        special_flavour = (brand_type) mi.props[SPECIAL_WEAPON_KEY].get_int();</a>
<a name="ln3749">    }</a>
<a name="ln3750"> </a>
<a name="ln3751">    for (int i = 0; i &lt; MAX_NUM_ATTACKS; ++i)</a>
<a name="ln3752">    {</a>
<a name="ln3753">        const mon_attack_def &amp;attack = mi.attack[i];</a>
<a name="ln3754">        if (attack.type == AT_NONE)</a>
<a name="ln3755">            break; // assumes there are no gaps in attack arrays</a>
<a name="ln3756"> </a>
<a name="ln3757">        const item_def* weapon = _weapon_for_attack(mi, i);</a>
<a name="ln3758">        mon_attack_info attack_info = { attack, weapon };</a>
<a name="ln3759"> </a>
<a name="ln3760">        ++attack_counts[attack_info];</a>
<a name="ln3761">    }</a>
<a name="ln3762"> </a>
<a name="ln3763">    // Hydrae have only one explicit attack, which is repeated for each head.</a>
<a name="ln3764">    if (mons_genus(mi.base_type) == MONS_HYDRA)</a>
<a name="ln3765">        for (auto &amp;attack_count : attack_counts)</a>
<a name="ln3766">            attack_count.second = mi.num_heads;</a>
<a name="ln3767"> </a>
<a name="ln3768">    vector&lt;string&gt; attack_descs;</a>
<a name="ln3769">    for (const auto &amp;attack_count : attack_counts)</a>
<a name="ln3770">    {</a>
<a name="ln3771">        const mon_attack_info &amp;info = attack_count.first;</a>
<a name="ln3772">        const mon_attack_def &amp;attack = info.definition;</a>
<a name="ln3773"> </a>
<a name="ln3774">        const string weapon_name =</a>
<a name="ln3775">              info.weapon ? info.weapon-&gt;name(DESC_PLAIN).c_str()</a>
<a name="ln3776">            : ghost_brand_name(special_flavour, mi.type).c_str();</a>
<a name="ln3777">        const string weapon_note = weapon_name.size() ?</a>
<a name="ln3778">            make_stringf(&quot; plus %s %s&quot;,</a>
<a name="ln3779">                        mi.pronoun(PRONOUN_POSSESSIVE), weapon_name.c_str())</a>
<a name="ln3780">            : &quot;&quot;;</a>
<a name="ln3781"> </a>
<a name="ln3782">        const string count_desc =</a>
<a name="ln3783">              attack_count.second == 1 ? &quot;&quot; :</a>
<a name="ln3784">              attack_count.second == 2 ? &quot; twice&quot; :</a>
<a name="ln3785">              &quot; &quot; + number_in_words(attack_count.second) + &quot; times&quot;;</a>
<a name="ln3786"> </a>
<a name="ln3787">        // XXX: hack alert</a>
<a name="ln3788">        if (attack.flavour == AF_PURE_FIRE)</a>
<a name="ln3789">        {</a>
<a name="ln3790">            attack_descs.push_back(</a>
<a name="ln3791">                make_stringf(&quot;%s for up to %d fire damage&quot;,</a>
<a name="ln3792">                             mon_attack_name(attack.type, false).c_str(),</a>
<a name="ln3793">                             flavour_damage(attack.flavour, mi.hd, false)));</a>
<a name="ln3794">            continue;</a>
<a name="ln3795">        }</a>
<a name="ln3796"> </a>
<a name="ln3797">        // Damage is listed in parentheses for attacks with a flavour</a>
<a name="ln3798">        // description, but not for plain attacks.</a>
<a name="ln3799">        bool has_flavour = !_flavour_base_desc(attack.flavour).empty();</a>
<a name="ln3800">        const string damage_desc =</a>
<a name="ln3801">            make_stringf(&quot;%sfor up to %d damage%s%s%s&quot;,</a>
<a name="ln3802">                         has_flavour ? &quot;(&quot; : &quot;&quot;,</a>
<a name="ln3803">                         attack.damage,</a>
<a name="ln3804">                         attack_count.second &gt; 1 ? &quot; each&quot; : &quot;&quot;,</a>
<a name="ln3805">                         weapon_note.c_str(),</a>
<a name="ln3806">                         has_flavour ? &quot;)&quot; : &quot;&quot;);</a>
<a name="ln3807"> </a>
<a name="ln3808">        attack_descs.push_back(</a>
<a name="ln3809">            make_stringf(&quot;%s%s%s%s %s%s&quot;,</a>
<a name="ln3810">                         _special_flavour_prefix(attack.flavour),</a>
<a name="ln3811">                         mon_attack_name(attack.type, false).c_str(),</a>
<a name="ln3812">                         _flavour_range_desc(attack.flavour),</a>
<a name="ln3813">                         count_desc.c_str(),</a>
<a name="ln3814">                         damage_desc.c_str(),</a>
<a name="ln3815">                         _flavour_effect(attack.flavour, mi.hd).c_str()));</a>
<a name="ln3816">    }</a>
<a name="ln3817"> </a>
<a name="ln3818">    if (!attack_descs.empty())</a>
<a name="ln3819">    {</a>
<a name="ln3820">        result &lt;&lt; uppercase_first(mi.pronoun(PRONOUN_SUBJECTIVE));</a>
<a name="ln3821">        result &lt;&lt; &quot; can &quot; &lt;&lt; comma_separated_line(attack_descs.begin(),</a>
<a name="ln3822">                                                  attack_descs.end(),</a>
<a name="ln3823">                                                  &quot;; and &quot;, &quot;; &quot;);</a>
<a name="ln3824">        result &lt;&lt; &quot;.\n&quot;;</a>
<a name="ln3825">    }</a>
<a name="ln3826"> </a>
<a name="ln3827">    if (mi.type == MONS_ROYAL_JELLY)</a>
<a name="ln3828">    {</a>
<a name="ln3829">        result &lt;&lt; &quot;It will release varied jellies when damaged or killed, with&quot;</a>
<a name="ln3830">            &quot; the number of jellies proportional to the amount of damage.\n&quot;;</a>
<a name="ln3831">        result &lt;&lt; &quot;It will release all of its jellies when polymorphed.\n&quot;;</a>
<a name="ln3832">    }</a>
<a name="ln3833"> </a>
<a name="ln3834">    return result.str();</a>
<a name="ln3835">}</a>
<a name="ln3836"> </a>
<a name="ln3837">static string _monster_missiles_description(const monster_info&amp; mi)</a>
<a name="ln3838">{</a>
<a name="ln3839">    item_def *missile = mi.inv[MSLOT_MISSILE].get();</a>
<a name="ln3840">    if (!missile)</a>
<a name="ln3841">        return &quot;&quot;;</a>
<a name="ln3842"> </a>
<a name="ln3843">    string desc;</a>
<a name="ln3844">    desc += uppercase_first(mi.pronoun(PRONOUN_SUBJECTIVE));</a>
<a name="ln3845">    desc += mi.pronoun_plurality() ? &quot; are quivering &quot; : &quot; is quivering &quot;;</a>
<a name="ln3846">    desc += missile-&gt;name(DESC_A, false, false, true, false, ISFLAG_KNOW_CURSE);</a>
<a name="ln3847">    desc += &quot;.\n&quot;;</a>
<a name="ln3848">    return desc;</a>
<a name="ln3849">}</a>
<a name="ln3850"> </a>
<a name="ln3851">static string _monster_spells_description(const monster_info&amp; mi)</a>
<a name="ln3852">{</a>
<a name="ln3853">    // Show monster spells and spell-like abilities.</a>
<a name="ln3854">    if (!mi.has_spells())</a>
<a name="ln3855">        return &quot;&quot;;</a>
<a name="ln3856"> </a>
<a name="ln3857">    formatted_string description;</a>
<a name="ln3858">    describe_spellset(monster_spellset(mi), nullptr, description, &amp;mi);</a>
<a name="ln3859">    description.cprintf(&quot;\nTo read a description, press the key listed above. &quot;</a>
<a name="ln3860">        &quot;(x%%) indicates the chance to beat your MR, &quot;</a>
<a name="ln3861">        &quot;and (y) indicates the spell range&quot;);</a>
<a name="ln3862">    description.cprintf(crawl_state.need_save</a>
<a name="ln3863">        ? &quot;; shown in red if you are in range.\n&quot;</a>
<a name="ln3864">        : &quot;.\n&quot;);</a>
<a name="ln3865"> </a>
<a name="ln3866">    return description.to_colour_string();</a>
<a name="ln3867">}</a>
<a name="ln3868"> </a>
<a name="ln3869">static const char *_speed_description(int speed)</a>
<a name="ln3870">{</a>
<a name="ln3871">    // These thresholds correspond to the player mutations for fast and slow.</a>
<a name="ln3872">    ASSERT(speed != 10);</a>
<a name="ln3873">    if (speed &lt; 7)</a>
<a name="ln3874">        return &quot;extremely slowly&quot;;</a>
<a name="ln3875">    else if (speed &lt; 8)</a>
<a name="ln3876">        return &quot;very slowly&quot;;</a>
<a name="ln3877">    else if (speed &lt; 10)</a>
<a name="ln3878">        return &quot;slowly&quot;;</a>
<a name="ln3879">    else if (speed &gt; 15)</a>
<a name="ln3880">        return &quot;extremely quickly&quot;;</a>
<a name="ln3881">    else if (speed &gt; 13)</a>
<a name="ln3882">        return &quot;very quickly&quot;;</a>
<a name="ln3883">    else if (speed &gt; 10)</a>
<a name="ln3884">        return &quot;quickly&quot;;</a>
<a name="ln3885"> </a>
<a name="ln3886">    return &quot;buggily&quot;;</a>
<a name="ln3887">}</a>
<a name="ln3888"> </a>
<a name="ln3889">static void _add_energy_to_string(int speed, int energy, string what,</a>
<a name="ln3890">                                  vector&lt;string&gt; &amp;fast, vector&lt;string&gt; &amp;slow)</a>
<a name="ln3891">{</a>
<a name="ln3892">    if (energy == 10)</a>
<a name="ln3893">        return;</a>
<a name="ln3894"> </a>
<a name="ln3895">    const int act_speed = (speed * 10) / energy;</a>
<a name="ln3896">    if (act_speed &gt; 10)</a>
<a name="ln3897">        fast.push_back(what + &quot; &quot; + _speed_description(act_speed));</a>
<a name="ln3898">    if (act_speed &lt; 10)</a>
<a name="ln3899">        slow.push_back(what + &quot; &quot; + _speed_description(act_speed));</a>
<a name="ln3900">}</a>
<a name="ln3901"> </a>
<a name="ln3902"> </a>
<a name="ln3903">/**</a>
<a name="ln3904"> * Print a bar of +s and .s representing a given stat to a provided stream.</a>
<a name="ln3905"> *</a>
<a name="ln3906"> * @param value[in]         The current value represented by the bar.</a>
<a name="ln3907"> * @param scale[in]         The value that each + and . represents.</a>
<a name="ln3908"> * @param name              The name of the bar.</a>
<a name="ln3909"> * @param result[in,out]    The stringstream to append to.</a>
<a name="ln3910"> * @param base_value[in]    The 'base' value represented by the bar. If</a>
<a name="ln3911"> *                          INT_MAX, is ignored.</a>
<a name="ln3912"> */</a>
<a name="ln3913">static void _print_bar(int value, int scale, string name,</a>
<a name="ln3914">                       ostringstream &amp;result, int base_value = INT_MAX)</a>
<a name="ln3915">{</a>
<a name="ln3916">    if (base_value == INT_MAX)</a>
<a name="ln3917">        base_value = value;</a>
<a name="ln3918"> </a>
<a name="ln3919">    result &lt;&lt; name &lt;&lt; &quot; &quot;;</a>
<a name="ln3920"> </a>
<a name="ln3921">    const int display_max = value ? value : base_value;</a>
<a name="ln3922">    const bool currently_disabled = !value &amp;&amp; base_value;</a>
<a name="ln3923"> </a>
<a name="ln3924">    if (currently_disabled)</a>
<a name="ln3925">      result &lt;&lt; &quot;(&quot;;</a>
<a name="ln3926"> </a>
<a name="ln3927">    for (int i = 0; i * scale &lt; display_max; i++)</a>
<a name="ln3928">    {</a>
<a name="ln3929">        result &lt;&lt; &quot;+&quot;;</a>
<a name="ln3930">        if (i % 5 == 4)</a>
<a name="ln3931">            result &lt;&lt; &quot; &quot;;</a>
<a name="ln3932">    }</a>
<a name="ln3933"> </a>
<a name="ln3934">    if (currently_disabled)</a>
<a name="ln3935">      result &lt;&lt; &quot;)&quot;;</a>
<a name="ln3936"> </a>
<a name="ln3937">#ifdef DEBUG_DIAGNOSTICS</a>
<a name="ln3938">    if (!you.suppress_wizard)</a>
<a name="ln3939">        result &lt;&lt; &quot; (&quot; &lt;&lt; value &lt;&lt; &quot;)&quot;;</a>
<a name="ln3940">#endif</a>
<a name="ln3941"> </a>
<a name="ln3942">    if (currently_disabled)</a>
<a name="ln3943">    {</a>
<a name="ln3944">        result &lt;&lt; &quot; (Normal &quot; &lt;&lt; name &lt;&lt; &quot;)&quot;;</a>
<a name="ln3945"> </a>
<a name="ln3946">#ifdef DEBUG_DIAGNOSTICS</a>
<a name="ln3947">        if (!you.suppress_wizard)</a>
<a name="ln3948">            result &lt;&lt; &quot; (&quot; &lt;&lt; base_value &lt;&lt; &quot;)&quot;;</a>
<a name="ln3949">#endif</a>
<a name="ln3950">    }</a>
<a name="ln3951">}</a>
<a name="ln3952"> </a>
<a name="ln3953">/**</a>
<a name="ln3954"> * Append information about a given monster's HP to the provided stream.</a>
<a name="ln3955"> *</a>
<a name="ln3956"> * @param mi[in]            Player-visible info about the monster in question.</a>
<a name="ln3957"> * @param result[in,out]    The stringstream to append to.</a>
<a name="ln3958"> */</a>
<a name="ln3959">static void _describe_monster_hp(const monster_info&amp; mi, ostringstream &amp;result)</a>
<a name="ln3960">{</a>
<a name="ln3961">    result &lt;&lt; &quot;Max HP: &quot; &lt;&lt; mi.get_max_hp_desc() &lt;&lt; &quot;\n&quot;;</a>
<a name="ln3962">}</a>
<a name="ln3963"> </a>
<a name="ln3964">/**</a>
<a name="ln3965"> * Append information about a given monster's AC to the provided stream.</a>
<a name="ln3966"> *</a>
<a name="ln3967"> * @param mi[in]            Player-visible info about the monster in question.</a>
<a name="ln3968"> * @param result[in,out]    The stringstream to append to.</a>
<a name="ln3969"> */</a>
<a name="ln3970">static void _describe_monster_ac(const monster_info&amp; mi, ostringstream &amp;result)</a>
<a name="ln3971">{</a>
<a name="ln3972">    // MAX_GHOST_EVASION + two pips (so with EV in parens it's the same)</a>
<a name="ln3973">    _print_bar(mi.ac, 5, &quot;AC&quot;, result);</a>
<a name="ln3974">    result &lt;&lt; &quot;\n&quot;;</a>
<a name="ln3975">}</a>
<a name="ln3976"> </a>
<a name="ln3977">/**</a>
<a name="ln3978"> * Append information about a given monster's EV to the provided stream.</a>
<a name="ln3979"> *</a>
<a name="ln3980"> * @param mi[in]            Player-visible info about the monster in question.</a>
<a name="ln3981"> * @param result[in,out]    The stringstream to append to.</a>
<a name="ln3982"> */</a>
<a name="ln3983">static void _describe_monster_ev(const monster_info&amp; mi, ostringstream &amp;result)</a>
<a name="ln3984">{</a>
<a name="ln3985">    _print_bar(mi.ev, 5, &quot;EV&quot;, result, mi.base_ev);</a>
<a name="ln3986">    result &lt;&lt; &quot;\n&quot;;</a>
<a name="ln3987">}</a>
<a name="ln3988"> </a>
<a name="ln3989">/**</a>
<a name="ln3990"> * Append information about a given monster's MR to the provided stream.</a>
<a name="ln3991"> *</a>
<a name="ln3992"> * @param mi[in]            Player-visible info about the monster in question.</a>
<a name="ln3993"> * @param result[in,out]    The stringstream to append to.</a>
<a name="ln3994"> */</a>
<a name="ln3995">static void _describe_monster_mr(const monster_info&amp; mi, ostringstream &amp;result)</a>
<a name="ln3996">{</a>
<a name="ln3997">    if (mi.res_magic() == MAG_IMMUNE)</a>
<a name="ln3998">    {</a>
<a name="ln3999">        result &lt;&lt; &quot;MR ∞\n&quot;;</a>
<a name="ln4000">        return;</a>
<a name="ln4001">    }</a>
<a name="ln4002"> </a>
<a name="ln4003">    const int bar_scale = MR_PIP;</a>
<a name="ln4004">    _print_bar(mi.res_magic(), bar_scale, &quot;MR&quot;, result);</a>
<a name="ln4005">    result &lt;&lt; &quot;\n&quot;;</a>
<a name="ln4006">}</a>
<a name="ln4007"> </a>
<a name="ln4008">// Size adjectives</a>
<a name="ln4009">const char* const size_adj[] =</a>
<a name="ln4010">{</a>
<a name="ln4011">    &quot;tiny&quot;,</a>
<a name="ln4012">    &quot;very small&quot;,</a>
<a name="ln4013">    &quot;small&quot;,</a>
<a name="ln4014">    &quot;medium&quot;,</a>
<a name="ln4015">    &quot;large&quot;,</a>
<a name="ln4016">    &quot;very large&quot;,</a>
<a name="ln4017">    &quot;giant&quot;,</a>
<a name="ln4018">};</a>
<a name="ln4019">COMPILE_CHECK(ARRAYSZ(size_adj) == NUM_SIZE_LEVELS);</a>
<a name="ln4020"> </a>
<a name="ln4021">// This is used in monster description and on '%' screen for player size</a>
<a name="ln4022">const char* get_size_adj(const size_type size, bool ignore_medium)</a>
<a name="ln4023">{</a>
<a name="ln4024">    ASSERT_RANGE(size, 0, ARRAYSZ(size_adj));</a>
<a name="ln4025">    if (ignore_medium &amp;&amp; size == SIZE_MEDIUM)</a>
<a name="ln4026">        return nullptr; // don't mention medium size</a>
<a name="ln4027">    return size_adj[size];</a>
<a name="ln4028">}</a>
<a name="ln4029"> </a>
<a name="ln4030">// Describe a monster's (intrinsic) resistances, speed and a few other</a>
<a name="ln4031">// attributes.</a>
<a name="ln4032">static string _monster_stat_description(const monster_info&amp; mi)</a>
<a name="ln4033">{</a>
<a name="ln4034">    if (mons_is_sensed(mi.type) || mons_is_projectile(mi.type))</a>
<a name="ln4035">        return &quot;&quot;;</a>
<a name="ln4036"> </a>
<a name="ln4037">    ostringstream result;</a>
<a name="ln4038"> </a>
<a name="ln4039">    _describe_monster_hp(mi, result);</a>
<a name="ln4040">    _describe_monster_ac(mi, result);</a>
<a name="ln4041">    _describe_monster_ev(mi, result);</a>
<a name="ln4042">    _describe_monster_mr(mi, result);</a>
<a name="ln4043"> </a>
<a name="ln4044">    result &lt;&lt; &quot;\n&quot;;</a>
<a name="ln4045"> </a>
<a name="ln4046">    resists_t resist = mi.resists();</a>
<a name="ln4047"> </a>
<a name="ln4048">    const mon_resist_flags resists[] =</a>
<a name="ln4049">    {</a>
<a name="ln4050">        MR_RES_ELEC,    MR_RES_POISON, MR_RES_FIRE,</a>
<a name="ln4051">        MR_RES_STEAM,   MR_RES_COLD,   MR_RES_ACID,</a>
<a name="ln4052">        MR_RES_ROTTING, MR_RES_NEG,    MR_RES_DAMNATION,</a>
<a name="ln4053">        MR_RES_TORNADO,</a>
<a name="ln4054">    };</a>
<a name="ln4055"> </a>
<a name="ln4056">    vector&lt;string&gt; extreme_resists;</a>
<a name="ln4057">    vector&lt;string&gt; high_resists;</a>
<a name="ln4058">    vector&lt;string&gt; base_resists;</a>
<a name="ln4059">    vector&lt;string&gt; suscept;</a>
<a name="ln4060"> </a>
<a name="ln4061">    for (mon_resist_flags rflags : resists)</a>
<a name="ln4062">    {</a>
<a name="ln4063">        int level = get_resist(resist, rflags);</a>
<a name="ln4064"> </a>
<a name="ln4065">        if (level != 0)</a>
<a name="ln4066">        {</a>
<a name="ln4067">            const char* attackname = _get_resist_name(rflags);</a>
<a name="ln4068">            if (rflags == MR_RES_DAMNATION || rflags == MR_RES_TORNADO)</a>
<a name="ln4069">                level = 3; // one level is immunity</a>
<a name="ln4070">            level = max(level, -1);</a>
<a name="ln4071">            level = min(level,  3);</a>
<a name="ln4072">            switch (level)</a>
<a name="ln4073">            {</a>
<a name="ln4074">                case -1:</a>
<a name="ln4075">                    suscept.emplace_back(attackname);</a>
<a name="ln4076">                    break;</a>
<a name="ln4077">                case 1:</a>
<a name="ln4078">                    base_resists.emplace_back(attackname);</a>
<a name="ln4079">                    break;</a>
<a name="ln4080">                case 2:</a>
<a name="ln4081">                    high_resists.emplace_back(attackname);</a>
<a name="ln4082">                    break;</a>
<a name="ln4083">                case 3:</a>
<a name="ln4084">                    extreme_resists.emplace_back(attackname);</a>
<a name="ln4085">                    break;</a>
<a name="ln4086">            }</a>
<a name="ln4087">        }</a>
<a name="ln4088">    }</a>
<a name="ln4089"> </a>
<a name="ln4090">    if (mi.props.exists(CLOUD_IMMUNE_MB_KEY) &amp;&amp; mi.props[CLOUD_IMMUNE_MB_KEY])</a>
<a name="ln4091">        extreme_resists.emplace_back(&quot;clouds of all kinds&quot;);</a>
<a name="ln4092"> </a>
<a name="ln4093">    vector&lt;string&gt; resist_descriptions;</a>
<a name="ln4094">    if (!extreme_resists.empty())</a>
<a name="ln4095">    {</a>
<a name="ln4096">        const string tmp = &quot;immune to &quot;</a>
<a name="ln4097">            + comma_separated_line(extreme_resists.begin(),</a>
<a name="ln4098">                                   extreme_resists.end());</a>
<a name="ln4099">        resist_descriptions.push_back(tmp);</a>
<a name="ln4100">    }</a>
<a name="ln4101">    if (!high_resists.empty())</a>
<a name="ln4102">    {</a>
<a name="ln4103">        const string tmp = &quot;very resistant to &quot;</a>
<a name="ln4104">            + comma_separated_line(high_resists.begin(), high_resists.end());</a>
<a name="ln4105">        resist_descriptions.push_back(tmp);</a>
<a name="ln4106">    }</a>
<a name="ln4107">    if (!base_resists.empty())</a>
<a name="ln4108">    {</a>
<a name="ln4109">        const string tmp = &quot;resistant to &quot;</a>
<a name="ln4110">            + comma_separated_line(base_resists.begin(), base_resists.end());</a>
<a name="ln4111">        resist_descriptions.push_back(tmp);</a>
<a name="ln4112">    }</a>
<a name="ln4113"> </a>
<a name="ln4114">    const char* pronoun = mi.pronoun(PRONOUN_SUBJECTIVE);</a>
<a name="ln4115">    const bool plural = mi.pronoun_plurality();</a>
<a name="ln4116"> </a>
<a name="ln4117">    if (mi.threat != MTHRT_UNDEF)</a>
<a name="ln4118">    {</a>
<a name="ln4119">        result &lt;&lt; uppercase_first(pronoun) &lt;&lt; &quot; &quot;</a>
<a name="ln4120">               &lt;&lt; conjugate_verb(&quot;look&quot;, plural) &lt;&lt; &quot; &quot;</a>
<a name="ln4121">               &lt;&lt; _get_threat_desc(mi.threat) &lt;&lt; &quot;.\n&quot;;</a>
<a name="ln4122">    }</a>
<a name="ln4123"> </a>
<a name="ln4124">    if (!resist_descriptions.empty())</a>
<a name="ln4125">    {</a>
<a name="ln4126">        result &lt;&lt; uppercase_first(pronoun) &lt;&lt; &quot; &quot;</a>
<a name="ln4127">               &lt;&lt; conjugate_verb(&quot;are&quot;, plural) &lt;&lt; &quot; &quot;</a>
<a name="ln4128">               &lt;&lt; comma_separated_line(resist_descriptions.begin(),</a>
<a name="ln4129">                                       resist_descriptions.end(),</a>
<a name="ln4130">                                       &quot;; and &quot;, &quot;; &quot;)</a>
<a name="ln4131">               &lt;&lt; &quot;.\n&quot;;</a>
<a name="ln4132">    }</a>
<a name="ln4133"> </a>
<a name="ln4134">    // Is monster susceptible to anything? (On a new line.)</a>
<a name="ln4135">    if (!suscept.empty())</a>
<a name="ln4136">    {</a>
<a name="ln4137">        result &lt;&lt; uppercase_first(pronoun) &lt;&lt; &quot; &quot;</a>
<a name="ln4138">               &lt;&lt; conjugate_verb(&quot;are&quot;, plural) &lt;&lt; &quot; susceptible to &quot;</a>
<a name="ln4139">               &lt;&lt; comma_separated_line(suscept.begin(), suscept.end())</a>
<a name="ln4140">               &lt;&lt; &quot;.\n&quot;;</a>
<a name="ln4141">    }</a>
<a name="ln4142"> </a>
<a name="ln4143">    if (mi.is(MB_CHAOTIC))</a>
<a name="ln4144">    {</a>
<a name="ln4145">        result &lt;&lt; uppercase_first(pronoun) &lt;&lt; &quot; &quot;</a>
<a name="ln4146">               &lt;&lt; conjugate_verb(&quot;are&quot;, plural)</a>
<a name="ln4147">               &lt;&lt; &quot; vulnerable to silver and hated by Zin.\n&quot;;</a>
<a name="ln4148">    }</a>
<a name="ln4149"> </a>
<a name="ln4150">    if (mons_class_flag(mi.type, M_STATIONARY)</a>
<a name="ln4151">        &amp;&amp; !mons_is_tentacle_or_tentacle_segment(mi.type))</a>
<a name="ln4152">    {</a>
<a name="ln4153">        result &lt;&lt; uppercase_first(pronoun) &lt;&lt; &quot; cannot move.\n&quot;;</a>
<a name="ln4154">    }</a>
<a name="ln4155"> </a>
<a name="ln4156">    if (mons_class_flag(mi.type, M_COLD_BLOOD)</a>
<a name="ln4157">        &amp;&amp; get_resist(resist, MR_RES_COLD) &lt;= 0)</a>
<a name="ln4158">    {</a>
<a name="ln4159">        result &lt;&lt; uppercase_first(pronoun)</a>
<a name="ln4160">               &lt;&lt; &quot; &quot; &lt;&lt; conjugate_verb(&quot;are&quot;, plural)</a>
<a name="ln4161">               &lt;&lt; &quot; cold-blooded and may be slowed by cold attacks.\n&quot;;</a>
<a name="ln4162">    }</a>
<a name="ln4163"> </a>
<a name="ln4164">    // Seeing invisible.</a>
<a name="ln4165">    if (mi.can_see_invisible())</a>
<a name="ln4166">        result &lt;&lt; uppercase_first(pronoun) &lt;&lt; &quot; can see invisible.\n&quot;;</a>
<a name="ln4167"> </a>
<a name="ln4168">    // Echolocation, wolf noses, jellies, etc</a>
<a name="ln4169">    if (!mons_can_be_blinded(mi.type))</a>
<a name="ln4170">    {</a>
<a name="ln4171">        result &lt;&lt; uppercase_first(pronoun) &lt;&lt; &quot; &quot;</a>
<a name="ln4172">               &lt;&lt; conjugate_verb(&quot;are&quot;, plural)</a>
<a name="ln4173">               &lt;&lt; &quot; immune to blinding.\n&quot;;</a>
<a name="ln4174">    }</a>
<a name="ln4175">    // XXX: could mention &quot;immune to dazzling&quot; here, but that's spammy, since</a>
<a name="ln4176">    // it's true of such a huge number of monsters. (undead, statues, plants).</a>
<a name="ln4177">    // Might be better to have some place where players can see holiness &amp;</a>
<a name="ln4178">    // information about holiness.......?</a>
<a name="ln4179"> </a>
<a name="ln4180">    if (mi.intel() &lt;= I_BRAINLESS)</a>
<a name="ln4181">    {</a>
<a name="ln4182">        // Matters for Ely.</a>
<a name="ln4183">        result &lt;&lt; uppercase_first(pronoun) &lt;&lt; &quot; &quot;</a>
<a name="ln4184">               &lt;&lt; conjugate_verb(&quot;are&quot;, plural) &lt;&lt; &quot; mindless.\n&quot;;</a>
<a name="ln4185">    }</a>
<a name="ln4186">    else if (mi.intel() &gt;= I_HUMAN)</a>
<a name="ln4187">    {</a>
<a name="ln4188">        // Matters for Yred, Gozag, Zin, TSO, Alistair....</a>
<a name="ln4189">        result &lt;&lt; uppercase_first(pronoun) &lt;&lt; &quot; &quot;</a>
<a name="ln4190">               &lt;&lt; conjugate_verb(&quot;are&quot;, plural) &lt;&lt; &quot; intelligent.\n&quot;;</a>
<a name="ln4191">    }</a>
<a name="ln4192"> </a>
<a name="ln4193">    // Unusual monster speed.</a>
<a name="ln4194">    const int speed = mi.base_speed();</a>
<a name="ln4195">    bool did_speed = false;</a>
<a name="ln4196">    if (speed != 10 &amp;&amp; speed != 0)</a>
<a name="ln4197">    {</a>
<a name="ln4198">        did_speed = true;</a>
<a name="ln4199">        result &lt;&lt; uppercase_first(pronoun) &lt;&lt; &quot; &quot;</a>
<a name="ln4200">               &lt;&lt; conjugate_verb(&quot;are&quot;, plural) &lt;&lt; &quot; &quot;</a>
<a name="ln4201">               &lt;&lt; mi.speed_description();</a>
<a name="ln4202">    }</a>
<a name="ln4203">    const mon_energy_usage def = DEFAULT_ENERGY;</a>
<a name="ln4204">    if (!(mi.menergy == def))</a>
<a name="ln4205">    {</a>
<a name="ln4206">        const mon_energy_usage me = mi.menergy;</a>
<a name="ln4207">        vector&lt;string&gt; fast, slow;</a>
<a name="ln4208">        if (!did_speed)</a>
<a name="ln4209">            result &lt;&lt; uppercase_first(pronoun) &lt;&lt; &quot; &quot;;</a>
<a name="ln4210">        _add_energy_to_string(speed, me.move,</a>
<a name="ln4211">                              conjugate_verb(&quot;cover&quot;, plural) + &quot; ground&quot;,</a>
<a name="ln4212">                              fast, slow);</a>
<a name="ln4213">        // since MOVE_ENERGY also sets me.swim</a>
<a name="ln4214">        if (me.swim != me.move)</a>
<a name="ln4215">        {</a>
<a name="ln4216">            _add_energy_to_string(speed, me.swim,</a>
<a name="ln4217">                                  conjugate_verb(&quot;swim&quot;, plural), fast, slow);</a>
<a name="ln4218">        }</a>
<a name="ln4219">        _add_energy_to_string(speed, me.attack,</a>
<a name="ln4220">                              conjugate_verb(&quot;attack&quot;, plural), fast, slow);</a>
<a name="ln4221">        if (mons_class_itemuse(mi.type) &gt;= MONUSE_STARTING_EQUIPMENT)</a>
<a name="ln4222">        {</a>
<a name="ln4223">            _add_energy_to_string(speed, me.missile,</a>
<a name="ln4224">                                  conjugate_verb(&quot;shoot&quot;, plural), fast, slow);</a>
<a name="ln4225">        }</a>
<a name="ln4226">        _add_energy_to_string(</a>
<a name="ln4227">            speed, me.spell,</a>
<a name="ln4228">            mi.is_actual_spellcaster() ? conjugate_verb(&quot;cast&quot;, plural)</a>
<a name="ln4229">                                         + &quot; spells&quot; :</a>
<a name="ln4230">            mi.is_priest()             ? conjugate_verb(&quot;use&quot;, plural)</a>
<a name="ln4231">                                         + &quot; invocations&quot;</a>
<a name="ln4232">                                       : conjugate_verb(&quot;use&quot;, plural)</a>
<a name="ln4233">                                         + &quot; natural abilities&quot;, fast, slow);</a>
<a name="ln4234">        _add_energy_to_string(speed, me.special,</a>
<a name="ln4235">                              conjugate_verb(&quot;use&quot;, plural)</a>
<a name="ln4236">                              + &quot; special abilities&quot;,</a>
<a name="ln4237">                              fast, slow);</a>
<a name="ln4238">        if (mons_class_itemuse(mi.type) &gt;= MONUSE_STARTING_EQUIPMENT)</a>
<a name="ln4239">        {</a>
<a name="ln4240">            _add_energy_to_string(speed, me.item,</a>
<a name="ln4241">                                  conjugate_verb(&quot;use&quot;, plural) + &quot; items&quot;,</a>
<a name="ln4242">                                  fast, slow);</a>
<a name="ln4243">        }</a>
<a name="ln4244"> </a>
<a name="ln4245">        if (speed &gt;= 10)</a>
<a name="ln4246">        {</a>
<a name="ln4247">            if (did_speed &amp;&amp; fast.size() == 1)</a>
<a name="ln4248">                result &lt;&lt; &quot; and &quot; &lt;&lt; fast[0];</a>
<a name="ln4249">            else if (!fast.empty())</a>
<a name="ln4250">            {</a>
<a name="ln4251">                if (did_speed)</a>
<a name="ln4252">                    result &lt;&lt; &quot;, &quot;;</a>
<a name="ln4253">                result &lt;&lt; comma_separated_line(fast.begin(), fast.end());</a>
<a name="ln4254">            }</a>
<a name="ln4255">            if (!slow.empty())</a>
<a name="ln4256">            {</a>
<a name="ln4257">                if (did_speed || !fast.empty())</a>
<a name="ln4258">                    result &lt;&lt; &quot;, but &quot;;</a>
<a name="ln4259">                result &lt;&lt; comma_separated_line(slow.begin(), slow.end());</a>
<a name="ln4260">            }</a>
<a name="ln4261">        }</a>
<a name="ln4262">        else if (speed &lt; 10)</a>
<a name="ln4263">        {</a>
<a name="ln4264">            if (did_speed &amp;&amp; slow.size() == 1)</a>
<a name="ln4265">                result &lt;&lt; &quot; and &quot; &lt;&lt; slow[0];</a>
<a name="ln4266">            else if (!slow.empty())</a>
<a name="ln4267">            {</a>
<a name="ln4268">                if (did_speed)</a>
<a name="ln4269">                    result &lt;&lt; &quot;, &quot;;</a>
<a name="ln4270">                result &lt;&lt; comma_separated_line(slow.begin(), slow.end());</a>
<a name="ln4271">            }</a>
<a name="ln4272">            if (!fast.empty())</a>
<a name="ln4273">            {</a>
<a name="ln4274">                if (did_speed || !slow.empty())</a>
<a name="ln4275">                    result &lt;&lt; &quot;, but &quot;;</a>
<a name="ln4276">                result &lt;&lt; comma_separated_line(fast.begin(), fast.end());</a>
<a name="ln4277">            }</a>
<a name="ln4278">        }</a>
<a name="ln4279">        result &lt;&lt; &quot;.\n&quot;;</a>
<a name="ln4280">    }</a>
<a name="ln4281">    else if (did_speed)</a>
<a name="ln4282">        result &lt;&lt; &quot;.\n&quot;;</a>
<a name="ln4283"> </a>
<a name="ln4284">    if (mi.type == MONS_SHADOW)</a>
<a name="ln4285">    {</a>
<a name="ln4286">        // Cf. monster::action_energy() in monster.cc.</a>
<a name="ln4287">        result &lt;&lt; uppercase_first(pronoun) &lt;&lt; &quot; &quot;</a>
<a name="ln4288">               &lt;&lt; conjugate_verb(&quot;cover&quot;, plural)</a>
<a name="ln4289">               &lt;&lt; &quot; ground more quickly when invisible.\n&quot;;</a>
<a name="ln4290">    }</a>
<a name="ln4291"> </a>
<a name="ln4292">    if (mi.airborne())</a>
<a name="ln4293">        result &lt;&lt; uppercase_first(pronoun) &lt;&lt; &quot; can fly.\n&quot;;</a>
<a name="ln4294"> </a>
<a name="ln4295">    // Unusual regeneration rates.</a>
<a name="ln4296">    if (!mi.can_regenerate())</a>
<a name="ln4297">        result &lt;&lt; uppercase_first(pronoun) &lt;&lt; &quot; cannot regenerate.\n&quot;;</a>
<a name="ln4298">    else if (mons_class_fast_regen(mi.type))</a>
<a name="ln4299">        result &lt;&lt; uppercase_first(pronoun) &lt;&lt; &quot; &quot;</a>
<a name="ln4300">               &lt;&lt; conjugate_verb(&quot;regenerate&quot;, plural)</a>
<a name="ln4301">               &lt;&lt; &quot; quickly.\n&quot;;</a>
<a name="ln4302"> </a>
<a name="ln4303">    const char* mon_size = get_size_adj(mi.body_size(), true);</a>
<a name="ln4304">    if (mon_size)</a>
<a name="ln4305">    {</a>
<a name="ln4306">        result &lt;&lt; uppercase_first(pronoun) &lt;&lt; &quot; &quot;</a>
<a name="ln4307">               &lt;&lt; conjugate_verb(&quot;are&quot;, plural) &lt;&lt; &quot; &quot;</a>
<a name="ln4308">               &lt;&lt; mon_size &lt;&lt; &quot;.\n&quot;;</a>
<a name="ln4309">    }</a>
<a name="ln4310"> </a>
<a name="ln4311">    if (in_good_standing(GOD_ZIN, 0) &amp;&amp; !mi.pos.origin() &amp;&amp; monster_at(mi.pos))</a>
<a name="ln4312">    {</a>
<a name="ln4313">        recite_counts retval;</a>
<a name="ln4314">        monster *m = monster_at(mi.pos);</a>
<a name="ln4315">        auto eligibility = zin_check_recite_to_single_monster(m, retval);</a>
<a name="ln4316">        if (eligibility == RE_INELIGIBLE)</a>
<a name="ln4317">        {</a>
<a name="ln4318">            result &lt;&lt; uppercase_first(pronoun) &lt;&lt;</a>
<a name="ln4319">                    &quot; cannot be affected by reciting Zin's laws.&quot;;</a>
<a name="ln4320">        }</a>
<a name="ln4321">        else if (eligibility == RE_TOO_STRONG)</a>
<a name="ln4322">        {</a>
<a name="ln4323">            result &lt;&lt; uppercase_first(pronoun) &lt;&lt; &quot; &quot;</a>
<a name="ln4324">                   &lt;&lt; conjugate_verb(&quot;are&quot;, plural)</a>
<a name="ln4325">                   &lt;&lt; &quot; too strong to be affected by reciting Zin's laws.&quot;;</a>
<a name="ln4326">        }</a>
<a name="ln4327">        else // RE_ELIGIBLE || RE_RECITE_TIMER</a>
<a name="ln4328">        {</a>
<a name="ln4329">            result &lt;&lt; uppercase_first(pronoun) &lt;&lt;</a>
<a name="ln4330">                            &quot; can be affected by reciting Zin's laws.&quot;;</a>
<a name="ln4331">        }</a>
<a name="ln4332"> </a>
<a name="ln4333">        if (you.wizard)</a>
<a name="ln4334">        {</a>
<a name="ln4335">            result &lt;&lt; &quot; (Recite power:&quot; &lt;&lt; zin_recite_power()</a>
<a name="ln4336">                   &lt;&lt; &quot;, Hit dice:&quot; &lt;&lt; mi.hd &lt;&lt; &quot;)&quot;;</a>
<a name="ln4337">        }</a>
<a name="ln4338">        result &lt;&lt; &quot;\n&quot;;</a>
<a name="ln4339">    }</a>
<a name="ln4340"> </a>
<a name="ln4341">    result &lt;&lt; _monster_attacks_description(mi);</a>
<a name="ln4342">    result &lt;&lt; _monster_missiles_description(mi);</a>
<a name="ln4343">    result &lt;&lt; _monster_spells_description(mi);</a>
<a name="ln4344"> </a>
<a name="ln4345">    return result.str();</a>
<a name="ln4346">}</a>
<a name="ln4347"> </a>
<a name="ln4348">branch_type serpent_of_hell_branch(monster_type m)</a>
<a name="ln4349">{</a>
<a name="ln4350">    switch (m)</a>
<a name="ln4351">    {</a>
<a name="ln4352">    case MONS_SERPENT_OF_HELL_COCYTUS:</a>
<a name="ln4353">        return BRANCH_COCYTUS;</a>
<a name="ln4354">    case MONS_SERPENT_OF_HELL_DIS:</a>
<a name="ln4355">        return BRANCH_DIS;</a>
<a name="ln4356">    case MONS_SERPENT_OF_HELL_TARTARUS:</a>
<a name="ln4357">        return BRANCH_TARTARUS;</a>
<a name="ln4358">    case MONS_SERPENT_OF_HELL:</a>
<a name="ln4359">        return BRANCH_GEHENNA;</a>
<a name="ln4360">    default:</a>
<a name="ln4361">        die(&quot;bad serpent of hell monster_type&quot;);</a>
<a name="ln4362">    }</a>
<a name="ln4363">}</a>
<a name="ln4364"> </a>
<a name="ln4365">string serpent_of_hell_flavour(monster_type m)</a>
<a name="ln4366">{</a>
<a name="ln4367">    return lowercase_string(branches[serpent_of_hell_branch(m)].shortname);</a>
<a name="ln4368">}</a>
<a name="ln4369"> </a>
<a name="ln4370">// Fetches the monster's database description and reads it into inf.</a>
<a name="ln4371">void get_monster_db_desc(const monster_info&amp; mi, describe_info &amp;inf,</a>
<a name="ln4372">                         bool &amp;has_stat_desc)</a>
<a name="ln4373">{</a>
<a name="ln4374">    if (inf.title.empty())</a>
<a name="ln4375">        inf.title = getMiscString(mi.common_name(DESC_DBNAME) + &quot; title&quot;);</a>
<a name="ln4376">    if (inf.title.empty())</a>
<a name="ln4377">        inf.title = uppercase_first(mi.full_name(DESC_A)) + &quot;.&quot;;</a>
<a name="ln4378"> </a>
<a name="ln4379">    string db_name;</a>
<a name="ln4380"> </a>
<a name="ln4381">    if (mi.props.exists(&quot;dbname&quot;))</a>
<a name="ln4382">        db_name = mi.props[&quot;dbname&quot;].get_string();</a>
<a name="ln4383">    else if (mi.mname.empty())</a>
<a name="ln4384">        db_name = mi.db_name();</a>
<a name="ln4385">    else</a>
<a name="ln4386">        db_name = mi.full_name(DESC_PLAIN);</a>
<a name="ln4387"> </a>
<a name="ln4388">    if (mons_species(mi.type) == MONS_SERPENT_OF_HELL)</a>
<a name="ln4389">        db_name += &quot; &quot; + serpent_of_hell_flavour(mi.type);</a>
<a name="ln4390"> </a>
<a name="ln4391">    // This is somewhat hackish, but it's a good way of over-riding monsters'</a>
<a name="ln4392">    // descriptions in Lua vaults by using MonPropsMarker. This is also the</a>
<a name="ln4393">    // method used by set_feature_desc_long, etc. {due}</a>
<a name="ln4394">    if (!mi.description.empty())</a>
<a name="ln4395">        inf.body &lt;&lt; mi.description;</a>
<a name="ln4396">    // Don't get description for player ghosts.</a>
<a name="ln4397">    else if (mi.type != MONS_PLAYER_GHOST</a>
<a name="ln4398">             &amp;&amp; mi.type != MONS_PLAYER_ILLUSION)</a>
<a name="ln4399">    {</a>
<a name="ln4400">        inf.body &lt;&lt; getLongDescription(db_name);</a>
<a name="ln4401">    }</a>
<a name="ln4402"> </a>
<a name="ln4403">    // And quotes {due}</a>
<a name="ln4404">    if (!mi.quote.empty())</a>
<a name="ln4405">        inf.quote = mi.quote;</a>
<a name="ln4406">    else</a>
<a name="ln4407">        inf.quote = getQuoteString(db_name);</a>
<a name="ln4408"> </a>
<a name="ln4409">    string symbol;</a>
<a name="ln4410">    symbol += get_monster_data(mi.type)-&gt;basechar;</a>
<a name="ln4411">    if (isaupper(symbol[0]))</a>
<a name="ln4412">        symbol = &quot;cap-&quot; + symbol;</a>
<a name="ln4413"> </a>
<a name="ln4414">    string quote2;</a>
<a name="ln4415">    if (!mons_is_unique(mi.type))</a>
<a name="ln4416">    {</a>
<a name="ln4417">        string symbol_prefix = &quot;__&quot; + symbol + &quot;_prefix&quot;;</a>
<a name="ln4418">        inf.prefix = getLongDescription(symbol_prefix);</a>
<a name="ln4419"> </a>
<a name="ln4420">        string symbol_suffix = &quot;__&quot; + symbol + &quot;_suffix&quot;;</a>
<a name="ln4421">        quote2 = getQuoteString(symbol_suffix);</a>
<a name="ln4422">    }</a>
<a name="ln4423"> </a>
<a name="ln4424">    if (!inf.quote.empty() &amp;&amp; !quote2.empty())</a>
<a name="ln4425">        inf.quote += &quot;\n&quot;;</a>
<a name="ln4426">    inf.quote += quote2;</a>
<a name="ln4427"> </a>
<a name="ln4428">    const string it = mi.pronoun(PRONOUN_SUBJECTIVE);</a>
<a name="ln4429">    const string it_o = mi.pronoun(PRONOUN_OBJECTIVE);</a>
<a name="ln4430">    const string It = uppercase_first(it);</a>
<a name="ln4431">    const string is = conjugate_verb(&quot;are&quot;, mi.pronoun_plurality());</a>
<a name="ln4432"> </a>
<a name="ln4433">    switch (mi.type)</a>
<a name="ln4434">    {</a>
<a name="ln4435">    case MONS_RED_DRACONIAN:</a>
<a name="ln4436">    case MONS_WHITE_DRACONIAN:</a>
<a name="ln4437">    case MONS_GREEN_DRACONIAN:</a>
<a name="ln4438">    case MONS_PALE_DRACONIAN:</a>
<a name="ln4439">    case MONS_BLACK_DRACONIAN:</a>
<a name="ln4440">    case MONS_YELLOW_DRACONIAN:</a>
<a name="ln4441">    case MONS_PURPLE_DRACONIAN:</a>
<a name="ln4442">    case MONS_GREY_DRACONIAN:</a>
<a name="ln4443">    case MONS_DRACONIAN_SHIFTER:</a>
<a name="ln4444">    case MONS_DRACONIAN_SCORCHER:</a>
<a name="ln4445">    case MONS_DRACONIAN_ANNIHILATOR:</a>
<a name="ln4446">    case MONS_DRACONIAN_STORMCALLER:</a>
<a name="ln4447">    case MONS_DRACONIAN_MONK:</a>
<a name="ln4448">    case MONS_DRACONIAN_KNIGHT:</a>
<a name="ln4449">    {</a>
<a name="ln4450">        inf.body &lt;&lt; &quot;\n&quot; &lt;&lt; _describe_draconian(mi) &lt;&lt; &quot;\n&quot;;</a>
<a name="ln4451">        break;</a>
<a name="ln4452">    }</a>
<a name="ln4453"> </a>
<a name="ln4454">    case MONS_MONSTROUS_DEMONSPAWN:</a>
<a name="ln4455">    case MONS_GELID_DEMONSPAWN:</a>
<a name="ln4456">    case MONS_INFERNAL_DEMONSPAWN:</a>
<a name="ln4457">    case MONS_TORTUROUS_DEMONSPAWN:</a>
<a name="ln4458">    case MONS_BLOOD_SAINT:</a>
<a name="ln4459">    case MONS_WARMONGER:</a>
<a name="ln4460">    case MONS_CORRUPTER:</a>
<a name="ln4461">    case MONS_BLACK_SUN:</a>
<a name="ln4462">    {</a>
<a name="ln4463">        inf.body &lt;&lt; &quot;\n&quot; &lt;&lt; _describe_demonspawn(mi) &lt;&lt; &quot;\n&quot;;</a>
<a name="ln4464">        break;</a>
<a name="ln4465">    }</a>
<a name="ln4466"> </a>
<a name="ln4467">    case MONS_PLAYER_GHOST:</a>
<a name="ln4468">        inf.body &lt;&lt; &quot;The apparition of &quot; &lt;&lt; get_ghost_description(mi) &lt;&lt; &quot;.\n&quot;;</a>
<a name="ln4469">        if (mi.props.exists(MIRRORED_GHOST_KEY))</a>
<a name="ln4470">            inf.body &lt;&lt; &quot;It looks just like you...spooky!\n&quot;;</a>
<a name="ln4471">        break;</a>
<a name="ln4472"> </a>
<a name="ln4473">    case MONS_PLAYER_ILLUSION:</a>
<a name="ln4474">        inf.body &lt;&lt; &quot;An illusion of &quot; &lt;&lt; get_ghost_description(mi) &lt;&lt; &quot;.\n&quot;;</a>
<a name="ln4475">        break;</a>
<a name="ln4476"> </a>
<a name="ln4477">    case MONS_PANDEMONIUM_LORD:</a>
<a name="ln4478">        inf.body &lt;&lt; _describe_demon(mi.mname, mi.airborne()) &lt;&lt; &quot;\n&quot;;</a>
<a name="ln4479">        break;</a>
<a name="ln4480"> </a>
<a name="ln4481">    case MONS_MUTANT_BEAST:</a>
<a name="ln4482">        // vault renames get their own descriptions</a>
<a name="ln4483">        if (mi.mname.empty() || !mi.is(MB_NAME_REPLACE))</a>
<a name="ln4484">            inf.body &lt;&lt; _describe_mutant_beast(mi) &lt;&lt; &quot;\n&quot;;</a>
<a name="ln4485">        break;</a>
<a name="ln4486"> </a>
<a name="ln4487">    case MONS_BLOCK_OF_ICE:</a>
<a name="ln4488">        if (mi.is(MB_SLOWLY_DYING))</a>
<a name="ln4489">            inf.body &lt;&lt; &quot;\nIt is quickly melting away.\n&quot;;</a>
<a name="ln4490">        break;</a>
<a name="ln4491"> </a>
<a name="ln4492">    case MONS_PILLAR_OF_SALT:</a>
<a name="ln4493">        if (mi.is(MB_SLOWLY_DYING))</a>
<a name="ln4494">            inf.body &lt;&lt; &quot;\nIt is quickly crumbling away.\n&quot;;</a>
<a name="ln4495">        break;</a>
<a name="ln4496"> </a>
<a name="ln4497">    case MONS_PROGRAM_BUG:</a>
<a name="ln4498">        inf.body &lt;&lt; &quot;If this monster is a \&quot;program bug\&quot;, then it's &quot;</a>
<a name="ln4499">                &quot;recommended that you save your game and reload. Please report &quot;</a>
<a name="ln4500">                &quot;monsters who masquerade as program bugs or run around the &quot;</a>
<a name="ln4501">                &quot;dungeon without a proper description to the authorities.\n&quot;;</a>
<a name="ln4502">        break;</a>
<a name="ln4503"> </a>
<a name="ln4504">    default:</a>
<a name="ln4505">        break;</a>
<a name="ln4506">    }</a>
<a name="ln4507"> </a>
<a name="ln4508">    if (!mons_is_unique(mi.type))</a>
<a name="ln4509">    {</a>
<a name="ln4510">        string symbol_suffix = &quot;__&quot;;</a>
<a name="ln4511">        symbol_suffix += symbol;</a>
<a name="ln4512">        symbol_suffix += &quot;_suffix&quot;;</a>
<a name="ln4513"> </a>
<a name="ln4514">        string suffix = getLongDescription(symbol_suffix)</a>
<a name="ln4515">                      + getLongDescription(symbol_suffix + &quot;_examine&quot;);</a>
<a name="ln4516"> </a>
<a name="ln4517">        if (!suffix.empty())</a>
<a name="ln4518">            inf.body &lt;&lt; &quot;\n&quot; &lt;&lt; suffix;</a>
<a name="ln4519">    }</a>
<a name="ln4520"> </a>
<a name="ln4521">    const int curse_power = mummy_curse_power(mi.type);</a>
<a name="ln4522">    if (curse_power &amp;&amp; !mi.is(MB_SUMMONED))</a>
<a name="ln4523">    {</a>
<a name="ln4524">        inf.body &lt;&lt; &quot;\n&quot; &lt;&lt; It &lt;&lt; &quot; will inflict a &quot;;</a>
<a name="ln4525">        if (curse_power &gt; 10)</a>
<a name="ln4526">            inf.body &lt;&lt; &quot;powerful &quot;;</a>
<a name="ln4527">        inf.body &lt;&lt; &quot;necromantic curse on &quot;</a>
<a name="ln4528">                 &lt;&lt; mi.pronoun(PRONOUN_POSSESSIVE) &lt;&lt; &quot; foe when destroyed.\n&quot;;</a>
<a name="ln4529">    }</a>
<a name="ln4530"> </a>
<a name="ln4531">    // Get information on resistances, speed, etc.</a>
<a name="ln4532">    string result = _monster_stat_description(mi);</a>
<a name="ln4533">    if (!result.empty())</a>
<a name="ln4534">    {</a>
<a name="ln4535">        inf.body &lt;&lt; &quot;\n&quot; &lt;&lt; result;</a>
<a name="ln4536">        has_stat_desc = true;</a>
<a name="ln4537">    }</a>
<a name="ln4538"> </a>
<a name="ln4539">    bool stair_use = false;</a>
<a name="ln4540">    if (!mons_class_can_use_stairs(mi.type))</a>
<a name="ln4541">    {</a>
<a name="ln4542">        inf.body &lt;&lt; It &lt;&lt; &quot; &quot; &lt;&lt; is &lt;&lt; &quot; incapable of using stairs.\n&quot;;</a>
<a name="ln4543">        stair_use = true;</a>
<a name="ln4544">    }</a>
<a name="ln4545"> </a>
<a name="ln4546">    if (mi.is(MB_SUMMONED) || mi.is(MB_PERM_SUMMON))</a>
<a name="ln4547">    {</a>
<a name="ln4548">        inf.body &lt;&lt; &quot;\nThis monster has been summoned&quot;</a>
<a name="ln4549">                 &lt;&lt; (mi.is(MB_SUMMONED) ? &quot;, and is thus only temporary. &quot;</a>
<a name="ln4550">                                        : &quot; in a durable way. &quot;);</a>
<a name="ln4551">        // TODO: hacks; convert angered_by_attacks to a monster_info check</a>
<a name="ln4552">        // (but on the other hand, it is really limiting to not have access</a>
<a name="ln4553">        // to the monster...)</a>
<a name="ln4554">        if (!mi.pos.origin() &amp;&amp; monster_at(mi.pos)</a>
<a name="ln4555">                                &amp;&amp; monster_at(mi.pos)-&gt;angered_by_attacks()</a>
<a name="ln4556">                                &amp;&amp; mi.attitude == ATT_FRIENDLY)</a>
<a name="ln4557">        {</a>
<a name="ln4558">            inf.body &lt;&lt; &quot;If angered &quot; &lt;&lt; it</a>
<a name="ln4559">                                      &lt;&lt; &quot; will immediately vanish, yielding &quot;;</a>
<a name="ln4560">        }</a>
<a name="ln4561">        else</a>
<a name="ln4562">            inf.body &lt;&lt; &quot;Killing &quot; &lt;&lt; it_o &lt;&lt; &quot; yields &quot;;</a>
<a name="ln4563">        inf.body &lt;&lt; &quot;no experience, nutrition or items&quot;;</a>
<a name="ln4564"> </a>
<a name="ln4565">        if (!stair_use)</a>
<a name="ln4566">            inf.body &lt;&lt; &quot;; &quot; &lt;&lt; it &lt;&lt; &quot; &quot; &lt;&lt; is &lt;&lt; &quot; incapable of using stairs&quot;;</a>
<a name="ln4567"> </a>
<a name="ln4568">        if (mi.is(MB_PERM_SUMMON))</a>
<a name="ln4569">            inf.body &lt;&lt; &quot;, and &quot; &lt;&lt; it &lt;&lt; &quot; cannot be abjured&quot;;</a>
<a name="ln4570"> </a>
<a name="ln4571">        inf.body &lt;&lt; &quot;.\n&quot;;</a>
<a name="ln4572">    }</a>
<a name="ln4573">    else if (mi.is(MB_NO_REWARD))</a>
<a name="ln4574">    {</a>
<a name="ln4575">        inf.body &lt;&lt; &quot;\nKilling this monster yields no experience, nutrition or&quot;</a>
<a name="ln4576">                    &quot; items.&quot;;</a>
<a name="ln4577">    }</a>
<a name="ln4578">    else if (mons_class_leaves_hide(mi.type))</a>
<a name="ln4579">    {</a>
<a name="ln4580">        inf.body &lt;&lt; &quot;\nIf &quot; &lt;&lt; it &lt;&lt; &quot; &quot; &lt;&lt; is &lt;&lt;</a>
<a name="ln4581">                    &quot; slain, it may be possible to recover &quot;</a>
<a name="ln4582">                 &lt;&lt; mi.pronoun(PRONOUN_POSSESSIVE)</a>
<a name="ln4583">                 &lt;&lt; &quot; hide, which can be used as armour.\n&quot;;</a>
<a name="ln4584">    }</a>
<a name="ln4585"> </a>
<a name="ln4586">    if (mi.is(MB_SUMMONED_CAPPED))</a>
<a name="ln4587">    {</a>
<a name="ln4588">        inf.body &lt;&lt; &quot;\nYou have summoned too many monsters of this kind to &quot;</a>
<a name="ln4589">                    &quot;sustain them all, and thus this one will shortly &quot;</a>
<a name="ln4590">                    &quot;expire.\n&quot;;</a>
<a name="ln4591">    }</a>
<a name="ln4592"> </a>
<a name="ln4593">    if (!inf.quote.empty())</a>
<a name="ln4594">        inf.quote += &quot;\n&quot;;</a>
<a name="ln4595"> </a>
<a name="ln4596">#ifdef DEBUG_DIAGNOSTICS</a>
<a name="ln4597">    if (you.suppress_wizard)</a>
<a name="ln4598">        return;</a>
<a name="ln4599">    if (mi.pos.origin() || !monster_at(mi.pos))</a>
<a name="ln4600">        return; // not a real monster</a>
<a name="ln4601">    monster&amp; mons = *monster_at(mi.pos);</a>
<a name="ln4602"> </a>
<a name="ln4603">    if (mons.has_originating_map())</a>
<a name="ln4604">    {</a>
<a name="ln4605">        inf.body &lt;&lt; make_stringf(&quot;\nPlaced by map: %s&quot;,</a>
<a name="ln4606">                                 mons.originating_map().c_str());</a>
<a name="ln4607">    }</a>
<a name="ln4608"> </a>
<a name="ln4609">    inf.body &lt;&lt; &quot;\nMonster health: &quot;</a>
<a name="ln4610">             &lt;&lt; mons.hit_points &lt;&lt; &quot;/&quot; &lt;&lt; mons.max_hit_points &lt;&lt; &quot;\n&quot;;</a>
<a name="ln4611"> </a>
<a name="ln4612">    const actor *mfoe = mons.get_foe();</a>
<a name="ln4613">    inf.body &lt;&lt; &quot;Monster foe: &quot;</a>
<a name="ln4614">             &lt;&lt; (mfoe? mfoe-&gt;name(DESC_PLAIN, true)</a>
<a name="ln4615">                 : &quot;(none)&quot;);</a>
<a name="ln4616"> </a>
<a name="ln4617">    vector&lt;string&gt; attitude;</a>
<a name="ln4618">    if (mons.friendly())</a>
<a name="ln4619">        attitude.emplace_back(&quot;friendly&quot;);</a>
<a name="ln4620">    if (mons.neutral())</a>
<a name="ln4621">        attitude.emplace_back(&quot;neutral&quot;);</a>
<a name="ln4622">    if (mons.good_neutral())</a>
<a name="ln4623">        attitude.emplace_back(&quot;good_neutral&quot;);</a>
<a name="ln4624">    if (mons.strict_neutral())</a>
<a name="ln4625">        attitude.emplace_back(&quot;strict_neutral&quot;);</a>
<a name="ln4626">    if (mons.pacified())</a>
<a name="ln4627">        attitude.emplace_back(&quot;pacified&quot;);</a>
<a name="ln4628">    if (mons.wont_attack())</a>
<a name="ln4629">        attitude.emplace_back(&quot;wont_attack&quot;);</a>
<a name="ln4630">    if (!attitude.empty())</a>
<a name="ln4631">    {</a>
<a name="ln4632">        string att = comma_separated_line(attitude.begin(), attitude.end(),</a>
<a name="ln4633">                                          &quot;; &quot;, &quot;; &quot;);</a>
<a name="ln4634">        if (mons.has_ench(ENCH_INSANE))</a>
<a name="ln4635">            inf.body &lt;&lt; &quot;; frenzied and insane (otherwise &quot; &lt;&lt; att &lt;&lt; &quot;)&quot;;</a>
<a name="ln4636">        else</a>
<a name="ln4637">            inf.body &lt;&lt; &quot;; &quot; &lt;&lt; att;</a>
<a name="ln4638">    }</a>
<a name="ln4639">    else if (mons.has_ench(ENCH_INSANE))</a>
<a name="ln4640">        inf.body &lt;&lt; &quot;; frenzied and insane&quot;;</a>
<a name="ln4641"> </a>
<a name="ln4642">    inf.body &lt;&lt; &quot;\n\nHas holiness: &quot;;</a>
<a name="ln4643">    inf.body &lt;&lt; holiness_description(mi.holi);</a>
<a name="ln4644">    inf.body &lt;&lt; &quot;.&quot;;</a>
<a name="ln4645"> </a>
<a name="ln4646">    const monster_spells &amp;hspell_pass = mons.spells;</a>
<a name="ln4647">    bool found_spell = false;</a>
<a name="ln4648"> </a>
<a name="ln4649">    for (unsigned int i = 0; i &lt; hspell_pass.size(); ++i)</a>
<a name="ln4650">    {</a>
<a name="ln4651">        if (!found_spell)</a>
<a name="ln4652">        {</a>
<a name="ln4653">            inf.body &lt;&lt; &quot;\n\nMonster Spells:\n&quot;;</a>
<a name="ln4654">            found_spell = true;</a>
<a name="ln4655">        }</a>
<a name="ln4656"> </a>
<a name="ln4657">        inf.body &lt;&lt; &quot;    &quot; &lt;&lt; i &lt;&lt; &quot;: &quot;</a>
<a name="ln4658">                 &lt;&lt; spell_title(hspell_pass[i].spell)</a>
<a name="ln4659">                 &lt;&lt; &quot; (&quot;;</a>
<a name="ln4660">        if (hspell_pass[i].flags &amp; MON_SPELL_EMERGENCY)</a>
<a name="ln4661">            inf.body &lt;&lt; &quot;emergency, &quot;;</a>
<a name="ln4662">        if (hspell_pass[i].flags &amp; MON_SPELL_NATURAL)</a>
<a name="ln4663">            inf.body &lt;&lt; &quot;natural, &quot;;</a>
<a name="ln4664">        if (hspell_pass[i].flags &amp; MON_SPELL_MAGICAL)</a>
<a name="ln4665">            inf.body &lt;&lt; &quot;magical, &quot;;</a>
<a name="ln4666">        if (hspell_pass[i].flags &amp; MON_SPELL_WIZARD)</a>
<a name="ln4667">            inf.body &lt;&lt; &quot;wizard, &quot;;</a>
<a name="ln4668">        if (hspell_pass[i].flags &amp; MON_SPELL_PRIEST)</a>
<a name="ln4669">            inf.body &lt;&lt; &quot;priest, &quot;;</a>
<a name="ln4670">        if (hspell_pass[i].flags &amp; MON_SPELL_BREATH)</a>
<a name="ln4671">            inf.body &lt;&lt; &quot;breath, &quot;;</a>
<a name="ln4672">        inf.body &lt;&lt; (int) hspell_pass[i].freq &lt;&lt; &quot;)&quot;;</a>
<a name="ln4673">    }</a>
<a name="ln4674"> </a>
<a name="ln4675">    bool has_item = false;</a>
<a name="ln4676">    for (mon_inv_iterator ii(mons); ii; ++ii)</a>
<a name="ln4677">    {</a>
<a name="ln4678">        if (!has_item)</a>
<a name="ln4679">        {</a>
<a name="ln4680">            inf.body &lt;&lt; &quot;\n\nMonster Inventory:\n&quot;;</a>
<a name="ln4681">            has_item = true;</a>
<a name="ln4682">        }</a>
<a name="ln4683">        inf.body &lt;&lt; &quot;    &quot; &lt;&lt; ii.slot() &lt;&lt; &quot;: &quot;</a>
<a name="ln4684">                 &lt;&lt; ii-&gt;name(DESC_A, false, true);</a>
<a name="ln4685">    }</a>
<a name="ln4686"> </a>
<a name="ln4687">    if (mons.props.exists(&quot;blame&quot;))</a>
<a name="ln4688">    {</a>
<a name="ln4689">        inf.body &lt;&lt; &quot;\n\nMonster blame chain:\n&quot;;</a>
<a name="ln4690"> </a>
<a name="ln4691">        const CrawlVector&amp; blame = mons.props[&quot;blame&quot;].get_vector();</a>
<a name="ln4692"> </a>
<a name="ln4693">        for (const auto &amp;entry : blame)</a>
<a name="ln4694">            inf.body &lt;&lt; &quot;    &quot; &lt;&lt; entry.get_string() &lt;&lt; &quot;\n&quot;;</a>
<a name="ln4695">    }</a>
<a name="ln4696">    inf.body &lt;&lt; &quot;\n\n&quot; &lt;&lt; debug_constriction_string(&amp;mons);</a>
<a name="ln4697">#endif</a>
<a name="ln4698">}</a>
<a name="ln4699"> </a>
<a name="ln4700">int describe_monsters(const monster_info &amp;mi, const string&amp; /*footer*/)</a>
<a name="ln4701">{</a>
<a name="ln4702">    bool has_stat_desc = false;</a>
<a name="ln4703">    describe_info inf;</a>
<a name="ln4704">    formatted_string desc;</a>
<a name="ln4705"> </a>
<a name="ln4706">    get_monster_db_desc(mi, inf, has_stat_desc);</a>
<a name="ln4707"> </a>
<a name="ln4708">    spellset spells = monster_spellset(mi);</a>
<a name="ln4709"> </a>
<a name="ln4710">    auto vbox = make_shared&lt;Box&gt;(Widget::VERT);</a>
<a name="ln4711">    auto title_hbox = make_shared&lt;Box&gt;(Widget::HORZ);</a>
<a name="ln4712"> </a>
<a name="ln4713">#ifdef USE_TILE_LOCAL</a>
<a name="ln4714">    auto dgn = make_shared&lt;Dungeon&gt;();</a>
<a name="ln4715">    dgn-&gt;width = dgn-&gt;height = 1;</a>
<a name="ln4716">    dgn-&gt;buf().add_monster(mi, 0, 0);</a>
<a name="ln4717">    title_hbox-&gt;add_child(move(dgn));</a>
<a name="ln4718">#endif</a>
<a name="ln4719"> </a>
<a name="ln4720">    auto title = make_shared&lt;Text&gt;();</a>
<a name="ln4721">    title-&gt;set_text(inf.title);</a>
<a name="ln4722">    title-&gt;set_margin_for_sdl(0, 0, 0, 10);</a>
<a name="ln4723">    title_hbox-&gt;add_child(move(title));</a>
<a name="ln4724"> </a>
<a name="ln4725">    title_hbox-&gt;set_cross_alignment(Widget::CENTER);</a>
<a name="ln4726">    title_hbox-&gt;set_margin_for_crt(0, 0, 1, 0);</a>
<a name="ln4727">    title_hbox-&gt;set_margin_for_sdl(0, 0, 20, 0);</a>
<a name="ln4728">    vbox-&gt;add_child(move(title_hbox));</a>
<a name="ln4729"> </a>
<a name="ln4730">    desc += inf.body.str();</a>
<a name="ln4731">    if (crawl_state.game_is_hints())</a>
<a name="ln4732">        desc += formatted_string(hints_describe_monster(mi, has_stat_desc));</a>
<a name="ln4733">    desc += inf.footer;</a>
<a name="ln4734">    desc = formatted_string::parse_string(trimmed_string(desc));</a>
<a name="ln4735"> </a>
<a name="ln4736">    const formatted_string quote = formatted_string(trimmed_string(inf.quote));</a>
<a name="ln4737"> </a>
<a name="ln4738">    auto desc_sw = make_shared&lt;Switcher&gt;();</a>
<a name="ln4739">    auto more_sw = make_shared&lt;Switcher&gt;();</a>
<a name="ln4740">    desc_sw-&gt;current() = 0;</a>
<a name="ln4741">    more_sw-&gt;current() = 0;</a>
<a name="ln4742"> </a>
<a name="ln4743">#ifdef USE_TILE_LOCAL</a>
<a name="ln4744"># define MORE_PREFIX &quot;[&lt;w&gt;!&lt;/w&gt;&quot; &quot;|&lt;w&gt;Right-click&lt;/w&gt;&quot; &quot;]: &quot;</a>
<a name="ln4745">#else</a>
<a name="ln4746"># define MORE_PREFIX &quot;[&lt;w&gt;!&lt;/w&gt;&quot; &quot;]: &quot;</a>
<a name="ln4747">#endif</a>
<a name="ln4748"> </a>
<a name="ln4749">    const char* mores[2] = {</a>
<a name="ln4750">        MORE_PREFIX &quot;&lt;w&gt;Description&lt;/w&gt;|Quote&quot;,</a>
<a name="ln4751">        MORE_PREFIX &quot;Description|&lt;w&gt;Quote&lt;/w&gt;&quot;,</a>
<a name="ln4752">    };</a>
<a name="ln4753"> </a>
<a name="ln4754">    for (int i = 0; i &lt; (inf.quote.empty() ? 1 : 2); i++)</a>
<a name="ln4755">    {</a>
<a name="ln4756">        const formatted_string *content[2] = { &amp;desc, &amp;quote };</a>
<a name="ln4757">        auto scroller = make_shared&lt;Scroller&gt;();</a>
<a name="ln4758">        auto text = make_shared&lt;Text&gt;(content[i]-&gt;trim());</a>
<a name="ln4759">        text-&gt;set_wrap_text(true);</a>
<a name="ln4760">        scroller-&gt;set_child(text);</a>
<a name="ln4761">        desc_sw-&gt;add_child(move(scroller));</a>
<a name="ln4762"> </a>
<a name="ln4763">        more_sw-&gt;add_child(make_shared&lt;Text&gt;(</a>
<a name="ln4764">                formatted_string::parse_string(mores[i])));</a>
<a name="ln4765">    }</a>
<a name="ln4766"> </a>
<a name="ln4767">    more_sw-&gt;set_margin_for_sdl(20, 0, 0, 0);</a>
<a name="ln4768">    more_sw-&gt;set_margin_for_crt(1, 0, 0, 0);</a>
<a name="ln4769">    desc_sw-&gt;expand_h = false;</a>
<a name="ln4770">    desc_sw-&gt;align_x = Widget::STRETCH;</a>
<a name="ln4771">    vbox-&gt;add_child(desc_sw);</a>
<a name="ln4772">    if (!inf.quote.empty())</a>
<a name="ln4773">        vbox-&gt;add_child(more_sw);</a>
<a name="ln4774"> </a>
<a name="ln4775">#ifdef USE_TILE_LOCAL</a>
<a name="ln4776">    vbox-&gt;max_size().width = tiles.get_crt_font()-&gt;char_width()*80;</a>
<a name="ln4777">#endif</a>
<a name="ln4778"> </a>
<a name="ln4779">    auto popup = make_shared&lt;ui::Popup&gt;(move(vbox));</a>
<a name="ln4780"> </a>
<a name="ln4781">    bool done = false;</a>
<a name="ln4782">    int lastch;</a>
<a name="ln4783">    popup-&gt;on_keydown_event([&amp;](const KeyEvent&amp; ev) {</a>
<a name="ln4784">        const auto key = ev.key();</a>
<a name="ln4785">        lastch = key;</a>
<a name="ln4786">        done = key == CK_ESCAPE;</a>
<a name="ln4787">        if (!inf.quote.empty() &amp;&amp; (key == '!' || key == CK_MOUSE_CMD))</a>
<a name="ln4788">        {</a>
<a name="ln4789">            int n = (desc_sw-&gt;current() + 1) % 2;</a>
<a name="ln4790">            desc_sw-&gt;current() = more_sw-&gt;current() = n;</a>
<a name="ln4791">#ifdef USE_TILE_WEB</a>
<a name="ln4792">            tiles.json_open_object();</a>
<a name="ln4793">            tiles.json_write_int(&quot;pane&quot;, n);</a>
<a name="ln4794">            tiles.ui_state_change(&quot;describe-monster&quot;, 0);</a>
<a name="ln4795">#endif</a>
<a name="ln4796">        }</a>
<a name="ln4797">        if (desc_sw-&gt;current_widget()-&gt;on_event(ev))</a>
<a name="ln4798">            return true;</a>
<a name="ln4799">        const vector&lt;pair&lt;spell_type,char&gt;&gt; spell_map = map_chars_to_spells(spells, nullptr);</a>
<a name="ln4800">        auto entry = find_if(spell_map.begin(), spell_map.end(),</a>
<a name="ln4801">                [key](const pair&lt;spell_type,char&gt;&amp; e) { return e.second == key; });</a>
<a name="ln4802">        if (entry == spell_map.end())</a>
<a name="ln4803">            return false;</a>
<a name="ln4804">        describe_spell(entry-&gt;first, &amp;mi, nullptr);</a>
<a name="ln4805">        return true;</a>
<a name="ln4806">    });</a>
<a name="ln4807"> </a>
<a name="ln4808">#ifdef USE_TILE_WEB</a>
<a name="ln4809">    tiles.json_open_object();</a>
<a name="ln4810">    tiles.json_write_string(&quot;title&quot;, inf.title);</a>
<a name="ln4811">    formatted_string needle;</a>
<a name="ln4812">    describe_spellset(spells, nullptr, needle, &amp;mi);</a>
<a name="ln4813">    string desc_without_spells = desc.to_colour_string();</a>
<a name="ln4814">    if (!needle.empty())</a>
<a name="ln4815">    {</a>
<a name="ln4816">        desc_without_spells = replace_all(desc_without_spells,</a>
<a name="ln4817">                needle.to_colour_string(), &quot;SPELLSET_PLACEHOLDER&quot;);</a>
<a name="ln4818">    }</a>
<a name="ln4819">    tiles.json_write_string(&quot;body&quot;, desc_without_spells);</a>
<a name="ln4820">    tiles.json_write_string(&quot;quote&quot;, quote);</a>
<a name="ln4821">    write_spellset(spells, nullptr, &amp;mi);</a>
<a name="ln4822"> </a>
<a name="ln4823">    {</a>
<a name="ln4824">        tileidx_t t    = tileidx_monster(mi);</a>
<a name="ln4825">        tileidx_t t0   = t &amp; TILE_FLAG_MASK;</a>
<a name="ln4826">        tileidx_t flag = t &amp; (~TILE_FLAG_MASK);</a>
<a name="ln4827"> </a>
<a name="ln4828">        if (!mons_class_is_stationary(mi.type) || mi.type == MONS_TRAINING_DUMMY)</a>
<a name="ln4829">        {</a>
<a name="ln4830">            tileidx_t mcache_idx = mcache.register_monster(mi);</a>
<a name="ln4831">            t = flag | (mcache_idx ? mcache_idx : t0);</a>
<a name="ln4832">            t0 = t &amp; TILE_FLAG_MASK;</a>
<a name="ln4833">        }</a>
<a name="ln4834"> </a>
<a name="ln4835">        tiles.json_write_int(&quot;fg_idx&quot;, t0);</a>
<a name="ln4836">        tiles.json_write_name(&quot;flag&quot;);</a>
<a name="ln4837">        tiles.write_tileidx(flag);</a>
<a name="ln4838"> </a>
<a name="ln4839">        if (t0 &gt;= TILEP_MCACHE_START)</a>
<a name="ln4840">        {</a>
<a name="ln4841">            mcache_entry *entry = mcache.get(t0);</a>
<a name="ln4842">            if (entry)</a>
<a name="ln4843">                tiles.send_mcache(entry, false);</a>
<a name="ln4844">            else</a>
<a name="ln4845">            {</a>
<a name="ln4846">                tiles.json_write_comma();</a>
<a name="ln4847">                tiles.write_message(&quot;\&quot;doll\&quot;:[[%d,%d]]&quot;, TILEP_MONS_UNKNOWN, TILE_Y);</a>
<a name="ln4848">                tiles.json_write_null(&quot;mcache&quot;);</a>
<a name="ln4849">            }</a>
<a name="ln4850">        }</a>
<a name="ln4851">        else if (t0 &gt;= TILE_MAIN_MAX)</a>
<a name="ln4852">        {</a>
<a name="ln4853">            tiles.json_write_comma();</a>
<a name="ln4854">            tiles.write_message(&quot;\&quot;doll\&quot;:[[%u,%d]]&quot;, (unsigned int) t0, TILE_Y);</a>
<a name="ln4855">            tiles.json_write_null(&quot;mcache&quot;);</a>
<a name="ln4856">        }</a>
<a name="ln4857">    }</a>
<a name="ln4858">    tiles.push_ui_layout(&quot;describe-monster&quot;, 1);</a>
<a name="ln4859">    popup-&gt;on_layout_pop([](){ tiles.pop_ui_layout(); });</a>
<a name="ln4860">#endif</a>
<a name="ln4861"> </a>
<a name="ln4862">    ui::run_layout(move(popup), done);</a>
<a name="ln4863"> </a>
<a name="ln4864">    return lastch;</a>
<a name="ln4865">}</a>
<a name="ln4866"> </a>
<a name="ln4867">static const char* xl_rank_names[] =</a>
<a name="ln4868">{</a>
<a name="ln4869">    &quot;weakling&quot;,</a>
<a name="ln4870">    &quot;amateur&quot;,</a>
<a name="ln4871">    &quot;novice&quot;,</a>
<a name="ln4872">    &quot;journeyman&quot;,</a>
<a name="ln4873">    &quot;adept&quot;,</a>
<a name="ln4874">    &quot;veteran&quot;,</a>
<a name="ln4875">    &quot;master&quot;,</a>
<a name="ln4876">    &quot;legendary&quot;</a>
<a name="ln4877">};</a>
<a name="ln4878"> </a>
<a name="ln4879">static string _xl_rank_name(const int xl_rank)</a>
<a name="ln4880">{</a>
<a name="ln4881">    const string rank = xl_rank_names[xl_rank];</a>
<a name="ln4882"> </a>
<a name="ln4883">    return article_a(rank);</a>
<a name="ln4884">}</a>
<a name="ln4885"> </a>
<a name="ln4886">string short_ghost_description(const monster *mon, bool abbrev)</a>
<a name="ln4887">{</a>
<a name="ln4888">    ASSERT(mons_is_pghost(mon-&gt;type));</a>
<a name="ln4889"> </a>
<a name="ln4890">    const ghost_demon &amp;ghost = *(mon-&gt;ghost);</a>
<a name="ln4891">    const char* rank = xl_rank_names[ghost_level_to_rank(ghost.xl)];</a>
<a name="ln4892"> </a>
<a name="ln4893">    string desc = make_stringf(&quot;%s %s %s&quot;, rank,</a>
<a name="ln4894">                               species_name(ghost.species).c_str(),</a>
<a name="ln4895">                               get_job_name(ghost.job));</a>
<a name="ln4896"> </a>
<a name="ln4897">    if (abbrev || strwidth(desc) &gt; 40)</a>
<a name="ln4898">    {</a>
<a name="ln4899">        desc = make_stringf(&quot;%s %s%s&quot;,</a>
<a name="ln4900">                            rank,</a>
<a name="ln4901">                            get_species_abbrev(ghost.species),</a>
<a name="ln4902">                            get_job_abbrev(ghost.job));</a>
<a name="ln4903">    }</a>
<a name="ln4904"> </a>
<a name="ln4905">    return desc;</a>
<a name="ln4906">}</a>
<a name="ln4907"> </a>
<a name="ln4908">// Describes the current ghost's previous owner. The caller must</a>
<a name="ln4909">// prepend &quot;The apparition of&quot; or whatever and append any trailing</a>
<a name="ln4910">// punctuation that's wanted.</a>
<a name="ln4911">string get_ghost_description(const monster_info &amp;mi, bool concise)</a>
<a name="ln4912">{</a>
<a name="ln4913">    ostringstream gstr;</a>
<a name="ln4914"> </a>
<a name="ln4915">    const species_type gspecies = mi.i_ghost.species;</a>
<a name="ln4916"> </a>
<a name="ln4917">    gstr &lt;&lt; mi.mname &lt;&lt; &quot; the &quot;</a>
<a name="ln4918">         &lt;&lt; skill_title_by_rank(mi.i_ghost.best_skill,</a>
<a name="ln4919">                        mi.i_ghost.best_skill_rank,</a>
<a name="ln4920">                        gspecies,</a>
<a name="ln4921">                        species_has_low_str(gspecies), mi.i_ghost.religion)</a>
<a name="ln4922">         &lt;&lt; &quot;, &quot; &lt;&lt; _xl_rank_name(mi.i_ghost.xl_rank) &lt;&lt; &quot; &quot;;</a>
<a name="ln4923"> </a>
<a name="ln4924">    if (concise)</a>
<a name="ln4925">    {</a>
<a name="ln4926">        gstr &lt;&lt; get_species_abbrev(gspecies)</a>
<a name="ln4927">             &lt;&lt; get_job_abbrev(mi.i_ghost.job);</a>
<a name="ln4928">    }</a>
<a name="ln4929">    else</a>
<a name="ln4930">    {</a>
<a name="ln4931">        gstr &lt;&lt; species_name(gspecies)</a>
<a name="ln4932">             &lt;&lt; &quot; &quot;</a>
<a name="ln4933">             &lt;&lt; get_job_name(mi.i_ghost.job);</a>
<a name="ln4934">    }</a>
<a name="ln4935"> </a>
<a name="ln4936">    if (mi.i_ghost.religion != GOD_NO_GOD)</a>
<a name="ln4937">    {</a>
<a name="ln4938">        gstr &lt;&lt; &quot; of &quot;</a>
<a name="ln4939">             &lt;&lt; god_name(mi.i_ghost.religion);</a>
<a name="ln4940">    }</a>
<a name="ln4941"> </a>
<a name="ln4942">    return gstr.str();</a>
<a name="ln4943">}</a>
<a name="ln4944"> </a>
<a name="ln4945">void describe_skill(skill_type skill)</a>
<a name="ln4946">{</a>
<a name="ln4947">    describe_info inf;</a>
<a name="ln4948">    inf.title = skill_name(skill);</a>
<a name="ln4949">    inf.body &lt;&lt; get_skill_description(skill, false);</a>
<a name="ln4950">#ifdef USE_TILE</a>
<a name="ln4951">    tile_def tile = tile_def(tileidx_skill(skill, TRAINING_ENABLED), TEX_GUI);</a>
<a name="ln4952">    show_description(inf, &amp;tile);</a>
<a name="ln4953">#else</a>
<a name="ln4954">    show_description(inf);</a>
<a name="ln4955">#endif</a>
<a name="ln4956">}</a>
<a name="ln4957"> </a>
<a name="ln4958">// only used in tiles</a>
<a name="ln4959">string get_command_description(const command_type cmd, bool terse)</a>
<a name="ln4960">{</a>
<a name="ln4961">    string lookup = command_to_name(cmd);</a>
<a name="ln4962"> </a>
<a name="ln4963">    if (!terse)</a>
<a name="ln4964">        lookup += &quot; verbose&quot;;</a>
<a name="ln4965"> </a>
<a name="ln4966">    string result = getLongDescription(lookup);</a>
<a name="ln4967">    if (result.empty())</a>
<a name="ln4968">    {</a>
<a name="ln4969">        if (!terse)</a>
<a name="ln4970">        {</a>
<a name="ln4971">            // Try for the terse description.</a>
<a name="ln4972">            result = get_command_description(cmd, true);</a>
<a name="ln4973">            if (!result.empty())</a>
<a name="ln4974">                return result + &quot;.&quot;;</a>
<a name="ln4975">        }</a>
<a name="ln4976">        return command_to_name(cmd);</a>
<a name="ln4977">    }</a>
<a name="ln4978"> </a>
<a name="ln4979">    return result.substr(0, result.length() - 1);</a>
<a name="ln4980">}</a>
<a name="ln4981"> </a>
<a name="ln4982">/**</a>
<a name="ln4983"> * Provide auto-generated information about the given cloud type. Describe</a>
<a name="ln4984"> * opacity &amp; related factors.</a>
<a name="ln4985"> *</a>
<a name="ln4986"> * @param cloud_type        The cloud_type in question.</a>
<a name="ln4987"> * @return e.g. &quot;\nThis cloud is opaque; one tile will not block vision, but</a>
<a name="ln4988"> *      multiple will. \nClouds of this kind the player makes will vanish very</a>
<a name="ln4989"> *      quickly once outside the player's sight.&quot;</a>
<a name="ln4990"> */</a>
<a name="ln4991">string extra_cloud_info(cloud_type cloud_type)</a>
<a name="ln4992">{</a>
<a name="ln4993">    const bool opaque = is_opaque_cloud(cloud_type);</a>
<a name="ln4994">    const string opacity_info = !opaque ? &quot;&quot; :</a>
<a name="ln4995">        &quot;\nThis cloud is opaque; one tile will not block vision, but &quot;</a>
<a name="ln4996">        &quot;multiple will.&quot;;</a>
<a name="ln4997">    const string vanish_info</a>
<a name="ln4998">        = make_stringf(&quot;\nClouds of this kind an adventurer makes will vanish &quot;</a>
<a name="ln4999">                       &quot;%s once outside their sight.&quot;,</a>
<a name="ln5000">                       opaque ? &quot;quickly&quot; : &quot;almost instantly&quot;);</a>
<a name="ln5001">    return opacity_info + vanish_info;</a>
<a name="ln5002">}</a>

</code></pre>
<div class="balloon" rel="658"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v1016/" target="_blank">V1016</a> Expression 'trap >= 0' is always true.</p></div>
<div class="balloon" rel="3236"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v648/" target="_blank">V648</a> Priority of the '&&' operation is higher than that of the '||' operation.</p></div>

<link rel="stylesheet" href="highlight.css">
<script src="highlight.pack.js"></script>
<script src="highlightjs-line-numbers.js"></script>
<script>hljs.initHighlightingOnLoad();</script>
<script>hljs.initLineNumbersOnLoad();</script>
<script>
  $(document).ready(function() {
      $('.balloon').each(function () {
          var bl = $(this);
          var line = bl.attr('rel');
          var text = $('a[name="ln'+line+'"]').text();

          var space_count = 0;
          for(var i = 0; i<text.length; i++){
              var char = text[i];
              if((char !== ' ')&&(char !== '\t'))break;
              if(char === '\t')space_count++;
              space_count++;
          }

          bl.css('margin-left', space_count*8);
          $('a[name="ln'+line+'"]').after(bl);
      });

      window.location = window.location;
  });
</script>
</body>
</html>
