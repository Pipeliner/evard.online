
<html>
<head>

  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
  <title>monster.cc</title>

  <link rel="stylesheet" href="../style.css"/>
  <script src="../jquery-3.2.1.min.js"></script>
</head>
<body>

<pre><code class = "cpp">
<a name="ln1">/**</a>
<a name="ln2"> * @file</a>
<a name="ln3"> * @brief Monsters class methods</a>
<a name="ln4">**/</a>
<a name="ln5"> </a>
<a name="ln6">#include &quot;AppHdr.h&quot;</a>
<a name="ln7"> </a>
<a name="ln8">#include &lt;algorithm&gt;</a>
<a name="ln9">#include &lt;functional&gt;</a>
<a name="ln10">#include &lt;queue&gt;</a>
<a name="ln11"> </a>
<a name="ln12">#include &quot;act-iter.h&quot;</a>
<a name="ln13">#include &quot;areas.h&quot;</a>
<a name="ln14">#include &quot;artefact.h&quot;</a>
<a name="ln15">#include &quot;art-enum.h&quot;</a>
<a name="ln16">#include &quot;attack.h&quot;</a>
<a name="ln17">#include &quot;attitude-change.h&quot;</a>
<a name="ln18">#include &quot;bloodspatter.h&quot;</a>
<a name="ln19">#include &quot;branch.h&quot;</a>
<a name="ln20">#include &quot;cloud.h&quot;</a>
<a name="ln21">#include &quot;colour.h&quot;</a>
<a name="ln22">#include &quot;coordit.h&quot;</a>
<a name="ln23">#include &quot;database.h&quot;</a>
<a name="ln24">#include &quot;dgn-event.h&quot;</a>
<a name="ln25">#include &quot;dgn-overview.h&quot;</a>
<a name="ln26">#include &quot;directn.h&quot;</a>
<a name="ln27">#include &quot;english.h&quot;</a>
<a name="ln28">#include &quot;env.h&quot;</a>
<a name="ln29">#include &quot;fight.h&quot;</a>
<a name="ln30">#include &quot;fineff.h&quot;</a>
<a name="ln31">#include &quot;fprop.h&quot;</a>
<a name="ln32">#include &quot;ghost.h&quot;</a>
<a name="ln33">#include &quot;god-abil.h&quot;</a>
<a name="ln34">#include &quot;god-conduct.h&quot;</a>
<a name="ln35">#include &quot;god-item.h&quot;</a>
<a name="ln36">#include &quot;item-name.h&quot;</a>
<a name="ln37">#include &quot;item-prop.h&quot;</a>
<a name="ln38">#include &quot;item-status-flag-type.h&quot;</a>
<a name="ln39">#include &quot;items.h&quot;</a>
<a name="ln40">#include &quot;libutil.h&quot;</a>
<a name="ln41">#include &quot;makeitem.h&quot;</a>
<a name="ln42">#include &quot;message.h&quot;</a>
<a name="ln43">#include &quot;misc.h&quot;</a>
<a name="ln44">#include &quot;mon-abil.h&quot;</a>
<a name="ln45">#include &quot;mon-act.h&quot;</a>
<a name="ln46">#include &quot;mon-behv.h&quot;</a>
<a name="ln47">#include &quot;mon-book.h&quot;</a>
<a name="ln48">#include &quot;mon-cast.h&quot;</a>
<a name="ln49">#include &quot;mon-clone.h&quot;</a>
<a name="ln50">#include &quot;mon-death.h&quot;</a>
<a name="ln51">#include &quot;mon-place.h&quot;</a>
<a name="ln52">#include &quot;mon-poly.h&quot;</a>
<a name="ln53">#include &quot;mon-tentacle.h&quot;</a>
<a name="ln54">#include &quot;mon-transit.h&quot;</a>
<a name="ln55">#include &quot;religion.h&quot;</a>
<a name="ln56">#include &quot;rot.h&quot;</a>
<a name="ln57">#include &quot;spl-monench.h&quot;</a>
<a name="ln58">#include &quot;spl-summoning.h&quot;</a>
<a name="ln59">#include &quot;spl-util.h&quot;</a>
<a name="ln60">#include &quot;state.h&quot;</a>
<a name="ln61">#include &quot;stringutil.h&quot;</a>
<a name="ln62">#include &quot;teleport.h&quot;</a>
<a name="ln63">#include &quot;terrain.h&quot;</a>
<a name="ln64">#ifdef USE_TILE</a>
<a name="ln65">#include &quot;tilepick.h&quot;</a>
<a name="ln66">#include &quot;tileview.h&quot;</a>
<a name="ln67">#endif</a>
<a name="ln68">#include &quot;traps.h&quot;</a>
<a name="ln69">#include &quot;view.h&quot;</a>
<a name="ln70">#include &quot;xom.h&quot;</a>
<a name="ln71"> </a>
<a name="ln72">monster::monster()</a>
<a name="ln73">    : hit_points(0), max_hit_points(0),</a>
<a name="ln74">      speed(0), speed_increment(0), target(), firing_pos(),</a>
<a name="ln75">      patrol_point(), travel_target(MTRAV_NONE), inv(NON_ITEM), spells(),</a>
<a name="ln76">      attitude(ATT_HOSTILE), behaviour(BEH_WANDER), foe(MHITYOU),</a>
<a name="ln77">      enchantments(), flags(), xp_tracking(XP_NON_VAULT), experience(0),</a>
<a name="ln78">      base_monster(MONS_NO_MONSTER), number(0), colour(COLOUR_INHERIT),</a>
<a name="ln79">      foe_memory(0), god(GOD_NO_GOD), ghost(), seen_context(SC_NONE),</a>
<a name="ln80">      client_id(0), hit_dice(0)</a>
<a name="ln81"> </a>
<a name="ln82">{</a>
<a name="ln83">    type = MONS_NO_MONSTER;</a>
<a name="ln84">    travel_path.clear();</a>
<a name="ln85">    props.clear();</a>
<a name="ln86">    if (crawl_state.game_is_arena())</a>
<a name="ln87">        foe = MHITNOT;</a>
<a name="ln88">    shield_blocks = 0;</a>
<a name="ln89"> </a>
<a name="ln90">    constricting = 0;</a>
<a name="ln91"> </a>
<a name="ln92">    clear_constricted();</a>
<a name="ln93">    went_unseen_this_turn = false;</a>
<a name="ln94">    unseen_pos = coord_def(0, 0);</a>
<a name="ln95">}</a>
<a name="ln96"> </a>
<a name="ln97">// Empty destructor to keep unique_ptr happy with incomplete ghost_demon type.</a>
<a name="ln98">monster::~monster()</a>
<a name="ln99">{</a>
<a name="ln100">}</a>
<a name="ln101"> </a>
<a name="ln102">monster::monster(const monster&amp; mon)</a>
<a name="ln103">{</a>
<a name="ln104">    constricting = 0;</a>
<a name="ln105">    init_with(mon);</a>
<a name="ln106">}</a>
<a name="ln107"> </a>
<a name="ln108">monster &amp;monster::operator = (const monster&amp; mon)</a>
<a name="ln109">{</a>
<a name="ln110">    if (this != &amp;mon)</a>
<a name="ln111">        init_with(mon);</a>
<a name="ln112">    return *this;</a>
<a name="ln113">}</a>
<a name="ln114"> </a>
<a name="ln115">void monster::reset()</a>
<a name="ln116">{</a>
<a name="ln117">    mname.clear();</a>
<a name="ln118">    enchantments.clear();</a>
<a name="ln119">    ench_cache.reset();</a>
<a name="ln120">    ench_countdown = 0;</a>
<a name="ln121">    inv.init(NON_ITEM);</a>
<a name="ln122">    spells.clear();</a>
<a name="ln123"> </a>
<a name="ln124">    mid             = 0;</a>
<a name="ln125">    flags           = MF_NO_FLAGS;</a>
<a name="ln126">    experience      = 0;</a>
<a name="ln127">    type            = MONS_NO_MONSTER;</a>
<a name="ln128">    base_monster    = MONS_NO_MONSTER;</a>
<a name="ln129">    hit_points      = 0;</a>
<a name="ln130">    max_hit_points  = 0;</a>
<a name="ln131">    hit_dice        = 0;</a>
<a name="ln132">    speed_increment = 0;</a>
<a name="ln133">    attitude        = ATT_HOSTILE;</a>
<a name="ln134">    behaviour       = BEH_SLEEP;</a>
<a name="ln135">    foe             = MHITNOT;</a>
<a name="ln136">    summoner        = 0;</a>
<a name="ln137">    number          = 0;</a>
<a name="ln138">    damage_friendly = 0;</a>
<a name="ln139">    damage_total    = 0;</a>
<a name="ln140">    shield_blocks   = 0;</a>
<a name="ln141">    foe_memory      = 0;</a>
<a name="ln142">    god             = GOD_NO_GOD;</a>
<a name="ln143">    went_unseen_this_turn = false;</a>
<a name="ln144">    unseen_pos = coord_def(0, 0);</a>
<a name="ln145"> </a>
<a name="ln146">    mons_remove_from_grid(*this);</a>
<a name="ln147">    target.reset();</a>
<a name="ln148">    position.reset();</a>
<a name="ln149">    firing_pos.reset();</a>
<a name="ln150">    patrol_point.reset();</a>
<a name="ln151">    travel_target = MTRAV_NONE;</a>
<a name="ln152">    travel_path.clear();</a>
<a name="ln153">    ghost.reset(nullptr);</a>
<a name="ln154">    seen_context = SC_NONE;</a>
<a name="ln155">    props.clear();</a>
<a name="ln156">    clear_constricted();</a>
<a name="ln157">    // no actual in-game monster should be reset while still constricting</a>
<a name="ln158">    ASSERT(!constricting);</a>
<a name="ln159"> </a>
<a name="ln160">    client_id = 0;</a>
<a name="ln161"> </a>
<a name="ln162">    // Just for completeness.</a>
<a name="ln163">    speed           = 0;</a>
<a name="ln164">    colour         = COLOUR_INHERIT;</a>
<a name="ln165">}</a>
<a name="ln166"> </a>
<a name="ln167">void monster::init_with(const monster&amp; mon)</a>
<a name="ln168">{</a>
<a name="ln169">    reset();</a>
<a name="ln170"> </a>
<a name="ln171">    mid               = mon.mid;</a>
<a name="ln172">    mname             = mon.mname;</a>
<a name="ln173">    type              = mon.type;</a>
<a name="ln174">    base_monster      = mon.base_monster;</a>
<a name="ln175">    hit_points        = mon.hit_points;</a>
<a name="ln176">    max_hit_points    = mon.max_hit_points;</a>
<a name="ln177">    hit_dice          = mon.hit_dice;</a>
<a name="ln178">    speed             = mon.speed;</a>
<a name="ln179">    speed_increment   = mon.speed_increment;</a>
<a name="ln180">    position          = mon.position;</a>
<a name="ln181">    target            = mon.target;</a>
<a name="ln182">    firing_pos        = mon.firing_pos;</a>
<a name="ln183">    patrol_point      = mon.patrol_point;</a>
<a name="ln184">    travel_target     = mon.travel_target;</a>
<a name="ln185">    travel_path       = mon.travel_path;</a>
<a name="ln186">    inv               = mon.inv;</a>
<a name="ln187">    spells            = mon.spells;</a>
<a name="ln188">    attitude          = mon.attitude;</a>
<a name="ln189">    behaviour         = mon.behaviour;</a>
<a name="ln190">    foe               = mon.foe;</a>
<a name="ln191">    enchantments      = mon.enchantments;</a>
<a name="ln192">    ench_cache        = mon.ench_cache;</a>
<a name="ln193">    flags             = mon.flags;</a>
<a name="ln194">    experience        = mon.experience;</a>
<a name="ln195">    number            = mon.number;</a>
<a name="ln196">    colour            = mon.colour;</a>
<a name="ln197">    summoner          = mon.summoner;</a>
<a name="ln198">    foe_memory        = mon.foe_memory;</a>
<a name="ln199">    god               = mon.god;</a>
<a name="ln200">    props             = mon.props;</a>
<a name="ln201">    damage_friendly   = mon.damage_friendly;</a>
<a name="ln202">    damage_total      = mon.damage_total;</a>
<a name="ln203">    xp_tracking       = mon.xp_tracking;</a>
<a name="ln204"> </a>
<a name="ln205">    if (mon.ghost)</a>
<a name="ln206">        ghost.reset(new ghost_demon(*mon.ghost));</a>
<a name="ln207">    else</a>
<a name="ln208">        ghost.reset(nullptr);</a>
<a name="ln209">}</a>
<a name="ln210"> </a>
<a name="ln211">uint32_t monster::last_client_id = 0;</a>
<a name="ln212"> </a>
<a name="ln213">uint32_t monster::get_client_id() const</a>
<a name="ln214">{</a>
<a name="ln215">    return client_id;</a>
<a name="ln216">}</a>
<a name="ln217"> </a>
<a name="ln218">void monster::reset_client_id()</a>
<a name="ln219">{</a>
<a name="ln220">    client_id = 0;</a>
<a name="ln221">}</a>
<a name="ln222"> </a>
<a name="ln223">void monster::ensure_has_client_id()</a>
<a name="ln224">{</a>
<a name="ln225">    if (client_id == 0)</a>
<a name="ln226">        client_id = ++last_client_id;</a>
<a name="ln227">}</a>
<a name="ln228"> </a>
<a name="ln229">mon_attitude_type monster::temp_attitude() const</a>
<a name="ln230">{</a>
<a name="ln231">    if (has_ench(ENCH_INSANE))</a>
<a name="ln232">        return ATT_NEUTRAL;</a>
<a name="ln233"> </a>
<a name="ln234">    if (has_ench(ENCH_HEXED))</a>
<a name="ln235">    {</a>
<a name="ln236">        actor *agent = monster_by_mid(get_ench(ENCH_HEXED).source);</a>
<a name="ln237">        if (agent)</a>
<a name="ln238">        {</a>
<a name="ln239">            ASSERT(agent-&gt;is_monster());</a>
<a name="ln240">            return agent-&gt;as_monster()-&gt;attitude;</a>
<a name="ln241">        }</a>
<a name="ln242">        return ATT_HOSTILE; // ???</a>
<a name="ln243">    }</a>
<a name="ln244">    if (has_ench(ENCH_CHARM) || has_ench(ENCH_FRIENDLY_BRIBED))</a>
<a name="ln245">        return ATT_FRIENDLY;</a>
<a name="ln246">    else if (has_ench(ENCH_NEUTRAL_BRIBED))</a>
<a name="ln247">        return ATT_GOOD_NEUTRAL; // ???</a>
<a name="ln248">    else</a>
<a name="ln249">        return attitude;</a>
<a name="ln250">}</a>
<a name="ln251"> </a>
<a name="ln252">bool monster::swimming() const</a>
<a name="ln253">{</a>
<a name="ln254">    const dungeon_feature_type grid = grd(pos());</a>
<a name="ln255">    return feat_is_watery(grid) &amp;&amp; mons_primary_habitat(*this) == HT_WATER;</a>
<a name="ln256">}</a>
<a name="ln257"> </a>
<a name="ln258">bool monster::submerged() const</a>
<a name="ln259">{</a>
<a name="ln260">    // FIXME, switch to 4.1's MF_SUBMERGED system which is much cleaner.</a>
<a name="ln261">    // Can't find any reference to MF_SUBMERGED anywhere. Don't know what</a>
<a name="ln262">    // this means. - abrahamwl</a>
<a name="ln263">    return has_ench(ENCH_SUBMERGED);</a>
<a name="ln264">}</a>
<a name="ln265"> </a>
<a name="ln266">bool monster::extra_balanced_at(const coord_def p) const</a>
<a name="ln267">{</a>
<a name="ln268">    const dungeon_feature_type grid = grd(p);</a>
<a name="ln269">    return (mons_genus(type) == MONS_DRACONIAN</a>
<a name="ln270">            &amp;&amp; draco_or_demonspawn_subspecies(*this) == MONS_GREY_DRACONIAN)</a>
<a name="ln271">                || grid == DNGN_SHALLOW_WATER</a>
<a name="ln272">                   &amp;&amp; (mons_genus(type) == MONS_NAGA // tails, not feet</a>
<a name="ln273">                       || mons_genus(type) == MONS_SALAMANDER</a>
<a name="ln274">                       || body_size(PSIZE_BODY) &gt;= SIZE_LARGE);</a>
<a name="ln275">}</a>
<a name="ln276"> </a>
<a name="ln277">bool monster::extra_balanced() const</a>
<a name="ln278">{</a>
<a name="ln279">    return extra_balanced_at(pos());</a>
<a name="ln280">}</a>
<a name="ln281"> </a>
<a name="ln282">/**</a>
<a name="ln283"> * Monster floundering conditions.</a>
<a name="ln284"> *</a>
<a name="ln285"> * Floundering reduces movement speed and can cause the monster to fumble</a>
<a name="ln286"> * its attacks. It can be caused by water or by Leda's liquefaction.</a>
<a name="ln287"> *</a>
<a name="ln288"> * @param p Coordinates of position to check.</a>
<a name="ln289"> * @return Whether the monster would be floundering at p.</a>
<a name="ln290"> */</a>
<a name="ln291">bool monster::floundering_at(const coord_def p) const</a>
<a name="ln292">{</a>
<a name="ln293">    const dungeon_feature_type grid = grd(p);</a>
<a name="ln294">    return (liquefied(p)</a>
<a name="ln295">            || (feat_is_water(grid)</a>
<a name="ln296">                // Can't use monster_habitable_grid() because that'll return</a>
<a name="ln297">                // true for non-water monsters in shallow water.</a>
<a name="ln298">                &amp;&amp; mons_primary_habitat(*this) != HT_WATER</a>
<a name="ln299">                // Use real_amphibious to detect giant non-water monsters in</a>
<a name="ln300">                // deep water, who flounder despite being treated as amphibious.</a>
<a name="ln301">                &amp;&amp; mons_habitat(*this, true) != HT_AMPHIBIOUS</a>
<a name="ln302">                &amp;&amp; !extra_balanced_at(p)))</a>
<a name="ln303">           &amp;&amp; ground_level();</a>
<a name="ln304">}</a>
<a name="ln305"> </a>
<a name="ln306">bool monster::floundering() const</a>
<a name="ln307">{</a>
<a name="ln308">    return floundering_at(pos());</a>
<a name="ln309">}</a>
<a name="ln310"> </a>
<a name="ln311">bool monster::can_pass_through_feat(dungeon_feature_type grid) const</a>
<a name="ln312">{</a>
<a name="ln313">    return mons_class_can_pass(mons_base_type(*this), grid);</a>
<a name="ln314">}</a>
<a name="ln315"> </a>
<a name="ln316">bool monster::is_habitable_feat(dungeon_feature_type actual_grid) const</a>
<a name="ln317">{</a>
<a name="ln318">    return monster_habitable_grid(this, actual_grid);</a>
<a name="ln319">}</a>
<a name="ln320"> </a>
<a name="ln321">bool monster::can_drown() const</a>
<a name="ln322">{</a>
<a name="ln323">    // Presumably a electric eel in lava or a lavafish in deep water could</a>
<a name="ln324">    // drown, but that should never happen, so this simple check should</a>
<a name="ln325">    // be enough.</a>
<a name="ln326">    switch (mons_primary_habitat(*this))</a>
<a name="ln327">    {</a>
<a name="ln328">    case HT_WATER:</a>
<a name="ln329">    case HT_LAVA:</a>
<a name="ln330">    case HT_AMPHIBIOUS:</a>
<a name="ln331">        return false;</a>
<a name="ln332">    default:</a>
<a name="ln333">        break;</a>
<a name="ln334">    }</a>
<a name="ln335"> </a>
<a name="ln336">    return !is_unbreathing();</a>
<a name="ln337">}</a>
<a name="ln338"> </a>
<a name="ln339">size_type monster::body_size(size_part_type /* psize */, bool /* base */) const</a>
<a name="ln340">{</a>
<a name="ln341">    monster_info mi(this, MILEV_NAME);</a>
<a name="ln342">    return mi.body_size();</a>
<a name="ln343">}</a>
<a name="ln344"> </a>
<a name="ln345">/**</a>
<a name="ln346"> * Returns brand information from an associated ghost_demon, if any.</a>
<a name="ln347"> * Used for player ghosts, illusions, and pan lords. Safe to call if `ghost`</a>
<a name="ln348"> * is not set; will just return SPWPN_NORMAL for this case.</a>
<a name="ln349"> */</a>
<a name="ln350">brand_type monster::ghost_brand() const</a>
<a name="ln351">{</a>
<a name="ln352">    if (!ghost || !(type == MONS_PANDEMONIUM_LORD || mons_is_pghost(type)))</a>
<a name="ln353">        return SPWPN_NORMAL;</a>
<a name="ln354">    return ghost-&gt;brand;</a>
<a name="ln355">}</a>
<a name="ln356"> </a>
<a name="ln357">/**</a>
<a name="ln358"> * Is there a ghost_demon associated with this monster that has a brand set?</a>
<a name="ln359"> * Used for player ghosts, illusions, and pan lords. Safe to call if `ghost`</a>
<a name="ln360"> * is not set.</a>
<a name="ln361"> */</a>
<a name="ln362">bool monster::has_ghost_brand() const</a>
<a name="ln363">{</a>
<a name="ln364">    return ghost_brand() != SPWPN_NORMAL;</a>
<a name="ln365">}</a>
<a name="ln366"> </a>
<a name="ln367">brand_type monster::damage_brand(int which_attack)</a>
<a name="ln368">{</a>
<a name="ln369">    const item_def *mweap = weapon(which_attack);</a>
<a name="ln370"> </a>
<a name="ln371">    if (!mweap)</a>
<a name="ln372">        return ghost_brand();</a>
<a name="ln373"> </a>
<a name="ln374">    return !is_range_weapon(*mweap) ? static_cast&lt;brand_type&gt;(get_weapon_brand(*mweap))</a>
<a name="ln375">                                    : SPWPN_NORMAL;</a>
<a name="ln376">}</a>
<a name="ln377"> </a>
<a name="ln378">int monster::damage_type(int which_attack)</a>
<a name="ln379">{</a>
<a name="ln380">    const item_def *mweap = weapon(which_attack);</a>
<a name="ln381"> </a>
<a name="ln382">    if (!mweap)</a>
<a name="ln383">    {</a>
<a name="ln384">        const mon_attack_def atk = mons_attack_spec(*this, which_attack);</a>
<a name="ln385">        return (atk.type == AT_CLAW)          ? DVORP_CLAWING :</a>
<a name="ln386">               (atk.type == AT_TENTACLE_SLAP) ? DVORP_TENTACLE</a>
<a name="ln387">                                              : DVORP_CRUSHING;</a>
<a name="ln388">    }</a>
<a name="ln389"> </a>
<a name="ln390">    return get_vorpal_type(*mweap);</a>
<a name="ln391">}</a>
<a name="ln392"> </a>
<a name="ln393">/**</a>
<a name="ln394"> * Return the delay caused by attacking with weapon and projectile.</a>
<a name="ln395"> *</a>
<a name="ln396"> * @param projectile    The projectile to be fired/thrown, if any.</a>
<a name="ln397"> * @return              The time taken by an attack with the monster's weapon</a>
<a name="ln398"> *                      and the given projectile, in aut.</a>
<a name="ln399"> */</a>
<a name="ln400">random_var monster::attack_delay(const item_def *projectile,</a>
<a name="ln401">                                 bool /*rescale*/) const</a>
<a name="ln402">{</a>
<a name="ln403">    const item_def* weap = weapon();</a>
<a name="ln404"> </a>
<a name="ln405">    const bool use_unarmed =</a>
<a name="ln406">        (projectile) ? is_launched(this, weap, *projectile) != launch_retval::LAUNCHED</a>
<a name="ln407">                     : !weap;</a>
<a name="ln408"> </a>
<a name="ln409">    if (use_unarmed || !weap)</a>
<a name="ln410">        return random_var(10);</a>
<a name="ln411"> </a>
<a name="ln412">    random_var delay(property(*weap, PWPN_SPEED));</a>
<a name="ln413">    if (get_weapon_brand(*weap) == SPWPN_SPEED)</a>
<a name="ln414">        delay = div_rand_round(delay * 2, 3);</a>
<a name="ln415">    return (random_var(10) + delay) / 2;</a>
<a name="ln416">}</a>
<a name="ln417"> </a>
<a name="ln418">int monster::has_claws(bool /*allow_tran*/) const</a>
<a name="ln419">{</a>
<a name="ln420">    for (int i = 0; i &lt; MAX_NUM_ATTACKS; i++)</a>
<a name="ln421">    {</a>
<a name="ln422">        const mon_attack_def atk = mons_attack_spec(*this, i);</a>
<a name="ln423">        if (atk.type == AT_CLAW)</a>
<a name="ln424">        {</a>
<a name="ln425">            // Some better criteria would be better.</a>
<a name="ln426">            if (body_size() &lt; SIZE_LARGE || atk.damage &lt; 15)</a>
<a name="ln427">                return 1;</a>
<a name="ln428">            return 3;</a>
<a name="ln429">        }</a>
<a name="ln430">    }</a>
<a name="ln431"> </a>
<a name="ln432">    return 0;</a>
<a name="ln433">}</a>
<a name="ln434"> </a>
<a name="ln435">item_def *monster::missiles() const</a>
<a name="ln436">{</a>
<a name="ln437">    return inv[MSLOT_MISSILE] != NON_ITEM ? &amp;mitm[inv[MSLOT_MISSILE]] : nullptr;</a>
<a name="ln438">}</a>
<a name="ln439"> </a>
<a name="ln440">item_def *monster::launcher() const</a>
<a name="ln441">{</a>
<a name="ln442">    item_def *weap = mslot_item(MSLOT_WEAPON);</a>
<a name="ln443">    if (weap &amp;&amp; is_range_weapon(*weap))</a>
<a name="ln444">        return weap;</a>
<a name="ln445"> </a>
<a name="ln446">    weap = mslot_item(MSLOT_ALT_WEAPON);</a>
<a name="ln447">    return weap &amp;&amp; is_range_weapon(*weap) ? weap : nullptr;</a>
<a name="ln448">}</a>
<a name="ln449"> </a>
<a name="ln450">// Does not check whether the monster can dual-wield - that is the</a>
<a name="ln451">// caller's responsibility.</a>
<a name="ln452">static int _mons_offhand_weapon_index(const monster* m)</a>
<a name="ln453">{</a>
<a name="ln454">    return m-&gt;inv[MSLOT_ALT_WEAPON];</a>
<a name="ln455">}</a>
<a name="ln456"> </a>
<a name="ln457">item_def *monster::weapon(int which_attack) const</a>
<a name="ln458">{</a>
<a name="ln459">    const mon_attack_def attk = mons_attack_spec(*this, which_attack);</a>
<a name="ln460">    if (attk.type != AT_HIT &amp;&amp; attk.type != AT_WEAP_ONLY)</a>
<a name="ln461">        return nullptr;</a>
<a name="ln462"> </a>
<a name="ln463">    // Even/odd attacks use main/offhand weapon.</a>
<a name="ln464">    if (which_attack &gt; 1)</a>
<a name="ln465">        which_attack &amp;= 1;</a>
<a name="ln466"> </a>
<a name="ln467">    // This randomly picks one of the wielded weapons for monsters that can use</a>
<a name="ln468">    // two weapons. Not ideal, but better than nothing. fight.cc does it right,</a>
<a name="ln469">    // for various values of right.</a>
<a name="ln470">    int weap = inv[MSLOT_WEAPON];</a>
<a name="ln471"> </a>
<a name="ln472">    if (which_attack &amp;&amp; mons_wields_two_weapons(*this))</a>
<a name="ln473">    {</a>
<a name="ln474">        const int offhand = _mons_offhand_weapon_index(this);</a>
<a name="ln475">        if (offhand != NON_ITEM</a>
<a name="ln476">            &amp;&amp; (weap == NON_ITEM || which_attack == 1 || coinflip()))</a>
<a name="ln477">        {</a>
<a name="ln478">            weap = offhand;</a>
<a name="ln479">        }</a>
<a name="ln480">    }</a>
<a name="ln481"> </a>
<a name="ln482">    return weap == NON_ITEM ? nullptr : &amp;mitm[weap];</a>
<a name="ln483">}</a>
<a name="ln484"> </a>
<a name="ln485">/**</a>
<a name="ln486"> * Find a monster's melee weapon, if any.</a>
<a name="ln487"> *</a>
<a name="ln488"> * Finds melee weapons carried in the primary or aux slot; if the monster has</a>
<a name="ln489"> * both (dual-wielding), choose one with a coinflip.</a>
<a name="ln490"> *</a>
<a name="ln491"> * @return A melee weapon that the monster is holding, or null.</a>
<a name="ln492"> */</a>
<a name="ln493">item_def *monster::melee_weapon() const</a>
<a name="ln494">{</a>
<a name="ln495">    item_def* first_weapon = mslot_item(MSLOT_WEAPON);</a>
<a name="ln496">    item_def* second_weapon = mslot_item(MSLOT_ALT_WEAPON);</a>
<a name="ln497">    const bool primary_is_melee = first_weapon</a>
<a name="ln498">                                  &amp;&amp; is_melee_weapon(*first_weapon);</a>
<a name="ln499">    const bool secondary_is_melee = second_weapon</a>
<a name="ln500">                                    &amp;&amp; is_melee_weapon(*second_weapon);</a>
<a name="ln501">    if (primary_is_melee &amp;&amp; secondary_is_melee)</a>
<a name="ln502">        return random_choose(first_weapon, second_weapon);</a>
<a name="ln503">    if (primary_is_melee)</a>
<a name="ln504">        return first_weapon;</a>
<a name="ln505">    if (secondary_is_melee)</a>
<a name="ln506">        return second_weapon;</a>
<a name="ln507">    return nullptr;</a>
<a name="ln508">}</a>
<a name="ln509"> </a>
<a name="ln510">// Give hands required to wield weapon.</a>
<a name="ln511">hands_reqd_type monster::hands_reqd(const item_def &amp;item, bool base) const</a>
<a name="ln512">{</a>
<a name="ln513">    if (mons_genus(type) == MONS_FORMICID)</a>
<a name="ln514">        return HANDS_ONE;</a>
<a name="ln515">    return actor::hands_reqd(item, base);</a>
<a name="ln516">}</a>
<a name="ln517"> </a>
<a name="ln518">bool monster::can_wield(const item_def&amp; item, bool ignore_curse,</a>
<a name="ln519">                         bool ignore_brand, bool ignore_shield,</a>
<a name="ln520">                         bool ignore_transform) const</a>
<a name="ln521">{</a>
<a name="ln522">    // Monsters can only wield weapons or go unarmed (OBJ_UNASSIGNED</a>
<a name="ln523">    // means unarmed).</a>
<a name="ln524">    if (item.base_type != OBJ_WEAPONS &amp;&amp; item.base_type != OBJ_UNASSIGNED)</a>
<a name="ln525">        return false;</a>
<a name="ln526"> </a>
<a name="ln527">    // These *are* weapons, so they can't wield another weapon or</a>
<a name="ln528">    // unwield themselves.</a>
<a name="ln529">    if (mons_class_is_animated_weapon(type))</a>
<a name="ln530">        return false;</a>
<a name="ln531"> </a>
<a name="ln532">    // MF_HARD_RESET means that all items the monster is carrying will</a>
<a name="ln533">    // disappear when it does, so it can't accept new items or give up</a>
<a name="ln534">    // the ones it has.</a>
<a name="ln535">    if (flags &amp; MF_HARD_RESET)</a>
<a name="ln536">        return false;</a>
<a name="ln537"> </a>
<a name="ln538">    // Summoned items can only be held by summoned monsters.</a>
<a name="ln539">    if ((item.flags &amp; ISFLAG_SUMMONED) &amp;&amp; !is_summoned())</a>
<a name="ln540">        return false;</a>
<a name="ln541"> </a>
<a name="ln542">    item_def* weap1 = nullptr;</a>
<a name="ln543">    if (inv[MSLOT_WEAPON] != NON_ITEM)</a>
<a name="ln544">        weap1 = &amp;mitm[inv[MSLOT_WEAPON]];</a>
<a name="ln545"> </a>
<a name="ln546">    int       avail_slots = 1;</a>
<a name="ln547">    item_def* weap2       = nullptr;</a>
<a name="ln548">    if (mons_wields_two_weapons(*this))</a>
<a name="ln549">    {</a>
<a name="ln550">        if (!weap1 || hands_reqd(*weap1) != HANDS_TWO)</a>
<a name="ln551">            avail_slots = 2;</a>
<a name="ln552"> </a>
<a name="ln553">        const int offhand = _mons_offhand_weapon_index(this);</a>
<a name="ln554">        if (offhand != NON_ITEM)</a>
<a name="ln555">            weap2 = &amp;mitm[offhand];</a>
<a name="ln556">    }</a>
<a name="ln557"> </a>
<a name="ln558">    // If we're already wielding it, then of course we can wield it.</a>
<a name="ln559">    if (&amp;item == weap1 || &amp;item == weap2)</a>
<a name="ln560">        return true;</a>
<a name="ln561"> </a>
<a name="ln562">    // Barehanded needs two hands.</a>
<a name="ln563">    const bool two_handed = item.base_type == OBJ_UNASSIGNED</a>
<a name="ln564">                            || hands_reqd(item) == HANDS_TWO;</a>
<a name="ln565"> </a>
<a name="ln566">    item_def* _shield = nullptr;</a>
<a name="ln567">    if (inv[MSLOT_SHIELD] != NON_ITEM)</a>
<a name="ln568">    {</a>
<a name="ln569">        ASSERT(!(weap1 &amp;&amp; weap2));</a>
<a name="ln570"> </a>
<a name="ln571">        if (two_handed &amp;&amp; !ignore_shield)</a>
<a name="ln572">            return false;</a>
<a name="ln573"> </a>
<a name="ln574">        _shield = &amp;mitm[inv[MSLOT_SHIELD]];</a>
<a name="ln575">    }</a>
<a name="ln576"> </a>
<a name="ln577">    if (!ignore_curse)</a>
<a name="ln578">    {</a>
<a name="ln579">        int num_cursed = 0;</a>
<a name="ln580">        if (weap1 &amp;&amp; weap1-&gt;cursed())</a>
<a name="ln581">            num_cursed++;</a>
<a name="ln582">        if (weap2 &amp;&amp; weap2-&gt;cursed())</a>
<a name="ln583">            num_cursed++;</a>
<a name="ln584">        if (_shield &amp;&amp; _shield-&gt;cursed())</a>
<a name="ln585">            num_cursed++;</a>
<a name="ln586"> </a>
<a name="ln587">        if (two_handed &amp;&amp; num_cursed &gt; 0 || num_cursed &gt;= avail_slots)</a>
<a name="ln588">            return false;</a>
<a name="ln589">    }</a>
<a name="ln590"> </a>
<a name="ln591">    return could_wield(item, ignore_brand, ignore_transform);</a>
<a name="ln592">}</a>
<a name="ln593"> </a>
<a name="ln594">/**</a>
<a name="ln595"> * Checks whether the monster could ever wield the given item, regardless of</a>
<a name="ln596"> * what they're currently wielding or any other state.</a>
<a name="ln597"> *</a>
<a name="ln598"> * @param item              The item to wield.</a>
<a name="ln599"> * @param ignore_brand      Whether to disregard the item's brand.</a>
<a name="ln600"> * @return                  Whether the monster could potentially wield the</a>
<a name="ln601"> *                          item.</a>
<a name="ln602"> */</a>
<a name="ln603">bool monster::could_wield(const item_def &amp;item, bool ignore_brand,</a>
<a name="ln604">                           bool /* ignore_transform */, bool /* quiet */) const</a>
<a name="ln605">{</a>
<a name="ln606">    ASSERT(item.defined());</a>
<a name="ln607"> </a>
<a name="ln608">    // These *are* weapons, so they can't wield another weapon.</a>
<a name="ln609">    if (mons_class_is_animated_weapon(type))</a>
<a name="ln610">        return false;</a>
<a name="ln611"> </a>
<a name="ln612">    // Monsters can't use unrandarts with special effects.</a>
<a name="ln613">    if (is_special_unrandom_artefact(item) &amp;&amp; !crawl_state.game_is_arena())</a>
<a name="ln614">        return false;</a>
<a name="ln615"> </a>
<a name="ln616">    // Wimpy monsters (e.g. kobolds, goblins) can't use halberds, etc.</a>
<a name="ln617">    if (is_weapon(item) &amp;&amp; !is_weapon_wieldable(item, body_size()))</a>
<a name="ln618">        return false;</a>
<a name="ln619"> </a>
<a name="ln620">    if (!ignore_brand)</a>
<a name="ln621">    {</a>
<a name="ln622">        // Undead and demonic monsters and monsters that are</a>
<a name="ln623">        // gifts/worshippers of Yredelemnul won't use holy weapons.</a>
<a name="ln624">        if ((undead_or_demonic() || god == GOD_YREDELEMNUL)</a>
<a name="ln625">            &amp;&amp; is_holy_item(item))</a>
<a name="ln626">        {</a>
<a name="ln627">            return false;</a>
<a name="ln628">        }</a>
<a name="ln629"> </a>
<a name="ln630">        // Holy monsters that aren't gifts/worshippers of chaotic gods</a>
<a name="ln631">        // and monsters that are gifts/worshippers of good gods won't</a>
<a name="ln632">        // use potentially evil weapons.</a>
<a name="ln633">        if (((is_holy() &amp;&amp; !is_chaotic_god(god))</a>
<a name="ln634">                || is_good_god(god))</a>
<a name="ln635">            &amp;&amp; is_potentially_evil_item(item))</a>
<a name="ln636">        {</a>
<a name="ln637">            return false;</a>
<a name="ln638">        }</a>
<a name="ln639"> </a>
<a name="ln640">        // Holy monsters and monsters that are gifts/worshippers of good</a>
<a name="ln641">        // gods won't use evil weapons.</a>
<a name="ln642">        if ((is_holy() || is_good_god(god)) &amp;&amp; is_evil_item(item))</a>
<a name="ln643">            return false;</a>
<a name="ln644"> </a>
<a name="ln645">        // Monsters that are gifts/worshippers of Zin won't use unclean</a>
<a name="ln646">        // weapons.</a>
<a name="ln647">        if (god == GOD_ZIN &amp;&amp; is_unclean_item(item))</a>
<a name="ln648">            return false;</a>
<a name="ln649"> </a>
<a name="ln650">        // Holy monsters that aren't gifts/worshippers of chaotic gods</a>
<a name="ln651">        // and monsters that are gifts/worshippers of good gods won't</a>
<a name="ln652">        // use chaotic weapons.</a>
<a name="ln653">        if (((is_holy() &amp;&amp; !is_chaotic_god(god)) || is_good_god(god))</a>
<a name="ln654">            &amp;&amp; is_chaotic_item(item))</a>
<a name="ln655">        {</a>
<a name="ln656">            return false;</a>
<a name="ln657">        }</a>
<a name="ln658">    }</a>
<a name="ln659"> </a>
<a name="ln660">    return true;</a>
<a name="ln661">}</a>
<a name="ln662"> </a>
<a name="ln663">bool monster::can_throw_large_rocks() const</a>
<a name="ln664">{</a>
<a name="ln665">    monster_type species = mons_species(false); // zombies can't</a>
<a name="ln666">    return species == MONS_STONE_GIANT</a>
<a name="ln667">           || species == MONS_CYCLOPS</a>
<a name="ln668">           || species == MONS_OGRE;</a>
<a name="ln669">}</a>
<a name="ln670"> </a>
<a name="ln671">bool monster::can_speak()</a>
<a name="ln672">{</a>
<a name="ln673">    if (has_ench(ENCH_MUTE))</a>
<a name="ln674">        return false;</a>
<a name="ln675"> </a>
<a name="ln676">    // Priest and wizard monsters can always speak.</a>
<a name="ln677">    if (is_priest() || is_actual_spellcaster())</a>
<a name="ln678">        return true;</a>
<a name="ln679"> </a>
<a name="ln680">    // Silent or non-sentient monsters can't use the original speech.</a>
<a name="ln681">    if (mons_intel(*this) &lt; I_HUMAN || !mons_can_shout(type))</a>
<a name="ln682">        return false;</a>
<a name="ln683"> </a>
<a name="ln684">    // Does it have the proper vocal equipment?</a>
<a name="ln685">    return mon_shape_is_humanoid(get_mon_shape(*this));</a>
<a name="ln686">}</a>
<a name="ln687"> </a>
<a name="ln688">bool monster::is_silenced() const</a>
<a name="ln689">{</a>
<a name="ln690">    return silenced(pos())</a>
<a name="ln691">            || has_ench(ENCH_MUTE)</a>
<a name="ln692">            || (has_ench(ENCH_WATER_HOLD)</a>
<a name="ln693">                || has_ench(ENCH_WATERLOGGED))</a>
<a name="ln694">               &amp;&amp; !res_water_drowning();</a>
<a name="ln695">}</a>
<a name="ln696"> </a>
<a name="ln697">bool monster::search_slots(function&lt;bool (const mon_spell_slot &amp;)&gt; func) const</a>
<a name="ln698">{</a>
<a name="ln699">    return any_of(begin(spells), end(spells), func);</a>
<a name="ln700">}</a>
<a name="ln701"> </a>
<a name="ln702">bool monster::search_spells(function&lt;bool (spell_type)&gt; func) const</a>
<a name="ln703">{</a>
<a name="ln704">    return search_slots([&amp;] (const mon_spell_slot &amp;s)</a>
<a name="ln705">                        { return func(s.spell); });</a>
<a name="ln706">}</a>
<a name="ln707"> </a>
<a name="ln708">bool monster::has_spell_of_type(spschool discipline) const</a>
<a name="ln709">{</a>
<a name="ln710">    return search_spells(bind(spell_typematch, placeholders::_1, discipline));</a>
<a name="ln711">}</a>
<a name="ln712"> </a>
<a name="ln713">void monster::bind_melee_flags()</a>
<a name="ln714">{</a>
<a name="ln715">    // Bind fighter / dual-wielder / archer flags from the base type.</a>
<a name="ln716"> </a>
<a name="ln717">    // Alas, we don't know if the mon is zombified at the moment, if it</a>
<a name="ln718">    // is, the flags (other than dual-wielder) will be removed later.</a>
<a name="ln719">    if (mons_class_flag(type, M_FIGHTER))</a>
<a name="ln720">        flags |= MF_FIGHTER;</a>
<a name="ln721">    if (mons_class_flag(type, M_TWO_WEAPONS))</a>
<a name="ln722">        flags |= MF_TWO_WEAPONS;</a>
<a name="ln723">    if (mons_class_flag(type, M_ARCHER))</a>
<a name="ln724">        flags |= MF_ARCHER;</a>
<a name="ln725">}</a>
<a name="ln726"> </a>
<a name="ln727">void monster::bind_spell_flags()</a>
<a name="ln728">{</a>
<a name="ln729">    if (!mons_is_ghost_demon(type) &amp;&amp; mons_has_ranged_spell(*this))</a>
<a name="ln730">        flags |= MF_SEEN_RANGED;</a>
<a name="ln731">}</a>
<a name="ln732"> </a>
<a name="ln733">static bool _needs_ranged_attack(const monster* mon)</a>
<a name="ln734">{</a>
<a name="ln735">    // Prevent monsters that have conjurations from grabbing missiles.</a>
<a name="ln736">    if (mon-&gt;has_spell_of_type(spschool::conjuration))</a>
<a name="ln737">        return false;</a>
<a name="ln738"> </a>
<a name="ln739">    // Same for summonings, but make an exception for friendlies.</a>
<a name="ln740">    if (!mon-&gt;friendly() &amp;&amp; mon-&gt;has_spell_of_type(spschool::summoning))</a>
<a name="ln741">        return false;</a>
<a name="ln742"> </a>
<a name="ln743">    // Blademasters don't want to throw stuff.</a>
<a name="ln744">    if (mon-&gt;type == MONS_DEEP_ELF_BLADEMASTER)</a>
<a name="ln745">        return false;</a>
<a name="ln746"> </a>
<a name="ln747">    return true;</a>
<a name="ln748">}</a>
<a name="ln749"> </a>
<a name="ln750">bool monster::can_use_missile(const item_def &amp;item) const</a>
<a name="ln751">{</a>
<a name="ln752">    // Don't allow monsters to pick up missiles without the corresponding</a>
<a name="ln753">    // launcher. The opposite is okay, and sufficient wandering will</a>
<a name="ln754">    // hopefully take the monster to a stack of appropriate missiles.</a>
<a name="ln755"> </a>
<a name="ln756">    if (!_needs_ranged_attack(this))</a>
<a name="ln757">        return false;</a>
<a name="ln758"> </a>
<a name="ln759">    if (item.base_type == OBJ_WEAPONS</a>
<a name="ln760">        || item.base_type == OBJ_MISSILES &amp;&amp; !has_launcher(item))</a>
<a name="ln761">    {</a>
<a name="ln762">        return is_throwable(this, item);</a>
<a name="ln763">    }</a>
<a name="ln764"> </a>
<a name="ln765">    if (item.base_type != OBJ_MISSILES)</a>
<a name="ln766">        return false;</a>
<a name="ln767"> </a>
<a name="ln768">    // Stones are allowed even without launcher.</a>
<a name="ln769">    if (item.sub_type == MI_STONE)</a>
<a name="ln770">        return true;</a>
<a name="ln771"> </a>
<a name="ln772">    item_def *launch;</a>
<a name="ln773">    for (int i = MSLOT_WEAPON; i &lt;= MSLOT_ALT_WEAPON; ++i)</a>
<a name="ln774">    {</a>
<a name="ln775">        launch = mslot_item(static_cast&lt;mon_inv_type&gt;(i));</a>
<a name="ln776">        if (launch &amp;&amp; item.launched_by(*launch))</a>
<a name="ln777">            return true;</a>
<a name="ln778">    }</a>
<a name="ln779"> </a>
<a name="ln780">    // No fitting launcher in inventory.</a>
<a name="ln781">    return false;</a>
<a name="ln782">}</a>
<a name="ln783"> </a>
<a name="ln784">/**</a>
<a name="ln785"> * Does this monster have any interest in using the given wand? (Will they</a>
<a name="ln786"> * pick it up?)</a>
<a name="ln787"> *</a>
<a name="ln788"> * Based purely on monster HD &amp; wand type for now. Higher-HD monsters are less</a>
<a name="ln789"> * inclined to bother with wands, especially the weaker ones.</a>
<a name="ln790"> *</a>
<a name="ln791"> * @param item      The wand in question.</a>
<a name="ln792"> * @return          Whether the monster will bother picking up the wand.</a>
<a name="ln793"> */</a>
<a name="ln794">bool monster::likes_wand(const item_def &amp;item) const</a>
<a name="ln795">{</a>
<a name="ln796">    ASSERT(item.base_type == OBJ_WANDS);</a>
<a name="ln797">    // kind of a hack</a>
<a name="ln798">    // assumptions:</a>
<a name="ln799">    // bad wands are value 48, so won't be used past hd 4</a>
<a name="ln800">    // mediocre wands are value 24; won't be used past hd 8</a>
<a name="ln801">    // good wands are value 15; won't be used past hd 9</a>
<a name="ln802">    // best wands are value 9; won't be used past hd 10</a>
<a name="ln803">    // better implementations welcome</a>
<a name="ln804">    return wand_charge_value(item.sub_type) + get_hit_dice() * 6 &lt;= 72;</a>
<a name="ln805">}</a>
<a name="ln806"> </a>
<a name="ln807">void monster::equip_weapon_message(item_def &amp;item)</a>
<a name="ln808">{</a>
<a name="ln809">    const string str = &quot; wields &quot; +</a>
<a name="ln810">                       item.name(DESC_A, false, false, true, false,</a>
<a name="ln811">                                 ISFLAG_CURSED) + &quot;.&quot;;</a>
<a name="ln812">    simple_monster_message(*this, str.c_str());</a>
<a name="ln813"> </a>
<a name="ln814">    const int brand = get_weapon_brand(item);</a>
<a name="ln815"> </a>
<a name="ln816">    bool message_given = true;</a>
<a name="ln817">    switch (brand)</a>
<a name="ln818">    {</a>
<a name="ln819">    case SPWPN_FLAMING:</a>
<a name="ln820">        mpr(&quot;It bursts into flame!&quot;);</a>
<a name="ln821">        break;</a>
<a name="ln822">    case SPWPN_FREEZING:</a>
<a name="ln823">        mpr(is_range_weapon(item) ? &quot;It is covered in frost.&quot;</a>
<a name="ln824">                                  : &quot;It glows with a cold blue light!&quot;);</a>
<a name="ln825">        break;</a>
<a name="ln826">    case SPWPN_HOLY_WRATH:</a>
<a name="ln827">        mpr(&quot;It softly glows with a divine radiance!&quot;);</a>
<a name="ln828">        break;</a>
<a name="ln829">    case SPWPN_ELECTROCUTION:</a>
<a name="ln830">        mprf(MSGCH_SOUND, &quot;You hear the crackle of electricity.&quot;);</a>
<a name="ln831">        break;</a>
<a name="ln832">    case SPWPN_VENOM:</a>
<a name="ln833">        mpr(&quot;It begins to drip with poison!&quot;);</a>
<a name="ln834">        break;</a>
<a name="ln835">    case SPWPN_DRAINING:</a>
<a name="ln836">        mpr(&quot;You sense an unholy aura.&quot;);</a>
<a name="ln837">        break;</a>
<a name="ln838">    case SPWPN_DISTORTION:</a>
<a name="ln839">        mpr(&quot;Its appearance distorts for a moment.&quot;);</a>
<a name="ln840">        break;</a>
<a name="ln841">    case SPWPN_CHAOS:</a>
<a name="ln842">        mpr(&quot;It is briefly surrounded by a scintillating aura of &quot;</a>
<a name="ln843">            &quot;random colours.&quot;);</a>
<a name="ln844">        break;</a>
<a name="ln845">    case SPWPN_PENETRATION:</a>
<a name="ln846">    {</a>
<a name="ln847">        bool plural = true;</a>
<a name="ln848">        string hand = hand_name(true, &amp;plural);</a>
<a name="ln849">        mprf(&quot;%s %s briefly %s through it before %s %s to get a &quot;</a>
<a name="ln850">             &quot;firm grip on it.&quot;,</a>
<a name="ln851">             pronoun(PRONOUN_POSSESSIVE).c_str(),</a>
<a name="ln852">             hand.c_str(),</a>
<a name="ln853">             // Not conj_verb: the monster isn't the subject.</a>
<a name="ln854">             conjugate_verb(&quot;pass&quot;, plural).c_str(),</a>
<a name="ln855">             pronoun(PRONOUN_SUBJECTIVE).c_str(),</a>
<a name="ln856">             conjugate_verb(&quot;manage&quot;, pronoun_plurality()).c_str());</a>
<a name="ln857">    }</a>
<a name="ln858">        break;</a>
<a name="ln859">    case SPWPN_REAPING:</a>
<a name="ln860">        mpr(&quot;It is briefly surrounded by shifting shadows.&quot;);</a>
<a name="ln861">        break;</a>
<a name="ln862">    case SPWPN_ACID:</a>
<a name="ln863">        mprf(&quot;It begins to drip corrosive slime!&quot;);</a>
<a name="ln864">        break;</a>
<a name="ln865"> </a>
<a name="ln866">    default:</a>
<a name="ln867">        // A ranged weapon without special message is known to be unbranded.</a>
<a name="ln868">        if (brand != SPWPN_NORMAL || !is_range_weapon(item))</a>
<a name="ln869">            message_given = false;</a>
<a name="ln870">    }</a>
<a name="ln871"> </a>
<a name="ln872">    if (message_given)</a>
<a name="ln873">    {</a>
<a name="ln874">        if (is_artefact(item) &amp;&amp; !is_unrandom_artefact(item))</a>
<a name="ln875">            artefact_learn_prop(item, ARTP_BRAND);</a>
<a name="ln876">        else</a>
<a name="ln877">            set_ident_flags(item, ISFLAG_KNOW_TYPE);</a>
<a name="ln878">    }</a>
<a name="ln879">}</a>
<a name="ln880"> </a>
<a name="ln881">/**</a>
<a name="ln882"> * What AC bonus does the monster get from the given item?</a>
<a name="ln883"> *</a>
<a name="ln884"> * @param calc_unid     Whether to include properties unknown (to the player)</a>
<a name="ln885"> *                      in the calculated result.</a>
<a name="ln886"> * @return              The AC provided by wearing the given item.</a>
<a name="ln887"> */</a>
<a name="ln888">int monster::armour_bonus(const item_def &amp;item, bool calc_unid) const</a>
<a name="ln889">{</a>
<a name="ln890">    ASSERT(!is_shield(item));</a>
<a name="ln891"> </a>
<a name="ln892">    int armour_ac = property(item, PARM_AC);</a>
<a name="ln893">    // For consistency with players, we should multiply this by 1 + (skill/22),</a>
<a name="ln894">    // where skill may be HD.</a>
<a name="ln895"> </a>
<a name="ln896">    if (!calc_unid &amp;&amp; !item_ident(item, ISFLAG_KNOW_PLUSES))</a>
<a name="ln897">        return armour_ac;</a>
<a name="ln898"> </a>
<a name="ln899">    const int armour_plus = item.plus;</a>
<a name="ln900">    ASSERT(abs(armour_plus) &lt; 30); // sanity check</a>
<a name="ln901">    return armour_ac + armour_plus;</a>
<a name="ln902">}</a>
<a name="ln903"> </a>
<a name="ln904">void monster::equip_armour_message(item_def &amp;item)</a>
<a name="ln905">{</a>
<a name="ln906">    const string str = &quot; wears &quot; +</a>
<a name="ln907">                       item.name(DESC_A) + &quot;.&quot;;</a>
<a name="ln908">    simple_monster_message(*this, str.c_str());</a>
<a name="ln909">}</a>
<a name="ln910"> </a>
<a name="ln911">void monster::equip_jewellery_message(item_def &amp;item)</a>
<a name="ln912">{</a>
<a name="ln913">    ASSERT(item.base_type == OBJ_JEWELLERY);</a>
<a name="ln914"> </a>
<a name="ln915">    const string str = &quot; puts on &quot; +</a>
<a name="ln916">                       item.name(DESC_A) + &quot;.&quot;;</a>
<a name="ln917">    simple_monster_message(*this, str.c_str());</a>
<a name="ln918">}</a>
<a name="ln919"> </a>
<a name="ln920">void monster::equip_message(item_def &amp;item)</a>
<a name="ln921">{</a>
<a name="ln922">    switch (item.base_type)</a>
<a name="ln923">    {</a>
<a name="ln924">    case OBJ_WEAPONS:</a>
<a name="ln925">    case OBJ_STAVES:</a>
<a name="ln926">        equip_weapon_message(item);</a>
<a name="ln927">        break;</a>
<a name="ln928"> </a>
<a name="ln929">    case OBJ_ARMOUR:</a>
<a name="ln930">        equip_armour_message(item);</a>
<a name="ln931">        break;</a>
<a name="ln932"> </a>
<a name="ln933">    case OBJ_JEWELLERY:</a>
<a name="ln934">        equip_jewellery_message(item);</a>
<a name="ln935">    break;</a>
<a name="ln936"> </a>
<a name="ln937">    default:</a>
<a name="ln938">        break;</a>
<a name="ln939">    }</a>
<a name="ln940">}</a>
<a name="ln941"> </a>
<a name="ln942">void monster::unequip_weapon(item_def &amp;item, bool msg)</a>
<a name="ln943">{</a>
<a name="ln944">    if (msg)</a>
<a name="ln945">    {</a>
<a name="ln946">        const string str = &quot; unwields &quot; +</a>
<a name="ln947">                           item.name(DESC_A, false, false, true, false,</a>
<a name="ln948">                                     ISFLAG_CURSED) + &quot;.&quot;;</a>
<a name="ln949">        msg = simple_monster_message(*this, str.c_str());</a>
<a name="ln950">    }</a>
<a name="ln951"> </a>
<a name="ln952">    const int brand = get_weapon_brand(item);</a>
<a name="ln953">    if (msg &amp;&amp; brand != SPWPN_NORMAL)</a>
<a name="ln954">    {</a>
<a name="ln955">        bool message_given = true;</a>
<a name="ln956">        switch (brand)</a>
<a name="ln957">        {</a>
<a name="ln958">        case SPWPN_FLAMING:</a>
<a name="ln959">            mpr(&quot;It stops flaming.&quot;);</a>
<a name="ln960">            break;</a>
<a name="ln961"> </a>
<a name="ln962">        case SPWPN_HOLY_WRATH:</a>
<a name="ln963">            mpr(&quot;It stops glowing.&quot;);</a>
<a name="ln964">            break;</a>
<a name="ln965"> </a>
<a name="ln966">        case SPWPN_ELECTROCUTION:</a>
<a name="ln967">            mpr(&quot;It stops crackling.&quot;);</a>
<a name="ln968">            break;</a>
<a name="ln969"> </a>
<a name="ln970">        case SPWPN_VENOM:</a>
<a name="ln971">            mpr(&quot;It stops dripping with poison.&quot;);</a>
<a name="ln972">            break;</a>
<a name="ln973"> </a>
<a name="ln974">        case SPWPN_DISTORTION:</a>
<a name="ln975">            mpr(&quot;Its appearance distorts for a moment.&quot;);</a>
<a name="ln976">            break;</a>
<a name="ln977"> </a>
<a name="ln978">        default:</a>
<a name="ln979">            message_given = false;</a>
<a name="ln980">        }</a>
<a name="ln981">        if (message_given)</a>
<a name="ln982">        {</a>
<a name="ln983">            if (is_artefact(item) &amp;&amp; !is_unrandom_artefact(item))</a>
<a name="ln984">                artefact_learn_prop(item, ARTP_BRAND);</a>
<a name="ln985">            else</a>
<a name="ln986">                set_ident_flags(item, ISFLAG_KNOW_TYPE);</a>
<a name="ln987">        }</a>
<a name="ln988">    }</a>
<a name="ln989"> </a>
<a name="ln990">    monster *spectral_weapon = find_spectral_weapon(this);</a>
<a name="ln991">    if (spectral_weapon)</a>
<a name="ln992">        end_spectral_weapon(spectral_weapon, false);</a>
<a name="ln993">}</a>
<a name="ln994"> </a>
<a name="ln995">void monster::unequip_armour(item_def &amp;item, bool msg)</a>
<a name="ln996">{</a>
<a name="ln997">    if (msg)</a>
<a name="ln998">    {</a>
<a name="ln999">        const string str = &quot; takes off &quot; +</a>
<a name="ln1000">                           item.name(DESC_A) + &quot;.&quot;;</a>
<a name="ln1001">        simple_monster_message(*this, str.c_str());</a>
<a name="ln1002">    }</a>
<a name="ln1003">}</a>
<a name="ln1004"> </a>
<a name="ln1005">void monster::unequip_jewellery(item_def &amp;item, bool msg)</a>
<a name="ln1006">{</a>
<a name="ln1007">    ASSERT(item.base_type == OBJ_JEWELLERY);</a>
<a name="ln1008"> </a>
<a name="ln1009">    if (msg)</a>
<a name="ln1010">    {</a>
<a name="ln1011">        const string str = &quot; takes off &quot; +</a>
<a name="ln1012">                           item.name(DESC_A) + &quot;.&quot;;</a>
<a name="ln1013">        simple_monster_message(*this, str.c_str());</a>
<a name="ln1014">    }</a>
<a name="ln1015">}</a>
<a name="ln1016"> </a>
<a name="ln1017">/**</a>
<a name="ln1018"> * Applies appropriate effects when unequipping an item.</a>
<a name="ln1019"> *</a>
<a name="ln1020"> * Note: this method does NOT modify this-&gt;inv to point to NON_ITEM!</a>
<a name="ln1021"> * @param item  the item to be removed.</a>
<a name="ln1022"> * @param msg   whether to give a message</a>
<a name="ln1023"> * @param force whether to remove the item even if cursed.</a>
<a name="ln1024"> * @return whether the item was unequipped successfully.</a>
<a name="ln1025"> */</a>
<a name="ln1026">bool monster::unequip(item_def &amp;item, bool msg, bool force)</a>
<a name="ln1027">{</a>
<a name="ln1028">    if (!force &amp;&amp; item.cursed())</a>
<a name="ln1029">        return false;</a>
<a name="ln1030"> </a>
<a name="ln1031">    if (!force &amp;&amp; you.can_see(*this))</a>
<a name="ln1032">        set_ident_flags(item, ISFLAG_KNOW_CURSE);</a>
<a name="ln1033"> </a>
<a name="ln1034">    switch (item.base_type)</a>
<a name="ln1035">    {</a>
<a name="ln1036">    case OBJ_WEAPONS:</a>
<a name="ln1037">        unequip_weapon(item, msg);</a>
<a name="ln1038">        break;</a>
<a name="ln1039"> </a>
<a name="ln1040">    case OBJ_ARMOUR:</a>
<a name="ln1041">        unequip_armour(item, msg);</a>
<a name="ln1042">        break;</a>
<a name="ln1043"> </a>
<a name="ln1044">    case OBJ_JEWELLERY:</a>
<a name="ln1045">        unequip_jewellery(item, msg);</a>
<a name="ln1046">        break;</a>
<a name="ln1047"> </a>
<a name="ln1048">    default:</a>
<a name="ln1049">        break;</a>
<a name="ln1050">    }</a>
<a name="ln1051"> </a>
<a name="ln1052">    return true;</a>
<a name="ln1053">}</a>
<a name="ln1054"> </a>
<a name="ln1055">void monster::lose_pickup_energy()</a>
<a name="ln1056">{</a>
<a name="ln1057">    if (const monsterentry* entry = find_monsterentry())</a>
<a name="ln1058">    {</a>
<a name="ln1059">        const int delta = speed * entry-&gt;energy_usage.pickup_percent / 100;</a>
<a name="ln1060">        if (speed_increment &gt; 25 &amp;&amp; delta &lt; speed_increment)</a>
<a name="ln1061">            speed_increment -= delta;</a>
<a name="ln1062">    }</a>
<a name="ln1063">}</a>
<a name="ln1064"> </a>
<a name="ln1065">void monster::pickup_message(const item_def &amp;item)</a>
<a name="ln1066">{</a>
<a name="ln1067">    if (is_range_weapon(item)</a>
<a name="ln1068">        || is_throwable(this, item)</a>
<a name="ln1069">        || item.base_type == OBJ_MISSILES)</a>
<a name="ln1070">    {</a>
<a name="ln1071">        flags |= MF_SEEN_RANGED;</a>
<a name="ln1072">    }</a>
<a name="ln1073"> </a>
<a name="ln1074">    mprf(&quot;%s picks up %s.&quot;,</a>
<a name="ln1075">         name(DESC_THE).c_str(),</a>
<a name="ln1076">         item.base_type == OBJ_GOLD ? &quot;some gold&quot;</a>
<a name="ln1077">                                    : item.name(DESC_A).c_str());</a>
<a name="ln1078">}</a>
<a name="ln1079"> </a>
<a name="ln1080">bool monster::pickup(item_def &amp;item, mon_inv_type slot, bool msg)</a>
<a name="ln1081">{</a>
<a name="ln1082">    ASSERT(item.defined());</a>
<a name="ln1083"> </a>
<a name="ln1084">    const monster* other_mon = item.holding_monster();</a>
<a name="ln1085"> </a>
<a name="ln1086">    if (other_mon != nullptr)</a>
<a name="ln1087">    {</a>
<a name="ln1088">        if (other_mon == this)</a>
<a name="ln1089">        {</a>
<a name="ln1090">            if (inv[slot] == item.index())</a>
<a name="ln1091">            {</a>
<a name="ln1092">                mprf(MSGCH_DIAGNOSTICS, &quot;Monster %s already holding item %s.&quot;,</a>
<a name="ln1093">                     name(DESC_PLAIN, true).c_str(),</a>
<a name="ln1094">                     item.name(DESC_PLAIN, false, true).c_str());</a>
<a name="ln1095">                return false;</a>
<a name="ln1096">            }</a>
<a name="ln1097">            else</a>
<a name="ln1098">            {</a>
<a name="ln1099">                mprf(MSGCH_DIAGNOSTICS, &quot;Item %s thinks it's already held by &quot;</a>
<a name="ln1100">                                        &quot;monster %s.&quot;,</a>
<a name="ln1101">                     item.name(DESC_PLAIN, false, true).c_str(),</a>
<a name="ln1102">                     name(DESC_PLAIN, true).c_str());</a>
<a name="ln1103">            }</a>
<a name="ln1104">        }</a>
<a name="ln1105">        else if (other_mon-&gt;type == MONS_NO_MONSTER)</a>
<a name="ln1106">        {</a>
<a name="ln1107">            mprf(MSGCH_DIAGNOSTICS, &quot;Item %s, held by dead monster, being &quot;</a>
<a name="ln1108">                                    &quot;picked up by monster %s.&quot;,</a>
<a name="ln1109">                 item.name(DESC_PLAIN, false, true).c_str(),</a>
<a name="ln1110">                 name(DESC_PLAIN, true).c_str());</a>
<a name="ln1111">        }</a>
<a name="ln1112">        else</a>
<a name="ln1113">        {</a>
<a name="ln1114">            mprf(MSGCH_DIAGNOSTICS, &quot;Item %s, held by monster %s, being &quot;</a>
<a name="ln1115">                                    &quot;picked up by monster %s.&quot;,</a>
<a name="ln1116">                 item.name(DESC_PLAIN, false, true).c_str(),</a>
<a name="ln1117">                 other_mon-&gt;name(DESC_PLAIN, true).c_str(),</a>
<a name="ln1118">                 name(DESC_PLAIN, true).c_str());</a>
<a name="ln1119">        }</a>
<a name="ln1120">    }</a>
<a name="ln1121"> </a>
<a name="ln1122">    // If a monster chooses a two-handed weapon as main weapon, it will</a>
<a name="ln1123">    // first have to drop any shield it might wear.</a>
<a name="ln1124">    // (Monsters will always favour damage over protection.)</a>
<a name="ln1125">    if ((slot == MSLOT_WEAPON || slot == MSLOT_ALT_WEAPON)</a>
<a name="ln1126">        &amp;&amp; inv[MSLOT_SHIELD] != NON_ITEM</a>
<a name="ln1127">        &amp;&amp; hands_reqd(item) == HANDS_TWO)</a>
<a name="ln1128">    {</a>
<a name="ln1129">        if (!drop_item(MSLOT_SHIELD, msg))</a>
<a name="ln1130">            return false;</a>
<a name="ln1131">    }</a>
<a name="ln1132"> </a>
<a name="ln1133">    // Similarly, monsters won't pick up shields if they're</a>
<a name="ln1134">    // wielding (or alt-wielding) a two-handed weapon.</a>
<a name="ln1135">    if (slot == MSLOT_SHIELD)</a>
<a name="ln1136">    {</a>
<a name="ln1137">        const item_def* wpn = mslot_item(MSLOT_WEAPON);</a>
<a name="ln1138">        const item_def* alt = mslot_item(MSLOT_ALT_WEAPON);</a>
<a name="ln1139">        if (wpn &amp;&amp; hands_reqd(*wpn) == HANDS_TWO)</a>
<a name="ln1140">            return false;</a>
<a name="ln1141">        if (alt &amp;&amp; hands_reqd(*alt) == HANDS_TWO)</a>
<a name="ln1142">            return false;</a>
<a name="ln1143">    }</a>
<a name="ln1144"> </a>
<a name="ln1145">    if (inv[slot] != NON_ITEM)</a>
<a name="ln1146">    {</a>
<a name="ln1147">        item_def &amp;dest(mitm[inv[slot]]);</a>
<a name="ln1148">        if (items_stack(item, dest))</a>
<a name="ln1149">        {</a>
<a name="ln1150">            dungeon_events.fire_position_event(</a>
<a name="ln1151">                dgn_event(DET_ITEM_PICKUP, pos(), 0, item.index(),</a>
<a name="ln1152">                          mindex()),</a>
<a name="ln1153">                pos());</a>
<a name="ln1154"> </a>
<a name="ln1155">            if (msg)</a>
<a name="ln1156">                pickup_message(item);</a>
<a name="ln1157">            merge_item_stacks(item, dest);</a>
<a name="ln1158">            inc_mitm_item_quantity(inv[slot], item.quantity);</a>
<a name="ln1159">            destroy_item(item.index());</a>
<a name="ln1160">            if (msg)</a>
<a name="ln1161">                equip_message(item);</a>
<a name="ln1162">            lose_pickup_energy();</a>
<a name="ln1163">            return true;</a>
<a name="ln1164">        }</a>
<a name="ln1165">        return false;</a>
<a name="ln1166">    }</a>
<a name="ln1167"> </a>
<a name="ln1168">    // don't try to pick up mimics</a>
<a name="ln1169">    if (item.flags &amp; ISFLAG_MIMIC)</a>
<a name="ln1170">        return false;</a>
<a name="ln1171"> </a>
<a name="ln1172">    dungeon_events.fire_position_event(</a>
<a name="ln1173">        dgn_event(DET_ITEM_PICKUP, pos(), 0, item.index(),</a>
<a name="ln1174">                  mindex()),</a>
<a name="ln1175">        pos());</a>
<a name="ln1176"> </a>
<a name="ln1177">    const int item_index = item.index();</a>
<a name="ln1178">    unlink_item(item_index);</a>
<a name="ln1179"> </a>
<a name="ln1180">    inv[slot] = item_index;</a>
<a name="ln1181"> </a>
<a name="ln1182">    item.set_holding_monster(*this);</a>
<a name="ln1183"> </a>
<a name="ln1184">    if (msg)</a>
<a name="ln1185">    {</a>
<a name="ln1186">        pickup_message(item);</a>
<a name="ln1187">        equip_message(item);</a>
<a name="ln1188">    }</a>
<a name="ln1189">    lose_pickup_energy();</a>
<a name="ln1190">    return true;</a>
<a name="ln1191">}</a>
<a name="ln1192"> </a>
<a name="ln1193">bool monster::drop_item(mon_inv_type eslot, bool msg)</a>
<a name="ln1194">{</a>
<a name="ln1195">    int item_index = inv[eslot];</a>
<a name="ln1196">    if (item_index == NON_ITEM)</a>
<a name="ln1197">        return true;</a>
<a name="ln1198"> </a>
<a name="ln1199">    item_def&amp; pitem = mitm[item_index];</a>
<a name="ln1200"> </a>
<a name="ln1201">    // Unequip equipped items before dropping them; unequip() prevents</a>
<a name="ln1202">    // cursed items from being removed.</a>
<a name="ln1203">    bool was_unequipped = false;</a>
<a name="ln1204">    if (eslot == MSLOT_WEAPON</a>
<a name="ln1205">        || eslot == MSLOT_ARMOUR</a>
<a name="ln1206">        || eslot == MSLOT_JEWELLERY</a>
<a name="ln1207">        || eslot == MSLOT_ALT_WEAPON &amp;&amp; mons_wields_two_weapons(*this))</a>
<a name="ln1208">    {</a>
<a name="ln1209">        if (!unequip(pitem, msg))</a>
<a name="ln1210">            return false;</a>
<a name="ln1211">        was_unequipped = true;</a>
<a name="ln1212">    }</a>
<a name="ln1213"> </a>
<a name="ln1214">    if (pitem.flags &amp; ISFLAG_SUMMONED)</a>
<a name="ln1215">    {</a>
<a name="ln1216">        if (msg)</a>
<a name="ln1217">        {</a>
<a name="ln1218">            mprf(&quot;%s %s as %s drops %s!&quot;,</a>
<a name="ln1219">                 pitem.name(DESC_THE).c_str(),</a>
<a name="ln1220">                 summoned_poof_msg(this, pitem).c_str(),</a>
<a name="ln1221">                 name(DESC_THE).c_str(),</a>
<a name="ln1222">                 pitem.quantity &gt; 1 ? &quot;them&quot; : &quot;it&quot;);</a>
<a name="ln1223">        }</a>
<a name="ln1224"> </a>
<a name="ln1225">        item_was_destroyed(pitem);</a>
<a name="ln1226">        destroy_item(item_index);</a>
<a name="ln1227">    }</a>
<a name="ln1228">    else</a>
<a name="ln1229">    {</a>
<a name="ln1230">        if (msg)</a>
<a name="ln1231">        {</a>
<a name="ln1232">            mprf(&quot;%s drops %s.&quot;, name(DESC_THE).c_str(),</a>
<a name="ln1233">                 pitem.name(DESC_A).c_str());</a>
<a name="ln1234">        }</a>
<a name="ln1235">        pitem.props[DROPPER_MID_KEY].get_int() = mid;</a>
<a name="ln1236"> </a>
<a name="ln1237">        if (!move_item_to_grid(&amp;item_index, pos(), swimming()))</a>
<a name="ln1238">        {</a>
<a name="ln1239">            // Re-equip item if we somehow failed to drop it.</a>
<a name="ln1240">            if (was_unequipped &amp;&amp; msg)</a>
<a name="ln1241">                equip_message(pitem);</a>
<a name="ln1242"> </a>
<a name="ln1243">            return false;</a>
<a name="ln1244">        }</a>
<a name="ln1245">    }</a>
<a name="ln1246"> </a>
<a name="ln1247">    inv[eslot] = NON_ITEM;</a>
<a name="ln1248">    return true;</a>
<a name="ln1249">}</a>
<a name="ln1250"> </a>
<a name="ln1251">bool monster::pickup_launcher(item_def &amp;launch, bool msg, bool force)</a>
<a name="ln1252">{</a>
<a name="ln1253">    // Don't allow monsters to pick up launchers that would also</a>
<a name="ln1254">    // refuse to pick up the matching ammo.</a>
<a name="ln1255">    if (!force &amp;&amp; !_needs_ranged_attack(this))</a>
<a name="ln1256">        return false;</a>
<a name="ln1257"> </a>
<a name="ln1258">    // Don't allow monsters to switch to another type of launcher</a>
<a name="ln1259">    // as that would require them to also drop their ammunition</a>
<a name="ln1260">    // and then try to find ammunition for their new launcher.</a>
<a name="ln1261">    // However, they may switch to another launcher if they're</a>
<a name="ln1262">    // out of ammo. (jpeg)</a>
<a name="ln1263">    const int mdam_rating = mons_weapon_damage_rating(launch);</a>
<a name="ln1264">    const missile_type mt = fires_ammo_type(launch);</a>
<a name="ln1265">    mon_inv_type eslot = NUM_MONSTER_SLOTS;</a>
<a name="ln1266">    for (int i = MSLOT_WEAPON; i &lt;= MSLOT_ALT_WEAPON; ++i)</a>
<a name="ln1267">    {</a>
<a name="ln1268">        auto slot = static_cast&lt;mon_inv_type&gt;(i);</a>
<a name="ln1269">        if (const item_def *elaunch = mslot_item(slot))</a>
<a name="ln1270">        {</a>
<a name="ln1271">            if (!is_range_weapon(*elaunch))</a>
<a name="ln1272">                continue;</a>
<a name="ln1273"> </a>
<a name="ln1274">            return (fires_ammo_type(*elaunch) == mt || !missiles())</a>
<a name="ln1275">                   &amp;&amp; (mons_weapon_damage_rating(*elaunch) &lt; mdam_rating</a>
<a name="ln1276">                       || mons_weapon_damage_rating(*elaunch) == mdam_rating</a>
<a name="ln1277">                          &amp;&amp; get_weapon_brand(*elaunch) == SPWPN_NORMAL</a>
<a name="ln1278">                          &amp;&amp; get_weapon_brand(launch) != SPWPN_NORMAL)</a>
<a name="ln1279">                   &amp;&amp; drop_item(slot, msg) &amp;&amp; pickup(launch, slot, msg);</a>
<a name="ln1280">        }</a>
<a name="ln1281">        else</a>
<a name="ln1282">            eslot = slot;</a>
<a name="ln1283">    }</a>
<a name="ln1284"> </a>
<a name="ln1285">    return eslot == NUM_MONSTER_SLOTS ? false : pickup(launch, eslot, msg);</a>
<a name="ln1286">}</a>
<a name="ln1287"> </a>
<a name="ln1288">static bool _is_signature_weapon(const monster* mons, const item_def &amp;weapon)</a>
<a name="ln1289">{</a>
<a name="ln1290">    // Don't pick up items that would interfere with our special ability</a>
<a name="ln1291">    if (mons-&gt;type == MONS_RED_DEVIL)</a>
<a name="ln1292">        return item_attack_skill(weapon) == SK_POLEARMS;</a>
<a name="ln1293"> </a>
<a name="ln1294">    // Some other uniques have a signature weapon, usually because they</a>
<a name="ln1295">    // always spawn with it, or because it is referenced in their speech</a>
<a name="ln1296">    // and/or descriptions.</a>
<a name="ln1297">    // Upgrading to a similar type is pretty much always allowed, unless</a>
<a name="ln1298">    // we are more interested in the brand, and the brand is *rare*.</a>
<a name="ln1299">    if (mons_is_unique(mons-&gt;type))</a>
<a name="ln1300">    {</a>
<a name="ln1301">        weapon_type wtype = (weapon.base_type == OBJ_WEAPONS) ?</a>
<a name="ln1302">            (weapon_type)weapon.sub_type : NUM_WEAPONS;</a>
<a name="ln1303"> </a>
<a name="ln1304">        // We might allow Sigmund to pick up a better scythe if he finds</a>
<a name="ln1305">        // one...</a>
<a name="ln1306">        if (mons-&gt;type == MONS_SIGMUND)</a>
<a name="ln1307">            return wtype == WPN_SCYTHE;</a>
<a name="ln1308"> </a>
<a name="ln1309">        // Crazy Yiuf's got MONUSE_STARTING_EQUIPMENT right now, but</a>
<a name="ln1310">        // in case that ever changes we don't want him to switch away</a>
<a name="ln1311">        // from his quarterstaff of chaos.</a>
<a name="ln1312">        if (mons-&gt;type == MONS_CRAZY_YIUF)</a>
<a name="ln1313">        {</a>
<a name="ln1314">            return wtype == WPN_QUARTERSTAFF</a>
<a name="ln1315">                   &amp;&amp; get_weapon_brand(weapon) == SPWPN_CHAOS;</a>
<a name="ln1316">        }</a>
<a name="ln1317"> </a>
<a name="ln1318">        // Distortion/chaos is immensely flavourful, and we shouldn't</a>
<a name="ln1319">        // allow Psyche to switch away from it.</a>
<a name="ln1320">        if (mons-&gt;type == MONS_PSYCHE)</a>
<a name="ln1321">        {</a>
<a name="ln1322">            return get_weapon_brand(weapon) == SPWPN_CHAOS</a>
<a name="ln1323">                   || get_weapon_brand(weapon) == SPWPN_DISTORTION;</a>
<a name="ln1324">        }</a>
<a name="ln1325"> </a>
<a name="ln1326">        // Don't switch Azrael away from the customary scimitar of</a>
<a name="ln1327">        // flaming.</a>
<a name="ln1328">        if (mons-&gt;type == MONS_AZRAEL)</a>
<a name="ln1329">        {</a>
<a name="ln1330">            return wtype == WPN_SCIMITAR</a>
<a name="ln1331">                   &amp;&amp; get_weapon_brand(weapon) == SPWPN_FLAMING;</a>
<a name="ln1332">        }</a>
<a name="ln1333"> </a>
<a name="ln1334">        if (mons-&gt;type == MONS_AGNES)</a>
<a name="ln1335">            return wtype == WPN_LAJATANG;</a>
<a name="ln1336"> </a>
<a name="ln1337">        if (mons-&gt;type == MONS_EDMUND)</a>
<a name="ln1338">            return wtype == WPN_FLAIL || wtype == WPN_DIRE_FLAIL;</a>
<a name="ln1339"> </a>
<a name="ln1340">        // Pikel's got MONUSE_STARTING_EQUIPMENT right now, but,</a>
<a name="ln1341">        // in case that ever changes, we don't want him to switch away</a>
<a name="ln1342">        // from a whip.</a>
<a name="ln1343">        if (mons-&gt;type == MONS_PIKEL)</a>
<a name="ln1344">            return get_vorpal_type(weapon) == DVORP_SLASHING;</a>
<a name="ln1345"> </a>
<a name="ln1346">        if (mons-&gt;type == MONS_NIKOLA)</a>
<a name="ln1347">            return get_weapon_brand(weapon) == SPWPN_ELECTROCUTION;</a>
<a name="ln1348"> </a>
<a name="ln1349">        if (mons-&gt;type == MONS_DUVESSA)</a>
<a name="ln1350">        {</a>
<a name="ln1351">            return item_attack_skill(weapon) == SK_SHORT_BLADES</a>
<a name="ln1352">                   || item_attack_skill(weapon) == SK_LONG_BLADES;</a>
<a name="ln1353">        }</a>
<a name="ln1354"> </a>
<a name="ln1355">        if (mons-&gt;type == MONS_IGNACIO)</a>
<a name="ln1356">            return wtype == WPN_EXECUTIONERS_AXE;</a>
<a name="ln1357"> </a>
<a name="ln1358">        if (mons-&gt;type == MONS_MENNAS)</a>
<a name="ln1359">            return get_weapon_brand(weapon) == SPWPN_HOLY_WRATH;</a>
<a name="ln1360"> </a>
<a name="ln1361">        if (mons-&gt;type == MONS_ARACHNE)</a>
<a name="ln1362">        {</a>
<a name="ln1363">            return weapon.is_type(OBJ_STAVES, STAFF_POISON)</a>
<a name="ln1364">                   || is_unrandom_artefact(weapon, UNRAND_OLGREB);</a>
<a name="ln1365">        }</a>
<a name="ln1366"> </a>
<a name="ln1367">        if (mons-&gt;type == MONS_FANNAR)</a>
<a name="ln1368">            return weapon.is_type(OBJ_STAVES, STAFF_COLD);</a>
<a name="ln1369"> </a>
<a name="ln1370">        // Asterion's demon weapon was a gift from Makhleb.</a>
<a name="ln1371">        if (mons-&gt;type == MONS_ASTERION)</a>
<a name="ln1372">        {</a>
<a name="ln1373">            return wtype == WPN_DEMON_BLADE || wtype == WPN_DEMON_WHIP</a>
<a name="ln1374">                || wtype == WPN_DEMON_TRIDENT;</a>
<a name="ln1375">        }</a>
<a name="ln1376"> </a>
<a name="ln1377">        // Donald kept dropping his shield. I hate that.</a>
<a name="ln1378">        if (mons-&gt;type == MONS_DONALD)</a>
<a name="ln1379">            return mons-&gt;hands_reqd(weapon) == HANDS_ONE;</a>
<a name="ln1380"> </a>
<a name="ln1381">        // What kind of assassin would forget her dagger somewhere else?</a>
<a name="ln1382">        if (mons-&gt;type == MONS_SONJA)</a>
<a name="ln1383">            return item_attack_skill(weapon) == SK_SHORT_BLADES;</a>
<a name="ln1384"> </a>
<a name="ln1385">        if (mons-&gt;type == MONS_IMPERIAL_MYRMIDON)</a>
<a name="ln1386">            return item_attack_skill(weapon) == SK_LONG_BLADES;</a>
<a name="ln1387">    }</a>
<a name="ln1388"> </a>
<a name="ln1389">    if (mons-&gt;is_holy())</a>
<a name="ln1390">        return is_blessed(weapon) || get_weapon_brand(weapon) == SPWPN_HOLY_WRATH;</a>
<a name="ln1391"> </a>
<a name="ln1392">    if (is_unrandom_artefact(weapon))</a>
<a name="ln1393">    {</a>
<a name="ln1394">        switch (weapon.unrand_idx)</a>
<a name="ln1395">        {</a>
<a name="ln1396">        case UNRAND_ASMODEUS:</a>
<a name="ln1397">            return mons-&gt;type == MONS_ASMODEUS;</a>
<a name="ln1398"> </a>
<a name="ln1399">        case UNRAND_DISPATER:</a>
<a name="ln1400">            return mons-&gt;type == MONS_DISPATER;</a>
<a name="ln1401"> </a>
<a name="ln1402">        case UNRAND_CEREBOV:</a>
<a name="ln1403">            return mons-&gt;type == MONS_CEREBOV;</a>
<a name="ln1404"> </a>
<a name="ln1405">        case UNRAND_MORG:</a>
<a name="ln1406">            return mons-&gt;type == MONS_BORIS;</a>
<a name="ln1407">        }</a>
<a name="ln1408">    }</a>
<a name="ln1409"> </a>
<a name="ln1410">    return false;</a>
<a name="ln1411">}</a>
<a name="ln1412"> </a>
<a name="ln1413">static int _ego_damage_bonus(item_def &amp;item)</a>
<a name="ln1414">{</a>
<a name="ln1415">    switch (get_weapon_brand(item))</a>
<a name="ln1416">    {</a>
<a name="ln1417">    case SPWPN_NORMAL:      return 0;</a>
<a name="ln1418">    case SPWPN_VORPAL:      // deliberate fall through</a>
<a name="ln1419">    case SPWPN_PROTECTION:  return 1;</a>
<a name="ln1420">    default:                return 2;</a>
<a name="ln1421">    }</a>
<a name="ln1422">}</a>
<a name="ln1423"> </a>
<a name="ln1424">bool monster::pickup_melee_weapon(item_def &amp;item, bool msg)</a>
<a name="ln1425">{</a>
<a name="ln1426">    // Draconian monks are masters of unarmed combat.</a>
<a name="ln1427">    // Monstrous demonspawn prefer to RIP AND TEAR with their claws.</a>
<a name="ln1428">    // XXX: this could probably be a monster flag</a>
<a name="ln1429">    if (type == MONS_DRACONIAN_MONK</a>
<a name="ln1430">        || mons_is_demonspawn(type)</a>
<a name="ln1431">           &amp;&amp; draco_or_demonspawn_subspecies(*this) == MONS_MONSTROUS_DEMONSPAWN)</a>
<a name="ln1432">    {</a>
<a name="ln1433">        return false;</a>
<a name="ln1434">    }</a>
<a name="ln1435"> </a>
<a name="ln1436">    const bool dual_wielding = mons_wields_two_weapons(*this);</a>
<a name="ln1437">    if (dual_wielding)</a>
<a name="ln1438">    {</a>
<a name="ln1439">        // If we have either weapon slot free, pick up the weapon.</a>
<a name="ln1440">        if (inv[MSLOT_WEAPON] == NON_ITEM)</a>
<a name="ln1441">            return pickup(item, MSLOT_WEAPON, msg);</a>
<a name="ln1442"> </a>
<a name="ln1443">        if (inv[MSLOT_ALT_WEAPON] == NON_ITEM)</a>
<a name="ln1444">            return pickup(item, MSLOT_ALT_WEAPON, msg);</a>
<a name="ln1445">    }</a>
<a name="ln1446"> </a>
<a name="ln1447">    const int new_wpn_dam = mons_weapon_damage_rating(item)</a>
<a name="ln1448">                            + _ego_damage_bonus(item);</a>
<a name="ln1449">    mon_inv_type eslot = NUM_MONSTER_SLOTS;</a>
<a name="ln1450">    item_def *weap;</a>
<a name="ln1451"> </a>
<a name="ln1452">    // Monsters have two weapon slots, one of which can be a ranged, and</a>
<a name="ln1453">    // the other a melee weapon. (The exception being dual-wielders who can</a>
<a name="ln1454">    // wield two melee weapons). The weapon in MSLOT_WEAPON is the one</a>
<a name="ln1455">    // currently wielded (can be empty).</a>
<a name="ln1456"> </a>
<a name="ln1457">    for (int i = MSLOT_WEAPON; i &lt;= MSLOT_ALT_WEAPON; ++i)</a>
<a name="ln1458">    {</a>
<a name="ln1459">        auto slot = static_cast&lt;mon_inv_type&gt;(i);</a>
<a name="ln1460">        weap = mslot_item(slot);</a>
<a name="ln1461"> </a>
<a name="ln1462">        if (!weap)</a>
<a name="ln1463">        {</a>
<a name="ln1464">            // If no weapon in this slot, mark this one.</a>
<a name="ln1465">            if (eslot == NUM_MONSTER_SLOTS)</a>
<a name="ln1466">                eslot = slot;</a>
<a name="ln1467">        }</a>
<a name="ln1468">        else</a>
<a name="ln1469">        {</a>
<a name="ln1470">            if (is_range_weapon(*weap))</a>
<a name="ln1471">                continue;</a>
<a name="ln1472"> </a>
<a name="ln1473">            // Don't swap from a signature weapon to a non-signature one.</a>
<a name="ln1474">            if (!_is_signature_weapon(this, item)</a>
<a name="ln1475">                &amp;&amp; _is_signature_weapon(this, *weap))</a>
<a name="ln1476">            {</a>
<a name="ln1477">                if (dual_wielding)</a>
<a name="ln1478">                    continue;</a>
<a name="ln1479">                else</a>
<a name="ln1480">                    return false;</a>
<a name="ln1481">            }</a>
<a name="ln1482"> </a>
<a name="ln1483">            // If we get here, the weapon is a melee weapon.</a>
<a name="ln1484">            // If the new weapon is better than the current one and not cursed,</a>
<a name="ln1485">            // replace it. Otherwise, give up.</a>
<a name="ln1486">            const int old_wpn_dam = mons_weapon_damage_rating(*weap)</a>
<a name="ln1487">                                    + _ego_damage_bonus(*weap);</a>
<a name="ln1488"> </a>
<a name="ln1489">            bool new_wpn_better = new_wpn_dam &gt; old_wpn_dam;</a>
<a name="ln1490">            if (new_wpn_dam == old_wpn_dam)</a>
<a name="ln1491">            {</a>
<a name="ln1492">                // Use shopping value as a crude estimate of resistances etc.</a>
<a name="ln1493">                // XXX: This is not really logical as many properties don't</a>
<a name="ln1494">                //      apply to monsters (e.g. flight, blink, berserk).</a>
<a name="ln1495">                // For simplicity, don't apply this check to secondary weapons</a>
<a name="ln1496">                // for dual wielding monsters.</a>
<a name="ln1497">                int oldval = item_value(*weap, true);</a>
<a name="ln1498">                int newval = item_value(item, true);</a>
<a name="ln1499"> </a>
<a name="ln1500">                if (newval &gt; oldval)</a>
<a name="ln1501">                    new_wpn_better = true;</a>
<a name="ln1502">            }</a>
<a name="ln1503"> </a>
<a name="ln1504">            if (new_wpn_better &amp;&amp; !weap-&gt;cursed())</a>
<a name="ln1505">            {</a>
<a name="ln1506">                if (!dual_wielding</a>
<a name="ln1507">                    || slot == MSLOT_WEAPON</a>
<a name="ln1508">                    || old_wpn_dam</a>
<a name="ln1509">                       &lt; mons_weapon_damage_rating(*mslot_item(MSLOT_WEAPON))</a>
<a name="ln1510">                         + _ego_damage_bonus(*mslot_item(MSLOT_WEAPON)))</a>
<a name="ln1511">                {</a>
<a name="ln1512">                    eslot = slot;</a>
<a name="ln1513">                    if (!dual_wielding)</a>
<a name="ln1514">                        break;</a>
<a name="ln1515">                }</a>
<a name="ln1516">            }</a>
<a name="ln1517">            else if (!dual_wielding)</a>
<a name="ln1518">            {</a>
<a name="ln1519">                // Only dual wielders want two melee weapons.</a>
<a name="ln1520">                return false;</a>
<a name="ln1521">            }</a>
<a name="ln1522">        }</a>
<a name="ln1523">    }</a>
<a name="ln1524"> </a>
<a name="ln1525">    // No slot found to place this item.</a>
<a name="ln1526">    if (eslot == NUM_MONSTER_SLOTS)</a>
<a name="ln1527">        return false;</a>
<a name="ln1528"> </a>
<a name="ln1529">    // Current item cannot be dropped.</a>
<a name="ln1530">    if (inv[eslot] != NON_ITEM &amp;&amp; !drop_item(eslot, msg))</a>
<a name="ln1531">        return false;</a>
<a name="ln1532"> </a>
<a name="ln1533">    return pickup(item, eslot, msg);</a>
<a name="ln1534">}</a>
<a name="ln1535"> </a>
<a name="ln1536">bool monster::wants_weapon(const item_def &amp;weap) const</a>
<a name="ln1537">{</a>
<a name="ln1538">    if (!could_wield(weap))</a>
<a name="ln1539">        return false;</a>
<a name="ln1540"> </a>
<a name="ln1541">    // Blademasters and master archers like their starting weapon and</a>
<a name="ln1542">    // don't want another, thank you.</a>
<a name="ln1543">    if (type == MONS_DEEP_ELF_BLADEMASTER</a>
<a name="ln1544">        || type == MONS_DEEP_ELF_MASTER_ARCHER)</a>
<a name="ln1545">    {</a>
<a name="ln1546">        return false;</a>
<a name="ln1547">    }</a>
<a name="ln1548"> </a>
<a name="ln1549">    // Monsters capable of dual-wielding will always prefer two weapons</a>
<a name="ln1550">    // to a single two-handed one, however strong.</a>
<a name="ln1551">    if (mons_wields_two_weapons(*this)</a>
<a name="ln1552">        &amp;&amp; hands_reqd(weap) == HANDS_TWO)</a>
<a name="ln1553">    {</a>
<a name="ln1554">        return false;</a>
<a name="ln1555">    }</a>
<a name="ln1556"> </a>
<a name="ln1557">    // Don't pick up a new weapon if we've been gifted one by the player.</a>
<a name="ln1558">    if (is_range_weapon(weap) &amp;&amp; props.exists(BEOGH_RANGE_WPN_GIFT_KEY))</a>
<a name="ln1559">        return false;</a>
<a name="ln1560">    else if (props.exists(BEOGH_MELEE_WPN_GIFT_KEY))</a>
<a name="ln1561">        return false;</a>
<a name="ln1562"> </a>
<a name="ln1563">    // Arcane spellcasters don't want -Cast.</a>
<a name="ln1564">    if (is_actual_spellcaster()</a>
<a name="ln1565">        &amp;&amp; is_artefact(weap)</a>
<a name="ln1566">        &amp;&amp; artefact_property(weap, ARTP_PREVENT_SPELLCASTING))</a>
<a name="ln1567">    {</a>
<a name="ln1568">        return false;</a>
<a name="ln1569">    }</a>
<a name="ln1570"> </a>
<a name="ln1571">    // Nobody picks up giant clubs. Starting equipment is okay, of course.</a>
<a name="ln1572">    if (is_giant_club_type(weap.sub_type))</a>
<a name="ln1573">        return false;</a>
<a name="ln1574"> </a>
<a name="ln1575">    return true;</a>
<a name="ln1576">}</a>
<a name="ln1577"> </a>
<a name="ln1578">bool monster::wants_armour(const item_def &amp;item) const</a>
<a name="ln1579">{</a>
<a name="ln1580">    // Monsters that are capable of dual wielding won't pick up shields.</a>
<a name="ln1581">    // Neither will monsters that are already wielding a two-hander.</a>
<a name="ln1582">    if (is_shield(item)</a>
<a name="ln1583">        &amp;&amp; (mons_wields_two_weapons(*this)</a>
<a name="ln1584">            || mslot_item(MSLOT_WEAPON)</a>
<a name="ln1585">               &amp;&amp; hands_reqd(*mslot_item(MSLOT_WEAPON))</a>
<a name="ln1586">                      == HANDS_TWO))</a>
<a name="ln1587">    {</a>
<a name="ln1588">        return false;</a>
<a name="ln1589">    }</a>
<a name="ln1590"> </a>
<a name="ln1591">    // Don't pick up new armour if we've been gifted something by the player.</a>
<a name="ln1592">    if (is_shield(item) &amp;&amp; props.exists(BEOGH_SH_GIFT_KEY))</a>
<a name="ln1593">        return false;</a>
<a name="ln1594">    else if (props.exists(BEOGH_ARM_GIFT_KEY))</a>
<a name="ln1595">        return false;</a>
<a name="ln1596"> </a>
<a name="ln1597">    // Spellcasters won't pick up restricting armour, although they can</a>
<a name="ln1598">    // start with one. Applies to arcane spells only, of course.</a>
<a name="ln1599">    if (!pos().origin() &amp;&amp; is_actual_spellcaster()</a>
<a name="ln1600">        &amp;&amp; (property(item, PARM_EVASION) / 10 &lt; -5</a>
<a name="ln1601">            || is_artefact(item)</a>
<a name="ln1602">               &amp;&amp; artefact_property(item, ARTP_PREVENT_SPELLCASTING)))</a>
<a name="ln1603">    {</a>
<a name="ln1604">        return false;</a>
<a name="ln1605">    }</a>
<a name="ln1606"> </a>
<a name="ln1607">    // Returns whether this armour is the monster's size.</a>
<a name="ln1608">    return check_armour_size(item, body_size());</a>
<a name="ln1609">}</a>
<a name="ln1610"> </a>
<a name="ln1611">bool monster::wants_jewellery(const item_def &amp;item) const</a>
<a name="ln1612">{</a>
<a name="ln1613">    // Arcane spellcasters don't want -Cast.</a>
<a name="ln1614">    if (is_actual_spellcaster()</a>
<a name="ln1615">        &amp;&amp; is_artefact(item)</a>
<a name="ln1616">        &amp;&amp; artefact_property(item, ARTP_PREVENT_SPELLCASTING))</a>
<a name="ln1617">    {</a>
<a name="ln1618">        return false;</a>
<a name="ln1619">    }</a>
<a name="ln1620"> </a>
<a name="ln1621">    if (item.sub_type == AMU_INACCURACY)</a>
<a name="ln1622">        return false;</a>
<a name="ln1623"> </a>
<a name="ln1624">    // TODO: figure out what monsters actually want rings or amulets</a>
<a name="ln1625">    return true;</a>
<a name="ln1626">}</a>
<a name="ln1627"> </a>
<a name="ln1628">// Monsters magically know the real properties of all items.</a>
<a name="ln1629">static int _get_monster_armour_value(const monster *mon,</a>
<a name="ln1630">                                     const item_def &amp;item)</a>
<a name="ln1631">{</a>
<a name="ln1632">    // Each resistance/property counts as much as 1 point of AC.</a>
<a name="ln1633">    // Steam has been excluded because of its general uselessness.</a>
<a name="ln1634">    int value = item.armour_rating()</a>
<a name="ln1635">              + get_armour_res_fire(item, true)</a>
<a name="ln1636">              + get_armour_res_cold(item, true)</a>
<a name="ln1637">              + get_armour_res_elec(item, true)</a>
<a name="ln1638">              + get_armour_res_corr(item);</a>
<a name="ln1639"> </a>
<a name="ln1640">    // Give a simple bonus, no matter the size of the MR bonus.</a>
<a name="ln1641">    if (get_armour_res_magic(item, true) &gt; 0)</a>
<a name="ln1642">        value++;</a>
<a name="ln1643"> </a>
<a name="ln1644">    // Poison becomes much less valuable if the monster is</a>
<a name="ln1645">    // intrinsically resistant.</a>
<a name="ln1646">    if (get_mons_resist(*mon, MR_RES_POISON) &lt;= 0)</a>
<a name="ln1647">        value += get_armour_res_poison(item, true);</a>
<a name="ln1648"> </a>
<a name="ln1649">    // Same for life protection.</a>
<a name="ln1650">    if (mon-&gt;holiness() &amp; MH_NATURAL)</a>
<a name="ln1651">        value += get_armour_life_protection(item, true);</a>
<a name="ln1652"> </a>
<a name="ln1653">    // See invisible also is only useful if not already intrinsic.</a>
<a name="ln1654">    if (!mons_class_flag(mon-&gt;type, M_SEE_INVIS))</a>
<a name="ln1655">        value += get_armour_see_invisible(item, true);</a>
<a name="ln1656"> </a>
<a name="ln1657">    // Give a sizable bonus for shields of reflection.</a>
<a name="ln1658">    if (get_armour_ego_type(item) == SPARM_REFLECTION)</a>
<a name="ln1659">        value += 3;</a>
<a name="ln1660"> </a>
<a name="ln1661">    // And an even more sizable bonus for boots/bardings of running.</a>
<a name="ln1662">    if (get_armour_ego_type(item) == SPARM_RUNNING)</a>
<a name="ln1663">        value += 5;</a>
<a name="ln1664"> </a>
<a name="ln1665">    return value;</a>
<a name="ln1666">}</a>
<a name="ln1667"> </a>
<a name="ln1668">/**</a>
<a name="ln1669"> * Attempt to have a monster pick up and wear the given armour item.</a>
<a name="ln1670"> * @param item  The item in question.</a>
<a name="ln1671"> * @param msg   Whether to print a message</a>
<a name="ln1672"> * @param force If true, force the monster to pick up and wear the item.</a>
<a name="ln1673"> * @return  True if the monster picks up and wears the item, false otherwise.</a>
<a name="ln1674"> */</a>
<a name="ln1675">bool monster::pickup_armour(item_def &amp;item, bool msg, bool force)</a>
<a name="ln1676">{</a>
<a name="ln1677">    ASSERT(item.base_type == OBJ_ARMOUR);</a>
<a name="ln1678"> </a>
<a name="ln1679">    if (!force &amp;&amp; !wants_armour(item))</a>
<a name="ln1680">        return false;</a>
<a name="ln1681"> </a>
<a name="ln1682">    const monster_type genus = mons_genus(mons_species(true));</a>
<a name="ln1683">    const monster_type base_type = mons_is_zombified(*this) ? base_monster</a>
<a name="ln1684">                                                            : type;</a>
<a name="ln1685">    equipment_type eq = EQ_NONE;</a>
<a name="ln1686"> </a>
<a name="ln1687">    // HACK to allow nagas/centaurs to wear bardings. (jpeg)</a>
<a name="ln1688">    switch (item.sub_type)</a>
<a name="ln1689">    {</a>
<a name="ln1690">    case ARM_NAGA_BARDING:</a>
<a name="ln1691">        if (genus == MONS_NAGA || genus == MONS_SALAMANDER)</a>
<a name="ln1692">            eq = EQ_BODY_ARMOUR;</a>
<a name="ln1693">        break;</a>
<a name="ln1694">    case ARM_CENTAUR_BARDING:</a>
<a name="ln1695">        if (genus == MONS_CENTAUR || genus == MONS_YAKTAUR)</a>
<a name="ln1696">            eq = EQ_BODY_ARMOUR;</a>
<a name="ln1697">        break;</a>
<a name="ln1698">    // And another hack or two...</a>
<a name="ln1699">    case ARM_HAT:</a>
<a name="ln1700">        if (base_type == MONS_GASTRONOK || genus == MONS_OCTOPODE)</a>
<a name="ln1701">            eq = EQ_BODY_ARMOUR;</a>
<a name="ln1702">        break;</a>
<a name="ln1703">    case ARM_CLOAK:</a>
<a name="ln1704">        if (base_type == MONS_MAURICE</a>
<a name="ln1705">            || base_type == MONS_NIKOLA</a>
<a name="ln1706">            || base_type == MONS_CRAZY_YIUF</a>
<a name="ln1707">            || genus == MONS_DRACONIAN)</a>
<a name="ln1708">        {</a>
<a name="ln1709">            eq = EQ_BODY_ARMOUR;</a>
<a name="ln1710">        }</a>
<a name="ln1711">        break;</a>
<a name="ln1712">    case ARM_GLOVES:</a>
<a name="ln1713">        if (base_type == MONS_NIKOLA)</a>
<a name="ln1714">            eq = EQ_SHIELD;</a>
<a name="ln1715">        break;</a>
<a name="ln1716">    case ARM_HELMET:</a>
<a name="ln1717">        if (base_type == MONS_ROBIN)</a>
<a name="ln1718">            eq = EQ_SHIELD;</a>
<a name="ln1719">        break;</a>
<a name="ln1720">    default:</a>
<a name="ln1721">        eq = get_armour_slot(item);</a>
<a name="ln1722"> </a>
<a name="ln1723">        if (eq == EQ_BODY_ARMOUR &amp;&amp; genus == MONS_DRACONIAN)</a>
<a name="ln1724">            return false;</a>
<a name="ln1725"> </a>
<a name="ln1726">        if (eq != EQ_HELMET &amp;&amp; base_type == MONS_GASTRONOK)</a>
<a name="ln1727">            return false;</a>
<a name="ln1728"> </a>
<a name="ln1729">        if (eq != EQ_HELMET &amp;&amp; eq != EQ_SHIELD</a>
<a name="ln1730">            &amp;&amp; genus == MONS_OCTOPODE)</a>
<a name="ln1731">        {</a>
<a name="ln1732">            return false;</a>
<a name="ln1733">        }</a>
<a name="ln1734">    }</a>
<a name="ln1735"> </a>
<a name="ln1736">    // Bardings are only wearable by the appropriate monster.</a>
<a name="ln1737">    if (eq == EQ_NONE)</a>
<a name="ln1738">        return false;</a>
<a name="ln1739"> </a>
<a name="ln1740">    // XXX: Monsters can only equip body armour and shields (as of 0.4).</a>
<a name="ln1741">    if (!force &amp;&amp; eq != EQ_BODY_ARMOUR &amp;&amp; eq != EQ_SHIELD)</a>
<a name="ln1742">        return false;</a>
<a name="ln1743"> </a>
<a name="ln1744">    const mon_inv_type mslot = equip_slot_to_mslot(eq);</a>
<a name="ln1745">    if (mslot == NUM_MONSTER_SLOTS)</a>
<a name="ln1746">        return false;</a>
<a name="ln1747"> </a>
<a name="ln1748">    int value_new = _get_monster_armour_value(this, item);</a>
<a name="ln1749"> </a>
<a name="ln1750">    // No armour yet -&gt; get this one.</a>
<a name="ln1751">    if (!mslot_item(mslot) &amp;&amp; value_new &gt; 0)</a>
<a name="ln1752">        return pickup(item, mslot, msg);</a>
<a name="ln1753"> </a>
<a name="ln1754">    // Simplistic armour evaluation (comparing AC and resistances).</a>
<a name="ln1755">    if (const item_def *existing_armour = slot_item(eq, false))</a>
<a name="ln1756">    {</a>
<a name="ln1757">        if (!force)</a>
<a name="ln1758">        {</a>
<a name="ln1759">            int value_old = _get_monster_armour_value(this,</a>
<a name="ln1760">                                                      *existing_armour);</a>
<a name="ln1761">            if (value_old &gt; value_new)</a>
<a name="ln1762">                return false;</a>
<a name="ln1763"> </a>
<a name="ln1764">            if (value_old == value_new)</a>
<a name="ln1765">            {</a>
<a name="ln1766">                // If items are of the same value, use shopping</a>
<a name="ln1767">                // value as a further crude estimate.</a>
<a name="ln1768">                value_old = item_value(*existing_armour, true);</a>
<a name="ln1769">                value_new = item_value(item, true);</a>
<a name="ln1770">            }</a>
<a name="ln1771">            if (value_old &gt;= value_new)</a>
<a name="ln1772">                return false;</a>
<a name="ln1773">        }</a>
<a name="ln1774"> </a>
<a name="ln1775">        if (!drop_item(mslot, msg))</a>
<a name="ln1776">            return false;</a>
<a name="ln1777">    }</a>
<a name="ln1778"> </a>
<a name="ln1779">    return pickup(item, mslot, msg);</a>
<a name="ln1780">}</a>
<a name="ln1781"> </a>
<a name="ln1782">static int _get_monster_jewellery_value(const monster *mon,</a>
<a name="ln1783">                                   const item_def &amp;item)</a>
<a name="ln1784">{</a>
<a name="ln1785">    ASSERT(item.base_type == OBJ_JEWELLERY);</a>
<a name="ln1786"> </a>
<a name="ln1787">    // Each resistance/property counts as one point.</a>
<a name="ln1788">    int value = 0;</a>
<a name="ln1789"> </a>
<a name="ln1790">    if (item.sub_type == RING_PROTECTION</a>
<a name="ln1791">        || item.sub_type == RING_EVASION</a>
<a name="ln1792">        || item.sub_type == RING_SLAYING</a>
<a name="ln1793">        || item.sub_type == AMU_REFLECTION)</a>
<a name="ln1794">    {</a>
<a name="ln1795">        value += item.plus;</a>
<a name="ln1796">    }</a>
<a name="ln1797"> </a>
<a name="ln1798">    if (item.sub_type == AMU_INACCURACY)</a>
<a name="ln1799">        value -= 5;</a>
<a name="ln1800"> </a>
<a name="ln1801">    value += get_jewellery_res_fire(item, true);</a>
<a name="ln1802">    value += get_jewellery_res_cold(item, true);</a>
<a name="ln1803">    value += get_jewellery_res_elec(item, true);</a>
<a name="ln1804"> </a>
<a name="ln1805">    // Give a simple bonus, no matter the size of the MR bonus.</a>
<a name="ln1806">    if (get_jewellery_res_magic(item, true) &gt; 0)</a>
<a name="ln1807">        value++;</a>
<a name="ln1808"> </a>
<a name="ln1809">    // Poison becomes much less valuable if the monster is</a>
<a name="ln1810">    // intrinsically resistant.</a>
<a name="ln1811">    if (get_mons_resist(*mon, MR_RES_POISON) &lt;= 0)</a>
<a name="ln1812">        value += get_jewellery_res_poison(item, true);</a>
<a name="ln1813"> </a>
<a name="ln1814">    // Same for life protection.</a>
<a name="ln1815">    if (mon-&gt;holiness() &amp; MH_NATURAL)</a>
<a name="ln1816">        value += get_jewellery_life_protection(item, true);</a>
<a name="ln1817"> </a>
<a name="ln1818">    // See invisible also is only useful if not already intrinsic.</a>
<a name="ln1819">    if (!mons_class_flag(mon-&gt;type, M_SEE_INVIS))</a>
<a name="ln1820">        value += get_jewellery_see_invisible(item, true);</a>
<a name="ln1821"> </a>
<a name="ln1822">    // If we're not naturally corrosion-resistant.</a>
<a name="ln1823">    if (item.sub_type == RING_RESIST_CORROSION &amp;&amp; !mon-&gt;res_corr(false, false))</a>
<a name="ln1824">        value++;</a>
<a name="ln1825"> </a>
<a name="ln1826">    return value;</a>
<a name="ln1827">}</a>
<a name="ln1828"> </a>
<a name="ln1829">bool monster::pickup_jewellery(item_def &amp;item, bool msg, bool force)</a>
<a name="ln1830">{</a>
<a name="ln1831">    ASSERT(item.base_type == OBJ_JEWELLERY);</a>
<a name="ln1832"> </a>
<a name="ln1833">    if (!force &amp;&amp; !wants_jewellery(item))</a>
<a name="ln1834">        return false;</a>
<a name="ln1835"> </a>
<a name="ln1836">    equipment_type eq = EQ_RINGS;</a>
<a name="ln1837"> </a>
<a name="ln1838">    const mon_inv_type mslot = equip_slot_to_mslot(eq);</a>
<a name="ln1839">    if (mslot == NUM_MONSTER_SLOTS)</a>
<a name="ln1840">        return false;</a>
<a name="ln1841"> </a>
<a name="ln1842">    int value_new = _get_monster_jewellery_value(this, item);</a>
<a name="ln1843"> </a>
<a name="ln1844">    // No armour yet -&gt; get this one.</a>
<a name="ln1845">    if (!mslot_item(mslot) &amp;&amp; value_new &gt; 0)</a>
<a name="ln1846">        return pickup(item, mslot, msg);</a>
<a name="ln1847"> </a>
<a name="ln1848">    // Simplistic jewellery evaluation (comparing AC and resistances).</a>
<a name="ln1849">    if (const item_def *existing_jewellery = slot_item(eq, false))</a>
<a name="ln1850">    {</a>
<a name="ln1851">        if (!force)</a>
<a name="ln1852">        {</a>
<a name="ln1853">            int value_old = _get_monster_jewellery_value(this,</a>
<a name="ln1854">                                                         *existing_jewellery);</a>
<a name="ln1855">            if (value_old &gt; value_new)</a>
<a name="ln1856">                return false;</a>
<a name="ln1857"> </a>
<a name="ln1858">            if (value_old == value_new)</a>
<a name="ln1859">            {</a>
<a name="ln1860">                // If items are of the same value, use shopping</a>
<a name="ln1861">                // value as a further crude estimate.</a>
<a name="ln1862">                value_old = item_value(*existing_jewellery, true);</a>
<a name="ln1863">                value_new = item_value(item, true);</a>
<a name="ln1864">                if (value_old &gt;= value_new)</a>
<a name="ln1865">                    return false;</a>
<a name="ln1866">            }</a>
<a name="ln1867">        }</a>
<a name="ln1868"> </a>
<a name="ln1869">        if (!drop_item(mslot, msg))</a>
<a name="ln1870">            return false;</a>
<a name="ln1871">    }</a>
<a name="ln1872"> </a>
<a name="ln1873">    return pickup(item, mslot, msg);</a>
<a name="ln1874">}</a>
<a name="ln1875"> </a>
<a name="ln1876">bool monster::pickup_weapon(item_def &amp;item, bool msg, bool force)</a>
<a name="ln1877">{</a>
<a name="ln1878">    if (!force &amp;&amp; !wants_weapon(item))</a>
<a name="ln1879">        return false;</a>
<a name="ln1880"> </a>
<a name="ln1881">    // Weapon pickup involves:</a>
<a name="ln1882">    // - If we have no weapons, always pick this up.</a>
<a name="ln1883">    // - If this is a melee weapon and we already have a melee weapon, pick</a>
<a name="ln1884">    //   it up if it is superior to the one we're carrying (and drop the</a>
<a name="ln1885">    //   one we have).</a>
<a name="ln1886">    // - If it is a ranged weapon, and we already have a ranged weapon,</a>
<a name="ln1887">    //   pick it up if it is better than the one we have.</a>
<a name="ln1888"> </a>
<a name="ln1889">    if (is_range_weapon(item))</a>
<a name="ln1890">        return pickup_launcher(item, msg, force);</a>
<a name="ln1891"> </a>
<a name="ln1892">    if (pickup_melee_weapon(item, msg))</a>
<a name="ln1893">        return true;</a>
<a name="ln1894"> </a>
<a name="ln1895">    return false;</a>
<a name="ln1896">}</a>
<a name="ln1897"> </a>
<a name="ln1898">/**</a>
<a name="ln1899"> * Have a monster pick up a missile item.</a>
<a name="ln1900"> *</a>
<a name="ln1901"> * @param item  The item to pick up.</a>
<a name="ln1902"> * @param msg   Whether to print a message about the pickup.</a>
<a name="ln1903"> * @param force If true, the monster will always try to pick up the item.</a>
<a name="ln1904"> * @return  True if the monster picked up the missile, false otherwise.</a>
<a name="ln1905">*/</a>
<a name="ln1906">bool monster::pickup_missile(item_def &amp;item, bool msg, bool force)</a>
<a name="ln1907">{</a>
<a name="ln1908">    const item_def *miss = missiles();</a>
<a name="ln1909"> </a>
<a name="ln1910">    if (!force)</a>
<a name="ln1911">    {</a>
<a name="ln1912">        if (item.sub_type == MI_THROWING_NET)</a>
<a name="ln1913">        {</a>
<a name="ln1914">            // Monster may not pick up trapping net.</a>
<a name="ln1915">            if (caught() &amp;&amp; item_is_stationary_net(item))</a>
<a name="ln1916">                return false;</a>
<a name="ln1917">        }</a>
<a name="ln1918">        else // None of these exceptions hold for throwing nets.</a>
<a name="ln1919">        {</a>
<a name="ln1920">            // Spellcasters should not waste time with ammunition.</a>
<a name="ln1921">            // Neither summons nor hostile enchantments are counted for</a>
<a name="ln1922">            // this purpose.</a>
<a name="ln1923">            if (!force &amp;&amp; mons_has_ranged_spell(*this, true, false))</a>
<a name="ln1924">                return false;</a>
<a name="ln1925"> </a>
<a name="ln1926">            // Monsters in a fight will only pick up missiles if doing so</a>
<a name="ln1927">            // is worthwhile.</a>
<a name="ln1928">            if (!mons_is_wandering(*this)</a>
<a name="ln1929">                &amp;&amp; foe != MHITYOU</a>
<a name="ln1930">                &amp;&amp; (item.quantity &lt; 5 || miss &amp;&amp; miss-&gt;quantity &gt;= 7))</a>
<a name="ln1931">            {</a>
<a name="ln1932">                return false;</a>
<a name="ln1933">            }</a>
<a name="ln1934">        }</a>
<a name="ln1935">    }</a>
<a name="ln1936"> </a>
<a name="ln1937">    if (miss &amp;&amp; items_stack(*miss, item))</a>
<a name="ln1938">        return pickup(item, MSLOT_MISSILE, msg);</a>
<a name="ln1939"> </a>
<a name="ln1940">    if (!force &amp;&amp; !can_use_missile(item))</a>
<a name="ln1941">        return false;</a>
<a name="ln1942"> </a>
<a name="ln1943">    if (miss)</a>
<a name="ln1944">    {</a>
<a name="ln1945">        item_def *launch;</a>
<a name="ln1946">        for (int i = MSLOT_WEAPON; i &lt;= MSLOT_ALT_WEAPON; ++i)</a>
<a name="ln1947">        {</a>
<a name="ln1948">            launch = mslot_item(static_cast&lt;mon_inv_type&gt;(i));</a>
<a name="ln1949">            if (launch)</a>
<a name="ln1950">            {</a>
<a name="ln1951">                const int item_brand = get_ammo_brand(item);</a>
<a name="ln1952">                // If this ammunition is better, drop the old ones.</a>
<a name="ln1953">                // Don't upgrade to ammunition whose brand cancels the</a>
<a name="ln1954">                // launcher brand or doesn't improve it further.</a>
<a name="ln1955">                // Don't drop huge stacks for tiny stacks.</a>
<a name="ln1956">                if (item.launched_by(*launch)</a>
<a name="ln1957">                    &amp;&amp; (!miss-&gt;launched_by(*launch)</a>
<a name="ln1958">                        || item.sub_type == MI_SLING_BULLET</a>
<a name="ln1959">                           &amp;&amp; miss-&gt;sub_type == MI_STONE</a>
<a name="ln1960">                        || get_ammo_brand(*miss) == SPMSL_NORMAL</a>
<a name="ln1961">                           &amp;&amp; item_brand != SPMSL_NORMAL)</a>
<a name="ln1962">                    &amp;&amp; item.quantity * 2 &gt; miss-&gt;quantity)</a>
<a name="ln1963">                {</a>
<a name="ln1964">                    if (!drop_item(MSLOT_MISSILE, msg))</a>
<a name="ln1965">                        return false;</a>
<a name="ln1966">                    break;</a>
<a name="ln1967">                }</a>
<a name="ln1968">            }</a>
<a name="ln1969">        }</a>
<a name="ln1970"> </a>
<a name="ln1971">        // Allow upgrading throwing weapon brands (XXX: improve this!)</a>
<a name="ln1972">        if (item.sub_type == miss-&gt;sub_type</a>
<a name="ln1973">            &amp;&amp; (item.sub_type == MI_BOOMERANG || item.sub_type == MI_JAVELIN)</a>
<a name="ln1974">            &amp;&amp; get_ammo_brand(*miss) == SPMSL_NORMAL</a>
<a name="ln1975">            &amp;&amp; get_ammo_brand(item) != SPMSL_NORMAL)</a>
<a name="ln1976">        {</a>
<a name="ln1977">            if (!drop_item(MSLOT_MISSILE, msg))</a>
<a name="ln1978">                return false;</a>
<a name="ln1979">        }</a>
<a name="ln1980">    }</a>
<a name="ln1981"> </a>
<a name="ln1982">    return pickup(item, MSLOT_MISSILE, msg);</a>
<a name="ln1983">}</a>
<a name="ln1984"> </a>
<a name="ln1985">bool monster::pickup_wand(item_def &amp;item, bool msg, bool force)</a>
<a name="ln1986">{</a>
<a name="ln1987">    if (!force)</a>
<a name="ln1988">    {</a>
<a name="ln1989">        // Don't pick up empty wands.</a>
<a name="ln1990">        if (item.plus == 0)</a>
<a name="ln1991">            return false;</a>
<a name="ln1992"> </a>
<a name="ln1993">        // Only low-HD monsters bother with wands.</a>
<a name="ln1994">        if (!likes_wand(item))</a>
<a name="ln1995">            return false;</a>
<a name="ln1996"> </a>
<a name="ln1997">        // Holy monsters and worshippers of good gods won't pick up evil</a>
<a name="ln1998">        // wands.</a>
<a name="ln1999">        if ((is_holy() || is_good_god(god)) &amp;&amp; is_evil_item(item))</a>
<a name="ln2000">            return false;</a>
<a name="ln2001">    }</a>
<a name="ln2002"> </a>
<a name="ln2003">    // If a monster already has a charged wand, don't bother.</a>
<a name="ln2004">    // Otherwise, replace with a charged one.</a>
<a name="ln2005">    if (item_def *wand = mslot_item(MSLOT_WAND))</a>
<a name="ln2006">    {</a>
<a name="ln2007">        if (wand-&gt;plus &gt; 0 &amp;&amp; !force)</a>
<a name="ln2008">            return false;</a>
<a name="ln2009"> </a>
<a name="ln2010">        if (!drop_item(MSLOT_WAND, msg))</a>
<a name="ln2011">            return false;</a>
<a name="ln2012">    }</a>
<a name="ln2013"> </a>
<a name="ln2014">    if (pickup(item, MSLOT_WAND, msg))</a>
<a name="ln2015">        return true;</a>
<a name="ln2016">    else</a>
<a name="ln2017">        return false;</a>
<a name="ln2018">}</a>
<a name="ln2019"> </a>
<a name="ln2020">bool monster::pickup_scroll(item_def &amp;item, bool msg)</a>
<a name="ln2021">{</a>
<a name="ln2022">    return pickup(item, MSLOT_SCROLL, msg);</a>
<a name="ln2023">}</a>
<a name="ln2024"> </a>
<a name="ln2025">bool monster::pickup_potion(item_def &amp;item, bool msg, bool force)</a>
<a name="ln2026">{</a>
<a name="ln2027">    if (!can_drink() &amp;&amp; !force)</a>
<a name="ln2028">        return false;</a>
<a name="ln2029">    return pickup(item, MSLOT_POTION, msg);</a>
<a name="ln2030">}</a>
<a name="ln2031"> </a>
<a name="ln2032">bool monster::pickup_gold(item_def &amp;item, bool msg)</a>
<a name="ln2033">{</a>
<a name="ln2034">    return pickup(item, MSLOT_GOLD, msg);</a>
<a name="ln2035">}</a>
<a name="ln2036"> </a>
<a name="ln2037">bool monster::pickup_misc(item_def &amp;item, bool msg, bool force)</a>
<a name="ln2038">{</a>
<a name="ln2039">    // Monsters can't use any miscellaneous items right now, so don't</a>
<a name="ln2040">    // let them pick them up unless explicitly given.</a>
<a name="ln2041">    if (!force)</a>
<a name="ln2042">        return false;</a>
<a name="ln2043">    return pickup(item, MSLOT_MISCELLANY, msg);</a>
<a name="ln2044">}</a>
<a name="ln2045"> </a>
<a name="ln2046">// Eaten items are handled elsewhere, in _handle_pickup() in mon-act.cc.</a>
<a name="ln2047">bool monster::pickup_item(item_def &amp;item, bool msg, bool force)</a>
<a name="ln2048">{</a>
<a name="ln2049">    // Equipping stuff can be forced when initially equipping monsters.</a>
<a name="ln2050">    if (!force)</a>
<a name="ln2051">    {</a>
<a name="ln2052">        // If a monster isn't otherwise occupied (has a foe, is fleeing, etc.)</a>
<a name="ln2053">        // it is considered wandering.</a>
<a name="ln2054">        bool wandering = mons_is_wandering(*this);</a>
<a name="ln2055">        const int itype = item.base_type;</a>
<a name="ln2056"> </a>
<a name="ln2057">        // Weak(ened) monsters won't stop to pick up things as long as they</a>
<a name="ln2058">        // feel unsafe.</a>
<a name="ln2059">        if (!wandering &amp;&amp; (hit_points * 10 &lt; max_hit_points || hit_points &lt; 10)</a>
<a name="ln2060">            &amp;&amp; mon_enemies_around(this))</a>
<a name="ln2061">        {</a>
<a name="ln2062">            return false;</a>
<a name="ln2063">        }</a>
<a name="ln2064">        if (!wandering &amp;&amp; !wont_attack())</a>
<a name="ln2065">        {</a>
<a name="ln2066">            // These are not important enough for pickup when</a>
<a name="ln2067">            // seeking, fleeing etc.</a>
<a name="ln2068">            if (itype == OBJ_ARMOUR || itype == OBJ_CORPSES</a>
<a name="ln2069">                || itype == OBJ_JEWELLERY</a>
<a name="ln2070">                || itype == OBJ_MISCELLANY || itype == OBJ_GOLD)</a>
<a name="ln2071">            {</a>
<a name="ln2072">                return false;</a>
<a name="ln2073">            }</a>
<a name="ln2074"> </a>
<a name="ln2075">            if (itype == OBJ_WEAPONS || itype == OBJ_MISSILES)</a>
<a name="ln2076">            {</a>
<a name="ln2077">                // Fleeing monsters only pick up emergency equipment.</a>
<a name="ln2078">                if (mons_is_fleeing(*this))</a>
<a name="ln2079">                    return false;</a>
<a name="ln2080"> </a>
<a name="ln2081">                // While occupied, hostile monsters won't pick up items</a>
<a name="ln2082">                // dropped or thrown by you. (You might have done that to</a>
<a name="ln2083">                // distract them.)</a>
<a name="ln2084">                if (testbits(item.flags, ISFLAG_DROPPED)</a>
<a name="ln2085">                    || testbits(item.flags, ISFLAG_THROWN))</a>
<a name="ln2086">                {</a>
<a name="ln2087">                    return false;</a>
<a name="ln2088">                }</a>
<a name="ln2089">            }</a>
<a name="ln2090">        }</a>
<a name="ln2091">    }</a>
<a name="ln2092"> </a>
<a name="ln2093">    switch (item.base_type)</a>
<a name="ln2094">    {</a>
<a name="ln2095">    // Pickup some stuff only if WANDERING.</a>
<a name="ln2096">    case OBJ_ARMOUR:</a>
<a name="ln2097">        return pickup_armour(item, msg, force);</a>
<a name="ln2098">    case OBJ_GOLD:</a>
<a name="ln2099">        return pickup_gold(item, msg);</a>
<a name="ln2100">    case OBJ_JEWELLERY:</a>
<a name="ln2101">        return pickup_jewellery(item, msg, force);</a>
<a name="ln2102">    // Fleeing monsters won't pick up these.</a>
<a name="ln2103">    // Hostiles won't pick them up if they were ever dropped/thrown by you.</a>
<a name="ln2104">    case OBJ_STAVES:</a>
<a name="ln2105">    case OBJ_WEAPONS:</a>
<a name="ln2106">        return pickup_weapon(item, msg, force);</a>
<a name="ln2107">    case OBJ_MISSILES:</a>
<a name="ln2108">        return pickup_missile(item, msg, force);</a>
<a name="ln2109">    // Other types can always be picked up</a>
<a name="ln2110">    // (barring other checks depending on subtype, of course).</a>
<a name="ln2111">    case OBJ_WANDS:</a>
<a name="ln2112">        return pickup_wand(item, msg, force);</a>
<a name="ln2113">    case OBJ_SCROLLS:</a>
<a name="ln2114">        return pickup_scroll(item, msg);</a>
<a name="ln2115">    case OBJ_POTIONS:</a>
<a name="ln2116">        return pickup_potion(item, msg, force);</a>
<a name="ln2117">    case OBJ_BOOKS:</a>
<a name="ln2118">    case OBJ_MISCELLANY:</a>
<a name="ln2119">        return pickup_misc(item, msg, force);</a>
<a name="ln2120">    default:</a>
<a name="ln2121">        return false;</a>
<a name="ln2122">    }</a>
<a name="ln2123">}</a>
<a name="ln2124"> </a>
<a name="ln2125">void monster::swap_weapons(maybe_bool maybe_msg)</a>
<a name="ln2126">{</a>
<a name="ln2127">    const bool msg = tobool(maybe_msg, observable());</a>
<a name="ln2128"> </a>
<a name="ln2129">    item_def *weap = mslot_item(MSLOT_WEAPON);</a>
<a name="ln2130">    item_def *alt  = mslot_item(MSLOT_ALT_WEAPON);</a>
<a name="ln2131"> </a>
<a name="ln2132">    if (weap &amp;&amp; !unequip(*weap, msg))</a>
<a name="ln2133">    {</a>
<a name="ln2134">        // Item was cursed.</a>
<a name="ln2135">        // A centaur may randomly decide to not shoot you, but bashing</a>
<a name="ln2136">        // people with a ranged weapon is a dead giveaway.</a>
<a name="ln2137">        if (weap-&gt;cursed() &amp;&amp; you.can_see(*this) &amp;&amp; is_range_weapon(*weap))</a>
<a name="ln2138">            set_ident_flags(*weap, ISFLAG_KNOW_CURSE);</a>
<a name="ln2139">        return;</a>
<a name="ln2140">    }</a>
<a name="ln2141"> </a>
<a name="ln2142">    swap(inv[MSLOT_WEAPON], inv[MSLOT_ALT_WEAPON]);</a>
<a name="ln2143"> </a>
<a name="ln2144">    if (alt &amp;&amp; msg)</a>
<a name="ln2145">        equip_message(*alt);</a>
<a name="ln2146"> </a>
<a name="ln2147">    // Monsters can swap weapons really fast. :-)</a>
<a name="ln2148">    if ((weap || alt) &amp;&amp; speed_increment &gt;= 2)</a>
<a name="ln2149">    {</a>
<a name="ln2150">        if (const monsterentry *entry = find_monsterentry())</a>
<a name="ln2151">            speed_increment -= div_rand_round(entry-&gt;energy_usage.attack, 5);</a>
<a name="ln2152">    }</a>
<a name="ln2153">}</a>
<a name="ln2154"> </a>
<a name="ln2155">void monster::wield_melee_weapon(maybe_bool msg)</a>
<a name="ln2156">{</a>
<a name="ln2157">    const item_def *weap = mslot_item(MSLOT_WEAPON);</a>
<a name="ln2158">    if (!weap || (!weap-&gt;cursed() &amp;&amp; is_range_weapon(*weap)))</a>
<a name="ln2159">    {</a>
<a name="ln2160">        const item_def *alt = mslot_item(MSLOT_ALT_WEAPON);</a>
<a name="ln2161"> </a>
<a name="ln2162">        // Switch to the alternate weapon if it's not a ranged weapon, too,</a>
<a name="ln2163">        // or switch away from our main weapon if it's a ranged weapon.</a>
<a name="ln2164">        if (alt &amp;&amp; !is_range_weapon(*alt)</a>
<a name="ln2165">            || weap &amp;&amp; !alt &amp;&amp; type != MONS_STATUE)</a>
<a name="ln2166">        {</a>
<a name="ln2167">            swap_weapons(msg);</a>
<a name="ln2168">        }</a>
<a name="ln2169">    }</a>
<a name="ln2170">}</a>
<a name="ln2171"> </a>
<a name="ln2172">item_def *monster::slot_item(equipment_type eq, bool /*include_melded*/) const</a>
<a name="ln2173">{</a>
<a name="ln2174">    return mslot_item(equip_slot_to_mslot(eq));</a>
<a name="ln2175">}</a>
<a name="ln2176"> </a>
<a name="ln2177">item_def *monster::mslot_item(mon_inv_type mslot) const</a>
<a name="ln2178">{</a>
<a name="ln2179">    const int mi = (mslot == NUM_MONSTER_SLOTS) ? NON_ITEM : inv[mslot];</a>
<a name="ln2180">    return mi == NON_ITEM ? nullptr : &amp;mitm[mi];</a>
<a name="ln2181">}</a>
<a name="ln2182"> </a>
<a name="ln2183">item_def *monster::shield() const</a>
<a name="ln2184">{</a>
<a name="ln2185">    return mslot_item(MSLOT_SHIELD);</a>
<a name="ln2186">}</a>
<a name="ln2187"> </a>
<a name="ln2188">/**</a>
<a name="ln2189"> * Does this monster have a proper name?</a>
<a name="ln2190"> *</a>
<a name="ln2191"> * @return  Whether the monster has a proper name, e.g. &quot;Rupert&quot; or</a>
<a name="ln2192"> *          &quot;Bogric the orc warlord&quot;. Should not include 'renamed' vault</a>
<a name="ln2193"> *          monsters, e.g. &quot;decayed bog mummy&quot; or &quot;bag of meat&quot;.</a>
<a name="ln2194"> */</a>
<a name="ln2195">bool monster::is_named() const</a>
<a name="ln2196">{</a>
<a name="ln2197">    return mons_is_unique(type)</a>
<a name="ln2198">           || (!mname.empty() &amp;&amp; !testbits(flags, MF_NAME_ADJECTIVE |</a>
<a name="ln2199">                                                  MF_NAME_REPLACE));</a>
<a name="ln2200">}</a>
<a name="ln2201"> </a>
<a name="ln2202">bool monster::has_base_name() const</a>
<a name="ln2203">{</a>
<a name="ln2204">    // Any non-ghost, non-Pandemonium demon that has an explicitly set</a>
<a name="ln2205">    // name has a base name.</a>
<a name="ln2206">    return !mname.empty() &amp;&amp; !ghost;</a>
<a name="ln2207">}</a>
<a name="ln2208"> </a>
<a name="ln2209">static string _invalid_monster_str(monster_type type)</a>
<a name="ln2210">{</a>
<a name="ln2211">    string str = &quot;INVALID MONSTER &quot;;</a>
<a name="ln2212"> </a>
<a name="ln2213">    switch (type)</a>
<a name="ln2214">    {</a>
<a name="ln2215">    case NUM_MONSTERS:</a>
<a name="ln2216">        return str + &quot;NUM_MONSTERS&quot;;</a>
<a name="ln2217">    case MONS_NO_MONSTER:</a>
<a name="ln2218">        return str + &quot;MONS_NO_MONSTER&quot;;</a>
<a name="ln2219">    case MONS_PLAYER:</a>
<a name="ln2220">        return str + &quot;MONS_PLAYER&quot;;</a>
<a name="ln2221">    case RANDOM_DRACONIAN:</a>
<a name="ln2222">        return str + &quot;RANDOM_DRACONIAN&quot;;</a>
<a name="ln2223">    case RANDOM_BASE_DRACONIAN:</a>
<a name="ln2224">        return str + &quot;RANDOM_BASE_DRACONIAN&quot;;</a>
<a name="ln2225">    case RANDOM_NONBASE_DRACONIAN:</a>
<a name="ln2226">        return str + &quot;RANDOM_NONBASE_DRACONIAN&quot;;</a>
<a name="ln2227">    case WANDERING_MONSTER:</a>
<a name="ln2228">        return str + &quot;WANDERING_MONSTER&quot;;</a>
<a name="ln2229">    default:</a>
<a name="ln2230">        break;</a>
<a name="ln2231">    }</a>
<a name="ln2232"> </a>
<a name="ln2233">    str += make_stringf(&quot;#%d&quot;, (int) type);</a>
<a name="ln2234"> </a>
<a name="ln2235">    if (type &lt; 0)</a>
<a name="ln2236">        return str;</a>
<a name="ln2237"> </a>
<a name="ln2238">    if (type &gt; NUM_MONSTERS)</a>
<a name="ln2239">    {</a>
<a name="ln2240">        str += make_stringf(&quot; (NUM_MONSTERS + %d)&quot;,</a>
<a name="ln2241">                            int (NUM_MONSTERS - type));</a>
<a name="ln2242">        return str;</a>
<a name="ln2243">    }</a>
<a name="ln2244"> </a>
<a name="ln2245">    int          i;</a>
<a name="ln2246">    monster_type new_type;</a>
<a name="ln2247">    for (i = 0; true; i++)</a>
<a name="ln2248">    {</a>
<a name="ln2249">        new_type = (monster_type) (((int) type) - i);</a>
<a name="ln2250"> </a>
<a name="ln2251">        if (invalid_monster_type(new_type))</a>
<a name="ln2252">            continue;</a>
<a name="ln2253">        break;</a>
<a name="ln2254">    }</a>
<a name="ln2255">    str += make_stringf(&quot; (%s + %d)&quot;,</a>
<a name="ln2256">                        mons_type_name(new_type, DESC_PLAIN).c_str(),</a>
<a name="ln2257">                        i);</a>
<a name="ln2258"> </a>
<a name="ln2259">    return str;</a>
<a name="ln2260">}</a>
<a name="ln2261"> </a>
<a name="ln2262">static string _mon_special_name(const monster&amp; mon, description_level_type desc,</a>
<a name="ln2263">                                bool force_seen)</a>
<a name="ln2264">{</a>
<a name="ln2265">    if (desc == DESC_NONE)</a>
<a name="ln2266">        return &quot;&quot;;</a>
<a name="ln2267"> </a>
<a name="ln2268">    const bool arena_submerged = crawl_state.game_is_arena() &amp;&amp; !force_seen</a>
<a name="ln2269">                                     &amp;&amp; mon.submerged();</a>
<a name="ln2270"> </a>
<a name="ln2271">    if (mon.type == MONS_NO_MONSTER)</a>
<a name="ln2272">        return &quot;DEAD MONSTER&quot;;</a>
<a name="ln2273">    else if (mon.mid == MID_YOU_FAULTLESS)</a>
<a name="ln2274">        return &quot;INVALID YOU_FAULTLESS&quot;;</a>
<a name="ln2275">    else if (invalid_monster_type(mon.type) &amp;&amp; mon.type != MONS_PROGRAM_BUG)</a>
<a name="ln2276">        return _invalid_monster_str(mon.type);</a>
<a name="ln2277"> </a>
<a name="ln2278">    // Handle non-visible case first.</a>
<a name="ln2279">    if (!force_seen &amp;&amp; !mon.observable() &amp;&amp; !arena_submerged)</a>
<a name="ln2280">    {</a>
<a name="ln2281">        switch (desc)</a>
<a name="ln2282">        {</a>
<a name="ln2283">        case DESC_THE: case DESC_A: case DESC_PLAIN: case DESC_YOUR:</a>
<a name="ln2284">            return &quot;something&quot;;</a>
<a name="ln2285">        case DESC_ITS:</a>
<a name="ln2286">            return &quot;something's&quot;;</a>
<a name="ln2287">        default:</a>
<a name="ln2288">            return &quot;it (buggy)&quot;;</a>
<a name="ln2289">        }</a>
<a name="ln2290">    }</a>
<a name="ln2291"> </a>
<a name="ln2292">    if (desc == DESC_DBNAME)</a>
<a name="ln2293">    {</a>
<a name="ln2294">        monster_info mi(&amp;mon, MILEV_NAME);</a>
<a name="ln2295">        return mi.db_name();</a>
<a name="ln2296">    }</a>
<a name="ln2297"> </a>
<a name="ln2298">    return &quot;&quot;;</a>
<a name="ln2299">}</a>
<a name="ln2300"> </a>
<a name="ln2301">string monster::name(description_level_type desc, bool force_vis,</a>
<a name="ln2302">                     bool force_article) const</a>
<a name="ln2303">{</a>
<a name="ln2304">    string s = _mon_special_name(*this, desc, force_vis);</a>
<a name="ln2305">    if (!s.empty() || desc == DESC_NONE)</a>
<a name="ln2306">        return s;</a>
<a name="ln2307"> </a>
<a name="ln2308">    monster_info mi(this, MILEV_NAME);</a>
<a name="ln2309">    // i.e. to produce &quot;the Maras&quot; instead of just &quot;Maras&quot;</a>
<a name="ln2310">    if (force_article)</a>
<a name="ln2311">        mi.mb.set(MB_NAME_UNQUALIFIED, false);</a>
<a name="ln2312">    return mi.proper_name(desc)</a>
<a name="ln2313">#ifdef DEBUG_MONINDEX</a>
<a name="ln2314">    // This is incredibly spammy, too bad for regular debug builds, but</a>
<a name="ln2315">    // I keep re-adding this over and over during debugging.</a>
<a name="ln2316">           + (Options.quiet_debug_messages[DIAG_MONINDEX]</a>
<a name="ln2317">              ? string()</a>
<a name="ln2318">              : make_stringf(&quot;«%d:%d»&quot;, mindex(), mid))</a>
<a name="ln2319">#endif</a>
<a name="ln2320">    ;</a>
<a name="ln2321">}</a>
<a name="ln2322"> </a>
<a name="ln2323">string monster::base_name(description_level_type desc, bool force_vis) const</a>
<a name="ln2324">{</a>
<a name="ln2325">    string s = _mon_special_name(*this, desc, force_vis);</a>
<a name="ln2326">    if (!s.empty() || desc == DESC_NONE)</a>
<a name="ln2327">        return s;</a>
<a name="ln2328"> </a>
<a name="ln2329">    monster_info mi(this, MILEV_NAME);</a>
<a name="ln2330">    return mi.common_name(desc);</a>
<a name="ln2331">}</a>
<a name="ln2332"> </a>
<a name="ln2333">string monster::full_name(description_level_type desc) const</a>
<a name="ln2334">{</a>
<a name="ln2335">    string s = _mon_special_name(*this, desc, true);</a>
<a name="ln2336">    if (!s.empty() || desc == DESC_NONE)</a>
<a name="ln2337">        return s;</a>
<a name="ln2338"> </a>
<a name="ln2339">    monster_info mi(this, MILEV_NAME);</a>
<a name="ln2340">    return mi.full_name(desc);</a>
<a name="ln2341">}</a>
<a name="ln2342"> </a>
<a name="ln2343">string monster::pronoun(pronoun_type pro, bool force_visible) const</a>
<a name="ln2344">{</a>
<a name="ln2345">    const bool seen = force_visible || you.can_see(*this);</a>
<a name="ln2346">    if (seen &amp;&amp; props.exists(MON_GENDER_KEY))</a>
<a name="ln2347">    {</a>
<a name="ln2348">        return decline_pronoun((gender_type)props[MON_GENDER_KEY].get_int(),</a>
<a name="ln2349">                               pro);</a>
<a name="ln2350">    }</a>
<a name="ln2351">    return mons_pronoun(type, pro, seen);</a>
<a name="ln2352">}</a>
<a name="ln2353"> </a>
<a name="ln2354">bool monster::pronoun_plurality(bool force_visible) const</a>
<a name="ln2355">{</a>
<a name="ln2356">    const bool seen = force_visible || you.can_see(*this);</a>
<a name="ln2357">    if (seen &amp;&amp; props.exists(MON_GENDER_KEY))</a>
<a name="ln2358">        return props[MON_GENDER_KEY].get_int() == GENDER_NEUTRAL;</a>
<a name="ln2359"> </a>
<a name="ln2360">    return seen &amp;&amp; mons_class_gender(type) == GENDER_NEUTRAL;</a>
<a name="ln2361">}</a>
<a name="ln2362"> </a>
<a name="ln2363">string monster::conj_verb(const string &amp;verb) const</a>
<a name="ln2364">{</a>
<a name="ln2365">    return conjugate_verb(verb, false);</a>
<a name="ln2366">}</a>
<a name="ln2367"> </a>
<a name="ln2368">string monster::hand_name(bool plural, bool *can_plural) const</a>
<a name="ln2369">{</a>
<a name="ln2370">    bool _can_plural;</a>
<a name="ln2371">    if (can_plural == nullptr)</a>
<a name="ln2372">        can_plural = &amp;_can_plural;</a>
<a name="ln2373">    *can_plural = true;</a>
<a name="ln2374"> </a>
<a name="ln2375">    string str;</a>
<a name="ln2376">    char        ch = mons_base_char(type);</a>
<a name="ln2377"> </a>
<a name="ln2378">    const bool rand = (type == MONS_CHAOS_SPAWN);</a>
<a name="ln2379"> </a>
<a name="ln2380">    switch (get_mon_shape(*this))</a>
<a name="ln2381">    {</a>
<a name="ln2382">    case MON_SHAPE_CENTAUR:</a>
<a name="ln2383">    case MON_SHAPE_NAGA:</a>
<a name="ln2384">        // Defaults to &quot;hand&quot;</a>
<a name="ln2385">        break;</a>
<a name="ln2386">    case MON_SHAPE_HUMANOID:</a>
<a name="ln2387">    case MON_SHAPE_HUMANOID_WINGED:</a>
<a name="ln2388">    case MON_SHAPE_HUMANOID_TAILED:</a>
<a name="ln2389">    case MON_SHAPE_HUMANOID_WINGED_TAILED:</a>
<a name="ln2390">        if (ch == 'T' || ch == 'd' || ch == 'n' || mons_is_demon(type))</a>
<a name="ln2391">            str = &quot;claw&quot;;</a>
<a name="ln2392">        break;</a>
<a name="ln2393"> </a>
<a name="ln2394">    case MON_SHAPE_QUADRUPED:</a>
<a name="ln2395">    case MON_SHAPE_QUADRUPED_TAILLESS:</a>
<a name="ln2396">    case MON_SHAPE_QUADRUPED_WINGED:</a>
<a name="ln2397">    case MON_SHAPE_ARACHNID:</a>
<a name="ln2398">        if (mons_genus(type) == MONS_SCORPION || rand &amp;&amp; one_chance_in(4))</a>
<a name="ln2399">            str = &quot;pincer&quot;;</a>
<a name="ln2400">        else</a>
<a name="ln2401">        {</a>
<a name="ln2402">            str = &quot;front &quot;;</a>
<a name="ln2403">            return str + foot_name(plural, can_plural);</a>
<a name="ln2404">        }</a>
<a name="ln2405">        break;</a>
<a name="ln2406"> </a>
<a name="ln2407">    case MON_SHAPE_BLOB:</a>
<a name="ln2408">    case MON_SHAPE_SNAKE:</a>
<a name="ln2409">    case MON_SHAPE_FISH:</a>
<a name="ln2410">        return foot_name(plural, can_plural);</a>
<a name="ln2411"> </a>
<a name="ln2412">    case MON_SHAPE_BAT:</a>
<a name="ln2413">    case MON_SHAPE_BIRD:</a>
<a name="ln2414">        str = &quot;wing&quot;;</a>
<a name="ln2415">        break;</a>
<a name="ln2416"> </a>
<a name="ln2417">    case MON_SHAPE_INSECT:</a>
<a name="ln2418">    case MON_SHAPE_INSECT_WINGED:</a>
<a name="ln2419">    case MON_SHAPE_CENTIPEDE:</a>
<a name="ln2420">        str = &quot;antenna&quot;;</a>
<a name="ln2421">        break;</a>
<a name="ln2422"> </a>
<a name="ln2423">    case MON_SHAPE_SNAIL:</a>
<a name="ln2424">        str = &quot;eye-stalk&quot;;</a>
<a name="ln2425">        break;</a>
<a name="ln2426"> </a>
<a name="ln2427">    case MON_SHAPE_PLANT:</a>
<a name="ln2428">        str = &quot;leaf&quot;;</a>
<a name="ln2429">        break;</a>
<a name="ln2430"> </a>
<a name="ln2431">    case MON_SHAPE_MISC:</a>
<a name="ln2432">        if (ch == 'x' || ch == 'X' || rand)</a>
<a name="ln2433">        {</a>
<a name="ln2434">            str = &quot;tentacle&quot;;</a>
<a name="ln2435">            break;</a>
<a name="ln2436">        }</a>
<a name="ln2437">        // Deliberate fallthrough.</a>
<a name="ln2438">    case MON_SHAPE_FUNGUS:</a>
<a name="ln2439">        str         = &quot;body&quot;;</a>
<a name="ln2440">        *can_plural = false;</a>
<a name="ln2441">        break;</a>
<a name="ln2442"> </a>
<a name="ln2443">    case MON_SHAPE_ORB:</a>
<a name="ln2444">        switch (type)</a>
<a name="ln2445">        {</a>
<a name="ln2446">            case MONS_BALLISTOMYCETE_SPORE:</a>
<a name="ln2447">                str = &quot;rhizome&quot;;</a>
<a name="ln2448">                break;</a>
<a name="ln2449"> </a>
<a name="ln2450">            case MONS_FLOATING_EYE:</a>
<a name="ln2451">            case MONS_EYE_OF_DRAINING:</a>
<a name="ln2452">            case MONS_SHINING_EYE:</a>
<a name="ln2453">            case MONS_EYE_OF_DEVASTATION:</a>
<a name="ln2454">            case MONS_GOLDEN_EYE:</a>
<a name="ln2455">                *can_plural = false;</a>
<a name="ln2456">                // Deliberate fallthrough.</a>
<a name="ln2457">            case MONS_GREAT_ORB_OF_EYES:</a>
<a name="ln2458">                str = &quot;pupil&quot;;</a>
<a name="ln2459">                break;</a>
<a name="ln2460"> </a>
<a name="ln2461">            case MONS_GLOWING_ORANGE_BRAIN:</a>
<a name="ln2462">            default:</a>
<a name="ln2463">                if (rand)</a>
<a name="ln2464">                    str = &quot;rhizome&quot;;</a>
<a name="ln2465">                else</a>
<a name="ln2466">                {</a>
<a name="ln2467">                    str        = &quot;body&quot;;</a>
<a name="ln2468">                    *can_plural = false;</a>
<a name="ln2469">                }</a>
<a name="ln2470">                break;</a>
<a name="ln2471">        }</a>
<a name="ln2472">        break;</a>
<a name="ln2473"> </a>
<a name="ln2474">    case MON_SHAPE_BUGGY:</a>
<a name="ln2475">        str = &quot;handbug&quot;;</a>
<a name="ln2476">        break;</a>
<a name="ln2477">    }</a>
<a name="ln2478"> </a>
<a name="ln2479">    if (str.empty())</a>
<a name="ln2480">    {</a>
<a name="ln2481">        // Reduce the chance of a random-shaped monster having hands.</a>
<a name="ln2482">        if (rand &amp;&amp; coinflip())</a>
<a name="ln2483">            return hand_name(plural, can_plural);</a>
<a name="ln2484"> </a>
<a name="ln2485">        str = &quot;hand&quot;;</a>
<a name="ln2486">    }</a>
<a name="ln2487"> </a>
<a name="ln2488">    if (plural &amp;&amp; *can_plural)</a>
<a name="ln2489">        str = pluralise(str);</a>
<a name="ln2490"> </a>
<a name="ln2491">    return str;</a>
<a name="ln2492">}</a>
<a name="ln2493"> </a>
<a name="ln2494">string monster::foot_name(bool plural, bool *can_plural) const</a>
<a name="ln2495">{</a>
<a name="ln2496">    bool _can_plural;</a>
<a name="ln2497">    if (can_plural == nullptr)</a>
<a name="ln2498">        can_plural = &amp;_can_plural;</a>
<a name="ln2499">    *can_plural = true;</a>
<a name="ln2500"> </a>
<a name="ln2501">    string str;</a>
<a name="ln2502">    char        ch = mons_base_char(type);</a>
<a name="ln2503"> </a>
<a name="ln2504">    const bool rand = (type == MONS_CHAOS_SPAWN);</a>
<a name="ln2505"> </a>
<a name="ln2506">    switch (get_mon_shape(*this))</a>
<a name="ln2507">    {</a>
<a name="ln2508">    case MON_SHAPE_INSECT:</a>
<a name="ln2509">    case MON_SHAPE_INSECT_WINGED:</a>
<a name="ln2510">    case MON_SHAPE_ARACHNID:</a>
<a name="ln2511">    case MON_SHAPE_CENTIPEDE:</a>
<a name="ln2512">        str = &quot;leg&quot;;</a>
<a name="ln2513">        break;</a>
<a name="ln2514"> </a>
<a name="ln2515">    case MON_SHAPE_HUMANOID:</a>
<a name="ln2516">    case MON_SHAPE_HUMANOID_WINGED:</a>
<a name="ln2517">    case MON_SHAPE_HUMANOID_TAILED:</a>
<a name="ln2518">    case MON_SHAPE_HUMANOID_WINGED_TAILED:</a>
<a name="ln2519">        if (type == MONS_MINOTAUR)</a>
<a name="ln2520">            str = &quot;hoof&quot;;</a>
<a name="ln2521">        else if (swimming() &amp;&amp; mons_genus(type) == MONS_MERFOLK)</a>
<a name="ln2522">        {</a>
<a name="ln2523">            str         = &quot;tail&quot;;</a>
<a name="ln2524">            *can_plural = false;</a>
<a name="ln2525">        }</a>
<a name="ln2526">        break;</a>
<a name="ln2527"> </a>
<a name="ln2528">    case MON_SHAPE_CENTAUR:</a>
<a name="ln2529">        str = &quot;hoof&quot;;</a>
<a name="ln2530">        break;</a>
<a name="ln2531"> </a>
<a name="ln2532">    case MON_SHAPE_QUADRUPED:</a>
<a name="ln2533">    case MON_SHAPE_QUADRUPED_TAILLESS:</a>
<a name="ln2534">    case MON_SHAPE_QUADRUPED_WINGED:</a>
<a name="ln2535">        if (rand)</a>
<a name="ln2536">        {</a>
<a name="ln2537">            const char* feet[] = {&quot;paw&quot;, &quot;talon&quot;, &quot;hoof&quot;};</a>
<a name="ln2538">            str = RANDOM_ELEMENT(feet);</a>
<a name="ln2539">        }</a>
<a name="ln2540">        else if (mons_genus(type) == MONS_HOG)</a>
<a name="ln2541">            str = &quot;trotter&quot;;</a>
<a name="ln2542">        else if (ch == 'h')</a>
<a name="ln2543">            str = &quot;paw&quot;;</a>
<a name="ln2544">        else if (ch == 'l' || ch == 'D')</a>
<a name="ln2545">            str = &quot;talon&quot;;</a>
<a name="ln2546">        else if (type == MONS_YAK || type == MONS_DEATH_YAK)</a>
<a name="ln2547">            str = &quot;hoof&quot;;</a>
<a name="ln2548">        else if (ch == 'H')</a>
<a name="ln2549">        {</a>
<a name="ln2550">            if (type == MONS_MANTICORE || type == MONS_SPHINX)</a>
<a name="ln2551">                str = &quot;paw&quot;;</a>
<a name="ln2552">            else</a>
<a name="ln2553">                str = &quot;talon&quot;;</a>
<a name="ln2554">        }</a>
<a name="ln2555">        break;</a>
<a name="ln2556"> </a>
<a name="ln2557">    case MON_SHAPE_BIRD:</a>
<a name="ln2558">        str = &quot;talon&quot;;</a>
<a name="ln2559">        break;</a>
<a name="ln2560"> </a>
<a name="ln2561">    case MON_SHAPE_BAT:</a>
<a name="ln2562">        str = &quot;claw&quot;;</a>
<a name="ln2563">        break;</a>
<a name="ln2564"> </a>
<a name="ln2565">    case MON_SHAPE_SNAKE:</a>
<a name="ln2566">    case MON_SHAPE_FISH:</a>
<a name="ln2567">        str         = &quot;tail&quot;;</a>
<a name="ln2568">        *can_plural = false;</a>
<a name="ln2569">        break;</a>
<a name="ln2570"> </a>
<a name="ln2571">    case MON_SHAPE_PLANT:</a>
<a name="ln2572">        str = &quot;root&quot;;</a>
<a name="ln2573">        break;</a>
<a name="ln2574"> </a>
<a name="ln2575">    case MON_SHAPE_FUNGUS:</a>
<a name="ln2576">        str         = &quot;stem&quot;;</a>
<a name="ln2577">        *can_plural = false;</a>
<a name="ln2578">        break;</a>
<a name="ln2579"> </a>
<a name="ln2580">    case MON_SHAPE_BLOB:</a>
<a name="ln2581">        str = &quot;pseudopod&quot;;</a>
<a name="ln2582">        break;</a>
<a name="ln2583"> </a>
<a name="ln2584">    case MON_SHAPE_MISC:</a>
<a name="ln2585">        if (ch == 'x' || ch == 'X' || rand)</a>
<a name="ln2586">        {</a>
<a name="ln2587">            str = &quot;tentacle&quot;;</a>
<a name="ln2588">            break;</a>
<a name="ln2589">        }</a>
<a name="ln2590">        // Deliberate fallthrough.</a>
<a name="ln2591">    case MON_SHAPE_SNAIL:</a>
<a name="ln2592">    case MON_SHAPE_NAGA:</a>
<a name="ln2593">    case MON_SHAPE_ORB:</a>
<a name="ln2594">        str         = &quot;underside&quot;;</a>
<a name="ln2595">        *can_plural = false;</a>
<a name="ln2596">        break;</a>
<a name="ln2597"> </a>
<a name="ln2598">    case MON_SHAPE_BUGGY:</a>
<a name="ln2599">        str = &quot;footbug&quot;;</a>
<a name="ln2600">        break;</a>
<a name="ln2601">    }</a>
<a name="ln2602"> </a>
<a name="ln2603">    if (str.empty())</a>
<a name="ln2604">    {</a>
<a name="ln2605">        // Reduce the chance of a random-shaped monster having feet.</a>
<a name="ln2606">        if (rand &amp;&amp; coinflip())</a>
<a name="ln2607">            return foot_name(plural, can_plural);</a>
<a name="ln2608"> </a>
<a name="ln2609">        return plural ? &quot;feet&quot; : &quot;foot&quot;;</a>
<a name="ln2610">    }</a>
<a name="ln2611"> </a>
<a name="ln2612">    if (plural &amp;&amp; *can_plural)</a>
<a name="ln2613">        str = pluralise(str);</a>
<a name="ln2614"> </a>
<a name="ln2615">    return str;</a>
<a name="ln2616">}</a>
<a name="ln2617"> </a>
<a name="ln2618">string monster::arm_name(bool plural, bool *can_plural) const</a>
<a name="ln2619">{</a>
<a name="ln2620">    mon_body_shape shape = get_mon_shape(*this);</a>
<a name="ln2621"> </a>
<a name="ln2622">    if (!mon_shape_is_humanoid(shape))</a>
<a name="ln2623">        return hand_name(plural, can_plural);</a>
<a name="ln2624"> </a>
<a name="ln2625">    if (can_plural != nullptr)</a>
<a name="ln2626">        *can_plural = true;</a>
<a name="ln2627"> </a>
<a name="ln2628">    string adj;</a>
<a name="ln2629">    string str = &quot;arm&quot;;</a>
<a name="ln2630"> </a>
<a name="ln2631">    switch (mons_genus(type))</a>
<a name="ln2632">    {</a>
<a name="ln2633">    case MONS_DRACONIAN:</a>
<a name="ln2634">    case MONS_NAGA:</a>
<a name="ln2635">        adj = &quot;scaled&quot;;</a>
<a name="ln2636">        break;</a>
<a name="ln2637"> </a>
<a name="ln2638">    case MONS_TENGU:</a>
<a name="ln2639">        adj = &quot;feathered&quot;;</a>
<a name="ln2640">        break;</a>
<a name="ln2641"> </a>
<a name="ln2642">    case MONS_MUMMY:</a>
<a name="ln2643">        adj = &quot;bandage-wrapped&quot;;</a>
<a name="ln2644">        break;</a>
<a name="ln2645"> </a>
<a name="ln2646">    case MONS_OCTOPODE:</a>
<a name="ln2647">        str = &quot;tentacle&quot;;</a>
<a name="ln2648">        break;</a>
<a name="ln2649"> </a>
<a name="ln2650">    case MONS_LICH:</a>
<a name="ln2651">    case MONS_SKELETAL_WARRIOR:</a>
<a name="ln2652">    case MONS_ANCIENT_CHAMPION:</a>
<a name="ln2653">    case MONS_REVENANT:</a>
<a name="ln2654">        adj = &quot;bony&quot;;</a>
<a name="ln2655">        break;</a>
<a name="ln2656"> </a>
<a name="ln2657">    default:</a>
<a name="ln2658">        break;</a>
<a name="ln2659">    }</a>
<a name="ln2660"> </a>
<a name="ln2661">    if (!adj.empty())</a>
<a name="ln2662">        str = adj + &quot; &quot; + str;</a>
<a name="ln2663"> </a>
<a name="ln2664">    if (plural)</a>
<a name="ln2665">        str = pluralise(str);</a>
<a name="ln2666"> </a>
<a name="ln2667">    return str;</a>
<a name="ln2668">}</a>
<a name="ln2669"> </a>
<a name="ln2670">int monster::mindex() const</a>
<a name="ln2671">{</a>
<a name="ln2672">    return this - menv.buffer();</a>
<a name="ln2673">}</a>
<a name="ln2674"> </a>
<a name="ln2675">/**</a>
<a name="ln2676"> * Sets the monster's &quot;hit dice&quot;. Doesn't currently handle adjusting HP, etc.</a>
<a name="ln2677"> *</a>
<a name="ln2678"> * @param new_hit_dice      The new value to set HD to.</a>
<a name="ln2679"> */</a>
<a name="ln2680">void monster::set_hit_dice(int new_hit_dice)</a>
<a name="ln2681">{</a>
<a name="ln2682">    hit_dice = new_hit_dice;</a>
<a name="ln2683"> </a>
<a name="ln2684">    // XXX: this is unbelievably hacky to preserve old behaviour</a>
<a name="ln2685">    if (type == MONS_OKLOB_PLANT &amp;&amp; !spells.empty()</a>
<a name="ln2686">        &amp;&amp; spells[0].spell == SPELL_SPIT_ACID)</a>
<a name="ln2687">    {</a>
<a name="ln2688">        spells[0].freq = 200 * hit_dice / 30;</a>
<a name="ln2689">    }</a>
<a name="ln2690">}</a>
<a name="ln2691"> </a>
<a name="ln2692">void monster::set_position(const coord_def &amp;c)</a>
<a name="ln2693">{</a>
<a name="ln2694">    if (mons_is_projectile(*this))</a>
<a name="ln2695">    {</a>
<a name="ln2696">        // Assume some means of displacement, normal moves will overwrite this.</a>
<a name="ln2697">        props[IOOD_X].get_float() += c.x - pos().x;</a>
<a name="ln2698">        props[IOOD_Y].get_float() += c.y - pos().y;</a>
<a name="ln2699">    }</a>
<a name="ln2700"> </a>
<a name="ln2701">    actor::set_position(c);</a>
<a name="ln2702">}</a>
<a name="ln2703"> </a>
<a name="ln2704">void monster::moveto(const coord_def&amp; c, bool clear_net)</a>
<a name="ln2705">{</a>
<a name="ln2706">    if (clear_net &amp;&amp; c != pos() &amp;&amp; in_bounds(pos()))</a>
<a name="ln2707">        mons_clear_trapping_net(this);</a>
<a name="ln2708"> </a>
<a name="ln2709">    set_position(c);</a>
<a name="ln2710"> </a>
<a name="ln2711">    // Do constriction invalidation after to the move, so that all LOS checking</a>
<a name="ln2712">    // is available.</a>
<a name="ln2713">    clear_invalid_constrictions(true);</a>
<a name="ln2714">}</a>
<a name="ln2715"> </a>
<a name="ln2716">bool monster::fumbles_attack()</a>
<a name="ln2717">{</a>
<a name="ln2718">    if (floundering() &amp;&amp; one_chance_in(4))</a>
<a name="ln2719">    {</a>
<a name="ln2720">        if (you.can_see(*this))</a>
<a name="ln2721">        {</a>
<a name="ln2722">            mprf(&quot;%s %s&quot;, name(DESC_THE).c_str(), liquefied(pos())</a>
<a name="ln2723">                 ? &quot;becomes momentarily stuck in the liquid earth.&quot;</a>
<a name="ln2724">                 : grd(pos()) == DNGN_TOXIC_BOG</a>
<a name="ln2725">                 ? &quot;becomes momentarily stuck in the toxic bog.&quot;</a>
<a name="ln2726">                 : &quot;splashes around in the water.&quot;);</a>
<a name="ln2727">        }</a>
<a name="ln2728">        else if (player_can_hear(pos(), LOS_RADIUS))</a>
<a name="ln2729">            mprf(MSGCH_SOUND, &quot;You hear a splashing noise.&quot;);</a>
<a name="ln2730"> </a>
<a name="ln2731">        return true;</a>
<a name="ln2732">    }</a>
<a name="ln2733"> </a>
<a name="ln2734">    if (submerged())</a>
<a name="ln2735">        return true;</a>
<a name="ln2736"> </a>
<a name="ln2737">    return false;</a>
<a name="ln2738">}</a>
<a name="ln2739"> </a>
<a name="ln2740">void monster::attacking(actor * /* other */, bool /* ranged */)</a>
<a name="ln2741">{</a>
<a name="ln2742">}</a>
<a name="ln2743"> </a>
<a name="ln2744">// Sends a monster into a frenzy.</a>
<a name="ln2745">bool monster::go_frenzy(actor *source)</a>
<a name="ln2746">{</a>
<a name="ln2747">    if (!can_go_frenzy())</a>
<a name="ln2748">        return false;</a>
<a name="ln2749"> </a>
<a name="ln2750">    if (has_ench(ENCH_SLOW))</a>
<a name="ln2751">    {</a>
<a name="ln2752">        del_ench(ENCH_SLOW, true); // Give no additional message.</a>
<a name="ln2753">        simple_monster_message(*this,</a>
<a name="ln2754">            make_stringf(&quot; shakes off %s lethargy.&quot;,</a>
<a name="ln2755">                         pronoun(PRONOUN_POSSESSIVE).c_str()).c_str());</a>
<a name="ln2756">    }</a>
<a name="ln2757">    del_ench(ENCH_HASTE, true);</a>
<a name="ln2758">    del_ench(ENCH_FATIGUE, true); // Give no additional message.</a>
<a name="ln2759"> </a>
<a name="ln2760">    const int duration = 16 + random2avg(13, 2);</a>
<a name="ln2761"> </a>
<a name="ln2762">    add_ench(mon_enchant(ENCH_INSANE, 0, source, duration * BASELINE_DELAY));</a>
<a name="ln2763">    if (holiness() &amp; MH_NATURAL)</a>
<a name="ln2764">    {</a>
<a name="ln2765">        add_ench(mon_enchant(ENCH_HASTE, 0, source, duration * BASELINE_DELAY));</a>
<a name="ln2766">        add_ench(mon_enchant(ENCH_MIGHT, 0, source, duration * BASELINE_DELAY));</a>
<a name="ln2767">    }</a>
<a name="ln2768">    mons_att_changed(this);</a>
<a name="ln2769"> </a>
<a name="ln2770">    if (simple_monster_message(*this, &quot; flies into a frenzy!&quot;))</a>
<a name="ln2771">        // Xom likes monsters going insane.</a>
<a name="ln2772">        xom_is_stimulated(friendly() ? 25 : 100);</a>
<a name="ln2773"> </a>
<a name="ln2774">    return true;</a>
<a name="ln2775">}</a>
<a name="ln2776"> </a>
<a name="ln2777">bool monster::go_berserk(bool intentional, bool /* potion */)</a>
<a name="ln2778">{</a>
<a name="ln2779">    if (!can_go_berserk())</a>
<a name="ln2780">        return false;</a>
<a name="ln2781"> </a>
<a name="ln2782">    if (stasis())</a>
<a name="ln2783">        return false;</a>
<a name="ln2784"> </a>
<a name="ln2785">    if (has_ench(ENCH_SLOW))</a>
<a name="ln2786">    {</a>
<a name="ln2787">        del_ench(ENCH_SLOW, true); // Give no additional message.</a>
<a name="ln2788">        simple_monster_message(*this,</a>
<a name="ln2789">            make_stringf(&quot; shakes off %s lethargy.&quot;,</a>
<a name="ln2790">                         pronoun(PRONOUN_POSSESSIVE).c_str()).c_str());</a>
<a name="ln2791">    }</a>
<a name="ln2792">    del_ench(ENCH_FATIGUE, true); // Give no additional message.</a>
<a name="ln2793">    del_ench(ENCH_FEAR, true);    // Going berserk breaks fear.</a>
<a name="ln2794">    behaviour = BEH_SEEK;</a>
<a name="ln2795"> </a>
<a name="ln2796">    // If we're intentionally berserking, use a melee weapon;</a>
<a name="ln2797">    // we won't be able to swap afterwards.</a>
<a name="ln2798">    if (intentional)</a>
<a name="ln2799">        wield_melee_weapon();</a>
<a name="ln2800"> </a>
<a name="ln2801">    add_ench(ENCH_BERSERK);</a>
<a name="ln2802">    if (simple_monster_message(*this, &quot; goes berserk!&quot;))</a>
<a name="ln2803">        // Xom likes monsters going berserk.</a>
<a name="ln2804">        xom_is_stimulated(friendly() ? 25 : 100);</a>
<a name="ln2805"> </a>
<a name="ln2806">    if (const item_def* w = weapon())</a>
<a name="ln2807">    {</a>
<a name="ln2808">        if (is_unrandom_artefact(*w, UNRAND_ZEALOT_SWORD))</a>
<a name="ln2809">            for (actor_near_iterator mi(pos(), LOS_NO_TRANS); mi; ++mi)</a>
<a name="ln2810">                if (mons_aligned(this, *mi))</a>
<a name="ln2811">                    mi-&gt;go_berserk(false);</a>
<a name="ln2812">    }</a>
<a name="ln2813"> </a>
<a name="ln2814">    return true;</a>
<a name="ln2815">}</a>
<a name="ln2816"> </a>
<a name="ln2817">void monster::expose_to_element(beam_type flavour, int strength,</a>
<a name="ln2818">                                bool slow_cold_blood)</a>
<a name="ln2819">{</a>
<a name="ln2820">    switch (flavour)</a>
<a name="ln2821">    {</a>
<a name="ln2822">    case BEAM_COLD:</a>
<a name="ln2823">        if (slow_cold_blood &amp;&amp; mons_class_flag(type, M_COLD_BLOOD)</a>
<a name="ln2824">            &amp;&amp; res_cold() &lt;= 0 &amp;&amp; coinflip())</a>
<a name="ln2825">        {</a>
<a name="ln2826">            do_slow_monster(*this, this, (strength + random2(5)) * BASELINE_DELAY);</a>
<a name="ln2827">        }</a>
<a name="ln2828">        break;</a>
<a name="ln2829">    case BEAM_WATER:</a>
<a name="ln2830">        del_ench(ENCH_STICKY_FLAME);</a>
<a name="ln2831">        break;</a>
<a name="ln2832">    case BEAM_FIRE:</a>
<a name="ln2833">    case BEAM_LAVA:</a>
<a name="ln2834">    case BEAM_STICKY_FLAME:</a>
<a name="ln2835">    case BEAM_STEAM:</a>
<a name="ln2836">        if (has_ench(ENCH_OZOCUBUS_ARMOUR))</a>
<a name="ln2837">        {</a>
<a name="ln2838">            // The 10 here is from expose_player_to_element.</a>
<a name="ln2839">            const int amount = strength ? strength : 10;</a>
<a name="ln2840">            if (!lose_ench_levels(get_ench(ENCH_OZOCUBUS_ARMOUR),</a>
<a name="ln2841">                                  amount * BASELINE_DELAY, true)</a>
<a name="ln2842">                &amp;&amp; you.can_see(*this))</a>
<a name="ln2843">            {</a>
<a name="ln2844">                mprf(&quot;The heat melts %s icy armour.&quot;,</a>
<a name="ln2845">                     apostrophise(name(DESC_THE)).c_str());</a>
<a name="ln2846">            }</a>
<a name="ln2847">        }</a>
<a name="ln2848">        if (has_ench(ENCH_ICEMAIL))</a>
<a name="ln2849">            del_ench(ENCH_ICEMAIL);</a>
<a name="ln2850">        break;</a>
<a name="ln2851">    default:</a>
<a name="ln2852">        break;</a>
<a name="ln2853">    }</a>
<a name="ln2854">}</a>
<a name="ln2855"> </a>
<a name="ln2856">void monster::banish(actor *agent, const string &amp;, const int, bool force)</a>
<a name="ln2857">{</a>
<a name="ln2858">    coord_def old_pos = pos();</a>
<a name="ln2859"> </a>
<a name="ln2860">    if (mons_is_projectile(type))</a>
<a name="ln2861">        return;</a>
<a name="ln2862"> </a>
<a name="ln2863">    if (!force &amp;&amp; player_in_branch(BRANCH_ABYSS)</a>
<a name="ln2864">        &amp;&amp; x_chance_in_y(you.depth, brdepth[BRANCH_ABYSS]))</a>
<a name="ln2865">    {</a>
<a name="ln2866">        simple_monster_message(*this, &quot; wobbles for a moment.&quot;);</a>
<a name="ln2867">        return;</a>
<a name="ln2868">    }</a>
<a name="ln2869"> </a>
<a name="ln2870">    if (mons_is_tentacle_or_tentacle_segment(type))</a>
<a name="ln2871">    {</a>
<a name="ln2872">        monster* head = monster_by_mid(tentacle_connect);</a>
<a name="ln2873">        if (head)</a>
<a name="ln2874">        {</a>
<a name="ln2875">            head-&gt;banish(agent, &quot;&quot;, 0, force);</a>
<a name="ln2876">            return;</a>
<a name="ln2877">        }</a>
<a name="ln2878">    }</a>
<a name="ln2879"> </a>
<a name="ln2880">    simple_monster_message(*this, &quot; is devoured by a tear in reality.&quot;,</a>
<a name="ln2881">                           MSGCH_BANISHMENT);</a>
<a name="ln2882">    if (agent &amp;&amp; mons_gives_xp(*this, *agent))</a>
<a name="ln2883">    {</a>
<a name="ln2884">        // Double the existing damage blame counts, so the unassigned xp for</a>
<a name="ln2885">        // remaining hp is effectively halved. No need to pass flags this way.</a>
<a name="ln2886">        damage_total *= 2;</a>
<a name="ln2887">        damage_friendly *= 2;</a>
<a name="ln2888">        blame_damage(agent, hit_points);</a>
<a name="ln2889">        // Note: we do not set MF_PACIFIED, the monster is usually not</a>
<a name="ln2890">        // distinguishable from others of the same kind in the Abyss.</a>
<a name="ln2891"> </a>
<a name="ln2892">        if (agent-&gt;is_player())</a>
<a name="ln2893">        {</a>
<a name="ln2894">            did_god_conduct(DID_BANISH, get_experience_level(),</a>
<a name="ln2895">                            true /*possibly wrong*/, this);</a>
<a name="ln2896">        }</a>
<a name="ln2897">    }</a>
<a name="ln2898">    monster_die(*this, KILL_BANISHED, NON_MONSTER);</a>
<a name="ln2899"> </a>
<a name="ln2900">    if (!cell_is_solid(old_pos))</a>
<a name="ln2901">        place_cloud(CLOUD_TLOC_ENERGY, old_pos, 5 + random2(8), 0);</a>
<a name="ln2902">    for (adjacent_iterator ai(old_pos); ai; ++ai)</a>
<a name="ln2903">        if (!cell_is_solid(*ai) &amp;&amp; !cloud_at(*ai) &amp;&amp; coinflip())</a>
<a name="ln2904">            place_cloud(CLOUD_TLOC_ENERGY, *ai, 1 + random2(8), 0);</a>
<a name="ln2905">}</a>
<a name="ln2906"> </a>
<a name="ln2907">bool monster::has_spells() const</a>
<a name="ln2908">{</a>
<a name="ln2909">    return spells.size() &gt; 0;</a>
<a name="ln2910">}</a>
<a name="ln2911"> </a>
<a name="ln2912">bool monster::has_spell(spell_type spell) const</a>
<a name="ln2913">{</a>
<a name="ln2914">    return search_spells([=] (spell_type sp) { return sp == spell; } );</a>
<a name="ln2915">}</a>
<a name="ln2916"> </a>
<a name="ln2917">mon_spell_slot_flags monster::spell_slot_flags(spell_type spell) const</a>
<a name="ln2918">{</a>
<a name="ln2919">    mon_spell_slot_flags slot_flags;</a>
<a name="ln2920">    for (const mon_spell_slot &amp;slot : spells)</a>
<a name="ln2921">        if (slot.spell == spell)</a>
<a name="ln2922">            slot_flags |= slot.flags;</a>
<a name="ln2923"> </a>
<a name="ln2924">    return slot_flags;</a>
<a name="ln2925">}</a>
<a name="ln2926"> </a>
<a name="ln2927">bool monster::has_unclean_spell() const</a>
<a name="ln2928">{</a>
<a name="ln2929">    return search_spells(is_unclean_spell);</a>
<a name="ln2930">}</a>
<a name="ln2931"> </a>
<a name="ln2932">bool monster::has_chaotic_spell() const</a>
<a name="ln2933">{</a>
<a name="ln2934">    return search_spells(is_chaotic_spell);</a>
<a name="ln2935">}</a>
<a name="ln2936"> </a>
<a name="ln2937">bool monster::has_attack_flavour(int flavour) const</a>
<a name="ln2938">{</a>
<a name="ln2939">    for (int i = 0; i &lt; 4; ++i)</a>
<a name="ln2940">    {</a>
<a name="ln2941">        const int attk_flavour = mons_attack_spec(*this, i).flavour;</a>
<a name="ln2942">        if (attk_flavour == flavour)</a>
<a name="ln2943">            return true;</a>
<a name="ln2944">    }</a>
<a name="ln2945"> </a>
<a name="ln2946">    return false;</a>
<a name="ln2947">}</a>
<a name="ln2948"> </a>
<a name="ln2949">bool monster::has_damage_type(int dam_type)</a>
<a name="ln2950">{</a>
<a name="ln2951">    for (int i = 0; i &lt; 4; ++i)</a>
<a name="ln2952">    {</a>
<a name="ln2953">        const int dmg_type = damage_type(i);</a>
<a name="ln2954">        if (dmg_type == dam_type)</a>
<a name="ln2955">            return true;</a>
<a name="ln2956">    }</a>
<a name="ln2957"> </a>
<a name="ln2958">    return false;</a>
<a name="ln2959">}</a>
<a name="ln2960"> </a>
<a name="ln2961">int monster::constriction_damage(bool direct) const</a>
<a name="ln2962">{</a>
<a name="ln2963">    if (direct)</a>
<a name="ln2964">    {</a>
<a name="ln2965">        for (int i = 0; i &lt; 4; ++i)</a>
<a name="ln2966">        {</a>
<a name="ln2967">            const mon_attack_def attack = mons_attack_spec(*this, i);</a>
<a name="ln2968">            if (attack.type == AT_CONSTRICT)</a>
<a name="ln2969">                return attack.damage;</a>
<a name="ln2970">        }</a>
<a name="ln2971">        return -1;</a>
<a name="ln2972">    }</a>
<a name="ln2973"> </a>
<a name="ln2974">    // The only monster spell that's a source of indirect constriction.</a>
<a name="ln2975">    return roll_dice(2, div_rand_round(40 +</a>
<a name="ln2976">                mons_spellpower(*this, SPELL_GRASPING_ROOTS), 20));</a>
<a name="ln2977">}</a>
<a name="ln2978"> </a>
<a name="ln2979">bool monster::constriction_does_damage(bool direct) const</a>
<a name="ln2980">{</a>
<a name="ln2981">    return constriction_damage(direct) &gt; 0;</a>
<a name="ln2982">}</a>
<a name="ln2983"> </a>
<a name="ln2984">/** Return true if the monster temporarily confused. False for butterflies, or</a>
<a name="ln2985">    other permanently confused monsters.</a>
<a name="ln2986">*/</a>
<a name="ln2987">bool monster::confused() const</a>
<a name="ln2988">{</a>
<a name="ln2989">    return mons_is_confused(*this);</a>
<a name="ln2990">}</a>
<a name="ln2991"> </a>
<a name="ln2992">static bool _you_responsible_for_ench(mon_enchant me)</a>
<a name="ln2993">{</a>
<a name="ln2994">    return me.who == KC_YOU</a>
<a name="ln2995">        || me.who == KC_FRIENDLY &amp;&amp; !crawl_state.game_is_arena();</a>
<a name="ln2996">}</a>
<a name="ln2997"> </a>
<a name="ln2998">bool monster::confused_by_you() const</a>
<a name="ln2999">{</a>
<a name="ln3000">    if (mons_class_flag(type, M_CONFUSED))</a>
<a name="ln3001">        return false;</a>
<a name="ln3002"> </a>
<a name="ln3003">    const mon_enchant me = get_ench(ENCH_CONFUSION);</a>
<a name="ln3004">    const mon_enchant me2 = get_ench(ENCH_MAD);</a>
<a name="ln3005"> </a>
<a name="ln3006">    return (me.ench == ENCH_CONFUSION &amp;&amp; _you_responsible_for_ench(me))</a>
<a name="ln3007">           || (me2.ench == ENCH_MAD &amp;&amp; _you_responsible_for_ench(me2));</a>
<a name="ln3008">}</a>
<a name="ln3009"> </a>
<a name="ln3010">bool monster::paralysed() const</a>
<a name="ln3011">{</a>
<a name="ln3012">    return has_ench(ENCH_PARALYSIS) || has_ench(ENCH_DUMB);</a>
<a name="ln3013">}</a>
<a name="ln3014"> </a>
<a name="ln3015">bool monster::cannot_act() const</a>
<a name="ln3016">{</a>
<a name="ln3017">    return paralysed() || petrified();</a>
<a name="ln3018">}</a>
<a name="ln3019"> </a>
<a name="ln3020">bool monster::cannot_move() const</a>
<a name="ln3021">{</a>
<a name="ln3022">    return cannot_act();</a>
<a name="ln3023">}</a>
<a name="ln3024"> </a>
<a name="ln3025">bool monster::asleep() const</a>
<a name="ln3026">{</a>
<a name="ln3027">    return behaviour == BEH_SLEEP;</a>
<a name="ln3028">}</a>
<a name="ln3029"> </a>
<a name="ln3030">bool monster::backlit(bool self_halo) const</a>
<a name="ln3031">{</a>
<a name="ln3032">    if (has_ench(ENCH_CORONA) || has_ench(ENCH_STICKY_FLAME)</a>
<a name="ln3033">        || has_ench(ENCH_SILVER_CORONA))</a>
<a name="ln3034">    {</a>
<a name="ln3035">        return true;</a>
<a name="ln3036">    }</a>
<a name="ln3037"> </a>
<a name="ln3038">    return !umbraed() &amp;&amp; haloed() &amp;&amp; (self_halo || halo_radius() == -1);</a>
<a name="ln3039">}</a>
<a name="ln3040"> </a>
<a name="ln3041">bool monster::umbra() const</a>
<a name="ln3042">{</a>
<a name="ln3043">    return umbraed() &amp;&amp; !haloed();</a>
<a name="ln3044">}</a>
<a name="ln3045"> </a>
<a name="ln3046">bool monster::caught() const</a>
<a name="ln3047">{</a>
<a name="ln3048">    return has_ench(ENCH_HELD);</a>
<a name="ln3049">}</a>
<a name="ln3050"> </a>
<a name="ln3051">bool monster::petrified() const</a>
<a name="ln3052">{</a>
<a name="ln3053">    return has_ench(ENCH_PETRIFIED);</a>
<a name="ln3054">}</a>
<a name="ln3055"> </a>
<a name="ln3056">bool monster::petrifying() const</a>
<a name="ln3057">{</a>
<a name="ln3058">    return has_ench(ENCH_PETRIFYING);</a>
<a name="ln3059">}</a>
<a name="ln3060"> </a>
<a name="ln3061">bool monster::liquefied_ground() const</a>
<a name="ln3062">{</a>
<a name="ln3063">    return liquefied(pos())</a>
<a name="ln3064">           &amp;&amp; ground_level() &amp;&amp; !is_insubstantial()</a>
<a name="ln3065">           &amp;&amp; !mons_class_is_stationary(type);</a>
<a name="ln3066">}</a>
<a name="ln3067"> </a>
<a name="ln3068">// in units of 1/25 hp/turn</a>
<a name="ln3069">int monster::natural_regen_rate() const</a>
<a name="ln3070">{</a>
<a name="ln3071">    // A HD divider ranging from 3 (at 1 HD) to 1 (at 8 HD).</a>
<a name="ln3072">    int divider = max(div_rand_round(15 - get_hit_dice(), 4), 1);</a>
<a name="ln3073"> </a>
<a name="ln3074">    return max(div_rand_round(get_hit_dice(), divider), 1);</a>
<a name="ln3075">}</a>
<a name="ln3076"> </a>
<a name="ln3077">// in units of 1/100 hp/turn</a>
<a name="ln3078">int monster::off_level_regen_rate() const</a>
<a name="ln3079">{</a>
<a name="ln3080">    if (!mons_can_regenerate(*this))</a>
<a name="ln3081">        return 0;</a>
<a name="ln3082"> </a>
<a name="ln3083">    if (mons_class_fast_regen(type) || type == MONS_PLAYER_GHOST)</a>
<a name="ln3084">        return 100;</a>
<a name="ln3085">    // Capped at 0.1 hp/turn.</a>
<a name="ln3086">    return max(natural_regen_rate() * 4, 10);</a>
<a name="ln3087">}</a>
<a name="ln3088"> </a>
<a name="ln3089">bool monster::friendly() const</a>
<a name="ln3090">{</a>
<a name="ln3091">    return temp_attitude() == ATT_FRIENDLY;</a>
<a name="ln3092">}</a>
<a name="ln3093"> </a>
<a name="ln3094">bool monster::neutral() const</a>
<a name="ln3095">{</a>
<a name="ln3096">    mon_attitude_type att = temp_attitude();</a>
<a name="ln3097">    return att == ATT_NEUTRAL || att == ATT_GOOD_NEUTRAL</a>
<a name="ln3098">           || att == ATT_STRICT_NEUTRAL;</a>
<a name="ln3099">}</a>
<a name="ln3100"> </a>
<a name="ln3101">bool monster::good_neutral() const</a>
<a name="ln3102">{</a>
<a name="ln3103">    return temp_attitude() == ATT_GOOD_NEUTRAL;</a>
<a name="ln3104">}</a>
<a name="ln3105"> </a>
<a name="ln3106">bool monster::strict_neutral() const</a>
<a name="ln3107">{</a>
<a name="ln3108">    return temp_attitude() == ATT_STRICT_NEUTRAL;</a>
<a name="ln3109">}</a>
<a name="ln3110"> </a>
<a name="ln3111">bool monster::wont_attack() const</a>
<a name="ln3112">{</a>
<a name="ln3113">    return friendly() || good_neutral() || strict_neutral();</a>
<a name="ln3114">}</a>
<a name="ln3115"> </a>
<a name="ln3116">bool monster::pacified() const</a>
<a name="ln3117">{</a>
<a name="ln3118">    return attitude == ATT_NEUTRAL &amp;&amp; testbits(flags, MF_PACIFIED);</a>
<a name="ln3119">}</a>
<a name="ln3120"> </a>
<a name="ln3121">/**</a>
<a name="ln3122"> * Returns whether the monster currently has any kind of shield.</a>
<a name="ln3123"> */</a>
<a name="ln3124">bool monster::shielded() const</a>
<a name="ln3125">{</a>
<a name="ln3126">    return shield()</a>
<a name="ln3127">           || wearing(EQ_AMULET_PLUS, AMU_REFLECTION) &gt; 0;</a>
<a name="ln3128">}</a>
<a name="ln3129"> </a>
<a name="ln3130">int monster::shield_bonus() const</a>
<a name="ln3131">{</a>
<a name="ln3132">    if (incapacitated())</a>
<a name="ln3133">        return -100;</a>
<a name="ln3134"> </a>
<a name="ln3135">    int sh = -100;</a>
<a name="ln3136">    const item_def *shld = shield();</a>
<a name="ln3137">    if (shld &amp;&amp; get_armour_slot(*shld) == EQ_SHIELD)</a>
<a name="ln3138">    {</a>
<a name="ln3139"> </a>
<a name="ln3140">        int shld_c = property(*shld, PARM_AC) + shld-&gt;plus * 2;</a>
<a name="ln3141">        shld_c = shld_c * 2 + (body_size(PSIZE_TORSO) - SIZE_MEDIUM)</a>
<a name="ln3142">                            * (shld-&gt;sub_type - ARM_TOWER_SHIELD);</a>
<a name="ln3143">        sh = random2avg(shld_c + get_hit_dice() * 4 / 3, 2) / 2;</a>
<a name="ln3144">    }</a>
<a name="ln3145">    // shielding from jewellery</a>
<a name="ln3146">    const item_def *amulet = mslot_item(MSLOT_JEWELLERY);</a>
<a name="ln3147">    if (amulet &amp;&amp; amulet-&gt;sub_type == AMU_REFLECTION)</a>
<a name="ln3148">    {</a>
<a name="ln3149">        const int jewellery_plus = amulet-&gt;plus;</a>
<a name="ln3150">        ASSERT(abs(jewellery_plus) &lt; 30); // sanity check</a>
<a name="ln3151">        sh += jewellery_plus * 2;</a>
<a name="ln3152">    }</a>
<a name="ln3153"> </a>
<a name="ln3154">    return sh;</a>
<a name="ln3155">}</a>
<a name="ln3156"> </a>
<a name="ln3157">int monster::shield_block_penalty() const</a>
<a name="ln3158">{</a>
<a name="ln3159">    return 4 * shield_blocks * shield_blocks;</a>
<a name="ln3160">}</a>
<a name="ln3161"> </a>
<a name="ln3162">void monster::shield_block_succeeded(actor *attacker)</a>
<a name="ln3163">{</a>
<a name="ln3164">    actor::shield_block_succeeded(attacker);</a>
<a name="ln3165"> </a>
<a name="ln3166">    ++shield_blocks;</a>
<a name="ln3167">}</a>
<a name="ln3168"> </a>
<a name="ln3169">int monster::shield_bypass_ability(int) const</a>
<a name="ln3170">{</a>
<a name="ln3171">    return 15 + get_hit_dice() * 2 / 3;</a>
<a name="ln3172">}</a>
<a name="ln3173"> </a>
<a name="ln3174">bool monster::missile_repulsion() const</a>
<a name="ln3175">{</a>
<a name="ln3176">    return has_ench(ENCH_REPEL_MISSILES) || scan_artefacts(ARTP_RMSL);</a>
<a name="ln3177">}</a>
<a name="ln3178"> </a>
<a name="ln3179">void monster::ablate_repulsion()</a>
<a name="ln3180">{</a>
<a name="ln3181">    if (has_ench(ENCH_REPEL_MISSILES))</a>
<a name="ln3182">    {</a>
<a name="ln3183">        if (one_chance_in(2 + spell_hd()))</a>
<a name="ln3184">            del_ench(ENCH_REPEL_MISSILES);</a>
<a name="ln3185">    }</a>
<a name="ln3186">}</a>
<a name="ln3187"> </a>
<a name="ln3188">/**</a>
<a name="ln3189"> * How many weapons of the given brand does this monster currently wield?</a>
<a name="ln3190"> *</a>
<a name="ln3191"> * @param mon           The monster in question.</a>
<a name="ln3192"> * @param brand         The brand in question.</a>
<a name="ln3193"> * @param calc_unid     Whether to include weapons whose brands are unknown (to</a>
<a name="ln3194"> *                      the player).</a>
<a name="ln3195"> * @return              The number of the aforementioned weapons currently</a>
<a name="ln3196"> *                      wielded.</a>
<a name="ln3197"> */</a>
<a name="ln3198">static int _weapons_with_prop(const monster *mon, brand_type brand,</a>
<a name="ln3199">                              bool calc_unid = true)</a>
<a name="ln3200">{</a>
<a name="ln3201">    int wielded = 0;</a>
<a name="ln3202"> </a>
<a name="ln3203">    const mon_inv_type last_weap_slot = mons_wields_two_weapons(*mon) ?</a>
<a name="ln3204">                                        MSLOT_ALT_WEAPON :</a>
<a name="ln3205">                                        MSLOT_WEAPON;</a>
<a name="ln3206">    for (int i = MSLOT_WEAPON; i &lt;= last_weap_slot; i++)</a>
<a name="ln3207">    {</a>
<a name="ln3208">        const item_def *weap = mon-&gt;mslot_item(static_cast&lt;mon_inv_type&gt;(i));</a>
<a name="ln3209">        if (!weap)</a>
<a name="ln3210">            continue;</a>
<a name="ln3211"> </a>
<a name="ln3212">        if (!calc_unid &amp;&amp; !item_ident(*weap, ISFLAG_KNOW_TYPE))</a>
<a name="ln3213">            continue;</a>
<a name="ln3214"> </a>
<a name="ln3215">        const int weap_brand = get_weapon_brand(*weap);</a>
<a name="ln3216">        if (brand == weap_brand)</a>
<a name="ln3217">            wielded++;</a>
<a name="ln3218">    }</a>
<a name="ln3219"> </a>
<a name="ln3220">    return wielded;</a>
<a name="ln3221">}</a>
<a name="ln3222"> </a>
<a name="ln3223">/**</a>
<a name="ln3224"> * What AC bonus or penalty does a given zombie type apply to the base</a>
<a name="ln3225"> * monster type's?</a>
<a name="ln3226"> *</a>
<a name="ln3227"> * @param type      The type of zombie. (Skeleton, simulac, etc)</a>
<a name="ln3228"> * @return          The ac modifier to apply to the base monster's AC.</a>
<a name="ln3229"> */</a>
<a name="ln3230">static int _zombie_ac_modifier(monster_type type)</a>
<a name="ln3231">{</a>
<a name="ln3232">    ASSERT(mons_class_is_zombified(type));</a>
<a name="ln3233"> </a>
<a name="ln3234">    switch (type)</a>
<a name="ln3235">    {</a>
<a name="ln3236">        case MONS_ZOMBIE:</a>
<a name="ln3237">        case MONS_SIMULACRUM:</a>
<a name="ln3238">            return -2;</a>
<a name="ln3239">        case MONS_SKELETON:</a>
<a name="ln3240">            return -6;</a>
<a name="ln3241">        case MONS_SPECTRAL_THING:</a>
<a name="ln3242">            return 2;</a>
<a name="ln3243">        default:</a>
<a name="ln3244">            die(&quot;invalid zombie type %d (%s)&quot;, type,</a>
<a name="ln3245">                mons_class_name(type));</a>
<a name="ln3246">    }</a>
<a name="ln3247">}</a>
<a name="ln3248"> </a>
<a name="ln3249">/**</a>
<a name="ln3250"> * What's the base armour class of this monster?</a>
<a name="ln3251"> *</a>
<a name="ln3252"> * Usually based on type; ghost demons can override this, and draconians/</a>
<a name="ln3253"> * demonspawn are... complicated.</a>
<a name="ln3254"> *</a>
<a name="ln3255"> * @return The base armour class of this monster, before applying item &amp;</a>
<a name="ln3256"> *          status effects.</a>
<a name="ln3257"> */</a>
<a name="ln3258">int monster::base_armour_class() const</a>
<a name="ln3259">{</a>
<a name="ln3260">    ASSERT(!invalid_monster_type(type));</a>
<a name="ln3261"> </a>
<a name="ln3262">    // ghost demon struct overrides the monster values.</a>
<a name="ln3263">    if (mons_is_ghost_demon(type))</a>
<a name="ln3264">        return ghost-&gt;ac;</a>
<a name="ln3265"> </a>
<a name="ln3266">    // zombie, skeleton, etc ac mods</a>
<a name="ln3267">    if (mons_class_is_zombified(type))</a>
<a name="ln3268">    {</a>
<a name="ln3269">        // handle weird zombies for which type isn't enough to reconstruct ac</a>
<a name="ln3270">        // (e.g. zombies with jobs &amp; demonghost zombies)</a>
<a name="ln3271">        const int base_ac = props.exists(ZOMBIE_BASE_AC_KEY) ?</a>
<a name="ln3272">                                props[ZOMBIE_BASE_AC_KEY].get_int() :</a>
<a name="ln3273">                                get_monster_data(base_monster)-&gt;AC;</a>
<a name="ln3274"> </a>
<a name="ln3275">        return _zombie_ac_modifier(type) + base_ac;</a>
<a name="ln3276">    }</a>
<a name="ln3277"> </a>
<a name="ln3278">    // abominations are weird.</a>
<a name="ln3279">    if (type == MONS_ABOMINATION_LARGE)</a>
<a name="ln3280">        return min(20, 7 + get_hit_dice() / 2);</a>
<a name="ln3281">    if (type == MONS_ABOMINATION_SMALL)</a>
<a name="ln3282">        return min(10, 3 + get_hit_dice() * 2 / 3);</a>
<a name="ln3283"> </a>
<a name="ln3284">    // Hepliaklqana ancestors scale with xl.</a>
<a name="ln3285">    if (mons_is_hepliaklqana_ancestor(type))</a>
<a name="ln3286">    {</a>
<a name="ln3287">        if (type == MONS_ANCESTOR_KNIGHT)</a>
<a name="ln3288">            return get_experience_level() + 7;</a>
<a name="ln3289">        return get_experience_level() / 2;</a>
<a name="ln3290">    }</a>
<a name="ln3291"> </a>
<a name="ln3292">    const int base_ac = get_monster_data(type)-&gt;AC;</a>
<a name="ln3293"> </a>
<a name="ln3294">    // demonspawn &amp; draconians combine base &amp; class ac values.</a>
<a name="ln3295">    if (mons_is_job(type))</a>
<a name="ln3296">    {</a>
<a name="ln3297">        ASSERT(!invalid_monster_type(base_monster));</a>
<a name="ln3298">        return base_ac + get_monster_data(base_monster)-&gt;AC;</a>
<a name="ln3299">    }</a>
<a name="ln3300"> </a>
<a name="ln3301">    // mutant beasts get extra AC for being musk oxen.</a>
<a name="ln3302">    if (has_facet(BF_OX))</a>
<a name="ln3303">        return base_ac + 5;</a>
<a name="ln3304"> </a>
<a name="ln3305">    return base_ac;</a>
<a name="ln3306">}</a>
<a name="ln3307"> </a>
<a name="ln3308">/**</a>
<a name="ln3309"> * What's the armour class of this monster?</a>
<a name="ln3310"> *</a>
<a name="ln3311"> * @param calc_unid     Whether to include unknown items/properties in the</a>
<a name="ln3312"> *                      calculated results.</a>
<a name="ln3313"> * @return              The armour class of this monster, including items,</a>
<a name="ln3314"> *                      statuses, etc.</a>
<a name="ln3315"> */</a>
<a name="ln3316">int monster::armour_class(bool calc_unid) const</a>
<a name="ln3317">{</a>
<a name="ln3318">    int ac = base_armour_class();</a>
<a name="ln3319"> </a>
<a name="ln3320">    // check for protection-brand weapons</a>
<a name="ln3321">    ac += 5 * _weapons_with_prop(this, SPWPN_PROTECTION, calc_unid);</a>
<a name="ln3322"> </a>
<a name="ln3323">    // armour from ac</a>
<a name="ln3324">    const item_def *armour = mslot_item(MSLOT_ARMOUR);</a>
<a name="ln3325">    if (armour)</a>
<a name="ln3326">        ac += armour_bonus(*armour, calc_unid);</a>
<a name="ln3327"> </a>
<a name="ln3328">    // armour from jewellery</a>
<a name="ln3329">    const item_def *ring = mslot_item(MSLOT_JEWELLERY);</a>
<a name="ln3330">    if (ring &amp;&amp; ring-&gt;sub_type == RING_PROTECTION</a>
<a name="ln3331">        &amp;&amp; (calc_unid</a>
<a name="ln3332">            || item_ident(*ring, ISFLAG_KNOW_TYPE | ISFLAG_KNOW_PLUSES)))</a>
<a name="ln3333">    {</a>
<a name="ln3334">        const int jewellery_plus = ring-&gt;plus;</a>
<a name="ln3335">        ASSERT(abs(jewellery_plus) &lt; 30); // sanity check</a>
<a name="ln3336">        ac += jewellery_plus;</a>
<a name="ln3337">    }</a>
<a name="ln3338"> </a>
<a name="ln3339">    // various enchantments</a>
<a name="ln3340">    if (has_ench(ENCH_OZOCUBUS_ARMOUR))</a>
<a name="ln3341">        ac += 4 + get_hit_dice() / 3;</a>
<a name="ln3342">    if (has_ench(ENCH_ICEMAIL))</a>
<a name="ln3343">        ac += ICEMAIL_MAX;</a>
<a name="ln3344">    if (has_ench(ENCH_IDEALISED))</a>
<a name="ln3345">        ac += 4 + get_hit_dice() / 3;</a>
<a name="ln3346"> </a>
<a name="ln3347">    // Penalty due to bad temp mutations.</a>
<a name="ln3348">    if (has_ench(ENCH_WRETCHED))</a>
<a name="ln3349">        ac -= 8;</a>
<a name="ln3350"> </a>
<a name="ln3351">    // corrosion hurts.</a>
<a name="ln3352">    if (has_ench(ENCH_CORROSION))</a>
<a name="ln3353">        ac -= 8;</a>
<a name="ln3354"> </a>
<a name="ln3355">    return max(ac, 0);</a>
<a name="ln3356">}</a>
<a name="ln3357"> </a>
<a name="ln3358">/**</a>
<a name="ln3359"> * What EV bonus or penalty does a given zombie type apply to the base</a>
<a name="ln3360"> * monster type's?</a>
<a name="ln3361"> *</a>
<a name="ln3362"> * @param type      The type of zombie. (Skeleton, simulac, etc)</a>
<a name="ln3363"> * @return          The ev modifier to apply to the base monster's EV.</a>
<a name="ln3364"> */</a>
<a name="ln3365">static int _zombie_ev_modifier(monster_type type)</a>
<a name="ln3366">{</a>
<a name="ln3367">    ASSERT(mons_class_is_zombified(type));</a>
<a name="ln3368"> </a>
<a name="ln3369">    switch (type)</a>
<a name="ln3370">    {</a>
<a name="ln3371">        case MONS_ZOMBIE:</a>
<a name="ln3372">        case MONS_SIMULACRUM:</a>
<a name="ln3373">        case MONS_SPECTRAL_THING:</a>
<a name="ln3374">            return -5;</a>
<a name="ln3375">        case MONS_SKELETON:</a>
<a name="ln3376">            return -7;</a>
<a name="ln3377">        default:</a>
<a name="ln3378">            die(&quot;invalid zombie type %d (%s)&quot;, type,</a>
<a name="ln3379">                mons_class_name(type));</a>
<a name="ln3380">    }</a>
<a name="ln3381">}</a>
<a name="ln3382"> </a>
<a name="ln3383">/**</a>
<a name="ln3384"> * What's the base evasion of this monster?</a>
<a name="ln3385"> *</a>
<a name="ln3386"> * @return The base evasion of this monster, before applying items &amp; statuses.</a>
<a name="ln3387"> **/</a>
<a name="ln3388">int monster::base_evasion() const</a>
<a name="ln3389">{</a>
<a name="ln3390">    // ghost demon struct overrides the monster values.</a>
<a name="ln3391">    if (mons_is_ghost_demon(type))</a>
<a name="ln3392">        return ghost-&gt;ev;</a>
<a name="ln3393"> </a>
<a name="ln3394">    // zombie, skeleton, etc ac mods</a>
<a name="ln3395">    if (mons_class_is_zombified(type))</a>
<a name="ln3396">    {</a>
<a name="ln3397">        // handle weird zombies for which type isn't enough to reconstruct ev</a>
<a name="ln3398">        // (e.g. zombies with jobs &amp; demonghost zombies)</a>
<a name="ln3399">        const int base_ev = props.exists(ZOMBIE_BASE_EV_KEY) ?</a>
<a name="ln3400">                                props[ZOMBIE_BASE_EV_KEY].get_int() :</a>
<a name="ln3401">                                get_monster_data(base_monster)-&gt;ev;</a>
<a name="ln3402"> </a>
<a name="ln3403">        return _zombie_ev_modifier(type) + base_ev;</a>
<a name="ln3404">    }</a>
<a name="ln3405"> </a>
<a name="ln3406">    // abominations are weird.</a>
<a name="ln3407">    if (type == MONS_ABOMINATION_LARGE)</a>
<a name="ln3408">        return min(20, 2 * get_hit_dice() / 3);</a>
<a name="ln3409">    if (type == MONS_ABOMINATION_SMALL)</a>
<a name="ln3410">        return min(10, 4 + get_hit_dice());</a>
<a name="ln3411"> </a>
<a name="ln3412">    const int base_ev = get_monster_data(type)-&gt;ev;</a>
<a name="ln3413"> </a>
<a name="ln3414">    // demonspawn &amp; draconians combine base &amp; class ac values.</a>
<a name="ln3415">    if (mons_is_job(type))</a>
<a name="ln3416">        return base_ev + get_monster_data(base_monster)-&gt;ev;</a>
<a name="ln3417"> </a>
<a name="ln3418">    return base_ev;</a>
<a name="ln3419">}</a>
<a name="ln3420"> </a>
<a name="ln3421">/**</a>
<a name="ln3422"> * What's the current evasion of this monster?</a>
<a name="ln3423"> *</a>
<a name="ln3424"> * @param evit      A bitfield of ev modifiers to ignore.</a>
<a name="ln3425"> * @return The evasion of this monster, after applying items &amp; statuses.</a>
<a name="ln3426"> **/</a>
<a name="ln3427">int monster::evasion(ev_ignore_type evit, const actor* /*act*/) const</a>
<a name="ln3428">{</a>
<a name="ln3429">    const bool calc_unid = !testbits(evit, ev_ignore::unided);</a>
<a name="ln3430"> </a>
<a name="ln3431">    int ev = base_evasion();</a>
<a name="ln3432"> </a>
<a name="ln3433">    // account for armour</a>
<a name="ln3434">    for (int slot = MSLOT_ARMOUR; slot &lt;= MSLOT_SHIELD; slot++)</a>
<a name="ln3435">    {</a>
<a name="ln3436">        const item_def* armour = mslot_item(static_cast&lt;mon_inv_type&gt;(slot));</a>
<a name="ln3437">        if (armour)</a>
<a name="ln3438">        {</a>
<a name="ln3439">            ev += property(*armour, PARM_EVASION) / 10</a>
<a name="ln3440">                  / (is_shield(*armour) ? 2 : 6);</a>
<a name="ln3441">        }</a>
<a name="ln3442">    }</a>
<a name="ln3443"> </a>
<a name="ln3444">    // evasion from jewellery</a>
<a name="ln3445">    const item_def *ring = mslot_item(MSLOT_JEWELLERY);</a>
<a name="ln3446">    if (ring &amp;&amp; ring-&gt;sub_type == RING_EVASION</a>
<a name="ln3447">        &amp;&amp; (calc_unid</a>
<a name="ln3448">            || item_ident(*ring, ISFLAG_KNOW_TYPE | ISFLAG_KNOW_PLUSES)))</a>
<a name="ln3449">    {</a>
<a name="ln3450">        const int jewellery_plus = ring-&gt;plus;</a>
<a name="ln3451">        ASSERT(abs(jewellery_plus) &lt; 30); // sanity check</a>
<a name="ln3452">        ev += jewellery_plus;</a>
<a name="ln3453">    }</a>
<a name="ln3454"> </a>
<a name="ln3455">    if (has_ench(ENCH_AGILE))</a>
<a name="ln3456">        ev += AGILITY_BONUS;</a>
<a name="ln3457"> </a>
<a name="ln3458">    if (evit &amp; ev_ignore::helpless)</a>
<a name="ln3459">        return max(ev, 0);</a>
<a name="ln3460"> </a>
<a name="ln3461">    if (paralysed() || petrified() || petrifying() || asleep())</a>
<a name="ln3462">        return 0;</a>
<a name="ln3463"> </a>
<a name="ln3464">    if (caught() || is_constricted())</a>
<a name="ln3465">        ev /= (body_size(PSIZE_BODY) + 2);</a>
<a name="ln3466">    else if (confused())</a>
<a name="ln3467">        ev /= 2;</a>
<a name="ln3468"> </a>
<a name="ln3469">    return max(ev, 0);</a>
<a name="ln3470">}</a>
<a name="ln3471"> </a>
<a name="ln3472">bool monster::heal(int amount)</a>
<a name="ln3473">{</a>
<a name="ln3474">    if (mons_is_statue(type))</a>
<a name="ln3475">        return false;</a>
<a name="ln3476"> </a>
<a name="ln3477">    if (amount &lt; 1)</a>
<a name="ln3478">        return false;</a>
<a name="ln3479">    else if (hit_points == max_hit_points)</a>
<a name="ln3480">        return false;</a>
<a name="ln3481"> </a>
<a name="ln3482">    hit_points += amount;</a>
<a name="ln3483"> </a>
<a name="ln3484">    bool success = true;</a>
<a name="ln3485"> </a>
<a name="ln3486">    if (hit_points &gt; max_hit_points)</a>
<a name="ln3487">        hit_points = max_hit_points;</a>
<a name="ln3488"> </a>
<a name="ln3489">    if (hit_points == max_hit_points)</a>
<a name="ln3490">    {</a>
<a name="ln3491">        // Clear the damage blame if it goes away completely.</a>
<a name="ln3492">        damage_friendly = 0;</a>
<a name="ln3493">        damage_total = 0;</a>
<a name="ln3494">        props.erase(&quot;reaping_damage&quot;);</a>
<a name="ln3495">    }</a>
<a name="ln3496"> </a>
<a name="ln3497">    return success;</a>
<a name="ln3498">}</a>
<a name="ln3499"> </a>
<a name="ln3500">void monster::blame_damage(const actor* attacker, int amount)</a>
<a name="ln3501">{</a>
<a name="ln3502">    ASSERT(amount &gt;= 0);</a>
<a name="ln3503">    damage_total = min&lt;int&gt;(MAX_DAMAGE_COUNTER, damage_total + amount);</a>
<a name="ln3504">    if (attacker)</a>
<a name="ln3505">    {</a>
<a name="ln3506">        damage_friendly = min&lt;int&gt;(MAX_DAMAGE_COUNTER * 2,</a>
<a name="ln3507">                      damage_friendly + amount * exp_rate(attacker-&gt;mindex()));</a>
<a name="ln3508">    }</a>
<a name="ln3509">}</a>
<a name="ln3510"> </a>
<a name="ln3511">void monster::suicide(int hp_target)</a>
<a name="ln3512">{</a>
<a name="ln3513">    ASSERT(hp_target &lt;= 0);</a>
<a name="ln3514">    const int dam = hit_points - hp_target;</a>
<a name="ln3515">    if (dam &gt; 0)</a>
<a name="ln3516">        blame_damage(nullptr, dam);</a>
<a name="ln3517">    hit_points = hp_target;</a>
<a name="ln3518">}</a>
<a name="ln3519"> </a>
<a name="ln3520">mon_holy_type monster::holiness(bool /*temp*/) const</a>
<a name="ln3521">{</a>
<a name="ln3522">    // zombie kraken tentacles</a>
<a name="ln3523">    if (testbits(flags, MF_FAKE_UNDEAD))</a>
<a name="ln3524">        return MH_UNDEAD;</a>
<a name="ln3525"> </a>
<a name="ln3526">    mon_holy_type holi = mons_class_holiness(type);</a>
<a name="ln3527"> </a>
<a name="ln3528">    // Assume that all unknown gods are not holy.</a>
<a name="ln3529">    if (is_priest() &amp;&amp; is_good_god(god))</a>
<a name="ln3530">        holi |= MH_HOLY;</a>
<a name="ln3531"> </a>
<a name="ln3532">    // Assume that all unknown gods are evil.</a>
<a name="ln3533">    if (is_priest() &amp;&amp; (is_evil_god(god) || is_unknown_god(god)))</a>
<a name="ln3534">        holi |= MH_EVIL;</a>
<a name="ln3535"> </a>
<a name="ln3536">    if (has_attack_flavour(AF_DRAIN_XP)</a>
<a name="ln3537">        || has_attack_flavour(AF_VAMPIRIC))</a>
<a name="ln3538">    {</a>
<a name="ln3539">        holi |= MH_EVIL;</a>
<a name="ln3540">    }</a>
<a name="ln3541"> </a>
<a name="ln3542">    if (testbits(flags, MF_SPECTRALISED))</a>
<a name="ln3543">        holi |= MH_EVIL;</a>
<a name="ln3544"> </a>
<a name="ln3545">    return holi;</a>
<a name="ln3546">}</a>
<a name="ln3547"> </a>
<a name="ln3548">bool monster::undead_or_demonic() const</a>
<a name="ln3549">{</a>
<a name="ln3550">    const mon_holy_type holi = holiness();</a>
<a name="ln3551"> </a>
<a name="ln3552">    return bool(holi &amp; (MH_UNDEAD | MH_DEMONIC));</a>
<a name="ln3553">}</a>
<a name="ln3554"> </a>
<a name="ln3555">bool monster::is_holy(bool /*check_spells*/) const</a>
<a name="ln3556">{</a>
<a name="ln3557">    return bool(holiness() &amp; MH_HOLY);</a>
<a name="ln3558">}</a>
<a name="ln3559"> </a>
<a name="ln3560">bool monster::is_nonliving(bool /*temp*/) const</a>
<a name="ln3561">{</a>
<a name="ln3562">    return bool(holiness() &amp; MH_NONLIVING);</a>
<a name="ln3563">}</a>
<a name="ln3564"> </a>
<a name="ln3565">/** Is the monster considered unclean by Zin?</a>
<a name="ln3566"> *</a>
<a name="ln3567"> *  If not 0, then Zin won't let you have it as an ally, and gives</a>
<a name="ln3568"> *  piety for killing it.</a>
<a name="ln3569"> *  @param check_god whether the monster having a chaotic god matters.</a>
<a name="ln3570"> *  @returns 0 if not hated, a number greater than 0 otherwise.</a>
<a name="ln3571"> */</a>
<a name="ln3572">int monster::how_unclean(bool check_god) const</a>
<a name="ln3573">{</a>
<a name="ln3574">    int uncleanliness = 0;</a>
<a name="ln3575"> </a>
<a name="ln3576">    if (has_attack_flavour(AF_HUNGER))</a>
<a name="ln3577">        uncleanliness++;</a>
<a name="ln3578">    if (has_attack_flavour(AF_ROT))</a>
<a name="ln3579">        uncleanliness++;</a>
<a name="ln3580">    if (has_attack_flavour(AF_STEAL))</a>
<a name="ln3581">        uncleanliness++;</a>
<a name="ln3582">    if (has_attack_flavour(AF_VAMPIRIC))</a>
<a name="ln3583">        uncleanliness++;</a>
<a name="ln3584"> </a>
<a name="ln3585">    // Zin considers insanity unclean. And slugs that speak.</a>
<a name="ln3586">    if (type == MONS_CRAZY_YIUF</a>
<a name="ln3587">        || type == MONS_PSYCHE</a>
<a name="ln3588">        || type == MONS_LOUISE</a>
<a name="ln3589">        || type == MONS_GASTRONOK)</a>
<a name="ln3590">    {</a>
<a name="ln3591">        uncleanliness++;</a>
<a name="ln3592">    }</a>
<a name="ln3593"> </a>
<a name="ln3594">    // A floating mass of disease is nearly the definition of unclean.</a>
<a name="ln3595">    if (type == MONS_ANCIENT_ZYME)</a>
<a name="ln3596">        uncleanliness++;</a>
<a name="ln3597"> </a>
<a name="ln3598">    // Assume that all unknown gods are not chaotic.</a>
<a name="ln3599">    //</a>
<a name="ln3600">    // Being a worshipper of a chaotic god doesn't yet make you</a>
<a name="ln3601">    // physically/essentially chaotic (so you don't get hurt by silver),</a>
<a name="ln3602">    // but Zin does mind.</a>
<a name="ln3603">    if (is_priest() &amp;&amp; is_chaotic_god(god) &amp;&amp; check_god)</a>
<a name="ln3604">        uncleanliness++;</a>
<a name="ln3605"> </a>
<a name="ln3606">    if (has_unclean_spell())</a>
<a name="ln3607">        uncleanliness++;</a>
<a name="ln3608"> </a>
<a name="ln3609">    if (has_chaotic_spell() &amp;&amp; is_actual_spellcaster())</a>
<a name="ln3610">        uncleanliness++;</a>
<a name="ln3611"> </a>
<a name="ln3612">    // Corporeal undead are a perversion of natural form.</a>
<a name="ln3613">    if (holiness() &amp; MH_UNDEAD &amp;&amp; !is_insubstantial())</a>
<a name="ln3614">        uncleanliness++;</a>
<a name="ln3615"> </a>
<a name="ln3616">    return uncleanliness;</a>
<a name="ln3617">}</a>
<a name="ln3618"> </a>
<a name="ln3619">/** How chaotic do you know this monster to be?</a>
<a name="ln3620"> *</a>
<a name="ln3621"> * @param check_spells_god whether to look at its spells and/or</a>
<a name="ln3622"> *        religion; silver damage does not.</a>
<a name="ln3623"> * @returns 0 if not chaotic, a larger number if so.</a>
<a name="ln3624"> */</a>
<a name="ln3625">int monster::known_chaos(bool check_spells_god) const</a>
<a name="ln3626">{</a>
<a name="ln3627">    int chaotic = 0;</a>
<a name="ln3628"> </a>
<a name="ln3629">    if (type == MONS_UGLY_THING</a>
<a name="ln3630">        || type == MONS_VERY_UGLY_THING</a>
<a name="ln3631">        || type == MONS_ABOMINATION_SMALL</a>
<a name="ln3632">        || type == MONS_ABOMINATION_LARGE</a>
<a name="ln3633">        || type == MONS_WRETCHED_STAR</a>
<a name="ln3634">        || type == MONS_KILLER_KLOWN      // For their random attacks.</a>
<a name="ln3635">        || type == MONS_TIAMAT            // For her colour-changing.</a>
<a name="ln3636">        || type == MONS_BAI_SUZHEN</a>
<a name="ln3637">        || type == MONS_BAI_SUZHEN_DRAGON // For her transformation.</a>
<a name="ln3638">        || mons_is_demonspawn(type))      // Like player demonspawn.</a>
<a name="ln3639">    {</a>
<a name="ln3640">        chaotic++;</a>
<a name="ln3641">    }</a>
<a name="ln3642"> </a>
<a name="ln3643">    if (is_shapeshifter() &amp;&amp; (flags &amp; MF_KNOWN_SHIFTER))</a>
<a name="ln3644">        chaotic++;</a>
<a name="ln3645"> </a>
<a name="ln3646">    // Knowing chaotic spells is not enough to make you &quot;essentially&quot;</a>
<a name="ln3647">    // chaotic (i.e., silver doesn't hurt you), but it does make you</a>
<a name="ln3648">    // chaotic enough for Zin's chaos recitation. Having chaotic</a>
<a name="ln3649">    // abilities (not actual spells) does mean you're truly changed</a>
<a name="ln3650">    // by chaos.</a>
<a name="ln3651">    if (has_chaotic_spell() &amp;&amp; (!is_actual_spellcaster()</a>
<a name="ln3652">                                || check_spells_god))</a>
<a name="ln3653">    {</a>
<a name="ln3654">        chaotic++;</a>
<a name="ln3655">    }</a>
<a name="ln3656"> </a>
<a name="ln3657">    if (has_attack_flavour(AF_MUTATE)</a>
<a name="ln3658">        || has_attack_flavour(AF_CHAOTIC))</a>
<a name="ln3659">    {</a>
<a name="ln3660">        chaotic++;</a>
<a name="ln3661">    }</a>
<a name="ln3662"> </a>
<a name="ln3663">    if (is_chaotic_god(god))</a>
<a name="ln3664">        chaotic++;</a>
<a name="ln3665"> </a>
<a name="ln3666">    if (is_chaotic_god(god) &amp;&amp; is_priest())</a>
<a name="ln3667">        chaotic++;</a>
<a name="ln3668"> </a>
<a name="ln3669">    return chaotic;</a>
<a name="ln3670">}</a>
<a name="ln3671"> </a>
<a name="ln3672">/** How chaotic is this monster really?</a>
<a name="ln3673"> *</a>
<a name="ln3674"> * @param check_spells_god whether to look at its spells and/or</a>
<a name="ln3675"> *        religion; silver damage does not.</a>
<a name="ln3676"> * @returns 0 if not chaotic, a larger number if so.</a>
<a name="ln3677"> */</a>
<a name="ln3678">int monster::how_chaotic(bool check_spells_god) const</a>
<a name="ln3679">{</a>
<a name="ln3680">    // Don't count known shapeshifters twice.</a>
<a name="ln3681">    if (is_shapeshifter() &amp;&amp; (flags &amp; MF_KNOWN_SHIFTER))</a>
<a name="ln3682">        return known_chaos(check_spells_god);</a>
<a name="ln3683">    else</a>
<a name="ln3684">        return is_shapeshifter() + known_chaos(check_spells_god);</a>
<a name="ln3685">}</a>
<a name="ln3686"> </a>
<a name="ln3687">bool monster::is_unbreathing() const</a>
<a name="ln3688">{</a>
<a name="ln3689">    return mons_is_unbreathing(type);</a>
<a name="ln3690">}</a>
<a name="ln3691"> </a>
<a name="ln3692">bool monster::is_insubstantial() const</a>
<a name="ln3693">{</a>
<a name="ln3694">    return mons_class_flag(type, M_INSUBSTANTIAL);</a>
<a name="ln3695">}</a>
<a name="ln3696"> </a>
<a name="ln3697">/// Is this monster completely immune to Damnation-flavoured damage?</a>
<a name="ln3698">bool monster::res_damnation() const</a>
<a name="ln3699">{</a>
<a name="ln3700">    return get_mons_resist(*this, MR_RES_DAMNATION);</a>
<a name="ln3701">}</a>
<a name="ln3702"> </a>
<a name="ln3703">int monster::res_fire() const</a>
<a name="ln3704">{</a>
<a name="ln3705">    int u = get_mons_resist(*this, MR_RES_FIRE);</a>
<a name="ln3706"> </a>
<a name="ln3707">    if (mons_itemuse(*this) &gt;= MONUSE_STARTING_EQUIPMENT)</a>
<a name="ln3708">    {</a>
<a name="ln3709">        u += scan_artefacts(ARTP_FIRE);</a>
<a name="ln3710"> </a>
<a name="ln3711">        const int armour    = inv[MSLOT_ARMOUR];</a>
<a name="ln3712">        const int shld      = inv[MSLOT_SHIELD];</a>
<a name="ln3713">        const int jewellery = inv[MSLOT_JEWELLERY];</a>
<a name="ln3714"> </a>
<a name="ln3715">        if (armour != NON_ITEM &amp;&amp; mitm[armour].base_type == OBJ_ARMOUR)</a>
<a name="ln3716">            u += get_armour_res_fire(mitm[armour], false);</a>
<a name="ln3717"> </a>
<a name="ln3718">        if (shld != NON_ITEM &amp;&amp; mitm[shld].base_type == OBJ_ARMOUR)</a>
<a name="ln3719">            u += get_armour_res_fire(mitm[shld], false);</a>
<a name="ln3720"> </a>
<a name="ln3721">        if (jewellery != NON_ITEM &amp;&amp; mitm[jewellery].base_type == OBJ_JEWELLERY)</a>
<a name="ln3722">            u += get_jewellery_res_fire(mitm[jewellery], false);</a>
<a name="ln3723"> </a>
<a name="ln3724">        const item_def *w = primary_weapon();</a>
<a name="ln3725">        if (w &amp;&amp; w-&gt;is_type(OBJ_STAVES, STAFF_FIRE))</a>
<a name="ln3726">            u++;</a>
<a name="ln3727">    }</a>
<a name="ln3728"> </a>
<a name="ln3729">    if (has_ench(ENCH_FIRE_VULN))</a>
<a name="ln3730">        u--;</a>
<a name="ln3731"> </a>
<a name="ln3732">    if (has_ench(ENCH_RESISTANCE))</a>
<a name="ln3733">        u++;</a>
<a name="ln3734"> </a>
<a name="ln3735">    if (u &lt; -3)</a>
<a name="ln3736">        u = -3;</a>
<a name="ln3737">    else if (u &gt; 3)</a>
<a name="ln3738">        u = 3;</a>
<a name="ln3739"> </a>
<a name="ln3740">    return u;</a>
<a name="ln3741">}</a>
<a name="ln3742"> </a>
<a name="ln3743">int monster::res_steam() const</a>
<a name="ln3744">{</a>
<a name="ln3745">    int res = get_mons_resist(*this, MR_RES_STEAM);</a>
<a name="ln3746">    if (wearing(EQ_BODY_ARMOUR, ARM_STEAM_DRAGON_ARMOUR))</a>
<a name="ln3747">        res += 3;</a>
<a name="ln3748"> </a>
<a name="ln3749">    res += (res_fire() + 1) / 2;</a>
<a name="ln3750"> </a>
<a name="ln3751">    if (res &gt; 3)</a>
<a name="ln3752">        res = 3;</a>
<a name="ln3753"> </a>
<a name="ln3754">    return res;</a>
<a name="ln3755">}</a>
<a name="ln3756"> </a>
<a name="ln3757">int monster::res_cold() const</a>
<a name="ln3758">{</a>
<a name="ln3759">    int u = get_mons_resist(*this, MR_RES_COLD);</a>
<a name="ln3760"> </a>
<a name="ln3761">    if (mons_itemuse(*this) &gt;= MONUSE_STARTING_EQUIPMENT)</a>
<a name="ln3762">    {</a>
<a name="ln3763">        u += scan_artefacts(ARTP_COLD);</a>
<a name="ln3764"> </a>
<a name="ln3765">        const int armour    = inv[MSLOT_ARMOUR];</a>
<a name="ln3766">        const int shld      = inv[MSLOT_SHIELD];</a>
<a name="ln3767">        const int jewellery = inv[MSLOT_JEWELLERY];</a>
<a name="ln3768"> </a>
<a name="ln3769">        if (armour != NON_ITEM &amp;&amp; mitm[armour].base_type == OBJ_ARMOUR)</a>
<a name="ln3770">            u += get_armour_res_cold(mitm[armour], false);</a>
<a name="ln3771"> </a>
<a name="ln3772">        if (shld != NON_ITEM &amp;&amp; mitm[shld].base_type == OBJ_ARMOUR)</a>
<a name="ln3773">            u += get_armour_res_cold(mitm[shld], false);</a>
<a name="ln3774"> </a>
<a name="ln3775">        if (jewellery != NON_ITEM &amp;&amp; mitm[jewellery].base_type == OBJ_JEWELLERY)</a>
<a name="ln3776">            u += get_jewellery_res_cold(mitm[jewellery], false);</a>
<a name="ln3777"> </a>
<a name="ln3778">        const item_def *w = primary_weapon();</a>
<a name="ln3779">        if (w &amp;&amp; w-&gt;is_type(OBJ_STAVES, STAFF_COLD))</a>
<a name="ln3780">            u++;</a>
<a name="ln3781">    }</a>
<a name="ln3782"> </a>
<a name="ln3783">    if (has_ench(ENCH_RESISTANCE))</a>
<a name="ln3784">        u++;</a>
<a name="ln3785"> </a>
<a name="ln3786">    if (u &lt; -3)</a>
<a name="ln3787">        u = -3;</a>
<a name="ln3788">    else if (u &gt; 3)</a>
<a name="ln3789">        u = 3;</a>
<a name="ln3790"> </a>
<a name="ln3791">    return u;</a>
<a name="ln3792">}</a>
<a name="ln3793"> </a>
<a name="ln3794">int monster::res_elec() const</a>
<a name="ln3795">{</a>
<a name="ln3796">    // This is a variable, not a player_xx() function, so can be above 1.</a>
<a name="ln3797">    int u = 0;</a>
<a name="ln3798"> </a>
<a name="ln3799">    u += get_mons_resist(*this, MR_RES_ELEC);</a>
<a name="ln3800"> </a>
<a name="ln3801">    // Don't bother checking equipment if the monster can't use it.</a>
<a name="ln3802">    if (mons_itemuse(*this) &gt;= MONUSE_STARTING_EQUIPMENT)</a>
<a name="ln3803">    {</a>
<a name="ln3804">        u += scan_artefacts(ARTP_ELECTRICITY);</a>
<a name="ln3805"> </a>
<a name="ln3806">        // No ego armour, but storm dragon.</a>
<a name="ln3807">        // Also no non-artefact rings at present,</a>
<a name="ln3808">        // but it doesn't hurt to be thorough.</a>
<a name="ln3809">        const int armour    = inv[MSLOT_ARMOUR];</a>
<a name="ln3810">        const int jewellery = inv[MSLOT_JEWELLERY];</a>
<a name="ln3811"> </a>
<a name="ln3812">        if (armour != NON_ITEM &amp;&amp; mitm[armour].base_type == OBJ_ARMOUR)</a>
<a name="ln3813">            u += get_armour_res_elec(mitm[armour], false);</a>
<a name="ln3814"> </a>
<a name="ln3815">        if (jewellery != NON_ITEM &amp;&amp; mitm[jewellery].base_type == OBJ_JEWELLERY)</a>
<a name="ln3816">            u += get_jewellery_res_elec(mitm[jewellery], false);</a>
<a name="ln3817"> </a>
<a name="ln3818">        const item_def *w = primary_weapon();</a>
<a name="ln3819">        if (w &amp;&amp; w-&gt;is_type(OBJ_STAVES, STAFF_AIR))</a>
<a name="ln3820">            u++;</a>
<a name="ln3821">    }</a>
<a name="ln3822"> </a>
<a name="ln3823">    if (has_ench(ENCH_RESISTANCE))</a>
<a name="ln3824">        u++;</a>
<a name="ln3825"> </a>
<a name="ln3826">    // Monsters can legitimately get multiple levels of electricity resistance.</a>
<a name="ln3827"> </a>
<a name="ln3828">    return u;</a>
<a name="ln3829">}</a>
<a name="ln3830"> </a>
<a name="ln3831">int monster::res_water_drowning() const</a>
<a name="ln3832">{</a>
<a name="ln3833">    int rw = 0;</a>
<a name="ln3834"> </a>
<a name="ln3835">    if (is_unbreathing())</a>
<a name="ln3836">        rw++;</a>
<a name="ln3837"> </a>
<a name="ln3838">    habitat_type hab = mons_habitat(*this);</a>
<a name="ln3839">    if (hab == HT_WATER || hab == HT_AMPHIBIOUS)</a>
<a name="ln3840">        rw++;</a>
<a name="ln3841"> </a>
<a name="ln3842">    if (get_mons_resist(*this, MR_VUL_WATER))</a>
<a name="ln3843">        rw--;</a>
<a name="ln3844"> </a>
<a name="ln3845">    return sgn(rw);</a>
<a name="ln3846">}</a>
<a name="ln3847"> </a>
<a name="ln3848">int monster::res_poison(bool temp) const</a>
<a name="ln3849">{</a>
<a name="ln3850">    int u = get_mons_resist(*this, MR_RES_POISON);</a>
<a name="ln3851"> </a>
<a name="ln3852">    if (const item_def* w = primary_weapon())</a>
<a name="ln3853">    {</a>
<a name="ln3854">        if (is_unrandom_artefact(*w, UNRAND_OLGREB))</a>
<a name="ln3855">            return 3;</a>
<a name="ln3856">    }</a>
<a name="ln3857"> </a>
<a name="ln3858">    if (temp &amp;&amp; has_ench(ENCH_POISON_VULN))</a>
<a name="ln3859">        u--;</a>
<a name="ln3860"> </a>
<a name="ln3861">    if (u &gt; 0)</a>
<a name="ln3862">        return u;</a>
<a name="ln3863"> </a>
<a name="ln3864">    if (mons_itemuse(*this) &gt;= MONUSE_STARTING_EQUIPMENT)</a>
<a name="ln3865">    {</a>
<a name="ln3866">        u += scan_artefacts(ARTP_POISON);</a>
<a name="ln3867"> </a>
<a name="ln3868">        const int armour    = inv[MSLOT_ARMOUR];</a>
<a name="ln3869">        const int shld      = inv[MSLOT_SHIELD];</a>
<a name="ln3870">        const int jewellery = inv[MSLOT_JEWELLERY];</a>
<a name="ln3871"> </a>
<a name="ln3872">        if (armour != NON_ITEM &amp;&amp; mitm[armour].base_type == OBJ_ARMOUR)</a>
<a name="ln3873">            u += get_armour_res_poison(mitm[armour], false);</a>
<a name="ln3874"> </a>
<a name="ln3875">        if (shld != NON_ITEM &amp;&amp; mitm[shld].base_type == OBJ_ARMOUR)</a>
<a name="ln3876">            u += get_armour_res_poison(mitm[shld], false);</a>
<a name="ln3877"> </a>
<a name="ln3878">        if (jewellery != NON_ITEM &amp;&amp; mitm[jewellery].base_type == OBJ_JEWELLERY)</a>
<a name="ln3879">            u += get_jewellery_res_poison(mitm[jewellery], false);</a>
<a name="ln3880"> </a>
<a name="ln3881">        const item_def *w = primary_weapon();</a>
<a name="ln3882">        if (w &amp;&amp; w-&gt;is_type(OBJ_STAVES, STAFF_POISON))</a>
<a name="ln3883">            u++;</a>
<a name="ln3884">    }</a>
<a name="ln3885"> </a>
<a name="ln3886">    if (has_ench(ENCH_RESISTANCE))</a>
<a name="ln3887">        u++;</a>
<a name="ln3888"> </a>
<a name="ln3889">    // Monsters can have multiple innate levels of poison resistance, but</a>
<a name="ln3890">    // like players, equipment doesn't stack.</a>
<a name="ln3891">    if (u &gt; 0)</a>
<a name="ln3892">        return 1;</a>
<a name="ln3893">    return u;</a>
<a name="ln3894">}</a>
<a name="ln3895"> </a>
<a name="ln3896">bool monster::res_sticky_flame() const</a>
<a name="ln3897">{</a>
<a name="ln3898">    return is_insubstantial() || get_mons_resist(*this, MR_RES_STICKY_FLAME) &gt; 0;</a>
<a name="ln3899">}</a>
<a name="ln3900"> </a>
<a name="ln3901">static rot_resistance _base_rot_resistance(const monster &amp;mons)</a>
<a name="ln3902">{</a>
<a name="ln3903">    const mon_holy_type holi = mons.holiness();</a>
<a name="ln3904"> </a>
<a name="ln3905">    // handle undead first so that multi-holiness undead get their due</a>
<a name="ln3906">    if (holi &amp; MH_UNDEAD)</a>
<a name="ln3907">    {</a>
<a name="ln3908">        if (mons_genus(mons.type) == MONS_GHOUL || mons.type == MONS_ZOMBIE)</a>
<a name="ln3909">            return ROT_RESIST_MUNDANE;</a>
<a name="ln3910">        return ROT_RESIST_FULL;</a>
<a name="ln3911">    }</a>
<a name="ln3912">    if (holi &amp; (MH_NATURAL | MH_PLANT))</a>
<a name="ln3913">        return ROT_RESIST_NONE; // was 1 for plants before. Gardening shows it should be -1</a>
<a name="ln3914">    if (holi &amp; (MH_HOLY | MH_DEMONIC))</a>
<a name="ln3915">        return ROT_RESIST_MUNDANE;</a>
<a name="ln3916">    if (mons.is_nonliving())</a>
<a name="ln3917">        return ROT_RESIST_FULL;</a>
<a name="ln3918">    if (mons.is_insubstantial())</a>
<a name="ln3919">        return ROT_RESIST_FULL;</a>
<a name="ln3920">    return ROT_RESIST_NONE;</a>
<a name="ln3921">}</a>
<a name="ln3922"> </a>
<a name="ln3923">rot_resistance monster::res_rotting(bool /*temp*/) const</a>
<a name="ln3924">{</a>
<a name="ln3925">    const rot_resistance res = _base_rot_resistance(*this);</a>
<a name="ln3926">    if (res != ROT_RESIST_NONE)</a>
<a name="ln3927">        return res;</a>
<a name="ln3928"> </a>
<a name="ln3929">    if (get_mons_resist(*this, MR_RES_ROTTING))</a>
<a name="ln3930">        return ROT_RESIST_MUNDANE;</a>
<a name="ln3931"> </a>
<a name="ln3932">    const item_def *armour = mslot_item(MSLOT_ARMOUR);</a>
<a name="ln3933">    if (armour &amp;&amp; is_unrandom_artefact(*armour, UNRAND_EMBRACE))</a>
<a name="ln3934">        return ROT_RESIST_MUNDANE;</a>
<a name="ln3935"> </a>
<a name="ln3936">    return res;</a>
<a name="ln3937">}</a>
<a name="ln3938"> </a>
<a name="ln3939">int monster::res_holy_energy() const</a>
<a name="ln3940">{</a>
<a name="ln3941">    if (type == MONS_PROFANE_SERVITOR)</a>
<a name="ln3942">        return 3;</a>
<a name="ln3943"> </a>
<a name="ln3944">    if (undead_or_demonic())</a>
<a name="ln3945">        return -1;</a>
<a name="ln3946"> </a>
<a name="ln3947">    if (is_holy()</a>
<a name="ln3948">        || is_good_god(god)</a>
<a name="ln3949">        || is_good_god(you.religion) &amp;&amp; is_follower(*this))</a>
<a name="ln3950">    {</a>
<a name="ln3951">        return 3;</a>
<a name="ln3952">    }</a>
<a name="ln3953"> </a>
<a name="ln3954">    return 0;</a>
<a name="ln3955">}</a>
<a name="ln3956"> </a>
<a name="ln3957">int monster::res_negative_energy(bool intrinsic_only) const</a>
<a name="ln3958">{</a>
<a name="ln3959">    // If you change this, also change get_mons_resists.</a>
<a name="ln3960">    if (!(holiness() &amp; MH_NATURAL))</a>
<a name="ln3961">        return 3;</a>
<a name="ln3962"> </a>
<a name="ln3963">    int u = get_mons_resist(*this, MR_RES_NEG);</a>
<a name="ln3964"> </a>
<a name="ln3965">    if (mons_itemuse(*this) &gt;= MONUSE_STARTING_EQUIPMENT &amp;&amp; !intrinsic_only)</a>
<a name="ln3966">    {</a>
<a name="ln3967">        u += scan_artefacts(ARTP_NEGATIVE_ENERGY);</a>
<a name="ln3968"> </a>
<a name="ln3969">        const int armour    = inv[MSLOT_ARMOUR];</a>
<a name="ln3970">        const int shld      = inv[MSLOT_SHIELD];</a>
<a name="ln3971">        const int jewellery = inv[MSLOT_JEWELLERY];</a>
<a name="ln3972"> </a>
<a name="ln3973">        if (armour != NON_ITEM &amp;&amp; mitm[armour].base_type == OBJ_ARMOUR)</a>
<a name="ln3974">            u += get_armour_life_protection(mitm[armour], false);</a>
<a name="ln3975"> </a>
<a name="ln3976">        if (shld != NON_ITEM &amp;&amp; mitm[shld].base_type == OBJ_ARMOUR)</a>
<a name="ln3977">            u += get_armour_life_protection(mitm[shld], false);</a>
<a name="ln3978"> </a>
<a name="ln3979">        if (jewellery != NON_ITEM &amp;&amp; mitm[jewellery].base_type == OBJ_JEWELLERY)</a>
<a name="ln3980">            u += get_jewellery_life_protection(mitm[jewellery], false);</a>
<a name="ln3981"> </a>
<a name="ln3982">        const item_def *w = primary_weapon();</a>
<a name="ln3983">        if (w &amp;&amp; w-&gt;is_type(OBJ_STAVES, STAFF_DEATH))</a>
<a name="ln3984">            u++;</a>
<a name="ln3985">    }</a>
<a name="ln3986"> </a>
<a name="ln3987">    if (u &gt; 3)</a>
<a name="ln3988">        u = 3;</a>
<a name="ln3989"> </a>
<a name="ln3990">    return u;</a>
<a name="ln3991">}</a>
<a name="ln3992"> </a>
<a name="ln3993">bool monster::res_torment() const</a>
<a name="ln3994">{</a>
<a name="ln3995">    const mon_holy_type holy = holiness();</a>
<a name="ln3996">    return holy &amp; (MH_UNDEAD | MH_DEMONIC | MH_PLANT | MH_NONLIVING)</a>
<a name="ln3997">           || get_mons_resist(*this, MR_RES_TORMENT) &gt; 0;</a>
<a name="ln3998">}</a>
<a name="ln3999"> </a>
<a name="ln4000">bool monster::res_tornado() const</a>
<a name="ln4001">{</a>
<a name="ln4002">    return has_ench(ENCH_TORNADO)</a>
<a name="ln4003">           || has_ench(ENCH_VORTEX)</a>
<a name="ln4004">           || get_mons_resist(*this, MR_RES_TORNADO) &gt; 0;</a>
<a name="ln4005">}</a>
<a name="ln4006"> </a>
<a name="ln4007">bool monster::res_petrify(bool /*temp*/) const</a>
<a name="ln4008">{</a>
<a name="ln4009">    return is_insubstantial() || get_mons_resist(*this, MR_RES_PETRIFY) &gt; 0;</a>
<a name="ln4010">}</a>
<a name="ln4011"> </a>
<a name="ln4012">int monster::res_constrict() const</a>
<a name="ln4013">{</a>
<a name="ln4014">    // 3 is immunity, 1 or 2 reduces damage</a>
<a name="ln4015">    if (is_insubstantial())</a>
<a name="ln4016">        return 3;</a>
<a name="ln4017">    if (mons_genus(type) == MONS_JELLY)</a>
<a name="ln4018">        return 3;</a>
<a name="ln4019">    if (is_spiny())</a>
<a name="ln4020">        return 3;</a>
<a name="ln4021"> </a>
<a name="ln4022">    return 0;</a>
<a name="ln4023">}</a>
<a name="ln4024"> </a>
<a name="ln4025">bool monster::res_corr(bool calc_unid, bool items) const</a>
<a name="ln4026">{</a>
<a name="ln4027">    if (get_mons_resist(*this, MR_RES_ACID) &gt; 0)</a>
<a name="ln4028">        return true;</a>
<a name="ln4029"> </a>
<a name="ln4030">    return actor::res_corr(calc_unid, items);</a>
<a name="ln4031">}</a>
<a name="ln4032"> </a>
<a name="ln4033">int monster::res_acid(bool calc_unid) const</a>
<a name="ln4034">{</a>
<a name="ln4035">    int u = max(get_mons_resist(*this, MR_RES_ACID), (int)actor::res_corr(calc_unid));</a>
<a name="ln4036"> </a>
<a name="ln4037">    if (has_ench(ENCH_RESISTANCE))</a>
<a name="ln4038">        u++;</a>
<a name="ln4039"> </a>
<a name="ln4040">    return u;</a>
<a name="ln4041">}</a>
<a name="ln4042"> </a>
<a name="ln4043">/**</a>
<a name="ln4044"> * What MR (resistance to hexes, etc) does this monster have?</a>
<a name="ln4045"> *</a>
<a name="ln4046"> * @param calc_unid     Whether to include items &amp; effects the player may not</a>
<a name="ln4047"> *                      know about.</a>
<a name="ln4048"> * @return              The monster's magic resistance value.</a>
<a name="ln4049"> */</a>
<a name="ln4050">int monster::res_magic(bool calc_unid) const</a>
<a name="ln4051">{</a>
<a name="ln4052">    if (mons_immune_magic(*this))</a>
<a name="ln4053">        return MAG_IMMUNE;</a>
<a name="ln4054"> </a>
<a name="ln4055">    const int type_mr = (get_monster_data(type))-&gt;resist_magic;</a>
<a name="ln4056">    // Negative values get multiplied with monster hit dice.</a>
<a name="ln4057">    int u = type_mr &lt; 0 ?</a>
<a name="ln4058">                get_hit_dice() * -type_mr * 4 / 3 :</a>
<a name="ln4059">                mons_class_res_magic(type, base_monster);</a>
<a name="ln4060"> </a>
<a name="ln4061">    // Hepliaklqana ancestors scale with xl.</a>
<a name="ln4062">    if (mons_is_hepliaklqana_ancestor(type))</a>
<a name="ln4063">        u = get_experience_level() * get_experience_level() / 2; // 0-160ish</a>
<a name="ln4064"> </a>
<a name="ln4065">    // Draining/malmutation reduce monster base MR proportionately.</a>
<a name="ln4066">    const int HD = get_hit_dice();</a>
<a name="ln4067">    if (HD &lt; get_experience_level())</a>
<a name="ln4068">        u = u * HD / get_experience_level();</a>
<a name="ln4069"> </a>
<a name="ln4070">    // Resistance from artefact properties.</a>
<a name="ln4071">    u += 40 * scan_artefacts(ARTP_MAGIC_RESISTANCE);</a>
<a name="ln4072"> </a>
<a name="ln4073">    // Ego equipment resistance.</a>
<a name="ln4074">    const int armour    = inv[MSLOT_ARMOUR];</a>
<a name="ln4075">    const int shld      = inv[MSLOT_SHIELD];</a>
<a name="ln4076">    const int jewellery = inv[MSLOT_JEWELLERY];</a>
<a name="ln4077"> </a>
<a name="ln4078">    // XXX: should also include artefacts mr props</a>
<a name="ln4079">    // (remove &quot;, false&quot; and add appropriate flag checks for calc_unid)</a>
<a name="ln4080"> </a>
<a name="ln4081">    if (armour != NON_ITEM &amp;&amp; mitm[armour].base_type == OBJ_ARMOUR</a>
<a name="ln4082">        &amp;&amp; (calc_unid || (mitm[armour].flags &amp; ISFLAG_KNOW_TYPE)))</a>
<a name="ln4083">    {</a>
<a name="ln4084">        u += get_armour_res_magic(mitm[armour], false);</a>
<a name="ln4085">    }</a>
<a name="ln4086"> </a>
<a name="ln4087">    if (shld != NON_ITEM &amp;&amp; mitm[shld].base_type == OBJ_ARMOUR</a>
<a name="ln4088">        &amp;&amp; (calc_unid || (mitm[shld].flags &amp; ISFLAG_KNOW_TYPE)))</a>
<a name="ln4089">    {</a>
<a name="ln4090">        u += get_armour_res_magic(mitm[shld], false);</a>
<a name="ln4091">    }</a>
<a name="ln4092"> </a>
<a name="ln4093">    if (jewellery != NON_ITEM &amp;&amp; mitm[jewellery].base_type == OBJ_JEWELLERY</a>
<a name="ln4094">        &amp;&amp; calc_unid) // XXX: can you ever see monster jewellery?</a>
<a name="ln4095">    {</a>
<a name="ln4096">        u += get_jewellery_res_magic(mitm[jewellery], false);</a>
<a name="ln4097">    }</a>
<a name="ln4098"> </a>
<a name="ln4099">    if (has_ench(ENCH_RAISED_MR)) //trog's hand</a>
<a name="ln4100">        u += 80;</a>
<a name="ln4101"> </a>
<a name="ln4102">    if (has_ench(ENCH_LOWERED_MR))</a>
<a name="ln4103">        u /= 2;</a>
<a name="ln4104"> </a>
<a name="ln4105">    if (u &lt; 0)</a>
<a name="ln4106">        u = 0;</a>
<a name="ln4107"> </a>
<a name="ln4108">    return u;</a>
<a name="ln4109">}</a>
<a name="ln4110"> </a>
<a name="ln4111">bool monster::no_tele(bool calc_unid, bool /*permit_id*/, bool /*blinking*/) const</a>
<a name="ln4112">{</a>
<a name="ln4113">    // Plants can't survive without roots, so it's either this or auto-kill.</a>
<a name="ln4114">    // Statues have pedestals so moving them is weird.</a>
<a name="ln4115">    if (mons_class_is_stationary(type))</a>
<a name="ln4116">        return true;</a>
<a name="ln4117"> </a>
<a name="ln4118">    if (mons_is_projectile(type))</a>
<a name="ln4119">        return true;</a>
<a name="ln4120"> </a>
<a name="ln4121">    // Might be better to teleport the whole kraken instead...</a>
<a name="ln4122">    if (mons_is_tentacle_or_tentacle_segment(type))</a>
<a name="ln4123">        return true;</a>
<a name="ln4124"> </a>
<a name="ln4125">    if (stasis())</a>
<a name="ln4126">        return true;</a>
<a name="ln4127"> </a>
<a name="ln4128">    // TODO: permit_id</a>
<a name="ln4129">    if (has_notele_item(calc_unid))</a>
<a name="ln4130">        return true;</a>
<a name="ln4131"> </a>
<a name="ln4132">    if (has_ench(ENCH_DIMENSION_ANCHOR))</a>
<a name="ln4133">        return true;</a>
<a name="ln4134"> </a>
<a name="ln4135">    return false;</a>
<a name="ln4136">}</a>
<a name="ln4137"> </a>
<a name="ln4138">bool monster::antimagic_susceptible() const</a>
<a name="ln4139">{</a>
<a name="ln4140">    return search_slots([] (const mon_spell_slot&amp; slot)</a>
<a name="ln4141">                        { return bool(slot.flags &amp; MON_SPELL_ANTIMAGIC_MASK); });</a>
<a name="ln4142">}</a>
<a name="ln4143"> </a>
<a name="ln4144">bool monster::airborne() const</a>
<a name="ln4145">{</a>
<a name="ln4146">    // For dancing weapons, this function can get called before their</a>
<a name="ln4147">    // ghost_demon is created, so check for a nullptr ghost. -cao</a>
<a name="ln4148">    return mons_is_ghost_demon(type) &amp;&amp; ghost &amp;&amp; ghost-&gt;flies</a>
<a name="ln4149">           // check both so spectral humans and zombified dragons both fly</a>
<a name="ln4150">           || mons_class_flag(mons_base_type(*this), M_FLIES)</a>
<a name="ln4151">           || mons_class_flag(type, M_FLIES)</a>
<a name="ln4152">           || has_facet(BF_BAT)</a>
<a name="ln4153">           || scan_artefacts(ARTP_FLY) &gt; 0</a>
<a name="ln4154">           || mslot_item(MSLOT_ARMOUR)</a>
<a name="ln4155">              &amp;&amp; mslot_item(MSLOT_ARMOUR)-&gt;base_type == OBJ_ARMOUR</a>
<a name="ln4156">              &amp;&amp; mslot_item(MSLOT_ARMOUR)-&gt;brand == SPARM_FLYING</a>
<a name="ln4157">           || mslot_item(MSLOT_JEWELLERY)</a>
<a name="ln4158">              &amp;&amp; mslot_item(MSLOT_JEWELLERY)-&gt;is_type(OBJ_JEWELLERY, RING_FLIGHT)</a>
<a name="ln4159">           || has_ench(ENCH_FLIGHT);</a>
<a name="ln4160">}</a>
<a name="ln4161"> </a>
<a name="ln4162">bool monster::is_banished() const</a>
<a name="ln4163">{</a>
<a name="ln4164">    return !alive() &amp;&amp; flags &amp; MF_BANISHED;</a>
<a name="ln4165">}</a>
<a name="ln4166"> </a>
<a name="ln4167">monster_type monster::mons_species(bool zombie_base) const</a>
<a name="ln4168">{</a>
<a name="ln4169">    if (zombie_base &amp;&amp; mons_class_is_zombified(type))</a>
<a name="ln4170">        return ::mons_species(base_monster);</a>
<a name="ln4171">    return ::mons_species(type);</a>
<a name="ln4172">}</a>
<a name="ln4173"> </a>
<a name="ln4174">bool monster::poison(actor *agent, int amount, bool force)</a>
<a name="ln4175">{</a>
<a name="ln4176">    if (amount &lt;= 0)</a>
<a name="ln4177">        return false;</a>
<a name="ln4178"> </a>
<a name="ln4179">    // Scale poison down for monsters.</a>
<a name="ln4180">    amount = 1 + amount / 7;</a>
<a name="ln4181"> </a>
<a name="ln4182">    return poison_monster(this, agent, amount, force);</a>
<a name="ln4183">}</a>
<a name="ln4184"> </a>
<a name="ln4185">int monster::skill(skill_type sk, int scale, bool /*real*/, bool /*drained*/, bool /*temp*/) const</a>
<a name="ln4186">{</a>
<a name="ln4187">    // Let spectral weapons have necromancy skill for pain brand.</a>
<a name="ln4188">    if (mons_intel(*this) &lt; I_HUMAN &amp;&amp; !mons_is_avatar(type))</a>
<a name="ln4189">        return 0;</a>
<a name="ln4190"> </a>
<a name="ln4191">    const int hd = scale * get_hit_dice();</a>
<a name="ln4192">    int ret;</a>
<a name="ln4193">    switch (sk)</a>
<a name="ln4194">    {</a>
<a name="ln4195">    case SK_EVOCATIONS:</a>
<a name="ln4196">        return hd;</a>
<a name="ln4197"> </a>
<a name="ln4198">    case SK_NECROMANCY:</a>
<a name="ln4199">        return (has_spell_of_type(spschool::necromancy)) ? hd : hd/2;</a>
<a name="ln4200"> </a>
<a name="ln4201">    case SK_POISON_MAGIC:</a>
<a name="ln4202">    case SK_FIRE_MAGIC:</a>
<a name="ln4203">    case SK_ICE_MAGIC:</a>
<a name="ln4204">    case SK_EARTH_MAGIC:</a>
<a name="ln4205">    case SK_AIR_MAGIC:</a>
<a name="ln4206">    case SK_SUMMONINGS:</a>
<a name="ln4207">        return is_actual_spellcaster() ? hd : hd / 3;</a>
<a name="ln4208"> </a>
<a name="ln4209">    // Weapon skills for spectral weapon</a>
<a name="ln4210">    case SK_SHORT_BLADES:</a>
<a name="ln4211">    case SK_LONG_BLADES:</a>
<a name="ln4212">    case SK_AXES:</a>
<a name="ln4213">    case SK_MACES_FLAILS:</a>
<a name="ln4214">    case SK_POLEARMS:</a>
<a name="ln4215">    case SK_STAVES:</a>
<a name="ln4216">        ret = hd;</a>
<a name="ln4217">        if (weapon()</a>
<a name="ln4218">            &amp;&amp; sk == item_attack_skill(*weapon())</a>
<a name="ln4219">            &amp;&amp; _is_signature_weapon(this, *weapon()))</a>
<a name="ln4220">        {</a>
<a name="ln4221">            // generally slightly skilled if it's a signature weapon</a>
<a name="ln4222">            ret = ret * 5 / 4;</a>
<a name="ln4223">        }</a>
<a name="ln4224">        return ret;</a>
<a name="ln4225"> </a>
<a name="ln4226">    default:</a>
<a name="ln4227">        return 0;</a>
<a name="ln4228">    }</a>
<a name="ln4229">}</a>
<a name="ln4230"> </a>
<a name="ln4231">/**</a>
<a name="ln4232"> * Move a monster to an approximate location.</a>
<a name="ln4233"> *</a>
<a name="ln4234"> * @param p the position to end up near.</a>
<a name="ln4235"> * @return whether it tried to move the monster at all.</a>
<a name="ln4236"> */</a>
<a name="ln4237">bool monster::shift(coord_def p)</a>
<a name="ln4238">{</a>
<a name="ln4239">    coord_def result;</a>
<a name="ln4240"> </a>
<a name="ln4241">    int count = 0;</a>
<a name="ln4242"> </a>
<a name="ln4243">    if (p.origin())</a>
<a name="ln4244">        p = pos();</a>
<a name="ln4245"> </a>
<a name="ln4246">    for (adjacent_iterator ai(p); ai; ++ai)</a>
<a name="ln4247">    {</a>
<a name="ln4248">        // Don't drop on anything but vanilla floor right now.</a>
<a name="ln4249">        if (grd(*ai) != DNGN_FLOOR)</a>
<a name="ln4250">            continue;</a>
<a name="ln4251"> </a>
<a name="ln4252">        if (actor_at(*ai))</a>
<a name="ln4253">            continue;</a>
<a name="ln4254"> </a>
<a name="ln4255">        if (one_chance_in(++count))</a>
<a name="ln4256">            result = *ai;</a>
<a name="ln4257">    }</a>
<a name="ln4258"> </a>
<a name="ln4259">    if (count &gt; 0)</a>
<a name="ln4260">        move_to_pos(result);</a>
<a name="ln4261"> </a>
<a name="ln4262">    return count &gt; 0;</a>
<a name="ln4263">}</a>
<a name="ln4264">void monster::blink()</a>
<a name="ln4265">{</a>
<a name="ln4266">    monster_blink(this);</a>
<a name="ln4267">}</a>
<a name="ln4268"> </a>
<a name="ln4269">void monster::teleport(bool now, bool)</a>
<a name="ln4270">{</a>
<a name="ln4271">    monster_teleport(this, now, false);</a>
<a name="ln4272">}</a>
<a name="ln4273"> </a>
<a name="ln4274">bool monster::alive() const</a>
<a name="ln4275">{</a>
<a name="ln4276">    return hit_points &gt; 0 &amp;&amp; type != MONS_NO_MONSTER;</a>
<a name="ln4277">}</a>
<a name="ln4278"> </a>
<a name="ln4279">god_type monster::deity() const</a>
<a name="ln4280">{</a>
<a name="ln4281">    return god;</a>
<a name="ln4282">}</a>
<a name="ln4283"> </a>
<a name="ln4284">bool monster::drain_exp(actor *agent, bool quiet, int /*pow*/)</a>
<a name="ln4285">{</a>
<a name="ln4286">    if (res_negative_energy() &gt;= 3)</a>
<a name="ln4287">        return false;</a>
<a name="ln4288"> </a>
<a name="ln4289">    if (!quiet &amp;&amp; you.can_see(*this))</a>
<a name="ln4290">        mprf(&quot;%s is drained!&quot;, name(DESC_THE).c_str());</a>
<a name="ln4291"> </a>
<a name="ln4292">    // If quiet, don't clean up the monster in order to credit properly.</a>
<a name="ln4293">    hurt(agent, 2 + random2(3), BEAM_NEG, KILLED_BY_DRAINING, &quot;&quot;, &quot;&quot;, !quiet);</a>
<a name="ln4294"> </a>
<a name="ln4295">    if (alive())</a>
<a name="ln4296">    {</a>
<a name="ln4297">        int dur = 200 + random2(100);</a>
<a name="ln4298">        dur = min(dur, 300 - get_ench(ENCH_DRAINED).duration - random2(50));</a>
<a name="ln4299"> </a>
<a name="ln4300">        if (res_negative_energy())</a>
<a name="ln4301">            dur /= (res_negative_energy() * 2);</a>
<a name="ln4302"> </a>
<a name="ln4303">        const mon_enchant drain_ench = mon_enchant(ENCH_DRAINED, 1, agent,</a>
<a name="ln4304">                                                   dur);</a>
<a name="ln4305">        add_ench(drain_ench);</a>
<a name="ln4306">    }</a>
<a name="ln4307"> </a>
<a name="ln4308">    return true;</a>
<a name="ln4309">}</a>
<a name="ln4310"> </a>
<a name="ln4311">bool monster::rot(actor *agent, int amount, bool quiet, bool no_cleanup)</a>
<a name="ln4312">{</a>
<a name="ln4313">    if (res_rotting() || amount &lt;= 0)</a>
<a name="ln4314">        return false;</a>
<a name="ln4315"> </a>
<a name="ln4316">    if (!quiet &amp;&amp; you.can_see(*this))</a>
<a name="ln4317">        mprf(&quot;%s looks less resilient!&quot;, name(DESC_THE).c_str());</a>
<a name="ln4318"> </a>
<a name="ln4319">    // If requested, don't clean up the monster in order to credit properly.</a>
<a name="ln4320">    hurt(agent, amount, BEAM_MISSILE, KILLED_BY_BEAM, &quot;&quot;, &quot;&quot;, !no_cleanup);</a>
<a name="ln4321"> </a>
<a name="ln4322">    if (alive())</a>
<a name="ln4323">    {</a>
<a name="ln4324">        max_hit_points -= amount * 2;</a>
<a name="ln4325">        hit_points = min(max_hit_points, hit_points);</a>
<a name="ln4326"> </a>
<a name="ln4327">        // Clean up the monster if that killed it (unless we shouldn't).</a>
<a name="ln4328">        if (!no_cleanup &amp;&amp; max_hit_points &lt;= 0)</a>
<a name="ln4329">            hurt(agent, 0, BEAM_MISSILE, KILLED_BY_BEAM);</a>
<a name="ln4330">    }</a>
<a name="ln4331"> </a>
<a name="ln4332">    return true;</a>
<a name="ln4333">}</a>
<a name="ln4334"> </a>
<a name="ln4335">bool monster::corrode_equipment(const char* corrosion_source, int degree)</a>
<a name="ln4336">{</a>
<a name="ln4337">    // Don't corrode spectral weapons or temporary items.</a>
<a name="ln4338">    if (mons_is_avatar(type) || type == MONS_PLAYER_SHADOW)</a>
<a name="ln4339">        return false;</a>
<a name="ln4340"> </a>
<a name="ln4341">    // rCorr protects against 50% of corrosion.</a>
<a name="ln4342">    // As long as degree is at least 1, we'll apply the status once, because</a>
<a name="ln4343">    // it doesn't look to me like applying it more times does anything.</a>
<a name="ln4344">    // If I'm wrong, we should fix that.</a>
<a name="ln4345">    if (res_corr())</a>
<a name="ln4346">    {</a>
<a name="ln4347">        degree = binomial(degree, 50);</a>
<a name="ln4348">        if (!degree)</a>
<a name="ln4349">        {</a>
<a name="ln4350">            dprf(&quot;rCorr protects.&quot;);</a>
<a name="ln4351">            return false;</a>
<a name="ln4352">        }</a>
<a name="ln4353">    }</a>
<a name="ln4354"> </a>
<a name="ln4355">    if (you.see_cell(pos()))</a>
<a name="ln4356">    {</a>
<a name="ln4357">        if (!has_ench(ENCH_CORROSION))</a>
<a name="ln4358">            mprf(&quot;%s corrodes %s!&quot;, corrosion_source, name(DESC_THE).c_str());</a>
<a name="ln4359">        else</a>
<a name="ln4360">            mprf(&quot;%s seems to be corroded for longer.&quot;, name(DESC_THE).c_str());</a>
<a name="ln4361">    }</a>
<a name="ln4362"> </a>
<a name="ln4363">    add_ench(mon_enchant(ENCH_CORROSION, 0));</a>
<a name="ln4364">    return true;</a>
<a name="ln4365">}</a>
<a name="ln4366"> </a>
<a name="ln4367">/**</a>
<a name="ln4368"> * Attempts to apply corrosion to a monster.</a>
<a name="ln4369"> */</a>
<a name="ln4370">void monster::splash_with_acid(const actor* evildoer, int /*acid_strength*/,</a>
<a name="ln4371">                               bool /*allow_corrosion*/, const char* /*hurt_msg*/)</a>
<a name="ln4372">{</a>
<a name="ln4373">    // Splashing with acid shouldn't do anything to immune targets</a>
<a name="ln4374">    if (res_acid() == 3)</a>
<a name="ln4375">        return;</a>
<a name="ln4376"> </a>
<a name="ln4377">    const int dam = roll_dice(2, 4);</a>
<a name="ln4378">    const int post_res_dam = resist_adjust_damage(this, BEAM_ACID, dam);</a>
<a name="ln4379"> </a>
<a name="ln4380">    if (this-&gt;observable())</a>
<a name="ln4381">    {</a>
<a name="ln4382">        mprf(&quot;%s is splashed with acid%s&quot;, this-&gt;name(DESC_THE).c_str(),</a>
<a name="ln4383">             attack_strength_punctuation(post_res_dam).c_str());</a>
<a name="ln4384">    }</a>
<a name="ln4385"> </a>
<a name="ln4386">    if (!one_chance_in(3))</a>
<a name="ln4387">        corrode_equipment();</a>
<a name="ln4388"> </a>
<a name="ln4389">    if (post_res_dam &gt; 0)</a>
<a name="ln4390">        hurt(evildoer, post_res_dam, BEAM_ACID, KILLED_BY_ACID);</a>
<a name="ln4391">}</a>
<a name="ln4392"> </a>
<a name="ln4393">int monster::hurt(const actor *agent, int amount, beam_type flavour,</a>
<a name="ln4394">                   kill_method_type kill_type, string /*source*/,</a>
<a name="ln4395">                   string /*aux*/, bool cleanup_dead, bool attacker_effects)</a>
<a name="ln4396">{</a>
<a name="ln4397">    if (mons_is_projectile(type)</a>
<a name="ln4398">        || mid == MID_ANON_FRIEND</a>
<a name="ln4399">        || type == MONS_PLAYER_SHADOW)</a>
<a name="ln4400">    {</a>
<a name="ln4401">        return 0;</a>
<a name="ln4402">    }</a>
<a name="ln4403"> </a>
<a name="ln4404">    if (alive())</a>
<a name="ln4405">    {</a>
<a name="ln4406">        if (amount != INSTANT_DEATH</a>
<a name="ln4407">            &amp;&amp; mons_species(true) == MONS_DEEP_DWARF)</a>
<a name="ln4408">        {</a>
<a name="ln4409">            // Deep Dwarves get to shave _any_ hp loss. Player version:</a>
<a name="ln4410">            int shave = 1 + random2(2 + random2(1 + get_hit_dice() / 3));</a>
<a name="ln4411">            dprf(&quot;(mon) HP shaved: %d.&quot;, shave);</a>
<a name="ln4412">            amount -= shave;</a>
<a name="ln4413">            if (amount &lt;= 0)</a>
<a name="ln4414">                return 0;</a>
<a name="ln4415">        }</a>
<a name="ln4416"> </a>
<a name="ln4417">        if (amount != INSTANT_DEATH)</a>
<a name="ln4418">        {</a>
<a name="ln4419">            if (petrified())</a>
<a name="ln4420">                amount /= 2;</a>
<a name="ln4421">            else if (petrifying())</a>
<a name="ln4422">                amount = amount * 2 / 3;</a>
<a name="ln4423">        }</a>
<a name="ln4424"> </a>
<a name="ln4425">        if (amount != INSTANT_DEATH &amp;&amp; has_ench(ENCH_INJURY_BOND))</a>
<a name="ln4426">        {</a>
<a name="ln4427">            actor* guardian = get_ench(ENCH_INJURY_BOND).agent();</a>
<a name="ln4428">            if (guardian &amp;&amp; guardian-&gt;alive() &amp;&amp; mons_aligned(guardian, this))</a>
<a name="ln4429">            {</a>
<a name="ln4430">                int split = amount / 2;</a>
<a name="ln4431">                if (split &gt; 0)</a>
<a name="ln4432">                {</a>
<a name="ln4433">                    deferred_damage_fineff::schedule(agent, guardian,</a>
<a name="ln4434">                                                     split, false);</a>
<a name="ln4435">                    amount -= split;</a>
<a name="ln4436">                }</a>
<a name="ln4437">            }</a>
<a name="ln4438">        }</a>
<a name="ln4439"> </a>
<a name="ln4440">        if (amount == INSTANT_DEATH)</a>
<a name="ln4441">            amount = hit_points;</a>
<a name="ln4442">        else if (get_hit_dice() &lt;= 0)</a>
<a name="ln4443">            amount = hit_points;</a>
<a name="ln4444">        else if (amount &lt;= 0 &amp;&amp; hit_points &lt;= max_hit_points)</a>
<a name="ln4445">            return 0;</a>
<a name="ln4446"> </a>
<a name="ln4447">        // Apply damage multipliers for amulet of harm</a>
<a name="ln4448">        if (amount != INSTANT_DEATH)</a>
<a name="ln4449">        {</a>
<a name="ln4450">            // +30% damage when the opponent has harm</a>
<a name="ln4451">            if (agent &amp;&amp; agent-&gt;extra_harm())</a>
<a name="ln4452">                amount = amount * 13 / 10;</a>
<a name="ln4453">            // +20% damage when self has harm</a>
<a name="ln4454">            else if (extra_harm())</a>
<a name="ln4455">                amount = amount * 6 / 5;</a>
<a name="ln4456">        }</a>
<a name="ln4457"> </a>
<a name="ln4458">        // Apply damage multipliers for quad damage</a>
<a name="ln4459">        if (attacker_effects &amp;&amp; agent &amp;&amp; agent-&gt;is_player()</a>
<a name="ln4460">            &amp;&amp; you.duration[DUR_QUAD_DAMAGE]</a>
<a name="ln4461">            &amp;&amp; flavour != BEAM_TORMENT_DAMAGE)</a>
<a name="ln4462">        {</a>
<a name="ln4463">            amount *= 4;</a>
<a name="ln4464">            if (amount &gt; hit_points + 50)</a>
<a name="ln4465">                flags |= MF_EXPLODE_KILL;</a>
<a name="ln4466">        }</a>
<a name="ln4467"> </a>
<a name="ln4468">        amount = min(amount, hit_points);</a>
<a name="ln4469">        hit_points -= amount;</a>
<a name="ln4470"> </a>
<a name="ln4471">        if (hit_points &gt; max_hit_points)</a>
<a name="ln4472">        {</a>
<a name="ln4473">            amount    += hit_points - max_hit_points;</a>
<a name="ln4474">            hit_points = max_hit_points;</a>
<a name="ln4475">        }</a>
<a name="ln4476"> </a>
<a name="ln4477">        if (flavour == BEAM_DEVASTATION || flavour == BEAM_DISINTEGRATION)</a>
<a name="ln4478">        {</a>
<a name="ln4479">            if (can_bleed())</a>
<a name="ln4480">                blood_spray(pos(), type, amount / 5);</a>
<a name="ln4481"> </a>
<a name="ln4482">            if (!alive())</a>
<a name="ln4483">                flags |= MF_EXPLODE_KILL;</a>
<a name="ln4484">        }</a>
<a name="ln4485"> </a>
<a name="ln4486">        // Hurt conducts -- pain bond is exempted for balance/gameplay reasons.</a>
<a name="ln4487">        // Damage over time effects are excluded for similar reasons.</a>
<a name="ln4488">        if (agent &amp;&amp; agent-&gt;is_player() &amp;&amp; mons_gives_xp(*this, *agent)</a>
<a name="ln4489">            &amp;&amp; flavour != BEAM_SHARED_PAIN</a>
<a name="ln4490">            &amp;&amp; flavour != BEAM_STICKY_FLAME</a>
<a name="ln4491">            &amp;&amp; kill_type != KILLED_BY_POISON</a>
<a name="ln4492">            &amp;&amp; kill_type != KILLED_BY_CLOUD)</a>
<a name="ln4493">        {</a>
<a name="ln4494">           did_hurt_conduct(DID_HURT_FOE, *this, amount);</a>
<a name="ln4495">        }</a>
<a name="ln4496"> </a>
<a name="ln4497">        // Handle pain bond behaviour here. Is technically passive damage.</a>
<a name="ln4498">        // radiate_pain_bond may do additional damage by recursively looping</a>
<a name="ln4499">        // back to the original trigger.</a>
<a name="ln4500">        if (has_ench(ENCH_PAIN_BOND) &amp;&amp; flavour != BEAM_SHARED_PAIN)</a>
<a name="ln4501">        {</a>
<a name="ln4502">            int hp_before_pain_bond = hit_points;</a>
<a name="ln4503">            radiate_pain_bond(*this, amount, this);</a>
<a name="ln4504">            amount += max(hp_before_pain_bond - hit_points, 0);</a>
<a name="ln4505">        }</a>
<a name="ln4506"> </a>
<a name="ln4507">        // Allow the victim to exhibit passive damage behaviour (e.g.</a>
<a name="ln4508">        // the Royal Jelly or Uskayaw's Pain Bond).</a>
<a name="ln4509">        react_to_damage(agent, amount, flavour);</a>
<a name="ln4510"> </a>
<a name="ln4511">        // Don't mirror Yredelemnul's effects (in particular don't mirror</a>
<a name="ln4512">        // mirrored damage).</a>
<a name="ln4513">        if (has_ench(ENCH_MIRROR_DAMAGE)</a>
<a name="ln4514">            &amp;&amp; crawl_state.which_god_acting() != GOD_YREDELEMNUL)</a>
<a name="ln4515">        {</a>
<a name="ln4516">            // ensure that YOU_FAULTLESS is converted to `you`. this may still</a>
<a name="ln4517">            // fail e.g. when the damage is from a vault-created cloud</a>
<a name="ln4518">            if (auto valid_agent = ensure_valid_actor(agent))</a>
<a name="ln4519">                mirror_damage_fineff::schedule(valid_agent, this, amount * 2 / 3);</a>
<a name="ln4520">        }</a>
<a name="ln4521"> </a>
<a name="ln4522">        blame_damage(agent, amount);</a>
<a name="ln4523">    }</a>
<a name="ln4524"> </a>
<a name="ln4525">    if (cleanup_dead &amp;&amp; (hit_points &lt;= 0 || get_hit_dice() &lt;= 0)</a>
<a name="ln4526">        &amp;&amp; type != MONS_NO_MONSTER)</a>
<a name="ln4527">    {</a>
<a name="ln4528">        if (agent == nullptr)</a>
<a name="ln4529">            monster_die(*this, KILL_MISC, NON_MONSTER);</a>
<a name="ln4530">        else if (agent-&gt;is_player())</a>
<a name="ln4531">            monster_die(*this, KILL_YOU, NON_MONSTER);</a>
<a name="ln4532">        else</a>
<a name="ln4533">            monster_die(*this, KILL_MON, agent-&gt;mindex());</a>
<a name="ln4534">    }</a>
<a name="ln4535"> </a>
<a name="ln4536">    return amount;</a>
<a name="ln4537">}</a>
<a name="ln4538"> </a>
<a name="ln4539">void monster::confuse(actor *atk, int strength)</a>
<a name="ln4540">{</a>
<a name="ln4541">    if (!check_clarity())</a>
<a name="ln4542">        enchant_actor_with_flavour(this, atk, BEAM_CONFUSION, strength);</a>
<a name="ln4543">}</a>
<a name="ln4544"> </a>
<a name="ln4545">void monster::paralyse(actor *atk, int strength, string /*cause*/)</a>
<a name="ln4546">{</a>
<a name="ln4547">    enchant_actor_with_flavour(this, atk, BEAM_PARALYSIS, strength);</a>
<a name="ln4548">}</a>
<a name="ln4549"> </a>
<a name="ln4550">void monster::petrify(actor *atk, bool /*force*/)</a>
<a name="ln4551">{</a>
<a name="ln4552">    enchant_actor_with_flavour(this, atk, BEAM_PETRIFY);</a>
<a name="ln4553">}</a>
<a name="ln4554"> </a>
<a name="ln4555">bool monster::fully_petrify(actor */*atk*/, bool quiet)</a>
<a name="ln4556">{</a>
<a name="ln4557">    bool msg = !quiet &amp;&amp; simple_monster_message(*this, mons_is_immotile(*this) ?</a>
<a name="ln4558">                         &quot; turns to stone!&quot; : &quot; stops moving altogether!&quot;);</a>
<a name="ln4559"> </a>
<a name="ln4560">    add_ench(ENCH_PETRIFIED);</a>
<a name="ln4561">    return msg;</a>
<a name="ln4562">}</a>
<a name="ln4563"> </a>
<a name="ln4564">void monster::slow_down(actor *atk, int strength)</a>
<a name="ln4565">{</a>
<a name="ln4566">    enchant_actor_with_flavour(this, atk, BEAM_SLOW, strength);</a>
<a name="ln4567">}</a>
<a name="ln4568"> </a>
<a name="ln4569">void monster::set_ghost(const ghost_demon &amp;g)</a>
<a name="ln4570">{</a>
<a name="ln4571">    ghost.reset(new ghost_demon(g));</a>
<a name="ln4572"> </a>
<a name="ln4573">    if (!ghost-&gt;name.empty())</a>
<a name="ln4574">        mname = ghost-&gt;name;</a>
<a name="ln4575">}</a>
<a name="ln4576"> </a>
<a name="ln4577">void monster::set_new_monster_id()</a>
<a name="ln4578">{</a>
<a name="ln4579">    mid = ++you.last_mid;</a>
<a name="ln4580">    // Sorry, if you made 4294901759 monsters over the course of your</a>
<a name="ln4581">    // game you deserve a crash, particularly when the game doesn't</a>
<a name="ln4582">    // even last that many turns.</a>
<a name="ln4583">    ASSERT(mid &lt; MID_FIRST_NON_MONSTER);</a>
<a name="ln4584">    env.mid_cache[mid] = mindex();</a>
<a name="ln4585">}</a>
<a name="ln4586"> </a>
<a name="ln4587">void monster::ghost_init(bool need_pos)</a>
<a name="ln4588">{</a>
<a name="ln4589">    ghost_demon_init();</a>
<a name="ln4590"> </a>
<a name="ln4591">    god             = ghost-&gt;religion;</a>
<a name="ln4592">    attitude        = ATT_HOSTILE;</a>
<a name="ln4593">    behaviour       = BEH_WANDER;</a>
<a name="ln4594">    flags           = MF_NO_FLAGS;</a>
<a name="ln4595">    foe             = MHITNOT;</a>
<a name="ln4596">    foe_memory      = 0;</a>
<a name="ln4597">    number          = MONS_NO_MONSTER;</a>
<a name="ln4598"> </a>
<a name="ln4599">    // Ghosts can't worship good gods, but keep the god in the ghost</a>
<a name="ln4600">    // structure so the ghost can comment on it.</a>
<a name="ln4601">    if (is_good_god(god))</a>
<a name="ln4602">        god = GOD_NO_GOD;</a>
<a name="ln4603"> </a>
<a name="ln4604">    inv.init(NON_ITEM);</a>
<a name="ln4605">    enchantments.clear();</a>
<a name="ln4606">    ench_cache.reset();</a>
<a name="ln4607">    ench_countdown = 0;</a>
<a name="ln4608"> </a>
<a name="ln4609">    // Summoned player ghosts are already given a position; calling this</a>
<a name="ln4610">    // in those instances will cause a segfault. Instead, check to see</a>
<a name="ln4611">    // if we have a home first. {due}</a>
<a name="ln4612">    if (need_pos &amp;&amp; !in_bounds(pos()))</a>
<a name="ln4613">        find_place_to_live();</a>
<a name="ln4614"> </a>
<a name="ln4615">    bind_melee_flags();</a>
<a name="ln4616">    bind_spell_flags(); // does this even do anything on ghosts?</a>
<a name="ln4617">}</a>
<a name="ln4618"> </a>
<a name="ln4619">void monster::uglything_init(bool only_mutate)</a>
<a name="ln4620">{</a>
<a name="ln4621">    // If we're mutating an ugly thing, leave its experience level, hit</a>
<a name="ln4622">    // dice and maximum and current hit points as they are.</a>
<a name="ln4623">    if (!only_mutate)</a>
<a name="ln4624">    {</a>
<a name="ln4625">        hit_dice        = ghost-&gt;xl;</a>
<a name="ln4626">        max_hit_points  = ghost-&gt;max_hp;</a>
<a name="ln4627">        hit_points      = max_hit_points;</a>
<a name="ln4628">    }</a>
<a name="ln4629"> </a>
<a name="ln4630">    speed           = ghost-&gt;speed;</a>
<a name="ln4631">    speed_increment = 70;</a>
<a name="ln4632">    colour          = ghost-&gt;colour;</a>
<a name="ln4633">}</a>
<a name="ln4634"> </a>
<a name="ln4635">void monster::ghost_demon_init()</a>
<a name="ln4636">{</a>
<a name="ln4637">    hit_dice        = ghost-&gt;xl;</a>
<a name="ln4638">    max_hit_points  = min&lt;short int&gt;(ghost-&gt;max_hp, MAX_MONSTER_HP);</a>
<a name="ln4639">    hit_points      = max_hit_points;</a>
<a name="ln4640">    speed           = ghost-&gt;speed;</a>
<a name="ln4641">    speed_increment = 70;</a>
<a name="ln4642">    if (ghost-&gt;colour != COLOUR_UNDEF)</a>
<a name="ln4643">        colour = ghost-&gt;colour;</a>
<a name="ln4644"> </a>
<a name="ln4645">    load_ghost_spells();</a>
<a name="ln4646">}</a>
<a name="ln4647"> </a>
<a name="ln4648">void monster::uglything_mutate(colour_t force_colour)</a>
<a name="ln4649">{</a>
<a name="ln4650">    ghost-&gt;init_ugly_thing(type == MONS_VERY_UGLY_THING, true, force_colour);</a>
<a name="ln4651">    uglything_init(true);</a>
<a name="ln4652">}</a>
<a name="ln4653"> </a>
<a name="ln4654">// Randomise potential damage.</a>
<a name="ln4655">static int _estimated_trap_damage(trap_type trap)</a>
<a name="ln4656">{</a>
<a name="ln4657">    switch (trap)</a>
<a name="ln4658">    {</a>
<a name="ln4659">        case TRAP_BLADE: return 10 + random2(30);</a>
<a name="ln4660">        case TRAP_ARROW: return random2(7);</a>
<a name="ln4661">        case TRAP_SPEAR: return random2(10);</a>
<a name="ln4662">        case TRAP_BOLT:  return random2(13);</a>
<a name="ln4663">        default:         return 0;</a>
<a name="ln4664">    }</a>
<a name="ln4665">}</a>
<a name="ln4666"> </a>
<a name="ln4667">/**</a>
<a name="ln4668"> * Check whether a given trap (described by trap position) can be</a>
<a name="ln4669"> * regarded as safe. Takes into account monster intelligence and</a>
<a name="ln4670"> * allegiance.</a>
<a name="ln4671"> *</a>
<a name="ln4672"> * @param where       The square to be checked for dangerous traps.</a>
<a name="ln4673"> * @param just_check  Used for intelligent monsters trying to avoid traps.</a>
<a name="ln4674"> * @return            Whether the monster will willingly enter the square.</a>
<a name="ln4675"> */</a>
<a name="ln4676">bool monster::is_trap_safe(const coord_def&amp; where, bool just_check) const</a>
<a name="ln4677">{</a>
<a name="ln4678">    const mon_intel_type intel = mons_intel(*this);</a>
<a name="ln4679"> </a>
<a name="ln4680">    const trap_def *ptrap = trap_at(where);</a>
<a name="ln4681">    if (!ptrap)</a>
<a name="ln4682">        return true;</a>
<a name="ln4683">    const trap_def&amp; trap = *ptrap;</a>
<a name="ln4684"> </a>
<a name="ln4685">    // Known shafts are safe.</a>
<a name="ln4686">    if (trap.type == TRAP_SHAFT)</a>
<a name="ln4687">        return true;</a>
<a name="ln4688"> </a>
<a name="ln4689">#if TAG_MAJOR_VERSION == 34</a>
<a name="ln4690">    if (trap.type == TRAP_SHADOW_DORMANT || trap.type == TRAP_SHADOW)</a>
<a name="ln4691">        return true;</a>
<a name="ln4692">#endif</a>
<a name="ln4693"> </a>
<a name="ln4694">    // No friendly or good neutral monsters will ever enter a trap that harms</a>
<a name="ln4695">    // the player when triggered.</a>
<a name="ln4696">    if (wont_attack() &amp;&amp; trap.is_bad_for_player())</a>
<a name="ln4697">        return false;</a>
<a name="ln4698"> </a>
<a name="ln4699">    // Dumb monsters don't care at all.</a>
<a name="ln4700">    if (intel == I_BRAINLESS)</a>
<a name="ln4701">        return true;</a>
<a name="ln4702"> </a>
<a name="ln4703">    // Ditto, berserkers &amp; frenzied creatures.</a>
<a name="ln4704">    if (berserk_or_insane())</a>
<a name="ln4705">        return true;</a>
<a name="ln4706"> </a>
<a name="ln4707">    // Friendlies will try not to be parted from you.</a>
<a name="ln4708">    if (intelligent_ally(*this) &amp;&amp; (trap.type == TRAP_TELEPORT</a>
<a name="ln4709">                                   || trap.type == TRAP_TELEPORT_PERMANENT)</a>
<a name="ln4710">        &amp;&amp; can_see(you))</a>
<a name="ln4711">    {</a>
<a name="ln4712">        return false;</a>
<a name="ln4713">    }</a>
<a name="ln4714"> </a>
<a name="ln4715">    // Hostile monsters are not afraid of non-mechanical traps.</a>
<a name="ln4716">    // But, in the arena Zot traps affect all monsters.</a>
<a name="ln4717">    if (!trap.is_mechanical())</a>
<a name="ln4718">        return !crawl_state.game_is_arena() || trap.type != TRAP_ZOT;</a>
<a name="ln4719"> </a>
<a name="ln4720">    // Net traps always target the player, let's use them!</a>
<a name="ln4721">    if (trap.type == TRAP_NET)</a>
<a name="ln4722">        return true;</a>
<a name="ln4723"> </a>
<a name="ln4724">    // If just checking a mechanical trap is dangerous</a>
<a name="ln4725">    if (just_check)</a>
<a name="ln4726">        return false;</a>
<a name="ln4727"> </a>
<a name="ln4728">    // Mechanical trap calculations</a>
<a name="ln4729">    // Test for corridor-like environment.</a>
<a name="ln4730">    const int x = where.x - pos().x;</a>
<a name="ln4731">    const int y = where.y - pos().y;</a>
<a name="ln4732"> </a>
<a name="ln4733">    // The question is whether the monster (m) can easily reach its</a>
<a name="ln4734">    // presumable destination (x) without stepping on the trap. Traps</a>
<a name="ln4735">    // in corridors do not allow this. See e.g</a>
<a name="ln4736">    //  #x#        ##</a>
<a name="ln4737">    //  #^#   or  m^x</a>
<a name="ln4738">    //   m         ##</a>
<a name="ln4739">    //</a>
<a name="ln4740">    // The same problem occurs if paths are blocked by monsters,</a>
<a name="ln4741">    // hostile terrain or other traps rather than walls.</a>
<a name="ln4742">    // What we do is check whether the squares with the relative</a>
<a name="ln4743">    // positions (-1,0)/(+1,0) or (0,-1)/(0,+1) form a &quot;corridor&quot;</a>
<a name="ln4744">    // (relative to the _trap_ position rather than the monster one).</a>
<a name="ln4745">    // If they don't, the trap square is marked as &quot;unsafe&quot; (because</a>
<a name="ln4746">    // there's a good alternative move for the monster to take),</a>
<a name="ln4747">    // otherwise the decision will be made according to later tests</a>
<a name="ln4748">    // (monster hp, trap type, ...)</a>
<a name="ln4749">    // If a monster still gets stuck in a corridor it will usually be</a>
<a name="ln4750">    // because it has less than half its maximum hp.</a>
<a name="ln4751"> </a>
<a name="ln4752">    if ((mon_can_move_to_pos(this, coord_def(x-1, y), true)</a>
<a name="ln4753">         || mon_can_move_to_pos(this, coord_def(x+1,y), true))</a>
<a name="ln4754">        &amp;&amp; (mon_can_move_to_pos(this, coord_def(x,y-1), true)</a>
<a name="ln4755">            || mon_can_move_to_pos(this, coord_def(x,y+1), true)))</a>
<a name="ln4756">    {</a>
<a name="ln4757">        return false;</a>
<a name="ln4758">    }</a>
<a name="ln4759"> </a>
<a name="ln4760">    // Healthy monsters don't mind a little pain.</a>
<a name="ln4761">    if (hit_points &gt;= max_hit_points / 2</a>
<a name="ln4762">        &amp;&amp; (intel &lt; I_HUMAN</a>
<a name="ln4763">            || hit_points &gt; _estimated_trap_damage(trap.type)))</a>
<a name="ln4764">    {</a>
<a name="ln4765">        return true;</a>
<a name="ln4766">    }</a>
<a name="ln4767"> </a>
<a name="ln4768">    // we don't think we have enough hp (per above), so avoid mech traps</a>
<a name="ln4769">    return false;</a>
<a name="ln4770">}</a>
<a name="ln4771"> </a>
<a name="ln4772">bool monster::is_cloud_safe(const coord_def &amp;place) const</a>
<a name="ln4773">{</a>
<a name="ln4774">    return !mons_avoids_cloud(this, place);</a>
<a name="ln4775">}</a>
<a name="ln4776"> </a>
<a name="ln4777">bool monster::check_set_valid_home(const coord_def &amp;place,</a>
<a name="ln4778">                                    coord_def &amp;chosen,</a>
<a name="ln4779">                                    int &amp;nvalid) const</a>
<a name="ln4780">{</a>
<a name="ln4781">    if (!in_bounds(place))</a>
<a name="ln4782">        return false;</a>
<a name="ln4783"> </a>
<a name="ln4784">    if (actor_at(place))</a>
<a name="ln4785">        return false;</a>
<a name="ln4786"> </a>
<a name="ln4787">    if (!monster_habitable_grid(this, grd(place)))</a>
<a name="ln4788">        return false;</a>
<a name="ln4789"> </a>
<a name="ln4790">    if (!is_trap_safe(place, true))</a>
<a name="ln4791">        return false;</a>
<a name="ln4792"> </a>
<a name="ln4793">    if (one_chance_in(++nvalid))</a>
<a name="ln4794">        chosen = place;</a>
<a name="ln4795"> </a>
<a name="ln4796">    return true;</a>
<a name="ln4797">}</a>
<a name="ln4798"> </a>
<a name="ln4799"> </a>
<a name="ln4800">bool monster::is_location_safe(const coord_def &amp;place)</a>
<a name="ln4801">{</a>
<a name="ln4802">    if (!monster_habitable_grid(this, grd(place)))</a>
<a name="ln4803">        return false;</a>
<a name="ln4804"> </a>
<a name="ln4805">    if (!is_trap_safe(place, true))</a>
<a name="ln4806">        return false;</a>
<a name="ln4807"> </a>
<a name="ln4808">    if (!is_cloud_safe(place))</a>
<a name="ln4809">        return false;</a>
<a name="ln4810"> </a>
<a name="ln4811">    return true;</a>
<a name="ln4812">}</a>
<a name="ln4813"> </a>
<a name="ln4814">bool monster::has_originating_map() const</a>
<a name="ln4815">{</a>
<a name="ln4816">    return props.exists(MAP_KEY);</a>
<a name="ln4817">}</a>
<a name="ln4818"> </a>
<a name="ln4819">string monster::originating_map() const</a>
<a name="ln4820">{</a>
<a name="ln4821">    if (!has_originating_map())</a>
<a name="ln4822">        return &quot;&quot;;</a>
<a name="ln4823">    return props[MAP_KEY].get_string();</a>
<a name="ln4824">}</a>
<a name="ln4825"> </a>
<a name="ln4826">void monster::set_originating_map(const string &amp;map_name)</a>
<a name="ln4827">{</a>
<a name="ln4828">    if (!map_name.empty())</a>
<a name="ln4829">        props[MAP_KEY].get_string() = map_name;</a>
<a name="ln4830">}</a>
<a name="ln4831"> </a>
<a name="ln4832">#define MAX_PLACE_NEAR_DIST 8</a>
<a name="ln4833"> </a>
<a name="ln4834">bool monster::find_home_near_place(const coord_def &amp;c)</a>
<a name="ln4835">{</a>
<a name="ln4836">    int last_dist = -1;</a>
<a name="ln4837">    coord_def place(-1, -1);</a>
<a name="ln4838">    int nvalid = 0;</a>
<a name="ln4839">    SquareArray&lt;int, MAX_PLACE_NEAR_DIST&gt; dist(-1);</a>
<a name="ln4840">    queue&lt;coord_def&gt; q;</a>
<a name="ln4841"> </a>
<a name="ln4842">    q.push(c);</a>
<a name="ln4843">    dist(coord_def()) = 0;</a>
<a name="ln4844">    while (!q.empty())</a>
<a name="ln4845">    {</a>
<a name="ln4846">        coord_def p = q.front();</a>
<a name="ln4847">        q.pop();</a>
<a name="ln4848">        if (dist(p - c) &gt;= last_dist &amp;&amp; nvalid)</a>
<a name="ln4849">        {</a>
<a name="ln4850">            bool moved_to_pos = move_to_pos(place);</a>
<a name="ln4851">            ASSERT(moved_to_pos);</a>
<a name="ln4852">            // can't apply location effects here, since the monster might not</a>
<a name="ln4853">            // be on the level yet, which interacts poorly with e.g. shafts</a>
<a name="ln4854">            return true;</a>
<a name="ln4855">        }</a>
<a name="ln4856">        else if (dist(p - c) &gt;= MAX_PLACE_NEAR_DIST)</a>
<a name="ln4857">            break;</a>
<a name="ln4858"> </a>
<a name="ln4859">        for (adjacent_iterator ai(p); ai; ++ai)</a>
<a name="ln4860">        {</a>
<a name="ln4861">            if (dist(*ai - c) &gt; -1)</a>
<a name="ln4862">                continue;</a>
<a name="ln4863">            dist(*ai - c) = last_dist = dist(p - c) + 1;</a>
<a name="ln4864"> </a>
<a name="ln4865">            if (!monster_habitable_grid(this, grd(*ai)))</a>
<a name="ln4866">                continue;</a>
<a name="ln4867"> </a>
<a name="ln4868">            q.push(*ai);</a>
<a name="ln4869">            check_set_valid_home(*ai, place, nvalid);</a>
<a name="ln4870">        }</a>
<a name="ln4871">    }</a>
<a name="ln4872"> </a>
<a name="ln4873">    return false;</a>
<a name="ln4874">}</a>
<a name="ln4875"> </a>
<a name="ln4876">bool monster::find_home_near_player()</a>
<a name="ln4877">{</a>
<a name="ln4878">    return find_home_near_place(you.pos());</a>
<a name="ln4879">}</a>
<a name="ln4880"> </a>
<a name="ln4881">bool monster::find_home_anywhere()</a>
<a name="ln4882">{</a>
<a name="ln4883">    coord_def place(-1, -1);</a>
<a name="ln4884">    int nvalid = 0;</a>
<a name="ln4885">    for (int tries = 0; tries &lt; 600; ++tries)</a>
<a name="ln4886">        if (check_set_valid_home(random_in_bounds(), place, nvalid))</a>
<a name="ln4887">        {</a>
<a name="ln4888">            bool moved_to_pos = move_to_pos(place);</a>
<a name="ln4889">            ASSERT(moved_to_pos);</a>
<a name="ln4890">            // can't apply location effects here, since the monster might not</a>
<a name="ln4891">            // be on the level yet, which interacts poorly with e.g. shafts</a>
<a name="ln4892">            return true;</a>
<a name="ln4893">        }</a>
<a name="ln4894">    return false;</a>
<a name="ln4895">}</a>
<a name="ln4896"> </a>
<a name="ln4897">bool monster::find_place_to_live(bool near_player)</a>
<a name="ln4898">{</a>
<a name="ln4899">    return near_player &amp;&amp; find_home_near_player()</a>
<a name="ln4900">           || find_home_anywhere();</a>
<a name="ln4901">}</a>
<a name="ln4902"> </a>
<a name="ln4903">void monster::destroy_inventory()</a>
<a name="ln4904">{</a>
<a name="ln4905">    for (mon_inv_iterator ii(*this); ii; ++ii)</a>
<a name="ln4906">        destroy_item(ii-&gt;index());</a>
<a name="ln4907">}</a>
<a name="ln4908"> </a>
<a name="ln4909">bool monster::is_travelling() const</a>
<a name="ln4910">{</a>
<a name="ln4911">    return !travel_path.empty();</a>
<a name="ln4912">}</a>
<a name="ln4913"> </a>
<a name="ln4914">bool monster::is_patrolling() const</a>
<a name="ln4915">{</a>
<a name="ln4916">    return !patrol_point.origin();</a>
<a name="ln4917">}</a>
<a name="ln4918"> </a>
<a name="ln4919">bool monster::needs_abyss_transit() const</a>
<a name="ln4920">{</a>
<a name="ln4921">    return (mons_is_unique(type)</a>
<a name="ln4922">            || (flags &amp; MF_BANISHED)</a>
<a name="ln4923">            || get_experience_level() &gt; 8 + random2(25)</a>
<a name="ln4924">            &amp;&amp; mons_can_use_stairs(*this))</a>
<a name="ln4925">        &amp;&amp; !is_summoned()</a>
<a name="ln4926">        &amp;&amp; !mons_is_conjured(type);</a>
<a name="ln4927">}</a>
<a name="ln4928"> </a>
<a name="ln4929">void monster::set_transit(const level_id &amp;dest)</a>
<a name="ln4930">{</a>
<a name="ln4931">    add_monster_to_transit(dest, *this);</a>
<a name="ln4932">    if (you.can_see(*this))</a>
<a name="ln4933">        remove_unique_annotation(this);</a>
<a name="ln4934">}</a>
<a name="ln4935"> </a>
<a name="ln4936">void monster::load_ghost_spells()</a>
<a name="ln4937">{</a>
<a name="ln4938">    if (!ghost)</a>
<a name="ln4939">    {</a>
<a name="ln4940">        spells.clear();</a>
<a name="ln4941">        return;</a>
<a name="ln4942">    }</a>
<a name="ln4943"> </a>
<a name="ln4944">    spells = ghost-&gt;spells;</a>
<a name="ln4945"> </a>
<a name="ln4946">#ifdef DEBUG_DIAGNOSTICS</a>
<a name="ln4947">    dprf(DIAG_MONPLACE, &quot;Ghost spells:&quot;);</a>
<a name="ln4948">    for (unsigned int i = 0; i &lt; spells.size(); i++)</a>
<a name="ln4949">    {</a>
<a name="ln4950">        dprf(DIAG_MONPLACE, &quot;Spell #%d: %d (%s)&quot;,</a>
<a name="ln4951">             i, spells[i].spell, spell_title(spells[i].spell));</a>
<a name="ln4952">    }</a>
<a name="ln4953">#endif</a>
<a name="ln4954">}</a>
<a name="ln4955"> </a>
<a name="ln4956">bool monster::has_hydra_multi_attack() const</a>
<a name="ln4957">{</a>
<a name="ln4958">    return mons_genus(mons_base_type(*this)) == MONS_HYDRA</a>
<a name="ln4959">        || mons_species(true) == MONS_SERPENT_OF_HELL;</a>
<a name="ln4960">}</a>
<a name="ln4961"> </a>
<a name="ln4962">int monster::heads() const</a>
<a name="ln4963">{</a>
<a name="ln4964">    if (has_hydra_multi_attack())</a>
<a name="ln4965">        return num_heads;</a>
<a name="ln4966">    else if (mons_shouts(mons_species(true)) == S_SHOUT2)</a>
<a name="ln4967">        return 2;</a>
<a name="ln4968">    // There are lots of things with more or fewer heads, but the return value</a>
<a name="ln4969">    // here doesn't actually matter for non-hydra-type monsters.</a>
<a name="ln4970">    else</a>
<a name="ln4971">        return 1;</a>
<a name="ln4972">}</a>
<a name="ln4973"> </a>
<a name="ln4974">bool monster::has_multitargeting() const</a>
<a name="ln4975">{</a>
<a name="ln4976">    return has_hydra_multi_attack() &amp;&amp; !mons_is_zombified(*this);</a>
<a name="ln4977">}</a>
<a name="ln4978"> </a>
<a name="ln4979">bool monster::is_priest() const</a>
<a name="ln4980">{</a>
<a name="ln4981">    return search_slots([] (const mon_spell_slot&amp; slot)</a>
<a name="ln4982">                        { return bool(slot.flags &amp; MON_SPELL_PRIEST); });</a>
<a name="ln4983">}</a>
<a name="ln4984"> </a>
<a name="ln4985">bool monster::is_fighter() const</a>
<a name="ln4986">{</a>
<a name="ln4987">    return bool(flags &amp; MF_FIGHTER);</a>
<a name="ln4988">}</a>
<a name="ln4989"> </a>
<a name="ln4990">bool monster::is_archer() const</a>
<a name="ln4991">{</a>
<a name="ln4992">    return bool(flags &amp; MF_ARCHER);</a>
<a name="ln4993">}</a>
<a name="ln4994"> </a>
<a name="ln4995">bool monster::is_actual_spellcaster() const</a>
<a name="ln4996">{</a>
<a name="ln4997">    return search_slots([] (const mon_spell_slot&amp; slot)</a>
<a name="ln4998">                        { return bool(slot.flags &amp; MON_SPELL_WIZARD); } );</a>
<a name="ln4999">}</a>
<a name="ln5000"> </a>
<a name="ln5001">bool monster::is_shapeshifter() const</a>
<a name="ln5002">{</a>
<a name="ln5003">    return has_ench(ENCH_GLOWING_SHAPESHIFTER, ENCH_SHAPESHIFTER);</a>
<a name="ln5004">}</a>
<a name="ln5005"> </a>
<a name="ln5006">void monster::scale_hp(int num, int den)</a>
<a name="ln5007">{</a>
<a name="ln5008">    // Without the +1, we lose maxhp on every berserk (the only use) if the</a>
<a name="ln5009">    // maxhp is odd. This version does preserve the value correctly, but only</a>
<a name="ln5010">    // if it is first inflated then deflated.</a>
<a name="ln5011">    hit_points     = (hit_points * num + 1) / den;</a>
<a name="ln5012">    max_hit_points = (max_hit_points * num + 1) / den;</a>
<a name="ln5013"> </a>
<a name="ln5014">    if (hit_points &lt; 1)</a>
<a name="ln5015">        hit_points = 1;</a>
<a name="ln5016">    if (max_hit_points &lt; 1)</a>
<a name="ln5017">        max_hit_points = 1;</a>
<a name="ln5018">    if (hit_points &gt; max_hit_points)</a>
<a name="ln5019">        hit_points = max_hit_points;</a>
<a name="ln5020">}</a>
<a name="ln5021"> </a>
<a name="ln5022">kill_category monster::kill_alignment() const</a>
<a name="ln5023">{</a>
<a name="ln5024">    if (mid == MID_YOU_FAULTLESS)</a>
<a name="ln5025">        return KC_YOU;</a>
<a name="ln5026">    return friendly() ? KC_FRIENDLY : KC_OTHER;</a>
<a name="ln5027">}</a>
<a name="ln5028"> </a>
<a name="ln5029">bool monster::sicken(int amount)</a>
<a name="ln5030">{</a>
<a name="ln5031">    if (res_rotting() || (amount /= 2) &lt; 1)</a>
<a name="ln5032">        return false;</a>
<a name="ln5033"> </a>
<a name="ln5034">    if (!has_ench(ENCH_SICK) &amp;&amp; you.can_see(*this))</a>
<a name="ln5035">    {</a>
<a name="ln5036">        // Yes, could be confused with poisoning.</a>
<a name="ln5037">        mprf(&quot;%s looks sick.&quot;, name(DESC_THE).c_str());</a>
<a name="ln5038">    }</a>
<a name="ln5039"> </a>
<a name="ln5040">    add_ench(mon_enchant(ENCH_SICK, 0, 0, amount * BASELINE_DELAY));</a>
<a name="ln5041"> </a>
<a name="ln5042">    return true;</a>
<a name="ln5043">}</a>
<a name="ln5044"> </a>
<a name="ln5045">// Recalculate movement speed.</a>
<a name="ln5046">void monster::calc_speed()</a>
<a name="ln5047">{</a>
<a name="ln5048">    speed = mons_base_speed(*this);</a>
<a name="ln5049"> </a>
<a name="ln5050">    if (has_ench(ENCH_BERSERK))</a>
<a name="ln5051">        speed = berserk_mul(speed);</a>
<a name="ln5052">    else if (has_ench(ENCH_HASTE))</a>
<a name="ln5053">        speed = haste_mul(speed);</a>
<a name="ln5054">    if (has_ench(ENCH_SLOW))</a>
<a name="ln5055">        speed = haste_div(speed);</a>
<a name="ln5056">}</a>
<a name="ln5057"> </a>
<a name="ln5058">// Check speed and speed_increment sanity.</a>
<a name="ln5059">void monster::check_speed()</a>
<a name="ln5060">{</a>
<a name="ln5061">    // FIXME: If speed is borked, recalculate. Need to figure out how</a>
<a name="ln5062">    // speed is getting borked.</a>
<a name="ln5063">    if (speed &lt; 0 || speed &gt; 130)</a>
<a name="ln5064">    {</a>
<a name="ln5065">        dprf(&quot;Bad speed: %s, spd: %d, spi: %d, hd: %d, ench: %s&quot;,</a>
<a name="ln5066">             name(DESC_PLAIN).c_str(),</a>
<a name="ln5067">             speed, speed_increment, get_hit_dice(),</a>
<a name="ln5068">             describe_enchantments().c_str());</a>
<a name="ln5069"> </a>
<a name="ln5070">        calc_speed();</a>
<a name="ln5071"> </a>
<a name="ln5072">        dprf(&quot;Fixed speed for %s to %d&quot;, name(DESC_PLAIN).c_str(), speed);</a>
<a name="ln5073">    }</a>
<a name="ln5074"> </a>
<a name="ln5075">    if (speed_increment &lt; 0)</a>
<a name="ln5076">        speed_increment = 0;</a>
<a name="ln5077"> </a>
<a name="ln5078">    if (speed_increment &gt; 200)</a>
<a name="ln5079">    {</a>
<a name="ln5080">        dprf(&quot;Clamping speed increment on %s: %d&quot;,</a>
<a name="ln5081">             name(DESC_PLAIN).c_str(), speed_increment);</a>
<a name="ln5082"> </a>
<a name="ln5083">        speed_increment = 140;</a>
<a name="ln5084">    }</a>
<a name="ln5085">}</a>
<a name="ln5086"> </a>
<a name="ln5087">actor *monster::get_foe() const</a>
<a name="ln5088">{</a>
<a name="ln5089">    if (foe == MHITNOT)</a>
<a name="ln5090">        return nullptr;</a>
<a name="ln5091">    else if (foe == MHITYOU)</a>
<a name="ln5092">        return friendly() ? nullptr : &amp;you;</a>
<a name="ln5093"> </a>
<a name="ln5094">    // Must be a monster!</a>
<a name="ln5095">    monster* my_foe = &amp;menv[foe];</a>
<a name="ln5096">    return my_foe-&gt;alive()? my_foe : nullptr;</a>
<a name="ln5097">}</a>
<a name="ln5098"> </a>
<a name="ln5099">int monster::foe_distance() const</a>
<a name="ln5100">{</a>
<a name="ln5101">    const actor *afoe = get_foe();</a>
<a name="ln5102">    return afoe ? pos().distance_from(afoe-&gt;pos())</a>
<a name="ln5103">                : INFINITE_DISTANCE;</a>
<a name="ln5104">}</a>
<a name="ln5105"> </a>
<a name="ln5106">bool monster::can_go_frenzy() const</a>
<a name="ln5107">{</a>
<a name="ln5108">    if (mons_is_tentacle_or_tentacle_segment(type))</a>
<a name="ln5109">        return false;</a>
<a name="ln5110"> </a>
<a name="ln5111">    // Brainless natural monsters can still be berserked/frenzied.</a>
<a name="ln5112">    // This could maybe all be replaced by mons_is_object()?</a>
<a name="ln5113">    if (mons_intel(*this) == I_BRAINLESS &amp;&amp; !(holiness() &amp; MH_NATURAL))</a>
<a name="ln5114">        return false;</a>
<a name="ln5115"> </a>
<a name="ln5116">    if (paralysed() || petrified() || petrifying() || asleep())</a>
<a name="ln5117">        return false;</a>
<a name="ln5118"> </a>
<a name="ln5119">    if (berserk_or_insane() || has_ench(ENCH_FATIGUE))</a>
<a name="ln5120">        return false;</a>
<a name="ln5121"> </a>
<a name="ln5122">    // If we have no melee attack, going berserk is pointless.</a>
<a name="ln5123">    if (!mons_has_attacks(*this))</a>
<a name="ln5124">        return false;</a>
<a name="ln5125"> </a>
<a name="ln5126">    // These allies have a special loyalty</a>
<a name="ln5127">    if (mons_is_hepliaklqana_ancestor(type)</a>
<a name="ln5128">        || testbits(flags, MF_DEMONIC_GUARDIAN))</a>
<a name="ln5129">    {</a>
<a name="ln5130">        return false;</a>
<a name="ln5131">    }</a>
<a name="ln5132"> </a>
<a name="ln5133">    return true;</a>
<a name="ln5134">}</a>
<a name="ln5135"> </a>
<a name="ln5136">bool monster::can_go_berserk() const</a>
<a name="ln5137">{</a>
<a name="ln5138">    return bool(holiness() &amp; MH_NATURAL) &amp;&amp; can_go_frenzy();</a>
<a name="ln5139">}</a>
<a name="ln5140"> </a>
<a name="ln5141">bool monster::berserk() const</a>
<a name="ln5142">{</a>
<a name="ln5143">    return has_ench(ENCH_BERSERK);</a>
<a name="ln5144">}</a>
<a name="ln5145"> </a>
<a name="ln5146">// XXX: this function could use a better name</a>
<a name="ln5147">bool monster::berserk_or_insane() const</a>
<a name="ln5148">{</a>
<a name="ln5149">    return berserk() || has_ench(ENCH_INSANE);</a>
<a name="ln5150">}</a>
<a name="ln5151"> </a>
<a name="ln5152">bool monster::needs_berserk(bool check_spells, bool ignore_distance) const</a>
<a name="ln5153">{</a>
<a name="ln5154">    if (!can_go_berserk())</a>
<a name="ln5155">        return false;</a>
<a name="ln5156"> </a>
<a name="ln5157">    if (has_ench(ENCH_HASTE) || has_ench(ENCH_TP))</a>
<a name="ln5158">        return false;</a>
<a name="ln5159"> </a>
<a name="ln5160">    if (!ignore_distance &amp;&amp; foe_distance() &gt; 3)</a>
<a name="ln5161">        return false;</a>
<a name="ln5162"> </a>
<a name="ln5163">    if (check_spells)</a>
<a name="ln5164">    {</a>
<a name="ln5165">        for (const mon_spell_slot &amp;slot : spells)</a>
<a name="ln5166">        {</a>
<a name="ln5167">            // Don't count natural abilities for this purpose.</a>
<a name="ln5168">            if (slot.flags &amp; MON_SPELL_NATURAL)</a>
<a name="ln5169">                continue;</a>
<a name="ln5170"> </a>
<a name="ln5171">            const int spell = slot.spell;</a>
<a name="ln5172">            if (spell != SPELL_BERSERKER_RAGE)</a>
<a name="ln5173">                return false;</a>
<a name="ln5174">        }</a>
<a name="ln5175">    }</a>
<a name="ln5176"> </a>
<a name="ln5177">    return true;</a>
<a name="ln5178">}</a>
<a name="ln5179"> </a>
<a name="ln5180">/**</a>
<a name="ln5181"> * Can this monster see invisible creatures?</a>
<a name="ln5182"> *</a>
<a name="ln5183"> * @param calc_unid     Should effects the player doesn't know about be</a>
<a name="ln5184"> *                      considered?</a>
<a name="ln5185"> * @return              Whether the monster can see invisible things.</a>
<a name="ln5186"> */</a>
<a name="ln5187">bool monster::can_see_invisible(bool calc_unid) const</a>
<a name="ln5188">{</a>
<a name="ln5189">    if (mons_is_ghost_demon(type))</a>
<a name="ln5190">        return ghost-&gt;see_invis;</a>
<a name="ln5191">    else if (mons_class_sees_invis(type, base_monster))</a>
<a name="ln5192">        return true;</a>
<a name="ln5193">    else if (has_facet(BF_WEIRD))</a>
<a name="ln5194">        return true;</a>
<a name="ln5195"> </a>
<a name="ln5196">    if (!calc_unid)</a>
<a name="ln5197">        return false;</a>
<a name="ln5198"> </a>
<a name="ln5199">    if (scan_artefacts(ARTP_SEE_INVISIBLE) &gt; 0)</a>
<a name="ln5200">        return true;</a>
<a name="ln5201">    else if (wearing(EQ_RINGS, RING_SEE_INVISIBLE))</a>
<a name="ln5202">        return true;</a>
<a name="ln5203">    else if (wearing_ego(EQ_ALL_ARMOUR, SPARM_SEE_INVISIBLE))</a>
<a name="ln5204">        return true;</a>
<a name="ln5205"> </a>
<a name="ln5206">    return false;</a>
<a name="ln5207">}</a>
<a name="ln5208"> </a>
<a name="ln5209">bool monster::invisible() const</a>
<a name="ln5210">{</a>
<a name="ln5211">    return has_ench(ENCH_INVIS) &amp;&amp; !backlit();</a>
<a name="ln5212">}</a>
<a name="ln5213"> </a>
<a name="ln5214">bool monster::visible_to(const actor *looker) const</a>
<a name="ln5215">{</a>
<a name="ln5216">    bool blind = looker-&gt;is_monster()</a>
<a name="ln5217">                 &amp;&amp; looker-&gt;as_monster()-&gt;has_ench(ENCH_BLIND);</a>
<a name="ln5218"> </a>
<a name="ln5219">    bool vis = looker-&gt;is_player() &amp;&amp; friendly()</a>
<a name="ln5220">               || (!blind &amp;&amp; (!invisible() || looker-&gt;can_see_invisible()));</a>
<a name="ln5221"> </a>
<a name="ln5222">    return vis &amp;&amp; (this == looker || !submerged());</a>
<a name="ln5223">}</a>
<a name="ln5224"> </a>
<a name="ln5225">bool monster::near_foe() const</a>
<a name="ln5226">{</a>
<a name="ln5227">    const actor *afoe = get_foe();</a>
<a name="ln5228">    return afoe &amp;&amp; see_cell_no_trans(afoe-&gt;pos())</a>
<a name="ln5229">           &amp;&amp; summon_can_attack(this, afoe);</a>
<a name="ln5230">}</a>
<a name="ln5231"> </a>
<a name="ln5232">/**</a>
<a name="ln5233"> * Can the monster be mutated?</a>
<a name="ln5234"> *</a>
<a name="ln5235"> * Nonliving (e.g. statue) monsters &amp; the undead are safe, as are a very few</a>
<a name="ln5236"> * other weird types of monsters.</a>
<a name="ln5237"> *</a>
<a name="ln5238"> * @return Whether the monster can be mutated in any way.</a>
<a name="ln5239"> */</a>
<a name="ln5240">bool monster::can_mutate() const</a>
<a name="ln5241">{</a>
<a name="ln5242">    if (mons_is_tentacle_or_tentacle_segment(type))</a>
<a name="ln5243">        return false;</a>
<a name="ln5244"> </a>
<a name="ln5245">    // too weird</a>
<a name="ln5246">    if (type == MONS_CHAOS_SPAWN)</a>
<a name="ln5247">        return false;</a>
<a name="ln5248"> </a>
<a name="ln5249">    // Abominations re-randomize their tile when mutated. They do not gain the</a>
<a name="ln5250">    // malmutate status or experience any other non-cosmetic effect.</a>
<a name="ln5251">    if (type == MONS_ABOMINATION_SMALL || type == MONS_ABOMINATION_LARGE)</a>
<a name="ln5252">        return true;</a>
<a name="ln5253"> </a>
<a name="ln5254">    const mon_holy_type holi = holiness();</a>
<a name="ln5255"> </a>
<a name="ln5256">    return !(holi &amp; (MH_UNDEAD | MH_NONLIVING));</a>
<a name="ln5257">}</a>
<a name="ln5258"> </a>
<a name="ln5259">bool monster::can_safely_mutate(bool /*temp*/) const</a>
<a name="ln5260">{</a>
<a name="ln5261">    return can_mutate();</a>
<a name="ln5262">}</a>
<a name="ln5263"> </a>
<a name="ln5264">bool monster::can_polymorph() const</a>
<a name="ln5265">{</a>
<a name="ln5266">    // can't mutate but can be poly'd</a>
<a name="ln5267">    if (type == MONS_CHAOS_SPAWN)</a>
<a name="ln5268">        return true;</a>
<a name="ln5269"> </a>
<a name="ln5270">    // Abominations re-randomize their tile when mutated, so can_mutate returns</a>
<a name="ln5271">    // true for them. Like all undead, they can't be polymorphed.</a>
<a name="ln5272">    if (type == MONS_ABOMINATION_SMALL || type == MONS_ABOMINATION_LARGE)</a>
<a name="ln5273">        return false;</a>
<a name="ln5274"> </a>
<a name="ln5275">    return can_mutate();</a>
<a name="ln5276">}</a>
<a name="ln5277"> </a>
<a name="ln5278">bool monster::can_bleed(bool /*allow_tran*/) const</a>
<a name="ln5279">{</a>
<a name="ln5280">    return mons_has_blood(type);</a>
<a name="ln5281">}</a>
<a name="ln5282"> </a>
<a name="ln5283">bool monster::is_stationary() const</a>
<a name="ln5284">{</a>
<a name="ln5285">    return mons_class_is_stationary(type);</a>
<a name="ln5286">}</a>
<a name="ln5287"> </a>
<a name="ln5288">/**</a>
<a name="ln5289"> * Malmutate the monster.</a>
<a name="ln5290"> *</a>
<a name="ln5291"> * Gives a temporary 'wretched' effect, generally. Some monsters have special</a>
<a name="ln5292"> * interactions.</a>
<a name="ln5293"> *</a>
<a name="ln5294"> * @return Whether the monster was mutated in any way.</a>
<a name="ln5295"> */</a>
<a name="ln5296">bool monster::malmutate(const string &amp;/*reason*/)</a>
<a name="ln5297">{</a>
<a name="ln5298">    if (!can_mutate())</a>
<a name="ln5299">        return false;</a>
<a name="ln5300"> </a>
<a name="ln5301">    // Abominations re-randomize their tile when mutated. They do not gain the</a>
<a name="ln5302">    // malmutate status or experience any other non-cosmetic effect.</a>
<a name="ln5303">    if (type == MONS_ABOMINATION_SMALL || type == MONS_ABOMINATION_LARGE)</a>
<a name="ln5304">    {</a>
<a name="ln5305">#ifdef USE_TILE</a>
<a name="ln5306">        props[TILE_NUM_KEY].get_short() = ui_random(256);</a>
<a name="ln5307">#endif</a>
<a name="ln5308">        return true;</a>
<a name="ln5309">    }</a>
<a name="ln5310"> </a>
<a name="ln5311">    // Ugly things merely change colour.</a>
<a name="ln5312">    if (type == MONS_UGLY_THING || type == MONS_VERY_UGLY_THING)</a>
<a name="ln5313">    {</a>
<a name="ln5314">        ugly_thing_mutate(*this);</a>
<a name="ln5315">        return true;</a>
<a name="ln5316">    }</a>
<a name="ln5317"> </a>
<a name="ln5318">    simple_monster_message(*this, &quot; twists and deforms.&quot;);</a>
<a name="ln5319">    add_ench(mon_enchant(ENCH_WRETCHED, 1));</a>
<a name="ln5320">    return true;</a>
<a name="ln5321">}</a>
<a name="ln5322"> </a>
<a name="ln5323">/**</a>
<a name="ln5324"> * Corrupt the monster's body.</a>
<a name="ln5325"> *</a>
<a name="ln5326"> * Analogous to effects that give the player temp mutations, like wretched star</a>
<a name="ln5327"> * pulses &amp; demonspawn corruptors. Currently identical to malmutate. (Writing</a>
<a name="ln5328"> * this function anyway, since they probably shouldn't be identical.)</a>
<a name="ln5329"> *</a>
<a name="ln5330"> * XXX: adjust duration to differentiate? (make malmut's duration longer, or</a>
<a name="ln5331"> * corrupt's shorter?)</a>
<a name="ln5332"> */</a>
<a name="ln5333">void monster::corrupt()</a>
<a name="ln5334">{</a>
<a name="ln5335">    malmutate(&quot;&quot;);</a>
<a name="ln5336">}</a>
<a name="ln5337"> </a>
<a name="ln5338">bool monster::polymorph(int /* pow */, bool /*allow_immobile*/)</a>
<a name="ln5339">{</a>
<a name="ln5340">    return polymorph();</a>
<a name="ln5341">}</a>
<a name="ln5342"> </a>
<a name="ln5343">bool monster::polymorph(poly_power_type power)</a>
<a name="ln5344">{</a>
<a name="ln5345">    if (!can_polymorph())</a>
<a name="ln5346">        return false;</a>
<a name="ln5347"> </a>
<a name="ln5348">    // Polymorphing a (very) ugly thing will mutate it into a different</a>
<a name="ln5349">    // (very) ugly thing.</a>
<a name="ln5350">    if (type == MONS_UGLY_THING || type == MONS_VERY_UGLY_THING)</a>
<a name="ln5351">    {</a>
<a name="ln5352">        ugly_thing_mutate(*this);</a>
<a name="ln5353">        return true;</a>
<a name="ln5354">    }</a>
<a name="ln5355"> </a>
<a name="ln5356">    // Polymorphing a shapeshifter will make it revert to its original</a>
<a name="ln5357">    // form.</a>
<a name="ln5358">    if (has_ench(ENCH_GLOWING_SHAPESHIFTER))</a>
<a name="ln5359">        return monster_polymorph(this, MONS_GLOWING_SHAPESHIFTER, power);</a>
<a name="ln5360">    if (has_ench(ENCH_SHAPESHIFTER))</a>
<a name="ln5361">        return monster_polymorph(this, MONS_SHAPESHIFTER, power);</a>
<a name="ln5362"> </a>
<a name="ln5363">    // Polymorphing a slime creature will usually split it first</a>
<a name="ln5364">    // and polymorph each part separately.</a>
<a name="ln5365">    if (type == MONS_SLIME_CREATURE)</a>
<a name="ln5366">    {</a>
<a name="ln5367">        slime_creature_polymorph(*this, power);</a>
<a name="ln5368">        return true;</a>
<a name="ln5369">    }</a>
<a name="ln5370"> </a>
<a name="ln5371">    return monster_polymorph(this, RANDOM_MONSTER, power);</a>
<a name="ln5372">}</a>
<a name="ln5373"> </a>
<a name="ln5374">static bool _mons_is_icy(int mc)</a>
<a name="ln5375">{</a>
<a name="ln5376">    return mc == MONS_ICE_BEAST</a>
<a name="ln5377">           || mc == MONS_SIMULACRUM</a>
<a name="ln5378">           || mc == MONS_ICE_STATUE</a>
<a name="ln5379">           || mc == MONS_BLOCK_OF_ICE;</a>
<a name="ln5380">}</a>
<a name="ln5381"> </a>
<a name="ln5382">bool monster::is_icy() const</a>
<a name="ln5383">{</a>
<a name="ln5384">    return _mons_is_icy(type);</a>
<a name="ln5385">}</a>
<a name="ln5386"> </a>
<a name="ln5387">static bool _mons_is_fiery(int mc)</a>
<a name="ln5388">{</a>
<a name="ln5389">    return mc == MONS_FIRE_VORTEX</a>
<a name="ln5390">           || mc == MONS_FIRE_ELEMENTAL</a>
<a name="ln5391">           || mc == MONS_EFREET</a>
<a name="ln5392">           || mc == MONS_AZRAEL</a>
<a name="ln5393">           || mc == MONS_LAVA_SNAKE</a>
<a name="ln5394">           || mc == MONS_SALAMANDER</a>
<a name="ln5395">           || mc == MONS_SALAMANDER_MYSTIC</a>
<a name="ln5396">           || mc == MONS_MOLTEN_GARGOYLE</a>
<a name="ln5397">           || mc == MONS_ORB_OF_FIRE;</a>
<a name="ln5398">}</a>
<a name="ln5399"> </a>
<a name="ln5400">bool monster::is_fiery() const</a>
<a name="ln5401">{</a>
<a name="ln5402">    return _mons_is_fiery(type);</a>
<a name="ln5403">}</a>
<a name="ln5404"> </a>
<a name="ln5405">static bool _mons_is_skeletal(int mc)</a>
<a name="ln5406">{</a>
<a name="ln5407">    return mc == MONS_SKELETON</a>
<a name="ln5408">           || mc == MONS_BONE_DRAGON</a>
<a name="ln5409">           || mc == MONS_SKELETAL_WARRIOR</a>
<a name="ln5410">           || mc == MONS_ANCIENT_CHAMPION</a>
<a name="ln5411">           || mc == MONS_REVENANT</a>
<a name="ln5412">           || mc == MONS_FLYING_SKULL</a>
<a name="ln5413">           || mc == MONS_CURSE_SKULL</a>
<a name="ln5414">           || mc == MONS_MURRAY;</a>
<a name="ln5415">}</a>
<a name="ln5416"> </a>
<a name="ln5417">bool monster::is_skeletal() const</a>
<a name="ln5418">{</a>
<a name="ln5419">    return _mons_is_skeletal(type);</a>
<a name="ln5420">}</a>
<a name="ln5421"> </a>
<a name="ln5422">/**</a>
<a name="ln5423"> * Does this monster have spines?</a>
<a name="ln5424"> *</a>
<a name="ln5425"> * (If so, it may do damage when attacked in melee, and has rConstrict (!?)</a>
<a name="ln5426"> *</a>
<a name="ln5427"> * @return  Whether this monster has spines.</a>
<a name="ln5428"> */</a>
<a name="ln5429">bool monster::is_spiny() const</a>
<a name="ln5430">{</a>
<a name="ln5431">    return mons_class_flag(mons_is_job(type) ? base_monster : type,</a>
<a name="ln5432">                           M_SPINY);</a>
<a name="ln5433">}</a>
<a name="ln5434"> </a>
<a name="ln5435">bool monster::has_action_energy() const</a>
<a name="ln5436">{</a>
<a name="ln5437">    return speed_increment &gt;= 80;</a>
<a name="ln5438">}</a>
<a name="ln5439"> </a>
<a name="ln5440">void monster::check_redraw(const coord_def &amp;old, bool clear_tiles) const</a>
<a name="ln5441">{</a>
<a name="ln5442">    if (!crawl_state.io_inited)</a>
<a name="ln5443">        return;</a>
<a name="ln5444"> </a>
<a name="ln5445">    const bool see_new = you.see_cell(pos());</a>
<a name="ln5446">    const bool see_old = you.see_cell(old);</a>
<a name="ln5447">    if ((see_new || see_old) &amp;&amp; !view_update())</a>
<a name="ln5448">    {</a>
<a name="ln5449">        if (see_new)</a>
<a name="ln5450">            view_update_at(pos());</a>
<a name="ln5451"> </a>
<a name="ln5452">        // Don't leave a trail if we can see the monster move in.</a>
<a name="ln5453">        if (see_old || (pos() - old).rdist() &lt;= 1)</a>
<a name="ln5454">        {</a>
<a name="ln5455">            view_update_at(old);</a>
<a name="ln5456">#ifdef USE_TILE</a>
<a name="ln5457">            if (clear_tiles &amp;&amp; !see_old)</a>
<a name="ln5458">                tile_reset_fg(old);</a>
<a name="ln5459">#else</a>
<a name="ln5460">            UNUSED(clear_tiles);</a>
<a name="ln5461">#endif</a>
<a name="ln5462">        }</a>
<a name="ln5463">        update_screen();</a>
<a name="ln5464">    }</a>
<a name="ln5465">}</a>
<a name="ln5466"> </a>
<a name="ln5467">void monster::apply_location_effects(const coord_def &amp;oldpos,</a>
<a name="ln5468">                                     killer_type killer,</a>
<a name="ln5469">                                     int killernum)</a>
<a name="ln5470">{</a>
<a name="ln5471">    if (oldpos != pos())</a>
<a name="ln5472">        dungeon_events.fire_position_event(DET_MONSTER_MOVED, pos());</a>
<a name="ln5473"> </a>
<a name="ln5474">    if (alive()</a>
<a name="ln5475">        &amp;&amp; (mons_habitat(*this) == HT_WATER || mons_habitat(*this) == HT_LAVA)</a>
<a name="ln5476">        &amp;&amp; !monster_habitable_grid(this, grd(pos()))</a>
<a name="ln5477">        &amp;&amp; !has_ench(ENCH_AQUATIC_LAND))</a>
<a name="ln5478">    {</a>
<a name="ln5479">        // Elemental wellsprings always have water beneath them</a>
<a name="ln5480">        if (type == MONS_ELEMENTAL_WELLSPRING)</a>
<a name="ln5481">        {</a>
<a name="ln5482">            temp_change_terrain(pos(), DNGN_SHALLOW_WATER, 100,</a>
<a name="ln5483">                                TERRAIN_CHANGE_FLOOD, this);</a>
<a name="ln5484">        }</a>
<a name="ln5485">        else</a>
<a name="ln5486">            add_ench(ENCH_AQUATIC_LAND);</a>
<a name="ln5487">    }</a>
<a name="ln5488"> </a>
<a name="ln5489">    if (alive() &amp;&amp; has_ench(ENCH_AQUATIC_LAND))</a>
<a name="ln5490">    {</a>
<a name="ln5491">        if (!monster_habitable_grid(this, grd(pos())))</a>
<a name="ln5492">            simple_monster_message(*this, &quot; flops around on dry land!&quot;);</a>
<a name="ln5493">        else if (!monster_habitable_grid(this, grd(oldpos)))</a>
<a name="ln5494">        {</a>
<a name="ln5495">            if (you.can_see(*this))</a>
<a name="ln5496">            {</a>
<a name="ln5497">                mprf(&quot;%s dives back into the %s!&quot;, name(DESC_THE).c_str(),</a>
<a name="ln5498">                                                   feat_type_name(grd(pos())));</a>
<a name="ln5499">            }</a>
<a name="ln5500">            del_ench(ENCH_AQUATIC_LAND);</a>
<a name="ln5501">        }</a>
<a name="ln5502">        // This may have been called via dungeon_terrain_changed instead</a>
<a name="ln5503">        // of by the monster moving move, in that case grd(oldpos) will</a>
<a name="ln5504">        // be the current position that became watery.</a>
<a name="ln5505">        else</a>
<a name="ln5506">            del_ench(ENCH_AQUATIC_LAND);</a>
<a name="ln5507">    }</a>
<a name="ln5508"> </a>
<a name="ln5509">    // Monsters stepping on traps:</a>
<a name="ln5510">    trap_def* ptrap = trap_at(pos());</a>
<a name="ln5511">    if (ptrap)</a>
<a name="ln5512">        ptrap-&gt;trigger(*this);</a>
<a name="ln5513"> </a>
<a name="ln5514">    if (alive())</a>
<a name="ln5515">        mons_check_pool(this, pos(), killer, killernum);</a>
<a name="ln5516"> </a>
<a name="ln5517">    if (alive()</a>
<a name="ln5518">        &amp;&amp; has_ench(ENCH_SUBMERGED)</a>
<a name="ln5519">        &amp;&amp; !monster_can_submerge(this, grd(pos())))</a>
<a name="ln5520">    {</a>
<a name="ln5521">        del_ench(ENCH_SUBMERGED);</a>
<a name="ln5522">    }</a>
<a name="ln5523"> </a>
<a name="ln5524">    terrain_property_t &amp;prop = env.pgrid(pos());</a>
<a name="ln5525"> </a>
<a name="ln5526">    if (prop &amp; FPROP_BLOODY)</a>
<a name="ln5527">    {</a>
<a name="ln5528">        monster_type genus = mons_genus(type);</a>
<a name="ln5529"> </a>
<a name="ln5530">        if (genus == MONS_JELLY || genus == MONS_ELEPHANT_SLUG)</a>
<a name="ln5531">        {</a>
<a name="ln5532">            prop &amp;= ~FPROP_BLOODY;</a>
<a name="ln5533">            if (you.see_cell(pos()) &amp;&amp; !visible_to(&amp;you))</a>
<a name="ln5534">            {</a>
<a name="ln5535">                string desc =</a>
<a name="ln5536">                    feature_description_at(pos(), false, DESC_THE);</a>
<a name="ln5537">                mprf(&quot;The bloodstain on %s disappears!&quot;, desc.c_str());</a>
<a name="ln5538">            }</a>
<a name="ln5539">        }</a>
<a name="ln5540">    }</a>
<a name="ln5541">}</a>
<a name="ln5542"> </a>
<a name="ln5543">void monster::self_destruct()</a>
<a name="ln5544">{</a>
<a name="ln5545">    suicide();</a>
<a name="ln5546">    monster_die(*as_monster(), KILL_MON, mindex());</a>
<a name="ln5547">}</a>
<a name="ln5548"> </a>
<a name="ln5549">/** A higher-level moving method than moveto().</a>
<a name="ln5550"> *</a>
<a name="ln5551"> *  @param newpos    where to move this monster</a>
<a name="ln5552"> *  @param clear_net whether to clear any trapping nets</a>
<a name="ln5553"> *  @param force     whether to move it even if you're standing there</a>
<a name="ln5554"> *  @returns whether the move took place.</a>
<a name="ln5555"> */</a>
<a name="ln5556">bool monster::move_to_pos(const coord_def &amp;newpos, bool clear_net, bool force)</a>
<a name="ln5557">{</a>
<a name="ln5558">    const actor* a = actor_at(newpos);</a>
<a name="ln5559">    if (a &amp;&amp; !(a-&gt;is_player() &amp;&amp; (fedhas_passthrough(this) || force)))</a>
<a name="ln5560">        return false;</a>
<a name="ln5561"> </a>
<a name="ln5562">    const int index = mindex();</a>
<a name="ln5563"> </a>
<a name="ln5564">    // Clear old cell pointer.</a>
<a name="ln5565">    if (in_bounds(pos()) &amp;&amp; mgrd(pos()) == index)</a>
<a name="ln5566">        mgrd(pos()) = NON_MONSTER;</a>
<a name="ln5567"> </a>
<a name="ln5568">    // Set monster x,y to new value.</a>
<a name="ln5569">    moveto(newpos, clear_net);</a>
<a name="ln5570"> </a>
<a name="ln5571">    // Set new monster grid pointer to this monster.</a>
<a name="ln5572">    mgrd(newpos) = index;</a>
<a name="ln5573"> </a>
<a name="ln5574">    return true;</a>
<a name="ln5575">}</a>
<a name="ln5576"> </a>
<a name="ln5577">/** Swap positions with another monster.</a>
<a name="ln5578"> *</a>
<a name="ln5579"> *  move_to_pos can't be used in this case, since it can't move something</a>
<a name="ln5580"> *  to a spot that's occupied. This will abort if either monster can't survive</a>
<a name="ln5581"> *  in the new place.</a>
<a name="ln5582"> *</a>
<a name="ln5583"> *  We also cannot use moveto, since that calls clear_invalid_constrictions,</a>
<a name="ln5584"> *  which may cause a more(), causing a render. While monsters are being</a>
<a name="ln5585"> *  swapped, their positions and the mgrd mismatch, so rendering would crash.</a>
<a name="ln5586"> *</a>
<a name="ln5587"> *  @param other the monster to swap with</a>
<a name="ln5588"> *  @returns whether they ended up moving.</a>
<a name="ln5589"> */</a>
<a name="ln5590">bool monster::swap_with(monster* other)</a>
<a name="ln5591">{</a>
<a name="ln5592">    const coord_def old_pos = pos();</a>
<a name="ln5593">    const coord_def new_pos = other-&gt;pos();</a>
<a name="ln5594"> </a>
<a name="ln5595">    if (!can_pass_through(new_pos)</a>
<a name="ln5596">        || !other-&gt;can_pass_through(old_pos))</a>
<a name="ln5597">    {</a>
<a name="ln5598">        return false;</a>
<a name="ln5599">    }</a>
<a name="ln5600"> </a>
<a name="ln5601">    if (!monster_habitable_grid(this, grd(new_pos))</a>
<a name="ln5602">        || !monster_habitable_grid(other, grd(old_pos)))</a>
<a name="ln5603">    {</a>
<a name="ln5604">        return false;</a>
<a name="ln5605">    }</a>
<a name="ln5606"> </a>
<a name="ln5607">    mons_clear_trapping_net(this);</a>
<a name="ln5608">    mons_clear_trapping_net(other);</a>
<a name="ln5609"> </a>
<a name="ln5610">    // Swap monster positions. Cannot render inside here, since mgrd and monster</a>
<a name="ln5611">    // positions would mismatch.</a>
<a name="ln5612">    mgrd(old_pos) = other-&gt;mindex();</a>
<a name="ln5613">    mgrd(new_pos) = mindex();</a>
<a name="ln5614">    set_position(new_pos);</a>
<a name="ln5615">    other-&gt;set_position(old_pos);</a>
<a name="ln5616"> </a>
<a name="ln5617">    // Okay to render again now</a>
<a name="ln5618">    clear_invalid_constrictions(true);</a>
<a name="ln5619">    other-&gt;clear_invalid_constrictions(true);</a>
<a name="ln5620"> </a>
<a name="ln5621">    return true;</a>
<a name="ln5622">}</a>
<a name="ln5623"> </a>
<a name="ln5624">// Returns true if the trap should be revealed to the player.</a>
<a name="ln5625">bool monster::do_shaft()</a>
<a name="ln5626">{</a>
<a name="ln5627">    if (!is_valid_shaft_level())</a>
<a name="ln5628">        return false;</a>
<a name="ln5629"> </a>
<a name="ln5630">    // Tentacles are immune to shafting</a>
<a name="ln5631">    if (mons_is_tentacle_or_tentacle_segment(type))</a>
<a name="ln5632">        return false;</a>
<a name="ln5633"> </a>
<a name="ln5634">    // Handle instances of do_shaft() being invoked magically when</a>
<a name="ln5635">    // the monster isn't standing over a shaft.</a>
<a name="ln5636">    if (get_trap_type(pos()) != TRAP_SHAFT</a>
<a name="ln5637">        &amp;&amp; !feat_is_shaftable(grd(pos())))</a>
<a name="ln5638">    {</a>
<a name="ln5639">        return false;</a>
<a name="ln5640">    }</a>
<a name="ln5641"> </a>
<a name="ln5642">    level_id lev = shaft_dest();</a>
<a name="ln5643"> </a>
<a name="ln5644">    if (lev == level_id::current())</a>
<a name="ln5645">        return false;</a>
<a name="ln5646"> </a>
<a name="ln5647">    // If a pacified monster is leaving the level via a shaft trap, and</a>
<a name="ln5648">    // has reached its goal, vaporize it instead of moving it.</a>
<a name="ln5649">    // ditto, non-monsters like battlespheres and prisms.</a>
<a name="ln5650">    if (!pacified() &amp;&amp; !mons_is_conjured(type))</a>
<a name="ln5651">        set_transit(lev);</a>
<a name="ln5652"> </a>
<a name="ln5653">    string msg = make_stringf(&quot; %s a shaft!&quot;,</a>
<a name="ln5654">                              !ground_level() ? &quot;is sucked into&quot;</a>
<a name="ln5655">                                              : &quot;falls through&quot;);</a>
<a name="ln5656"> </a>
<a name="ln5657">    const bool reveal = simple_monster_message(*this, msg.c_str());</a>
<a name="ln5658"> </a>
<a name="ln5659">    place_cloud(CLOUD_DUST, pos(), 1 + random2(3), this);</a>
<a name="ln5660"> </a>
<a name="ln5661">    // Monster is no longer on this level.</a>
<a name="ln5662">    destroy_inventory();</a>
<a name="ln5663">    monster_cleanup(this);</a>
<a name="ln5664"> </a>
<a name="ln5665">    return reveal;</a>
<a name="ln5666">}</a>
<a name="ln5667"> </a>
<a name="ln5668">void monster::put_to_sleep(actor */*attacker*/, int /*strength*/, bool hibernate)</a>
<a name="ln5669">{</a>
<a name="ln5670">    const bool valid_target = hibernate ? can_hibernate() : can_sleep();</a>
<a name="ln5671">    if (!valid_target)</a>
<a name="ln5672">        return;</a>
<a name="ln5673"> </a>
<a name="ln5674">    stop_directly_constricting_all(false);</a>
<a name="ln5675">    behaviour = BEH_SLEEP;</a>
<a name="ln5676">    flags |= MF_JUST_SLEPT;</a>
<a name="ln5677">    if (hibernate)</a>
<a name="ln5678">        add_ench(ENCH_SLEEP_WARY);</a>
<a name="ln5679">}</a>
<a name="ln5680"> </a>
<a name="ln5681">void monster::weaken(actor *attacker, int pow)</a>
<a name="ln5682">{</a>
<a name="ln5683">    if (!has_ench(ENCH_WEAK))</a>
<a name="ln5684">        simple_monster_message(*this, &quot; looks weaker.&quot;);</a>
<a name="ln5685"> </a>
<a name="ln5686">    add_ench(mon_enchant(ENCH_WEAK, 1, attacker,</a>
<a name="ln5687">                         (pow + random2(pow + 3)) * BASELINE_DELAY));</a>
<a name="ln5688">}</a>
<a name="ln5689"> </a>
<a name="ln5690">void monster::check_awaken(int)</a>
<a name="ln5691">{</a>
<a name="ln5692">    // XXX</a>
<a name="ln5693">}</a>
<a name="ln5694"> </a>
<a name="ln5695">int monster::beam_resists(bolt &amp;beam, int hurted, bool doEffects, string /*source*/)</a>
<a name="ln5696">{</a>
<a name="ln5697">    return mons_adjust_flavoured(this, beam, hurted, doEffects);</a>
<a name="ln5698">}</a>
<a name="ln5699"> </a>
<a name="ln5700">const monsterentry *monster::find_monsterentry() const</a>
<a name="ln5701">{</a>
<a name="ln5702">    return (type == MONS_NO_MONSTER || type == MONS_PROGRAM_BUG) ? nullptr</a>
<a name="ln5703">                                                    : get_monster_data(type);</a>
<a name="ln5704">}</a>
<a name="ln5705"> </a>
<a name="ln5706">int monster::action_energy(energy_use_type et) const</a>
<a name="ln5707">{</a>
<a name="ln5708">    if (!find_monsterentry())</a>
<a name="ln5709">        return 10;</a>
<a name="ln5710"> </a>
<a name="ln5711">    const mon_energy_usage &amp;mu = mons_energy(*this);</a>
<a name="ln5712">    int move_cost = 0;</a>
<a name="ln5713">    switch (et)</a>
<a name="ln5714">    {</a>
<a name="ln5715">    case EUT_MOVE:    move_cost = mu.move; break;</a>
<a name="ln5716">    // Amphibious monster speed boni are now dealt with using SWIM_ENERGY,</a>
<a name="ln5717">    // rather than here.</a>
<a name="ln5718">    case EUT_SWIM:    move_cost = mu.swim; break;</a>
<a name="ln5719">    case EUT_MISSILE: return mu.missile;</a>
<a name="ln5720">    case EUT_ITEM:    return mu.item;</a>
<a name="ln5721">    case EUT_SPECIAL: return mu.special;</a>
<a name="ln5722">    case EUT_SPELL:   return mu.spell;</a>
<a name="ln5723">    case EUT_ATTACK:  return mu.attack;</a>
<a name="ln5724">    case EUT_PICKUP:  return mu.pickup_percent;</a>
<a name="ln5725">    }</a>
<a name="ln5726"> </a>
<a name="ln5727">    if (has_ench(ENCH_SWIFT))</a>
<a name="ln5728">        move_cost -= 3;</a>
<a name="ln5729"> </a>
<a name="ln5730">    if (wearing_ego(EQ_ALL_ARMOUR, SPARM_PONDEROUSNESS))</a>
<a name="ln5731">        move_cost += 1;</a>
<a name="ln5732"> </a>
<a name="ln5733">    if (run())</a>
<a name="ln5734">        move_cost -= 1;</a>
<a name="ln5735"> </a>
<a name="ln5736">    // Shadows move more quickly when blended with the darkness.</a>
<a name="ln5737">    // Change _monster_stat_description in describe.cc if you change this.</a>
<a name="ln5738">    if (type == MONS_SHADOW &amp;&amp; invisible())</a>
<a name="ln5739">        move_cost -= 3;</a>
<a name="ln5740"> </a>
<a name="ln5741">    // Floundering monsters get the same penalty as the player, except that</a>
<a name="ln5742">    // players get the penalty on entering water, while monsters get the</a>
<a name="ln5743">    // penalty when leaving it.</a>
<a name="ln5744">    if (floundering() || has_ench(ENCH_LIQUEFYING))</a>
<a name="ln5745">        move_cost += 6;</a>
<a name="ln5746"> </a>
<a name="ln5747">    // Never reduce the cost to zero</a>
<a name="ln5748">    return max(move_cost, 1);</a>
<a name="ln5749">}</a>
<a name="ln5750"> </a>
<a name="ln5751">void monster::lose_energy(energy_use_type et, int div, int mult)</a>
<a name="ln5752">{</a>
<a name="ln5753">    int energy_loss  = div_round_up(mult * action_energy(et), div);</a>
<a name="ln5754">    if (has_ench(ENCH_PETRIFYING))</a>
<a name="ln5755">    {</a>
<a name="ln5756">        energy_loss *= 3;</a>
<a name="ln5757">        energy_loss /= 2;</a>
<a name="ln5758">    }</a>
<a name="ln5759"> </a>
<a name="ln5760">    if ((et == EUT_MOVE || et == EUT_SWIM) &amp;&amp; has_ench(ENCH_FROZEN))</a>
<a name="ln5761">        energy_loss += 4;</a>
<a name="ln5762"> </a>
<a name="ln5763">    // Randomize interval between servitor spellcasts</a>
<a name="ln5764">    // TODO: is there a more transparent way to implement this than energy?</a>
<a name="ln5765">    if ((et == EUT_SPELL &amp;&amp; type == MONS_SPELLFORGED_SERVITOR))</a>
<a name="ln5766">        energy_loss += random2(16);</a>
<a name="ln5767"> </a>
<a name="ln5768">    // Randomize movement cost slightly, to make it less predictable,</a>
<a name="ln5769">    // and make pillar-dancing not entirely safe.</a>
<a name="ln5770">    // No randomization for allies following you to avoid traffic jam</a>
<a name="ln5771">    if ((et == EUT_MOVE || et == EUT_SWIM) &amp;&amp; (!friendly() || foe != MHITYOU))</a>
<a name="ln5772">        energy_loss += random2(3) - 1;</a>
<a name="ln5773"> </a>
<a name="ln5774">    speed_increment -= energy_loss;</a>
<a name="ln5775">}</a>
<a name="ln5776"> </a>
<a name="ln5777">void monster::gain_energy(energy_use_type et, int div, int mult)</a>
<a name="ln5778">{</a>
<a name="ln5779">    int energy_gain  = div_round_up(mult * action_energy(et), div);</a>
<a name="ln5780">    if (has_ench(ENCH_PETRIFYING))</a>
<a name="ln5781">    {</a>
<a name="ln5782">        energy_gain *= 2;</a>
<a name="ln5783">        energy_gain /= 3;</a>
<a name="ln5784">    }</a>
<a name="ln5785"> </a>
<a name="ln5786">    speed_increment += energy_gain;</a>
<a name="ln5787">}</a>
<a name="ln5788"> </a>
<a name="ln5789">/**</a>
<a name="ln5790"> * Can this monster ever drink any potions at all?</a>
<a name="ln5791"> *</a>
<a name="ln5792"> * @return  Whether the monster can drink potions (not a statue, mummy, etc)</a>
<a name="ln5793"> */</a>
<a name="ln5794">bool monster::can_drink() const</a>
<a name="ln5795">{</a>
<a name="ln5796">    if (mons_class_is_stationary(type))</a>
<a name="ln5797">        return false;</a>
<a name="ln5798"> </a>
<a name="ln5799">    if (mons_itemuse(*this) &lt; MONUSE_STARTING_EQUIPMENT)</a>
<a name="ln5800">        return false;</a>
<a name="ln5801"> </a>
<a name="ln5802">    // These monsters cannot drink.</a>
<a name="ln5803">    if (is_skeletal() || is_insubstantial()</a>
<a name="ln5804">        || mons_species() == MONS_LICH || mons_genus(type) == MONS_MUMMY</a>
<a name="ln5805">        || mons_species() == MONS_WIGHT || type == MONS_GASTRONOK)</a>
<a name="ln5806">    {</a>
<a name="ln5807">        return false;</a>
<a name="ln5808">    }</a>
<a name="ln5809"> </a>
<a name="ln5810">    return true;</a>
<a name="ln5811">}</a>
<a name="ln5812"> </a>
<a name="ln5813">bool monster::can_drink_potion(potion_type ptype) const</a>
<a name="ln5814">{</a>
<a name="ln5815">    if (!can_drink())</a>
<a name="ln5816">        return false;</a>
<a name="ln5817"> </a>
<a name="ln5818">    switch (ptype)</a>
<a name="ln5819">    {</a>
<a name="ln5820">        case POT_CURING:</a>
<a name="ln5821">        case POT_HEAL_WOUNDS:</a>
<a name="ln5822">            return !(holiness() &amp; (MH_NONLIVING | MH_PLANT));</a>
<a name="ln5823">        case POT_BERSERK_RAGE:</a>
<a name="ln5824">            return can_go_berserk();</a>
<a name="ln5825">        case POT_HASTE:</a>
<a name="ln5826">        case POT_MIGHT:</a>
<a name="ln5827">        case POT_INVISIBILITY:</a>
<a name="ln5828">        case POT_RESISTANCE:</a>
<a name="ln5829">            // If there are any item using monsters that are permanently</a>
<a name="ln5830">            // invisible, this might have to be restricted.</a>
<a name="ln5831">            return true;</a>
<a name="ln5832">        default:</a>
<a name="ln5833">            break;</a>
<a name="ln5834">        CASE_REMOVED_POTIONS(ptype)</a>
<a name="ln5835">    }</a>
<a name="ln5836"> </a>
<a name="ln5837">    return false;</a>
<a name="ln5838">}</a>
<a name="ln5839"> </a>
<a name="ln5840">bool monster::should_drink_potion(potion_type ptype) const</a>
<a name="ln5841">{</a>
<a name="ln5842">    switch (ptype)</a>
<a name="ln5843">    {</a>
<a name="ln5844">    case POT_CURING:</a>
<a name="ln5845">        return hit_points &lt;= max_hit_points / 2</a>
<a name="ln5846">               || has_ench(ENCH_POISON)</a>
<a name="ln5847">               || has_ench(ENCH_SICK)</a>
<a name="ln5848">               || has_ench(ENCH_CONFUSION);</a>
<a name="ln5849">    case POT_HEAL_WOUNDS:</a>
<a name="ln5850">        return hit_points &lt;= max_hit_points / 2;</a>
<a name="ln5851">    case POT_BERSERK_RAGE:</a>
<a name="ln5852">        // this implies !berserk()</a>
<a name="ln5853">        return !has_ench(ENCH_MIGHT) &amp;&amp; !has_ench(ENCH_HASTE)</a>
<a name="ln5854">               &amp;&amp; needs_berserk();</a>
<a name="ln5855">    case POT_HASTE:</a>
<a name="ln5856">        return !has_ench(ENCH_HASTE);</a>
<a name="ln5857">    case POT_MIGHT:</a>
<a name="ln5858">        return !has_ench(ENCH_MIGHT) &amp;&amp; foe_distance() &lt;= 2;</a>
<a name="ln5859">    case POT_RESISTANCE:</a>
<a name="ln5860">        return !has_ench(ENCH_RESISTANCE);</a>
<a name="ln5861">    case POT_INVISIBILITY:</a>
<a name="ln5862">        // We're being nice: friendlies won't go invisible if the player</a>
<a name="ln5863">        // won't be able to see them.</a>
<a name="ln5864">        return !has_ench(ENCH_INVIS)</a>
<a name="ln5865">               &amp;&amp; (you.can_see_invisible(false) || !friendly());</a>
<a name="ln5866">    default:</a>
<a name="ln5867">        break;</a>
<a name="ln5868">    CASE_REMOVED_POTIONS(ptype)</a>
<a name="ln5869">    }</a>
<a name="ln5870"> </a>
<a name="ln5871">    return false;</a>
<a name="ln5872">}</a>
<a name="ln5873"> </a>
<a name="ln5874">// Return true if the potion should be identified.</a>
<a name="ln5875">bool monster::drink_potion_effect(potion_type pot_eff, bool card)</a>
<a name="ln5876">{</a>
<a name="ln5877">    if (!card)</a>
<a name="ln5878">        simple_monster_message(*this, &quot; drinks a potion.&quot;);</a>
<a name="ln5879"> </a>
<a name="ln5880">    switch (pot_eff)</a>
<a name="ln5881">    {</a>
<a name="ln5882">    case POT_CURING:</a>
<a name="ln5883">    {</a>
<a name="ln5884">        if (heal(5 + random2(7)))</a>
<a name="ln5885">            simple_monster_message(*this, &quot; is healed!&quot;);</a>
<a name="ln5886"> </a>
<a name="ln5887">        static const enchant_type cured_enchants[] =</a>
<a name="ln5888">        {</a>
<a name="ln5889">            ENCH_POISON, ENCH_SICK, ENCH_CONFUSION</a>
<a name="ln5890">        };</a>
<a name="ln5891"> </a>
<a name="ln5892">        for (enchant_type cured : cured_enchants)</a>
<a name="ln5893">            del_ench(cured);</a>
<a name="ln5894">    }</a>
<a name="ln5895">    break;</a>
<a name="ln5896"> </a>
<a name="ln5897">    case POT_HEAL_WOUNDS:</a>
<a name="ln5898">        if (heal(10 + random2avg(28, 3)))</a>
<a name="ln5899">            simple_monster_message(*this, &quot; is healed!&quot;);</a>
<a name="ln5900">        break;</a>
<a name="ln5901"> </a>
<a name="ln5902">    case POT_BERSERK_RAGE:</a>
<a name="ln5903">        enchant_actor_with_flavour(this, this, BEAM_BERSERK);</a>
<a name="ln5904">        break;</a>
<a name="ln5905"> </a>
<a name="ln5906">    case POT_HASTE:</a>
<a name="ln5907">        enchant_actor_with_flavour(this, this, BEAM_HASTE);</a>
<a name="ln5908">        break;</a>
<a name="ln5909"> </a>
<a name="ln5910">    case POT_MIGHT:</a>
<a name="ln5911">        enchant_actor_with_flavour(this, this, BEAM_MIGHT);</a>
<a name="ln5912">        break;</a>
<a name="ln5913"> </a>
<a name="ln5914">    case POT_INVISIBILITY:</a>
<a name="ln5915">        enchant_actor_with_flavour(this, this, BEAM_INVISIBILITY);</a>
<a name="ln5916">        break;</a>
<a name="ln5917"> </a>
<a name="ln5918">    case POT_RESISTANCE:</a>
<a name="ln5919">        enchant_actor_with_flavour(this, this, BEAM_RESISTANCE);</a>
<a name="ln5920">        break;</a>
<a name="ln5921"> </a>
<a name="ln5922">    default:</a>
<a name="ln5923">        return false;</a>
<a name="ln5924">    CASE_REMOVED_POTIONS(pot_eff)</a>
<a name="ln5925">    }</a>
<a name="ln5926"> </a>
<a name="ln5927">    return !card;</a>
<a name="ln5928">}</a>
<a name="ln5929"> </a>
<a name="ln5930">bool monster::can_evoke_jewellery(jewellery_type jtype) const</a>
<a name="ln5931">{</a>
<a name="ln5932">    if (mons_class_is_stationary(type))</a>
<a name="ln5933">        return false;</a>
<a name="ln5934"> </a>
<a name="ln5935">    if (mons_itemuse(*this) &lt; MONUSE_STARTING_EQUIPMENT)</a>
<a name="ln5936">        return false;</a>
<a name="ln5937"> </a>
<a name="ln5938">    switch (jtype)</a>
<a name="ln5939">    {</a>
<a name="ln5940">        case AMU_RAGE:</a>
<a name="ln5941">            return can_go_berserk();</a>
<a name="ln5942">        default:</a>
<a name="ln5943">            break;</a>
<a name="ln5944">    }</a>
<a name="ln5945"> </a>
<a name="ln5946">    return false;</a>
<a name="ln5947">}</a>
<a name="ln5948"> </a>
<a name="ln5949">bool monster::should_evoke_jewellery(jewellery_type jtype) const</a>
<a name="ln5950">{</a>
<a name="ln5951">    switch (jtype)</a>
<a name="ln5952">    {</a>
<a name="ln5953">    case AMU_RAGE:</a>
<a name="ln5954">        // this implies !berserk()</a>
<a name="ln5955">        return !has_ench(ENCH_MIGHT) &amp;&amp; !has_ench(ENCH_HASTE)</a>
<a name="ln5956">               &amp;&amp; needs_berserk();</a>
<a name="ln5957">    default:</a>
<a name="ln5958">        break;</a>
<a name="ln5959">    }</a>
<a name="ln5960"> </a>
<a name="ln5961">    return false;</a>
<a name="ln5962">}</a>
<a name="ln5963"> </a>
<a name="ln5964">// Return true if the jewellery should be identified.</a>
<a name="ln5965">bool monster::evoke_jewellery_effect(jewellery_type jtype)</a>
<a name="ln5966">{</a>
<a name="ln5967">    // XXX: this is mostly to prevent a funny message order:</a>
<a name="ln5968">    // &quot;$foo evokes its amulet. $foo wields a great mace. $foo goes berserk!&quot;</a>
<a name="ln5969">    if (jtype == AMU_RAGE)</a>
<a name="ln5970">        wield_melee_weapon();</a>
<a name="ln5971"> </a>
<a name="ln5972">    mprf(&quot;%s evokes %s %s.&quot;, name(DESC_THE).c_str(),</a>
<a name="ln5973">         pronoun(PRONOUN_POSSESSIVE).c_str(),</a>
<a name="ln5974">         jewellery_is_amulet(jtype) ? &quot;amulet&quot; : &quot;ring&quot;);</a>
<a name="ln5975"> </a>
<a name="ln5976">    switch (jtype)</a>
<a name="ln5977">    {</a>
<a name="ln5978">    case AMU_RAGE:</a>
<a name="ln5979">        enchant_actor_with_flavour(this, this, BEAM_BERSERK);</a>
<a name="ln5980">        break;</a>
<a name="ln5981"> </a>
<a name="ln5982">    default:</a>
<a name="ln5983">        return false;</a>
<a name="ln5984">    }</a>
<a name="ln5985"> </a>
<a name="ln5986">    return true;</a>
<a name="ln5987">}</a>
<a name="ln5988"> </a>
<a name="ln5989">void monster::react_to_damage(const actor *oppressor, int damage,</a>
<a name="ln5990">                               beam_type flavour)</a>
<a name="ln5991">{</a>
<a name="ln5992">    // Don't discharge on small amounts of damage (this helps avoid</a>
<a name="ln5993">    // continuously shocking when poisoned or sticky flamed)</a>
<a name="ln5994">    // XXX: this might not be necessary anymore?</a>
<a name="ln5995">    if (type == MONS_SHOCK_SERPENT &amp;&amp; damage &gt; 4 &amp;&amp; oppressor &amp;&amp; oppressor != this)</a>
<a name="ln5996">    {</a>
<a name="ln5997">        const int pow = div_rand_round(min(damage, hit_points + damage), 9);</a>
<a name="ln5998">        if (pow)</a>
<a name="ln5999">        {</a>
<a name="ln6000">            // we intentionally allow harming the oppressor in this case,</a>
<a name="ln6001">            // so need to cast off its constness</a>
<a name="ln6002">            shock_serpent_discharge_fineff::schedule(this,</a>
<a name="ln6003">                                                     const_cast&lt;actor&amp;&gt;(*oppressor),</a>
<a name="ln6004">                                                     pos(), pow);</a>
<a name="ln6005">        }</a>
<a name="ln6006">    }</a>
<a name="ln6007"> </a>
<a name="ln6008">    // The (real) royal jelly objects to taking damage and will SULK. :-)</a>
<a name="ln6009">    if (type == MONS_ROYAL_JELLY &amp;&amp; !is_summoned())</a>
<a name="ln6010">        trj_spawn_fineff::schedule(oppressor, this, pos(), damage);</a>
<a name="ln6011"> </a>
<a name="ln6012">    // Damage sharing from the spectral weapon to its owner</a>
<a name="ln6013">    // The damage shared should not be directly lethal, though like the</a>
<a name="ln6014">    // pain spell, it can leave the player at a very dangerous 1hp.</a>
<a name="ln6015">    // XXX: This makes a lot of messages, especially when the spectral weapon</a>
<a name="ln6016">    //      is hit by a monster with multiple attacks and is frozen, burned, etc.</a>
<a name="ln6017">    if (type == MONS_SPECTRAL_WEAPON &amp;&amp; oppressor)</a>
<a name="ln6018">    {</a>
<a name="ln6019">        // The owner should not be able to damage itself</a>
<a name="ln6020">        // XXX: the mid check here is intended to treat the player's shadow</a>
<a name="ln6021">        // mimic as the player itself, i.e. the weapon won't share damage</a>
<a name="ln6022">        // the shadow mimic inflicts on it (this causes a crash).</a>
<a name="ln6023">        actor *owner = actor_by_mid(summoner);</a>
<a name="ln6024">        if (owner &amp;&amp; owner != oppressor &amp;&amp; oppressor-&gt;mid != summoner)</a>
<a name="ln6025">        {</a>
<a name="ln6026">            int shared_damage = damage / 2;</a>
<a name="ln6027">            if (shared_damage &gt; 0)</a>
<a name="ln6028">            {</a>
<a name="ln6029">                if (owner-&gt;is_player())</a>
<a name="ln6030">                    mpr(&quot;Your spectral weapon shares its damage with you!&quot;);</a>
<a name="ln6031">                else if (owner-&gt;alive() &amp;&amp; you.can_see(*owner))</a>
<a name="ln6032">                {</a>
<a name="ln6033">                    string buf = &quot; shares &quot;;</a>
<a name="ln6034">                    buf += owner-&gt;pronoun(PRONOUN_POSSESSIVE);</a>
<a name="ln6035">                    buf += &quot; spectral weapon's damage!&quot;;</a>
<a name="ln6036">                    simple_monster_message(*owner-&gt;as_monster(), buf.c_str());</a>
<a name="ln6037">                }</a>
<a name="ln6038"> </a>
<a name="ln6039">                // Share damage using a fineff, so that it's non-fatal</a>
<a name="ln6040">                // regardless of processing order in an AoE attack.</a>
<a name="ln6041">                deferred_damage_fineff::schedule(oppressor, owner,</a>
<a name="ln6042">                                                 shared_damage, false, false);</a>
<a name="ln6043">            }</a>
<a name="ln6044">        }</a>
<a name="ln6045">    }</a>
<a name="ln6046">    else if (mons_is_tentacle_or_tentacle_segment(type)</a>
<a name="ln6047">             &amp;&amp; !mons_is_solo_tentacle(type)</a>
<a name="ln6048">             &amp;&amp; flavour != BEAM_TORMENT_DAMAGE</a>
<a name="ln6049">             &amp;&amp; monster_by_mid(tentacle_connect)</a>
<a name="ln6050">             &amp;&amp; monster_by_mid(tentacle_connect)-&gt;is_parent_monster_of(this))</a>
<a name="ln6051">    {</a>
<a name="ln6052">        deferred_damage_fineff::schedule(oppressor,</a>
<a name="ln6053">                                         monster_by_mid(tentacle_connect),</a>
<a name="ln6054">                                         damage, false);</a>
<a name="ln6055">    }</a>
<a name="ln6056"> </a>
<a name="ln6057">    if (!alive())</a>
<a name="ln6058">        return;</a>
<a name="ln6059"> </a>
<a name="ln6060">    if (!mons_is_tentacle_or_tentacle_segment(type)</a>
<a name="ln6061">        &amp;&amp; has_ench(ENCH_INNER_FLAME) &amp;&amp; oppressor &amp;&amp; damage)</a>
<a name="ln6062">    {</a>
<a name="ln6063">        mon_enchant i_f = get_ench(ENCH_INNER_FLAME);</a>
<a name="ln6064">        if (you.see_cell(pos()))</a>
<a name="ln6065">            mprf(&quot;Flame seeps out of %s.&quot;, name(DESC_THE).c_str());</a>
<a name="ln6066">        check_place_cloud(CLOUD_FIRE, pos(), 3, actor_by_mid(i_f.source));</a>
<a name="ln6067">    }</a>
<a name="ln6068"> </a>
<a name="ln6069"> </a>
<a name="ln6070">    if (mons_species() == MONS_BUSH</a>
<a name="ln6071">        &amp;&amp; res_fire() &lt; 0 &amp;&amp; flavour == BEAM_FIRE</a>
<a name="ln6072">        &amp;&amp; damage &gt; 8 &amp;&amp; x_chance_in_y(damage, 20))</a>
<a name="ln6073">    {</a>
<a name="ln6074">        place_cloud(CLOUD_FIRE, pos(), 20 + random2(15), oppressor, 5);</a>
<a name="ln6075">    }</a>
<a name="ln6076">    else if (type == MONS_SPRIGGAN_RIDER)</a>
<a name="ln6077">    {</a>
<a name="ln6078">        if (hit_points + damage &gt; max_hit_points / 2)</a>
<a name="ln6079">            damage = max_hit_points / 2 - hit_points;</a>
<a name="ln6080">        if (damage &gt; 0 &amp;&amp; x_chance_in_y(damage, damage + hit_points)</a>
<a name="ln6081">            &amp;&amp; flavour != BEAM_TORMENT_DAMAGE)</a>
<a name="ln6082">        {</a>
<a name="ln6083">            bool fly_died = coinflip();</a>
<a name="ln6084">            int old_hp                = hit_points;</a>
<a name="ln6085">            auto old_flags            = flags;</a>
<a name="ln6086">            mon_enchant_list old_ench = enchantments;</a>
<a name="ln6087">            FixedBitVector&lt;NUM_ENCHANTMENTS&gt; old_ench_cache = ench_cache;</a>
<a name="ln6088">            int8_t old_ench_countdown = ench_countdown;</a>
<a name="ln6089">            string old_name = mname;</a>
<a name="ln6090"> </a>
<a name="ln6091">            if (!fly_died)</a>
<a name="ln6092">                monster_drop_things(this, mons_aligned(oppressor, &amp;you));</a>
<a name="ln6093"> </a>
<a name="ln6094">            type = fly_died ? MONS_SPRIGGAN : MONS_HORNET;</a>
<a name="ln6095">            define_monster(*this);</a>
<a name="ln6096">            hit_points = min(old_hp, hit_points);</a>
<a name="ln6097">            flags          = old_flags;</a>
<a name="ln6098">            enchantments   = old_ench;</a>
<a name="ln6099">            ench_cache     = old_ench_cache;</a>
<a name="ln6100">            ench_countdown = old_ench_countdown;</a>
<a name="ln6101">            // Keep the rider's name, if it had one (Mercenary card).</a>
<a name="ln6102">            if (!old_name.empty())</a>
<a name="ln6103">                mname = old_name;</a>
<a name="ln6104"> </a>
<a name="ln6105">            mounted_kill(this, fly_died ? MONS_HORNET : MONS_SPRIGGAN,</a>
<a name="ln6106">                !oppressor ? KILL_MISC</a>
<a name="ln6107">                : (oppressor-&gt;is_player())</a>
<a name="ln6108">                  ? KILL_YOU : KILL_MON,</a>
<a name="ln6109">                (oppressor &amp;&amp; oppressor-&gt;is_monster())</a>
<a name="ln6110">                  ? oppressor-&gt;mindex() : NON_MONSTER);</a>
<a name="ln6111"> </a>
<a name="ln6112">            // Now clear the name, if the rider just died.</a>
<a name="ln6113">            if (!fly_died)</a>
<a name="ln6114">                mname.clear();</a>
<a name="ln6115"> </a>
<a name="ln6116">            if (fly_died &amp;&amp; !is_habitable(pos()))</a>
<a name="ln6117">            {</a>
<a name="ln6118">                hit_points = 0;</a>
<a name="ln6119">                if (observable())</a>
<a name="ln6120">                {</a>
<a name="ln6121">                    mprf(&quot;As %s mount dies, %s plunges down into %s!&quot;,</a>
<a name="ln6122">                         pronoun(PRONOUN_POSSESSIVE).c_str(),</a>
<a name="ln6123">                         name(DESC_THE).c_str(),</a>
<a name="ln6124">                         grd(pos()) == DNGN_LAVA ?</a>
<a name="ln6125">                             &quot;lava and is incinerated&quot; :</a>
<a name="ln6126">                             &quot;deep water and drowns&quot;);</a>
<a name="ln6127">                }</a>
<a name="ln6128">            }</a>
<a name="ln6129">            else if (fly_died &amp;&amp; observable())</a>
<a name="ln6130">            {</a>
<a name="ln6131">                mprf(&quot;%s falls from %s now dead mount.&quot;,</a>
<a name="ln6132">                     name(DESC_THE).c_str(),</a>
<a name="ln6133">                     pronoun(PRONOUN_POSSESSIVE).c_str());</a>
<a name="ln6134">            }</a>
<a name="ln6135">        }</a>
<a name="ln6136">    }</a>
<a name="ln6137">    else if (type == MONS_STARCURSED_MASS)</a>
<a name="ln6138">        starcursed_merge_fineff::schedule(this);</a>
<a name="ln6139">    else if (type == MONS_RAKSHASA &amp;&amp; !has_ench(ENCH_PHANTOM_MIRROR)</a>
<a name="ln6140">             &amp;&amp; hit_points &lt; max_hit_points / 2</a>
<a name="ln6141">             &amp;&amp; hit_points - damage &gt; 0)</a>
<a name="ln6142">    {</a>
<a name="ln6143">        if (!props.exists(&quot;emergency_clone&quot;))</a>
<a name="ln6144">        {</a>
<a name="ln6145">            rakshasa_clone_fineff::schedule(this, pos());</a>
<a name="ln6146">            props[&quot;emergency_clone&quot;].get_bool() = true;</a>
<a name="ln6147">        }</a>
<a name="ln6148">    }</a>
<a name="ln6149"> </a>
<a name="ln6150">    else if (type == MONS_BAI_SUZHEN &amp;&amp; hit_points &lt; max_hit_points / 2</a>
<a name="ln6151">                                     &amp;&amp; hit_points - damage &gt; 0)</a>
<a name="ln6152">    {</a>
<a name="ln6153">        int old_hp                = hit_points;</a>
<a name="ln6154">        auto old_flags            = flags;</a>
<a name="ln6155">        mon_enchant_list old_ench = enchantments;</a>
<a name="ln6156">        FixedBitVector&lt;NUM_ENCHANTMENTS&gt; old_ench_cache = ench_cache;</a>
<a name="ln6157">        int8_t old_ench_countdown = ench_countdown;</a>
<a name="ln6158">        string old_name = mname;</a>
<a name="ln6159"> </a>
<a name="ln6160">        monster_drop_things(this, mons_aligned(oppressor, &amp;you));</a>
<a name="ln6161"> </a>
<a name="ln6162">        type = MONS_BAI_SUZHEN_DRAGON;</a>
<a name="ln6163">        define_monster(*this);</a>
<a name="ln6164">        hit_points = min(old_hp, hit_points);</a>
<a name="ln6165">        flags          = old_flags;</a>
<a name="ln6166">        enchantments   = old_ench;</a>
<a name="ln6167">        ench_cache     = old_ench_cache;</a>
<a name="ln6168">        ench_countdown = old_ench_countdown;</a>
<a name="ln6169"> </a>
<a name="ln6170">        if (observable())</a>
<a name="ln6171">        {</a>
<a name="ln6172">            mprf(MSGCH_WARN,</a>
<a name="ln6173">                &quot;%s roars in fury and transforms into a fierce dragon!&quot;,</a>
<a name="ln6174">                name(DESC_THE).c_str());</a>
<a name="ln6175">        }</a>
<a name="ln6176">        if (caught())</a>
<a name="ln6177">            check_net_will_hold_monster(this);</a>
<a name="ln6178">        if (this-&gt;is_constricted())</a>
<a name="ln6179">            this-&gt;stop_being_constricted();</a>
<a name="ln6180"> </a>
<a name="ln6181">        add_ench(ENCH_RING_OF_THUNDER);</a>
<a name="ln6182">    }</a>
<a name="ln6183">}</a>
<a name="ln6184"> </a>
<a name="ln6185">reach_type monster::reach_range() const</a>
<a name="ln6186">{</a>
<a name="ln6187">    const mon_attack_def attk(mons_attack_spec(*this, 0));</a>
<a name="ln6188">    if ((attk.flavour == AF_REACH || attk.flavour == AF_REACH_STING)</a>
<a name="ln6189">        &amp;&amp; attk.damage)</a>
<a name="ln6190">    {</a>
<a name="ln6191">        return REACH_TWO;</a>
<a name="ln6192">    }</a>
<a name="ln6193"> </a>
<a name="ln6194">    const item_def *wpn = primary_weapon();</a>
<a name="ln6195">    if (wpn)</a>
<a name="ln6196">        return weapon_reach(*wpn);</a>
<a name="ln6197">    return REACH_NONE;</a>
<a name="ln6198">}</a>
<a name="ln6199"> </a>
<a name="ln6200">void monster::steal_item_from_player()</a>
<a name="ln6201">{</a>
<a name="ln6202">    if (confused())</a>
<a name="ln6203">    {</a>
<a name="ln6204">        string msg = getSpeakString(&quot;Maurice confused nonstealing&quot;);</a>
<a name="ln6205">        if (!msg.empty() &amp;&amp; msg != &quot;__NONE&quot;)</a>
<a name="ln6206">        {</a>
<a name="ln6207">            msg = replace_all(msg, &quot;@The_monster@&quot;, name(DESC_THE));</a>
<a name="ln6208">            mprf(MSGCH_TALK, &quot;%s&quot;, msg.c_str());</a>
<a name="ln6209">        }</a>
<a name="ln6210">        return;</a>
<a name="ln6211">    }</a>
<a name="ln6212">    // Theft isn't very peaceful. More importantly, you would risk losing the</a>
<a name="ln6213">    // item forever when the monster flees the level.</a>
<a name="ln6214">    if (pacified())</a>
<a name="ln6215">        return;</a>
<a name="ln6216"> </a>
<a name="ln6217">    mon_inv_type mslot = NUM_MONSTER_SLOTS;</a>
<a name="ln6218">    int steal_what  = -1;</a>
<a name="ln6219">    int total_value = 0;</a>
<a name="ln6220">    for (int m = 0; m &lt; ENDOFPACK; ++m)</a>
<a name="ln6221">    {</a>
<a name="ln6222">        if (!you.inv[m].defined())</a>
<a name="ln6223">            continue;</a>
<a name="ln6224"> </a>
<a name="ln6225">        // Cannot unequip player.</a>
<a name="ln6226">        // TODO: Allow stealing of the wielded weapon?</a>
<a name="ln6227">        //       Needs to be unwielded properly and should never lead to</a>
<a name="ln6228">        //       fatal stat loss.</a>
<a name="ln6229">        // 1KB: I'd say no, weapon is being held, it's different from pulling</a>
<a name="ln6230">        //      a wand from your pocket.</a>
<a name="ln6231">        if (item_is_equipped(you.inv[m]))</a>
<a name="ln6232">            continue;</a>
<a name="ln6233"> </a>
<a name="ln6234">        mon_inv_type monslot = item_to_mslot(you.inv[m]);</a>
<a name="ln6235">        if (monslot == NUM_MONSTER_SLOTS)</a>
<a name="ln6236">            continue;</a>
<a name="ln6237"> </a>
<a name="ln6238">        // Only try to steal stuff we can still store somewhere.</a>
<a name="ln6239">        if (inv[monslot] != NON_ITEM)</a>
<a name="ln6240">        {</a>
<a name="ln6241">            if (monslot == MSLOT_WEAPON</a>
<a name="ln6242">                &amp;&amp; inv[MSLOT_ALT_WEAPON] == NON_ITEM)</a>
<a name="ln6243">            {</a>
<a name="ln6244">                monslot = MSLOT_ALT_WEAPON;</a>
<a name="ln6245">            }</a>
<a name="ln6246">            else</a>
<a name="ln6247">                continue;</a>
<a name="ln6248">        }</a>
<a name="ln6249"> </a>
<a name="ln6250">        // Candidate for stealing.</a>
<a name="ln6251">        const int value = item_value(you.inv[m], true);</a>
<a name="ln6252">        total_value += value;</a>
<a name="ln6253"> </a>
<a name="ln6254">        if (x_chance_in_y(value, total_value))</a>
<a name="ln6255">        {</a>
<a name="ln6256">            steal_what = m;</a>
<a name="ln6257">            mslot      = monslot;</a>
<a name="ln6258">        }</a>
<a name="ln6259">    }</a>
<a name="ln6260"> </a>
<a name="ln6261">    if (steal_what == -1 || you.gold &gt; 0 &amp;&amp; one_chance_in(10))</a>
<a name="ln6262">    {</a>
<a name="ln6263">        // Found no item worth stealing, try gold.</a>
<a name="ln6264">        if (you.gold == 0)</a>
<a name="ln6265">        {</a>
<a name="ln6266">            if (silenced(pos()))</a>
<a name="ln6267">                return;</a>
<a name="ln6268"> </a>
<a name="ln6269">            string complaint = getSpeakString(&quot;Maurice nonstealing&quot;);</a>
<a name="ln6270">            if (!complaint.empty())</a>
<a name="ln6271">            {</a>
<a name="ln6272">                complaint = replace_all(complaint, &quot;@The_monster@&quot;,</a>
<a name="ln6273">                                        name(DESC_THE));</a>
<a name="ln6274">                mprf(MSGCH_TALK, &quot;%s&quot;, complaint.c_str());</a>
<a name="ln6275">            }</a>
<a name="ln6276"> </a>
<a name="ln6277">            bolt beem;</a>
<a name="ln6278">            beem.source    = pos();</a>
<a name="ln6279">            beem.target    = pos();</a>
<a name="ln6280">            beem.source_id = mid;</a>
<a name="ln6281"> </a>
<a name="ln6282">            // Try to teleport away.</a>
<a name="ln6283">            if (no_tele())</a>
<a name="ln6284">                return;</a>
<a name="ln6285"> </a>
<a name="ln6286">            if (has_ench(ENCH_TP))</a>
<a name="ln6287">            {</a>
<a name="ln6288">                mons_cast_noise(this, beem, SPELL_BLINK, MON_SPELL_WIZARD);</a>
<a name="ln6289">                // this can kill us, delay the call</a>
<a name="ln6290">                blink_fineff::schedule(this);</a>
<a name="ln6291">            }</a>
<a name="ln6292">            else</a>
<a name="ln6293">                mons_cast(this, beem, SPELL_TELEPORT_SELF, MON_SPELL_WIZARD);</a>
<a name="ln6294"> </a>
<a name="ln6295">            return;</a>
<a name="ln6296">        }</a>
<a name="ln6297"> </a>
<a name="ln6298">        const int stolen_amount = min(20 + random2(800), you.gold);</a>
<a name="ln6299">        if (inv[MSLOT_GOLD] != NON_ITEM)</a>
<a name="ln6300">        {</a>
<a name="ln6301">            // If Maurice already's got some gold, simply increase the amount.</a>
<a name="ln6302">            mitm[inv[MSLOT_GOLD]].quantity += stolen_amount;</a>
<a name="ln6303">            // Don't re-tithe stolen gold under Zin.</a>
<a name="ln6304">            mitm[inv[MSLOT_GOLD]].tithe_state = (you_worship(GOD_ZIN))</a>
<a name="ln6305">                                                ? TS_NO_TITHE : TS_NO_PIETY;</a>
<a name="ln6306">        }</a>
<a name="ln6307">        else</a>
<a name="ln6308">        {</a>
<a name="ln6309">            // Else create a new item for this pile of gold.</a>
<a name="ln6310">            const int idx = items(false, OBJ_GOLD, OBJ_RANDOM, 0);</a>
<a name="ln6311">            if (idx == NON_ITEM)</a>
<a name="ln6312">                return;</a>
<a name="ln6313"> </a>
<a name="ln6314">            item_def &amp;new_item = mitm[idx];</a>
<a name="ln6315">            new_item.base_type = OBJ_GOLD;</a>
<a name="ln6316">            new_item.sub_type  = 0;</a>
<a name="ln6317">            // Don't re-tithe stolen gold under Zin.</a>
<a name="ln6318">            new_item.tithe_state = (you_worship(GOD_ZIN)) ? TS_NO_TITHE</a>
<a name="ln6319">                                                          : TS_NO_PIETY;</a>
<a name="ln6320">            new_item.plus2     = 0;</a>
<a name="ln6321">            new_item.special   = 0;</a>
<a name="ln6322">            new_item.flags     = 0;</a>
<a name="ln6323">            new_item.link      = NON_ITEM;</a>
<a name="ln6324">            new_item.quantity  = stolen_amount;</a>
<a name="ln6325">            new_item.pos.reset();</a>
<a name="ln6326">            item_colour(new_item);</a>
<a name="ln6327"> </a>
<a name="ln6328">            unlink_item(idx);</a>
<a name="ln6329"> </a>
<a name="ln6330">            inv[MSLOT_GOLD] = idx;</a>
<a name="ln6331">            new_item.set_holding_monster(*this);</a>
<a name="ln6332">        }</a>
<a name="ln6333">        mprf(&quot;%s steals %d gold piece%s!&quot;,</a>
<a name="ln6334">             name(DESC_THE).c_str(),</a>
<a name="ln6335">             stolen_amount,</a>
<a name="ln6336">             stolen_amount != 1 ? &quot;s&quot; : &quot;&quot;);</a>
<a name="ln6337"> </a>
<a name="ln6338">        you.attribute[ATTR_GOLD_FOUND] -= stolen_amount;</a>
<a name="ln6339"> </a>
<a name="ln6340">        you.del_gold(stolen_amount);</a>
<a name="ln6341">        mprf(&quot;You now have %d gold piece%s.&quot;,</a>
<a name="ln6342">             you.gold, you.gold != 1 ? &quot;s&quot; : &quot;&quot;);</a>
<a name="ln6343"> </a>
<a name="ln6344">        return;</a>
<a name="ln6345">    }</a>
<a name="ln6346"> </a>
<a name="ln6347">    ASSERT(steal_what != -1);</a>
<a name="ln6348">    ASSERT(mslot != NUM_MONSTER_SLOTS);</a>
<a name="ln6349">    ASSERT(inv[mslot] == NON_ITEM);</a>
<a name="ln6350"> </a>
<a name="ln6351">    item_def* tmp = take_item(steal_what, mslot, true);</a>
<a name="ln6352">    if (!tmp)</a>
<a name="ln6353">        return;</a>
<a name="ln6354">    item_def&amp; new_item = *tmp;</a>
<a name="ln6355"> </a>
<a name="ln6356">    // You'll want to autopickup it after killing Maurice.</a>
<a name="ln6357">    new_item.flags |= ISFLAG_THROWN;</a>
<a name="ln6358"> </a>
<a name="ln6359">    // Fix up blood/chunk timers.</a>
<a name="ln6360">    const int orig_qty = you.inv[steal_what].quantity;</a>
<a name="ln6361">    if (is_perishable_stack(new_item))</a>
<a name="ln6362">    {</a>
<a name="ln6363">        // Somehow they always steal the freshest blood.</a>
<a name="ln6364">        for (int i = new_item.quantity; i &lt; orig_qty; ++i)</a>
<a name="ln6365">            remove_oldest_perishable_item(new_item);</a>
<a name="ln6366"> </a>
<a name="ln6367">        // If the whole stack is gone, it doesn't need to be cleaned up.</a>
<a name="ln6368">        if (you.inv[steal_what].defined())</a>
<a name="ln6369">            remove_newest_perishable_item(you.inv[steal_what]);</a>
<a name="ln6370">    }</a>
<a name="ln6371">}</a>
<a name="ln6372"> </a>
<a name="ln6373">/**</a>
<a name="ln6374"> * &quot;Give&quot; a monster an item from the player's inventory.</a>
<a name="ln6375"> *</a>
<a name="ln6376"> * @param steal_what The slot in your inventory of the item.</a>
<a name="ln6377"> * @param mslot Which mon_inv_type to put the item in</a>
<a name="ln6378"> *</a>
<a name="ln6379"> * @returns new_item the new item, now in the monster's inventory.</a>
<a name="ln6380"> */</a>
<a name="ln6381">item_def* monster::take_item(int steal_what, mon_inv_type mslot,</a>
<a name="ln6382">                             bool is_stolen)</a>
<a name="ln6383">{</a>
<a name="ln6384">    // Create new item.</a>
<a name="ln6385">    int index = get_mitm_slot(10);</a>
<a name="ln6386">    if (index == NON_ITEM)</a>
<a name="ln6387">        return nullptr;</a>
<a name="ln6388"> </a>
<a name="ln6389">    item_def &amp;new_item = mitm[index];</a>
<a name="ln6390"> </a>
<a name="ln6391">    // Copy item.</a>
<a name="ln6392">    new_item = you.inv[steal_what];</a>
<a name="ln6393"> </a>
<a name="ln6394">    // If the item was stolen, randomize quantity</a>
<a name="ln6395">    if (is_stolen)</a>
<a name="ln6396">    {</a>
<a name="ln6397">        const int stolen_amount = 1 + random2(new_item.quantity);</a>
<a name="ln6398">        if (stolen_amount &lt; new_item.quantity)</a>
<a name="ln6399">        {</a>
<a name="ln6400">            mprf(&quot;%s steals %d of %s!&quot;,</a>
<a name="ln6401">                 name(DESC_THE).c_str(),</a>
<a name="ln6402">                 stolen_amount,</a>
<a name="ln6403">                 new_item.name(DESC_YOUR).c_str());</a>
<a name="ln6404">        }</a>
<a name="ln6405">        else</a>
<a name="ln6406">        {</a>
<a name="ln6407">            mprf(&quot;%s steals %s!&quot;,</a>
<a name="ln6408">                 name(DESC_THE).c_str(),</a>
<a name="ln6409">                 new_item.name(DESC_YOUR).c_str());</a>
<a name="ln6410">        }</a>
<a name="ln6411">        new_item.quantity = stolen_amount;</a>
<a name="ln6412">    }</a>
<a name="ln6413"> </a>
<a name="ln6414">    // Drop the item already in the slot (including the shield</a>
<a name="ln6415">    // if it's a two-hander).</a>
<a name="ln6416">    // TODO: fail conditions here have an awkward ordering with the steal msgs</a>
<a name="ln6417">    if ((mslot == MSLOT_WEAPON || mslot == MSLOT_ALT_WEAPON)</a>
<a name="ln6418">        &amp;&amp; inv[MSLOT_SHIELD] != NON_ITEM</a>
<a name="ln6419">        &amp;&amp; hands_reqd(new_item) == HANDS_TWO</a>
<a name="ln6420">        &amp;&amp; !drop_item(MSLOT_SHIELD, observable()))</a>
<a name="ln6421">    {</a>
<a name="ln6422">        return nullptr;</a>
<a name="ln6423">    }</a>
<a name="ln6424">    if (inv[mslot] != NON_ITEM &amp;&amp; !drop_item(mslot, observable()))</a>
<a name="ln6425">        return nullptr;</a>
<a name="ln6426"> </a>
<a name="ln6427">    // Set the item as unlinked.</a>
<a name="ln6428">    new_item.pos.reset();</a>
<a name="ln6429">    new_item.link = NON_ITEM;</a>
<a name="ln6430">    unlink_item(index);</a>
<a name="ln6431">    inv[mslot] = index;</a>
<a name="ln6432">    new_item.set_holding_monster(*this);</a>
<a name="ln6433"> </a>
<a name="ln6434">    if (mslot != MSLOT_ALT_WEAPON || mons_wields_two_weapons(*this))</a>
<a name="ln6435">        equip_message(new_item);</a>
<a name="ln6436"> </a>
<a name="ln6437">    // Item is gone from player's inventory.</a>
<a name="ln6438">    dec_inv_item_quantity(steal_what, new_item.quantity);</a>
<a name="ln6439"> </a>
<a name="ln6440">    return &amp;new_item;</a>
<a name="ln6441">}</a>
<a name="ln6442"> </a>
<a name="ln6443">/** Disarm this monster, and preferably pull the weapon into your tile.</a>
<a name="ln6444"> *</a>
<a name="ln6445"> *  @returns a pointer to the weapon disarmed, or nullptr if unsuccessful.</a>
<a name="ln6446"> */</a>
<a name="ln6447">item_def* monster::disarm()</a>
<a name="ln6448">{</a>
<a name="ln6449">    item_def *mons_wpn = mslot_item(MSLOT_WEAPON);</a>
<a name="ln6450"> </a>
<a name="ln6451">    // is it ok to move the weapon into your tile (w/o destroying it?)</a>
<a name="ln6452">    const bool your_tile_ok = !feat_eliminates_items(grd(you.pos()));</a>
<a name="ln6453"> </a>
<a name="ln6454">    // It's ok to drop the weapon into deep water if it comes out right away,</a>
<a name="ln6455">    // but if the monster is on lava we just have to abort.</a>
<a name="ln6456">    const bool mon_tile_ok = !feat_destroys_items(grd(pos()))</a>
<a name="ln6457">                             &amp;&amp; (your_tile_ok</a>
<a name="ln6458">                                 || !feat_eliminates_items(grd(pos())));</a>
<a name="ln6459"> </a>
<a name="ln6460">    if (!mons_wpn</a>
<a name="ln6461">        || mons_wpn-&gt;cursed()</a>
<a name="ln6462">        || mons_class_is_animated_weapon(type)</a>
<a name="ln6463">        || !adjacent(you.pos(), pos())</a>
<a name="ln6464">        || !you.can_see(*this)</a>
<a name="ln6465">        || !mon_tile_ok</a>
<a name="ln6466">        || mons_wpn-&gt;flags &amp; ISFLAG_SUMMONED)</a>
<a name="ln6467">    {</a>
<a name="ln6468">        return nullptr;</a>
<a name="ln6469">    }</a>
<a name="ln6470"> </a>
<a name="ln6471">    drop_item(MSLOT_WEAPON, false);</a>
<a name="ln6472"> </a>
<a name="ln6473">    // XXX: assumes nothing's re-ordering items - e.g. gozag gold</a>
<a name="ln6474">    if (your_tile_ok)</a>
<a name="ln6475">        move_top_item(pos(), you.pos());</a>
<a name="ln6476"> </a>
<a name="ln6477">    if (type == MONS_CEREBOV)</a>
<a name="ln6478">        you.props[CEREBOV_DISARMED_KEY] = true;</a>
<a name="ln6479"> </a>
<a name="ln6480">    return mons_wpn;</a>
<a name="ln6481">}</a>
<a name="ln6482"> </a>
<a name="ln6483">/**</a>
<a name="ln6484"> * Checks if the monster can pass through webs freely.</a>
<a name="ln6485"> *</a>
<a name="ln6486"> * Currently: spiders (including Arachne), moths, demonic crawlers,</a>
<a name="ln6487"> * ghosts &amp; other incorporeal monsters, and jelly monsters.</a>
<a name="ln6488"> *</a>
<a name="ln6489"> * @return Whether the monster is immune to webs.</a>
<a name="ln6490"> */</a>
<a name="ln6491">bool monster::is_web_immune() const</a>
<a name="ln6492">{</a>
<a name="ln6493">    return mons_genus(type) == MONS_SPIDER</a>
<a name="ln6494">            || type == MONS_ARACHNE</a>
<a name="ln6495">            || mons_genus(type) == MONS_MOTH</a>
<a name="ln6496">            || mons_genus(type) == MONS_DEMONIC_CRAWLER</a>
<a name="ln6497">            || is_insubstantial()</a>
<a name="ln6498">            || mons_genus(type) == MONS_JELLY;</a>
<a name="ln6499">}</a>
<a name="ln6500"> </a>
<a name="ln6501">// Followers of Yredelemnul and Dithmenos don't have their accuracy</a>
<a name="ln6502">// reduced by umbra.</a>
<a name="ln6503">bool monster::nightvision() const</a>
<a name="ln6504">{</a>
<a name="ln6505">    return god == GOD_YREDELEMNUL</a>
<a name="ln6506">           || god == GOD_DITHMENOS;</a>
<a name="ln6507">}</a>
<a name="ln6508"> </a>
<a name="ln6509">bool monster::attempt_escape(int attempts)</a>
<a name="ln6510">{</a>
<a name="ln6511">    int attfactor;</a>
<a name="ln6512">    int randfact;</a>
<a name="ln6513"> </a>
<a name="ln6514">    if (!is_constricted())</a>
<a name="ln6515">        return true;</a>
<a name="ln6516"> </a>
<a name="ln6517">    escape_attempts += attempts;</a>
<a name="ln6518">    attfactor = 3 * escape_attempts;</a>
<a name="ln6519"> </a>
<a name="ln6520">    if (constricted_by == MID_PLAYER)</a>
<a name="ln6521">    {</a>
<a name="ln6522">        if (has_ench(ENCH_VILE_CLUTCH))</a>
<a name="ln6523">        {</a>
<a name="ln6524">            randfact = roll_dice(1, 10 + div_rand_round(</a>
<a name="ln6525">                    calc_spell_power(SPELL_BORGNJORS_VILE_CLUTCH, true), 5));</a>
<a name="ln6526">        }</a>
<a name="ln6527">        else</a>
<a name="ln6528">            randfact = roll_dice(1, 3 + you.experience_level);</a>
<a name="ln6529">    }</a>
<a name="ln6530">    else</a>
<a name="ln6531">    {</a>
<a name="ln6532">        const monster* themonst = monster_by_mid(constricted_by);</a>
<a name="ln6533">        ASSERT(themonst);</a>
<a name="ln6534"> </a>
<a name="ln6535">        // Monsters use the same escape formula for all forms of constriction.</a>
<a name="ln6536">        randfact = 5 + roll_dice(1, 5)</a>
<a name="ln6537">            + roll_dice(1, themonst-&gt;get_hit_dice());</a>
<a name="ln6538">    }</a>
<a name="ln6539"> </a>
<a name="ln6540">    if (attfactor &gt; randfact)</a>
<a name="ln6541">    {</a>
<a name="ln6542">        stop_being_constricted(true);</a>
<a name="ln6543">        return true;</a>
<a name="ln6544">    }</a>
<a name="ln6545">    else</a>
<a name="ln6546">        return false;</a>
<a name="ln6547">}</a>
<a name="ln6548"> </a>
<a name="ln6549">/**</a>
<a name="ln6550"> * Does the monster have a free tentacle to constrict something?</a>
<a name="ln6551"> * Currently only used by octopode monsters.</a>
<a name="ln6552"> * @return  True if it can constrict an additional monster, false otherwise.</a>
<a name="ln6553"> */</a>
<a name="ln6554">bool monster::has_usable_tentacle() const</a>
<a name="ln6555">{</a>
<a name="ln6556">    if (mons_genus(type) != MONS_OCTOPODE)</a>
<a name="ln6557">        return false;</a>
<a name="ln6558"> </a>
<a name="ln6559">    // ignoring monster octopodes with weapons, for now</a>
<a name="ln6560">    return num_constricting() &lt; 8;</a>
<a name="ln6561">}</a>
<a name="ln6562"> </a>
<a name="ln6563">// Move the monster to the nearest valid space.</a>
<a name="ln6564">bool monster::shove(const char* feat_name)</a>
<a name="ln6565">{</a>
<a name="ln6566">    for (distance_iterator di(pos()); di; ++di)</a>
<a name="ln6567">        if (monster_space_valid(this, *di, false))</a>
<a name="ln6568">        {</a>
<a name="ln6569">            move_to_pos(*di);</a>
<a name="ln6570">            simple_monster_message(*this,</a>
<a name="ln6571">                make_stringf(&quot; is pushed out of the %s.&quot;, feat_name).c_str());</a>
<a name="ln6572">            dprf(&quot;Moved to (%d, %d).&quot;, pos().x, pos().y);</a>
<a name="ln6573"> </a>
<a name="ln6574">            return true;</a>
<a name="ln6575">        }</a>
<a name="ln6576"> </a>
<a name="ln6577">    return false;</a>
<a name="ln6578">}</a>
<a name="ln6579"> </a>
<a name="ln6580">void monster::id_if_worn(mon_inv_type mslot, object_class_type base_type,</a>
<a name="ln6581">                          int sub_type) const</a>
<a name="ln6582">{</a>
<a name="ln6583">    item_def *item = mslot_item(mslot);</a>
<a name="ln6584"> </a>
<a name="ln6585">    if (item &amp;&amp; item-&gt;is_type(base_type, sub_type))</a>
<a name="ln6586">        set_ident_type(*item, true);</a>
<a name="ln6587">}</a>
<a name="ln6588"> </a>
<a name="ln6589">bool monster::check_clarity() const</a>
<a name="ln6590">{</a>
<a name="ln6591">    return clarity();</a>
<a name="ln6592">}</a>
<a name="ln6593"> </a>
<a name="ln6594">bool monster::stasis() const</a>
<a name="ln6595">{</a>
<a name="ln6596">    return mons_genus(type) == MONS_FORMICID</a>
<a name="ln6597">           || type == MONS_PLAYER_GHOST &amp;&amp; ghost-&gt;species == SP_FORMICID;</a>
<a name="ln6598">}</a>
<a name="ln6599"> </a>
<a name="ln6600">bool monster::cloud_immune(bool calc_unid, bool items) const</a>
<a name="ln6601">{</a>
<a name="ln6602">    // Cloud Mage is also checked for in (so stay in sync with)</a>
<a name="ln6603">    // monster_info::monster_info(monster_type, monster_type).</a>
<a name="ln6604">    return type == MONS_CLOUD_MAGE || actor::cloud_immune(calc_unid, items);</a>
<a name="ln6605">}</a>
<a name="ln6606"> </a>
<a name="ln6607">bool monster::is_illusion() const</a>
<a name="ln6608">{</a>
<a name="ln6609">    return type == MONS_PLAYER_ILLUSION</a>
<a name="ln6610">           || has_ench(ENCH_PHANTOM_MIRROR)</a>
<a name="ln6611">           || props.exists(CLONE_SLAVE_KEY);</a>
<a name="ln6612">}</a>
<a name="ln6613"> </a>
<a name="ln6614">bool monster::is_divine_companion() const</a>
<a name="ln6615">{</a>
<a name="ln6616">    return attitude == ATT_FRIENDLY</a>
<a name="ln6617">           &amp;&amp; !is_summoned()</a>
<a name="ln6618">           &amp;&amp; (mons_is_god_gift(*this, GOD_BEOGH)</a>
<a name="ln6619">               || mons_is_god_gift(*this, GOD_YREDELEMNUL)</a>
<a name="ln6620">               || mons_is_god_gift(*this, GOD_HEPLIAKLQANA))</a>
<a name="ln6621">           &amp;&amp; mons_can_use_stairs(*this);</a>
<a name="ln6622">}</a>
<a name="ln6623"> </a>
<a name="ln6624">bool monster::is_jumpy() const</a>
<a name="ln6625">{</a>
<a name="ln6626">    return type == MONS_JUMPING_SPIDER;</a>
<a name="ln6627">}</a>
<a name="ln6628"> </a>
<a name="ln6629">// HD for spellcasting purposes.</a>
<a name="ln6630">// Currently only used for Aura of Brilliance and Hep ancestors.</a>
<a name="ln6631">int monster::spell_hd(spell_type spell) const</a>
<a name="ln6632">{</a>
<a name="ln6633">    UNUSED(spell);</a>
<a name="ln6634">    int hd = get_hit_dice();</a>
<a name="ln6635">    if (mons_is_hepliaklqana_ancestor(type))</a>
<a name="ln6636">        hd = max(1, hd * 2 / 3);</a>
<a name="ln6637">    if (has_ench(ENCH_IDEALISED))</a>
<a name="ln6638">        hd *= 2;</a>
<a name="ln6639">    if (has_ench(ENCH_EMPOWERED_SPELLS))</a>
<a name="ln6640">        hd += 5;</a>
<a name="ln6641">    return hd;</a>
<a name="ln6642">}</a>
<a name="ln6643"> </a>
<a name="ln6644">/**</a>
<a name="ln6645"> * For monsters with random spellbooks, track which spells</a>
<a name="ln6646"> * the player has seen this monster cast.</a>
<a name="ln6647"> *</a>
<a name="ln6648"> * @param spell     The spell the player just saw the monster cast.</a>
<a name="ln6649"> */</a>
<a name="ln6650">void monster::note_spell_cast(spell_type spell)</a>
<a name="ln6651">{</a>
<a name="ln6652">    const monster_info mi(this);</a>
<a name="ln6653">    if (get_spellbooks(mi).size() &lt;= 1)</a>
<a name="ln6654">        return;</a>
<a name="ln6655"> </a>
<a name="ln6656">    for (int old_spell : props[SEEN_SPELLS_KEY].get_vector())</a>
<a name="ln6657">        if (old_spell == spell)</a>
<a name="ln6658">            return;</a>
<a name="ln6659"> </a>
<a name="ln6660">    dprf(&quot;tracking seen spell %s for %s&quot;,</a>
<a name="ln6661">         spell_title(spell), name(DESC_A, true).c_str());</a>
<a name="ln6662">    props[SEEN_SPELLS_KEY].get_vector().push_back(spell);</a>
<a name="ln6663">}</a>
<a name="ln6664"> </a>
<a name="ln6665">/**</a>
<a name="ln6666"> * Remove this monsters summon's. Any monsters summoned by this monster will be</a>
<a name="ln6667"> * abjured and any spectral weapon or battlesphere avatars they have will be</a>
<a name="ln6668"> * ended.</a>
<a name="ln6669"> *</a>
<a name="ln6670"> * @param check_attitude If true, only remove summons/avatars whose attitude</a>
<a name="ln6671"> *                       differs from the the monster.</a>
<a name="ln6672"> */</a>
<a name="ln6673">void monster::remove_summons(bool check_attitude)</a>
<a name="ln6674">{</a>
<a name="ln6675">    monster* avatar = find_spectral_weapon(this);</a>
<a name="ln6676">    if (avatar &amp;&amp; (!check_attitude || attitude != avatar-&gt;attitude))</a>
<a name="ln6677">        end_spectral_weapon(avatar, false, false);</a>
<a name="ln6678"> </a>
<a name="ln6679">    avatar = find_battlesphere(this);</a>
<a name="ln6680">    if (avatar &amp;&amp; (!check_attitude || attitude != avatar-&gt;attitude))</a>
<a name="ln6681">        end_battlesphere(avatar, false);</a>
<a name="ln6682"> </a>
<a name="ln6683">    for (monster_iterator mi; mi; ++mi)</a>
<a name="ln6684">    {</a>
<a name="ln6685">        int sumtype = 0;</a>
<a name="ln6686"> </a>
<a name="ln6687">        if ((!check_attitude || attitude != mi-&gt;attitude)</a>
<a name="ln6688">            &amp;&amp; mi-&gt;summoner == mid</a>
<a name="ln6689">            &amp;&amp; (mi-&gt;is_summoned(nullptr, &amp;sumtype)</a>
<a name="ln6690">                || sumtype == MON_SUMM_CLONE))</a>
<a name="ln6691">        {</a>
<a name="ln6692">            mi-&gt;del_ench(ENCH_ABJ);</a>
<a name="ln6693">        }</a>
<a name="ln6694">    }</a>
<a name="ln6695">}</a>
<a name="ln6696"> </a>
<a name="ln6697">/**</a>
<a name="ln6698"> * Does this monster have the given mutant beast facet?</a>
<a name="ln6699"> *</a>
<a name="ln6700"> * @param facet     The beast_facet in question; e.g. BF_BAT.</a>
<a name="ln6701"> * @return          Whether the given facet is one this monster has.</a>
<a name="ln6702"> */</a>
<a name="ln6703">bool monster::has_facet(int facet) const</a>
<a name="ln6704">{</a>
<a name="ln6705">    if (!props.exists(MUTANT_BEAST_FACETS))</a>
<a name="ln6706">        return false;</a>
<a name="ln6707"> </a>
<a name="ln6708">    for (auto facet_val : props[MUTANT_BEAST_FACETS].get_vector())</a>
<a name="ln6709">        if (facet_val.get_int() == facet)</a>
<a name="ln6710">            return true;</a>
<a name="ln6711">    return false;</a>
<a name="ln6712">}</a>
<a name="ln6713"> </a>
<a name="ln6714">/// If the player attacks this monster, will it become hostile?</a>
<a name="ln6715">bool monster::angered_by_attacks() const</a>
<a name="ln6716">{</a>
<a name="ln6717">    return !has_ench(ENCH_INSANE)</a>
<a name="ln6718">            &amp;&amp; !mons_is_avatar(type)</a>
<a name="ln6719">            &amp;&amp; type != MONS_SPELLFORGED_SERVITOR</a>
<a name="ln6720">            &amp;&amp; !mons_is_conjured(type)</a>
<a name="ln6721">            &amp;&amp; !testbits(flags, MF_DEMONIC_GUARDIAN)</a>
<a name="ln6722">            &amp;&amp; !mons_is_hepliaklqana_ancestor(type);</a>
<a name="ln6723">}</a>

</code></pre>
<div class="balloon" rel="271"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v648/" target="_blank">V648</a> Priority of the '&&' operation is higher than that of the '||' operation.</p></div>
<div class="balloon" rel="692"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v648/" target="_blank">V648</a> Priority of the '&&' operation is higher than that of the '||' operation.</p></div>
<div class="balloon" rel="760"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v648/" target="_blank">V648</a> Priority of the '&&' operation is higher than that of the '||' operation.</p></div>
<div class="balloon" rel="1207"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v648/" target="_blank">V648</a> Priority of the '&&' operation is higher than that of the '||' operation.</p></div>
<div class="balloon" rel="1430"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v648/" target="_blank">V648</a> Priority of the '&&' operation is higher than that of the '||' operation.</p></div>
<div class="balloon" rel="1601"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v648/" target="_blank">V648</a> Priority of the '&&' operation is higher than that of the '||' operation.</p></div>
<div class="balloon" rel="1923"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v560/" target="_blank">V560</a> A part of conditional expression is always true: !force.</p></div>
<div class="balloon" rel="1958"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v648/" target="_blank">V648</a> Priority of the '&&' operation is higher than that of the '||' operation.</p></div>
<div class="balloon" rel="2398"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v648/" target="_blank">V648</a> Priority of the '&&' operation is higher than that of the '||' operation.</p></div>
<div class="balloon" rel="2995"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v648/" target="_blank">V648</a> Priority of the '&&' operation is higher than that of the '||' operation.</p></div>
<div class="balloon" rel="3949"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v648/" target="_blank">V648</a> Priority of the '&&' operation is higher than that of the '||' operation.</p></div>
<div class="balloon" rel="4328"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v1051/" target="_blank">V1051</a> Consider checking for misprints. It's possible that the 'hit_points' should be checked here.</p></div>
<div class="balloon" rel="4843"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v644/" target="_blank">V644</a> A suspicious function declaration. It is possible that the 'dist' type object was meant to be created.</p></div>
<div class="balloon" rel="4923"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v648/" target="_blank">V648</a> Priority of the '&&' operation is higher than that of the '||' operation.</p></div>
<div class="balloon" rel="5031"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v1019/" target="_blank">V1019</a> Compound assignment expression 'amount /= 2' is used inside condition.</p></div>
<div class="balloon" rel="6261"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v648/" target="_blank">V648</a> Priority of the '&&' operation is higher than that of the '||' operation.</p></div>
<div class="balloon" rel="6597"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v648/" target="_blank">V648</a> Priority of the '&&' operation is higher than that of the '||' operation.</p></div>
<div class="balloon" rel="72"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v730/" target="_blank">V730</a> Not all members of a class are initialized inside the constructor. Consider inspecting: ench_countdown, summoner, damage_friendly, damage_total.</p></div>

<link rel="stylesheet" href="highlight.css">
<script src="highlight.pack.js"></script>
<script src="highlightjs-line-numbers.js"></script>
<script>hljs.initHighlightingOnLoad();</script>
<script>hljs.initLineNumbersOnLoad();</script>
<script>
  $(document).ready(function() {
      $('.balloon').each(function () {
          var bl = $(this);
          var line = bl.attr('rel');
          var text = $('a[name="ln'+line+'"]').text();

          var space_count = 0;
          for(var i = 0; i<text.length; i++){
              var char = text[i];
              if((char !== ' ')&&(char !== '\t'))break;
              if(char === '\t')space_count++;
              space_count++;
          }

          bl.css('margin-left', space_count*8);
          $('a[name="ln'+line+'"]').after(bl);
      });

      window.location = window.location;
  });
</script>
</body>
</html>
