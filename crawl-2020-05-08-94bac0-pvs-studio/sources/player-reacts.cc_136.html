
<html>
<head>

  <meta http-equiv="Content-Type" content="text/html; charset=US-ASCII" />
  <title>player-reacts.cc</title>

  <link rel="stylesheet" href="../style.css"/>
  <script src="../jquery-3.2.1.min.js"></script>
</head>
<body>

<pre><code class = "cpp">
<a name="ln1">/**</a>
<a name="ln2"> * @file player_reacts.cc</a>
<a name="ln3"> * @brief Player functions called every turn, mostly handling enchantment durations/expirations.</a>
<a name="ln4"> **/</a>
<a name="ln5"> </a>
<a name="ln6">#include &quot;AppHdr.h&quot;</a>
<a name="ln7"> </a>
<a name="ln8">#include &quot;player-reacts.h&quot;</a>
<a name="ln9"> </a>
<a name="ln10">#include &lt;algorithm&gt;</a>
<a name="ln11">#include &lt;cerrno&gt;</a>
<a name="ln12">#include &lt;cstdio&gt;</a>
<a name="ln13">#include &lt;cstdlib&gt;</a>
<a name="ln14">#include &lt;cstring&gt;</a>
<a name="ln15">#include &lt;iostream&gt;</a>
<a name="ln16">#include &lt;list&gt;</a>
<a name="ln17">#include &lt;sstream&gt;</a>
<a name="ln18">#include &lt;string&gt;</a>
<a name="ln19"> </a>
<a name="ln20">#ifndef TARGET_OS_WINDOWS</a>
<a name="ln21"># ifndef __ANDROID__</a>
<a name="ln22">#  include &lt;langinfo.h&gt;</a>
<a name="ln23"># endif</a>
<a name="ln24">#endif</a>
<a name="ln25">#include &lt;fcntl.h&gt;</a>
<a name="ln26">#ifdef USE_UNIX_SIGNALS</a>
<a name="ln27">#include &lt;csignal&gt;</a>
<a name="ln28">#endif</a>
<a name="ln29"> </a>
<a name="ln30">#include &quot;abyss.h&quot; // abyss_maybe_spawn_xp_exit</a>
<a name="ln31">#include &quot;act-iter.h&quot;</a>
<a name="ln32">#include &quot;areas.h&quot;</a>
<a name="ln33">#include &quot;artefact.h&quot;</a>
<a name="ln34">#include &quot;beam.h&quot;</a>
<a name="ln35">#include &quot;cloud.h&quot;</a>
<a name="ln36">#include &quot;clua.h&quot;</a>
<a name="ln37">#include &quot;colour.h&quot;</a>
<a name="ln38">#include &quot;coord.h&quot;</a>
<a name="ln39">#include &quot;coordit.h&quot;</a>
<a name="ln40">#include &quot;database.h&quot;</a>
<a name="ln41">#include &quot;dbg-util.h&quot;</a>
<a name="ln42">#include &quot;delay.h&quot;</a>
<a name="ln43">#ifdef DGL_SIMPLE_MESSAGING</a>
<a name="ln44">#include &quot;dgl-message.h&quot;</a>
<a name="ln45">#endif</a>
<a name="ln46">#include &quot;dlua.h&quot;</a>
<a name="ln47">#include &quot;dungeon.h&quot;</a>
<a name="ln48">#include &quot;env.h&quot;</a>
<a name="ln49">#include &quot;exercise.h&quot;</a>
<a name="ln50">#include &quot;files.h&quot;</a>
<a name="ln51">#include &quot;food.h&quot;</a>
<a name="ln52">#include &quot;god-abil.h&quot;</a>
<a name="ln53">#include &quot;god-companions.h&quot;</a>
<a name="ln54">#include &quot;god-passive.h&quot;</a>
<a name="ln55">#include &quot;invent.h&quot;</a>
<a name="ln56">#include &quot;item-prop.h&quot;</a>
<a name="ln57">#include &quot;item-use.h&quot;</a>
<a name="ln58">#include &quot;level-state-type.h&quot;</a>
<a name="ln59">#include &quot;libutil.h&quot;</a>
<a name="ln60">#include &quot;maps.h&quot;</a>
<a name="ln61">#include &quot;message.h&quot;</a>
<a name="ln62">#include &quot;mon-abil.h&quot;</a>
<a name="ln63">#include &quot;mon-cast.h&quot;</a>
<a name="ln64">#include &quot;mon-death.h&quot;</a>
<a name="ln65">#include &quot;mon-place.h&quot;</a>
<a name="ln66">#include &quot;mon-tentacle.h&quot;</a>
<a name="ln67">#include &quot;mon-util.h&quot;</a>
<a name="ln68">#include &quot;mutation.h&quot;</a>
<a name="ln69">#include &quot;ouch.h&quot;</a>
<a name="ln70">#include &quot;player.h&quot;</a>
<a name="ln71">#include &quot;player-stats.h&quot;</a>
<a name="ln72">#include &quot;random.h&quot;</a>
<a name="ln73">#include &quot;religion.h&quot;</a>
<a name="ln74">#include &quot;shopping.h&quot;</a>
<a name="ln75">#include &quot;shout.h&quot;</a>
<a name="ln76">#include &quot;skills.h&quot;</a>
<a name="ln77">#include &quot;spl-cast.h&quot;</a>
<a name="ln78">#include &quot;spl-clouds.h&quot;</a>
<a name="ln79">#include &quot;spl-damage.h&quot;</a>
<a name="ln80">#include &quot;spl-goditem.h&quot;</a>
<a name="ln81">#include &quot;spl-other.h&quot;</a>
<a name="ln82">#include &quot;spl-summoning.h&quot;</a>
<a name="ln83">#include &quot;spl-transloc.h&quot;</a>
<a name="ln84">#include &quot;spl-util.h&quot;</a>
<a name="ln85">#include &quot;state.h&quot;</a>
<a name="ln86">#include &quot;status.h&quot;</a>
<a name="ln87">#include &quot;stepdown.h&quot;</a>
<a name="ln88">#include &quot;stringutil.h&quot;</a>
<a name="ln89">#include &quot;terrain.h&quot;</a>
<a name="ln90">#ifdef USE_TILE</a>
<a name="ln91">#include &quot;rltiles/tiledef-dngn.h&quot;</a>
<a name="ln92">#include &quot;tilepick.h&quot;</a>
<a name="ln93">#endif</a>
<a name="ln94">#include &quot;transform.h&quot;</a>
<a name="ln95">#include &quot;traps.h&quot;</a>
<a name="ln96">#include &quot;travel.h&quot;</a>
<a name="ln97">#include &quot;view.h&quot;</a>
<a name="ln98">#include &quot;xom.h&quot;</a>
<a name="ln99"> </a>
<a name="ln100">/**</a>
<a name="ln101"> * Decrement a duration by the given delay.</a>
<a name="ln102"> </a>
<a name="ln103"> * The midloss value should be either 0 or a number of turns where the delay</a>
<a name="ln104"> * from those turns at normal speed is less than the duration's midpoint. The</a>
<a name="ln105"> * use of midloss prevents the player from knowing the exact remaining duration</a>
<a name="ln106"> * when the midpoint message is displayed.</a>
<a name="ln107"> *</a>
<a name="ln108"> * @param dur The duration type to be decremented.</a>
<a name="ln109"> * @param delay The delay aut amount by which to decrement the duration.</a>
<a name="ln110"> * @param endmsg The message to be displayed when the duration ends.</a>
<a name="ln111"> * @param midloss A number of normal-speed turns by which to further decrement</a>
<a name="ln112"> *                the duration if we cross the duration's midpoint.</a>
<a name="ln113"> * @param endmsg The message to be displayed when the duration is decremented</a>
<a name="ln114"> *               to a value under its midpoint.</a>
<a name="ln115"> * @param chan The channel where the endmsg will be printed if the duration</a>
<a name="ln116"> *             ends.</a>
<a name="ln117"> *</a>
<a name="ln118"> * @return  True if the duration ended, false otherwise.</a>
<a name="ln119"> */</a>
<a name="ln120"> </a>
<a name="ln121">static bool _decrement_a_duration(duration_type dur, int delay,</a>
<a name="ln122">                                 const char* endmsg = nullptr,</a>
<a name="ln123">                                 int midloss = 0,</a>
<a name="ln124">                                 const char* midmsg = nullptr,</a>
<a name="ln125">                                 msg_channel_type chan = MSGCH_DURATION)</a>
<a name="ln126">{</a>
<a name="ln127">    ASSERT(you.duration[dur] &gt;= 0);</a>
<a name="ln128">    if (you.duration[dur] == 0)</a>
<a name="ln129">        return false;</a>
<a name="ln130"> </a>
<a name="ln131">    ASSERT(!midloss || midmsg != nullptr);</a>
<a name="ln132">    const int midpoint = duration_expire_point(dur);</a>
<a name="ln133">    ASSERTM(!midloss || midloss * BASELINE_DELAY &lt; midpoint,</a>
<a name="ln134">            &quot;midpoint delay loss %d not less than duration midpoint %d&quot;,</a>
<a name="ln135">            midloss * BASELINE_DELAY, midpoint);</a>
<a name="ln136"> </a>
<a name="ln137">    const int old_dur = you.duration[dur];</a>
<a name="ln138">    you.duration[dur] -= delay;</a>
<a name="ln139"> </a>
<a name="ln140">    // If we cross the midpoint, handle midloss and print the midpoint message.</a>
<a name="ln141">    if (you.duration[dur] &lt;= midpoint &amp;&amp; old_dur &gt; midpoint)</a>
<a name="ln142">    {</a>
<a name="ln143">        you.duration[dur] -= midloss * BASELINE_DELAY;</a>
<a name="ln144">        if (midmsg)</a>
<a name="ln145">        {</a>
<a name="ln146">            // Make sure the player has a turn to react to the midpoint</a>
<a name="ln147">            // message.</a>
<a name="ln148">            if (you.duration[dur] &lt;= 0)</a>
<a name="ln149">                you.duration[dur] = 1;</a>
<a name="ln150">            if (need_expiration_warning(dur))</a>
<a name="ln151">                mprf(MSGCH_DANGER, &quot;Careful! %s&quot;, midmsg);</a>
<a name="ln152">            else</a>
<a name="ln153">                mprf(chan, &quot;%s&quot;, midmsg);</a>
<a name="ln154">        }</a>
<a name="ln155">    }</a>
<a name="ln156"> </a>
<a name="ln157">    if (you.duration[dur] &lt;= 0)</a>
<a name="ln158">    {</a>
<a name="ln159">        you.duration[dur] = 0;</a>
<a name="ln160">        if (endmsg &amp;&amp; *endmsg != '\0')</a>
<a name="ln161">            mprf(chan, &quot;%s&quot;, endmsg);</a>
<a name="ln162">        return true;</a>
<a name="ln163">    }</a>
<a name="ln164"> </a>
<a name="ln165">    return false;</a>
<a name="ln166">}</a>
<a name="ln167"> </a>
<a name="ln168"> </a>
<a name="ln169">static void _decrement_petrification(int delay)</a>
<a name="ln170">{</a>
<a name="ln171">    if (_decrement_a_duration(DUR_PETRIFIED, delay) &amp;&amp; !you.paralysed())</a>
<a name="ln172">    {</a>
<a name="ln173">        you.redraw_evasion = true;</a>
<a name="ln174">        // implicit assumption: all races that can be petrified are made of</a>
<a name="ln175">        // flesh when not petrified</a>
<a name="ln176">        const string flesh_equiv = get_form()-&gt;flesh_equivalent.empty() ?</a>
<a name="ln177">                                            &quot;flesh&quot; :</a>
<a name="ln178">                                            get_form()-&gt;flesh_equivalent;</a>
<a name="ln179"> </a>
<a name="ln180">        mprf(MSGCH_DURATION, &quot;You turn to %s and can move again.&quot;,</a>
<a name="ln181">             flesh_equiv.c_str());</a>
<a name="ln182"> </a>
<a name="ln183">        if (you.props.exists(PETRIFIED_BY_KEY))</a>
<a name="ln184">            you.props.erase(PETRIFIED_BY_KEY);</a>
<a name="ln185">    }</a>
<a name="ln186"> </a>
<a name="ln187">    if (you.duration[DUR_PETRIFYING])</a>
<a name="ln188">    {</a>
<a name="ln189">        int &amp;dur = you.duration[DUR_PETRIFYING];</a>
<a name="ln190">        int old_dur = dur;</a>
<a name="ln191">        if ((dur -= delay) &lt;= 0)</a>
<a name="ln192">        {</a>
<a name="ln193">            dur = 0;</a>
<a name="ln194">            // If we'd kill the player when active flight stops, this will</a>
<a name="ln195">            // need to pass the killer. Unlike monsters, almost all flight is</a>
<a name="ln196">            // magical, inluding tengu, as there's no flapping of wings. Should</a>
<a name="ln197">            // we be nasty to dragon and bat forms?  For now, let's not instakill</a>
<a name="ln198">            // them even if it's inconsistent.</a>
<a name="ln199">            you.fully_petrify(nullptr);</a>
<a name="ln200">        }</a>
<a name="ln201">        else if (dur &lt; 15 &amp;&amp; old_dur &gt;= 15)</a>
<a name="ln202">            mpr(&quot;Your limbs are stiffening.&quot;);</a>
<a name="ln203">    }</a>
<a name="ln204">}</a>
<a name="ln205"> </a>
<a name="ln206">static void _decrement_paralysis(int delay)</a>
<a name="ln207">{</a>
<a name="ln208">    _decrement_a_duration(DUR_PARALYSIS_IMMUNITY, delay);</a>
<a name="ln209"> </a>
<a name="ln210">    if (you.duration[DUR_PARALYSIS])</a>
<a name="ln211">    {</a>
<a name="ln212">        _decrement_a_duration(DUR_PARALYSIS, delay);</a>
<a name="ln213"> </a>
<a name="ln214">        if (!you.duration[DUR_PARALYSIS] &amp;&amp; !you.petrified())</a>
<a name="ln215">        {</a>
<a name="ln216">            mprf(MSGCH_DURATION, &quot;You can move again.&quot;);</a>
<a name="ln217">            you.redraw_evasion = true;</a>
<a name="ln218">            you.duration[DUR_PARALYSIS_IMMUNITY] = roll_dice(1, 3)</a>
<a name="ln219">            * BASELINE_DELAY;</a>
<a name="ln220">            if (you.props.exists(PARALYSED_BY_KEY))</a>
<a name="ln221">                you.props.erase(PARALYSED_BY_KEY);</a>
<a name="ln222">        }</a>
<a name="ln223">    }</a>
<a name="ln224">}</a>
<a name="ln225"> </a>
<a name="ln226">/**</a>
<a name="ln227"> * Check whether the player's ice (Ozocubu's) armour was melted this turn.</a>
<a name="ln228"> * If so, print the appropriate message and clear the flag.</a>
<a name="ln229"> */</a>
<a name="ln230">static void _maybe_melt_armour()</a>
<a name="ln231">{</a>
<a name="ln232">    // We have to do the messaging here, because a simple wand of flame will</a>
<a name="ln233">    // call _maybe_melt_player_enchantments twice. It also avoids duplicate</a>
<a name="ln234">    // messages when melting because of several heat sources.</a>
<a name="ln235">    if (you.props.exists(MELT_ARMOUR_KEY))</a>
<a name="ln236">    {</a>
<a name="ln237">        you.props.erase(MELT_ARMOUR_KEY);</a>
<a name="ln238">        mprf(MSGCH_DURATION, &quot;The heat melts your icy armour.&quot;);</a>
<a name="ln239">    }</a>
<a name="ln240">}</a>
<a name="ln241"> </a>
<a name="ln242">/**</a>
<a name="ln243"> * How much horror does the player character feel in the current situation?</a>
<a name="ln244"> *</a>
<a name="ln245"> * (For Ru's MUT_COWARDICE.)</a>
<a name="ln246"> *</a>
<a name="ln247"> * Penalties are based on the &quot;scariness&quot; (threat level) of monsters currently</a>
<a name="ln248"> * visible.</a>
<a name="ln249"> */</a>
<a name="ln250">static int _current_horror_level()</a>
<a name="ln251">{</a>
<a name="ln252">    int horror_level = 0;</a>
<a name="ln253"> </a>
<a name="ln254">    for (monster_near_iterator mi(&amp;you, LOS_NO_TRANS); mi; ++mi)</a>
<a name="ln255">    {</a>
<a name="ln256"> </a>
<a name="ln257">        if (mons_aligned(*mi, &amp;you)</a>
<a name="ln258">            || !mons_is_threatening(**mi)</a>
<a name="ln259">            || mons_is_tentacle_or_tentacle_segment(mi-&gt;type))</a>
<a name="ln260">        {</a>
<a name="ln261">            continue;</a>
<a name="ln262">        }</a>
<a name="ln263"> </a>
<a name="ln264">        const mon_threat_level_type threat_level = mons_threat_level(**mi);</a>
<a name="ln265">        if (threat_level == MTHRT_NASTY)</a>
<a name="ln266">            horror_level += 3;</a>
<a name="ln267">        else if (threat_level == MTHRT_TOUGH)</a>
<a name="ln268">            horror_level += 1;</a>
<a name="ln269">    }</a>
<a name="ln270">    // Subtract one from the horror level so that you don't get a message</a>
<a name="ln271">    // when a single tough monster appears.</a>
<a name="ln272">    horror_level = max(0, horror_level - 1);</a>
<a name="ln273">    return horror_level;</a>
<a name="ln274">}</a>
<a name="ln275"> </a>
<a name="ln276">/**</a>
<a name="ln277"> * What was the player's most recent horror level?</a>
<a name="ln278"> *</a>
<a name="ln279"> * (For Ru's MUT_COWARDICE.)</a>
<a name="ln280"> */</a>
<a name="ln281">static int _old_horror_level()</a>
<a name="ln282">{</a>
<a name="ln283">    if (you.duration[DUR_HORROR])</a>
<a name="ln284">        return you.props[HORROR_PENALTY_KEY].get_int();</a>
<a name="ln285">    return 0;</a>
<a name="ln286">}</a>
<a name="ln287"> </a>
<a name="ln288">/**</a>
<a name="ln289"> * When the player should no longer be horrified, end the DUR_HORROR if it</a>
<a name="ln290"> * exists &amp; cleanup the corresponding prop.</a>
<a name="ln291"> */</a>
<a name="ln292">static void _end_horror()</a>
<a name="ln293">{</a>
<a name="ln294">    if (!you.duration[DUR_HORROR])</a>
<a name="ln295">        return;</a>
<a name="ln296"> </a>
<a name="ln297">    you.props.erase(HORROR_PENALTY_KEY);</a>
<a name="ln298">    you.set_duration(DUR_HORROR, 0);</a>
<a name="ln299">}</a>
<a name="ln300"> </a>
<a name="ln301">/**</a>
<a name="ln302"> * Update penalties for cowardice based on the current situation, if the player</a>
<a name="ln303"> * has Ru's MUT_COWARDICE.</a>
<a name="ln304"> */</a>
<a name="ln305">static void _update_cowardice()</a>
<a name="ln306">{</a>
<a name="ln307">    if (!you.has_mutation(MUT_COWARDICE))</a>
<a name="ln308">    {</a>
<a name="ln309">        // If the player somehow becomes sane again, handle that</a>
<a name="ln310">        _end_horror();</a>
<a name="ln311">        return;</a>
<a name="ln312">    }</a>
<a name="ln313"> </a>
<a name="ln314">    const int horror_level = _current_horror_level();</a>
<a name="ln315"> </a>
<a name="ln316">    if (horror_level &lt;= 0)</a>
<a name="ln317">    {</a>
<a name="ln318">        // If you were horrified before &amp; aren't now, clean up.</a>
<a name="ln319">        _end_horror();</a>
<a name="ln320">        return;</a>
<a name="ln321">    }</a>
<a name="ln322"> </a>
<a name="ln323">    // Lookup the old value before modifying it</a>
<a name="ln324">    const int old_horror_level = _old_horror_level();</a>
<a name="ln325"> </a>
<a name="ln326">    // as long as there's still scary enemies, keep the horror going</a>
<a name="ln327">    you.props[HORROR_PENALTY_KEY] = horror_level;</a>
<a name="ln328">    you.set_duration(DUR_HORROR, 1);</a>
<a name="ln329"> </a>
<a name="ln330">    // only show a message on increase</a>
<a name="ln331">    if (horror_level &lt;= old_horror_level)</a>
<a name="ln332">        return;</a>
<a name="ln333"> </a>
<a name="ln334">    if (horror_level &gt;= HORROR_LVL_OVERWHELMING)</a>
<a name="ln335">        mpr(&quot;Monsters! Monsters everywhere! You have to get out of here!&quot;);</a>
<a name="ln336">    else if (horror_level &gt;= HORROR_LVL_EXTREME)</a>
<a name="ln337">        mpr(&quot;You reel with horror at the sight of these foes!&quot;);</a>
<a name="ln338">    else</a>
<a name="ln339">        mpr(&quot;You feel a twist of horror at the sight of this foe.&quot;);</a>
<a name="ln340">}</a>
<a name="ln341"> </a>
<a name="ln342">// Uskawyaw piety decays incredibly fast, but only to a baseline level of *.</a>
<a name="ln343">// Using Uskayaw abilities can still take you under *.</a>
<a name="ln344">static void _handle_uskayaw_piety(int time_taken)</a>
<a name="ln345">{</a>
<a name="ln346">    if (you.props[USKAYAW_NUM_MONSTERS_HURT].get_int() &gt; 0)</a>
<a name="ln347">    {</a>
<a name="ln348">        int num_hurt = you.props[USKAYAW_NUM_MONSTERS_HURT];</a>
<a name="ln349">        int hurt_val = you.props[USKAYAW_MONSTER_HURT_VALUE];</a>
<a name="ln350">        int piety_gain = max(num_hurt, stepdown_value(hurt_val, 5, 10, 20, 40));</a>
<a name="ln351"> </a>
<a name="ln352">        gain_piety(piety_gain);</a>
<a name="ln353">        you.props[USKAYAW_AUT_SINCE_PIETY_GAIN] = 0;</a>
<a name="ln354">    }</a>
<a name="ln355">    else if (you.piety &gt; piety_breakpoint(0))</a>
<a name="ln356">    {</a>
<a name="ln357">        // If we didn't do a dance action and we can lose piety, we're going</a>
<a name="ln358">        // to lose piety proportional to the time since the last time we took</a>
<a name="ln359">        // a dance action and hurt a monster.</a>
<a name="ln360">        int time_since_gain = you.props[USKAYAW_AUT_SINCE_PIETY_GAIN].get_int();</a>
<a name="ln361">        time_since_gain += time_taken;</a>
<a name="ln362"> </a>
<a name="ln363">        // Only start losing piety if it's been a few turns since we gained</a>
<a name="ln364">        // piety, in order to give more tolerance for missing in combat.</a>
<a name="ln365">        if (time_since_gain &gt; 30)</a>
<a name="ln366">        {</a>
<a name="ln367">            int piety_lost = min(you.piety - piety_breakpoint(0),</a>
<a name="ln368">                    div_rand_round(time_since_gain, 10));</a>
<a name="ln369"> </a>
<a name="ln370">            if (piety_lost &gt; 0)</a>
<a name="ln371">                lose_piety(piety_lost);</a>
<a name="ln372"> </a>
<a name="ln373">        }</a>
<a name="ln374">        you.props[USKAYAW_AUT_SINCE_PIETY_GAIN] = time_since_gain;</a>
<a name="ln375">    }</a>
<a name="ln376"> </a>
<a name="ln377">    // Re-initialize Uskayaw piety variables</a>
<a name="ln378">    you.props[USKAYAW_NUM_MONSTERS_HURT] = 0;</a>
<a name="ln379">    you.props[USKAYAW_MONSTER_HURT_VALUE] = 0;</a>
<a name="ln380">}</a>
<a name="ln381"> </a>
<a name="ln382">static void _handle_uskayaw_time(int time_taken)</a>
<a name="ln383">{</a>
<a name="ln384">    _handle_uskayaw_piety(time_taken);</a>
<a name="ln385"> </a>
<a name="ln386">    int audience_timer = you.props[USKAYAW_AUDIENCE_TIMER].get_int();</a>
<a name="ln387">    int bond_timer = you.props[USKAYAW_BOND_TIMER].get_int();</a>
<a name="ln388"> </a>
<a name="ln389">    // For the timered abilities, if we set the timer to -1, that means we</a>
<a name="ln390">    // need to trigger the abilities this turn. Otherwise we'll decrement the</a>
<a name="ln391">    // timer down to a minimum of 0, at which point it becomes eligible to</a>
<a name="ln392">    // trigger again.</a>
<a name="ln393">    if (audience_timer == -1 || (you.piety &gt;= piety_breakpoint(2)</a>
<a name="ln394">            &amp;&amp; x_chance_in_y(time_taken, 100 + audience_timer)))</a>
<a name="ln395">    {</a>
<a name="ln396">        uskayaw_prepares_audience();</a>
<a name="ln397">    }</a>
<a name="ln398">    else</a>
<a name="ln399">        you.props[USKAYAW_AUDIENCE_TIMER] = max(0, audience_timer - time_taken);</a>
<a name="ln400"> </a>
<a name="ln401">    if (bond_timer == -1 || (you.piety &gt;= piety_breakpoint(3)</a>
<a name="ln402">            &amp;&amp; x_chance_in_y(time_taken, 100 + bond_timer)))</a>
<a name="ln403">    {</a>
<a name="ln404">        uskayaw_bonds_audience();</a>
<a name="ln405">    }</a>
<a name="ln406">    else</a>
<a name="ln407">        you.props[USKAYAW_BOND_TIMER] =  max(0, bond_timer - time_taken);</a>
<a name="ln408">}</a>
<a name="ln409"> </a>
<a name="ln410">/**</a>
<a name="ln411"> * Player reactions after monster and cloud activities in the turn are finished.</a>
<a name="ln412"> */</a>
<a name="ln413">void player_reacts_to_monsters()</a>
<a name="ln414">{</a>
<a name="ln415">    // In case Maurice managed to steal a needed item for example.</a>
<a name="ln416">    if (!you_are_delayed())</a>
<a name="ln417">        update_can_currently_train();</a>
<a name="ln418"> </a>
<a name="ln419">    if (you.duration[DUR_FIRE_SHIELD] &gt; 0)</a>
<a name="ln420">        manage_fire_shield();</a>
<a name="ln421"> </a>
<a name="ln422">    check_monster_detect();</a>
<a name="ln423"> </a>
<a name="ln424">    if (have_passive(passive_t::detect_items) || you.has_mutation(MUT_JELLY_GROWTH)</a>
<a name="ln425">        || you.get_mutation_level(MUT_STRONG_NOSE) &gt; 0)</a>
<a name="ln426">    {</a>
<a name="ln427">        detect_items(-1);</a>
<a name="ln428">    }</a>
<a name="ln429"> </a>
<a name="ln430">    _decrement_paralysis(you.time_taken);</a>
<a name="ln431">    _decrement_petrification(you.time_taken);</a>
<a name="ln432">    if (_decrement_a_duration(DUR_SLEEP, you.time_taken))</a>
<a name="ln433">        you.awaken();</a>
<a name="ln434"> </a>
<a name="ln435">    if (_decrement_a_duration(DUR_GRASPING_ROOTS, you.time_taken)</a>
<a name="ln436">        &amp;&amp; you.is_constricted())</a>
<a name="ln437">    {</a>
<a name="ln438">        // We handle the end-of-enchantment message here since the method</a>
<a name="ln439">        // of constriction is no longer detectable.</a>
<a name="ln440">        mprf(&quot;The grasping roots release their grip on you.&quot;);</a>
<a name="ln441">        you.stop_being_constricted(true);</a>
<a name="ln442">    }</a>
<a name="ln443"> </a>
<a name="ln444">    _maybe_melt_armour();</a>
<a name="ln445">    _update_cowardice();</a>
<a name="ln446">    if (you_worship(GOD_USKAYAW))</a>
<a name="ln447">        _handle_uskayaw_time(you.time_taken);</a>
<a name="ln448">}</a>
<a name="ln449"> </a>
<a name="ln450">static bool _check_recite()</a>
<a name="ln451">{</a>
<a name="ln452">    if (silenced(you.pos())</a>
<a name="ln453">        || you.paralysed()</a>
<a name="ln454">        || you.confused()</a>
<a name="ln455">        || you.asleep()</a>
<a name="ln456">        || you.petrified()</a>
<a name="ln457">        || you.berserk())</a>
<a name="ln458">    {</a>
<a name="ln459">        mprf(MSGCH_DURATION, &quot;Your recitation is interrupted.&quot;);</a>
<a name="ln460">        you.duration[DUR_RECITE] = 0;</a>
<a name="ln461">        return false;</a>
<a name="ln462">    }</a>
<a name="ln463">    return true;</a>
<a name="ln464">}</a>
<a name="ln465"> </a>
<a name="ln466"> </a>
<a name="ln467">static void _handle_recitation(int step)</a>
<a name="ln468">{</a>
<a name="ln469">    mprf(&quot;\&quot;%s\&quot;&quot;,</a>
<a name="ln470">         zin_recite_text(you.attribute[ATTR_RECITE_SEED],</a>
<a name="ln471">                         you.attribute[ATTR_RECITE_TYPE], step).c_str());</a>
<a name="ln472"> </a>
<a name="ln473">    if (apply_area_visible(zin_recite_to_single_monster, you.pos()))</a>
<a name="ln474">        viewwindow();</a>
<a name="ln475"> </a>
<a name="ln476">    // Recite trains more than once per use, because it has a</a>
<a name="ln477">    // long timer in between uses and actually takes up multiple</a>
<a name="ln478">    // turns.</a>
<a name="ln479">    practise_using_ability(ABIL_ZIN_RECITE);</a>
<a name="ln480"> </a>
<a name="ln481">    noisy(you.shout_volume(), you.pos());</a>
<a name="ln482"> </a>
<a name="ln483">    if (step == 0)</a>
<a name="ln484">    {</a>
<a name="ln485">        ostringstream speech;</a>
<a name="ln486">        speech &lt;&lt; zin_recite_text(you.attribute[ATTR_RECITE_SEED],</a>
<a name="ln487">                                  you.attribute[ATTR_RECITE_TYPE], -1);</a>
<a name="ln488">        speech &lt;&lt; '.';</a>
<a name="ln489">        if (one_chance_in(27))</a>
<a name="ln490">        {</a>
<a name="ln491">            const string closure = getSpeakString(&quot;recite_closure&quot;);</a>
<a name="ln492">            if (!closure.empty())</a>
<a name="ln493">                speech &lt;&lt; ' ' &lt;&lt; closure;</a>
<a name="ln494">        }</a>
<a name="ln495">        mprf(MSGCH_DURATION, &quot;You finish reciting %s&quot;, speech.str().c_str());</a>
<a name="ln496">    }</a>
<a name="ln497">}</a>
<a name="ln498"> </a>
<a name="ln499">/**</a>
<a name="ln500"> * Try to respawn the player's ancestor, if possible.</a>
<a name="ln501"> */</a>
<a name="ln502">static void _try_to_respawn_ancestor()</a>
<a name="ln503">{</a>
<a name="ln504">     monster *ancestor = create_monster(hepliaklqana_ancestor_gen_data());</a>
<a name="ln505">     if (!ancestor)</a>
<a name="ln506">         return;</a>
<a name="ln507"> </a>
<a name="ln508">    mprf(&quot;%s emerges from the mists of memory!&quot;,</a>
<a name="ln509">         ancestor-&gt;name(DESC_YOUR).c_str());</a>
<a name="ln510">    add_companion(ancestor);</a>
<a name="ln511">    check_place_cloud(CLOUD_MIST, ancestor-&gt;pos(), random_range(1,2),</a>
<a name="ln512">                      ancestor); // ;)</a>
<a name="ln513">}</a>
<a name="ln514"> </a>
<a name="ln515"> </a>
<a name="ln516">/**</a>
<a name="ln517"> * Take a 'simple' duration, decrement it, and print messages as appropriate</a>
<a name="ln518"> * when it hits 50% and 0% remaining.</a>
<a name="ln519"> *</a>
<a name="ln520"> * @param dur       The duration in question.</a>
<a name="ln521"> * @param delay     How much to decrement the duration by.</a>
<a name="ln522"> */</a>
<a name="ln523">static void _decrement_simple_duration(duration_type dur, int delay)</a>
<a name="ln524">{</a>
<a name="ln525">    if (_decrement_a_duration(dur, delay, duration_end_message(dur),</a>
<a name="ln526">                             duration_mid_offset(dur),</a>
<a name="ln527">                             duration_mid_message(dur),</a>
<a name="ln528">                             duration_mid_chan(dur)))</a>
<a name="ln529">    {</a>
<a name="ln530">        duration_end_effect(dur);</a>
<a name="ln531">    }</a>
<a name="ln532">}</a>
<a name="ln533"> </a>
<a name="ln534"> </a>
<a name="ln535"> </a>
<a name="ln536">/**</a>
<a name="ln537"> * Decrement player durations based on how long the player's turn lasted in aut.</a>
<a name="ln538"> */</a>
<a name="ln539">static void _decrement_durations()</a>
<a name="ln540">{</a>
<a name="ln541">    const int delay = you.time_taken;</a>
<a name="ln542"> </a>
<a name="ln543">    if (you.gourmand())</a>
<a name="ln544">    {</a>
<a name="ln545">        // Innate gourmand is always fully active.</a>
<a name="ln546">        if (you.has_mutation(MUT_GOURMAND))</a>
<a name="ln547">            you.duration[DUR_GOURMAND] = GOURMAND_MAX;</a>
<a name="ln548">        else if (you.duration[DUR_GOURMAND] &lt; GOURMAND_MAX &amp;&amp; coinflip())</a>
<a name="ln549">            you.duration[DUR_GOURMAND] += delay;</a>
<a name="ln550">    }</a>
<a name="ln551">    else</a>
<a name="ln552">        you.duration[DUR_GOURMAND] = 0;</a>
<a name="ln553"> </a>
<a name="ln554">    if (you.duration[DUR_LIQUID_FLAMES])</a>
<a name="ln555">        dec_napalm_player(delay);</a>
<a name="ln556"> </a>
<a name="ln557">    const bool melted = you.props.exists(MELT_ARMOUR_KEY);</a>
<a name="ln558">    if (_decrement_a_duration(DUR_ICY_ARMOUR, delay,</a>
<a name="ln559">                              &quot;Your icy armour evaporates.&quot;,</a>
<a name="ln560">                              melted ? 0 : coinflip(),</a>
<a name="ln561">                              melted ? nullptr</a>
<a name="ln562">                              : &quot;Your icy armour starts to melt.&quot;))</a>
<a name="ln563">    {</a>
<a name="ln564">        if (you.props.exists(ICY_ARMOUR_KEY))</a>
<a name="ln565">            you.props.erase(ICY_ARMOUR_KEY);</a>
<a name="ln566">        you.redraw_armour_class = true;</a>
<a name="ln567">    }</a>
<a name="ln568"> </a>
<a name="ln569">    // Possible reduction of silence radius.</a>
<a name="ln570">    if (you.duration[DUR_SILENCE])</a>
<a name="ln571">        invalidate_agrid();</a>
<a name="ln572">    // and liquefying radius.</a>
<a name="ln573">    if (you.duration[DUR_LIQUEFYING])</a>
<a name="ln574">        invalidate_agrid();</a>
<a name="ln575"> </a>
<a name="ln576">    // FIXME: [ds] Remove this once we've ensured durations can never go &lt; 0?</a>
<a name="ln577">    if (you.duration[DUR_TRANSFORMATION] &lt;= 0</a>
<a name="ln578">        &amp;&amp; you.form != transformation::none)</a>
<a name="ln579">    {</a>
<a name="ln580">        you.duration[DUR_TRANSFORMATION] = 1;</a>
<a name="ln581">    }</a>
<a name="ln582"> </a>
<a name="ln583">    // Vampire bat transformations are permanent (until ended), unless they</a>
<a name="ln584">    // are uncancellable (polymorph wand on a full vampire).</a>
<a name="ln585">    if (you.species != SP_VAMPIRE || you.form != transformation::bat</a>
<a name="ln586">        || you.transform_uncancellable)</a>
<a name="ln587">    {</a>
<a name="ln588">        if (form_can_fly()</a>
<a name="ln589">            || form_likes_water() &amp;&amp; feat_is_water(grd(you.pos())))</a>
<a name="ln590">        {</a>
<a name="ln591">            // Disable emergency flight if it was active</a>
<a name="ln592">            you.props.erase(EMERGENCY_FLIGHT_KEY);</a>
<a name="ln593">        }</a>
<a name="ln594"> </a>
<a name="ln595">        if (_decrement_a_duration(DUR_TRANSFORMATION, delay, nullptr, random2(3),</a>
<a name="ln596">                                  &quot;Your transformation is almost over.&quot;))</a>
<a name="ln597">        {</a>
<a name="ln598">            untransform();</a>
<a name="ln599">        }</a>
<a name="ln600">    }</a>
<a name="ln601"> </a>
<a name="ln602">    if (you.attribute[ATTR_SWIFTNESS] &gt;= 0)</a>
<a name="ln603">    {</a>
<a name="ln604">        if (_decrement_a_duration(DUR_SWIFTNESS, delay,</a>
<a name="ln605">                                  &quot;You feel sluggish.&quot;, coinflip(),</a>
<a name="ln606">                                  &quot;You start to feel a little slower.&quot;))</a>
<a name="ln607">        {</a>
<a name="ln608">            // Start anti-swiftness.</a>
<a name="ln609">            you.duration[DUR_SWIFTNESS] = you.attribute[ATTR_SWIFTNESS];</a>
<a name="ln610">            you.attribute[ATTR_SWIFTNESS] = -1;</a>
<a name="ln611">        }</a>
<a name="ln612">    }</a>
<a name="ln613">    else</a>
<a name="ln614">    {</a>
<a name="ln615">        if (_decrement_a_duration(DUR_SWIFTNESS, delay,</a>
<a name="ln616">                                  &quot;You no longer feel sluggish.&quot;, coinflip(),</a>
<a name="ln617">                                  &quot;You start to feel a little faster.&quot;))</a>
<a name="ln618">        {</a>
<a name="ln619">            you.attribute[ATTR_SWIFTNESS] = 0;</a>
<a name="ln620">        }</a>
<a name="ln621">    }</a>
<a name="ln622"> </a>
<a name="ln623">    // Decrement Powered By Death strength</a>
<a name="ln624">    int pbd_str = you.props[POWERED_BY_DEATH_KEY].get_int();</a>
<a name="ln625">    if (pbd_str &gt; 0 &amp;&amp; _decrement_a_duration(DUR_POWERED_BY_DEATH, delay))</a>
<a name="ln626">    {</a>
<a name="ln627">        you.props[POWERED_BY_DEATH_KEY] = pbd_str - 1;</a>
<a name="ln628">        reset_powered_by_death_duration();</a>
<a name="ln629">    }</a>
<a name="ln630"> </a>
<a name="ln631">    dec_ambrosia_player(delay);</a>
<a name="ln632">    dec_channel_player(delay);</a>
<a name="ln633">    dec_slow_player(delay);</a>
<a name="ln634">    dec_berserk_recovery_player(delay);</a>
<a name="ln635">    dec_haste_player(delay);</a>
<a name="ln636"> </a>
<a name="ln637">    for (int i = 0; i &lt; NUM_STATS; ++i)</a>
<a name="ln638">    {</a>
<a name="ln639">        stat_type s = static_cast&lt;stat_type&gt;(i);</a>
<a name="ln640">        if (you.stat(s) &gt; 0</a>
<a name="ln641">            &amp;&amp; _decrement_a_duration(stat_zero_duration(s), delay))</a>
<a name="ln642">        {</a>
<a name="ln643">            mprf(MSGCH_RECOVERY, &quot;Your %s has recovered.&quot;, stat_desc(s, SD_NAME));</a>
<a name="ln644">            you.redraw_stats[s] = true;</a>
<a name="ln645">            if (you.duration[DUR_SLOW] == 0)</a>
<a name="ln646">                mprf(MSGCH_DURATION, &quot;You feel yourself speed up.&quot;);</a>
<a name="ln647">        }</a>
<a name="ln648">    }</a>
<a name="ln649"> </a>
<a name="ln650">    // Leak piety from the piety pool into actual piety.</a>
<a name="ln651">    // Note that changes of religious status without corresponding actions</a>
<a name="ln652">    // (killing monsters, offering items, ...) might be confusing for characters</a>
<a name="ln653">    // of other religions.</a>
<a name="ln654">    // For now, though, keep information about what happened hidden.</a>
<a name="ln655">    if (you.piety &lt; MAX_PIETY &amp;&amp; you.duration[DUR_PIETY_POOL] &gt; 0</a>
<a name="ln656">        &amp;&amp; one_chance_in(5))</a>
<a name="ln657">    {</a>
<a name="ln658">        you.duration[DUR_PIETY_POOL]--;</a>
<a name="ln659">        gain_piety(1, 1);</a>
<a name="ln660"> </a>
<a name="ln661">#if defined(DEBUG_DIAGNOSTICS) || defined(DEBUG_SACRIFICE) || defined(DEBUG_PIETY)</a>
<a name="ln662">        mprf(MSGCH_DIAGNOSTICS, &quot;Piety increases by 1 due to piety pool.&quot;);</a>
<a name="ln663"> </a>
<a name="ln664">        if (you.duration[DUR_PIETY_POOL] == 0)</a>
<a name="ln665">            mprf(MSGCH_DIAGNOSTICS, &quot;Piety pool is now empty.&quot;);</a>
<a name="ln666">#endif</a>
<a name="ln667">    }</a>
<a name="ln668"> </a>
<a name="ln669">    if (you.duration[DUR_DISJUNCTION])</a>
<a name="ln670">        disjunction_spell();</a>
<a name="ln671"> </a>
<a name="ln672">    // Should expire before flight.</a>
<a name="ln673">    if (you.duration[DUR_TORNADO])</a>
<a name="ln674">    {</a>
<a name="ln675">        tornado_damage(&amp;you, min(delay, you.duration[DUR_TORNADO]));</a>
<a name="ln676">        if (_decrement_a_duration(DUR_TORNADO, delay,</a>
<a name="ln677">                                  &quot;The winds around you start to calm down.&quot;))</a>
<a name="ln678">        {</a>
<a name="ln679">            you.duration[DUR_TORNADO_COOLDOWN] = random_range(35, 45);</a>
<a name="ln680">        }</a>
<a name="ln681">    }</a>
<a name="ln682"> </a>
<a name="ln683">    if (you.duration[DUR_FLIGHT])</a>
<a name="ln684">    {</a>
<a name="ln685">        if (!you.permanent_flight())</a>
<a name="ln686">        {</a>
<a name="ln687">            if (_decrement_a_duration(DUR_FLIGHT, delay, nullptr, random2(6),</a>
<a name="ln688">                                      &quot;You are starting to lose your buoyancy.&quot;))</a>
<a name="ln689">            {</a>
<a name="ln690">                land_player();</a>
<a name="ln691">            }</a>
<a name="ln692">            else</a>
<a name="ln693">            {</a>
<a name="ln694">                // Disable emergency flight if it was active</a>
<a name="ln695">                you.props.erase(EMERGENCY_FLIGHT_KEY);</a>
<a name="ln696">            }</a>
<a name="ln697">        }</a>
<a name="ln698">        else if ((you.duration[DUR_FLIGHT] -= delay) &lt;= 0)</a>
<a name="ln699">        {</a>
<a name="ln700">            // Just time out potions/spells/miscasts.</a>
<a name="ln701">            you.attribute[ATTR_FLIGHT_UNCANCELLABLE] = 0;</a>
<a name="ln702">            you.duration[DUR_FLIGHT] = 0;</a>
<a name="ln703">            you.props.erase(EMERGENCY_FLIGHT_KEY);</a>
<a name="ln704">        }</a>
<a name="ln705">    }</a>
<a name="ln706"> </a>
<a name="ln707">    if (you.duration[DUR_DEATHS_DOOR]</a>
<a name="ln708">        &amp;&amp; you.attribute[ATTR_DEATHS_DOOR_HP] &gt; 0</a>
<a name="ln709">        &amp;&amp; you.hp &gt; you.attribute[ATTR_DEATHS_DOOR_HP])</a>
<a name="ln710">    {</a>
<a name="ln711">        set_hp(you.attribute[ATTR_DEATHS_DOOR_HP]);</a>
<a name="ln712">        you.redraw_hit_points = true;</a>
<a name="ln713">    }</a>
<a name="ln714">    else if (!you.duration[DUR_DEATHS_DOOR]</a>
<a name="ln715">             &amp;&amp; you.attribute[ATTR_DEATHS_DOOR_HP] &gt; 0)</a>
<a name="ln716">    {</a>
<a name="ln717">        you.attribute[ATTR_DEATHS_DOOR_HP] = 0;</a>
<a name="ln718">    }</a>
<a name="ln719"> </a>
<a name="ln720">    if (_decrement_a_duration(DUR_CLOUD_TRAIL, delay,</a>
<a name="ln721">            &quot;Your trail of clouds dissipates.&quot;))</a>
<a name="ln722">    {</a>
<a name="ln723">        you.props.erase(XOM_CLOUD_TRAIL_TYPE_KEY);</a>
<a name="ln724">    }</a>
<a name="ln725"> </a>
<a name="ln726">    if (you.duration[DUR_DARKNESS] &amp;&amp; you.haloed())</a>
<a name="ln727">    {</a>
<a name="ln728">        you.duration[DUR_DARKNESS] = 0;</a>
<a name="ln729">        mpr(&quot;The divine light dispels your darkness!&quot;);</a>
<a name="ln730">        update_vision_range();</a>
<a name="ln731">    }</a>
<a name="ln732"> </a>
<a name="ln733">    if (you.duration[DUR_WATER_HOLD])</a>
<a name="ln734">        handle_player_drowning(delay);</a>
<a name="ln735"> </a>
<a name="ln736">    if (you.duration[DUR_FLAYED])</a>
<a name="ln737">    {</a>
<a name="ln738">        bool near_ghost = false;</a>
<a name="ln739">        for (monster_iterator mi; mi; ++mi)</a>
<a name="ln740">        {</a>
<a name="ln741">            if (mi-&gt;type == MONS_FLAYED_GHOST &amp;&amp; !mi-&gt;wont_attack()</a>
<a name="ln742">                &amp;&amp; you.see_cell(mi-&gt;pos()))</a>
<a name="ln743">            {</a>
<a name="ln744">                near_ghost = true;</a>
<a name="ln745">                break;</a>
<a name="ln746">            }</a>
<a name="ln747">        }</a>
<a name="ln748">        if (!near_ghost)</a>
<a name="ln749">        {</a>
<a name="ln750">            if (_decrement_a_duration(DUR_FLAYED, delay))</a>
<a name="ln751">                heal_flayed_effect(&amp;you);</a>
<a name="ln752">        }</a>
<a name="ln753">        else if (you.duration[DUR_FLAYED] &lt; 80)</a>
<a name="ln754">            you.duration[DUR_FLAYED] += div_rand_round(50, delay);</a>
<a name="ln755">    }</a>
<a name="ln756"> </a>
<a name="ln757">    if (you.duration[DUR_TOXIC_RADIANCE])</a>
<a name="ln758">        toxic_radiance_effect(&amp;you, min(delay, you.duration[DUR_TOXIC_RADIANCE]));</a>
<a name="ln759"> </a>
<a name="ln760">    if (you.duration[DUR_RECITE] &amp;&amp; _check_recite())</a>
<a name="ln761">    {</a>
<a name="ln762">        const int old_recite =</a>
<a name="ln763">            (you.duration[DUR_RECITE] + BASELINE_DELAY - 1) / BASELINE_DELAY;</a>
<a name="ln764">        _decrement_a_duration(DUR_RECITE, delay);</a>
<a name="ln765">        const int new_recite =</a>
<a name="ln766">            (you.duration[DUR_RECITE] + BASELINE_DELAY - 1) / BASELINE_DELAY;</a>
<a name="ln767">        if (old_recite != new_recite)</a>
<a name="ln768">            _handle_recitation(new_recite);</a>
<a name="ln769">    }</a>
<a name="ln770"> </a>
<a name="ln771">    if (you.attribute[ATTR_NEXT_RECALL_INDEX] &gt; 0)</a>
<a name="ln772">        do_recall(delay);</a>
<a name="ln773"> </a>
<a name="ln774">    if (you.duration[DUR_DRAGON_CALL])</a>
<a name="ln775">        do_dragon_call(delay);</a>
<a name="ln776"> </a>
<a name="ln777">    if (you.duration[DUR_ABJURATION_AURA])</a>
<a name="ln778">        do_aura_of_abjuration(delay);</a>
<a name="ln779"> </a>
<a name="ln780">    if (you.duration[DUR_DOOM_HOWL])</a>
<a name="ln781">        doom_howl(min(delay, you.duration[DUR_DOOM_HOWL]));</a>
<a name="ln782"> </a>
<a name="ln783">    dec_elixir_player(delay);</a>
<a name="ln784">    dec_frozen_ramparts(delay);</a>
<a name="ln785"> </a>
<a name="ln786">    if (!you.cannot_move()</a>
<a name="ln787">        &amp;&amp; !you.confused()</a>
<a name="ln788">        &amp;&amp; !you.asleep())</a>
<a name="ln789">    {</a>
<a name="ln790">        extract_manticore_spikes(</a>
<a name="ln791">            make_stringf(&quot;You %s the barbed spikes from your body.&quot;,</a>
<a name="ln792">                you.berserk() ? &quot;rip and tear&quot; : &quot;carefully extract&quot;).c_str());</a>
<a name="ln793">    }</a>
<a name="ln794"> </a>
<a name="ln795">    if (!you.duration[DUR_ANCESTOR_DELAY]</a>
<a name="ln796">        &amp;&amp; in_good_standing(GOD_HEPLIAKLQANA)</a>
<a name="ln797">        &amp;&amp; hepliaklqana_ancestor() == MID_NOBODY)</a>
<a name="ln798">    {</a>
<a name="ln799">        _try_to_respawn_ancestor();</a>
<a name="ln800">    }</a>
<a name="ln801"> </a>
<a name="ln802">    const bool sanguine_armour_is_valid = sanguine_armour_valid();</a>
<a name="ln803">    if (sanguine_armour_is_valid)</a>
<a name="ln804">        activate_sanguine_armour();</a>
<a name="ln805">    else if (!sanguine_armour_is_valid &amp;&amp; you.duration[DUR_SANGUINE_ARMOUR])</a>
<a name="ln806">        you.duration[DUR_SANGUINE_ARMOUR] = 1; // expire</a>
<a name="ln807"> </a>
<a name="ln808">    if (you.duration[DUR_HEAVENLY_STORM])</a>
<a name="ln809">        wu_jian_heaven_tick();</a>
<a name="ln810"> </a>
<a name="ln811">    // these should be after decr_ambrosia, transforms, liquefying, etc.</a>
<a name="ln812">    for (int i = 0; i &lt; NUM_DURATIONS; ++i)</a>
<a name="ln813">        if (duration_decrements_normally((duration_type) i))</a>
<a name="ln814">            _decrement_simple_duration((duration_type) i, delay);</a>
<a name="ln815">}</a>
<a name="ln816"> </a>
<a name="ln817">/**</a>
<a name="ln818"> * Handles player ghoul rotting over time.</a>
<a name="ln819"> */</a>
<a name="ln820">static void _rot_ghoul_players()</a>
<a name="ln821">{</a>
<a name="ln822">    if (you.species != SP_GHOUL)</a>
<a name="ln823">        return;</a>
<a name="ln824"> </a>
<a name="ln825">    int resilience = 400;</a>
<a name="ln826">    if (have_passive(passive_t::slow_metabolism))</a>
<a name="ln827">        resilience = resilience * 3 / 2;</a>
<a name="ln828"> </a>
<a name="ln829">    // Faster rotting when hungry.</a>
<a name="ln830">    if (you.hunger_state &lt; HS_SATIATED)</a>
<a name="ln831">        resilience &gt;&gt;= HS_SATIATED - you.hunger_state;</a>
<a name="ln832"> </a>
<a name="ln833">    if (one_chance_in(resilience))</a>
<a name="ln834">    {</a>
<a name="ln835">        dprf(&quot;rot rate: 1/%d&quot;, resilience);</a>
<a name="ln836">        mprf(MSGCH_WARN, &quot;You feel your flesh rotting away.&quot;);</a>
<a name="ln837">        rot_hp(1);</a>
<a name="ln838">    }</a>
<a name="ln839">}</a>
<a name="ln840"> </a>
<a name="ln841">static void _handle_emergency_flight()</a>
<a name="ln842">{</a>
<a name="ln843">    ASSERT(you.props[EMERGENCY_FLIGHT_KEY].get_bool());</a>
<a name="ln844"> </a>
<a name="ln845">    if (!is_feat_dangerous(orig_terrain(you.pos()), true, false))</a>
<a name="ln846">    {</a>
<a name="ln847">        mpr(&quot;You float gracefully downwards.&quot;);</a>
<a name="ln848">        land_player();</a>
<a name="ln849">        you.props.erase(EMERGENCY_FLIGHT_KEY);</a>
<a name="ln850">    }</a>
<a name="ln851">    else</a>
<a name="ln852">    {</a>
<a name="ln853">        const int drain = div_rand_round(15 * you.time_taken, BASELINE_DELAY);</a>
<a name="ln854">        drain_player(drain, true, true);</a>
<a name="ln855">    }</a>
<a name="ln856">}</a>
<a name="ln857"> </a>
<a name="ln858">// Regen equipment and amulet of the acrobat only begins to function when full</a>
<a name="ln859">// health is reached while they are worn.</a>
<a name="ln860">static void _update_equipment_attunement_by_health()</a>
<a name="ln861">{</a>
<a name="ln862">    if (you.hp != you.hp_max)</a>
<a name="ln863">        return;</a>
<a name="ln864"> </a>
<a name="ln865">    if (!you.activated[EQ_AMULET] &amp;&amp; you.wearing(EQ_AMULET, AMU_ACROBAT))</a>
<a name="ln866">    {</a>
<a name="ln867">        mprf(&quot;Your amulet attunes itself to your body. You feel like doing &quot;</a>
<a name="ln868">             &quot;cartwheels.&quot;);</a>
<a name="ln869">        you.activated.set(EQ_AMULET);</a>
<a name="ln870">    }</a>
<a name="ln871"> </a>
<a name="ln872">    if (you.get_mutation_level(MUT_NO_REGENERATION))</a>
<a name="ln873">        return;</a>
<a name="ln874"> </a>
<a name="ln875">    vector&lt;string&gt; eq_list;</a>
<a name="ln876">    bool plural = false;</a>
<a name="ln877"> </a>
<a name="ln878">    if (!you.activated[EQ_AMULET] &amp;&amp; you.wearing(EQ_AMULET, AMU_REGENERATION))</a>
<a name="ln879">    {</a>
<a name="ln880">        eq_list.push_back(&quot;amulet&quot;);</a>
<a name="ln881">        you.activated.set(EQ_AMULET);</a>
<a name="ln882">    }</a>
<a name="ln883"> </a>
<a name="ln884">    for (int slot = EQ_MIN_ARMOUR; slot &lt;= EQ_MAX_ARMOUR; ++slot)</a>
<a name="ln885">    {</a>
<a name="ln886">        if (you.melded[slot] || you.equip[slot] == -1 || you.activated[slot])</a>
<a name="ln887">            continue;</a>
<a name="ln888">        const item_def &amp;arm = you.inv[you.equip[slot]];</a>
<a name="ln889">        if (armour_type_prop(arm.sub_type, ARMF_REGENERATION)</a>
<a name="ln890">            || is_artefact(arm) &amp;&amp; artefact_property(arm, ARTP_REGENERATION))</a>
<a name="ln891">        {</a>
<a name="ln892">            eq_list.push_back(</a>
<a name="ln893">                slot != EQ_BODY_ARMOUR ?</a>
<a name="ln894">                    item_slot_name(static_cast&lt;equipment_type&gt;(slot)) :</a>
<a name="ln895">                    is_artefact(arm) ? get_artefact_name(arm) : &quot;armour&quot;);</a>
<a name="ln896"> </a>
<a name="ln897">            if (slot == EQ_GLOVES || slot == EQ_BOOTS)</a>
<a name="ln898">                plural = true;</a>
<a name="ln899">            you.activated.set(slot);</a>
<a name="ln900">        }</a>
<a name="ln901">    }</a>
<a name="ln902"> </a>
<a name="ln903">    if (eq_list.empty())</a>
<a name="ln904">        return;</a>
<a name="ln905"> </a>
<a name="ln906">    plural = plural || eq_list.size() &gt; 1;</a>
<a name="ln907">    string eq_str = comma_separated_line(eq_list.begin(), eq_list.end());</a>
<a name="ln908">    mprf(&quot;Your %s attune%s to your body as you begin to regenerate &quot;</a>
<a name="ln909">         &quot;more quickly.&quot;, eq_str.c_str(), plural ? &quot; themselves&quot; : &quot;s itself&quot;);</a>
<a name="ln910">}</a>
<a name="ln911"> </a>
<a name="ln912">// Amulet of magic regeneration needs to be worn while at full magic before it</a>
<a name="ln913">// begins to function.</a>
<a name="ln914">static void _update_mana_regen_amulet_attunement()</a>
<a name="ln915">{</a>
<a name="ln916">    if (you.wearing(EQ_AMULET, AMU_MANA_REGENERATION)</a>
<a name="ln917">        &amp;&amp; player_regenerates_mp())</a>
<a name="ln918">    {</a>
<a name="ln919">        if (you.magic_points == you.max_magic_points</a>
<a name="ln920">            &amp;&amp; you.props[MANA_REGEN_AMULET_ACTIVE].get_int() == 0)</a>
<a name="ln921">        {</a>
<a name="ln922">            you.props[MANA_REGEN_AMULET_ACTIVE] = 1;</a>
<a name="ln923">            mpr(&quot;Your amulet attunes itself to your body and you begin to &quot;</a>
<a name="ln924">                &quot;regenerate magic more quickly.&quot;);</a>
<a name="ln925">        }</a>
<a name="ln926">    }</a>
<a name="ln927">    else</a>
<a name="ln928">        you.props[MANA_REGEN_AMULET_ACTIVE] = 0;</a>
<a name="ln929">}</a>
<a name="ln930"> </a>
<a name="ln931">// cjo: Handles player hp and mp regeneration. If the counter</a>
<a name="ln932">// you.hit_points_regeneration is over 100, a loop restores 1 hp and decreases</a>
<a name="ln933">// the counter by 100 (so you can regen more than 1 hp per turn). If the counter</a>
<a name="ln934">// is below 100, it is increased by a variable calculated from delay,</a>
<a name="ln935">// BASELINE_DELAY, and your regeneration rate. MP regeneration happens</a>
<a name="ln936">// similarly, but the countup depends on delay, BASELINE_DELAY, and</a>
<a name="ln937">// you.max_magic_points</a>
<a name="ln938">static void _regenerate_hp_and_mp(int delay)</a>
<a name="ln939">{</a>
<a name="ln940">    if (crawl_state.disables[DIS_PLAYER_REGEN])</a>
<a name="ln941">        return;</a>
<a name="ln942"> </a>
<a name="ln943">    // HP Regeneration</a>
<a name="ln944">    if (!you.duration[DUR_DEATHS_DOOR])</a>
<a name="ln945">    {</a>
<a name="ln946">        const int base_val = player_regen();</a>
<a name="ln947">        you.hit_points_regeneration += div_rand_round(base_val * delay, BASELINE_DELAY);</a>
<a name="ln948">    }</a>
<a name="ln949"> </a>
<a name="ln950">    while (you.hit_points_regeneration &gt;= 100)</a>
<a name="ln951">    {</a>
<a name="ln952">        // at low mp, &quot;mana link&quot; restores mp in place of hp</a>
<a name="ln953">        if (you.has_mutation(MUT_MANA_LINK)</a>
<a name="ln954">            &amp;&amp; !x_chance_in_y(you.magic_points, you.max_magic_points))</a>
<a name="ln955">        {</a>
<a name="ln956">            inc_mp(1);</a>
<a name="ln957">        }</a>
<a name="ln958">        else // standard hp regeneration</a>
<a name="ln959">            inc_hp(1);</a>
<a name="ln960">        you.hit_points_regeneration -= 100;</a>
<a name="ln961">    }</a>
<a name="ln962"> </a>
<a name="ln963">    ASSERT_RANGE(you.hit_points_regeneration, 0, 100);</a>
<a name="ln964"> </a>
<a name="ln965">    _update_equipment_attunement_by_health();</a>
<a name="ln966"> </a>
<a name="ln967">    // MP Regeneration</a>
<a name="ln968">    if (!player_regenerates_mp())</a>
<a name="ln969">        return;</a>
<a name="ln970"> </a>
<a name="ln971">    if (you.magic_points &lt; you.max_magic_points)</a>
<a name="ln972">    {</a>
<a name="ln973">        const int base_val = player_mp_regen();</a>
<a name="ln974">        int mp_regen_countup = div_rand_round(base_val * delay, BASELINE_DELAY);</a>
<a name="ln975">        you.magic_points_regeneration += mp_regen_countup;</a>
<a name="ln976">    }</a>
<a name="ln977"> </a>
<a name="ln978">    while (you.magic_points_regeneration &gt;= 100)</a>
<a name="ln979">    {</a>
<a name="ln980">        inc_mp(1);</a>
<a name="ln981">        you.magic_points_regeneration -= 100;</a>
<a name="ln982">    }</a>
<a name="ln983"> </a>
<a name="ln984">    ASSERT_RANGE(you.magic_points_regeneration, 0, 100);</a>
<a name="ln985"> </a>
<a name="ln986">    _update_mana_regen_amulet_attunement();</a>
<a name="ln987">}</a>
<a name="ln988"> </a>
<a name="ln989">void player_reacts()</a>
<a name="ln990">{</a>
<a name="ln991">    //XXX: does this _need_ to be calculated up here?</a>
<a name="ln992">    const int stealth = player_stealth();</a>
<a name="ln993"> </a>
<a name="ln994">#ifdef DEBUG_STEALTH</a>
<a name="ln995">    // Too annoying for regular diagnostics.</a>
<a name="ln996">    mprf(MSGCH_DIAGNOSTICS, &quot;stealth: %d&quot;, stealth);</a>
<a name="ln997">#endif</a>
<a name="ln998"> </a>
<a name="ln999">    if (you.has_mutation(MUT_DEMONIC_GUARDIAN))</a>
<a name="ln1000">        check_demonic_guardian();</a>
<a name="ln1001"> </a>
<a name="ln1002">    if (you.unrand_reacts.any())</a>
<a name="ln1003">        unrand_reacts();</a>
<a name="ln1004"> </a>
<a name="ln1005">    // Handle sound-dependent effects that are silenced</a>
<a name="ln1006">    if (silenced(you.pos()))</a>
<a name="ln1007">    {</a>
<a name="ln1008">        if (you.duration[DUR_SONG_OF_SLAYING])</a>
<a name="ln1009">        {</a>
<a name="ln1010">            mpr(&quot;The silence causes your song to end.&quot;);</a>
<a name="ln1011">            _decrement_a_duration(DUR_SONG_OF_SLAYING, you.duration[DUR_SONG_OF_SLAYING]);</a>
<a name="ln1012">        }</a>
<a name="ln1013">    }</a>
<a name="ln1014"> </a>
<a name="ln1015">    // Singing makes a continuous noise</a>
<a name="ln1016">    if (you.duration[DUR_SONG_OF_SLAYING])</a>
<a name="ln1017">        noisy(spell_effect_noise(SPELL_SONG_OF_SLAYING), you.pos());</a>
<a name="ln1018"> </a>
<a name="ln1019">    if (x_chance_in_y(you.time_taken, 10 * BASELINE_DELAY))</a>
<a name="ln1020">    {</a>
<a name="ln1021">        const int teleportitis_level = player_teleport();</a>
<a name="ln1022">        // this is instantaneous</a>
<a name="ln1023">        if (teleportitis_level &gt; 0 &amp;&amp; one_chance_in(100 / teleportitis_level))</a>
<a name="ln1024">            you_teleport_now(false, true, &quot;You feel strangely unstable.&quot;);</a>
<a name="ln1025">        else if (player_in_branch(BRANCH_ABYSS) &amp;&amp; one_chance_in(80)</a>
<a name="ln1026">                 &amp;&amp; (!map_masked(you.pos(), MMT_VAULT) || one_chance_in(3)))</a>
<a name="ln1027">        {</a>
<a name="ln1028">            you_teleport_now(); // to new area of the Abyss</a>
<a name="ln1029"> </a>
<a name="ln1030">            // It's effectively a new level, make a checkpoint save so eventual</a>
<a name="ln1031">            // crashes lose less of the player's progress (and fresh new bad</a>
<a name="ln1032">            // mutations).</a>
<a name="ln1033">            if (!crawl_state.disables[DIS_SAVE_CHECKPOINTS])</a>
<a name="ln1034">                save_game(false);</a>
<a name="ln1035">        }</a>
<a name="ln1036">        else if (you.form == transformation::wisp &amp;&amp; !you.stasis())</a>
<a name="ln1037">            uncontrolled_blink();</a>
<a name="ln1038">    }</a>
<a name="ln1039"> </a>
<a name="ln1040">    abyss_maybe_spawn_xp_exit();</a>
<a name="ln1041"> </a>
<a name="ln1042">    actor_apply_cloud(&amp;you);</a>
<a name="ln1043">    actor_apply_toxic_bog(&amp;you);</a>
<a name="ln1044"> </a>
<a name="ln1045">    if (env.level_state &amp; LSTATE_SLIMY_WALL)</a>
<a name="ln1046">        slime_wall_damage(&amp;you, you.time_taken);</a>
<a name="ln1047"> </a>
<a name="ln1048">    // Icy shield and armour melt over lava.</a>
<a name="ln1049">    if (grd(you.pos()) == DNGN_LAVA)</a>
<a name="ln1050">        maybe_melt_player_enchantments(BEAM_FIRE, you.time_taken);</a>
<a name="ln1051"> </a>
<a name="ln1052">    // Handle starvation before subtracting hunger for this turn (including</a>
<a name="ln1053">    // hunger from the berserk duration) and before monsters react, so you</a>
<a name="ln1054">    // always get a turn (though it may be a delay or macro!) between getting</a>
<a name="ln1055">    // the Fainting light and actually fainting.</a>
<a name="ln1056">    handle_starvation();</a>
<a name="ln1057"> </a>
<a name="ln1058">    _decrement_durations();</a>
<a name="ln1059">    _rot_ghoul_players();</a>
<a name="ln1060"> </a>
<a name="ln1061">    // Translocations and possibly other duration decrements can</a>
<a name="ln1062">    // escape a player from beholders and fearmongers. These should</a>
<a name="ln1063">    // update after.</a>
<a name="ln1064">    you.update_beholders();</a>
<a name="ln1065">    you.update_fearmongers();</a>
<a name="ln1066"> </a>
<a name="ln1067">    you.handle_constriction();</a>
<a name="ln1068"> </a>
<a name="ln1069">    // increment constriction durations</a>
<a name="ln1070">    you.accum_has_constricted();</a>
<a name="ln1071"> </a>
<a name="ln1072">    const int food_use = div_rand_round(player_hunger_rate() * you.time_taken,</a>
<a name="ln1073">                                        BASELINE_DELAY);</a>
<a name="ln1074">    if (food_use &gt; 0 &amp;&amp; you.hunger &gt; 0)</a>
<a name="ln1075">        make_hungry(food_use, true);</a>
<a name="ln1076"> </a>
<a name="ln1077">    _regenerate_hp_and_mp(you.time_taken);</a>
<a name="ln1078"> </a>
<a name="ln1079">    dec_disease_player(you.time_taken);</a>
<a name="ln1080">    if (you.duration[DUR_POISONING])</a>
<a name="ln1081">        handle_player_poison(you.time_taken);</a>
<a name="ln1082"> </a>
<a name="ln1083">    // Reveal adjacent mimics.</a>
<a name="ln1084">    for (adjacent_iterator ai(you.pos(), false); ai; ++ai)</a>
<a name="ln1085">        discover_mimic(*ai);</a>
<a name="ln1086"> </a>
<a name="ln1087">    // Player stealth check.</a>
<a name="ln1088">    seen_monsters_react(stealth);</a>
<a name="ln1089"> </a>
<a name="ln1090">    // XOM now ticks from here, to increase his reaction time to tension.</a>
<a name="ln1091">    if (you_worship(GOD_XOM))</a>
<a name="ln1092">        xom_tick();</a>
<a name="ln1093">    else if (you_worship(GOD_QAZLAL))</a>
<a name="ln1094">        qazlal_storm_clouds();</a>
<a name="ln1095"> </a>
<a name="ln1096">    if (you.props[EMERGENCY_FLIGHT_KEY].get_bool())</a>
<a name="ln1097">        _handle_emergency_flight();</a>
<a name="ln1098">}</a>
<a name="ln1099"> </a>
<a name="ln1100">void extract_manticore_spikes(const char* endmsg)</a>
<a name="ln1101">{</a>
<a name="ln1102">    if (_decrement_a_duration(DUR_BARBS, you.time_taken, endmsg))</a>
<a name="ln1103">    {</a>
<a name="ln1104">        // Note: When this is called in _move player(), ATTR_BARBS_POW</a>
<a name="ln1105">        // has already been used to calculated damage for the player.</a>
<a name="ln1106">        // Otherwise, this prevents the damage.</a>
<a name="ln1107"> </a>
<a name="ln1108">        you.attribute[ATTR_BARBS_POW] = 0;</a>
<a name="ln1109"> </a>
<a name="ln1110">        you.props.erase(BARBS_MOVE_KEY);</a>
<a name="ln1111">    }</a>
<a name="ln1112">}</a>

</code></pre>
<div class="balloon" rel="589"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v648/" target="_blank">V648</a> Priority of the '&&' operation is higher than that of the '||' operation.</p></div>
<div class="balloon" rel="805"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v560/" target="_blank">V560</a> A part of conditional expression is always true: !sanguine_armour_is_valid.</p></div>
<div class="balloon" rel="890"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v648/" target="_blank">V648</a> Priority of the '&&' operation is higher than that of the '||' operation.</p></div>

<link rel="stylesheet" href="highlight.css">
<script src="highlight.pack.js"></script>
<script src="highlightjs-line-numbers.js"></script>
<script>hljs.initHighlightingOnLoad();</script>
<script>hljs.initLineNumbersOnLoad();</script>
<script>
  $(document).ready(function() {
      $('.balloon').each(function () {
          var bl = $(this);
          var line = bl.attr('rel');
          var text = $('a[name="ln'+line+'"]').text();

          var space_count = 0;
          for(var i = 0; i<text.length; i++){
              var char = text[i];
              if((char !== ' ')&&(char !== '\t'))break;
              if(char === '\t')space_count++;
              space_count++;
          }

          bl.css('margin-left', space_count*8);
          $('a[name="ln'+line+'"]').after(bl);
      });

      window.location = window.location;
  });
</script>
</body>
</html>
