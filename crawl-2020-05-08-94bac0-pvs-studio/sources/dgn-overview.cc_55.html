
<html>
<head>

  <meta http-equiv="Content-Type" content="text/html; charset=US-ASCII" />
  <title>dgn-overview.cc</title>

  <link rel="stylesheet" href="../style.css"/>
  <script src="../jquery-3.2.1.min.js"></script>
</head>
<body>

<pre><code class = "cpp">
<a name="ln1">/**</a>
<a name="ln2"> * @file</a>
<a name="ln3"> * @brief Records location of stairs etc</a>
<a name="ln4">**/</a>
<a name="ln5"> </a>
<a name="ln6">#include &quot;AppHdr.h&quot;</a>
<a name="ln7"> </a>
<a name="ln8">#include &quot;dgn-overview.h&quot;</a>
<a name="ln9"> </a>
<a name="ln10">#include &lt;algorithm&gt;</a>
<a name="ln11">#include &lt;cstdio&gt;</a>
<a name="ln12">#include &lt;cstdlib&gt;</a>
<a name="ln13">#include &lt;cstring&gt;</a>
<a name="ln14"> </a>
<a name="ln15">#include &quot;branch.h&quot;</a>
<a name="ln16">#include &quot;describe.h&quot;</a>
<a name="ln17">#include &quot;env.h&quot;</a>
<a name="ln18">#include &quot;feature.h&quot;</a>
<a name="ln19">#include &quot;files.h&quot;</a>
<a name="ln20">#include &quot;libutil.h&quot;</a>
<a name="ln21">#include &quot;macro.h&quot;</a>
<a name="ln22">#include &quot;menu.h&quot;</a>
<a name="ln23">#include &quot;message.h&quot;</a>
<a name="ln24">#include &quot;prompt.h&quot;</a>
<a name="ln25">#include &quot;religion.h&quot;</a>
<a name="ln26">#include &quot;scroller.h&quot;</a>
<a name="ln27">#include &quot;stairs.h&quot;</a>
<a name="ln28">#include &quot;stringutil.h&quot;</a>
<a name="ln29">#include &quot;terrain.h&quot;</a>
<a name="ln30">#include &quot;travel.h&quot;</a>
<a name="ln31">#include &quot;unicode.h&quot;</a>
<a name="ln32"> </a>
<a name="ln33">typedef map&lt;branch_type, set&lt;level_id&gt; &gt; stair_map_type;</a>
<a name="ln34">typedef map&lt;level_pos, shop_type&gt; shop_map_type;</a>
<a name="ln35">typedef map&lt;level_pos, god_type&gt; altar_map_type;</a>
<a name="ln36">typedef map&lt;level_pos, branch_type&gt; portal_map_type;</a>
<a name="ln37">typedef map&lt;level_pos, string&gt; portal_note_map_type;</a>
<a name="ln38">typedef map&lt;level_id, string&gt; annotation_map_type;</a>
<a name="ln39">typedef pair&lt;string, level_id&gt; monster_annotation;</a>
<a name="ln40"> </a>
<a name="ln41">stair_map_type stair_level;</a>
<a name="ln42">shop_map_type shops_present;</a>
<a name="ln43">altar_map_type altars_present;</a>
<a name="ln44">portal_map_type portals_present;</a>
<a name="ln45">portal_note_map_type portal_notes;</a>
<a name="ln46">annotation_map_type level_annotations;</a>
<a name="ln47">annotation_map_type level_exclusions;</a>
<a name="ln48">annotation_map_type level_uniques;</a>
<a name="ln49">// FIXME: this should really be a multiset, in case you get multiple</a>
<a name="ln50">// ghosts with the same name, combo, and XL on the same level.</a>
<a name="ln51">set&lt;monster_annotation&gt; auto_unique_annotations;</a>
<a name="ln52"> </a>
<a name="ln53">static void _seen_altar(god_type god, const coord_def&amp; pos);</a>
<a name="ln54">static void _seen_staircase(const coord_def&amp; pos);</a>
<a name="ln55">static void _seen_shop(const coord_def&amp; pos);</a>
<a name="ln56">static void _seen_portal(dungeon_feature_type feat, const coord_def&amp; pos);</a>
<a name="ln57">static void _process_command(const char keypress);</a>
<a name="ln58"> </a>
<a name="ln59">static string _get_branches(bool display);</a>
<a name="ln60">static string _get_altars(bool display);</a>
<a name="ln61">static string _get_shops(bool display);</a>
<a name="ln62">static string _get_portals();</a>
<a name="ln63">static string _get_notes(bool display);</a>
<a name="ln64">static string _print_altars_for_gods(const vector&lt;god_type&gt;&amp; gods,</a>
<a name="ln65">                                     bool print_unseen, bool display);</a>
<a name="ln66">static const string _get_coloured_level_annotation(level_id li);</a>
<a name="ln67"> </a>
<a name="ln68">void overview_clear()</a>
<a name="ln69">{</a>
<a name="ln70">    stair_level.clear();</a>
<a name="ln71">    shops_present.clear();</a>
<a name="ln72">    altars_present.clear();</a>
<a name="ln73">    portals_present.clear();</a>
<a name="ln74">    portal_notes.clear();</a>
<a name="ln75">    level_annotations.clear();</a>
<a name="ln76">    level_exclusions.clear();</a>
<a name="ln77">    level_uniques.clear();</a>
<a name="ln78">    auto_unique_annotations.clear();</a>
<a name="ln79">}</a>
<a name="ln80"> </a>
<a name="ln81">void seen_notable_thing(dungeon_feature_type which_thing, const coord_def&amp; pos)</a>
<a name="ln82">{</a>
<a name="ln83">    // Don't record in temporary terrain</a>
<a name="ln84">    if (!player_in_connected_branch())</a>
<a name="ln85">        return;</a>
<a name="ln86"> </a>
<a name="ln87">    const god_type god = feat_altar_god(which_thing);</a>
<a name="ln88">    if (god != GOD_NO_GOD)</a>
<a name="ln89">        _seen_altar(god, pos);</a>
<a name="ln90">    else if (feat_is_branch_entrance(which_thing))</a>
<a name="ln91">        _seen_staircase(pos);</a>
<a name="ln92">    else if (which_thing == DNGN_ENTER_SHOP)</a>
<a name="ln93">        _seen_shop(pos);</a>
<a name="ln94">    else if (feat_is_gate(which_thing)) // overinclusive</a>
<a name="ln95">        _seen_portal(which_thing, pos);</a>
<a name="ln96">}</a>
<a name="ln97"> </a>
<a name="ln98">bool move_notable_thing(const coord_def&amp; orig, const coord_def&amp; dest)</a>
<a name="ln99">{</a>
<a name="ln100">    ASSERT_IN_BOUNDS(orig);</a>
<a name="ln101">    ASSERT_IN_BOUNDS(dest);</a>
<a name="ln102">    ASSERT(orig != dest);</a>
<a name="ln103">    ASSERT(!is_notable_terrain(grd(dest)));</a>
<a name="ln104"> </a>
<a name="ln105">    if (!is_notable_terrain(grd(orig)))</a>
<a name="ln106">        return false;</a>
<a name="ln107"> </a>
<a name="ln108">    level_pos pos1(level_id::current(), orig);</a>
<a name="ln109">    level_pos pos2(level_id::current(), dest);</a>
<a name="ln110"> </a>
<a name="ln111">    if (shops_present.count(pos1))</a>
<a name="ln112">        shops_present[pos2]         = shops_present[pos1];</a>
<a name="ln113">    if (altars_present.count(pos1))</a>
<a name="ln114">        altars_present[pos2]        = altars_present[pos1];</a>
<a name="ln115">    if (portals_present.count(pos1))</a>
<a name="ln116">        portals_present[pos2]       = portals_present[pos1];</a>
<a name="ln117">    if (portal_notes.count(pos1))</a>
<a name="ln118">        portal_notes[pos2]          = portal_notes[pos1];</a>
<a name="ln119"> </a>
<a name="ln120">    unnotice_feature(pos1);</a>
<a name="ln121"> </a>
<a name="ln122">    return true;</a>
<a name="ln123">}</a>
<a name="ln124"> </a>
<a name="ln125">static string coloured_branch(branch_type br)</a>
<a name="ln126">{</a>
<a name="ln127">    if (br &lt; 0 || br &gt;= NUM_BRANCHES)</a>
<a name="ln128">        return &quot;&lt;lightred&gt;Buggy buglands&lt;/lightred&gt;&quot;;</a>
<a name="ln129"> </a>
<a name="ln130">    return make_stringf(&quot;&lt;yellow&gt;%s&lt;/yellow&gt;&quot;, branches[br].shortname);</a>
<a name="ln131">}</a>
<a name="ln132"> </a>
<a name="ln133">static string shoptype_to_string(shop_type s)</a>
<a name="ln134">{</a>
<a name="ln135">    switch (s)</a>
<a name="ln136">    {</a>
<a name="ln137">    case SHOP_WEAPON:          return &quot;&lt;w&gt;(&lt;/w&gt;&quot;;</a>
<a name="ln138">    case SHOP_WEAPON_ANTIQUE:  return &quot;&lt;yellow&gt;(&lt;/yellow&gt;&quot;;</a>
<a name="ln139">    case SHOP_ARMOUR:          return &quot;&lt;w&gt;[&lt;/w&gt;&quot;;</a>
<a name="ln140">    case SHOP_ARMOUR_ANTIQUE:  return &quot;&lt;yellow&gt;[&lt;/yellow&gt;&quot;;</a>
<a name="ln141">    case SHOP_GENERAL:         return &quot;&lt;w&gt;*&lt;/w&gt;&quot;;</a>
<a name="ln142">    case SHOP_GENERAL_ANTIQUE: return &quot;&lt;yellow&gt;*&lt;/yellow&gt;&quot;;</a>
<a name="ln143">    case SHOP_JEWELLERY:       return &quot;&lt;w&gt;=&lt;/w&gt;&quot;;</a>
<a name="ln144">    case SHOP_EVOKABLES:       return &quot;&lt;w&gt;}&lt;/w&gt;&quot;;</a>
<a name="ln145">    case SHOP_BOOK:            return &quot;&lt;w&gt;:&lt;/w&gt;&quot;;</a>
<a name="ln146">    case SHOP_FOOD:            return &quot;&lt;w&gt;%&lt;/w&gt;&quot;;</a>
<a name="ln147">    case SHOP_DISTILLERY:      return &quot;&lt;w&gt;!&lt;/w&gt;&quot;;</a>
<a name="ln148">    case SHOP_SCROLL:          return &quot;&lt;w&gt;?&lt;/w&gt;&quot;;</a>
<a name="ln149">    default:                   return &quot;&lt;w&gt;x&lt;/w&gt;&quot;;</a>
<a name="ln150">    }</a>
<a name="ln151">}</a>
<a name="ln152"> </a>
<a name="ln153">bool overview_knows_portal(branch_type portal)</a>
<a name="ln154">{</a>
<a name="ln155">    for (const auto &amp;entry : portals_present)</a>
<a name="ln156">        if (entry.second == portal)</a>
<a name="ln157">            return true;</a>
<a name="ln158"> </a>
<a name="ln159">    return false;</a>
<a name="ln160">}</a>
<a name="ln161"> </a>
<a name="ln162">// Ever used only for Pan, Abyss and Hell.</a>
<a name="ln163">int overview_knows_num_portals(dungeon_feature_type portal)</a>
<a name="ln164">{</a>
<a name="ln165">    int num = 0;</a>
<a name="ln166">    for (const auto &amp;entry : portals_present)</a>
<a name="ln167">    {</a>
<a name="ln168">        if (branches[entry.second].entry_stairs == portal)</a>
<a name="ln169">            num++;</a>
<a name="ln170">    }</a>
<a name="ln171"> </a>
<a name="ln172">    return num;</a>
<a name="ln173">}</a>
<a name="ln174"> </a>
<a name="ln175">static string _portals_description_string()</a>
<a name="ln176">{</a>
<a name="ln177">    string disp;</a>
<a name="ln178">    level_id    last_id;</a>
<a name="ln179">    for (branch_iterator it; it; ++it)</a>
<a name="ln180">    {</a>
<a name="ln181">        last_id.depth = 10000;</a>
<a name="ln182">        for (const auto &amp;entry : portals_present)</a>
<a name="ln183">        {</a>
<a name="ln184">            // one line per region should be enough, they're all of the form</a>
<a name="ln185">            // Branch:XX.</a>
<a name="ln186">            if (entry.second == it-&gt;id)</a>
<a name="ln187">            {</a>
<a name="ln188">                if (last_id.depth == 10000)</a>
<a name="ln189">                    disp += coloured_branch(entry.second)+ &quot;:&quot;;</a>
<a name="ln190"> </a>
<a name="ln191">                if (entry.first.id == last_id)</a>
<a name="ln192">                    disp += '*';</a>
<a name="ln193">                else</a>
<a name="ln194">                {</a>
<a name="ln195">                    disp += ' ';</a>
<a name="ln196">                    disp += entry.first.id.describe(false, true);</a>
<a name="ln197">                }</a>
<a name="ln198">                last_id = entry.first.id;</a>
<a name="ln199"> </a>
<a name="ln200">                // Portals notes (Trove price).</a>
<a name="ln201">                const string note = portal_notes[entry.first];</a>
<a name="ln202">                if (!note.empty())</a>
<a name="ln203">                    disp += &quot; (&quot; + note + &quot;)&quot;;</a>
<a name="ln204">            }</a>
<a name="ln205">        }</a>
<a name="ln206">        if (last_id.depth != 10000)</a>
<a name="ln207">            disp += &quot;\n&quot;;</a>
<a name="ln208">    }</a>
<a name="ln209">    return disp;</a>
<a name="ln210">}</a>
<a name="ln211"> </a>
<a name="ln212">// display: format for in-game display; !display: format for dump</a>
<a name="ln213">string overview_description_string(bool display)</a>
<a name="ln214">{</a>
<a name="ln215">    string disp;</a>
<a name="ln216"> </a>
<a name="ln217">    disp += &quot;                    &lt;white&gt;Dungeon Overview and Level Annotations&lt;/white&gt;\n&quot; ;</a>
<a name="ln218">    disp += _get_branches(display);</a>
<a name="ln219">    disp += _get_altars(display);</a>
<a name="ln220">    disp += _get_shops(display);</a>
<a name="ln221">    disp += _get_portals();</a>
<a name="ln222">    disp += _get_notes(display);</a>
<a name="ln223"> </a>
<a name="ln224">    return disp.substr(0, disp.find_last_not_of('\n')+1);</a>
<a name="ln225">}</a>
<a name="ln226"> </a>
<a name="ln227">// iterate through every dungeon branch, listing the ones which have been found</a>
<a name="ln228">static string _get_seen_branches(bool display)</a>
<a name="ln229">{</a>
<a name="ln230">    // Each branch entry takes up 26 spaces + 38 for tags.</a>
<a name="ln231">    const int width = 64;</a>
<a name="ln232"> </a>
<a name="ln233">    int num_printed_branches = 0;</a>
<a name="ln234">    char buffer[100];</a>
<a name="ln235">    string disp;</a>
<a name="ln236"> </a>
<a name="ln237">    disp += &quot;\n&lt;green&gt;Branches:&lt;/green&gt;&quot;;</a>
<a name="ln238">    if (display)</a>
<a name="ln239">    {</a>
<a name="ln240">        disp += &quot; (press &lt;white&gt;G&lt;/white&gt; to reach them and &quot;</a>
<a name="ln241">                &quot;&lt;white&gt;?/B&lt;/white&gt; for more information)&quot;;</a>
<a name="ln242">    }</a>
<a name="ln243">    disp += &quot;\n&quot;;</a>
<a name="ln244"> </a>
<a name="ln245">    for (branch_iterator it; it; ++it)</a>
<a name="ln246">    {</a>
<a name="ln247">        const branch_type branch = it-&gt;id;</a>
<a name="ln248"> </a>
<a name="ln249">        if (branch == BRANCH_ZIGGURAT)</a>
<a name="ln250">            continue;</a>
<a name="ln251"> </a>
<a name="ln252">        if (branch == root_branch</a>
<a name="ln253">            || stair_level.count(branch))</a>
<a name="ln254">        {</a>
<a name="ln255">            // having an entry for branch that is an empty set means a branch</a>
<a name="ln256">            // that no longer has any stairs.</a>
<a name="ln257">            level_id lid(branch, 0);</a>
<a name="ln258">            lid = find_deepest_explored(lid);</a>
<a name="ln259"> </a>
<a name="ln260">            string entry_desc;</a>
<a name="ln261">            for (auto lvl : stair_level[branch])</a>
<a name="ln262">                entry_desc += &quot; &quot; + lvl.describe(false, true);</a>
<a name="ln263"> </a>
<a name="ln264">            // &quot;D&quot; is a little too short here.</a>
<a name="ln265">            const char *brname = (branch == BRANCH_DUNGEON</a>
<a name="ln266">                                  ? it-&gt;shortname</a>
<a name="ln267">                                  : it-&gt;abbrevname);</a>
<a name="ln268"> </a>
<a name="ln269">            if (entry_desc.size() == 0 &amp;&amp; branch != BRANCH_DUNGEON</a>
<a name="ln270">                &amp;&amp; you.where_are_you != branch)</a>
<a name="ln271">            {</a>
<a name="ln272">                // previously visited portal branches</a>
<a name="ln273">                snprintf(buffer, sizeof buffer,</a>
<a name="ln274">                    &quot;&lt;yellow&gt;%7s&lt;/yellow&gt; &lt;darkgrey&gt;(visited)&lt;/darkgrey&gt;&quot;,</a>
<a name="ln275">                    brname);</a>
<a name="ln276">            }</a>
<a name="ln277">            else</a>
<a name="ln278">            {</a>
<a name="ln279">                snprintf(buffer, sizeof buffer,</a>
<a name="ln280">                    &quot;&lt;yellow&gt;%*s&lt;/yellow&gt; &lt;darkgrey&gt;(%d/%d)&lt;/darkgrey&gt;%s&quot;,</a>
<a name="ln281">                    branch == root_branch ? -7 : 7,</a>
<a name="ln282">                    brname, lid.depth, brdepth[branch], entry_desc.c_str());</a>
<a name="ln283">            }</a>
<a name="ln284"> </a>
<a name="ln285">            disp += buffer;</a>
<a name="ln286">            num_printed_branches++;</a>
<a name="ln287"> </a>
<a name="ln288">            disp += (num_printed_branches % 3) == 0</a>
<a name="ln289">                    ? &quot;\n&quot;</a>
<a name="ln290">                    : string(max&lt;int&gt;(width - strlen(buffer), 0), ' ');</a>
<a name="ln291">        }</a>
<a name="ln292">    }</a>
<a name="ln293"> </a>
<a name="ln294">    if (num_printed_branches % 3 != 0)</a>
<a name="ln295">        disp += &quot;\n&quot;;</a>
<a name="ln296">    return disp;</a>
<a name="ln297">}</a>
<a name="ln298"> </a>
<a name="ln299">static string _get_unseen_branches()</a>
<a name="ln300">{</a>
<a name="ln301">    int num_printed_branches = 0;</a>
<a name="ln302">    char buffer[100];</a>
<a name="ln303">    string disp;</a>
<a name="ln304"> </a>
<a name="ln305">    for (branch_iterator it; it; ++it)</a>
<a name="ln306">    {</a>
<a name="ln307">        if (it-&gt;id &lt; BRANCH_FIRST_NON_DUNGEON)</a>
<a name="ln308">            continue;</a>
<a name="ln309"> </a>
<a name="ln310">        const branch_type branch = it-&gt;id;</a>
<a name="ln311">        if (!connected_branch_can_exist(branch))</a>
<a name="ln312">            continue;</a>
<a name="ln313"> </a>
<a name="ln314">        if (branch == BRANCH_VESTIBULE || !is_connected_branch(branch))</a>
<a name="ln315">            continue;</a>
<a name="ln316"> </a>
<a name="ln317">        if (branch_is_unfinished(branch))</a>
<a name="ln318">            continue;</a>
<a name="ln319"> </a>
<a name="ln320">        if (!stair_level.count(branch))</a>
<a name="ln321">        {</a>
<a name="ln322">            const branch_type parent = it-&gt;parent_branch;</a>
<a name="ln323">            // Root branches.</a>
<a name="ln324">            if (parent == NUM_BRANCHES)</a>
<a name="ln325">                continue;</a>
<a name="ln326">            level_id lid(parent, 0);</a>
<a name="ln327">            lid = find_deepest_explored(lid);</a>
<a name="ln328">            if (lid.depth &gt;= it-&gt;mindepth)</a>
<a name="ln329">            {</a>
<a name="ln330">                if (it-&gt;mindepth != it-&gt;maxdepth)</a>
<a name="ln331">                {</a>
<a name="ln332">                    snprintf(buffer, sizeof buffer,</a>
<a name="ln333">                        &quot;&lt;darkgrey&gt;%6s: %s:%d-%d&lt;/darkgrey&gt;&quot;,</a>
<a name="ln334">                            it-&gt;abbrevname,</a>
<a name="ln335">                            branches[parent].abbrevname,</a>
<a name="ln336">                            it-&gt;mindepth,</a>
<a name="ln337">                            it-&gt;maxdepth);</a>
<a name="ln338">                }</a>
<a name="ln339">                else</a>
<a name="ln340">                {</a>
<a name="ln341">                    snprintf(buffer, sizeof buffer,</a>
<a name="ln342">                        &quot;&lt;darkgrey&gt;%6s: %s:%d&lt;/darkgrey&gt;&quot;,</a>
<a name="ln343">                            it-&gt;abbrevname,</a>
<a name="ln344">                            branches[parent].abbrevname,</a>
<a name="ln345">                            it-&gt;mindepth);</a>
<a name="ln346">                }</a>
<a name="ln347"> </a>
<a name="ln348">                disp += buffer;</a>
<a name="ln349">                num_printed_branches++;</a>
<a name="ln350"> </a>
<a name="ln351">                disp += (num_printed_branches % 4) == 0</a>
<a name="ln352">                        ? &quot;\n&quot;</a>
<a name="ln353">                        // Each branch entry takes up 20 spaces</a>
<a name="ln354">                        : string(20 + 21 - strlen(buffer), ' ');</a>
<a name="ln355">            }</a>
<a name="ln356">        }</a>
<a name="ln357">    }</a>
<a name="ln358"> </a>
<a name="ln359">    if (num_printed_branches % 4 != 0)</a>
<a name="ln360">        disp += &quot;\n&quot;;</a>
<a name="ln361">    return disp;</a>
<a name="ln362">}</a>
<a name="ln363"> </a>
<a name="ln364">static string _get_branches(bool display)</a>
<a name="ln365">{</a>
<a name="ln366">    return _get_seen_branches(display) + _get_unseen_branches();</a>
<a name="ln367">}</a>
<a name="ln368"> </a>
<a name="ln369">// iterate through every god and display their altar's discovery state by colour</a>
<a name="ln370">static string _get_altars(bool display)</a>
<a name="ln371">{</a>
<a name="ln372">    // Just wastes space for demigods.</a>
<a name="ln373">    if (you.species == SP_DEMIGOD)</a>
<a name="ln374">        return &quot;&quot;;</a>
<a name="ln375"> </a>
<a name="ln376">    string disp;</a>
<a name="ln377"> </a>
<a name="ln378">    disp += &quot;\n&lt;green&gt;Altars:&lt;/green&gt;&quot;;</a>
<a name="ln379">    if (display)</a>
<a name="ln380">    {</a>
<a name="ln381">        disp += &quot; (press &lt;white&gt;_&lt;/white&gt; to reach them and &quot;</a>
<a name="ln382">                &quot;&lt;white&gt;?/G&lt;/white&gt; for information about gods)&quot;;</a>
<a name="ln383">    }</a>
<a name="ln384">    disp += &quot;\n&quot;;</a>
<a name="ln385">    disp += _print_altars_for_gods(temple_god_list(), true, display);</a>
<a name="ln386">    disp += _print_altars_for_gods(nontemple_god_list(), false, display);</a>
<a name="ln387"> </a>
<a name="ln388">    return disp;</a>
<a name="ln389">}</a>
<a name="ln390"> </a>
<a name="ln391">// Loops through gods, printing their altar status by colour.</a>
<a name="ln392">static string _print_altars_for_gods(const vector&lt;god_type&gt;&amp; gods,</a>
<a name="ln393">                                     bool print_unseen, bool display)</a>
<a name="ln394">{</a>
<a name="ln395">    string disp;</a>
<a name="ln396">    char buffer[100];</a>
<a name="ln397">    int num_printed = 0;</a>
<a name="ln398">    char const *colour;</a>
<a name="ln399">    const int columns = 4;</a>
<a name="ln400"> </a>
<a name="ln401">    for (const god_type god : gods)</a>
<a name="ln402">    {</a>
<a name="ln403">        // for each god, look through the notable altars list for a match</a>
<a name="ln404">        bool has_altar_been_seen = false;</a>
<a name="ln405">        for (const auto &amp;entry : altars_present)</a>
<a name="ln406">        {</a>
<a name="ln407">            if (entry.second == god)</a>
<a name="ln408">            {</a>
<a name="ln409">                has_altar_been_seen = true;</a>
<a name="ln410">                break;</a>
<a name="ln411">            }</a>
<a name="ln412">        }</a>
<a name="ln413"> </a>
<a name="ln414">        // If dumping, only laundry list the seen gods</a>
<a name="ln415">        if (!display)</a>
<a name="ln416">        {</a>
<a name="ln417">            if (has_altar_been_seen)</a>
<a name="ln418">                disp += uppercase_first(god_name(god, false)) + &quot;\n&quot;;</a>
<a name="ln419">            continue;</a>
<a name="ln420">        }</a>
<a name="ln421"> </a>
<a name="ln422">        colour = &quot;darkgrey&quot;;</a>
<a name="ln423">        if (has_altar_been_seen)</a>
<a name="ln424">            colour = &quot;white&quot;;</a>
<a name="ln425">        // Good gods don't inflict penance unless they hate your god.</a>
<a name="ln426">        if (player_under_penance(god)</a>
<a name="ln427">            &amp;&amp; (xp_penance(god) || active_penance(god)))</a>
<a name="ln428">        {</a>
<a name="ln429">            colour = (you.penance[god] &gt; 10) ? &quot;red&quot; : &quot;lightred&quot;;</a>
<a name="ln430">        }</a>
<a name="ln431">        // Indicate good gods that you've abandoned, though.</a>
<a name="ln432">        else if (player_under_penance(god))</a>
<a name="ln433">            colour = &quot;magenta&quot;;</a>
<a name="ln434">        else if (you_worship(god))</a>
<a name="ln435">            colour = &quot;yellow&quot;;</a>
<a name="ln436">        else if (god_likes_your_god(god) &amp;&amp; has_altar_been_seen)</a>
<a name="ln437">            colour = &quot;brown&quot;;</a>
<a name="ln438"> </a>
<a name="ln439">        if (!print_unseen &amp;&amp; !strcmp(colour, &quot;darkgrey&quot;))</a>
<a name="ln440">            continue;</a>
<a name="ln441"> </a>
<a name="ln442">        if (is_unavailable_god(god))</a>
<a name="ln443">            colour = &quot;darkgrey&quot;;</a>
<a name="ln444"> </a>
<a name="ln445">        string disp_name = uppercase_first(god_name(god, false));</a>
<a name="ln446">        if (god == GOD_GOZAG &amp;&amp; !you_worship(GOD_GOZAG))</a>
<a name="ln447">            disp_name += make_stringf(&quot; ($%d)&quot;, gozag_service_fee());</a>
<a name="ln448"> </a>
<a name="ln449">        snprintf(buffer, sizeof buffer, &quot;&lt;%s&gt;%s&lt;/%s&gt;&quot;,</a>
<a name="ln450">                 colour, disp_name.c_str(), colour);</a>
<a name="ln451">        disp += buffer;</a>
<a name="ln452">        num_printed++;</a>
<a name="ln453"> </a>
<a name="ln454">        if (num_printed % columns == 0)</a>
<a name="ln455">            disp += &quot;\n&quot;;</a>
<a name="ln456">        else</a>
<a name="ln457">            // manually aligning the god columns: ten spaces between columns</a>
<a name="ln458">            switch (num_printed % columns)</a>
<a name="ln459">            {</a>
<a name="ln460">            case 1: disp += string(19 - strwidth(disp_name), ' ');</a>
<a name="ln461">                    break;</a>
<a name="ln462">            case 2: disp += string(23 - strwidth(disp_name), ' ');</a>
<a name="ln463">                    break;</a>
<a name="ln464">            case 3: disp += string(20 - strwidth(disp_name), ' ');</a>
<a name="ln465">                    break;</a>
<a name="ln466">            }</a>
<a name="ln467">    }</a>
<a name="ln468"> </a>
<a name="ln469">    if (num_printed &gt; 0 &amp;&amp; num_printed % columns != 0)</a>
<a name="ln470">        disp += &quot;\n&quot;;</a>
<a name="ln471">    return disp;</a>
<a name="ln472">}</a>
<a name="ln473"> </a>
<a name="ln474">// iterate through all discovered shops, printing what level they are on.</a>
<a name="ln475">static string _get_shops(bool display)</a>
<a name="ln476">{</a>
<a name="ln477">    string disp;</a>
<a name="ln478">    level_id last_id;</a>
<a name="ln479"> </a>
<a name="ln480">    if (!shops_present.empty())</a>
<a name="ln481">    {</a>
<a name="ln482">        disp +=&quot;\n&lt;green&gt;Shops:&lt;/green&gt;&quot;;</a>
<a name="ln483">        if (display)</a>
<a name="ln484">            disp += &quot; (press &lt;white&gt;$&lt;/white&gt; to reach them - yellow denotes antique shop)&quot;;</a>
<a name="ln485">        disp += &quot;\n&quot;;</a>
<a name="ln486">    }</a>
<a name="ln487">    last_id.depth = 10000;</a>
<a name="ln488"> </a>
<a name="ln489">    // There are at most 5 shops per level, plus up to 8 chars for the</a>
<a name="ln490">    // level name, plus 4 for the spacing (3 as padding + 1 separating</a>
<a name="ln491">    // items from level). That makes a total of 17 characters per shop:</a>
<a name="ln492">    //       1...5....0....5..</a>
<a name="ln493">    // &quot;D:8 *   Vaults:2 **([+   D:24 +&quot;;</a>
<a name="ln494">    const int maxcolumn = 79 - 17;</a>
<a name="ln495">    int column_count = 0;</a>
<a name="ln496"> </a>
<a name="ln497">    for (const auto &amp;entry : shops_present)</a>
<a name="ln498">    {</a>
<a name="ln499">        if (entry.first.id != last_id)</a>
<a name="ln500">        {</a>
<a name="ln501">            const bool existing = you.level_visited(entry.first.id);</a>
<a name="ln502">            if (column_count &gt; maxcolumn)</a>
<a name="ln503">            {</a>
<a name="ln504">                disp += &quot;\n&quot;;</a>
<a name="ln505">                column_count = 0;</a>
<a name="ln506">            }</a>
<a name="ln507">            else if (column_count != 0)</a>
<a name="ln508">            {</a>
<a name="ln509">                disp += &quot;   &quot;;</a>
<a name="ln510">                column_count += 3;</a>
<a name="ln511">            }</a>
<a name="ln512">            disp += existing ? &quot;&lt;lightgrey&gt;&quot; : &quot;&lt;darkgrey&gt;&quot;;</a>
<a name="ln513"> </a>
<a name="ln514">            const string loc = entry.first.id.describe(false, true);</a>
<a name="ln515">            disp += loc;</a>
<a name="ln516">            column_count += strwidth(loc);</a>
<a name="ln517"> </a>
<a name="ln518">            disp += &quot; &quot;;</a>
<a name="ln519">            disp += existing ? &quot;&lt;/lightgrey&gt;&quot; : &quot;&lt;/darkgrey&gt;&quot;;</a>
<a name="ln520">            column_count += 1;</a>
<a name="ln521"> </a>
<a name="ln522">            last_id = entry.first.id;</a>
<a name="ln523">        }</a>
<a name="ln524">        disp += shoptype_to_string(entry.second);</a>
<a name="ln525">        ++column_count;</a>
<a name="ln526">    }</a>
<a name="ln527"> </a>
<a name="ln528">    if (!shops_present.empty())</a>
<a name="ln529">        disp += &quot;\n&quot;;</a>
<a name="ln530"> </a>
<a name="ln531">    return disp;</a>
<a name="ln532">}</a>
<a name="ln533"> </a>
<a name="ln534">// Loop through found portals and display them</a>
<a name="ln535">static string _get_portals()</a>
<a name="ln536">{</a>
<a name="ln537">    string disp;</a>
<a name="ln538"> </a>
<a name="ln539">    if (!portals_present.empty())</a>
<a name="ln540">        disp += &quot;\n&lt;green&gt;Portals:&lt;/green&gt;\n&quot;;</a>
<a name="ln541">    disp += _portals_description_string();</a>
<a name="ln542"> </a>
<a name="ln543">    return disp;</a>
<a name="ln544">}</a>
<a name="ln545"> </a>
<a name="ln546">// Loop through each branch, printing stored notes.</a>
<a name="ln547">static string _get_notes(bool display)</a>
<a name="ln548">{</a>
<a name="ln549">    string disp;</a>
<a name="ln550"> </a>
<a name="ln551">    for (branch_iterator it; it; ++it)</a>
<a name="ln552">        for (int d = 1; d &lt;= brdepth[it-&gt;id]; ++d)</a>
<a name="ln553">        {</a>
<a name="ln554">            level_id i(it-&gt;id, d);</a>
<a name="ln555">            if (!get_level_annotation(i).empty())</a>
<a name="ln556">                disp += _get_coloured_level_annotation(i) + &quot;\n&quot;;</a>
<a name="ln557">        }</a>
<a name="ln558"> </a>
<a name="ln559">    if (disp.empty())</a>
<a name="ln560">        return disp;</a>
<a name="ln561"> </a>
<a name="ln562">    if (display)</a>
<a name="ln563">        return &quot;\n&lt;green&gt;Annotations:&lt;/green&gt; (press &lt;white&gt;!&lt;/white&gt; to annotate current level)\n&quot; + disp;</a>
<a name="ln564">    return &quot;\n&lt;green&gt;Annotations:&lt;/green&gt;\n&quot; + disp;</a>
<a name="ln565">}</a>
<a name="ln566"> </a>
<a name="ln567">template &lt;typename Z, typename Key&gt;</a>
<a name="ln568">static inline bool _find_erase(Z &amp;map, const Key &amp;k)</a>
<a name="ln569">{</a>
<a name="ln570">    if (map.count(k))</a>
<a name="ln571">    {</a>
<a name="ln572">        map.erase(k);</a>
<a name="ln573">        return true;</a>
<a name="ln574">    }</a>
<a name="ln575">    return false;</a>
<a name="ln576">}</a>
<a name="ln577"> </a>
<a name="ln578">static bool _unnotice_portal(const level_pos &amp;pos)</a>
<a name="ln579">{</a>
<a name="ln580">    (void) _find_erase(portal_notes, pos);</a>
<a name="ln581">    return _find_erase(portals_present, pos);</a>
<a name="ln582">}</a>
<a name="ln583"> </a>
<a name="ln584">static bool _unnotice_altar(const level_pos &amp;pos)</a>
<a name="ln585">{</a>
<a name="ln586">    return _find_erase(altars_present, pos);</a>
<a name="ln587">}</a>
<a name="ln588"> </a>
<a name="ln589">static bool _unnotice_shop(const level_pos &amp;pos)</a>
<a name="ln590">{</a>
<a name="ln591">    return _find_erase(shops_present, pos);</a>
<a name="ln592">}</a>
<a name="ln593"> </a>
<a name="ln594">static bool _unnotice_stair(const level_pos &amp;pos)</a>
<a name="ln595">{</a>
<a name="ln596">    const dungeon_feature_type feat = grd(pos.pos);</a>
<a name="ln597">    if (!feat_is_branch_entrance(feat))</a>
<a name="ln598">        return false;</a>
<a name="ln599"> </a>
<a name="ln600">    for (branch_iterator it; it; ++it)</a>
<a name="ln601">        if (it-&gt;entry_stairs == feat)</a>
<a name="ln602">        {</a>
<a name="ln603">            const branch_type br = it-&gt;id;</a>
<a name="ln604">            if (stair_level.count(br))</a>
<a name="ln605">            {</a>
<a name="ln606">                stair_level[br].erase(level_id::current());</a>
<a name="ln607">                if (stair_level[br].empty())</a>
<a name="ln608">                    stair_level.erase(br);</a>
<a name="ln609">                return true;</a>
<a name="ln610">            }</a>
<a name="ln611">        }</a>
<a name="ln612"> </a>
<a name="ln613">    return false;</a>
<a name="ln614">}</a>
<a name="ln615"> </a>
<a name="ln616">bool unnotice_feature(const level_pos &amp;pos)</a>
<a name="ln617">{</a>
<a name="ln618">    StashTrack.remove_shop(pos);</a>
<a name="ln619">    shopping_list.forget_pos(pos);</a>
<a name="ln620">    return _unnotice_portal(pos)</a>
<a name="ln621">        || _unnotice_altar(pos)</a>
<a name="ln622">        || _unnotice_shop(pos)</a>
<a name="ln623">        || _unnotice_stair(pos);</a>
<a name="ln624">}</a>
<a name="ln625"> </a>
<a name="ln626">class dgn_overview : public formatted_scroller</a>
<a name="ln627">{</a>
<a name="ln628">public:</a>
<a name="ln629">    dgn_overview(const string&amp; text = &quot;&quot;) : formatted_scroller(FS_PREWRAPPED_TEXT, text) {};</a>
<a name="ln630"> </a>
<a name="ln631">private:</a>
<a name="ln632">    bool process_key(int ch) override</a>
<a name="ln633">    {</a>
<a name="ln634">        // We handle these after exiting dungeon overview window</a>
<a name="ln635">        // to prevent menus from stacking on top of each other.</a>
<a name="ln636">        if (ch == 'G' || ch == '_' || ch == '$' || ch =='!')</a>
<a name="ln637">            return false;</a>
<a name="ln638">        else</a>
<a name="ln639">            return formatted_scroller::process_key(ch);</a>
<a name="ln640">    }</a>
<a name="ln641">};</a>
<a name="ln642"> </a>
<a name="ln643">void display_overview()</a>
<a name="ln644">{</a>
<a name="ln645">    string disp = overview_description_string(true);</a>
<a name="ln646">    linebreak_string(disp, 80);</a>
<a name="ln647">    dgn_overview overview(disp);</a>
<a name="ln648">    _process_command(overview.show());</a>
<a name="ln649">}</a>
<a name="ln650"> </a>
<a name="ln651">static void _process_command(const char keypress)</a>
<a name="ln652">{</a>
<a name="ln653">    switch (keypress)</a>
<a name="ln654">    {</a>
<a name="ln655">        case 'G':</a>
<a name="ln656">            do_interlevel_travel();</a>
<a name="ln657">            return;</a>
<a name="ln658">        case '_':</a>
<a name="ln659">            if (!altars_present.empty())</a>
<a name="ln660">            {</a>
<a name="ln661">                macro_sendkeys_end_add_expanded('_');</a>
<a name="ln662">                do_interlevel_travel();</a>
<a name="ln663">            }</a>
<a name="ln664">            else</a>
<a name="ln665">                mpr(&quot;Sorry, you haven't seen any altar yet.&quot;);</a>
<a name="ln666">            return;</a>
<a name="ln667">        case '$':</a>
<a name="ln668">            if (!shops_present.empty())</a>
<a name="ln669">                StashTrack.search_stashes(&quot;shop&quot;);</a>
<a name="ln670">            else</a>
<a name="ln671">                mpr(&quot;Sorry, you haven't seen any shop yet.&quot;);</a>
<a name="ln672">            return;</a>
<a name="ln673">        case '!':</a>
<a name="ln674">            annotate_level();</a>
<a name="ln675">            return;</a>
<a name="ln676">        default:</a>
<a name="ln677">            return;</a>
<a name="ln678">    }</a>
<a name="ln679">}</a>
<a name="ln680"> </a>
<a name="ln681">static void _seen_staircase(const coord_def&amp; pos)</a>
<a name="ln682">{</a>
<a name="ln683">    // Only handles stairs, not gates or arches</a>
<a name="ln684">    // Don't worry about:</a>
<a name="ln685">    //   - stairs returning to dungeon - predictable</a>
<a name="ln686">    //   - entrances to the hells - always in vestibule</a>
<a name="ln687"> </a>
<a name="ln688">    // If the branch has already been entered, then the new entry is obviously</a>
<a name="ln689">    // a mimic, don't add it.</a>
<a name="ln690">    const branch_type branch = get_branch_at(pos);</a>
<a name="ln691">    if (!branch_entered(branch))</a>
<a name="ln692">        stair_level[branch].insert(level_id::current());</a>
<a name="ln693">}</a>
<a name="ln694"> </a>
<a name="ln695">// If player has seen an altar; record it.</a>
<a name="ln696">static void _seen_altar(god_type god, const coord_def&amp; pos)</a>
<a name="ln697">{</a>
<a name="ln698">    // Can't record in Abyss or Pan.</a>
<a name="ln699">    if (!player_in_connected_branch())</a>
<a name="ln700">        return;</a>
<a name="ln701"> </a>
<a name="ln702">    level_pos where(level_id::current(), pos);</a>
<a name="ln703">    altars_present[where] = god;</a>
<a name="ln704">}</a>
<a name="ln705"> </a>
<a name="ln706">static void _seen_shop(const coord_def&amp; pos)</a>
<a name="ln707">{</a>
<a name="ln708">    shops_present[level_pos(level_id::current(), pos)] = shop_at(pos)-&gt;type;</a>
<a name="ln709">}</a>
<a name="ln710"> </a>
<a name="ln711">static void _seen_portal(dungeon_feature_type which_thing, const coord_def&amp; pos)</a>
<a name="ln712">{</a>
<a name="ln713">    if (feat_is_portal_entrance(which_thing)</a>
<a name="ln714">        || which_thing == DNGN_ENTER_ABYSS</a>
<a name="ln715">        || which_thing == DNGN_ENTER_PANDEMONIUM</a>
<a name="ln716">        || which_thing == DNGN_ENTER_HELL &amp;&amp; !player_in_hell())</a>
<a name="ln717">    {</a>
<a name="ln718">        level_pos where(level_id::current(), pos);</a>
<a name="ln719">        portals_present[where] = stair_destination(pos).branch;</a>
<a name="ln720">        portal_notes[where] =</a>
<a name="ln721">            env.markers.property_at(pos, MAT_ANY, &quot;overview_note&quot;);</a>
<a name="ln722">    }</a>
<a name="ln723">}</a>
<a name="ln724"> </a>
<a name="ln725">#define SEEN_RUNED_DOOR_KEY &quot;num_runed_doors&quot;</a>
<a name="ln726">#define SEEN_TRANSPORTER_KEY &quot;num_transporters&quot;</a>
<a name="ln727"> </a>
<a name="ln728">// Get the env prop key we use to track discoveries of this feature.</a>
<a name="ln729">static const char *_get_tracked_feature_key(dungeon_feature_type feat)</a>
<a name="ln730">{</a>
<a name="ln731">    switch (feat)</a>
<a name="ln732">    {</a>
<a name="ln733">        case DNGN_RUNED_DOOR:</a>
<a name="ln734">        case DNGN_RUNED_CLEAR_DOOR:</a>
<a name="ln735">            return SEEN_RUNED_DOOR_KEY;</a>
<a name="ln736">            break;</a>
<a name="ln737">        case DNGN_TRANSPORTER:</a>
<a name="ln738">            return SEEN_TRANSPORTER_KEY;</a>
<a name="ln739">            break;</a>
<a name="ln740">        default:</a>
<a name="ln741">            die(&quot;Unknown tracked feature: %s&quot;, get_feature_def(feat).name);</a>
<a name="ln742">            return nullptr;</a>
<a name="ln743">    }</a>
<a name="ln744">}</a>
<a name="ln745"> </a>
<a name="ln746">/**</a>
<a name="ln747"> * Update the level annotations for a feature we track in travel cache.</a>
<a name="ln748"> *</a>
<a name="ln749"> * @param feat       The type of feature we're updating.</a>
<a name="ln750"> * @param old_num    The previous count of the feature, so we can determine</a>
<a name="ln751"> *                   whether we need to remove the annotation entirely.</a>
<a name="ln752"> **/</a>
<a name="ln753">static void _update_tracked_feature_annot(dungeon_feature_type feat,</a>
<a name="ln754">                                          int old_num)</a>
<a name="ln755">{</a>
<a name="ln756">    const level_id li = level_id::current();</a>
<a name="ln757">    const char *feat_key = _get_tracked_feature_key(feat);</a>
<a name="ln758">    const int new_num = env.properties[feat_key];</a>
<a name="ln759">    const char *feat_desc = get_feature_def(feat).name;</a>
<a name="ln760">    const string new_string = make_stringf(&quot;%d %s%s&quot;, new_num, feat_desc,</a>
<a name="ln761">                                           new_num == 1 ? &quot;&quot; : &quot;s&quot;);</a>
<a name="ln762">    const string old_string = make_stringf(&quot;%d %s%s&quot;, old_num, feat_desc,</a>
<a name="ln763">                                           old_num == 1 ? &quot;&quot; : &quot;s&quot;);</a>
<a name="ln764"> </a>
<a name="ln765">    //TODO: regexes</a>
<a name="ln766">    if (old_num &gt; 0 &amp;&amp; new_num &gt; 0)</a>
<a name="ln767">    {</a>
<a name="ln768">       level_annotations[li] = replace_all(level_annotations[li],</a>
<a name="ln769">                                           old_string, new_string);</a>
<a name="ln770">    }</a>
<a name="ln771">    else if (old_num == 0)</a>
<a name="ln772">    {</a>
<a name="ln773">        if (!level_annotations[li].empty())</a>
<a name="ln774">            level_annotations[li] += &quot;, &quot;;</a>
<a name="ln775">        level_annotations[li] += new_string;</a>
<a name="ln776">    }</a>
<a name="ln777">    else if (new_num == 0)</a>
<a name="ln778">    {</a>
<a name="ln779">        level_annotations[li] = replace_all(level_annotations[li],</a>
<a name="ln780">                                            &quot;, &quot; + old_string, &quot;&quot;);</a>
<a name="ln781">        level_annotations[li] = replace_all(level_annotations[li],</a>
<a name="ln782">                                            old_string, &quot;&quot;);</a>
<a name="ln783">    }</a>
<a name="ln784">}</a>
<a name="ln785"> </a>
<a name="ln786">/**</a>
<a name="ln787"> * Update the count for a newly discovered feature whose discovery/exploration</a>
<a name="ln788"> * we track for travel cache purposes.</a>
<a name="ln789"> *</a>
<a name="ln790"> * @param feat    The type of feature we've just seen.</a>
<a name="ln791"> **/</a>
<a name="ln792">void seen_tracked_feature(dungeon_feature_type feat)</a>
<a name="ln793">{</a>
<a name="ln794">    const char *feat_key = _get_tracked_feature_key(feat);</a>
<a name="ln795"> </a>
<a name="ln796">    if (!env.properties.exists(feat_key))</a>
<a name="ln797">        env.properties[feat_key] = 0;</a>
<a name="ln798"> </a>
<a name="ln799">    _update_tracked_feature_annot(feat, env.properties[feat_key].get_int()++);</a>
<a name="ln800">}</a>
<a name="ln801"> </a>
<a name="ln802">/**</a>
<a name="ln803"> * Update the count for an explored feature whose discovery/exploration we track</a>
<a name="ln804"> * for travel cache purposes.</a>
<a name="ln805"> *</a>
<a name="ln806"> * @param feat    The type of feature we've just explored.</a>
<a name="ln807"> **/</a>
<a name="ln808">void explored_tracked_feature(dungeon_feature_type feat)</a>
<a name="ln809">{</a>
<a name="ln810">    const char *feat_key = _get_tracked_feature_key(feat);</a>
<a name="ln811">#if TAG_MAJOR_VERSION &gt; 34</a>
<a name="ln812">    ASSERT(env.properties.exists(feat_key));</a>
<a name="ln813">#endif</a>
<a name="ln814"> </a>
<a name="ln815">    // Opening a runed door we haven't seen (because of door_vault, probably).</a>
<a name="ln816">    if (env.properties[feat_key].get_int() == 0)</a>
<a name="ln817">        return;</a>
<a name="ln818"> </a>
<a name="ln819">    _update_tracked_feature_annot(feat, env.properties[feat_key].get_int()--);</a>
<a name="ln820">}</a>
<a name="ln821"> </a>
<a name="ln822">void enter_branch(branch_type branch, level_id from)</a>
<a name="ln823">{</a>
<a name="ln824">    // this will ensure that branch is in stair_level either way</a>
<a name="ln825">    // TODO: track stair levels for portal branches somehow?</a>
<a name="ln826">    if (stair_level[branch].size() &gt; 1)</a>
<a name="ln827">    {</a>
<a name="ln828">        stair_level[branch].clear();</a>
<a name="ln829">        stair_level[branch].insert(from);</a>
<a name="ln830">    }</a>
<a name="ln831">}</a>
<a name="ln832"> </a>
<a name="ln833">// Add an annotation on a level if we corrupt with Lugonu's ability</a>
<a name="ln834">void mark_corrupted_level(level_id li)</a>
<a name="ln835">{</a>
<a name="ln836">    if (!level_annotations[li].empty())</a>
<a name="ln837">        level_annotations[li] += &quot;, &quot;;</a>
<a name="ln838">    level_annotations[li] += &quot;corrupted&quot;;</a>
<a name="ln839">}</a>
<a name="ln840"> </a>
<a name="ln841">////////////////////////////////////////////////////////////////////////</a>
<a name="ln842"> </a>
<a name="ln843">static void _update_unique_annotation(level_id level)</a>
<a name="ln844">{</a>
<a name="ln845">    string note = &quot;&quot;;</a>
<a name="ln846">    string sep = &quot;, &quot;;</a>
<a name="ln847"> </a>
<a name="ln848">    for (const auto &amp;annot : auto_unique_annotations)</a>
<a name="ln849">        if (annot.first.find(',') != string::npos)</a>
<a name="ln850">            sep = &quot;; &quot;;</a>
<a name="ln851"> </a>
<a name="ln852">    for (const auto &amp;annot : auto_unique_annotations)</a>
<a name="ln853">    {</a>
<a name="ln854">        if (annot.second == level)</a>
<a name="ln855">        {</a>
<a name="ln856">            if (note.length() &gt; 0)</a>
<a name="ln857">                note += sep;</a>
<a name="ln858">            note += annot.first;</a>
<a name="ln859">        }</a>
<a name="ln860">    }</a>
<a name="ln861">    if (note.empty())</a>
<a name="ln862">        level_uniques.erase(level);</a>
<a name="ln863">    else</a>
<a name="ln864">        level_uniques[level] = note;</a>
<a name="ln865">}</a>
<a name="ln866"> </a>
<a name="ln867">static string unique_name(monster* mons)</a>
<a name="ln868">{</a>
<a name="ln869">    string name = mons-&gt;name(DESC_PLAIN, true);</a>
<a name="ln870">    if (mons-&gt;type == MONS_PLAYER_GHOST)</a>
<a name="ln871">        name += &quot;, &quot; + short_ghost_description(mons, true);</a>
<a name="ln872">    else</a>
<a name="ln873">    {</a>
<a name="ln874">        if (strstr(name.c_str(), &quot;Royal Jelly&quot;))</a>
<a name="ln875">            name = &quot;Royal Jelly&quot;;</a>
<a name="ln876">        if (strstr(name.c_str(), &quot;Lernaean hydra&quot;))</a>
<a name="ln877">            name = &quot;Lernaean hydra&quot;;</a>
<a name="ln878">        if (strstr(name.c_str(), &quot;Serpent of Hell&quot;))</a>
<a name="ln879">            name = &quot;Serpent of Hell&quot;;</a>
<a name="ln880">        if (strstr(name.c_str(), &quot;Blork&quot;))</a>
<a name="ln881">            name = &quot;Blork the orc&quot;;</a>
<a name="ln882">    }</a>
<a name="ln883">    return name;</a>
<a name="ln884">}</a>
<a name="ln885"> </a>
<a name="ln886">void set_unique_annotation(monster* mons, const level_id level)</a>
<a name="ln887">{</a>
<a name="ln888">    if (!mons_is_or_was_unique(*mons)</a>
<a name="ln889">        &amp;&amp; mons-&gt;type != MONS_PLAYER_GHOST</a>
<a name="ln890">        || testbits(mons-&gt;flags, MF_SPECTRALISED)</a>
<a name="ln891">        || mons-&gt;is_illusion()</a>
<a name="ln892">        || mons-&gt;props.exists(&quot;no_annotate&quot;)</a>
<a name="ln893">            &amp;&amp; mons-&gt;props[&quot;no_annotate&quot;].get_bool())</a>
<a name="ln894"> </a>
<a name="ln895">    {</a>
<a name="ln896">        return;</a>
<a name="ln897">    }</a>
<a name="ln898"> </a>
<a name="ln899">    remove_unique_annotation(mons);</a>
<a name="ln900">    auto_unique_annotations.insert(make_pair(unique_name(mons), level));</a>
<a name="ln901">    _update_unique_annotation(level);</a>
<a name="ln902">}</a>
<a name="ln903"> </a>
<a name="ln904">void remove_unique_annotation(monster* mons)</a>
<a name="ln905">{</a>
<a name="ln906">    if (mons-&gt;is_illusion()) // Fake monsters don't clear real annotations</a>
<a name="ln907">        return;</a>
<a name="ln908">    set&lt;level_id&gt; affected_levels;</a>
<a name="ln909">    string name = unique_name(mons);</a>
<a name="ln910">    for (auto i = auto_unique_annotations.begin();</a>
<a name="ln911">         i != auto_unique_annotations.end();)</a>
<a name="ln912">    {</a>
<a name="ln913">        // Only remove player ghosts from the current level or that you can see</a>
<a name="ln914">        // (e.g. following you on stairs): there may be a different ghost with</a>
<a name="ln915">        // the same unique_name elsewhere.</a>
<a name="ln916">        if ((mons-&gt;type != MONS_PLAYER_GHOST</a>
<a name="ln917">             || i-&gt;second == level_id::current()</a>
<a name="ln918">             || you.can_see(*mons) &amp;&amp; testbits(mons-&gt;flags, MF_TAKING_STAIRS))</a>
<a name="ln919">            &amp;&amp; i-&gt;first == name)</a>
<a name="ln920">        {</a>
<a name="ln921">            affected_levels.insert(i-&gt;second);</a>
<a name="ln922">            auto_unique_annotations.erase(i++);</a>
<a name="ln923">        }</a>
<a name="ln924">        else</a>
<a name="ln925">            ++i;</a>
<a name="ln926">    }</a>
<a name="ln927"> </a>
<a name="ln928">    for (auto lvl : affected_levels)</a>
<a name="ln929">        _update_unique_annotation(lvl);</a>
<a name="ln930">}</a>
<a name="ln931"> </a>
<a name="ln932">void set_level_exclusion_annotation(string str, level_id li)</a>
<a name="ln933">{</a>
<a name="ln934">    if (str.empty())</a>
<a name="ln935">    {</a>
<a name="ln936">        clear_level_exclusion_annotation(li);</a>
<a name="ln937">        return;</a>
<a name="ln938">    }</a>
<a name="ln939"> </a>
<a name="ln940">    level_exclusions[li] = str;</a>
<a name="ln941">}</a>
<a name="ln942"> </a>
<a name="ln943">void clear_level_exclusion_annotation(level_id li)</a>
<a name="ln944">{</a>
<a name="ln945">    level_exclusions.erase(li);</a>
<a name="ln946">}</a>
<a name="ln947"> </a>
<a name="ln948">string get_level_annotation(level_id li, bool skip_excl, bool skip_uniq,</a>
<a name="ln949">                            bool use_colour, int colour)</a>
<a name="ln950">{</a>
<a name="ln951">    string note = &quot;&quot;;</a>
<a name="ln952"> </a>
<a name="ln953">    if (string *ann = map_find(level_annotations, li))</a>
<a name="ln954">        note += use_colour ? colour_string(*ann, colour) : *ann;</a>
<a name="ln955"> </a>
<a name="ln956">    if (!skip_excl)</a>
<a name="ln957">        if (string *excl = map_find(level_exclusions, li))</a>
<a name="ln958">        {</a>
<a name="ln959">            if (note.length() &gt; 0)</a>
<a name="ln960">                note += &quot;, &quot;;</a>
<a name="ln961">            note += *excl;</a>
<a name="ln962">        }</a>
<a name="ln963"> </a>
<a name="ln964">    if (!skip_uniq)</a>
<a name="ln965">        if (string *uniq = map_find(level_uniques, li))</a>
<a name="ln966">        {</a>
<a name="ln967">            if (note.length() &gt; 0)</a>
<a name="ln968">                note += &quot;, &quot;;</a>
<a name="ln969">            note += *uniq;</a>
<a name="ln970">        }</a>
<a name="ln971"> </a>
<a name="ln972">    return note;</a>
<a name="ln973">}</a>
<a name="ln974"> </a>
<a name="ln975">static const string _get_coloured_level_annotation(level_id li)</a>
<a name="ln976">{</a>
<a name="ln977">    string place = &quot;&lt;yellow&gt;&quot; + li.describe() + &quot;&lt;/yellow&gt;&quot;;</a>
<a name="ln978">    int col = level_annotation_has(&quot;!&quot;, li) ? LIGHTRED : WHITE;</a>
<a name="ln979">    return place + &quot; &quot; + get_level_annotation(li, false, false, true, col);</a>
<a name="ln980">}</a>
<a name="ln981"> </a>
<a name="ln982">bool level_annotation_has(string find, level_id li)</a>
<a name="ln983">{</a>
<a name="ln984">    string str = get_level_annotation(li);</a>
<a name="ln985"> </a>
<a name="ln986">    return str.find(find) != string::npos;</a>
<a name="ln987">}</a>
<a name="ln988"> </a>
<a name="ln989">void annotate_level()</a>
<a name="ln990">{</a>
<a name="ln991">    level_id li  = level_id::current();</a>
<a name="ln992">    level_id li2 = level_id::current();</a>
<a name="ln993"> </a>
<a name="ln994">    if (feat_is_stair(grd(you.pos())))</a>
<a name="ln995">    {</a>
<a name="ln996">        li2 = level_id::get_next_level_id(you.pos());</a>
<a name="ln997"> </a>
<a name="ln998">        if (li2.depth &lt;= 0)</a>
<a name="ln999">            li2 = level_id::current();</a>
<a name="ln1000">    }</a>
<a name="ln1001"> </a>
<a name="ln1002">    if (li2 != level_id::current())</a>
<a name="ln1003">    {</a>
<a name="ln1004">        if (yesno(&quot;Annotate level on other end of current stairs?&quot;, true, 'n'))</a>
<a name="ln1005">            li = li2;</a>
<a name="ln1006">    }</a>
<a name="ln1007"> </a>
<a name="ln1008">    do_annotate(li);</a>
<a name="ln1009">}</a>
<a name="ln1010"> </a>
<a name="ln1011">void do_annotate(level_id&amp; li)</a>
<a name="ln1012">{</a>
<a name="ln1013">    string old = get_level_annotation(li, true, true);</a>
<a name="ln1014">    if (!old.empty())</a>
<a name="ln1015">    {</a>
<a name="ln1016">        mprf(MSGCH_PROMPT, &quot;Current level annotation: &lt;lightgrey&gt;%s&lt;/lightgrey&gt;&quot;,</a>
<a name="ln1017">             old.c_str());</a>
<a name="ln1018">    }</a>
<a name="ln1019"> </a>
<a name="ln1020">    const string prompt = &quot;New annotation for &quot; + li.describe()</a>
<a name="ln1021">                          + &quot; (include '!' for warning): &quot;;</a>
<a name="ln1022"> </a>
<a name="ln1023">    char buf[77];</a>
<a name="ln1024">    if (msgwin_get_line_autohist(prompt, buf, sizeof(buf), old))</a>
<a name="ln1025">        canned_msg(MSG_OK);</a>
<a name="ln1026">    else if (old == buf)</a>
<a name="ln1027">        canned_msg(MSG_OK);</a>
<a name="ln1028">    else if (*buf)</a>
<a name="ln1029">        level_annotations[li] = buf;</a>
<a name="ln1030">    else</a>
<a name="ln1031">    {</a>
<a name="ln1032">        mpr(&quot;Cleared annotation.&quot;);</a>
<a name="ln1033">        level_annotations.erase(li);</a>
<a name="ln1034">    }</a>
<a name="ln1035">}</a>
<a name="ln1036"> </a>
<a name="ln1037">void clear_level_annotations(level_id li)</a>
<a name="ln1038">{</a>
<a name="ln1039">    level_annotations.erase(li);</a>
<a name="ln1040"> </a>
<a name="ln1041">    // Abyss persists its denizens.</a>
<a name="ln1042">    if (li == BRANCH_ABYSS)</a>
<a name="ln1043">        return;</a>
<a name="ln1044"> </a>
<a name="ln1045">    for (auto i = auto_unique_annotations.begin(), next = i;</a>
<a name="ln1046">         i != auto_unique_annotations.end(); i = next)</a>
<a name="ln1047">    {</a>
<a name="ln1048">        next = i;</a>
<a name="ln1049">        ++next;</a>
<a name="ln1050">        if (i-&gt;second == li)</a>
<a name="ln1051">            auto_unique_annotations.erase(i);</a>
<a name="ln1052">    }</a>
<a name="ln1053">    level_uniques.erase(li);</a>
<a name="ln1054">}</a>
<a name="ln1055"> </a>
<a name="ln1056">void marshallUniqueAnnotations(writer&amp; outf)</a>
<a name="ln1057">{</a>
<a name="ln1058">    marshallShort(outf, auto_unique_annotations.size());</a>
<a name="ln1059">    for (const auto &amp;annot : auto_unique_annotations)</a>
<a name="ln1060">    {</a>
<a name="ln1061">        marshallString(outf, annot.first);</a>
<a name="ln1062">        annot.second.save(outf);</a>
<a name="ln1063">    }</a>
<a name="ln1064">}</a>
<a name="ln1065"> </a>
<a name="ln1066">void unmarshallUniqueAnnotations(reader&amp; inf)</a>
<a name="ln1067">{</a>
<a name="ln1068">    auto_unique_annotations.clear();</a>
<a name="ln1069">    int num_notes = unmarshallShort(inf);</a>
<a name="ln1070">    for (int i = 0; i &lt; num_notes; ++i)</a>
<a name="ln1071">    {</a>
<a name="ln1072">        string name = unmarshallString(inf);</a>
<a name="ln1073">        level_id level;</a>
<a name="ln1074">        level.load(inf);</a>
<a name="ln1075">        auto_unique_annotations.insert(make_pair(name, level));</a>
<a name="ln1076">    }</a>
<a name="ln1077">}</a>
<a name="ln1078"> </a>
<a name="ln1079">/**</a>
<a name="ln1080"> * Can the player encounter the given connected branch, given their</a>
<a name="ln1081"> * knowledge of which have been seen so far?</a>
<a name="ln1082"> * @param br A connected branch.</a>
<a name="ln1083"> * @returns True if the branch can exist, false otherwise.</a>
<a name="ln1084">*/</a>
<a name="ln1085">bool connected_branch_can_exist(branch_type br)</a>
<a name="ln1086">{</a>
<a name="ln1087">    if (br == BRANCH_SPIDER &amp;&amp; stair_level.count(BRANCH_SNAKE)</a>
<a name="ln1088">        || br == BRANCH_SNAKE &amp;&amp; stair_level.count(BRANCH_SPIDER)</a>
<a name="ln1089">        || br == BRANCH_SWAMP &amp;&amp; stair_level.count(BRANCH_SHOALS)</a>
<a name="ln1090">        || br == BRANCH_SHOALS &amp;&amp; stair_level.count(BRANCH_SWAMP))</a>
<a name="ln1091">    {</a>
<a name="ln1092">        return false;</a>
<a name="ln1093">    }</a>
<a name="ln1094"> </a>
<a name="ln1095">    return true;</a>
<a name="ln1096">}</a>

</code></pre>
<div class="balloon" rel="716"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v648/" target="_blank">V648</a> Priority of the '&&' operation is higher than that of the '||' operation.</p></div>
<div class="balloon" rel="892"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v648/" target="_blank">V648</a> Priority of the '&&' operation is higher than that of the '||' operation.</p></div>
<div class="balloon" rel="918"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v648/" target="_blank">V648</a> Priority of the '&&' operation is higher than that of the '||' operation.</p></div>

<link rel="stylesheet" href="highlight.css">
<script src="highlight.pack.js"></script>
<script src="highlightjs-line-numbers.js"></script>
<script>hljs.initHighlightingOnLoad();</script>
<script>hljs.initLineNumbersOnLoad();</script>
<script>
  $(document).ready(function() {
      $('.balloon').each(function () {
          var bl = $(this);
          var line = bl.attr('rel');
          var text = $('a[name="ln'+line+'"]').text();

          var space_count = 0;
          for(var i = 0; i<text.length; i++){
              var char = text[i];
              if((char !== ' ')&&(char !== '\t'))break;
              if(char === '\t')space_count++;
              space_count++;
          }

          bl.css('margin-left', space_count*8);
          $('a[name="ln'+line+'"]').after(bl);
      });

      window.location = window.location;
  });
</script>
</body>
</html>
