
<html>
<head>

  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
  <title>initfile.cc</title>

  <link rel="stylesheet" href="../style.css"/>
  <script src="../jquery-3.2.1.min.js"></script>
</head>
<body>

<pre><code class = "cpp">
<a name="ln1">/**</a>
<a name="ln2"> * @file</a>
<a name="ln3"> * @brief Simple reading of an init file and system variables</a>
<a name="ln4"> * @detailed read_init_file is the main function, but read_option_line does</a>
<a name="ln5"> * most of the work though. Read through read_init_file to get an overview of</a>
<a name="ln6"> * how Crawl loads options. This file also contains a large number of utility</a>
<a name="ln7"> * functions for setting particular options and converting between human</a>
<a name="ln8"> * readable strings and internal values. (E.g. str_to_enemy_hp_colour,</a>
<a name="ln9"> * _weapon_to_str). There is also some code dealing with sorting menus.</a>
<a name="ln10">**/</a>
<a name="ln11"> </a>
<a name="ln12">#include &quot;AppHdr.h&quot;</a>
<a name="ln13"> </a>
<a name="ln14">#include &quot;initfile.h&quot;</a>
<a name="ln15"> </a>
<a name="ln16">#include &lt;algorithm&gt;</a>
<a name="ln17">#include &lt;cinttypes&gt;</a>
<a name="ln18">#include &lt;cctype&gt;</a>
<a name="ln19">#include &lt;cstdio&gt;</a>
<a name="ln20">#include &lt;cstdlib&gt;</a>
<a name="ln21">#include &lt;iomanip&gt;</a>
<a name="ln22">#include &lt;set&gt;</a>
<a name="ln23">#include &lt;string&gt;</a>
<a name="ln24"> </a>
<a name="ln25">#include &quot;branch-data-json.h&quot;</a>
<a name="ln26">#include &quot;chardump.h&quot;</a>
<a name="ln27">#include &quot;clua.h&quot;</a>
<a name="ln28">#include &quot;colour.h&quot;</a>
<a name="ln29">#include &quot;confirm-butcher-type.h&quot;</a>
<a name="ln30">#include &quot;defines.h&quot;</a>
<a name="ln31">#include &quot;delay.h&quot;</a>
<a name="ln32">#include &quot;describe.h&quot;</a>
<a name="ln33">#include &quot;directn.h&quot;</a>
<a name="ln34">#include &quot;dlua.h&quot;</a>
<a name="ln35">#include &quot;end.h&quot;</a>
<a name="ln36">#include &quot;errors.h&quot;</a>
<a name="ln37">#include &quot;files.h&quot;</a>
<a name="ln38">#include &quot;game-options.h&quot;</a>
<a name="ln39">#include &quot;ghost.h&quot;</a>
<a name="ln40">#include &quot;invent.h&quot;</a>
<a name="ln41">#include &quot;item-prop.h&quot;</a>
<a name="ln42">#include &quot;items.h&quot;</a>
<a name="ln43">#include &quot;jobs.h&quot;</a>
<a name="ln44">#include &quot;kills.h&quot;</a>
<a name="ln45">#include &quot;libutil.h&quot;</a>
<a name="ln46">#include &quot;macro.h&quot;</a>
<a name="ln47">#include &quot;mapdef.h&quot;</a>
<a name="ln48">#include &quot;message.h&quot;</a>
<a name="ln49">#include &quot;mon-util.h&quot;</a>
<a name="ln50">#include &quot;monster.h&quot;</a>
<a name="ln51">#include &quot;newgame.h&quot;</a>
<a name="ln52">#include &quot;options.h&quot;</a>
<a name="ln53">#include &quot;playable.h&quot;</a>
<a name="ln54">#include &quot;player.h&quot;</a>
<a name="ln55">#include &quot;prompt.h&quot;</a>
<a name="ln56">#include &quot;slot-select-mode.h&quot;</a>
<a name="ln57">#include &quot;species.h&quot;</a>
<a name="ln58">#include &quot;spl-util.h&quot;</a>
<a name="ln59">#include &quot;stash.h&quot;</a>
<a name="ln60">#include &quot;state.h&quot;</a>
<a name="ln61">#include &quot;stringutil.h&quot;</a>
<a name="ln62">#include &quot;syscalls.h&quot;</a>
<a name="ln63">#include &quot;tags.h&quot;</a>
<a name="ln64">#include &quot;throw.h&quot;</a>
<a name="ln65">#include &quot;travel.h&quot;</a>
<a name="ln66">#include &quot;unwind.h&quot;</a>
<a name="ln67">#include &quot;version.h&quot;</a>
<a name="ln68">#include &quot;viewchar.h&quot;</a>
<a name="ln69">#include &quot;view.h&quot;</a>
<a name="ln70">#include &quot;wizard-option-type.h&quot;</a>
<a name="ln71">#ifdef USE_TILE</a>
<a name="ln72">#include &quot;tilepick.h&quot;</a>
<a name="ln73">#include &quot;rltiles/tiledef-player.h&quot;</a>
<a name="ln74">#endif</a>
<a name="ln75">#include &quot;tiles-build-specific.h&quot;</a>
<a name="ln76"> </a>
<a name="ln77"> </a>
<a name="ln78"> </a>
<a name="ln79">// For finding the executable's path</a>
<a name="ln80">#ifdef TARGET_OS_WINDOWS</a>
<a name="ln81">#define WIN32_LEAN_AND_MEAN</a>
<a name="ln82">#include &lt;windows.h&gt;</a>
<a name="ln83">#include &lt;shlwapi.h&gt;</a>
<a name="ln84">#include &lt;shlobj.h&gt;</a>
<a name="ln85">#elif defined(TARGET_OS_MACOSX)</a>
<a name="ln86">extern char **NXArgv;</a>
<a name="ln87">#ifndef DATA_DIR_PATH</a>
<a name="ln88">#include &lt;unistd.h&gt;</a>
<a name="ln89">#endif</a>
<a name="ln90">#elif defined(TARGET_OS_LINUX) || defined(TARGET_OS_CYGWIN)</a>
<a name="ln91">#include &lt;unistd.h&gt;</a>
<a name="ln92">#endif</a>
<a name="ln93"> </a>
<a name="ln94">const string game_options::interrupt_prefix = &quot;interrupt_&quot;;</a>
<a name="ln95">system_environment SysEnv;</a>
<a name="ln96">game_options Options;</a>
<a name="ln97"> </a>
<a name="ln98">static string _get_save_path(string subdir);</a>
<a name="ln99">static string _supported_language_listing();</a>
<a name="ln100"> </a>
<a name="ln101">static bool _first_less(const pair&lt;int, int&gt; &amp;l, const pair&lt;int, int&gt; &amp;r)</a>
<a name="ln102">{</a>
<a name="ln103">    return l.first &lt; r.first;</a>
<a name="ln104">}</a>
<a name="ln105"> </a>
<a name="ln106">static bool _first_greater(const pair&lt;int, int&gt; &amp;l, const pair&lt;int, int&gt; &amp;r)</a>
<a name="ln107">{</a>
<a name="ln108">    return l.first &gt; r.first;</a>
<a name="ln109">}</a>
<a name="ln110"> </a>
<a name="ln111">const vector&lt;GameOption*&gt; game_options::build_options_list()</a>
<a name="ln112">{</a>
<a name="ln113">#ifndef DEBUG</a>
<a name="ln114">    const bool USING_TOUCH =</a>
<a name="ln115">#if defined(TOUCH_UI)</a>
<a name="ln116">        true;</a>
<a name="ln117">#else</a>
<a name="ln118">        false;</a>
<a name="ln119">#endif</a>
<a name="ln120">#endif</a>
<a name="ln121">    const bool USING_DGL =</a>
<a name="ln122">#if defined(DGAMELAUNCH)</a>
<a name="ln123">        true;</a>
<a name="ln124">#else</a>
<a name="ln125">        false;</a>
<a name="ln126">#endif</a>
<a name="ln127">    const bool USING_UNIX =</a>
<a name="ln128">#if defined(UNIX)</a>
<a name="ln129">        true;</a>
<a name="ln130">#else</a>
<a name="ln131">        false;</a>
<a name="ln132">#endif</a>
<a name="ln133"> </a>
<a name="ln134">#ifdef USE_TILE</a>
<a name="ln135">    const bool USING_WEB_TILES =</a>
<a name="ln136">#if defined(USE_TILE_WEB)</a>
<a name="ln137">        true;</a>
<a name="ln138">#else</a>
<a name="ln139">        false;</a>
<a name="ln140">#endif</a>
<a name="ln141">#endif</a>
<a name="ln142"> </a>
<a name="ln143">    #define SIMPLE_NAME(_opt) _opt, {#_opt}</a>
<a name="ln144">    vector&lt;GameOption*&gt; options = {</a>
<a name="ln145">        new BoolGameOption(SIMPLE_NAME(autopickup_starting_ammo), true),</a>
<a name="ln146">        new BoolGameOption(SIMPLE_NAME(easy_door), true),</a>
<a name="ln147">        new BoolGameOption(SIMPLE_NAME(default_show_all_skills), false),</a>
<a name="ln148">        new BoolGameOption(SIMPLE_NAME(read_persist_options), false),</a>
<a name="ln149">        new BoolGameOption(SIMPLE_NAME(auto_switch), false),</a>
<a name="ln150">        new BoolGameOption(SIMPLE_NAME(suppress_startup_errors), false),</a>
<a name="ln151">        new BoolGameOption(SIMPLE_NAME(simple_targeting), false),</a>
<a name="ln152">        new BoolGameOption(easy_quit_item_prompts,</a>
<a name="ln153">                           { &quot;easy_quit_item_prompts&quot;, &quot;easy_quit_item_lists&quot; },</a>
<a name="ln154">                           true),</a>
<a name="ln155">        new BoolGameOption(SIMPLE_NAME(travel_open_doors), true),</a>
<a name="ln156">        new BoolGameOption(easy_unequip,</a>
<a name="ln157">                           { &quot;easy_unequip&quot;, &quot;easy_armour&quot;, &quot;easy_armor&quot; },</a>
<a name="ln158">                           true),</a>
<a name="ln159">        new BoolGameOption(SIMPLE_NAME(equip_unequip), false),</a>
<a name="ln160">        new BoolGameOption(SIMPLE_NAME(jewellery_prompt), false),</a>
<a name="ln161">        new BoolGameOption(SIMPLE_NAME(easy_door), true),</a>
<a name="ln162">        new BoolGameOption(SIMPLE_NAME(warn_hatches), false),</a>
<a name="ln163">        new BoolGameOption(SIMPLE_NAME(enable_recast_spell), true),</a>
<a name="ln164">        new BoolGameOption(SIMPLE_NAME(easy_eat_chunks), false),</a>
<a name="ln165">        new BoolGameOption(SIMPLE_NAME(auto_eat_chunks), true),</a>
<a name="ln166">        new BoolGameOption(SIMPLE_NAME(auto_hide_spells), false),</a>
<a name="ln167">        new BoolGameOption(SIMPLE_NAME(blink_brightens_background), false),</a>
<a name="ln168">        new BoolGameOption(SIMPLE_NAME(bold_brightens_foreground), false),</a>
<a name="ln169">        new BoolGameOption(SIMPLE_NAME(best_effort_brighten_background), false),</a>
<a name="ln170">#ifdef TARGET_OS_MACOSX</a>
<a name="ln171">        new BoolGameOption(SIMPLE_NAME(best_effort_brighten_foreground), false),</a>
<a name="ln172">        new BoolGameOption(SIMPLE_NAME(allow_extended_colours), true),</a>
<a name="ln173">#else</a>
<a name="ln174">        new BoolGameOption(SIMPLE_NAME(best_effort_brighten_foreground), true),</a>
<a name="ln175">        new BoolGameOption(SIMPLE_NAME(allow_extended_colours), false),</a>
<a name="ln176">#endif</a>
<a name="ln177">        new BoolGameOption(SIMPLE_NAME(regex_search), false),</a>
<a name="ln178">        new BoolGameOption(SIMPLE_NAME(autopickup_search), false),</a>
<a name="ln179">        new BoolGameOption(SIMPLE_NAME(show_newturn_mark), true),</a>
<a name="ln180">        new BoolGameOption(SIMPLE_NAME(show_game_time), true),</a>
<a name="ln181">        new BoolGameOption(SIMPLE_NAME(equip_bar), false),</a>
<a name="ln182">        new BoolGameOption(SIMPLE_NAME(animate_equip_bar), false),</a>
<a name="ln183">        new BoolGameOption(SIMPLE_NAME(mouse_input), false),</a>
<a name="ln184">        new BoolGameOption(SIMPLE_NAME(mlist_allow_alternate_layout), false),</a>
<a name="ln185">        new BoolGameOption(SIMPLE_NAME(messages_at_top), false),</a>
<a name="ln186">        new BoolGameOption(SIMPLE_NAME(msg_condense_repeats), true),</a>
<a name="ln187">        new BoolGameOption(SIMPLE_NAME(msg_condense_short), true),</a>
<a name="ln188">        new BoolGameOption(SIMPLE_NAME(view_lock_x), true),</a>
<a name="ln189">        new BoolGameOption(SIMPLE_NAME(view_lock_y), true),</a>
<a name="ln190">        new BoolGameOption(SIMPLE_NAME(center_on_scroll), false),</a>
<a name="ln191">        new BoolGameOption(SIMPLE_NAME(symmetric_scroll), true),</a>
<a name="ln192">        new BoolGameOption(SIMPLE_NAME(always_show_exclusions), true),</a>
<a name="ln193">        new BoolGameOption(SIMPLE_NAME(note_all_skill_levels), false),</a>
<a name="ln194">        new BoolGameOption(SIMPLE_NAME(note_skill_max), true),</a>
<a name="ln195">        new BoolGameOption(SIMPLE_NAME(note_xom_effects), true),</a>
<a name="ln196">        new BoolGameOption(SIMPLE_NAME(note_chat_messages), false),</a>
<a name="ln197">        new BoolGameOption(SIMPLE_NAME(note_dgl_messages), true),</a>
<a name="ln198">        new BoolGameOption(SIMPLE_NAME(clear_messages), false),</a>
<a name="ln199">#ifdef DEBUG</a>
<a name="ln200">        new BoolGameOption(SIMPLE_NAME(show_more), false),</a>
<a name="ln201">#else</a>
<a name="ln202">        new BoolGameOption(SIMPLE_NAME(show_more), !USING_TOUCH),</a>
<a name="ln203">#endif</a>
<a name="ln204">        new BoolGameOption(SIMPLE_NAME(small_more), false),</a>
<a name="ln205">        new BoolGameOption(SIMPLE_NAME(pickup_thrown), true),</a>
<a name="ln206">        new BoolGameOption(SIMPLE_NAME(show_travel_trail), USING_DGL),</a>
<a name="ln207">        new BoolGameOption(SIMPLE_NAME(use_fake_cursor), USING_UNIX ),</a>
<a name="ln208">        new BoolGameOption(SIMPLE_NAME(use_fake_player_cursor), true),</a>
<a name="ln209">        new BoolGameOption(SIMPLE_NAME(show_player_species), false),</a>
<a name="ln210">        new BoolGameOption(SIMPLE_NAME(use_modifier_prefix_keys), true),</a>
<a name="ln211">        new BoolGameOption(SIMPLE_NAME(ability_menu), true),</a>
<a name="ln212">        new BoolGameOption(SIMPLE_NAME(easy_floor_use), true),</a>
<a name="ln213">        new BoolGameOption(SIMPLE_NAME(bad_item_prompt), true),</a>
<a name="ln214">        new BoolGameOption(SIMPLE_NAME(dos_use_background_intensity), true),</a>
<a name="ln215">        new BoolGameOption(SIMPLE_NAME(explore_greedy), true),</a>
<a name="ln216">        new BoolGameOption(SIMPLE_NAME(explore_auto_rest), true),</a>
<a name="ln217">        new BoolGameOption(SIMPLE_NAME(travel_key_stop), true),</a>
<a name="ln218">        new BoolGameOption(SIMPLE_NAME(dump_on_save), true),</a>
<a name="ln219">        new BoolGameOption(SIMPLE_NAME(rest_wait_both), false),</a>
<a name="ln220">        new BoolGameOption(SIMPLE_NAME(rest_wait_ancestor), false),</a>
<a name="ln221">        new BoolGameOption(SIMPLE_NAME(cloud_status), !is_tiles()),</a>
<a name="ln222">        new BoolGameOption(SIMPLE_NAME(darken_beyond_range), true),</a>
<a name="ln223">        new BoolGameOption(SIMPLE_NAME(arena_dump_msgs), false),</a>
<a name="ln224">        new BoolGameOption(SIMPLE_NAME(arena_dump_msgs_all), false),</a>
<a name="ln225">        new BoolGameOption(SIMPLE_NAME(arena_list_eq), false),</a>
<a name="ln226">        new BoolGameOption(SIMPLE_NAME(default_manual_training), false),</a>
<a name="ln227">        new BoolGameOption(SIMPLE_NAME(one_SDL_sound_channel), false),</a>
<a name="ln228">        new BoolGameOption(SIMPLE_NAME(sounds_on), true),</a>
<a name="ln229">        new ColourGameOption(SIMPLE_NAME(tc_reachable), BLUE),</a>
<a name="ln230">        new ColourGameOption(SIMPLE_NAME(tc_excluded), LIGHTMAGENTA),</a>
<a name="ln231">        new ColourGameOption(SIMPLE_NAME(tc_exclude_circle), RED),</a>
<a name="ln232">        new ColourGameOption(SIMPLE_NAME(tc_forbidden), LIGHTCYAN),</a>
<a name="ln233">        new ColourGameOption(SIMPLE_NAME(tc_dangerous), CYAN),</a>
<a name="ln234">        new ColourGameOption(SIMPLE_NAME(tc_disconnected), DARKGREY),</a>
<a name="ln235">        // [ds] Default to jazzy colours.</a>
<a name="ln236">        new ColourGameOption(SIMPLE_NAME(detected_item_colour), GREEN),</a>
<a name="ln237">        new ColourGameOption(SIMPLE_NAME(detected_monster_colour), LIGHTRED),</a>
<a name="ln238">        new ColourGameOption(SIMPLE_NAME(remembered_monster_colour), DARKGREY),</a>
<a name="ln239">        new ColourGameOption(SIMPLE_NAME(status_caption_colour), BROWN),</a>
<a name="ln240">        new ColourGameOption(SIMPLE_NAME(background_colour), BLACK),</a>
<a name="ln241">        new ColourGameOption(SIMPLE_NAME(foreground_colour), LIGHTGREY),</a>
<a name="ln242">        new CursesGameOption(SIMPLE_NAME(friend_brand),</a>
<a name="ln243">                             CHATTR_HILITE | (GREEN &lt;&lt; 8)),</a>
<a name="ln244">        new CursesGameOption(SIMPLE_NAME(neutral_brand),</a>
<a name="ln245">                             CHATTR_HILITE | (LIGHTGREY &lt;&lt; 8)),</a>
<a name="ln246">        new CursesGameOption(SIMPLE_NAME(stab_brand),</a>
<a name="ln247">                             CHATTR_HILITE | (BLUE &lt;&lt; 8)),</a>
<a name="ln248">        new CursesGameOption(SIMPLE_NAME(may_stab_brand),</a>
<a name="ln249">                             CHATTR_HILITE | (YELLOW &lt;&lt; 8)),</a>
<a name="ln250">        new CursesGameOption(SIMPLE_NAME(feature_item_brand), CHATTR_REVERSE),</a>
<a name="ln251">        new CursesGameOption(SIMPLE_NAME(trap_item_brand), CHATTR_REVERSE),</a>
<a name="ln252">        new CursesGameOption(SIMPLE_NAME(heap_brand), CHATTR_REVERSE),</a>
<a name="ln253">        new IntGameOption(SIMPLE_NAME(note_hp_percent), 5, 0, 100),</a>
<a name="ln254">        new IntGameOption(SIMPLE_NAME(hp_warning), 30, 0, 100),</a>
<a name="ln255">        new IntGameOption(magic_point_warning, {&quot;mp_warning&quot;}, 0, 0, 100),</a>
<a name="ln256">        new IntGameOption(SIMPLE_NAME(autofight_warning), 0, 0, 1000),</a>
<a name="ln257">        // These need to be odd, hence allow +1.</a>
<a name="ln258">        new IntGameOption(SIMPLE_NAME(view_max_width),</a>
<a name="ln259">                      max(VIEW_BASE_WIDTH, VIEW_MIN_WIDTH),</a>
<a name="ln260">                      VIEW_MIN_WIDTH, GXM + 1),</a>
<a name="ln261">        new IntGameOption(SIMPLE_NAME(view_max_height), max(21, VIEW_MIN_HEIGHT),</a>
<a name="ln262">                      VIEW_MIN_HEIGHT, GYM + 1),</a>
<a name="ln263">        new IntGameOption(SIMPLE_NAME(mlist_min_height), 4, 0),</a>
<a name="ln264">        new IntGameOption(SIMPLE_NAME(msg_min_height), max(7, MSG_MIN_HEIGHT),</a>
<a name="ln265">                          MSG_MIN_HEIGHT),</a>
<a name="ln266">        new IntGameOption(SIMPLE_NAME(msg_max_height), max(10, MSG_MIN_HEIGHT),</a>
<a name="ln267">                          MSG_MIN_HEIGHT),</a>
<a name="ln268">        new IntGameOption(SIMPLE_NAME(msg_webtiles_height), -1),</a>
<a name="ln269">        new IntGameOption(SIMPLE_NAME(rest_wait_percent), 100, 0, 100),</a>
<a name="ln270">        new IntGameOption(SIMPLE_NAME(pickup_menu_limit), 1),</a>
<a name="ln271">        new IntGameOption(SIMPLE_NAME(view_delay), DEFAULT_VIEW_DELAY, 0),</a>
<a name="ln272">        new IntGameOption(SIMPLE_NAME(fail_severity_to_confirm), 3, -1, 3),</a>
<a name="ln273">        new IntGameOption(SIMPLE_NAME(travel_delay), USING_DGL ? -1 : 20,</a>
<a name="ln274">                          -1, 2000),</a>
<a name="ln275">        new IntGameOption(SIMPLE_NAME(rest_delay), USING_DGL ? -1 : 0,</a>
<a name="ln276">                          -1, 2000),</a>
<a name="ln277">        new IntGameOption(SIMPLE_NAME(explore_delay), -1, -1, 2000),</a>
<a name="ln278">        new IntGameOption(SIMPLE_NAME(explore_item_greed), 10, -1000, 1000),</a>
<a name="ln279">        new IntGameOption(SIMPLE_NAME(explore_wall_bias), 0, 0, 1000),</a>
<a name="ln280">        new IntGameOption(SIMPLE_NAME(scroll_margin_x), 2, 0),</a>
<a name="ln281">        new IntGameOption(SIMPLE_NAME(scroll_margin_y), 2, 0),</a>
<a name="ln282">        new IntGameOption(SIMPLE_NAME(item_stack_summary_minimum), 4),</a>
<a name="ln283">        new IntGameOption(SIMPLE_NAME(level_map_cursor_step), 7, 1, 50),</a>
<a name="ln284">        new IntGameOption(SIMPLE_NAME(dump_item_origin_price), -1, -1),</a>
<a name="ln285">        new IntGameOption(SIMPLE_NAME(dump_message_count), 20),</a>
<a name="ln286">        new IntGameOption(SIMPLE_NAME(auto_butcher_max_chunks), 10, 0),</a>
<a name="ln287">        new ListGameOption&lt;text_pattern&gt;(SIMPLE_NAME(confirm_action)),</a>
<a name="ln288">        new ListGameOption&lt;text_pattern&gt;(SIMPLE_NAME(drop_filter)),</a>
<a name="ln289">        new ListGameOption&lt;text_pattern&gt;(SIMPLE_NAME(note_monsters)),</a>
<a name="ln290">        new ListGameOption&lt;text_pattern&gt;(SIMPLE_NAME(note_messages)),</a>
<a name="ln291">        new ListGameOption&lt;text_pattern&gt;(SIMPLE_NAME(note_items)),</a>
<a name="ln292">        new ListGameOption&lt;text_pattern&gt;(SIMPLE_NAME(auto_exclude)),</a>
<a name="ln293">        new ListGameOption&lt;text_pattern&gt;(SIMPLE_NAME(explore_stop_pickup_ignore)),</a>
<a name="ln294">        new ColourThresholdOption(hp_colour, {&quot;hp_colour&quot;, &quot;hp_color&quot;},</a>
<a name="ln295">                                  &quot;50:yellow, 25:red&quot;, _first_greater),</a>
<a name="ln296">        new ColourThresholdOption(mp_colour, {&quot;mp_colour&quot;, &quot;mp_color&quot;},</a>
<a name="ln297">                                  &quot;50:yellow, 25:red&quot;, _first_greater),</a>
<a name="ln298">        new ColourThresholdOption(stat_colour, {&quot;stat_colour&quot;, &quot;stat_color&quot;},</a>
<a name="ln299">                                  &quot;3:red&quot;, _first_less),</a>
<a name="ln300">        new StringGameOption(SIMPLE_NAME(sound_file_path), &quot;&quot;),</a>
<a name="ln301"> </a>
<a name="ln302">#ifdef DGL_SIMPLE_MESSAGING</a>
<a name="ln303">        new BoolGameOption(SIMPLE_NAME(messaging), false),</a>
<a name="ln304">#endif</a>
<a name="ln305">#ifndef DGAMELAUNCH</a>
<a name="ln306">        new BoolGameOption(SIMPLE_NAME(name_bypasses_menu), true),</a>
<a name="ln307">        new BoolGameOption(SIMPLE_NAME(restart_after_save), false),</a>
<a name="ln308">        new BoolGameOption(SIMPLE_NAME(newgame_after_quit), false),</a>
<a name="ln309">        new StringGameOption(SIMPLE_NAME(map_file_name), &quot;&quot;),</a>
<a name="ln310">        new StringGameOption(SIMPLE_NAME(save_dir), _get_save_path(&quot;saves/&quot;)),</a>
<a name="ln311">        new StringGameOption(SIMPLE_NAME(morgue_dir),</a>
<a name="ln312">                             _get_save_path(&quot;morgue/&quot;)),</a>
<a name="ln313">#endif</a>
<a name="ln314">#ifdef USE_TILE</a>
<a name="ln315">        new BoolGameOption(SIMPLE_NAME(tile_skip_title), false),</a>
<a name="ln316">        new BoolGameOption(SIMPLE_NAME(tile_menu_icons), true),</a>
<a name="ln317">        new BoolGameOption(SIMPLE_NAME(tile_filter_scaling), false),</a>
<a name="ln318">        new BoolGameOption(SIMPLE_NAME(tile_force_overlay), false),</a>
<a name="ln319">        new BoolGameOption(SIMPLE_NAME(tile_show_minihealthbar), true),</a>
<a name="ln320">        new BoolGameOption(SIMPLE_NAME(tile_show_minimagicbar), true),</a>
<a name="ln321">        new BoolGameOption(SIMPLE_NAME(tile_show_demon_tier), false),</a>
<a name="ln322">        new StringGameOption(SIMPLE_NAME(tile_show_threat_levels), &quot;&quot;),</a>
<a name="ln323">        new StringGameOption(SIMPLE_NAME(tile_show_items), &quot;!?/%=([)x}:|\\&quot;),</a>
<a name="ln324">        // disabled by default due to performance issues</a>
<a name="ln325">        new BoolGameOption(SIMPLE_NAME(tile_water_anim), !USING_WEB_TILES),</a>
<a name="ln326">        new BoolGameOption(SIMPLE_NAME(tile_misc_anim), true),</a>
<a name="ln327">        new IntGameOption(SIMPLE_NAME(tile_font_crt_size), 0, 0, INT_MAX),</a>
<a name="ln328">        new IntGameOption(SIMPLE_NAME(tile_font_msg_size), 0, 0, INT_MAX),</a>
<a name="ln329">        new IntGameOption(SIMPLE_NAME(tile_font_stat_size), 0, 0, INT_MAX),</a>
<a name="ln330">        new IntGameOption(SIMPLE_NAME(tile_font_tip_size), 0, 0, INT_MAX),</a>
<a name="ln331">        new IntGameOption(SIMPLE_NAME(tile_font_lbl_size), 0, 0, INT_MAX),</a>
<a name="ln332">        new IntGameOption(SIMPLE_NAME(tile_cell_pixels), 32, 1, INT_MAX),</a>
<a name="ln333">        new IntGameOption(SIMPLE_NAME(tile_map_pixels), 0, 0, INT_MAX),</a>
<a name="ln334">        new IntGameOption(SIMPLE_NAME(tile_tooltip_ms), 500, 0, INT_MAX),</a>
<a name="ln335">        new IntGameOption(SIMPLE_NAME(tile_update_rate), 1000, 50, INT_MAX),</a>
<a name="ln336">        new IntGameOption(SIMPLE_NAME(tile_runrest_rate), 100, 0, INT_MAX),</a>
<a name="ln337">        // minimap colours</a>
<a name="ln338">        new TileColGameOption(SIMPLE_NAME(tile_branchstairs_col), &quot;#ff7788&quot;),</a>
<a name="ln339">        new TileColGameOption(SIMPLE_NAME(tile_deep_water_col), &quot;#001122&quot;),</a>
<a name="ln340">        new TileColGameOption(SIMPLE_NAME(tile_door_col), &quot;#775544&quot;),</a>
<a name="ln341">        new TileColGameOption(SIMPLE_NAME(tile_downstairs_col), &quot;#ff00ff&quot;),</a>
<a name="ln342">        new TileColGameOption(SIMPLE_NAME(tile_excl_centre_col), &quot;#552266&quot;),</a>
<a name="ln343">        new TileColGameOption(SIMPLE_NAME(tile_excluded_col), &quot;#552266&quot;),</a>
<a name="ln344">        new TileColGameOption(SIMPLE_NAME(tile_explore_horizon_col), &quot;#6B301B&quot;),</a>
<a name="ln345">        new TileColGameOption(SIMPLE_NAME(tile_feature_col), &quot;#997700&quot;),</a>
<a name="ln346">        new TileColGameOption(SIMPLE_NAME(tile_floor_col), &quot;#333333&quot;),</a>
<a name="ln347">        new TileColGameOption(SIMPLE_NAME(tile_item_col), &quot;#005544&quot;),</a>
<a name="ln348">        new TileColGameOption(SIMPLE_NAME(tile_lava_col), &quot;#552211&quot;),</a>
<a name="ln349">        new TileColGameOption(SIMPLE_NAME(tile_mapped_floor_col), &quot;#222266&quot;),</a>
<a name="ln350">        new TileColGameOption(SIMPLE_NAME(tile_mapped_wall_col), &quot;#444499&quot;),</a>
<a name="ln351">        new TileColGameOption(SIMPLE_NAME(tile_monster_col), &quot;#660000&quot;),</a>
<a name="ln352">        new TileColGameOption(SIMPLE_NAME(tile_plant_col), &quot;#446633&quot;),</a>
<a name="ln353">        new TileColGameOption(SIMPLE_NAME(tile_player_col), &quot;white&quot;),</a>
<a name="ln354">        new TileColGameOption(SIMPLE_NAME(tile_portal_col), &quot;#ffdd00&quot;),</a>
<a name="ln355">        new TileColGameOption(SIMPLE_NAME(tile_trap_col), &quot;#aa6644&quot;),</a>
<a name="ln356">        new TileColGameOption(SIMPLE_NAME(tile_unseen_col), &quot;black&quot;),</a>
<a name="ln357">        new TileColGameOption(SIMPLE_NAME(tile_upstairs_col), &quot;cyan&quot;),</a>
<a name="ln358">        new TileColGameOption(SIMPLE_NAME(tile_transporter_col), &quot;#0000ff&quot;),</a>
<a name="ln359">        new TileColGameOption(SIMPLE_NAME(tile_transporter_landing_col), &quot;#5200aa&quot;),</a>
<a name="ln360">        new TileColGameOption(SIMPLE_NAME(tile_wall_col), &quot;#666666&quot;),</a>
<a name="ln361">        new TileColGameOption(SIMPLE_NAME(tile_water_col), &quot;#114455&quot;),</a>
<a name="ln362">        new TileColGameOption(SIMPLE_NAME(tile_window_col), &quot;#558855&quot;),</a>
<a name="ln363">        new ListGameOption&lt;string&gt;(SIMPLE_NAME(tile_layout_priority),</a>
<a name="ln364">#ifdef TOUCH_UI</a>
<a name="ln365">            split_string(&quot;,&quot;, &quot;minimap, command, inventory, &quot;</a>
<a name="ln366">                              &quot;command2, spell, ability, monster&quot;)),</a>
<a name="ln367">#else</a>
<a name="ln368">            split_string(&quot;,&quot;, &quot;minimap, inventory, command, &quot;</a>
<a name="ln369">                              &quot;spell, ability, monster&quot;)),</a>
<a name="ln370">#endif</a>
<a name="ln371">#endif</a>
<a name="ln372">#ifdef USE_TILE_LOCAL</a>
<a name="ln373">        new IntGameOption(SIMPLE_NAME(tile_key_repeat_delay), 200, 0, INT_MAX),</a>
<a name="ln374">        new IntGameOption(SIMPLE_NAME(tile_window_width), -90, INT_MIN, INT_MAX),</a>
<a name="ln375">        new IntGameOption(SIMPLE_NAME(tile_window_height), -90, INT_MIN, INT_MAX),</a>
<a name="ln376">        new StringGameOption(SIMPLE_NAME(tile_font_crt_file), MONOSPACED_FONT),</a>
<a name="ln377">        new StringGameOption(SIMPLE_NAME(tile_font_msg_file), MONOSPACED_FONT),</a>
<a name="ln378">        new StringGameOption(SIMPLE_NAME(tile_font_stat_file), MONOSPACED_FONT),</a>
<a name="ln379">        new StringGameOption(SIMPLE_NAME(tile_font_tip_file), MONOSPACED_FONT),</a>
<a name="ln380">        new StringGameOption(SIMPLE_NAME(tile_font_lbl_file), PROPORTIONAL_FONT),</a>
<a name="ln381">        new BoolGameOption(SIMPLE_NAME(tile_single_column_menus), true),</a>
<a name="ln382">#endif</a>
<a name="ln383">#ifdef USE_TILE_WEB</a>
<a name="ln384">        new BoolGameOption(SIMPLE_NAME(tile_realtime_anim), false),</a>
<a name="ln385">        new BoolGameOption(SIMPLE_NAME(tile_level_map_hide_messages), true),</a>
<a name="ln386">        new BoolGameOption(SIMPLE_NAME(tile_level_map_hide_sidebar), false),</a>
<a name="ln387">        new BoolGameOption(SIMPLE_NAME(tile_web_mouse_control), true),</a>
<a name="ln388">        new StringGameOption(SIMPLE_NAME(tile_font_crt_family), &quot;monospace&quot;),</a>
<a name="ln389">        new StringGameOption(SIMPLE_NAME(tile_font_msg_family), &quot;monospace&quot;),</a>
<a name="ln390">        new StringGameOption(SIMPLE_NAME(tile_font_stat_family), &quot;monospace&quot;),</a>
<a name="ln391">        new StringGameOption(SIMPLE_NAME(tile_font_lbl_family), &quot;monospace&quot;),</a>
<a name="ln392">#endif</a>
<a name="ln393">#ifdef USE_FT</a>
<a name="ln394">        new BoolGameOption(SIMPLE_NAME(tile_font_ft_light), false),</a>
<a name="ln395">#endif</a>
<a name="ln396">#ifdef WIZARD</a>
<a name="ln397">        new BoolGameOption(SIMPLE_NAME(fsim_csv), false),</a>
<a name="ln398">        new ListGameOption&lt;string&gt;(SIMPLE_NAME(fsim_scale)),</a>
<a name="ln399">        new ListGameOption&lt;string&gt;(SIMPLE_NAME(fsim_kit)),</a>
<a name="ln400">        new StringGameOption(SIMPLE_NAME(fsim_mode), &quot;&quot;),</a>
<a name="ln401">        new StringGameOption(SIMPLE_NAME(fsim_mons), &quot;&quot;),</a>
<a name="ln402">        new IntGameOption(SIMPLE_NAME(fsim_rounds), 4000, 1000, 500000),</a>
<a name="ln403">#endif</a>
<a name="ln404">#if !defined(DGAMELAUNCH) || defined(DGL_REMEMBER_NAME)</a>
<a name="ln405">        new BoolGameOption(SIMPLE_NAME(remember_name), true),</a>
<a name="ln406">#endif</a>
<a name="ln407">    };</a>
<a name="ln408"> </a>
<a name="ln409">#undef SIMPLE_NAME</a>
<a name="ln410">    return options;</a>
<a name="ln411">}</a>
<a name="ln412"> </a>
<a name="ln413">map&lt;string, GameOption*&gt; game_options::build_options_map(</a>
<a name="ln414">    const vector&lt;GameOption*&gt; &amp;options)</a>
<a name="ln415">{</a>
<a name="ln416">    map&lt;string, GameOption*&gt; option_map;</a>
<a name="ln417">    for (GameOption* option : options)</a>
<a name="ln418">        for (string name : option-&gt;getNames())</a>
<a name="ln419">            option_map[name] = option;</a>
<a name="ln420">    return option_map;</a>
<a name="ln421">}</a>
<a name="ln422"> </a>
<a name="ln423">object_class_type item_class_by_sym(char32_t c)</a>
<a name="ln424">{</a>
<a name="ln425">    switch (c)</a>
<a name="ln426">    {</a>
<a name="ln427">    case ')':</a>
<a name="ln428">        return OBJ_WEAPONS;</a>
<a name="ln429">    case '(':</a>
<a name="ln430">    case U'\x27b9': //➹</a>
<a name="ln431">        return OBJ_MISSILES;</a>
<a name="ln432">    case '[':</a>
<a name="ln433">        return OBJ_ARMOUR;</a>
<a name="ln434">    case '/':</a>
<a name="ln435">        return OBJ_WANDS;</a>
<a name="ln436">    case '%':</a>
<a name="ln437">        return OBJ_FOOD;</a>
<a name="ln438">    case '?':</a>
<a name="ln439">        return OBJ_SCROLLS;</a>
<a name="ln440">    case '&quot;': // Make the amulet symbol equiv to ring -- bwross</a>
<a name="ln441">    case '=':</a>
<a name="ln442">    case U'\xb0': //°</a>
<a name="ln443">        return OBJ_JEWELLERY;</a>
<a name="ln444">    case '!':</a>
<a name="ln445">        return OBJ_POTIONS;</a>
<a name="ln446">    case ':':</a>
<a name="ln447">    case '+': // ??? -- was the only symbol working for tile order up to 0.10,</a>
<a name="ln448">              // so keeping it for compat purposes (user configs).</a>
<a name="ln449">    case U'\x221e': //∞</a>
<a name="ln450">        return OBJ_BOOKS;</a>
<a name="ln451">    case '|':</a>
<a name="ln452">        return OBJ_STAVES;</a>
<a name="ln453">    case '0':</a>
<a name="ln454">        return OBJ_ORBS;</a>
<a name="ln455">    case '}':</a>
<a name="ln456">        return OBJ_MISCELLANY;</a>
<a name="ln457">    case '&amp;':</a>
<a name="ln458">    case 'X':</a>
<a name="ln459">    case 'x':</a>
<a name="ln460">        return OBJ_CORPSES;</a>
<a name="ln461">    case '$':</a>
<a name="ln462">    case U'\x20ac': //€</a>
<a name="ln463">    case U'\xa3': //£</a>
<a name="ln464">    case U'\xa5': //¥ // FR: support more currencies</a>
<a name="ln465">        return OBJ_GOLD;</a>
<a name="ln466">#if TAG_MAJOR_VERSION == 34</a>
<a name="ln467">    case '\\': // Compat break: used to be staves (why not '|'?).</a>
<a name="ln468">        return OBJ_RODS;</a>
<a name="ln469">#endif</a>
<a name="ln470">    default:</a>
<a name="ln471">        return NUM_OBJECT_CLASSES;</a>
<a name="ln472">    }</a>
<a name="ln473">}</a>
<a name="ln474"> </a>
<a name="ln475">// Returns MSGCOL_NONE if unmatched else returns 0-15.</a>
<a name="ln476">static msg_colour_type _str_to_channel_colour(const string &amp;str)</a>
<a name="ln477">{</a>
<a name="ln478">    int col = str_to_colour(str);</a>
<a name="ln479">    msg_colour_type ret = MSGCOL_NONE;</a>
<a name="ln480">    if (col == -1)</a>
<a name="ln481">    {</a>
<a name="ln482">        if (str == &quot;mute&quot;)</a>
<a name="ln483">            ret = MSGCOL_MUTED;</a>
<a name="ln484">        else if (str == &quot;plain&quot; || str == &quot;off&quot;)</a>
<a name="ln485">            ret = MSGCOL_PLAIN;</a>
<a name="ln486">        else if (str == &quot;default&quot; || str == &quot;on&quot;)</a>
<a name="ln487">            ret = MSGCOL_DEFAULT;</a>
<a name="ln488">        else if (str == &quot;alternate&quot;)</a>
<a name="ln489">            ret = MSGCOL_ALTERNATE;</a>
<a name="ln490">    }</a>
<a name="ln491">    else</a>
<a name="ln492">        ret = msg_colour(col);</a>
<a name="ln493"> </a>
<a name="ln494">    return ret;</a>
<a name="ln495">}</a>
<a name="ln496"> </a>
<a name="ln497">static const string message_channel_names[] =</a>
<a name="ln498">{</a>
<a name="ln499">    &quot;plain&quot;, &quot;friend_action&quot;, &quot;prompt&quot;, &quot;god&quot;, &quot;duration&quot;, &quot;danger&quot;, &quot;warning&quot;,</a>
<a name="ln500">    &quot;food&quot;, &quot;recovery&quot;, &quot;sound&quot;, &quot;talk&quot;, &quot;talk_visual&quot;, &quot;intrinsic_gain&quot;,</a>
<a name="ln501">    &quot;mutation&quot;, &quot;monster_spell&quot;, &quot;monster_enchant&quot;, &quot;friend_spell&quot;,</a>
<a name="ln502">    &quot;friend_enchant&quot;, &quot;monster_damage&quot;, &quot;monster_target&quot;, &quot;banishment&quot;,</a>
<a name="ln503">    &quot;rotten_meat&quot;, &quot;equipment&quot;, &quot;floor&quot;, &quot;multiturn&quot;, &quot;examine&quot;,</a>
<a name="ln504">    &quot;examine_filter&quot;, &quot;diagnostic&quot;, &quot;error&quot;, &quot;tutorial&quot;, &quot;orb&quot;, &quot;timed_portal&quot;,</a>
<a name="ln505">    &quot;hell_effect&quot;, &quot;monster_warning&quot;, &quot;dgl_message&quot;,</a>
<a name="ln506">};</a>
<a name="ln507"> </a>
<a name="ln508">// returns -1 if unmatched else returns 0--(NUM_MESSAGE_CHANNELS-1)</a>
<a name="ln509">int str_to_channel(const string &amp;str)</a>
<a name="ln510">{</a>
<a name="ln511">    COMPILE_CHECK(ARRAYSZ(message_channel_names) == NUM_MESSAGE_CHANNELS);</a>
<a name="ln512"> </a>
<a name="ln513">    // widespread aliases</a>
<a name="ln514">    if (str == &quot;visual&quot;)</a>
<a name="ln515">        return MSGCH_TALK_VISUAL;</a>
<a name="ln516">    else if (str == &quot;spell&quot;)</a>
<a name="ln517">        return MSGCH_MONSTER_SPELL;</a>
<a name="ln518"> </a>
<a name="ln519">    for (int ret = 0; ret &lt; NUM_MESSAGE_CHANNELS; ret++)</a>
<a name="ln520">    {</a>
<a name="ln521">        if (str == message_channel_names[ret])</a>
<a name="ln522">            return ret;</a>
<a name="ln523">    }</a>
<a name="ln524"> </a>
<a name="ln525">    return -1;</a>
<a name="ln526">}</a>
<a name="ln527"> </a>
<a name="ln528">string channel_to_str(int channel)</a>
<a name="ln529">{</a>
<a name="ln530">    if (channel &lt; 0 || channel &gt;= NUM_MESSAGE_CHANNELS)</a>
<a name="ln531">        return &quot;&quot;;</a>
<a name="ln532"> </a>
<a name="ln533">    return message_channel_names[channel];</a>
<a name="ln534">}</a>
<a name="ln535"> </a>
<a name="ln536"> </a>
<a name="ln537">// The map used to interpret a crawlrc entry as a starting weapon</a>
<a name="ln538">// type. For most entries, we can just look up which weapon has the entry as</a>
<a name="ln539">// its name; this map contains the exceptions.</a>
<a name="ln540">// This should be const, but operator[] on maps isn't const.</a>
<a name="ln541">static map&lt;string, weapon_type&gt; _special_weapon_map = {</a>
<a name="ln542"> </a>
<a name="ln543">    // &quot;staff&quot; normally refers to a magical staff, but here we want to</a>
<a name="ln544">    // interpret it as a quarterstaff.</a>
<a name="ln545">    {&quot;staff&quot;,       WPN_QUARTERSTAFF},</a>
<a name="ln546"> </a>
<a name="ln547">    // These weapons' base names have changed; we want to interpret the old</a>
<a name="ln548">    // names correctly.</a>
<a name="ln549">    {&quot;sling&quot;,       WPN_HUNTING_SLING},</a>
<a name="ln550">    {&quot;crossbow&quot;,    WPN_HAND_CROSSBOW},</a>
<a name="ln551"> </a>
<a name="ln552">    // Pseudo-weapons.</a>
<a name="ln553">    {&quot;unarmed&quot;,     WPN_UNARMED},</a>
<a name="ln554">    {&quot;claws&quot;,       WPN_UNARMED},</a>
<a name="ln555"> </a>
<a name="ln556">    {&quot;thrown&quot;,      WPN_THROWN},</a>
<a name="ln557">    {&quot;rocks&quot;,       WPN_THROWN},</a>
<a name="ln558">    {&quot;boomerangs&quot;,   WPN_THROWN},</a>
<a name="ln559">    {&quot;javelins&quot;,    WPN_THROWN},</a>
<a name="ln560"> </a>
<a name="ln561">    {&quot;random&quot;,      WPN_RANDOM},</a>
<a name="ln562"> </a>
<a name="ln563">    {&quot;viable&quot;,      WPN_VIABLE},</a>
<a name="ln564">};</a>
<a name="ln565"> </a>
<a name="ln566">/**</a>
<a name="ln567"> * Interpret a crawlrc entry as a starting weapon type.</a>
<a name="ln568"> *</a>
<a name="ln569"> * @param str   The value of the crawlrc entry.</a>
<a name="ln570"> * @return      The weapon the string refers to, or WPN_UNKNOWN if invalid</a>
<a name="ln571"> */</a>
<a name="ln572">weapon_type str_to_weapon(const string &amp;str)</a>
<a name="ln573">{</a>
<a name="ln574">    string str_nospace = str;</a>
<a name="ln575">    remove_whitespace(str_nospace);</a>
<a name="ln576"> </a>
<a name="ln577">    // Synonyms and pseudo-weapons.</a>
<a name="ln578">    if (_special_weapon_map.count(str_nospace))</a>
<a name="ln579">        return _special_weapon_map[str_nospace];</a>
<a name="ln580"> </a>
<a name="ln581">    // Real weapons referred to by their standard names.</a>
<a name="ln582">    return name_nospace_to_weapon(str_nospace);</a>
<a name="ln583">}</a>
<a name="ln584"> </a>
<a name="ln585">static string _weapon_to_str(weapon_type wpn_type)</a>
<a name="ln586">{</a>
<a name="ln587">    if (wpn_type &gt;= 0 &amp;&amp; wpn_type &lt; NUM_WEAPONS)</a>
<a name="ln588">        return weapon_base_name(wpn_type);</a>
<a name="ln589"> </a>
<a name="ln590">    switch (wpn_type)</a>
<a name="ln591">    {</a>
<a name="ln592">    case WPN_UNARMED:</a>
<a name="ln593">        return &quot;claws&quot;;</a>
<a name="ln594">    case WPN_THROWN:</a>
<a name="ln595">        return &quot;thrown&quot;;</a>
<a name="ln596">    case WPN_VIABLE:</a>
<a name="ln597">        return &quot;viable&quot;;</a>
<a name="ln598">    case WPN_RANDOM:</a>
<a name="ln599">    default:</a>
<a name="ln600">        return &quot;random&quot;;</a>
<a name="ln601">    }</a>
<a name="ln602">}</a>
<a name="ln603"> </a>
<a name="ln604">// Summon types can be any of mon_summon_type (enum.h), or a relevant summoning</a>
<a name="ln605">// spell.</a>
<a name="ln606">int str_to_summon_type(const string &amp;str)</a>
<a name="ln607">{</a>
<a name="ln608">    if (str == &quot;clone&quot;)</a>
<a name="ln609">        return MON_SUMM_CLONE;</a>
<a name="ln610">    if (str == &quot;animate&quot;)</a>
<a name="ln611">        return MON_SUMM_ANIMATE;</a>
<a name="ln612">    if (str == &quot;chaos&quot;)</a>
<a name="ln613">        return MON_SUMM_CHAOS;</a>
<a name="ln614">    if (str == &quot;miscast&quot;)</a>
<a name="ln615">        return MON_SUMM_MISCAST;</a>
<a name="ln616">    if (str == &quot;zot&quot;)</a>
<a name="ln617">        return MON_SUMM_ZOT;</a>
<a name="ln618">    if (str == &quot;wrath&quot;)</a>
<a name="ln619">        return MON_SUMM_WRATH;</a>
<a name="ln620">    if (str == &quot;aid&quot;)</a>
<a name="ln621">        return MON_SUMM_AID;</a>
<a name="ln622"> </a>
<a name="ln623">    return spell_by_name(str);</a>
<a name="ln624">}</a>
<a name="ln625"> </a>
<a name="ln626">static fire_type _str_to_fire_types(const string &amp;str)</a>
<a name="ln627">{</a>
<a name="ln628">    if (str == &quot;launcher&quot;)</a>
<a name="ln629">        return FIRE_LAUNCHER;</a>
<a name="ln630">    else if (str == &quot;stone&quot;)</a>
<a name="ln631">        return FIRE_STONE;</a>
<a name="ln632">    else if (str == &quot;rock&quot;)</a>
<a name="ln633">        return FIRE_ROCK;</a>
<a name="ln634">    else if (str == &quot;javelin&quot;)</a>
<a name="ln635">        return FIRE_JAVELIN;</a>
<a name="ln636">    else if (str == &quot;boomerang&quot;)</a>
<a name="ln637">        return FIRE_BOOMERANG;</a>
<a name="ln638">    else if (str == &quot;dart&quot;)</a>
<a name="ln639">        return FIRE_DART;</a>
<a name="ln640">    else if (str == &quot;net&quot;)</a>
<a name="ln641">        return FIRE_NET;</a>
<a name="ln642">    else if (str == &quot;inscribed&quot;)</a>
<a name="ln643">        return FIRE_INSCRIBED;</a>
<a name="ln644"> </a>
<a name="ln645">    return FIRE_NONE;</a>
<a name="ln646">}</a>
<a name="ln647"> </a>
<a name="ln648">string gametype_to_str(game_type type)</a>
<a name="ln649">{</a>
<a name="ln650">    switch (type)</a>
<a name="ln651">    {</a>
<a name="ln652">    case GAME_TYPE_NORMAL:</a>
<a name="ln653">        return &quot;normal&quot;;</a>
<a name="ln654">    case GAME_TYPE_CUSTOM_SEED:</a>
<a name="ln655">        return &quot;seeded&quot;;</a>
<a name="ln656">    case GAME_TYPE_TUTORIAL:</a>
<a name="ln657">        return &quot;tutorial&quot;;</a>
<a name="ln658">    case GAME_TYPE_ARENA:</a>
<a name="ln659">        return &quot;arena&quot;;</a>
<a name="ln660">    case GAME_TYPE_SPRINT:</a>
<a name="ln661">        return &quot;sprint&quot;;</a>
<a name="ln662">    case GAME_TYPE_HINTS:</a>
<a name="ln663">        return &quot;hints&quot;;</a>
<a name="ln664">    default:</a>
<a name="ln665">        return &quot;none&quot;;</a>
<a name="ln666">    }</a>
<a name="ln667">}</a>
<a name="ln668"> </a>
<a name="ln669">#ifndef DGAMELAUNCH</a>
<a name="ln670">static game_type _str_to_gametype(const string&amp; s)</a>
<a name="ln671">{</a>
<a name="ln672">    for (int i = 0; i &lt; NUM_GAME_TYPE; ++i)</a>
<a name="ln673">    {</a>
<a name="ln674">        game_type t = static_cast&lt;game_type&gt;(i);</a>
<a name="ln675">        if (s == gametype_to_str(t))</a>
<a name="ln676">            return t;</a>
<a name="ln677">    }</a>
<a name="ln678">    return NUM_GAME_TYPE;</a>
<a name="ln679">}</a>
<a name="ln680">#endif</a>
<a name="ln681"> </a>
<a name="ln682">static string _species_to_str(species_type sp)</a>
<a name="ln683">{</a>
<a name="ln684">    if (sp == SP_RANDOM)</a>
<a name="ln685">        return &quot;random&quot;;</a>
<a name="ln686">    else if (sp == SP_VIABLE)</a>
<a name="ln687">        return &quot;viable&quot;;</a>
<a name="ln688">    else</a>
<a name="ln689">        return species_name(sp);</a>
<a name="ln690">}</a>
<a name="ln691"> </a>
<a name="ln692">static species_type _str_to_species(const string &amp;str)</a>
<a name="ln693">{</a>
<a name="ln694">    if (str == &quot;random&quot;)</a>
<a name="ln695">        return SP_RANDOM;</a>
<a name="ln696">    else if (str == &quot;viable&quot;)</a>
<a name="ln697">        return SP_VIABLE;</a>
<a name="ln698"> </a>
<a name="ln699">    species_type ret = SP_UNKNOWN;</a>
<a name="ln700">    if (str.length() == 2) // scan abbreviations</a>
<a name="ln701">        ret = get_species_by_abbrev(str.c_str());</a>
<a name="ln702"> </a>
<a name="ln703">    // if we don't have a match, scan the full names</a>
<a name="ln704">    if (ret == SP_UNKNOWN &amp;&amp; str.length() &gt;= 2)</a>
<a name="ln705">        ret = find_species_from_string(str, true);</a>
<a name="ln706"> </a>
<a name="ln707">    if (!is_starting_species(ret))</a>
<a name="ln708">        ret = SP_UNKNOWN;</a>
<a name="ln709"> </a>
<a name="ln710">    if (ret == SP_UNKNOWN)</a>
<a name="ln711">        fprintf(stderr, &quot;Unknown species choice: %s\n&quot;, str.c_str());</a>
<a name="ln712"> </a>
<a name="ln713">    return ret;</a>
<a name="ln714">}</a>
<a name="ln715"> </a>
<a name="ln716">static string _job_to_str(job_type job)</a>
<a name="ln717">{</a>
<a name="ln718">    if (job == JOB_RANDOM)</a>
<a name="ln719">        return &quot;random&quot;;</a>
<a name="ln720">    else if (job == JOB_VIABLE)</a>
<a name="ln721">        return &quot;viable&quot;;</a>
<a name="ln722">    else</a>
<a name="ln723">        return get_job_name(job);</a>
<a name="ln724">}</a>
<a name="ln725"> </a>
<a name="ln726">job_type str_to_job(const string &amp;str)</a>
<a name="ln727">{</a>
<a name="ln728">    if (str == &quot;random&quot;)</a>
<a name="ln729">        return JOB_RANDOM;</a>
<a name="ln730">    else if (str == &quot;viable&quot;)</a>
<a name="ln731">        return JOB_VIABLE;</a>
<a name="ln732"> </a>
<a name="ln733">    job_type job = JOB_UNKNOWN;</a>
<a name="ln734"> </a>
<a name="ln735">    if (str.length() == 2) // scan abbreviations</a>
<a name="ln736">        job = get_job_by_abbrev(str.c_str());</a>
<a name="ln737"> </a>
<a name="ln738">    // if we don't have a match, scan the full names</a>
<a name="ln739">    if (job == JOB_UNKNOWN)</a>
<a name="ln740">        job = get_job_by_name(str.c_str());</a>
<a name="ln741"> </a>
<a name="ln742">    if (!is_starting_job(job))</a>
<a name="ln743">        job = JOB_UNKNOWN;</a>
<a name="ln744"> </a>
<a name="ln745">    if (job == JOB_UNKNOWN)</a>
<a name="ln746">        fprintf(stderr, &quot;Unknown background choice: %s\n&quot;, str.c_str());</a>
<a name="ln747"> </a>
<a name="ln748">    return job;</a>
<a name="ln749">}</a>
<a name="ln750"> </a>
<a name="ln751">// read a value which can be either a boolean (in which case return</a>
<a name="ln752">// 0 for true, -1 for false), or a string of the form PREFIX:NUMBER</a>
<a name="ln753">// (e.g., auto:7), in which case return NUMBER as an int.</a>
<a name="ln754">static int _read_bool_or_number(const string &amp;field, int def_value,</a>
<a name="ln755">                                const string&amp; num_prefix)</a>
<a name="ln756">{</a>
<a name="ln757">    int ret = def_value;</a>
<a name="ln758"> </a>
<a name="ln759">    if (field == &quot;true&quot; || field == &quot;1&quot; || field == &quot;yes&quot;)</a>
<a name="ln760">        ret = 0;</a>
<a name="ln761"> </a>
<a name="ln762">    if (field == &quot;false&quot; || field == &quot;0&quot; || field == &quot;no&quot;)</a>
<a name="ln763">        ret = -1;</a>
<a name="ln764"> </a>
<a name="ln765">    if (starts_with(field, num_prefix))</a>
<a name="ln766">        ret = atoi(field.c_str() + num_prefix.size());</a>
<a name="ln767"> </a>
<a name="ln768">    return ret;</a>
<a name="ln769">}</a>
<a name="ln770"> </a>
<a name="ln771">void game_options::str_to_enemy_hp_colour(const string &amp;colours, bool prepend)</a>
<a name="ln772">{</a>
<a name="ln773">    vector&lt;string&gt; colour_list = split_string(&quot; &quot;, colours, true, true);</a>
<a name="ln774">    if (prepend)</a>
<a name="ln775">        reverse(colour_list.begin(), colour_list.end());</a>
<a name="ln776">    for (const string &amp;colstr : colour_list)</a>
<a name="ln777">    {</a>
<a name="ln778">        const int col = str_to_colour(colstr);</a>
<a name="ln779">        if (col &lt; 0)</a>
<a name="ln780">        {</a>
<a name="ln781">            Options.report_error(&quot;Bad enemy_hp_colour: %s\n&quot;, colstr.c_str());</a>
<a name="ln782">            return;</a>
<a name="ln783">        }</a>
<a name="ln784">        else if (prepend)</a>
<a name="ln785">            enemy_hp_colour.insert(enemy_hp_colour.begin(), col);</a>
<a name="ln786">        else</a>
<a name="ln787">            enemy_hp_colour.push_back(col);</a>
<a name="ln788">    }</a>
<a name="ln789">}</a>
<a name="ln790"> </a>
<a name="ln791">#ifdef USE_TILE</a>
<a name="ln792">static FixedVector&lt;const char*, TAGPREF_MAX&gt;</a>
<a name="ln793">    tag_prefs(&quot;none&quot;, &quot;tutorial&quot;, &quot;named&quot;, &quot;enemy&quot;);</a>
<a name="ln794"> </a>
<a name="ln795">static tag_pref _str_to_tag_pref(const char *opt)</a>
<a name="ln796">{</a>
<a name="ln797">    for (int i = 0; i &lt; TAGPREF_MAX; i++)</a>
<a name="ln798">    {</a>
<a name="ln799">        if (!strcasecmp(opt, tag_prefs[i]))</a>
<a name="ln800">            return (tag_pref)i;</a>
<a name="ln801">    }</a>
<a name="ln802"> </a>
<a name="ln803">    return TAGPREF_ENEMY;</a>
<a name="ln804">}</a>
<a name="ln805">#endif</a>
<a name="ln806"> </a>
<a name="ln807">void game_options::new_dump_fields(const string &amp;text, bool add, bool prepend)</a>
<a name="ln808">{</a>
<a name="ln809">    // Easy; chardump.cc has most of the intelligence.</a>
<a name="ln810">    vector&lt;string&gt; fields = split_string(&quot;,&quot;, text, true, true);</a>
<a name="ln811">    if (add)</a>
<a name="ln812">        merge_lists(dump_order, fields, prepend);</a>
<a name="ln813">    else</a>
<a name="ln814">    {</a>
<a name="ln815">        for (const string &amp;field : fields)</a>
<a name="ln816">            erase_val(dump_order, field);</a>
<a name="ln817">    }</a>
<a name="ln818">}</a>
<a name="ln819"> </a>
<a name="ln820">static string _correct_spelling(const string&amp; str)</a>
<a name="ln821">{</a>
<a name="ln822">    if (str == &quot;armor_on&quot;)</a>
<a name="ln823">        return &quot;armour_on&quot;;</a>
<a name="ln824">    if (str == &quot;armor_off&quot;)</a>
<a name="ln825">        return &quot;armour_off&quot;;</a>
<a name="ln826">    if (str == &quot;memorize&quot;)</a>
<a name="ln827">        return &quot;memorise&quot;;</a>
<a name="ln828">    if (str == &quot;jewelry_on&quot;)</a>
<a name="ln829">        return &quot;jewellery_on&quot;;</a>
<a name="ln830">    return str;</a>
<a name="ln831">}</a>
<a name="ln832"> </a>
<a name="ln833">void game_options::set_default_activity_interrupts()</a>
<a name="ln834">{</a>
<a name="ln835">    const char *default_activity_interrupts[] =</a>
<a name="ln836">    {</a>
<a name="ln837">        &quot;interrupt_armour_on = hp_loss, monster_attack, monster, mimic&quot;,</a>
<a name="ln838">        &quot;interrupt_armour_off = interrupt_armour_on&quot;,</a>
<a name="ln839">        &quot;interrupt_drop_item = interrupt_armour_on&quot;,</a>
<a name="ln840">        &quot;interrupt_jewellery_on = interrupt_armour_on&quot;,</a>
<a name="ln841">        &quot;interrupt_memorise = hp_loss, monster_attack, stat&quot;,</a>
<a name="ln842">        &quot;interrupt_butcher = interrupt_armour_on, teleport, stat&quot;,</a>
<a name="ln843">        &quot;interrupt_exsanguinate = interrupt_butcher&quot;,</a>
<a name="ln844">        &quot;interrupt_revivify = interrupt_butcher&quot;,</a>
<a name="ln845">        &quot;interrupt_multidrop = hp_loss, monster_attack, teleport, stat&quot;,</a>
<a name="ln846">        &quot;interrupt_macro = interrupt_multidrop&quot;,</a>
<a name="ln847">        &quot;interrupt_travel = interrupt_butcher, hungry, hit_monster, &quot;</a>
<a name="ln848">                            &quot;sense_monster&quot;,</a>
<a name="ln849">        &quot;interrupt_run = interrupt_travel, message&quot;,</a>
<a name="ln850">        &quot;interrupt_rest = interrupt_run, full_hp, full_mp, ancestor_hp&quot;,</a>
<a name="ln851"> </a>
<a name="ln852">        // Stair ascents/descents cannot be interrupted except by</a>
<a name="ln853">        // teleportation. Attempts to interrupt the delay will just</a>
<a name="ln854">        // trash all queued delays, including travel.</a>
<a name="ln855">        &quot;interrupt_ascending_stairs = teleport&quot;,</a>
<a name="ln856">        &quot;interrupt_descending_stairs = teleport&quot;,</a>
<a name="ln857">        // These are totally uninterruptible by default, since it's</a>
<a name="ln858">        // impossible for them to be interrupted anyway.</a>
<a name="ln859">        &quot;interrupt_drop_item = &quot;,</a>
<a name="ln860">        &quot;interrupt_jewellery_off =&quot;,</a>
<a name="ln861">    };</a>
<a name="ln862"> </a>
<a name="ln863">    for (const char* line : default_activity_interrupts)</a>
<a name="ln864">        read_option_line(line, false);</a>
<a name="ln865">}</a>
<a name="ln866"> </a>
<a name="ln867">void game_options::set_activity_interrupt(</a>
<a name="ln868">        FixedBitVector&lt;NUM_ACTIVITY_INTERRUPTS&gt; &amp;eints,</a>
<a name="ln869">        const string &amp;interrupt)</a>
<a name="ln870">{</a>
<a name="ln871">    if (starts_with(interrupt, interrupt_prefix))</a>
<a name="ln872">    {</a>
<a name="ln873">        string delay_name =</a>
<a name="ln874">            _correct_spelling(interrupt.substr(interrupt_prefix.length()));</a>
<a name="ln875">        if (!activity_interrupts.count(delay_name))</a>
<a name="ln876">            return report_error(&quot;Unknown delay: %s\n&quot;, delay_name.c_str());</a>
<a name="ln877"> </a>
<a name="ln878">        FixedBitVector&lt;NUM_ACTIVITY_INTERRUPTS&gt; &amp;refints =</a>
<a name="ln879">            activity_interrupts[delay_name];</a>
<a name="ln880"> </a>
<a name="ln881">        eints |= refints;</a>
<a name="ln882">        return;</a>
<a name="ln883">    }</a>
<a name="ln884"> </a>
<a name="ln885">    activity_interrupt ai = get_activity_interrupt(interrupt);</a>
<a name="ln886">    if (ai == activity_interrupt::COUNT)</a>
<a name="ln887">    {</a>
<a name="ln888">        return report_error(&quot;Delay interrupt name \&quot;%s\&quot; not recognised.\n&quot;,</a>
<a name="ln889">                            interrupt.c_str());</a>
<a name="ln890">    }</a>
<a name="ln891"> </a>
<a name="ln892">    eints.set(static_cast&lt;int&gt;(ai));</a>
<a name="ln893">}</a>
<a name="ln894"> </a>
<a name="ln895">void game_options::set_activity_interrupt(const string &amp;activity_name,</a>
<a name="ln896">                                          const string &amp;interrupt_names,</a>
<a name="ln897">                                          bool append_interrupts,</a>
<a name="ln898">                                          bool remove_interrupts)</a>
<a name="ln899">{</a>
<a name="ln900">    vector&lt;string&gt; interrupts = split_string(&quot;,&quot;, interrupt_names);</a>
<a name="ln901">    auto &amp; eints = activity_interrupts[_correct_spelling(activity_name)];</a>
<a name="ln902"> </a>
<a name="ln903">    if (remove_interrupts)</a>
<a name="ln904">    {</a>
<a name="ln905">        FixedBitVector&lt;NUM_ACTIVITY_INTERRUPTS&gt; refints;</a>
<a name="ln906">        for (const string &amp;interrupt : interrupts)</a>
<a name="ln907">            set_activity_interrupt(refints, interrupt);</a>
<a name="ln908"> </a>
<a name="ln909">        for (int i = 0; i &lt; NUM_ACTIVITY_INTERRUPTS; ++i)</a>
<a name="ln910">            if (refints[i])</a>
<a name="ln911">                eints.set(i, false);</a>
<a name="ln912">    }</a>
<a name="ln913">    else</a>
<a name="ln914">    {</a>
<a name="ln915">        if (!append_interrupts)</a>
<a name="ln916">            eints.reset();</a>
<a name="ln917"> </a>
<a name="ln918">        for (const string &amp;interrupt : interrupts)</a>
<a name="ln919">            set_activity_interrupt(eints, interrupt);</a>
<a name="ln920">    }</a>
<a name="ln921"> </a>
<a name="ln922">    eints.set(static_cast&lt;int&gt;(activity_interrupt::force));</a>
<a name="ln923">}</a>
<a name="ln924"> </a>
<a name="ln925">#if defined(DGAMELAUNCH)</a>
<a name="ln926">static string _resolve_dir(string path, string suffix)</a>
<a name="ln927">{</a>
<a name="ln928">    UNUSED(suffix);</a>
<a name="ln929">    return catpath(path, &quot;&quot;);</a>
<a name="ln930">}</a>
<a name="ln931">#else</a>
<a name="ln932"> </a>
<a name="ln933">static string _user_home_dir()</a>
<a name="ln934">{</a>
<a name="ln935">#ifdef TARGET_OS_WINDOWS</a>
<a name="ln936">    wchar_t home[MAX_PATH];</a>
<a name="ln937">    if (SHGetFolderPathW(0, CSIDL_APPDATA, 0, 0, home))</a>
<a name="ln938">        return &quot;./&quot;;</a>
<a name="ln939">    else</a>
<a name="ln940">        return utf16_to_8(home);</a>
<a name="ln941">#else</a>
<a name="ln942">    const char *home = getenv(&quot;HOME&quot;);</a>
<a name="ln943">    if (!home || !*home)</a>
<a name="ln944">        return &quot;./&quot;;</a>
<a name="ln945">    else</a>
<a name="ln946">        return mb_to_utf8(home);</a>
<a name="ln947">#endif</a>
<a name="ln948">}</a>
<a name="ln949"> </a>
<a name="ln950">static string _user_home_subpath(const string &amp;subpath)</a>
<a name="ln951">{</a>
<a name="ln952">    return catpath(_user_home_dir(), subpath);</a>
<a name="ln953">}</a>
<a name="ln954"> </a>
<a name="ln955">static string _resolve_dir(string path, string suffix)</a>
<a name="ln956">{</a>
<a name="ln957">    if (path[0] != '~')</a>
<a name="ln958">        return catpath(string(path), suffix);</a>
<a name="ln959">    else</a>
<a name="ln960">        return _user_home_subpath(catpath(path.substr(1), suffix));</a>
<a name="ln961">}</a>
<a name="ln962">#endif</a>
<a name="ln963"> </a>
<a name="ln964">static string _get_save_path(string subdir)</a>
<a name="ln965">{</a>
<a name="ln966">    return _resolve_dir(SysEnv.crawl_dir, subdir);</a>
<a name="ln967">}</a>
<a name="ln968"> </a>
<a name="ln969">void game_options::reset_options()</a>
<a name="ln970">{</a>
<a name="ln971">    // XXX: do we really need to rebuild the list and map every time?</a>
<a name="ln972">    // Will they ever change within a single execution of Crawl?</a>
<a name="ln973">    // GameOption::value's value will change of course, but not the reference.</a>
<a name="ln974">    deleteAll(option_behaviour);</a>
<a name="ln975">    option_behaviour = build_options_list();</a>
<a name="ln976">    options_by_name = build_options_map(option_behaviour);</a>
<a name="ln977">    for (GameOption* option : option_behaviour)</a>
<a name="ln978">        option-&gt;reset();</a>
<a name="ln979"> </a>
<a name="ln980">    filename     = &quot;unknown&quot;;</a>
<a name="ln981">    basefilename = &quot;unknown&quot;;</a>
<a name="ln982">    line_num     = -1;</a>
<a name="ln983"> </a>
<a name="ln984">    set_default_activity_interrupts();</a>
<a name="ln985"> </a>
<a name="ln986">#ifdef DEBUG_DIAGNOSTICS</a>
<a name="ln987">    quiet_debug_messages.reset();</a>
<a name="ln988">#ifdef DEBUG_MONSPEAK</a>
<a name="ln989">    quiet_debug_messages.set(DIAG_SPEECH);</a>
<a name="ln990">#endif</a>
<a name="ln991"># ifdef DEBUG_MONINDEX</a>
<a name="ln992">    quiet_debug_messages.set(DIAG_MONINDEX);</a>
<a name="ln993"># endif</a>
<a name="ln994">#endif</a>
<a name="ln995"> </a>
<a name="ln996">    macro_dir = SysEnv.macro_dir;</a>
<a name="ln997"> </a>
<a name="ln998">#ifdef DGAMELAUNCH</a>
<a name="ln999">    save_dir = _get_save_path(&quot;saves/&quot;);</a>
<a name="ln1000">    morgue_dir = _get_save_path(&quot;morgue/&quot;);</a>
<a name="ln1001">#else</a>
<a name="ln1002">    if (macro_dir.empty())</a>
<a name="ln1003">    {</a>
<a name="ln1004">#ifdef UNIX</a>
<a name="ln1005">        macro_dir = _user_home_subpath(&quot;.crawl&quot;);</a>
<a name="ln1006">#else</a>
<a name="ln1007">        macro_dir = &quot;settings/&quot;;</a>
<a name="ln1008">#endif</a>
<a name="ln1009">    }</a>
<a name="ln1010">#endif</a>
<a name="ln1011"> </a>
<a name="ln1012">#if defined(TARGET_OS_MACOSX)</a>
<a name="ln1013">    UNUSED(_resolve_dir);</a>
<a name="ln1014"> </a>
<a name="ln1015">    if (SysEnv.macro_dir.empty())</a>
<a name="ln1016">        macro_dir  = _get_save_path(&quot;&quot;);</a>
<a name="ln1017">#endif</a>
<a name="ln1018"> </a>
<a name="ln1019">#if defined(SHARED_DIR_PATH)</a>
<a name="ln1020">    shared_dir = _resolve_dir(SHARED_DIR_PATH, &quot;&quot;);</a>
<a name="ln1021">#else</a>
<a name="ln1022">    shared_dir = save_dir;</a>
<a name="ln1023">#endif</a>
<a name="ln1024"> </a>
<a name="ln1025">    additional_macro_files.clear();</a>
<a name="ln1026"> </a>
<a name="ln1027">#ifdef DGL_SIMPLE_MESSAGING</a>
<a name="ln1028">    messaging = true;</a>
<a name="ln1029">#endif</a>
<a name="ln1030"> </a>
<a name="ln1031">    autopickup_on    = 1;</a>
<a name="ln1032"> </a>
<a name="ln1033">    game = newgame_def();</a>
<a name="ln1034"> </a>
<a name="ln1035">    char_set      = CSET_DEFAULT;</a>
<a name="ln1036"> </a>
<a name="ln1037">    incremental_pregen = true;</a>
<a name="ln1038">    pregen_dungeon = false;</a>
<a name="ln1039"> </a>
<a name="ln1040">    // set it to the .crawlrc default</a>
<a name="ln1041">    autopickups.reset();</a>
<a name="ln1042">    autopickups.set(OBJ_GOLD);</a>
<a name="ln1043">    autopickups.set(OBJ_SCROLLS);</a>
<a name="ln1044">    autopickups.set(OBJ_POTIONS);</a>
<a name="ln1045">    autopickups.set(OBJ_BOOKS);</a>
<a name="ln1046">    autopickups.set(OBJ_JEWELLERY);</a>
<a name="ln1047">    autopickups.set(OBJ_WANDS);</a>
<a name="ln1048">    autopickups.set(OBJ_FOOD);</a>
<a name="ln1049"> </a>
<a name="ln1050">    confirm_butcher        = confirm_butcher_type::normal;</a>
<a name="ln1051">    auto_butcher           = HS_ENGORGED;</a>
<a name="ln1052">    easy_confirm           = easy_confirm_type::safe;</a>
<a name="ln1053">    allow_self_target      = confirm_prompt_type::prompt;</a>
<a name="ln1054">    skill_focus            = SKM_FOCUS_ON;</a>
<a name="ln1055"> </a>
<a name="ln1056">    user_note_prefix       = &quot;&quot;;</a>
<a name="ln1057"> </a>
<a name="ln1058">    arena_dump_msgs        = false;</a>
<a name="ln1059">    arena_dump_msgs_all    = false;</a>
<a name="ln1060">    arena_list_eq          = false;</a>
<a name="ln1061"> </a>
<a name="ln1062">    // Sort only pickup menus by default.</a>
<a name="ln1063">    sort_menus.clear();</a>
<a name="ln1064">    set_menu_sort(&quot;pickup: true&quot;);</a>
<a name="ln1065"> </a>
<a name="ln1066">    assign_item_slot       = SS_FORWARD;</a>
<a name="ln1067">    show_god_gift          = MB_MAYBE;</a>
<a name="ln1068"> </a>
<a name="ln1069">    explore_stop           = (ES_ITEM | ES_STAIR | ES_PORTAL | ES_BRANCH</a>
<a name="ln1070">                              | ES_SHOP | ES_ALTAR | ES_RUNED_DOOR</a>
<a name="ln1071">                              | ES_TRANSPORTER | ES_GREEDY_PICKUP_SMART</a>
<a name="ln1072">                              | ES_GREEDY_VISITED_ITEM_STACK);</a>
<a name="ln1073"> </a>
<a name="ln1074">    dump_kill_places       = KDO_ONE_PLACE;</a>
<a name="ln1075">    dump_item_origins      = IODS_ARTEFACTS;</a>
<a name="ln1076"> </a>
<a name="ln1077">    flush_input[ FLUSH_ON_FAILURE ]     = true;</a>
<a name="ln1078">    flush_input[ FLUSH_BEFORE_COMMAND ] = false;</a>
<a name="ln1079">    flush_input[ FLUSH_ON_MESSAGE ]     = false;</a>
<a name="ln1080">    flush_input[ FLUSH_LUA ]            = true;</a>
<a name="ln1081"> </a>
<a name="ln1082">    fire_items_start       = 0;           // start at slot 'a'</a>
<a name="ln1083"> </a>
<a name="ln1084">    // Clear fire_order and set up the defaults.</a>
<a name="ln1085">    set_fire_order(&quot;launcher,&quot;</a>
<a name="ln1086">                   &quot;javelin / boomerang / stone / rock / net / dart, &quot;</a>
<a name="ln1087">                   &quot;inscribed&quot;,</a>
<a name="ln1088">                   false, false);</a>
<a name="ln1089"> </a>
<a name="ln1090">    // These are only used internally, and only from the commandline:</a>
<a name="ln1091">    // XXX: These need a better place.</a>
<a name="ln1092">    sc_entries             = 0;</a>
<a name="ln1093">    sc_format              = -1;</a>
<a name="ln1094"> </a>
<a name="ln1095">#ifdef DGAMELAUNCH</a>
<a name="ln1096">    restart_after_game = MB_FALSE;</a>
<a name="ln1097">    restart_after_save = false;</a>
<a name="ln1098">    newgame_after_quit = false;</a>
<a name="ln1099">    name_bypasses_menu = true;</a>
<a name="ln1100">#else</a>
<a name="ln1101">#ifdef USE_TILE_LOCAL</a>
<a name="ln1102">    restart_after_game = MB_TRUE;</a>
<a name="ln1103">#else</a>
<a name="ln1104">    restart_after_game = MB_MAYBE;</a>
<a name="ln1105">#endif</a>
<a name="ln1106">#endif</a>
<a name="ln1107"> </a>
<a name="ln1108">#ifdef WIZARD</a>
<a name="ln1109">#ifdef DGAMELAUNCH</a>
<a name="ln1110">    if (wiz_mode != WIZ_NO)</a>
<a name="ln1111">    {</a>
<a name="ln1112">        wiz_mode         = WIZ_NEVER;</a>
<a name="ln1113">        explore_mode     = WIZ_NEVER;</a>
<a name="ln1114">    }</a>
<a name="ln1115">#else</a>
<a name="ln1116">    wiz_mode             = WIZ_NO;</a>
<a name="ln1117">    explore_mode         = WIZ_NO;</a>
<a name="ln1118">#endif</a>
<a name="ln1119">#endif</a>
<a name="ln1120">    terp_files.clear();</a>
<a name="ln1121"> </a>
<a name="ln1122">#ifdef USE_TILE_LOCAL</a>
<a name="ln1123"> </a>
<a name="ln1124">    // window layout</a>
<a name="ln1125">    tile_full_screen      = SCREENMODE_AUTO;</a>
<a name="ln1126">    tile_use_small_layout = MB_MAYBE;</a>
<a name="ln1127">#endif</a>
<a name="ln1128"> </a>
<a name="ln1129">#ifdef USE_TILE</a>
<a name="ln1130">    // XXX: arena may now be chosen after options are read.</a>
<a name="ln1131">    tile_tag_pref         = crawl_state.game_is_arena() ? TAGPREF_NAMED</a>
<a name="ln1132">                                                        : TAGPREF_ENEMY;</a>
<a name="ln1133"> </a>
<a name="ln1134">    tile_use_monster         = MONS_PROGRAM_BUG;</a>
<a name="ln1135">    tile_player_tile         = 0;</a>
<a name="ln1136">    tile_weapon_offsets.first  = INT_MAX;</a>
<a name="ln1137">    tile_weapon_offsets.second = INT_MAX;</a>
<a name="ln1138">    tile_shield_offsets.first  = INT_MAX;</a>
<a name="ln1139">    tile_shield_offsets.second = INT_MAX;</a>
<a name="ln1140">    tile_viewport_scale = 100;</a>
<a name="ln1141">    tile_map_scale      = 60;</a>
<a name="ln1142">#endif</a>
<a name="ln1143"> </a>
<a name="ln1144">#ifdef USE_TILE_WEB</a>
<a name="ln1145">    tile_display_mode = &quot;tiles&quot;;</a>
<a name="ln1146">#endif</a>
<a name="ln1147"> </a>
<a name="ln1148">    // map each colour to itself as default</a>
<a name="ln1149">    for (int i = 0; i &lt; (int)ARRAYSZ(colour); ++i)</a>
<a name="ln1150">        colour[i] = i;</a>
<a name="ln1151"> </a>
<a name="ln1152">    // map each channel to plain (well, default for now since I'm testing)</a>
<a name="ln1153">    for (int i = 0; i &lt; NUM_MESSAGE_CHANNELS; ++i)</a>
<a name="ln1154">        channels[i] = MSGCOL_DEFAULT;</a>
<a name="ln1155"> </a>
<a name="ln1156">    // Clear vector options.</a>
<a name="ln1157">    dump_order.clear();</a>
<a name="ln1158">    new_dump_fields(&quot;header,hiscore,stats,misc,inventory,&quot;</a>
<a name="ln1159">                    &quot;skills,spells,overview,mutations,messages,&quot;</a>
<a name="ln1160">                    &quot;screenshot,monlist,kills,notes,vaults,&quot;</a>
<a name="ln1161">                    &quot;skill_gains,action_counts&quot;);</a>
<a name="ln1162">    // Currently enabled by default for testing in trunk.</a>
<a name="ln1163">    if (Version::ReleaseType == VER_ALPHA)</a>
<a name="ln1164">        new_dump_fields(&quot;xp_by_level&quot;);</a>
<a name="ln1165"> </a>
<a name="ln1166">    use_animations = (UA_BEAM | UA_RANGE | UA_HP | UA_MONSTER_IN_SIGHT</a>
<a name="ln1167">                      | UA_PICKUP | UA_MONSTER | UA_PLAYER | UA_BRANCH_ENTRY</a>
<a name="ln1168">                      | UA_ALWAYS_ON);</a>
<a name="ln1169"> </a>
<a name="ln1170">    enemy_hp_colour.clear();</a>
<a name="ln1171">    // I think these defaults are pretty ugly but apparently OS X has problems</a>
<a name="ln1172">    // with lighter colours</a>
<a name="ln1173">    enemy_hp_colour.push_back(GREEN);</a>
<a name="ln1174">    enemy_hp_colour.push_back(GREEN);</a>
<a name="ln1175">    enemy_hp_colour.push_back(BROWN);</a>
<a name="ln1176">    enemy_hp_colour.push_back(BROWN);</a>
<a name="ln1177">    enemy_hp_colour.push_back(MAGENTA);</a>
<a name="ln1178">    enemy_hp_colour.push_back(RED);</a>
<a name="ln1179"> </a>
<a name="ln1180">    force_autopickup.clear();</a>
<a name="ln1181">    autoinscriptions.clear();</a>
<a name="ln1182">    note_skill_levels.reset();</a>
<a name="ln1183">    note_skill_levels.set(1);</a>
<a name="ln1184">    note_skill_levels.set(5);</a>
<a name="ln1185">    note_skill_levels.set(10);</a>
<a name="ln1186">    note_skill_levels.set(15);</a>
<a name="ln1187">    note_skill_levels.set(27);</a>
<a name="ln1188">    auto_spell_letters.clear();</a>
<a name="ln1189">    auto_item_letters.clear();</a>
<a name="ln1190">    auto_ability_letters.clear();</a>
<a name="ln1191">    force_more_message.clear();</a>
<a name="ln1192">    flash_screen_message.clear();</a>
<a name="ln1193">    sound_mappings.clear();</a>
<a name="ln1194">    menu_colour_mappings.clear();</a>
<a name="ln1195">    message_colour_mappings.clear();</a>
<a name="ln1196">    named_options.clear();</a>
<a name="ln1197"> </a>
<a name="ln1198">    clear_cset_overrides();</a>
<a name="ln1199"> </a>
<a name="ln1200">    clear_feature_overrides();</a>
<a name="ln1201">    mon_glyph_overrides.clear();</a>
<a name="ln1202">    item_glyph_overrides.clear();</a>
<a name="ln1203">    item_glyph_cache.clear();</a>
<a name="ln1204"> </a>
<a name="ln1205">    // Map each category to itself. The user can override in init.txt</a>
<a name="ln1206">    kill_map[KC_YOU] = KC_YOU;</a>
<a name="ln1207">    kill_map[KC_FRIENDLY] = KC_FRIENDLY;</a>
<a name="ln1208">    kill_map[KC_OTHER] = KC_OTHER;</a>
<a name="ln1209"> </a>
<a name="ln1210">    // Forget any files we remembered as included.</a>
<a name="ln1211">    included.clear();</a>
<a name="ln1212"> </a>
<a name="ln1213">    // Forget variables and such.</a>
<a name="ln1214">    aliases.clear();</a>
<a name="ln1215">    variables.clear();</a>
<a name="ln1216">    constants.clear();</a>
<a name="ln1217">}</a>
<a name="ln1218"> </a>
<a name="ln1219">void game_options::clear_cset_overrides()</a>
<a name="ln1220">{</a>
<a name="ln1221">    memset(cset_override, 0, sizeof cset_override);</a>
<a name="ln1222">}</a>
<a name="ln1223"> </a>
<a name="ln1224">void game_options::clear_feature_overrides()</a>
<a name="ln1225">{</a>
<a name="ln1226">    feature_colour_overrides.clear();</a>
<a name="ln1227">    feature_symbol_overrides.clear();</a>
<a name="ln1228">}</a>
<a name="ln1229"> </a>
<a name="ln1230">char32_t get_glyph_override(int c)</a>
<a name="ln1231">{</a>
<a name="ln1232">    if (c &lt; 0)</a>
<a name="ln1233">        c = -c;</a>
<a name="ln1234">    if (wcwidth(c) != 1)</a>
<a name="ln1235">    {</a>
<a name="ln1236">        mprf(MSGCH_ERROR, &quot;Invalid glyph override: %X&quot;, c);</a>
<a name="ln1237">        c = 0;</a>
<a name="ln1238">    }</a>
<a name="ln1239">    return c;</a>
<a name="ln1240">}</a>
<a name="ln1241"> </a>
<a name="ln1242">static int read_symbol(string s)</a>
<a name="ln1243">{</a>
<a name="ln1244">    if (s.empty())</a>
<a name="ln1245">        return 0;</a>
<a name="ln1246"> </a>
<a name="ln1247">    if (s.length() &gt; 1 &amp;&amp; s[0] == '\\')</a>
<a name="ln1248">        s = s.substr(1);</a>
<a name="ln1249"> </a>
<a name="ln1250">    {</a>
<a name="ln1251">        char32_t c;</a>
<a name="ln1252">        const char *nc = s.c_str();</a>
<a name="ln1253">        nc += utf8towc(&amp;c, nc);</a>
<a name="ln1254">        // no control, combining or CJK characters, please</a>
<a name="ln1255">        if (!*nc &amp;&amp; wcwidth(c) == 1)</a>
<a name="ln1256">            return c;</a>
<a name="ln1257">    }</a>
<a name="ln1258"> </a>
<a name="ln1259">    int base = 10;</a>
<a name="ln1260">    if (s.length() &gt; 1 &amp;&amp; s[0] == 'x')</a>
<a name="ln1261">    {</a>
<a name="ln1262">        s = s.substr(1);</a>
<a name="ln1263">        base = 16;</a>
<a name="ln1264">    }</a>
<a name="ln1265"> </a>
<a name="ln1266">    char *tail;</a>
<a name="ln1267">    return strtoul(s.c_str(), &amp;tail, base);</a>
<a name="ln1268">}</a>
<a name="ln1269"> </a>
<a name="ln1270">void game_options::set_fire_order(const string &amp;s, bool append, bool prepend)</a>
<a name="ln1271">{</a>
<a name="ln1272">    if (!append &amp;&amp; !prepend)</a>
<a name="ln1273">        fire_order.clear();</a>
<a name="ln1274">    vector&lt;string&gt; slots = split_string(&quot;,&quot;, s);</a>
<a name="ln1275">    if (prepend)</a>
<a name="ln1276">        reverse(slots.begin(), slots.end());</a>
<a name="ln1277">    for (const string &amp;slot : slots)</a>
<a name="ln1278">        add_fire_order_slot(slot, prepend);</a>
<a name="ln1279">}</a>
<a name="ln1280"> </a>
<a name="ln1281">void game_options::add_fire_order_slot(const string &amp;s, bool prepend)</a>
<a name="ln1282">{</a>
<a name="ln1283">    unsigned flags = 0;</a>
<a name="ln1284">    for (const string &amp;alt : split_string(&quot;/&quot;, s))</a>
<a name="ln1285">        flags |= _str_to_fire_types(alt);</a>
<a name="ln1286"> </a>
<a name="ln1287">    if (flags)</a>
<a name="ln1288">    {</a>
<a name="ln1289">        if (prepend)</a>
<a name="ln1290">            fire_order.insert(fire_order.begin(), flags);</a>
<a name="ln1291">        else</a>
<a name="ln1292">            fire_order.push_back(flags);</a>
<a name="ln1293">    }</a>
<a name="ln1294">}</a>
<a name="ln1295"> </a>
<a name="ln1296">static monster_type _mons_class_by_string(const string &amp;name)</a>
<a name="ln1297">{</a>
<a name="ln1298">    const string match = lowercase_string(name);</a>
<a name="ln1299">    for (monster_type i = MONS_0; i &lt; NUM_MONSTERS; ++i)</a>
<a name="ln1300">    {</a>
<a name="ln1301">        const monsterentry *me = get_monster_data(i);</a>
<a name="ln1302">        if (!me || me-&gt;mc == MONS_PROGRAM_BUG)</a>
<a name="ln1303">            continue;</a>
<a name="ln1304"> </a>
<a name="ln1305">        if (lowercase_string(me-&gt;name) == match)</a>
<a name="ln1306">            return i;</a>
<a name="ln1307">    }</a>
<a name="ln1308">    return MONS_0;</a>
<a name="ln1309">}</a>
<a name="ln1310"> </a>
<a name="ln1311">static set&lt;monster_type&gt; _mons_classes_by_glyph(const char letter)</a>
<a name="ln1312">{</a>
<a name="ln1313">    set&lt;monster_type&gt; matches;</a>
<a name="ln1314">    for (monster_type i = MONS_0; i &lt; NUM_MONSTERS; ++i)</a>
<a name="ln1315">    {</a>
<a name="ln1316">        const monsterentry *me = get_monster_data(i);</a>
<a name="ln1317">        if (!me || me-&gt;mc == MONS_PROGRAM_BUG)</a>
<a name="ln1318">            continue;</a>
<a name="ln1319"> </a>
<a name="ln1320">        if (me-&gt;basechar == letter)</a>
<a name="ln1321">            matches.insert(i);</a>
<a name="ln1322">    }</a>
<a name="ln1323">    return matches;</a>
<a name="ln1324">}</a>
<a name="ln1325"> </a>
<a name="ln1326">cglyph_t game_options::parse_mon_glyph(const string &amp;s) const</a>
<a name="ln1327">{</a>
<a name="ln1328">    cglyph_t md;</a>
<a name="ln1329">    md.col = 0;</a>
<a name="ln1330">    vector&lt;string&gt; phrases = split_string(&quot; &quot;, s);</a>
<a name="ln1331">    for (const string &amp;p : phrases)</a>
<a name="ln1332">    {</a>
<a name="ln1333">        const int col = str_to_colour(p, -1, false);</a>
<a name="ln1334">        if (col != -1)</a>
<a name="ln1335">            md.col = col;</a>
<a name="ln1336">        else</a>
<a name="ln1337">            md.ch = p == &quot;_&quot;? ' ' : read_symbol(p);</a>
<a name="ln1338">    }</a>
<a name="ln1339">    return md;</a>
<a name="ln1340">}</a>
<a name="ln1341"> </a>
<a name="ln1342">void game_options::remove_mon_glyph_override(const string &amp;text, bool /*prepend*/)</a>
<a name="ln1343">{</a>
<a name="ln1344">    vector&lt;string&gt; override = split_string(&quot;:&quot;, text);</a>
<a name="ln1345"> </a>
<a name="ln1346">    set&lt;monster_type&gt; matches;</a>
<a name="ln1347">    if (override[0].length() == 1)</a>
<a name="ln1348">        matches = _mons_classes_by_glyph(override[0][0]);</a>
<a name="ln1349">    else</a>
<a name="ln1350">    {</a>
<a name="ln1351">        const monster_type m = _mons_class_by_string(override[0]);</a>
<a name="ln1352">        if (m == MONS_0)</a>
<a name="ln1353">        {</a>
<a name="ln1354">            report_error(&quot;Unknown monster: \&quot;%s\&quot;&quot;, text.c_str());</a>
<a name="ln1355">            return;</a>
<a name="ln1356">        }</a>
<a name="ln1357">        matches.insert(m);</a>
<a name="ln1358">    }</a>
<a name="ln1359">    for (monster_type m : matches)</a>
<a name="ln1360">        mon_glyph_overrides.erase(m);;</a>
<a name="ln1361">}</a>
<a name="ln1362"> </a>
<a name="ln1363">void game_options::add_mon_glyph_override(const string &amp;text, bool /*prepend*/)</a>
<a name="ln1364">{</a>
<a name="ln1365">    vector&lt;string&gt; override = split_string(&quot;:&quot;, text);</a>
<a name="ln1366">    if (override.size() != 2u)</a>
<a name="ln1367">        return;</a>
<a name="ln1368"> </a>
<a name="ln1369">    set&lt;monster_type&gt; matches;</a>
<a name="ln1370">    if (override[0].length() == 1)</a>
<a name="ln1371">        matches = _mons_classes_by_glyph(override[0][0]);</a>
<a name="ln1372">    else</a>
<a name="ln1373">    {</a>
<a name="ln1374">        const monster_type m = _mons_class_by_string(override[0]);</a>
<a name="ln1375">        if (m == MONS_0)</a>
<a name="ln1376">        {</a>
<a name="ln1377">            report_error(&quot;Unknown monster: \&quot;%s\&quot;&quot;, text.c_str());</a>
<a name="ln1378">            return;</a>
<a name="ln1379">        }</a>
<a name="ln1380">        matches.insert(m);</a>
<a name="ln1381">    }</a>
<a name="ln1382"> </a>
<a name="ln1383">    cglyph_t mdisp;</a>
<a name="ln1384"> </a>
<a name="ln1385">    // Look for monsters first so that &quot;blue devil&quot; works right.</a>
<a name="ln1386">    const monster_type n = _mons_class_by_string(override[1]);</a>
<a name="ln1387">    if (n != MONS_0)</a>
<a name="ln1388">    {</a>
<a name="ln1389">        const monsterentry *me = get_monster_data(n);</a>
<a name="ln1390">        mdisp.ch = me-&gt;basechar;</a>
<a name="ln1391">        mdisp.col = me-&gt;colour;</a>
<a name="ln1392">    }</a>
<a name="ln1393">    else</a>
<a name="ln1394">        mdisp = parse_mon_glyph(override[1]);</a>
<a name="ln1395"> </a>
<a name="ln1396">    if (mdisp.ch || mdisp.col)</a>
<a name="ln1397">        for (monster_type m : matches)</a>
<a name="ln1398">            mon_glyph_overrides[m] = mdisp;</a>
<a name="ln1399">}</a>
<a name="ln1400"> </a>
<a name="ln1401">void game_options::remove_item_glyph_override(const string &amp;text, bool /*prepend*/)</a>
<a name="ln1402">{</a>
<a name="ln1403">    string key = text;</a>
<a name="ln1404">    trim_string(key);</a>
<a name="ln1405"> </a>
<a name="ln1406">    erase_if(item_glyph_overrides,</a>
<a name="ln1407">             [&amp;key](const item_glyph_override_type&amp; arg)</a>
<a name="ln1408">             { return key == arg.first; });</a>
<a name="ln1409">}</a>
<a name="ln1410"> </a>
<a name="ln1411">void game_options::add_item_glyph_override(const string &amp;text, bool prepend)</a>
<a name="ln1412">{</a>
<a name="ln1413">    vector&lt;string&gt; override = split_string(&quot;:&quot;, text);</a>
<a name="ln1414">    if (override.size() != 2u)</a>
<a name="ln1415">        return;</a>
<a name="ln1416"> </a>
<a name="ln1417">    cglyph_t mdisp = parse_mon_glyph(override[1]);</a>
<a name="ln1418">    if (mdisp.ch || mdisp.col)</a>
<a name="ln1419">    {</a>
<a name="ln1420">        if (prepend)</a>
<a name="ln1421">        {</a>
<a name="ln1422">            item_glyph_overrides.emplace(item_glyph_overrides.begin(),</a>
<a name="ln1423">                                               override[0],mdisp);</a>
<a name="ln1424">        }</a>
<a name="ln1425">        else</a>
<a name="ln1426">            item_glyph_overrides.emplace_back(override[0], mdisp);</a>
<a name="ln1427">    }</a>
<a name="ln1428">}</a>
<a name="ln1429"> </a>
<a name="ln1430">void game_options::remove_feature_override(const string &amp;text, bool /*prepend*/)</a>
<a name="ln1431">{</a>
<a name="ln1432">    string fname;</a>
<a name="ln1433">    string::size_type epos = text.rfind(&quot;}&quot;);</a>
<a name="ln1434">    if (epos != string::npos)</a>
<a name="ln1435">        fname = text.substr(0, text.rfind(&quot;{&quot;,epos));</a>
<a name="ln1436">    else</a>
<a name="ln1437">        fname = text;</a>
<a name="ln1438"> </a>
<a name="ln1439">    trim_string(fname);</a>
<a name="ln1440"> </a>
<a name="ln1441">    vector&lt;dungeon_feature_type&gt; feats = features_by_desc(text_pattern(fname));</a>
<a name="ln1442">    for (dungeon_feature_type f : feats)</a>
<a name="ln1443">    {</a>
<a name="ln1444">        feature_colour_overrides.erase(f);</a>
<a name="ln1445">        feature_symbol_overrides.erase(f);</a>
<a name="ln1446">    }</a>
<a name="ln1447">}</a>
<a name="ln1448"> </a>
<a name="ln1449">void game_options::add_feature_override(const string &amp;text, bool /*prepend*/)</a>
<a name="ln1450">{</a>
<a name="ln1451">    string::size_type epos = text.rfind(&quot;}&quot;);</a>
<a name="ln1452">    if (epos == string::npos)</a>
<a name="ln1453">        return;</a>
<a name="ln1454"> </a>
<a name="ln1455">    string::size_type spos = text.rfind(&quot;{&quot;, epos);</a>
<a name="ln1456">    if (spos == string::npos)</a>
<a name="ln1457">        return;</a>
<a name="ln1458"> </a>
<a name="ln1459">    string fname = text.substr(0, spos);</a>
<a name="ln1460">    string props = text.substr(spos + 1, epos - spos - 1);</a>
<a name="ln1461">    vector&lt;string&gt; iprops = split_string(&quot;,&quot;, props, true, true);</a>
<a name="ln1462"> </a>
<a name="ln1463">    if (iprops.size() &lt; 1 || iprops.size() &gt; 7)</a>
<a name="ln1464">        return;</a>
<a name="ln1465"> </a>
<a name="ln1466">    if (iprops.size() &lt; 7)</a>
<a name="ln1467">        iprops.resize(7);</a>
<a name="ln1468"> </a>
<a name="ln1469">    trim_string(fname);</a>
<a name="ln1470">    vector&lt;dungeon_feature_type&gt; feats = features_by_desc(text_pattern(fname));</a>
<a name="ln1471">    if (feats.empty())</a>
<a name="ln1472">        return;</a>
<a name="ln1473"> </a>
<a name="ln1474">    for (const dungeon_feature_type feat : feats)</a>
<a name="ln1475">    {</a>
<a name="ln1476">        if (feat &gt;= NUM_FEATURES)</a>
<a name="ln1477">            continue; // TODO: handle other object types.</a>
<a name="ln1478"> </a>
<a name="ln1479">#define SYM(n, field) if (char32_t s = read_symbol(iprops[n])) \</a>
<a name="ln1480">                          feature_symbol_overrides[feat][n] = s; \</a>
<a name="ln1481">                      else \</a>
<a name="ln1482">                          feature_symbol_overrides[feat][n] = '\0';</a>
<a name="ln1483">        SYM(0, symbol);</a>
<a name="ln1484">        SYM(1, magic_symbol);</a>
<a name="ln1485">#undef SYM</a>
<a name="ln1486">        feature_def &amp;fov(feature_colour_overrides[feat]);</a>
<a name="ln1487">#define COL(n, field) if (colour_t c = str_to_colour(iprops[n], BLACK)) \</a>
<a name="ln1488">                          fov.field = c;</a>
<a name="ln1489">        COL(2, dcolour);</a>
<a name="ln1490">        COL(3, unseen_dcolour);</a>
<a name="ln1491">        COL(4, seen_dcolour);</a>
<a name="ln1492">        COL(5, em_dcolour);</a>
<a name="ln1493">        COL(6, seen_em_dcolour);</a>
<a name="ln1494">#undef COL</a>
<a name="ln1495">    }</a>
<a name="ln1496">}</a>
<a name="ln1497"> </a>
<a name="ln1498">void game_options::add_cset_override(dungeon_char_type dc, int symbol)</a>
<a name="ln1499">{</a>
<a name="ln1500">    cset_override[dc] = get_glyph_override(symbol);</a>
<a name="ln1501">}</a>
<a name="ln1502"> </a>
<a name="ln1503">string find_crawlrc()</a>
<a name="ln1504">{</a>
<a name="ln1505">    const char* locations_data[][2] =</a>
<a name="ln1506">    {</a>
<a name="ln1507">        { SysEnv.crawl_dir.c_str(), &quot;init.txt&quot; },</a>
<a name="ln1508">#ifdef UNIX</a>
<a name="ln1509">        { SysEnv.home.c_str(), &quot;.crawl/init.txt&quot; },</a>
<a name="ln1510">        { SysEnv.home.c_str(), &quot;.crawlrc&quot; },</a>
<a name="ln1511">        { SysEnv.home.c_str(), &quot;init.txt&quot; },</a>
<a name="ln1512">#endif</a>
<a name="ln1513">#ifndef DATA_DIR_PATH</a>
<a name="ln1514">        { &quot;&quot;, &quot;init.txt&quot; },</a>
<a name="ln1515">        { &quot;..&quot;, &quot;init.txt&quot; },</a>
<a name="ln1516">        { &quot;../settings&quot;, &quot;init.txt&quot; },</a>
<a name="ln1517">#endif</a>
<a name="ln1518">        { nullptr, nullptr }                // placeholder to mark end</a>
<a name="ln1519">    };</a>
<a name="ln1520"> </a>
<a name="ln1521">    // We'll look for these files in any supplied -rcdirs.</a>
<a name="ln1522">    static const char *rc_dir_filenames[] =</a>
<a name="ln1523">    {</a>
<a name="ln1524">        &quot;.crawlrc&quot;,</a>
<a name="ln1525">        &quot;init.txt&quot;,</a>
<a name="ln1526">    };</a>
<a name="ln1527"> </a>
<a name="ln1528">    // -rc option always wins.</a>
<a name="ln1529">    if (!SysEnv.crawl_rc.empty())</a>
<a name="ln1530">        return SysEnv.crawl_rc;</a>
<a name="ln1531"> </a>
<a name="ln1532">    // If we have any rcdirs, look in them for files from the</a>
<a name="ln1533">    // rc_dir_names list.</a>
<a name="ln1534">    for (const string &amp;rc_dir : SysEnv.rcdirs)</a>
<a name="ln1535">    {</a>
<a name="ln1536">        for (const string &amp;rc_fn : rc_dir_filenames)</a>
<a name="ln1537">        {</a>
<a name="ln1538">            const string rc(catpath(rc_dir, rc_fn));</a>
<a name="ln1539">            if (file_exists(rc))</a>
<a name="ln1540">                return rc;</a>
<a name="ln1541">        }</a>
<a name="ln1542">    }</a>
<a name="ln1543"> </a>
<a name="ln1544">    // Check all possibilities for init.txt</a>
<a name="ln1545">    for (int i = 0; locations_data[i][1] != nullptr; ++i)</a>
<a name="ln1546">    {</a>
<a name="ln1547">        // Don't look at unset options</a>
<a name="ln1548">        if (locations_data[i][0] != nullptr)</a>
<a name="ln1549">        {</a>
<a name="ln1550">            const string rc = catpath(locations_data[i][0],</a>
<a name="ln1551">                                      locations_data[i][1]);</a>
<a name="ln1552">            if (file_exists(rc))</a>
<a name="ln1553">                return rc;</a>
<a name="ln1554">        }</a>
<a name="ln1555">    }</a>
<a name="ln1556"> </a>
<a name="ln1557">    // Last attempt: pick up init.txt from datafile_path, which will</a>
<a name="ln1558">    // also search the settings/ directory.</a>
<a name="ln1559">    return datafile_path(&quot;init.txt&quot;, false, false);</a>
<a name="ln1560">}</a>
<a name="ln1561"> </a>
<a name="ln1562">static const char* lua_builtins[] =</a>
<a name="ln1563">{</a>
<a name="ln1564">    &quot;clua/stash.lua&quot;,</a>
<a name="ln1565">    &quot;clua/delays.lua&quot;,</a>
<a name="ln1566">    &quot;clua/autofight.lua&quot;,</a>
<a name="ln1567">    &quot;clua/automagic.lua&quot;,</a>
<a name="ln1568">    &quot;clua/kills.lua&quot;,</a>
<a name="ln1569">};</a>
<a name="ln1570"> </a>
<a name="ln1571">static const char* config_defaults[] =</a>
<a name="ln1572">{</a>
<a name="ln1573">    &quot;defaults/autopickup_exceptions.txt&quot;,</a>
<a name="ln1574">    &quot;defaults/runrest_messages.txt&quot;,</a>
<a name="ln1575">    &quot;defaults/standard_colours.txt&quot;,</a>
<a name="ln1576">    &quot;defaults/food_colouring.txt&quot;,</a>
<a name="ln1577">    &quot;defaults/menu_colours.txt&quot;,</a>
<a name="ln1578">    &quot;defaults/glyph_colours.txt&quot;,</a>
<a name="ln1579">    &quot;defaults/messages.txt&quot;,</a>
<a name="ln1580">    &quot;defaults/misc.txt&quot;,</a>
<a name="ln1581">};</a>
<a name="ln1582"> </a>
<a name="ln1583">void read_init_file(bool runscript)</a>
<a name="ln1584">{</a>
<a name="ln1585">    Options.reset_options();</a>
<a name="ln1586"> </a>
<a name="ln1587">    // Load Lua builtins.</a>
<a name="ln1588">#ifdef CLUA_BINDINGS</a>
<a name="ln1589">    if (runscript)</a>
<a name="ln1590">    {</a>
<a name="ln1591">        for (const char *builtin : lua_builtins)</a>
<a name="ln1592">        {</a>
<a name="ln1593">            clua.execfile(builtin, false, false);</a>
<a name="ln1594">            if (!clua.error.empty())</a>
<a name="ln1595">                mprf(MSGCH_ERROR, &quot;Lua error: %s&quot;, clua.error.c_str());</a>
<a name="ln1596">        }</a>
<a name="ln1597">    }</a>
<a name="ln1598"> </a>
<a name="ln1599">    // Load default options.</a>
<a name="ln1600">    for (const char *def_file : config_defaults)</a>
<a name="ln1601">        Options.include(datafile_path(def_file), false, runscript);</a>
<a name="ln1602">#else</a>
<a name="ln1603">    UNUSED(lua_builtins);</a>
<a name="ln1604">    UNUSED(config_defaults);</a>
<a name="ln1605">#endif</a>
<a name="ln1606"> </a>
<a name="ln1607">    // Load early binding extra options from the command line BEFORE init.txt.</a>
<a name="ln1608">    Options.filename     = &quot;extra opts first&quot;;</a>
<a name="ln1609">    Options.basefilename = &quot;extra opts first&quot;;</a>
<a name="ln1610">    Options.line_num     = 0;</a>
<a name="ln1611">    for (const string &amp;extra : SysEnv.extra_opts_first)</a>
<a name="ln1612">    {</a>
<a name="ln1613">        Options.line_num++;</a>
<a name="ln1614">        Options.read_option_line(extra, true);</a>
<a name="ln1615">    }</a>
<a name="ln1616"> </a>
<a name="ln1617">    // Load init.txt.</a>
<a name="ln1618">    const string crawl_rc = find_crawlrc();</a>
<a name="ln1619">    const string init_file_name(crawl_rc);</a>
<a name="ln1620"> </a>
<a name="ln1621">    /**</a>
<a name="ln1622">     Mac OS X apps almost always put their user-modifiable configuration files</a>
<a name="ln1623">     in the Application Support directory. On Mac OS X when DATA_DIR_PATH is</a>
<a name="ln1624">     not defined, place a symbolic link to the init.txt file in crawl_dir</a>
<a name="ln1625">     (probably &quot;~/Library/Application Support/Dungeon Crawl Stone Soup&quot;) where</a>
<a name="ln1626">     the user is likely to go looking for it.</a>
<a name="ln1627">     */</a>
<a name="ln1628">#if defined(TARGET_OS_MACOSX) &amp;&amp; !defined(DATA_DIR_PATH)</a>
<a name="ln1629">    char *cwd = getcwd(NULL, 0);</a>
<a name="ln1630">    if (cwd)</a>
<a name="ln1631">    {</a>
<a name="ln1632">        const string absolute_crawl_rc = is_absolute_path(crawl_rc) ? crawl_rc : catpath(cwd, crawl_rc);</a>
<a name="ln1633">        char *resolved = realpath(absolute_crawl_rc.c_str(), NULL);</a>
<a name="ln1634">        if (resolved)</a>
<a name="ln1635">        {</a>
<a name="ln1636">            const string crawl_dir_init = catpath(SysEnv.crawl_dir.c_str(), &quot;init.txt&quot;);</a>
<a name="ln1637">            symlink(resolved, crawl_dir_init.c_str());</a>
<a name="ln1638">            free(resolved);</a>
<a name="ln1639">        }</a>
<a name="ln1640">        free(cwd);</a>
<a name="ln1641">    }</a>
<a name="ln1642">#endif</a>
<a name="ln1643"> </a>
<a name="ln1644">    FileLineInput f(init_file_name.c_str());</a>
<a name="ln1645"> </a>
<a name="ln1646">    Options.filename = init_file_name;</a>
<a name="ln1647">    Options.line_num = 0;</a>
<a name="ln1648">#ifdef UNIX</a>
<a name="ln1649">    Options.basefilename = &quot;~/.crawlrc&quot;;</a>
<a name="ln1650">#else</a>
<a name="ln1651">    Options.basefilename = &quot;init.txt&quot;;</a>
<a name="ln1652">#endif</a>
<a name="ln1653"> </a>
<a name="ln1654">    if (f.error())</a>
<a name="ln1655">        return;</a>
<a name="ln1656">    Options.read_options(f, runscript);</a>
<a name="ln1657"> </a>
<a name="ln1658">    if (Options.read_persist_options)</a>
<a name="ln1659">    {</a>
<a name="ln1660">        // Read options from a .persist file if one exists.</a>
<a name="ln1661">        clua.load_persist();</a>
<a name="ln1662">        clua.pushglobal(&quot;c_persist.options&quot;);</a>
<a name="ln1663">        if (lua_isstring(clua, -1))</a>
<a name="ln1664">            read_options(lua_tostring(clua, -1), runscript);</a>
<a name="ln1665">        lua_pop(clua, 1);</a>
<a name="ln1666">    }</a>
<a name="ln1667"> </a>
<a name="ln1668">    // Load late binding extra options from the command line AFTER init.txt.</a>
<a name="ln1669">    Options.filename     = &quot;extra opts last&quot;;</a>
<a name="ln1670">    Options.basefilename = &quot;extra opts last&quot;;</a>
<a name="ln1671">    Options.line_num     = 0;</a>
<a name="ln1672">    for (const string &amp;extra : SysEnv.extra_opts_last)</a>
<a name="ln1673">    {</a>
<a name="ln1674">        Options.line_num++;</a>
<a name="ln1675">        Options.read_option_line(extra, true);</a>
<a name="ln1676">    }</a>
<a name="ln1677"> </a>
<a name="ln1678">    Options.filename     = init_file_name;</a>
<a name="ln1679">    Options.basefilename = get_base_filename(init_file_name);</a>
<a name="ln1680">    Options.line_num     = -1;</a>
<a name="ln1681">}</a>
<a name="ln1682"> </a>
<a name="ln1683">newgame_def read_startup_prefs()</a>
<a name="ln1684">{</a>
<a name="ln1685">#ifndef DISABLE_STICKY_STARTUP_OPTIONS</a>
<a name="ln1686">    FileLineInput fl(get_prefs_filename().c_str());</a>
<a name="ln1687">    if (fl.error())</a>
<a name="ln1688">        return newgame_def();</a>
<a name="ln1689"> </a>
<a name="ln1690">    game_options temp;</a>
<a name="ln1691">    temp.read_options(fl, false);</a>
<a name="ln1692"> </a>
<a name="ln1693">    if (!temp.game.allowed_species.empty())</a>
<a name="ln1694">        temp.game.species = temp.game.allowed_species[0];</a>
<a name="ln1695">    if (!temp.game.allowed_jobs.empty())</a>
<a name="ln1696">        temp.game.job = temp.game.allowed_jobs[0];</a>
<a name="ln1697">    if (!temp.game.allowed_weapons.empty())</a>
<a name="ln1698">        temp.game.weapon = temp.game.allowed_weapons[0];</a>
<a name="ln1699">    if (!Options.seed_from_rc)</a>
<a name="ln1700">        Options.seed = temp.seed_from_rc;</a>
<a name="ln1701">    if (!Options.remember_name)</a>
<a name="ln1702">        temp.game.name = &quot;&quot;;</a>
<a name="ln1703">    return temp.game;</a>
<a name="ln1704">#endif // !DISABLE_STICKY_STARTUP_OPTIONS</a>
<a name="ln1705">}</a>
<a name="ln1706"> </a>
<a name="ln1707">#ifndef DISABLE_STICKY_STARTUP_OPTIONS</a>
<a name="ln1708">static void write_newgame_options(const newgame_def&amp; prefs, FILE *f)</a>
<a name="ln1709">{</a>
<a name="ln1710">    if (prefs.type != NUM_GAME_TYPE)</a>
<a name="ln1711">        fprintf(f, &quot;type = %s\n&quot;, gametype_to_str(prefs.type).c_str());</a>
<a name="ln1712">    if (!prefs.map.empty())</a>
<a name="ln1713">        fprintf(f, &quot;map = %s\n&quot;, prefs.map.c_str());</a>
<a name="ln1714">    if (!prefs.arena_teams.empty())</a>
<a name="ln1715">        fprintf(f, &quot;arena_teams = %s\n&quot;, prefs.arena_teams.c_str());</a>
<a name="ln1716">    fprintf(f, &quot;name = %s\n&quot;, prefs.name.c_str());</a>
<a name="ln1717">    if (prefs.species != SP_UNKNOWN)</a>
<a name="ln1718">        fprintf(f, &quot;species = %s\n&quot;, _species_to_str(prefs.species).c_str());</a>
<a name="ln1719">    if (prefs.job != JOB_UNKNOWN)</a>
<a name="ln1720">        fprintf(f, &quot;background = %s\n&quot;, _job_to_str(prefs.job).c_str());</a>
<a name="ln1721">    if (prefs.weapon != WPN_UNKNOWN)</a>
<a name="ln1722">        fprintf(f, &quot;weapon = %s\n&quot;, _weapon_to_str(prefs.weapon).c_str());</a>
<a name="ln1723">    if (prefs.seed != 0)</a>
<a name="ln1724">        fprintf(f, &quot;game_seed = %&quot; PRIu64 &quot;\n&quot;, prefs.seed);</a>
<a name="ln1725">    fprintf(f, &quot;fully_random = %s\n&quot;, prefs.fully_random ? &quot;yes&quot; : &quot;no&quot;);</a>
<a name="ln1726">}</a>
<a name="ln1727">#endif // !DISABLE_STICKY_STARTUP_OPTIONS</a>
<a name="ln1728"> </a>
<a name="ln1729">void write_newgame_options_file(const newgame_def&amp; prefs)</a>
<a name="ln1730">{</a>
<a name="ln1731">#ifndef DISABLE_STICKY_STARTUP_OPTIONS</a>
<a name="ln1732">    // [ds] Saving startup prefs should work like this:</a>
<a name="ln1733">    //</a>
<a name="ln1734">    // 1. If the game is started without specifying a game type, always</a>
<a name="ln1735">    //    save startup preferences in the base savedir.</a>
<a name="ln1736">    // 2. If the game is started with a game type (Sprint), save startup</a>
<a name="ln1737">    //    preferences in the game-specific savedir.</a>
<a name="ln1738">    //</a>
<a name="ln1739">    // The idea is that public servers can use one instance of Crawl</a>
<a name="ln1740">    // but present Crawl and Sprint as two separate games in the</a>
<a name="ln1741">    // server-specific game menu -- the startup prefs file for Crawl and</a>
<a name="ln1742">    // Sprint should never collide, because the public server config will</a>
<a name="ln1743">    // specify the game type on the command-line.</a>
<a name="ln1744">    //</a>
<a name="ln1745">    // For normal users, startup prefs should always be saved in the</a>
<a name="ln1746">    // same base savedir so that when they start Crawl with &quot;./crawl&quot;</a>
<a name="ln1747">    // or the equivalent, their last game choices will be remembered,</a>
<a name="ln1748">    // even if they chose a Sprint game.</a>
<a name="ln1749">    //</a>
<a name="ln1750">    // Yes, this is unnecessarily complex. Better ideas welcome.</a>
<a name="ln1751">    //</a>
<a name="ln1752">    unwind_var&lt;game_type&gt; gt(crawl_state.type, Options.game.type);</a>
<a name="ln1753"> </a>
<a name="ln1754">    string fn = get_prefs_filename();</a>
<a name="ln1755">    FILE *f = fopen_u(fn.c_str(), &quot;w&quot;);</a>
<a name="ln1756">    if (!f)</a>
<a name="ln1757">        return;</a>
<a name="ln1758">    write_newgame_options(prefs, f);</a>
<a name="ln1759">    fclose(f);</a>
<a name="ln1760">#endif // !DISABLE_STICKY_STARTUP_OPTIONS</a>
<a name="ln1761">}</a>
<a name="ln1762"> </a>
<a name="ln1763">void save_player_name()</a>
<a name="ln1764">{</a>
<a name="ln1765">#ifndef DISABLE_STICKY_STARTUP_OPTIONS</a>
<a name="ln1766">    // Read other preferences</a>
<a name="ln1767">    newgame_def prefs = read_startup_prefs();</a>
<a name="ln1768">    prefs.name = Options.remember_name ? you.your_name : &quot;&quot;;</a>
<a name="ln1769"> </a>
<a name="ln1770">    // And save</a>
<a name="ln1771">    write_newgame_options_file(prefs);</a>
<a name="ln1772">#endif // !DISABLE_STICKY_STARTUP_OPTIONS</a>
<a name="ln1773">}</a>
<a name="ln1774"> </a>
<a name="ln1775">#ifndef DISABLE_STICKY_STARTUP_OPTIONS</a>
<a name="ln1776">// TODO: can these functions be generalized? This is called on game end, maybe</a>
<a name="ln1777">// the entire pref should be updated then?</a>
<a name="ln1778">void save_seed_pref()</a>
<a name="ln1779">{</a>
<a name="ln1780">#ifndef DGAMELAUNCH</a>
<a name="ln1781">    if (!crawl_state.game_standard_levelgen())</a>
<a name="ln1782">        return;</a>
<a name="ln1783">    // Read other preferences</a>
<a name="ln1784">    newgame_def prefs = read_startup_prefs();</a>
<a name="ln1785">    prefs.seed = crawl_state.seed;</a>
<a name="ln1786"> </a>
<a name="ln1787">    // And save</a>
<a name="ln1788">    write_newgame_options_file(prefs);</a>
<a name="ln1789">#endif</a>
<a name="ln1790">}</a>
<a name="ln1791">#endif // !DISABLE_STICKY_STARTUP_OPTIONS</a>
<a name="ln1792"> </a>
<a name="ln1793">void read_options(const string &amp;s, bool runscript, bool clear_aliases)</a>
<a name="ln1794">{</a>
<a name="ln1795">    StringLineInput st(s);</a>
<a name="ln1796">    Options.read_options(st, runscript, clear_aliases);</a>
<a name="ln1797">}</a>
<a name="ln1798"> </a>
<a name="ln1799">game_options::game_options()</a>
<a name="ln1800">    : seed(0), seed_from_rc(0),</a>
<a name="ln1801">    no_save(false), language(lang_t::EN), lang_name(nullptr)</a>
<a name="ln1802">{</a>
<a name="ln1803">    reset_options();</a>
<a name="ln1804">}</a>
<a name="ln1805"> </a>
<a name="ln1806">game_options::~game_options()</a>
<a name="ln1807">{</a>
<a name="ln1808">    deleteAll(option_behaviour);</a>
<a name="ln1809">}</a>
<a name="ln1810"> </a>
<a name="ln1811">void game_options::read_options(LineInput &amp;il, bool runscript,</a>
<a name="ln1812">                                bool clear_aliases)</a>
<a name="ln1813">{</a>
<a name="ln1814">    unsigned int line = 0;</a>
<a name="ln1815"> </a>
<a name="ln1816">    bool inscriptblock = false;</a>
<a name="ln1817">    bool inscriptcond  = false;</a>
<a name="ln1818">    bool isconditional = false;</a>
<a name="ln1819"> </a>
<a name="ln1820">    bool l_init        = false;</a>
<a name="ln1821"> </a>
<a name="ln1822">    if (clear_aliases)</a>
<a name="ln1823">        aliases.clear();</a>
<a name="ln1824"> </a>
<a name="ln1825">    dlua_chunk luacond(filename);</a>
<a name="ln1826">    dlua_chunk luacode(filename);</a>
<a name="ln1827"> </a>
<a name="ln1828">    while (!il.eof())</a>
<a name="ln1829">    {</a>
<a name="ln1830">        line_num++;</a>
<a name="ln1831">        string s   = il.get_line();</a>
<a name="ln1832">        string str = s;</a>
<a name="ln1833">        line++;</a>
<a name="ln1834"> </a>
<a name="ln1835">        trim_string(str);</a>
<a name="ln1836"> </a>
<a name="ln1837">        // This is to make some efficient comments</a>
<a name="ln1838">        if ((str.empty() || str[0] == '#') &amp;&amp; !inscriptcond &amp;&amp; !inscriptblock)</a>
<a name="ln1839">            continue;</a>
<a name="ln1840"> </a>
<a name="ln1841">        if (!inscriptcond &amp;&amp; str[0] == ':')</a>
<a name="ln1842">        {</a>
<a name="ln1843">            // The init file is now forced into isconditional mode.</a>
<a name="ln1844">            isconditional = true;</a>
<a name="ln1845">            str = str.substr(1);</a>
<a name="ln1846">            if (!str.empty() &amp;&amp; runscript)</a>
<a name="ln1847">            {</a>
<a name="ln1848">                // If we're in the middle of an option block, close it.</a>
<a name="ln1849">                if (!luacond.empty() &amp;&amp; l_init)</a>
<a name="ln1850">                {</a>
<a name="ln1851">                    luacond.add(line - 1, &quot;]])&quot;);</a>
<a name="ln1852">                    l_init = false;</a>
<a name="ln1853">                }</a>
<a name="ln1854">                luacond.add(line, str);</a>
<a name="ln1855">            }</a>
<a name="ln1856">            continue;</a>
<a name="ln1857">        }</a>
<a name="ln1858">        if (!inscriptcond &amp;&amp; (starts_with(str, &quot;L&lt;&quot;) || starts_with(str, &quot;&lt;&quot;)))</a>
<a name="ln1859">        {</a>
<a name="ln1860">            // The init file is now forced into isconditional mode.</a>
<a name="ln1861">            isconditional = true;</a>
<a name="ln1862">            inscriptcond  = true;</a>
<a name="ln1863"> </a>
<a name="ln1864">            str = str.substr(starts_with(str, &quot;L&lt;&quot;) ? 2 : 1);</a>
<a name="ln1865">            // Is this a one-liner?</a>
<a name="ln1866">            if (!str.empty() &amp;&amp; str.back() == '&gt;')</a>
<a name="ln1867">            {</a>
<a name="ln1868">                inscriptcond = false;</a>
<a name="ln1869">                str = str.substr(0, str.length() - 1);</a>
<a name="ln1870">            }</a>
<a name="ln1871"> </a>
<a name="ln1872">            if (!str.empty() &amp;&amp; runscript)</a>
<a name="ln1873">            {</a>
<a name="ln1874">                // If we're in the middle of an option block, close it.</a>
<a name="ln1875">                if (!luacond.empty() &amp;&amp; l_init)</a>
<a name="ln1876">                {</a>
<a name="ln1877">                    luacond.add(line - 1, &quot;]])&quot;);</a>
<a name="ln1878">                    l_init = false;</a>
<a name="ln1879">                }</a>
<a name="ln1880">                luacond.add(line, str);</a>
<a name="ln1881">            }</a>
<a name="ln1882">            continue;</a>
<a name="ln1883">        }</a>
<a name="ln1884">        else if (inscriptcond &amp;&amp; !str.empty()</a>
<a name="ln1885">                 &amp;&amp; (str.find(&quot;&gt;&quot;) == str.length() - 1 || str == &quot;&gt;L&quot;))</a>
<a name="ln1886">        {</a>
<a name="ln1887">            inscriptcond = false;</a>
<a name="ln1888">            str = str.substr(0, str.length() - 1);</a>
<a name="ln1889">            if (!str.empty() &amp;&amp; runscript)</a>
<a name="ln1890">                luacond.add(line, str);</a>
<a name="ln1891">            continue;</a>
<a name="ln1892">        }</a>
<a name="ln1893">        else if (inscriptcond)</a>
<a name="ln1894">        {</a>
<a name="ln1895">            if (runscript)</a>
<a name="ln1896">                luacond.add(line, s);</a>
<a name="ln1897">            continue;</a>
<a name="ln1898">        }</a>
<a name="ln1899"> </a>
<a name="ln1900">        // Handle blocks of Lua</a>
<a name="ln1901">        if (!inscriptblock</a>
<a name="ln1902">            &amp;&amp; (starts_with(str, &quot;Lua{&quot;) || starts_with(str, &quot;{&quot;)))</a>
<a name="ln1903">        {</a>
<a name="ln1904">            inscriptblock = true;</a>
<a name="ln1905">            luacode.clear();</a>
<a name="ln1906">            luacode.set_file(filename);</a>
<a name="ln1907"> </a>
<a name="ln1908">            // Strip leading Lua[</a>
<a name="ln1909">            str = str.substr(starts_with(str, &quot;Lua{&quot;) ? 4 : 1);</a>
<a name="ln1910"> </a>
<a name="ln1911">            if (!str.empty() &amp;&amp; str.find(&quot;}&quot;) == str.length() - 1)</a>
<a name="ln1912">            {</a>
<a name="ln1913">                str = str.substr(0, str.length() - 1);</a>
<a name="ln1914">                inscriptblock = false;</a>
<a name="ln1915">            }</a>
<a name="ln1916"> </a>
<a name="ln1917">            if (!str.empty())</a>
<a name="ln1918">                luacode.add(line, str);</a>
<a name="ln1919"> </a>
<a name="ln1920">            if (!inscriptblock &amp;&amp; runscript)</a>
<a name="ln1921">            {</a>
<a name="ln1922">#ifdef CLUA_BINDINGS</a>
<a name="ln1923">                if (luacode.run(clua))</a>
<a name="ln1924">                {</a>
<a name="ln1925">                    mprf(MSGCH_ERROR, &quot;Lua error: %s&quot;,</a>
<a name="ln1926">                         luacode.orig_error().c_str());</a>
<a name="ln1927">                }</a>
<a name="ln1928">                luacode.clear();</a>
<a name="ln1929">#endif</a>
<a name="ln1930">            }</a>
<a name="ln1931"> </a>
<a name="ln1932">            continue;</a>
<a name="ln1933">        }</a>
<a name="ln1934">        else if (inscriptblock &amp;&amp; (str == &quot;}Lua&quot; || str == &quot;}&quot;))</a>
<a name="ln1935">        {</a>
<a name="ln1936">            inscriptblock = false;</a>
<a name="ln1937">#ifdef CLUA_BINDINGS</a>
<a name="ln1938">            if (runscript)</a>
<a name="ln1939">            {</a>
<a name="ln1940">                if (luacode.run(clua))</a>
<a name="ln1941">                {</a>
<a name="ln1942">                    mprf(MSGCH_ERROR, &quot;Lua error: %s&quot;,</a>
<a name="ln1943">                         luacode.orig_error().c_str());</a>
<a name="ln1944">                }</a>
<a name="ln1945">            }</a>
<a name="ln1946">#endif</a>
<a name="ln1947">            luacode.clear();</a>
<a name="ln1948">            continue;</a>
<a name="ln1949">        }</a>
<a name="ln1950">        else if (inscriptblock)</a>
<a name="ln1951">        {</a>
<a name="ln1952">            luacode.add(line, s);</a>
<a name="ln1953">            continue;</a>
<a name="ln1954">        }</a>
<a name="ln1955"> </a>
<a name="ln1956">        if (isconditional &amp;&amp; runscript)</a>
<a name="ln1957">        {</a>
<a name="ln1958">            if (!l_init)</a>
<a name="ln1959">            {</a>
<a name="ln1960">                luacond.add(line, &quot;crawl.setopt([[&quot;);</a>
<a name="ln1961">                l_init = true;</a>
<a name="ln1962">            }</a>
<a name="ln1963"> </a>
<a name="ln1964">            luacond.add(line, s);</a>
<a name="ln1965">            continue;</a>
<a name="ln1966">        }</a>
<a name="ln1967"> </a>
<a name="ln1968">        read_option_line(str, runscript);</a>
<a name="ln1969">    }</a>
<a name="ln1970"> </a>
<a name="ln1971">#ifdef CLUA_BINDINGS</a>
<a name="ln1972">    if (runscript &amp;&amp; !luacond.empty())</a>
<a name="ln1973">    {</a>
<a name="ln1974">        if (l_init)</a>
<a name="ln1975">            luacond.add(line, &quot;]])&quot;);</a>
<a name="ln1976">        if (luacond.run(clua))</a>
<a name="ln1977">            mprf(MSGCH_ERROR, &quot;Lua error: %s&quot;, luacond.orig_error().c_str());</a>
<a name="ln1978">    }</a>
<a name="ln1979">#endif</a>
<a name="ln1980">}</a>
<a name="ln1981"> </a>
<a name="ln1982">void game_options::fixup_options()</a>
<a name="ln1983">{</a>
<a name="ln1984">    // Validate save_dir</a>
<a name="ln1985">    if (!check_mkdir(&quot;Save directory&quot;, &amp;save_dir))</a>
<a name="ln1986">        end(1, false, &quot;Cannot create save directory '%s'&quot;, save_dir.c_str());</a>
<a name="ln1987"> </a>
<a name="ln1988">    if (!SysEnv.morgue_dir.empty())</a>
<a name="ln1989">        morgue_dir = SysEnv.morgue_dir;</a>
<a name="ln1990"> </a>
<a name="ln1991">    if (!check_mkdir(&quot;Morgue directory&quot;, &amp;morgue_dir))</a>
<a name="ln1992">        end(1, false, &quot;Cannot create morgue directory '%s'&quot;, morgue_dir.c_str());</a>
<a name="ln1993">}</a>
<a name="ln1994"> </a>
<a name="ln1995">static int _str_to_killcategory(const string &amp;s)</a>
<a name="ln1996">{</a>
<a name="ln1997">    static const char *kc[] =</a>
<a name="ln1998">    {</a>
<a name="ln1999">        &quot;you&quot;,</a>
<a name="ln2000">        &quot;friend&quot;,</a>
<a name="ln2001">        &quot;other&quot;,</a>
<a name="ln2002">    };</a>
<a name="ln2003"> </a>
<a name="ln2004">    for (unsigned i = 0; i &lt; ARRAYSZ(kc); ++i)</a>
<a name="ln2005">        if (s == kc[i])</a>
<a name="ln2006">            return i;</a>
<a name="ln2007"> </a>
<a name="ln2008">    return -1;</a>
<a name="ln2009">}</a>
<a name="ln2010"> </a>
<a name="ln2011">#ifdef USE_TILE</a>
<a name="ln2012">void game_options::set_player_tile(const string &amp;field)</a>
<a name="ln2013">{</a>
<a name="ln2014">    if (field == &quot;normal&quot;)</a>
<a name="ln2015">    {</a>
<a name="ln2016">        tile_use_monster = MONS_0;</a>
<a name="ln2017">        tile_player_tile = 0;</a>
<a name="ln2018">        return;</a>
<a name="ln2019">    }</a>
<a name="ln2020">    else if (field == &quot;playermons&quot;)</a>
<a name="ln2021">    {</a>
<a name="ln2022">        tile_use_monster = MONS_PLAYER;</a>
<a name="ln2023">        tile_player_tile = 0;</a>
<a name="ln2024">        return;</a>
<a name="ln2025">    }</a>
<a name="ln2026"> </a>
<a name="ln2027">    vector&lt;string&gt; fields = split_string(&quot;:&quot;, field);</a>
<a name="ln2028">    // Handle tile:&lt;tile-name&gt; values</a>
<a name="ln2029">    if (fields.size() == 2 &amp;&amp; fields[0] == &quot;tile&quot;)</a>
<a name="ln2030">    {</a>
<a name="ln2031">        // A variant tile. We have to find the base tile to look this up inthe</a>
<a name="ln2032">        // tile index.</a>
<a name="ln2033">        if (isdigit(*(fields[1].rbegin())))</a>
<a name="ln2034">        {</a>
<a name="ln2035">            string base_tname = fields[1];</a>
<a name="ln2036">            size_t found = base_tname.rfind('_');</a>
<a name="ln2037">            int offset = 0;</a>
<a name="ln2038">            tileidx_t base_tile = 0;</a>
<a name="ln2039">            if (found != std::string::npos</a>
<a name="ln2040">                &amp;&amp; parse_int(fields[1].substr(found + 1).c_str(), offset))</a>
<a name="ln2041">            {</a>
<a name="ln2042">                base_tname = base_tname.substr(0, found);</a>
<a name="ln2043">                if (!tile_player_index(base_tname.c_str(), &amp;base_tile))</a>
<a name="ln2044">                {</a>
<a name="ln2045">                    report_error(&quot;Can't find base tile \&quot;%s\&quot; of variant &quot;</a>
<a name="ln2046">                                 &quot;tile \&quot;%s\&quot;&quot;, base_tname.c_str(),</a>
<a name="ln2047">                                 fields[1].c_str());</a>
<a name="ln2048">                    return;</a>
<a name="ln2049">                }</a>
<a name="ln2050">                tile_player_tile = tileidx_mon_clamp(base_tile, offset);</a>
<a name="ln2051">            }</a>
<a name="ln2052">        }</a>
<a name="ln2053">        else if (!tile_player_index(fields[1].c_str(), &amp;tile_player_tile))</a>
<a name="ln2054">        {</a>
<a name="ln2055">            report_error(&quot;Unknown tile: \&quot;%s\&quot;&quot;, fields[1].c_str());</a>
<a name="ln2056">            return;</a>
<a name="ln2057">        }</a>
<a name="ln2058">        tile_use_monster = MONS_PLAYER;</a>
<a name="ln2059">    }</a>
<a name="ln2060">    else if (fields.size() == 2 &amp;&amp; fields[0] == &quot;mons&quot;)</a>
<a name="ln2061">    {</a>
<a name="ln2062">        // Handle mons:&lt;monster-name&gt; values</a>
<a name="ln2063">        const monster_type m = _mons_class_by_string(fields[1]);</a>
<a name="ln2064">        if (m == MONS_0)</a>
<a name="ln2065">            report_error(&quot;Unknown monster: \&quot;%s\&quot;&quot;, fields[1].c_str());</a>
<a name="ln2066">        else</a>
<a name="ln2067">        {</a>
<a name="ln2068">            tile_use_monster = m;</a>
<a name="ln2069">            tile_player_tile = 0;</a>
<a name="ln2070">        }</a>
<a name="ln2071">    }</a>
<a name="ln2072">    else</a>
<a name="ln2073">    {</a>
<a name="ln2074">        report_error(&quot;Invalid setting for tile_player_tile: \&quot;%s\&quot;&quot;,</a>
<a name="ln2075">                     field.c_str());</a>
<a name="ln2076">    }</a>
<a name="ln2077">}</a>
<a name="ln2078"> </a>
<a name="ln2079">void game_options::set_tile_offsets(const string &amp;field, bool set_shield)</a>
<a name="ln2080">{</a>
<a name="ln2081">    bool error = false;</a>
<a name="ln2082">    pair&lt;int, int&gt; *offsets;</a>
<a name="ln2083">    if (set_shield)</a>
<a name="ln2084">        offsets = &amp;tile_shield_offsets;</a>
<a name="ln2085">    else</a>
<a name="ln2086">        offsets = &amp;tile_weapon_offsets;</a>
<a name="ln2087"> </a>
<a name="ln2088">    if (field == &quot;reset&quot;)</a>
<a name="ln2089">    {</a>
<a name="ln2090">        offsets-&gt;first = INT_MAX;</a>
<a name="ln2091">        offsets-&gt;second = INT_MAX;</a>
<a name="ln2092">        return;</a>
<a name="ln2093">    }</a>
<a name="ln2094"> </a>
<a name="ln2095">    vector&lt;string&gt; offs = split_string(&quot;,&quot;, field);</a>
<a name="ln2096">    if (offs.size() != 2</a>
<a name="ln2097">        || !parse_int(offs[0].c_str(), offsets-&gt;first)</a>
<a name="ln2098">        || abs(offsets-&gt;first) &gt; 32</a>
<a name="ln2099">        || !parse_int(offs[1].c_str(), offsets-&gt;second)</a>
<a name="ln2100">        || abs(offsets-&gt;second) &gt; 32)</a>
<a name="ln2101">    {</a>
<a name="ln2102">        report_error(&quot;Invalid %s tile offsets: \&quot;%s\&quot;&quot;,</a>
<a name="ln2103">                     set_shield ? &quot;shield&quot; : &quot;weapon&quot;, field.c_str());</a>
<a name="ln2104">        error = true;</a>
<a name="ln2105">    }</a>
<a name="ln2106"> </a>
<a name="ln2107">    if (error)</a>
<a name="ln2108">    {</a>
<a name="ln2109">        offsets-&gt;first = INT_MAX;</a>
<a name="ln2110">        offsets-&gt;second = INT_MAX;</a>
<a name="ln2111">    }</a>
<a name="ln2112">}</a>
<a name="ln2113">#endif // USE_TILE</a>
<a name="ln2114"> </a>
<a name="ln2115">void game_options::do_kill_map(const string &amp;from, const string &amp;to)</a>
<a name="ln2116">{</a>
<a name="ln2117">    int ifrom = _str_to_killcategory(from),</a>
<a name="ln2118">        ito   = _str_to_killcategory(to);</a>
<a name="ln2119">    if (ifrom != -1 &amp;&amp; ito != -1)</a>
<a name="ln2120">        kill_map[ifrom] = ito;</a>
<a name="ln2121">}</a>
<a name="ln2122"> </a>
<a name="ln2123">use_animations_type game_options::read_use_animations(const string &amp;field) const</a>
<a name="ln2124">{</a>
<a name="ln2125">    use_animations_type animations;</a>
<a name="ln2126">    vector&lt;string&gt; types = split_string(&quot;,&quot;, field);</a>
<a name="ln2127">    for (const auto &amp;type : types)</a>
<a name="ln2128">    {</a>
<a name="ln2129">        if (type == &quot;beam&quot;)</a>
<a name="ln2130">            animations |= UA_BEAM;</a>
<a name="ln2131">        else if (type == &quot;range&quot;)</a>
<a name="ln2132">            animations |= UA_RANGE;</a>
<a name="ln2133">        else if (type == &quot;hp&quot;)</a>
<a name="ln2134">            animations |= UA_HP;</a>
<a name="ln2135">        else if (type == &quot;monster_in_sight&quot;)</a>
<a name="ln2136">            animations |= UA_MONSTER_IN_SIGHT;</a>
<a name="ln2137">        else if (type == &quot;pickup&quot;)</a>
<a name="ln2138">            animations |= UA_PICKUP;</a>
<a name="ln2139">        else if (type == &quot;monster&quot;)</a>
<a name="ln2140">            animations |= UA_MONSTER;</a>
<a name="ln2141">        else if (type == &quot;player&quot;)</a>
<a name="ln2142">            animations |= UA_PLAYER;</a>
<a name="ln2143">        else if (type == &quot;branch_entry&quot;)</a>
<a name="ln2144">            animations |= UA_BRANCH_ENTRY;</a>
<a name="ln2145">    }</a>
<a name="ln2146"> </a>
<a name="ln2147">    return animations;</a>
<a name="ln2148">}</a>
<a name="ln2149"> </a>
<a name="ln2150">int game_options::read_explore_stop_conditions(const string &amp;field) const</a>
<a name="ln2151">{</a>
<a name="ln2152">    int conditions = 0;</a>
<a name="ln2153">    vector&lt;string&gt; stops = split_string(&quot;,&quot;, field);</a>
<a name="ln2154">    for (const string &amp;stop : stops)</a>
<a name="ln2155">    {</a>
<a name="ln2156">        const string c = replace_all_of(stop, &quot; &quot;, &quot;_&quot;);</a>
<a name="ln2157">        if (c == &quot;item&quot; || c == &quot;items&quot;)</a>
<a name="ln2158">            conditions |= ES_ITEM;</a>
<a name="ln2159">        else if (c == &quot;greedy_pickup&quot;)</a>
<a name="ln2160">            conditions |= ES_GREEDY_PICKUP;</a>
<a name="ln2161">        else if (c == &quot;greedy_pickup_gold&quot;)</a>
<a name="ln2162">            conditions |= ES_GREEDY_PICKUP_GOLD;</a>
<a name="ln2163">        else if (c == &quot;greedy_pickup_smart&quot;)</a>
<a name="ln2164">            conditions |= ES_GREEDY_PICKUP_SMART;</a>
<a name="ln2165">        else if (c == &quot;greedy_pickup_thrown&quot;)</a>
<a name="ln2166">            conditions |= ES_GREEDY_PICKUP_THROWN;</a>
<a name="ln2167">        else if (c == &quot;shop&quot; || c == &quot;shops&quot;)</a>
<a name="ln2168">            conditions |= ES_SHOP;</a>
<a name="ln2169">        else if (c == &quot;stair&quot; || c == &quot;stairs&quot;)</a>
<a name="ln2170">            conditions |= ES_STAIR;</a>
<a name="ln2171">        else if (c == &quot;branch&quot; || c == &quot;branches&quot;)</a>
<a name="ln2172">            conditions |= ES_BRANCH;</a>
<a name="ln2173">        else if (c == &quot;portal&quot; || c == &quot;portals&quot;)</a>
<a name="ln2174">            conditions |= ES_PORTAL;</a>
<a name="ln2175">        else if (c == &quot;altar&quot; || c == &quot;altars&quot;)</a>
<a name="ln2176">            conditions |= ES_ALTAR;</a>
<a name="ln2177">        else if (c == &quot;runed_door&quot;)</a>
<a name="ln2178">            conditions |= ES_RUNED_DOOR;</a>
<a name="ln2179">        else if (c == &quot;transporter&quot;)</a>
<a name="ln2180">            conditions |= ES_TRANSPORTER;</a>
<a name="ln2181">        else if (c == &quot;greedy_item&quot; || c == &quot;greedy_items&quot;)</a>
<a name="ln2182">            conditions |= ES_GREEDY_ITEM;</a>
<a name="ln2183">        else if (c == &quot;greedy_visited_item_stack&quot;)</a>
<a name="ln2184">            conditions |= ES_GREEDY_VISITED_ITEM_STACK;</a>
<a name="ln2185">        else if (c == &quot;glowing&quot; || c == &quot;glowing_item&quot;</a>
<a name="ln2186">                 || c == &quot;glowing_items&quot;)</a>
<a name="ln2187">            conditions |= ES_GLOWING_ITEM;</a>
<a name="ln2188">        else if (c == &quot;artefact&quot; || c == &quot;artefacts&quot;</a>
<a name="ln2189">                 || c == &quot;artifact&quot; || c == &quot;artifacts&quot;)</a>
<a name="ln2190">            conditions |= ES_ARTEFACT;</a>
<a name="ln2191">        else if (c == &quot;rune&quot; || c == &quot;runes&quot;)</a>
<a name="ln2192">            conditions |= ES_RUNE;</a>
<a name="ln2193">    }</a>
<a name="ln2194">    return conditions;</a>
<a name="ln2195">}</a>
<a name="ln2196"> </a>
<a name="ln2197">// Note the distinction between:</a>
<a name="ln2198">// 1. aliases &quot;ae := autopickup_exception&quot; &quot;ae += useless_item&quot;</a>
<a name="ln2199">//    stored in game_options.aliases.</a>
<a name="ln2200">// 2. variables &quot;$slots := abc&quot; &quot;spell_slots += Dispel undead:$slots&quot;</a>
<a name="ln2201">//    stored in game_options.variables.</a>
<a name="ln2202">// 3. constant variables &quot;$slots = abc&quot;, &quot;constant = slots&quot;.</a>
<a name="ln2203">//    stored in game_options.variables, but with an extra entry in</a>
<a name="ln2204">//    game_options.constants.</a>
<a name="ln2205">void game_options::add_alias(const string &amp;key, const string &amp;val)</a>
<a name="ln2206">{</a>
<a name="ln2207">    if (key[0] == '$')</a>
<a name="ln2208">    {</a>
<a name="ln2209">        string name = key.substr(1);</a>
<a name="ln2210">        // Don't alter if it's a constant.</a>
<a name="ln2211">        if (constants.count(name))</a>
<a name="ln2212">            return;</a>
<a name="ln2213">        variables[name] = val;</a>
<a name="ln2214">    }</a>
<a name="ln2215">    else</a>
<a name="ln2216">        aliases[key] = val;</a>
<a name="ln2217">}</a>
<a name="ln2218"> </a>
<a name="ln2219">string game_options::unalias(const string &amp;key) const</a>
<a name="ln2220">{</a>
<a name="ln2221">    return lookup(aliases, key, key);</a>
<a name="ln2222">}</a>
<a name="ln2223"> </a>
<a name="ln2224">#define IS_VAR_CHAR(c) (isaalpha(c) || c == '_' || c == '-')</a>
<a name="ln2225"> </a>
<a name="ln2226">string game_options::expand_vars(const string &amp;field) const</a>
<a name="ln2227">{</a>
<a name="ln2228">    string field_out = field;</a>
<a name="ln2229"> </a>
<a name="ln2230">    string::size_type curr_pos = 0;</a>
<a name="ln2231"> </a>
<a name="ln2232">    // Only try 100 times, so as to not get stuck in infinite recursion.</a>
<a name="ln2233">    for (int i = 0; i &lt; 100; i++)</a>
<a name="ln2234">    {</a>
<a name="ln2235">        string::size_type dollar_pos = field_out.find(&quot;$&quot;, curr_pos);</a>
<a name="ln2236"> </a>
<a name="ln2237">        if (dollar_pos == string::npos || field_out.size() == (dollar_pos + 1))</a>
<a name="ln2238">            break;</a>
<a name="ln2239"> </a>
<a name="ln2240">        string::size_type start_pos = dollar_pos + 1;</a>
<a name="ln2241"> </a>
<a name="ln2242">        if (!IS_VAR_CHAR(field_out[start_pos]))</a>
<a name="ln2243">            continue;</a>
<a name="ln2244"> </a>
<a name="ln2245">        string::size_type end_pos;</a>
<a name="ln2246">        for (end_pos = start_pos; end_pos + 1 &lt; field_out.size(); end_pos++)</a>
<a name="ln2247">        {</a>
<a name="ln2248">            if (!IS_VAR_CHAR(field_out[end_pos + 1]))</a>
<a name="ln2249">                break;</a>
<a name="ln2250">        }</a>
<a name="ln2251"> </a>
<a name="ln2252">        string var_name = field_out.substr(start_pos, end_pos - start_pos + 1);</a>
<a name="ln2253"> </a>
<a name="ln2254">        auto x = variables.find(var_name);</a>
<a name="ln2255"> </a>
<a name="ln2256">        if (x == variables.end())</a>
<a name="ln2257">        {</a>
<a name="ln2258">            curr_pos = end_pos + 1;</a>
<a name="ln2259">            continue;</a>
<a name="ln2260">        }</a>
<a name="ln2261"> </a>
<a name="ln2262">        string dollar_plus_name = &quot;$&quot;;</a>
<a name="ln2263">        dollar_plus_name += var_name;</a>
<a name="ln2264"> </a>
<a name="ln2265">        field_out = replace_all(field_out, dollar_plus_name, x-&gt;second);</a>
<a name="ln2266"> </a>
<a name="ln2267">        // Start over at beginning</a>
<a name="ln2268">        curr_pos = 0;</a>
<a name="ln2269">    }</a>
<a name="ln2270"> </a>
<a name="ln2271">    return field_out;</a>
<a name="ln2272">}</a>
<a name="ln2273"> </a>
<a name="ln2274">void game_options::add_message_colour_mappings(const string &amp;field,</a>
<a name="ln2275">                                               bool prepend, bool subtract)</a>
<a name="ln2276">{</a>
<a name="ln2277">    vector&lt;string&gt; fragments = split_string(&quot;,&quot;, field);</a>
<a name="ln2278">    if (prepend)</a>
<a name="ln2279">        reverse(fragments.begin(), fragments.end());</a>
<a name="ln2280">    for (const string &amp;fragment : fragments)</a>
<a name="ln2281">        add_message_colour_mapping(fragment, prepend, subtract);</a>
<a name="ln2282">}</a>
<a name="ln2283"> </a>
<a name="ln2284">message_filter game_options::parse_message_filter(const string &amp;filter)</a>
<a name="ln2285">{</a>
<a name="ln2286">    string::size_type pos = filter.find(&quot;:&quot;);</a>
<a name="ln2287">    if (pos &amp;&amp; pos != string::npos)</a>
<a name="ln2288">    {</a>
<a name="ln2289">        string prefix = filter.substr(0, pos);</a>
<a name="ln2290">        int channel = str_to_channel(prefix);</a>
<a name="ln2291">        if (channel != -1 || prefix == &quot;any&quot;)</a>
<a name="ln2292">        {</a>
<a name="ln2293">            string s = filter.substr(pos + 1);</a>
<a name="ln2294">            trim_string(s);</a>
<a name="ln2295">            return message_filter(channel, s);</a>
<a name="ln2296">        }</a>
<a name="ln2297">    }</a>
<a name="ln2298"> </a>
<a name="ln2299">    return message_filter(filter);</a>
<a name="ln2300">}</a>
<a name="ln2301"> </a>
<a name="ln2302">void game_options::add_message_colour_mapping(const string &amp;field,</a>
<a name="ln2303">                                              bool prepend, bool subtract)</a>
<a name="ln2304">{</a>
<a name="ln2305">    vector&lt;string&gt; cmap = split_string(&quot;:&quot;, field, true, true, 1);</a>
<a name="ln2306"> </a>
<a name="ln2307">    if (cmap.size() != 2)</a>
<a name="ln2308">        return;</a>
<a name="ln2309"> </a>
<a name="ln2310">    const int col = str_to_colour(cmap[0]);</a>
<a name="ln2311">    msg_colour_type mcol;</a>
<a name="ln2312">    if (cmap[0] == &quot;mute&quot;)</a>
<a name="ln2313">        mcol = MSGCOL_MUTED;</a>
<a name="ln2314">    else if (col == -1)</a>
<a name="ln2315">        return;</a>
<a name="ln2316">    else</a>
<a name="ln2317">        mcol = msg_colour(col);</a>
<a name="ln2318"> </a>
<a name="ln2319">    message_colour_mapping m = { parse_message_filter(cmap[1]), mcol };</a>
<a name="ln2320">    if (subtract)</a>
<a name="ln2321">        remove_matching(message_colour_mappings, m);</a>
<a name="ln2322">    else if (prepend)</a>
<a name="ln2323">        message_colour_mappings.insert(message_colour_mappings.begin(), m);</a>
<a name="ln2324">    else</a>
<a name="ln2325">        message_colour_mappings.push_back(m);</a>
<a name="ln2326">}</a>
<a name="ln2327"> </a>
<a name="ln2328">// Option syntax is:</a>
<a name="ln2329">// sort_menu = [menu_type:]yes|no|auto:n[:sort_conditions]</a>
<a name="ln2330">void game_options::set_menu_sort(string field)</a>
<a name="ln2331">{</a>
<a name="ln2332">    if (field.empty())</a>
<a name="ln2333">        return;</a>
<a name="ln2334"> </a>
<a name="ln2335">    menu_sort_condition cond(field);</a>
<a name="ln2336"> </a>
<a name="ln2337">    // Overrides all previous settings.</a>
<a name="ln2338">    if (cond.mtype == menu_type::any)</a>
<a name="ln2339">        sort_menus.clear();</a>
<a name="ln2340"> </a>
<a name="ln2341">    // Override existing values, if necessary.</a>
<a name="ln2342">    for (menu_sort_condition &amp;m_cond : sort_menus)</a>
<a name="ln2343">        if (m_cond.mtype == cond.mtype)</a>
<a name="ln2344">        {</a>
<a name="ln2345">            m_cond.sort = cond.sort;</a>
<a name="ln2346">            m_cond.cmp  = cond.cmp;</a>
<a name="ln2347">            return;</a>
<a name="ln2348">        }</a>
<a name="ln2349"> </a>
<a name="ln2350">    sort_menus.push_back(cond);</a>
<a name="ln2351">}</a>
<a name="ln2352"> </a>
<a name="ln2353">// Lots of things use split parse, for some ^= and += should do different things,</a>
<a name="ln2354">// for others they should not. Split parse just pases them along.</a>
<a name="ln2355">void game_options::split_parse(const string &amp;s, const string &amp;separator,</a>
<a name="ln2356">                               void (game_options::*add)(const string &amp;, bool),</a>
<a name="ln2357">                               bool prepend)</a>
<a name="ln2358">{</a>
<a name="ln2359">    const vector&lt;string&gt; defs = split_string(separator, s);</a>
<a name="ln2360">    if (prepend)</a>
<a name="ln2361">    {</a>
<a name="ln2362">        for ( auto it = defs.rbegin() ; it != defs.rend(); ++it)</a>
<a name="ln2363">            (this-&gt;*add)(*it, prepend);</a>
<a name="ln2364">    }</a>
<a name="ln2365">    else</a>
<a name="ln2366">    {</a>
<a name="ln2367">        for ( auto it = defs.begin() ; it != defs.end(); ++it)</a>
<a name="ln2368">            (this-&gt;*add)(*it, prepend);</a>
<a name="ln2369">    }</a>
<a name="ln2370">}</a>
<a name="ln2371"> </a>
<a name="ln2372">void game_options::set_option_fragment(const string &amp;s, bool /*prepend*/)</a>
<a name="ln2373">{</a>
<a name="ln2374">    if (s.empty())</a>
<a name="ln2375">        return;</a>
<a name="ln2376"> </a>
<a name="ln2377">    string::size_type st = s.find(':');</a>
<a name="ln2378">    if (st == string::npos)</a>
<a name="ln2379">    {</a>
<a name="ln2380">        // Boolean option.</a>
<a name="ln2381">        if (s[0] == '!')</a>
<a name="ln2382">            read_option_line(s.substr(1) + &quot; = false&quot;, true);</a>
<a name="ln2383">        else</a>
<a name="ln2384">            read_option_line(s + &quot; = true&quot;, true);</a>
<a name="ln2385">    }</a>
<a name="ln2386">    else</a>
<a name="ln2387">    {</a>
<a name="ln2388">        // key:val option.</a>
<a name="ln2389">        read_option_line(s.substr(0, st) + &quot; = &quot; + s.substr(st + 1), true);</a>
<a name="ln2390">    }</a>
<a name="ln2391">}</a>
<a name="ln2392"> </a>
<a name="ln2393">// Not a method of the game_options class since keybindings aren't</a>
<a name="ln2394">// stored in that class.</a>
<a name="ln2395">static void _bindkey(string field)</a>
<a name="ln2396">{</a>
<a name="ln2397">    const size_t start_bracket = field.find_first_of('[');</a>
<a name="ln2398">    const size_t end_bracket   = field.find_last_of(']');</a>
<a name="ln2399"> </a>
<a name="ln2400">    if (start_bracket == string::npos</a>
<a name="ln2401">        || end_bracket == string::npos</a>
<a name="ln2402">        || start_bracket &gt; end_bracket)</a>
<a name="ln2403">    {</a>
<a name="ln2404">        mprf(MSGCH_ERROR, &quot;Bad bindkey bracketing in '%s'&quot;,</a>
<a name="ln2405">             field.c_str());</a>
<a name="ln2406">        return;</a>
<a name="ln2407">    }</a>
<a name="ln2408"> </a>
<a name="ln2409">    const string key_str = field.substr(start_bracket + 1,</a>
<a name="ln2410">                                        end_bracket - start_bracket - 1);</a>
<a name="ln2411">    const char *s = key_str.c_str();</a>
<a name="ln2412"> </a>
<a name="ln2413">    char32_t wc;</a>
<a name="ln2414">    vector&lt;char32_t&gt; wchars;</a>
<a name="ln2415">    while (int l = utf8towc(&amp;wc, s))</a>
<a name="ln2416">    {</a>
<a name="ln2417">        s += l;</a>
<a name="ln2418">        wchars.push_back(wc);</a>
<a name="ln2419">    }</a>
<a name="ln2420"> </a>
<a name="ln2421">    int key;</a>
<a name="ln2422"> </a>
<a name="ln2423">    // TODO: Function keys.</a>
<a name="ln2424">    if (wchars.size() == 0)</a>
<a name="ln2425">    {</a>
<a name="ln2426">        mprf(MSGCH_ERROR, &quot;No key in bindkey directive '%s'&quot;,</a>
<a name="ln2427">             field.c_str());</a>
<a name="ln2428">        return;</a>
<a name="ln2429">    }</a>
<a name="ln2430">    else if (wchars.size() == 1)</a>
<a name="ln2431">        key = wchars[0];</a>
<a name="ln2432">    else if (wchars.size() == 2)</a>
<a name="ln2433">    {</a>
<a name="ln2434">        // Ctrl + non-ascii is meaningless here.</a>
<a name="ln2435">        if (wchars[0] != '^' || wchars[1] &gt; 127)</a>
<a name="ln2436">        {</a>
<a name="ln2437">            mprf(MSGCH_ERROR, &quot;Invalid key '%s' in bindkey directive '%s'&quot;,</a>
<a name="ln2438">                 key_str.c_str(), field.c_str());</a>
<a name="ln2439">            return;</a>
<a name="ln2440">        }</a>
<a name="ln2441"> </a>
<a name="ln2442">        key = CONTROL(wchars[1]);</a>
<a name="ln2443">    }</a>
<a name="ln2444">    else</a>
<a name="ln2445">    {</a>
<a name="ln2446">        mprf(MSGCH_ERROR, &quot;Invalid key '%s' in bindkey directive '%s'&quot;,</a>
<a name="ln2447">             key_str.c_str(), field.c_str());</a>
<a name="ln2448">        return;</a>
<a name="ln2449">    }</a>
<a name="ln2450"> </a>
<a name="ln2451">    const size_t start_name = field.find_first_not_of(' ', end_bracket + 1);</a>
<a name="ln2452">    if (start_name == string::npos)</a>
<a name="ln2453">    {</a>
<a name="ln2454">        mprf(MSGCH_ERROR, &quot;No command name for bindkey directive '%s'&quot;,</a>
<a name="ln2455">             field.c_str());</a>
<a name="ln2456">        return;</a>
<a name="ln2457">    }</a>
<a name="ln2458"> </a>
<a name="ln2459">    const string       name = field.substr(start_name);</a>
<a name="ln2460">    const command_type cmd  = name_to_command(name);</a>
<a name="ln2461">    if (cmd == CMD_NO_CMD)</a>
<a name="ln2462">    {</a>
<a name="ln2463">        mprf(MSGCH_ERROR, &quot;No command named '%s'&quot;, name.c_str());</a>
<a name="ln2464">        return;</a>
<a name="ln2465">    }</a>
<a name="ln2466"> </a>
<a name="ln2467">    bind_command_to_key(cmd, key);</a>
<a name="ln2468">}</a>
<a name="ln2469"> </a>
<a name="ln2470">static bool _is_autopickup_ban(pair&lt;text_pattern, bool&gt; entry)</a>
<a name="ln2471">{</a>
<a name="ln2472">    return !entry.second;</a>
<a name="ln2473">}</a>
<a name="ln2474"> </a>
<a name="ln2475">void game_options::read_option_line(const string &amp;str, bool runscript)</a>
<a name="ln2476">{</a>
<a name="ln2477">#define NEWGAME_OPTION(_opt, _conv, _type)                                     \</a>
<a name="ln2478">    if (plain)                                                                 \</a>
<a name="ln2479">        _opt.clear();                                                          \</a>
<a name="ln2480">    for (const auto &amp;part : split_string(&quot;,&quot;, field))                          \</a>
<a name="ln2481">    {                                                                          \</a>
<a name="ln2482">        if (minus_equal)                                                       \</a>
<a name="ln2483">        {                                                                      \</a>
<a name="ln2484">            auto it2 = find(_opt.begin(), _opt.end(), _conv(part));            \</a>
<a name="ln2485">            if (it2 != _opt.end())                                             \</a>
<a name="ln2486">                _opt.erase(it2);                                               \</a>
<a name="ln2487">        }                                                                      \</a>
<a name="ln2488">        else                                                                   \</a>
<a name="ln2489">            _opt.push_back(_conv(part));                                       \</a>
<a name="ln2490">    }</a>
<a name="ln2491">    string key    = &quot;&quot;;</a>
<a name="ln2492">    string subkey = &quot;&quot;;</a>
<a name="ln2493">    string field  = &quot;&quot;;</a>
<a name="ln2494"> </a>
<a name="ln2495">    bool plus_equal  = false;</a>
<a name="ln2496">    bool caret_equal = false;</a>
<a name="ln2497">    bool minus_equal = false;</a>
<a name="ln2498">    rc_line_type line_type = RCFILE_LINE_EQUALS;</a>
<a name="ln2499"> </a>
<a name="ln2500">    const int first_equals = str.find('=');</a>
<a name="ln2501"> </a>
<a name="ln2502">    // all lines with no equal-signs we ignore</a>
<a name="ln2503">    if (first_equals &lt; 0)</a>
<a name="ln2504">        return;</a>
<a name="ln2505"> </a>
<a name="ln2506">    field = str.substr(first_equals + 1);</a>
<a name="ln2507">    field = expand_vars(field);</a>
<a name="ln2508"> </a>
<a name="ln2509">    string prequal = trimmed_string(str.substr(0, first_equals));</a>
<a name="ln2510"> </a>
<a name="ln2511">    // Is this a case of key += val?</a>
<a name="ln2512">    if (prequal.length() &amp;&amp; prequal[prequal.length() - 1] == '+')</a>
<a name="ln2513">    {</a>
<a name="ln2514">        plus_equal = true;</a>
<a name="ln2515">        line_type = RCFILE_LINE_PLUS;</a>
<a name="ln2516">        prequal = prequal.substr(0, prequal.length() - 1);</a>
<a name="ln2517">        trim_string(prequal);</a>
<a name="ln2518">    }</a>
<a name="ln2519">    else if (prequal.length() &amp;&amp; prequal[prequal.length() - 1] == '-')</a>
<a name="ln2520">    {</a>
<a name="ln2521">        minus_equal = true;</a>
<a name="ln2522">        line_type = RCFILE_LINE_MINUS;</a>
<a name="ln2523">        prequal = prequal.substr(0, prequal.length() - 1);</a>
<a name="ln2524">        trim_string(prequal);</a>
<a name="ln2525">    }</a>
<a name="ln2526">    else if (prequal.length() &amp;&amp; prequal[prequal.length() - 1] == '^')</a>
<a name="ln2527">    {</a>
<a name="ln2528">        caret_equal = true;</a>
<a name="ln2529">        line_type = RCFILE_LINE_CARET;</a>
<a name="ln2530">        prequal = prequal.substr(0, prequal.length() - 1);</a>
<a name="ln2531">        trim_string(prequal);</a>
<a name="ln2532">    }</a>
<a name="ln2533">    else if (prequal.length() &amp;&amp; prequal[prequal.length() - 1] == ':')</a>
<a name="ln2534">    {</a>
<a name="ln2535">        prequal = prequal.substr(0, prequal.length() - 1);</a>
<a name="ln2536">        trim_string(prequal);</a>
<a name="ln2537">        trim_string(field);</a>
<a name="ln2538"> </a>
<a name="ln2539">        add_alias(prequal, field);</a>
<a name="ln2540">        return;</a>
<a name="ln2541">    }</a>
<a name="ln2542"> </a>
<a name="ln2543">    bool plain = !plus_equal &amp;&amp; !minus_equal &amp;&amp; !caret_equal;</a>
<a name="ln2544"> </a>
<a name="ln2545">    prequal = unalias(prequal);</a>
<a name="ln2546"> </a>
<a name="ln2547">    const string::size_type first_dot = prequal.find('.');</a>
<a name="ln2548">    if (first_dot != string::npos)</a>
<a name="ln2549">    {</a>
<a name="ln2550">        key    = prequal.substr(0, first_dot);</a>
<a name="ln2551">        subkey = prequal.substr(first_dot + 1);</a>
<a name="ln2552">    }</a>
<a name="ln2553">    else</a>
<a name="ln2554">    {</a>
<a name="ln2555">        // no subkey (dots are okay in value field)</a>
<a name="ln2556">        key    = prequal;</a>
<a name="ln2557">    }</a>
<a name="ln2558"> </a>
<a name="ln2559">    // Clean up our data...</a>
<a name="ln2560">    lowercase(trim_string(key));</a>
<a name="ln2561">    lowercase(trim_string(subkey));</a>
<a name="ln2562"> </a>
<a name="ln2563">    // some fields want capitals... none care about external spaces</a>
<a name="ln2564">    trim_string(field);</a>
<a name="ln2565"> </a>
<a name="ln2566">    // Keep unlowercased field around</a>
<a name="ln2567">    const string orig_field = field;</a>
<a name="ln2568"> </a>
<a name="ln2569">    if (key != &quot;name&quot; &amp;&amp; key != &quot;crawl_dir&quot; &amp;&amp; key != &quot;macro_dir&quot;</a>
<a name="ln2570">        &amp;&amp; key != &quot;combo&quot;</a>
<a name="ln2571">        &amp;&amp; key != &quot;species&quot; &amp;&amp; key != &quot;background&quot; &amp;&amp; key != &quot;job&quot;</a>
<a name="ln2572">        &amp;&amp; key != &quot;race&quot; &amp;&amp; key != &quot;class&quot; &amp;&amp; key != &quot;ban_pickup&quot;</a>
<a name="ln2573">        &amp;&amp; key != &quot;autopickup_exceptions&quot;</a>
<a name="ln2574">        &amp;&amp; key != &quot;explore_stop_pickup_ignore&quot;</a>
<a name="ln2575">        &amp;&amp; key != &quot;stop_travel&quot;</a>
<a name="ln2576">        &amp;&amp; key != &quot;force_more_message&quot;</a>
<a name="ln2577">        &amp;&amp; key != &quot;flash_screen_message&quot;</a>
<a name="ln2578">        &amp;&amp; key != &quot;confirm_action&quot;</a>
<a name="ln2579">        &amp;&amp; key != &quot;drop_filter&quot; &amp;&amp; key != &quot;lua_file&quot; &amp;&amp; key != &quot;terp_file&quot;</a>
<a name="ln2580">        &amp;&amp; key != &quot;note_items&quot; &amp;&amp; key != &quot;autoinscribe&quot;</a>
<a name="ln2581">        &amp;&amp; key != &quot;note_monsters&quot; &amp;&amp; key != &quot;note_messages&quot;</a>
<a name="ln2582">        &amp;&amp; key != &quot;display_char&quot; &amp;&amp; !starts_with(key, &quot;cset&quot;) // compatibility</a>
<a name="ln2583">        &amp;&amp; key != &quot;dungeon&quot; &amp;&amp; key != &quot;feature&quot;</a>
<a name="ln2584">        &amp;&amp; key != &quot;mon_glyph&quot; &amp;&amp; key != &quot;item_glyph&quot;</a>
<a name="ln2585">        &amp;&amp; key != &quot;fire_items_start&quot;</a>
<a name="ln2586">        &amp;&amp; key != &quot;opt&quot; &amp;&amp; key != &quot;option&quot;</a>
<a name="ln2587">        &amp;&amp; key != &quot;menu_colour&quot; &amp;&amp; key != &quot;menu_color&quot;</a>
<a name="ln2588">        &amp;&amp; key != &quot;message_colour&quot; &amp;&amp; key != &quot;message_color&quot;</a>
<a name="ln2589">        &amp;&amp; key != &quot;levels&quot; &amp;&amp; key != &quot;level&quot; &amp;&amp; key != &quot;entries&quot;</a>
<a name="ln2590">        &amp;&amp; key != &quot;include&quot; &amp;&amp; key != &quot;bindkey&quot;</a>
<a name="ln2591">        &amp;&amp; key != &quot;spell_slot&quot;</a>
<a name="ln2592">        &amp;&amp; key != &quot;item_slot&quot;</a>
<a name="ln2593">        &amp;&amp; key != &quot;ability_slot&quot;</a>
<a name="ln2594">        &amp;&amp; key != &quot;sound&quot; &amp;&amp; key != &quot;hold_sound&quot; &amp;&amp; key != &quot;sound_file_path&quot;</a>
<a name="ln2595">        &amp;&amp; key.find(&quot;font&quot;) == string::npos)</a>
<a name="ln2596">    {</a>
<a name="ln2597">        lowercase(field);</a>
<a name="ln2598">    }</a>
<a name="ln2599"> </a>
<a name="ln2600">    GameOption *const *option = map_find(options_by_name, key);</a>
<a name="ln2601">    if (option)</a>
<a name="ln2602">    {</a>
<a name="ln2603">        const string error = (*option)-&gt;loadFromString(field, line_type);</a>
<a name="ln2604">        if (!error.empty())</a>
<a name="ln2605">            report_error(&quot;%s&quot;, error.c_str());</a>
<a name="ln2606">    }</a>
<a name="ln2607">    else if (key == &quot;include&quot;)</a>
<a name="ln2608">        include(field, true, runscript);</a>
<a name="ln2609">    else if (key == &quot;opt&quot; || key == &quot;option&quot;)</a>
<a name="ln2610">        split_parse(field, &quot;,&quot;, &amp;game_options::set_option_fragment);</a>
<a name="ln2611">    else if (key == &quot;autopickup&quot;)</a>
<a name="ln2612">    {</a>
<a name="ln2613">        // clear out autopickup</a>
<a name="ln2614">        autopickups.reset();</a>
<a name="ln2615"> </a>
<a name="ln2616">        char32_t c;</a>
<a name="ln2617">        for (const char* tp = field.c_str(); int s = utf8towc(&amp;c, tp); tp += s)</a>
<a name="ln2618">        {</a>
<a name="ln2619">            object_class_type type = item_class_by_sym(c);</a>
<a name="ln2620"> </a>
<a name="ln2621">            if (type &lt; NUM_OBJECT_CLASSES)</a>
<a name="ln2622">                autopickups.set(type);</a>
<a name="ln2623">            else</a>
<a name="ln2624">                report_error(&quot;Bad object type '%*s' for autopickup.\n&quot;, s, tp);</a>
<a name="ln2625">        }</a>
<a name="ln2626">    }</a>
<a name="ln2627">#if !defined(DGAMELAUNCH) || defined(DGL_REMEMBER_NAME)</a>
<a name="ln2628">    else if (key == &quot;name&quot;)</a>
<a name="ln2629">    {</a>
<a name="ln2630">        // field is already cleaned up from trim_string()</a>
<a name="ln2631">        game.name = field;</a>
<a name="ln2632">    }</a>
<a name="ln2633">#endif</a>
<a name="ln2634">    else if (key == &quot;char_set&quot;)</a>
<a name="ln2635">    {</a>
<a name="ln2636">        if (field == &quot;ascii&quot;)</a>
<a name="ln2637">            char_set = CSET_ASCII;</a>
<a name="ln2638">        else if (field == &quot;default&quot;)</a>
<a name="ln2639">            char_set = CSET_DEFAULT;</a>
<a name="ln2640">        else</a>
<a name="ln2641">            fprintf(stderr, &quot;Bad character set: %s\n&quot;, field.c_str());</a>
<a name="ln2642">    }</a>
<a name="ln2643">    else if (key == &quot;language&quot;)</a>
<a name="ln2644">    {</a>
<a name="ln2645">        if (!set_lang(field.c_str()))</a>
<a name="ln2646">        {</a>
<a name="ln2647">            report_error(&quot;No translations for language '%s'.\n&quot;</a>
<a name="ln2648">                         &quot;Languages with at least partial translation: %s&quot;,</a>
<a name="ln2649">                         field.c_str(), _supported_language_listing().c_str());</a>
<a name="ln2650">        }</a>
<a name="ln2651">    }</a>
<a name="ln2652">    else if (key == &quot;fake_lang&quot;)</a>
<a name="ln2653">        set_fake_langs(field);</a>
<a name="ln2654">    else if (key == &quot;default_autopickup&quot;)</a>
<a name="ln2655">    {</a>
<a name="ln2656">        if (read_bool(field, true))</a>
<a name="ln2657">            autopickup_on = 1;</a>
<a name="ln2658">        else</a>
<a name="ln2659">            autopickup_on = 0;</a>
<a name="ln2660">    }</a>
<a name="ln2661">    else if (key == &quot;easy_confirm&quot;)</a>
<a name="ln2662">    {</a>
<a name="ln2663">        // decide when to allow both 'Y'/'N' and 'y'/'n' on yesno() prompts</a>
<a name="ln2664">        if (field == &quot;none&quot;)</a>
<a name="ln2665">            easy_confirm = easy_confirm_type::none;</a>
<a name="ln2666">        else if (field == &quot;safe&quot;)</a>
<a name="ln2667">            easy_confirm = easy_confirm_type::safe;</a>
<a name="ln2668">        else if (field == &quot;all&quot;)</a>
<a name="ln2669">            easy_confirm = easy_confirm_type::all;</a>
<a name="ln2670">    }</a>
<a name="ln2671">    else if (key == &quot;allow_self_target&quot;)</a>
<a name="ln2672">    {</a>
<a name="ln2673">        if (field == &quot;yes&quot;)</a>
<a name="ln2674">            allow_self_target = confirm_prompt_type::none;</a>
<a name="ln2675">        else if (field == &quot;no&quot;)</a>
<a name="ln2676">            allow_self_target = confirm_prompt_type::cancel;</a>
<a name="ln2677">        else if (field == &quot;prompt&quot;)</a>
<a name="ln2678">            allow_self_target = confirm_prompt_type::prompt;</a>
<a name="ln2679">    }</a>
<a name="ln2680">    else if (key == &quot;confirm_butcher&quot;)</a>
<a name="ln2681">    {</a>
<a name="ln2682">        if (field == &quot;always&quot;)</a>
<a name="ln2683">            confirm_butcher = confirm_butcher_type::always;</a>
<a name="ln2684">        else if (field == &quot;never&quot;)</a>
<a name="ln2685">            confirm_butcher = confirm_butcher_type::never;</a>
<a name="ln2686">        else if (field == &quot;auto&quot;)</a>
<a name="ln2687">            confirm_butcher = confirm_butcher_type::normal;</a>
<a name="ln2688">    }</a>
<a name="ln2689">    else if (key == &quot;auto_butcher&quot;)</a>
<a name="ln2690">    {</a>
<a name="ln2691">        if (field == &quot;true&quot; || field == &quot;engorged&quot;)</a>
<a name="ln2692">            auto_butcher = HS_ENGORGED;</a>
<a name="ln2693">        else if (field == &quot;very full&quot;)</a>
<a name="ln2694">            auto_butcher = HS_VERY_FULL;</a>
<a name="ln2695">        else if (field == &quot;full&quot;)</a>
<a name="ln2696">            auto_butcher = HS_FULL;</a>
<a name="ln2697">        else if (field == &quot;satiated&quot;)</a>
<a name="ln2698">            auto_butcher = HS_SATIATED;</a>
<a name="ln2699">        else if (field == &quot;hungry&quot;)</a>
<a name="ln2700">            auto_butcher = HS_HUNGRY;</a>
<a name="ln2701">        else if (field == &quot;very hungry&quot;)</a>
<a name="ln2702">            auto_butcher = HS_VERY_HUNGRY;</a>
<a name="ln2703">        else if (field == &quot;near starving&quot;)</a>
<a name="ln2704">            auto_butcher = HS_NEAR_STARVING;</a>
<a name="ln2705">        else if (field == &quot;false&quot; || field == &quot;starving&quot;)</a>
<a name="ln2706">            auto_butcher = HS_STARVING;</a>
<a name="ln2707">    }</a>
<a name="ln2708">    else if (key == &quot;lua_file&quot; &amp;&amp; runscript)</a>
<a name="ln2709">    {</a>
<a name="ln2710">#ifdef CLUA_BINDINGS</a>
<a name="ln2711">        clua.execfile(field.c_str(), false, false);</a>
<a name="ln2712">        if (!clua.error.empty())</a>
<a name="ln2713">            mprf(MSGCH_ERROR, &quot;Lua error: %s&quot;, clua.error.c_str());</a>
<a name="ln2714">#endif</a>
<a name="ln2715">    }</a>
<a name="ln2716">    else if (key == &quot;terp_file&quot; &amp;&amp; runscript)</a>
<a name="ln2717">        terp_files.push_back(field);</a>
<a name="ln2718">    else if (key == &quot;colour&quot; || key == &quot;color&quot;)</a>
<a name="ln2719">    {</a>
<a name="ln2720">        const int orig_col   = str_to_colour(subkey);</a>
<a name="ln2721">        const int result_col = str_to_colour(field);</a>
<a name="ln2722"> </a>
<a name="ln2723">        if (orig_col != -1 &amp;&amp; result_col != -1)</a>
<a name="ln2724">            colour[orig_col] = result_col;</a>
<a name="ln2725">        else</a>
<a name="ln2726">        {</a>
<a name="ln2727">            fprintf(stderr, &quot;Bad colour -- %s=%d or %s=%d\n&quot;,</a>
<a name="ln2728">                     subkey.c_str(), orig_col, field.c_str(), result_col);</a>
<a name="ln2729">        }</a>
<a name="ln2730">    }</a>
<a name="ln2731">    else if (key == &quot;channel&quot;)</a>
<a name="ln2732">    {</a>
<a name="ln2733">        const int chnl = str_to_channel(subkey);</a>
<a name="ln2734">        const msg_colour_type col  = _str_to_channel_colour(field);</a>
<a name="ln2735"> </a>
<a name="ln2736">        if (chnl != -1 &amp;&amp; col != MSGCOL_NONE)</a>
<a name="ln2737">            channels[chnl] = col;</a>
<a name="ln2738">        else if (chnl == -1)</a>
<a name="ln2739">            fprintf(stderr, &quot;Bad channel -- %s\n&quot;, subkey.c_str());</a>
<a name="ln2740">        else if (col == MSGCOL_NONE)</a>
<a name="ln2741">            fprintf(stderr, &quot;Bad colour -- %s\n&quot;, field.c_str());</a>
<a name="ln2742">    }</a>
<a name="ln2743">    else if (key == &quot;use_animations&quot;)</a>
<a name="ln2744">    {</a>
<a name="ln2745">        if (plain)</a>
<a name="ln2746">            use_animations = UA_ALWAYS_ON;</a>
<a name="ln2747"> </a>
<a name="ln2748">        const auto new_animations = read_use_animations(field);</a>
<a name="ln2749">        if (minus_equal)</a>
<a name="ln2750">            use_animations &amp;= ~new_animations;</a>
<a name="ln2751">        else</a>
<a name="ln2752">            use_animations |= new_animations;</a>
<a name="ln2753">    }</a>
<a name="ln2754">    else if (starts_with(key, interrupt_prefix))</a>
<a name="ln2755">    {</a>
<a name="ln2756">        set_activity_interrupt(key.substr(interrupt_prefix.length()),</a>
<a name="ln2757">                               field,</a>
<a name="ln2758">                               plus_equal || caret_equal,</a>
<a name="ln2759">                               minus_equal);</a>
<a name="ln2760">    }</a>
<a name="ln2761">    else if (key == &quot;display_char&quot;</a>
<a name="ln2762">             || starts_with(key, &quot;cset&quot;)) // compatibility with old rcfiles</a>
<a name="ln2763">    {</a>
<a name="ln2764">        for (const string &amp;over : split_string(&quot;,&quot;, field))</a>
<a name="ln2765">        {</a>
<a name="ln2766">            vector&lt;string&gt; mapping = split_string(&quot;:&quot;, over);</a>
<a name="ln2767">            if (mapping.size() != 2)</a>
<a name="ln2768">                continue;</a>
<a name="ln2769"> </a>
<a name="ln2770">            dungeon_char_type dc = dchar_by_name(mapping[0]);</a>
<a name="ln2771">            if (dc == NUM_DCHAR_TYPES)</a>
<a name="ln2772">                continue;</a>
<a name="ln2773"> </a>
<a name="ln2774">            add_cset_override(dc, read_symbol(mapping[1]));</a>
<a name="ln2775">        }</a>
<a name="ln2776">    }</a>
<a name="ln2777">    else if (key == &quot;feature&quot; || key == &quot;dungeon&quot;)</a>
<a name="ln2778">    {</a>
<a name="ln2779">        if (plain)</a>
<a name="ln2780">           clear_feature_overrides();</a>
<a name="ln2781"> </a>
<a name="ln2782">        if (minus_equal)</a>
<a name="ln2783">            split_parse(field, &quot;;&quot;, &amp;game_options::remove_feature_override);</a>
<a name="ln2784">        else</a>
<a name="ln2785">            split_parse(field, &quot;;&quot;, &amp;game_options::add_feature_override);</a>
<a name="ln2786">    }</a>
<a name="ln2787">    else if (key == &quot;mon_glyph&quot;)</a>
<a name="ln2788">    {</a>
<a name="ln2789">        if (plain)</a>
<a name="ln2790">           mon_glyph_overrides.clear();</a>
<a name="ln2791"> </a>
<a name="ln2792">        if (minus_equal)</a>
<a name="ln2793">            split_parse(field, &quot;,&quot;, &amp;game_options::remove_mon_glyph_override);</a>
<a name="ln2794">        else</a>
<a name="ln2795">            split_parse(field, &quot;,&quot;, &amp;game_options::add_mon_glyph_override);</a>
<a name="ln2796">    }</a>
<a name="ln2797">    else if (key == &quot;item_glyph&quot;)</a>
<a name="ln2798">    {</a>
<a name="ln2799">        if (plain)</a>
<a name="ln2800">        {</a>
<a name="ln2801">            item_glyph_overrides.clear();</a>
<a name="ln2802">            item_glyph_cache.clear();</a>
<a name="ln2803">        }</a>
<a name="ln2804"> </a>
<a name="ln2805">        if (minus_equal)</a>
<a name="ln2806">            split_parse(field, &quot;,&quot;, &amp;game_options::remove_item_glyph_override);</a>
<a name="ln2807">        else</a>
<a name="ln2808">            split_parse(field, &quot;,&quot;, &amp;game_options::add_item_glyph_override, caret_equal);</a>
<a name="ln2809">    }</a>
<a name="ln2810">    else if (key == &quot;arena_teams&quot;)</a>
<a name="ln2811">        game.arena_teams = field;</a>
<a name="ln2812">    // [ds] Allow changing map only if the map hasn't been set on the</a>
<a name="ln2813">    // command-line.</a>
<a name="ln2814">    else if (key == &quot;map&quot; &amp;&amp; crawl_state.sprint_map.empty())</a>
<a name="ln2815">        game.map = field;</a>
<a name="ln2816">    // [ds] For dgamelaunch setups, the player should *not* be able to</a>
<a name="ln2817">    // set game type in their rc; the only way to set game type for</a>
<a name="ln2818">    // DGL builds should be the command-line options.</a>
<a name="ln2819">    else if (key == &quot;type&quot;)</a>
<a name="ln2820">    {</a>
<a name="ln2821">#if defined(DGAMELAUNCH)</a>
<a name="ln2822">        game.type = Options.game.type;</a>
<a name="ln2823">#else</a>
<a name="ln2824">        game.type = _str_to_gametype(field);</a>
<a name="ln2825">#endif</a>
<a name="ln2826">    }</a>
<a name="ln2827">    else if (key == &quot;combo&quot;)</a>
<a name="ln2828">    {</a>
<a name="ln2829">        game.allowed_species.clear();</a>
<a name="ln2830">        game.allowed_jobs.clear();</a>
<a name="ln2831">        game.allowed_weapons.clear();</a>
<a name="ln2832">        NEWGAME_OPTION(game.allowed_combos, string, string);</a>
<a name="ln2833">    }</a>
<a name="ln2834">    else if (key == &quot;fully_random&quot;)</a>
<a name="ln2835">        game.fully_random = read_bool(field, game.fully_random);</a>
<a name="ln2836">    else if (key == &quot;species&quot; || key == &quot;race&quot;)</a>
<a name="ln2837">    {</a>
<a name="ln2838">        game.allowed_combos.clear();</a>
<a name="ln2839">        NEWGAME_OPTION(game.allowed_species, _str_to_species,</a>
<a name="ln2840">                       species_type);</a>
<a name="ln2841">    }</a>
<a name="ln2842">    else if (key == &quot;background&quot; || key == &quot;job&quot; || key == &quot;class&quot;)</a>
<a name="ln2843">    {</a>
<a name="ln2844">        game.allowed_combos.clear();</a>
<a name="ln2845">        NEWGAME_OPTION(game.allowed_jobs, str_to_job, job_type);</a>
<a name="ln2846">    }</a>
<a name="ln2847">    else if (key == &quot;weapon&quot;)</a>
<a name="ln2848">    {</a>
<a name="ln2849">        // Choose this weapon for backgrounds that get choice.</a>
<a name="ln2850">        game.allowed_combos.clear();</a>
<a name="ln2851">        NEWGAME_OPTION(game.allowed_weapons, str_to_weapon, weapon_type);</a>
<a name="ln2852">    }</a>
<a name="ln2853">    else if (key == &quot;fire_items_start&quot;)</a>
<a name="ln2854">    {</a>
<a name="ln2855">        if (isaalpha(field[0]))</a>
<a name="ln2856">            fire_items_start = letter_to_index(field[0]);</a>
<a name="ln2857">        else</a>
<a name="ln2858">        {</a>
<a name="ln2859">            fprintf(stderr, &quot;Bad fire item start index: %s\n&quot;,</a>
<a name="ln2860">                     field.c_str());</a>
<a name="ln2861">        }</a>
<a name="ln2862">    }</a>
<a name="ln2863">    else if (key == &quot;assign_item_slot&quot;)</a>
<a name="ln2864">    {</a>
<a name="ln2865">        if (field == &quot;forward&quot;)</a>
<a name="ln2866">            assign_item_slot = SS_FORWARD;</a>
<a name="ln2867">        else if (field == &quot;backward&quot;)</a>
<a name="ln2868">            assign_item_slot = SS_BACKWARD;</a>
<a name="ln2869">    }</a>
<a name="ln2870">#ifndef DGAMELAUNCH</a>
<a name="ln2871">    else if (key == &quot;restart_after_game&quot;)</a>
<a name="ln2872">        restart_after_game = read_maybe_bool(field);</a>
<a name="ln2873">#endif</a>
<a name="ln2874">    else if (key == &quot;show_god_gift&quot;)</a>
<a name="ln2875">    {</a>
<a name="ln2876">        if (field == &quot;yes&quot;)</a>
<a name="ln2877">            show_god_gift = MB_TRUE;</a>
<a name="ln2878">        else if (field == &quot;unid&quot; || field == &quot;unident&quot; || field == &quot;unidentified&quot;)</a>
<a name="ln2879">            show_god_gift = MB_MAYBE;</a>
<a name="ln2880">        else if (field == &quot;no&quot;)</a>
<a name="ln2881">            show_god_gift = MB_FALSE;</a>
<a name="ln2882">        else</a>
<a name="ln2883">            report_error(&quot;Unknown show_god_gift value: %s\n&quot;, field.c_str());</a>
<a name="ln2884">    }</a>
<a name="ln2885">    else if (key == &quot;fire_order&quot;)</a>
<a name="ln2886">        set_fire_order(field, plus_equal, caret_equal);</a>
<a name="ln2887">#ifndef DGAMELAUNCH</a>
<a name="ln2888">    // If DATA_DIR_PATH is set, don't set crawl_dir from .crawlrc.</a>
<a name="ln2889">#ifndef DATA_DIR_PATH</a>
<a name="ln2890">    else if (key == &quot;crawl_dir&quot;)</a>
<a name="ln2891">    {</a>
<a name="ln2892">        // We shouldn't bother to allocate this a second time</a>
<a name="ln2893">        // if the user puts two crawl_dir lines in the init file.</a>
<a name="ln2894">        SysEnv.crawl_dir = field;</a>
<a name="ln2895">    }</a>
<a name="ln2896">    else if (key == &quot;macro_dir&quot;)</a>
<a name="ln2897">        macro_dir = field;</a>
<a name="ln2898">#endif</a>
<a name="ln2899">#endif</a>
<a name="ln2900">    else if (key == &quot;view_lock&quot;)</a>
<a name="ln2901">    {</a>
<a name="ln2902">        const bool lock = read_bool(field, true);</a>
<a name="ln2903">        view_lock_x = view_lock_y = lock;</a>
<a name="ln2904">    }</a>
<a name="ln2905">    else if (key == &quot;scroll_margin&quot;)</a>
<a name="ln2906">    {</a>
<a name="ln2907">        int scrollmarg = atoi(field.c_str());</a>
<a name="ln2908">        if (scrollmarg &lt; 0)</a>
<a name="ln2909">            scrollmarg = 0;</a>
<a name="ln2910">        scroll_margin_x = scroll_margin_y = scrollmarg;</a>
<a name="ln2911">    }</a>
<a name="ln2912">    else if (key == &quot;user_note_prefix&quot;)</a>
<a name="ln2913">    {</a>
<a name="ln2914">        // field is already cleaned up from trim_string()</a>
<a name="ln2915">        user_note_prefix = orig_field;</a>
<a name="ln2916">    }</a>
<a name="ln2917">    else if (key == &quot;skill_focus&quot;)</a>
<a name="ln2918">    {</a>
<a name="ln2919">        if (field == &quot;toggle&quot;)</a>
<a name="ln2920">            skill_focus = SKM_FOCUS_TOGGLE;</a>
<a name="ln2921">        else if (read_bool(field, true))</a>
<a name="ln2922">            skill_focus = SKM_FOCUS_ON;</a>
<a name="ln2923">        else</a>
<a name="ln2924">            skill_focus = SKM_FOCUS_OFF;</a>
<a name="ln2925">    }</a>
<a name="ln2926">    else if (key == &quot;flush&quot;)</a>
<a name="ln2927">    {</a>
<a name="ln2928">        if (subkey == &quot;failure&quot;)</a>
<a name="ln2929">        {</a>
<a name="ln2930">            flush_input[FLUSH_ON_FAILURE]</a>
<a name="ln2931">                = read_bool(field, flush_input[FLUSH_ON_FAILURE]);</a>
<a name="ln2932">        }</a>
<a name="ln2933">        else if (subkey == &quot;command&quot;)</a>
<a name="ln2934">        {</a>
<a name="ln2935">            flush_input[FLUSH_BEFORE_COMMAND]</a>
<a name="ln2936">                = read_bool(field, flush_input[FLUSH_BEFORE_COMMAND]);</a>
<a name="ln2937">        }</a>
<a name="ln2938">        else if (subkey == &quot;message&quot;)</a>
<a name="ln2939">        {</a>
<a name="ln2940">            flush_input[FLUSH_ON_MESSAGE]</a>
<a name="ln2941">                = read_bool(field, flush_input[FLUSH_ON_MESSAGE]);</a>
<a name="ln2942">        }</a>
<a name="ln2943">        else if (subkey == &quot;lua&quot;)</a>
<a name="ln2944">        {</a>
<a name="ln2945">            flush_input[FLUSH_LUA]</a>
<a name="ln2946">                = read_bool(field, flush_input[FLUSH_LUA]);</a>
<a name="ln2947">        }</a>
<a name="ln2948">    }</a>
<a name="ln2949">    else if (key == &quot;wiz_mode&quot;)</a>
<a name="ln2950">    {</a>
<a name="ln2951">        // wiz_mode is recognised as a legal key in all compiles -- bwr</a>
<a name="ln2952">#ifdef WIZARD</a>
<a name="ln2953">    #ifndef DGAMELAUNCH</a>
<a name="ln2954">        if (field == &quot;never&quot;)</a>
<a name="ln2955">            wiz_mode = WIZ_NEVER;</a>
<a name="ln2956">        else if (field == &quot;no&quot;)</a>
<a name="ln2957">            wiz_mode = WIZ_NO;</a>
<a name="ln2958">        else if (field == &quot;yes&quot;)</a>
<a name="ln2959">            wiz_mode = WIZ_YES;</a>
<a name="ln2960">        else</a>
<a name="ln2961">            report_error(&quot;Unknown wiz_mode option: %s\n&quot;, field.c_str());</a>
<a name="ln2962">    #endif</a>
<a name="ln2963">#endif</a>
<a name="ln2964">    }</a>
<a name="ln2965">    else if (key == &quot;explore_mode&quot;)</a>
<a name="ln2966">    {</a>
<a name="ln2967">#ifdef WIZARD</a>
<a name="ln2968">    #ifndef DGAMELAUNCH</a>
<a name="ln2969">        if (field == &quot;never&quot;)</a>
<a name="ln2970">            explore_mode = WIZ_NEVER;</a>
<a name="ln2971">        else if (field == &quot;no&quot;)</a>
<a name="ln2972">            explore_mode = WIZ_NO;</a>
<a name="ln2973">        else if (field == &quot;yes&quot;)</a>
<a name="ln2974">            explore_mode = WIZ_YES;</a>
<a name="ln2975">        else</a>
<a name="ln2976">            report_error(&quot;Unknown explore_mode option: %s\n&quot;, field.c_str());</a>
<a name="ln2977">    #endif</a>
<a name="ln2978">#endif</a>
<a name="ln2979">    }</a>
<a name="ln2980">    else if (key == &quot;ban_pickup&quot;)</a>
<a name="ln2981">    {</a>
<a name="ln2982">        // Only remove negative, not positive, exceptions.</a>
<a name="ln2983">        if (plain)</a>
<a name="ln2984">            erase_if(force_autopickup, _is_autopickup_ban);</a>
<a name="ln2985"> </a>
<a name="ln2986">        vector&lt;pair&lt;text_pattern, bool&gt; &gt; new_entries;</a>
<a name="ln2987">        for (const string &amp;s : split_string(&quot;,&quot;, field))</a>
<a name="ln2988">        {</a>
<a name="ln2989">            if (s.empty())</a>
<a name="ln2990">                continue;</a>
<a name="ln2991"> </a>
<a name="ln2992">            const pair&lt;text_pattern, bool&gt; f_a(s, false);</a>
<a name="ln2993"> </a>
<a name="ln2994">            if (minus_equal)</a>
<a name="ln2995">                remove_matching(force_autopickup, f_a);</a>
<a name="ln2996">            else</a>
<a name="ln2997">                new_entries.push_back(f_a);</a>
<a name="ln2998">        }</a>
<a name="ln2999">        merge_lists(force_autopickup, new_entries, caret_equal);</a>
<a name="ln3000">    }</a>
<a name="ln3001">    else if (key == &quot;autopickup_exceptions&quot;)</a>
<a name="ln3002">    {</a>
<a name="ln3003">        if (plain)</a>
<a name="ln3004">            force_autopickup.clear();</a>
<a name="ln3005"> </a>
<a name="ln3006">        vector&lt;pair&lt;text_pattern, bool&gt; &gt; new_entries;</a>
<a name="ln3007">        for (const string &amp;s : split_string(&quot;,&quot;, field))</a>
<a name="ln3008">        {</a>
<a name="ln3009">            if (s.empty())</a>
<a name="ln3010">                continue;</a>
<a name="ln3011"> </a>
<a name="ln3012">            pair&lt;text_pattern, bool&gt; f_a;</a>
<a name="ln3013"> </a>
<a name="ln3014">            if (s[0] == '&gt;')</a>
<a name="ln3015">                f_a = make_pair(s.substr(1), false);</a>
<a name="ln3016">            else if (s[0] == '&lt;')</a>
<a name="ln3017">                f_a = make_pair(s.substr(1), true);</a>
<a name="ln3018">            else</a>
<a name="ln3019">                f_a = make_pair(s, false);</a>
<a name="ln3020"> </a>
<a name="ln3021">            if (minus_equal)</a>
<a name="ln3022">                remove_matching(force_autopickup, f_a);</a>
<a name="ln3023">            else</a>
<a name="ln3024">                new_entries.push_back(f_a);</a>
<a name="ln3025">        }</a>
<a name="ln3026">        merge_lists(force_autopickup, new_entries, caret_equal);</a>
<a name="ln3027">    }</a>
<a name="ln3028">#ifndef _MSC_VER</a>
<a name="ln3029">    // break if-else chain on broken Microsoft compilers with stupid nesting limits</a>
<a name="ln3030">    else</a>
<a name="ln3031">#endif</a>
<a name="ln3032"> </a>
<a name="ln3033">    if (key == &quot;autoinscribe&quot;)</a>
<a name="ln3034">    {</a>
<a name="ln3035">        if (plain)</a>
<a name="ln3036">            autoinscriptions.clear();</a>
<a name="ln3037"> </a>
<a name="ln3038">        const size_t first = field.find_first_of(':');</a>
<a name="ln3039">        const size_t last  = field.find_last_of(':');</a>
<a name="ln3040">        if (first == string::npos || first != last)</a>
<a name="ln3041">        {</a>
<a name="ln3042">            return report_error(&quot;Autoinscribe string must have exactly &quot;</a>
<a name="ln3043">                                &quot;one colon: %s\n&quot;, field.c_str());</a>
<a name="ln3044">        }</a>
<a name="ln3045"> </a>
<a name="ln3046">        if (first == 0)</a>
<a name="ln3047">        {</a>
<a name="ln3048">            report_error(&quot;Autoinscribe pattern is empty: %s\n&quot;, field.c_str());</a>
<a name="ln3049">            return;</a>
<a name="ln3050">        }</a>
<a name="ln3051"> </a>
<a name="ln3052">        if (last == field.length() - 1)</a>
<a name="ln3053">        {</a>
<a name="ln3054">            report_error(&quot;Autoinscribe result is empty: %s\n&quot;, field.c_str());</a>
<a name="ln3055">            return;</a>
<a name="ln3056">        }</a>
<a name="ln3057"> </a>
<a name="ln3058">        vector&lt;string&gt; thesplit = split_string(&quot;:&quot;, field);</a>
<a name="ln3059"> </a>
<a name="ln3060">        if (thesplit.size() != 2)</a>
<a name="ln3061">        {</a>
<a name="ln3062">            report_error(&quot;Error parsing autoinscribe string: %s\n&quot;,</a>
<a name="ln3063">                         field.c_str());</a>
<a name="ln3064">            return;</a>
<a name="ln3065">        }</a>
<a name="ln3066"> </a>
<a name="ln3067">        pair&lt;text_pattern,string&gt; entry(thesplit[0], thesplit[1]);</a>
<a name="ln3068"> </a>
<a name="ln3069">        if (minus_equal)</a>
<a name="ln3070">            remove_matching(autoinscriptions, entry);</a>
<a name="ln3071">        else if (caret_equal)</a>
<a name="ln3072">            autoinscriptions.insert(autoinscriptions.begin(), entry);</a>
<a name="ln3073">        else</a>
<a name="ln3074">            autoinscriptions.push_back(entry);</a>
<a name="ln3075">    }</a>
<a name="ln3076">    else if (key == &quot;enemy_hp_colour&quot; || key == &quot;enemy_hp_color&quot;)</a>
<a name="ln3077">    {</a>
<a name="ln3078">        if (plain)</a>
<a name="ln3079">            enemy_hp_colour.clear();</a>
<a name="ln3080">        str_to_enemy_hp_colour(field, caret_equal);</a>
<a name="ln3081">    }</a>
<a name="ln3082">    else if (key == &quot;monster_list_colour&quot; || key == &quot;monster_list_color&quot;)</a>
<a name="ln3083">    {</a>
<a name="ln3084">        if (plain)</a>
<a name="ln3085">            clear_monster_list_colours();</a>
<a name="ln3086"> </a>
<a name="ln3087">        vector&lt;string&gt; thesplit = split_string(&quot;,&quot;, field);</a>
<a name="ln3088">        for (unsigned i = 0; i &lt; thesplit.size(); ++i)</a>
<a name="ln3089">        {</a>
<a name="ln3090">            vector&lt;string&gt; insplit = split_string(&quot;:&quot;, thesplit[i]);</a>
<a name="ln3091"> </a>
<a name="ln3092">            if (insplit.empty() || insplit.size() &gt; 2</a>
<a name="ln3093">                 || insplit.size() == 1 &amp;&amp; !minus_equal</a>
<a name="ln3094">                 || insplit.size() == 2 &amp;&amp; minus_equal)</a>
<a name="ln3095">            {</a>
<a name="ln3096">                report_error(&quot;Bad monster_list_colour string: %s\n&quot;,</a>
<a name="ln3097">                             field.c_str());</a>
<a name="ln3098">                break;</a>
<a name="ln3099">            }</a>
<a name="ln3100"> </a>
<a name="ln3101">            const int scolour = minus_equal ? -1 : str_to_colour(insplit[1]);</a>
<a name="ln3102"> </a>
<a name="ln3103">            // No elemental colours!</a>
<a name="ln3104">            if (scolour &gt;= 16 || scolour &lt; 0 &amp;&amp; !minus_equal)</a>
<a name="ln3105">            {</a>
<a name="ln3106">                report_error(&quot;Bad monster_list_colour: %s&quot;, insplit[1].c_str());</a>
<a name="ln3107">                break;</a>
<a name="ln3108">            }</a>
<a name="ln3109">            if (!set_monster_list_colour(insplit[0], scolour))</a>
<a name="ln3110">            {</a>
<a name="ln3111">                report_error(&quot;Bad monster_list_colour key: %s\n&quot;,</a>
<a name="ln3112">                             insplit[0].c_str());</a>
<a name="ln3113">                break;</a>
<a name="ln3114">            }</a>
<a name="ln3115">        }</a>
<a name="ln3116">    }</a>
<a name="ln3117"> </a>
<a name="ln3118">    else if (key == &quot;note_skill_levels&quot;)</a>
<a name="ln3119">    {</a>
<a name="ln3120">        if (plain)</a>
<a name="ln3121">            note_skill_levels.reset();</a>
<a name="ln3122">        vector&lt;string&gt; thesplit = split_string(&quot;,&quot;, field);</a>
<a name="ln3123">        for (unsigned i = 0; i &lt; thesplit.size(); ++i)</a>
<a name="ln3124">        {</a>
<a name="ln3125">            int num = atoi(thesplit[i].c_str());</a>
<a name="ln3126">            if (num &gt; 0 &amp;&amp; num &lt;= 27)</a>
<a name="ln3127">                note_skill_levels.set(num, !minus_equal);</a>
<a name="ln3128">            else</a>
<a name="ln3129">            {</a>
<a name="ln3130">                report_error(&quot;Bad skill level to note -- %s\n&quot;,</a>
<a name="ln3131">                             thesplit[i].c_str());</a>
<a name="ln3132">                continue;</a>
<a name="ln3133">            }</a>
<a name="ln3134">        }</a>
<a name="ln3135">    }</a>
<a name="ln3136">    else if (key == &quot;spell_slot&quot;</a>
<a name="ln3137">             || key == &quot;item_slot&quot;</a>
<a name="ln3138">             || key == &quot;ability_slot&quot;)</a>
<a name="ln3139"> </a>
<a name="ln3140">    {</a>
<a name="ln3141">        auto&amp; auto_letters = (key == &quot;item_slot&quot;  ? auto_item_letters</a>
<a name="ln3142">                           : (key == &quot;spell_slot&quot; ? auto_spell_letters</a>
<a name="ln3143">                                                  : auto_ability_letters));</a>
<a name="ln3144">        if (plain)</a>
<a name="ln3145">            auto_letters.clear();</a>
<a name="ln3146"> </a>
<a name="ln3147">        vector&lt;string&gt; thesplit = split_string(&quot;:&quot;, field);</a>
<a name="ln3148">        if (thesplit.size() != 2)</a>
<a name="ln3149">        {</a>
<a name="ln3150">            return report_error(&quot;Error parsing %s string: %s\n&quot;,</a>
<a name="ln3151">                                key.c_str(), field.c_str());</a>
<a name="ln3152">        }</a>
<a name="ln3153">        pair&lt;text_pattern,string&gt; entry(text_pattern(thesplit[0], true),</a>
<a name="ln3154">                                        thesplit[1]);</a>
<a name="ln3155"> </a>
<a name="ln3156">        if (minus_equal)</a>
<a name="ln3157">            remove_matching(auto_letters, entry);</a>
<a name="ln3158">        else if (caret_equal)</a>
<a name="ln3159">            auto_letters.insert(auto_letters.begin(), entry);</a>
<a name="ln3160">        else</a>
<a name="ln3161">            auto_letters.push_back(entry);</a>
<a name="ln3162">    }</a>
<a name="ln3163">    else if (key == &quot;sort_menus&quot;)</a>
<a name="ln3164">    {</a>
<a name="ln3165">        for (const string &amp;frag : split_string(&quot;;&quot;, field))</a>
<a name="ln3166">            if (!frag.empty())</a>
<a name="ln3167">                set_menu_sort(frag);</a>
<a name="ln3168">    }</a>
<a name="ln3169">    else if (key == &quot;force_more_message&quot; || key == &quot;flash_screen_message&quot;)</a>
<a name="ln3170">    {</a>
<a name="ln3171">        vector&lt;message_filter&gt; &amp;filters = (key == &quot;force_more_message&quot; ? force_more_message : flash_screen_message);</a>
<a name="ln3172">        if (plain)</a>
<a name="ln3173">            filters.clear();</a>
<a name="ln3174"> </a>
<a name="ln3175">        vector&lt;message_filter&gt; new_entries;</a>
<a name="ln3176">        for (const string &amp;fragment : split_string(&quot;,&quot;, field))</a>
<a name="ln3177">        {</a>
<a name="ln3178">            if (fragment.empty())</a>
<a name="ln3179">                continue;</a>
<a name="ln3180"> </a>
<a name="ln3181">            message_filter mf(fragment);</a>
<a name="ln3182"> </a>
<a name="ln3183">            string::size_type pos = fragment.find(&quot;:&quot;);</a>
<a name="ln3184">            if (pos &amp;&amp; pos != string::npos)</a>
<a name="ln3185">            {</a>
<a name="ln3186">                string prefix = fragment.substr(0, pos);</a>
<a name="ln3187">                int channel = str_to_channel(prefix);</a>
<a name="ln3188">                if (channel != -1 || prefix == &quot;any&quot;)</a>
<a name="ln3189">                {</a>
<a name="ln3190">                    string s = fragment.substr(pos + 1);</a>
<a name="ln3191">                    mf = message_filter(channel, trim_string(s));</a>
<a name="ln3192">                }</a>
<a name="ln3193">            }</a>
<a name="ln3194"> </a>
<a name="ln3195">            if (minus_equal)</a>
<a name="ln3196">                remove_matching(filters, mf);</a>
<a name="ln3197">            else</a>
<a name="ln3198">                new_entries.push_back(mf);</a>
<a name="ln3199">        }</a>
<a name="ln3200">        merge_lists(filters, new_entries, caret_equal);</a>
<a name="ln3201">    }</a>
<a name="ln3202">    else if (key == &quot;travel_avoid_terrain&quot;)</a>
<a name="ln3203">    {</a>
<a name="ln3204">        // TODO: allow resetting (need reset_forbidden_terrain())</a>
<a name="ln3205">        for (const string &amp;seg : split_string(&quot;,&quot;, field))</a>
<a name="ln3206">            prevent_travel_to(seg);</a>
<a name="ln3207">    }</a>
<a name="ln3208">    else if (key == &quot;explore_stop&quot;)</a>
<a name="ln3209">    {</a>
<a name="ln3210">        if (plain)</a>
<a name="ln3211">            explore_stop = ES_NONE;</a>
<a name="ln3212"> </a>
<a name="ln3213">        const int new_conditions = read_explore_stop_conditions(field);</a>
<a name="ln3214">        if (minus_equal)</a>
<a name="ln3215">            explore_stop &amp;= ~new_conditions;</a>
<a name="ln3216">        else</a>
<a name="ln3217">            explore_stop |= new_conditions;</a>
<a name="ln3218">    }</a>
<a name="ln3219">    else if (key == &quot;sound&quot; || key == &quot;hold_sound&quot;)</a>
<a name="ln3220">    {</a>
<a name="ln3221">        if (plain)</a>
<a name="ln3222">            sound_mappings.clear();</a>
<a name="ln3223"> </a>
<a name="ln3224">        vector&lt;sound_mapping&gt; new_entries;</a>
<a name="ln3225">        for (const string &amp;sub : split_string(&quot;,&quot;, field))</a>
<a name="ln3226">        {</a>
<a name="ln3227">            string::size_type cpos = sub.find(&quot;:&quot;, 0);</a>
<a name="ln3228">            if (cpos != string::npos)</a>
<a name="ln3229">            {</a>
<a name="ln3230">                sound_mapping entry;</a>
<a name="ln3231">                entry.pattern = sub.substr(0, cpos);</a>
<a name="ln3232">                entry.soundfile = sound_file_path + sub.substr(cpos + 1);</a>
<a name="ln3233">                if (key == &quot;hold_sound&quot;)</a>
<a name="ln3234">                    entry.interrupt_game = true;</a>
<a name="ln3235">                else</a>
<a name="ln3236">                    entry.interrupt_game = false;</a>
<a name="ln3237"> </a>
<a name="ln3238">                if (minus_equal)</a>
<a name="ln3239">                    remove_matching(sound_mappings, entry);</a>
<a name="ln3240">                else</a>
<a name="ln3241">                    new_entries.push_back(entry);</a>
<a name="ln3242">            }</a>
<a name="ln3243">        }</a>
<a name="ln3244">        merge_lists(sound_mappings, new_entries, caret_equal);</a>
<a name="ln3245">    }</a>
<a name="ln3246">#ifndef TARGET_COMPILER_VC</a>
<a name="ln3247">    // MSVC has a limit on how many if/else if can be chained together.</a>
<a name="ln3248">    else</a>
<a name="ln3249">#endif</a>
<a name="ln3250">    if (key == &quot;menu_colour&quot; || key == &quot;menu_color&quot;)</a>
<a name="ln3251">    {</a>
<a name="ln3252">        if (plain)</a>
<a name="ln3253">            menu_colour_mappings.clear();</a>
<a name="ln3254"> </a>
<a name="ln3255">        vector&lt;colour_mapping&gt; new_entries;</a>
<a name="ln3256">        for (const string &amp;seg : split_string(&quot;,&quot;, field))</a>
<a name="ln3257">        {</a>
<a name="ln3258">            // Format is &quot;tag:colour:pattern&quot; or &quot;colour:pattern&quot; (default tag).</a>
<a name="ln3259">            // FIXME: arrange so that you can use ':' inside a pattern</a>
<a name="ln3260">            vector&lt;string&gt; subseg = split_string(&quot;:&quot;, seg, false);</a>
<a name="ln3261">            string tagname, patname, colname;</a>
<a name="ln3262">            if (subseg.size() &lt; 2)</a>
<a name="ln3263">                continue;</a>
<a name="ln3264">            if (subseg.size() &gt;= 3)</a>
<a name="ln3265">            {</a>
<a name="ln3266">                tagname = subseg[0];</a>
<a name="ln3267">                colname = subseg[1];</a>
<a name="ln3268">                patname = subseg[2];</a>
<a name="ln3269">            }</a>
<a name="ln3270">            else</a>
<a name="ln3271">            {</a>
<a name="ln3272">                colname = subseg[0];</a>
<a name="ln3273">                patname = subseg[1];</a>
<a name="ln3274">            }</a>
<a name="ln3275"> </a>
<a name="ln3276">            colour_mapping mapping;</a>
<a name="ln3277">            mapping.tag     = tagname;</a>
<a name="ln3278">            mapping.pattern = patname;</a>
<a name="ln3279">            const int col = str_to_colour(colname);</a>
<a name="ln3280">            mapping.colour = col;</a>
<a name="ln3281"> </a>
<a name="ln3282">            if (col == -1)</a>
<a name="ln3283">                continue;</a>
<a name="ln3284">            else if (minus_equal)</a>
<a name="ln3285">                remove_matching(menu_colour_mappings, mapping);</a>
<a name="ln3286">            else</a>
<a name="ln3287">                new_entries.push_back(mapping);</a>
<a name="ln3288">        }</a>
<a name="ln3289">        merge_lists(menu_colour_mappings, new_entries, caret_equal);</a>
<a name="ln3290">    }</a>
<a name="ln3291">    else if (key == &quot;message_colour&quot; || key == &quot;message_color&quot;)</a>
<a name="ln3292">    {</a>
<a name="ln3293">        // TODO: support -= here.</a>
<a name="ln3294">        if (plain)</a>
<a name="ln3295">            message_colour_mappings.clear();</a>
<a name="ln3296"> </a>
<a name="ln3297">        add_message_colour_mappings(field, caret_equal, minus_equal);</a>
<a name="ln3298">    }</a>
<a name="ln3299">    else if (key == &quot;dump_order&quot;)</a>
<a name="ln3300">    {</a>
<a name="ln3301">        if (plain)</a>
<a name="ln3302">            dump_order.clear();</a>
<a name="ln3303"> </a>
<a name="ln3304">        new_dump_fields(field, !minus_equal, caret_equal);</a>
<a name="ln3305">    }</a>
<a name="ln3306">    else if (key == &quot;dump_kill_places&quot;)</a>
<a name="ln3307">    {</a>
<a name="ln3308">        dump_kill_places = (field == &quot;none&quot; ? KDO_NO_PLACES :</a>
<a name="ln3309">                            field == &quot;all&quot;  ? KDO_ALL_PLACES</a>
<a name="ln3310">                                            : KDO_ONE_PLACE);</a>
<a name="ln3311">    }</a>
<a name="ln3312">    else if (key == &quot;kill_map&quot;)</a>
<a name="ln3313">    {</a>
<a name="ln3314">        // TODO: treat this as a map option (e.g. kill_map.you = friendly)</a>
<a name="ln3315">        if (plain &amp;&amp; field.empty())</a>
<a name="ln3316">        {</a>
<a name="ln3317">            kill_map[KC_YOU] = KC_YOU;</a>
<a name="ln3318">            kill_map[KC_FRIENDLY] = KC_FRIENDLY;</a>
<a name="ln3319">            kill_map[KC_OTHER] = KC_OTHER;</a>
<a name="ln3320">        }</a>
<a name="ln3321"> </a>
<a name="ln3322">        for (const string &amp;s : split_string(&quot;,&quot;, field))</a>
<a name="ln3323">        {</a>
<a name="ln3324">            string::size_type cpos = s.find(&quot;:&quot;, 0);</a>
<a name="ln3325">            if (cpos != string::npos)</a>
<a name="ln3326">            {</a>
<a name="ln3327">                string from = s.substr(0, cpos);</a>
<a name="ln3328">                string to   = s.substr(cpos + 1);</a>
<a name="ln3329">                do_kill_map(from, to);</a>
<a name="ln3330">            }</a>
<a name="ln3331">        }</a>
<a name="ln3332">    }</a>
<a name="ln3333">    else if (key == &quot;dump_item_origins&quot;)</a>
<a name="ln3334">    {</a>
<a name="ln3335">        if (plain)</a>
<a name="ln3336">            dump_item_origins = IODS_PRICE;</a>
<a name="ln3337"> </a>
<a name="ln3338">        for (const string &amp;ch : split_string(&quot;,&quot;, field))</a>
<a name="ln3339">        {</a>
<a name="ln3340">            if (ch == &quot;artefacts&quot; || ch == &quot;artifacts&quot;</a>
<a name="ln3341">                || ch == &quot;artefact&quot; || ch == &quot;artifact&quot;)</a>
<a name="ln3342">            {</a>
<a name="ln3343">                dump_item_origins |= IODS_ARTEFACTS;</a>
<a name="ln3344">            }</a>
<a name="ln3345">            else if (ch == &quot;ego_arm&quot; || ch == &quot;ego armour&quot;</a>
<a name="ln3346">                     || ch == &quot;ego_armour&quot; || ch == &quot;ego armor&quot;</a>
<a name="ln3347">                     || ch == &quot;ego_armor&quot;)</a>
<a name="ln3348">            {</a>
<a name="ln3349">                dump_item_origins |= IODS_EGO_ARMOUR;</a>
<a name="ln3350">            }</a>
<a name="ln3351">            else if (ch == &quot;ego_weap&quot; || ch == &quot;ego weapon&quot;</a>
<a name="ln3352">                     || ch == &quot;ego_weapon&quot; || ch == &quot;ego weapons&quot;</a>
<a name="ln3353">                     || ch == &quot;ego_weapons&quot;)</a>
<a name="ln3354">            {</a>
<a name="ln3355">                dump_item_origins |= IODS_EGO_WEAPON;</a>
<a name="ln3356">            }</a>
<a name="ln3357">            else if (ch == &quot;jewellery&quot; || ch == &quot;jewelry&quot;)</a>
<a name="ln3358">                dump_item_origins |= IODS_JEWELLERY;</a>
<a name="ln3359">            else if (ch == &quot;runes&quot;)</a>
<a name="ln3360">                dump_item_origins |= IODS_RUNES;</a>
<a name="ln3361">            else if (ch == &quot;staves&quot;)</a>
<a name="ln3362">                dump_item_origins |= IODS_STAVES;</a>
<a name="ln3363">            else if (ch == &quot;books&quot;)</a>
<a name="ln3364">                dump_item_origins |= IODS_BOOKS;</a>
<a name="ln3365">            else if (ch == &quot;all&quot; || ch == &quot;everything&quot;)</a>
<a name="ln3366">                dump_item_origins = IODS_EVERYTHING;</a>
<a name="ln3367">        }</a>
<a name="ln3368">    }</a>
<a name="ln3369">    else if (key == &quot;additional_macro_file&quot;)</a>
<a name="ln3370">    {</a>
<a name="ln3371">        // TODO: this option could probably be improved. For now, keep the</a>
<a name="ln3372">        // &quot;= means append&quot; behaviour, and don't allow clearing the list;</a>
<a name="ln3373">        // if we rename to &quot;additional_macro_files&quot; then it could work like</a>
<a name="ln3374">        // other list options.</a>
<a name="ln3375">        const string resolved = resolve_include(orig_field, &quot;macro &quot;);</a>
<a name="ln3376">        if (!resolved.empty())</a>
<a name="ln3377">            additional_macro_files.push_back(resolved);</a>
<a name="ln3378">    }</a>
<a name="ln3379">    else if (key == &quot;macros&quot;)</a>
<a name="ln3380">    {</a>
<a name="ln3381">        // orig_field because this function wants capitals</a>
<a name="ln3382">        const string possible_error = read_rc_file_macro(orig_field);</a>
<a name="ln3383"> </a>
<a name="ln3384">        if (!possible_error.empty())</a>
<a name="ln3385">            report_error(possible_error.c_str(), orig_field.c_str());</a>
<a name="ln3386">    }</a>
<a name="ln3387">#ifdef USE_TILE</a>
<a name="ln3388">#ifdef USE_TILE_LOCAL</a>
<a name="ln3389">    else if (key == &quot;tile_full_screen&quot;)</a>
<a name="ln3390">    {</a>
<a name="ln3391">        const maybe_bool fs_val = read_maybe_bool(field);</a>
<a name="ln3392">        if (fs_val == MB_TRUE)</a>
<a name="ln3393">            tile_full_screen = SCREENMODE_FULL;</a>
<a name="ln3394">        else if (fs_val == MB_FALSE)</a>
<a name="ln3395">            tile_full_screen = SCREENMODE_WINDOW;</a>
<a name="ln3396">        else</a>
<a name="ln3397">            tile_full_screen = SCREENMODE_AUTO;</a>
<a name="ln3398">    }</a>
<a name="ln3399">#endif // USE_TILE_LOCAL</a>
<a name="ln3400">#ifdef TOUCH_UI</a>
<a name="ln3401">    else if (key == &quot;tile_use_small_layout&quot;)</a>
<a name="ln3402">        tile_use_small_layout = read_maybe_bool(field);</a>
<a name="ln3403">#endif</a>
<a name="ln3404">    else if (key == &quot;tile_show_player_species&quot; &amp;&amp; field == &quot;true&quot;)</a>
<a name="ln3405">    {</a>
<a name="ln3406">        field = &quot;playermons&quot;;</a>
<a name="ln3407">        set_player_tile(field);</a>
<a name="ln3408">    }</a>
<a name="ln3409">    else if (key == &quot;tile_player_tile&quot;)</a>
<a name="ln3410">        set_player_tile(field);</a>
<a name="ln3411">    else if (key == &quot;tile_weapon_offsets&quot;)</a>
<a name="ln3412">        set_tile_offsets(field, false);</a>
<a name="ln3413">    else if (key == &quot;tile_shield_offsets&quot;)</a>
<a name="ln3414">        set_tile_offsets(field, true);</a>
<a name="ln3415">    else if (key == &quot;tile_tag_pref&quot;)</a>
<a name="ln3416">        tile_tag_pref = _str_to_tag_pref(field.c_str());</a>
<a name="ln3417">#ifdef USE_TILE_WEB</a>
<a name="ln3418">    else if (key == &quot;tile_display_mode&quot;)</a>
<a name="ln3419">    {</a>
<a name="ln3420">        if (field == &quot;tiles&quot; || field == &quot;glyphs&quot; || field == &quot;hybrid&quot;)</a>
<a name="ln3421">            tile_display_mode = field;</a>
<a name="ln3422">        else</a>
<a name="ln3423">        {</a>
<a name="ln3424">            mprf(MSGCH_ERROR, &quot;Unknown value for tile_display_mode: '%s'&quot;</a>
<a name="ln3425">                              &quot; (possible values: tiles/glyphs/hybrid&quot;,</a>
<a name="ln3426">                                                                field.c_str());</a>
<a name="ln3427">        }</a>
<a name="ln3428">    }</a>
<a name="ln3429">#endif</a>
<a name="ln3430">#endif // USE_TILE</a>
<a name="ln3431"> </a>
<a name="ln3432">    else if (key == &quot;bindkey&quot;)</a>
<a name="ln3433">        _bindkey(field);</a>
<a name="ln3434">    else if (key == &quot;constant&quot;)</a>
<a name="ln3435">    {</a>
<a name="ln3436">        if (!variables.count(field))</a>
<a name="ln3437">            report_error(&quot;No variable named '%s' to make constant&quot;, field.c_str());</a>
<a name="ln3438">        else if (constants.count(field))</a>
<a name="ln3439">            report_error(&quot;'%s' is already a constant&quot;, field.c_str());</a>
<a name="ln3440">        else</a>
<a name="ln3441">            constants.insert(field);</a>
<a name="ln3442">    }</a>
<a name="ln3443">    else if (key == &quot;game_seed&quot;)</a>
<a name="ln3444">    {</a>
<a name="ln3445">        // special handling because of the large type.</a>
<a name="ln3446">        uint64_t tmp_seed = 0;</a>
<a name="ln3447">        if (sscanf(field.c_str(), &quot;%&quot; SCNu64, &amp;tmp_seed))</a>
<a name="ln3448">        {</a>
<a name="ln3449">            // seed_from_rc is only ever set here, or by the CLO. The CLO gets</a>
<a name="ln3450">            // first crack, so don't overwrite it here.</a>
<a name="ln3451">            if (!seed_from_rc)</a>
<a name="ln3452">                seed_from_rc = tmp_seed;</a>
<a name="ln3453">        }</a>
<a name="ln3454">    }</a>
<a name="ln3455">    else if (key == &quot;pregen_dungeon&quot;)</a>
<a name="ln3456">    {</a>
<a name="ln3457">        // TODO: probably convert the underlying values to some kind of enum</a>
<a name="ln3458">        // TODO: store these options in a save?</a>
<a name="ln3459">        if (field == &quot;true&quot; || field == &quot;full&quot;)</a>
<a name="ln3460">        {</a>
<a name="ln3461">#ifdef DGAMELAUNCH</a>
<a name="ln3462">            report_error(</a>
<a name="ln3463">                &quot;Full pregeneration is not allowed on this build of crawl.&quot;);</a>
<a name="ln3464">#else</a>
<a name="ln3465">            pregen_dungeon = true;</a>
<a name="ln3466">            incremental_pregen = true; // still affects loading games not</a>
<a name="ln3467">                                       // started with full pregen</a>
<a name="ln3468">#endif</a>
<a name="ln3469">        }</a>
<a name="ln3470">        else if (field == &quot;incremental&quot;)</a>
<a name="ln3471">        {</a>
<a name="ln3472">            pregen_dungeon = false;</a>
<a name="ln3473">            incremental_pregen = true;</a>
<a name="ln3474">        }</a>
<a name="ln3475">        else if (field == &quot;false&quot; || field == &quot;classic&quot;)</a>
<a name="ln3476">            pregen_dungeon = incremental_pregen = false;</a>
<a name="ln3477">        else</a>
<a name="ln3478">        {</a>
<a name="ln3479">            report_error(&quot;Unknown value '%s' for pregen_dungeon.&quot;,</a>
<a name="ln3480">                                                            field.c_str());</a>
<a name="ln3481">        }</a>
<a name="ln3482">    }</a>
<a name="ln3483">#ifdef USE_TILE</a>
<a name="ln3484">    // TODO: generalize these to an option type?</a>
<a name="ln3485">    else if (key == &quot;tile_viewport_scale&quot;)</a>
<a name="ln3486">    {</a>
<a name="ln3487">        float tmp_scale;</a>
<a name="ln3488">        if (sscanf(field.c_str(), &quot;%f&quot;, &amp;tmp_scale))</a>
<a name="ln3489">        {</a>
<a name="ln3490">            tile_viewport_scale = min(1600, max(20,</a>
<a name="ln3491">                                        static_cast&lt;int&gt;(tmp_scale * 100)));</a>
<a name="ln3492">        }</a>
<a name="ln3493">        else</a>
<a name="ln3494">        {</a>
<a name="ln3495">            report_error(&quot;Expected a decimal value for tile_viewport_scale,&quot;</a>
<a name="ln3496">                &quot; but got '%s'.&quot;, field.c_str());</a>
<a name="ln3497">        }</a>
<a name="ln3498">    }</a>
<a name="ln3499">    else if (key == &quot;tile_map_scale&quot;)</a>
<a name="ln3500">    {</a>
<a name="ln3501">        float tmp_scale;</a>
<a name="ln3502">        if (sscanf(field.c_str(), &quot;%f&quot;, &amp;tmp_scale))</a>
<a name="ln3503">        {</a>
<a name="ln3504">            tile_map_scale = min(1600, max(20,</a>
<a name="ln3505">                                        static_cast&lt;int&gt;(tmp_scale * 100)));</a>
<a name="ln3506">        }</a>
<a name="ln3507">        else</a>
<a name="ln3508">        {</a>
<a name="ln3509">            report_error(&quot;Expected a decimal value for tile_map_scale,&quot;</a>
<a name="ln3510">                &quot; but got '%s'.&quot;, field.c_str());</a>
<a name="ln3511">        }</a>
<a name="ln3512">    }</a>
<a name="ln3513">#endif</a>
<a name="ln3514"> </a>
<a name="ln3515">    // Catch-all else, copies option into map</a>
<a name="ln3516">    else if (runscript)</a>
<a name="ln3517">    {</a>
<a name="ln3518">#ifdef CLUA_BINDINGS</a>
<a name="ln3519">        int setmode = 0;</a>
<a name="ln3520">        if (plus_equal)</a>
<a name="ln3521">            setmode = 1;</a>
<a name="ln3522">        if (minus_equal)</a>
<a name="ln3523">            setmode = -1;</a>
<a name="ln3524">        if (caret_equal)</a>
<a name="ln3525">            setmode = 2;</a>
<a name="ln3526"> </a>
<a name="ln3527">        if (!clua.callbooleanfn(false, &quot;c_process_lua_option&quot;, &quot;ssd&quot;,</a>
<a name="ln3528">                        key.c_str(), orig_field.c_str(), setmode))</a>
<a name="ln3529">#endif</a>
<a name="ln3530">        {</a>
<a name="ln3531">#ifdef CLUA_BINDINGS</a>
<a name="ln3532">            if (!clua.error.empty())</a>
<a name="ln3533">                mprf(MSGCH_ERROR, &quot;Lua error: %s&quot;, clua.error.c_str());</a>
<a name="ln3534">#endif</a>
<a name="ln3535">            named_options[key] = orig_field;</a>
<a name="ln3536">        }</a>
<a name="ln3537">    }</a>
<a name="ln3538">}</a>
<a name="ln3539"> </a>
<a name="ln3540">static const map&lt;string, flang_t&gt; fake_lang_names = {</a>
<a name="ln3541">    { &quot;dwarven&quot;, flang_t::dwarven },</a>
<a name="ln3542">    { &quot;dwarf&quot;, flang_t::dwarven },</a>
<a name="ln3543"> </a>
<a name="ln3544">    { &quot;jäger&quot;, flang_t::jagerkin },</a>
<a name="ln3545">    { &quot;jägerkin&quot;, flang_t::jagerkin },</a>
<a name="ln3546">    { &quot;jager&quot;, flang_t::jagerkin },</a>
<a name="ln3547">    { &quot;jagerkin&quot;, flang_t::jagerkin },</a>
<a name="ln3548">    { &quot;jaeger&quot;, flang_t::jagerkin },</a>
<a name="ln3549">    { &quot;jaegerkin&quot;, flang_t::jagerkin },</a>
<a name="ln3550"> </a>
<a name="ln3551">    // Due to a historical conflict with actual german, slang names are</a>
<a name="ln3552">    // supported. Not the really rude ones, though.</a>
<a name="ln3553">    { &quot;de&quot;, flang_t::kraut },</a>
<a name="ln3554">    { &quot;german&quot;, flang_t::kraut },</a>
<a name="ln3555">    { &quot;kraut&quot;, flang_t::kraut },</a>
<a name="ln3556">    { &quot;jerry&quot;, flang_t::kraut },</a>
<a name="ln3557">    { &quot;fritz&quot;, flang_t::kraut },</a>
<a name="ln3558"> </a>
<a name="ln3559">    { &quot;futhark&quot;, flang_t::futhark },</a>
<a name="ln3560">    { &quot;runes&quot;, flang_t::futhark },</a>
<a name="ln3561">    { &quot;runic&quot;, flang_t::futhark },</a>
<a name="ln3562"> </a>
<a name="ln3563">    { &quot;wide&quot;, flang_t::wide },</a>
<a name="ln3564">    { &quot;doublewidth&quot;, flang_t::wide },</a>
<a name="ln3565">    { &quot;fullwidth&quot;, flang_t::wide },</a>
<a name="ln3566"> </a>
<a name="ln3567">    { &quot;grunt&quot;, flang_t::grunt },</a>
<a name="ln3568">    { &quot;sgrunt&quot;, flang_t::grunt },</a>
<a name="ln3569">    { &quot;!!!&quot;, flang_t::grunt },</a>
<a name="ln3570"> </a>
<a name="ln3571">    { &quot;butt&quot;, flang_t::butt },</a>
<a name="ln3572">    { &quot;buttbot&quot;, flang_t::butt },</a>
<a name="ln3573">    { &quot;tef&quot;, flang_t::butt },</a>
<a name="ln3574">};</a>
<a name="ln3575"> </a>
<a name="ln3576">struct language_def</a>
<a name="ln3577">{</a>
<a name="ln3578">    lang_t lang;</a>
<a name="ln3579">    const char *code;</a>
<a name="ln3580">    set&lt;string&gt; names;</a>
<a name="ln3581">};</a>
<a name="ln3582"> </a>
<a name="ln3583">static const language_def lang_data[] =</a>
<a name="ln3584">{</a>
<a name="ln3585">    // Use null, not &quot;en&quot;, for English so we don't try to look up translations.</a>
<a name="ln3586">    { lang_t::EN, nullptr, { &quot;english&quot;, &quot;en&quot;, &quot;c&quot; } },</a>
<a name="ln3587">    { lang_t::CS, &quot;cs&quot;, { &quot;czech&quot;, &quot;český&quot;, &quot;cesky&quot; } },</a>
<a name="ln3588">    { lang_t::DA, &quot;da&quot;, { &quot;danish&quot;, &quot;dansk&quot; } },</a>
<a name="ln3589">    { lang_t::DE, &quot;de&quot;, { &quot;german&quot;, &quot;deutsch&quot; } },</a>
<a name="ln3590">    { lang_t::EL, &quot;el&quot;, { &quot;greek&quot;, &quot;ελληνικά&quot;, &quot;ελληνικα&quot; } },</a>
<a name="ln3591">    { lang_t::ES, &quot;es&quot;, { &quot;spanish&quot;, &quot;español&quot;, &quot;espanol&quot; } },</a>
<a name="ln3592">    { lang_t::FI, &quot;fi&quot;, { &quot;finnish&quot;, &quot;suomi&quot; } },</a>
<a name="ln3593">    { lang_t::FR, &quot;fr&quot;, { &quot;french&quot;, &quot;français&quot;, &quot;francais&quot; } },</a>
<a name="ln3594">    { lang_t::HU, &quot;hu&quot;, { &quot;hungarian&quot;, &quot;magyar&quot; } },</a>
<a name="ln3595">    { lang_t::IT, &quot;it&quot;, { &quot;italian&quot;, &quot;italiano&quot; } },</a>
<a name="ln3596">    { lang_t::JA, &quot;ja&quot;, { &quot;japanese&quot;, &quot;日本人&quot; } },</a>
<a name="ln3597">    { lang_t::KO, &quot;ko&quot;, { &quot;korean&quot;, &quot;한국의&quot; } },</a>
<a name="ln3598">    { lang_t::LT, &quot;lt&quot;, { &quot;lithuanian&quot;, &quot;lietuvos&quot; } },</a>
<a name="ln3599">    { lang_t::LV, &quot;lv&quot;, { &quot;latvian&quot;, &quot;lettish&quot;, &quot;latvijas&quot;, &quot;latviešu&quot;,</a>
<a name="ln3600">                          &quot;latvieshu&quot;, &quot;latviesu&quot; } },</a>
<a name="ln3601">    { lang_t::NL, &quot;nl&quot;, { &quot;dutch&quot;, &quot;nederlands&quot; } },</a>
<a name="ln3602">    { lang_t::PL, &quot;pl&quot;, { &quot;polish&quot;, &quot;polski&quot; } },</a>
<a name="ln3603">    { lang_t::PT, &quot;pt&quot;, { &quot;portuguese&quot;, &quot;português&quot;, &quot;portugues&quot; } },</a>
<a name="ln3604">    { lang_t::RU, &quot;ru&quot;, { &quot;russian&quot;, &quot;русский&quot;, &quot;русскии&quot; } },</a>
<a name="ln3605">    { lang_t::SV, &quot;sv&quot;, { &quot;swedish&quot;, &quot;svenska&quot; } },</a>
<a name="ln3606">    { lang_t::ZH, &quot;zh&quot;, { &quot;chinese&quot;, &quot;中国的&quot;, &quot;中國的&quot; } },</a>
<a name="ln3607">};</a>
<a name="ln3608"> </a>
<a name="ln3609">static string _supported_language_listing()</a>
<a name="ln3610">{</a>
<a name="ln3611">    return comma_separated_fn(&amp;lang_data[0], &amp;lang_data[ARRAYSZ(lang_data)],</a>
<a name="ln3612">                              [](language_def ld){return ld.code ? ld.code : &quot;en&quot;;},</a>
<a name="ln3613">                              &quot;,&quot;, &quot;,&quot;,</a>
<a name="ln3614">                              [](language_def){return true;});</a>
<a name="ln3615">}</a>
<a name="ln3616"> </a>
<a name="ln3617">bool game_options::set_lang(const char *lc)</a>
<a name="ln3618">{</a>
<a name="ln3619">    if (!lc)</a>
<a name="ln3620">        return false;</a>
<a name="ln3621"> </a>
<a name="ln3622">    if (lc[0] &amp;&amp; lc[1] &amp;&amp; (lc[2] == '_' || lc[2] == '-'))</a>
<a name="ln3623">        return set_lang(string(lc, 2).c_str());</a>
<a name="ln3624"> </a>
<a name="ln3625">    const string l = lowercase_string(lc); // Windows returns it capitalized.</a>
<a name="ln3626">    for (const auto &amp;ldef : lang_data)</a>
<a name="ln3627">    {</a>
<a name="ln3628">        if ((ldef.code &amp;&amp; l == ldef.code) || ldef.names.count(l))</a>
<a name="ln3629">        {</a>
<a name="ln3630">            language = ldef.lang;</a>
<a name="ln3631">            lang_name = ldef.code;</a>
<a name="ln3632">            return true;</a>
<a name="ln3633">        }</a>
<a name="ln3634">    }</a>
<a name="ln3635"> </a>
<a name="ln3636">    if (const flang_t * const flang = map_find(fake_lang_names, l))</a>
<a name="ln3637">    {</a>
<a name="ln3638">        // Handle fake languages for backwards-compatibility with old rcs.</a>
<a name="ln3639">        // Override rather than stack, because that's how it used to work.</a>
<a name="ln3640">        fake_langs = { { *flang, -1 } };</a>
<a name="ln3641">        return true;</a>
<a name="ln3642">    }</a>
<a name="ln3643"> </a>
<a name="ln3644">    return false;</a>
<a name="ln3645">}</a>
<a name="ln3646"> </a>
<a name="ln3647">/**</a>
<a name="ln3648"> * Apply the player's fake language settings.</a>
<a name="ln3649"> *</a>
<a name="ln3650"> * @param input     The value of the &quot;fake_lang&quot; field.</a>
<a name="ln3651"> */</a>
<a name="ln3652">void game_options::set_fake_langs(const string &amp;input)</a>
<a name="ln3653">{</a>
<a name="ln3654">    fake_langs.clear();</a>
<a name="ln3655">    for (const string &amp;flang_text : split_string(&quot;,&quot;, input))</a>
<a name="ln3656">    {</a>
<a name="ln3657">        const int MAX_LANGS = 3;</a>
<a name="ln3658">        if (fake_langs.size() &gt;= (size_t) MAX_LANGS)</a>
<a name="ln3659">        {</a>
<a name="ln3660">            report_error(&quot;Too many fake langs; maximum is %d&quot;, MAX_LANGS);</a>
<a name="ln3661">            break;</a>
<a name="ln3662">        }</a>
<a name="ln3663"> </a>
<a name="ln3664">        const vector&lt;string&gt; split_flang = split_string(&quot;:&quot;, flang_text);</a>
<a name="ln3665">        const string flang_name = split_flang[0];</a>
<a name="ln3666">        if (split_flang.size() &gt; 2)</a>
<a name="ln3667">        {</a>
<a name="ln3668">            report_error(&quot;Invalid fake-lang format: %s&quot;, flang_text.c_str());</a>
<a name="ln3669">            continue;</a>
<a name="ln3670">        }</a>
<a name="ln3671"> </a>
<a name="ln3672">        int tval = -1;</a>
<a name="ln3673">        const int value = split_flang.size() &gt;= 2</a>
<a name="ln3674">                          &amp;&amp; parse_int(split_flang[1].c_str(), tval) ? tval : -1;</a>
<a name="ln3675"> </a>
<a name="ln3676">        const flang_t *flang = map_find(fake_lang_names, flang_name);</a>
<a name="ln3677">        if (flang)</a>
<a name="ln3678">        {</a>
<a name="ln3679">            if (split_flang.size() &gt;= 2)</a>
<a name="ln3680">            {</a>
<a name="ln3681">                if (*flang != flang_t::butt)</a>
<a name="ln3682">                {</a>
<a name="ln3683">                    report_error(&quot;Lang %s doesn't take a value&quot;,</a>
<a name="ln3684">                                 flang_name.c_str());</a>
<a name="ln3685">                    continue;</a>
<a name="ln3686">                }</a>
<a name="ln3687"> </a>
<a name="ln3688">                if (value == -1)</a>
<a name="ln3689">                {</a>
<a name="ln3690">                    report_error(&quot;Invalid value '%s' provided for lang&quot;,</a>
<a name="ln3691">                                 split_flang[1].c_str());</a>
<a name="ln3692">                    continue;</a>
<a name="ln3693">                }</a>
<a name="ln3694">            }</a>
<a name="ln3695"> </a>
<a name="ln3696">            fake_langs.push_back({*flang, value});</a>
<a name="ln3697">        }</a>
<a name="ln3698">        else</a>
<a name="ln3699">            report_error(&quot;Unknown language %s!&quot;, flang_name.c_str());</a>
<a name="ln3700"> </a>
<a name="ln3701">    }</a>
<a name="ln3702">}</a>
<a name="ln3703"> </a>
<a name="ln3704">// Checks an include file name for safety and resolves it to a readable path.</a>
<a name="ln3705">// If file cannot be resolved, returns the empty string (this does not throw!)</a>
<a name="ln3706">// If file can be resolved, returns the resolved path.</a>
<a name="ln3707">/// @throws unsafe_path if included_file fails the safety check.</a>
<a name="ln3708">string game_options::resolve_include(string parent_file, string included_file,</a>
<a name="ln3709">                                     const vector&lt;string&gt; *rcdirs)</a>
<a name="ln3710">{</a>
<a name="ln3711">    // Before we start, make sure we convert forward slashes to the platform's</a>
<a name="ln3712">    // favoured file separator.</a>
<a name="ln3713">    parent_file   = canonicalise_file_separator(parent_file);</a>
<a name="ln3714">    included_file = canonicalise_file_separator(included_file);</a>
<a name="ln3715"> </a>
<a name="ln3716">    // How we resolve include paths:</a>
<a name="ln3717">    // 1. If it's an absolute path, use it directly.</a>
<a name="ln3718">    // 2. Try the name relative to the parent filename, if supplied.</a>
<a name="ln3719">    // 3. Try the name relative to any of the provided rcdirs.</a>
<a name="ln3720">    // 4. Try locating the name as a regular data file (also checks for the</a>
<a name="ln3721">    //    file name relative to the current directory).</a>
<a name="ln3722">    // 5. Fail, and return empty string.</a>
<a name="ln3723"> </a>
<a name="ln3724">    assert_read_safe_path(included_file);</a>
<a name="ln3725"> </a>
<a name="ln3726">    // There's only so much you can do with an absolute path.</a>
<a name="ln3727">    // Note: absolute paths can only get here if we're not on a</a>
<a name="ln3728">    // multiuser system. On multiuser systems assert_read_safe_path()</a>
<a name="ln3729">    // will throw an exception if it sees absolute paths.</a>
<a name="ln3730">    if (is_absolute_path(included_file))</a>
<a name="ln3731">        return file_exists(included_file)? included_file : &quot;&quot;;</a>
<a name="ln3732"> </a>
<a name="ln3733">    if (!parent_file.empty())</a>
<a name="ln3734">    {</a>
<a name="ln3735">        const string candidate = get_path_relative_to(parent_file,</a>
<a name="ln3736">                                                      included_file);</a>
<a name="ln3737">        if (file_exists(candidate))</a>
<a name="ln3738">            return candidate;</a>
<a name="ln3739">    }</a>
<a name="ln3740"> </a>
<a name="ln3741">    if (rcdirs)</a>
<a name="ln3742">    {</a>
<a name="ln3743">        for (const string &amp;dir : *rcdirs)</a>
<a name="ln3744">        {</a>
<a name="ln3745">            const string candidate(catpath(dir, included_file));</a>
<a name="ln3746">            if (file_exists(candidate))</a>
<a name="ln3747">                return candidate;</a>
<a name="ln3748">        }</a>
<a name="ln3749">    }</a>
<a name="ln3750"> </a>
<a name="ln3751">    return datafile_path(included_file, false, true);</a>
<a name="ln3752">}</a>
<a name="ln3753"> </a>
<a name="ln3754">string game_options::resolve_include(const string &amp;file, const char *type)</a>
<a name="ln3755">{</a>
<a name="ln3756">    try</a>
<a name="ln3757">    {</a>
<a name="ln3758">        const string resolved = resolve_include(filename, file, &amp;SysEnv.rcdirs);</a>
<a name="ln3759"> </a>
<a name="ln3760">        if (resolved.empty())</a>
<a name="ln3761">            report_error(&quot;Cannot find %sfile \&quot;%s\&quot;.&quot;, type, file.c_str());</a>
<a name="ln3762">        return resolved;</a>
<a name="ln3763">    }</a>
<a name="ln3764">    catch (const unsafe_path &amp;err)</a>
<a name="ln3765">    {</a>
<a name="ln3766">        report_error(&quot;Cannot include %sfile: %s&quot;, type, err.what());</a>
<a name="ln3767">        return &quot;&quot;;</a>
<a name="ln3768">    }</a>
<a name="ln3769">}</a>
<a name="ln3770"> </a>
<a name="ln3771">bool game_options::was_included(const string &amp;file) const</a>
<a name="ln3772">{</a>
<a name="ln3773">    return included.count(file);</a>
<a name="ln3774">}</a>
<a name="ln3775"> </a>
<a name="ln3776">void game_options::include(const string &amp;rawfilename, bool resolve,</a>
<a name="ln3777">                           bool runscript)</a>
<a name="ln3778">{</a>
<a name="ln3779">    const string include_file = resolve ? resolve_include(rawfilename)</a>
<a name="ln3780">                                        : rawfilename;</a>
<a name="ln3781"> </a>
<a name="ln3782">    if (was_included(include_file))</a>
<a name="ln3783">        return;</a>
<a name="ln3784"> </a>
<a name="ln3785">    included.insert(include_file);</a>
<a name="ln3786"> </a>
<a name="ln3787">    // Change filename to the included filename while we're reading it.</a>
<a name="ln3788">    unwind_var&lt;string&gt; optfile(filename, include_file);</a>
<a name="ln3789">    unwind_var&lt;string&gt; basefile(basefilename, rawfilename);</a>
<a name="ln3790"> </a>
<a name="ln3791">    // Save current line number</a>
<a name="ln3792">    unwind_var&lt;int&gt; currlinenum(line_num, 0);</a>
<a name="ln3793"> </a>
<a name="ln3794">    // Also unwind any aliases defined in included files.</a>
<a name="ln3795">    unwind_var&lt;string_map&gt; unwalias(aliases);</a>
<a name="ln3796"> </a>
<a name="ln3797">    FileLineInput fl(include_file.c_str());</a>
<a name="ln3798">    if (!fl.error())</a>
<a name="ln3799">        read_options(fl, runscript, false);</a>
<a name="ln3800">}</a>
<a name="ln3801"> </a>
<a name="ln3802">void game_options::report_error(const char* format, ...)</a>
<a name="ln3803">{</a>
<a name="ln3804">    va_list args;</a>
<a name="ln3805">    va_start(args, format);</a>
<a name="ln3806">    string error = vmake_stringf(format, args);</a>
<a name="ln3807">    va_end(args);</a>
<a name="ln3808"> </a>
<a name="ln3809">    mprf(MSGCH_ERROR, &quot;Warning: %s (%s:%d)&quot;, error.c_str(),</a>
<a name="ln3810">         basefilename.c_str(), line_num);</a>
<a name="ln3811">}</a>
<a name="ln3812"> </a>
<a name="ln3813">static string check_string(const char *s)</a>
<a name="ln3814">{</a>
<a name="ln3815">    return s? s : &quot;&quot;;</a>
<a name="ln3816">}</a>
<a name="ln3817"> </a>
<a name="ln3818">void get_system_environment()</a>
<a name="ln3819">{</a>
<a name="ln3820">    // The player's name</a>
<a name="ln3821">    SysEnv.crawl_name = check_string(getenv(&quot;CRAWL_NAME&quot;));</a>
<a name="ln3822"> </a>
<a name="ln3823">    // The directory which contians init.txt, macro.txt, morgue.txt</a>
<a name="ln3824">    // This should end with the appropriate path delimiter.</a>
<a name="ln3825">    SysEnv.crawl_dir = check_string(getenv(&quot;CRAWL_DIR&quot;));</a>
<a name="ln3826"> </a>
<a name="ln3827">#if defined(TARGET_OS_MACOSX) &amp;&amp; !defined(DGAMELAUNCH)</a>
<a name="ln3828">    if (SysEnv.crawl_dir.empty())</a>
<a name="ln3829">    {</a>
<a name="ln3830">        SysEnv.crawl_dir</a>
<a name="ln3831">            = _user_home_subpath(&quot;Library/Application Support/&quot; CRAWL);</a>
<a name="ln3832">    }</a>
<a name="ln3833">#endif</a>
<a name="ln3834"> </a>
<a name="ln3835">#ifdef SAVE_DIR_PATH</a>
<a name="ln3836">    if (SysEnv.crawl_dir.empty())</a>
<a name="ln3837">        SysEnv.crawl_dir = SAVE_DIR_PATH;</a>
<a name="ln3838">#endif</a>
<a name="ln3839"> </a>
<a name="ln3840">#ifdef DGL_SIMPLE_MESSAGING</a>
<a name="ln3841">    // Enable DGL_SIMPLE_MESSAGING only if SIMPLEMAIL and MAIL are set.</a>
<a name="ln3842">    const char *simplemail = getenv(&quot;SIMPLEMAIL&quot;);</a>
<a name="ln3843">    if (simplemail &amp;&amp; strcmp(simplemail, &quot;0&quot;))</a>
<a name="ln3844">    {</a>
<a name="ln3845">        const char *mail = getenv(&quot;MAIL&quot;);</a>
<a name="ln3846">        SysEnv.messagefile = mail? mail : &quot;&quot;;</a>
<a name="ln3847">    }</a>
<a name="ln3848">#endif</a>
<a name="ln3849"> </a>
<a name="ln3850">    // The full path to the init file -- this overrides CRAWL_DIR.</a>
<a name="ln3851">    SysEnv.crawl_rc = check_string(getenv(&quot;CRAWL_RC&quot;));</a>
<a name="ln3852"> </a>
<a name="ln3853">#ifdef UNIX</a>
<a name="ln3854">    // The user's home directory (used to look for ~/.crawlrc file)</a>
<a name="ln3855">    SysEnv.home = check_string(getenv(&quot;HOME&quot;));</a>
<a name="ln3856">#endif</a>
<a name="ln3857">}</a>
<a name="ln3858"> </a>
<a name="ln3859">static void set_crawl_base_dir(const char *arg)</a>
<a name="ln3860">{</a>
<a name="ln3861">    if (!arg)</a>
<a name="ln3862">        return;</a>
<a name="ln3863"> </a>
<a name="ln3864">    SysEnv.crawl_base = get_parent_directory(arg);</a>
<a name="ln3865">}</a>
<a name="ln3866"> </a>
<a name="ln3867">// parse args, filling in Options and game environment as we go.</a>
<a name="ln3868">// returns true if no unknown or malformed arguments were found.</a>
<a name="ln3869"> </a>
<a name="ln3870">// Keep this in sync with the option names.</a>
<a name="ln3871">enum commandline_option_type</a>
<a name="ln3872">{</a>
<a name="ln3873">    CLO_SCORES,</a>
<a name="ln3874">    CLO_NAME,</a>
<a name="ln3875">    CLO_RACE,</a>
<a name="ln3876">    CLO_CLASS,</a>
<a name="ln3877">    CLO_DIR,</a>
<a name="ln3878">    CLO_RC,</a>
<a name="ln3879">    CLO_RCDIR,</a>
<a name="ln3880">    CLO_TSCORES,</a>
<a name="ln3881">    CLO_VSCORES,</a>
<a name="ln3882">    CLO_SCOREFILE,</a>
<a name="ln3883">    CLO_MORGUE,</a>
<a name="ln3884">    CLO_MACRO,</a>
<a name="ln3885">    CLO_MAPSTAT,</a>
<a name="ln3886">    CLO_MAPSTAT_DUMP_DISCONNECT,</a>
<a name="ln3887">    CLO_OBJSTAT,</a>
<a name="ln3888">    CLO_ITERATIONS,</a>
<a name="ln3889">    CLO_FORCE_MAP,</a>
<a name="ln3890">    CLO_ARENA,</a>
<a name="ln3891">    CLO_DUMP_MAPS,</a>
<a name="ln3892">    CLO_TEST,</a>
<a name="ln3893">    CLO_SCRIPT,</a>
<a name="ln3894">    CLO_BUILDDB,</a>
<a name="ln3895">    CLO_HELP,</a>
<a name="ln3896">    CLO_VERSION,</a>
<a name="ln3897">    CLO_SEED,</a>
<a name="ln3898">    CLO_PREGEN,</a>
<a name="ln3899">    CLO_SAVE_VERSION,</a>
<a name="ln3900">    CLO_SPRINT,</a>
<a name="ln3901">    CLO_EXTRA_OPT_FIRST,</a>
<a name="ln3902">    CLO_EXTRA_OPT_LAST,</a>
<a name="ln3903">    CLO_SPRINT_MAP,</a>
<a name="ln3904">    CLO_EDIT_SAVE,</a>
<a name="ln3905">    CLO_PRINT_CHARSET,</a>
<a name="ln3906">    CLO_TUTORIAL,</a>
<a name="ln3907">    CLO_WIZARD,</a>
<a name="ln3908">    CLO_EXPLORE,</a>
<a name="ln3909">    CLO_NO_SAVE,</a>
<a name="ln3910">    CLO_GDB,</a>
<a name="ln3911">    CLO_NO_GDB, CLO_NOGDB,</a>
<a name="ln3912">    CLO_THROTTLE,</a>
<a name="ln3913">    CLO_NO_THROTTLE,</a>
<a name="ln3914">    CLO_PLAYABLE_JSON, // JSON metadata for species, jobs, combos.</a>
<a name="ln3915">    CLO_BRANCHES_JSON, // JSON metadata for branches.</a>
<a name="ln3916">    CLO_EDIT_BONES,</a>
<a name="ln3917">#ifdef USE_TILE_WEB</a>
<a name="ln3918">    CLO_WEBTILES_SOCKET,</a>
<a name="ln3919">    CLO_AWAIT_CONNECTION,</a>
<a name="ln3920">    CLO_PRINT_WEBTILES_OPTIONS,</a>
<a name="ln3921">#endif</a>
<a name="ln3922"> </a>
<a name="ln3923">    CLO_NOPS</a>
<a name="ln3924">};</a>
<a name="ln3925"> </a>
<a name="ln3926">static const char *cmd_ops[] =</a>
<a name="ln3927">{</a>
<a name="ln3928">    &quot;scores&quot;, &quot;name&quot;, &quot;species&quot;, &quot;background&quot;, &quot;dir&quot;, &quot;rc&quot;, &quot;rcdir&quot;, &quot;tscores&quot;,</a>
<a name="ln3929">    &quot;vscores&quot;, &quot;scorefile&quot;, &quot;morgue&quot;, &quot;macro&quot;, &quot;mapstat&quot;, &quot;dump-disconnect&quot;,</a>
<a name="ln3930">    &quot;objstat&quot;, &quot;iters&quot;, &quot;force-map&quot;, &quot;arena&quot;, &quot;dump-maps&quot;, &quot;test&quot;, &quot;script&quot;,</a>
<a name="ln3931">    &quot;builddb&quot;, &quot;help&quot;, &quot;version&quot;, &quot;seed&quot;, &quot;pregen&quot;, &quot;save-version&quot;, &quot;sprint&quot;,</a>
<a name="ln3932">    &quot;extra-opt-first&quot;, &quot;extra-opt-last&quot;, &quot;sprint-map&quot;, &quot;edit-save&quot;,</a>
<a name="ln3933">    &quot;print-charset&quot;, &quot;tutorial&quot;, &quot;wizard&quot;, &quot;explore&quot;, &quot;no-save&quot;, &quot;gdb&quot;,</a>
<a name="ln3934">    &quot;no-gdb&quot;, &quot;nogdb&quot;, &quot;throttle&quot;, &quot;no-throttle&quot;, &quot;playable-json&quot;, &quot;branches-json&quot;,</a>
<a name="ln3935">    &quot;bones&quot;,</a>
<a name="ln3936">#ifdef USE_TILE_WEB</a>
<a name="ln3937">    &quot;webtiles-socket&quot;, &quot;await-connection&quot;, &quot;print-webtiles-options&quot;,</a>
<a name="ln3938">#endif</a>
<a name="ln3939">};</a>
<a name="ln3940"> </a>
<a name="ln3941">static const int num_cmd_ops = CLO_NOPS;</a>
<a name="ln3942">static bool arg_seen[num_cmd_ops];</a>
<a name="ln3943"> </a>
<a name="ln3944">static string _find_executable_path()</a>
<a name="ln3945">{</a>
<a name="ln3946">    // A lot of OSes give ways to find the location of the running app's</a>
<a name="ln3947">    // binary executable. This is useful, because argv[0] can be relative</a>
<a name="ln3948">    // when we really need an absolute path in order to locate the game's</a>
<a name="ln3949">    // resources.</a>
<a name="ln3950">#if defined (TARGET_OS_WINDOWS)</a>
<a name="ln3951">    wchar_t tempPath[MAX_PATH];</a>
<a name="ln3952">    if (GetModuleFileNameW(nullptr, tempPath, MAX_PATH))</a>
<a name="ln3953">        return utf16_to_8(tempPath);</a>
<a name="ln3954">    else</a>
<a name="ln3955">        return &quot;&quot;;</a>
<a name="ln3956">#elif defined (TARGET_OS_LINUX) || defined (TARGET_OS_CYGWIN)</a>
<a name="ln3957">    char tempPath[2048];</a>
<a name="ln3958">    const ssize_t rsize =</a>
<a name="ln3959">        readlink(&quot;/proc/self/exe&quot;, tempPath, sizeof(tempPath) - 1);</a>
<a name="ln3960">    if (rsize &gt; 0)</a>
<a name="ln3961">    {</a>
<a name="ln3962">        tempPath[rsize] = 0;</a>
<a name="ln3963">        return mb_to_utf8(tempPath);</a>
<a name="ln3964">    }</a>
<a name="ln3965">    return &quot;&quot;;</a>
<a name="ln3966">#elif defined (TARGET_OS_MACOSX)</a>
<a name="ln3967">    return mb_to_utf8(NXArgv[0]);</a>
<a name="ln3968">#else</a>
<a name="ln3969">    // We don't know how to find the executable's path on this OS.</a>
<a name="ln3970">    return &quot;&quot;;</a>
<a name="ln3971">#endif</a>
<a name="ln3972">}</a>
<a name="ln3973"> </a>
<a name="ln3974">static void _print_version()</a>
<a name="ln3975">{</a>
<a name="ln3976">    printf(&quot;Crawl version %s%s&quot;, Version::Long, &quot;\n&quot;);</a>
<a name="ln3977">    printf(&quot;Save file version %d.%d%s&quot;, TAG_MAJOR_VERSION, TAG_MINOR_VERSION, &quot;\n&quot;);</a>
<a name="ln3978">    printf(&quot;%s&quot;, compilation_info);</a>
<a name="ln3979">}</a>
<a name="ln3980"> </a>
<a name="ln3981">static void _print_save_version(char *name)</a>
<a name="ln3982">{</a>
<a name="ln3983">    try</a>
<a name="ln3984">    {</a>
<a name="ln3985">        string filename = name;</a>
<a name="ln3986">        // Check for the exact filename first, then go by char name.</a>
<a name="ln3987">        if (!file_exists(filename))</a>
<a name="ln3988">            filename = get_savedir_filename(filename);</a>
<a name="ln3989">        package save(filename.c_str(), false);</a>
<a name="ln3990">        reader chrf(&amp;save, &quot;chr&quot;);</a>
<a name="ln3991"> </a>
<a name="ln3992">        save_version v = get_save_version(chrf);</a>
<a name="ln3993">        if (!v.valid())</a>
<a name="ln3994">            fail(&quot;Save file is invalid.&quot;);</a>
<a name="ln3995">        else</a>
<a name="ln3996">            printf(&quot;Save file version for %s is %d.%d\n&quot;, name, v.major, v.minor);</a>
<a name="ln3997">    }</a>
<a name="ln3998">    catch (ext_fail_exception &amp;fe)</a>
<a name="ln3999">    {</a>
<a name="ln4000">        fprintf(stderr, &quot;Error: %s\n&quot;, fe.what());</a>
<a name="ln4001">    }</a>
<a name="ln4002">}</a>
<a name="ln4003"> </a>
<a name="ln4004">enum es_command_type</a>
<a name="ln4005">{</a>
<a name="ln4006">    ES_LS,</a>
<a name="ln4007">    ES_RM,</a>
<a name="ln4008">    ES_GET,</a>
<a name="ln4009">    ES_PUT,</a>
<a name="ln4010">    ES_REPACK,</a>
<a name="ln4011">    ES_INFO,</a>
<a name="ln4012">    NUM_ES</a>
<a name="ln4013">};</a>
<a name="ln4014"> </a>
<a name="ln4015">enum eb_command_type</a>
<a name="ln4016">{</a>
<a name="ln4017">    EB_LS,</a>
<a name="ln4018">    EB_MERGE,</a>
<a name="ln4019">    EB_RM,</a>
<a name="ln4020">    EB_REWRITE,</a>
<a name="ln4021">    NUM_EB</a>
<a name="ln4022">};</a>
<a name="ln4023"> </a>
<a name="ln4024">template &lt;typename T&gt; struct edit_command</a>
<a name="ln4025">{</a>
<a name="ln4026">    T cmd;</a>
<a name="ln4027">    const char* name;</a>
<a name="ln4028">    bool rw;</a>
<a name="ln4029">    int min_args, max_args;</a>
<a name="ln4030">};</a>
<a name="ln4031"> </a>
<a name="ln4032">static edit_command&lt;es_command_type&gt; es_commands[] =</a>
<a name="ln4033">{</a>
<a name="ln4034">    { ES_LS,      &quot;ls&quot;,      false, 0, 0, },</a>
<a name="ln4035">    { ES_GET,     &quot;get&quot;,     false, 1, 2, },</a>
<a name="ln4036">    { ES_PUT,     &quot;put&quot;,     true,  1, 2, },</a>
<a name="ln4037">    { ES_RM,      &quot;rm&quot;,      true,  1, 1, },</a>
<a name="ln4038">    { ES_REPACK,  &quot;repack&quot;,  false, 0, 0, },</a>
<a name="ln4039">    { ES_INFO,    &quot;info&quot;,    false, 0, 0, },</a>
<a name="ln4040">};</a>
<a name="ln4041"> </a>
<a name="ln4042">static edit_command&lt;eb_command_type&gt; eb_commands[] =</a>
<a name="ln4043">{</a>
<a name="ln4044">    { EB_LS,       &quot;ls&quot;,      false, 0, 2, },</a>
<a name="ln4045">    { EB_MERGE,    &quot;merge&quot;,   false, 1, 1, },</a>
<a name="ln4046">    { EB_RM,       &quot;rm&quot;,      true,  1, 1 },</a>
<a name="ln4047">    { EB_REWRITE,  &quot;rewrite&quot;, true,  0, 1 },</a>
<a name="ln4048">};</a>
<a name="ln4049"> </a>
<a name="ln4050">#define FAIL(...) do { fprintf(stderr, __VA_ARGS__); return; } while (0)</a>
<a name="ln4051">static void _edit_save(int argc, char **argv)</a>
<a name="ln4052">{</a>
<a name="ln4053">    if (argc &lt;= 1 || !strcmp(argv[1], &quot;help&quot;))</a>
<a name="ln4054">    {</a>
<a name="ln4055">        printf(&quot;Usage: crawl --edit-save &lt;name&gt; &lt;command&gt;, where &lt;command&gt; may be:\n&quot;</a>
<a name="ln4056">               &quot;  ls                          list the chunks\n&quot;</a>
<a name="ln4057">               &quot;  get &lt;chunk&gt; [&lt;chunkfile&gt;]   extract a chunk into &lt;chunkfile&gt;\n&quot;</a>
<a name="ln4058">               &quot;  put &lt;chunk&gt; [&lt;chunkfile&gt;]   import a chunk from &lt;chunkfile&gt;\n&quot;</a>
<a name="ln4059">               &quot;     &lt;chunkfile&gt; defaults to \&quot;chunk\&quot;; use \&quot;-\&quot; for stdout/stdin\n&quot;</a>
<a name="ln4060">               &quot;  rm &lt;chunk&gt;                  delete a chunk\n&quot;</a>
<a name="ln4061">               &quot;  repack                      defrag and reclaim unused space\n&quot;</a>
<a name="ln4062">             );</a>
<a name="ln4063">        return;</a>
<a name="ln4064">    }</a>
<a name="ln4065">    const char *name = argv[0];</a>
<a name="ln4066">    const char *cmdn = argv[1];</a>
<a name="ln4067"> </a>
<a name="ln4068">    es_command_type cmd = NUM_ES;</a>
<a name="ln4069">    bool rw;</a>
<a name="ln4070"> </a>
<a name="ln4071">    for (const auto &amp;ec : es_commands)</a>
<a name="ln4072">        if (!strcmp(ec.name, cmdn))</a>
<a name="ln4073">        {</a>
<a name="ln4074">            if (argc &lt; ec.min_args + 2)</a>
<a name="ln4075">                FAIL(&quot;Too few arguments for %s.\n&quot;, cmdn);</a>
<a name="ln4076">            else if (argc &gt; ec.max_args + 2)</a>
<a name="ln4077">                FAIL(&quot;Too many arguments for %s.\n&quot;, cmdn);</a>
<a name="ln4078">            cmd = ec.cmd;</a>
<a name="ln4079">            rw = ec.rw;</a>
<a name="ln4080">            break;</a>
<a name="ln4081">        }</a>
<a name="ln4082">    if (cmd == NUM_ES)</a>
<a name="ln4083">        FAIL(&quot;Unknown command: %s.\n&quot;, cmdn);</a>
<a name="ln4084"> </a>
<a name="ln4085">    try</a>
<a name="ln4086">    {</a>
<a name="ln4087">        string filename = name;</a>
<a name="ln4088">        // Check for the exact filename first, then go by char name.</a>
<a name="ln4089">        if (!file_exists(filename))</a>
<a name="ln4090">            filename = get_savedir_filename(filename);</a>
<a name="ln4091">        package save(filename.c_str(), rw);</a>
<a name="ln4092"> </a>
<a name="ln4093">        if (cmd == ES_LS)</a>
<a name="ln4094">        {</a>
<a name="ln4095">            vector&lt;string&gt; list = save.list_chunks();</a>
<a name="ln4096">            sort(list.begin(), list.end(), numcmpstr);</a>
<a name="ln4097">            for (const string &amp;s : list)</a>
<a name="ln4098">                printf(&quot;%s\n&quot;, s.c_str());</a>
<a name="ln4099">        }</a>
<a name="ln4100">        else if (cmd == ES_GET)</a>
<a name="ln4101">        {</a>
<a name="ln4102">            const char *chunk = argv[2];</a>
<a name="ln4103">            if (!*chunk || strlen(chunk) &gt; MAX_CHUNK_NAME_LENGTH)</a>
<a name="ln4104">                FAIL(&quot;Invalid chunk name \&quot;%s\&quot;.\n&quot;, chunk);</a>
<a name="ln4105">            if (!save.has_chunk(chunk))</a>
<a name="ln4106">                FAIL(&quot;No such chunk in the save file.\n&quot;);</a>
<a name="ln4107">            chunk_reader inc(&amp;save, chunk);</a>
<a name="ln4108"> </a>
<a name="ln4109">            const char *file = (argc == 4) ? argv[3] : &quot;chunk&quot;;</a>
<a name="ln4110">            FILE *f;</a>
<a name="ln4111">            if (strcmp(file, &quot;-&quot;))</a>
<a name="ln4112">                f = fopen_u(file, &quot;wb&quot;);</a>
<a name="ln4113">            else</a>
<a name="ln4114">                f = stdout;</a>
<a name="ln4115">            if (!f)</a>
<a name="ln4116">                sysfail(&quot;Can't open \&quot;%s\&quot; for writing&quot;, file);</a>
<a name="ln4117"> </a>
<a name="ln4118">            char buf[16384];</a>
<a name="ln4119">            while (size_t s = inc.read(buf, sizeof(buf)))</a>
<a name="ln4120">                if (fwrite(buf, 1, s, f) != s)</a>
<a name="ln4121">                    sysfail(&quot;Error writing \&quot;%s\&quot;&quot;, file);</a>
<a name="ln4122"> </a>
<a name="ln4123">            if (f != stdout)</a>
<a name="ln4124">                if (fclose(f))</a>
<a name="ln4125">                    sysfail(&quot;Write error on close of \&quot;%s\&quot;&quot;, file);</a>
<a name="ln4126">        }</a>
<a name="ln4127">        else if (cmd == ES_PUT)</a>
<a name="ln4128">        {</a>
<a name="ln4129">            const char *chunk = argv[2];</a>
<a name="ln4130">            if (!*chunk || strlen(chunk) &gt; MAX_CHUNK_NAME_LENGTH)</a>
<a name="ln4131">                FAIL(&quot;Invalid chunk name \&quot;%s\&quot;.\n&quot;, chunk);</a>
<a name="ln4132"> </a>
<a name="ln4133">            const char *file = (argc == 4) ? argv[3] : &quot;chunk&quot;;</a>
<a name="ln4134">            FILE *f;</a>
<a name="ln4135">            if (strcmp(file, &quot;-&quot;))</a>
<a name="ln4136">                f = fopen_u(file, &quot;rb&quot;);</a>
<a name="ln4137">            else</a>
<a name="ln4138">                f = stdin;</a>
<a name="ln4139">            if (!f)</a>
<a name="ln4140">                sysfail(&quot;Can't read \&quot;%s\&quot;&quot;, file);</a>
<a name="ln4141">            chunk_writer outc(&amp;save, chunk);</a>
<a name="ln4142"> </a>
<a name="ln4143">            char buf[16384];</a>
<a name="ln4144">            while (size_t s = fread(buf, 1, sizeof(buf), f))</a>
<a name="ln4145">                outc.write(buf, s);</a>
<a name="ln4146">            if (ferror(f))</a>
<a name="ln4147">                sysfail(&quot;Error reading \&quot;%s\&quot;&quot;, file);</a>
<a name="ln4148"> </a>
<a name="ln4149">            if (f != stdin)</a>
<a name="ln4150">                fclose(f);</a>
<a name="ln4151">        }</a>
<a name="ln4152">        else if (cmd == ES_RM)</a>
<a name="ln4153">        {</a>
<a name="ln4154">            const char *chunk = argv[2];</a>
<a name="ln4155">            if (!*chunk || strlen(chunk) &gt; MAX_CHUNK_NAME_LENGTH)</a>
<a name="ln4156">                FAIL(&quot;Invalid chunk name \&quot;%s\&quot;.\n&quot;, chunk);</a>
<a name="ln4157">            if (!save.has_chunk(chunk))</a>
<a name="ln4158">                FAIL(&quot;No such chunk in the save file.\n&quot;);</a>
<a name="ln4159"> </a>
<a name="ln4160">            save.delete_chunk(chunk);</a>
<a name="ln4161">        }</a>
<a name="ln4162">        else if (cmd == ES_REPACK)</a>
<a name="ln4163">        {</a>
<a name="ln4164">            package save2((filename + &quot;.tmp&quot;).c_str(), true, true);</a>
<a name="ln4165">            for (const string &amp;chunk : save.list_chunks())</a>
<a name="ln4166">            {</a>
<a name="ln4167">                char buf[16384];</a>
<a name="ln4168"> </a>
<a name="ln4169">                chunk_reader in(&amp;save, chunk);</a>
<a name="ln4170">                chunk_writer out(&amp;save2, chunk);</a>
<a name="ln4171"> </a>
<a name="ln4172">                while (plen_t s = in.read(buf, sizeof(buf)))</a>
<a name="ln4173">                    out.write(buf, s);</a>
<a name="ln4174">            }</a>
<a name="ln4175">            save2.commit();</a>
<a name="ln4176">            save.unlink();</a>
<a name="ln4177">            rename_u((filename + &quot;.tmp&quot;).c_str(), filename.c_str());</a>
<a name="ln4178">        }</a>
<a name="ln4179">        else if (cmd == ES_INFO)</a>
<a name="ln4180">        {</a>
<a name="ln4181">            vector&lt;string&gt; list = save.list_chunks();</a>
<a name="ln4182">            sort(list.begin(), list.end(), numcmpstr);</a>
<a name="ln4183">            plen_t nchunks = list.size();</a>
<a name="ln4184">            plen_t frag = save.get_chunk_fragmentation(&quot;&quot;);</a>
<a name="ln4185">            plen_t flen = save.get_size();</a>
<a name="ln4186">            plen_t slack = save.get_slack();</a>
<a name="ln4187">            printf(&quot;Chunks: (size compressed/uncompressed, fragments, name)\n&quot;);</a>
<a name="ln4188">            for (const string &amp;chunk : list)</a>
<a name="ln4189">            {</a>
<a name="ln4190">                int cfrag = save.get_chunk_fragmentation(chunk);</a>
<a name="ln4191">                frag += cfrag;</a>
<a name="ln4192">                int cclen = save.get_chunk_compressed_length(chunk);</a>
<a name="ln4193"> </a>
<a name="ln4194">                char buf[16384];</a>
<a name="ln4195">                chunk_reader in(&amp;save, chunk);</a>
<a name="ln4196">                plen_t clen = 0;</a>
<a name="ln4197">                while (plen_t s = in.read(buf, sizeof(buf)))</a>
<a name="ln4198">                    clen += s;</a>
<a name="ln4199">                printf(&quot;%7d/%7d %3u %s\n&quot;, cclen, clen, cfrag, chunk.c_str());</a>
<a name="ln4200">            }</a>
<a name="ln4201">            // the directory is not a chunk visible from the outside</a>
<a name="ln4202">            printf(&quot;Fragmentation:    %u/%u (%4.2f)\n&quot;, frag, nchunks + 1,</a>
<a name="ln4203">                   ((float)frag) / (nchunks + 1));</a>
<a name="ln4204">            printf(&quot;Unused space:     %u/%u (%u%%)\n&quot;, slack, flen,</a>
<a name="ln4205">                   100 - (100 * (flen - slack) / flen));</a>
<a name="ln4206">            // there's also wasted space due to fragmentation, but since</a>
<a name="ln4207">            // it's linear, there's no need to print it</a>
<a name="ln4208">        }</a>
<a name="ln4209">    }</a>
<a name="ln4210">    catch (ext_fail_exception &amp;fe)</a>
<a name="ln4211">    {</a>
<a name="ln4212">        fprintf(stderr, &quot;Error: %s\n&quot;, fe.what());</a>
<a name="ln4213">    }</a>
<a name="ln4214">}</a>
<a name="ln4215"> </a>
<a name="ln4216">static save_version _read_bones_version(const string &amp;filename)</a>
<a name="ln4217">{</a>
<a name="ln4218">    reader inf(filename);</a>
<a name="ln4219">    if (!inf.valid())</a>
<a name="ln4220">    {</a>
<a name="ln4221">        string error = &quot;File doesn't exist: &quot; + filename;</a>
<a name="ln4222">        throw corrupted_save(error);</a>
<a name="ln4223">    }</a>
<a name="ln4224"> </a>
<a name="ln4225">    inf.set_safe_read(true); // don't die on 0-byte bones</a>
<a name="ln4226">    // use lower-level call here, because read_ghost_header fixes up the version</a>
<a name="ln4227">    save_version version = get_save_version(inf);</a>
<a name="ln4228">    inf.close();</a>
<a name="ln4229">    return version;</a>
<a name="ln4230">}</a>
<a name="ln4231"> </a>
<a name="ln4232">static void _write_bones(const string &amp;filename, vector&lt;ghost_demon&gt; ghosts)</a>
<a name="ln4233">{</a>
<a name="ln4234">    // TODO: duplicates some logic in files.cc</a>
<a name="ln4235">    FILE* ghost_file = lk_open_exclusive(filename);</a>
<a name="ln4236">    if (!ghost_file)</a>
<a name="ln4237">    {</a>
<a name="ln4238">        string error = &quot;Couldn't write to bones file &quot; + filename;</a>
<a name="ln4239">        throw corrupted_save(error);</a>
<a name="ln4240">    }</a>
<a name="ln4241">    writer outw(filename, ghost_file);</a>
<a name="ln4242"> </a>
<a name="ln4243">    write_ghost_version(outw);</a>
<a name="ln4244">    tag_write_ghosts(outw, ghosts);</a>
<a name="ln4245"> </a>
<a name="ln4246">    lk_close(ghost_file);</a>
<a name="ln4247">}</a>
<a name="ln4248"> </a>
<a name="ln4249">static void _bones_ls(const string &amp;filename, const string name_match,</a>
<a name="ln4250">                                                            bool long_output)</a>
<a name="ln4251">{</a>
<a name="ln4252">    save_version v = _read_bones_version(filename);</a>
<a name="ln4253">    cout &lt;&lt; &quot;Bones file '&quot; &lt;&lt; filename &lt;&lt; &quot;', version &quot; &lt;&lt; v.major &lt;&lt; &quot;.&quot;</a>
<a name="ln4254">         &lt;&lt; v.minor &lt;&lt; &quot;:\n&quot;;</a>
<a name="ln4255">    const vector&lt;ghost_demon&gt; ghosts = load_bones_file(filename, false);</a>
<a name="ln4256">    monster m;</a>
<a name="ln4257">    if (long_output)</a>
<a name="ln4258">    {</a>
<a name="ln4259">        init_monsters(); // no monster is valid without this</a>
<a name="ln4260">        init_spell_descs();</a>
<a name="ln4261">        init_spell_name_cache();</a>
<a name="ln4262">        m.reset();</a>
<a name="ln4263">        m.type = MONS_PROGRAM_BUG;</a>
<a name="ln4264">        m.base_monster = MONS_PHANTOM;</a>
<a name="ln4265">    }</a>
<a name="ln4266">    int count = 0;</a>
<a name="ln4267">    for (auto g : ghosts)</a>
<a name="ln4268">    {</a>
<a name="ln4269">        // TODO: partial name matching?</a>
<a name="ln4270">        if (name_match.size() &amp;&amp; name_match != lowercase_string(g.name))</a>
<a name="ln4271">            continue;</a>
<a name="ln4272">        count++;</a>
<a name="ln4273">        if (long_output)</a>
<a name="ln4274">        {</a>
<a name="ln4275">            // TOOD: line wrapping, some elements of this aren't meaningful at</a>
<a name="ln4276">            // the command line</a>
<a name="ln4277">            describe_info inf;</a>
<a name="ln4278">            m.set_ghost(g);</a>
<a name="ln4279">            m.ghost_init(false);</a>
<a name="ln4280">            m.type = MONS_PLAYER_GHOST;</a>
<a name="ln4281">            monster_info mi(&amp;m);</a>
<a name="ln4282">            bool has_stat_desc = false;</a>
<a name="ln4283">            get_monster_db_desc(mi, inf, has_stat_desc);</a>
<a name="ln4284">            cout &lt;&lt; &quot;#######################\n&quot;</a>
<a name="ln4285">                 &lt;&lt; inf.title &lt;&lt; &quot;\n&quot;</a>
<a name="ln4286">                 &lt;&lt; inf.body.str() &lt;&lt; &quot;\n&quot;</a>
<a name="ln4287">                 &lt;&lt; inf.footer &lt;&lt; &quot;\n&quot;;</a>
<a name="ln4288">        }</a>
<a name="ln4289">        else</a>
<a name="ln4290">        {</a>
<a name="ln4291">            cout &lt;&lt; std::setw(12) &lt;&lt; std::left &lt;&lt; g.name</a>
<a name="ln4292">                 &lt;&lt; &quot; XL&quot; &lt;&lt; std::setw(2) &lt;&lt; g.xl &lt;&lt; &quot; &quot;</a>
<a name="ln4293">                 &lt;&lt; combo_type{species_type(g.species), job_type(g.job)}.abbr()</a>
<a name="ln4294">                 &lt;&lt; &quot;\n&quot;;</a>
<a name="ln4295">        }</a>
<a name="ln4296">    }</a>
<a name="ln4297">    if (!count)</a>
<a name="ln4298">    {</a>
<a name="ln4299">        if (name_match.size())</a>
<a name="ln4300">            cout &lt;&lt; &quot;No matching ghosts for &quot; &lt;&lt; name_match &lt;&lt; &quot;.\n&quot;;</a>
<a name="ln4301">        else</a>
<a name="ln4302">            cout &lt;&lt; &quot;Empty ghost file.\n&quot;;</a>
<a name="ln4303">    }</a>
<a name="ln4304">    else</a>
<a name="ln4305">        cout &lt;&lt; count &lt;&lt; &quot; ghosts total\n&quot;;</a>
<a name="ln4306">}</a>
<a name="ln4307"> </a>
<a name="ln4308">static void _bones_rewrite(const string filename, const string remove, bool dedup)</a>
<a name="ln4309">{</a>
<a name="ln4310">    const vector&lt;ghost_demon&gt; ghosts = load_bones_file(filename, false);</a>
<a name="ln4311"> </a>
<a name="ln4312">    vector&lt;ghost_demon&gt; out;</a>
<a name="ln4313">    bool matched = false;</a>
<a name="ln4314">    const string remove_lower = lowercase_string(remove);</a>
<a name="ln4315">    map&lt;string, int&gt; ghosts_by_name;</a>
<a name="ln4316">    int dups = 0;</a>
<a name="ln4317"> </a>
<a name="ln4318">    for (auto g : ghosts)</a>
<a name="ln4319">    {</a>
<a name="ln4320">        if (dedup &amp;&amp; ghosts_by_name.count(g.name)</a>
<a name="ln4321">                                            &amp;&amp; ghosts_by_name[g.name] == g.xl)</a>
<a name="ln4322">        {</a>
<a name="ln4323">            dups++;</a>
<a name="ln4324">            continue;</a>
<a name="ln4325">        }</a>
<a name="ln4326">        if (lowercase_string(g.name) == remove_lower)</a>
<a name="ln4327">        {</a>
<a name="ln4328">            matched = true;</a>
<a name="ln4329">            continue;</a>
<a name="ln4330">        }</a>
<a name="ln4331">        out.push_back(g);</a>
<a name="ln4332">        ghosts_by_name[g.name] = g.xl;</a>
<a name="ln4333">    }</a>
<a name="ln4334">    if (matched || remove.size() == 0)</a>
<a name="ln4335">    {</a>
<a name="ln4336">        cout &lt;&lt; &quot;Rewriting '&quot; &lt;&lt; filename &lt;&lt; &quot;'&quot;;</a>
<a name="ln4337">        if (matched)</a>
<a name="ln4338">            cout &lt;&lt; &quot; without ghost '&quot; &lt;&lt; remove_lower &lt;&lt; &quot;'&quot;;</a>
<a name="ln4339">        if (dups)</a>
<a name="ln4340">            cout &lt;&lt; &quot;, &quot; &lt;&lt; dups &lt;&lt; &quot; duplicates removed&quot;;</a>
<a name="ln4341">        cout &lt;&lt; &quot;\n&quot;;</a>
<a name="ln4342">        unlink(filename.c_str());</a>
<a name="ln4343">        _write_bones(filename, out);</a>
<a name="ln4344">    }</a>
<a name="ln4345">    else</a>
<a name="ln4346">        cout &lt;&lt; &quot;No matching ghosts for '&quot; &lt;&lt; remove_lower &lt;&lt; &quot;'\n&quot;;</a>
<a name="ln4347">}</a>
<a name="ln4348"> </a>
<a name="ln4349">static void _bones_merge(const vector&lt;string&gt; files, const string out_name)</a>
<a name="ln4350">{</a>
<a name="ln4351">    vector&lt;ghost_demon&gt; out;</a>
<a name="ln4352">    for (auto filename : files)</a>
<a name="ln4353">    {</a>
<a name="ln4354">        auto ghosts = load_bones_file(filename, false);</a>
<a name="ln4355">        out.insert(out.end(), ghosts.begin(), ghosts.end());</a>
<a name="ln4356">    }</a>
<a name="ln4357">    if (file_exists(out_name))</a>
<a name="ln4358">        unlink(out_name.c_str());</a>
<a name="ln4359">    if (out.size() == 0)</a>
<a name="ln4360">        cout &lt;&lt; &quot;Writing empty bones file&quot;;</a>
<a name="ln4361">    else</a>
<a name="ln4362">        cout &lt;&lt; &quot;Writing &quot; &lt;&lt; out.size() &lt;&lt; &quot; ghosts&quot;;</a>
<a name="ln4363">    cout &lt;&lt; &quot; to &quot; &lt;&lt; out_name &lt;&lt; &quot;\n&quot;;</a>
<a name="ln4364">    _write_bones(out_name, out);</a>
<a name="ln4365">}</a>
<a name="ln4366"> </a>
<a name="ln4367">static void _edit_bones(int argc, char **argv)</a>
<a name="ln4368">{</a>
<a name="ln4369">    if (argc &lt;= 1 || !strcmp(argv[1], &quot;help&quot;))</a>
<a name="ln4370">    {</a>
<a name="ln4371">        printf(&quot;Usage: crawl --bones &lt;command&gt; ARGS, where &lt;command&gt; may be:\n&quot;</a>
<a name="ln4372">               &quot;  ls &lt;file&gt; [&lt;name&gt;] [--long] list the ghosts in &lt;file&gt;\n&quot;</a>
<a name="ln4373">               &quot;                              --long shows full monster descriptions\n&quot;</a>
<a name="ln4374">               &quot;  merge &lt;file1&gt; &lt;file2&gt;       merge two bones files together, rewriting into &lt;file2&gt;\n&quot;</a>
<a name="ln4375">               &quot;  rm &lt;file&gt; &lt;name&gt;            rewrite a ghost file without &lt;name&gt;\n&quot;</a>
<a name="ln4376">               &quot;  rewrite &lt;file&gt; [--dedup]    rewrite a ghost file, fixing up version etc.\n&quot;</a>
<a name="ln4377">             );</a>
<a name="ln4378">        return;</a>
<a name="ln4379">    }</a>
<a name="ln4380">    const char *cmdn = argv[0];</a>
<a name="ln4381">    const char *name = argv[1];</a>
<a name="ln4382"> </a>
<a name="ln4383">    eb_command_type cmd = NUM_EB;</a>
<a name="ln4384"> </a>
<a name="ln4385">    for (const auto &amp;ec : eb_commands)</a>
<a name="ln4386">        if (!strcmp(ec.name, cmdn))</a>
<a name="ln4387">        {</a>
<a name="ln4388">            if (argc &lt; ec.min_args + 2)</a>
<a name="ln4389">                FAIL(&quot;Too few arguments for %s.\n&quot;, cmdn);</a>
<a name="ln4390">            else if (argc &gt; ec.max_args + 2)</a>
<a name="ln4391">                FAIL(&quot;Too many arguments for %s.\n&quot;, cmdn);</a>
<a name="ln4392">            cmd = ec.cmd;</a>
<a name="ln4393">            break;</a>
<a name="ln4394">        }</a>
<a name="ln4395">    if (cmd == NUM_EB)</a>
<a name="ln4396">        FAIL(&quot;Unknown command: %s.\n&quot;, cmdn);</a>
<a name="ln4397"> </a>
<a name="ln4398">    try</a>
<a name="ln4399">    {</a>
<a name="ln4400">        if (!file_exists(name))</a>
<a name="ln4401">            FAIL(&quot;'%s' doesn't exist!\n&quot;, name);</a>
<a name="ln4402"> </a>
<a name="ln4403">        if (cmd == EB_LS)</a>
<a name="ln4404">        {</a>
<a name="ln4405">            const bool long_out =</a>
<a name="ln4406">                           argc == 3 &amp;&amp; !strcmp(argv[2], &quot;--long&quot;)</a>
<a name="ln4407">                        || argc == 4 &amp;&amp; !strcmp(argv[3], &quot;--long&quot;);</a>
<a name="ln4408">            if (argc == 4 &amp;&amp; !long_out)</a>
<a name="ln4409">                FAIL(&quot;Unknown extra option to ls: '%s'\n&quot;, argv[3]);</a>
<a name="ln4410">            const string name_match = argc == 3 &amp;&amp; !long_out || argc == 4</a>
<a name="ln4411">                                    ? string(argv[2])</a>
<a name="ln4412">                                    : &quot;&quot;;</a>
<a name="ln4413">            _bones_ls(name, lowercase_string(name_match), long_out);</a>
<a name="ln4414">        }</a>
<a name="ln4415">        else if (cmd == EB_REWRITE)</a>
<a name="ln4416">        {</a>
<a name="ln4417">            const bool dedup = argc == 3 &amp;&amp; !strcmp(argv[2], &quot;--dedup&quot;);</a>
<a name="ln4418">            if (argc == 3 &amp;&amp; !dedup)</a>
<a name="ln4419">                FAIL(&quot;Unknown extra argument to rewrite: '%s'\n&quot;, argv[2]);</a>
<a name="ln4420">            _bones_rewrite(name, &quot;&quot;, dedup);</a>
<a name="ln4421">        }</a>
<a name="ln4422">        else if (cmd == EB_RM)</a>
<a name="ln4423">        {</a>
<a name="ln4424">            const string name_match = argv[2];</a>
<a name="ln4425">            _bones_rewrite(name, name_match, false);</a>
<a name="ln4426">        }</a>
<a name="ln4427">        else if (cmd == EB_MERGE)</a>
<a name="ln4428">        {</a>
<a name="ln4429">            const string out_name = argv[2];</a>
<a name="ln4430">            _bones_merge({name, out_name}, out_name);</a>
<a name="ln4431">        }</a>
<a name="ln4432">    }</a>
<a name="ln4433">    catch (corrupted_save &amp;err)</a>
<a name="ln4434">    {</a>
<a name="ln4435">        // not a corrupted save per se, just from the future. Try to load the</a>
<a name="ln4436">        // versioned bones file if it exists.</a>
<a name="ln4437">        if (err.version.valid() &amp;&amp; err.version.is_future())</a>
<a name="ln4438">        {</a>
<a name="ln4439">            FAIL(&quot;Bones file '%s' is from the future (%d.%d), this instance of &quot;</a>
<a name="ln4440">                 &quot;crawl needs %d.%d.\n&quot;, name,</a>
<a name="ln4441">                    err.version.major, err.version.minor,</a>
<a name="ln4442">                    save_version::current_bones().major,</a>
<a name="ln4443">                    save_version::current_bones().minor);</a>
<a name="ln4444">        }</a>
<a name="ln4445">        else</a>
<a name="ln4446">            FAIL(&quot;Error: %s\n&quot;, err.what());</a>
<a name="ln4447">    }</a>
<a name="ln4448">    catch (ext_fail_exception &amp;fe)</a>
<a name="ln4449">    {</a>
<a name="ln4450">        FAIL(&quot;Error: %s\n&quot;, fe.what());</a>
<a name="ln4451">    }</a>
<a name="ln4452">}</a>
<a name="ln4453"> </a>
<a name="ln4454">#undef FAIL</a>
<a name="ln4455"> </a>
<a name="ln4456">#ifdef USE_TILE_WEB</a>
<a name="ln4457">static void _write_colour_list(const vector&lt;pair&lt;int, int&gt; &gt; variable,</a>
<a name="ln4458">        const string &amp;name)</a>
<a name="ln4459">{</a>
<a name="ln4460">    tiles.json_open_array(name);</a>
<a name="ln4461">    for (const auto &amp;entry : variable)</a>
<a name="ln4462">    {</a>
<a name="ln4463">        tiles.json_open_object();</a>
<a name="ln4464">        tiles.json_write_int(&quot;value&quot;, entry.first);</a>
<a name="ln4465">        tiles.json_write_string(&quot;colour&quot;, colour_to_str(entry.second));</a>
<a name="ln4466">        tiles.json_close_object();</a>
<a name="ln4467">    }</a>
<a name="ln4468">    tiles.json_close_array();</a>
<a name="ln4469">}</a>
<a name="ln4470"> </a>
<a name="ln4471">static void _write_vcolour(const string &amp;name, VColour colour)</a>
<a name="ln4472">{</a>
<a name="ln4473">    tiles.json_open_object(name);</a>
<a name="ln4474">    tiles.json_write_int(&quot;r&quot;, colour.r);</a>
<a name="ln4475">    tiles.json_write_int(&quot;g&quot;, colour.g);</a>
<a name="ln4476">    tiles.json_write_int(&quot;b&quot;, colour.b);</a>
<a name="ln4477">    if (colour.a != 255)</a>
<a name="ln4478">        tiles.json_write_int(&quot;a&quot;, colour.a);</a>
<a name="ln4479">    tiles.json_close_object();</a>
<a name="ln4480">}</a>
<a name="ln4481"> </a>
<a name="ln4482">static void _write_minimap_colours()</a>
<a name="ln4483">{</a>
<a name="ln4484">    _write_vcolour(&quot;tile_unseen_col&quot;, Options.tile_unseen_col);</a>
<a name="ln4485">    _write_vcolour(&quot;tile_floor_col&quot;, Options.tile_floor_col);</a>
<a name="ln4486">    _write_vcolour(&quot;tile_wall_col&quot;, Options.tile_wall_col);</a>
<a name="ln4487">    _write_vcolour(&quot;tile_mapped_floor_col&quot;, Options.tile_mapped_floor_col);</a>
<a name="ln4488">    _write_vcolour(&quot;tile_mapped_wall_col&quot;, Options.tile_mapped_wall_col);</a>
<a name="ln4489">    _write_vcolour(&quot;tile_door_col&quot;, Options.tile_door_col);</a>
<a name="ln4490">    _write_vcolour(&quot;tile_item_col&quot;, Options.tile_item_col);</a>
<a name="ln4491">    _write_vcolour(&quot;tile_monster_col&quot;, Options.tile_monster_col);</a>
<a name="ln4492">    _write_vcolour(&quot;tile_plant_col&quot;, Options.tile_plant_col);</a>
<a name="ln4493">    _write_vcolour(&quot;tile_upstairs_col&quot;, Options.tile_upstairs_col);</a>
<a name="ln4494">    _write_vcolour(&quot;tile_downstairs_col&quot;, Options.tile_downstairs_col);</a>
<a name="ln4495">    _write_vcolour(&quot;tile_branchstairs_col&quot;, Options.tile_branchstairs_col);</a>
<a name="ln4496">    _write_vcolour(&quot;tile_feature_col&quot;, Options.tile_feature_col);</a>
<a name="ln4497">    _write_vcolour(&quot;tile_water_col&quot;, Options.tile_water_col);</a>
<a name="ln4498">    _write_vcolour(&quot;tile_lava_col&quot;, Options.tile_lava_col);</a>
<a name="ln4499">    _write_vcolour(&quot;tile_trap_col&quot;, Options.tile_trap_col);</a>
<a name="ln4500">    _write_vcolour(&quot;tile_excl_centre_col&quot;, Options.tile_excl_centre_col);</a>
<a name="ln4501">    _write_vcolour(&quot;tile_excluded_col&quot;, Options.tile_excluded_col);</a>
<a name="ln4502">    _write_vcolour(&quot;tile_player_col&quot;, Options.tile_player_col);</a>
<a name="ln4503">    _write_vcolour(&quot;tile_deep_water_col&quot;, Options.tile_deep_water_col);</a>
<a name="ln4504">    _write_vcolour(&quot;tile_portal_col&quot;, Options.tile_portal_col);</a>
<a name="ln4505">    _write_vcolour(&quot;tile_transporter_col&quot;, Options.tile_transporter_col);</a>
<a name="ln4506">    _write_vcolour(&quot;tile_transporter_landing_col&quot;, Options.tile_transporter_landing_col);</a>
<a name="ln4507">    _write_vcolour(&quot;tile_explore_horizon_col&quot;, Options.tile_explore_horizon_col);</a>
<a name="ln4508"> </a>
<a name="ln4509">    _write_vcolour(&quot;tile_window_col&quot;, Options.tile_window_col);</a>
<a name="ln4510">}</a>
<a name="ln4511"> </a>
<a name="ln4512">void game_options::write_webtiles_options(const string&amp; name)</a>
<a name="ln4513">{</a>
<a name="ln4514">    tiles.json_open_object(name);</a>
<a name="ln4515"> </a>
<a name="ln4516">    _write_colour_list(Options.hp_colour, &quot;hp_colour&quot;);</a>
<a name="ln4517">    _write_colour_list(Options.mp_colour, &quot;mp_colour&quot;);</a>
<a name="ln4518">    _write_colour_list(Options.stat_colour, &quot;stat_colour&quot;);</a>
<a name="ln4519"> </a>
<a name="ln4520">    tiles.json_write_bool(&quot;tile_show_minihealthbar&quot;,</a>
<a name="ln4521">                          Options.tile_show_minihealthbar);</a>
<a name="ln4522">    tiles.json_write_bool(&quot;tile_show_minimagicbar&quot;,</a>
<a name="ln4523">                          Options.tile_show_minimagicbar);</a>
<a name="ln4524">    tiles.json_write_bool(&quot;tile_show_demon_tier&quot;,</a>
<a name="ln4525">                          Options.tile_show_demon_tier);</a>
<a name="ln4526"> </a>
<a name="ln4527">    tiles.json_write_int(&quot;tile_map_pixels&quot;, Options.tile_map_pixels);</a>
<a name="ln4528"> </a>
<a name="ln4529">    tiles.json_write_string(&quot;tile_display_mode&quot;, Options.tile_display_mode);</a>
<a name="ln4530">    tiles.json_write_int(&quot;tile_cell_pixels&quot;, Options.tile_cell_pixels);</a>
<a name="ln4531">    tiles.json_write_int(&quot;tile_viewport_scale&quot;, Options.tile_viewport_scale);</a>
<a name="ln4532">    tiles.json_write_int(&quot;tile_map_scale&quot;, Options.tile_map_scale);</a>
<a name="ln4533">    tiles.json_write_bool(&quot;tile_filter_scaling&quot;, Options.tile_filter_scaling);</a>
<a name="ln4534">    tiles.json_write_bool(&quot;tile_water_anim&quot;, Options.tile_water_anim);</a>
<a name="ln4535">    tiles.json_write_bool(&quot;tile_misc_anim&quot;, Options.tile_misc_anim);</a>
<a name="ln4536">    tiles.json_write_bool(&quot;tile_realtime_anim&quot;, Options.tile_realtime_anim);</a>
<a name="ln4537">    tiles.json_write_bool(&quot;tile_level_map_hide_messages&quot;,</a>
<a name="ln4538">            Options.tile_level_map_hide_messages);</a>
<a name="ln4539">    tiles.json_write_bool(&quot;tile_level_map_hide_sidebar&quot;,</a>
<a name="ln4540">            Options.tile_level_map_hide_sidebar);</a>
<a name="ln4541">    tiles.json_write_bool(&quot;tile_web_mouse_control&quot;, Options.tile_web_mouse_control);</a>
<a name="ln4542">    tiles.json_write_bool(&quot;tile_menu_icons&quot;, Options.tile_menu_icons);</a>
<a name="ln4543"> </a>
<a name="ln4544">    tiles.json_write_string(&quot;tile_font_crt_family&quot;,</a>
<a name="ln4545">            Options.tile_font_crt_family);</a>
<a name="ln4546">    tiles.json_write_string(&quot;tile_font_stat_family&quot;,</a>
<a name="ln4547">            Options.tile_font_stat_family);</a>
<a name="ln4548">    tiles.json_write_string(&quot;tile_font_msg_family&quot;,</a>
<a name="ln4549">            Options.tile_font_msg_family);</a>
<a name="ln4550">    tiles.json_write_string(&quot;tile_font_lbl_family&quot;,</a>
<a name="ln4551">            Options.tile_font_lbl_family);</a>
<a name="ln4552">    tiles.json_write_int(&quot;tile_font_crt_size&quot;, Options.tile_font_crt_size);</a>
<a name="ln4553">    tiles.json_write_int(&quot;tile_font_stat_size&quot;, Options.tile_font_stat_size);</a>
<a name="ln4554">    tiles.json_write_int(&quot;tile_font_msg_size&quot;, Options.tile_font_msg_size);</a>
<a name="ln4555">    tiles.json_write_int(&quot;tile_font_lbl_size&quot;, Options.tile_font_lbl_size);</a>
<a name="ln4556"> </a>
<a name="ln4557">    tiles.json_write_bool(&quot;show_game_time&quot;, Options.show_game_time);</a>
<a name="ln4558"> </a>
<a name="ln4559">    _write_minimap_colours();</a>
<a name="ln4560"> </a>
<a name="ln4561">    tiles.json_close_object();</a>
<a name="ln4562">}</a>
<a name="ln4563"> </a>
<a name="ln4564">static void _print_webtiles_options()</a>
<a name="ln4565">{</a>
<a name="ln4566">    Options.write_webtiles_options(&quot;&quot;);</a>
<a name="ln4567">    printf(&quot;%s\n&quot;, tiles.get_message().c_str());</a>
<a name="ln4568">}</a>
<a name="ln4569">#endif</a>
<a name="ln4570"> </a>
<a name="ln4571">static bool _check_extra_opt(char* _opt)</a>
<a name="ln4572">{</a>
<a name="ln4573">    string opt(_opt);</a>
<a name="ln4574">    trim_string(opt);</a>
<a name="ln4575"> </a>
<a name="ln4576">    if (opt[0] == ':' || opt[0] == '&lt;' || opt[0] == '{'</a>
<a name="ln4577">        || starts_with(opt, &quot;L&lt;&quot;) || starts_with(opt, &quot;Lua{&quot;))</a>
<a name="ln4578">    {</a>
<a name="ln4579">        fprintf(stderr, &quot;An extra option can't use Lua (%s)\n&quot;,</a>
<a name="ln4580">                _opt);</a>
<a name="ln4581">        return false;</a>
<a name="ln4582">    }</a>
<a name="ln4583"> </a>
<a name="ln4584">    if (opt[0] == '#')</a>
<a name="ln4585">    {</a>
<a name="ln4586">        fprintf(stderr, &quot;An extra option can't be a comment (%s)\n&quot;,</a>
<a name="ln4587">                _opt);</a>
<a name="ln4588">        return false;</a>
<a name="ln4589">    }</a>
<a name="ln4590"> </a>
<a name="ln4591">    if (opt.find_first_of('=') == string::npos)</a>
<a name="ln4592">    {</a>
<a name="ln4593">        fprintf(stderr, &quot;An extra opt must contain a '=' (%s)\n&quot;,</a>
<a name="ln4594">                _opt);</a>
<a name="ln4595">        return false;</a>
<a name="ln4596">    }</a>
<a name="ln4597"> </a>
<a name="ln4598">    vector&lt;string&gt; parts = split_string(opt, &quot;=&quot;);</a>
<a name="ln4599">    if (opt.find_first_of('=') == 0 || parts[0].length() == 0)</a>
<a name="ln4600">    {</a>
<a name="ln4601">        fprintf(stderr, &quot;An extra opt must have an option name (%s)\n&quot;,</a>
<a name="ln4602">                _opt);</a>
<a name="ln4603">        return false;</a>
<a name="ln4604">    }</a>
<a name="ln4605"> </a>
<a name="ln4606">    return true;</a>
<a name="ln4607">}</a>
<a name="ln4608"> </a>
<a name="ln4609">bool parse_args(int argc, char **argv, bool rc_only)</a>
<a name="ln4610">{</a>
<a name="ln4611">    COMPILE_CHECK(ARRAYSZ(cmd_ops) == CLO_NOPS);</a>
<a name="ln4612"> </a>
<a name="ln4613">#ifndef DEBUG_STATISTICS</a>
<a name="ln4614">    const char *dbg_stat_err = &quot;mapstat and objstat are available only in &quot;</a>
<a name="ln4615">                               &quot;DEBUG_STATISTICS builds.\n&quot;;</a>
<a name="ln4616">#endif</a>
<a name="ln4617"> </a>
<a name="ln4618">    if (crawl_state.command_line_arguments.empty())</a>
<a name="ln4619">    {</a>
<a name="ln4620">        crawl_state.command_line_arguments.insert(</a>
<a name="ln4621">            crawl_state.command_line_arguments.end(),</a>
<a name="ln4622">            argv, argv + argc);</a>
<a name="ln4623">    }</a>
<a name="ln4624"> </a>
<a name="ln4625">    string exe_path = _find_executable_path();</a>
<a name="ln4626"> </a>
<a name="ln4627">    if (!exe_path.empty())</a>
<a name="ln4628">        set_crawl_base_dir(exe_path.c_str());</a>
<a name="ln4629">    else</a>
<a name="ln4630">        set_crawl_base_dir(argv[0]);</a>
<a name="ln4631"> </a>
<a name="ln4632">    SysEnv.crawl_exe = get_base_filename(argv[0]);</a>
<a name="ln4633"> </a>
<a name="ln4634">    SysEnv.rcdirs.clear();</a>
<a name="ln4635">    SysEnv.map_gen_iters = 0;</a>
<a name="ln4636"> </a>
<a name="ln4637">    if (argc &lt; 2)           // no args!</a>
<a name="ln4638">        return true;</a>
<a name="ln4639"> </a>
<a name="ln4640">    char *arg, *next_arg;</a>
<a name="ln4641">    int current = 1;</a>
<a name="ln4642">    bool nextUsed = false;</a>
<a name="ln4643">    int ecount;</a>
<a name="ln4644"> </a>
<a name="ln4645">    // initialise</a>
<a name="ln4646">    for (int i = 0; i &lt; num_cmd_ops; i++)</a>
<a name="ln4647">         arg_seen[i] = false;</a>
<a name="ln4648"> </a>
<a name="ln4649">    if (SysEnv.cmd_args.empty())</a>
<a name="ln4650">    {</a>
<a name="ln4651">        for (int i = 1; i &lt; argc; ++i)</a>
<a name="ln4652">            SysEnv.cmd_args.emplace_back(argv[i]);</a>
<a name="ln4653">    }</a>
<a name="ln4654"> </a>
<a name="ln4655">    while (current &lt; argc)</a>
<a name="ln4656">    {</a>
<a name="ln4657">        // get argument</a>
<a name="ln4658">        arg = argv[current];</a>
<a name="ln4659"> </a>
<a name="ln4660">        // next argument (if there is one)</a>
<a name="ln4661">        if (current+1 &lt; argc)</a>
<a name="ln4662">            next_arg = argv[current+1];</a>
<a name="ln4663">        else</a>
<a name="ln4664">            next_arg = nullptr;</a>
<a name="ln4665"> </a>
<a name="ln4666">        nextUsed = false;</a>
<a name="ln4667"> </a>
<a name="ln4668">        // arg MUST begin with '-'</a>
<a name="ln4669">        char c = arg[0];</a>
<a name="ln4670">        if (c != '-')</a>
<a name="ln4671">        {</a>
<a name="ln4672">            fprintf(stderr,</a>
<a name="ln4673">                    &quot;Option '%s' is invalid; options must be prefixed &quot;</a>
<a name="ln4674">                    &quot;with -\n\n&quot;, arg);</a>
<a name="ln4675">            return false;</a>
<a name="ln4676">        }</a>
<a name="ln4677"> </a>
<a name="ln4678">        // Look for match (we accept both -option and --option).</a>
<a name="ln4679">        if (arg[1] == '-')</a>
<a name="ln4680">            arg = &amp;arg[2];</a>
<a name="ln4681">        else</a>
<a name="ln4682">            arg = &amp;arg[1];</a>
<a name="ln4683"> </a>
<a name="ln4684">        // Mac app bundle executables get a process serial number</a>
<a name="ln4685">        if (strncmp(arg, &quot;psn_&quot;, 4) == 0)</a>
<a name="ln4686">        {</a>
<a name="ln4687">            current++;</a>
<a name="ln4688">            continue;</a>
<a name="ln4689">        }</a>
<a name="ln4690"> </a>
<a name="ln4691">        int o;</a>
<a name="ln4692">        for (o = 0; o &lt; num_cmd_ops; o++)</a>
<a name="ln4693">            if (strcasecmp(cmd_ops[o], arg) == 0)</a>
<a name="ln4694">                break;</a>
<a name="ln4695"> </a>
<a name="ln4696">        // Print the list of commandline options for &quot;--help&quot;.</a>
<a name="ln4697">        if (o == CLO_HELP)</a>
<a name="ln4698">            return false;</a>
<a name="ln4699"> </a>
<a name="ln4700">        if (o == num_cmd_ops)</a>
<a name="ln4701">        {</a>
<a name="ln4702">            fprintf(stderr,</a>
<a name="ln4703">                    &quot;Unknown option: %s\n\n&quot;, argv[current]);</a>
<a name="ln4704">            return false;</a>
<a name="ln4705">        }</a>
<a name="ln4706"> </a>
<a name="ln4707">        // Disallow options specified more than once.</a>
<a name="ln4708">        if (arg_seen[o])</a>
<a name="ln4709">        {</a>
<a name="ln4710">            fprintf(stderr, &quot;Duplicate option: %s\n\n&quot;, argv[current]);</a>
<a name="ln4711">            return false;</a>
<a name="ln4712">        }</a>
<a name="ln4713"> </a>
<a name="ln4714">        // Set arg to 'seen'.</a>
<a name="ln4715">        arg_seen[o] = true;</a>
<a name="ln4716"> </a>
<a name="ln4717">        // Partially parse next argument.</a>
<a name="ln4718">        bool next_is_param = false;</a>
<a name="ln4719">        if (next_arg != nullptr</a>
<a name="ln4720">            &amp;&amp; (next_arg[0] != '-' || strlen(next_arg) == 1))</a>
<a name="ln4721">        {</a>
<a name="ln4722">            next_is_param = true;</a>
<a name="ln4723">        }</a>
<a name="ln4724"> </a>
<a name="ln4725">        // Take action according to the cmd chosen.</a>
<a name="ln4726">        switch (o)</a>
<a name="ln4727">        {</a>
<a name="ln4728">        case CLO_SCORES:</a>
<a name="ln4729">        case CLO_TSCORES:</a>
<a name="ln4730">        case CLO_VSCORES:</a>
<a name="ln4731">            if (!next_is_param)</a>
<a name="ln4732">                ecount = -1;            // default</a>
<a name="ln4733">            else // optional number given</a>
<a name="ln4734">            {</a>
<a name="ln4735">                ecount = atoi(next_arg);</a>
<a name="ln4736">                if (ecount &lt; 1)</a>
<a name="ln4737">                    ecount = 1;</a>
<a name="ln4738"> </a>
<a name="ln4739">                if (ecount &gt; SCORE_FILE_ENTRIES)</a>
<a name="ln4740">                    ecount = SCORE_FILE_ENTRIES;</a>
<a name="ln4741"> </a>
<a name="ln4742">                nextUsed = true;</a>
<a name="ln4743">            }</a>
<a name="ln4744"> </a>
<a name="ln4745">            if (!rc_only)</a>
<a name="ln4746">            {</a>
<a name="ln4747">                Options.sc_entries = ecount;</a>
<a name="ln4748"> </a>
<a name="ln4749">                if (o == CLO_TSCORES)</a>
<a name="ln4750">                    Options.sc_format = SCORE_TERSE;</a>
<a name="ln4751">                else if (o == CLO_VSCORES)</a>
<a name="ln4752">                    Options.sc_format = SCORE_VERBOSE;</a>
<a name="ln4753">                else if (o == CLO_SCORES)</a>
<a name="ln4754">                    Options.sc_format = SCORE_REGULAR;</a>
<a name="ln4755">            }</a>
<a name="ln4756">            break;</a>
<a name="ln4757"> </a>
<a name="ln4758">        case CLO_MAPSTAT:</a>
<a name="ln4759">        case CLO_OBJSTAT:</a>
<a name="ln4760">#ifdef DEBUG_STATISTICS</a>
<a name="ln4761">            if (o == CLO_MAPSTAT)</a>
<a name="ln4762">                crawl_state.map_stat_gen = true;</a>
<a name="ln4763">            else</a>
<a name="ln4764">                crawl_state.obj_stat_gen = true;</a>
<a name="ln4765">#ifdef USE_TILE_LOCAL</a>
<a name="ln4766">            crawl_state.tiles_disabled = true;</a>
<a name="ln4767">#endif</a>
<a name="ln4768"> </a>
<a name="ln4769">            if (!SysEnv.map_gen_iters)</a>
<a name="ln4770">                SysEnv.map_gen_iters = 100;</a>
<a name="ln4771">            if (next_is_param)</a>
<a name="ln4772">            {</a>
<a name="ln4773">                SysEnv.map_gen_range.reset(new depth_ranges);</a>
<a name="ln4774">                try</a>
<a name="ln4775">                {</a>
<a name="ln4776">                    *SysEnv.map_gen_range =</a>
<a name="ln4777">                        depth_ranges::parse_depth_ranges(next_arg);</a>
<a name="ln4778">                }</a>
<a name="ln4779">                catch (const bad_level_id &amp;err)</a>
<a name="ln4780">                {</a>
<a name="ln4781">                    end(1, false, &quot;Error parsing depths: %s\n&quot;, err.what());</a>
<a name="ln4782">                }</a>
<a name="ln4783">                nextUsed = true;</a>
<a name="ln4784">            }</a>
<a name="ln4785">            break;</a>
<a name="ln4786">#else</a>
<a name="ln4787">            end(1, false, &quot;%s&quot;, dbg_stat_err);</a>
<a name="ln4788">#endif</a>
<a name="ln4789">        case CLO_MAPSTAT_DUMP_DISCONNECT:</a>
<a name="ln4790">#ifdef DEBUG_STATISTICS</a>
<a name="ln4791">            crawl_state.map_stat_dump_disconnect = true;</a>
<a name="ln4792">#else</a>
<a name="ln4793">            end(1, false, &quot;%s&quot;, dbg_stat_err);</a>
<a name="ln4794">#endif</a>
<a name="ln4795">        case CLO_ITERATIONS:</a>
<a name="ln4796">#ifdef DEBUG_STATISTICS</a>
<a name="ln4797">            if (!next_is_param || !isadigit(*next_arg))</a>
<a name="ln4798">                end(1, false, &quot;Integer argument required for -%s\n&quot;, arg);</a>
<a name="ln4799">            else</a>
<a name="ln4800">            {</a>
<a name="ln4801">                SysEnv.map_gen_iters = atoi(next_arg);</a>
<a name="ln4802">                if (SysEnv.map_gen_iters &lt; 1)</a>
<a name="ln4803">                    SysEnv.map_gen_iters = 1;</a>
<a name="ln4804">                else if (SysEnv.map_gen_iters &gt; 10000)</a>
<a name="ln4805">                    SysEnv.map_gen_iters = 10000;</a>
<a name="ln4806">                nextUsed = true;</a>
<a name="ln4807">            }</a>
<a name="ln4808">#else</a>
<a name="ln4809">            end(1, false, &quot;%s&quot;, dbg_stat_err);</a>
<a name="ln4810">#endif</a>
<a name="ln4811">            break;</a>
<a name="ln4812"> </a>
<a name="ln4813">        case CLO_FORCE_MAP:</a>
<a name="ln4814">#ifdef DEBUG_STATISTICS</a>
<a name="ln4815">            if (!next_is_param)</a>
<a name="ln4816">                end(1, false, &quot;String argument required for -%s\n&quot;, arg);</a>
<a name="ln4817">            else</a>
<a name="ln4818">            {</a>
<a name="ln4819">                crawl_state.force_map = next_arg;</a>
<a name="ln4820">                nextUsed = true;</a>
<a name="ln4821">            }</a>
<a name="ln4822">#else</a>
<a name="ln4823">            end(1, false, &quot;%s&quot;, dbg_stat_err);</a>
<a name="ln4824">#endif</a>
<a name="ln4825">            break;</a>
<a name="ln4826"> </a>
<a name="ln4827">        case CLO_ARENA:</a>
<a name="ln4828">            if (!rc_only)</a>
<a name="ln4829">            {</a>
<a name="ln4830">                Options.game.type = GAME_TYPE_ARENA;</a>
<a name="ln4831">                Options.restart_after_game = MB_FALSE;</a>
<a name="ln4832">            }</a>
<a name="ln4833">            if (next_is_param)</a>
<a name="ln4834">            {</a>
<a name="ln4835">                if (!rc_only)</a>
<a name="ln4836">                    Options.game.arena_teams = next_arg;</a>
<a name="ln4837">                nextUsed = true;</a>
<a name="ln4838">            }</a>
<a name="ln4839">            break;</a>
<a name="ln4840"> </a>
<a name="ln4841">        case CLO_DUMP_MAPS:</a>
<a name="ln4842">            crawl_state.dump_maps = true;</a>
<a name="ln4843">            break;</a>
<a name="ln4844"> </a>
<a name="ln4845">        case CLO_PLAYABLE_JSON:</a>
<a name="ln4846">            fprintf(stdout, &quot;%s&quot;, playable_metadata_json().c_str());</a>
<a name="ln4847">            end(0);</a>
<a name="ln4848"> </a>
<a name="ln4849">        case CLO_BRANCHES_JSON:</a>
<a name="ln4850">            fprintf(stdout, &quot;%s&quot;, branch_data_json().c_str());</a>
<a name="ln4851">            end(0);</a>
<a name="ln4852"> </a>
<a name="ln4853">        case CLO_TEST:</a>
<a name="ln4854">            crawl_state.test = true;</a>
<a name="ln4855">            if (next_is_param)</a>
<a name="ln4856">            {</a>
<a name="ln4857">                if (!(crawl_state.test_list = !strcmp(next_arg, &quot;list&quot;)))</a>
<a name="ln4858">                    crawl_state.tests_selected = split_string(&quot;,&quot;, next_arg);</a>
<a name="ln4859">                nextUsed = true;</a>
<a name="ln4860">            }</a>
<a name="ln4861">            break;</a>
<a name="ln4862"> </a>
<a name="ln4863">        case CLO_SCRIPT:</a>
<a name="ln4864">            crawl_state.test   = true;</a>
<a name="ln4865">            crawl_state.script = true;</a>
<a name="ln4866">            crawl_state.script_args.clear();</a>
<a name="ln4867">            if (current &lt; argc - 1)</a>
<a name="ln4868">            {</a>
<a name="ln4869">                crawl_state.tests_selected = split_string(&quot;,&quot;, next_arg);</a>
<a name="ln4870">                for (int extra = current + 2; extra &lt; argc; ++extra)</a>
<a name="ln4871">                    crawl_state.script_args.emplace_back(argv[extra]);</a>
<a name="ln4872">                current = argc;</a>
<a name="ln4873">            }</a>
<a name="ln4874">            else</a>
<a name="ln4875">            {</a>
<a name="ln4876">                end(1, false,</a>
<a name="ln4877">                    &quot;-script must specify comma-separated script names&quot;);</a>
<a name="ln4878">            }</a>
<a name="ln4879">            break;</a>
<a name="ln4880"> </a>
<a name="ln4881">        case CLO_BUILDDB:</a>
<a name="ln4882">            if (next_is_param)</a>
<a name="ln4883">                return false;</a>
<a name="ln4884">            crawl_state.build_db = true;</a>
<a name="ln4885">#ifdef USE_TILE_LOCAL</a>
<a name="ln4886">            crawl_state.tiles_disabled = true;</a>
<a name="ln4887">#endif</a>
<a name="ln4888">            break;</a>
<a name="ln4889"> </a>
<a name="ln4890">        case CLO_GDB:</a>
<a name="ln4891">            crawl_state.no_gdb = 0;</a>
<a name="ln4892">            break;</a>
<a name="ln4893"> </a>
<a name="ln4894">        case CLO_NO_GDB:</a>
<a name="ln4895">        case CLO_NOGDB:</a>
<a name="ln4896">            crawl_state.no_gdb = &quot;GDB disabled via the command line.&quot;;</a>
<a name="ln4897">            break;</a>
<a name="ln4898"> </a>
<a name="ln4899">        case CLO_MACRO:</a>
<a name="ln4900">            if (!next_is_param)</a>
<a name="ln4901">                return false;</a>
<a name="ln4902">            SysEnv.macro_dir = next_arg;</a>
<a name="ln4903">            nextUsed = true;</a>
<a name="ln4904">            break;</a>
<a name="ln4905"> </a>
<a name="ln4906">        case CLO_MORGUE:</a>
<a name="ln4907">            if (!next_is_param)</a>
<a name="ln4908">                return false;</a>
<a name="ln4909">            if (!rc_only)</a>
<a name="ln4910">                SysEnv.morgue_dir = next_arg;</a>
<a name="ln4911">            nextUsed = true;</a>
<a name="ln4912">            break;</a>
<a name="ln4913"> </a>
<a name="ln4914">        case CLO_SCOREFILE:</a>
<a name="ln4915">            if (!next_is_param)</a>
<a name="ln4916">                return false;</a>
<a name="ln4917">            if (!rc_only)</a>
<a name="ln4918">                SysEnv.scorefile = next_arg;</a>
<a name="ln4919">            nextUsed = true;</a>
<a name="ln4920">            break;</a>
<a name="ln4921"> </a>
<a name="ln4922">        case CLO_NAME:</a>
<a name="ln4923">            if (!next_is_param)</a>
<a name="ln4924">                return false;</a>
<a name="ln4925">            if (!rc_only)</a>
<a name="ln4926">                Options.game.name = next_arg;</a>
<a name="ln4927">            nextUsed = true;</a>
<a name="ln4928">            break;</a>
<a name="ln4929"> </a>
<a name="ln4930">        case CLO_RACE:</a>
<a name="ln4931">        case CLO_CLASS:</a>
<a name="ln4932">            if (!next_is_param)</a>
<a name="ln4933">                return false;</a>
<a name="ln4934"> </a>
<a name="ln4935">            if (!rc_only)</a>
<a name="ln4936">            {</a>
<a name="ln4937">                if (o == 2)</a>
<a name="ln4938">                    Options.game.species = _str_to_species(string(next_arg));</a>
<a name="ln4939"> </a>
<a name="ln4940">                if (o == 3)</a>
<a name="ln4941">                    Options.game.job = str_to_job(string(next_arg));</a>
<a name="ln4942">            }</a>
<a name="ln4943">            nextUsed = true;</a>
<a name="ln4944">            break;</a>
<a name="ln4945"> </a>
<a name="ln4946">        case CLO_RCDIR:</a>
<a name="ln4947">            // Always parse.</a>
<a name="ln4948">            if (!next_is_param)</a>
<a name="ln4949">                return false;</a>
<a name="ln4950"> </a>
<a name="ln4951">            SysEnv.add_rcdir(next_arg);</a>
<a name="ln4952">            nextUsed = true;</a>
<a name="ln4953">            break;</a>
<a name="ln4954"> </a>
<a name="ln4955">        case CLO_DIR:</a>
<a name="ln4956">            // Always parse.</a>
<a name="ln4957">            if (!next_is_param)</a>
<a name="ln4958">                return false;</a>
<a name="ln4959"> </a>
<a name="ln4960">            SysEnv.crawl_dir = next_arg;</a>
<a name="ln4961">            nextUsed = true;</a>
<a name="ln4962">            break;</a>
<a name="ln4963"> </a>
<a name="ln4964">        case CLO_RC:</a>
<a name="ln4965">            // Always parse.</a>
<a name="ln4966">            if (!next_is_param)</a>
<a name="ln4967">                return false;</a>
<a name="ln4968"> </a>
<a name="ln4969">            SysEnv.crawl_rc = next_arg;</a>
<a name="ln4970">            nextUsed = true;</a>
<a name="ln4971">            break;</a>
<a name="ln4972"> </a>
<a name="ln4973">        case CLO_HELP:</a>
<a name="ln4974">            // Shouldn't happen.</a>
<a name="ln4975">            return false;</a>
<a name="ln4976"> </a>
<a name="ln4977">        case CLO_VERSION:</a>
<a name="ln4978">            _print_version();</a>
<a name="ln4979">            end(0);</a>
<a name="ln4980"> </a>
<a name="ln4981">        case CLO_SAVE_VERSION:</a>
<a name="ln4982">            // Always parse.</a>
<a name="ln4983">            if (!next_is_param)</a>
<a name="ln4984">                return false;</a>
<a name="ln4985"> </a>
<a name="ln4986">            _print_save_version(next_arg);</a>
<a name="ln4987">            end(0);</a>
<a name="ln4988"> </a>
<a name="ln4989">        case CLO_EDIT_SAVE:</a>
<a name="ln4990">            // Always parse.</a>
<a name="ln4991">            _edit_save(argc - current - 1, argv + current + 1);</a>
<a name="ln4992">            end(0);</a>
<a name="ln4993"> </a>
<a name="ln4994">        case CLO_EDIT_BONES:</a>
<a name="ln4995">            _edit_bones(argc - current - 1, argv + current + 1);</a>
<a name="ln4996">            end(0);</a>
<a name="ln4997"> </a>
<a name="ln4998">        case CLO_SEED:</a>
<a name="ln4999">            if (!next_is_param)</a>
<a name="ln5000">            {</a>
<a name="ln5001">                // show seed choice menu</a>
<a name="ln5002">                Options.game.type = GAME_TYPE_CUSTOM_SEED;</a>
<a name="ln5003">                break;</a>
<a name="ln5004">            }</a>
<a name="ln5005"> </a>
<a name="ln5006">            if (!sscanf(next_arg, &quot;%&quot; SCNu64, &amp;Options.seed_from_rc))</a>
<a name="ln5007">                return false;</a>
<a name="ln5008">            Options.seed = Options.seed_from_rc;</a>
<a name="ln5009">            nextUsed = true;</a>
<a name="ln5010">            break;</a>
<a name="ln5011"> </a>
<a name="ln5012">        case CLO_PREGEN:</a>
<a name="ln5013">            Options.pregen_dungeon = true;</a>
<a name="ln5014">            break;</a>
<a name="ln5015"> </a>
<a name="ln5016">        case CLO_SPRINT:</a>
<a name="ln5017">            if (!rc_only)</a>
<a name="ln5018">                Options.game.type = GAME_TYPE_SPRINT;</a>
<a name="ln5019">            break;</a>
<a name="ln5020"> </a>
<a name="ln5021">        case CLO_SPRINT_MAP:</a>
<a name="ln5022">            if (!next_is_param)</a>
<a name="ln5023">                return false;</a>
<a name="ln5024"> </a>
<a name="ln5025">            nextUsed               = true;</a>
<a name="ln5026">            crawl_state.sprint_map = next_arg;</a>
<a name="ln5027">            Options.game.map       = next_arg;</a>
<a name="ln5028">            break;</a>
<a name="ln5029"> </a>
<a name="ln5030">        case CLO_TUTORIAL:</a>
<a name="ln5031">            if (!rc_only)</a>
<a name="ln5032">                Options.game.type = GAME_TYPE_TUTORIAL;</a>
<a name="ln5033">            break;</a>
<a name="ln5034"> </a>
<a name="ln5035">        case CLO_WIZARD:</a>
<a name="ln5036">#ifdef WIZARD</a>
<a name="ln5037">            if (!rc_only)</a>
<a name="ln5038">                Options.wiz_mode = WIZ_NO;</a>
<a name="ln5039">#endif</a>
<a name="ln5040">            break;</a>
<a name="ln5041"> </a>
<a name="ln5042">        case CLO_EXPLORE:</a>
<a name="ln5043">#ifdef WIZARD</a>
<a name="ln5044">            if (!rc_only)</a>
<a name="ln5045">                Options.explore_mode = WIZ_NO;</a>
<a name="ln5046">#endif</a>
<a name="ln5047">            break;</a>
<a name="ln5048"> </a>
<a name="ln5049">        case CLO_NO_SAVE:</a>
<a name="ln5050">            if (!rc_only)</a>
<a name="ln5051">                Options.no_save = true;</a>
<a name="ln5052">            break;</a>
<a name="ln5053"> </a>
<a name="ln5054">#ifdef USE_TILE_WEB</a>
<a name="ln5055">        case CLO_WEBTILES_SOCKET:</a>
<a name="ln5056">            nextUsed          = true;</a>
<a name="ln5057">            tiles.m_sock_name = next_arg;</a>
<a name="ln5058">            break;</a>
<a name="ln5059"> </a>
<a name="ln5060">        case CLO_AWAIT_CONNECTION:</a>
<a name="ln5061">            tiles.m_await_connection = true;</a>
<a name="ln5062">            break;</a>
<a name="ln5063"> </a>
<a name="ln5064">        case CLO_PRINT_WEBTILES_OPTIONS:</a>
<a name="ln5065">            if (!rc_only)</a>
<a name="ln5066">            {</a>
<a name="ln5067">                _print_webtiles_options();</a>
<a name="ln5068">                end(0);</a>
<a name="ln5069">            }</a>
<a name="ln5070">            break;</a>
<a name="ln5071">#endif</a>
<a name="ln5072"> </a>
<a name="ln5073">        case CLO_PRINT_CHARSET:</a>
<a name="ln5074">            if (rc_only)</a>
<a name="ln5075">                break;</a>
<a name="ln5076">#ifdef DGAMELAUNCH</a>
<a name="ln5077">            // Tell DGL we don't use ancient charsets anymore. The glyph set</a>
<a name="ln5078">            // doesn't matter here, just the encoding.</a>
<a name="ln5079">            printf(&quot;UNICODE\n&quot;);</a>
<a name="ln5080">#else</a>
<a name="ln5081">            printf(&quot;This option is for DGL use only.\n&quot;);</a>
<a name="ln5082">#endif</a>
<a name="ln5083">            end(0);</a>
<a name="ln5084">            break;</a>
<a name="ln5085"> </a>
<a name="ln5086">        case CLO_THROTTLE:</a>
<a name="ln5087">            crawl_state.throttle = true;</a>
<a name="ln5088">            break;</a>
<a name="ln5089"> </a>
<a name="ln5090">        case CLO_NO_THROTTLE:</a>
<a name="ln5091">            crawl_state.throttle = false;</a>
<a name="ln5092">            break;</a>
<a name="ln5093"> </a>
<a name="ln5094">        case CLO_EXTRA_OPT_FIRST:</a>
<a name="ln5095">            if (!next_is_param)</a>
<a name="ln5096">                return false;</a>
<a name="ln5097"> </a>
<a name="ln5098">            // Don't print the help message if the opt was wrong</a>
<a name="ln5099">            if (!_check_extra_opt(next_arg))</a>
<a name="ln5100">                return true;</a>
<a name="ln5101"> </a>
<a name="ln5102">            SysEnv.extra_opts_first.emplace_back(next_arg);</a>
<a name="ln5103">            nextUsed = true;</a>
<a name="ln5104"> </a>
<a name="ln5105">            // Can be used multiple times.</a>
<a name="ln5106">            arg_seen[o] = false;</a>
<a name="ln5107">            break;</a>
<a name="ln5108"> </a>
<a name="ln5109">        case CLO_EXTRA_OPT_LAST:</a>
<a name="ln5110">            if (!next_is_param)</a>
<a name="ln5111">                return false;</a>
<a name="ln5112"> </a>
<a name="ln5113">            // Don't print the help message if the opt was wrong</a>
<a name="ln5114">            if (!_check_extra_opt(next_arg))</a>
<a name="ln5115">                return true;</a>
<a name="ln5116"> </a>
<a name="ln5117">            SysEnv.extra_opts_last.emplace_back(next_arg);</a>
<a name="ln5118">            nextUsed = true;</a>
<a name="ln5119"> </a>
<a name="ln5120">            // Can be used multiple times.</a>
<a name="ln5121">            arg_seen[o] = false;</a>
<a name="ln5122">            break;</a>
<a name="ln5123">        }</a>
<a name="ln5124"> </a>
<a name="ln5125">        // Update position.</a>
<a name="ln5126">        current++;</a>
<a name="ln5127">        if (nextUsed)</a>
<a name="ln5128">            current++;</a>
<a name="ln5129">    }</a>
<a name="ln5130"> </a>
<a name="ln5131">    return true;</a>
<a name="ln5132">}</a>
<a name="ln5133"> </a>
<a name="ln5134">///////////////////////////////////////////////////////////////////////</a>
<a name="ln5135">// system_environment</a>
<a name="ln5136"> </a>
<a name="ln5137">void system_environment::add_rcdir(const string &amp;dir)</a>
<a name="ln5138">{</a>
<a name="ln5139">    string cdir = canonicalise_file_separator(dir);</a>
<a name="ln5140">    if (dir_exists(cdir))</a>
<a name="ln5141">        rcdirs.push_back(cdir);</a>
<a name="ln5142">    else</a>
<a name="ln5143">        end(1, false, &quot;Cannot find -rcdir \&quot;%s\&quot;&quot;, cdir.c_str());</a>
<a name="ln5144">}</a>
<a name="ln5145"> </a>
<a name="ln5146">///////////////////////////////////////////////////////////////////////</a>
<a name="ln5147">// menu_sort_condition</a>
<a name="ln5148"> </a>
<a name="ln5149">menu_sort_condition::menu_sort_condition(menu_type _mt, int _sort)</a>
<a name="ln5150">    : mtype(_mt), sort(_sort), cmp()</a>
<a name="ln5151">{</a>
<a name="ln5152">}</a>
<a name="ln5153"> </a>
<a name="ln5154">menu_sort_condition::menu_sort_condition(const string &amp;s)</a>
<a name="ln5155">    : mtype(menu_type::any), sort(-1), cmp()</a>
<a name="ln5156">{</a>
<a name="ln5157">    string cp = s;</a>
<a name="ln5158">    set_menu_type(cp);</a>
<a name="ln5159">    set_sort(cp);</a>
<a name="ln5160">    set_comparators(cp);</a>
<a name="ln5161">}</a>
<a name="ln5162"> </a>
<a name="ln5163">bool menu_sort_condition::matches(menu_type mt) const</a>
<a name="ln5164">{</a>
<a name="ln5165">    return mtype == menu_type::any || mtype == mt;</a>
<a name="ln5166">}</a>
<a name="ln5167"> </a>
<a name="ln5168">void menu_sort_condition::set_menu_type(string &amp;s)</a>
<a name="ln5169">{</a>
<a name="ln5170">    static struct</a>
<a name="ln5171">    {</a>
<a name="ln5172">        const string mname;</a>
<a name="ln5173">        menu_type mtype;</a>
<a name="ln5174">    } menu_type_map[] =</a>
<a name="ln5175">      {</a>
<a name="ln5176">          { &quot;any:&quot;,    menu_type::any       },</a>
<a name="ln5177">          { &quot;inv:&quot;,    menu_type::invlist   },</a>
<a name="ln5178">          { &quot;drop:&quot;,   menu_type::drop      },</a>
<a name="ln5179">          { &quot;pickup:&quot;, menu_type::pickup    },</a>
<a name="ln5180">          { &quot;know:&quot;,   menu_type::know      }</a>
<a name="ln5181">      };</a>
<a name="ln5182"> </a>
<a name="ln5183">    for (const auto &amp;mi : menu_type_map)</a>
<a name="ln5184">    {</a>
<a name="ln5185">        const string &amp;name = mi.mname;</a>
<a name="ln5186">        if (starts_with(s, name))</a>
<a name="ln5187">        {</a>
<a name="ln5188">            s = s.substr(name.length());</a>
<a name="ln5189">            mtype = mi.mtype;</a>
<a name="ln5190">            break;</a>
<a name="ln5191">        }</a>
<a name="ln5192">    }</a>
<a name="ln5193">}</a>
<a name="ln5194"> </a>
<a name="ln5195">void menu_sort_condition::set_sort(string &amp;s)</a>
<a name="ln5196">{</a>
<a name="ln5197">    // Strip off the optional sort clauses and get the primary sort condition.</a>
<a name="ln5198">    string::size_type trail_pos = s.find(':');</a>
<a name="ln5199">    if (starts_with(s, &quot;auto:&quot;))</a>
<a name="ln5200">        trail_pos = s.find(':', trail_pos + 1);</a>
<a name="ln5201"> </a>
<a name="ln5202">    string sort_cond = trail_pos == string::npos? s : s.substr(0, trail_pos);</a>
<a name="ln5203"> </a>
<a name="ln5204">    trim_string(sort_cond);</a>
<a name="ln5205">    sort = _read_bool_or_number(sort_cond, sort, &quot;auto:&quot;);</a>
<a name="ln5206"> </a>
<a name="ln5207">    if (trail_pos != string::npos)</a>
<a name="ln5208">        s = s.substr(trail_pos + 1);</a>
<a name="ln5209">    else</a>
<a name="ln5210">        s.clear();</a>
<a name="ln5211">}</a>
<a name="ln5212"> </a>
<a name="ln5213">void menu_sort_condition::set_comparators(string &amp;s)</a>
<a name="ln5214">{</a>
<a name="ln5215">    init_item_sort_comparators(</a>
<a name="ln5216">        cmp,</a>
<a name="ln5217">        s.empty()? &quot;equipped, basename, qualname, curse, qty&quot; : s);</a>
<a name="ln5218">}</a>

</code></pre>
<div class="balloon" rel="587"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v1016/" target="_blank">V1016</a> Expression 'wpn_type >= 0' is always true.</p></div>
<div class="balloon" rel="3093"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v648/" target="_blank">V648</a> Priority of the '&&' operation is higher than that of the '||' operation.</p></div>
<div class="balloon" rel="3104"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v648/" target="_blank">V648</a> Priority of the '&&' operation is higher than that of the '||' operation.</p></div>
<div class="balloon" rel="1799"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v730/" target="_blank">V730</a> It is possible that not all members of a class are initialized inside the constructor. Consider inspecting: macro_meta_entry, evil_colour.</p></div>

<link rel="stylesheet" href="highlight.css">
<script src="highlight.pack.js"></script>
<script src="highlightjs-line-numbers.js"></script>
<script>hljs.initHighlightingOnLoad();</script>
<script>hljs.initLineNumbersOnLoad();</script>
<script>
  $(document).ready(function() {
      $('.balloon').each(function () {
          var bl = $(this);
          var line = bl.attr('rel');
          var text = $('a[name="ln'+line+'"]').text();

          var space_count = 0;
          for(var i = 0; i<text.length; i++){
              var char = text[i];
              if((char !== ' ')&&(char !== '\t'))break;
              if(char === '\t')space_count++;
              space_count++;
          }

          bl.css('margin-left', space_count*8);
          $('a[name="ln'+line+'"]').after(bl);
      });

      window.location = window.location;
  });
</script>
</body>
</html>
