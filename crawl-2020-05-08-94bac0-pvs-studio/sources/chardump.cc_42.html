
<html>
<head>

  <meta http-equiv="Content-Type" content="text/html; charset=US-ASCII" />
  <title>chardump.cc</title>

  <link rel="stylesheet" href="../style.css"/>
  <script src="../jquery-3.2.1.min.js"></script>
</head>
<body>

<pre><code class = "cpp">
<a name="ln1">/**</a>
<a name="ln2"> * @file</a>
<a name="ln3"> * @brief Dumps character info out to the morgue file.</a>
<a name="ln4">**/</a>
<a name="ln5"> </a>
<a name="ln6">#include &quot;AppHdr.h&quot;</a>
<a name="ln7"> </a>
<a name="ln8">#include &quot;chardump.h&quot;</a>
<a name="ln9"> </a>
<a name="ln10">#include &lt;string&gt;</a>
<a name="ln11">#include &lt;cctype&gt;</a>
<a name="ln12">#include &lt;cinttypes&gt;</a>
<a name="ln13">#include &lt;cstdio&gt;</a>
<a name="ln14">#include &lt;cstdlib&gt;</a>
<a name="ln15">#include &lt;cstring&gt;</a>
<a name="ln16">#include &lt;fcntl.h&gt;</a>
<a name="ln17">#if !defined(__IBMCPP__) &amp;&amp; !defined(TARGET_COMPILER_VC)</a>
<a name="ln18">#include &lt;unistd.h&gt;</a>
<a name="ln19">#endif</a>
<a name="ln20"> </a>
<a name="ln21">#include &quot;ability.h&quot;</a>
<a name="ln22">#include &quot;artefact.h&quot;</a>
<a name="ln23">#include &quot;art-enum.h&quot;</a>
<a name="ln24">#include &quot;branch.h&quot;</a>
<a name="ln25">#include &quot;describe.h&quot;</a>
<a name="ln26">#include &quot;dgn-overview.h&quot;</a>
<a name="ln27">#include &quot;dungeon.h&quot;</a>
<a name="ln28">#include &quot;fight.h&quot;</a>
<a name="ln29">#include &quot;files.h&quot;</a>
<a name="ln30">#include &quot;god-prayer.h&quot;</a>
<a name="ln31">#include &quot;hiscores.h&quot;</a>
<a name="ln32">#include &quot;initfile.h&quot;</a>
<a name="ln33">#include &quot;invent.h&quot;</a>
<a name="ln34">#include &quot;item-prop.h&quot;</a>
<a name="ln35">#include &quot;items.h&quot;</a>
<a name="ln36">#include &quot;kills.h&quot;</a>
<a name="ln37">#include &quot;libutil.h&quot;</a>
<a name="ln38">#include &quot;melee-attack.h&quot;</a>
<a name="ln39">#include &quot;message.h&quot;</a>
<a name="ln40">#include &quot;mutation.h&quot;</a>
<a name="ln41">#include &quot;notes.h&quot;</a>
<a name="ln42">#include &quot;output.h&quot;</a>
<a name="ln43">#include &quot;place.h&quot;</a>
<a name="ln44">#include &quot;prompt.h&quot;</a>
<a name="ln45">#include &quot;religion.h&quot;</a>
<a name="ln46">#include &quot;scroller.h&quot;</a>
<a name="ln47">#include &quot;showsymb.h&quot;</a>
<a name="ln48">#include &quot;skills.h&quot;</a>
<a name="ln49">#include &quot;spl-book.h&quot;</a>
<a name="ln50">#include &quot;spl-util.h&quot;</a>
<a name="ln51">#include &quot;state.h&quot;</a>
<a name="ln52">#include &quot;stringutil.h&quot;</a>
<a name="ln53">#include &quot;transform.h&quot;</a>
<a name="ln54">#include &quot;travel.h&quot;</a>
<a name="ln55">#include &quot;unicode.h&quot;</a>
<a name="ln56">#include &quot;version.h&quot;</a>
<a name="ln57">#include &quot;viewchar.h&quot;</a>
<a name="ln58">#include &quot;view.h&quot;</a>
<a name="ln59">#include &quot;xom.h&quot;</a>
<a name="ln60"> </a>
<a name="ln61">struct dump_params;</a>
<a name="ln62"> </a>
<a name="ln63">static void _sdump_header(dump_params &amp;);</a>
<a name="ln64">static void _sdump_stats(dump_params &amp;);</a>
<a name="ln65">static void _sdump_location(dump_params &amp;);</a>
<a name="ln66">static void _sdump_religion(dump_params &amp;);</a>
<a name="ln67">static void _sdump_hunger(dump_params &amp;);</a>
<a name="ln68">static void _sdump_transform(dump_params &amp;);</a>
<a name="ln69">static void _sdump_visits(dump_params &amp;);</a>
<a name="ln70">static void _sdump_gold(dump_params &amp;);</a>
<a name="ln71">static void _sdump_misc(dump_params &amp;);</a>
<a name="ln72">static void _sdump_turns_by_place(dump_params &amp;);</a>
<a name="ln73">static void _sdump_notes(dump_params &amp;);</a>
<a name="ln74">static void _sdump_inventory(dump_params &amp;);</a>
<a name="ln75">static void _sdump_skills(dump_params &amp;);</a>
<a name="ln76">static void _sdump_spells(dump_params &amp;);</a>
<a name="ln77">static void _sdump_mutations(dump_params &amp;);</a>
<a name="ln78">static void _sdump_messages(dump_params &amp;);</a>
<a name="ln79">static void _sdump_screenshot(dump_params &amp;);</a>
<a name="ln80">static void _sdump_kills_by_place(dump_params &amp;);</a>
<a name="ln81">static void _sdump_kills(dump_params &amp;);</a>
<a name="ln82">static void _sdump_xp_by_level(dump_params &amp;);</a>
<a name="ln83">static void _sdump_newline(dump_params &amp;);</a>
<a name="ln84">static void _sdump_overview(dump_params &amp;);</a>
<a name="ln85">static void _sdump_hiscore(dump_params &amp;);</a>
<a name="ln86">static void _sdump_monster_list(dump_params &amp;);</a>
<a name="ln87">static void _sdump_vault_list(dump_params &amp;);</a>
<a name="ln88">static void _sdump_skill_gains(dump_params &amp;);</a>
<a name="ln89">static void _sdump_action_counts(dump_params &amp;);</a>
<a name="ln90">static void _sdump_separator(dump_params &amp;);</a>
<a name="ln91">#ifdef CLUA_BINDINGS</a>
<a name="ln92">static void _sdump_lua(dump_params &amp;);</a>
<a name="ln93">#endif</a>
<a name="ln94">static bool _write_dump(const string &amp;fname, const dump_params &amp;,</a>
<a name="ln95">                        bool print_dump_path = false);</a>
<a name="ln96"> </a>
<a name="ln97">struct dump_section_handler</a>
<a name="ln98">{</a>
<a name="ln99">    const char *name;</a>
<a name="ln100">    void (*handler)(dump_params &amp;);</a>
<a name="ln101">};</a>
<a name="ln102"> </a>
<a name="ln103">struct dump_params</a>
<a name="ln104">{</a>
<a name="ln105">    string text;</a>
<a name="ln106">    string section;</a>
<a name="ln107">    bool full_id;</a>
<a name="ln108">    const scorefile_entry *se;</a>
<a name="ln109"> </a>
<a name="ln110">    dump_params(const string &amp;sec = &quot;&quot;, bool id = false,</a>
<a name="ln111">                const scorefile_entry *s = nullptr)</a>
<a name="ln112">        : section(sec), full_id(id), se(s)</a>
<a name="ln113">    {</a>
<a name="ln114">        // Start with enough room for 100 80 character lines.</a>
<a name="ln115">        text.reserve(100 * 80);</a>
<a name="ln116">    }</a>
<a name="ln117">};</a>
<a name="ln118"> </a>
<a name="ln119">static dump_section_handler dump_handlers[] =</a>
<a name="ln120">{</a>
<a name="ln121">    { &quot;header&quot;,         _sdump_header        },</a>
<a name="ln122">    { &quot;stats&quot;,          _sdump_stats         },</a>
<a name="ln123">    { &quot;location&quot;,       _sdump_location      },</a>
<a name="ln124">    { &quot;religion&quot;,       _sdump_religion      },</a>
<a name="ln125">    { &quot;hunger&quot;,         _sdump_hunger        },</a>
<a name="ln126">    { &quot;transform&quot;,      _sdump_transform     },</a>
<a name="ln127">    { &quot;visits&quot;,         _sdump_visits        },</a>
<a name="ln128">    { &quot;gold&quot;,           _sdump_gold          },</a>
<a name="ln129">    { &quot;misc&quot;,           _sdump_misc          },</a>
<a name="ln130">    { &quot;turns_by_place&quot;, _sdump_turns_by_place},</a>
<a name="ln131">    { &quot;notes&quot;,          _sdump_notes         },</a>
<a name="ln132">    { &quot;inventory&quot;,      _sdump_inventory     },</a>
<a name="ln133">    { &quot;skills&quot;,         _sdump_skills        },</a>
<a name="ln134">    { &quot;spells&quot;,         _sdump_spells        },</a>
<a name="ln135">    { &quot;mutations&quot;,      _sdump_mutations     },</a>
<a name="ln136">    { &quot;messages&quot;,       _sdump_messages      },</a>
<a name="ln137">    { &quot;screenshot&quot;,     _sdump_screenshot    },</a>
<a name="ln138">    { &quot;kills_by_place&quot;, _sdump_kills_by_place},</a>
<a name="ln139">    { &quot;kills&quot;,          _sdump_kills         },</a>
<a name="ln140">    { &quot;xp_by_level&quot;,    _sdump_xp_by_level   },</a>
<a name="ln141">    { &quot;overview&quot;,       _sdump_overview      },</a>
<a name="ln142">    { &quot;hiscore&quot;,        _sdump_hiscore       },</a>
<a name="ln143">    { &quot;monlist&quot;,        _sdump_monster_list  },</a>
<a name="ln144">    { &quot;vaults&quot;,         _sdump_vault_list    },</a>
<a name="ln145">    { &quot;spell_usage&quot;,    _sdump_action_counts }, // compat</a>
<a name="ln146">    { &quot;action_counts&quot;,  _sdump_action_counts },</a>
<a name="ln147">    { &quot;skill_gains&quot;,    _sdump_skill_gains   },</a>
<a name="ln148"> </a>
<a name="ln149">    // Conveniences for the .crawlrc artist.</a>
<a name="ln150">    { &quot;&quot;,               _sdump_newline       },</a>
<a name="ln151">    { &quot;-&quot;,              _sdump_separator     },</a>
<a name="ln152"> </a>
<a name="ln153">#ifdef CLUA_BINDINGS</a>
<a name="ln154">    { nullptr,          _sdump_lua           }</a>
<a name="ln155">#else</a>
<a name="ln156">    { nullptr,          nullptr              }</a>
<a name="ln157">#endif</a>
<a name="ln158">};</a>
<a name="ln159"> </a>
<a name="ln160">static void dump_section(dump_params &amp;par)</a>
<a name="ln161">{</a>
<a name="ln162">    for (int i = 0; ; ++i)</a>
<a name="ln163">    {</a>
<a name="ln164">        if (!dump_handlers[i].name || par.section == dump_handlers[i].name)</a>
<a name="ln165">        {</a>
<a name="ln166">            if (dump_handlers[i].handler)</a>
<a name="ln167">                (*dump_handlers[i].handler)(par);</a>
<a name="ln168">            break;</a>
<a name="ln169">        }</a>
<a name="ln170">    }</a>
<a name="ln171">}</a>
<a name="ln172"> </a>
<a name="ln173">static dump_params _get_dump(bool full_id = false,</a>
<a name="ln174">                             const scorefile_entry *se = nullptr)</a>
<a name="ln175">{</a>
<a name="ln176">    dump_params par(&quot;&quot;, full_id, se);</a>
<a name="ln177"> </a>
<a name="ln178">    for (const string &amp;section : Options.dump_order)</a>
<a name="ln179">    {</a>
<a name="ln180">        par.section = section;</a>
<a name="ln181">        dump_section(par);</a>
<a name="ln182">    }</a>
<a name="ln183"> </a>
<a name="ln184">    // Hopefully we get RVO so we don't have to copy the text.</a>
<a name="ln185">    return par;</a>
<a name="ln186">}</a>
<a name="ln187"> </a>
<a name="ln188">bool dump_char(const string &amp;fname, bool quiet, bool full_id,</a>
<a name="ln189">               const scorefile_entry *se)</a>
<a name="ln190">{</a>
<a name="ln191">    return _write_dump(fname, _get_dump(full_id, se), quiet);</a>
<a name="ln192">}</a>
<a name="ln193"> </a>
<a name="ln194">static void _sdump_header(dump_params &amp;par)</a>
<a name="ln195">{</a>
<a name="ln196">    string type = crawl_state.game_type_name();</a>
<a name="ln197">    if (type.empty())</a>
<a name="ln198">        type = CRAWL;</a>
<a name="ln199">    else</a>
<a name="ln200">        type += &quot; DCSS&quot;;</a>
<a name="ln201"> </a>
<a name="ln202">    par.text += &quot; &quot; + type + &quot; version &quot; + Version::Long;</a>
<a name="ln203">#ifdef USE_TILE_LOCAL</a>
<a name="ln204">    par.text += &quot; (tiles)&quot;;</a>
<a name="ln205">#elif defined(USE_TILE_WEB)</a>
<a name="ln206">    if (::tiles.is_controlled_from_web())</a>
<a name="ln207">        par.text += &quot; (webtiles)&quot;;</a>
<a name="ln208">    else</a>
<a name="ln209">        par.text += &quot; (console)&quot;;</a>
<a name="ln210">#else</a>
<a name="ln211">    par.text += &quot; (console)&quot;;</a>
<a name="ln212">#endif</a>
<a name="ln213">    par.text += &quot; character file.\n\n&quot;;</a>
<a name="ln214"> </a>
<a name="ln215">    if (you.fully_seeded</a>
<a name="ln216">#ifdef DGAMELAUNCH</a>
<a name="ln217">        &amp;&amp; (par.se // for online games, show seed for a dead char</a>
<a name="ln218">            || you.wizard</a>
<a name="ln219">            || crawl_state.type == GAME_TYPE_CUSTOM_SEED)</a>
<a name="ln220">#endif</a>
<a name="ln221">        )</a>
<a name="ln222">    {</a>
<a name="ln223">        par.text += make_stringf(</a>
<a name="ln224">            &quot;Game seed: %&quot; PRIu64 &quot;, levelgen mode: %s\n\n&quot;,</a>
<a name="ln225">            crawl_state.seed, you.deterministic_levelgen</a>
<a name="ln226">                                                ? &quot;deterministic&quot; : &quot;classic&quot;);</a>
<a name="ln227">    }</a>
<a name="ln228">}</a>
<a name="ln229"> </a>
<a name="ln230">static void _sdump_stats(dump_params &amp;par)</a>
<a name="ln231">{</a>
<a name="ln232">    par.text += dump_overview_screen(par.full_id);</a>
<a name="ln233">    par.text += &quot;\n\n&quot;;</a>
<a name="ln234">}</a>
<a name="ln235"> </a>
<a name="ln236">static void _sdump_hunger(dump_params &amp;par)</a>
<a name="ln237">{</a>
<a name="ln238">    if (par.se)</a>
<a name="ln239">        par.text += &quot;You were &quot;;</a>
<a name="ln240">    else</a>
<a name="ln241">        par.text += &quot;You are &quot;;</a>
<a name="ln242"> </a>
<a name="ln243">    par.text += hunger_level();</a>
<a name="ln244">    par.text += &quot;.\n\n&quot;;</a>
<a name="ln245">}</a>
<a name="ln246"> </a>
<a name="ln247">static void _sdump_transform(dump_params &amp;par)</a>
<a name="ln248">{</a>
<a name="ln249">    string &amp;text(par.text);</a>
<a name="ln250">    if (you.form != transformation::none)</a>
<a name="ln251">        text += get_form()-&gt;get_description(par.se) + &quot;\n\n&quot;;}</a>
<a name="ln252"> </a>
<a name="ln253">static branch_type single_portals[] =</a>
<a name="ln254">{</a>
<a name="ln255">    BRANCH_TROVE,</a>
<a name="ln256">    BRANCH_SEWER,</a>
<a name="ln257">    BRANCH_OSSUARY,</a>
<a name="ln258">    BRANCH_BAILEY,</a>
<a name="ln259">    BRANCH_GAUNTLET,</a>
<a name="ln260">    BRANCH_ICE_CAVE,</a>
<a name="ln261">    BRANCH_VOLCANO,</a>
<a name="ln262">    BRANCH_WIZLAB,</a>
<a name="ln263">    BRANCH_DESOLATION,</a>
<a name="ln264">#if TAG_MAJOR_VERSION == 34</a>
<a name="ln265">    BRANCH_LABYRINTH,</a>
<a name="ln266">#endif</a>
<a name="ln267">};</a>
<a name="ln268"> </a>
<a name="ln269">static void _sdump_visits(dump_params &amp;par)</a>
<a name="ln270">{</a>
<a name="ln271">    string &amp;text(par.text);</a>
<a name="ln272"> </a>
<a name="ln273">    string have = &quot;have &quot;;</a>
<a name="ln274">    string seen = &quot;seen&quot;;</a>
<a name="ln275">    if (par.se) // you died -&gt; past tense</a>
<a name="ln276">    {</a>
<a name="ln277">        have = &quot;&quot;;</a>
<a name="ln278">        seen = &quot;saw&quot;;</a>
<a name="ln279">    }</a>
<a name="ln280"> </a>
<a name="ln281">    const vector&lt;PlaceInfo&gt; branches_visited = you.get_all_place_info(true, true);</a>
<a name="ln282"> </a>
<a name="ln283">    PlaceInfo branches_total;</a>
<a name="ln284">    for (const PlaceInfo &amp;branch : branches_visited)</a>
<a name="ln285">        branches_total += branch;</a>
<a name="ln286"> </a>
<a name="ln287">    text += make_stringf(&quot;You %svisited %d branch&quot;,</a>
<a name="ln288">                         have.c_str(), (int)branches_visited.size());</a>
<a name="ln289">    if (branches_visited.size() != 1)</a>
<a name="ln290">        text += &quot;es&quot;;</a>
<a name="ln291">    if (brdepth[root_branch] &gt; 1 || branches_visited.size() != 1)</a>
<a name="ln292">    {</a>
<a name="ln293">        text += make_stringf(&quot; of the dungeon, and %s %d of its levels.\n&quot;,</a>
<a name="ln294">                             seen.c_str(), branches_total.levels_seen);</a>
<a name="ln295">    }</a>
<a name="ln296"> </a>
<a name="ln297">    {</a>
<a name="ln298">        const PlaceInfo place_info = you.get_place_info(BRANCH_PANDEMONIUM);</a>
<a name="ln299">        if (place_info.num_visits &gt; 0)</a>
<a name="ln300">        {</a>
<a name="ln301">            text += make_stringf(&quot;You %svisited Pandemonium %d time&quot;,</a>
<a name="ln302">                                 have.c_str(), place_info.num_visits);</a>
<a name="ln303">            if (place_info.num_visits &gt; 1)</a>
<a name="ln304">                text += &quot;s&quot;;</a>
<a name="ln305">            text += make_stringf(&quot;, and %s %d of its levels.\n&quot;,</a>
<a name="ln306">                                 seen.c_str(), place_info.levels_seen);</a>
<a name="ln307">        }</a>
<a name="ln308">    }</a>
<a name="ln309"> </a>
<a name="ln310">    {</a>
<a name="ln311">        const PlaceInfo place_info = you.get_place_info(BRANCH_ABYSS);</a>
<a name="ln312">        if (place_info.num_visits &gt; 0)</a>
<a name="ln313">        {</a>
<a name="ln314">            text += make_stringf(&quot;You %svisited the Abyss %d time&quot;,</a>
<a name="ln315">                                 have.c_str(), place_info.num_visits);</a>
<a name="ln316">            if (place_info.num_visits &gt; 1)</a>
<a name="ln317">                text += &quot;s&quot;;</a>
<a name="ln318">            text += &quot;.\n&quot;;</a>
<a name="ln319">        }</a>
<a name="ln320">    }</a>
<a name="ln321"> </a>
<a name="ln322">    {</a>
<a name="ln323">        const PlaceInfo place_info = you.get_place_info(BRANCH_BAZAAR);</a>
<a name="ln324">        if (place_info.num_visits &gt; 0)</a>
<a name="ln325">        {</a>
<a name="ln326">            text += make_stringf(&quot;You %svisited %d bazaar&quot;,</a>
<a name="ln327">                                 have.c_str(), place_info.num_visits);</a>
<a name="ln328">            if (place_info.num_visits &gt; 1)</a>
<a name="ln329">                text += &quot;s&quot;;</a>
<a name="ln330">            text += &quot;.\n&quot;;</a>
<a name="ln331">        }</a>
<a name="ln332">    }</a>
<a name="ln333"> </a>
<a name="ln334">    {</a>
<a name="ln335">        const PlaceInfo place_info = you.get_place_info(BRANCH_ZIGGURAT);</a>
<a name="ln336">        if (place_info.num_visits &gt; 0)</a>
<a name="ln337">        {</a>
<a name="ln338">            int num_zigs = place_info.num_visits;</a>
<a name="ln339">            text += make_stringf(&quot;You %s%s %d ziggurat&quot;,</a>
<a name="ln340">                                 have.c_str(),</a>
<a name="ln341">                                 (num_zigs == you.zigs_completed) ? &quot;completed&quot;</a>
<a name="ln342">                                                                  : &quot;visited&quot;,</a>
<a name="ln343">                                 num_zigs);</a>
<a name="ln344">            if (num_zigs &gt; 1)</a>
<a name="ln345">                text += &quot;s&quot;;</a>
<a name="ln346">            if (num_zigs != you.zigs_completed &amp;&amp; you.zigs_completed)</a>
<a name="ln347">                text += make_stringf(&quot; (completing %d)&quot;, you.zigs_completed);</a>
<a name="ln348">            text += make_stringf(&quot;, and %s %d of %s levels&quot;,</a>
<a name="ln349">                                 seen.c_str(), place_info.levels_seen,</a>
<a name="ln350">                                 num_zigs &gt; 1 ? &quot;their&quot; : &quot;its&quot;);</a>
<a name="ln351">            if (num_zigs != 1 &amp;&amp; !you.zigs_completed)</a>
<a name="ln352">                text += make_stringf(&quot; (deepest: %d)&quot;, you.zig_max);</a>
<a name="ln353">            text += &quot;.\n&quot;;</a>
<a name="ln354">        }</a>
<a name="ln355">    }</a>
<a name="ln356"> </a>
<a name="ln357">    vector&lt;string&gt; misc_portals;</a>
<a name="ln358">    for (branch_type br : single_portals)</a>
<a name="ln359">    {</a>
<a name="ln360">        const PlaceInfo place_info = you.get_place_info(br);</a>
<a name="ln361">        if (!place_info.num_visits)</a>
<a name="ln362">            continue;</a>
<a name="ln363">        string name = branches[br].shortname;</a>
<a name="ln364">        if (place_info.num_visits &gt; 1)</a>
<a name="ln365">            name += make_stringf(&quot; (%d times)&quot;, place_info.num_visits);</a>
<a name="ln366">        misc_portals.push_back(name);</a>
<a name="ln367">    }</a>
<a name="ln368">    if (!misc_portals.empty())</a>
<a name="ln369">    {</a>
<a name="ln370">        text += &quot;You &quot; + have + &quot;also visited: &quot;</a>
<a name="ln371">                + comma_separated_line(misc_portals.begin(),</a>
<a name="ln372">                                       misc_portals.end())</a>
<a name="ln373">                + &quot;.\n&quot;;</a>
<a name="ln374">    }</a>
<a name="ln375"> </a>
<a name="ln376">    text += &quot;\n&quot;;</a>
<a name="ln377">}</a>
<a name="ln378"> </a>
<a name="ln379">static void _sdump_gold(dump_params &amp;par)</a>
<a name="ln380">{</a>
<a name="ln381">    string &amp;text(par.text);</a>
<a name="ln382"> </a>
<a name="ln383">    int lines = 0;</a>
<a name="ln384"> </a>
<a name="ln385">    const char* have = &quot;have &quot;;</a>
<a name="ln386">    if (par.se) // you died -&gt; past tense</a>
<a name="ln387">        have = &quot;&quot;;</a>
<a name="ln388"> </a>
<a name="ln389">    if (you.attribute[ATTR_GOLD_FOUND] &gt; 0)</a>
<a name="ln390">    {</a>
<a name="ln391">        lines++;</a>
<a name="ln392">        text += make_stringf(&quot;You %scollected %d gold pieces.\n&quot;, have,</a>
<a name="ln393">                             you.attribute[ATTR_GOLD_FOUND]);</a>
<a name="ln394">    }</a>
<a name="ln395"> </a>
<a name="ln396">    if (you.attribute[ATTR_PURCHASES] &gt; 0)</a>
<a name="ln397">    {</a>
<a name="ln398">        lines++;</a>
<a name="ln399">        text += make_stringf(&quot;You %sspent %d gold pieces at shops.\n&quot;, have,</a>
<a name="ln400">                             you.attribute[ATTR_PURCHASES]);</a>
<a name="ln401">    }</a>
<a name="ln402"> </a>
<a name="ln403">    if (you.attribute[ATTR_DONATIONS] &gt; 0)</a>
<a name="ln404">    {</a>
<a name="ln405">        lines++;</a>
<a name="ln406">        text += make_stringf(&quot;You %sdonated %d gold pieces to Zin.\n&quot;, have,</a>
<a name="ln407">                             you.attribute[ATTR_DONATIONS]);</a>
<a name="ln408">    }</a>
<a name="ln409"> </a>
<a name="ln410">    if (you.attribute[ATTR_GOZAG_GOLD_USED] &gt; 0)</a>
<a name="ln411">    {</a>
<a name="ln412">        lines++;</a>
<a name="ln413">        text += make_stringf(&quot;You %spaid %d gold pieces to Gozag.\n&quot;, have,</a>
<a name="ln414">                             you.attribute[ATTR_GOZAG_GOLD_USED]);</a>
<a name="ln415">    }</a>
<a name="ln416"> </a>
<a name="ln417">    if (you.attribute[ATTR_MISC_SPENDING] &gt; 0)</a>
<a name="ln418">    {</a>
<a name="ln419">        lines++;</a>
<a name="ln420">        text += make_stringf(&quot;You %sused %d gold pieces for miscellaneous &quot;</a>
<a name="ln421">                             &quot;purposes.\n&quot;, have,</a>
<a name="ln422">                             you.attribute[ATTR_MISC_SPENDING]);</a>
<a name="ln423">    }</a>
<a name="ln424"> </a>
<a name="ln425">    if (lines &gt; 0)</a>
<a name="ln426">        text += &quot;\n&quot;;</a>
<a name="ln427">}</a>
<a name="ln428"> </a>
<a name="ln429">static void _sdump_misc(dump_params &amp;par)</a>
<a name="ln430">{</a>
<a name="ln431">    _sdump_location(par);</a>
<a name="ln432">    _sdump_religion(par);</a>
<a name="ln433">    _sdump_hunger(par);</a>
<a name="ln434">    _sdump_transform(par);</a>
<a name="ln435">    _sdump_visits(par);</a>
<a name="ln436">    _sdump_gold(par);</a>
<a name="ln437">}</a>
<a name="ln438"> </a>
<a name="ln439">#define TO_PERCENT(x, y) (100.0f * (static_cast&lt;float&gt;(x)) / (static_cast&lt;float&gt;(y)))</a>
<a name="ln440"> </a>
<a name="ln441">static string _denanify(const string &amp;s)</a>
<a name="ln442">{</a>
<a name="ln443">    string out = replace_all(s, &quot; nan &quot;, &quot; N/A &quot;);</a>
<a name="ln444">    out = replace_all(out, &quot; -nan &quot;, &quot; N/A  &quot;);</a>
<a name="ln445">    out = replace_all(out, &quot; 1#IND &quot;, &quot;  N/A  &quot;);</a>
<a name="ln446">    out = replace_all(out, &quot; -1#IND &quot;, &quot;  N/A   &quot;);</a>
<a name="ln447">    return out;</a>
<a name="ln448">}</a>
<a name="ln449"> </a>
<a name="ln450">static string _sdump_turns_place_info(const PlaceInfo place_info, string name = &quot;&quot;)</a>
<a name="ln451">{</a>
<a name="ln452">    const PlaceInfo   gi = you.global_info;</a>
<a name="ln453">    string out;</a>
<a name="ln454"> </a>
<a name="ln455">    if (name.empty())</a>
<a name="ln456">        name = place_info.short_name();</a>
<a name="ln457"> </a>
<a name="ln458">    float a, b, c, d, e, f;</a>
<a name="ln459">    unsigned int non_interlevel =</a>
<a name="ln460">        place_info.turns_total - place_info.turns_interlevel;</a>
<a name="ln461">    unsigned int global_non_interlevel =</a>
<a name="ln462">        gi.turns_total - gi.turns_interlevel;</a>
<a name="ln463"> </a>
<a name="ln464">    a = TO_PERCENT(place_info.turns_total, gi.turns_total);</a>
<a name="ln465">    b = TO_PERCENT(non_interlevel, global_non_interlevel);</a>
<a name="ln466">    c = TO_PERCENT(place_info.turns_interlevel, place_info.turns_total);</a>
<a name="ln467">    d = TO_PERCENT(place_info.turns_resting, non_interlevel);</a>
<a name="ln468">    e = TO_PERCENT(place_info.turns_explore, non_interlevel);</a>
<a name="ln469">    f = static_cast&lt;float&gt;(non_interlevel) /</a>
<a name="ln470">        static_cast&lt;float&gt;(place_info.levels_seen);</a>
<a name="ln471"> </a>
<a name="ln472">    out =</a>
<a name="ln473">        make_stringf(&quot;%14s | %5.1f | %5.1f | %5.1f | %5.1f | %5.1f | %13.1f\n&quot;,</a>
<a name="ln474">                     name.c_str(), a, b, c , d, e, f);</a>
<a name="ln475"> </a>
<a name="ln476">    return _denanify(out);</a>
<a name="ln477">}</a>
<a name="ln478"> </a>
<a name="ln479">static string _sdump_level_xp_info(LevelXPInfo xp_info, string name = &quot;&quot;)</a>
<a name="ln480">{</a>
<a name="ln481">    string out;</a>
<a name="ln482"> </a>
<a name="ln483">    if (name.empty())</a>
<a name="ln484">        name = xp_info.level.describe();</a>
<a name="ln485"> </a>
<a name="ln486">    float c, f;</a>
<a name="ln487">    unsigned int total_xp = xp_info.vault_xp + xp_info.non_vault_xp;</a>
<a name="ln488">    unsigned int total_count = xp_info.vault_count + xp_info.non_vault_count;</a>
<a name="ln489"> </a>
<a name="ln490">    c = TO_PERCENT(xp_info.vault_xp, total_xp);</a>
<a name="ln491">    f = TO_PERCENT(xp_info.vault_count, total_count);</a>
<a name="ln492"> </a>
<a name="ln493">    out =</a>
<a name="ln494">        make_stringf(&quot;%11s | %7d | %7d | %5.1f | %7d | %7d | %5.1f\n&quot;,</a>
<a name="ln495">                     name.c_str(), xp_info.non_vault_xp, xp_info.vault_xp,</a>
<a name="ln496">                     c, xp_info.non_vault_count, xp_info.vault_count, f);</a>
<a name="ln497"> </a>
<a name="ln498">    return _denanify(out);</a>
<a name="ln499">}</a>
<a name="ln500"> </a>
<a name="ln501">static void _sdump_turns_by_place(dump_params &amp;par)</a>
<a name="ln502">{</a>
<a name="ln503">    string &amp;text(par.text);</a>
<a name="ln504"> </a>
<a name="ln505">    const vector&lt;PlaceInfo&gt; all_visited = you.get_all_place_info(true);</a>
<a name="ln506"> </a>
<a name="ln507">    text +=</a>
<a name="ln508">&quot;Table legend:\n&quot;</a>
<a name="ln509">&quot; A = Turns spent in this place as a percentage of turns spent in the\n&quot;</a>
<a name="ln510">&quot;     entire game.\n&quot;</a>
<a name="ln511">&quot; B = Non-inter-level travel turns spent in this place as a percentage of\n&quot;</a>
<a name="ln512">&quot;     non-inter-level travel turns spent in the entire game.\n&quot;</a>
<a name="ln513">&quot; C = Inter-level travel turns spent in this place as a percentage of\n&quot;</a>
<a name="ln514">&quot;     turns spent in this place.\n&quot;</a>
<a name="ln515">&quot; D = Turns resting spent in this place as a percentage of non-inter-level\n&quot;</a>
<a name="ln516">&quot;     travel turns spent in this place.\n&quot;</a>
<a name="ln517">&quot; E = Turns spent auto-exploring this place as a percentage of\n&quot;</a>
<a name="ln518">&quot;     non-inter-level travel turns spent in this place.\n&quot;</a>
<a name="ln519">&quot; F = Non-inter-level travel turns spent in this place divided by the\n&quot;</a>
<a name="ln520">&quot;     number of levels of this place that you've seen.\n\n&quot;;</a>
<a name="ln521"> </a>
<a name="ln522">    text += &quot;               &quot;;</a>
<a name="ln523">    text += &quot;    A       B       C       D       E               F\n&quot;;</a>
<a name="ln524">    text += &quot;               &quot;;</a>
<a name="ln525">    text += &quot;+-------+-------+-------+-------+-------+----------------------\n&quot;;</a>
<a name="ln526"> </a>
<a name="ln527">    text += _sdump_turns_place_info(you.global_info, &quot;Total&quot;);</a>
<a name="ln528"> </a>
<a name="ln529">    for (const PlaceInfo &amp;pi : all_visited)</a>
<a name="ln530">        text += _sdump_turns_place_info(pi);</a>
<a name="ln531"> </a>
<a name="ln532">    text += &quot;               &quot;;</a>
<a name="ln533">    text += &quot;+-------+-------+-------+-------+-------+----------------------\n&quot;;</a>
<a name="ln534"> </a>
<a name="ln535">    text += &quot;\n&quot;;</a>
<a name="ln536">}</a>
<a name="ln537"> </a>
<a name="ln538">static void _sdump_xp_by_level(dump_params &amp;par)</a>
<a name="ln539">{</a>
<a name="ln540">    string &amp;text(par.text);</a>
<a name="ln541"> </a>
<a name="ln542">    vector&lt;LevelXPInfo&gt; all_info = you.get_all_xp_info(true);</a>
<a name="ln543"> </a>
<a name="ln544">    text +=</a>
<a name="ln545">&quot;Table legend:\n&quot;</a>
<a name="ln546">&quot; A = Non-vault XP\n&quot;</a>
<a name="ln547">&quot; B = Vault XP\n&quot;</a>
<a name="ln548">&quot; C = Vault XP percentage of total XP\n&quot;</a>
<a name="ln549">&quot; D = Non-vault monster count\n&quot;</a>
<a name="ln550">&quot; E = Vault monster count\n&quot;</a>
<a name="ln551">&quot; F = Vault count percentage of total count\n\n&quot;;</a>
<a name="ln552"> </a>
<a name="ln553">    text += &quot;            &quot;;</a>
<a name="ln554">    text += &quot;     A         B        C        D         E        F   \n&quot;;</a>
<a name="ln555">    text += &quot;            &quot;;</a>
<a name="ln556">    text += &quot;+---------+---------+-------+---------+---------+-------\n&quot;;</a>
<a name="ln557"> </a>
<a name="ln558">    text += _sdump_level_xp_info(you.global_xp_info, &quot;Total&quot;);</a>
<a name="ln559"> </a>
<a name="ln560">    text += &quot;            &quot;;</a>
<a name="ln561">    text += &quot;+---------+---------+-------+---------+---------+-------\n&quot;;</a>
<a name="ln562"> </a>
<a name="ln563">    for (const LevelXPInfo &amp;mi : all_info)</a>
<a name="ln564">        text += _sdump_level_xp_info(mi);</a>
<a name="ln565"> </a>
<a name="ln566">    text += &quot;            &quot;;</a>
<a name="ln567">    text += &quot;+---------+---------+-------+---------+---------+-------\n&quot;;</a>
<a name="ln568"> </a>
<a name="ln569">    text += &quot;\n&quot;;</a>
<a name="ln570">}</a>
<a name="ln571"> </a>
<a name="ln572">static void _sdump_newline(dump_params &amp;par)</a>
<a name="ln573">{</a>
<a name="ln574">    par.text += &quot;\n&quot;;</a>
<a name="ln575">}</a>
<a name="ln576"> </a>
<a name="ln577">static void _sdump_separator(dump_params &amp;par)</a>
<a name="ln578">{</a>
<a name="ln579">    par.text += string(79, '-') + &quot;\n&quot;;</a>
<a name="ln580">}</a>
<a name="ln581"> </a>
<a name="ln582">#ifdef CLUA_BINDINGS</a>
<a name="ln583">// Assume this is an arbitrary Lua function name, call the function and</a>
<a name="ln584">// dump whatever it returns.</a>
<a name="ln585">static void _sdump_lua(dump_params &amp;par)</a>
<a name="ln586">{</a>
<a name="ln587">    string luatext;</a>
<a name="ln588">    if (!clua.callfn(par.section.c_str(), &quot;&gt;s&quot;, &amp;luatext)</a>
<a name="ln589">        &amp;&amp; !clua.error.empty())</a>
<a name="ln590">    {</a>
<a name="ln591">        par.text += &quot;Lua dump error: &quot; + clua.error + &quot;\n&quot;;</a>
<a name="ln592">    }</a>
<a name="ln593">    else</a>
<a name="ln594">        par.text += luatext;</a>
<a name="ln595">}</a>
<a name="ln596">#endif</a>
<a name="ln597"> </a>
<a name="ln598">string chardump_desc(const item_def&amp; item)</a>
<a name="ln599">{</a>
<a name="ln600">    string desc = get_item_description(item, false, true);</a>
<a name="ln601">    string outs;</a>
<a name="ln602"> </a>
<a name="ln603">    outs.reserve(desc.length() + 32);</a>
<a name="ln604"> </a>
<a name="ln605">    const int indent = 3;</a>
<a name="ln606"> </a>
<a name="ln607">    if (desc.empty()) // always at least an empty line</a>
<a name="ln608">        return &quot;\n&quot;;</a>
<a name="ln609"> </a>
<a name="ln610">    while (!desc.empty())</a>
<a name="ln611">    {</a>
<a name="ln612">        outs += string(indent, ' ')</a>
<a name="ln613">                  + wordwrap_line(desc, 79 - indent)</a>
<a name="ln614">                  + &quot;\n&quot;;</a>
<a name="ln615">    }</a>
<a name="ln616"> </a>
<a name="ln617">    return outs;</a>
<a name="ln618">}</a>
<a name="ln619"> </a>
<a name="ln620">static void _sdump_messages(dump_params &amp;par)</a>
<a name="ln621">{</a>
<a name="ln622">    // A little message history:</a>
<a name="ln623">    if (Options.dump_message_count &gt; 0)</a>
<a name="ln624">    {</a>
<a name="ln625">        par.text += &quot;Message History\n\n&quot;;</a>
<a name="ln626">        par.text += get_last_messages(Options.dump_message_count);</a>
<a name="ln627">    }</a>
<a name="ln628">}</a>
<a name="ln629"> </a>
<a name="ln630">static void _sdump_screenshot(dump_params &amp;par)</a>
<a name="ln631">{</a>
<a name="ln632">    par.text += screenshot();</a>
<a name="ln633">    par.text += &quot;\n\n&quot;;</a>
<a name="ln634">}</a>
<a name="ln635"> </a>
<a name="ln636">static void _sdump_notes(dump_params &amp;par)</a>
<a name="ln637">{</a>
<a name="ln638">    string &amp;text(par.text);</a>
<a name="ln639">    if (note_list.empty())</a>
<a name="ln640">        return;</a>
<a name="ln641"> </a>
<a name="ln642">    text += &quot;Notes\n&quot;;</a>
<a name="ln643">    text += &quot;Turn   | Place    | Note\n&quot;;</a>
<a name="ln644">    text += &quot;-------+----------+-------------------------------------------\n&quot;;</a>
<a name="ln645">    for (const Note &amp;note : note_list)</a>
<a name="ln646">    {</a>
<a name="ln647">        if (note.hidden())</a>
<a name="ln648">            continue;</a>
<a name="ln649"> </a>
<a name="ln650">        string prefix = note.describe(true, true, false);</a>
<a name="ln651">        string suffix = note.describe(false, false, true);</a>
<a name="ln652">        if (suffix.empty())</a>
<a name="ln653">            continue;</a>
<a name="ln654">        int spaceleft = 80 - prefix.length() - 1; // Use 100 cols</a>
<a name="ln655">        if (spaceleft &lt;= 0)</a>
<a name="ln656">            return;</a>
<a name="ln657"> </a>
<a name="ln658">        linebreak_string(suffix, spaceleft);</a>
<a name="ln659">        vector&lt;string&gt; parts = split_string(&quot;\n&quot;, suffix);</a>
<a name="ln660">        if (parts.empty()) // Disregard pure-whitespace notes.</a>
<a name="ln661">            continue;</a>
<a name="ln662"> </a>
<a name="ln663">        text += prefix + parts[0] + &quot;\n&quot;;</a>
<a name="ln664">        for (unsigned int j = 1; j &lt; parts.size(); ++j)</a>
<a name="ln665">            text += string(prefix.length()-2, ' ') + string(&quot;| &quot;) + parts[j] + &quot;\n&quot;;</a>
<a name="ln666">    }</a>
<a name="ln667">    text += &quot;\n&quot;;</a>
<a name="ln668">}</a>
<a name="ln669"> </a>
<a name="ln670">static void _sdump_location(dump_params &amp;par)</a>
<a name="ln671">{</a>
<a name="ln672">    if (you.depth == 0 &amp;&amp; player_in_branch(BRANCH_DUNGEON))</a>
<a name="ln673">        par.text += &quot;You escaped&quot;;</a>
<a name="ln674">    else if (par.se)</a>
<a name="ln675">        par.text += &quot;You were &quot; + prep_branch_level_name();</a>
<a name="ln676">    else</a>
<a name="ln677">        par.text += &quot;You are &quot; + prep_branch_level_name();</a>
<a name="ln678"> </a>
<a name="ln679">    par.text += &quot;.&quot;;</a>
<a name="ln680">    par.text += &quot;\n&quot;;</a>
<a name="ln681">}</a>
<a name="ln682"> </a>
<a name="ln683">static void _sdump_religion(dump_params &amp;par)</a>
<a name="ln684">{</a>
<a name="ln685">    string &amp;text(par.text);</a>
<a name="ln686">    if (!you_worship(GOD_NO_GOD))</a>
<a name="ln687">    {</a>
<a name="ln688">        if (par.se)</a>
<a name="ln689">            text += &quot;You worshipped &quot;;</a>
<a name="ln690">        else</a>
<a name="ln691">            text += &quot;You worship &quot;;</a>
<a name="ln692">        text += god_name(you.religion);</a>
<a name="ln693">        text += &quot;.\n&quot;;</a>
<a name="ln694"> </a>
<a name="ln695">        if (!you_worship(GOD_XOM))</a>
<a name="ln696">        {</a>
<a name="ln697">            if (!player_under_penance())</a>
<a name="ln698">            {</a>
<a name="ln699">                text += god_prayer_reaction();</a>
<a name="ln700">                text += &quot;\n&quot;;</a>
<a name="ln701">            }</a>
<a name="ln702">            else</a>
<a name="ln703">            {</a>
<a name="ln704">                string verb = par.se ? &quot;was&quot; : &quot;is&quot;;</a>
<a name="ln705"> </a>
<a name="ln706">                text += uppercase_first(god_name(you.religion));</a>
<a name="ln707">                text += &quot; &quot; + verb + &quot; demanding penance.\n&quot;;</a>
<a name="ln708">            }</a>
<a name="ln709">        }</a>
<a name="ln710">        else</a>
<a name="ln711">        {</a>
<a name="ln712">            if (par.se)</a>
<a name="ln713">                text += &quot;You were &quot;;</a>
<a name="ln714">            else</a>
<a name="ln715">                text += &quot;You are &quot;;</a>
<a name="ln716">            text += describe_xom_favour();</a>
<a name="ln717">            text += &quot;\n&quot;;</a>
<a name="ln718">        }</a>
<a name="ln719">    }</a>
<a name="ln720">}</a>
<a name="ln721"> </a>
<a name="ln722">static bool _dump_item_origin(const item_def &amp;item)</a>
<a name="ln723">{</a>
<a name="ln724">#define fs(x) (flags &amp; (x))</a>
<a name="ln725">    const int flags = Options.dump_item_origins;</a>
<a name="ln726">    if (flags == IODS_EVERYTHING)</a>
<a name="ln727">        return true;</a>
<a name="ln728"> </a>
<a name="ln729">    if (fs(IODS_ARTEFACTS)</a>
<a name="ln730">        &amp;&amp; is_artefact(item) &amp;&amp; item_ident(item, ISFLAG_KNOW_PROPERTIES))</a>
<a name="ln731">    {</a>
<a name="ln732">        return true;</a>
<a name="ln733">    }</a>
<a name="ln734">    if (fs(IODS_EGO_ARMOUR) &amp;&amp; item.base_type == OBJ_ARMOUR</a>
<a name="ln735">        &amp;&amp; item_type_known(item))</a>
<a name="ln736">    {</a>
<a name="ln737">        const int spec_ench = get_armour_ego_type(item);</a>
<a name="ln738">        return spec_ench != SPARM_NORMAL;</a>
<a name="ln739">    }</a>
<a name="ln740"> </a>
<a name="ln741">    if (fs(IODS_EGO_WEAPON) &amp;&amp; item.base_type == OBJ_WEAPONS</a>
<a name="ln742">        &amp;&amp; item_type_known(item))</a>
<a name="ln743">    {</a>
<a name="ln744">        return get_weapon_brand(item) != SPWPN_NORMAL;</a>
<a name="ln745">    }</a>
<a name="ln746"> </a>
<a name="ln747">    if (fs(IODS_JEWELLERY) &amp;&amp; item.base_type == OBJ_JEWELLERY)</a>
<a name="ln748">        return true;</a>
<a name="ln749"> </a>
<a name="ln750">    if (fs(IODS_RUNES) &amp;&amp; item.base_type == OBJ_RUNES)</a>
<a name="ln751">        return true;</a>
<a name="ln752"> </a>
<a name="ln753">    if (fs(IODS_STAVES) &amp;&amp; item.base_type == OBJ_STAVES)</a>
<a name="ln754">        return true;</a>
<a name="ln755"> </a>
<a name="ln756">    if (fs(IODS_BOOKS) &amp;&amp; item.base_type == OBJ_BOOKS)</a>
<a name="ln757">        return true;</a>
<a name="ln758"> </a>
<a name="ln759">    const int refpr = Options.dump_item_origin_price;</a>
<a name="ln760">    if (refpr == -1)</a>
<a name="ln761">        return false;</a>
<a name="ln762">    return (int)item_value(item, false) &gt;= refpr;</a>
<a name="ln763">#undef fs</a>
<a name="ln764">}</a>
<a name="ln765"> </a>
<a name="ln766">static void _sdump_inventory(dump_params &amp;par)</a>
<a name="ln767">{</a>
<a name="ln768">    int i;</a>
<a name="ln769"> </a>
<a name="ln770">    string &amp;text(par.text);</a>
<a name="ln771"> </a>
<a name="ln772">    int inv_class2[NUM_OBJECT_CLASSES] = { 0, };</a>
<a name="ln773">    int inv_count = 0;</a>
<a name="ln774"> </a>
<a name="ln775">    for (const auto &amp;item : you.inv)</a>
<a name="ln776">    {</a>
<a name="ln777">        if (item.defined())</a>
<a name="ln778">        {</a>
<a name="ln779">            // adds up number of each class in invent.</a>
<a name="ln780">            inv_class2[item.base_type]++;</a>
<a name="ln781">            inv_count++;</a>
<a name="ln782">        }</a>
<a name="ln783">    }</a>
<a name="ln784"> </a>
<a name="ln785">    if (!inv_count)</a>
<a name="ln786">    {</a>
<a name="ln787">        text += &quot;You aren't carrying anything.&quot;;</a>
<a name="ln788">        text += &quot;\n&quot;;</a>
<a name="ln789">    }</a>
<a name="ln790">    else</a>
<a name="ln791">    {</a>
<a name="ln792">        text += &quot;Inventory:\n\n&quot;;</a>
<a name="ln793"> </a>
<a name="ln794">        for (int obj = 0; obj &lt; NUM_OBJECT_CLASSES; obj++)</a>
<a name="ln795">        {</a>
<a name="ln796">            i = inv_order[obj];</a>
<a name="ln797"> </a>
<a name="ln798">            if (inv_class2[i] == 0)</a>
<a name="ln799">                continue;</a>
<a name="ln800"> </a>
<a name="ln801">            text += item_class_name(i);</a>
<a name="ln802">            text += &quot;\n&quot;;</a>
<a name="ln803"> </a>
<a name="ln804">            for (const auto &amp;item : you.inv)</a>
<a name="ln805">            {</a>
<a name="ln806">                if (!item.defined() || item.base_type != i)</a>
<a name="ln807">                    continue;</a>
<a name="ln808"> </a>
<a name="ln809">                text += &quot; &quot;;</a>
<a name="ln810">                text += item.name(DESC_INVENTORY_EQUIP);</a>
<a name="ln811"> </a>
<a name="ln812">                inv_count--;</a>
<a name="ln813"> </a>
<a name="ln814">                if (origin_describable(item) &amp;&amp; _dump_item_origin(item))</a>
<a name="ln815">                    text += &quot;\n&quot; &quot;   (&quot; + origin_desc(item) + &quot;)&quot;;</a>
<a name="ln816"> </a>
<a name="ln817">                if (is_dumpable_artefact(item))</a>
<a name="ln818">                    text += chardump_desc(item);</a>
<a name="ln819">                else</a>
<a name="ln820">                    text += &quot;\n&quot;;</a>
<a name="ln821">            }</a>
<a name="ln822">        }</a>
<a name="ln823">    }</a>
<a name="ln824">    text += &quot;\n\n&quot;;</a>
<a name="ln825">}</a>
<a name="ln826"> </a>
<a name="ln827">static void _sdump_skills(dump_params &amp;par)</a>
<a name="ln828">{</a>
<a name="ln829">    string &amp;text(par.text);</a>
<a name="ln830"> </a>
<a name="ln831">    text += &quot;   Skills:\n&quot;;</a>
<a name="ln832"> </a>
<a name="ln833">    dump_skills(text);</a>
<a name="ln834">    text += &quot;\n&quot;;</a>
<a name="ln835">    text += &quot;\n&quot;;</a>
<a name="ln836">}</a>
<a name="ln837"> </a>
<a name="ln838">static string spell_type_shortname(spschool spell_class, bool slash)</a>
<a name="ln839">{</a>
<a name="ln840">    string ret;</a>
<a name="ln841"> </a>
<a name="ln842">    if (slash)</a>
<a name="ln843">        ret = &quot;/&quot;;</a>
<a name="ln844"> </a>
<a name="ln845">    ret += spelltype_short_name(spell_class);</a>
<a name="ln846"> </a>
<a name="ln847">    return ret;</a>
<a name="ln848">}</a>
<a name="ln849"> </a>
<a name="ln850">static void _sdump_spells(dump_params &amp;par)</a>
<a name="ln851">{</a>
<a name="ln852">    string &amp;text(par.text);</a>
<a name="ln853"> </a>
<a name="ln854">    int spell_levels = player_spell_levels();</a>
<a name="ln855"> </a>
<a name="ln856">    string verb = par.se? &quot;had&quot; : &quot;have&quot;;</a>
<a name="ln857"> </a>
<a name="ln858">    if (spell_levels == 1)</a>
<a name="ln859">        text += &quot;You &quot; + verb + &quot; one spell level left.&quot;;</a>
<a name="ln860">    else if (spell_levels == 0)</a>
<a name="ln861">    {</a>
<a name="ln862">        verb = par.se? &quot;couldn't&quot; : &quot;cannot&quot;;</a>
<a name="ln863"> </a>
<a name="ln864">        text += &quot;You &quot; + verb + &quot; memorise any spells.&quot;;</a>
<a name="ln865">    }</a>
<a name="ln866">    else</a>
<a name="ln867">    {</a>
<a name="ln868">        if (par.se)</a>
<a name="ln869">            text += &quot;You had &quot;;</a>
<a name="ln870">        else</a>
<a name="ln871">            text += &quot;You have &quot;;</a>
<a name="ln872">        text += make_stringf(&quot;%d spell levels left.&quot;, spell_levels);</a>
<a name="ln873">    }</a>
<a name="ln874"> </a>
<a name="ln875">    text += &quot;\n&quot;;</a>
<a name="ln876"> </a>
<a name="ln877">    if (!you.spell_no)</a>
<a name="ln878">    {</a>
<a name="ln879">        verb = par.se? &quot;didn't&quot; : &quot;don't&quot;;</a>
<a name="ln880"> </a>
<a name="ln881">        text += &quot;You &quot; + verb + &quot; know any spells.\n&quot;;</a>
<a name="ln882">    }</a>
<a name="ln883">    else</a>
<a name="ln884">    {</a>
<a name="ln885">        verb = par.se? &quot;knew&quot; : &quot;know&quot;;</a>
<a name="ln886"> </a>
<a name="ln887">        text += &quot;You &quot; + verb + &quot; the following spells:\n\n&quot;;</a>
<a name="ln888"> </a>
<a name="ln889">        text += &quot; Your Spells              Type           Power        Failure   Level  Hunger&quot; &quot;\n&quot;;</a>
<a name="ln890"> </a>
<a name="ln891">        for (int j = 0; j &lt; 52; j++)</a>
<a name="ln892">        {</a>
<a name="ln893">            const char letter = index_to_letter(j);</a>
<a name="ln894">            const spell_type spell  = get_spell_by_letter(letter);</a>
<a name="ln895"> </a>
<a name="ln896">            if (spell != SPELL_NO_SPELL)</a>
<a name="ln897">            {</a>
<a name="ln898">                string spell_line;</a>
<a name="ln899"> </a>
<a name="ln900">                spell_line += letter;</a>
<a name="ln901">                spell_line += &quot; - &quot;;</a>
<a name="ln902">                spell_line += spell_title(spell);</a>
<a name="ln903"> </a>
<a name="ln904">                spell_line = chop_string(spell_line, 24);</a>
<a name="ln905">                spell_line += &quot;  &quot;;</a>
<a name="ln906"> </a>
<a name="ln907">                bool already = false;</a>
<a name="ln908"> </a>
<a name="ln909">                for (const auto bit : spschools_type::range())</a>
<a name="ln910">                {</a>
<a name="ln911">                    if (spell_typematch(spell, bit))</a>
<a name="ln912">                    {</a>
<a name="ln913">                        spell_line += spell_type_shortname(bit, already);</a>
<a name="ln914">                        already = true;</a>
<a name="ln915">                    }</a>
<a name="ln916">                }</a>
<a name="ln917"> </a>
<a name="ln918">                spell_line = chop_string(spell_line, 41);</a>
<a name="ln919"> </a>
<a name="ln920">                spell_line += spell_power_string(spell);</a>
<a name="ln921"> </a>
<a name="ln922">                spell_line = chop_string(spell_line, 54);</a>
<a name="ln923"> </a>
<a name="ln924">                spell_line += failure_rate_to_string(raw_spell_fail(spell));</a>
<a name="ln925"> </a>
<a name="ln926">                spell_line = chop_string(spell_line, 66);</a>
<a name="ln927"> </a>
<a name="ln928">                spell_line += make_stringf(&quot;%-5d&quot;, spell_difficulty(spell));</a>
<a name="ln929"> </a>
<a name="ln930">                spell_line += spell_hunger_string(spell);</a>
<a name="ln931">                spell_line += &quot;\n&quot;;</a>
<a name="ln932"> </a>
<a name="ln933">                text += spell_line;</a>
<a name="ln934">            }</a>
<a name="ln935">        }</a>
<a name="ln936">        text += &quot;\n&quot;;</a>
<a name="ln937">    }</a>
<a name="ln938"> </a>
<a name="ln939">    if (!you.spell_library.count())</a>
<a name="ln940">    {</a>
<a name="ln941">        verb = par.se ? &quot;was&quot; : &quot;is&quot;;</a>
<a name="ln942">        text += &quot;Your spell library &quot; + verb + &quot; empty.\n\n&quot;;</a>
<a name="ln943">    }</a>
<a name="ln944">    else</a>
<a name="ln945">    {</a>
<a name="ln946">        verb = par.se? &quot;contained&quot; : &quot;contains&quot;;</a>
<a name="ln947">        text += &quot;Your spell library &quot; + verb + &quot; the following spells:\n\n&quot;;</a>
<a name="ln948">        text += &quot; Spells                   Type           Power        Failure   Level  Hunger&quot; &quot;\n&quot;;</a>
<a name="ln949"> </a>
<a name="ln950">        auto const library = get_sorted_spell_list(true, false);</a>
<a name="ln951"> </a>
<a name="ln952">        for (const spell_type spell : library)</a>
<a name="ln953">        {</a>
<a name="ln954">            const bool memorisable = you_can_memorise(spell);</a>
<a name="ln955"> </a>
<a name="ln956">            string spell_line;</a>
<a name="ln957"> </a>
<a name="ln958">            spell_line += ' ';</a>
<a name="ln959">            spell_line += spell_title(spell);</a>
<a name="ln960"> </a>
<a name="ln961">            spell_line = chop_string(spell_line, 24);</a>
<a name="ln962">            spell_line += &quot;  &quot;;</a>
<a name="ln963"> </a>
<a name="ln964">            bool already = false;</a>
<a name="ln965"> </a>
<a name="ln966">            for (const auto bit : spschools_type::range())</a>
<a name="ln967">            {</a>
<a name="ln968">                if (spell_typematch(spell, bit))</a>
<a name="ln969">                {</a>
<a name="ln970">                    spell_line += spell_type_shortname(bit, already);</a>
<a name="ln971">                    already = true;</a>
<a name="ln972">                }</a>
<a name="ln973">            }</a>
<a name="ln974"> </a>
<a name="ln975">            spell_line = chop_string(spell_line, 41);</a>
<a name="ln976"> </a>
<a name="ln977">            if (memorisable)</a>
<a name="ln978">                spell_line += spell_power_string(spell);</a>
<a name="ln979">            else</a>
<a name="ln980">                spell_line += &quot;Unusable&quot;;</a>
<a name="ln981"> </a>
<a name="ln982">            spell_line = chop_string(spell_line, 54);</a>
<a name="ln983"> </a>
<a name="ln984">            if (memorisable)</a>
<a name="ln985">                spell_line += failure_rate_to_string(raw_spell_fail(spell));</a>
<a name="ln986">            else</a>
<a name="ln987">                spell_line += &quot;N/A&quot;;</a>
<a name="ln988"> </a>
<a name="ln989">            spell_line = chop_string(spell_line, 66);</a>
<a name="ln990"> </a>
<a name="ln991">            spell_line += make_stringf(&quot;%-5d&quot;, spell_difficulty(spell));</a>
<a name="ln992"> </a>
<a name="ln993">            if (memorisable)</a>
<a name="ln994">                spell_line += spell_hunger_string(spell);</a>
<a name="ln995">            else</a>
<a name="ln996">                spell_line += &quot;N/A&quot;;</a>
<a name="ln997">            spell_line += &quot;\n&quot;;</a>
<a name="ln998"> </a>
<a name="ln999">            text += spell_line;</a>
<a name="ln1000">        }</a>
<a name="ln1001">        text += &quot;\n\n&quot;;</a>
<a name="ln1002">    }</a>
<a name="ln1003">}</a>
<a name="ln1004"> </a>
<a name="ln1005">static void _sdump_kills(dump_params &amp;par)</a>
<a name="ln1006">{</a>
<a name="ln1007">    par.text += you.kills.kill_info();</a>
<a name="ln1008">    par.text += &quot;\n&quot;;</a>
<a name="ln1009">}</a>
<a name="ln1010"> </a>
<a name="ln1011">static string _sdump_kills_place_info(const PlaceInfo place_info, string name = &quot;&quot;)</a>
<a name="ln1012">{</a>
<a name="ln1013">    string out;</a>
<a name="ln1014"> </a>
<a name="ln1015">    if (name.empty())</a>
<a name="ln1016">        name = place_info.short_name();</a>
<a name="ln1017"> </a>
<a name="ln1018">    unsigned int global_total_kills = 0;</a>
<a name="ln1019">    for (int i = 0; i &lt; KC_NCATEGORIES; i++)</a>
<a name="ln1020">        global_total_kills += you.global_info.mon_kill_num[i];</a>
<a name="ln1021"> </a>
<a name="ln1022">    unsigned int total_kills = 0;</a>
<a name="ln1023">    for (int i = 0; i &lt; KC_NCATEGORIES; i++)</a>
<a name="ln1024">        total_kills += place_info.mon_kill_num[i];</a>
<a name="ln1025"> </a>
<a name="ln1026">    // Skip places where nothing was killed.</a>
<a name="ln1027">    if (total_kills == 0)</a>
<a name="ln1028">        return &quot;&quot;;</a>
<a name="ln1029"> </a>
<a name="ln1030">    float a, b, c, d, e, f;</a>
<a name="ln1031"> </a>
<a name="ln1032">    a = TO_PERCENT(total_kills, global_total_kills);</a>
<a name="ln1033">    b = TO_PERCENT(place_info.mon_kill_num[KC_YOU],</a>
<a name="ln1034">                   you.global_info.mon_kill_num[KC_YOU]);</a>
<a name="ln1035">    c = TO_PERCENT(place_info.mon_kill_num[KC_FRIENDLY],</a>
<a name="ln1036">                   you.global_info.mon_kill_num[KC_FRIENDLY]);</a>
<a name="ln1037">    d = TO_PERCENT(place_info.mon_kill_num[KC_OTHER],</a>
<a name="ln1038">                   you.global_info.mon_kill_num[KC_OTHER]);</a>
<a name="ln1039">    e = TO_PERCENT(place_info.mon_kill_exp,</a>
<a name="ln1040">                   you.global_info.mon_kill_exp);</a>
<a name="ln1041"> </a>
<a name="ln1042">    f = float(place_info.mon_kill_exp) / place_info.levels_seen;</a>
<a name="ln1043"> </a>
<a name="ln1044">    out =</a>
<a name="ln1045">        make_stringf(&quot;%14s | %5.1f | %5.1f | %5.1f | %5.1f | %5.1f |&quot;</a>
<a name="ln1046">                     &quot; %13.1f\n&quot;,</a>
<a name="ln1047">                     name.c_str(), a, b, c , d, e, f);</a>
<a name="ln1048"> </a>
<a name="ln1049">    return _denanify(out);</a>
<a name="ln1050">}</a>
<a name="ln1051"> </a>
<a name="ln1052">static void _sdump_kills_by_place(dump_params &amp;par)</a>
<a name="ln1053">{</a>
<a name="ln1054">    string &amp;text(par.text);</a>
<a name="ln1055"> </a>
<a name="ln1056">    const vector&lt;PlaceInfo&gt; all_visited = you.get_all_place_info(true);</a>
<a name="ln1057"> </a>
<a name="ln1058">    string result = &quot;&quot;;</a>
<a name="ln1059"> </a>
<a name="ln1060">    string header =</a>
<a name="ln1061">    &quot;Table legend:\n&quot;</a>
<a name="ln1062">    &quot; A = Kills in this place as a percentage of kills in entire the game.\n&quot;</a>
<a name="ln1063">    &quot; B = Kills by you in this place as a percentage of kills by you in\n&quot;</a>
<a name="ln1064">    &quot;     the entire game.\n&quot;</a>
<a name="ln1065">    &quot; C = Kills by friends in this place as a percentage of kills by\n&quot;</a>
<a name="ln1066">    &quot;     friends in the entire game.\n&quot;</a>
<a name="ln1067">    &quot; D = Other kills in this place as a percentage of other kills in the\n&quot;</a>
<a name="ln1068">    &quot;     entire game.\n&quot;</a>
<a name="ln1069">    &quot; E = Experience gained in this place as a percentage of experience\n&quot;</a>
<a name="ln1070">    &quot;     gained in the entire game.\n&quot;</a>
<a name="ln1071">    &quot; F = Experience gained in this place divided by the number of levels of\n&quot;</a>
<a name="ln1072">    &quot;     this place that you have seen.\n\n&quot;;</a>
<a name="ln1073"> </a>
<a name="ln1074">    header += &quot;               &quot;;</a>
<a name="ln1075">    header += &quot;    A       B       C       D       E               F\n&quot;;</a>
<a name="ln1076">    header += &quot;               &quot;;</a>
<a name="ln1077">    header += &quot;+-------+-------+-------+-------+-------+----------------------\n&quot;;</a>
<a name="ln1078"> </a>
<a name="ln1079">    string footer = &quot;               &quot;;</a>
<a name="ln1080">    footer += &quot;+-------+-------+-------+-------+-------+----------------------\n&quot;;</a>
<a name="ln1081"> </a>
<a name="ln1082">    result += _sdump_kills_place_info(you.global_info, &quot;Total&quot;);</a>
<a name="ln1083"> </a>
<a name="ln1084">    for (const PlaceInfo &amp;pi : all_visited)</a>
<a name="ln1085">        result += _sdump_kills_place_info(pi);</a>
<a name="ln1086"> </a>
<a name="ln1087">    if (!result.empty())</a>
<a name="ln1088">        text += header + result + footer + &quot;\n&quot;;</a>
<a name="ln1089">}</a>
<a name="ln1090"> </a>
<a name="ln1091">static void _sdump_overview(dump_params &amp;par)</a>
<a name="ln1092">{</a>
<a name="ln1093">    string overview =</a>
<a name="ln1094">        formatted_string::parse_string(overview_description_string(false));</a>
<a name="ln1095">    trim_string(overview);</a>
<a name="ln1096">    linebreak_string(overview, 80);</a>
<a name="ln1097">    par.text += overview;</a>
<a name="ln1098">    par.text += &quot;\n\n&quot;;</a>
<a name="ln1099">}</a>
<a name="ln1100"> </a>
<a name="ln1101">static void _sdump_hiscore(dump_params &amp;par)</a>
<a name="ln1102">{</a>
<a name="ln1103">    if (!par.se)</a>
<a name="ln1104">        return;</a>
<a name="ln1105"> </a>
<a name="ln1106">    string hiscore = hiscores_format_single_long(*(par.se), true);</a>
<a name="ln1107">    trim_string(hiscore);</a>
<a name="ln1108">    par.text += hiscore;</a>
<a name="ln1109">    par.text += &quot;\n\n&quot;;</a>
<a name="ln1110">}</a>
<a name="ln1111"> </a>
<a name="ln1112">static void _sdump_monster_list(dump_params &amp;par)</a>
<a name="ln1113">{</a>
<a name="ln1114">    string monlist = mpr_monster_list(par.se);</a>
<a name="ln1115">    trim_string(monlist);</a>
<a name="ln1116">    while (!monlist.empty())</a>
<a name="ln1117">        par.text += wordwrap_line(monlist, 80) + &quot;\n&quot;;</a>
<a name="ln1118">    par.text += &quot;\n&quot;;</a>
<a name="ln1119">}</a>
<a name="ln1120"> </a>
<a name="ln1121">static void _sdump_vault_list(dump_params &amp;par)</a>
<a name="ln1122">{</a>
<a name="ln1123">    if (par.full_id || par.se</a>
<a name="ln1124">#ifdef WIZARD</a>
<a name="ln1125">        || you.wizard || you.suppress_wizard</a>
<a name="ln1126">#endif</a>
<a name="ln1127">     )</a>
<a name="ln1128">    {</a>
<a name="ln1129">        par.text += &quot;Levels and vault maps discovered:\n&quot;;</a>
<a name="ln1130">        par.text += dump_vault_maps();</a>
<a name="ln1131">        par.text += &quot;\n&quot;;</a>
<a name="ln1132">    }</a>
<a name="ln1133">}</a>
<a name="ln1134"> </a>
<a name="ln1135">static bool _sort_by_first(pair&lt;int, FixedVector&lt;int, 28&gt; &gt; a,</a>
<a name="ln1136">                           pair&lt;int, FixedVector&lt;int, 28&gt; &gt; b)</a>
<a name="ln1137">{</a>
<a name="ln1138">    for (int i = 0; i &lt; 27; i++)</a>
<a name="ln1139">    {</a>
<a name="ln1140">        if (a.second[i] &gt; b.second[i])</a>
<a name="ln1141">            return true;</a>
<a name="ln1142">        else if (a.second[i] &lt; b.second[i])</a>
<a name="ln1143">            return false;</a>
<a name="ln1144">    }</a>
<a name="ln1145">    return false;</a>
<a name="ln1146">}</a>
<a name="ln1147"> </a>
<a name="ln1148">static void _count_action(caction_type type, int subtype)</a>
<a name="ln1149">{</a>
<a name="ln1150">    pair&lt;caction_type, int&gt; pair(type, subtype);</a>
<a name="ln1151">    if (!you.action_count.count(pair))</a>
<a name="ln1152">        you.action_count[pair].init(0);</a>
<a name="ln1153">    you.action_count[pair][you.experience_level - 1]++;</a>
<a name="ln1154">}</a>
<a name="ln1155"> </a>
<a name="ln1156">/**</a>
<a name="ln1157"> * The alternate type is stored in the higher bytes.</a>
<a name="ln1158"> **/</a>
<a name="ln1159">void count_action(caction_type type, int subtype, int auxtype)</a>
<a name="ln1160">{</a>
<a name="ln1161">    ASSERT_RANGE(subtype, -32768, 32768);</a>
<a name="ln1162">    ASSERT_RANGE(auxtype, -32768, 32768);</a>
<a name="ln1163">    _count_action(type, caction_compound(subtype, auxtype));</a>
<a name="ln1164">}</a>
<a name="ln1165"> </a>
<a name="ln1166">int caction_compound(int subtype, int auxtype)</a>
<a name="ln1167">{</a>
<a name="ln1168">    ASSERT_RANGE(subtype, -32768, 32768);</a>
<a name="ln1169">    ASSERT_RANGE(auxtype, -32768, 32768);</a>
<a name="ln1170">    return (auxtype &lt;&lt; 16) | (subtype &amp; 0xFFFF);</a>
<a name="ln1171">}</a>
<a name="ln1172"> </a>
<a name="ln1173">/**</a>
<a name="ln1174"> * .first is the subtype; .second is the auxtype (-1 if none).</a>
<a name="ln1175"> **/</a>
<a name="ln1176">pair&lt;int, int&gt; caction_extract_types(int compound_subtype)</a>
<a name="ln1177">{</a>
<a name="ln1178">    return make_pair(int16_t(compound_subtype),</a>
<a name="ln1179">                     int16_t(compound_subtype &gt;&gt; 16));</a>
<a name="ln1180">}</a>
<a name="ln1181"> </a>
<a name="ln1182">static string _describe_action(caction_type type)</a>
<a name="ln1183">{</a>
<a name="ln1184">    switch (type)</a>
<a name="ln1185">    {</a>
<a name="ln1186">    case CACT_MELEE:</a>
<a name="ln1187">        return &quot;Melee&quot;;</a>
<a name="ln1188">    case CACT_FIRE:</a>
<a name="ln1189">        return &quot; Fire&quot;;</a>
<a name="ln1190">    case CACT_THROW:</a>
<a name="ln1191">        return &quot;Throw&quot;;</a>
<a name="ln1192">    case CACT_ARMOUR:</a>
<a name="ln1193">        return &quot;Armor&quot;; // &quot;Armour&quot; is too long</a>
<a name="ln1194">    case CACT_BLOCK:</a>
<a name="ln1195">        return &quot;Block&quot;;</a>
<a name="ln1196">    case CACT_DODGE:</a>
<a name="ln1197">        return &quot;Dodge&quot;;</a>
<a name="ln1198">    case CACT_CAST:</a>
<a name="ln1199">        return &quot; Cast&quot;;</a>
<a name="ln1200">    case CACT_INVOKE:</a>
<a name="ln1201">        return &quot;Invok&quot;;</a>
<a name="ln1202">    case CACT_ABIL:</a>
<a name="ln1203">        return &quot; Abil&quot;;</a>
<a name="ln1204">    case CACT_EVOKE:</a>
<a name="ln1205">        return &quot;Evoke&quot;;</a>
<a name="ln1206">    case CACT_USE:</a>
<a name="ln1207">        return &quot;  Use&quot;;</a>
<a name="ln1208">    case CACT_STAB:</a>
<a name="ln1209">        return &quot; Stab&quot;;</a>
<a name="ln1210">    case CACT_EAT:</a>
<a name="ln1211">        return &quot;  Eat&quot;;</a>
<a name="ln1212">    case CACT_RIPOSTE:</a>
<a name="ln1213">        return &quot;Rpst.&quot;;</a>
<a name="ln1214">    default:</a>
<a name="ln1215">        return &quot;Error&quot;;</a>
<a name="ln1216">    }</a>
<a name="ln1217">}</a>
<a name="ln1218"> </a>
<a name="ln1219">static const char* _stab_names[] =</a>
<a name="ln1220">{</a>
<a name="ln1221">    &quot;Normal&quot;,</a>
<a name="ln1222">    &quot;Distracted&quot;,</a>
<a name="ln1223">    &quot;Confused&quot;,</a>
<a name="ln1224">    &quot;Fleeing&quot;,</a>
<a name="ln1225">    &quot;Invisible&quot;,</a>
<a name="ln1226">    &quot;Held in net/web&quot;,</a>
<a name="ln1227">    &quot;Petrifying&quot;, // could be nice to combine the two</a>
<a name="ln1228">    &quot;Petrified&quot;,</a>
<a name="ln1229">    &quot;Paralysed&quot;,</a>
<a name="ln1230">    &quot;Sleeping&quot;,</a>
<a name="ln1231">    &quot;Betrayed ally&quot;,</a>
<a name="ln1232">};</a>
<a name="ln1233"> </a>
<a name="ln1234">static const char* _aux_attack_names[1 + UNAT_LAST_ATTACK] =</a>
<a name="ln1235">{</a>
<a name="ln1236">    &quot;No attack&quot;,</a>
<a name="ln1237">    &quot;Constrict&quot;,</a>
<a name="ln1238">    &quot;Kick&quot;,</a>
<a name="ln1239">    &quot;Headbutt&quot;,</a>
<a name="ln1240">    &quot;Peck&quot;,</a>
<a name="ln1241">    &quot;Tailslap&quot;,</a>
<a name="ln1242">    &quot;Punch&quot;,</a>
<a name="ln1243">    &quot;Bite&quot;,</a>
<a name="ln1244">    &quot;Pseudopods&quot;,</a>
<a name="ln1245">    &quot;Tentacles&quot;,</a>
<a name="ln1246">};</a>
<a name="ln1247"> </a>
<a name="ln1248">static string _describe_action_subtype(caction_type type, int compound_subtype)</a>
<a name="ln1249">{</a>
<a name="ln1250">    pair&lt;int, int&gt; types = caction_extract_types(compound_subtype);</a>
<a name="ln1251">    int subtype = types.first;</a>
<a name="ln1252">    int auxtype = types.second;</a>
<a name="ln1253"> </a>
<a name="ln1254">    switch (type)</a>
<a name="ln1255">    {</a>
<a name="ln1256">    case CACT_THROW:</a>
<a name="ln1257">    {</a>
<a name="ln1258">        if (auxtype == OBJ_MISSILES)</a>
<a name="ln1259">            return uppercase_first(item_base_name(OBJ_MISSILES, subtype));</a>
<a name="ln1260">        else</a>
<a name="ln1261">            return &quot;Other&quot;;</a>
<a name="ln1262">    }</a>
<a name="ln1263">    case CACT_MELEE:</a>
<a name="ln1264">    case CACT_FIRE:</a>
<a name="ln1265">    case CACT_RIPOSTE:</a>
<a name="ln1266">        if (subtype == -1)</a>
<a name="ln1267">        {</a>
<a name="ln1268">            if (auxtype == -1)</a>
<a name="ln1269">                return &quot;Unarmed&quot;;</a>
<a name="ln1270">            else</a>
<a name="ln1271">            {</a>
<a name="ln1272">                ASSERT_RANGE(auxtype, 0, NUM_UNARMED_ATTACKS);</a>
<a name="ln1273">                return _aux_attack_names[auxtype];</a>
<a name="ln1274">            }</a>
<a name="ln1275">        }</a>
<a name="ln1276">        else if (subtype &gt;= UNRAND_START)</a>
<a name="ln1277">        {</a>
<a name="ln1278">            // Paranoia: an artefact may lose its specialness.</a>
<a name="ln1279">            const char *tn = get_unrand_entry(subtype)-&gt;type_name;</a>
<a name="ln1280">            if (tn)</a>
<a name="ln1281">                return uppercase_first(tn);</a>
<a name="ln1282">            subtype = get_unrand_entry(subtype)-&gt;sub_type;</a>
<a name="ln1283">        }</a>
<a name="ln1284">        return uppercase_first(item_base_name(OBJ_WEAPONS, subtype));</a>
<a name="ln1285">    case CACT_ARMOUR:</a>
<a name="ln1286">        return (subtype == -1) ? &quot;Skin&quot;</a>
<a name="ln1287">               : uppercase_first(item_base_name(OBJ_ARMOUR, subtype));</a>
<a name="ln1288">    case CACT_BLOCK:</a>
<a name="ln1289">    {</a>
<a name="ln1290">        if (subtype &gt; -1)</a>
<a name="ln1291">            return uppercase_first(item_base_name(OBJ_ARMOUR, subtype));</a>
<a name="ln1292">        switch (auxtype)</a>
<a name="ln1293">        {</a>
<a name="ln1294">        case BLOCK_OTHER:</a>
<a name="ln1295">            return &quot;Other&quot;; // non-shield block</a>
<a name="ln1296">        case BLOCK_REFLECT:</a>
<a name="ln1297">            return &quot;Reflection&quot;;</a>
<a name="ln1298">        default:</a>
<a name="ln1299">            return &quot;Error&quot;;</a>
<a name="ln1300">        }</a>
<a name="ln1301">    }</a>
<a name="ln1302">    case CACT_DODGE:</a>
<a name="ln1303">    {</a>
<a name="ln1304">        switch ((dodge_type)subtype)</a>
<a name="ln1305">        {</a>
<a name="ln1306">        case DODGE_EVASION:</a>
<a name="ln1307">            return &quot;Dodged&quot;;</a>
<a name="ln1308">        case DODGE_REPEL:</a>
<a name="ln1309">            return &quot;Repelled&quot;;</a>
<a name="ln1310">        default:</a>
<a name="ln1311">            return &quot;Error&quot;;</a>
<a name="ln1312">        }</a>
<a name="ln1313">    }</a>
<a name="ln1314">    case CACT_CAST:</a>
<a name="ln1315">        return spell_title((spell_type)subtype);</a>
<a name="ln1316">    case CACT_INVOKE:</a>
<a name="ln1317">    case CACT_ABIL:</a>
<a name="ln1318">        return ability_name((ability_type)subtype);</a>
<a name="ln1319">    case CACT_EVOKE:</a>
<a name="ln1320">        if (subtype &gt;= UNRAND_START &amp;&amp; subtype &lt;= UNRAND_LAST)</a>
<a name="ln1321">            return uppercase_first(get_unrand_entry(subtype)-&gt;name);</a>
<a name="ln1322"> </a>
<a name="ln1323">        if (auxtype &gt; -1)</a>
<a name="ln1324">        {</a>
<a name="ln1325">            item_def dummy;</a>
<a name="ln1326">            dummy.base_type = (object_class_type)(auxtype);</a>
<a name="ln1327">            dummy.sub_type  = subtype;</a>
<a name="ln1328">            dummy.quantity  = 1;</a>
<a name="ln1329">            return uppercase_first(dummy.name(DESC_DBNAME, true));</a>
<a name="ln1330">        }</a>
<a name="ln1331"> </a>
<a name="ln1332">        switch ((evoc_type)subtype)</a>
<a name="ln1333">        {</a>
<a name="ln1334">        case EVOC_WAND:</a>
<a name="ln1335">            return &quot;Wand&quot;;</a>
<a name="ln1336">#if TAG_MAJOR_VERSION == 34</a>
<a name="ln1337">        case EVOC_ROD:</a>
<a name="ln1338">            return &quot;Rod&quot;;</a>
<a name="ln1339">        case EVOC_DECK:</a>
<a name="ln1340">            return &quot;Deck&quot;;</a>
<a name="ln1341">        case EVOC_MISC:</a>
<a name="ln1342">            return &quot;Miscellaneous&quot;;</a>
<a name="ln1343">        case EVOC_BUGGY_TOME:</a>
<a name="ln1344">            return &quot;tome&quot;;</a>
<a name="ln1345">#endif</a>
<a name="ln1346">        default:</a>
<a name="ln1347">            return &quot;Error&quot;;</a>
<a name="ln1348">        }</a>
<a name="ln1349">    case CACT_USE:</a>
<a name="ln1350">        return uppercase_first(base_type_string((object_class_type)subtype));</a>
<a name="ln1351">    case CACT_STAB:</a>
<a name="ln1352">        COMPILE_CHECK(ARRAYSZ(_stab_names) == NUM_STABS);</a>
<a name="ln1353">        ASSERT_RANGE(subtype, 1, NUM_STABS);</a>
<a name="ln1354">        return _stab_names[subtype];</a>
<a name="ln1355">    case CACT_EAT:</a>
<a name="ln1356">        return subtype &gt;= 0 ? uppercase_first(food_type_name(subtype))</a>
<a name="ln1357">                            : &quot;Corpse&quot;;</a>
<a name="ln1358">    default:</a>
<a name="ln1359">        return &quot;Error&quot;;</a>
<a name="ln1360">    }</a>
<a name="ln1361">}</a>
<a name="ln1362"> </a>
<a name="ln1363">static void _sdump_action_counts(dump_params &amp;par)</a>
<a name="ln1364">{</a>
<a name="ln1365">    if (you.action_count.empty())</a>
<a name="ln1366">        return;</a>
<a name="ln1367">    int max_lt = (min&lt;int&gt;(you.max_level, 27) - 1) / 3;</a>
<a name="ln1368"> </a>
<a name="ln1369">    // Don't show both a total and 1..3 when there's only one tier.</a>
<a name="ln1370">    if (max_lt)</a>
<a name="ln1371">        max_lt++;</a>
<a name="ln1372"> </a>
<a name="ln1373">    par.text += make_stringf(&quot;%-24s&quot;, &quot;Action&quot;);</a>
<a name="ln1374">    for (int lt = 0; lt &lt; max_lt; lt++)</a>
<a name="ln1375">        par.text += make_stringf(&quot; | %2d-%2d&quot;, lt * 3 + 1, lt * 3 + 3);</a>
<a name="ln1376">    par.text += make_stringf(&quot; || %5s&quot;, &quot;total&quot;);</a>
<a name="ln1377">    par.text += &quot;\n-------------------------&quot;;</a>
<a name="ln1378">    for (int lt = 0; lt &lt; max_lt; lt++)</a>
<a name="ln1379">        par.text += &quot;+-------&quot;;</a>
<a name="ln1380">    par.text += &quot;++-------\n&quot;;</a>
<a name="ln1381"> </a>
<a name="ln1382">    for (int cact = 0; cact &lt; NUM_CACTIONS; cact++)</a>
<a name="ln1383">    {</a>
<a name="ln1384">        vector&lt;pair&lt;int, FixedVector&lt;int, 28&gt; &gt; &gt; action_vec;</a>
<a name="ln1385">        for (const auto &amp;entry : you.action_count)</a>
<a name="ln1386">        {</a>
<a name="ln1387">            if (entry.first.first != cact)</a>
<a name="ln1388">                continue;</a>
<a name="ln1389">            FixedVector&lt;int, 28&gt; v;</a>
<a name="ln1390">            v[27] = 0;</a>
<a name="ln1391">            for (int i = 0; i &lt; 27; i++)</a>
<a name="ln1392">            {</a>
<a name="ln1393">                v[i] = entry.second[i];</a>
<a name="ln1394">                v[27] += v[i];</a>
<a name="ln1395">            }</a>
<a name="ln1396">            action_vec.emplace_back(entry.first.second, v);</a>
<a name="ln1397">        }</a>
<a name="ln1398">        sort(action_vec.begin(), action_vec.end(), _sort_by_first);</a>
<a name="ln1399"> </a>
<a name="ln1400">        for (auto ac = action_vec.begin(); ac != action_vec.end(); ++ac)</a>
<a name="ln1401">        {</a>
<a name="ln1402">            if (ac == action_vec.begin())</a>
<a name="ln1403">            {</a>
<a name="ln1404">                par.text += _describe_action(caction_type(cact));</a>
<a name="ln1405">                par.text += &quot;: &quot;;</a>
<a name="ln1406">            }</a>
<a name="ln1407">            else</a>
<a name="ln1408">                par.text += &quot;       &quot;;</a>
<a name="ln1409">            par.text += chop_string(_describe_action_subtype(caction_type(cact), ac-&gt;first), 17);</a>
<a name="ln1410">            for (int lt = 0; lt &lt; max_lt; lt++)</a>
<a name="ln1411">            {</a>
<a name="ln1412">                int ltotal = 0;</a>
<a name="ln1413">                for (int i = lt * 3; i &lt; lt * 3 + 3; i++)</a>
<a name="ln1414">                    ltotal += ac-&gt;second[i];</a>
<a name="ln1415">                if (ltotal)</a>
<a name="ln1416">                    par.text += make_stringf(&quot; |%6d&quot;, ltotal);</a>
<a name="ln1417">                else</a>
<a name="ln1418">                    par.text += &quot; |      &quot;;</a>
<a name="ln1419">            }</a>
<a name="ln1420">            par.text += make_stringf(&quot; ||%6d&quot;, ac-&gt;second[27]);</a>
<a name="ln1421">            par.text += &quot;\n&quot;;</a>
<a name="ln1422">        }</a>
<a name="ln1423">    }</a>
<a name="ln1424">    par.text += &quot;\n&quot;;</a>
<a name="ln1425">}</a>
<a name="ln1426"> </a>
<a name="ln1427">static void _sdump_skill_gains(dump_params &amp;par)</a>
<a name="ln1428">{</a>
<a name="ln1429">    typedef map&lt;int, int&gt; XlToSkillLevelMap;</a>
<a name="ln1430">    map&lt;skill_type, XlToSkillLevelMap&gt; skill_gains;</a>
<a name="ln1431">    vector&lt;skill_type&gt; skill_order;</a>
<a name="ln1432">    int xl = 0;</a>
<a name="ln1433">    int max_xl = 0;</a>
<a name="ln1434">    for (const Note &amp;note : note_list)</a>
<a name="ln1435">    {</a>
<a name="ln1436">        if (note.type == NOTE_XP_LEVEL_CHANGE)</a>
<a name="ln1437">            xl = note.first;</a>
<a name="ln1438">        else if (note.type == NOTE_GAIN_SKILL || note.type == NOTE_LOSE_SKILL)</a>
<a name="ln1439">        {</a>
<a name="ln1440">            skill_type skill = static_cast&lt;skill_type&gt;(note.first);</a>
<a name="ln1441">            int skill_level = note.second;</a>
<a name="ln1442">            if (skill_gains.find(skill) == skill_gains.end())</a>
<a name="ln1443">                skill_order.push_back(skill);</a>
<a name="ln1444">            skill_gains[skill][xl] = skill_level;</a>
<a name="ln1445">            max_xl = max(max_xl, xl);</a>
<a name="ln1446">        }</a>
<a name="ln1447">    }</a>
<a name="ln1448"> </a>
<a name="ln1449">    if (skill_order.empty())</a>
<a name="ln1450">        return;</a>
<a name="ln1451"> </a>
<a name="ln1452">    for (int i = 0; i &lt; NUM_SKILLS; i++)</a>
<a name="ln1453">    {</a>
<a name="ln1454">        skill_type skill = static_cast&lt;skill_type&gt;(i);</a>
<a name="ln1455">        if (you.skill(skill, 10, true) &gt; 0</a>
<a name="ln1456">            &amp;&amp; skill_gains.find(skill) == skill_gains.end())</a>
<a name="ln1457">        {</a>
<a name="ln1458">            skill_order.push_back(skill);</a>
<a name="ln1459">        }</a>
<a name="ln1460">    }</a>
<a name="ln1461"> </a>
<a name="ln1462">    par.text += &quot;Skill      XL: |&quot;;</a>
<a name="ln1463">    for (xl = 1; xl &lt;= max_xl; xl++)</a>
<a name="ln1464">        par.text += make_stringf(&quot; %2d&quot;, xl);</a>
<a name="ln1465">    par.text += &quot; |\n&quot;;</a>
<a name="ln1466">    par.text += &quot;---------------+&quot;;</a>
<a name="ln1467">    for (xl = 1; xl &lt;= max_xl; xl++)</a>
<a name="ln1468">        par.text += &quot;---&quot;;</a>
<a name="ln1469">    par.text += &quot;-+-----\n&quot;;</a>
<a name="ln1470"> </a>
<a name="ln1471">    for (skill_type skill : skill_order)</a>
<a name="ln1472">    {</a>
<a name="ln1473">        par.text += make_stringf(&quot;%-14s |&quot;, skill_name(skill));</a>
<a name="ln1474">        const XlToSkillLevelMap &amp;gains = skill_gains[skill];</a>
<a name="ln1475">        for (xl = 1; xl &lt;= max_xl; xl++)</a>
<a name="ln1476">        {</a>
<a name="ln1477">            auto it = gains.find(xl);</a>
<a name="ln1478">            if (it != gains.end())</a>
<a name="ln1479">                par.text += make_stringf(&quot; %2d&quot;, it-&gt;second);</a>
<a name="ln1480">            else</a>
<a name="ln1481">                par.text += &quot;   &quot;;</a>
<a name="ln1482">        }</a>
<a name="ln1483">        par.text += make_stringf(&quot; | %4.1f\n&quot;,</a>
<a name="ln1484">                                 you.skill(skill, 10, true) * 0.1);</a>
<a name="ln1485">    }</a>
<a name="ln1486">    par.text += &quot;\n&quot;;</a>
<a name="ln1487">}</a>
<a name="ln1488"> </a>
<a name="ln1489">static void _sdump_mutations(dump_params &amp;par)</a>
<a name="ln1490">{</a>
<a name="ln1491">    string &amp;text(par.text);</a>
<a name="ln1492"> </a>
<a name="ln1493">    if (you.how_mutated(true, false))</a>
<a name="ln1494">    {</a>
<a name="ln1495">        text += &quot;\n&quot;;</a>
<a name="ln1496">        text += (formatted_string::parse_string(describe_mutations(false)));</a>
<a name="ln1497">        text += &quot;\n\n&quot;;</a>
<a name="ln1498">    }</a>
<a name="ln1499">}</a>
<a name="ln1500"> </a>
<a name="ln1501">// Must match the order of hunger_state_t enums</a>
<a name="ln1502">static const char* hunger_names[] =</a>
<a name="ln1503">{</a>
<a name="ln1504">    &quot;fainting&quot;,</a>
<a name="ln1505">    &quot;starving&quot;,</a>
<a name="ln1506">    &quot;near starving&quot;,</a>
<a name="ln1507">    &quot;very hungry&quot;,</a>
<a name="ln1508">    &quot;hungry&quot;,</a>
<a name="ln1509">    &quot;not hungry&quot;,</a>
<a name="ln1510">    &quot;full&quot;,</a>
<a name="ln1511">    &quot;very full&quot;,</a>
<a name="ln1512">    &quot;completely stuffed&quot;,</a>
<a name="ln1513">};</a>
<a name="ln1514">COMPILE_CHECK(ARRAYSZ(hunger_names) == HS_ENGORGED + 1);</a>
<a name="ln1515"> </a>
<a name="ln1516">const char *hunger_level()</a>
<a name="ln1517">{</a>
<a name="ln1518">    ASSERT(you.hunger_state &lt;= HS_ENGORGED);</a>
<a name="ln1519"> </a>
<a name="ln1520">    if (you.species == SP_VAMPIRE)</a>
<a name="ln1521">        return you.vampire_alive ? &quot;alive&quot; : &quot;bloodless&quot;;</a>
<a name="ln1522">    return hunger_names[you.hunger_state];</a>
<a name="ln1523">}</a>
<a name="ln1524"> </a>
<a name="ln1525">string morgue_directory()</a>
<a name="ln1526">{</a>
<a name="ln1527">    string dir = (!Options.morgue_dir.empty() ? Options.morgue_dir :</a>
<a name="ln1528">                  !SysEnv.crawl_dir.empty()   ? SysEnv.crawl_dir</a>
<a name="ln1529">                                              : &quot;&quot;);</a>
<a name="ln1530"> </a>
<a name="ln1531">    if (!dir.empty() &amp;&amp; dir[dir.length() - 1] != FILE_SEPARATOR)</a>
<a name="ln1532">        dir += FILE_SEPARATOR;</a>
<a name="ln1533"> </a>
<a name="ln1534">    return dir;</a>
<a name="ln1535">}</a>
<a name="ln1536"> </a>
<a name="ln1537">void dump_map(FILE *fp, bool debug, bool dist)</a>
<a name="ln1538">{</a>
<a name="ln1539">    if (debug)</a>
<a name="ln1540">    {</a>
<a name="ln1541">#ifdef COLOURED_DUMPS</a>
<a name="ln1542">        // Usage: make EXTERNAL_DEFINES=&quot;-DCOLOURED_DUMPS&quot;</a>
<a name="ln1543">        // To read the dumps, cat them or use less -R.</a>
<a name="ln1544">        // ansi2html can be used to make html.</a>
<a name="ln1545"> </a>
<a name="ln1546">        fprintf(fp, &quot;Vaults used:\n&quot;);</a>
<a name="ln1547">        for (size_t i = 0; i &lt; env.level_vaults.size(); ++i)</a>
<a name="ln1548">        {</a>
<a name="ln1549">            const vault_placement &amp;vp(*env.level_vaults[i]);</a>
<a name="ln1550">            fprintf(fp, &quot;  \e[3%dm%s\e[0m at (%d,%d) size (%d,%d)\n&quot;,</a>
<a name="ln1551">                    6 - (int)i % 6, vp.map.name.c_str(),</a>
<a name="ln1552">                    vp.pos.x, vp.pos.y, vp.size.x, vp.size.y);</a>
<a name="ln1553">        }</a>
<a name="ln1554">        fprintf(fp, &quot;  (bright = stacked, \e[37;1mwhite\e[0m = not in level_map_ids)\n&quot;);</a>
<a name="ln1555">        size_t last_nv = 0;</a>
<a name="ln1556">        int    last_v = 0;</a>
<a name="ln1557">#endif</a>
<a name="ln1558">        // Write the whole map out without checking for mappedness. Handy</a>
<a name="ln1559">        // for debugging level-generation issues.</a>
<a name="ln1560">        for (int y = 0; y &lt; GYM; ++y)</a>
<a name="ln1561">        {</a>
<a name="ln1562">            for (int x = 0; x &lt; GXM; ++x)</a>
<a name="ln1563">            {</a>
<a name="ln1564">#ifdef COLOURED_DUMPS</a>
<a name="ln1565">                size_t nv = 0;</a>
<a name="ln1566">                for (auto &amp;vault : env.level_vaults)</a>
<a name="ln1567">                    if (vault-&gt;map.in_map(coord_def(x, y) - vault-&gt;pos))</a>
<a name="ln1568">                        nv++;</a>
<a name="ln1569"> </a>
<a name="ln1570">                int v = env.level_map_ids[x][y];</a>
<a name="ln1571">                if (v == INVALID_MAP_INDEX)</a>
<a name="ln1572">                    v = -1;</a>
<a name="ln1573">                if (nv != last_nv || v != last_v)</a>
<a name="ln1574">                {</a>
<a name="ln1575">                    if (nv)</a>
<a name="ln1576">                        fprintf(fp, &quot;\e[%d;3%dm&quot;, nv != 1, 6 - v % 6);</a>
<a name="ln1577">                    else</a>
<a name="ln1578">                        fprintf(fp, &quot;\e[0m&quot;);</a>
<a name="ln1579">                    last_nv = nv;</a>
<a name="ln1580">                    last_v = v;</a>
<a name="ln1581">                }</a>
<a name="ln1582">#endif</a>
<a name="ln1583">                if (dist &amp;&amp; you.pos() == coord_def(x, y))</a>
<a name="ln1584">                    fputc('@', fp);</a>
<a name="ln1585">                else if (testbits(env.pgrid[x][y], FPROP_HIGHLIGHT))</a>
<a name="ln1586">                    fputc('?', fp);</a>
<a name="ln1587">                else if (dist &amp;&amp; grd[x][y] == DNGN_FLOOR</a>
<a name="ln1588">                         &amp;&amp; travel_point_distance[x][y] &gt; 0</a>
<a name="ln1589">                         &amp;&amp; travel_point_distance[x][y] &lt; 10)</a>
<a name="ln1590">                {</a>
<a name="ln1591">                    fputc('0' + travel_point_distance[x][y], fp);</a>
<a name="ln1592">                }</a>
<a name="ln1593">                else if (grd[x][y] &gt;= NUM_FEATURES)</a>
<a name="ln1594">                    fputc('!', fp);</a>
<a name="ln1595">                else</a>
<a name="ln1596">                {</a>
<a name="ln1597">                    fputs(OUTS(stringize_glyph(</a>
<a name="ln1598">                               get_feature_def(grd[x][y]).symbol())), fp);</a>
<a name="ln1599">                }</a>
<a name="ln1600">            }</a>
<a name="ln1601">            fputc('\n', fp);</a>
<a name="ln1602">#ifdef COLOURED_DUMPS</a>
<a name="ln1603">            last_v = 0; // force a colour code, because of less+libvte</a>
<a name="ln1604">#endif</a>
<a name="ln1605">        }</a>
<a name="ln1606">#ifdef COLOURED_DUMPS</a>
<a name="ln1607">        fprintf(fp, &quot;\e[0m&quot;);</a>
<a name="ln1608">#endif</a>
<a name="ln1609">    }</a>
<a name="ln1610">    else</a>
<a name="ln1611">    {</a>
<a name="ln1612">        int min_x = GXM-1, max_x = 0, min_y = GYM-1, max_y = 0;</a>
<a name="ln1613"> </a>
<a name="ln1614">        for (int i = X_BOUND_1; i &lt;= X_BOUND_2; i++)</a>
<a name="ln1615">            for (int j = Y_BOUND_1; j &lt;= Y_BOUND_2; j++)</a>
<a name="ln1616">                if (env.map_knowledge[i][j].known())</a>
<a name="ln1617">                {</a>
<a name="ln1618">                    if (i &gt; max_x) max_x = i;</a>
<a name="ln1619">                    if (i &lt; min_x) min_x = i;</a>
<a name="ln1620">                    if (j &gt; max_y) max_y = j;</a>
<a name="ln1621">                    if (j &lt; min_y) min_y = j;</a>
<a name="ln1622">                }</a>
<a name="ln1623"> </a>
<a name="ln1624">        for (int y = min_y; y &lt;= max_y; ++y)</a>
<a name="ln1625">        {</a>
<a name="ln1626">            for (int x = min_x; x &lt;= max_x; ++x)</a>
<a name="ln1627">            {</a>
<a name="ln1628">                fputs(OUTS(stringize_glyph(</a>
<a name="ln1629">                           get_cell_glyph(coord_def(x, y)).ch)), fp);</a>
<a name="ln1630">            }</a>
<a name="ln1631"> </a>
<a name="ln1632">            fputc('\n', fp);</a>
<a name="ln1633">        }</a>
<a name="ln1634">    }</a>
<a name="ln1635">}</a>
<a name="ln1636"> </a>
<a name="ln1637">void dump_map(const char* fname, bool debug, bool dist)</a>
<a name="ln1638">{</a>
<a name="ln1639">    FILE* fp = fopen_replace(fname);</a>
<a name="ln1640">    if (!fp)</a>
<a name="ln1641">        return;</a>
<a name="ln1642"> </a>
<a name="ln1643">    dump_map(fp, debug, dist);</a>
<a name="ln1644"> </a>
<a name="ln1645">    fclose(fp);</a>
<a name="ln1646">}</a>
<a name="ln1647"> </a>
<a name="ln1648">static bool _write_dump(const string &amp;fname, const dump_params &amp;par, bool quiet)</a>
<a name="ln1649">{</a>
<a name="ln1650">    bool succeeded = false;</a>
<a name="ln1651"> </a>
<a name="ln1652">    string file_name = morgue_directory();</a>
<a name="ln1653"> </a>
<a name="ln1654">    file_name += strip_filename_unsafe_chars(fname);</a>
<a name="ln1655"> </a>
<a name="ln1656">    StashTrack.update_corpses();</a>
<a name="ln1657"> </a>
<a name="ln1658">    string stash_file_name;</a>
<a name="ln1659">    stash_file_name = file_name;</a>
<a name="ln1660">    stash_file_name += &quot;.lst&quot;;</a>
<a name="ln1661">    StashTrack.dump(stash_file_name.c_str(), par.full_id);</a>
<a name="ln1662"> </a>
<a name="ln1663">    string map_file_name = file_name + &quot;.map&quot;;</a>
<a name="ln1664">    dump_map(map_file_name.c_str());</a>
<a name="ln1665"> </a>
<a name="ln1666">    file_name += &quot;.txt&quot;;</a>
<a name="ln1667">    FILE *handle = fopen_replace(file_name.c_str());</a>
<a name="ln1668"> </a>
<a name="ln1669">    dprf(&quot;File name: %s&quot;, file_name.c_str());</a>
<a name="ln1670"> </a>
<a name="ln1671">    if (handle != nullptr)</a>
<a name="ln1672">    {</a>
<a name="ln1673">        fputs(OUTS(par.text), handle);</a>
<a name="ln1674">        fclose(handle);</a>
<a name="ln1675">        succeeded = true;</a>
<a name="ln1676">        if (!quiet)</a>
<a name="ln1677">#ifdef DGAMELAUNCH</a>
<a name="ln1678">            mpr(&quot;Char dumped successfully.&quot;);</a>
<a name="ln1679">#else</a>
<a name="ln1680">            mprf(&quot;Char dumped to '%s'.&quot;, file_name.c_str());</a>
<a name="ln1681">#endif</a>
<a name="ln1682">    }</a>
<a name="ln1683">    else</a>
<a name="ln1684">        mprf(MSGCH_ERROR, &quot;Error opening file '%s'&quot;, file_name.c_str());</a>
<a name="ln1685"> </a>
<a name="ln1686">    return succeeded;</a>
<a name="ln1687">}</a>
<a name="ln1688"> </a>
<a name="ln1689">void display_notes()</a>
<a name="ln1690">{</a>
<a name="ln1691">    formatted_scroller scr(FS_START_AT_END | FS_PREWRAPPED_TEXT);</a>
<a name="ln1692">    scr.set_more();</a>
<a name="ln1693">    scr.set_tag(&quot;notes&quot;);</a>
<a name="ln1694">    scr.add_raw_text(&quot;Turn   | Place    | Note\n&quot;);</a>
<a name="ln1695">    for (const Note &amp;note : note_list)</a>
<a name="ln1696">    {</a>
<a name="ln1697">        if (note.hidden())</a>
<a name="ln1698">            continue;</a>
<a name="ln1699">        string prefix = note.describe(true, true, false);</a>
<a name="ln1700">        string suffix = note.describe(false, false, true);</a>
<a name="ln1701">        if (suffix.empty())</a>
<a name="ln1702">            continue;</a>
<a name="ln1703">        int spaceleft = 80 - prefix.length() - 1; // Use 100 cols</a>
<a name="ln1704">        if (spaceleft &lt;= 0)</a>
<a name="ln1705">            return;</a>
<a name="ln1706"> </a>
<a name="ln1707">        linebreak_string(suffix, spaceleft);</a>
<a name="ln1708">        vector&lt;string&gt; parts = split_string(&quot;\n&quot;, suffix);</a>
<a name="ln1709">        if (parts.empty()) // Disregard pure-whitespace notes.</a>
<a name="ln1710">            continue;</a>
<a name="ln1711"> </a>
<a name="ln1712">        scr.add_raw_text(prefix + parts[0] + &quot;\n&quot;);</a>
<a name="ln1713">        for (unsigned int j = 1; j &lt; parts.size(); ++j)</a>
<a name="ln1714">            scr.add_raw_text(string(prefix.length()-2, ' ') + string(&quot;| &quot;) + parts[j] + &quot;\n&quot;);</a>
<a name="ln1715">    }</a>
<a name="ln1716">    scr.show();</a>
<a name="ln1717">}</a>
<a name="ln1718"> </a>
<a name="ln1719">void display_char_dump()</a>
<a name="ln1720">{</a>
<a name="ln1721">    formatted_scroller scr(FS_PREWRAPPED_TEXT);</a>
<a name="ln1722">    scr.add_raw_text(_get_dump().text, false);</a>
<a name="ln1723">    scr.set_more();</a>
<a name="ln1724">    scr.set_tag(&quot;dump&quot;);</a>
<a name="ln1725">    scr.show();</a>
<a name="ln1726">}</a>
<a name="ln1727"> </a>
<a name="ln1728">#ifdef DGL_WHEREIS</a>
<a name="ln1729">///////////////////////////////////////////////////////////////////////////</a>
<a name="ln1730">// whereis player</a>
<a name="ln1731">void whereis_record(const char *status)</a>
<a name="ln1732">{</a>
<a name="ln1733">    const string file_name = morgue_directory()</a>
<a name="ln1734">                             + strip_filename_unsafe_chars(you.your_name)</a>
<a name="ln1735">                             + string(&quot;.where&quot;);</a>
<a name="ln1736"> </a>
<a name="ln1737">    if (FILE *handle = fopen_replace(file_name.c_str()))</a>
<a name="ln1738">    {</a>
<a name="ln1739">        // no need to bother with supporting ancient charsets for DGL</a>
<a name="ln1740">        fprintf(handle, &quot;%s:status=%s\n&quot;,</a>
<a name="ln1741">                xlog_status_line().c_str(),</a>
<a name="ln1742">                status? status : &quot;&quot;);</a>
<a name="ln1743">        fclose(handle);</a>
<a name="ln1744">    }</a>
<a name="ln1745">}</a>
<a name="ln1746">#endif</a>
<a name="ln1747"> </a>
<a name="ln1748">///////////////////////////////////////////////////////////////////////////////</a>
<a name="ln1749">// Turn timestamps</a>
<a name="ln1750">//</a>
<a name="ln1751">// For DGL installs, write a timestamp at regular intervals into a file in</a>
<a name="ln1752">// the morgue directory. The timestamp file is named</a>
<a name="ln1753">// &quot;timestamp-&lt;player&gt;-&lt;starttime&gt;.ts&quot;. All timestamps are standard Unix</a>
<a name="ln1754">// time_t, but currently only the low 4 bytes are saved even on systems</a>
<a name="ln1755">// with 64-bit time_t.</a>
<a name="ln1756">//</a>
<a name="ln1757">// Timestamp files are append only, and Crawl will check and handle cases</a>
<a name="ln1758">// where a previous Crawl process crashed at a higher turn count on the same</a>
<a name="ln1759">// game.</a>
<a name="ln1760">//</a>
<a name="ln1761">// Having timestamps associated with the game allows for much easier seeking</a>
<a name="ln1762">// within Crawl ttyrecs by external tools such as FooTV.</a>
<a name="ln1763"> </a>
<a name="ln1764">#ifdef DGL_TURN_TIMESTAMPS</a>
<a name="ln1765"> </a>
<a name="ln1766">#include &quot;syscalls.h&quot;</a>
<a name="ln1767">#include &lt;sys/stat.h&gt;</a>
<a name="ln1768"> </a>
<a name="ln1769">// File-format version for timestamp files. Crawl will never append to a</a>
<a name="ln1770">const uint32_t DGL_TIMESTAMP_VERSION = 1;</a>
<a name="ln1771">const int VERSION_SIZE = sizeof(DGL_TIMESTAMP_VERSION);</a>
<a name="ln1772">const int TIMESTAMP_SIZE = sizeof(uint32_t);</a>
<a name="ln1773"> </a>
<a name="ln1774">// Returns the name of the timestamp file based on the morgue_dir,</a>
<a name="ln1775">// character name and the game start time.</a>
<a name="ln1776">static string _dgl_timestamp_filename()</a>
<a name="ln1777">{</a>
<a name="ln1778">    const string filename = &quot;timestamp-&quot; + you.your_name + &quot;-&quot;</a>
<a name="ln1779">                            + make_file_time(you.birth_time);</a>
<a name="ln1780">    return morgue_directory() + strip_filename_unsafe_chars(filename) + &quot;.ts&quot;;</a>
<a name="ln1781">}</a>
<a name="ln1782"> </a>
<a name="ln1783">// Returns true if the given file exists and is not a timestamp file</a>
<a name="ln1784">// of a known version or truncated timestamp file.</a>
<a name="ln1785">static bool _dgl_unknown_timestamp_file(const string &amp;filename)</a>
<a name="ln1786">{</a>
<a name="ln1787">    if (FILE *inh = fopen_u(filename.c_str(), &quot;rb&quot;))</a>
<a name="ln1788">    {</a>
<a name="ln1789">        reader r(inh);</a>
<a name="ln1790">        r.set_safe_read(true);</a>
<a name="ln1791">        try</a>
<a name="ln1792">        {</a>
<a name="ln1793">            const uint32_t file_version = unmarshallInt(r);</a>
<a name="ln1794">            fclose(inh);</a>
<a name="ln1795">            return file_version != DGL_TIMESTAMP_VERSION;</a>
<a name="ln1796">        }</a>
<a name="ln1797">        catch (short_read_exception &amp;e)</a>
<a name="ln1798">        {</a>
<a name="ln1799">            // Empty file, or &lt;4 bytes: remove file and use it.</a>
<a name="ln1800">            fclose(inh);</a>
<a name="ln1801">            // True (don't use) if we couldn't remove it, false if we could.</a>
<a name="ln1802">            return unlink_u(filename.c_str()) != 0;</a>
<a name="ln1803">        }</a>
<a name="ln1804">    }</a>
<a name="ln1805">    return false;</a>
<a name="ln1806">}</a>
<a name="ln1807"> </a>
<a name="ln1808">// Returns a filehandle to use to write turn timestamps, nullptr if</a>
<a name="ln1809">// timestamps should not be written.</a>
<a name="ln1810">static FILE *_dgl_timestamp_filehandle()</a>
<a name="ln1811">{</a>
<a name="ln1812">    static FILE *timestamp_file = nullptr;</a>
<a name="ln1813">    static bool opened_file = false;</a>
<a name="ln1814">    if (!opened_file)</a>
<a name="ln1815">    {</a>
<a name="ln1816">        opened_file = true;</a>
<a name="ln1817"> </a>
<a name="ln1818">        const string filename = _dgl_timestamp_filename();</a>
<a name="ln1819">        // First check if there's already a timestamp file. If it exists</a>
<a name="ln1820">        // but has a different version, we cannot safely modify it, so bail.</a>
<a name="ln1821">        if (!_dgl_unknown_timestamp_file(filename))</a>
<a name="ln1822">            timestamp_file = fopen_u(filename.c_str(), &quot;ab&quot;);</a>
<a name="ln1823">    }</a>
<a name="ln1824">    return timestamp_file;</a>
<a name="ln1825">}</a>
<a name="ln1826"> </a>
<a name="ln1827">// Records a timestamp in the .ts file at the given offset. If no timestamp</a>
<a name="ln1828">// file exists, a new file will be created.</a>
<a name="ln1829">static void _dgl_record_timestamp(unsigned long file_offset, time_t time)</a>
<a name="ln1830">{</a>
<a name="ln1831">    static bool timestamp_first_write = true;</a>
<a name="ln1832">    if (FILE *ftimestamp = _dgl_timestamp_filehandle())</a>
<a name="ln1833">    {</a>
<a name="ln1834">        writer w(_dgl_timestamp_filename(), ftimestamp, true);</a>
<a name="ln1835">        if (timestamp_first_write)</a>
<a name="ln1836">        {</a>
<a name="ln1837">            unsigned long ts_size = file_size(ftimestamp);</a>
<a name="ln1838">            if (!ts_size)</a>
<a name="ln1839">            {</a>
<a name="ln1840">                marshallInt(w, DGL_TIMESTAMP_VERSION);</a>
<a name="ln1841">                ts_size += sizeof(DGL_TIMESTAMP_VERSION);</a>
<a name="ln1842">            }</a>
<a name="ln1843"> </a>
<a name="ln1844">            // It's possible that the file we want to write is already</a>
<a name="ln1845">            // larger than the offset we expect if the game previously</a>
<a name="ln1846">            // crashed. When the game crashes, turn count is</a>
<a name="ln1847">            // effectively rewound to the point of the last save. In</a>
<a name="ln1848">            // such cases, we should not add timestamps until we reach</a>
<a name="ln1849">            // the correct turn count again.</a>
<a name="ln1850">            if (ts_size &amp;&amp; ts_size &gt; file_offset)</a>
<a name="ln1851">                return;</a>
<a name="ln1852"> </a>
<a name="ln1853">            if (file_offset &gt; ts_size)</a>
<a name="ln1854">            {</a>
<a name="ln1855">                const int backlog =</a>
<a name="ln1856">                    (file_offset - ts_size) / TIMESTAMP_SIZE;</a>
<a name="ln1857">                for (int i = 0; i &lt; backlog; ++i)</a>
<a name="ln1858">                    marshallInt(w, 0);</a>
<a name="ln1859">            }</a>
<a name="ln1860"> </a>
<a name="ln1861">            timestamp_first_write = false;</a>
<a name="ln1862">        }</a>
<a name="ln1863">        fseek(ftimestamp, 0, SEEK_END);</a>
<a name="ln1864">        // [ds] FIXME: Eventually switch to 8 byte timestamps.</a>
<a name="ln1865">        marshallInt(w, static_cast&lt;uint32_t&gt;(time));</a>
<a name="ln1866">        fflush(ftimestamp);</a>
<a name="ln1867">    }</a>
<a name="ln1868">}</a>
<a name="ln1869"> </a>
<a name="ln1870">// Record timestamps every so many turns:</a>
<a name="ln1871">const int TIMESTAMP_TURN_INTERVAL = 100;</a>
<a name="ln1872">// Stop recording timestamps after this turncount.</a>
<a name="ln1873">const int TIMESTAMP_TURN_MAX = 500000;</a>
<a name="ln1874">static void _dgl_record_timestamp(int turn)</a>
<a name="ln1875">{</a>
<a name="ln1876">    if (turn &amp;&amp; turn &lt; TIMESTAMP_TURN_MAX &amp;&amp; !(turn % TIMESTAMP_TURN_INTERVAL))</a>
<a name="ln1877">    {</a>
<a name="ln1878">        const time_t now = time(nullptr);</a>
<a name="ln1879">        const unsigned long offset =</a>
<a name="ln1880">            (VERSION_SIZE +</a>
<a name="ln1881">             (turn / TIMESTAMP_TURN_INTERVAL - 1) * TIMESTAMP_SIZE);</a>
<a name="ln1882">        _dgl_record_timestamp(offset, now);</a>
<a name="ln1883">    }</a>
<a name="ln1884">}</a>
<a name="ln1885"> </a>
<a name="ln1886">#endif</a>
<a name="ln1887"> </a>
<a name="ln1888">// Records a timestamp for the current player turn if appropriate.</a>
<a name="ln1889">void record_turn_timestamp()</a>
<a name="ln1890">{</a>
<a name="ln1891">#ifdef DGL_TURN_TIMESTAMPS</a>
<a name="ln1892">    if (crawl_state.need_save)</a>
<a name="ln1893">        _dgl_record_timestamp(you.num_turns);</a>
<a name="ln1894">#endif</a>
<a name="ln1895">}</a>

</code></pre>
<div class="balloon" rel="1170"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v610/" target="_blank">V610</a> Undefined behavior. Check the shift operator '<<'. The left operand is negative ('auxtype' = [-32768..32767]).</p></div>

<link rel="stylesheet" href="highlight.css">
<script src="highlight.pack.js"></script>
<script src="highlightjs-line-numbers.js"></script>
<script>hljs.initHighlightingOnLoad();</script>
<script>hljs.initLineNumbersOnLoad();</script>
<script>
  $(document).ready(function() {
      $('.balloon').each(function () {
          var bl = $(this);
          var line = bl.attr('rel');
          var text = $('a[name="ln'+line+'"]').text();

          var space_count = 0;
          for(var i = 0; i<text.length; i++){
              var char = text[i];
              if((char !== ' ')&&(char !== '\t'))break;
              if(char === '\t')space_count++;
              space_count++;
          }

          bl.css('margin-left', space_count*8);
          $('a[name="ln'+line+'"]').after(bl);
      });

      window.location = window.location;
  });
</script>
</body>
</html>
