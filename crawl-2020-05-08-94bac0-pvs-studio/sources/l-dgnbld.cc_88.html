
<html>
<head>

  <meta http-equiv="Content-Type" content="text/html; charset=US-ASCII" />
  <title>l-dgnbld.cc</title>

  <link rel="stylesheet" href="../style.css"/>
  <script src="../jquery-3.2.1.min.js"></script>
</head>
<body>

<pre><code class = "cpp">
<a name="ln1">/***</a>
<a name="ln2"> * @module dgn</a>
<a name="ln3"> */</a>
<a name="ln4">#include &quot;AppHdr.h&quot;</a>
<a name="ln5"> </a>
<a name="ln6">#include &quot;l-libs.h&quot;</a>
<a name="ln7"> </a>
<a name="ln8">#include &lt;cmath&gt;</a>
<a name="ln9">#include &lt;vector&gt;</a>
<a name="ln10"> </a>
<a name="ln11">#include &quot;cluautil.h&quot;</a>
<a name="ln12">#include &quot;coordit.h&quot;</a>
<a name="ln13">#include &quot;dgn-delve.h&quot;</a>
<a name="ln14">#include &quot;dgn-irregular-box.h&quot;</a>
<a name="ln15">#include &quot;dgn-layouts.h&quot;</a>
<a name="ln16">#include &quot;dgn-shoals.h&quot;</a>
<a name="ln17">#include &quot;dgn-swamp.h&quot;</a>
<a name="ln18">#include &quot;dungeon.h&quot;</a>
<a name="ln19"> </a>
<a name="ln20">static const char *exit_glyphs = &quot;{}()[]&lt;&gt;@&quot;;</a>
<a name="ln21"> </a>
<a name="ln22">// Return the integer stored in the table (on the stack) with the key name.</a>
<a name="ln23">// If the key doesn't exist or the value is the wrong type, return defval.</a>
<a name="ln24">static int _table_int(lua_State *ls, int idx, const char *name, int defval)</a>
<a name="ln25">{</a>
<a name="ln26">    if (!lua_istable(ls, idx))</a>
<a name="ln27">        return defval;</a>
<a name="ln28">    lua_pushstring(ls, name);</a>
<a name="ln29">    lua_gettable(ls, idx &lt; 0 ? idx - 1 : idx);</a>
<a name="ln30">    bool nil = lua_isnil(ls, idx);</a>
<a name="ln31">    bool valid = lua_isnumber(ls, idx);</a>
<a name="ln32">    if (!nil &amp;&amp; !valid)</a>
<a name="ln33">        luaL_error(ls, &quot;'%s' in table, but not an int.&quot;, name);</a>
<a name="ln34">    int ret = (!nil &amp;&amp; valid ? luaL_safe_checkint(ls, idx) : defval);</a>
<a name="ln35">    lua_pop(ls, 1);</a>
<a name="ln36">    return ret;</a>
<a name="ln37">}</a>
<a name="ln38"> </a>
<a name="ln39">// Return the character stored in the table (on the stack) with the key name.</a>
<a name="ln40">// If the key doesn't exist or the value is the wrong type, return defval.</a>
<a name="ln41">static char _table_char(lua_State *ls, int idx, const char *name, char defval)</a>
<a name="ln42">{</a>
<a name="ln43">    if (!lua_istable(ls, idx))</a>
<a name="ln44">        return defval;</a>
<a name="ln45">    lua_pushstring(ls, name);</a>
<a name="ln46">    lua_gettable(ls, idx &lt; 0 ? idx - 1 : idx);</a>
<a name="ln47">    bool nil = lua_isnil(ls, idx);</a>
<a name="ln48">    bool valid = lua_isstring(ls, idx);</a>
<a name="ln49">    if (!nil &amp;&amp; !valid)</a>
<a name="ln50">        luaL_error(ls, &quot;'%s' in table, but not a string.&quot;, name);</a>
<a name="ln51"> </a>
<a name="ln52">    char ret = defval;</a>
<a name="ln53">    if (!nil &amp;&amp; valid)</a>
<a name="ln54">    {</a>
<a name="ln55">        const char *str = lua_tostring(ls, idx);</a>
<a name="ln56">        if (str[0] &amp;&amp; !str[1])</a>
<a name="ln57">            ret = str[0];</a>
<a name="ln58">        else</a>
<a name="ln59">            luaL_error(ls, &quot;'%s' has more than one character.&quot;, name);</a>
<a name="ln60">    }</a>
<a name="ln61">    lua_pop(ls, 1);</a>
<a name="ln62">    return ret;</a>
<a name="ln63">}</a>
<a name="ln64"> </a>
<a name="ln65">// Return the string stored in the table (on the stack) with the key name.</a>
<a name="ln66">// If the key doesn't exist or the value is the wrong type, return defval.</a>
<a name="ln67">static const char* _table_str(lua_State *ls, int idx, const char *name, const char *defval)</a>
<a name="ln68">{</a>
<a name="ln69">    if (!lua_istable(ls, idx))</a>
<a name="ln70">        return defval;</a>
<a name="ln71">    lua_pushstring(ls, name);</a>
<a name="ln72">    lua_gettable(ls, idx &lt; 0 ? idx - 1 : idx);</a>
<a name="ln73">    bool nil = lua_isnil(ls, idx);</a>
<a name="ln74">    bool valid = lua_isstring(ls, idx);</a>
<a name="ln75">    if (!nil &amp;&amp; !valid)</a>
<a name="ln76">        luaL_error(ls, &quot;'%s' in table, but not a string.&quot;, name);</a>
<a name="ln77">    const char *ret = (!nil &amp;&amp; valid ? lua_tostring(ls, idx) : defval);</a>
<a name="ln78">    lua_pop(ls, 1);</a>
<a name="ln79">    return ret;</a>
<a name="ln80">}</a>
<a name="ln81"> </a>
<a name="ln82">// Return the boolean stored in the table (on the stack) with the key name.</a>
<a name="ln83">// If the key doesn't exist or the value is the wrong type, return defval.</a>
<a name="ln84">static bool _table_bool(lua_State *ls, int idx, const char *name, bool defval)</a>
<a name="ln85">{</a>
<a name="ln86">    if (!lua_istable(ls, idx))</a>
<a name="ln87">        return defval;</a>
<a name="ln88">    lua_pushstring(ls, name);</a>
<a name="ln89">    lua_gettable(ls, idx &lt; 0 ? idx - 1 : idx);</a>
<a name="ln90">    bool nil = lua_isnil(ls, idx);</a>
<a name="ln91">    bool valid = lua_isboolean(ls, idx);</a>
<a name="ln92">    if (!nil &amp;&amp; !valid)</a>
<a name="ln93">        luaL_error(ls, &quot;'%s' in table, but not a bool.&quot;, name);</a>
<a name="ln94">    bool ret = (!nil &amp;&amp; valid ? lua_toboolean(ls, idx) : defval);</a>
<a name="ln95">    lua_pop(ls, 1);</a>
<a name="ln96">    return ret;</a>
<a name="ln97">}</a>
<a name="ln98"> </a>
<a name="ln99">// These macros all assume the table is on the top of the lua stack.</a>
<a name="ln100">#define TABLE_INT(ls, val, def) int val = _table_int(ls, -1, #val, def);</a>
<a name="ln101">#define TABLE_CHAR(ls, val, def) char val = _table_char(ls, -1, #val, def);</a>
<a name="ln102">#define TABLE_STR(ls, val, def) const char *val = _table_str(ls, -1, #val, def);</a>
<a name="ln103">#define TABLE_BOOL(ls, val, def) bool val = _table_bool(ls, -1, #val, def);</a>
<a name="ln104"> </a>
<a name="ln105">#define ARG_INT(ls, num, val, def) int val = lua_isnone(ls, num) ? \</a>
<a name="ln106">                                             def : luaL_safe_tointeger(ls, num)</a>
<a name="ln107"> </a>
<a name="ln108">// Read a set of box coords (x1, y1, x2, y2) from the table.</a>
<a name="ln109">// Return true if coords are valid.</a>
<a name="ln110">static bool _coords(lua_State *ls, map_lines &amp;lines,</a>
<a name="ln111">                    int &amp;x1, int &amp;y1, int &amp;x2, int &amp;y2, int border = 0)</a>
<a name="ln112">{</a>
<a name="ln113">    const int idx = -1;</a>
<a name="ln114">    x1 = _table_int(ls, idx, &quot;x1&quot;, 0);</a>
<a name="ln115">    y1 = _table_int(ls, idx, &quot;y1&quot;, 0);</a>
<a name="ln116">    x2 = _table_int(ls, idx, &quot;x2&quot;, lines.width() - 1);</a>
<a name="ln117">    y2 = _table_int(ls, idx, &quot;y2&quot;, lines.height() - 1);</a>
<a name="ln118"> </a>
<a name="ln119">    if (x2 &lt; x1)</a>
<a name="ln120">        swap(x1, x2);</a>
<a name="ln121">    if (y2 &lt; y1)</a>
<a name="ln122">        swap(y1, y2);</a>
<a name="ln123"> </a>
<a name="ln124">    return x1 + border &lt;= x2 - border &amp;&amp; y1 + border &lt;= y2 - border;</a>
<a name="ln125">}</a>
<a name="ln126"> </a>
<a name="ln127">// Check if a given coordiante is valid for lines.</a>
<a name="ln128">static bool _valid_coord(lua_State *ls, map_lines &amp;lines, int x, int y, bool error = true)</a>
<a name="ln129">{</a>
<a name="ln130">    if (x &lt; 0 || x &gt;= lines.width())</a>
<a name="ln131">    {</a>
<a name="ln132">        if (error)</a>
<a name="ln133">            luaL_error(ls, &quot;Invalid x coordinate: %d&quot;, x);</a>
<a name="ln134">        return false;</a>
<a name="ln135">    }</a>
<a name="ln136"> </a>
<a name="ln137">    if (y &lt; 0 || y &gt;= lines.height())</a>
<a name="ln138">    {</a>
<a name="ln139">        if (error)</a>
<a name="ln140">            luaL_error(ls, &quot;Invalid y coordinate: %d&quot;, y);</a>
<a name="ln141">        return false;</a>
<a name="ln142">    }</a>
<a name="ln143"> </a>
<a name="ln144">    return true;</a>
<a name="ln145">}</a>
<a name="ln146"> </a>
<a name="ln147">// Does what fill_area did, but here, so that it can be used through</a>
<a name="ln148">// multiple functions (including make_box).</a>
<a name="ln149">static int _fill_area(lua_State */*ls*/, map_lines &amp;lines, int x1, int y1, int x2, int y2, char fill)</a>
<a name="ln150">{</a>
<a name="ln151">    for (int y = y1; y &lt;= y2; ++y)</a>
<a name="ln152">        for (int x = x1; x &lt;= x2; ++x)</a>
<a name="ln153">            lines(x, y) = fill;</a>
<a name="ln154"> </a>
<a name="ln155">    return 0;</a>
<a name="ln156">}</a>
<a name="ln157"> </a>
<a name="ln158">static void _border_area(map_lines &amp;lines, int x1, int y1, int x2, int y2, char border)</a>
<a name="ln159">{</a>
<a name="ln160">    for (int x = x1 + 1; x &lt; x2; ++x)</a>
<a name="ln161">        lines(x, y1) = border, lines(x, y2) = border;</a>
<a name="ln162">    for (int y = y1; y &lt;= y2; ++y)</a>
<a name="ln163">        lines(x1, y) = border, lines(x2, y) = border;</a>
<a name="ln164">}</a>
<a name="ln165"> </a>
<a name="ln166">// Does what count_passable_neighbors does, but in C++ form.</a>
<a name="ln167">static int _count_passable_neighbors(lua_State *ls, map_lines &amp;lines, int x,</a>
<a name="ln168">                                     int y, const char *passable = traversable_glyphs)</a>
<a name="ln169">{</a>
<a name="ln170">    coord_def tl(x, y);</a>
<a name="ln171">    int count = 0;</a>
<a name="ln172"> </a>
<a name="ln173">    for (adjacent_iterator ai(tl); ai; ++ai)</a>
<a name="ln174">    {</a>
<a name="ln175">        if (_valid_coord(ls, lines, ai-&gt;x, ai-&gt;y, false))</a>
<a name="ln176">            if (strchr(passable, lines(*ai)))</a>
<a name="ln177">                count++;</a>
<a name="ln178">    }</a>
<a name="ln179"> </a>
<a name="ln180">    return count;</a>
<a name="ln181">}</a>
<a name="ln182"> </a>
<a name="ln183">static vector&lt;coord_def&gt; _get_pool_seed_positions(</a>
<a name="ln184">                                                vector&lt;vector&lt;int&gt; &gt; pool_index,</a>
<a name="ln185">                                                int pool_size,</a>
<a name="ln186">                                                int min_separation)</a>
<a name="ln187">{</a>
<a name="ln188">    const int NO_POOL   = 999997; // must match dgn_add_pools</a>
<a name="ln189"> </a>
<a name="ln190">    if (pool_size &lt; 1)</a>
<a name="ln191">        pool_size = 1;</a>
<a name="ln192"> </a>
<a name="ln193">    // 1. Find all floor positions</a>
<a name="ln194"> </a>
<a name="ln195">    vector&lt;coord_def&gt; floor_positions;</a>
<a name="ln196"> </a>
<a name="ln197">    for (unsigned int x = 0; x &lt; pool_index.size(); x++)</a>
<a name="ln198">        for (unsigned int y = 0; y &lt; pool_index[x].size(); y++)</a>
<a name="ln199">        {</a>
<a name="ln200">            if (pool_index[x][y] == NO_POOL)</a>
<a name="ln201">                floor_positions.emplace_back(x, y);</a>
<a name="ln202">        }</a>
<a name="ln203"> </a>
<a name="ln204">    // 2. Choose the pool seed positions</a>
<a name="ln205"> </a>
<a name="ln206">    int min_separation_squared = min_separation * min_separation;</a>
<a name="ln207">    int pool_count_goal = (floor_positions.size() + random2(pool_size))</a>
<a name="ln208">                          / pool_size;</a>
<a name="ln209"> </a>
<a name="ln210">    vector&lt;coord_def&gt; seeds;</a>
<a name="ln211"> </a>
<a name="ln212">    for (int i = 0; i &lt; pool_count_goal; i++)</a>
<a name="ln213">    {</a>
<a name="ln214">        if (floor_positions.empty())</a>
<a name="ln215">        {</a>
<a name="ln216">            // give up if no more positions</a>
<a name="ln217">            break;</a>
<a name="ln218">        }</a>
<a name="ln219"> </a>
<a name="ln220">        // choose a random position</a>
<a name="ln221">        int chosen_index = random2(floor_positions.size());</a>
<a name="ln222">        coord_def chosen_coord = floor_positions[chosen_index];</a>
<a name="ln223">        floor_positions[chosen_index] = floor_positions.back();</a>
<a name="ln224">        floor_positions.pop_back();</a>
<a name="ln225"> </a>
<a name="ln226">        // check if it is too close to another seed</a>
<a name="ln227">        bool too_close = false;</a>
<a name="ln228">        for (coord_def seed : seeds)</a>
<a name="ln229">        {</a>
<a name="ln230">            int diff_x = chosen_coord.x - seed.x;</a>
<a name="ln231">            int diff_y = chosen_coord.y - seed.y;</a>
<a name="ln232">            int distance_squared = diff_x * diff_x + diff_y * diff_y;</a>
<a name="ln233"> </a>
<a name="ln234">            if (distance_squared &lt; min_separation_squared)</a>
<a name="ln235">            {</a>
<a name="ln236">                too_close = true;</a>
<a name="ln237">                break;</a>
<a name="ln238">            }</a>
<a name="ln239">        }</a>
<a name="ln240"> </a>
<a name="ln241">        // if not too close, add it to the list</a>
<a name="ln242">        if (!too_close)</a>
<a name="ln243">            seeds.push_back(chosen_coord);</a>
<a name="ln244">    }</a>
<a name="ln245"> </a>
<a name="ln246">    // 3. Return the pool seeds</a>
<a name="ln247"> </a>
<a name="ln248">    return seeds;</a>
<a name="ln249">}</a>
<a name="ln250"> </a>
<a name="ln251">// This function assumes the table is on the top of the lua stack.</a>
<a name="ln252">static vector&lt;char&gt; _pool_fill_glyphs_from_table(lua_State *ls,</a>
<a name="ln253">                                                 const char *name)</a>
<a name="ln254">{</a>
<a name="ln255">    // We will go through the table and put each possible pool</a>
<a name="ln256">    //  fill glyph in a vector once for each weight. This will</a>
<a name="ln257">    //  make it easy to select random ones with the correct</a>
<a name="ln258">    //  distribution when we need to.</a>
<a name="ln259">    vector&lt;char&gt; fill_glyphs;</a>
<a name="ln260"> </a>
<a name="ln261">    lua_pushstring(ls, name);</a>
<a name="ln262">    lua_gettable(ls, -2);</a>
<a name="ln263">    if (!lua_isnil(ls, -1) &amp;&amp; lua_istable(ls, -1))</a>
<a name="ln264">    {</a>
<a name="ln265">        // For some reason, LUA requires us to have a dummy</a>
<a name="ln266">        //  value to remove from the stack whenever we do a</a>
<a name="ln267">        //  table lookup. Here is the first one</a>
<a name="ln268">        lua_pushnil(ls);</a>
<a name="ln269"> </a>
<a name="ln270">        // table is now at -2</a>
<a name="ln271">        while (lua_next(ls, -2) != 0)</a>
<a name="ln272">        {</a>
<a name="ln273">            // uses 'key' (at index -2) and 'value' (at index -1)</a>
<a name="ln274">            if (lua_type(ls, -2) == LUA_TSTRING</a>
<a name="ln275">                &amp;&amp; lua_type(ls, -1) == LUA_TNUMBER)</a>
<a name="ln276">            {</a>
<a name="ln277">                // we use first character of string as glyph</a>
<a name="ln278">                char glyph = (lua_tostring(ls, -2))[0];</a>
<a name="ln279"> </a>
<a name="ln280">                int count = luaL_safe_tointeger(ls, -1);</a>
<a name="ln281">                // sanity-check</a>
<a name="ln282">                if (count &gt; 10000)</a>
<a name="ln283">                    count = 10000;</a>
<a name="ln284"> </a>
<a name="ln285">                if (glyph != '\0')</a>
<a name="ln286">                {</a>
<a name="ln287">                    for (int i = 0; i &lt; count; i++)</a>
<a name="ln288">                        fill_glyphs.push_back(glyph);</a>
<a name="ln289">                }</a>
<a name="ln290">            }</a>
<a name="ln291"> </a>
<a name="ln292">            // removes 'value'; keeps 'key' for next iteration</a>
<a name="ln293">            lua_pop(ls, 1);</a>
<a name="ln294">        }</a>
<a name="ln295">    }</a>
<a name="ln296">    lua_pop(ls, 1);</a>
<a name="ln297"> </a>
<a name="ln298">    // We might have not got anything, if so, use floor</a>
<a name="ln299">    if (fill_glyphs.size() == 0)</a>
<a name="ln300">        fill_glyphs.push_back('.');</a>
<a name="ln301">    sort(fill_glyphs.begin(), fill_glyphs.end());</a>
<a name="ln302"> </a>
<a name="ln303">    return fill_glyphs;</a>
<a name="ln304">}</a>
<a name="ln305"> </a>
<a name="ln306">// These functions check for irregularities before the first</a>
<a name="ln307">//  corner along a wall in the indicated direction.</a>
<a name="ln308">static bool _wall_is_empty(map_lines &amp;lines,</a>
<a name="ln309">                           int x, int y,</a>
<a name="ln310">                           const char* wall, const char* floor,</a>
<a name="ln311">                           bool horiz = false,</a>
<a name="ln312">                           int max_check = 9999)</a>
<a name="ln313">{</a>
<a name="ln314">    coord_def normal(horiz ? 0 : 1, horiz ? 1 : 0);</a>
<a name="ln315">    for (int d = 1; d &gt;= -1; d-=2)</a>
<a name="ln316">    {</a>
<a name="ln317">        coord_def length(horiz ? d : 0, horiz ? 0 : d);</a>
<a name="ln318">        int n = 1;</a>
<a name="ln319"> </a>
<a name="ln320">        while (n &lt;= max_check)</a>
<a name="ln321">        {</a>
<a name="ln322">            coord_def pos(x + length.x*n,y + length.y*n);</a>
<a name="ln323">            if (!lines.in_bounds(coord_def(pos.x + normal.x, pos.y + normal.y))</a>
<a name="ln324">                || !strchr(floor, lines(pos.x + normal.x, pos.y + normal.y)))</a>
<a name="ln325">            {</a>
<a name="ln326">                break;</a>
<a name="ln327">            }</a>
<a name="ln328">            if (!lines.in_bounds(coord_def(pos.x - normal.x, pos.y - normal.y))</a>
<a name="ln329">                || !strchr(floor, lines(pos.x - normal.x, pos.y - normal.y)))</a>
<a name="ln330">            {</a>
<a name="ln331">                break;</a>
<a name="ln332">            }</a>
<a name="ln333"> </a>
<a name="ln334">            if (!strchr(wall, lines(pos.x, pos.y)))</a>
<a name="ln335">                return false;</a>
<a name="ln336"> </a>
<a name="ln337">            n++;</a>
<a name="ln338">        }</a>
<a name="ln339">    }</a>
<a name="ln340"> </a>
<a name="ln341">    // hit the end of the wall, so this is good</a>
<a name="ln342">    return true;</a>
<a name="ln343">}</a>
<a name="ln344"> </a>
<a name="ln345">// Only used for the join_the_dots command.</a>
<a name="ln346">struct join_the_dots_path</a>
<a name="ln347">{</a>
<a name="ln348">    vector&lt;coord_def&gt; cells;</a>
<a name="ln349">    int hit_vault_count;</a>
<a name="ln350">    int avoid_vault_count;</a>
<a name="ln351">};</a>
<a name="ln352"> </a>
<a name="ln353">/*</a>
<a name="ln354"> * Calculates a possible path joining the provided coordinates.</a>
<a name="ln355"> *</a>
<a name="ln356"> * @param from              The start of the path to be calculated.</a>
<a name="ln357"> * @param to                The end of the path to be calculated.</a>
<a name="ln358"> * @param force_straight    Whether the path must be a straight line.</a>
<a name="ln359"> * @param allow_diagonals   Whether the path can travel diagonally.</a>
<a name="ln360"> * @return A data structure containing (1) the path, &amp; (2) the number of times</a>
<a name="ln361"> * it hit or almost hit an existing vault.</a>
<a name="ln362"> */</a>
<a name="ln363">static join_the_dots_path _calculate_join_the_dots_path (const coord_def&amp; from,</a>
<a name="ln364">                                                         const coord_def&amp; to,</a>
<a name="ln365">                                                         bool force_straight,</a>
<a name="ln366">                                                         bool allow_diagonals)</a>
<a name="ln367">{</a>
<a name="ln368">    join_the_dots_path path;</a>
<a name="ln369">    path.hit_vault_count = 0;</a>
<a name="ln370">    path.avoid_vault_count = 0;</a>
<a name="ln371"> </a>
<a name="ln372">    coord_def at = from;</a>
<a name="ln373">    while (true) // loop breaks below</a>
<a name="ln374">    {</a>
<a name="ln375">        // 1. Handle this position</a>
<a name="ln376"> </a>
<a name="ln377">        path.cells.push_back(at);</a>
<a name="ln378">        if (env.level_map_mask(at) &amp; MMT_VAULT)</a>
<a name="ln379">            path.hit_vault_count++;</a>
<a name="ln380"> </a>
<a name="ln381">        // check done after recording position</a>
<a name="ln382">        if (at == to)</a>
<a name="ln383">            break;  // exit loop</a>
<a name="ln384"> </a>
<a name="ln385">        // 2. Identify good moves</a>
<a name="ln386"> </a>
<a name="ln387">        // possible next positions</a>
<a name="ln388">        int x_move = (at.x &lt; to.x) ? 1 : ((at.x &gt; to.x) ? -1 : 0);</a>
<a name="ln389">        int y_move = (at.y &lt; to.y) ? 1 : ((at.y &gt; to.y) ? -1 : 0);</a>
<a name="ln390"> </a>
<a name="ln391">        coord_def next_x  = coord_def(at.x + x_move, at.y);</a>
<a name="ln392">        coord_def next_y  = coord_def(at.x,          at.y + y_move);</a>
<a name="ln393">        coord_def next_xy = coord_def(at.x + x_move, at.y + y_move);</a>
<a name="ln394"> </a>
<a name="ln395">        // moves that get you closer</a>
<a name="ln396">        bool good_x  = (x_move != 0);</a>
<a name="ln397">        bool good_y  = (y_move != 0);</a>
<a name="ln398">        bool good_xy = (x_move != 0) &amp;&amp; (y_move != 0) &amp;&amp; allow_diagonals;</a>
<a name="ln399"> </a>
<a name="ln400">        // avoid vaults if possible</a>
<a name="ln401">        bool vault_x  = env.level_map_mask(next_x)  &amp; MMT_VAULT;</a>
<a name="ln402">        bool vault_y  = env.level_map_mask(next_y)  &amp; MMT_VAULT;</a>
<a name="ln403">        bool vault_xy = env.level_map_mask(next_xy) &amp; MMT_VAULT;</a>
<a name="ln404">        if (   (!vault_x  &amp;&amp; good_x)</a>
<a name="ln405">            || (!vault_y  &amp;&amp; good_y)</a>
<a name="ln406">            || (!vault_xy &amp;&amp; good_xy))</a>
<a name="ln407">        {</a>
<a name="ln408">            // if there is a good path that doesn't hit a vault,</a>
<a name="ln409">            //  disable the otherwise-good paths that do</a>
<a name="ln410"> </a>
<a name="ln411">            if (vault_x)  path.avoid_vault_count++;</a>
<a name="ln412">            if (vault_y)  path.avoid_vault_count++;</a>
<a name="ln413">            if (vault_xy) path.avoid_vault_count++;</a>
<a name="ln414"> </a>
<a name="ln415">            // There is no &amp;&amp;= operator because short-circuit</a>
<a name="ln416">            //  evaluation can do strange and terrible things</a>
<a name="ln417">            //  when combined with function calls.</a>
<a name="ln418">            good_x  &amp;= !vault_x;</a>
<a name="ln419">            good_y  &amp;= !vault_y;</a>
<a name="ln420">            good_xy &amp;= !vault_xy;</a>
<a name="ln421">        }</a>
<a name="ln422">        else</a>
<a name="ln423">        {</a>
<a name="ln424">            // there is no way to avoid vaults, so hitting one is OK</a>
<a name="ln425">            path.avoid_vault_count += 3;</a>
<a name="ln426">        }</a>
<a name="ln427"> </a>
<a name="ln428">        // 3. Choose the next move</a>
<a name="ln429">        if (force_straight)</a>
<a name="ln430">        {</a>
<a name="ln431">            if (good_xy)</a>
<a name="ln432">                at = next_xy;</a>
<a name="ln433">            else if (good_x)</a>
<a name="ln434">                at = next_x;</a>
<a name="ln435">            else</a>
<a name="ln436">                at = next_y;</a>
<a name="ln437">        }</a>
<a name="ln438">        else</a>
<a name="ln439">        {</a>
<a name="ln440">            // allow irregular paths</a>
<a name="ln441"> </a>
<a name="ln442">            // used for movement ratios; our goal is to make a</a>
<a name="ln443">            //  path approximately straight in any direction</a>
<a name="ln444">            int x_diff = abs(at.x - to.x);</a>
<a name="ln445">            int y_diff = abs(at.y - to.y);</a>
<a name="ln446">            int sum_diff = x_diff + y_diff;</a>
<a name="ln447">            int min_diff = (x_diff &lt; y_diff) ? x_diff : y_diff;</a>
<a name="ln448">            int max_diff = sum_diff - min_diff;</a>
<a name="ln449"> </a>
<a name="ln450">            // halve chance because a diagonal is worth 2 other moves</a>
<a name="ln451">            if (good_xy &amp;&amp; (x_chance_in_y(min_diff, max_diff * 2)</a>
<a name="ln452">                            || (!good_x &amp;&amp; !good_y)))</a>
<a name="ln453">            {</a>
<a name="ln454">                at = next_xy;</a>
<a name="ln455">            }</a>
<a name="ln456">            else if (good_x &amp;&amp; (x_chance_in_y(x_diff, sum_diff) || !good_y))</a>
<a name="ln457">                at = next_x;</a>
<a name="ln458">            else</a>
<a name="ln459">                at = next_y;</a>
<a name="ln460">        }</a>
<a name="ln461">    }</a>
<a name="ln462"> </a>
<a name="ln463">    // path is finished</a>
<a name="ln464">    return path;</a>
<a name="ln465">}</a>
<a name="ln466"> </a>
<a name="ln467"> </a>
<a name="ln468">/*</a>
<a name="ln469"> * Calculates a possible path joining the provided coordinates.</a>
<a name="ln470"> *</a>
<a name="ln471"> * @param from              The start of the path to be calculated.</a>
<a name="ln472"> * @param to                The end of the path to be calculated.</a>
<a name="ln473"> * @param force_straight    Whether the path must be a straight line.</a>
<a name="ln474"> * @param allow_diagonals   Whether the path can travel diagonally.</a>
<a name="ln475"> * @return A data structure containing (1) the path, &amp; (2) the number of times</a>
<a name="ln476"> * it hit or almost hit an existing vault.</a>
<a name="ln477"> */</a>
<a name="ln478">static void _draw_join_the_dots_path (map_lines &amp;lines,</a>
<a name="ln479">                                      const join_the_dots_path&amp; path,</a>
<a name="ln480">                                      const char* passable,</a>
<a name="ln481">                                      int thickness, char fill)</a>
<a name="ln482">{</a>
<a name="ln483">    int delta_min = -thickness / 2;</a>
<a name="ln484">    int delta_max = delta_min + thickness;</a>
<a name="ln485">    for (coord_def center : path.cells)</a>
<a name="ln486">    {</a>
<a name="ln487">        for (int dx = delta_min; dx &lt; delta_max; dx++)</a>
<a name="ln488">            for (int dy = delta_min; dy &lt; delta_max; dy++)</a>
<a name="ln489">            {</a>
<a name="ln490">                int x = center.x + dx;</a>
<a name="ln491">                int y = center.y + dy;</a>
<a name="ln492"> </a>
<a name="ln493">                // we never change the border</a>
<a name="ln494">                if (x &gt;= 1 &amp;&amp; x &lt; lines.width()  - 1 &amp;&amp;</a>
<a name="ln495">                    y &gt;= 1 &amp;&amp; y &lt; lines.height() - 1 &amp;&amp;</a>
<a name="ln496">                    !strchr(passable, lines(x, y)))</a>
<a name="ln497">                {</a>
<a name="ln498">                    lines(x, y) = fill;</a>
<a name="ln499">                }</a>
<a name="ln500">            }</a>
<a name="ln501">    }</a>
<a name="ln502">}</a>
<a name="ln503"> </a>
<a name="ln504"> </a>
<a name="ln505">LUAFN(dgn_count_feature_in_box)</a>
<a name="ln506">{</a>
<a name="ln507">    LINES(ls, 1, map, lines);</a>
<a name="ln508"> </a>
<a name="ln509">    int x1, y1, x2, y2;</a>
<a name="ln510">    if (!_coords(ls, lines, x1, y1, x2, y2))</a>
<a name="ln511">        return 0;</a>
<a name="ln512"> </a>
<a name="ln513">    TABLE_STR(ls, feat, &quot;&quot;);</a>
<a name="ln514"> </a>
<a name="ln515">    coord_def tl(x1, y1);</a>
<a name="ln516">    coord_def br(x2, y2);</a>
<a name="ln517"> </a>
<a name="ln518">    PLUARET(number, lines.count_feature_in_box(tl, br, feat));</a>
<a name="ln519">}</a>
<a name="ln520"> </a>
<a name="ln521">LUAFN(dgn_count_antifeature_in_box)</a>
<a name="ln522">{</a>
<a name="ln523">    LINES(ls, 1, map, lines);</a>
<a name="ln524"> </a>
<a name="ln525">    int x1, y1, x2, y2;</a>
<a name="ln526">    if (!_coords(ls, lines, x1, y1, x2, y2))</a>
<a name="ln527">        return 0;</a>
<a name="ln528"> </a>
<a name="ln529">    TABLE_STR(ls, feat, &quot;&quot;);</a>
<a name="ln530"> </a>
<a name="ln531">    coord_def tl(x1, y1);</a>
<a name="ln532">    coord_def br(x2, y2);</a>
<a name="ln533"> </a>
<a name="ln534">    int sum = (br.x - tl.x + 1) * (br.y - tl.y + 1);</a>
<a name="ln535">    PLUARET(number, sum - lines.count_feature_in_box(tl, br, feat));</a>
<a name="ln536">}</a>
<a name="ln537"> </a>
<a name="ln538">LUAFN(dgn_count_neighbors)</a>
<a name="ln539">{</a>
<a name="ln540">    LINES(ls, 1, map, lines);</a>
<a name="ln541"> </a>
<a name="ln542">    TABLE_STR(ls, feat, &quot;&quot;);</a>
<a name="ln543">    TABLE_INT(ls, x, -1);</a>
<a name="ln544">    TABLE_INT(ls, y, -1);</a>
<a name="ln545"> </a>
<a name="ln546">    if (!_valid_coord(ls, lines, x, y))</a>
<a name="ln547">        return 0;</a>
<a name="ln548"> </a>
<a name="ln549">    coord_def tl(x-1, y-1);</a>
<a name="ln550">    coord_def br(x+1, y+1);</a>
<a name="ln551"> </a>
<a name="ln552">    PLUARET(number, lines.count_feature_in_box(tl, br, feat));</a>
<a name="ln553">}</a>
<a name="ln554"> </a>
<a name="ln555">LUAFN(dgn_count_passable_neighbors)</a>
<a name="ln556">{</a>
<a name="ln557">    LINES(ls, 1, map, lines);</a>
<a name="ln558"> </a>
<a name="ln559">    TABLE_STR(ls, passable, traversable_glyphs);</a>
<a name="ln560">    TABLE_INT(ls, x, -1);</a>
<a name="ln561">    TABLE_INT(ls, y, -1);</a>
<a name="ln562"> </a>
<a name="ln563">    if (!_valid_coord(ls, lines, x, y))</a>
<a name="ln564">    {</a>
<a name="ln565">        lua_pushnumber(ls, 0);</a>
<a name="ln566">        return 1;</a>
<a name="ln567">    }</a>
<a name="ln568"> </a>
<a name="ln569">    lua_pushnumber(ls, _count_passable_neighbors(ls, lines, x, y, passable));</a>
<a name="ln570">    return 1;</a>
<a name="ln571">}</a>
<a name="ln572"> </a>
<a name="ln573">LUAFN(dgn_is_valid_coord)</a>
<a name="ln574">{</a>
<a name="ln575">    LINES(ls, 1, map, lines);</a>
<a name="ln576"> </a>
<a name="ln577">    TABLE_INT(ls, x, -1);</a>
<a name="ln578">    TABLE_INT(ls, y, -1);</a>
<a name="ln579"> </a>
<a name="ln580">    if (x &lt; 0 || x &gt;= lines.width())</a>
<a name="ln581">    {</a>
<a name="ln582">        lua_pushboolean(ls, false);</a>
<a name="ln583">        return 1;</a>
<a name="ln584">    }</a>
<a name="ln585"> </a>
<a name="ln586">    if (y &lt; 0 || y &gt;= lines.height())</a>
<a name="ln587">    {</a>
<a name="ln588">        lua_pushboolean(ls, false);</a>
<a name="ln589">        return 1;</a>
<a name="ln590">    }</a>
<a name="ln591"> </a>
<a name="ln592">    lua_pushboolean(ls, true);</a>
<a name="ln593">    return 1;</a>
<a name="ln594">}</a>
<a name="ln595"> </a>
<a name="ln596">LUAFN(dgn_extend_map)</a>
<a name="ln597">{</a>
<a name="ln598">    LINES(ls, 1, map, lines);</a>
<a name="ln599"> </a>
<a name="ln600">    TABLE_INT(ls, height, 1);</a>
<a name="ln601">    TABLE_INT(ls, width, 1);</a>
<a name="ln602">    TABLE_CHAR(ls, fill, 'x');</a>
<a name="ln603"> </a>
<a name="ln604">    lines.extend(width, height, fill);</a>
<a name="ln605"> </a>
<a name="ln606">    return 0;</a>
<a name="ln607">}</a>
<a name="ln608"> </a>
<a name="ln609">LUAFN(dgn_fill_area)</a>
<a name="ln610">{</a>
<a name="ln611">    LINES(ls, 1, map, lines);</a>
<a name="ln612"> </a>
<a name="ln613">    int x1, y1, x2, y2;</a>
<a name="ln614">    if (!_coords(ls, lines, x1, y1, x2, y2))</a>
<a name="ln615">        return 0;</a>
<a name="ln616"> </a>
<a name="ln617">    TABLE_CHAR(ls, fill, 'x');</a>
<a name="ln618">    TABLE_CHAR(ls, border, fill);</a>
<a name="ln619"> </a>
<a name="ln620">    _fill_area(ls, lines, x1, y1, x2, y2, fill);</a>
<a name="ln621">    if (border != fill)</a>
<a name="ln622">        _border_area(lines, x1, y1, x2, y2, border);</a>
<a name="ln623"> </a>
<a name="ln624">    return 0;</a>
<a name="ln625">}</a>
<a name="ln626"> </a>
<a name="ln627">LUAFN(dgn_fill_disconnected)</a>
<a name="ln628">{</a>
<a name="ln629">    LINES(ls, 1, map, lines);</a>
<a name="ln630"> </a>
<a name="ln631">    int x1, y1, x2, y2;</a>
<a name="ln632">    if (!_coords(ls, lines, x1, y1, x2, y2))</a>
<a name="ln633">        return 0;</a>
<a name="ln634"> </a>
<a name="ln635">    TABLE_CHAR(ls, fill, 'x');</a>
<a name="ln636">    TABLE_STR(ls, passable, traversable_glyphs);</a>
<a name="ln637">    TABLE_STR(ls, wanted, exit_glyphs);</a>
<a name="ln638"> </a>
<a name="ln639">    coord_def tl(x1, y1);</a>
<a name="ln640">    coord_def br(x2, y2);</a>
<a name="ln641"> </a>
<a name="ln642">    travel_distance_grid_t tpd;</a>
<a name="ln643">    memset(tpd, 0, sizeof(tpd));</a>
<a name="ln644"> </a>
<a name="ln645">    int nzones = 0;</a>
<a name="ln646">    for (rectangle_iterator ri(tl, br); ri; ++ri)</a>
<a name="ln647">    {</a>
<a name="ln648">        const coord_def c = *ri;</a>
<a name="ln649">        if (tpd[c.x][c.y] || passable &amp;&amp; !strchr(passable, lines(c)))</a>
<a name="ln650">            continue;</a>
<a name="ln651"> </a>
<a name="ln652">        if (lines.fill_zone(tpd, c, tl, br, ++nzones, wanted, passable))</a>
<a name="ln653">            continue;</a>
<a name="ln654"> </a>
<a name="ln655">        // If wanted wasn't found, fill every passable square that</a>
<a name="ln656">        // we just found with the 'fill' glyph.</a>
<a name="ln657">        for (rectangle_iterator f(tl, br); f; ++f)</a>
<a name="ln658">        {</a>
<a name="ln659">            const coord_def fc = *f;</a>
<a name="ln660">            if (tpd[fc.x][fc.y] == nzones)</a>
<a name="ln661">                lines(fc) = fill;</a>
<a name="ln662">        }</a>
<a name="ln663">    }</a>
<a name="ln664"> </a>
<a name="ln665">    return 0;</a>
<a name="ln666">}</a>
<a name="ln667"> </a>
<a name="ln668">LUAFN(dgn_is_passable_coord)</a>
<a name="ln669">{</a>
<a name="ln670">    LINES(ls, 1, map, lines);</a>
<a name="ln671"> </a>
<a name="ln672">    TABLE_INT(ls, x, -1);</a>
<a name="ln673">    TABLE_INT(ls, y, -1);</a>
<a name="ln674">    TABLE_STR(ls, passable, traversable_glyphs);</a>
<a name="ln675"> </a>
<a name="ln676">    if (!_valid_coord(ls, lines, x, y))</a>
<a name="ln677">        return 0;</a>
<a name="ln678"> </a>
<a name="ln679">    if (strchr(passable, lines(x, y)))</a>
<a name="ln680">        lua_pushboolean(ls, true);</a>
<a name="ln681">    else</a>
<a name="ln682">        lua_pushboolean(ls, false);</a>
<a name="ln683"> </a>
<a name="ln684">    return 1;</a>
<a name="ln685">}</a>
<a name="ln686"> </a>
<a name="ln687">LUAFN(dgn_find_in_area)</a>
<a name="ln688">{</a>
<a name="ln689">    LINES(ls, 1, map, lines);</a>
<a name="ln690"> </a>
<a name="ln691">    TABLE_INT(ls, x1, -1);</a>
<a name="ln692">    TABLE_INT(ls, y1, -1);</a>
<a name="ln693">    TABLE_INT(ls, x2, -1);</a>
<a name="ln694">    TABLE_INT(ls, y2, -1);</a>
<a name="ln695">    TABLE_BOOL(ls, find_vault, false);</a>
<a name="ln696"> </a>
<a name="ln697">    if (!_coords(ls, lines, x1, y1, x2, y2))</a>
<a name="ln698">        return 0;</a>
<a name="ln699"> </a>
<a name="ln700">    TABLE_STR(ls, find, &quot;x&quot;);</a>
<a name="ln701"> </a>
<a name="ln702">    int x, y;</a>
<a name="ln703"> </a>
<a name="ln704">    for (x = x1; x &lt;= x2; x++)</a>
<a name="ln705">        for (y = y1; y &lt;= y2; y++)</a>
<a name="ln706">            if (strchr(find, lines(x, y))</a>
<a name="ln707">                || (find_vault &amp;&amp; (env.level_map_mask(coord_def(x,y))</a>
<a name="ln708">                                   &amp; MMT_VAULT)))</a>
<a name="ln709">            {</a>
<a name="ln710">                lua_pushboolean(ls, true);</a>
<a name="ln711">                return 1;</a>
<a name="ln712">            }</a>
<a name="ln713"> </a>
<a name="ln714">    lua_pushboolean(ls, false);</a>
<a name="ln715">    return 1;</a>
<a name="ln716">}</a>
<a name="ln717"> </a>
<a name="ln718">LUAFN(dgn_height)</a>
<a name="ln719">{</a>
<a name="ln720">    LINES(ls, 1, map, lines);</a>
<a name="ln721">    PLUARET(number, lines.height());</a>
<a name="ln722">}</a>
<a name="ln723"> </a>
<a name="ln724">LUAFN(dgn_primary_vault_dimensions)</a>
<a name="ln725">{</a>
<a name="ln726">    // we don't need this because this function doesn't use the</a>
<a name="ln727">    //  current map</a>
<a name="ln728">    // LINES(ls, 1, lines);</a>
<a name="ln729"> </a>
<a name="ln730">    static const int NO_PRIMARY_VAULT = 99999;</a>
<a name="ln731"> </a>
<a name="ln732">    int x_min =  NO_PRIMARY_VAULT;</a>
<a name="ln733">    int x_max = -NO_PRIMARY_VAULT;</a>
<a name="ln734">    int y_min =  NO_PRIMARY_VAULT;</a>
<a name="ln735">    int y_max = -NO_PRIMARY_VAULT;</a>
<a name="ln736"> </a>
<a name="ln737">    for (int y = 0; y &lt; GYM; y++)</a>
<a name="ln738">        for (int x = 0; x &lt; GXM; x++)</a>
<a name="ln739">        {</a>
<a name="ln740">            if (env.level_map_mask(coord_def(x,y)) &amp; MMT_VAULT)</a>
<a name="ln741">            {</a>
<a name="ln742">                if (x &lt; x_min)</a>
<a name="ln743">                    x_min = x;</a>
<a name="ln744">                if (x &gt; x_max)</a>
<a name="ln745">                    x_max = x;</a>
<a name="ln746">                if (y &lt; y_min)</a>
<a name="ln747">                    y_min = y;</a>
<a name="ln748">                if (y &gt; y_max)</a>
<a name="ln749">                    y_max = y;</a>
<a name="ln750">            }</a>
<a name="ln751">        }</a>
<a name="ln752"> </a>
<a name="ln753">    if (x_min != NO_PRIMARY_VAULT)</a>
<a name="ln754">    {</a>
<a name="ln755">        if (x_max == -NO_PRIMARY_VAULT)</a>
<a name="ln756">            return luaL_error(ls, &quot;Primary vault has x_min %d but no x_max&quot;, x_min);</a>
<a name="ln757">        if (y_min ==  NO_PRIMARY_VAULT)</a>
<a name="ln758">            return luaL_error(ls, &quot;Primary vault has x_min %d but no y_min&quot;, x_min);</a>
<a name="ln759">        if (y_max == -NO_PRIMARY_VAULT)</a>
<a name="ln760">            return luaL_error(ls, &quot;Primary vault has x_min %d but no y_max&quot;, x_min);</a>
<a name="ln761"> </a>
<a name="ln762">        lua_pushnumber(ls, x_min);</a>
<a name="ln763">        lua_pushnumber(ls, x_max);</a>
<a name="ln764">        lua_pushnumber(ls, y_min);</a>
<a name="ln765">        lua_pushnumber(ls, y_max);</a>
<a name="ln766">    }</a>
<a name="ln767">    else  // no primary vault found</a>
<a name="ln768">    {</a>
<a name="ln769">        if (x_max != -NO_PRIMARY_VAULT)</a>
<a name="ln770">            return luaL_error(ls, &quot;Primary vault has x_max %d but no x_min&quot;, x_max);</a>
<a name="ln771">        if (y_min !=  NO_PRIMARY_VAULT)</a>
<a name="ln772">            return luaL_error(ls, &quot;Primary vault has y_min %d but no x_min&quot;, y_min);</a>
<a name="ln773">        if (y_max != -NO_PRIMARY_VAULT)</a>
<a name="ln774">            return luaL_error(ls, &quot;Primary vault has y_max %d but no x_min&quot;, y_max);</a>
<a name="ln775"> </a>
<a name="ln776">        lua_pushnil(ls);</a>
<a name="ln777">        lua_pushnil(ls);</a>
<a name="ln778">        lua_pushnil(ls);</a>
<a name="ln779">        lua_pushnil(ls);</a>
<a name="ln780">    }</a>
<a name="ln781"> </a>
<a name="ln782">    return 4;</a>
<a name="ln783">}</a>
<a name="ln784"> </a>
<a name="ln785">LUAFN(dgn_join_the_dots)</a>
<a name="ln786">{</a>
<a name="ln787">    LINES(ls, 1, map, lines);</a>
<a name="ln788"> </a>
<a name="ln789">    TABLE_INT(ls, x1, -1);</a>
<a name="ln790">    TABLE_INT(ls, y1, -1);</a>
<a name="ln791">    TABLE_INT(ls, x2, -1);</a>
<a name="ln792">    TABLE_INT(ls, y2, -1);</a>
<a name="ln793">    TABLE_STR(ls, passable, traversable_glyphs);</a>
<a name="ln794">    TABLE_CHAR(ls, fill, '.');</a>
<a name="ln795">    TABLE_BOOL(ls, force_straight, false);</a>
<a name="ln796">    TABLE_BOOL(ls, allow_diagonals, false);</a>
<a name="ln797">    TABLE_INT(ls, thickness, 1);</a>
<a name="ln798"> </a>
<a name="ln799">    if (!_valid_coord(ls, lines, x1, y1))</a>
<a name="ln800">        return 0;</a>
<a name="ln801">    if (!_valid_coord(ls, lines, x2, y2))</a>
<a name="ln802">        return 0;</a>
<a name="ln803"> </a>
<a name="ln804">    coord_def from(x1, y1);</a>
<a name="ln805">    coord_def to(x2, y2);</a>
<a name="ln806"> </a>
<a name="ln807">    if (from == to)</a>
<a name="ln808">        return 0;</a>
<a name="ln809"> </a>
<a name="ln810">    // calculate possible paths</a>
<a name="ln811">    join_the_dots_path path1 =</a>
<a name="ln812">        _calculate_join_the_dots_path(from, to,</a>
<a name="ln813">                                      force_straight, allow_diagonals);</a>
<a name="ln814">    join_the_dots_path path2 =</a>
<a name="ln815">        _calculate_join_the_dots_path(to, from,</a>
<a name="ln816">                                      force_straight, allow_diagonals);</a>
<a name="ln817"> </a>
<a name="ln818">    // add better path</a>
<a name="ln819">    // prefer fewer vaults hit, then fewer vaults avoided, then toss a coin</a>
<a name="ln820">    const bool first_path_better =</a>
<a name="ln821">        path1.hit_vault_count &lt; path2.hit_vault_count</a>
<a name="ln822">        || (path1.hit_vault_count == path2.hit_vault_count</a>
<a name="ln823">            &amp;&amp; (path1.avoid_vault_count &lt; path2.avoid_vault_count</a>
<a name="ln824">                || path1.avoid_vault_count == path2.avoid_vault_count</a>
<a name="ln825">                   &amp;&amp; coinflip()</a>
<a name="ln826">                )</a>
<a name="ln827">            );</a>
<a name="ln828">    _draw_join_the_dots_path(lines, first_path_better ? path1 : path2,</a>
<a name="ln829">                             passable, thickness, fill);</a>
<a name="ln830"> </a>
<a name="ln831">    return 0;</a>
<a name="ln832">}</a>
<a name="ln833"> </a>
<a name="ln834">LUAFN(dgn_make_circle)</a>
<a name="ln835">{</a>
<a name="ln836">    LINES(ls, 1, map, lines);</a>
<a name="ln837"> </a>
<a name="ln838">    TABLE_INT(ls, x, -1);</a>
<a name="ln839">    TABLE_INT(ls, y, -1);</a>
<a name="ln840">    TABLE_INT(ls, radius, 1);</a>
<a name="ln841">    TABLE_CHAR(ls, fill, 'x');</a>
<a name="ln842"> </a>
<a name="ln843">    if (!_valid_coord(ls, lines, x, y))</a>
<a name="ln844">        return 0;</a>
<a name="ln845"> </a>
<a name="ln846">    float radius_squared_max = (radius + 0.5f) * (radius + 0.5f);</a>
<a name="ln847">    for (int ry = -radius; ry &lt;= radius; ++ry)</a>
<a name="ln848">        for (int rx = -radius; rx &lt;= radius; ++rx)</a>
<a name="ln849">            if (rx * rx + ry * ry &lt; radius_squared_max)</a>
<a name="ln850">                lines(x + rx, y + ry) = fill;</a>
<a name="ln851"> </a>
<a name="ln852">    return 0;</a>
<a name="ln853">}</a>
<a name="ln854"> </a>
<a name="ln855">LUAFN(dgn_make_diamond)</a>
<a name="ln856">{</a>
<a name="ln857">    LINES(ls, 1, map, lines);</a>
<a name="ln858"> </a>
<a name="ln859">    TABLE_INT(ls, x, -1);</a>
<a name="ln860">    TABLE_INT(ls, y, -1);</a>
<a name="ln861">    TABLE_INT(ls, radius, 1);</a>
<a name="ln862">    TABLE_CHAR(ls, fill, 'x');</a>
<a name="ln863"> </a>
<a name="ln864">    if (!_valid_coord(ls, lines, x, y))</a>
<a name="ln865">        return 0;</a>
<a name="ln866"> </a>
<a name="ln867">    for (int ry = -radius; ry &lt;= radius; ++ry)</a>
<a name="ln868">        for (int rx = -radius; rx &lt;= radius; ++rx)</a>
<a name="ln869">            if (abs(rx) + abs(ry) &lt;= radius)</a>
<a name="ln870">                lines(x + rx, y + ry) = fill;</a>
<a name="ln871"> </a>
<a name="ln872">    return 0;</a>
<a name="ln873">}</a>
<a name="ln874"> </a>
<a name="ln875">LUAFN(dgn_make_rounded_square)</a>
<a name="ln876">{</a>
<a name="ln877">    LINES(ls, 1, map, lines);</a>
<a name="ln878"> </a>
<a name="ln879">    TABLE_INT(ls, x, -1);</a>
<a name="ln880">    TABLE_INT(ls, y, -1);</a>
<a name="ln881">    TABLE_INT(ls, radius, 1);</a>
<a name="ln882">    TABLE_CHAR(ls, fill, 'x');</a>
<a name="ln883"> </a>
<a name="ln884">    if (!_valid_coord(ls, lines, x, y))</a>
<a name="ln885">        return 0;</a>
<a name="ln886"> </a>
<a name="ln887">    for (int ry = -radius; ry &lt;= radius; ++ry)</a>
<a name="ln888">        for (int rx = -radius; rx &lt;= radius; ++rx)</a>
<a name="ln889">            if (abs(rx) != radius || abs(ry) != radius)</a>
<a name="ln890">                lines(x + rx, y + ry) = fill;</a>
<a name="ln891"> </a>
<a name="ln892">    return 0;</a>
<a name="ln893">}</a>
<a name="ln894"> </a>
<a name="ln895">LUAFN(dgn_make_square)</a>
<a name="ln896">{</a>
<a name="ln897">    LINES(ls, 1, map, lines);</a>
<a name="ln898"> </a>
<a name="ln899">    TABLE_INT(ls, x, -1);</a>
<a name="ln900">    TABLE_INT(ls, y, -1);</a>
<a name="ln901">    TABLE_INT(ls, radius, 1);</a>
<a name="ln902">    TABLE_CHAR(ls, fill, 'x');</a>
<a name="ln903"> </a>
<a name="ln904">    if (!_valid_coord(ls, lines, x, y))</a>
<a name="ln905">        return 0;</a>
<a name="ln906"> </a>
<a name="ln907">    for (int ry = -radius; ry &lt;= radius; ++ry)</a>
<a name="ln908">        for (int rx = -radius; rx &lt;= radius; ++rx)</a>
<a name="ln909">            lines(x + rx, y + ry) = fill;</a>
<a name="ln910"> </a>
<a name="ln911">    return 0;</a>
<a name="ln912">}</a>
<a name="ln913"> </a>
<a name="ln914">LUAFN(dgn_make_box)</a>
<a name="ln915">{</a>
<a name="ln916">    LINES(ls, 1, map, lines);</a>
<a name="ln917"> </a>
<a name="ln918">    int x1, y1, x2, y2;</a>
<a name="ln919">    if (!_coords(ls, lines, x1, y1, x2, y2))</a>
<a name="ln920">        return 0;</a>
<a name="ln921"> </a>
<a name="ln922">    TABLE_CHAR(ls, floor, '.');</a>
<a name="ln923">    TABLE_CHAR(ls, wall, 'x');</a>
<a name="ln924">    TABLE_INT(ls, thickness, 1);</a>
<a name="ln925"> </a>
<a name="ln926">    _fill_area(ls, lines, x1, y1, x2, y2, wall);</a>
<a name="ln927">    _fill_area(ls, lines, x1+thickness, y1+thickness,</a>
<a name="ln928">                          x2-thickness, y2-thickness, floor);</a>
<a name="ln929"> </a>
<a name="ln930">    return 0;</a>
<a name="ln931">}</a>
<a name="ln932"> </a>
<a name="ln933">LUAFN(dgn_make_box_doors)</a>
<a name="ln934">{</a>
<a name="ln935">    LINES(ls, 1, map, lines);</a>
<a name="ln936"> </a>
<a name="ln937">    int x1, y1, x2, y2;</a>
<a name="ln938">    if (!_coords(ls, lines, x1, y1, x2, y2))</a>
<a name="ln939">        return 0;</a>
<a name="ln940"> </a>
<a name="ln941">    TABLE_INT(ls, number, 1);</a>
<a name="ln942">    TABLE_INT(ls, thickness, 1);</a>
<a name="ln943">    TABLE_CHAR(ls, door, '+');</a>
<a name="ln944">    TABLE_CHAR(ls, inner_door, '.');</a>
<a name="ln945">    TABLE_CHAR(ls, between_doors, '.');</a>
<a name="ln946">    TABLE_BOOL(ls, veto_gates, false);</a>
<a name="ln947">    TABLE_STR(ls, passable, traversable_glyphs);</a>
<a name="ln948"> </a>
<a name="ln949">    // size doesn't include corners</a>
<a name="ln950">    int size_x = x2 - x1 + 1 - thickness * 2;</a>
<a name="ln951">    int size_y = y2 - y1 + 1 - thickness * 2;</a>
<a name="ln952">    int position_count = size_x * 2 + size_y * 2;</a>
<a name="ln953"> </a>
<a name="ln954">    int max_sanity = number * 100;</a>
<a name="ln955">    int sanity = 0;</a>
<a name="ln956"> </a>
<a name="ln957">    int door_count = 0;</a>
<a name="ln958">    while (door_count &lt; number)</a>
<a name="ln959">    {</a>
<a name="ln960">        int position = random2(position_count);</a>
<a name="ln961">        int side;</a>
<a name="ln962">        int x, y;</a>
<a name="ln963">        if (position &lt; size_x)</a>
<a name="ln964">        {</a>
<a name="ln965">            side = 0;</a>
<a name="ln966">            x = x1 + thickness + position;</a>
<a name="ln967">            y = y1;</a>
<a name="ln968">        }</a>
<a name="ln969">        else if (position &lt; size_x * 2)</a>
<a name="ln970">        {</a>
<a name="ln971">            side = 1;</a>
<a name="ln972">            x = x1 + thickness + (position - size_x);</a>
<a name="ln973">            y = y2;</a>
<a name="ln974">        }</a>
<a name="ln975">        else if (position &lt; size_x * 2 + size_y)</a>
<a name="ln976">        {</a>
<a name="ln977">            side = 2;</a>
<a name="ln978">            x = x1;</a>
<a name="ln979">            y = y1 + thickness + (position - size_x * 2);</a>
<a name="ln980">        }</a>
<a name="ln981">        else</a>
<a name="ln982">        {</a>
<a name="ln983">            side = 3;</a>
<a name="ln984">            x = x2;</a>
<a name="ln985">            y = y1 + thickness + (position - size_x * 2 - size_y);</a>
<a name="ln986">        }</a>
<a name="ln987"> </a>
<a name="ln988">        // We veto a position if:</a>
<a name="ln989">        //  -&gt; The cell outside the box is not passible</a>
<a name="ln990">        //  -&gt; The cell (however far) inside the box is not passible</a>
<a name="ln991">        //  -&gt; There is a door to the left or right and we are vetoing gates</a>
<a name="ln992">        bool good = true;</a>
<a name="ln993">        if (side &lt; 2)</a>
<a name="ln994">        {</a>
<a name="ln995">            if (!strchr(passable, lines(x, y - (side == 0 ? 1 : thickness))))</a>
<a name="ln996">                good = false;</a>
<a name="ln997">            if (!strchr(passable, lines(x, y + (side == 1 ? 1 : thickness))))</a>
<a name="ln998">                good = false;</a>
<a name="ln999">            if (veto_gates &amp;&amp; (lines(x-1, y) == door || lines(x+1, y) == door))</a>
<a name="ln1000">                good = false;</a>
<a name="ln1001">        }</a>
<a name="ln1002">        else</a>
<a name="ln1003">        {</a>
<a name="ln1004">            if (!strchr(passable, lines(x - (side == 2 ? 1 : thickness), y)))</a>
<a name="ln1005">                good = false;</a>
<a name="ln1006">            if (!strchr(passable, lines(x + (side == 3 ? 1 : thickness), y)))</a>
<a name="ln1007">                good = false;</a>
<a name="ln1008">            if (veto_gates &amp;&amp; (lines(x, y-1) == door || lines(x, y+1) == door))</a>
<a name="ln1009">                good = false;</a>
<a name="ln1010">        }</a>
<a name="ln1011"> </a>
<a name="ln1012">        if (good)</a>
<a name="ln1013">        {</a>
<a name="ln1014">            door_count++;</a>
<a name="ln1015">            lines(x, y) = door;</a>
<a name="ln1016">            for (int i = 1; i &lt; thickness; i++)</a>
<a name="ln1017">            {</a>
<a name="ln1018">                switch (side)</a>
<a name="ln1019">                {</a>
<a name="ln1020">                case 0: y++;  break;</a>
<a name="ln1021">                case 1: y--;  break;</a>
<a name="ln1022">                case 2: x++;  break;</a>
<a name="ln1023">                case 3: x--;  break;</a>
<a name="ln1024">                }</a>
<a name="ln1025">                lines(x, y) = between_doors;</a>
<a name="ln1026">            }</a>
<a name="ln1027">            if (thickness &gt; 1)</a>
<a name="ln1028">                lines(x, y) = inner_door;</a>
<a name="ln1029">        }</a>
<a name="ln1030">        else</a>
<a name="ln1031">        {</a>
<a name="ln1032">            sanity++;</a>
<a name="ln1033">            if (sanity &gt;= max_sanity)</a>
<a name="ln1034">                break;</a>
<a name="ln1035">        }</a>
<a name="ln1036">    }</a>
<a name="ln1037"> </a>
<a name="ln1038">    lua_pushnumber(ls, door_count);</a>
<a name="ln1039">    return 1;</a>
<a name="ln1040">}</a>
<a name="ln1041"> </a>
<a name="ln1042">LUAFN(dgn_make_irregular_box)</a>
<a name="ln1043">{</a>
<a name="ln1044">    LINES(ls, 1, map, lines);</a>
<a name="ln1045"> </a>
<a name="ln1046">    int x1, y1, x2, y2;</a>
<a name="ln1047">    if (!_coords(ls, lines, x1, y1, x2, y2))</a>
<a name="ln1048">        return 0;</a>
<a name="ln1049"> </a>
<a name="ln1050">    TABLE_CHAR(ls, floor, '.');</a>
<a name="ln1051">    TABLE_CHAR(ls, wall, 'x');</a>
<a name="ln1052">    TABLE_CHAR(ls, door, '+');</a>
<a name="ln1053">    TABLE_INT(ls, door_count, 1);</a>
<a name="ln1054">    TABLE_INT(ls, div_x, 1);</a>
<a name="ln1055">    TABLE_INT(ls, div_y, 1);</a>
<a name="ln1056">    TABLE_INT(ls, in_x, 10000);</a>
<a name="ln1057">    TABLE_INT(ls, in_y, 10000);</a>
<a name="ln1058"> </a>
<a name="ln1059">    make_irregular_box(lines, x1, y1, x2, y2,</a>
<a name="ln1060">                       div_x, div_y, in_x, in_y,</a>
<a name="ln1061">                       floor, wall, door, door_count);</a>
<a name="ln1062">    return 0;</a>
<a name="ln1063">}</a>
<a name="ln1064"> </a>
<a name="ln1065">LUAFN(dgn_make_round_box)</a>
<a name="ln1066">{</a>
<a name="ln1067">    LINES(ls, 1, map, lines);</a>
<a name="ln1068"> </a>
<a name="ln1069">    int x1, y1, x2, y2;</a>
<a name="ln1070">    if (!_coords(ls, lines, x1, y1, x2, y2))</a>
<a name="ln1071">        return 0;</a>
<a name="ln1072"> </a>
<a name="ln1073">    TABLE_CHAR(ls, floor, '.');</a>
<a name="ln1074">    TABLE_CHAR(ls, wall, 'x');</a>
<a name="ln1075">    TABLE_CHAR(ls, door, '+');</a>
<a name="ln1076">    TABLE_INT(ls, door_count, 1);</a>
<a name="ln1077">    TABLE_STR(ls, passable, traversable_glyphs);</a>
<a name="ln1078">    TABLE_BOOL(ls, veto_gates, false);</a>
<a name="ln1079">    TABLE_BOOL(ls, veto_if_no_doors, false);</a>
<a name="ln1080"> </a>
<a name="ln1081">    const int OUTSIDE = 0;</a>
<a name="ln1082">    const int WALL    = 1;</a>
<a name="ln1083">    const int FLOOR   = 2;</a>
<a name="ln1084">    const int DOOR    = 3;</a>
<a name="ln1085"> </a>
<a name="ln1086">    int size_x = x2 - x1 + 1;</a>
<a name="ln1087">    int size_y = y2 - y1 + 1;</a>
<a name="ln1088"> </a>
<a name="ln1089">    //</a>
<a name="ln1090">    //  The basic idea here is we draw a filled circle, hollow</a>
<a name="ln1091">    //    out the middle, and then place doors on straight walls</a>
<a name="ln1092">    //    until we have enough.</a>
<a name="ln1093">    //</a>
<a name="ln1094">    //  We do not know for sure whether we want to actually draw</a>
<a name="ln1095">    //    anything until the end, so we will draw out tower onto</a>
<a name="ln1096">    //    our own separate array (actually a vector of vectors</a>
<a name="ln1097">    //    so we can set the size at runtime). Then, if</a>
<a name="ln1098">    //    everything goes well, we will copy it to the world with</a>
<a name="ln1099">    //    the appropriate glyphs.</a>
<a name="ln1100">    //</a>
<a name="ln1101">    //  Note that each of these steps has to be completed before</a>
<a name="ln1102">    //    we can do the next one, so all the loops over the same</a>
<a name="ln1103">    //    area are required.</a>
<a name="ln1104">    //</a>
<a name="ln1105"> </a>
<a name="ln1106">    //  1. Fill with OUTSIDE glyphs.</a>
<a name="ln1107">    vector&lt;vector&lt;int&gt; &gt; new_glyphs(size_x, vector&lt;int&gt;(size_y, OUTSIDE));</a>
<a name="ln1108"> </a>
<a name="ln1109">    //  2. Draw wall glyphs for filled circle.</a>
<a name="ln1110">    //    -&gt; This is a formula for an ellipse in case we get a</a>
<a name="ln1111">    //       non-circular room to make</a>
<a name="ln1112">    //    -&gt; we add an extra 0.5 to the radius so that we don't</a>
<a name="ln1113">    //       get wall isolated cells on the outside</a>
<a name="ln1114">    float radius_x = (size_x - 1.0f) * 0.5f;</a>
<a name="ln1115">    float radius_y = (size_y - 1.0f) * 0.5f;</a>
<a name="ln1116">    for (int x = 0; x &lt; size_x; x++)</a>
<a name="ln1117">        for (int y = 0; y &lt; size_y; y++)</a>
<a name="ln1118">        {</a>
<a name="ln1119">            float fraction_x = (x - radius_x) / (radius_x + 0.5f);</a>
<a name="ln1120">            float fraction_y = (y - radius_y) / (radius_y + 0.5f);</a>
<a name="ln1121">            if (fraction_x * fraction_x + fraction_y * fraction_y &lt;= 1.0f)</a>
<a name="ln1122">                new_glyphs[x][y] = WALL;</a>
<a name="ln1123">        }</a>
<a name="ln1124"> </a>
<a name="ln1125">    //  3. Replace all wall glypyhs that don't touch outside the</a>
<a name="ln1126">    //     circle with floor glyphs.</a>
<a name="ln1127">    for (int x = 0; x &lt; size_x; x++)</a>
<a name="ln1128">        for (int y = 0; y &lt; size_y; y++)</a>
<a name="ln1129">        {</a>
<a name="ln1130">            // we can't use adjacent_iterator it doesn't</a>
<a name="ln1131">            //  report neighbours with negative coordinates</a>
<a name="ln1132">            if (new_glyphs[x][y] == WALL</a>
<a name="ln1133">                &amp;&amp; x &gt; 0 &amp;&amp; x &lt; size_x - 1</a>
<a name="ln1134">                &amp;&amp; y &gt; 0 &amp;&amp; y &lt; size_y - 1</a>
<a name="ln1135">                &amp;&amp; new_glyphs[x - 1][y - 1] != OUTSIDE</a>
<a name="ln1136">                &amp;&amp; new_glyphs[x    ][y - 1] != OUTSIDE</a>
<a name="ln1137">                &amp;&amp; new_glyphs[x + 1][y - 1] != OUTSIDE</a>
<a name="ln1138">                &amp;&amp; new_glyphs[x - 1][y    ] != OUTSIDE</a>
<a name="ln1139">                &amp;&amp; new_glyphs[x + 1][y    ] != OUTSIDE</a>
<a name="ln1140">                &amp;&amp; new_glyphs[x - 1][y + 1] != OUTSIDE</a>
<a name="ln1141">                &amp;&amp; new_glyphs[x    ][y + 1] != OUTSIDE</a>
<a name="ln1142">                &amp;&amp; new_glyphs[x + 1][y + 1] != OUTSIDE)</a>
<a name="ln1143">            {</a>
<a name="ln1144">                new_glyphs[x][y] = FLOOR;</a>
<a name="ln1145">            }</a>
<a name="ln1146">        }</a>
<a name="ln1147"> </a>
<a name="ln1148">    //  4. Find all potential door positions.</a>
<a name="ln1149">    vector&lt;coord_def&gt; door_positions;</a>
<a name="ln1150">    for (int x = 0; x &lt; size_x; x++)</a>
<a name="ln1151">        for (int y = 0; y &lt; size_y; y++)</a>
<a name="ln1152">            if (new_glyphs[x][y] == WALL)</a>
<a name="ln1153">            {</a>
<a name="ln1154">                // check for wall in each direction</a>
<a name="ln1155">                bool xm = (x - 1 &gt;= 0      &amp;&amp; new_glyphs[x - 1][y] == WALL);</a>
<a name="ln1156">                bool xp = (x + 1 &lt;  size_x &amp;&amp; new_glyphs[x + 1][y] == WALL);</a>
<a name="ln1157">                bool ym = (y - 1 &gt;= 0      &amp;&amp; new_glyphs[x][y - 1] == WALL);</a>
<a name="ln1158">                bool yp = (y + 1 &lt;  size_y &amp;&amp; new_glyphs[x][y + 1] == WALL);</a>
<a name="ln1159"> </a>
<a name="ln1160">                int real_x = x1 + x;</a>
<a name="ln1161">                int real_y = y1 + y;</a>
<a name="ln1162"> </a>
<a name="ln1163">                // We are on an X-aligned wall</a>
<a name="ln1164">                if (xm &amp;&amp; xp &amp;&amp; !ym &amp;&amp; !yp)</a>
<a name="ln1165">                {</a>
<a name="ln1166">                    //</a>
<a name="ln1167">                    //  Check for passable glyphs in real map</a>
<a name="ln1168">                    //    and outside the tower. The check</a>
<a name="ln1169">                    //    order is:</a>
<a name="ln1170">                    //    -&gt; in real map</a>
<a name="ln1171">                    //    -&gt; passable</a>
<a name="ln1172">                    //    -&gt; outside temporary array</a>
<a name="ln1173">                    //       or array has OUTSIDE glyph</a>
<a name="ln1174">                    //</a>
<a name="ln1175">                    //  If we can find one on at least one side,</a>
<a name="ln1176">                    //    we can put a door here.</a>
<a name="ln1177">                    //    -&gt; we will only get two on rooms only</a>
<a name="ln1178">                    //       1 cell wide including walls</a>
<a name="ln1179">                    //</a>
<a name="ln1180"> </a>
<a name="ln1181">                    if (real_y - 1 &gt;= 0</a>
<a name="ln1182">                        &amp;&amp; strchr(passable, lines(real_x, real_y - 1))</a>
<a name="ln1183">                        &amp;&amp; (y - 1 &lt; 0</a>
<a name="ln1184">                            || new_glyphs[x][y - 1] == OUTSIDE))</a>
<a name="ln1185">                    {</a>
<a name="ln1186">                        door_positions.emplace_back(x, y);</a>
<a name="ln1187">                    }</a>
<a name="ln1188">                    else if (real_y + 1 &lt; lines.height()</a>
<a name="ln1189">                             &amp;&amp; strchr(passable, lines(real_x, real_y + 1))</a>
<a name="ln1190">                             &amp;&amp; (y + 1 &gt;= size_y</a>
<a name="ln1191">                                 || new_glyphs[x][y + 1] == OUTSIDE))</a>
<a name="ln1192">                    {</a>
<a name="ln1193">                        door_positions.emplace_back(x, y);</a>
<a name="ln1194">                    }</a>
<a name="ln1195">                }</a>
<a name="ln1196"> </a>
<a name="ln1197">                // We are on an Y-aligned wall</a>
<a name="ln1198">                if (!xm &amp;&amp; !xp &amp;&amp; ym &amp;&amp; yp)</a>
<a name="ln1199">                {</a>
<a name="ln1200">                    // Same checks as above, but the other axis</a>
<a name="ln1201">                    if (real_x - 1 &gt;= 0</a>
<a name="ln1202">                        &amp;&amp; strchr(passable, lines(real_x - 1, real_y))</a>
<a name="ln1203">                        &amp;&amp; (x - 1 &lt; 0</a>
<a name="ln1204">                            || new_glyphs[x - 1][y] == OUTSIDE))</a>
<a name="ln1205">                    {</a>
<a name="ln1206">                        door_positions.emplace_back(x, y);</a>
<a name="ln1207">                    }</a>
<a name="ln1208">                    else if (real_x + 1 &lt; lines.width()</a>
<a name="ln1209">                             &amp;&amp; strchr(passable, lines(real_x + 1, real_y))</a>
<a name="ln1210">                             &amp;&amp; (x + 1 &gt;= size_x</a>
<a name="ln1211">                                 || new_glyphs[x + 1][y] == OUTSIDE))</a>
<a name="ln1212">                    {</a>
<a name="ln1213">                        door_positions.emplace_back(x, y);</a>
<a name="ln1214">                    }</a>
<a name="ln1215">                }</a>
<a name="ln1216">            }</a>
<a name="ln1217"> </a>
<a name="ln1218">    //  5. Add doors</a>
<a name="ln1219">    int doors_placed = 0;</a>
<a name="ln1220">    while (doors_placed &lt; door_count &amp;&amp; !door_positions.empty())</a>
<a name="ln1221">    {</a>
<a name="ln1222">        int index = random2(door_positions.size());</a>
<a name="ln1223">        coord_def pos = door_positions[index];</a>
<a name="ln1224">        door_positions[index] = door_positions[door_positions.size() - 1];</a>
<a name="ln1225">        door_positions.pop_back();</a>
<a name="ln1226"> </a>
<a name="ln1227">        bool good_spot = true;</a>
<a name="ln1228">        if (veto_gates)</a>
<a name="ln1229">        {</a>
<a name="ln1230">            if (pos.x - 1 &gt;= 0     &amp;&amp; new_glyphs[pos.x - 1][pos.y] == DOOR)</a>
<a name="ln1231">                good_spot = false;</a>
<a name="ln1232">            if (pos.x + 1 &lt; size_x &amp;&amp; new_glyphs[pos.x + 1][pos.y] == DOOR)</a>
<a name="ln1233">                good_spot = false;</a>
<a name="ln1234">            if (pos.y - 1 &gt;= 0     &amp;&amp; new_glyphs[pos.x][pos.y - 1] == DOOR)</a>
<a name="ln1235">                good_spot = false;</a>
<a name="ln1236">            if (pos.y + 1 &lt; size_y &amp;&amp; new_glyphs[pos.x][pos.y + 1] == DOOR)</a>
<a name="ln1237">                good_spot = false;</a>
<a name="ln1238">        }</a>
<a name="ln1239"> </a>
<a name="ln1240">        if (good_spot)</a>
<a name="ln1241">        {</a>
<a name="ln1242">            new_glyphs[pos.x][pos.y] = DOOR;</a>
<a name="ln1243">            doors_placed++;</a>
<a name="ln1244">        }</a>
<a name="ln1245">    }</a>
<a name="ln1246"> </a>
<a name="ln1247">    //  6. Add tower to map (if not vetoed)</a>
<a name="ln1248">    if (doors_placed &gt; 0 || !veto_if_no_doors)</a>
<a name="ln1249">    {</a>
<a name="ln1250">        for (int x = 0; x &lt; size_x; x++)</a>
<a name="ln1251">            for (int y = 0; y &lt; size_y; y++)</a>
<a name="ln1252">            {</a>
<a name="ln1253">                switch (new_glyphs[x][y])</a>
<a name="ln1254">                {</a>
<a name="ln1255">                // leave existing glyphs on OUTSIDE</a>
<a name="ln1256">                case WALL:  lines(x1 + x, y1 + y) = wall;  break;</a>
<a name="ln1257">                case FLOOR: lines(x1 + x, y1 + y) = floor; break;</a>
<a name="ln1258">                case DOOR:  lines(x1 + x, y1 + y) = door; break;</a>
<a name="ln1259">                }</a>
<a name="ln1260">            }</a>
<a name="ln1261"> </a>
<a name="ln1262">        lua_pushboolean(ls, true);</a>
<a name="ln1263">    }</a>
<a name="ln1264">    else</a>
<a name="ln1265">        lua_pushboolean(ls, false);</a>
<a name="ln1266"> </a>
<a name="ln1267">    return 1;</a>
<a name="ln1268">}</a>
<a name="ln1269"> </a>
<a name="ln1270">// Return a metatable for a point on the map_lines grid.</a>
<a name="ln1271">LUAFN(dgn_mapgrd_table)</a>
<a name="ln1272">{</a>
<a name="ln1273">    MAP(ls, 1, map);</a>
<a name="ln1274"> </a>
<a name="ln1275">    map_def **mapref = clua_new_userdata&lt;map_def *&gt;(ls, MAPGRD_METATABLE);</a>
<a name="ln1276">    *mapref = map;</a>
<a name="ln1277"> </a>
<a name="ln1278">    return 1;</a>
<a name="ln1279">}</a>
<a name="ln1280"> </a>
<a name="ln1281">LUAFN(dgn_octa_room)</a>
<a name="ln1282">{</a>
<a name="ln1283">    LINES(ls, 1, map, lines);</a>
<a name="ln1284"> </a>
<a name="ln1285">    int default_oblique = min(lines.width(), lines.height()) / 2 - 1;</a>
<a name="ln1286">    TABLE_INT(ls, oblique, default_oblique);</a>
<a name="ln1287">    TABLE_CHAR(ls, outside, 'x');</a>
<a name="ln1288">    TABLE_CHAR(ls, inside, '.');</a>
<a name="ln1289">    TABLE_STR(ls, replace, &quot;&quot;);</a>
<a name="ln1290"> </a>
<a name="ln1291">    int x1, y1, x2, y2;</a>
<a name="ln1292">    if (!_coords(ls, lines, x1, y1, x2, y2))</a>
<a name="ln1293">        return 0;</a>
<a name="ln1294"> </a>
<a name="ln1295">    coord_def tl(x1, y1);</a>
<a name="ln1296">    coord_def br(x2, y2);</a>
<a name="ln1297"> </a>
<a name="ln1298">    for (rectangle_iterator ri(tl, br); ri; ++ri)</a>
<a name="ln1299">    {</a>
<a name="ln1300">        const coord_def mc = *ri;</a>
<a name="ln1301">        char glyph = lines(mc);</a>
<a name="ln1302">        if (replace[0] &amp;&amp; !strchr(replace, glyph))</a>
<a name="ln1303">            continue;</a>
<a name="ln1304"> </a>
<a name="ln1305">        int ob = 0;</a>
<a name="ln1306">        ob += max(oblique + tl.x - mc.x, 0);</a>
<a name="ln1307">        ob += max(oblique + mc.x - br.x, 0);</a>
<a name="ln1308"> </a>
<a name="ln1309">        bool is_inside = (mc.y &gt;= tl.y + ob &amp;&amp; mc.y &lt;= br.y - ob);</a>
<a name="ln1310">        lines(mc) = is_inside ? inside : outside;</a>
<a name="ln1311">    }</a>
<a name="ln1312"> </a>
<a name="ln1313">    return 0;</a>
<a name="ln1314">}</a>
<a name="ln1315"> </a>
<a name="ln1316">LUAFN(dgn_remove_isolated_glyphs)</a>
<a name="ln1317">{</a>
<a name="ln1318">    LINES(ls, 1, map, lines);</a>
<a name="ln1319"> </a>
<a name="ln1320">    TABLE_STR(ls, find, &quot;&quot;);</a>
<a name="ln1321">    TABLE_CHAR(ls, replace, '.');</a>
<a name="ln1322">    TABLE_INT(ls, percent, 100);</a>
<a name="ln1323">    TABLE_BOOL(ls, boxy, false);</a>
<a name="ln1324"> </a>
<a name="ln1325">    int x1, y1, x2, y2;</a>
<a name="ln1326">    if (!_coords(ls, lines, x1, y1, x2, y2))</a>
<a name="ln1327">        return 0;</a>
<a name="ln1328"> </a>
<a name="ln1329">    // we never change the border</a>
<a name="ln1330">    if (x1 &lt; 1)</a>
<a name="ln1331">        x1 = 1;</a>
<a name="ln1332">    if (x2 &gt;= lines.width() - 1)</a>
<a name="ln1333">        x2 = lines.width() - 2;</a>
<a name="ln1334">    if (y1 &lt; 1)</a>
<a name="ln1335">        y1 = 1;</a>
<a name="ln1336">    if (y2 &gt;= lines.height() - 1)</a>
<a name="ln1337">        y2 = lines.height() - 2;</a>
<a name="ln1338"> </a>
<a name="ln1339">    for (int y = y1; y &lt;= y2; ++y)</a>
<a name="ln1340">        for (int x = x1; x &lt;= x2; ++x)</a>
<a name="ln1341">            if (strchr(find, lines(x, y)) &amp;&amp; x_chance_in_y(percent, 100))</a>
<a name="ln1342">            {</a>
<a name="ln1343">                bool do_replace = true;</a>
<a name="ln1344">                for (radius_iterator ri(coord_def(x, y), 1,</a>
<a name="ln1345">                                        (boxy ? C_ROUND : C_POINTY),</a>
<a name="ln1346">                                        true); ri; ++ri)</a>
<a name="ln1347">                {</a>
<a name="ln1348">                    if (_valid_coord(ls, lines, ri-&gt;x, ri-&gt;y, false))</a>
<a name="ln1349">                        if (strchr(find, lines(*ri)))</a>
<a name="ln1350">                        {</a>
<a name="ln1351">                            do_replace = false;</a>
<a name="ln1352">                            break;</a>
<a name="ln1353">                        }</a>
<a name="ln1354">                }</a>
<a name="ln1355">                if (do_replace)</a>
<a name="ln1356">                    lines(x, y) = replace;</a>
<a name="ln1357">            }</a>
<a name="ln1358"> </a>
<a name="ln1359">    return 0;</a>
<a name="ln1360">}</a>
<a name="ln1361"> </a>
<a name="ln1362">LUAFN(dgn_widen_paths)</a>
<a name="ln1363">{</a>
<a name="ln1364">    LINES(ls, 1, map, lines);</a>
<a name="ln1365"> </a>
<a name="ln1366">    TABLE_STR(ls, find, &quot;&quot;);</a>
<a name="ln1367">    TABLE_CHAR(ls, replace, '.');</a>
<a name="ln1368">    TABLE_STR(ls, passable, traversable_glyphs);</a>
<a name="ln1369">    TABLE_INT(ls, percent, 100);</a>
<a name="ln1370">    TABLE_BOOL(ls, boxy, false);</a>
<a name="ln1371"> </a>
<a name="ln1372">    int x1, y1, x2, y2;</a>
<a name="ln1373">    if (!_coords(ls, lines, x1, y1, x2, y2))</a>
<a name="ln1374">        return 0;</a>
<a name="ln1375"> </a>
<a name="ln1376">    // we never change the border</a>
<a name="ln1377">    if (x1 &lt; 1)</a>
<a name="ln1378">        x1 = 1;</a>
<a name="ln1379">    if (x2 &gt;= lines.width() - 1)</a>
<a name="ln1380">        x2 = lines.width() - 2;</a>
<a name="ln1381">    if (y1 &lt; 1)</a>
<a name="ln1382">        y1 = 1;</a>
<a name="ln1383">    if (y2 &gt;= lines.height() - 1)</a>
<a name="ln1384">        y2 = lines.height() - 2;</a>
<a name="ln1385"> </a>
<a name="ln1386">    vector&lt;int&gt; percent_for_neighbours;</a>
<a name="ln1387">    // these cases are temporary, to keep a particular seed stable for a bit...</a>
<a name="ln1388">    // They mimic some floating point quirks of the previous version.</a>
<a name="ln1389">    // there's one more case in gehenna that I didn't bother with.</a>
<a name="ln1390">    if (percent == 30)</a>
<a name="ln1391">        percent_for_neighbours = {0, 30, 52, 66, 76, 84, 89, 92, 95};</a>
<a name="ln1392">    else if (percent == 50)</a>
<a name="ln1393">        percent_for_neighbours = {0, 50, 75, 88, 94, 97, 99, 100, 100};</a>
<a name="ln1394">    else</a>
<a name="ln1395">    {</a>
<a name="ln1396">        const long antifraction_each = 10 - percent / 10; // truncates...</a>
<a name="ln1397">        long antifraction_current = 10 * antifraction_each;</a>
<a name="ln1398">        long divisor = 1;</a>
<a name="ln1399">        percent_for_neighbours.push_back(0);</a>
<a name="ln1400">        for (int i = 1; i &lt; 9; i++)</a>
<a name="ln1401">        {</a>
<a name="ln1402">            percent_for_neighbours.push_back(</a>
<a name="ln1403">                100 - antifraction_current / divisor);</a>
<a name="ln1404">            antifraction_current *= antifraction_each;</a>
<a name="ln1405">            divisor *= 10;</a>
<a name="ln1406">        }</a>
<a name="ln1407">    }</a>
<a name="ln1408"> </a>
<a name="ln1409">    // We do not replace this as we go to avoid favouring some directions.</a>
<a name="ln1410">    vector&lt;coord_def&gt; coord_to_replace;</a>
<a name="ln1411"> </a>
<a name="ln1412">    for (int y = y1; y &lt;= y2; ++y)</a>
<a name="ln1413">        for (int x = x1; x &lt;= x2; ++x)</a>
<a name="ln1414">            if (strchr(find, lines(x, y)))</a>
<a name="ln1415">            {</a>
<a name="ln1416">                int neighbour_count = 0;</a>
<a name="ln1417">                for (radius_iterator ri(coord_def(x, y), 1,</a>
<a name="ln1418">                                        (boxy ? C_ROUND : C_POINTY),</a>
<a name="ln1419">                                        true); ri; ++ri)</a>
<a name="ln1420">                {</a>
<a name="ln1421">                    if (_valid_coord(ls, lines, ri-&gt;x, ri-&gt;y, false))</a>
<a name="ln1422">                        if (strchr(passable, lines(*ri)))</a>
<a name="ln1423">                            neighbour_count++;</a>
<a name="ln1424">                }</a>
<a name="ln1425"> </a>
<a name="ln1426">                // store this coordinate if needed</a>
<a name="ln1427">                if (x_chance_in_y(percent_for_neighbours[neighbour_count], 100))</a>
<a name="ln1428">                    coord_to_replace.emplace_back(x, y);</a>
<a name="ln1429">            }</a>
<a name="ln1430"> </a>
<a name="ln1431">    // now go through and actually replace the positions</a>
<a name="ln1432">    for (coord_def c : coord_to_replace)</a>
<a name="ln1433">        lines(c) = replace;</a>
<a name="ln1434"> </a>
<a name="ln1435">    return 0;</a>
<a name="ln1436">}</a>
<a name="ln1437"> </a>
<a name="ln1438">LUAFN(dgn_connect_adjacent_rooms)</a>
<a name="ln1439">{</a>
<a name="ln1440">    LINES(ls, 1, map, lines);</a>
<a name="ln1441"> </a>
<a name="ln1442">    TABLE_STR(ls, wall, &quot;xcvbmn&quot;);</a>
<a name="ln1443">    TABLE_STR(ls, floor, &quot;.&quot;);</a>
<a name="ln1444">    TABLE_CHAR(ls, replace, '.');</a>
<a name="ln1445">    TABLE_INT(ls, max, 1);</a>
<a name="ln1446">    TABLE_INT(ls, min, max);</a>
<a name="ln1447">    TABLE_INT(ls, check_distance, 9999);</a>
<a name="ln1448"> </a>
<a name="ln1449">    int x1, y1, x2, y2;</a>
<a name="ln1450">    if (!_coords(ls, lines, x1, y1, x2, y2))</a>
<a name="ln1451">        return 0;</a>
<a name="ln1452"> </a>
<a name="ln1453">    // we never go right up to the border to avoid looking off the map edge</a>
<a name="ln1454">    if (x1 &lt; 1)</a>
<a name="ln1455">        x1 = 1;</a>
<a name="ln1456">    if (x2 &gt;= lines.width() - 1)</a>
<a name="ln1457">        x2 = lines.width() - 2;</a>
<a name="ln1458">    if (y1 &lt; 1)</a>
<a name="ln1459">        y1 = 1;</a>
<a name="ln1460">    if (y2 &gt;= lines.height() - 1)</a>
<a name="ln1461">        y2 = lines.height() - 2;</a>
<a name="ln1462"> </a>
<a name="ln1463">    if (min &lt; 0)</a>
<a name="ln1464">        return luaL_error(ls, &quot;Invalid min connections: %d&quot;, min);</a>
<a name="ln1465">    if (max &lt; min)</a>
<a name="ln1466">    {</a>
<a name="ln1467">        return luaL_error(ls, &quot;Invalid max connections: %d (min is %d)&quot;,</a>
<a name="ln1468">                          max, min);</a>
<a name="ln1469">    }</a>
<a name="ln1470"> </a>
<a name="ln1471">    int count = random_range(min, max);</a>
<a name="ln1472">    for (random_rectangle_iterator ri(coord_def(x1, y1),</a>
<a name="ln1473">                                      coord_def(x2, y2)); ri; ++ri)</a>
<a name="ln1474">    {</a>
<a name="ln1475">        if (count &lt;= 0)</a>
<a name="ln1476">        {</a>
<a name="ln1477">            // stop when have checked enough spots</a>
<a name="ln1478">            return 0;</a>
<a name="ln1479">        }</a>
<a name="ln1480"> </a>
<a name="ln1481">        int x = ri-&gt;x;</a>
<a name="ln1482">        int y = ri-&gt;y;</a>
<a name="ln1483"> </a>
<a name="ln1484">        if (strchr(wall, lines(*ri)))</a>
<a name="ln1485">        {</a>
<a name="ln1486">            if (strchr(floor, lines(x, y - 1))</a>
<a name="ln1487">                &amp;&amp; strchr(floor, lines(x, y + 1))</a>
<a name="ln1488">                &amp;&amp; (_wall_is_empty(lines, x, y, wall, floor,</a>
<a name="ln1489">                                   true, check_distance)))</a>
<a name="ln1490">            {</a>
<a name="ln1491">                lines(*ri) = replace;</a>
<a name="ln1492">            }</a>
<a name="ln1493">            else if (strchr(floor, lines(x - 1, y))</a>
<a name="ln1494">                     &amp;&amp; strchr(floor, lines(x + 1, y))</a>
<a name="ln1495">                     &amp;&amp; (_wall_is_empty(lines, x, y, wall, floor,</a>
<a name="ln1496">                                        false, check_distance)))</a>
<a name="ln1497">            {</a>
<a name="ln1498">                lines(*ri) = replace;</a>
<a name="ln1499">            }</a>
<a name="ln1500">        }</a>
<a name="ln1501">        count--;</a>
<a name="ln1502">    }</a>
<a name="ln1503"> </a>
<a name="ln1504">    return 0;</a>
<a name="ln1505">}</a>
<a name="ln1506"> </a>
<a name="ln1507">LUAFN(dgn_remove_disconnected_doors)</a>
<a name="ln1508">{</a>
<a name="ln1509">    LINES(ls, 1, map, lines);</a>
<a name="ln1510"> </a>
<a name="ln1511">    TABLE_STR(ls, door, &quot;+&quot;);</a>
<a name="ln1512">    TABLE_STR(ls, open, traversable_glyphs);</a>
<a name="ln1513">    TABLE_CHAR(ls, replace, '.');</a>
<a name="ln1514"> </a>
<a name="ln1515">    int x1, y1, x2, y2;</a>
<a name="ln1516">    if (!_coords(ls, lines, x1, y1, x2, y2))</a>
<a name="ln1517">        return 0;</a>
<a name="ln1518"> </a>
<a name="ln1519">    // we never go right up to the border to avoid looking off the map edge</a>
<a name="ln1520">    if (x1 &lt; 1)</a>
<a name="ln1521">        x1 = 1;</a>
<a name="ln1522">    if (x2 &gt;= lines.width() - 1)</a>
<a name="ln1523">        x2 = lines.width() - 2;</a>
<a name="ln1524">    if (y1 &lt; 1)</a>
<a name="ln1525">        y1 = 1;</a>
<a name="ln1526">    if (y2 &gt;= lines.height() - 1)</a>
<a name="ln1527">        y2 = lines.height() - 2;</a>
<a name="ln1528"> </a>
<a name="ln1529">    // TODO: Improve this to handle gates correctly.</a>
<a name="ln1530">    //  -&gt; Right now it just removes them.</a>
<a name="ln1531">    //  -&gt; I (infiniplex) tried to find formulas for this and there were</a>
<a name="ln1532">    //     too many weird cases.</a>
<a name="ln1533">    //    -&gt; 2-long hallway with doors at both end should not be a gate</a>
<a name="ln1534">    //    -&gt; end(s) of gate surround by wall should become wall</a>
<a name="ln1535">    //    -&gt; door glyphs in a shape other than a straight line</a>
<a name="ln1536">    //    -&gt; walls of either side of the middle of a gate when the ends</a>
<a name="ln1537">    //       are open may connect otherwise-disconnected regions</a>
<a name="ln1538">    //    -&gt; results must be direction-independent</a>
<a name="ln1539"> </a>
<a name="ln1540">    for (int y = y1; y &lt;= y2; ++y)</a>
<a name="ln1541">        for (int x = x1; x &lt;= x2; ++x)</a>
<a name="ln1542">            if (strchr(door, lines(x, y)))</a>
<a name="ln1543">            {</a>
<a name="ln1544">                //</a>
<a name="ln1545">                // This door is not part of a gate</a>
<a name="ln1546">                //  -&gt; There are a lot of cases here because doors</a>
<a name="ln1547">                //     can be at corners</a>
<a name="ln1548">                //  -&gt; We will choose the doors we want to keep</a>
<a name="ln1549">                //     and remove the rest of them</a>
<a name="ln1550">                //</a>
<a name="ln1551"> </a>
<a name="ln1552">                // which directions are open</a>
<a name="ln1553">                bool south     = strchr(open, lines(x,     y + 1));</a>
<a name="ln1554">                bool north     = strchr(open, lines(x,     y - 1));</a>
<a name="ln1555">                bool east      = strchr(open, lines(x + 1, y));</a>
<a name="ln1556">                bool west      = strchr(open, lines(x - 1, y));</a>
<a name="ln1557">                bool southeast = strchr(open, lines(x + 1, y + 1));</a>
<a name="ln1558">                bool northwest = strchr(open, lines(x - 1, y - 1));</a>
<a name="ln1559">                bool southwest = strchr(open, lines(x - 1, y + 1));</a>
<a name="ln1560">                bool northeast = strchr(open, lines(x + 1, y - 1));</a>
<a name="ln1561"> </a>
<a name="ln1562"> </a>
<a name="ln1563">                //</a>
<a name="ln1564">                // A door in an S-N straight wall</a>
<a name="ln1565">                //</a>
<a name="ln1566">                //     x      x     .x      x      x.</a>
<a name="ln1567">                //    .+.     +.     +.    .+     .+</a>
<a name="ln1568">                //     x     .x      x      x.     x</a>
<a name="ln1569">                //</a>
<a name="ln1570">                if (!south &amp;&amp; !north</a>
<a name="ln1571">                    &amp;&amp; (east || west)</a>
<a name="ln1572">                    &amp;&amp; (east || southeast || northeast)</a>
<a name="ln1573">                    &amp;&amp; (west || southwest || northwest))</a>
<a name="ln1574">                {</a>
<a name="ln1575">                    continue;</a>
<a name="ln1576">                }</a>
<a name="ln1577"> </a>
<a name="ln1578">                //</a>
<a name="ln1579">                // A door in an E-W straight wall</a>
<a name="ln1580">                //</a>
<a name="ln1581">                //     .     .        .     .      .</a>
<a name="ln1582">                //    x+x    x+x    x+x    x+x    x+x</a>
<a name="ln1583">                //     .      .      .     .        .</a>
<a name="ln1584">                //</a>
<a name="ln1585">                if (!east &amp;&amp; !west</a>
<a name="ln1586">                    &amp;&amp; (south || north)</a>
<a name="ln1587">                    &amp;&amp; (south || northeast || northwest)</a>
<a name="ln1588">                    &amp;&amp; (north || southeast || southwest))</a>
<a name="ln1589">                {</a>
<a name="ln1590">                    continue;</a>
<a name="ln1591">                }</a>
<a name="ln1592"> </a>
<a name="ln1593">                //</a>
<a name="ln1594">                // A door in a SE-NW diagonal</a>
<a name="ln1595">                //</a>
<a name="ln1596">                //    .x     ..     .xx</a>
<a name="ln1597">                //    x+.    .+x    x+x</a>
<a name="ln1598">                //     ..     x.    xx.</a>
<a name="ln1599">                //</a>
<a name="ln1600">                if (southeast &amp;&amp; northwest &amp;&amp; south == east &amp;&amp; north == west)</a>
<a name="ln1601">                {</a>
<a name="ln1602">                    if (south != west)</a>
<a name="ln1603">                        continue;</a>
<a name="ln1604">                    else if (!south &amp;&amp; !west &amp;&amp; !southwest &amp;&amp; !northeast)</a>
<a name="ln1605">                        continue;</a>
<a name="ln1606">                }</a>
<a name="ln1607"> </a>
<a name="ln1608">                //</a>
<a name="ln1609">                // A door in a SW-NE diagonal</a>
<a name="ln1610">                //</a>
<a name="ln1611">                //     ..     x.    xx.</a>
<a name="ln1612">                //    x+.    .+x    x+x</a>
<a name="ln1613">                //    .x     ..     .xx</a>
<a name="ln1614">                //</a>
<a name="ln1615">                if (southwest &amp;&amp; northeast &amp;&amp; south == west &amp;&amp; north == east)</a>
<a name="ln1616">                {</a>
<a name="ln1617">                    if (south != east)</a>
<a name="ln1618">                        continue;</a>
<a name="ln1619">                    else if (!south &amp;&amp; !east &amp;&amp; !southeast &amp;&amp; !northwest)</a>
<a name="ln1620">                        continue;</a>
<a name="ln1621">                }</a>
<a name="ln1622"> </a>
<a name="ln1623">                // if we get her, the door is invalid</a>
<a name="ln1624">                lines(x, y) = replace;</a>
<a name="ln1625">            }</a>
<a name="ln1626"> </a>
<a name="ln1627">    return 0;</a>
<a name="ln1628">}</a>
<a name="ln1629"> </a>
<a name="ln1630">LUAFN(dgn_add_windows)</a>
<a name="ln1631">{</a>
<a name="ln1632">    LINES(ls, 1, map, lines);</a>
<a name="ln1633"> </a>
<a name="ln1634">    TABLE_STR(ls, wall, &quot;xcvbmn&quot;);</a>
<a name="ln1635">    TABLE_STR(ls, open, traversable_glyphs);</a>
<a name="ln1636">    TABLE_CHAR(ls, window, 'm');</a>
<a name="ln1637"> </a>
<a name="ln1638">    int x1, y1, x2, y2;</a>
<a name="ln1639">    if (!_coords(ls, lines, x1, y1, x2, y2))</a>
<a name="ln1640">        return 0;</a>
<a name="ln1641"> </a>
<a name="ln1642">    // we never go right up to the border to avoid looking off the map edge</a>
<a name="ln1643">    if (x1 &lt; 1)</a>
<a name="ln1644">        x1 = 1;</a>
<a name="ln1645">    if (x2 &gt;= lines.width() - 1)</a>
<a name="ln1646">        x2 = lines.width() - 2;</a>
<a name="ln1647">    if (y1 &lt; 1)</a>
<a name="ln1648">        y1 = 1;</a>
<a name="ln1649">    if (y2 &gt;= lines.height() - 1)</a>
<a name="ln1650">        y2 = lines.height() - 2;</a>
<a name="ln1651"> </a>
<a name="ln1652">    for (int y = y1; y &lt;= y2; ++y)</a>
<a name="ln1653">        for (int x = x1; x &lt;= x2; ++x)</a>
<a name="ln1654">            if (strchr(wall, lines(x, y)))</a>
<a name="ln1655">            {</a>
<a name="ln1656">                // which directions are open</a>
<a name="ln1657">                bool south_open     = strchr(open, lines(x,     y + 1));</a>
<a name="ln1658">                bool north_open     = strchr(open, lines(x,     y - 1));</a>
<a name="ln1659">                bool east_open      = strchr(open, lines(x + 1, y));</a>
<a name="ln1660">                bool west_open      = strchr(open, lines(x - 1, y));</a>
<a name="ln1661">                bool southeast_open = strchr(open, lines(x + 1, y + 1));</a>
<a name="ln1662">                bool northwest_open = strchr(open, lines(x - 1, y - 1));</a>
<a name="ln1663">                bool southwest_open = strchr(open, lines(x - 1, y + 1));</a>
<a name="ln1664">                bool northeast_open = strchr(open, lines(x + 1, y - 1));</a>
<a name="ln1665"> </a>
<a name="ln1666">                // which directions are blocked by walls</a>
<a name="ln1667">                bool south_blocked     = strchr(wall, lines(x,     y + 1));</a>
<a name="ln1668">                bool north_blocked     = strchr(wall, lines(x,     y - 1));</a>
<a name="ln1669">                bool east_blocked      = strchr(wall, lines(x + 1, y));</a>
<a name="ln1670">                bool west_blocked      = strchr(wall, lines(x - 1, y));</a>
<a name="ln1671">                bool southeast_blocked = strchr(wall, lines(x + 1, y + 1));</a>
<a name="ln1672">                bool northwest_blocked = strchr(wall, lines(x - 1, y - 1));</a>
<a name="ln1673">                bool southwest_blocked = strchr(wall, lines(x - 1, y + 1));</a>
<a name="ln1674">                bool northeast_blocked = strchr(wall, lines(x + 1, y - 1));</a>
<a name="ln1675"> </a>
<a name="ln1676">                // a simple window in a straight wall</a>
<a name="ln1677">                //</a>
<a name="ln1678">                //   .    x</a>
<a name="ln1679">                //  xmx  .m.</a>
<a name="ln1680">                //   .    x</a>
<a name="ln1681">                //</a>
<a name="ln1682">                if (south_open &amp;&amp; north_open &amp;&amp; east_blocked &amp;&amp; west_blocked)</a>
<a name="ln1683">                    lines(x, y) = window;</a>
<a name="ln1684">                if (east_open &amp;&amp; west_open &amp;&amp; south_blocked &amp;&amp; north_blocked)</a>
<a name="ln1685">                    lines(x, y) = window;</a>
<a name="ln1686"> </a>
<a name="ln1687">                // a diagonal window in a straight segment of a bent wall</a>
<a name="ln1688">                //</a>
<a name="ln1689">                //  . x  x .   x    x</a>
<a name="ln1690">                //  xmx  xmx  .m.  .m.</a>
<a name="ln1691">                //  x .  . x   x    x</a>
<a name="ln1692">                //</a>
<a name="ln1693">                if (east_blocked &amp;&amp; west_blocked)</a>
<a name="ln1694">                {</a>
<a name="ln1695">                    if (southeast_open &amp;&amp; northwest_open</a>
<a name="ln1696">                        &amp;&amp; southwest_blocked &amp;&amp; northeast_blocked)</a>
<a name="ln1697">                    {</a>
<a name="ln1698">                        lines(x, y) = window;</a>
<a name="ln1699">                    }</a>
<a name="ln1700">                    if (southwest_open &amp;&amp; northeast_open</a>
<a name="ln1701">                        &amp;&amp; southeast_blocked &amp;&amp; northwest_blocked)</a>
<a name="ln1702">                    {</a>
<a name="ln1703">                        lines(x, y) = window;</a>
<a name="ln1704">                    }</a>
<a name="ln1705">                }</a>
<a name="ln1706"> </a>
<a name="ln1707">                // a window in a 3-wide diagonal wall</a>
<a name="ln1708">                //</a>
<a name="ln1709">                //  .x    x.</a>
<a name="ln1710">                //  xmx  xmx</a>
<a name="ln1711">                //   x.  .x</a>
<a name="ln1712">                //</a>
<a name="ln1713">                if (   south_blocked &amp;&amp; north_blocked</a>
<a name="ln1714">                    &amp;&amp; east_blocked  &amp;&amp; west_blocked)</a>
<a name="ln1715">                {</a>
<a name="ln1716">                    if (southeast_open &amp;&amp; northwest_open)</a>
<a name="ln1717">                        lines(x, y) = window;</a>
<a name="ln1718">                    if (southwest_open &amp;&amp; northeast_open)</a>
<a name="ln1719">                        lines(x, y) = window;</a>
<a name="ln1720">                }</a>
<a name="ln1721"> </a>
<a name="ln1722">                // a window in a 2-wide diagonal wall</a>
<a name="ln1723">                //  -&gt; this will change the whole wall</a>
<a name="ln1724">                //</a>
<a name="ln1725">                //   .    .   .x    x.</a>
<a name="ln1726">                //  .mx  xm.  xm.  .mx</a>
<a name="ln1727">                //   x.  .x    .    .</a>
<a name="ln1728">                //</a>
<a name="ln1729">                if (south_blocked &amp;&amp; east_blocked</a>
<a name="ln1730">                    &amp;&amp; north_open &amp;&amp; west_open &amp;&amp; southeast_open)</a>
<a name="ln1731">                {</a>
<a name="ln1732">                    lines(x, y) = window;</a>
<a name="ln1733">                }</a>
<a name="ln1734">                if (south_blocked &amp;&amp; west_blocked</a>
<a name="ln1735">                    &amp;&amp; north_open &amp;&amp; east_open &amp;&amp; southwest_open)</a>
<a name="ln1736">                {</a>
<a name="ln1737">                    lines(x, y) = window;</a>
<a name="ln1738">                }</a>
<a name="ln1739">                if (north_blocked &amp;&amp; west_blocked</a>
<a name="ln1740">                    &amp;&amp; south_open &amp;&amp; east_open &amp;&amp; northwest_open)</a>
<a name="ln1741">                {</a>
<a name="ln1742">                    lines(x, y) = window;</a>
<a name="ln1743">                }</a>
<a name="ln1744">                if (north_blocked &amp;&amp; east_blocked</a>
<a name="ln1745">                    &amp;&amp; south_open &amp;&amp; west_open &amp;&amp; northeast_open)</a>
<a name="ln1746">                {</a>
<a name="ln1747">                    lines(x, y) = window;</a>
<a name="ln1748">                }</a>
<a name="ln1749">            }</a>
<a name="ln1750"> </a>
<a name="ln1751">    return 0;</a>
<a name="ln1752">}</a>
<a name="ln1753"> </a>
<a name="ln1754">LUAFN(dgn_replace_area)</a>
<a name="ln1755">{</a>
<a name="ln1756">    LINES(ls, 1, map, lines);</a>
<a name="ln1757"> </a>
<a name="ln1758">    TABLE_STR(ls, find, 0);</a>
<a name="ln1759">    TABLE_CHAR(ls, replace, '\0');</a>
<a name="ln1760"> </a>
<a name="ln1761">    int x1, y1, x2, y2;</a>
<a name="ln1762">    if (!_coords(ls, lines, x1, y1, x2, y2))</a>
<a name="ln1763">        return 0;</a>
<a name="ln1764"> </a>
<a name="ln1765">    for (int y = y1; y &lt;= y2; ++y)</a>
<a name="ln1766">        for (int x = x1; x &lt;= x2; ++x)</a>
<a name="ln1767">            if (strchr(find, lines(x, y)))</a>
<a name="ln1768">                lines(x, y) = replace;</a>
<a name="ln1769"> </a>
<a name="ln1770">    return 0;</a>
<a name="ln1771">}</a>
<a name="ln1772"> </a>
<a name="ln1773">LUAFN(dgn_replace_first)</a>
<a name="ln1774">{</a>
<a name="ln1775">    LINES(ls, 1, map, lines);</a>
<a name="ln1776"> </a>
<a name="ln1777">    TABLE_INT(ls, x, 0);</a>
<a name="ln1778">    TABLE_INT(ls, y, 0);</a>
<a name="ln1779">    TABLE_INT(ls, xdir, 2);</a>
<a name="ln1780">    TABLE_INT(ls, ydir, 2);</a>
<a name="ln1781">    TABLE_CHAR(ls, find, '\0');</a>
<a name="ln1782">    TABLE_CHAR(ls, replace, '\0');</a>
<a name="ln1783">    TABLE_BOOL(ls, required, false);</a>
<a name="ln1784"> </a>
<a name="ln1785">    if (!_valid_coord(ls, lines, x, y))</a>
<a name="ln1786">        return 0;</a>
<a name="ln1787"> </a>
<a name="ln1788">    if (xdir &lt; -1 || xdir &gt; 1)</a>
<a name="ln1789">        return luaL_error(ls, &quot;Invalid xdir: %d&quot;, xdir);</a>
<a name="ln1790"> </a>
<a name="ln1791">    if (ydir &lt; -1 || ydir &gt; 1)</a>
<a name="ln1792">        return luaL_error(ls, &quot;Invalid ydir: %d&quot;, ydir);</a>
<a name="ln1793"> </a>
<a name="ln1794">    while (lines.in_bounds(coord_def(x, y)))</a>
<a name="ln1795">    {</a>
<a name="ln1796">        if (lines(x, y) == find)</a>
<a name="ln1797">        {</a>
<a name="ln1798">            lines(x, y) = replace;</a>
<a name="ln1799">            return 0;</a>
<a name="ln1800">        }</a>
<a name="ln1801"> </a>
<a name="ln1802">        x += xdir;</a>
<a name="ln1803">        y += ydir;</a>
<a name="ln1804">    }</a>
<a name="ln1805"> </a>
<a name="ln1806">    if (required)</a>
<a name="ln1807">        return luaL_error(ls, &quot;Could not find feature '%c' to replace&quot;, find);</a>
<a name="ln1808"> </a>
<a name="ln1809">    return 0;</a>
<a name="ln1810">}</a>
<a name="ln1811"> </a>
<a name="ln1812">LUAFN(dgn_replace_random)</a>
<a name="ln1813">{</a>
<a name="ln1814">    LINES(ls, 1, map, lines);</a>
<a name="ln1815"> </a>
<a name="ln1816">    TABLE_CHAR(ls, find, '\0');</a>
<a name="ln1817">    TABLE_CHAR(ls, replace, '\0');</a>
<a name="ln1818">    TABLE_BOOL(ls, required, false);</a>
<a name="ln1819"> </a>
<a name="ln1820">    int x1, y1, x2, y2;</a>
<a name="ln1821">    if (!_coords(ls, lines, x1, y1, x2, y2))</a>
<a name="ln1822">        return 0;</a>
<a name="ln1823"> </a>
<a name="ln1824">    int count = (x2 - x1 + 1) * (y2 - y1 + 1);</a>
<a name="ln1825">    if (!count)</a>
<a name="ln1826">    {</a>
<a name="ln1827">        if (required)</a>
<a name="ln1828">            luaL_error(ls, &quot;%s&quot;, &quot;No elements to replace&quot;);</a>
<a name="ln1829">        return 0;</a>
<a name="ln1830">    }</a>
<a name="ln1831"> </a>
<a name="ln1832">    vector&lt;coord_def&gt; loc;</a>
<a name="ln1833">    loc.reserve(count);</a>
<a name="ln1834"> </a>
<a name="ln1835">    for (int y = y1; y &lt;= y2; ++y)</a>
<a name="ln1836">        for (int x = x1; x &lt;= x2; ++x)</a>
<a name="ln1837">            if (lines(x, y) == find)</a>
<a name="ln1838">                loc.emplace_back(x, y);</a>
<a name="ln1839"> </a>
<a name="ln1840">    if (loc.empty())</a>
<a name="ln1841">    {</a>
<a name="ln1842">        if (required)</a>
<a name="ln1843">            luaL_error(ls, &quot;Could not find '%c'&quot;, find);</a>
<a name="ln1844">        return 0;</a>
<a name="ln1845">    }</a>
<a name="ln1846"> </a>
<a name="ln1847">    int idx = random2(loc.size());</a>
<a name="ln1848">    lines(loc[idx]) = replace;</a>
<a name="ln1849"> </a>
<a name="ln1850">    return 0;</a>
<a name="ln1851">}</a>
<a name="ln1852"> </a>
<a name="ln1853">LUAFN(dgn_replace_closest)</a>
<a name="ln1854">{</a>
<a name="ln1855">    LINES(ls, 1, map, lines);</a>
<a name="ln1856"> </a>
<a name="ln1857">    TABLE_INT(ls, x, 0);</a>
<a name="ln1858">    TABLE_INT(ls, y, 0);</a>
<a name="ln1859">    TABLE_CHAR(ls, find, '\0');</a>
<a name="ln1860">    TABLE_CHAR(ls, replace, '\0');</a>
<a name="ln1861">    TABLE_BOOL(ls, required, false);</a>
<a name="ln1862"> </a>
<a name="ln1863">    coord_def center(x, y);</a>
<a name="ln1864"> </a>
<a name="ln1865">    int x1, y1, x2, y2;</a>
<a name="ln1866">    if (!_coords(ls, lines, x1, y1, x2, y2))</a>
<a name="ln1867">        return 0;</a>
<a name="ln1868"> </a>
<a name="ln1869">    int count = (x2 - x1 + 1) * (y2 - y1 + 1);</a>
<a name="ln1870">    if (!count)</a>
<a name="ln1871">    {</a>
<a name="ln1872">        if (required)</a>
<a name="ln1873">            luaL_error(ls, &quot;%s&quot;, &quot;No elements to replace&quot;);</a>
<a name="ln1874">        return 0;</a>
<a name="ln1875">    }</a>
<a name="ln1876"> </a>
<a name="ln1877">    vector&lt;coord_def&gt; loc;</a>
<a name="ln1878">    loc.reserve(count);</a>
<a name="ln1879"> </a>
<a name="ln1880">    int best_distance = 10000;</a>
<a name="ln1881">    unsigned int best_count = 0;</a>
<a name="ln1882">    coord_def best_coord;</a>
<a name="ln1883"> </a>
<a name="ln1884">    for (int this_y = y1; this_y &lt;= y2; ++this_y)</a>
<a name="ln1885">        for (int this_x = x1; this_x &lt;= x2; ++this_x)</a>
<a name="ln1886">            if (lines(this_x, this_y) == find)</a>
<a name="ln1887">            {</a>
<a name="ln1888">                coord_def here(this_x, this_y);</a>
<a name="ln1889">                int distance = here.distance_from(center);</a>
<a name="ln1890">                if (distance &lt; best_distance)</a>
<a name="ln1891">                {</a>
<a name="ln1892">                    best_distance = distance;</a>
<a name="ln1893">                    best_count = 1;</a>
<a name="ln1894">                    best_coord = here;</a>
<a name="ln1895">                }</a>
<a name="ln1896">                else if (distance == best_distance)</a>
<a name="ln1897">                {</a>
<a name="ln1898">                    best_count++;</a>
<a name="ln1899">                    if (one_chance_in(best_count))</a>
<a name="ln1900">                        best_coord = here;</a>
<a name="ln1901">                }</a>
<a name="ln1902">            }</a>
<a name="ln1903"> </a>
<a name="ln1904">    if (best_count == 0)</a>
<a name="ln1905">    {</a>
<a name="ln1906">        if (required)</a>
<a name="ln1907">            return luaL_error(ls, &quot;Could not find '%c'&quot;, find);</a>
<a name="ln1908">        return 0;</a>
<a name="ln1909">    }</a>
<a name="ln1910"> </a>
<a name="ln1911">    lines(best_coord) = replace;</a>
<a name="ln1912"> </a>
<a name="ln1913">    return 0;</a>
<a name="ln1914">}</a>
<a name="ln1915"> </a>
<a name="ln1916">LUAFN(dgn_smear_map)</a>
<a name="ln1917">{</a>
<a name="ln1918">    LINES(ls, 1, map, lines);</a>
<a name="ln1919"> </a>
<a name="ln1920">    TABLE_INT(ls, iterations, 1);</a>
<a name="ln1921">    TABLE_CHAR(ls, smear, 'x');</a>
<a name="ln1922">    TABLE_STR(ls, onto, &quot;.&quot;);</a>
<a name="ln1923">    TABLE_BOOL(ls, boxy, false);</a>
<a name="ln1924"> </a>
<a name="ln1925">    const int border = 1;</a>
<a name="ln1926">    int x1, y1, x2, y2;</a>
<a name="ln1927">    if (!_coords(ls, lines, x1, y1, x2, y2, border))</a>
<a name="ln1928">        return 0;</a>
<a name="ln1929"> </a>
<a name="ln1930">    const int max_test_per_iteration = 10;</a>
<a name="ln1931">    int sanity = 0;</a>
<a name="ln1932">    int max_sanity = iterations * max_test_per_iteration;</a>
<a name="ln1933"> </a>
<a name="ln1934">    for (int i = 0; i &lt; iterations; i++)</a>
<a name="ln1935">    {</a>
<a name="ln1936">        bool diagonals, straights;</a>
<a name="ln1937">        coord_def mc;</a>
<a name="ln1938"> </a>
<a name="ln1939">        do</a>
<a name="ln1940">        {</a>
<a name="ln1941">            do</a>
<a name="ln1942">            {</a>
<a name="ln1943">                if (sanity++ &gt; max_sanity)</a>
<a name="ln1944">                    return 0;</a>
<a name="ln1945"> </a>
<a name="ln1946">                mc.x = random_range(x1+border, y2-border);</a>
<a name="ln1947">                mc.y = random_range(y1+border, y2-border);</a>
<a name="ln1948">            }</a>
<a name="ln1949">            while (onto[0] &amp;&amp; !strchr(onto, lines(mc)));</a>
<a name="ln1950"> </a>
<a name="ln1951">            // Is there a &quot;smear&quot; feature along the diagonal from mc?</a>
<a name="ln1952">            diagonals = lines(mc.x + 1, mc.y + 1) == smear</a>
<a name="ln1953">                        || lines(mc.x - 1, mc.y + 1) == smear</a>
<a name="ln1954">                        || lines(mc.x - 1, mc.y - 1) == smear</a>
<a name="ln1955">                        || lines(mc.x + 1, mc.y - 1) == smear;</a>
<a name="ln1956"> </a>
<a name="ln1957">            // Is there a &quot;smear&quot; feature up, down, left, or right from mc?</a>
<a name="ln1958">            straights = lines(mc.x + 1, mc.y) == smear</a>
<a name="ln1959">                        || lines(mc.x - 1, mc.y) == smear</a>
<a name="ln1960">                        || lines(mc.x, mc.y + 1) == smear</a>
<a name="ln1961">                        || lines(mc.x, mc.y - 1) == smear;</a>
<a name="ln1962">        }</a>
<a name="ln1963">        while (!straights &amp;&amp; (boxy || !diagonals));</a>
<a name="ln1964"> </a>
<a name="ln1965">        lines(mc) = smear;</a>
<a name="ln1966">    }</a>
<a name="ln1967"> </a>
<a name="ln1968">    return 0;</a>
<a name="ln1969">}</a>
<a name="ln1970"> </a>
<a name="ln1971">LUAFN(dgn_spotty_map)</a>
<a name="ln1972">{</a>
<a name="ln1973">    LINES(ls, 1, map, lines);</a>
<a name="ln1974"> </a>
<a name="ln1975">    TABLE_STR(ls, replace, &quot;x&quot;);</a>
<a name="ln1976">    TABLE_CHAR(ls, fill, '.');</a>
<a name="ln1977">    TABLE_BOOL(ls, boxy, true);</a>
<a name="ln1978">    TABLE_INT(ls, iterations, random2(boxy ? 750 : 1500));</a>
<a name="ln1979"> </a>
<a name="ln1980">    const int border = 4;</a>
<a name="ln1981">    int x1, y1, x2, y2;</a>
<a name="ln1982">    if (!_coords(ls, lines, x1, y1, x2, y2, border))</a>
<a name="ln1983">        return 0;</a>
<a name="ln1984"> </a>
<a name="ln1985">    const int max_test_per_iteration = 10;</a>
<a name="ln1986">    int sanity = 0;</a>
<a name="ln1987">    int max_sanity = iterations * max_test_per_iteration;</a>
<a name="ln1988"> </a>
<a name="ln1989">    for (int i = 0; i &lt; iterations; i++)</a>
<a name="ln1990">    {</a>
<a name="ln1991">        int x, y;</a>
<a name="ln1992">        do</a>
<a name="ln1993">        {</a>
<a name="ln1994">            if (sanity++ &gt; max_sanity)</a>
<a name="ln1995">                return 0;</a>
<a name="ln1996"> </a>
<a name="ln1997">            x = random_range(x1 + border, x2 - border);</a>
<a name="ln1998">            y = random_range(y1 + border, y2 - border);</a>
<a name="ln1999">        }</a>
<a name="ln2000">        while (strchr(replace, lines(x, y))</a>
<a name="ln2001">               &amp;&amp; strchr(replace, lines(x-1, y))</a>
<a name="ln2002">               &amp;&amp; strchr(replace, lines(x+1, y))</a>
<a name="ln2003">               &amp;&amp; strchr(replace, lines(x, y-1))</a>
<a name="ln2004">               &amp;&amp; strchr(replace, lines(x, y+1))</a>
<a name="ln2005">               &amp;&amp; strchr(replace, lines(x-2, y))</a>
<a name="ln2006">               &amp;&amp; strchr(replace, lines(x+2, y))</a>
<a name="ln2007">               &amp;&amp; strchr(replace, lines(x, y-2))</a>
<a name="ln2008">               &amp;&amp; strchr(replace, lines(x, y+2)));</a>
<a name="ln2009"> </a>
<a name="ln2010">        for (radius_iterator ai(coord_def(x, y), boxy ? 2 : 1, C_CIRCLE,</a>
<a name="ln2011">                                false); ai; ++ai)</a>
<a name="ln2012">        {</a>
<a name="ln2013">            if (strchr(replace, lines(*ai)))</a>
<a name="ln2014">                lines(*ai) = fill;</a>
<a name="ln2015">        }</a>
<a name="ln2016">    }</a>
<a name="ln2017"> </a>
<a name="ln2018">    return 0;</a>
<a name="ln2019">}</a>
<a name="ln2020"> </a>
<a name="ln2021">LUAFN(dgn_add_pools)</a>
<a name="ln2022">{</a>
<a name="ln2023">    LINES(ls, 1, map, lines);</a>
<a name="ln2024"> </a>
<a name="ln2025">    TABLE_STR(ls, replace, &quot;.&quot;);</a>
<a name="ln2026">    TABLE_CHAR(ls, border, '.');</a>
<a name="ln2027">    TABLE_INT(ls, pool_size, 100);</a>
<a name="ln2028">    TABLE_INT(ls, seed_separation, 2);</a>
<a name="ln2029"> </a>
<a name="ln2030">    vector&lt;char&gt; fill_glyphs = _pool_fill_glyphs_from_table(ls, &quot;contents&quot;);</a>
<a name="ln2031"> </a>
<a name="ln2032">    int x1, y1, x2, y2;</a>
<a name="ln2033">    if (!_coords(ls, lines, x1, y1, x2, y2))</a>
<a name="ln2034">        return 0;</a>
<a name="ln2035"> </a>
<a name="ln2036">    int size_x = x2 - x1 + 1;</a>
<a name="ln2037">    int size_y = y2 - y1 + 1;</a>
<a name="ln2038"> </a>
<a name="ln2039">    //</a>
<a name="ln2040">    //  The basic ideas here is that we place a number of</a>
<a name="ln2041">    //    pool &quot;seeds&quot; on the map and spread them outward</a>
<a name="ln2042">    //    randomly until they run into each other. We never</a>
<a name="ln2043">    //    fill in the last cell, so they never actually</a>
<a name="ln2044">    //    touch and we get paths between them.</a>
<a name="ln2045">    //</a>
<a name="ln2046">    //  The algorithm we use to spread the pools is like a</a>
<a name="ln2047">    //    depth-/breadth-first search, except that:</a>
<a name="ln2048">    //      1. We choose a random element from the open list</a>
<a name="ln2049">    //      2. We have multiple starting locations, each</a>
<a name="ln2050">    //         with its own &quot;closed&quot; value</a>
<a name="ln2051">    //      3. We mark all cells bordered by 2 (or more)</a>
<a name="ln2052">    //         distinct non-BORDER closed values with special</a>
<a name="ln2053">    //         closed value BORDER</a>
<a name="ln2054">    //</a>
<a name="ln2055">    //  In the end, we used the &quot;closed&quot; values to determine</a>
<a name="ln2056">    //    which pool we are in. The BORDER value indicates</a>
<a name="ln2057">    //    a path between pools.</a>
<a name="ln2058">    //</a>
<a name="ln2059"> </a>
<a name="ln2060">    // NO_POOL</a>
<a name="ln2061">    //  -&gt; must be lowest constant</a>
<a name="ln2062">    //  -&gt; must match _get_pool_seed_positions</a>
<a name="ln2063">    const int NO_POOL   = 999997;</a>
<a name="ln2064">    const int IN_LIST   = 999998;</a>
<a name="ln2065">    const int BORDER    = 999999;</a>
<a name="ln2066">    const int FORBIDDEN = 1000000;</a>
<a name="ln2067"> </a>
<a name="ln2068">    // Step 1: Make a 2D array to store which pool each cell is part of</a>
<a name="ln2069">    //    -&gt; We use nested vectors to store this. We cannot use</a>
<a name="ln2070">    //       a fixedarray because we don't know the size at</a>
<a name="ln2071">    //       compile time.</a>
<a name="ln2072"> </a>
<a name="ln2073">    vector&lt;vector&lt;int&gt; &gt; pool_index(size_x, vector&lt;int&gt;(size_y, FORBIDDEN));</a>
<a name="ln2074">    for (int x = 0; x &lt; size_x; x++)</a>
<a name="ln2075">        for (int y = 0; y &lt; size_y; y++)</a>
<a name="ln2076">        {</a>
<a name="ln2077">            if (strchr(replace, lines(x + x1, y + y1)))</a>
<a name="ln2078">                pool_index[x][y] = NO_POOL;</a>
<a name="ln2079">        }</a>
<a name="ln2080"> </a>
<a name="ln2081">    // Step 2: Place the pool seeds and add their neighbours to the open list</a>
<a name="ln2082"> </a>
<a name="ln2083">    vector&lt;coord_def&gt; pool_seeds = _get_pool_seed_positions(pool_index,</a>
<a name="ln2084">                                                            pool_size,</a>
<a name="ln2085">                                                            seed_separation);</a>
<a name="ln2086">    vector&lt;coord_def&gt; open_list;</a>
<a name="ln2087"> </a>
<a name="ln2088">    for (unsigned int pool = 0; pool &lt; pool_seeds.size(); pool++)</a>
<a name="ln2089">    {</a>
<a name="ln2090">        int x = pool_seeds[pool].x;</a>
<a name="ln2091">        int y = pool_seeds[pool].y;</a>
<a name="ln2092"> </a>
<a name="ln2093">        pool_index[x][y] = pool;</a>
<a name="ln2094"> </a>
<a name="ln2095">        // add neighbours to open list</a>
<a name="ln2096">        for (orth_adjacent_iterator ai(pool_seeds[pool]); ai; ++ai)</a>
<a name="ln2097">            if (_valid_coord(ls, lines, ai-&gt;x, ai-&gt;y, false))</a>
<a name="ln2098">            {</a>
<a name="ln2099">                pool_index[ai-&gt;x][ai-&gt;y] = IN_LIST;</a>
<a name="ln2100">                open_list.push_back(*ai);</a>
<a name="ln2101">            }</a>
<a name="ln2102">    }</a>
<a name="ln2103"> </a>
<a name="ln2104">    // Step 3: Spread out pools as far as possible</a>
<a name="ln2105"> </a>
<a name="ln2106">    while (!open_list.empty())</a>
<a name="ln2107">    {</a>
<a name="ln2108">        // remove a random position from the open list</a>
<a name="ln2109">        int index_chosen = random2(open_list.size());</a>
<a name="ln2110">        coord_def chosen_coord = open_list[index_chosen];</a>
<a name="ln2111">        open_list[index_chosen] = open_list.back();</a>
<a name="ln2112">        open_list.pop_back();</a>
<a name="ln2113"> </a>
<a name="ln2114">        // choose which neighbouring pool to join</a>
<a name="ln2115">        int chosen_pool = NO_POOL;</a>
<a name="ln2116">        for (adjacent_iterator ai(chosen_coord); ai; ++ai)</a>
<a name="ln2117">            if (_valid_coord(ls, lines, ai-&gt;x, ai-&gt;y, false))</a>
<a name="ln2118">            {</a>
<a name="ln2119">                int neighbour_pool = pool_index[ai-&gt;x][ai-&gt;y];</a>
<a name="ln2120">                if (neighbour_pool &lt; NO_POOL)</a>
<a name="ln2121">                {</a>
<a name="ln2122">                    // this is a valid pool, consider it</a>
<a name="ln2123">                    if (chosen_pool == NO_POOL)</a>
<a name="ln2124">                        chosen_pool = neighbour_pool;</a>
<a name="ln2125">                    else if (chosen_pool == neighbour_pool)</a>
<a name="ln2126">                        ; // already correct</a>
<a name="ln2127">                    else</a>
<a name="ln2128">                    {</a>
<a name="ln2129">                        // this is the path between pools</a>
<a name="ln2130">                        chosen_pool = BORDER;</a>
<a name="ln2131">                        break;</a>
<a name="ln2132">                    }</a>
<a name="ln2133">                }</a>
<a name="ln2134">                else if (neighbour_pool == FORBIDDEN)</a>
<a name="ln2135">                {</a>
<a name="ln2136">                    // next to a wall</a>
<a name="ln2137">                    chosen_pool = BORDER;</a>
<a name="ln2138">                    break;</a>
<a name="ln2139">                }</a>
<a name="ln2140">            }</a>
<a name="ln2141"> </a>
<a name="ln2142">        if (chosen_pool != NO_POOL)</a>
<a name="ln2143">        {</a>
<a name="ln2144">            // add this cell to the appropriate pool</a>
<a name="ln2145">            pool_index[chosen_coord.x][chosen_coord.y] = chosen_pool;</a>
<a name="ln2146"> </a>
<a name="ln2147">            // add neighbours to open list</a>
<a name="ln2148">            for (orth_adjacent_iterator ai(chosen_coord); ai; ++ai)</a>
<a name="ln2149">                if (_valid_coord(ls, lines, ai-&gt;x, ai-&gt;y, false)</a>
<a name="ln2150">                    &amp;&amp; pool_index[ai-&gt;x][ai-&gt;y] == NO_POOL)</a>
<a name="ln2151">                {</a>
<a name="ln2152">                    pool_index[ai-&gt;x][ai-&gt;y] = IN_LIST;</a>
<a name="ln2153">                    open_list.push_back(*ai);</a>
<a name="ln2154">                }</a>
<a name="ln2155">        }</a>
<a name="ln2156">        else</a>
<a name="ln2157">        {</a>
<a name="ln2158">            // a default, although I do not know why we ever get here</a>
<a name="ln2159">            pool_index[chosen_coord.x][chosen_coord.y] = NO_POOL;</a>
<a name="ln2160">        }</a>
<a name="ln2161">    }</a>
<a name="ln2162"> </a>
<a name="ln2163">    // Step 4: Add the pools to the map</a>
<a name="ln2164"> </a>
<a name="ln2165">    vector&lt;char&gt; pool_glyphs(pool_seeds.size(), '\0');</a>
<a name="ln2166">    for (char &amp;gly : pool_glyphs)</a>
<a name="ln2167">        gly = fill_glyphs[random2(fill_glyphs.size())];</a>
<a name="ln2168"> </a>
<a name="ln2169">    for (int x = 0; x &lt; size_x; x++)</a>
<a name="ln2170">        for (int y = 0; y &lt; size_y; y++)</a>
<a name="ln2171">            {</a>
<a name="ln2172">            int index = pool_index[x][y];</a>
<a name="ln2173">            if (index &lt; (int)(pool_glyphs.size()))</a>
<a name="ln2174">                lines(x + x1, y + y1) = pool_glyphs[index];</a>
<a name="ln2175">            else if (index == NO_POOL || index == BORDER)</a>
<a name="ln2176">                lines(x + x1, y + y1) = border;</a>
<a name="ln2177">            else if (index == FORBIDDEN)</a>
<a name="ln2178">                ; // leave it alone</a>
<a name="ln2179">            else</a>
<a name="ln2180">            {</a>
<a name="ln2181">                return luaL_error(ls, &quot;Invalid pool index %i/%i at (%i, %i)&quot;,</a>
<a name="ln2182">                                  index, pool_glyphs.size(), x + x1, y + y1);</a>
<a name="ln2183">            }</a>
<a name="ln2184">        }</a>
<a name="ln2185"> </a>
<a name="ln2186">    return 0;</a>
<a name="ln2187">}</a>
<a name="ln2188"> </a>
<a name="ln2189">static int dgn_width(lua_State *ls)</a>
<a name="ln2190">{</a>
<a name="ln2191">    LINES(ls, 1, map, lines);</a>
<a name="ln2192">    PLUARET(number, lines.width());</a>
<a name="ln2193">}</a>
<a name="ln2194"> </a>
<a name="ln2195">LUAFN(dgn_delve)</a>
<a name="ln2196">{</a>
<a name="ln2197">    LINES(ls, 1, map, lines);</a>
<a name="ln2198"> </a>
<a name="ln2199">    ARG_INT(ls, 2, ngb_min, 2);</a>
<a name="ln2200">    ARG_INT(ls, 3, ngb_max, 3);</a>
<a name="ln2201">    ARG_INT(ls, 4, connchance, 0);</a>
<a name="ln2202">    ARG_INT(ls, 5, cellnum, -1);</a>
<a name="ln2203">    ARG_INT(ls, 6, top, 125);</a>
<a name="ln2204"> </a>
<a name="ln2205">    delve(&amp;lines, ngb_min, ngb_max, connchance, cellnum, top);</a>
<a name="ln2206">    return 0;</a>
<a name="ln2207">}</a>
<a name="ln2208"> </a>
<a name="ln2209">LUAFN(dgn_farthest_from)</a>
<a name="ln2210">{</a>
<a name="ln2211">    LINES(ls, 1, map, lines);</a>
<a name="ln2212">    const char *beacons = luaL_checkstring(ls, 2);</a>
<a name="ln2213"> </a>
<a name="ln2214">    ASSERT(lines.width() &lt;= GXM);</a>
<a name="ln2215">    ASSERT(lines.height() &lt;= GYM);</a>
<a name="ln2216">    FixedArray&lt;bool, GXM, GYM&gt; visited;</a>
<a name="ln2217">    visited.init(false);</a>
<a name="ln2218">    vector&lt;coord_def&gt; queue;</a>
<a name="ln2219">    unsigned int dc_prev = 0, dc_next; // indices where dist changes to the next value</a>
<a name="ln2220"> </a>
<a name="ln2221">    for (int x = lines.width(); x &gt;= 0; x--)</a>
<a name="ln2222">        for (int y = lines.height(); y &gt;= 0; y--)</a>
<a name="ln2223">        {</a>
<a name="ln2224">            coord_def c(x, y);</a>
<a name="ln2225">            if (lines.in_map(c) &amp;&amp; strchr(beacons, lines(c)))</a>
<a name="ln2226">            {</a>
<a name="ln2227">                queue.push_back(c);</a>
<a name="ln2228">                visited(c) = true;</a>
<a name="ln2229">            }</a>
<a name="ln2230">        }</a>
<a name="ln2231"> </a>
<a name="ln2232">    dc_next = queue.size();</a>
<a name="ln2233">    if (!dc_next)</a>
<a name="ln2234">    {</a>
<a name="ln2235">        // Not a single beacon, nowhere to go.</a>
<a name="ln2236">        lua_pushnil(ls);</a>
<a name="ln2237">        lua_pushnil(ls);</a>
<a name="ln2238">        return 2;</a>
<a name="ln2239">    }</a>
<a name="ln2240"> </a>
<a name="ln2241">    for (unsigned int dc = 0; dc &lt; queue.size(); dc++)</a>
<a name="ln2242">    {</a>
<a name="ln2243">        if (dc &gt;= dc_next)</a>
<a name="ln2244">        {</a>
<a name="ln2245">            dc_prev = dc_next;</a>
<a name="ln2246">            dc_next = dc;</a>
<a name="ln2247">        }</a>
<a name="ln2248"> </a>
<a name="ln2249">        coord_def c = queue[dc];</a>
<a name="ln2250">        for (adjacent_iterator ai(c); ai; ++ai)</a>
<a name="ln2251">            if (lines.in_map(*ai) &amp;&amp; !visited(*ai)</a>
<a name="ln2252">                &amp;&amp; strchr(traversable_glyphs, lines(*ai)))</a>
<a name="ln2253">            {</a>
<a name="ln2254">                queue.push_back(*ai);</a>
<a name="ln2255">                visited(*ai) = true;</a>
<a name="ln2256">            }</a>
<a name="ln2257">    }</a>
<a name="ln2258"> </a>
<a name="ln2259">    ASSERT(dc_next &gt; dc_prev);</a>
<a name="ln2260">    // There may be multiple farthest cells, pick one at random.</a>
<a name="ln2261">    coord_def loc = queue[random_range(dc_prev, dc_next - 1)];</a>
<a name="ln2262">    lua_pushnumber(ls, loc.x);</a>
<a name="ln2263">    lua_pushnumber(ls, loc.y);</a>
<a name="ln2264">    return 2;</a>
<a name="ln2265">}</a>
<a name="ln2266"> </a>
<a name="ln2267">/* Wrappers for C++ layouts, to facilitate choosing of layouts by weight and</a>
<a name="ln2268"> * depth */</a>
<a name="ln2269"> </a>
<a name="ln2270">LUAFN(dgn_layout_basic)</a>
<a name="ln2271">{</a>
<a name="ln2272">    UNUSED(ls);</a>
<a name="ln2273">    dgn_build_basic_level();</a>
<a name="ln2274">    return 0;</a>
<a name="ln2275">}</a>
<a name="ln2276"> </a>
<a name="ln2277">LUAFN(dgn_layout_bigger_room)</a>
<a name="ln2278">{</a>
<a name="ln2279">    UNUSED(ls);</a>
<a name="ln2280">    dgn_build_bigger_room_level();</a>
<a name="ln2281">    return 0;</a>
<a name="ln2282">}</a>
<a name="ln2283"> </a>
<a name="ln2284">LUAFN(dgn_layout_chaotic_city)</a>
<a name="ln2285">{</a>
<a name="ln2286">    const dungeon_feature_type feature = check_lua_feature(ls, 2, true);</a>
<a name="ln2287">    dgn_build_chaotic_city_level(feature == DNGN_UNSEEN ? NUM_FEATURES : feature);</a>
<a name="ln2288">    return 0;</a>
<a name="ln2289">}</a>
<a name="ln2290"> </a>
<a name="ln2291">LUAFN(dgn_layout_shoals)</a>
<a name="ln2292">{</a>
<a name="ln2293">    UNUSED(ls);</a>
<a name="ln2294">    dgn_build_shoals_level();</a>
<a name="ln2295">    return 0;</a>
<a name="ln2296">}</a>
<a name="ln2297"> </a>
<a name="ln2298">LUAFN(dgn_layout_swamp)</a>
<a name="ln2299">{</a>
<a name="ln2300">    UNUSED(ls);</a>
<a name="ln2301">    dgn_build_swamp_level();</a>
<a name="ln2302">    return 0;</a>
<a name="ln2303">}</a>
<a name="ln2304"> </a>
<a name="ln2305">const struct luaL_reg dgn_build_dlib[] =</a>
<a name="ln2306">{</a>
<a name="ln2307">    { &quot;count_feature_in_box&quot;, &amp;dgn_count_feature_in_box },</a>
<a name="ln2308">    { &quot;count_antifeature_in_box&quot;, &amp;dgn_count_antifeature_in_box },</a>
<a name="ln2309">    { &quot;count_neighbors&quot;, &amp;dgn_count_neighbors },</a>
<a name="ln2310">    { &quot;count_passable_neighbors&quot;, &amp;dgn_count_passable_neighbors },</a>
<a name="ln2311">    { &quot;is_valid_coord&quot;, &amp;dgn_is_valid_coord },</a>
<a name="ln2312">    { &quot;is_passable_coord&quot;, &amp;dgn_is_passable_coord },</a>
<a name="ln2313">    { &quot;extend_map&quot;, &amp;dgn_extend_map },</a>
<a name="ln2314">    { &quot;fill_area&quot;, &amp;dgn_fill_area },</a>
<a name="ln2315">    { &quot;fill_disconnected&quot;, &amp;dgn_fill_disconnected },</a>
<a name="ln2316">    { &quot;find_in_area&quot;, &amp;dgn_find_in_area },</a>
<a name="ln2317">    { &quot;height&quot;, dgn_height },</a>
<a name="ln2318">    { &quot;primary_vault_dimensions&quot;, &amp;dgn_primary_vault_dimensions },</a>
<a name="ln2319">    { &quot;join_the_dots&quot;, &amp;dgn_join_the_dots },</a>
<a name="ln2320">    { &quot;make_circle&quot;, &amp;dgn_make_circle },</a>
<a name="ln2321">    { &quot;make_diamond&quot;, &amp;dgn_make_diamond },</a>
<a name="ln2322">    { &quot;make_rounded_square&quot;, &amp;dgn_make_rounded_square },</a>
<a name="ln2323">    { &quot;make_square&quot;, &amp;dgn_make_square },</a>
<a name="ln2324">    { &quot;make_box&quot;, &amp;dgn_make_box },</a>
<a name="ln2325">    { &quot;make_box_doors&quot;, &amp;dgn_make_box_doors },</a>
<a name="ln2326">    { &quot;make_irregular_box&quot;, &amp;dgn_make_irregular_box },</a>
<a name="ln2327">    { &quot;make_round_box&quot;, &amp;dgn_make_round_box },</a>
<a name="ln2328">    { &quot;mapgrd_table&quot;, dgn_mapgrd_table },</a>
<a name="ln2329">    { &quot;octa_room&quot;, &amp;dgn_octa_room },</a>
<a name="ln2330">    { &quot;remove_isolated_glyphs&quot;, &amp;dgn_remove_isolated_glyphs },</a>
<a name="ln2331">    { &quot;widen_paths&quot;, &amp;dgn_widen_paths },</a>
<a name="ln2332">    { &quot;connect_adjacent_rooms&quot;, &amp;dgn_connect_adjacent_rooms },</a>
<a name="ln2333">    { &quot;remove_disconnected_doors&quot;, &amp;dgn_remove_disconnected_doors },</a>
<a name="ln2334">    { &quot;add_windows&quot;, &amp;dgn_add_windows },</a>
<a name="ln2335">    { &quot;replace_area&quot;, &amp;dgn_replace_area },</a>
<a name="ln2336">    { &quot;replace_first&quot;, &amp;dgn_replace_first },</a>
<a name="ln2337">    { &quot;replace_random&quot;, &amp;dgn_replace_random },</a>
<a name="ln2338">    { &quot;replace_closest&quot;, &amp;dgn_replace_closest },</a>
<a name="ln2339">    { &quot;smear_map&quot;, &amp;dgn_smear_map },</a>
<a name="ln2340">    { &quot;spotty_map&quot;, &amp;dgn_spotty_map },</a>
<a name="ln2341">    { &quot;add_pools&quot;, &amp;dgn_add_pools },</a>
<a name="ln2342">    { &quot;delve&quot;, &amp;dgn_delve },</a>
<a name="ln2343">    { &quot;width&quot;, dgn_width },</a>
<a name="ln2344">    { &quot;farthest_from&quot;, &amp;dgn_farthest_from },</a>
<a name="ln2345"> </a>
<a name="ln2346">    { &quot;layout_basic&quot;, &amp;dgn_layout_basic },</a>
<a name="ln2347">    { &quot;layout_bigger_room&quot;, &amp;dgn_layout_bigger_room },</a>
<a name="ln2348">    { &quot;layout_chaotic_city&quot;, &amp;dgn_layout_chaotic_city },</a>
<a name="ln2349">    { &quot;layout_shoals&quot;, &amp;dgn_layout_shoals },</a>
<a name="ln2350">    { &quot;layout_swamp&quot;, &amp;dgn_layout_swamp },</a>
<a name="ln2351"> </a>
<a name="ln2352">    { nullptr, nullptr }</a>
<a name="ln2353">};</a>

</code></pre>
<div class="balloon" rel="815"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v764/" target="_blank">V764</a> Possible incorrect order of arguments passed to '_calculate_join_the_dots_path' function: 'to' and 'from'.</p></div>

<link rel="stylesheet" href="highlight.css">
<script src="highlight.pack.js"></script>
<script src="highlightjs-line-numbers.js"></script>
<script>hljs.initHighlightingOnLoad();</script>
<script>hljs.initLineNumbersOnLoad();</script>
<script>
  $(document).ready(function() {
      $('.balloon').each(function () {
          var bl = $(this);
          var line = bl.attr('rel');
          var text = $('a[name="ln'+line+'"]').text();

          var space_count = 0;
          for(var i = 0; i<text.length; i++){
              var char = text[i];
              if((char !== ' ')&&(char !== '\t'))break;
              if(char === '\t')space_count++;
              space_count++;
          }

          bl.css('margin-left', space_count*8);
          $('a[name="ln'+line+'"]').after(bl);
      });

      window.location = window.location;
  });
</script>
</body>
</html>
