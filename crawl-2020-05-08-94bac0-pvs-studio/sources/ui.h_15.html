
<html>
<head>

  <meta http-equiv="Content-Type" content="text/html; charset=US-ASCII" />
  <title>ui.h</title>

  <link rel="stylesheet" href="../style.css"/>
  <script src="../jquery-3.2.1.min.js"></script>
</head>
<body>

<pre><code class = "cpp">
<a name="ln1">/**</a>
<a name="ln2"> * @file</a>
<a name="ln3"> * @brief Hierarchical layout system.</a>
<a name="ln4">**/</a>
<a name="ln5"> </a>
<a name="ln6">#pragma once</a>
<a name="ln7"> </a>
<a name="ln8">#include &lt;functional&gt;</a>
<a name="ln9"> </a>
<a name="ln10">#include &quot;format.h&quot;</a>
<a name="ln11">#include &quot;KeymapContext.h&quot;</a>
<a name="ln12">#include &quot;state.h&quot;</a>
<a name="ln13">#include &quot;rltiles/tiledef-gui.h&quot;</a>
<a name="ln14">#include &quot;tilefont.h&quot;</a>
<a name="ln15">#include &quot;unwind.h&quot;</a>
<a name="ln16">#include &quot;cio.h&quot;</a>
<a name="ln17">#ifdef USE_TILE_LOCAL</a>
<a name="ln18"># include &quot;tilebuf.h&quot;</a>
<a name="ln19"># include &quot;tiledgnbuf.h&quot;</a>
<a name="ln20"># include &quot;tiledoll.h&quot;</a>
<a name="ln21"># include &quot;tilesdl.h&quot;</a>
<a name="ln22">#endif</a>
<a name="ln23">#ifdef USE_TILE_WEB</a>
<a name="ln24"># include &quot;tileweb.h&quot;</a>
<a name="ln25"># include &quot;json.h&quot;</a>
<a name="ln26">#endif</a>
<a name="ln27"> </a>
<a name="ln28">struct wm_keyboard_event;</a>
<a name="ln29"> </a>
<a name="ln30">namespace ui {</a>
<a name="ln31"> </a>
<a name="ln32">struct SizeReq</a>
<a name="ln33">{</a>
<a name="ln34">    int min, nat;</a>
<a name="ln35">};</a>
<a name="ln36"> </a>
<a name="ln37">class Margin</a>
<a name="ln38">{</a>
<a name="ln39">public:</a>
<a name="ln40">    constexpr Margin() : top(0), right(0), bottom(0), left(0) {}</a>
<a name="ln41"> </a>
<a name="ln42">    explicit constexpr Margin(int v) : top(v), right(v), bottom(v), left(v) {}</a>
<a name="ln43">    constexpr Margin(int v, int h) : top(v), right(h), bottom(v), left(h) {}</a>
<a name="ln44">    constexpr Margin(int t, int lr, int b)</a>
<a name="ln45">        : top(t), right(lr), bottom(b), left(lr) {}</a>
<a name="ln46">    constexpr Margin(int t, int r, int b, int l)</a>
<a name="ln47">        : top(t), right(r), bottom(b), left(l) {}</a>
<a name="ln48"> </a>
<a name="ln49">    int top, right, bottom, left;</a>
<a name="ln50">};</a>
<a name="ln51"> </a>
<a name="ln52">class Region</a>
<a name="ln53">{</a>
<a name="ln54">public:</a>
<a name="ln55">    constexpr Region() : x(0), y(0), width(0), height(0) {}</a>
<a name="ln56">    constexpr Region(int _x, int _y, int _width, int _height)</a>
<a name="ln57">        : x(_x), y(_y), width(_width), height(_height) {}</a>
<a name="ln58"> </a>
<a name="ln59">    constexpr bool operator == (const Region&amp; other) const</a>
<a name="ln60">    {</a>
<a name="ln61">        return x == other.x &amp;&amp; y == other.y</a>
<a name="ln62">            &amp;&amp; width == other.width &amp;&amp; height == other.height;</a>
<a name="ln63">    }</a>
<a name="ln64"> </a>
<a name="ln65">    constexpr bool empty() const</a>
<a name="ln66">    {</a>
<a name="ln67">        return width == 0 || height == 0;</a>
<a name="ln68">    }</a>
<a name="ln69"> </a>
<a name="ln70">    constexpr int ex() const</a>
<a name="ln71">    {</a>
<a name="ln72">        return x + width;</a>
<a name="ln73">    }</a>
<a name="ln74"> </a>
<a name="ln75">    constexpr int ey() const</a>
<a name="ln76">    {</a>
<a name="ln77">        return y + height;</a>
<a name="ln78">    }</a>
<a name="ln79"> </a>
<a name="ln80">    constexpr bool contains_point(int _x, int _y) const</a>
<a name="ln81">    {</a>
<a name="ln82">        return _x &gt;= x &amp;&amp; _x &lt; ex() &amp;&amp; _y &gt;= y &amp;&amp; _y &lt; ey();</a>
<a name="ln83">    }</a>
<a name="ln84"> </a>
<a name="ln85">    int x, y, width, height;</a>
<a name="ln86">};</a>
<a name="ln87"> </a>
<a name="ln88">class Size</a>
<a name="ln89">{</a>
<a name="ln90">public:</a>
<a name="ln91">    constexpr Size() : width(0), height(0) {}</a>
<a name="ln92">    explicit constexpr Size(int v) : width(v), height(v) {}</a>
<a name="ln93">    constexpr Size(int w, int h) : width(w), height(h) {}</a>
<a name="ln94"> </a>
<a name="ln95">    constexpr bool operator &lt;= (const Size&amp; other) const</a>
<a name="ln96">    {</a>
<a name="ln97">        return width &lt;= other.width &amp;&amp; height &lt;= other.height;</a>
<a name="ln98">    }</a>
<a name="ln99"> </a>
<a name="ln100">    constexpr bool operator == (const Size&amp; other) const</a>
<a name="ln101">    {</a>
<a name="ln102">        return width == other.width &amp;&amp; height == other.height;</a>
<a name="ln103">    }</a>
<a name="ln104"> </a>
<a name="ln105">    int width, height;</a>
<a name="ln106">};</a>
<a name="ln107"> </a>
<a name="ln108">class Widget;</a>
<a name="ln109"> </a>
<a name="ln110">class Event</a>
<a name="ln111">{</a>
<a name="ln112">public:</a>
<a name="ln113">    enum Type {</a>
<a name="ln114">        KeyDown = 0,</a>
<a name="ln115">        KeyUp,</a>
<a name="ln116">        MouseMove,</a>
<a name="ln117">        MouseDown,</a>
<a name="ln118">        MouseUp,</a>
<a name="ln119">        MouseEnter,</a>
<a name="ln120">        MouseLeave,</a>
<a name="ln121">        MouseWheel,</a>
<a name="ln122">        FocusIn,</a>
<a name="ln123">        FocusOut,</a>
<a name="ln124">        Activate,</a>
<a name="ln125">    };</a>
<a name="ln126"> </a>
<a name="ln127">    explicit Event(Type type);</a>
<a name="ln128"> </a>
<a name="ln129">    Type type() const { return m_type; }</a>
<a name="ln130"> </a>
<a name="ln131">    shared_ptr&lt;Widget&gt;&amp; target() { return m_target; }</a>
<a name="ln132">    shared_ptr&lt;Widget&gt; target() const { return m_target; }</a>
<a name="ln133">    void set_target(shared_ptr&lt;Widget&gt; _target) { m_target = move(_target); }</a>
<a name="ln134"> </a>
<a name="ln135">protected:</a>
<a name="ln136">    Type m_type;</a>
<a name="ln137">    shared_ptr&lt;Widget&gt; m_target;</a>
<a name="ln138">};</a>
<a name="ln139"> </a>
<a name="ln140">class KeyEvent final : public Event</a>
<a name="ln141">{</a>
<a name="ln142">public:</a>
<a name="ln143">    KeyEvent(Type type, const wm_keyboard_event&amp; wm_ev);</a>
<a name="ln144"> </a>
<a name="ln145">    int key() const { return m_key; }</a>
<a name="ln146"> </a>
<a name="ln147">protected:</a>
<a name="ln148">    int m_key;</a>
<a name="ln149">};</a>
<a name="ln150"> </a>
<a name="ln151">class MouseEvent final : public Event</a>
<a name="ln152">{</a>
<a name="ln153">public:</a>
<a name="ln154">#ifdef USE_TILE_LOCAL</a>
<a name="ln155">    MouseEvent(Type type, const wm_mouse_event&amp; wm_ev);</a>
<a name="ln156">#endif</a>
<a name="ln157"> </a>
<a name="ln158">    enum class Button</a>
<a name="ln159">    {</a>
<a name="ln160">        None = 0,</a>
<a name="ln161">        Left = 1,</a>
<a name="ln162">        Middle = 2,</a>
<a name="ln163">        Right = 4,</a>
<a name="ln164">    };</a>
<a name="ln165"> </a>
<a name="ln166">    Button button() const { return m_button; }</a>
<a name="ln167">    int x() const { return m_x; }</a>
<a name="ln168">    int y() const { return m_y; }</a>
<a name="ln169">    int wheel_dx() const { return m_wheel_dx; }</a>
<a name="ln170">    int wheel_dy() const { return m_wheel_dy; }</a>
<a name="ln171"> </a>
<a name="ln172">protected:</a>
<a name="ln173">    Button m_button;</a>
<a name="ln174">    int m_x, m_y;</a>
<a name="ln175">    int m_wheel_dx, m_wheel_dy;</a>
<a name="ln176">};</a>
<a name="ln177"> </a>
<a name="ln178">class FocusEvent final : public Event</a>
<a name="ln179">{</a>
<a name="ln180">public:</a>
<a name="ln181">    FocusEvent(Type type);</a>
<a name="ln182">};</a>
<a name="ln183"> </a>
<a name="ln184">class ActivateEvent final : public Event</a>
<a name="ln185">{</a>
<a name="ln186">public:</a>
<a name="ln187">    ActivateEvent();</a>
<a name="ln188">};</a>
<a name="ln189"> </a>
<a name="ln190">template&lt;typename, typename&gt; class Slot;</a>
<a name="ln191"> </a>
<a name="ln192">template&lt;class Target, class... Args&gt;</a>
<a name="ln193">class Slot&lt;Target, bool(Args...)&gt;</a>
<a name="ln194">{</a>
<a name="ln195">public:</a>
<a name="ln196">    ~Slot() { alive = false; }</a>
<a name="ln197">    typedef function&lt;bool (Args...)&gt; HandlerSig;</a>
<a name="ln198">    typedef multimap&lt;Target*, HandlerSig&gt; HandlerMap;</a>
<a name="ln199">    template&lt;typename P&gt;</a>
<a name="ln200">    bool emit_if(P pred, Args&amp;... args)</a>
<a name="ln201">    {</a>
<a name="ln202">        for (auto it : handlers)</a>
<a name="ln203">            if (pred(it.first))</a>
<a name="ln204">            {</a>
<a name="ln205">                HandlerSig func = it.second;</a>
<a name="ln206">                if (func(forward&lt;Args&gt;(args)...))</a>
<a name="ln207">                    return true;</a>
<a name="ln208">            }</a>
<a name="ln209">        return false;</a>
<a name="ln210">    }</a>
<a name="ln211">    bool emit(Target *target, Args&amp;... args)</a>
<a name="ln212">    {</a>
<a name="ln213">        auto i = handlers.equal_range(target);</a>
<a name="ln214">        for (auto it = i.first; it != i.second; ++it)</a>
<a name="ln215">        {</a>
<a name="ln216">            HandlerSig func = it-&gt;second;</a>
<a name="ln217">            if (func(forward&lt;Args&gt;(args)...))</a>
<a name="ln218">                return true;</a>
<a name="ln219">        }</a>
<a name="ln220">        return false;</a>
<a name="ln221">    }</a>
<a name="ln222">    void on(Target *target, HandlerSig handler)</a>
<a name="ln223">    {</a>
<a name="ln224">        auto new_pair = pair&lt;Target*, HandlerSig&gt;(target, handler);</a>
<a name="ln225">        handlers.insert(new_pair);</a>
<a name="ln226">    }</a>
<a name="ln227">    void remove_by_target(Target *target)</a>
<a name="ln228">    {</a>
<a name="ln229">        if (alive)</a>
<a name="ln230">            handlers.erase(target);</a>
<a name="ln231">    }</a>
<a name="ln232">protected:</a>
<a name="ln233">    bool alive {true};</a>
<a name="ln234">    HandlerMap handlers;</a>
<a name="ln235">};</a>
<a name="ln236"> </a>
<a name="ln237">class Widget : public enable_shared_from_this&lt;Widget&gt;</a>
<a name="ln238">{</a>
<a name="ln239">    friend struct UIRoot;</a>
<a name="ln240"> </a>
<a name="ln241">public:</a>
<a name="ln242">    enum Align {</a>
<a name="ln243">        START = 0,</a>
<a name="ln244">        END,</a>
<a name="ln245">        CENTER,</a>
<a name="ln246">        STRETCH,</a>
<a name="ln247">    };</a>
<a name="ln248"> </a>
<a name="ln249">    enum Direction {</a>
<a name="ln250">        HORZ = 0,</a>
<a name="ln251">        VERT,</a>
<a name="ln252">    };</a>
<a name="ln253"> </a>
<a name="ln254">    virtual ~Widget();</a>
<a name="ln255"> </a>
<a name="ln256">    int flex_grow = 1;</a>
<a name="ln257">    bool expand_h = false, expand_v = false;</a>
<a name="ln258">    bool shrink_h = false, shrink_v = false;</a>
<a name="ln259">    Region get_region() const { return m_region; }</a>
<a name="ln260"> </a>
<a name="ln261">    // FIXME: convert to getter and setter</a>
<a name="ln262">    Size&amp; min_size()</a>
<a name="ln263">    {</a>
<a name="ln264">        _invalidate_sizereq();</a>
<a name="ln265">        return m_min_size;</a>
<a name="ln266">    }</a>
<a name="ln267"> </a>
<a name="ln268">    Size&amp; max_size()</a>
<a name="ln269">    {</a>
<a name="ln270">        _invalidate_sizereq();</a>
<a name="ln271">        return m_max_size;</a>
<a name="ln272">    }</a>
<a name="ln273"> </a>
<a name="ln274">    virtual void _render() = 0;</a>
<a name="ln275">    virtual SizeReq _get_preferred_size(Direction dim, int prosp_width);</a>
<a name="ln276">    virtual void _allocate_region();</a>
<a name="ln277"> </a>
<a name="ln278">    void _set_parent(Widget* p);</a>
<a name="ln279"> </a>
<a name="ln280">    Widget* _get_parent() const</a>
<a name="ln281">    {</a>
<a name="ln282">        return m_parent;</a>
<a name="ln283">    }</a>
<a name="ln284"> </a>
<a name="ln285">    shared_ptr&lt;Widget&gt; get_shared()</a>
<a name="ln286">    {</a>
<a name="ln287">        return shared_from_this();</a>
<a name="ln288">    }</a>
<a name="ln289"> </a>
<a name="ln290">    /**</a>
<a name="ln291">     * Mark this widget as possibly having changed size.</a>
<a name="ln292">     *</a>
<a name="ln293">     * _get_preferred_size() will be called before the next allocation/render.</a>
<a name="ln294">     */</a>
<a name="ln295">    void _invalidate_sizereq(bool immediate = true);</a>
<a name="ln296"> </a>
<a name="ln297">    /**</a>
<a name="ln298">     * Mark this widget as needing reallocation.</a>
<a name="ln299">     *</a>
<a name="ln300">     * _allocate_region() will be called before the next call to _render(), even</a>
<a name="ln301">     * if the widget has not resized or moved. This is useful if buffers need to</a>
<a name="ln302">     * be repacked due to widget state change.</a>
<a name="ln303">     */</a>
<a name="ln304">    void _queue_allocation(bool immediate = true);</a>
<a name="ln305"> </a>
<a name="ln306">    void set_allocation_needed()</a>
<a name="ln307">    {</a>
<a name="ln308">        alloc_queued = true;</a>
<a name="ln309">    }</a>
<a name="ln310"> </a>
<a name="ln311">    /**</a>
<a name="ln312">     * Mark this widget as needing redraw. render() will be called.</a>
<a name="ln313">     */</a>
<a name="ln314">    void _expose();</a>
<a name="ln315"> </a>
<a name="ln316">    /**</a>
<a name="ln317">     * Get/set visibility of this widget only, ignoring the visibility of its</a>
<a name="ln318">     * ancestors, if there are any, or whether it is in a layout at all.</a>
<a name="ln319">     */</a>
<a name="ln320">    bool is_visible() const</a>
<a name="ln321">    {</a>
<a name="ln322">        return m_visible;</a>
<a name="ln323">    }</a>
<a name="ln324">    void set_visible(bool);</a>
<a name="ln325"> </a>
<a name="ln326">    bool is_ancestor_of(const shared_ptr&lt;Widget&gt;&amp; other);</a>
<a name="ln327"> </a>
<a name="ln328">    virtual void for_each_child(function&lt;void(shared_ptr&lt;Widget&gt;&amp;)&gt;)</a>
<a name="ln329">    {</a>
<a name="ln330">    }</a>
<a name="ln331"> </a>
<a name="ln332">    // Wrapper functions which handle common behaviour</a>
<a name="ln333">    // - margins</a>
<a name="ln334">    // - caching</a>
<a name="ln335">    void render();</a>
<a name="ln336">    SizeReq get_preferred_size(Direction dim, int prosp_width);</a>
<a name="ln337">    void allocate_region(Region region);</a>
<a name="ln338"> </a>
<a name="ln339">    Margin get_margin() const</a>
<a name="ln340">    {</a>
<a name="ln341">        return margin;</a>
<a name="ln342">    }</a>
<a name="ln343"> </a>
<a name="ln344">    template&lt;class... Args&gt;</a>
<a name="ln345">    void set_margin_for_crt(Args&amp;&amp;... args)</a>
<a name="ln346">    {</a>
<a name="ln347">#ifndef USE_TILE_LOCAL</a>
<a name="ln348">        margin = Margin(forward&lt;Args&gt;(args)...);</a>
<a name="ln349">        _invalidate_sizereq();</a>
<a name="ln350">#else</a>
<a name="ln351">        UNUSED(args...);</a>
<a name="ln352">#endif</a>
<a name="ln353">    }</a>
<a name="ln354"> </a>
<a name="ln355">    template&lt;class... Args&gt;</a>
<a name="ln356">    void set_margin_for_sdl(Args&amp;&amp;... args)</a>
<a name="ln357">    {</a>
<a name="ln358">#ifdef USE_TILE_LOCAL</a>
<a name="ln359">        margin = Margin(forward&lt;Args&gt;(args)...);</a>
<a name="ln360">        _invalidate_sizereq();</a>
<a name="ln361">#else</a>
<a name="ln362">        UNUSED(args...);</a>
<a name="ln363">#endif</a>
<a name="ln364">    }</a>
<a name="ln365"> </a>
<a name="ln366">    virtual bool on_event(const Event&amp; event);</a>
<a name="ln367"> </a>
<a name="ln368">    template&lt;class F&gt;</a>
<a name="ln369">    void on_any_event(F&amp;&amp; cb)</a>
<a name="ln370">    {</a>
<a name="ln371">        slots.event.on(this, forward&lt;F&gt;(cb));</a>
<a name="ln372">    }</a>
<a name="ln373"> </a>
<a name="ln374">    template&lt;class F&gt;</a>
<a name="ln375">    void on_hotkey_event(F&amp;&amp; cb)</a>
<a name="ln376">    {</a>
<a name="ln377">        slots.hotkey.on(this, [cb](const Event&amp; event){</a>
<a name="ln378">            return cb(static_cast&lt;const KeyEvent&amp;&gt;(event));</a>
<a name="ln379">        });</a>
<a name="ln380">    }</a>
<a name="ln381"> </a>
<a name="ln382">    template&lt;class F&gt;</a>
<a name="ln383">    void on_layout_pop(F&amp;&amp; cb)</a>
<a name="ln384">    {</a>
<a name="ln385">        slots.layout_pop.on(this, [cb](){</a>
<a name="ln386">            cb();</a>
<a name="ln387">            return false;</a>
<a name="ln388">        });</a>
<a name="ln389">    }</a>
<a name="ln390"> </a>
<a name="ln391">#define EVENT_HANDLER_HELPER(NAME, ENUM, CLASS) \</a>
<a name="ln392">    template&lt;class F&gt; \</a>
<a name="ln393">    void NAME(F&amp;&amp; cb) \</a>
<a name="ln394">    { \</a>
<a name="ln395">        slots.event.on(this, [cb](const Event&amp; event){ \</a>
<a name="ln396">            if (event.type() != Event::Type::ENUM) \</a>
<a name="ln397">                return false; \</a>
<a name="ln398">            return cb(static_cast&lt;const CLASS&amp;&gt;(event)); \</a>
<a name="ln399">        }); \</a>
<a name="ln400">    }</a>
<a name="ln401">    EVENT_HANDLER_HELPER(on_keydown_event, KeyDown, KeyEvent)</a>
<a name="ln402">    EVENT_HANDLER_HELPER(on_keyup_event, KeyUp, KeyEvent)</a>
<a name="ln403">    EVENT_HANDLER_HELPER(on_mousemove_event, MouseMove, MouseEvent)</a>
<a name="ln404">    EVENT_HANDLER_HELPER(on_mousedown_event, MouseDown, MouseEvent)</a>
<a name="ln405">    EVENT_HANDLER_HELPER(on_mouseup_event, MouseUp, MouseEvent)</a>
<a name="ln406">    EVENT_HANDLER_HELPER(on_mouseenter_event, MouseEnter, MouseEvent)</a>
<a name="ln407">    EVENT_HANDLER_HELPER(on_mouseleave_event, MouseLeave, MouseEvent)</a>
<a name="ln408">    EVENT_HANDLER_HELPER(on_mousewheel_event, MouseWheel, MouseEvent)</a>
<a name="ln409">    EVENT_HANDLER_HELPER(on_focusin_event, FocusIn, FocusEvent)</a>
<a name="ln410">    EVENT_HANDLER_HELPER(on_focusout_event, FocusOut, FocusEvent)</a>
<a name="ln411">    EVENT_HANDLER_HELPER(on_activate_event, Activate, ActivateEvent)</a>
<a name="ln412">#undef EVENT_HANDLER_HELPER</a>
<a name="ln413"> </a>
<a name="ln414">    /**</a>
<a name="ln415">     * Container widget interface. Must return a pointer to the child widget at</a>
<a name="ln416">     * the given screen position, or nullptr.</a>
<a name="ln417">     */</a>
<a name="ln418">    virtual shared_ptr&lt;Widget&gt; get_child_at_offset(int, int)</a>
<a name="ln419">    {</a>
<a name="ln420">        return nullptr;</a>
<a name="ln421">    }</a>
<a name="ln422"> </a>
<a name="ln423">    const string&amp; sync_id()</a>
<a name="ln424">    {</a>
<a name="ln425">        return m_sync_id;</a>
<a name="ln426">    }</a>
<a name="ln427"> </a>
<a name="ln428">    void set_sync_id(string id);</a>
<a name="ln429"> </a>
<a name="ln430">protected:</a>
<a name="ln431">    Region m_region;</a>
<a name="ln432">    Margin margin = Margin{0};</a>
<a name="ln433"> </a>
<a name="ln434">    void _unparent(shared_ptr&lt;Widget&gt;&amp; child);</a>
<a name="ln435"> </a>
<a name="ln436">    vector&lt;shared_ptr&lt;Widget&gt;&gt; m_internal_children;</a>
<a name="ln437">    void add_internal_child(shared_ptr&lt;Widget&gt; child);</a>
<a name="ln438"> </a>
<a name="ln439">    template&lt;class F&gt;</a>
<a name="ln440">    void for_each_internal_child(F&amp;&amp; cb)</a>
<a name="ln441">    {</a>
<a name="ln442">        for (auto&amp; child : m_internal_children)</a>
<a name="ln443">            cb(child);</a>
<a name="ln444">    }</a>
<a name="ln445"> </a>
<a name="ln446">    template&lt;class F&gt;</a>
<a name="ln447">    void for_each_child_including_internal(F&amp;&amp; cb)</a>
<a name="ln448">    {</a>
<a name="ln449">        for_each_internal_child(forward&lt;F&gt;(cb));</a>
<a name="ln450">        for_each_child(forward&lt;F&gt;(cb));</a>
<a name="ln451">    }</a>
<a name="ln452"> </a>
<a name="ln453">    /**</a>
<a name="ln454">     * Whether widgets of this class should be included in the set of focusable</a>
<a name="ln455">     * widgets. Should return a constant boolean.</a>
<a name="ln456">     */</a>
<a name="ln457">    virtual bool can_take_focus() { return false; };</a>
<a name="ln458"> </a>
<a name="ln459">    /**</a>
<a name="ln460">     * Whether a widget is currently focusable.</a>
<a name="ln461">     */</a>
<a name="ln462">    bool focusable()</a>
<a name="ln463">    {</a>
<a name="ln464">        // FIXME: does not take into account hierarchical visibility</a>
<a name="ln465">        // e.g. widget in currently hidden child of switcher</a>
<a name="ln466">        return is_visible();</a>
<a name="ln467">    }</a>
<a name="ln468"> </a>
<a name="ln469">#ifdef USE_TILE_WEB</a>
<a name="ln470">    virtual void sync_save_state();</a>
<a name="ln471">    virtual void sync_load_state(const JsonNode *json);</a>
<a name="ln472">    void sync_state_changed();</a>
<a name="ln473">#endif</a>
<a name="ln474"> </a>
<a name="ln475">    void _emit_layout_pop();</a>
<a name="ln476"> </a>
<a name="ln477">private:</a>
<a name="ln478">    bool cached_sr_valid[2] = { false, false };</a>
<a name="ln479">    SizeReq cached_sr[2];</a>
<a name="ln480">    int cached_sr_pw;</a>
<a name="ln481">    bool alloc_queued = false;</a>
<a name="ln482">    bool m_visible = true;</a>
<a name="ln483">    Widget* m_parent = nullptr;</a>
<a name="ln484"> </a>
<a name="ln485">    Size m_min_size = Size{0};</a>
<a name="ln486">    Size m_max_size = Size{INT_MAX};</a>
<a name="ln487"> </a>
<a name="ln488">    string m_sync_id;</a>
<a name="ln489"> </a>
<a name="ln490">    static struct slots {</a>
<a name="ln491">        Slot&lt;Widget, bool(const Event&amp;)&gt; event;</a>
<a name="ln492">        Slot&lt;Widget, bool(const Event&amp;)&gt; hotkey;</a>
<a name="ln493">        Slot&lt;Widget, bool()&gt; layout_pop;</a>
<a name="ln494">    } slots;</a>
<a name="ln495">};</a>
<a name="ln496"> </a>
<a name="ln497">class Container : public Widget</a>
<a name="ln498">{</a>
<a name="ln499">public:</a>
<a name="ln500">    virtual ~Container() {}</a>
<a name="ln501">    virtual void for_each_child(function&lt;void(shared_ptr&lt;Widget&gt;&amp;)&gt; f) = 0;</a>
<a name="ln502">};</a>
<a name="ln503"> </a>
<a name="ln504">class Bin : public Container</a>
<a name="ln505">{</a>
<a name="ln506">public:</a>
<a name="ln507">    virtual ~Bin()</a>
<a name="ln508">    {</a>
<a name="ln509">        if (m_child)</a>
<a name="ln510">            _unparent(m_child);</a>
<a name="ln511">    }</a>
<a name="ln512">    void set_child(shared_ptr&lt;Widget&gt; child);</a>
<a name="ln513">    virtual shared_ptr&lt;Widget&gt; get_child() const</a>
<a name="ln514">    {</a>
<a name="ln515">        return m_child;</a>
<a name="ln516">    }</a>
<a name="ln517">    shared_ptr&lt;Widget&gt; get_child_at_offset(int x, int y) override;</a>
<a name="ln518"> </a>
<a name="ln519">protected:</a>
<a name="ln520">    class iterator</a>
<a name="ln521">    {</a>
<a name="ln522">    public:</a>
<a name="ln523">        typedef shared_ptr&lt;Widget&gt; value_type;</a>
<a name="ln524">        typedef ptrdiff_t distance;</a>
<a name="ln525">        typedef shared_ptr&lt;Widget&gt;* pointer;</a>
<a name="ln526">        typedef shared_ptr&lt;Widget&gt;&amp; reference;</a>
<a name="ln527">        typedef input_iterator_tag iterator_category;</a>
<a name="ln528"> </a>
<a name="ln529">        value_type c;</a>
<a name="ln530">        bool state;</a>
<a name="ln531"> </a>
<a name="ln532">        iterator(value_type&amp; _c, bool _state) : c(_c), state(_state) {}</a>
<a name="ln533">        void operator++ () { state = true; }</a>
<a name="ln534">        value_type&amp; operator* () { return c; }</a>
<a name="ln535">        bool operator== (const iterator&amp; other) { return c == other.c &amp;&amp; state == other.state; }</a>
<a name="ln536">        bool operator!= (const iterator&amp; other) { return !(*this == other); }</a>
<a name="ln537">    };</a>
<a name="ln538"> </a>
<a name="ln539">public:</a>
<a name="ln540">    iterator begin() { return iterator(m_child, false); }</a>
<a name="ln541">    iterator end() { return iterator(m_child, true); }</a>
<a name="ln542">    void for_each_child(function&lt;void(shared_ptr&lt;Widget&gt;&amp;)&gt; f) override</a>
<a name="ln543">    {</a>
<a name="ln544">        for (auto&amp; child : *this)</a>
<a name="ln545">            f(child);</a>
<a name="ln546">    }</a>
<a name="ln547"> </a>
<a name="ln548">protected:</a>
<a name="ln549">    shared_ptr&lt;Widget&gt; m_child;</a>
<a name="ln550">};</a>
<a name="ln551"> </a>
<a name="ln552">class ContainerVec : public Container</a>
<a name="ln553">{</a>
<a name="ln554">public:</a>
<a name="ln555">    virtual ~ContainerVec()</a>
<a name="ln556">    {</a>
<a name="ln557">        for (auto&amp; child : m_children)</a>
<a name="ln558">            if (child)</a>
<a name="ln559">                _unparent(child);</a>
<a name="ln560">    }</a>
<a name="ln561"> </a>
<a name="ln562">    shared_ptr&lt;Widget&gt; get_child_at_offset(int x, int y) override;</a>
<a name="ln563"> </a>
<a name="ln564">    size_t num_children() const</a>
<a name="ln565">    {</a>
<a name="ln566">        return m_children.size();</a>
<a name="ln567">    }</a>
<a name="ln568"> </a>
<a name="ln569">    template&lt;typename T&gt;</a>
<a name="ln570">    shared_ptr&lt;Widget&gt;&amp; get_child(T pos)</a>
<a name="ln571">    {</a>
<a name="ln572">        return m_children[pos];</a>
<a name="ln573">    }</a>
<a name="ln574"> </a>
<a name="ln575">    template&lt;typename T&gt;</a>
<a name="ln576">    const shared_ptr&lt;Widget&gt;&amp; get_child(T pos) const</a>
<a name="ln577">    {</a>
<a name="ln578">        return m_children[pos];</a>
<a name="ln579">    }</a>
<a name="ln580"> </a>
<a name="ln581">    template&lt;typename T&gt;</a>
<a name="ln582">    shared_ptr&lt;Widget&gt;&amp; operator[](T pos)</a>
<a name="ln583">    {</a>
<a name="ln584">        return m_children[pos];</a>
<a name="ln585">    }</a>
<a name="ln586"> </a>
<a name="ln587">    template&lt;typename T&gt;</a>
<a name="ln588">    const shared_ptr&lt;Widget&gt;&amp; operator[](T pos) const</a>
<a name="ln589">    {</a>
<a name="ln590">        return m_children[pos];</a>
<a name="ln591">    }</a>
<a name="ln592"> </a>
<a name="ln593">protected:</a>
<a name="ln594">    class iterator</a>
<a name="ln595">    {</a>
<a name="ln596">    public:</a>
<a name="ln597">        typedef shared_ptr&lt;Widget&gt; value_type;</a>
<a name="ln598">        typedef ptrdiff_t distance;</a>
<a name="ln599">        typedef shared_ptr&lt;Widget&gt;* pointer;</a>
<a name="ln600">        typedef shared_ptr&lt;Widget&gt;&amp; reference;</a>
<a name="ln601">        typedef input_iterator_tag iterator_category;</a>
<a name="ln602"> </a>
<a name="ln603">        vector&lt;value_type&gt;&amp; c;</a>
<a name="ln604">        vector&lt;value_type&gt;::iterator it;</a>
<a name="ln605"> </a>
<a name="ln606">        iterator(vector&lt;value_type&gt;&amp; _c, vector&lt;value_type&gt;::iterator _it) : c(_c), it(_it) {}</a>
<a name="ln607">        void operator++ () { ++it; }</a>
<a name="ln608">        value_type&amp; operator* () { return *it; }</a>
<a name="ln609">        bool operator== (const iterator&amp; other) { return c == other.c &amp;&amp; it == other.it; }</a>
<a name="ln610">        bool operator!= (const iterator&amp; other) { return !(*this == other); }</a>
<a name="ln611">    };</a>
<a name="ln612"> </a>
<a name="ln613">public:</a>
<a name="ln614">    iterator begin()</a>
<a name="ln615">    {</a>
<a name="ln616">        return iterator(m_children, m_children.begin());</a>
<a name="ln617">    }</a>
<a name="ln618">    iterator end()</a>
<a name="ln619">    {</a>
<a name="ln620">        return iterator(m_children, m_children.end());</a>
<a name="ln621">    }</a>
<a name="ln622"> </a>
<a name="ln623">    void for_each_child(function&lt;void(shared_ptr&lt;Widget&gt;&amp;)&gt; f) override</a>
<a name="ln624">    {</a>
<a name="ln625">        for (auto&amp; child : *this)</a>
<a name="ln626">            f(child);</a>
<a name="ln627">    }</a>
<a name="ln628"> </a>
<a name="ln629">protected:</a>
<a name="ln630">    vector&lt;shared_ptr&lt;Widget&gt;&gt; m_children;</a>
<a name="ln631">};</a>
<a name="ln632"> </a>
<a name="ln633">// Box widget: similar to the CSS flexbox (without wrapping)</a>
<a name="ln634">//  - Lays its children out in either a row or a column</a>
<a name="ln635">//  - Extra space is allocated according to each child's flex_grow property</a>
<a name="ln636"> </a>
<a name="ln637">class Box : public ContainerVec</a>
<a name="ln638">{</a>
<a name="ln639">public:</a>
<a name="ln640">    enum Expand {</a>
<a name="ln641">        NONE = 0x0,</a>
<a name="ln642">        EXPAND_H = 0x1,</a>
<a name="ln643">        EXPAND_V = 0x2,</a>
<a name="ln644">        SHRINK_H = 0x4,</a>
<a name="ln645">        SHRINK_V = 0x8,</a>
<a name="ln646">    };</a>
<a name="ln647"> </a>
<a name="ln648">    explicit Box(Direction dir, Expand expand_flags = NONE)</a>
<a name="ln649">    {</a>
<a name="ln650">        horz = dir == HORZ;</a>
<a name="ln651">        expand_h = expand_flags &amp; EXPAND_H;</a>
<a name="ln652">        expand_v = expand_flags &amp; EXPAND_V;</a>
<a name="ln653">    }</a>
<a name="ln654"> </a>
<a name="ln655">    virtual ~Box() {}</a>
<a name="ln656">    void add_child(shared_ptr&lt;Widget&gt; child);</a>
<a name="ln657"> </a>
<a name="ln658">    Widget::Align main_alignment() const { return align_main; }</a>
<a name="ln659">    Widget::Align cross_alignment() const { return align_cross; }</a>
<a name="ln660"> </a>
<a name="ln661">    void set_main_alignment(Widget::Align align)</a>
<a name="ln662">    {</a>
<a name="ln663">        align_main = align;</a>
<a name="ln664">        _invalidate_sizereq();</a>
<a name="ln665">    };</a>
<a name="ln666">    void set_cross_alignment(Widget::Align align)</a>
<a name="ln667">    {</a>
<a name="ln668">        align_cross = align;</a>
<a name="ln669">        _invalidate_sizereq();</a>
<a name="ln670">    };</a>
<a name="ln671"> </a>
<a name="ln672">    void _render() override;</a>
<a name="ln673">    SizeReq _get_preferred_size(Direction dim, int prosp_width) override;</a>
<a name="ln674">    void _allocate_region() override;</a>
<a name="ln675"> </a>
<a name="ln676">protected:</a>
<a name="ln677">    bool horz;</a>
<a name="ln678">    Widget::Align align_main = START;</a>
<a name="ln679">    Widget::Align align_cross = START;</a>
<a name="ln680"> </a>
<a name="ln681">    vector&lt;int&gt; layout_main_axis(vector&lt;SizeReq&gt;&amp; ch_psz, int main_sz);</a>
<a name="ln682">    vector&lt;int&gt; layout_cross_axis(vector&lt;SizeReq&gt;&amp; ch_psz, int cross_sz);</a>
<a name="ln683">};</a>
<a name="ln684"> </a>
<a name="ln685">class Text : public Widget</a>
<a name="ln686">{</a>
<a name="ln687">public:</a>
<a name="ln688">    Text();</a>
<a name="ln689">    virtual ~Text() {}</a>
<a name="ln690"> </a>
<a name="ln691">    template&lt;class... Args&gt;</a>
<a name="ln692">    explicit Text(Args&amp;&amp;... args) : Text()</a>
<a name="ln693">    {</a>
<a name="ln694">        set_text(forward&lt;Args&gt;(args)...);</a>
<a name="ln695">    }</a>
<a name="ln696"> </a>
<a name="ln697">    void set_text(const formatted_string &amp;fs);</a>
<a name="ln698">    void set_text(const string&amp; text)</a>
<a name="ln699">    {</a>
<a name="ln700">        set_text(formatted_string(text));</a>
<a name="ln701">    }</a>
<a name="ln702"> </a>
<a name="ln703">    const formatted_string&amp; get_text() const</a>
<a name="ln704">    {</a>
<a name="ln705">        return m_text;</a>
<a name="ln706">    }</a>
<a name="ln707"> </a>
<a name="ln708">    void set_font(FontWrapper *font);</a>
<a name="ln709">    void set_highlight_pattern(string pattern, bool hl_line = false);</a>
<a name="ln710"> </a>
<a name="ln711">    void _render() override;</a>
<a name="ln712">    SizeReq _get_preferred_size(Direction dim, int prosp_width) override;</a>
<a name="ln713">    void _allocate_region() override;</a>
<a name="ln714"> </a>
<a name="ln715">#ifndef USE_TILE_LOCAL</a>
<a name="ln716">    void set_bg_colour(COLOURS colour);</a>
<a name="ln717">#endif</a>
<a name="ln718"> </a>
<a name="ln719">    void set_wrap_text(bool _wrap_text)</a>
<a name="ln720">    {</a>
<a name="ln721">        if (wrap_text == _wrap_text)</a>
<a name="ln722">            return;</a>
<a name="ln723">        wrap_text = _wrap_text;</a>
<a name="ln724">        _invalidate_sizereq();</a>
<a name="ln725">    }</a>
<a name="ln726"> </a>
<a name="ln727">    void set_ellipsize(bool _ellipsize)</a>
<a name="ln728">    {</a>
<a name="ln729">        if (ellipsize == _ellipsize)</a>
<a name="ln730">            return;</a>
<a name="ln731">        ellipsize = _ellipsize;</a>
<a name="ln732">        _invalidate_sizereq();</a>
<a name="ln733">    }</a>
<a name="ln734"> </a>
<a name="ln735">protected:</a>
<a name="ln736">    void wrap_text_to_size(int width, int height);</a>
<a name="ln737"> </a>
<a name="ln738">    bool wrap_text = false;</a>
<a name="ln739">    bool ellipsize = false;</a>
<a name="ln740"> </a>
<a name="ln741">    formatted_string m_text;</a>
<a name="ln742">#ifdef USE_TILE_LOCAL</a>
<a name="ln743">    struct brkpt { unsigned int op, line; };</a>
<a name="ln744">    vector&lt;brkpt&gt; m_brkpts;</a>
<a name="ln745">    formatted_string m_text_wrapped;</a>
<a name="ln746">    ShapeBuffer m_hl_buf;</a>
<a name="ln747">    FontWrapper *m_font;</a>
<a name="ln748">#else</a>
<a name="ln749">    vector&lt;formatted_string&gt; m_wrapped_lines;</a>
<a name="ln750">    COLOURS m_bg_colour = BLACK;</a>
<a name="ln751">#endif</a>
<a name="ln752">    Size m_wrapped_size = Size{-1};</a>
<a name="ln753">    string hl_pat;</a>
<a name="ln754">    bool hl_line;</a>
<a name="ln755">};</a>
<a name="ln756"> </a>
<a name="ln757">class Image : public Widget</a>
<a name="ln758">{</a>
<a name="ln759">public:</a>
<a name="ln760">    Image() {}</a>
<a name="ln761">    explicit Image(tile_def tile) : Image()</a>
<a name="ln762">    {</a>
<a name="ln763">        set_tile(tile);</a>
<a name="ln764">    }</a>
<a name="ln765">    virtual ~Image() {}</a>
<a name="ln766">    void set_tile(tile_def tile);</a>
<a name="ln767">    tile_def get_tile() const</a>
<a name="ln768">    {</a>
<a name="ln769">        return m_tile;</a>
<a name="ln770">    }</a>
<a name="ln771"> </a>
<a name="ln772">    void _render() override;</a>
<a name="ln773">    SizeReq _get_preferred_size(Direction dim, int prosp_width) override;</a>
<a name="ln774"> </a>
<a name="ln775">protected:</a>
<a name="ln776">    tile_def m_tile = {TILEG_ERROR, TEX_GUI};</a>
<a name="ln777">    int m_tw {0}, m_th {0};</a>
<a name="ln778"> </a>
<a name="ln779">#ifdef USE_TILE_LOCAL</a>
<a name="ln780">    GenericTexture m_img;</a>
<a name="ln781">#endif</a>
<a name="ln782">};</a>
<a name="ln783"> </a>
<a name="ln784">class Stack : public ContainerVec</a>
<a name="ln785">{</a>
<a name="ln786">public:</a>
<a name="ln787">    virtual ~Stack() {}</a>
<a name="ln788">    void add_child(shared_ptr&lt;Widget&gt; child);</a>
<a name="ln789">    void pop_child();</a>
<a name="ln790"> </a>
<a name="ln791">    shared_ptr&lt;Widget&gt; get_child_at_offset(int x, int y) override;</a>
<a name="ln792"> </a>
<a name="ln793">    void _render() override;</a>
<a name="ln794">    SizeReq _get_preferred_size(Direction dim, int prosp_width) override;</a>
<a name="ln795">    void _allocate_region() override;</a>
<a name="ln796">};</a>
<a name="ln797"> </a>
<a name="ln798">class Switcher : public ContainerVec</a>
<a name="ln799">{</a>
<a name="ln800">public:</a>
<a name="ln801">    virtual ~Switcher() {}</a>
<a name="ln802">    void add_child(shared_ptr&lt;Widget&gt; child);</a>
<a name="ln803">    // FIXME: convert to getter and setter</a>
<a name="ln804">    int&amp; current();</a>
<a name="ln805">    shared_ptr&lt;Widget&gt; current_widget();</a>
<a name="ln806"> </a>
<a name="ln807">    Widget::Align align_x = START, align_y = START;</a>
<a name="ln808"> </a>
<a name="ln809">    void _render() override;</a>
<a name="ln810">    SizeReq _get_preferred_size(Direction dim, int prosp_width) override;</a>
<a name="ln811">    void _allocate_region() override;</a>
<a name="ln812">    shared_ptr&lt;Widget&gt; get_child_at_offset(int x, int y) override;</a>
<a name="ln813"> </a>
<a name="ln814">protected:</a>
<a name="ln815">    int m_current;</a>
<a name="ln816">};</a>
<a name="ln817"> </a>
<a name="ln818">class Grid : public Container</a>
<a name="ln819">{</a>
<a name="ln820">public:</a>
<a name="ln821">    virtual ~Grid() {</a>
<a name="ln822">        for (auto&amp; child : m_child_info)</a>
<a name="ln823">            if (child.widget)</a>
<a name="ln824">                _unparent(child.widget);</a>
<a name="ln825">    }</a>
<a name="ln826"> </a>
<a name="ln827">    void add_child(shared_ptr&lt;Widget&gt; child, int x, int y, int w = 1, int h = 1);</a>
<a name="ln828"> </a>
<a name="ln829">    int column_flex_grow(int x) const</a>
<a name="ln830">    {</a>
<a name="ln831">        return m_col_info.at(x).flex_grow;</a>
<a name="ln832">    }</a>
<a name="ln833">    int row_flex_grow(int y) const</a>
<a name="ln834">    {</a>
<a name="ln835">        return m_row_info.at(y).flex_grow;</a>
<a name="ln836">    }</a>
<a name="ln837"> </a>
<a name="ln838">    // FIXME: convert to getter and setter</a>
<a name="ln839">    int&amp; column_flex_grow(int x)</a>
<a name="ln840">    {</a>
<a name="ln841">        init_track_info();</a>
<a name="ln842">        return m_col_info.at(x).flex_grow;</a>
<a name="ln843">    }</a>
<a name="ln844">    int&amp; row_flex_grow(int y)</a>
<a name="ln845">    {</a>
<a name="ln846">        init_track_info();</a>
<a name="ln847">        return m_row_info.at(y).flex_grow;</a>
<a name="ln848">    }</a>
<a name="ln849"> </a>
<a name="ln850">    void _render() override;</a>
<a name="ln851">    SizeReq _get_preferred_size(Direction dim, int prosp_width) override;</a>
<a name="ln852">    void _allocate_region() override;</a>
<a name="ln853">    shared_ptr&lt;Widget&gt; get_child_at_offset(int x, int y) override;</a>
<a name="ln854"> </a>
<a name="ln855">    bool stretch_h = false, stretch_v = false;</a>
<a name="ln856"> </a>
<a name="ln857">protected:</a>
<a name="ln858">    Region get_tracks_region(int x, int y, int w, int h) const</a>
<a name="ln859">    {</a>
<a name="ln860">        Region track_region;</a>
<a name="ln861">        track_region.x = m_col_info[x].offset;</a>
<a name="ln862">        track_region.y = m_row_info[y].offset;</a>
<a name="ln863">        track_region.width = m_col_info[x+w-1].size + m_col_info[x+w-1].offset - m_col_info[x].offset;</a>
<a name="ln864">        track_region.height = m_row_info[y+h-1].size + m_row_info[y+h-1].offset - m_row_info[y].offset;</a>
<a name="ln865">        return track_region;</a>
<a name="ln866">    }</a>
<a name="ln867"> </a>
<a name="ln868">    struct track_info {</a>
<a name="ln869">        int size;</a>
<a name="ln870">        int offset;</a>
<a name="ln871">        SizeReq sr;</a>
<a name="ln872">        int flex_grow = 1;</a>
<a name="ln873">    };</a>
<a name="ln874">    vector&lt;track_info&gt; m_col_info;</a>
<a name="ln875">    vector&lt;track_info&gt; m_row_info;</a>
<a name="ln876"> </a>
<a name="ln877">    struct child_info {</a>
<a name="ln878">        struct {</a>
<a name="ln879">            int x, y;</a>
<a name="ln880">        } pos;</a>
<a name="ln881">        Size span;</a>
<a name="ln882">        shared_ptr&lt;Widget&gt; widget;</a>
<a name="ln883">        inline bool operator==(const child_info&amp; rhs) const { return widget == rhs.widget; }</a>
<a name="ln884">    };</a>
<a name="ln885">    vector&lt;child_info&gt; m_child_info;</a>
<a name="ln886"> </a>
<a name="ln887">    void layout_track(Direction dim, SizeReq sr, int size);</a>
<a name="ln888">    void set_track_offsets(vector&lt;track_info&gt;&amp; tracks);</a>
<a name="ln889">    void compute_track_sizereqs(Direction dim);</a>
<a name="ln890">    void init_track_info();</a>
<a name="ln891">    bool m_track_info_dirty = false;</a>
<a name="ln892"> </a>
<a name="ln893">protected:</a>
<a name="ln894">    class iterator</a>
<a name="ln895">    {</a>
<a name="ln896">    public:</a>
<a name="ln897">        typedef shared_ptr&lt;Widget&gt; value_type;</a>
<a name="ln898">        typedef ptrdiff_t distance;</a>
<a name="ln899">        typedef shared_ptr&lt;Widget&gt;* pointer;</a>
<a name="ln900">        typedef shared_ptr&lt;Widget&gt;&amp; reference;</a>
<a name="ln901">        typedef input_iterator_tag iterator_category;</a>
<a name="ln902"> </a>
<a name="ln903">        vector&lt;child_info&gt;&amp; c;</a>
<a name="ln904">        vector&lt;child_info&gt;::iterator it;</a>
<a name="ln905"> </a>
<a name="ln906">        iterator(vector&lt;child_info&gt;&amp; _c, vector&lt;child_info&gt;::iterator _it) : c(_c), it(_it) {}</a>
<a name="ln907">        void operator++ () { ++it; }</a>
<a name="ln908">        value_type&amp; operator* () { return it-&gt;widget; }</a>
<a name="ln909">        bool operator== (const iterator&amp; other) { return c == other.c &amp;&amp; it == other.it; }</a>
<a name="ln910">        bool operator!= (const iterator&amp; other) { return !(*this == other); }</a>
<a name="ln911">    };</a>
<a name="ln912"> </a>
<a name="ln913">public:</a>
<a name="ln914">    iterator begin() { return iterator(m_child_info, m_child_info.begin()); }</a>
<a name="ln915">    iterator end() { return iterator(m_child_info, m_child_info.end()); }</a>
<a name="ln916">    void for_each_child(function&lt;void(shared_ptr&lt;Widget&gt;&amp;)&gt; f) override</a>
<a name="ln917">    {</a>
<a name="ln918">        for (auto&amp; child : *this)</a>
<a name="ln919">            f(child);</a>
<a name="ln920">    }</a>
<a name="ln921">};</a>
<a name="ln922"> </a>
<a name="ln923">class Scroller : public Bin</a>
<a name="ln924">{</a>
<a name="ln925">public:</a>
<a name="ln926">    virtual ~Scroller() {}</a>
<a name="ln927"> </a>
<a name="ln928">    virtual void set_scroll(int y);</a>
<a name="ln929"> </a>
<a name="ln930">    int get_scroll() const</a>
<a name="ln931">    {</a>
<a name="ln932">        return m_scroll;</a>
<a name="ln933">    }</a>
<a name="ln934"> </a>
<a name="ln935">    void set_scrollbar_visible(bool vis)</a>
<a name="ln936">    {</a>
<a name="ln937">        m_scrolbar_visible = vis;</a>
<a name="ln938">    }</a>
<a name="ln939"> </a>
<a name="ln940">    void _render() override;</a>
<a name="ln941">    SizeReq _get_preferred_size(Direction dim, int prosp_width) override;</a>
<a name="ln942">    void _allocate_region() override;</a>
<a name="ln943">    bool on_event(const Event&amp; event) override;</a>
<a name="ln944"> </a>
<a name="ln945">protected:</a>
<a name="ln946">    int m_scroll = 0;</a>
<a name="ln947">    bool m_scrolbar_visible = true;</a>
<a name="ln948">#ifdef USE_TILE_LOCAL</a>
<a name="ln949">    VertBuffer m_shade_buf = VertBuffer(false, true);</a>
<a name="ln950">    ShapeBuffer m_scrollbar_buf;</a>
<a name="ln951">#endif</a>
<a name="ln952">};</a>
<a name="ln953"> </a>
<a name="ln954">class Layout : public Bin</a>
<a name="ln955">{</a>
<a name="ln956">public:</a>
<a name="ln957">    explicit Layout(shared_ptr&lt;Widget&gt; child);</a>
<a name="ln958"> </a>
<a name="ln959">    void _render() override;</a>
<a name="ln960">    SizeReq _get_preferred_size(Direction dim, int prosp_width) override;</a>
<a name="ln961">    void _allocate_region() override;</a>
<a name="ln962">protected:</a>
<a name="ln963">#ifdef USE_TILE_LOCAL</a>
<a name="ln964">    int m_depth;</a>
<a name="ln965">#endif</a>
<a name="ln966">};</a>
<a name="ln967"> </a>
<a name="ln968">class Popup : public Layout</a>
<a name="ln969">{</a>
<a name="ln970">public:</a>
<a name="ln971">    explicit Popup(shared_ptr&lt;Widget&gt; child) : Layout(move(child)) {}</a>
<a name="ln972"> </a>
<a name="ln973">    void _render() override;</a>
<a name="ln974">    SizeReq _get_preferred_size(Direction dim, int prosp_width) override;</a>
<a name="ln975">    void _allocate_region() override;</a>
<a name="ln976"> </a>
<a name="ln977">    Size get_max_child_size();</a>
<a name="ln978"> </a>
<a name="ln979">protected:</a>
<a name="ln980">#ifdef USE_TILE_LOCAL</a>
<a name="ln981">    ShapeBuffer m_buf;</a>
<a name="ln982">    static constexpr int m_depth_indent = 20;</a>
<a name="ln983">    static constexpr int m_padding = 23;</a>
<a name="ln984"> </a>
<a name="ln985">    int base_margin();</a>
<a name="ln986">#endif</a>
<a name="ln987">    bool m_centred{!crawl_state.need_save};</a>
<a name="ln988">};</a>
<a name="ln989"> </a>
<a name="ln990">class Checkbox : public Bin</a>
<a name="ln991">{</a>
<a name="ln992">public:</a>
<a name="ln993">    Checkbox() {};</a>
<a name="ln994"> </a>
<a name="ln995">    virtual void _render() override;</a>
<a name="ln996">    virtual SizeReq _get_preferred_size(Direction dim, int prosp_width) override;</a>
<a name="ln997">    virtual void _allocate_region() override;</a>
<a name="ln998"> </a>
<a name="ln999">    virtual bool on_event(const Event&amp; event) override;</a>
<a name="ln1000"> </a>
<a name="ln1001">    bool checked() const</a>
<a name="ln1002">    {</a>
<a name="ln1003">        return m_checked;</a>
<a name="ln1004">    };</a>
<a name="ln1005"> </a>
<a name="ln1006">    void set_checked(bool _checked)</a>
<a name="ln1007">    {</a>
<a name="ln1008">        if (m_checked == _checked)</a>
<a name="ln1009">            return;</a>
<a name="ln1010">        m_checked = _checked;</a>
<a name="ln1011">#ifdef USE_TILE_WEB</a>
<a name="ln1012">        sync_state_changed();</a>
<a name="ln1013">#endif</a>
<a name="ln1014">        _expose();</a>
<a name="ln1015">    };</a>
<a name="ln1016"> </a>
<a name="ln1017">protected:</a>
<a name="ln1018">    bool can_take_focus() override { return true; };</a>
<a name="ln1019"> </a>
<a name="ln1020">#ifdef USE_TILE_WEB</a>
<a name="ln1021">    void sync_save_state() override;</a>
<a name="ln1022">    void sync_load_state(const JsonNode *json) override;</a>
<a name="ln1023">#endif</a>
<a name="ln1024"> </a>
<a name="ln1025">    bool m_checked = false;</a>
<a name="ln1026">#ifdef USE_TILE_LOCAL</a>
<a name="ln1027">    bool m_hovered = false;</a>
<a name="ln1028">#endif</a>
<a name="ln1029"> </a>
<a name="ln1030">#ifdef USE_TILE_LOCAL</a>
<a name="ln1031">    static const int check_w = 30;</a>
<a name="ln1032">    static const int check_h = 20;</a>
<a name="ln1033">#else</a>
<a name="ln1034">    static const int check_w = 4;</a>
<a name="ln1035">    static const int check_h = 1;</a>
<a name="ln1036">#endif</a>
<a name="ln1037">};</a>
<a name="ln1038"> </a>
<a name="ln1039">class TextEntry : public Widget</a>
<a name="ln1040">{</a>
<a name="ln1041">public:</a>
<a name="ln1042">    TextEntry();</a>
<a name="ln1043">    virtual void _render() override;</a>
<a name="ln1044">    virtual SizeReq _get_preferred_size(Direction dim, int prosp_width) override;</a>
<a name="ln1045">    virtual void _allocate_region() override;</a>
<a name="ln1046">    virtual bool on_event(const Event&amp; event) override;</a>
<a name="ln1047"> </a>
<a name="ln1048">    void set_font(FontWrapper *font);</a>
<a name="ln1049"> </a>
<a name="ln1050">    string get_text() const { return m_text; };</a>
<a name="ln1051">    void set_text(string s) {</a>
<a name="ln1052">        m_line_reader.set_text(s);</a>
<a name="ln1053">        m_text = m_line_reader.get_text();</a>
<a name="ln1054">        m_cursor = m_line_reader.get_cursor_position();</a>
<a name="ln1055">#ifdef USE_TILE_WEB</a>
<a name="ln1056">        sync_state_changed();</a>
<a name="ln1057">#endif</a>
<a name="ln1058">        _expose();</a>
<a name="ln1059">    };</a>
<a name="ln1060"> </a>
<a name="ln1061">    template&lt;typename T&gt;</a>
<a name="ln1062">    void set_input_history(T&amp;&amp; fn) {</a>
<a name="ln1063">        m_line_reader.set_input_history(forward&lt;T&gt;(fn));</a>
<a name="ln1064">    }</a>
<a name="ln1065"> </a>
<a name="ln1066">    template&lt;typename T&gt;</a>
<a name="ln1067">    void set_keyproc(T&amp;&amp; fn) {</a>
<a name="ln1068">        m_line_reader.set_keyproc(forward&lt;T&gt;(fn));</a>
<a name="ln1069">    }</a>
<a name="ln1070"> </a>
<a name="ln1071">protected:</a>
<a name="ln1072">    bool can_take_focus() override { return true; };</a>
<a name="ln1073"> </a>
<a name="ln1074">#ifdef USE_TILE_WEB</a>
<a name="ln1075">    void sync_save_state() override;</a>
<a name="ln1076">    void sync_load_state(const JsonNode *json) override;</a>
<a name="ln1077">#endif</a>
<a name="ln1078"> </a>
<a name="ln1079">#ifdef USE_TILE_LOCAL</a>
<a name="ln1080">    int padding_size();</a>
<a name="ln1081">#endif</a>
<a name="ln1082"> </a>
<a name="ln1083">    string m_text;</a>
<a name="ln1084">    int m_cursor = 0;</a>
<a name="ln1085">    int m_hscroll = 0;</a>
<a name="ln1086"> </a>
<a name="ln1087">    class LineReader</a>
<a name="ln1088">    {</a>
<a name="ln1089">    public:</a>
<a name="ln1090">        LineReader(char *buffer, size_t bufsz);</a>
<a name="ln1091">        virtual ~LineReader();</a>
<a name="ln1092"> </a>
<a name="ln1093">        typedef keyfun_action (*keyproc)(int &amp;key);</a>
<a name="ln1094"> </a>
<a name="ln1095">        string get_text() const;</a>
<a name="ln1096">        void set_text(string s);</a>
<a name="ln1097"> </a>
<a name="ln1098">        void set_input_history(input_history *ih);</a>
<a name="ln1099">        void set_keyproc(keyproc fn);</a>
<a name="ln1100"> </a>
<a name="ln1101">        void set_edit_mode(edit_mode m);</a>
<a name="ln1102">        edit_mode get_edit_mode();</a>
<a name="ln1103"> </a>
<a name="ln1104">        void set_prompt(string p);</a>
<a name="ln1105"> </a>
<a name="ln1106">        void insert_char_at_cursor(int ch);</a>
<a name="ln1107">        void overwrite_char_at_cursor(int ch);</a>
<a name="ln1108">#ifdef USE_TILE_WEB</a>
<a name="ln1109">        void set_tag(const string &amp;tag);</a>
<a name="ln1110">#endif</a>
<a name="ln1111"> </a>
<a name="ln1112">        int get_cursor_position() {</a>
<a name="ln1113">            return cur - buffer;</a>
<a name="ln1114">        };</a>
<a name="ln1115"> </a>
<a name="ln1116">        int process_key_core(int ch);</a>
<a name="ln1117">        int process_key(int ch);</a>
<a name="ln1118"> </a>
<a name="ln1119">    protected:</a>
<a name="ln1120">        void backspace();</a>
<a name="ln1121">        void delete_char();</a>
<a name="ln1122">        void killword();</a>
<a name="ln1123">        void kill_to_begin();</a>
<a name="ln1124">        void kill_to_end();</a>
<a name="ln1125">#ifdef USE_TILE_LOCAL</a>
<a name="ln1126">        void clipboard_paste();</a>
<a name="ln1127">#endif</a>
<a name="ln1128"> </a>
<a name="ln1129">        bool is_wordchar(char32_t c);</a>
<a name="ln1130"> </a>
<a name="ln1131">    protected:</a>
<a name="ln1132">        char            *buffer;</a>
<a name="ln1133">        size_t          bufsz;</a>
<a name="ln1134">        input_history   *history;</a>
<a name="ln1135">        keyproc         keyfn;</a>
<a name="ln1136">        edit_mode       mode;</a>
<a name="ln1137">        string          prompt; // currently only used for webtiles input dialogs</a>
<a name="ln1138"> </a>
<a name="ln1139">#ifdef USE_TILE_WEB</a>
<a name="ln1140">        string          tag; // For identification on the Webtiles client side</a>
<a name="ln1141">#endif</a>
<a name="ln1142"> </a>
<a name="ln1143">        // These are subject to change during editing.</a>
<a name="ln1144">        char            *cur;</a>
<a name="ln1145">        int             length;</a>
<a name="ln1146">    };</a>
<a name="ln1147"> </a>
<a name="ln1148">    char m_buffer[1024];</a>
<a name="ln1149">    LineReader m_line_reader;</a>
<a name="ln1150"> </a>
<a name="ln1151">#ifdef USE_TILE_LOCAL</a>
<a name="ln1152">    ShapeBuffer m_buf;</a>
<a name="ln1153">    FontWrapper *m_font;</a>
<a name="ln1154">#endif</a>
<a name="ln1155">};</a>
<a name="ln1156"> </a>
<a name="ln1157">#ifdef USE_TILE_LOCAL</a>
<a name="ln1158">class Dungeon : public Widget</a>
<a name="ln1159">{</a>
<a name="ln1160">public:</a>
<a name="ln1161">    Dungeon() : m_buf((ImageManager*)tiles.get_image_manager()) {}</a>
<a name="ln1162">    virtual ~Dungeon() {}</a>
<a name="ln1163"> </a>
<a name="ln1164">    void _render() override;</a>
<a name="ln1165">    SizeReq _get_preferred_size(Direction dim, int prosp_width) override;</a>
<a name="ln1166"> </a>
<a name="ln1167">    unsigned width = 0;</a>
<a name="ln1168">    unsigned height = 0;</a>
<a name="ln1169"> </a>
<a name="ln1170">    // FIXME: convert to getter and setter</a>
<a name="ln1171">    DungeonCellBuffer&amp; buf()</a>
<a name="ln1172">    {</a>
<a name="ln1173">        m_dirty = true;</a>
<a name="ln1174">        return m_buf;</a>
<a name="ln1175">    }</a>
<a name="ln1176"> </a>
<a name="ln1177">protected:</a>
<a name="ln1178">    DungeonCellBuffer m_buf;</a>
<a name="ln1179">    bool m_dirty = true;</a>
<a name="ln1180">};</a>
<a name="ln1181"> </a>
<a name="ln1182">class PlayerDoll : public Widget</a>
<a name="ln1183">{</a>
<a name="ln1184">public:</a>
<a name="ln1185">    explicit PlayerDoll(dolls_data doll);</a>
<a name="ln1186">    virtual ~PlayerDoll();</a>
<a name="ln1187"> </a>
<a name="ln1188">    void _render() override;</a>
<a name="ln1189">    SizeReq _get_preferred_size(Direction dim, int prosp_width) override;</a>
<a name="ln1190">    void _allocate_region() override;</a>
<a name="ln1191"> </a>
<a name="ln1192">protected:</a>
<a name="ln1193">    void _pack_doll();</a>
<a name="ln1194"> </a>
<a name="ln1195">    dolls_data m_save_doll;</a>
<a name="ln1196">    vector&lt;tile_def&gt; m_tiles;</a>
<a name="ln1197">    FixedVector&lt;TileBuffer, TEX_MAX&gt; m_tile_buf;</a>
<a name="ln1198">};</a>
<a name="ln1199">#endif</a>
<a name="ln1200"> </a>
<a name="ln1201">#ifdef USE_TILE</a>
<a name="ln1202">void push_cutoff();</a>
<a name="ln1203">void pop_cutoff();</a>
<a name="ln1204"> </a>
<a name="ln1205">class cutoff_point</a>
<a name="ln1206">{</a>
<a name="ln1207">public:</a>
<a name="ln1208">    cutoff_point() { push_cutoff(); }</a>
<a name="ln1209">    ~cutoff_point() { pop_cutoff(); }</a>
<a name="ln1210">};</a>
<a name="ln1211">#endif</a>
<a name="ln1212"> </a>
<a name="ln1213">void push_layout(shared_ptr&lt;Widget&gt; root, KeymapContext km = KMC_DEFAULT);</a>
<a name="ln1214">void pop_layout();</a>
<a name="ln1215">shared_ptr&lt;Widget&gt; top_layout();</a>
<a name="ln1216">void pump_events(int wait_event_timeout = INT_MAX);</a>
<a name="ln1217">void run_layout(shared_ptr&lt;Widget&gt; root, const bool&amp; done,</a>
<a name="ln1218">        shared_ptr&lt;Widget&gt; initial_focus = nullptr);</a>
<a name="ln1219">bool has_layout();</a>
<a name="ln1220">NORETURN void restart_layout();</a>
<a name="ln1221">int getch(KeymapContext km = KMC_DEFAULT);</a>
<a name="ln1222">void force_render();</a>
<a name="ln1223">void render();</a>
<a name="ln1224">void delay(unsigned int ms);</a>
<a name="ln1225"> </a>
<a name="ln1226">void push_scissor(Region scissor);</a>
<a name="ln1227">void pop_scissor();</a>
<a name="ln1228">Region get_scissor();</a>
<a name="ln1229"> </a>
<a name="ln1230">void set_focused_widget(Widget* w);</a>
<a name="ln1231">Widget* get_focused_widget();</a>
<a name="ln1232">bool raise_event(Event&amp; event);</a>
<a name="ln1233"> </a>
<a name="ln1234">#ifdef USE_TILE_WEB</a>
<a name="ln1235">void recv_ui_state_change(const JsonNode *json);</a>
<a name="ln1236">void sync_ui_state();</a>
<a name="ln1237">int layout_generation_id();</a>
<a name="ln1238">#endif</a>
<a name="ln1239"> </a>
<a name="ln1240">// XXX: this is a hack used to ensure that when switching to a</a>
<a name="ln1241">// layout-based UI, the starting window size is correct. This is necessary</a>
<a name="ln1242">// because there's no way to query TilesFramework for the current screen size</a>
<a name="ln1243">void resize(int w, int h);</a>
<a name="ln1244"> </a>
<a name="ln1245">bool is_available();</a>
<a name="ln1246"> </a>
<a name="ln1247">void show_cursor_at(coord_def pos);</a>
<a name="ln1248">void show_cursor_at(int x, int y);</a>
<a name="ln1249"> </a>
<a name="ln1250">class progress_popup</a>
<a name="ln1251">{</a>
<a name="ln1252">public:</a>
<a name="ln1253">    progress_popup(string title, int width);</a>
<a name="ln1254">    ~progress_popup();</a>
<a name="ln1255">    void set_status_text(string status);</a>
<a name="ln1256">    void advance_progress();</a>
<a name="ln1257">    void force_redraw();</a>
<a name="ln1258">private:</a>
<a name="ln1259">    shared_ptr&lt;Popup&gt; contents;</a>
<a name="ln1260">    shared_ptr&lt;Text&gt; progress_bar;</a>
<a name="ln1261">    shared_ptr&lt;Text&gt; status_text;</a>
<a name="ln1262">    unsigned int position;</a>
<a name="ln1263">    unsigned int bar_width;</a>
<a name="ln1264">    formatted_string get_progress_string(unsigned int len);</a>
<a name="ln1265">    unwind_bool no_more;</a>
<a name="ln1266">};</a>
<a name="ln1267"> </a>
<a name="ln1268">}</a>

</code></pre>
<div class="balloon" rel="949"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v1002/" target="_blank">V1002</a> The 'VertBuffer' class, containing pointers, constructor and destructor, is copied by the automatically generated copy constructor.</p></div>
<div class="balloon" rel="868"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v730/" target="_blank">V730</a> Not all members of a class are initialized inside the compiler generated constructor. Consider inspecting: size, offset, sr.</p></div>

<link rel="stylesheet" href="highlight.css">
<script src="highlight.pack.js"></script>
<script src="highlightjs-line-numbers.js"></script>
<script>hljs.initHighlightingOnLoad();</script>
<script>hljs.initLineNumbersOnLoad();</script>
<script>
  $(document).ready(function() {
      $('.balloon').each(function () {
          var bl = $(this);
          var line = bl.attr('rel');
          var text = $('a[name="ln'+line+'"]').text();

          var space_count = 0;
          for(var i = 0; i<text.length; i++){
              var char = text[i];
              if((char !== ' ')&&(char !== '\t'))break;
              if(char === '\t')space_count++;
              space_count++;
          }

          bl.css('margin-left', space_count*8);
          $('a[name="ln'+line+'"]').after(bl);
      });

      window.location = window.location;
  });
</script>
</body>
</html>
