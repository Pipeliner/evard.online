
<html>
<head>

  <meta http-equiv="Content-Type" content="text/html; charset=US-ASCII" />
  <title>tilepick.cc</title>

  <link rel="stylesheet" href="../style.css"/>
  <script src="../jquery-3.2.1.min.js"></script>
</head>
<body>

<pre><code class = "cpp">
<a name="ln1">#include &quot;AppHdr.h&quot;</a>
<a name="ln2"> </a>
<a name="ln3">#include &quot;tilepick.h&quot;</a>
<a name="ln4"> </a>
<a name="ln5">#include &quot;artefact.h&quot;</a>
<a name="ln6">#include &quot;art-enum.h&quot;</a>
<a name="ln7">#include &quot;cloud.h&quot;</a>
<a name="ln8">#include &quot;colour.h&quot;</a>
<a name="ln9">#include &quot;coord.h&quot;</a>
<a name="ln10">#include &quot;coordit.h&quot;</a>
<a name="ln11">#include &quot;describe.h&quot;</a>
<a name="ln12">#include &quot;env.h&quot;</a>
<a name="ln13">#include &quot;files.h&quot;</a>
<a name="ln14">#include &quot;food.h&quot;</a>
<a name="ln15">#include &quot;item-name.h&quot;</a>
<a name="ln16">#include &quot;item-prop.h&quot;</a>
<a name="ln17">#include &quot;item-status-flag-type.h&quot;</a>
<a name="ln18">#include &quot;level-state-type.h&quot;</a>
<a name="ln19">#include &quot;libutil.h&quot;</a>
<a name="ln20">#include &quot;mon-death.h&quot;</a>
<a name="ln21">#include &quot;mon-tentacle.h&quot;</a>
<a name="ln22">#include &quot;mon-util.h&quot;</a>
<a name="ln23">#include &quot;options.h&quot;</a>
<a name="ln24">#include &quot;player.h&quot;</a>
<a name="ln25">#include &quot;shopping.h&quot;</a>
<a name="ln26">#include &quot;state.h&quot;</a>
<a name="ln27">#include &quot;stringutil.h&quot;</a>
<a name="ln28">#include &quot;terrain.h&quot;</a>
<a name="ln29">#include &quot;rltiles/tiledef-dngn.h&quot;</a>
<a name="ln30">#include &quot;tile-flags.h&quot;</a>
<a name="ln31">#include &quot;rltiles/tiledef-gui.h&quot;</a>
<a name="ln32">#include &quot;rltiles/tiledef-main.h&quot;</a>
<a name="ln33">#include &quot;rltiles/tiledef-player.h&quot;</a>
<a name="ln34">#include &quot;rltiles/tiledef-unrand.h&quot;</a>
<a name="ln35">#include &quot;tilemcache.h&quot;</a>
<a name="ln36">#include &quot;tileview.h&quot;</a>
<a name="ln37">#include &quot;transform.h&quot;</a>
<a name="ln38">#include &quot;traps.h&quot;</a>
<a name="ln39">#include &quot;viewgeom.h&quot;</a>
<a name="ln40"> </a>
<a name="ln41">// This should not be changed.</a>
<a name="ln42">COMPILE_CHECK(TILE_DNGN_UNSEEN == 0);</a>
<a name="ln43"> </a>
<a name="ln44">// NOTE: If one of the following asserts fail, it's because the corresponding</a>
<a name="ln45">// enum in item-prop-enum.h was modified, but rltiles/dc-item.txt was not</a>
<a name="ln46">// modified in parallel.</a>
<a name="ln47"> </a>
<a name="ln48">// These brands start with &quot;normal&quot; which there's no tile for, so subtract 1.</a>
<a name="ln49">COMPILE_CHECK(NUM_REAL_SPECIAL_WEAPONS - 1</a>
<a name="ln50">              == TILE_BRAND_WEP_LAST - TILE_BRAND_WEP_FIRST + 1);</a>
<a name="ln51">COMPILE_CHECK(NUM_REAL_SPECIAL_ARMOURS - 1</a>
<a name="ln52">              == TILE_BRAND_ARM_LAST - TILE_BRAND_ARM_FIRST + 1);</a>
<a name="ln53"> </a>
<a name="ln54">COMPILE_CHECK(NUM_RINGS == TILE_RING_ID_LAST - TILE_RING_ID_FIRST + 1);</a>
<a name="ln55">COMPILE_CHECK(NUM_JEWELLERY - AMU_FIRST_AMULET</a>
<a name="ln56">              == TILE_AMU_ID_LAST - TILE_AMU_ID_FIRST + 1);</a>
<a name="ln57">COMPILE_CHECK(NUM_SCROLLS == TILE_SCR_ID_LAST - TILE_SCR_ID_FIRST + 1);</a>
<a name="ln58">COMPILE_CHECK(NUM_STAVES == TILE_STAFF_ID_LAST - TILE_STAFF_ID_FIRST + 1);</a>
<a name="ln59">#if TAG_MAJOR_VERSION == 34</a>
<a name="ln60">COMPILE_CHECK(NUM_RODS == TILE_ROD_ID_LAST - TILE_ROD_ID_FIRST + 1);</a>
<a name="ln61">#endif</a>
<a name="ln62">COMPILE_CHECK(NUM_WANDS == TILE_WAND_ID_LAST - TILE_WAND_ID_FIRST + 1);</a>
<a name="ln63">COMPILE_CHECK(NUM_POTIONS == TILE_POT_ID_LAST - TILE_POT_ID_FIRST + 1);</a>
<a name="ln64"> </a>
<a name="ln65">TextureID get_dngn_tex(tileidx_t idx)</a>
<a name="ln66">{</a>
<a name="ln67">    ASSERT(idx &lt; TILE_FEAT_MAX);</a>
<a name="ln68">    if (idx &lt; TILE_FLOOR_MAX)</a>
<a name="ln69">        return TEX_FLOOR;</a>
<a name="ln70">    else if (idx &lt; TILE_WALL_MAX)</a>
<a name="ln71">        return TEX_WALL;</a>
<a name="ln72">    else</a>
<a name="ln73">        return TEX_FEAT;</a>
<a name="ln74">}</a>
<a name="ln75"> </a>
<a name="ln76">tileidx_t tileidx_trap(trap_type type)</a>
<a name="ln77">{</a>
<a name="ln78">    switch (type)</a>
<a name="ln79">    {</a>
<a name="ln80">    case TRAP_ARROW:</a>
<a name="ln81">        return TILE_DNGN_TRAP_ARROW;</a>
<a name="ln82">    case TRAP_SPEAR:</a>
<a name="ln83">        return TILE_DNGN_TRAP_SPEAR;</a>
<a name="ln84">    case TRAP_DISPERSAL:</a>
<a name="ln85">        return TILE_DNGN_TRAP_DISPERSAL;</a>
<a name="ln86">    case TRAP_TELEPORT:</a>
<a name="ln87">        return TILE_DNGN_TRAP_TELEPORT;</a>
<a name="ln88">    case TRAP_TELEPORT_PERMANENT:</a>
<a name="ln89">        return TILE_DNGN_TRAP_TELEPORT_PERMANENT;</a>
<a name="ln90">    case TRAP_ALARM:</a>
<a name="ln91">        return TILE_DNGN_TRAP_ALARM;</a>
<a name="ln92">    case TRAP_BLADE:</a>
<a name="ln93">        return TILE_DNGN_TRAP_BLADE;</a>
<a name="ln94">    case TRAP_BOLT:</a>
<a name="ln95">        return TILE_DNGN_TRAP_BOLT;</a>
<a name="ln96">    case TRAP_NET:</a>
<a name="ln97">        return TILE_DNGN_TRAP_NET;</a>
<a name="ln98">    case TRAP_ZOT:</a>
<a name="ln99">        return TILE_DNGN_TRAP_ZOT;</a>
<a name="ln100">    case TRAP_DART:</a>
<a name="ln101">        return TILE_DNGN_TRAP_DART;</a>
<a name="ln102">    case TRAP_SHAFT:</a>
<a name="ln103">        return TILE_DNGN_TRAP_SHAFT;</a>
<a name="ln104">    case TRAP_GOLUBRIA:</a>
<a name="ln105">        return TILE_DNGN_TRAP_GOLUBRIA;</a>
<a name="ln106">    case TRAP_PLATE:</a>
<a name="ln107">        return TILE_DNGN_TRAP_PLATE;</a>
<a name="ln108">    case TRAP_WEB:</a>
<a name="ln109">        return TILE_DNGN_TRAP_WEB;</a>
<a name="ln110">    default:</a>
<a name="ln111">        return TILE_DNGN_ERROR;</a>
<a name="ln112">    }</a>
<a name="ln113">}</a>
<a name="ln114"> </a>
<a name="ln115">tileidx_t tileidx_shop(const shop_struct *shop)</a>
<a name="ln116">{</a>
<a name="ln117">    if (!shop)</a>
<a name="ln118">        return TILE_DNGN_ERROR;</a>
<a name="ln119"> </a>
<a name="ln120">    switch (shop-&gt;type)</a>
<a name="ln121">    {</a>
<a name="ln122">        case SHOP_WEAPON:</a>
<a name="ln123">        case SHOP_WEAPON_ANTIQUE:</a>
<a name="ln124">            return TILE_SHOP_WEAPONS;</a>
<a name="ln125">        case SHOP_ARMOUR:</a>
<a name="ln126">        case SHOP_ARMOUR_ANTIQUE:</a>
<a name="ln127">            return TILE_SHOP_ARMOUR;</a>
<a name="ln128">        case SHOP_JEWELLERY:</a>
<a name="ln129">            return TILE_SHOP_JEWELLERY;</a>
<a name="ln130">        case SHOP_EVOKABLES:</a>
<a name="ln131">            return TILE_SHOP_GADGETS;</a>
<a name="ln132">        case SHOP_FOOD:</a>
<a name="ln133">            return TILE_SHOP_FOOD;</a>
<a name="ln134">        case SHOP_BOOK:</a>
<a name="ln135">            return TILE_SHOP_BOOKS;</a>
<a name="ln136">        case SHOP_SCROLL:</a>
<a name="ln137">            return TILE_SHOP_SCROLLS;</a>
<a name="ln138">        case SHOP_DISTILLERY:</a>
<a name="ln139">            return TILE_SHOP_POTIONS;</a>
<a name="ln140">        case SHOP_GENERAL:</a>
<a name="ln141">        case SHOP_GENERAL_ANTIQUE:</a>
<a name="ln142">            return TILE_SHOP_GENERAL;</a>
<a name="ln143">        default:</a>
<a name="ln144">            return TILE_DNGN_ERROR;</a>
<a name="ln145">    }</a>
<a name="ln146">}</a>
<a name="ln147"> </a>
<a name="ln148">tileidx_t tileidx_feature_base(dungeon_feature_type feat)</a>
<a name="ln149">{</a>
<a name="ln150">    switch (feat)</a>
<a name="ln151">    {</a>
<a name="ln152">    case DNGN_UNSEEN:</a>
<a name="ln153">        return TILE_DNGN_UNSEEN;</a>
<a name="ln154">    case DNGN_ROCK_WALL:</a>
<a name="ln155">        return TILE_WALL_NORMAL;</a>
<a name="ln156">    case DNGN_PERMAROCK_WALL:</a>
<a name="ln157">        return TILE_WALL_PERMAROCK;</a>
<a name="ln158">    case DNGN_SLIMY_WALL:</a>
<a name="ln159">        return TILE_WALL_SLIME;</a>
<a name="ln160">    case DNGN_RUNED_DOOR:</a>
<a name="ln161">        return TILE_DNGN_RUNED_DOOR;</a>
<a name="ln162">    case DNGN_RUNED_CLEAR_DOOR:</a>
<a name="ln163">        return TILE_DNGN_RUNED_CLEAR_DOOR;</a>
<a name="ln164">    case DNGN_SEALED_DOOR:</a>
<a name="ln165">        return TILE_DNGN_SEALED_DOOR;</a>
<a name="ln166">    case DNGN_SEALED_CLEAR_DOOR:</a>
<a name="ln167">        return TILE_DNGN_SEALED_CLEAR_DOOR;</a>
<a name="ln168">    case DNGN_GRATE:</a>
<a name="ln169">        return TILE_DNGN_GRATE;</a>
<a name="ln170">    case DNGN_CLEAR_ROCK_WALL:</a>
<a name="ln171">        return TILE_DNGN_TRANSPARENT_WALL;</a>
<a name="ln172">    case DNGN_CLEAR_STONE_WALL:</a>
<a name="ln173">        return TILE_DNGN_TRANSPARENT_STONE;</a>
<a name="ln174">    case DNGN_CLEAR_PERMAROCK_WALL:</a>
<a name="ln175">        return TILE_WALL_PERMAROCK_CLEAR;</a>
<a name="ln176">    case DNGN_STONE_WALL:</a>
<a name="ln177">        return TILE_DNGN_STONE_WALL;</a>
<a name="ln178">    case DNGN_CLOSED_DOOR:</a>
<a name="ln179">        return TILE_DNGN_CLOSED_DOOR;</a>
<a name="ln180">    case DNGN_CLOSED_CLEAR_DOOR:</a>
<a name="ln181">        return TILE_DNGN_CLOSED_CLEAR_DOOR;</a>
<a name="ln182">    case DNGN_METAL_WALL:</a>
<a name="ln183">        return TILE_DNGN_METAL_WALL;</a>
<a name="ln184">    case DNGN_CRYSTAL_WALL:</a>
<a name="ln185">        return TILE_DNGN_CRYSTAL_WALL;</a>
<a name="ln186">    case DNGN_ORCISH_IDOL:</a>
<a name="ln187">        return TILE_DNGN_ORCISH_IDOL;</a>
<a name="ln188">    case DNGN_TREE:</a>
<a name="ln189">        return player_in_branch(BRANCH_SWAMP) ? TILE_DNGN_MANGROVE : TILE_DNGN_TREE;</a>
<a name="ln190">    case DNGN_GRANITE_STATUE:</a>
<a name="ln191">        return TILE_DNGN_GRANITE_STATUE;</a>
<a name="ln192">    case DNGN_LAVA:</a>
<a name="ln193">        return TILE_DNGN_LAVA;</a>
<a name="ln194">    case DNGN_LAVA_SEA:</a>
<a name="ln195">        return TILE_DNGN_LAVA_SEA;</a>
<a name="ln196">    case DNGN_DEEP_WATER:</a>
<a name="ln197">        return TILE_DNGN_DEEP_WATER;</a>
<a name="ln198">    case DNGN_SHALLOW_WATER:</a>
<a name="ln199">        return TILE_DNGN_SHALLOW_WATER;</a>
<a name="ln200">    case DNGN_OPEN_SEA:</a>
<a name="ln201">        return TILE_DNGN_OPEN_SEA;</a>
<a name="ln202">    case DNGN_TOXIC_BOG:</a>
<a name="ln203">        return TILE_DNGN_TOXIC_BOG;</a>
<a name="ln204">    case DNGN_FLOOR:</a>
<a name="ln205">        return TILE_FLOOR_NORMAL;</a>
<a name="ln206">    case DNGN_ENDLESS_SALT:</a>
<a name="ln207">        return TILE_DNGN_ENDLESS_SALT;</a>
<a name="ln208">    case DNGN_ENTER_HELL:</a>
<a name="ln209">        if (player_in_hell())</a>
<a name="ln210">            return TILE_DNGN_RETURN_VESTIBULE;</a>
<a name="ln211">        return TILE_DNGN_ENTER_HELL;</a>
<a name="ln212">    case DNGN_OPEN_DOOR:</a>
<a name="ln213">        return TILE_DNGN_OPEN_DOOR;</a>
<a name="ln214">    case DNGN_OPEN_CLEAR_DOOR:</a>
<a name="ln215">        return TILE_DNGN_OPEN_CLEAR_DOOR;</a>
<a name="ln216">#if TAG_MAJOR_VERSION == 34</a>
<a name="ln217">    case DNGN_TRAP_MECHANICAL:</a>
<a name="ln218">        return TILE_DNGN_TRAP_ARROW;</a>
<a name="ln219">#endif</a>
<a name="ln220">    case DNGN_TRAP_ARROW:</a>
<a name="ln221">        return TILE_DNGN_TRAP_ARROW;</a>
<a name="ln222">    case DNGN_TRAP_SPEAR:</a>
<a name="ln223">        return TILE_DNGN_TRAP_SPEAR;</a>
<a name="ln224">    case DNGN_TRAP_BLADE:</a>
<a name="ln225">        return TILE_DNGN_TRAP_BLADE;</a>
<a name="ln226">    case DNGN_TRAP_DART:</a>
<a name="ln227">        return TILE_DNGN_TRAP_DART;</a>
<a name="ln228">    case DNGN_TRAP_BOLT:</a>
<a name="ln229">        return TILE_DNGN_TRAP_BOLT;</a>
<a name="ln230">    case DNGN_TRAP_NET:</a>
<a name="ln231">        return TILE_DNGN_TRAP_NET;</a>
<a name="ln232">    case DNGN_TRAP_PLATE:</a>
<a name="ln233">        return TILE_DNGN_TRAP_PLATE;</a>
<a name="ln234">    case DNGN_TRAP_DISPERSAL:</a>
<a name="ln235">        return TILE_DNGN_TRAP_DISPERSAL;</a>
<a name="ln236">    case DNGN_TRAP_TELEPORT:</a>
<a name="ln237">        return TILE_DNGN_TRAP_TELEPORT;</a>
<a name="ln238">    case DNGN_TRAP_TELEPORT_PERMANENT:</a>
<a name="ln239">        return TILE_DNGN_TRAP_TELEPORT_PERMANENT;</a>
<a name="ln240">    case DNGN_TRAP_ALARM:</a>
<a name="ln241">        return TILE_DNGN_TRAP_ALARM;</a>
<a name="ln242">    case DNGN_TRAP_ZOT:</a>
<a name="ln243">        return TILE_DNGN_TRAP_ZOT;</a>
<a name="ln244">    case DNGN_TRAP_SHAFT:</a>
<a name="ln245">        return TILE_DNGN_TRAP_SHAFT;</a>
<a name="ln246">    case DNGN_TRAP_WEB:</a>
<a name="ln247">        return TILE_DNGN_TRAP_WEB;</a>
<a name="ln248">#if TAG_MAJOR_VERSION == 34</a>
<a name="ln249">    case DNGN_TELEPORTER:</a>
<a name="ln250">        return TILE_DNGN_TRAP_GOLUBRIA;</a>
<a name="ln251">#endif</a>
<a name="ln252">    case DNGN_TRANSPORTER:</a>
<a name="ln253">        return TILE_DNGN_TRANSPORTER;</a>
<a name="ln254">    case DNGN_TRANSPORTER_LANDING:</a>
<a name="ln255">        return TILE_DNGN_TRANSPORTER_LANDING;</a>
<a name="ln256">    case DNGN_ENTER_SHOP:</a>
<a name="ln257">        return TILE_SHOP_GENERAL;</a>
<a name="ln258">    case DNGN_ABANDONED_SHOP:</a>
<a name="ln259">        return TILE_DNGN_ABANDONED_SHOP;</a>
<a name="ln260">    case DNGN_ENTER_GAUNTLET:</a>
<a name="ln261">        return TILE_DNGN_PORTAL_GAUNTLET;</a>
<a name="ln262">    case DNGN_STONE_STAIRS_DOWN_I:</a>
<a name="ln263">    case DNGN_STONE_STAIRS_DOWN_II:</a>
<a name="ln264">    case DNGN_STONE_STAIRS_DOWN_III:</a>
<a name="ln265">        return TILE_DNGN_STONE_STAIRS_DOWN;</a>
<a name="ln266">    case DNGN_ESCAPE_HATCH_DOWN:</a>
<a name="ln267">        return TILE_DNGN_ESCAPE_HATCH_DOWN;</a>
<a name="ln268">    case DNGN_SEALED_STAIRS_DOWN:</a>
<a name="ln269">        return TILE_DNGN_SEALED_STAIRS_DOWN;</a>
<a name="ln270">    case DNGN_STONE_STAIRS_UP_I:</a>
<a name="ln271">    case DNGN_STONE_STAIRS_UP_II:</a>
<a name="ln272">    case DNGN_STONE_STAIRS_UP_III:</a>
<a name="ln273">        return TILE_DNGN_STONE_STAIRS_UP;</a>
<a name="ln274">    case DNGN_EXIT_GAUNTLET:</a>
<a name="ln275">    case DNGN_ESCAPE_HATCH_UP:</a>
<a name="ln276">        return TILE_DNGN_ESCAPE_HATCH_UP;</a>
<a name="ln277">    case DNGN_SEALED_STAIRS_UP:</a>
<a name="ln278">        return TILE_DNGN_SEALED_STAIRS_UP;</a>
<a name="ln279">    case DNGN_EXIT_DUNGEON:</a>
<a name="ln280">        return TILE_DNGN_EXIT_DUNGEON;</a>
<a name="ln281">    case DNGN_ENTER_DIS:</a>
<a name="ln282">        return TILE_DNGN_ENTER_DIS;</a>
<a name="ln283">    case DNGN_ENTER_GEHENNA:</a>
<a name="ln284">        return TILE_DNGN_ENTER_GEHENNA;</a>
<a name="ln285">    case DNGN_ENTER_COCYTUS:</a>
<a name="ln286">        return TILE_DNGN_ENTER_COCYTUS;</a>
<a name="ln287">    case DNGN_ENTER_TARTARUS:</a>
<a name="ln288">        return TILE_DNGN_ENTER_TARTARUS;</a>
<a name="ln289">    case DNGN_ENTER_ABYSS:</a>
<a name="ln290">    case DNGN_EXIT_THROUGH_ABYSS:</a>
<a name="ln291">        return TILE_DNGN_ENTER_ABYSS;</a>
<a name="ln292">    case DNGN_ABYSSAL_STAIR:</a>
<a name="ln293">        return TILE_DNGN_ABYSSAL_STAIR;</a>
<a name="ln294">    case DNGN_EXIT_HELL:</a>
<a name="ln295">        return TILE_DNGN_RETURN_HELL;</a>
<a name="ln296">    case DNGN_EXIT_ABYSS:</a>
<a name="ln297">        return TILE_DNGN_EXIT_ABYSS;</a>
<a name="ln298">    case DNGN_STONE_ARCH:</a>
<a name="ln299">        if (player_in_branch(BRANCH_VESTIBULE))</a>
<a name="ln300">            return TILE_DNGN_STONE_ARCH_HELL;</a>
<a name="ln301">        return TILE_DNGN_STONE_ARCH;</a>
<a name="ln302">    case DNGN_ENTER_PANDEMONIUM:</a>
<a name="ln303">        return TILE_DNGN_ENTER_PANDEMONIUM;</a>
<a name="ln304">    case DNGN_TRANSIT_PANDEMONIUM:</a>
<a name="ln305">        return TILE_DNGN_TRANSIT_PANDEMONIUM;</a>
<a name="ln306">    case DNGN_EXIT_PANDEMONIUM:</a>
<a name="ln307">        return TILE_DNGN_EXIT_PANDEMONIUM;</a>
<a name="ln308"> </a>
<a name="ln309">    // branch entry stairs</a>
<a name="ln310">#if TAG_MAJOR_VERSION == 34</a>
<a name="ln311">    case DNGN_ENTER_DWARF:</a>
<a name="ln312">    case DNGN_ENTER_FOREST:</a>
<a name="ln313">    case DNGN_ENTER_BLADE:</a>
<a name="ln314">        return TILE_DNGN_ENTER;</a>
<a name="ln315">#endif</a>
<a name="ln316">    case DNGN_ENTER_TEMPLE:</a>
<a name="ln317">        return TILE_DNGN_ENTER_TEMPLE;</a>
<a name="ln318">    case DNGN_ENTER_ORC:</a>
<a name="ln319">        return TILE_DNGN_ENTER_ORC;</a>
<a name="ln320">    case DNGN_ENTER_ELF:</a>
<a name="ln321">        return TILE_DNGN_ENTER_ELF;</a>
<a name="ln322">    case DNGN_ENTER_LAIR:</a>
<a name="ln323">        return TILE_DNGN_ENTER_LAIR;</a>
<a name="ln324">    case DNGN_ENTER_SNAKE:</a>
<a name="ln325">        return TILE_DNGN_ENTER_SNAKE;</a>
<a name="ln326">    case DNGN_ENTER_SWAMP:</a>
<a name="ln327">        return TILE_DNGN_ENTER_SWAMP;</a>
<a name="ln328">    case DNGN_ENTER_SPIDER:</a>
<a name="ln329">        return TILE_DNGN_ENTER_SPIDER;</a>
<a name="ln330">    case DNGN_ENTER_SHOALS:</a>
<a name="ln331">        return TILE_DNGN_ENTER_SHOALS;</a>
<a name="ln332">    case DNGN_ENTER_SLIME:</a>
<a name="ln333">        return TILE_DNGN_ENTER_SLIME;</a>
<a name="ln334">    case DNGN_ENTER_DEPTHS:</a>
<a name="ln335">        return TILE_DNGN_ENTER_DEPTHS;</a>
<a name="ln336">    case DNGN_ENTER_VAULTS:</a>
<a name="ln337">        return you.level_visited(level_id(BRANCH_VAULTS, 1)) ? TILE_DNGN_ENTER_VAULTS_OPEN</a>
<a name="ln338">                              : TILE_DNGN_ENTER_VAULTS_CLOSED;</a>
<a name="ln339">    case DNGN_ENTER_CRYPT:</a>
<a name="ln340">        return TILE_DNGN_ENTER_CRYPT;</a>
<a name="ln341">    case DNGN_ENTER_TOMB:</a>
<a name="ln342">        return TILE_DNGN_ENTER_TOMB;</a>
<a name="ln343">    case DNGN_ENTER_ZOT:</a>
<a name="ln344">        return you.level_visited(level_id(BRANCH_ZOT, 1)) ? TILE_DNGN_ENTER_ZOT_OPEN</a>
<a name="ln345">                              : TILE_DNGN_ENTER_ZOT_CLOSED;</a>
<a name="ln346">    case DNGN_ENTER_ZIGGURAT:</a>
<a name="ln347">        return TILE_DNGN_PORTAL_ZIGGURAT;</a>
<a name="ln348">    case DNGN_ENTER_BAZAAR:</a>
<a name="ln349">        return TILE_DNGN_PORTAL_BAZAAR;</a>
<a name="ln350">    case DNGN_ENTER_TROVE:</a>
<a name="ln351">        return TILE_DNGN_PORTAL_TROVE;</a>
<a name="ln352">    case DNGN_ENTER_SEWER:</a>
<a name="ln353">        return TILE_DNGN_PORTAL_SEWER;</a>
<a name="ln354">    case DNGN_ENTER_OSSUARY:</a>
<a name="ln355">        return TILE_DNGN_PORTAL_OSSUARY;</a>
<a name="ln356">    case DNGN_ENTER_BAILEY:</a>
<a name="ln357">        return TILE_DNGN_PORTAL_BAILEY;</a>
<a name="ln358">    case DNGN_ENTER_ICE_CAVE:</a>
<a name="ln359">        return TILE_DNGN_PORTAL_ICE_CAVE;</a>
<a name="ln360">    case DNGN_ENTER_VOLCANO:</a>
<a name="ln361">        return TILE_DNGN_PORTAL_VOLCANO;</a>
<a name="ln362">    case DNGN_ENTER_WIZLAB:</a>
<a name="ln363">        return TILE_DNGN_PORTAL_WIZARD_LAB;</a>
<a name="ln364">    case DNGN_ENTER_DESOLATION:</a>
<a name="ln365">        return TILE_DNGN_PORTAL_DESOLATION;</a>
<a name="ln366"> </a>
<a name="ln367">    // branch exit stairs</a>
<a name="ln368">#if TAG_MAJOR_VERSION == 34</a>
<a name="ln369">    case DNGN_EXIT_DWARF:</a>
<a name="ln370">    case DNGN_EXIT_FOREST:</a>
<a name="ln371">    case DNGN_EXIT_BLADE:</a>
<a name="ln372">        return TILE_DNGN_RETURN;</a>
<a name="ln373">#endif</a>
<a name="ln374">    case DNGN_EXIT_TEMPLE:</a>
<a name="ln375">        return TILE_DNGN_EXIT_TEMPLE;</a>
<a name="ln376">    case DNGN_EXIT_ORC:</a>
<a name="ln377">        return TILE_DNGN_EXIT_ORC;</a>
<a name="ln378">    case DNGN_EXIT_ELF:</a>
<a name="ln379">        return TILE_DNGN_EXIT_ELF;</a>
<a name="ln380">    case DNGN_EXIT_LAIR:</a>
<a name="ln381">        return TILE_DNGN_EXIT_LAIR;</a>
<a name="ln382">    case DNGN_EXIT_SNAKE:</a>
<a name="ln383">        return TILE_DNGN_EXIT_SNAKE;</a>
<a name="ln384">    case DNGN_EXIT_SWAMP:</a>
<a name="ln385">        return TILE_DNGN_EXIT_SWAMP;</a>
<a name="ln386">    case DNGN_EXIT_SPIDER:</a>
<a name="ln387">        return TILE_DNGN_EXIT_SPIDER;</a>
<a name="ln388">    case DNGN_EXIT_SHOALS:</a>
<a name="ln389">        return TILE_DNGN_EXIT_SHOALS;</a>
<a name="ln390">    case DNGN_EXIT_SLIME:</a>
<a name="ln391">        return TILE_DNGN_EXIT_SLIME;</a>
<a name="ln392">    case DNGN_EXIT_DEPTHS:</a>
<a name="ln393">        return TILE_DNGN_RETURN_DEPTHS;</a>
<a name="ln394">    case DNGN_EXIT_VAULTS:</a>
<a name="ln395">        return TILE_DNGN_EXIT_VAULTS;</a>
<a name="ln396">    case DNGN_EXIT_CRYPT:</a>
<a name="ln397">        return TILE_DNGN_EXIT_CRYPT;</a>
<a name="ln398">    case DNGN_EXIT_TOMB:</a>
<a name="ln399">        return TILE_DNGN_EXIT_TOMB;</a>
<a name="ln400">    case DNGN_EXIT_ZOT:</a>
<a name="ln401">        return TILE_DNGN_RETURN_ZOT;</a>
<a name="ln402"> </a>
<a name="ln403">    case DNGN_EXIT_ZIGGURAT:</a>
<a name="ln404">    case DNGN_EXIT_BAZAAR:</a>
<a name="ln405">    case DNGN_EXIT_TROVE:</a>
<a name="ln406">    case DNGN_EXIT_SEWER:</a>
<a name="ln407">    case DNGN_EXIT_OSSUARY:</a>
<a name="ln408">    case DNGN_EXIT_BAILEY:</a>
<a name="ln409">    case DNGN_EXIT_DESOLATION:</a>
<a name="ln410">        return TILE_DNGN_PORTAL;</a>
<a name="ln411">    case DNGN_EXIT_ICE_CAVE:</a>
<a name="ln412">        return TILE_DNGN_PORTAL_ICE_CAVE;</a>
<a name="ln413">    case DNGN_EXIT_VOLCANO:</a>
<a name="ln414">        return TILE_DNGN_EXIT_VOLCANO;</a>
<a name="ln415">    case DNGN_EXIT_WIZLAB:</a>
<a name="ln416">        return TILE_DNGN_PORTAL_WIZARD_LAB;</a>
<a name="ln417"> </a>
<a name="ln418">#if TAG_MAJOR_VERSION == 34</a>
<a name="ln419">    case DNGN_ENTER_PORTAL_VAULT:</a>
<a name="ln420">    case DNGN_EXIT_PORTAL_VAULT:</a>
<a name="ln421">        return TILE_DNGN_PORTAL;</a>
<a name="ln422">#endif</a>
<a name="ln423">    case DNGN_EXPIRED_PORTAL:</a>
<a name="ln424">        return TILE_DNGN_PORTAL_EXPIRED;</a>
<a name="ln425">    case DNGN_MALIGN_GATEWAY:</a>
<a name="ln426">        return TILE_DNGN_STARRY_PORTAL;</a>
<a name="ln427"> </a>
<a name="ln428">    // altars</a>
<a name="ln429">    case DNGN_ALTAR_ZIN:</a>
<a name="ln430">        return TILE_DNGN_ALTAR_ZIN;</a>
<a name="ln431">    case DNGN_ALTAR_SHINING_ONE:</a>
<a name="ln432">        return TILE_DNGN_ALTAR_SHINING_ONE;</a>
<a name="ln433">    case DNGN_ALTAR_KIKUBAAQUDGHA:</a>
<a name="ln434">        return TILE_DNGN_ALTAR_KIKUBAAQUDGHA;</a>
<a name="ln435">    case DNGN_ALTAR_YREDELEMNUL:</a>
<a name="ln436">        return TILE_DNGN_ALTAR_YREDELEMNUL;</a>
<a name="ln437">    case DNGN_ALTAR_XOM:</a>
<a name="ln438">        return TILE_DNGN_ALTAR_XOM;</a>
<a name="ln439">    case DNGN_ALTAR_VEHUMET:</a>
<a name="ln440">        return TILE_DNGN_ALTAR_VEHUMET;</a>
<a name="ln441">    case DNGN_ALTAR_OKAWARU:</a>
<a name="ln442">        return TILE_DNGN_ALTAR_OKAWARU;</a>
<a name="ln443">    case DNGN_ALTAR_MAKHLEB:</a>
<a name="ln444">        return TILE_DNGN_ALTAR_MAKHLEB;</a>
<a name="ln445">    case DNGN_ALTAR_SIF_MUNA:</a>
<a name="ln446">        return TILE_DNGN_ALTAR_SIF_MUNA;</a>
<a name="ln447">    case DNGN_ALTAR_TROG:</a>
<a name="ln448">        return TILE_DNGN_ALTAR_TROG;</a>
<a name="ln449">    case DNGN_ALTAR_NEMELEX_XOBEH:</a>
<a name="ln450">        return TILE_DNGN_ALTAR_NEMELEX_XOBEH;</a>
<a name="ln451">    case DNGN_ALTAR_ELYVILON:</a>
<a name="ln452">        return TILE_DNGN_ALTAR_ELYVILON;</a>
<a name="ln453">    case DNGN_ALTAR_LUGONU:</a>
<a name="ln454">        return TILE_DNGN_ALTAR_LUGONU;</a>
<a name="ln455">    case DNGN_ALTAR_BEOGH:</a>
<a name="ln456">        return TILE_DNGN_ALTAR_BEOGH;</a>
<a name="ln457">    case DNGN_ALTAR_JIYVA:</a>
<a name="ln458">        return TILE_DNGN_ALTAR_JIYVA;</a>
<a name="ln459">    case DNGN_ALTAR_FEDHAS:</a>
<a name="ln460">        return TILE_DNGN_ALTAR_FEDHAS;</a>
<a name="ln461">    case DNGN_ALTAR_CHEIBRIADOS:</a>
<a name="ln462">        return TILE_DNGN_ALTAR_CHEIBRIADOS;</a>
<a name="ln463">    case DNGN_ALTAR_ASHENZARI:</a>
<a name="ln464">        return TILE_DNGN_ALTAR_ASHENZARI;</a>
<a name="ln465">    case DNGN_ALTAR_DITHMENOS:</a>
<a name="ln466">        return TILE_DNGN_ALTAR_DITHMENOS;</a>
<a name="ln467">    case DNGN_ALTAR_GOZAG:</a>
<a name="ln468">        return TILE_DNGN_ALTAR_GOZAG;</a>
<a name="ln469">    case DNGN_ALTAR_QAZLAL:</a>
<a name="ln470">        return TILE_DNGN_ALTAR_QAZLAL;</a>
<a name="ln471">    case DNGN_ALTAR_RU:</a>
<a name="ln472">        return TILE_DNGN_ALTAR_RU;</a>
<a name="ln473">#if TAG_MAJOR_VERSION == 34</a>
<a name="ln474">    case DNGN_ALTAR_PAKELLAS:</a>
<a name="ln475">        return TILE_DNGN_ALTAR_PAKELLAS;</a>
<a name="ln476">#endif</a>
<a name="ln477">    case DNGN_ALTAR_USKAYAW:</a>
<a name="ln478">        return TILE_DNGN_ALTAR_USKAYAW;</a>
<a name="ln479">    case DNGN_ALTAR_HEPLIAKLQANA:</a>
<a name="ln480">        return TILE_DNGN_ALTAR_HEPLIAKLQANA;</a>
<a name="ln481">    case DNGN_ALTAR_WU_JIAN:</a>
<a name="ln482">        return TILE_DNGN_ALTAR_WU_JIAN;</a>
<a name="ln483">    case DNGN_ALTAR_ECUMENICAL:</a>
<a name="ln484">        return TILE_DNGN_ALTAR_ECUMENICAL;</a>
<a name="ln485">    case DNGN_FOUNTAIN_BLUE:</a>
<a name="ln486">        return TILE_DNGN_BLUE_FOUNTAIN;</a>
<a name="ln487">    case DNGN_FOUNTAIN_SPARKLING:</a>
<a name="ln488">        return TILE_DNGN_SPARKLING_FOUNTAIN;</a>
<a name="ln489">    case DNGN_FOUNTAIN_BLOOD:</a>
<a name="ln490">        return TILE_DNGN_BLOOD_FOUNTAIN;</a>
<a name="ln491">    case DNGN_DRY_FOUNTAIN:</a>
<a name="ln492">        return TILE_DNGN_DRY_FOUNTAIN;</a>
<a name="ln493">    case DNGN_PASSAGE_OF_GOLUBRIA:</a>
<a name="ln494">        return TILE_DNGN_TRAP_GOLUBRIA;</a>
<a name="ln495">    case DNGN_UNKNOWN_ALTAR:</a>
<a name="ln496">        return TILE_DNGN_UNKNOWN_ALTAR;</a>
<a name="ln497">    case DNGN_UNKNOWN_PORTAL:</a>
<a name="ln498">        return TILE_DNGN_UNKNOWN_PORTAL;</a>
<a name="ln499">    default:</a>
<a name="ln500">        return TILE_DNGN_ERROR;</a>
<a name="ln501">    }</a>
<a name="ln502">}</a>
<a name="ln503"> </a>
<a name="ln504">bool is_door_tile(tileidx_t tile)</a>
<a name="ln505">{</a>
<a name="ln506">    return tile &gt;= TILE_DNGN_CLOSED_DOOR &amp;&amp;</a>
<a name="ln507">        tile &lt; TILE_DNGN_STONE_ARCH;</a>
<a name="ln508">}</a>
<a name="ln509"> </a>
<a name="ln510">tileidx_t tileidx_feature(const coord_def &amp;gc)</a>
<a name="ln511">{</a>
<a name="ln512">    dungeon_feature_type feat = env.map_knowledge(gc).feat();</a>
<a name="ln513"> </a>
<a name="ln514">    tileidx_t override = env.tile_flv(gc).feat;</a>
<a name="ln515">    bool can_override = !feat_is_door(feat)</a>
<a name="ln516">                        &amp;&amp; feat != DNGN_FLOOR</a>
<a name="ln517">                        &amp;&amp; feat != DNGN_UNSEEN</a>
<a name="ln518">                        &amp;&amp; feat != DNGN_PASSAGE_OF_GOLUBRIA</a>
<a name="ln519">                        &amp;&amp; feat != DNGN_MALIGN_GATEWAY;</a>
<a name="ln520">    if (override &amp;&amp; can_override)</a>
<a name="ln521">        return override;</a>
<a name="ln522"> </a>
<a name="ln523">    // Any grid-specific tiles.</a>
<a name="ln524">    switch (feat)</a>
<a name="ln525">    {</a>
<a name="ln526">    case DNGN_FLOOR:</a>
<a name="ln527">        if (env.level_state &amp; LSTATE_SLIMY_WALL)</a>
<a name="ln528">            for (adjacent_iterator ai(gc); ai; ++ai)</a>
<a name="ln529">                if (env.map_knowledge(*ai).feat() == DNGN_SLIMY_WALL)</a>
<a name="ln530">                    return TILE_FLOOR_SLIME_ACIDIC;</a>
<a name="ln531"> </a>
<a name="ln532">        if (env.level_state &amp; LSTATE_ICY_WALL)</a>
<a name="ln533">        {</a>
<a name="ln534">            for (adjacent_iterator ai(gc); ai; ++ai)</a>
<a name="ln535">            {</a>
<a name="ln536">                if (feat_is_wall(env.map_knowledge(*ai).feat())</a>
<a name="ln537">                    &amp;&amp; env.map_knowledge(*ai).flags &amp; MAP_ICY)</a>
<a name="ln538">                {</a>
<a name="ln539">                    return TILE_FLOOR_ICY;</a>
<a name="ln540">                }</a>
<a name="ln541">            }</a>
<a name="ln542">        }</a>
<a name="ln543">        // deliberate fall-through</a>
<a name="ln544">    case DNGN_ROCK_WALL:</a>
<a name="ln545">    case DNGN_STONE_WALL:</a>
<a name="ln546">    case DNGN_CRYSTAL_WALL:</a>
<a name="ln547">    case DNGN_PERMAROCK_WALL:</a>
<a name="ln548">    case DNGN_CLEAR_PERMAROCK_WALL:</a>
<a name="ln549">    {</a>
<a name="ln550">        unsigned colour = env.map_knowledge(gc).feat_colour();</a>
<a name="ln551">        if (colour == 0)</a>
<a name="ln552">        {</a>
<a name="ln553">            colour = feat == DNGN_FLOOR     ? env.floor_colour :</a>
<a name="ln554">                     feat == DNGN_ROCK_WALL ? env.rock_colour</a>
<a name="ln555">                                            : 0; // meh</a>
<a name="ln556">        }</a>
<a name="ln557">        if (colour &gt;= ETC_FIRST)</a>
<a name="ln558">        {</a>
<a name="ln559">            tileidx_t idx = (feat == DNGN_FLOOR) ? env.tile_flv(gc).floor :</a>
<a name="ln560">                (feat == DNGN_ROCK_WALL) ? env.tile_flv(gc).wall</a>
<a name="ln561">                : tileidx_feature_base(feat);</a>
<a name="ln562"> </a>
<a name="ln563">#ifdef USE_TILE</a>
<a name="ln564">            if (feat == DNGN_STONE_WALL)</a>
<a name="ln565">                apply_variations(env.tile_flv(gc), &amp;idx, gc);</a>
<a name="ln566">#endif</a>
<a name="ln567"> </a>
<a name="ln568">            tileidx_t base = tile_dngn_basetile(idx);</a>
<a name="ln569">            tileidx_t spec = idx - base;</a>
<a name="ln570">            unsigned rc = real_colour(colour, gc);</a>
<a name="ln571">            return tile_dngn_coloured(base, rc) + spec; // XXX</a>
<a name="ln572">        }</a>
<a name="ln573">        return tileidx_feature_base(feat);</a>
<a name="ln574">    }</a>
<a name="ln575"> </a>
<a name="ln576">#if TAG_MAJOR_VERSION == 34</a>
<a name="ln577">    // New trap-type-specific features are handled in default case.</a>
<a name="ln578">    case DNGN_TRAP_MECHANICAL:</a>
<a name="ln579">    case DNGN_TRAP_TELEPORT:</a>
<a name="ln580">        return tileidx_trap(env.map_knowledge(gc).trap());</a>
<a name="ln581">#endif</a>
<a name="ln582"> </a>
<a name="ln583">    case DNGN_TRAP_WEB:</a>
<a name="ln584">    {</a>
<a name="ln585">        /*</a>
<a name="ln586">        trap_type this_trap_type = get_trap_type(gc);</a>
<a name="ln587">        // There's room here to have different types of webs (acid? fire? ice? different strengths?)</a>
<a name="ln588">        if (this_trap_type==TRAP_WEB) {*/</a>
<a name="ln589"> </a>
<a name="ln590">        // Determine web connectivity on all sides</a>
<a name="ln591">        const coord_def neigh[4] =</a>
<a name="ln592">        {</a>
<a name="ln593">            coord_def(gc.x, gc.y - 1),</a>
<a name="ln594">            coord_def(gc.x + 1, gc.y),</a>
<a name="ln595">            coord_def(gc.x, gc.y + 1),</a>
<a name="ln596">            coord_def(gc.x - 1, gc.y),</a>
<a name="ln597">        };</a>
<a name="ln598">        int solid = 0;</a>
<a name="ln599">        for (int i = 0; i &lt; 4; i++)</a>
<a name="ln600">            if (feat_is_solid(env.map_knowledge(neigh[i]).feat())</a>
<a name="ln601">                || env.map_knowledge(neigh[i]).trap() == TRAP_WEB)</a>
<a name="ln602">            {</a>
<a name="ln603">                solid |= 1 &lt;&lt; i;</a>
<a name="ln604">            }</a>
<a name="ln605">        if (solid)</a>
<a name="ln606">            return TILE_DNGN_TRAP_WEB_N - 1 + solid;</a>
<a name="ln607">        return TILE_DNGN_TRAP_WEB;</a>
<a name="ln608">    }</a>
<a name="ln609">    case DNGN_ENTER_SHOP:</a>
<a name="ln610">        return tileidx_shop(shop_at(gc));</a>
<a name="ln611"> </a>
<a name="ln612">    case DNGN_DEEP_WATER:</a>
<a name="ln613">        if (env.map_knowledge(gc).feat_colour() == GREEN</a>
<a name="ln614">            || env.map_knowledge(gc).feat_colour() == LIGHTGREEN)</a>
<a name="ln615">        {</a>
<a name="ln616">            return TILE_DNGN_DEEP_WATER_MURKY;</a>
<a name="ln617">        }</a>
<a name="ln618">        else if (player_in_branch(BRANCH_SHOALS))</a>
<a name="ln619">            return TILE_SHOALS_DEEP_WATER;</a>
<a name="ln620"> </a>
<a name="ln621">        return TILE_DNGN_DEEP_WATER;</a>
<a name="ln622">    case DNGN_SHALLOW_WATER:</a>
<a name="ln623">        {</a>
<a name="ln624">            tileidx_t t = TILE_DNGN_SHALLOW_WATER;</a>
<a name="ln625">            if (env.map_knowledge(gc).feat_colour() == GREEN</a>
<a name="ln626">                || env.map_knowledge(gc).feat_colour() == LIGHTGREEN)</a>
<a name="ln627">            {</a>
<a name="ln628">                t = TILE_DNGN_SHALLOW_WATER_MURKY;</a>
<a name="ln629">            }</a>
<a name="ln630">            else if (player_in_branch(BRANCH_SHOALS))</a>
<a name="ln631">                t = TILE_SHOALS_SHALLOW_WATER;</a>
<a name="ln632"> </a>
<a name="ln633">            if (env.map_knowledge(gc).invisible_monster())</a>
<a name="ln634">            {</a>
<a name="ln635">                // Add disturbance to tile.</a>
<a name="ln636">                t += tile_dngn_count(t);</a>
<a name="ln637">            }</a>
<a name="ln638"> </a>
<a name="ln639">            return t;</a>
<a name="ln640">        }</a>
<a name="ln641">    default:</a>
<a name="ln642">        return tileidx_feature_base(feat);</a>
<a name="ln643">    }</a>
<a name="ln644">}</a>
<a name="ln645"> </a>
<a name="ln646">static tileidx_t _mon_random(tileidx_t tile, int mon_id)</a>
<a name="ln647">{</a>
<a name="ln648">    int count = tile_player_count(tile);</a>
<a name="ln649">    return tile + hash_with_seed(count, mon_id, you.frame_no);</a>
<a name="ln650">}</a>
<a name="ln651"> </a>
<a name="ln652">#ifdef USE_TILE</a>
<a name="ln653">static bool _mons_is_kraken_tentacle(const int mtype)</a>
<a name="ln654">{</a>
<a name="ln655">    return mtype == MONS_KRAKEN_TENTACLE</a>
<a name="ln656">           || mtype == MONS_KRAKEN_TENTACLE_SEGMENT;</a>
<a name="ln657">}</a>
<a name="ln658">#endif</a>
<a name="ln659"> </a>
<a name="ln660">tileidx_t tileidx_tentacle(const monster_info&amp; mon)</a>
<a name="ln661">{</a>
<a name="ln662">    ASSERT(mons_is_tentacle_or_tentacle_segment(mon.type));</a>
<a name="ln663"> </a>
<a name="ln664">    // If the tentacle is submerged, we shouldn't even get here.</a>
<a name="ln665">    ASSERT(!mon.is(MB_SUBMERGED));</a>
<a name="ln666"> </a>
<a name="ln667">    // Get tentacle position.</a>
<a name="ln668">    const coord_def t_pos = mon.pos;</a>
<a name="ln669">    // No parent tentacle, or the connection to the head is unknown.</a>
<a name="ln670">    bool no_head_connect  = !mon.props.exists(&quot;inwards&quot;);</a>
<a name="ln671">    coord_def h_pos       = coord_def(); // head position</a>
<a name="ln672">    if (!no_head_connect)</a>
<a name="ln673">    {</a>
<a name="ln674">        // Get the parent tentacle's location.</a>
<a name="ln675">        h_pos = t_pos + mon.props[&quot;inwards&quot;].get_coord();</a>
<a name="ln676">    }</a>
<a name="ln677">    if (no_head_connect &amp;&amp; (mon.type == MONS_SNAPLASHER_VINE</a>
<a name="ln678">                            || mon.type == MONS_SNAPLASHER_VINE_SEGMENT))</a>
<a name="ln679">    {</a>
<a name="ln680">        // Find an adjacent tree to pretend we're connected to.</a>
<a name="ln681">        for (adjacent_iterator ai(t_pos); ai; ++ai)</a>
<a name="ln682">        {</a>
<a name="ln683">            if (feat_is_tree(grd(*ai)))</a>
<a name="ln684">            {</a>
<a name="ln685">                h_pos = *ai;</a>
<a name="ln686">                no_head_connect = false;</a>
<a name="ln687">                break;</a>
<a name="ln688">            }</a>
<a name="ln689">        }</a>
<a name="ln690">    }</a>
<a name="ln691"> </a>
<a name="ln692">    // Is there a connection to the given direction?</a>
<a name="ln693">    // (either through head or next)</a>
<a name="ln694">    bool north = false, east = false,</a>
<a name="ln695">        south = false, west = false,</a>
<a name="ln696">        north_east = false, south_east = false,</a>
<a name="ln697">        south_west = false, north_west = false;</a>
<a name="ln698"> </a>
<a name="ln699">    if (!no_head_connect)</a>
<a name="ln700">    {</a>
<a name="ln701">        if (h_pos.x == t_pos.x)</a>
<a name="ln702">        {</a>
<a name="ln703">            if (h_pos.y &lt; t_pos.y)</a>
<a name="ln704">                north = true;</a>
<a name="ln705">            else</a>
<a name="ln706">                south = true;</a>
<a name="ln707">        }</a>
<a name="ln708">        else if (h_pos.y == t_pos.y)</a>
<a name="ln709">        {</a>
<a name="ln710">            if (h_pos.x &lt; t_pos.x)</a>
<a name="ln711">                west = true;</a>
<a name="ln712">            else</a>
<a name="ln713">                east = true;</a>
<a name="ln714">        }</a>
<a name="ln715">        else if (h_pos.x &lt; t_pos.x)</a>
<a name="ln716">        {</a>
<a name="ln717">            if (h_pos.y &lt; t_pos.y)</a>
<a name="ln718">                north_west = true;</a>
<a name="ln719">            else</a>
<a name="ln720">                south_west = true;</a>
<a name="ln721">        }</a>
<a name="ln722">        else if (h_pos.x &gt; t_pos.x)</a>
<a name="ln723">        {</a>
<a name="ln724">            if (h_pos.y &lt; t_pos.y)</a>
<a name="ln725">                north_east = true;</a>
<a name="ln726">            else</a>
<a name="ln727">                south_east = true;</a>
<a name="ln728">        }</a>
<a name="ln729">    }</a>
<a name="ln730"> </a>
<a name="ln731">    // Tentacle only requires checking of head position.</a>
<a name="ln732">    if (mons_is_tentacle(mon.type))</a>
<a name="ln733">    {</a>
<a name="ln734">        if (no_head_connect)</a>
<a name="ln735">        {</a>
<a name="ln736">            tileidx_t tile;</a>
<a name="ln737">            switch (mon.type)</a>
<a name="ln738">            {</a>
<a name="ln739">                case MONS_KRAKEN_TENTACLE: tile = TILEP_MONS_KRAKEN_TENTACLE_WATER; break;</a>
<a name="ln740">                case MONS_STARSPAWN_TENTACLE: tile = TILEP_MONS_STARSPAWN_TENTACLE_S; break;</a>
<a name="ln741">                case MONS_ELDRITCH_TENTACLE: tile = TILEP_MONS_ELDRITCH_TENTACLE_PORTAL; break;</a>
<a name="ln742">                case MONS_SNAPLASHER_VINE: tile = TILEP_MONS_VINE_S; break;</a>
<a name="ln743">                default: die(&quot;bad tentacle type&quot;);</a>
<a name="ln744">            }</a>
<a name="ln745"> </a>
<a name="ln746">            bool vary = !(mon.props.exists(&quot;fake&quot;) &amp;&amp; mon.props[&quot;fake&quot;].get_bool());</a>
<a name="ln747">            return vary ? _mon_random(tile, t_pos.y*GXM + t_pos.x) : tile;</a>
<a name="ln748">        }</a>
<a name="ln749"> </a>
<a name="ln750">        // Different handling according to relative positions.</a>
<a name="ln751">        if (north)</a>
<a name="ln752">            return TILEP_MONS_KRAKEN_TENTACLE_N;</a>
<a name="ln753">        if (south)</a>
<a name="ln754">            return TILEP_MONS_KRAKEN_TENTACLE_S;</a>
<a name="ln755">        if (west)</a>
<a name="ln756">            return TILEP_MONS_KRAKEN_TENTACLE_W;</a>
<a name="ln757">        if (east)</a>
<a name="ln758">            return TILEP_MONS_KRAKEN_TENTACLE_E;</a>
<a name="ln759">        if (north_west)</a>
<a name="ln760">            return TILEP_MONS_KRAKEN_TENTACLE_NW;</a>
<a name="ln761">        if (south_west)</a>
<a name="ln762">            return TILEP_MONS_KRAKEN_TENTACLE_SW;</a>
<a name="ln763">        if (north_east)</a>
<a name="ln764">            return TILEP_MONS_KRAKEN_TENTACLE_NE;</a>
<a name="ln765">        if (south_east)</a>
<a name="ln766">            return TILEP_MONS_KRAKEN_TENTACLE_SE;</a>
<a name="ln767">        die(&quot;impossible kraken direction&quot;);</a>
<a name="ln768">    }</a>
<a name="ln769">    // Only tentacle segments from now on.</a>
<a name="ln770">    ASSERT(mons_is_tentacle_segment(mon.type));</a>
<a name="ln771"> </a>
<a name="ln772">    // For segments, we also need the next segment (or end piece).</a>
<a name="ln773">    coord_def n_pos;</a>
<a name="ln774">    bool no_next_connect = !mon.props.exists(&quot;outwards&quot;);</a>
<a name="ln775">    if (!no_next_connect)</a>
<a name="ln776">        n_pos = t_pos + mon.props[&quot;outwards&quot;].get_coord();</a>
<a name="ln777"> </a>
<a name="ln778">    if (no_head_connect &amp;&amp; no_next_connect)</a>
<a name="ln779">    {</a>
<a name="ln780">        // Both head and next are submerged.</a>
<a name="ln781">        return TILEP_MONS_KRAKEN_TENTACLE_SEGMENT_WATER;</a>
<a name="ln782">    }</a>
<a name="ln783"> </a>
<a name="ln784">    if (!no_next_connect)</a>
<a name="ln785">    {</a>
<a name="ln786">        if (n_pos.x == t_pos.x)</a>
<a name="ln787">        {</a>
<a name="ln788">            if (n_pos.y &lt; t_pos.y)</a>
<a name="ln789">                north = true;</a>
<a name="ln790">            else</a>
<a name="ln791">                south = true;</a>
<a name="ln792">        }</a>
<a name="ln793">        else if (n_pos.y == t_pos.y)</a>
<a name="ln794">        {</a>
<a name="ln795">            if (n_pos.x &lt; t_pos.x)</a>
<a name="ln796">                west = true;</a>
<a name="ln797">            else</a>
<a name="ln798">                east = true;</a>
<a name="ln799">        }</a>
<a name="ln800">        else if (n_pos.x &lt; t_pos.x)</a>
<a name="ln801">        {</a>
<a name="ln802">            if (n_pos.y &lt; t_pos.y)</a>
<a name="ln803">                north_west = true;</a>
<a name="ln804">            else</a>
<a name="ln805">                south_west = true;</a>
<a name="ln806">        }</a>
<a name="ln807">        else if (n_pos.x &gt; t_pos.x)</a>
<a name="ln808">        {</a>
<a name="ln809">            if (n_pos.y &lt; t_pos.y)</a>
<a name="ln810">                north_east = true;</a>
<a name="ln811">            else</a>
<a name="ln812">                south_east = true;</a>
<a name="ln813">        }</a>
<a name="ln814">    }</a>
<a name="ln815"> </a>
<a name="ln816">    if (no_head_connect || no_next_connect)</a>
<a name="ln817">    {</a>
<a name="ln818">        // One segment end goes into water, the other</a>
<a name="ln819">        // into the direction of head or next.</a>
<a name="ln820"> </a>
<a name="ln821">        if (north)</a>
<a name="ln822">            return TILEP_MONS_KRAKEN_TENTACLE_SEGMENT_N;</a>
<a name="ln823">        if (south)</a>
<a name="ln824">            return TILEP_MONS_KRAKEN_TENTACLE_SEGMENT_S;</a>
<a name="ln825">        if (west)</a>
<a name="ln826">            return TILEP_MONS_KRAKEN_TENTACLE_SEGMENT_W;</a>
<a name="ln827">        if (east)</a>
<a name="ln828">            return TILEP_MONS_KRAKEN_TENTACLE_SEGMENT_E;</a>
<a name="ln829">        if (north_west)</a>
<a name="ln830">            return TILEP_MONS_KRAKEN_TENTACLE_SEGMENT_NW;</a>
<a name="ln831">        if (south_west)</a>
<a name="ln832">            return TILEP_MONS_KRAKEN_TENTACLE_SEGMENT_SW;</a>
<a name="ln833">        if (north_east)</a>
<a name="ln834">            return TILEP_MONS_KRAKEN_TENTACLE_SEGMENT_NE;</a>
<a name="ln835">        if (south_east)</a>
<a name="ln836">            return TILEP_MONS_KRAKEN_TENTACLE_SEGMENT_SE;</a>
<a name="ln837">        die(&quot;impossible kraken direction&quot;);</a>
<a name="ln838">    }</a>
<a name="ln839"> </a>
<a name="ln840">    // Okay, neither head nor next are submerged.</a>
<a name="ln841">    // Compare all three positions.</a>
<a name="ln842"> </a>
<a name="ln843">    // Straight lines first: Vertical.</a>
<a name="ln844">    if (north &amp;&amp; south)</a>
<a name="ln845">        return TILEP_MONS_KRAKEN_TENTACLE_SEGMENT_N_S;</a>
<a name="ln846">    // Horizontal.</a>
<a name="ln847">    if (east &amp;&amp; west)</a>
<a name="ln848">        return TILEP_MONS_KRAKEN_TENTACLE_SEGMENT_E_W;</a>
<a name="ln849">    // Diagonals.</a>
<a name="ln850">    if (north_west &amp;&amp; south_east)</a>
<a name="ln851">        return TILEP_MONS_KRAKEN_TENTACLE_SEGMENT_NW_SE;</a>
<a name="ln852">    if (north_east &amp;&amp; south_west)</a>
<a name="ln853">        return TILEP_MONS_KRAKEN_TENTACLE_SEGMENT_NE_SW;</a>
<a name="ln854"> </a>
<a name="ln855">    // Curved segments.</a>
<a name="ln856">    if (east &amp;&amp; north)</a>
<a name="ln857">        return TILEP_MONS_KRAKEN_TENTACLE_SEGMENT_E_N;</a>
<a name="ln858">    if (east &amp;&amp; south)</a>
<a name="ln859">        return TILEP_MONS_KRAKEN_TENTACLE_SEGMENT_E_S;</a>
<a name="ln860">    if (south &amp;&amp; west)</a>
<a name="ln861">        return TILEP_MONS_KRAKEN_TENTACLE_SEGMENT_S_W;</a>
<a name="ln862">    if (north &amp;&amp; west)</a>
<a name="ln863">        return TILEP_MONS_KRAKEN_TENTACLE_SEGMENT_N_W;</a>
<a name="ln864">    if (north_east &amp;&amp; north_west)</a>
<a name="ln865">        return TILEP_MONS_KRAKEN_TENTACLE_SEGMENT_NE_NW;</a>
<a name="ln866">    if (south_east &amp;&amp; south_west)</a>
<a name="ln867">        return TILEP_MONS_KRAKEN_TENTACLE_SEGMENT_SE_SW;</a>
<a name="ln868">    if (north_west &amp;&amp; south_west)</a>
<a name="ln869">        return TILEP_MONS_KRAKEN_TENTACLE_SEGMENT_NW_SW;</a>
<a name="ln870">    if (north_east &amp;&amp; south_east)</a>
<a name="ln871">        return TILEP_MONS_KRAKEN_TENTACLE_SEGMENT_NE_SE;</a>
<a name="ln872"> </a>
<a name="ln873">    // Connect corners and edges.</a>
<a name="ln874">    if (north &amp;&amp; south_west)</a>
<a name="ln875">        return TILEP_MONS_KRAKEN_TENTACLE_SEGMENT_N_SW;</a>
<a name="ln876">    if (north &amp;&amp; south_east)</a>
<a name="ln877">        return TILEP_MONS_KRAKEN_TENTACLE_SEGMENT_N_SE;</a>
<a name="ln878">    if (south &amp;&amp; north_west)</a>
<a name="ln879">        return TILEP_MONS_KRAKEN_TENTACLE_SEGMENT_S_NW;</a>
<a name="ln880">    if (south &amp;&amp; north_east)</a>
<a name="ln881">        return TILEP_MONS_KRAKEN_TENTACLE_SEGMENT_S_NE;</a>
<a name="ln882">    if (west &amp;&amp; north_east)</a>
<a name="ln883">        return TILEP_MONS_KRAKEN_TENTACLE_SEGMENT_W_NE;</a>
<a name="ln884">    if (west &amp;&amp; south_east)</a>
<a name="ln885">        return TILEP_MONS_KRAKEN_TENTACLE_SEGMENT_W_SE;</a>
<a name="ln886">    if (east &amp;&amp; north_west)</a>
<a name="ln887">        return TILEP_MONS_KRAKEN_TENTACLE_SEGMENT_E_NW;</a>
<a name="ln888">    if (east &amp;&amp; south_west)</a>
<a name="ln889">        return TILEP_MONS_KRAKEN_TENTACLE_SEGMENT_E_SW;</a>
<a name="ln890"> </a>
<a name="ln891">    // Connections at acute angles; can currently only happen for vines.</a>
<a name="ln892">    if (north &amp;&amp; north_west)</a>
<a name="ln893">        return TILEP_MONS_KRAKEN_TENTACLE_SEGMENT_N_NW;</a>
<a name="ln894">    if (north &amp;&amp; north_east)</a>
<a name="ln895">        return TILEP_MONS_KRAKEN_TENTACLE_SEGMENT_N_NE;</a>
<a name="ln896">    if (east &amp;&amp; north_east)</a>
<a name="ln897">        return TILEP_MONS_KRAKEN_TENTACLE_SEGMENT_E_NE;</a>
<a name="ln898">    if (east &amp;&amp; south_east)</a>
<a name="ln899">        return TILEP_MONS_KRAKEN_TENTACLE_SEGMENT_E_SE;</a>
<a name="ln900">    if (south &amp;&amp; south_east)</a>
<a name="ln901">        return TILEP_MONS_KRAKEN_TENTACLE_SEGMENT_S_SE;</a>
<a name="ln902">    if (south &amp;&amp; south_west)</a>
<a name="ln903">        return TILEP_MONS_KRAKEN_TENTACLE_SEGMENT_S_SW;</a>
<a name="ln904">    if (west &amp;&amp; south_west)</a>
<a name="ln905">        return TILEP_MONS_KRAKEN_TENTACLE_SEGMENT_W_SW;</a>
<a name="ln906">    if (west &amp;&amp; north_west)</a>
<a name="ln907">        return TILEP_MONS_KRAKEN_TENTACLE_SEGMENT_W_NW;</a>
<a name="ln908"> </a>
<a name="ln909">    return TILEP_MONS_PROGRAM_BUG;</a>
<a name="ln910">}</a>
<a name="ln911"> </a>
<a name="ln912">#ifdef USE_TILE</a>
<a name="ln913">tileidx_t tileidx_out_of_bounds(int branch)</a>
<a name="ln914">{</a>
<a name="ln915">    if (branch == BRANCH_SHOALS)</a>
<a name="ln916">        return TILE_DNGN_OPEN_SEA | TILE_FLAG_UNSEEN;</a>
<a name="ln917">    else</a>
<a name="ln918">        return TILE_DNGN_UNSEEN | TILE_FLAG_UNSEEN;</a>
<a name="ln919">}</a>
<a name="ln920"> </a>
<a name="ln921">void tileidx_out_of_los(tileidx_t *fg, tileidx_t *bg, tileidx_t *cloud, const coord_def&amp; gc)</a>
<a name="ln922">{</a>
<a name="ln923">    // Player memory.</a>
<a name="ln924">    tileidx_t mem_fg = env.tile_bk_fg(gc);</a>
<a name="ln925">    tileidx_t mem_bg = env.tile_bk_bg(gc);</a>
<a name="ln926">    tileidx_t mem_cloud = env.tile_bk_cloud(gc);</a>
<a name="ln927"> </a>
<a name="ln928">    // Detected info is just stored in map_knowledge and doesn't get</a>
<a name="ln929">    // written to what the player remembers. We'll feather that in here.</a>
<a name="ln930"> </a>
<a name="ln931">    // save any rays, which will get overwritten by mapped terrain</a>
<a name="ln932">    auto rays = *bg &amp; (TILE_FLAG_RAY_MULTI | TILE_FLAG_RAY_OOR | TILE_FLAG_RAY</a>
<a name="ln933">                        | TILE_FLAG_LANDING);</a>
<a name="ln934"> </a>
<a name="ln935">    const map_cell &amp;cell = env.map_knowledge(gc);</a>
<a name="ln936"> </a>
<a name="ln937">    // Override terrain for magic mapping.</a>
<a name="ln938">    if (!cell.seen() &amp;&amp; env.map_knowledge(gc).mapped())</a>
<a name="ln939">        *bg = tileidx_feature_base(cell.feat());</a>
<a name="ln940">    else</a>
<a name="ln941">        *bg = mem_bg;</a>
<a name="ln942">    *bg |= tileidx_unseen_flag(gc);</a>
<a name="ln943"> </a>
<a name="ln944">    // if out-of-los rays are getting shown that shouldn't be, the bug isn't</a>
<a name="ln945">    // here -- fix it in the targeter</a>
<a name="ln946">    *bg |= rays;</a>
<a name="ln947"> </a>
<a name="ln948">    // Override foreground for monsters/items</a>
<a name="ln949">    if (env.map_knowledge(gc).detected_monster())</a>
<a name="ln950">    {</a>
<a name="ln951">        ASSERT(cell.monster() == MONS_SENSED);</a>
<a name="ln952">        *fg = tileidx_monster_base(cell.monsterinfo()-&gt;base_type, 0);</a>
<a name="ln953">    }</a>
<a name="ln954">    else if (env.map_knowledge(gc).detected_item())</a>
<a name="ln955">        *fg = tileidx_item(*cell.item());</a>
<a name="ln956">    else</a>
<a name="ln957">        *fg = mem_fg;</a>
<a name="ln958"> </a>
<a name="ln959">    *cloud = mem_cloud;</a>
<a name="ln960">}</a>
<a name="ln961"> </a>
<a name="ln962">static tileidx_t _zombie_tile_to_spectral(const tileidx_t z_tile)</a>
<a name="ln963">{</a>
<a name="ln964">    switch (z_tile)</a>
<a name="ln965">    {</a>
<a name="ln966">    case TILEP_MONS_ZOMBIE_SMALL:</a>
<a name="ln967">    case TILEP_MONS_ZOMBIE_SPRIGGAN:</a>
<a name="ln968">    case TILEP_MONS_ZOMBIE_GOBLIN:</a>
<a name="ln969">    case TILEP_MONS_ZOMBIE_HOBGOBLIN:</a>
<a name="ln970">    case TILEP_MONS_ZOMBIE_GNOLL:</a>
<a name="ln971">    case TILEP_MONS_ZOMBIE_KOBOLD:</a>
<a name="ln972">    case TILEP_MONS_ZOMBIE_ORC:</a>
<a name="ln973">    case TILEP_MONS_ZOMBIE_HUMAN:</a>
<a name="ln974">    case TILEP_MONS_ZOMBIE_DRACONIAN:</a>
<a name="ln975">    case TILEP_MONS_ZOMBIE_ELF:</a>
<a name="ln976">    case TILEP_MONS_ZOMBIE_FAUN:</a>
<a name="ln977">    case TILEP_MONS_ZOMBIE_MERFOLK:</a>
<a name="ln978">    case TILEP_MONS_ZOMBIE_MINOTAUR:</a>
<a name="ln979">    case TILEP_MONS_ZOMBIE_MONKEY:</a>
<a name="ln980">        return TILEP_MONS_SPECTRAL_SMALL;</a>
<a name="ln981">    case TILEP_MONS_ZOMBIE_LARGE:</a>
<a name="ln982">    case TILEP_MONS_ZOMBIE_OGRE:</a>
<a name="ln983">    case TILEP_MONS_ZOMBIE_TROLL:</a>
<a name="ln984">    case TILEP_MONS_ZOMBIE_JUGGERNAUT:</a>
<a name="ln985">    case TILEP_MONS_ZOMBIE_UGLY_THING:</a>
<a name="ln986">        return TILEP_MONS_SPECTRAL_LARGE;</a>
<a name="ln987">    case TILEP_MONS_ZOMBIE_QUADRUPED_SMALL:</a>
<a name="ln988">    case TILEP_MONS_ZOMBIE_RAT:</a>
<a name="ln989">    case TILEP_MONS_ZOMBIE_QUOKKA:</a>
<a name="ln990">    case TILEP_MONS_ZOMBIE_JACKAL:</a>
<a name="ln991">    case TILEP_MONS_ZOMBIE_HOUND:</a>
<a name="ln992">    case TILEP_MONS_ZOMBIE_CRAB:</a>
<a name="ln993">    case TILEP_MONS_ZOMBIE_TURTLE:</a>
<a name="ln994">    case TILEP_MONS_ZOMBIE_BEAR:</a>
<a name="ln995">        return TILEP_MONS_SPECTRAL_QUADRUPED_SMALL;</a>
<a name="ln996">    case TILEP_MONS_ZOMBIE_QUADRUPED_LARGE:</a>
<a name="ln997">    case TILEP_MONS_ZOMBIE_ELEPHANT:</a>
<a name="ln998">    case TILEP_MONS_ZOMBIE_YAK:</a>
<a name="ln999">    case TILEP_MONS_ZOMBIE_QUADRUPED_WINGED:</a>
<a name="ln1000">        return TILEP_MONS_SPECTRAL_QUADRUPED_LARGE;</a>
<a name="ln1001">    case TILEP_MONS_ZOMBIE_FROG:</a>
<a name="ln1002">        return TILEP_MONS_SPECTRAL_FROG;</a>
<a name="ln1003">    case TILEP_MONS_ZOMBIE_BAT:</a>
<a name="ln1004">    case TILEP_MONS_ZOMBIE_BIRD: /* no bird spectral tile */</a>
<a name="ln1005">    case TILEP_MONS_ZOMBIE_HARPY:</a>
<a name="ln1006">        return TILEP_MONS_SPECTRAL_BAT;</a>
<a name="ln1007">    case TILEP_MONS_ZOMBIE_BEE:</a>
<a name="ln1008">    case TILEP_MONS_ZOMBIE_MELIAI:</a>
<a name="ln1009">    case TILEP_MONS_ZOMBIE_HORNET:</a>
<a name="ln1010">        return TILEP_MONS_SPECTRAL_BEE;</a>
<a name="ln1011">    case TILEP_MONS_ZOMBIE_BEETLE:</a>
<a name="ln1012">    case TILEP_MONS_ZOMBIE_ROACH:</a>
<a name="ln1013">    case TILEP_MONS_ZOMBIE_BUG:</a>
<a name="ln1014">        return TILEP_MONS_SPECTRAL_BUG;</a>
<a name="ln1015">    case TILEP_MONS_ZOMBIE_FISH:</a>
<a name="ln1016">        return TILEP_MONS_SPECTRAL_FISH;</a>
<a name="ln1017">    case TILEP_MONS_ZOMBIE_CENTAUR:</a>
<a name="ln1018">    case TILEP_MONS_ZOMBIE_YAKTAUR:</a>
<a name="ln1019">        return TILEP_MONS_SPECTRAL_CENTAUR;</a>
<a name="ln1020">    case TILEP_MONS_ZOMBIE_NAGA:</a>
<a name="ln1021">    case TILEP_MONS_ZOMBIE_GUARDIAN_SERPENT:</a>
<a name="ln1022">    case TILEP_MONS_ZOMBIE_SALAMANDER:</a>
<a name="ln1023">        return TILEP_MONS_SPECTRAL_NAGA;</a>
<a name="ln1024">    case TILEP_MONS_ZOMBIE_SNAKE:</a>
<a name="ln1025">    case TILEP_MONS_ZOMBIE_ADDER:</a>
<a name="ln1026">    case TILEP_MONS_ZOMBIE_WORM:</a>
<a name="ln1027">    case TILEP_MONS_ZOMBIE_LINDWURM:</a>
<a name="ln1028">        return TILEP_MONS_SPECTRAL_SNAKE;</a>
<a name="ln1029">    case TILEP_MONS_ZOMBIE_LIZARD:</a>
<a name="ln1030">        return TILEP_MONS_SPECTRAL_LIZARD;</a>
<a name="ln1031">    case TILEP_MONS_ZOMBIE_SCORPION:</a>
<a name="ln1032">    case TILEP_MONS_ZOMBIE_SPIDER_LARGE:</a>
<a name="ln1033">    case TILEP_MONS_ZOMBIE_SPIDER_SMALL:</a>
<a name="ln1034">        return TILEP_MONS_SPECTRAL_SPIDER;</a>
<a name="ln1035">    case TILEP_MONS_ZOMBIE_DRAGON:</a>
<a name="ln1036">    case TILEP_MONS_ZOMBIE_IRON_DRAGON:</a>
<a name="ln1037">    case TILEP_MONS_ZOMBIE_GOLDEN_DRAGON:</a>
<a name="ln1038">    case TILEP_MONS_ZOMBIE_QUICKSILVER_DRAGON:</a>
<a name="ln1039">        return TILEP_MONS_SPECTRAL_DRAGON;</a>
<a name="ln1040">    case TILEP_MONS_ZOMBIE_DRAKE:</a>
<a name="ln1041">    case TILEP_MONS_ZOMBIE_WYVERN:</a>
<a name="ln1042">        return TILEP_MONS_SPECTRAL_DRAKE;</a>
<a name="ln1043">    case TILEP_MONS_ZOMBIE_KRAKEN:</a>
<a name="ln1044">        return TILEP_MONS_SPECTRAL_KRAKEN;</a>
<a name="ln1045">    default:</a>
<a name="ln1046">        if (tile_player_basetile(z_tile) == TILEP_MONS_ZOMBIE_HYDRA)</a>
<a name="ln1047">        {</a>
<a name="ln1048">            return TILEP_MONS_SPECTRAL_HYDRA</a>
<a name="ln1049">                   + (z_tile - TILEP_MONS_ZOMBIE_HYDRA);</a>
<a name="ln1050">        }</a>
<a name="ln1051">    }</a>
<a name="ln1052">    return TILEP_MONS_SPECTRAL_SMALL;</a>
<a name="ln1053">}</a>
<a name="ln1054"> </a>
<a name="ln1055">static tileidx_t _zombie_tile_to_simulacrum(const tileidx_t z_tile)</a>
<a name="ln1056">{</a>
<a name="ln1057">    switch (z_tile)</a>
<a name="ln1058">    {</a>
<a name="ln1059">    case TILEP_MONS_ZOMBIE_SMALL:</a>
<a name="ln1060">    case TILEP_MONS_ZOMBIE_SPRIGGAN:</a>
<a name="ln1061">    case TILEP_MONS_ZOMBIE_GOBLIN:</a>
<a name="ln1062">    case TILEP_MONS_ZOMBIE_HOBGOBLIN:</a>
<a name="ln1063">    case TILEP_MONS_ZOMBIE_GNOLL:</a>
<a name="ln1064">    case TILEP_MONS_ZOMBIE_KOBOLD:</a>
<a name="ln1065">    case TILEP_MONS_ZOMBIE_ORC:</a>
<a name="ln1066">    case TILEP_MONS_ZOMBIE_HUMAN:</a>
<a name="ln1067">    case TILEP_MONS_ZOMBIE_DRACONIAN:</a>
<a name="ln1068">    case TILEP_MONS_ZOMBIE_ELF:</a>
<a name="ln1069">    case TILEP_MONS_ZOMBIE_FAUN:</a>
<a name="ln1070">    case TILEP_MONS_ZOMBIE_MERFOLK:</a>
<a name="ln1071">    case TILEP_MONS_ZOMBIE_MINOTAUR:</a>
<a name="ln1072">    case TILEP_MONS_ZOMBIE_MONKEY:</a>
<a name="ln1073">        return TILEP_MONS_SIMULACRUM_SMALL;</a>
<a name="ln1074">    case TILEP_MONS_ZOMBIE_LARGE:</a>
<a name="ln1075">    case TILEP_MONS_ZOMBIE_OGRE:</a>
<a name="ln1076">    case TILEP_MONS_ZOMBIE_TROLL:</a>
<a name="ln1077">    case TILEP_MONS_ZOMBIE_JUGGERNAUT:</a>
<a name="ln1078">    case TILEP_MONS_ZOMBIE_UGLY_THING:</a>
<a name="ln1079">        return TILEP_MONS_SIMULACRUM_LARGE;</a>
<a name="ln1080">    case TILEP_MONS_ZOMBIE_QUADRUPED_SMALL:</a>
<a name="ln1081">    case TILEP_MONS_ZOMBIE_BEAR:</a>
<a name="ln1082">    case TILEP_MONS_ZOMBIE_RAT:</a>
<a name="ln1083">    case TILEP_MONS_ZOMBIE_QUOKKA:</a>
<a name="ln1084">    case TILEP_MONS_ZOMBIE_JACKAL:</a>
<a name="ln1085">    case TILEP_MONS_ZOMBIE_HOUND:</a>
<a name="ln1086">    case TILEP_MONS_ZOMBIE_CRAB:</a>
<a name="ln1087">    case TILEP_MONS_ZOMBIE_TURTLE:</a>
<a name="ln1088">        return TILEP_MONS_SIMULACRUM_QUADRUPED_SMALL;</a>
<a name="ln1089">    case TILEP_MONS_ZOMBIE_QUADRUPED_LARGE:</a>
<a name="ln1090">    case TILEP_MONS_ZOMBIE_FROG:</a>
<a name="ln1091">    case TILEP_MONS_ZOMBIE_ELEPHANT:</a>
<a name="ln1092">    case TILEP_MONS_ZOMBIE_YAK:</a>
<a name="ln1093">    case TILEP_MONS_ZOMBIE_QUADRUPED_WINGED:</a>
<a name="ln1094">        return TILEP_MONS_SIMULACRUM_QUADRUPED_LARGE;</a>
<a name="ln1095">    case TILEP_MONS_ZOMBIE_BAT:</a>
<a name="ln1096">    case TILEP_MONS_ZOMBIE_BIRD: /* no bird simulacrum tile */</a>
<a name="ln1097">    case TILEP_MONS_ZOMBIE_HARPY:</a>
<a name="ln1098">        return TILEP_MONS_SIMULACRUM_BAT;</a>
<a name="ln1099">    case TILEP_MONS_ZOMBIE_BEE:</a>
<a name="ln1100">    case TILEP_MONS_ZOMBIE_MELIAI:</a>
<a name="ln1101">    case TILEP_MONS_ZOMBIE_HORNET:</a>
<a name="ln1102">        return TILEP_MONS_SIMULACRUM_BEE;</a>
<a name="ln1103">    case TILEP_MONS_ZOMBIE_BEETLE:</a>
<a name="ln1104">    case TILEP_MONS_ZOMBIE_ROACH:</a>
<a name="ln1105">    case TILEP_MONS_ZOMBIE_BUG:</a>
<a name="ln1106">        return TILEP_MONS_SIMULACRUM_BUG;</a>
<a name="ln1107">    case TILEP_MONS_ZOMBIE_FISH:</a>
<a name="ln1108">        return TILEP_MONS_SIMULACRUM_FISH;</a>
<a name="ln1109">    case TILEP_MONS_ZOMBIE_CENTAUR:</a>
<a name="ln1110">    case TILEP_MONS_ZOMBIE_YAKTAUR:</a>
<a name="ln1111">        return TILEP_MONS_SIMULACRUM_CENTAUR;</a>
<a name="ln1112">    case TILEP_MONS_ZOMBIE_NAGA:</a>
<a name="ln1113">    case TILEP_MONS_ZOMBIE_GUARDIAN_SERPENT:</a>
<a name="ln1114">    case TILEP_MONS_ZOMBIE_SALAMANDER:</a>
<a name="ln1115">        return TILEP_MONS_SIMULACRUM_NAGA;</a>
<a name="ln1116">    case TILEP_MONS_ZOMBIE_SNAKE:</a>
<a name="ln1117">    case TILEP_MONS_ZOMBIE_ADDER:</a>
<a name="ln1118">    case TILEP_MONS_ZOMBIE_WORM:</a>
<a name="ln1119">    case TILEP_MONS_ZOMBIE_LINDWURM:</a>
<a name="ln1120">        return TILEP_MONS_SIMULACRUM_SNAKE;</a>
<a name="ln1121">    case TILEP_MONS_ZOMBIE_LIZARD:</a>
<a name="ln1122">        return TILEP_MONS_SIMULACRUM_LIZARD;</a>
<a name="ln1123">    case TILEP_MONS_ZOMBIE_SCORPION:</a>
<a name="ln1124">    case TILEP_MONS_ZOMBIE_SPIDER_LARGE:</a>
<a name="ln1125">    case TILEP_MONS_ZOMBIE_SPIDER_SMALL:</a>
<a name="ln1126">        return TILEP_MONS_SIMULACRUM_SPIDER;</a>
<a name="ln1127">    case TILEP_MONS_ZOMBIE_DRAGON:</a>
<a name="ln1128">    case TILEP_MONS_ZOMBIE_IRON_DRAGON:</a>
<a name="ln1129">    case TILEP_MONS_ZOMBIE_GOLDEN_DRAGON:</a>
<a name="ln1130">    case TILEP_MONS_ZOMBIE_QUICKSILVER_DRAGON:</a>
<a name="ln1131">        return TILEP_MONS_SIMULACRUM_DRAGON;</a>
<a name="ln1132">    case TILEP_MONS_ZOMBIE_DRAKE:</a>
<a name="ln1133">    case TILEP_MONS_ZOMBIE_WYVERN:</a>
<a name="ln1134">        return TILEP_MONS_SIMULACRUM_DRAKE;</a>
<a name="ln1135">    case TILEP_MONS_ZOMBIE_KRAKEN:</a>
<a name="ln1136">        return TILEP_MONS_SIMULACRUM_KRAKEN;</a>
<a name="ln1137">    default:</a>
<a name="ln1138">        if (tile_player_basetile(z_tile) == TILEP_MONS_ZOMBIE_HYDRA)</a>
<a name="ln1139">        {</a>
<a name="ln1140">            return TILEP_MONS_SIMULACRUM_HYDRA</a>
<a name="ln1141">                   + (z_tile - TILEP_MONS_ZOMBIE_HYDRA);</a>
<a name="ln1142">        }</a>
<a name="ln1143">    }</a>
<a name="ln1144">    return TILEP_MONS_SIMULACRUM_SMALL;</a>
<a name="ln1145">}</a>
<a name="ln1146"> </a>
<a name="ln1147">static tileidx_t _zombie_tile_to_skeleton(const tileidx_t z_tile)</a>
<a name="ln1148">{</a>
<a name="ln1149">    switch (z_tile)</a>
<a name="ln1150">    {</a>
<a name="ln1151">    case TILEP_MONS_ZOMBIE_SMALL:</a>
<a name="ln1152">    case TILEP_MONS_ZOMBIE_SPRIGGAN:</a>
<a name="ln1153">    case TILEP_MONS_ZOMBIE_GOBLIN:</a>
<a name="ln1154">    case TILEP_MONS_ZOMBIE_KOBOLD:</a>
<a name="ln1155">    case TILEP_MONS_ZOMBIE_MONKEY:</a>
<a name="ln1156">        return TILEP_MONS_SKELETON_SMALL;</a>
<a name="ln1157">    case TILEP_MONS_ZOMBIE_HOBGOBLIN:</a>
<a name="ln1158">    case TILEP_MONS_ZOMBIE_GNOLL:</a>
<a name="ln1159">    case TILEP_MONS_ZOMBIE_ORC:</a>
<a name="ln1160">    case TILEP_MONS_ZOMBIE_HUMAN:</a>
<a name="ln1161">    case TILEP_MONS_ZOMBIE_ELF:</a>
<a name="ln1162">    case TILEP_MONS_ZOMBIE_MERFOLK:</a>
<a name="ln1163">    case TILEP_MONS_ZOMBIE_MINOTAUR:</a>
<a name="ln1164">    case TILEP_MONS_ZOMBIE_FAUN:</a>
<a name="ln1165">        return TILEP_MONS_SKELETON_MEDIUM;</a>
<a name="ln1166">    case TILEP_MONS_ZOMBIE_TROLL:</a>
<a name="ln1167">        return TILEP_MONS_SKELETON_TROLL;</a>
<a name="ln1168">    case TILEP_MONS_ZOMBIE_LARGE:</a>
<a name="ln1169">    case TILEP_MONS_ZOMBIE_OGRE:</a>
<a name="ln1170">    case TILEP_MONS_ZOMBIE_JUGGERNAUT:</a>
<a name="ln1171">        return TILEP_MONS_SKELETON_LARGE;</a>
<a name="ln1172">    case TILEP_MONS_ZOMBIE_QUADRUPED_SMALL:</a>
<a name="ln1173">    case TILEP_MONS_ZOMBIE_RAT:</a>
<a name="ln1174">    case TILEP_MONS_ZOMBIE_QUOKKA:</a>
<a name="ln1175">    case TILEP_MONS_ZOMBIE_JACKAL:</a>
<a name="ln1176">    case TILEP_MONS_ZOMBIE_HOUND:</a>
<a name="ln1177">    case TILEP_MONS_ZOMBIE_BEETLE:</a>
<a name="ln1178">    case TILEP_MONS_ZOMBIE_ROACH:</a>
<a name="ln1179">    case TILEP_MONS_ZOMBIE_BEAR:</a>
<a name="ln1180">    case TILEP_MONS_ZOMBIE_BUG:</a>
<a name="ln1181">        return TILEP_MONS_SKELETON_QUADRUPED_SMALL;</a>
<a name="ln1182">    case TILEP_MONS_ZOMBIE_LIZARD:</a>
<a name="ln1183">    case TILEP_MONS_ZOMBIE_CRAB:</a>
<a name="ln1184">        return TILEP_MONS_SKELETON_LIZARD;</a>
<a name="ln1185">    case TILEP_MONS_ZOMBIE_TURTLE:</a>
<a name="ln1186">        return TILEP_MONS_SKELETON_TURTLE;</a>
<a name="ln1187">    case TILEP_MONS_ZOMBIE_QUADRUPED_LARGE:</a>
<a name="ln1188">    case TILEP_MONS_ZOMBIE_ELEPHANT:</a>
<a name="ln1189">    case TILEP_MONS_ZOMBIE_YAK:</a>
<a name="ln1190">        return TILEP_MONS_SKELETON_QUADRUPED_LARGE;</a>
<a name="ln1191">    case TILEP_MONS_ZOMBIE_FROG:</a>
<a name="ln1192">        return TILEP_MONS_SKELETON_FROG;</a>
<a name="ln1193">    case TILEP_MONS_ZOMBIE_QUADRUPED_WINGED:</a>
<a name="ln1194">        return TILEP_MONS_SKELETON_QUADRUPED_WINGED;</a>
<a name="ln1195">    case TILEP_MONS_ZOMBIE_BAT:</a>
<a name="ln1196">        return TILEP_MONS_SKELETON_BAT;</a>
<a name="ln1197">    case TILEP_MONS_ZOMBIE_HARPY:</a>
<a name="ln1198">    case TILEP_MONS_ZOMBIE_BIRD:</a>
<a name="ln1199">        return TILEP_MONS_SKELETON_BIRD;</a>
<a name="ln1200">    case TILEP_MONS_ZOMBIE_FISH:</a>
<a name="ln1201">        return TILEP_MONS_SKELETON_FISH;</a>
<a name="ln1202">    case TILEP_MONS_ZOMBIE_CENTAUR:</a>
<a name="ln1203">    case TILEP_MONS_ZOMBIE_YAKTAUR:</a>
<a name="ln1204">        return TILEP_MONS_SKELETON_CENTAUR;</a>
<a name="ln1205">    case TILEP_MONS_ZOMBIE_NAGA:</a>
<a name="ln1206">    case TILEP_MONS_ZOMBIE_GUARDIAN_SERPENT:</a>
<a name="ln1207">    case TILEP_MONS_ZOMBIE_SALAMANDER:</a>
<a name="ln1208">        return TILEP_MONS_SKELETON_NAGA;</a>
<a name="ln1209">    case TILEP_MONS_ZOMBIE_SNAKE:</a>
<a name="ln1210">    case TILEP_MONS_ZOMBIE_ADDER:</a>
<a name="ln1211">    case TILEP_MONS_ZOMBIE_WORM:</a>
<a name="ln1212">    case TILEP_MONS_ZOMBIE_LINDWURM:</a>
<a name="ln1213">        return TILEP_MONS_SKELETON_SNAKE;</a>
<a name="ln1214">    case TILEP_MONS_ZOMBIE_DRAGON:</a>
<a name="ln1215">    case TILEP_MONS_ZOMBIE_IRON_DRAGON:</a>
<a name="ln1216">    case TILEP_MONS_ZOMBIE_GOLDEN_DRAGON:</a>
<a name="ln1217">    case TILEP_MONS_ZOMBIE_QUICKSILVER_DRAGON:</a>
<a name="ln1218">        return TILEP_MONS_SKELETON_DRAGON;</a>
<a name="ln1219">    case TILEP_MONS_ZOMBIE_DRAKE:</a>
<a name="ln1220">    case TILEP_MONS_ZOMBIE_WYVERN:</a>
<a name="ln1221">        return TILEP_MONS_SKELETON_DRAKE;</a>
<a name="ln1222">    case TILEP_MONS_ZOMBIE_UGLY_THING:</a>
<a name="ln1223">        return TILEP_MONS_SKELETON_UGLY_THING;</a>
<a name="ln1224">    case TILEP_MONS_ZOMBIE_DRACONIAN:</a>
<a name="ln1225">        return TILEP_MONS_SKELETON_DRACONIAN;</a>
<a name="ln1226">    default:</a>
<a name="ln1227">        if (tile_player_basetile(z_tile) == TILEP_MONS_ZOMBIE_HYDRA)</a>
<a name="ln1228">        {</a>
<a name="ln1229">            return TILEP_MONS_SKELETON_HYDRA</a>
<a name="ln1230">                   + (z_tile - TILEP_MONS_ZOMBIE_HYDRA);</a>
<a name="ln1231">        }</a>
<a name="ln1232">    }</a>
<a name="ln1233">    return TILEP_MONS_SKELETON_SMALL;</a>
<a name="ln1234">}</a>
<a name="ln1235"> </a>
<a name="ln1236">/**</a>
<a name="ln1237"> * For a given monster, what tile is appropriate for that monster if it's a</a>
<a name="ln1238"> * zombie?</a>
<a name="ln1239"> *</a>
<a name="ln1240"> * If it's another kind of derived undead (e.g. a skeleton), the actual tile to</a>
<a name="ln1241"> * be used will be derived from the zombie tile we return here.</a>
<a name="ln1242"> *</a>
<a name="ln1243"> * @param mon   The monster in question.</a>
<a name="ln1244"> * @return      An appropriate zombie tile; e.g. TILEP_MONS_ZOMBIE_DRAGON.</a>
<a name="ln1245"> */</a>
<a name="ln1246">static tileidx_t _mon_to_zombie_tile(const monster_info &amp;mon)</a>
<a name="ln1247">{</a>
<a name="ln1248">    const monster_type subtype = mon.base_type;</a>
<a name="ln1249"> </a>
<a name="ln1250">    // hydras get special casing</a>
<a name="ln1251"> </a>
<a name="ln1252">    if (subtype == MONS_LERNAEAN_HYDRA &amp;&amp; mon.type == MONS_ZOMBIE)</a>
<a name="ln1253">    {</a>
<a name="ln1254">        // Step down the number of heads to get the appropriate tile:</a>
<a name="ln1255">        // for the last five heads, use tiles 1-5, for greater amounts</a>
<a name="ln1256">        // use the next tile for every 5 more heads.</a>
<a name="ln1257">        return tileidx_mon_clamp(TILEP_MONS_LERNAEAN_HYDRA_ZOMBIE,</a>
<a name="ln1258">                                 mon.number &lt;= 5 ?</a>
<a name="ln1259">                                 mon.number - 1 :</a>
<a name="ln1260">                                 4 + (mon.number - 1)/5);</a>
<a name="ln1261">    }</a>
<a name="ln1262">    if (mons_genus(subtype) == MONS_HYDRA)</a>
<a name="ln1263">        return TILEP_MONS_ZOMBIE_HYDRA + min(mon.num_heads, 5) - 1;</a>
<a name="ln1264"> </a>
<a name="ln1265">    // specific per-species zombies - use to override genuses</a>
<a name="ln1266">    static const map&lt;monster_type, tileidx_t&gt; species_tiles = {</a>
<a name="ln1267">        { MONS_JUGGERNAUT,              TILEP_MONS_ZOMBIE_JUGGERNAUT },</a>
<a name="ln1268">        { MONS_ACID_DRAGON,             TILEP_MONS_ZOMBIE_DRAKE },</a>
<a name="ln1269">        { MONS_STEAM_DRAGON,            TILEP_MONS_ZOMBIE_DRAKE },</a>
<a name="ln1270">        { MONS_JACKAL,                  TILEP_MONS_ZOMBIE_JACKAL },</a>
<a name="ln1271">        { MONS_ADDER,                   TILEP_MONS_ZOMBIE_ADDER },</a>
<a name="ln1272">        { MONS_WOLF_SPIDER,             TILEP_MONS_ZOMBIE_SPIDER_LARGE },</a>
<a name="ln1273">        { MONS_EMPEROR_SCORPION,        TILEP_MONS_ZOMBIE_SPIDER_LARGE },</a>
<a name="ln1274">        { MONS_HOWLER_MONKEY,           TILEP_MONS_ZOMBIE_MONKEY },</a>
<a name="ln1275">        { MONS_IRON_DRAGON,             TILEP_MONS_ZOMBIE_IRON_DRAGON },</a>
<a name="ln1276">        { MONS_GOLDEN_DRAGON,           TILEP_MONS_ZOMBIE_GOLDEN_DRAGON },</a>
<a name="ln1277">        { MONS_QUICKSILVER_DRAGON,      TILEP_MONS_ZOMBIE_QUICKSILVER_DRAGON },</a>
<a name="ln1278">        { MONS_LINDWURM,                TILEP_MONS_ZOMBIE_LINDWURM, },</a>
<a name="ln1279">        { MONS_MELIAI,                  TILEP_MONS_ZOMBIE_MELIAI, },</a>
<a name="ln1280">        { MONS_HORNET,                  TILEP_MONS_ZOMBIE_HORNET, },</a>
<a name="ln1281">    };</a>
<a name="ln1282">    // per-genus zombies - use by default</a>
<a name="ln1283">    static const map&lt;monster_type, tileidx_t&gt; genus_tiles = {</a>
<a name="ln1284">        { MONS_GOBLIN,                  TILEP_MONS_ZOMBIE_GOBLIN },</a>
<a name="ln1285">        { MONS_HOBGOBLIN,               TILEP_MONS_ZOMBIE_HOBGOBLIN },</a>
<a name="ln1286">        { MONS_GNOLL,                   TILEP_MONS_ZOMBIE_GNOLL },</a>
<a name="ln1287">        { MONS_HUMAN,                   TILEP_MONS_ZOMBIE_HUMAN },</a>
<a name="ln1288">        { MONS_GHOUL,                   TILEP_MONS_ZOMBIE_HUMAN }, // for skel</a>
<a name="ln1289">        { MONS_KOBOLD,                  TILEP_MONS_ZOMBIE_KOBOLD },</a>
<a name="ln1290">        { MONS_ORC,                     TILEP_MONS_ZOMBIE_ORC },</a>
<a name="ln1291">        { MONS_TROLL,                   TILEP_MONS_ZOMBIE_TROLL },</a>
<a name="ln1292">        { MONS_OGRE,                    TILEP_MONS_ZOMBIE_OGRE },</a>
<a name="ln1293">        { MONS_HARPY,                   TILEP_MONS_ZOMBIE_HARPY },</a>
<a name="ln1294">        { MONS_DRACONIAN,               TILEP_MONS_ZOMBIE_DRACONIAN },</a>
<a name="ln1295">        { MONS_DRAGON,                  TILEP_MONS_ZOMBIE_DRAGON },</a>
<a name="ln1296">        { MONS_WYVERN,                  TILEP_MONS_ZOMBIE_WYVERN },</a>
<a name="ln1297">        { MONS_DRAKE,                   TILEP_MONS_ZOMBIE_DRAKE },</a>
<a name="ln1298">        { MONS_GIANT_LIZARD,            TILEP_MONS_ZOMBIE_LIZARD },</a>
<a name="ln1299">        { MONS_CROCODILE,               TILEP_MONS_ZOMBIE_LIZARD },</a>
<a name="ln1300">        { MONS_RAT,                     TILEP_MONS_ZOMBIE_RAT },</a>
<a name="ln1301">        { MONS_QUOKKA,                  TILEP_MONS_ZOMBIE_QUOKKA },</a>
<a name="ln1302">        { MONS_HOUND,                   TILEP_MONS_ZOMBIE_HOUND },</a>
<a name="ln1303">        { MONS_FROG,                    TILEP_MONS_ZOMBIE_FROG },</a>
<a name="ln1304">        { MONS_CRAB,                    TILEP_MONS_ZOMBIE_CRAB },</a>
<a name="ln1305">        { MONS_SNAPPING_TURTLE,         TILEP_MONS_ZOMBIE_TURTLE },</a>
<a name="ln1306">        { MONS_WORM,                    TILEP_MONS_ZOMBIE_WORM },</a>
<a name="ln1307">        { MONS_GIANT_COCKROACH,         TILEP_MONS_ZOMBIE_ROACH },</a>
<a name="ln1308">        { MONS_SCORPION,                TILEP_MONS_ZOMBIE_SCORPION },</a>
<a name="ln1309">        { MONS_KRAKEN,                  TILEP_MONS_ZOMBIE_KRAKEN },</a>
<a name="ln1310">        { MONS_OCTOPODE,                TILEP_MONS_ZOMBIE_OCTOPODE },</a>
<a name="ln1311">        { MONS_UGLY_THING,              TILEP_MONS_ZOMBIE_UGLY_THING },</a>
<a name="ln1312">        { MONS_ELEPHANT,                TILEP_MONS_ZOMBIE_ELEPHANT },</a>
<a name="ln1313">        { MONS_ELF,                     TILEP_MONS_ZOMBIE_ELF },</a>
<a name="ln1314">        { MONS_FAUN,                    TILEP_MONS_ZOMBIE_FAUN },</a>
<a name="ln1315">        { MONS_SATYR,                   TILEP_MONS_ZOMBIE_FAUN },</a>
<a name="ln1316">        { MONS_GUARDIAN_SERPENT,        TILEP_MONS_ZOMBIE_GUARDIAN_SERPENT, },</a>
<a name="ln1317">        { MONS_MERFOLK,                 TILEP_MONS_ZOMBIE_MERFOLK, },</a>
<a name="ln1318">        { MONS_MINOTAUR,                TILEP_MONS_ZOMBIE_MINOTAUR, },</a>
<a name="ln1319">        { MONS_SALAMANDER,              TILEP_MONS_ZOMBIE_SALAMANDER, },</a>
<a name="ln1320">        { MONS_SPRIGGAN,                TILEP_MONS_ZOMBIE_SPRIGGAN, },</a>
<a name="ln1321">        { MONS_YAKTAUR,                 TILEP_MONS_ZOMBIE_YAKTAUR, },</a>
<a name="ln1322">        { MONS_YAK,                     TILEP_MONS_ZOMBIE_YAK, },</a>
<a name="ln1323">        { MONS_BEAR,                    TILEP_MONS_ZOMBIE_BEAR, },</a>
<a name="ln1324">    };</a>
<a name="ln1325"> </a>
<a name="ln1326">    struct shape_size_tiles</a>
<a name="ln1327">    {</a>
<a name="ln1328">        tileidx_t small; ///&lt; Z_SMALL and default tile</a>
<a name="ln1329">        tileidx_t big;   ///&lt; Z_BIG tile</a>
<a name="ln1330">    };</a>
<a name="ln1331">    const shape_size_tiles GENERIC_ZOMBIES = { TILEP_MONS_ZOMBIE_SMALL,</a>
<a name="ln1332">                                               TILEP_MONS_ZOMBIE_LARGE };</a>
<a name="ln1333">    static const map&lt;mon_body_shape, shape_size_tiles&gt; shape_tiles = {</a>
<a name="ln1334">        { MON_SHAPE_CENTAUR,            {TILEP_MONS_ZOMBIE_CENTAUR} },</a>
<a name="ln1335">        { MON_SHAPE_NAGA,               {TILEP_MONS_ZOMBIE_NAGA} },</a>
<a name="ln1336">        { MON_SHAPE_QUADRUPED_WINGED,   {TILEP_MONS_ZOMBIE_QUADRUPED_WINGED} },</a>
<a name="ln1337">        { MON_SHAPE_BAT,                {TILEP_MONS_ZOMBIE_BAT} },</a>
<a name="ln1338">        { MON_SHAPE_BIRD,               {TILEP_MONS_ZOMBIE_BIRD} },</a>
<a name="ln1339">        { MON_SHAPE_SNAKE,              {TILEP_MONS_ZOMBIE_SNAKE} },</a>
<a name="ln1340">        { MON_SHAPE_SNAIL,              {TILEP_MONS_ZOMBIE_SNAKE} },</a>
<a name="ln1341">        { MON_SHAPE_FISH,               {TILEP_MONS_ZOMBIE_FISH} },</a>
<a name="ln1342">        { MON_SHAPE_INSECT,             {TILEP_MONS_ZOMBIE_BUG} },</a>
<a name="ln1343">        { MON_SHAPE_CENTIPEDE,          {TILEP_MONS_ZOMBIE_BUG} },</a>
<a name="ln1344">        { MON_SHAPE_INSECT_WINGED,      {TILEP_MONS_ZOMBIE_BEE} },</a>
<a name="ln1345">        { MON_SHAPE_ARACHNID,           {TILEP_MONS_ZOMBIE_SPIDER_SMALL} },</a>
<a name="ln1346">        { MON_SHAPE_QUADRUPED_TAILLESS, {TILEP_MONS_ZOMBIE_QUADRUPED_SMALL,</a>
<a name="ln1347">                                         TILEP_MONS_ZOMBIE_QUADRUPED_LARGE} },</a>
<a name="ln1348">        { MON_SHAPE_QUADRUPED,          {TILEP_MONS_ZOMBIE_QUADRUPED_SMALL,</a>
<a name="ln1349">                                         TILEP_MONS_ZOMBIE_QUADRUPED_LARGE} },</a>
<a name="ln1350">        { MON_SHAPE_HUMANOID,           GENERIC_ZOMBIES },</a>
<a name="ln1351">        { MON_SHAPE_HUMANOID_WINGED,    GENERIC_ZOMBIES },</a>
<a name="ln1352">        { MON_SHAPE_HUMANOID_TAILED,    GENERIC_ZOMBIES },</a>
<a name="ln1353">        { MON_SHAPE_HUMANOID_WINGED_TAILED,   GENERIC_ZOMBIES },</a>
<a name="ln1354">    };</a>
<a name="ln1355"> </a>
<a name="ln1356">    const tileidx_t *subtype_tile = map_find(species_tiles, subtype);</a>
<a name="ln1357">    if (subtype_tile)</a>
<a name="ln1358">        return *subtype_tile;</a>
<a name="ln1359"> </a>
<a name="ln1360">    const tileidx_t *genus_tile = map_find(genus_tiles, mons_genus(subtype));</a>
<a name="ln1361">    if (genus_tile)</a>
<a name="ln1362">        return *genus_tile;</a>
<a name="ln1363"> </a>
<a name="ln1364">    const int z_size = mons_zombie_size(subtype);</a>
<a name="ln1365">    const shape_size_tiles *shape_tile_pair</a>
<a name="ln1366">        = map_find(shape_tiles, get_mon_shape(subtype));</a>
<a name="ln1367">    if (shape_tile_pair)</a>
<a name="ln1368">    {</a>
<a name="ln1369">        if (z_size == Z_BIG &amp;&amp; shape_tile_pair-&gt;big)</a>
<a name="ln1370">            return shape_tile_pair-&gt;big;</a>
<a name="ln1371">        return shape_tile_pair-&gt;small;</a>
<a name="ln1372">    }</a>
<a name="ln1373"> </a>
<a name="ln1374">    return TILEP_ERROR;</a>
<a name="ln1375">}</a>
<a name="ln1376"> </a>
<a name="ln1377">/// What tile should be used for a given derived undead monster?</a>
<a name="ln1378">static tileidx_t _tileidx_monster_zombified(const monster_info&amp; mon)</a>
<a name="ln1379">{</a>
<a name="ln1380">    const tileidx_t zombie_tile = _mon_to_zombie_tile(mon);</a>
<a name="ln1381">    switch (mon.type)</a>
<a name="ln1382">    {</a>
<a name="ln1383">        case MONS_SKELETON:</a>
<a name="ln1384">            return _zombie_tile_to_skeleton(zombie_tile);</a>
<a name="ln1385">        case MONS_SPECTRAL_THING:</a>
<a name="ln1386">            return _zombie_tile_to_spectral(zombie_tile);</a>
<a name="ln1387">        case MONS_SIMULACRUM:</a>
<a name="ln1388">            return _zombie_tile_to_simulacrum(zombie_tile);</a>
<a name="ln1389">        default:</a>
<a name="ln1390">            return zombie_tile;</a>
<a name="ln1391">    }</a>
<a name="ln1392">}</a>
<a name="ln1393"> </a>
<a name="ln1394">// Special case for *taurs which have a different tile</a>
<a name="ln1395">// for when they have a bow.</a>
<a name="ln1396">static bool _bow_offset(const monster_info&amp; mon)</a>
<a name="ln1397">{</a>
<a name="ln1398">    if (!mon.inv[MSLOT_WEAPON])</a>
<a name="ln1399">        return true;</a>
<a name="ln1400"> </a>
<a name="ln1401">    switch (mon.inv[MSLOT_WEAPON]-&gt;sub_type)</a>
<a name="ln1402">    {</a>
<a name="ln1403">    case WPN_SHORTBOW:</a>
<a name="ln1404">    case WPN_LONGBOW:</a>
<a name="ln1405">    case WPN_ARBALEST:</a>
<a name="ln1406">        return false;</a>
<a name="ln1407">    default:</a>
<a name="ln1408">        return true;</a>
<a name="ln1409">    }</a>
<a name="ln1410">}</a>
<a name="ln1411"> </a>
<a name="ln1412">static tileidx_t _mon_mod(tileidx_t tile, int offset)</a>
<a name="ln1413">{</a>
<a name="ln1414">    int count = tile_player_count(tile);</a>
<a name="ln1415">    return tile + offset % count;</a>
<a name="ln1416">}</a>
<a name="ln1417"> </a>
<a name="ln1418">tileidx_t tileidx_mon_clamp(tileidx_t tile, int offset)</a>
<a name="ln1419">{</a>
<a name="ln1420">    int count = tile_player_count(tile);</a>
<a name="ln1421">    return tile + min(max(offset, 0), count - 1);</a>
<a name="ln1422">}</a>
<a name="ln1423"> </a>
<a name="ln1424">// actually, a triangle wave, but it's up to the actual tiles</a>
<a name="ln1425">static tileidx_t _mon_sinus(tileidx_t tile)</a>
<a name="ln1426">{</a>
<a name="ln1427">    int count = tile_player_count(tile);</a>
<a name="ln1428">    ASSERT(count &gt; 0);</a>
<a name="ln1429">    ASSERT(count &gt; 1); // technically, staying put would work</a>
<a name="ln1430">    int n = you.frame_no % (2 * count - 2);</a>
<a name="ln1431">    return (n &lt; count) ? (tile + n) : (tile + 2 * count - 2 - n);</a>
<a name="ln1432">}</a>
<a name="ln1433"> </a>
<a name="ln1434">static tileidx_t _mon_cycle(tileidx_t tile, int offset)</a>
<a name="ln1435">{</a>
<a name="ln1436">    int count = tile_player_count(tile);</a>
<a name="ln1437">    return tile + ((offset + you.frame_no) % count);</a>
<a name="ln1438">}</a>
<a name="ln1439"> </a>
<a name="ln1440">static tileidx_t _modrng(int mod, tileidx_t first, tileidx_t last)</a>
<a name="ln1441">{</a>
<a name="ln1442">    return first + mod % (last - first + 1);</a>
<a name="ln1443">}</a>
<a name="ln1444"> </a>
<a name="ln1445">// This function allows for getting a monster from &quot;just&quot; the type.</a>
<a name="ln1446">// To avoid needless duplication of a cases in tileidx_monster, some</a>
<a name="ln1447">// extra parameters that have reasonable defaults for monsters where</a>
<a name="ln1448">// only the type is known are pushed here.</a>
<a name="ln1449">tileidx_t tileidx_monster_base(int type, int mon_id, bool in_water, int colour,</a>
<a name="ln1450">                               int number, int tile_num_prop, bool vary)</a>
<a name="ln1451">{</a>
<a name="ln1452">    switch (type)</a>
<a name="ln1453">    {</a>
<a name="ln1454">    case MONS_UGLY_THING:</a>
<a name="ln1455">    case MONS_VERY_UGLY_THING:</a>
<a name="ln1456">    {</a>
<a name="ln1457">        const tileidx_t ugly_tile = (type == MONS_VERY_UGLY_THING) ?</a>
<a name="ln1458">            TILEP_MONS_VERY_UGLY_THING : TILEP_MONS_UGLY_THING;</a>
<a name="ln1459">        int colour_offset = ugly_thing_colour_offset(colour);</a>
<a name="ln1460">        return tileidx_mon_clamp(ugly_tile, colour_offset);</a>
<a name="ln1461">    }</a>
<a name="ln1462"> </a>
<a name="ln1463">    case MONS_HYDRA:</a>
<a name="ln1464">        // Number of heads</a>
<a name="ln1465">        return tileidx_mon_clamp(TILEP_MONS_HYDRA, number - 1);</a>
<a name="ln1466">    case MONS_SLIME_CREATURE:</a>
<a name="ln1467">    case MONS_MERGED_SLIME_CREATURE:</a>
<a name="ln1468">        return tileidx_mon_clamp(TILEP_MONS_SLIME_CREATURE, number - 1);</a>
<a name="ln1469">    case MONS_LERNAEAN_HYDRA:</a>
<a name="ln1470">        // Step down the number of heads to get the appropriate tile:</a>
<a name="ln1471">        // For the last five heads, use tiles 1-5, for greater amounts</a>
<a name="ln1472">        // use the next tile for every 5 more heads.</a>
<a name="ln1473">        return tileidx_mon_clamp(TILEP_MONS_LERNAEAN_HYDRA,</a>
<a name="ln1474">                                 number &lt;= 5 ?</a>
<a name="ln1475">                                 number - 1 : 4 + (number - 1)/5);</a>
<a name="ln1476"> </a>
<a name="ln1477">    // draconian ('d')</a>
<a name="ln1478">    case MONS_TIAMAT:</a>
<a name="ln1479">    {</a>
<a name="ln1480">        int offset = 0;</a>
<a name="ln1481">        switch (colour)</a>
<a name="ln1482">        {</a>
<a name="ln1483">        case BLUE:          offset = 0; break;</a>
<a name="ln1484">        case YELLOW:        offset = 1; break;</a>
<a name="ln1485">        case GREEN:         offset = 2; break;</a>
<a name="ln1486">        case LIGHTGREY:     offset = 3; break;</a>
<a name="ln1487">        case LIGHTMAGENTA:  offset = 4; break;</a>
<a name="ln1488">        case CYAN:          offset = 5; break;</a>
<a name="ln1489">        case MAGENTA:       offset = 6; break;</a>
<a name="ln1490">        case LIGHTRED:      offset = 7; break;</a>
<a name="ln1491">        case WHITE:         offset = 8; break;</a>
<a name="ln1492">        }</a>
<a name="ln1493"> </a>
<a name="ln1494">        return TILEP_MONS_TIAMAT + offset;</a>
<a name="ln1495">    }</a>
<a name="ln1496">    }</a>
<a name="ln1497"> </a>
<a name="ln1498">    const monster_type mtype = static_cast&lt;monster_type&gt;(type);</a>
<a name="ln1499">    const tileidx_t base_tile = get_mon_base_tile(mtype);</a>
<a name="ln1500">    const mon_type_tile_variation vary_type = vary ? get_mon_tile_variation(mtype) : TVARY_NONE;</a>
<a name="ln1501">    switch (vary_type)</a>
<a name="ln1502">    {</a>
<a name="ln1503">    case TVARY_NONE:</a>
<a name="ln1504">        return base_tile;</a>
<a name="ln1505">    case TVARY_MOD:</a>
<a name="ln1506">        return _mon_mod(base_tile, tile_num_prop);</a>
<a name="ln1507">    case TVARY_CYCLE:</a>
<a name="ln1508">        return _mon_cycle(base_tile, tile_num_prop);</a>
<a name="ln1509">    case TVARY_RANDOM:</a>
<a name="ln1510">        return _mon_random(base_tile, mon_id);</a>
<a name="ln1511">    case TVARY_WATER:</a>
<a name="ln1512">        return base_tile + (in_water ? 1 : 0);</a>
<a name="ln1513">    default:</a>
<a name="ln1514">        die(&quot;Unknown tile variation type %d for mon %d!&quot;, vary_type, mtype);</a>
<a name="ln1515">    }</a>
<a name="ln1516">}</a>
<a name="ln1517"> </a>
<a name="ln1518">enum class main_dir</a>
<a name="ln1519">{</a>
<a name="ln1520">    north = 0,</a>
<a name="ln1521">    east,</a>
<a name="ln1522">    south,</a>
<a name="ln1523">    west</a>
<a name="ln1524">};</a>
<a name="ln1525"> </a>
<a name="ln1526">enum class tentacle_type</a>
<a name="ln1527">{</a>
<a name="ln1528">    kraken = 0,</a>
<a name="ln1529">    eldritch = 1,</a>
<a name="ln1530">    starspawn = 2,</a>
<a name="ln1531">    vine = 3,</a>
<a name="ln1532">    zombie_kraken = 4,</a>
<a name="ln1533">    simulacrum_kraken = 5,</a>
<a name="ln1534">    spectral_kraken = 6,</a>
<a name="ln1535">};</a>
<a name="ln1536"> </a>
<a name="ln1537">static void _add_tentacle_overlay(const coord_def pos,</a>
<a name="ln1538">                                  const main_dir dir,</a>
<a name="ln1539">                                  tentacle_type type)</a>
<a name="ln1540">{</a>
<a name="ln1541">    /* This adds the corner overlays; e.g. in the following situation:</a>
<a name="ln1542">         .#</a>
<a name="ln1543">         #.</a>
<a name="ln1544">        we need to add corners to the floor tiles since the tentacle</a>
<a name="ln1545">        will otherwise look weird. So when placing the upper tentacle</a>
<a name="ln1546">        tile, this function is called with dir main_dir::west, so the upper</a>
<a name="ln1547">        floor tile gets a corner in the south-east; and similarly,</a>
<a name="ln1548">        when placing the lower tentacle tile, we get called with dir</a>
<a name="ln1549">        main_dir::east to give the lower floor tile a NW overlay.</a>
<a name="ln1550">     */</a>
<a name="ln1551">    coord_def next = pos;</a>
<a name="ln1552">    switch (dir)</a>
<a name="ln1553">    {</a>
<a name="ln1554">        case main_dir::north: next += coord_def( 0, -1); break;</a>
<a name="ln1555">        case main_dir::east:  next += coord_def( 1,  0); break;</a>
<a name="ln1556">        case main_dir::south: next += coord_def( 0,  1); break;</a>
<a name="ln1557">        case main_dir::west:  next += coord_def(-1,  0); break;</a>
<a name="ln1558">        default:</a>
<a name="ln1559">            die(&quot;invalid direction&quot;);</a>
<a name="ln1560">    }</a>
<a name="ln1561">    if (!in_bounds(next))</a>
<a name="ln1562">        return;</a>
<a name="ln1563"> </a>
<a name="ln1564">    const coord_def next_showpos(grid2show(next));</a>
<a name="ln1565">    if (!show_bounds(next_showpos))</a>
<a name="ln1566">        return;</a>
<a name="ln1567"> </a>
<a name="ln1568">    tile_flags flag;</a>
<a name="ln1569">    switch (dir)</a>
<a name="ln1570">    {</a>
<a name="ln1571">        case main_dir::north: flag = TILE_FLAG_TENTACLE_SW; break;</a>
<a name="ln1572">        case main_dir::east: flag = TILE_FLAG_TENTACLE_NW; break;</a>
<a name="ln1573">        case main_dir::south: flag = TILE_FLAG_TENTACLE_NE; break;</a>
<a name="ln1574">        case main_dir::west: flag = TILE_FLAG_TENTACLE_SE; break;</a>
<a name="ln1575">        default: die(&quot;invalid direction&quot;);</a>
<a name="ln1576">    }</a>
<a name="ln1577">    env.tile_bg(next_showpos) |= flag;</a>
<a name="ln1578"> </a>
<a name="ln1579">    switch (type)</a>
<a name="ln1580">    {</a>
<a name="ln1581">        case tentacle_type::eldritch: flag = TILE_FLAG_TENTACLE_ELDRITCH; break;</a>
<a name="ln1582">        case tentacle_type::starspawn: flag = TILE_FLAG_TENTACLE_STARSPAWN; break;</a>
<a name="ln1583">        case tentacle_type::vine: flag = TILE_FLAG_TENTACLE_VINE; break;</a>
<a name="ln1584">        case tentacle_type::zombie_kraken: flag = TILE_FLAG_TENTACLE_ZOMBIE_KRAKEN; break;</a>
<a name="ln1585">        case tentacle_type::simulacrum_kraken: flag = TILE_FLAG_TENTACLE_SIMULACRUM_KRAKEN; break;</a>
<a name="ln1586">        case tentacle_type::spectral_kraken: flag = TILE_FLAG_TENTACLE_SPECTRAL_KRAKEN; break;</a>
<a name="ln1587">        default: flag = TILE_FLAG_TENTACLE_KRAKEN;</a>
<a name="ln1588">    }</a>
<a name="ln1589">    env.tile_bg(next_showpos) |= flag;</a>
<a name="ln1590">}</a>
<a name="ln1591"> </a>
<a name="ln1592">static void _handle_tentacle_overlay(const coord_def pos,</a>
<a name="ln1593">                                     const tileidx_t tile,</a>
<a name="ln1594">                                     tentacle_type type)</a>
<a name="ln1595">{</a>
<a name="ln1596">    switch (tile)</a>
<a name="ln1597">    {</a>
<a name="ln1598">    case TILEP_MONS_KRAKEN_TENTACLE_NW:</a>
<a name="ln1599">    case TILEP_MONS_KRAKEN_TENTACLE_SEGMENT_NW:</a>
<a name="ln1600">    case TILEP_MONS_KRAKEN_TENTACLE_SEGMENT_S_NW:</a>
<a name="ln1601">    case TILEP_MONS_KRAKEN_TENTACLE_SEGMENT_E_NW:</a>
<a name="ln1602">        _add_tentacle_overlay(pos, main_dir::north, type);</a>
<a name="ln1603">        break;</a>
<a name="ln1604">    case TILEP_MONS_KRAKEN_TENTACLE_NE:</a>
<a name="ln1605">    case TILEP_MONS_KRAKEN_TENTACLE_SEGMENT_NE:</a>
<a name="ln1606">    case TILEP_MONS_KRAKEN_TENTACLE_SEGMENT_S_NE:</a>
<a name="ln1607">    case TILEP_MONS_KRAKEN_TENTACLE_SEGMENT_W_NE:</a>
<a name="ln1608">        _add_tentacle_overlay(pos, main_dir::east, type);</a>
<a name="ln1609">        break;</a>
<a name="ln1610">    case TILEP_MONS_KRAKEN_TENTACLE_SE:</a>
<a name="ln1611">    case TILEP_MONS_KRAKEN_TENTACLE_SEGMENT_SE:</a>
<a name="ln1612">    case TILEP_MONS_KRAKEN_TENTACLE_SEGMENT_N_SE:</a>
<a name="ln1613">    case TILEP_MONS_KRAKEN_TENTACLE_SEGMENT_W_SE:</a>
<a name="ln1614">        _add_tentacle_overlay(pos, main_dir::south, type);</a>
<a name="ln1615">        break;</a>
<a name="ln1616">    case TILEP_MONS_KRAKEN_TENTACLE_SW:</a>
<a name="ln1617">    case TILEP_MONS_KRAKEN_TENTACLE_SEGMENT_SW:</a>
<a name="ln1618">    case TILEP_MONS_KRAKEN_TENTACLE_SEGMENT_N_SW:</a>
<a name="ln1619">    case TILEP_MONS_KRAKEN_TENTACLE_SEGMENT_E_SW:</a>
<a name="ln1620">        _add_tentacle_overlay(pos, main_dir::west, type);</a>
<a name="ln1621">        break;</a>
<a name="ln1622">    // diagonals</a>
<a name="ln1623">    case TILEP_MONS_KRAKEN_TENTACLE_SEGMENT_NW_SE:</a>
<a name="ln1624">        _add_tentacle_overlay(pos, main_dir::north, type);</a>
<a name="ln1625">        _add_tentacle_overlay(pos, main_dir::south, type);</a>
<a name="ln1626">        break;</a>
<a name="ln1627">    case TILEP_MONS_KRAKEN_TENTACLE_SEGMENT_NE_SW:</a>
<a name="ln1628">        _add_tentacle_overlay(pos, main_dir::east, type);</a>
<a name="ln1629">        _add_tentacle_overlay(pos, main_dir::west, type);</a>
<a name="ln1630">        break;</a>
<a name="ln1631">    // other</a>
<a name="ln1632">    case TILEP_MONS_KRAKEN_TENTACLE_SEGMENT_NE_NW:</a>
<a name="ln1633">        _add_tentacle_overlay(pos, main_dir::north, type);</a>
<a name="ln1634">        _add_tentacle_overlay(pos, main_dir::east, type);</a>
<a name="ln1635">        break;</a>
<a name="ln1636">    case TILEP_MONS_KRAKEN_TENTACLE_SEGMENT_NE_SE:</a>
<a name="ln1637">        _add_tentacle_overlay(pos, main_dir::east, type);</a>
<a name="ln1638">        _add_tentacle_overlay(pos, main_dir::south, type);</a>
<a name="ln1639">        break;</a>
<a name="ln1640">    case TILEP_MONS_KRAKEN_TENTACLE_SEGMENT_SE_SW:</a>
<a name="ln1641">        _add_tentacle_overlay(pos, main_dir::south, type);</a>
<a name="ln1642">        _add_tentacle_overlay(pos, main_dir::west, type);</a>
<a name="ln1643">        break;</a>
<a name="ln1644">    case TILEP_MONS_KRAKEN_TENTACLE_SEGMENT_NW_SW:</a>
<a name="ln1645">        _add_tentacle_overlay(pos, main_dir::north, type);</a>
<a name="ln1646">        _add_tentacle_overlay(pos, main_dir::west, type);</a>
<a name="ln1647">        break;</a>
<a name="ln1648">    }</a>
<a name="ln1649">}</a>
<a name="ln1650"> </a>
<a name="ln1651">static tentacle_type _get_tentacle_type(const monster_info&amp; mon)</a>
<a name="ln1652">{</a>
<a name="ln1653">    switch (mon.type)</a>
<a name="ln1654">    {</a>
<a name="ln1655">        case MONS_KRAKEN_TENTACLE:</a>
<a name="ln1656">        case MONS_KRAKEN_TENTACLE_SEGMENT:</a>
<a name="ln1657">            switch (mon.base_type)</a>
<a name="ln1658">            {</a>
<a name="ln1659">                case MONS_ZOMBIE:</a>
<a name="ln1660">                    return tentacle_type::zombie_kraken;</a>
<a name="ln1661">                case MONS_SIMULACRUM:</a>
<a name="ln1662">                    return tentacle_type::simulacrum_kraken;</a>
<a name="ln1663">                case MONS_SPECTRAL_THING:</a>
<a name="ln1664">                    return tentacle_type::spectral_kraken;</a>
<a name="ln1665">                default:</a>
<a name="ln1666">                    return tentacle_type::kraken;</a>
<a name="ln1667">            }</a>
<a name="ln1668">        case MONS_ELDRITCH_TENTACLE:</a>
<a name="ln1669">        case MONS_ELDRITCH_TENTACLE_SEGMENT:</a>
<a name="ln1670">            return tentacle_type::eldritch;</a>
<a name="ln1671">        case MONS_STARSPAWN_TENTACLE:</a>
<a name="ln1672">        case MONS_STARSPAWN_TENTACLE_SEGMENT:</a>
<a name="ln1673">            return tentacle_type::starspawn;</a>
<a name="ln1674">        case MONS_SNAPLASHER_VINE:</a>
<a name="ln1675">        case MONS_SNAPLASHER_VINE_SEGMENT:</a>
<a name="ln1676">            return tentacle_type::vine;</a>
<a name="ln1677"> </a>
<a name="ln1678">        default:</a>
<a name="ln1679">            die(&quot;Invalid tentacle type!&quot;);</a>
<a name="ln1680">            return tentacle_type::kraken; // Silence a warning</a>
<a name="ln1681">    }</a>
<a name="ln1682">}</a>
<a name="ln1683"> </a>
<a name="ln1684">static bool _tentacle_tile_not_flying(tileidx_t tile)</a>
<a name="ln1685">{</a>
<a name="ln1686">    // All tiles between these two enums feature tentacles</a>
<a name="ln1687">    // emerging from water.</a>
<a name="ln1688">    return tile &gt;= TILEP_FIRST_TENTACLE_IN_WATER</a>
<a name="ln1689">           &amp;&amp; tile &lt;= TILEP_LAST_TENTACLE_IN_WATER</a>
<a name="ln1690">        || tile &gt;= TILEP_FIRST_ZOMBIE_TENTACLE_IN_WATER</a>
<a name="ln1691">           &amp;&amp; tile &lt;= TILEP_LAST_ZOMBIE_TENTACLE_IN_WATER</a>
<a name="ln1692">        || tile &gt;= TILEP_FIRST_SIMULACRUM_TENTACLE_IN_WATER</a>
<a name="ln1693">           &amp;&amp; tile &lt;= TILEP_LAST_SIMULACRUM_TENTACLE_IN_WATER</a>
<a name="ln1694">        || tile &gt;= TILEP_FIRST_SPECTRAL_TENTACLE_IN_WATER</a>
<a name="ln1695">           &amp;&amp; tile &lt;= TILEP_LAST_SPECTRAL_TENTACLE_IN_WATER;</a>
<a name="ln1696">}</a>
<a name="ln1697"> </a>
<a name="ln1698">static tileidx_t _tileidx_monster_no_props(const monster_info&amp; mon)</a>
<a name="ln1699">{</a>
<a name="ln1700">    const bool in_water = feat_is_water(env.map_knowledge(mon.pos).feat());</a>
<a name="ln1701"> </a>
<a name="ln1702">    // Show only base class for detected monsters.</a>
<a name="ln1703">    if (mons_class_is_zombified(mon.type))</a>
<a name="ln1704">        return _tileidx_monster_zombified(mon);</a>
<a name="ln1705"> </a>
<a name="ln1706">    if (mon.props.exists(&quot;monster_tile&quot;))</a>
<a name="ln1707">    {</a>
<a name="ln1708">        tileidx_t t = mon.props[&quot;monster_tile&quot;].get_short();</a>
<a name="ln1709">        if (t == TILEP_MONS_HELL_WIZARD)</a>
<a name="ln1710">            return _mon_sinus(t);</a>
<a name="ln1711">        return t;</a>
<a name="ln1712">    }</a>
<a name="ln1713"> </a>
<a name="ln1714">    int tile_num = 0;</a>
<a name="ln1715">    if (mon.props.exists(TILE_NUM_KEY))</a>
<a name="ln1716">        tile_num = mon.props[TILE_NUM_KEY].get_short();</a>
<a name="ln1717"> </a>
<a name="ln1718">    bool vary = !(mon.props.exists(&quot;fake&quot;) &amp;&amp; mon.props[&quot;fake&quot;].get_bool());</a>
<a name="ln1719">    const tileidx_t base = tileidx_monster_base(mon.type,</a>
<a name="ln1720">                                                mon.pos.y*GXM + mon.pos.x,</a>
<a name="ln1721">                                                in_water, mon.colour(true),</a>
<a name="ln1722">                                                mon.number, tile_num, vary);</a>
<a name="ln1723"> </a>
<a name="ln1724">    switch (mon.type)</a>
<a name="ln1725">    {</a>
<a name="ln1726">        // use a different tile not using a standard ranged weapon.</a>
<a name="ln1727">        case MONS_CENTAUR:</a>
<a name="ln1728">        case MONS_CENTAUR_WARRIOR:</a>
<a name="ln1729">        case MONS_YAKTAUR:</a>
<a name="ln1730">        case MONS_YAKTAUR_CAPTAIN:</a>
<a name="ln1731">            return base + (_bow_offset(mon) ? 1 : 0);</a>
<a name="ln1732"> </a>
<a name="ln1733">        case MONS_CEREBOV:</a>
<a name="ln1734">            return base + (mon.inv[MSLOT_WEAPON] ? 0 : 1);</a>
<a name="ln1735"> </a>
<a name="ln1736">        case MONS_SLAVE:</a>
<a name="ln1737">            return base + (mon.mname == &quot;freed slave&quot; ? 1 : 0);</a>
<a name="ln1738"> </a>
<a name="ln1739">        case MONS_BALLISTOMYCETE:</a>
<a name="ln1740">            return base + (mon.is_active ? 1 : 0);</a>
<a name="ln1741"> </a>
<a name="ln1742">        case MONS_DUVESSA:</a>
<a name="ln1743">        case MONS_DOWAN:</a>
<a name="ln1744">            return mon.props.exists(ELVEN_IS_ENERGIZED_KEY) ? base + 1 : base;</a>
<a name="ln1745"> </a>
<a name="ln1746">        case MONS_ARACHNE:</a>
<a name="ln1747">        {</a>
<a name="ln1748">            // Arachne normally is drawn with her staff wielded two-handed,</a>
<a name="ln1749">            // but will use a regular stance if she picks up a shield</a>
<a name="ln1750">            // (enhancer staves are compatible with those).</a>
<a name="ln1751">            const item_def* weapon = mon.inv[MSLOT_WEAPON].get();</a>
<a name="ln1752">            if (!mon.inv[MSLOT_SHIELD] &amp;&amp; weapon</a>
<a name="ln1753">                &amp;&amp; (weapon-&gt;is_type(OBJ_STAVES, STAFF_POISON)</a>
<a name="ln1754">                    || is_unrandom_artefact(*weapon, UNRAND_OLGREB)))</a>
<a name="ln1755">            {</a>
<a name="ln1756">                return base;</a>
<a name="ln1757">            }</a>
<a name="ln1758">            else</a>
<a name="ln1759">                return base + 1;</a>
<a name="ln1760">        }</a>
<a name="ln1761"> </a>
<a name="ln1762">        case MONS_AGNES:</a>
<a name="ln1763">        {</a>
<a name="ln1764">            // For if Agnes loses her lajatang</a>
<a name="ln1765">            const item_def * const weapon = mon.inv[MSLOT_WEAPON].get();</a>
<a name="ln1766">            if (weapon &amp;&amp; weapon-&gt;is_type(OBJ_WEAPONS, WPN_LAJATANG))</a>
<a name="ln1767">                return TILEP_MONS_AGNES;</a>
<a name="ln1768">            else</a>
<a name="ln1769">                return TILEP_MONS_AGNES_STAVELESS;</a>
<a name="ln1770">        }</a>
<a name="ln1771"> </a>
<a name="ln1772">        case MONS_ERICA:</a>
<a name="ln1773">        {</a>
<a name="ln1774">            // For if Erica loses her flaming scimitar</a>
<a name="ln1775">            const item_def * const weapon = mon.inv[MSLOT_WEAPON].get();</a>
<a name="ln1776">            if (weapon</a>
<a name="ln1777">                &amp;&amp; weapon-&gt;is_type(OBJ_WEAPONS, WPN_SCIMITAR)</a>
<a name="ln1778">                &amp;&amp; weapon-&gt;brand == SPWPN_FLAMING)</a>
<a name="ln1779">            {</a>
<a name="ln1780">                return TILEP_MONS_ERICA;</a>
<a name="ln1781">            }</a>
<a name="ln1782">            else</a>
<a name="ln1783">                return TILEP_MONS_ERICA_SWORDLESS;</a>
<a name="ln1784">        }</a>
<a name="ln1785"> </a>
<a name="ln1786">        case MONS_BUSH:</a>
<a name="ln1787">            if (env.map_knowledge(mon.pos).cloud() == CLOUD_FIRE)</a>
<a name="ln1788">                return TILEP_MONS_BUSH_BURNING;</a>
<a name="ln1789">            return base;</a>
<a name="ln1790"> </a>
<a name="ln1791">        case MONS_DANCING_WEAPON:</a>
<a name="ln1792">        {</a>
<a name="ln1793">            // Use item tile.</a>
<a name="ln1794">            const item_def&amp; item = *mon.inv[MSLOT_WEAPON];</a>
<a name="ln1795">            return tileidx_item(item) | TILE_FLAG_ANIM_WEP;</a>
<a name="ln1796">        }</a>
<a name="ln1797"> </a>
<a name="ln1798">        case MONS_SPECTRAL_WEAPON:</a>
<a name="ln1799">        {</a>
<a name="ln1800">            if (!mon.inv[MSLOT_WEAPON])</a>
<a name="ln1801">                return TILEP_MONS_SPECTRAL_SBL;</a>
<a name="ln1802"> </a>
<a name="ln1803">            // Tiles exist for each class of weapon.</a>
<a name="ln1804">            const item_def&amp; item = *mon.inv[MSLOT_WEAPON];</a>
<a name="ln1805">            switch (item_attack_skill(item))</a>
<a name="ln1806">            {</a>
<a name="ln1807">            case SK_LONG_BLADES:</a>
<a name="ln1808">                return TILEP_MONS_SPECTRAL_LBL;</a>
<a name="ln1809">            case SK_AXES:</a>
<a name="ln1810">                return TILEP_MONS_SPECTRAL_AXE;</a>
<a name="ln1811">            case SK_POLEARMS:</a>
<a name="ln1812">                return TILEP_MONS_SPECTRAL_SPEAR;</a>
<a name="ln1813">            case SK_STAVES:</a>
<a name="ln1814">                return TILEP_MONS_SPECTRAL_STAFF;</a>
<a name="ln1815">            case SK_MACES_FLAILS:</a>
<a name="ln1816">                {</a>
<a name="ln1817">                    const weapon_type wt = (weapon_type)item.sub_type;</a>
<a name="ln1818">                    return (wt == WPN_WHIP || wt == WPN_FLAIL</a>
<a name="ln1819">                            || wt == WPN_DIRE_FLAIL || wt == WPN_DEMON_WHIP</a>
<a name="ln1820">                            || wt == WPN_SACRED_SCOURGE) ?</a>
<a name="ln1821">                        TILEP_MONS_SPECTRAL_WHIP : TILEP_MONS_SPECTRAL_MACE;</a>
<a name="ln1822">                }</a>
<a name="ln1823">            default:</a>
<a name="ln1824">                return TILEP_MONS_SPECTRAL_SBL;</a>
<a name="ln1825">            }</a>
<a name="ln1826">        }</a>
<a name="ln1827"> </a>
<a name="ln1828">        case MONS_KRAKEN_TENTACLE:</a>
<a name="ln1829">        case MONS_KRAKEN_TENTACLE_SEGMENT:</a>
<a name="ln1830">        case MONS_ELDRITCH_TENTACLE:</a>
<a name="ln1831">        case MONS_ELDRITCH_TENTACLE_SEGMENT:</a>
<a name="ln1832">        case MONS_STARSPAWN_TENTACLE:</a>
<a name="ln1833">        case MONS_STARSPAWN_TENTACLE_SEGMENT:</a>
<a name="ln1834">        case MONS_SNAPLASHER_VINE:</a>
<a name="ln1835">        case MONS_SNAPLASHER_VINE_SEGMENT:</a>
<a name="ln1836">        {</a>
<a name="ln1837">            tileidx_t tile = tileidx_tentacle(mon);</a>
<a name="ln1838">            _handle_tentacle_overlay(mon.pos, tile, _get_tentacle_type(mon));</a>
<a name="ln1839"> </a>
<a name="ln1840">            if (!_mons_is_kraken_tentacle(mon.type)</a>
<a name="ln1841">                &amp;&amp; tile &gt;= TILEP_MONS_KRAKEN_TENTACLE_SEGMENT_N</a>
<a name="ln1842">                &amp;&amp; (tile &lt;= TILEP_MONS_KRAKEN_TENTACLE_SEGMENT_W_SE</a>
<a name="ln1843">                    || tile &lt;= TILEP_MONS_KRAKEN_TENTACLE_SEGMENT_W_NW &amp;&amp;</a>
<a name="ln1844">                       mon.type == MONS_SNAPLASHER_VINE_SEGMENT))</a>
<a name="ln1845">            {</a>
<a name="ln1846">                tile += TILEP_MONS_ELDRITCH_TENTACLE_PORTAL_N;</a>
<a name="ln1847">                tile -= TILEP_MONS_KRAKEN_TENTACLE_SEGMENT_N;</a>
<a name="ln1848"> </a>
<a name="ln1849">                if (mon.type == MONS_STARSPAWN_TENTACLE</a>
<a name="ln1850">                    || mon.type == MONS_STARSPAWN_TENTACLE_SEGMENT)</a>
<a name="ln1851">                {</a>
<a name="ln1852">                    tile += TILEP_MONS_STARSPAWN_TENTACLE_N;</a>
<a name="ln1853">                    tile -= TILEP_MONS_ELDRITCH_TENTACLE_N;</a>
<a name="ln1854">                }</a>
<a name="ln1855">                else if (mon.type == MONS_SNAPLASHER_VINE</a>
<a name="ln1856">                         || mon.type == MONS_SNAPLASHER_VINE_SEGMENT)</a>
<a name="ln1857">                {</a>
<a name="ln1858">                    tile += TILEP_MONS_VINE_N;</a>
<a name="ln1859">                    tile -= TILEP_MONS_ELDRITCH_TENTACLE_N;</a>
<a name="ln1860">                }</a>
<a name="ln1861">            }</a>
<a name="ln1862"> </a>
<a name="ln1863">            if (_mons_is_kraken_tentacle(mon.type) &amp;&amp; mon.base_type == MONS_ZOMBIE)</a>
<a name="ln1864">            {</a>
<a name="ln1865">                tile += TILEP_MONS_KRAKEN_ZOMBIE_TENTACLE_SEGMENT_N;</a>
<a name="ln1866">                tile -= TILEP_MONS_KRAKEN_TENTACLE_SEGMENT_N;</a>
<a name="ln1867">            }</a>
<a name="ln1868">            if (_mons_is_kraken_tentacle(mon.type) &amp;&amp; mon.base_type == MONS_SIMULACRUM)</a>
<a name="ln1869">            {</a>
<a name="ln1870">                tile += TILEP_MONS_KRAKEN_SIMULACRUM_TENTACLE_SEGMENT_N;</a>
<a name="ln1871">                tile -= TILEP_MONS_KRAKEN_TENTACLE_SEGMENT_N;</a>
<a name="ln1872">            }</a>
<a name="ln1873">            if (_mons_is_kraken_tentacle(mon.type) &amp;&amp; mon.base_type == MONS_SPECTRAL_THING)</a>
<a name="ln1874">            {</a>
<a name="ln1875">                tile += TILEP_MONS_KRAKEN_SPECTRAL_TENTACLE_SEGMENT_N;</a>
<a name="ln1876">                tile -= TILEP_MONS_KRAKEN_TENTACLE_SEGMENT_N;</a>
<a name="ln1877">            }</a>
<a name="ln1878"> </a>
<a name="ln1879">            return tile;</a>
<a name="ln1880">        }</a>
<a name="ln1881"> </a>
<a name="ln1882">        case MONS_SENSED:</a>
<a name="ln1883">        {</a>
<a name="ln1884">            // Should be always out of LOS, though...</a>
<a name="ln1885">            if (base == TILEP_MONS_PROGRAM_BUG)</a>
<a name="ln1886">                return TILE_UNSEEN_MONSTER;</a>
<a name="ln1887">            return base;</a>
<a name="ln1888">        }</a>
<a name="ln1889"> </a>
<a name="ln1890">        default:</a>
<a name="ln1891">            return base;</a>
<a name="ln1892">    }</a>
<a name="ln1893">}</a>
<a name="ln1894"> </a>
<a name="ln1895">tileidx_t tileidx_monster(const monster_info&amp; mons)</a>
<a name="ln1896">{</a>
<a name="ln1897">    tileidx_t ch = _tileidx_monster_no_props(mons);</a>
<a name="ln1898"> </a>
<a name="ln1899">    if ((!mons.ground_level() &amp;&amp; !_tentacle_tile_not_flying(ch)))</a>
<a name="ln1900">        ch |= TILE_FLAG_FLYING;</a>
<a name="ln1901">    if (mons.is(MB_CAUGHT))</a>
<a name="ln1902">        ch |= TILE_FLAG_NET;</a>
<a name="ln1903">    if (mons.is(MB_WEBBED))</a>
<a name="ln1904">        ch |= TILE_FLAG_WEB;</a>
<a name="ln1905">    if (mons.is(MB_POISONED))</a>
<a name="ln1906">        ch |= TILE_FLAG_POISON;</a>
<a name="ln1907">    else if (mons.is(MB_MORE_POISONED))</a>
<a name="ln1908">        ch |= TILE_FLAG_MORE_POISON;</a>
<a name="ln1909">    else if (mons.is(MB_MAX_POISONED))</a>
<a name="ln1910">        ch |= TILE_FLAG_MAX_POISON;</a>
<a name="ln1911">    if (mons.is(MB_BURNING))</a>
<a name="ln1912">        ch |= TILE_FLAG_STICKY_FLAME;</a>
<a name="ln1913">    if (mons.is(MB_INNER_FLAME))</a>
<a name="ln1914">        ch |= TILE_FLAG_INNER_FLAME;</a>
<a name="ln1915">    if (!mons.constrictor_name.empty())</a>
<a name="ln1916">        ch |= TILE_FLAG_CONSTRICTED;</a>
<a name="ln1917">    if (mons.is(MB_BERSERK))</a>
<a name="ln1918">        ch |= TILE_FLAG_BERSERK;</a>
<a name="ln1919">    if (mons.is(MB_GLOWING))</a>
<a name="ln1920">        ch |= TILE_FLAG_GLOWING;</a>
<a name="ln1921">    if (mons.is(MB_SLOWED))</a>
<a name="ln1922">        ch |= TILE_FLAG_SLOWED;</a>
<a name="ln1923">    if (mons.is(MB_MIRROR_DAMAGE))</a>
<a name="ln1924">        ch |= TILE_FLAG_PAIN_MIRROR;</a>
<a name="ln1925">    if (mons.is(MB_HASTED))</a>
<a name="ln1926">        ch |= TILE_FLAG_HASTED;</a>
<a name="ln1927">    if (mons.is(MB_STRONG))</a>
<a name="ln1928">        ch |= TILE_FLAG_MIGHT;</a>
<a name="ln1929">    if (mons.is(MB_PETRIFYING))</a>
<a name="ln1930">        ch |= TILE_FLAG_PETRIFYING;</a>
<a name="ln1931">    if (mons.is(MB_PETRIFIED))</a>
<a name="ln1932">        ch |= TILE_FLAG_PETRIFIED;</a>
<a name="ln1933">    if (mons.is(MB_BLIND))</a>
<a name="ln1934">        ch |= TILE_FLAG_BLIND;</a>
<a name="ln1935">    if (mons.is(MB_SUMMONED))</a>
<a name="ln1936">        ch |= TILE_FLAG_SUMMONED;</a>
<a name="ln1937">    if (mons.is(MB_PERM_SUMMON))</a>
<a name="ln1938">        ch |= TILE_FLAG_PERM_SUMMON;</a>
<a name="ln1939">    if (mons.is(MB_WORD_OF_RECALL))</a>
<a name="ln1940">        ch |= TILE_FLAG_RECALL;</a>
<a name="ln1941">    if (mons.is(MB_LIGHTLY_DRAINED) || mons.is(MB_HEAVILY_DRAINED))</a>
<a name="ln1942">        ch |= TILE_FLAG_DRAIN;</a>
<a name="ln1943">    if (mons.is(MB_IDEALISED))</a>
<a name="ln1944">        ch |= TILE_FLAG_IDEALISED;</a>
<a name="ln1945">    if (mons.is(MB_BOUND_SOUL))</a>
<a name="ln1946">        ch |= TILE_FLAG_BOUND_SOUL;</a>
<a name="ln1947">    if (mons.is(MB_INFESTATION))</a>
<a name="ln1948">        ch |= TILE_FLAG_INFESTED;</a>
<a name="ln1949">    if (mons.is(MB_CORROSION))</a>
<a name="ln1950">        ch |= TILE_FLAG_CORRODED;</a>
<a name="ln1951">    if (mons.is(MB_SWIFT))</a>
<a name="ln1952">        ch |= TILE_FLAG_SWIFT;</a>
<a name="ln1953">    if (mons.is(MB_VILE_CLUTCH))</a>
<a name="ln1954">        ch |= TILE_FLAG_VILE_CLUTCH;</a>
<a name="ln1955">    if (mons.is(MB_POSSESSABLE))</a>
<a name="ln1956">        ch |= TILE_FLAG_POSSESSABLE;</a>
<a name="ln1957"> </a>
<a name="ln1958">    if (mons.attitude == ATT_FRIENDLY)</a>
<a name="ln1959">        ch |= TILE_FLAG_PET;</a>
<a name="ln1960">    else if (mons.attitude == ATT_GOOD_NEUTRAL)</a>
<a name="ln1961">        ch |= TILE_FLAG_GD_NEUTRAL;</a>
<a name="ln1962">    else if (mons.neutral())</a>
<a name="ln1963">        ch |= TILE_FLAG_NEUTRAL;</a>
<a name="ln1964">    else</a>
<a name="ln1965">        switch (mons.threat)</a>
<a name="ln1966">        {</a>
<a name="ln1967">        case MTHRT_TRIVIAL:</a>
<a name="ln1968">            if (Options.tile_show_threat_levels.find(&quot;trivial&quot;) != string::npos)</a>
<a name="ln1969">                ch |= TILE_FLAG_TRIVIAL;</a>
<a name="ln1970">            break;</a>
<a name="ln1971">        case MTHRT_EASY:</a>
<a name="ln1972">            if (Options.tile_show_threat_levels.find(&quot;easy&quot;) != string::npos)</a>
<a name="ln1973">                ch |= TILE_FLAG_EASY;</a>
<a name="ln1974">            break;</a>
<a name="ln1975">        case MTHRT_TOUGH:</a>
<a name="ln1976">            if (Options.tile_show_threat_levels.find(&quot;tough&quot;) != string::npos)</a>
<a name="ln1977">                ch |= TILE_FLAG_TOUGH;</a>
<a name="ln1978">            break;</a>
<a name="ln1979">        case MTHRT_NASTY:</a>
<a name="ln1980">            if (Options.tile_show_threat_levels.find(&quot;nasty&quot;) != string::npos)</a>
<a name="ln1981">                ch |= TILE_FLAG_NASTY;</a>
<a name="ln1982">            break;</a>
<a name="ln1983">        default:</a>
<a name="ln1984">            break;</a>
<a name="ln1985">        }</a>
<a name="ln1986"> </a>
<a name="ln1987">    if (mons.is(MB_FLEEING))</a>
<a name="ln1988">        ch |= TILE_FLAG_FLEEING;</a>
<a name="ln1989">    else if (mons.is(MB_STABBABLE) || mons.is(MB_SLEEPING)</a>
<a name="ln1990">             || mons.is(MB_DORMANT))</a>
<a name="ln1991">    {</a>
<a name="ln1992">        // XXX: should we have different tile flags for &quot;stabbable&quot; versus</a>
<a name="ln1993">        // &quot;sleeping&quot;?</a>
<a name="ln1994">        ch |= TILE_FLAG_STAB;</a>
<a name="ln1995">    }</a>
<a name="ln1996">    // Should petrify show the '?' symbol?</a>
<a name="ln1997">    else if (mons.is(MB_DISTRACTED) &amp;&amp; !mons.is(MB_PETRIFYING))</a>
<a name="ln1998">        ch |= TILE_FLAG_MAY_STAB;</a>
<a name="ln1999"> </a>
<a name="ln2000">    mon_dam_level_type damage_level = mons.dam;</a>
<a name="ln2001"> </a>
<a name="ln2002">    switch (damage_level)</a>
<a name="ln2003">    {</a>
<a name="ln2004">    case MDAM_DEAD:</a>
<a name="ln2005">    case MDAM_ALMOST_DEAD:</a>
<a name="ln2006">        ch |= TILE_FLAG_MDAM_ADEAD;</a>
<a name="ln2007">        break;</a>
<a name="ln2008">    case MDAM_SEVERELY_DAMAGED:</a>
<a name="ln2009">        ch |= TILE_FLAG_MDAM_SEV;</a>
<a name="ln2010">        break;</a>
<a name="ln2011">    case MDAM_HEAVILY_DAMAGED:</a>
<a name="ln2012">        ch |= TILE_FLAG_MDAM_HEAVY;</a>
<a name="ln2013">        break;</a>
<a name="ln2014">    case MDAM_MODERATELY_DAMAGED:</a>
<a name="ln2015">        ch |= TILE_FLAG_MDAM_MOD;</a>
<a name="ln2016">        break;</a>
<a name="ln2017">    case MDAM_LIGHTLY_DAMAGED:</a>
<a name="ln2018">        ch |= TILE_FLAG_MDAM_LIGHT;</a>
<a name="ln2019">        break;</a>
<a name="ln2020">    case MDAM_OKAY:</a>
<a name="ln2021">    default:</a>
<a name="ln2022">        // no flag for okay.</a>
<a name="ln2023">        break;</a>
<a name="ln2024">    }</a>
<a name="ln2025"> </a>
<a name="ln2026">#ifdef USE_TILE_LOCAL</a>
<a name="ln2027">    // handled on client side in WebTiles</a>
<a name="ln2028">    if (Options.tile_show_demon_tier)</a>
<a name="ln2029">    {</a>
<a name="ln2030">#endif</a>
<a name="ln2031">        // FIXME: non-linear bits suck, should be a simple addition</a>
<a name="ln2032">        switch (mons_demon_tier(mons.type))</a>
<a name="ln2033">        {</a>
<a name="ln2034">        case 1:</a>
<a name="ln2035">            ch |= TILE_FLAG_DEMON_1;</a>
<a name="ln2036">            break;</a>
<a name="ln2037">        case 2:</a>
<a name="ln2038">            ch |= TILE_FLAG_DEMON_2;</a>
<a name="ln2039">            break;</a>
<a name="ln2040">        case 3:</a>
<a name="ln2041">            ch |= TILE_FLAG_DEMON_3;</a>
<a name="ln2042">            break;</a>
<a name="ln2043">        case 4:</a>
<a name="ln2044">            ch |= TILE_FLAG_DEMON_4;</a>
<a name="ln2045">            break;</a>
<a name="ln2046">        case 5:</a>
<a name="ln2047">            ch |= TILE_FLAG_DEMON_5;</a>
<a name="ln2048">            break;</a>
<a name="ln2049">        }</a>
<a name="ln2050">#ifdef USE_TILE_LOCAL</a>
<a name="ln2051">    }</a>
<a name="ln2052">#endif</a>
<a name="ln2053"> </a>
<a name="ln2054">    return ch;</a>
<a name="ln2055">}</a>
<a name="ln2056"> </a>
<a name="ln2057">static tileidx_t tileidx_draco_base(monster_type draco)</a>
<a name="ln2058">{</a>
<a name="ln2059">    return TILEP_DRACO_BASE + (draco - MONS_DRACONIAN);</a>
<a name="ln2060">}</a>
<a name="ln2061"> </a>
<a name="ln2062">tileidx_t tileidx_draco_base(const monster_info&amp; mon)</a>
<a name="ln2063">{</a>
<a name="ln2064">    return tileidx_draco_base(mon.draco_or_demonspawn_subspecies());</a>
<a name="ln2065">}</a>
<a name="ln2066"> </a>
<a name="ln2067">tileidx_t tileidx_draco_job(const monster_info&amp; mon)</a>
<a name="ln2068">{</a>
<a name="ln2069">    if (mons_is_draconian_job(mon.type))</a>
<a name="ln2070">        return get_mon_base_tile(mon.type);</a>
<a name="ln2071">    return 0;</a>
<a name="ln2072">}</a>
<a name="ln2073"> </a>
<a name="ln2074">tileidx_t tileidx_demonspawn_base(const monster_info&amp; mon)</a>
<a name="ln2075">{</a>
<a name="ln2076">    return get_mon_base_tile(mon.draco_or_demonspawn_subspecies());</a>
<a name="ln2077">}</a>
<a name="ln2078"> </a>
<a name="ln2079">tileidx_t tileidx_demonspawn_job(const monster_info&amp; mon)</a>
<a name="ln2080">{</a>
<a name="ln2081">    if (mons_is_demonspawn_job(mon.type))</a>
<a name="ln2082">        return get_mon_base_tile(mon.type);</a>
<a name="ln2083">    return 0;</a>
<a name="ln2084">}</a>
<a name="ln2085"> </a>
<a name="ln2086">/**</a>
<a name="ln2087"> * Return the monster tile used for the player based on a monster type.</a>
<a name="ln2088"> *</a>
<a name="ln2089"> * When using the player species monster or a monster in general instead of an</a>
<a name="ln2090"> * explicit tile name, this function cleans up the tiles for certain monsters</a>
<a name="ln2091"> * where there's an alternate tile that's better than the base one for doll</a>
<a name="ln2092"> * purposes.</a>
<a name="ln2093"> * @returns The tile id of the tile that will be used.</a>
<a name="ln2094">*/</a>
<a name="ln2095">tileidx_t tileidx_player_mons()</a>
<a name="ln2096">{</a>
<a name="ln2097">    ASSERT(Options.tile_use_monster != MONS_0);</a>
<a name="ln2098"> </a>
<a name="ln2099">    monster_type mons;</a>
<a name="ln2100">    if (Options.tile_player_tile)</a>
<a name="ln2101">        return Options.tile_player_tile;</a>
<a name="ln2102"> </a>
<a name="ln2103">    if (Options.tile_use_monster == MONS_PLAYER)</a>
<a name="ln2104">        mons = player_mons(false);</a>
<a name="ln2105">    else</a>
<a name="ln2106">        mons = Options.tile_use_monster;</a>
<a name="ln2107"> </a>
<a name="ln2108">    if (mons_is_base_draconian(mons))</a>
<a name="ln2109">        return tileidx_draco_base(mons);</a>
<a name="ln2110"> </a>
<a name="ln2111">    switch (mons)</a>
<a name="ln2112">    {</a>
<a name="ln2113">    case MONS_CENTAUR:         return TILEP_MONS_CENTAUR_MELEE;</a>
<a name="ln2114">    case MONS_CENTAUR_WARRIOR: return TILEP_MONS_CENTAUR_WARRIOR_MELEE;</a>
<a name="ln2115">    case MONS_YAKTAUR:         return TILEP_MONS_YAKTAUR_MELEE;</a>
<a name="ln2116">    case MONS_YAKTAUR_CAPTAIN: return TILEP_MONS_YAKTAUR_CAPTAIN_MELEE;</a>
<a name="ln2117">    default:                   return tileidx_monster_base(mons, 0);</a>
<a name="ln2118">    }</a>
<a name="ln2119">}</a>
<a name="ln2120"> </a>
<a name="ln2121">static tileidx_t _tileidx_unrand_artefact(int idx)</a>
<a name="ln2122">{</a>
<a name="ln2123">    const tileidx_t tile = unrandart_to_tile(idx);</a>
<a name="ln2124">    return tile ? tile : tileidx_t{TILE_TODO};</a>
<a name="ln2125">}</a>
<a name="ln2126"> </a>
<a name="ln2127">static tileidx_t _tileidx_wyrmbane(int plus)</a>
<a name="ln2128">{</a>
<a name="ln2129">    if (plus &lt; 10)</a>
<a name="ln2130">        return TILE_UNRAND_WYRMBANE;</a>
<a name="ln2131">    else if (plus &lt; 12)</a>
<a name="ln2132">        return TILE_UNRAND_WYRMBANE1;</a>
<a name="ln2133">    else if (plus &lt; 15)</a>
<a name="ln2134">        return TILE_UNRAND_WYRMBANE2;</a>
<a name="ln2135">    else if (plus &lt; 18)</a>
<a name="ln2136">        return TILE_UNRAND_WYRMBANE3;</a>
<a name="ln2137">    else</a>
<a name="ln2138">        return TILE_UNRAND_WYRMBANE4;</a>
<a name="ln2139">}</a>
<a name="ln2140"> </a>
<a name="ln2141">static tileidx_t _tileidx_weapon_base(const item_def &amp;item)</a>
<a name="ln2142">{</a>
<a name="ln2143">    switch (item.sub_type)</a>
<a name="ln2144">    {</a>
<a name="ln2145">    case WPN_DAGGER:                return TILE_WPN_DAGGER;</a>
<a name="ln2146">    case WPN_SHORT_SWORD:           return TILE_WPN_SHORT_SWORD;</a>
<a name="ln2147">    case WPN_QUICK_BLADE:           return TILE_WPN_QUICK_BLADE;</a>
<a name="ln2148">    case WPN_RAPIER:                return TILE_WPN_RAPIER;</a>
<a name="ln2149">    case WPN_FALCHION:              return TILE_WPN_FALCHION;</a>
<a name="ln2150">    case WPN_LONG_SWORD:            return TILE_WPN_LONG_SWORD;</a>
<a name="ln2151">    case WPN_GREAT_SWORD:           return TILE_WPN_GREAT_SWORD;</a>
<a name="ln2152">    case WPN_SCIMITAR:              return TILE_WPN_SCIMITAR;</a>
<a name="ln2153">    case WPN_DOUBLE_SWORD:          return TILE_WPN_DOUBLE_SWORD;</a>
<a name="ln2154">    case WPN_TRIPLE_SWORD:          return TILE_WPN_TRIPLE_SWORD;</a>
<a name="ln2155">    case WPN_HAND_AXE:              return TILE_WPN_HAND_AXE;</a>
<a name="ln2156">    case WPN_WAR_AXE:               return TILE_WPN_WAR_AXE;</a>
<a name="ln2157">    case WPN_BROAD_AXE:             return TILE_WPN_BROAD_AXE;</a>
<a name="ln2158">    case WPN_BATTLEAXE:             return TILE_WPN_BATTLEAXE;</a>
<a name="ln2159">    case WPN_EXECUTIONERS_AXE:      return TILE_WPN_EXECUTIONERS_AXE;</a>
<a name="ln2160">#if TAG_MAJOR_VERSION == 34</a>
<a name="ln2161">    case WPN_BLOWGUN:               return TILE_WPN_BLOWGUN;</a>
<a name="ln2162">#endif</a>
<a name="ln2163">    case WPN_HUNTING_SLING:         return TILE_WPN_HUNTING_SLING;</a>
<a name="ln2164">    case WPN_FUSTIBALUS:            return TILE_WPN_FUSTIBALUS;</a>
<a name="ln2165">    case WPN_SHORTBOW:              return TILE_WPN_SHORTBOW;</a>
<a name="ln2166">    case WPN_HAND_CROSSBOW:         return TILE_WPN_HAND_CROSSBOW;</a>
<a name="ln2167">    case WPN_ARBALEST:              return TILE_WPN_ARBALEST;</a>
<a name="ln2168">    case WPN_TRIPLE_CROSSBOW:       return TILE_WPN_TRIPLE_CROSSBOW;</a>
<a name="ln2169">    case WPN_SPEAR:                 return TILE_WPN_SPEAR;</a>
<a name="ln2170">    case WPN_TRIDENT:               return TILE_WPN_TRIDENT;</a>
<a name="ln2171">    case WPN_HALBERD:               return TILE_WPN_HALBERD;</a>
<a name="ln2172">    case WPN_SCYTHE:                return TILE_WPN_SCYTHE;</a>
<a name="ln2173">    case WPN_GLAIVE:                return TILE_WPN_GLAIVE;</a>
<a name="ln2174">#if TAG_MAJOR_VERSION == 34</a>
<a name="ln2175">    case WPN_STAFF:                 return TILE_WPN_STAFF;</a>
<a name="ln2176">#endif</a>
<a name="ln2177">    case WPN_QUARTERSTAFF:          return TILE_WPN_QUARTERSTAFF;</a>
<a name="ln2178">    case WPN_CLUB:                  return TILE_WPN_CLUB;</a>
<a name="ln2179">    case WPN_MACE:                  return TILE_WPN_MACE;</a>
<a name="ln2180">    case WPN_FLAIL:                 return TILE_WPN_FLAIL;</a>
<a name="ln2181">    case WPN_GREAT_MACE:            return TILE_WPN_GREAT_MACE;</a>
<a name="ln2182">    case WPN_DIRE_FLAIL:            return TILE_WPN_DIRE_FLAIL;</a>
<a name="ln2183">    case WPN_MORNINGSTAR:           return TILE_WPN_MORNINGSTAR;</a>
<a name="ln2184">    case WPN_EVENINGSTAR:           return TILE_WPN_EVENINGSTAR;</a>
<a name="ln2185">    case WPN_GIANT_CLUB:            return TILE_WPN_GIANT_CLUB;</a>
<a name="ln2186">    case WPN_GIANT_SPIKED_CLUB:     return TILE_WPN_GIANT_SPIKED_CLUB;</a>
<a name="ln2187">    case WPN_WHIP:                  return TILE_WPN_WHIP;</a>
<a name="ln2188">    case WPN_DEMON_BLADE:           return TILE_WPN_DEMON_BLADE;</a>
<a name="ln2189">    case WPN_EUDEMON_BLADE:         return TILE_WPN_BLESSED_BLADE;</a>
<a name="ln2190">    case WPN_DEMON_WHIP:            return TILE_WPN_DEMON_WHIP;</a>
<a name="ln2191">    case WPN_SACRED_SCOURGE:        return TILE_WPN_SACRED_SCOURGE;</a>
<a name="ln2192">    case WPN_DEMON_TRIDENT:         return TILE_WPN_DEMON_TRIDENT;</a>
<a name="ln2193">    case WPN_TRISHULA:              return TILE_WPN_TRISHULA;</a>
<a name="ln2194">    case WPN_LONGBOW:               return TILE_WPN_LONGBOW;</a>
<a name="ln2195">    case WPN_LAJATANG:              return TILE_WPN_LAJATANG;</a>
<a name="ln2196">    case WPN_BARDICHE:              return TILE_WPN_BARDICHE;</a>
<a name="ln2197">    }</a>
<a name="ln2198"> </a>
<a name="ln2199">    return TILE_ERROR;</a>
<a name="ln2200">}</a>
<a name="ln2201"> </a>
<a name="ln2202">static tileidx_t _tileidx_weapon(const item_def &amp;item)</a>
<a name="ln2203">{</a>
<a name="ln2204">    tileidx_t tile = _tileidx_weapon_base(item);</a>
<a name="ln2205">    return tileidx_enchant_equ(item, tile);</a>
<a name="ln2206">}</a>
<a name="ln2207"> </a>
<a name="ln2208">static tileidx_t _tileidx_missile_base(const item_def &amp;item)</a>
<a name="ln2209">{</a>
<a name="ln2210">    int brand = item.brand;</a>
<a name="ln2211">    // 0 indicates no ego at all</a>
<a name="ln2212"> </a>
<a name="ln2213">    switch (item.sub_type)</a>
<a name="ln2214">    {</a>
<a name="ln2215">    case MI_STONE:        return TILE_MI_STONE;</a>
<a name="ln2216">    case MI_LARGE_ROCK:   return TILE_MI_LARGE_ROCK;</a>
<a name="ln2217">    case MI_THROWING_NET: return TILE_MI_THROWING_NET;</a>
<a name="ln2218">    case MI_BOOMERANG:</a>
<a name="ln2219">        switch (brand)</a>
<a name="ln2220">        {</a>
<a name="ln2221">        default:             return TILE_MI_BOOMERANG + 1;</a>
<a name="ln2222">        case 0:              return TILE_MI_BOOMERANG;</a>
<a name="ln2223">        case SPMSL_SILVER:   return TILE_MI_BOOMERANG_SILVER;</a>
<a name="ln2224">        }</a>
<a name="ln2225"> </a>
<a name="ln2226">    case MI_DART:</a>
<a name="ln2227">        switch (brand)</a>
<a name="ln2228">        {</a>
<a name="ln2229">        default:             return TILE_MI_DART + 1;</a>
<a name="ln2230">        case 0:              return TILE_MI_DART;</a>
<a name="ln2231">        case SPMSL_POISONED: return TILE_MI_DART_P;</a>
<a name="ln2232">        case SPMSL_CURARE:   return TILE_MI_DART_CURARE;</a>
<a name="ln2233">        }</a>
<a name="ln2234"> </a>
<a name="ln2235">    case MI_ARROW:</a>
<a name="ln2236">        switch (brand)</a>
<a name="ln2237">        {</a>
<a name="ln2238">        default:             return TILE_MI_ARROW + 1;</a>
<a name="ln2239">        case 0:              return TILE_MI_ARROW;</a>
<a name="ln2240">#if TAG_MAJOR_VERSION == 34</a>
<a name="ln2241">        case SPMSL_STEEL:    return TILE_MI_ARROW_STEEL;</a>
<a name="ln2242">#endif</a>
<a name="ln2243">        case SPMSL_SILVER:   return TILE_MI_ARROW_SILVER;</a>
<a name="ln2244">        }</a>
<a name="ln2245"> </a>
<a name="ln2246">    case MI_BOLT:</a>
<a name="ln2247">        switch (brand)</a>
<a name="ln2248">        {</a>
<a name="ln2249">        default:             return TILE_MI_BOLT + 1;</a>
<a name="ln2250">        case 0:              return TILE_MI_BOLT;</a>
<a name="ln2251">#if TAG_MAJOR_VERSION == 34</a>
<a name="ln2252">        case SPMSL_STEEL:    return TILE_MI_BOLT_STEEL;</a>
<a name="ln2253">#endif</a>
<a name="ln2254">        case SPMSL_SILVER:   return TILE_MI_BOLT_SILVER;</a>
<a name="ln2255">        }</a>
<a name="ln2256"> </a>
<a name="ln2257">    case MI_SLING_BULLET:</a>
<a name="ln2258">        switch (brand)</a>
<a name="ln2259">        {</a>
<a name="ln2260">        default:             return TILE_MI_SLING_BULLET + 1;</a>
<a name="ln2261">        case 0:              return TILE_MI_SLING_BULLET;</a>
<a name="ln2262">#if TAG_MAJOR_VERSION == 34</a>
<a name="ln2263">        case SPMSL_STEEL:    return TILE_MI_SLING_BULLET_STEEL;</a>
<a name="ln2264">#endif</a>
<a name="ln2265">        case SPMSL_SILVER:   return TILE_MI_SLING_BULLET_SILVER;</a>
<a name="ln2266">        }</a>
<a name="ln2267"> </a>
<a name="ln2268">    case MI_JAVELIN:</a>
<a name="ln2269">        switch (brand)</a>
<a name="ln2270">        {</a>
<a name="ln2271">        default:             return TILE_MI_JAVELIN + 1;</a>
<a name="ln2272">        case 0:              return TILE_MI_JAVELIN;</a>
<a name="ln2273">#if TAG_MAJOR_VERSION == 34</a>
<a name="ln2274">        case SPMSL_STEEL:    return TILE_MI_JAVELIN_STEEL;</a>
<a name="ln2275">#endif</a>
<a name="ln2276">        case SPMSL_SILVER:   return TILE_MI_JAVELIN_SILVER;</a>
<a name="ln2277">        }</a>
<a name="ln2278">    }</a>
<a name="ln2279"> </a>
<a name="ln2280">    return TILE_ERROR;</a>
<a name="ln2281">}</a>
<a name="ln2282"> </a>
<a name="ln2283">static tileidx_t _tileidx_missile(const item_def &amp;item)</a>
<a name="ln2284">{</a>
<a name="ln2285">    int tile = _tileidx_missile_base(item);</a>
<a name="ln2286">    return tileidx_enchant_equ(item, tile);</a>
<a name="ln2287">}</a>
<a name="ln2288"> </a>
<a name="ln2289">static tileidx_t _tileidx_armour_base(const item_def &amp;item)</a>
<a name="ln2290">{</a>
<a name="ln2291">    int type  = item.sub_type;</a>
<a name="ln2292">    switch (type)</a>
<a name="ln2293">    {</a>
<a name="ln2294">    case ARM_ROBE:</a>
<a name="ln2295">        return TILE_ARM_ROBE;</a>
<a name="ln2296"> </a>
<a name="ln2297">    case ARM_LEATHER_ARMOUR:</a>
<a name="ln2298">        return TILE_ARM_LEATHER_ARMOUR;</a>
<a name="ln2299"> </a>
<a name="ln2300">    case ARM_RING_MAIL:</a>
<a name="ln2301">        return TILE_ARM_RING_MAIL;</a>
<a name="ln2302"> </a>
<a name="ln2303">    case ARM_SCALE_MAIL:</a>
<a name="ln2304">        return TILE_ARM_SCALE_MAIL;</a>
<a name="ln2305"> </a>
<a name="ln2306">    case ARM_CHAIN_MAIL:</a>
<a name="ln2307">        return TILE_ARM_CHAIN_MAIL;</a>
<a name="ln2308"> </a>
<a name="ln2309">    case ARM_PLATE_ARMOUR:</a>
<a name="ln2310">        return TILE_ARM_PLATE_ARMOUR;</a>
<a name="ln2311"> </a>
<a name="ln2312">    case ARM_CRYSTAL_PLATE_ARMOUR:</a>
<a name="ln2313">        return TILE_ARM_CRYSTAL_PLATE_ARMOUR;</a>
<a name="ln2314"> </a>
<a name="ln2315">    case ARM_KITE_SHIELD:</a>
<a name="ln2316">        return TILE_ARM_KITE_SHIELD;</a>
<a name="ln2317"> </a>
<a name="ln2318">    case ARM_CLOAK:</a>
<a name="ln2319">        return TILE_ARM_CLOAK;</a>
<a name="ln2320"> </a>
<a name="ln2321">    case ARM_SCARF:</a>
<a name="ln2322">        return TILE_ARM_SCARF;</a>
<a name="ln2323"> </a>
<a name="ln2324">    case ARM_HAT:</a>
<a name="ln2325">        return TILE_THELM_HAT;</a>
<a name="ln2326"> </a>
<a name="ln2327">#if TAG_MAJOR_VERSION == 34</a>
<a name="ln2328">    case ARM_CAP:</a>
<a name="ln2329">        return TILE_THELM_CAP;</a>
<a name="ln2330">#endif</a>
<a name="ln2331"> </a>
<a name="ln2332">    case ARM_HELMET:</a>
<a name="ln2333">        return TILE_THELM_HELM;</a>
<a name="ln2334"> </a>
<a name="ln2335">    case ARM_GLOVES:</a>
<a name="ln2336">        return TILE_ARM_GLOVES;</a>
<a name="ln2337"> </a>
<a name="ln2338">    case ARM_BOOTS:</a>
<a name="ln2339">        return TILE_ARM_BOOTS;</a>
<a name="ln2340"> </a>
<a name="ln2341">    case ARM_BUCKLER:</a>
<a name="ln2342">        return TILE_ARM_BUCKLER;</a>
<a name="ln2343"> </a>
<a name="ln2344">    case ARM_TOWER_SHIELD:</a>
<a name="ln2345">        return TILE_ARM_TOWER_SHIELD;</a>
<a name="ln2346"> </a>
<a name="ln2347">    case ARM_CENTAUR_BARDING:</a>
<a name="ln2348">        return TILE_ARM_CENTAUR_BARDING;</a>
<a name="ln2349"> </a>
<a name="ln2350">    case ARM_NAGA_BARDING:</a>
<a name="ln2351">        return TILE_ARM_NAGA_BARDING;</a>
<a name="ln2352"> </a>
<a name="ln2353">    case ARM_ANIMAL_SKIN:</a>
<a name="ln2354">        return TILE_ARM_ANIMAL_SKIN;</a>
<a name="ln2355"> </a>
<a name="ln2356">    case ARM_TROLL_LEATHER_ARMOUR:</a>
<a name="ln2357">        return TILE_ARM_TROLL_LEATHER_ARMOUR;</a>
<a name="ln2358"> </a>
<a name="ln2359">    case ARM_FIRE_DRAGON_ARMOUR:</a>
<a name="ln2360">        return TILE_ARM_FIRE_DRAGON_ARMOUR;</a>
<a name="ln2361"> </a>
<a name="ln2362">    case ARM_ICE_DRAGON_ARMOUR:</a>
<a name="ln2363">        return TILE_ARM_ICE_DRAGON_ARMOUR;</a>
<a name="ln2364"> </a>
<a name="ln2365">    case ARM_STEAM_DRAGON_ARMOUR:</a>
<a name="ln2366">        return TILE_ARM_STEAM_DRAGON_ARMOUR;</a>
<a name="ln2367"> </a>
<a name="ln2368">    case ARM_ACID_DRAGON_ARMOUR:</a>
<a name="ln2369">        return TILE_ARM_ACID_DRAGON_ARMOUR;</a>
<a name="ln2370"> </a>
<a name="ln2371">    case ARM_QUICKSILVER_DRAGON_ARMOUR:</a>
<a name="ln2372">        return TILE_ARM_QUICKSILVER_DRAGON_ARMOUR;</a>
<a name="ln2373"> </a>
<a name="ln2374">    case ARM_STORM_DRAGON_ARMOUR:</a>
<a name="ln2375">        return TILE_ARM_STORM_DRAGON_ARMOUR;</a>
<a name="ln2376"> </a>
<a name="ln2377">    case ARM_SHADOW_DRAGON_ARMOUR:</a>
<a name="ln2378">        return TILE_ARM_SHADOW_DRAGON_ARMOUR;</a>
<a name="ln2379"> </a>
<a name="ln2380">    case ARM_GOLD_DRAGON_ARMOUR:</a>
<a name="ln2381">        return TILE_ARM_GOLD_DRAGON_ARMOUR;</a>
<a name="ln2382"> </a>
<a name="ln2383">    case ARM_PEARL_DRAGON_ARMOUR:</a>
<a name="ln2384">        return TILE_ARM_PEARL_DRAGON_ARMOUR;</a>
<a name="ln2385"> </a>
<a name="ln2386">    case ARM_SWAMP_DRAGON_ARMOUR:</a>
<a name="ln2387">        return TILE_ARM_SWAMP_DRAGON_ARMOUR;</a>
<a name="ln2388">    }</a>
<a name="ln2389"> </a>
<a name="ln2390">    return TILE_ERROR;</a>
<a name="ln2391">}</a>
<a name="ln2392"> </a>
<a name="ln2393">static tileidx_t _tileidx_armour(const item_def &amp;item)</a>
<a name="ln2394">{</a>
<a name="ln2395">    tileidx_t tile = _tileidx_armour_base(item);</a>
<a name="ln2396">    return tileidx_enchant_equ(item, tile);</a>
<a name="ln2397">}</a>
<a name="ln2398"> </a>
<a name="ln2399">static tileidx_t _tileidx_chunk(const item_def &amp;item)</a>
<a name="ln2400">{</a>
<a name="ln2401">    if (is_inedible(item))</a>
<a name="ln2402">        return TILE_FOOD_CHUNK_INEDIBLE;</a>
<a name="ln2403"> </a>
<a name="ln2404">    if (is_noxious(item))</a>
<a name="ln2405">        return TILE_FOOD_CHUNK_ROTTING;</a>
<a name="ln2406"> </a>
<a name="ln2407">    if (is_forbidden_food(item))</a>
<a name="ln2408">        return TILE_FOOD_CHUNK_FORBIDDEN;</a>
<a name="ln2409"> </a>
<a name="ln2410">    return TILE_FOOD_CHUNK;</a>
<a name="ln2411">}</a>
<a name="ln2412"> </a>
<a name="ln2413">static tileidx_t _tileidx_food(const item_def &amp;item)</a>
<a name="ln2414">{</a>
<a name="ln2415"> </a>
<a name="ln2416">    switch (item.sub_type)</a>
<a name="ln2417">    {</a>
<a name="ln2418">    case FOOD_CHUNK:</a>
<a name="ln2419">        return _tileidx_chunk(item);</a>
<a name="ln2420">    case FOOD_RATION:</a>
<a name="ln2421">    case NUM_FOODS:</a>
<a name="ln2422">    {</a>
<a name="ln2423">        // rnd should never be 0, but just in case...</a>
<a name="ln2424">        const int offset = max(item.rnd - 1, 0) %</a>
<a name="ln2425">                            (TILE_FOOD_RATION_LAST - TILE_FOOD_RATION_FIRST);</a>
<a name="ln2426">        return TILE_FOOD_RATION + offset;</a>
<a name="ln2427">    }</a>
<a name="ln2428">    default:</a>
<a name="ln2429">        return TILE_ERROR;</a>
<a name="ln2430">    }</a>
<a name="ln2431">}</a>
<a name="ln2432"> </a>
<a name="ln2433">// Returns index of skeleton tiles.</a>
<a name="ln2434">// Parameter item holds the skeleton.</a>
<a name="ln2435">static tileidx_t _tileidx_bone(const item_def &amp;item)</a>
<a name="ln2436">{</a>
<a name="ln2437">    const monster_type mc = item.mon_type;</a>
<a name="ln2438">    const size_type st = get_monster_data(mc)-&gt;size;</a>
<a name="ln2439">    int cs = 0;</a>
<a name="ln2440"> </a>
<a name="ln2441">    switch (st)</a>
<a name="ln2442">    {</a>
<a name="ln2443">    default:</a>
<a name="ln2444">        cs = 0; break;</a>
<a name="ln2445">    case SIZE_MEDIUM:</a>
<a name="ln2446">        cs = 1; break;</a>
<a name="ln2447">    case SIZE_LARGE:</a>
<a name="ln2448">    case SIZE_BIG:</a>
<a name="ln2449">        cs = 2; break;</a>
<a name="ln2450">    case SIZE_GIANT:</a>
<a name="ln2451">        cs = 3; break;</a>
<a name="ln2452">    }</a>
<a name="ln2453"> </a>
<a name="ln2454">    switch (get_mon_shape(item.mon_type))</a>
<a name="ln2455">    {</a>
<a name="ln2456">    case MON_SHAPE_HUMANOID:</a>
<a name="ln2457">    case MON_SHAPE_HUMANOID_TAILED:</a>
<a name="ln2458">    case MON_SHAPE_HUMANOID_WINGED:</a>
<a name="ln2459">    case MON_SHAPE_HUMANOID_WINGED_TAILED:</a>
<a name="ln2460">        return TILE_FOOD_BONE_HUMANOID + cs;</a>
<a name="ln2461">    default:</a>
<a name="ln2462">        return TILE_FOOD_BONE + cs;</a>
<a name="ln2463">    }</a>
<a name="ln2464">}</a>
<a name="ln2465"> </a>
<a name="ln2466">// Returns index of corpse tiles.</a>
<a name="ln2467">// Parameter item holds the corpse.</a>
<a name="ln2468">static tileidx_t _tileidx_corpse(const item_def &amp;item)</a>
<a name="ln2469">{</a>
<a name="ln2470">    const int type = item.plus;</a>
<a name="ln2471">    const tileidx_t base = get_mon_base_corpse_tile((monster_type)type);</a>
<a name="ln2472"> </a>
<a name="ln2473">    switch (type)</a>
<a name="ln2474">    {</a>
<a name="ln2475">    case MONS_KILLER_KLOWN:</a>
<a name="ln2476">    {</a>
<a name="ln2477">        const int count = tile_main_count(TILE_CORPSE_KILLER_KLOWN);</a>
<a name="ln2478">        return base + ui_random(count);</a>
<a name="ln2479">    }</a>
<a name="ln2480"> </a>
<a name="ln2481">    case MONS_UGLY_THING:</a>
<a name="ln2482">    case MONS_VERY_UGLY_THING:</a>
<a name="ln2483">    {</a>
<a name="ln2484">        int colour_offset = ugly_thing_colour_offset(item.get_colour());</a>
<a name="ln2485">        if (colour_offset == -1)</a>
<a name="ln2486">            colour_offset = 0;</a>
<a name="ln2487">        return base + colour_offset;</a>
<a name="ln2488">    }</a>
<a name="ln2489"> </a>
<a name="ln2490">    default:</a>
<a name="ln2491">        return base;</a>
<a name="ln2492">    }</a>
<a name="ln2493">}</a>
<a name="ln2494"> </a>
<a name="ln2495">static tileidx_t _tileidx_uncollected_rune(const item_def &amp;item)</a>
<a name="ln2496">{</a>
<a name="ln2497">    switch (item.sub_type)</a>
<a name="ln2498">    {</a>
<a name="ln2499">    // the hell runes:</a>
<a name="ln2500">    case RUNE_DIS:         return TILE_UNCOLLECTED_RUNE_DIS;</a>
<a name="ln2501">    case RUNE_GEHENNA:     return TILE_UNCOLLECTED_RUNE_GEHENNA;</a>
<a name="ln2502">    case RUNE_COCYTUS:     return TILE_UNCOLLECTED_RUNE_COCYTUS;</a>
<a name="ln2503">    case RUNE_TARTARUS:    return TILE_UNCOLLECTED_RUNE_TARTARUS;</a>
<a name="ln2504"> </a>
<a name="ln2505">    // special pandemonium runes:</a>
<a name="ln2506">    case RUNE_MNOLEG:      return TILE_UNCOLLECTED_RUNE_MNOLEG;</a>
<a name="ln2507">    case RUNE_LOM_LOBON:   return TILE_UNCOLLECTED_RUNE_LOM_LOBON;</a>
<a name="ln2508">    case RUNE_CEREBOV:     return TILE_UNCOLLECTED_RUNE_CEREBOV;</a>
<a name="ln2509">    case RUNE_GLOORX_VLOQ: return TILE_UNCOLLECTED_RUNE_GLOORX_VLOQ;</a>
<a name="ln2510"> </a>
<a name="ln2511">    case RUNE_DEMONIC:     return TILE_UNCOLLECTED_RUNE_DEMONIC;</a>
<a name="ln2512">    case RUNE_ABYSSAL:     return TILE_UNCOLLECTED_RUNE_ABYSS;</a>
<a name="ln2513"> </a>
<a name="ln2514">    case RUNE_SNAKE:       return TILE_UNCOLLECTED_RUNE_SNAKE;</a>
<a name="ln2515">    case RUNE_SPIDER:      return TILE_UNCOLLECTED_RUNE_SPIDER;</a>
<a name="ln2516">    case RUNE_SLIME:       return TILE_UNCOLLECTED_RUNE_SLIME;</a>
<a name="ln2517">    case RUNE_VAULTS:      return TILE_UNCOLLECTED_RUNE_VAULTS;</a>
<a name="ln2518">    case RUNE_TOMB:        return TILE_UNCOLLECTED_RUNE_TOMB;</a>
<a name="ln2519">    case RUNE_SWAMP:       return TILE_UNCOLLECTED_RUNE_SWAMP;</a>
<a name="ln2520">    case RUNE_SHOALS:      return TILE_UNCOLLECTED_RUNE_SHOALS;</a>
<a name="ln2521">    case RUNE_ELF:         return TILE_UNCOLLECTED_RUNE_ELVEN;</a>
<a name="ln2522"> </a>
<a name="ln2523">    case RUNE_FOREST:</a>
<a name="ln2524">    default:               return TILE_MISC_UNCOLLECTED_RUNE_OF_ZOT;</a>
<a name="ln2525">    }</a>
<a name="ln2526">}</a>
<a name="ln2527"> </a>
<a name="ln2528">static tileidx_t _tileidx_rune(const item_def &amp;item)</a>
<a name="ln2529">{</a>
<a name="ln2530">    switch (item.sub_type)</a>
<a name="ln2531">    {</a>
<a name="ln2532">    // the hell runes:</a>
<a name="ln2533">    case RUNE_DIS:         return TILE_RUNE_DIS;</a>
<a name="ln2534">    case RUNE_GEHENNA:     return TILE_RUNE_GEHENNA;</a>
<a name="ln2535">    case RUNE_COCYTUS:     return TILE_RUNE_COCYTUS;</a>
<a name="ln2536">    case RUNE_TARTARUS:    return TILE_RUNE_TARTARUS;</a>
<a name="ln2537"> </a>
<a name="ln2538">    // special pandemonium runes:</a>
<a name="ln2539">    case RUNE_MNOLEG:      return TILE_RUNE_MNOLEG;</a>
<a name="ln2540">    case RUNE_LOM_LOBON:   return TILE_RUNE_LOM_LOBON;</a>
<a name="ln2541">    case RUNE_CEREBOV:     return TILE_RUNE_CEREBOV;</a>
<a name="ln2542">    case RUNE_GLOORX_VLOQ: return TILE_RUNE_GLOORX_VLOQ;</a>
<a name="ln2543"> </a>
<a name="ln2544">    case RUNE_DEMONIC:     return TILE_RUNE_DEMONIC</a>
<a name="ln2545">        + ((uint32_t)item.rnd) % tile_main_count(TILE_RUNE_DEMONIC);</a>
<a name="ln2546">    case RUNE_ABYSSAL:     return TILE_RUNE_ABYSS;</a>
<a name="ln2547"> </a>
<a name="ln2548">    case RUNE_SNAKE:       return TILE_RUNE_SNAKE;</a>
<a name="ln2549">    case RUNE_SPIDER:      return TILE_RUNE_SPIDER;</a>
<a name="ln2550">    case RUNE_SLIME:       return TILE_RUNE_SLIME;</a>
<a name="ln2551">    case RUNE_VAULTS:      return TILE_RUNE_VAULTS;</a>
<a name="ln2552">    case RUNE_TOMB:        return TILE_RUNE_TOMB;</a>
<a name="ln2553">    case RUNE_SWAMP:       return TILE_RUNE_SWAMP;</a>
<a name="ln2554">    case RUNE_SHOALS:      return TILE_RUNE_SHOALS;</a>
<a name="ln2555">    case RUNE_ELF:         return TILE_RUNE_ELVEN;</a>
<a name="ln2556"> </a>
<a name="ln2557">    case RUNE_FOREST:</a>
<a name="ln2558">    default:               return TILE_MISC_RUNE_OF_ZOT;</a>
<a name="ln2559">    }</a>
<a name="ln2560">}</a>
<a name="ln2561"> </a>
<a name="ln2562">static tileidx_t _tileidx_misc(const item_def &amp;item)</a>
<a name="ln2563">{</a>
<a name="ln2564">    switch (item.sub_type)</a>
<a name="ln2565">    {</a>
<a name="ln2566">#if TAG_MAJOR_VERSION == 34</a>
<a name="ln2567">    case MISC_BOTTLED_EFREET:</a>
<a name="ln2568">        return TILE_MISC_BOTTLED_EFREET;</a>
<a name="ln2569"> </a>
<a name="ln2570">    case MISC_FAN_OF_GALES:</a>
<a name="ln2571">        return TILE_MISC_FAN_OF_GALES_INERT;</a>
<a name="ln2572"> </a>
<a name="ln2573">    case MISC_LAMP_OF_FIRE:</a>
<a name="ln2574">        return TILE_MISC_LAMP_OF_FIRE_INERT;</a>
<a name="ln2575"> </a>
<a name="ln2576">    case MISC_STONE_OF_TREMORS:</a>
<a name="ln2577">        return TILE_MISC_STONE_OF_TREMORS_INERT;</a>
<a name="ln2578">#endif</a>
<a name="ln2579"> </a>
<a name="ln2580">    case MISC_PHIAL_OF_FLOODS:</a>
<a name="ln2581">        return evoker_charges(item.sub_type) ? TILE_MISC_PHIAL_OF_FLOODS</a>
<a name="ln2582">                                             : TILE_MISC_PHIAL_OF_FLOODS_INERT;</a>
<a name="ln2583"> </a>
<a name="ln2584">#if TAG_MAJOR_VERSION == 34</a>
<a name="ln2585">    case MISC_BUGGY_LANTERN_OF_SHADOWS:</a>
<a name="ln2586">        return TILE_MISC_LANTERN_OF_SHADOWS;</a>
<a name="ln2587">#endif</a>
<a name="ln2588"> </a>
<a name="ln2589">    case MISC_HORN_OF_GERYON:</a>
<a name="ln2590">        return TILE_MISC_HORN_OF_GERYON;</a>
<a name="ln2591"> </a>
<a name="ln2592">    case MISC_BOX_OF_BEASTS:</a>
<a name="ln2593">        return TILE_MISC_BOX_OF_BEASTS;</a>
<a name="ln2594"> </a>
<a name="ln2595">#if TAG_MAJOR_VERSION == 34</a>
<a name="ln2596">    case MISC_CRYSTAL_BALL_OF_ENERGY:</a>
<a name="ln2597">        return TILE_MISC_CRYSTAL_BALL_OF_ENERGY;</a>
<a name="ln2598">#endif</a>
<a name="ln2599"> </a>
<a name="ln2600">    case MISC_LIGHTNING_ROD:</a>
<a name="ln2601">        return evoker_charges(item.sub_type) ? TILE_MISC_LIGHTNING_ROD</a>
<a name="ln2602">                                             : TILE_MISC_LIGHTNING_ROD_INERT;</a>
<a name="ln2603"> </a>
<a name="ln2604">#if TAG_MAJOR_VERSION == 34</a>
<a name="ln2605">    case MISC_SACK_OF_SPIDERS:</a>
<a name="ln2606">        return TILE_MISC_SACK_OF_SPIDERS;</a>
<a name="ln2607">#endif</a>
<a name="ln2608"> </a>
<a name="ln2609">    // Default for summary menus</a>
<a name="ln2610">    case NUM_MISCELLANY:</a>
<a name="ln2611">    case MISC_PHANTOM_MIRROR:</a>
<a name="ln2612">        return TILE_MISC_PHANTOM_MIRROR;</a>
<a name="ln2613"> </a>
<a name="ln2614">    case MISC_ZIGGURAT:</a>
<a name="ln2615">        return TILE_MISC_ZIGGURAT;</a>
<a name="ln2616"> </a>
<a name="ln2617">    case MISC_QUAD_DAMAGE:</a>
<a name="ln2618">        return TILE_MISC_QUAD_DAMAGE;</a>
<a name="ln2619">    }</a>
<a name="ln2620"> </a>
<a name="ln2621">    return TILE_ERROR;</a>
<a name="ln2622">}</a>
<a name="ln2623"> </a>
<a name="ln2624">static tileidx_t _tileidx_gold(const item_def &amp;item)</a>
<a name="ln2625">{</a>
<a name="ln2626">    if (item.quantity &gt;= 1 &amp;&amp; item.quantity &lt;= 10)</a>
<a name="ln2627">        return TILE_GOLD01 + item.quantity - 1;</a>
<a name="ln2628">    if (item.quantity &lt; 20)</a>
<a name="ln2629">        return TILE_GOLD16;</a>
<a name="ln2630">    if (item.quantity &lt; 30)</a>
<a name="ln2631">        return TILE_GOLD19;</a>
<a name="ln2632">    if (item.quantity &lt; 100)</a>
<a name="ln2633">        return TILE_GOLD23;</a>
<a name="ln2634">    return TILE_GOLD25;</a>
<a name="ln2635">}</a>
<a name="ln2636"> </a>
<a name="ln2637">tileidx_t tileidx_item(const item_def &amp;item)</a>
<a name="ln2638">{</a>
<a name="ln2639">    if (item.props.exists(&quot;item_tile&quot;))</a>
<a name="ln2640">        return item.props[&quot;item_tile&quot;].get_short();</a>
<a name="ln2641"> </a>
<a name="ln2642">    const int clas        = item.base_type;</a>
<a name="ln2643">    const int type        = item.sub_type;</a>
<a name="ln2644">    const int subtype_rnd = item.subtype_rnd;</a>
<a name="ln2645">    const int rnd         = item.rnd;</a>
<a name="ln2646"> </a>
<a name="ln2647">    switch (clas)</a>
<a name="ln2648">    {</a>
<a name="ln2649">    case OBJ_WEAPONS:</a>
<a name="ln2650">        if (is_unrandom_artefact(item, UNRAND_WYRMBANE))</a>
<a name="ln2651">            return _tileidx_wyrmbane(item.plus);</a>
<a name="ln2652">        else if (is_unrandom_artefact(item))</a>
<a name="ln2653">            return _tileidx_unrand_artefact(find_unrandart_index(item));</a>
<a name="ln2654">        else</a>
<a name="ln2655">            return _tileidx_weapon(item);</a>
<a name="ln2656"> </a>
<a name="ln2657">    case OBJ_MISSILES:</a>
<a name="ln2658">        return _tileidx_missile(item);</a>
<a name="ln2659"> </a>
<a name="ln2660">    case OBJ_ARMOUR:</a>
<a name="ln2661">        if (is_unrandom_artefact(item))</a>
<a name="ln2662">            return _tileidx_unrand_artefact(find_unrandart_index(item));</a>
<a name="ln2663">        else</a>
<a name="ln2664">            return _tileidx_armour(item);</a>
<a name="ln2665"> </a>
<a name="ln2666">    case OBJ_WANDS:</a>
<a name="ln2667">        if (item.flags &amp; ISFLAG_KNOW_TYPE)</a>
<a name="ln2668">            return TILE_WAND_ID_FIRST + type;</a>
<a name="ln2669">        else</a>
<a name="ln2670">            return TILE_WAND_OFFSET + subtype_rnd % NDSC_WAND_PRI;</a>
<a name="ln2671"> </a>
<a name="ln2672">    case OBJ_FOOD:</a>
<a name="ln2673">        return _tileidx_food(item);</a>
<a name="ln2674"> </a>
<a name="ln2675">    case OBJ_SCROLLS:</a>
<a name="ln2676">        if (item.flags &amp; ISFLAG_KNOW_TYPE)</a>
<a name="ln2677">            return TILE_SCR_ID_FIRST + type;</a>
<a name="ln2678">        return TILE_SCROLL;</a>
<a name="ln2679"> </a>
<a name="ln2680">    case OBJ_GOLD:</a>
<a name="ln2681">        return _tileidx_gold(item);</a>
<a name="ln2682"> </a>
<a name="ln2683">    case OBJ_JEWELLERY:</a>
<a name="ln2684">        if (is_unrandom_artefact(item))</a>
<a name="ln2685">            return _tileidx_unrand_artefact(find_unrandart_index(item));</a>
<a name="ln2686"> </a>
<a name="ln2687">        // rings</a>
<a name="ln2688">        if (!jewellery_is_amulet(item))</a>
<a name="ln2689">        {</a>
<a name="ln2690">            if (is_artefact(item))</a>
<a name="ln2691">            {</a>
<a name="ln2692">                const int offset = item.rnd</a>
<a name="ln2693">                                   % tile_main_count(TILE_RING_RANDART_OFFSET);</a>
<a name="ln2694">                return TILE_RING_RANDART_OFFSET + offset;</a>
<a name="ln2695">            }</a>
<a name="ln2696"> </a>
<a name="ln2697">            if (item.flags &amp; ISFLAG_KNOW_TYPE)</a>
<a name="ln2698">            {</a>
<a name="ln2699">                return TILE_RING_ID_FIRST + type - RING_FIRST_RING</a>
<a name="ln2700">#if TAG_MAJOR_VERSION == 34</a>
<a name="ln2701">                       + 1 // we have a save-compat ring tile before FIRST_RING</a>
<a name="ln2702">#endif</a>
<a name="ln2703">                    ;</a>
<a name="ln2704">            }</a>
<a name="ln2705"> </a>
<a name="ln2706">            return TILE_RING_NORMAL_OFFSET + subtype_rnd % NDSC_JEWEL_PRI;</a>
<a name="ln2707">        }</a>
<a name="ln2708"> </a>
<a name="ln2709">        // amulets</a>
<a name="ln2710">        if (is_artefact(item))</a>
<a name="ln2711">        {</a>
<a name="ln2712">            const int offset = item.rnd</a>
<a name="ln2713">                               % tile_main_count(TILE_AMU_RANDART_OFFSET);</a>
<a name="ln2714">            return TILE_AMU_RANDART_OFFSET + offset;</a>
<a name="ln2715">        }</a>
<a name="ln2716"> </a>
<a name="ln2717">        if (item.flags &amp; ISFLAG_KNOW_TYPE)</a>
<a name="ln2718">            return TILE_AMU_ID_FIRST + type - AMU_FIRST_AMULET;</a>
<a name="ln2719">        return TILE_AMU_NORMAL_OFFSET + subtype_rnd % NDSC_JEWEL_PRI;</a>
<a name="ln2720"> </a>
<a name="ln2721">    case OBJ_POTIONS:</a>
<a name="ln2722">        if (item.flags &amp; ISFLAG_KNOW_TYPE)</a>
<a name="ln2723">            return TILE_POT_ID_FIRST + type;</a>
<a name="ln2724">        else</a>
<a name="ln2725">            return TILE_POTION_OFFSET + item.subtype_rnd % NDSC_POT_PRI;</a>
<a name="ln2726"> </a>
<a name="ln2727">    case OBJ_BOOKS:</a>
<a name="ln2728">        if (is_random_artefact(item))</a>
<a name="ln2729">        {</a>
<a name="ln2730">            const int offset = rnd % tile_main_count(TILE_BOOK_RANDART_OFFSET);</a>
<a name="ln2731">            return TILE_BOOK_RANDART_OFFSET + offset;</a>
<a name="ln2732">        }</a>
<a name="ln2733"> </a>
<a name="ln2734">        if (item.sub_type == BOOK_MANUAL)</a>
<a name="ln2735">            return TILE_BOOK_MANUAL + rnd % tile_main_count(TILE_BOOK_MANUAL);</a>
<a name="ln2736"> </a>
<a name="ln2737">        return TILE_BOOK_OFFSET</a>
<a name="ln2738">               + rnd % tile_main_count(TILE_BOOK_OFFSET);</a>
<a name="ln2739"> </a>
<a name="ln2740">    case OBJ_STAVES:</a>
<a name="ln2741">        if (item.flags &amp; ISFLAG_KNOW_TYPE)</a>
<a name="ln2742">            return TILE_STAFF_ID_FIRST + type;</a>
<a name="ln2743"> </a>
<a name="ln2744">        return TILE_STAFF_OFFSET</a>
<a name="ln2745">               + (subtype_rnd / NDSC_STAVE_PRI) % NDSC_STAVE_SEC;</a>
<a name="ln2746"> </a>
<a name="ln2747">#if TAG_MAJOR_VERSION == 34</a>
<a name="ln2748">    case OBJ_RODS:</a>
<a name="ln2749">        return TILE_ROD + item.rnd % tile_main_count(TILE_ROD);</a>
<a name="ln2750">#endif</a>
<a name="ln2751"> </a>
<a name="ln2752">    case OBJ_CORPSES:</a>
<a name="ln2753">        if (item.sub_type == CORPSE_SKELETON)</a>
<a name="ln2754">            return _tileidx_bone(item);</a>
<a name="ln2755">        else</a>
<a name="ln2756">            return _tileidx_corpse(item);</a>
<a name="ln2757"> </a>
<a name="ln2758">    case OBJ_ORBS:</a>
<a name="ln2759">        if (item.quantity &lt;= 0)</a>
<a name="ln2760">            return TILE_UNCOLLECTED_ORB;</a>
<a name="ln2761">        return TILE_ORB + ui_random(tile_main_count(TILE_ORB));</a>
<a name="ln2762"> </a>
<a name="ln2763">    case OBJ_MISCELLANY:</a>
<a name="ln2764">        return _tileidx_misc(item);</a>
<a name="ln2765"> </a>
<a name="ln2766">    case OBJ_RUNES:</a>
<a name="ln2767">        if (item.quantity &lt;= 0)</a>
<a name="ln2768">            return _tileidx_uncollected_rune(item);</a>
<a name="ln2769">        return _tileidx_rune(item);</a>
<a name="ln2770"> </a>
<a name="ln2771">    case OBJ_DETECTED:</a>
<a name="ln2772">        return TILE_UNSEEN_ITEM;</a>
<a name="ln2773"> </a>
<a name="ln2774">    default:</a>
<a name="ln2775">        return TILE_ERROR;</a>
<a name="ln2776">    }</a>
<a name="ln2777">}</a>
<a name="ln2778"> </a>
<a name="ln2779">//  Determine Octant of missile direction</a>
<a name="ln2780">//   .---&gt; X+</a>
<a name="ln2781">//   |</a>
<a name="ln2782">//   |  701</a>
<a name="ln2783">//   Y  6O2</a>
<a name="ln2784">//   +  543</a>
<a name="ln2785">//</a>
<a name="ln2786">// The octant boundary slope tan(pi/8)=sqrt(2)-1 = 0.414 is approximated by 2/5.</a>
<a name="ln2787">static int _tile_bolt_dir(int dx, int dy)</a>
<a name="ln2788">{</a>
<a name="ln2789">    int ax = abs(dx);</a>
<a name="ln2790">    int ay = abs(dy);</a>
<a name="ln2791"> </a>
<a name="ln2792">    if (5*ay &lt; 2*ax)</a>
<a name="ln2793">        return (dx &gt; 0) ? 2 : 6;</a>
<a name="ln2794">    else if (5*ax &lt; 2*ay)</a>
<a name="ln2795">        return (dy &gt; 0) ? 4 : 0;</a>
<a name="ln2796">    else if (dx &gt; 0)</a>
<a name="ln2797">        return (dy &gt; 0) ? 3 : 1;</a>
<a name="ln2798">    else</a>
<a name="ln2799">        return (dy &gt; 0) ? 5: 7;</a>
<a name="ln2800">}</a>
<a name="ln2801"> </a>
<a name="ln2802">tileidx_t tileidx_item_throw(const item_def &amp;item, int dx, int dy)</a>
<a name="ln2803">{</a>
<a name="ln2804">    if (item.base_type == OBJ_MISSILES)</a>
<a name="ln2805">    {</a>
<a name="ln2806">        int ch = -1;</a>
<a name="ln2807">        int dir = _tile_bolt_dir(dx, dy);</a>
<a name="ln2808"> </a>
<a name="ln2809">        // Thrown items with multiple directions</a>
<a name="ln2810">        switch (item.sub_type)</a>
<a name="ln2811">        {</a>
<a name="ln2812">            case MI_ARROW:</a>
<a name="ln2813">                ch = TILE_MI_ARROW0;</a>
<a name="ln2814">                break;</a>
<a name="ln2815">            case MI_BOLT:</a>
<a name="ln2816">                ch = TILE_MI_BOLT0;</a>
<a name="ln2817">                break;</a>
<a name="ln2818">            case MI_DART:</a>
<a name="ln2819">                ch = TILE_MI_DART0;</a>
<a name="ln2820">                break;</a>
<a name="ln2821">            case MI_JAVELIN:</a>
<a name="ln2822">                ch = TILE_MI_JAVELIN0;</a>
<a name="ln2823">                break;</a>
<a name="ln2824">            case MI_THROWING_NET:</a>
<a name="ln2825">                ch = TILE_MI_THROWING_NET0;</a>
<a name="ln2826">                break;</a>
<a name="ln2827">            default:</a>
<a name="ln2828">                break;</a>
<a name="ln2829">        }</a>
<a name="ln2830">        if (ch != -1)</a>
<a name="ln2831">            return ch + dir;</a>
<a name="ln2832"> </a>
<a name="ln2833">        // Thrown items with a single direction</a>
<a name="ln2834">        switch (item.sub_type)</a>
<a name="ln2835">        {</a>
<a name="ln2836">            case MI_STONE:</a>
<a name="ln2837">                ch = TILE_MI_STONE0;</a>
<a name="ln2838">                break;</a>
<a name="ln2839">            case MI_SLING_BULLET:</a>
<a name="ln2840">                switch (item.brand)</a>
<a name="ln2841">                {</a>
<a name="ln2842">                default:</a>
<a name="ln2843">                    ch = TILE_MI_SLING_BULLET0;</a>
<a name="ln2844">                    break;</a>
<a name="ln2845">#if TAG_MAJOR_VERSION == 34</a>
<a name="ln2846">                case SPMSL_STEEL:</a>
<a name="ln2847">                    ch = TILE_MI_SLING_BULLET_STEEL0;</a>
<a name="ln2848">                    break;</a>
<a name="ln2849">#endif</a>
<a name="ln2850">                case SPMSL_SILVER:</a>
<a name="ln2851">                    ch = TILE_MI_SLING_BULLET_SILVER0;</a>
<a name="ln2852">                    break;</a>
<a name="ln2853">                }</a>
<a name="ln2854">                break;</a>
<a name="ln2855">            case MI_LARGE_ROCK:</a>
<a name="ln2856">                ch = TILE_MI_LARGE_ROCK0;</a>
<a name="ln2857">                break;</a>
<a name="ln2858">            case MI_THROWING_NET:</a>
<a name="ln2859">                ch = TILE_MI_THROWING_NET0;</a>
<a name="ln2860">                break;</a>
<a name="ln2861">            case MI_BOOMERANG:</a>
<a name="ln2862">                ch = TILE_MI_BOOMERANG0;</a>
<a name="ln2863">            default:</a>
<a name="ln2864">                break;</a>
<a name="ln2865">        }</a>
<a name="ln2866">        if (ch != -1)</a>
<a name="ln2867">            return tileidx_enchant_equ(item, ch);</a>
<a name="ln2868">    }</a>
<a name="ln2869"> </a>
<a name="ln2870">    // If not a special case, just return the default tile.</a>
<a name="ln2871">    return tileidx_item(item);</a>
<a name="ln2872">}</a>
<a name="ln2873"> </a>
<a name="ln2874">// For items with randomized descriptions, only the overlay label is</a>
<a name="ln2875">// placed in the tile page. This function looks up what the base item</a>
<a name="ln2876">// is based on the randomized description. It returns 0 if there is none.</a>
<a name="ln2877">tileidx_t tileidx_known_base_item(tileidx_t label)</a>
<a name="ln2878">{</a>
<a name="ln2879">    if (label &gt;= TILE_POT_ID_FIRST &amp;&amp; label &lt;= TILE_POT_ID_LAST)</a>
<a name="ln2880">    {</a>
<a name="ln2881">        int type = label - TILE_POT_ID_FIRST;</a>
<a name="ln2882">        int desc = you.item_description[IDESC_POTIONS][type] % NDSC_POT_PRI;</a>
<a name="ln2883"> </a>
<a name="ln2884">        if (!get_ident_type(OBJ_POTIONS, type))</a>
<a name="ln2885">            return TILE_UNSEEN_POTION;</a>
<a name="ln2886">        else</a>
<a name="ln2887">            return TILE_POTION_OFFSET + desc;</a>
<a name="ln2888">    }</a>
<a name="ln2889"> </a>
<a name="ln2890">    if (label &gt;= TILE_RING_ID_FIRST &amp;&amp; label &lt;= TILE_RING_ID_LAST)</a>
<a name="ln2891">    {</a>
<a name="ln2892">        int type = label - TILE_RING_ID_FIRST + RING_FIRST_RING</a>
<a name="ln2893">#if TAG_MAJOR_VERSION == 34</a>
<a name="ln2894">                   - 1 // we have a save-compat ring tile before FIRST_RING</a>
<a name="ln2895">#endif</a>
<a name="ln2896">            ;</a>
<a name="ln2897">        int desc = you.item_description[IDESC_RINGS][type] % NDSC_JEWEL_PRI;</a>
<a name="ln2898"> </a>
<a name="ln2899">        if (!get_ident_type(OBJ_JEWELLERY, type))</a>
<a name="ln2900">            return TILE_UNSEEN_RING;</a>
<a name="ln2901">        else</a>
<a name="ln2902">            return TILE_RING_NORMAL_OFFSET + desc;</a>
<a name="ln2903">    }</a>
<a name="ln2904"> </a>
<a name="ln2905">    if (label &gt;= TILE_AMU_ID_FIRST &amp;&amp; label &lt;= TILE_AMU_ID_LAST)</a>
<a name="ln2906">    {</a>
<a name="ln2907">        int type = label - TILE_AMU_ID_FIRST + AMU_FIRST_AMULET;</a>
<a name="ln2908">        int desc = you.item_description[IDESC_RINGS][type] % NDSC_JEWEL_PRI;</a>
<a name="ln2909"> </a>
<a name="ln2910">        if (!get_ident_type(OBJ_JEWELLERY, type))</a>
<a name="ln2911">            return TILE_UNSEEN_AMULET;</a>
<a name="ln2912">        else</a>
<a name="ln2913">            return TILE_AMU_NORMAL_OFFSET + desc;</a>
<a name="ln2914">    }</a>
<a name="ln2915"> </a>
<a name="ln2916">    if (label &gt;= TILE_SCR_ID_FIRST &amp;&amp; label &lt;= TILE_SCR_ID_LAST)</a>
<a name="ln2917">        return TILE_SCROLL;</a>
<a name="ln2918"> </a>
<a name="ln2919">    if (label &gt;= TILE_WAND_ID_FIRST &amp;&amp; label &lt;= TILE_WAND_ID_LAST)</a>
<a name="ln2920">    {</a>
<a name="ln2921">        int type = label - TILE_WAND_ID_FIRST;</a>
<a name="ln2922">        int desc = you.item_description[IDESC_WANDS][type] % NDSC_WAND_PRI;</a>
<a name="ln2923"> </a>
<a name="ln2924">        if (!get_ident_type(OBJ_WANDS, type))</a>
<a name="ln2925">            return TILE_UNSEEN_WAND;</a>
<a name="ln2926">        else</a>
<a name="ln2927">            return TILE_WAND_OFFSET + desc;</a>
<a name="ln2928">    }</a>
<a name="ln2929"> </a>
<a name="ln2930">    if (label &gt;= TILE_STAFF_ID_FIRST &amp;&amp; label &lt;= TILE_STAFF_ID_LAST)</a>
<a name="ln2931">    {</a>
<a name="ln2932">        int type = label - TILE_STAFF_ID_FIRST;</a>
<a name="ln2933">        int desc = you.item_description[IDESC_STAVES][type];</a>
<a name="ln2934">        desc = (desc / NDSC_STAVE_PRI) % NDSC_STAVE_SEC;</a>
<a name="ln2935"> </a>
<a name="ln2936">        if (!get_ident_type(OBJ_STAVES, type))</a>
<a name="ln2937">            return TILE_UNSEEN_STAFF;</a>
<a name="ln2938">        else</a>
<a name="ln2939">            return TILE_STAFF_OFFSET + desc;</a>
<a name="ln2940">    }</a>
<a name="ln2941"> </a>
<a name="ln2942">    return 0;</a>
<a name="ln2943">}</a>
<a name="ln2944"> </a>
<a name="ln2945">tileidx_t tileidx_cloud(const cloud_info &amp;cl)</a>
<a name="ln2946">{</a>
<a name="ln2947">    const cloud_type type  = cl.type;</a>
<a name="ln2948">    const int colour = cl.colour;</a>
<a name="ln2949">    const unsigned int dur = cl.duration;</a>
<a name="ln2950"> </a>
<a name="ln2951">    tileidx_t ch = cl.tile;</a>
<a name="ln2952"> </a>
<a name="ln2953">    if (ch == 0)</a>
<a name="ln2954">    {</a>
<a name="ln2955">        const cloud_tile_info &amp;tile_info = cloud_type_tile_info(type);</a>
<a name="ln2956"> </a>
<a name="ln2957">        switch (tile_info.variation)</a>
<a name="ln2958">        {</a>
<a name="ln2959">            case CTVARY_NONE:</a>
<a name="ln2960">                ch = tile_info.base;</a>
<a name="ln2961">                break;</a>
<a name="ln2962">            case CTVARY_DUR:</a>
<a name="ln2963">                ch = tile_info.base + min(dur,</a>
<a name="ln2964">                                          tile_main_count(tile_info.base) - 1);</a>
<a name="ln2965">                break;</a>
<a name="ln2966">            case CTVARY_RANDOM:</a>
<a name="ln2967">                ch = tile_info.base + hash_with_seed(</a>
<a name="ln2968">                        tile_main_count(tile_info.base),</a>
<a name="ln2969">                        cl.pos.y * GXM + cl.pos.x, you.frame_no);</a>
<a name="ln2970">                break;</a>
<a name="ln2971">        }</a>
<a name="ln2972"> </a>
<a name="ln2973">        if (!ch || ch == TILE_ERROR)</a>
<a name="ln2974">            ch = TILE_CLOUD_GREY_SMOKE;</a>
<a name="ln2975"> </a>
<a name="ln2976">        switch (type)</a>
<a name="ln2977">        {</a>
<a name="ln2978">            case CLOUD_MUTAGENIC:</a>
<a name="ln2979">                ch = (dur == 0 ? TILE_CLOUD_MUTAGENIC_0 :</a>
<a name="ln2980">                      dur == 1 ? TILE_CLOUD_MUTAGENIC_1</a>
<a name="ln2981">                               : TILE_CLOUD_MUTAGENIC_2);</a>
<a name="ln2982">                ch += ui_random(tile_main_count(ch));</a>
<a name="ln2983">                break;</a>
<a name="ln2984"> </a>
<a name="ln2985">            case CLOUD_TORNADO:</a>
<a name="ln2986">                ch = get_tornado_phase(cl.pos) ? TILE_CLOUD_RAGING_WINDS_0</a>
<a name="ln2987">                                               : TILE_CLOUD_RAGING_WINDS_1;</a>
<a name="ln2988">                break;</a>
<a name="ln2989"> </a>
<a name="ln2990">            default:</a>
<a name="ln2991">                break;</a>
<a name="ln2992">        }</a>
<a name="ln2993">    }</a>
<a name="ln2994"> </a>
<a name="ln2995">    if (colour != -1)</a>
<a name="ln2996">        ch = tile_main_coloured(ch, colour);</a>
<a name="ln2997"> </a>
<a name="ln2998">    // XXX: Should be no need for TILE_FLAG_FLYING anymore since clouds are</a>
<a name="ln2999">    // drawn in a separate layer but I'll leave it for now in case anything changes --mumra</a>
<a name="ln3000">    return ch | TILE_FLAG_FLYING;</a>
<a name="ln3001">}</a>
<a name="ln3002"> </a>
<a name="ln3003">tileidx_t tileidx_bolt(const bolt &amp;bolt)</a>
<a name="ln3004">{</a>
<a name="ln3005">    const int col = bolt.colour;</a>
<a name="ln3006">    const coord_def diff = bolt.target - bolt.source;</a>
<a name="ln3007">    const int dir = _tile_bolt_dir(diff.x, diff.y);</a>
<a name="ln3008"> </a>
<a name="ln3009">    switch (col)</a>
<a name="ln3010">    {</a>
<a name="ln3011">    case WHITE:</a>
<a name="ln3012">        if (bolt.name == &quot;crystal spear&quot;)</a>
<a name="ln3013">            return TILE_BOLT_CRYSTAL_SPEAR + dir;</a>
<a name="ln3014">        else if (bolt.name == &quot;puff of frost&quot;)</a>
<a name="ln3015">            return TILE_BOLT_FROST;</a>
<a name="ln3016">        else if (bolt.name == &quot;shard of ice&quot;)</a>
<a name="ln3017">            return TILE_BOLT_ICICLE + dir;</a>
<a name="ln3018">        else if (bolt.name == &quot;searing ray&quot;)</a>
<a name="ln3019">            return TILE_BOLT_SEARING_RAY;</a>
<a name="ln3020">        break;</a>
<a name="ln3021"> </a>
<a name="ln3022">    case LIGHTCYAN:</a>
<a name="ln3023">        if (bolt.name == &quot;iron shot&quot;)</a>
<a name="ln3024">            return TILE_BOLT_IRON_SHOT + dir;</a>
<a name="ln3025">        else if (bolt.name == &quot;zap&quot;)</a>
<a name="ln3026">            return TILE_BOLT_ZAP + dir % tile_main_count(TILE_BOLT_ZAP);</a>
<a name="ln3027">        break;</a>
<a name="ln3028"> </a>
<a name="ln3029">    case RED:</a>
<a name="ln3030">        if (bolt.name == &quot;puff of flame&quot;)</a>
<a name="ln3031">            return TILE_BOLT_FLAME;</a>
<a name="ln3032">        break;</a>
<a name="ln3033"> </a>
<a name="ln3034">    case LIGHTRED:</a>
<a name="ln3035">        if (bolt.name.find(&quot;damnation&quot;) != string::npos)</a>
<a name="ln3036">            return TILE_BOLT_DAMNATION;</a>
<a name="ln3037">        break;</a>
<a name="ln3038"> </a>
<a name="ln3039">    case LIGHTMAGENTA:</a>
<a name="ln3040">        if (bolt.name == &quot;magic dart&quot;)</a>
<a name="ln3041">            return TILE_BOLT_MAGIC_DART;</a>
<a name="ln3042">        break;</a>
<a name="ln3043"> </a>
<a name="ln3044">    case BROWN:</a>
<a name="ln3045">        if (bolt.name == &quot;blast of sand&quot;)</a>
<a name="ln3046">            return TILE_BOLT_SANDBLAST;</a>
<a name="ln3047">        else if (bolt.name == &quot;klown pie&quot;)</a>
<a name="ln3048">            return TILE_BOLT_PIE + dir;</a>
<a name="ln3049">        break;</a>
<a name="ln3050"> </a>
<a name="ln3051">    case GREEN:</a>
<a name="ln3052">        if (bolt.name == &quot;sting&quot;)</a>
<a name="ln3053">            return TILE_BOLT_POISON_ARROW + dir;</a>
<a name="ln3054">        break;</a>
<a name="ln3055"> </a>
<a name="ln3056">    case LIGHTGREEN:</a>
<a name="ln3057">        if (bolt.name == &quot;poison arrow&quot;)</a>
<a name="ln3058">            return TILE_BOLT_POISON_ARROW + dir;</a>
<a name="ln3059">        break;</a>
<a name="ln3060"> </a>
<a name="ln3061">    case LIGHTGREY:</a>
<a name="ln3062">        if (bolt.name == &quot;stone arrow&quot;)</a>
<a name="ln3063">            return TILE_BOLT_STONE_ARROW + dir;</a>
<a name="ln3064">        break;</a>
<a name="ln3065"> </a>
<a name="ln3066">    case DARKGREY:</a>
<a name="ln3067">        if (bolt.name == &quot;bolt of negative energy&quot;)</a>
<a name="ln3068">            return TILE_BOLT_DRAIN;</a>
<a name="ln3069">        break;</a>
<a name="ln3070"> </a>
<a name="ln3071">    case MAGENTA:</a>
<a name="ln3072">        break;</a>
<a name="ln3073"> </a>
<a name="ln3074">    case CYAN:</a>
<a name="ln3075">        if (bolt.name == &quot;slug dart&quot;)</a>
<a name="ln3076">            return TILE_BOLT_STONE_ARROW + dir;</a>
<a name="ln3077">        break;</a>
<a name="ln3078"> </a>
<a name="ln3079">    case ETC_MUTAGENIC:</a>
<a name="ln3080">        if (bolt.name == &quot;irradiate&quot; || bolt.name == &quot;unravelling&quot;)</a>
<a name="ln3081">            return TILE_BOLT_IRRADIATE;</a>
<a name="ln3082">        break;</a>
<a name="ln3083">    }</a>
<a name="ln3084"> </a>
<a name="ln3085">    return tileidx_zap(col);</a>
<a name="ln3086">}</a>
<a name="ln3087"> </a>
<a name="ln3088">tileidx_t vary_bolt_tile(tileidx_t tile, int dist)</a>
<a name="ln3089">{</a>
<a name="ln3090">    switch (tile)</a>
<a name="ln3091">    {</a>
<a name="ln3092">    case TILE_BOLT_FROST:</a>
<a name="ln3093">    case TILE_BOLT_MAGIC_DART:</a>
<a name="ln3094">    case TILE_BOLT_SANDBLAST:</a>
<a name="ln3095">    case TILE_BOLT_STING:</a>
<a name="ln3096">        return tile + dist % tile_main_count(tile);</a>
<a name="ln3097">    case TILE_BOLT_FLAME:</a>
<a name="ln3098">    case TILE_BOLT_IRRADIATE:</a>
<a name="ln3099">        return tile + ui_random(tile_main_count(tile));</a>
<a name="ln3100">    case TILE_MI_BOOMERANG0:</a>
<a name="ln3101">        return tile + ui_random(4);</a>
<a name="ln3102">    default:</a>
<a name="ln3103">        return tile;</a>
<a name="ln3104">    }</a>
<a name="ln3105">}</a>
<a name="ln3106"> </a>
<a name="ln3107">tileidx_t tileidx_zap(int colour)</a>
<a name="ln3108">{</a>
<a name="ln3109">    switch (colour)</a>
<a name="ln3110">    {</a>
<a name="ln3111">    case ETC_HOLY:</a>
<a name="ln3112">        colour = YELLOW;</a>
<a name="ln3113">        break;</a>
<a name="ln3114">    default:</a>
<a name="ln3115">        colour = element_colour(colour);</a>
<a name="ln3116">        break;</a>
<a name="ln3117">    }</a>
<a name="ln3118"> </a>
<a name="ln3119">    if (colour &lt; 1)</a>
<a name="ln3120">        colour = 7;</a>
<a name="ln3121">    else if (colour &gt; 8)</a>
<a name="ln3122">        colour -= 8;</a>
<a name="ln3123"> </a>
<a name="ln3124">    return TILE_SYM_BOLT_OFS - 1 + colour;</a>
<a name="ln3125">}</a>
<a name="ln3126"> </a>
<a name="ln3127">tileidx_t tileidx_spell(spell_type spell)</a>
<a name="ln3128">{</a>
<a name="ln3129">    if (spell == NUM_SPELLS)</a>
<a name="ln3130">        return TILEG_MEMORISE; // XXX: Hack!</a>
<a name="ln3131">    return get_spell_tile(spell);</a>
<a name="ln3132">}</a>
<a name="ln3133"> </a>
<a name="ln3134">/**</a>
<a name="ln3135"> * Get the appropriate tile for the given skill @ the given training level.</a>
<a name="ln3136"> *</a>
<a name="ln3137"> * @param skill     The skill in question; e.g. SK_FIGHTING.</a>
<a name="ln3138"> * @param train     The training_status to render at; e.g. TRAINING_DISABLED.</a>
<a name="ln3139"> * @return          An appropriate tile; e.g. TILEG_FIGHTING_OFF&gt;</a>
<a name="ln3140"> */</a>
<a name="ln3141">tileidx_t tileidx_skill(skill_type skill, int train)</a>
<a name="ln3142">{</a>
<a name="ln3143">    tileidx_t ch;</a>
<a name="ln3144">    switch (skill)</a>
<a name="ln3145">    {</a>
<a name="ln3146">    case SK_FIGHTING:       ch = TILEG_FIGHTING_ON; break;</a>
<a name="ln3147">    case SK_SHORT_BLADES:   ch = TILEG_SHORT_BLADES_ON; break;</a>
<a name="ln3148">    case SK_LONG_BLADES:    ch = TILEG_LONG_BLADES_ON; break;</a>
<a name="ln3149">    case SK_AXES:           ch = TILEG_AXES_ON; break;</a>
<a name="ln3150">    case SK_MACES_FLAILS:   ch = TILEG_MACES_FLAILS_ON; break;</a>
<a name="ln3151">    case SK_POLEARMS:       ch = TILEG_POLEARMS_ON; break;</a>
<a name="ln3152">    case SK_STAVES:         ch = TILEG_STAVES_ON; break;</a>
<a name="ln3153">    case SK_SLINGS:         ch = TILEG_SLINGS_ON; break;</a>
<a name="ln3154">    case SK_BOWS:           ch = TILEG_BOWS_ON; break;</a>
<a name="ln3155">    case SK_CROSSBOWS:      ch = TILEG_CROSSBOWS_ON; break;</a>
<a name="ln3156">    case SK_THROWING:       ch = TILEG_THROWING_ON; break;</a>
<a name="ln3157">    case SK_ARMOUR:         ch = TILEG_ARMOUR_ON; break;</a>
<a name="ln3158">    case SK_DODGING:        ch = TILEG_DODGING_ON; break;</a>
<a name="ln3159">    case SK_STEALTH:        ch = TILEG_STEALTH_ON; break;</a>
<a name="ln3160">    case SK_SHIELDS:        ch = TILEG_SHIELDS_ON; break;</a>
<a name="ln3161">    case SK_UNARMED_COMBAT:</a>
<a name="ln3162">        {</a>
<a name="ln3163">            const string hand = you.hand_name(false);</a>
<a name="ln3164">            if (hand == &quot;hand&quot;)</a>
<a name="ln3165">                ch = TILEG_UNARMED_COMBAT_ON;</a>
<a name="ln3166">            else if (hand == &quot;paw&quot;)</a>
<a name="ln3167">                ch = TILEG_UNARMED_COMBAT_PAW_ON;</a>
<a name="ln3168">            else if (hand == &quot;tentacle&quot;)</a>
<a name="ln3169">                ch = TILEG_UNARMED_COMBAT_TENTACLE_ON;</a>
<a name="ln3170">            else</a>
<a name="ln3171">                ch = TILEG_UNARMED_COMBAT_CLAW_ON;</a>
<a name="ln3172">        }</a>
<a name="ln3173">        break;</a>
<a name="ln3174">    case SK_SPELLCASTING:   ch = TILEG_SPELLCASTING_ON; break;</a>
<a name="ln3175">    case SK_CONJURATIONS:   ch = TILEG_CONJURATIONS_ON; break;</a>
<a name="ln3176">    case SK_HEXES:          ch = TILEG_HEXES_ON; break;</a>
<a name="ln3177">    case SK_CHARMS:         ch = TILEG_CHARMS_ON; break;</a>
<a name="ln3178">    case SK_SUMMONINGS:     ch = TILEG_SUMMONINGS_ON; break;</a>
<a name="ln3179">    case SK_NECROMANCY:</a>
<a name="ln3180">        ch = you.religion == GOD_KIKUBAAQUDGHA ? TILEG_NECROMANCY_K_ON</a>
<a name="ln3181">                                               : TILEG_NECROMANCY_ON; break;</a>
<a name="ln3182">    case SK_TRANSLOCATIONS: ch = TILEG_TRANSLOCATIONS_ON; break;</a>
<a name="ln3183">    case SK_TRANSMUTATIONS: ch = TILEG_TRANSMUTATIONS_ON; break;</a>
<a name="ln3184">    case SK_FIRE_MAGIC:     ch = TILEG_FIRE_MAGIC_ON; break;</a>
<a name="ln3185">    case SK_ICE_MAGIC:      ch = TILEG_ICE_MAGIC_ON; break;</a>
<a name="ln3186">    case SK_AIR_MAGIC:      ch = TILEG_AIR_MAGIC_ON; break;</a>
<a name="ln3187">    case SK_EARTH_MAGIC:    ch = TILEG_EARTH_MAGIC_ON; break;</a>
<a name="ln3188">    case SK_POISON_MAGIC:   ch = TILEG_POISON_MAGIC_ON; break;</a>
<a name="ln3189">    case SK_EVOCATIONS:     ch = TILEG_EVOCATIONS_ON; break;</a>
<a name="ln3190">    case SK_INVOCATIONS:</a>
<a name="ln3191">        {</a>
<a name="ln3192">            switch (you.religion)</a>
<a name="ln3193">            {</a>
<a name="ln3194">            // Gods who use invo get a unique tile.</a>
<a name="ln3195">            case GOD_SHINING_ONE:</a>
<a name="ln3196">                ch = TILEG_INVOCATIONS_1_ON; break;</a>
<a name="ln3197">            case GOD_BEOGH:</a>
<a name="ln3198">                ch = TILEG_INVOCATIONS_B_ON; break;</a>
<a name="ln3199">            case GOD_CHEIBRIADOS:</a>
<a name="ln3200">                ch = TILEG_INVOCATIONS_C_ON; break;</a>
<a name="ln3201">            case GOD_DITHMENOS:</a>
<a name="ln3202">                ch = TILEG_INVOCATIONS_D_ON; break;</a>
<a name="ln3203">            case GOD_ELYVILON:</a>
<a name="ln3204">                ch = TILEG_INVOCATIONS_E_ON; break;</a>
<a name="ln3205">            case GOD_FEDHAS:</a>
<a name="ln3206">                ch = TILEG_INVOCATIONS_F_ON; break;</a>
<a name="ln3207">            case GOD_HEPLIAKLQANA:</a>
<a name="ln3208">                ch = TILEG_INVOCATIONS_H_ON; break;</a>
<a name="ln3209">            case GOD_LUGONU:</a>
<a name="ln3210">                ch = TILEG_INVOCATIONS_L_ON; break;</a>
<a name="ln3211">            case GOD_MAKHLEB:</a>
<a name="ln3212">                ch = TILEG_INVOCATIONS_M_ON; break;</a>
<a name="ln3213">            case GOD_NEMELEX_XOBEH:</a>
<a name="ln3214">                ch = TILEG_INVOCATIONS_N_ON; break;</a>
<a name="ln3215">            case GOD_OKAWARU:</a>
<a name="ln3216">                ch = TILEG_INVOCATIONS_O_ON; break;</a>
<a name="ln3217">            case GOD_QAZLAL:</a>
<a name="ln3218">                ch = TILEG_INVOCATIONS_Q_ON; break;</a>
<a name="ln3219">            case GOD_SIF_MUNA:</a>
<a name="ln3220">                ch = TILEG_INVOCATIONS_S_ON; break;</a>
<a name="ln3221">            case GOD_USKAYAW:</a>
<a name="ln3222">                ch = TILEG_INVOCATIONS_U_ON; break;</a>
<a name="ln3223">            case GOD_YREDELEMNUL:</a>
<a name="ln3224">                ch = TILEG_INVOCATIONS_Y_ON; break;</a>
<a name="ln3225">            case GOD_ZIN:</a>
<a name="ln3226">                ch = TILEG_INVOCATIONS_Z_ON; break;</a>
<a name="ln3227">            default:</a>
<a name="ln3228">                ch = TILEG_INVOCATIONS_ON;</a>
<a name="ln3229">            }</a>
<a name="ln3230">        }</a>
<a name="ln3231">        break;</a>
<a name="ln3232">    default:                return TILEG_TODO;</a>
<a name="ln3233">    }</a>
<a name="ln3234"> </a>
<a name="ln3235">    switch (train)</a>
<a name="ln3236">    {</a>
<a name="ln3237">    case TRAINING_DISABLED:</a>
<a name="ln3238">        return ch + TILEG_FIGHTING_OFF - TILEG_FIGHTING_ON;</a>
<a name="ln3239">    case TRAINING_INACTIVE:</a>
<a name="ln3240">        return ch + TILEG_FIGHTING_INACTIVE - TILEG_FIGHTING_ON;</a>
<a name="ln3241">    case TRAINING_ENABLED:</a>
<a name="ln3242">        return ch;</a>
<a name="ln3243">    case TRAINING_FOCUSED:</a>
<a name="ln3244">        return ch + TILEG_FIGHTING_FOCUS - TILEG_FIGHTING_ON;</a>
<a name="ln3245">    case TRAINING_MASTERED:</a>
<a name="ln3246">        return ch + TILEG_FIGHTING_MAX - TILEG_FIGHTING_ON;</a>
<a name="ln3247">    default:</a>
<a name="ln3248">        die(&quot;invalid skill tile type&quot;);</a>
<a name="ln3249">    }</a>
<a name="ln3250"> </a>
<a name="ln3251">}</a>
<a name="ln3252"> </a>
<a name="ln3253">tileidx_t tileidx_command(const command_type cmd)</a>
<a name="ln3254">{</a>
<a name="ln3255">    switch (cmd)</a>
<a name="ln3256">    {</a>
<a name="ln3257">    case CMD_REST:</a>
<a name="ln3258">        return TILEG_CMD_REST;</a>
<a name="ln3259">    case CMD_EXPLORE:</a>
<a name="ln3260">        return TILEG_CMD_EXPLORE;</a>
<a name="ln3261">    case CMD_INTERLEVEL_TRAVEL:</a>
<a name="ln3262">        return TILEG_CMD_INTERLEVEL_TRAVEL;</a>
<a name="ln3263">#ifdef CLUA_BINDINGS</a>
<a name="ln3264">    // might not be defined if building without LUA</a>
<a name="ln3265">    case CMD_AUTOFIGHT:</a>
<a name="ln3266">        return TILEG_CMD_AUTOFIGHT;</a>
<a name="ln3267">#endif</a>
<a name="ln3268">    case CMD_WAIT:</a>
<a name="ln3269">        return TILEG_CMD_WAIT;</a>
<a name="ln3270">    case CMD_USE_ABILITY:</a>
<a name="ln3271">        return TILEG_CMD_USE_ABILITY;</a>
<a name="ln3272">    case CMD_SEARCH_STASHES:</a>
<a name="ln3273">        return TILEG_CMD_SEARCH_STASHES;</a>
<a name="ln3274">    case CMD_REPLAY_MESSAGES:</a>
<a name="ln3275">        return TILEG_CMD_REPLAY_MESSAGES;</a>
<a name="ln3276">    case CMD_RESISTS_SCREEN:</a>
<a name="ln3277">        return TILEG_CMD_RESISTS_SCREEN;</a>
<a name="ln3278">    case CMD_DISPLAY_OVERMAP:</a>
<a name="ln3279">        return TILEG_CMD_DISPLAY_OVERMAP;</a>
<a name="ln3280">    case CMD_DISPLAY_RELIGION:</a>
<a name="ln3281">        return TILEG_CMD_DISPLAY_RELIGION;</a>
<a name="ln3282">    case CMD_DISPLAY_MUTATIONS:</a>
<a name="ln3283">        return TILEG_CMD_DISPLAY_MUTATIONS;</a>
<a name="ln3284">    case CMD_DISPLAY_SKILLS:</a>
<a name="ln3285">        return TILEG_CMD_DISPLAY_SKILLS;</a>
<a name="ln3286">    case CMD_DISPLAY_CHARACTER_STATUS:</a>
<a name="ln3287">        return TILEG_CMD_DISPLAY_CHARACTER_STATUS;</a>
<a name="ln3288">    case CMD_DISPLAY_KNOWN_OBJECTS:</a>
<a name="ln3289">        return TILEG_CMD_KNOWN_ITEMS;</a>
<a name="ln3290">    case CMD_SAVE_GAME_NOW:</a>
<a name="ln3291">        return TILEG_CMD_SAVE_GAME_NOW;</a>
<a name="ln3292">    case CMD_EDIT_PLAYER_TILE:</a>
<a name="ln3293">        return TILEG_CMD_EDIT_PLAYER_TILE;</a>
<a name="ln3294">    case CMD_DISPLAY_COMMANDS:</a>
<a name="ln3295">        return TILEG_CMD_DISPLAY_COMMANDS;</a>
<a name="ln3296">    case CMD_LOOKUP_HELP:</a>
<a name="ln3297">        return TILEG_CMD_LOOKUP_HELP;</a>
<a name="ln3298">    case CMD_CHARACTER_DUMP:</a>
<a name="ln3299">        return TILEG_CMD_CHARACTER_DUMP;</a>
<a name="ln3300">    case CMD_DISPLAY_INVENTORY:</a>
<a name="ln3301">        return TILEG_CMD_DISPLAY_INVENTORY;</a>
<a name="ln3302">    case CMD_CAST_SPELL:</a>
<a name="ln3303">        return TILEG_CMD_CAST_SPELL;</a>
<a name="ln3304">    case CMD_BUTCHER:</a>
<a name="ln3305">        return TILEG_CMD_BUTCHER;</a>
<a name="ln3306">    case CMD_MEMORISE_SPELL:</a>
<a name="ln3307">        return TILEG_CMD_MEMORISE_SPELL;</a>
<a name="ln3308">    case CMD_DROP:</a>
<a name="ln3309">        return TILEG_CMD_DROP;</a>
<a name="ln3310">    case CMD_DISPLAY_MAP:</a>
<a name="ln3311">        return TILEG_CMD_DISPLAY_MAP;</a>
<a name="ln3312">    case CMD_MAP_GOTO_TARGET:</a>
<a name="ln3313">        return TILEG_CMD_MAP_GOTO_TARGET;</a>
<a name="ln3314">    case CMD_MAP_NEXT_LEVEL:</a>
<a name="ln3315">        return TILEG_CMD_MAP_NEXT_LEVEL;</a>
<a name="ln3316">    case CMD_MAP_PREV_LEVEL:</a>
<a name="ln3317">        return TILEG_CMD_MAP_PREV_LEVEL;</a>
<a name="ln3318">    case CMD_MAP_GOTO_LEVEL:</a>
<a name="ln3319">        return TILEG_CMD_MAP_GOTO_LEVEL;</a>
<a name="ln3320">    case CMD_MAP_EXCLUDE_AREA:</a>
<a name="ln3321">        return TILEG_CMD_MAP_EXCLUDE_AREA;</a>
<a name="ln3322">    case CMD_MAP_FIND_EXCLUDED:</a>
<a name="ln3323">        return TILEG_CMD_MAP_FIND_EXCLUDED;</a>
<a name="ln3324">    case CMD_MAP_CLEAR_EXCLUDES:</a>
<a name="ln3325">        return TILEG_CMD_MAP_CLEAR_EXCLUDES;</a>
<a name="ln3326">    case CMD_MAP_ADD_WAYPOINT:</a>
<a name="ln3327">        return TILEG_CMD_MAP_ADD_WAYPOINT;</a>
<a name="ln3328">    case CMD_MAP_FIND_WAYPOINT:</a>
<a name="ln3329">        return TILEG_CMD_MAP_FIND_WAYPOINT;</a>
<a name="ln3330">    case CMD_MAP_FIND_UPSTAIR:</a>
<a name="ln3331">        return TILEG_CMD_MAP_FIND_UPSTAIR;</a>
<a name="ln3332">    case CMD_MAP_FIND_DOWNSTAIR:</a>
<a name="ln3333">        return TILEG_CMD_MAP_FIND_DOWNSTAIR;</a>
<a name="ln3334">    case CMD_MAP_FIND_YOU:</a>
<a name="ln3335">        return TILEG_CMD_MAP_FIND_YOU;</a>
<a name="ln3336">    case CMD_MAP_FIND_PORTAL:</a>
<a name="ln3337">        return TILEG_CMD_MAP_FIND_PORTAL;</a>
<a name="ln3338">    case CMD_MAP_FIND_TRAP:</a>
<a name="ln3339">        return TILEG_CMD_MAP_FIND_TRAP;</a>
<a name="ln3340">    case CMD_MAP_FIND_ALTAR:</a>
<a name="ln3341">        return TILEG_CMD_MAP_FIND_ALTAR;</a>
<a name="ln3342">    case CMD_MAP_FIND_STASH:</a>
<a name="ln3343">        return TILEG_CMD_MAP_FIND_STASH;</a>
<a name="ln3344">#ifdef TOUCH_UI</a>
<a name="ln3345">    case CMD_SHOW_KEYBOARD:</a>
<a name="ln3346">        return TILEG_CMD_KEYBOARD;</a>
<a name="ln3347">#endif</a>
<a name="ln3348">    default:</a>
<a name="ln3349">        return TILEG_TODO;</a>
<a name="ln3350">    }</a>
<a name="ln3351">}</a>
<a name="ln3352"> </a>
<a name="ln3353">tileidx_t tileidx_gametype(const game_type gtype)</a>
<a name="ln3354">{</a>
<a name="ln3355">    switch (gtype)</a>
<a name="ln3356">    {</a>
<a name="ln3357">    case GAME_TYPE_NORMAL:</a>
<a name="ln3358">    case GAME_TYPE_CUSTOM_SEED:</a>
<a name="ln3359">        return TILEG_STARTUP_STONESOUP;</a>
<a name="ln3360">    case GAME_TYPE_TUTORIAL:</a>
<a name="ln3361">        return TILEG_STARTUP_TUTORIAL;</a>
<a name="ln3362">    case GAME_TYPE_HINTS:</a>
<a name="ln3363">        return TILEG_STARTUP_HINTS;</a>
<a name="ln3364">    case GAME_TYPE_SPRINT:</a>
<a name="ln3365">        return TILEG_STARTUP_SPRINT;</a>
<a name="ln3366">    case GAME_TYPE_INSTRUCTIONS:</a>
<a name="ln3367">        return TILEG_STARTUP_INSTRUCTIONS;</a>
<a name="ln3368">    case GAME_TYPE_ARENA:</a>
<a name="ln3369">        return TILEG_STARTUP_ARENA;</a>
<a name="ln3370">    case GAME_TYPE_HIGH_SCORES:</a>
<a name="ln3371">        return TILEG_STARTUP_HIGH_SCORES;</a>
<a name="ln3372">    default:</a>
<a name="ln3373">        return TILEG_ERROR;</a>
<a name="ln3374">    }</a>
<a name="ln3375">}</a>
<a name="ln3376"> </a>
<a name="ln3377">tileidx_t tileidx_ability(const ability_type ability)</a>
<a name="ln3378">{</a>
<a name="ln3379">    switch (ability)</a>
<a name="ln3380">    {</a>
<a name="ln3381">    // Innate abilities and (Demonspaw) mutations.</a>
<a name="ln3382">    case ABIL_SPIT_POISON:</a>
<a name="ln3383">        return TILEG_ABILITY_SPIT_POISON;</a>
<a name="ln3384">    case ABIL_BREATHE_FIRE:</a>
<a name="ln3385">        return TILEG_ABILITY_BREATHE_FIRE;</a>
<a name="ln3386">    case ABIL_BREATHE_FROST:</a>
<a name="ln3387">        return TILEG_ABILITY_BREATHE_FROST;</a>
<a name="ln3388">    case ABIL_BREATHE_POISON:</a>
<a name="ln3389">        return TILEG_ABILITY_BREATHE_POISON;</a>
<a name="ln3390">    case ABIL_BREATHE_LIGHTNING:</a>
<a name="ln3391">        return TILEG_ABILITY_BREATHE_LIGHTNING;</a>
<a name="ln3392">    case ABIL_BREATHE_POWER:</a>
<a name="ln3393">        return TILEG_ABILITY_BREATHE_ENERGY;</a>
<a name="ln3394">    case ABIL_BREATHE_STEAM:</a>
<a name="ln3395">        return TILEG_ABILITY_BREATHE_STEAM;</a>
<a name="ln3396">    case ABIL_BREATHE_MEPHITIC:</a>
<a name="ln3397">        return TILEG_ABILITY_BREATHE_MEPHITIC;</a>
<a name="ln3398">    case ABIL_BREATHE_ACID:</a>
<a name="ln3399">        return TILEG_ABILITY_BREATHE_ACID;</a>
<a name="ln3400">    case ABIL_BLINK:</a>
<a name="ln3401">        return TILEG_ABILITY_BLINK;</a>
<a name="ln3402">    case ABIL_HOP:</a>
<a name="ln3403">        return TILEG_ABILITY_HOP;</a>
<a name="ln3404"> </a>
<a name="ln3405">    // Others</a>
<a name="ln3406">    case ABIL_END_TRANSFORMATION:</a>
<a name="ln3407">        return TILEG_ABILITY_END_TRANSFORMATION;</a>
<a name="ln3408">    case ABIL_STOP_RECALL:</a>
<a name="ln3409">        return TILEG_ABILITY_STOP_RECALL;</a>
<a name="ln3410">    case ABIL_CANCEL_PPROJ:</a>
<a name="ln3411">        return TILEG_ABILITY_CANCEL_PPROJ;</a>
<a name="ln3412"> </a>
<a name="ln3413">    // Species-specific abilities.</a>
<a name="ln3414">    // Demonspawn-only</a>
<a name="ln3415">    case ABIL_DAMNATION:</a>
<a name="ln3416">        return TILEG_ABILITY_HURL_DAMNATION;</a>
<a name="ln3417">    // Tengu, Draconians</a>
<a name="ln3418">    case ABIL_FLY:</a>
<a name="ln3419">        return TILEG_ABILITY_FLIGHT;</a>
<a name="ln3420">    case ABIL_STOP_FLYING:</a>
<a name="ln3421">        return TILEG_ABILITY_FLIGHT_END;</a>
<a name="ln3422">    // Vampires</a>
<a name="ln3423">    case ABIL_TRAN_BAT:</a>
<a name="ln3424">        return TILEG_ABILITY_BAT_FORM;</a>
<a name="ln3425">    case ABIL_EXSANGUINATE:</a>
<a name="ln3426">        return TILEG_ABILITY_EXSANGUINATE;</a>
<a name="ln3427">    case ABIL_REVIVIFY:</a>
<a name="ln3428">        return TILEG_ABILITY_REVIVIFY;</a>
<a name="ln3429">    // Deep Dwarves</a>
<a name="ln3430">    case ABIL_HEAL_WOUNDS:</a>
<a name="ln3431">        return TILEG_ABILITY_HEAL_WOUNDS;</a>
<a name="ln3432">    // Formicids</a>
<a name="ln3433">    case ABIL_DIG:</a>
<a name="ln3434">        return TILEG_ABILITY_DIG;</a>
<a name="ln3435">    case ABIL_SHAFT_SELF:</a>
<a name="ln3436">        return TILEG_ABILITY_SHAFT_SELF;</a>
<a name="ln3437"> </a>
<a name="ln3438">    // Evoking items.</a>
<a name="ln3439">    case ABIL_EVOKE_BERSERK:</a>
<a name="ln3440">        return TILEG_ABILITY_EVOKE_BERSERK;</a>
<a name="ln3441">    case ABIL_EVOKE_BLINK:</a>
<a name="ln3442">        return TILEG_ABILITY_BLINK;</a>
<a name="ln3443">    case ABIL_EVOKE_TURN_INVISIBLE:</a>
<a name="ln3444">        return TILEG_ABILITY_EVOKE_INVISIBILITY;</a>
<a name="ln3445">    case ABIL_EVOKE_TURN_VISIBLE:</a>
<a name="ln3446">        return TILEG_ABILITY_EVOKE_INVISIBILITY_END;</a>
<a name="ln3447">    case ABIL_EVOKE_FLIGHT:</a>
<a name="ln3448">        return TILEG_ABILITY_EVOKE_FLIGHT;</a>
<a name="ln3449">    case ABIL_EVOKE_FOG:</a>
<a name="ln3450">        return TILEG_ABILITY_EVOKE_FOG;</a>
<a name="ln3451">    case ABIL_EVOKE_RATSKIN:</a>
<a name="ln3452">        return TILEG_ABILITY_EVOKE_RATSKIN;</a>
<a name="ln3453">    case ABIL_EVOKE_THUNDER:</a>
<a name="ln3454">        return TILEG_ABILITY_EVOKE_THUNDER;</a>
<a name="ln3455"> </a>
<a name="ln3456">    // Divine abilities</a>
<a name="ln3457">    // Zin</a>
<a name="ln3458">    case ABIL_ZIN_SUSTENANCE:</a>
<a name="ln3459">        return TILEG_TODO;</a>
<a name="ln3460">    case ABIL_ZIN_RECITE:</a>
<a name="ln3461">        return TILEG_ABILITY_ZIN_RECITE;</a>
<a name="ln3462">    case ABIL_ZIN_VITALISATION:</a>
<a name="ln3463">        return TILEG_ABILITY_ZIN_VITALISATION;</a>
<a name="ln3464">    case ABIL_ZIN_IMPRISON:</a>
<a name="ln3465">        return TILEG_ABILITY_ZIN_IMPRISON;</a>
<a name="ln3466">    case ABIL_ZIN_SANCTUARY:</a>
<a name="ln3467">        return TILEG_ABILITY_ZIN_SANCTUARY;</a>
<a name="ln3468">    case ABIL_ZIN_DONATE_GOLD:</a>
<a name="ln3469">        return TILEG_ABILITY_ZIN_DONATE_GOLD;</a>
<a name="ln3470">    // TSO</a>
<a name="ln3471">    case ABIL_TSO_DIVINE_SHIELD:</a>
<a name="ln3472">        return TILEG_ABILITY_TSO_DIVINE_SHIELD;</a>
<a name="ln3473">    case ABIL_TSO_CLEANSING_FLAME:</a>
<a name="ln3474">        return TILEG_ABILITY_TSO_CLEANSING_FLAME;</a>
<a name="ln3475">    case ABIL_TSO_SUMMON_DIVINE_WARRIOR:</a>
<a name="ln3476">        return TILEG_ABILITY_TSO_DIVINE_WARRIOR;</a>
<a name="ln3477">    case ABIL_TSO_BLESS_WEAPON:</a>
<a name="ln3478">        return TILEG_ABILITY_TSO_BLESS_WEAPON;</a>
<a name="ln3479">    // Kiku</a>
<a name="ln3480">    case ABIL_KIKU_RECEIVE_CORPSES:</a>
<a name="ln3481">        return TILEG_ABILITY_KIKU_RECEIVE_CORPSES;</a>
<a name="ln3482">    case ABIL_KIKU_TORMENT:</a>
<a name="ln3483">        return TILEG_ABILITY_KIKU_TORMENT;</a>
<a name="ln3484">    case ABIL_KIKU_BLESS_WEAPON:</a>
<a name="ln3485">        return TILEG_ABILITY_KIKU_BLESS_WEAPON;</a>
<a name="ln3486">    case ABIL_KIKU_GIFT_NECRONOMICON:</a>
<a name="ln3487">        return TILEG_ABILITY_KIKU_NECRONOMICON;</a>
<a name="ln3488">    // Yredelemnul</a>
<a name="ln3489">    case ABIL_YRED_INJURY_MIRROR:</a>
<a name="ln3490">        return TILEG_ABILITY_YRED_INJURY_MIRROR;</a>
<a name="ln3491">    case ABIL_YRED_ANIMATE_REMAINS:</a>
<a name="ln3492">        return TILEG_ABILITY_YRED_ANIMATE_REMAINS;</a>
<a name="ln3493">    case ABIL_YRED_RECALL_UNDEAD_SLAVES:</a>
<a name="ln3494">        return TILEG_ABILITY_YRED_RECALL;</a>
<a name="ln3495">    case ABIL_YRED_ANIMATE_DEAD:</a>
<a name="ln3496">        return TILEG_ABILITY_YRED_ANIMATE_DEAD;</a>
<a name="ln3497">    case ABIL_YRED_DRAIN_LIFE:</a>
<a name="ln3498">        return TILEG_ABILITY_YRED_DRAIN_LIFE;</a>
<a name="ln3499">    case ABIL_YRED_ENSLAVE_SOUL:</a>
<a name="ln3500">        return TILEG_ABILITY_YRED_ENSLAVE_SOUL;</a>
<a name="ln3501">    // Xom, Vehumet = 90</a>
<a name="ln3502">    // Okawaru</a>
<a name="ln3503">    case ABIL_OKAWARU_HEROISM:</a>
<a name="ln3504">        return TILEG_ABILITY_OKAWARU_HEROISM;</a>
<a name="ln3505">    case ABIL_OKAWARU_FINESSE:</a>
<a name="ln3506">        return TILEG_ABILITY_OKAWARU_FINESSE;</a>
<a name="ln3507">    // Makhleb</a>
<a name="ln3508">    case ABIL_MAKHLEB_MINOR_DESTRUCTION:</a>
<a name="ln3509">        return TILEG_ABILITY_MAKHLEB_MINOR_DESTRUCTION;</a>
<a name="ln3510">    case ABIL_MAKHLEB_LESSER_SERVANT_OF_MAKHLEB:</a>
<a name="ln3511">        return TILEG_ABILITY_MAKHLEB_LESSER_SERVANT;</a>
<a name="ln3512">    case ABIL_MAKHLEB_MAJOR_DESTRUCTION:</a>
<a name="ln3513">        return TILEG_ABILITY_MAKHLEB_MAJOR_DESTRUCTION;</a>
<a name="ln3514">    case ABIL_MAKHLEB_GREATER_SERVANT_OF_MAKHLEB:</a>
<a name="ln3515">        return TILEG_ABILITY_MAKHLEB_GREATER_SERVANT;</a>
<a name="ln3516">    // Sif Muna</a>
<a name="ln3517">    case ABIL_SIF_MUNA_CHANNEL_ENERGY:</a>
<a name="ln3518">        return TILEG_ABILITY_SIF_MUNA_CHANNEL;</a>
<a name="ln3519">    case ABIL_SIF_MUNA_FORGET_SPELL:</a>
<a name="ln3520">        return TILEG_ABILITY_SIF_MUNA_AMNESIA;</a>
<a name="ln3521">    case ABIL_SIF_MUNA_DIVINE_EXEGESIS:</a>
<a name="ln3522">        return TILEG_ABILITY_SIF_MUNA_EXEGESIS;</a>
<a name="ln3523">    // Trog</a>
<a name="ln3524">    case ABIL_TROG_BERSERK:</a>
<a name="ln3525">        return TILEG_ABILITY_TROG_BERSERK;</a>
<a name="ln3526">    case ABIL_TROG_REGEN_MR:</a>
<a name="ln3527">        return TILEG_ABILITY_TROG_HAND;</a>
<a name="ln3528">    case ABIL_TROG_BROTHERS_IN_ARMS:</a>
<a name="ln3529">        return TILEG_ABILITY_TROG_BROTHERS_IN_ARMS;</a>
<a name="ln3530">    // Elyvilon</a>
<a name="ln3531">    case ABIL_ELYVILON_LIFESAVING:</a>
<a name="ln3532">        return TILEG_ABILITY_ELYVILON_DIVINE_PROTECTION;</a>
<a name="ln3533">    case ABIL_ELYVILON_LESSER_HEALING:</a>
<a name="ln3534">        return TILEG_ABILITY_ELYVILON_LESSER_HEALING;</a>
<a name="ln3535">    case ABIL_ELYVILON_PURIFICATION:</a>
<a name="ln3536">        return TILEG_ABILITY_ELYVILON_PURIFICATION;</a>
<a name="ln3537">    case ABIL_ELYVILON_GREATER_HEALING:</a>
<a name="ln3538">        return TILEG_ABILITY_ELYVILON_GREATER_HEALING;</a>
<a name="ln3539">    case ABIL_ELYVILON_HEAL_OTHER:</a>
<a name="ln3540">        return TILEG_ABILITY_ELYVILON_HEAL_OTHER;</a>
<a name="ln3541">    case ABIL_ELYVILON_DIVINE_VIGOUR:</a>
<a name="ln3542">        return TILEG_ABILITY_ELYVILON_DIVINE_VIGOUR;</a>
<a name="ln3543">    // Lugonu</a>
<a name="ln3544">    case ABIL_LUGONU_ABYSS_EXIT:</a>
<a name="ln3545">        return TILEG_ABILITY_LUGONU_EXIT_ABYSS;</a>
<a name="ln3546">    case ABIL_LUGONU_BEND_SPACE:</a>
<a name="ln3547">        return TILEG_ABILITY_LUGONU_BEND_SPACE;</a>
<a name="ln3548">    case ABIL_LUGONU_BANISH:</a>
<a name="ln3549">        return TILEG_ABILITY_LUGONU_BANISH;</a>
<a name="ln3550">    case ABIL_LUGONU_CORRUPT:</a>
<a name="ln3551">        return TILEG_ABILITY_LUGONU_CORRUPT;</a>
<a name="ln3552">    case ABIL_LUGONU_ABYSS_ENTER:</a>
<a name="ln3553">        return TILEG_ABILITY_LUGONU_ENTER_ABYSS;</a>
<a name="ln3554">    case ABIL_LUGONU_BLESS_WEAPON:</a>
<a name="ln3555">        return TILEG_ABILITY_LUGONU_BLESS_WEAPON;</a>
<a name="ln3556">    // Nemelex</a>
<a name="ln3557">    case ABIL_NEMELEX_TRIPLE_DRAW:</a>
<a name="ln3558">        return TILEG_ABILITY_NEMELEX_TRIPLE_DRAW;</a>
<a name="ln3559">    case ABIL_NEMELEX_DEAL_FOUR:</a>
<a name="ln3560">        return TILEG_ABILITY_NEMELEX_DEAL_FOUR;</a>
<a name="ln3561">    case ABIL_NEMELEX_STACK_FIVE:</a>
<a name="ln3562">        return TILEG_ABILITY_NEMELEX_STACK_FIVE;</a>
<a name="ln3563">    case ABIL_NEMELEX_DRAW_ESCAPE:</a>
<a name="ln3564">        return TILEG_ABILITY_NEMELEX_DRAW_ESCAPE;</a>
<a name="ln3565">    case ABIL_NEMELEX_DRAW_DESTRUCTION:</a>
<a name="ln3566">        return TILEG_ABILITY_NEMELEX_DRAW_DESTRUCTION;</a>
<a name="ln3567">    case ABIL_NEMELEX_DRAW_SUMMONING:</a>
<a name="ln3568">        return TILEG_ABILITY_NEMELEX_DRAW_SUMMONING;</a>
<a name="ln3569">    case ABIL_NEMELEX_DRAW_STACK:</a>
<a name="ln3570">        return TILEG_ABILITY_NEMELEX_DRAW_STACK;</a>
<a name="ln3571">    // Beogh</a>
<a name="ln3572">    case ABIL_BEOGH_GIFT_ITEM:</a>
<a name="ln3573">        return TILEG_ABILITY_BEOGH_GIFT_ITEM;</a>
<a name="ln3574">    case ABIL_BEOGH_SMITING:</a>
<a name="ln3575">        return TILEG_ABILITY_BEOGH_SMITE;</a>
<a name="ln3576">    case ABIL_BEOGH_RECALL_ORCISH_FOLLOWERS:</a>
<a name="ln3577">        return TILEG_ABILITY_BEOGH_RECALL;</a>
<a name="ln3578">    case ABIL_CONVERT_TO_BEOGH:</a>
<a name="ln3579">        return TILEG_ABILITY_CONVERT_TO_BEOGH;</a>
<a name="ln3580">    case ABIL_BEOGH_RESURRECTION:</a>
<a name="ln3581">        return TILEG_ABILITY_BEOGH_RESURRECTION;</a>
<a name="ln3582">    // Jiyva</a>
<a name="ln3583">    case ABIL_JIYVA_CALL_JELLY:</a>
<a name="ln3584">        return TILEG_ABILITY_JIYVA_REQUEST_JELLY;</a>
<a name="ln3585">    case ABIL_JIYVA_SLIMIFY:</a>
<a name="ln3586">        return TILEG_ABILITY_JIYVA_SLIMIFY;</a>
<a name="ln3587">    case ABIL_JIYVA_CURE_BAD_MUTATION:</a>
<a name="ln3588">        return TILEG_ABILITY_JIYVA_CURE_BAD_MUTATIONS;</a>
<a name="ln3589">    // Fedhas</a>
<a name="ln3590">    case ABIL_FEDHAS_WALL_OF_BRIARS:</a>
<a name="ln3591">        return TILEG_ABILITY_FEDHAS_WALL_OF_BRIARS;</a>
<a name="ln3592">    case ABIL_FEDHAS_GROW_BALLISTOMYCETE:</a>
<a name="ln3593">        return TILEG_ABILITY_FEDHAS_GROW_BALLISTOMYCETE;</a>
<a name="ln3594">    case ABIL_FEDHAS_OVERGROW:</a>
<a name="ln3595">        return TILEG_ABILITY_FEDHAS_OVERGROW;</a>
<a name="ln3596">    case ABIL_FEDHAS_GROW_OKLOB:</a>
<a name="ln3597">        return TILEG_ABILITY_FEDHAS_GROW_OKLOB;</a>
<a name="ln3598">    // Cheibriados</a>
<a name="ln3599">    case ABIL_CHEIBRIADOS_TIME_STEP:</a>
<a name="ln3600">        return TILEG_ABILITY_CHEIBRIADOS_TIME_STEP;</a>
<a name="ln3601">    case ABIL_CHEIBRIADOS_TIME_BEND:</a>
<a name="ln3602">        return TILEG_ABILITY_CHEIBRIADOS_BEND_TIME;</a>
<a name="ln3603">    case ABIL_CHEIBRIADOS_SLOUCH:</a>
<a name="ln3604">        return TILEG_ABILITY_CHEIBRIADOS_SLOUCH;</a>
<a name="ln3605">    case ABIL_CHEIBRIADOS_DISTORTION:</a>
<a name="ln3606">        return TILEG_ABILITY_CHEIBRIADOS_TEMPORAL_DISTORTION;</a>
<a name="ln3607">    // Ashenzari</a>
<a name="ln3608">    case ABIL_ASHENZARI_CURSE:</a>
<a name="ln3609">        return TILEG_ABILITY_ASHENZARI_CURSE;</a>
<a name="ln3610">    case ABIL_ASHENZARI_SCRYING:</a>
<a name="ln3611">        return TILEG_ABILITY_ASHENZARI_SCRY;</a>
<a name="ln3612">    case ABIL_ASHENZARI_TRANSFER_KNOWLEDGE:</a>
<a name="ln3613">        return TILEG_ABILITY_ASHENZARI_TRANSFER_KNOWLEDGE;</a>
<a name="ln3614">    case ABIL_ASHENZARI_END_TRANSFER:</a>
<a name="ln3615">        return TILEG_ABILITY_ASHENZARI_TRANSFER_KNOWLEDGE_END;</a>
<a name="ln3616">    // Dithmenos</a>
<a name="ln3617">    case ABIL_DITHMENOS_SHADOW_STEP:</a>
<a name="ln3618">        return TILEG_ABILITY_DITHMENOS_SHADOW_STEP;</a>
<a name="ln3619">    case ABIL_DITHMENOS_SHADOW_FORM:</a>
<a name="ln3620">        return TILEG_ABILITY_DITHMENOS_SHADOW_FORM;</a>
<a name="ln3621">    // Gozag</a>
<a name="ln3622">    case ABIL_GOZAG_POTION_PETITION:</a>
<a name="ln3623">        return TILEG_ABILITY_GOZAG_POTION_PETITION;</a>
<a name="ln3624">    case ABIL_GOZAG_CALL_MERCHANT:</a>
<a name="ln3625">        return TILEG_ABILITY_GOZAG_CALL_MERCHANT;</a>
<a name="ln3626">    case ABIL_GOZAG_BRIBE_BRANCH:</a>
<a name="ln3627">        return TILEG_ABILITY_GOZAG_BRIBE_BRANCH;</a>
<a name="ln3628">    // Qazlal</a>
<a name="ln3629">    case ABIL_QAZLAL_UPHEAVAL:</a>
<a name="ln3630">        return TILEG_ABILITY_QAZLAL_UPHEAVAL;</a>
<a name="ln3631">    case ABIL_QAZLAL_ELEMENTAL_FORCE:</a>
<a name="ln3632">        return TILEG_ABILITY_QAZLAL_ELEMENTAL_FORCE;</a>
<a name="ln3633">    case ABIL_QAZLAL_DISASTER_AREA:</a>
<a name="ln3634">        return TILEG_ABILITY_QAZLAL_DISASTER_AREA;</a>
<a name="ln3635">    // Ru</a>
<a name="ln3636">    case ABIL_RU_DRAW_OUT_POWER:</a>
<a name="ln3637">        return TILEG_ABILITY_RU_DRAW_OUT_POWER;</a>
<a name="ln3638">    case ABIL_RU_POWER_LEAP:</a>
<a name="ln3639">        return TILEG_ABILITY_RU_POWER_LEAP;</a>
<a name="ln3640">    case ABIL_RU_APOCALYPSE:</a>
<a name="ln3641">        return TILEG_ABILITY_RU_APOCALYPSE;</a>
<a name="ln3642"> </a>
<a name="ln3643">    case ABIL_RU_SACRIFICE_PURITY:</a>
<a name="ln3644">        return TILEG_ABILITY_RU_SACRIFICE_PURITY;</a>
<a name="ln3645">    case ABIL_RU_SACRIFICE_WORDS:</a>
<a name="ln3646">        return TILEG_ABILITY_RU_SACRIFICE_WORDS;</a>
<a name="ln3647">    case ABIL_RU_SACRIFICE_DRINK:</a>
<a name="ln3648">        return TILEG_ABILITY_RU_SACRIFICE_DRINK;</a>
<a name="ln3649">    case ABIL_RU_SACRIFICE_ESSENCE:</a>
<a name="ln3650">        return TILEG_ABILITY_RU_SACRIFICE_ESSENCE;</a>
<a name="ln3651">    case ABIL_RU_SACRIFICE_HEALTH:</a>
<a name="ln3652">        return TILEG_ABILITY_RU_SACRIFICE_HEALTH;</a>
<a name="ln3653">    case ABIL_RU_SACRIFICE_STEALTH:</a>
<a name="ln3654">        return TILEG_ABILITY_RU_SACRIFICE_STEALTH;</a>
<a name="ln3655">    case ABIL_RU_SACRIFICE_ARTIFICE:</a>
<a name="ln3656">        return TILEG_ABILITY_RU_SACRIFICE_ARTIFICE;</a>
<a name="ln3657">    case ABIL_RU_SACRIFICE_LOVE:</a>
<a name="ln3658">        return TILEG_ABILITY_RU_SACRIFICE_LOVE;</a>
<a name="ln3659">    case ABIL_RU_SACRIFICE_COURAGE:</a>
<a name="ln3660">        return TILEG_ABILITY_RU_SACRIFICE_COURAGE;</a>
<a name="ln3661">    case ABIL_RU_SACRIFICE_ARCANA:</a>
<a name="ln3662">        return TILEG_ABILITY_RU_SACRIFICE_ARCANA;</a>
<a name="ln3663">    case ABIL_RU_SACRIFICE_NIMBLENESS:</a>
<a name="ln3664">        return TILEG_ABILITY_RU_SACRIFICE_NIMBLENESS;</a>
<a name="ln3665">    case ABIL_RU_SACRIFICE_DURABILITY:</a>
<a name="ln3666">        return TILEG_ABILITY_RU_SACRIFICE_DURABILITY;</a>
<a name="ln3667">    case ABIL_RU_SACRIFICE_HAND:</a>
<a name="ln3668">        return TILEG_ABILITY_RU_SACRIFICE_HAND;</a>
<a name="ln3669">    case ABIL_RU_SACRIFICE_EXPERIENCE:</a>
<a name="ln3670">        return TILEG_ABILITY_RU_SACRIFICE_EXPERIENCE;</a>
<a name="ln3671">    case ABIL_RU_SACRIFICE_SKILL:</a>
<a name="ln3672">        return TILEG_ABILITY_RU_SACRIFICE_SKILL;</a>
<a name="ln3673">    case ABIL_RU_SACRIFICE_EYE:</a>
<a name="ln3674">        return TILEG_ABILITY_RU_SACRIFICE_EYE;</a>
<a name="ln3675">    case ABIL_RU_SACRIFICE_RESISTANCE:</a>
<a name="ln3676">        return TILEG_ABILITY_RU_SACRIFICE_RESISTANCE;</a>
<a name="ln3677">    case ABIL_RU_REJECT_SACRIFICES:</a>
<a name="ln3678">        return TILEG_ABILITY_RU_REJECT_SACRIFICES;</a>
<a name="ln3679">    // Pakellas</a>
<a name="ln3680">#if TAG_MAJOR_VERSION == 34</a>
<a name="ln3681">    case ABIL_PAKELLAS_DEVICE_SURGE:</a>
<a name="ln3682">        return TILEG_ABILITY_PAKELLAS_DEVICE_SURGE;</a>
<a name="ln3683">    case ABIL_PAKELLAS_QUICK_CHARGE:</a>
<a name="ln3684">        return TILEG_ABILITY_PAKELLAS_QUICK_CHARGE;</a>
<a name="ln3685">#endif</a>
<a name="ln3686">    // Hepliaklqana</a>
<a name="ln3687">    case ABIL_HEPLIAKLQANA_RECALL:</a>
<a name="ln3688">        return TILEG_ABILITY_HEP_RECALL;</a>
<a name="ln3689">    case ABIL_HEPLIAKLQANA_IDEALISE:</a>
<a name="ln3690">        return TILEG_ABILITY_HEP_IDEALISE;</a>
<a name="ln3691">    case ABIL_HEPLIAKLQANA_TRANSFERENCE:</a>
<a name="ln3692">        return TILEG_ABILITY_HEP_TRANSFERENCE;</a>
<a name="ln3693">    case ABIL_HEPLIAKLQANA_IDENTITY:</a>
<a name="ln3694">        return TILEG_ABILITY_HEP_IDENTITY;</a>
<a name="ln3695">    case ABIL_HEPLIAKLQANA_TYPE_KNIGHT:</a>
<a name="ln3696">        return TILEG_ABILITY_HEP_KNIGHT;</a>
<a name="ln3697">    case ABIL_HEPLIAKLQANA_TYPE_BATTLEMAGE:</a>
<a name="ln3698">        return TILEG_ABILITY_HEP_BATTLEMAGE;</a>
<a name="ln3699">    case ABIL_HEPLIAKLQANA_TYPE_HEXER:</a>
<a name="ln3700">        return TILEG_ABILITY_HEP_HEXER;</a>
<a name="ln3701">    // usk</a>
<a name="ln3702">   case ABIL_USKAYAW_STOMP:</a>
<a name="ln3703">        return TILEG_ABILITY_USKAYAW_STOMP;</a>
<a name="ln3704">   case ABIL_USKAYAW_LINE_PASS:</a>
<a name="ln3705">        return TILEG_ABILITY_USKAYAW_LINE_PASS;</a>
<a name="ln3706">   case ABIL_USKAYAW_GRAND_FINALE:</a>
<a name="ln3707">        return TILEG_ABILITY_USKAYAW_GRAND_FINALE;</a>
<a name="ln3708">     // Wu Jian</a>
<a name="ln3709">    case ABIL_WU_JIAN_WALLJUMP:</a>
<a name="ln3710">        return TILEG_ABILITY_WU_JIAN_WALL_JUMP;</a>
<a name="ln3711">    case ABIL_WU_JIAN_SERPENTS_LASH:</a>
<a name="ln3712">        return TILEG_ABILITY_WU_JIAN_SERPENTS_LASH;</a>
<a name="ln3713">    case ABIL_WU_JIAN_HEAVENLY_STORM:</a>
<a name="ln3714">        return TILEG_ABILITY_WU_JIAN_HEAVENLY_STORM;</a>
<a name="ln3715"> </a>
<a name="ln3716">    // General divine (pseudo) abilities.</a>
<a name="ln3717">    case ABIL_RENOUNCE_RELIGION:</a>
<a name="ln3718">        return TILEG_ABILITY_RENOUNCE_RELIGION;</a>
<a name="ln3719"> </a>
<a name="ln3720">    default:</a>
<a name="ln3721">        return TILEG_ERROR;</a>
<a name="ln3722">    }</a>
<a name="ln3723">}</a>
<a name="ln3724"> </a>
<a name="ln3725">tileidx_t tileidx_branch(const branch_type br)</a>
<a name="ln3726">{</a>
<a name="ln3727">    switch (br)</a>
<a name="ln3728">    {</a>
<a name="ln3729">    case BRANCH_DUNGEON:</a>
<a name="ln3730">        return TILE_DNGN_EXIT_DUNGEON;</a>
<a name="ln3731">    case BRANCH_TEMPLE:</a>
<a name="ln3732">        return TILE_DNGN_ENTER_TEMPLE;</a>
<a name="ln3733">    case BRANCH_ORC:</a>
<a name="ln3734">        return TILE_DNGN_ENTER_ORC;</a>
<a name="ln3735">    case BRANCH_ELF:</a>
<a name="ln3736">        return TILE_DNGN_ENTER_ELF;</a>
<a name="ln3737">    case BRANCH_LAIR:</a>
<a name="ln3738">        return TILE_DNGN_ENTER_LAIR;</a>
<a name="ln3739">    case BRANCH_SWAMP:</a>
<a name="ln3740">        return TILE_DNGN_ENTER_SWAMP;</a>
<a name="ln3741">    case BRANCH_SHOALS:</a>
<a name="ln3742">        return TILE_DNGN_ENTER_SHOALS;</a>
<a name="ln3743">    case BRANCH_SNAKE:</a>
<a name="ln3744">        return TILE_DNGN_ENTER_SNAKE;</a>
<a name="ln3745">    case BRANCH_SPIDER:</a>
<a name="ln3746">        return TILE_DNGN_ENTER_SPIDER;</a>
<a name="ln3747">    case BRANCH_SLIME:</a>
<a name="ln3748">        return TILE_DNGN_ENTER_SLIME;</a>
<a name="ln3749">    case BRANCH_VAULTS:</a>
<a name="ln3750">        return TILE_DNGN_ENTER_VAULTS_OPEN;</a>
<a name="ln3751">    case BRANCH_CRYPT:</a>
<a name="ln3752">        return TILE_DNGN_ENTER_CRYPT;</a>
<a name="ln3753">    case BRANCH_TOMB:</a>
<a name="ln3754">        return TILE_DNGN_ENTER_TOMB;</a>
<a name="ln3755">    case BRANCH_DEPTHS:</a>
<a name="ln3756">        return TILE_DNGN_ENTER_DEPTHS;</a>
<a name="ln3757">    case BRANCH_VESTIBULE:</a>
<a name="ln3758">        return TILE_DNGN_ENTER_HELL;</a>
<a name="ln3759">    case BRANCH_DIS:</a>
<a name="ln3760">        return TILE_DNGN_ENTER_DIS;</a>
<a name="ln3761">    case BRANCH_GEHENNA:</a>
<a name="ln3762">        return TILE_DNGN_ENTER_GEHENNA;</a>
<a name="ln3763">    case BRANCH_COCYTUS:</a>
<a name="ln3764">        return TILE_DNGN_ENTER_COCYTUS;</a>
<a name="ln3765">    case BRANCH_TARTARUS:</a>
<a name="ln3766">        return TILE_DNGN_ENTER_TARTARUS;</a>
<a name="ln3767">    case BRANCH_ZOT:</a>
<a name="ln3768">        return TILE_DNGN_ENTER_ZOT_OPEN;</a>
<a name="ln3769">    case BRANCH_ABYSS:</a>
<a name="ln3770">        return TILE_DNGN_ENTER_ABYSS;</a>
<a name="ln3771">    case BRANCH_PANDEMONIUM:</a>
<a name="ln3772">        return TILE_DNGN_ENTER_PANDEMONIUM;</a>
<a name="ln3773">    case BRANCH_ZIGGURAT:</a>
<a name="ln3774">        return TILE_DNGN_PORTAL_ZIGGURAT;</a>
<a name="ln3775">    case BRANCH_GAUNTLET:</a>
<a name="ln3776">        return TILE_DNGN_PORTAL_GAUNTLET;</a>
<a name="ln3777">    case BRANCH_BAZAAR:</a>
<a name="ln3778">        return TILE_DNGN_PORTAL_BAZAAR;</a>
<a name="ln3779">    case BRANCH_TROVE:</a>
<a name="ln3780">        return TILE_DNGN_PORTAL_TROVE;</a>
<a name="ln3781">    case BRANCH_SEWER:</a>
<a name="ln3782">        return TILE_DNGN_PORTAL_SEWER;</a>
<a name="ln3783">    case BRANCH_OSSUARY:</a>
<a name="ln3784">        return TILE_DNGN_PORTAL_OSSUARY;</a>
<a name="ln3785">    case BRANCH_BAILEY:</a>
<a name="ln3786">        return TILE_DNGN_PORTAL_BAILEY;</a>
<a name="ln3787">    case BRANCH_ICE_CAVE:</a>
<a name="ln3788">        return TILE_DNGN_PORTAL_ICE_CAVE;</a>
<a name="ln3789">    case BRANCH_VOLCANO:</a>
<a name="ln3790">        return TILE_DNGN_PORTAL_VOLCANO;</a>
<a name="ln3791">    case BRANCH_WIZLAB:</a>
<a name="ln3792">        return TILE_DNGN_PORTAL_WIZARD_LAB_7; /* I like this colour */</a>
<a name="ln3793">    case BRANCH_DESOLATION:</a>
<a name="ln3794">        return TILE_DNGN_PORTAL_DESOLATION;</a>
<a name="ln3795"> </a>
<a name="ln3796">    default:</a>
<a name="ln3797">        return TILEG_ERROR;</a>
<a name="ln3798">    }</a>
<a name="ln3799">}</a>
<a name="ln3800"> </a>
<a name="ln3801">static tileidx_t _tileidx_player_job_base(const job_type job)</a>
<a name="ln3802">{</a>
<a name="ln3803">    switch (job)</a>
<a name="ln3804">    {</a>
<a name="ln3805">        case JOB_FIGHTER:</a>
<a name="ln3806">            return TILEG_JOB_FIGHTER;</a>
<a name="ln3807">        case JOB_WIZARD:</a>
<a name="ln3808">            return TILEG_JOB_WIZARD;</a>
<a name="ln3809">        case JOB_GLADIATOR:</a>
<a name="ln3810">            return TILEG_JOB_GLADIATOR;</a>
<a name="ln3811">        case JOB_NECROMANCER:</a>
<a name="ln3812">            return TILEG_JOB_NECROMANCER;</a>
<a name="ln3813">        case JOB_ASSASSIN:</a>
<a name="ln3814">            return TILEG_JOB_ASSASSIN;</a>
<a name="ln3815">        case JOB_BERSERKER:</a>
<a name="ln3816">            return TILEG_JOB_BERSERKER;</a>
<a name="ln3817">        case JOB_HUNTER:</a>
<a name="ln3818">            return TILEG_JOB_HUNTER;</a>
<a name="ln3819">        case JOB_CONJURER:</a>
<a name="ln3820">            return TILEG_JOB_CONJURER;</a>
<a name="ln3821">        case JOB_ENCHANTER:</a>
<a name="ln3822">            return TILEG_JOB_ENCHANTER;</a>
<a name="ln3823">        case JOB_FIRE_ELEMENTALIST:</a>
<a name="ln3824">            return TILEG_JOB_FIRE_ELEMENTALIST;</a>
<a name="ln3825">        case JOB_ICE_ELEMENTALIST:</a>
<a name="ln3826">            return TILEG_JOB_ICE_ELEMENTALIST;</a>
<a name="ln3827">        case JOB_SUMMONER:</a>
<a name="ln3828">            return TILEG_JOB_SUMMONER;</a>
<a name="ln3829">        case JOB_AIR_ELEMENTALIST:</a>
<a name="ln3830">            return TILEG_JOB_AIR_ELEMENTALIST;</a>
<a name="ln3831">        case JOB_EARTH_ELEMENTALIST:</a>
<a name="ln3832">            return TILEG_JOB_EARTH_ELEMENTALIST;</a>
<a name="ln3833">        case JOB_SKALD:</a>
<a name="ln3834">            return TILEG_JOB_SKALD;</a>
<a name="ln3835">        case JOB_VENOM_MAGE:</a>
<a name="ln3836">            return TILEG_JOB_VENOM_MAGE;</a>
<a name="ln3837">        case JOB_CHAOS_KNIGHT:</a>
<a name="ln3838">            return TILEG_JOB_CHAOS_KNIGHT;</a>
<a name="ln3839">        case JOB_TRANSMUTER:</a>
<a name="ln3840">            return TILEG_JOB_TRANSMUTER;</a>
<a name="ln3841">        case JOB_MONK:</a>
<a name="ln3842">            return TILEG_JOB_MONK;</a>
<a name="ln3843">        case JOB_WARPER:</a>
<a name="ln3844">            return TILEG_JOB_WARPER;</a>
<a name="ln3845">        case JOB_WANDERER:</a>
<a name="ln3846">            return TILEG_JOB_WANDERER;</a>
<a name="ln3847">        case JOB_ARTIFICER:</a>
<a name="ln3848">            return TILEG_JOB_ARTIFICER;</a>
<a name="ln3849">        case JOB_ARCANE_MARKSMAN:</a>
<a name="ln3850">            return TILEG_JOB_ARCANE_MARKSMAN;</a>
<a name="ln3851">        case JOB_ABYSSAL_KNIGHT:</a>
<a name="ln3852">            return TILEG_JOB_ABYSSAL_KNIGHT;</a>
<a name="ln3853">        default:</a>
<a name="ln3854">            return TILEG_ERROR;</a>
<a name="ln3855">    }</a>
<a name="ln3856">}</a>
<a name="ln3857"> </a>
<a name="ln3858">static tileidx_t _tileidx_player_species_base(const species_type species)</a>
<a name="ln3859">{</a>
<a name="ln3860">    switch (species)</a>
<a name="ln3861">    {</a>
<a name="ln3862">        case SP_HUMAN:</a>
<a name="ln3863">            return TILEG_SP_HUMAN;</a>
<a name="ln3864">        case SP_DEEP_ELF:</a>
<a name="ln3865">            return TILEG_SP_DEEP_ELF;</a>
<a name="ln3866">        case SP_HALFLING:</a>
<a name="ln3867">            return TILEG_SP_HALFLING;</a>
<a name="ln3868">        case SP_HILL_ORC:</a>
<a name="ln3869">            return TILEG_SP_HILL_ORC;</a>
<a name="ln3870">        case SP_KOBOLD:</a>
<a name="ln3871">            return TILEG_SP_KOBOLD;</a>
<a name="ln3872">        case SP_MUMMY:</a>
<a name="ln3873">            return TILEG_SP_MUMMY;</a>
<a name="ln3874">        case SP_NAGA:</a>
<a name="ln3875">            return TILEG_SP_NAGA;</a>
<a name="ln3876">        case SP_OGRE:</a>
<a name="ln3877">            return TILEG_SP_OGRE;</a>
<a name="ln3878">        case SP_TROLL:</a>
<a name="ln3879">            return TILEG_SP_TROLL;</a>
<a name="ln3880">        case SP_BASE_DRACONIAN:</a>
<a name="ln3881">            return TILEG_SP_DRACONIAN;</a>
<a name="ln3882">        case SP_CENTAUR:</a>
<a name="ln3883">            return TILEG_SP_CENTAUR;</a>
<a name="ln3884">        case SP_DEMIGOD:</a>
<a name="ln3885">            return TILEG_SP_DEMIGOD;</a>
<a name="ln3886">        case SP_SPRIGGAN:</a>
<a name="ln3887">            return TILEG_SP_SPRIGGAN;</a>
<a name="ln3888">        case SP_MINOTAUR:</a>
<a name="ln3889">            return TILEG_SP_MINOTAUR;</a>
<a name="ln3890">        case SP_DEMONSPAWN:</a>
<a name="ln3891">            return TILEG_SP_DEMONSPAWN;</a>
<a name="ln3892">        case SP_GHOUL:</a>
<a name="ln3893">            return TILEG_SP_GHOUL;</a>
<a name="ln3894">        case SP_TENGU:</a>
<a name="ln3895">            return TILEG_SP_TENGU;</a>
<a name="ln3896">        case SP_MERFOLK:</a>
<a name="ln3897">            return TILEG_SP_MERFOLK;</a>
<a name="ln3898">        case SP_VAMPIRE:</a>
<a name="ln3899">            return TILEG_SP_VAMPIRE;</a>
<a name="ln3900">        case SP_DEEP_DWARF:</a>
<a name="ln3901">            return TILEG_SP_DEEP_DWARF;</a>
<a name="ln3902">        case SP_FELID:</a>
<a name="ln3903">            return TILEG_SP_FELID;</a>
<a name="ln3904">        case SP_OCTOPODE:</a>
<a name="ln3905">            return TILEG_SP_OCTOPODE;</a>
<a name="ln3906">        case SP_GARGOYLE:</a>
<a name="ln3907">            return TILEG_SP_GARGOYLE;</a>
<a name="ln3908">        case SP_FORMICID:</a>
<a name="ln3909">            return TILEG_SP_FORMICID;</a>
<a name="ln3910">        case SP_VINE_STALKER:</a>
<a name="ln3911">            return TILEG_SP_VINE_STALKER;</a>
<a name="ln3912">        case SP_BARACHI:</a>
<a name="ln3913">            return TILEG_SP_BARACHI;</a>
<a name="ln3914">        case SP_GNOLL:</a>
<a name="ln3915">            return TILEG_SP_GNOLL;</a>
<a name="ln3916">        default:</a>
<a name="ln3917">            return TILEP_ERROR;</a>
<a name="ln3918">    }</a>
<a name="ln3919">}</a>
<a name="ln3920"> </a>
<a name="ln3921">tileidx_t tileidx_player_species(const species_type species, bool recommended)</a>
<a name="ln3922">{</a>
<a name="ln3923">    tileidx_t off = recommended ? -TILEG_LAST_SPECIES+TILEG_LAST_RECOMMENDED_SPECIES: 0;</a>
<a name="ln3924">    return _tileidx_player_species_base(species) + off;</a>
<a name="ln3925">}</a>
<a name="ln3926"> </a>
<a name="ln3927">tileidx_t tileidx_player_job(const job_type job, bool recommended)</a>
<a name="ln3928">{</a>
<a name="ln3929">    tileidx_t off = recommended ? -TILEG_LAST_JOB+TILEG_LAST_RECOMMENDED_JOB: 0;</a>
<a name="ln3930">    return _tileidx_player_job_base(job) + off;</a>
<a name="ln3931">}</a>
<a name="ln3932"> </a>
<a name="ln3933">tileidx_t tileidx_known_brand(const item_def &amp;item)</a>
<a name="ln3934">{</a>
<a name="ln3935">    if (!item_type_known(item))</a>
<a name="ln3936">        return 0;</a>
<a name="ln3937"> </a>
<a name="ln3938">    if (item.base_type == OBJ_WEAPONS)</a>
<a name="ln3939">    {</a>
<a name="ln3940">        const int brand = get_weapon_brand(item);</a>
<a name="ln3941">        if (brand != SPWPN_NORMAL)</a>
<a name="ln3942">            return TILE_BRAND_WEP_FIRST + get_weapon_brand(item) - 1;</a>
<a name="ln3943">    }</a>
<a name="ln3944">    else if (item.base_type == OBJ_ARMOUR)</a>
<a name="ln3945">    {</a>
<a name="ln3946">        const int brand = get_armour_ego_type(item);</a>
<a name="ln3947">        if (brand != SPARM_NORMAL)</a>
<a name="ln3948">            return TILE_BRAND_ARM_FIRST + get_armour_ego_type(item) - 1;</a>
<a name="ln3949">    }</a>
<a name="ln3950">    else if (item.base_type == OBJ_MISSILES)</a>
<a name="ln3951">    {</a>
<a name="ln3952">        switch (get_ammo_brand(item))</a>
<a name="ln3953">        {</a>
<a name="ln3954">#if TAG_MAJOR_VERSION == 34</a>
<a name="ln3955">        case SPMSL_FLAME:</a>
<a name="ln3956">            return TILE_BRAND_FLAME;</a>
<a name="ln3957">        case SPMSL_FROST:</a>
<a name="ln3958">            return TILE_BRAND_FROST;</a>
<a name="ln3959">#endif</a>
<a name="ln3960">        case SPMSL_POISONED:</a>
<a name="ln3961">            return TILE_BRAND_POISONED;</a>
<a name="ln3962">        case SPMSL_CURARE:</a>
<a name="ln3963">            return TILE_BRAND_CURARE;</a>
<a name="ln3964">#if TAG_MAJOR_VERSION == 34</a>
<a name="ln3965">        case SPMSL_RETURNING:</a>
<a name="ln3966">            return TILE_BRAND_RETURNING;</a>
<a name="ln3967">#endif</a>
<a name="ln3968">        case SPMSL_CHAOS:</a>
<a name="ln3969">            return TILE_BRAND_CHAOS;</a>
<a name="ln3970">#if TAG_MAJOR_VERSION == 34</a>
<a name="ln3971">        case SPMSL_PENETRATION:</a>
<a name="ln3972">            return TILE_BRAND_PENETRATION;</a>
<a name="ln3973">#endif</a>
<a name="ln3974">        case SPMSL_DISPERSAL:</a>
<a name="ln3975">            return TILE_BRAND_DISPERSAL;</a>
<a name="ln3976">        case SPMSL_EXPLODING:</a>
<a name="ln3977">            return TILE_BRAND_EXPLOSION;</a>
<a name="ln3978">#if TAG_MAJOR_VERSION == 34</a>
<a name="ln3979">        case SPMSL_CONFUSION:</a>
<a name="ln3980">            return TILE_BRAND_CONFUSION;</a>
<a name="ln3981">        case SPMSL_PARALYSIS:</a>
<a name="ln3982">            return TILE_BRAND_PARALYSIS;</a>
<a name="ln3983">        case SPMSL_SLOW:</a>
<a name="ln3984">            return TILE_BRAND_SLOWING;</a>
<a name="ln3985">        case SPMSL_SICKNESS:</a>
<a name="ln3986">            return TILE_BRAND_SICKNESS;</a>
<a name="ln3987">        case SPMSL_SLEEP:</a>
<a name="ln3988">            return TILE_BRAND_SLEEP;</a>
<a name="ln3989">#endif</a>
<a name="ln3990">        case SPMSL_FRENZY:</a>
<a name="ln3991">            return TILE_BRAND_FRENZY;</a>
<a name="ln3992">        case SPMSL_BLINDING:</a>
<a name="ln3993">            return TILE_BRAND_BLINDING;</a>
<a name="ln3994">        default:</a>
<a name="ln3995">            break;</a>
<a name="ln3996">        }</a>
<a name="ln3997">    }</a>
<a name="ln3998">#if TAG_MAJOR_VERSION == 34</a>
<a name="ln3999">    else if (item.base_type == OBJ_RODS)</a>
<a name="ln4000">    {</a>
<a name="ln4001">        // Technically not a brand, but still handled here</a>
<a name="ln4002">        return TILE_ROD_ID_FIRST + item.sub_type;</a>
<a name="ln4003">    }</a>
<a name="ln4004">#endif</a>
<a name="ln4005">    return 0;</a>
<a name="ln4006">}</a>
<a name="ln4007"> </a>
<a name="ln4008">tileidx_t tileidx_corpse_brand(const item_def &amp;item)</a>
<a name="ln4009">{</a>
<a name="ln4010">    if (item.base_type != OBJ_CORPSES || item.sub_type != CORPSE_BODY)</a>
<a name="ln4011">        return 0;</a>
<a name="ln4012"> </a>
<a name="ln4013">    // Harmful chunk effects &gt; religious rules &gt; reduced nutrition.</a>
<a name="ln4014">    if (is_noxious(item))</a>
<a name="ln4015">        return TILE_FOOD_ROTTING;</a>
<a name="ln4016"> </a>
<a name="ln4017">    if (is_forbidden_food(item))</a>
<a name="ln4018">        return TILE_FOOD_FORBIDDEN;</a>
<a name="ln4019"> </a>
<a name="ln4020">    return 0;</a>
<a name="ln4021">}</a>
<a name="ln4022"> </a>
<a name="ln4023">tileidx_t tileidx_unseen_flag(const coord_def &amp;gc)</a>
<a name="ln4024">{</a>
<a name="ln4025">    if (!map_bounds(gc))</a>
<a name="ln4026">        return TILE_FLAG_UNSEEN;</a>
<a name="ln4027">    else if (env.map_knowledge(gc).known()</a>
<a name="ln4028">                &amp;&amp; !env.map_knowledge(gc).seen()</a>
<a name="ln4029">             || env.map_knowledge(gc).detected_item()</a>
<a name="ln4030">             || env.map_knowledge(gc).detected_monster()</a>
<a name="ln4031">           )</a>
<a name="ln4032">    {</a>
<a name="ln4033">        return TILE_FLAG_MM_UNSEEN;</a>
<a name="ln4034">    }</a>
<a name="ln4035">    else</a>
<a name="ln4036">        return TILE_FLAG_UNSEEN;</a>
<a name="ln4037">}</a>
<a name="ln4038"> </a>
<a name="ln4039">int enchant_to_int(const item_def &amp;item)</a>
<a name="ln4040">{</a>
<a name="ln4041">    if (is_random_artefact(item))</a>
<a name="ln4042">        return 4;</a>
<a name="ln4043"> </a>
<a name="ln4044">    switch (item.flags &amp; ISFLAG_COSMETIC_MASK)</a>
<a name="ln4045">    {</a>
<a name="ln4046">        default:</a>
<a name="ln4047">            return 0;</a>
<a name="ln4048">        case ISFLAG_EMBROIDERED_SHINY:</a>
<a name="ln4049">            return 1;</a>
<a name="ln4050">        case ISFLAG_RUNED:</a>
<a name="ln4051">            return 2;</a>
<a name="ln4052">        case ISFLAG_GLOWING:</a>
<a name="ln4053">            return 3;</a>
<a name="ln4054">    }</a>
<a name="ln4055">}</a>
<a name="ln4056"> </a>
<a name="ln4057">tileidx_t tileidx_enchant_equ(const item_def &amp;item, tileidx_t tile, bool player)</a>
<a name="ln4058">{</a>
<a name="ln4059">    static const int etable[5][5] =</a>
<a name="ln4060">    {</a>
<a name="ln4061">      {0, 0, 0, 0, 0},  // all variants look the same</a>
<a name="ln4062">      {0, 1, 1, 1, 1},  // normal, ego/randart</a>
<a name="ln4063">      {0, 1, 1, 1, 2},  // normal, ego, randart</a>
<a name="ln4064">      {0, 1, 1, 2, 3},  // normal, ego (shiny/runed), ego (glowing), randart</a>
<a name="ln4065">      {0, 1, 2, 3, 4}   // normal, shiny, runed, glowing, randart</a>
<a name="ln4066">    };</a>
<a name="ln4067"> </a>
<a name="ln4068">    const int etype = enchant_to_int(item);</a>
<a name="ln4069"> </a>
<a name="ln4070">    // XXX: only helmets and robes have variants, but it would be nice</a>
<a name="ln4071">    // if this weren't hardcoded.</a>
<a name="ln4072">    if (tile == TILE_THELM_HELM)</a>
<a name="ln4073">    {</a>
<a name="ln4074">        switch (etype)</a>
<a name="ln4075">        {</a>
<a name="ln4076">            case 1:</a>
<a name="ln4077">            case 2:</a>
<a name="ln4078">            case 3:</a>
<a name="ln4079">                tile = _modrng(item.rnd, TILE_THELM_EGO_FIRST, TILE_THELM_EGO_LAST);</a>
<a name="ln4080">                break;</a>
<a name="ln4081">            case 4:</a>
<a name="ln4082">                tile = _modrng(item.rnd, TILE_THELM_ART_FIRST, TILE_THELM_ART_LAST);</a>
<a name="ln4083">                break;</a>
<a name="ln4084">            default:</a>
<a name="ln4085">                tile = _modrng(item.rnd, TILE_THELM_FIRST, TILE_THELM_LAST);</a>
<a name="ln4086">        }</a>
<a name="ln4087">        return tile;</a>
<a name="ln4088">    }</a>
<a name="ln4089"> </a>
<a name="ln4090">    if (tile == TILE_ARM_ROBE)</a>
<a name="ln4091">    {</a>
<a name="ln4092">        switch (etype)</a>
<a name="ln4093">        {</a>
<a name="ln4094">            case 1:</a>
<a name="ln4095">            case 2:</a>
<a name="ln4096">            case 3:</a>
<a name="ln4097">                tile = _modrng(item.rnd, TILE_ARM_ROBE_EGO_FIRST, TILE_ARM_ROBE_EGO_LAST);</a>
<a name="ln4098">                break;</a>
<a name="ln4099">            case 4:</a>
<a name="ln4100">                tile = _modrng(item.rnd, TILE_ARM_ROBE_ART_FIRST, TILE_ARM_ROBE_ART_LAST);</a>
<a name="ln4101">                break;</a>
<a name="ln4102">            default:</a>
<a name="ln4103">                tile = _modrng(item.rnd, TILE_ARM_ROBE_FIRST, TILE_ARM_ROBE_LAST);</a>
<a name="ln4104">        }</a>
<a name="ln4105">        return tile;</a>
<a name="ln4106">    }</a>
<a name="ln4107"> </a>
<a name="ln4108">    int idx;</a>
<a name="ln4109">    if (player)</a>
<a name="ln4110">        idx = tile_player_count(tile) - 1;</a>
<a name="ln4111">    else</a>
<a name="ln4112">        idx = tile_main_count(tile) - 1;</a>
<a name="ln4113">    ASSERT(idx &lt; 5);</a>
<a name="ln4114"> </a>
<a name="ln4115">    tile += etable[idx][etype];</a>
<a name="ln4116"> </a>
<a name="ln4117">    return tile;</a>
<a name="ln4118">}</a>
<a name="ln4119"> </a>
<a name="ln4120">string tile_debug_string(tileidx_t fg, tileidx_t bg, char prefix)</a>
<a name="ln4121">{</a>
<a name="ln4122">    tileidx_t fg_idx = fg &amp; TILE_FLAG_MASK;</a>
<a name="ln4123">    tileidx_t bg_idx = bg &amp; TILE_FLAG_MASK;</a>
<a name="ln4124"> </a>
<a name="ln4125">    string fg_name;</a>
<a name="ln4126">    if (fg_idx &lt; TILE_MAIN_MAX)</a>
<a name="ln4127">        fg_name = tile_main_name(fg_idx);</a>
<a name="ln4128">    else if (fg_idx &lt; TILEP_MCACHE_START)</a>
<a name="ln4129">        fg_name = (tile_player_name(fg_idx));</a>
<a name="ln4130">    else</a>
<a name="ln4131">    {</a>
<a name="ln4132">        fg_name = &quot;mc:&quot;;</a>
<a name="ln4133">        mcache_entry *entry = mcache.get(fg_idx);</a>
<a name="ln4134">        if (entry)</a>
<a name="ln4135">        {</a>
<a name="ln4136">            tile_draw_info dinfo[mcache_entry::MAX_INFO_COUNT];</a>
<a name="ln4137">            unsigned int count = entry-&gt;info(&amp;dinfo[0]);</a>
<a name="ln4138">            for (unsigned int i = 0; i &lt; count; ++i)</a>
<a name="ln4139">            {</a>
<a name="ln4140">                tileidx_t mc_idx = dinfo[i].idx;</a>
<a name="ln4141">                if (mc_idx &lt; TILE_MAIN_MAX)</a>
<a name="ln4142">                    fg_name += tile_main_name(mc_idx);</a>
<a name="ln4143">                else if (mc_idx &lt; TILEP_PLAYER_MAX)</a>
<a name="ln4144">                    fg_name += tile_player_name(mc_idx);</a>
<a name="ln4145">                else</a>
<a name="ln4146">                    fg_name += &quot;[invalid index]&quot;;</a>
<a name="ln4147"> </a>
<a name="ln4148">                if (i &lt; count - 1)</a>
<a name="ln4149">                    fg_name += &quot;, &quot;;</a>
<a name="ln4150">            }</a>
<a name="ln4151">        }</a>
<a name="ln4152">        else</a>
<a name="ln4153">            fg_name += &quot;[not found]&quot;;</a>
<a name="ln4154">    }</a>
<a name="ln4155"> </a>
<a name="ln4156">    string tile_string = make_stringf(</a>
<a name="ln4157">        &quot;%cFG: %4&quot; PRIu64&quot; | 0x%8&quot; PRIx64&quot; (%s)\n&quot;</a>
<a name="ln4158">        &quot;%cBG: %4&quot; PRIu64&quot; | 0x%8&quot; PRIx64&quot; (%s)\n&quot;,</a>
<a name="ln4159">        prefix,</a>
<a name="ln4160">        fg_idx,</a>
<a name="ln4161">        fg &amp; ~TILE_FLAG_MASK,</a>
<a name="ln4162">        fg_name.c_str(),</a>
<a name="ln4163">        prefix,</a>
<a name="ln4164">        bg_idx,</a>
<a name="ln4165">        bg &amp; ~TILE_FLAG_MASK,</a>
<a name="ln4166">        tile_dngn_name(bg_idx));</a>
<a name="ln4167"> </a>
<a name="ln4168">    return tile_string;</a>
<a name="ln4169">}</a>
<a name="ln4170"> </a>
<a name="ln4171">void bind_item_tile(item_def &amp;item)</a>
<a name="ln4172">{</a>
<a name="ln4173">    if (item.props.exists(&quot;item_tile_name&quot;))</a>
<a name="ln4174">    {</a>
<a name="ln4175">        string tile = item.props[&quot;item_tile_name&quot;].get_string();</a>
<a name="ln4176">        dprf(&quot;Binding non-worn item tile: \&quot;%s\&quot;.&quot;, tile.c_str());</a>
<a name="ln4177">        tileidx_t index;</a>
<a name="ln4178">        if (!tile_main_index(tile.c_str(), &amp;index))</a>
<a name="ln4179">        {</a>
<a name="ln4180">            // If invalid tile name, complain and discard the props.</a>
<a name="ln4181">            dprf(&quot;bad tile name: \&quot;%s\&quot;.&quot;, tile.c_str());</a>
<a name="ln4182">            item.props.erase(&quot;item_tile_name&quot;);</a>
<a name="ln4183">            item.props.erase(&quot;item_tile&quot;);</a>
<a name="ln4184">        }</a>
<a name="ln4185">        else</a>
<a name="ln4186">            item.props[&quot;item_tile&quot;] = short(index);</a>
<a name="ln4187">    }</a>
<a name="ln4188"> </a>
<a name="ln4189">    if (item.props.exists(&quot;worn_tile_name&quot;))</a>
<a name="ln4190">    {</a>
<a name="ln4191">        string tile = item.props[&quot;worn_tile_name&quot;].get_string();</a>
<a name="ln4192">        dprf(&quot;Binding worn item tile: \&quot;%s\&quot;.&quot;, tile.c_str());</a>
<a name="ln4193">        tileidx_t index;</a>
<a name="ln4194">        if (!tile_player_index(tile.c_str(), &amp;index))</a>
<a name="ln4195">        {</a>
<a name="ln4196">            // If invalid tile name, complain and discard the props.</a>
<a name="ln4197">            dprf(&quot;bad tile name: \&quot;%s\&quot;.&quot;, tile.c_str());</a>
<a name="ln4198">            item.props.erase(&quot;worn_tile_name&quot;);</a>
<a name="ln4199">            item.props.erase(&quot;worn_tile&quot;);</a>
<a name="ln4200">        }</a>
<a name="ln4201">        else</a>
<a name="ln4202">            item.props[&quot;worn_tile&quot;] = short(index);</a>
<a name="ln4203">    }</a>
<a name="ln4204">}</a>
<a name="ln4205">#endif</a>
<a name="ln4206"> </a>
<a name="ln4207">void tile_init_props(monster* mon)</a>
<a name="ln4208">{</a>
<a name="ln4209">    // Only monsters using mon_mod or mon_cycle need a tile_num.</a>
<a name="ln4210">    switch (mon-&gt;type)</a>
<a name="ln4211">    {</a>
<a name="ln4212">        case MONS_SLAVE:</a>
<a name="ln4213">        case MONS_TOADSTOOL:</a>
<a name="ln4214">        case MONS_FUNGUS:</a>
<a name="ln4215">        case MONS_PLANT:</a>
<a name="ln4216">        case MONS_BUSH:</a>
<a name="ln4217">        case MONS_FIRE_VORTEX:</a>
<a name="ln4218">        case MONS_TWISTER:</a>
<a name="ln4219">        case MONS_SPATIAL_VORTEX:</a>
<a name="ln4220">        case MONS_SPATIAL_MAELSTROM:</a>
<a name="ln4221">        case MONS_ABOMINATION_SMALL:</a>
<a name="ln4222">        case MONS_ABOMINATION_LARGE:</a>
<a name="ln4223">        case MONS_BLOCK_OF_ICE:</a>
<a name="ln4224">        case MONS_BUTTERFLY:</a>
<a name="ln4225">        case MONS_HUMAN:</a>
<a name="ln4226">        case MONS_DEEP_ELF_ELEMENTALIST:</a>
<a name="ln4227">            break;</a>
<a name="ln4228">        default:</a>
<a name="ln4229">            return;</a>
<a name="ln4230">    }</a>
<a name="ln4231"> </a>
<a name="ln4232">    // Already overridden or set.</a>
<a name="ln4233">    if (mon-&gt;props.exists(&quot;monster_tile&quot;) || mon-&gt;props.exists(TILE_NUM_KEY))</a>
<a name="ln4234">        return;</a>
<a name="ln4235"> </a>
<a name="ln4236">    mon-&gt;props[TILE_NUM_KEY] = short(random2(256));</a>
<a name="ln4237">}</a>

</code></pre>
<div class="balloon" rel="1843"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v648/" target="_blank">V648</a> Priority of the '&&' operation is higher than that of the '||' operation.</p></div>
<div class="balloon" rel="1899"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v592/" target="_blank">V592</a> The expression was enclosed by parentheses twice: ((expression)). One pair of parentheses is unnecessary or misprint is present.</p></div>
<div class="balloon" rel="2995"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v547/" target="_blank">V547</a> Expression 'colour != - 1' is always true.</p></div>

<link rel="stylesheet" href="highlight.css">
<script src="highlight.pack.js"></script>
<script src="highlightjs-line-numbers.js"></script>
<script>hljs.initHighlightingOnLoad();</script>
<script>hljs.initLineNumbersOnLoad();</script>
<script>
  $(document).ready(function() {
      $('.balloon').each(function () {
          var bl = $(this);
          var line = bl.attr('rel');
          var text = $('a[name="ln'+line+'"]').text();

          var space_count = 0;
          for(var i = 0; i<text.length; i++){
              var char = text[i];
              if((char !== ' ')&&(char !== '\t'))break;
              if(char === '\t')space_count++;
              space_count++;
          }

          bl.css('margin-left', space_count*8);
          $('a[name="ln'+line+'"]').after(bl);
      });

      window.location = window.location;
  });
</script>
</body>
</html>
