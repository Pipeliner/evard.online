
<html>
<head>

  <meta http-equiv="Content-Type" content="text/html; charset=US-ASCII" />
  <title>xom.cc</title>

  <link rel="stylesheet" href="../style.css"/>
  <script src="../jquery-3.2.1.min.js"></script>
</head>
<body>

<pre><code class = "cpp">
<a name="ln1">/**</a>
<a name="ln2"> * @file</a>
<a name="ln3"> * @brief All things Xomly</a>
<a name="ln4">**/</a>
<a name="ln5"> </a>
<a name="ln6">#include &quot;AppHdr.h&quot;</a>
<a name="ln7"> </a>
<a name="ln8">#include &quot;xom.h&quot;</a>
<a name="ln9"> </a>
<a name="ln10">#include &lt;algorithm&gt;</a>
<a name="ln11">#include &lt;functional&gt;</a>
<a name="ln12"> </a>
<a name="ln13">#include &quot;abyss.h&quot;</a>
<a name="ln14">#include &quot;acquire.h&quot;</a>
<a name="ln15">#include &quot;act-iter.h&quot;</a>
<a name="ln16">#include &quot;areas.h&quot;</a>
<a name="ln17">#include &quot;artefact.h&quot;</a>
<a name="ln18">#include &quot;cloud.h&quot;</a>
<a name="ln19">#include &quot;coordit.h&quot;</a>
<a name="ln20">#include &quot;database.h&quot;</a>
<a name="ln21">#ifdef WIZARD</a>
<a name="ln22">#include &quot;dbg-util.h&quot;</a>
<a name="ln23">#endif</a>
<a name="ln24">#include &quot;delay.h&quot;</a>
<a name="ln25">#include &quot;directn.h&quot;</a>
<a name="ln26">#include &quot;english.h&quot;</a>
<a name="ln27">#include &quot;env.h&quot;</a>
<a name="ln28">#include &quot;errors.h&quot;</a>
<a name="ln29">#include &quot;god-item.h&quot;</a>
<a name="ln30">#include &quot;item-name.h&quot;</a>
<a name="ln31">#include &quot;item-prop.h&quot;</a>
<a name="ln32">#include &quot;item-status-flag-type.h&quot;</a>
<a name="ln33">#include &quot;items.h&quot;</a>
<a name="ln34">#include &quot;item-use.h&quot;</a>
<a name="ln35">#include &quot;losglobal.h&quot;</a>
<a name="ln36">#include &quot;makeitem.h&quot;</a>
<a name="ln37">#include &quot;map-knowledge.h&quot;</a>
<a name="ln38">#include &quot;message.h&quot;</a>
<a name="ln39">#include &quot;misc.h&quot;</a>
<a name="ln40">#include &quot;mon-behv.h&quot;</a>
<a name="ln41">#include &quot;mon-death.h&quot;</a>
<a name="ln42">#include &quot;mon-place.h&quot;</a>
<a name="ln43">#include &quot;mon-poly.h&quot;</a>
<a name="ln44">#include &quot;mon-tentacle.h&quot;</a>
<a name="ln45">#include &quot;mutation.h&quot;</a>
<a name="ln46">#include &quot;nearby-danger.h&quot;</a>
<a name="ln47">#include &quot;notes.h&quot;</a>
<a name="ln48">#include &quot;output.h&quot;</a>
<a name="ln49">#include &quot;player-stats.h&quot;</a>
<a name="ln50">#include &quot;potion.h&quot;</a>
<a name="ln51">#include &quot;prompt.h&quot;</a>
<a name="ln52">#include &quot;religion.h&quot;</a>
<a name="ln53">#include &quot;shout.h&quot;</a>
<a name="ln54">#include &quot;spl-clouds.h&quot;</a>
<a name="ln55">#include &quot;spl-goditem.h&quot;</a>
<a name="ln56">#include &quot;spl-monench.h&quot;</a>
<a name="ln57">#include &quot;spl-transloc.h&quot;</a>
<a name="ln58">#include &quot;stairs.h&quot;</a>
<a name="ln59">#include &quot;stash.h&quot;</a>
<a name="ln60">#include &quot;state.h&quot;</a>
<a name="ln61">#include &quot;stepdown.h&quot;</a>
<a name="ln62">#include &quot;stringutil.h&quot;</a>
<a name="ln63">#include &quot;teleport.h&quot;</a>
<a name="ln64">#include &quot;terrain.h&quot;</a>
<a name="ln65">#include &quot;transform.h&quot;</a>
<a name="ln66">#include &quot;traps.h&quot;</a>
<a name="ln67">#include &quot;travel.h&quot;</a>
<a name="ln68">#include &quot;viewchar.h&quot;</a>
<a name="ln69">#include &quot;view.h&quot;</a>
<a name="ln70"> </a>
<a name="ln71">#ifdef DEBUG_XOM</a>
<a name="ln72">#    define DEBUG_RELIGION</a>
<a name="ln73">#    define NOTE_DEBUG_XOM</a>
<a name="ln74">#endif</a>
<a name="ln75"> </a>
<a name="ln76">#ifdef DEBUG_RELIGION</a>
<a name="ln77">#    define DEBUG_DIAGNOSTICS</a>
<a name="ln78">#    define DEBUG_GIFTS</a>
<a name="ln79">#endif</a>
<a name="ln80"> </a>
<a name="ln81">static void _do_xom_event(xom_event_type event_type, int sever);</a>
<a name="ln82">static int _xom_event_badness(xom_event_type event_type);</a>
<a name="ln83"> </a>
<a name="ln84">static bool _action_is_bad(xom_event_type action)</a>
<a name="ln85">{</a>
<a name="ln86">    return action &gt; XOM_LAST_GOOD_ACT &amp;&amp; action &lt;= XOM_LAST_BAD_ACT;</a>
<a name="ln87">}</a>
<a name="ln88"> </a>
<a name="ln89">// Spells to be cast at tension &gt; 0, i.e. usually in battle situations.</a>
<a name="ln90">// Spells later in the list require higher severity to have a chance of being</a>
<a name="ln91">// selected.</a>
<a name="ln92">static const vector&lt;spell_type&gt; _xom_random_spells =</a>
<a name="ln93">{</a>
<a name="ln94">    SPELL_SUMMON_BUTTERFLIES,</a>
<a name="ln95">    SPELL_SUMMON_SMALL_MAMMAL,</a>
<a name="ln96">    SPELL_CALL_CANINE_FAMILIAR,</a>
<a name="ln97">    SPELL_OLGREBS_TOXIC_RADIANCE,</a>
<a name="ln98">    SPELL_SUMMON_ICE_BEAST,</a>
<a name="ln99">    SPELL_LEDAS_LIQUEFACTION,</a>
<a name="ln100">    SPELL_CAUSE_FEAR,</a>
<a name="ln101">    SPELL_INTOXICATE,</a>
<a name="ln102">    SPELL_RING_OF_FLAMES,</a>
<a name="ln103">    SPELL_SHADOW_CREATURES,</a>
<a name="ln104">    SPELL_SUMMON_MANA_VIPER,</a>
<a name="ln105">    SPELL_STATUE_FORM,</a>
<a name="ln106">    SPELL_DISPERSAL,</a>
<a name="ln107">    SPELL_ENGLACIATION,</a>
<a name="ln108">    SPELL_DEATH_CHANNEL,</a>
<a name="ln109">    SPELL_SUMMON_HYDRA,</a>
<a name="ln110">    SPELL_MONSTROUS_MENAGERIE,</a>
<a name="ln111">    SPELL_DISCORD,</a>
<a name="ln112">    SPELL_DISJUNCTION,</a>
<a name="ln113">    SPELL_SUMMON_HORRIBLE_THINGS,</a>
<a name="ln114">    SPELL_SUMMON_DRAGON,</a>
<a name="ln115">    SPELL_NECROMUTATION,</a>
<a name="ln116">    SPELL_CHAIN_OF_CHAOS</a>
<a name="ln117">};</a>
<a name="ln118"> </a>
<a name="ln119">static const char *_xom_message_arrays[NUM_XOM_MESSAGE_TYPES][6] =</a>
<a name="ln120">{</a>
<a name="ln121">    // XM_NORMAL</a>
<a name="ln122">    {</a>
<a name="ln123">        &quot;Xom is interested.&quot;,</a>
<a name="ln124">        &quot;Xom is mildly amused.&quot;,</a>
<a name="ln125">        &quot;Xom is amused.&quot;,</a>
<a name="ln126">        &quot;Xom is highly amused!&quot;,</a>
<a name="ln127">        &quot;Xom thinks this is hilarious!&quot;,</a>
<a name="ln128">        &quot;Xom roars with laughter!&quot;</a>
<a name="ln129">    },</a>
<a name="ln130"> </a>
<a name="ln131">    // XM_INTRIGUED</a>
<a name="ln132">    {</a>
<a name="ln133">        &quot;Xom is interested.&quot;,</a>
<a name="ln134">        &quot;Xom is very interested.&quot;,</a>
<a name="ln135">        &quot;Xom is extremely interested.&quot;,</a>
<a name="ln136">        &quot;Xom is intrigued!&quot;,</a>
<a name="ln137">        &quot;Xom is very intrigued!&quot;,</a>
<a name="ln138">        &quot;Xom is fascinated!&quot;</a>
<a name="ln139">    }</a>
<a name="ln140">};</a>
<a name="ln141"> </a>
<a name="ln142">/**</a>
<a name="ln143"> * How much does Xom like you right now?</a>
<a name="ln144"> *</a>
<a name="ln145"> * Doesn't account for boredom, or whether or not you actually worship Xom.</a>
<a name="ln146"> *</a>
<a name="ln147"> * @return An index mapping to an entry in xom_moods.</a>
<a name="ln148"> */</a>
<a name="ln149">int xom_favour_rank()</a>
<a name="ln150">{</a>
<a name="ln151">    static const int breakpoints[] = { 20, 50, 80, 120, 150, 180};</a>
<a name="ln152">    for (unsigned int i = 0; i &lt; ARRAYSZ(breakpoints); ++i)</a>
<a name="ln153">        if (you.piety &lt;= breakpoints[i])</a>
<a name="ln154">            return i;</a>
<a name="ln155">    return ARRAYSZ(breakpoints);</a>
<a name="ln156">}</a>
<a name="ln157"> </a>
<a name="ln158">static const char* xom_moods[] = {</a>
<a name="ln159">    &quot;a very special plaything of Xom.&quot;,</a>
<a name="ln160">    &quot;a special plaything of Xom.&quot;,</a>
<a name="ln161">    &quot;a plaything of Xom.&quot;,</a>
<a name="ln162">    &quot;a toy of Xom.&quot;,</a>
<a name="ln163">    &quot;a favourite toy of Xom.&quot;,</a>
<a name="ln164">    &quot;a beloved toy of Xom.&quot;,</a>
<a name="ln165">    &quot;Xom's teddy bear.&quot;</a>
<a name="ln166">};</a>
<a name="ln167"> </a>
<a name="ln168">static const char *describe_xom_mood()</a>
<a name="ln169">{</a>
<a name="ln170">    const int mood = xom_favour_rank();</a>
<a name="ln171">    ASSERT(mood &gt;= 0);</a>
<a name="ln172">    ASSERT((size_t) mood &lt; ARRAYSZ(xom_moods));</a>
<a name="ln173">    return xom_moods[mood];</a>
<a name="ln174">}</a>
<a name="ln175"> </a>
<a name="ln176">const string describe_xom_favour()</a>
<a name="ln177">{</a>
<a name="ln178">    string favour;</a>
<a name="ln179">    if (!you_worship(GOD_XOM))</a>
<a name="ln180">        favour = &quot;a very buggy toy of Xom.&quot;;</a>
<a name="ln181">    else if (you.gift_timeout &lt; 1)</a>
<a name="ln182">        favour = &quot;a BORING thing.&quot;;</a>
<a name="ln183">    else</a>
<a name="ln184">        favour = describe_xom_mood();</a>
<a name="ln185"> </a>
<a name="ln186">    return favour;</a>
<a name="ln187">}</a>
<a name="ln188"> </a>
<a name="ln189">#define XOM_SPEECH(x) x</a>
<a name="ln190">static string _get_xom_speech(const string &amp;key)</a>
<a name="ln191">{</a>
<a name="ln192">    string result = getSpeakString(&quot;Xom &quot; + key);</a>
<a name="ln193"> </a>
<a name="ln194">    if (result.empty())</a>
<a name="ln195">        result = getSpeakString(&quot;Xom &quot; XOM_SPEECH(&quot;general effect&quot;));</a>
<a name="ln196"> </a>
<a name="ln197">    if (result.empty())</a>
<a name="ln198">        return &quot;Xom makes something happen.&quot;;</a>
<a name="ln199"> </a>
<a name="ln200">    return result;</a>
<a name="ln201">}</a>
<a name="ln202"> </a>
<a name="ln203">static bool _xom_is_bored()</a>
<a name="ln204">{</a>
<a name="ln205">    return you_worship(GOD_XOM) &amp;&amp; !you.gift_timeout;</a>
<a name="ln206">}</a>
<a name="ln207"> </a>
<a name="ln208">static bool _xom_feels_nasty()</a>
<a name="ln209">{</a>
<a name="ln210">    // Xom will only directly kill you with a bad effect if you're under</a>
<a name="ln211">    // penance from him, or if he's bored.</a>
<a name="ln212">    return you.penance[GOD_XOM] || _xom_is_bored();</a>
<a name="ln213">}</a>
<a name="ln214"> </a>
<a name="ln215">bool xom_is_nice(int tension)</a>
<a name="ln216">{</a>
<a name="ln217">    if (player_under_penance(GOD_XOM))</a>
<a name="ln218">        return false;</a>
<a name="ln219"> </a>
<a name="ln220">    if (you_worship(GOD_XOM))</a>
<a name="ln221">    {</a>
<a name="ln222">        // If you.gift_timeout is 0, then Xom is BORED. He HATES that.</a>
<a name="ln223">        if (!you.gift_timeout)</a>
<a name="ln224">            return false;</a>
<a name="ln225"> </a>
<a name="ln226">        // At high tension Xom is more likely to be nice, at zero</a>
<a name="ln227">        // tension the opposite.</a>
<a name="ln228">        const int tension_bonus</a>
<a name="ln229">            = (tension == -1 ? 0 // :</a>
<a name="ln230">// Xom needs to be less negative</a>
<a name="ln231">//              : tension ==  0 ? -min(abs(HALF_MAX_PIETY - you.piety) / 2,</a>
<a name="ln232">//                                     you.piety / 10)</a>
<a name="ln233">                             : min((MAX_PIETY - you.piety) / 2,</a>
<a name="ln234">                                   random2(tension)));</a>
<a name="ln235"> </a>
<a name="ln236">        const int effective_piety = you.piety + tension_bonus;</a>
<a name="ln237">        ASSERT_RANGE(effective_piety, 0, MAX_PIETY + 1);</a>
<a name="ln238"> </a>
<a name="ln239">#ifdef DEBUG_XOM</a>
<a name="ln240">        mprf(MSGCH_DIAGNOSTICS,</a>
<a name="ln241">             &quot;Xom: tension: %d, piety: %d -&gt; tension bonus = %d, eff. piety: %d&quot;,</a>
<a name="ln242">             tension, you.piety, tension_bonus, effective_piety);</a>
<a name="ln243">#endif</a>
<a name="ln244"> </a>
<a name="ln245">        // Whether Xom is nice depends largely on his mood (== piety).</a>
<a name="ln246">        return x_chance_in_y(effective_piety, MAX_PIETY);</a>
<a name="ln247">    }</a>
<a name="ln248">    else // CARD_XOM</a>
<a name="ln249">        return coinflip();</a>
<a name="ln250">}</a>
<a name="ln251"> </a>
<a name="ln252">static void _xom_is_stimulated(int maxinterestingness,</a>
<a name="ln253">                               const char *message_array[],</a>
<a name="ln254">                               bool force_message)</a>
<a name="ln255">{</a>
<a name="ln256">    if (!you_worship(GOD_XOM) || maxinterestingness &lt;= 0)</a>
<a name="ln257">        return;</a>
<a name="ln258"> </a>
<a name="ln259">    // Xom is not directly stimulated by his own acts.</a>
<a name="ln260">    if (crawl_state.which_god_acting() == GOD_XOM)</a>
<a name="ln261">        return;</a>
<a name="ln262"> </a>
<a name="ln263">    int interestingness = random2(piety_scale(maxinterestingness));</a>
<a name="ln264"> </a>
<a name="ln265">    interestingness = min(200, interestingness);</a>
<a name="ln266"> </a>
<a name="ln267">#if defined(DEBUG_RELIGION) || defined(DEBUG_GIFTS) || defined(DEBUG_XOM)</a>
<a name="ln268">    mprf(MSGCH_DIAGNOSTICS,</a>
<a name="ln269">         &quot;Xom: gift_timeout: %d, maxinterestingness = %d, interestingness = %d&quot;,</a>
<a name="ln270">         you.gift_timeout, maxinterestingness, interestingness);</a>
<a name="ln271">#endif</a>
<a name="ln272"> </a>
<a name="ln273">    bool was_stimulated = false;</a>
<a name="ln274">    if (interestingness &gt; you.gift_timeout &amp;&amp; interestingness &gt;= 10)</a>
<a name="ln275">    {</a>
<a name="ln276">        you.gift_timeout = interestingness;</a>
<a name="ln277">        was_stimulated = true;</a>
<a name="ln278">    }</a>
<a name="ln279"> </a>
<a name="ln280">    if (was_stimulated || force_message)</a>
<a name="ln281">    {</a>
<a name="ln282">        god_speaks(GOD_XOM,</a>
<a name="ln283">                   ((interestingness &gt; 160) ? message_array[5] :</a>
<a name="ln284">                    (interestingness &gt;  80) ? message_array[4] :</a>
<a name="ln285">                    (interestingness &gt;  60) ? message_array[3] :</a>
<a name="ln286">                    (interestingness &gt;  40) ? message_array[2] :</a>
<a name="ln287">                    (interestingness &gt;  20) ? message_array[1]</a>
<a name="ln288">                                            : message_array[0]));</a>
<a name="ln289">        //updating piety status line</a>
<a name="ln290">        you.redraw_title = true;</a>
<a name="ln291">    }</a>
<a name="ln292">}</a>
<a name="ln293"> </a>
<a name="ln294">void xom_is_stimulated(int maxinterestingness, xom_message_type message_type,</a>
<a name="ln295">                       bool force_message)</a>
<a name="ln296">{</a>
<a name="ln297">    _xom_is_stimulated(maxinterestingness, _xom_message_arrays[message_type],</a>
<a name="ln298">                       force_message);</a>
<a name="ln299">}</a>
<a name="ln300"> </a>
<a name="ln301">void xom_is_stimulated(int maxinterestingness, const string&amp; message,</a>
<a name="ln302">                       bool force_message)</a>
<a name="ln303">{</a>
<a name="ln304">    if (!you_worship(GOD_XOM))</a>
<a name="ln305">        return;</a>
<a name="ln306"> </a>
<a name="ln307">    const char *message_array[6];</a>
<a name="ln308"> </a>
<a name="ln309">    for (int i = 0; i &lt; 6; ++i)</a>
<a name="ln310">        message_array[i] = message.c_str();</a>
<a name="ln311"> </a>
<a name="ln312">    _xom_is_stimulated(maxinterestingness, message_array, force_message);</a>
<a name="ln313">}</a>
<a name="ln314"> </a>
<a name="ln315">void xom_tick()</a>
<a name="ln316">{</a>
<a name="ln317">    // Xom now ticks every action, not every 20 turns.</a>
<a name="ln318">    if (one_chance_in(20))</a>
<a name="ln319">    {</a>
<a name="ln320">        // Xom semi-randomly drifts your piety.</a>
<a name="ln321">        const string old_xom_favour = describe_xom_favour();</a>
<a name="ln322">        const bool good = (you.piety == HALF_MAX_PIETY ? coinflip()</a>
<a name="ln323">                                                       : you.piety &gt; HALF_MAX_PIETY);</a>
<a name="ln324">        int size = abs(you.piety - HALF_MAX_PIETY);</a>
<a name="ln325"> </a>
<a name="ln326">        // Piety slowly drifts towards the extremes.</a>
<a name="ln327">        const int delta = piety_scale(x_chance_in_y(511, 1000) ? 1 : -1);</a>
<a name="ln328">        size += delta;</a>
<a name="ln329">        if (size &gt; HALF_MAX_PIETY)</a>
<a name="ln330">            size = HALF_MAX_PIETY;</a>
<a name="ln331"> </a>
<a name="ln332">        you.piety = HALF_MAX_PIETY + (good ? size : -size);</a>
<a name="ln333">        string new_xom_favour = describe_xom_favour();</a>
<a name="ln334">        you.redraw_title = true; // redraw piety/boredom display</a>
<a name="ln335">        if (old_xom_favour != new_xom_favour)</a>
<a name="ln336">        {</a>
<a name="ln337">            // If we entered another favour state, take a big step into</a>
<a name="ln338">            // the new territory, to avoid oscillating favour announcements</a>
<a name="ln339">            // every few turns.</a>
<a name="ln340">            size += delta * 8;</a>
<a name="ln341">            if (size &gt; HALF_MAX_PIETY)</a>
<a name="ln342">                size = HALF_MAX_PIETY;</a>
<a name="ln343"> </a>
<a name="ln344">            // If size was 0 to begin with, it may become negative, but that</a>
<a name="ln345">            // doesn't really matter.</a>
<a name="ln346">            you.piety = HALF_MAX_PIETY + (good ? size : -size);</a>
<a name="ln347">        }</a>
<a name="ln348">#ifdef DEBUG_XOM</a>
<a name="ln349">        const string note = make_stringf(&quot;xom_tick(), delta: %d, piety: %d&quot;,</a>
<a name="ln350">                                         delta, you.piety);</a>
<a name="ln351">        take_note(Note(NOTE_MESSAGE, 0, 0, note), true);</a>
<a name="ln352">#endif</a>
<a name="ln353"> </a>
<a name="ln354">        // ...but he gets bored...</a>
<a name="ln355">        if (you.gift_timeout &gt; 0 &amp;&amp; coinflip())</a>
<a name="ln356">           you.gift_timeout--;</a>
<a name="ln357"> </a>
<a name="ln358">        new_xom_favour = describe_xom_favour();</a>
<a name="ln359">        if (old_xom_favour != new_xom_favour)</a>
<a name="ln360">        {</a>
<a name="ln361">            const string msg = &quot;You are now &quot; + new_xom_favour;</a>
<a name="ln362">            god_speaks(you.religion, msg.c_str());</a>
<a name="ln363">        }</a>
<a name="ln364"> </a>
<a name="ln365">        if (you.gift_timeout == 1)</a>
<a name="ln366">            simple_god_message(&quot; is getting BORED.&quot;);</a>
<a name="ln367">    }</a>
<a name="ln368"> </a>
<a name="ln369">    if (x_chance_in_y(2 + you.faith(), 6))</a>
<a name="ln370">    {</a>
<a name="ln371">        const int tension = get_tension(GOD_XOM);</a>
<a name="ln372">        const int chance = (tension ==  0 ? 1 :</a>
<a name="ln373">                            tension &lt;=  5 ? 2 :</a>
<a name="ln374">                            tension &lt;= 10 ? 3 :</a>
<a name="ln375">                            tension &lt;= 20 ? 4</a>
<a name="ln376">                                          : 5);</a>
<a name="ln377"> </a>
<a name="ln378">        // If Xom is bored, the chances for Xom acting are sort of reversed.</a>
<a name="ln379">        if (!you.gift_timeout &amp;&amp; x_chance_in_y(25 - chance*chance, 100))</a>
<a name="ln380">        {</a>
<a name="ln381">            xom_acts(abs(you.piety - HALF_MAX_PIETY), MB_MAYBE, tension);</a>
<a name="ln382">            return;</a>
<a name="ln383">        }</a>
<a name="ln384">        else if (you.gift_timeout &lt;= 1 &amp;&amp; chance &gt; 0</a>
<a name="ln385">                 &amp;&amp; x_chance_in_y(chance - 1, 80))</a>
<a name="ln386">        {</a>
<a name="ln387">            // During tension, Xom may briefly forget about being bored.</a>
<a name="ln388">            const int interest = random2(chance * 15);</a>
<a name="ln389">            if (interest &gt; 0)</a>
<a name="ln390">            {</a>
<a name="ln391">                if (interest &lt; 25)</a>
<a name="ln392">                    simple_god_message(&quot; is interested.&quot;);</a>
<a name="ln393">                else</a>
<a name="ln394">                    simple_god_message(&quot; is intrigued.&quot;);</a>
<a name="ln395"> </a>
<a name="ln396">                you.gift_timeout += interest;</a>
<a name="ln397">                //updating piety status line</a>
<a name="ln398">                you.redraw_title = true;</a>
<a name="ln399">#if defined(DEBUG_RELIGION) || defined(DEBUG_XOM)</a>
<a name="ln400">                mprf(MSGCH_DIAGNOSTICS,</a>
<a name="ln401">                     &quot;tension %d (chance: %d) -&gt; increase interest to %d&quot;,</a>
<a name="ln402">                     tension, chance, you.gift_timeout);</a>
<a name="ln403">#endif</a>
<a name="ln404">            }</a>
<a name="ln405">        }</a>
<a name="ln406"> </a>
<a name="ln407">        if (x_chance_in_y(chance*chance, 100))</a>
<a name="ln408">            xom_acts(abs(you.piety - HALF_MAX_PIETY), MB_MAYBE, tension);</a>
<a name="ln409">    }</a>
<a name="ln410">}</a>
<a name="ln411"> </a>
<a name="ln412">static bool mon_nearby(function&lt;bool(monster&amp;)&gt; filter)</a>
<a name="ln413">{</a>
<a name="ln414">    for (monster_near_iterator mi(you.pos(), LOS_NO_TRANS); mi; ++mi)</a>
<a name="ln415">        if (filter(**mi))</a>
<a name="ln416">            return true;</a>
<a name="ln417">    return false;</a>
<a name="ln418">}</a>
<a name="ln419"> </a>
<a name="ln420">// Picks 100 random grids from the level and checks whether they've been</a>
<a name="ln421">// marked as seen (explored) or known (mapped). If seen_only is true,</a>
<a name="ln422">// grids only &quot;seen&quot; via magic mapping don't count. Returns the</a>
<a name="ln423">// estimated percentage value of exploration.</a>
<a name="ln424">static int _exploration_estimate(bool seen_only = false)</a>
<a name="ln425">{</a>
<a name="ln426">    int seen  = 0;</a>
<a name="ln427">    int total = 0;</a>
<a name="ln428">    int tries = 0;</a>
<a name="ln429"> </a>
<a name="ln430">    do</a>
<a name="ln431">    {</a>
<a name="ln432">        tries++;</a>
<a name="ln433"> </a>
<a name="ln434">        coord_def pos = random_in_bounds();</a>
<a name="ln435">        if (!seen_only &amp;&amp; env.map_knowledge(pos).known() || env.map_knowledge(pos).seen())</a>
<a name="ln436">        {</a>
<a name="ln437">            seen++;</a>
<a name="ln438">            total++;</a>
<a name="ln439">            continue;</a>
<a name="ln440">        }</a>
<a name="ln441"> </a>
<a name="ln442">        bool open = true;</a>
<a name="ln443">        if (cell_is_solid(pos) &amp;&amp; !feat_is_closed_door(grd(pos)))</a>
<a name="ln444">        {</a>
<a name="ln445">            open = false;</a>
<a name="ln446">            for (adjacent_iterator ai(pos); ai; ++ai)</a>
<a name="ln447">            {</a>
<a name="ln448">                if (map_bounds(*ai) &amp;&amp; (!feat_is_opaque(grd(*ai))</a>
<a name="ln449">                                        || feat_is_closed_door(grd(*ai))))</a>
<a name="ln450">                {</a>
<a name="ln451">                    open = true;</a>
<a name="ln452">                    break;</a>
<a name="ln453">                }</a>
<a name="ln454">            }</a>
<a name="ln455">        }</a>
<a name="ln456"> </a>
<a name="ln457">        if (open)</a>
<a name="ln458">            total++;</a>
<a name="ln459">    }</a>
<a name="ln460">    while (total &lt; 100 &amp;&amp; tries &lt; 1000);</a>
<a name="ln461"> </a>
<a name="ln462">    // If we didn't get any qualifying grids, there are probably so few</a>
<a name="ln463">    // of them you've already seen them all.</a>
<a name="ln464">    if (total == 0)</a>
<a name="ln465">        return 100;</a>
<a name="ln466"> </a>
<a name="ln467">    if (total &lt; 100)</a>
<a name="ln468">        seen *= 100 / total;</a>
<a name="ln469"> </a>
<a name="ln470">    return seen;</a>
<a name="ln471">}</a>
<a name="ln472"> </a>
<a name="ln473">static bool _teleportation_check()</a>
<a name="ln474">{</a>
<a name="ln475">    if (crawl_state.game_is_sprint())</a>
<a name="ln476">        return false;</a>
<a name="ln477"> </a>
<a name="ln478">    return !you.no_tele(false, false);</a>
<a name="ln479">}</a>
<a name="ln480"> </a>
<a name="ln481">static bool _transformation_check(const spell_type spell)</a>
<a name="ln482">{</a>
<a name="ln483">    transformation tran = transformation::none;</a>
<a name="ln484">    switch (spell)</a>
<a name="ln485">    {</a>
<a name="ln486">    case SPELL_BEASTLY_APPENDAGE:</a>
<a name="ln487">        tran = transformation::appendage;</a>
<a name="ln488">        break;</a>
<a name="ln489">    case SPELL_SPIDER_FORM:</a>
<a name="ln490">        tran = transformation::spider;</a>
<a name="ln491">        break;</a>
<a name="ln492">    case SPELL_STATUE_FORM:</a>
<a name="ln493">        tran = transformation::statue;</a>
<a name="ln494">        break;</a>
<a name="ln495">    case SPELL_ICE_FORM:</a>
<a name="ln496">        tran = transformation::ice_beast;</a>
<a name="ln497">        break;</a>
<a name="ln498">    case SPELL_HYDRA_FORM:</a>
<a name="ln499">        tran = transformation::hydra;</a>
<a name="ln500">        break;</a>
<a name="ln501">    case SPELL_DRAGON_FORM:</a>
<a name="ln502">        tran = transformation::dragon;</a>
<a name="ln503">        break;</a>
<a name="ln504">    case SPELL_NECROMUTATION:</a>
<a name="ln505">        tran = transformation::lich;</a>
<a name="ln506">        break;</a>
<a name="ln507">    default:</a>
<a name="ln508">        break;</a>
<a name="ln509">    }</a>
<a name="ln510"> </a>
<a name="ln511">    if (tran == transformation::none)</a>
<a name="ln512">        return true;</a>
<a name="ln513"> </a>
<a name="ln514">    // Check whether existing enchantments/transformations, cursed</a>
<a name="ln515">    // equipment or potential stat loss interfere with this</a>
<a name="ln516">    // transformation.</a>
<a name="ln517">    return transform(0, tran, true, true);</a>
<a name="ln518">}</a>
<a name="ln519"> </a>
<a name="ln520">/// Try to choose a random player-castable spell.</a>
<a name="ln521">static spell_type _choose_random_spell(int sever)</a>
<a name="ln522">{</a>
<a name="ln523">    const int spellenum = max(1, sever);</a>
<a name="ln524">    vector&lt;spell_type&gt; ok_spells;</a>
<a name="ln525">    const vector&lt;spell_type&gt; &amp;spell_list = _xom_random_spells;</a>
<a name="ln526">    for (int i = 0; i &lt; min(spellenum, (int)spell_list.size()); ++i)</a>
<a name="ln527">    {</a>
<a name="ln528">        const spell_type spell = spell_list[i];</a>
<a name="ln529">        if (!spell_is_useless(spell, true, true, true)</a>
<a name="ln530">             &amp;&amp; _transformation_check(spell))</a>
<a name="ln531">        {</a>
<a name="ln532">            ok_spells.push_back(spell);</a>
<a name="ln533">        }</a>
<a name="ln534">    }</a>
<a name="ln535"> </a>
<a name="ln536">    if (!ok_spells.size())</a>
<a name="ln537">        return SPELL_NO_SPELL;</a>
<a name="ln538">    return ok_spells[random2(ok_spells.size())];</a>
<a name="ln539">}</a>
<a name="ln540"> </a>
<a name="ln541">/// Cast a random spell 'through' the player.</a>
<a name="ln542">static void _xom_random_spell(int sever)</a>
<a name="ln543">{</a>
<a name="ln544">    const spell_type spell = _choose_random_spell(sever);</a>
<a name="ln545">    if (spell == SPELL_NO_SPELL)</a>
<a name="ln546">        return;</a>
<a name="ln547"> </a>
<a name="ln548">    god_speaks(GOD_XOM, _get_xom_speech(&quot;spell effect&quot;).c_str());</a>
<a name="ln549"> </a>
<a name="ln550">#if defined(DEBUG_DIAGNOSTICS) || defined(DEBUG_RELIGION) || defined(DEBUG_XOM)</a>
<a name="ln551">    mprf(MSGCH_DIAGNOSTICS,</a>
<a name="ln552">         &quot;_xom_makes_you_cast_random_spell(); spell: %d&quot;,</a>
<a name="ln553">         spell);</a>
<a name="ln554">#endif</a>
<a name="ln555"> </a>
<a name="ln556">    your_spells(spell, sever, false);</a>
<a name="ln557">    const string note = make_stringf(&quot;cast spell '%s'&quot;, spell_title(spell));</a>
<a name="ln558">    take_note(Note(NOTE_XOM_EFFECT, you.piety, -1, note), true);</a>
<a name="ln559">}</a>
<a name="ln560"> </a>
<a name="ln561">/// Map out the level.</a>
<a name="ln562">static void _xom_magic_mapping(int sever)</a>
<a name="ln563">{</a>
<a name="ln564">    god_speaks(GOD_XOM, _get_xom_speech(&quot;divination&quot;).c_str());</a>
<a name="ln565"> </a>
<a name="ln566">    // power isn't relevant at present, but may again be, someday?</a>
<a name="ln567">    const int power = stepdown_value(sever, 10, 10, 40, 45);</a>
<a name="ln568">    magic_mapping(5 + power, 50 + random2avg(power * 2, 2), false);</a>
<a name="ln569">    take_note(Note(NOTE_XOM_EFFECT, you.piety, -1,</a>
<a name="ln570">                   &quot;divination: magic mapping&quot;), true);</a>
<a name="ln571">}</a>
<a name="ln572"> </a>
<a name="ln573">/// Detect items across the level.</a>
<a name="ln574">static void _xom_detect_items(int sever)</a>
<a name="ln575">{</a>
<a name="ln576">    god_speaks(GOD_XOM, _get_xom_speech(&quot;divination&quot;).c_str());</a>
<a name="ln577"> </a>
<a name="ln578">    if (detect_items(sever) == 0)</a>
<a name="ln579">        canned_msg(MSG_DETECT_NOTHING);</a>
<a name="ln580">    else</a>
<a name="ln581">        mpr(&quot;You detect items!&quot;);</a>
<a name="ln582"> </a>
<a name="ln583">    take_note(Note(NOTE_XOM_EFFECT, you.piety, -1,</a>
<a name="ln584">                   &quot;divination: detect items&quot;), true);</a>
<a name="ln585">}</a>
<a name="ln586"> </a>
<a name="ln587">/// Detect creatures across the level.</a>
<a name="ln588">static void _xom_detect_creatures(int sever)</a>
<a name="ln589">{</a>
<a name="ln590">    god_speaks(GOD_XOM, _get_xom_speech(&quot;divination&quot;).c_str());</a>
<a name="ln591"> </a>
<a name="ln592">    const int prev_detected = count_detected_mons();</a>
<a name="ln593">    const int num_creatures = detect_creatures(sever);</a>
<a name="ln594"> </a>
<a name="ln595">    if (num_creatures == 0)</a>
<a name="ln596">        canned_msg(MSG_DETECT_NOTHING);</a>
<a name="ln597">    else if (num_creatures == prev_detected)</a>
<a name="ln598">    {</a>
<a name="ln599">        // This is not strictly true. You could have cast Detect</a>
<a name="ln600">        // Creatures with a big enough fuzz that the detected glyph is</a>
<a name="ln601">        // still on the map when the original one has been killed. Then</a>
<a name="ln602">        // another one is spawned, so the number is the same as before.</a>
<a name="ln603">        // There's no way we can check this, however.</a>
<a name="ln604">        mpr(&quot;You detect no further creatures.&quot;);</a>
<a name="ln605">    }</a>
<a name="ln606">    else</a>
<a name="ln607">        mpr(&quot;You detect creatures!&quot;);</a>
<a name="ln608"> </a>
<a name="ln609">    take_note(Note(NOTE_XOM_EFFECT, you.piety, -1,</a>
<a name="ln610">                   &quot;divination: detect creatures&quot;), true);</a>
<a name="ln611">}</a>
<a name="ln612"> </a>
<a name="ln613">static void _try_brand_switch(const int item_index)</a>
<a name="ln614">{</a>
<a name="ln615">    if (item_index == NON_ITEM)</a>
<a name="ln616">        return;</a>
<a name="ln617"> </a>
<a name="ln618">    item_def &amp;item(mitm[item_index]);</a>
<a name="ln619"> </a>
<a name="ln620">    if (item.base_type != OBJ_WEAPONS)</a>
<a name="ln621">        return;</a>
<a name="ln622"> </a>
<a name="ln623">    if (is_unrandom_artefact(item))</a>
<a name="ln624">        return;</a>
<a name="ln625"> </a>
<a name="ln626">    // Only do it some of the time.</a>
<a name="ln627">    if (one_chance_in(3))</a>
<a name="ln628">        return;</a>
<a name="ln629"> </a>
<a name="ln630">    if (get_weapon_brand(item) == SPWPN_NORMAL)</a>
<a name="ln631">        return;</a>
<a name="ln632"> </a>
<a name="ln633">    if (is_random_artefact(item))</a>
<a name="ln634">        artefact_set_property(item, ARTP_BRAND, SPWPN_CHAOS);</a>
<a name="ln635">    else</a>
<a name="ln636">        item.brand = SPWPN_CHAOS;</a>
<a name="ln637">}</a>
<a name="ln638"> </a>
<a name="ln639">static void _xom_make_item(object_class_type base, int subtype, int power)</a>
<a name="ln640">{</a>
<a name="ln641">    god_acting gdact(GOD_XOM);</a>
<a name="ln642"> </a>
<a name="ln643">    int thing_created = items(true, base, subtype, power, 0, GOD_XOM);</a>
<a name="ln644"> </a>
<a name="ln645">    if (thing_created == NON_ITEM)</a>
<a name="ln646">    {</a>
<a name="ln647">        god_speaks(GOD_XOM, &quot;\&quot;No, never mind.\&quot;&quot;);</a>
<a name="ln648">        return;</a>
<a name="ln649">    }</a>
<a name="ln650"> </a>
<a name="ln651">    _try_brand_switch(thing_created);</a>
<a name="ln652"> </a>
<a name="ln653">    static char gift_buf[100];</a>
<a name="ln654">    snprintf(gift_buf, sizeof(gift_buf), &quot;god gift: %s&quot;,</a>
<a name="ln655">             mitm[thing_created].name(DESC_PLAIN).c_str());</a>
<a name="ln656">    take_note(Note(NOTE_XOM_EFFECT, you.piety, -1, gift_buf), true);</a>
<a name="ln657"> </a>
<a name="ln658">    canned_msg(MSG_SOMETHING_APPEARS);</a>
<a name="ln659">    move_item_to_grid(&amp;thing_created, you.pos());</a>
<a name="ln660"> </a>
<a name="ln661">    if (thing_created == NON_ITEM) // if it fell into lava</a>
<a name="ln662">        simple_god_message(&quot; snickers.&quot;, GOD_XOM);</a>
<a name="ln663"> </a>
<a name="ln664">    stop_running();</a>
<a name="ln665">}</a>
<a name="ln666"> </a>
<a name="ln667">/// Xom's 'acquirement'. A gift for the player, of a sort...</a>
<a name="ln668">static void _xom_acquirement(int /*sever*/)</a>
<a name="ln669">{</a>
<a name="ln670">    god_speaks(GOD_XOM, _get_xom_speech(&quot;general gift&quot;).c_str());</a>
<a name="ln671"> </a>
<a name="ln672">    const object_class_type types[] =</a>
<a name="ln673">    {</a>
<a name="ln674">        OBJ_WEAPONS, OBJ_ARMOUR, OBJ_JEWELLERY,  OBJ_BOOKS,</a>
<a name="ln675">        OBJ_STAVES,  OBJ_WANDS,  OBJ_MISCELLANY, OBJ_FOOD,  OBJ_GOLD,</a>
<a name="ln676">        OBJ_MISSILES</a>
<a name="ln677">    };</a>
<a name="ln678">    const object_class_type force_class = RANDOM_ELEMENT(types);</a>
<a name="ln679"> </a>
<a name="ln680">    const int item_index = acquirement_create_item(force_class, GOD_XOM,</a>
<a name="ln681">            false, you.pos());</a>
<a name="ln682">    if (item_index == NON_ITEM)</a>
<a name="ln683">    {</a>
<a name="ln684">        god_speaks(GOD_XOM, &quot;\&quot;No, never mind.\&quot;&quot;);</a>
<a name="ln685">        return;</a>
<a name="ln686">    }</a>
<a name="ln687"> </a>
<a name="ln688">    _try_brand_switch(item_index);</a>
<a name="ln689"> </a>
<a name="ln690">    const string note = make_stringf(&quot;god gift: %s&quot;,</a>
<a name="ln691">                                     mitm[item_index].name(DESC_PLAIN).c_str());</a>
<a name="ln692">    take_note(Note(NOTE_XOM_EFFECT, you.piety, -1, note), true);</a>
<a name="ln693"> </a>
<a name="ln694">    stop_running();</a>
<a name="ln695">    more();</a>
<a name="ln696">}</a>
<a name="ln697"> </a>
<a name="ln698">/// Create a random item and give it to the player.</a>
<a name="ln699">static void _xom_random_item(int sever)</a>
<a name="ln700">{</a>
<a name="ln701">    god_speaks(GOD_XOM, _get_xom_speech(&quot;general gift&quot;).c_str());</a>
<a name="ln702">    _xom_make_item(OBJ_RANDOM, OBJ_RANDOM, sever * 3);</a>
<a name="ln703">    more();</a>
<a name="ln704">}</a>
<a name="ln705"> </a>
<a name="ln706">static bool _choose_mutatable_monster(const monster&amp; mon)</a>
<a name="ln707">{</a>
<a name="ln708">    return mon.alive() &amp;&amp; mon.can_safely_mutate()</a>
<a name="ln709">           &amp;&amp; !mon.submerged();</a>
<a name="ln710">}</a>
<a name="ln711"> </a>
<a name="ln712">static bool _choose_enchantable_monster(const monster&amp; mon)</a>
<a name="ln713">{</a>
<a name="ln714">    return mon.alive() &amp;&amp; !mon.wont_attack()</a>
<a name="ln715">           &amp;&amp; !mons_immune_magic(mon);</a>
<a name="ln716">}</a>
<a name="ln717"> </a>
<a name="ln718">static bool _is_chaos_upgradeable(const item_def &amp;item,</a>
<a name="ln719">                                  const monster* mon)</a>
<a name="ln720">{</a>
<a name="ln721">    // Since Xom is a god, he is capable of changing randarts, but not</a>
<a name="ln722">    // other artefacts.</a>
<a name="ln723">    if (is_unrandom_artefact(item))</a>
<a name="ln724">        return false;</a>
<a name="ln725"> </a>
<a name="ln726">    // Staves can't be changed either, since they don't have brands in the way</a>
<a name="ln727">    // other weapons do.</a>
<a name="ln728">    if (item.base_type == OBJ_STAVES</a>
<a name="ln729">#if TAG_MAJOR_VERSION == 34</a>
<a name="ln730">        || item.base_type == OBJ_RODS</a>
<a name="ln731">#endif</a>
<a name="ln732">       )</a>
<a name="ln733">{</a>
<a name="ln734">        return false;</a>
<a name="ln735">}</a>
<a name="ln736"> </a>
<a name="ln737">    // Only upgrade permanent items, since the player should get a</a>
<a name="ln738">    // chance to use the item if he or she can defeat the monster.</a>
<a name="ln739">    if (item.flags &amp; ISFLAG_SUMMONED)</a>
<a name="ln740">        return false;</a>
<a name="ln741"> </a>
<a name="ln742">    // Blessed weapons are protected, being gifts from good gods.</a>
<a name="ln743">    if (is_blessed(item))</a>
<a name="ln744">        return false;</a>
<a name="ln745"> </a>
<a name="ln746">    // God gifts are protected -- but not his own!</a>
<a name="ln747">    if (item.orig_monnum &lt; 0)</a>
<a name="ln748">    {</a>
<a name="ln749">        god_type iorig = static_cast&lt;god_type&gt;(-item.orig_monnum);</a>
<a name="ln750">        if (iorig &gt; GOD_NO_GOD &amp;&amp; iorig &lt; NUM_GODS &amp;&amp; iorig != GOD_XOM)</a>
<a name="ln751">            return false;</a>
<a name="ln752">    }</a>
<a name="ln753"> </a>
<a name="ln754">    // Leave branded items alone, since this is supposed to be an</a>
<a name="ln755">    // upgrade.</a>
<a name="ln756">    if (item.base_type == OBJ_MISSILES)</a>
<a name="ln757">    {</a>
<a name="ln758">        // Don't make boulders or throwing nets of chaos.</a>
<a name="ln759">        if (item.sub_type == MI_LARGE_ROCK</a>
<a name="ln760">            || item.sub_type == MI_THROWING_NET)</a>
<a name="ln761">        {</a>
<a name="ln762">            return false;</a>
<a name="ln763">        }</a>
<a name="ln764"> </a>
<a name="ln765">        if (get_ammo_brand(item) == SPMSL_NORMAL)</a>
<a name="ln766">            return true;</a>
<a name="ln767">    }</a>
<a name="ln768">    else</a>
<a name="ln769">    {</a>
<a name="ln770">        // If the weapon is a launcher, and the monster is either out</a>
<a name="ln771">        // of ammo or is carrying javelins, then don't bother upgrading</a>
<a name="ln772">        // the launcher.</a>
<a name="ln773">        if (is_range_weapon(item)</a>
<a name="ln774">            &amp;&amp; (mon-&gt;inv[MSLOT_MISSILE] == NON_ITEM</a>
<a name="ln775">                || !has_launcher(mitm[mon-&gt;inv[MSLOT_MISSILE]])))</a>
<a name="ln776">        {</a>
<a name="ln777">            return false;</a>
<a name="ln778">        }</a>
<a name="ln779"> </a>
<a name="ln780">        if (get_weapon_brand(item) == SPWPN_NORMAL)</a>
<a name="ln781">            return true;</a>
<a name="ln782">    }</a>
<a name="ln783"> </a>
<a name="ln784">    return false;</a>
<a name="ln785">}</a>
<a name="ln786"> </a>
<a name="ln787">static bool _choose_chaos_upgrade(const monster&amp; mon)</a>
<a name="ln788">{</a>
<a name="ln789">    // Only choose monsters that will attack.</a>
<a name="ln790">    if (!mon.alive() || mons_attitude(mon) != ATT_HOSTILE</a>
<a name="ln791">        || mons_is_fleeing(mon))</a>
<a name="ln792">    {</a>
<a name="ln793">        return false;</a>
<a name="ln794">    }</a>
<a name="ln795"> </a>
<a name="ln796">    if (mons_itemuse(mon) &lt; MONUSE_STARTING_EQUIPMENT)</a>
<a name="ln797">        return false;</a>
<a name="ln798"> </a>
<a name="ln799">    // Holy beings are presumably protected by another god, unless</a>
<a name="ln800">    // they're gifts from a chaotic god.</a>
<a name="ln801">    if (mon.is_holy() &amp;&amp; !is_chaotic_god(mon.god))</a>
<a name="ln802">        return false;</a>
<a name="ln803"> </a>
<a name="ln804">    // God gifts from good gods will be protected by their god from</a>
<a name="ln805">    // being given chaos weapons, while other gods won't mind the help</a>
<a name="ln806">    // in their servants' killing the player.</a>
<a name="ln807">    if (is_good_god(mon.god))</a>
<a name="ln808">        return false;</a>
<a name="ln809"> </a>
<a name="ln810">    // Beogh presumably doesn't want Xom messing with his orcs, even if</a>
<a name="ln811">    // it would give them a better weapon.</a>
<a name="ln812">    if (mons_genus(mon.type) == MONS_ORC</a>
<a name="ln813">        &amp;&amp; (mon.is_priest() || coinflip()))</a>
<a name="ln814">    {</a>
<a name="ln815">        return false;</a>
<a name="ln816">    }</a>
<a name="ln817"> </a>
<a name="ln818">    mon_inv_type slots[] = {MSLOT_WEAPON, MSLOT_ALT_WEAPON, MSLOT_MISSILE};</a>
<a name="ln819"> </a>
<a name="ln820">    // NOTE: Code assumes that the monster will only be carrying one</a>
<a name="ln821">    // missile launcher at a time.</a>
<a name="ln822">    bool special_launcher = false;</a>
<a name="ln823">    for (int i = 0; i &lt; 3; ++i)</a>
<a name="ln824">    {</a>
<a name="ln825">        const mon_inv_type slot = slots[i];</a>
<a name="ln826">        const int          midx = mon.inv[slot];</a>
<a name="ln827"> </a>
<a name="ln828">        if (midx == NON_ITEM)</a>
<a name="ln829">            continue;</a>
<a name="ln830">        const item_def &amp;item(mitm[midx]);</a>
<a name="ln831"> </a>
<a name="ln832">        // The monster already has a chaos weapon. Give the upgrade to</a>
<a name="ln833">        // a different monster.</a>
<a name="ln834">        if (is_chaotic_item(item))</a>
<a name="ln835">            return false;</a>
<a name="ln836"> </a>
<a name="ln837">        if (_is_chaos_upgradeable(item, &amp;mon))</a>
<a name="ln838">        {</a>
<a name="ln839">            if (item.base_type != OBJ_MISSILES)</a>
<a name="ln840">                return true;</a>
<a name="ln841"> </a>
<a name="ln842">            // If, for some weird reason, a monster is carrying a bow</a>
<a name="ln843">            // and javelins, then branding the javelins is okay, since</a>
<a name="ln844">            // they won't be fired by the bow.</a>
<a name="ln845">            if (!special_launcher || !has_launcher(item))</a>
<a name="ln846">                return true;</a>
<a name="ln847">        }</a>
<a name="ln848"> </a>
<a name="ln849">        if (is_range_weapon(item))</a>
<a name="ln850">        {</a>
<a name="ln851">            // If the launcher alters its ammo, then branding the</a>
<a name="ln852">            // monster's ammo won't be an upgrade.</a>
<a name="ln853">            int brand = get_weapon_brand(item);</a>
<a name="ln854">            if (brand == SPWPN_FLAMING || brand == SPWPN_FREEZING</a>
<a name="ln855">                || brand == SPWPN_VENOM)</a>
<a name="ln856">            {</a>
<a name="ln857">                special_launcher = true;</a>
<a name="ln858">            }</a>
<a name="ln859">        }</a>
<a name="ln860">    }</a>
<a name="ln861"> </a>
<a name="ln862">    return false;</a>
<a name="ln863">}</a>
<a name="ln864"> </a>
<a name="ln865">static void _do_chaos_upgrade(item_def &amp;item, const monster* mon)</a>
<a name="ln866">{</a>
<a name="ln867">    ASSERT(item.base_type == OBJ_MISSILES</a>
<a name="ln868">           || item.base_type == OBJ_WEAPONS);</a>
<a name="ln869">    ASSERT(!is_unrandom_artefact(item));</a>
<a name="ln870"> </a>
<a name="ln871">    bool seen = false;</a>
<a name="ln872">    if (mon &amp;&amp; you.can_see(*mon) &amp;&amp; item.base_type == OBJ_WEAPONS)</a>
<a name="ln873">    {</a>
<a name="ln874">        seen = true;</a>
<a name="ln875"> </a>
<a name="ln876">        description_level_type desc = mon-&gt;friendly() ? DESC_YOUR :</a>
<a name="ln877">                                                        DESC_THE;</a>
<a name="ln878">        string msg = apostrophise(mon-&gt;name(desc));</a>
<a name="ln879"> </a>
<a name="ln880">        msg += &quot; &quot;;</a>
<a name="ln881"> </a>
<a name="ln882">        msg += item.name(DESC_PLAIN, false, false, false);</a>
<a name="ln883"> </a>
<a name="ln884">        msg += &quot; is briefly surrounded by a scintillating aura of &quot;</a>
<a name="ln885">               &quot;random colours.&quot;;</a>
<a name="ln886"> </a>
<a name="ln887">        mpr(msg);</a>
<a name="ln888">    }</a>
<a name="ln889"> </a>
<a name="ln890">    const int brand = (item.base_type == OBJ_WEAPONS) ? (int) SPWPN_CHAOS</a>
<a name="ln891">                                                      : (int) SPMSL_CHAOS;</a>
<a name="ln892"> </a>
<a name="ln893">    if (is_random_artefact(item))</a>
<a name="ln894">    {</a>
<a name="ln895">        artefact_set_property(item, ARTP_BRAND, brand);</a>
<a name="ln896"> </a>
<a name="ln897">        if (seen)</a>
<a name="ln898">            artefact_learn_prop(item, ARTP_BRAND);</a>
<a name="ln899">    }</a>
<a name="ln900">    else</a>
<a name="ln901">    {</a>
<a name="ln902">        item.brand = brand;</a>
<a name="ln903"> </a>
<a name="ln904">        if (seen)</a>
<a name="ln905">            set_ident_flags(item, ISFLAG_KNOW_TYPE);</a>
<a name="ln906"> </a>
<a name="ln907">        // Make sure it's visibly special.</a>
<a name="ln908">        if (!(item.flags &amp; ISFLAG_COSMETIC_MASK))</a>
<a name="ln909">            item.flags |= ISFLAG_GLOWING;</a>
<a name="ln910"> </a>
<a name="ln911">        // Make the pluses more like a randomly generated ego item.</a>
<a name="ln912">        if (item.base_type == OBJ_WEAPONS)</a>
<a name="ln913">            item.plus  += random2(5);</a>
<a name="ln914">    }</a>
<a name="ln915">}</a>
<a name="ln916"> </a>
<a name="ln917">static monster_type _xom_random_demon(int sever)</a>
<a name="ln918">{</a>
<a name="ln919">    const int roll = random2(1000 - (MAX_PIETY - sever) * 5);</a>
<a name="ln920">#ifdef DEBUG_DIAGNOSTICS</a>
<a name="ln921">    mprf(MSGCH_DIAGNOSTICS, &quot;_xom_random_demon(); sever = %d, roll: %d&quot;,</a>
<a name="ln922">         sever, roll);</a>
<a name="ln923">#endif</a>
<a name="ln924">    monster_type dct = (roll &gt;= 340) ? RANDOM_DEMON_COMMON</a>
<a name="ln925">                                     : RANDOM_DEMON_LESSER;</a>
<a name="ln926"> </a>
<a name="ln927">    monster_type demon = MONS_PROGRAM_BUG;</a>
<a name="ln928"> </a>
<a name="ln929">    if (dct == RANDOM_DEMON_COMMON &amp;&amp; one_chance_in(10))</a>
<a name="ln930">        demon = MONS_CHAOS_SPAWN;</a>
<a name="ln931">    else</a>
<a name="ln932">        demon = summon_any_demon(dct);</a>
<a name="ln933"> </a>
<a name="ln934">    return demon;</a>
<a name="ln935">}</a>
<a name="ln936"> </a>
<a name="ln937">static bool _player_is_dead()</a>
<a name="ln938">{</a>
<a name="ln939">    return you.hp &lt;= 0</a>
<a name="ln940">        || is_feat_dangerous(grd(you.pos()))</a>
<a name="ln941">        || you.did_escape_death();</a>
<a name="ln942">}</a>
<a name="ln943"> </a>
<a name="ln944">static void _note_potion_effect(potion_type pot)</a>
<a name="ln945">{</a>
<a name="ln946">    string potion_name = potion_type_name(static_cast&lt;int&gt;(pot));</a>
<a name="ln947"> </a>
<a name="ln948">    string potion_msg = &quot;potion effect &quot;;</a>
<a name="ln949"> </a>
<a name="ln950">    potion_msg += (&quot;(&quot; + potion_name + &quot;)&quot;);</a>
<a name="ln951"> </a>
<a name="ln952">    take_note(Note(NOTE_XOM_EFFECT, you.piety, -1, potion_msg), true);</a>
<a name="ln953">}</a>
<a name="ln954"> </a>
<a name="ln955"> </a>
<a name="ln956">/// Feed the player a notionally-good potion effect.</a>
<a name="ln957">static void _xom_do_potion(int /*sever*/)</a>
<a name="ln958">{</a>
<a name="ln959">    potion_type pot = POT_CURING;</a>
<a name="ln960">    do</a>
<a name="ln961">    {</a>
<a name="ln962">        pot = random_choose_weighted(10, POT_CURING,</a>
<a name="ln963">                                     10, POT_HEAL_WOUNDS,</a>
<a name="ln964">                                     10, POT_MAGIC,</a>
<a name="ln965">                                     10, POT_HASTE,</a>
<a name="ln966">                                     10, POT_MIGHT,</a>
<a name="ln967">                                     10, POT_STABBING,</a>
<a name="ln968">                                     10, POT_BRILLIANCE,</a>
<a name="ln969">                                     10, POT_INVISIBILITY,</a>
<a name="ln970">                                     5,  POT_BERSERK_RAGE,</a>
<a name="ln971">                                     1,  POT_EXPERIENCE);</a>
<a name="ln972">    }</a>
<a name="ln973">    while (!get_potion_effect(pot)-&gt;can_quaff()); // ugh</a>
<a name="ln974"> </a>
<a name="ln975">    god_speaks(GOD_XOM, _get_xom_speech(&quot;potion effect&quot;).c_str());</a>
<a name="ln976"> </a>
<a name="ln977">    if (pot == POT_INVISIBILITY)</a>
<a name="ln978">        you.attribute[ATTR_INVIS_UNCANCELLABLE] = 1;</a>
<a name="ln979"> </a>
<a name="ln980">    _note_potion_effect(pot);</a>
<a name="ln981"> </a>
<a name="ln982">    get_potion_effect(pot)-&gt;effect(true, 150);</a>
<a name="ln983"> </a>
<a name="ln984">    level_change(); // need this for !xp - see mantis #3245</a>
<a name="ln985">}</a>
<a name="ln986"> </a>
<a name="ln987">static void _confuse_monster(monster* mons, int sever)</a>
<a name="ln988">{</a>
<a name="ln989">    if (mons-&gt;check_clarity())</a>
<a name="ln990">        return;</a>
<a name="ln991">    if (mons-&gt;holiness() &amp; (MH_NONLIVING | MH_PLANT))</a>
<a name="ln992">        return;</a>
<a name="ln993"> </a>
<a name="ln994">    const bool was_confused = mons-&gt;confused();</a>
<a name="ln995">    if (mons-&gt;add_ench(mon_enchant(ENCH_CONFUSION, 0,</a>
<a name="ln996">          &amp;menv[ANON_FRIENDLY_MONSTER], random2(sever) * 10)))</a>
<a name="ln997">    {</a>
<a name="ln998">        if (was_confused)</a>
<a name="ln999">            simple_monster_message(*mons, &quot; looks rather more confused.&quot;);</a>
<a name="ln1000">        else</a>
<a name="ln1001">            simple_monster_message(*mons, &quot; looks rather confused.&quot;);</a>
<a name="ln1002">    }</a>
<a name="ln1003">}</a>
<a name="ln1004"> </a>
<a name="ln1005">static void _xom_confuse_monsters(int sever)</a>
<a name="ln1006">{</a>
<a name="ln1007">    bool spoke = false;</a>
<a name="ln1008">    for (monster_near_iterator mi(you.pos(), LOS_NO_TRANS); mi; ++mi)</a>
<a name="ln1009">    {</a>
<a name="ln1010">        if (mi-&gt;wont_attack() || one_chance_in(20))</a>
<a name="ln1011">            continue;</a>
<a name="ln1012"> </a>
<a name="ln1013">        // Only give this message once.</a>
<a name="ln1014">        if (!spoke)</a>
<a name="ln1015">            god_speaks(GOD_XOM, _get_xom_speech(&quot;confusion&quot;).c_str());</a>
<a name="ln1016">        spoke = true;</a>
<a name="ln1017"> </a>
<a name="ln1018">        _confuse_monster(*mi, sever);</a>
<a name="ln1019">    }</a>
<a name="ln1020"> </a>
<a name="ln1021">    if (spoke)</a>
<a name="ln1022">    {</a>
<a name="ln1023">        take_note(Note(NOTE_XOM_EFFECT, you.piety, -1, &quot;confuse monster(s)&quot;),</a>
<a name="ln1024">                  true);</a>
<a name="ln1025">    }</a>
<a name="ln1026">}</a>
<a name="ln1027"> </a>
<a name="ln1028">/// Post a passel of pals to the player.</a>
<a name="ln1029">static void _xom_send_allies(int sever)</a>
<a name="ln1030">{</a>
<a name="ln1031">    // The number of allies is dependent on severity, though heavily</a>
<a name="ln1032">    // randomised.</a>
<a name="ln1033">    int numdemons = sever;</a>
<a name="ln1034">    for (int i = 0; i &lt; 3; i++)</a>
<a name="ln1035">        numdemons = random2(numdemons + 1);</a>
<a name="ln1036">    numdemons = min(numdemons + 2, 16);</a>
<a name="ln1037"> </a>
<a name="ln1038">    // Limit number of demons by experience level.</a>
<a name="ln1039">    const int maxdemons = (you.experience_level);</a>
<a name="ln1040">    if (numdemons &gt; maxdemons)</a>
<a name="ln1041">        numdemons = maxdemons;</a>
<a name="ln1042"> </a>
<a name="ln1043">    int num_actually_summoned = 0;</a>
<a name="ln1044"> </a>
<a name="ln1045">    for (int i = 0; i &lt; numdemons; ++i)</a>
<a name="ln1046">    {</a>
<a name="ln1047">        monster_type mon_type = _xom_random_demon(sever);</a>
<a name="ln1048"> </a>
<a name="ln1049">        mgen_data mg(mon_type, BEH_FRIENDLY, you.pos(), MHITYOU, MG_FORCE_BEH);</a>
<a name="ln1050">        mg.set_summoned(&amp;you, 3, MON_SUMM_AID, GOD_XOM);</a>
<a name="ln1051"> </a>
<a name="ln1052">        // Even though the friendlies are charged to you for accounting,</a>
<a name="ln1053">        // they should still show as Xom's fault if one of them kills you.</a>
<a name="ln1054">        mg.non_actor_summoner = &quot;Xom&quot;;</a>
<a name="ln1055"> </a>
<a name="ln1056">        if (create_monster(mg))</a>
<a name="ln1057">            num_actually_summoned++;</a>
<a name="ln1058">    }</a>
<a name="ln1059"> </a>
<a name="ln1060">    if (num_actually_summoned)</a>
<a name="ln1061">    {</a>
<a name="ln1062">        god_speaks(GOD_XOM, _get_xom_speech(&quot;multiple summons&quot;).c_str());</a>
<a name="ln1063"> </a>
<a name="ln1064">        const string note = make_stringf(&quot;summons %d friendly demon%s&quot;,</a>
<a name="ln1065">                                         num_actually_summoned,</a>
<a name="ln1066">                                         num_actually_summoned &gt; 1 ? &quot;s&quot; : &quot;&quot;);</a>
<a name="ln1067">        take_note(Note(NOTE_XOM_EFFECT, you.piety, -1, note), true);</a>
<a name="ln1068">    }</a>
<a name="ln1069">}</a>
<a name="ln1070"> </a>
<a name="ln1071">/// Send a single pal to the player's aid, hopefully.</a>
<a name="ln1072">static void _xom_send_one_ally(int sever)</a>
<a name="ln1073">{</a>
<a name="ln1074">    const monster_type mon_type = _xom_random_demon(sever);</a>
<a name="ln1075"> </a>
<a name="ln1076">    mgen_data mg(mon_type, BEH_FRIENDLY, you.pos(), MHITYOU, MG_FORCE_BEH);</a>
<a name="ln1077">    mg.set_summoned(&amp;you, 6, MON_SUMM_AID, GOD_XOM);</a>
<a name="ln1078"> </a>
<a name="ln1079">    mg.non_actor_summoner = &quot;Xom&quot;;</a>
<a name="ln1080"> </a>
<a name="ln1081">    if (monster *summons = create_monster(mg))</a>
<a name="ln1082">    {</a>
<a name="ln1083">        god_speaks(GOD_XOM, _get_xom_speech(&quot;single summon&quot;).c_str());</a>
<a name="ln1084"> </a>
<a name="ln1085">        const string note = make_stringf(&quot;summons friendly %s&quot;,</a>
<a name="ln1086">                                         summons-&gt;name(DESC_PLAIN).c_str());</a>
<a name="ln1087">        take_note(Note(NOTE_XOM_EFFECT, you.piety, -1, note), true);</a>
<a name="ln1088">    }</a>
<a name="ln1089">}</a>
<a name="ln1090"> </a>
<a name="ln1091">/**</a>
<a name="ln1092"> * Try to polymorph the given monster. If 'helpful', hostile monsters will</a>
<a name="ln1093"> * (try to) turn into weaker ones, and friendly monsters into stronger ones;</a>
<a name="ln1094"> * if (!helpful), the reverse is true.</a>
<a name="ln1095"> *</a>
<a name="ln1096"> * @param mons      The monster in question.</a>
<a name="ln1097"> * @param helpful   Whether to try to be helpful.</a>
<a name="ln1098"> */</a>
<a name="ln1099">static void _xom_polymorph_monster(monster &amp;mons, bool helpful)</a>
<a name="ln1100">{</a>
<a name="ln1101">    god_speaks(GOD_XOM,</a>
<a name="ln1102">               helpful ? _get_xom_speech(&quot;good monster polymorph&quot;).c_str()</a>
<a name="ln1103">                       : _get_xom_speech(&quot;bad monster polymorph&quot;).c_str());</a>
<a name="ln1104"> </a>
<a name="ln1105">    const bool see_old = you.can_see(mons);</a>
<a name="ln1106">    const string old_name = see_old ? mons.full_name(DESC_PLAIN)</a>
<a name="ln1107">                                    : &quot;something unseen&quot;;</a>
<a name="ln1108"> </a>
<a name="ln1109">    if (one_chance_in(8)</a>
<a name="ln1110">        &amp;&amp; !mons_is_ghost_demon(mons.type)</a>
<a name="ln1111">        &amp;&amp; !mons.is_shapeshifter()</a>
<a name="ln1112">        &amp;&amp; mons.holiness() &amp; MH_NATURAL)</a>
<a name="ln1113">    {</a>
<a name="ln1114">        mons.add_ench(one_chance_in(3) ? ENCH_GLOWING_SHAPESHIFTER</a>
<a name="ln1115">                                       : ENCH_SHAPESHIFTER);</a>
<a name="ln1116">    }</a>
<a name="ln1117"> </a>
<a name="ln1118">    const bool powerup = !(mons.wont_attack() ^ helpful);</a>
<a name="ln1119">    mons.polymorph(powerup ? PPT_MORE : PPT_LESS);</a>
<a name="ln1120"> </a>
<a name="ln1121">    const bool see_new = you.can_see(mons);</a>
<a name="ln1122"> </a>
<a name="ln1123">    if (see_old || see_new)</a>
<a name="ln1124">    {</a>
<a name="ln1125">        const string new_name = see_new ? mons.full_name(DESC_PLAIN)</a>
<a name="ln1126">                                        : &quot;something unseen&quot;;</a>
<a name="ln1127"> </a>
<a name="ln1128">        string note = make_stringf(&quot;polymorph %s -&gt; %s&quot;,</a>
<a name="ln1129">                                   old_name.c_str(), new_name.c_str());</a>
<a name="ln1130"> </a>
<a name="ln1131">#ifdef NOTE_DEBUG_XOM</a>
<a name="ln1132">        note += &quot; (&quot;;</a>
<a name="ln1133">        note += (powerup ? &quot;upgrade&quot; : &quot;downgrade&quot;);</a>
<a name="ln1134">        note += &quot;)&quot;;</a>
<a name="ln1135">#endif</a>
<a name="ln1136">        take_note(Note(NOTE_XOM_EFFECT, you.piety, -1, note), true);</a>
<a name="ln1137">    }</a>
<a name="ln1138">}</a>
<a name="ln1139"> </a>
<a name="ln1140">/// Find a monster to poly.</a>
<a name="ln1141">static monster* _xom_mons_poly_target()</a>
<a name="ln1142">{</a>
<a name="ln1143">    for (monster_near_iterator mi(you.pos(), LOS_NO_TRANS); mi; ++mi)</a>
<a name="ln1144">        if (_choose_mutatable_monster(**mi) &amp;&amp; !mons_is_firewood(**mi))</a>
<a name="ln1145">            return *mi;</a>
<a name="ln1146">    return nullptr;</a>
<a name="ln1147">}</a>
<a name="ln1148"> </a>
<a name="ln1149">/// Try to polymporph a nearby monster into something weaker... or stronger.</a>
<a name="ln1150">static void _xom_polymorph_nearby_monster(bool helpful)</a>
<a name="ln1151">{</a>
<a name="ln1152">    monster* mon = _xom_mons_poly_target();</a>
<a name="ln1153">    if (mon)</a>
<a name="ln1154">        _xom_polymorph_monster(*mon, helpful);</a>
<a name="ln1155">}</a>
<a name="ln1156"> </a>
<a name="ln1157">/// Try to polymporph a nearby monster into something weaker.</a>
<a name="ln1158">static void _xom_good_polymorph(int /*sever*/)</a>
<a name="ln1159">{</a>
<a name="ln1160">    _xom_polymorph_nearby_monster(true);</a>
<a name="ln1161">}</a>
<a name="ln1162"> </a>
<a name="ln1163">/// Try to polymporph a nearby monster into something stronger.</a>
<a name="ln1164">static void _xom_bad_polymorph(int /*sever*/)</a>
<a name="ln1165">{</a>
<a name="ln1166">    _xom_polymorph_nearby_monster(false);</a>
<a name="ln1167">}</a>
<a name="ln1168"> </a>
<a name="ln1169">bool swap_monsters(monster* m1, monster* m2)</a>
<a name="ln1170">{</a>
<a name="ln1171">    monster&amp; mon1(*m1);</a>
<a name="ln1172">    monster&amp; mon2(*m2);</a>
<a name="ln1173"> </a>
<a name="ln1174">    const bool mon1_caught = mon1.caught();</a>
<a name="ln1175">    const bool mon2_caught = mon2.caught();</a>
<a name="ln1176"> </a>
<a name="ln1177">    // Make submerged monsters unsubmerge.</a>
<a name="ln1178">    mon1.del_ench(ENCH_SUBMERGED);</a>
<a name="ln1179">    mon2.del_ench(ENCH_SUBMERGED);</a>
<a name="ln1180"> </a>
<a name="ln1181">    mon1.swap_with(m2);</a>
<a name="ln1182"> </a>
<a name="ln1183">    if (mon1_caught &amp;&amp; !mon2_caught)</a>
<a name="ln1184">    {</a>
<a name="ln1185">        check_net_will_hold_monster(&amp;mon2);</a>
<a name="ln1186">        mon1.del_ench(ENCH_HELD, true);</a>
<a name="ln1187"> </a>
<a name="ln1188">    }</a>
<a name="ln1189">    else if (mon2_caught &amp;&amp; !mon1_caught)</a>
<a name="ln1190">    {</a>
<a name="ln1191">        check_net_will_hold_monster(&amp;mon1);</a>
<a name="ln1192">        mon2.del_ench(ENCH_HELD, true);</a>
<a name="ln1193">    }</a>
<a name="ln1194"> </a>
<a name="ln1195">    return true;</a>
<a name="ln1196">}</a>
<a name="ln1197"> </a>
<a name="ln1198">/// Which monsters, if any, can Xom currently swap with the player?</a>
<a name="ln1199">static vector&lt;monster*&gt; _rearrangeable_pieces()</a>
<a name="ln1200">{</a>
<a name="ln1201">    vector&lt;monster* &gt; mons;</a>
<a name="ln1202">    if (player_stair_delay() || monster_at(you.pos()))</a>
<a name="ln1203">        return mons;</a>
<a name="ln1204"> </a>
<a name="ln1205">    for (monster_near_iterator mi(&amp;you, LOS_NO_TRANS); mi; ++mi)</a>
<a name="ln1206">    {</a>
<a name="ln1207">        if (!mons_is_tentacle_or_tentacle_segment(mi-&gt;type))</a>
<a name="ln1208">            mons.push_back(*mi);</a>
<a name="ln1209">    }</a>
<a name="ln1210">    return mons;</a>
<a name="ln1211">}</a>
<a name="ln1212"> </a>
<a name="ln1213">// Swap places with a random monster and, depending on severity, also</a>
<a name="ln1214">// between monsters. This can be pretty bad if there are a lot of</a>
<a name="ln1215">// hostile monsters around.</a>
<a name="ln1216">static void _xom_rearrange_pieces(int sever)</a>
<a name="ln1217">{</a>
<a name="ln1218">    vector&lt;monster*&gt; mons = _rearrangeable_pieces();</a>
<a name="ln1219">    if (mons.empty())</a>
<a name="ln1220">        return;</a>
<a name="ln1221"> </a>
<a name="ln1222">    god_speaks(GOD_XOM, _get_xom_speech(&quot;rearrange the pieces&quot;).c_str());</a>
<a name="ln1223"> </a>
<a name="ln1224">    const int num_mons = mons.size();</a>
<a name="ln1225"> </a>
<a name="ln1226">    // Swap places with a random monster.</a>
<a name="ln1227">    monster* mon = mons[random2(num_mons)];</a>
<a name="ln1228">    swap_with_monster(mon);</a>
<a name="ln1229"> </a>
<a name="ln1230">    // Sometimes confuse said monster.</a>
<a name="ln1231">    if (coinflip())</a>
<a name="ln1232">        _confuse_monster(mon, sever);</a>
<a name="ln1233"> </a>
<a name="ln1234">    if (num_mons &gt; 1 &amp;&amp; x_chance_in_y(sever, 70))</a>
<a name="ln1235">    {</a>
<a name="ln1236">        bool did_message = false;</a>
<a name="ln1237">        const int max_repeats = min(num_mons / 2, 8);</a>
<a name="ln1238">        const int repeats     = min(random2(sever / 10) + 1, max_repeats);</a>
<a name="ln1239">        for (int i = 0; i &lt; repeats; ++i)</a>
<a name="ln1240">        {</a>
<a name="ln1241">            const int mon1 = random2(num_mons);</a>
<a name="ln1242">            int mon2 = mon1;</a>
<a name="ln1243">            while (mon1 == mon2)</a>
<a name="ln1244">                mon2 = random2(num_mons);</a>
<a name="ln1245"> </a>
<a name="ln1246">            if (swap_monsters(mons[mon1], mons[mon2]))</a>
<a name="ln1247">            {</a>
<a name="ln1248">                if (!did_message)</a>
<a name="ln1249">                {</a>
<a name="ln1250">                    mpr(&quot;Some monsters swap places.&quot;);</a>
<a name="ln1251">                    did_message = true;</a>
<a name="ln1252">                }</a>
<a name="ln1253">                if (one_chance_in(4))</a>
<a name="ln1254">                    _confuse_monster(mons[mon1], sever);</a>
<a name="ln1255">                if (one_chance_in(4))</a>
<a name="ln1256">                    _confuse_monster(mons[mon2], sever);</a>
<a name="ln1257">            }</a>
<a name="ln1258">        }</a>
<a name="ln1259">    }</a>
<a name="ln1260">    take_note(Note(NOTE_XOM_EFFECT, you.piety, -1, &quot;swap monsters&quot;), true);</a>
<a name="ln1261">}</a>
<a name="ln1262"> </a>
<a name="ln1263">static int _xom_random_stickable(const int HD)</a>
<a name="ln1264">{</a>
<a name="ln1265">    unsigned int c;</a>
<a name="ln1266"> </a>
<a name="ln1267">    static const int arr[] =</a>
<a name="ln1268">    {</a>
<a name="ln1269">        WPN_CLUB,    WPN_SPEAR,      WPN_TRIDENT,      WPN_HALBERD,</a>
<a name="ln1270">        WPN_SCYTHE,  WPN_GLAIVE,     WPN_QUARTERSTAFF,</a>
<a name="ln1271">        WPN_SHORTBOW,   WPN_LONGBOW,      WPN_GIANT_CLUB,</a>
<a name="ln1272">        WPN_GIANT_SPIKED_CLUB</a>
<a name="ln1273">    };</a>
<a name="ln1274"> </a>
<a name="ln1275">    // Maximum snake hd is 11 (anaconda) so random2(hd) gives us 0-10, and</a>
<a name="ln1276">    // weapon_rarity also gives us 1-10.</a>
<a name="ln1277">    do</a>
<a name="ln1278">    {</a>
<a name="ln1279">        c = random2(HD);</a>
<a name="ln1280">    }</a>
<a name="ln1281">    while (c &gt;= ARRAYSZ(arr)</a>
<a name="ln1282">           || random2(HD) &gt; weapon_rarity(arr[c]) &amp;&amp; x_chance_in_y(c, HD));</a>
<a name="ln1283"> </a>
<a name="ln1284">    return arr[c];</a>
<a name="ln1285">}</a>
<a name="ln1286"> </a>
<a name="ln1287">static bool _hostile_snake(monster&amp; mon)</a>
<a name="ln1288">{</a>
<a name="ln1289">    return mon.attitude == ATT_HOSTILE</a>
<a name="ln1290">            &amp;&amp; mons_genus(mon.type) == MONS_SNAKE;</a>
<a name="ln1291">}</a>
<a name="ln1292"> </a>
<a name="ln1293">// An effect similar to old sticks to snakes (which worked on &quot;sticks&quot; other</a>
<a name="ln1294">// than arrows)</a>
<a name="ln1295">//  * Transformations are permanent.</a>
<a name="ln1296">//  * Weapons are always non-cursed.</a>
<a name="ln1297">//  * HD influences the enchantment and type of the weapon.</a>
<a name="ln1298">//  * Weapon is not guaranteed to be useful.</a>
<a name="ln1299">//  * Weapon will never be branded.</a>
<a name="ln1300">static void _xom_snakes_to_sticks(int /*sever*/)</a>
<a name="ln1301">{</a>
<a name="ln1302">    bool action = false;</a>
<a name="ln1303">    for (monster_near_iterator mi(you.pos(), LOS_NO_TRANS); mi; ++mi)</a>
<a name="ln1304">    {</a>
<a name="ln1305">        if (!_hostile_snake(**mi))</a>
<a name="ln1306">            continue;</a>
<a name="ln1307"> </a>
<a name="ln1308">        if (!action)</a>
<a name="ln1309">        {</a>
<a name="ln1310">            take_note(Note(NOTE_XOM_EFFECT, you.piety, -1,</a>
<a name="ln1311">                           &quot;snakes to sticks&quot;), true);</a>
<a name="ln1312">            god_speaks(GOD_XOM, _get_xom_speech(&quot;snakes to sticks&quot;).c_str());</a>
<a name="ln1313">            action = true;</a>
<a name="ln1314">        }</a>
<a name="ln1315"> </a>
<a name="ln1316">        const object_class_type base_type = x_chance_in_y(3,5) ? OBJ_MISSILES</a>
<a name="ln1317">                                                               : OBJ_WEAPONS;</a>
<a name="ln1318"> </a>
<a name="ln1319">        const int sub_type =</a>
<a name="ln1320">            (base_type == OBJ_MISSILES ?</a>
<a name="ln1321">             (x_chance_in_y(3,5) ? MI_ARROW : MI_JAVELIN)</a>
<a name="ln1322">             : _xom_random_stickable(mi-&gt;get_experience_level()));</a>
<a name="ln1323"> </a>
<a name="ln1324">        int item_slot = items(false, base_type, sub_type,</a>
<a name="ln1325">                              mi-&gt;get_experience_level() / 3 - 1,</a>
<a name="ln1326">                              0, -1);</a>
<a name="ln1327"> </a>
<a name="ln1328">        if (item_slot == NON_ITEM)</a>
<a name="ln1329">            continue;</a>
<a name="ln1330"> </a>
<a name="ln1331">        item_def &amp;item(mitm[item_slot]);</a>
<a name="ln1332"> </a>
<a name="ln1333">        // Always limit the quantity to 1.</a>
<a name="ln1334">        item.quantity = 1;</a>
<a name="ln1335"> </a>
<a name="ln1336">        // Output some text since otherwise snakes will disappear silently.</a>
<a name="ln1337">        mprf(&quot;%s reforms as %s.&quot;, mi-&gt;name(DESC_THE).c_str(),</a>
<a name="ln1338">             item.name(DESC_A).c_str());</a>
<a name="ln1339"> </a>
<a name="ln1340">        // Dismiss monster silently.</a>
<a name="ln1341">        move_item_to_grid(&amp;item_slot, mi-&gt;pos());</a>
<a name="ln1342">        monster_die(**mi, KILL_DISMISSED, NON_MONSTER, true, false);</a>
<a name="ln1343">    }</a>
<a name="ln1344">}</a>
<a name="ln1345"> </a>
<a name="ln1346">/// Try to find a nearby hostile monster with an animateable weapon.</a>
<a name="ln1347">static monster* _find_monster_with_animateable_weapon()</a>
<a name="ln1348">{</a>
<a name="ln1349">    vector&lt;monster* &gt; mons_wpn;</a>
<a name="ln1350">    for (monster_near_iterator mi(&amp;you, LOS_NO_TRANS); mi; ++mi)</a>
<a name="ln1351">    {</a>
<a name="ln1352">        if (mi-&gt;wont_attack() || mi-&gt;is_summoned()</a>
<a name="ln1353">            || mons_itemuse(**mi) &lt; MONUSE_STARTING_EQUIPMENT</a>
<a name="ln1354">            || (mi-&gt;flags &amp; MF_HARD_RESET))</a>
<a name="ln1355">        {</a>
<a name="ln1356">            continue;</a>
<a name="ln1357">        }</a>
<a name="ln1358"> </a>
<a name="ln1359">        const int mweap = mi-&gt;inv[MSLOT_WEAPON];</a>
<a name="ln1360">        if (mweap == NON_ITEM)</a>
<a name="ln1361">            continue;</a>
<a name="ln1362"> </a>
<a name="ln1363">        const item_def weapon = mitm[mweap];</a>
<a name="ln1364"> </a>
<a name="ln1365">        if (weapon.base_type == OBJ_WEAPONS</a>
<a name="ln1366">            &amp;&amp; !(weapon.flags &amp; ISFLAG_SUMMONED)</a>
<a name="ln1367">            &amp;&amp; weapon.quantity == 1</a>
<a name="ln1368">            &amp;&amp; !is_range_weapon(weapon)</a>
<a name="ln1369">            &amp;&amp; !is_special_unrandom_artefact(weapon)</a>
<a name="ln1370">            &amp;&amp; get_weapon_brand(weapon) != SPWPN_DISTORTION)</a>
<a name="ln1371">        {</a>
<a name="ln1372">            mons_wpn.push_back(*mi);</a>
<a name="ln1373">        }</a>
<a name="ln1374">    }</a>
<a name="ln1375">    if (mons_wpn.empty())</a>
<a name="ln1376">        return nullptr;</a>
<a name="ln1377">    return mons_wpn[random2(mons_wpn.size())];</a>
<a name="ln1378">}</a>
<a name="ln1379"> </a>
<a name="ln1380">static void _xom_animate_monster_weapon(int sever)</a>
<a name="ln1381">{</a>
<a name="ln1382">    // Pick a random monster...</a>
<a name="ln1383">    monster* mon = _find_monster_with_animateable_weapon();</a>
<a name="ln1384">    if (!mon)</a>
<a name="ln1385">        return;</a>
<a name="ln1386"> </a>
<a name="ln1387">    god_speaks(GOD_XOM, _get_xom_speech(&quot;animate monster weapon&quot;).c_str());</a>
<a name="ln1388"> </a>
<a name="ln1389">    // ...and get its weapon.</a>
<a name="ln1390">    const int wpn = mon-&gt;inv[MSLOT_WEAPON];</a>
<a name="ln1391">    ASSERT(wpn != NON_ITEM);</a>
<a name="ln1392"> </a>
<a name="ln1393">    const int dur = min(2 + (random2(sever) / 5), 6);</a>
<a name="ln1394"> </a>
<a name="ln1395">    mgen_data mg(MONS_DANCING_WEAPON, BEH_FRIENDLY, mon-&gt;pos(), mon-&gt;mindex());</a>
<a name="ln1396">    mg.set_summoned(&amp;you, dur, SPELL_TUKIMAS_DANCE, GOD_XOM);</a>
<a name="ln1397"> </a>
<a name="ln1398">    mg.non_actor_summoner = &quot;Xom&quot;;</a>
<a name="ln1399"> </a>
<a name="ln1400">    monster *dancing = create_monster(mg);</a>
<a name="ln1401"> </a>
<a name="ln1402">    if (!dancing)</a>
<a name="ln1403">        return;</a>
<a name="ln1404"> </a>
<a name="ln1405">    // Make the monster unwield its weapon.</a>
<a name="ln1406">    mon-&gt;unequip(*(mon-&gt;mslot_item(MSLOT_WEAPON)), false, true);</a>
<a name="ln1407">    mon-&gt;inv[MSLOT_WEAPON] = NON_ITEM;</a>
<a name="ln1408"> </a>
<a name="ln1409">    mprf(&quot;%s %s dances into the air!&quot;,</a>
<a name="ln1410">         apostrophise(mon-&gt;name(DESC_THE)).c_str(),</a>
<a name="ln1411">         mitm[wpn].name(DESC_PLAIN).c_str());</a>
<a name="ln1412"> </a>
<a name="ln1413">    destroy_item(dancing-&gt;inv[MSLOT_WEAPON]);</a>
<a name="ln1414"> </a>
<a name="ln1415">    dancing-&gt;inv[MSLOT_WEAPON] = wpn;</a>
<a name="ln1416">    mitm[wpn].set_holding_monster(*dancing);</a>
<a name="ln1417">    dancing-&gt;colour = mitm[wpn].get_colour();</a>
<a name="ln1418">}</a>
<a name="ln1419"> </a>
<a name="ln1420">static void _xom_give_mutations(bool good)</a>
<a name="ln1421">{</a>
<a name="ln1422">    if (!you.can_safely_mutate())</a>
<a name="ln1423">        return;</a>
<a name="ln1424"> </a>
<a name="ln1425">    god_speaks(GOD_XOM, good ? _get_xom_speech(&quot;good mutations&quot;).c_str()</a>
<a name="ln1426">                             : _get_xom_speech(&quot;random mutations&quot;).c_str());</a>
<a name="ln1427"> </a>
<a name="ln1428">    const int num_tries = random2(4) + 1;</a>
<a name="ln1429"> </a>
<a name="ln1430">    const string note = make_stringf(&quot;give %smutation%s&quot;,</a>
<a name="ln1431">#ifdef NOTE_DEBUG_XOM</a>
<a name="ln1432">             good ? &quot;good &quot; : &quot;random &quot;,</a>
<a name="ln1433">#else</a>
<a name="ln1434">             &quot;&quot;,</a>
<a name="ln1435">#endif</a>
<a name="ln1436">             num_tries &gt; 1 ? &quot;s&quot; : &quot;&quot;);</a>
<a name="ln1437"> </a>
<a name="ln1438">    take_note(Note(NOTE_XOM_EFFECT, you.piety, -1, note), true);</a>
<a name="ln1439">    mpr(&quot;Your body is suffused with distortional energy.&quot;);</a>
<a name="ln1440"> </a>
<a name="ln1441">    bool failMsg = true;</a>
<a name="ln1442"> </a>
<a name="ln1443">    for (int i = num_tries; i &gt; 0; --i)</a>
<a name="ln1444">    {</a>
<a name="ln1445">        if (!mutate(good ? RANDOM_GOOD_MUTATION : RANDOM_XOM_MUTATION,</a>
<a name="ln1446">                    good ? &quot;Xom's grace&quot; : &quot;Xom's mischief&quot;,</a>
<a name="ln1447">                    failMsg, false, true, false, MUTCLASS_NORMAL))</a>
<a name="ln1448">        {</a>
<a name="ln1449">            failMsg = false;</a>
<a name="ln1450">        }</a>
<a name="ln1451">    }</a>
<a name="ln1452">}</a>
<a name="ln1453"> </a>
<a name="ln1454">static void _xom_give_good_mutations(int) { _xom_give_mutations(true); }</a>
<a name="ln1455">static void _xom_give_bad_mutations(int) { _xom_give_mutations(false); }</a>
<a name="ln1456"> </a>
<a name="ln1457">/**</a>
<a name="ln1458"> * Have Xom throw divine lightning.</a>
<a name="ln1459"> */</a>
<a name="ln1460">static void _xom_throw_divine_lightning(int /*sever*/)</a>
<a name="ln1461">{</a>
<a name="ln1462">    god_speaks(GOD_XOM, &quot;The area is suffused with divine lightning!&quot;);</a>
<a name="ln1463"> </a>
<a name="ln1464">    bolt beam;</a>
<a name="ln1465"> </a>
<a name="ln1466">    beam.flavour      = BEAM_ELECTRICITY;</a>
<a name="ln1467">    beam.glyph        = dchar_glyph(DCHAR_FIRED_BURST);</a>
<a name="ln1468">    beam.damage       = dice_def(3, 30);</a>
<a name="ln1469">    beam.target       = you.pos();</a>
<a name="ln1470">    beam.name         = &quot;blast of lightning&quot;;</a>
<a name="ln1471">    beam.colour       = LIGHTCYAN;</a>
<a name="ln1472">    beam.thrower      = KILL_MISC;</a>
<a name="ln1473">    beam.source_id    = MID_NOBODY;</a>
<a name="ln1474">    beam.aux_source   = &quot;Xom's lightning strike&quot;;</a>
<a name="ln1475">    beam.ex_size      = 2;</a>
<a name="ln1476">    beam.is_explosion = true;</a>
<a name="ln1477"> </a>
<a name="ln1478">    beam.explode(true, true);</a>
<a name="ln1479"> </a>
<a name="ln1480">    take_note(Note(NOTE_XOM_EFFECT, you.piety, -1, &quot;divine lightning&quot;), true);</a>
<a name="ln1481">}</a>
<a name="ln1482"> </a>
<a name="ln1483">/// What scenery nearby would Xom like to mess with, if any?</a>
<a name="ln1484">static vector&lt;coord_def&gt; _xom_scenery_candidates()</a>
<a name="ln1485">{</a>
<a name="ln1486">    vector&lt;coord_def&gt; candidates;</a>
<a name="ln1487">    vector&lt;coord_def&gt; closed_doors;</a>
<a name="ln1488">    vector&lt;coord_def&gt; open_doors;</a>
<a name="ln1489">    for (radius_iterator ri(you.pos(), LOS_DEFAULT); ri; ++ri)</a>
<a name="ln1490">    {</a>
<a name="ln1491">        if (!you.see_cell(*ri))</a>
<a name="ln1492">            continue;</a>
<a name="ln1493"> </a>
<a name="ln1494">        dungeon_feature_type feat = grd(*ri);</a>
<a name="ln1495">        if (feat_is_fountain(feat))</a>
<a name="ln1496">            candidates.push_back(*ri);</a>
<a name="ln1497">        else if (feat_is_closed_door(feat))</a>
<a name="ln1498">        {</a>
<a name="ln1499">            // Check whether this door is already included in a gate.</a>
<a name="ln1500">            if (find(begin(closed_doors), end(closed_doors), *ri)</a>
<a name="ln1501">                == end(closed_doors))</a>
<a name="ln1502">            {</a>
<a name="ln1503">                // If it's a gate, add all doors belonging to the gate.</a>
<a name="ln1504">                set&lt;coord_def&gt; all_door;</a>
<a name="ln1505">                find_connected_identical(*ri, all_door);</a>
<a name="ln1506">                for (auto dc : all_door)</a>
<a name="ln1507">                    closed_doors.push_back(dc);</a>
<a name="ln1508">            }</a>
<a name="ln1509">        }</a>
<a name="ln1510">        else if (feat_is_open_door(feat) &amp;&amp; !actor_at(*ri)</a>
<a name="ln1511">                 &amp;&amp; igrd(*ri) == NON_ITEM)</a>
<a name="ln1512">        {</a>
<a name="ln1513">            // Check whether this door is already included in a gate.</a>
<a name="ln1514">            if (find(begin(open_doors), end(open_doors), *ri)</a>
<a name="ln1515">                == end(open_doors))</a>
<a name="ln1516">            {</a>
<a name="ln1517">                // Check whether any of the doors belonging to a gate is</a>
<a name="ln1518">                // blocked by an item or monster.</a>
<a name="ln1519">                set&lt;coord_def&gt; all_door;</a>
<a name="ln1520">                find_connected_identical(*ri, all_door);</a>
<a name="ln1521">                bool is_blocked = false;</a>
<a name="ln1522">                for (auto dc : all_door)</a>
<a name="ln1523">                {</a>
<a name="ln1524">                    if (actor_at(dc) || igrd(dc) != NON_ITEM)</a>
<a name="ln1525">                    {</a>
<a name="ln1526">                        is_blocked = true;</a>
<a name="ln1527">                        break;</a>
<a name="ln1528">                    }</a>
<a name="ln1529">                }</a>
<a name="ln1530"> </a>
<a name="ln1531">                // If the doorway isn't blocked, add all doors</a>
<a name="ln1532">                // belonging to the gate.</a>
<a name="ln1533">                if (!is_blocked)</a>
<a name="ln1534">                {</a>
<a name="ln1535">                    for (auto dc : all_door)</a>
<a name="ln1536">                        open_doors.push_back(dc);</a>
<a name="ln1537">                }</a>
<a name="ln1538">            }</a>
<a name="ln1539">        }</a>
<a name="ln1540">    }</a>
<a name="ln1541">    // Order needs to be the same as messaging below, else the messages might</a>
<a name="ln1542">    // not make sense.</a>
<a name="ln1543">    // FIXME: Changed fountains behind doors are not properly remembered.</a>
<a name="ln1544">    //        (At least in tiles.)</a>
<a name="ln1545">    candidates.insert(end(candidates), begin(open_doors), end(open_doors));</a>
<a name="ln1546">    candidates.insert(end(candidates), begin(closed_doors), end(closed_doors));</a>
<a name="ln1547"> </a>
<a name="ln1548">    return candidates;</a>
<a name="ln1549">}</a>
<a name="ln1550"> </a>
<a name="ln1551">/// Place one or more altars to Xom nearish the player.</a>
<a name="ln1552">static void _xom_place_altars()</a>
<a name="ln1553">{</a>
<a name="ln1554">    coord_def place;</a>
<a name="ln1555">    bool success = false;</a>
<a name="ln1556">    const int max_altars = max(1, random2(random2(14)));</a>
<a name="ln1557">    for (int tries = max_altars; tries &gt; 0; --tries)</a>
<a name="ln1558">    {</a>
<a name="ln1559">        if ((random_near_space(&amp;you, you.pos(), place, false)</a>
<a name="ln1560">             || random_near_space(&amp;you, you.pos(), place, true))</a>
<a name="ln1561">            &amp;&amp; grd(place) == DNGN_FLOOR)</a>
<a name="ln1562">        {</a>
<a name="ln1563">            grd(place) = DNGN_ALTAR_XOM;</a>
<a name="ln1564">            success = true;</a>
<a name="ln1565">        }</a>
<a name="ln1566">    }</a>
<a name="ln1567"> </a>
<a name="ln1568">    if (success)</a>
<a name="ln1569">    {</a>
<a name="ln1570">        take_note(Note(NOTE_XOM_EFFECT, you.piety, -1,</a>
<a name="ln1571">                       &quot;scenery: create altars&quot;), true);</a>
<a name="ln1572">        god_speaks(GOD_XOM, _get_xom_speech(&quot;scenery&quot;).c_str());</a>
<a name="ln1573">    }</a>
<a name="ln1574">}</a>
<a name="ln1575"> </a>
<a name="ln1576">/// Mess with nearby terrain features, more-or-less harmlessly.</a>
<a name="ln1577">static void _xom_change_scenery(int /*sever*/)</a>
<a name="ln1578">{</a>
<a name="ln1579">    vector&lt;coord_def&gt; candidates = _xom_scenery_candidates();</a>
<a name="ln1580"> </a>
<a name="ln1581">    if (candidates.empty())</a>
<a name="ln1582">    {</a>
<a name="ln1583">        _xom_place_altars();</a>
<a name="ln1584">        return;</a>
<a name="ln1585">    }</a>
<a name="ln1586"> </a>
<a name="ln1587">    int fountains_blood = 0;</a>
<a name="ln1588">    int doors_open      = 0;</a>
<a name="ln1589">    int doors_close     = 0;</a>
<a name="ln1590">    for (coord_def pos : candidates)</a>
<a name="ln1591">    {</a>
<a name="ln1592">        switch (grd(pos))</a>
<a name="ln1593">        {</a>
<a name="ln1594">        case DNGN_CLOSED_DOOR:</a>
<a name="ln1595">        case DNGN_CLOSED_CLEAR_DOOR:</a>
<a name="ln1596">        case DNGN_RUNED_DOOR:</a>
<a name="ln1597">        case DNGN_RUNED_CLEAR_DOOR:</a>
<a name="ln1598">            dgn_open_door(pos);</a>
<a name="ln1599">            set_terrain_changed(pos);</a>
<a name="ln1600">            if (you.see_cell(pos))</a>
<a name="ln1601">                doors_open++;</a>
<a name="ln1602">            break;</a>
<a name="ln1603">        case DNGN_OPEN_DOOR:</a>
<a name="ln1604">        case DNGN_OPEN_CLEAR_DOOR:</a>
<a name="ln1605">            dgn_close_door(pos);</a>
<a name="ln1606">            set_terrain_changed(pos);</a>
<a name="ln1607">            if (you.see_cell(pos))</a>
<a name="ln1608">                doors_close++;</a>
<a name="ln1609">            break;</a>
<a name="ln1610">        case DNGN_DRY_FOUNTAIN:</a>
<a name="ln1611">        case DNGN_FOUNTAIN_BLUE:</a>
<a name="ln1612">            if (x_chance_in_y(fountains_blood, 3))</a>
<a name="ln1613">                continue;</a>
<a name="ln1614"> </a>
<a name="ln1615">            grd(pos) = DNGN_FOUNTAIN_BLOOD;</a>
<a name="ln1616">            set_terrain_changed(pos);</a>
<a name="ln1617">            if (you.see_cell(pos))</a>
<a name="ln1618">                fountains_blood++;</a>
<a name="ln1619">            break;</a>
<a name="ln1620">        default:</a>
<a name="ln1621">            break;</a>
<a name="ln1622">        }</a>
<a name="ln1623">    }</a>
<a name="ln1624">    if (!doors_open &amp;&amp; !doors_close &amp;&amp; !fountains_blood)</a>
<a name="ln1625">        return;</a>
<a name="ln1626"> </a>
<a name="ln1627">    god_speaks(GOD_XOM, _get_xom_speech(&quot;scenery&quot;).c_str());</a>
<a name="ln1628"> </a>
<a name="ln1629">    vector&lt;string&gt; effects, terse;</a>
<a name="ln1630">    if (fountains_blood &gt; 0)</a>
<a name="ln1631">    {</a>
<a name="ln1632">        string fountains = make_stringf(</a>
<a name="ln1633">                 &quot;%s fountain%s start%s gushing blood&quot;,</a>
<a name="ln1634">                 fountains_blood == 1 ? &quot;a&quot; : &quot;some&quot;,</a>
<a name="ln1635">                 fountains_blood == 1 ? &quot;&quot;  : &quot;s&quot;,</a>
<a name="ln1636">                 fountains_blood == 1 ? &quot;s&quot; : &quot;&quot;);</a>
<a name="ln1637"> </a>
<a name="ln1638">        if (effects.empty())</a>
<a name="ln1639">            fountains = uppercase_first(fountains);</a>
<a name="ln1640">        effects.push_back(fountains);</a>
<a name="ln1641">        terse.push_back(make_stringf(&quot;%d fountains blood&quot;, fountains_blood));</a>
<a name="ln1642">    }</a>
<a name="ln1643">    if (!effects.empty())</a>
<a name="ln1644">    {</a>
<a name="ln1645">        mprf(&quot;%s!&quot;,</a>
<a name="ln1646">             comma_separated_line(effects.begin(), effects.end(),</a>
<a name="ln1647">                                  &quot;, and &quot;).c_str());</a>
<a name="ln1648">        effects.clear();</a>
<a name="ln1649">    }</a>
<a name="ln1650"> </a>
<a name="ln1651">    if (doors_open &gt; 0)</a>
<a name="ln1652">    {</a>
<a name="ln1653">        effects.push_back(make_stringf(&quot;%s door%s burst%s open&quot;,</a>
<a name="ln1654">                                       doors_open == 1 ? &quot;A&quot;    :</a>
<a name="ln1655">                                       doors_open == 2 ? &quot;Two&quot;</a>
<a name="ln1656">                                                       : &quot;Several&quot;,</a>
<a name="ln1657">                                       doors_open == 1 ? &quot;&quot;  : &quot;s&quot;,</a>
<a name="ln1658">                                       doors_open == 1 ? &quot;s&quot; : &quot;&quot;));</a>
<a name="ln1659">        terse.push_back(make_stringf(&quot;%d doors open&quot;, doors_open));</a>
<a name="ln1660">    }</a>
<a name="ln1661">    if (doors_close &gt; 0)</a>
<a name="ln1662">    {</a>
<a name="ln1663">        string closed = make_stringf(&quot;%s%s door%s slam%s shut&quot;,</a>
<a name="ln1664">                 doors_close == 1 ? &quot;a&quot;    :</a>
<a name="ln1665">                 doors_close == 2 ? &quot;two&quot;</a>
<a name="ln1666">                                  : &quot;several&quot;,</a>
<a name="ln1667">                 doors_open &gt; 0   ? (doors_close == 1 ? &quot;nother&quot; : &quot; other&quot;)</a>
<a name="ln1668">                                  : &quot;&quot;,</a>
<a name="ln1669">                 doors_close == 1 ? &quot;&quot;  : &quot;s&quot;,</a>
<a name="ln1670">                 doors_close == 1 ? &quot;s&quot; : &quot;&quot;);</a>
<a name="ln1671">        if (effects.empty())</a>
<a name="ln1672">            closed = uppercase_first(closed);</a>
<a name="ln1673">        effects.push_back(closed);</a>
<a name="ln1674">        terse.push_back(make_stringf(&quot;%d doors close&quot;, doors_close));</a>
<a name="ln1675">    }</a>
<a name="ln1676">    if (!effects.empty())</a>
<a name="ln1677">    {</a>
<a name="ln1678">        take_note(Note(NOTE_XOM_EFFECT, you.piety, -1, (&quot;scenery: &quot;</a>
<a name="ln1679">            + comma_separated_line(terse.begin(), terse.end(), &quot;, &quot;, &quot;, &quot;)).c_str()),</a>
<a name="ln1680">            true);</a>
<a name="ln1681">        mprf(&quot;%s!&quot;,</a>
<a name="ln1682">             comma_separated_line(effects.begin(), effects.end(),</a>
<a name="ln1683">                                  &quot;, and &quot;).c_str());</a>
<a name="ln1684">    }</a>
<a name="ln1685"> </a>
<a name="ln1686">    if (doors_open || doors_close)</a>
<a name="ln1687">        noisy(10, you.pos());</a>
<a name="ln1688">}</a>
<a name="ln1689"> </a>
<a name="ln1690">/// Xom hurls fireballs at your foes! Or, possibly, 'fireballs'.</a>
<a name="ln1691">static void _xom_destruction(int sever, bool real)</a>
<a name="ln1692">{</a>
<a name="ln1693">    bool rc = false;</a>
<a name="ln1694"> </a>
<a name="ln1695">    for (monster_near_iterator mi(you.pos(), LOS_NO_TRANS); mi; ++mi)</a>
<a name="ln1696">    {</a>
<a name="ln1697">        if (mons_is_projectile(**mi)</a>
<a name="ln1698">            || mons_is_tentacle_or_tentacle_segment(mi-&gt;type)</a>
<a name="ln1699">            || one_chance_in(3))</a>
<a name="ln1700">        {</a>
<a name="ln1701">            continue;</a>
<a name="ln1702">        }</a>
<a name="ln1703"> </a>
<a name="ln1704">        // Skip adjacent monsters, and skip non-hostile monsters if not feeling nasty.</a>
<a name="ln1705">        if (real</a>
<a name="ln1706">            &amp;&amp; (adjacent(you.pos(), mi-&gt;pos())</a>
<a name="ln1707">                || mi-&gt;wont_attack() &amp;&amp; !_xom_feels_nasty()))</a>
<a name="ln1708">        {</a>
<a name="ln1709">            continue;</a>
<a name="ln1710">        }</a>
<a name="ln1711"> </a>
<a name="ln1712">        if (!real)</a>
<a name="ln1713">        {</a>
<a name="ln1714">            if (!rc)</a>
<a name="ln1715">                god_speaks(GOD_XOM, _get_xom_speech(&quot;fake destruction&quot;).c_str());</a>
<a name="ln1716">            rc = true;</a>
<a name="ln1717">            backlight_monster(*mi);</a>
<a name="ln1718">            continue;</a>
<a name="ln1719">        }</a>
<a name="ln1720"> </a>
<a name="ln1721">        bolt beam;</a>
<a name="ln1722"> </a>
<a name="ln1723">        beam.flavour      = BEAM_FIRE;</a>
<a name="ln1724">        beam.glyph        = dchar_glyph(DCHAR_FIRED_BURST);</a>
<a name="ln1725">        beam.damage       = dice_def(2, 4 + sever / 10);</a>
<a name="ln1726">        beam.target       = mi-&gt;pos();</a>
<a name="ln1727">        beam.name         = &quot;fireball&quot;;</a>
<a name="ln1728">        beam.colour       = RED;</a>
<a name="ln1729">        beam.thrower      = KILL_MISC;</a>
<a name="ln1730">        beam.source_id    = MID_NOBODY;</a>
<a name="ln1731">        beam.aux_source   = &quot;Xom's destruction&quot;;</a>
<a name="ln1732">        beam.ex_size      = 1;</a>
<a name="ln1733">        beam.is_explosion = true;</a>
<a name="ln1734"> </a>
<a name="ln1735">        // Only give this message once.</a>
<a name="ln1736">        if (!rc)</a>
<a name="ln1737">            god_speaks(GOD_XOM, _get_xom_speech(&quot;destruction&quot;).c_str());</a>
<a name="ln1738">        rc = true;</a>
<a name="ln1739"> </a>
<a name="ln1740">        beam.explode();</a>
<a name="ln1741">    }</a>
<a name="ln1742"> </a>
<a name="ln1743">    if (rc)</a>
<a name="ln1744">    {</a>
<a name="ln1745">        take_note(Note(NOTE_XOM_EFFECT, you.piety, -1,</a>
<a name="ln1746">                       real ? &quot;destruction&quot; : &quot;fake destruction&quot;), true);</a>
<a name="ln1747">    }</a>
<a name="ln1748">}</a>
<a name="ln1749"> </a>
<a name="ln1750">static void _xom_real_destruction(int sever) { _xom_destruction(sever, true); }</a>
<a name="ln1751">static void _xom_fake_destruction(int sever) { _xom_destruction(sever, false); }</a>
<a name="ln1752"> </a>
<a name="ln1753">static void _xom_enchant_monster(bool helpful)</a>
<a name="ln1754">{</a>
<a name="ln1755">    monster* mon = choose_random_nearby_monster(0, _choose_enchantable_monster);</a>
<a name="ln1756">    if (!mon)</a>
<a name="ln1757">        return;</a>
<a name="ln1758"> </a>
<a name="ln1759">    god_speaks(GOD_XOM,</a>
<a name="ln1760">               helpful ? _get_xom_speech(&quot;good enchant monster&quot;).c_str()</a>
<a name="ln1761">                       : _get_xom_speech(&quot;bad enchant monster&quot;).c_str());</a>
<a name="ln1762"> </a>
<a name="ln1763">    beam_type ench;</a>
<a name="ln1764"> </a>
<a name="ln1765">    if (helpful) // To the player, not the monster.</a>
<a name="ln1766">    {</a>
<a name="ln1767">        static const beam_type enchantments[] =</a>
<a name="ln1768">        {</a>
<a name="ln1769">            BEAM_PETRIFY,</a>
<a name="ln1770">            BEAM_SLOW,</a>
<a name="ln1771">            BEAM_PARALYSIS,</a>
<a name="ln1772">            BEAM_ENSLAVE,</a>
<a name="ln1773">        };</a>
<a name="ln1774">        ench = RANDOM_ELEMENT(enchantments);</a>
<a name="ln1775">    }</a>
<a name="ln1776">    else</a>
<a name="ln1777">    {</a>
<a name="ln1778">        static const beam_type enchantments[] =</a>
<a name="ln1779">        {</a>
<a name="ln1780">            BEAM_HASTE,</a>
<a name="ln1781">            BEAM_MIGHT,</a>
<a name="ln1782">            BEAM_AGILITY,</a>
<a name="ln1783">            BEAM_INVISIBILITY,</a>
<a name="ln1784">            BEAM_RESISTANCE,</a>
<a name="ln1785">        };</a>
<a name="ln1786">        ench = RANDOM_ELEMENT(enchantments);</a>
<a name="ln1787">    }</a>
<a name="ln1788"> </a>
<a name="ln1789">    enchant_actor_with_flavour(mon, 0, ench);</a>
<a name="ln1790"> </a>
<a name="ln1791">    // Take a note.</a>
<a name="ln1792">    const string note = make_stringf(&quot;enchant monster %s&quot;,</a>
<a name="ln1793">                                     helpful ? &quot;(good)&quot; : &quot;(bad)&quot;);</a>
<a name="ln1794">    take_note(Note(NOTE_XOM_EFFECT, you.piety, -1, note), true);</a>
<a name="ln1795">}</a>
<a name="ln1796"> </a>
<a name="ln1797">static void _xom_good_enchant_monster(int /*sever*/)</a>
<a name="ln1798">{</a>
<a name="ln1799">    _xom_enchant_monster(true);</a>
<a name="ln1800">}</a>
<a name="ln1801">static void _xom_bad_enchant_monster(int /*sever*/)</a>
<a name="ln1802">{</a>
<a name="ln1803">    _xom_enchant_monster(false);</a>
<a name="ln1804">}</a>
<a name="ln1805"> </a>
<a name="ln1806">/// Toss some fog around the player. Helping...?</a>
<a name="ln1807">static void _xom_fog(int /*sever*/)</a>
<a name="ln1808">{</a>
<a name="ln1809">    big_cloud(CLOUD_RANDOM_SMOKE, &amp;you, you.pos(), 50, 8 + random2(8));</a>
<a name="ln1810">    take_note(Note(NOTE_XOM_EFFECT, you.piety, -1, &quot;fog&quot;), true);</a>
<a name="ln1811">    god_speaks(GOD_XOM, _get_xom_speech(&quot;cloud&quot;).c_str());</a>
<a name="ln1812">}</a>
<a name="ln1813"> </a>
<a name="ln1814">static void _xom_pseudo_miscast(int /*sever*/)</a>
<a name="ln1815">{</a>
<a name="ln1816">    take_note(Note(NOTE_XOM_EFFECT, you.piety, -1, &quot;silly message&quot;), true);</a>
<a name="ln1817">    god_speaks(GOD_XOM, _get_xom_speech(&quot;zero miscast effect&quot;).c_str());</a>
<a name="ln1818"> </a>
<a name="ln1819">    vector&lt;string&gt; messages;</a>
<a name="ln1820">    vector&lt;string&gt; priority;</a>
<a name="ln1821"> </a>
<a name="ln1822">    vector&lt;item_def *&gt; inv_items;</a>
<a name="ln1823">    for (auto &amp;item : you.inv)</a>
<a name="ln1824">    {</a>
<a name="ln1825">        if (item.defined() &amp;&amp; !item_is_equipped(item)</a>
<a name="ln1826">            &amp;&amp; !item.is_critical())</a>
<a name="ln1827">        {</a>
<a name="ln1828">            inv_items.push_back(&amp;item);</a>
<a name="ln1829">        }</a>
<a name="ln1830">    }</a>
<a name="ln1831"> </a>
<a name="ln1832">    // Assure that the messages vector has at least one element.</a>
<a name="ln1833">    messages.emplace_back(&quot;Nothing appears to happen... Ominous!&quot;);</a>
<a name="ln1834"> </a>
<a name="ln1835">    ///////////////////////////////////</a>
<a name="ln1836">    // Dungeon feature dependent stuff.</a>
<a name="ln1837"> </a>
<a name="ln1838">    FixedBitVector&lt;NUM_FEATURES&gt; in_view;</a>
<a name="ln1839">    for (radius_iterator ri(you.pos(), LOS_DEFAULT); ri; ++ri)</a>
<a name="ln1840">        in_view.set(grd(*ri));</a>
<a name="ln1841"> </a>
<a name="ln1842">    if (in_view[DNGN_LAVA])</a>
<a name="ln1843">        messages.emplace_back(&quot;The lava spits out sparks!&quot;);</a>
<a name="ln1844"> </a>
<a name="ln1845">    if (in_view[DNGN_SHALLOW_WATER] || in_view[DNGN_DEEP_WATER])</a>
<a name="ln1846">    {</a>
<a name="ln1847">        messages.emplace_back(&quot;The water briefly bubbles.&quot;);</a>
<a name="ln1848">        messages.emplace_back(&quot;The water briefly swirls.&quot;);</a>
<a name="ln1849">        messages.emplace_back(&quot;The water briefly glows.&quot;);</a>
<a name="ln1850">    }</a>
<a name="ln1851"> </a>
<a name="ln1852">    if (in_view[DNGN_DEEP_WATER])</a>
<a name="ln1853">    {</a>
<a name="ln1854">        messages.emplace_back(&quot;From the corner of your eye you spot something &quot;</a>
<a name="ln1855">                           &quot;lurking in the deep water.&quot;);</a>
<a name="ln1856">    }</a>
<a name="ln1857"> </a>
<a name="ln1858">    if (in_view[DNGN_ORCISH_IDOL])</a>
<a name="ln1859">        priority.emplace_back(&quot;The idol of Beogh turns to glare at you.&quot;);</a>
<a name="ln1860"> </a>
<a name="ln1861">    if (in_view[DNGN_GRANITE_STATUE])</a>
<a name="ln1862">        priority.emplace_back(&quot;The granite statue turns to stare at you.&quot;);</a>
<a name="ln1863"> </a>
<a name="ln1864">    if (in_view[DNGN_CLEAR_ROCK_WALL] || in_view[DNGN_CLEAR_STONE_WALL]</a>
<a name="ln1865">        || in_view[DNGN_CLEAR_PERMAROCK_WALL])</a>
<a name="ln1866">    {</a>
<a name="ln1867">        messages.emplace_back(&quot;Dim shapes swim through the translucent wall.&quot;);</a>
<a name="ln1868">    }</a>
<a name="ln1869"> </a>
<a name="ln1870">    if (in_view[DNGN_CRYSTAL_WALL])</a>
<a name="ln1871">        messages.emplace_back(&quot;Dim shapes swim through the crystal wall.&quot;);</a>
<a name="ln1872"> </a>
<a name="ln1873">    if (in_view[DNGN_METAL_WALL])</a>
<a name="ln1874">    {</a>
<a name="ln1875">        messages.emplace_back(&quot;Tendrils of electricity crawl over the metal &quot;</a>
<a name="ln1876">                              &quot;wall!&quot;);</a>
<a name="ln1877">    }</a>
<a name="ln1878"> </a>
<a name="ln1879">    if (in_view[DNGN_FOUNTAIN_BLUE] || in_view[DNGN_FOUNTAIN_SPARKLING])</a>
<a name="ln1880">    {</a>
<a name="ln1881">        priority.emplace_back(&quot;The water in the fountain briefly bubbles.&quot;);</a>
<a name="ln1882">        priority.emplace_back(&quot;The water in the fountain briefly swirls.&quot;);</a>
<a name="ln1883">        priority.emplace_back(&quot;The water in the fountain briefly glows.&quot;);</a>
<a name="ln1884">    }</a>
<a name="ln1885"> </a>
<a name="ln1886">    if (in_view[DNGN_DRY_FOUNTAIN])</a>
<a name="ln1887">    {</a>
<a name="ln1888">        priority.emplace_back(&quot;Water briefly sprays from the dry fountain.&quot;);</a>
<a name="ln1889">        priority.emplace_back(&quot;Dust puffs up from the dry fountain.&quot;);</a>
<a name="ln1890">    }</a>
<a name="ln1891"> </a>
<a name="ln1892">    if (in_view[DNGN_STONE_ARCH])</a>
<a name="ln1893">    {</a>
<a name="ln1894">        priority.emplace_back(&quot;The stone arch briefly shows a sunny meadow on &quot;</a>
<a name="ln1895">                              &quot;the other side.&quot;);</a>
<a name="ln1896">    }</a>
<a name="ln1897"> </a>
<a name="ln1898">    const dungeon_feature_type feat = grd(you.pos());</a>
<a name="ln1899"> </a>
<a name="ln1900">    if (!feat_is_solid(feat) &amp;&amp; feat_stair_direction(feat) == CMD_NO_CMD</a>
<a name="ln1901">        &amp;&amp; !feat_is_trap(feat) &amp;&amp; feat != DNGN_STONE_ARCH</a>
<a name="ln1902">        &amp;&amp; !feat_is_open_door(feat) &amp;&amp; feat != DNGN_ABANDONED_SHOP)</a>
<a name="ln1903">    {</a>
<a name="ln1904">        const string feat_name = feature_description_at(you.pos(), false,</a>
<a name="ln1905">                                                        DESC_THE);</a>
<a name="ln1906"> </a>
<a name="ln1907">        if (you.airborne())</a>
<a name="ln1908">        {</a>
<a name="ln1909">            // Don't put airborne messages into the priority vector for</a>
<a name="ln1910">            // anyone who can fly a lot.</a>
<a name="ln1911">            vector&lt;string&gt;* vec;</a>
<a name="ln1912">            if (you.racial_permanent_flight())</a>
<a name="ln1913">                vec = &amp;messages;</a>
<a name="ln1914">            else</a>
<a name="ln1915">                vec = &amp;priority;</a>
<a name="ln1916"> </a>
<a name="ln1917">            vec-&gt;push_back(feat_name</a>
<a name="ln1918">                           + &quot; seems to fall away from under you!&quot;);</a>
<a name="ln1919">            vec-&gt;push_back(feat_name</a>
<a name="ln1920">                           + &quot; seems to rush up at you!&quot;);</a>
<a name="ln1921"> </a>
<a name="ln1922">            if (feat_is_water(feat))</a>
<a name="ln1923">            {</a>
<a name="ln1924">                priority.emplace_back(&quot;Something invisible splashes into the &quot;</a>
<a name="ln1925">                                      &quot;water beneath you!&quot;);</a>
<a name="ln1926">            }</a>
<a name="ln1927">        }</a>
<a name="ln1928">        else if (feat_is_water(feat))</a>
<a name="ln1929">        {</a>
<a name="ln1930">            priority.emplace_back(&quot;The water briefly recedes away from you.&quot;);</a>
<a name="ln1931">            priority.emplace_back(&quot;Something invisible splashes into the water &quot;</a>
<a name="ln1932">                                  &quot;beside you!&quot;);</a>
<a name="ln1933">        }</a>
<a name="ln1934">    }</a>
<a name="ln1935"> </a>
<a name="ln1936">    if (feat_has_solid_floor(feat) &amp;&amp; !inv_items.empty())</a>
<a name="ln1937">    {</a>
<a name="ln1938">        const item_def &amp;item = **random_iterator(inv_items);</a>
<a name="ln1939"> </a>
<a name="ln1940">        string name;</a>
<a name="ln1941">        if (item.quantity == 1)</a>
<a name="ln1942">            name = item.name(DESC_YOUR, false, false, false);</a>
<a name="ln1943">        else</a>
<a name="ln1944">        {</a>
<a name="ln1945">            name  = &quot;One of &quot;;</a>
<a name="ln1946">            name += item.name(DESC_YOUR, false, false, false);</a>
<a name="ln1947">        }</a>
<a name="ln1948">        messages.push_back(name + &quot; falls out of your pack, then &quot;</a>
<a name="ln1949">                           &quot;immediately jumps back in!&quot;);</a>
<a name="ln1950">    }</a>
<a name="ln1951"> </a>
<a name="ln1952">    //////////////////////////////////////////////</a>
<a name="ln1953">    // Body, player species, transformations, etc.</a>
<a name="ln1954"> </a>
<a name="ln1955">    if (you.species == SP_MUMMY &amp;&amp; you_can_wear(EQ_BODY_ARMOUR, true))</a>
<a name="ln1956">    {</a>
<a name="ln1957">        messages.emplace_back(&quot;You briefly get tangled in your bandages.&quot;);</a>
<a name="ln1958">        if (!you.airborne() &amp;&amp; !you.swimming())</a>
<a name="ln1959">            messages.emplace_back(&quot;You trip over your bandages.&quot;);</a>
<a name="ln1960">    }</a>
<a name="ln1961"> </a>
<a name="ln1962">    {</a>
<a name="ln1963">        string str = &quot;A monocle briefly appears over your &quot;;</a>
<a name="ln1964">        str += random_choose(&quot;right&quot;, &quot;left&quot;);</a>
<a name="ln1965">        if (you.form == transformation::spider)</a>
<a name="ln1966">        {</a>
<a name="ln1967">            if (coinflip())</a>
<a name="ln1968">                str += &quot; primary&quot;;</a>
<a name="ln1969">            else</a>
<a name="ln1970">            {</a>
<a name="ln1971">                str += random_choose(&quot; front&quot;, &quot; middle&quot;, &quot; rear&quot;);</a>
<a name="ln1972">                str += &quot; secondary&quot;;</a>
<a name="ln1973">            }</a>
<a name="ln1974">        }</a>
<a name="ln1975">        str += &quot; eye.&quot;;</a>
<a name="ln1976">        messages.push_back(str);</a>
<a name="ln1977">    }</a>
<a name="ln1978"> </a>
<a name="ln1979">    if (species_has_hair(you.species))</a>
<a name="ln1980">    {</a>
<a name="ln1981">        messages.emplace_back(&quot;Your eyebrows briefly feel incredibly bushy.&quot;);</a>
<a name="ln1982">        messages.emplace_back(&quot;Your eyebrows wriggle.&quot;);</a>
<a name="ln1983">    }</a>
<a name="ln1984"> </a>
<a name="ln1985">    if (you.species != SP_NAGA &amp;&amp; !you.fishtail &amp;&amp; !you.airborne())</a>
<a name="ln1986">        messages.emplace_back(&quot;You do an impromptu tapdance.&quot;);</a>
<a name="ln1987"> </a>
<a name="ln1988">    ///////////////////////////</a>
<a name="ln1989">    // Equipment related stuff.</a>
<a name="ln1990"> </a>
<a name="ln1991">    if (you_can_wear(EQ_WEAPON, true)</a>
<a name="ln1992">        &amp;&amp; !you.slot_item(EQ_WEAPON))</a>
<a name="ln1993">    {</a>
<a name="ln1994">        string str = &quot;A fancy cane briefly appears in your &quot;;</a>
<a name="ln1995">        str += you.hand_name(false);</a>
<a name="ln1996">        str += &quot;.&quot;;</a>
<a name="ln1997"> </a>
<a name="ln1998">        messages.push_back(str);</a>
<a name="ln1999">    }</a>
<a name="ln2000"> </a>
<a name="ln2001">    if (you.slot_item(EQ_CLOAK))</a>
<a name="ln2002">    {</a>
<a name="ln2003">        item_def* item = you.slot_item(EQ_CLOAK);</a>
<a name="ln2004"> </a>
<a name="ln2005">        if (item-&gt;sub_type == ARM_CLOAK)</a>
<a name="ln2006">            messages.emplace_back(&quot;Your cloak billows in an unfelt wind.&quot;);</a>
<a name="ln2007">        else if (item-&gt;sub_type == ARM_SCARF)</a>
<a name="ln2008">            messages.emplace_back(&quot;Your scarf briefly wraps itself around your head!&quot;);</a>
<a name="ln2009">    }</a>
<a name="ln2010"> </a>
<a name="ln2011">    if (item_def* item = you.slot_item(EQ_HELMET))</a>
<a name="ln2012">    {</a>
<a name="ln2013">        string str = &quot;Your &quot;;</a>
<a name="ln2014">        str += item-&gt;name(DESC_BASENAME, false, false, false);</a>
<a name="ln2015">        str += &quot; leaps into the air, briefly spins, then lands back on &quot;</a>
<a name="ln2016">               &quot;your head!&quot;;</a>
<a name="ln2017"> </a>
<a name="ln2018">        messages.push_back(str);</a>
<a name="ln2019">    }</a>
<a name="ln2020"> </a>
<a name="ln2021">    if (item_def* item = you.slot_item(EQ_BOOTS))</a>
<a name="ln2022">    {</a>
<a name="ln2023">        if (item-&gt;sub_type == ARM_BOOTS &amp;&amp; !you.cannot_act())</a>
<a name="ln2024">        {</a>
<a name="ln2025">            string name = item-&gt;name(DESC_BASENAME, false, false, false);</a>
<a name="ln2026">            name = replace_all(name, &quot;pair of &quot;, &quot;&quot;);</a>
<a name="ln2027"> </a>
<a name="ln2028">            string str = &quot;You compulsively click the heels of your &quot;;</a>
<a name="ln2029">            str += name;</a>
<a name="ln2030">            str += &quot; together three times.&quot;;</a>
<a name="ln2031">            messages.push_back(str);</a>
<a name="ln2032">        }</a>
<a name="ln2033">    }</a>
<a name="ln2034"> </a>
<a name="ln2035">    if (item_def* item = you.slot_item(EQ_SHIELD))</a>
<a name="ln2036">    {</a>
<a name="ln2037">        string str = &quot;Your &quot;;</a>
<a name="ln2038">        str += item-&gt;name(DESC_BASENAME, false, false, false);</a>
<a name="ln2039">        str += &quot; spins!&quot;;</a>
<a name="ln2040"> </a>
<a name="ln2041">        messages.push_back(str);</a>
<a name="ln2042"> </a>
<a name="ln2043">        str = &quot;Your &quot;;</a>
<a name="ln2044">        str += item-&gt;name(DESC_BASENAME, false, false, false);</a>
<a name="ln2045">        str += &quot; briefly flashes a lurid colour!&quot;;</a>
<a name="ln2046">        messages.push_back(str);</a>
<a name="ln2047">    }</a>
<a name="ln2048"> </a>
<a name="ln2049">    if (item_def* item = you.slot_item(EQ_BODY_ARMOUR))</a>
<a name="ln2050">    {</a>
<a name="ln2051">        string str;</a>
<a name="ln2052">        string name = item-&gt;name(DESC_BASENAME, false, false, false);</a>
<a name="ln2053"> </a>
<a name="ln2054">        if (name.find(&quot;dragon&quot;) != string::npos)</a>
<a name="ln2055">        {</a>
<a name="ln2056">            str  = &quot;The scales on your &quot;;</a>
<a name="ln2057">            str += name;</a>
<a name="ln2058">            str += &quot; wiggle briefly.&quot;;</a>
<a name="ln2059">        }</a>
<a name="ln2060">        else if (item-&gt;sub_type == ARM_ANIMAL_SKIN)</a>
<a name="ln2061">        {</a>
<a name="ln2062">            str  = &quot;The fur on your &quot;;</a>
<a name="ln2063">            str += name;</a>
<a name="ln2064">            str += &quot; grows longer at an alarming rate, then retracts back &quot;</a>
<a name="ln2065">                   &quot;to normal.&quot;;</a>
<a name="ln2066">        }</a>
<a name="ln2067">        else if (item-&gt;sub_type == ARM_LEATHER_ARMOUR)</a>
<a name="ln2068">        {</a>
<a name="ln2069">            str  = &quot;Your &quot;;</a>
<a name="ln2070">            str += name;</a>
<a name="ln2071">            str += &quot; briefly grows fur, then returns to normal.&quot;;</a>
<a name="ln2072">        }</a>
<a name="ln2073">        else if (item-&gt;sub_type == ARM_ROBE)</a>
<a name="ln2074">        {</a>
<a name="ln2075">            str  = &quot;You briefly become tangled in your &quot;;</a>
<a name="ln2076">            str += pluralise(name);</a>
<a name="ln2077">            str += &quot;.&quot;;</a>
<a name="ln2078">        }</a>
<a name="ln2079">        else if (item-&gt;sub_type &gt;= ARM_RING_MAIL</a>
<a name="ln2080">                 &amp;&amp; item-&gt;sub_type &lt;= ARM_PLATE_ARMOUR)</a>
<a name="ln2081">        {</a>
<a name="ln2082">            str  = &quot;Your &quot;;</a>
<a name="ln2083">            str += name;</a>
<a name="ln2084">            str += &quot; briefly appears rusty.&quot;;</a>
<a name="ln2085">        }</a>
<a name="ln2086"> </a>
<a name="ln2087">        if (!str.empty())</a>
<a name="ln2088">            messages.push_back(str);</a>
<a name="ln2089">    }</a>
<a name="ln2090"> </a>
<a name="ln2091">    ////////</a>
<a name="ln2092">    // Misc.</a>
<a name="ln2093">    if (!inv_items.empty())</a>
<a name="ln2094">    {</a>
<a name="ln2095">        item_def &amp;item = **random_iterator(inv_items);</a>
<a name="ln2096"> </a>
<a name="ln2097">        string name = item.name(DESC_YOUR, false, false, false);</a>
<a name="ln2098">        string verb = random_choose(&quot;glow&quot;, &quot;vibrate&quot;);</a>
<a name="ln2099"> </a>
<a name="ln2100">        if (item.quantity == 1)</a>
<a name="ln2101">            verb += &quot;s&quot;;</a>
<a name="ln2102"> </a>
<a name="ln2103">        messages.push_back(name + &quot; briefly &quot; + verb + &quot;.&quot;);</a>
<a name="ln2104">    }</a>
<a name="ln2105"> </a>
<a name="ln2106">    if (!priority.empty() &amp;&amp; coinflip())</a>
<a name="ln2107">        mpr(priority[random2(priority.size())]);</a>
<a name="ln2108">    else</a>
<a name="ln2109">        mpr(messages[random2(messages.size())]);</a>
<a name="ln2110">}</a>
<a name="ln2111"> </a>
<a name="ln2112">static bool _miscast_is_nasty(int sever)</a>
<a name="ln2113">{</a>
<a name="ln2114">    return sever &gt;= 5 &amp;&amp; _xom_feels_nasty();</a>
<a name="ln2115">}</a>
<a name="ln2116"> </a>
<a name="ln2117">static void _xom_chaos_upgrade(int /*sever*/)</a>
<a name="ln2118">{</a>
<a name="ln2119">    monster* mon = choose_random_nearby_monster(0, _choose_chaos_upgrade);</a>
<a name="ln2120"> </a>
<a name="ln2121">    if (!mon)</a>
<a name="ln2122">        return;</a>
<a name="ln2123"> </a>
<a name="ln2124">    god_speaks(GOD_XOM, _get_xom_speech(&quot;chaos upgrade&quot;).c_str());</a>
<a name="ln2125"> </a>
<a name="ln2126">    mon_inv_type slots[] = {MSLOT_WEAPON, MSLOT_ALT_WEAPON, MSLOT_MISSILE};</a>
<a name="ln2127"> </a>
<a name="ln2128">    bool rc = false;</a>
<a name="ln2129">    for (int i = 0; i &lt; 3 &amp;&amp; !rc; ++i)</a>
<a name="ln2130">    {</a>
<a name="ln2131">        item_def* const item = mon-&gt;mslot_item(slots[i]);</a>
<a name="ln2132">        if (item &amp;&amp; _is_chaos_upgradeable(*item, mon))</a>
<a name="ln2133">        {</a>
<a name="ln2134">            _do_chaos_upgrade(*item, mon);</a>
<a name="ln2135">            rc = true;</a>
<a name="ln2136">        }</a>
<a name="ln2137">    }</a>
<a name="ln2138">    ASSERT(rc);</a>
<a name="ln2139"> </a>
<a name="ln2140">    // Wake the monster up.</a>
<a name="ln2141">    behaviour_event(mon, ME_ALERT, &amp;you);</a>
<a name="ln2142"> </a>
<a name="ln2143">    if (rc)</a>
<a name="ln2144">        take_note(Note(NOTE_XOM_EFFECT, you.piety, -1, &quot;chaos upgrade&quot;), true);</a>
<a name="ln2145">}</a>
<a name="ln2146"> </a>
<a name="ln2147">static void _xom_player_confusion_effect(int sever)</a>
<a name="ln2148">{</a>
<a name="ln2149">    const bool conf = you.confused();</a>
<a name="ln2150"> </a>
<a name="ln2151">    if (!confuse_player(5 + random2(3), true))</a>
<a name="ln2152">        return;</a>
<a name="ln2153"> </a>
<a name="ln2154">    god_speaks(GOD_XOM, _get_xom_speech(&quot;confusion&quot;).c_str());</a>
<a name="ln2155">    mprf(MSGCH_WARN, &quot;You are %sconfused.&quot;,</a>
<a name="ln2156">         conf ? &quot;more &quot; : &quot;&quot;);</a>
<a name="ln2157"> </a>
<a name="ln2158">    // At higher severities, Xom is less likely to confuse surrounding</a>
<a name="ln2159">    // creatures.</a>
<a name="ln2160">    bool mons_too = false;</a>
<a name="ln2161">    if (random2(sever) &lt; 30)</a>
<a name="ln2162">    {</a>
<a name="ln2163">        for (monster_near_iterator mi(you.pos(), LOS_NO_TRANS); mi; ++mi)</a>
<a name="ln2164">        {</a>
<a name="ln2165">            if (random2(sever) &gt; 30)</a>
<a name="ln2166">                continue;</a>
<a name="ln2167">            _confuse_monster(*mi, sever);</a>
<a name="ln2168">            mons_too = true;</a>
<a name="ln2169">        }</a>
<a name="ln2170">    }</a>
<a name="ln2171"> </a>
<a name="ln2172">    // Take a note.</a>
<a name="ln2173">    string conf_msg = &quot;confusion&quot;;</a>
<a name="ln2174">    if (mons_too)</a>
<a name="ln2175">        conf_msg += &quot; (+ monsters)&quot;;</a>
<a name="ln2176">    take_note(Note(NOTE_XOM_EFFECT, you.piety, -1, conf_msg), true);</a>
<a name="ln2177">}</a>
<a name="ln2178"> </a>
<a name="ln2179">static bool _valid_floor_grid(coord_def pos)</a>
<a name="ln2180">{</a>
<a name="ln2181">    if (!in_bounds(pos))</a>
<a name="ln2182">        return false;</a>
<a name="ln2183"> </a>
<a name="ln2184">    return grd(pos) == DNGN_FLOOR;</a>
<a name="ln2185">}</a>
<a name="ln2186"> </a>
<a name="ln2187">bool move_stair(coord_def stair_pos, bool away, bool allow_under)</a>
<a name="ln2188">{</a>
<a name="ln2189">    if (!allow_under)</a>
<a name="ln2190">        ASSERT(stair_pos != you.pos());</a>
<a name="ln2191"> </a>
<a name="ln2192">    dungeon_feature_type feat = grd(stair_pos);</a>
<a name="ln2193">    ASSERT(feat_stair_direction(feat) != CMD_NO_CMD);</a>
<a name="ln2194"> </a>
<a name="ln2195">    coord_def begin, towards;</a>
<a name="ln2196"> </a>
<a name="ln2197">    bool stairs_moved = false;</a>
<a name="ln2198">    if (away)</a>
<a name="ln2199">    {</a>
<a name="ln2200">        // If the staircase starts out under the player, first shove it</a>
<a name="ln2201">        // onto a neighbouring grid.</a>
<a name="ln2202">        if (allow_under &amp;&amp; stair_pos == you.pos())</a>
<a name="ln2203">        {</a>
<a name="ln2204">            coord_def new_pos(stair_pos);</a>
<a name="ln2205">            // Loop twice through all adjacent grids. In the first round,</a>
<a name="ln2206">            // only consider grids whose next neighbour in the direction</a>
<a name="ln2207">            // away from the player is also of type floor. If we didn't</a>
<a name="ln2208">            // find any matching grid, try again without that restriction.</a>
<a name="ln2209">            for (int tries = 0; tries &lt; 2; ++tries)</a>
<a name="ln2210">            {</a>
<a name="ln2211">                int adj_count = 0;</a>
<a name="ln2212">                for (adjacent_iterator ai(stair_pos); ai; ++ai)</a>
<a name="ln2213">                    if (grd(*ai) == DNGN_FLOOR</a>
<a name="ln2214">                        &amp;&amp; (tries || _valid_floor_grid(*ai + *ai - stair_pos))</a>
<a name="ln2215">                        &amp;&amp; one_chance_in(++adj_count))</a>
<a name="ln2216">                    {</a>
<a name="ln2217">                        new_pos = *ai;</a>
<a name="ln2218">                    }</a>
<a name="ln2219"> </a>
<a name="ln2220">                if (!tries &amp;&amp; new_pos != stair_pos)</a>
<a name="ln2221">                    break;</a>
<a name="ln2222">            }</a>
<a name="ln2223"> </a>
<a name="ln2224">            if (new_pos == stair_pos)</a>
<a name="ln2225">                return false;</a>
<a name="ln2226"> </a>
<a name="ln2227">            if (!slide_feature_over(stair_pos, new_pos, true))</a>
<a name="ln2228">                return false;</a>
<a name="ln2229"> </a>
<a name="ln2230">            stair_pos = new_pos;</a>
<a name="ln2231">            stairs_moved = true;</a>
<a name="ln2232">        }</a>
<a name="ln2233"> </a>
<a name="ln2234">        begin   = you.pos();</a>
<a name="ln2235">        towards = stair_pos;</a>
<a name="ln2236">    }</a>
<a name="ln2237">    else</a>
<a name="ln2238">    {</a>
<a name="ln2239">        // Can't move towards player if it's already adjacent.</a>
<a name="ln2240">        if (adjacent(you.pos(), stair_pos))</a>
<a name="ln2241">            return false;</a>
<a name="ln2242"> </a>
<a name="ln2243">        begin   = stair_pos;</a>
<a name="ln2244">        towards = you.pos();</a>
<a name="ln2245">    }</a>
<a name="ln2246"> </a>
<a name="ln2247">    ray_def ray;</a>
<a name="ln2248">    if (!find_ray(begin, towards, ray, opc_solid_see))</a>
<a name="ln2249">    {</a>
<a name="ln2250">        mprf(MSGCH_ERROR, &quot;Couldn't find ray between player and stairs.&quot;);</a>
<a name="ln2251">        return stairs_moved;</a>
<a name="ln2252">    }</a>
<a name="ln2253"> </a>
<a name="ln2254">    // Don't start off under the player.</a>
<a name="ln2255">    if (away)</a>
<a name="ln2256">        ray.advance();</a>
<a name="ln2257"> </a>
<a name="ln2258">    bool found_stairs = false;</a>
<a name="ln2259">    int  past_stairs  = 0;</a>
<a name="ln2260">    while (in_bounds(ray.pos()) &amp;&amp; you.see_cell(ray.pos())</a>
<a name="ln2261">           &amp;&amp; !cell_is_solid(ray.pos()) &amp;&amp; ray.pos() != you.pos())</a>
<a name="ln2262">    {</a>
<a name="ln2263">        if (ray.pos() == stair_pos)</a>
<a name="ln2264">            found_stairs = true;</a>
<a name="ln2265">        if (found_stairs)</a>
<a name="ln2266">            past_stairs++;</a>
<a name="ln2267">        ray.advance();</a>
<a name="ln2268">    }</a>
<a name="ln2269">    past_stairs--;</a>
<a name="ln2270"> </a>
<a name="ln2271">    if (!away &amp;&amp; cell_is_solid(ray.pos()))</a>
<a name="ln2272">    {</a>
<a name="ln2273">        // Transparent wall between stair and player.</a>
<a name="ln2274">        return stairs_moved;</a>
<a name="ln2275">    }</a>
<a name="ln2276"> </a>
<a name="ln2277">    if (away &amp;&amp; !found_stairs)</a>
<a name="ln2278">    {</a>
<a name="ln2279">        if (cell_is_solid(ray.pos()))</a>
<a name="ln2280">        {</a>
<a name="ln2281">            // Transparent wall between stair and player.</a>
<a name="ln2282">            return stairs_moved;</a>
<a name="ln2283">        }</a>
<a name="ln2284"> </a>
<a name="ln2285">        mprf(MSGCH_ERROR, &quot;Ray didn't cross stairs.&quot;);</a>
<a name="ln2286">    }</a>
<a name="ln2287"> </a>
<a name="ln2288">    if (away &amp;&amp; past_stairs &lt;= 0)</a>
<a name="ln2289">    {</a>
<a name="ln2290">        // Stairs already at edge, can't move further away.</a>
<a name="ln2291">        return stairs_moved;</a>
<a name="ln2292">    }</a>
<a name="ln2293"> </a>
<a name="ln2294">    if (!in_bounds(ray.pos()) || ray.pos() == you.pos())</a>
<a name="ln2295">        ray.regress();</a>
<a name="ln2296"> </a>
<a name="ln2297">    while (!you.see_cell(ray.pos()) || grd(ray.pos()) != DNGN_FLOOR)</a>
<a name="ln2298">    {</a>
<a name="ln2299">        ray.regress();</a>
<a name="ln2300">        if (!in_bounds(ray.pos()) || ray.pos() == you.pos()</a>
<a name="ln2301">            || ray.pos() == stair_pos)</a>
<a name="ln2302">        {</a>
<a name="ln2303">            // No squares in path are a plain floor.</a>
<a name="ln2304">            return stairs_moved;</a>
<a name="ln2305">        }</a>
<a name="ln2306">    }</a>
<a name="ln2307"> </a>
<a name="ln2308">    ASSERT(stair_pos != ray.pos());</a>
<a name="ln2309"> </a>
<a name="ln2310">    string stair_str = feature_description_at(stair_pos, false, DESC_THE);</a>
<a name="ln2311"> </a>
<a name="ln2312">    mprf(&quot;%s slides %s you!&quot;, stair_str.c_str(),</a>
<a name="ln2313">         away ? &quot;away from&quot; : &quot;towards&quot;);</a>
<a name="ln2314"> </a>
<a name="ln2315">    // Animate stair moving.</a>
<a name="ln2316">    const feature_def &amp;feat_def = get_feature_def(feat);</a>
<a name="ln2317"> </a>
<a name="ln2318">    bolt beam;</a>
<a name="ln2319"> </a>
<a name="ln2320">    beam.range   = INFINITE_DISTANCE;</a>
<a name="ln2321">    beam.flavour = BEAM_VISUAL;</a>
<a name="ln2322">    beam.glyph   = feat_def.symbol();</a>
<a name="ln2323">    beam.colour  = feat_def.colour();</a>
<a name="ln2324">    beam.source  = stair_pos;</a>
<a name="ln2325">    beam.target  = ray.pos();</a>
<a name="ln2326">    beam.name    = &quot;STAIR BEAM&quot;;</a>
<a name="ln2327">    beam.draw_delay = 50; // Make beam animation slower than normal.</a>
<a name="ln2328"> </a>
<a name="ln2329">    beam.aimed_at_spot = true;</a>
<a name="ln2330">    beam.fire();</a>
<a name="ln2331"> </a>
<a name="ln2332">    // Clear out &quot;missile trails&quot;</a>
<a name="ln2333">    viewwindow();</a>
<a name="ln2334"> </a>
<a name="ln2335">    if (!swap_features(stair_pos, ray.pos(), false, false))</a>
<a name="ln2336">    {</a>
<a name="ln2337">        mprf(MSGCH_ERROR, &quot;_move_stair(): failed to move %s&quot;,</a>
<a name="ln2338">             stair_str.c_str());</a>
<a name="ln2339">        return stairs_moved;</a>
<a name="ln2340">    }</a>
<a name="ln2341"> </a>
<a name="ln2342">    return true;</a>
<a name="ln2343">}</a>
<a name="ln2344"> </a>
<a name="ln2345">static vector&lt;coord_def&gt; _nearby_stairs()</a>
<a name="ln2346">{</a>
<a name="ln2347">    vector&lt;coord_def&gt; stairs_avail;</a>
<a name="ln2348">    for (radius_iterator ri(you.pos(), LOS_RADIUS, C_SQUARE); ri; ++ri)</a>
<a name="ln2349">    {</a>
<a name="ln2350">        if (!cell_see_cell(you.pos(), *ri, LOS_SOLID_SEE))</a>
<a name="ln2351">            continue;</a>
<a name="ln2352"> </a>
<a name="ln2353">        dungeon_feature_type feat = grd(*ri);</a>
<a name="ln2354">        if (feat_stair_direction(feat) != CMD_NO_CMD</a>
<a name="ln2355">            &amp;&amp; feat != DNGN_ENTER_SHOP)</a>
<a name="ln2356">        {</a>
<a name="ln2357">            stairs_avail.push_back(*ri);</a>
<a name="ln2358">        }</a>
<a name="ln2359">    }</a>
<a name="ln2360"> </a>
<a name="ln2361">    return stairs_avail;</a>
<a name="ln2362">}</a>
<a name="ln2363"> </a>
<a name="ln2364">static void _xom_repel_stairs(bool unclimbable)</a>
<a name="ln2365">{</a>
<a name="ln2366">    vector&lt;coord_def&gt; stairs_avail  = _nearby_stairs();</a>
<a name="ln2367"> </a>
<a name="ln2368">    // Only works if there are stairs in view.</a>
<a name="ln2369">    if (stairs_avail.empty())</a>
<a name="ln2370">        return;</a>
<a name="ln2371"> </a>
<a name="ln2372">    bool real_stairs = false;</a>
<a name="ln2373">    for (auto loc : stairs_avail)</a>
<a name="ln2374">        if (feat_is_staircase(grd(loc)))</a>
<a name="ln2375">            real_stairs = true;</a>
<a name="ln2376"> </a>
<a name="ln2377">    // Don't mention staircases if there aren't any nearby.</a>
<a name="ln2378">    string stair_msg = _get_xom_speech(&quot;repel stairs&quot;);</a>
<a name="ln2379">    if (stair_msg.find(&quot;@staircase@&quot;) != string::npos)</a>
<a name="ln2380">    {</a>
<a name="ln2381">        string feat_name;</a>
<a name="ln2382">        if (!real_stairs)</a>
<a name="ln2383">        {</a>
<a name="ln2384">            if (feat_is_escape_hatch(grd(stairs_avail[0])))</a>
<a name="ln2385">                feat_name = &quot;escape hatch&quot;;</a>
<a name="ln2386">            else</a>
<a name="ln2387">                feat_name = &quot;gate&quot;;</a>
<a name="ln2388">        }</a>
<a name="ln2389">        else</a>
<a name="ln2390">            feat_name = &quot;staircase&quot;;</a>
<a name="ln2391">        stair_msg = replace_all(stair_msg, &quot;@staircase@&quot;, feat_name);</a>
<a name="ln2392">    }</a>
<a name="ln2393"> </a>
<a name="ln2394">    god_speaks(GOD_XOM, stair_msg.c_str());</a>
<a name="ln2395"> </a>
<a name="ln2396">    you.duration[DUR_REPEL_STAIRS_MOVE] = 1000; // 100 turns</a>
<a name="ln2397">    if (unclimbable)</a>
<a name="ln2398">        you.duration[DUR_REPEL_STAIRS_CLIMB] = 500; // 50 turns</a>
<a name="ln2399"> </a>
<a name="ln2400">    shuffle_array(stairs_avail);</a>
<a name="ln2401">    int count_moved = 0;</a>
<a name="ln2402">    for (coord_def stair : stairs_avail)</a>
<a name="ln2403">        if (move_stair(stair, true, true))</a>
<a name="ln2404">            count_moved++;</a>
<a name="ln2405"> </a>
<a name="ln2406">    if (!count_moved)</a>
<a name="ln2407">    {</a>
<a name="ln2408">        if (one_chance_in(8))</a>
<a name="ln2409">            mpr(&quot;Nothing appears to happen... Ominous!&quot;);</a>
<a name="ln2410">        else</a>
<a name="ln2411">            canned_msg(MSG_NOTHING_HAPPENS);</a>
<a name="ln2412">    }</a>
<a name="ln2413">    else</a>
<a name="ln2414">        take_note(Note(NOTE_XOM_EFFECT, you.piety, -1, &quot;repel stairs&quot;), true);</a>
<a name="ln2415">}</a>
<a name="ln2416"> </a>
<a name="ln2417">static void _xom_moving_stairs(int) { _xom_repel_stairs(false); }</a>
<a name="ln2418">static void _xom_unclimbable_stairs(int) { _xom_repel_stairs(true); }</a>
<a name="ln2419"> </a>
<a name="ln2420">static void _xom_cloud_trail(int /*sever*/)</a>
<a name="ln2421">{</a>
<a name="ln2422">    you.duration[DUR_CLOUD_TRAIL] = random_range(600, 1200);</a>
<a name="ln2423">    you.props[XOM_CLOUD_TRAIL_TYPE_KEY] =</a>
<a name="ln2424">        // 80% chance of a useful trail</a>
<a name="ln2425">        random_choose_weighted(20, CLOUD_CHAOS,</a>
<a name="ln2426">                               10, CLOUD_MAGIC_TRAIL,</a>
<a name="ln2427">                               5,  CLOUD_MIASMA,</a>
<a name="ln2428">                               5,  CLOUD_PETRIFY,</a>
<a name="ln2429">                               5,  CLOUD_MUTAGENIC,</a>
<a name="ln2430">                               5,  CLOUD_NEGATIVE_ENERGY);</a>
<a name="ln2431"> </a>
<a name="ln2432">    take_note(Note(NOTE_XOM_EFFECT, you.piety, -1, &quot;cloud trail&quot;), true);</a>
<a name="ln2433"> </a>
<a name="ln2434">    const string speech = _get_xom_speech(&quot;cloud trail&quot;);</a>
<a name="ln2435">    god_speaks(GOD_XOM, speech.c_str());</a>
<a name="ln2436">}</a>
<a name="ln2437"> </a>
<a name="ln2438">static void _xom_statloss(int /*sever*/)</a>
<a name="ln2439">{</a>
<a name="ln2440">    const string speech = _get_xom_speech(&quot;draining or torment&quot;);</a>
<a name="ln2441">    const bool nasty = _xom_feels_nasty();</a>
<a name="ln2442"> </a>
<a name="ln2443">    const stat_type stat = static_cast&lt;stat_type&gt;(random2(NUM_STATS));</a>
<a name="ln2444">    int loss = 1;</a>
<a name="ln2445"> </a>
<a name="ln2446">    // Don't kill the player unless Xom is being nasty.</a>
<a name="ln2447">    if (nasty)</a>
<a name="ln2448">        loss = 1 + random2(3);</a>
<a name="ln2449">    else if (you.stat(stat) &lt;= loss)</a>
<a name="ln2450">        return;</a>
<a name="ln2451"> </a>
<a name="ln2452">    god_speaks(GOD_XOM, speech.c_str());</a>
<a name="ln2453">    lose_stat(stat, loss);</a>
<a name="ln2454"> </a>
<a name="ln2455">    const char* sstr[3] = { &quot;Str&quot;, &quot;Int&quot;, &quot;Dex&quot; };</a>
<a name="ln2456">    const string note = make_stringf(&quot;stat loss: -%d %s (%d/%d)&quot;,</a>
<a name="ln2457">                                     loss, sstr[stat], you.stat(stat),</a>
<a name="ln2458">                                     you.max_stat(stat));</a>
<a name="ln2459"> </a>
<a name="ln2460">    take_note(Note(NOTE_XOM_EFFECT, you.piety, -1, note), true);</a>
<a name="ln2461">}</a>
<a name="ln2462"> </a>
<a name="ln2463">static void _xom_draining(int /*sever*/)</a>
<a name="ln2464">{</a>
<a name="ln2465">    const string speech = _get_xom_speech(&quot;draining or torment&quot;);</a>
<a name="ln2466">    god_speaks(GOD_XOM, speech.c_str());</a>
<a name="ln2467"> </a>
<a name="ln2468">    drain_player(100, true);</a>
<a name="ln2469"> </a>
<a name="ln2470">    take_note(Note(NOTE_XOM_EFFECT, you.piety, -1, &quot;draining&quot;), true);</a>
<a name="ln2471">}</a>
<a name="ln2472"> </a>
<a name="ln2473">static void _xom_torment(int /*sever*/)</a>
<a name="ln2474">{</a>
<a name="ln2475">    const string speech = _get_xom_speech(&quot;draining or torment&quot;);</a>
<a name="ln2476">    god_speaks(GOD_XOM, speech.c_str());</a>
<a name="ln2477"> </a>
<a name="ln2478">    torment_player(0, TORMENT_XOM);</a>
<a name="ln2479"> </a>
<a name="ln2480">    const string note = make_stringf(&quot;torment (%d/%d hp)&quot;, you.hp, you.hp_max);</a>
<a name="ln2481">    take_note(Note(NOTE_XOM_EFFECT, you.piety, -1, note), true);</a>
<a name="ln2482">}</a>
<a name="ln2483"> </a>
<a name="ln2484">static monster* _xom_summon_hostile(monster_type hostile)</a>
<a name="ln2485">{</a>
<a name="ln2486">    return create_monster(mgen_data::hostile_at(hostile, true, you.pos())</a>
<a name="ln2487">                          .set_summoned(nullptr, 4, MON_SUMM_WRATH, GOD_XOM)</a>
<a name="ln2488">                          .set_non_actor_summoner(&quot;Xom&quot;));</a>
<a name="ln2489">}</a>
<a name="ln2490"> </a>
<a name="ln2491">static void _xom_summon_hostiles(int sever)</a>
<a name="ln2492">{</a>
<a name="ln2493">    int num_summoned = 0;</a>
<a name="ln2494">    const bool shadow_creatures = one_chance_in(3);</a>
<a name="ln2495"> </a>
<a name="ln2496">    if (shadow_creatures)</a>
<a name="ln2497">    {</a>
<a name="ln2498">        // Small number of shadow creatures.</a>
<a name="ln2499">        int count = 1 + random2(4);</a>
<a name="ln2500">        for (int i = 0; i &lt; count; ++i)</a>
<a name="ln2501">            if (_xom_summon_hostile(RANDOM_MOBILE_MONSTER))</a>
<a name="ln2502">                num_summoned++;</a>
<a name="ln2503">    }</a>
<a name="ln2504">    else</a>
<a name="ln2505">    {</a>
<a name="ln2506">        // The number of demons is dependent on severity, though heavily</a>
<a name="ln2507">        // randomised.</a>
<a name="ln2508">        int numdemons = sever;</a>
<a name="ln2509">        for (int i = 0; i &lt; 3; ++i)</a>
<a name="ln2510">            numdemons = random2(numdemons + 1);</a>
<a name="ln2511">        numdemons = min(numdemons + 1, 14);</a>
<a name="ln2512"> </a>
<a name="ln2513">        // Limit number of demons by experience level.</a>
<a name="ln2514">        if (!you.penance[GOD_XOM])</a>
<a name="ln2515">        {</a>
<a name="ln2516">            const int maxdemons = ((you.experience_level / 2) + 1);</a>
<a name="ln2517">            if (numdemons &gt; maxdemons)</a>
<a name="ln2518">                numdemons = maxdemons;</a>
<a name="ln2519">        }</a>
<a name="ln2520"> </a>
<a name="ln2521">        for (int i = 0; i &lt; numdemons; ++i)</a>
<a name="ln2522">            if (_xom_summon_hostile(_xom_random_demon(sever)))</a>
<a name="ln2523">                num_summoned++;</a>
<a name="ln2524">    }</a>
<a name="ln2525"> </a>
<a name="ln2526">    if (num_summoned &gt; 0)</a>
<a name="ln2527">    {</a>
<a name="ln2528">        const string note = make_stringf(&quot;summons %d hostile %s%s&quot;,</a>
<a name="ln2529">                                         num_summoned,</a>
<a name="ln2530">                                         shadow_creatures ? &quot;shadow creature&quot;</a>
<a name="ln2531">                                                          : &quot;demon&quot;,</a>
<a name="ln2532">                                         num_summoned &gt; 1 ? &quot;s&quot; : &quot;&quot;);</a>
<a name="ln2533">        take_note(Note(NOTE_XOM_EFFECT, you.piety, -1, note), true);</a>
<a name="ln2534"> </a>
<a name="ln2535">        const string speech = _get_xom_speech(&quot;hostile monster&quot;);</a>
<a name="ln2536">        god_speaks(GOD_XOM, speech.c_str());</a>
<a name="ln2537">    }</a>
<a name="ln2538">}</a>
<a name="ln2539"> </a>
<a name="ln2540">static bool _has_min_banishment_level()</a>
<a name="ln2541">{</a>
<a name="ln2542">    return you.experience_level &gt;= 9;</a>
<a name="ln2543">}</a>
<a name="ln2544"> </a>
<a name="ln2545">// Rolls whether banishment will be averted.</a>
<a name="ln2546">static bool _will_not_banish()</a>
<a name="ln2547">{</a>
<a name="ln2548">    return x_chance_in_y(5, you.experience_level);</a>
<a name="ln2549">}</a>
<a name="ln2550"> </a>
<a name="ln2551">// Disallow early banishment and make it much rarer later-on.</a>
<a name="ln2552">// While Xom is bored, the chance is increased.</a>
<a name="ln2553">static bool _allow_xom_banishment()</a>
<a name="ln2554">{</a>
<a name="ln2555">    // Always allowed if under penance.</a>
<a name="ln2556">    if (player_under_penance(GOD_XOM))</a>
<a name="ln2557">        return true;</a>
<a name="ln2558"> </a>
<a name="ln2559">    // If Xom is bored, banishment becomes viable earlier.</a>
<a name="ln2560">    if (_xom_is_bored())</a>
<a name="ln2561">        return !_will_not_banish();</a>
<a name="ln2562"> </a>
<a name="ln2563">    // Below the minimum experience level, only fake banishment is allowed.</a>
<a name="ln2564">    if (!_has_min_banishment_level())</a>
<a name="ln2565">    {</a>
<a name="ln2566">        // Allow banishment; it will be retracted right away.</a>
<a name="ln2567">        if (one_chance_in(5) &amp;&amp; x_chance_in_y(you.piety, 1000))</a>
<a name="ln2568">            return true;</a>
<a name="ln2569">        else</a>
<a name="ln2570">            return false;</a>
<a name="ln2571">    }</a>
<a name="ln2572">    else if (_will_not_banish())</a>
<a name="ln2573">        return false;</a>
<a name="ln2574"> </a>
<a name="ln2575">    return true;</a>
<a name="ln2576">}</a>
<a name="ln2577"> </a>
<a name="ln2578">static void _revert_banishment(bool xom_banished = true)</a>
<a name="ln2579">{</a>
<a name="ln2580">    more();</a>
<a name="ln2581">    god_speaks(GOD_XOM, xom_banished</a>
<a name="ln2582">               ? _get_xom_speech(&quot;revert own banishment&quot;).c_str()</a>
<a name="ln2583">               : _get_xom_speech(&quot;revert other banishment&quot;).c_str());</a>
<a name="ln2584">    down_stairs(DNGN_EXIT_ABYSS);</a>
<a name="ln2585">    take_note(Note(NOTE_XOM_EFFECT, you.piety, -1,</a>
<a name="ln2586">                   &quot;revert banishment&quot;), true);</a>
<a name="ln2587">}</a>
<a name="ln2588"> </a>
<a name="ln2589">xom_event_type xom_maybe_reverts_banishment(bool xom_banished, bool debug)</a>
<a name="ln2590">{</a>
<a name="ln2591">    // Never revert if Xom is bored or the player is under penance.</a>
<a name="ln2592">    if (_xom_feels_nasty())</a>
<a name="ln2593">        return XOM_BAD_BANISHMENT;</a>
<a name="ln2594"> </a>
<a name="ln2595">    // Sometimes Xom will immediately revert banishment.</a>
<a name="ln2596">    // Always if the banishment happened below the minimum exp level and Xom was responsible.</a>
<a name="ln2597">    if (xom_banished &amp;&amp; !_has_min_banishment_level() || x_chance_in_y(you.piety, 1000))</a>
<a name="ln2598">    {</a>
<a name="ln2599">        if (!debug)</a>
<a name="ln2600">            _revert_banishment(xom_banished);</a>
<a name="ln2601">        return XOM_BAD_PSEUDO_BANISHMENT;</a>
<a name="ln2602">    }</a>
<a name="ln2603">    return XOM_BAD_BANISHMENT;</a>
<a name="ln2604">}</a>
<a name="ln2605"> </a>
<a name="ln2606">static void _xom_do_banishment(bool real)</a>
<a name="ln2607">{</a>
<a name="ln2608">    god_speaks(GOD_XOM, _get_xom_speech(&quot;banishment&quot;).c_str());</a>
<a name="ln2609"> </a>
<a name="ln2610">    // Handles note taking, scales depth by XL</a>
<a name="ln2611">    banished(&quot;Xom&quot;, you.experience_level);</a>
<a name="ln2612">    if (!real)</a>
<a name="ln2613">        _revert_banishment();</a>
<a name="ln2614">}</a>
<a name="ln2615"> </a>
<a name="ln2616">static void _xom_banishment(int /*sever*/) { _xom_do_banishment(true); }</a>
<a name="ln2617">static void _xom_pseudo_banishment(int) { _xom_do_banishment(false); }</a>
<a name="ln2618"> </a>
<a name="ln2619">static void _xom_noise(int /*sever*/)</a>
<a name="ln2620">{</a>
<a name="ln2621">    // Ranges from shout to shatter volume.</a>
<a name="ln2622">    const int noisiness = 12 + random2(19);</a>
<a name="ln2623"> </a>
<a name="ln2624">    god_speaks(GOD_XOM, _get_xom_speech(&quot;noise&quot;).c_str());</a>
<a name="ln2625">    // Xom isn't subject to silence.</a>
<a name="ln2626">    fake_noisy(noisiness, you.pos());</a>
<a name="ln2627"> </a>
<a name="ln2628">    take_note(Note(NOTE_XOM_EFFECT, you.piety, -1, &quot;noise&quot;), true);</a>
<a name="ln2629">}</a>
<a name="ln2630"> </a>
<a name="ln2631">static bool _mon_valid_blink_victim(const monster&amp; mon)</a>
<a name="ln2632">{</a>
<a name="ln2633">    return !mon.wont_attack()</a>
<a name="ln2634">            &amp;&amp; !mon.no_tele()</a>
<a name="ln2635">            &amp;&amp; !mons_is_projectile(mon);</a>
<a name="ln2636">}</a>
<a name="ln2637"> </a>
<a name="ln2638">static void _xom_blink_monsters(int /*sever*/)</a>
<a name="ln2639">{</a>
<a name="ln2640">    int blinks = 0;</a>
<a name="ln2641">    // Sometimes blink towards the player, sometimes randomly. It might</a>
<a name="ln2642">    // end up being helpful instead of dangerous, but Xom doesn't mind.</a>
<a name="ln2643">    const bool blink_to_player = _xom_feels_nasty() || coinflip();</a>
<a name="ln2644">    for (monster_near_iterator mi(you.pos(), LOS_NO_TRANS); mi; ++mi)</a>
<a name="ln2645">    {</a>
<a name="ln2646">        if (blinks &gt;= 5)</a>
<a name="ln2647">            break;</a>
<a name="ln2648"> </a>
<a name="ln2649">        if (!_mon_valid_blink_victim(**mi) || coinflip())</a>
<a name="ln2650">            continue;</a>
<a name="ln2651"> </a>
<a name="ln2652">        // Only give this message once.</a>
<a name="ln2653">        if (!blinks)</a>
<a name="ln2654">            god_speaks(GOD_XOM, _get_xom_speech(&quot;blink monsters&quot;).c_str());</a>
<a name="ln2655"> </a>
<a name="ln2656">        if (blink_to_player)</a>
<a name="ln2657">            blink_other_close(*mi, you.pos());</a>
<a name="ln2658">        else</a>
<a name="ln2659">            monster_blink(*mi, false);</a>
<a name="ln2660"> </a>
<a name="ln2661">        blinks++;</a>
<a name="ln2662">    }</a>
<a name="ln2663"> </a>
<a name="ln2664">    if (blinks)</a>
<a name="ln2665">    {</a>
<a name="ln2666">        take_note(Note(NOTE_XOM_EFFECT, you.piety, -1, &quot;blink monster(s)&quot;),</a>
<a name="ln2667">                  true);</a>
<a name="ln2668">    }</a>
<a name="ln2669">}</a>
<a name="ln2670"> </a>
<a name="ln2671">static void _xom_cleaving(int sever)</a>
<a name="ln2672">{</a>
<a name="ln2673">    god_speaks(GOD_XOM, _get_xom_speech(&quot;cleaving&quot;).c_str());</a>
<a name="ln2674"> </a>
<a name="ln2675">    you.increase_duration(DUR_CLEAVE, 10 + random2(sever));</a>
<a name="ln2676"> </a>
<a name="ln2677">    if (const item_def* const weapon = you.weapon())</a>
<a name="ln2678">    {</a>
<a name="ln2679">        const bool axe = item_attack_skill(*weapon) == SK_AXES;</a>
<a name="ln2680">        mprf(MSGCH_DURATION,</a>
<a name="ln2681">             &quot;%s %s sharp%s&quot;, weapon-&gt;name(DESC_YOUR).c_str(),</a>
<a name="ln2682">             conjugate_verb(&quot;look&quot;, weapon-&gt;quantity &gt; 1).c_str(),</a>
<a name="ln2683">             (axe) ? &quot; (like it always does).&quot; : &quot;.&quot;);</a>
<a name="ln2684">    }</a>
<a name="ln2685">    else</a>
<a name="ln2686">    {</a>
<a name="ln2687">        mprf(MSGCH_DURATION, &quot;%s&quot;,</a>
<a name="ln2688">             you.hands_act(&quot;look&quot;, &quot;sharp.&quot;).c_str());</a>
<a name="ln2689">    }</a>
<a name="ln2690"> </a>
<a name="ln2691">    take_note(Note(NOTE_XOM_EFFECT, you.piety, -1, &quot;cleaving&quot;), true);</a>
<a name="ln2692">}</a>
<a name="ln2693"> </a>
<a name="ln2694"> </a>
<a name="ln2695">static void _handle_accidental_death(const int orig_hp,</a>
<a name="ln2696">    const FixedVector&lt;uint8_t, NUM_MUTATIONS&gt; &amp;orig_mutation,</a>
<a name="ln2697">    const transformation orig_form)</a>
<a name="ln2698">{</a>
<a name="ln2699">    // Did ouch() return early because the player died from the Xom</a>
<a name="ln2700">    // effect, even though neither is the player under penance nor is</a>
<a name="ln2701">    // Xom bored?</a>
<a name="ln2702">    if ((!you.did_escape_death()</a>
<a name="ln2703">         &amp;&amp; you.escaped_death_aux.empty()</a>
<a name="ln2704">         &amp;&amp; !_player_is_dead())</a>
<a name="ln2705">        || you.pending_revival) // don't let xom take credit for felid revival</a>
<a name="ln2706">    {</a>
<a name="ln2707">        // The player is fine.</a>
<a name="ln2708">        return;</a>
<a name="ln2709">    }</a>
<a name="ln2710"> </a>
<a name="ln2711">    string speech_type = XOM_SPEECH(&quot;accidental homicide&quot;);</a>
<a name="ln2712"> </a>
<a name="ln2713">    const dungeon_feature_type feat = grd(you.pos());</a>
<a name="ln2714"> </a>
<a name="ln2715">    switch (you.escaped_death_cause)</a>
<a name="ln2716">    {</a>
<a name="ln2717">        case NUM_KILLBY:</a>
<a name="ln2718">        case KILLED_BY_LEAVING:</a>
<a name="ln2719">        case KILLED_BY_WINNING:</a>
<a name="ln2720">        case KILLED_BY_QUITTING:</a>
<a name="ln2721">            speech_type = XOM_SPEECH(&quot;weird death&quot;);</a>
<a name="ln2722">            break;</a>
<a name="ln2723"> </a>
<a name="ln2724">        case KILLED_BY_LAVA:</a>
<a name="ln2725">        case KILLED_BY_WATER:</a>
<a name="ln2726">            if (!is_feat_dangerous(feat))</a>
<a name="ln2727">                speech_type = &quot;weird death&quot;;</a>
<a name="ln2728">            break;</a>
<a name="ln2729"> </a>
<a name="ln2730">        default:</a>
<a name="ln2731">            if (is_feat_dangerous(feat))</a>
<a name="ln2732">                speech_type = &quot;weird death&quot;;</a>
<a name="ln2733">        break;</a>
<a name="ln2734">    }</a>
<a name="ln2735"> </a>
<a name="ln2736">    canned_msg(MSG_YOU_DIE);</a>
<a name="ln2737">    god_speaks(GOD_XOM, _get_xom_speech(speech_type).c_str());</a>
<a name="ln2738">    god_speaks(GOD_XOM, _get_xom_speech(&quot;resurrection&quot;).c_str());</a>
<a name="ln2739"> </a>
<a name="ln2740">    int pre_mut_hp = you.hp;</a>
<a name="ln2741">    if (you.hp &lt;= 0)</a>
<a name="ln2742">        you.hp = 9999; // avoid spurious recursive deaths if heavily rotten</a>
<a name="ln2743"> </a>
<a name="ln2744">    // If any mutation has changed, death was because of it.</a>
<a name="ln2745">    for (int i = 0; i &lt; NUM_MUTATIONS; ++i)</a>
<a name="ln2746">    {</a>
<a name="ln2747">        if (orig_mutation[i] &gt; you.mutation[i])</a>
<a name="ln2748">            mutate((mutation_type)i, &quot;Xom's lifesaving&quot;, true, true, true);</a>
<a name="ln2749">        else if (orig_mutation[i] &lt; you.mutation[i])</a>
<a name="ln2750">            delete_mutation((mutation_type)i, &quot;Xom's lifesaving&quot;, true, true, true);</a>
<a name="ln2751">    }</a>
<a name="ln2752"> </a>
<a name="ln2753">    if (pre_mut_hp &lt;= 0)</a>
<a name="ln2754">        set_hp(min(orig_hp, you.hp_max));</a>
<a name="ln2755"> </a>
<a name="ln2756">    if (orig_form != you.form)</a>
<a name="ln2757">    {</a>
<a name="ln2758">        dprf(&quot;Trying emergency untransformation.&quot;);</a>
<a name="ln2759">        you.transform_uncancellable = false;</a>
<a name="ln2760">        transform(10, orig_form, true);</a>
<a name="ln2761">    }</a>
<a name="ln2762"> </a>
<a name="ln2763">    if (is_feat_dangerous(feat) &amp;&amp; !crawl_state.game_is_sprint())</a>
<a name="ln2764">        you_teleport_now();</a>
<a name="ln2765">}</a>
<a name="ln2766"> </a>
<a name="ln2767">/**</a>
<a name="ln2768"> * Try to choose an action for Xom to take that is at least notionally 'good'</a>
<a name="ln2769"> * for the player.</a>
<a name="ln2770"> *</a>
<a name="ln2771"> * @param sever         The intended magnitude of the action.</a>
<a name="ln2772"> * @param tension       How much danger we think the player's currently in.</a>
<a name="ln2773"> * @return              A good action for Xom to take, e.g. XOM_GOOD_ALLIES.</a>
<a name="ln2774"> */</a>
<a name="ln2775">static xom_event_type _xom_choose_good_action(int sever, int tension)</a>
<a name="ln2776">{</a>
<a name="ln2777">    // This series of random calls produces a poisson-looking</a>
<a name="ln2778">    // distribution: initial hump, plus a long-ish tail.</a>
<a name="ln2779">    // a wizard has pronounced a curse on the original author of this code</a>
<a name="ln2780"> </a>
<a name="ln2781">    // Don't make the player go berserk, etc. if there's no danger.</a>
<a name="ln2782">    if (tension &gt; random2(3) &amp;&amp; x_chance_in_y(2, sever))</a>
<a name="ln2783">        return XOM_GOOD_POTION;</a>
<a name="ln2784"> </a>
<a name="ln2785">    if (x_chance_in_y(3, sever))</a>
<a name="ln2786">    {</a>
<a name="ln2787">        const xom_event_type divination</a>
<a name="ln2788">            = random_choose(XOM_GOOD_MAGIC_MAPPING,</a>
<a name="ln2789">                            XOM_GOOD_DETECT_CREATURES,</a>
<a name="ln2790">                            XOM_GOOD_DETECT_ITEMS);</a>
<a name="ln2791"> </a>
<a name="ln2792">        if (divination == XOM_GOOD_DETECT_CREATURES)</a>
<a name="ln2793">        {</a>
<a name="ln2794">            return divination; // useful regardless of exploration state</a>
<a name="ln2795"> </a>
<a name="ln2796">        // Only do mmap/detect items if there's a decent chunk of unexplored</a>
<a name="ln2797">        }</a>
<a name="ln2798">        // level left</a>
<a name="ln2799">        const int explored = _exploration_estimate(false);</a>
<a name="ln2800">        if (explored &lt;= 80 || x_chance_in_y(explored, 100))</a>
<a name="ln2801">            return divination;</a>
<a name="ln2802">    }</a>
<a name="ln2803"> </a>
<a name="ln2804">    if (x_chance_in_y(4, sever) &amp;&amp; tension &gt; 0</a>
<a name="ln2805">        &amp;&amp; _choose_random_spell(sever) != SPELL_NO_SPELL)</a>
<a name="ln2806">    {</a>
<a name="ln2807">        return XOM_GOOD_SPELL;</a>
<a name="ln2808">    }</a>
<a name="ln2809"> </a>
<a name="ln2810">    if (tension &lt;= 0 &amp;&amp; x_chance_in_y(5, sever)</a>
<a name="ln2811">        &amp;&amp; !you.duration[DUR_CLOUD_TRAIL])</a>
<a name="ln2812">    {</a>
<a name="ln2813">        return XOM_GOOD_CLOUD_TRAIL;</a>
<a name="ln2814">    }</a>
<a name="ln2815"> </a>
<a name="ln2816">    if (tension &gt; 0 &amp;&amp; x_chance_in_y(5, sever)</a>
<a name="ln2817">        &amp;&amp; mon_nearby([](monster&amp; mon){ return !mon.wont_attack(); }))</a>
<a name="ln2818">    {</a>
<a name="ln2819">        return XOM_GOOD_CONFUSION;</a>
<a name="ln2820">    }</a>
<a name="ln2821"> </a>
<a name="ln2822">    if (tension &gt; 0 &amp;&amp; x_chance_in_y(6, sever)</a>
<a name="ln2823">        &amp;&amp; mon_nearby(_choose_enchantable_monster))</a>
<a name="ln2824">    {</a>
<a name="ln2825">        return XOM_GOOD_ENCHANT_MONSTER;</a>
<a name="ln2826">    }</a>
<a name="ln2827"> </a>
<a name="ln2828">    if (tension &gt; random2(5) &amp;&amp; x_chance_in_y(7, sever)</a>
<a name="ln2829">        &amp;&amp; !you.get_mutation_level(MUT_NO_LOVE))</a>
<a name="ln2830">    {</a>
<a name="ln2831">        return XOM_GOOD_SINGLE_ALLY;</a>
<a name="ln2832">    }</a>
<a name="ln2833">    if (tension &lt; random2(5) &amp;&amp; x_chance_in_y(8, sever)</a>
<a name="ln2834">        &amp;&amp; !_xom_scenery_candidates().empty() || one_chance_in(8))</a>
<a name="ln2835">    {</a>
<a name="ln2836">        return XOM_GOOD_SCENERY;</a>
<a name="ln2837">    }</a>
<a name="ln2838"> </a>
<a name="ln2839">    if (x_chance_in_y(9, sever) &amp;&amp; mon_nearby(_hostile_snake))</a>
<a name="ln2840">        return XOM_GOOD_SNAKES;</a>
<a name="ln2841"> </a>
<a name="ln2842">    if (tension &gt; random2(10) &amp;&amp; x_chance_in_y(10, sever)</a>
<a name="ln2843">        &amp;&amp; !you.get_mutation_level(MUT_NO_LOVE))</a>
<a name="ln2844">    {</a>
<a name="ln2845">        return XOM_GOOD_ALLIES;</a>
<a name="ln2846">    }</a>
<a name="ln2847">    if (tension &gt; random2(8) &amp;&amp; x_chance_in_y(11, sever)</a>
<a name="ln2848">        &amp;&amp; _find_monster_with_animateable_weapon()</a>
<a name="ln2849">        &amp;&amp; !you.get_mutation_level(MUT_NO_LOVE))</a>
<a name="ln2850">    {</a>
<a name="ln2851">        return XOM_GOOD_ANIMATE_MON_WPN;</a>
<a name="ln2852">    }</a>
<a name="ln2853"> </a>
<a name="ln2854">    if (x_chance_in_y(12, sever) &amp;&amp; _xom_mons_poly_target() != nullptr)</a>
<a name="ln2855">        return XOM_GOOD_POLYMORPH;</a>
<a name="ln2856"> </a>
<a name="ln2857">    if (tension &gt; 0 &amp;&amp; x_chance_in_y(13, sever))</a>
<a name="ln2858">    {</a>
<a name="ln2859">        const bool fake = one_chance_in(3);</a>
<a name="ln2860">        for (monster_near_iterator mi(you.pos(), LOS_NO_TRANS); mi; ++mi)</a>
<a name="ln2861">        {</a>
<a name="ln2862">            if (mons_is_projectile(**mi)</a>
<a name="ln2863">                || mons_is_tentacle_or_tentacle_segment(mi-&gt;type))</a>
<a name="ln2864">            {</a>
<a name="ln2865">                continue;</a>
<a name="ln2866">            }</a>
<a name="ln2867"> </a>
<a name="ln2868">            if (fake)</a>
<a name="ln2869">                return XOM_GOOD_FAKE_DESTRUCTION;</a>
<a name="ln2870"> </a>
<a name="ln2871">            // Skip adjacent monsters, and skip non-hostile monsters if not feeling nasty.</a>
<a name="ln2872">            if (!adjacent(you.pos(), mi-&gt;pos())</a>
<a name="ln2873">                 &amp;&amp; (!mi-&gt;wont_attack() || _xom_feels_nasty()))</a>
<a name="ln2874">            {</a>
<a name="ln2875">                return XOM_GOOD_DESTRUCTION;</a>
<a name="ln2876">            }</a>
<a name="ln2877">        }</a>
<a name="ln2878">    }</a>
<a name="ln2879"> </a>
<a name="ln2880">    if (tension &gt; random2(5) &amp;&amp; x_chance_in_y(14, sever))</a>
<a name="ln2881">        return XOM_GOOD_CLEAVING;</a>
<a name="ln2882"> </a>
<a name="ln2883">    if (tension &gt; 0 &amp;&amp; x_chance_in_y(15, sever) &amp;&amp; !cloud_at(you.pos()))</a>
<a name="ln2884">        return XOM_GOOD_FOG;</a>
<a name="ln2885"> </a>
<a name="ln2886">    if (random2(tension) &lt; 15 &amp;&amp; x_chance_in_y(16, sever))</a>
<a name="ln2887">    {</a>
<a name="ln2888">        return x_chance_in_y(sever, 201) ? XOM_GOOD_ACQUIREMENT</a>
<a name="ln2889">                                         : XOM_GOOD_RANDOM_ITEM;</a>
<a name="ln2890">    }</a>
<a name="ln2891"> </a>
<a name="ln2892">    if (!player_in_branch(BRANCH_ABYSS) &amp;&amp; x_chance_in_y(17, sever)</a>
<a name="ln2893">        &amp;&amp; _teleportation_check())</a>
<a name="ln2894">    {</a>
<a name="ln2895">        // This is not very interesting if the level is already fully</a>
<a name="ln2896">        // explored (presumably cleared). Even then, it may</a>
<a name="ln2897">        // occasionally happen.</a>
<a name="ln2898">        const int explored = _exploration_estimate(true);</a>
<a name="ln2899">        if (explored &lt; 80 || !x_chance_in_y(explored, 120))</a>
<a name="ln2900">            return XOM_GOOD_TELEPORT;</a>
<a name="ln2901">    }</a>
<a name="ln2902"> </a>
<a name="ln2903">    if (random2(tension) &lt; 5 &amp;&amp; x_chance_in_y(19, sever)</a>
<a name="ln2904">        &amp;&amp; x_chance_in_y(16, you.how_mutated())</a>
<a name="ln2905">        &amp;&amp; you.can_safely_mutate())</a>
<a name="ln2906">    {</a>
<a name="ln2907">        return XOM_GOOD_MUTATION;</a>
<a name="ln2908">    }</a>
<a name="ln2909"> </a>
<a name="ln2910">    if (tension &gt; 0 &amp;&amp; x_chance_in_y(20, sever)</a>
<a name="ln2911">        &amp;&amp; player_in_a_dangerous_place())</a>
<a name="ln2912">    {</a>
<a name="ln2913">        // Make sure there's at least one enemy within the lightning radius.</a>
<a name="ln2914">        for (radius_iterator ri(you.pos(), 2, C_SQUARE, LOS_SOLID, true); ri;</a>
<a name="ln2915">             ++ri)</a>
<a name="ln2916">        {</a>
<a name="ln2917">            const monster *mon = monster_at(*ri);</a>
<a name="ln2918">            if (mon &amp;&amp; !mon-&gt;wont_attack())</a>
<a name="ln2919">                return XOM_GOOD_LIGHTNING;</a>
<a name="ln2920">        }</a>
<a name="ln2921">    }</a>
<a name="ln2922"> </a>
<a name="ln2923">    return XOM_DID_NOTHING;</a>
<a name="ln2924">}</a>
<a name="ln2925"> </a>
<a name="ln2926">/**</a>
<a name="ln2927"> * Try to choose an action for Xom to take that is at least notionally 'bad'</a>
<a name="ln2928"> * for the player.</a>
<a name="ln2929"> *</a>
<a name="ln2930"> * @param sever         The intended magnitude of the action.</a>
<a name="ln2931"> * @param tension       How much danger we think the player's currently in.</a>
<a name="ln2932"> * @return              A bad action for Xom to take, e.g. XOM_BAD_NOISE.</a>
<a name="ln2933"> */</a>
<a name="ln2934">static xom_event_type _xom_choose_bad_action(int sever, int tension)</a>
<a name="ln2935">{</a>
<a name="ln2936">    const bool nasty = _miscast_is_nasty(sever);</a>
<a name="ln2937"> </a>
<a name="ln2938">    if (!nasty &amp;&amp; x_chance_in_y(3, sever))</a>
<a name="ln2939">        return XOM_BAD_MISCAST_PSEUDO;</a>
<a name="ln2940"> </a>
<a name="ln2941">    // Sometimes do noise out of combat.</a>
<a name="ln2942">    if ((tension &gt; 0 || coinflip()) &amp;&amp; x_chance_in_y(6, sever))</a>
<a name="ln2943">        return XOM_BAD_NOISE;</a>
<a name="ln2944">    if (tension &gt; 0 &amp;&amp; x_chance_in_y(7, sever))</a>
<a name="ln2945">        return XOM_BAD_ENCHANT_MONSTER;</a>
<a name="ln2946"> </a>
<a name="ln2947">    if (tension &gt; 0 &amp;&amp; x_chance_in_y(8, sever)</a>
<a name="ln2948">        &amp;&amp; mon_nearby(_mon_valid_blink_victim))</a>
<a name="ln2949">    {</a>
<a name="ln2950">        return XOM_BAD_BLINK_MONSTERS;</a>
<a name="ln2951">    }</a>
<a name="ln2952"> </a>
<a name="ln2953">    // It's pointless to confuse player if there's no danger nearby.</a>
<a name="ln2954">    if (tension &gt; 0 &amp;&amp; x_chance_in_y(9, sever))</a>
<a name="ln2955">        return XOM_BAD_CONFUSION;</a>
<a name="ln2956"> </a>
<a name="ln2957">    if (tension &gt; 0 &amp;&amp; x_chance_in_y(10, sever)</a>
<a name="ln2958">        &amp;&amp; _rearrangeable_pieces().size())</a>
<a name="ln2959">    {</a>
<a name="ln2960">        return XOM_BAD_SWAP_MONSTERS;</a>
<a name="ln2961">    }</a>
<a name="ln2962"> </a>
<a name="ln2963">    if (x_chance_in_y(14, sever) &amp;&amp; mon_nearby(_choose_chaos_upgrade))</a>
<a name="ln2964">        return XOM_BAD_CHAOS_UPGRADE;</a>
<a name="ln2965">    if (x_chance_in_y(15, sever) &amp;&amp; !player_in_branch(BRANCH_ABYSS)</a>
<a name="ln2966">        &amp;&amp; _teleportation_check())</a>
<a name="ln2967">    {</a>
<a name="ln2968">        const int explored = _exploration_estimate(true);</a>
<a name="ln2969">        if (!(nasty &amp;&amp; (explored &gt;= 40 || tension &gt; 10)</a>
<a name="ln2970">            || explored &gt;= 60 + random2(40)))</a>
<a name="ln2971">        {</a>
<a name="ln2972">            return XOM_BAD_TELEPORT;</a>
<a name="ln2973">        }</a>
<a name="ln2974">    }</a>
<a name="ln2975">    if (x_chance_in_y(16, sever))</a>
<a name="ln2976">        return XOM_BAD_POLYMORPH;</a>
<a name="ln2977"> // Pushing stairs/exits is always hilarious in the Abyss!</a>
<a name="ln2978">    if ((tension &gt; 0 || player_in_branch(BRANCH_ABYSS))</a>
<a name="ln2979">        &amp;&amp; x_chance_in_y(17, sever) &amp;&amp; !_nearby_stairs().empty()</a>
<a name="ln2980">        &amp;&amp; !you.duration[DUR_REPEL_STAIRS_MOVE]</a>
<a name="ln2981">        &amp;&amp; !you.duration[DUR_REPEL_STAIRS_CLIMB])</a>
<a name="ln2982">    {</a>
<a name="ln2983">        if (one_chance_in(5)</a>
<a name="ln2984">            || feat_stair_direction(grd(you.pos())) != CMD_NO_CMD</a>
<a name="ln2985">                &amp;&amp; grd(you.pos()) != DNGN_ENTER_SHOP)</a>
<a name="ln2986">        {</a>
<a name="ln2987">            return XOM_BAD_CLIMB_STAIRS;</a>
<a name="ln2988">        }</a>
<a name="ln2989">        return XOM_BAD_MOVING_STAIRS;</a>
<a name="ln2990">    }</a>
<a name="ln2991">    if (random2(tension) &lt; 11 &amp;&amp; x_chance_in_y(18, sever)</a>
<a name="ln2992">        &amp;&amp; you.can_safely_mutate())</a>
<a name="ln2993">    {</a>
<a name="ln2994">        return XOM_BAD_MUTATION;</a>
<a name="ln2995">    }</a>
<a name="ln2996">    if (x_chance_in_y(19, sever))</a>
<a name="ln2997">        return XOM_BAD_SUMMON_HOSTILES;</a>
<a name="ln2998"> </a>
<a name="ln2999">    if (x_chance_in_y(21, sever))</a>
<a name="ln3000">    {</a>
<a name="ln3001">        if (coinflip())</a>
<a name="ln3002">            return XOM_BAD_STATLOSS;</a>
<a name="ln3003">        if (coinflip())</a>
<a name="ln3004">        {</a>
<a name="ln3005">            if (player_prot_life() &lt; 3)</a>
<a name="ln3006">                return XOM_BAD_DRAINING;</a>
<a name="ln3007">            // else choose something else</a>
<a name="ln3008">        } else if (!player_res_torment(false))</a>
<a name="ln3009">            return XOM_BAD_TORMENT;</a>
<a name="ln3010">        // else choose something else</a>
<a name="ln3011">    }</a>
<a name="ln3012">    if (tension &gt; 0 &amp;&amp; x_chance_in_y(22, sever)</a>
<a name="ln3013">        &amp;&amp; !cloud_at(you.pos()))</a>
<a name="ln3014">    {</a>
<a name="ln3015">        return XOM_BAD_CHAOS_CLOUD;</a>
<a name="ln3016">    }</a>
<a name="ln3017">    if (one_chance_in(sever) &amp;&amp; !player_in_branch(BRANCH_ABYSS)</a>
<a name="ln3018">        &amp;&amp; _allow_xom_banishment())</a>
<a name="ln3019">    {</a>
<a name="ln3020">        return xom_maybe_reverts_banishment(true, true);</a>
<a name="ln3021">    }</a>
<a name="ln3022"> </a>
<a name="ln3023">    return XOM_DID_NOTHING; // ugh</a>
<a name="ln3024">}</a>
<a name="ln3025"> </a>
<a name="ln3026">/**</a>
<a name="ln3027"> * Try to choose an action for Xom to take.</a>
<a name="ln3028"> *</a>
<a name="ln3029"> * @param niceness      Whether the action should be 'good' for the player.</a>
<a name="ln3030"> * @param sever         The intended magnitude of the action.</a>
<a name="ln3031"> * @param tension       How much danger we think the player's currently in.</a>
<a name="ln3032"> * @return              An bad action for Xom to take, e.g. XOM_DID_NOTHING.</a>
<a name="ln3033"> */</a>
<a name="ln3034">xom_event_type xom_choose_action(bool niceness, int sever, int tension)</a>
<a name="ln3035">{</a>
<a name="ln3036">    sever = max(1, sever);</a>
<a name="ln3037"> </a>
<a name="ln3038">    if (_player_is_dead() &amp;&amp; !you.pending_revival)</a>
<a name="ln3039">    {</a>
<a name="ln3040">        // This should only happen if the player used wizard mode to</a>
<a name="ln3041">        // escape death from deep water or lava.</a>
<a name="ln3042">        ASSERT(you.wizard);</a>
<a name="ln3043">        ASSERT(!you.did_escape_death());</a>
<a name="ln3044">        if (is_feat_dangerous(grd(you.pos())))</a>
<a name="ln3045">            mprf(MSGCH_DIAGNOSTICS, &quot;Player is standing in deadly terrain, skipping Xom act.&quot;);</a>
<a name="ln3046">        else</a>
<a name="ln3047">            mprf(MSGCH_DIAGNOSTICS, &quot;Player is already dead, skipping Xom act.&quot;);</a>
<a name="ln3048">        return XOM_PLAYER_DEAD;</a>
<a name="ln3049">    }</a>
<a name="ln3050"> </a>
<a name="ln3051">    if (niceness)</a>
<a name="ln3052">    {</a>
<a name="ln3053">        // Make good acts at zero tension less likely, especially if Xom</a>
<a name="ln3054">        // is in a bad mood.</a>
<a name="ln3055">        if (tension == 0</a>
<a name="ln3056">            &amp;&amp; you_worship(GOD_XOM) &amp;&amp; !x_chance_in_y(you.piety, MAX_PIETY))</a>
<a name="ln3057">        {</a>
<a name="ln3058">#ifdef NOTE_DEBUG_XOM</a>
<a name="ln3059">            take_note(Note(NOTE_MESSAGE, 0, 0, &quot;suppress good act because of &quot;</a>
<a name="ln3060">                           &quot;zero tension&quot;), true);</a>
<a name="ln3061">#endif</a>
<a name="ln3062">            return XOM_DID_NOTHING;</a>
<a name="ln3063">        }</a>
<a name="ln3064"> </a>
<a name="ln3065">        // {sarcastically}: Good stuff. {seriously}: remove this loop</a>
<a name="ln3066">        while (true)</a>
<a name="ln3067">        {</a>
<a name="ln3068">            const xom_event_type action = _xom_choose_good_action(sever,</a>
<a name="ln3069">                                                                  tension);</a>
<a name="ln3070">            if (action != XOM_DID_NOTHING)</a>
<a name="ln3071">                return action;</a>
<a name="ln3072">        }</a>
<a name="ln3073">    }</a>
<a name="ln3074"> </a>
<a name="ln3075">    // Make bad acts at non-zero tension less likely, especially if Xom</a>
<a name="ln3076">    // is in a good mood.</a>
<a name="ln3077">    if (!_xom_feels_nasty() &amp;&amp; tension &gt; random2(10)</a>
<a name="ln3078">        &amp;&amp; you_worship(GOD_XOM) &amp;&amp; x_chance_in_y(you.piety, MAX_PIETY))</a>
<a name="ln3079">    {</a>
<a name="ln3080">#ifdef NOTE_DEBUG_XOM</a>
<a name="ln3081">        const string note = string(&quot;suppress bad act because of &quot;) +</a>
<a name="ln3082">                                   tension + &quot; tension&quot;;</a>
<a name="ln3083">        take_note(Note(NOTE_MESSAGE, 0, 0, note), true);</a>
<a name="ln3084">#endif</a>
<a name="ln3085">        return XOM_DID_NOTHING;</a>
<a name="ln3086">    }</a>
<a name="ln3087"> </a>
<a name="ln3088">    // Bad mojo. (this loop, that is)</a>
<a name="ln3089">    while (true)</a>
<a name="ln3090">    {</a>
<a name="ln3091">        const xom_event_type action = _xom_choose_bad_action(sever, tension);</a>
<a name="ln3092">        if (action != XOM_DID_NOTHING)</a>
<a name="ln3093">            return action;</a>
<a name="ln3094">    }</a>
<a name="ln3095"> </a>
<a name="ln3096">    die(&quot;This should never happen.&quot;);</a>
<a name="ln3097">}</a>
<a name="ln3098"> </a>
<a name="ln3099">/**</a>
<a name="ln3100"> * Execute the specified Xom Action.</a>
<a name="ln3101"> *</a>
<a name="ln3102"> * @param action        The action type in question; e.g. XOM_BAD_NOISE.</a>
<a name="ln3103"> * @param sever         The severity of the action.</a>
<a name="ln3104"> */</a>
<a name="ln3105">void xom_take_action(xom_event_type action, int sever)</a>
<a name="ln3106">{</a>
<a name="ln3107">    const int  orig_hp       = you.hp;</a>
<a name="ln3108">    const transformation orig_form = you.form;</a>
<a name="ln3109">    const FixedVector&lt;uint8_t, NUM_MUTATIONS&gt; orig_mutation = you.mutation;</a>
<a name="ln3110">    const bool was_bored = _xom_is_bored();</a>
<a name="ln3111"> </a>
<a name="ln3112">    const bool bad_effect = _action_is_bad(action);</a>
<a name="ln3113"> </a>
<a name="ln3114">    if (was_bored &amp;&amp; bad_effect &amp;&amp; Options.note_xom_effects)</a>
<a name="ln3115">        take_note(Note(NOTE_MESSAGE, 0, 0, &quot;XOM is BORED!&quot;), true);</a>
<a name="ln3116"> </a>
<a name="ln3117">    // actually take the action!</a>
<a name="ln3118">    {</a>
<a name="ln3119">        god_acting gdact(GOD_XOM);</a>
<a name="ln3120">        _do_xom_event(action, sever);</a>
<a name="ln3121">    }</a>
<a name="ln3122"> </a>
<a name="ln3123">    // If we got here because Xom was bored, reset gift timeout according</a>
<a name="ln3124">    // to the badness of the effect.</a>
<a name="ln3125">    if (bad_effect &amp;&amp; _xom_is_bored())</a>
<a name="ln3126">    {</a>
<a name="ln3127">        const int badness = _xom_event_badness(action);</a>
<a name="ln3128">        const int interest = random2avg(badness * 60, 2);</a>
<a name="ln3129">        you.gift_timeout   = min(interest, 255);</a>
<a name="ln3130">        //updating piety status line</a>
<a name="ln3131">        you.redraw_title = true;</a>
<a name="ln3132">#if defined(DEBUG_RELIGION) || defined(DEBUG_XOM)</a>
<a name="ln3133">        mprf(MSGCH_DIAGNOSTICS, &quot;badness: %d, new interest: %d&quot;,</a>
<a name="ln3134">             badness, you.gift_timeout);</a>
<a name="ln3135">#endif</a>
<a name="ln3136">    }</a>
<a name="ln3137"> </a>
<a name="ln3138">    _handle_accidental_death(orig_hp, orig_mutation, orig_form);</a>
<a name="ln3139"> </a>
<a name="ln3140">    if (you_worship(GOD_XOM) &amp;&amp; one_chance_in(5))</a>
<a name="ln3141">    {</a>
<a name="ln3142">        const string old_xom_favour = describe_xom_favour();</a>
<a name="ln3143">        you.piety = random2(MAX_PIETY + 1);</a>
<a name="ln3144">        you.redraw_title = true; // redraw piety/boredom display</a>
<a name="ln3145">        const string new_xom_favour = describe_xom_favour();</a>
<a name="ln3146">        if (was_bored || old_xom_favour != new_xom_favour)</a>
<a name="ln3147">        {</a>
<a name="ln3148">            const string msg = &quot;You are now &quot; + new_xom_favour;</a>
<a name="ln3149">            god_speaks(you.religion, msg.c_str());</a>
<a name="ln3150">        }</a>
<a name="ln3151">#ifdef NOTE_DEBUG_XOM</a>
<a name="ln3152">        const string note = string(&quot;reroll piety: &quot;) + you.piety;</a>
<a name="ln3153">        take_note(Note(NOTE_MESSAGE, 0, 0, note), true);</a>
<a name="ln3154">#endif</a>
<a name="ln3155">    }</a>
<a name="ln3156">    else if (was_bored)</a>
<a name="ln3157">    {</a>
<a name="ln3158">        // If we didn't reroll at least mention the new favour</a>
<a name="ln3159">        // now that it's not &quot;BORING thing&quot; anymore.</a>
<a name="ln3160">        const string new_xom_favour = describe_xom_favour();</a>
<a name="ln3161">        const string msg = &quot;You are now &quot; + new_xom_favour;</a>
<a name="ln3162">        god_speaks(you.religion, msg.c_str());</a>
<a name="ln3163">    }</a>
<a name="ln3164">}</a>
<a name="ln3165"> </a>
<a name="ln3166">/**</a>
<a name="ln3167"> * Let Xom take an action, probably.</a>
<a name="ln3168"> *</a>
<a name="ln3169"> * @param sever         The intended magnitude of the action.</a>
<a name="ln3170"> * @param nice          Whether the action should be 'good' for the player.</a>
<a name="ln3171"> *                      If MB_MAYBE, determined by xom's whim.</a>
<a name="ln3172"> *                      May be overridden.</a>
<a name="ln3173"> * @param tension       How much danger we think the player's currently in.</a>
<a name="ln3174"> * @return              Whichever action Xom took, or XOM_DID_NOTHING.</a>
<a name="ln3175"> */</a>
<a name="ln3176">xom_event_type xom_acts(int sever, maybe_bool nice, int tension, bool debug)</a>
<a name="ln3177">{</a>
<a name="ln3178">    bool niceness = tobool(nice, xom_is_nice(tension));</a>
<a name="ln3179"> </a>
<a name="ln3180">#if defined(DEBUG_RELIGION) || defined(DEBUG_XOM)</a>
<a name="ln3181">    if (!debug)</a>
<a name="ln3182">    {</a>
<a name="ln3183">        // This probably seems a bit odd, but we really don't want to display</a>
<a name="ln3184">        // these when doing a heavy-duty wiz-mode debug test: just ends up</a>
<a name="ln3185">        // as message spam and the player doesn't get any further information</a>
<a name="ln3186">        // anyway. (jpeg)</a>
<a name="ln3187"> </a>
<a name="ln3188">        // these numbers (sever, tension) may be modified later...</a>
<a name="ln3189">        mprf(MSGCH_DIAGNOSTICS, &quot;xom_acts(%u, %d, %d); piety: %u, interest: %u&quot;,</a>
<a name="ln3190">             niceness, sever, tension, you.piety, you.gift_timeout);</a>
<a name="ln3191"> </a>
<a name="ln3192">        static char xom_buf[100];</a>
<a name="ln3193">        snprintf(xom_buf, sizeof(xom_buf), &quot;xom_acts(%s, %d, %d), mood: %d&quot;,</a>
<a name="ln3194">                 (niceness ? &quot;true&quot; : &quot;false&quot;), sever, tension, you.piety);</a>
<a name="ln3195">        take_note(Note(NOTE_MESSAGE, 0, 0, xom_buf), true);</a>
<a name="ln3196">    }</a>
<a name="ln3197">#endif</a>
<a name="ln3198"> </a>
<a name="ln3199">    if (tension == -1)</a>
<a name="ln3200">        tension = get_tension(GOD_XOM);</a>
<a name="ln3201"> </a>
<a name="ln3202">#if defined(DEBUG_RELIGION) || defined(DEBUG_XOM) || defined(DEBUG_TENSION)</a>
<a name="ln3203">    // No message during heavy-duty wizmode testing:</a>
<a name="ln3204">    // Instead all results are written into xom_debug.stat.</a>
<a name="ln3205">    if (!debug)</a>
<a name="ln3206">        mprf(MSGCH_DIAGNOSTICS, &quot;Xom tension: %d&quot;, tension);</a>
<a name="ln3207">#endif</a>
<a name="ln3208"> </a>
<a name="ln3209">    const xom_event_type action = xom_choose_action(niceness, sever, tension);</a>
<a name="ln3210">    if (!debug)</a>
<a name="ln3211">        xom_take_action(action, sever);</a>
<a name="ln3212"> </a>
<a name="ln3213">    return action;</a>
<a name="ln3214">}</a>
<a name="ln3215"> </a>
<a name="ln3216">void xom_check_lost_item(const item_def&amp; item)</a>
<a name="ln3217">{</a>
<a name="ln3218">    if (is_unrandom_artefact(item))</a>
<a name="ln3219">        xom_is_stimulated(100, &quot;Xom snickers.&quot;, true);</a>
<a name="ln3220">}</a>
<a name="ln3221"> </a>
<a name="ln3222">void xom_check_destroyed_item(const item_def&amp; item)</a>
<a name="ln3223">{</a>
<a name="ln3224">    if (is_unrandom_artefact(item))</a>
<a name="ln3225">        xom_is_stimulated(100, &quot;Xom snickers.&quot;, true);</a>
<a name="ln3226">}</a>
<a name="ln3227"> </a>
<a name="ln3228">static bool _death_is_funny(const kill_method_type killed_by)</a>
<a name="ln3229">{</a>
<a name="ln3230">    switch (killed_by)</a>
<a name="ln3231">    {</a>
<a name="ln3232">    // The less original deaths are considered boring.</a>
<a name="ln3233">    case KILLED_BY_MONSTER:</a>
<a name="ln3234">    case KILLED_BY_BEAM:</a>
<a name="ln3235">    case KILLED_BY_CLOUD:</a>
<a name="ln3236">    case KILLED_BY_FREEZING:</a>
<a name="ln3237">    case KILLED_BY_BURNING:</a>
<a name="ln3238">    case KILLED_BY_SELF_AIMED:</a>
<a name="ln3239">    case KILLED_BY_SOMETHING:</a>
<a name="ln3240">    case KILLED_BY_TRAP:</a>
<a name="ln3241">        return false;</a>
<a name="ln3242">    default:</a>
<a name="ln3243">        // All others are fun (says Xom).</a>
<a name="ln3244">        return true;</a>
<a name="ln3245">    }</a>
<a name="ln3246">}</a>
<a name="ln3247"> </a>
<a name="ln3248">void xom_death_message(const kill_method_type killed_by)</a>
<a name="ln3249">{</a>
<a name="ln3250">    if (!you_worship(GOD_XOM) &amp;&amp; (!you.worshipped[GOD_XOM] || coinflip()))</a>
<a name="ln3251">        return;</a>
<a name="ln3252"> </a>
<a name="ln3253">    const int death_tension = get_tension(GOD_XOM);</a>
<a name="ln3254"> </a>
<a name="ln3255">    // &quot;Normal&quot; deaths with only down to -2 hp and comparatively low tension</a>
<a name="ln3256">    // are considered particularly boring.</a>
<a name="ln3257">    if (!_death_is_funny(killed_by) &amp;&amp; you.hp &gt;= -1 * random2(3)</a>
<a name="ln3258">        &amp;&amp; death_tension &lt;= random2(10))</a>
<a name="ln3259">    {</a>
<a name="ln3260">        god_speaks(GOD_XOM, _get_xom_speech(&quot;boring death&quot;).c_str());</a>
<a name="ln3261">    }</a>
<a name="ln3262">    // Unusual methods of dying, really low hp, or high tension make</a>
<a name="ln3263">    // for funny deaths.</a>
<a name="ln3264">    else if (_death_is_funny(killed_by) || you.hp &lt;= -10</a>
<a name="ln3265">             || death_tension &gt;= 20)</a>
<a name="ln3266">    {</a>
<a name="ln3267">        god_speaks(GOD_XOM, _get_xom_speech(&quot;laughter&quot;).c_str());</a>
<a name="ln3268">    }</a>
<a name="ln3269"> </a>
<a name="ln3270">    // All others just get ignored by Xom.</a>
<a name="ln3271">}</a>
<a name="ln3272"> </a>
<a name="ln3273">static int _death_is_worth_saving(const kill_method_type killed_by)</a>
<a name="ln3274">{</a>
<a name="ln3275">    switch (killed_by)</a>
<a name="ln3276">    {</a>
<a name="ln3277">    // These don't count.</a>
<a name="ln3278">    case KILLED_BY_LEAVING:</a>
<a name="ln3279">    case KILLED_BY_WINNING:</a>
<a name="ln3280">    case KILLED_BY_QUITTING:</a>
<a name="ln3281"> </a>
<a name="ln3282">    // These are too much hassle.</a>
<a name="ln3283">    case KILLED_BY_LAVA:</a>
<a name="ln3284">    case KILLED_BY_WATER:</a>
<a name="ln3285">    case KILLED_BY_DRAINING:</a>
<a name="ln3286">    case KILLED_BY_STARVATION:</a>
<a name="ln3287">    case KILLED_BY_ROTTING:</a>
<a name="ln3288"> </a>
<a name="ln3289">    // Don't protect the player from these.</a>
<a name="ln3290">    case KILLED_BY_SELF_AIMED:</a>
<a name="ln3291">    case KILLED_BY_TARGETING:</a>
<a name="ln3292">        return false;</a>
<a name="ln3293"> </a>
<a name="ln3294">    // Everything else is fair game.</a>
<a name="ln3295">    default:</a>
<a name="ln3296">        return true;</a>
<a name="ln3297">    }</a>
<a name="ln3298">}</a>
<a name="ln3299"> </a>
<a name="ln3300">static string _get_death_type_keyword(const kill_method_type killed_by)</a>
<a name="ln3301">{</a>
<a name="ln3302">    switch (killed_by)</a>
<a name="ln3303">    {</a>
<a name="ln3304">    case KILLED_BY_MONSTER:</a>
<a name="ln3305">    case KILLED_BY_BEAM:</a>
<a name="ln3306">    case KILLED_BY_BEOGH_SMITING:</a>
<a name="ln3307">    case KILLED_BY_TSO_SMITING:</a>
<a name="ln3308">    case KILLED_BY_DIVINE_WRATH:</a>
<a name="ln3309">        return &quot;actor&quot;;</a>
<a name="ln3310">    default:</a>
<a name="ln3311">        return &quot;general&quot;;</a>
<a name="ln3312">    }</a>
<a name="ln3313">}</a>
<a name="ln3314"> </a>
<a name="ln3315">/**</a>
<a name="ln3316"> * Have Xom maybe act to save your life. There is both a flat chance</a>
<a name="ln3317"> * and an additional chance based on tension that he will refuse to</a>
<a name="ln3318"> * save you.</a>
<a name="ln3319"> * @param death_type  The type of death that occurred.</a>
<a name="ln3320"> * @return            True if Xom saves your life, false otherwise.</a>
<a name="ln3321"> */</a>
<a name="ln3322">bool xom_saves_your_life(const kill_method_type death_type)</a>
<a name="ln3323">{</a>
<a name="ln3324">    if (!you_worship(GOD_XOM) || _xom_feels_nasty())</a>
<a name="ln3325">        return false;</a>
<a name="ln3326"> </a>
<a name="ln3327">    // If this happens, don't bother.</a>
<a name="ln3328">    if (you.hp_max &lt; 1 || you.experience_level &lt; 1)</a>
<a name="ln3329">        return false;</a>
<a name="ln3330"> </a>
<a name="ln3331">    // Generally a rare effect.</a>
<a name="ln3332">    if (!one_chance_in(20))</a>
<a name="ln3333">        return false;</a>
<a name="ln3334"> </a>
<a name="ln3335">    if (!_death_is_worth_saving(death_type))</a>
<a name="ln3336">        return false;</a>
<a name="ln3337"> </a>
<a name="ln3338">    // In addition, the chance depends on the current tension and Xom's mood.</a>
<a name="ln3339">    const int death_tension = get_tension(GOD_XOM);</a>
<a name="ln3340">    if (death_tension &lt; random2(5) || !xom_is_nice(death_tension))</a>
<a name="ln3341">        return false;</a>
<a name="ln3342"> </a>
<a name="ln3343">    // Fake death message.</a>
<a name="ln3344">    canned_msg(MSG_YOU_DIE);</a>
<a name="ln3345">    more();</a>
<a name="ln3346"> </a>
<a name="ln3347">    const string key = _get_death_type_keyword(death_type);</a>
<a name="ln3348">    // XOM_SPEECH(&quot;life saving actor&quot;) or XOM_SPEECH(&quot;life saving general&quot;)</a>
<a name="ln3349">    string speech = _get_xom_speech(&quot;life saving &quot; + key);</a>
<a name="ln3350">    god_speaks(GOD_XOM, speech.c_str());</a>
<a name="ln3351"> </a>
<a name="ln3352">    // Give back some hp.</a>
<a name="ln3353">    if (you.hp &lt; 1)</a>
<a name="ln3354">        set_hp(1 + random2(you.hp_max/4));</a>
<a name="ln3355"> </a>
<a name="ln3356">    god_speaks(GOD_XOM, &quot;Xom revives you!&quot;);</a>
<a name="ln3357"> </a>
<a name="ln3358">    // Ideally, this should contain the death cause but that is too much</a>
<a name="ln3359">    // trouble for now.</a>
<a name="ln3360">    take_note(Note(NOTE_XOM_REVIVAL));</a>
<a name="ln3361"> </a>
<a name="ln3362">    // Make sure Xom doesn't get bored within the next couple of turns.</a>
<a name="ln3363">    if (you.gift_timeout &lt; 10)</a>
<a name="ln3364">        you.gift_timeout = 10;</a>
<a name="ln3365"> </a>
<a name="ln3366">    return true;</a>
<a name="ln3367">}</a>
<a name="ln3368"> </a>
<a name="ln3369">// Xom might have something to say when you enter a new level.</a>
<a name="ln3370">void xom_new_level_noise_or_stealth()</a>
<a name="ln3371">{</a>
<a name="ln3372">    if (!you_worship(GOD_XOM) &amp;&amp; !player_under_penance(GOD_XOM))</a>
<a name="ln3373">        return;</a>
<a name="ln3374"> </a>
<a name="ln3375">    // But only occasionally.</a>
<a name="ln3376">    if (one_chance_in(30))</a>
<a name="ln3377">    {</a>
<a name="ln3378">        if (!player_under_penance(GOD_XOM) &amp;&amp; coinflip())</a>
<a name="ln3379">        {</a>
<a name="ln3380">            god_speaks(GOD_XOM, _get_xom_speech(&quot;stealth player&quot;).c_str());</a>
<a name="ln3381">            mpr(you.duration[DUR_STEALTH] ? &quot;You feel more catlike.&quot;</a>
<a name="ln3382">                                          : &quot;You feel stealthy.&quot;);</a>
<a name="ln3383">            you.increase_duration(DUR_STEALTH, 10 + random2(80));</a>
<a name="ln3384">            take_note(Note(NOTE_XOM_EFFECT, you.piety, -1,</a>
<a name="ln3385">                           &quot;stealth player&quot;), true);</a>
<a name="ln3386">        }</a>
<a name="ln3387">        else</a>
<a name="ln3388">            _xom_noise(-1);</a>
<a name="ln3389">    }</a>
<a name="ln3390">    return;</a>
<a name="ln3391">}</a>
<a name="ln3392"> </a>
<a name="ln3393">/**</a>
<a name="ln3394"> * The Xom teleportation train takes you on instant</a>
<a name="ln3395"> * teleportation to a few random areas, stopping randomly but</a>
<a name="ln3396"> * most likely in an area that is not dangerous to you.</a>
<a name="ln3397"> */</a>
<a name="ln3398">static void _xom_good_teleport(int /*sever*/)</a>
<a name="ln3399">{</a>
<a name="ln3400">    god_speaks(GOD_XOM, _get_xom_speech(&quot;teleportation journey&quot;).c_str());</a>
<a name="ln3401">    int count = 0;</a>
<a name="ln3402">    do</a>
<a name="ln3403">    {</a>
<a name="ln3404">        count++;</a>
<a name="ln3405">        you_teleport_now();</a>
<a name="ln3406">        more();</a>
<a name="ln3407">        if (one_chance_in(10) || count &gt;= 7 + random2(5))</a>
<a name="ln3408">            break;</a>
<a name="ln3409">    }</a>
<a name="ln3410">    while (x_chance_in_y(3, 4) || player_in_a_dangerous_place());</a>
<a name="ln3411">    maybe_update_stashes();</a>
<a name="ln3412"> </a>
<a name="ln3413">    // Take a note.</a>
<a name="ln3414">    const string note = make_stringf(&quot;%d-stop teleportation journey%s&quot;, count,</a>
<a name="ln3415">#ifdef NOTE_DEBUG_XOM</a>
<a name="ln3416">             player_in_a_dangerous_place() ? &quot; (dangerous)&quot; :</a>
<a name="ln3417">#endif</a>
<a name="ln3418">             &quot;&quot;);</a>
<a name="ln3419">    take_note(Note(NOTE_XOM_EFFECT, you.piety, -1, note), true);</a>
<a name="ln3420">}</a>
<a name="ln3421"> </a>
<a name="ln3422">/**</a>
<a name="ln3423"> * The Xom teleportation train takes you on instant</a>
<a name="ln3424"> * teleportation to a few random areas, stopping if either</a>
<a name="ln3425"> * an area is dangerous to you or randomly.</a>
<a name="ln3426"> */</a>
<a name="ln3427">static void _xom_bad_teleport(int /*sever*/)</a>
<a name="ln3428">{</a>
<a name="ln3429">    god_speaks(GOD_XOM,</a>
<a name="ln3430">               _get_xom_speech(&quot;teleportation journey&quot;).c_str());</a>
<a name="ln3431"> </a>
<a name="ln3432">    int count = 0;</a>
<a name="ln3433">    do</a>
<a name="ln3434">    {</a>
<a name="ln3435">        you_teleport_now();</a>
<a name="ln3436">        more();</a>
<a name="ln3437">        if (count++ &gt;= 7 + random2(5))</a>
<a name="ln3438">            break;</a>
<a name="ln3439">    }</a>
<a name="ln3440">    while (x_chance_in_y(3, 4) &amp;&amp; !player_in_a_dangerous_place());</a>
<a name="ln3441">    maybe_update_stashes();</a>
<a name="ln3442"> </a>
<a name="ln3443">    // Take a note.</a>
<a name="ln3444">    const string note = make_stringf(&quot;%d-stop teleportation journey%s&quot;, count,</a>
<a name="ln3445">#ifdef NOTE_DEBUG_XOM</a>
<a name="ln3446">             badness == 3 ? &quot; (dangerous)&quot; : &quot;&quot;);</a>
<a name="ln3447">#else</a>
<a name="ln3448">    &quot;&quot;);</a>
<a name="ln3449">#endif</a>
<a name="ln3450">    take_note(Note(NOTE_XOM_EFFECT, you.piety, -1, note), true);</a>
<a name="ln3451">}</a>
<a name="ln3452"> </a>
<a name="ln3453">/// Place a one-tile chaos cloud on the player, with minor spreading.</a>
<a name="ln3454">static void _xom_chaos_cloud(int /*sever*/)</a>
<a name="ln3455">{</a>
<a name="ln3456">    const int lifetime = 3 + random2(12) * 3;</a>
<a name="ln3457">    const int spread_rate = random_range(5,15);</a>
<a name="ln3458">    check_place_cloud(CLOUD_CHAOS, you.pos(), lifetime,</a>
<a name="ln3459">                      nullptr, spread_rate);</a>
<a name="ln3460">    take_note(Note(NOTE_XOM_EFFECT, you.piety, -1, &quot;chaos cloud&quot;),</a>
<a name="ln3461">              true);</a>
<a name="ln3462">    god_speaks(GOD_XOM, _get_xom_speech(&quot;cloud&quot;).c_str());</a>
<a name="ln3463">}</a>
<a name="ln3464"> </a>
<a name="ln3465">struct xom_effect_count</a>
<a name="ln3466">{</a>
<a name="ln3467">    string effect;</a>
<a name="ln3468">    int    count;</a>
<a name="ln3469"> </a>
<a name="ln3470">    xom_effect_count(string e, int c) : effect(e), count(c) {};</a>
<a name="ln3471">};</a>
<a name="ln3472"> </a>
<a name="ln3473">/// A type of action Xom can take.</a>
<a name="ln3474">struct xom_event</a>
<a name="ln3475">{</a>
<a name="ln3476">    /// Wizmode name for the event.</a>
<a name="ln3477">    const char* name;</a>
<a name="ln3478">    /// The event action.</a>
<a name="ln3479">    function&lt;void(int sever)&gt; action;</a>
<a name="ln3480">    /**</a>
<a name="ln3481">     * Rough estimate of how hard a Xom effect hits the player,</a>
<a name="ln3482">     * scaled between 10 (harmless) and 50 (disastrous). Reduces boredom.</a>
<a name="ln3483">     */</a>
<a name="ln3484">    int badness_10x;</a>
<a name="ln3485">};</a>
<a name="ln3486"> </a>
<a name="ln3487">static const map&lt;xom_event_type, xom_event&gt; xom_events = {</a>
<a name="ln3488">    { XOM_DID_NOTHING, { &quot;nothing&quot; }},</a>
<a name="ln3489">    { XOM_GOOD_POTION, { &quot;potion&quot;, _xom_do_potion }},</a>
<a name="ln3490">    { XOM_GOOD_MAGIC_MAPPING, { &quot;magic mapping&quot;, _xom_magic_mapping }},</a>
<a name="ln3491">    { XOM_GOOD_DETECT_CREATURES, { &quot;detect creatures&quot;, _xom_detect_creatures }},</a>
<a name="ln3492">    { XOM_GOOD_DETECT_ITEMS, { &quot;detect items&quot;, _xom_detect_items }},</a>
<a name="ln3493">    { XOM_GOOD_SPELL, { &quot;tension spell&quot;, _xom_random_spell }},</a>
<a name="ln3494">    { XOM_GOOD_CONFUSION, { &quot;confuse monsters&quot;, _xom_confuse_monsters }},</a>
<a name="ln3495">    { XOM_GOOD_SINGLE_ALLY, { &quot;single ally&quot;, _xom_send_one_ally }},</a>
<a name="ln3496">    { XOM_GOOD_ANIMATE_MON_WPN, { &quot;animate monster weapon&quot;,</a>
<a name="ln3497">                                  _xom_animate_monster_weapon }},</a>
<a name="ln3498">    { XOM_GOOD_RANDOM_ITEM, { &quot;random item gift&quot;, _xom_random_item }},</a>
<a name="ln3499">    { XOM_GOOD_ACQUIREMENT, { &quot;acquirement&quot;, _xom_acquirement }},</a>
<a name="ln3500">    { XOM_GOOD_ALLIES, { &quot;summon allies&quot;, _xom_send_allies }},</a>
<a name="ln3501">    { XOM_GOOD_POLYMORPH, { &quot;good polymorph&quot;, _xom_good_polymorph }},</a>
<a name="ln3502">    { XOM_GOOD_TELEPORT, { &quot;good teleportation&quot;, _xom_good_teleport }},</a>
<a name="ln3503">    { XOM_GOOD_MUTATION, { &quot;good mutations&quot;, _xom_give_good_mutations }},</a>
<a name="ln3504">    { XOM_GOOD_LIGHTNING, { &quot;lightning&quot;, _xom_throw_divine_lightning }},</a>
<a name="ln3505">    { XOM_GOOD_SCENERY, { &quot;change scenery&quot;, _xom_change_scenery }},</a>
<a name="ln3506">    { XOM_GOOD_SNAKES, { &quot;snakes to sticks&quot;, _xom_snakes_to_sticks }},</a>
<a name="ln3507">    { XOM_GOOD_DESTRUCTION, { &quot;mass fireball&quot;, _xom_real_destruction }},</a>
<a name="ln3508">    { XOM_GOOD_FAKE_DESTRUCTION, { &quot;fake fireball&quot;, _xom_fake_destruction }},</a>
<a name="ln3509">    { XOM_GOOD_ENCHANT_MONSTER, { &quot;good enchant monster&quot;,</a>
<a name="ln3510">                                  _xom_good_enchant_monster }},</a>
<a name="ln3511">    { XOM_GOOD_FOG, { &quot;fog&quot;, _xom_fog }},</a>
<a name="ln3512">    { XOM_GOOD_CLOUD_TRAIL, { &quot;cloud trail&quot;, _xom_cloud_trail }},</a>
<a name="ln3513">    { XOM_GOOD_CLEAVING, { &quot;cleaving&quot;, _xom_cleaving }},</a>
<a name="ln3514"> </a>
<a name="ln3515">    { XOM_BAD_MISCAST_PSEUDO, { &quot;pseudo-miscast&quot;, _xom_pseudo_miscast, 10}},</a>
<a name="ln3516">    { XOM_BAD_NOISE, { &quot;noise&quot;, _xom_noise, 10 }},</a>
<a name="ln3517">    { XOM_BAD_ENCHANT_MONSTER, { &quot;bad enchant monster&quot;,</a>
<a name="ln3518">                                 _xom_bad_enchant_monster, 10}},</a>
<a name="ln3519">    { XOM_BAD_BLINK_MONSTERS, { &quot;blink monsters&quot;, _xom_blink_monsters, 10}},</a>
<a name="ln3520">    { XOM_BAD_CONFUSION, { &quot;confuse player&quot;, _xom_player_confusion_effect, 13}},</a>
<a name="ln3521">    { XOM_BAD_SWAP_MONSTERS, { &quot;swap monsters&quot;, _xom_rearrange_pieces, 20 }},</a>
<a name="ln3522">    { XOM_BAD_CHAOS_UPGRADE, { &quot;chaos upgrade&quot;, _xom_chaos_upgrade, 20}},</a>
<a name="ln3523">    { XOM_BAD_TELEPORT, { &quot;bad teleportation&quot;, _xom_bad_teleport, -1}},</a>
<a name="ln3524">    { XOM_BAD_POLYMORPH, { &quot;bad polymorph&quot;, _xom_bad_polymorph, 30}},</a>
<a name="ln3525">    { XOM_BAD_MOVING_STAIRS, { &quot;moving stairs&quot;, _xom_moving_stairs, 20}},</a>
<a name="ln3526">    { XOM_BAD_CLIMB_STAIRS, { &quot;unclimbable stairs&quot;, _xom_unclimbable_stairs,</a>
<a name="ln3527">                              30}},</a>
<a name="ln3528">    { XOM_BAD_MUTATION, { &quot;bad mutations&quot;, _xom_give_bad_mutations, 30}},</a>
<a name="ln3529">    { XOM_BAD_SUMMON_HOSTILES, { &quot;summon hostiles&quot;, _xom_summon_hostiles, 35}},</a>
<a name="ln3530">    { XOM_BAD_STATLOSS, { &quot;statloss&quot;, _xom_statloss, 23}},</a>
<a name="ln3531">    { XOM_BAD_DRAINING, { &quot;draining&quot;, _xom_draining, 23}},</a>
<a name="ln3532">    { XOM_BAD_TORMENT, { &quot;torment&quot;, _xom_torment, 23}},</a>
<a name="ln3533">    { XOM_BAD_CHAOS_CLOUD, { &quot;chaos cloud&quot;, _xom_chaos_cloud, 20}},</a>
<a name="ln3534">    { XOM_BAD_BANISHMENT, { &quot;banishment&quot;, _xom_banishment, 50}},</a>
<a name="ln3535">    { XOM_BAD_PSEUDO_BANISHMENT, {&quot;psuedo-banishment&quot;, _xom_pseudo_banishment,</a>
<a name="ln3536">                                  10}},</a>
<a name="ln3537">};</a>
<a name="ln3538"> </a>
<a name="ln3539">static void _do_xom_event(xom_event_type event_type, int sever)</a>
<a name="ln3540">{</a>
<a name="ln3541">    const xom_event *event = map_find(xom_events, event_type);</a>
<a name="ln3542">    if (event &amp;&amp; event-&gt;action)</a>
<a name="ln3543">        event-&gt;action(sever);</a>
<a name="ln3544">}</a>
<a name="ln3545"> </a>
<a name="ln3546">static int _xom_event_badness(xom_event_type event_type)</a>
<a name="ln3547">{</a>
<a name="ln3548">    if (event_type == XOM_BAD_TELEPORT)</a>
<a name="ln3549">        return player_in_a_dangerous_place() ? 3 : 1;</a>
<a name="ln3550"> </a>
<a name="ln3551">    const xom_event *event = map_find(xom_events, event_type);</a>
<a name="ln3552">    if (event)</a>
<a name="ln3553">        return div_rand_round(event-&gt;badness_10x, 10);</a>
<a name="ln3554">    return 0;</a>
<a name="ln3555">}</a>
<a name="ln3556"> </a>
<a name="ln3557">string xom_effect_to_name(xom_event_type effect)</a>
<a name="ln3558">{</a>
<a name="ln3559">    const xom_event *event = map_find(xom_events, effect);</a>
<a name="ln3560">    return event ? event-&gt;name : &quot;bugginess&quot;;</a>
<a name="ln3561">}</a>
<a name="ln3562"> </a>
<a name="ln3563">/// Basic sanity checks on xom_events.</a>
<a name="ln3564">void validate_xom_events()</a>
<a name="ln3565">{</a>
<a name="ln3566">    string fails;</a>
<a name="ln3567">    set&lt;string&gt; action_names;</a>
<a name="ln3568"> </a>
<a name="ln3569">    for (int i = 0; i &lt; XOM_LAST_REAL_ACT; ++i)</a>
<a name="ln3570">    {</a>
<a name="ln3571">        const xom_event_type event_type = static_cast&lt;xom_event_type&gt;(i);</a>
<a name="ln3572">        const xom_event *event = map_find(xom_events, event_type);</a>
<a name="ln3573">        if (!event)</a>
<a name="ln3574">        {</a>
<a name="ln3575">            fails += make_stringf(&quot;Xom event %d has no associated data!\n&quot;, i);</a>
<a name="ln3576">            continue;</a>
<a name="ln3577">        }</a>
<a name="ln3578"> </a>
<a name="ln3579">        if (action_names.count(event-&gt;name))</a>
<a name="ln3580">            fails += make_stringf(&quot;Duplicate name '%s'!\n&quot;, event-&gt;name);</a>
<a name="ln3581">        action_names.insert(event-&gt;name);</a>
<a name="ln3582"> </a>
<a name="ln3583">        if (_action_is_bad(event_type))</a>
<a name="ln3584">        {</a>
<a name="ln3585">            if ((event-&gt;badness_10x &lt; 10 || event-&gt;badness_10x &gt; 50)</a>
<a name="ln3586">                &amp;&amp; event-&gt;badness_10x != -1) // implies it's special-cased</a>
<a name="ln3587">            {</a>
<a name="ln3588">                fails += make_stringf(&quot;'%s' badness %d outside 10-50 range.\n&quot;,</a>
<a name="ln3589">                                      event-&gt;name, event-&gt;badness_10x);</a>
<a name="ln3590">            }</a>
<a name="ln3591">        } else if (event-&gt;badness_10x)</a>
<a name="ln3592">        {</a>
<a name="ln3593">            fails += make_stringf(&quot;'%s' is not bad, but has badness!\n&quot;,</a>
<a name="ln3594">                                  event-&gt;name);</a>
<a name="ln3595">        }</a>
<a name="ln3596"> </a>
<a name="ln3597">        if (event_type != XOM_DID_NOTHING &amp;&amp; !event-&gt;action)</a>
<a name="ln3598">            fails += make_stringf(&quot;No action for '%s'!\n&quot;, event-&gt;name);</a>
<a name="ln3599">    }</a>
<a name="ln3600"> </a>
<a name="ln3601">    dump_test_fails(fails, &quot;xom-data&quot;);</a>
<a name="ln3602">}</a>
<a name="ln3603"> </a>
<a name="ln3604">#ifdef WIZARD</a>
<a name="ln3605">static bool _sort_xom_effects(const xom_effect_count &amp;a,</a>
<a name="ln3606">                              const xom_effect_count &amp;b)</a>
<a name="ln3607">{</a>
<a name="ln3608">    if (a.count == b.count)</a>
<a name="ln3609">        return a.effect &lt; b.effect;</a>
<a name="ln3610"> </a>
<a name="ln3611">    return a.count &gt; b.count;</a>
<a name="ln3612">}</a>
<a name="ln3613"> </a>
<a name="ln3614">static string _list_exploration_estimate()</a>
<a name="ln3615">{</a>
<a name="ln3616">    int explored = 0;</a>
<a name="ln3617">    int mapped   = 0;</a>
<a name="ln3618">    for (int k = 0; k &lt; 10; ++k)</a>
<a name="ln3619">    {</a>
<a name="ln3620">        mapped   += _exploration_estimate(false);</a>
<a name="ln3621">        explored += _exploration_estimate(true);</a>
<a name="ln3622">    }</a>
<a name="ln3623">    mapped /= 10;</a>
<a name="ln3624">    explored /= 10;</a>
<a name="ln3625"> </a>
<a name="ln3626">    return make_stringf(&quot;mapping estimate: %d%%\nexploration estimate: %d%%\n&quot;,</a>
<a name="ln3627">                        mapped, explored);</a>
<a name="ln3628">}</a>
<a name="ln3629"> </a>
<a name="ln3630">// Loops over the entire piety spectrum and calls xom_acts() multiple</a>
<a name="ln3631">// times for each value, then prints the results into a file.</a>
<a name="ln3632">// TODO: Allow specification of niceness, tension, and boredness.</a>
<a name="ln3633">void debug_xom_effects()</a>
<a name="ln3634">{</a>
<a name="ln3635">    // Repeat N times.</a>
<a name="ln3636">    const int N = prompt_for_int(&quot;How many iterations over the &quot;</a>
<a name="ln3637">                                 &quot;entire piety range? &quot;, true);</a>
<a name="ln3638"> </a>
<a name="ln3639">    if (N == 0)</a>
<a name="ln3640">    {</a>
<a name="ln3641">        canned_msg(MSG_OK);</a>
<a name="ln3642">        return;</a>
<a name="ln3643">    }</a>
<a name="ln3644"> </a>
<a name="ln3645">    FILE *ostat = fopen(&quot;xom_debug.stat&quot;, &quot;w&quot;);</a>
<a name="ln3646">    if (!ostat)</a>
<a name="ln3647">    {</a>
<a name="ln3648">        mprf(MSGCH_ERROR, &quot;Can't write 'xom_debug.stat'. Aborting.&quot;);</a>
<a name="ln3649">        return;</a>
<a name="ln3650">    }</a>
<a name="ln3651"> </a>
<a name="ln3652">    const int real_piety    = you.piety;</a>
<a name="ln3653">    const god_type real_god = you.religion;</a>
<a name="ln3654">    you.religion            = GOD_XOM;</a>
<a name="ln3655">    const int tension       = get_tension(GOD_XOM);</a>
<a name="ln3656"> </a>
<a name="ln3657">    fprintf(ostat, &quot;---- STARTING XOM DEBUG TESTING ----\n&quot;);</a>
<a name="ln3658">    fprintf(ostat, &quot;%s\n&quot;, dump_overview_screen(false).c_str());</a>
<a name="ln3659">    fprintf(ostat, &quot;%s\n&quot;, screenshot().c_str());</a>
<a name="ln3660">    fprintf(ostat, &quot;%s\n&quot;, _list_exploration_estimate().c_str());</a>
<a name="ln3661">    fprintf(ostat, &quot;%s\n&quot;, mpr_monster_list().c_str());</a>
<a name="ln3662">    fprintf(ostat, &quot; --&gt; Tension: %d\n&quot;, tension);</a>
<a name="ln3663"> </a>
<a name="ln3664">    if (player_under_penance(GOD_XOM))</a>
<a name="ln3665">        fprintf(ostat, &quot;You are under Xom's penance!\n&quot;);</a>
<a name="ln3666">    else if (_xom_is_bored())</a>
<a name="ln3667">        fprintf(ostat, &quot;Xom is BORED.\n&quot;);</a>
<a name="ln3668">    fprintf(ostat, &quot;\nRunning %d times through entire mood cycle.\n&quot;, N);</a>
<a name="ln3669">    fprintf(ostat, &quot;---- OUTPUT EFFECT PERCENTAGES ----\n&quot;);</a>
<a name="ln3670"> </a>
<a name="ln3671">    vector&lt;xom_event_type&gt;          mood_effects;</a>
<a name="ln3672">    vector&lt;vector&lt;xom_event_type&gt;&gt;  all_effects;</a>
<a name="ln3673">    vector&lt;string&gt;                  moods;</a>
<a name="ln3674">    vector&lt;int&gt;                     mood_good_acts;</a>
<a name="ln3675"> </a>
<a name="ln3676">    string old_mood = &quot;&quot;;</a>
<a name="ln3677">    string     mood = &quot;&quot;;</a>
<a name="ln3678"> </a>
<a name="ln3679">    // Add an empty list to later add all effects to.</a>
<a name="ln3680">    all_effects.push_back(mood_effects);</a>
<a name="ln3681">    moods.emplace_back(&quot;total&quot;);</a>
<a name="ln3682">    mood_good_acts.push_back(0); // count total good acts</a>
<a name="ln3683"> </a>
<a name="ln3684">    int mood_good = 0;</a>
<a name="ln3685">    for (int p = 0; p &lt;= MAX_PIETY; ++p)</a>
<a name="ln3686">    {</a>
<a name="ln3687">        you.piety     = p;</a>
<a name="ln3688">        int sever     = abs(p - HALF_MAX_PIETY);</a>
<a name="ln3689">        mood          = describe_xom_mood();</a>
<a name="ln3690">        if (old_mood != mood)</a>
<a name="ln3691">        {</a>
<a name="ln3692">            if (!old_mood.empty())</a>
<a name="ln3693">            {</a>
<a name="ln3694">                all_effects.push_back(mood_effects);</a>
<a name="ln3695">                mood_effects.clear();</a>
<a name="ln3696">                mood_good_acts.push_back(mood_good);</a>
<a name="ln3697">                mood_good_acts[0] += mood_good;</a>
<a name="ln3698">                mood_good = 0;</a>
<a name="ln3699">            }</a>
<a name="ln3700">            moods.push_back(mood);</a>
<a name="ln3701">            old_mood = mood;</a>
<a name="ln3702">        }</a>
<a name="ln3703"> </a>
<a name="ln3704">        // Repeat N times.</a>
<a name="ln3705">        for (int i = 0; i &lt; N; ++i)</a>
<a name="ln3706">        {</a>
<a name="ln3707">            const xom_event_type result = xom_acts(sever, MB_MAYBE, tension,</a>
<a name="ln3708">                                                   true);</a>
<a name="ln3709"> </a>
<a name="ln3710">            mood_effects.push_back(result);</a>
<a name="ln3711">            all_effects[0].push_back(result);</a>
<a name="ln3712"> </a>
<a name="ln3713">            if (result &lt;= XOM_LAST_GOOD_ACT)</a>
<a name="ln3714">                mood_good++;</a>
<a name="ln3715">        }</a>
<a name="ln3716">    }</a>
<a name="ln3717">    all_effects.push_back(mood_effects);</a>
<a name="ln3718">    mood_effects.clear();</a>
<a name="ln3719">    mood_good_acts.push_back(mood_good);</a>
<a name="ln3720">    mood_good_acts[0] += mood_good;</a>
<a name="ln3721"> </a>
<a name="ln3722">    const int num_moods = moods.size();</a>
<a name="ln3723">    vector&lt;xom_effect_count&gt; xom_ec_pairs;</a>
<a name="ln3724">    for (int i = 0; i &lt; num_moods; ++i)</a>
<a name="ln3725">    {</a>
<a name="ln3726">        mood_effects    = all_effects[i];</a>
<a name="ln3727">        const int total = mood_effects.size();</a>
<a name="ln3728"> </a>
<a name="ln3729">        if (i == 0)</a>
<a name="ln3730">            fprintf(ostat, &quot;\nTotal effects (all piety ranges)\n&quot;);</a>
<a name="ln3731">        else</a>
<a name="ln3732">            fprintf(ostat, &quot;\nMood: You are %s\n&quot;, moods[i].c_str());</a>
<a name="ln3733"> </a>
<a name="ln3734">        fprintf(ostat, &quot;GOOD%7.2f%%\n&quot;,</a>
<a name="ln3735">                (100.0 * (float) mood_good_acts[i] / (float) total));</a>
<a name="ln3736">        fprintf(ostat, &quot;BAD %7.2f%%\n&quot;,</a>
<a name="ln3737">                (100.0 * (float) (total - mood_good_acts[i]) / (float) total));</a>
<a name="ln3738"> </a>
<a name="ln3739">        sort(mood_effects.begin(), mood_effects.end());</a>
<a name="ln3740"> </a>
<a name="ln3741">        xom_ec_pairs.clear();</a>
<a name="ln3742">        xom_event_type old_effect = XOM_DID_NOTHING;</a>
<a name="ln3743">        int count      = 0;</a>
<a name="ln3744">        for (int k = 0; k &lt; total; ++k)</a>
<a name="ln3745">        {</a>
<a name="ln3746">            if (mood_effects[k] != old_effect)</a>
<a name="ln3747">            {</a>
<a name="ln3748">                if (count &gt; 0)</a>
<a name="ln3749">                {</a>
<a name="ln3750">                    xom_ec_pairs.emplace_back(xom_effect_to_name(old_effect),</a>
<a name="ln3751">                                              count);</a>
<a name="ln3752">                }</a>
<a name="ln3753">                old_effect = mood_effects[k];</a>
<a name="ln3754">                count = 1;</a>
<a name="ln3755">            }</a>
<a name="ln3756">            else</a>
<a name="ln3757">                count++;</a>
<a name="ln3758">        }</a>
<a name="ln3759"> </a>
<a name="ln3760">        if (count &gt; 0)</a>
<a name="ln3761">            xom_ec_pairs.emplace_back(xom_effect_to_name(old_effect), count);</a>
<a name="ln3762"> </a>
<a name="ln3763">        sort(xom_ec_pairs.begin(), xom_ec_pairs.end(), _sort_xom_effects);</a>
<a name="ln3764">        for (const xom_effect_count &amp;xec : xom_ec_pairs)</a>
<a name="ln3765">        {</a>
<a name="ln3766">            fprintf(ostat, &quot;%7.2f%%    %s\n&quot;,</a>
<a name="ln3767">                    (100.0 * xec.count / total),</a>
<a name="ln3768">                    xec.effect.c_str());</a>
<a name="ln3769">        }</a>
<a name="ln3770">    }</a>
<a name="ln3771">    fprintf(ostat, &quot;---- FINISHED XOM DEBUG TESTING ----\n&quot;);</a>
<a name="ln3772">    fclose(ostat);</a>
<a name="ln3773">    mpr(&quot;Results written into 'xom_debug.stat'.&quot;);</a>
<a name="ln3774"> </a>
<a name="ln3775">    you.piety    = real_piety;</a>
<a name="ln3776">    you.religion = real_god;</a>
<a name="ln3777">}</a>
<a name="ln3778">#endif // WIZARD</a>

</code></pre>
<div class="balloon" rel="384"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v560/" target="_blank">V560</a> A part of conditional expression is always true: chance > 0.</p></div>
<div class="balloon" rel="750"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v1016/" target="_blank">V1016</a> Expression 'iorig > GOD_NO_GOD' is always true.</p></div>
<div class="balloon" rel="1282"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v648/" target="_blank">V648</a> Priority of the '&&' operation is higher than that of the '||' operation.</p></div>
<div class="balloon" rel="1472"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v1048/" target="_blank">V1048</a> The 'beam.thrower' variable was assigned the same value.</p></div>
<div class="balloon" rel="1638"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v547/" target="_blank">V547</a> Expression 'effects.empty()' is always true.</p></div>
<div class="balloon" rel="1707"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v648/" target="_blank">V648</a> Priority of the '&&' operation is higher than that of the '||' operation.</p></div>
<div class="balloon" rel="1729"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v1048/" target="_blank">V1048</a> The 'beam.thrower' variable was assigned the same value.</p></div>
<div class="balloon" rel="2143"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v547/" target="_blank">V547</a> Expression 'rc' is always true.</p></div>
<div class="balloon" rel="2984"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v648/" target="_blank">V648</a> Priority of the '&&' operation is higher than that of the '||' operation.</p></div>

<link rel="stylesheet" href="highlight.css">
<script src="highlight.pack.js"></script>
<script src="highlightjs-line-numbers.js"></script>
<script>hljs.initHighlightingOnLoad();</script>
<script>hljs.initLineNumbersOnLoad();</script>
<script>
  $(document).ready(function() {
      $('.balloon').each(function () {
          var bl = $(this);
          var line = bl.attr('rel');
          var text = $('a[name="ln'+line+'"]').text();

          var space_count = 0;
          for(var i = 0; i<text.length; i++){
              var char = text[i];
              if((char !== ' ')&&(char !== '\t'))break;
              if(char === '\t')space_count++;
              space_count++;
          }

          bl.css('margin-left', space_count*8);
          $('a[name="ln'+line+'"]').after(bl);
      });

      window.location = window.location;
  });
</script>
</body>
</html>
