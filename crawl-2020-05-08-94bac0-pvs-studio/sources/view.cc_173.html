
<html>
<head>

  <meta http-equiv="Content-Type" content="text/html; charset=US-ASCII" />
  <title>view.cc</title>

  <link rel="stylesheet" href="../style.css"/>
  <script src="../jquery-3.2.1.min.js"></script>
</head>
<body>

<pre><code class = "cpp">
<a name="ln1">/**</a>
<a name="ln2"> * @file</a>
<a name="ln3"> * @brief Misc function used to render the dungeon.</a>
<a name="ln4">**/</a>
<a name="ln5"> </a>
<a name="ln6">#include &quot;AppHdr.h&quot;</a>
<a name="ln7"> </a>
<a name="ln8">#include &quot;view.h&quot;</a>
<a name="ln9"> </a>
<a name="ln10">#include &lt;algorithm&gt;</a>
<a name="ln11">#include &lt;cmath&gt;</a>
<a name="ln12">#include &lt;cstring&gt;</a>
<a name="ln13">#include &lt;memory&gt;</a>
<a name="ln14">#include &lt;sstream&gt;</a>
<a name="ln15"> </a>
<a name="ln16">#include &quot;act-iter.h&quot;</a>
<a name="ln17">#include &quot;artefact.h&quot;</a>
<a name="ln18">#include &quot;cio.h&quot;</a>
<a name="ln19">#include &quot;cloud.h&quot;</a>
<a name="ln20">#include &quot;clua.h&quot;</a>
<a name="ln21">#include &quot;colour.h&quot;</a>
<a name="ln22">#include &quot;coord.h&quot;</a>
<a name="ln23">#include &quot;coordit.h&quot;</a>
<a name="ln24">#include &quot;database.h&quot;</a>
<a name="ln25">#include &quot;delay.h&quot;</a>
<a name="ln26">#include &quot;dgn-overview.h&quot;</a>
<a name="ln27">#include &quot;directn.h&quot;</a>
<a name="ln28">#include &quot;english.h&quot;</a>
<a name="ln29">#include &quot;env.h&quot;</a>
<a name="ln30">#include &quot;exclude.h&quot;</a>
<a name="ln31">#include &quot;feature.h&quot;</a>
<a name="ln32">#include &quot;files.h&quot;</a>
<a name="ln33">#include &quot;fprop.h&quot;</a>
<a name="ln34">#include &quot;god-conduct.h&quot;</a>
<a name="ln35">#include &quot;god-passive.h&quot;</a>
<a name="ln36">#include &quot;god-wrath.h&quot;</a>
<a name="ln37">#include &quot;hints.h&quot;</a>
<a name="ln38">#include &quot;items.h&quot;</a>
<a name="ln39">#include &quot;item-name.h&quot; // item_type_known</a>
<a name="ln40">#include &quot;item-prop.h&quot; // get_weapon_brand</a>
<a name="ln41">#include &quot;libutil.h&quot;</a>
<a name="ln42">#include &quot;macro.h&quot;</a>
<a name="ln43">#include &quot;map-knowledge.h&quot;</a>
<a name="ln44">#include &quot;message.h&quot;</a>
<a name="ln45">#include &quot;misc.h&quot;</a>
<a name="ln46">#include &quot;mon-behv.h&quot;</a>
<a name="ln47">#include &quot;mon-death.h&quot;</a>
<a name="ln48">#include &quot;mon-poly.h&quot;</a>
<a name="ln49">#include &quot;mon-tentacle.h&quot;</a>
<a name="ln50">#include &quot;mon-util.h&quot;</a>
<a name="ln51">#include &quot;nearby-danger.h&quot;</a>
<a name="ln52">#include &quot;notes.h&quot;</a>
<a name="ln53">#include &quot;options.h&quot;</a>
<a name="ln54">#include &quot;output.h&quot;</a>
<a name="ln55">#include &quot;player.h&quot;</a>
<a name="ln56">#include &quot;random.h&quot;</a>
<a name="ln57">#include &quot;religion.h&quot;</a>
<a name="ln58">#include &quot;shout.h&quot;</a>
<a name="ln59">#include &quot;show.h&quot;</a>
<a name="ln60">#include &quot;showsymb.h&quot;</a>
<a name="ln61">#include &quot;state.h&quot;</a>
<a name="ln62">#include &quot;stringutil.h&quot;</a>
<a name="ln63">#include &quot;target.h&quot;</a>
<a name="ln64">#include &quot;terrain.h&quot;</a>
<a name="ln65">#include &quot;tilemcache.h&quot;</a>
<a name="ln66">#ifdef USE_TILE</a>
<a name="ln67"> #include &quot;tile-flags.h&quot;</a>
<a name="ln68"> #include &quot;tilepick.h&quot;</a>
<a name="ln69"> #include &quot;tilepick-p.h&quot;</a>
<a name="ln70"> #include &quot;tileview.h&quot;</a>
<a name="ln71">#endif</a>
<a name="ln72">#include &quot;tiles-build-specific.h&quot;</a>
<a name="ln73">#include &quot;traps.h&quot;</a>
<a name="ln74">#include &quot;travel.h&quot;</a>
<a name="ln75">#include &quot;unicode.h&quot;</a>
<a name="ln76">#include &quot;unwind.h&quot;</a>
<a name="ln77">#include &quot;viewchar.h&quot;</a>
<a name="ln78">#include &quot;viewmap.h&quot;</a>
<a name="ln79">#include &quot;xom.h&quot;</a>
<a name="ln80"> </a>
<a name="ln81">static layers_type _layers = LAYERS_ALL;</a>
<a name="ln82">static layers_type _layers_saved = LAYERS_NONE;</a>
<a name="ln83"> </a>
<a name="ln84">crawl_view_geometry crawl_view;</a>
<a name="ln85"> </a>
<a name="ln86">bool handle_seen_interrupt(monster* mons, vector&lt;string&gt;* msgs_buf)</a>
<a name="ln87">{</a>
<a name="ln88">    activity_interrupt_data aid(mons);</a>
<a name="ln89">    if (mons-&gt;seen_context)</a>
<a name="ln90">        aid.context = mons-&gt;seen_context;</a>
<a name="ln91">    // XXX: Hack to make the 'seen' monster spec flag work.</a>
<a name="ln92">    else if (testbits(mons-&gt;flags, MF_WAS_IN_VIEW)</a>
<a name="ln93">             || testbits(mons-&gt;flags, MF_SEEN))</a>
<a name="ln94">    {</a>
<a name="ln95">        aid.context = SC_ALREADY_SEEN;</a>
<a name="ln96">    }</a>
<a name="ln97">    else</a>
<a name="ln98">        aid.context = SC_NEWLY_SEEN;</a>
<a name="ln99"> </a>
<a name="ln100">    if (!mons_is_safe(mons))</a>
<a name="ln101">    {</a>
<a name="ln102">        return interrupt_activity(activity_interrupt::see_monster,</a>
<a name="ln103">                                  aid, msgs_buf);</a>
<a name="ln104">    }</a>
<a name="ln105"> </a>
<a name="ln106">    return false;</a>
<a name="ln107">}</a>
<a name="ln108"> </a>
<a name="ln109">void flush_comes_into_view()</a>
<a name="ln110">{</a>
<a name="ln111">    if (!you.turn_is_over</a>
<a name="ln112">        || (!you_are_delayed() &amp;&amp; !crawl_state.is_repeating_cmd()))</a>
<a name="ln113">    {</a>
<a name="ln114">        return;</a>
<a name="ln115">    }</a>
<a name="ln116"> </a>
<a name="ln117">    monster* mon = crawl_state.which_mon_acting();</a>
<a name="ln118"> </a>
<a name="ln119">    if (!mon || !mon-&gt;alive() || (mon-&gt;flags &amp; MF_WAS_IN_VIEW)</a>
<a name="ln120">        || !you.can_see(*mon))</a>
<a name="ln121">    {</a>
<a name="ln122">        return;</a>
<a name="ln123">    }</a>
<a name="ln124"> </a>
<a name="ln125">    handle_seen_interrupt(mon);</a>
<a name="ln126">}</a>
<a name="ln127"> </a>
<a name="ln128">void seen_monsters_react(int stealth)</a>
<a name="ln129">{</a>
<a name="ln130">    if (you.duration[DUR_TIME_STEP] || crawl_state.game_is_arena())</a>
<a name="ln131">        return;</a>
<a name="ln132"> </a>
<a name="ln133">    for (monster_near_iterator mi(you.pos()); mi; ++mi)</a>
<a name="ln134">    {</a>
<a name="ln135">        if ((mi-&gt;asleep() || mons_is_wandering(**mi))</a>
<a name="ln136">            &amp;&amp; check_awaken(*mi, stealth))</a>
<a name="ln137">        {</a>
<a name="ln138">            behaviour_event(*mi, ME_ALERT, &amp;you, you.pos(), false);</a>
<a name="ln139"> </a>
<a name="ln140">            // That might have caused a pacified monster to leave the level.</a>
<a name="ln141">            if (!(*mi)-&gt;alive())</a>
<a name="ln142">                continue;</a>
<a name="ln143"> </a>
<a name="ln144">            monster_consider_shouting(**mi);</a>
<a name="ln145">        }</a>
<a name="ln146"> </a>
<a name="ln147">        if (!mi-&gt;visible_to(&amp;you))</a>
<a name="ln148">            continue;</a>
<a name="ln149"> </a>
<a name="ln150">        if (!mi-&gt;has_ench(ENCH_INSANE) &amp;&amp; mi-&gt;can_see(you))</a>
<a name="ln151">        {</a>
<a name="ln152">            // Trigger Duvessa &amp; Dowan upgrades</a>
<a name="ln153">            if (mi-&gt;props.exists(ELVEN_ENERGIZE_KEY))</a>
<a name="ln154">            {</a>
<a name="ln155">                mi-&gt;props.erase(ELVEN_ENERGIZE_KEY);</a>
<a name="ln156">                elven_twin_energize(*mi);</a>
<a name="ln157">            }</a>
<a name="ln158">#if TAG_MAJOR_VERSION == 34</a>
<a name="ln159">            else if (mi-&gt;props.exists(OLD_DUVESSA_ENERGIZE_KEY))</a>
<a name="ln160">            {</a>
<a name="ln161">                mi-&gt;props.erase(OLD_DUVESSA_ENERGIZE_KEY);</a>
<a name="ln162">                elven_twin_energize(*mi);</a>
<a name="ln163">            }</a>
<a name="ln164">            else if (mi-&gt;props.exists(OLD_DOWAN_ENERGIZE_KEY))</a>
<a name="ln165">            {</a>
<a name="ln166">                mi-&gt;props.erase(OLD_DOWAN_ENERGIZE_KEY);</a>
<a name="ln167">                elven_twin_energize(*mi);</a>
<a name="ln168">            }</a>
<a name="ln169">#endif</a>
<a name="ln170">        }</a>
<a name="ln171">    }</a>
<a name="ln172">}</a>
<a name="ln173"> </a>
<a name="ln174">static string _desc_mons_type_map(map&lt;monster_type, int&gt; types)</a>
<a name="ln175">{</a>
<a name="ln176">    string message;</a>
<a name="ln177">    unsigned int count = 1;</a>
<a name="ln178">    for (const auto &amp;entry : types)</a>
<a name="ln179">    {</a>
<a name="ln180">        string name;</a>
<a name="ln181">        description_level_type desc;</a>
<a name="ln182">        if (entry.second == 1)</a>
<a name="ln183">            desc = DESC_A;</a>
<a name="ln184">        else</a>
<a name="ln185">            desc = DESC_PLAIN;</a>
<a name="ln186"> </a>
<a name="ln187">        name = mons_type_name(entry.first, desc);</a>
<a name="ln188">        if (entry.second &gt; 1)</a>
<a name="ln189">        {</a>
<a name="ln190">            name = make_stringf(&quot;%d %s&quot;, entry.second,</a>
<a name="ln191">                                pluralise_monster(name).c_str());</a>
<a name="ln192">        }</a>
<a name="ln193"> </a>
<a name="ln194">        message += name;</a>
<a name="ln195">        if (count == types.size() - 1)</a>
<a name="ln196">            message += &quot; and &quot;;</a>
<a name="ln197">        else if (count &lt; types.size())</a>
<a name="ln198">            message += &quot;, &quot;;</a>
<a name="ln199">        ++count;</a>
<a name="ln200">    }</a>
<a name="ln201">    return message;</a>
<a name="ln202">}</a>
<a name="ln203"> </a>
<a name="ln204">static monster_type _mons_genus_keep_uniques(monster_type mc)</a>
<a name="ln205">{</a>
<a name="ln206">    return mons_is_unique(mc) ? mc : mons_genus(mc);</a>
<a name="ln207">}</a>
<a name="ln208"> </a>
<a name="ln209">/**</a>
<a name="ln210"> * Monster list simplification</a>
<a name="ln211"> *</a>
<a name="ln212"> * When too many monsters come into view at once, we group the ones with the</a>
<a name="ln213"> * same genus, starting with the most represented genus.</a>
<a name="ln214"> *</a>
<a name="ln215"> * @param types monster types and the number of monster for each type.</a>
<a name="ln216"> * @param genera monster genera and the number of monster for each genus.</a>
<a name="ln217"> */</a>
<a name="ln218">static void _genus_factoring(map&lt;monster_type, int&gt; &amp;types,</a>
<a name="ln219">                             map&lt;monster_type, int&gt; &amp;genera)</a>
<a name="ln220">{</a>
<a name="ln221">    monster_type genus = MONS_NO_MONSTER;</a>
<a name="ln222">    int num = 0;</a>
<a name="ln223">    // Find the most represented genus.</a>
<a name="ln224">    for (const auto &amp;entry : genera)</a>
<a name="ln225">        if (entry.second &gt; num)</a>
<a name="ln226">        {</a>
<a name="ln227">            genus = entry.first;</a>
<a name="ln228">            num = entry.second;</a>
<a name="ln229">        }</a>
<a name="ln230"> </a>
<a name="ln231">    // The most represented genus has a single member.</a>
<a name="ln232">    // No more factoring is possible, we're done.</a>
<a name="ln233">    if (num == 1)</a>
<a name="ln234">    {</a>
<a name="ln235">        genera.clear();</a>
<a name="ln236">        return;</a>
<a name="ln237">    }</a>
<a name="ln238"> </a>
<a name="ln239">    genera.erase(genus);</a>
<a name="ln240">    auto it = types.begin();</a>
<a name="ln241">    do</a>
<a name="ln242">    {</a>
<a name="ln243">        if (_mons_genus_keep_uniques(it-&gt;first) != genus)</a>
<a name="ln244">        {</a>
<a name="ln245">            ++it;</a>
<a name="ln246">            continue;</a>
<a name="ln247">        }</a>
<a name="ln248"> </a>
<a name="ln249">        // This genus has a single monster type. Can't factor.</a>
<a name="ln250">        if (it-&gt;second == num)</a>
<a name="ln251">            return;</a>
<a name="ln252"> </a>
<a name="ln253">        types.erase(it++);</a>
<a name="ln254"> </a>
<a name="ln255">    } while (it != types.end());</a>
<a name="ln256"> </a>
<a name="ln257">    types[genus] = num;</a>
<a name="ln258">}</a>
<a name="ln259"> </a>
<a name="ln260">static bool _is_weapon_worth_listing(const unique_ptr&lt;item_def&gt; &amp;wpn)</a>
<a name="ln261">{</a>
<a name="ln262">    return wpn &amp;&amp; (wpn-&gt;base_type == OBJ_STAVES</a>
<a name="ln263">                   || is_unrandom_artefact(*wpn.get())</a>
<a name="ln264">                   || get_weapon_brand(*wpn.get()) != SPWPN_NORMAL);</a>
<a name="ln265">}</a>
<a name="ln266"> </a>
<a name="ln267">static bool _is_item_worth_listing(const unique_ptr&lt;item_def&gt; &amp;item)</a>
<a name="ln268">{</a>
<a name="ln269">    return item &amp;&amp; (item_is_branded(*item.get())</a>
<a name="ln270">                    || is_artefact(*item.get()));</a>
<a name="ln271">}</a>
<a name="ln272"> </a>
<a name="ln273">static bool _is_mon_equipment_worth_listing(const monster_info &amp;mi)</a>
<a name="ln274">{</a>
<a name="ln275"> </a>
<a name="ln276">    if (_is_weapon_worth_listing(mi.inv[MSLOT_WEAPON]))</a>
<a name="ln277">        return true;</a>
<a name="ln278">    const unique_ptr&lt;item_def&gt; &amp;alt_weap = mi.inv[MSLOT_ALT_WEAPON];</a>
<a name="ln279">    if (mi.wields_two_weapons() &amp;&amp; _is_weapon_worth_listing(alt_weap))</a>
<a name="ln280">        return true;</a>
<a name="ln281">    // can a wand be in the alt weapon slot? get_monster_equipment_desc seems to</a>
<a name="ln282">    // think so, so we'll check</a>
<a name="ln283">    if (alt_weap &amp;&amp; alt_weap-&gt;base_type == OBJ_WANDS)</a>
<a name="ln284">        return true;</a>
<a name="ln285">    if (mi.inv[MSLOT_WAND])</a>
<a name="ln286">        return true;</a>
<a name="ln287"> </a>
<a name="ln288">    return _is_item_worth_listing(mi.inv[MSLOT_SHIELD])</a>
<a name="ln289">        || _is_item_worth_listing(mi.inv[MSLOT_ARMOUR])</a>
<a name="ln290">        || _is_item_worth_listing(mi.inv[MSLOT_JEWELLERY])</a>
<a name="ln291">        || _is_item_worth_listing(mi.inv[MSLOT_MISSILE]);</a>
<a name="ln292">}</a>
<a name="ln293"> </a>
<a name="ln294">/// Return a warning for the player about newly-seen monsters, as appropriate.</a>
<a name="ln295">static string _monster_headsup(const vector&lt;monster*&gt; &amp;monsters,</a>
<a name="ln296">                               const map&lt;monster_type, int&gt; &amp;types,</a>
<a name="ln297">                               bool divine)</a>
<a name="ln298">{</a>
<a name="ln299">    string warning_msg = &quot;&quot;;</a>
<a name="ln300">    for (const monster* mon : monsters)</a>
<a name="ln301">    {</a>
<a name="ln302">        monster_info mi(mon);</a>
<a name="ln303">        const bool zin_ided = mon-&gt;props.exists(&quot;zin_id&quot;);</a>
<a name="ln304">        const bool has_interesting_equipment</a>
<a name="ln305">            = _is_mon_equipment_worth_listing(mi);</a>
<a name="ln306">        if ((divine &amp;&amp; !zin_ided)</a>
<a name="ln307">            || (!divine &amp;&amp; !has_interesting_equipment))</a>
<a name="ln308">        {</a>
<a name="ln309">            continue;</a>
<a name="ln310">        }</a>
<a name="ln311"> </a>
<a name="ln312">        if (!divine &amp;&amp; monsters.size() == 1)</a>
<a name="ln313">            continue; // don't give redundant warnings for enemies</a>
<a name="ln314"> </a>
<a name="ln315">        if (warning_msg.size())</a>
<a name="ln316">            warning_msg += &quot; &quot;;</a>
<a name="ln317"> </a>
<a name="ln318">        string monname;</a>
<a name="ln319">        if (monsters.size() == 1)</a>
<a name="ln320">            monname = mon-&gt;pronoun(PRONOUN_SUBJECTIVE);</a>
<a name="ln321">        else if (mon-&gt;type == MONS_DANCING_WEAPON)</a>
<a name="ln322">            monname = &quot;There&quot;;</a>
<a name="ln323">        else if (types.at(mon-&gt;type) == 1)</a>
<a name="ln324">            monname = mon-&gt;full_name(DESC_THE);</a>
<a name="ln325">        else</a>
<a name="ln326">            monname = mon-&gt;full_name(DESC_A);</a>
<a name="ln327">        warning_msg += uppercase_first(monname);</a>
<a name="ln328"> </a>
<a name="ln329">        warning_msg += &quot; &quot;;</a>
<a name="ln330">        if (monsters.size() == 1)</a>
<a name="ln331">            warning_msg += conjugate_verb(&quot;are&quot;, mon-&gt;pronoun_plurality());</a>
<a name="ln332">        else</a>
<a name="ln333">            warning_msg += &quot;is&quot;;</a>
<a name="ln334"> </a>
<a name="ln335">        mons_equip_desc_level_type level = mon-&gt;type != MONS_DANCING_WEAPON</a>
<a name="ln336">            ? DESC_IDENTIFIED : DESC_WEAPON_WARNING;</a>
<a name="ln337"> </a>
<a name="ln338">        if (!divine)</a>
<a name="ln339">        {</a>
<a name="ln340">            if (mon-&gt;type != MONS_DANCING_WEAPON)</a>
<a name="ln341">                warning_msg += &quot; &quot;;</a>
<a name="ln342">            warning_msg += get_monster_equipment_desc(mi, level, DESC_NONE);</a>
<a name="ln343">            warning_msg += &quot;.&quot;;</a>
<a name="ln344">            continue;</a>
<a name="ln345">        }</a>
<a name="ln346"> </a>
<a name="ln347">        if (you_worship(GOD_ZIN))</a>
<a name="ln348">        {</a>
<a name="ln349">            warning_msg += &quot; a foul &quot;;</a>
<a name="ln350">            if (mon-&gt;has_ench(ENCH_GLOWING_SHAPESHIFTER))</a>
<a name="ln351">                warning_msg += &quot;glowing &quot;;</a>
<a name="ln352">            warning_msg += &quot;shapeshifter&quot;;</a>
<a name="ln353">        }</a>
<a name="ln354">        else</a>
<a name="ln355">        {</a>
<a name="ln356">            // TODO: deduplicate</a>
<a name="ln357">            if (mon-&gt;type != MONS_DANCING_WEAPON)</a>
<a name="ln358">                warning_msg += &quot; &quot;;</a>
<a name="ln359">            warning_msg += get_monster_equipment_desc(mi, level, DESC_NONE);</a>
<a name="ln360">        }</a>
<a name="ln361">        warning_msg += &quot;.&quot;;</a>
<a name="ln362">    }</a>
<a name="ln363"> </a>
<a name="ln364">    return warning_msg;</a>
<a name="ln365">}</a>
<a name="ln366"> </a>
<a name="ln367">/// Let Ash/Zin warn the player about newly-seen monsters, as appropriate.</a>
<a name="ln368">static void _divine_headsup(const vector&lt;monster*&gt; &amp;monsters,</a>
<a name="ln369">                            const map&lt;monster_type, int&gt; &amp;types)</a>
<a name="ln370">{</a>
<a name="ln371">    const string warnings = _monster_headsup(monsters, types, true);</a>
<a name="ln372">    if (!warnings.size())</a>
<a name="ln373">        return;</a>
<a name="ln374"> </a>
<a name="ln375">    const string warning_msg = &quot; warns you: &quot; + warnings;</a>
<a name="ln376">    simple_god_message(warning_msg.c_str());</a>
<a name="ln377">#ifndef USE_TILE_LOCAL</a>
<a name="ln378">    // XXX: should this really be here...?</a>
<a name="ln379">    if (you_worship(GOD_ZIN))</a>
<a name="ln380">        update_monster_pane();</a>
<a name="ln381">#endif</a>
<a name="ln382">}</a>
<a name="ln383"> </a>
<a name="ln384">static void _secular_headsup(const vector&lt;monster*&gt; &amp;monsters,</a>
<a name="ln385">                             const map&lt;monster_type, int&gt; &amp;types)</a>
<a name="ln386">{</a>
<a name="ln387">    const string warnings = _monster_headsup(monsters, types, false);</a>
<a name="ln388">    if (!warnings.size())</a>
<a name="ln389">        return;</a>
<a name="ln390">    mprf(MSGCH_MONSTER_WARNING, &quot;%s&quot;, warnings.c_str());</a>
<a name="ln391">}</a>
<a name="ln392"> </a>
<a name="ln393">static map&lt;monster_type, int&gt; _count_monster_types(const vector&lt;monster*&gt;&amp; monsters,</a>
<a name="ln394">                                                   const unsigned int max_types = UINT_MAX)</a>
<a name="ln395">{</a>
<a name="ln396">    map&lt;monster_type, int&gt; types;</a>
<a name="ln397">    map&lt;monster_type, int&gt; genera; // This is the plural for genus!</a>
<a name="ln398">    for (const monster *mon : monsters)</a>
<a name="ln399">    {</a>
<a name="ln400">        const monster_type type = mon-&gt;type;</a>
<a name="ln401">        types[type]++;</a>
<a name="ln402">        genera[_mons_genus_keep_uniques(type)]++;</a>
<a name="ln403">    }</a>
<a name="ln404"> </a>
<a name="ln405">    while (types.size() &gt; max_types &amp;&amp; !genera.empty())</a>
<a name="ln406">        _genus_factoring(types, genera);</a>
<a name="ln407"> </a>
<a name="ln408">    return types;</a>
<a name="ln409">}</a>
<a name="ln410"> </a>
<a name="ln411">/**</a>
<a name="ln412"> * Return a string listing monsters in a human readable form.</a>
<a name="ln413"> * E.g. &quot;a hydra and 2 liches&quot;.</a>
<a name="ln414"> *</a>
<a name="ln415"> * @param monsters      A list of monsters that just became visible.</a>
<a name="ln416"> */</a>
<a name="ln417">string describe_monsters_condensed(const vector&lt;monster*&gt;&amp; monsters)</a>
<a name="ln418">{</a>
<a name="ln419">    return _desc_mons_type_map(_count_monster_types(monsters, 4));</a>
<a name="ln420">}</a>
<a name="ln421"> </a>
<a name="ln422">/**</a>
<a name="ln423"> * Handle printing &quot;foo comes into view&quot; messages for newly appeared monsters.</a>
<a name="ln424"> * Also let Ash/Zin warn the player about newly-seen monsters, as appropriate.</a>
<a name="ln425"> *</a>
<a name="ln426"> * @param msgs          A list of individual 'comes into view' messages; e.g.</a>
<a name="ln427"> *                      &quot;the goblin comes into view.&quot;, &quot;Mara opens the gate.&quot;</a>
<a name="ln428"> * @param monsters      A list of monsters that just became visible.</a>
<a name="ln429"> */</a>
<a name="ln430">static void _handle_comes_into_view(const vector&lt;string&gt; &amp;msgs,</a>
<a name="ln431">                                    const vector&lt;monster*&gt; monsters)</a>
<a name="ln432">{</a>
<a name="ln433">    if (monsters.size() == 1)</a>
<a name="ln434">        mprf(MSGCH_MONSTER_WARNING, &quot;%s&quot;, msgs[0].c_str());</a>
<a name="ln435">    else</a>
<a name="ln436">        mprf(MSGCH_MONSTER_WARNING, &quot;%s come into view.&quot;,</a>
<a name="ln437">             describe_monsters_condensed(monsters).c_str());</a>
<a name="ln438"> </a>
<a name="ln439">    const auto&amp; types = _count_monster_types(monsters);</a>
<a name="ln440">    _divine_headsup(monsters, types);</a>
<a name="ln441">    _secular_headsup(monsters, types);</a>
<a name="ln442">}</a>
<a name="ln443"> </a>
<a name="ln444">/// If the player has the shout mutation, maybe shout at newly-seen monsters.</a>
<a name="ln445">static void _maybe_trigger_shoutitis(const vector&lt;monster*&gt; monsters)</a>
<a name="ln446">{</a>
<a name="ln447">    if (!you.get_mutation_level(MUT_SCREAM))</a>
<a name="ln448">        return;</a>
<a name="ln449"> </a>
<a name="ln450">    for (const monster* mon : monsters)</a>
<a name="ln451">    {</a>
<a name="ln452">        if (!mons_is_tentacle_or_tentacle_segment(mon-&gt;type)</a>
<a name="ln453">            &amp;&amp; !mons_is_conjured(mon-&gt;type)</a>
<a name="ln454">            &amp;&amp; x_chance_in_y(3 + you.get_mutation_level(MUT_SCREAM) * 3, 100))</a>
<a name="ln455">        {</a>
<a name="ln456">            yell(mon);</a>
<a name="ln457">            return;</a>
<a name="ln458">        }</a>
<a name="ln459">    }</a>
<a name="ln460">}</a>
<a name="ln461"> </a>
<a name="ln462">/// Let Gozag's wrath buff newly-seen hostile monsters, maybe.</a>
<a name="ln463">static void _maybe_gozag_incite(vector&lt;monster*&gt; monsters)</a>
<a name="ln464">{</a>
<a name="ln465">    if (!player_under_penance(GOD_GOZAG))</a>
<a name="ln466">        return;</a>
<a name="ln467"> </a>
<a name="ln468">    counted_monster_list mon_count;</a>
<a name="ln469">    vector&lt;monster *&gt; incited;</a>
<a name="ln470">    for (monster* mon : monsters)</a>
<a name="ln471">    {</a>
<a name="ln472">        // XXX: some of this is probably redundant with interrupt_activity</a>
<a name="ln473">        if (!mon-&gt;see_cell(you.pos()) // xray_vision</a>
<a name="ln474">            || mon-&gt;wont_attack()</a>
<a name="ln475">            || mon-&gt;is_stationary()</a>
<a name="ln476">            || mons_is_object(mon-&gt;type)</a>
<a name="ln477">            || mons_is_tentacle_or_tentacle_segment(mon-&gt;type))</a>
<a name="ln478">        {</a>
<a name="ln479">            continue;</a>
<a name="ln480">        }</a>
<a name="ln481"> </a>
<a name="ln482">        if (coinflip()</a>
<a name="ln483">            &amp;&amp; mon-&gt;get_experience_level() &gt;= random2(you.experience_level))</a>
<a name="ln484">        {</a>
<a name="ln485">            mon_count.add(mon);</a>
<a name="ln486">            incited.push_back(mon);</a>
<a name="ln487">        }</a>
<a name="ln488">    }</a>
<a name="ln489"> </a>
<a name="ln490">    if (incited.empty())</a>
<a name="ln491">        return;</a>
<a name="ln492"> </a>
<a name="ln493">    string msg = make_stringf(&quot;%s incites %s against you.&quot;,</a>
<a name="ln494">                              god_name(GOD_GOZAG).c_str(),</a>
<a name="ln495">                              mon_count.describe().c_str());</a>
<a name="ln496">    if (strwidth(msg) &gt;= get_number_of_cols() - 2)</a>
<a name="ln497">    {</a>
<a name="ln498">        msg = make_stringf(&quot;%s incites your enemies against you.&quot;,</a>
<a name="ln499">                           god_name(GOD_GOZAG).c_str());</a>
<a name="ln500">    }</a>
<a name="ln501">    mprf(MSGCH_GOD, GOD_GOZAG, &quot;%s&quot;, msg.c_str());</a>
<a name="ln502"> </a>
<a name="ln503">    for (monster *mon : incited)</a>
<a name="ln504">        gozag_incite(mon);</a>
<a name="ln505">}</a>
<a name="ln506"> </a>
<a name="ln507">void update_monsters_in_view()</a>
<a name="ln508">{</a>
<a name="ln509">    int num_hostile = 0;</a>
<a name="ln510">    vector&lt;string&gt; msgs;</a>
<a name="ln511">    vector&lt;monster*&gt; monsters;</a>
<a name="ln512"> </a>
<a name="ln513">    for (monster_iterator mi; mi; ++mi)</a>
<a name="ln514">    {</a>
<a name="ln515">        if (you.see_cell(mi-&gt;pos()))</a>
<a name="ln516">        {</a>
<a name="ln517">            if (mi-&gt;attitude == ATT_HOSTILE)</a>
<a name="ln518">                num_hostile++;</a>
<a name="ln519"> </a>
<a name="ln520">            if (mi-&gt;visible_to(&amp;you))</a>
<a name="ln521">            {</a>
<a name="ln522">                if (handle_seen_interrupt(*mi, &amp;msgs))</a>
<a name="ln523">                    monsters.push_back(*mi);</a>
<a name="ln524">                seen_monster(*mi);</a>
<a name="ln525">            }</a>
<a name="ln526">            else</a>
<a name="ln527">                mi-&gt;flags &amp;= ~MF_WAS_IN_VIEW;</a>
<a name="ln528">        }</a>
<a name="ln529">        else if (!you.turn_is_over)</a>
<a name="ln530">        {</a>
<a name="ln531">            if (mi-&gt;flags &amp; MF_WAS_IN_VIEW)</a>
<a name="ln532">            {</a>
<a name="ln533">                // Reset client id so the player doesn't know (for sure) he</a>
<a name="ln534">                // has seen this monster before when it reappears.</a>
<a name="ln535">                mi-&gt;reset_client_id();</a>
<a name="ln536">            }</a>
<a name="ln537"> </a>
<a name="ln538">            mi-&gt;flags &amp;= ~MF_WAS_IN_VIEW;</a>
<a name="ln539"> </a>
<a name="ln540">            // If the monster hasn't been seen by the time that the player</a>
<a name="ln541">            // gets control back then seen_context is out of date.</a>
<a name="ln542">            mi-&gt;seen_context = SC_NONE;</a>
<a name="ln543">        }</a>
<a name="ln544">    }</a>
<a name="ln545"> </a>
<a name="ln546">    // Summoners may have lost their summons upon seeing us and converting</a>
<a name="ln547">    // leaving invalid monsters in this vector.</a>
<a name="ln548">    monsters.erase(</a>
<a name="ln549">        std::remove_if(monsters.begin(), monsters.end(),</a>
<a name="ln550">            [](const monster * m) { return !m-&gt;alive(); }),</a>
<a name="ln551">        monsters.end());</a>
<a name="ln552"> </a>
<a name="ln553">    if (!msgs.empty())</a>
<a name="ln554">    {</a>
<a name="ln555">        _handle_comes_into_view(msgs, monsters);</a>
<a name="ln556">        // XXX: does interrupt_activity() add 'comes into view' messages to</a>
<a name="ln557">        // 'msgs' in ALL cases we want shoutitis/gozag wrath to trigger?</a>
<a name="ln558">        _maybe_trigger_shoutitis(monsters);</a>
<a name="ln559">        _maybe_gozag_incite(monsters);</a>
<a name="ln560">    }</a>
<a name="ln561"> </a>
<a name="ln562">    // Xom thinks it's hilarious the way the player picks up an ever</a>
<a name="ln563">    // growing entourage of monsters while running through the Abyss.</a>
<a name="ln564">    // To approximate this, if the number of hostile monsters in view</a>
<a name="ln565">    // is greater than it ever was for this particular trip to the</a>
<a name="ln566">    // Abyss, Xom is stimulated in proportion to the number of</a>
<a name="ln567">    // hostile monsters. Thus if the entourage doesn't grow, then</a>
<a name="ln568">    // Xom becomes bored.</a>
<a name="ln569">    if (player_in_branch(BRANCH_ABYSS)</a>
<a name="ln570">        &amp;&amp; you.attribute[ATTR_ABYSS_ENTOURAGE] &lt; num_hostile)</a>
<a name="ln571">    {</a>
<a name="ln572">        you.attribute[ATTR_ABYSS_ENTOURAGE] = num_hostile;</a>
<a name="ln573">        xom_is_stimulated(12 * num_hostile);</a>
<a name="ln574">    }</a>
<a name="ln575">}</a>
<a name="ln576"> </a>
<a name="ln577"> </a>
<a name="ln578">// We logically associate a difficulty parameter with each tile on each level,</a>
<a name="ln579">// to make deterministic passive mapping work. It is deterministic so that the</a>
<a name="ln580">// reveal order doesn't, for example, change on reload.</a>
<a name="ln581">//</a>
<a name="ln582">// This function returns the difficulty parameters for each tile on the current</a>
<a name="ln583">// level, whose difficulty is less than a certain amount.</a>
<a name="ln584">//</a>
<a name="ln585">// Random difficulties are used in the few cases where we want repeated maps</a>
<a name="ln586">// to give different results; scrolls and cards, since they are a finite</a>
<a name="ln587">// resource.</a>
<a name="ln588">static const FixedArray&lt;uint8_t, GXM, GYM&gt;&amp; _tile_difficulties(bool random)</a>
<a name="ln589">{</a>
<a name="ln590">    // We will often be called with the same level parameter and cutoff, so</a>
<a name="ln591">    // cache this (DS with passive mapping autoexploring could be 5000 calls</a>
<a name="ln592">    // in a second or so).</a>
<a name="ln593">    static FixedArray&lt;uint8_t, GXM, GYM&gt; cache;</a>
<a name="ln594">    static int cache_seed = -1;</a>
<a name="ln595"> </a>
<a name="ln596">    if (random)</a>
<a name="ln597">    {</a>
<a name="ln598">        cache_seed = -1;</a>
<a name="ln599">        for (int y = Y_BOUND_1; y &lt;= Y_BOUND_2; ++y)</a>
<a name="ln600">            for (int x = X_BOUND_1; x &lt;= X_BOUND_2; ++x)</a>
<a name="ln601">                cache[x][y] = random2(100);</a>
<a name="ln602">        return cache;</a>
<a name="ln603">    }</a>
<a name="ln604"> </a>
<a name="ln605">    // must not produce the magic value (-1)</a>
<a name="ln606">    int seed = ((static_cast&lt;int&gt;(you.where_are_you) &lt;&lt; 8) + you.depth)</a>
<a name="ln607">             ^ (you.game_seed &amp; 0x7fffffff);</a>
<a name="ln608"> </a>
<a name="ln609">    if (seed == cache_seed)</a>
<a name="ln610">        return cache;</a>
<a name="ln611"> </a>
<a name="ln612">    cache_seed = seed;</a>
<a name="ln613"> </a>
<a name="ln614">    for (int y = Y_BOUND_1; y &lt;= Y_BOUND_2; ++y)</a>
<a name="ln615">        for (int x = X_BOUND_1; x &lt;= X_BOUND_2; ++x)</a>
<a name="ln616">            cache[x][y] = hash_with_seed(100, seed, y * GXM + x);</a>
<a name="ln617"> </a>
<a name="ln618">    return cache;</a>
<a name="ln619">}</a>
<a name="ln620"> </a>
<a name="ln621">static colour_t _feat_default_map_colour(dungeon_feature_type feat)</a>
<a name="ln622">{</a>
<a name="ln623">    if (player_in_branch(BRANCH_SEWER) &amp;&amp; feat_is_water(feat))</a>
<a name="ln624">        return feat == DNGN_DEEP_WATER ? GREEN : LIGHTGREEN;</a>
<a name="ln625">    return BLACK;</a>
<a name="ln626">}</a>
<a name="ln627"> </a>
<a name="ln628">// Returns true if it succeeded.</a>
<a name="ln629">bool magic_mapping(int map_radius, int proportion, bool suppress_msg,</a>
<a name="ln630">                   bool force, bool deterministic,</a>
<a name="ln631">                   coord_def origin)</a>
<a name="ln632">{</a>
<a name="ln633">    if (!force &amp;&amp; !is_map_persistent())</a>
<a name="ln634">    {</a>
<a name="ln635">        if (!suppress_msg)</a>
<a name="ln636">            canned_msg(MSG_DISORIENTED);</a>
<a name="ln637"> </a>
<a name="ln638">        return false;</a>
<a name="ln639">    }</a>
<a name="ln640"> </a>
<a name="ln641">    const bool wizard_map = (you.wizard &amp;&amp; map_radius == 1000);</a>
<a name="ln642"> </a>
<a name="ln643">    if (map_radius &lt; 5)</a>
<a name="ln644">        map_radius = 5;</a>
<a name="ln645"> </a>
<a name="ln646">    // now gradually weaker with distance:</a>
<a name="ln647">    const int pfar     = map_radius * 7 / 10;</a>
<a name="ln648">    const int very_far = map_radius * 9 / 10;</a>
<a name="ln649"> </a>
<a name="ln650">    bool did_map = false;</a>
<a name="ln651">    int  num_altars        = 0;</a>
<a name="ln652">    int  num_shops_portals = 0;</a>
<a name="ln653"> </a>
<a name="ln654">    const FixedArray&lt;uint8_t, GXM, GYM&gt;&amp; difficulty =</a>
<a name="ln655">        _tile_difficulties(!deterministic);</a>
<a name="ln656"> </a>
<a name="ln657">    for (radius_iterator ri(in_bounds(origin) ? origin : you.pos(),</a>
<a name="ln658">                            map_radius, C_SQUARE);</a>
<a name="ln659">         ri; ++ri)</a>
<a name="ln660">    {</a>
<a name="ln661">        coord_def pos = *ri;</a>
<a name="ln662">        if (!wizard_map)</a>
<a name="ln663">        {</a>
<a name="ln664">            int threshold = proportion;</a>
<a name="ln665"> </a>
<a name="ln666">            const int dist = grid_distance(you.pos(), pos);</a>
<a name="ln667"> </a>
<a name="ln668">            if (dist &gt; very_far)</a>
<a name="ln669">                threshold = threshold / 3;</a>
<a name="ln670">            else if (dist &gt; pfar)</a>
<a name="ln671">                threshold = threshold * 2 / 3;</a>
<a name="ln672"> </a>
<a name="ln673">            if (difficulty(pos) &gt; threshold)</a>
<a name="ln674">                continue;</a>
<a name="ln675">        }</a>
<a name="ln676"> </a>
<a name="ln677">        map_cell&amp; knowledge = env.map_knowledge(pos);</a>
<a name="ln678"> </a>
<a name="ln679">        if (knowledge.changed())</a>
<a name="ln680">        {</a>
<a name="ln681">            // If the player has already seen the square, update map</a>
<a name="ln682">            // knowledge with the new terrain. Otherwise clear what we had</a>
<a name="ln683">            // before.</a>
<a name="ln684">            if (knowledge.seen())</a>
<a name="ln685">            {</a>
<a name="ln686">                dungeon_feature_type newfeat = grd(pos);</a>
<a name="ln687">                trap_type tr = feat_is_trap(newfeat) ? get_trap_type(pos) : TRAP_UNASSIGNED;</a>
<a name="ln688">                knowledge.set_feature(newfeat, env.grid_colours(pos), tr);</a>
<a name="ln689">            }</a>
<a name="ln690">            else</a>
<a name="ln691">                knowledge.clear();</a>
<a name="ln692">        }</a>
<a name="ln693"> </a>
<a name="ln694">        // Don't assume that DNGN_UNSEEN cells ever count as mapped.</a>
<a name="ln695">        // Because of a bug at one point in map forgetting, cells could</a>
<a name="ln696">        // spuriously get marked as mapped even when they were completely</a>
<a name="ln697">        // unseen.</a>
<a name="ln698">        const bool already_mapped = knowledge.mapped()</a>
<a name="ln699">                            &amp;&amp; knowledge.feat() != DNGN_UNSEEN;</a>
<a name="ln700"> </a>
<a name="ln701">        if (!wizard_map &amp;&amp; (knowledge.seen() || already_mapped))</a>
<a name="ln702">            continue;</a>
<a name="ln703"> </a>
<a name="ln704">        const dungeon_feature_type feat = grd(pos);</a>
<a name="ln705"> </a>
<a name="ln706">        bool open = true;</a>
<a name="ln707"> </a>
<a name="ln708">        if (feat_is_solid(feat) &amp;&amp; !feat_is_closed_door(feat))</a>
<a name="ln709">        {</a>
<a name="ln710">            open = false;</a>
<a name="ln711">            for (adjacent_iterator ai(pos); ai; ++ai)</a>
<a name="ln712">            {</a>
<a name="ln713">                if (map_bounds(*ai) &amp;&amp; (!feat_is_opaque(grd(*ai))</a>
<a name="ln714">                                        || feat_is_closed_door(grd(*ai))))</a>
<a name="ln715">                {</a>
<a name="ln716">                    open = true;</a>
<a name="ln717">                    break;</a>
<a name="ln718">                }</a>
<a name="ln719">            }</a>
<a name="ln720">        }</a>
<a name="ln721"> </a>
<a name="ln722">        if (open)</a>
<a name="ln723">        {</a>
<a name="ln724">            if (wizard_map)</a>
<a name="ln725">            {</a>
<a name="ln726">                knowledge.set_feature(feat, _feat_default_map_colour(feat),</a>
<a name="ln727">                    feat_is_trap(grd(pos)) ? get_trap_type(pos)</a>
<a name="ln728">                                           : TRAP_UNASSIGNED);</a>
<a name="ln729">            }</a>
<a name="ln730">            else if (!knowledge.feat())</a>
<a name="ln731">            {</a>
<a name="ln732">                auto base_feat = magic_map_base_feat(feat);</a>
<a name="ln733">                auto colour = _feat_default_map_colour(base_feat);</a>
<a name="ln734">                auto trap = feat_is_trap(grd(pos)) ? get_trap_type(pos)</a>
<a name="ln735">                                                   : TRAP_UNASSIGNED;</a>
<a name="ln736">                knowledge.set_feature(base_feat, colour, trap);</a>
<a name="ln737">            }</a>
<a name="ln738">            if (emphasise(pos))</a>
<a name="ln739">                knowledge.flags |= MAP_EMPHASIZE;</a>
<a name="ln740"> </a>
<a name="ln741">            if (wizard_map)</a>
<a name="ln742">            {</a>
<a name="ln743">                if (is_notable_terrain(feat))</a>
<a name="ln744">                    seen_notable_thing(feat, pos);</a>
<a name="ln745"> </a>
<a name="ln746">                set_terrain_seen(pos);</a>
<a name="ln747">#ifdef USE_TILE</a>
<a name="ln748">                tile_wizmap_terrain(pos);</a>
<a name="ln749">#endif</a>
<a name="ln750">            }</a>
<a name="ln751">            else</a>
<a name="ln752">            {</a>
<a name="ln753">                set_terrain_mapped(pos);</a>
<a name="ln754"> </a>
<a name="ln755">                if (get_cell_map_feature(knowledge) == MF_STAIR_BRANCH)</a>
<a name="ln756">                    seen_notable_thing(feat, pos);</a>
<a name="ln757"> </a>
<a name="ln758">                if (get_feature_dchar(feat) == DCHAR_ALTAR)</a>
<a name="ln759">                    num_altars++;</a>
<a name="ln760">                else if (get_feature_dchar(feat) == DCHAR_ARCH)</a>
<a name="ln761">                    num_shops_portals++;</a>
<a name="ln762">            }</a>
<a name="ln763"> </a>
<a name="ln764">            did_map = true;</a>
<a name="ln765">        }</a>
<a name="ln766">    }</a>
<a name="ln767"> </a>
<a name="ln768">    if (!suppress_msg)</a>
<a name="ln769">    {</a>
<a name="ln770">        if (did_map)</a>
<a name="ln771">            mpr(&quot;You feel aware of your surroundings.&quot;);</a>
<a name="ln772">        else</a>
<a name="ln773">            canned_msg(MSG_DISORIENTED);</a>
<a name="ln774"> </a>
<a name="ln775">        vector&lt;string&gt; sensed;</a>
<a name="ln776"> </a>
<a name="ln777">        if (num_altars &gt; 0)</a>
<a name="ln778">        {</a>
<a name="ln779">            sensed.push_back(make_stringf(&quot;%d altar%s&quot;, num_altars,</a>
<a name="ln780">                                          num_altars &gt; 1 ? &quot;s&quot; : &quot;&quot;));</a>
<a name="ln781">        }</a>
<a name="ln782"> </a>
<a name="ln783">        if (num_shops_portals &gt; 0)</a>
<a name="ln784">        {</a>
<a name="ln785">            const char* plur = num_shops_portals &gt; 1 ? &quot;s&quot; : &quot;&quot;;</a>
<a name="ln786">            sensed.push_back(make_stringf(&quot;%d shop%s/portal%s&quot;,</a>
<a name="ln787">                                          num_shops_portals, plur, plur));</a>
<a name="ln788">        }</a>
<a name="ln789"> </a>
<a name="ln790">        if (!sensed.empty())</a>
<a name="ln791">            mpr_comma_separated_list(&quot;You sensed &quot;, sensed);</a>
<a name="ln792">    }</a>
<a name="ln793"> </a>
<a name="ln794">    return did_map;</a>
<a name="ln795">}</a>
<a name="ln796"> </a>
<a name="ln797">void fully_map_level()</a>
<a name="ln798">{</a>
<a name="ln799">    for (rectangle_iterator ri(1); ri; ++ri)</a>
<a name="ln800">    {</a>
<a name="ln801">        bool ok = false;</a>
<a name="ln802">        for (adjacent_iterator ai(*ri, false); ai; ++ai)</a>
<a name="ln803">            if (!feat_is_opaque(grd(*ai)))</a>
<a name="ln804">                ok = true;</a>
<a name="ln805">        if (!ok)</a>
<a name="ln806">            continue;</a>
<a name="ln807">        env.map_knowledge(*ri).set_feature(grd(*ri), 0,</a>
<a name="ln808">            feat_is_trap(grd(*ri)) ? get_trap_type(*ri) : TRAP_UNASSIGNED);</a>
<a name="ln809">        set_terrain_seen(*ri);</a>
<a name="ln810">#ifdef USE_TILE</a>
<a name="ln811">        tile_wizmap_terrain(*ri);</a>
<a name="ln812">#endif</a>
<a name="ln813">        if (igrd(*ri) != NON_ITEM)</a>
<a name="ln814">            env.map_knowledge(*ri).set_detected_item();</a>
<a name="ln815">        env.pgrid(*ri) |= FPROP_SEEN_OR_NOEXP;</a>
<a name="ln816">    }</a>
<a name="ln817">}</a>
<a name="ln818"> </a>
<a name="ln819">bool mon_enemies_around(const monster* mons)</a>
<a name="ln820">{</a>
<a name="ln821">    // If the monster has a foe, return true.</a>
<a name="ln822">    if (mons-&gt;foe != MHITNOT &amp;&amp; mons-&gt;foe != MHITYOU)</a>
<a name="ln823">        return true;</a>
<a name="ln824"> </a>
<a name="ln825">    if (crawl_state.game_is_arena())</a>
<a name="ln826">    {</a>
<a name="ln827">        // If the arena-mode code in _handle_behaviour() hasn't set a foe then</a>
<a name="ln828">        // we don't have one.</a>
<a name="ln829">        return false;</a>
<a name="ln830">    }</a>
<a name="ln831">    else if (mons-&gt;wont_attack())</a>
<a name="ln832">    {</a>
<a name="ln833">        // Additionally, if an ally is nearby and *you* have a foe,</a>
<a name="ln834">        // consider it as the ally's enemy too.</a>
<a name="ln835">        return you.can_see(*mons) &amp;&amp; there_are_monsters_nearby(true);</a>
<a name="ln836">    }</a>
<a name="ln837">    else</a>
<a name="ln838">    {</a>
<a name="ln839">        // For hostile monster* you* are the main enemy.</a>
<a name="ln840">        return mons-&gt;can_see(you);</a>
<a name="ln841">    }</a>
<a name="ln842">}</a>
<a name="ln843"> </a>
<a name="ln844">// Returns a string containing a representation of the map. Leading and</a>
<a name="ln845">// trailing spaces are trimmed from each line. Leading and trailing empty</a>
<a name="ln846">// lines are also snipped.</a>
<a name="ln847">string screenshot()</a>
<a name="ln848">{</a>
<a name="ln849">    vector&lt;string&gt; lines(crawl_view.viewsz.y);</a>
<a name="ln850">    unsigned int lsp = GXM;</a>
<a name="ln851">    for (int y = 0; y &lt; crawl_view.viewsz.y; y++)</a>
<a name="ln852">    {</a>
<a name="ln853">        string line;</a>
<a name="ln854">        for (int x = 0; x &lt; crawl_view.viewsz.x; x++)</a>
<a name="ln855">        {</a>
<a name="ln856">            // in grid coords</a>
<a name="ln857">            const coord_def gc = view2grid(crawl_view.viewp +</a>
<a name="ln858">                                     coord_def(x, y));</a>
<a name="ln859">            char32_t ch =</a>
<a name="ln860">                  (!map_bounds(gc))             ? ' ' :</a>
<a name="ln861">                  (gc == you.pos())             ? mons_char(you.symbol)</a>
<a name="ln862">                                                : get_cell_glyph(gc).ch;</a>
<a name="ln863">            line += stringize_glyph(ch);</a>
<a name="ln864">        }</a>
<a name="ln865">        // right-trim the line</a>
<a name="ln866">        for (int x = line.length() - 1; x &gt;= 0; x--)</a>
<a name="ln867">            if (line[x] == ' ')</a>
<a name="ln868">                line.erase(x);</a>
<a name="ln869">            else</a>
<a name="ln870">                break;</a>
<a name="ln871">        // see how much it can be left-trimmed</a>
<a name="ln872">        for (unsigned int x = 0; x &lt; line.length(); x++)</a>
<a name="ln873">            if (line[x] != ' ')</a>
<a name="ln874">            {</a>
<a name="ln875">                if (lsp &gt; x)</a>
<a name="ln876">                    lsp = x;</a>
<a name="ln877">                break;</a>
<a name="ln878">            }</a>
<a name="ln879">        lines[y] = line;</a>
<a name="ln880">    }</a>
<a name="ln881"> </a>
<a name="ln882">    for (string &amp;line : lines)</a>
<a name="ln883">        line.erase(0, lsp);     // actually trim from the left</a>
<a name="ln884">    while (!lines.empty() &amp;&amp; lines.back().empty())</a>
<a name="ln885">        lines.pop_back();       // then from the bottom</a>
<a name="ln886"> </a>
<a name="ln887">    ostringstream ss;</a>
<a name="ln888">    unsigned int y = 0;</a>
<a name="ln889">    for (y = 0; y &lt; lines.size() &amp;&amp; lines[y].empty(); y++)</a>
<a name="ln890">        ;                       // ... and from the top</a>
<a name="ln891">    for (; y &lt; lines.size(); y++)</a>
<a name="ln892">        ss &lt;&lt; lines[y] &lt;&lt; &quot;\n&quot;;</a>
<a name="ln893">    return ss.str();</a>
<a name="ln894">}</a>
<a name="ln895"> </a>
<a name="ln896">int viewmap_flash_colour()</a>
<a name="ln897">{</a>
<a name="ln898">    return _layers &amp; LAYERS_ALL &amp;&amp; you.berserk() ? RED : BLACK;</a>
<a name="ln899">}</a>
<a name="ln900"> </a>
<a name="ln901">// Updates one square of the view area. Should only be called for square</a>
<a name="ln902">// in LOS.</a>
<a name="ln903">void view_update_at(const coord_def &amp;pos)</a>
<a name="ln904">{</a>
<a name="ln905">    if (pos == you.pos())</a>
<a name="ln906">        return;</a>
<a name="ln907"> </a>
<a name="ln908">    show_update_at(pos);</a>
<a name="ln909"> </a>
<a name="ln910">#ifndef USE_TILE_LOCAL</a>
<a name="ln911">    if (!env.map_knowledge(pos).visible())</a>
<a name="ln912">        return;</a>
<a name="ln913">    cglyph_t g = get_cell_glyph(pos);</a>
<a name="ln914"> </a>
<a name="ln915">    int flash_colour = you.flash_colour == BLACK</a>
<a name="ln916">        ? viewmap_flash_colour()</a>
<a name="ln917">        : you.flash_colour;</a>
<a name="ln918">    monster_type mons = env.map_knowledge(pos).monster();</a>
<a name="ln919">    int cell_colour =</a>
<a name="ln920">        flash_colour &amp;&amp;</a>
<a name="ln921">        (mons == MONS_NO_MONSTER || mons_class_is_firewood(mons))</a>
<a name="ln922">            ? real_colour(flash_colour)</a>
<a name="ln923">            : g.col;</a>
<a name="ln924"> </a>
<a name="ln925">    const coord_def vp = grid2view(pos);</a>
<a name="ln926">    // Don't draw off-screen.</a>
<a name="ln927">    if (crawl_view.in_viewport_v(vp))</a>
<a name="ln928">    {</a>
<a name="ln929">        cgotoxy(vp.x, vp.y, GOTO_DNGN);</a>
<a name="ln930">        put_colour_ch(cell_colour, g.ch);</a>
<a name="ln931">    }</a>
<a name="ln932"> </a>
<a name="ln933">    // Force colour back to normal, else clrscr() will flood screen</a>
<a name="ln934">    // with this colour on DOS.</a>
<a name="ln935">    textcolour(LIGHTGREY);</a>
<a name="ln936"> </a>
<a name="ln937">#endif</a>
<a name="ln938">#ifdef USE_TILE_WEB</a>
<a name="ln939">    tiles.mark_for_redraw(pos);</a>
<a name="ln940">#endif</a>
<a name="ln941">}</a>
<a name="ln942"> </a>
<a name="ln943">// TODO: this should be fixed so that it can work in local tiles</a>
<a name="ln944">void flash_monster_colour(const monster* mon, colour_t fmc_colour,</a>
<a name="ln945">                          int fmc_delay)</a>
<a name="ln946">{</a>
<a name="ln947">    ASSERT(mon); // XXX: change to const monster &amp;mon</a>
<a name="ln948">#ifndef USE_TILE_LOCAL</a>
<a name="ln949">    if ((Options.use_animations &amp; UA_PLAYER) &amp;&amp; you.can_see(*mon))</a>
<a name="ln950">    {</a>
<a name="ln951">        colour_t old_flash_colour = you.flash_colour;</a>
<a name="ln952">        coord_def c(mon-&gt;pos());</a>
<a name="ln953"> </a>
<a name="ln954">        you.flash_colour = fmc_colour;</a>
<a name="ln955">        view_update_at(c);</a>
<a name="ln956"> </a>
<a name="ln957">        update_screen();</a>
<a name="ln958">        delay(fmc_delay);</a>
<a name="ln959"> </a>
<a name="ln960">        you.flash_colour = old_flash_colour;</a>
<a name="ln961">        view_update_at(c);</a>
<a name="ln962">        update_screen();</a>
<a name="ln963">    }</a>
<a name="ln964">#else</a>
<a name="ln965">    UNUSED(fmc_colour, fmc_delay);</a>
<a name="ln966">#endif</a>
<a name="ln967">}</a>
<a name="ln968"> </a>
<a name="ln969">bool view_update()</a>
<a name="ln970">{</a>
<a name="ln971">    if (you.num_turns &gt; you.last_view_update)</a>
<a name="ln972">    {</a>
<a name="ln973">        viewwindow();</a>
<a name="ln974">        return true;</a>
<a name="ln975">    }</a>
<a name="ln976">    return false;</a>
<a name="ln977">}</a>
<a name="ln978"> </a>
<a name="ln979">void flash_view(use_animation_type a, colour_t colour, targeter *where)</a>
<a name="ln980">{</a>
<a name="ln981">    if (Options.use_animations &amp; a)</a>
<a name="ln982">    {</a>
<a name="ln983">        you.flash_colour = colour;</a>
<a name="ln984">        you.flash_where = where;</a>
<a name="ln985">        viewwindow(false);</a>
<a name="ln986">    }</a>
<a name="ln987">}</a>
<a name="ln988"> </a>
<a name="ln989">void flash_view_delay(use_animation_type a, colour_t colour, int flash_delay,</a>
<a name="ln990">                      targeter *where)</a>
<a name="ln991">{</a>
<a name="ln992">    if (Options.use_animations &amp; a)</a>
<a name="ln993">    {</a>
<a name="ln994">        flash_view(a, colour, where);</a>
<a name="ln995">        scaled_delay(flash_delay);</a>
<a name="ln996">        flash_view(a, 0);</a>
<a name="ln997">    }</a>
<a name="ln998">}</a>
<a name="ln999"> </a>
<a name="ln1000">enum class update_flag</a>
<a name="ln1001">{</a>
<a name="ln1002">    affect_excludes = (1 &lt;&lt; 0),</a>
<a name="ln1003">    added_exclude   = (1 &lt;&lt; 1),</a>
<a name="ln1004">};</a>
<a name="ln1005">DEF_BITFIELD(update_flags, update_flag);</a>
<a name="ln1006"> </a>
<a name="ln1007">// Do various updates when the player sees a cell. Returns whether</a>
<a name="ln1008">// exclusion LOS might have been affected.</a>
<a name="ln1009">static update_flags player_view_update_at(const coord_def &amp;gc)</a>
<a name="ln1010">{</a>
<a name="ln1011">    maybe_remove_autoexclusion(gc);</a>
<a name="ln1012">    update_flags ret;</a>
<a name="ln1013"> </a>
<a name="ln1014">    // Set excludes in a radius of 1 around harmful clouds genereated</a>
<a name="ln1015">    // by neither monsters nor the player.</a>
<a name="ln1016">    const cloud_struct* cloud = cloud_at(gc);</a>
<a name="ln1017">    if (cloud &amp;&amp; !crawl_state.game_is_arena())</a>
<a name="ln1018">    {</a>
<a name="ln1019">        const cloud_struct &amp;cl = *cloud;</a>
<a name="ln1020"> </a>
<a name="ln1021">        bool did_exclude = false;</a>
<a name="ln1022">        if (!cl.temporary() &amp;&amp; is_damaging_cloud(cl.type, false))</a>
<a name="ln1023">        {</a>
<a name="ln1024">            int size = cl.exclusion_radius();</a>
<a name="ln1025"> </a>
<a name="ln1026">            // Steam clouds are less dangerous than the other ones,</a>
<a name="ln1027">            // so don't exclude the neighbour cells.</a>
<a name="ln1028">            if (cl.type == CLOUD_STEAM &amp;&amp; size == 1)</a>
<a name="ln1029">                size = 0;</a>
<a name="ln1030"> </a>
<a name="ln1031">            bool was_exclusion = is_exclude_root(gc);</a>
<a name="ln1032">            set_exclude(gc, size, true, false, true);</a>
<a name="ln1033">            if (!did_exclude &amp;&amp; !was_exclusion)</a>
<a name="ln1034">                ret |= update_flag::added_exclude;</a>
<a name="ln1035">        }</a>
<a name="ln1036">    }</a>
<a name="ln1037"> </a>
<a name="ln1038">    // Print hints mode messages for features in LOS.</a>
<a name="ln1039">    if (crawl_state.game_is_hints())</a>
<a name="ln1040">        hints_observe_cell(gc);</a>
<a name="ln1041"> </a>
<a name="ln1042">    if (env.map_knowledge(gc).changed() || !env.map_knowledge(gc).seen())</a>
<a name="ln1043">        ret |= update_flag::affect_excludes;</a>
<a name="ln1044"> </a>
<a name="ln1045">    set_terrain_visible(gc);</a>
<a name="ln1046"> </a>
<a name="ln1047">    if (!(env.pgrid(gc) &amp; FPROP_SEEN_OR_NOEXP))</a>
<a name="ln1048">    {</a>
<a name="ln1049">        if (!crawl_state.game_is_arena()</a>
<a name="ln1050">            &amp;&amp; cell_triggers_conduct(gc)</a>
<a name="ln1051">            &amp;&amp; !player_in_branch(BRANCH_TEMPLE))</a>
<a name="ln1052">        {</a>
<a name="ln1053">            did_god_conduct(DID_EXPLORATION, 2500);</a>
<a name="ln1054">            const int density = env.density ? env.density : 2000;</a>
<a name="ln1055">            you.exploration += div_rand_round(1&lt;&lt;16, density);</a>
<a name="ln1056">            roll_trap_effects();</a>
<a name="ln1057">        }</a>
<a name="ln1058">        env.pgrid(gc) |= FPROP_SEEN_OR_NOEXP;</a>
<a name="ln1059">    }</a>
<a name="ln1060"> </a>
<a name="ln1061">#ifdef USE_TILE</a>
<a name="ln1062">    const coord_def ep = grid2show(gc);</a>
<a name="ln1063"> </a>
<a name="ln1064">    // We remove any references to mcache when</a>
<a name="ln1065">    // writing to the background.</a>
<a name="ln1066">    env.tile_bk_fg(gc) = env.tile_fg(ep);</a>
<a name="ln1067">    env.tile_bk_bg(gc) = env.tile_bg(ep);</a>
<a name="ln1068">    env.tile_bk_cloud(gc) = env.tile_cloud(ep);</a>
<a name="ln1069">#endif</a>
<a name="ln1070"> </a>
<a name="ln1071">    return ret;</a>
<a name="ln1072">}</a>
<a name="ln1073"> </a>
<a name="ln1074">static void player_view_update()</a>
<a name="ln1075">{</a>
<a name="ln1076">    if (crawl_state.game_is_arena())</a>
<a name="ln1077">    {</a>
<a name="ln1078">        for (rectangle_iterator ri(crawl_view.vgrdc, LOS_MAX_RANGE); ri; ++ri)</a>
<a name="ln1079">            player_view_update_at(*ri);</a>
<a name="ln1080">        // no need to do excludes on the arena</a>
<a name="ln1081">        return;</a>
<a name="ln1082">    }</a>
<a name="ln1083"> </a>
<a name="ln1084">    vector&lt;coord_def&gt; update_excludes;</a>
<a name="ln1085">    bool need_update = false;</a>
<a name="ln1086"> </a>
<a name="ln1087">    for (radius_iterator ri(you.pos(), you.xray_vision ? LOS_NONE : LOS_DEFAULT); ri; ++ri)</a>
<a name="ln1088">    {</a>
<a name="ln1089">        update_flags flags = player_view_update_at(*ri);</a>
<a name="ln1090">        if (flags &amp; update_flag::affect_excludes)</a>
<a name="ln1091">            update_excludes.push_back(*ri);</a>
<a name="ln1092">        if (flags &amp; update_flag::added_exclude)</a>
<a name="ln1093">            need_update = true;</a>
<a name="ln1094">    }</a>
<a name="ln1095">    // Update exclusion LOS for possibly affected excludes.</a>
<a name="ln1096">    update_exclusion_los(update_excludes);</a>
<a name="ln1097">    // Catch up on deferred updates for cloud excludes.</a>
<a name="ln1098">    if (need_update)</a>
<a name="ln1099">        deferred_exclude_update();</a>
<a name="ln1100">}</a>
<a name="ln1101"> </a>
<a name="ln1102">static void _draw_out_of_bounds(screen_cell_t *cell)</a>
<a name="ln1103">{</a>
<a name="ln1104">    cell-&gt;glyph  = ' ';</a>
<a name="ln1105">    cell-&gt;colour = DARKGREY;</a>
<a name="ln1106">#ifdef USE_TILE</a>
<a name="ln1107">    cell-&gt;tile.fg = 0;</a>
<a name="ln1108">    cell-&gt;tile.bg = tileidx_out_of_bounds(you.where_are_you);</a>
<a name="ln1109">#endif</a>
<a name="ln1110">}</a>
<a name="ln1111"> </a>
<a name="ln1112">static void _draw_outside_los(screen_cell_t *cell, const coord_def &amp;gc,</a>
<a name="ln1113">                                    const coord_def &amp;ep)</a>
<a name="ln1114">{</a>
<a name="ln1115">    // Outside the env.show area.</a>
<a name="ln1116">    cglyph_t g = get_cell_glyph(gc);</a>
<a name="ln1117">    cell-&gt;glyph  = g.ch;</a>
<a name="ln1118">    cell-&gt;colour = g.col;</a>
<a name="ln1119"> </a>
<a name="ln1120">#ifdef USE_TILE</a>
<a name="ln1121">    // this is just for out-of-los rays, but I don't see a more efficient way..</a>
<a name="ln1122">    if (in_bounds(gc))</a>
<a name="ln1123">        cell-&gt;tile.bg = env.tile_bg(ep);</a>
<a name="ln1124"> </a>
<a name="ln1125">    tileidx_out_of_los(&amp;cell-&gt;tile.fg, &amp;cell-&gt;tile.bg, &amp;cell-&gt;tile.cloud, gc);</a>
<a name="ln1126">#else</a>
<a name="ln1127">    UNUSED(ep);</a>
<a name="ln1128">#endif</a>
<a name="ln1129">}</a>
<a name="ln1130"> </a>
<a name="ln1131">static void _draw_player(screen_cell_t *cell,</a>
<a name="ln1132">                         const coord_def &amp;gc, const coord_def &amp;ep,</a>
<a name="ln1133">                         bool anim_updates)</a>
<a name="ln1134">{</a>
<a name="ln1135">    // Player overrides everything in cell.</a>
<a name="ln1136">    cell-&gt;glyph  = mons_char(you.symbol);</a>
<a name="ln1137">    cell-&gt;colour = mons_class_colour(you.symbol);</a>
<a name="ln1138">    if (you.swimming())</a>
<a name="ln1139">    {</a>
<a name="ln1140">        if (grd(gc) == DNGN_DEEP_WATER)</a>
<a name="ln1141">            cell-&gt;colour = BLUE;</a>
<a name="ln1142">        else</a>
<a name="ln1143">            cell-&gt;colour = CYAN;</a>
<a name="ln1144">    }</a>
<a name="ln1145">    if (Options.use_fake_player_cursor)</a>
<a name="ln1146">        cell-&gt;colour |= COLFLAG_REVERSE;</a>
<a name="ln1147"> </a>
<a name="ln1148">    cell-&gt;colour = real_colour(cell-&gt;colour);</a>
<a name="ln1149"> </a>
<a name="ln1150">#ifdef USE_TILE</a>
<a name="ln1151">    cell-&gt;tile.fg = env.tile_fg(ep) = tileidx_player();</a>
<a name="ln1152">    cell-&gt;tile.bg = env.tile_bg(ep);</a>
<a name="ln1153">    cell-&gt;tile.cloud = env.tile_cloud(ep);</a>
<a name="ln1154">    if (anim_updates)</a>
<a name="ln1155">        tile_apply_animations(cell-&gt;tile.bg, &amp;env.tile_flv(gc));</a>
<a name="ln1156">#else</a>
<a name="ln1157">    UNUSED(ep, anim_updates);</a>
<a name="ln1158">#endif</a>
<a name="ln1159">}</a>
<a name="ln1160"> </a>
<a name="ln1161">static void _draw_los(screen_cell_t *cell,</a>
<a name="ln1162">                      const coord_def &amp;gc, const coord_def &amp;ep,</a>
<a name="ln1163">                      bool anim_updates)</a>
<a name="ln1164">{</a>
<a name="ln1165">    cglyph_t g = get_cell_glyph(gc);</a>
<a name="ln1166">    cell-&gt;glyph  = g.ch;</a>
<a name="ln1167">    cell-&gt;colour = g.col;</a>
<a name="ln1168"> </a>
<a name="ln1169">#ifdef USE_TILE</a>
<a name="ln1170">    cell-&gt;tile.fg = env.tile_fg(ep);</a>
<a name="ln1171">    cell-&gt;tile.bg = env.tile_bg(ep);</a>
<a name="ln1172">    cell-&gt;tile.cloud = env.tile_cloud(ep);</a>
<a name="ln1173">    if (anim_updates)</a>
<a name="ln1174">        tile_apply_animations(cell-&gt;tile.bg, &amp;env.tile_flv(gc));</a>
<a name="ln1175">#else</a>
<a name="ln1176">    UNUSED(ep, anim_updates);</a>
<a name="ln1177">#endif</a>
<a name="ln1178">}</a>
<a name="ln1179"> </a>
<a name="ln1180">class shake_viewport_animation: public animation</a>
<a name="ln1181">{</a>
<a name="ln1182">public:</a>
<a name="ln1183">    shake_viewport_animation() { frames = 5; frame_delay = 40; }</a>
<a name="ln1184"> </a>
<a name="ln1185">    void init_frame(int /*frame*/) override</a>
<a name="ln1186">    {</a>
<a name="ln1187">        offset = coord_def();</a>
<a name="ln1188">        offset.x = random2(3) - 1;</a>
<a name="ln1189">        offset.y = random2(3) - 1;</a>
<a name="ln1190">    }</a>
<a name="ln1191"> </a>
<a name="ln1192">    coord_def cell_cb(const coord_def &amp;pos, int &amp;/*colour*/) override</a>
<a name="ln1193">    {</a>
<a name="ln1194">        return pos + offset;</a>
<a name="ln1195">    }</a>
<a name="ln1196"> </a>
<a name="ln1197">private:</a>
<a name="ln1198">    coord_def offset;</a>
<a name="ln1199">};</a>
<a name="ln1200"> </a>
<a name="ln1201">class checkerboard_animation: public animation</a>
<a name="ln1202">{</a>
<a name="ln1203">public:</a>
<a name="ln1204">    checkerboard_animation() { frame_delay = 100; frames = 5; }</a>
<a name="ln1205">    void init_frame(int frame) override</a>
<a name="ln1206">    {</a>
<a name="ln1207">        current_frame = frame;</a>
<a name="ln1208">    }</a>
<a name="ln1209"> </a>
<a name="ln1210">    coord_def cell_cb(const coord_def &amp;pos, int &amp;/*colour*/) override</a>
<a name="ln1211">    {</a>
<a name="ln1212">        if (current_frame % 2 == (pos.x + pos.y) % 2 &amp;&amp; pos != you.pos())</a>
<a name="ln1213">            return coord_def(-1, -1);</a>
<a name="ln1214">        else</a>
<a name="ln1215">            return pos;</a>
<a name="ln1216">    }</a>
<a name="ln1217"> </a>
<a name="ln1218">    int current_frame;</a>
<a name="ln1219">};</a>
<a name="ln1220"> </a>
<a name="ln1221">class banish_animation: public animation</a>
<a name="ln1222">{</a>
<a name="ln1223">public:</a>
<a name="ln1224">    banish_animation(): remaining(false) { }</a>
<a name="ln1225"> </a>
<a name="ln1226">    void init_frame(int frame) override</a>
<a name="ln1227">    {</a>
<a name="ln1228">        current_frame = frame;</a>
<a name="ln1229"> </a>
<a name="ln1230">        if (!frame)</a>
<a name="ln1231">        {</a>
<a name="ln1232">            frames = 10;</a>
<a name="ln1233">            hidden.clear();</a>
<a name="ln1234">            remaining = true;</a>
<a name="ln1235">        }</a>
<a name="ln1236"> </a>
<a name="ln1237">        if (remaining)</a>
<a name="ln1238">            frames = frame + 2;</a>
<a name="ln1239">        else</a>
<a name="ln1240">            frames = frame;</a>
<a name="ln1241"> </a>
<a name="ln1242">        remaining = false;</a>
<a name="ln1243">    }</a>
<a name="ln1244"> </a>
<a name="ln1245">    coord_def cell_cb(const coord_def &amp;pos, int &amp;/*colour*/) override</a>
<a name="ln1246">    {</a>
<a name="ln1247">        if (pos == you.pos())</a>
<a name="ln1248">            return pos;</a>
<a name="ln1249"> </a>
<a name="ln1250">        if (bool *found = map_find(hidden, pos))</a>
<a name="ln1251">        {</a>
<a name="ln1252">            if (*found)</a>
<a name="ln1253">                return coord_def(-1, -1);</a>
<a name="ln1254">        }</a>
<a name="ln1255"> </a>
<a name="ln1256">        if (!random2(10 - current_frame))</a>
<a name="ln1257">        {</a>
<a name="ln1258">            hidden.insert(make_pair(pos, true));</a>
<a name="ln1259">            return coord_def(-1, -1);</a>
<a name="ln1260">        }</a>
<a name="ln1261"> </a>
<a name="ln1262">        remaining = true;</a>
<a name="ln1263">        return pos;</a>
<a name="ln1264">    }</a>
<a name="ln1265"> </a>
<a name="ln1266">    bool remaining;</a>
<a name="ln1267">    map&lt;coord_def, bool&gt; hidden;</a>
<a name="ln1268">    int current_frame;</a>
<a name="ln1269">};</a>
<a name="ln1270"> </a>
<a name="ln1271">class slideout_animation: public animation</a>
<a name="ln1272">{</a>
<a name="ln1273">public:</a>
<a name="ln1274">    void init_frame(int frame) override</a>
<a name="ln1275">    {</a>
<a name="ln1276">        current_frame = frame;</a>
<a name="ln1277">    }</a>
<a name="ln1278"> </a>
<a name="ln1279">    coord_def cell_cb(const coord_def &amp;pos, int &amp;/*colour*/) override</a>
<a name="ln1280">    {</a>
<a name="ln1281">        coord_def ret;</a>
<a name="ln1282">        if (pos.y % 2)</a>
<a name="ln1283">            ret = coord_def(pos.x + current_frame * 4, pos.y);</a>
<a name="ln1284">        else</a>
<a name="ln1285">            ret = coord_def(pos.x - current_frame * 4, pos.y);</a>
<a name="ln1286"> </a>
<a name="ln1287">        coord_def view = grid2view(ret);</a>
<a name="ln1288">        const coord_def max = crawl_view.viewsz;</a>
<a name="ln1289">        if (view.x &lt; 1 || view.y &lt; 1 || view.x &gt; max.x || view.y &gt; max.y)</a>
<a name="ln1290">            return coord_def(-1, -1);</a>
<a name="ln1291">        else</a>
<a name="ln1292">            return ret;</a>
<a name="ln1293">    }</a>
<a name="ln1294"> </a>
<a name="ln1295">    int current_frame;</a>
<a name="ln1296">};</a>
<a name="ln1297"> </a>
<a name="ln1298">class orb_animation: public animation</a>
<a name="ln1299">{</a>
<a name="ln1300">public:</a>
<a name="ln1301">    void init_frame(int frame) override</a>
<a name="ln1302">    {</a>
<a name="ln1303">        current_frame = frame;</a>
<a name="ln1304">        range = current_frame &gt; 5</a>
<a name="ln1305">            ? (10 - current_frame)</a>
<a name="ln1306">            : current_frame;</a>
<a name="ln1307">        frame_delay = 3 * (6 - range) * (6 - range);</a>
<a name="ln1308">    }</a>
<a name="ln1309"> </a>
<a name="ln1310">    coord_def cell_cb(const coord_def &amp;pos, int &amp;colour) override</a>
<a name="ln1311">    {</a>
<a name="ln1312">        const coord_def diff = pos - you.pos();</a>
<a name="ln1313">        const int dist = diff.x * diff.x * 4 / 9 + diff.y * diff.y;</a>
<a name="ln1314">        const int min = range * range;</a>
<a name="ln1315">        const int max = (range + 2) * (range  + 2);</a>
<a name="ln1316">        if (dist &gt;= min &amp;&amp; dist &lt; max)</a>
<a name="ln1317">            if (is_tiles())</a>
<a name="ln1318">                colour = MAGENTA;</a>
<a name="ln1319">            else</a>
<a name="ln1320">                colour = DARKGREY;</a>
<a name="ln1321">        else</a>
<a name="ln1322">            colour = 0;</a>
<a name="ln1323"> </a>
<a name="ln1324">        return pos;</a>
<a name="ln1325">    }</a>
<a name="ln1326"> </a>
<a name="ln1327">    int range;</a>
<a name="ln1328">    int current_frame;</a>
<a name="ln1329">};</a>
<a name="ln1330"> </a>
<a name="ln1331">static shake_viewport_animation shake_viewport;</a>
<a name="ln1332">static checkerboard_animation checkerboard;</a>
<a name="ln1333">static banish_animation banish;</a>
<a name="ln1334">static slideout_animation slideout;</a>
<a name="ln1335">static orb_animation orb;</a>
<a name="ln1336"> </a>
<a name="ln1337">static animation *animations[NUM_ANIMATIONS] = {</a>
<a name="ln1338">    &amp;shake_viewport,</a>
<a name="ln1339">    &amp;checkerboard,</a>
<a name="ln1340">    &amp;banish,</a>
<a name="ln1341">    &amp;slideout,</a>
<a name="ln1342">    &amp;orb</a>
<a name="ln1343">};</a>
<a name="ln1344"> </a>
<a name="ln1345">void run_animation(animation_type anim, use_animation_type type, bool cleanup)</a>
<a name="ln1346">{</a>
<a name="ln1347">#ifdef USE_TILE_WEB</a>
<a name="ln1348">    // XXX this doesn't work in webtiles yet</a>
<a name="ln1349">    if (is_tiles())</a>
<a name="ln1350">        return;</a>
<a name="ln1351">#endif</a>
<a name="ln1352">    if (Options.use_animations &amp; type)</a>
<a name="ln1353">    {</a>
<a name="ln1354">        animation *a = animations[anim];</a>
<a name="ln1355"> </a>
<a name="ln1356">        viewwindow();</a>
<a name="ln1357"> </a>
<a name="ln1358">        for (int i = 0; i &lt; a-&gt;frames; ++i)</a>
<a name="ln1359">        {</a>
<a name="ln1360">            a-&gt;init_frame(i);</a>
<a name="ln1361">            viewwindow(false, false, a);</a>
<a name="ln1362">            delay(a-&gt;frame_delay);</a>
<a name="ln1363">        }</a>
<a name="ln1364"> </a>
<a name="ln1365">        if (cleanup)</a>
<a name="ln1366">            viewwindow();</a>
<a name="ln1367">    }</a>
<a name="ln1368">}</a>
<a name="ln1369"> </a>
<a name="ln1370">static bool _view_is_updating = false;</a>
<a name="ln1371"> </a>
<a name="ln1372">/**</a>
<a name="ln1373"> * Draws the main window using the character set returned</a>
<a name="ln1374"> * by get_show_glyph().</a>
<a name="ln1375"> *</a>
<a name="ln1376"> * @param show_updates if true, env.show and dependent structures</a>
<a name="ln1377"> *                     are updated. Should be set if anything in</a>
<a name="ln1378"> *                     view has changed.</a>
<a name="ln1379"> * @param tiles_only if true, only the tile view will be updated. This</a>
<a name="ln1380"> *                   is only relevant for Webtiles.</a>
<a name="ln1381"> * @param a[in] the animation to be showing, if any.</a>
<a name="ln1382"> */</a>
<a name="ln1383">void viewwindow(bool show_updates, bool tiles_only, animation *a)</a>
<a name="ln1384">{</a>
<a name="ln1385">    if (_view_is_updating)</a>
<a name="ln1386">    {</a>
<a name="ln1387">        // recursive calls to this function can lead to memory corruption or</a>
<a name="ln1388">        // crashes, depending on the circumstance, because some functions</a>
<a name="ln1389">        // called from here (e.g. show_init) will wipe out a whole bunch of</a>
<a name="ln1390">        // map data that will still be lurking around higher on the call stack</a>
<a name="ln1391">        // as references. Because the call paths are so complicated, it's hard</a>
<a name="ln1392">        // to find a principled / non-brute-force way of preventing recursion</a>
<a name="ln1393">        // here -- though it's still better to prevent it by other means if</a>
<a name="ln1394">        // possible.</a>
<a name="ln1395">        dprf(&quot;Recursive viewwindow call attempted!&quot;);</a>
<a name="ln1396">        return;</a>
<a name="ln1397">    }</a>
<a name="ln1398"> </a>
<a name="ln1399">    {</a>
<a name="ln1400">        unwind_bool updating(_view_is_updating, true);</a>
<a name="ln1401"> </a>
<a name="ln1402">        // The player could be at (0,0) if we are called during level-gen; this can</a>
<a name="ln1403">        // happen via mpr -&gt; interrupt_activity -&gt; stop_delay -&gt; runrest::stop</a>
<a name="ln1404">        if (you.duration[DUR_TIME_STEP] || you.pos().origin())</a>
<a name="ln1405">            return;</a>
<a name="ln1406"> </a>
<a name="ln1407">        screen_cell_t *cell(crawl_view.vbuf);</a>
<a name="ln1408"> </a>
<a name="ln1409">        // The buffer is not initialised when run from 'monster'; abort early.</a>
<a name="ln1410">        if (!cell)</a>
<a name="ln1411">            return;</a>
<a name="ln1412"> </a>
<a name="ln1413">        // Update the animation of cells only once per turn.</a>
<a name="ln1414">        const bool anim_updates = (you.last_view_update != you.num_turns);</a>
<a name="ln1415"> </a>
<a name="ln1416">        if (anim_updates)</a>
<a name="ln1417">            you.frame_no++;</a>
<a name="ln1418"> </a>
<a name="ln1419">#ifdef USE_TILE</a>
<a name="ln1420">        tiles.clear_text_tags(TAG_NAMED_MONSTER);</a>
<a name="ln1421"> </a>
<a name="ln1422">        if (show_updates)</a>
<a name="ln1423">            mcache.clear_nonref();</a>
<a name="ln1424">#endif</a>
<a name="ln1425"> </a>
<a name="ln1426">        if (show_updates || _layers != LAYERS_ALL)</a>
<a name="ln1427">        {</a>
<a name="ln1428">            if (!is_map_persistent())</a>
<a name="ln1429">                ash_detect_portals(false);</a>
<a name="ln1430"> </a>
<a name="ln1431">#ifdef USE_TILE</a>
<a name="ln1432">            tile_draw_floor();</a>
<a name="ln1433">            tile_draw_rays(true);</a>
<a name="ln1434">            tiles.clear_overlays();</a>
<a name="ln1435">#endif</a>
<a name="ln1436"> </a>
<a name="ln1437">            show_init(_layers);</a>
<a name="ln1438">        }</a>
<a name="ln1439"> </a>
<a name="ln1440">        if (show_updates)</a>
<a name="ln1441">            player_view_update();</a>
<a name="ln1442"> </a>
<a name="ln1443">        bool run_dont_draw = you.running &amp;&amp; Options.travel_delay &lt; 0</a>
<a name="ln1444">                    &amp;&amp; (!you.running.is_explore() || Options.explore_delay &lt; 0);</a>
<a name="ln1445">        if (you.running &amp;&amp; you.running.is_rest())</a>
<a name="ln1446">            run_dont_draw = Options.rest_delay == -1;</a>
<a name="ln1447">        if (mouse_control::current_mode() != MOUSE_MODE_NORMAL)</a>
<a name="ln1448">            run_dont_draw = false;</a>
<a name="ln1449"> </a>
<a name="ln1450">        if (run_dont_draw || you.asleep())</a>
<a name="ln1451">        {</a>
<a name="ln1452">            // Reset env.show if we munged it.</a>
<a name="ln1453">            if (_layers != LAYERS_ALL)</a>
<a name="ln1454">                show_init();</a>
<a name="ln1455">            return;</a>
<a name="ln1456">        }</a>
<a name="ln1457"> </a>
<a name="ln1458">        cursor_control cs(false);</a>
<a name="ln1459"> </a>
<a name="ln1460">        int flash_colour = you.flash_colour;</a>
<a name="ln1461">        if (flash_colour == BLACK)</a>
<a name="ln1462">            flash_colour = viewmap_flash_colour();</a>
<a name="ln1463"> </a>
<a name="ln1464">        const coord_def tl = coord_def(1, 1);</a>
<a name="ln1465">        const coord_def br = crawl_view.viewsz;</a>
<a name="ln1466">        for (rectangle_iterator ri(tl, br); ri; ++ri)</a>
<a name="ln1467">        {</a>
<a name="ln1468">            // in grid coords</a>
<a name="ln1469">            const coord_def gc = a</a>
<a name="ln1470">                ? a-&gt;cell_cb(view2grid(*ri), flash_colour)</a>
<a name="ln1471">                : view2grid(*ri);</a>
<a name="ln1472"> </a>
<a name="ln1473">            if (you.flash_where &amp;&amp; you.flash_where-&gt;is_affected(gc) &lt;= 0)</a>
<a name="ln1474">                draw_cell(cell, gc, anim_updates, 0);</a>
<a name="ln1475">            else</a>
<a name="ln1476">                draw_cell(cell, gc, anim_updates, flash_colour);</a>
<a name="ln1477"> </a>
<a name="ln1478">            cell++;</a>
<a name="ln1479">        }</a>
<a name="ln1480"> </a>
<a name="ln1481">        you.last_view_update = you.num_turns;</a>
<a name="ln1482">#ifndef USE_TILE_LOCAL</a>
<a name="ln1483">        if (!tiles_only)</a>
<a name="ln1484">        {</a>
<a name="ln1485">            puttext(crawl_view.viewp.x, crawl_view.viewp.y, crawl_view.vbuf);</a>
<a name="ln1486">            update_monster_pane();</a>
<a name="ln1487">        }</a>
<a name="ln1488">#else</a>
<a name="ln1489">        UNUSED(tiles_only);</a>
<a name="ln1490">#endif</a>
<a name="ln1491">#ifdef USE_TILE</a>
<a name="ln1492">        tiles.set_need_redraw(you.running ? Options.tile_runrest_rate : 0);</a>
<a name="ln1493">        tiles.load_dungeon(crawl_view.vbuf, crawl_view.vgrdc);</a>
<a name="ln1494">        tiles.update_tabs();</a>
<a name="ln1495">#endif</a>
<a name="ln1496"> </a>
<a name="ln1497">        // Leaving it this way because short flashes can occur in long ones,</a>
<a name="ln1498">        // and this simply works without requiring a stack.</a>
<a name="ln1499">        you.flash_colour = BLACK;</a>
<a name="ln1500">        you.flash_where = 0;</a>
<a name="ln1501"> </a>
<a name="ln1502">        // Reset env.show if we munged it.</a>
<a name="ln1503">        if (_layers != LAYERS_ALL)</a>
<a name="ln1504">            show_init();</a>
<a name="ln1505">    }</a>
<a name="ln1506">}</a>
<a name="ln1507"> </a>
<a name="ln1508">void draw_cell(screen_cell_t *cell, const coord_def &amp;gc,</a>
<a name="ln1509">               bool anim_updates, int flash_colour)</a>
<a name="ln1510">{</a>
<a name="ln1511">#ifdef USE_TILE</a>
<a name="ln1512">    cell-&gt;tile.clear();</a>
<a name="ln1513">#endif</a>
<a name="ln1514">    const coord_def ep = grid2show(gc);</a>
<a name="ln1515"> </a>
<a name="ln1516">    if (!map_bounds(gc))</a>
<a name="ln1517">        _draw_out_of_bounds(cell);</a>
<a name="ln1518">    else if (!crawl_view.in_los_bounds_g(gc))</a>
<a name="ln1519">        _draw_outside_los(cell, gc, coord_def());</a>
<a name="ln1520">    else if (gc == you.pos() &amp;&amp; you.on_current_level</a>
<a name="ln1521">             &amp;&amp; _layers &amp; LAYER_PLAYER</a>
<a name="ln1522">             &amp;&amp; !crawl_state.game_is_arena()</a>
<a name="ln1523">             &amp;&amp; !crawl_state.arena_suspended)</a>
<a name="ln1524">    {</a>
<a name="ln1525">        _draw_player(cell, gc, ep, anim_updates);</a>
<a name="ln1526">    }</a>
<a name="ln1527">    else if (you.see_cell(gc) &amp;&amp; you.on_current_level)</a>
<a name="ln1528">        _draw_los(cell, gc, ep, anim_updates);</a>
<a name="ln1529">    else</a>
<a name="ln1530">        _draw_outside_los(cell, gc, ep); // in los bounds but not visible</a>
<a name="ln1531"> </a>
<a name="ln1532">#ifdef USE_TILE</a>
<a name="ln1533">    cell-&gt;tile.map_knowledge = map_bounds(gc) ? env.map_knowledge(gc) : map_cell();</a>
<a name="ln1534">#endif</a>
<a name="ln1535"> </a>
<a name="ln1536">    cell-&gt;flash_colour = BLACK;</a>
<a name="ln1537"> </a>
<a name="ln1538">    // Don't hide important information by recolouring monsters.</a>
<a name="ln1539">    bool allow_mon_recolour = query_map_knowledge(true, gc, [](const map_cell&amp; m) {</a>
<a name="ln1540">        return m.monster() == MONS_NO_MONSTER || mons_class_is_firewood(m.monster());</a>
<a name="ln1541">    });</a>
<a name="ln1542"> </a>
<a name="ln1543">    // Is this cell excluded from movement by mesmerise-related statuses?</a>
<a name="ln1544">    // MAP_WITHHELD is set in `show.cc:_update_feat_at`.</a>
<a name="ln1545">    bool mesmerise_excluded = (gc != you.pos() // for fungus form</a>
<a name="ln1546">                               &amp;&amp; allow_mon_recolour</a>
<a name="ln1547">                               &amp;&amp; map_bounds(gc)</a>
<a name="ln1548">                               &amp;&amp; you.on_current_level</a>
<a name="ln1549">                               &amp;&amp; (env.map_knowledge(gc).flags &amp; MAP_WITHHELD)</a>
<a name="ln1550">                               &amp;&amp; !feat_is_solid(grd(gc)));</a>
<a name="ln1551"> </a>
<a name="ln1552">    // Alter colour if flashing the characters vision.</a>
<a name="ln1553">    if (flash_colour)</a>
<a name="ln1554">    {</a>
<a name="ln1555">        if (!you.see_cell(gc))</a>
<a name="ln1556">            cell-&gt;colour = DARKGREY;</a>
<a name="ln1557">#ifdef USE_TILE_LOCAL</a>
<a name="ln1558">        else</a>
<a name="ln1559">            cell-&gt;colour = real_colour(flash_colour);</a>
<a name="ln1560">#else</a>
<a name="ln1561">        else if (gc != you.pos() &amp;&amp; allow_mon_recolour)</a>
<a name="ln1562">            cell-&gt;colour = real_colour(flash_colour);</a>
<a name="ln1563">#endif</a>
<a name="ln1564">        cell-&gt;flash_colour = cell-&gt;colour;</a>
<a name="ln1565">    }</a>
<a name="ln1566">    else if (crawl_state.darken_range)</a>
<a name="ln1567">    {</a>
<a name="ln1568">        if ((crawl_state.darken_range-&gt;obeys_mesmerise &amp;&amp; mesmerise_excluded)</a>
<a name="ln1569">            || (!crawl_state.darken_range-&gt;valid_aim(gc)))</a>
<a name="ln1570">        {</a>
<a name="ln1571">            cell-&gt;colour = DARKGREY;</a>
<a name="ln1572">#ifdef USE_TILE</a>
<a name="ln1573">            if (you.see_cell(gc))</a>
<a name="ln1574">                cell-&gt;tile.bg |= TILE_FLAG_OOR;</a>
<a name="ln1575">#endif</a>
<a name="ln1576">        }</a>
<a name="ln1577">    }</a>
<a name="ln1578">    else if (crawl_state.flash_monsters)</a>
<a name="ln1579">    {</a>
<a name="ln1580">        bool found = gc == you.pos();</a>
<a name="ln1581"> </a>
<a name="ln1582">        if (!found)</a>
<a name="ln1583">            for (auto mon : *crawl_state.flash_monsters)</a>
<a name="ln1584">            {</a>
<a name="ln1585">                if (gc == mon-&gt;pos())</a>
<a name="ln1586">                {</a>
<a name="ln1587">                    found = true;</a>
<a name="ln1588">                    break;</a>
<a name="ln1589">                }</a>
<a name="ln1590">            }</a>
<a name="ln1591"> </a>
<a name="ln1592">        if (!found)</a>
<a name="ln1593">            cell-&gt;colour = DARKGREY;</a>
<a name="ln1594">    }</a>
<a name="ln1595">    else if (mesmerise_excluded) // but no range limits in place</a>
<a name="ln1596">    {</a>
<a name="ln1597">        cell-&gt;colour = DARKGREY;</a>
<a name="ln1598"> </a>
<a name="ln1599">#ifdef USE_TILE_LOCAL</a>
<a name="ln1600">        cell-&gt;tile.bg |= TILE_FLAG_OOR;</a>
<a name="ln1601">#elif defined(USE_TILE_WEB)</a>
<a name="ln1602">        // For webtiles, we only grey out visible tiles</a>
<a name="ln1603">        if (you.see_cell(gc))</a>
<a name="ln1604">            cell-&gt;tile.bg |= TILE_FLAG_OOR;</a>
<a name="ln1605">#endif</a>
<a name="ln1606">    }</a>
<a name="ln1607"> </a>
<a name="ln1608">#ifdef USE_TILE</a>
<a name="ln1609">    tile_apply_properties(gc, cell-&gt;tile);</a>
<a name="ln1610">#endif</a>
<a name="ln1611"> </a>
<a name="ln1612">#ifndef USE_TILE_LOCAL</a>
<a name="ln1613">    if ((_layers != LAYERS_ALL || Options.always_show_exclusions)</a>
<a name="ln1614">        &amp;&amp; you.on_current_level</a>
<a name="ln1615">        &amp;&amp; map_bounds(gc)</a>
<a name="ln1616">        &amp;&amp; (_layers == LAYERS_NONE</a>
<a name="ln1617">            || gc != you.pos()</a>
<a name="ln1618">               &amp;&amp; (env.map_knowledge(gc).monster() == MONS_NO_MONSTER</a>
<a name="ln1619">                   || !you.see_cell(gc)))</a>
<a name="ln1620">        &amp;&amp; travel_colour_override(gc))</a>
<a name="ln1621">    {</a>
<a name="ln1622">        if (is_exclude_root(gc))</a>
<a name="ln1623">            cell-&gt;colour = Options.tc_excluded;</a>
<a name="ln1624">        else if (is_excluded(gc))</a>
<a name="ln1625">            cell-&gt;colour = Options.tc_exclude_circle;</a>
<a name="ln1626">    }</a>
<a name="ln1627">#endif</a>
<a name="ln1628">}</a>
<a name="ln1629"> </a>
<a name="ln1630">// Hide view layers. The player can toggle certain layers back on</a>
<a name="ln1631">// and the resulting configuration will be remembered for the</a>
<a name="ln1632">// remainder of the game session.</a>
<a name="ln1633">static void _config_layers_menu()</a>
<a name="ln1634">{</a>
<a name="ln1635">    bool exit = false;</a>
<a name="ln1636"> </a>
<a name="ln1637">    _layers = _layers_saved;</a>
<a name="ln1638">    crawl_state.viewport_weapons    = !!(_layers &amp; LAYER_MONSTER_WEAPONS);</a>
<a name="ln1639">    crawl_state.viewport_monster_hp = !!(_layers &amp; LAYER_MONSTER_HEALTH);</a>
<a name="ln1640"> </a>
<a name="ln1641">    msgwin_set_temporary(true);</a>
<a name="ln1642">    while (!exit)</a>
<a name="ln1643">    {</a>
<a name="ln1644">        viewwindow();</a>
<a name="ln1645">        mprf(MSGCH_PROMPT, &quot;Select layers to display:\n&quot;</a>
<a name="ln1646">                           &quot;&lt;%s&gt;(m)onsters&lt;/%s&gt;|&quot;</a>
<a name="ln1647">                           &quot;&lt;%s&gt;(p)layer&lt;/%s&gt;|&quot;</a>
<a name="ln1648">                           &quot;&lt;%s&gt;(i)tems&lt;/%s&gt;|&quot;</a>
<a name="ln1649">                           &quot;&lt;%s&gt;(c)louds&lt;/%s&gt;&quot;</a>
<a name="ln1650">#ifndef USE_TILE_LOCAL</a>
<a name="ln1651">                           &quot;|&quot;</a>
<a name="ln1652">                           &quot;&lt;%s&gt;monster (w)eapons&lt;/%s&gt;|&quot;</a>
<a name="ln1653">                           &quot;&lt;%s&gt;monster (h)ealth&lt;/%s&gt;&quot;</a>
<a name="ln1654">#endif</a>
<a name="ln1655">                           ,</a>
<a name="ln1656">           _layers &amp; LAYER_MONSTERS        ? &quot;lightgrey&quot; : &quot;darkgrey&quot;,</a>
<a name="ln1657">           _layers &amp; LAYER_MONSTERS        ? &quot;lightgrey&quot; : &quot;darkgrey&quot;,</a>
<a name="ln1658">           _layers &amp; LAYER_PLAYER          ? &quot;lightgrey&quot; : &quot;darkgrey&quot;,</a>
<a name="ln1659">           _layers &amp; LAYER_PLAYER          ? &quot;lightgrey&quot; : &quot;darkgrey&quot;,</a>
<a name="ln1660">           _layers &amp; LAYER_ITEMS           ? &quot;lightgrey&quot; : &quot;darkgrey&quot;,</a>
<a name="ln1661">           _layers &amp; LAYER_ITEMS           ? &quot;lightgrey&quot; : &quot;darkgrey&quot;,</a>
<a name="ln1662">           _layers &amp; LAYER_CLOUDS          ? &quot;lightgrey&quot; : &quot;darkgrey&quot;,</a>
<a name="ln1663">           _layers &amp; LAYER_CLOUDS          ? &quot;lightgrey&quot; : &quot;darkgrey&quot;</a>
<a name="ln1664">#ifndef USE_TILE_LOCAL</a>
<a name="ln1665">           ,</a>
<a name="ln1666">           _layers &amp; LAYER_MONSTER_WEAPONS ? &quot;lightgrey&quot; : &quot;darkgrey&quot;,</a>
<a name="ln1667">           _layers &amp; LAYER_MONSTER_WEAPONS ? &quot;lightgrey&quot; : &quot;darkgrey&quot;,</a>
<a name="ln1668">           _layers &amp; LAYER_MONSTER_HEALTH  ? &quot;lightgrey&quot; : &quot;darkgrey&quot;,</a>
<a name="ln1669">           _layers &amp; LAYER_MONSTER_HEALTH  ? &quot;lightgrey&quot; : &quot;darkgrey&quot;</a>
<a name="ln1670">#endif</a>
<a name="ln1671">        );</a>
<a name="ln1672">        mprf(MSGCH_PROMPT, &quot;Press escape to toggle all layers. &quot;</a>
<a name="ln1673">                           &quot;Press any other key to exit.&quot;);</a>
<a name="ln1674"> </a>
<a name="ln1675">        switch (get_ch())</a>
<a name="ln1676">        {</a>
<a name="ln1677">        case 'm': _layers_saved = _layers ^= LAYER_MONSTERS;        break;</a>
<a name="ln1678">        case 'p': _layers_saved = _layers ^= LAYER_PLAYER;          break;</a>
<a name="ln1679">        case 'i': _layers_saved = _layers ^= LAYER_ITEMS;           break;</a>
<a name="ln1680">        case 'c': _layers_saved = _layers ^= LAYER_CLOUDS;          break;</a>
<a name="ln1681">#ifndef USE_TILE_LOCAL</a>
<a name="ln1682">        case 'w': _layers_saved = _layers ^= LAYER_MONSTER_WEAPONS;</a>
<a name="ln1683">                  if (_layers &amp; LAYER_MONSTER_WEAPONS)</a>
<a name="ln1684">                      _layers_saved = _layers |= LAYER_MONSTERS;</a>
<a name="ln1685">                  break;</a>
<a name="ln1686">        case 'h': _layers_saved = _layers ^= LAYER_MONSTER_HEALTH;</a>
<a name="ln1687">                  if (_layers &amp; LAYER_MONSTER_HEALTH)</a>
<a name="ln1688">                      _layers_saved = _layers |= LAYER_MONSTERS;</a>
<a name="ln1689">                  break;</a>
<a name="ln1690">#endif</a>
<a name="ln1691">        CASE_ESCAPE if (_layers)</a>
<a name="ln1692">                      _layers_saved = _layers = LAYERS_NONE;</a>
<a name="ln1693">                  else</a>
<a name="ln1694">                  {</a>
<a name="ln1695">#ifndef USE_TILE_LOCAL</a>
<a name="ln1696">                      _layers_saved = _layers = LAYERS_ALL</a>
<a name="ln1697">                                      | LAYER_MONSTER_WEAPONS</a>
<a name="ln1698">                                      | LAYER_MONSTER_HEALTH;</a>
<a name="ln1699">#else</a>
<a name="ln1700">                      _layers_saved = _layers = LAYERS_ALL;</a>
<a name="ln1701">#endif</a>
<a name="ln1702">                  }</a>
<a name="ln1703">                  break;</a>
<a name="ln1704">        default:</a>
<a name="ln1705">            _layers = LAYERS_ALL;</a>
<a name="ln1706">            crawl_state.viewport_weapons    = !!(_layers &amp; LAYER_MONSTER_WEAPONS);</a>
<a name="ln1707">            crawl_state.viewport_monster_hp = !!(_layers &amp; LAYER_MONSTER_HEALTH);</a>
<a name="ln1708">            exit = true;</a>
<a name="ln1709">            break;</a>
<a name="ln1710">        }</a>
<a name="ln1711"> </a>
<a name="ln1712">        crawl_state.viewport_weapons    = !!(_layers &amp; LAYER_MONSTER_WEAPONS);</a>
<a name="ln1713">        crawl_state.viewport_monster_hp = !!(_layers &amp; LAYER_MONSTER_HEALTH);</a>
<a name="ln1714"> </a>
<a name="ln1715">        msgwin_clear_temporary();</a>
<a name="ln1716">    }</a>
<a name="ln1717">    msgwin_set_temporary(false);</a>
<a name="ln1718"> </a>
<a name="ln1719">    canned_msg(MSG_OK);</a>
<a name="ln1720">}</a>
<a name="ln1721"> </a>
<a name="ln1722">void toggle_show_terrain()</a>
<a name="ln1723">{</a>
<a name="ln1724">    if (_layers == LAYERS_ALL)</a>
<a name="ln1725">        _config_layers_menu();</a>
<a name="ln1726">    else</a>
<a name="ln1727">        reset_show_terrain();</a>
<a name="ln1728">}</a>
<a name="ln1729"> </a>
<a name="ln1730">void reset_show_terrain()</a>
<a name="ln1731">{</a>
<a name="ln1732">    if (_layers != LAYERS_ALL)</a>
<a name="ln1733">        mprf(MSGCH_PROMPT, &quot;Restoring view layers.&quot;);</a>
<a name="ln1734"> </a>
<a name="ln1735">    _layers = LAYERS_ALL;</a>
<a name="ln1736">    crawl_state.viewport_weapons    = !!(_layers &amp; LAYER_MONSTER_WEAPONS);</a>
<a name="ln1737">    crawl_state.viewport_monster_hp = !!(_layers &amp; LAYER_MONSTER_HEALTH);</a>
<a name="ln1738">}</a>
<a name="ln1739"> </a>
<a name="ln1740">////////////////////////////////////////////////////////////////////////////</a>
<a name="ln1741">// Term resize handling (generic).</a>
<a name="ln1742"> </a>
<a name="ln1743">void handle_terminal_resize()</a>
<a name="ln1744">{</a>
<a name="ln1745">    crawl_state.terminal_resized = false;</a>
<a name="ln1746"> </a>
<a name="ln1747">    if (crawl_state.terminal_resize_handler)</a>
<a name="ln1748">        (*crawl_state.terminal_resize_handler)();</a>
<a name="ln1749">    else</a>
<a name="ln1750">        crawl_view.init_geometry();</a>
<a name="ln1751"> </a>
<a name="ln1752">    redraw_screen();</a>
<a name="ln1753">}</a>

</code></pre>
<div class="balloon" rel="730"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v768/" target="_blank">V768</a> The expression 'knowledge.feat()' is of enum type. It is odd that it is used as an expression of a Boolean-type.</p></div>
<div class="balloon" rel="1033"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v560/" target="_blank">V560</a> A part of conditional expression is always true: !did_exclude.</p></div>
<div class="balloon" rel="1204"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v730/" target="_blank">V730</a> Not all members of a class are initialized inside the constructor. Consider inspecting: current_frame.</p></div>
<div class="balloon" rel="1224"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v730/" target="_blank">V730</a> Not all members of a class are initialized inside the constructor. Consider inspecting: current_frame.</p></div>

<link rel="stylesheet" href="highlight.css">
<script src="highlight.pack.js"></script>
<script src="highlightjs-line-numbers.js"></script>
<script>hljs.initHighlightingOnLoad();</script>
<script>hljs.initLineNumbersOnLoad();</script>
<script>
  $(document).ready(function() {
      $('.balloon').each(function () {
          var bl = $(this);
          var line = bl.attr('rel');
          var text = $('a[name="ln'+line+'"]').text();

          var space_count = 0;
          for(var i = 0; i<text.length; i++){
              var char = text[i];
              if((char !== ' ')&&(char !== '\t'))break;
              if(char === '\t')space_count++;
              space_count++;
          }

          bl.css('margin-left', space_count*8);
          $('a[name="ln'+line+'"]').after(bl);
      });

      window.location = window.location;
  });
</script>
</body>
</html>
