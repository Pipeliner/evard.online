
<html>
<head>

  <meta http-equiv="Content-Type" content="text/html; charset=US-ASCII" />
  <title>player.cc</title>

  <link rel="stylesheet" href="../style.css"/>
  <script src="../jquery-3.2.1.min.js"></script>
</head>
<body>

<pre><code class = "cpp">
<a name="ln1">/**</a>
<a name="ln2"> * @file</a>
<a name="ln3"> * @brief Player related functions.</a>
<a name="ln4">**/</a>
<a name="ln5"> </a>
<a name="ln6">#include &quot;AppHdr.h&quot;</a>
<a name="ln7"> </a>
<a name="ln8">#include &quot;player.h&quot;</a>
<a name="ln9"> </a>
<a name="ln10">#include &lt;algorithm&gt;</a>
<a name="ln11">#include &lt;cctype&gt;</a>
<a name="ln12">#include &lt;cmath&gt;</a>
<a name="ln13">#include &lt;cstdio&gt;</a>
<a name="ln14">#include &lt;cstdlib&gt;</a>
<a name="ln15">#include &lt;cstring&gt;</a>
<a name="ln16">#include &lt;sstream&gt;</a>
<a name="ln17"> </a>
<a name="ln18">#include &quot;ability.h&quot;</a>
<a name="ln19">#include &quot;abyss.h&quot;</a>
<a name="ln20">#include &quot;act-iter.h&quot;</a>
<a name="ln21">#include &quot;areas.h&quot;</a>
<a name="ln22">#include &quot;art-enum.h&quot;</a>
<a name="ln23">#include &quot;attack.h&quot;</a>
<a name="ln24">#include &quot;bloodspatter.h&quot;</a>
<a name="ln25">#include &quot;branch.h&quot;</a>
<a name="ln26">#include &quot;chardump.h&quot;</a>
<a name="ln27">#include &quot;cloud.h&quot;</a>
<a name="ln28">#include &quot;coordit.h&quot;</a>
<a name="ln29">#include &quot;delay.h&quot;</a>
<a name="ln30">#include &quot;dgn-overview.h&quot;</a>
<a name="ln31">#include &quot;dgn-event.h&quot;</a>
<a name="ln32">#include &quot;directn.h&quot;</a>
<a name="ln33">#include &quot;english.h&quot;</a>
<a name="ln34">#include &quot;env.h&quot;</a>
<a name="ln35">#include &quot;errors.h&quot;</a>
<a name="ln36">#include &quot;exercise.h&quot;</a>
<a name="ln37">#include &quot;files.h&quot;</a>
<a name="ln38">#include &quot;food.h&quot;</a>
<a name="ln39">#include &quot;god-abil.h&quot;</a>
<a name="ln40">#include &quot;god-conduct.h&quot;</a>
<a name="ln41">#include &quot;god-passive.h&quot;</a>
<a name="ln42">#include &quot;god-wrath.h&quot;</a>
<a name="ln43">#include &quot;hints.h&quot;</a>
<a name="ln44">#include &quot;hiscores.h&quot;</a>
<a name="ln45">#include &quot;invent.h&quot;</a>
<a name="ln46">#include &quot;item-prop.h&quot;</a>
<a name="ln47">#include &quot;items.h&quot;</a>
<a name="ln48">#include &quot;item-use.h&quot;</a>
<a name="ln49">#include &quot;kills.h&quot;</a>
<a name="ln50">#include &quot;level-state-type.h&quot;</a>
<a name="ln51">#include &quot;libutil.h&quot;</a>
<a name="ln52">#include &quot;macro.h&quot;</a>
<a name="ln53">#include &quot;melee-attack.h&quot;</a>
<a name="ln54">#include &quot;message.h&quot;</a>
<a name="ln55">#include &quot;mon-place.h&quot;</a>
<a name="ln56">#include &quot;mutation.h&quot;</a>
<a name="ln57">#include &quot;nearby-danger.h&quot;</a>
<a name="ln58">#include &quot;notes.h&quot;</a>
<a name="ln59">#include &quot;output.h&quot;</a>
<a name="ln60">#include &quot;player-equip.h&quot;</a>
<a name="ln61">#include &quot;player-save-info.h&quot;</a>
<a name="ln62">#include &quot;player-stats.h&quot;</a>
<a name="ln63">#include &quot;prompt.h&quot;</a>
<a name="ln64">#include &quot;religion.h&quot;</a>
<a name="ln65">#include &quot;shout.h&quot;</a>
<a name="ln66">#include &quot;skills.h&quot;</a>
<a name="ln67">#include &quot;species.h&quot; // random_starting_species</a>
<a name="ln68">#include &quot;spl-damage.h&quot;</a>
<a name="ln69">#include &quot;spl-selfench.h&quot;</a>
<a name="ln70">#include &quot;spl-transloc.h&quot;</a>
<a name="ln71">#include &quot;spl-util.h&quot;</a>
<a name="ln72">#include &quot;sprint.h&quot;</a>
<a name="ln73">#include &quot;stairs.h&quot;</a>
<a name="ln74">#include &quot;stash.h&quot;</a>
<a name="ln75">#include &quot;state.h&quot;</a>
<a name="ln76">#include &quot;status.h&quot;</a>
<a name="ln77">#include &quot;stepdown.h&quot;</a>
<a name="ln78">#include &quot;stringutil.h&quot;</a>
<a name="ln79">#include &quot;terrain.h&quot;</a>
<a name="ln80">#ifdef USE_TILE</a>
<a name="ln81"> #include &quot;tilepick.h&quot;</a>
<a name="ln82"> #include &quot;tileview.h&quot;</a>
<a name="ln83">#endif</a>
<a name="ln84">#include &quot;transform.h&quot;</a>
<a name="ln85">#include &quot;traps.h&quot;</a>
<a name="ln86">#include &quot;travel.h&quot;</a>
<a name="ln87">#include &quot;view.h&quot;</a>
<a name="ln88">#include &quot;wizard-option-type.h&quot;</a>
<a name="ln89">#include &quot;xom.h&quot;</a>
<a name="ln90"> </a>
<a name="ln91">static void _moveto_maybe_repel_stairs()</a>
<a name="ln92">{</a>
<a name="ln93">    const dungeon_feature_type new_grid = env.grid(you.pos());</a>
<a name="ln94">    const command_type stair_dir = feat_stair_direction(new_grid);</a>
<a name="ln95"> </a>
<a name="ln96">    if (stair_dir == CMD_NO_CMD</a>
<a name="ln97">        || new_grid == DNGN_ENTER_SHOP</a>
<a name="ln98">        ||  !you.duration[DUR_REPEL_STAIRS_MOVE])</a>
<a name="ln99">    {</a>
<a name="ln100">        return;</a>
<a name="ln101">    }</a>
<a name="ln102"> </a>
<a name="ln103">    int pct = you.duration[DUR_REPEL_STAIRS_CLIMB] ? 29 : 50;</a>
<a name="ln104"> </a>
<a name="ln105">    // When the effect is still strong, the chance to actually catch</a>
<a name="ln106">    // a stair is smaller. (Assuming the duration starts out at 1000.)</a>
<a name="ln107">    const int dur = max(0, you.duration[DUR_REPEL_STAIRS_MOVE] - 700);</a>
<a name="ln108">    pct += dur/10;</a>
<a name="ln109"> </a>
<a name="ln110">    if (x_chance_in_y(pct, 100))</a>
<a name="ln111">    {</a>
<a name="ln112">        const string stair_str = feature_description_at(you.pos(), false,</a>
<a name="ln113">                                                        DESC_THE);</a>
<a name="ln114">        const string prep = feat_preposition(new_grid, true, &amp;you);</a>
<a name="ln115"> </a>
<a name="ln116">        if (slide_feature_over(you.pos()))</a>
<a name="ln117">        {</a>
<a name="ln118">            mprf(&quot;%s slides away as you move %s it!&quot;, stair_str.c_str(),</a>
<a name="ln119">                 prep.c_str());</a>
<a name="ln120"> </a>
<a name="ln121">            if (player_in_a_dangerous_place() &amp;&amp; one_chance_in(5))</a>
<a name="ln122">                xom_is_stimulated(25);</a>
<a name="ln123">        }</a>
<a name="ln124">    }</a>
<a name="ln125">}</a>
<a name="ln126"> </a>
<a name="ln127">bool check_moveto_cloud(const coord_def&amp; p, const string &amp;move_verb,</a>
<a name="ln128">                        bool *prompted)</a>
<a name="ln129">{</a>
<a name="ln130">    if (you.confused())</a>
<a name="ln131">        return true;</a>
<a name="ln132"> </a>
<a name="ln133">    const cloud_type ctype = env.map_knowledge(p).cloud();</a>
<a name="ln134">    // Don't prompt if already in a cloud of the same type.</a>
<a name="ln135">    if (is_damaging_cloud(ctype, true, cloud_is_yours_at(p))</a>
<a name="ln136">        &amp;&amp; ctype != cloud_type_at(you.pos())</a>
<a name="ln137">        &amp;&amp; !crawl_state.disables[DIS_CONFIRMATIONS])</a>
<a name="ln138">    {</a>
<a name="ln139">        // Don't prompt for steam unless we're at uncomfortably low hp.</a>
<a name="ln140">        if (ctype == CLOUD_STEAM)</a>
<a name="ln141">        {</a>
<a name="ln142">            int threshold = 20;</a>
<a name="ln143">            if (player_res_steam() &lt; 0)</a>
<a name="ln144">                threshold = threshold * 3 / 2;</a>
<a name="ln145">            threshold = threshold * you.time_taken / BASELINE_DELAY;</a>
<a name="ln146">            // Do prompt if we'd lose icemail, though.</a>
<a name="ln147">            if (you.hp &gt; threshold &amp;&amp; !you.has_mutation(MUT_ICEMAIL))</a>
<a name="ln148">                return true;</a>
<a name="ln149">        }</a>
<a name="ln150">        // Don't prompt for meph if we have clarity, unless at very low HP.</a>
<a name="ln151">        if (ctype == CLOUD_MEPHITIC &amp;&amp; you.clarity(false)</a>
<a name="ln152">            &amp;&amp; you.hp &gt; 2 * you.time_taken / BASELINE_DELAY)</a>
<a name="ln153">        {</a>
<a name="ln154">            return true;</a>
<a name="ln155">        }</a>
<a name="ln156"> </a>
<a name="ln157">        if (prompted)</a>
<a name="ln158">            *prompted = true;</a>
<a name="ln159">        string prompt = make_stringf(&quot;Really %s into that cloud of %s?&quot;,</a>
<a name="ln160">                                     move_verb.c_str(),</a>
<a name="ln161">                                     cloud_type_name(ctype).c_str());</a>
<a name="ln162">        learned_something_new(HINT_CLOUD_WARNING);</a>
<a name="ln163"> </a>
<a name="ln164">        if (!yesno(prompt.c_str(), false, 'n'))</a>
<a name="ln165">        {</a>
<a name="ln166">            canned_msg(MSG_OK);</a>
<a name="ln167">            return false;</a>
<a name="ln168">        }</a>
<a name="ln169">    }</a>
<a name="ln170">    return true;</a>
<a name="ln171">}</a>
<a name="ln172"> </a>
<a name="ln173">bool check_moveto_trap(const coord_def&amp; p, const string &amp;move_verb,</a>
<a name="ln174">                       bool *prompted)</a>
<a name="ln175">{</a>
<a name="ln176">    // Boldly go into the unknown (for shadow step and other ranged move</a>
<a name="ln177">    // prompts)</a>
<a name="ln178">    if (env.map_knowledge(p).trap() == TRAP_UNASSIGNED)</a>
<a name="ln179">        return true;</a>
<a name="ln180"> </a>
<a name="ln181">    // If there's no trap, let's go.</a>
<a name="ln182">    trap_def* trap = trap_at(p);</a>
<a name="ln183">    if (!trap)</a>
<a name="ln184">        return true;</a>
<a name="ln185"> </a>
<a name="ln186">    if (trap-&gt;type == TRAP_ZOT &amp;&amp; !trap-&gt;is_safe() &amp;&amp; !crawl_state.disables[DIS_CONFIRMATIONS])</a>
<a name="ln187">    {</a>
<a name="ln188">        string msg = &quot;Do you really want to %s into the Zot trap?&quot;;</a>
<a name="ln189">        string prompt = make_stringf(msg.c_str(), move_verb.c_str());</a>
<a name="ln190"> </a>
<a name="ln191">        if (prompted)</a>
<a name="ln192">            *prompted = true;</a>
<a name="ln193">        if (!yes_or_no(&quot;%s&quot;, prompt.c_str()))</a>
<a name="ln194">        {</a>
<a name="ln195">            canned_msg(MSG_OK);</a>
<a name="ln196">            return false;</a>
<a name="ln197">        }</a>
<a name="ln198">    }</a>
<a name="ln199">    else if (!trap-&gt;is_safe() &amp;&amp; !crawl_state.disables[DIS_CONFIRMATIONS])</a>
<a name="ln200">    {</a>
<a name="ln201">        string prompt;</a>
<a name="ln202"> </a>
<a name="ln203">        if (prompted)</a>
<a name="ln204">            *prompted = true;</a>
<a name="ln205">        prompt = make_stringf(&quot;Really %s %s that %s?&quot;, move_verb.c_str(),</a>
<a name="ln206">                              (trap-&gt;type == TRAP_ALARM</a>
<a name="ln207">                               || trap-&gt;type == TRAP_PLATE) ? &quot;onto&quot;</a>
<a name="ln208">                              : &quot;into&quot;,</a>
<a name="ln209">                              feature_description_at(p, false, DESC_BASENAME).c_str());</a>
<a name="ln210">        if (!yesno(prompt.c_str(), true, 'n'))</a>
<a name="ln211">        {</a>
<a name="ln212">            canned_msg(MSG_OK);</a>
<a name="ln213">            return false;</a>
<a name="ln214">        }</a>
<a name="ln215">    }</a>
<a name="ln216">    return true;</a>
<a name="ln217">}</a>
<a name="ln218"> </a>
<a name="ln219">static bool _check_moveto_dangerous(const coord_def&amp; p, const string&amp; msg)</a>
<a name="ln220">{</a>
<a name="ln221">    if (you.can_swim() &amp;&amp; feat_is_water(env.grid(p))</a>
<a name="ln222">        || you.airborne() || !is_feat_dangerous(env.grid(p)))</a>
<a name="ln223">    {</a>
<a name="ln224">        return true;</a>
<a name="ln225">    }</a>
<a name="ln226"> </a>
<a name="ln227">    if (!msg.empty())</a>
<a name="ln228">        mpr(msg);</a>
<a name="ln229">    else if (species_likes_water(you.species) &amp;&amp; feat_is_water(env.grid(p)))</a>
<a name="ln230">        mpr(&quot;You cannot enter water in your current form.&quot;);</a>
<a name="ln231">    else</a>
<a name="ln232">        canned_msg(MSG_UNTHINKING_ACT);</a>
<a name="ln233">    return false;</a>
<a name="ln234">}</a>
<a name="ln235"> </a>
<a name="ln236">bool check_moveto_terrain(const coord_def&amp; p, const string &amp;move_verb,</a>
<a name="ln237">                          const string &amp;msg, bool *prompted)</a>
<a name="ln238">{</a>
<a name="ln239">    // Boldly go into the unknown (for shadow step and other ranged move</a>
<a name="ln240">    // prompts)</a>
<a name="ln241">    if (!env.map_knowledge(p).known())</a>
<a name="ln242">        return true;</a>
<a name="ln243"> </a>
<a name="ln244">    if (!_check_moveto_dangerous(p, msg))</a>
<a name="ln245">        return false;</a>
<a name="ln246">    if (!you.airborne() &amp;&amp; env.grid(you.pos()) != DNGN_TOXIC_BOG</a>
<a name="ln247">        &amp;&amp; env.grid(p) == DNGN_TOXIC_BOG)</a>
<a name="ln248">    {</a>
<a name="ln249">        string prompt;</a>
<a name="ln250"> </a>
<a name="ln251">        if (prompted)</a>
<a name="ln252">            *prompted = true;</a>
<a name="ln253"> </a>
<a name="ln254">        if (!msg.empty())</a>
<a name="ln255">            prompt = msg + &quot; &quot;;</a>
<a name="ln256"> </a>
<a name="ln257">        prompt += &quot;Are you sure you want to &quot; + move_verb</a>
<a name="ln258">                + &quot; into a toxic bog?&quot;;</a>
<a name="ln259"> </a>
<a name="ln260">        if (!yesno(prompt.c_str(), false, 'n'))</a>
<a name="ln261">        {</a>
<a name="ln262">            canned_msg(MSG_OK);</a>
<a name="ln263">            return false;</a>
<a name="ln264">        }</a>
<a name="ln265">    }</a>
<a name="ln266">    if (!need_expiration_warning() &amp;&amp; need_expiration_warning(p)</a>
<a name="ln267">        &amp;&amp; !crawl_state.disables[DIS_CONFIRMATIONS])</a>
<a name="ln268">    {</a>
<a name="ln269">        string prompt;</a>
<a name="ln270"> </a>
<a name="ln271">        if (prompted)</a>
<a name="ln272">            *prompted = true;</a>
<a name="ln273"> </a>
<a name="ln274">        if (!msg.empty())</a>
<a name="ln275">            prompt = msg + &quot; &quot;;</a>
<a name="ln276"> </a>
<a name="ln277">        prompt += &quot;Are you sure you want to &quot; + move_verb;</a>
<a name="ln278"> </a>
<a name="ln279">        if (you.ground_level())</a>
<a name="ln280">            prompt += &quot; into &quot;;</a>
<a name="ln281">        else</a>
<a name="ln282">            prompt += &quot; over &quot;;</a>
<a name="ln283"> </a>
<a name="ln284">        prompt += env.grid(p) == DNGN_DEEP_WATER ? &quot;deep water&quot; : &quot;lava&quot;;</a>
<a name="ln285"> </a>
<a name="ln286">        prompt += need_expiration_warning(DUR_FLIGHT, p)</a>
<a name="ln287">            ? &quot; while you are losing your buoyancy?&quot;</a>
<a name="ln288">            : &quot; while your transformation is expiring?&quot;;</a>
<a name="ln289"> </a>
<a name="ln290">        if (!yesno(prompt.c_str(), false, 'n'))</a>
<a name="ln291">        {</a>
<a name="ln292">            canned_msg(MSG_OK);</a>
<a name="ln293">            return false;</a>
<a name="ln294">        }</a>
<a name="ln295">    }</a>
<a name="ln296">    return true;</a>
<a name="ln297">}</a>
<a name="ln298"> </a>
<a name="ln299">bool check_moveto_exclusions(const vector&lt;coord_def&gt; &amp;areas,</a>
<a name="ln300">                             const string &amp;move_verb,</a>
<a name="ln301">                             bool *prompted)</a>
<a name="ln302">{</a>
<a name="ln303">    const bool you_pos_excluded = is_excluded(you.pos())</a>
<a name="ln304">            &amp;&amp; !is_stair_exclusion(you.pos());</a>
<a name="ln305">    if (you_pos_excluded || crawl_state.disables[DIS_CONFIRMATIONS])</a>
<a name="ln306">        return true;</a>
<a name="ln307"> </a>
<a name="ln308">    int count = 0;</a>
<a name="ln309">    for (auto p : areas)</a>
<a name="ln310">    {</a>
<a name="ln311">        if (is_excluded(p) &amp;&amp; !is_stair_exclusion(p))</a>
<a name="ln312">            count++;</a>
<a name="ln313">    }</a>
<a name="ln314">    if (count == 0)</a>
<a name="ln315">        return true;</a>
<a name="ln316">    const string prompt = make_stringf((count == (int) areas.size() ?</a>
<a name="ln317">                    &quot;Really %s into a travel-excluded area?&quot; :</a>
<a name="ln318">                    &quot;You might %s into a travel-excluded area, are you sure?&quot;),</a>
<a name="ln319">                              move_verb.c_str());</a>
<a name="ln320"> </a>
<a name="ln321">    if (prompted)</a>
<a name="ln322">        *prompted = true;</a>
<a name="ln323">    if (!yesno(prompt.c_str(), false, 'n'))</a>
<a name="ln324">    {</a>
<a name="ln325">        canned_msg(MSG_OK);</a>
<a name="ln326">        return false;</a>
<a name="ln327">    }</a>
<a name="ln328">    return true;</a>
<a name="ln329">}</a>
<a name="ln330"> </a>
<a name="ln331">bool check_moveto_exclusion(const coord_def&amp; p, const string &amp;move_verb,</a>
<a name="ln332">                            bool *prompted)</a>
<a name="ln333">{</a>
<a name="ln334">    return check_moveto_exclusions({p}, move_verb, prompted);</a>
<a name="ln335">}</a>
<a name="ln336"> </a>
<a name="ln337">bool check_moveto(const coord_def&amp; p, const string &amp;move_verb, const string &amp;msg)</a>
<a name="ln338">{</a>
<a name="ln339">    return check_moveto_terrain(p, move_verb, msg)</a>
<a name="ln340">           &amp;&amp; check_moveto_cloud(p, move_verb)</a>
<a name="ln341">           &amp;&amp; check_moveto_trap(p, move_verb)</a>
<a name="ln342">           &amp;&amp; check_moveto_exclusion(p, move_verb);</a>
<a name="ln343">}</a>
<a name="ln344"> </a>
<a name="ln345">// Returns true if this is a valid swap for this monster. If true, then</a>
<a name="ln346">// the valid location is set in loc. (Otherwise loc becomes garbage.)</a>
<a name="ln347">bool swap_check(monster* mons, coord_def &amp;loc, bool quiet)</a>
<a name="ln348">{</a>
<a name="ln349">    loc = you.pos();</a>
<a name="ln350"> </a>
<a name="ln351">    if (you.is_stationary())</a>
<a name="ln352">        return false;</a>
<a name="ln353"> </a>
<a name="ln354">    // Don't move onto dangerous terrain.</a>
<a name="ln355">    if (is_feat_dangerous(grd(mons-&gt;pos())))</a>
<a name="ln356">    {</a>
<a name="ln357">        canned_msg(MSG_UNTHINKING_ACT);</a>
<a name="ln358">        return false;</a>
<a name="ln359">    }</a>
<a name="ln360"> </a>
<a name="ln361">    if (mons_is_projectile(*mons))</a>
<a name="ln362">    {</a>
<a name="ln363">        if (!quiet)</a>
<a name="ln364">            mpr(&quot;It's unwise to walk into this.&quot;);</a>
<a name="ln365">        return false;</a>
<a name="ln366">    }</a>
<a name="ln367"> </a>
<a name="ln368">    if (mons-&gt;caught())</a>
<a name="ln369">    {</a>
<a name="ln370">        if (!quiet)</a>
<a name="ln371">        {</a>
<a name="ln372">            simple_monster_message(*mons,</a>
<a name="ln373">                make_stringf(&quot; is %s!&quot;, held_status(mons)).c_str());</a>
<a name="ln374">        }</a>
<a name="ln375">        return false;</a>
<a name="ln376">    }</a>
<a name="ln377"> </a>
<a name="ln378">    if (mons-&gt;is_constricted())</a>
<a name="ln379">    {</a>
<a name="ln380">        if (!quiet)</a>
<a name="ln381">            simple_monster_message(*mons, &quot; is being constricted!&quot;);</a>
<a name="ln382">        return false;</a>
<a name="ln383">    }</a>
<a name="ln384"> </a>
<a name="ln385">    if (mons-&gt;is_stationary() || mons-&gt;asleep() || mons-&gt;cannot_move())</a>
<a name="ln386">    {</a>
<a name="ln387">        if (!quiet)</a>
<a name="ln388">            simple_monster_message(*mons, &quot; cannot move out of your way!&quot;);</a>
<a name="ln389">        return false;</a>
<a name="ln390">    }</a>
<a name="ln391"> </a>
<a name="ln392">    // prompt when swapping into known zot traps</a>
<a name="ln393">    if (!quiet &amp;&amp; trap_at(loc) &amp;&amp; trap_at(loc)-&gt;type == TRAP_ZOT</a>
<a name="ln394">        &amp;&amp; !yes_or_no(&quot;Do you really want to swap %s into the Zot trap?&quot;,</a>
<a name="ln395">                      mons-&gt;name(DESC_YOUR).c_str()))</a>
<a name="ln396">    {</a>
<a name="ln397">        return false;</a>
<a name="ln398">    }</a>
<a name="ln399"> </a>
<a name="ln400">    // First try: move monster onto your position.</a>
<a name="ln401">    bool swap = !monster_at(loc) &amp;&amp; monster_habitable_grid(mons, grd(loc));</a>
<a name="ln402"> </a>
<a name="ln403">    if (monster_at(loc)</a>
<a name="ln404">        &amp;&amp; monster_at(loc)-&gt;type == MONS_TOADSTOOL</a>
<a name="ln405">        &amp;&amp; mons-&gt;type == MONS_WANDERING_MUSHROOM)</a>
<a name="ln406">    {</a>
<a name="ln407">        swap = monster_habitable_grid(mons, grd(loc));</a>
<a name="ln408">    }</a>
<a name="ln409"> </a>
<a name="ln410">    // Choose an appropriate habitat square at random around the target.</a>
<a name="ln411">    if (!swap)</a>
<a name="ln412">    {</a>
<a name="ln413">        int num_found = 0;</a>
<a name="ln414"> </a>
<a name="ln415">        for (adjacent_iterator ai(mons-&gt;pos()); ai; ++ai)</a>
<a name="ln416">            if (!monster_at(*ai) &amp;&amp; monster_habitable_grid(mons, grd(*ai))</a>
<a name="ln417">                &amp;&amp; one_chance_in(++num_found))</a>
<a name="ln418">            {</a>
<a name="ln419">                loc = *ai;</a>
<a name="ln420">            }</a>
<a name="ln421"> </a>
<a name="ln422">        if (num_found)</a>
<a name="ln423">            swap = true;</a>
<a name="ln424">    }</a>
<a name="ln425"> </a>
<a name="ln426">    if (!swap &amp;&amp; !quiet)</a>
<a name="ln427">    {</a>
<a name="ln428">        // Might not be ideal, but it's better than insta-killing</a>
<a name="ln429">        // the monster... maybe try for a short blink instead? - bwr</a>
<a name="ln430">        simple_monster_message(*mons, &quot; cannot make way for you.&quot;);</a>
<a name="ln431">        // FIXME: activity_interrupt::hit_monster isn't ideal.</a>
<a name="ln432">        interrupt_activity(activity_interrupt::hit_monster, mons);</a>
<a name="ln433">    }</a>
<a name="ln434"> </a>
<a name="ln435">    return swap;</a>
<a name="ln436">}</a>
<a name="ln437"> </a>
<a name="ln438">static void _splash()</a>
<a name="ln439">{</a>
<a name="ln440">    if (you.can_swim())</a>
<a name="ln441">        noisy(4, you.pos(), &quot;Floosh!&quot;);</a>
<a name="ln442">    else if (!you.can_water_walk())</a>
<a name="ln443">        noisy(8, you.pos(), &quot;Splash!&quot;);</a>
<a name="ln444">}</a>
<a name="ln445"> </a>
<a name="ln446">void moveto_location_effects(dungeon_feature_type old_feat,</a>
<a name="ln447">                             bool stepped, const coord_def&amp; old_pos)</a>
<a name="ln448">{</a>
<a name="ln449">    const dungeon_feature_type new_grid = env.grid(you.pos());</a>
<a name="ln450"> </a>
<a name="ln451">    // Terrain effects.</a>
<a name="ln452">    if (is_feat_dangerous(new_grid))</a>
<a name="ln453">        fall_into_a_pool(new_grid);</a>
<a name="ln454"> </a>
<a name="ln455">    // called after fall_into_a_pool, in case of emergency untransform</a>
<a name="ln456">    if (you.species == SP_MERFOLK)</a>
<a name="ln457">        merfolk_check_swimming(stepped);</a>
<a name="ln458"> </a>
<a name="ln459">    if (you.ground_level())</a>
<a name="ln460">    {</a>
<a name="ln461">        if (feat_is_water(new_grid))</a>
<a name="ln462">        {</a>
<a name="ln463">            if (!stepped)</a>
<a name="ln464">                _splash();</a>
<a name="ln465"> </a>
<a name="ln466">            if (!you.can_swim() &amp;&amp; !you.can_water_walk())</a>
<a name="ln467">            {</a>
<a name="ln468">                if (!feat_is_water(old_feat))</a>
<a name="ln469">                {</a>
<a name="ln470">                    if (new_grid == DNGN_TOXIC_BOG)</a>
<a name="ln471">                    {</a>
<a name="ln472">                        mprf(&quot;You %s the toxic bog.&quot;,</a>
<a name="ln473">                                stepped ? &quot;enter&quot; : &quot;fall into&quot;);</a>
<a name="ln474">                    }</a>
<a name="ln475">                    else</a>
<a name="ln476">                    {</a>
<a name="ln477">                        mprf(&quot;You %s the %s water.&quot;,</a>
<a name="ln478">                             stepped ? &quot;enter&quot; : &quot;fall into&quot;,</a>
<a name="ln479">                             new_grid == DNGN_SHALLOW_WATER ? &quot;shallow&quot;</a>
<a name="ln480">                             : &quot;deep&quot;);</a>
<a name="ln481">                    }</a>
<a name="ln482">                }</a>
<a name="ln483"> </a>
<a name="ln484">                if (new_grid == DNGN_DEEP_WATER &amp;&amp; old_feat != DNGN_DEEP_WATER)</a>
<a name="ln485">                    mpr(&quot;You sink to the bottom.&quot;);</a>
<a name="ln486"> </a>
<a name="ln487">                if (!feat_is_water(old_feat))</a>
<a name="ln488">                {</a>
<a name="ln489">                    mpr(&quot;Moving in this stuff is going to be slow.&quot;);</a>
<a name="ln490">                    if (you.invisible())</a>
<a name="ln491">                        mpr(&quot;...and don't expect to remain undetected.&quot;);</a>
<a name="ln492">                }</a>
<a name="ln493">            }</a>
<a name="ln494"> </a>
<a name="ln495">            if (you.species == SP_OCTOPODE</a>
<a name="ln496">                &amp;&amp; !feat_is_water(old_feat)</a>
<a name="ln497">                &amp;&amp; you.invisible())</a>
<a name="ln498">            {</a>
<a name="ln499">                mpr(&quot;Don't expect to remain undetected while in the water.&quot;);</a>
<a name="ln500">            }</a>
<a name="ln501">        }</a>
<a name="ln502">        else if (you.props.exists(TEMP_WATERWALK_KEY))</a>
<a name="ln503">            you.props.erase(TEMP_WATERWALK_KEY);</a>
<a name="ln504">    }</a>
<a name="ln505"> </a>
<a name="ln506">    id_floor_items();</a>
<a name="ln507"> </a>
<a name="ln508">    // Falling into a toxic bog, take the damage</a>
<a name="ln509">    if (old_pos == you.pos() &amp;&amp; stepped)</a>
<a name="ln510">        actor_apply_toxic_bog(&amp;you);</a>
<a name="ln511"> </a>
<a name="ln512">    // Traps go off.</a>
<a name="ln513">    // (But not when losing flight - i.e., moving into the same tile)</a>
<a name="ln514">    trap_def* ptrap = trap_at(you.pos());</a>
<a name="ln515">    if (ptrap &amp;&amp; old_pos != you.pos())</a>
<a name="ln516">        ptrap-&gt;trigger(you);</a>
<a name="ln517"> </a>
<a name="ln518">    if (stepped)</a>
<a name="ln519">        _moveto_maybe_repel_stairs();</a>
<a name="ln520">}</a>
<a name="ln521"> </a>
<a name="ln522">// Use this function whenever the player enters (or lands and thus re-enters)</a>
<a name="ln523">// a grid.</a>
<a name="ln524">//</a>
<a name="ln525">// stepped     - normal walking moves</a>
<a name="ln526">void move_player_to_grid(const coord_def&amp; p, bool stepped)</a>
<a name="ln527">{</a>
<a name="ln528">    ASSERT(!crawl_state.game_is_arena());</a>
<a name="ln529">    ASSERT_IN_BOUNDS(p);</a>
<a name="ln530"> </a>
<a name="ln531">    if (!stepped)</a>
<a name="ln532">        tornado_move(p);</a>
<a name="ln533"> </a>
<a name="ln534">    // assuming that entering the same square means coming from above (flight)</a>
<a name="ln535">    const coord_def old_pos = you.pos();</a>
<a name="ln536">    const bool from_above = (old_pos == p);</a>
<a name="ln537">    const dungeon_feature_type old_grid =</a>
<a name="ln538">        (from_above) ? DNGN_FLOOR : grd(old_pos);</a>
<a name="ln539"> </a>
<a name="ln540">    // Really must be clear.</a>
<a name="ln541">    ASSERT(you.can_pass_through_feat(grd(p)));</a>
<a name="ln542"> </a>
<a name="ln543">    // Better not be an unsubmerged monster either.</a>
<a name="ln544">    ASSERT(!monster_at(p) || monster_at(p)-&gt;submerged()</a>
<a name="ln545">           || fedhas_passthrough(monster_at(p))</a>
<a name="ln546">           || mons_is_player_shadow(*monster_at(p)));</a>
<a name="ln547"> </a>
<a name="ln548">    // Move the player to new location.</a>
<a name="ln549">    you.moveto(p, true);</a>
<a name="ln550">    viewwindow();</a>
<a name="ln551"> </a>
<a name="ln552">    moveto_location_effects(old_grid, stepped, old_pos);</a>
<a name="ln553">}</a>
<a name="ln554"> </a>
<a name="ln555"> </a>
<a name="ln556">/**</a>
<a name="ln557"> * Check if the given terrain feature is safe for the player to move into.</a>
<a name="ln558"> * (Or, at least, not instantly lethal.)</a>
<a name="ln559"> *</a>
<a name="ln560"> * @param grid          The type of terrain feature under consideration.</a>
<a name="ln561"> * @param permanently   Whether to disregard temporary effects (non-permanent</a>
<a name="ln562"> *                      flight, forms, etc)</a>
<a name="ln563"> * @param ignore_flight Whether to ignore all forms of flight (including</a>
<a name="ln564"> *                      permanent flight)</a>
<a name="ln565"> * @return              Whether the terrain is safe.</a>
<a name="ln566"> */</a>
<a name="ln567">bool is_feat_dangerous(dungeon_feature_type grid, bool permanently,</a>
<a name="ln568">                       bool ignore_flight)</a>
<a name="ln569">{</a>
<a name="ln570">    if (!ignore_flight</a>
<a name="ln571">        &amp;&amp; (you.permanent_flight() || you.airborne() &amp;&amp; !permanently))</a>
<a name="ln572">    {</a>
<a name="ln573">        return false;</a>
<a name="ln574">    }</a>
<a name="ln575">    else if (grid == DNGN_DEEP_WATER &amp;&amp; !player_likes_water(permanently)</a>
<a name="ln576">             || grid == DNGN_LAVA)</a>
<a name="ln577">    {</a>
<a name="ln578">        return true;</a>
<a name="ln579">    }</a>
<a name="ln580">    else</a>
<a name="ln581">        return false;</a>
<a name="ln582">}</a>
<a name="ln583"> </a>
<a name="ln584">bool is_map_persistent()</a>
<a name="ln585">{</a>
<a name="ln586">    return !testbits(your_branch().branch_flags, brflag::no_map)</a>
<a name="ln587">           || env.properties.exists(FORCE_MAPPABLE_KEY);</a>
<a name="ln588">}</a>
<a name="ln589"> </a>
<a name="ln590">bool player_in_hell(bool vestibule)</a>
<a name="ln591">{</a>
<a name="ln592">    return vestibule ? is_hell_branch(you.where_are_you) :</a>
<a name="ln593">                       is_hell_subbranch(you.where_are_you);</a>
<a name="ln594">}</a>
<a name="ln595"> </a>
<a name="ln596">/**</a>
<a name="ln597"> * Is the player in the slightly-special version of the abyss that AKs start</a>
<a name="ln598"> * in?</a>
<a name="ln599"> */</a>
<a name="ln600">bool player_in_starting_abyss()</a>
<a name="ln601">{</a>
<a name="ln602">    return you.chapter == CHAPTER_POCKET_ABYSS</a>
<a name="ln603">           &amp;&amp; player_in_branch(BRANCH_ABYSS) &amp;&amp; you.depth &lt;= 1;</a>
<a name="ln604">}</a>
<a name="ln605"> </a>
<a name="ln606">bool player_in_connected_branch()</a>
<a name="ln607">{</a>
<a name="ln608">    return is_connected_branch(you.where_are_you);</a>
<a name="ln609">}</a>
<a name="ln610"> </a>
<a name="ln611">bool player_likes_water(bool permanently)</a>
<a name="ln612">{</a>
<a name="ln613">    return !permanently &amp;&amp; you.can_water_walk()</a>
<a name="ln614">           || (species_likes_water(you.species) || !permanently)</a>
<a name="ln615">               &amp;&amp; form_likes_water();</a>
<a name="ln616">}</a>
<a name="ln617"> </a>
<a name="ln618">/**</a>
<a name="ln619"> * Is the player considered to be closely related, if not the same species, to</a>
<a name="ln620"> * the given monster? (See mon-data.h for species/genus info.)</a>
<a name="ln621"> *</a>
<a name="ln622"> * @param mon   The type of monster to be compared.</a>
<a name="ln623"> * @return      Whether the player's species is related to the one given.</a>
<a name="ln624"> */</a>
<a name="ln625">bool is_player_same_genus(const monster_type mon)</a>
<a name="ln626">{</a>
<a name="ln627">    return mons_genus(mon) == mons_genus(player_mons(false));</a>
<a name="ln628">}</a>
<a name="ln629"> </a>
<a name="ln630">void update_player_symbol()</a>
<a name="ln631">{</a>
<a name="ln632">    you.symbol = Options.show_player_species ? player_mons() : transform_mons();</a>
<a name="ln633">}</a>
<a name="ln634"> </a>
<a name="ln635">monster_type player_mons(bool transform)</a>
<a name="ln636">{</a>
<a name="ln637">    monster_type mons;</a>
<a name="ln638"> </a>
<a name="ln639">    if (transform)</a>
<a name="ln640">    {</a>
<a name="ln641">        mons = transform_mons();</a>
<a name="ln642">        if (mons != MONS_PLAYER)</a>
<a name="ln643">            return mons;</a>
<a name="ln644">    }</a>
<a name="ln645"> </a>
<a name="ln646">    mons = player_species_to_mons_species(you.species);</a>
<a name="ln647"> </a>
<a name="ln648">    if (mons == MONS_ORC)</a>
<a name="ln649">    {</a>
<a name="ln650">        if (you_worship(GOD_BEOGH))</a>
<a name="ln651">        {</a>
<a name="ln652">            mons = (you.piety &gt;= piety_breakpoint(4)) ? MONS_ORC_HIGH_PRIEST</a>
<a name="ln653">                                                      : MONS_ORC_PRIEST;</a>
<a name="ln654">        }</a>
<a name="ln655">    }</a>
<a name="ln656">    else if (mons == MONS_OGRE)</a>
<a name="ln657">    {</a>
<a name="ln658">        const skill_type sk = best_skill(SK_FIRST_SKILL, SK_LAST_SKILL);</a>
<a name="ln659">        if (sk &gt;= SK_SPELLCASTING &amp;&amp; sk &lt;= SK_LAST_MAGIC)</a>
<a name="ln660">            mons = MONS_OGRE_MAGE;</a>
<a name="ln661">    }</a>
<a name="ln662"> </a>
<a name="ln663">    return mons;</a>
<a name="ln664">}</a>
<a name="ln665"> </a>
<a name="ln666">void update_vision_range()</a>
<a name="ln667">{</a>
<a name="ln668">    you.normal_vision = LOS_DEFAULT_RANGE;</a>
<a name="ln669">    int nom   = 1;</a>
<a name="ln670">    int denom = 1;</a>
<a name="ln671"> </a>
<a name="ln672">    // Barachi have +1 base LOS.</a>
<a name="ln673">    if (you.species == SP_BARACHI)</a>
<a name="ln674">        you.normal_vision += 1;</a>
<a name="ln675"> </a>
<a name="ln676">    // Nightstalker gives -1/-2/-3.</a>
<a name="ln677">    if (you.get_mutation_level(MUT_NIGHTSTALKER))</a>
<a name="ln678">    {</a>
<a name="ln679">        nom *= you.normal_vision - you.get_mutation_level(MUT_NIGHTSTALKER);</a>
<a name="ln680">        denom *= you.normal_vision;</a>
<a name="ln681">    }</a>
<a name="ln682"> </a>
<a name="ln683">    // the Darkness spell.</a>
<a name="ln684">    if (you.duration[DUR_DARKNESS])</a>
<a name="ln685">        nom *= 3, denom *= 4;</a>
<a name="ln686"> </a>
<a name="ln687">    // robe of Night.</a>
<a name="ln688">    if (player_equip_unrand(UNRAND_NIGHT))</a>
<a name="ln689">        nom *= 3, denom *= 4;</a>
<a name="ln690"> </a>
<a name="ln691">    you.current_vision = (you.normal_vision * nom + denom / 2) / denom;</a>
<a name="ln692">    ASSERT(you.current_vision &gt; 0);</a>
<a name="ln693">    set_los_radius(you.current_vision);</a>
<a name="ln694">}</a>
<a name="ln695"> </a>
<a name="ln696">/**</a>
<a name="ln697"> * Ignoring form &amp; most equipment, but not the UNRAND_FINGER_AMULET, can the</a>
<a name="ln698"> * player use (usually wear) a given equipment slot?</a>
<a name="ln699"> *</a>
<a name="ln700"> * @param eq   The slot in question.</a>
<a name="ln701"> * @param temp Whether to consider forms.</a>
<a name="ln702"> * @return   MB_FALSE if the player can never use the slot;</a>
<a name="ln703"> *           MB_MAYBE if the player can only use some items for the slot;</a>
<a name="ln704"> *           MB_TRUE  if the player can use any (fsvo any) item for the slot.</a>
<a name="ln705"> */</a>
<a name="ln706">maybe_bool you_can_wear(equipment_type eq, bool temp)</a>
<a name="ln707">{</a>
<a name="ln708">    if (temp &amp;&amp; !get_form()-&gt;slot_available(eq))</a>
<a name="ln709">        return MB_FALSE;</a>
<a name="ln710"> </a>
<a name="ln711">    switch (eq)</a>
<a name="ln712">    {</a>
<a name="ln713">    case EQ_LEFT_RING:</a>
<a name="ln714">        if (you.get_mutation_level(MUT_MISSING_HAND))</a>
<a name="ln715">            return MB_FALSE;</a>
<a name="ln716">        // intentional fallthrough</a>
<a name="ln717">    case EQ_RIGHT_RING:</a>
<a name="ln718">        return you.species != SP_OCTOPODE ? MB_TRUE : MB_FALSE;</a>
<a name="ln719"> </a>
<a name="ln720">    case EQ_RING_EIGHT:</a>
<a name="ln721">        if (you.get_mutation_level(MUT_MISSING_HAND))</a>
<a name="ln722">            return MB_FALSE;</a>
<a name="ln723">        // intentional fallthrough</a>
<a name="ln724">    case EQ_RING_ONE:</a>
<a name="ln725">    case EQ_RING_TWO:</a>
<a name="ln726">    case EQ_RING_THREE:</a>
<a name="ln727">    case EQ_RING_FOUR:</a>
<a name="ln728">    case EQ_RING_FIVE:</a>
<a name="ln729">    case EQ_RING_SIX:</a>
<a name="ln730">    case EQ_RING_SEVEN:</a>
<a name="ln731">        return you.species == SP_OCTOPODE ? MB_TRUE : MB_FALSE;</a>
<a name="ln732"> </a>
<a name="ln733">    case EQ_WEAPON:</a>
<a name="ln734">    case EQ_STAFF:</a>
<a name="ln735">        return you.species == SP_FELID ? MB_FALSE :</a>
<a name="ln736">               you.body_size(PSIZE_TORSO, !temp) &lt; SIZE_MEDIUM ? MB_MAYBE :</a>
<a name="ln737">                                         MB_TRUE;</a>
<a name="ln738"> </a>
<a name="ln739">    // You can always wear at least one ring (forms were already handled).</a>
<a name="ln740">    case EQ_RINGS:</a>
<a name="ln741">    case EQ_ALL_ARMOUR:</a>
<a name="ln742">    case EQ_AMULET:</a>
<a name="ln743">        return MB_TRUE;</a>
<a name="ln744"> </a>
<a name="ln745">    case EQ_RING_AMULET:</a>
<a name="ln746">        return player_equip_unrand(UNRAND_FINGER_AMULET) ? MB_TRUE : MB_FALSE;</a>
<a name="ln747"> </a>
<a name="ln748">    default:</a>
<a name="ln749">        break;</a>
<a name="ln750">    }</a>
<a name="ln751"> </a>
<a name="ln752">    item_def dummy, alternate;</a>
<a name="ln753">    dummy.base_type = alternate.base_type = OBJ_ARMOUR;</a>
<a name="ln754">    dummy.sub_type = alternate.sub_type = NUM_ARMOURS;</a>
<a name="ln755">    // Make sure can_wear_armour doesn't think it's Lear's.</a>
<a name="ln756">    dummy.unrand_idx = alternate.unrand_idx = 0;</a>
<a name="ln757"> </a>
<a name="ln758">    switch (eq)</a>
<a name="ln759">    {</a>
<a name="ln760">    case EQ_CLOAK:</a>
<a name="ln761">        dummy.sub_type = ARM_CLOAK;</a>
<a name="ln762">        alternate.sub_type = ARM_SCARF;</a>
<a name="ln763">        break;</a>
<a name="ln764"> </a>
<a name="ln765">    case EQ_GLOVES:</a>
<a name="ln766">        dummy.sub_type = ARM_GLOVES;</a>
<a name="ln767">        break;</a>
<a name="ln768"> </a>
<a name="ln769">    case EQ_BOOTS: // And bardings</a>
<a name="ln770">        dummy.sub_type = ARM_BOOTS;</a>
<a name="ln771">        if (you.species == SP_NAGA)</a>
<a name="ln772">            alternate.sub_type = ARM_NAGA_BARDING;</a>
<a name="ln773">        if (you.species == SP_CENTAUR)</a>
<a name="ln774">            alternate.sub_type = ARM_CENTAUR_BARDING;</a>
<a name="ln775">        break;</a>
<a name="ln776"> </a>
<a name="ln777">    case EQ_BODY_ARMOUR:</a>
<a name="ln778">        // Assume that anything that can wear any armour at all can wear a robe</a>
<a name="ln779">        // and that anything that can wear CPA can wear all armour.</a>
<a name="ln780">        dummy.sub_type = ARM_CRYSTAL_PLATE_ARMOUR;</a>
<a name="ln781">        alternate.sub_type = ARM_ROBE;</a>
<a name="ln782">        break;</a>
<a name="ln783"> </a>
<a name="ln784">    case EQ_SHIELD:</a>
<a name="ln785">        // No races right now that can wear ARM_TOWER_SHIELD but not ARM_KITE_SHIELD</a>
<a name="ln786">        dummy.sub_type = ARM_TOWER_SHIELD;</a>
<a name="ln787">        if (you.body_size(PSIZE_TORSO, !temp) &lt; SIZE_MEDIUM)</a>
<a name="ln788">            alternate.sub_type = ARM_BUCKLER;</a>
<a name="ln789">        break;</a>
<a name="ln790"> </a>
<a name="ln791">    case EQ_HELMET:</a>
<a name="ln792">        dummy.sub_type = ARM_HELMET;</a>
<a name="ln793">        alternate.sub_type = ARM_HAT;</a>
<a name="ln794">        break;</a>
<a name="ln795"> </a>
<a name="ln796">    default:</a>
<a name="ln797">        die(&quot;unhandled equipment type %d&quot;, eq);</a>
<a name="ln798">        break;</a>
<a name="ln799">    }</a>
<a name="ln800"> </a>
<a name="ln801">    ASSERT(dummy.sub_type != NUM_ARMOURS);</a>
<a name="ln802"> </a>
<a name="ln803">    if (can_wear_armour(dummy, false, !temp))</a>
<a name="ln804">        return MB_TRUE;</a>
<a name="ln805">    else if (alternate.sub_type != NUM_ARMOURS</a>
<a name="ln806">             &amp;&amp; can_wear_armour(alternate, false, !temp))</a>
<a name="ln807">    {</a>
<a name="ln808">        return MB_MAYBE;</a>
<a name="ln809">    }</a>
<a name="ln810">    else</a>
<a name="ln811">        return MB_FALSE;</a>
<a name="ln812">}</a>
<a name="ln813"> </a>
<a name="ln814">bool player_has_feet(bool temp, bool include_mutations)</a>
<a name="ln815">{</a>
<a name="ln816">    if (you.species == SP_NAGA</a>
<a name="ln817">        || you.species == SP_FELID</a>
<a name="ln818">        || you.species == SP_OCTOPODE</a>
<a name="ln819">        || you.fishtail &amp;&amp; temp)</a>
<a name="ln820">    {</a>
<a name="ln821">        return false;</a>
<a name="ln822">    }</a>
<a name="ln823"> </a>
<a name="ln824">    if (include_mutations &amp;&amp;</a>
<a name="ln825">        (you.get_mutation_level(MUT_HOOVES, temp) == 3</a>
<a name="ln826">         || you.get_mutation_level(MUT_TALONS, temp) == 3))</a>
<a name="ln827">    {</a>
<a name="ln828">        return false;</a>
<a name="ln829">    }</a>
<a name="ln830"> </a>
<a name="ln831">    return true;</a>
<a name="ln832">}</a>
<a name="ln833"> </a>
<a name="ln834">// Returns false if the player is wielding a weapon inappropriate for Berserk.</a>
<a name="ln835">bool berserk_check_wielded_weapon()</a>
<a name="ln836">{</a>
<a name="ln837">    const item_def * const wpn = you.weapon();</a>
<a name="ln838">    bool penance = false;</a>
<a name="ln839">    if (wpn &amp;&amp; wpn-&gt;defined()</a>
<a name="ln840">        &amp;&amp; (!is_melee_weapon(*wpn)</a>
<a name="ln841">            || needs_handle_warning(*wpn, OPER_ATTACK, penance)))</a>
<a name="ln842">    {</a>
<a name="ln843">        string prompt = &quot;Do you really want to go berserk while wielding &quot;</a>
<a name="ln844">                        + wpn-&gt;name(DESC_YOUR) + &quot;?&quot;;</a>
<a name="ln845">        if (penance)</a>
<a name="ln846">            prompt += &quot; This could place you under penance!&quot;;</a>
<a name="ln847"> </a>
<a name="ln848">        if (!yesno(prompt.c_str(), true, 'n'))</a>
<a name="ln849">        {</a>
<a name="ln850">            canned_msg(MSG_OK);</a>
<a name="ln851">            return false;</a>
<a name="ln852">        }</a>
<a name="ln853">    }</a>
<a name="ln854"> </a>
<a name="ln855">    return true;</a>
<a name="ln856">}</a>
<a name="ln857"> </a>
<a name="ln858">// Looks in equipment &quot;slot&quot; to see if there is an equipped &quot;sub_type&quot;.</a>
<a name="ln859">// Returns number of matches (in the case of rings, both are checked)</a>
<a name="ln860">int player::wearing(equipment_type slot, int sub_type, bool calc_unid) const</a>
<a name="ln861">{</a>
<a name="ln862">    int ret = 0;</a>
<a name="ln863"> </a>
<a name="ln864">    const item_def* item;</a>
<a name="ln865"> </a>
<a name="ln866">    switch (slot)</a>
<a name="ln867">    {</a>
<a name="ln868">    case EQ_WEAPON:</a>
<a name="ln869">        // Hands can have more than just weapons.</a>
<a name="ln870">        if (weapon() &amp;&amp; weapon()-&gt;is_type(OBJ_WEAPONS, sub_type))</a>
<a name="ln871">            ret++;</a>
<a name="ln872">        break;</a>
<a name="ln873"> </a>
<a name="ln874">    case EQ_STAFF:</a>
<a name="ln875">        // Like above, but must be magical staff.</a>
<a name="ln876">        if (weapon()</a>
<a name="ln877">            &amp;&amp; weapon()-&gt;is_type(OBJ_STAVES, sub_type)</a>
<a name="ln878">            &amp;&amp; (calc_unid || item_type_known(*weapon())))</a>
<a name="ln879">        {</a>
<a name="ln880">            ret++;</a>
<a name="ln881">        }</a>
<a name="ln882">        break;</a>
<a name="ln883"> </a>
<a name="ln884">    case EQ_AMULET:</a>
<a name="ln885">    case EQ_AMULET_PLUS:</a>
<a name="ln886">        if ((item = slot_item(static_cast&lt;equipment_type&gt;(EQ_AMULET)))</a>
<a name="ln887">            &amp;&amp; item-&gt;sub_type == sub_type</a>
<a name="ln888">            &amp;&amp; (calc_unid</a>
<a name="ln889">                || item_type_known(*item)))</a>
<a name="ln890">        {</a>
<a name="ln891">            ret += (slot == EQ_AMULET_PLUS ? item-&gt;plus : 1);</a>
<a name="ln892">        }</a>
<a name="ln893">        break;</a>
<a name="ln894"> </a>
<a name="ln895">    case EQ_RINGS:</a>
<a name="ln896">    case EQ_RINGS_PLUS:</a>
<a name="ln897">        for (int slots = EQ_FIRST_JEWELLERY; slots &lt;= EQ_LAST_JEWELLERY; slots++)</a>
<a name="ln898">        {</a>
<a name="ln899">            if (slots == EQ_AMULET)</a>
<a name="ln900">                continue;</a>
<a name="ln901"> </a>
<a name="ln902">            if ((item = slot_item(static_cast&lt;equipment_type&gt;(slots)))</a>
<a name="ln903">                &amp;&amp; item-&gt;sub_type == sub_type</a>
<a name="ln904">                &amp;&amp; (calc_unid</a>
<a name="ln905">                    || item_type_known(*item)))</a>
<a name="ln906">            {</a>
<a name="ln907">                ret += (slot == EQ_RINGS_PLUS ? item-&gt;plus : 1);</a>
<a name="ln908">            }</a>
<a name="ln909">        }</a>
<a name="ln910">        break;</a>
<a name="ln911"> </a>
<a name="ln912">    case EQ_ALL_ARMOUR:</a>
<a name="ln913">        // Doesn't make much sense here... be specific. -- bwr</a>
<a name="ln914">        die(&quot;EQ_ALL_ARMOUR is not a proper slot&quot;);</a>
<a name="ln915">        break;</a>
<a name="ln916"> </a>
<a name="ln917">    default:</a>
<a name="ln918">        if (! (slot &gt;= EQ_FIRST_EQUIP &amp;&amp; slot &lt; NUM_EQUIP))</a>
<a name="ln919">            die(&quot;invalid slot&quot;);</a>
<a name="ln920">        if ((item = slot_item(slot))</a>
<a name="ln921">            &amp;&amp; item-&gt;sub_type == sub_type</a>
<a name="ln922">            &amp;&amp; (calc_unid || item_type_known(*item)))</a>
<a name="ln923">        {</a>
<a name="ln924">            ret++;</a>
<a name="ln925">        }</a>
<a name="ln926">        break;</a>
<a name="ln927">    }</a>
<a name="ln928"> </a>
<a name="ln929">    return ret;</a>
<a name="ln930">}</a>
<a name="ln931"> </a>
<a name="ln932">// Looks in equipment &quot;slot&quot; to see if equipped item has &quot;special&quot; ego-type</a>
<a name="ln933">// Returns number of matches (jewellery returns zero -- no ego type).</a>
<a name="ln934">// [ds] There's no equivalent of calc_unid or req_id because as of now, weapons</a>
<a name="ln935">// and armour type-id on wield/wear.</a>
<a name="ln936">int player::wearing_ego(equipment_type slot, int special, bool calc_unid) const</a>
<a name="ln937">{</a>
<a name="ln938">    int ret = 0;</a>
<a name="ln939"> </a>
<a name="ln940">    const item_def* item;</a>
<a name="ln941">    switch (slot)</a>
<a name="ln942">    {</a>
<a name="ln943">    case EQ_WEAPON:</a>
<a name="ln944">        // Hands can have more than just weapons.</a>
<a name="ln945">        if ((item = slot_item(EQ_WEAPON))</a>
<a name="ln946">            &amp;&amp; item-&gt;base_type == OBJ_WEAPONS</a>
<a name="ln947">            &amp;&amp; get_weapon_brand(*item) == special)</a>
<a name="ln948">        {</a>
<a name="ln949">            ret++;</a>
<a name="ln950">        }</a>
<a name="ln951">        break;</a>
<a name="ln952"> </a>
<a name="ln953">    case EQ_LEFT_RING:</a>
<a name="ln954">    case EQ_RIGHT_RING:</a>
<a name="ln955">    case EQ_AMULET:</a>
<a name="ln956">    case EQ_STAFF:</a>
<a name="ln957">    case EQ_RINGS:</a>
<a name="ln958">    case EQ_RINGS_PLUS:</a>
<a name="ln959">        // no ego types for these slots</a>
<a name="ln960">        break;</a>
<a name="ln961"> </a>
<a name="ln962">    case EQ_ALL_ARMOUR:</a>
<a name="ln963">        // Check all armour slots:</a>
<a name="ln964">        for (int i = EQ_MIN_ARMOUR; i &lt;= EQ_MAX_ARMOUR; i++)</a>
<a name="ln965">        {</a>
<a name="ln966">            if ((item = slot_item(static_cast&lt;equipment_type&gt;(i)))</a>
<a name="ln967">                &amp;&amp; get_armour_ego_type(*item) == special</a>
<a name="ln968">                &amp;&amp; (calc_unid || item_type_known(*item)))</a>
<a name="ln969">            {</a>
<a name="ln970">                ret++;</a>
<a name="ln971">            }</a>
<a name="ln972">        }</a>
<a name="ln973">        break;</a>
<a name="ln974"> </a>
<a name="ln975">    default:</a>
<a name="ln976">        if (slot &lt; EQ_MIN_ARMOUR || slot &gt; EQ_MAX_ARMOUR)</a>
<a name="ln977">            die(&quot;invalid slot: %d&quot;, slot);</a>
<a name="ln978">        // Check a specific armour slot for an ego type:</a>
<a name="ln979">        if ((item = slot_item(static_cast&lt;equipment_type&gt;(slot)))</a>
<a name="ln980">            &amp;&amp; get_armour_ego_type(*item) == special</a>
<a name="ln981">            &amp;&amp; (calc_unid || item_type_known(*item)))</a>
<a name="ln982">        {</a>
<a name="ln983">            ret++;</a>
<a name="ln984">        }</a>
<a name="ln985">        break;</a>
<a name="ln986">    }</a>
<a name="ln987"> </a>
<a name="ln988">    return ret;</a>
<a name="ln989">}</a>
<a name="ln990"> </a>
<a name="ln991">// Returns true if the indicated unrandart is equipped</a>
<a name="ln992">// [ds] There's no equivalent of calc_unid or req_id because as of now, weapons</a>
<a name="ln993">// and armour type-id on wield/wear.</a>
<a name="ln994">bool player_equip_unrand(int unrand_index)</a>
<a name="ln995">{</a>
<a name="ln996">    const unrandart_entry* entry = get_unrand_entry(unrand_index);</a>
<a name="ln997">    equipment_type   slot  = get_item_slot(entry-&gt;base_type,</a>
<a name="ln998">                                           entry-&gt;sub_type);</a>
<a name="ln999"> </a>
<a name="ln1000">    item_def* item;</a>
<a name="ln1001"> </a>
<a name="ln1002">    switch (slot)</a>
<a name="ln1003">    {</a>
<a name="ln1004">    case EQ_WEAPON:</a>
<a name="ln1005">        // Hands can have more than just weapons.</a>
<a name="ln1006">        if ((item = you.slot_item(slot))</a>
<a name="ln1007">            &amp;&amp; item-&gt;base_type == OBJ_WEAPONS</a>
<a name="ln1008">            &amp;&amp; is_unrandom_artefact(*item)</a>
<a name="ln1009">            &amp;&amp; item-&gt;unrand_idx == unrand_index)</a>
<a name="ln1010">        {</a>
<a name="ln1011">            return true;</a>
<a name="ln1012">        }</a>
<a name="ln1013">        break;</a>
<a name="ln1014"> </a>
<a name="ln1015">    case EQ_RINGS:</a>
<a name="ln1016">        for (int slots = EQ_FIRST_JEWELLERY; slots &lt;= EQ_LAST_JEWELLERY; ++slots)</a>
<a name="ln1017">        {</a>
<a name="ln1018">            if (slots == EQ_AMULET)</a>
<a name="ln1019">                continue;</a>
<a name="ln1020"> </a>
<a name="ln1021">            if ((item = you.slot_item(static_cast&lt;equipment_type&gt;(slots)))</a>
<a name="ln1022">                &amp;&amp; is_unrandom_artefact(*item)</a>
<a name="ln1023">                &amp;&amp; item-&gt;unrand_idx == unrand_index)</a>
<a name="ln1024">            {</a>
<a name="ln1025">                return true;</a>
<a name="ln1026">            }</a>
<a name="ln1027">        }</a>
<a name="ln1028">        break;</a>
<a name="ln1029"> </a>
<a name="ln1030">    case EQ_NONE:</a>
<a name="ln1031">    case EQ_STAFF:</a>
<a name="ln1032">    case EQ_LEFT_RING:</a>
<a name="ln1033">    case EQ_RIGHT_RING:</a>
<a name="ln1034">    case EQ_RINGS_PLUS:</a>
<a name="ln1035">    case EQ_ALL_ARMOUR:</a>
<a name="ln1036">        // no unrandarts for these slots.</a>
<a name="ln1037">        break;</a>
<a name="ln1038"> </a>
<a name="ln1039">    default:</a>
<a name="ln1040">        if (slot &lt;= EQ_NONE || slot &gt;= NUM_EQUIP)</a>
<a name="ln1041">            die(&quot;invalid slot: %d&quot;, slot);</a>
<a name="ln1042">        // Check a specific slot.</a>
<a name="ln1043">        if ((item = you.slot_item(slot))</a>
<a name="ln1044">            &amp;&amp; is_unrandom_artefact(*item)</a>
<a name="ln1045">            &amp;&amp; item-&gt;unrand_idx == unrand_index)</a>
<a name="ln1046">        {</a>
<a name="ln1047">            return true;</a>
<a name="ln1048">        }</a>
<a name="ln1049">        break;</a>
<a name="ln1050">    }</a>
<a name="ln1051"> </a>
<a name="ln1052">    return false;</a>
<a name="ln1053">}</a>
<a name="ln1054"> </a>
<a name="ln1055">bool player_can_hear(const coord_def&amp; p, int hear_distance)</a>
<a name="ln1056">{</a>
<a name="ln1057">    return !silenced(p)</a>
<a name="ln1058">           &amp;&amp; !silenced(you.pos())</a>
<a name="ln1059">           &amp;&amp; you.pos().distance_from(p) &lt;= hear_distance;</a>
<a name="ln1060">}</a>
<a name="ln1061"> </a>
<a name="ln1062">int player_teleport(bool calc_unid)</a>
<a name="ln1063">{</a>
<a name="ln1064">    ASSERT(!crawl_state.game_is_arena());</a>
<a name="ln1065"> </a>
<a name="ln1066">    // Don't allow any form of teleportation in Sprint or Gauntlets.</a>
<a name="ln1067">    if (crawl_state.game_is_sprint() || player_in_branch(BRANCH_GAUNTLET))</a>
<a name="ln1068">        return 0;</a>
<a name="ln1069"> </a>
<a name="ln1070">    // Short-circuit rings of teleport to prevent spam.</a>
<a name="ln1071">    if (you.species == SP_FORMICID)</a>
<a name="ln1072">        return 0;</a>
<a name="ln1073"> </a>
<a name="ln1074">    int tp = 0;</a>
<a name="ln1075"> </a>
<a name="ln1076">    // rings (keep in sync with _equip_jewellery_effect)</a>
<a name="ln1077">    tp += 8 * you.wearing(EQ_RINGS, RING_TELEPORTATION, calc_unid);</a>
<a name="ln1078"> </a>
<a name="ln1079">    // artefacts</a>
<a name="ln1080">    tp += 8 * you.scan_artefacts(ARTP_CAUSE_TELEPORTATION, calc_unid);</a>
<a name="ln1081"> </a>
<a name="ln1082">    // mutations</a>
<a name="ln1083">    tp += you.get_mutation_level(MUT_TELEPORT) * 4;</a>
<a name="ln1084"> </a>
<a name="ln1085">    return tp;</a>
<a name="ln1086">}</a>
<a name="ln1087"> </a>
<a name="ln1088">// Computes bonuses to regeneration from most sources. Does not handle</a>
<a name="ln1089">// slow regeneration, vampireness, or Trog's Hand.</a>
<a name="ln1090">static int _player_bonus_regen()</a>
<a name="ln1091">{</a>
<a name="ln1092">    int rr = 0;</a>
<a name="ln1093"> </a>
<a name="ln1094">    // Jewellery.</a>
<a name="ln1095">    if (you.activated[EQ_AMULET])</a>
<a name="ln1096">        rr += REGEN_PIP * you.wearing(EQ_AMULET, AMU_REGENERATION);</a>
<a name="ln1097"> </a>
<a name="ln1098">    // Artefacts (artp_regen is only on armour) and troll leather armour</a>
<a name="ln1099">    for (int slot = EQ_MIN_ARMOUR; slot &lt;= EQ_MAX_ARMOUR; ++slot)</a>
<a name="ln1100">    {</a>
<a name="ln1101">        if (you.melded[slot] || you.equip[slot] == -1 || !you.activated[slot])</a>
<a name="ln1102">            continue;</a>
<a name="ln1103">        const item_def &amp;arm = you.inv[you.equip[slot]];</a>
<a name="ln1104">        if (armour_type_prop(arm.sub_type, ARMF_REGENERATION))</a>
<a name="ln1105">            rr += REGEN_PIP;</a>
<a name="ln1106">        if (is_artefact(arm))</a>
<a name="ln1107">            rr += REGEN_PIP * artefact_property(arm, ARTP_REGENERATION);</a>
<a name="ln1108">    }</a>
<a name="ln1109"> </a>
<a name="ln1110">    // Fast heal mutation.</a>
<a name="ln1111">    rr += you.get_mutation_level(MUT_REGENERATION) * REGEN_PIP;</a>
<a name="ln1112"> </a>
<a name="ln1113">    // Powered By Death mutation, boosts regen by variable strength</a>
<a name="ln1114">    // if the duration of the effect is still active.</a>
<a name="ln1115">    if (you.duration[DUR_POWERED_BY_DEATH])</a>
<a name="ln1116">        rr += you.props[POWERED_BY_DEATH_KEY].get_int() * 100;</a>
<a name="ln1117"> </a>
<a name="ln1118">    return rr;</a>
<a name="ln1119">}</a>
<a name="ln1120"> </a>
<a name="ln1121">// Inhibited regeneration: stops regeneration when monsters are visible</a>
<a name="ln1122">bool regeneration_is_inhibited()</a>
<a name="ln1123">{</a>
<a name="ln1124">    if (you.get_mutation_level(MUT_INHIBITED_REGENERATION) == 1</a>
<a name="ln1125">        || (you.species == SP_VAMPIRE &amp;&amp; !you.vampire_alive))</a>
<a name="ln1126">    {</a>
<a name="ln1127">        for (monster_near_iterator mi(you.pos(), LOS_NO_TRANS); mi; ++mi)</a>
<a name="ln1128">        {</a>
<a name="ln1129">            if (mons_is_threatening(**mi)</a>
<a name="ln1130">                &amp;&amp; !mi-&gt;wont_attack()</a>
<a name="ln1131">                &amp;&amp; !mi-&gt;neutral()</a>
<a name="ln1132">                &amp;&amp; !mi-&gt;submerged())</a>
<a name="ln1133">            {</a>
<a name="ln1134">                return true;</a>
<a name="ln1135">            }</a>
<a name="ln1136">        }</a>
<a name="ln1137">    }</a>
<a name="ln1138"> </a>
<a name="ln1139">    return false;</a>
<a name="ln1140">}</a>
<a name="ln1141"> </a>
<a name="ln1142">int player_regen()</a>
<a name="ln1143">{</a>
<a name="ln1144">    // Note: if some condition can set rr = 0, can't be rested off, and</a>
<a name="ln1145">    // would allow travel, please update is_sufficiently_rested.</a>
<a name="ln1146"> </a>
<a name="ln1147">    int rr = you.hp_max / 3;</a>
<a name="ln1148"> </a>
<a name="ln1149">    if (rr &gt; 20)</a>
<a name="ln1150">        rr = 20 + ((rr - 20) / 2);</a>
<a name="ln1151"> </a>
<a name="ln1152">    // Add in miscellaneous bonuses</a>
<a name="ln1153">    rr += _player_bonus_regen();</a>
<a name="ln1154"> </a>
<a name="ln1155">    // Before applying other effects, make sure that there's something</a>
<a name="ln1156">    // to heal.</a>
<a name="ln1157">    rr = max(1, rr);</a>
<a name="ln1158"> </a>
<a name="ln1159">    // Bonus regeneration for alive vampires.</a>
<a name="ln1160">    if (you.species == SP_VAMPIRE &amp;&amp; you.vampire_alive)</a>
<a name="ln1161">        rr += 20;</a>
<a name="ln1162"> </a>
<a name="ln1163">    if (you.duration[DUR_COLLAPSE])</a>
<a name="ln1164">        rr /= 4;</a>
<a name="ln1165"> </a>
<a name="ln1166">    if (you.disease || regeneration_is_inhibited() || !player_regenerates_hp())</a>
<a name="ln1167">        rr = 0;</a>
<a name="ln1168"> </a>
<a name="ln1169">    // Trog's Hand. This circumvents sickness or inhibited regeneration.</a>
<a name="ln1170">    if (you.duration[DUR_TROGS_HAND])</a>
<a name="ln1171">        rr += 100;</a>
<a name="ln1172"> </a>
<a name="ln1173">    return rr;</a>
<a name="ln1174">}</a>
<a name="ln1175"> </a>
<a name="ln1176">int player_mp_regen()</a>
<a name="ln1177">{</a>
<a name="ln1178">    int regen_amount = 7 + you.max_magic_points / 2;</a>
<a name="ln1179"> </a>
<a name="ln1180">    if (you.get_mutation_level(MUT_MANA_REGENERATION))</a>
<a name="ln1181">        regen_amount *= 2;</a>
<a name="ln1182"> </a>
<a name="ln1183">    if (you.props[MANA_REGEN_AMULET_ACTIVE].get_int() == 1)</a>
<a name="ln1184">        regen_amount += 25;</a>
<a name="ln1185"> </a>
<a name="ln1186">    return regen_amount;</a>
<a name="ln1187">}</a>
<a name="ln1188"> </a>
<a name="ln1189">int player_hunger_rate()</a>
<a name="ln1190">{</a>
<a name="ln1191">    int hunger = 3;</a>
<a name="ln1192"> </a>
<a name="ln1193">    if (you.species == SP_TROLL)</a>
<a name="ln1194">        hunger += 3;            // in addition to the +3 for fast metabolism</a>
<a name="ln1195"> </a>
<a name="ln1196">    hunger += you.get_mutation_level(MUT_FAST_METABOLISM)</a>
<a name="ln1197">            - you.get_mutation_level(MUT_SLOW_METABOLISM);</a>
<a name="ln1198"> </a>
<a name="ln1199">    // If Cheibriados has slowed your life processes, you will hunger less.</a>
<a name="ln1200">    if (have_passive(passive_t::slow_metabolism))</a>
<a name="ln1201">        hunger /= 2;</a>
<a name="ln1202"> </a>
<a name="ln1203">    if (hunger &lt; 1)</a>
<a name="ln1204">        hunger = 1;</a>
<a name="ln1205"> </a>
<a name="ln1206">    return hunger;</a>
<a name="ln1207">}</a>
<a name="ln1208"> </a>
<a name="ln1209">/**</a>
<a name="ln1210"> * How many spell levels does the player have total, including those used up</a>
<a name="ln1211"> * by memorised spells?</a>
<a name="ln1212"> */</a>
<a name="ln1213">int player_total_spell_levels()</a>
<a name="ln1214">{</a>
<a name="ln1215">    return you.experience_level - 1 + you.skill(SK_SPELLCASTING, 2, true);</a>
<a name="ln1216">}</a>
<a name="ln1217"> </a>
<a name="ln1218">/**</a>
<a name="ln1219"> * How many spell levels does the player currently have available for</a>
<a name="ln1220"> * memorising new spells?</a>
<a name="ln1221"> */</a>
<a name="ln1222">int player_spell_levels()</a>
<a name="ln1223">{</a>
<a name="ln1224">    int sl = min(player_total_spell_levels(), 99);</a>
<a name="ln1225"> </a>
<a name="ln1226">    for (const spell_type spell : you.spells)</a>
<a name="ln1227">    {</a>
<a name="ln1228">        if (spell != SPELL_NO_SPELL)</a>
<a name="ln1229">            sl -= spell_difficulty(spell);</a>
<a name="ln1230">    }</a>
<a name="ln1231"> </a>
<a name="ln1232">    // Note: This can happen because of draining. -- bwr</a>
<a name="ln1233">    if (sl &lt; 0)</a>
<a name="ln1234">        sl = 0;</a>
<a name="ln1235"> </a>
<a name="ln1236">    return sl;</a>
<a name="ln1237">}</a>
<a name="ln1238"> </a>
<a name="ln1239">bool player_likes_chunks(bool permanently)</a>
<a name="ln1240">{</a>
<a name="ln1241">    return you.gourmand(true, !permanently)</a>
<a name="ln1242">           || you.get_mutation_level(MUT_CARNIVOROUS) &gt; 0;</a>
<a name="ln1243">}</a>
<a name="ln1244"> </a>
<a name="ln1245">// If temp is set to false, temporary sources or resistance won't be counted.</a>
<a name="ln1246">int player_res_fire(bool calc_unid, bool temp, bool items)</a>
<a name="ln1247">{</a>
<a name="ln1248">    int rf = 0;</a>
<a name="ln1249"> </a>
<a name="ln1250">    if (items)</a>
<a name="ln1251">    {</a>
<a name="ln1252">        // rings of fire resistance/fire</a>
<a name="ln1253">        rf += you.wearing(EQ_RINGS, RING_PROTECTION_FROM_FIRE, calc_unid);</a>
<a name="ln1254">        rf += you.wearing(EQ_RINGS, RING_FIRE, calc_unid);</a>
<a name="ln1255"> </a>
<a name="ln1256">        // rings of ice</a>
<a name="ln1257">        rf -= you.wearing(EQ_RINGS, RING_ICE, calc_unid);</a>
<a name="ln1258"> </a>
<a name="ln1259">        // Staves</a>
<a name="ln1260">        rf += you.wearing(EQ_STAFF, STAFF_FIRE, calc_unid);</a>
<a name="ln1261"> </a>
<a name="ln1262">        // body armour:</a>
<a name="ln1263">        const item_def *body_armour = you.slot_item(EQ_BODY_ARMOUR);</a>
<a name="ln1264">        if (body_armour)</a>
<a name="ln1265">            rf += armour_type_prop(body_armour-&gt;sub_type, ARMF_RES_FIRE);</a>
<a name="ln1266"> </a>
<a name="ln1267">        // ego armours</a>
<a name="ln1268">        rf += you.wearing_ego(EQ_ALL_ARMOUR, SPARM_FIRE_RESISTANCE);</a>
<a name="ln1269">        rf += you.wearing_ego(EQ_ALL_ARMOUR, SPARM_RESISTANCE);</a>
<a name="ln1270"> </a>
<a name="ln1271">        // randart weapons:</a>
<a name="ln1272">        rf += you.scan_artefacts(ARTP_FIRE, calc_unid);</a>
<a name="ln1273"> </a>
<a name="ln1274">        // dragonskin cloak: 0.5 to draconic resistances</a>
<a name="ln1275">        if (calc_unid &amp;&amp; player_equip_unrand(UNRAND_DRAGONSKIN)</a>
<a name="ln1276">            &amp;&amp; coinflip())</a>
<a name="ln1277">        {</a>
<a name="ln1278">            rf++;</a>
<a name="ln1279">        }</a>
<a name="ln1280">    }</a>
<a name="ln1281"> </a>
<a name="ln1282">    // species:</a>
<a name="ln1283">    if (you.species == SP_MUMMY)</a>
<a name="ln1284">        rf--;</a>
<a name="ln1285"> </a>
<a name="ln1286">    // mutations:</a>
<a name="ln1287">    rf += you.get_mutation_level(MUT_HEAT_RESISTANCE, temp);</a>
<a name="ln1288">    rf -= you.get_mutation_level(MUT_HEAT_VULNERABILITY, temp);</a>
<a name="ln1289">    rf -= you.get_mutation_level(MUT_TEMPERATURE_SENSITIVITY, temp);</a>
<a name="ln1290">    rf += you.get_mutation_level(MUT_MOLTEN_SCALES, temp) == 3 ? 1 : 0;</a>
<a name="ln1291"> </a>
<a name="ln1292">    // spells:</a>
<a name="ln1293">    if (temp)</a>
<a name="ln1294">    {</a>
<a name="ln1295">        if (you.duration[DUR_RESISTANCE])</a>
<a name="ln1296">            rf++;</a>
<a name="ln1297"> </a>
<a name="ln1298">        if (you.duration[DUR_FIRE_SHIELD])</a>
<a name="ln1299">            rf += 2;</a>
<a name="ln1300"> </a>
<a name="ln1301">        if (you.duration[DUR_QAZLAL_FIRE_RES])</a>
<a name="ln1302">            rf++;</a>
<a name="ln1303"> </a>
<a name="ln1304">        rf += get_form()-&gt;res_fire();</a>
<a name="ln1305">    }</a>
<a name="ln1306"> </a>
<a name="ln1307">    if (rf &gt; 3)</a>
<a name="ln1308">        rf = 3;</a>
<a name="ln1309">    if (temp &amp;&amp; you.duration[DUR_FIRE_VULN])</a>
<a name="ln1310">        rf--;</a>
<a name="ln1311">    if (rf &lt; -3)</a>
<a name="ln1312">        rf = -3;</a>
<a name="ln1313"> </a>
<a name="ln1314">    return rf;</a>
<a name="ln1315">}</a>
<a name="ln1316"> </a>
<a name="ln1317">int player_res_steam(bool calc_unid, bool temp, bool items)</a>
<a name="ln1318">{</a>
<a name="ln1319">    int res = 0;</a>
<a name="ln1320">    const int rf = player_res_fire(calc_unid, temp, items);</a>
<a name="ln1321"> </a>
<a name="ln1322">    if (you.species == SP_PALE_DRACONIAN)</a>
<a name="ln1323">        res += 2;</a>
<a name="ln1324"> </a>
<a name="ln1325">    if (items)</a>
<a name="ln1326">    {</a>
<a name="ln1327">        const item_def *body_armour = you.slot_item(EQ_BODY_ARMOUR);</a>
<a name="ln1328">        if (body_armour)</a>
<a name="ln1329">            res += armour_type_prop(body_armour-&gt;sub_type, ARMF_RES_STEAM) * 2;</a>
<a name="ln1330">    }</a>
<a name="ln1331"> </a>
<a name="ln1332">    res += rf * 2;</a>
<a name="ln1333"> </a>
<a name="ln1334">    if (res &gt; 2)</a>
<a name="ln1335">        res = 2;</a>
<a name="ln1336"> </a>
<a name="ln1337">    return res;</a>
<a name="ln1338">}</a>
<a name="ln1339"> </a>
<a name="ln1340">int player_res_cold(bool calc_unid, bool temp, bool items)</a>
<a name="ln1341">{</a>
<a name="ln1342">    int rc = 0;</a>
<a name="ln1343"> </a>
<a name="ln1344">    if (temp)</a>
<a name="ln1345">    {</a>
<a name="ln1346">        if (you.duration[DUR_RESISTANCE])</a>
<a name="ln1347">            rc++;</a>
<a name="ln1348"> </a>
<a name="ln1349">        if (you.duration[DUR_FIRE_SHIELD])</a>
<a name="ln1350">            rc -= 2;</a>
<a name="ln1351"> </a>
<a name="ln1352">        if (you.duration[DUR_QAZLAL_COLD_RES])</a>
<a name="ln1353">            rc++;</a>
<a name="ln1354"> </a>
<a name="ln1355">        rc += get_form()-&gt;res_cold();</a>
<a name="ln1356"> </a>
<a name="ln1357">        if (you.species == SP_VAMPIRE &amp;&amp; !you.vampire_alive)</a>
<a name="ln1358">                rc += 2;</a>
<a name="ln1359">    }</a>
<a name="ln1360"> </a>
<a name="ln1361">    if (items)</a>
<a name="ln1362">    {</a>
<a name="ln1363">        // rings of cold resistance/ice</a>
<a name="ln1364">        rc += you.wearing(EQ_RINGS, RING_PROTECTION_FROM_COLD, calc_unid);</a>
<a name="ln1365">        rc += you.wearing(EQ_RINGS, RING_ICE, calc_unid);</a>
<a name="ln1366"> </a>
<a name="ln1367">        // rings of fire</a>
<a name="ln1368">        rc -= you.wearing(EQ_RINGS, RING_FIRE, calc_unid);</a>
<a name="ln1369"> </a>
<a name="ln1370">        // Staves</a>
<a name="ln1371">        rc += you.wearing(EQ_STAFF, STAFF_COLD, calc_unid);</a>
<a name="ln1372"> </a>
<a name="ln1373">        // body armour:</a>
<a name="ln1374">        const item_def *body_armour = you.slot_item(EQ_BODY_ARMOUR);</a>
<a name="ln1375">        if (body_armour)</a>
<a name="ln1376">            rc += armour_type_prop(body_armour-&gt;sub_type, ARMF_RES_COLD);</a>
<a name="ln1377"> </a>
<a name="ln1378">        // ego armours</a>
<a name="ln1379">        rc += you.wearing_ego(EQ_ALL_ARMOUR, SPARM_COLD_RESISTANCE);</a>
<a name="ln1380">        rc += you.wearing_ego(EQ_ALL_ARMOUR, SPARM_RESISTANCE);</a>
<a name="ln1381"> </a>
<a name="ln1382">        // randart weapons:</a>
<a name="ln1383">        rc += you.scan_artefacts(ARTP_COLD, calc_unid);</a>
<a name="ln1384"> </a>
<a name="ln1385">        // dragonskin cloak: 0.5 to draconic resistances</a>
<a name="ln1386">        if (calc_unid &amp;&amp; player_equip_unrand(UNRAND_DRAGONSKIN) &amp;&amp; coinflip())</a>
<a name="ln1387">            rc++;</a>
<a name="ln1388">    }</a>
<a name="ln1389"> </a>
<a name="ln1390">    // mutations:</a>
<a name="ln1391">    rc += you.get_mutation_level(MUT_COLD_RESISTANCE, temp);</a>
<a name="ln1392">    rc -= you.get_mutation_level(MUT_COLD_VULNERABILITY, temp);</a>
<a name="ln1393">    rc -= you.get_mutation_level(MUT_TEMPERATURE_SENSITIVITY, temp);</a>
<a name="ln1394">    rc += you.get_mutation_level(MUT_ICY_BLUE_SCALES, temp) == 3 ? 1 : 0;</a>
<a name="ln1395">    rc += you.get_mutation_level(MUT_SHAGGY_FUR, temp) == 3 ? 1 : 0;</a>
<a name="ln1396"> </a>
<a name="ln1397">    if (rc &lt; -3)</a>
<a name="ln1398">        rc = -3;</a>
<a name="ln1399">    else if (rc &gt; 3)</a>
<a name="ln1400">        rc = 3;</a>
<a name="ln1401"> </a>
<a name="ln1402">    return rc;</a>
<a name="ln1403">}</a>
<a name="ln1404"> </a>
<a name="ln1405">bool player::res_corr(bool calc_unid, bool items) const</a>
<a name="ln1406">{</a>
<a name="ln1407">    // dragonskin cloak: 0.5 to draconic resistances</a>
<a name="ln1408">    if (items &amp;&amp; calc_unid</a>
<a name="ln1409">        &amp;&amp; player_equip_unrand(UNRAND_DRAGONSKIN) &amp;&amp; coinflip())</a>
<a name="ln1410">    {</a>
<a name="ln1411">        return true;</a>
<a name="ln1412">    }</a>
<a name="ln1413"> </a>
<a name="ln1414">    if (have_passive(passive_t::resist_corrosion))</a>
<a name="ln1415">        return true;</a>
<a name="ln1416"> </a>
<a name="ln1417">    if (get_mutation_level(MUT_ACID_RESISTANCE))</a>
<a name="ln1418">        return true;</a>
<a name="ln1419"> </a>
<a name="ln1420">    if (get_form()-&gt;res_acid())</a>
<a name="ln1421">        return true;</a>
<a name="ln1422"> </a>
<a name="ln1423">    if (you.duration[DUR_RESISTANCE])</a>
<a name="ln1424">        return true;</a>
<a name="ln1425"> </a>
<a name="ln1426">    // TODO: why doesn't this use the usual form suppression mechanism?</a>
<a name="ln1427">    if (form_keeps_mutations()</a>
<a name="ln1428">        &amp;&amp; get_mutation_level(MUT_YELLOW_SCALES) &gt;= 3)</a>
<a name="ln1429">    {</a>
<a name="ln1430">        return true;</a>
<a name="ln1431">    }</a>
<a name="ln1432"> </a>
<a name="ln1433">    return actor::res_corr(calc_unid, items);</a>
<a name="ln1434">}</a>
<a name="ln1435"> </a>
<a name="ln1436">int player_res_acid(bool calc_unid, bool items)</a>
<a name="ln1437">{</a>
<a name="ln1438">    return you.res_corr(calc_unid, items) ? 1 : 0;</a>
<a name="ln1439">}</a>
<a name="ln1440"> </a>
<a name="ln1441">int player_res_electricity(bool calc_unid, bool temp, bool items)</a>
<a name="ln1442">{</a>
<a name="ln1443">    int re = 0;</a>
<a name="ln1444"> </a>
<a name="ln1445">    if (items)</a>
<a name="ln1446">    {</a>
<a name="ln1447">        // staff</a>
<a name="ln1448">        re += you.wearing(EQ_STAFF, STAFF_AIR, calc_unid);</a>
<a name="ln1449"> </a>
<a name="ln1450">        // body armour:</a>
<a name="ln1451">        const item_def *body_armour = you.slot_item(EQ_BODY_ARMOUR);</a>
<a name="ln1452">        if (body_armour)</a>
<a name="ln1453">            re += armour_type_prop(body_armour-&gt;sub_type, ARMF_RES_ELEC);</a>
<a name="ln1454"> </a>
<a name="ln1455">        // randart weapons:</a>
<a name="ln1456">        re += you.scan_artefacts(ARTP_ELECTRICITY, calc_unid);</a>
<a name="ln1457"> </a>
<a name="ln1458">        // dragonskin cloak: 0.5 to draconic resistances</a>
<a name="ln1459">        if (calc_unid &amp;&amp; player_equip_unrand(UNRAND_DRAGONSKIN) &amp;&amp; coinflip())</a>
<a name="ln1460">            re++;</a>
<a name="ln1461">    }</a>
<a name="ln1462"> </a>
<a name="ln1463">    // mutations:</a>
<a name="ln1464">    re += you.get_mutation_level(MUT_THIN_METALLIC_SCALES, temp) == 3 ? 1 : 0;</a>
<a name="ln1465">    re += you.get_mutation_level(MUT_SHOCK_RESISTANCE, temp);</a>
<a name="ln1466">    re -= you.get_mutation_level(MUT_SHOCK_VULNERABILITY, temp);</a>
<a name="ln1467"> </a>
<a name="ln1468">    if (temp)</a>
<a name="ln1469">    {</a>
<a name="ln1470">        if (you.duration[DUR_RESISTANCE])</a>
<a name="ln1471">            re++;</a>
<a name="ln1472"> </a>
<a name="ln1473">        if (you.duration[DUR_QAZLAL_ELEC_RES])</a>
<a name="ln1474">            re++;</a>
<a name="ln1475"> </a>
<a name="ln1476">        // transformations:</a>
<a name="ln1477">        if (get_form()-&gt;res_elec())</a>
<a name="ln1478">            re++;</a>
<a name="ln1479">    }</a>
<a name="ln1480"> </a>
<a name="ln1481">    if (re &gt; 1)</a>
<a name="ln1482">        re = 1;</a>
<a name="ln1483"> </a>
<a name="ln1484">    return re;</a>
<a name="ln1485">}</a>
<a name="ln1486"> </a>
<a name="ln1487">/**</a>
<a name="ln1488"> * Is the player character immune to torment?</a>
<a name="ln1489"> *</a>
<a name="ln1490"> * @param random    Whether to include unreliable effects (stochastic resist)</a>
<a name="ln1491"> * @return          Whether the player resists a given instance of torment; if</a>
<a name="ln1492"> *                  random is passed, the result may vary from call to call.</a>
<a name="ln1493"> */</a>
<a name="ln1494">bool player_res_torment(bool random)</a>
<a name="ln1495">{</a>
<a name="ln1496">    if (you.get_mutation_level(MUT_TORMENT_RESISTANCE))</a>
<a name="ln1497">        return true;</a>
<a name="ln1498"> </a>
<a name="ln1499">    if (random</a>
<a name="ln1500">        &amp;&amp; you.get_mutation_level(MUT_STOCHASTIC_TORMENT_RESISTANCE)</a>
<a name="ln1501">        &amp;&amp; coinflip())</a>
<a name="ln1502">    {</a>
<a name="ln1503">        return true;</a>
<a name="ln1504">    }</a>
<a name="ln1505"> </a>
<a name="ln1506">    return get_form()-&gt;res_neg() == 3</a>
<a name="ln1507">           || you.species == SP_VAMPIRE &amp;&amp; !you.vampire_alive</a>
<a name="ln1508">           || you.petrified()</a>
<a name="ln1509">#if TAG_MAJOR_VERSION == 34</a>
<a name="ln1510">           || player_equip_unrand(UNRAND_ETERNAL_TORMENT)</a>
<a name="ln1511">#endif</a>
<a name="ln1512">           ;</a>
<a name="ln1513">}</a>
<a name="ln1514"> </a>
<a name="ln1515">// Kiku protects you from torment to a degree.</a>
<a name="ln1516">bool player_kiku_res_torment()</a>
<a name="ln1517">{</a>
<a name="ln1518">    // no protection during pain branding weapon</a>
<a name="ln1519">    return have_passive(passive_t::resist_torment)</a>
<a name="ln1520">           &amp;&amp; !(you_worship(GOD_KIKUBAAQUDGHA) &amp;&amp; you.gift_timeout);</a>
<a name="ln1521">}</a>
<a name="ln1522"> </a>
<a name="ln1523">// If temp is set to false, temporary sources or resistance won't be counted.</a>
<a name="ln1524">int player_res_poison(bool calc_unid, bool temp, bool items)</a>
<a name="ln1525">{</a>
<a name="ln1526">    switch (you.undead_state(temp))</a>
<a name="ln1527">    {</a>
<a name="ln1528">        case US_ALIVE:</a>
<a name="ln1529">            break;</a>
<a name="ln1530">        case US_HUNGRY_DEAD: //ghouls</a>
<a name="ln1531">        case US_UNDEAD: // mummies &amp; lichform</a>
<a name="ln1532">            return 3;</a>
<a name="ln1533">        case US_SEMI_UNDEAD: // vampire</a>
<a name="ln1534">            if (!you.vampire_alive) // XXX: &amp;&amp; temp?</a>
<a name="ln1535">                return 3;</a>
<a name="ln1536">            break;</a>
<a name="ln1537">    }</a>
<a name="ln1538"> </a>
<a name="ln1539">    if (you.is_nonliving(temp)</a>
<a name="ln1540">        || temp &amp;&amp; get_form()-&gt;res_pois() == 3</a>
<a name="ln1541">        || items &amp;&amp; player_equip_unrand(UNRAND_OLGREB)</a>
<a name="ln1542">        || temp &amp;&amp; you.duration[DUR_DIVINE_STAMINA])</a>
<a name="ln1543">    {</a>
<a name="ln1544">        return 3;</a>
<a name="ln1545">    }</a>
<a name="ln1546"> </a>
<a name="ln1547">    int rp = 0;</a>
<a name="ln1548"> </a>
<a name="ln1549">    if (items)</a>
<a name="ln1550">    {</a>
<a name="ln1551">        // rings of poison resistance</a>
<a name="ln1552">        rp += you.wearing(EQ_RINGS, RING_POISON_RESISTANCE, calc_unid);</a>
<a name="ln1553"> </a>
<a name="ln1554">        // Staves</a>
<a name="ln1555">        rp += you.wearing(EQ_STAFF, STAFF_POISON, calc_unid);</a>
<a name="ln1556"> </a>
<a name="ln1557">        // ego armour:</a>
<a name="ln1558">        rp += you.wearing_ego(EQ_ALL_ARMOUR, SPARM_POISON_RESISTANCE);</a>
<a name="ln1559"> </a>
<a name="ln1560">        // body armour:</a>
<a name="ln1561">        const item_def *body_armour = you.slot_item(EQ_BODY_ARMOUR);</a>
<a name="ln1562">        if (body_armour)</a>
<a name="ln1563">            rp += armour_type_prop(body_armour-&gt;sub_type, ARMF_RES_POISON);</a>
<a name="ln1564"> </a>
<a name="ln1565">        // rPois+ artefacts</a>
<a name="ln1566">        rp += you.scan_artefacts(ARTP_POISON, calc_unid);</a>
<a name="ln1567"> </a>
<a name="ln1568">        // dragonskin cloak: 0.5 to draconic resistances</a>
<a name="ln1569">        if (calc_unid &amp;&amp; player_equip_unrand(UNRAND_DRAGONSKIN) &amp;&amp; coinflip())</a>
<a name="ln1570">            rp++;</a>
<a name="ln1571">    }</a>
<a name="ln1572"> </a>
<a name="ln1573">    // mutations:</a>
<a name="ln1574">    rp += you.get_mutation_level(MUT_POISON_RESISTANCE, temp);</a>
<a name="ln1575">    rp += you.get_mutation_level(MUT_SLIMY_GREEN_SCALES, temp) == 3 ? 1 : 0;</a>
<a name="ln1576"> </a>
<a name="ln1577">    if (temp)</a>
<a name="ln1578">    {</a>
<a name="ln1579">        // potions/cards:</a>
<a name="ln1580">        if (you.duration[DUR_RESISTANCE])</a>
<a name="ln1581">            rp++;</a>
<a name="ln1582"> </a>
<a name="ln1583">        if (get_form()-&gt;res_pois() &gt; 0)</a>
<a name="ln1584">            rp++;</a>
<a name="ln1585">    }</a>
<a name="ln1586"> </a>
<a name="ln1587">    // Cap rPois at + before vulnerability effects are applied</a>
<a name="ln1588">    // (so carrying multiple rPois effects is never useful)</a>
<a name="ln1589">    rp = min(1, rp);</a>
<a name="ln1590"> </a>
<a name="ln1591">    if (temp)</a>
<a name="ln1592">    {</a>
<a name="ln1593">        if (get_form()-&gt;res_pois() &lt; 0)</a>
<a name="ln1594">            rp--;</a>
<a name="ln1595"> </a>
<a name="ln1596">        if (you.duration[DUR_POISON_VULN])</a>
<a name="ln1597">            rp--;</a>
<a name="ln1598">    }</a>
<a name="ln1599"> </a>
<a name="ln1600">    // don't allow rPois--, etc.</a>
<a name="ln1601">    rp = max(-1, rp);</a>
<a name="ln1602"> </a>
<a name="ln1603">    return rp;</a>
<a name="ln1604">}</a>
<a name="ln1605"> </a>
<a name="ln1606">int player_res_sticky_flame()</a>
<a name="ln1607">{</a>
<a name="ln1608">    return get_form()-&gt;res_sticky_flame();</a>
<a name="ln1609">}</a>
<a name="ln1610"> </a>
<a name="ln1611">int player_spec_death()</a>
<a name="ln1612">{</a>
<a name="ln1613">    int sd = 0;</a>
<a name="ln1614"> </a>
<a name="ln1615">    // Staves</a>
<a name="ln1616">    sd += you.wearing(EQ_STAFF, STAFF_DEATH);</a>
<a name="ln1617"> </a>
<a name="ln1618">    // species:</a>
<a name="ln1619">    sd += you.get_mutation_level(MUT_NECRO_ENHANCER);</a>
<a name="ln1620"> </a>
<a name="ln1621">    // transformations:</a>
<a name="ln1622">    if (you.form == transformation::lich)</a>
<a name="ln1623">        sd++;</a>
<a name="ln1624"> </a>
<a name="ln1625">    return sd;</a>
<a name="ln1626">}</a>
<a name="ln1627"> </a>
<a name="ln1628">int player_spec_fire()</a>
<a name="ln1629">{</a>
<a name="ln1630">    int sf = 0;</a>
<a name="ln1631"> </a>
<a name="ln1632">    // staves:</a>
<a name="ln1633">    sf += you.wearing(EQ_STAFF, STAFF_FIRE);</a>
<a name="ln1634"> </a>
<a name="ln1635">    // rings of fire:</a>
<a name="ln1636">    sf += you.wearing(EQ_RINGS, RING_FIRE);</a>
<a name="ln1637"> </a>
<a name="ln1638">    if (you.duration[DUR_FIRE_SHIELD])</a>
<a name="ln1639">        sf++;</a>
<a name="ln1640"> </a>
<a name="ln1641">    if (player_equip_unrand(UNRAND_ELEMENTAL_STAFF))</a>
<a name="ln1642">        sf++;</a>
<a name="ln1643"> </a>
<a name="ln1644">    return sf;</a>
<a name="ln1645">}</a>
<a name="ln1646"> </a>
<a name="ln1647">int player_spec_cold()</a>
<a name="ln1648">{</a>
<a name="ln1649">    int sc = 0;</a>
<a name="ln1650"> </a>
<a name="ln1651">    // staves:</a>
<a name="ln1652">    sc += you.wearing(EQ_STAFF, STAFF_COLD);</a>
<a name="ln1653"> </a>
<a name="ln1654">    // rings of ice:</a>
<a name="ln1655">    sc += you.wearing(EQ_RINGS, RING_ICE);</a>
<a name="ln1656"> </a>
<a name="ln1657">    if (player_equip_unrand(UNRAND_ELEMENTAL_STAFF))</a>
<a name="ln1658">        sc++;</a>
<a name="ln1659"> </a>
<a name="ln1660">    return sc;</a>
<a name="ln1661">}</a>
<a name="ln1662"> </a>
<a name="ln1663">int player_spec_earth()</a>
<a name="ln1664">{</a>
<a name="ln1665">    int se = 0;</a>
<a name="ln1666"> </a>
<a name="ln1667">    // Staves</a>
<a name="ln1668">    se += you.wearing(EQ_STAFF, STAFF_EARTH);</a>
<a name="ln1669"> </a>
<a name="ln1670">    if (player_equip_unrand(UNRAND_ELEMENTAL_STAFF))</a>
<a name="ln1671">        se++;</a>
<a name="ln1672"> </a>
<a name="ln1673">    return se;</a>
<a name="ln1674">}</a>
<a name="ln1675"> </a>
<a name="ln1676">int player_spec_air()</a>
<a name="ln1677">{</a>
<a name="ln1678">    int sa = 0;</a>
<a name="ln1679"> </a>
<a name="ln1680">    // Staves</a>
<a name="ln1681">    sa += you.wearing(EQ_STAFF, STAFF_AIR);</a>
<a name="ln1682"> </a>
<a name="ln1683">    if (player_equip_unrand(UNRAND_ELEMENTAL_STAFF))</a>
<a name="ln1684">        sa++;</a>
<a name="ln1685"> </a>
<a name="ln1686">    return sa;</a>
<a name="ln1687">}</a>
<a name="ln1688"> </a>
<a name="ln1689">int player_spec_conj()</a>
<a name="ln1690">{</a>
<a name="ln1691">    int sc = 0;</a>
<a name="ln1692"> </a>
<a name="ln1693">    // Staves</a>
<a name="ln1694">    sc += you.wearing(EQ_STAFF, STAFF_CONJURATION);</a>
<a name="ln1695"> </a>
<a name="ln1696">    if (player_equip_unrand(UNRAND_BATTLE))</a>
<a name="ln1697">        sc++;</a>
<a name="ln1698"> </a>
<a name="ln1699">    return sc;</a>
<a name="ln1700">}</a>
<a name="ln1701"> </a>
<a name="ln1702">int player_spec_hex()</a>
<a name="ln1703">{</a>
<a name="ln1704">    return 0;</a>
<a name="ln1705">}</a>
<a name="ln1706"> </a>
<a name="ln1707">int player_spec_charm()</a>
<a name="ln1708">{</a>
<a name="ln1709">    // Nothing, for the moment.</a>
<a name="ln1710">    return 0;</a>
<a name="ln1711">}</a>
<a name="ln1712"> </a>
<a name="ln1713">int player_spec_summ()</a>
<a name="ln1714">{</a>
<a name="ln1715">    int ss = 0;</a>
<a name="ln1716"> </a>
<a name="ln1717">    // Staves</a>
<a name="ln1718">    ss += you.wearing(EQ_STAFF, STAFF_SUMMONING);</a>
<a name="ln1719"> </a>
<a name="ln1720">    return ss;</a>
<a name="ln1721">}</a>
<a name="ln1722"> </a>
<a name="ln1723">int player_spec_poison()</a>
<a name="ln1724">{</a>
<a name="ln1725">    int sp = 0;</a>
<a name="ln1726"> </a>
<a name="ln1727">    // Staves</a>
<a name="ln1728">    sp += you.wearing(EQ_STAFF, STAFF_POISON);</a>
<a name="ln1729"> </a>
<a name="ln1730">    if (player_equip_unrand(UNRAND_OLGREB))</a>
<a name="ln1731">        sp++;</a>
<a name="ln1732"> </a>
<a name="ln1733">    return sp;</a>
<a name="ln1734">}</a>
<a name="ln1735"> </a>
<a name="ln1736">bool hungerless_spells()</a>
<a name="ln1737">{</a>
<a name="ln1738">    return you.wearing(EQ_STAFF, STAFF_ENERGY) || you.duration[DUR_BRILLIANCE];</a>
<a name="ln1739">}</a>
<a name="ln1740"> </a>
<a name="ln1741">// If temp is set to false, temporary sources of resistance won't be</a>
<a name="ln1742">// counted.</a>
<a name="ln1743">int player_prot_life(bool calc_unid, bool temp, bool items)</a>
<a name="ln1744">{</a>
<a name="ln1745">    int pl = 0;</a>
<a name="ln1746"> </a>
<a name="ln1747">    // Hunger is temporary, true, but that's something you can control,</a>
<a name="ln1748">    // especially as life protection only increases the hungrier you</a>
<a name="ln1749">    // get.</a>
<a name="ln1750">    if (you.species == SP_VAMPIRE &amp;&amp; !you.vampire_alive)</a>
<a name="ln1751">            pl = 3;</a>
<a name="ln1752"> </a>
<a name="ln1753">    // Same here. Your piety status, and, hence, TSO's protection, is</a>
<a name="ln1754">    // something you can more or less control.</a>
<a name="ln1755">    if (you_worship(GOD_SHINING_ONE))</a>
<a name="ln1756">    {</a>
<a name="ln1757">        if (you.piety &gt;= piety_breakpoint(1))</a>
<a name="ln1758">            pl++;</a>
<a name="ln1759">        if (you.piety &gt;= piety_breakpoint(3))</a>
<a name="ln1760">            pl++;</a>
<a name="ln1761">        if (you.piety &gt;= piety_breakpoint(5))</a>
<a name="ln1762">            pl++;</a>
<a name="ln1763">    }</a>
<a name="ln1764"> </a>
<a name="ln1765">    if (temp)</a>
<a name="ln1766">    {</a>
<a name="ln1767">        pl += get_form()-&gt;res_neg();</a>
<a name="ln1768"> </a>
<a name="ln1769">        // completely stoned, unlike statue which has some life force</a>
<a name="ln1770">        if (you.petrified())</a>
<a name="ln1771">            pl += 3;</a>
<a name="ln1772">    }</a>
<a name="ln1773"> </a>
<a name="ln1774">    if (items)</a>
<a name="ln1775">    {</a>
<a name="ln1776">        // rings</a>
<a name="ln1777">        pl += you.wearing(EQ_RINGS, RING_LIFE_PROTECTION, calc_unid);</a>
<a name="ln1778"> </a>
<a name="ln1779">        // armour (checks body armour only)</a>
<a name="ln1780">        pl += you.wearing_ego(EQ_ALL_ARMOUR, SPARM_POSITIVE_ENERGY);</a>
<a name="ln1781"> </a>
<a name="ln1782">        // pearl dragon counts</a>
<a name="ln1783">        const item_def *body_armour = you.slot_item(EQ_BODY_ARMOUR);</a>
<a name="ln1784">        if (body_armour)</a>
<a name="ln1785">            pl += armour_type_prop(body_armour-&gt;sub_type, ARMF_RES_NEG);</a>
<a name="ln1786"> </a>
<a name="ln1787">        // randart wpns</a>
<a name="ln1788">        pl += you.scan_artefacts(ARTP_NEGATIVE_ENERGY, calc_unid);</a>
<a name="ln1789"> </a>
<a name="ln1790">        // dragonskin cloak: 0.5 to draconic resistances</a>
<a name="ln1791">        if (calc_unid &amp;&amp; player_equip_unrand(UNRAND_DRAGONSKIN) &amp;&amp; coinflip())</a>
<a name="ln1792">            pl++;</a>
<a name="ln1793"> </a>
<a name="ln1794">        pl += you.wearing(EQ_STAFF, STAFF_DEATH, calc_unid);</a>
<a name="ln1795">    }</a>
<a name="ln1796"> </a>
<a name="ln1797">    // undead/demonic power</a>
<a name="ln1798">    pl += you.get_mutation_level(MUT_NEGATIVE_ENERGY_RESISTANCE, temp);</a>
<a name="ln1799"> </a>
<a name="ln1800">    pl = min(3, pl);</a>
<a name="ln1801"> </a>
<a name="ln1802">    return pl;</a>
<a name="ln1803">}</a>
<a name="ln1804"> </a>
<a name="ln1805">// New player movement speed system... allows for a bit more than</a>
<a name="ln1806">// &quot;player runs fast&quot; and &quot;player walks slow&quot; in that the speed is</a>
<a name="ln1807">// actually calculated (allowing for centaurs to get a bonus from</a>
<a name="ln1808">// swiftness and other such things). Levels of the mutation now</a>
<a name="ln1809">// also have meaning (before they all just meant fast). Most of</a>
<a name="ln1810">// this isn't as fast as it used to be (6 for having anything), but</a>
<a name="ln1811">// even a slight speed advantage is very good... and we certainly don't</a>
<a name="ln1812">// want to go past 6 (see below). -- bwr</a>
<a name="ln1813">int player_movement_speed()</a>
<a name="ln1814">{</a>
<a name="ln1815">    int mv = 10;</a>
<a name="ln1816"> </a>
<a name="ln1817">    // transformations</a>
<a name="ln1818">    if (you.form == transformation::bat)</a>
<a name="ln1819">        mv = 5; // but allowed minimum is six</a>
<a name="ln1820">    else if (you.form == transformation::pig)</a>
<a name="ln1821">        mv = 7;</a>
<a name="ln1822">    else if (you.form == transformation::wisp)</a>
<a name="ln1823">        mv = 8;</a>
<a name="ln1824">    else if (you.fishtail || you.form == transformation::hydra &amp;&amp; you.in_water())</a>
<a name="ln1825">        mv = 6;</a>
<a name="ln1826"> </a>
<a name="ln1827">    // Wading through water is very slow.</a>
<a name="ln1828">    if (you.in_water() &amp;&amp; !you.can_swim())</a>
<a name="ln1829">        mv += 6;</a>
<a name="ln1830"> </a>
<a name="ln1831">    // moving on liquefied ground, or while maintaining the</a>
<a name="ln1832">    // effect takes longer</a>
<a name="ln1833">    if (you.liquefied_ground() || you.duration[DUR_LIQUEFYING])</a>
<a name="ln1834">        mv += 3;</a>
<a name="ln1835"> </a>
<a name="ln1836">    // armour</a>
<a name="ln1837">    if (you.run())</a>
<a name="ln1838">        mv -= 1;</a>
<a name="ln1839"> </a>
<a name="ln1840">    mv += you.wearing_ego(EQ_ALL_ARMOUR, SPARM_PONDEROUSNESS);</a>
<a name="ln1841"> </a>
<a name="ln1842">    // Cheibriados</a>
<a name="ln1843">    if (have_passive(passive_t::slowed))</a>
<a name="ln1844">        mv += 2 + min(div_rand_round(you.piety, 20), 8);</a>
<a name="ln1845">    else if (player_under_penance(GOD_CHEIBRIADOS))</a>
<a name="ln1846">        mv += 2 + min(div_rand_round(you.piety_max[GOD_CHEIBRIADOS], 20), 8);</a>
<a name="ln1847"> </a>
<a name="ln1848">    // Tengu can move slightly faster when flying.</a>
<a name="ln1849">    if (you.tengu_flight())</a>
<a name="ln1850">        mv--;</a>
<a name="ln1851"> </a>
<a name="ln1852">    if (you.duration[DUR_FROZEN])</a>
<a name="ln1853">        mv += 3;</a>
<a name="ln1854"> </a>
<a name="ln1855">    // Mutations: -2, -3, -4, unless innate and shapechanged.</a>
<a name="ln1856">    if (int fast = you.get_mutation_level(MUT_FAST))</a>
<a name="ln1857">        mv -= fast + 1;</a>
<a name="ln1858"> </a>
<a name="ln1859">    if (int slow = you.get_mutation_level(MUT_SLOW))</a>
<a name="ln1860">    {</a>
<a name="ln1861">        mv *= 10 + slow * 2;</a>
<a name="ln1862">        mv /= 10;</a>
<a name="ln1863">    }</a>
<a name="ln1864"> </a>
<a name="ln1865">    if (you.duration[DUR_SWIFTNESS] &gt; 0 &amp;&amp; !you.in_liquid())</a>
<a name="ln1866">    {</a>
<a name="ln1867">        if (you.attribute[ATTR_SWIFTNESS] &gt; 0)</a>
<a name="ln1868">          mv = div_rand_round(3*mv, 4);</a>
<a name="ln1869">        else if (mv &gt;= 8)</a>
<a name="ln1870">          mv = div_rand_round(3*mv, 2);</a>
<a name="ln1871">        else if (mv == 7)</a>
<a name="ln1872">          mv = div_rand_round(7*6, 5); // balance for the cap at 6</a>
<a name="ln1873">    }</a>
<a name="ln1874"> </a>
<a name="ln1875">    // We'll use the old value of six as a minimum, with haste this could</a>
<a name="ln1876">    // end up as a speed of three, which is about as fast as we want</a>
<a name="ln1877">    // the player to be able to go (since 3 is 3.33x as fast and 2 is 5x,</a>
<a name="ln1878">    // which is a bit of a jump, and a bit too fast) -- bwr</a>
<a name="ln1879">    // Currently Haste takes 6 to 4, which is 2.5x as fast as delay 10</a>
<a name="ln1880">    // and still seems plenty fast. -- elliptic</a>
<a name="ln1881">    if (mv &lt; FASTEST_PLAYER_MOVE_SPEED)</a>
<a name="ln1882">        mv = FASTEST_PLAYER_MOVE_SPEED;</a>
<a name="ln1883"> </a>
<a name="ln1884">    return mv;</a>
<a name="ln1885">}</a>
<a name="ln1886"> </a>
<a name="ln1887">/**</a>
<a name="ln1888"> * Multiply the power of some evocation per the player's current evocations</a>
<a name="ln1889"> * enhancers.</a>
<a name="ln1890"> *</a>
<a name="ln1891"> * @param power         The base power of the evocation.</a>
<a name="ln1892"> * @param enhancers     Bonus enhancers to evocations (pak device surge).</a>
<a name="ln1893"> * @return              A modified power value.</a>
<a name="ln1894"> */</a>
<a name="ln1895">int player_adjust_evoc_power(const int power, int enhancers)</a>
<a name="ln1896">{</a>
<a name="ln1897">    const int total_enhancers = you.spec_evoke() + enhancers;</a>
<a name="ln1898">    return stepdown_spellpower(100 *apply_enhancement(power, total_enhancers));</a>
<a name="ln1899">}</a>
<a name="ln1900"> </a>
<a name="ln1901">// This function differs from the above in that it's used to set the</a>
<a name="ln1902">// initial time_taken value for the turn. Everything else (movement,</a>
<a name="ln1903">// spellcasting, combat) applies a ratio to this value.</a>
<a name="ln1904">int player_speed()</a>
<a name="ln1905">{</a>
<a name="ln1906">    int ps = 10;</a>
<a name="ln1907"> </a>
<a name="ln1908">    // When paralysed, speed is irrelevant.</a>
<a name="ln1909">    if (you.cannot_act())</a>
<a name="ln1910">        return ps;</a>
<a name="ln1911"> </a>
<a name="ln1912">    if (you.duration[DUR_SLOW] || have_stat_zero())</a>
<a name="ln1913">        ps = haste_mul(ps);</a>
<a name="ln1914"> </a>
<a name="ln1915">    if (you.duration[DUR_BERSERK] &amp;&amp; !have_passive(passive_t::no_haste))</a>
<a name="ln1916">        ps = berserk_div(ps);</a>
<a name="ln1917">    else if (you.duration[DUR_HASTE])</a>
<a name="ln1918">        ps = haste_div(ps);</a>
<a name="ln1919"> </a>
<a name="ln1920">    if (you.form == transformation::statue || you.duration[DUR_PETRIFYING])</a>
<a name="ln1921">    {</a>
<a name="ln1922">        ps *= 15;</a>
<a name="ln1923">        ps /= 10;</a>
<a name="ln1924">    }</a>
<a name="ln1925"> </a>
<a name="ln1926">    return ps;</a>
<a name="ln1927">}</a>
<a name="ln1928"> </a>
<a name="ln1929">bool is_effectively_light_armour(const item_def *item)</a>
<a name="ln1930">{</a>
<a name="ln1931">    return !item</a>
<a name="ln1932">           || (abs(property(*item, PARM_EVASION)) / 10 &lt; 5);</a>
<a name="ln1933">}</a>
<a name="ln1934"> </a>
<a name="ln1935">bool player_effectively_in_light_armour()</a>
<a name="ln1936">{</a>
<a name="ln1937">    const item_def *armour = you.slot_item(EQ_BODY_ARMOUR, false);</a>
<a name="ln1938">    return is_effectively_light_armour(armour);</a>
<a name="ln1939">}</a>
<a name="ln1940"> </a>
<a name="ln1941">// This function returns true if the player has a radically different</a>
<a name="ln1942">// shape... minor changes like blade hands don't count, also note</a>
<a name="ln1943">// that lich transformation doesn't change the character's shape</a>
<a name="ln1944">// (so we end up with Naga-liches, Spriggan-liches, Minotaur-liches)</a>
<a name="ln1945">// it just makes the character undead (with the benefits that implies). - bwr</a>
<a name="ln1946">bool player_is_shapechanged()</a>
<a name="ln1947">{</a>
<a name="ln1948">    if (you.form == transformation::none</a>
<a name="ln1949">        || you.form == transformation::blade_hands</a>
<a name="ln1950">        || you.form == transformation::lich</a>
<a name="ln1951">        || you.form == transformation::shadow</a>
<a name="ln1952">        || you.form == transformation::appendage)</a>
<a name="ln1953">    {</a>
<a name="ln1954">        return false;</a>
<a name="ln1955">    }</a>
<a name="ln1956"> </a>
<a name="ln1957">    return true;</a>
<a name="ln1958">}</a>
<a name="ln1959"> </a>
<a name="ln1960">void update_acrobat_status()</a>
<a name="ln1961">{</a>
<a name="ln1962">    if (!you.wearing(EQ_AMULET, AMU_ACROBAT) || !you.activated[EQ_AMULET])</a>
<a name="ln1963">        return;</a>
<a name="ln1964"> </a>
<a name="ln1965">    // Acrobat duration goes slightly into the next turn, giving the</a>
<a name="ln1966">    // player visual feedback of the EV bonus recieved.</a>
<a name="ln1967">    // This is assignment and not increment as acrobat duration depends</a>
<a name="ln1968">    // on player action.</a>
<a name="ln1969">    you.duration[DUR_ACROBAT] = you.time_taken+1;</a>
<a name="ln1970">    you.redraw_evasion = true;</a>
<a name="ln1971">}</a>
<a name="ln1972"> </a>
<a name="ln1973">// An evasion factor based on the player's body size, smaller == higher</a>
<a name="ln1974">// evasion size factor.</a>
<a name="ln1975">static int _player_evasion_size_factor(bool base = false)</a>
<a name="ln1976">{</a>
<a name="ln1977">    // XXX: you.body_size() implementations are incomplete, fix.</a>
<a name="ln1978">    const size_type size = you.body_size(PSIZE_BODY, base);</a>
<a name="ln1979">    return 2 * (SIZE_MEDIUM - size);</a>
<a name="ln1980">}</a>
<a name="ln1981"> </a>
<a name="ln1982">// Determines racial shield penalties (formicids get a bonus compared to</a>
<a name="ln1983">// other medium-sized races)</a>
<a name="ln1984">int player_shield_racial_factor()</a>
<a name="ln1985">{</a>
<a name="ln1986">    return max(1, 5 + (you.species == SP_FORMICID ? -2 // Same as trolls/centaurs/etc.</a>
<a name="ln1987">                                                  : _player_evasion_size_factor(true)));</a>
<a name="ln1988">}</a>
<a name="ln1989"> </a>
<a name="ln1990"> </a>
<a name="ln1991">// The total EV penalty to the player for all their worn armour items</a>
<a name="ln1992">// with a base EV penalty (i.e. EV penalty as a base armour property,</a>
<a name="ln1993">// not as a randart property).</a>
<a name="ln1994">static int _player_adjusted_evasion_penalty(const int scale)</a>
<a name="ln1995">{</a>
<a name="ln1996">    int piece_armour_evasion_penalty = 0;</a>
<a name="ln1997"> </a>
<a name="ln1998">    // Some lesser armours have small penalties now (barding).</a>
<a name="ln1999">    for (int i = EQ_MIN_ARMOUR; i &lt; EQ_MAX_ARMOUR; i++)</a>
<a name="ln2000">    {</a>
<a name="ln2001">        if (i == EQ_SHIELD || !you.slot_item(static_cast&lt;equipment_type&gt;(i)))</a>
<a name="ln2002">            continue;</a>
<a name="ln2003"> </a>
<a name="ln2004">        // [ds] Evasion modifiers for armour are negatives, change</a>
<a name="ln2005">        // those to positive for penalty calc.</a>
<a name="ln2006">        const int penalty = (-property(you.inv[you.equip[i]], PARM_EVASION))/3;</a>
<a name="ln2007">        if (penalty &gt; 0)</a>
<a name="ln2008">            piece_armour_evasion_penalty += penalty;</a>
<a name="ln2009">    }</a>
<a name="ln2010"> </a>
<a name="ln2011">    return piece_armour_evasion_penalty * scale / 10 +</a>
<a name="ln2012">           you.adjusted_body_armour_penalty(scale);</a>
<a name="ln2013">}</a>
<a name="ln2014"> </a>
<a name="ln2015">// Player EV bonuses for various effects and transformations. This</a>
<a name="ln2016">// does not include tengu/merfolk EV bonuses for flight/swimming.</a>
<a name="ln2017">static int _player_evasion_bonuses()</a>
<a name="ln2018">{</a>
<a name="ln2019">    int evbonus = 0;</a>
<a name="ln2020"> </a>
<a name="ln2021">    if (you.duration[DUR_AGILITY])</a>
<a name="ln2022">        evbonus += AGILITY_BONUS;</a>
<a name="ln2023"> </a>
<a name="ln2024">    evbonus += you.wearing(EQ_RINGS_PLUS, RING_EVASION);</a>
<a name="ln2025"> </a>
<a name="ln2026">    evbonus += you.scan_artefacts(ARTP_EVASION);</a>
<a name="ln2027"> </a>
<a name="ln2028">    // mutations</a>
<a name="ln2029">    evbonus += you.get_mutation_level(MUT_GELATINOUS_BODY);</a>
<a name="ln2030"> </a>
<a name="ln2031">    if (you.get_mutation_level(MUT_DISTORTION_FIELD))</a>
<a name="ln2032">        evbonus += you.get_mutation_level(MUT_DISTORTION_FIELD) + 1;</a>
<a name="ln2033"> </a>
<a name="ln2034">    // transformation penalties/bonuses not covered by size alone:</a>
<a name="ln2035">    if (you.get_mutation_level(MUT_SLOW_REFLEXES))</a>
<a name="ln2036">        evbonus -= you.get_mutation_level(MUT_SLOW_REFLEXES) * 5;</a>
<a name="ln2037"> </a>
<a name="ln2038">    // If you have an active amulet of the acrobat and just moved or waited, get massive</a>
<a name="ln2039">    // EV bonus.</a>
<a name="ln2040">    if (acrobat_boost_active())</a>
<a name="ln2041">        evbonus += 15;</a>
<a name="ln2042"> </a>
<a name="ln2043">    return evbonus;</a>
<a name="ln2044">}</a>
<a name="ln2045"> </a>
<a name="ln2046">// Player EV scaling for being flying tengu or swimming merfolk.</a>
<a name="ln2047">static int _player_scale_evasion(int prescaled_ev, const int scale)</a>
<a name="ln2048">{</a>
<a name="ln2049">    if (you.duration[DUR_PETRIFYING] || you.caught())</a>
<a name="ln2050">        prescaled_ev /= 2;</a>
<a name="ln2051"> </a>
<a name="ln2052">    // Merfolk get a 25% evasion bonus in water.</a>
<a name="ln2053">    if (you.fishtail)</a>
<a name="ln2054">    {</a>
<a name="ln2055">        const int ev_bonus = max(2 * scale, prescaled_ev / 4);</a>
<a name="ln2056">        return prescaled_ev + ev_bonus;</a>
<a name="ln2057">    }</a>
<a name="ln2058"> </a>
<a name="ln2059">    // Flying Tengu get a 20% evasion bonus.</a>
<a name="ln2060">    if (you.tengu_flight())</a>
<a name="ln2061">    {</a>
<a name="ln2062">        const int ev_bonus = max(1 * scale, prescaled_ev / 5);</a>
<a name="ln2063">        return prescaled_ev + ev_bonus;</a>
<a name="ln2064">    }</a>
<a name="ln2065"> </a>
<a name="ln2066">    return prescaled_ev;</a>
<a name="ln2067">}</a>
<a name="ln2068"> </a>
<a name="ln2069">/**</a>
<a name="ln2070"> * What is the player's bonus to EV from dodging when not paralysed, after</a>
<a name="ln2071"> * accounting for size &amp; body armour penalties?</a>
<a name="ln2072"> *</a>
<a name="ln2073"> * First, calculate base dodge bonus (linear with dodging * stepdowned dex),</a>
<a name="ln2074"> * and armour dodge penalty (base armour evp, increased for small races &amp;</a>
<a name="ln2075"> * decreased for large, then with a magic &quot;3&quot; subtracted from it to make the</a>
<a name="ln2076"> * penalties not too harsh).</a>
<a name="ln2077"> *</a>
<a name="ln2078"> * If the player's strength is greater than the armour dodge penalty, return</a>
<a name="ln2079"> *      base dodge * (1 - dodge_pen / (str*2)).</a>
<a name="ln2080"> * E.g., if str is twice dodge penalty, return 3/4 of base dodge. If</a>
<a name="ln2081"> * str = dodge_pen * 4, return 7/8...</a>
<a name="ln2082"> *</a>
<a name="ln2083"> * If str is less than dodge penalty, return</a>
<a name="ln2084"> *      base_dodge * str / (dodge_pen * 2).</a>
<a name="ln2085"> * E.g., if str = dodge_pen / 2, return 1/4 of base dodge. if</a>
<a name="ln2086"> * str = dodge_pen / 4, return 1/8...</a>
<a name="ln2087"> *</a>
<a name="ln2088"> * For either equation, if str = dodge_pen, the result is base_dodge/2.</a>
<a name="ln2089"> *</a>
<a name="ln2090"> * @param scale     A scale to multiply the result by, to avoid precision loss.</a>
<a name="ln2091"> * @return          A bonus to EV, multiplied by the scale.</a>
<a name="ln2092"> */</a>
<a name="ln2093">static int _player_armour_adjusted_dodge_bonus(int scale)</a>
<a name="ln2094">{</a>
<a name="ln2095">    const int ev_dex = stepdown(you.dex(), 18, ROUND_CLOSE, MAX_STAT_VALUE);</a>
<a name="ln2096"> </a>
<a name="ln2097">    const int dodge_bonus =</a>
<a name="ln2098">        (70 + you.skill(SK_DODGING, 10) * ev_dex) * scale</a>
<a name="ln2099">        / (20 - _player_evasion_size_factor()) / 10;</a>
<a name="ln2100"> </a>
<a name="ln2101">    const int armour_dodge_penalty = you.unadjusted_body_armour_penalty() - 3;</a>
<a name="ln2102">    if (armour_dodge_penalty &lt;= 0)</a>
<a name="ln2103">        return dodge_bonus;</a>
<a name="ln2104"> </a>
<a name="ln2105">    const int str = max(1, you.strength());</a>
<a name="ln2106">    if (armour_dodge_penalty &gt;= str)</a>
<a name="ln2107">        return dodge_bonus * str / (armour_dodge_penalty * 2);</a>
<a name="ln2108">    return dodge_bonus - dodge_bonus * armour_dodge_penalty / (str * 2);</a>
<a name="ln2109">}</a>
<a name="ln2110"> </a>
<a name="ln2111">// Total EV for player using the revised 0.6 evasion model.</a>
<a name="ln2112">static int _player_evasion(ev_ignore_type evit)</a>
<a name="ln2113">{</a>
<a name="ln2114">    const int size_factor = _player_evasion_size_factor();</a>
<a name="ln2115">    // Size is all that matters when paralysed or at 0 dex.</a>
<a name="ln2116">    if ((you.cannot_move() || you.duration[DUR_CLUMSY]</a>
<a name="ln2117">            || you.form == transformation::tree)</a>
<a name="ln2118">        &amp;&amp; !(evit &amp; ev_ignore::helpless))</a>
<a name="ln2119">    {</a>
<a name="ln2120">        return max(1, 2 + size_factor / 2);</a>
<a name="ln2121">    }</a>
<a name="ln2122"> </a>
<a name="ln2123">    const int scale = 100;</a>
<a name="ln2124">    const int size_base_ev = (10 + size_factor) * scale;</a>
<a name="ln2125"> </a>
<a name="ln2126">    const int vertigo_penalty = you.duration[DUR_VERTIGO] ? 5 * scale : 0;</a>
<a name="ln2127"> </a>
<a name="ln2128">    const int prestepdown_evasion =</a>
<a name="ln2129">        size_base_ev</a>
<a name="ln2130">        + _player_armour_adjusted_dodge_bonus(scale)</a>
<a name="ln2131">        - _player_adjusted_evasion_penalty(scale)</a>
<a name="ln2132">        - you.adjusted_shield_penalty(scale)</a>
<a name="ln2133">        - vertigo_penalty;</a>
<a name="ln2134"> </a>
<a name="ln2135">    const int poststepdown_evasion =</a>
<a name="ln2136">        stepdown_value(prestepdown_evasion, 20*scale, 30*scale, 60*scale, -1);</a>
<a name="ln2137"> </a>
<a name="ln2138">    const int evasion_bonuses = _player_evasion_bonuses() * scale;</a>
<a name="ln2139"> </a>
<a name="ln2140">    const int final_evasion =</a>
<a name="ln2141">        _player_scale_evasion(poststepdown_evasion, scale) + evasion_bonuses;</a>
<a name="ln2142"> </a>
<a name="ln2143">    return unscale_round_up(final_evasion, scale);</a>
<a name="ln2144">}</a>
<a name="ln2145"> </a>
<a name="ln2146">// Returns the spellcasting penalty (increase in spell failure) for the</a>
<a name="ln2147">// player's worn body armour and shield.</a>
<a name="ln2148">int player_armour_shield_spell_penalty()</a>
<a name="ln2149">{</a>
<a name="ln2150">    const int scale = 100;</a>
<a name="ln2151"> </a>
<a name="ln2152">    const int body_armour_penalty =</a>
<a name="ln2153">        max(19 * you.adjusted_body_armour_penalty(scale), 0);</a>
<a name="ln2154"> </a>
<a name="ln2155">    const int total_penalty = body_armour_penalty</a>
<a name="ln2156">                 + 19 * you.adjusted_shield_penalty(scale);</a>
<a name="ln2157"> </a>
<a name="ln2158">    return max(total_penalty, 0) / scale;</a>
<a name="ln2159">}</a>
<a name="ln2160"> </a>
<a name="ln2161">/**</a>
<a name="ln2162"> * How many spell-success-chance-boosting ('wizardry') effects can the player</a>
<a name="ln2163"> * apply to the given spell?</a>
<a name="ln2164"> *</a>
<a name="ln2165"> * @param spell     The type of spell being cast.</a>
<a name="ln2166"> * @return          The number of relevant wizardry effects.</a>
<a name="ln2167"> */</a>
<a name="ln2168">int player_wizardry(spell_type /*spell*/)</a>
<a name="ln2169">{</a>
<a name="ln2170">    return you.wearing(EQ_RINGS, RING_WIZARDRY)</a>
<a name="ln2171">           + you.wearing(EQ_STAFF, STAFF_WIZARDRY);</a>
<a name="ln2172">}</a>
<a name="ln2173"> </a>
<a name="ln2174">/**</a>
<a name="ln2175"> * Calculate the SH value used internally.</a>
<a name="ln2176"> *</a>
<a name="ln2177"> * Exactly twice the value displayed to players, for legacy reasons.</a>
<a name="ln2178"> * @return      The player's current SH value.</a>
<a name="ln2179"> */</a>
<a name="ln2180">int player_shield_class()</a>
<a name="ln2181">{</a>
<a name="ln2182">    int shield = 0;</a>
<a name="ln2183"> </a>
<a name="ln2184">    if (you.incapacitated())</a>
<a name="ln2185">        return 0;</a>
<a name="ln2186"> </a>
<a name="ln2187">    if (you.shield())</a>
<a name="ln2188">    {</a>
<a name="ln2189">        const item_def&amp; item = you.inv[you.equip[EQ_SHIELD]];</a>
<a name="ln2190">        int size_factor = (you.body_size(PSIZE_TORSO) - SIZE_MEDIUM)</a>
<a name="ln2191">                        * (item.sub_type - ARM_TOWER_SHIELD);</a>
<a name="ln2192">        int base_shield = property(item, PARM_AC) * 2 + size_factor;</a>
<a name="ln2193"> </a>
<a name="ln2194">        // bonus applied only to base, see above for effect:</a>
<a name="ln2195">        shield += base_shield * 50;</a>
<a name="ln2196">        shield += base_shield * you.skill(SK_SHIELDS, 5) / 2;</a>
<a name="ln2197"> </a>
<a name="ln2198">        shield += item.plus * 200;</a>
<a name="ln2199"> </a>
<a name="ln2200">        shield += you.skill(SK_SHIELDS, 38)</a>
<a name="ln2201">                + min(you.skill(SK_SHIELDS, 38), 3 * 38);</a>
<a name="ln2202"> </a>
<a name="ln2203">        int stat = 0;</a>
<a name="ln2204">        if (item.sub_type == ARM_BUCKLER)</a>
<a name="ln2205">            stat = you.dex() * 38;</a>
<a name="ln2206">        else if (item.sub_type == ARM_TOWER_SHIELD)</a>
<a name="ln2207">            stat = you.dex() * 12 + you.strength() * 26;</a>
<a name="ln2208">        else</a>
<a name="ln2209">            stat = you.dex() * 19 + you.strength() * 19;</a>
<a name="ln2210">        stat = stat * (base_shield + 13) / 26;</a>
<a name="ln2211"> </a>
<a name="ln2212">        shield += stat;</a>
<a name="ln2213">    }</a>
<a name="ln2214"> </a>
<a name="ln2215">    // mutations</a>
<a name="ln2216">    // +4, +6, +8 (displayed values)</a>
<a name="ln2217">    shield += (you.get_mutation_level(MUT_LARGE_BONE_PLATES) &gt; 0</a>
<a name="ln2218">               ? you.get_mutation_level(MUT_LARGE_BONE_PLATES) * 400 + 400</a>
<a name="ln2219">               : 0);</a>
<a name="ln2220"> </a>
<a name="ln2221">    shield += qazlal_sh_boost() * 100;</a>
<a name="ln2222">    shield += tso_sh_boost() * 100;</a>
<a name="ln2223">    shield += you.wearing(EQ_AMULET_PLUS, AMU_REFLECTION) * 200;</a>
<a name="ln2224">    shield += you.scan_artefacts(ARTP_SHIELDING) * 200;</a>
<a name="ln2225"> </a>
<a name="ln2226">    return (shield + 50) / 100;</a>
<a name="ln2227">}</a>
<a name="ln2228"> </a>
<a name="ln2229">/**</a>
<a name="ln2230"> * Calculate the SH value that should be displayed to players.</a>
<a name="ln2231"> *</a>
<a name="ln2232"> * Exactly half the internal value, for legacy reasons.</a>
<a name="ln2233"> * @return      The SH value to be displayed.</a>
<a name="ln2234"> */</a>
<a name="ln2235">int player_displayed_shield_class()</a>
<a name="ln2236">{</a>
<a name="ln2237">    return player_shield_class() / 2;</a>
<a name="ln2238">}</a>
<a name="ln2239"> </a>
<a name="ln2240">/**</a>
<a name="ln2241"> * Does the player have 'omnireflection' (the ability to reflect piercing</a>
<a name="ln2242"> * effects and enchantments)?</a>
<a name="ln2243"> *</a>
<a name="ln2244"> * @return      Whether the player has the Warlock's Mirror equipped.</a>
<a name="ln2245"> */</a>
<a name="ln2246">bool player_omnireflects()</a>
<a name="ln2247">{</a>
<a name="ln2248">    return player_equip_unrand(UNRAND_WARLOCK_MIRROR);</a>
<a name="ln2249">}</a>
<a name="ln2250"> </a>
<a name="ln2251">void forget_map(bool rot)</a>
<a name="ln2252">{</a>
<a name="ln2253">    ASSERT(!crawl_state.game_is_arena());</a>
<a name="ln2254"> </a>
<a name="ln2255">    // If forgetting was intentional, clear the travel trail.</a>
<a name="ln2256">    if (!rot)</a>
<a name="ln2257">        clear_travel_trail();</a>
<a name="ln2258"> </a>
<a name="ln2259">    const bool rot_resist = player_in_branch(BRANCH_ABYSS)</a>
<a name="ln2260">                            &amp;&amp; have_passive(passive_t::map_rot_res_abyss);</a>
<a name="ln2261">    const double geometric_chance = 0.99;</a>
<a name="ln2262">    const int radius = (rot_resist ? 200 : 100);</a>
<a name="ln2263"> </a>
<a name="ln2264">    const int scalar = 0xFF;</a>
<a name="ln2265">    for (rectangle_iterator ri(0); ri; ++ri)</a>
<a name="ln2266">    {</a>
<a name="ln2267">        const coord_def &amp;p = *ri;</a>
<a name="ln2268">        if (!env.map_knowledge(p).known() || you.see_cell(p))</a>
<a name="ln2269">            continue;</a>
<a name="ln2270"> </a>
<a name="ln2271">        if (rot)</a>
<a name="ln2272">        {</a>
<a name="ln2273">            const int dist = grid_distance(you.pos(), p);</a>
<a name="ln2274">            int chance = pow(geometric_chance,</a>
<a name="ln2275">                             max(1, (dist * dist - radius) / 40)) * scalar;</a>
<a name="ln2276">            if (x_chance_in_y(chance, scalar))</a>
<a name="ln2277">                continue;</a>
<a name="ln2278">        }</a>
<a name="ln2279"> </a>
<a name="ln2280">        if (you.see_cell(p))</a>
<a name="ln2281">            continue;</a>
<a name="ln2282"> </a>
<a name="ln2283">        env.map_knowledge(p).clear();</a>
<a name="ln2284">        if (env.map_forgotten)</a>
<a name="ln2285">            (*env.map_forgotten)(p).clear();</a>
<a name="ln2286">        StashTrack.update_stash(p);</a>
<a name="ln2287">#ifdef USE_TILE</a>
<a name="ln2288">        tile_forget_map(p);</a>
<a name="ln2289">#endif</a>
<a name="ln2290">    }</a>
<a name="ln2291"> </a>
<a name="ln2292">    ash_detect_portals(is_map_persistent());</a>
<a name="ln2293">#ifdef USE_TILE</a>
<a name="ln2294">    tiles.update_minimap_bounds();</a>
<a name="ln2295">#endif</a>
<a name="ln2296">}</a>
<a name="ln2297"> </a>
<a name="ln2298">static void _recover_stat()</a>
<a name="ln2299">{</a>
<a name="ln2300">    FixedVector&lt;int, NUM_STATS&gt; recovered_stats(0);</a>
<a name="ln2301"> </a>
<a name="ln2302">    while (you.attribute[ATTR_STAT_LOSS_XP] &lt;= 0)</a>
<a name="ln2303">    {</a>
<a name="ln2304">        stat_type stat = random_lost_stat();</a>
<a name="ln2305">        ASSERT(stat != NUM_STATS);</a>
<a name="ln2306"> </a>
<a name="ln2307">        recovered_stats[stat]++;</a>
<a name="ln2308"> </a>
<a name="ln2309">        // Very heavily drained stats recover faster.</a>
<a name="ln2310">        if (you.stat(stat, false) &lt; 0)</a>
<a name="ln2311">            recovered_stats[stat] += random2(-you.stat(stat, false) / 2);</a>
<a name="ln2312"> </a>
<a name="ln2313">        bool still_drained = false;</a>
<a name="ln2314">        for (int i = 0; i &lt; NUM_STATS; ++i)</a>
<a name="ln2315">            if (you.stat_loss[i] - recovered_stats[i] &gt; 0)</a>
<a name="ln2316">                still_drained = true;</a>
<a name="ln2317"> </a>
<a name="ln2318">        if (still_drained)</a>
<a name="ln2319">            you.attribute[ATTR_STAT_LOSS_XP] += stat_loss_roll();</a>
<a name="ln2320">        else</a>
<a name="ln2321">            break;</a>
<a name="ln2322">    }</a>
<a name="ln2323"> </a>
<a name="ln2324">    for (int i = 0; i &lt; NUM_STATS; ++i)</a>
<a name="ln2325">        if (recovered_stats[i] &gt; 0)</a>
<a name="ln2326">            restore_stat((stat_type) i, recovered_stats[i], false, true);</a>
<a name="ln2327">}</a>
<a name="ln2328"> </a>
<a name="ln2329">int get_exp_progress()</a>
<a name="ln2330">{</a>
<a name="ln2331">    if (you.experience_level &gt;= you.get_max_xl())</a>
<a name="ln2332">        return 0;</a>
<a name="ln2333"> </a>
<a name="ln2334">    const int current = exp_needed(you.experience_level);</a>
<a name="ln2335">    const int next    = exp_needed(you.experience_level + 1);</a>
<a name="ln2336">    if (next == current)</a>
<a name="ln2337">        return 0;</a>
<a name="ln2338">    return (you.experience - current) * 100 / (next - current);</a>
<a name="ln2339">}</a>
<a name="ln2340"> </a>
<a name="ln2341">static void _recharge_xp_evokers(int exp)</a>
<a name="ln2342">{</a>
<a name="ln2343">    FixedVector&lt;item_def*, NUM_MISCELLANY&gt; evokers(nullptr);</a>
<a name="ln2344">    list_charging_evokers(evokers);</a>
<a name="ln2345"> </a>
<a name="ln2346">    int xp_factor = max(min((int)exp_needed(you.experience_level+1, 0) * 2 / 7,</a>
<a name="ln2347">                             you.experience_level * 425),</a>
<a name="ln2348">                        you.experience_level*4 + 30)</a>
<a name="ln2349">                    / (3 + you.skill_rdiv(SK_EVOCATIONS, 2, 13));</a>
<a name="ln2350"> </a>
<a name="ln2351">    for (int i = 0; i &lt; NUM_MISCELLANY; ++i)</a>
<a name="ln2352">    {</a>
<a name="ln2353">        item_def* evoker = evokers[i];</a>
<a name="ln2354">        if (!evoker)</a>
<a name="ln2355">            continue;</a>
<a name="ln2356"> </a>
<a name="ln2357">        int &amp;debt = evoker_debt(evoker-&gt;sub_type);</a>
<a name="ln2358">        if (debt == 0)</a>
<a name="ln2359">            continue;</a>
<a name="ln2360"> </a>
<a name="ln2361">        const int old_charges = evoker_charges(i);</a>
<a name="ln2362">        debt = max(0, debt - div_rand_round(exp, xp_factor));</a>
<a name="ln2363">        const int gained = evoker_charges(i) - old_charges;</a>
<a name="ln2364">        if (!gained)</a>
<a name="ln2365">            continue;</a>
<a name="ln2366"> </a>
<a name="ln2367">        if (evoker_max_charges(i) == 1)</a>
<a name="ln2368">            mprf(&quot;%s has recharged.&quot;, evoker-&gt;name(DESC_YOUR).c_str());</a>
<a name="ln2369">        else</a>
<a name="ln2370">        {</a>
<a name="ln2371">            mprf(&quot;%s has regained %s charge%s.&quot;,</a>
<a name="ln2372">                 evoker-&gt;name(DESC_YOUR).c_str(),</a>
<a name="ln2373">                 number_in_words(gained).c_str(), gained &gt; 1 ? &quot;s&quot; : &quot;&quot;);</a>
<a name="ln2374">        }</a>
<a name="ln2375">    }</a>
<a name="ln2376">}</a>
<a name="ln2377"> </a>
<a name="ln2378">/// Make progress toward the abyss spawning an exit/stairs.</a>
<a name="ln2379">static void _reduce_abyss_xp_timer(int exp)</a>
<a name="ln2380">{</a>
<a name="ln2381">    if (!player_in_branch(BRANCH_ABYSS))</a>
<a name="ln2382">        return;</a>
<a name="ln2383"> </a>
<a name="ln2384">    const int xp_factor =</a>
<a name="ln2385">        max(min((int)exp_needed(you.experience_level+1, 0) / 7,</a>
<a name="ln2386">                you.experience_level * 425),</a>
<a name="ln2387">            you.experience_level*2 + 15) / 5;</a>
<a name="ln2388"> </a>
<a name="ln2389">    if (!you.props.exists(ABYSS_STAIR_XP_KEY))</a>
<a name="ln2390">        you.props[ABYSS_STAIR_XP_KEY] = EXIT_XP_COST;</a>
<a name="ln2391">    const int reqd_xp = you.props[ABYSS_STAIR_XP_KEY].get_int();</a>
<a name="ln2392">    const int new_req = reqd_xp - div_rand_round(exp, xp_factor);</a>
<a name="ln2393">    dprf(&quot;reducing xp timer from %d to %d (factor = %d)&quot;,</a>
<a name="ln2394">         reqd_xp, new_req, xp_factor);</a>
<a name="ln2395">    you.props[ABYSS_STAIR_XP_KEY].get_int() = new_req;</a>
<a name="ln2396">}</a>
<a name="ln2397"> </a>
<a name="ln2398">/// update penance for XP based gods</a>
<a name="ln2399">static void _handle_xp_penance(int exp)</a>
<a name="ln2400">{</a>
<a name="ln2401">    vector&lt;god_type&gt; xp_gods;</a>
<a name="ln2402">    for (god_iterator it; it; ++it)</a>
<a name="ln2403">    {</a>
<a name="ln2404">        if (xp_penance(*it))</a>
<a name="ln2405">            xp_gods.push_back(*it);</a>
<a name="ln2406">    }</a>
<a name="ln2407"> </a>
<a name="ln2408">    if (!xp_gods.empty())</a>
<a name="ln2409">    {</a>
<a name="ln2410">        god_type god = xp_gods[random2(xp_gods.size())];</a>
<a name="ln2411">        reduce_xp_penance(god, exp);</a>
<a name="ln2412">    }</a>
<a name="ln2413">}</a>
<a name="ln2414"> </a>
<a name="ln2415">/// update transfer knowledge</a>
<a name="ln2416">static void _transfer_knowledge(int exp)</a>
<a name="ln2417">{</a>
<a name="ln2418">    if (!(you.transfer_skill_points &gt; 0))</a>
<a name="ln2419">        return;</a>
<a name="ln2420"> </a>
<a name="ln2421">    // Can happen if the game got interrupted during target skill choice.</a>
<a name="ln2422">    if (is_invalid_skill(you.transfer_to_skill))</a>
<a name="ln2423">    {</a>
<a name="ln2424">        you.transfer_from_skill = SK_NONE;</a>
<a name="ln2425">        you.transfer_skill_points = 0;</a>
<a name="ln2426">        you.transfer_total_skill_points = 0;</a>
<a name="ln2427">    }</a>
<a name="ln2428">    else</a>
<a name="ln2429">    {</a>
<a name="ln2430">        int amount = exp * 20</a>
<a name="ln2431">        / calc_skill_cost(you.skill_cost_level);</a>
<a name="ln2432">        if (amount &gt;= 20 || one_chance_in(20 - amount))</a>
<a name="ln2433">        {</a>
<a name="ln2434">            amount = max(20, amount);</a>
<a name="ln2435">            transfer_skill_points(you.transfer_from_skill,</a>
<a name="ln2436">                                  you.transfer_to_skill, amount, false);</a>
<a name="ln2437">        }</a>
<a name="ln2438">    }</a>
<a name="ln2439">}</a>
<a name="ln2440"> </a>
<a name="ln2441">/// update temporary mutations</a>
<a name="ln2442">static void _handle_temp_mutation(int exp)</a>
<a name="ln2443">{</a>
<a name="ln2444">    if (!(you.attribute[ATTR_TEMP_MUTATIONS] &gt; 0))</a>
<a name="ln2445">        return;</a>
<a name="ln2446"> </a>
<a name="ln2447">    you.attribute[ATTR_TEMP_MUT_XP] -= exp;</a>
<a name="ln2448">    if (you.attribute[ATTR_TEMP_MUT_XP] &lt;= 0)</a>
<a name="ln2449">        temp_mutation_wanes();</a>
<a name="ln2450">}</a>
<a name="ln2451"> </a>
<a name="ln2452">/// update stat loss</a>
<a name="ln2453">static void _handle_stat_loss(int exp)</a>
<a name="ln2454">{</a>
<a name="ln2455">    if (!(you.attribute[ATTR_STAT_LOSS_XP] &gt; 0))</a>
<a name="ln2456">        return;</a>
<a name="ln2457"> </a>
<a name="ln2458">    int loss = div_rand_round(exp * 3 / 2,</a>
<a name="ln2459">                              max(1, calc_skill_cost(you.skill_cost_level) - 3));</a>
<a name="ln2460">    you.attribute[ATTR_STAT_LOSS_XP] -= loss;</a>
<a name="ln2461">    dprf(&quot;Stat loss points: %d&quot;, you.attribute[ATTR_STAT_LOSS_XP]);</a>
<a name="ln2462">    if (you.attribute[ATTR_STAT_LOSS_XP] &lt;= 0)</a>
<a name="ln2463">        _recover_stat();</a>
<a name="ln2464">}</a>
<a name="ln2465"> </a>
<a name="ln2466">/// update xp drain</a>
<a name="ln2467">static void _handle_xp_drain(int exp)</a>
<a name="ln2468">{</a>
<a name="ln2469">    if (!you.attribute[ATTR_XP_DRAIN])</a>
<a name="ln2470">        return;</a>
<a name="ln2471"> </a>
<a name="ln2472">    int loss = div_rand_round(exp * 3 / 2,</a>
<a name="ln2473">                              calc_skill_cost(you.skill_cost_level));</a>
<a name="ln2474"> </a>
<a name="ln2475">    // Make it easier to recover from very heavy levels of draining</a>
<a name="ln2476">    // (they're nasty enough as it is)</a>
<a name="ln2477">    loss = loss * (1 + (you.attribute[ATTR_XP_DRAIN] / 250.0f));</a>
<a name="ln2478"> </a>
<a name="ln2479">    dprf(&quot;Lost %d of %d draining points&quot;, loss, you.attribute[ATTR_XP_DRAIN]);</a>
<a name="ln2480"> </a>
<a name="ln2481">    you.attribute[ATTR_XP_DRAIN] -= loss;</a>
<a name="ln2482">    // Regaining skills may affect AC/EV.</a>
<a name="ln2483">    you.redraw_armour_class = true;</a>
<a name="ln2484">    you.redraw_evasion = true;</a>
<a name="ln2485">    if (you.attribute[ATTR_XP_DRAIN] &lt;= 0)</a>
<a name="ln2486">    {</a>
<a name="ln2487">        you.attribute[ATTR_XP_DRAIN] = 0;</a>
<a name="ln2488">        mprf(MSGCH_RECOVERY, &quot;Your life force feels restored.&quot;);</a>
<a name="ln2489">    }</a>
<a name="ln2490">}</a>
<a name="ln2491"> </a>
<a name="ln2492">static void _handle_god_wrath(int exp)</a>
<a name="ln2493">{</a>
<a name="ln2494">    for (god_iterator it; it; ++it)</a>
<a name="ln2495">    {</a>
<a name="ln2496">        if (active_penance(*it))</a>
<a name="ln2497">        {</a>
<a name="ln2498">            you.attribute[ATTR_GOD_WRATH_XP] -= exp;</a>
<a name="ln2499">            while (you.attribute[ATTR_GOD_WRATH_XP] &lt; 0)</a>
<a name="ln2500">            {</a>
<a name="ln2501">                you.attribute[ATTR_GOD_WRATH_COUNT]++;</a>
<a name="ln2502">                set_penance_xp_timeout();</a>
<a name="ln2503">            }</a>
<a name="ln2504">            break;</a>
<a name="ln2505">        }</a>
<a name="ln2506">    }</a>
<a name="ln2507">}</a>
<a name="ln2508"> </a>
<a name="ln2509">void gain_exp(unsigned int exp_gained, unsigned int* actual_gain)</a>
<a name="ln2510">{</a>
<a name="ln2511">    if (crawl_state.game_is_arena())</a>
<a name="ln2512">        return;</a>
<a name="ln2513"> </a>
<a name="ln2514">    // xp-gated effects that don't use sprint inflation</a>
<a name="ln2515">    _handle_xp_penance(exp_gained);</a>
<a name="ln2516">    _handle_god_wrath(exp_gained);</a>
<a name="ln2517">    _transfer_knowledge(exp_gained);</a>
<a name="ln2518"> </a>
<a name="ln2519">    // evolution mutation timer</a>
<a name="ln2520">    you.attribute[ATTR_EVOL_XP] += exp_gained;</a>
<a name="ln2521"> </a>
<a name="ln2522">    // modified experience due to sprint inflation</a>
<a name="ln2523">    unsigned int skill_xp = exp_gained;</a>
<a name="ln2524">    if (crawl_state.game_is_sprint())</a>
<a name="ln2525">        skill_xp = sprint_modify_exp(skill_xp);</a>
<a name="ln2526"> </a>
<a name="ln2527">    // xp-gated effects that use sprint inflation</a>
<a name="ln2528">    _handle_stat_loss(skill_xp);</a>
<a name="ln2529">    _handle_temp_mutation(skill_xp);</a>
<a name="ln2530">    _recharge_xp_evokers(skill_xp);</a>
<a name="ln2531">    _reduce_abyss_xp_timer(skill_xp);</a>
<a name="ln2532">    _handle_xp_drain(skill_xp);</a>
<a name="ln2533"> </a>
<a name="ln2534">    if (player_under_penance(GOD_HEPLIAKLQANA))</a>
<a name="ln2535">        return; // no xp for you!</a>
<a name="ln2536"> </a>
<a name="ln2537">    // handle actual experience gains,</a>
<a name="ln2538">    // i.e. XL and skills</a>
<a name="ln2539"> </a>
<a name="ln2540">    const unsigned int old_exp = you.experience;</a>
<a name="ln2541"> </a>
<a name="ln2542">    dprf(&quot;gain_exp: %d&quot;, exp_gained);</a>
<a name="ln2543"> </a>
<a name="ln2544">    if (you.experience + exp_gained &gt; (unsigned int)MAX_EXP_TOTAL)</a>
<a name="ln2545">        you.experience = MAX_EXP_TOTAL;</a>
<a name="ln2546">    else</a>
<a name="ln2547">        you.experience += exp_gained;</a>
<a name="ln2548"> </a>
<a name="ln2549">    you.exp_available += 10 * skill_xp;</a>
<a name="ln2550"> </a>
<a name="ln2551">    train_skills();</a>
<a name="ln2552">    while (check_selected_skills()</a>
<a name="ln2553">           &amp;&amp; you.exp_available &gt;= calc_skill_cost(you.skill_cost_level))</a>
<a name="ln2554">    {</a>
<a name="ln2555">        train_skills();</a>
<a name="ln2556">    }</a>
<a name="ln2557"> </a>
<a name="ln2558">    level_change();</a>
<a name="ln2559"> </a>
<a name="ln2560">    if (actual_gain != nullptr)</a>
<a name="ln2561">        *actual_gain = you.experience - old_exp;</a>
<a name="ln2562">}</a>
<a name="ln2563"> </a>
<a name="ln2564">bool will_gain_life(int lev)</a>
<a name="ln2565">{</a>
<a name="ln2566">    if (lev &lt; you.attribute[ATTR_LIFE_GAINED] - 2)</a>
<a name="ln2567">        return false;</a>
<a name="ln2568"> </a>
<a name="ln2569">    return you.lives + you.deaths &lt; (lev - 1) / 3;</a>
<a name="ln2570">}</a>
<a name="ln2571"> </a>
<a name="ln2572">static void _felid_extra_life()</a>
<a name="ln2573">{</a>
<a name="ln2574">    if (will_gain_life(you.max_level)</a>
<a name="ln2575">        &amp;&amp; you.lives &lt; 2)</a>
<a name="ln2576">    {</a>
<a name="ln2577">        you.lives++;</a>
<a name="ln2578">        mprf(MSGCH_INTRINSIC_GAIN, &quot;Extra life!&quot;);</a>
<a name="ln2579">        you.attribute[ATTR_LIFE_GAINED] = you.max_level;</a>
<a name="ln2580">        // Should play the 1UP sound from SMB...</a>
<a name="ln2581">    }</a>
<a name="ln2582">}</a>
<a name="ln2583"> </a>
<a name="ln2584">static void _gain_and_note_hp_mp()</a>
<a name="ln2585">{</a>
<a name="ln2586">    const int old_mp = you.magic_points;</a>
<a name="ln2587">    const int old_maxmp = you.max_magic_points;</a>
<a name="ln2588"> </a>
<a name="ln2589">    // recalculate for game</a>
<a name="ln2590">    calc_hp(true, false);</a>
<a name="ln2591">    calc_mp();</a>
<a name="ln2592"> </a>
<a name="ln2593">    set_mp(old_maxmp &gt; 0 ? old_mp * you.max_magic_points / old_maxmp</a>
<a name="ln2594">           : you.max_magic_points);</a>
<a name="ln2595"> </a>
<a name="ln2596">    // Get &quot;real&quot; values for note-taking, i.e. ignore Berserk,</a>
<a name="ln2597">    // transformations or equipped items.</a>
<a name="ln2598">    const int note_maxhp = get_real_hp(false, true);</a>
<a name="ln2599">    const int note_maxmp = get_real_mp(false);</a>
<a name="ln2600"> </a>
<a name="ln2601">    char buf[200];</a>
<a name="ln2602">    sprintf(buf, &quot;HP: %d/%d MP: %d/%d&quot;,</a>
<a name="ln2603">            min(you.hp, note_maxhp), note_maxhp,</a>
<a name="ln2604">            min(you.magic_points, note_maxmp), note_maxmp);</a>
<a name="ln2605">    take_note(Note(NOTE_XP_LEVEL_CHANGE, you.experience_level, 0, buf));</a>
<a name="ln2606">}</a>
<a name="ln2607"> </a>
<a name="ln2608">/**</a>
<a name="ln2609"> * Calculate max HP changes and scale current HP accordingly.</a>
<a name="ln2610"> */</a>
<a name="ln2611">void calc_hp(bool scale, bool set)</a>
<a name="ln2612">{</a>
<a name="ln2613">    // Rounding must be down or Deep Dwarves would abuse certain values.</a>
<a name="ln2614">    // We can reduce errors by a factor of 100 by using partial hp we have.</a>
<a name="ln2615">    int oldhp = you.hp;</a>
<a name="ln2616">    int old_max = you.hp_max;</a>
<a name="ln2617"> </a>
<a name="ln2618">    you.hp_max = get_real_hp(true, true);</a>
<a name="ln2619"> </a>
<a name="ln2620">    if (scale)</a>
<a name="ln2621">    {</a>
<a name="ln2622">        int hp = you.hp * 100 + you.hit_points_regeneration;</a>
<a name="ln2623">        int new_max = you.hp_max;</a>
<a name="ln2624">        hp = hp * new_max / old_max;</a>
<a name="ln2625">        if (hp &lt; 100)</a>
<a name="ln2626">            hp = 100;</a>
<a name="ln2627">        set_hp(min(hp / 100, you.hp_max));</a>
<a name="ln2628">        you.hit_points_regeneration = hp % 100;</a>
<a name="ln2629">    }</a>
<a name="ln2630">    if (set)</a>
<a name="ln2631">        you.hp = you.hp_max;</a>
<a name="ln2632"> </a>
<a name="ln2633">    you.hp = min(you.hp, you.hp_max);</a>
<a name="ln2634"> </a>
<a name="ln2635">    if (oldhp != you.hp || old_max != you.hp_max)</a>
<a name="ln2636">    {</a>
<a name="ln2637">        dprf(&quot;HP changed: %d/%d -&gt; %d/%d&quot;, oldhp, old_max, you.hp, you.hp_max);</a>
<a name="ln2638">        you.redraw_hit_points = true;</a>
<a name="ln2639">    }</a>
<a name="ln2640">}</a>
<a name="ln2641"> </a>
<a name="ln2642">int xp_to_level_diff(int xp, int scale)</a>
<a name="ln2643">{</a>
<a name="ln2644">    ASSERT(xp &gt;= 0);</a>
<a name="ln2645">    const int adjusted_xp = you.experience + xp;</a>
<a name="ln2646">    int projected_level = you.experience_level;</a>
<a name="ln2647">    while (you.experience &gt;= exp_needed(projected_level + 1))</a>
<a name="ln2648">        projected_level++; // handle xl 27 chars</a>
<a name="ln2649">    int adjusted_level = projected_level;</a>
<a name="ln2650"> </a>
<a name="ln2651">    // closest whole number level, rounding down</a>
<a name="ln2652">    while (adjusted_xp &gt;= (int) exp_needed(adjusted_level + 1))</a>
<a name="ln2653">        adjusted_level++;</a>
<a name="ln2654">    if (scale &gt; 1)</a>
<a name="ln2655">    {</a>
<a name="ln2656">        // TODO: what is up with all the casts here?</a>
<a name="ln2657"> </a>
<a name="ln2658">        // decimal scaled version of current level including whatever fractional</a>
<a name="ln2659">        // part scale can handle</a>
<a name="ln2660">        const int cur_level_scaled = projected_level * scale</a>
<a name="ln2661">                + (you.experience - (int) exp_needed(projected_level)) * scale /</a>
<a name="ln2662">                    ((int) exp_needed(projected_level + 1)</a>
<a name="ln2663">                                    - (int) exp_needed(projected_level));</a>
<a name="ln2664"> </a>
<a name="ln2665">        // decimal scaled version of what adjusted_xp would get you</a>
<a name="ln2666">        const int adjusted_level_scaled = adjusted_level * scale</a>
<a name="ln2667">                + (adjusted_xp - (int) exp_needed(adjusted_level)) * scale /</a>
<a name="ln2668">                    ((int) exp_needed(adjusted_level + 1)</a>
<a name="ln2669">                                    - (int) exp_needed(adjusted_level));</a>
<a name="ln2670">        // TODO: this would be more usable with better rounding behaviour</a>
<a name="ln2671">        return adjusted_level_scaled - cur_level_scaled;</a>
<a name="ln2672">    } else</a>
<a name="ln2673">        return adjusted_level - projected_level;</a>
<a name="ln2674">}</a>
<a name="ln2675"> </a>
<a name="ln2676">/**</a>
<a name="ln2677"> * Handle the effects from a player's change in XL.</a>
<a name="ln2678"> * @param aux                     A string describing the cause of the level</a>
<a name="ln2679"> *                                change.</a>
<a name="ln2680"> * @param skip_attribute_increase If true and XL has increased, don't process</a>
<a name="ln2681"> *                                stat gains. Currently only used by wizmode</a>
<a name="ln2682"> *                                commands.</a>
<a name="ln2683"> */</a>
<a name="ln2684">void level_change(bool skip_attribute_increase)</a>
<a name="ln2685">{</a>
<a name="ln2686">    // necessary for the time being, as level_change() is called</a>
<a name="ln2687">    // directly sometimes {dlb}</a>
<a name="ln2688">    you.redraw_experience = true;</a>
<a name="ln2689"> </a>
<a name="ln2690">    while (you.experience &lt; exp_needed(you.experience_level))</a>
<a name="ln2691">        lose_level();</a>
<a name="ln2692"> </a>
<a name="ln2693">    while (you.experience_level &lt; you.get_max_xl()</a>
<a name="ln2694">           &amp;&amp; you.experience &gt;= exp_needed(you.experience_level + 1))</a>
<a name="ln2695">    {</a>
<a name="ln2696">        if (!skip_attribute_increase)</a>
<a name="ln2697">        {</a>
<a name="ln2698">            crawl_state.cancel_cmd_all();</a>
<a name="ln2699"> </a>
<a name="ln2700">            if (is_processing_macro())</a>
<a name="ln2701">                flush_input_buffer(FLUSH_ABORT_MACRO);</a>
<a name="ln2702">        }</a>
<a name="ln2703"> </a>
<a name="ln2704">        // [ds] Make sure we increment you.experience_level and apply</a>
<a name="ln2705">        // any stat/hp increases only after we've cleared all prompts</a>
<a name="ln2706">        // for this experience level. If we do part of the work before</a>
<a name="ln2707">        // the prompt, and a player on telnet gets disconnected, the</a>
<a name="ln2708">        // SIGHUP will save Crawl in the in-between state and rob the</a>
<a name="ln2709">        // player of their level-up perks.</a>
<a name="ln2710"> </a>
<a name="ln2711">        const int new_exp = you.experience_level + 1;</a>
<a name="ln2712">        // some species need to do this at a specific time; most just do it at the end</a>
<a name="ln2713">        bool updated_maxhp = false;</a>
<a name="ln2714"> </a>
<a name="ln2715">        if (new_exp &lt;= you.max_level)</a>
<a name="ln2716">        {</a>
<a name="ln2717">            mprf(MSGCH_INTRINSIC_GAIN,</a>
<a name="ln2718">                 &quot;Welcome back to level %d!&quot;, new_exp);</a>
<a name="ln2719"> </a>
<a name="ln2720">            // No more prompts for this XL past this point.</a>
<a name="ln2721"> </a>
<a name="ln2722">            you.experience_level = new_exp;</a>
<a name="ln2723">        }</a>
<a name="ln2724">        else  // Character has gained a new level</a>
<a name="ln2725">        {</a>
<a name="ln2726">            // Don't want to see the dead creature at the prompt.</a>
<a name="ln2727">            redraw_screen();</a>
<a name="ln2728"> </a>
<a name="ln2729">            if (new_exp == 27)</a>
<a name="ln2730">                mprf(MSGCH_INTRINSIC_GAIN, &quot;You have reached level 27, the final one!&quot;);</a>
<a name="ln2731">            else if (new_exp == you.get_max_xl())</a>
<a name="ln2732">                mprf(MSGCH_INTRINSIC_GAIN, &quot;You have reached level %d, the highest you will ever reach!&quot;,</a>
<a name="ln2733">                        you.get_max_xl());</a>
<a name="ln2734">            else</a>
<a name="ln2735">            {</a>
<a name="ln2736">                mprf(MSGCH_INTRINSIC_GAIN, &quot;You have reached level %d!&quot;,</a>
<a name="ln2737">                     new_exp);</a>
<a name="ln2738">            }</a>
<a name="ln2739"> </a>
<a name="ln2740">            const bool manual_stat_level = new_exp % 3 == 0;  // 3,6,9,12...</a>
<a name="ln2741"> </a>
<a name="ln2742">            // Must do this before actually changing experience_level,</a>
<a name="ln2743">            // so we will re-prompt on load if a hup is received.</a>
<a name="ln2744">            if (manual_stat_level &amp;&amp; !skip_attribute_increase)</a>
<a name="ln2745">                if (!attribute_increase())</a>
<a name="ln2746">                    return; // abort level gain, the xp is still there</a>
<a name="ln2747"> </a>
<a name="ln2748">            // Set this after printing, since a more() might clear it.</a>
<a name="ln2749">            you.redraw_experience = true;</a>
<a name="ln2750"> </a>
<a name="ln2751">            crawl_state.stat_gain_prompt = false;</a>
<a name="ln2752">            you.experience_level = new_exp;</a>
<a name="ln2753">            you.max_level = you.experience_level;</a>
<a name="ln2754"> </a>
<a name="ln2755">#ifdef USE_TILE_LOCAL</a>
<a name="ln2756">            // In case of intrinsic ability changes.</a>
<a name="ln2757">            tiles.layout_statcol();</a>
<a name="ln2758">            redraw_screen();</a>
<a name="ln2759">#endif</a>
<a name="ln2760">            if (!skip_attribute_increase)</a>
<a name="ln2761">                species_stat_gain(you.species);</a>
<a name="ln2762"> </a>
<a name="ln2763">            switch (you.species)</a>
<a name="ln2764">            {</a>
<a name="ln2765">            case SP_VAMPIRE:</a>
<a name="ln2766">                if (you.experience_level == 3)</a>
<a name="ln2767">                {</a>
<a name="ln2768">                    if (you.vampire_alive)</a>
<a name="ln2769">                    {</a>
<a name="ln2770">                        mprf(MSGCH_INTRINSIC_GAIN, &quot;If you were bloodless &quot;</a>
<a name="ln2771">                             &quot;you could now transform into a vampire bat.&quot;);</a>
<a name="ln2772">                    }</a>
<a name="ln2773">                    else</a>
<a name="ln2774">                    {</a>
<a name="ln2775">                        mprf(MSGCH_INTRINSIC_GAIN,</a>
<a name="ln2776">                             &quot;You can now transform into a vampire bat.&quot;);</a>
<a name="ln2777">                    }</a>
<a name="ln2778">                }</a>
<a name="ln2779">                break;</a>
<a name="ln2780"> </a>
<a name="ln2781">            case SP_NAGA:</a>
<a name="ln2782">                if (!(you.experience_level % 3))</a>
<a name="ln2783">                {</a>
<a name="ln2784">                    mprf(MSGCH_INTRINSIC_GAIN, &quot;Your skin feels tougher.&quot;);</a>
<a name="ln2785">                    you.redraw_armour_class = true;</a>
<a name="ln2786">                }</a>
<a name="ln2787">                break;</a>
<a name="ln2788"> </a>
<a name="ln2789">            case SP_BASE_DRACONIAN:</a>
<a name="ln2790">                if (you.experience_level &gt;= 7)</a>
<a name="ln2791">                {</a>
<a name="ln2792">                    you.species = random_draconian_colour();</a>
<a name="ln2793"> </a>
<a name="ln2794">                    // We just changed our aptitudes, so some skills may now</a>
<a name="ln2795">                    // be at the wrong level (with negative progress); if we</a>
<a name="ln2796">                    // print anything in this condition, we might trigger a</a>
<a name="ln2797">                    // --More--, a redraw, and a crash (#6376 on Mantis).</a>
<a name="ln2798">                    //</a>
<a name="ln2799">                    // Hence we first fix up our skill levels silently (passing</a>
<a name="ln2800">                    // do_level_up = false) but save the old values; then when</a>
<a name="ln2801">                    // we want the messages later, we restore the old skill</a>
<a name="ln2802">                    // levels and call check_skill_level_change() again, this</a>
<a name="ln2803">                    // time passing do_level_up = true.</a>
<a name="ln2804"> </a>
<a name="ln2805">                    uint8_t saved_skills[NUM_SKILLS];</a>
<a name="ln2806">                    for (skill_type sk = SK_FIRST_SKILL; sk &lt; NUM_SKILLS; ++sk)</a>
<a name="ln2807">                    {</a>
<a name="ln2808">                        saved_skills[sk] = you.skills[sk];</a>
<a name="ln2809">                        check_skill_level_change(sk, false);</a>
<a name="ln2810">                    }</a>
<a name="ln2811">                    // The player symbol depends on species.</a>
<a name="ln2812">                    update_player_symbol();</a>
<a name="ln2813">#ifdef USE_TILE</a>
<a name="ln2814">                    init_player_doll();</a>
<a name="ln2815">#endif</a>
<a name="ln2816">                    mprf(MSGCH_INTRINSIC_GAIN,</a>
<a name="ln2817">                         &quot;Your scales start taking on %s colour.&quot;,</a>
<a name="ln2818">                         article_a(scale_type(you.species)).c_str());</a>
<a name="ln2819"> </a>
<a name="ln2820">                    // Produce messages about skill increases/decreases. We</a>
<a name="ln2821">                    // restore one skill level at a time so that at most the</a>
<a name="ln2822">                    // skill being checked is at the wrong level.</a>
<a name="ln2823">                    for (skill_type sk = SK_FIRST_SKILL; sk &lt; NUM_SKILLS; ++sk)</a>
<a name="ln2824">                    {</a>
<a name="ln2825">                        const int oldapt = species_apt(sk, SP_BASE_DRACONIAN);</a>
<a name="ln2826">                        const int newapt = species_apt(sk, you.species);</a>
<a name="ln2827">                        if (oldapt != newapt)</a>
<a name="ln2828">                        {</a>
<a name="ln2829">                            mprf(MSGCH_INTRINSIC_GAIN, &quot;You learn %s %s%s.&quot;,</a>
<a name="ln2830">                                 skill_name(sk),</a>
<a name="ln2831">                                 abs(oldapt - newapt) &gt; 1 ? &quot;much &quot; : &quot;&quot;,</a>
<a name="ln2832">                                 oldapt &gt; newapt ? &quot;slower&quot; : &quot;quicker&quot;);</a>
<a name="ln2833">                        }</a>
<a name="ln2834"> </a>
<a name="ln2835">                        you.skills[sk] = saved_skills[sk];</a>
<a name="ln2836">                        check_skill_level_change(sk);</a>
<a name="ln2837">                    }</a>
<a name="ln2838"> </a>
<a name="ln2839">                    // It's possible we passed a training target due to</a>
<a name="ln2840">                    // skills being rescaled to new aptitudes. Thus, we must</a>
<a name="ln2841">                    // check the training targets.</a>
<a name="ln2842">                    check_training_targets();</a>
<a name="ln2843"> </a>
<a name="ln2844">                    // Tell the player about their new species</a>
<a name="ln2845">                    for (auto &amp;mut : fake_mutations(you.species, false))</a>
<a name="ln2846">                        mprf(MSGCH_INTRINSIC_GAIN, &quot;%s&quot;, mut.c_str());</a>
<a name="ln2847"> </a>
<a name="ln2848">                    // needs to be done early here, so HP doesn't look rotted</a>
<a name="ln2849">                    // when we redraw the screen</a>
<a name="ln2850">                    _gain_and_note_hp_mp();</a>
<a name="ln2851">                    updated_maxhp = true;</a>
<a name="ln2852"> </a>
<a name="ln2853">                    redraw_screen();</a>
<a name="ln2854">                }</a>
<a name="ln2855">                break;</a>
<a name="ln2856"> </a>
<a name="ln2857">            case SP_DEMONSPAWN:</a>
<a name="ln2858">            {</a>
<a name="ln2859">                bool gave_message = false;</a>
<a name="ln2860">                int level = 0;</a>
<a name="ln2861">                mutation_type first_body_facet = NUM_MUTATIONS;</a>
<a name="ln2862"> </a>
<a name="ln2863">                for (const player::demon_trait trait : you.demonic_traits)</a>
<a name="ln2864">                {</a>
<a name="ln2865">                    if (is_body_facet(trait.mutation))</a>
<a name="ln2866">                    {</a>
<a name="ln2867">                        if (first_body_facet &lt; NUM_MUTATIONS</a>
<a name="ln2868">                            &amp;&amp; trait.mutation != first_body_facet)</a>
<a name="ln2869">                        {</a>
<a name="ln2870">                            if (you.experience_level == level)</a>
<a name="ln2871">                            {</a>
<a name="ln2872">                                mprf(MSGCH_MUTATION, &quot;You feel monstrous as &quot;</a>
<a name="ln2873">                                     &quot;your demonic heritage exerts itself.&quot;);</a>
<a name="ln2874">                                mark_milestone(&quot;monstrous&quot;, &quot;discovered their &quot;</a>
<a name="ln2875">                                               &quot;monstrous ancestry!&quot;);</a>
<a name="ln2876">                            }</a>
<a name="ln2877">                            break;</a>
<a name="ln2878">                        }</a>
<a name="ln2879"> </a>
<a name="ln2880">                        if (first_body_facet == NUM_MUTATIONS)</a>
<a name="ln2881">                        {</a>
<a name="ln2882">                            first_body_facet = trait.mutation;</a>
<a name="ln2883">                            level = trait.level_gained;</a>
<a name="ln2884">                        }</a>
<a name="ln2885">                    }</a>
<a name="ln2886">                }</a>
<a name="ln2887"> </a>
<a name="ln2888">                for (const player::demon_trait trait : you.demonic_traits)</a>
<a name="ln2889">                {</a>
<a name="ln2890">                    if (trait.level_gained == you.experience_level)</a>
<a name="ln2891">                    {</a>
<a name="ln2892">                        if (!gave_message)</a>
<a name="ln2893">                        {</a>
<a name="ln2894">                            mprf(MSGCH_INTRINSIC_GAIN,</a>
<a name="ln2895">                                 &quot;Your demonic ancestry asserts itself...&quot;);</a>
<a name="ln2896"> </a>
<a name="ln2897">                            gave_message = true;</a>
<a name="ln2898">                        }</a>
<a name="ln2899">                        perma_mutate(trait.mutation, 1, &quot;demonic ancestry&quot;);</a>
<a name="ln2900">                    }</a>
<a name="ln2901">                }</a>
<a name="ln2902"> </a>
<a name="ln2903">                break;</a>
<a name="ln2904">            }</a>
<a name="ln2905"> </a>
<a name="ln2906">            case SP_FELID:</a>
<a name="ln2907">                _felid_extra_life();</a>
<a name="ln2908">                break;</a>
<a name="ln2909"> </a>
<a name="ln2910">            default:</a>
<a name="ln2911">                break;</a>
<a name="ln2912">            }</a>
<a name="ln2913"> </a>
<a name="ln2914">            give_level_mutations(you.species, you.experience_level);</a>
<a name="ln2915"> </a>
<a name="ln2916">        }</a>
<a name="ln2917"> </a>
<a name="ln2918">        if (species_is_draconian(you.species) &amp;&amp; !(you.experience_level % 3))</a>
<a name="ln2919">        {</a>
<a name="ln2920">            mprf(MSGCH_INTRINSIC_GAIN, &quot;Your scales feel tougher.&quot;);</a>
<a name="ln2921">            you.redraw_armour_class = true;</a>
<a name="ln2922">        }</a>
<a name="ln2923">        if (!updated_maxhp)</a>
<a name="ln2924">            _gain_and_note_hp_mp();</a>
<a name="ln2925"> </a>
<a name="ln2926">        xom_is_stimulated(12);</a>
<a name="ln2927">        if (in_good_standing(GOD_HEPLIAKLQANA))</a>
<a name="ln2928">            upgrade_hepliaklqana_ancestor();</a>
<a name="ln2929"> </a>
<a name="ln2930">        learned_something_new(HINT_NEW_LEVEL);</a>
<a name="ln2931">    }</a>
<a name="ln2932"> </a>
<a name="ln2933">    while (you.experience &gt;= exp_needed(you.max_level + 1))</a>
<a name="ln2934">    {</a>
<a name="ln2935">        ASSERT(you.experience_level == you.get_max_xl());</a>
<a name="ln2936">        ASSERT(you.max_level &lt; 127); // marshalled as an 1-byte value</a>
<a name="ln2937">        you.max_level++;</a>
<a name="ln2938">        if (you.species == SP_FELID)</a>
<a name="ln2939">            _felid_extra_life();</a>
<a name="ln2940">    }</a>
<a name="ln2941"> </a>
<a name="ln2942">    you.redraw_title = true;</a>
<a name="ln2943"> </a>
<a name="ln2944">#ifdef DGL_WHEREIS</a>
<a name="ln2945">    whereis_record();</a>
<a name="ln2946">#endif</a>
<a name="ln2947"> </a>
<a name="ln2948">    // Hints mode arbitrarily ends at xp 7.</a>
<a name="ln2949">    if (crawl_state.game_is_hints() &amp;&amp; you.experience_level &gt;= 7)</a>
<a name="ln2950">        hints_finished();</a>
<a name="ln2951">}</a>
<a name="ln2952"> </a>
<a name="ln2953">void adjust_level(int diff, bool just_xp)</a>
<a name="ln2954">{</a>
<a name="ln2955">    ASSERT((uint64_t)you.experience &lt;= (uint64_t)MAX_EXP_TOTAL);</a>
<a name="ln2956">    const int max_exp_level = you.get_max_xl();</a>
<a name="ln2957">    if (you.experience_level + diff &lt; 1)</a>
<a name="ln2958">        you.experience = 0;</a>
<a name="ln2959">    else if (you.experience_level + diff &gt;= max_exp_level)</a>
<a name="ln2960">    {</a>
<a name="ln2961">        const unsigned needed = exp_needed(max_exp_level);</a>
<a name="ln2962">        // Level gain when already at max should never reduce player XP;</a>
<a name="ln2963">        // but level loss (diff &lt; 0) should.</a>
<a name="ln2964">        if (diff &lt; 0 || you.experience &lt; needed)</a>
<a name="ln2965">            you.experience = needed;</a>
<a name="ln2966">    }</a>
<a name="ln2967">    else</a>
<a name="ln2968">    {</a>
<a name="ln2969">        while (diff &lt; 0 &amp;&amp; you.experience &gt;=</a>
<a name="ln2970">                exp_needed(max_exp_level))</a>
<a name="ln2971">        {</a>
<a name="ln2972">            // Having XP for level 53 and going back to 26 due to a single</a>
<a name="ln2973">            // card would mean your felid is not going to get any extra lives</a>
<a name="ln2974">            // in foreseable future.</a>
<a name="ln2975">            you.experience -= exp_needed(max_exp_level)</a>
<a name="ln2976">                    - exp_needed(max_exp_level - 1);</a>
<a name="ln2977">            diff++;</a>
<a name="ln2978">        }</a>
<a name="ln2979">        int old_min = exp_needed(you.experience_level);</a>
<a name="ln2980">        int old_max = exp_needed(you.experience_level + 1);</a>
<a name="ln2981">        int new_min = exp_needed(you.experience_level + diff);</a>
<a name="ln2982">        int new_max = exp_needed(you.experience_level + 1 + diff);</a>
<a name="ln2983">        dprf(&quot;XP before: %d\n&quot;, you.experience);</a>
<a name="ln2984">        dprf(&quot;%4.2f of %d..%d to %d..%d&quot;,</a>
<a name="ln2985">             (you.experience - old_min) * 1.0 / (old_max - old_min),</a>
<a name="ln2986">             old_min, old_max, new_min, new_max);</a>
<a name="ln2987"> </a>
<a name="ln2988">        you.experience = ((int64_t)(new_max - new_min))</a>
<a name="ln2989">                       * (you.experience - old_min)</a>
<a name="ln2990">                       / (old_max - old_min)</a>
<a name="ln2991">                       + new_min;</a>
<a name="ln2992">        dprf(&quot;XP after: %d\n&quot;, you.experience);</a>
<a name="ln2993">    }</a>
<a name="ln2994"> </a>
<a name="ln2995">    ASSERT((uint64_t)you.experience &lt;= (uint64_t)MAX_EXP_TOTAL);</a>
<a name="ln2996"> </a>
<a name="ln2997">    if (!just_xp)</a>
<a name="ln2998">        level_change();</a>
<a name="ln2999">}</a>
<a name="ln3000"> </a>
<a name="ln3001">/**</a>
<a name="ln3002"> * Get the player's current stealth value.</a>
<a name="ln3003"> *</a>
<a name="ln3004"> * (Keep in mind, while tweaking this function: the order in which stealth</a>
<a name="ln3005"> * modifiers are applied is significant!)</a>
<a name="ln3006"> *</a>
<a name="ln3007"> * @return  The player's current stealth value.</a>
<a name="ln3008"> */</a>
<a name="ln3009">int player_stealth()</a>
<a name="ln3010">{</a>
<a name="ln3011">    ASSERT(!crawl_state.game_is_arena());</a>
<a name="ln3012">    // Extreme stealthiness can be enforced by wizmode stealth setting.</a>
<a name="ln3013">    if (crawl_state.disables[DIS_MON_SIGHT])</a>
<a name="ln3014">        return 1000;</a>
<a name="ln3015"> </a>
<a name="ln3016">    // berserking, &quot;clumsy&quot; (0-dex), sacrifice stealth.</a>
<a name="ln3017">    if (you.berserk()</a>
<a name="ln3018">        || you.duration[DUR_CLUMSY]</a>
<a name="ln3019">        || you.get_mutation_level(MUT_NO_STEALTH))</a>
<a name="ln3020">    {</a>
<a name="ln3021">        return 0;</a>
<a name="ln3022">    }</a>
<a name="ln3023"> </a>
<a name="ln3024">    int stealth = you.dex() * 3;</a>
<a name="ln3025"> </a>
<a name="ln3026">    stealth += you.skill(SK_STEALTH, 15);</a>
<a name="ln3027"> </a>
<a name="ln3028">    if (you.confused())</a>
<a name="ln3029">        stealth /= 3;</a>
<a name="ln3030"> </a>
<a name="ln3031">    const item_def *arm = you.slot_item(EQ_BODY_ARMOUR, false);</a>
<a name="ln3032">    const item_def *boots = you.slot_item(EQ_BOOTS, false);</a>
<a name="ln3033"> </a>
<a name="ln3034">    if (arm)</a>
<a name="ln3035">    {</a>
<a name="ln3036">        // [ds] New stealth penalty formula from rob: SP = 6 * (EP^2)</a>
<a name="ln3037">        // Now 2 * EP^2 / 3 after EP rescaling.</a>
<a name="ln3038">        const int evp = you.unadjusted_body_armour_penalty();</a>
<a name="ln3039">        const int penalty = evp * evp * 2 / 3;</a>
<a name="ln3040">        stealth -= penalty;</a>
<a name="ln3041"> </a>
<a name="ln3042">        const int pips = armour_type_prop(arm-&gt;sub_type, ARMF_STEALTH);</a>
<a name="ln3043">        stealth += pips * STEALTH_PIP;</a>
<a name="ln3044">    }</a>
<a name="ln3045"> </a>
<a name="ln3046">    stealth += STEALTH_PIP * you.scan_artefacts(ARTP_STEALTH);</a>
<a name="ln3047"> </a>
<a name="ln3048">    stealth += STEALTH_PIP * you.wearing(EQ_RINGS, RING_STEALTH);</a>
<a name="ln3049">    stealth -= STEALTH_PIP * you.wearing(EQ_RINGS, RING_ATTENTION);</a>
<a name="ln3050"> </a>
<a name="ln3051">    if (you.duration[DUR_STEALTH])</a>
<a name="ln3052">        stealth += STEALTH_PIP * 2;</a>
<a name="ln3053"> </a>
<a name="ln3054">    if (you.form == transformation::blade_hands &amp;&amp; you.species == SP_FELID</a>
<a name="ln3055">        &amp;&amp; !you.airborne())</a>
<a name="ln3056">    {</a>
<a name="ln3057">        stealth -= STEALTH_PIP; // klack klack klack go the blade paws</a>
<a name="ln3058">        // this is an absurd special case but also it's really funny so w/e</a>
<a name="ln3059">    }</a>
<a name="ln3060"> </a>
<a name="ln3061">    // Mutations.</a>
<a name="ln3062">    stealth += STEALTH_PIP * you.get_mutation_level(MUT_NIGHTSTALKER);</a>
<a name="ln3063">    stealth += (STEALTH_PIP / 2)</a>
<a name="ln3064">                * you.get_mutation_level(MUT_THIN_SKELETAL_STRUCTURE);</a>
<a name="ln3065">    stealth += STEALTH_PIP * you.get_mutation_level(MUT_CAMOUFLAGE);</a>
<a name="ln3066">    const int how_transparent = you.get_mutation_level(MUT_TRANSLUCENT_SKIN);</a>
<a name="ln3067">    if (how_transparent)</a>
<a name="ln3068">        stealth += 15 * (how_transparent);</a>
<a name="ln3069"> </a>
<a name="ln3070">    // Radiating silence is the negative complement of shouting all the</a>
<a name="ln3071">    // time... a sudden change from background noise to no noise is going</a>
<a name="ln3072">    // to clue anything in to the fact that something is very wrong...</a>
<a name="ln3073">    // a personal silence spell would naturally be different, but this</a>
<a name="ln3074">    // silence radiates for a distance and prevents monster spellcasting,</a>
<a name="ln3075">    // which pretty much gives away the stealth game.</a>
<a name="ln3076">    if (you.duration[DUR_SILENCE])</a>
<a name="ln3077">        stealth -= STEALTH_PIP;</a>
<a name="ln3078"> </a>
<a name="ln3079">    // Bloodless vampires are stealthier.</a>
<a name="ln3080">    if (you.species == SP_VAMPIRE &amp;&amp; !you.vampire_alive)</a>
<a name="ln3081">            stealth += STEALTH_PIP * 2;</a>
<a name="ln3082"> </a>
<a name="ln3083">    if (!you.airborne())</a>
<a name="ln3084">    {</a>
<a name="ln3085">        if (you.in_water())</a>
<a name="ln3086">        {</a>
<a name="ln3087">            // Merfolk can sneak up on monsters underwater -- bwr</a>
<a name="ln3088">            if (you.fishtail || you.species == SP_OCTOPODE)</a>
<a name="ln3089">                stealth += STEALTH_PIP;</a>
<a name="ln3090">            else if (!you.can_swim() &amp;&amp; !you.extra_balanced())</a>
<a name="ln3091">                stealth /= 2;       // splashy-splashy</a>
<a name="ln3092">        }</a>
<a name="ln3093">        else if (boots &amp;&amp; get_armour_ego_type(*boots) == SPARM_STEALTH)</a>
<a name="ln3094">            stealth += STEALTH_PIP;</a>
<a name="ln3095">        else if (you.has_usable_hooves())</a>
<a name="ln3096">            stealth -= 5 + 5 * you.get_mutation_level(MUT_HOOVES);</a>
<a name="ln3097">        else if (you.species == SP_FELID</a>
<a name="ln3098">                 &amp;&amp; (you.form == transformation::none</a>
<a name="ln3099">                     || you.form == transformation::appendage))</a>
<a name="ln3100">        {</a>
<a name="ln3101">            stealth += 20;  // paws</a>
<a name="ln3102">        }</a>
<a name="ln3103">    }</a>
<a name="ln3104"> </a>
<a name="ln3105">    // If you've been tagged with Corona or are Glowing, the glow</a>
<a name="ln3106">    // makes you extremely unstealthy.</a>
<a name="ln3107">    if (you.backlit())</a>
<a name="ln3108">        stealth = stealth * 2 / 5;</a>
<a name="ln3109"> </a>
<a name="ln3110">    // On the other hand, shrouding has the reverse effect, if you know</a>
<a name="ln3111">    // how to make use of it:</a>
<a name="ln3112">    if (you.umbra())</a>
<a name="ln3113">    {</a>
<a name="ln3114">        int umbra_mul = 1, umbra_div = 1;</a>
<a name="ln3115">        if (you.nightvision())</a>
<a name="ln3116">        {</a>
<a name="ln3117">            umbra_mul = you.piety + MAX_PIETY;</a>
<a name="ln3118">            umbra_div = MAX_PIETY;</a>
<a name="ln3119">        }</a>
<a name="ln3120">        if (player_equip_unrand(UNRAND_SHADOWS)</a>
<a name="ln3121">            &amp;&amp; 2 * umbra_mul &lt; 3 * umbra_div)</a>
<a name="ln3122">        {</a>
<a name="ln3123">            umbra_mul = 3;</a>
<a name="ln3124">            umbra_div = 2;</a>
<a name="ln3125">        }</a>
<a name="ln3126">        stealth *= umbra_mul;</a>
<a name="ln3127">        stealth /= umbra_div;</a>
<a name="ln3128">    }</a>
<a name="ln3129"> </a>
<a name="ln3130">    if (you.form == transformation::shadow)</a>
<a name="ln3131">        stealth *= 2;</a>
<a name="ln3132"> </a>
<a name="ln3133">    // If you're surrounded by a storm, you're inherently pretty conspicuous.</a>
<a name="ln3134">    if (have_passive(passive_t::storm_shield))</a>
<a name="ln3135">    {</a>
<a name="ln3136">        stealth = stealth</a>
<a name="ln3137">                  * (MAX_PIETY - min((int)you.piety, piety_breakpoint(5)))</a>
<a name="ln3138">                  / (MAX_PIETY - piety_breakpoint(0));</a>
<a name="ln3139">    }</a>
<a name="ln3140">    // The shifting glow from the Orb, while too unstable to negate invis</a>
<a name="ln3141">    // or affect to-hit, affects stealth even more than regular glow.</a>
<a name="ln3142">    if (player_has_orb())</a>
<a name="ln3143">        stealth /= 3;</a>
<a name="ln3144"> </a>
<a name="ln3145">    stealth = max(0, stealth);</a>
<a name="ln3146"> </a>
<a name="ln3147">    return stealth;</a>
<a name="ln3148">}</a>
<a name="ln3149"> </a>
<a name="ln3150">// Is a given duration about to expire?</a>
<a name="ln3151">bool dur_expiring(duration_type dur)</a>
<a name="ln3152">{</a>
<a name="ln3153">    const int value = you.duration[dur];</a>
<a name="ln3154">    if (value &lt;= 0)</a>
<a name="ln3155">        return false;</a>
<a name="ln3156"> </a>
<a name="ln3157">    return value &lt;= duration_expire_point(dur);</a>
<a name="ln3158">}</a>
<a name="ln3159"> </a>
<a name="ln3160">static void _display_char_status(int value, const char *fmt, ...)</a>
<a name="ln3161">{</a>
<a name="ln3162">    va_list argp;</a>
<a name="ln3163">    va_start(argp, fmt);</a>
<a name="ln3164"> </a>
<a name="ln3165">    string msg = vmake_stringf(fmt, argp);</a>
<a name="ln3166"> </a>
<a name="ln3167">    if (you.wizard)</a>
<a name="ln3168">        mprf(&quot;%s (%d).&quot;, msg.c_str(), value);</a>
<a name="ln3169">    else</a>
<a name="ln3170">        mprf(&quot;%s.&quot;, msg.c_str());</a>
<a name="ln3171"> </a>
<a name="ln3172">    va_end(argp);</a>
<a name="ln3173">}</a>
<a name="ln3174"> </a>
<a name="ln3175">static void _display_vampire_status()</a>
<a name="ln3176">{</a>
<a name="ln3177">    string msg = &quot;At your current blood state you &quot;;</a>
<a name="ln3178">    vector&lt;const char *&gt; attrib;</a>
<a name="ln3179"> </a>
<a name="ln3180">    if (!you.vampire_alive)</a>
<a name="ln3181">    {</a>
<a name="ln3182">        attrib.push_back(&quot;are immune to poison&quot;);</a>
<a name="ln3183">        attrib.push_back(&quot;significantly resist cold&quot;);</a>
<a name="ln3184">        attrib.push_back(&quot;are immune to negative energy&quot;);</a>
<a name="ln3185">        attrib.push_back(&quot;resist torment&quot;);</a>
<a name="ln3186">        attrib.push_back(&quot;do not heal with monsters in sight.&quot;);</a>
<a name="ln3187">    }</a>
<a name="ln3188">    else</a>
<a name="ln3189">        attrib.push_back(&quot;heal quickly.&quot;);</a>
<a name="ln3190"> </a>
<a name="ln3191">    if (!attrib.empty())</a>
<a name="ln3192">    {</a>
<a name="ln3193">        msg += comma_separated_line(attrib.begin(), attrib.end());</a>
<a name="ln3194">        mpr(msg);</a>
<a name="ln3195">    }</a>
<a name="ln3196">}</a>
<a name="ln3197"> </a>
<a name="ln3198">static void _display_movement_speed()</a>
<a name="ln3199">{</a>
<a name="ln3200">    const int move_cost = (player_speed() * player_movement_speed()) / 10;</a>
<a name="ln3201"> </a>
<a name="ln3202">    const bool water  = you.in_liquid();</a>
<a name="ln3203">    const bool swim   = you.swimming();</a>
<a name="ln3204"> </a>
<a name="ln3205">    const bool fly    = you.airborne();</a>
<a name="ln3206">    const bool swift  = (you.duration[DUR_SWIFTNESS] &gt; 0</a>
<a name="ln3207">                         &amp;&amp; you.attribute[ATTR_SWIFTNESS] &gt;= 0);</a>
<a name="ln3208">    const bool antiswift = (you.duration[DUR_SWIFTNESS] &gt; 0</a>
<a name="ln3209">                            &amp;&amp; you.attribute[ATTR_SWIFTNESS] &lt; 0);</a>
<a name="ln3210"> </a>
<a name="ln3211">    _display_char_status(move_cost, &quot;Your %s speed is %s%s%s&quot;,</a>
<a name="ln3212">          // order is important for these:</a>
<a name="ln3213">          (swim)    ? &quot;swimming&quot; :</a>
<a name="ln3214">          (water)   ? &quot;wading&quot; :</a>
<a name="ln3215">          (fly)     ? &quot;flying&quot;</a>
<a name="ln3216">                    : &quot;movement&quot;,</a>
<a name="ln3217"> </a>
<a name="ln3218">          (!water &amp;&amp; swift) ? &quot;aided by the wind&quot; :</a>
<a name="ln3219">          (!water &amp;&amp; antiswift) ? &quot;hindered by the wind&quot; : &quot;&quot;,</a>
<a name="ln3220"> </a>
<a name="ln3221">          (!water &amp;&amp; swift) ? ((move_cost &gt;= 10) ? &quot;, but still &quot;</a>
<a name="ln3222">                                                 : &quot; and &quot;) :</a>
<a name="ln3223">          (!water &amp;&amp; antiswift) ? ((move_cost &lt;= 10) ? &quot;, but still &quot;</a>
<a name="ln3224">                                                     : &quot; and &quot;)</a>
<a name="ln3225">                            : &quot;&quot;,</a>
<a name="ln3226"> </a>
<a name="ln3227">          (move_cost &lt;   8) ? &quot;very quick&quot; :</a>
<a name="ln3228">          (move_cost &lt;  10) ? &quot;quick&quot; :</a>
<a name="ln3229">          (move_cost == 10) ? &quot;average&quot; :</a>
<a name="ln3230">          (move_cost &lt;  13) ? &quot;slow&quot;</a>
<a name="ln3231">                            : &quot;very slow&quot;);</a>
<a name="ln3232">}</a>
<a name="ln3233"> </a>
<a name="ln3234">static void _display_tohit()</a>
<a name="ln3235">{</a>
<a name="ln3236">#ifdef DEBUG_DIAGNOSTICS</a>
<a name="ln3237">    melee_attack attk(&amp;you, nullptr);</a>
<a name="ln3238"> </a>
<a name="ln3239">    const int to_hit = attk.calc_to_hit(false);</a>
<a name="ln3240"> </a>
<a name="ln3241">    dprf(&quot;To-hit: %d&quot;, to_hit);</a>
<a name="ln3242">#endif</a>
<a name="ln3243">}</a>
<a name="ln3244"> </a>
<a name="ln3245">static const char* _attack_delay_desc(int attack_delay)</a>
<a name="ln3246">{</a>
<a name="ln3247">    return (attack_delay &gt;= 200) ? &quot;extremely slow&quot; :</a>
<a name="ln3248">           (attack_delay &gt;= 155) ? &quot;very slow&quot; :</a>
<a name="ln3249">           (attack_delay &gt;= 125) ? &quot;quite slow&quot; :</a>
<a name="ln3250">           (attack_delay &gt;= 105) ? &quot;below average&quot; :</a>
<a name="ln3251">           (attack_delay &gt;=  95) ? &quot;average&quot; :</a>
<a name="ln3252">           (attack_delay &gt;=  75) ? &quot;above average&quot; :</a>
<a name="ln3253">           (attack_delay &gt;=  55) ? &quot;quite fast&quot; :</a>
<a name="ln3254">           (attack_delay &gt;=  45) ? &quot;very fast&quot; :</a>
<a name="ln3255">           (attack_delay &gt;=  35) ? &quot;extremely fast&quot; :</a>
<a name="ln3256">                                   &quot;blindingly fast&quot;;</a>
<a name="ln3257">}</a>
<a name="ln3258"> </a>
<a name="ln3259">/**</a>
<a name="ln3260"> * Print a message indicating the player's attack delay with their current</a>
<a name="ln3261"> * weapon &amp; its ammo (if applicable).</a>
<a name="ln3262"> *</a>
<a name="ln3263"> * Assumes the attack speed of a ranged weapon does not depend on what</a>
<a name="ln3264"> * ammunition is being used (as long as it is valid).</a>
<a name="ln3265"> */</a>
<a name="ln3266">static void _display_attack_delay()</a>
<a name="ln3267">{</a>
<a name="ln3268">    const item_def* weapon = you.weapon();</a>
<a name="ln3269">    int delay;</a>
<a name="ln3270">    if (weapon &amp;&amp; is_range_weapon(*weapon))</a>
<a name="ln3271">    {</a>
<a name="ln3272">        item_def ammo;</a>
<a name="ln3273">        ammo.base_type = OBJ_MISSILES;</a>
<a name="ln3274">        ammo.sub_type = fires_ammo_type(*weapon);</a>
<a name="ln3275">        delay = you.attack_delay(&amp;ammo, false).expected();</a>
<a name="ln3276">    }</a>
<a name="ln3277">    else</a>
<a name="ln3278">        delay = you.attack_delay(nullptr, false).expected();</a>
<a name="ln3279"> </a>
<a name="ln3280">    const bool at_min_delay = weapon</a>
<a name="ln3281">                              &amp;&amp; you.skill(item_attack_skill(*weapon))</a>
<a name="ln3282">                                 &gt;= weapon_min_delay_skill(*weapon);</a>
<a name="ln3283"> </a>
<a name="ln3284">    // Scale to fit the displayed weapon base delay, i.e.,</a>
<a name="ln3285">    // normal speed is 100 (as in 100%).</a>
<a name="ln3286">    int avg = 10 * delay;</a>
<a name="ln3287"> </a>
<a name="ln3288">    _display_char_status(avg, &quot;Your attack speed is %s%s%s&quot;,</a>
<a name="ln3289">                         _attack_delay_desc(avg),</a>
<a name="ln3290">                         at_min_delay ?</a>
<a name="ln3291">                            &quot; (and cannot be improved with additional weapon skill)&quot; : &quot;&quot;,</a>
<a name="ln3292">                         you.adjusted_shield_penalty() ?</a>
<a name="ln3293">                            &quot; (and is slowed by your insufficient shield skill)&quot; : &quot;&quot;);</a>
<a name="ln3294">}</a>
<a name="ln3295"> </a>
<a name="ln3296">// forward declaration</a>
<a name="ln3297">static string _constriction_description();</a>
<a name="ln3298"> </a>
<a name="ln3299">void display_char_status()</a>
<a name="ln3300">{</a>
<a name="ln3301">    const int halo_size = you.halo_radius();</a>
<a name="ln3302">    if (halo_size &gt;= 0)</a>
<a name="ln3303">    {</a>
<a name="ln3304">        if (halo_size &gt; 37)</a>
<a name="ln3305">            mpr(&quot;You are illuminated by a large divine halo.&quot;);</a>
<a name="ln3306">        else if (halo_size &gt; 10)</a>
<a name="ln3307">            mpr(&quot;You are illuminated by a divine halo.&quot;);</a>
<a name="ln3308">        else</a>
<a name="ln3309">            mpr(&quot;You are illuminated by a small divine halo.&quot;);</a>
<a name="ln3310">    }</a>
<a name="ln3311">    else if (you.haloed())</a>
<a name="ln3312">        mpr(&quot;An external divine halo illuminates you.&quot;);</a>
<a name="ln3313"> </a>
<a name="ln3314">    if (you.species == SP_VAMPIRE)</a>
<a name="ln3315">        _display_vampire_status();</a>
<a name="ln3316"> </a>
<a name="ln3317">    status_info inf;</a>
<a name="ln3318">    for (unsigned i = 0; i &lt;= STATUS_LAST_STATUS; ++i)</a>
<a name="ln3319">    {</a>
<a name="ln3320">        if (fill_status_info(i, inf) &amp;&amp; !inf.long_text.empty())</a>
<a name="ln3321">            mpr(inf.long_text);</a>
<a name="ln3322">    }</a>
<a name="ln3323">    string cinfo = _constriction_description();</a>
<a name="ln3324">    if (!cinfo.empty())</a>
<a name="ln3325">        mpr(cinfo);</a>
<a name="ln3326"> </a>
<a name="ln3327">    _display_movement_speed();</a>
<a name="ln3328">    _display_tohit();</a>
<a name="ln3329">    _display_attack_delay();</a>
<a name="ln3330"> </a>
<a name="ln3331">    // Display base attributes, if necessary.</a>
<a name="ln3332">    if (innate_stat(STAT_STR) != you.strength()</a>
<a name="ln3333">        || innate_stat(STAT_INT) != you.intel()</a>
<a name="ln3334">        || innate_stat(STAT_DEX) != you.dex())</a>
<a name="ln3335">    {</a>
<a name="ln3336">        mprf(&quot;Your base attributes are Str %d, Int %d, Dex %d.&quot;,</a>
<a name="ln3337">             innate_stat(STAT_STR),</a>
<a name="ln3338">             innate_stat(STAT_INT),</a>
<a name="ln3339">             innate_stat(STAT_DEX));</a>
<a name="ln3340">    }</a>
<a name="ln3341">}</a>
<a name="ln3342"> </a>
<a name="ln3343">bool player::clarity(bool calc_unid, bool items) const</a>
<a name="ln3344">{</a>
<a name="ln3345">    if (you.get_mutation_level(MUT_CLARITY))</a>
<a name="ln3346">        return true;</a>
<a name="ln3347"> </a>
<a name="ln3348">    if (have_passive(passive_t::clarity))</a>
<a name="ln3349">        return true;</a>
<a name="ln3350"> </a>
<a name="ln3351">    return actor::clarity(calc_unid, items);</a>
<a name="ln3352">}</a>
<a name="ln3353"> </a>
<a name="ln3354">bool player::gourmand(bool calc_unid, bool items) const</a>
<a name="ln3355">{</a>
<a name="ln3356">    return you.get_mutation_level(MUT_GOURMAND) &gt; 0</a>
<a name="ln3357">           || actor::gourmand(calc_unid, items);</a>
<a name="ln3358">}</a>
<a name="ln3359"> </a>
<a name="ln3360">bool player::stasis() const</a>
<a name="ln3361">{</a>
<a name="ln3362">    return species == SP_FORMICID;</a>
<a name="ln3363">}</a>
<a name="ln3364"> </a>
<a name="ln3365">bool player::cloud_immune(bool calc_unid, bool items) const</a>
<a name="ln3366">{</a>
<a name="ln3367">    return have_passive(passive_t::cloud_immunity)</a>
<a name="ln3368">        || actor::cloud_immune(calc_unid, items);</a>
<a name="ln3369">}</a>
<a name="ln3370"> </a>
<a name="ln3371">unsigned int exp_needed(int lev, int exp_apt)</a>
<a name="ln3372">{</a>
<a name="ln3373">    unsigned int level = 0;</a>
<a name="ln3374"> </a>
<a name="ln3375">    // Note: For historical reasons, all of the following numbers are for a</a>
<a name="ln3376">    // species (like human) with XP aptitude 1, not 0 as one might expect.</a>
<a name="ln3377"> </a>
<a name="ln3378">    // Basic plan:</a>
<a name="ln3379">    // Section 1: levels  1- 5, second derivative goes 10-10-20-30.</a>
<a name="ln3380">    // Section 2: levels  6-13, second derivative is exponential/doubling.</a>
<a name="ln3381">    // Section 3: levels 14-27, second derivative is constant at 8470.</a>
<a name="ln3382"> </a>
<a name="ln3383">    // Here's a table:</a>
<a name="ln3384">    //</a>
<a name="ln3385">    // level      xp      delta   delta2</a>
<a name="ln3386">    // =====   =======    =====   ======</a>
<a name="ln3387">    //   1           0        0       0</a>
<a name="ln3388">    //   2          10       10      10</a>
<a name="ln3389">    //   3          30       20      10</a>
<a name="ln3390">    //   4          70       40      20</a>
<a name="ln3391">    //   5         140       70      30</a>
<a name="ln3392">    //   6         270      130      60</a>
<a name="ln3393">    //   7         520      250     120</a>
<a name="ln3394">    //   8        1010      490     240</a>
<a name="ln3395">    //   9        1980      970     480</a>
<a name="ln3396">    //  10        3910     1930     960</a>
<a name="ln3397">    //  11        7760     3850    1920</a>
<a name="ln3398">    //  12       15450     7690    3840</a>
<a name="ln3399">    //  13       26895    11445    3755</a>
<a name="ln3400">    //  14       45585    18690    7245</a>
<a name="ln3401">    //  15       72745    27160    8470</a>
<a name="ln3402">    //  16      108375    35630    8470</a>
<a name="ln3403">    //  17      152475    44100    8470</a>
<a name="ln3404">    //  18      205045    52570    8470</a>
<a name="ln3405">    //  19      266085    61040    8470</a>
<a name="ln3406">    //  20      335595    69510    8470</a>
<a name="ln3407">    //  21      413575    77980    8470</a>
<a name="ln3408">    //  22      500025    86450    8470</a>
<a name="ln3409">    //  23      594945    94920    8470</a>
<a name="ln3410">    //  24      698335    103390   8470</a>
<a name="ln3411">    //  25      810195    111860   8470</a>
<a name="ln3412">    //  26      930525    120330   8470</a>
<a name="ln3413">    //  27     1059325    128800   8470</a>
<a name="ln3414"> </a>
<a name="ln3415">    switch (lev)</a>
<a name="ln3416">    {</a>
<a name="ln3417">    case 1:</a>
<a name="ln3418">        level = 1;</a>
<a name="ln3419">        break;</a>
<a name="ln3420">    case 2:</a>
<a name="ln3421">        level = 10;</a>
<a name="ln3422">        break;</a>
<a name="ln3423">    case 3:</a>
<a name="ln3424">        level = 30;</a>
<a name="ln3425">        break;</a>
<a name="ln3426">    case 4:</a>
<a name="ln3427">        level = 70;</a>
<a name="ln3428">        break;</a>
<a name="ln3429"> </a>
<a name="ln3430">    default:</a>
<a name="ln3431">        if (lev &lt; 13)</a>
<a name="ln3432">        {</a>
<a name="ln3433">            lev -= 4;</a>
<a name="ln3434">            level = 10 + 10 * lev + (60 &lt;&lt; lev);</a>
<a name="ln3435">        }</a>
<a name="ln3436">        else</a>
<a name="ln3437">        {</a>
<a name="ln3438">            lev -= 12;</a>
<a name="ln3439">            level = 16675 + 5985 * lev + 4235 * lev * lev;</a>
<a name="ln3440">        }</a>
<a name="ln3441">        break;</a>
<a name="ln3442">    }</a>
<a name="ln3443"> </a>
<a name="ln3444">    if (exp_apt == -99)</a>
<a name="ln3445">        exp_apt = species_exp_modifier(you.species);</a>
<a name="ln3446"> </a>
<a name="ln3447">    return (unsigned int) ((level - 1) * apt_to_factor(exp_apt - 1));</a>
<a name="ln3448">}</a>
<a name="ln3449"> </a>
<a name="ln3450">// returns bonuses from rings of slaying, etc.</a>
<a name="ln3451">int slaying_bonus(bool ranged)</a>
<a name="ln3452">{</a>
<a name="ln3453">    int ret = 0;</a>
<a name="ln3454"> </a>
<a name="ln3455">    ret += you.wearing(EQ_RINGS_PLUS, RING_SLAYING);</a>
<a name="ln3456">    ret += you.scan_artefacts(ARTP_SLAYING);</a>
<a name="ln3457">    if (you.wearing_ego(EQ_GLOVES, SPARM_ARCHERY) &amp;&amp; ranged)</a>
<a name="ln3458">        ret += 4;</a>
<a name="ln3459"> </a>
<a name="ln3460">    ret += 3 * augmentation_amount();</a>
<a name="ln3461"> </a>
<a name="ln3462">    if (you.duration[DUR_SONG_OF_SLAYING])</a>
<a name="ln3463">        ret += you.props[SONG_OF_SLAYING_KEY].get_int();</a>
<a name="ln3464"> </a>
<a name="ln3465">    if (you.duration[DUR_HORROR])</a>
<a name="ln3466">        ret -= you.props[HORROR_PENALTY_KEY].get_int();</a>
<a name="ln3467"> </a>
<a name="ln3468">    if (you.props.exists(WU_JIAN_HEAVENLY_STORM_KEY))</a>
<a name="ln3469">        ret += you.props[WU_JIAN_HEAVENLY_STORM_KEY].get_int();</a>
<a name="ln3470"> </a>
<a name="ln3471">    return ret;</a>
<a name="ln3472">}</a>
<a name="ln3473"> </a>
<a name="ln3474">// Checks each equip slot for a randart, and adds up all of those with</a>
<a name="ln3475">// a given property. Slow if any randarts are worn, so avoid where</a>
<a name="ln3476">// possible. If `matches' is non-nullptr, items with nonzero property are</a>
<a name="ln3477">// pushed onto *matches.</a>
<a name="ln3478">int player::scan_artefacts(artefact_prop_type which_property,</a>
<a name="ln3479">                           bool calc_unid,</a>
<a name="ln3480">                           vector&lt;const item_def *&gt; *matches) const</a>
<a name="ln3481">{</a>
<a name="ln3482">    int retval = 0;</a>
<a name="ln3483"> </a>
<a name="ln3484">    for (int i = EQ_FIRST_EQUIP; i &lt; NUM_EQUIP; ++i)</a>
<a name="ln3485">    {</a>
<a name="ln3486">        if (melded[i] || equip[i] == -1)</a>
<a name="ln3487">            continue;</a>
<a name="ln3488"> </a>
<a name="ln3489">        const int eq = equip[i];</a>
<a name="ln3490"> </a>
<a name="ln3491">        const item_def &amp;item = inv[eq];</a>
<a name="ln3492"> </a>
<a name="ln3493">        // Only weapons give their effects when in our hands.</a>
<a name="ln3494">        if (i == EQ_WEAPON &amp;&amp; item.base_type != OBJ_WEAPONS)</a>
<a name="ln3495">            continue;</a>
<a name="ln3496"> </a>
<a name="ln3497">        int val = 0;</a>
<a name="ln3498"> </a>
<a name="ln3499">        // TODO: id check not needed, probably, due to full wear-id?</a>
<a name="ln3500">        if (is_artefact(item) &amp;&amp; (calc_unid || fully_identified(item)))</a>
<a name="ln3501">            val = artefact_property(item, which_property);</a>
<a name="ln3502"> </a>
<a name="ln3503">        retval += val;</a>
<a name="ln3504"> </a>
<a name="ln3505">        if (matches &amp;&amp; val)</a>
<a name="ln3506">            matches-&gt;push_back(&amp;item);</a>
<a name="ln3507">    }</a>
<a name="ln3508"> </a>
<a name="ln3509">    return retval;</a>
<a name="ln3510">}</a>
<a name="ln3511"> </a>
<a name="ln3512">void dec_hp(int hp_loss, bool fatal, const char *aux)</a>
<a name="ln3513">{</a>
<a name="ln3514">    ASSERT(!crawl_state.game_is_arena());</a>
<a name="ln3515"> </a>
<a name="ln3516">    if (!fatal &amp;&amp; you.hp &lt; 1)</a>
<a name="ln3517">        you.hp = 1;</a>
<a name="ln3518"> </a>
<a name="ln3519">    if (!fatal &amp;&amp; hp_loss &gt;= you.hp)</a>
<a name="ln3520">        hp_loss = you.hp - 1;</a>
<a name="ln3521"> </a>
<a name="ln3522">    if (hp_loss &lt; 1)</a>
<a name="ln3523">        return;</a>
<a name="ln3524"> </a>
<a name="ln3525">    // If it's not fatal, use ouch() so that notes can be taken. If it IS</a>
<a name="ln3526">    // fatal, somebody else is doing the bookkeeping, and we don't want to mess</a>
<a name="ln3527">    // with that.</a>
<a name="ln3528">    if (!fatal &amp;&amp; aux)</a>
<a name="ln3529">        ouch(hp_loss, KILLED_BY_SOMETHING, MID_NOBODY, aux);</a>
<a name="ln3530">    else</a>
<a name="ln3531">        you.hp -= hp_loss;</a>
<a name="ln3532"> </a>
<a name="ln3533">    you.redraw_hit_points = true;</a>
<a name="ln3534">}</a>
<a name="ln3535"> </a>
<a name="ln3536">void calc_mp()</a>
<a name="ln3537">{</a>
<a name="ln3538">    you.max_magic_points = get_real_mp(true);</a>
<a name="ln3539">    you.magic_points = min(you.magic_points, you.max_magic_points);</a>
<a name="ln3540">    you.redraw_magic_points = true;</a>
<a name="ln3541">}</a>
<a name="ln3542"> </a>
<a name="ln3543">void flush_mp()</a>
<a name="ln3544">{</a>
<a name="ln3545">    if (Options.magic_point_warning</a>
<a name="ln3546">        &amp;&amp; you.magic_points &lt; you.max_magic_points</a>
<a name="ln3547">                              * Options.magic_point_warning / 100)</a>
<a name="ln3548">    {</a>
<a name="ln3549">        mprf(MSGCH_DANGER, &quot;* * * LOW MAGIC WARNING * * *&quot;);</a>
<a name="ln3550">    }</a>
<a name="ln3551"> </a>
<a name="ln3552">    take_note(Note(NOTE_MP_CHANGE, you.magic_points, you.max_magic_points));</a>
<a name="ln3553">    you.redraw_magic_points = true;</a>
<a name="ln3554">}</a>
<a name="ln3555"> </a>
<a name="ln3556">void dec_mp(int mp_loss, bool silent)</a>
<a name="ln3557">{</a>
<a name="ln3558">    ASSERT(!crawl_state.game_is_arena());</a>
<a name="ln3559"> </a>
<a name="ln3560">    if (mp_loss &lt; 1)</a>
<a name="ln3561">        return;</a>
<a name="ln3562"> </a>
<a name="ln3563">    you.magic_points -= mp_loss;</a>
<a name="ln3564"> </a>
<a name="ln3565">    you.magic_points = max(0, you.magic_points);</a>
<a name="ln3566">    if (!silent)</a>
<a name="ln3567">        flush_mp();</a>
<a name="ln3568">}</a>
<a name="ln3569"> </a>
<a name="ln3570">bool enough_hp(int minimum, bool suppress_msg, bool abort_macros)</a>
<a name="ln3571">{</a>
<a name="ln3572">    ASSERT(!crawl_state.game_is_arena());</a>
<a name="ln3573"> </a>
<a name="ln3574">    if (you.duration[DUR_DEATHS_DOOR])</a>
<a name="ln3575">    {</a>
<a name="ln3576">        if (!suppress_msg)</a>
<a name="ln3577">            mpr(&quot;You cannot pay life while functionally dead.&quot;);</a>
<a name="ln3578"> </a>
<a name="ln3579">        if (abort_macros)</a>
<a name="ln3580">        {</a>
<a name="ln3581">            crawl_state.cancel_cmd_again();</a>
<a name="ln3582">            crawl_state.cancel_cmd_repeat();</a>
<a name="ln3583">        }</a>
<a name="ln3584">        return false;</a>
<a name="ln3585">    }</a>
<a name="ln3586"> </a>
<a name="ln3587">    // We want to at least keep 1 HP. -- bwr</a>
<a name="ln3588">    if (you.hp &lt; minimum + 1)</a>
<a name="ln3589">    {</a>
<a name="ln3590">        if (!suppress_msg)</a>
<a name="ln3591">            mpr(&quot;You don't have enough health at the moment.&quot;);</a>
<a name="ln3592"> </a>
<a name="ln3593">        if (abort_macros)</a>
<a name="ln3594">        {</a>
<a name="ln3595">            crawl_state.cancel_cmd_again();</a>
<a name="ln3596">            crawl_state.cancel_cmd_repeat();</a>
<a name="ln3597">        }</a>
<a name="ln3598">        return false;</a>
<a name="ln3599">    }</a>
<a name="ln3600"> </a>
<a name="ln3601">    return true;</a>
<a name="ln3602">}</a>
<a name="ln3603"> </a>
<a name="ln3604">bool enough_mp(int minimum, bool suppress_msg, bool abort_macros)</a>
<a name="ln3605">{</a>
<a name="ln3606">    ASSERT(!crawl_state.game_is_arena());</a>
<a name="ln3607"> </a>
<a name="ln3608">    if (you.magic_points &lt; minimum)</a>
<a name="ln3609">    {</a>
<a name="ln3610">        if (!suppress_msg)</a>
<a name="ln3611">        {</a>
<a name="ln3612">            if (get_real_mp(true) &lt; minimum)</a>
<a name="ln3613">                mpr(&quot;You don't have enough magic capacity.&quot;);</a>
<a name="ln3614">            else</a>
<a name="ln3615">                mpr(&quot;You don't have enough magic at the moment.&quot;);</a>
<a name="ln3616">        }</a>
<a name="ln3617">        if (abort_macros)</a>
<a name="ln3618">        {</a>
<a name="ln3619">            crawl_state.cancel_cmd_again();</a>
<a name="ln3620">            crawl_state.cancel_cmd_repeat();</a>
<a name="ln3621">        }</a>
<a name="ln3622">        return false;</a>
<a name="ln3623">    }</a>
<a name="ln3624"> </a>
<a name="ln3625">    return true;</a>
<a name="ln3626">}</a>
<a name="ln3627"> </a>
<a name="ln3628">static int _rest_trigger_level(int max)</a>
<a name="ln3629">{</a>
<a name="ln3630">    return (max * Options.rest_wait_percent) / 100;</a>
<a name="ln3631">}</a>
<a name="ln3632"> </a>
<a name="ln3633">static bool _should_stop_resting(int cur, int max)</a>
<a name="ln3634">{</a>
<a name="ln3635">    return cur == max || cur == _rest_trigger_level(max);</a>
<a name="ln3636">}</a>
<a name="ln3637"> </a>
<a name="ln3638">void inc_mp(int mp_gain, bool silent)</a>
<a name="ln3639">{</a>
<a name="ln3640">    ASSERT(!crawl_state.game_is_arena());</a>
<a name="ln3641"> </a>
<a name="ln3642">    if (mp_gain &lt; 1 || you.magic_points &gt;= you.max_magic_points)</a>
<a name="ln3643">        return;</a>
<a name="ln3644"> </a>
<a name="ln3645">    you.magic_points += mp_gain;</a>
<a name="ln3646"> </a>
<a name="ln3647">    if (you.magic_points &gt; you.max_magic_points)</a>
<a name="ln3648">        you.magic_points = you.max_magic_points;</a>
<a name="ln3649"> </a>
<a name="ln3650">    if (!silent)</a>
<a name="ln3651">    {</a>
<a name="ln3652">        if (_should_stop_resting(you.magic_points, you.max_magic_points))</a>
<a name="ln3653">            interrupt_activity(activity_interrupt::full_mp);</a>
<a name="ln3654">        you.redraw_magic_points = true;</a>
<a name="ln3655">    }</a>
<a name="ln3656">}</a>
<a name="ln3657"> </a>
<a name="ln3658">// Note that &quot;max_too&quot; refers to the base potential, the actual</a>
<a name="ln3659">// resulting max value is subject to penalties, bonuses, and scalings.</a>
<a name="ln3660">// To avoid message spam, don't take notes when HP increases.</a>
<a name="ln3661">void inc_hp(int hp_gain)</a>
<a name="ln3662">{</a>
<a name="ln3663">    ASSERT(!crawl_state.game_is_arena());</a>
<a name="ln3664"> </a>
<a name="ln3665">    if (hp_gain &lt; 1 || you.hp &gt;= you.hp_max)</a>
<a name="ln3666">        return;</a>
<a name="ln3667"> </a>
<a name="ln3668">    you.hp += hp_gain;</a>
<a name="ln3669"> </a>
<a name="ln3670">    if (you.hp &gt; you.hp_max)</a>
<a name="ln3671">        you.hp = you.hp_max;</a>
<a name="ln3672"> </a>
<a name="ln3673">    if (_should_stop_resting(you.hp, you.hp_max))</a>
<a name="ln3674">        interrupt_activity(activity_interrupt::full_hp);</a>
<a name="ln3675"> </a>
<a name="ln3676">    you.redraw_hit_points = true;</a>
<a name="ln3677">}</a>
<a name="ln3678"> </a>
<a name="ln3679">void rot_hp(int hp_loss)</a>
<a name="ln3680">{</a>
<a name="ln3681">    if (!player_rotted() &amp;&amp; hp_loss &gt; 0)</a>
<a name="ln3682">        you.redraw_magic_points = true;</a>
<a name="ln3683"> </a>
<a name="ln3684">    const int initial_rot = you.hp_max_adj_temp;</a>
<a name="ln3685">    you.hp_max_adj_temp -= hp_loss;</a>
<a name="ln3686">    // don't allow more rot than you have normal mhp</a>
<a name="ln3687">    you.hp_max_adj_temp = max(-(get_real_hp(false, false) - 1),</a>
<a name="ln3688">                              you.hp_max_adj_temp);</a>
<a name="ln3689">    if (initial_rot == you.hp_max_adj_temp)</a>
<a name="ln3690">        return;</a>
<a name="ln3691"> </a>
<a name="ln3692">    calc_hp();</a>
<a name="ln3693"> </a>
<a name="ln3694">    if (you.species != SP_GHOUL)</a>
<a name="ln3695">        xom_is_stimulated(hp_loss * 25);</a>
<a name="ln3696"> </a>
<a name="ln3697">    you.redraw_hit_points = true;</a>
<a name="ln3698">}</a>
<a name="ln3699"> </a>
<a name="ln3700">int unrot_hp(int hp_recovered)</a>
<a name="ln3701">{</a>
<a name="ln3702">    int hp_balance = 0;</a>
<a name="ln3703">    if (hp_recovered &gt; -you.hp_max_adj_temp)</a>
<a name="ln3704">    {</a>
<a name="ln3705">        hp_balance = hp_recovered + you.hp_max_adj_temp;</a>
<a name="ln3706">        you.hp_max_adj_temp = 0;</a>
<a name="ln3707">    }</a>
<a name="ln3708">    else</a>
<a name="ln3709">        you.hp_max_adj_temp += hp_recovered;</a>
<a name="ln3710">    calc_hp();</a>
<a name="ln3711"> </a>
<a name="ln3712">    you.redraw_hit_points = true;</a>
<a name="ln3713">    if (!player_rotted())</a>
<a name="ln3714">        you.redraw_magic_points = true;</a>
<a name="ln3715">    return hp_balance;</a>
<a name="ln3716">}</a>
<a name="ln3717"> </a>
<a name="ln3718">int player_rotted()</a>
<a name="ln3719">{</a>
<a name="ln3720">    return -you.hp_max_adj_temp;</a>
<a name="ln3721">}</a>
<a name="ln3722"> </a>
<a name="ln3723">void rot_mp(int mp_loss)</a>
<a name="ln3724">{</a>
<a name="ln3725">    you.mp_max_adj -= mp_loss;</a>
<a name="ln3726">    calc_mp();</a>
<a name="ln3727"> </a>
<a name="ln3728">    you.redraw_magic_points = true;</a>
<a name="ln3729">}</a>
<a name="ln3730"> </a>
<a name="ln3731">void inc_max_hp(int hp_gain)</a>
<a name="ln3732">{</a>
<a name="ln3733">    you.hp += hp_gain;</a>
<a name="ln3734">    you.hp_max_adj_perm += hp_gain;</a>
<a name="ln3735">    calc_hp();</a>
<a name="ln3736"> </a>
<a name="ln3737">    take_note(Note(NOTE_MAXHP_CHANGE, you.hp_max));</a>
<a name="ln3738">    you.redraw_hit_points = true;</a>
<a name="ln3739">}</a>
<a name="ln3740"> </a>
<a name="ln3741">void dec_max_hp(int hp_loss)</a>
<a name="ln3742">{</a>
<a name="ln3743">    you.hp_max_adj_perm -= hp_loss;</a>
<a name="ln3744">    calc_hp();</a>
<a name="ln3745"> </a>
<a name="ln3746">    take_note(Note(NOTE_MAXHP_CHANGE, you.hp_max));</a>
<a name="ln3747">    you.redraw_hit_points = true;</a>
<a name="ln3748">}</a>
<a name="ln3749"> </a>
<a name="ln3750">void set_hp(int new_amount)</a>
<a name="ln3751">{</a>
<a name="ln3752">    ASSERT(!crawl_state.game_is_arena());</a>
<a name="ln3753"> </a>
<a name="ln3754">    you.hp = new_amount;</a>
<a name="ln3755"> </a>
<a name="ln3756">    if (you.hp &gt; you.hp_max)</a>
<a name="ln3757">        you.hp = you.hp_max;</a>
<a name="ln3758"> </a>
<a name="ln3759">    // Must remain outside conditional, given code usage. {dlb}</a>
<a name="ln3760">    you.redraw_hit_points = true;</a>
<a name="ln3761">}</a>
<a name="ln3762"> </a>
<a name="ln3763">void set_mp(int new_amount)</a>
<a name="ln3764">{</a>
<a name="ln3765">    ASSERT(!crawl_state.game_is_arena());</a>
<a name="ln3766"> </a>
<a name="ln3767">    you.magic_points = new_amount;</a>
<a name="ln3768"> </a>
<a name="ln3769">    if (you.magic_points &gt; you.max_magic_points)</a>
<a name="ln3770">        you.magic_points = you.max_magic_points;</a>
<a name="ln3771"> </a>
<a name="ln3772">    take_note(Note(NOTE_MP_CHANGE, you.magic_points, you.max_magic_points));</a>
<a name="ln3773"> </a>
<a name="ln3774">    // Must remain outside conditional, given code usage. {dlb}</a>
<a name="ln3775">    you.redraw_magic_points = true;</a>
<a name="ln3776">}</a>
<a name="ln3777"> </a>
<a name="ln3778">/**</a>
<a name="ln3779"> * Get the player's max HP</a>
<a name="ln3780"> * @param trans          Whether to include transformations, berserk,</a>
<a name="ln3781"> *                       items etc.</a>
<a name="ln3782"> * @param rotted         Whether to include the effects of rotting.</a>
<a name="ln3783"> * @return               The player's calculated max HP.</a>
<a name="ln3784"> */</a>
<a name="ln3785">int get_real_hp(bool trans, bool rotted)</a>
<a name="ln3786">{</a>
<a name="ln3787">    int hitp;</a>
<a name="ln3788"> </a>
<a name="ln3789">    hitp  = you.experience_level * 11 / 2 + 8;</a>
<a name="ln3790">    hitp += you.hp_max_adj_perm;</a>
<a name="ln3791">    // Important: we shouldn't add Heroism boosts here.</a>
<a name="ln3792">    hitp += you.experience_level * you.skill(SK_FIGHTING, 5, true) / 70</a>
<a name="ln3793">          + (you.skill(SK_FIGHTING, 3, true) + 1) / 2;</a>
<a name="ln3794"> </a>
<a name="ln3795">    // Racial modifier.</a>
<a name="ln3796">    hitp *= 10 + species_hp_modifier(you.species);</a>
<a name="ln3797">    hitp /= 10;</a>
<a name="ln3798"> </a>
<a name="ln3799">    const bool hep_frail = have_passive(passive_t::frail)</a>
<a name="ln3800">                           || player_under_penance(GOD_HEPLIAKLQANA);</a>
<a name="ln3801"> </a>
<a name="ln3802">    // Mutations that increase HP by a percentage</a>
<a name="ln3803">    hitp *= 100 + (you.get_mutation_level(MUT_ROBUST) * 10)</a>
<a name="ln3804">                + (you.attribute[ATTR_DIVINE_VIGOUR] * 5)</a>
<a name="ln3805">                + (you.get_mutation_level(MUT_RUGGED_BROWN_SCALES) ?</a>
<a name="ln3806">                   you.get_mutation_level(MUT_RUGGED_BROWN_SCALES) * 2 + 1 : 0)</a>
<a name="ln3807">                - (you.get_mutation_level(MUT_FRAIL) * 10)</a>
<a name="ln3808">                - (hep_frail ? 10 : 0)</a>
<a name="ln3809">                - (!you.vampire_alive ? 20 : 0);</a>
<a name="ln3810"> </a>
<a name="ln3811">    hitp /= 100;</a>
<a name="ln3812"> </a>
<a name="ln3813">    if (rotted)</a>
<a name="ln3814">        hitp += you.hp_max_adj_temp;</a>
<a name="ln3815"> </a>
<a name="ln3816">    if (trans)</a>
<a name="ln3817">        hitp += you.scan_artefacts(ARTP_HP);</a>
<a name="ln3818"> </a>
<a name="ln3819">    // Being berserk makes you resistant to damage. I don't know why.</a>
<a name="ln3820">    if (trans &amp;&amp; you.berserk())</a>
<a name="ln3821">        hitp = hitp * 3 / 2;</a>
<a name="ln3822"> </a>
<a name="ln3823">    // Some transformations give you extra hp.</a>
<a name="ln3824">    if (trans)</a>
<a name="ln3825">        hitp = hitp * form_hp_mod() / 10;</a>
<a name="ln3826"> </a>
<a name="ln3827">#if TAG_MAJOR_VERSION == 34</a>
<a name="ln3828">    if (trans &amp;&amp; player_equip_unrand(UNRAND_ETERNAL_TORMENT))</a>
<a name="ln3829">        hitp = hitp * 4 / 5;</a>
<a name="ln3830">#endif</a>
<a name="ln3831"> </a>
<a name="ln3832">    return max(1, hitp);</a>
<a name="ln3833">}</a>
<a name="ln3834"> </a>
<a name="ln3835">int get_real_mp(bool include_items)</a>
<a name="ln3836">{</a>
<a name="ln3837">    const int scale = 100;</a>
<a name="ln3838">    int spellcasting = you.skill(SK_SPELLCASTING, 1 * scale, true);</a>
<a name="ln3839">    int scaled_xl = you.experience_level * scale;</a>
<a name="ln3840"> </a>
<a name="ln3841">    // the first 4 experience levels give an extra .5 mp up to your spellcasting</a>
<a name="ln3842">    // the last 4 give no mp</a>
<a name="ln3843">    int enp = min(23 * scale, scaled_xl);</a>
<a name="ln3844"> </a>
<a name="ln3845">    int spell_extra = spellcasting; // 100%</a>
<a name="ln3846">    int invoc_extra = you.skill(SK_INVOCATIONS, 1 * scale, true) / 2; // 50%</a>
<a name="ln3847">    int evoc_extra = you.skill(SK_EVOCATIONS, 1 * scale, true) / 2; // 50%</a>
<a name="ln3848">    int highest_skill = max(spell_extra, max(invoc_extra, evoc_extra));</a>
<a name="ln3849">    enp += highest_skill + min(8 * scale, min(highest_skill, scaled_xl)) / 2;</a>
<a name="ln3850"> </a>
<a name="ln3851">    // Analogous to ROBUST/FRAIL</a>
<a name="ln3852">    enp *= 100 + (you.get_mutation_level(MUT_HIGH_MAGIC) * 10)</a>
<a name="ln3853">               + (you.attribute[ATTR_DIVINE_VIGOUR] * 5)</a>
<a name="ln3854">               - (you.get_mutation_level(MUT_LOW_MAGIC) * 10);</a>
<a name="ln3855">    enp /= 100 * scale;</a>
<a name="ln3856">//    enp = stepdown_value(enp, 9, 18, 45, 100)</a>
<a name="ln3857">    enp += species_mp_modifier(you.species);</a>
<a name="ln3858"> </a>
<a name="ln3859">    // This is our &quot;rotted&quot; base, applied after multipliers</a>
<a name="ln3860">    enp += you.mp_max_adj;</a>
<a name="ln3861"> </a>
<a name="ln3862">    // Now applied after scaling so that power items are more useful -- bwr</a>
<a name="ln3863">    if (include_items)</a>
<a name="ln3864">    {</a>
<a name="ln3865">        enp += 9 * you.wearing(EQ_RINGS, RING_MAGICAL_POWER);</a>
<a name="ln3866">        enp +=     you.scan_artefacts(ARTP_MAGICAL_POWER);</a>
<a name="ln3867">    }</a>
<a name="ln3868"> </a>
<a name="ln3869">    if (include_items &amp;&amp; you.wearing_ego(EQ_WEAPON, SPWPN_ANTIMAGIC))</a>
<a name="ln3870">        enp /= 3;</a>
<a name="ln3871"> </a>
<a name="ln3872">    enp = max(enp, 0);</a>
<a name="ln3873"> </a>
<a name="ln3874">    return enp;</a>
<a name="ln3875">}</a>
<a name="ln3876"> </a>
<a name="ln3877">bool player_regenerates_hp()</a>
<a name="ln3878">{</a>
<a name="ln3879">    if (you.has_mutation(MUT_NO_REGENERATION))</a>
<a name="ln3880">        return false;</a>
<a name="ln3881">    return true;</a>
<a name="ln3882">}</a>
<a name="ln3883"> </a>
<a name="ln3884">bool player_regenerates_mp()</a>
<a name="ln3885">{</a>
<a name="ln3886">    // Don't let DD use guardian spirit for free HP, since their</a>
<a name="ln3887">    // damage shaving is enough. (due, dpeg)</a>
<a name="ln3888">    if (you.spirit_shield() &amp;&amp; you.species == SP_DEEP_DWARF)</a>
<a name="ln3889">        return false;</a>
<a name="ln3890">#if TAG_MAJOR_VERSION == 34</a>
<a name="ln3891">    // Pakellas blocks MP regeneration.</a>
<a name="ln3892">    if (have_passive(passive_t::no_mp_regen) || player_under_penance(GOD_PAKELLAS))</a>
<a name="ln3893">        return false;</a>
<a name="ln3894">#endif</a>
<a name="ln3895">    return true;</a>
<a name="ln3896">}</a>
<a name="ln3897"> </a>
<a name="ln3898">int get_contamination_level()</a>
<a name="ln3899">{</a>
<a name="ln3900">    const int glow = you.magic_contamination;</a>
<a name="ln3901"> </a>
<a name="ln3902">    if (glow &gt; 60000)</a>
<a name="ln3903">        return glow / 20000 + 4;</a>
<a name="ln3904">    if (glow &gt; 40000)</a>
<a name="ln3905">        return 6;</a>
<a name="ln3906">    if (glow &gt; 25000)</a>
<a name="ln3907">        return 5;</a>
<a name="ln3908">    if (glow &gt; 15000)</a>
<a name="ln3909">        return 4;</a>
<a name="ln3910">    if (glow &gt; 5000)</a>
<a name="ln3911">        return 3;</a>
<a name="ln3912">    if (glow &gt; 3500) // An indicator that using another contamination-causing</a>
<a name="ln3913">        return 2;    // ability might risk causing yellow glow.</a>
<a name="ln3914">    if (glow &gt; 0)</a>
<a name="ln3915">        return 1;</a>
<a name="ln3916"> </a>
<a name="ln3917">    return 0;</a>
<a name="ln3918">}</a>
<a name="ln3919"> </a>
<a name="ln3920">bool player_severe_contamination()</a>
<a name="ln3921">{</a>
<a name="ln3922">    return get_contamination_level() &gt;= SEVERE_CONTAM_LEVEL;</a>
<a name="ln3923">}</a>
<a name="ln3924"> </a>
<a name="ln3925">/**</a>
<a name="ln3926"> * Provide a description of the given contamination 'level'.</a>
<a name="ln3927"> *</a>
<a name="ln3928"> * @param cont  A contamination 'tier', corresponding to a nonlinear</a>
<a name="ln3929"> *              contamination value; generated by get_contamination_level().</a>
<a name="ln3930"> *</a>
<a name="ln3931"> * @return      A string describing the player when in the given contamination</a>
<a name="ln3932"> *              level.</a>
<a name="ln3933"> */</a>
<a name="ln3934">string describe_contamination(int cont)</a>
<a name="ln3935">{</a>
<a name="ln3936">    /// Mappings from contamination levels to descriptions.</a>
<a name="ln3937">    static const string contam_descriptions[] =</a>
<a name="ln3938">    {</a>
<a name="ln3939">        &quot;&quot;,</a>
<a name="ln3940">        &quot;You are very lightly contaminated with residual magic.&quot;,</a>
<a name="ln3941">        &quot;You are lightly contaminated with residual magic.&quot;,</a>
<a name="ln3942">        &quot;You are contaminated with residual magic.&quot;,</a>
<a name="ln3943">        &quot;You are heavily infused with residual magic.&quot;,</a>
<a name="ln3944">        &quot;You are practically glowing with residual magic!&quot;,</a>
<a name="ln3945">        &quot;Your entire body has taken on an eerie glow!&quot;,</a>
<a name="ln3946">        &quot;You are engulfed in a nimbus of crackling magics!&quot;,</a>
<a name="ln3947">    };</a>
<a name="ln3948"> </a>
<a name="ln3949">    ASSERT(cont &gt;= 0);</a>
<a name="ln3950">    return contam_descriptions[min((size_t) cont,</a>
<a name="ln3951">                                   ARRAYSZ(contam_descriptions) - 1)];</a>
<a name="ln3952">}</a>
<a name="ln3953"> </a>
<a name="ln3954">// Controlled is true if the player actively did something to cause</a>
<a name="ln3955">// contamination.</a>
<a name="ln3956">void contaminate_player(int change, bool controlled, bool msg)</a>
<a name="ln3957">{</a>
<a name="ln3958">    ASSERT(!crawl_state.game_is_arena());</a>
<a name="ln3959"> </a>
<a name="ln3960">    int old_amount = you.magic_contamination;</a>
<a name="ln3961">    int old_level  = get_contamination_level();</a>
<a name="ln3962">    bool was_glowing = player_severe_contamination();</a>
<a name="ln3963">    int new_level  = 0;</a>
<a name="ln3964"> </a>
<a name="ln3965">#if TAG_MAJOR_VERSION == 34</a>
<a name="ln3966">    if (change &gt; 0 &amp;&amp; player_equip_unrand(UNRAND_ETHERIC_CAGE))</a>
<a name="ln3967">        change *= 2;</a>
<a name="ln3968">#endif</a>
<a name="ln3969"> </a>
<a name="ln3970">    you.magic_contamination = max(0, min(250000,</a>
<a name="ln3971">                                         you.magic_contamination + change));</a>
<a name="ln3972"> </a>
<a name="ln3973">    new_level = get_contamination_level();</a>
<a name="ln3974"> </a>
<a name="ln3975">    if (you.magic_contamination != old_amount)</a>
<a name="ln3976">        dprf(&quot;change: %d  radiation: %d&quot;, change, you.magic_contamination);</a>
<a name="ln3977"> </a>
<a name="ln3978">    if (new_level &gt; old_level)</a>
<a name="ln3979">    {</a>
<a name="ln3980">        if (msg)</a>
<a name="ln3981">        {</a>
<a name="ln3982">            mprf(player_severe_contamination() ? MSGCH_WARN : MSGCH_PLAIN,</a>
<a name="ln3983">                 &quot;%s&quot;, describe_contamination(new_level).c_str());</a>
<a name="ln3984">        }</a>
<a name="ln3985">        if (player_severe_contamination())</a>
<a name="ln3986">            xom_is_stimulated(new_level * 25);</a>
<a name="ln3987">    }</a>
<a name="ln3988">    else if (msg &amp;&amp; new_level &lt; old_level)</a>
<a name="ln3989">    {</a>
<a name="ln3990">        if (old_level == 1 &amp;&amp; new_level == 0)</a>
<a name="ln3991">            mpr(&quot;Your magical contamination has completely faded away.&quot;);</a>
<a name="ln3992">        else if (player_severe_contamination() || was_glowing)</a>
<a name="ln3993">        {</a>
<a name="ln3994">            mprf(MSGCH_RECOVERY,</a>
<a name="ln3995">                 &quot;You feel less contaminated with magical energies.&quot;);</a>
<a name="ln3996">        }</a>
<a name="ln3997"> </a>
<a name="ln3998">        if (!player_severe_contamination() &amp;&amp; was_glowing &amp;&amp; you.invisible())</a>
<a name="ln3999">        {</a>
<a name="ln4000">            mpr(&quot;You fade completely from view now that you are no longer &quot;</a>
<a name="ln4001">                &quot;glowing from magical contamination.&quot;);</a>
<a name="ln4002">        }</a>
<a name="ln4003">    }</a>
<a name="ln4004"> </a>
<a name="ln4005">    if (you.magic_contamination &gt; 0)</a>
<a name="ln4006">        learned_something_new(HINT_GLOWING);</a>
<a name="ln4007"> </a>
<a name="ln4008">    // Zin doesn't like mutations or mutagenic radiation.</a>
<a name="ln4009">    if (you_worship(GOD_ZIN))</a>
<a name="ln4010">    {</a>
<a name="ln4011">        // Whenever the glow status is first reached, give a warning message.</a>
<a name="ln4012">        if (!was_glowing &amp;&amp; player_severe_contamination())</a>
<a name="ln4013">            did_god_conduct(DID_CAUSE_GLOWING, 0, false);</a>
<a name="ln4014">        // If the player actively did something to increase glowing,</a>
<a name="ln4015">        // Zin is displeased.</a>
<a name="ln4016">        else if (controlled &amp;&amp; change &gt; 0 &amp;&amp; was_glowing)</a>
<a name="ln4017">            did_god_conduct(DID_CAUSE_GLOWING, 1 + new_level, true);</a>
<a name="ln4018">    }</a>
<a name="ln4019">}</a>
<a name="ln4020"> </a>
<a name="ln4021">/**</a>
<a name="ln4022"> * Increase the player's confusion duration.</a>
<a name="ln4023"> *</a>
<a name="ln4024"> * @param amount   The number of turns to increase confusion duration by.</a>
<a name="ln4025"> * @param quiet    Whether to suppress messaging on success/failure.</a>
<a name="ln4026"> * @param force    Whether to ignore resistance (used only for intentional</a>
<a name="ln4027"> *                 self-confusion, e.g. via ambrosia).</a>
<a name="ln4028"> * @return         Whether confusion was successful.</a>
<a name="ln4029"> */</a>
<a name="ln4030">bool confuse_player(int amount, bool quiet, bool force)</a>
<a name="ln4031">{</a>
<a name="ln4032">    ASSERT(!crawl_state.game_is_arena());</a>
<a name="ln4033"> </a>
<a name="ln4034">    if (amount &lt;= 0)</a>
<a name="ln4035">        return false;</a>
<a name="ln4036"> </a>
<a name="ln4037">    if (!force &amp;&amp; you.clarity())</a>
<a name="ln4038">    {</a>
<a name="ln4039">        if (!quiet)</a>
<a name="ln4040">            mpr(&quot;You feel momentarily confused.&quot;);</a>
<a name="ln4041">        return false;</a>
<a name="ln4042">    }</a>
<a name="ln4043"> </a>
<a name="ln4044">    if (!force &amp;&amp; you.duration[DUR_DIVINE_STAMINA] &gt; 0)</a>
<a name="ln4045">    {</a>
<a name="ln4046">        if (!quiet)</a>
<a name="ln4047">            mpr(&quot;Your divine stamina protects you from confusion!&quot;);</a>
<a name="ln4048">        return false;</a>
<a name="ln4049">    }</a>
<a name="ln4050"> </a>
<a name="ln4051">    const int old_value = you.duration[DUR_CONF];</a>
<a name="ln4052">    you.increase_duration(DUR_CONF, amount, 40);</a>
<a name="ln4053"> </a>
<a name="ln4054">    if (you.duration[DUR_CONF] &gt; old_value)</a>
<a name="ln4055">    {</a>
<a name="ln4056">        you.check_awaken(500);</a>
<a name="ln4057"> </a>
<a name="ln4058">        if (!quiet)</a>
<a name="ln4059">        {</a>
<a name="ln4060">            mprf(MSGCH_WARN, &quot;You are %sconfused.&quot;,</a>
<a name="ln4061">                 old_value &gt; 0 ? &quot;more &quot; : &quot;&quot;);</a>
<a name="ln4062">        }</a>
<a name="ln4063"> </a>
<a name="ln4064">        learned_something_new(HINT_YOU_ENCHANTED);</a>
<a name="ln4065"> </a>
<a name="ln4066">        xom_is_stimulated((you.duration[DUR_CONF] - old_value)</a>
<a name="ln4067">                           / BASELINE_DELAY);</a>
<a name="ln4068">    }</a>
<a name="ln4069"> </a>
<a name="ln4070">    return true;</a>
<a name="ln4071">}</a>
<a name="ln4072"> </a>
<a name="ln4073">void paralyse_player(string source, int amount)</a>
<a name="ln4074">{</a>
<a name="ln4075">    if (!amount)</a>
<a name="ln4076">        amount = 2 + random2(6 + you.duration[DUR_PARALYSIS] / BASELINE_DELAY);</a>
<a name="ln4077"> </a>
<a name="ln4078">    you.paralyse(nullptr, amount, source);</a>
<a name="ln4079">}</a>
<a name="ln4080"> </a>
<a name="ln4081">bool poison_player(int amount, string source, string source_aux, bool force)</a>
<a name="ln4082">{</a>
<a name="ln4083">    ASSERT(!crawl_state.game_is_arena());</a>
<a name="ln4084"> </a>
<a name="ln4085">    if (crawl_state.disables[DIS_AFFLICTIONS])</a>
<a name="ln4086">        return false;</a>
<a name="ln4087"> </a>
<a name="ln4088">    if (you.duration[DUR_DIVINE_STAMINA] &gt; 0)</a>
<a name="ln4089">    {</a>
<a name="ln4090">        mpr(&quot;Your divine stamina protects you from poison!&quot;);</a>
<a name="ln4091">        return false;</a>
<a name="ln4092">    }</a>
<a name="ln4093"> </a>
<a name="ln4094">    if (player_res_poison() &gt;= 3)</a>
<a name="ln4095">    {</a>
<a name="ln4096">        dprf(&quot;Cannot poison, you are immune!&quot;);</a>
<a name="ln4097">        return false;</a>
<a name="ln4098">    }</a>
<a name="ln4099">    else if (!force &amp;&amp; player_res_poison() &gt; 0 &amp;&amp; !one_chance_in(3))</a>
<a name="ln4100">        return false;</a>
<a name="ln4101"> </a>
<a name="ln4102">    const int old_value = you.duration[DUR_POISONING];</a>
<a name="ln4103">    const bool was_fatal = poison_is_lethal();</a>
<a name="ln4104"> </a>
<a name="ln4105">    if (player_res_poison() &lt; 0)</a>
<a name="ln4106">        amount *= 2;</a>
<a name="ln4107"> </a>
<a name="ln4108">    you.duration[DUR_POISONING] += amount * 1000;</a>
<a name="ln4109"> </a>
<a name="ln4110">    if (you.duration[DUR_POISONING] &gt; old_value)</a>
<a name="ln4111">    {</a>
<a name="ln4112">        if (poison_is_lethal() &amp;&amp; !was_fatal)</a>
<a name="ln4113">            mprf(MSGCH_DANGER, &quot;You are lethally poisoned!&quot;);</a>
<a name="ln4114">        else</a>
<a name="ln4115">        {</a>
<a name="ln4116">            mprf(MSGCH_WARN, &quot;You are %spoisoned.&quot;,</a>
<a name="ln4117">                old_value &gt; 0 ? &quot;more &quot; : &quot;&quot;);</a>
<a name="ln4118">        }</a>
<a name="ln4119"> </a>
<a name="ln4120">        learned_something_new(HINT_YOU_POISON);</a>
<a name="ln4121">    }</a>
<a name="ln4122"> </a>
<a name="ln4123">    you.props[&quot;poisoner&quot;] = source;</a>
<a name="ln4124">    you.props[&quot;poison_aux&quot;] = source_aux;</a>
<a name="ln4125"> </a>
<a name="ln4126">    // Display the poisoned segment of our health, in case we take no damage</a>
<a name="ln4127">    you.redraw_hit_points = true;</a>
<a name="ln4128"> </a>
<a name="ln4129">    return amount;</a>
<a name="ln4130">}</a>
<a name="ln4131"> </a>
<a name="ln4132">int get_player_poisoning()</a>
<a name="ln4133">{</a>
<a name="ln4134">    if (player_res_poison() &lt; 3)</a>
<a name="ln4135">    {</a>
<a name="ln4136">        // Approximate the effect of damage shaving by giving the first</a>
<a name="ln4137">        // 25 points of poison damage for 'free'</a>
<a name="ln4138">        if (you.species == SP_DEEP_DWARF)</a>
<a name="ln4139">            return max(0, (you.duration[DUR_POISONING] / 1000) - 25);</a>
<a name="ln4140">        else</a>
<a name="ln4141">            return you.duration[DUR_POISONING] / 1000;</a>
<a name="ln4142">    }</a>
<a name="ln4143">    else</a>
<a name="ln4144">        return 0;</a>
<a name="ln4145">}</a>
<a name="ln4146"> </a>
<a name="ln4147">// The amount of aut needed for poison to end if</a>
<a name="ln4148">// you.duration[DUR_POISONING] == dur, assuming no Chei/DD shenanigans.</a>
<a name="ln4149">// This function gives the following behaviour:</a>
<a name="ln4150">// * 1/15 of current poison is removed every 10 aut normally</a>
<a name="ln4151">// * but speed of poison is capped between 0.025 and 1.000 HP/aut</a>
<a name="ln4152">static double _poison_dur_to_aut(double dur)</a>
<a name="ln4153">{</a>
<a name="ln4154">    // Poison already at minimum speed.</a>
<a name="ln4155">    if (dur &lt; 15.0 * 250.0)</a>
<a name="ln4156">        return dur / 25.0;</a>
<a name="ln4157">    // Poison is not at maximum speed.</a>
<a name="ln4158">    if (dur &lt; 15.0 * 10000.0)</a>
<a name="ln4159">        return 150.0 + 10.0 * log(dur / (15.0 * 250.0)) / log(15.0 / 14.0);</a>
<a name="ln4160">    return 150.0 + (dur - 15.0 * 10000.0) / 1000.0</a>
<a name="ln4161">                 + 10.0 * log(10000.0 / 250.0) / log(15.0 / 14.0);</a>
<a name="ln4162">}</a>
<a name="ln4163"> </a>
<a name="ln4164">// The inverse of the above function, i.e. the amount of poison needed</a>
<a name="ln4165">// to last for aut time.</a>
<a name="ln4166">static double _poison_aut_to_dur(double aut)</a>
<a name="ln4167">{</a>
<a name="ln4168">    // Amount of time that poison lasts at minimum speed.</a>
<a name="ln4169">    if (aut &lt; 150.0)</a>
<a name="ln4170">        return aut * 25.0;</a>
<a name="ln4171">    // Amount of time that poison exactly at the maximum speed lasts.</a>
<a name="ln4172">    const double aut_from_max_speed = 150.0 + 10.0 * log(40.0) / log(15.0 / 14.0);</a>
<a name="ln4173">    if (aut &lt; aut_from_max_speed)</a>
<a name="ln4174">        return 15.0 * 250.0 * exp(log(15.0 / 14.0) / 10.0 * (aut - 150.0));</a>
<a name="ln4175">    return 15.0 * 10000.0 + 1000.0 * (aut - aut_from_max_speed);</a>
<a name="ln4176">}</a>
<a name="ln4177"> </a>
<a name="ln4178">void handle_player_poison(int delay)</a>
<a name="ln4179">{</a>
<a name="ln4180">    const double cur_dur = you.duration[DUR_POISONING];</a>
<a name="ln4181">    const double cur_aut = _poison_dur_to_aut(cur_dur);</a>
<a name="ln4182"> </a>
<a name="ln4183">    // If Cheibriados has slowed your life processes, poison affects you less</a>
<a name="ln4184">    // quickly (you take the same total damage, but spread out over a longer</a>
<a name="ln4185">    // period of time).</a>
<a name="ln4186">    const double delay_scaling = have_passive(passive_t::slow_metabolism)</a>
<a name="ln4187">                               ? 2.0 / 3.0 : 1.0;</a>
<a name="ln4188"> </a>
<a name="ln4189">    const double new_aut = cur_aut - ((double) delay) * delay_scaling;</a>
<a name="ln4190">    const double new_dur = _poison_aut_to_dur(new_aut);</a>
<a name="ln4191"> </a>
<a name="ln4192">    const int decrease = you.duration[DUR_POISONING] - (int) new_dur;</a>
<a name="ln4193"> </a>
<a name="ln4194">    // Transforming into a form with no metabolism merely suspends the poison</a>
<a name="ln4195">    // but doesn't let your body get rid of it.</a>
<a name="ln4196">    if (you.is_nonliving() || (you.undead_state() &amp;&amp; !you.vampire_alive))</a>
<a name="ln4197">        return;</a>
<a name="ln4198"> </a>
<a name="ln4199">    // Other sources of immunity (Zin, staff of Olgreb) let poison dissipate.</a>
<a name="ln4200">    bool do_dmg = (player_res_poison() &gt;= 3 ? false : true);</a>
<a name="ln4201"> </a>
<a name="ln4202">    int dmg = (you.duration[DUR_POISONING] / 1000)</a>
<a name="ln4203">               - ((you.duration[DUR_POISONING] - decrease) / 1000);</a>
<a name="ln4204"> </a>
<a name="ln4205">    // Approximate old damage shaving by giving immunity to small amounts</a>
<a name="ln4206">    // of poison. Stronger poison will do the same damage as for non-DD</a>
<a name="ln4207">    // until it goes below the threshold, which is a bit weird, but</a>
<a name="ln4208">    // so is damage shaving.</a>
<a name="ln4209">    if (you.species == SP_DEEP_DWARF &amp;&amp; you.duration[DUR_POISONING] - decrease &lt; 25000)</a>
<a name="ln4210">    {</a>
<a name="ln4211">        dmg = (you.duration[DUR_POISONING] / 1000)</a>
<a name="ln4212">            - (25000 / 1000);</a>
<a name="ln4213">        if (dmg &lt; 0)</a>
<a name="ln4214">            dmg = 0;</a>
<a name="ln4215">    }</a>
<a name="ln4216"> </a>
<a name="ln4217">    msg_channel_type channel = MSGCH_PLAIN;</a>
<a name="ln4218">    const char *adj = &quot;&quot;;</a>
<a name="ln4219"> </a>
<a name="ln4220">    if (dmg &gt; 6)</a>
<a name="ln4221">    {</a>
<a name="ln4222">        channel = MSGCH_DANGER;</a>
<a name="ln4223">        adj = &quot;extremely &quot;;</a>
<a name="ln4224">    }</a>
<a name="ln4225">    else if (dmg &gt; 2)</a>
<a name="ln4226">    {</a>
<a name="ln4227">        channel = MSGCH_WARN;</a>
<a name="ln4228">        adj = &quot;very &quot;;</a>
<a name="ln4229">    }</a>
<a name="ln4230"> </a>
<a name="ln4231">    if (do_dmg &amp;&amp; dmg &gt; 0)</a>
<a name="ln4232">    {</a>
<a name="ln4233">        int oldhp = you.hp;</a>
<a name="ln4234">        ouch(dmg, KILLED_BY_POISON);</a>
<a name="ln4235">        if (you.hp &lt; oldhp)</a>
<a name="ln4236">            mprf(channel, &quot;You feel %ssick.&quot;, adj);</a>
<a name="ln4237">    }</a>
<a name="ln4238"> </a>
<a name="ln4239">    // Now decrease the poison in our system</a>
<a name="ln4240">    reduce_player_poison(decrease);</a>
<a name="ln4241">}</a>
<a name="ln4242"> </a>
<a name="ln4243">void reduce_player_poison(int amount)</a>
<a name="ln4244">{</a>
<a name="ln4245">    if (amount &lt;= 0)</a>
<a name="ln4246">        return;</a>
<a name="ln4247"> </a>
<a name="ln4248">    you.duration[DUR_POISONING] -= amount;</a>
<a name="ln4249"> </a>
<a name="ln4250">    // Less than 1 point of damage remaining, so just end the poison</a>
<a name="ln4251">    if (you.duration[DUR_POISONING] &lt; 1000)</a>
<a name="ln4252">        you.duration[DUR_POISONING] = 0;</a>
<a name="ln4253"> </a>
<a name="ln4254">    if (you.duration[DUR_POISONING] &lt;= 0)</a>
<a name="ln4255">    {</a>
<a name="ln4256">        you.duration[DUR_POISONING] = 0;</a>
<a name="ln4257">        you.props.erase(&quot;poisoner&quot;);</a>
<a name="ln4258">        you.props.erase(&quot;poison_aux&quot;);</a>
<a name="ln4259">        mprf(MSGCH_RECOVERY, &quot;You are no longer poisoned.&quot;);</a>
<a name="ln4260">    }</a>
<a name="ln4261"> </a>
<a name="ln4262">    you.redraw_hit_points = true;</a>
<a name="ln4263">}</a>
<a name="ln4264"> </a>
<a name="ln4265">// Takes *current* regeneration rate into account. Might sometimes be</a>
<a name="ln4266">// incorrect, but hopefully if so then the player is surviving with 1 HP.</a>
<a name="ln4267">bool poison_is_lethal()</a>
<a name="ln4268">{</a>
<a name="ln4269">    if (you.hp &lt;= 0)</a>
<a name="ln4270">        return get_player_poisoning();</a>
<a name="ln4271">    if (get_player_poisoning() &lt; you.hp)</a>
<a name="ln4272">        return false;</a>
<a name="ln4273">    return poison_survival() &lt;= 0;</a>
<a name="ln4274">}</a>
<a name="ln4275"> </a>
<a name="ln4276">// Try to predict the minimum value of the player's health in the coming</a>
<a name="ln4277">// turns given the current poison amount and regen rate.</a>
<a name="ln4278">int poison_survival()</a>
<a name="ln4279">{</a>
<a name="ln4280">    if (!get_player_poisoning())</a>
<a name="ln4281">        return you.hp;</a>
<a name="ln4282">    const int rr = player_regen();</a>
<a name="ln4283">    const bool chei = have_passive(passive_t::slow_metabolism);</a>
<a name="ln4284">    const bool dd = (you.species == SP_DEEP_DWARF);</a>
<a name="ln4285">    const int amount = you.duration[DUR_POISONING];</a>
<a name="ln4286">    const double full_aut = _poison_dur_to_aut(amount);</a>
<a name="ln4287">    // Calculate the poison amount at which regen starts to beat poison.</a>
<a name="ln4288">    double min_poison_rate = 0.25;</a>
<a name="ln4289">    if (dd)</a>
<a name="ln4290">        min_poison_rate = 25.0/15.0;</a>
<a name="ln4291">    if (chei)</a>
<a name="ln4292">        min_poison_rate /= 1.5;</a>
<a name="ln4293">    int regen_beats_poison;</a>
<a name="ln4294">    if (rr &lt;= (int) (100.0 * min_poison_rate))</a>
<a name="ln4295">        regen_beats_poison = dd ? 25000 : 0;</a>
<a name="ln4296">    else</a>
<a name="ln4297">    {</a>
<a name="ln4298">        regen_beats_poison = 150 * rr;</a>
<a name="ln4299">        if (chei)</a>
<a name="ln4300">            regen_beats_poison = 3 * regen_beats_poison / 2;</a>
<a name="ln4301">    }</a>
<a name="ln4302"> </a>
<a name="ln4303">    if (rr == 0)</a>
<a name="ln4304">        return min(you.hp, you.hp - amount / 1000 + regen_beats_poison / 1000);</a>
<a name="ln4305"> </a>
<a name="ln4306">    // Calculate the amount of time until regen starts to beat poison.</a>
<a name="ln4307">    double poison_duration = full_aut - _poison_dur_to_aut(regen_beats_poison);</a>
<a name="ln4308"> </a>
<a name="ln4309">    if (poison_duration &lt; 0)</a>
<a name="ln4310">        poison_duration = 0;</a>
<a name="ln4311">    if (chei)</a>
<a name="ln4312">        poison_duration *= 1.5;</a>
<a name="ln4313"> </a>
<a name="ln4314">    // Worst case scenario is right before natural regen gives you a point of</a>
<a name="ln4315">    // HP, so consider the nearest two such points.</a>
<a name="ln4316">    const int predicted_regen = (int) ((((double) you.hit_points_regeneration) + rr * poison_duration / 10.0) / 100.0);</a>
<a name="ln4317">    double test_aut1 = (100.0 * predicted_regen - 1.0 - ((double) you.hit_points_regeneration)) / (rr / 10.0);</a>
<a name="ln4318">    double test_aut2 = (100.0 * predicted_regen + 99.0 - ((double) you.hit_points_regeneration)) / (rr / 10.0);</a>
<a name="ln4319"> </a>
<a name="ln4320">    if (chei)</a>
<a name="ln4321">    {</a>
<a name="ln4322">        test_aut1 /= 1.5;</a>
<a name="ln4323">        test_aut2 /= 1.5;</a>
<a name="ln4324">    }</a>
<a name="ln4325"> </a>
<a name="ln4326">    const int test_amount1 = _poison_aut_to_dur(full_aut - test_aut1);</a>
<a name="ln4327">    const int test_amount2 = _poison_aut_to_dur(full_aut - test_aut2);</a>
<a name="ln4328"> </a>
<a name="ln4329">    int prediction1 = you.hp;</a>
<a name="ln4330">    int prediction2 = you.hp;</a>
<a name="ln4331"> </a>
<a name="ln4332">    // Don't look backwards in time.</a>
<a name="ln4333">    if (test_aut1 &gt; 0)</a>
<a name="ln4334">        prediction1 -= (amount / 1000 - test_amount1 / 1000 - (predicted_regen - 1));</a>
<a name="ln4335">    prediction2 -= (amount / 1000 - test_amount2 / 1000 - predicted_regen);</a>
<a name="ln4336"> </a>
<a name="ln4337">    return min(prediction1, prediction2);</a>
<a name="ln4338">}</a>
<a name="ln4339"> </a>
<a name="ln4340">bool miasma_player(actor *who, string source_aux)</a>
<a name="ln4341">{</a>
<a name="ln4342">    ASSERT(!crawl_state.game_is_arena());</a>
<a name="ln4343"> </a>
<a name="ln4344">    if (you.res_rotting() || you.duration[DUR_DEATHS_DOOR])</a>
<a name="ln4345">        return false;</a>
<a name="ln4346"> </a>
<a name="ln4347">    if (you.duration[DUR_DIVINE_STAMINA] &gt; 0)</a>
<a name="ln4348">    {</a>
<a name="ln4349">        mpr(&quot;Your divine stamina protects you from the miasma!&quot;);</a>
<a name="ln4350">        return false;</a>
<a name="ln4351">    }</a>
<a name="ln4352"> </a>
<a name="ln4353">    bool success = poison_player(5 + roll_dice(3, 12),</a>
<a name="ln4354">                                 who ? who-&gt;name(DESC_A) : &quot;&quot;,</a>
<a name="ln4355">                                 source_aux);</a>
<a name="ln4356"> </a>
<a name="ln4357">    if (coinflip())</a>
<a name="ln4358">    {</a>
<a name="ln4359">        you.rot(who, 1);</a>
<a name="ln4360">        success = true;</a>
<a name="ln4361">    }</a>
<a name="ln4362"> </a>
<a name="ln4363">    if (one_chance_in(3))</a>
<a name="ln4364">    {</a>
<a name="ln4365">        slow_player(10 + random2(5));</a>
<a name="ln4366">        success = true;</a>
<a name="ln4367">    }</a>
<a name="ln4368"> </a>
<a name="ln4369">    return success;</a>
<a name="ln4370">}</a>
<a name="ln4371"> </a>
<a name="ln4372">bool napalm_player(int amount, string source, string source_aux)</a>
<a name="ln4373">{</a>
<a name="ln4374">    ASSERT(!crawl_state.game_is_arena());</a>
<a name="ln4375"> </a>
<a name="ln4376">    if (player_res_sticky_flame() || amount &lt;= 0 || you.duration[DUR_WATER_HOLD] || feat_is_watery(grd(you.pos())))</a>
<a name="ln4377">        return false;</a>
<a name="ln4378"> </a>
<a name="ln4379">    const int old_value = you.duration[DUR_LIQUID_FLAMES];</a>
<a name="ln4380">    you.increase_duration(DUR_LIQUID_FLAMES, amount, 100);</a>
<a name="ln4381"> </a>
<a name="ln4382">    if (you.duration[DUR_LIQUID_FLAMES] &gt; old_value)</a>
<a name="ln4383">        mprf(MSGCH_WARN, &quot;You are covered in liquid flames!&quot;);</a>
<a name="ln4384"> </a>
<a name="ln4385">    you.props[&quot;sticky_flame_source&quot;] = source;</a>
<a name="ln4386">    you.props[&quot;sticky_flame_aux&quot;] = source_aux;</a>
<a name="ln4387"> </a>
<a name="ln4388">    return true;</a>
<a name="ln4389">}</a>
<a name="ln4390"> </a>
<a name="ln4391">void dec_napalm_player(int delay)</a>
<a name="ln4392">{</a>
<a name="ln4393">    delay = min(delay, you.duration[DUR_LIQUID_FLAMES]);</a>
<a name="ln4394"> </a>
<a name="ln4395">    if (feat_is_watery(grd(you.pos())))</a>
<a name="ln4396">    {</a>
<a name="ln4397">        if (you.ground_level())</a>
<a name="ln4398">            mprf(MSGCH_WARN, &quot;The flames go out!&quot;);</a>
<a name="ln4399">        else</a>
<a name="ln4400">            mprf(MSGCH_WARN, &quot;You dip into the water, and the flames go out!&quot;);</a>
<a name="ln4401">        you.duration[DUR_LIQUID_FLAMES] = 0;</a>
<a name="ln4402">        you.props.erase(&quot;sticky_flame_source&quot;);</a>
<a name="ln4403">        you.props.erase(&quot;sticky_flame_aux&quot;);</a>
<a name="ln4404">        return;</a>
<a name="ln4405">    }</a>
<a name="ln4406"> </a>
<a name="ln4407">    mprf(MSGCH_WARN, &quot;You are covered in liquid flames!&quot;);</a>
<a name="ln4408"> </a>
<a name="ln4409">    const int hurted = resist_adjust_damage(&amp;you, BEAM_FIRE,</a>
<a name="ln4410">                                            random2avg(9, 2) + 1);</a>
<a name="ln4411"> </a>
<a name="ln4412">    you.expose_to_element(BEAM_STICKY_FLAME, 2);</a>
<a name="ln4413">    maybe_melt_player_enchantments(BEAM_STICKY_FLAME, hurted * delay / BASELINE_DELAY);</a>
<a name="ln4414"> </a>
<a name="ln4415">    ouch(hurted * delay / BASELINE_DELAY, KILLED_BY_BURNING);</a>
<a name="ln4416"> </a>
<a name="ln4417">    you.duration[DUR_LIQUID_FLAMES] -= delay;</a>
<a name="ln4418">    if (you.duration[DUR_LIQUID_FLAMES] &lt;= 0)</a>
<a name="ln4419">    {</a>
<a name="ln4420">        you.props.erase(&quot;sticky_flame_source&quot;);</a>
<a name="ln4421">        you.props.erase(&quot;sticky_flame_aux&quot;);</a>
<a name="ln4422">    }</a>
<a name="ln4423">}</a>
<a name="ln4424"> </a>
<a name="ln4425">bool slow_player(int turns)</a>
<a name="ln4426">{</a>
<a name="ln4427">    ASSERT(!crawl_state.game_is_arena());</a>
<a name="ln4428"> </a>
<a name="ln4429">    if (turns &lt;= 0)</a>
<a name="ln4430">        return false;</a>
<a name="ln4431"> </a>
<a name="ln4432">    if (you.stasis())</a>
<a name="ln4433">    {</a>
<a name="ln4434">        mpr(&quot;Your stasis prevents you from being slowed.&quot;);</a>
<a name="ln4435">        return false;</a>
<a name="ln4436">    }</a>
<a name="ln4437"> </a>
<a name="ln4438">    // Multiplying these values because moving while slowed takes longer than</a>
<a name="ln4439">    // the usual delay.</a>
<a name="ln4440">    turns = haste_mul(turns);</a>
<a name="ln4441">    int threshold = haste_mul(100);</a>
<a name="ln4442"> </a>
<a name="ln4443">    if (you.duration[DUR_SLOW] &gt;= threshold * BASELINE_DELAY)</a>
<a name="ln4444">        mpr(&quot;You already are as slow as you could be.&quot;);</a>
<a name="ln4445">    else</a>
<a name="ln4446">    {</a>
<a name="ln4447">        if (you.duration[DUR_SLOW] == 0)</a>
<a name="ln4448">            mpr(&quot;You feel yourself slow down.&quot;);</a>
<a name="ln4449">        else</a>
<a name="ln4450">            mpr(&quot;You feel as though you will be slow longer.&quot;);</a>
<a name="ln4451"> </a>
<a name="ln4452">        you.increase_duration(DUR_SLOW, turns, threshold);</a>
<a name="ln4453">        learned_something_new(HINT_YOU_ENCHANTED);</a>
<a name="ln4454">    }</a>
<a name="ln4455"> </a>
<a name="ln4456">    return true;</a>
<a name="ln4457">}</a>
<a name="ln4458"> </a>
<a name="ln4459">void dec_slow_player(int delay)</a>
<a name="ln4460">{</a>
<a name="ln4461">    if (!you.duration[DUR_SLOW])</a>
<a name="ln4462">        return;</a>
<a name="ln4463"> </a>
<a name="ln4464">    if (you.duration[DUR_SLOW] &gt; BASELINE_DELAY)</a>
<a name="ln4465">    {</a>
<a name="ln4466">        // Make slowing and hasting effects last as long.</a>
<a name="ln4467">        you.duration[DUR_SLOW] -= you.duration[DUR_HASTE]</a>
<a name="ln4468">            ? haste_mul(delay) : delay;</a>
<a name="ln4469">    }</a>
<a name="ln4470"> </a>
<a name="ln4471">    if (you.torpor_slowed())</a>
<a name="ln4472">    {</a>
<a name="ln4473">        you.duration[DUR_SLOW] = 1;</a>
<a name="ln4474">        return;</a>
<a name="ln4475">    }</a>
<a name="ln4476">    if (you.props.exists(TORPOR_SLOWED_KEY))</a>
<a name="ln4477">        you.props.erase(TORPOR_SLOWED_KEY);</a>
<a name="ln4478"> </a>
<a name="ln4479">    if (you.duration[DUR_SLOW] &lt;= BASELINE_DELAY)</a>
<a name="ln4480">    {</a>
<a name="ln4481">        you.duration[DUR_SLOW] = 0;</a>
<a name="ln4482">        if (!have_stat_zero())</a>
<a name="ln4483">            mprf(MSGCH_DURATION, &quot;You feel yourself speed up.&quot;);</a>
<a name="ln4484">    }</a>
<a name="ln4485">}</a>
<a name="ln4486"> </a>
<a name="ln4487">void dec_berserk_recovery_player(int delay)</a>
<a name="ln4488">{</a>
<a name="ln4489">    if (!you.duration[DUR_BERSERK_COOLDOWN])</a>
<a name="ln4490">        return;</a>
<a name="ln4491"> </a>
<a name="ln4492">    if (you.duration[DUR_BERSERK_COOLDOWN] &gt; BASELINE_DELAY)</a>
<a name="ln4493">    {</a>
<a name="ln4494">        you.duration[DUR_BERSERK_COOLDOWN] -= you.duration[DUR_HASTE]</a>
<a name="ln4495">                                              ? haste_mul(delay) : delay;</a>
<a name="ln4496">    }</a>
<a name="ln4497"> </a>
<a name="ln4498">    if (you.duration[DUR_BERSERK_COOLDOWN] &lt;= BASELINE_DELAY)</a>
<a name="ln4499">    {</a>
<a name="ln4500">        mprf(MSGCH_DURATION, &quot;You recover from your berserk rage.&quot;);</a>
<a name="ln4501">        you.duration[DUR_BERSERK_COOLDOWN] = 0;</a>
<a name="ln4502">    }</a>
<a name="ln4503">}</a>
<a name="ln4504"> </a>
<a name="ln4505">bool haste_player(int turns, bool rageext)</a>
<a name="ln4506">{</a>
<a name="ln4507">    ASSERT(!crawl_state.game_is_arena());</a>
<a name="ln4508"> </a>
<a name="ln4509">    if (turns &lt;= 0)</a>
<a name="ln4510">        return false;</a>
<a name="ln4511"> </a>
<a name="ln4512">    if (you.stasis())</a>
<a name="ln4513">    {</a>
<a name="ln4514">        mpr(&quot;Your stasis prevents you from being hasted.&quot;);</a>
<a name="ln4515">        return false;</a>
<a name="ln4516">    }</a>
<a name="ln4517"> </a>
<a name="ln4518">    // Cutting the nominal turns in half since hasted actions take half the</a>
<a name="ln4519">    // usual delay.</a>
<a name="ln4520">    turns = haste_div(turns);</a>
<a name="ln4521">    const int threshold = 40;</a>
<a name="ln4522"> </a>
<a name="ln4523">    if (!you.duration[DUR_HASTE])</a>
<a name="ln4524">        mpr(&quot;You feel yourself speed up.&quot;);</a>
<a name="ln4525">    else if (you.duration[DUR_HASTE] &gt; threshold * BASELINE_DELAY)</a>
<a name="ln4526">        mpr(&quot;You already have as much speed as you can handle.&quot;);</a>
<a name="ln4527">    else if (!rageext)</a>
<a name="ln4528">        mpr(&quot;You feel as though your hastened speed will last longer.&quot;);</a>
<a name="ln4529"> </a>
<a name="ln4530">    you.increase_duration(DUR_HASTE, turns, threshold);</a>
<a name="ln4531"> </a>
<a name="ln4532">    return true;</a>
<a name="ln4533">}</a>
<a name="ln4534"> </a>
<a name="ln4535">void dec_haste_player(int delay)</a>
<a name="ln4536">{</a>
<a name="ln4537">    if (!you.duration[DUR_HASTE])</a>
<a name="ln4538">        return;</a>
<a name="ln4539"> </a>
<a name="ln4540">    if (you.duration[DUR_HASTE] &gt; BASELINE_DELAY)</a>
<a name="ln4541">    {</a>
<a name="ln4542">        int old_dur = you.duration[DUR_HASTE];</a>
<a name="ln4543"> </a>
<a name="ln4544">        you.duration[DUR_HASTE] -= delay;</a>
<a name="ln4545"> </a>
<a name="ln4546">        int threshold = 6 * BASELINE_DELAY;</a>
<a name="ln4547">        // message if we cross the threshold</a>
<a name="ln4548">        if (old_dur &gt; threshold &amp;&amp; you.duration[DUR_HASTE] &lt;= threshold)</a>
<a name="ln4549">        {</a>
<a name="ln4550">            mprf(MSGCH_DURATION, &quot;Your extra speed is starting to run out.&quot;);</a>
<a name="ln4551">            if (coinflip())</a>
<a name="ln4552">                you.duration[DUR_HASTE] -= BASELINE_DELAY;</a>
<a name="ln4553">        }</a>
<a name="ln4554">    }</a>
<a name="ln4555">    else if (you.duration[DUR_HASTE] &lt;= BASELINE_DELAY)</a>
<a name="ln4556">    {</a>
<a name="ln4557">        if (!you.duration[DUR_BERSERK])</a>
<a name="ln4558">            mprf(MSGCH_DURATION, &quot;You feel yourself slow down.&quot;);</a>
<a name="ln4559">        you.duration[DUR_HASTE] = 0;</a>
<a name="ln4560">    }</a>
<a name="ln4561">}</a>
<a name="ln4562"> </a>
<a name="ln4563">void dec_disease_player(int delay)</a>
<a name="ln4564">{</a>
<a name="ln4565">    if (you.disease)</a>
<a name="ln4566">    {</a>
<a name="ln4567">        int rr = 50;</a>
<a name="ln4568"> </a>
<a name="ln4569">        // Extra regeneration means faster recovery from disease.</a>
<a name="ln4570">        // But not if not actually regenerating!</a>
<a name="ln4571">        if (player_regenerates_hp())</a>
<a name="ln4572">            rr += _player_bonus_regen();</a>
<a name="ln4573"> </a>
<a name="ln4574">        // Trog's Hand.</a>
<a name="ln4575">        if (you.duration[DUR_TROGS_HAND])</a>
<a name="ln4576">            rr += 100;</a>
<a name="ln4577"> </a>
<a name="ln4578">        rr = div_rand_round(rr * delay, 50);</a>
<a name="ln4579"> </a>
<a name="ln4580">        you.disease -= rr;</a>
<a name="ln4581">        if (you.disease &lt; 0)</a>
<a name="ln4582">            you.disease = 0;</a>
<a name="ln4583"> </a>
<a name="ln4584">        if (you.disease == 0)</a>
<a name="ln4585">            mprf(MSGCH_RECOVERY, &quot;You feel your health improve.&quot;);</a>
<a name="ln4586">    }</a>
<a name="ln4587">}</a>
<a name="ln4588"> </a>
<a name="ln4589">static void _dec_elixir_hp(int delay)</a>
<a name="ln4590">{</a>
<a name="ln4591">    you.duration[DUR_ELIXIR_HEALTH] -= delay;</a>
<a name="ln4592">    if (you.duration[DUR_ELIXIR_HEALTH] &lt; 0)</a>
<a name="ln4593">        you.duration[DUR_ELIXIR_HEALTH] = 0;</a>
<a name="ln4594"> </a>
<a name="ln4595">    int heal = (delay * you.hp_max / 10) / BASELINE_DELAY;</a>
<a name="ln4596">    if (!you.duration[DUR_DEATHS_DOOR])</a>
<a name="ln4597">        inc_hp(heal);</a>
<a name="ln4598">}</a>
<a name="ln4599"> </a>
<a name="ln4600">static void _dec_elixir_mp(int delay)</a>
<a name="ln4601">{</a>
<a name="ln4602">    you.duration[DUR_ELIXIR_MAGIC] -= delay;</a>
<a name="ln4603">    if (you.duration[DUR_ELIXIR_MAGIC] &lt; 0)</a>
<a name="ln4604">        you.duration[DUR_ELIXIR_MAGIC] = 0;</a>
<a name="ln4605"> </a>
<a name="ln4606">    int heal = (delay * you.max_magic_points / 10) / BASELINE_DELAY;</a>
<a name="ln4607">    inc_mp(heal);</a>
<a name="ln4608">}</a>
<a name="ln4609"> </a>
<a name="ln4610">void dec_elixir_player(int delay)</a>
<a name="ln4611">{</a>
<a name="ln4612">    if (you.duration[DUR_ELIXIR_HEALTH])</a>
<a name="ln4613">        _dec_elixir_hp(delay);</a>
<a name="ln4614">    if (you.duration[DUR_ELIXIR_MAGIC])</a>
<a name="ln4615">        _dec_elixir_mp(delay);</a>
<a name="ln4616">}</a>
<a name="ln4617"> </a>
<a name="ln4618">void dec_ambrosia_player(int delay)</a>
<a name="ln4619">{</a>
<a name="ln4620">    if (!you.duration[DUR_AMBROSIA])</a>
<a name="ln4621">        return;</a>
<a name="ln4622"> </a>
<a name="ln4623">    // ambrosia ends when confusion does.</a>
<a name="ln4624">    if (!you.confused())</a>
<a name="ln4625">        you.duration[DUR_AMBROSIA] = 0;</a>
<a name="ln4626"> </a>
<a name="ln4627">    you.duration[DUR_AMBROSIA] = max(0, you.duration[DUR_AMBROSIA] - delay);</a>
<a name="ln4628"> </a>
<a name="ln4629">    // 3-5 per turn, 9-50 over (3-10) turns</a>
<a name="ln4630">    const int hp_restoration = div_rand_round(delay*(3 + random2(3)), BASELINE_DELAY);</a>
<a name="ln4631">    const int mp_restoration = div_rand_round(delay*(3 + random2(3)), BASELINE_DELAY);</a>
<a name="ln4632"> </a>
<a name="ln4633">    if (!you.duration[DUR_DEATHS_DOOR])</a>
<a name="ln4634">        inc_hp(you.scale_potion_healing(hp_restoration));</a>
<a name="ln4635"> </a>
<a name="ln4636">    inc_mp(mp_restoration);</a>
<a name="ln4637"> </a>
<a name="ln4638">    if (!you.duration[DUR_AMBROSIA])</a>
<a name="ln4639">        mpr(&quot;You feel less invigorated.&quot;);</a>
<a name="ln4640">}</a>
<a name="ln4641"> </a>
<a name="ln4642">void dec_channel_player(int delay)</a>
<a name="ln4643">{</a>
<a name="ln4644">    if (!you.duration[DUR_CHANNEL_ENERGY])</a>
<a name="ln4645">        return;</a>
<a name="ln4646"> </a>
<a name="ln4647">    you.duration[DUR_CHANNEL_ENERGY] =</a>
<a name="ln4648">        max(0, you.duration[DUR_CHANNEL_ENERGY] - delay);</a>
<a name="ln4649"> </a>
<a name="ln4650">    // 3-5 per turn, 9-50 over (3-10) turns</a>
<a name="ln4651">    const int mp_restoration = div_rand_round(delay*(3 + random2(3)),</a>
<a name="ln4652">                                              BASELINE_DELAY);</a>
<a name="ln4653">    inc_mp(mp_restoration);</a>
<a name="ln4654"> </a>
<a name="ln4655">    if (!you.duration[DUR_CHANNEL_ENERGY])</a>
<a name="ln4656">        mpr(&quot;You feel less invigorated.&quot;);</a>
<a name="ln4657">}</a>
<a name="ln4658"> </a>
<a name="ln4659">void dec_frozen_ramparts(int delay)</a>
<a name="ln4660">{</a>
<a name="ln4661">    if (!you.duration[DUR_FROZEN_RAMPARTS])</a>
<a name="ln4662">        return;</a>
<a name="ln4663"> </a>
<a name="ln4664">    you.duration[DUR_FROZEN_RAMPARTS] =</a>
<a name="ln4665">        max(0, you.duration[DUR_FROZEN_RAMPARTS] - delay);</a>
<a name="ln4666"> </a>
<a name="ln4667">    if (!you.duration[DUR_FROZEN_RAMPARTS])</a>
<a name="ln4668">    {</a>
<a name="ln4669">        ASSERT(you.props.exists(FROZEN_RAMPARTS_KEY));</a>
<a name="ln4670">        const auto &amp;pos = you.props[FROZEN_RAMPARTS_KEY].get_coord();</a>
<a name="ln4671">        ASSERT(in_bounds(pos));</a>
<a name="ln4672"> </a>
<a name="ln4673">        for (distance_iterator di(pos, false, false,</a>
<a name="ln4674">                    spell_range(SPELL_FROZEN_RAMPARTS, -1, false)); di; di++)</a>
<a name="ln4675">        {</a>
<a name="ln4676">            env.pgrid(*di) &amp;= ~FPROP_ICY;</a>
<a name="ln4677">            env.map_knowledge(*di).flags &amp;= ~MAP_ICY;</a>
<a name="ln4678">        }</a>
<a name="ln4679"> </a>
<a name="ln4680">        you.props.erase(FROZEN_RAMPARTS_KEY);</a>
<a name="ln4681"> </a>
<a name="ln4682">        env.level_state &amp;= ~LSTATE_ICY_WALL;</a>
<a name="ln4683"> </a>
<a name="ln4684">        mpr(&quot;The frozen ramparts melt away.&quot;);</a>
<a name="ln4685">    }</a>
<a name="ln4686">}</a>
<a name="ln4687"> </a>
<a name="ln4688">bool invis_allowed(bool quiet, string *fail_reason)</a>
<a name="ln4689">{</a>
<a name="ln4690">    string msg;</a>
<a name="ln4691">    bool success = true;</a>
<a name="ln4692"> </a>
<a name="ln4693">    if (you.haloed() &amp;&amp; you.halo_radius() != -1)</a>
<a name="ln4694">    {</a>
<a name="ln4695">        bool divine = you.props.exists(WU_JIAN_HEAVENLY_STORM_KEY)</a>
<a name="ln4696">                      || you.religion == GOD_SHINING_ONE;</a>
<a name="ln4697">        bool weapon = player_equip_unrand(UNRAND_EOS);</a>
<a name="ln4698">        string reason;</a>
<a name="ln4699"> </a>
<a name="ln4700">        if (divine &amp;&amp; weapon)</a>
<a name="ln4701">            reason = &quot;Your weapon and divine halo glow too brightly&quot;;</a>
<a name="ln4702">        else if (divine)</a>
<a name="ln4703">            reason = &quot;Your divine halo glows too radiantly&quot;;</a>
<a name="ln4704">        else if (weapon)</a>
<a name="ln4705">            reason = &quot;Your weapon shines too brightly&quot;;</a>
<a name="ln4706">        else</a>
<a name="ln4707">            die(&quot;haloed by an unknown source&quot;);</a>
<a name="ln4708"> </a>
<a name="ln4709">        msg = reason + &quot; to become invisible.&quot;;</a>
<a name="ln4710">        success = false;</a>
<a name="ln4711">    }</a>
<a name="ln4712">    else if (you.backlit())</a>
<a name="ln4713">    {</a>
<a name="ln4714">        msg = &quot;Invisibility will do you no good right now&quot;;</a>
<a name="ln4715">        if (quiet)</a>
<a name="ln4716">            success = false;</a>
<a name="ln4717">        else if (!quiet &amp;&amp; !yesno((msg + &quot;; use anyway?&quot;).c_str(), false, 'n'))</a>
<a name="ln4718">        {</a>
<a name="ln4719">            canned_msg(MSG_OK);</a>
<a name="ln4720">            success = false;</a>
<a name="ln4721">            quiet = true; // since we just said something</a>
<a name="ln4722">        }</a>
<a name="ln4723">        msg += &quot;.&quot;;</a>
<a name="ln4724">    }</a>
<a name="ln4725"> </a>
<a name="ln4726">    if (!success)</a>
<a name="ln4727">    {</a>
<a name="ln4728">        if (fail_reason)</a>
<a name="ln4729">            *fail_reason = msg;</a>
<a name="ln4730">        if (!quiet)</a>
<a name="ln4731">            mpr(msg);</a>
<a name="ln4732">    }</a>
<a name="ln4733">    return success;</a>
<a name="ln4734">}</a>
<a name="ln4735"> </a>
<a name="ln4736">bool flight_allowed(bool quiet, string *fail_reason)</a>
<a name="ln4737">{</a>
<a name="ln4738">    string msg;</a>
<a name="ln4739">    bool success = true;</a>
<a name="ln4740"> </a>
<a name="ln4741">    if (get_form()-&gt;forbids_flight())</a>
<a name="ln4742">    {</a>
<a name="ln4743">        msg = you.form == transformation::tree ? &quot;Your roots keep you in place.&quot;</a>
<a name="ln4744">            : &quot;You can't fly in this form.&quot;;</a>
<a name="ln4745">        success = false;</a>
<a name="ln4746">    }</a>
<a name="ln4747">    else if (you.liquefied_ground() &amp;&amp; you.duration[DUR_LIQUEFYING] == 0)</a>
<a name="ln4748">    {</a>
<a name="ln4749">        msg = &quot;You can't fly while stuck in liquid ground.&quot;;</a>
<a name="ln4750">        success = false;</a>
<a name="ln4751">    }</a>
<a name="ln4752"> </a>
<a name="ln4753">    if (!success)</a>
<a name="ln4754">    {</a>
<a name="ln4755">        if (fail_reason)</a>
<a name="ln4756">            *fail_reason = msg;</a>
<a name="ln4757">        if (!quiet)</a>
<a name="ln4758">            mpr(msg);</a>
<a name="ln4759">    }</a>
<a name="ln4760">    return success;</a>
<a name="ln4761">}</a>
<a name="ln4762"> </a>
<a name="ln4763">void float_player()</a>
<a name="ln4764">{</a>
<a name="ln4765">    if (you.fishtail)</a>
<a name="ln4766">    {</a>
<a name="ln4767">        mpr(&quot;Your tail turns into legs as you fly out of the water.&quot;);</a>
<a name="ln4768">        merfolk_stop_swimming();</a>
<a name="ln4769">    }</a>
<a name="ln4770">    else if (you.tengu_flight())</a>
<a name="ln4771">        mpr(&quot;You swoop lightly up into the air.&quot;);</a>
<a name="ln4772">    else</a>
<a name="ln4773">        mpr(&quot;You fly up into the air.&quot;);</a>
<a name="ln4774"> </a>
<a name="ln4775">    if (you.species == SP_TENGU)</a>
<a name="ln4776">        you.redraw_evasion = true;</a>
<a name="ln4777">}</a>
<a name="ln4778"> </a>
<a name="ln4779">void fly_player(int pow, bool already_flying)</a>
<a name="ln4780">{</a>
<a name="ln4781">    if (!flight_allowed())</a>
<a name="ln4782">        return;</a>
<a name="ln4783"> </a>
<a name="ln4784">    bool standing = !you.airborne() &amp;&amp; !already_flying;</a>
<a name="ln4785">    if (!already_flying)</a>
<a name="ln4786">        mprf(MSGCH_DURATION, &quot;You feel %s buoyant.&quot;, standing ? &quot;very&quot; : &quot;more&quot;);</a>
<a name="ln4787"> </a>
<a name="ln4788">    you.increase_duration(DUR_FLIGHT, 25 + random2(pow), 100);</a>
<a name="ln4789"> </a>
<a name="ln4790">    if (standing)</a>
<a name="ln4791">        float_player();</a>
<a name="ln4792">}</a>
<a name="ln4793"> </a>
<a name="ln4794">void enable_emergency_flight()</a>
<a name="ln4795">{</a>
<a name="ln4796">    mprf(&quot;You can't survive in this terrain! You fly above the %s, but the &quot;</a>
<a name="ln4797">         &quot;process is draining.&quot;,</a>
<a name="ln4798">         (grd(you.pos()) == DNGN_LAVA)       ? &quot;lava&quot; :</a>
<a name="ln4799">         (grd(you.pos()) == DNGN_DEEP_WATER) ? &quot;water&quot;</a>
<a name="ln4800">                                             : &quot;buggy terrain&quot;);</a>
<a name="ln4801"> </a>
<a name="ln4802">    you.props[EMERGENCY_FLIGHT_KEY] = true;</a>
<a name="ln4803">}</a>
<a name="ln4804"> </a>
<a name="ln4805">/**</a>
<a name="ln4806"> * Handle the player's flight ending. Apply emergency flight if needed.</a>
<a name="ln4807"> *</a>
<a name="ln4808"> * @param quiet         Should we notify the player flight is ending?</a>
<a name="ln4809"> * @return              If flight was ended.</a>
<a name="ln4810"> */</a>
<a name="ln4811">bool land_player(bool quiet)</a>
<a name="ln4812">{</a>
<a name="ln4813">    // there was another source keeping you aloft</a>
<a name="ln4814">    if (you.airborne())</a>
<a name="ln4815">        return false;</a>
<a name="ln4816"> </a>
<a name="ln4817">    // Handle landing on (formerly) instakill terrain</a>
<a name="ln4818">    if (is_feat_dangerous(grd(you.pos())))</a>
<a name="ln4819">    {</a>
<a name="ln4820">        enable_emergency_flight();</a>
<a name="ln4821">        return false;</a>
<a name="ln4822">    }</a>
<a name="ln4823"> </a>
<a name="ln4824">    if (!quiet)</a>
<a name="ln4825">        mpr(&quot;You float gracefully downwards.&quot;);</a>
<a name="ln4826">    if (you.species == SP_TENGU)</a>
<a name="ln4827">        you.redraw_evasion = true;</a>
<a name="ln4828"> </a>
<a name="ln4829">    you.attribute[ATTR_FLIGHT_UNCANCELLABLE] = 0;</a>
<a name="ln4830">    // Re-enter the terrain.</a>
<a name="ln4831">    move_player_to_grid(you.pos(), false);</a>
<a name="ln4832">    return true;</a>
<a name="ln4833">}</a>
<a name="ln4834"> </a>
<a name="ln4835">static void _end_water_hold()</a>
<a name="ln4836">{</a>
<a name="ln4837">    you.duration[DUR_WATER_HOLD] = 0;</a>
<a name="ln4838">    you.props.erase(&quot;water_holder&quot;);</a>
<a name="ln4839">}</a>
<a name="ln4840"> </a>
<a name="ln4841">bool player::clear_far_engulf()</a>
<a name="ln4842">{</a>
<a name="ln4843">    if (!you.duration[DUR_WATER_HOLD])</a>
<a name="ln4844">        return false;</a>
<a name="ln4845"> </a>
<a name="ln4846">    monster * const mons = monster_by_mid(you.props[&quot;water_holder&quot;].get_int());</a>
<a name="ln4847">    if (!mons || !mons-&gt;alive() || !adjacent(mons-&gt;pos(), you.pos()))</a>
<a name="ln4848">    {</a>
<a name="ln4849">        if (you.res_water_drowning())</a>
<a name="ln4850">            mpr(&quot;The water engulfing you falls away.&quot;);</a>
<a name="ln4851">        else</a>
<a name="ln4852">            mpr(&quot;You gasp with relief as air once again reaches your lungs.&quot;);</a>
<a name="ln4853"> </a>
<a name="ln4854">        _end_water_hold();</a>
<a name="ln4855">        return true;</a>
<a name="ln4856">    }</a>
<a name="ln4857">    return false;</a>
<a name="ln4858">}</a>
<a name="ln4859"> </a>
<a name="ln4860">void handle_player_drowning(int delay)</a>
<a name="ln4861">{</a>
<a name="ln4862">    if (you.clear_far_engulf())</a>
<a name="ln4863">        return;</a>
<a name="ln4864">    if (you.res_water_drowning())</a>
<a name="ln4865">    {</a>
<a name="ln4866">        // Reset so damage doesn't ramp up while able to breathe</a>
<a name="ln4867">        you.duration[DUR_WATER_HOLD] = 10;</a>
<a name="ln4868">    }</a>
<a name="ln4869">    else</a>
<a name="ln4870">    {</a>
<a name="ln4871">        you.duration[DUR_WATER_HOLD] += delay;</a>
<a name="ln4872">        int dam =</a>
<a name="ln4873">            div_rand_round((28 + stepdown((float)you.duration[DUR_WATER_HOLD], 28.0))</a>
<a name="ln4874">                            * delay,</a>
<a name="ln4875">                            BASELINE_DELAY * 10);</a>
<a name="ln4876">        ouch(dam, KILLED_BY_WATER, you.props[&quot;water_holder&quot;].get_int());</a>
<a name="ln4877">        mprf(MSGCH_WARN, &quot;Your lungs strain for air!&quot;);</a>
<a name="ln4878">    }</a>
<a name="ln4879">}</a>
<a name="ln4880"> </a>
<a name="ln4881">int count_worn_ego(int which_ego)</a>
<a name="ln4882">{</a>
<a name="ln4883">    int result = 0;</a>
<a name="ln4884">    for (int slot = EQ_MIN_ARMOUR; slot &lt;= EQ_MAX_ARMOUR; ++slot)</a>
<a name="ln4885">    {</a>
<a name="ln4886">        if (you.equip[slot] != -1 &amp;&amp; !you.melded[slot]</a>
<a name="ln4887">            &amp;&amp; get_armour_ego_type(you.inv[you.equip[slot]]) == which_ego)</a>
<a name="ln4888">        {</a>
<a name="ln4889">            result++;</a>
<a name="ln4890">        }</a>
<a name="ln4891">    }</a>
<a name="ln4892"> </a>
<a name="ln4893">    return result;</a>
<a name="ln4894">}</a>
<a name="ln4895"> </a>
<a name="ln4896">player::player()</a>
<a name="ln4897">{</a>
<a name="ln4898">    // warning: this constructor is called for `you` in an indeterminate order</a>
<a name="ln4899">    // with respect to other globals, and so anything that depends on a global</a>
<a name="ln4900">    // you should not do here. This includes things like `branches`, as well as</a>
<a name="ln4901">    // any const static string prop name -- any object that needs to call a</a>
<a name="ln4902">    // constructor is risky, and may or may not have called it yet. E.g. strings</a>
<a name="ln4903">    // could be empty, branches could have every branch set as the dungeon, etc.</a>
<a name="ln4904">    // One candidate location is startup.cc:_initialize, which is nearly the</a>
<a name="ln4905">    // first things called in the launch game loop.</a>
<a name="ln4906"> </a>
<a name="ln4907">    chr_god_name.clear();</a>
<a name="ln4908">    chr_species_name.clear();</a>
<a name="ln4909">    chr_class_name.clear();</a>
<a name="ln4910">    // Permanent data:</a>
<a name="ln4911">    your_name.clear();</a>
<a name="ln4912">    species          = SP_UNKNOWN;</a>
<a name="ln4913">    char_class       = JOB_UNKNOWN;</a>
<a name="ln4914">    type             = MONS_PLAYER;</a>
<a name="ln4915">    mid              = MID_PLAYER;</a>
<a name="ln4916">    position.reset();</a>
<a name="ln4917"> </a>
<a name="ln4918">#ifdef WIZARD</a>
<a name="ln4919">    wizard = Options.wiz_mode == WIZ_YES;</a>
<a name="ln4920">    explore = Options.explore_mode == WIZ_YES;</a>
<a name="ln4921">#else</a>
<a name="ln4922">    wizard = false;</a>
<a name="ln4923">    explore = false;</a>
<a name="ln4924">#endif</a>
<a name="ln4925">    suppress_wizard = false;</a>
<a name="ln4926"> </a>
<a name="ln4927">    birth_time       = time(0);</a>
<a name="ln4928"> </a>
<a name="ln4929">    // Long-term state:</a>
<a name="ln4930">    elapsed_time     = 0;</a>
<a name="ln4931">    elapsed_time_at_last_input = 0;</a>
<a name="ln4932"> </a>
<a name="ln4933">    hp               = 0;</a>
<a name="ln4934">    hp_max           = 0;</a>
<a name="ln4935">    hp_max_adj_temp  = 0;</a>
<a name="ln4936">    hp_max_adj_perm  = 0;</a>
<a name="ln4937"> </a>
<a name="ln4938">    magic_points     = 0;</a>
<a name="ln4939">    max_magic_points = 0;</a>
<a name="ln4940">    mp_max_adj       = 0;</a>
<a name="ln4941"> </a>
<a name="ln4942">    stat_loss.init(0);</a>
<a name="ln4943">    base_stats.init(0);</a>
<a name="ln4944"> </a>
<a name="ln4945">    hunger          = HUNGER_DEFAULT;</a>
<a name="ln4946">    hunger_state    = HS_SATIATED;</a>
<a name="ln4947">    disease         = 0;</a>
<a name="ln4948">    max_level       = 1;</a>
<a name="ln4949">    hit_points_regeneration   = 0;</a>
<a name="ln4950">    magic_points_regeneration = 0;</a>
<a name="ln4951">    experience       = 0;</a>
<a name="ln4952">    total_experience = 0;</a>
<a name="ln4953">    experience_level = 1;</a>
<a name="ln4954">    gold             = 0;</a>
<a name="ln4955">    zigs_completed   = 0;</a>
<a name="ln4956">    zig_max          = 0;</a>
<a name="ln4957"> </a>
<a name="ln4958">    equip.init(-1);</a>
<a name="ln4959">    melded.reset();</a>
<a name="ln4960">    unrand_reacts.reset();</a>
<a name="ln4961">    activated.reset();</a>
<a name="ln4962">    last_unequip = -1;</a>
<a name="ln4963"> </a>
<a name="ln4964">    symbol          = MONS_PLAYER;</a>
<a name="ln4965">    form            = transformation::none;</a>
<a name="ln4966"> </a>
<a name="ln4967">    for (auto &amp;item : inv)</a>
<a name="ln4968">        item.clear();</a>
<a name="ln4969">    runes.reset();</a>
<a name="ln4970">    obtainable_runes = 15;</a>
<a name="ln4971"> </a>
<a name="ln4972">    spell_library.reset();</a>
<a name="ln4973">    spells.init(SPELL_NO_SPELL);</a>
<a name="ln4974">    old_vehumet_gifts.clear();</a>
<a name="ln4975">    spell_no        = 0;</a>
<a name="ln4976">    vehumet_gifts.clear();</a>
<a name="ln4977">    chapter  = CHAPTER_ORB_HUNTING;</a>
<a name="ln4978">    royal_jelly_dead = false;</a>
<a name="ln4979">    transform_uncancellable = false;</a>
<a name="ln4980">    fishtail = false;</a>
<a name="ln4981">    vampire_alive = true;</a>
<a name="ln4982"> </a>
<a name="ln4983">    pet_target      = MHITNOT;</a>
<a name="ln4984"> </a>
<a name="ln4985">    duration.init(0);</a>
<a name="ln4986">    apply_berserk_penalty = false;</a>
<a name="ln4987">    berserk_penalty = 0;</a>
<a name="ln4988">    attribute.init(0);</a>
<a name="ln4989">    // Default to flying the first time you wear boots of flying.</a>
<a name="ln4990">    attribute[ATTR_LAST_FLIGHT_STATUS] = 1;</a>
<a name="ln4991">    quiver.init(ENDOFPACK);</a>
<a name="ln4992"> </a>
<a name="ln4993">    last_timer_effect.init(0);</a>
<a name="ln4994">    next_timer_effect.init(20 * BASELINE_DELAY);</a>
<a name="ln4995"> </a>
<a name="ln4996">    pending_revival = false;</a>
<a name="ln4997">    lives = 0;</a>
<a name="ln4998">    deaths = 0;</a>
<a name="ln4999"> </a>
<a name="ln5000">    xray_vision = false;</a>
<a name="ln5001"> </a>
<a name="ln5002">    init_skills();</a>
<a name="ln5003"> </a>
<a name="ln5004">    skill_menu_do = SKM_NONE;</a>
<a name="ln5005">    skill_menu_view = SKM_NONE;</a>
<a name="ln5006"> </a>
<a name="ln5007">    transfer_from_skill = SK_NONE;</a>
<a name="ln5008">    transfer_to_skill = SK_NONE;</a>
<a name="ln5009">    transfer_skill_points = 0;</a>
<a name="ln5010">    transfer_total_skill_points = 0;</a>
<a name="ln5011"> </a>
<a name="ln5012">    skill_cost_level = 1;</a>
<a name="ln5013">    exp_available = 0;</a>
<a name="ln5014"> </a>
<a name="ln5015">    item_description.init(255);</a>
<a name="ln5016">    unique_items.init(UNIQ_NOT_EXISTS);</a>
<a name="ln5017">    unique_creatures.reset();</a>
<a name="ln5018">    force_autopickup.init(0);</a>
<a name="ln5019"> </a>
<a name="ln5020">    kills = KillMaster();</a>
<a name="ln5021"> </a>
<a name="ln5022">    where_are_you    = BRANCH_DUNGEON;</a>
<a name="ln5023">    depth            = 1;</a>
<a name="ln5024"> </a>
<a name="ln5025">    branch_stairs.init(0);</a>
<a name="ln5026"> </a>
<a name="ln5027">    religion         = GOD_NO_GOD;</a>
<a name="ln5028">    jiyva_second_name.clear();</a>
<a name="ln5029">    piety            = 0;</a>
<a name="ln5030">    piety_hysteresis = 0;</a>
<a name="ln5031">    gift_timeout     = 0;</a>
<a name="ln5032">    saved_good_god_piety = 0;</a>
<a name="ln5033">    previous_good_god = GOD_NO_GOD;</a>
<a name="ln5034">    penance.init(0);</a>
<a name="ln5035">    worshipped.init(0);</a>
<a name="ln5036">    num_current_gifts.init(0);</a>
<a name="ln5037">    num_total_gifts.init(0);</a>
<a name="ln5038">    one_time_ability_used.reset();</a>
<a name="ln5039">    piety_max.init(0);</a>
<a name="ln5040">    exp_docked.init(0);</a>
<a name="ln5041">    exp_docked_total.init(0);</a>
<a name="ln5042"> </a>
<a name="ln5043">    mutation.init(0);</a>
<a name="ln5044">    innate_mutation.init(0);</a>
<a name="ln5045">    temp_mutation.init(0);</a>
<a name="ln5046">    demonic_traits.clear();</a>
<a name="ln5047">    sacrifices.init(0);</a>
<a name="ln5048"> </a>
<a name="ln5049">    magic_contamination = 0;</a>
<a name="ln5050"> </a>
<a name="ln5051">    seen_weapon.init(0);</a>
<a name="ln5052">    seen_armour.init(0);</a>
<a name="ln5053">    seen_misc.reset();</a>
<a name="ln5054"> </a>
<a name="ln5055">    octopus_king_rings = 0x00;</a>
<a name="ln5056"> </a>
<a name="ln5057">    normal_vision    = LOS_DEFAULT_RANGE;</a>
<a name="ln5058">    current_vision   = LOS_DEFAULT_RANGE;</a>
<a name="ln5059"> </a>
<a name="ln5060">    real_time_ms     = chrono::milliseconds::zero();</a>
<a name="ln5061">    real_time_delta  = chrono::milliseconds::zero();</a>
<a name="ln5062">    num_turns        = 0;</a>
<a name="ln5063">    exploration      = 0;</a>
<a name="ln5064"> </a>
<a name="ln5065">    trapped          = false;</a>
<a name="ln5066"> </a>
<a name="ln5067">    last_view_update = 0;</a>
<a name="ln5068"> </a>
<a name="ln5069">    spell_letter_table.init(-1);</a>
<a name="ln5070">    ability_letter_table.init(ABIL_NON_ABILITY);</a>
<a name="ln5071"> </a>
<a name="ln5072">    uniq_map_tags.clear();</a>
<a name="ln5073">    uniq_map_names.clear();</a>
<a name="ln5074">    uniq_map_tags_abyss.clear();</a>
<a name="ln5075">    uniq_map_names_abyss.clear();</a>
<a name="ln5076">    vault_list.clear();</a>
<a name="ln5077"> </a>
<a name="ln5078">    global_info = PlaceInfo();</a>
<a name="ln5079">    global_info.assert_validity();</a>
<a name="ln5080"> </a>
<a name="ln5081">    m_quiver = player_quiver();</a>
<a name="ln5082"> </a>
<a name="ln5083">    props.clear();</a>
<a name="ln5084"> </a>
<a name="ln5085">    beholders.clear();</a>
<a name="ln5086">    fearmongers.clear();</a>
<a name="ln5087">    dactions.clear();</a>
<a name="ln5088">    level_stack.clear();</a>
<a name="ln5089">    type_ids.init(false);</a>
<a name="ln5090"> </a>
<a name="ln5091">    banished_by.clear();</a>
<a name="ln5092">    banished_power = 0;</a>
<a name="ln5093"> </a>
<a name="ln5094">    last_mid = 0;</a>
<a name="ln5095">    last_cast_spell = SPELL_NO_SPELL;</a>
<a name="ln5096"> </a>
<a name="ln5097">    // Non-saved UI state:</a>
<a name="ln5098">    prev_targ        = MHITNOT;</a>
<a name="ln5099">    prev_grd_targ.reset();</a>
<a name="ln5100">    divine_exegesis  = false;</a>
<a name="ln5101"> </a>
<a name="ln5102">    travel_x         = 0;</a>
<a name="ln5103">    travel_y         = 0;</a>
<a name="ln5104">    travel_z         = level_id();</a>
<a name="ln5105"> </a>
<a name="ln5106">    running.clear();</a>
<a name="ln5107">    travel_ally_pace = false;</a>
<a name="ln5108">    received_weapon_warning = false;</a>
<a name="ln5109">    received_noskill_warning = false;</a>
<a name="ln5110">    wizmode_teleported_into_rock = false;</a>
<a name="ln5111">    ash_init_bondage(this);</a>
<a name="ln5112">    digging = false;</a>
<a name="ln5113"> </a>
<a name="ln5114">    delay_queue.clear();</a>
<a name="ln5115"> </a>
<a name="ln5116">    last_keypress_time = chrono::system_clock::now();</a>
<a name="ln5117"> </a>
<a name="ln5118">    action_count.clear();</a>
<a name="ln5119"> </a>
<a name="ln5120">    branches_left.reset();</a>
<a name="ln5121"> </a>
<a name="ln5122">    // Volatile (same-turn) state:</a>
<a name="ln5123">    turn_is_over     = false;</a>
<a name="ln5124">    banished         = false;</a>
<a name="ln5125"> </a>
<a name="ln5126">    wield_change         = false;</a>
<a name="ln5127">    redraw_quiver        = false;</a>
<a name="ln5128">    redraw_status_lights = false;</a>
<a name="ln5129">    redraw_hit_points    = false;</a>
<a name="ln5130">    redraw_magic_points  = false;</a>
<a name="ln5131">    redraw_stats.init(false);</a>
<a name="ln5132">    redraw_experience    = false;</a>
<a name="ln5133">    redraw_armour_class  = false;</a>
<a name="ln5134">    redraw_evasion       = false;</a>
<a name="ln5135">    redraw_title         = false;</a>
<a name="ln5136"> </a>
<a name="ln5137">    flash_colour        = BLACK;</a>
<a name="ln5138">    flash_where         = nullptr;</a>
<a name="ln5139"> </a>
<a name="ln5140">    time_taken          = 0;</a>
<a name="ln5141">    shield_blocks       = 0;</a>
<a name="ln5142"> </a>
<a name="ln5143">    abyss_speed         = 0;</a>
<a name="ln5144">    game_seed           = 0;</a>
<a name="ln5145">    fully_seeded        = true;</a>
<a name="ln5146">    deterministic_levelgen = true;</a>
<a name="ln5147"> </a>
<a name="ln5148">    old_hunger          = hunger;</a>
<a name="ln5149"> </a>
<a name="ln5150">    los_noise_level     = 0;        ///&lt; temporary slot for loud noise levels</a>
<a name="ln5151">    los_noise_last_turn = 0;</a>
<a name="ln5152">    ///&lt; loudest noise heard on the last turn, for HUD display</a>
<a name="ln5153"> </a>
<a name="ln5154">    transit_stair       = DNGN_UNSEEN;</a>
<a name="ln5155">    entering_level      = false;</a>
<a name="ln5156"> </a>
<a name="ln5157">    reset_escaped_death();</a>
<a name="ln5158">    on_current_level    = true;</a>
<a name="ln5159">    seen_portals        = 0;</a>
<a name="ln5160">    frame_no            = 0;</a>
<a name="ln5161"> </a>
<a name="ln5162">    save                = nullptr;</a>
<a name="ln5163">    prev_save_version.clear();</a>
<a name="ln5164"> </a>
<a name="ln5165">    clear_constricted();</a>
<a name="ln5166">    constricting = 0;</a>
<a name="ln5167"> </a>
<a name="ln5168">    // Protected fields:</a>
<a name="ln5169">    clear_place_info();</a>
<a name="ln5170">}</a>
<a name="ln5171"> </a>
<a name="ln5172">void player::init_skills()</a>
<a name="ln5173">{</a>
<a name="ln5174">    auto_training = !(Options.default_manual_training);</a>
<a name="ln5175">    skills.init(0);</a>
<a name="ln5176">    train.init(TRAINING_DISABLED);</a>
<a name="ln5177">    train_alt.init(TRAINING_DISABLED);</a>
<a name="ln5178">    training.init(0);</a>
<a name="ln5179">    can_currently_train.reset();</a>
<a name="ln5180">    skill_points.init(0);</a>
<a name="ln5181">    ct_skill_points.init(0);</a>
<a name="ln5182">    skill_order.init(MAX_SKILL_ORDER);</a>
<a name="ln5183">    training_targets.init(0);</a>
<a name="ln5184">    exercises.clear();</a>
<a name="ln5185">    exercises_all.clear();</a>
<a name="ln5186">}</a>
<a name="ln5187"> </a>
<a name="ln5188">player_save_info&amp; player_save_info::operator=(const player&amp; rhs)</a>
<a name="ln5189">{</a>
<a name="ln5190">    name             = rhs.your_name;</a>
<a name="ln5191">    experience       = rhs.experience;</a>
<a name="ln5192">    experience_level = rhs.experience_level;</a>
<a name="ln5193">    wizard           = rhs.wizard || rhs.suppress_wizard;</a>
<a name="ln5194">    species          = rhs.species;</a>
<a name="ln5195">    species_name     = rhs.chr_species_name;</a>
<a name="ln5196">    class_name       = rhs.chr_class_name;</a>
<a name="ln5197">    religion         = rhs.religion;</a>
<a name="ln5198">    god_name         = rhs.chr_god_name;</a>
<a name="ln5199">    jiyva_second_name= rhs.jiyva_second_name;</a>
<a name="ln5200"> </a>
<a name="ln5201">    // [ds] Perhaps we should move game type to player?</a>
<a name="ln5202">    saved_game_type  = crawl_state.type;</a>
<a name="ln5203"> </a>
<a name="ln5204">    return *this;</a>
<a name="ln5205">}</a>
<a name="ln5206"> </a>
<a name="ln5207">bool player_save_info::operator&lt;(const player_save_info&amp; rhs) const</a>
<a name="ln5208">{</a>
<a name="ln5209">    return experience_level &gt; rhs.experience_level</a>
<a name="ln5210">           || (experience_level == rhs.experience_level &amp;&amp; name &lt; rhs.name);</a>
<a name="ln5211">}</a>
<a name="ln5212"> </a>
<a name="ln5213">string player_save_info::really_short_desc() const</a>
<a name="ln5214">{</a>
<a name="ln5215">    ostringstream desc;</a>
<a name="ln5216">    desc &lt;&lt; name &lt;&lt; &quot; the &quot; &lt;&lt; species_name &lt;&lt; ' ' &lt;&lt; class_name;</a>
<a name="ln5217"> </a>
<a name="ln5218">    return desc.str();</a>
<a name="ln5219">}</a>
<a name="ln5220"> </a>
<a name="ln5221">string player_save_info::short_desc() const</a>
<a name="ln5222">{</a>
<a name="ln5223">    ostringstream desc;</a>
<a name="ln5224"> </a>
<a name="ln5225">    const string qualifier = game_state::game_type_name_for(saved_game_type);</a>
<a name="ln5226">    if (!qualifier.empty())</a>
<a name="ln5227">        desc &lt;&lt; &quot;[&quot; &lt;&lt; qualifier &lt;&lt; &quot;] &quot;;</a>
<a name="ln5228"> </a>
<a name="ln5229">    desc &lt;&lt; name &lt;&lt; &quot;, a level &quot; &lt;&lt; experience_level &lt;&lt; ' '</a>
<a name="ln5230">         &lt;&lt; species_name &lt;&lt; ' ' &lt;&lt; class_name;</a>
<a name="ln5231"> </a>
<a name="ln5232">    if (religion == GOD_JIYVA)</a>
<a name="ln5233">        desc &lt;&lt; &quot; of &quot; &lt;&lt; god_name &lt;&lt; &quot; &quot; &lt;&lt; jiyva_second_name;</a>
<a name="ln5234">    else if (religion != GOD_NO_GOD)</a>
<a name="ln5235">        desc &lt;&lt; &quot; of &quot; &lt;&lt; god_name;</a>
<a name="ln5236"> </a>
<a name="ln5237">#ifdef WIZARD</a>
<a name="ln5238">    if (wizard)</a>
<a name="ln5239">        desc &lt;&lt; &quot; (WIZ)&quot;;</a>
<a name="ln5240">#endif</a>
<a name="ln5241"> </a>
<a name="ln5242">    return desc.str();</a>
<a name="ln5243">}</a>
<a name="ln5244"> </a>
<a name="ln5245">player::~player()</a>
<a name="ln5246">{</a>
<a name="ln5247">    if (CrawlIsCrashing &amp;&amp; save)</a>
<a name="ln5248">    {</a>
<a name="ln5249">        save-&gt;abort();</a>
<a name="ln5250">        delete save;</a>
<a name="ln5251">        save = nullptr;</a>
<a name="ln5252">    }</a>
<a name="ln5253">    ASSERT(!save); // the save file should be closed or deleted</a>
<a name="ln5254">}</a>
<a name="ln5255"> </a>
<a name="ln5256">bool player::airborne() const</a>
<a name="ln5257">{</a>
<a name="ln5258">    // Might otherwise be airborne, but currently stuck to the ground</a>
<a name="ln5259">    if (get_form()-&gt;forbids_flight())</a>
<a name="ln5260">        return false;</a>
<a name="ln5261"> </a>
<a name="ln5262">    if (duration[DUR_FLIGHT]</a>
<a name="ln5263">        || you.props[EMERGENCY_FLIGHT_KEY].get_bool()</a>
<a name="ln5264">        || attribute[ATTR_PERM_FLIGHT]</a>
<a name="ln5265">        || get_form()-&gt;enables_flight())</a>
<a name="ln5266">    {</a>
<a name="ln5267">        return true;</a>
<a name="ln5268">    }</a>
<a name="ln5269"> </a>
<a name="ln5270">    return false;</a>
<a name="ln5271">}</a>
<a name="ln5272"> </a>
<a name="ln5273">bool player::is_banished() const</a>
<a name="ln5274">{</a>
<a name="ln5275">    return banished;</a>
<a name="ln5276">}</a>
<a name="ln5277"> </a>
<a name="ln5278">bool player::is_sufficiently_rested() const</a>
<a name="ln5279">{</a>
<a name="ln5280">    // Only return false if resting will actually help.</a>
<a name="ln5281">    return (!player_regenerates_hp() || hp &gt;= _rest_trigger_level(hp_max))</a>
<a name="ln5282">            &amp;&amp; (magic_points &gt;= _rest_trigger_level(max_magic_points)</a>
<a name="ln5283">                || !player_regenerates_mp());</a>
<a name="ln5284">}</a>
<a name="ln5285"> </a>
<a name="ln5286">bool player::in_water() const</a>
<a name="ln5287">{</a>
<a name="ln5288">    return ground_level() &amp;&amp; !you.can_water_walk() &amp;&amp; feat_is_water(grd(pos()));</a>
<a name="ln5289">}</a>
<a name="ln5290"> </a>
<a name="ln5291">bool player::in_liquid() const</a>
<a name="ln5292">{</a>
<a name="ln5293">    return in_water() || liquefied_ground();</a>
<a name="ln5294">}</a>
<a name="ln5295"> </a>
<a name="ln5296">bool player::can_swim(bool permanently) const</a>
<a name="ln5297">{</a>
<a name="ln5298">    // Transforming could be fatal if it would cause unequipment of</a>
<a name="ln5299">    // stat-boosting boots or heavy armour.</a>
<a name="ln5300">    return (species_can_swim(species)</a>
<a name="ln5301">            || body_size(PSIZE_BODY) &gt;= SIZE_GIANT</a>
<a name="ln5302">            || !permanently)</a>
<a name="ln5303">                &amp;&amp; form_can_swim();</a>
<a name="ln5304">}</a>
<a name="ln5305"> </a>
<a name="ln5306">/// Can the player do a passing imitation of a notorious Palestinian?</a>
<a name="ln5307">bool player::can_water_walk() const</a>
<a name="ln5308">{</a>
<a name="ln5309">    return have_passive(passive_t::water_walk)</a>
<a name="ln5310">           || you.props.exists(TEMP_WATERWALK_KEY);</a>
<a name="ln5311">}</a>
<a name="ln5312"> </a>
<a name="ln5313">int player::visible_igrd(const coord_def &amp;where) const</a>
<a name="ln5314">{</a>
<a name="ln5315">    if (grd(where) == DNGN_LAVA</a>
<a name="ln5316">        || (grd(where) == DNGN_DEEP_WATER</a>
<a name="ln5317">            &amp;&amp; !species_likes_water(species)))</a>
<a name="ln5318">    {</a>
<a name="ln5319">        return NON_ITEM;</a>
<a name="ln5320">    }</a>
<a name="ln5321"> </a>
<a name="ln5322">    return igrd(where);</a>
<a name="ln5323">}</a>
<a name="ln5324"> </a>
<a name="ln5325">bool player::has_spell(spell_type spell) const</a>
<a name="ln5326">{</a>
<a name="ln5327">    return find(begin(spells), end(spells), spell) != end(spells);</a>
<a name="ln5328">}</a>
<a name="ln5329"> </a>
<a name="ln5330">bool player::cannot_speak() const</a>
<a name="ln5331">{</a>
<a name="ln5332">    if (silenced(pos()))</a>
<a name="ln5333">        return true;</a>
<a name="ln5334"> </a>
<a name="ln5335">    if (cannot_move()) // we allow talking during sleep ;)</a>
<a name="ln5336">        return true;</a>
<a name="ln5337"> </a>
<a name="ln5338">    // No transform that prevents the player from speaking yet.</a>
<a name="ln5339">    // ... yet setting this would prevent saccing junk and similar activities</a>
<a name="ln5340">    // for no good reason.</a>
<a name="ln5341">    return false;</a>
<a name="ln5342">}</a>
<a name="ln5343"> </a>
<a name="ln5344">static const string shout_verbs[] = {&quot;shout&quot;, &quot;yell&quot;, &quot;scream&quot;};</a>
<a name="ln5345">static const string felid_shout_verbs[] = {&quot;meow&quot;, &quot;yowl&quot;, &quot;caterwaul&quot;};</a>
<a name="ln5346">static const string frog_shout_verbs[] = {&quot;ribbit&quot;, &quot;croak&quot;, &quot;bellow&quot;};</a>
<a name="ln5347">static const string dog_shout_verbs[] = {&quot;bark&quot;, &quot;howl&quot;, &quot;screech&quot;};</a>
<a name="ln5348"> </a>
<a name="ln5349">/**</a>
<a name="ln5350"> * What verb should be used to describe the player's shouting?</a>
<a name="ln5351"> *</a>
<a name="ln5352"> * @param directed      Whether you're shouting at anyone in particular.</a>
<a name="ln5353"> * @return              A shouty kind of verb.</a>
<a name="ln5354"> */</a>
<a name="ln5355">string player::shout_verb(bool directed) const</a>
<a name="ln5356">{</a>
<a name="ln5357">    if (!get_form()-&gt;shout_verb.empty())</a>
<a name="ln5358">        return get_form()-&gt;shout_verb;</a>
<a name="ln5359"> </a>
<a name="ln5360">    const int screaminess = max(get_mutation_level(MUT_SCREAM) - 1, 0);</a>
<a name="ln5361"> </a>
<a name="ln5362">    if (species == SP_GNOLL)</a>
<a name="ln5363">        return dog_shout_verbs[screaminess];</a>
<a name="ln5364">    if (species == SP_BARACHI)</a>
<a name="ln5365">        return frog_shout_verbs[screaminess];</a>
<a name="ln5366">    if (species != SP_FELID)</a>
<a name="ln5367">        return shout_verbs[screaminess];</a>
<a name="ln5368">    if (directed &amp;&amp; screaminess == 0)</a>
<a name="ln5369">        return &quot;hiss&quot;; // hiss at, not meow at</a>
<a name="ln5370">    return felid_shout_verbs[screaminess];</a>
<a name="ln5371">}</a>
<a name="ln5372"> </a>
<a name="ln5373">/**</a>
<a name="ln5374"> * How loud are the player's shouts?</a>
<a name="ln5375"> *</a>
<a name="ln5376"> * @return The noise produced by a single player shout.</a>
<a name="ln5377"> */</a>
<a name="ln5378">int player::shout_volume() const</a>
<a name="ln5379">{</a>
<a name="ln5380">    const int base_noise = 12 + get_form()-&gt;shout_volume_modifier;</a>
<a name="ln5381"> </a>
<a name="ln5382">    if (get_mutation_level(MUT_SCREAM))</a>
<a name="ln5383">        return base_noise + 2 * (get_mutation_level(MUT_SCREAM) - 1);</a>
<a name="ln5384"> </a>
<a name="ln5385">    return base_noise;</a>
<a name="ln5386">}</a>
<a name="ln5387"> </a>
<a name="ln5388">void player::god_conduct(conduct_type thing_done, int level)</a>
<a name="ln5389">{</a>
<a name="ln5390">    ::did_god_conduct(thing_done, level);</a>
<a name="ln5391">}</a>
<a name="ln5392"> </a>
<a name="ln5393">void player::banish(actor* /*agent*/, const string &amp;who, const int power,</a>
<a name="ln5394">                    bool force)</a>
<a name="ln5395">{</a>
<a name="ln5396">    ASSERT(!crawl_state.game_is_arena());</a>
<a name="ln5397">    if (brdepth[BRANCH_ABYSS] == -1)</a>
<a name="ln5398">        return;</a>
<a name="ln5399"> </a>
<a name="ln5400">    if (elapsed_time &lt;= attribute[ATTR_BANISHMENT_IMMUNITY])</a>
<a name="ln5401">    {</a>
<a name="ln5402">        mpr(&quot;You resist the pull of the Abyss.&quot;);</a>
<a name="ln5403">        return;</a>
<a name="ln5404">    }</a>
<a name="ln5405"> </a>
<a name="ln5406">    if (!force &amp;&amp; player_in_branch(BRANCH_ABYSS)</a>
<a name="ln5407">        &amp;&amp; x_chance_in_y(you.depth, brdepth[BRANCH_ABYSS]))</a>
<a name="ln5408">    {</a>
<a name="ln5409">        mpr(&quot;You wobble for a moment.&quot;);</a>
<a name="ln5410">        return;</a>
<a name="ln5411">    }</a>
<a name="ln5412"> </a>
<a name="ln5413">    banished    = true;</a>
<a name="ln5414">    banished_by = who;</a>
<a name="ln5415">    banished_power = power;</a>
<a name="ln5416">}</a>
<a name="ln5417"> </a>
<a name="ln5418">// Currently a no-op, previously was used for vampire hunger modifications.</a>
<a name="ln5419">// Perhaps in the fullness of time this can be removed.</a>
<a name="ln5420">int calc_hunger(int food_cost)</a>
<a name="ln5421">{</a>
<a name="ln5422">    return food_cost;</a>
<a name="ln5423">}</a>
<a name="ln5424"> </a>
<a name="ln5425">/*</a>
<a name="ln5426"> * Approximate the loudest noise the player heard in the last</a>
<a name="ln5427"> * turn, possibly rescaling. This gets updated every</a>
<a name="ln5428"> * `world_reacts`. If `adjusted` is set to true, this rescales</a>
<a name="ln5429"> * noise on a 0-1000 scale according to some breakpoints that</a>
<a name="ln5430"> * I have hand-calibrated. Otherwise, it returns the raw noise</a>
<a name="ln5431"> * value (approximately from 0 to 40). The breakpoints aim to</a>
<a name="ln5432"> * approximate 1x los radius, 2x los radius, and 3x los radius</a>
<a name="ln5433"> * relative to an open area.</a>
<a name="ln5434"> *</a>
<a name="ln5435"> * @param adjusted      Whether to rescale the noise level.</a>
<a name="ln5436"> *</a>
<a name="ln5437"> * @return The (scaled or unscaled) noise level heard by the player.</a>
<a name="ln5438"> */</a>
<a name="ln5439">int player::get_noise_perception(bool adjusted) const</a>
<a name="ln5440">{</a>
<a name="ln5441">    // los_noise_last_turn is already normalized for the branch's ambient</a>
<a name="ln5442">    // noise.</a>
<a name="ln5443">    const int level = los_noise_last_turn;</a>
<a name="ln5444">    static const int BAR_MAX = 1000; // TODO: export to output.cc &amp; webtiles</a>
<a name="ln5445">    if (!adjusted)</a>
<a name="ln5446">         return (level + 500) / BAR_MAX;</a>
<a name="ln5447"> </a>
<a name="ln5448">    static const vector&lt;int&gt; NOISE_BREAKPOINTS = { 0, 6000, 13000, 29000 };</a>
<a name="ln5449">    const int BAR_FRAC = BAR_MAX / (NOISE_BREAKPOINTS.size() - 1);</a>
<a name="ln5450">    for (size_t i = 1; i &lt; NOISE_BREAKPOINTS.size(); ++i)</a>
<a name="ln5451">    {</a>
<a name="ln5452">        const int breakpoint = NOISE_BREAKPOINTS[i];</a>
<a name="ln5453">        if (level &gt; breakpoint)</a>
<a name="ln5454">            continue;</a>
<a name="ln5455">        // what fragment of this breakpoint does the noise fill up?</a>
<a name="ln5456">        const int prev_break = NOISE_BREAKPOINTS[i-1];</a>
<a name="ln5457">        const int break_width = breakpoint - prev_break;</a>
<a name="ln5458">        const int in_segment = (level - prev_break) * BAR_FRAC / break_width;</a>
<a name="ln5459">        // that fragment + previous breakpoints passed is our total noise.</a>
<a name="ln5460">        return in_segment + (i - 1) * BAR_FRAC;</a>
<a name="ln5461">        // example: 10k noise. that's 4k past the 6k breakpoint</a>
<a name="ln5462">        // ((10k-6k) * 333 / (13k - 6k)) + 333, or a bit more than half the bar</a>
<a name="ln5463">    }</a>
<a name="ln5464"> </a>
<a name="ln5465">    return BAR_MAX;</a>
<a name="ln5466">}</a>
<a name="ln5467"> </a>
<a name="ln5468">bool player::paralysed() const</a>
<a name="ln5469">{</a>
<a name="ln5470">    return duration[DUR_PARALYSIS];</a>
<a name="ln5471">}</a>
<a name="ln5472"> </a>
<a name="ln5473">bool player::cannot_move() const</a>
<a name="ln5474">{</a>
<a name="ln5475">    return paralysed() || petrified();</a>
<a name="ln5476">}</a>
<a name="ln5477"> </a>
<a name="ln5478">bool player::confused() const</a>
<a name="ln5479">{</a>
<a name="ln5480">    return duration[DUR_CONF];</a>
<a name="ln5481">}</a>
<a name="ln5482"> </a>
<a name="ln5483">bool player::caught() const</a>
<a name="ln5484">{</a>
<a name="ln5485">    return attribute[ATTR_HELD];</a>
<a name="ln5486">}</a>
<a name="ln5487"> </a>
<a name="ln5488">bool player::petrifying() const</a>
<a name="ln5489">{</a>
<a name="ln5490">    return duration[DUR_PETRIFYING];</a>
<a name="ln5491">}</a>
<a name="ln5492"> </a>
<a name="ln5493">bool player::petrified() const</a>
<a name="ln5494">{</a>
<a name="ln5495">    return duration[DUR_PETRIFIED];</a>
<a name="ln5496">}</a>
<a name="ln5497"> </a>
<a name="ln5498">bool player::liquefied_ground() const</a>
<a name="ln5499">{</a>
<a name="ln5500">    return liquefied(pos())</a>
<a name="ln5501">           &amp;&amp; ground_level() &amp;&amp; !is_insubstantial();</a>
<a name="ln5502">}</a>
<a name="ln5503"> </a>
<a name="ln5504">int player::shield_block_penalty() const</a>
<a name="ln5505">{</a>
<a name="ln5506">    return 5 * shield_blocks * shield_blocks;</a>
<a name="ln5507">}</a>
<a name="ln5508"> </a>
<a name="ln5509">/**</a>
<a name="ln5510"> * Returns whether the player currently has any kind of shield.</a>
<a name="ln5511"> *</a>
<a name="ln5512"> * XXX: why does this function exist?</a>
<a name="ln5513"> */</a>
<a name="ln5514">bool player::shielded() const</a>
<a name="ln5515">{</a>
<a name="ln5516">    return shield()</a>
<a name="ln5517">           || duration[DUR_DIVINE_SHIELD]</a>
<a name="ln5518">           || get_mutation_level(MUT_LARGE_BONE_PLATES) &gt; 0</a>
<a name="ln5519">           || qazlal_sh_boost() &gt; 0</a>
<a name="ln5520">           || you.wearing(EQ_AMULET_PLUS, AMU_REFLECTION) &gt; 0</a>
<a name="ln5521">           || you.scan_artefacts(ARTP_SHIELDING);</a>
<a name="ln5522">}</a>
<a name="ln5523"> </a>
<a name="ln5524">int player::shield_bonus() const</a>
<a name="ln5525">{</a>
<a name="ln5526">    const int shield_class = player_shield_class();</a>
<a name="ln5527">    if (shield_class &lt;= 0)</a>
<a name="ln5528">        return -100;</a>
<a name="ln5529"> </a>
<a name="ln5530">    return random2avg(shield_class * 2, 2) / 3 - 1;</a>
<a name="ln5531">}</a>
<a name="ln5532"> </a>
<a name="ln5533">int player::shield_bypass_ability(int tohit) const</a>
<a name="ln5534">{</a>
<a name="ln5535">    return 15 + tohit / 2;</a>
<a name="ln5536">}</a>
<a name="ln5537"> </a>
<a name="ln5538">void player::shield_block_succeeded(actor *foe)</a>
<a name="ln5539">{</a>
<a name="ln5540">    actor::shield_block_succeeded(foe);</a>
<a name="ln5541"> </a>
<a name="ln5542">    shield_blocks++;</a>
<a name="ln5543">    practise_shield_block();</a>
<a name="ln5544">    if (shield())</a>
<a name="ln5545">        count_action(CACT_BLOCK, shield()-&gt;sub_type);</a>
<a name="ln5546">    else</a>
<a name="ln5547">        count_action(CACT_BLOCK, -1, BLOCK_OTHER); // non-shield block</a>
<a name="ln5548">}</a>
<a name="ln5549"> </a>
<a name="ln5550">bool player::missile_repulsion() const</a>
<a name="ln5551">{</a>
<a name="ln5552">    return get_mutation_level(MUT_DISTORTION_FIELD) == 3</a>
<a name="ln5553">        || you.wearing_ego(EQ_ALL_ARMOUR, SPARM_REPULSION)</a>
<a name="ln5554">        || scan_artefacts(ARTP_RMSL, true)</a>
<a name="ln5555">        || have_passive(passive_t::upgraded_storm_shield);</a>
<a name="ln5556">}</a>
<a name="ln5557"> </a>
<a name="ln5558">/**</a>
<a name="ln5559"> * What's the base value of the penalties the player receives from their</a>
<a name="ln5560"> * body armour?</a>
<a name="ln5561"> *</a>
<a name="ln5562"> * Used as the base for adjusted armour penalty calculations, as well as for</a>
<a name="ln5563"> * stealth penalty calculations.</a>
<a name="ln5564"> *</a>
<a name="ln5565"> * @return  The player's body armour's PARM_EVASION, if any, taking into account</a>
<a name="ln5566"> *          the sturdy frame mutation that reduces encumbrance.</a>
<a name="ln5567"> */</a>
<a name="ln5568">int player::unadjusted_body_armour_penalty() const</a>
<a name="ln5569">{</a>
<a name="ln5570">    const item_def *body_armour = slot_item(EQ_BODY_ARMOUR, false);</a>
<a name="ln5571">    if (!body_armour)</a>
<a name="ln5572">        return 0;</a>
<a name="ln5573"> </a>
<a name="ln5574">    // PARM_EVASION is always less than or equal to 0</a>
<a name="ln5575">    return max(0, -property(*body_armour, PARM_EVASION) / 10</a>
<a name="ln5576">                  - get_mutation_level(MUT_STURDY_FRAME) * 2);</a>
<a name="ln5577">}</a>
<a name="ln5578"> </a>
<a name="ln5579">/**</a>
<a name="ln5580"> * The encumbrance penalty to the player for their worn body armour.</a>
<a name="ln5581"> *</a>
<a name="ln5582"> * @param scale     A scale to multiply the result by, to avoid precision loss.</a>
<a name="ln5583"> * @return          A penalty to EV based quadratically on body armour</a>
<a name="ln5584"> *                  encumbrance.</a>
<a name="ln5585"> */</a>
<a name="ln5586">int player::adjusted_body_armour_penalty(int scale) const</a>
<a name="ln5587">{</a>
<a name="ln5588">    const int base_ev_penalty = unadjusted_body_armour_penalty();</a>
<a name="ln5589"> </a>
<a name="ln5590">    // New formula for effect of str on aevp: (2/5) * evp^2 / (str+3)</a>
<a name="ln5591">    return 2 * base_ev_penalty * base_ev_penalty * (450 - skill(SK_ARMOUR, 10))</a>
<a name="ln5592">           * scale / (5 * (strength() + 3)) / 450;</a>
<a name="ln5593">}</a>
<a name="ln5594"> </a>
<a name="ln5595">/**</a>
<a name="ln5596"> * The encumbrance penalty to the player for their worn shield.</a>
<a name="ln5597"> *</a>
<a name="ln5598"> * @param scale     A scale to multiply the result by, to avoid precision loss.</a>
<a name="ln5599"> * @return          A penalty to EV based on shield weight.</a>
<a name="ln5600"> */</a>
<a name="ln5601">int player::adjusted_shield_penalty(int scale) const</a>
<a name="ln5602">{</a>
<a name="ln5603">    const item_def *shield_l = slot_item(EQ_SHIELD, false);</a>
<a name="ln5604">    if (!shield_l)</a>
<a name="ln5605">        return 0;</a>
<a name="ln5606"> </a>
<a name="ln5607">    const int base_shield_penalty = -property(*shield_l, PARM_EVASION);</a>
<a name="ln5608">    return max(0, ((base_shield_penalty * scale) - skill(SK_SHIELDS, scale)</a>
<a name="ln5609">                  / player_shield_racial_factor() * 10) / 10);</a>
<a name="ln5610">}</a>
<a name="ln5611"> </a>
<a name="ln5612">float player::get_shield_skill_to_offset_penalty(const item_def &amp;item)</a>
<a name="ln5613">{</a>
<a name="ln5614">    int evp = property(item, PARM_EVASION);</a>
<a name="ln5615">    return -1 * evp * player_shield_racial_factor() / 10.0;</a>
<a name="ln5616">}</a>
<a name="ln5617"> </a>
<a name="ln5618">int player::armour_tohit_penalty(bool random_factor, int scale) const</a>
<a name="ln5619">{</a>
<a name="ln5620">    return maybe_roll_dice(1, adjusted_body_armour_penalty(scale), random_factor);</a>
<a name="ln5621">}</a>
<a name="ln5622"> </a>
<a name="ln5623">int player::shield_tohit_penalty(bool random_factor, int scale) const</a>
<a name="ln5624">{</a>
<a name="ln5625">    return maybe_roll_dice(1, adjusted_shield_penalty(scale), random_factor);</a>
<a name="ln5626">}</a>
<a name="ln5627"> </a>
<a name="ln5628">/**</a>
<a name="ln5629"> * Get the player's skill level for sk.</a>
<a name="ln5630"> *</a>
<a name="ln5631"> * @param scale a scale factor to multiply by.</a>
<a name="ln5632"> * @param real whether to return the real value, or modified value.</a>
<a name="ln5633"> * @param drained whether to include modification by draining.</a>
<a name="ln5634"> * @param temp whether to include modification by other temporary factors (e.g. heroism)</a>
<a name="ln5635"> */</a>
<a name="ln5636">int player::skill(skill_type sk, int scale, bool real, bool drained, bool temp) const</a>
<a name="ln5637">{</a>
<a name="ln5638">    // If you add another enhancement/reduction, be sure to change</a>
<a name="ln5639">    // SkillMenuSwitch::get_help() to reflect that</a>
<a name="ln5640"> </a>
<a name="ln5641">    // wizard racechange, or upgraded old save</a>
<a name="ln5642">    if (is_useless_skill(sk))</a>
<a name="ln5643">        return 0;</a>
<a name="ln5644"> </a>
<a name="ln5645">    // skills[sk] might not be updated yet if this is in the middle of</a>
<a name="ln5646">    // skill training, so make sure to use the correct value.</a>
<a name="ln5647">    int actual_skill = skills[sk];</a>
<a name="ln5648">    unsigned int effective_points = skill_points[sk];</a>
<a name="ln5649">    if (!real)</a>
<a name="ln5650">        effective_points += get_crosstrain_points(sk);</a>
<a name="ln5651">    effective_points = min(effective_points, skill_exp_needed(MAX_SKILL_LEVEL, sk));</a>
<a name="ln5652">    actual_skill = calc_skill_level_change(sk, actual_skill, effective_points);</a>
<a name="ln5653"> </a>
<a name="ln5654">    int level = actual_skill * scale</a>
<a name="ln5655">      + get_skill_progress(sk, actual_skill, effective_points, scale);</a>
<a name="ln5656">    if (real)</a>
<a name="ln5657">        return level;</a>
<a name="ln5658">    if (drained &amp;&amp; you.attribute[ATTR_XP_DRAIN])</a>
<a name="ln5659">    {</a>
<a name="ln5660">        // skill = base * (3000 - drain) / 3000  - drain / 100</a>
<a name="ln5661">        //         base - ((drain * base / 3000) + drain / 100)</a>
<a name="ln5662">        int drain_scale = max(0, (30 * 100 - you.attribute[ATTR_XP_DRAIN]) * scale);</a>
<a name="ln5663">        level = skill(sk, drain_scale, real, false);</a>
<a name="ln5664">        return max(0, (level - 30 * scale * you.attribute[ATTR_XP_DRAIN]) / (30 * 100));</a>
<a name="ln5665">    }</a>
<a name="ln5666"> </a>
<a name="ln5667">    if (penance[GOD_ASHENZARI])</a>
<a name="ln5668">    {</a>
<a name="ln5669">        if (temp)</a>
<a name="ln5670">            level = max(level - 4 * scale, level / 2);</a>
<a name="ln5671">    }</a>
<a name="ln5672">    else if (ash_has_skill_boost(sk))</a>
<a name="ln5673">            level = ash_skill_boost(sk, scale);</a>
<a name="ln5674"> </a>
<a name="ln5675">    if (temp &amp;&amp; duration[DUR_HEROISM] &amp;&amp; sk &lt;= SK_LAST_MUNDANE)</a>
<a name="ln5676">        level = min(level + 5 * scale, MAX_SKILL_LEVEL * scale);</a>
<a name="ln5677">    return level;</a>
<a name="ln5678">}</a>
<a name="ln5679"> </a>
<a name="ln5680">int player_icemail_armour_class()</a>
<a name="ln5681">{</a>
<a name="ln5682">    if (!you.has_mutation(MUT_ICEMAIL))</a>
<a name="ln5683">        return 0;</a>
<a name="ln5684"> </a>
<a name="ln5685">    return you.duration[DUR_ICEMAIL_DEPLETED] ? 0 : ICEMAIL_MAX;</a>
<a name="ln5686">}</a>
<a name="ln5687"> </a>
<a name="ln5688">/**</a>
<a name="ln5689"> * How many points of AC does the player get from their sanguine armour, if</a>
<a name="ln5690"> * they have any?</a>
<a name="ln5691"> *</a>
<a name="ln5692"> * @return      The AC bonus * 100. (For scaling.)</a>
<a name="ln5693"> */</a>
<a name="ln5694">int sanguine_armour_bonus()</a>
<a name="ln5695">{</a>
<a name="ln5696">    if (!you.duration[DUR_SANGUINE_ARMOUR])</a>
<a name="ln5697">        return 0;</a>
<a name="ln5698"> </a>
<a name="ln5699">    const int mut_lev = you.get_mutation_level(MUT_SANGUINE_ARMOUR);</a>
<a name="ln5700">    // like iridescent, but somewhat moreso (when active)</a>
<a name="ln5701">    return 300 + mut_lev * 300;</a>
<a name="ln5702">}</a>
<a name="ln5703"> </a>
<a name="ln5704">/**</a>
<a name="ln5705"> * How much AC does the player get from an unenchanted version of the given</a>
<a name="ln5706"> * armour?</a>
<a name="ln5707"> *</a>
<a name="ln5708"> * @param armour    The armour in question.</a>
<a name="ln5709"> * @param scale     A value to multiply the result by. (Used to avoid integer</a>
<a name="ln5710"> *                  rounding.)</a>
<a name="ln5711"> * @return          The AC from that armour, including armour skill, mutations</a>
<a name="ln5712"> *                  &amp; divine blessings, but not enchantments or egos.</a>
<a name="ln5713"> */</a>
<a name="ln5714">int player::base_ac_from(const item_def &amp;armour, int scale) const</a>
<a name="ln5715">{</a>
<a name="ln5716">    const int base = property(armour, PARM_AC) * scale;</a>
<a name="ln5717"> </a>
<a name="ln5718">    // [ds] effectively: ac_value * (22 + Arm) / 22, where Arm = Armour Skill.</a>
<a name="ln5719">    const int AC = base * (440 + skill(SK_ARMOUR, 20)) / 440;</a>
<a name="ln5720"> </a>
<a name="ln5721">    // The deformed don't fit into body armour very well.</a>
<a name="ln5722">    // (This includes nagas and centaurs.)</a>
<a name="ln5723">    if (get_armour_slot(armour) == EQ_BODY_ARMOUR</a>
<a name="ln5724">            &amp;&amp; (get_mutation_level(MUT_DEFORMED)</a>
<a name="ln5725">                || get_mutation_level(MUT_PSEUDOPODS)))</a>
<a name="ln5726">    {</a>
<a name="ln5727">        return AC - base / 2;</a>
<a name="ln5728">    }</a>
<a name="ln5729"> </a>
<a name="ln5730">    return AC;</a>
<a name="ln5731">}</a>
<a name="ln5732"> </a>
<a name="ln5733">/**</a>
<a name="ln5734"> * What bonus AC are you getting from your species?</a>
<a name="ln5735"> *</a>
<a name="ln5736"> * Does not account for any real mutations, such as scales or thick skin, that</a>
<a name="ln5737"> * you may have as a result of your species.</a>
<a name="ln5738"> * @param temp Whether to account for transformations.</a>
<a name="ln5739"> * @returns how much AC you are getting from your species &quot;fake mutations&quot; * 100</a>
<a name="ln5740"> */</a>
<a name="ln5741">int player::racial_ac(bool temp) const</a>
<a name="ln5742">{</a>
<a name="ln5743">    // drac scales suppressed in all serious forms, except dragon</a>
<a name="ln5744">    if (species_is_draconian(species)</a>
<a name="ln5745">        &amp;&amp; (!player_is_shapechanged() || form == transformation::dragon</a>
<a name="ln5746">            || !temp))</a>
<a name="ln5747">    {</a>
<a name="ln5748">        int AC = 400 + 100 * (experience_level / 3);  // max 13</a>
<a name="ln5749">        if (species == SP_GREY_DRACONIAN) // no breath</a>
<a name="ln5750">            AC += 500;</a>
<a name="ln5751">        return AC;</a>
<a name="ln5752">    }</a>
<a name="ln5753"> </a>
<a name="ln5754">    if (!(player_is_shapechanged() &amp;&amp; temp))</a>
<a name="ln5755">    {</a>
<a name="ln5756">        if (species == SP_NAGA)</a>
<a name="ln5757">            return 100 * experience_level / 3;              // max 9</a>
<a name="ln5758">        else if (species == SP_GARGOYLE)</a>
<a name="ln5759">        {</a>
<a name="ln5760">            return 200 + 100 * experience_level * 2 / 5     // max 20</a>
<a name="ln5761">                       + 100 * max(0, experience_level - 7) * 2 / 5;</a>
<a name="ln5762">        }</a>
<a name="ln5763">    }</a>
<a name="ln5764"> </a>
<a name="ln5765">    return 0;</a>
<a name="ln5766">}</a>
<a name="ln5767"> </a>
<a name="ln5768">// Each instance of this class stores a mutation which might change a</a>
<a name="ln5769">// player's AC and how much their AC should change if the player has</a>
<a name="ln5770">// said mutation.</a>
<a name="ln5771">class mutation_ac_changes{</a>
<a name="ln5772">    public:</a>
<a name="ln5773">        /**</a>
<a name="ln5774">         * The AC a player gains from a given mutation. If the player</a>
<a name="ln5775">         * lacks said mutation, return 0.</a>
<a name="ln5776">         *</a>
<a name="ln5777">         * @return How much AC to give the player for the handled</a>
<a name="ln5778">         *         mutation.</a>
<a name="ln5779">         */</a>
<a name="ln5780">        int get_ac_change_for_mutation(){</a>
<a name="ln5781">            int ac_change = 0;</a>
<a name="ln5782"> </a>
<a name="ln5783">            int mutation_level = you.get_mutation_level(mut, mutation_activation_threshold);</a>
<a name="ln5784"> </a>
<a name="ln5785">            switch (mutation_level){</a>
<a name="ln5786">                case 0:</a>
<a name="ln5787">                    ac_change = 0;</a>
<a name="ln5788">                    break;</a>
<a name="ln5789">                case 1:</a>
<a name="ln5790">                case 2:</a>
<a name="ln5791">                case 3:</a>
<a name="ln5792">                    ac_change = ac_changes[mutation_level - 1];</a>
<a name="ln5793">                    break;</a>
<a name="ln5794">            }</a>
<a name="ln5795"> </a>
<a name="ln5796">            // The output for this function is scaled differently than the UI.</a>
<a name="ln5797">            return ac_change * 100;</a>
<a name="ln5798">        }</a>
<a name="ln5799"> </a>
<a name="ln5800">        mutation_ac_changes(mutation_type mut_aug,</a>
<a name="ln5801">                            mutation_activity_type mutation_activation_threshold_aug,</a>
<a name="ln5802">                            vector&lt;int&gt; ac_changes_aug)</a>
<a name="ln5803">        : mut (mut_aug),</a>
<a name="ln5804">          mutation_activation_threshold (mutation_activation_threshold_aug),</a>
<a name="ln5805">          ac_changes (ac_changes_aug)</a>
<a name="ln5806">        {</a>
<a name="ln5807">        }</a>
<a name="ln5808"> </a>
<a name="ln5809">    private:</a>
<a name="ln5810">        mutation_type mut;</a>
<a name="ln5811">        mutation_activity_type mutation_activation_threshold;</a>
<a name="ln5812">        vector&lt;int&gt; ac_changes;</a>
<a name="ln5813">};</a>
<a name="ln5814"> </a>
<a name="ln5815">// Constant vectors for the most common mutation ac results used in</a>
<a name="ln5816">// all_mutation_ac_changes</a>
<a name="ln5817">const vector&lt;int&gt; ONE_TWO_THREE  = {1,2,3};</a>
<a name="ln5818">const vector&lt;int&gt; TWO_THREE_FOUR = {2,3,4};</a>
<a name="ln5819"> </a>
<a name="ln5820">vector&lt;mutation_ac_changes&gt; all_mutation_ac_changes = {</a>
<a name="ln5821">     mutation_ac_changes(MUT_GELATINOUS_BODY,        mutation_activity_type::PARTIAL, ONE_TWO_THREE)</a>
<a name="ln5822">    ,mutation_ac_changes(MUT_TOUGH_SKIN,             mutation_activity_type::PARTIAL, ONE_TWO_THREE)</a>
<a name="ln5823">    ,mutation_ac_changes(MUT_SHAGGY_FUR,             mutation_activity_type::PARTIAL, ONE_TWO_THREE)</a>
<a name="ln5824">    ,mutation_ac_changes(MUT_PHYSICAL_VULNERABILITY, mutation_activity_type::PARTIAL, {-5,-10,-15})</a>
<a name="ln5825">    // Scale mutations are more easily disabled (forms etc.). This appears to be for flavour reasons.</a>
<a name="ln5826">    // Preserved behaviour from before mutation ac was turned to data.</a>
<a name="ln5827">    ,mutation_ac_changes(MUT_IRIDESCENT_SCALES,      mutation_activity_type::FULL,    {2, 4, 6})</a>
<a name="ln5828">    ,mutation_ac_changes(MUT_RUGGED_BROWN_SCALES,    mutation_activity_type::FULL,    ONE_TWO_THREE)</a>
<a name="ln5829">    ,mutation_ac_changes(MUT_ICY_BLUE_SCALES,        mutation_activity_type::FULL,    TWO_THREE_FOUR)</a>
<a name="ln5830">    ,mutation_ac_changes(MUT_MOLTEN_SCALES,          mutation_activity_type::FULL,    TWO_THREE_FOUR)</a>
<a name="ln5831">    ,mutation_ac_changes(MUT_SLIMY_GREEN_SCALES,     mutation_activity_type::FULL,    TWO_THREE_FOUR)</a>
<a name="ln5832">    ,mutation_ac_changes(MUT_THIN_METALLIC_SCALES,   mutation_activity_type::FULL,    TWO_THREE_FOUR)</a>
<a name="ln5833">    ,mutation_ac_changes(MUT_YELLOW_SCALES,          mutation_activity_type::FULL,    TWO_THREE_FOUR)</a>
<a name="ln5834">};</a>
<a name="ln5835"> </a>
<a name="ln5836">/**</a>
<a name="ln5837"> * The AC changes the player has from mutations.</a>
<a name="ln5838"> *</a>
<a name="ln5839"> * Mostly additions from things like scales, but the physical vulnerability</a>
<a name="ln5840"> * mutation is also accounted for.</a>
<a name="ln5841"> *</a>
<a name="ln5842"> * @return  The player's AC gain from mutation, with 100 scaling (i.e,</a>
<a name="ln5843"> *          the returned result 100 times the UI shows as of Jan 2020)</a>
<a name="ln5844">*/</a>
<a name="ln5845">int player::ac_changes_from_mutations() const</a>
<a name="ln5846">{</a>
<a name="ln5847"> </a>
<a name="ln5848">    int AC = 0;</a>
<a name="ln5849"> </a>
<a name="ln5850">    for (vector&lt;mutation_ac_changes&gt;::iterator it =</a>
<a name="ln5851">            all_mutation_ac_changes.begin();</a>
<a name="ln5852">            it != all_mutation_ac_changes.end(); ++it)</a>
<a name="ln5853">    {</a>
<a name="ln5854">        AC += it-&gt;get_ac_change_for_mutation();</a>
<a name="ln5855">    }</a>
<a name="ln5856"> </a>
<a name="ln5857">    return AC;</a>
<a name="ln5858">}</a>
<a name="ln5859"> </a>
<a name="ln5860">/**</a>
<a name="ln5861"> * Get a vector with the items of armour the player is wearing.</a>
<a name="ln5862"> *</a>
<a name="ln5863"> * @return  A vector of non-null pointers to all armour the player has equipped.</a>
<a name="ln5864"> */</a>
<a name="ln5865">vector&lt;const item_def *&gt; player::get_armour_items() const</a>
<a name="ln5866">{</a>
<a name="ln5867">    vector&lt;const item_def *&gt; armour_items;</a>
<a name="ln5868"> </a>
<a name="ln5869">    for (int eq = EQ_MIN_ARMOUR; eq &lt;= EQ_MAX_ARMOUR; ++eq)</a>
<a name="ln5870">    {</a>
<a name="ln5871">        if (!slot_item(static_cast&lt;equipment_type&gt;(eq)))</a>
<a name="ln5872">            continue;</a>
<a name="ln5873"> </a>
<a name="ln5874">        armour_items.push_back(&amp;inv[equip[eq]]);</a>
<a name="ln5875"> </a>
<a name="ln5876">    }</a>
<a name="ln5877"> </a>
<a name="ln5878">    return armour_items;</a>
<a name="ln5879">}</a>
<a name="ln5880"> </a>
<a name="ln5881">/**</a>
<a name="ln5882"> * Get a vector with the items of armour the player would be wearing</a>
<a name="ln5883"> * if they put on a specific piece of armour</a>
<a name="ln5884"> *</a>
<a name="ln5885"> * @param   The item which the player would be wearing in this theoretical</a>
<a name="ln5886"> *          situation.</a>
<a name="ln5887"> * @return  A vector of non-null pointers to all armour the player would have</a>
<a name="ln5888"> *          equipped.</a>
<a name="ln5889"> */</a>
<a name="ln5890">vector&lt;const item_def *&gt; player::get_armour_items_one_sub(const item_def&amp; sub) const</a>
<a name="ln5891">{</a>
<a name="ln5892">    vector&lt;const item_def *&gt; armour_items = get_armour_items_one_removal(sub);</a>
<a name="ln5893"> </a>
<a name="ln5894">    armour_items.push_back(&amp;sub);</a>
<a name="ln5895"> </a>
<a name="ln5896">    return armour_items;</a>
<a name="ln5897">}</a>
<a name="ln5898"> </a>
<a name="ln5899">/**</a>
<a name="ln5900"> * Get a vector with the items of armour the player would be wearing</a>
<a name="ln5901"> * if they removed a specific piece of armour</a>
<a name="ln5902"> *</a>
<a name="ln5903"> * @param   The item which the player would be remove in this theoretical</a>
<a name="ln5904"> *          situation.</a>
<a name="ln5905"> * @return  A vector of non-null pointers to all armour the player would have</a>
<a name="ln5906"> *          equipped after removing the item passed in.</a>
<a name="ln5907"> */</a>
<a name="ln5908">vector&lt;const item_def *&gt; player::get_armour_items_one_removal(const item_def&amp; remove) const</a>
<a name="ln5909">{</a>
<a name="ln5910">    vector&lt;const item_def *&gt; armour_items;</a>
<a name="ln5911"> </a>
<a name="ln5912">    for (int eq = EQ_MIN_ARMOUR; eq &lt;= EQ_MAX_ARMOUR; ++eq)</a>
<a name="ln5913">    {</a>
<a name="ln5914">        if (get_armour_slot(remove) == eq)</a>
<a name="ln5915">            continue;</a>
<a name="ln5916"> </a>
<a name="ln5917">        if (!slot_item(static_cast&lt;equipment_type&gt;(eq)))</a>
<a name="ln5918">            continue;</a>
<a name="ln5919"> </a>
<a name="ln5920">        armour_items.push_back(&amp;inv[equip[eq]]);</a>
<a name="ln5921"> </a>
<a name="ln5922">    }</a>
<a name="ln5923"> </a>
<a name="ln5924">    return armour_items;</a>
<a name="ln5925">}</a>
<a name="ln5926"> </a>
<a name="ln5927">/**</a>
<a name="ln5928"> * Get the players &quot;base&quot; ac, assuming they are wearing a particular set of</a>
<a name="ln5929"> * armour items (which isn't necessarily the set of armour items they are</a>
<a name="ln5930"> * currently wearing.)</a>
<a name="ln5931"> *</a>
<a name="ln5932"> * @param   A scale by which the player's base AC is multiplied.</a>
<a name="ln5933"> * @param   A list of items to assume the player is wearing.</a>
<a name="ln5934"> * @return  The player's AC, multiplied by the given scale.</a>
<a name="ln5935"> */</a>
<a name="ln5936">int player::base_ac_with_specific_items(int scale,</a>
<a name="ln5937">                            vector&lt;const item_def *&gt; armour_items) const</a>
<a name="ln5938">{</a>
<a name="ln5939">    int AC = 0;</a>
<a name="ln5940"> </a>
<a name="ln5941">    for (auto item : armour_items)</a>
<a name="ln5942">    {</a>
<a name="ln5943">        // Shields give SH instead of AC</a>
<a name="ln5944">        if (get_armour_slot(*item) != EQ_SHIELD)</a>
<a name="ln5945">        {</a>
<a name="ln5946">            AC += base_ac_from(*item, 100);</a>
<a name="ln5947">            AC += item-&gt;plus * 100;</a>
<a name="ln5948">        }</a>
<a name="ln5949"> </a>
<a name="ln5950">        if (get_armour_ego_type(*item) == SPARM_PROTECTION)</a>
<a name="ln5951">            AC += 300;</a>
<a name="ln5952">    }</a>
<a name="ln5953"> </a>
<a name="ln5954">    AC += wearing(EQ_RINGS_PLUS, RING_PROTECTION) * 100;</a>
<a name="ln5955"> </a>
<a name="ln5956">    //XXX: This doesn't take into account armour_items, so an unrand shield</a>
<a name="ln5957">    //     with +AC would have a buggy display.</a>
<a name="ln5958">    AC += scan_artefacts(ARTP_AC) * 100;</a>
<a name="ln5959"> </a>
<a name="ln5960">    AC += get_form()-&gt;get_ac_bonus();</a>
<a name="ln5961"> </a>
<a name="ln5962">    AC += racial_ac(true);</a>
<a name="ln5963"> </a>
<a name="ln5964">    AC += ac_changes_from_mutations();</a>
<a name="ln5965"> </a>
<a name="ln5966">    return AC * scale / 100;</a>
<a name="ln5967">}</a>
<a name="ln5968">/**</a>
<a name="ln5969"> * The player's &quot;base&quot; armour class, before transitory buffs are applied.</a>
<a name="ln5970"> *</a>
<a name="ln5971"> * (This is somewhat arbitrarily defined - forms, for example, are considered</a>
<a name="ln5972"> * to be long-lived for these purposes.)</a>
<a name="ln5973"> *</a>
<a name="ln5974"> * @param   A scale by which the player's base AC is multiplied.</a>
<a name="ln5975"> * @return  The player's AC, multiplied by the given scale.</a>
<a name="ln5976"> */</a>
<a name="ln5977">int player::base_ac(int scale) const</a>
<a name="ln5978">{</a>
<a name="ln5979">    vector&lt;const item_def *&gt; armour_items = get_armour_items();</a>
<a name="ln5980"> </a>
<a name="ln5981">    return base_ac_with_specific_items(scale, armour_items);</a>
<a name="ln5982">}</a>
<a name="ln5983"> </a>
<a name="ln5984">int player::armour_class(bool /*calc_unid*/) const</a>
<a name="ln5985">{</a>
<a name="ln5986">    return armour_class_with_specific_items(get_armour_items());</a>
<a name="ln5987">}</a>
<a name="ln5988"> </a>
<a name="ln5989">int player::armour_class_with_one_sub(item_def sub) const</a>
<a name="ln5990">{</a>
<a name="ln5991">    return armour_class_with_specific_items(</a>
<a name="ln5992">                            get_armour_items_one_sub(sub));</a>
<a name="ln5993">}</a>
<a name="ln5994"> </a>
<a name="ln5995">int player::armour_class_with_one_removal(item_def removed) const</a>
<a name="ln5996">{</a>
<a name="ln5997">    return armour_class_with_specific_items(</a>
<a name="ln5998">                            get_armour_items_one_removal(removed));</a>
<a name="ln5999">}</a>
<a name="ln6000"> </a>
<a name="ln6001">int player::armour_class_with_specific_items(vector&lt;const item_def *&gt; items) const</a>
<a name="ln6002">{</a>
<a name="ln6003">    const int scale = 100;</a>
<a name="ln6004">    int AC = base_ac_with_specific_items(scale, items);</a>
<a name="ln6005"> </a>
<a name="ln6006">    if (duration[DUR_ICY_ARMOUR])</a>
<a name="ln6007">        AC += 500 + you.props[ICY_ARMOUR_KEY].get_int() * 8;</a>
<a name="ln6008"> </a>
<a name="ln6009">    if (has_mutation(MUT_ICEMAIL))</a>
<a name="ln6010">        AC += 100 * player_icemail_armour_class();</a>
<a name="ln6011"> </a>
<a name="ln6012">    if (duration[DUR_QAZLAL_AC])</a>
<a name="ln6013">        AC += 300;</a>
<a name="ln6014"> </a>
<a name="ln6015">    if (duration[DUR_SPWPN_PROTECTION])</a>
<a name="ln6016">        AC += 700;</a>
<a name="ln6017"> </a>
<a name="ln6018">    if (duration[DUR_CORROSION])</a>
<a name="ln6019">        AC -= 400 * you.props[&quot;corrosion_amount&quot;].get_int();</a>
<a name="ln6020"> </a>
<a name="ln6021">    AC += sanguine_armour_bonus();</a>
<a name="ln6022"> </a>
<a name="ln6023">    return AC / scale;</a>
<a name="ln6024">}</a>
<a name="ln6025"> </a>
<a name="ln6026"> /**</a>
<a name="ln6027">  * Guaranteed damage reduction.</a>
<a name="ln6028">  *</a>
<a name="ln6029">  * The percentage of the damage received that is guaranteed to be reduced</a>
<a name="ln6030">  * by the armour. As the AC roll is done before GDR is applied, GDR is only</a>
<a name="ln6031">  * useful when the AC roll is inferior to it. Therefore a higher GDR means</a>
<a name="ln6032">  * more damage reduced, but also more often.</a>
<a name="ln6033">  *</a>
<a name="ln6034">  * \f[ GDR = 14 \times (base\_AC - 2)^\frac{1}{2} \f]</a>
<a name="ln6035">  *</a>
<a name="ln6036">  * \return GDR as a percentage.</a>
<a name="ln6037">  **/</a>
<a name="ln6038">int player::gdr_perc() const</a>
<a name="ln6039">{</a>
<a name="ln6040">    switch (form)</a>
<a name="ln6041">    {</a>
<a name="ln6042">    case transformation::dragon:</a>
<a name="ln6043">        return 34; // base AC 8</a>
<a name="ln6044">    case transformation::statue:</a>
<a name="ln6045">        return 39; // like plate (AC 10)</a>
<a name="ln6046">    case transformation::tree:</a>
<a name="ln6047">        return 48;</a>
<a name="ln6048">    default:</a>
<a name="ln6049">        break;</a>
<a name="ln6050">    }</a>
<a name="ln6051"> </a>
<a name="ln6052">    const item_def *body_armour = slot_item(EQ_BODY_ARMOUR, false);</a>
<a name="ln6053"> </a>
<a name="ln6054">    int body_base_AC = (species == SP_GARGOYLE ? 5 : 0);</a>
<a name="ln6055">    if (body_armour)</a>
<a name="ln6056">        body_base_AC += property(*body_armour, PARM_AC);</a>
<a name="ln6057"> </a>
<a name="ln6058">    // We take a sqrt here because damage prevented by GDR is</a>
<a name="ln6059">    // actually proportional to the square of the GDR percentage</a>
<a name="ln6060">    // (assuming you have enough AC).</a>
<a name="ln6061">    int gdr = 14 * sqrt(max(body_base_AC - 2, 0));</a>
<a name="ln6062"> </a>
<a name="ln6063">    return gdr;</a>
<a name="ln6064">}</a>
<a name="ln6065"> </a>
<a name="ln6066">/**</a>
<a name="ln6067"> * What is the player's actual, current EV, possibly relative to an attacker,</a>
<a name="ln6068"> * including various temporary penalties?</a>
<a name="ln6069"> *</a>
<a name="ln6070"> * @param evit     Penalty types which should be excluded from the calculation.</a>
<a name="ln6071"> * @param act      The creature that the player is attempting to evade, if any.</a>
<a name="ln6072"> *                 May be null.</a>
<a name="ln6073"> * @return         The player's relevant EV.</a>
<a name="ln6074"> */</a>
<a name="ln6075">int player::evasion(ev_ignore_type evit, const actor* act) const</a>
<a name="ln6076">{</a>
<a name="ln6077">    const int base_evasion = _player_evasion(evit);</a>
<a name="ln6078"> </a>
<a name="ln6079">    const int constrict_penalty = is_constricted() ? 3 : 0;</a>
<a name="ln6080"> </a>
<a name="ln6081">    const bool attacker_invis = act &amp;&amp; !act-&gt;visible_to(this);</a>
<a name="ln6082">    const int invis_penalty</a>
<a name="ln6083">        = attacker_invis &amp;&amp; !testbits(evit, ev_ignore::helpless) ? 10 : 0;</a>
<a name="ln6084"> </a>
<a name="ln6085">    return base_evasion - constrict_penalty - invis_penalty;</a>
<a name="ln6086">}</a>
<a name="ln6087"> </a>
<a name="ln6088">bool player::heal(int amount)</a>
<a name="ln6089">{</a>
<a name="ln6090">    ::inc_hp(amount);</a>
<a name="ln6091">    return true; /* TODO Check whether the player was healed. */</a>
<a name="ln6092">}</a>
<a name="ln6093"> </a>
<a name="ln6094">/**</a>
<a name="ln6095"> * What is the player's (current) mon_holy_type category?</a>
<a name="ln6096"> * Stays up to date with god for evil/unholy</a>
<a name="ln6097"> * Nonliving (statues, etc), undead, or alive.</a>
<a name="ln6098"> *</a>
<a name="ln6099"> * @param temp      Whether to consider temporary effects: forms,</a>
<a name="ln6100"> *                  petrification...</a>
<a name="ln6101"> * @return          The player's holiness category.</a>
<a name="ln6102"> */</a>
<a name="ln6103">mon_holy_type player::holiness(bool temp) const</a>
<a name="ln6104">{</a>
<a name="ln6105">    mon_holy_type holi;</a>
<a name="ln6106"> </a>
<a name="ln6107">    // Lich form takes precedence over a species' base holiness</a>
<a name="ln6108">    // Alive Vampires are MH_NATURAL</a>
<a name="ln6109">    if (is_lifeless_undead(temp))</a>
<a name="ln6110">        holi = MH_UNDEAD;</a>
<a name="ln6111">    else if (species == SP_GARGOYLE)</a>
<a name="ln6112">        holi = MH_NONLIVING;</a>
<a name="ln6113">    else</a>
<a name="ln6114">        holi = MH_NATURAL;</a>
<a name="ln6115"> </a>
<a name="ln6116">    // Petrification takes precedence over base holiness and lich form</a>
<a name="ln6117">    if (temp &amp;&amp; (form == transformation::statue</a>
<a name="ln6118">                 || form == transformation::wisp</a>
<a name="ln6119">                 || petrified()))</a>
<a name="ln6120">    {</a>
<a name="ln6121">        holi = MH_NONLIVING;</a>
<a name="ln6122">    }</a>
<a name="ln6123"> </a>
<a name="ln6124">    if (is_good_god(religion))</a>
<a name="ln6125">        holi |= MH_HOLY;</a>
<a name="ln6126"> </a>
<a name="ln6127">    if (is_evil_god(religion)</a>
<a name="ln6128">        || species == SP_DEMONSPAWN || species == SP_VAMPIRE)</a>
<a name="ln6129">    {</a>
<a name="ln6130">        holi |= MH_EVIL;</a>
<a name="ln6131">    }</a>
<a name="ln6132"> </a>
<a name="ln6133">    // possible XXX: Monsters get evil/unholy bits set on spell selection</a>
<a name="ln6134">    //  should players?</a>
<a name="ln6135">    return holi;</a>
<a name="ln6136">}</a>
<a name="ln6137"> </a>
<a name="ln6138">bool player::undead_or_demonic() const</a>
<a name="ln6139">{</a>
<a name="ln6140">    // This is only for TSO-related stuff, so demonspawn are included.</a>
<a name="ln6141">    return undead_state() || species == SP_DEMONSPAWN;</a>
<a name="ln6142">}</a>
<a name="ln6143"> </a>
<a name="ln6144">bool player::is_holy(bool /*check_spells*/) const</a>
<a name="ln6145">{</a>
<a name="ln6146">    return bool(holiness() &amp; MH_HOLY);</a>
<a name="ln6147">}</a>
<a name="ln6148"> </a>
<a name="ln6149">bool player::is_nonliving(bool temp) const</a>
<a name="ln6150">{</a>
<a name="ln6151">    return bool(holiness(temp) &amp; MH_NONLIVING);</a>
<a name="ln6152">}</a>
<a name="ln6153"> </a>
<a name="ln6154">// This is a stub. Check is used only for silver damage. Worship of chaotic</a>
<a name="ln6155">// gods should probably be checked in the non-existing player::is_unclean,</a>
<a name="ln6156">// which could be used for something Zin-related (such as a priestly monster).</a>
<a name="ln6157">int player::how_chaotic(bool /*check_spells_god*/) const</a>
<a name="ln6158">{</a>
<a name="ln6159">    return 0;</a>
<a name="ln6160">}</a>
<a name="ln6161"> </a>
<a name="ln6162">/**</a>
<a name="ln6163"> * Does the player need to breathe?</a>
<a name="ln6164"> *</a>
<a name="ln6165"> * Pretty much only matters for mephitic clouds, &amp; confusing spores, &amp; curare.</a>
<a name="ln6166"> *</a>
<a name="ln6167"> * @return  Whether the player has no need to breathe.</a>
<a name="ln6168"> */</a>
<a name="ln6169">bool player::is_unbreathing() const</a>
<a name="ln6170">{</a>
<a name="ln6171">    return !get_form()-&gt;breathes || petrified()</a>
<a name="ln6172">        || get_mutation_level(MUT_UNBREATHING);</a>
<a name="ln6173">}</a>
<a name="ln6174"> </a>
<a name="ln6175">bool player::is_insubstantial() const</a>
<a name="ln6176">{</a>
<a name="ln6177">    return form == transformation::wisp;</a>
<a name="ln6178">}</a>
<a name="ln6179"> </a>
<a name="ln6180">int player::res_acid(bool calc_unid) const</a>
<a name="ln6181">{</a>
<a name="ln6182">    return player_res_acid(calc_unid);</a>
<a name="ln6183">}</a>
<a name="ln6184"> </a>
<a name="ln6185">int player::res_fire() const</a>
<a name="ln6186">{</a>
<a name="ln6187">    return player_res_fire();</a>
<a name="ln6188">}</a>
<a name="ln6189"> </a>
<a name="ln6190">int player::res_steam() const</a>
<a name="ln6191">{</a>
<a name="ln6192">    return player_res_steam();</a>
<a name="ln6193">}</a>
<a name="ln6194"> </a>
<a name="ln6195">int player::res_cold() const</a>
<a name="ln6196">{</a>
<a name="ln6197">    return player_res_cold();</a>
<a name="ln6198">}</a>
<a name="ln6199"> </a>
<a name="ln6200">int player::res_elec() const</a>
<a name="ln6201">{</a>
<a name="ln6202">    return player_res_electricity();</a>
<a name="ln6203">}</a>
<a name="ln6204"> </a>
<a name="ln6205">int player::res_water_drowning() const</a>
<a name="ln6206">{</a>
<a name="ln6207">    int rw = 0;</a>
<a name="ln6208"> </a>
<a name="ln6209">    if (is_unbreathing()</a>
<a name="ln6210">        || species_can_swim(species) &amp;&amp; !form_changed_physiology()</a>
<a name="ln6211">        || form == transformation::ice_beast</a>
<a name="ln6212">        || form == transformation::hydra)</a>
<a name="ln6213">    {</a>
<a name="ln6214">        rw++;</a>
<a name="ln6215">    }</a>
<a name="ln6216"> </a>
<a name="ln6217">    return rw;</a>
<a name="ln6218">}</a>
<a name="ln6219"> </a>
<a name="ln6220">int player::res_poison(bool temp) const</a>
<a name="ln6221">{</a>
<a name="ln6222">    return player_res_poison(true, temp);</a>
<a name="ln6223">}</a>
<a name="ln6224"> </a>
<a name="ln6225">rot_resistance player::res_rotting(bool temp) const</a>
<a name="ln6226">{</a>
<a name="ln6227">    if (get_mutation_level(MUT_ROT_IMMUNITY)</a>
<a name="ln6228">        || is_nonliving(temp)</a>
<a name="ln6229">        || temp &amp;&amp; get_form()-&gt;res_rot())</a>
<a name="ln6230">    {</a>
<a name="ln6231">        return ROT_RESIST_FULL;</a>
<a name="ln6232">    }</a>
<a name="ln6233"> </a>
<a name="ln6234">    const item_def *armour = slot_item(EQ_BODY_ARMOUR);</a>
<a name="ln6235">    const bool embraced = armour &amp;&amp; is_unrandom_artefact(*armour, UNRAND_EMBRACE);</a>
<a name="ln6236">    const rot_resistance base_res = embraced ? ROT_RESIST_MUNDANE : ROT_RESIST_NONE;</a>
<a name="ln6237"> </a>
<a name="ln6238">    switch (undead_state(temp))</a>
<a name="ln6239">    {</a>
<a name="ln6240">    default:</a>
<a name="ln6241">    case US_ALIVE:</a>
<a name="ln6242">        return base_res;</a>
<a name="ln6243"> </a>
<a name="ln6244">    case US_HUNGRY_DEAD:</a>
<a name="ln6245">        return ROT_RESIST_MUNDANE; // rottable by Zin, not by necromancy</a>
<a name="ln6246"> </a>
<a name="ln6247">    case US_SEMI_UNDEAD:</a>
<a name="ln6248">        if (temp &amp;&amp; !you.vampire_alive)</a>
<a name="ln6249">            return ROT_RESIST_MUNDANE;</a>
<a name="ln6250">        return base_res;</a>
<a name="ln6251"> </a>
<a name="ln6252">    case US_UNDEAD:</a>
<a name="ln6253">        return ROT_RESIST_FULL;</a>
<a name="ln6254">    }</a>
<a name="ln6255">}</a>
<a name="ln6256"> </a>
<a name="ln6257">bool player::res_sticky_flame() const</a>
<a name="ln6258">{</a>
<a name="ln6259">    return player_res_sticky_flame();</a>
<a name="ln6260">}</a>
<a name="ln6261"> </a>
<a name="ln6262">int player::res_holy_energy() const</a>
<a name="ln6263">{</a>
<a name="ln6264">    if (undead_or_demonic())</a>
<a name="ln6265">        return -1;</a>
<a name="ln6266"> </a>
<a name="ln6267">    if (is_holy())</a>
<a name="ln6268">        return 3;</a>
<a name="ln6269"> </a>
<a name="ln6270">    return 0;</a>
<a name="ln6271">}</a>
<a name="ln6272"> </a>
<a name="ln6273">int player::res_negative_energy(bool intrinsic_only) const</a>
<a name="ln6274">{</a>
<a name="ln6275">    return player_prot_life(!intrinsic_only, true, !intrinsic_only);</a>
<a name="ln6276">}</a>
<a name="ln6277"> </a>
<a name="ln6278">bool player::res_torment() const</a>
<a name="ln6279">{</a>
<a name="ln6280">    return player_res_torment();</a>
<a name="ln6281">}</a>
<a name="ln6282"> </a>
<a name="ln6283">bool player::res_tornado() const</a>
<a name="ln6284">{</a>
<a name="ln6285">    // Full control of the winds around you can negate a hostile tornado.</a>
<a name="ln6286">    return duration[DUR_TORNADO] ? 1 : 0;</a>
<a name="ln6287">}</a>
<a name="ln6288"> </a>
<a name="ln6289">bool player::res_petrify(bool temp) const</a>
<a name="ln6290">{</a>
<a name="ln6291">    return get_mutation_level(MUT_PETRIFICATION_RESISTANCE)</a>
<a name="ln6292">           || temp &amp;&amp; get_form()-&gt;res_petrify();</a>
<a name="ln6293">}</a>
<a name="ln6294"> </a>
<a name="ln6295">int player::res_constrict() const</a>
<a name="ln6296">{</a>
<a name="ln6297">    if (is_insubstantial())</a>
<a name="ln6298">        return 3;</a>
<a name="ln6299"> </a>
<a name="ln6300">    if (get_mutation_level(MUT_SPINY))</a>
<a name="ln6301">        return 3;</a>
<a name="ln6302"> </a>
<a name="ln6303">    return 0;</a>
<a name="ln6304">}</a>
<a name="ln6305"> </a>
<a name="ln6306">int player::res_magic(bool /*calc_unid*/) const</a>
<a name="ln6307">{</a>
<a name="ln6308">    return player_res_magic();</a>
<a name="ln6309">}</a>
<a name="ln6310"> </a>
<a name="ln6311">int player_res_magic(bool calc_unid, bool temp)</a>
<a name="ln6312">{</a>
<a name="ln6313"> </a>
<a name="ln6314">    if (temp &amp;&amp; you.form == transformation::shadow)</a>
<a name="ln6315">        return MAG_IMMUNE;</a>
<a name="ln6316"> </a>
<a name="ln6317">    int rm = you.experience_level * species_mr_modifier(you.species);</a>
<a name="ln6318"> </a>
<a name="ln6319">    // randarts</a>
<a name="ln6320">    rm += MR_PIP * you.scan_artefacts(ARTP_MAGIC_RESISTANCE, calc_unid);</a>
<a name="ln6321"> </a>
<a name="ln6322">    // body armour</a>
<a name="ln6323">    const item_def *body_armour = you.slot_item(EQ_BODY_ARMOUR);</a>
<a name="ln6324">    if (body_armour)</a>
<a name="ln6325">        rm += armour_type_prop(body_armour-&gt;sub_type, ARMF_RES_MAGIC) * MR_PIP;</a>
<a name="ln6326"> </a>
<a name="ln6327">    // ego armours</a>
<a name="ln6328">    rm += MR_PIP * you.wearing_ego(EQ_ALL_ARMOUR, SPARM_MAGIC_RESISTANCE,</a>
<a name="ln6329">                                   calc_unid);</a>
<a name="ln6330"> </a>
<a name="ln6331">    // rings of magic resistance</a>
<a name="ln6332">    rm += MR_PIP * you.wearing(EQ_RINGS, RING_PROTECTION_FROM_MAGIC, calc_unid);</a>
<a name="ln6333"> </a>
<a name="ln6334">    // Mutations</a>
<a name="ln6335">    rm += MR_PIP * you.get_mutation_level(MUT_MAGIC_RESISTANCE);</a>
<a name="ln6336">    rm -= MR_PIP * you.get_mutation_level(MUT_MAGICAL_VULNERABILITY);</a>
<a name="ln6337"> </a>
<a name="ln6338">    // transformations</a>
<a name="ln6339">    if (you.form == transformation::lich &amp;&amp; temp)</a>
<a name="ln6340">        rm += MR_PIP;</a>
<a name="ln6341"> </a>
<a name="ln6342">    // Trog's Hand</a>
<a name="ln6343">    if (you.duration[DUR_TROGS_HAND] &amp;&amp; temp)</a>
<a name="ln6344">        rm += MR_PIP * 2;</a>
<a name="ln6345"> </a>
<a name="ln6346">    // Enchantment effect</a>
<a name="ln6347">    if (you.duration[DUR_LOWERED_MR] &amp;&amp; temp)</a>
<a name="ln6348">        rm /= 2;</a>
<a name="ln6349"> </a>
<a name="ln6350">    if (rm &lt; 0)</a>
<a name="ln6351">        rm = 0;</a>
<a name="ln6352"> </a>
<a name="ln6353">    return rm;</a>
<a name="ln6354">}</a>
<a name="ln6355"> </a>
<a name="ln6356">/**</a>
<a name="ln6357"> * Is the player prevented from teleporting? If so, why?</a>
<a name="ln6358"> *</a>
<a name="ln6359"> * @param calc_unid     Whether to identify unknown items that prevent tele</a>
<a name="ln6360"> *                      (probably obsolete)</a>
<a name="ln6361"> * @param blinking      Are you blinking or teleporting?</a>
<a name="ln6362"> * @return              Why the player is prevented from teleporting, if they</a>
<a name="ln6363"> *                      are; else, the empty string.</a>
<a name="ln6364"> */</a>
<a name="ln6365">string player::no_tele_reason(bool calc_unid, bool blinking) const</a>
<a name="ln6366">{</a>
<a name="ln6367">    if (!blinking)</a>
<a name="ln6368">    {</a>
<a name="ln6369">        if (crawl_state.game_is_sprint())</a>
<a name="ln6370">            return &quot;Long-range teleportation is disallowed in Dungeon Sprint.&quot;;</a>
<a name="ln6371">        else if (player_in_branch(BRANCH_GAUNTLET))</a>
<a name="ln6372">        {</a>
<a name="ln6373">            return &quot;A magic seal in the Gauntlet prevents long-range &quot;</a>
<a name="ln6374">                &quot;teleports.&quot;;</a>
<a name="ln6375">        }</a>
<a name="ln6376">    }</a>
<a name="ln6377"> </a>
<a name="ln6378">    if (stasis())</a>
<a name="ln6379">        return &quot;Your stasis prevents you from teleporting.&quot;;</a>
<a name="ln6380"> </a>
<a name="ln6381">    vector&lt;string&gt; problems;</a>
<a name="ln6382"> </a>
<a name="ln6383">    if (duration[DUR_DIMENSION_ANCHOR])</a>
<a name="ln6384">        problems.emplace_back(&quot;locked down by a dimension anchor&quot;);</a>
<a name="ln6385"> </a>
<a name="ln6386">    if (form == transformation::tree)</a>
<a name="ln6387">        problems.emplace_back(&quot;held in place by your roots&quot;);</a>
<a name="ln6388"> </a>
<a name="ln6389">    vector&lt;const item_def *&gt; notele_items;</a>
<a name="ln6390">    if (has_notele_item(calc_unid, &amp;notele_items))</a>
<a name="ln6391">    {</a>
<a name="ln6392">        vector&lt;string&gt; worn_notele;</a>
<a name="ln6393">        bool found_nonartefact = false;</a>
<a name="ln6394"> </a>
<a name="ln6395">        for (const auto item : notele_items)</a>
<a name="ln6396">        {</a>
<a name="ln6397">            if (item-&gt;base_type == OBJ_WEAPONS)</a>
<a name="ln6398">            {</a>
<a name="ln6399">                problems.push_back(make_stringf(&quot;wielding %s&quot;,</a>
<a name="ln6400">                                                item-&gt;name(DESC_A).c_str()));</a>
<a name="ln6401">            }</a>
<a name="ln6402">            else</a>
<a name="ln6403">                worn_notele.push_back(item-&gt;name(DESC_A));</a>
<a name="ln6404">        }</a>
<a name="ln6405"> </a>
<a name="ln6406">        if (worn_notele.size() &gt; (problems.empty() ? 3 : 1))</a>
<a name="ln6407">        {</a>
<a name="ln6408">            problems.push_back(</a>
<a name="ln6409">                make_stringf(&quot;wearing %s %s preventing teleportation&quot;,</a>
<a name="ln6410">                             number_in_words(worn_notele.size()).c_str(),</a>
<a name="ln6411">                             found_nonartefact ? &quot;items&quot;: &quot;artefacts&quot;));</a>
<a name="ln6412">        }</a>
<a name="ln6413">        else if (!worn_notele.empty())</a>
<a name="ln6414">        {</a>
<a name="ln6415">            problems.push_back(</a>
<a name="ln6416">                make_stringf(&quot;wearing %s&quot;,</a>
<a name="ln6417">                             comma_separated_line(worn_notele.begin(),</a>
<a name="ln6418">                                                  worn_notele.end()).c_str()));</a>
<a name="ln6419">        }</a>
<a name="ln6420">    }</a>
<a name="ln6421"> </a>
<a name="ln6422">    if (problems.empty())</a>
<a name="ln6423">        return &quot;&quot;; // no problem</a>
<a name="ln6424"> </a>
<a name="ln6425">    return make_stringf(&quot;You cannot %s because you are %s.&quot;,</a>
<a name="ln6426">                        blinking ? &quot;blink&quot; : &quot;teleport&quot;,</a>
<a name="ln6427">                        comma_separated_line(problems.begin(),</a>
<a name="ln6428">                                             problems.end()).c_str());</a>
<a name="ln6429">}</a>
<a name="ln6430"> </a>
<a name="ln6431">/**</a>
<a name="ln6432"> * Is the player prevented from teleporting/blinking right now? If so,</a>
<a name="ln6433"> * print why.</a>
<a name="ln6434"> *</a>
<a name="ln6435"> * @param calc_unid     Whether to identify unknown items that prevent tele</a>
<a name="ln6436"> *                      (probably obsolete)</a>
<a name="ln6437"> * @param blinking      Are you blinking or teleporting?</a>
<a name="ln6438"> * @return              Whether the player is prevented from teleportation.</a>
<a name="ln6439"> */</a>
<a name="ln6440">bool player::no_tele_print_reason(bool calc_unid, bool blinking) const</a>
<a name="ln6441">{</a>
<a name="ln6442">    const string reason = no_tele_reason(calc_unid, blinking);</a>
<a name="ln6443">    if (reason.empty())</a>
<a name="ln6444">        return false;</a>
<a name="ln6445"> </a>
<a name="ln6446">    mpr(reason);</a>
<a name="ln6447">    return true;</a>
<a name="ln6448">}</a>
<a name="ln6449"> </a>
<a name="ln6450">/**</a>
<a name="ln6451"> * Is the player prevented from teleporting/blinking right now?</a>
<a name="ln6452"> *</a>
<a name="ln6453"> * @param calc_unid     Whether to identify unknown items that prevent tele</a>
<a name="ln6454"> *                      (probably obsolete)</a>
<a name="ln6455"> * @param permit_id     Unused for players.</a>
<a name="ln6456"> * @param blinking      Are you blinking or teleporting?</a>
<a name="ln6457"> * @return              Whether the player is prevented from teleportation.</a>
<a name="ln6458"> */</a>
<a name="ln6459">bool player::no_tele(bool calc_unid, bool /*permit_id*/, bool blinking) const</a>
<a name="ln6460">{</a>
<a name="ln6461">    return !no_tele_reason(calc_unid, blinking).empty();</a>
<a name="ln6462">}</a>
<a name="ln6463"> </a>
<a name="ln6464">bool player::fights_well_unarmed(int heavy_armour_penalty)</a>
<a name="ln6465">{</a>
<a name="ln6466">    return x_chance_in_y(skill(SK_UNARMED_COMBAT, 10), 200)</a>
<a name="ln6467">        &amp;&amp; x_chance_in_y(2, 1 + heavy_armour_penalty);</a>
<a name="ln6468">}</a>
<a name="ln6469"> </a>
<a name="ln6470">bool player::cancellable_flight() const</a>
<a name="ln6471">{</a>
<a name="ln6472">    return duration[DUR_FLIGHT] &amp;&amp; !permanent_flight()</a>
<a name="ln6473">           &amp;&amp; !attribute[ATTR_FLIGHT_UNCANCELLABLE];</a>
<a name="ln6474">}</a>
<a name="ln6475"> </a>
<a name="ln6476">bool player::permanent_flight() const</a>
<a name="ln6477">{</a>
<a name="ln6478">    return attribute[ATTR_PERM_FLIGHT];</a>
<a name="ln6479">}</a>
<a name="ln6480"> </a>
<a name="ln6481">bool player::racial_permanent_flight() const</a>
<a name="ln6482">{</a>
<a name="ln6483">    return get_mutation_level(MUT_TENGU_FLIGHT)</a>
<a name="ln6484">        || get_mutation_level(MUT_BIG_WINGS);</a>
<a name="ln6485">}</a>
<a name="ln6486"> </a>
<a name="ln6487">bool player::tengu_flight() const</a>
<a name="ln6488">{</a>
<a name="ln6489">    // Only Tengu get perks for flying.</a>
<a name="ln6490">    return species == SP_TENGU &amp;&amp; airborne();</a>
<a name="ln6491">}</a>
<a name="ln6492"> </a>
<a name="ln6493">/**</a>
<a name="ln6494"> * Returns true if player spellcasting is considered unholy.</a>
<a name="ln6495"> *</a>
<a name="ln6496"> * Checks to see if the player is wielding the Majin-Bo.</a>
<a name="ln6497"> *</a>
<a name="ln6498"> * @return          Whether player spellcasting is an unholy act.</a>
<a name="ln6499"> */</a>
<a name="ln6500">bool player::spellcasting_unholy() const</a>
<a name="ln6501">{</a>
<a name="ln6502">    return player_equip_unrand(UNRAND_MAJIN);</a>
<a name="ln6503">}</a>
<a name="ln6504"> </a>
<a name="ln6505">/**</a>
<a name="ln6506"> * What is the player's (current) place on the Undead Spectrum?</a>
<a name="ln6507"> * (alive, hungry undead (ghoul), semi-undead (vampire), or very dead (mummy,</a>
<a name="ln6508"> * lich)</a>
<a name="ln6509"> *</a>
<a name="ln6510"> * @param temp  Whether to consider temporary effects (lichform)</a>
<a name="ln6511"> * @return      The player's undead state.</a>
<a name="ln6512"> */</a>
<a name="ln6513">undead_state_type player::undead_state(bool temp) const</a>
<a name="ln6514">{</a>
<a name="ln6515">    if (temp &amp;&amp; you.form == transformation::lich)</a>
<a name="ln6516">        return US_UNDEAD;</a>
<a name="ln6517">    return species_undead_type(you.species);</a>
<a name="ln6518">}</a>
<a name="ln6519"> </a>
<a name="ln6520">bool player::nightvision() const</a>
<a name="ln6521">{</a>
<a name="ln6522">    return have_passive(passive_t::nightvision);</a>
<a name="ln6523">}</a>
<a name="ln6524"> </a>
<a name="ln6525">reach_type player::reach_range() const</a>
<a name="ln6526">{</a>
<a name="ln6527">    const item_def *wpn = weapon();</a>
<a name="ln6528">    if (wpn)</a>
<a name="ln6529">        return weapon_reach(*wpn);</a>
<a name="ln6530">    return REACH_NONE;</a>
<a name="ln6531">}</a>
<a name="ln6532"> </a>
<a name="ln6533">monster_type player::mons_species(bool /*zombie_base*/) const</a>
<a name="ln6534">{</a>
<a name="ln6535">    return player_species_to_mons_species(species);</a>
<a name="ln6536">}</a>
<a name="ln6537"> </a>
<a name="ln6538">bool player::poison(actor *agent, int amount, bool force)</a>
<a name="ln6539">{</a>
<a name="ln6540">    return ::poison_player(amount, agent? agent-&gt;name(DESC_A, true) : &quot;&quot;, &quot;&quot;,</a>
<a name="ln6541">                           force);</a>
<a name="ln6542">}</a>
<a name="ln6543"> </a>
<a name="ln6544">void player::expose_to_element(beam_type element, int _strength,</a>
<a name="ln6545">                               bool slow_cold_blood)</a>
<a name="ln6546">{</a>
<a name="ln6547">    ::expose_player_to_element(element, _strength, slow_cold_blood);</a>
<a name="ln6548">}</a>
<a name="ln6549"> </a>
<a name="ln6550">void player::blink()</a>
<a name="ln6551">{</a>
<a name="ln6552">    cast_blink();</a>
<a name="ln6553">}</a>
<a name="ln6554"> </a>
<a name="ln6555">void player::teleport(bool now, bool wizard_tele)</a>
<a name="ln6556">{</a>
<a name="ln6557">    ASSERT(!crawl_state.game_is_arena());</a>
<a name="ln6558"> </a>
<a name="ln6559">    if (now)</a>
<a name="ln6560">        you_teleport_now(wizard_tele);</a>
<a name="ln6561">    else</a>
<a name="ln6562">        you_teleport();</a>
<a name="ln6563">}</a>
<a name="ln6564"> </a>
<a name="ln6565">int player::hurt(const actor *agent, int amount, beam_type flavour,</a>
<a name="ln6566">                 kill_method_type kill_type, string source, string aux,</a>
<a name="ln6567">                 bool /*cleanup_dead*/, bool /*attacker_effects*/)</a>
<a name="ln6568">{</a>
<a name="ln6569">    // We ignore cleanup_dead here.</a>
<a name="ln6570">    if (!agent)</a>
<a name="ln6571">    {</a>
<a name="ln6572">        // FIXME: This can happen if a deferred_damage_fineff does damage</a>
<a name="ln6573">        // to a player from a dead monster. We should probably not do that,</a>
<a name="ln6574">        // but it could be tricky to fix, so for now let's at least avoid</a>
<a name="ln6575">        // a crash even if it does mean funny death messages.</a>
<a name="ln6576">        ouch(amount, kill_type, MID_NOBODY, aux.c_str(), false, source.c_str());</a>
<a name="ln6577">    }</a>
<a name="ln6578">    else</a>
<a name="ln6579">    {</a>
<a name="ln6580">        ouch(amount, kill_type, agent-&gt;mid, aux.c_str(),</a>
<a name="ln6581">             agent-&gt;visible_to(this), source.c_str());</a>
<a name="ln6582">    }</a>
<a name="ln6583"> </a>
<a name="ln6584">    if ((flavour == BEAM_DEVASTATION || flavour == BEAM_DISINTEGRATION)</a>
<a name="ln6585">        &amp;&amp; can_bleed())</a>
<a name="ln6586">    {</a>
<a name="ln6587">        blood_spray(pos(), type, amount / 5);</a>
<a name="ln6588">    }</a>
<a name="ln6589"> </a>
<a name="ln6590">    return amount;</a>
<a name="ln6591">}</a>
<a name="ln6592"> </a>
<a name="ln6593">void player::drain_stat(stat_type s, int amount)</a>
<a name="ln6594">{</a>
<a name="ln6595">    lose_stat(s, amount);</a>
<a name="ln6596">}</a>
<a name="ln6597"> </a>
<a name="ln6598">bool player::rot(actor */*who*/, int amount, bool quiet, bool /*no_cleanup*/)</a>
<a name="ln6599">{</a>
<a name="ln6600">    ASSERT(!crawl_state.game_is_arena());</a>
<a name="ln6601"> </a>
<a name="ln6602">    if (amount &lt;= 0)</a>
<a name="ln6603">        return false;</a>
<a name="ln6604"> </a>
<a name="ln6605">    if (res_rotting() || duration[DUR_DEATHS_DOOR])</a>
<a name="ln6606">    {</a>
<a name="ln6607">        mpr(&quot;You feel terrible.&quot;);</a>
<a name="ln6608">        return false;</a>
<a name="ln6609">    }</a>
<a name="ln6610"> </a>
<a name="ln6611">    if (duration[DUR_DIVINE_STAMINA] &gt; 0)</a>
<a name="ln6612">    {</a>
<a name="ln6613">        mpr(&quot;Your divine stamina protects you from decay!&quot;);</a>
<a name="ln6614">        return false;</a>
<a name="ln6615">    }</a>
<a name="ln6616"> </a>
<a name="ln6617">    rot_hp(amount);</a>
<a name="ln6618"> </a>
<a name="ln6619">    if (!quiet)</a>
<a name="ln6620">        mprf(MSGCH_WARN, &quot;You feel your flesh rotting away!&quot;);</a>
<a name="ln6621"> </a>
<a name="ln6622">    learned_something_new(HINT_YOU_ROTTING);</a>
<a name="ln6623"> </a>
<a name="ln6624">    if (one_chance_in(4))</a>
<a name="ln6625">        sicken(50 + random2(100));</a>
<a name="ln6626"> </a>
<a name="ln6627">    return true;</a>
<a name="ln6628">}</a>
<a name="ln6629"> </a>
<a name="ln6630">bool player::corrode_equipment(const char* corrosion_source, int degree)</a>
<a name="ln6631">{</a>
<a name="ln6632">    // rCorr protects against 50% of corrosion.</a>
<a name="ln6633">    if (res_corr())</a>
<a name="ln6634">    {</a>
<a name="ln6635">        degree = binomial(degree, 50);</a>
<a name="ln6636">        if (!degree)</a>
<a name="ln6637">        {</a>
<a name="ln6638">            dprf(&quot;rCorr protects.&quot;);</a>
<a name="ln6639">            return false;</a>
<a name="ln6640">        }</a>
<a name="ln6641">    }</a>
<a name="ln6642">    // always increase duration, but...</a>
<a name="ln6643">    increase_duration(DUR_CORROSION, 10 + roll_dice(2, 4), 50,</a>
<a name="ln6644">                      make_stringf(&quot;%s corrodes you!&quot;,</a>
<a name="ln6645">                                   corrosion_source).c_str());</a>
<a name="ln6646"> </a>
<a name="ln6647">    // the more corrosion you already have, the lower the odds of more</a>
<a name="ln6648">    int prev_corr = props[&quot;corrosion_amount&quot;].get_int();</a>
<a name="ln6649">    bool did_corrode = false;</a>
<a name="ln6650">    for (int i = 0; i &lt; degree; i++)</a>
<a name="ln6651">        if (!x_chance_in_y(prev_corr, prev_corr + 7))</a>
<a name="ln6652">        {</a>
<a name="ln6653">            props[&quot;corrosion_amount&quot;].get_int()++;</a>
<a name="ln6654">            prev_corr++;</a>
<a name="ln6655">            did_corrode = true;</a>
<a name="ln6656">        }</a>
<a name="ln6657"> </a>
<a name="ln6658">    if (did_corrode)</a>
<a name="ln6659">    {</a>
<a name="ln6660">        redraw_armour_class = true;</a>
<a name="ln6661">        wield_change = true;</a>
<a name="ln6662">    }</a>
<a name="ln6663">    return true;</a>
<a name="ln6664">}</a>
<a name="ln6665"> </a>
<a name="ln6666">/**</a>
<a name="ln6667"> * Attempts to apply corrosion to the player and deals acid damage.</a>
<a name="ln6668"> *</a>
<a name="ln6669"> * @param evildoer the cause of this acid splash.</a>
<a name="ln6670"> * @param acid_strength The strength of the acid.</a>
<a name="ln6671"> * @param allow_corrosion Whether to try and apply the corrosion debuff.</a>
<a name="ln6672"> * @param hurt_msg A message to display when dealing damage.</a>
<a name="ln6673"> */</a>
<a name="ln6674">void player::splash_with_acid(const actor* evildoer, int acid_strength,</a>
<a name="ln6675">                              bool allow_corrosion, const char* /*hurt_msg*/)</a>
<a name="ln6676">{</a>
<a name="ln6677">    if (allow_corrosion &amp;&amp; binomial(3, acid_strength + 1, 30))</a>
<a name="ln6678">        corrode_equipment();</a>
<a name="ln6679"> </a>
<a name="ln6680">    const int dam = roll_dice(4, acid_strength);</a>
<a name="ln6681">    const int post_res_dam = resist_adjust_damage(&amp;you, BEAM_ACID, dam);</a>
<a name="ln6682"> </a>
<a name="ln6683">    mprf(&quot;You are splashed with acid%s%s&quot;,</a>
<a name="ln6684">         post_res_dam &gt; 0 ? &quot;&quot; : &quot; but take no damage&quot;,</a>
<a name="ln6685">         attack_strength_punctuation(post_res_dam).c_str());</a>
<a name="ln6686">    if (post_res_dam &gt; 0)</a>
<a name="ln6687">    {</a>
<a name="ln6688">        if (post_res_dam &lt; dam)</a>
<a name="ln6689">            canned_msg(MSG_YOU_RESIST);</a>
<a name="ln6690"> </a>
<a name="ln6691">        ouch(post_res_dam, KILLED_BY_ACID,</a>
<a name="ln6692">             evildoer ? evildoer-&gt;mid : MID_NOBODY);</a>
<a name="ln6693">    }</a>
<a name="ln6694">}</a>
<a name="ln6695"> </a>
<a name="ln6696">bool player::drain_exp(actor */*who*/, bool quiet, int pow)</a>
<a name="ln6697">{</a>
<a name="ln6698">    return drain_player(pow, !quiet);</a>
<a name="ln6699">}</a>
<a name="ln6700"> </a>
<a name="ln6701">void player::confuse(actor */*who*/, int str)</a>
<a name="ln6702">{</a>
<a name="ln6703">    confuse_player(str);</a>
<a name="ln6704">}</a>
<a name="ln6705"> </a>
<a name="ln6706">/**</a>
<a name="ln6707"> * Paralyse the player for str turns.</a>
<a name="ln6708"> *</a>
<a name="ln6709"> *  Duration is capped at 13.</a>
<a name="ln6710"> *</a>
<a name="ln6711"> * @param who Pointer to the actor who paralysed the player.</a>
<a name="ln6712"> * @param str The number of turns the paralysis will last.</a>
<a name="ln6713"> * @param source Description of the source of the paralysis.</a>
<a name="ln6714"> */</a>
<a name="ln6715">void player::paralyse(actor *who, int str, string source)</a>
<a name="ln6716">{</a>
<a name="ln6717">    ASSERT(!crawl_state.game_is_arena());</a>
<a name="ln6718"> </a>
<a name="ln6719">    if (stasis())</a>
<a name="ln6720">    {</a>
<a name="ln6721">        mpr(&quot;Your stasis prevents you from being paralysed.&quot;);</a>
<a name="ln6722">        return;</a>
<a name="ln6723">    }</a>
<a name="ln6724"> </a>
<a name="ln6725">    // The who check has an effect in a few cases, most notably making</a>
<a name="ln6726">    // Death's Door + Borg's paralysis unblockable.</a>
<a name="ln6727">    if (who &amp;&amp; (duration[DUR_PARALYSIS] || duration[DUR_PARALYSIS_IMMUNITY]))</a>
<a name="ln6728">    {</a>
<a name="ln6729">        mpr(&quot;You shrug off the repeated paralysis!&quot;);</a>
<a name="ln6730">        return;</a>
<a name="ln6731">    }</a>
<a name="ln6732"> </a>
<a name="ln6733">    int &amp;paralysis(duration[DUR_PARALYSIS]);</a>
<a name="ln6734"> </a>
<a name="ln6735">    const bool use_actor_name = source.empty() &amp;&amp; who != nullptr;</a>
<a name="ln6736">    if (use_actor_name)</a>
<a name="ln6737">        source = who-&gt;name(DESC_A);</a>
<a name="ln6738"> </a>
<a name="ln6739">    if (!paralysis &amp;&amp; !source.empty())</a>
<a name="ln6740">    {</a>
<a name="ln6741">        take_note(Note(NOTE_PARALYSIS, str, 0, source));</a>
<a name="ln6742">        // use the real name here even for invisible monsters</a>
<a name="ln6743">        props[PARALYSED_BY_KEY] = use_actor_name ? who-&gt;name(DESC_A, true)</a>
<a name="ln6744">                                               : source;</a>
<a name="ln6745">    }</a>
<a name="ln6746"> </a>
<a name="ln6747">    if (asleep())</a>
<a name="ln6748">        you.awaken();</a>
<a name="ln6749"> </a>
<a name="ln6750">    mpr(&quot;You suddenly lose the ability to move!&quot;);</a>
<a name="ln6751"> </a>
<a name="ln6752">    paralysis = min(str, 13) * BASELINE_DELAY;</a>
<a name="ln6753"> </a>
<a name="ln6754">    stop_directly_constricting_all(false);</a>
<a name="ln6755">    end_searing_ray();</a>
<a name="ln6756">}</a>
<a name="ln6757"> </a>
<a name="ln6758">void player::petrify(actor *who, bool force)</a>
<a name="ln6759">{</a>
<a name="ln6760">    ASSERT(!crawl_state.game_is_arena());</a>
<a name="ln6761"> </a>
<a name="ln6762">    if (res_petrify() &amp;&amp; !force)</a>
<a name="ln6763">    {</a>
<a name="ln6764">        canned_msg(MSG_YOU_UNAFFECTED);</a>
<a name="ln6765">        return;</a>
<a name="ln6766">    }</a>
<a name="ln6767"> </a>
<a name="ln6768">    if (duration[DUR_DIVINE_STAMINA] &gt; 0)</a>
<a name="ln6769">    {</a>
<a name="ln6770">        mpr(&quot;Your divine stamina protects you from petrification!&quot;);</a>
<a name="ln6771">        return;</a>
<a name="ln6772">    }</a>
<a name="ln6773"> </a>
<a name="ln6774">    // Petrification always wakes you up</a>
<a name="ln6775">    if (asleep())</a>
<a name="ln6776">        you.awaken();</a>
<a name="ln6777"> </a>
<a name="ln6778">    if (petrifying())</a>
<a name="ln6779">    {</a>
<a name="ln6780">        mpr(&quot;Your limbs have turned to stone.&quot;);</a>
<a name="ln6781">        duration[DUR_PETRIFYING] = 1;</a>
<a name="ln6782">        return;</a>
<a name="ln6783">    }</a>
<a name="ln6784"> </a>
<a name="ln6785">    if (petrified())</a>
<a name="ln6786">        return;</a>
<a name="ln6787"> </a>
<a name="ln6788">    duration[DUR_PETRIFYING] = 3 * BASELINE_DELAY;</a>
<a name="ln6789"> </a>
<a name="ln6790">    if (who)</a>
<a name="ln6791">        props[PETRIFIED_BY_KEY] = who-&gt;name(DESC_A, true);</a>
<a name="ln6792"> </a>
<a name="ln6793">    redraw_evasion = true;</a>
<a name="ln6794">    mprf(MSGCH_WARN, &quot;You are slowing down.&quot;);</a>
<a name="ln6795">}</a>
<a name="ln6796"> </a>
<a name="ln6797">bool player::fully_petrify(actor */*foe*/, bool /*quiet*/)</a>
<a name="ln6798">{</a>
<a name="ln6799">    duration[DUR_PETRIFIED] = 6 * BASELINE_DELAY</a>
<a name="ln6800">                        + random2(4 * BASELINE_DELAY);</a>
<a name="ln6801">    redraw_evasion = true;</a>
<a name="ln6802">    mpr(&quot;You have turned to stone.&quot;);</a>
<a name="ln6803"> </a>
<a name="ln6804">    end_searing_ray();</a>
<a name="ln6805"> </a>
<a name="ln6806">    return true;</a>
<a name="ln6807">}</a>
<a name="ln6808"> </a>
<a name="ln6809">void player::slow_down(actor */*foe*/, int str)</a>
<a name="ln6810">{</a>
<a name="ln6811">    ::slow_player(str);</a>
<a name="ln6812">}</a>
<a name="ln6813"> </a>
<a name="ln6814"> </a>
<a name="ln6815">int player::has_claws(bool allow_tran) const</a>
<a name="ln6816">{</a>
<a name="ln6817">    if (allow_tran)</a>
<a name="ln6818">    {</a>
<a name="ln6819">        // these transformations bring claws with them</a>
<a name="ln6820">        if (form == transformation::dragon)</a>
<a name="ln6821">            return 3;</a>
<a name="ln6822"> </a>
<a name="ln6823">        // blade hands override claws</a>
<a name="ln6824">        if (form == transformation::blade_hands)</a>
<a name="ln6825">            return 0;</a>
<a name="ln6826">    }</a>
<a name="ln6827"> </a>
<a name="ln6828">    return get_mutation_level(MUT_CLAWS, allow_tran);</a>
<a name="ln6829">}</a>
<a name="ln6830"> </a>
<a name="ln6831">bool player::has_usable_claws(bool allow_tran) const</a>
<a name="ln6832">{</a>
<a name="ln6833">    return !slot_item(EQ_GLOVES) &amp;&amp; has_claws(allow_tran);</a>
<a name="ln6834">}</a>
<a name="ln6835"> </a>
<a name="ln6836">int player::has_talons(bool allow_tran) const</a>
<a name="ln6837">{</a>
<a name="ln6838">    // XXX: Do merfolk in water belong under allow_tran?</a>
<a name="ln6839">    if (fishtail)</a>
<a name="ln6840">        return 0;</a>
<a name="ln6841"> </a>
<a name="ln6842">    return get_mutation_level(MUT_TALONS, allow_tran);</a>
<a name="ln6843">}</a>
<a name="ln6844"> </a>
<a name="ln6845">bool player::has_usable_talons(bool allow_tran) const</a>
<a name="ln6846">{</a>
<a name="ln6847">    return !slot_item(EQ_BOOTS) &amp;&amp; has_talons(allow_tran);</a>
<a name="ln6848">}</a>
<a name="ln6849"> </a>
<a name="ln6850">int player::has_hooves(bool allow_tran) const</a>
<a name="ln6851">{</a>
<a name="ln6852">    // XXX: Do merfolk in water belong under allow_tran?</a>
<a name="ln6853">    if (fishtail)</a>
<a name="ln6854">        return 0;</a>
<a name="ln6855"> </a>
<a name="ln6856">    return get_mutation_level(MUT_HOOVES, allow_tran);</a>
<a name="ln6857">}</a>
<a name="ln6858"> </a>
<a name="ln6859">bool player::has_usable_hooves(bool allow_tran) const</a>
<a name="ln6860">{</a>
<a name="ln6861">    return has_hooves(allow_tran)</a>
<a name="ln6862">           &amp;&amp; (!slot_item(EQ_BOOTS)</a>
<a name="ln6863">               || wearing(EQ_BOOTS, ARM_CENTAUR_BARDING, true));</a>
<a name="ln6864">}</a>
<a name="ln6865"> </a>
<a name="ln6866">int player::has_fangs(bool allow_tran) const</a>
<a name="ln6867">{</a>
<a name="ln6868">    if (allow_tran)</a>
<a name="ln6869">    {</a>
<a name="ln6870">        // these transformations bring fangs with them</a>
<a name="ln6871">        if (form == transformation::dragon)</a>
<a name="ln6872">            return 3;</a>
<a name="ln6873">    }</a>
<a name="ln6874"> </a>
<a name="ln6875">    return get_mutation_level(MUT_FANGS, allow_tran);</a>
<a name="ln6876">}</a>
<a name="ln6877"> </a>
<a name="ln6878">int player::has_usable_fangs(bool allow_tran) const</a>
<a name="ln6879">{</a>
<a name="ln6880">    return has_fangs(allow_tran);</a>
<a name="ln6881">}</a>
<a name="ln6882"> </a>
<a name="ln6883">int player::has_tail(bool allow_tran) const</a>
<a name="ln6884">{</a>
<a name="ln6885">    if (allow_tran)</a>
<a name="ln6886">    {</a>
<a name="ln6887">        // these transformations bring a tail with them</a>
<a name="ln6888">        if (form == transformation::dragon)</a>
<a name="ln6889">            return 1;</a>
<a name="ln6890"> </a>
<a name="ln6891">        // Most transformations suppress a tail.</a>
<a name="ln6892">        if (!form_keeps_mutations())</a>
<a name="ln6893">            return 0;</a>
<a name="ln6894">    }</a>
<a name="ln6895"> </a>
<a name="ln6896">    // XXX: Do merfolk in water belong under allow_tran?</a>
<a name="ln6897">    if (species_is_draconian(species)</a>
<a name="ln6898">        || fishtail</a>
<a name="ln6899">        || get_mutation_level(MUT_STINGER, allow_tran))</a>
<a name="ln6900">    {</a>
<a name="ln6901">        return 1;</a>
<a name="ln6902">    }</a>
<a name="ln6903"> </a>
<a name="ln6904">    return 0;</a>
<a name="ln6905">}</a>
<a name="ln6906"> </a>
<a name="ln6907">int player::has_usable_tail(bool allow_tran) const</a>
<a name="ln6908">{</a>
<a name="ln6909">    return has_tail(allow_tran);</a>
<a name="ln6910">}</a>
<a name="ln6911"> </a>
<a name="ln6912">// Whether the player has a usable offhand for the</a>
<a name="ln6913">// purpose of punching.</a>
<a name="ln6914">bool player::has_usable_offhand() const</a>
<a name="ln6915">{</a>
<a name="ln6916">    if (get_mutation_level(MUT_MISSING_HAND))</a>
<a name="ln6917">        return false;</a>
<a name="ln6918">    if (shield())</a>
<a name="ln6919">        return false;</a>
<a name="ln6920"> </a>
<a name="ln6921">    const item_def* wp = slot_item(EQ_WEAPON);</a>
<a name="ln6922">    return !wp || hands_reqd(*wp) != HANDS_TWO;</a>
<a name="ln6923">}</a>
<a name="ln6924"> </a>
<a name="ln6925">bool player::has_usable_tentacle() const</a>
<a name="ln6926">{</a>
<a name="ln6927">    return usable_tentacles();</a>
<a name="ln6928">}</a>
<a name="ln6929"> </a>
<a name="ln6930">int player::usable_tentacles() const</a>
<a name="ln6931">{</a>
<a name="ln6932">    int numtentacle = has_usable_tentacles();</a>
<a name="ln6933"> </a>
<a name="ln6934">    if (numtentacle == 0)</a>
<a name="ln6935">        return false;</a>
<a name="ln6936"> </a>
<a name="ln6937">    int free_tentacles = numtentacle - num_constricting();</a>
<a name="ln6938"> </a>
<a name="ln6939">    if (shield())</a>
<a name="ln6940">        free_tentacles -= 2;</a>
<a name="ln6941"> </a>
<a name="ln6942">    const item_def* wp = slot_item(EQ_WEAPON);</a>
<a name="ln6943">    if (wp)</a>
<a name="ln6944">    {</a>
<a name="ln6945">        hands_reqd_type hands_req = hands_reqd(*wp);</a>
<a name="ln6946">        free_tentacles -= 2 * hands_req + 2;</a>
<a name="ln6947">    }</a>
<a name="ln6948"> </a>
<a name="ln6949">    return free_tentacles;</a>
<a name="ln6950">}</a>
<a name="ln6951"> </a>
<a name="ln6952">int player::has_pseudopods(bool allow_tran) const</a>
<a name="ln6953">{</a>
<a name="ln6954">    return get_mutation_level(MUT_PSEUDOPODS, allow_tran);</a>
<a name="ln6955">}</a>
<a name="ln6956"> </a>
<a name="ln6957">int player::has_usable_pseudopods(bool allow_tran) const</a>
<a name="ln6958">{</a>
<a name="ln6959">    return has_pseudopods(allow_tran);</a>
<a name="ln6960">}</a>
<a name="ln6961"> </a>
<a name="ln6962">int player::has_tentacles(bool allow_tran) const</a>
<a name="ln6963">{</a>
<a name="ln6964">    if (allow_tran)</a>
<a name="ln6965">    {</a>
<a name="ln6966">        // Most transformations suppress tentacles.</a>
<a name="ln6967">        if (!form_keeps_mutations())</a>
<a name="ln6968">            return 0;</a>
<a name="ln6969">    }</a>
<a name="ln6970"> </a>
<a name="ln6971">    if (species == SP_OCTOPODE &amp;&amp; get_mutation_level(MUT_MISSING_HAND))</a>
<a name="ln6972">        return 7;</a>
<a name="ln6973">    else if (species == SP_OCTOPODE)</a>
<a name="ln6974">        return 8;</a>
<a name="ln6975"> </a>
<a name="ln6976">    return 0;</a>
<a name="ln6977">}</a>
<a name="ln6978"> </a>
<a name="ln6979">int player::has_usable_tentacles(bool allow_tran) const</a>
<a name="ln6980">{</a>
<a name="ln6981">    return has_tentacles(allow_tran);</a>
<a name="ln6982">}</a>
<a name="ln6983"> </a>
<a name="ln6984">bool player::sicken(int amount)</a>
<a name="ln6985">{</a>
<a name="ln6986">    ASSERT(!crawl_state.game_is_arena());</a>
<a name="ln6987"> </a>
<a name="ln6988">    if (res_rotting() || amount &lt;= 0)</a>
<a name="ln6989">        return false;</a>
<a name="ln6990"> </a>
<a name="ln6991">    if (duration[DUR_DIVINE_STAMINA] &gt; 0)</a>
<a name="ln6992">    {</a>
<a name="ln6993">        mpr(&quot;Your divine stamina protects you from disease!&quot;);</a>
<a name="ln6994">        return false;</a>
<a name="ln6995">    }</a>
<a name="ln6996"> </a>
<a name="ln6997">    mpr(&quot;You feel ill.&quot;);</a>
<a name="ln6998"> </a>
<a name="ln6999">    disease += amount * BASELINE_DELAY;</a>
<a name="ln7000">    if (disease &gt; 210 * BASELINE_DELAY)</a>
<a name="ln7001">        disease = 210 * BASELINE_DELAY;</a>
<a name="ln7002"> </a>
<a name="ln7003">    return true;</a>
<a name="ln7004">}</a>
<a name="ln7005"> </a>
<a name="ln7006">/// Can the player see invisible things?</a>
<a name="ln7007">bool player::can_see_invisible(bool calc_unid) const</a>
<a name="ln7008">{</a>
<a name="ln7009">    if (crawl_state.game_is_arena())</a>
<a name="ln7010">        return true;</a>
<a name="ln7011"> </a>
<a name="ln7012">    if (wearing(EQ_RINGS, RING_SEE_INVISIBLE, calc_unid)</a>
<a name="ln7013">        // armour: (checks head armour only)</a>
<a name="ln7014">        || wearing_ego(EQ_HELMET, SPARM_SEE_INVISIBLE)</a>
<a name="ln7015">        // randart gear</a>
<a name="ln7016">        || scan_artefacts(ARTP_SEE_INVISIBLE, calc_unid) &gt; 0)</a>
<a name="ln7017">    {</a>
<a name="ln7018">        return true;</a>
<a name="ln7019">    }</a>
<a name="ln7020"> </a>
<a name="ln7021">    return innate_sinv();</a>
<a name="ln7022">}</a>
<a name="ln7023"> </a>
<a name="ln7024">/// Can the player see invisible things without needing items' help?</a>
<a name="ln7025">bool player::innate_sinv() const</a>
<a name="ln7026">{</a>
<a name="ln7027">    // Possible to have both with a temp mutation.</a>
<a name="ln7028">    if (has_mutation(MUT_ACUTE_VISION)</a>
<a name="ln7029">        &amp;&amp; !has_mutation(MUT_BLURRY_VISION))</a>
<a name="ln7030">    {</a>
<a name="ln7031">        return true;</a>
<a name="ln7032">    }</a>
<a name="ln7033"> </a>
<a name="ln7034">    // antennae give sInvis at 3</a>
<a name="ln7035">    if (get_mutation_level(MUT_ANTENNAE) == 3)</a>
<a name="ln7036">        return true;</a>
<a name="ln7037"> </a>
<a name="ln7038">    if (get_mutation_level(MUT_EYEBALLS) == 3)</a>
<a name="ln7039">        return true;</a>
<a name="ln7040"> </a>
<a name="ln7041">    if (have_passive(passive_t::sinv))</a>
<a name="ln7042">        return true;</a>
<a name="ln7043"> </a>
<a name="ln7044">    return false;</a>
<a name="ln7045">}</a>
<a name="ln7046"> </a>
<a name="ln7047">bool player::invisible() const</a>
<a name="ln7048">{</a>
<a name="ln7049">    return (duration[DUR_INVIS] || form == transformation::shadow)</a>
<a name="ln7050">           &amp;&amp; !backlit();</a>
<a name="ln7051">}</a>
<a name="ln7052"> </a>
<a name="ln7053">bool player::visible_to(const actor *looker) const</a>
<a name="ln7054">{</a>
<a name="ln7055">    if (crawl_state.game_is_arena())</a>
<a name="ln7056">        return false;</a>
<a name="ln7057"> </a>
<a name="ln7058">    const bool invis_to = invisible() &amp;&amp; !looker-&gt;can_see_invisible()</a>
<a name="ln7059">                          &amp;&amp; !in_water();</a>
<a name="ln7060">    if (this == looker)</a>
<a name="ln7061">        return !invis_to;</a>
<a name="ln7062"> </a>
<a name="ln7063">    const monster* mon = looker-&gt;as_monster();</a>
<a name="ln7064">    return mon-&gt;friendly()</a>
<a name="ln7065">        || (!mon-&gt;has_ench(ENCH_BLIND) &amp;&amp; !invis_to);</a>
<a name="ln7066">}</a>
<a name="ln7067"> </a>
<a name="ln7068">/**</a>
<a name="ln7069"> * Is the player backlit?</a>
<a name="ln7070"> *</a>
<a name="ln7071"> * @param self_halo If true, ignore the player's self-halo.</a>
<a name="ln7072"> * @returns True if the player is backlit.</a>
<a name="ln7073">*/</a>
<a name="ln7074">bool player::backlit(bool self_halo) const</a>
<a name="ln7075">{</a>
<a name="ln7076">    return player_severe_contamination()</a>
<a name="ln7077">           || duration[DUR_CORONA]</a>
<a name="ln7078">           || duration[DUR_LIQUID_FLAMES]</a>
<a name="ln7079">           || duration[DUR_QUAD_DAMAGE]</a>
<a name="ln7080">           || !umbraed() &amp;&amp; haloed() &amp;&amp; (self_halo || halo_radius() == -1);</a>
<a name="ln7081">}</a>
<a name="ln7082"> </a>
<a name="ln7083">bool player::umbra() const</a>
<a name="ln7084">{</a>
<a name="ln7085">    return !backlit() &amp;&amp; umbraed() &amp;&amp; !haloed();</a>
<a name="ln7086">}</a>
<a name="ln7087"> </a>
<a name="ln7088">// This is the imperative version.</a>
<a name="ln7089">void player::backlight()</a>
<a name="ln7090">{</a>
<a name="ln7091">    if (!duration[DUR_INVIS] &amp;&amp; form != transformation::shadow)</a>
<a name="ln7092">    {</a>
<a name="ln7093">        if (duration[DUR_CORONA])</a>
<a name="ln7094">            mpr(&quot;You glow brighter.&quot;);</a>
<a name="ln7095">        else</a>
<a name="ln7096">            mpr(&quot;You are outlined in light.&quot;);</a>
<a name="ln7097">        increase_duration(DUR_CORONA, random_range(15, 35), 250);</a>
<a name="ln7098">    }</a>
<a name="ln7099">    else</a>
<a name="ln7100">    {</a>
<a name="ln7101">        mpr(&quot;You feel strangely conspicuous.&quot;);</a>
<a name="ln7102">        increase_duration(DUR_CORONA, random_range(3, 5), 250);</a>
<a name="ln7103">    }</a>
<a name="ln7104">}</a>
<a name="ln7105"> </a>
<a name="ln7106">bool player::can_mutate() const</a>
<a name="ln7107">{</a>
<a name="ln7108">    return true;</a>
<a name="ln7109">}</a>
<a name="ln7110"> </a>
<a name="ln7111">/**</a>
<a name="ln7112"> * Can the player be mutated without rotting instead?</a>
<a name="ln7113"> *</a>
<a name="ln7114"> * @param temp      Whether to consider temporary modifiers (lichform)</a>
<a name="ln7115"> * @return Whether the player will mutate when mutated, instead of rotting.</a>
<a name="ln7116"> */</a>
<a name="ln7117">bool player::can_safely_mutate(bool temp) const</a>
<a name="ln7118">{</a>
<a name="ln7119">    if (!can_mutate())</a>
<a name="ln7120">        return false;</a>
<a name="ln7121"> </a>
<a name="ln7122">    return undead_state(temp) == US_ALIVE</a>
<a name="ln7123">           || undead_state(temp) == US_SEMI_UNDEAD;</a>
<a name="ln7124">}</a>
<a name="ln7125"> </a>
<a name="ln7126">// Is the player too undead to bleed, rage, or polymorph?</a>
<a name="ln7127">bool player::is_lifeless_undead(bool temp) const</a>
<a name="ln7128">{</a>
<a name="ln7129">    if (undead_state() == US_SEMI_UNDEAD)</a>
<a name="ln7130">        return temp ? !you.vampire_alive : false;</a>
<a name="ln7131">    else</a>
<a name="ln7132">        return undead_state(temp) != US_ALIVE;</a>
<a name="ln7133">}</a>
<a name="ln7134"> </a>
<a name="ln7135">bool player::can_polymorph() const</a>
<a name="ln7136">{</a>
<a name="ln7137">    return !(transform_uncancellable || is_lifeless_undead());</a>
<a name="ln7138">}</a>
<a name="ln7139"> </a>
<a name="ln7140">bool player::can_bleed(bool allow_tran) const</a>
<a name="ln7141">{</a>
<a name="ln7142">    // XXX: Lich and statue forms are still caught by the holiness checks below.</a>
<a name="ln7143">    if (allow_tran &amp;&amp; !form_can_bleed(form))</a>
<a name="ln7144">        return false;</a>
<a name="ln7145"> </a>
<a name="ln7146">    if (is_lifeless_undead() || is_nonliving())</a>
<a name="ln7147">    {   // demonspawn and demigods have a mere drop of taint</a>
<a name="ln7148">        return false;</a>
<a name="ln7149">    }</a>
<a name="ln7150"> </a>
<a name="ln7151">    return true;</a>
<a name="ln7152">}</a>
<a name="ln7153"> </a>
<a name="ln7154">bool player::is_stationary() const</a>
<a name="ln7155">{</a>
<a name="ln7156">    return form == transformation::tree;</a>
<a name="ln7157">}</a>
<a name="ln7158"> </a>
<a name="ln7159">bool player::malmutate(const string &amp;reason)</a>
<a name="ln7160">{</a>
<a name="ln7161">    ASSERT(!crawl_state.game_is_arena());</a>
<a name="ln7162"> </a>
<a name="ln7163">    if (!can_mutate())</a>
<a name="ln7164">        return false;</a>
<a name="ln7165"> </a>
<a name="ln7166">    const mutation_type mut_quality = one_chance_in(5) ? RANDOM_MUTATION</a>
<a name="ln7167">                                                       : RANDOM_BAD_MUTATION;</a>
<a name="ln7168">    if (mutate(mut_quality, reason))</a>
<a name="ln7169">    {</a>
<a name="ln7170">        learned_something_new(HINT_YOU_MUTATED);</a>
<a name="ln7171">        return true;</a>
<a name="ln7172">    }</a>
<a name="ln7173">    return false;</a>
<a name="ln7174">}</a>
<a name="ln7175"> </a>
<a name="ln7176">bool player::polymorph(int pow, bool allow_immobile)</a>
<a name="ln7177">{</a>
<a name="ln7178">    ASSERT(!crawl_state.game_is_arena());</a>
<a name="ln7179"> </a>
<a name="ln7180">    if (!can_polymorph())</a>
<a name="ln7181">        return false;</a>
<a name="ln7182"> </a>
<a name="ln7183">    transformation f = transformation::none;</a>
<a name="ln7184"> </a>
<a name="ln7185">    vector&lt;transformation&gt; forms = {</a>
<a name="ln7186">        transformation::bat,</a>
<a name="ln7187">        transformation::wisp,</a>
<a name="ln7188">        transformation::pig,</a>
<a name="ln7189">    };</a>
<a name="ln7190">    if (allow_immobile)</a>
<a name="ln7191">    {</a>
<a name="ln7192">        forms.emplace_back(transformation::tree);</a>
<a name="ln7193">        forms.emplace_back(transformation::fungus);</a>
<a name="ln7194">    }</a>
<a name="ln7195"> </a>
<a name="ln7196">    for (int tries = 0; tries &lt; 3; tries++)</a>
<a name="ln7197">    {</a>
<a name="ln7198">        f = forms[random2(forms.size())];</a>
<a name="ln7199"> </a>
<a name="ln7200">        // need to do a dry run first, as Zin's protection has a random factor</a>
<a name="ln7201">        if (transform(pow, f, true, true))</a>
<a name="ln7202">            break;</a>
<a name="ln7203"> </a>
<a name="ln7204">        f = transformation::none;</a>
<a name="ln7205">    }</a>
<a name="ln7206"> </a>
<a name="ln7207">    if (f != transformation::none &amp;&amp; transform(pow, f))</a>
<a name="ln7208">    {</a>
<a name="ln7209">        transform_uncancellable = true;</a>
<a name="ln7210">        return true;</a>
<a name="ln7211">    }</a>
<a name="ln7212">    return false;</a>
<a name="ln7213">}</a>
<a name="ln7214"> </a>
<a name="ln7215">bool player::is_icy() const</a>
<a name="ln7216">{</a>
<a name="ln7217">    return form == transformation::ice_beast;</a>
<a name="ln7218">}</a>
<a name="ln7219"> </a>
<a name="ln7220">bool player::is_fiery() const</a>
<a name="ln7221">{</a>
<a name="ln7222">    return false;</a>
<a name="ln7223">}</a>
<a name="ln7224"> </a>
<a name="ln7225">bool player::is_skeletal() const</a>
<a name="ln7226">{</a>
<a name="ln7227">    return false;</a>
<a name="ln7228">}</a>
<a name="ln7229"> </a>
<a name="ln7230">void player::shiftto(const coord_def &amp;c)</a>
<a name="ln7231">{</a>
<a name="ln7232">    crawl_view.shift_player_to(c);</a>
<a name="ln7233">    set_position(c);</a>
<a name="ln7234">    clear_invalid_constrictions();</a>
<a name="ln7235">}</a>
<a name="ln7236"> </a>
<a name="ln7237">bool player::asleep() const</a>
<a name="ln7238">{</a>
<a name="ln7239">    return duration[DUR_SLEEP];</a>
<a name="ln7240">}</a>
<a name="ln7241"> </a>
<a name="ln7242">bool player::cannot_act() const</a>
<a name="ln7243">{</a>
<a name="ln7244">    return asleep() || cannot_move();</a>
<a name="ln7245">}</a>
<a name="ln7246"> </a>
<a name="ln7247">bool player::can_throw_large_rocks() const</a>
<a name="ln7248">{</a>
<a name="ln7249">    return species_can_throw_large_rocks(species);</a>
<a name="ln7250">}</a>
<a name="ln7251"> </a>
<a name="ln7252">bool player::can_smell() const</a>
<a name="ln7253">{</a>
<a name="ln7254">    return species != SP_MUMMY;</a>
<a name="ln7255">}</a>
<a name="ln7256"> </a>
<a name="ln7257">bool player::can_sleep(bool holi_only) const</a>
<a name="ln7258">{</a>
<a name="ln7259">    return !you.duration[DUR_SLEEP_IMMUNITY] &amp;&amp; actor::can_sleep(holi_only);</a>
<a name="ln7260">}</a>
<a name="ln7261"> </a>
<a name="ln7262">/**</a>
<a name="ln7263"> * Attempts to put the player to sleep.</a>
<a name="ln7264"> *</a>
<a name="ln7265"> * @param power     The power of the effect putting the player to sleep.</a>
<a name="ln7266"> * @param hibernate Whether the player is being put to sleep by 'ensorcelled</a>
<a name="ln7267"> *                  hibernation' (doesn't affect characters with rC, ignores</a>
<a name="ln7268"> *                  power), or by a normal sleep effect.</a>
<a name="ln7269"> */</a>
<a name="ln7270">void player::put_to_sleep(actor*, int power, bool hibernate)</a>
<a name="ln7271">{</a>
<a name="ln7272">    ASSERT(!crawl_state.game_is_arena());</a>
<a name="ln7273"> </a>
<a name="ln7274">    const bool valid_target = hibernate ? can_hibernate() : can_sleep();</a>
<a name="ln7275">    if (!valid_target)</a>
<a name="ln7276">    {</a>
<a name="ln7277">        canned_msg(MSG_YOU_UNAFFECTED);</a>
<a name="ln7278">        return;</a>
<a name="ln7279">    }</a>
<a name="ln7280"> </a>
<a name="ln7281">    if (duration[DUR_SLEEP_IMMUNITY])</a>
<a name="ln7282">    {</a>
<a name="ln7283">        mpr(&quot;You can't fall asleep again this soon!&quot;);</a>
<a name="ln7284">        return;</a>
<a name="ln7285">    }</a>
<a name="ln7286"> </a>
<a name="ln7287">    if (duration[DUR_PARALYSIS]</a>
<a name="ln7288">        || duration[DUR_PETRIFIED]</a>
<a name="ln7289">        || duration[DUR_PETRIFYING])</a>
<a name="ln7290">    {</a>
<a name="ln7291">        mpr(&quot;You can't fall asleep in your current state!&quot;);</a>
<a name="ln7292">        return;</a>
<a name="ln7293">    }</a>
<a name="ln7294"> </a>
<a name="ln7295">    mpr(&quot;You fall asleep.&quot;);</a>
<a name="ln7296"> </a>
<a name="ln7297">    stop_directly_constricting_all(false);</a>
<a name="ln7298">    end_searing_ray();</a>
<a name="ln7299">    stop_delay();</a>
<a name="ln7300">    flash_view(UA_MONSTER, DARKGREY);</a>
<a name="ln7301"> </a>
<a name="ln7302">    // As above, do this after redraw.</a>
<a name="ln7303">    const int dur = hibernate ? 3 + random2avg(5, 2) :</a>
<a name="ln7304">                                5 + random2avg(power/10, 5);</a>
<a name="ln7305">    set_duration(DUR_SLEEP, dur);</a>
<a name="ln7306">}</a>
<a name="ln7307"> </a>
<a name="ln7308">void player::awaken()</a>
<a name="ln7309">{</a>
<a name="ln7310">    ASSERT(!crawl_state.game_is_arena());</a>
<a name="ln7311"> </a>
<a name="ln7312">    duration[DUR_SLEEP] = 0;</a>
<a name="ln7313">    set_duration(DUR_SLEEP_IMMUNITY, random_range(3, 5));</a>
<a name="ln7314">    mpr(&quot;You wake up.&quot;);</a>
<a name="ln7315">    flash_view(UA_MONSTER, BLACK);</a>
<a name="ln7316">}</a>
<a name="ln7317"> </a>
<a name="ln7318">void player::check_awaken(int disturbance)</a>
<a name="ln7319">{</a>
<a name="ln7320">    if (asleep() &amp;&amp; x_chance_in_y(disturbance + 1, 50))</a>
<a name="ln7321">    {</a>
<a name="ln7322">        awaken();</a>
<a name="ln7323">        dprf(&quot;Disturbance of intensity %d awoke player&quot;, disturbance);</a>
<a name="ln7324">    }</a>
<a name="ln7325">}</a>
<a name="ln7326"> </a>
<a name="ln7327">int player::beam_resists(bolt &amp;beam, int hurted, bool doEffects, string source)</a>
<a name="ln7328">{</a>
<a name="ln7329">    return check_your_resists(hurted, beam.flavour, source, &amp;beam, doEffects);</a>
<a name="ln7330">}</a>
<a name="ln7331"> </a>
<a name="ln7332">// Used for falling into traps and other bad effects, but is a slightly</a>
<a name="ln7333">// different effect from the player invokable ability.</a>
<a name="ln7334">bool player::do_shaft()</a>
<a name="ln7335">{</a>
<a name="ln7336">    if (!is_valid_shaft_level()</a>
<a name="ln7337">        || !feat_is_shaftable(grd(pos()))</a>
<a name="ln7338">        || duration[DUR_SHAFT_IMMUNITY])</a>
<a name="ln7339">    {</a>
<a name="ln7340">        return false;</a>
<a name="ln7341">    }</a>
<a name="ln7342"> </a>
<a name="ln7343">    // Ensure altars, items, and shops discovered at the moment</a>
<a name="ln7344">    // the player gets shafted are correctly registered.</a>
<a name="ln7345">    maybe_update_stashes();</a>
<a name="ln7346"> </a>
<a name="ln7347">    duration[DUR_SHAFT_IMMUNITY] = 1;</a>
<a name="ln7348">    down_stairs(DNGN_TRAP_SHAFT);</a>
<a name="ln7349"> </a>
<a name="ln7350">    return true;</a>
<a name="ln7351">}</a>
<a name="ln7352"> </a>
<a name="ln7353">bool player::can_do_shaft_ability(bool quiet) const</a>
<a name="ln7354">{</a>
<a name="ln7355">    if (attribute[ATTR_HELD])</a>
<a name="ln7356">    {</a>
<a name="ln7357">        if (!quiet)</a>
<a name="ln7358">            mprf(&quot;You can't shaft yourself while %s.&quot;, held_status());</a>
<a name="ln7359">        return false;</a>
<a name="ln7360">    }</a>
<a name="ln7361"> </a>
<a name="ln7362">    if (feat_is_shaftable(grd(pos())))</a>
<a name="ln7363">    {</a>
<a name="ln7364">        if (!is_valid_shaft_level())</a>
<a name="ln7365">        {</a>
<a name="ln7366">            if (!quiet)</a>
<a name="ln7367">                mpr(&quot;You can't shaft yourself on this level.&quot;);</a>
<a name="ln7368">            return false;</a>
<a name="ln7369">        }</a>
<a name="ln7370">    }</a>
<a name="ln7371">    else</a>
<a name="ln7372">    {</a>
<a name="ln7373">        if (!quiet)</a>
<a name="ln7374">            mpr(&quot;You can't shaft yourself on this terrain.&quot;);</a>
<a name="ln7375">        return false;</a>
<a name="ln7376">    }</a>
<a name="ln7377"> </a>
<a name="ln7378">    return true;</a>
<a name="ln7379">}</a>
<a name="ln7380"> </a>
<a name="ln7381">// Like do_shaft, but forced by the player.</a>
<a name="ln7382">// It has a slightly different set of rules.</a>
<a name="ln7383">bool player::do_shaft_ability()</a>
<a name="ln7384">{</a>
<a name="ln7385">    if (can_do_shaft_ability(true))</a>
<a name="ln7386">    {</a>
<a name="ln7387">        mpr(&quot;A shaft appears beneath you!&quot;);</a>
<a name="ln7388">        down_stairs(DNGN_TRAP_SHAFT, true);</a>
<a name="ln7389">        return true;</a>
<a name="ln7390">    }</a>
<a name="ln7391">    else</a>
<a name="ln7392">    {</a>
<a name="ln7393">        canned_msg(MSG_NOTHING_HAPPENS);</a>
<a name="ln7394">        redraw_screen();</a>
<a name="ln7395">        return false;</a>
<a name="ln7396">    }</a>
<a name="ln7397">}</a>
<a name="ln7398"> </a>
<a name="ln7399">bool player::did_escape_death() const</a>
<a name="ln7400">{</a>
<a name="ln7401">    return escaped_death_cause != NUM_KILLBY;</a>
<a name="ln7402">}</a>
<a name="ln7403"> </a>
<a name="ln7404">void player::reset_escaped_death()</a>
<a name="ln7405">{</a>
<a name="ln7406">    escaped_death_cause = NUM_KILLBY;</a>
<a name="ln7407">    escaped_death_aux   = &quot;&quot;;</a>
<a name="ln7408">}</a>
<a name="ln7409"> </a>
<a name="ln7410">void player::add_gold(int delta)</a>
<a name="ln7411">{</a>
<a name="ln7412">    set_gold(gold + delta);</a>
<a name="ln7413">}</a>
<a name="ln7414"> </a>
<a name="ln7415">void player::del_gold(int delta)</a>
<a name="ln7416">{</a>
<a name="ln7417">    set_gold(gold - delta);</a>
<a name="ln7418">}</a>
<a name="ln7419"> </a>
<a name="ln7420">void player::set_gold(int amount)</a>
<a name="ln7421">{</a>
<a name="ln7422">    ASSERT(amount &gt;= 0);</a>
<a name="ln7423"> </a>
<a name="ln7424">    if (amount != gold)</a>
<a name="ln7425">    {</a>
<a name="ln7426">        const int old_gold = gold;</a>
<a name="ln7427">        gold = amount;</a>
<a name="ln7428">        shopping_list.gold_changed(old_gold, gold);</a>
<a name="ln7429"> </a>
<a name="ln7430">        // XXX: this might benefit from being in its own function</a>
<a name="ln7431">        if (you_worship(GOD_GOZAG))</a>
<a name="ln7432">        {</a>
<a name="ln7433">            for (const auto&amp; power : get_god_powers(you.religion))</a>
<a name="ln7434">            {</a>
<a name="ln7435">                const int cost = get_gold_cost(power.abil);</a>
<a name="ln7436">                if (gold &gt;= cost &amp;&amp; old_gold &lt; cost)</a>
<a name="ln7437">                    power.display(true, &quot;You now have enough gold to %s.&quot;);</a>
<a name="ln7438">                else if (old_gold &gt;= cost &amp;&amp; gold &lt; cost)</a>
<a name="ln7439">                    power.display(false, &quot;You no longer have enough gold to %s.&quot;);</a>
<a name="ln7440">            }</a>
<a name="ln7441">            you.redraw_title = true;</a>
<a name="ln7442">        }</a>
<a name="ln7443">    }</a>
<a name="ln7444">}</a>
<a name="ln7445"> </a>
<a name="ln7446">void player::increase_duration(duration_type dur, int turns, int cap,</a>
<a name="ln7447">                               const char* msg)</a>
<a name="ln7448">{</a>
<a name="ln7449">    if (msg)</a>
<a name="ln7450">        mpr(msg);</a>
<a name="ln7451">    cap *= BASELINE_DELAY;</a>
<a name="ln7452"> </a>
<a name="ln7453">    duration[dur] += turns * BASELINE_DELAY;</a>
<a name="ln7454">    if (cap &amp;&amp; duration[dur] &gt; cap)</a>
<a name="ln7455">        duration[dur] = cap;</a>
<a name="ln7456">}</a>
<a name="ln7457"> </a>
<a name="ln7458">void player::set_duration(duration_type dur, int turns,</a>
<a name="ln7459">                          int cap, const char * msg)</a>
<a name="ln7460">{</a>
<a name="ln7461">    duration[dur] = 0;</a>
<a name="ln7462">    increase_duration(dur, turns, cap, msg);</a>
<a name="ln7463">}</a>
<a name="ln7464"> </a>
<a name="ln7465">void player::goto_place(const level_id &amp;lid)</a>
<a name="ln7466">{</a>
<a name="ln7467">    where_are_you = static_cast&lt;branch_type&gt;(lid.branch);</a>
<a name="ln7468">    depth = lid.depth;</a>
<a name="ln7469">    ASSERT_RANGE(depth, 1, brdepth[where_are_you] + 1);</a>
<a name="ln7470">}</a>
<a name="ln7471"> </a>
<a name="ln7472">bool player::attempt_escape(int attempts)</a>
<a name="ln7473">{</a>
<a name="ln7474">    monster *themonst;</a>
<a name="ln7475"> </a>
<a name="ln7476">    if (!is_constricted())</a>
<a name="ln7477">        return true;</a>
<a name="ln7478"> </a>
<a name="ln7479">    themonst = monster_by_mid(constricted_by);</a>
<a name="ln7480">    ASSERT(themonst);</a>
<a name="ln7481">    escape_attempts += attempts;</a>
<a name="ln7482"> </a>
<a name="ln7483">    const bool direct = is_directly_constricted();</a>
<a name="ln7484">    const string object = direct ? themonst-&gt;name(DESC_ITS, true)</a>
<a name="ln7485">                                 : &quot;the roots'&quot;;</a>
<a name="ln7486">    // player breaks free if (4+n)d13 &gt;= 5d(8+HD/4)</a>
<a name="ln7487">    const int escape_score = roll_dice(4 + escape_attempts, 13);</a>
<a name="ln7488">    if (escape_score</a>
<a name="ln7489">        &gt;= roll_dice(5, 8 + div_rand_round(themonst-&gt;get_hit_dice(), 4)))</a>
<a name="ln7490">    {</a>
<a name="ln7491">        mprf(&quot;You escape %s grasp.&quot;, object.c_str());</a>
<a name="ln7492"> </a>
<a name="ln7493">        // Stun the monster to prevent it from constricting again right away.</a>
<a name="ln7494">        if (direct)</a>
<a name="ln7495">            themonst-&gt;speed_increment -= 5;</a>
<a name="ln7496"> </a>
<a name="ln7497">        stop_being_constricted(true);</a>
<a name="ln7498"> </a>
<a name="ln7499">        return true;</a>
<a name="ln7500">    }</a>
<a name="ln7501">    else</a>
<a name="ln7502">    {</a>
<a name="ln7503">        mprf(&quot;%s grasp on you weakens, but your attempt to escape fails.&quot;,</a>
<a name="ln7504">             object.c_str());</a>
<a name="ln7505">        turn_is_over = true;</a>
<a name="ln7506">        return false;</a>
<a name="ln7507">    }</a>
<a name="ln7508">}</a>
<a name="ln7509"> </a>
<a name="ln7510">void player::sentinel_mark(bool trap)</a>
<a name="ln7511">{</a>
<a name="ln7512">    if (duration[DUR_SENTINEL_MARK])</a>
<a name="ln7513">    {</a>
<a name="ln7514">        mpr(&quot;The mark upon you grows brighter.&quot;);</a>
<a name="ln7515">        increase_duration(DUR_SENTINEL_MARK, random_range(20, 40), 180);</a>
<a name="ln7516">    }</a>
<a name="ln7517">    else</a>
<a name="ln7518">    {</a>
<a name="ln7519">        mprf(MSGCH_WARN, &quot;A sentinel's mark forms upon you.&quot;);</a>
<a name="ln7520">        increase_duration(DUR_SENTINEL_MARK, trap ? random_range(25, 40)</a>
<a name="ln7521">                                                  : random_range(35, 60),</a>
<a name="ln7522">                          250);</a>
<a name="ln7523">    }</a>
<a name="ln7524">}</a>
<a name="ln7525"> </a>
<a name="ln7526">/*</a>
<a name="ln7527"> * Is the player too terrified to move (because of fungusform)?</a>
<a name="ln7528"> *</a>
<a name="ln7529"> * @return true iff there is an alarming monster anywhere near a fungusform player.</a>
<a name="ln7530"> */</a>
<a name="ln7531">bool player::is_nervous()</a>
<a name="ln7532">{</a>
<a name="ln7533">    if (form != transformation::fungus)</a>
<a name="ln7534">        return false;</a>
<a name="ln7535">    for (monster_near_iterator mi(&amp;you); mi; ++mi)</a>
<a name="ln7536">    {</a>
<a name="ln7537">        if (made_nervous_by(*mi))</a>
<a name="ln7538">            return true;</a>
<a name="ln7539">    }</a>
<a name="ln7540">    return false;</a>
<a name="ln7541">}</a>
<a name="ln7542"> </a>
<a name="ln7543">/*</a>
<a name="ln7544"> * Does monster `mons` make the player nervous (in fungusform)?</a>
<a name="ln7545"> *</a>
<a name="ln7546"> * @param mons  the monster to check</a>
<a name="ln7547"> * @return      true iff mons is non-null, player is fungal, and `mons` is a threatening monster.</a>
<a name="ln7548"> */</a>
<a name="ln7549">bool player::made_nervous_by(const monster *mons)</a>
<a name="ln7550">{</a>
<a name="ln7551">    if (form != transformation::fungus)</a>
<a name="ln7552">        return false;</a>
<a name="ln7553">    if (!mons)</a>
<a name="ln7554">        return false;</a>
<a name="ln7555">    if (!mons_is_wandering(*mons)</a>
<a name="ln7556">        &amp;&amp; !mons-&gt;asleep()</a>
<a name="ln7557">        &amp;&amp; !mons-&gt;confused()</a>
<a name="ln7558">        &amp;&amp; !mons-&gt;cannot_act()</a>
<a name="ln7559">        &amp;&amp; mons_is_threatening(*mons)</a>
<a name="ln7560">        &amp;&amp; !mons-&gt;wont_attack()</a>
<a name="ln7561">        &amp;&amp; !mons-&gt;neutral())</a>
<a name="ln7562">    {</a>
<a name="ln7563">        return true;</a>
<a name="ln7564">    }</a>
<a name="ln7565">    return false;</a>
<a name="ln7566">}</a>
<a name="ln7567"> </a>
<a name="ln7568">void player::weaken(actor */*attacker*/, int pow)</a>
<a name="ln7569">{</a>
<a name="ln7570">    if (!duration[DUR_WEAK])</a>
<a name="ln7571">        mprf(MSGCH_WARN, &quot;You feel your attacks grow feeble.&quot;);</a>
<a name="ln7572">    else</a>
<a name="ln7573">        mprf(MSGCH_WARN, &quot;You feel as though you will be weak longer.&quot;);</a>
<a name="ln7574"> </a>
<a name="ln7575">    increase_duration(DUR_WEAK, pow + random2(pow + 3), 50);</a>
<a name="ln7576">}</a>
<a name="ln7577"> </a>
<a name="ln7578">/**</a>
<a name="ln7579"> * Check if the player is about to die from flight/form expiration.</a>
<a name="ln7580"> *</a>
<a name="ln7581"> * Check whether the player is on a cell which would be deadly if not for some</a>
<a name="ln7582"> * temporary condition, and if such condition is expiring. In that case, we</a>
<a name="ln7583"> * give a strong warning to the player. The actual message printing is done</a>
<a name="ln7584"> * by the caller.</a>
<a name="ln7585"> *</a>
<a name="ln7586"> * @param dur the duration to check for dangerous expiration.</a>
<a name="ln7587"> * @param p the coordinates of the cell to check. Defaults to player position.</a>
<a name="ln7588"> * @return whether the player is in immediate danger.</a>
<a name="ln7589"> */</a>
<a name="ln7590">bool need_expiration_warning(duration_type dur, dungeon_feature_type feat)</a>
<a name="ln7591">{</a>
<a name="ln7592">    if (!is_feat_dangerous(feat, true) || !dur_expiring(dur))</a>
<a name="ln7593">        return false;</a>
<a name="ln7594"> </a>
<a name="ln7595">    if (dur == DUR_FLIGHT)</a>
<a name="ln7596">        return true;</a>
<a name="ln7597">    else if (dur == DUR_TRANSFORMATION</a>
<a name="ln7598">             &amp;&amp; (form_can_swim()) || form_can_fly())</a>
<a name="ln7599">    {</a>
<a name="ln7600">        return true;</a>
<a name="ln7601">    }</a>
<a name="ln7602">    return false;</a>
<a name="ln7603">}</a>
<a name="ln7604"> </a>
<a name="ln7605">bool need_expiration_warning(duration_type dur, coord_def p)</a>
<a name="ln7606">{</a>
<a name="ln7607">    return need_expiration_warning(dur, env.grid(p));</a>
<a name="ln7608">}</a>
<a name="ln7609"> </a>
<a name="ln7610">bool need_expiration_warning(dungeon_feature_type feat)</a>
<a name="ln7611">{</a>
<a name="ln7612">    return need_expiration_warning(DUR_FLIGHT, feat)</a>
<a name="ln7613">           || need_expiration_warning(DUR_TRANSFORMATION, feat);</a>
<a name="ln7614">}</a>
<a name="ln7615"> </a>
<a name="ln7616">bool need_expiration_warning(coord_def p)</a>
<a name="ln7617">{</a>
<a name="ln7618">    return need_expiration_warning(env.grid(p));</a>
<a name="ln7619">}</a>
<a name="ln7620"> </a>
<a name="ln7621">static string _constriction_description()</a>
<a name="ln7622">{</a>
<a name="ln7623">    string cinfo = &quot;&quot;;</a>
<a name="ln7624">    vector&lt;string&gt; c_name;</a>
<a name="ln7625"> </a>
<a name="ln7626">    const int num_free_tentacles = you.usable_tentacles();</a>
<a name="ln7627">    if (num_free_tentacles)</a>
<a name="ln7628">    {</a>
<a name="ln7629">        cinfo += make_stringf(&quot;You have %d tentacle%s available for constriction.&quot;,</a>
<a name="ln7630">                              num_free_tentacles,</a>
<a name="ln7631">                              num_free_tentacles &gt; 1 ? &quot;s&quot; : &quot;&quot;);</a>
<a name="ln7632">    }</a>
<a name="ln7633"> </a>
<a name="ln7634">    if (you.is_directly_constricted())</a>
<a name="ln7635">    {</a>
<a name="ln7636">        const monster * const constrictor = monster_by_mid(you.constricted_by);</a>
<a name="ln7637">        ASSERT(constrictor);</a>
<a name="ln7638"> </a>
<a name="ln7639">        if (!cinfo.empty())</a>
<a name="ln7640">            cinfo += &quot;\n&quot;;</a>
<a name="ln7641"> </a>
<a name="ln7642">        cinfo += make_stringf(&quot;You are being %s by %s.&quot;,</a>
<a name="ln7643">                              constrictor-&gt;constriction_does_damage(true) ?</a>
<a name="ln7644">                                  &quot;held&quot; : &quot;constricted&quot;,</a>
<a name="ln7645">                              constrictor-&gt;name(DESC_A).c_str());</a>
<a name="ln7646">    }</a>
<a name="ln7647"> </a>
<a name="ln7648">    if (you.is_constricting())</a>
<a name="ln7649">    {</a>
<a name="ln7650">        for (const auto &amp;entry : *you.constricting)</a>
<a name="ln7651">        {</a>
<a name="ln7652">            monster *whom = monster_by_mid(entry.first);</a>
<a name="ln7653">            ASSERT(whom);</a>
<a name="ln7654"> </a>
<a name="ln7655">            if (!whom-&gt;is_directly_constricted())</a>
<a name="ln7656">                continue;</a>
<a name="ln7657"> </a>
<a name="ln7658">            c_name.push_back(whom-&gt;name(DESC_A));</a>
<a name="ln7659">        }</a>
<a name="ln7660"> </a>
<a name="ln7661">        if (!c_name.empty())</a>
<a name="ln7662">        {</a>
<a name="ln7663">            if (!cinfo.empty())</a>
<a name="ln7664">                cinfo += &quot;\n&quot;;</a>
<a name="ln7665"> </a>
<a name="ln7666">            cinfo += &quot;You are constricting &quot;;</a>
<a name="ln7667">            cinfo += comma_separated_line(c_name.begin(), c_name.end());</a>
<a name="ln7668">            cinfo += &quot;.&quot;;</a>
<a name="ln7669">        }</a>
<a name="ln7670">    }</a>
<a name="ln7671"> </a>
<a name="ln7672">    return cinfo;</a>
<a name="ln7673">}</a>
<a name="ln7674"> </a>
<a name="ln7675">/**</a>
<a name="ln7676"> *   The player's radius of monster detection.</a>
<a name="ln7677"> *   @return   the radius in which a player can detect monsters.</a>
<a name="ln7678">**/</a>
<a name="ln7679">int player_monster_detect_radius()</a>
<a name="ln7680">{</a>
<a name="ln7681">    int radius = you.get_mutation_level(MUT_ANTENNAE) * 2;</a>
<a name="ln7682"> </a>
<a name="ln7683">    if (player_equip_unrand(UNRAND_HOOD_ASSASSIN))</a>
<a name="ln7684">        radius = max(radius, 4);</a>
<a name="ln7685">    if (have_passive(passive_t::detect_montier))</a>
<a name="ln7686">        radius = max(radius, you.piety / 20);</a>
<a name="ln7687">    return min(radius, LOS_DEFAULT_RANGE);</a>
<a name="ln7688">}</a>
<a name="ln7689"> </a>
<a name="ln7690">/**</a>
<a name="ln7691"> * Return true if the player has angered Pandemonium by picking up or moving</a>
<a name="ln7692"> * the Orb of Zot.</a>
<a name="ln7693"> */</a>
<a name="ln7694">bool player_on_orb_run()</a>
<a name="ln7695">{</a>
<a name="ln7696">    return you.chapter == CHAPTER_ESCAPING</a>
<a name="ln7697">           || you.chapter == CHAPTER_ANGERED_PANDEMONIUM;</a>
<a name="ln7698">}</a>
<a name="ln7699"> </a>
<a name="ln7700">/**</a>
<a name="ln7701"> * Return true if the player has the Orb of Zot.</a>
<a name="ln7702"> * @return  True if the player has the Orb, false otherwise.</a>
<a name="ln7703"> */</a>
<a name="ln7704">bool player_has_orb()</a>
<a name="ln7705">{</a>
<a name="ln7706">    return you.chapter == CHAPTER_ESCAPING;</a>
<a name="ln7707">}</a>
<a name="ln7708"> </a>
<a name="ln7709">bool player::form_uses_xl() const</a>
<a name="ln7710">{</a>
<a name="ln7711">    // No body parts that translate in any way to something fisticuffs could</a>
<a name="ln7712">    // matter to, the attack mode is different. Plus, it's weird to have</a>
<a name="ln7713">    // users of one particular [non-]weapon be effective for this</a>
<a name="ln7714">    // unintentional form while others can just run or die. I believe this</a>
<a name="ln7715">    // should apply to more forms, too.  [1KB]</a>
<a name="ln7716">    return form == transformation::wisp || form == transformation::fungus</a>
<a name="ln7717">        || form == transformation::pig</a>
<a name="ln7718">        || form == transformation::bat &amp;&amp; you.species != SP_VAMPIRE;</a>
<a name="ln7719">}</a>
<a name="ln7720"> </a>
<a name="ln7721">static int _get_potion_heal_factor()</a>
<a name="ln7722">{</a>
<a name="ln7723">    // healing factor is expressed in thirds, so default is 3/3 -- 100%.</a>
<a name="ln7724">    int factor = 3;</a>
<a name="ln7725"> </a>
<a name="ln7726">    // start with penalties</a>
<a name="ln7727">    factor -= player_equip_unrand(UNRAND_VINES) ? 3 : 0;</a>
<a name="ln7728">    factor -= you.mutation[MUT_NO_POTION_HEAL];</a>
<a name="ln7729"> </a>
<a name="ln7730">    // then apply bonuses - Kryia's doubles potion healing</a>
<a name="ln7731">    factor *= player_equip_unrand(UNRAND_KRYIAS) ? 2 : 1;</a>
<a name="ln7732"> </a>
<a name="ln7733">    // make sure we don't turn healing negative.</a>
<a name="ln7734">    return max(0, factor);</a>
<a name="ln7735">}</a>
<a name="ln7736"> </a>
<a name="ln7737">void print_potion_heal_message()</a>
<a name="ln7738">{</a>
<a name="ln7739">    // Don't give multiple messages in weird cases with both enhanced</a>
<a name="ln7740">    // and reduced healing.</a>
<a name="ln7741">    if (_get_potion_heal_factor() &gt; 3)</a>
<a name="ln7742">    {</a>
<a name="ln7743">        if (player_equip_unrand(UNRAND_KRYIAS))</a>
<a name="ln7744">        {</a>
<a name="ln7745">            item_def* item = you.slot_item(EQ_BODY_ARMOUR);</a>
<a name="ln7746">            mprf(&quot;%s enhances the healing.&quot;,</a>
<a name="ln7747">            item-&gt;name(DESC_THE, false, false, false).c_str());</a>
<a name="ln7748">        }</a>
<a name="ln7749">        else</a>
<a name="ln7750">            mpr(&quot;The healing is enhanced.&quot;); // bad message, but this should</a>
<a name="ln7751">                                             // never be possible anyway</a>
<a name="ln7752">    }</a>
<a name="ln7753">    else if (_get_potion_heal_factor() == 0)</a>
<a name="ln7754">        mpr(&quot;Your system rejects the healing.&quot;);</a>
<a name="ln7755">    else if (_get_potion_heal_factor() &lt; 3)</a>
<a name="ln7756">        mpr(&quot;Your system partially rejects the healing.&quot;);</a>
<a name="ln7757">}</a>
<a name="ln7758"> </a>
<a name="ln7759">bool player::can_potion_heal()</a>
<a name="ln7760">{</a>
<a name="ln7761">    return _get_potion_heal_factor() &gt; 0;</a>
<a name="ln7762">}</a>
<a name="ln7763"> </a>
<a name="ln7764">int player::scale_potion_healing(int healing_amount)</a>
<a name="ln7765">{</a>
<a name="ln7766">    return div_rand_round(healing_amount * _get_potion_heal_factor(), 3);</a>
<a name="ln7767">}</a>
<a name="ln7768"> </a>
<a name="ln7769">void player_open_door(coord_def doorpos)</a>
<a name="ln7770">{</a>
<a name="ln7771">    // Finally, open the closed door!</a>
<a name="ln7772">    set&lt;coord_def&gt; all_door;</a>
<a name="ln7773">    find_connected_identical(doorpos, all_door);</a>
<a name="ln7774">    const char *adj, *noun;</a>
<a name="ln7775">    get_door_description(all_door.size(), &amp;adj, &amp;noun);</a>
<a name="ln7776"> </a>
<a name="ln7777">    const string door_desc_adj  =</a>
<a name="ln7778">        env.markers.property_at(doorpos, MAT_ANY, &quot;door_description_adjective&quot;);</a>
<a name="ln7779">    const string door_desc_noun =</a>
<a name="ln7780">        env.markers.property_at(doorpos, MAT_ANY, &quot;door_description_noun&quot;);</a>
<a name="ln7781">    if (!door_desc_adj.empty())</a>
<a name="ln7782">        adj = door_desc_adj.c_str();</a>
<a name="ln7783">    if (!door_desc_noun.empty())</a>
<a name="ln7784">        noun = door_desc_noun.c_str();</a>
<a name="ln7785"> </a>
<a name="ln7786">    if (!you.confused())</a>
<a name="ln7787">    {</a>
<a name="ln7788">        string door_open_prompt =</a>
<a name="ln7789">            env.markers.property_at(doorpos, MAT_ANY, &quot;door_open_prompt&quot;);</a>
<a name="ln7790"> </a>
<a name="ln7791">        bool ignore_exclude = false;</a>
<a name="ln7792"> </a>
<a name="ln7793">        if (!door_open_prompt.empty())</a>
<a name="ln7794">        {</a>
<a name="ln7795">            door_open_prompt += &quot; (y/N)&quot;;</a>
<a name="ln7796">            if (!yesno(door_open_prompt.c_str(), true, 'n', true, false))</a>
<a name="ln7797">            {</a>
<a name="ln7798">                if (is_exclude_root(doorpos))</a>
<a name="ln7799">                    canned_msg(MSG_OK);</a>
<a name="ln7800">                else</a>
<a name="ln7801">                {</a>
<a name="ln7802">                    if (yesno(&quot;Put travel exclusion on door? (Y/n)&quot;,</a>
<a name="ln7803">                              true, 'y'))</a>
<a name="ln7804">                    {</a>
<a name="ln7805">                        // Zero radius exclusion right on top of door.</a>
<a name="ln7806">                        set_exclude(doorpos, 0);</a>
<a name="ln7807">                    }</a>
<a name="ln7808">                }</a>
<a name="ln7809">                interrupt_activity(activity_interrupt::force);</a>
<a name="ln7810">                return;</a>
<a name="ln7811">            }</a>
<a name="ln7812">            ignore_exclude = true;</a>
<a name="ln7813">        }</a>
<a name="ln7814"> </a>
<a name="ln7815">        if (!ignore_exclude &amp;&amp; is_exclude_root(doorpos))</a>
<a name="ln7816">        {</a>
<a name="ln7817">            string prompt = make_stringf(&quot;This %s%s is marked as excluded! &quot;</a>
<a name="ln7818">                                         &quot;Open it anyway?&quot;, adj, noun);</a>
<a name="ln7819"> </a>
<a name="ln7820">            if (!yesno(prompt.c_str(), true, 'n', true, false))</a>
<a name="ln7821">            {</a>
<a name="ln7822">                canned_msg(MSG_OK);</a>
<a name="ln7823">                interrupt_activity(activity_interrupt::force);</a>
<a name="ln7824">                return;</a>
<a name="ln7825">            }</a>
<a name="ln7826">        }</a>
<a name="ln7827">    }</a>
<a name="ln7828"> </a>
<a name="ln7829">    const int skill = 8 + you.skill_rdiv(SK_STEALTH, 4, 3);</a>
<a name="ln7830"> </a>
<a name="ln7831">    string berserk_open = env.markers.property_at(doorpos, MAT_ANY,</a>
<a name="ln7832">                                                  &quot;door_berserk_verb_open&quot;);</a>
<a name="ln7833">    string berserk_adjective = env.markers.property_at(doorpos, MAT_ANY,</a>
<a name="ln7834">                                                       &quot;door_berserk_adjective&quot;);</a>
<a name="ln7835">    string door_open_creak = env.markers.property_at(doorpos, MAT_ANY,</a>
<a name="ln7836">                                                     &quot;door_noisy_verb_open&quot;);</a>
<a name="ln7837">    string door_airborne = env.markers.property_at(doorpos, MAT_ANY,</a>
<a name="ln7838">                                                   &quot;door_airborne_verb_open&quot;);</a>
<a name="ln7839">    string door_open_verb = env.markers.property_at(doorpos, MAT_ANY,</a>
<a name="ln7840">                                                    &quot;door_verb_open&quot;);</a>
<a name="ln7841"> </a>
<a name="ln7842">    if (you.berserk())</a>
<a name="ln7843">    {</a>
<a name="ln7844">        // XXX: Better flavour for larger doors?</a>
<a name="ln7845">        if (silenced(you.pos()))</a>
<a name="ln7846">        {</a>
<a name="ln7847">            if (!berserk_open.empty())</a>
<a name="ln7848">            {</a>
<a name="ln7849">                berserk_open += &quot;.&quot;;</a>
<a name="ln7850">                mprf(berserk_open.c_str(), adj, noun);</a>
<a name="ln7851">            }</a>
<a name="ln7852">            else</a>
<a name="ln7853">                mprf(&quot;The %s%s flies open!&quot;, adj, noun);</a>
<a name="ln7854">        }</a>
<a name="ln7855">        else</a>
<a name="ln7856">        {</a>
<a name="ln7857">            if (!berserk_open.empty())</a>
<a name="ln7858">            {</a>
<a name="ln7859">                if (!berserk_adjective.empty())</a>
<a name="ln7860">                    berserk_open += &quot; &quot; + berserk_adjective;</a>
<a name="ln7861">                else</a>
<a name="ln7862">                    berserk_open += &quot;.&quot;;</a>
<a name="ln7863">                mprf(MSGCH_SOUND, berserk_open.c_str(), adj, noun);</a>
<a name="ln7864">            }</a>
<a name="ln7865">            else</a>
<a name="ln7866">                mprf(MSGCH_SOUND, &quot;The %s%s flies open with a bang!&quot;, adj, noun);</a>
<a name="ln7867">            noisy(15, you.pos());</a>
<a name="ln7868">        }</a>
<a name="ln7869">    }</a>
<a name="ln7870">    else if (one_chance_in(skill) &amp;&amp; !silenced(you.pos()))</a>
<a name="ln7871">    {</a>
<a name="ln7872">        if (!door_open_creak.empty())</a>
<a name="ln7873">            mprf(MSGCH_SOUND, door_open_creak.c_str(), adj, noun);</a>
<a name="ln7874">        else</a>
<a name="ln7875">        {</a>
<a name="ln7876">            mprf(MSGCH_SOUND, &quot;As you open the %s%s, it creaks loudly!&quot;,</a>
<a name="ln7877">                 adj, noun);</a>
<a name="ln7878">        }</a>
<a name="ln7879">        noisy(10, you.pos());</a>
<a name="ln7880">    }</a>
<a name="ln7881">    else</a>
<a name="ln7882">    {</a>
<a name="ln7883">        const char* verb;</a>
<a name="ln7884">        if (you.airborne())</a>
<a name="ln7885">        {</a>
<a name="ln7886">            if (!door_airborne.empty())</a>
<a name="ln7887">                verb = door_airborne.c_str();</a>
<a name="ln7888">            else</a>
<a name="ln7889">                verb = &quot;You reach down and open the %s%s.&quot;;</a>
<a name="ln7890">        }</a>
<a name="ln7891">        else</a>
<a name="ln7892">        {</a>
<a name="ln7893">            if (!door_open_verb.empty())</a>
<a name="ln7894">               verb = door_open_verb.c_str();</a>
<a name="ln7895">            else</a>
<a name="ln7896">               verb = &quot;You open the %s%s.&quot;;</a>
<a name="ln7897">        }</a>
<a name="ln7898"> </a>
<a name="ln7899">        mprf(verb, adj, noun);</a>
<a name="ln7900">    }</a>
<a name="ln7901"> </a>
<a name="ln7902">    vector&lt;coord_def&gt; excludes;</a>
<a name="ln7903">    for (const auto &amp;dc : all_door)</a>
<a name="ln7904">    {</a>
<a name="ln7905">        if (cell_is_runed(dc))</a>
<a name="ln7906">            explored_tracked_feature(grd(dc));</a>
<a name="ln7907">        dgn_open_door(dc);</a>
<a name="ln7908">        set_terrain_changed(dc);</a>
<a name="ln7909">        dungeon_events.fire_position_event(DET_DOOR_OPENED, dc);</a>
<a name="ln7910"> </a>
<a name="ln7911">        // Even if some of the door is out of LOS, we want the entire</a>
<a name="ln7912">        // door to be updated. Hitting this case requires a really big</a>
<a name="ln7913">        // door!</a>
<a name="ln7914">        if (env.map_knowledge(dc).seen())</a>
<a name="ln7915">        {</a>
<a name="ln7916">            env.map_knowledge(dc).set_feature(grd(dc));</a>
<a name="ln7917">#ifdef USE_TILE</a>
<a name="ln7918">            env.tile_bk_bg(dc) = tileidx_feature_base(grd(dc));</a>
<a name="ln7919">#endif</a>
<a name="ln7920">        }</a>
<a name="ln7921"> </a>
<a name="ln7922">        if (is_excluded(dc))</a>
<a name="ln7923">            excludes.push_back(dc);</a>
<a name="ln7924">    }</a>
<a name="ln7925"> </a>
<a name="ln7926">    update_exclusion_los(excludes);</a>
<a name="ln7927">    viewwindow();</a>
<a name="ln7928">    you.turn_is_over = true;</a>
<a name="ln7929">}</a>
<a name="ln7930"> </a>
<a name="ln7931">void player_close_door(coord_def doorpos)</a>
<a name="ln7932">{</a>
<a name="ln7933">    // Finally, close the opened door!</a>
<a name="ln7934">    string berserk_close = env.markers.property_at(doorpos, MAT_ANY,</a>
<a name="ln7935">                                                &quot;door_berserk_verb_close&quot;);</a>
<a name="ln7936">    const string berserk_adjective = env.markers.property_at(doorpos, MAT_ANY,</a>
<a name="ln7937">                                                &quot;door_berserk_adjective&quot;);</a>
<a name="ln7938">    const string door_close_creak = env.markers.property_at(doorpos, MAT_ANY,</a>
<a name="ln7939">                                                &quot;door_noisy_verb_close&quot;);</a>
<a name="ln7940">    const string door_airborne = env.markers.property_at(doorpos, MAT_ANY,</a>
<a name="ln7941">                                                &quot;door_airborne_verb_close&quot;);</a>
<a name="ln7942">    const string door_close_verb = env.markers.property_at(doorpos, MAT_ANY,</a>
<a name="ln7943">                                                &quot;door_verb_close&quot;);</a>
<a name="ln7944">    const string door_desc_adj  = env.markers.property_at(doorpos, MAT_ANY,</a>
<a name="ln7945">                                                &quot;door_description_adjective&quot;);</a>
<a name="ln7946">    const string door_desc_noun = env.markers.property_at(doorpos, MAT_ANY,</a>
<a name="ln7947">                                                &quot;door_description_noun&quot;);</a>
<a name="ln7948">    set&lt;coord_def&gt; all_door;</a>
<a name="ln7949">    find_connected_identical(doorpos, all_door);</a>
<a name="ln7950">    const auto door_vec = vector&lt;coord_def&gt;(all_door.begin(), all_door.end());</a>
<a name="ln7951"> </a>
<a name="ln7952">    const char *adj, *noun;</a>
<a name="ln7953">    get_door_description(all_door.size(), &amp;adj, &amp;noun);</a>
<a name="ln7954">    const string waynoun_str = make_stringf(&quot;%sway&quot;, noun);</a>
<a name="ln7955">    const char *waynoun = waynoun_str.c_str();</a>
<a name="ln7956"> </a>
<a name="ln7957">    if (!door_desc_adj.empty())</a>
<a name="ln7958">        adj = door_desc_adj.c_str();</a>
<a name="ln7959">    if (!door_desc_noun.empty())</a>
<a name="ln7960">    {</a>
<a name="ln7961">        noun = door_desc_noun.c_str();</a>
<a name="ln7962">        waynoun = noun;</a>
<a name="ln7963">    }</a>
<a name="ln7964"> </a>
<a name="ln7965">    for (const coord_def&amp; dc : all_door)</a>
<a name="ln7966">    {</a>
<a name="ln7967">        if (monster* mon = monster_at(dc))</a>
<a name="ln7968">        {</a>
<a name="ln7969">            const bool mons_unseen = !you.can_see(*mon);</a>
<a name="ln7970">            if (mons_unseen || mons_is_object(mon-&gt;type))</a>
<a name="ln7971">            {</a>
<a name="ln7972">                mprf(&quot;Something is blocking the %s!&quot;, waynoun);</a>
<a name="ln7973">                // No free detection!</a>
<a name="ln7974">                if (mons_unseen)</a>
<a name="ln7975">                    you.turn_is_over = true;</a>
<a name="ln7976">            }</a>
<a name="ln7977">            else</a>
<a name="ln7978">                mprf(&quot;There's a creature in the %s!&quot;, waynoun);</a>
<a name="ln7979">            return;</a>
<a name="ln7980">        }</a>
<a name="ln7981"> </a>
<a name="ln7982">        if (igrd(dc) != NON_ITEM)</a>
<a name="ln7983">        {</a>
<a name="ln7984">            if (!has_push_spaces(dc, false, &amp;door_vec))</a>
<a name="ln7985">            {</a>
<a name="ln7986">                mprf(&quot;There's something jamming the %s.&quot;, waynoun);</a>
<a name="ln7987">                return;</a>
<a name="ln7988">            }</a>
<a name="ln7989">        }</a>
<a name="ln7990"> </a>
<a name="ln7991">        // messaging with gateways will be inconsistent if this isn't last</a>
<a name="ln7992">        if (you.pos() == dc)</a>
<a name="ln7993">        {</a>
<a name="ln7994">            mprf(&quot;There's a thick-headed creature in the %s!&quot;, waynoun);</a>
<a name="ln7995">            return;</a>
<a name="ln7996">        }</a>
<a name="ln7997">    }</a>
<a name="ln7998">    const int you_old_top_item = igrd(you.pos());</a>
<a name="ln7999"> </a>
<a name="ln8000">    bool items_moved = false;</a>
<a name="ln8001">    for (const coord_def&amp; dc : all_door)</a>
<a name="ln8002">        items_moved |= push_items_from(dc, &amp;door_vec);</a>
<a name="ln8003"> </a>
<a name="ln8004">    // TODO: if only one thing moved, use that item's name</a>
<a name="ln8005">    // TODO: handle des-derived strings.  (Better yet, find a way to not have</a>
<a name="ln8006">    // format strings in des...)</a>
<a name="ln8007">    const char *items_msg = items_moved ? &quot;, pushing everything out of the way&quot;</a>
<a name="ln8008">                                        : &quot;&quot;;</a>
<a name="ln8009"> </a>
<a name="ln8010">    const int skill = 8 + you.skill_rdiv(SK_STEALTH, 4, 3);</a>
<a name="ln8011"> </a>
<a name="ln8012">    if (you.berserk())</a>
<a name="ln8013">    {</a>
<a name="ln8014">        if (silenced(you.pos()))</a>
<a name="ln8015">        {</a>
<a name="ln8016">            if (!berserk_close.empty())</a>
<a name="ln8017">            {</a>
<a name="ln8018">                berserk_close += &quot;.&quot;;</a>
<a name="ln8019">                mprf(berserk_close.c_str(), adj, noun);</a>
<a name="ln8020">            }</a>
<a name="ln8021">            else</a>
<a name="ln8022">                mprf(&quot;You slam the %s%s shut%s!&quot;, adj, noun, items_msg);</a>
<a name="ln8023">        }</a>
<a name="ln8024">        else</a>
<a name="ln8025">        {</a>
<a name="ln8026">            if (!berserk_close.empty())</a>
<a name="ln8027">            {</a>
<a name="ln8028">                if (!berserk_adjective.empty())</a>
<a name="ln8029">                    berserk_close += &quot; &quot; + berserk_adjective;</a>
<a name="ln8030">                else</a>
<a name="ln8031">                    berserk_close += &quot;.&quot;;</a>
<a name="ln8032">                mprf(MSGCH_SOUND, berserk_close.c_str(), adj, noun);</a>
<a name="ln8033">            }</a>
<a name="ln8034">            else</a>
<a name="ln8035">            {</a>
<a name="ln8036">                mprf(MSGCH_SOUND, &quot;You slam the %s%s shut with a bang%s!&quot;,</a>
<a name="ln8037">                                  adj, noun, items_msg);</a>
<a name="ln8038">            }</a>
<a name="ln8039"> </a>
<a name="ln8040">            noisy(15, you.pos());</a>
<a name="ln8041">        }</a>
<a name="ln8042">    }</a>
<a name="ln8043">    else if (one_chance_in(skill) &amp;&amp; !silenced(you.pos()))</a>
<a name="ln8044">    {</a>
<a name="ln8045">        if (!door_close_creak.empty())</a>
<a name="ln8046">            mprf(MSGCH_SOUND, door_close_creak.c_str(), adj, noun);</a>
<a name="ln8047">        else</a>
<a name="ln8048">        {</a>
<a name="ln8049">            mprf(MSGCH_SOUND, &quot;As you close the %s%s%s, it creaks loudly!&quot;,</a>
<a name="ln8050">                              adj, noun, items_msg);</a>
<a name="ln8051">        }</a>
<a name="ln8052"> </a>
<a name="ln8053">        noisy(10, you.pos());</a>
<a name="ln8054">    }</a>
<a name="ln8055">    else</a>
<a name="ln8056">    {</a>
<a name="ln8057">        if (you.airborne())</a>
<a name="ln8058">        {</a>
<a name="ln8059">            if (!door_airborne.empty())</a>
<a name="ln8060">                mprf(door_airborne.c_str(), adj, noun);</a>
<a name="ln8061">            else</a>
<a name="ln8062">                mprf(&quot;You reach down and close the %s%s%s.&quot;, adj, noun, items_msg);</a>
<a name="ln8063">        }</a>
<a name="ln8064">        else</a>
<a name="ln8065">        {</a>
<a name="ln8066">            if (!door_close_verb.empty())</a>
<a name="ln8067">                mprf(door_close_verb.c_str(), adj, noun);</a>
<a name="ln8068">            else</a>
<a name="ln8069">                mprf(&quot;You close the %s%s%s.&quot;, adj, noun, items_msg);</a>
<a name="ln8070">        }</a>
<a name="ln8071">    }</a>
<a name="ln8072"> </a>
<a name="ln8073">    vector&lt;coord_def&gt; excludes;</a>
<a name="ln8074">    for (const coord_def&amp; dc : all_door)</a>
<a name="ln8075">    {</a>
<a name="ln8076">        // Once opened, formerly runed doors become normal doors.</a>
<a name="ln8077">        dgn_close_door(dc);</a>
<a name="ln8078">        set_terrain_changed(dc);</a>
<a name="ln8079">        dungeon_events.fire_position_event(DET_DOOR_CLOSED, dc);</a>
<a name="ln8080"> </a>
<a name="ln8081">        // Even if some of the door is out of LOS once it's closed</a>
<a name="ln8082">        // (or even if some of it is out of LOS when it's open), we</a>
<a name="ln8083">        // want the entire door to be updated.</a>
<a name="ln8084">        if (env.map_knowledge(dc).seen())</a>
<a name="ln8085">        {</a>
<a name="ln8086">            env.map_knowledge(dc).set_feature(grd(dc));</a>
<a name="ln8087">#ifdef USE_TILE</a>
<a name="ln8088">            env.tile_bk_bg(dc) = tileidx_feature_base(grd(dc));</a>
<a name="ln8089">#endif</a>
<a name="ln8090">        }</a>
<a name="ln8091"> </a>
<a name="ln8092">        if (is_excluded(dc))</a>
<a name="ln8093">            excludes.push_back(dc);</a>
<a name="ln8094">    }</a>
<a name="ln8095"> </a>
<a name="ln8096">    update_exclusion_los(excludes);</a>
<a name="ln8097"> </a>
<a name="ln8098">    // item pushing may have moved items under the player</a>
<a name="ln8099">    if (igrd(you.pos()) != you_old_top_item)</a>
<a name="ln8100">        item_check();</a>
<a name="ln8101">    you.turn_is_over = true;</a>
<a name="ln8102">}</a>
<a name="ln8103"> </a>
<a name="ln8104">/**</a>
<a name="ln8105"> * Return a string describing the player's hand(s) taking a given verb.</a>
<a name="ln8106"> *</a>
<a name="ln8107"> * @param plural_verb    A plural-agreeing verb. (&quot;Smoulders&quot;, &quot;are&quot;, etc.)</a>
<a name="ln8108"> * @return               A string describing the action.</a>
<a name="ln8109"> *                       E.g. &quot;tentacles smoulder&quot;, &quot;paw is&quot;, etc.</a>
<a name="ln8110"> */</a>
<a name="ln8111">string player::hands_verb(const string &amp;plural_verb) const</a>
<a name="ln8112">{</a>
<a name="ln8113">    bool plural;</a>
<a name="ln8114">    const string hand = hand_name(true, &amp;plural);</a>
<a name="ln8115">    return hand + &quot; &quot; + conjugate_verb(plural_verb, plural);</a>
<a name="ln8116">}</a>
<a name="ln8117"> </a>
<a name="ln8118">// Is this a character that would not normally have a preceding space when</a>
<a name="ln8119">// it follows a word?</a>
<a name="ln8120">static bool _is_end_punct(char c)</a>
<a name="ln8121">{</a>
<a name="ln8122">    switch (c)</a>
<a name="ln8123">    {</a>
<a name="ln8124">    case ' ': case '.': case '!': case '?':</a>
<a name="ln8125">    case ',': case ':': case ';': case ')':</a>
<a name="ln8126">        return true;</a>
<a name="ln8127">    }</a>
<a name="ln8128">    return false;</a>
<a name="ln8129">}</a>
<a name="ln8130"> </a>
<a name="ln8131">/**</a>
<a name="ln8132"> * Return a string describing the player's hand(s) (or equivalent) taking the</a>
<a name="ln8133"> * given action (verb).</a>
<a name="ln8134"> *</a>
<a name="ln8135"> * @param plural_verb   The plural-agreeing verb corresponding to the action to</a>
<a name="ln8136"> *                      take. E.g., &quot;smoulder&quot;, &quot;glow&quot;, &quot;gain&quot;, etc.</a>
<a name="ln8137"> * @param object        The object or predicate complement of the action,</a>
<a name="ln8138"> *                      including any sentence-final punctuation. E.g. &quot;.&quot;,</a>
<a name="ln8139"> *                      &quot;new energy.&quot;, etc.</a>
<a name="ln8140"> * @return              A string describing the player's hands taking the</a>
<a name="ln8141"> *                      given action. E.g. &quot;Your tentacle gains new energy.&quot;</a>
<a name="ln8142"> */</a>
<a name="ln8143">string player::hands_act(const string &amp;plural_verb,</a>
<a name="ln8144">                         const string &amp;object) const</a>
<a name="ln8145">{</a>
<a name="ln8146">    const bool space = !object.empty() &amp;&amp; !_is_end_punct(object[0]);</a>
<a name="ln8147">    return &quot;Your &quot; + hands_verb(plural_verb) + (space ? &quot; &quot; : &quot;&quot;) + object;</a>
<a name="ln8148">}</a>
<a name="ln8149"> </a>
<a name="ln8150">int player::inaccuracy() const</a>
<a name="ln8151">{</a>
<a name="ln8152">    int degree = 0;</a>
<a name="ln8153">    if (wearing(EQ_AMULET, AMU_INACCURACY))</a>
<a name="ln8154">        degree++;</a>
<a name="ln8155">    if (get_mutation_level(MUT_MISSING_EYE))</a>
<a name="ln8156">        degree++;</a>
<a name="ln8157">    return degree;</a>
<a name="ln8158">}</a>
<a name="ln8159"> </a>
<a name="ln8160">/**</a>
<a name="ln8161"> * Handle effects that occur after the player character stops berserking.</a>
<a name="ln8162"> */</a>
<a name="ln8163">void player_end_berserk()</a>
<a name="ln8164">{</a>
<a name="ln8165">    // Sometimes berserk leaves us physically drained.</a>
<a name="ln8166">    //</a>
<a name="ln8167">    // Chance of passing out:</a>
<a name="ln8168">    //     - mutation gives a large plus in order to try and</a>
<a name="ln8169">    //       avoid the mutation being a &quot;death sentence&quot; to</a>
<a name="ln8170">    //       certain characters.</a>
<a name="ln8171"> </a>
<a name="ln8172">    if (one_chance_in(10 + you.get_mutation_level(MUT_BERSERK) * 25))</a>
<a name="ln8173">    {</a>
<a name="ln8174">        // Note the beauty of Trog! They get an extra save that</a>
<a name="ln8175">        // goes up to 100% at 6 stars of piety.</a>
<a name="ln8176">        if (have_passive(passive_t::extend_berserk)</a>
<a name="ln8177">            &amp;&amp; x_chance_in_y(you.piety, piety_breakpoint(5)))</a>
<a name="ln8178">        {</a>
<a name="ln8179">            mpr(&quot;Trog's vigour flows through your veins.&quot;);</a>
<a name="ln8180">        }</a>
<a name="ln8181">        else</a>
<a name="ln8182">        {</a>
<a name="ln8183">            mprf(MSGCH_WARN, &quot;You pass out from exhaustion.&quot;);</a>
<a name="ln8184">            you.increase_duration(DUR_PARALYSIS, roll_dice(1, 4));</a>
<a name="ln8185">            you.stop_directly_constricting_all(false);</a>
<a name="ln8186">        }</a>
<a name="ln8187">    }</a>
<a name="ln8188"> </a>
<a name="ln8189">    if (!you.duration[DUR_PARALYSIS] &amp;&amp; !you.petrified())</a>
<a name="ln8190">        mprf(MSGCH_WARN, &quot;You are exhausted.&quot;);</a>
<a name="ln8191"> </a>
<a name="ln8192">    you.berserk_penalty = 0;</a>
<a name="ln8193"> </a>
<a name="ln8194">    const int dur = 12 + roll_dice(2, 12);</a>
<a name="ln8195">    // Slow durations are multiplied by haste_mul (3/2), exhaustion lasts</a>
<a name="ln8196">    // slightly longer.</a>
<a name="ln8197">    you.increase_duration(DUR_BERSERK_COOLDOWN, dur * 2);</a>
<a name="ln8198"> </a>
<a name="ln8199">    // Don't trigger too many hints mode messages.</a>
<a name="ln8200">    const bool hints_slow = Hints.hints_events[HINT_YOU_ENCHANTED];</a>
<a name="ln8201">    Hints.hints_events[HINT_YOU_ENCHANTED] = false;</a>
<a name="ln8202"> </a>
<a name="ln8203">    slow_player(dur);</a>
<a name="ln8204"> </a>
<a name="ln8205">    //Un-apply Berserk's +50% Current/Max HP</a>
<a name="ln8206">    calc_hp(true, false);</a>
<a name="ln8207"> </a>
<a name="ln8208">    learned_something_new(HINT_POSTBERSERK);</a>
<a name="ln8209">    Hints.hints_events[HINT_YOU_ENCHANTED] = hints_slow;</a>
<a name="ln8210">    you.redraw_quiver = true; // Can throw again.</a>
<a name="ln8211">}</a>
<a name="ln8212"> </a>
<a name="ln8213">/**</a>
<a name="ln8214"> * Does the player have the Sanguine Armour mutation (not suppressed by a form)</a>
<a name="ln8215"> * while being at a low enough HP (&lt;67%) for its benefits to trigger?</a>
<a name="ln8216"> *</a>
<a name="ln8217"> * @return Whether Sanguine Armour should be active.</a>
<a name="ln8218"> */</a>
<a name="ln8219">bool sanguine_armour_valid()</a>
<a name="ln8220">{</a>
<a name="ln8221">    // why does this need to specify the activity type explicitly?</a>
<a name="ln8222">    return you.hp &lt;= you.hp_max * 2 / 3</a>
<a name="ln8223">           &amp;&amp; you.get_mutation_level(MUT_SANGUINE_ARMOUR, mutation_activity_type::FULL);</a>
<a name="ln8224">}</a>
<a name="ln8225"> </a>
<a name="ln8226">/// Trigger sanguine armour, updating the duration &amp; messaging as appropriate.</a>
<a name="ln8227">void activate_sanguine_armour()</a>
<a name="ln8228">{</a>
<a name="ln8229">    const bool was_active = you.duration[DUR_SANGUINE_ARMOUR];</a>
<a name="ln8230">    you.duration[DUR_SANGUINE_ARMOUR] = random_range(60, 100);</a>
<a name="ln8231">    if (!was_active)</a>
<a name="ln8232">    {</a>
<a name="ln8233">        mpr(&quot;Your blood congeals into armour.&quot;);</a>
<a name="ln8234">        you.redraw_armour_class = true;</a>
<a name="ln8235">    }</a>
<a name="ln8236">}</a>
<a name="ln8237"> </a>
<a name="ln8238">/**</a>
<a name="ln8239"> * Refreshes the protective aura around the player after striking with</a>
<a name="ln8240"> * a weapon of protection. The duration is very short.</a>
<a name="ln8241"> */</a>
<a name="ln8242">void refresh_weapon_protection()</a>
<a name="ln8243">{</a>
<a name="ln8244">    if (!you.duration[DUR_SPWPN_PROTECTION])</a>
<a name="ln8245">        mpr(&quot;Your weapon exudes an aura of protection.&quot;);</a>
<a name="ln8246"> </a>
<a name="ln8247">    you.increase_duration(DUR_SPWPN_PROTECTION, 3 + random2(2), 5);</a>
<a name="ln8248">    you.redraw_armour_class = true;</a>
<a name="ln8249">}</a>
<a name="ln8250"> </a>
<a name="ln8251">// Is the player immune to a particular hex because of their</a>
<a name="ln8252">// intrinsic properties?</a>
<a name="ln8253">bool player::immune_to_hex(const spell_type hex) const</a>
<a name="ln8254">{</a>
<a name="ln8255">    switch (hex)</a>
<a name="ln8256">    {</a>
<a name="ln8257">    case SPELL_PARALYSIS_GAZE:</a>
<a name="ln8258">    case SPELL_PARALYSE:</a>
<a name="ln8259">    case SPELL_SLOW:</a>
<a name="ln8260">        return stasis();</a>
<a name="ln8261">    case SPELL_CONFUSE:</a>
<a name="ln8262">    case SPELL_CONFUSION_GAZE:</a>
<a name="ln8263">    case SPELL_MASS_CONFUSION:</a>
<a name="ln8264">        return clarity() || you.duration[DUR_DIVINE_STAMINA] &gt; 0;</a>
<a name="ln8265">    case SPELL_TELEPORT_OTHER:</a>
<a name="ln8266">    case SPELL_BLINK_OTHER:</a>
<a name="ln8267">    case SPELL_BLINK_OTHER_CLOSE:</a>
<a name="ln8268">        return no_tele();</a>
<a name="ln8269">    case SPELL_MESMERISE:</a>
<a name="ln8270">    case SPELL_AVATAR_SONG:</a>
<a name="ln8271">    case SPELL_SIREN_SONG:</a>
<a name="ln8272">        return clarity() || berserk();</a>
<a name="ln8273">    case SPELL_CAUSE_FEAR:</a>
<a name="ln8274">        return clarity() || !(holiness() &amp; MH_NATURAL) || berserk();</a>
<a name="ln8275">    case SPELL_PETRIFY:</a>
<a name="ln8276">        return res_petrify();</a>
<a name="ln8277">    case SPELL_PORKALATOR:</a>
<a name="ln8278">        return is_lifeless_undead();</a>
<a name="ln8279">    case SPELL_VIRULENCE:</a>
<a name="ln8280">        return res_poison() == 3;</a>
<a name="ln8281">    // don't include the hidden &quot;sleep immunity&quot; duration</a>
<a name="ln8282">    case SPELL_SLEEP:</a>
<a name="ln8283">    case SPELL_DREAM_DUST:</a>
<a name="ln8284">        return !actor::can_sleep();</a>
<a name="ln8285">    case SPELL_HIBERNATION:</a>
<a name="ln8286">        return !can_hibernate();</a>
<a name="ln8287">    default:</a>
<a name="ln8288">        return false;</a>
<a name="ln8289">    }</a>
<a name="ln8290">}</a>
<a name="ln8291"> </a>
<a name="ln8292">// Activate DUR_AGILE.</a>
<a name="ln8293">void player::be_agile(int pow)</a>
<a name="ln8294">{</a>
<a name="ln8295">    const bool were_agile = you.duration[DUR_AGILITY] &gt; 0;</a>
<a name="ln8296">    mprf(MSGCH_DURATION, &quot;You feel %sagile all of a sudden.&quot;,</a>
<a name="ln8297">         were_agile ? &quot;more &quot; : &quot;&quot;);</a>
<a name="ln8298"> </a>
<a name="ln8299">    you.increase_duration(DUR_AGILITY, 35 + random2(pow), 80);</a>
<a name="ln8300">    if (!were_agile)</a>
<a name="ln8301">        you.redraw_evasion = true;</a>
<a name="ln8302">}</a>

</code></pre>
<div class="balloon" rel="571"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v648/" target="_blank">V648</a> Priority of the '&&' operation is higher than that of the '||' operation.</p></div>
<div class="balloon" rel="819"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v648/" target="_blank">V648</a> Priority of the '&&' operation is higher than that of the '||' operation.</p></div>
<div class="balloon" rel="1507"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v648/" target="_blank">V648</a> Priority of the '&&' operation is higher than that of the '||' operation.</p></div>
<div class="balloon" rel="1540"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v648/" target="_blank">V648</a> Priority of the '&&' operation is higher than that of the '||' operation.</p></div>
<div class="balloon" rel="1824"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v648/" target="_blank">V648</a> Priority of the '&&' operation is higher than that of the '||' operation.</p></div>
<div class="balloon" rel="3191"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v547/" target="_blank">V547</a> Expression '!attrib.empty()' is always true.</p></div>
<div class="balloon" rel="4196"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v768/" target="_blank">V768</a> The expression 'you.undead_state()' is of enum type. It is odd that it is used as an expression of a Boolean-type.</p></div>
<div class="balloon" rel="4717"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v560/" target="_blank">V560</a> A part of conditional expression is always true: !quiet.</p></div>
<div class="balloon" rel="6141"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v768/" target="_blank">V768</a> The expression 'undead_state()' is of enum type. It is odd that it is used as an expression of a Boolean-type.</p></div>
<div class="balloon" rel="6210"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v648/" target="_blank">V648</a> Priority of the '&&' operation is higher than that of the '||' operation.</p></div>
<div class="balloon" rel="6229"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v648/" target="_blank">V648</a> Priority of the '&&' operation is higher than that of the '||' operation.</p></div>
<div class="balloon" rel="6292"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v648/" target="_blank">V648</a> Priority of the '&&' operation is higher than that of the '||' operation.</p></div>
<div class="balloon" rel="6411"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v547/" target="_blank">V547</a> Expression 'found_nonartefact' is always false.</p></div>
<div class="balloon" rel="7718"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v648/" target="_blank">V648</a> Priority of the '&&' operation is higher than that of the '||' operation.</p></div>

<link rel="stylesheet" href="highlight.css">
<script src="highlight.pack.js"></script>
<script src="highlightjs-line-numbers.js"></script>
<script>hljs.initHighlightingOnLoad();</script>
<script>hljs.initLineNumbersOnLoad();</script>
<script>
  $(document).ready(function() {
      $('.balloon').each(function () {
          var bl = $(this);
          var line = bl.attr('rel');
          var text = $('a[name="ln'+line+'"]').text();

          var space_count = 0;
          for(var i = 0; i<text.length; i++){
              var char = text[i];
              if((char !== ' ')&&(char !== '\t'))break;
              if(char === '\t')space_count++;
              space_count++;
          }

          bl.css('margin-left', space_count*8);
          $('a[name="ln'+line+'"]').after(bl);
      });

      window.location = window.location;
  });
</script>
</body>
</html>
