
<html>
<head>

  <meta http-equiv="Content-Type" content="text/html; charset=US-ASCII" />
  <title>mon-death.cc</title>

  <link rel="stylesheet" href="../style.css"/>
  <script src="../jquery-3.2.1.min.js"></script>
</head>
<body>

<pre><code class = "cpp">
<a name="ln1">/**</a>
<a name="ln2"> * @file</a>
<a name="ln3"> * @brief Contains monster death functionality, including unique code.</a>
<a name="ln4">**/</a>
<a name="ln5"> </a>
<a name="ln6">#include &quot;AppHdr.h&quot;</a>
<a name="ln7"> </a>
<a name="ln8">#include &quot;mon-death.h&quot;</a>
<a name="ln9"> </a>
<a name="ln10">#include &quot;act-iter.h&quot;</a>
<a name="ln11">#include &quot;areas.h&quot;</a>
<a name="ln12">#include &quot;arena.h&quot;</a>
<a name="ln13">#include &quot;artefact.h&quot;</a>
<a name="ln14">#include &quot;art-enum.h&quot;</a>
<a name="ln15">#include &quot;attitude-change.h&quot;</a>
<a name="ln16">#include &quot;bloodspatter.h&quot;</a>
<a name="ln17">#include &quot;butcher.h&quot;</a>
<a name="ln18">#include &quot;cloud.h&quot;</a>
<a name="ln19">#include &quot;cluautil.h&quot;</a>
<a name="ln20">#include &quot;colour.h&quot;</a>
<a name="ln21">#include &quot;coordit.h&quot;</a>
<a name="ln22">#include &quot;dactions.h&quot;</a>
<a name="ln23">#include &quot;database.h&quot;</a>
<a name="ln24">#include &quot;delay.h&quot;</a>
<a name="ln25">#include &quot;describe.h&quot;</a>
<a name="ln26">#include &quot;dgn-overview.h&quot;</a>
<a name="ln27">#include &quot;english.h&quot;</a>
<a name="ln28">#include &quot;env.h&quot;</a>
<a name="ln29">#include &quot;fineff.h&quot;</a>
<a name="ln30">#include &quot;food.h&quot;</a>
<a name="ln31">#include &quot;god-abil.h&quot;</a>
<a name="ln32">#include &quot;god-blessing.h&quot;</a>
<a name="ln33">#include &quot;god-companions.h&quot;</a>
<a name="ln34">#include &quot;god-conduct.h&quot;</a>
<a name="ln35">#include &quot;god-passive.h&quot; // passive_t::bless_followers, share_exp, convert_orcs</a>
<a name="ln36">#include &quot;hints.h&quot;</a>
<a name="ln37">#include &quot;hiscores.h&quot;</a>
<a name="ln38">#include &quot;item-name.h&quot;</a>
<a name="ln39">#include &quot;item-prop.h&quot;</a>
<a name="ln40">#include &quot;item-status-flag-type.h&quot;</a>
<a name="ln41">#include &quot;items.h&quot;</a>
<a name="ln42">#include &quot;kills.h&quot;</a>
<a name="ln43">#include &quot;libutil.h&quot;</a>
<a name="ln44">#include &quot;mapdef.h&quot;</a>
<a name="ln45">#include &quot;mapmark.h&quot;</a>
<a name="ln46">#include &quot;message.h&quot;</a>
<a name="ln47">#include &quot;mon-abil.h&quot;</a>
<a name="ln48">#include &quot;mon-behv.h&quot;</a>
<a name="ln49">#include &quot;mon-gear.h&quot;</a>
<a name="ln50">#include &quot;mon-place.h&quot;</a>
<a name="ln51">#include &quot;mon-poly.h&quot;</a>
<a name="ln52">#include &quot;mon-speak.h&quot;</a>
<a name="ln53">#include &quot;mon-tentacle.h&quot;</a>
<a name="ln54">#include &quot;mutation.h&quot;</a>
<a name="ln55">#include &quot;nearby-danger.h&quot;</a>
<a name="ln56">#include &quot;notes.h&quot;</a>
<a name="ln57">#include &quot;religion.h&quot;</a>
<a name="ln58">#include &quot;rot.h&quot;</a>
<a name="ln59">#include &quot;spl-damage.h&quot;</a>
<a name="ln60">#include &quot;spl-goditem.h&quot;</a>
<a name="ln61">#include &quot;spl-summoning.h&quot;</a>
<a name="ln62">#include &quot;sprint.h&quot; // SPRINT_MULTIPLIER</a>
<a name="ln63">#include &quot;state.h&quot;</a>
<a name="ln64">#include &quot;stepdown.h&quot;</a>
<a name="ln65">#include &quot;stringutil.h&quot;</a>
<a name="ln66">#include &quot;target.h&quot;</a>
<a name="ln67">#include &quot;terrain.h&quot;</a>
<a name="ln68">#include &quot;tilepick.h&quot;</a>
<a name="ln69">#include &quot;timed-effects.h&quot;</a>
<a name="ln70">#include &quot;traps.h&quot;</a>
<a name="ln71">#include &quot;unwind.h&quot;</a>
<a name="ln72">#include &quot;viewchar.h&quot;</a>
<a name="ln73">#include &quot;view.h&quot;</a>
<a name="ln74"> </a>
<a name="ln75">/**</a>
<a name="ln76"> * Initialise a corpse item.</a>
<a name="ln77"> *</a>
<a name="ln78"> * @param mons The monster to use as a template.</a>
<a name="ln79"> * @param corpse[out] The item that's filled in; no properties it already has</a>
<a name="ln80"> *                    are checked.</a>
<a name="ln81"> * @returns whether a corpse could be created.</a>
<a name="ln82"> */</a>
<a name="ln83">static bool _fill_out_corpse(const monster&amp; mons, item_def&amp; corpse)</a>
<a name="ln84">{</a>
<a name="ln85">    corpse.clear();</a>
<a name="ln86"> </a>
<a name="ln87">    monster_type mtype = mons.type;</a>
<a name="ln88">    monster_type corpse_class = mons_species(mtype);</a>
<a name="ln89"> </a>
<a name="ln90">    ASSERT(!invalid_monster_type(mtype));</a>
<a name="ln91">    ASSERT(!invalid_monster_type(corpse_class));</a>
<a name="ln92"> </a>
<a name="ln93">    if (mons_genus(mtype) == MONS_DRACONIAN</a>
<a name="ln94">        || mons_genus(mtype) == MONS_DEMONSPAWN)</a>
<a name="ln95">    {</a>
<a name="ln96">        if (mons.type == MONS_TIAMAT)</a>
<a name="ln97">            corpse_class = MONS_DRACONIAN;</a>
<a name="ln98">        else</a>
<a name="ln99">            corpse_class = draco_or_demonspawn_subspecies(mons);</a>
<a name="ln100">    }</a>
<a name="ln101"> </a>
<a name="ln102">    if (mons.props.exists(ORIGINAL_TYPE_KEY))</a>
<a name="ln103">    {</a>
<a name="ln104">        // Shapeshifters too.</a>
<a name="ln105">        mtype = (monster_type) mons.props[ORIGINAL_TYPE_KEY].get_int();</a>
<a name="ln106">        corpse_class = mons_species(mtype);</a>
<a name="ln107">    }</a>
<a name="ln108"> </a>
<a name="ln109">    if (!mons_class_can_leave_corpse(corpse_class))</a>
<a name="ln110">        return false;</a>
<a name="ln111"> </a>
<a name="ln112">    corpse.base_type      = OBJ_CORPSES;</a>
<a name="ln113">    corpse.mon_type       = corpse_class;</a>
<a name="ln114">    corpse.sub_type       = CORPSE_BODY;</a>
<a name="ln115">    corpse.freshness      = FRESHEST_CORPSE;  // rot time</a>
<a name="ln116">    corpse.quantity       = 1;</a>
<a name="ln117">    corpse.rnd            = 1 + random2(255);</a>
<a name="ln118">    corpse.orig_monnum    = mtype;</a>
<a name="ln119"> </a>
<a name="ln120">    corpse.props[MONSTER_HIT_DICE] = short(mons.get_experience_level());</a>
<a name="ln121">    if (mons.mons_species() == MONS_HYDRA)</a>
<a name="ln122">        corpse.props[CORPSE_HEADS] = short(mons.heads());</a>
<a name="ln123">    if (mons.props.exists(&quot;old_heads&quot;))</a>
<a name="ln124">        corpse.props[CORPSE_HEADS] = short(mons.props[&quot;old_heads&quot;].get_int());</a>
<a name="ln125">    COMPILE_CHECK(sizeof(mid_t) == sizeof(int));</a>
<a name="ln126">    corpse.props[MONSTER_MID]      = int(mons.mid);</a>
<a name="ln127"> </a>
<a name="ln128">    monster_info minfo(corpse_class);</a>
<a name="ln129">    int col = int(minfo.colour());</a>
<a name="ln130">    if (col == COLOUR_UNDEF)</a>
<a name="ln131">    {</a>
<a name="ln132">        // XXX hack to avoid crashing in wiz mode.</a>
<a name="ln133">        if (mons_is_ghost_demon(mons.type) &amp;&amp; !mons.ghost)</a>
<a name="ln134">            col = LIGHTRED;</a>
<a name="ln135">        else</a>
<a name="ln136">        {</a>
<a name="ln137">            minfo = monster_info(&amp;mons);</a>
<a name="ln138">            col = int(minfo.colour());</a>
<a name="ln139">        }</a>
<a name="ln140">    }</a>
<a name="ln141">    if (col == COLOUR_UNDEF)</a>
<a name="ln142">        col = int(random_colour());</a>
<a name="ln143">    corpse.props[FORCED_ITEM_COLOUR_KEY] = col;</a>
<a name="ln144"> </a>
<a name="ln145">    if (!mons.mname.empty() &amp;&amp; !(mons.flags &amp; MF_NAME_NOCORPSE))</a>
<a name="ln146">    {</a>
<a name="ln147">        corpse.props[CORPSE_NAME_KEY] = mons.mname;</a>
<a name="ln148">        corpse.props[CORPSE_NAME_TYPE_KEY].get_int64() = mons.flags.flags;</a>
<a name="ln149">    }</a>
<a name="ln150">    else if (mons_is_unique(mtype))</a>
<a name="ln151">    {</a>
<a name="ln152">        corpse.props[CORPSE_NAME_KEY] = mons_type_name(mtype, DESC_PLAIN);</a>
<a name="ln153">        corpse.props[CORPSE_NAME_TYPE_KEY].get_int64() = 0;</a>
<a name="ln154">    }</a>
<a name="ln155"> </a>
<a name="ln156">    // 0 mid indicates this is a dummy monster, such as for kiku corpse drop</a>
<a name="ln157">    if (mons_genus(mons.type) == MONS_ORC &amp;&amp; mons.mid != 0)</a>
<a name="ln158">    {</a>
<a name="ln159">        auto &amp;saved_mon = corpse.props[ORC_CORPSE_KEY].get_monster();</a>
<a name="ln160">        saved_mon = mons;</a>
<a name="ln161"> </a>
<a name="ln162">        // Ensure that saved_mon is alive, lest it be cleared on marshall.</a>
<a name="ln163">        if (saved_mon.max_hit_points &lt;= 0)</a>
<a name="ln164">            saved_mon.max_hit_points = 1;</a>
<a name="ln165">        saved_mon.hit_points = saved_mon.max_hit_points;</a>
<a name="ln166">    }</a>
<a name="ln167"> </a>
<a name="ln168">    return true;</a>
<a name="ln169">}</a>
<a name="ln170"> </a>
<a name="ln171">static bool _explode_corpse(item_def&amp; corpse, const coord_def&amp; where)</a>
<a name="ln172">{</a>
<a name="ln173">    // Don't want chunks to show up behind the player.</a>
<a name="ln174">    los_def ld(where, opc_no_actor);</a>
<a name="ln175"> </a>
<a name="ln176">    if (mons_class_leaves_hide(corpse.mon_type)</a>
<a name="ln177">        &amp;&amp; mons_genus(corpse.mon_type) == MONS_DRAGON)</a>
<a name="ln178">    {</a>
<a name="ln179">        // Uh... dragon hide is tough stuff and it keeps the monster in</a>
<a name="ln180">        // one piece?  More importantly, it prevents a flavour feature</a>
<a name="ln181">        // from becoming a trap for the unwary.</a>
<a name="ln182"> </a>
<a name="ln183">        return false;</a>
<a name="ln184">    }</a>
<a name="ln185"> </a>
<a name="ln186">    ld.update();</a>
<a name="ln187"> </a>
<a name="ln188">    const int max_chunks = max_corpse_chunks(corpse.mon_type);</a>
<a name="ln189">    const int nchunks = stepdown_value(1 + random2(max_chunks), 4, 4, 12, 12);</a>
<a name="ln190">    if (corpse.base_type != OBJ_GOLD)</a>
<a name="ln191">        blood_spray(where, corpse.mon_type, nchunks * 3); // spray some blood</a>
<a name="ln192"> </a>
<a name="ln193">    // Don't let the player evade food conducts by using OOD (!) or /disint</a>
<a name="ln194">    // Spray blood, but no chunks. (The mighty hand of your God squashes them</a>
<a name="ln195">    // in mid-flight...!)</a>
<a name="ln196">    if (is_forbidden_food(corpse))</a>
<a name="ln197">        return true;</a>
<a name="ln198"> </a>
<a name="ln199">    // turn the corpse into chunks</a>
<a name="ln200">    if (corpse.base_type != OBJ_GOLD)</a>
<a name="ln201">    {</a>
<a name="ln202">        corpse.base_type = OBJ_FOOD;</a>
<a name="ln203">        corpse.sub_type  = FOOD_CHUNK;</a>
<a name="ln204">        if (is_bad_food(corpse))</a>
<a name="ln205">            corpse.flags |= ISFLAG_DROPPED;</a>
<a name="ln206">    }</a>
<a name="ln207"> </a>
<a name="ln208">    const int total_gold = corpse.quantity;</a>
<a name="ln209"> </a>
<a name="ln210">    // spray chunks everywhere!</a>
<a name="ln211">    for (int ntries = 0, chunks_made = 0;</a>
<a name="ln212">         chunks_made &lt; nchunks &amp;&amp; ntries &lt; 10000; ++ntries)</a>
<a name="ln213">    {</a>
<a name="ln214">        coord_def cp = where;</a>
<a name="ln215">        cp.x += random_range(-LOS_DEFAULT_RANGE, LOS_DEFAULT_RANGE);</a>
<a name="ln216">        cp.y += random_range(-LOS_DEFAULT_RANGE, LOS_DEFAULT_RANGE);</a>
<a name="ln217"> </a>
<a name="ln218">        dprf(&quot;Trying to scatter chunk to %d, %d...&quot;, cp.x, cp.y);</a>
<a name="ln219"> </a>
<a name="ln220">        if (!in_bounds(cp))</a>
<a name="ln221">            continue;</a>
<a name="ln222"> </a>
<a name="ln223">        if (!ld.see_cell(cp))</a>
<a name="ln224">            continue;</a>
<a name="ln225"> </a>
<a name="ln226">        dprf(&quot;Cell is visible...&quot;);</a>
<a name="ln227"> </a>
<a name="ln228">        if (cell_is_solid(cp) || actor_at(cp))</a>
<a name="ln229">            continue;</a>
<a name="ln230"> </a>
<a name="ln231">        ++chunks_made;</a>
<a name="ln232"> </a>
<a name="ln233">        dprf(&quot;Success&quot;);</a>
<a name="ln234"> </a>
<a name="ln235">        if (corpse.base_type == OBJ_GOLD)</a>
<a name="ln236">            corpse.quantity = div_rand_round(total_gold, nchunks);</a>
<a name="ln237">        if (corpse.quantity)</a>
<a name="ln238">            copy_item_to_grid(corpse, cp);</a>
<a name="ln239">    }</a>
<a name="ln240"> </a>
<a name="ln241">    return true;</a>
<a name="ln242">}</a>
<a name="ln243"> </a>
<a name="ln244">static int _calc_monster_experience(monster* victim, killer_type killer,</a>
<a name="ln245">                                    int killer_index)</a>
<a name="ln246">{</a>
<a name="ln247">    const int experience = exper_value(*victim);</a>
<a name="ln248"> </a>
<a name="ln249">    if (!experience || !MON_KILL(killer) || invalid_monster_index(killer_index))</a>
<a name="ln250">        return 0;</a>
<a name="ln251"> </a>
<a name="ln252">    monster* mon = &amp;menv[killer_index];</a>
<a name="ln253">    if (!mon-&gt;alive() || !mons_gives_xp(*victim, *mon))</a>
<a name="ln254">        return 0;</a>
<a name="ln255"> </a>
<a name="ln256">    return experience;</a>
<a name="ln257">}</a>
<a name="ln258"> </a>
<a name="ln259">static void _give_monster_experience(int experience, int killer_index)</a>
<a name="ln260">{</a>
<a name="ln261">    if (experience &lt;= 0 || invalid_monster_index(killer_index))</a>
<a name="ln262">        return;</a>
<a name="ln263"> </a>
<a name="ln264">    monster* mon = &amp;menv[killer_index];</a>
<a name="ln265">    if (!mon-&gt;alive())</a>
<a name="ln266">        return;</a>
<a name="ln267"> </a>
<a name="ln268">    if (mon-&gt;gain_exp(experience))</a>
<a name="ln269">    {</a>
<a name="ln270">        if (!have_passive(passive_t::bless_followers) || !one_chance_in(3))</a>
<a name="ln271">            return;</a>
<a name="ln272"> </a>
<a name="ln273">        // Randomly bless the follower who gained experience.</a>
<a name="ln274">        if (random2(you.piety) &gt;= piety_breakpoint(2))</a>
<a name="ln275">            bless_follower(mon);</a>
<a name="ln276">    }</a>
<a name="ln277">}</a>
<a name="ln278"> </a>
<a name="ln279">static void _beogh_spread_experience(int exp)</a>
<a name="ln280">{</a>
<a name="ln281">    int total_hd = 0;</a>
<a name="ln282"> </a>
<a name="ln283">    for (monster_near_iterator mi(&amp;you); mi; ++mi)</a>
<a name="ln284">    {</a>
<a name="ln285">        if (is_orcish_follower(**mi))</a>
<a name="ln286">            total_hd += mi-&gt;get_experience_level();</a>
<a name="ln287">    }</a>
<a name="ln288"> </a>
<a name="ln289">    if (total_hd &lt;= 0)</a>
<a name="ln290">        return;</a>
<a name="ln291"> </a>
<a name="ln292">    for (monster_near_iterator mi(&amp;you); mi; ++mi)</a>
<a name="ln293">        if (is_orcish_follower(**mi))</a>
<a name="ln294">        {</a>
<a name="ln295">            _give_monster_experience(exp * mi-&gt;get_experience_level() / total_hd,</a>
<a name="ln296">                                         mi-&gt;mindex());</a>
<a name="ln297">        }</a>
<a name="ln298">}</a>
<a name="ln299"> </a>
<a name="ln300">static int _calc_player_experience(const monster* mons)</a>
<a name="ln301">{</a>
<a name="ln302">    int experience = exper_value(*mons);</a>
<a name="ln303">    if (!experience)</a>
<a name="ln304">        return 0;</a>
<a name="ln305"> </a>
<a name="ln306">    const bool already_got_half_xp = testbits(mons-&gt;flags, MF_PACIFIED);</a>
<a name="ln307">    const int half_xp = (experience + 1) / 2;</a>
<a name="ln308"> </a>
<a name="ln309">    if (!mons-&gt;damage_total)</a>
<a name="ln310">    {</a>
<a name="ln311">        mprf(MSGCH_WARN, &quot;Error, exp for monster with no damage: %s&quot;,</a>
<a name="ln312">             mons-&gt;name(DESC_PLAIN, true).c_str());</a>
<a name="ln313">        return 0;</a>
<a name="ln314">    }</a>
<a name="ln315"> </a>
<a name="ln316">    experience = (experience * mons-&gt;damage_friendly / mons-&gt;damage_total</a>
<a name="ln317">                  + 1) / 2;</a>
<a name="ln318">    ASSERT(mons-&gt;damage_friendly &lt;= 2 * mons-&gt;damage_total);</a>
<a name="ln319"> </a>
<a name="ln320">    // Note: This doesn't happen currently since monsters with</a>
<a name="ln321">    //       MF_PACIFIED have always gone through pacification,</a>
<a name="ln322">    //       hence also have MF_WAS_NEUTRAL. [rob]</a>
<a name="ln323">    if (already_got_half_xp)</a>
<a name="ln324">    {</a>
<a name="ln325">        experience -= half_xp;</a>
<a name="ln326">        if (experience &lt; 0)</a>
<a name="ln327">            experience = 0;</a>
<a name="ln328">    }</a>
<a name="ln329"> </a>
<a name="ln330">    return experience;</a>
<a name="ln331">}</a>
<a name="ln332"> </a>
<a name="ln333">static void _give_player_experience(int experience, killer_type killer,</a>
<a name="ln334">                                    bool pet_kill, bool was_visible,</a>
<a name="ln335">                                    xp_tracking_type xp_tracking)</a>
<a name="ln336">{</a>
<a name="ln337">    if (experience &lt;= 0 || crawl_state.game_is_arena())</a>
<a name="ln338">        return;</a>
<a name="ln339"> </a>
<a name="ln340">    unsigned int exp_gain = 0;</a>
<a name="ln341">    gain_exp(experience, &amp;exp_gain);</a>
<a name="ln342"> </a>
<a name="ln343">    kill_category kc =</a>
<a name="ln344">            (killer == KILL_YOU || killer == KILL_YOU_MISSILE) ? KC_YOU :</a>
<a name="ln345">            (pet_kill)                                         ? KC_FRIENDLY :</a>
<a name="ln346">                                                                 KC_OTHER;</a>
<a name="ln347">    PlaceInfo&amp; curr_PlaceInfo = you.get_place_info();</a>
<a name="ln348">    PlaceInfo  delta;</a>
<a name="ln349"> </a>
<a name="ln350">    delta.mon_kill_num[kc]++;</a>
<a name="ln351">    delta.mon_kill_exp += exp_gain;</a>
<a name="ln352"> </a>
<a name="ln353">    you.global_info += delta;</a>
<a name="ln354">    you.global_info.assert_validity();</a>
<a name="ln355"> </a>
<a name="ln356">    curr_PlaceInfo += delta;</a>
<a name="ln357">    curr_PlaceInfo.assert_validity();</a>
<a name="ln358"> </a>
<a name="ln359">    LevelXPInfo&amp; curr_xp_info = you.get_level_xp_info();</a>
<a name="ln360">    LevelXPInfo xp_delta;</a>
<a name="ln361"> </a>
<a name="ln362">    if (xp_tracking == XP_NON_VAULT)</a>
<a name="ln363">    {</a>
<a name="ln364">        xp_delta.non_vault_xp += exp_gain;</a>
<a name="ln365">        xp_delta.non_vault_count++;</a>
<a name="ln366">    }</a>
<a name="ln367">    else if (xp_tracking == XP_VAULT)</a>
<a name="ln368">    {</a>
<a name="ln369">        xp_delta.vault_xp += exp_gain;</a>
<a name="ln370">        xp_delta.vault_count++;</a>
<a name="ln371">    }</a>
<a name="ln372"> </a>
<a name="ln373">    you.global_xp_info += xp_delta;</a>
<a name="ln374">    you.global_xp_info.assert_validity();</a>
<a name="ln375"> </a>
<a name="ln376">    curr_xp_info += xp_delta;</a>
<a name="ln377">    curr_xp_info.assert_validity();</a>
<a name="ln378"> </a>
<a name="ln379">    // Give a message for monsters dying out of sight.</a>
<a name="ln380">    if (exp_gain &gt; 0 &amp;&amp; !was_visible)</a>
<a name="ln381">        mpr(&quot;You feel a bit more experienced.&quot;);</a>
<a name="ln382"> </a>
<a name="ln383">    if (kc == KC_YOU &amp;&amp; have_passive(passive_t::share_exp))</a>
<a name="ln384">        _beogh_spread_experience(experience / 2);</a>
<a name="ln385">}</a>
<a name="ln386"> </a>
<a name="ln387">static void _give_experience(int player_exp, int monster_exp,</a>
<a name="ln388">                             killer_type killer, int killer_index,</a>
<a name="ln389">                             bool pet_kill, bool was_visible,</a>
<a name="ln390">                             xp_tracking_type xp_tracking)</a>
<a name="ln391">{</a>
<a name="ln392">    _give_player_experience(player_exp, killer, pet_kill, was_visible,</a>
<a name="ln393">            xp_tracking);</a>
<a name="ln394">    _give_monster_experience(monster_exp, killer_index);</a>
<a name="ln395">}</a>
<a name="ln396"> </a>
<a name="ln397">/**</a>
<a name="ln398"> * Makes an item into gold. Praise Gozag!</a>
<a name="ln399"> *</a>
<a name="ln400"> * Gold is random, but correlates weakly with monster mass.</a>
<a name="ln401"> *</a>
<a name="ln402"> * Also sets the gold distraction timer on the player.</a>
<a name="ln403"> *</a>
<a name="ln404"> * @param corpse[out] The item to be Midasified.</a>
<a name="ln405"> */</a>
<a name="ln406">static void _gold_pile(item_def &amp;corpse, monster_type corpse_class)</a>
<a name="ln407">{</a>
<a name="ln408">    corpse.clear();</a>
<a name="ln409"> </a>
<a name="ln410">    int base_gold = 7;</a>
<a name="ln411">    // monsters with more chunks than SIZE_MEDIUM give more than base gold</a>
<a name="ln412">    const int extra_chunks = (max_corpse_chunks(corpse_class)</a>
<a name="ln413">                              - max_corpse_chunks(MONS_HUMAN)) * 2;</a>
<a name="ln414">    if (extra_chunks &gt; 0)</a>
<a name="ln415">        base_gold += extra_chunks;</a>
<a name="ln416"> </a>
<a name="ln417">    corpse.base_type = OBJ_GOLD;</a>
<a name="ln418">    corpse.mon_type = corpse_class; // for _explode_corpse</a>
<a name="ln419">    corpse.quantity = base_gold / 2 + random2avg(base_gold, 2);</a>
<a name="ln420">    item_colour(corpse);</a>
<a name="ln421"> </a>
<a name="ln422">    // Apply the gold aura effect to the player.</a>
<a name="ln423">    const int dur = corpse.quantity * 2;</a>
<a name="ln424">    if (dur &gt; you.duration[DUR_GOZAG_GOLD_AURA])</a>
<a name="ln425">        you.set_duration(DUR_GOZAG_GOLD_AURA, dur);</a>
<a name="ln426"> </a>
<a name="ln427">    // In sprint, increase the amount of gold from corpses (but not</a>
<a name="ln428">    // the gold aura duration!)</a>
<a name="ln429">    if (crawl_state.game_is_sprint())</a>
<a name="ln430">        corpse.quantity *= SPRINT_MULTIPLIER;</a>
<a name="ln431"> </a>
<a name="ln432">    const int chance = you.props[GOZAG_GOLD_AURA_KEY].get_int();</a>
<a name="ln433">    if (!x_chance_in_y(chance, chance + 9))</a>
<a name="ln434">        ++you.props[GOZAG_GOLD_AURA_KEY].get_int();</a>
<a name="ln435">    you.redraw_title = true;</a>
<a name="ln436">}</a>
<a name="ln437"> </a>
<a name="ln438">static void _create_monster_hide(const item_def &amp;corpse, bool silent)</a>
<a name="ln439">{</a>
<a name="ln440">    const monster_type mtyp = corpse.mon_type;</a>
<a name="ln441">    const armour_type type = hide_for_monster(mons_species(mtyp));</a>
<a name="ln442">    ASSERT(type != NUM_ARMOURS);</a>
<a name="ln443"> </a>
<a name="ln444">    int o = items(false, OBJ_ARMOUR, type, 0);</a>
<a name="ln445">    squash_plusses(o);</a>
<a name="ln446"> </a>
<a name="ln447">    if (o == NON_ITEM)</a>
<a name="ln448">        return;</a>
<a name="ln449">    item_def&amp; item = mitm[o];</a>
<a name="ln450"> </a>
<a name="ln451">    do_uncurse_item(item);</a>
<a name="ln452"> </a>
<a name="ln453">    const monster_type montype =</a>
<a name="ln454">        static_cast&lt;monster_type&gt;(corpse.orig_monnum);</a>
<a name="ln455">    if (!invalid_monster_type(montype) &amp;&amp; mons_is_unique(montype))</a>
<a name="ln456">        item.inscription = mons_type_name(montype, DESC_PLAIN);</a>
<a name="ln457"> </a>
<a name="ln458">    /// Slightly randomized bonus enchantment for certain uniques' hides</a>
<a name="ln459">    static const map&lt;monster_type, int&gt; hide_avg_plusses = {</a>
<a name="ln460">        { MONS_SNORG, 2 },</a>
<a name="ln461">        { MONS_XTAHUA, 3 },</a>
<a name="ln462">        { MONS_BAI_SUZHEN, 3 },</a>
<a name="ln463">        { MONS_BAI_SUZHEN_DRAGON, 3 },</a>
<a name="ln464">    };</a>
<a name="ln465"> </a>
<a name="ln466">    if (mtyp == MONS_DEEP_TROLL)</a>
<a name="ln467">    {</a>
<a name="ln468">        item.props[&quot;item_tile_name&quot;] = &quot;deep_troll_leather&quot;;</a>
<a name="ln469">        item.props[&quot;worn_tile_name&quot;] = &quot;deep_troll_leather&quot;;</a>
<a name="ln470">        bind_item_tile(item);</a>
<a name="ln471">    }</a>
<a name="ln472">    else if (mtyp == MONS_IRON_TROLL)</a>
<a name="ln473">    {</a>
<a name="ln474">        item.props[&quot;item_tile_name&quot;] = &quot;iron_troll_leather&quot;;</a>
<a name="ln475">        item.props[&quot;worn_tile_name&quot;] = &quot;iron_troll_leather&quot;;</a>
<a name="ln476">        bind_item_tile(item);</a>
<a name="ln477">    }</a>
<a name="ln478"> </a>
<a name="ln479">    const int* bonus_plus = map_find(hide_avg_plusses, montype);</a>
<a name="ln480">    if (bonus_plus)</a>
<a name="ln481">        item.plus += random_range(*bonus_plus * 2/3, *bonus_plus * 3/2);</a>
<a name="ln482"> </a>
<a name="ln483">    const coord_def pos = item_pos(corpse);</a>
<a name="ln484">    if (pos.origin())</a>
<a name="ln485">    {</a>
<a name="ln486">        set_ident_flags(item, ISFLAG_IDENT_MASK);</a>
<a name="ln487">        return;</a>
<a name="ln488">    }</a>
<a name="ln489"> </a>
<a name="ln490">    move_item_to_grid(&amp;o, pos);</a>
<a name="ln491"> </a>
<a name="ln492">    // Don't display this message if the scales were dropped over</a>
<a name="ln493">    // lava/deep water, because then they are hardly intact.</a>
<a name="ln494">    if (you.see_cell(pos) &amp;&amp; !silent &amp;&amp; !feat_eliminates_items(grd(pos)))</a>
<a name="ln495">    {</a>
<a name="ln496">        // XXX: tweak for uniques/named monsters, somehow?</a>
<a name="ln497">        mprf(&quot;%s %s intact enough to wear.&quot;,</a>
<a name="ln498">             item.name(DESC_THE).c_str(),</a>
<a name="ln499">             mons_genus(mtyp) == MONS_DRAGON ? &quot;are&quot;  // scales are</a>
<a name="ln500">                                             : &quot;is&quot;); // troll armour is</a>
<a name="ln501">                                                      // XXX: refactor</a>
<a name="ln502">    }</a>
<a name="ln503"> </a>
<a name="ln504">    // after messaging, for better results</a>
<a name="ln505">    set_ident_flags(item, ISFLAG_IDENT_MASK);</a>
<a name="ln506">}</a>
<a name="ln507"> </a>
<a name="ln508">static void _maybe_drop_monster_hide(const item_def &amp;corpse, bool silent)</a>
<a name="ln509">{</a>
<a name="ln510">    if (mons_class_leaves_hide(corpse.mon_type) &amp;&amp; !one_chance_in(3))</a>
<a name="ln511">        _create_monster_hide(corpse, silent);</a>
<a name="ln512">}</a>
<a name="ln513"> </a>
<a name="ln514">/**</a>
<a name="ln515"> * Create this monster's corpse in mitm at its position.</a>
<a name="ln516"> *</a>
<a name="ln517"> * @param mons the monster to corpsify</a>
<a name="ln518"> * @param silent whether to suppress all messages</a>
<a name="ln519"> * @param force whether to always make a corpse (no 50% chance not to make a</a>
<a name="ln520">                corpse, no goldification, no hides -- being summoned etc. still</a>
<a name="ln521">  *             matters, though)</a>
<a name="ln522"> * @returns a pointer to an item; it may be null, if the monster can't leave a</a>
<a name="ln523"> *          corpse or if the 50% chance is rolled; it may be gold, if the player</a>
<a name="ln524"> *          worships Gozag, or it may be the corpse.</a>
<a name="ln525"> */</a>
<a name="ln526">item_def* place_monster_corpse(const monster&amp; mons, bool silent, bool force)</a>
<a name="ln527">{</a>
<a name="ln528">    if (mons.is_summoned()</a>
<a name="ln529">        || mons.flags &amp; (MF_BANISHED | MF_HARD_RESET)</a>
<a name="ln530">        || mons.props.exists(&quot;pikel_band&quot;))</a>
<a name="ln531">    {</a>
<a name="ln532">        return nullptr;</a>
<a name="ln533">    }</a>
<a name="ln534"> </a>
<a name="ln535">    // Under Gozag, monsters turn into gold on death.</a>
<a name="ln536">    // Temporary Tukima's Dance weapons stay as weapons (no free gold),</a>
<a name="ln537">    // permanent dancing weapons turn to gold like other monsters.</a>
<a name="ln538">    bool goldify = have_passive(passive_t::goldify_corpses)</a>
<a name="ln539">                   &amp;&amp; mons_gives_xp(mons, you)</a>
<a name="ln540">                   &amp;&amp; !force;</a>
<a name="ln541"> </a>
<a name="ln542">    const bool no_coinflip = mons.props.exists(&quot;always_corpse&quot;)</a>
<a name="ln543">                             || force</a>
<a name="ln544">                             || goldify;</a>
<a name="ln545"> </a>
<a name="ln546">    // 50/50 chance of getting a corpse, usually.</a>
<a name="ln547">    if (!no_coinflip &amp;&amp; coinflip())</a>
<a name="ln548">        return nullptr;</a>
<a name="ln549"> </a>
<a name="ln550">    // The game can attempt to place a corpse for an out-of-bounds monster</a>
<a name="ln551">    // if a shifter turns into a ballistomycete spore and explodes. In this</a>
<a name="ln552">    // case we place no corpse since the explosion means anything left</a>
<a name="ln553">    // over would be scattered, tiny chunks of shifter.</a>
<a name="ln554">    if (!in_bounds(mons.pos()) &amp;&amp; !force)</a>
<a name="ln555">        return nullptr;</a>
<a name="ln556"> </a>
<a name="ln557">    // Don't attempt to place corpses within walls, either.</a>
<a name="ln558">    if (feat_is_solid(grd(mons.pos())) &amp;&amp; !force)</a>
<a name="ln559">        return nullptr;</a>
<a name="ln560"> </a>
<a name="ln561">    // If we were told not to leave a corpse, don't.</a>
<a name="ln562">    if (mons.props.exists(NEVER_CORPSE_KEY))</a>
<a name="ln563">        return nullptr;</a>
<a name="ln564"> </a>
<a name="ln565">    int o = get_mitm_slot();</a>
<a name="ln566"> </a>
<a name="ln567">    if (o == NON_ITEM)</a>
<a name="ln568">        return nullptr;</a>
<a name="ln569"> </a>
<a name="ln570">    item_def&amp; corpse(mitm[o]);</a>
<a name="ln571">    if (goldify)</a>
<a name="ln572">    {</a>
<a name="ln573">        _gold_pile(corpse, mons_species(mons.type));</a>
<a name="ln574">        // If gold would be destroyed, give it directly to the player instead.</a>
<a name="ln575">        if (feat_eliminates_items(grd(mons.pos())))</a>
<a name="ln576">        {</a>
<a name="ln577">            get_gold(corpse, corpse.quantity, false);</a>
<a name="ln578">            destroy_item(corpse, true);</a>
<a name="ln579">            return nullptr;</a>
<a name="ln580">        }</a>
<a name="ln581">    }</a>
<a name="ln582">    else if (!_fill_out_corpse(mons, corpse))</a>
<a name="ln583">        return nullptr;</a>
<a name="ln584"> </a>
<a name="ln585">    origin_set_monster(corpse, &amp;mons);</a>
<a name="ln586"> </a>
<a name="ln587">    if ((mons.flags &amp; MF_EXPLODE_KILL) &amp;&amp; _explode_corpse(corpse, mons.pos()))</a>
<a name="ln588">    {</a>
<a name="ln589">        // We already have a spray of chunks.</a>
<a name="ln590">        item_was_destroyed(corpse);</a>
<a name="ln591">        destroy_item(o);</a>
<a name="ln592">        return nullptr;</a>
<a name="ln593">    }</a>
<a name="ln594"> </a>
<a name="ln595">    if (in_bounds(mons.pos()))</a>
<a name="ln596">        move_item_to_grid(&amp;o, mons.pos(), !mons.swimming());</a>
<a name="ln597"> </a>
<a name="ln598">    if (o == NON_ITEM)</a>
<a name="ln599">        return nullptr;</a>
<a name="ln600"> </a>
<a name="ln601">    if (you.see_cell(mons.pos()) &amp;&amp; !silent &amp;&amp; !goldify)</a>
<a name="ln602">        hints_dissection_reminder();</a>
<a name="ln603"> </a>
<a name="ln604">    return &amp;mitm[o];</a>
<a name="ln605">}</a>
<a name="ln606"> </a>
<a name="ln607">static void _hints_inspect_kill()</a>
<a name="ln608">{</a>
<a name="ln609">    if (Hints.hints_events[HINT_KILLED_MONSTER])</a>
<a name="ln610">        learned_something_new(HINT_KILLED_MONSTER);</a>
<a name="ln611">}</a>
<a name="ln612"> </a>
<a name="ln613">static string _milestone_kill_verb(killer_type killer)</a>
<a name="ln614">{</a>
<a name="ln615">    return killer == KILL_BANISHED ? &quot;banished&quot; :</a>
<a name="ln616">           killer == KILL_PACIFIED ? &quot;pacified&quot; :</a>
<a name="ln617">           killer == KILL_ENSLAVED ? &quot;enslaved&quot; :</a>
<a name="ln618">           killer == KILL_SLIMIFIED ? &quot;slimified&quot; : &quot;killed&quot;;</a>
<a name="ln619">}</a>
<a name="ln620"> </a>
<a name="ln621">void record_monster_defeat(const monster* mons, killer_type killer)</a>
<a name="ln622">{</a>
<a name="ln623">    if (crawl_state.game_is_arena())</a>
<a name="ln624">        return;</a>
<a name="ln625">    if (killer == KILL_RESET || killer == KILL_DISMISSED)</a>
<a name="ln626">        return;</a>
<a name="ln627">    if (mons-&gt;has_ench(ENCH_FAKE_ABJURATION) || mons-&gt;is_summoned())</a>
<a name="ln628">        return;</a>
<a name="ln629">    if (mons-&gt;is_named() &amp;&amp; mons-&gt;friendly()</a>
<a name="ln630">        &amp;&amp; !mons_is_hepliaklqana_ancestor(mons-&gt;type))</a>
<a name="ln631">    {</a>
<a name="ln632">        take_note(Note(NOTE_ALLY_DEATH, 0, 0, mons-&gt;mname));</a>
<a name="ln633">    }</a>
<a name="ln634">    else if (mons_is_notable(*mons))</a>
<a name="ln635">    {</a>
<a name="ln636">        take_note(Note(NOTE_DEFEAT_MONSTER, mons-&gt;type, mons-&gt;friendly(),</a>
<a name="ln637">                       mons-&gt;full_name(DESC_A).c_str(),</a>
<a name="ln638">                       _milestone_kill_verb(killer).c_str()));</a>
<a name="ln639">    }</a>
<a name="ln640">    if (mons-&gt;type == MONS_PLAYER_GHOST)</a>
<a name="ln641">    {</a>
<a name="ln642">        monster_info mi(mons);</a>
<a name="ln643">        string milestone = _milestone_kill_verb(killer) + &quot; the ghost of &quot;;</a>
<a name="ln644">        milestone += get_ghost_description(mi, true);</a>
<a name="ln645">        milestone += &quot;.&quot;;</a>
<a name="ln646">        mark_milestone(&quot;ghost&quot;, milestone);</a>
<a name="ln647">    }</a>
<a name="ln648">    if (mons_is_or_was_unique(*mons) &amp;&amp; !testbits(mons-&gt;flags, MF_SPECTRALISED))</a>
<a name="ln649">    {</a>
<a name="ln650">        mark_milestone(&quot;uniq&quot;,</a>
<a name="ln651">                       _milestone_kill_verb(killer)</a>
<a name="ln652">                       + &quot; &quot;</a>
<a name="ln653">                       + mons-&gt;name(DESC_THE, true)</a>
<a name="ln654">                       + &quot;.&quot;);</a>
<a name="ln655">    }</a>
<a name="ln656">}</a>
<a name="ln657"> </a>
<a name="ln658">static bool _is_pet_kill(killer_type killer, int i)</a>
<a name="ln659">{</a>
<a name="ln660">    if (!MON_KILL(killer))</a>
<a name="ln661">        return false;</a>
<a name="ln662"> </a>
<a name="ln663">    if (i == ANON_FRIENDLY_MONSTER)</a>
<a name="ln664">        return true;</a>
<a name="ln665"> </a>
<a name="ln666">    if (invalid_monster_index(i))</a>
<a name="ln667">        return false;</a>
<a name="ln668"> </a>
<a name="ln669">    const monster* m = &amp;menv[i];</a>
<a name="ln670">    if (m-&gt;friendly()) // This includes enslaved monsters.</a>
<a name="ln671">        return true;</a>
<a name="ln672"> </a>
<a name="ln673">    // Check if the monster was confused by you or a friendly, which</a>
<a name="ln674">    // makes casualties to this monster collateral kills.</a>
<a name="ln675">    const mon_enchant me = m-&gt;get_ench(ENCH_CONFUSION);</a>
<a name="ln676">    const mon_enchant me2 = m-&gt;get_ench(ENCH_INSANE);</a>
<a name="ln677">    return me.ench == ENCH_CONFUSION</a>
<a name="ln678">           &amp;&amp; (me.who == KC_YOU || me.who == KC_FRIENDLY)</a>
<a name="ln679">           || me2.ench == ENCH_INSANE</a>
<a name="ln680">              &amp;&amp; (me2.who == KC_YOU || me2.who == KC_FRIENDLY);</a>
<a name="ln681">}</a>
<a name="ln682"> </a>
<a name="ln683">int exp_rate(int killer)</a>
<a name="ln684">{</a>
<a name="ln685">    // Damage by the spectral weapon is considered to be the player's damage ---</a>
<a name="ln686">    // so the player does not lose any exp from dealing damage with a spectral weapon summon</a>
<a name="ln687">    // ditto hep ancestors (sigh)</a>
<a name="ln688">    if (!invalid_monster_index(killer)</a>
<a name="ln689">        &amp;&amp; (menv[killer].type == MONS_SPECTRAL_WEAPON</a>
<a name="ln690">            || mons_is_hepliaklqana_ancestor(menv[killer].type))</a>
<a name="ln691">        &amp;&amp; menv[killer].summoner == MID_PLAYER)</a>
<a name="ln692">    {</a>
<a name="ln693">        return 2;</a>
<a name="ln694">    }</a>
<a name="ln695"> </a>
<a name="ln696">    if (killer == MHITYOU || killer == YOU_FAULTLESS)</a>
<a name="ln697">        return 2;</a>
<a name="ln698"> </a>
<a name="ln699">    if (_is_pet_kill(KILL_MON, killer))</a>
<a name="ln700">        return 1;</a>
<a name="ln701"> </a>
<a name="ln702">    return 0;</a>
<a name="ln703">}</a>
<a name="ln704"> </a>
<a name="ln705">// Elyvilon will occasionally (5% chance) protect the life of one of</a>
<a name="ln706">// your holy or natural allies.</a>
<a name="ln707">static bool _ely_protect_ally(monster* mons, killer_type killer)</a>
<a name="ln708">{</a>
<a name="ln709">    ASSERT(mons); // XXX: change to monster &amp;mons</a>
<a name="ln710">    if (!have_passive(passive_t::protect_ally))</a>
<a name="ln711">        return false;</a>
<a name="ln712"> </a>
<a name="ln713">    if (!MON_KILL(killer) &amp;&amp; !YOU_KILL(killer))</a>
<a name="ln714">        return false;</a>
<a name="ln715"> </a>
<a name="ln716">    if ( mons-&gt;holiness() &amp; ~(MH_HOLY | MH_NATURAL)</a>
<a name="ln717">        || !mons-&gt;friendly()</a>
<a name="ln718">        || !you.can_see(*mons) // for simplicity</a>
<a name="ln719">        || !one_chance_in(20))</a>
<a name="ln720">    {</a>
<a name="ln721">        return false;</a>
<a name="ln722">    }</a>
<a name="ln723"> </a>
<a name="ln724">    mons-&gt;hit_points = 1;</a>
<a name="ln725"> </a>
<a name="ln726">    const string msg = &quot; protects &quot; + mons-&gt;name(DESC_THE) + &quot; from harm!&quot;;</a>
<a name="ln727">    simple_god_message(msg.c_str());</a>
<a name="ln728"> </a>
<a name="ln729">    return true;</a>
<a name="ln730">}</a>
<a name="ln731"> </a>
<a name="ln732">// Elyvilon retribution effect: Heal hostile monsters that were about to</a>
<a name="ln733">// be killed by you or one of your friends.</a>
<a name="ln734">static bool _ely_heal_monster(monster* mons, killer_type killer, int i)</a>
<a name="ln735">{</a>
<a name="ln736">    god_type god = GOD_ELYVILON;</a>
<a name="ln737"> </a>
<a name="ln738">    if (!player_under_penance(god) || !god_hates_your_god(god))</a>
<a name="ln739">        return false;</a>
<a name="ln740"> </a>
<a name="ln741">    if (mons-&gt;wont_attack()</a>
<a name="ln742">        || mons_is_firewood(*mons)</a>
<a name="ln743">        || mons_is_object(mons-&gt;type)</a>
<a name="ln744">        || mons_is_tentacle_or_tentacle_segment(mons-&gt;type)</a>
<a name="ln745">        || mons-&gt;props.exists(&quot;ely_wrath_healed&quot;)</a>
<a name="ln746">        || mons-&gt;get_experience_level() &lt; random2(you.experience_level)</a>
<a name="ln747">        || !one_chance_in(3))</a>
<a name="ln748">    {</a>
<a name="ln749">        return false;</a>
<a name="ln750">    }</a>
<a name="ln751"> </a>
<a name="ln752">    if (MON_KILL(killer) &amp;&amp; !invalid_monster_index(i))</a>
<a name="ln753">    {</a>
<a name="ln754">        monster* mon = &amp;menv[i];</a>
<a name="ln755">        if (!mon-&gt;friendly())</a>
<a name="ln756">            return false;</a>
<a name="ln757"> </a>
<a name="ln758">        if (!you.see_cell(mons-&gt;pos()))</a>
<a name="ln759">            return false;</a>
<a name="ln760">    }</a>
<a name="ln761">    else if (!YOU_KILL(killer))</a>
<a name="ln762">        return false;</a>
<a name="ln763"> </a>
<a name="ln764">    dprf(&quot;monster hp: %d, max hp: %d&quot;, mons-&gt;hit_points, mons-&gt;max_hit_points);</a>
<a name="ln765"> </a>
<a name="ln766">    mons-&gt;hit_points = 1 + random2(mons-&gt;max_hit_points);</a>
<a name="ln767">    mons-&gt;props[&quot;ely_wrath_healed&quot;] = true;</a>
<a name="ln768"> </a>
<a name="ln769">    dprf(&quot;new hp: %d&quot;, mons-&gt;hit_points);</a>
<a name="ln770"> </a>
<a name="ln771">    const string msg = make_stringf(&quot;%s heals %s%s&quot;,</a>
<a name="ln772">             god_name(god, false).c_str(),</a>
<a name="ln773">             mons-&gt;name(DESC_THE).c_str(),</a>
<a name="ln774">             mons-&gt;hit_points * 2 &lt;= mons-&gt;max_hit_points ? &quot;.&quot; : &quot;!&quot;);</a>
<a name="ln775"> </a>
<a name="ln776">    god_speaks(god, msg.c_str());</a>
<a name="ln777"> </a>
<a name="ln778">    return true;</a>
<a name="ln779">}</a>
<a name="ln780"> </a>
<a name="ln781">static bool _yred_enslave_soul(monster* mons, killer_type killer)</a>
<a name="ln782">{</a>
<a name="ln783">    if (you_worship(GOD_YREDELEMNUL) &amp;&amp; mons_enslaved_body_and_soul(*mons)</a>
<a name="ln784">        &amp;&amp; you.see_cell(mons-&gt;pos()) &amp;&amp; killer != KILL_RESET</a>
<a name="ln785">        &amp;&amp; killer != KILL_DISMISSED</a>
<a name="ln786">        &amp;&amp; killer != KILL_BANISHED)</a>
<a name="ln787">    {</a>
<a name="ln788">        record_monster_defeat(mons, killer);</a>
<a name="ln789">        record_monster_defeat(mons, KILL_ENSLAVED);</a>
<a name="ln790">        yred_make_enslaved_soul(mons, player_under_penance());</a>
<a name="ln791">        return true;</a>
<a name="ln792">    }</a>
<a name="ln793"> </a>
<a name="ln794">    return false;</a>
<a name="ln795">}</a>
<a name="ln796"> </a>
<a name="ln797"> </a>
<a name="ln798">/**</a>
<a name="ln799"> * Attempt to get a deathbed conversion for the given orc.</a>
<a name="ln800"> *</a>
<a name="ln801"> * @param mons          A dying orc.</a>
<a name="ln802"> * @param killer        The way in which the monster was killed (or 'killed').</a>
<a name="ln803"> * @return              Whether the monster's life was saved (praise Beogh)</a>
<a name="ln804"> */</a>
<a name="ln805">static bool _beogh_forcibly_convert_orc(monster &amp;mons, killer_type killer)</a>
<a name="ln806">{</a>
<a name="ln807">    // Orcs may convert to Beogh under threat of death, either from</a>
<a name="ln808">    // you or, less often, your followers. In both cases, the</a>
<a name="ln809">    // checks are made against your stats. You're the potential</a>
<a name="ln810">    // messiah, after all.</a>
<a name="ln811">#ifdef DEBUG_DIAGNOSTICS</a>
<a name="ln812">    mprf(MSGCH_DIAGNOSTICS, &quot;Death convert attempt on %s, HD: %d, &quot;</a>
<a name="ln813">         &quot;your xl: %d&quot;,</a>
<a name="ln814">         mons.name(DESC_PLAIN).c_str(),</a>
<a name="ln815">         mons.get_hit_dice(),</a>
<a name="ln816">         you.experience_level);</a>
<a name="ln817">#endif</a>
<a name="ln818">    if (random2(you.piety) &gt;= piety_breakpoint(0)</a>
<a name="ln819">        &amp;&amp; random2(you.experience_level) &gt;= random2(mons.get_hit_dice())</a>
<a name="ln820">        // Bias beaten-up-conversion towards the stronger orcs.</a>
<a name="ln821">        &amp;&amp; random2(mons.get_experience_level()) &gt; 2)</a>
<a name="ln822">    {</a>
<a name="ln823">        beogh_convert_orc(&amp;mons, MON_KILL(killer) ? conv_t::deathbed_follower :</a>
<a name="ln824">                                                    conv_t::deathbed);</a>
<a name="ln825">        return true;</a>
<a name="ln826">    }</a>
<a name="ln827"> </a>
<a name="ln828">    return false;</a>
<a name="ln829">}</a>
<a name="ln830"> </a>
<a name="ln831">/**</a>
<a name="ln832"> * Attempt to get a deathbed conversion for the given monster.</a>
<a name="ln833"> *</a>
<a name="ln834"> * @param mons          A dying monster (not necessarily an orc)</a>
<a name="ln835"> * @param killer        The way in which the monster was killed (or 'killed').</a>
<a name="ln836"> * @param killer_index  The mindex of the killer, if known.</a>
<a name="ln837"> * @return              Whether the monster's life was saved (praise Beogh)</a>
<a name="ln838"> */</a>
<a name="ln839">static bool _beogh_maybe_convert_orc(monster &amp;mons, killer_type killer,</a>
<a name="ln840">                                    int killer_index)</a>
<a name="ln841">{</a>
<a name="ln842">    if (!have_passive(passive_t::convert_orcs)</a>
<a name="ln843">        || mons_genus(mons.type) != MONS_ORC</a>
<a name="ln844">        || mons.is_summoned() || mons.is_shapeshifter()</a>
<a name="ln845">        || !you.see_cell(mons.pos()) || mons_is_god_gift(mons))</a>
<a name="ln846">    {</a>
<a name="ln847">        return false;</a>
<a name="ln848">    }</a>
<a name="ln849"> </a>
<a name="ln850">    if (YOU_KILL(killer))</a>
<a name="ln851">        return _beogh_forcibly_convert_orc(mons, killer);</a>
<a name="ln852"> </a>
<a name="ln853">    if (MON_KILL(killer) &amp;&amp; !invalid_monster_index(killer_index))</a>
<a name="ln854">    {</a>
<a name="ln855">        const monster* responsible_monster = &amp;menv[killer_index];</a>
<a name="ln856">        if (is_follower(*responsible_monster) &amp;&amp; !one_chance_in(3))</a>
<a name="ln857">            return _beogh_forcibly_convert_orc(mons, killer);</a>
<a name="ln858">    }</a>
<a name="ln859"> </a>
<a name="ln860">    return false;</a>
<a name="ln861">}</a>
<a name="ln862"> </a>
<a name="ln863">/**</a>
<a name="ln864"> * Attempt to save the given monster's life at the last moment.</a>
<a name="ln865"> *</a>
<a name="ln866"> * Checks lost souls &amp; various divine effects (Yred, Beogh, Ely).</a>
<a name="ln867"> *</a>
<a name="ln868"> * @param mons          A dying monster.</a>
<a name="ln869"> * @param killer        The way in which the monster was killed (or 'killed').</a>
<a name="ln870"> * @param killer_index  The mindex of the killer, if known.</a>
<a name="ln871"> */</a>
<a name="ln872">static bool _monster_avoided_death(monster* mons, killer_type killer,</a>
<a name="ln873">                                   int killer_index)</a>
<a name="ln874">{</a>
<a name="ln875">    if (mons-&gt;max_hit_points &lt;= 0 || mons-&gt;get_hit_dice() &lt; 1)</a>
<a name="ln876">        return false;</a>
<a name="ln877"> </a>
<a name="ln878">    // Before the hp check since this should not care about the power of the</a>
<a name="ln879">    // finishing blow</a>
<a name="ln880">    if (lost_soul_revive(*mons, killer))</a>
<a name="ln881">        return true;</a>
<a name="ln882"> </a>
<a name="ln883">    // Yredelemnul special.</a>
<a name="ln884">    if (_yred_enslave_soul(mons, killer))</a>
<a name="ln885">        return true;</a>
<a name="ln886"> </a>
<a name="ln887">    // Beogh special.</a>
<a name="ln888">    if (_beogh_maybe_convert_orc(*mons, killer, killer_index))</a>
<a name="ln889">        return true;</a>
<a name="ln890"> </a>
<a name="ln891">    if (mons-&gt;hit_points &lt; -25 || mons-&gt;hit_points &lt; -mons-&gt;max_hit_points)</a>
<a name="ln892">        return false;</a>
<a name="ln893"> </a>
<a name="ln894">    // Elyvilon specials.</a>
<a name="ln895">    if (_ely_protect_ally(mons, killer))</a>
<a name="ln896">        return true;</a>
<a name="ln897">    if (_ely_heal_monster(mons, killer, killer_index))</a>
<a name="ln898">        return true;</a>
<a name="ln899"> </a>
<a name="ln900">    return false;</a>
<a name="ln901">}</a>
<a name="ln902"> </a>
<a name="ln903">static void _jiyva_died()</a>
<a name="ln904">{</a>
<a name="ln905">    if (you_worship(GOD_JIYVA))</a>
<a name="ln906">        return;</a>
<a name="ln907"> </a>
<a name="ln908">    add_daction(DACT_REMOVE_JIYVA_ALTARS);</a>
<a name="ln909"> </a>
<a name="ln910">    if (!player_in_branch(BRANCH_SLIME))</a>
<a name="ln911">        return;</a>
<a name="ln912"> </a>
<a name="ln913">    if (silenced(you.pos()))</a>
<a name="ln914">    {</a>
<a name="ln915">        god_speaks(GOD_JIYVA, &quot;With an infernal shudder, the power ruling &quot;</a>
<a name="ln916">                   &quot;this place vanishes!&quot;);</a>
<a name="ln917">    }</a>
<a name="ln918">    else</a>
<a name="ln919">    {</a>
<a name="ln920">        god_speaks(GOD_JIYVA, &quot;With an infernal noise, the power ruling this &quot;</a>
<a name="ln921">                   &quot;place vanishes!&quot;);</a>
<a name="ln922">    }</a>
<a name="ln923">}</a>
<a name="ln924"> </a>
<a name="ln925">void fire_monster_death_event(monster* mons,</a>
<a name="ln926">                              killer_type killer,</a>
<a name="ln927">                              bool polymorph)</a>
<a name="ln928">{</a>
<a name="ln929">    int type = mons-&gt;type;</a>
<a name="ln930"> </a>
<a name="ln931">    // Treat whatever the Royal Jelly polymorphed into as if it were still</a>
<a name="ln932">    // the Royal Jelly (but if a player chooses the character name</a>
<a name="ln933">    // &quot;shaped Royal Jelly&quot; don't unlock the vaults when the player's</a>
<a name="ln934">    // ghost is killed).</a>
<a name="ln935">    if (mons-&gt;mname == &quot;shaped Royal Jelly&quot;</a>
<a name="ln936">        &amp;&amp; !mons_is_pghost(mons-&gt;type))</a>
<a name="ln937">    {</a>
<a name="ln938">        type = MONS_ROYAL_JELLY;</a>
<a name="ln939">    }</a>
<a name="ln940"> </a>
<a name="ln941">    if (!polymorph)</a>
<a name="ln942">    {</a>
<a name="ln943">        dungeon_events.fire_event(</a>
<a name="ln944">            dgn_event(DET_MONSTER_DIED, mons-&gt;pos(), 0,</a>
<a name="ln945">                      mons-&gt;mid, killer));</a>
<a name="ln946">    }</a>
<a name="ln947"> </a>
<a name="ln948">    bool terrain_changed = false;</a>
<a name="ln949"> </a>
<a name="ln950">    for (map_marker *mark : env.markers.get_all(MAT_TERRAIN_CHANGE))</a>
<a name="ln951">    {</a>
<a name="ln952">        map_terrain_change_marker *marker =</a>
<a name="ln953">                dynamic_cast&lt;map_terrain_change_marker*&gt;(mark);</a>
<a name="ln954"> </a>
<a name="ln955">        if (marker-&gt;mon_num != 0 &amp;&amp; monster_by_mid(marker-&gt;mon_num) == mons)</a>
<a name="ln956">        {</a>
<a name="ln957">            terrain_changed = true;</a>
<a name="ln958">            marker-&gt;duration = 0;</a>
<a name="ln959">        }</a>
<a name="ln960">    }</a>
<a name="ln961"> </a>
<a name="ln962">    if (terrain_changed)</a>
<a name="ln963">        timeout_terrain_changes(0, true);</a>
<a name="ln964"> </a>
<a name="ln965">    if (killer == KILL_BANISHED)</a>
<a name="ln966">        return;</a>
<a name="ln967"> </a>
<a name="ln968">    los_monster_died(mons);</a>
<a name="ln969"> </a>
<a name="ln970">    if (type == MONS_ROYAL_JELLY &amp;&amp; !mons-&gt;is_summoned() &amp;&amp; !polymorph)</a>
<a name="ln971">    {</a>
<a name="ln972">        you.royal_jelly_dead = true;</a>
<a name="ln973"> </a>
<a name="ln974">        if (jiyva_is_dead())</a>
<a name="ln975">            _jiyva_died();</a>
<a name="ln976">    }</a>
<a name="ln977">}</a>
<a name="ln978"> </a>
<a name="ln979">int mummy_curse_power(monster_type type)</a>
<a name="ln980">{</a>
<a name="ln981">    // Plain mummies (and Menkaure) are too weak to curse you!</a>
<a name="ln982">    switch (type)</a>
<a name="ln983">    {</a>
<a name="ln984">        case MONS_GUARDIAN_MUMMY:</a>
<a name="ln985">        case MONS_MUMMY_PRIEST:</a>
<a name="ln986">        case MONS_GREATER_MUMMY:</a>
<a name="ln987">        case MONS_KHUFU:</a>
<a name="ln988">            return mons_class_hit_dice(type);</a>
<a name="ln989">        default:</a>
<a name="ln990">            return 0;</a>
<a name="ln991">    }</a>
<a name="ln992">}</a>
<a name="ln993"> </a>
<a name="ln994">template&lt;typename valid_T, typename connect_T&gt;</a>
<a name="ln995">static void _search_dungeon(const coord_def &amp; start,</a>
<a name="ln996">                    valid_T &amp; valid_target,</a>
<a name="ln997">                    connect_T &amp; connecting_square,</a>
<a name="ln998">                    set&lt;position_node&gt; &amp; visited,</a>
<a name="ln999">                    vector&lt;set&lt;position_node&gt;::iterator&gt; &amp; candidates,</a>
<a name="ln1000">                    bool exhaustive = true,</a>
<a name="ln1001">                    int connect_mode = 8)</a>
<a name="ln1002">{</a>
<a name="ln1003">    if (connect_mode &lt; 1 || connect_mode &gt; 8)</a>
<a name="ln1004">        connect_mode = 8;</a>
<a name="ln1005"> </a>
<a name="ln1006">    // Ordering the default compass index this way gives us the non</a>
<a name="ln1007">    // diagonal directions as the first four elements - so by just</a>
<a name="ln1008">    // using the first 4 elements instead of the whole array we</a>
<a name="ln1009">    // can have 4-connectivity.</a>
<a name="ln1010">    int compass_idx[] = {0, 2, 4, 6, 1, 3, 5, 7};</a>
<a name="ln1011"> </a>
<a name="ln1012">    position_node temp_node;</a>
<a name="ln1013">    temp_node.pos = start;</a>
<a name="ln1014">    temp_node.last = nullptr;</a>
<a name="ln1015"> </a>
<a name="ln1016">    queue&lt;set&lt;position_node&gt;::iterator &gt; fringe;</a>
<a name="ln1017"> </a>
<a name="ln1018">    auto current = visited.insert(temp_node).first;</a>
<a name="ln1019">    fringe.push(current);</a>
<a name="ln1020"> </a>
<a name="ln1021">    while (!fringe.empty())</a>
<a name="ln1022">    {</a>
<a name="ln1023">        current = fringe.front();</a>
<a name="ln1024">        fringe.pop();</a>
<a name="ln1025"> </a>
<a name="ln1026">        shuffle_array(compass_idx, connect_mode);</a>
<a name="ln1027"> </a>
<a name="ln1028">        for (int i=0; i &lt; connect_mode; ++i)</a>
<a name="ln1029">        {</a>
<a name="ln1030">            coord_def adjacent = current-&gt;pos + Compass[compass_idx[i]];</a>
<a name="ln1031">            if (in_bounds(adjacent))</a>
<a name="ln1032">            {</a>
<a name="ln1033">                temp_node.pos = adjacent;</a>
<a name="ln1034">                temp_node.last = &amp;(*current);</a>
<a name="ln1035">                auto res = visited.insert(temp_node);</a>
<a name="ln1036"> </a>
<a name="ln1037">                if (!res.second)</a>
<a name="ln1038">                    continue;</a>
<a name="ln1039"> </a>
<a name="ln1040">                if (valid_target(adjacent))</a>
<a name="ln1041">                {</a>
<a name="ln1042">                    candidates.push_back(res.first);</a>
<a name="ln1043">                    if (!exhaustive)</a>
<a name="ln1044">                        return;</a>
<a name="ln1045">                }</a>
<a name="ln1046"> </a>
<a name="ln1047">                if (connecting_square(adjacent))</a>
<a name="ln1048">                    fringe.push(res.first);</a>
<a name="ln1049">            }</a>
<a name="ln1050">        }</a>
<a name="ln1051">    }</a>
<a name="ln1052">}</a>
<a name="ln1053"> </a>
<a name="ln1054">static void _setup_base_explosion(bolt &amp; beam, const monster&amp; origin)</a>
<a name="ln1055">{</a>
<a name="ln1056">    beam.is_tracer    = false;</a>
<a name="ln1057">    beam.is_explosion = true;</a>
<a name="ln1058">    beam.source_id    = origin.mid;</a>
<a name="ln1059">    beam.glyph        = dchar_glyph(DCHAR_FIRED_BURST);</a>
<a name="ln1060">    beam.source       = origin.pos();</a>
<a name="ln1061">    beam.source_name  = origin.base_name(DESC_BASENAME, true);</a>
<a name="ln1062">    beam.target       = origin.pos();</a>
<a name="ln1063">    beam.explode_noise_msg = &quot;You hear an explosion!&quot;;</a>
<a name="ln1064"> </a>
<a name="ln1065">    if (!crawl_state.game_is_arena() &amp;&amp; origin.attitude == ATT_FRIENDLY</a>
<a name="ln1066">        &amp;&amp; !origin.is_summoned())</a>
<a name="ln1067">    {</a>
<a name="ln1068">        beam.thrower = KILL_YOU;</a>
<a name="ln1069">    }</a>
<a name="ln1070">    else</a>
<a name="ln1071">        beam.thrower = KILL_MON;</a>
<a name="ln1072"> </a>
<a name="ln1073">    beam.aux_source.clear();</a>
<a name="ln1074">    beam.attitude = origin.attitude;</a>
<a name="ln1075">}</a>
<a name="ln1076"> </a>
<a name="ln1077">void setup_spore_explosion(bolt &amp; beam, const monster&amp; origin)</a>
<a name="ln1078">{</a>
<a name="ln1079">    _setup_base_explosion(beam, origin);</a>
<a name="ln1080">    beam.flavour = BEAM_SPORE;</a>
<a name="ln1081">    beam.damage  = dice_def(3, 5 + origin.get_hit_dice());</a>
<a name="ln1082">    beam.name    = &quot;explosion of spores&quot;;</a>
<a name="ln1083">    beam.colour  = LIGHTGREY;</a>
<a name="ln1084">    beam.ex_size = 1;</a>
<a name="ln1085">}</a>
<a name="ln1086"> </a>
<a name="ln1087">static void _setup_lightning_explosion(bolt &amp; beam, const monster&amp; origin)</a>
<a name="ln1088">{</a>
<a name="ln1089">    _setup_base_explosion(beam, origin);</a>
<a name="ln1090">    beam.flavour   = BEAM_ELECTRICITY;</a>
<a name="ln1091">    beam.damage    = dice_def(3, 5 + origin.get_hit_dice() * 5 / 4);</a>
<a name="ln1092">    beam.name      = &quot;blast of lightning&quot;;</a>
<a name="ln1093">    beam.explode_noise_msg = &quot;You hear a clap of thunder!&quot;;</a>
<a name="ln1094">    beam.colour    = LIGHTCYAN;</a>
<a name="ln1095">    beam.ex_size   = x_chance_in_y(origin.get_hit_dice(), 24) ? 3 : 2;</a>
<a name="ln1096">    // Don't credit the player for ally-summoned ball lightning explosions.</a>
<a name="ln1097">    if (origin.summoner &amp;&amp; origin.summoner != MID_PLAYER)</a>
<a name="ln1098">        beam.thrower = KILL_MON;</a>
<a name="ln1099">}</a>
<a name="ln1100"> </a>
<a name="ln1101">static void _setup_prism_explosion(bolt&amp; beam, const monster&amp; origin)</a>
<a name="ln1102">{</a>
<a name="ln1103">    _setup_base_explosion(beam, origin);</a>
<a name="ln1104">    beam.flavour = BEAM_MMISSILE;</a>
<a name="ln1105">    beam.damage  = (origin.prism_charge == 2 ?</a>
<a name="ln1106">                        dice_def(3, 6 + origin.get_hit_dice() * 7 / 4)</a>
<a name="ln1107">                        : dice_def(2, 6 + origin.get_hit_dice() * 7 / 4));</a>
<a name="ln1108">    beam.name    = &quot;blast of energy&quot;;</a>
<a name="ln1109">    beam.colour  = MAGENTA;</a>
<a name="ln1110">    beam.ex_size = origin.prism_charge;</a>
<a name="ln1111">}</a>
<a name="ln1112"> </a>
<a name="ln1113">static void _setup_bennu_explosion(bolt&amp; beam, const monster&amp; origin)</a>
<a name="ln1114">{</a>
<a name="ln1115">    _setup_base_explosion(beam, origin);</a>
<a name="ln1116">    beam.flavour = BEAM_NEG;</a>
<a name="ln1117">    beam.damage  = dice_def(3, 5 + origin.get_hit_dice() * 5 / 4);</a>
<a name="ln1118">    beam.name    = &quot;pyre of ghostly fire&quot;;</a>
<a name="ln1119">    beam.explode_noise_msg = &quot;You hear an otherworldly crackling!&quot;;</a>
<a name="ln1120">    beam.colour  = CYAN;</a>
<a name="ln1121">    beam.ex_size = 2;</a>
<a name="ln1122">}</a>
<a name="ln1123"> </a>
<a name="ln1124">static void _setup_inner_flame_explosion(bolt &amp; beam, const monster&amp; origin,</a>
<a name="ln1125">                                         actor* agent)</a>
<a name="ln1126">{</a>
<a name="ln1127">    _setup_base_explosion(beam, origin);</a>
<a name="ln1128">    const int size   = origin.body_size(PSIZE_BODY);</a>
<a name="ln1129">    beam.flavour     = BEAM_FIRE;</a>
<a name="ln1130">    beam.damage      = (size &gt; SIZE_BIG)  ? dice_def(3, 25) :</a>
<a name="ln1131">                       (size &gt; SIZE_TINY) ? dice_def(3, 20) :</a>
<a name="ln1132">                                            dice_def(3, 15);</a>
<a name="ln1133">    beam.name        = &quot;fiery explosion&quot;;</a>
<a name="ln1134">    beam.colour      = RED;</a>
<a name="ln1135">    beam.ex_size     = (size &gt; SIZE_BIG) ? 2 : 1;</a>
<a name="ln1136">    beam.source_name = origin.name(DESC_A, true);</a>
<a name="ln1137">    beam.origin_spell = SPELL_INNER_FLAME;</a>
<a name="ln1138">    beam.thrower     = (agent &amp;&amp; agent-&gt;is_player()) ? KILL_YOU_MISSILE</a>
<a name="ln1139">                                                     : KILL_MON_MISSILE;</a>
<a name="ln1140">}</a>
<a name="ln1141"> </a>
<a name="ln1142">static bool _explode_monster(monster* mons, killer_type killer,</a>
<a name="ln1143">                             bool pet_kill, bool wizard)</a>
<a name="ln1144">{</a>
<a name="ln1145">    if (mons-&gt;hit_points &gt; 0 || mons-&gt;hit_points &lt;= -15 || wizard</a>
<a name="ln1146">        || killer == KILL_RESET || killer == KILL_DISMISSED</a>
<a name="ln1147">        || killer == KILL_BANISHED)</a>
<a name="ln1148">    {</a>
<a name="ln1149">        if (killer != KILL_TIMEOUT)</a>
<a name="ln1150">            return false;</a>
<a name="ln1151">    }</a>
<a name="ln1152"> </a>
<a name="ln1153">    bolt beam;</a>
<a name="ln1154">    const int type = mons-&gt;type;</a>
<a name="ln1155">    const char* sanct_msg = nullptr;</a>
<a name="ln1156">    actor* agent = mons;</a>
<a name="ln1157"> </a>
<a name="ln1158">    if (type == MONS_BALLISTOMYCETE_SPORE)</a>
<a name="ln1159">    {</a>
<a name="ln1160">        setup_spore_explosion(beam, *mons);</a>
<a name="ln1161">        sanct_msg    = &quot;By Zin's power, the ballistomycete spore's explosion is &quot;</a>
<a name="ln1162">                       &quot;contained.&quot;;</a>
<a name="ln1163">    }</a>
<a name="ln1164">    else if (type == MONS_BALL_LIGHTNING)</a>
<a name="ln1165">    {</a>
<a name="ln1166">        _setup_lightning_explosion(beam, *mons);</a>
<a name="ln1167">        sanct_msg    = &quot;By Zin's power, the ball lightning's explosion &quot;</a>
<a name="ln1168">                       &quot;is contained.&quot;;</a>
<a name="ln1169">    }</a>
<a name="ln1170">    else if (type == MONS_LURKING_HORROR)</a>
<a name="ln1171">        sanct_msg = &quot;The lurking horror fades away harmlessly.&quot;;</a>
<a name="ln1172">    else if (type == MONS_FULMINANT_PRISM)</a>
<a name="ln1173">    {</a>
<a name="ln1174">        _setup_prism_explosion(beam, *mons);</a>
<a name="ln1175">        sanct_msg = &quot;By Zin's power, the prism's explosion is contained.&quot;;</a>
<a name="ln1176">    }</a>
<a name="ln1177">    else if (type == MONS_BENNU)</a>
<a name="ln1178">    {</a>
<a name="ln1179">        _setup_bennu_explosion(beam, *mons);</a>
<a name="ln1180">        sanct_msg = &quot;By Zin's power, the bennu's fires are quelled.&quot;;</a>
<a name="ln1181">    }</a>
<a name="ln1182">    else if (mons-&gt;has_ench(ENCH_INNER_FLAME))</a>
<a name="ln1183">    {</a>
<a name="ln1184">        mon_enchant i_f = mons-&gt;get_ench(ENCH_INNER_FLAME);</a>
<a name="ln1185">        ASSERT(i_f.ench == ENCH_INNER_FLAME);</a>
<a name="ln1186">        agent = actor_by_mid(i_f.source);</a>
<a name="ln1187">        _setup_inner_flame_explosion(beam, *mons, agent);</a>
<a name="ln1188">        // This might need to change if monsters ever get the ability to cast</a>
<a name="ln1189">        // Inner Flame...</a>
<a name="ln1190">        if (agent &amp;&amp; agent-&gt;is_player())</a>
<a name="ln1191">            mons_add_blame(mons, &quot;hexed by the player character&quot;);</a>
<a name="ln1192">        else if (agent)</a>
<a name="ln1193">            mons_add_blame(mons, &quot;hexed by &quot; + agent-&gt;name(DESC_A, true));</a>
<a name="ln1194">        mons-&gt;flags    |= MF_EXPLODE_KILL;</a>
<a name="ln1195">        sanct_msg       = &quot;By Zin's power, the fiery explosion &quot;</a>
<a name="ln1196">                          &quot;is contained.&quot;;</a>
<a name="ln1197">        beam.aux_source = &quot;exploding inner flame&quot;;</a>
<a name="ln1198">    }</a>
<a name="ln1199">    else</a>
<a name="ln1200">    {</a>
<a name="ln1201">        msg::streams(MSGCH_DIAGNOSTICS) &lt;&lt; &quot;Unknown spore type: &quot;</a>
<a name="ln1202">                                        &lt;&lt; static_cast&lt;int&gt;(type)</a>
<a name="ln1203">                                        &lt;&lt; endl;</a>
<a name="ln1204">        return false;</a>
<a name="ln1205">    }</a>
<a name="ln1206"> </a>
<a name="ln1207">    if (beam.aux_source.empty())</a>
<a name="ln1208">    {</a>
<a name="ln1209">        if (type == MONS_BENNU)</a>
<a name="ln1210">        {</a>
<a name="ln1211">            if (YOU_KILL(killer))</a>
<a name="ln1212">                beam.aux_source = &quot;ignited by themself&quot;;</a>
<a name="ln1213">            else if (pet_kill)</a>
<a name="ln1214">                beam.aux_source = &quot;ignited by their pet&quot;;</a>
<a name="ln1215">        }</a>
<a name="ln1216">        else</a>
<a name="ln1217">        {</a>
<a name="ln1218">            if (YOU_KILL(killer))</a>
<a name="ln1219">                beam.aux_source = &quot;set off by themself&quot;;</a>
<a name="ln1220">            else if (pet_kill)</a>
<a name="ln1221">                beam.aux_source = &quot;set off by their pet&quot;;</a>
<a name="ln1222">        }</a>
<a name="ln1223">    }</a>
<a name="ln1224"> </a>
<a name="ln1225">    bool saw = false;</a>
<a name="ln1226">    if (you.can_see(*mons))</a>
<a name="ln1227">    {</a>
<a name="ln1228">        saw = true;</a>
<a name="ln1229">        viewwindow();</a>
<a name="ln1230">        if (is_sanctuary(mons-&gt;pos()))</a>
<a name="ln1231">            mprf(MSGCH_GOD, &quot;%s&quot;, sanct_msg);</a>
<a name="ln1232">        else if (type == MONS_BENNU)</a>
<a name="ln1233">            mprf(MSGCH_MONSTER_DAMAGE, MDAM_DEAD, &quot;%s blazes out!&quot;,</a>
<a name="ln1234">                 mons-&gt;full_name(DESC_THE).c_str());</a>
<a name="ln1235">        else</a>
<a name="ln1236">            mprf(MSGCH_MONSTER_DAMAGE, MDAM_DEAD, &quot;%s explodes!&quot;,</a>
<a name="ln1237">                 mons-&gt;full_name(DESC_THE).c_str());</a>
<a name="ln1238">    }</a>
<a name="ln1239"> </a>
<a name="ln1240">    if (is_sanctuary(mons-&gt;pos()))</a>
<a name="ln1241">        return false;</a>
<a name="ln1242"> </a>
<a name="ln1243">    // Explosion side-effects.</a>
<a name="ln1244">    if (type == MONS_LURKING_HORROR)</a>
<a name="ln1245">        torment(mons, TORMENT_LURKING_HORROR, mons-&gt;pos());</a>
<a name="ln1246">    else if (mons-&gt;has_ench(ENCH_INNER_FLAME))</a>
<a name="ln1247">    {</a>
<a name="ln1248">        for (adjacent_iterator ai(mons-&gt;pos(), false); ai; ++ai)</a>
<a name="ln1249">            if (!cell_is_solid(*ai) &amp;&amp; !cloud_at(*ai) &amp;&amp; !one_chance_in(5))</a>
<a name="ln1250">                place_cloud(CLOUD_FIRE, *ai, 10 + random2(10), agent);</a>
<a name="ln1251">    }</a>
<a name="ln1252"> </a>
<a name="ln1253">    // Detach monster from the grid first, so it doesn't get hit by</a>
<a name="ln1254">    // its own explosion. (GDL)</a>
<a name="ln1255">    // Unless it's a phoenix, where this isn't much of a concern.</a>
<a name="ln1256">    mgrd(mons-&gt;pos()) = NON_MONSTER;</a>
<a name="ln1257"> </a>
<a name="ln1258">    // The explosion might cause a monster to be placed where the bomb</a>
<a name="ln1259">    // used to be, so make sure that mgrd() doesn't get cleared a second</a>
<a name="ln1260">    // time (causing the new monster to become floating) when</a>
<a name="ln1261">    // mons-&gt;reset() is called.</a>
<a name="ln1262">    if (type == MONS_BALLISTOMYCETE_SPORE)</a>
<a name="ln1263">        mons-&gt;set_position(coord_def(0,0));</a>
<a name="ln1264"> </a>
<a name="ln1265">    // Exploding kills the monster a bit earlier than normal.</a>
<a name="ln1266">    mons-&gt;hit_points = -16;</a>
<a name="ln1267">    if (saw)</a>
<a name="ln1268">        viewwindow();</a>
<a name="ln1269"> </a>
<a name="ln1270">    // FIXME: show_more == you.see_cell(mons-&gt;pos())</a>
<a name="ln1271">    if (type == MONS_LURKING_HORROR)</a>
<a name="ln1272">    {</a>
<a name="ln1273">        targeter_radius hitfunc(mons, LOS_SOLID);</a>
<a name="ln1274">        flash_view_delay(UA_MONSTER, DARKGRAY, 300, &amp;hitfunc);</a>
<a name="ln1275">    }</a>
<a name="ln1276">    else</a>
<a name="ln1277">        beam.explode();</a>
<a name="ln1278"> </a>
<a name="ln1279">    // Monster died in explosion, so don't re-attach it to the grid.</a>
<a name="ln1280">    return true;</a>
<a name="ln1281">}</a>
<a name="ln1282"> </a>
<a name="ln1283">static void _infestation_create_scarab(monster* mons)</a>
<a name="ln1284">{</a>
<a name="ln1285">    mons-&gt;flags |= MF_EXPLODE_KILL;</a>
<a name="ln1286">    infestation_death_fineff::schedule(mons-&gt;pos(), mons-&gt;name(DESC_THE));</a>
<a name="ln1287">}</a>
<a name="ln1288"> </a>
<a name="ln1289">static void _monster_die_cloud(const monster* mons, bool corpse, bool silent,</a>
<a name="ln1290">                               bool summoned)</a>
<a name="ln1291">{</a>
<a name="ln1292">    // Chaos spawn always leave behind a cloud of chaos.</a>
<a name="ln1293">    if (mons-&gt;type == MONS_CHAOS_SPAWN)</a>
<a name="ln1294">    {</a>
<a name="ln1295">        summoned = true;</a>
<a name="ln1296">        corpse   = false;</a>
<a name="ln1297">    }</a>
<a name="ln1298"> </a>
<a name="ln1299">    if (!summoned)</a>
<a name="ln1300">        return;</a>
<a name="ln1301"> </a>
<a name="ln1302">    if (cell_is_solid(mons-&gt;pos()))</a>
<a name="ln1303">        return;</a>
<a name="ln1304"> </a>
<a name="ln1305">    string prefix = &quot; &quot;;</a>
<a name="ln1306">    if (corpse)</a>
<a name="ln1307">    {</a>
<a name="ln1308">        if (!mons_class_can_leave_corpse(mons_species(mons-&gt;type)))</a>
<a name="ln1309">            return;</a>
<a name="ln1310"> </a>
<a name="ln1311">        prefix = &quot;'s corpse &quot;;</a>
<a name="ln1312">    }</a>
<a name="ln1313"> </a>
<a name="ln1314">    string msg = summoned_poof_msg(mons) + &quot;!&quot;;</a>
<a name="ln1315"> </a>
<a name="ln1316">    cloud_type cloud = CLOUD_NONE;</a>
<a name="ln1317">    if (msg.find(&quot;smoke&quot;) != string::npos)</a>
<a name="ln1318">        cloud = random_smoke_type();</a>
<a name="ln1319">    else if (msg.find(&quot;chaos&quot;) != string::npos)</a>
<a name="ln1320">        cloud = CLOUD_CHAOS;</a>
<a name="ln1321"> </a>
<a name="ln1322">    if (!silent)</a>
<a name="ln1323">        simple_monster_message(*mons, (prefix + msg).c_str());</a>
<a name="ln1324"> </a>
<a name="ln1325">    if (cloud != CLOUD_NONE)</a>
<a name="ln1326">        place_cloud(cloud, mons-&gt;pos(), 1 + random2(3), mons);</a>
<a name="ln1327">}</a>
<a name="ln1328"> </a>
<a name="ln1329">static string _killer_type_name(killer_type killer)</a>
<a name="ln1330">{</a>
<a name="ln1331">    switch (killer)</a>
<a name="ln1332">    {</a>
<a name="ln1333">    case KILL_NONE:</a>
<a name="ln1334">        return &quot;none&quot;;</a>
<a name="ln1335">    case KILL_YOU:</a>
<a name="ln1336">        return &quot;you&quot;;</a>
<a name="ln1337">    case KILL_MON:</a>
<a name="ln1338">        return &quot;mon&quot;;</a>
<a name="ln1339">    case KILL_YOU_MISSILE:</a>
<a name="ln1340">        return &quot;you_missile&quot;;</a>
<a name="ln1341">    case KILL_MON_MISSILE:</a>
<a name="ln1342">        return &quot;mon_missile&quot;;</a>
<a name="ln1343">    case KILL_YOU_CONF:</a>
<a name="ln1344">        return &quot;you_conf&quot;;</a>
<a name="ln1345">    case KILL_MISCAST:</a>
<a name="ln1346">        return &quot;miscast&quot;;</a>
<a name="ln1347">    case KILL_MISC:</a>
<a name="ln1348">        return &quot;misc&quot;;</a>
<a name="ln1349">    case KILL_RESET:</a>
<a name="ln1350">        return &quot;reset&quot;;</a>
<a name="ln1351">    case KILL_DISMISSED:</a>
<a name="ln1352">        return &quot;dismissed&quot;;</a>
<a name="ln1353">    case KILL_BANISHED:</a>
<a name="ln1354">        return &quot;banished&quot;;</a>
<a name="ln1355">    case KILL_TIMEOUT:</a>
<a name="ln1356">        return &quot;timeout&quot;;</a>
<a name="ln1357">#if TAG_MAJOR_VERSION == 34</a>
<a name="ln1358">    case KILL_UNSUMMONED:</a>
<a name="ln1359">        return &quot;unsummoned&quot;;</a>
<a name="ln1360">#endif</a>
<a name="ln1361">    case KILL_PACIFIED:</a>
<a name="ln1362">        return &quot;pacified&quot;;</a>
<a name="ln1363">    case KILL_ENSLAVED:</a>
<a name="ln1364">        return &quot;enslaved&quot;;</a>
<a name="ln1365">    case KILL_SLIMIFIED:</a>
<a name="ln1366">        return &quot;slimified&quot;;</a>
<a name="ln1367">    }</a>
<a name="ln1368">    die(&quot;invalid killer type&quot;);</a>
<a name="ln1369">}</a>
<a name="ln1370"> </a>
<a name="ln1371">/**</a>
<a name="ln1372"> * Make a spectral thing or simulacrum out of a dying/dead monster.</a>
<a name="ln1373"> *</a>
<a name="ln1374"> * @param mons       the monster that died</a>
<a name="ln1375"> * @param quiet      whether to print flavour messages</a>
<a name="ln1376"> * @param bound_soul whether the undead is from Bind Souls (true) or DChan</a>
<a name="ln1377"> */</a>
<a name="ln1378">static void _make_derived_undead(monster* mons, bool quiet, bool bound_soul)</a>
<a name="ln1379">{</a>
<a name="ln1380">    if (mons-&gt;holiness() &amp; MH_NATURAL &amp;&amp; mons_can_be_zombified(*mons))</a>
<a name="ln1381">    {</a>
<a name="ln1382">        // Use the original monster type as the zombified type here, to</a>
<a name="ln1383">        // get the proper stats from it.</a>
<a name="ln1384">        mgen_data mg(bound_soul ? MONS_SIMULACRUM : MONS_SPECTRAL_THING,</a>
<a name="ln1385">                     bound_soul ? SAME_ATTITUDE(mons) : BEH_FRIENDLY,</a>
<a name="ln1386">                     mons-&gt;pos(),</a>
<a name="ln1387">                     // XXX: is MHITYOU really correct here?</a>
<a name="ln1388">                     crawl_state.game_is_arena() ? MHITNOT : MHITYOU);</a>
<a name="ln1389">        // Simulacra aren't summons, and we want them to stick</a>
<a name="ln1390">        // around even after killing the necromancer.</a>
<a name="ln1391">        mg.set_summoned(bound_soul ? nullptr : &amp;you,</a>
<a name="ln1392">                        0,</a>
<a name="ln1393">                        bound_soul ? SPELL_BIND_SOULS : SPELL_DEATH_CHANNEL,</a>
<a name="ln1394">                        bound_soul ?</a>
<a name="ln1395">                        GOD_NO_GOD : static_cast&lt;god_type&gt;(you.attribute[ATTR_DIVINE_DEATH_CHANNEL]));</a>
<a name="ln1396">        mg.set_base(mons-&gt;type);</a>
<a name="ln1397"> </a>
<a name="ln1398">        if (!mons-&gt;mname.empty() &amp;&amp; !(mons-&gt;flags &amp; MF_NAME_NOCORPSE))</a>
<a name="ln1399">            mg.mname = mons-&gt;mname;</a>
<a name="ln1400">        else if (mons_is_unique(mons-&gt;type))</a>
<a name="ln1401">            mg.mname = mons_type_name(mons-&gt;type, DESC_PLAIN);</a>
<a name="ln1402">        mg.extra_flags = mons-&gt;flags &amp; (MF_NAME_SUFFIX</a>
<a name="ln1403">                                          | MF_NAME_ADJECTIVE</a>
<a name="ln1404">                                          | MF_NAME_DESCRIPTOR);</a>
<a name="ln1405"> </a>
<a name="ln1406">        if (mons-&gt;mons_species() == MONS_HYDRA)</a>
<a name="ln1407">        {</a>
<a name="ln1408">            // No undead 0-headed hydras, sorry.</a>
<a name="ln1409">            if (mons-&gt;heads() == 0)</a>
<a name="ln1410">            {</a>
<a name="ln1411">                if (!quiet)</a>
<a name="ln1412">                {</a>
<a name="ln1413">                    mprf(&quot;A %s mist gathers momentarily, then fades.&quot;,</a>
<a name="ln1414">                         bound_soul ? &quot;freezing&quot; : &quot;glowing&quot;);</a>
<a name="ln1415">                }</a>
<a name="ln1416">                return;</a>
<a name="ln1417">            }</a>
<a name="ln1418">            else</a>
<a name="ln1419">                mg.props[MGEN_NUM_HEADS] = mons-&gt;heads();</a>
<a name="ln1420">        }</a>
<a name="ln1421"> </a>
<a name="ln1422">        string agent_name = &quot;&quot;;</a>
<a name="ln1423">        if (bound_soul)</a>
<a name="ln1424">        {</a>
<a name="ln1425">            const auto agent = mons-&gt;get_ench(ENCH_BOUND_SOUL).agent();</a>
<a name="ln1426">            if (agent)</a>
<a name="ln1427">                agent_name = agent-&gt;as_monster()-&gt;full_name(DESC_A);</a>
<a name="ln1428">        }</a>
<a name="ln1429"> </a>
<a name="ln1430">        string monster_name = &quot;&quot;;</a>
<a name="ln1431"> </a>
<a name="ln1432">        string message = quiet ? &quot;&quot; :</a>
<a name="ln1433">            make_stringf(&quot;A %s mist starts to gather...&quot;,</a>
<a name="ln1434">                         bound_soul ? &quot;freezing&quot; : &quot;glowing&quot;);</a>
<a name="ln1435"> </a>
<a name="ln1436">        make_derived_undead_fineff::schedule(mons-&gt;pos(), mg,</a>
<a name="ln1437">                mons-&gt;get_experience_level(), agent_name, message);</a>
<a name="ln1438"> </a>
<a name="ln1439">    }</a>
<a name="ln1440">}</a>
<a name="ln1441"> </a>
<a name="ln1442">static void _druid_final_boon(const monster* mons)</a>
<a name="ln1443">{</a>
<a name="ln1444">    vector&lt;monster*&gt; beasts;</a>
<a name="ln1445">    for (monster_near_iterator mi(mons); mi; ++mi)</a>
<a name="ln1446">    {</a>
<a name="ln1447">        if (mons_is_beast(mons_base_type(**mi)) &amp;&amp; mons_aligned(mons, *mi))</a>
<a name="ln1448">            beasts.push_back(*mi);</a>
<a name="ln1449">    }</a>
<a name="ln1450"> </a>
<a name="ln1451">    if (!beasts.size())</a>
<a name="ln1452">        return;</a>
<a name="ln1453"> </a>
<a name="ln1454">    if (you.can_see(*mons))</a>
<a name="ln1455">    {</a>
<a name="ln1456">        mprf(MSGCH_MONSTER_SPELL, &quot;With its final breath, %s offers up its power &quot;</a>
<a name="ln1457">                                  &quot;to the beasts of the wild!&quot;,</a>
<a name="ln1458">                                  mons-&gt;name(DESC_THE).c_str());</a>
<a name="ln1459">    }</a>
<a name="ln1460"> </a>
<a name="ln1461">    shuffle_array(beasts);</a>
<a name="ln1462">    int num = min((int)beasts.size(),</a>
<a name="ln1463">                  random_range(mons-&gt;get_hit_dice() / 3,</a>
<a name="ln1464">                               mons-&gt;get_hit_dice() / 2 + 1));</a>
<a name="ln1465"> </a>
<a name="ln1466">    // Healing and empowering done in two separate loops for tidier messages</a>
<a name="ln1467">    for (int i = 0; i &lt; num; ++i)</a>
<a name="ln1468">    {</a>
<a name="ln1469">        if (beasts[i]-&gt;heal(roll_dice(3, mons-&gt;get_hit_dice()))</a>
<a name="ln1470">            &amp;&amp; you.can_see(*beasts[i]))</a>
<a name="ln1471">        {</a>
<a name="ln1472">            mprf(&quot;%s %s healed.&quot;, beasts[i]-&gt;name(DESC_THE).c_str(),</a>
<a name="ln1473">                                  beasts[i]-&gt;conj_verb(&quot;are&quot;).c_str());</a>
<a name="ln1474">        }</a>
<a name="ln1475">    }</a>
<a name="ln1476"> </a>
<a name="ln1477">    for (int i = 0; i &lt; num; ++i)</a>
<a name="ln1478">    {</a>
<a name="ln1479">        simple_monster_message(*beasts[i], &quot; seems to grow more fierce.&quot;);</a>
<a name="ln1480">        beasts[i]-&gt;add_ench(mon_enchant(ENCH_MIGHT, 1, mons,</a>
<a name="ln1481">                                        random_range(100, 160)));</a>
<a name="ln1482">    }</a>
<a name="ln1483">}</a>
<a name="ln1484"> </a>
<a name="ln1485">static bool _mons_reaped(actor &amp;killer, monster&amp; victim)</a>
<a name="ln1486">{</a>
<a name="ln1487">    beh_type beh;</a>
<a name="ln1488">    unsigned short hitting;</a>
<a name="ln1489"> </a>
<a name="ln1490">    if (killer.is_player())</a>
<a name="ln1491">    {</a>
<a name="ln1492">        hitting = MHITYOU;</a>
<a name="ln1493">        beh     = BEH_FRIENDLY;</a>
<a name="ln1494">    }</a>
<a name="ln1495">    else</a>
<a name="ln1496">    {</a>
<a name="ln1497">        monster* mon = killer.as_monster();</a>
<a name="ln1498"> </a>
<a name="ln1499">        beh = SAME_ATTITUDE(mon);</a>
<a name="ln1500"> </a>
<a name="ln1501">        // Get a new foe for the zombie to target.</a>
<a name="ln1502">        behaviour_event(mon, ME_EVAL);</a>
<a name="ln1503">        hitting = mon-&gt;foe;</a>
<a name="ln1504">    }</a>
<a name="ln1505"> </a>
<a name="ln1506">    monster *zombie = 0;</a>
<a name="ln1507">    if (animate_remains(victim.pos(), CORPSE_BODY, beh, hitting, &amp;killer, &quot;&quot;,</a>
<a name="ln1508">                        GOD_NO_GOD, true, true, true, &amp;zombie) &lt;= 0)</a>
<a name="ln1509">    {</a>
<a name="ln1510">        return false;</a>
<a name="ln1511">    }</a>
<a name="ln1512"> </a>
<a name="ln1513">    if (you.can_see(victim))</a>
<a name="ln1514">        mprf(&quot;%s turns into a zombie!&quot;, victim.name(DESC_THE).c_str());</a>
<a name="ln1515">    else if (you.can_see(*zombie))</a>
<a name="ln1516">        mprf(&quot;%s appears out of thin air!&quot;, zombie-&gt;name(DESC_THE).c_str());</a>
<a name="ln1517"> </a>
<a name="ln1518">    player_angers_monster(zombie);</a>
<a name="ln1519"> </a>
<a name="ln1520">    return true;</a>
<a name="ln1521">}</a>
<a name="ln1522"> </a>
<a name="ln1523">static bool _reaping(monster &amp;mons)</a>
<a name="ln1524">{</a>
<a name="ln1525">    if (!mons.props.exists(&quot;reaping_damage&quot;))</a>
<a name="ln1526">        return false;</a>
<a name="ln1527"> </a>
<a name="ln1528">    int rd = mons.props[&quot;reaping_damage&quot;].get_int();</a>
<a name="ln1529">    dprf(&quot;Reaping chance: %d/%d&quot;, rd, mons.damage_total);</a>
<a name="ln1530">    if (!x_chance_in_y(rd, mons.damage_total))</a>
<a name="ln1531">        return false;</a>
<a name="ln1532"> </a>
<a name="ln1533">    actor *killer = actor_by_mid(mons.props[&quot;reaper&quot;].get_int());</a>
<a name="ln1534">    if (killer)</a>
<a name="ln1535">        return _mons_reaped(*killer, mons);</a>
<a name="ln1536">    return false;</a>
<a name="ln1537">}</a>
<a name="ln1538"> </a>
<a name="ln1539">static bool _god_will_bless_follower(monster* victim)</a>
<a name="ln1540">{</a>
<a name="ln1541">    return have_passive(passive_t::bless_followers)</a>
<a name="ln1542">           &amp;&amp; random2(you.piety) &gt;= piety_breakpoint(2)</a>
<a name="ln1543">           || have_passive(passive_t::bless_followers_vs_evil)</a>
<a name="ln1544">              &amp;&amp; victim-&gt;evil()</a>
<a name="ln1545">              &amp;&amp; random2(you.piety) &gt;= piety_breakpoint(0);</a>
<a name="ln1546">}</a>
<a name="ln1547"> </a>
<a name="ln1548">/**</a>
<a name="ln1549"> * Trigger the appropriate god conducts for a monster's death.</a>
<a name="ln1550"> *</a>
<a name="ln1551"> * @param mons              The dying monster.</a>
<a name="ln1552"> * @param killer            The responsibility for the death.</a>
<a name="ln1553"> *                          (KILL_YOU, KILL_MON...)</a>
<a name="ln1554"> * @param killer_index      The mindex of the killer, if known.</a>
<a name="ln1555"> * @param maybe_good_kill   Whether the kill can be rewarding in piety.</a>
<a name="ln1556"> *                          (Not summoned, etc)</a>
<a name="ln1557"> */</a>
<a name="ln1558">static void _fire_kill_conducts(monster &amp;mons, killer_type killer,</a>
<a name="ln1559">                                int killer_index, bool maybe_good_kill)</a>
<a name="ln1560">{</a>
<a name="ln1561">    const bool your_kill = killer == KILL_YOU ||</a>
<a name="ln1562">                           killer == KILL_YOU_CONF ||</a>
<a name="ln1563">                           killer == KILL_YOU_MISSILE;</a>
<a name="ln1564">    const bool pet_kill = _is_pet_kill(killer, killer_index);</a>
<a name="ln1565"> </a>
<a name="ln1566">    // Pretend the monster is already dead, so that make_god_gifts_disappear</a>
<a name="ln1567">    // (and similar) don't kill it twice.</a>
<a name="ln1568">    unwind_var&lt;int&gt; fake_hp(mons.hit_points, 0);</a>
<a name="ln1569"> </a>
<a name="ln1570">    // if you or your pets didn't do it, no one cares</a>
<a name="ln1571">    if (!your_kill &amp;&amp; !pet_kill)</a>
<a name="ln1572">        return;</a>
<a name="ln1573"> </a>
<a name="ln1574">    // player gets credit for reflection kills, but not blame</a>
<a name="ln1575">    const bool blameworthy = god_hates_killing(you.religion, mons)</a>
<a name="ln1576">                             &amp;&amp; killer_index != YOU_FAULTLESS;</a>
<a name="ln1577">    // if you can't get piety for it &amp; your god won't give penance/-piety for</a>
<a name="ln1578">    // it, no one cares</a>
<a name="ln1579">    // XXX: this will break holy death curses if they're added back...</a>
<a name="ln1580">    // but tbh that shouldn't really be in conducts anyway</a>
<a name="ln1581">    if (!maybe_good_kill &amp;&amp; !blameworthy)</a>
<a name="ln1582">        return;</a>
<a name="ln1583"> </a>
<a name="ln1584">    mon_holy_type holiness = mons.holiness();</a>
<a name="ln1585"> </a>
<a name="ln1586">    if (holiness &amp; MH_DEMONIC)</a>
<a name="ln1587">        did_kill_conduct(DID_KILL_DEMON, mons);</a>
<a name="ln1588">    else if (holiness &amp; (MH_NATURAL | MH_PLANT))</a>
<a name="ln1589">    {</a>
<a name="ln1590">        did_kill_conduct(DID_KILL_LIVING, mons);</a>
<a name="ln1591"> </a>
<a name="ln1592">        // TSO hates natural evil and unholy beings.</a>
<a name="ln1593">        if (mons.evil())</a>
<a name="ln1594">            did_kill_conduct(DID_KILL_NATURAL_EVIL, mons);</a>
<a name="ln1595">    }</a>
<a name="ln1596">    else if (holiness &amp; MH_UNDEAD)</a>
<a name="ln1597">        did_kill_conduct(DID_KILL_UNDEAD, mons);</a>
<a name="ln1598">    else if (holiness &amp; MH_NONLIVING)</a>
<a name="ln1599">        did_kill_conduct(DID_KILL_NONLIVING, mons);</a>
<a name="ln1600"> </a>
<a name="ln1601">    // Zin hates unclean and chaotic beings.</a>
<a name="ln1602">    if (mons.how_unclean())</a>
<a name="ln1603">        did_kill_conduct(DID_KILL_UNCLEAN, mons);</a>
<a name="ln1604">    else if (mons.how_chaotic())</a>
<a name="ln1605">        did_kill_conduct(DID_KILL_CHAOTIC, mons);</a>
<a name="ln1606"> </a>
<a name="ln1607">    // jmf: Trog hates wizards.</a>
<a name="ln1608">    if (mons.is_actual_spellcaster())</a>
<a name="ln1609">        did_kill_conduct(DID_KILL_WIZARD, mons);</a>
<a name="ln1610"> </a>
<a name="ln1611">    // Beogh hates priests of other gods.</a>
<a name="ln1612">    if (mons.is_priest())</a>
<a name="ln1613">        did_kill_conduct(DID_KILL_PRIEST, mons);</a>
<a name="ln1614"> </a>
<a name="ln1615">    // Jiyva hates you killing slimes, but eyeballs</a>
<a name="ln1616">    // mutation can confuse without you meaning it.</a>
<a name="ln1617">    if (mons_is_slime(mons) &amp;&amp; killer != KILL_YOU_CONF)</a>
<a name="ln1618">        did_kill_conduct(DID_KILL_SLIME, mons);</a>
<a name="ln1619"> </a>
<a name="ln1620">    if (mons.is_holy())</a>
<a name="ln1621">        did_kill_conduct(DID_KILL_HOLY, mons);</a>
<a name="ln1622"> </a>
<a name="ln1623">    // Fedhas shrooms cause confusion which leads to subsequent</a>
<a name="ln1624">    // confusion kills, sometimes of the player's own plants</a>
<a name="ln1625">    if (fedhas_protects(&amp;mons) &amp;&amp; killer != KILL_YOU_CONF)</a>
<a name="ln1626">        did_kill_conduct(DID_KILL_PLANT, mons);</a>
<a name="ln1627"> </a>
<a name="ln1628">    // Cheibriados hates fast monsters.</a>
<a name="ln1629">    if (cheibriados_thinks_mons_is_fast(mons) &amp;&amp; !mons.cannot_move())</a>
<a name="ln1630">        did_kill_conduct(DID_KILL_FAST, mons);</a>
<a name="ln1631">}</a>
<a name="ln1632"> </a>
<a name="ln1633">item_def* monster_die(monster&amp; mons, const actor *killer, bool silent,</a>
<a name="ln1634">                      bool wizard, bool fake)</a>
<a name="ln1635">{</a>
<a name="ln1636">    killer_type ktype = KILL_YOU;</a>
<a name="ln1637">    int kindex = NON_MONSTER;</a>
<a name="ln1638"> </a>
<a name="ln1639">    if (!killer)</a>
<a name="ln1640">        ktype = KILL_NONE;</a>
<a name="ln1641">    else if (killer-&gt;is_monster())</a>
<a name="ln1642">    {</a>
<a name="ln1643">        const monster *kmons = killer-&gt;as_monster();</a>
<a name="ln1644">        ktype = kmons-&gt;confused_by_you() ? KILL_YOU_CONF : KILL_MON;</a>
<a name="ln1645">        kindex = kmons-&gt;mindex();</a>
<a name="ln1646">    }</a>
<a name="ln1647"> </a>
<a name="ln1648">    return monster_die(mons, ktype, kindex, silent, wizard, fake);</a>
<a name="ln1649">}</a>
<a name="ln1650"> </a>
<a name="ln1651">/**</a>
<a name="ln1652"> * Print messages for dead monsters returning to their 'true form' on death.</a>
<a name="ln1653"> *</a>
<a name="ln1654"> * @param mons      The monster currently dying.</a>
<a name="ln1655"> */</a>
<a name="ln1656">static void _special_corpse_messaging(monster &amp;mons)</a>
<a name="ln1657">{</a>
<a name="ln1658">    if (!mons.props.exists(ORIGINAL_TYPE_KEY) &amp;&amp; mons.type != MONS_BAI_SUZHEN)</a>
<a name="ln1659">        return;</a>
<a name="ln1660"> </a>
<a name="ln1661">    const monster_type orig</a>
<a name="ln1662">        = mons.type == MONS_BAI_SUZHEN ? mons.type :</a>
<a name="ln1663">                (monster_type) mons.props[ORIGINAL_TYPE_KEY].get_int();</a>
<a name="ln1664"> </a>
<a name="ln1665">    if (orig == MONS_SHAPESHIFTER || orig == MONS_GLOWING_SHAPESHIFTER)</a>
<a name="ln1666">    {</a>
<a name="ln1667">        // No message for known shifters, unless they were originally</a>
<a name="ln1668">        // something else.</a>
<a name="ln1669">        if (!(mons.flags &amp; MF_KNOWN_SHIFTER))</a>
<a name="ln1670">        {</a>
<a name="ln1671">            const string message = &quot;'s shape twists and changes as &quot;</a>
<a name="ln1672">                + mons.pronoun(PRONOUN_SUBJECTIVE) + &quot; &quot;</a>
<a name="ln1673">                + conjugate_verb(&quot;die&quot;, mons.pronoun_plurality()) + &quot;.&quot;;</a>
<a name="ln1674">            simple_monster_message(mons, message.c_str());</a>
<a name="ln1675">        }</a>
<a name="ln1676"> </a>
<a name="ln1677">        return;</a>
<a name="ln1678">    }</a>
<a name="ln1679"> </a>
<a name="ln1680">    // Avoid &quot;Sigmund returns to its original shape as it dies.&quot;.</a>
<a name="ln1681">    unwind_var&lt;monster_type&gt; mt(mons.type, orig);</a>
<a name="ln1682">    const int num = mons.mons_species() == MONS_HYDRA</a>
<a name="ln1683">                    ? mons.props[&quot;old_heads&quot;].get_int()</a>
<a name="ln1684">                    : mons.number;</a>
<a name="ln1685">    unwind_var&lt;unsigned int&gt; number(mons.number, num);</a>
<a name="ln1686">    const string message = &quot; returns to &quot; +</a>
<a name="ln1687">                            mons.pronoun(PRONOUN_POSSESSIVE) +</a>
<a name="ln1688">                            &quot; original shape as &quot; +</a>
<a name="ln1689">                            mons.pronoun(PRONOUN_SUBJECTIVE) + &quot; &quot; +</a>
<a name="ln1690">                            conjugate_verb(&quot;die&quot;, mons.pronoun_plurality()) +</a>
<a name="ln1691">                            &quot;.&quot;;</a>
<a name="ln1692">    simple_monster_message(mons, message.c_str());</a>
<a name="ln1693">}</a>
<a name="ln1694"> </a>
<a name="ln1695">/**</a>
<a name="ln1696"> * Kill off a monster.</a>
<a name="ln1697"> *</a>
<a name="ln1698"> * @param mons The monster to be killed</a>
<a name="ln1699"> * @param killer The method in which it was killed (XXX: these aren't properly</a>
<a name="ln1700"> *               documented/coded)</a>
<a name="ln1701"> * @param killer_index The mindex of the killer (TODO: always use an actor*)</a>
<a name="ln1702"> * @param silent whether to print any messages about the death</a>
<a name="ln1703"> * @param wizard various switches</a>
<a name="ln1704"> * @param fake   The death of the mount of a mounted monster (spriggan rider).</a>
<a name="ln1705"> * @returns a pointer to the created corpse, possibly null</a>
<a name="ln1706"> */</a>
<a name="ln1707">item_def* monster_die(monster&amp; mons, killer_type killer,</a>
<a name="ln1708">                      int killer_index, bool silent, bool wizard, bool fake)</a>
<a name="ln1709">{</a>
<a name="ln1710">    ASSERT(!invalid_monster(&amp;mons));</a>
<a name="ln1711"> </a>
<a name="ln1712">    const bool was_visible = you.can_see(mons);</a>
<a name="ln1713"> </a>
<a name="ln1714">    // If a monster was banished to the Abyss and then killed there,</a>
<a name="ln1715">    // then its death wasn't a banishment.</a>
<a name="ln1716">    if (player_in_branch(BRANCH_ABYSS))</a>
<a name="ln1717">        mons.flags &amp;= ~MF_BANISHED;</a>
<a name="ln1718"> </a>
<a name="ln1719">    const bool spectralised = testbits(mons.flags, MF_SPECTRALISED);</a>
<a name="ln1720"> </a>
<a name="ln1721">    if (!silent &amp;&amp; !fake</a>
<a name="ln1722">        &amp;&amp; _monster_avoided_death(&amp;mons, killer, killer_index))</a>
<a name="ln1723">    {</a>
<a name="ln1724">        mons.flags &amp;= ~MF_EXPLODE_KILL;</a>
<a name="ln1725"> </a>
<a name="ln1726">        // revived by a lost soul?</a>
<a name="ln1727">        if (!spectralised &amp;&amp; testbits(mons.flags, MF_SPECTRALISED))</a>
<a name="ln1728">            return place_monster_corpse(mons, silent);</a>
<a name="ln1729">        return nullptr;</a>
<a name="ln1730">    }</a>
<a name="ln1731"> </a>
<a name="ln1732">    // If the monster was calling the tide, let go now.</a>
<a name="ln1733">    mons.del_ench(ENCH_TIDE);</a>
<a name="ln1734"> </a>
<a name="ln1735">    // Same for silencers.</a>
<a name="ln1736">    mons.del_ench(ENCH_SILENCE);</a>
<a name="ln1737"> </a>
<a name="ln1738">    // ... and liquefiers.</a>
<a name="ln1739">    mons.del_ench(ENCH_LIQUEFYING);</a>
<a name="ln1740"> </a>
<a name="ln1741">    // ... and wind-stillers.</a>
<a name="ln1742">    mons.del_ench(ENCH_STILL_WINDS, true);</a>
<a name="ln1743"> </a>
<a name="ln1744">    // and webbed monsters</a>
<a name="ln1745">    monster_web_cleanup(mons, true);</a>
<a name="ln1746"> </a>
<a name="ln1747">    // Clean up any blood from the flayed effect</a>
<a name="ln1748">    if (mons.has_ench(ENCH_FLAYED))</a>
<a name="ln1749">        heal_flayed_effect(&amp;mons, true, true);</a>
<a name="ln1750"> </a>
<a name="ln1751">    crawl_state.inc_mon_acting(&amp;mons);</a>
<a name="ln1752"> </a>
<a name="ln1753">    ASSERT(!(YOU_KILL(killer) &amp;&amp; crawl_state.game_is_arena()));</a>
<a name="ln1754"> </a>
<a name="ln1755">    if (mons.props.exists(MONSTER_DIES_LUA_KEY))</a>
<a name="ln1756">    {</a>
<a name="ln1757">        lua_stack_cleaner clean(dlua);</a>
<a name="ln1758"> </a>
<a name="ln1759">        dlua_chunk &amp;chunk = mons.props[MONSTER_DIES_LUA_KEY];</a>
<a name="ln1760"> </a>
<a name="ln1761">        if (!chunk.load(dlua))</a>
<a name="ln1762">        {</a>
<a name="ln1763">            push_monster(dlua, &amp;mons);</a>
<a name="ln1764">            clua_pushcxxstring(dlua, _killer_type_name(killer));</a>
<a name="ln1765">            dlua.callfn(nullptr, 2, 0);</a>
<a name="ln1766">        }</a>
<a name="ln1767">        else</a>
<a name="ln1768">        {</a>
<a name="ln1769">            mprf(MSGCH_ERROR,</a>
<a name="ln1770">                 &quot;Lua death function for monster '%s' didn't load: %s&quot;,</a>
<a name="ln1771">                 mons.full_name(DESC_PLAIN).c_str(),</a>
<a name="ln1772">                 dlua.error.c_str());</a>
<a name="ln1773">        }</a>
<a name="ln1774">    }</a>
<a name="ln1775"> </a>
<a name="ln1776">    mons_clear_trapping_net(&amp;mons);</a>
<a name="ln1777">    mons.stop_constricting_all();</a>
<a name="ln1778">    mons.stop_being_constricted();</a>
<a name="ln1779"> </a>
<a name="ln1780">    you.remove_beholder(mons);</a>
<a name="ln1781">    you.remove_fearmonger(&amp;mons);</a>
<a name="ln1782">    // Uniques leave notes and milestones, so this information is already leaked.</a>
<a name="ln1783">    remove_unique_annotation(&amp;mons);</a>
<a name="ln1784"> </a>
<a name="ln1785">          int  duration      = 0;</a>
<a name="ln1786">    const bool summoned      = mons.is_summoned(&amp;duration);</a>
<a name="ln1787">    const int monster_killed = mons.mindex();</a>
<a name="ln1788">    const bool hard_reset    = testbits(mons.flags, MF_HARD_RESET);</a>
<a name="ln1789">    const bool timeout       = killer == KILL_TIMEOUT;</a>
<a name="ln1790">    const bool fake_abjure   = mons.has_ench(ENCH_FAKE_ABJURATION);</a>
<a name="ln1791">    const bool gives_player_xp = mons_gives_xp(mons, you);</a>
<a name="ln1792">    bool drop_items          = !hard_reset;</a>
<a name="ln1793">    const bool submerged     = mons.submerged();</a>
<a name="ln1794">    bool in_transit          = false;</a>
<a name="ln1795">    const bool was_banished  = (killer == KILL_BANISHED);</a>
<a name="ln1796">    const bool mons_reset    = (killer == KILL_RESET</a>
<a name="ln1797">                                || killer == KILL_DISMISSED);</a>
<a name="ln1798">    const bool leaves_corpse = !summoned &amp;&amp; !fake_abjure &amp;&amp; !timeout</a>
<a name="ln1799">                               &amp;&amp; !mons_reset</a>
<a name="ln1800">                               &amp;&amp; !mons_is_tentacle_segment(mons.type);</a>
<a name="ln1801">    // Award experience for suicide if the suicide was caused by the</a>
<a name="ln1802">    // player.</a>
<a name="ln1803">    if (MON_KILL(killer) &amp;&amp; monster_killed == killer_index)</a>
<a name="ln1804">    {</a>
<a name="ln1805">        if (mons.confused_by_you())</a>
<a name="ln1806">        {</a>
<a name="ln1807">            ASSERT(!crawl_state.game_is_arena());</a>
<a name="ln1808">            killer = KILL_YOU_CONF;</a>
<a name="ln1809">        }</a>
<a name="ln1810">    }</a>
<a name="ln1811">    else if (MON_KILL(killer) &amp;&amp; mons.has_ench(ENCH_CHARM))</a>
<a name="ln1812">    {</a>
<a name="ln1813">        bool arena = crawl_state.game_is_arena();</a>
<a name="ln1814">        mon_enchant ench = mons.get_ench(ENCH_CHARM);</a>
<a name="ln1815">        if (ench.who == KC_YOU || (!arena &amp;&amp; ench.who == KC_FRIENDLY))</a>
<a name="ln1816">        {</a>
<a name="ln1817">            ASSERT(!arena);</a>
<a name="ln1818">            killer = KILL_YOU_CONF; // Well, it was confused in a sense... (jpeg)</a>
<a name="ln1819">        }</a>
<a name="ln1820">    }</a>
<a name="ln1821"> </a>
<a name="ln1822">    // Kills by the spectral weapon are considered as kills by the player</a>
<a name="ln1823">    // instead. Ditto Dithmenos shadow melee and shadow throw.</a>
<a name="ln1824">    if (MON_KILL(killer)</a>
<a name="ln1825">        &amp;&amp; !invalid_monster_index(killer_index)</a>
<a name="ln1826">        &amp;&amp; ((menv[killer_index].type == MONS_SPECTRAL_WEAPON</a>
<a name="ln1827">             &amp;&amp; menv[killer_index].summoner == MID_PLAYER)</a>
<a name="ln1828">            || mons_is_player_shadow(menv[killer_index])))</a>
<a name="ln1829">    {</a>
<a name="ln1830">        killer_index = you.mindex();</a>
<a name="ln1831">    }</a>
<a name="ln1832"> </a>
<a name="ln1833">    // Set an appropriate killer; besides the cases in the preceding if,</a>
<a name="ln1834">    // this handles Dithmenos shadow spells, which look like they come from</a>
<a name="ln1835">    // you because the shadow's mid is MID_PLAYER.</a>
<a name="ln1836">    if (MON_KILL(killer) &amp;&amp; killer_index == you.mindex())</a>
<a name="ln1837">        killer = (killer == KILL_MON_MISSILE) ? KILL_YOU_MISSILE : KILL_YOU;</a>
<a name="ln1838"> </a>
<a name="ln1839">    // Take notes and mark milestones.</a>
<a name="ln1840">    record_monster_defeat(&amp;mons, killer);</a>
<a name="ln1841"> </a>
<a name="ln1842">    // Various sources of berserk extension on kills.</a>
<a name="ln1843">    if (killer == KILL_YOU &amp;&amp; you.berserk())</a>
<a name="ln1844">    {</a>
<a name="ln1845">        if (have_passive(passive_t::extend_berserk)</a>
<a name="ln1846">            &amp;&amp; you.piety &gt; random2(1000))</a>
<a name="ln1847">        {</a>
<a name="ln1848">            const int bonus = (3 + random2avg(10, 2)) / 2;</a>
<a name="ln1849"> </a>
<a name="ln1850">            you.increase_duration(DUR_BERSERK, bonus);</a>
<a name="ln1851"> </a>
<a name="ln1852">            mprf(MSGCH_GOD, you.religion,</a>
<a name="ln1853">                 &quot;You feel the power of %s in you as your rage grows.&quot;,</a>
<a name="ln1854">                 uppercase_first(god_name(you.religion)).c_str());</a>
<a name="ln1855">        }</a>
<a name="ln1856">        else if (player_equip_unrand(UNRAND_BLOODLUST) &amp;&amp; coinflip())</a>
<a name="ln1857">        {</a>
<a name="ln1858">            const int bonus = (2 + random2(4)) / 2;</a>
<a name="ln1859">            you.increase_duration(DUR_BERSERK, bonus);</a>
<a name="ln1860">            mpr(&quot;The necklace of Bloodlust glows a violent red.&quot;);</a>
<a name="ln1861">        }</a>
<a name="ln1862">    }</a>
<a name="ln1863"> </a>
<a name="ln1864">    if (you.prev_targ == monster_killed)</a>
<a name="ln1865">    {</a>
<a name="ln1866">        you.prev_targ = MHITNOT;</a>
<a name="ln1867">        crawl_state.cancel_cmd_repeat();</a>
<a name="ln1868">    }</a>
<a name="ln1869"> </a>
<a name="ln1870">    if (killer == KILL_YOU)</a>
<a name="ln1871">        crawl_state.cancel_cmd_repeat();</a>
<a name="ln1872"> </a>
<a name="ln1873">    const bool pet_kill = _is_pet_kill(killer, killer_index);</a>
<a name="ln1874"> </a>
<a name="ln1875">    bool did_death_message = false;</a>
<a name="ln1876"> </a>
<a name="ln1877">    if (mons.type == MONS_BALLISTOMYCETE_SPORE</a>
<a name="ln1878">        || mons.type == MONS_BALL_LIGHTNING</a>
<a name="ln1879">        || mons.type == MONS_LURKING_HORROR</a>
<a name="ln1880">        || (mons.type == MONS_FULMINANT_PRISM &amp;&amp; mons.prism_charge &gt; 0)</a>
<a name="ln1881">        || mons.type == MONS_BENNU</a>
<a name="ln1882">        || mons.has_ench(ENCH_INNER_FLAME))</a>
<a name="ln1883">    {</a>
<a name="ln1884">        did_death_message =</a>
<a name="ln1885">            _explode_monster(&amp;mons, killer, pet_kill, wizard);</a>
<a name="ln1886">    }</a>
<a name="ln1887">    else if (mons.type == MONS_FULMINANT_PRISM &amp;&amp; mons.prism_charge == 0)</a>
<a name="ln1888">    {</a>
<a name="ln1889">        if (!silent &amp;&amp; !hard_reset &amp;&amp; !was_banished)</a>
<a name="ln1890">        {</a>
<a name="ln1891">            simple_monster_message(mons, &quot; detonates feebly.&quot;,</a>
<a name="ln1892">                                   MSGCH_MONSTER_DAMAGE, MDAM_DEAD);</a>
<a name="ln1893">            silent = true;</a>
<a name="ln1894">        }</a>
<a name="ln1895">    }</a>
<a name="ln1896">    else if (mons.type == MONS_FIRE_VORTEX</a>
<a name="ln1897">             || mons.type == MONS_SPATIAL_VORTEX</a>
<a name="ln1898">             || mons.type == MONS_TWISTER</a>
<a name="ln1899">             || (mons.type == MONS_FOXFIRE &amp;&amp; mons.steps_remaining == 0))</a>
<a name="ln1900">    {</a>
<a name="ln1901">        if (!silent &amp;&amp; !mons_reset &amp;&amp; !was_banished)</a>
<a name="ln1902">        {</a>
<a name="ln1903">            simple_monster_message(mons, &quot; dissipates!&quot;,</a>
<a name="ln1904">                                   MSGCH_MONSTER_DAMAGE, MDAM_DEAD);</a>
<a name="ln1905">            silent = true;</a>
<a name="ln1906">        }</a>
<a name="ln1907"> </a>
<a name="ln1908">        if (mons.type == MONS_FIRE_VORTEX &amp;&amp; !wizard &amp;&amp; !mons_reset</a>
<a name="ln1909">            &amp;&amp; !submerged &amp;&amp; !was_banished &amp;&amp; !cell_is_solid(mons.pos()))</a>
<a name="ln1910">        {</a>
<a name="ln1911">            place_cloud(CLOUD_FIRE, mons.pos(), 2 + random2(4), &amp;mons);</a>
<a name="ln1912">        }</a>
<a name="ln1913"> </a>
<a name="ln1914">        if (killer == KILL_RESET)</a>
<a name="ln1915">            killer = KILL_DISMISSED;</a>
<a name="ln1916">    }</a>
<a name="ln1917">    else if (mons.type == MONS_FOXFIRE)</a>
<a name="ln1918">    {</a>
<a name="ln1919">        // Foxfires are unkillable, they either dissapate by timing out</a>
<a name="ln1920">        // or hit something.</a>
<a name="ln1921">        silent = true;</a>
<a name="ln1922">    }</a>
<a name="ln1923">    else if (mons.type == MONS_SIMULACRUM)</a>
<a name="ln1924">    {</a>
<a name="ln1925">        if (!silent &amp;&amp; !mons_reset &amp;&amp; !was_banished)</a>
<a name="ln1926">        {</a>
<a name="ln1927">            simple_monster_message(mons, &quot; vapourises!&quot;,</a>
<a name="ln1928">                                   MSGCH_MONSTER_DAMAGE, MDAM_DEAD);</a>
<a name="ln1929">            silent = true;</a>
<a name="ln1930">        }</a>
<a name="ln1931"> </a>
<a name="ln1932">        if (!wizard &amp;&amp; !mons_reset &amp;&amp; !submerged &amp;&amp; !was_banished</a>
<a name="ln1933">            &amp;&amp; !cell_is_solid(mons.pos()))</a>
<a name="ln1934">        {</a>
<a name="ln1935">            place_cloud(CLOUD_COLD, mons.pos(), 2 + random2(4), &amp;mons);</a>
<a name="ln1936">        }</a>
<a name="ln1937"> </a>
<a name="ln1938">        if (killer == KILL_RESET)</a>
<a name="ln1939">            killer = KILL_DISMISSED;</a>
<a name="ln1940">    }</a>
<a name="ln1941">    else if (mons.type == MONS_DANCING_WEAPON)</a>
<a name="ln1942">    {</a>
<a name="ln1943">        if (!hard_reset)</a>
<a name="ln1944">        {</a>
<a name="ln1945">            if (killer == KILL_RESET)</a>
<a name="ln1946">                killer = KILL_DISMISSED;</a>
<a name="ln1947">        }</a>
<a name="ln1948"> </a>
<a name="ln1949">        int w_idx = mons.inv[MSLOT_WEAPON];</a>
<a name="ln1950">        ASSERT(w_idx != NON_ITEM);</a>
<a name="ln1951"> </a>
<a name="ln1952">        // XXX: This can probably become mons.is_summoned(): there's no</a>
<a name="ln1953">        // feasible way for a dancing weapon to &quot;drop&quot; it's weapon and somehow</a>
<a name="ln1954">        // gain a summoned one, or vice versa.</a>
<a name="ln1955">        bool summoned_it = mitm[w_idx].flags &amp; ISFLAG_SUMMONED;</a>
<a name="ln1956"> </a>
<a name="ln1957">        if (!silent &amp;&amp; !hard_reset &amp;&amp; !was_banished)</a>
<a name="ln1958">        {</a>
<a name="ln1959">            // Under Gozag, permanent dancing weapons get turned to gold.</a>
<a name="ln1960">            if (!summoned_it</a>
<a name="ln1961">                &amp;&amp; (!have_passive(passive_t::goldify_corpses)</a>
<a name="ln1962">                    || mons.has_ench(ENCH_ABJ)))</a>
<a name="ln1963">            {</a>
<a name="ln1964">                simple_monster_message(mons, &quot; falls from the air.&quot;,</a>
<a name="ln1965">                                       MSGCH_MONSTER_DAMAGE, MDAM_DEAD);</a>
<a name="ln1966">                silent = true;</a>
<a name="ln1967">            }</a>
<a name="ln1968">            else</a>
<a name="ln1969">                killer = KILL_RESET;</a>
<a name="ln1970">        }</a>
<a name="ln1971"> </a>
<a name="ln1972">        if (was_banished &amp;&amp; !summoned_it &amp;&amp; !hard_reset</a>
<a name="ln1973">            &amp;&amp; mons.has_ench(ENCH_ABJ))</a>
<a name="ln1974">        {</a>
<a name="ln1975">            if (is_unrandom_artefact(mitm[w_idx]))</a>
<a name="ln1976">                set_unique_item_status(mitm[w_idx], UNIQ_LOST_IN_ABYSS);</a>
<a name="ln1977"> </a>
<a name="ln1978">            destroy_item(w_idx);</a>
<a name="ln1979">        }</a>
<a name="ln1980">    }</a>
<a name="ln1981">    else if (mons.type == MONS_ELDRITCH_TENTACLE)</a>
<a name="ln1982">    {</a>
<a name="ln1983">        if (!silent &amp;&amp; !mons_reset &amp;&amp; !mons.has_ench(ENCH_SEVERED)</a>
<a name="ln1984">            &amp;&amp; !was_banished)</a>
<a name="ln1985">        {</a>
<a name="ln1986">            if (you.can_see(mons))</a>
<a name="ln1987">            {</a>
<a name="ln1988">                mprf(MSGCH_MONSTER_DAMAGE, MDAM_DEAD, silenced(mons.pos()) ?</a>
<a name="ln1989">                    &quot;The tentacle is hauled back through the portal!&quot; :</a>
<a name="ln1990">                    &quot;With a roar, the tentacle is hauled back through the portal!&quot;);</a>
<a name="ln1991">            }</a>
<a name="ln1992">            silent = true;</a>
<a name="ln1993">        }</a>
<a name="ln1994"> </a>
<a name="ln1995">        if (killer == KILL_RESET)</a>
<a name="ln1996">            killer = KILL_DISMISSED;</a>
<a name="ln1997">    }</a>
<a name="ln1998">    else if (mons.type == MONS_BATTLESPHERE)</a>
<a name="ln1999">    {</a>
<a name="ln2000">        if (!wizard &amp;&amp; !mons_reset &amp;&amp; !was_banished</a>
<a name="ln2001">            &amp;&amp; !cell_is_solid(mons.pos()))</a>
<a name="ln2002">        {</a>
<a name="ln2003">            place_cloud(CLOUD_MAGIC_TRAIL, mons.pos(), 3 + random2(3), &amp;mons);</a>
<a name="ln2004">        }</a>
<a name="ln2005">        end_battlesphere(&amp;mons, true);</a>
<a name="ln2006">    }</a>
<a name="ln2007">    else if (mons.type == MONS_BRIAR_PATCH)</a>
<a name="ln2008">    {</a>
<a name="ln2009">        if (timeout &amp;&amp; !silent)</a>
<a name="ln2010">            simple_monster_message(mons, &quot; crumbles away.&quot;);</a>
<a name="ln2011">    }</a>
<a name="ln2012">    else if (mons.type == MONS_SPECTRAL_WEAPON)</a>
<a name="ln2013">    {</a>
<a name="ln2014">        end_spectral_weapon(&amp;mons, true, killer == KILL_RESET);</a>
<a name="ln2015">        silent = true;</a>
<a name="ln2016">    }</a>
<a name="ln2017">    else if (mons.type == MONS_DROWNED_SOUL)</a>
<a name="ln2018">    {</a>
<a name="ln2019">        // Suppress death message if 'killed' by touching something</a>
<a name="ln2020">        if (mons.hit_points == -1000)</a>
<a name="ln2021">            silent = true;</a>
<a name="ln2022">    }</a>
<a name="ln2023">    else if (mons.type == MONS_SPRIGGAN_DRUID &amp;&amp; !silent &amp;&amp; !was_banished</a>
<a name="ln2024">             &amp;&amp; !wizard &amp;&amp; !mons_reset)</a>
<a name="ln2025">    {</a>
<a name="ln2026">        _druid_final_boon(&amp;mons);</a>
<a name="ln2027">    }</a>
<a name="ln2028">    else if (mons.type == MONS_ELEMENTAL_WELLSPRING</a>
<a name="ln2029">             &amp;&amp; mons.mindex() == killer_index)</a>
<a name="ln2030">    {</a>
<a name="ln2031">        if (!silent)</a>
<a name="ln2032">            simple_monster_message(mons, &quot; exhausts itself and dries up.&quot;);</a>
<a name="ln2033">        silent = true;</a>
<a name="ln2034">    }</a>
<a name="ln2035"> </a>
<a name="ln2036">    const bool death_message = !silent &amp;&amp; !did_death_message</a>
<a name="ln2037">                               &amp;&amp; you.can_see(mons);</a>
<a name="ln2038">    const bool exploded {mons.flags &amp; MF_EXPLODE_KILL};</a>
<a name="ln2039">    bool anon = (killer_index == ANON_FRIENDLY_MONSTER);</a>
<a name="ln2040">    const mon_holy_type targ_holy = mons.holiness();</a>
<a name="ln2041"> </a>
<a name="ln2042">    // Adjust song of slaying bonus. Kills by relevant avatars are adjusted by</a>
<a name="ln2043">    // now to KILL_YOU and are counted.</a>
<a name="ln2044">    if (you.duration[DUR_SONG_OF_SLAYING]</a>
<a name="ln2045">        &amp;&amp; killer == KILL_YOU</a>
<a name="ln2046">        &amp;&amp; gives_player_xp)</a>
<a name="ln2047">    {</a>
<a name="ln2048">        const int sos_bonus = you.props[SONG_OF_SLAYING_KEY].get_int();</a>
<a name="ln2049">        if (sos_bonus &lt;= 8) // cap at +9 slay</a>
<a name="ln2050">            you.props[SONG_OF_SLAYING_KEY] = sos_bonus + 1;</a>
<a name="ln2051">    }</a>
<a name="ln2052"> </a>
<a name="ln2053">    switch (killer)</a>
<a name="ln2054">    {</a>
<a name="ln2055">        case KILL_YOU:          // You kill in combat.</a>
<a name="ln2056">        case KILL_YOU_MISSILE:  // You kill by missile or beam.</a>
<a name="ln2057">        case KILL_YOU_CONF:     // You kill by confusion.</a>
<a name="ln2058">        {</a>
<a name="ln2059">            if (death_message)</a>
<a name="ln2060">            {</a>
<a name="ln2061">                if (killer == KILL_YOU_CONF</a>
<a name="ln2062">                    &amp;&amp; (anon || !invalid_monster_index(killer_index)))</a>
<a name="ln2063">                {</a>
<a name="ln2064">                    mprf(MSGCH_MONSTER_DAMAGE, MDAM_DEAD, &quot;%s is %s!&quot;,</a>
<a name="ln2065">                         mons.name(DESC_THE).c_str(),</a>
<a name="ln2066">                         exploded                        ? &quot;blown up&quot; :</a>
<a name="ln2067">                         wounded_damaged(targ_holy)      ? &quot;destroyed&quot;</a>
<a name="ln2068">                                                         : &quot;killed&quot;);</a>
<a name="ln2069">                }</a>
<a name="ln2070">                else</a>
<a name="ln2071">                {</a>
<a name="ln2072">                    mprf(MSGCH_MONSTER_DAMAGE, MDAM_DEAD, &quot;You %s %s!&quot;,</a>
<a name="ln2073">                         exploded                        ? &quot;blow up&quot; :</a>
<a name="ln2074">                         wounded_damaged(targ_holy)      ? &quot;destroy&quot;</a>
<a name="ln2075">                                                         : &quot;kill&quot;,</a>
<a name="ln2076">                         mons.name(DESC_THE).c_str());</a>
<a name="ln2077">                }</a>
<a name="ln2078">                // If this monster would otherwise give xp but didn't because</a>
<a name="ln2079">                // it grants no reward or was neutral, give a message.</a>
<a name="ln2080">                if (!gives_player_xp</a>
<a name="ln2081">                    &amp;&amp; mons_class_gives_xp(mons.type)</a>
<a name="ln2082">                    &amp;&amp; !summoned</a>
<a name="ln2083">                    &amp;&amp; !fake_abjure</a>
<a name="ln2084">                    &amp;&amp; !mons.friendly())</a>
<a name="ln2085">                {</a>
<a name="ln2086">                    mpr(&quot;That felt strangely unrewarding.&quot;);</a>
<a name="ln2087">                }</a>
<a name="ln2088">            }</a>
<a name="ln2089"> </a>
<a name="ln2090">            // Killing triggers hints mode lesson.</a>
<a name="ln2091">            if (gives_player_xp)</a>
<a name="ln2092">                _hints_inspect_kill();</a>
<a name="ln2093"> </a>
<a name="ln2094">            _fire_kill_conducts(mons, killer, killer_index, gives_player_xp);</a>
<a name="ln2095"> </a>
<a name="ln2096">            // Divine health and mana restoration doesn't happen when</a>
<a name="ln2097">            // killing born-friendly monsters.</a>
<a name="ln2098">            if (gives_player_xp</a>
<a name="ln2099">                &amp;&amp; (have_passive(passive_t::restore_hp)</a>
<a name="ln2100">                    || have_passive(passive_t::mp_on_kill)</a>
<a name="ln2101">                    || have_passive(passive_t::restore_hp_mp_vs_evil)</a>
<a name="ln2102">                       &amp;&amp; mons.evil())</a>
<a name="ln2103">                &amp;&amp; !mons_is_object(mons.type)</a>
<a name="ln2104">                &amp;&amp; !player_under_penance()</a>
<a name="ln2105">                &amp;&amp; (random2(you.piety) &gt;= piety_breakpoint(0)</a>
<a name="ln2106">#if TAG_MAJOR_VERSION == 34</a>
<a name="ln2107">                    || you_worship(GOD_PAKELLAS)</a>
<a name="ln2108">#endif</a>
<a name="ln2109">                   )</a>
<a name="ln2110">                )</a>
<a name="ln2111">            {</a>
<a name="ln2112">                int hp_heal = 0, mp_heal = 0;</a>
<a name="ln2113"> </a>
<a name="ln2114">                if (have_passive(passive_t::restore_hp))</a>
<a name="ln2115">                {</a>
<a name="ln2116">                    hp_heal = mons.get_experience_level()</a>
<a name="ln2117">                        + random2(mons.get_experience_level());</a>
<a name="ln2118">                }</a>
<a name="ln2119">                if (have_passive(passive_t::restore_hp_mp_vs_evil))</a>
<a name="ln2120">                {</a>
<a name="ln2121">                    hp_heal = random2(1 + 2 * mons.get_experience_level());</a>
<a name="ln2122">                    mp_heal = random2(2 + mons.get_experience_level() / 3);</a>
<a name="ln2123">                }</a>
<a name="ln2124"> </a>
<a name="ln2125">                if (have_passive(passive_t::mp_on_kill))</a>
<a name="ln2126">                {</a>
<a name="ln2127">                    mp_heal = 1 + random2(mons.get_experience_level() / 2);</a>
<a name="ln2128">#if TAG_MAJOR_VERSION == 34</a>
<a name="ln2129">                    if (you.religion == GOD_PAKELLAS)</a>
<a name="ln2130">                        mp_heal = random2(2 + mons.get_experience_level() / 6);</a>
<a name="ln2131">#endif</a>
<a name="ln2132">                }</a>
<a name="ln2133"> </a>
<a name="ln2134">                if (hp_heal &amp;&amp; you.hp &lt; you.hp_max</a>
<a name="ln2135">                    &amp;&amp; !you.duration[DUR_DEATHS_DOOR])</a>
<a name="ln2136">                {</a>
<a name="ln2137">                    canned_msg(MSG_GAIN_HEALTH);</a>
<a name="ln2138">                    inc_hp(hp_heal);</a>
<a name="ln2139">                }</a>
<a name="ln2140"> </a>
<a name="ln2141">                if (mp_heal &amp;&amp; you.magic_points &lt; you.max_magic_points)</a>
<a name="ln2142">                {</a>
<a name="ln2143">                    int tmp = min(you.max_magic_points - you.magic_points,</a>
<a name="ln2144">                                  mp_heal);</a>
<a name="ln2145">                    canned_msg(MSG_GAIN_MAGIC);</a>
<a name="ln2146">                    inc_mp(mp_heal);</a>
<a name="ln2147">                    mp_heal -= tmp;</a>
<a name="ln2148">                }</a>
<a name="ln2149"> </a>
<a name="ln2150">#if TAG_MAJOR_VERSION == 34</a>
<a name="ln2151">                // perhaps this should go to its own function</a>
<a name="ln2152">                if (mp_heal</a>
<a name="ln2153">                    &amp;&amp; have_passive(passive_t::bottle_mp)</a>
<a name="ln2154">                    &amp;&amp; !you_foodless(false))</a>
<a name="ln2155">                {</a>
<a name="ln2156">                    simple_god_message(&quot; collects the excess magic power.&quot;);</a>
<a name="ln2157">                    you.attribute[ATTR_PAKELLAS_EXTRA_MP] -= mp_heal;</a>
<a name="ln2158"> </a>
<a name="ln2159">                    if (you.attribute[ATTR_PAKELLAS_EXTRA_MP] &lt;= 0</a>
<a name="ln2160">                        &amp;&amp; (feat_has_solid_floor(grd(you.pos()))</a>
<a name="ln2161">                            || feat_is_watery(grd(you.pos()))</a>
<a name="ln2162">                               &amp;&amp; species_likes_water(you.species)))</a>
<a name="ln2163">                    {</a>
<a name="ln2164">                        int thing_created = items(true, OBJ_POTIONS,</a>
<a name="ln2165">                                                  POT_MAGIC, 1, 0,</a>
<a name="ln2166">                                                  GOD_PAKELLAS);</a>
<a name="ln2167">                        if (thing_created != NON_ITEM)</a>
<a name="ln2168">                        {</a>
<a name="ln2169">                            move_item_to_grid(&amp;thing_created, you.pos(), true);</a>
<a name="ln2170">                            mitm[thing_created].quantity = 1;</a>
<a name="ln2171">                            mitm[thing_created].flags |= ISFLAG_KNOW_TYPE;</a>
<a name="ln2172">                            // not a conventional gift, but use the same</a>
<a name="ln2173">                            // messaging</a>
<a name="ln2174">                            simple_god_message(&quot; grants you a gift!&quot;);</a>
<a name="ln2175">                            you.attribute[ATTR_PAKELLAS_EXTRA_MP]</a>
<a name="ln2176">                                += POT_MAGIC_MP;</a>
<a name="ln2177">                        }</a>
<a name="ln2178">                    }</a>
<a name="ln2179">                }</a>
<a name="ln2180">#endif</a>
<a name="ln2181">            }</a>
<a name="ln2182"> </a>
<a name="ln2183">            if (gives_player_xp &amp;&amp; you_worship(GOD_RU) &amp;&amp; you.piety &lt; 200</a>
<a name="ln2184">                &amp;&amp; one_chance_in(2))</a>
<a name="ln2185">            {</a>
<a name="ln2186">                ASSERT(you.props.exists(RU_SACRIFICE_PROGRESS_KEY));</a>
<a name="ln2187">                int current_progress =</a>
<a name="ln2188">                        you.props[RU_SACRIFICE_PROGRESS_KEY].get_int();</a>
<a name="ln2189">                you.props[RU_SACRIFICE_PROGRESS_KEY] = current_progress + 1;</a>
<a name="ln2190">            }</a>
<a name="ln2191"> </a>
<a name="ln2192">            // Randomly bless a follower.</a>
<a name="ln2193">            if (gives_player_xp</a>
<a name="ln2194">                &amp;&amp; !mons_is_object(mons.type)</a>
<a name="ln2195">                &amp;&amp; _god_will_bless_follower(&amp;mons))</a>
<a name="ln2196">            {</a>
<a name="ln2197">                bless_follower();</a>
<a name="ln2198">            }</a>
<a name="ln2199">            break;</a>
<a name="ln2200">        }</a>
<a name="ln2201"> </a>
<a name="ln2202">        case KILL_MON:          // Monster kills in combat.</a>
<a name="ln2203">        case KILL_MON_MISSILE:  // Monster kills by missile or beam.</a>
<a name="ln2204">        {</a>
<a name="ln2205">            if (death_message)</a>
<a name="ln2206">            {</a>
<a name="ln2207">                const char* msg =</a>
<a name="ln2208">                    exploded                   ? &quot; is blown up!&quot; :</a>
<a name="ln2209">                    wounded_damaged(targ_holy) ? &quot; is destroyed!&quot;</a>
<a name="ln2210">                                               : &quot; dies!&quot;;</a>
<a name="ln2211">                simple_monster_message(mons, msg, MSGCH_MONSTER_DAMAGE,</a>
<a name="ln2212">                                       MDAM_DEAD);</a>
<a name="ln2213">            }</a>
<a name="ln2214"> </a>
<a name="ln2215">            if (crawl_state.game_is_arena())</a>
<a name="ln2216">                break;</a>
<a name="ln2217"> </a>
<a name="ln2218">            _fire_kill_conducts(mons, killer, killer_index, gives_player_xp);</a>
<a name="ln2219"> </a>
<a name="ln2220">            // Trying to prevent summoning abuse here, so we're trying to</a>
<a name="ln2221">            // prevent summoned creatures from being done_good kills. Only</a>
<a name="ln2222">            // affects creatures which were friendly when summoned.</a>
<a name="ln2223">            if (!gives_player_xp</a>
<a name="ln2224">                || !pet_kill</a>
<a name="ln2225">                || !anon &amp;&amp; invalid_monster_index(killer_index))</a>
<a name="ln2226">            {</a>
<a name="ln2227">                break;</a>
<a name="ln2228">            }</a>
<a name="ln2229"> </a>
<a name="ln2230">            monster* killer_mon = nullptr;</a>
<a name="ln2231">            if (!anon)</a>
<a name="ln2232">                killer_mon = &amp;menv[killer_index];</a>
<a name="ln2233"> </a>
<a name="ln2234">            if (!invalid_monster_index(killer_index)</a>
<a name="ln2235">                &amp;&amp; _god_will_bless_follower(&amp;mons))</a>
<a name="ln2236">            {</a>
<a name="ln2237">                // Randomly bless the follower who killed.</a>
<a name="ln2238">                bless_follower(killer_mon);</a>
<a name="ln2239">            }</a>
<a name="ln2240">            break;</a>
<a name="ln2241">        }</a>
<a name="ln2242"> </a>
<a name="ln2243">        // Monster killed by trap/inanimate thing/itself/poison not from you.</a>
<a name="ln2244">        case KILL_MISC:</a>
<a name="ln2245">        case KILL_MISCAST:</a>
<a name="ln2246">            if (death_message)</a>
<a name="ln2247">            {</a>
<a name="ln2248">                if (fake_abjure)</a>
<a name="ln2249">                {</a>
<a name="ln2250">                    // Sticks to Snakes</a>
<a name="ln2251">                    if (mons_genus(mons.type) == MONS_SNAKE)</a>
<a name="ln2252">                        simple_monster_message(mons, &quot; withers and dies!&quot;);</a>
<a name="ln2253">                    // ratskin cloak</a>
<a name="ln2254">                    else if (mons_genus(mons.type) == MONS_RAT)</a>
<a name="ln2255">                    {</a>
<a name="ln2256">                        simple_monster_message(mons, &quot; returns to the shadows&quot;</a>
<a name="ln2257">                                                      &quot; of the Dungeon!&quot;);</a>
<a name="ln2258">                    }</a>
<a name="ln2259">                    // Death Channel</a>
<a name="ln2260">                    else if (mons.type == MONS_SPECTRAL_THING)</a>
<a name="ln2261">                        simple_monster_message(mons, &quot; fades into mist!&quot;);</a>
<a name="ln2262">                    // Animate Skeleton/Animate Dead/Infestation</a>
<a name="ln2263">                    else if (mons.type == MONS_ZOMBIE</a>
<a name="ln2264">                             || mons.type == MONS_SKELETON</a>
<a name="ln2265">                             || mons.type == MONS_DEATH_SCARAB)</a>
<a name="ln2266">                    {</a>
<a name="ln2267">                        simple_monster_message(mons, &quot; crumbles into dust!&quot;);</a>
<a name="ln2268">                    }</a>
<a name="ln2269">                    else</a>
<a name="ln2270">                    {</a>
<a name="ln2271">                        string msg = &quot; &quot; + summoned_poof_msg(&amp;mons) + &quot;!&quot;;</a>
<a name="ln2272">                        simple_monster_message(mons, msg.c_str());</a>
<a name="ln2273">                    }</a>
<a name="ln2274">                }</a>
<a name="ln2275">                else</a>
<a name="ln2276">                {</a>
<a name="ln2277">                    const char* msg =</a>
<a name="ln2278">                        exploded                     ? &quot; is blown up!&quot; :</a>
<a name="ln2279">                        wounded_damaged(targ_holy)   ? &quot; is destroyed!&quot;</a>
<a name="ln2280">                                                     : &quot; dies!&quot;;</a>
<a name="ln2281">                    simple_monster_message(mons, msg, MSGCH_MONSTER_DAMAGE,</a>
<a name="ln2282">                                           MDAM_DEAD);</a>
<a name="ln2283">                }</a>
<a name="ln2284">            }</a>
<a name="ln2285">            break;</a>
<a name="ln2286"> </a>
<a name="ln2287">        case KILL_BANISHED:</a>
<a name="ln2288">            // Monster doesn't die, just goes back to wherever it came from.</a>
<a name="ln2289">            // This must only be called by monsters running out of time (or</a>
<a name="ln2290">            // abjuration), because it uses the beam variables!  Or does it???</a>
<a name="ln2291">            // Pacified monsters leave the level when this happens.</a>
<a name="ln2292"> </a>
<a name="ln2293">            // KILL_RESET monsters no longer lose their whole inventory, only</a>
<a name="ln2294">            // items they were generated with.</a>
<a name="ln2295">            if (mons.pacified() || !mons.needs_abyss_transit())</a>
<a name="ln2296">            {</a>
<a name="ln2297">                // A banished monster that doesn't go on the transit list</a>
<a name="ln2298">                // loses all items.</a>
<a name="ln2299">                if (!mons.is_summoned())</a>
<a name="ln2300">                    drop_items = false;</a>
<a name="ln2301">                break;</a>
<a name="ln2302">            }</a>
<a name="ln2303"> </a>
<a name="ln2304">            // Monster goes to the Abyss.</a>
<a name="ln2305">            mons.flags |= MF_BANISHED;</a>
<a name="ln2306">            {</a>
<a name="ln2307">                unwind_var&lt;int&gt; dt(mons.damage_total, 0);</a>
<a name="ln2308">                unwind_var&lt;int&gt; df(mons.damage_friendly, 0);</a>
<a name="ln2309">                mons.set_transit(level_id(BRANCH_ABYSS));</a>
<a name="ln2310">            }</a>
<a name="ln2311">            set_unique_annotation(&amp;mons, BRANCH_ABYSS);</a>
<a name="ln2312">            in_transit = true;</a>
<a name="ln2313">            drop_items = false;</a>
<a name="ln2314">            mons.firing_pos.reset();</a>
<a name="ln2315">            // Make monster stop patrolling and/or travelling.</a>
<a name="ln2316">            mons.patrol_point.reset();</a>
<a name="ln2317">            mons.travel_path.clear();</a>
<a name="ln2318">            mons.travel_target = MTRAV_NONE;</a>
<a name="ln2319">            break;</a>
<a name="ln2320"> </a>
<a name="ln2321">        case KILL_RESET:</a>
<a name="ln2322">            drop_items = false;</a>
<a name="ln2323">            break;</a>
<a name="ln2324"> </a>
<a name="ln2325">        case KILL_TIMEOUT:</a>
<a name="ln2326">        case KILL_DISMISSED:</a>
<a name="ln2327">            break;</a>
<a name="ln2328"> </a>
<a name="ln2329">        default:</a>
<a name="ln2330">            drop_items = false;</a>
<a name="ln2331">            break;</a>
<a name="ln2332">    }</a>
<a name="ln2333"> </a>
<a name="ln2334">    // Make sure Boris has a foe to address.</a>
<a name="ln2335">    if (mons.foe == MHITNOT)</a>
<a name="ln2336">    {</a>
<a name="ln2337">        if (!mons.wont_attack() &amp;&amp; !crawl_state.game_is_arena())</a>
<a name="ln2338">            mons.foe = MHITYOU;</a>
<a name="ln2339">        else if (!invalid_monster_index(killer_index))</a>
<a name="ln2340">            mons.foe = killer_index;</a>
<a name="ln2341">    }</a>
<a name="ln2342"> </a>
<a name="ln2343">    // Make sure that the monster looks dead.</a>
<a name="ln2344">    if (mons.alive() &amp;&amp; (!summoned || duration &gt; 0))</a>
<a name="ln2345">    {</a>
<a name="ln2346">        dprf(&quot;Granting xp for non-damage kill.&quot;);</a>
<a name="ln2347">        if (YOU_KILL(killer))</a>
<a name="ln2348">            mons.damage_friendly += mons.hit_points * 2;</a>
<a name="ln2349">        else if (pet_kill)</a>
<a name="ln2350">            mons.damage_friendly += mons.hit_points;</a>
<a name="ln2351">        mons.damage_total += mons.hit_points;</a>
<a name="ln2352"> </a>
<a name="ln2353">        if (!in_transit) // banishment only</a>
<a name="ln2354">            mons.hit_points = -1;</a>
<a name="ln2355">    }</a>
<a name="ln2356"> </a>
<a name="ln2357">    if (!silent &amp;&amp; !wizard &amp;&amp; you.see_cell(mons.pos()))</a>
<a name="ln2358">    {</a>
<a name="ln2359">        // Make sure that the monster looks dead.</a>
<a name="ln2360">        if (mons.alive() &amp;&amp; !in_transit &amp;&amp; (!summoned || duration &gt; 0))</a>
<a name="ln2361">            mons.hit_points = -1;</a>
<a name="ln2362">        // Hack: with cleanup_dead=false, a tentacle [segment] of a dead</a>
<a name="ln2363">        // [malign] kraken has no valid head reference.</a>
<a name="ln2364">        if (!mons_is_tentacle_or_tentacle_segment(mons.type))</a>
<a name="ln2365">        {</a>
<a name="ln2366">            // Make sure Natasha gets her say even if she got polymorphed.</a>
<a name="ln2367">            const monster_type orig =</a>
<a name="ln2368">                mons_is_mons_class(&amp;mons, MONS_NATASHA) ? MONS_NATASHA</a>
<a name="ln2369">                                                       : mons.type;</a>
<a name="ln2370">            unwind_var&lt;monster_type&gt; mt(mons.type, orig);</a>
<a name="ln2371">            mons_speaks(&amp;mons);</a>
<a name="ln2372">        }</a>
<a name="ln2373">    }</a>
<a name="ln2374"> </a>
<a name="ln2375">    // None of these effects should trigger on illusory copies.</a>
<a name="ln2376">    if (!mons.is_illusion())</a>
<a name="ln2377">    {</a>
<a name="ln2378">        if (mons.type == MONS_BORIS &amp;&amp; !in_transit &amp;&amp; !mons.pacified())</a>
<a name="ln2379">        {</a>
<a name="ln2380">            // XXX: Actual blood curse effect for Boris? - bwr</a>
<a name="ln2381"> </a>
<a name="ln2382">            // Now that Boris is dead, he can be replaced when new levels</a>
<a name="ln2383">            // are generated.</a>
<a name="ln2384">            you.unique_creatures.set(mons.type, false);</a>
<a name="ln2385">            you.props[&quot;killed_boris_once&quot;] = true;</a>
<a name="ln2386">        }</a>
<a name="ln2387">        if (mons.type == MONS_JORY &amp;&amp; !in_transit)</a>
<a name="ln2388">            blood_spray(mons.pos(), MONS_JORY, 50);</a>
<a name="ln2389">        else if (mons_is_mons_class(&amp;mons, MONS_KIRKE)</a>
<a name="ln2390">                 &amp;&amp; !in_transit</a>
<a name="ln2391">                 &amp;&amp; !testbits(mons.flags, MF_WAS_NEUTRAL))</a>
<a name="ln2392">        {</a>
<a name="ln2393">            hogs_to_humans();</a>
<a name="ln2394">        }</a>
<a name="ln2395">        else if ((mons_is_mons_class(&amp;mons, MONS_NATASHA)</a>
<a name="ln2396">                  || mons_genus(mons.type) == MONS_FELID)</a>
<a name="ln2397">                 &amp;&amp; !in_transit &amp;&amp; !mons.pacified()</a>
<a name="ln2398">                 &amp;&amp; mons_felid_can_revive(&amp;mons))</a>
<a name="ln2399">        {</a>
<a name="ln2400">            drop_items = false;</a>
<a name="ln2401"> </a>
<a name="ln2402">            // Like Boris, but regenerates immediately</a>
<a name="ln2403">            if (mons_is_mons_class(&amp;mons, MONS_NATASHA))</a>
<a name="ln2404">                you.unique_creatures.set(MONS_NATASHA, false);</a>
<a name="ln2405">            if (!mons_reset &amp;&amp; !wizard)</a>
<a name="ln2406">                mons_felid_revive(&amp;mons);</a>
<a name="ln2407">        }</a>
<a name="ln2408">        else if (mons_is_mons_class(&amp;mons, MONS_PIKEL))</a>
<a name="ln2409">        {</a>
<a name="ln2410">            // His slaves don't care if he's dead or not, just whether or not</a>
<a name="ln2411">            // he goes away.</a>
<a name="ln2412">            pikel_band_neutralise();</a>
<a name="ln2413">        }</a>
<a name="ln2414">        else if (mons_is_elven_twin(&amp;mons))</a>
<a name="ln2415">            elven_twin_died(&amp;mons, in_transit, killer, killer_index);</a>
<a name="ln2416">        else if (mons.type == MONS_BENNU &amp;&amp; !in_transit &amp;&amp; !was_banished</a>
<a name="ln2417">                 &amp;&amp; !mons_reset &amp;&amp; !mons.pacified()</a>
<a name="ln2418">                 &amp;&amp; (!summoned || duration &gt; 0) &amp;&amp; !wizard</a>
<a name="ln2419">                 &amp;&amp; mons_bennu_can_revive(&amp;mons))</a>
<a name="ln2420">        {</a>
<a name="ln2421">            // All this information may be lost by the time the monster revives.</a>
<a name="ln2422">            const int revives = (mons.props.exists(&quot;bennu_revives&quot;))</a>
<a name="ln2423">                              ? mons.props[&quot;bennu_revives&quot;].get_byte() : 0;</a>
<a name="ln2424">            const beh_type att = mons.has_ench(ENCH_CHARM)</a>
<a name="ln2425">                                     ? BEH_HOSTILE : SAME_ATTITUDE(&amp;mons);</a>
<a name="ln2426"> </a>
<a name="ln2427">            bennu_revive_fineff::schedule(mons.pos(), revives, att, mons.foe);</a>
<a name="ln2428">        }</a>
<a name="ln2429">    }</a>
<a name="ln2430"> </a>
<a name="ln2431">    if (mons_is_tentacle_head(mons_base_type(mons)))</a>
<a name="ln2432">    {</a>
<a name="ln2433">        if (destroy_tentacles(&amp;mons)</a>
<a name="ln2434">            &amp;&amp; !in_transit</a>
<a name="ln2435">            &amp;&amp; you.see_cell(mons.pos())</a>
<a name="ln2436">            &amp;&amp; !was_banished)</a>
<a name="ln2437">        {</a>
<a name="ln2438">            if (mons_base_type(mons) == MONS_KRAKEN)</a>
<a name="ln2439">                mpr(&quot;The dead kraken's tentacles slide back into the water.&quot;);</a>
<a name="ln2440">            else if (mons.type == MONS_TENTACLED_STARSPAWN)</a>
<a name="ln2441">                mpr(&quot;The starspawn's tentacles wither and die.&quot;);</a>
<a name="ln2442">        }</a>
<a name="ln2443">    }</a>
<a name="ln2444">    else if (mons_is_tentacle_or_tentacle_segment(mons.type)</a>
<a name="ln2445">             &amp;&amp; killer != KILL_MISC</a>
<a name="ln2446">                 || mons.type == MONS_ELDRITCH_TENTACLE</a>
<a name="ln2447">                 || mons.type == MONS_SNAPLASHER_VINE)</a>
<a name="ln2448">    {</a>
<a name="ln2449">        if (mons.type == MONS_SNAPLASHER_VINE)</a>
<a name="ln2450">        {</a>
<a name="ln2451">            if (mons.props.exists(&quot;vine_awakener&quot;))</a>
<a name="ln2452">            {</a>
<a name="ln2453">                monster* awakener =</a>
<a name="ln2454">                        monster_by_mid(mons.props[&quot;vine_awakener&quot;].get_int());</a>
<a name="ln2455">                if (awakener)</a>
<a name="ln2456">                    awakener-&gt;props[&quot;vines_awakened&quot;].get_int()--;</a>
<a name="ln2457">            }</a>
<a name="ln2458">        }</a>
<a name="ln2459">        destroy_tentacle(&amp;mons);</a>
<a name="ln2460">    }</a>
<a name="ln2461">    else if (mons.type == MONS_ELDRITCH_TENTACLE_SEGMENT</a>
<a name="ln2462">             &amp;&amp; killer != KILL_MISC)</a>
<a name="ln2463">    {</a>
<a name="ln2464">       monster_die(*monster_by_mid(mons.tentacle_connect), killer,</a>
<a name="ln2465">                   killer_index, silent, wizard, fake);</a>
<a name="ln2466">    }</a>
<a name="ln2467">    else if (mons.type == MONS_FLAYED_GHOST)</a>
<a name="ln2468">        end_flayed_effect(&amp;mons);</a>
<a name="ln2469">    // Give the treant a last chance to release its hornets if it is killed in a</a>
<a name="ln2470">    // single blow from above half health</a>
<a name="ln2471">    else if (mons.type == MONS_SHAMBLING_MANGROVE &amp;&amp; !was_banished</a>
<a name="ln2472">             &amp;&amp; !mons.pacified() &amp;&amp; (!summoned || duration &gt; 0) &amp;&amp; !wizard</a>
<a name="ln2473">             &amp;&amp; !mons_reset)</a>
<a name="ln2474">    {</a>
<a name="ln2475">        treant_release_fauna(mons);</a>
<a name="ln2476">    }</a>
<a name="ln2477">    else if (!mons.is_summoned() &amp;&amp; mummy_curse_power(mons.type) &gt; 0)</a>
<a name="ln2478">    {</a>
<a name="ln2479">        // TODO: set attacker better? (Player attacker is handled by checking</a>
<a name="ln2480">        // killer when running the fineff.)</a>
<a name="ln2481">        mummy_death_curse_fineff::schedule(</a>
<a name="ln2482">                invalid_monster_index(killer_index)</a>
<a name="ln2483">                                            ? nullptr : &amp;menv[killer_index],</a>
<a name="ln2484">                mons.name(DESC_A),</a>
<a name="ln2485">                killer,</a>
<a name="ln2486">                mummy_curse_power(mons.type));</a>
<a name="ln2487">    }</a>
<a name="ln2488"> </a>
<a name="ln2489">    // Necromancy</a>
<a name="ln2490">    if (!was_banished &amp;&amp; !mons_reset)</a>
<a name="ln2491">    {</a>
<a name="ln2492">        if (mons.has_ench(ENCH_INFESTATION))</a>
<a name="ln2493">            _infestation_create_scarab(&amp;mons);</a>
<a name="ln2494">        if (you.duration[DUR_DEATH_CHANNEL] &amp;&amp; was_visible &amp;&amp; gives_player_xp)</a>
<a name="ln2495">            _make_derived_undead(&amp;mons, !death_message, false);</a>
<a name="ln2496">    }</a>
<a name="ln2497"> </a>
<a name="ln2498">    if (!wizard &amp;&amp; !submerged &amp;&amp; !was_banished)</a>
<a name="ln2499">    {</a>
<a name="ln2500">        _monster_die_cloud(&amp;mons, !fake_abjure &amp;&amp; !timeout &amp;&amp; !mons_reset,</a>
<a name="ln2501">                           silent, summoned);</a>
<a name="ln2502">    }</a>
<a name="ln2503"> </a>
<a name="ln2504">    item_def* corpse = nullptr;</a>
<a name="ln2505">    if (leaves_corpse &amp;&amp; !was_banished &amp;&amp; !spectralised)</a>
<a name="ln2506">    {</a>
<a name="ln2507">        // Have to add case for disintegration effect here? {dlb}</a>
<a name="ln2508">        item_def* daddy_corpse = nullptr;</a>
<a name="ln2509"> </a>
<a name="ln2510">        if (mons.type == MONS_SPRIGGAN_RIDER)</a>
<a name="ln2511">        {</a>
<a name="ln2512">            daddy_corpse = mounted_kill(&amp;mons, MONS_HORNET, killer, killer_index);</a>
<a name="ln2513">            mons.type = MONS_SPRIGGAN;</a>
<a name="ln2514">        }</a>
<a name="ln2515">        corpse = place_monster_corpse(mons, silent);</a>
<a name="ln2516">        if (!corpse)</a>
<a name="ln2517">            corpse = daddy_corpse;</a>
<a name="ln2518">    }</a>
<a name="ln2519">    if (corpse &amp;&amp; mons.has_ench(ENCH_BOUND_SOUL))</a>
<a name="ln2520">        _make_derived_undead(&amp;mons, !death_message, true);</a>
<a name="ln2521"> </a>
<a name="ln2522">    const unsigned int player_xp = gives_player_xp</a>
<a name="ln2523">        ? _calc_player_experience(&amp;mons) : 0;</a>
<a name="ln2524">    const unsigned int monster_xp = _calc_monster_experience(&amp;mons, killer,</a>
<a name="ln2525">                                                             killer_index);</a>
<a name="ln2526"> </a>
<a name="ln2527">    // Player Powered by Death</a>
<a name="ln2528">    if (gives_player_xp &amp;&amp; you.get_mutation_level(MUT_POWERED_BY_DEATH)</a>
<a name="ln2529">        &amp;&amp; (killer == KILL_YOU</a>
<a name="ln2530">            || killer == KILL_YOU_MISSILE</a>
<a name="ln2531">            || killer == KILL_YOU_CONF</a>
<a name="ln2532">            || pet_kill))</a>
<a name="ln2533">    {</a>
<a name="ln2534">        // Enable the status</a>
<a name="ln2535">        reset_powered_by_death_duration();</a>
<a name="ln2536"> </a>
<a name="ln2537">        // Maybe increase strength. The chance decreases with number</a>
<a name="ln2538">        // of existing stacks.</a>
<a name="ln2539">        const int pbd_level = you.get_mutation_level(MUT_POWERED_BY_DEATH);</a>
<a name="ln2540">        const int pbd_str = you.props[POWERED_BY_DEATH_KEY].get_int();</a>
<a name="ln2541">        if (x_chance_in_y(10 - pbd_str, 10))</a>
<a name="ln2542">        {</a>
<a name="ln2543">            const int pbd_inc = random2(1 + pbd_level);</a>
<a name="ln2544">            you.props[POWERED_BY_DEATH_KEY] = pbd_str + pbd_inc;</a>
<a name="ln2545">            dprf(&quot;Powered by Death strength +%d=%d&quot;, pbd_inc,</a>
<a name="ln2546">                 pbd_str + pbd_inc);</a>
<a name="ln2547">        }</a>
<a name="ln2548">    }</a>
<a name="ln2549"> </a>
<a name="ln2550">    if (!crawl_state.game_is_arena() &amp;&amp; leaves_corpse &amp;&amp; !in_transit)</a>
<a name="ln2551">        you.kills.record_kill(&amp;mons, killer, pet_kill);</a>
<a name="ln2552"> </a>
<a name="ln2553">    if (fake)</a>
<a name="ln2554">    {</a>
<a name="ln2555">        if (corpse &amp;&amp; _reaping(mons))</a>
<a name="ln2556">            corpse = nullptr;</a>
<a name="ln2557">        _give_experience(player_xp, monster_xp, killer, killer_index,</a>
<a name="ln2558">                         pet_kill, was_visible, mons.xp_tracking);</a>
<a name="ln2559">        crawl_state.dec_mon_acting(&amp;mons);</a>
<a name="ln2560"> </a>
<a name="ln2561">        return corpse;</a>
<a name="ln2562">    }</a>
<a name="ln2563"> </a>
<a name="ln2564">    mons_remove_from_grid(mons);</a>
<a name="ln2565">    fire_monster_death_event(&amp;mons, killer, false);</a>
<a name="ln2566"> </a>
<a name="ln2567">    if (crawl_state.game_is_arena())</a>
<a name="ln2568">        arena_monster_died(&amp;mons, killer, killer_index, silent, corpse);</a>
<a name="ln2569"> </a>
<a name="ln2570">    const coord_def mwhere = mons.pos();</a>
<a name="ln2571">    if (drop_items)</a>
<a name="ln2572">    {</a>
<a name="ln2573">        // monster_drop_things may lead to a level excursion (via</a>
<a name="ln2574">        // god_id_item -&gt; ... -&gt; ShoppingList::item_type_identified),</a>
<a name="ln2575">        // which fails to save/restore the dead monster. Keep it alive</a>
<a name="ln2576">        // since we still need it.</a>
<a name="ln2577">        unwind_var&lt;int&gt; fakehp(mons.hit_points, 1);</a>
<a name="ln2578">        monster_drop_things(&amp;mons, YOU_KILL(killer) || pet_kill);</a>
<a name="ln2579">    }</a>
<a name="ln2580">    else</a>
<a name="ln2581">    {</a>
<a name="ln2582">        // Destroy the items belonging to MF_HARD_RESET monsters so they</a>
<a name="ln2583">        // don't clutter up mitm[].</a>
<a name="ln2584">        mons.destroy_inventory();</a>
<a name="ln2585">    }</a>
<a name="ln2586"> </a>
<a name="ln2587">    if (leaves_corpse &amp;&amp; corpse)</a>
<a name="ln2588">    {</a>
<a name="ln2589">        if (!silent &amp;&amp; !wizard)</a>
<a name="ln2590">            _special_corpse_messaging(mons);</a>
<a name="ln2591">        // message ordering... :(</a>
<a name="ln2592">        if (corpse-&gt;base_type == OBJ_CORPSES) // not gold</a>
<a name="ln2593">            _maybe_drop_monster_hide(*corpse, silent);</a>
<a name="ln2594">    }</a>
<a name="ln2595"> </a>
<a name="ln2596">    if (mons.is_divine_companion()</a>
<a name="ln2597">        &amp;&amp; killer != KILL_RESET</a>
<a name="ln2598">        &amp;&amp; !(mons.flags &amp; MF_BANISHED))</a>
<a name="ln2599">    {</a>
<a name="ln2600">        remove_companion(&amp;mons);</a>
<a name="ln2601">        if (mons_is_hepliaklqana_ancestor(mons.type))</a>
<a name="ln2602">        {</a>
<a name="ln2603">            ASSERT(hepliaklqana_ancestor() == MID_NOBODY);</a>
<a name="ln2604">            if (!you.can_see(mons))</a>
<a name="ln2605">            {</a>
<a name="ln2606">                mprf(&quot;%s has departed this plane of existence.&quot;,</a>
<a name="ln2607">                     hepliaklqana_ally_name().c_str());</a>
<a name="ln2608">            }</a>
<a name="ln2609">            // respawn in ~30-60 turns</a>
<a name="ln2610">            you.duration[DUR_ANCESTOR_DELAY] = random_range(300, 600);</a>
<a name="ln2611">        }</a>
<a name="ln2612">    }</a>
<a name="ln2613"> </a>
<a name="ln2614">    // If we kill an invisible monster reactivate autopickup.</a>
<a name="ln2615">    // We need to check for actual invisibility rather than whether we</a>
<a name="ln2616">    // can see the monster. There are several edge cases where a monster</a>
<a name="ln2617">    // is visible to the player but we still need to turn autopickup</a>
<a name="ln2618">    // back on, such as TSO's halo or sticky flame. (jpeg)</a>
<a name="ln2619">    if (you.see_cell(mons.pos()) &amp;&amp; mons.has_ench(ENCH_INVIS)</a>
<a name="ln2620">        &amp;&amp; !mons.friendly())</a>
<a name="ln2621">    {</a>
<a name="ln2622">        autotoggle_autopickup(false);</a>
<a name="ln2623">    }</a>
<a name="ln2624"> </a>
<a name="ln2625">    if (corpse &amp;&amp; _reaping(mons))</a>
<a name="ln2626">        corpse = nullptr;</a>
<a name="ln2627"> </a>
<a name="ln2628">    crawl_state.dec_mon_acting(&amp;mons);</a>
<a name="ln2629">    monster_cleanup(&amp;mons);</a>
<a name="ln2630"> </a>
<a name="ln2631">    // Force redraw for monsters that die.</a>
<a name="ln2632">    if (in_bounds(mwhere) &amp;&amp; you.see_cell(mwhere))</a>
<a name="ln2633">    {</a>
<a name="ln2634">        view_update_at(mwhere);</a>
<a name="ln2635">        update_screen();</a>
<a name="ln2636">    }</a>
<a name="ln2637"> </a>
<a name="ln2638">    if (!mons_reset)</a>
<a name="ln2639">    {</a>
<a name="ln2640">        _give_experience(player_xp, monster_xp, killer, killer_index,</a>
<a name="ln2641">                pet_kill, was_visible, mons.xp_tracking);</a>
<a name="ln2642">    }</a>
<a name="ln2643">    return corpse;</a>
<a name="ln2644">}</a>
<a name="ln2645"> </a>
<a name="ln2646">void unawaken_vines(const monster* mons, bool quiet)</a>
<a name="ln2647">{</a>
<a name="ln2648">    int vines_seen = 0;</a>
<a name="ln2649">    for (monster_iterator mi; mi; ++mi)</a>
<a name="ln2650">    {</a>
<a name="ln2651">        if (mi-&gt;type == MONS_SNAPLASHER_VINE</a>
<a name="ln2652">            &amp;&amp; mi-&gt;props.exists(&quot;vine_awakener&quot;)</a>
<a name="ln2653">            &amp;&amp; monster_by_mid(mi-&gt;props[&quot;vine_awakener&quot;].get_int()) == mons)</a>
<a name="ln2654">        {</a>
<a name="ln2655">            if (you.can_see(**mi))</a>
<a name="ln2656">                ++vines_seen;</a>
<a name="ln2657">            monster_die(**mi, KILL_RESET, NON_MONSTER);</a>
<a name="ln2658">        }</a>
<a name="ln2659">    }</a>
<a name="ln2660"> </a>
<a name="ln2661">    if (!quiet &amp;&amp; vines_seen)</a>
<a name="ln2662">    {</a>
<a name="ln2663">        mprf(&quot;The vine%s fall%s limply to the ground.&quot;,</a>
<a name="ln2664">              (vines_seen &gt; 1 ? &quot;s&quot; : &quot;&quot;), (vines_seen == 1 ? &quot;s&quot; : &quot;&quot;));</a>
<a name="ln2665">    }</a>
<a name="ln2666">}</a>
<a name="ln2667"> </a>
<a name="ln2668">void heal_flayed_effect(actor* act, bool quiet, bool blood_only)</a>
<a name="ln2669">{</a>
<a name="ln2670">    ASSERT(act); // XXX: change to actor &amp;act</a>
<a name="ln2671">    if (!blood_only)</a>
<a name="ln2672">    {</a>
<a name="ln2673">        if (act-&gt;is_player())</a>
<a name="ln2674">            you.duration[DUR_FLAYED] = 0;</a>
<a name="ln2675">        else</a>
<a name="ln2676">            act-&gt;as_monster()-&gt;del_ench(ENCH_FLAYED, true, false);</a>
<a name="ln2677"> </a>
<a name="ln2678">        if (you.can_see(*act) &amp;&amp; !quiet)</a>
<a name="ln2679">        {</a>
<a name="ln2680">            mprf(&quot;The terrible wounds on %s body vanish.&quot;,</a>
<a name="ln2681">                 act-&gt;name(DESC_ITS).c_str());</a>
<a name="ln2682">        }</a>
<a name="ln2683"> </a>
<a name="ln2684">        act-&gt;heal(act-&gt;props[&quot;flay_damage&quot;].get_int());</a>
<a name="ln2685">        act-&gt;props.erase(&quot;flay_damage&quot;);</a>
<a name="ln2686">    }</a>
<a name="ln2687"> </a>
<a name="ln2688">    for (const CrawlStoreValue&amp; store : act-&gt;props[&quot;flay_blood&quot;].get_vector())</a>
<a name="ln2689">        env.pgrid(store.get_coord()) &amp;= ~FPROP_BLOODY;</a>
<a name="ln2690">    act-&gt;props.erase(&quot;flay_blood&quot;);</a>
<a name="ln2691">}</a>
<a name="ln2692"> </a>
<a name="ln2693">void end_flayed_effect(monster* ghost)</a>
<a name="ln2694">{</a>
<a name="ln2695">    if (you.duration[DUR_FLAYED] &amp;&amp; !ghost-&gt;wont_attack())</a>
<a name="ln2696">        heal_flayed_effect(&amp;you);</a>
<a name="ln2697"> </a>
<a name="ln2698">    for (monster_iterator mi; mi; ++mi)</a>
<a name="ln2699">    {</a>
<a name="ln2700">        if (mi-&gt;has_ench(ENCH_FLAYED) &amp;&amp; !mons_aligned(ghost, *mi))</a>
<a name="ln2701">            heal_flayed_effect(*mi);</a>
<a name="ln2702">    }</a>
<a name="ln2703">}</a>
<a name="ln2704"> </a>
<a name="ln2705">// Clean up after a dead monster.</a>
<a name="ln2706">void monster_cleanup(monster* mons)</a>
<a name="ln2707">{</a>
<a name="ln2708">    crawl_state.mon_gone(mons);</a>
<a name="ln2709"> </a>
<a name="ln2710">    if (mons-&gt;has_ench(ENCH_AWAKEN_FOREST))</a>
<a name="ln2711">    {</a>
<a name="ln2712">        forest_message(mons-&gt;pos(), &quot;The forest abruptly stops moving.&quot;);</a>
<a name="ln2713">        env.forest_awoken_until = 0;</a>
<a name="ln2714">    }</a>
<a name="ln2715"> </a>
<a name="ln2716">    if (mons-&gt;has_ench(ENCH_AWAKEN_VINES))</a>
<a name="ln2717">        unawaken_vines(mons, false);</a>
<a name="ln2718"> </a>
<a name="ln2719">    // Monsters haloes should be removed when they die.</a>
<a name="ln2720">    if (mons-&gt;halo_radius()</a>
<a name="ln2721">        || mons-&gt;umbra_radius()</a>
<a name="ln2722">        || mons-&gt;silence_radius())</a>
<a name="ln2723">    {</a>
<a name="ln2724">        invalidate_agrid();</a>
<a name="ln2725">    }</a>
<a name="ln2726"> </a>
<a name="ln2727">    // May have been constricting something. No message because that depends</a>
<a name="ln2728">    // on the order in which things are cleaned up: If the constrictee is</a>
<a name="ln2729">    // cleaned up first, we wouldn't get a message anyway.</a>
<a name="ln2730">    mons-&gt;stop_constricting_all(false, true);</a>
<a name="ln2731"> </a>
<a name="ln2732">    mons-&gt;clear_far_engulf();</a>
<a name="ln2733"> </a>
<a name="ln2734">    if (mons_is_tentacle_head(mons_base_type(*mons)))</a>
<a name="ln2735">        destroy_tentacles(mons);</a>
<a name="ln2736"> </a>
<a name="ln2737">    const mid_t mid = mons-&gt;mid;</a>
<a name="ln2738">    env.mid_cache.erase(mid);</a>
<a name="ln2739"> </a>
<a name="ln2740">    mons-&gt;remove_summons();</a>
<a name="ln2741"> </a>
<a name="ln2742">    unsigned int monster_killed = mons-&gt;mindex();</a>
<a name="ln2743">    for (monster_iterator mi; mi; ++mi)</a>
<a name="ln2744">    {</a>
<a name="ln2745">        if (mi-&gt;foe == monster_killed)</a>
<a name="ln2746">            mi-&gt;foe = MHITNOT;</a>
<a name="ln2747">    }</a>
<a name="ln2748"> </a>
<a name="ln2749">    if (you.pet_target == monster_killed)</a>
<a name="ln2750">        you.pet_target = MHITNOT;</a>
<a name="ln2751"> </a>
<a name="ln2752">    mons-&gt;reset();</a>
<a name="ln2753">}</a>
<a name="ln2754"> </a>
<a name="ln2755">item_def* mounted_kill(monster* daddy, monster_type mc, killer_type killer,</a>
<a name="ln2756">                       int killer_index)</a>
<a name="ln2757">{</a>
<a name="ln2758">    monster mon;</a>
<a name="ln2759">    mon.type = mc;</a>
<a name="ln2760">    mon.moveto(daddy-&gt;pos());</a>
<a name="ln2761">    define_monster(mon); // assumes mc is not a zombie</a>
<a name="ln2762">    mon.flags = daddy-&gt;flags;</a>
<a name="ln2763"> </a>
<a name="ln2764">    // Need to copy ENCH_ABJ etc. or we could get real XP/meat from a summon.</a>
<a name="ln2765">    mon.enchantments = daddy-&gt;enchantments;</a>
<a name="ln2766">    mon.ench_cache = daddy-&gt;ench_cache;</a>
<a name="ln2767"> </a>
<a name="ln2768">    mon.attitude = daddy-&gt;attitude;</a>
<a name="ln2769">    mon.damage_friendly = daddy-&gt;damage_friendly;</a>
<a name="ln2770">    mon.damage_total = daddy-&gt;damage_total;</a>
<a name="ln2771">    // Keep the rider's name, if it had one (Mercenary card).</a>
<a name="ln2772">    if (!daddy-&gt;mname.empty() &amp;&amp; mon.type == MONS_SPRIGGAN)</a>
<a name="ln2773">        mon.mname = daddy-&gt;mname;</a>
<a name="ln2774">    if (daddy-&gt;props.exists(&quot;reaping_damage&quot;))</a>
<a name="ln2775">    {</a>
<a name="ln2776">        dprf(&quot;Mounted kill: marking the other monster as reaped as well.&quot;);</a>
<a name="ln2777">        mon.props[&quot;reaping_damage&quot;].get_int() = daddy-&gt;props[&quot;reaping_damage&quot;].get_int();</a>
<a name="ln2778">        mon.props[&quot;reaper&quot;].get_int() = daddy-&gt;props[&quot;reaper&quot;].get_int();</a>
<a name="ln2779">    }</a>
<a name="ln2780"> </a>
<a name="ln2781">    return monster_die(mon, killer, killer_index, false, false, true);</a>
<a name="ln2782">}</a>
<a name="ln2783"> </a>
<a name="ln2784">/**</a>
<a name="ln2785"> * Applies harmful environmental effects from the current tile to monsters.</a>
<a name="ln2786"> *</a>
<a name="ln2787"> * @param mons      The monster to maybe drown/incinerate.</a>
<a name="ln2788"> * @param oldpos    Their previous tile, before landing up here.</a>
<a name="ln2789"> * @param killer    Who's responsible for killing them, if they die here.</a>
<a name="ln2790"> * @param killnum   The mindex of the killer, if any.</a>
<a name="ln2791"> */</a>
<a name="ln2792">void mons_check_pool(monster* mons, const coord_def &amp;oldpos,</a>
<a name="ln2793">                     killer_type killer, int killnum)</a>
<a name="ln2794">{</a>
<a name="ln2795">    // Flying monsters don't make contact with the terrain.</a>
<a name="ln2796">    if (!mons-&gt;ground_level())</a>
<a name="ln2797">        return;</a>
<a name="ln2798"> </a>
<a name="ln2799">    dungeon_feature_type grid = grd(mons-&gt;pos());</a>
<a name="ln2800">    if (grid != DNGN_LAVA &amp;&amp; grid != DNGN_DEEP_WATER</a>
<a name="ln2801">        || monster_habitable_grid(mons, grid))</a>
<a name="ln2802">    {</a>
<a name="ln2803">        return;</a>
<a name="ln2804">    }</a>
<a name="ln2805"> </a>
<a name="ln2806"> </a>
<a name="ln2807">    // Don't worry about invisibility. You should be able to see if</a>
<a name="ln2808">    // something has fallen into the lava.</a>
<a name="ln2809">    if (you.see_cell(mons-&gt;pos()) &amp;&amp; (oldpos == mons-&gt;pos() || grd(oldpos) != grid))</a>
<a name="ln2810">    {</a>
<a name="ln2811">         mprf(&quot;%s falls into the %s!&quot;,</a>
<a name="ln2812">             mons-&gt;name(DESC_THE).c_str(),</a>
<a name="ln2813">             grid == DNGN_LAVA ? &quot;lava&quot; : &quot;water&quot;);</a>
<a name="ln2814">    }</a>
<a name="ln2815"> </a>
<a name="ln2816">    // Even fire resistant monsters perish in lava.</a>
<a name="ln2817">    if (grid == DNGN_LAVA &amp;&amp; mons-&gt;res_fire() &lt; 2)</a>
<a name="ln2818">    {</a>
<a name="ln2819">        simple_monster_message(*mons, &quot; is incinerated.&quot;,</a>
<a name="ln2820">                               MSGCH_MONSTER_DAMAGE, MDAM_DEAD);</a>
<a name="ln2821">    }</a>
<a name="ln2822">    else if (mons-&gt;can_drown())</a>
<a name="ln2823">    {</a>
<a name="ln2824">        simple_monster_message(*mons, &quot; drowns.&quot;,</a>
<a name="ln2825">                               MSGCH_MONSTER_DAMAGE, MDAM_DEAD);</a>
<a name="ln2826">    }</a>
<a name="ln2827">    else</a>
<a name="ln2828">    {</a>
<a name="ln2829">        simple_monster_message(*mons, &quot; falls apart.&quot;,</a>
<a name="ln2830">                               MSGCH_MONSTER_DAMAGE, MDAM_DEAD);</a>
<a name="ln2831">    }</a>
<a name="ln2832"> </a>
<a name="ln2833">    if (killer == KILL_NONE)</a>
<a name="ln2834">    {</a>
<a name="ln2835">        // Self-kill.</a>
<a name="ln2836">        killer  = KILL_MON;</a>
<a name="ln2837">        killnum = mons-&gt;mindex();</a>
<a name="ln2838">    }</a>
<a name="ln2839"> </a>
<a name="ln2840">    // Yredelemnul special, redux: It's the only one that can</a>
<a name="ln2841">    // work on drowned monsters.</a>
<a name="ln2842">    if (!_yred_enslave_soul(mons, killer))</a>
<a name="ln2843">        monster_die(*mons, killer, killnum, true);</a>
<a name="ln2844">}</a>
<a name="ln2845"> </a>
<a name="ln2846">// Make all of the monster's original equipment disappear, unless it's a fixed</a>
<a name="ln2847">// artefact or unrand artefact.</a>
<a name="ln2848">static void _vanish_orig_eq(monster* mons)</a>
<a name="ln2849">{</a>
<a name="ln2850">    for (mon_inv_iterator ii(*mons); ii; ++ii)</a>
<a name="ln2851">    {</a>
<a name="ln2852">        if (origin_known(*ii) || ii-&gt;orig_monnum != 0</a>
<a name="ln2853">            || !ii-&gt;inscription.empty()</a>
<a name="ln2854">            || is_unrandom_artefact(*ii)</a>
<a name="ln2855">            || (ii-&gt;flags &amp; (ISFLAG_DROPPED | ISFLAG_THROWN</a>
<a name="ln2856">                              | ISFLAG_NOTED_GET)))</a>
<a name="ln2857">        {</a>
<a name="ln2858">            continue;</a>
<a name="ln2859">        }</a>
<a name="ln2860">        ii-&gt;flags |= ISFLAG_SUMMONED;</a>
<a name="ln2861">    }</a>
<a name="ln2862">}</a>
<a name="ln2863"> </a>
<a name="ln2864">int dismiss_monsters(string pattern)</a>
<a name="ln2865">{</a>
<a name="ln2866">    // Make all of the monsters' original equipment disappear unless &quot;keepitem&quot;</a>
<a name="ln2867">    // is found in the regex (except for fixed arts and unrand arts).</a>
<a name="ln2868">    const bool keep_item = strip_tag(pattern, &quot;keepitem&quot;);</a>
<a name="ln2869">    const bool harmful = pattern == &quot;harmful&quot;;</a>
<a name="ln2870">    const bool mobile  = pattern == &quot;mobile&quot;;</a>
<a name="ln2871">    const bool los     = pattern == &quot;los&quot;;</a>
<a name="ln2872"> </a>
<a name="ln2873">    // Dismiss by regex.</a>
<a name="ln2874">    text_pattern tpat(pattern);</a>
<a name="ln2875">    int ndismissed = 0;</a>
<a name="ln2876">    for (monster_iterator mi; mi; ++mi)</a>
<a name="ln2877">    {</a>
<a name="ln2878">        if (mi-&gt;alive()</a>
<a name="ln2879">            &amp;&amp; (mobile ? !mons_class_is_stationary(mi-&gt;type) :</a>
<a name="ln2880">                harmful ? mons_is_threatening(**mi) &amp;&amp; !mi-&gt;wont_attack() :</a>
<a name="ln2881">                los ? you.see_cell(mi-&gt;pos())</a>
<a name="ln2882">                : tpat.empty() || tpat.matches(mi-&gt;name(DESC_PLAIN, true))))</a>
<a name="ln2883">        {</a>
<a name="ln2884">            if (!keep_item)</a>
<a name="ln2885">                _vanish_orig_eq(*mi);</a>
<a name="ln2886">            monster_die(**mi, KILL_DISMISSED, NON_MONSTER, false, true);</a>
<a name="ln2887">            ++ndismissed;</a>
<a name="ln2888">        }</a>
<a name="ln2889">    }</a>
<a name="ln2890"> </a>
<a name="ln2891">    return ndismissed;</a>
<a name="ln2892">}</a>
<a name="ln2893"> </a>
<a name="ln2894">string summoned_poof_msg(const monster* mons, bool plural)</a>
<a name="ln2895">{</a>
<a name="ln2896">    int  summon_type = 0;</a>
<a name="ln2897">    bool valid_mon   = false;</a>
<a name="ln2898">    if (mons != nullptr &amp;&amp; !invalid_monster(mons))</a>
<a name="ln2899">    {</a>
<a name="ln2900">        (void) mons-&gt;is_summoned(nullptr, &amp;summon_type);</a>
<a name="ln2901">        valid_mon = true;</a>
<a name="ln2902">    }</a>
<a name="ln2903"> </a>
<a name="ln2904">    string msg      = &quot;disappear%s in a puff of smoke&quot;;</a>
<a name="ln2905">    bool   no_chaos = false;</a>
<a name="ln2906"> </a>
<a name="ln2907">    switch (summon_type)</a>
<a name="ln2908">    {</a>
<a name="ln2909">    case SPELL_SHADOW_CREATURES:</a>
<a name="ln2910">    case MON_SUMM_SCROLL:</a>
<a name="ln2911">        msg      = &quot;dissolve%s into shadows&quot;;</a>
<a name="ln2912">        no_chaos = true;</a>
<a name="ln2913">        break;</a>
<a name="ln2914"> </a>
<a name="ln2915">    case MON_SUMM_CHAOS:</a>
<a name="ln2916">        msg = &quot;degenerate%s into a cloud of primal chaos&quot;;</a>
<a name="ln2917">        break;</a>
<a name="ln2918"> </a>
<a name="ln2919">    case MON_SUMM_WRATH:</a>
<a name="ln2920">    case MON_SUMM_AID:</a>
<a name="ln2921">        if (valid_mon &amp;&amp; is_good_god(mons-&gt;god))</a>
<a name="ln2922">        {</a>
<a name="ln2923">            msg      = &quot;dissolve%s into sparkling lights&quot;;</a>
<a name="ln2924">            no_chaos = true;</a>
<a name="ln2925">        }</a>
<a name="ln2926">        break;</a>
<a name="ln2927"> </a>
<a name="ln2928">    case SPELL_SPECTRAL_CLOUD:</a>
<a name="ln2929">    case SPELL_CALL_LOST_SOUL:</a>
<a name="ln2930">        msg = &quot;fade%s away&quot;;</a>
<a name="ln2931">        break;</a>
<a name="ln2932">    }</a>
<a name="ln2933"> </a>
<a name="ln2934">    if (valid_mon)</a>
<a name="ln2935">    {</a>
<a name="ln2936">        if (mons-&gt;god == GOD_XOM &amp;&amp; !no_chaos &amp;&amp; one_chance_in(10)</a>
<a name="ln2937">            || mons-&gt;type == MONS_CHAOS_SPAWN)</a>
<a name="ln2938">        {</a>
<a name="ln2939">            msg = &quot;degenerate%s into a cloud of primal chaos&quot;;</a>
<a name="ln2940">        }</a>
<a name="ln2941"> </a>
<a name="ln2942">        if (mons-&gt;is_holy()</a>
<a name="ln2943">            &amp;&amp; summon_type != SPELL_SHADOW_CREATURES</a>
<a name="ln2944">            &amp;&amp; summon_type != MON_SUMM_CHAOS)</a>
<a name="ln2945">        {</a>
<a name="ln2946">            msg = &quot;dissolve%s into sparkling lights&quot;;</a>
<a name="ln2947">        }</a>
<a name="ln2948"> </a>
<a name="ln2949">        if (mons_is_slime(*mons)</a>
<a name="ln2950">            &amp;&amp; mons-&gt;god == GOD_JIYVA)</a>
<a name="ln2951">        {</a>
<a name="ln2952">            msg = &quot;dissolve%s into a puddle of slime&quot;;</a>
<a name="ln2953">        }</a>
<a name="ln2954"> </a>
<a name="ln2955">        if (mons-&gt;type == MONS_DROWNED_SOUL)</a>
<a name="ln2956">            msg = &quot;return%s to the deep&quot;;</a>
<a name="ln2957"> </a>
<a name="ln2958">        if (mons-&gt;has_ench(ENCH_PHANTOM_MIRROR))</a>
<a name="ln2959">            msg = &quot;shimmer%s and vanish&quot; + string(plural ? &quot;&quot; : &quot;es&quot;); // Ugh</a>
<a name="ln2960">    }</a>
<a name="ln2961"> </a>
<a name="ln2962">    // Conjugate.</a>
<a name="ln2963">    msg = make_stringf(msg.c_str(), plural ? &quot;&quot; : &quot;s&quot;);</a>
<a name="ln2964"> </a>
<a name="ln2965">    return msg;</a>
<a name="ln2966">}</a>
<a name="ln2967"> </a>
<a name="ln2968">string summoned_poof_msg(const monster* mons, const item_def &amp;item)</a>
<a name="ln2969">{</a>
<a name="ln2970">    ASSERT(item.flags &amp; ISFLAG_SUMMONED);</a>
<a name="ln2971"> </a>
<a name="ln2972">    return summoned_poof_msg(mons, item.quantity &gt; 1);</a>
<a name="ln2973">}</a>
<a name="ln2974"> </a>
<a name="ln2975">/**</a>
<a name="ln2976"> * Determine if a specified monster is or was a specified monster type.</a>
<a name="ln2977"> *</a>
<a name="ln2978"> * Checks both the monster type and the ORIGINAL_TYPE_KEY prop, thus allowing</a>
<a name="ln2979"> * the type to be transferred through polymorph.</a>
<a name="ln2980"> *</a>
<a name="ln2981"> * @param mons    The monster to be checked.</a>
<a name="ln2982"> * @param type    The type it might be.</a>
<a name="ln2983"> * @return        True if the monster was or is the type, otherwise false.</a>
<a name="ln2984">**/</a>
<a name="ln2985">bool mons_is_mons_class(const monster* mons, monster_type type)</a>
<a name="ln2986">{</a>
<a name="ln2987">    return mons-&gt;type == type</a>
<a name="ln2988">           || mons-&gt;props.exists(ORIGINAL_TYPE_KEY)</a>
<a name="ln2989">              &amp;&amp; mons-&gt;props[ORIGINAL_TYPE_KEY].get_int() == type;</a>
<a name="ln2990">}</a>
<a name="ln2991"> </a>
<a name="ln2992">/**</a>
<a name="ln2993"> * Perform neutralisation for members of Pikel's band upon Pikel's 'death'.</a>
<a name="ln2994"> *</a>
<a name="ln2995"> * This neutralisation occurs in multiple instances: when Pikel is neutralised,</a>
<a name="ln2996"> * enslaved, when Pikel dies, when Pikel is banished.</a>
<a name="ln2997"> * It is handled by a daction (as a fineff) to preserve across levels.</a>
<a name="ln2998"> **/</a>
<a name="ln2999">void pikel_band_neutralise()</a>
<a name="ln3000">{</a>
<a name="ln3001">    int visible_slaves = 0;</a>
<a name="ln3002">    for (monster_iterator mi; mi; ++mi)</a>
<a name="ln3003">    {</a>
<a name="ln3004">        if (mi-&gt;type == MONS_SLAVE</a>
<a name="ln3005">            &amp;&amp; testbits(mi-&gt;flags, MF_BAND_MEMBER)</a>
<a name="ln3006">            &amp;&amp; mi-&gt;props.exists(&quot;pikel_band&quot;)</a>
<a name="ln3007">            &amp;&amp; mi-&gt;mname != &quot;freed slave&quot;</a>
<a name="ln3008">            &amp;&amp; mi-&gt;observable())</a>
<a name="ln3009">        {</a>
<a name="ln3010">            visible_slaves++;</a>
<a name="ln3011">        }</a>
<a name="ln3012">    }</a>
<a name="ln3013">    string final_msg;</a>
<a name="ln3014">    if (visible_slaves &gt; 0)</a>
<a name="ln3015">    {</a>
<a name="ln3016">        if (you.get_mutation_level(MUT_NO_LOVE))</a>
<a name="ln3017">        {</a>
<a name="ln3018">            const char *substr = visible_slaves &gt; 1 ? &quot;slaves&quot; : &quot;slave&quot;;</a>
<a name="ln3019">            final_msg = make_stringf(&quot;Pikel's spell is broken, but the former &quot;</a>
<a name="ln3020">                                     &quot;%s can only feel hate for you!&quot;, substr);</a>
<a name="ln3021">        }</a>
<a name="ln3022">        else</a>
<a name="ln3023">        {</a>
<a name="ln3024">            const char *substr = visible_slaves &gt; 1</a>
<a name="ln3025">                ? &quot;slaves thank you for their&quot;</a>
<a name="ln3026">                : &quot;slave thanks you for its&quot;;</a>
<a name="ln3027">            final_msg = make_stringf(&quot;With Pikel's spell broken, the former %s &quot;</a>
<a name="ln3028">                                     &quot;freedom.&quot;, substr);</a>
<a name="ln3029">        }</a>
<a name="ln3030">    }</a>
<a name="ln3031">    delayed_action_fineff::schedule(DACT_PIKEL_SLAVES, final_msg);</a>
<a name="ln3032">}</a>
<a name="ln3033"> </a>
<a name="ln3034">/**</a>
<a name="ln3035"> * Revert porkalated hogs.</a>
<a name="ln3036"> *</a>
<a name="ln3037"> * Called upon Kirke's death. Hogs either from Kirke's band or</a>
<a name="ln3038"> * subsequently porkalated should be reverted to their original form.</a>
<a name="ln3039"> * This takes place as a daction to preserve behaviour across levels;</a>
<a name="ln3040"> * this function simply checks if any are visible and raises a fineff</a>
<a name="ln3041"> * containing an appropriate message. The fineff raises the actual</a>
<a name="ln3042"> * daction.</a>
<a name="ln3043"> */</a>
<a name="ln3044">void hogs_to_humans()</a>
<a name="ln3045">{</a>
<a name="ln3046">    int any = 0, human = 0;</a>
<a name="ln3047"> </a>
<a name="ln3048">    for (monster_iterator mi; mi; ++mi)</a>
<a name="ln3049">    {</a>
<a name="ln3050">        if (mons_genus(mi-&gt;type) != MONS_HOG)</a>
<a name="ln3051">            continue;</a>
<a name="ln3052"> </a>
<a name="ln3053">        if (!mi-&gt;props.exists(&quot;kirke_band&quot;)</a>
<a name="ln3054">            &amp;&amp; !mi-&gt;props.exists(ORIG_MONSTER_KEY))</a>
<a name="ln3055">        {</a>
<a name="ln3056">            continue;</a>
<a name="ln3057">        }</a>
<a name="ln3058"> </a>
<a name="ln3059">        // Shapeshifters will stop being a hog when they feel like it.</a>
<a name="ln3060">        if (mi-&gt;is_shapeshifter())</a>
<a name="ln3061">            continue;</a>
<a name="ln3062"> </a>
<a name="ln3063">        const bool could_see = you.can_see(**mi);</a>
<a name="ln3064"> </a>
<a name="ln3065">        if (could_see) any++;</a>
<a name="ln3066"> </a>
<a name="ln3067">        if (!mi-&gt;props.exists(ORIG_MONSTER_KEY) &amp;&amp; could_see)</a>
<a name="ln3068">            human++;</a>
<a name="ln3069">    }</a>
<a name="ln3070"> </a>
<a name="ln3071">    string final_msg;</a>
<a name="ln3072">    if (any &gt; 0)</a>
<a name="ln3073">    {</a>
<a name="ln3074">        final_msg = make_stringf(&quot;No longer under Kirke's spell, the %s %s %s!&quot;,</a>
<a name="ln3075">                                 any &gt; 1 ? &quot;hogs return to their&quot;</a>
<a name="ln3076">                                         : &quot;hog returns to its&quot;,</a>
<a name="ln3077">                                 any == human ? &quot;human&quot; : &quot;original&quot;,</a>
<a name="ln3078">                                 any &gt; 1 ? &quot;forms&quot; : &quot;form&quot;);</a>
<a name="ln3079">    }</a>
<a name="ln3080">    kirke_death_fineff::schedule(final_msg);</a>
<a name="ln3081">}</a>
<a name="ln3082"> </a>
<a name="ln3083">/**</a>
<a name="ln3084"> * Determine if a monster is either Dowan or Duvessa.</a>
<a name="ln3085"> *</a>
<a name="ln3086"> * Tracks through type and ORIGINAL_TYPE_KEY, thus tracking through polymorph.</a>
<a name="ln3087"> * Used to determine if a death function should be called for the monster</a>
<a name="ln3088"> * in question.</a>
<a name="ln3089"> *</a>
<a name="ln3090"> * @param mons    The monster to check.</a>
<a name="ln3091"> * @return        True if either Dowan or Duvessa, otherwise false.</a>
<a name="ln3092">**/</a>
<a name="ln3093">bool mons_is_elven_twin(const monster* mons)</a>
<a name="ln3094">{</a>
<a name="ln3095">    return mons_is_mons_class(mons, MONS_DOWAN)</a>
<a name="ln3096">           || mons_is_mons_class(mons, MONS_DUVESSA);</a>
<a name="ln3097">}</a>
<a name="ln3098"> </a>
<a name="ln3099">/**</a>
<a name="ln3100"> * Find Duvessa or Dowan, given the other.</a>
<a name="ln3101"> *</a>
<a name="ln3102"> * @param mons    The monster whose twin we seek.</a>
<a name="ln3103"> * @return        A pointer to the other elven twin, or nullptr if the twin</a>
<a name="ln3104"> *                no longer exists, or if given a mons that is not an elven twin.</a>
<a name="ln3105">**/</a>
<a name="ln3106">monster* mons_find_elven_twin_of(const monster* mons)</a>
<a name="ln3107">{</a>
<a name="ln3108">    if (!mons_is_elven_twin(mons))</a>
<a name="ln3109">        return nullptr;</a>
<a name="ln3110"> </a>
<a name="ln3111">    for (monster_iterator mi; mi; ++mi)</a>
<a name="ln3112">    {</a>
<a name="ln3113">        if (*mi == mons)</a>
<a name="ln3114">            continue;</a>
<a name="ln3115"> </a>
<a name="ln3116">        if (mons_is_elven_twin(*mi))</a>
<a name="ln3117">            return *mi;</a>
<a name="ln3118">    }</a>
<a name="ln3119"> </a>
<a name="ln3120">    return nullptr;</a>
<a name="ln3121">}</a>
<a name="ln3122"> </a>
<a name="ln3123">/**</a>
<a name="ln3124"> * Perform functional changes Dowan or Duvessa upon the other's death.</a>
<a name="ln3125"> *</a>
<a name="ln3126"> * This functional is called when either Dowan or Duvessa are killed or</a>
<a name="ln3127"> * banished. It performs a variety of changes in both attitude, spells, flavour,</a>
<a name="ln3128"> * speech, etc.</a>
<a name="ln3129"> *</a>
<a name="ln3130"> * @param twin          The monster who died.</a>
<a name="ln3131"> * @param in_transit    True if banished, otherwise false.</a>
<a name="ln3132"> * @param killer        The kill-type related to twin.</a>
<a name="ln3133"> * @param killer_index  The index of the actor who killed twin.</a>
<a name="ln3134">**/</a>
<a name="ln3135">void elven_twin_died(monster* twin, bool in_transit, killer_type killer, int killer_index)</a>
<a name="ln3136">{</a>
<a name="ln3137">    // Sometimes, if you pacify one twin near a staircase, they leave</a>
<a name="ln3138">    // in the same turn. Convert, in those instances. The strict_neutral check</a>
<a name="ln3139">    // is intended to cover the slimify case, we don't want to pacify the other</a>
<a name="ln3140">    // if a slimified twin dies.</a>
<a name="ln3141">    if (twin-&gt;neutral() &amp;&amp; !twin-&gt;has_ench(ENCH_INSANE)</a>
<a name="ln3142">                                                    &amp;&amp; !twin-&gt;strict_neutral())</a>
<a name="ln3143">    {</a>
<a name="ln3144">        elven_twins_pacify(twin);</a>
<a name="ln3145">        return;</a>
<a name="ln3146">    }</a>
<a name="ln3147"> </a>
<a name="ln3148">    monster* mons = mons_find_elven_twin_of(twin);</a>
<a name="ln3149"> </a>
<a name="ln3150">    if (!mons)</a>
<a name="ln3151">        return;</a>
<a name="ln3152"> </a>
<a name="ln3153">    // Don't consider already neutralised monsters.</a>
<a name="ln3154">    if (mons-&gt;good_neutral() || mons-&gt;strict_neutral())</a>
<a name="ln3155">        return;</a>
<a name="ln3156"> </a>
<a name="ln3157">    // Okay, let them climb stairs now.</a>
<a name="ln3158">    mons-&gt;props[&quot;can_climb&quot;] = true;</a>
<a name="ln3159">    if (!in_transit)</a>
<a name="ln3160">        mons-&gt;props[&quot;speech_prefix&quot;] = &quot;twin_died&quot;;</a>
<a name="ln3161">    else</a>
<a name="ln3162">        mons-&gt;props[&quot;speech_prefix&quot;] = &quot;twin_banished&quot;;</a>
<a name="ln3163"> </a>
<a name="ln3164">    // If you've stabbed one of them, the other one is likely asleep still.</a>
<a name="ln3165">    if (mons-&gt;asleep())</a>
<a name="ln3166">        behaviour_event(mons, ME_DISTURB, 0, mons-&gt;pos());</a>
<a name="ln3167"> </a>
<a name="ln3168">    // Will generate strings such as 'Duvessa_Duvessa_dies' or, alternately</a>
<a name="ln3169">    // 'Dowan_Dowan_dies', but as neither will match, these can safely be</a>
<a name="ln3170">    // ignored.</a>
<a name="ln3171">    string key = mons-&gt;name(DESC_THE, true) + &quot;_&quot;</a>
<a name="ln3172">                 + twin-&gt;name(DESC_THE, true) + &quot;_dies_&quot;;</a>
<a name="ln3173"> </a>
<a name="ln3174">    if (you.see_cell(mons-&gt;pos()))</a>
<a name="ln3175">    {</a>
<a name="ln3176">        if (!mons-&gt;visible_to(&amp;you))</a>
<a name="ln3177">            key += &quot;invisible_&quot;;</a>
<a name="ln3178">    }</a>
<a name="ln3179">    else</a>
<a name="ln3180">        key += &quot;distance_&quot;;</a>
<a name="ln3181"> </a>
<a name="ln3182">    bool i_killed = ((killer == KILL_MON || killer == KILL_MON_MISSILE)</a>
<a name="ln3183">                      &amp;&amp; mons-&gt;mindex() == killer_index);</a>
<a name="ln3184"> </a>
<a name="ln3185">    if (i_killed)</a>
<a name="ln3186">    {</a>
<a name="ln3187">        key += &quot;bytwin_&quot;;</a>
<a name="ln3188">        mons-&gt;props[&quot;speech_prefix&quot;] = &quot;twin_ikilled&quot;;</a>
<a name="ln3189">    }</a>
<a name="ln3190"> </a>
<a name="ln3191">    // Drop the final '_'.</a>
<a name="ln3192">    key.erase(key.length() - 1);</a>
<a name="ln3193"> </a>
<a name="ln3194">    string death_message = getSpeakString(key);</a>
<a name="ln3195"> </a>
<a name="ln3196">    // Check if they can speak or not: they may have been polymorphed.</a>
<a name="ln3197">    if (you.see_cell(mons-&gt;pos()) &amp;&amp; !death_message.empty() &amp;&amp; mons-&gt;can_speak())</a>
<a name="ln3198">        mons_speaks_msg(mons, death_message, MSGCH_TALK, silenced(you.pos()));</a>
<a name="ln3199">    else if (mons-&gt;can_speak())</a>
<a name="ln3200">        mpr(death_message);</a>
<a name="ln3201"> </a>
<a name="ln3202">    // Upgrade the spellbook here, as elven_twin_energize</a>
<a name="ln3203">    // may not be called due to lack of visibility.</a>
<a name="ln3204">    if (mons_is_mons_class(mons, MONS_DOWAN)</a>
<a name="ln3205">                                        &amp;&amp; !(mons-&gt;flags &amp; MF_POLYMORPHED))</a>
<a name="ln3206">    {</a>
<a name="ln3207">        // Don't mess with Dowan's spells if he's been polymorphed: most</a>
<a name="ln3208">        // possible forms have no spells, and the few that do (e.g. boggart)</a>
<a name="ln3209">        // have way more fun spells than this. If this ever changes, the</a>
<a name="ln3210">        // following code would need to be rewritten, as it'll crash.</a>
<a name="ln3211">        // TODO: this is a fairly brittle way of upgrading Dowan...</a>
<a name="ln3212">        ASSERT(mons-&gt;spells.size() &gt;= 5);</a>
<a name="ln3213">        mons-&gt;spells[0].spell = SPELL_STONE_ARROW;</a>
<a name="ln3214">        mons-&gt;spells[1].spell = SPELL_THROW_ICICLE;</a>
<a name="ln3215">        mons-&gt;spells[3].spell = SPELL_BLINK;</a>
<a name="ln3216">        mons-&gt;spells[4].spell = SPELL_HASTE;</a>
<a name="ln3217">        // Nothing with 6.</a>
<a name="ln3218"> </a>
<a name="ln3219">        // Indicate that he has an updated spellbook.</a>
<a name="ln3220">        mons-&gt;props[CUSTOM_SPELLS_KEY] = true;</a>
<a name="ln3221">    }</a>
<a name="ln3222"> </a>
<a name="ln3223">    // Finally give them new energy</a>
<a name="ln3224">    if (mons-&gt;can_see(you) &amp;&amp; !mons-&gt;has_ench(ENCH_INSANE))</a>
<a name="ln3225">        elven_twin_energize(mons);</a>
<a name="ln3226">    else</a>
<a name="ln3227">        mons-&gt;props[ELVEN_ENERGIZE_KEY] = true;</a>
<a name="ln3228">}</a>
<a name="ln3229"> </a>
<a name="ln3230">void elven_twin_energize(monster* mons)</a>
<a name="ln3231">{</a>
<a name="ln3232">    if (mons_is_mons_class(mons, MONS_DUVESSA))</a>
<a name="ln3233">        mons-&gt;go_berserk(true);</a>
<a name="ln3234">    else</a>
<a name="ln3235">    {</a>
<a name="ln3236">        ASSERT(mons_is_mons_class(mons, MONS_DOWAN));</a>
<a name="ln3237">        if (mons-&gt;observable())</a>
<a name="ln3238">            simple_monster_message(*mons, &quot; seems to find hidden reserves of power!&quot;);</a>
<a name="ln3239"> </a>
<a name="ln3240">        mons-&gt;add_ench(ENCH_HASTE);</a>
<a name="ln3241">    }</a>
<a name="ln3242"> </a>
<a name="ln3243">    mons-&gt;props[ELVEN_IS_ENERGIZED_KEY] = true;</a>
<a name="ln3244">}</a>
<a name="ln3245"> </a>
<a name="ln3246">/**</a>
<a name="ln3247"> * Pacification effects for Dowan and Duvessa.</a>
<a name="ln3248"> *</a>
<a name="ln3249"> * As twins, pacifying one pacifies the other.</a>
<a name="ln3250"> *</a>
<a name="ln3251"> * @param twin    The original monster pacified.</a>
<a name="ln3252">**/</a>
<a name="ln3253">void elven_twins_pacify(monster* twin)</a>
<a name="ln3254">{</a>
<a name="ln3255">    monster* mons = mons_find_elven_twin_of(twin);</a>
<a name="ln3256"> </a>
<a name="ln3257">    if (!mons)</a>
<a name="ln3258">        return;</a>
<a name="ln3259"> </a>
<a name="ln3260">    // Don't consider already neutralised monsters.</a>
<a name="ln3261">    if (mons-&gt;neutral())</a>
<a name="ln3262">        return;</a>
<a name="ln3263"> </a>
<a name="ln3264">    simple_monster_message(*mons, &quot; likewise turns neutral.&quot;);</a>
<a name="ln3265"> </a>
<a name="ln3266">    record_monster_defeat(mons, KILL_PACIFIED);</a>
<a name="ln3267">    mons_pacify(*mons, ATT_NEUTRAL);</a>
<a name="ln3268">}</a>
<a name="ln3269"> </a>
<a name="ln3270">/**</a>
<a name="ln3271"> * Unpacification effects for Dowan and Duvessa.</a>
<a name="ln3272"> *</a>
<a name="ln3273"> * If they are both pacified and you attack one, the other will not remain</a>
<a name="ln3274"> * neutral. This is both for flavour (they do things together), and</a>
<a name="ln3275"> * functionality (so Dowan does not begin beating on Duvessa, etc).</a>
<a name="ln3276"> *</a>
<a name="ln3277"> * @param twin    The monster attacked.</a>
<a name="ln3278">**/</a>
<a name="ln3279">void elven_twins_unpacify(monster* twin)</a>
<a name="ln3280">{</a>
<a name="ln3281">    monster* mons = mons_find_elven_twin_of(twin);</a>
<a name="ln3282"> </a>
<a name="ln3283">    if (!mons)</a>
<a name="ln3284">        return;</a>
<a name="ln3285"> </a>
<a name="ln3286">    // Don't consider already un-neutralised monsters.</a>
<a name="ln3287">    if (!mons-&gt;neutral() || mons-&gt;has_ench(ENCH_INSANE))</a>
<a name="ln3288">        return;</a>
<a name="ln3289">    simple_monster_message(*mons, &quot; gets angry again!&quot;);</a>
<a name="ln3290"> </a>
<a name="ln3291">    behaviour_event(mons, ME_WHACK, &amp;you, you.pos(), false);</a>
<a name="ln3292">}</a>
<a name="ln3293"> </a>
<a name="ln3294">bool mons_felid_can_revive(const monster* mons)</a>
<a name="ln3295">{</a>
<a name="ln3296">    return !mons-&gt;props.exists(&quot;felid_revives&quot;)</a>
<a name="ln3297">           || mons-&gt;props[&quot;felid_revives&quot;].get_byte() &lt; 2;</a>
<a name="ln3298">}</a>
<a name="ln3299"> </a>
<a name="ln3300">void mons_felid_revive(monster* mons)</a>
<a name="ln3301">{</a>
<a name="ln3302">    // FIXME: this should be a fineff like bennu_revive_fineff. But that</a>
<a name="ln3303">    // is tricky because the original actor will be dead (and not carrying</a>
<a name="ln3304">    // its items) by the time the fineff fires.</a>
<a name="ln3305"> </a>
<a name="ln3306">    // Mostly adapted from bring_to_safety()</a>
<a name="ln3307">    coord_def revive_place;</a>
<a name="ln3308">    int tries = 10000;</a>
<a name="ln3309">    while (tries &gt; 0) // Don't try too hard.</a>
<a name="ln3310">    {</a>
<a name="ln3311">        revive_place.x = random2(GXM);</a>
<a name="ln3312">        revive_place.y = random2(GYM);</a>
<a name="ln3313">        if (!in_bounds(revive_place)</a>
<a name="ln3314">            || grd(revive_place) != DNGN_FLOOR</a>
<a name="ln3315">            || cloud_at(revive_place)</a>
<a name="ln3316">            || monster_at(revive_place)</a>
<a name="ln3317">            || env.pgrid(revive_place) &amp; FPROP_NO_TELE_INTO</a>
<a name="ln3318">            || grid_distance(revive_place, mons-&gt;pos()) &lt; 9)</a>
<a name="ln3319">        {</a>
<a name="ln3320">            tries--;</a>
<a name="ln3321">            continue;</a>
<a name="ln3322">        }</a>
<a name="ln3323">        else</a>
<a name="ln3324">            break;</a>
<a name="ln3325">    }</a>
<a name="ln3326">    if (tries == 0)</a>
<a name="ln3327">        return;</a>
<a name="ln3328"> </a>
<a name="ln3329">    monster_type type = mons_is_mons_class(mons, MONS_NATASHA) ? MONS_NATASHA</a>
<a name="ln3330">                                                               : mons-&gt;type;</a>
<a name="ln3331">    const int revives = (mons-&gt;props.exists(&quot;felid_revives&quot;))</a>
<a name="ln3332">                        ? mons-&gt;props[&quot;felid_revives&quot;].get_byte() + 1</a>
<a name="ln3333">                        : 1;</a>
<a name="ln3334"> </a>
<a name="ln3335">    monster *newmons =</a>
<a name="ln3336">        create_monster(</a>
<a name="ln3337">            mgen_data(type, (mons-&gt;has_ench(ENCH_CHARM) ? BEH_HOSTILE</a>
<a name="ln3338">                             : SAME_ATTITUDE(mons)), revive_place, mons-&gt;foe));</a>
<a name="ln3339"> </a>
<a name="ln3340">    if (newmons)</a>
<a name="ln3341">    {</a>
<a name="ln3342">        for (mon_inv_iterator ii(*mons); ii; ++ii)</a>
<a name="ln3343">        {</a>
<a name="ln3344">            give_specific_item(newmons, *ii);</a>
<a name="ln3345">            destroy_item(ii-&gt;index());</a>
<a name="ln3346">        }</a>
<a name="ln3347"> </a>
<a name="ln3348">        newmons-&gt;props[&quot;felid_revives&quot;].get_byte() = revives;</a>
<a name="ln3349">    }</a>
<a name="ln3350">}</a>
<a name="ln3351"> </a>
<a name="ln3352">bool mons_bennu_can_revive(const monster* mons)</a>
<a name="ln3353">{</a>
<a name="ln3354">    return !mons-&gt;props.exists(&quot;bennu_revives&quot;)</a>
<a name="ln3355">           || mons-&gt;props[&quot;bennu_revives&quot;].get_byte() &lt; 1;</a>
<a name="ln3356">}</a>

</code></pre>
<div class="balloon" rel="955"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v522/" target="_blank">V522</a> There might be dereferencing of a potential null pointer 'marker'.</p></div>
<div class="balloon" rel="2101"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v648/" target="_blank">V648</a> Priority of the '&&' operation is higher than that of the '||' operation.</p></div>
<div class="balloon" rel="2161"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v648/" target="_blank">V648</a> Priority of the '&&' operation is higher than that of the '||' operation.</p></div>
<div class="balloon" rel="2225"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v648/" target="_blank">V648</a> Priority of the '&&' operation is higher than that of the '||' operation.</p></div>
<div class="balloon" rel="2988"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v648/" target="_blank">V648</a> Priority of the '&&' operation is higher than that of the '||' operation.</p></div>

<link rel="stylesheet" href="highlight.css">
<script src="highlight.pack.js"></script>
<script src="highlightjs-line-numbers.js"></script>
<script>hljs.initHighlightingOnLoad();</script>
<script>hljs.initLineNumbersOnLoad();</script>
<script>
  $(document).ready(function() {
      $('.balloon').each(function () {
          var bl = $(this);
          var line = bl.attr('rel');
          var text = $('a[name="ln'+line+'"]').text();

          var space_count = 0;
          for(var i = 0; i<text.length; i++){
              var char = text[i];
              if((char !== ' ')&&(char !== '\t'))break;
              if(char === '\t')space_count++;
              space_count++;
          }

          bl.css('margin-left', space_count*8);
          $('a[name="ln'+line+'"]').after(bl);
      });

      window.location = window.location;
  });
</script>
</body>
</html>
