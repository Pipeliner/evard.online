
<html>
<head>

  <meta http-equiv="Content-Type" content="text/html; charset=US-ASCII" />
  <title>travel.cc</title>

  <link rel="stylesheet" href="../style.css"/>
  <script src="../jquery-3.2.1.min.js"></script>
</head>
<body>

<pre><code class = "cpp">
<a name="ln1">/**</a>
<a name="ln2"> * @file</a>
<a name="ln3"> * @brief Travel stuff</a>
<a name="ln4">**/</a>
<a name="ln5">/* Known issues:</a>
<a name="ln6"> *   Hardcoded dungeon features all over the place - this thing is a devil to</a>
<a name="ln7"> *   refactor.</a>
<a name="ln8"> */</a>
<a name="ln9">#include &quot;AppHdr.h&quot;</a>
<a name="ln10"> </a>
<a name="ln11">#include &quot;travel.h&quot;</a>
<a name="ln12"> </a>
<a name="ln13">#include &lt;algorithm&gt;</a>
<a name="ln14">#include &lt;cctype&gt;</a>
<a name="ln15">#include &lt;cstdarg&gt;</a>
<a name="ln16">#include &lt;cstdio&gt;</a>
<a name="ln17">#include &lt;memory&gt;</a>
<a name="ln18">#include &lt;set&gt;</a>
<a name="ln19">#include &lt;sstream&gt;</a>
<a name="ln20"> </a>
<a name="ln21">#include &quot;branch.h&quot;</a>
<a name="ln22">#include &quot;cloud.h&quot;</a>
<a name="ln23">#include &quot;clua.h&quot;</a>
<a name="ln24">#include &quot;command.h&quot;</a>
<a name="ln25">#include &quot;coordit.h&quot;</a>
<a name="ln26">#include &quot;daction-type.h&quot;</a>
<a name="ln27">#include &quot;dactions.h&quot;</a>
<a name="ln28">#include &quot;directn.h&quot;</a>
<a name="ln29">#include &quot;delay.h&quot;</a>
<a name="ln30">#include &quot;dgn-overview.h&quot;</a>
<a name="ln31">#include &quot;english.h&quot;</a>
<a name="ln32">#include &quot;env.h&quot;</a>
<a name="ln33">#include &quot;files.h&quot;</a>
<a name="ln34">#include &quot;food.h&quot;</a>
<a name="ln35">#include &quot;format.h&quot;</a>
<a name="ln36">#include &quot;god-abil.h&quot;</a>
<a name="ln37">#include &quot;god-passive.h&quot;</a>
<a name="ln38">#include &quot;hints.h&quot;</a>
<a name="ln39">#include &quot;item-name.h&quot;</a>
<a name="ln40">#include &quot;item-prop.h&quot;</a>
<a name="ln41">#include &quot;item-status-flag-type.h&quot;</a>
<a name="ln42">#include &quot;items.h&quot;</a>
<a name="ln43">#include &quot;libutil.h&quot;</a>
<a name="ln44">#include &quot;macro.h&quot;</a>
<a name="ln45">#include &quot;mapmark.h&quot;</a>
<a name="ln46">#include &quot;message.h&quot;</a>
<a name="ln47">#include &quot;mon-death.h&quot;</a>
<a name="ln48">#include &quot;nearby-danger.h&quot;</a>
<a name="ln49">#include &quot;output.h&quot;</a>
<a name="ln50">#include &quot;place.h&quot;</a>
<a name="ln51">#include &quot;prompt.h&quot;</a>
<a name="ln52">#include &quot;religion.h&quot;</a>
<a name="ln53">#include &quot;stairs.h&quot;</a>
<a name="ln54">#include &quot;state.h&quot;</a>
<a name="ln55">#include &quot;stringutil.h&quot;</a>
<a name="ln56">#include &quot;terrain.h&quot;</a>
<a name="ln57">#include &quot;tiles-build-specific.h&quot;</a>
<a name="ln58">#include &quot;traps.h&quot;</a>
<a name="ln59">#include &quot;unicode.h&quot;</a>
<a name="ln60">#include &quot;unwind.h&quot;</a>
<a name="ln61">#include &quot;view.h&quot;</a>
<a name="ln62"> </a>
<a name="ln63">enum IntertravelDestination</a>
<a name="ln64">{</a>
<a name="ln65">    // Go down a level</a>
<a name="ln66">    ID_DOWN     = -100,</a>
<a name="ln67"> </a>
<a name="ln68">    // Go up a level</a>
<a name="ln69">    ID_UP       = -99,</a>
<a name="ln70"> </a>
<a name="ln71">    // Repeat last travel</a>
<a name="ln72">    ID_REPEAT   = -101,</a>
<a name="ln73"> </a>
<a name="ln74">    // Altar as target</a>
<a name="ln75">    ID_ALTAR    = -102,</a>
<a name="ln76"> </a>
<a name="ln77">    // Cancel interlevel travel</a>
<a name="ln78">    ID_CANCEL   = -1000,</a>
<a name="ln79">};</a>
<a name="ln80"> </a>
<a name="ln81">TravelCache travel_cache;</a>
<a name="ln82"> </a>
<a name="ln83">// Tracks the distance between the target location on the target level and the</a>
<a name="ln84">// stairs on the level.</a>
<a name="ln85">static vector&lt;stair_info&gt; curr_stairs;</a>
<a name="ln86"> </a>
<a name="ln87">// Squares that are not safe to travel to on the current level.</a>
<a name="ln88">exclude_set curr_excludes;</a>
<a name="ln89"> </a>
<a name="ln90">// This is where we last tried to take a stair during interlevel travel.</a>
<a name="ln91">// Note that last_stair.id.depth should be set to -1 before initiating interlevel</a>
<a name="ln92">// travel.</a>
<a name="ln93">static level_pos last_stair;</a>
<a name="ln94"> </a>
<a name="ln95">// Where travel wants to get to.</a>
<a name="ln96">static level_pos level_target;</a>
<a name="ln97"> </a>
<a name="ln98">// How many stairs there are between the source and destination of</a>
<a name="ln99">// interlevel travel, as estimated by level_distance.</a>
<a name="ln100">static int _Src_Dest_Level_Delta = -1;</a>
<a name="ln101"> </a>
<a name="ln102">// Source level where interlevel travel was last activated.</a>
<a name="ln103">static level_id _Src_Level;</a>
<a name="ln104"> </a>
<a name="ln105">// Remember the last place explore stopped because autopickup failed.</a>
<a name="ln106">static coord_def explore_stopped_pos;</a>
<a name="ln107"> </a>
<a name="ln108">// The place in the Vestibule of Hell where all portals to Hell land.</a>
<a name="ln109">static level_pos travel_hell_entry;</a>
<a name="ln110"> </a>
<a name="ln111">static string trans_travel_dest;</a>
<a name="ln112"> </a>
<a name="ln113">// Array of points on the map, each value being the distance the character</a>
<a name="ln114">// would have to travel to get there. Negative distances imply that the point</a>
<a name="ln115">// is a) a trap or hostile terrain or b) only reachable by crossing a trap or</a>
<a name="ln116">// hostile terrain.</a>
<a name="ln117">travel_distance_grid_t travel_point_distance;</a>
<a name="ln118"> </a>
<a name="ln119">// Apply slime wall checks when checking if squares are travelsafe.</a>
<a name="ln120">bool g_Slime_Wall_Check = true;</a>
<a name="ln121"> </a>
<a name="ln122">static uint8_t curr_waypoints[GXM][GYM];</a>
<a name="ln123"> </a>
<a name="ln124">// If true, feat_is_traversable_now() returns the same as feat_is_traversable().</a>
<a name="ln125">// FIXME: eliminate this. It's needed for RMODE_CONNECTIVITY.</a>
<a name="ln126">static bool ignore_player_traversability = false;</a>
<a name="ln127"> </a>
<a name="ln128">// Map of terrain types that are forbidden.</a>
<a name="ln129">static FixedVector&lt;int8_t,NUM_FEATURES&gt; forbidden_terrain;</a>
<a name="ln130"> </a>
<a name="ln131">//#define DEBUG_TRAVEL</a>
<a name="ln132"> </a>
<a name="ln133">/*</a>
<a name="ln134"> * Warn if interlevel travel is going to take you outside levels in</a>
<a name="ln135"> * the range [src,dest].</a>
<a name="ln136"> */</a>
<a name="ln137">class deviant_route_warning</a>
<a name="ln138">{</a>
<a name="ln139">private:</a>
<a name="ln140">    level_pos target;</a>
<a name="ln141">    bool warned;</a>
<a name="ln142"> </a>
<a name="ln143">public:</a>
<a name="ln144">    deviant_route_warning(): target(), warned(false)</a>
<a name="ln145">    {</a>
<a name="ln146">    }</a>
<a name="ln147"> </a>
<a name="ln148">    void new_dest(const level_pos &amp;dest);</a>
<a name="ln149">    bool warn_continue_travel(const level_pos &amp;des,</a>
<a name="ln150">                              const level_id &amp;deviant);</a>
<a name="ln151">};</a>
<a name="ln152"> </a>
<a name="ln153">void deviant_route_warning::new_dest(const level_pos &amp;dest)</a>
<a name="ln154">{</a>
<a name="ln155">    if (target != dest)</a>
<a name="ln156">    {</a>
<a name="ln157">        warned = false;</a>
<a name="ln158">        target = dest;</a>
<a name="ln159">    }</a>
<a name="ln160">}</a>
<a name="ln161"> </a>
<a name="ln162">// Returns true if the player wants to continue travelling after the warning.</a>
<a name="ln163">bool deviant_route_warning::warn_continue_travel(</a>
<a name="ln164">    const level_pos &amp;dest, const level_id &amp;deviant)</a>
<a name="ln165">{</a>
<a name="ln166">    // We've already prompted, don't ask again, on the player's head be it.</a>
<a name="ln167">    if (target == dest &amp;&amp; warned)</a>
<a name="ln168">        return true;</a>
<a name="ln169"> </a>
<a name="ln170">    target = dest;</a>
<a name="ln171">    const string prompt = make_stringf(&quot;Have to go through %s. Continue?&quot;,</a>
<a name="ln172">                                       deviant.describe().c_str());</a>
<a name="ln173">    // If the user says &quot;Yes, shut up and take me there&quot;, we won't ask</a>
<a name="ln174">    // again for that destination. If the user says &quot;No&quot;, we will</a>
<a name="ln175">    // prompt again.</a>
<a name="ln176">    return warned = yesno(prompt.c_str(), true, 'n', true, false);</a>
<a name="ln177">}</a>
<a name="ln178"> </a>
<a name="ln179">static deviant_route_warning _Route_Warning;</a>
<a name="ln180"> </a>
<a name="ln181">static bool _find_transtravel_square(const level_pos &amp;pos,</a>
<a name="ln182">                                     bool verbose = true);</a>
<a name="ln183"> </a>
<a name="ln184">static bool _loadlev_populate_stair_distances(const level_pos &amp;target);</a>
<a name="ln185">static void _populate_stair_distances(const level_pos &amp;target);</a>
<a name="ln186">static bool _is_greed_inducing_square(const LevelStashes *ls,</a>
<a name="ln187">                                      const coord_def &amp;c, bool autopickup);</a>
<a name="ln188">static bool _is_travelsafe_square(const coord_def&amp; c,</a>
<a name="ln189">                                  bool ignore_hostile = false,</a>
<a name="ln190">                                  bool ignore_danger = false,</a>
<a name="ln191">                                  bool try_fallback = false);</a>
<a name="ln192"> </a>
<a name="ln193">// Returns true if there is a known trap at (x,y). Returns false for non-trap</a>
<a name="ln194">// squares as also for undiscovered traps.</a>
<a name="ln195">//</a>
<a name="ln196">static inline bool is_trap(const coord_def&amp; c)</a>
<a name="ln197">{</a>
<a name="ln198">    return feat_is_trap(env.map_knowledge(c).feat());</a>
<a name="ln199">}</a>
<a name="ln200"> </a>
<a name="ln201">static inline bool _is_safe_cloud(const coord_def&amp; c)</a>
<a name="ln202">{</a>
<a name="ln203">    const cloud_type ctype = env.map_knowledge(c).cloud();</a>
<a name="ln204">    if (ctype == CLOUD_NONE)</a>
<a name="ln205">        return true;</a>
<a name="ln206"> </a>
<a name="ln207">    // We can also safely run through smoke, or any of our own clouds if</a>
<a name="ln208">    // following Qazlal.</a>
<a name="ln209">    return !is_damaging_cloud(ctype, true, YOU_KILL(env.map_knowledge(c).cloudinfo()-&gt;killer));</a>
<a name="ln210">}</a>
<a name="ln211"> </a>
<a name="ln212">// Returns an estimate for the time needed to cross this feature.</a>
<a name="ln213">// This is done, so traps etc. will usually be circumvented where possible.</a>
<a name="ln214">static inline int _feature_traverse_cost(dungeon_feature_type feature)</a>
<a name="ln215">{</a>
<a name="ln216">    if (feat_is_closed_door(feature)</a>
<a name="ln217">        // Higher cost for shallow water if species doesn't like water</a>
<a name="ln218">        || feature == DNGN_SHALLOW_WATER &amp;&amp; (!player_likes_water(true)))</a>
<a name="ln219">    {</a>
<a name="ln220">        return 2;</a>
<a name="ln221">    }</a>
<a name="ln222">    else if (feat_is_trap(feature) &amp;&amp; feature != DNGN_TRAP_SHAFT)</a>
<a name="ln223">        return 3;</a>
<a name="ln224"> </a>
<a name="ln225">    return 1;</a>
<a name="ln226">}</a>
<a name="ln227"> </a>
<a name="ln228">bool is_unknown_stair(const coord_def &amp;p)</a>
<a name="ln229">{</a>
<a name="ln230">    dungeon_feature_type feat = env.map_knowledge(p).feat();</a>
<a name="ln231"> </a>
<a name="ln232">    return feat_is_travelable_stair(feat) &amp;&amp; !travel_cache.know_stair(p)</a>
<a name="ln233">           &amp;&amp; feat != DNGN_EXIT_DUNGEON;</a>
<a name="ln234">}</a>
<a name="ln235"> </a>
<a name="ln236">/**</a>
<a name="ln237"> * Does the player know this transporter's destination?</a>
<a name="ln238"> *</a>
<a name="ln239"> * @param p    The location of the transporter.</a>
<a name="ln240"> * @returns    True if the feature is a transporter with an unknown</a>
<a name="ln241"> *             destination, false otherwise.</a>
<a name="ln242"> **/</a>
<a name="ln243">bool is_unknown_transporter(const coord_def &amp;p)</a>
<a name="ln244">{</a>
<a name="ln245">    dungeon_feature_type feat = env.map_knowledge(p).feat();</a>
<a name="ln246"> </a>
<a name="ln247">    return feat == DNGN_TRANSPORTER &amp;&amp; !travel_cache.know_transporter(p);</a>
<a name="ln248">}</a>
<a name="ln249"> </a>
<a name="ln250">// Returns true if the character can cross this dungeon feature, and</a>
<a name="ln251">// the player hasn't requested that travel avoid the feature.</a>
<a name="ln252">bool feat_is_traversable_now(dungeon_feature_type grid, bool try_fallback)</a>
<a name="ln253">{</a>
<a name="ln254">    if (!ignore_player_traversability)</a>
<a name="ln255">    {</a>
<a name="ln256">        // Don't auto travel through toxic bogs</a>
<a name="ln257">        if (grid == DNGN_TOXIC_BOG)</a>
<a name="ln258">            return false;</a>
<a name="ln259"> </a>
<a name="ln260">        // If the feature is in travel_avoid_terrain, respect that.</a>
<a name="ln261">        if (forbidden_terrain[grid])</a>
<a name="ln262">            return false;</a>
<a name="ln263"> </a>
<a name="ln264">        // Swimmers and water-walkers get deep water.</a>
<a name="ln265">        if (grid == DNGN_DEEP_WATER</a>
<a name="ln266">            &amp;&amp; (player_likes_water(true) || have_passive(passive_t::water_walk)))</a>
<a name="ln267">        {</a>
<a name="ln268">            return true;</a>
<a name="ln269">        }</a>
<a name="ln270"> </a>
<a name="ln271">        // The player can safely walk over shafts.</a>
<a name="ln272">        if (grid == DNGN_TRAP_SHAFT)</a>
<a name="ln273">            return true;</a>
<a name="ln274"> </a>
<a name="ln275">        // Permanently flying players can cross most hostile terrain.</a>
<a name="ln276">        if (grid == DNGN_DEEP_WATER || grid == DNGN_LAVA)</a>
<a name="ln277">            return you.permanent_flight();</a>
<a name="ln278">    }</a>
<a name="ln279"> </a>
<a name="ln280">    return feat_is_traversable(grid, try_fallback);</a>
<a name="ln281">}</a>
<a name="ln282"> </a>
<a name="ln283">// Returns true if a generic character can cross this dungeon feature.</a>
<a name="ln284">// Ignores swimming, flying, and travel_avoid_terrain.</a>
<a name="ln285">bool feat_is_traversable(dungeon_feature_type feat, bool try_fallback)</a>
<a name="ln286">{</a>
<a name="ln287">    if (feat_is_trap(feat) &amp;&amp; feat != DNGN_PASSAGE_OF_GOLUBRIA)</a>
<a name="ln288">    {</a>
<a name="ln289">        if (ignore_player_traversability)</a>
<a name="ln290">            return !(feat == DNGN_TRAP_SHAFT || feat == DNGN_TRAP_TELEPORT || feat == DNGN_TRAP_TELEPORT_PERMANENT);</a>
<a name="ln291">        return false;</a>
<a name="ln292">    }</a>
<a name="ln293">#if TAG_MAJOR_VERSION == 34</a>
<a name="ln294">    else if (feat == DNGN_TELEPORTER) // never ever enter it automatically</a>
<a name="ln295">        return false;</a>
<a name="ln296">#endif</a>
<a name="ln297">    else if (feat_has_solid_floor(feat)</a>
<a name="ln298">             || feat_is_closed_door(feat)</a>
<a name="ln299">                &amp;&amp; (!feat_is_sealed(feat) || try_fallback))</a>
<a name="ln300">    {</a>
<a name="ln301">        return true;</a>
<a name="ln302">    }</a>
<a name="ln303">    else</a>
<a name="ln304">        return false;</a>
<a name="ln305">}</a>
<a name="ln306"> </a>
<a name="ln307">static const char *_run_mode_name(int runmode)</a>
<a name="ln308">{</a>
<a name="ln309">    return runmode == RMODE_TRAVEL         ? &quot;travel&quot; :</a>
<a name="ln310">           runmode == RMODE_INTERLEVEL     ? &quot;intertravel&quot; :</a>
<a name="ln311">           runmode == RMODE_EXPLORE        ? &quot;explore&quot; :</a>
<a name="ln312">           runmode == RMODE_EXPLORE_GREEDY ? &quot;explore_greedy&quot; :</a>
<a name="ln313">           runmode &gt; 0                     ? &quot;run&quot;</a>
<a name="ln314">                                           : &quot;&quot;;</a>
<a name="ln315">}</a>
<a name="ln316"> </a>
<a name="ln317">uint8_t is_waypoint(const coord_def &amp;p)</a>
<a name="ln318">{</a>
<a name="ln319">    if (!can_travel_interlevel())</a>
<a name="ln320">        return 0;</a>
<a name="ln321">    return curr_waypoints[p.x][p.y];</a>
<a name="ln322">}</a>
<a name="ln323"> </a>
<a name="ln324">static inline bool is_stash(const LevelStashes *ls, const coord_def&amp; p)</a>
<a name="ln325">{</a>
<a name="ln326">    return ls &amp;&amp; ls-&gt;find_stash(p);</a>
<a name="ln327">}</a>
<a name="ln328"> </a>
<a name="ln329">static bool _monster_blocks_travel(const monster_info *mons)</a>
<a name="ln330">{</a>
<a name="ln331">    return mons</a>
<a name="ln332">           &amp;&amp; mons_class_is_stationary(mons-&gt;type)</a>
<a name="ln333">           &amp;&amp; !fedhas_passthrough(mons);</a>
<a name="ln334">}</a>
<a name="ln335"> </a>
<a name="ln336">/*</a>
<a name="ln337"> * Returns true if the square at (x,y) is a dungeon feature the character</a>
<a name="ln338"> * can't (under normal circumstances) safely cross.</a>
<a name="ln339"> *</a>
<a name="ln340"> * Note: is_reseedable can return true for dungeon features that is_traversable</a>
<a name="ln341"> *       also returns true for. This is okay, because is_traversable always</a>
<a name="ln342"> *       takes precedence over is_reseedable. is_reseedable is used only to</a>
<a name="ln343"> *       decide which squares to reseed from when flood-filling outwards to</a>
<a name="ln344"> *       colour the level map. It does not affect pathing of actual</a>
<a name="ln345"> *       travel/explore.</a>
<a name="ln346"> */</a>
<a name="ln347">static bool _is_reseedable(const coord_def&amp; c, bool ignore_danger = false)</a>
<a name="ln348">{</a>
<a name="ln349">    if (!ignore_danger &amp;&amp; is_excluded(c))</a>
<a name="ln350">        return true;</a>
<a name="ln351"> </a>
<a name="ln352">    map_cell &amp;cell(env.map_knowledge(c));</a>
<a name="ln353">    const dungeon_feature_type grid = cell.feat();</a>
<a name="ln354"> </a>
<a name="ln355">    if (feat_is_wall(grid) || grid == DNGN_TREE)</a>
<a name="ln356">        return false;</a>
<a name="ln357"> </a>
<a name="ln358">    return feat_is_water(grid)</a>
<a name="ln359">           || grid == DNGN_LAVA</a>
<a name="ln360">           || feat_is_runed(grid)</a>
<a name="ln361">           || is_trap(c)</a>
<a name="ln362">           || !ignore_danger &amp;&amp; _monster_blocks_travel(cell.monsterinfo())</a>
<a name="ln363">           || g_Slime_Wall_Check &amp;&amp; slime_wall_neighbour(c)</a>
<a name="ln364">           || !_is_safe_cloud(c);</a>
<a name="ln365">}</a>
<a name="ln366"> </a>
<a name="ln367">struct cell_travel_safety</a>
<a name="ln368">{</a>
<a name="ln369">    bool safe;</a>
<a name="ln370">    bool safe_if_ignoring_hostile_terrain;</a>
<a name="ln371"> </a>
<a name="ln372">    cell_travel_safety() : safe(false), safe_if_ignoring_hostile_terrain(false)</a>
<a name="ln373">    {</a>
<a name="ln374">    }</a>
<a name="ln375">};</a>
<a name="ln376"> </a>
<a name="ln377">typedef FixedArray&lt;cell_travel_safety, GXM, GYM&gt; travel_safe_grid;</a>
<a name="ln378">static unique_ptr&lt;travel_safe_grid&gt; _travel_safe_grid;</a>
<a name="ln379"> </a>
<a name="ln380">class precompute_travel_safety_grid</a>
<a name="ln381">{</a>
<a name="ln382">private:</a>
<a name="ln383">    bool did_compute;</a>
<a name="ln384"> </a>
<a name="ln385">public:</a>
<a name="ln386">    precompute_travel_safety_grid() : did_compute(false)</a>
<a name="ln387">    {</a>
<a name="ln388">        if (!_travel_safe_grid)</a>
<a name="ln389">        {</a>
<a name="ln390">            did_compute = true;</a>
<a name="ln391">            auto tsgrid = make_unique&lt;travel_safe_grid&gt;();</a>
<a name="ln392">            travel_safe_grid &amp;safegrid(*tsgrid);</a>
<a name="ln393">            for (rectangle_iterator ri(1); ri; ++ri)</a>
<a name="ln394">            {</a>
<a name="ln395">                const coord_def p(*ri);</a>
<a name="ln396">                cell_travel_safety &amp;ts(safegrid(p));</a>
<a name="ln397">                ts.safe = _is_travelsafe_square(p, false);</a>
<a name="ln398">                ts.safe_if_ignoring_hostile_terrain =</a>
<a name="ln399">                    _is_travelsafe_square(p, true);</a>
<a name="ln400">            }</a>
<a name="ln401">            _travel_safe_grid = move(tsgrid);</a>
<a name="ln402">        }</a>
<a name="ln403">    }</a>
<a name="ln404">    ~precompute_travel_safety_grid()</a>
<a name="ln405">    {</a>
<a name="ln406">        if (did_compute)</a>
<a name="ln407">            _travel_safe_grid.reset(nullptr);</a>
<a name="ln408">    }</a>
<a name="ln409">};</a>
<a name="ln410"> </a>
<a name="ln411">bool is_stair_exclusion(const coord_def &amp;p)</a>
<a name="ln412">{</a>
<a name="ln413">    if (feat_stair_direction(env.map_knowledge(p).feat()) == CMD_NO_CMD)</a>
<a name="ln414">        return false;</a>
<a name="ln415"> </a>
<a name="ln416">    return get_exclusion_radius(p) == 1;</a>
<a name="ln417">}</a>
<a name="ln418"> </a>
<a name="ln419">// Returns true if the square at (x,y) is okay to travel over. If ignore_hostile</a>
<a name="ln420">// is true, returns true even for dungeon features the character can normally</a>
<a name="ln421">// not cross safely (deep water, lava, traps).</a>
<a name="ln422">static bool _is_travelsafe_square(const coord_def&amp; c, bool ignore_hostile,</a>
<a name="ln423">                                  bool ignore_danger, bool try_fallback)</a>
<a name="ln424">{</a>
<a name="ln425">    if (!in_bounds(c))</a>
<a name="ln426">        return false;</a>
<a name="ln427"> </a>
<a name="ln428">    if (_travel_safe_grid)</a>
<a name="ln429">    {</a>
<a name="ln430">        const cell_travel_safety &amp;cell((*_travel_safe_grid)(c));</a>
<a name="ln431">        return ignore_hostile? cell.safe_if_ignoring_hostile_terrain</a>
<a name="ln432">               : cell.safe;</a>
<a name="ln433">    }</a>
<a name="ln434"> </a>
<a name="ln435">    if (!env.map_knowledge(c).known())</a>
<a name="ln436">        return false;</a>
<a name="ln437"> </a>
<a name="ln438">    const dungeon_feature_type grid = env.map_knowledge(c).feat();</a>
<a name="ln439"> </a>
<a name="ln440">    // Only try pathing through temporary obstructions we remember, not</a>
<a name="ln441">    // those we can actually see (since the latter are clearly still blockers)</a>
<a name="ln442">    try_fallback = try_fallback</a>
<a name="ln443">                    &amp;&amp; (!you.see_cell(c) || feat_is_runed(grid));</a>
<a name="ln444"> </a>
<a name="ln445">    // Also make note of what's displayed on the level map for</a>
<a name="ln446">    // plant/fungus checks.</a>
<a name="ln447">    const map_cell&amp; levelmap_cell = env.map_knowledge(c);</a>
<a name="ln448"> </a>
<a name="ln449">    // Travel will not voluntarily cross squares blocked by immobile</a>
<a name="ln450">    // monsters.</a>
<a name="ln451">    if (!ignore_danger &amp;&amp; !ignore_hostile)</a>
<a name="ln452">    {</a>
<a name="ln453">        const monster_info *minfo = levelmap_cell.monsterinfo();</a>
<a name="ln454">        if (minfo &amp;&amp; _monster_blocks_travel(minfo))</a>
<a name="ln455">            return false;</a>
<a name="ln456">    }</a>
<a name="ln457"> </a>
<a name="ln458">    // If 'ignore_hostile' is true, we're ignoring hazards that can be</a>
<a name="ln459">    // navigated over if the player is willing to take damage or fly.</a>
<a name="ln460">    if (ignore_hostile &amp;&amp; _is_reseedable(c, true))</a>
<a name="ln461">        return true;</a>
<a name="ln462"> </a>
<a name="ln463">    // Excluded squares are only safe if marking stairs, i.e. another level.</a>
<a name="ln464">    if (!ignore_danger &amp;&amp; is_excluded(c) &amp;&amp; !is_stair_exclusion(c))</a>
<a name="ln465">        return false;</a>
<a name="ln466"> </a>
<a name="ln467">    if (g_Slime_Wall_Check &amp;&amp; slime_wall_neighbour(c)</a>
<a name="ln468">        &amp;&amp; !actor_slime_wall_immune(&amp;you))</a>
<a name="ln469">    {</a>
<a name="ln470">        return false;</a>
<a name="ln471">    }</a>
<a name="ln472"> </a>
<a name="ln473">    if (!_is_safe_cloud(c) &amp;&amp; !try_fallback)</a>
<a name="ln474">        return false;</a>
<a name="ln475"> </a>
<a name="ln476">    if (is_trap(c))</a>
<a name="ln477">    {</a>
<a name="ln478">        trap_def trap;</a>
<a name="ln479">        trap.pos = c;</a>
<a name="ln480">        trap.type = env.map_knowledge(c).trap();</a>
<a name="ln481">        trap.ammo_qty = 1;</a>
<a name="ln482">        if (trap.is_safe())</a>
<a name="ln483">            return true;</a>
<a name="ln484">    }</a>
<a name="ln485"> </a>
<a name="ln486">    if (feat_is_runed(levelmap_cell.feat()) &amp;&amp; !try_fallback)</a>
<a name="ln487">        return false;</a>
<a name="ln488"> </a>
<a name="ln489">    return feat_is_traversable_now(grid, try_fallback);</a>
<a name="ln490">}</a>
<a name="ln491"> </a>
<a name="ln492">// Returns true if the location at (x,y) is monster-free and contains</a>
<a name="ln493">// no clouds. Travel uses this to check if the square the player is</a>
<a name="ln494">// about to move to is safe.</a>
<a name="ln495">static bool _is_safe_move(const coord_def&amp; c)</a>
<a name="ln496">{</a>
<a name="ln497">    if (const monster* mon = monster_at(c))</a>
<a name="ln498">    {</a>
<a name="ln499">        // Stop before wasting energy on plants and fungi,</a>
<a name="ln500">        // unless worshipping Fedhas.</a>
<a name="ln501">        if (you.can_see(*mon)</a>
<a name="ln502">            &amp;&amp; mons_class_is_firewood(mon-&gt;type)</a>
<a name="ln503">            &amp;&amp; !fedhas_passthrough(mon))</a>
<a name="ln504">        {</a>
<a name="ln505">            return false;</a>
<a name="ln506">        }</a>
<a name="ln507"> </a>
<a name="ln508">        // If this is any *other* monster, it'll be visible and</a>
<a name="ln509">        // a) Friendly, in which case we'll displace it, no problem.</a>
<a name="ln510">        // b) Unfriendly, in which case we're in deep trouble, since travel</a>
<a name="ln511">        //    should have been aborted already by the checks in view.cc.</a>
<a name="ln512">    }</a>
<a name="ln513"> </a>
<a name="ln514">    if (is_trap(c) &amp;&amp; !trap_at(c)-&gt;is_safe())</a>
<a name="ln515">        return false;</a>
<a name="ln516"> </a>
<a name="ln517">    return _is_safe_cloud(c);</a>
<a name="ln518">}</a>
<a name="ln519"> </a>
<a name="ln520">void travel_init_load_level()</a>
<a name="ln521">{</a>
<a name="ln522">    curr_excludes.clear();</a>
<a name="ln523">    travel_cache.set_level_excludes();</a>
<a name="ln524">    travel_cache.update_waypoints();</a>
<a name="ln525">}</a>
<a name="ln526"> </a>
<a name="ln527">// This is called after the player changes level.</a>
<a name="ln528">void travel_init_new_level()</a>
<a name="ln529">{</a>
<a name="ln530">    // Clear run details, but preserve the runmode, because we might be in</a>
<a name="ln531">    // the middle of interlevel travel.</a>
<a name="ln532">    int runmode = you.running;</a>
<a name="ln533">    you.running.clear();</a>
<a name="ln534">    you.running = runmode;</a>
<a name="ln535"> </a>
<a name="ln536">    travel_init_load_level();</a>
<a name="ln537"> </a>
<a name="ln538">    explore_stopped_pos.reset();</a>
<a name="ln539">}</a>
<a name="ln540"> </a>
<a name="ln541">// Given a dungeon feature description, returns the feature number. This is a</a>
<a name="ln542">// crude hack and currently recognises only (deep/shallow) water. (XXX)</a>
<a name="ln543">//</a>
<a name="ln544">// Returns -1 if the feature named is not recognised, else returns the feature</a>
<a name="ln545">// number (guaranteed to be 0-255).</a>
<a name="ln546">static int _get_feature_type(const string &amp;feature)</a>
<a name="ln547">{</a>
<a name="ln548">    if (feature.find(&quot;deep water&quot;) != string::npos)</a>
<a name="ln549">        return DNGN_DEEP_WATER;</a>
<a name="ln550">    if (feature.find(&quot;shallow water&quot;) != string::npos)</a>
<a name="ln551">        return DNGN_SHALLOW_WATER;</a>
<a name="ln552">    return -1;</a>
<a name="ln553">}</a>
<a name="ln554"> </a>
<a name="ln555">// Given a feature description, prevents travel to locations of that feature</a>
<a name="ln556">// type.</a>
<a name="ln557">void prevent_travel_to(const string &amp;feature)</a>
<a name="ln558">{</a>
<a name="ln559">    int feature_type = _get_feature_type(feature);</a>
<a name="ln560">    if (feature_type != -1)</a>
<a name="ln561">        forbidden_terrain[feature_type] = 1;</a>
<a name="ln562">}</a>
<a name="ln563"> </a>
<a name="ln564">static bool _is_branch_stair(const coord_def&amp; pos)</a>
<a name="ln565">{</a>
<a name="ln566">    const level_id curr = level_id::current();</a>
<a name="ln567">    const level_id next = level_id::get_next_level_id(pos);</a>
<a name="ln568"> </a>
<a name="ln569">    return next.branch != curr.branch;</a>
<a name="ln570">}</a>
<a name="ln571"> </a>
<a name="ln572">#define ES_item   (Options.explore_stop &amp; ES_ITEM)</a>
<a name="ln573">#define ES_greedy (Options.explore_stop &amp; ES_GREEDY_ITEM)</a>
<a name="ln574">#define ES_glow   (Options.explore_stop &amp; ES_GLOWING_ITEM)</a>
<a name="ln575">#define ES_art    (Options.explore_stop &amp; ES_ARTEFACT)</a>
<a name="ln576">#define ES_rune   (Options.explore_stop &amp; ES_RUNE)</a>
<a name="ln577">#define ES_shop   (Options.explore_stop &amp; ES_SHOP)</a>
<a name="ln578">#define ES_stair  (Options.explore_stop &amp; ES_STAIR)</a>
<a name="ln579">#define ES_transporter (Options.explore_stop &amp; ES_TRANSPORTER)</a>
<a name="ln580">#define ES_altar  (Options.explore_stop &amp; ES_ALTAR)</a>
<a name="ln581">#define ES_portal (Options.explore_stop &amp; ES_PORTAL)</a>
<a name="ln582">#define ES_branch (Options.explore_stop &amp; ES_BRANCH)</a>
<a name="ln583">#define ES_rdoor  (Options.explore_stop &amp; ES_RUNED_DOOR)</a>
<a name="ln584">#define ES_stack  (Options.explore_stop &amp; ES_GREEDY_VISITED_ITEM_STACK)</a>
<a name="ln585"> </a>
<a name="ln586">// Adds interesting stuff on the point p to explore_discoveries.</a>
<a name="ln587">static inline void _check_interesting_square(const coord_def pos,</a>
<a name="ln588">                                             explore_discoveries &amp;ed)</a>
<a name="ln589">{</a>
<a name="ln590">    if ((ES_item || ES_greedy || ES_glow || ES_art || ES_rune)</a>
<a name="ln591">        &amp;&amp; you.visible_igrd(pos) != NON_ITEM)</a>
<a name="ln592">    {</a>
<a name="ln593">        ed.found_item(pos, mitm[ you.visible_igrd(pos) ]);</a>
<a name="ln594">    }</a>
<a name="ln595"> </a>
<a name="ln596">    ed.found_feature(pos, grd(pos));</a>
<a name="ln597">}</a>
<a name="ln598"> </a>
<a name="ln599">static void _userdef_run_stoprunning_hook()</a>
<a name="ln600">{</a>
<a name="ln601">#ifdef CLUA_BINDINGS</a>
<a name="ln602">    if (you.running)</a>
<a name="ln603">        clua.callfn(&quot;ch_stop_running&quot;, &quot;s&quot;, _run_mode_name(you.running));</a>
<a name="ln604">#else</a>
<a name="ln605">    UNUSED(_run_mode_name);</a>
<a name="ln606">#endif</a>
<a name="ln607">}</a>
<a name="ln608"> </a>
<a name="ln609">static void _userdef_run_startrunning_hook()</a>
<a name="ln610">{</a>
<a name="ln611">#ifdef CLUA_BINDINGS</a>
<a name="ln612">    if (you.running)</a>
<a name="ln613">        clua.callfn(&quot;ch_start_running&quot;, &quot;s&quot;, _run_mode_name(you.running));</a>
<a name="ln614">#endif</a>
<a name="ln615">}</a>
<a name="ln616"> </a>
<a name="ln617">bool is_resting()</a>
<a name="ln618">{</a>
<a name="ln619">    return you.running.is_rest();</a>
<a name="ln620">}</a>
<a name="ln621"> </a>
<a name="ln622">static int _slowest_ally_speed()</a>
<a name="ln623">{</a>
<a name="ln624">    vector&lt;monster* &gt; followers = get_on_level_followers();</a>
<a name="ln625">    int min_speed = INT_MAX;</a>
<a name="ln626">    for (auto fol : followers)</a>
<a name="ln627">    {</a>
<a name="ln628">        int speed = fol-&gt;speed * BASELINE_DELAY</a>
<a name="ln629">                    / fol-&gt;action_energy(EUT_MOVE);</a>
<a name="ln630">        if (speed &lt; min_speed)</a>
<a name="ln631">            min_speed = speed;</a>
<a name="ln632">    }</a>
<a name="ln633">    return min_speed;</a>
<a name="ln634">}</a>
<a name="ln635"> </a>
<a name="ln636">static void _start_running()</a>
<a name="ln637">{</a>
<a name="ln638">    _userdef_run_startrunning_hook();</a>
<a name="ln639">    you.running.init_travel_speed();</a>
<a name="ln640"> </a>
<a name="ln641">    if (you.running &lt; 0)</a>
<a name="ln642">        start_delay&lt;TravelDelay&gt;();</a>
<a name="ln643">}</a>
<a name="ln644"> </a>
<a name="ln645">// Stops shift+running and all forms of travel.</a>
<a name="ln646">void stop_running(bool clear_delays)</a>
<a name="ln647">{</a>
<a name="ln648">    you.running.stop(clear_delays);</a>
<a name="ln649">}</a>
<a name="ln650"> </a>
<a name="ln651">static bool _is_valid_explore_target(const coord_def&amp; where)</a>
<a name="ln652">{</a>
<a name="ln653">    // If a square in LOS is unmapped, it's valid.</a>
<a name="ln654">    for (radius_iterator ri(where, LOS_DEFAULT, true); ri; ++ri)</a>
<a name="ln655">        if (!env.map_knowledge(*ri).seen())</a>
<a name="ln656">            return true;</a>
<a name="ln657"> </a>
<a name="ln658">    if (you.running == RMODE_EXPLORE_GREEDY)</a>
<a name="ln659">    {</a>
<a name="ln660">        LevelStashes *lev = StashTrack.find_current_level();</a>
<a name="ln661">        return lev &amp;&amp; lev-&gt;needs_visit(where, can_autopickup());</a>
<a name="ln662">    }</a>
<a name="ln663"> </a>
<a name="ln664">    return false;</a>
<a name="ln665">}</a>
<a name="ln666"> </a>
<a name="ln667">enum explore_status_type</a>
<a name="ln668">{</a>
<a name="ln669">    EST_FULLY_EXPLORED    = 0,</a>
<a name="ln670"> </a>
<a name="ln671">    // Could not explore because of hostile terrain</a>
<a name="ln672">    EST_PARTLY_EXPLORED   = 1,</a>
<a name="ln673"> </a>
<a name="ln674">    // Could not pick up interesting items because of hostile terrain. Note</a>
<a name="ln675">    // that this and EST_PARTLY_EXPLORED are not mutually exclusive.</a>
<a name="ln676">    EST_GREED_UNFULFILLED = 2,</a>
<a name="ln677">};</a>
<a name="ln678"> </a>
<a name="ln679">static bool _level_has_unknown_transporters()</a>
<a name="ln680">{</a>
<a name="ln681">    LevelInfo *li = travel_cache.find_level_info(level_id::current());</a>
<a name="ln682">    ASSERT(li);</a>
<a name="ln683"> </a>
<a name="ln684">    vector&lt;transporter_info&gt; transporters = li-&gt;get_transporters();</a>
<a name="ln685">    for (auto ti : transporters)</a>
<a name="ln686">    {</a>
<a name="ln687">        if (ti.destination.origin())</a>
<a name="ln688">            return true;</a>
<a name="ln689">    }</a>
<a name="ln690">    return false;</a>
<a name="ln691">}</a>
<a name="ln692"> </a>
<a name="ln693">// Determines if the level is fully explored.</a>
<a name="ln694">static int _find_explore_status(const travel_pathfind &amp;tp)</a>
<a name="ln695">{</a>
<a name="ln696">    int explore_status = 0;</a>
<a name="ln697"> </a>
<a name="ln698">    const coord_def greed = tp.greedy_square();</a>
<a name="ln699">    if (greed.x || greed.y)</a>
<a name="ln700">        explore_status |= EST_GREED_UNFULFILLED;</a>
<a name="ln701"> </a>
<a name="ln702">    const coord_def unexplored = tp.unexplored_square();</a>
<a name="ln703">    if (unexplored.x || unexplored.y || !tp.get_unreachables().empty())</a>
<a name="ln704">        explore_status |= EST_PARTLY_EXPLORED;</a>
<a name="ln705"> </a>
<a name="ln706">    return explore_status;</a>
<a name="ln707">}</a>
<a name="ln708"> </a>
<a name="ln709">static void _set_target_square(const coord_def &amp;target)</a>
<a name="ln710">{</a>
<a name="ln711">    you.running.pos = target;</a>
<a name="ln712">}</a>
<a name="ln713"> </a>
<a name="ln714">static void _explore_find_target_square()</a>
<a name="ln715">{</a>
<a name="ln716">    bool runed_door_pause = false;</a>
<a name="ln717"> </a>
<a name="ln718">    travel_pathfind tp;</a>
<a name="ln719">    tp.set_floodseed(you.pos(), true);</a>
<a name="ln720"> </a>
<a name="ln721">    coord_def whereto =</a>
<a name="ln722">        tp.pathfind(static_cast&lt;run_mode_type&gt;(you.running.runmode));</a>
<a name="ln723"> </a>
<a name="ln724">    // If we didn't find an explore target the first time, try fallback mode</a>
<a name="ln725">    if (!whereto.x &amp;&amp; !whereto.y)</a>
<a name="ln726">    {</a>
<a name="ln727">        travel_pathfind fallback_tp;</a>
<a name="ln728">        fallback_tp.set_floodseed(you.pos(), true);</a>
<a name="ln729">        whereto = fallback_tp.pathfind(static_cast&lt;run_mode_type&gt;(you.running.runmode), true);</a>
<a name="ln730"> </a>
<a name="ln731">        if (whereto.distance_from(you.pos()) == 1 &amp;&amp; cell_is_runed(whereto))</a>
<a name="ln732">        {</a>
<a name="ln733">            runed_door_pause = true;</a>
<a name="ln734">            whereto.reset();</a>
<a name="ln735">        }</a>
<a name="ln736">    }</a>
<a name="ln737"> </a>
<a name="ln738">    if (whereto.x || whereto.y)</a>
<a name="ln739">    {</a>
<a name="ln740">        // Make sure this is a square that is reachable, since we asked</a>
<a name="ln741">        // travel_pathfind to give us even unreachable squares. The</a>
<a name="ln742">        // player's starting position may in some cases not have its</a>
<a name="ln743">        // travel_point_distance set, but we know it's reachable, since</a>
<a name="ln744">        // we're there.</a>
<a name="ln745">        if (travel_point_distance[whereto.x][whereto.y] &lt;= 0</a>
<a name="ln746">            &amp;&amp; whereto != you.pos())</a>
<a name="ln747">        {</a>
<a name="ln748">            whereto.reset();</a>
<a name="ln749">        }</a>
<a name="ln750">    }</a>
<a name="ln751"> </a>
<a name="ln752">    if (whereto.x || whereto.y)</a>
<a name="ln753">    {</a>
<a name="ln754">        _set_target_square(whereto);</a>
<a name="ln755">        return;</a>
<a name="ln756">    }</a>
<a name="ln757">    else</a>
<a name="ln758">    {</a>
<a name="ln759">        // No place to go? Report to the player.</a>
<a name="ln760">        const int estatus = _find_explore_status(tp);</a>
<a name="ln761">        const bool unknown_trans = _level_has_unknown_transporters();</a>
<a name="ln762">        if (!estatus &amp;&amp; !unknown_trans)</a>
<a name="ln763">        {</a>
<a name="ln764">            mpr(&quot;Done exploring.&quot;);</a>
<a name="ln765">            learned_something_new(HINT_DONE_EXPLORE);</a>
<a name="ln766">        }</a>
<a name="ln767">        else</a>
<a name="ln768">        {</a>
<a name="ln769">            vector&lt;const char *&gt; reasons;</a>
<a name="ln770">            vector&lt;const char *&gt; inacc;</a>
<a name="ln771">            string inacc_desc = &quot;&quot;;</a>
<a name="ln772"> </a>
<a name="ln773">            if (runed_door_pause)</a>
<a name="ln774">                reasons.push_back(&quot;unopened runed door&quot;);</a>
<a name="ln775"> </a>
<a name="ln776">            if (unknown_trans)</a>
<a name="ln777">                reasons.push_back(&quot;unvisited transporter&quot;);</a>
<a name="ln778"> </a>
<a name="ln779">            if (estatus &amp; EST_GREED_UNFULFILLED)</a>
<a name="ln780">                inacc.push_back(&quot;items&quot;);</a>
<a name="ln781">            // A runed door already implies an unexplored place.</a>
<a name="ln782">            if (!runed_door_pause &amp;&amp; estatus &amp; EST_PARTLY_EXPLORED)</a>
<a name="ln783">                inacc.push_back(&quot;places&quot;);</a>
<a name="ln784"> </a>
<a name="ln785">            if (!inacc.empty())</a>
<a name="ln786">            {</a>
<a name="ln787">                inacc_desc = make_stringf(&quot;can't reach some %s&quot;,</a>
<a name="ln788">                                 comma_separated_line(inacc.begin(),</a>
<a name="ln789">                                                      inacc.end()).c_str());</a>
<a name="ln790">                reasons.push_back(inacc_desc.c_str());</a>
<a name="ln791">            }</a>
<a name="ln792">            mprf(&quot;Partly explored, %s.&quot;,</a>
<a name="ln793">                 comma_separated_line(reasons.begin(), reasons.end()).c_str());</a>
<a name="ln794">        }</a>
<a name="ln795">        stop_running();</a>
<a name="ln796">    }</a>
<a name="ln797">}</a>
<a name="ln798"> </a>
<a name="ln799">void explore_pickup_event(int did_pickup, int tried_pickup)</a>
<a name="ln800">{</a>
<a name="ln801">    if (!did_pickup &amp;&amp; !tried_pickup)</a>
<a name="ln802">        return;</a>
<a name="ln803"> </a>
<a name="ln804">    if (!you.running.is_explore())</a>
<a name="ln805">        return;</a>
<a name="ln806"> </a>
<a name="ln807">    if (did_pickup)</a>
<a name="ln808">    {</a>
<a name="ln809">        const int estop =</a>
<a name="ln810">            (you.running == RMODE_EXPLORE_GREEDY) ? ES_GREEDY_PICKUP_MASK</a>
<a name="ln811">                                                  : ES_NONE;</a>
<a name="ln812"> </a>
<a name="ln813">        if (Options.explore_stop &amp; estop)</a>
<a name="ln814">            stop_delay();</a>
<a name="ln815">    }</a>
<a name="ln816"> </a>
<a name="ln817">    // Greedy explore has no good way to deal with an item that we can't</a>
<a name="ln818">    // pick up, so the only thing to do is to stop.</a>
<a name="ln819">    if (tried_pickup &amp;&amp; you.running == RMODE_EXPLORE_GREEDY)</a>
<a name="ln820">    {</a>
<a name="ln821">        if (explore_stopped_pos == you.pos())</a>
<a name="ln822">        {</a>
<a name="ln823">            const string prompt =</a>
<a name="ln824">                make_stringf(&quot;Could not pick up %s here; shall I ignore %s?&quot;,</a>
<a name="ln825">                             tried_pickup == 1? &quot;an item&quot; : &quot;some items&quot;,</a>
<a name="ln826">                             tried_pickup == 1? &quot;it&quot; : &quot;them&quot;);</a>
<a name="ln827"> </a>
<a name="ln828">            // Make Escape =&gt; 'n' and stop run.</a>
<a name="ln829">            explicit_keymap map;</a>
<a name="ln830">            map[ESCAPE] = 'n';</a>
<a name="ln831">            map[CONTROL('G')] = 'n';</a>
<a name="ln832">            if (yesno(prompt.c_str(), true, 'y', true, false, false, &amp;map))</a>
<a name="ln833">            {</a>
<a name="ln834">                mark_items_non_pickup_at(you.pos());</a>
<a name="ln835">                // Don't stop explore.</a>
<a name="ln836">                return;</a>
<a name="ln837">            }</a>
<a name="ln838">            canned_msg(MSG_OK);</a>
<a name="ln839">        }</a>
<a name="ln840">        explore_stopped_pos = you.pos();</a>
<a name="ln841">        stop_delay();</a>
<a name="ln842">    }</a>
<a name="ln843">}</a>
<a name="ln844"> </a>
<a name="ln845">// Determine the necessary command when find_travel_pos() indicates that we</a>
<a name="ln846">// shouldn't move.</a>
<a name="ln847">static command_type _get_non_move_command()</a>
<a name="ln848">{</a>
<a name="ln849">    // Did we fail to get where we were going?</a>
<a name="ln850">    const bool fell_short = you.pos() != you.running.pos;</a>
<a name="ln851"> </a>
<a name="ln852">    if (you.running == RMODE_EXPLORE)</a>
<a name="ln853">        return CMD_NO_CMD;</a>
<a name="ln854"> </a>
<a name="ln855">    // Stop exploring if we fell short of our target (because of a runed</a>
<a name="ln856">    // door), but inspect the floor otherwise (because of an item that</a>
<a name="ln857">    // could not be picked up).</a>
<a name="ln858">    if (you.running == RMODE_EXPLORE_GREEDY)</a>
<a name="ln859">        return fell_short ? CMD_NO_CMD : CMD_INSPECT_FLOOR;</a>
<a name="ln860"> </a>
<a name="ln861">    const level_pos curr = level_pos(level_id::current(), you.pos());</a>
<a name="ln862"> </a>
<a name="ln863">    // We've reached our travel destination.</a>
<a name="ln864">    if (level_target == curr)</a>
<a name="ln865">        return CMD_NO_CMD;</a>
<a name="ln866"> </a>
<a name="ln867">    // If we we're not at our running position and we're not travelled to a</a>
<a name="ln868">    // transporter, simply stop running.</a>
<a name="ln869">    if (fell_short &amp;&amp; grd(you.pos()) != DNGN_TRANSPORTER)</a>
<a name="ln870">        return CMD_NO_CMD;</a>
<a name="ln871"> </a>
<a name="ln872">    // We're trying to take the same stairs again, abort.</a>
<a name="ln873">    if (last_stair == curr)</a>
<a name="ln874">        return CMD_NO_CMD;</a>
<a name="ln875"> </a>
<a name="ln876">    // Save the previous stair taken, so we can check that we're not trying to</a>
<a name="ln877">    // retake them after this command.</a>
<a name="ln878">    last_stair.id = level_id::current();</a>
<a name="ln879">    last_stair.pos = you.pos();</a>
<a name="ln880"> </a>
<a name="ln881">    return feat_stair_direction(grd(you.pos()));</a>
<a name="ln882">}</a>
<a name="ln883"> </a>
<a name="ln884">// Top-level travel control (called from input() in main.cc).</a>
<a name="ln885">//</a>
<a name="ln886">// travel() is responsible for making the individual moves that constitute</a>
<a name="ln887">// (interlevel) travel and explore and deciding when travel and explore</a>
<a name="ln888">// end.</a>
<a name="ln889">//</a>
<a name="ln890">// Don't call travel() if you.running &gt;= 0.</a>
<a name="ln891">command_type travel()</a>
<a name="ln892">{</a>
<a name="ln893">    int holdx, holdy;</a>
<a name="ln894">    int *move_x = &amp;holdx;</a>
<a name="ln895">    int *move_y = &amp;holdy;</a>
<a name="ln896">    holdx = holdy = 0;</a>
<a name="ln897"> </a>
<a name="ln898">    command_type result = CMD_NO_CMD;</a>
<a name="ln899"> </a>
<a name="ln900">    if (Options.travel_key_stop &amp;&amp; kbhit())</a>
<a name="ln901">    {</a>
<a name="ln902">        mprf(&quot;Key pressed, stopping %s.&quot;, you.running.runmode_name().c_str());</a>
<a name="ln903">        stop_running();</a>
<a name="ln904">        return CMD_NO_CMD;</a>
<a name="ln905">    }</a>
<a name="ln906"> </a>
<a name="ln907">    if (you.confused())</a>
<a name="ln908">    {</a>
<a name="ln909">        mprf(&quot;You're confused, stopping %s.&quot;,</a>
<a name="ln910">             you.running.runmode_name().c_str());</a>
<a name="ln911">        stop_running();</a>
<a name="ln912">        return CMD_NO_CMD;</a>
<a name="ln913">    }</a>
<a name="ln914"> </a>
<a name="ln915">    // Excluded squares are only safe if marking stairs, i.e. another level.</a>
<a name="ln916">    if (is_excluded(you.pos()) &amp;&amp; !is_stair_exclusion(you.pos()))</a>
<a name="ln917">    {</a>
<a name="ln918">        mprf(&quot;You're in a travel-excluded area, stopping %s.&quot;,</a>
<a name="ln919">             you.running.runmode_name().c_str());</a>
<a name="ln920">        stop_running();</a>
<a name="ln921">        return CMD_NO_CMD;</a>
<a name="ln922">    }</a>
<a name="ln923"> </a>
<a name="ln924">    if (you.running.is_explore())</a>
<a name="ln925">    {</a>
<a name="ln926">        if (Options.explore_auto_rest &amp;&amp; !you.is_sufficiently_rested())</a>
<a name="ln927">            return CMD_WAIT;</a>
<a name="ln928"> </a>
<a name="ln929">        // Exploring.</a>
<a name="ln930">        if (grd(you.pos()) == DNGN_ENTER_SHOP</a>
<a name="ln931">            &amp;&amp; you.running == RMODE_EXPLORE_GREEDY)</a>
<a name="ln932">        {</a>
<a name="ln933">            LevelStashes *lev = StashTrack.find_current_level();</a>
<a name="ln934">            if (lev &amp;&amp; lev-&gt;shop_needs_visit(you.pos()))</a>
<a name="ln935">            {</a>
<a name="ln936">                you.running = 0;</a>
<a name="ln937">                return CMD_GO_UPSTAIRS;</a>
<a name="ln938">            }</a>
<a name="ln939">        }</a>
<a name="ln940"> </a>
<a name="ln941">        // Speed up explore by not doing a double-floodfill if we have</a>
<a name="ln942">        // a valid target.</a>
<a name="ln943">        if (!you.running.pos.x</a>
<a name="ln944">            || you.running.pos == you.pos()</a>
<a name="ln945">            || !_is_valid_explore_target(you.running.pos))</a>
<a name="ln946">        {</a>
<a name="ln947">            _explore_find_target_square();</a>
<a name="ln948">        }</a>
<a name="ln949">    }</a>
<a name="ln950"> </a>
<a name="ln951">    // Interlevel travel. Since you.running.x is zero, we've either just</a>
<a name="ln952">    // initiated travel, or we've just climbed or descended a staircase, and we</a>
<a name="ln953">    // need to figure out where to travel to next.</a>
<a name="ln954">    if (you.running == RMODE_INTERLEVEL &amp;&amp; !you.running.pos.x)</a>
<a name="ln955">    {</a>
<a name="ln956">#ifdef DEBUG_TRAVEL</a>
<a name="ln957">        dprf(&quot;continuing translevel travel, branch %d depth %d, pos %d,%d&quot;,</a>
<a name="ln958">            level_target.id.branch, level_target.id.depth, level_target.pos.x,</a>
<a name="ln959">            level_target.pos.y);</a>
<a name="ln960">#endif</a>
<a name="ln961"> </a>
<a name="ln962">        if (!_find_transtravel_square(level_target) || !you.running.pos.x)</a>
<a name="ln963">            stop_running();</a>
<a name="ln964">        else</a>
<a name="ln965">            you.running.init_travel_speed();</a>
<a name="ln966">    }</a>
<a name="ln967"> </a>
<a name="ln968">    if (you.running &lt; 0)</a>
<a name="ln969">    {</a>
<a name="ln970">        // Remember what run-mode we were in so that we can resume</a>
<a name="ln971">        // explore/interlevel travel correctly.</a>
<a name="ln972">        int runmode = you.running;</a>
<a name="ln973"> </a>
<a name="ln974">        // Get the next step to make. If the travel command can't find a route,</a>
<a name="ln975">        // we turn off travel (find_travel_pos does that automatically).</a>
<a name="ln976">        find_travel_pos(you.pos(), move_x, move_y);</a>
<a name="ln977"> </a>
<a name="ln978">        // Stop greedy explore when visiting an unverified stash.</a>
<a name="ln979">        if ((*move_x || *move_y)</a>
<a name="ln980">            &amp;&amp; you.running == RMODE_EXPLORE_GREEDY</a>
<a name="ln981">            &amp;&amp; ES_stack)</a>
<a name="ln982">        {</a>
<a name="ln983">            const coord_def newpos = you.pos() + coord_def(*move_x, *move_y);</a>
<a name="ln984">            if (newpos == you.running.pos)</a>
<a name="ln985">            {</a>
<a name="ln986">                const LevelStashes *lev = StashTrack.find_current_level();</a>
<a name="ln987">                if (lev &amp;&amp; lev-&gt;needs_stop(newpos))</a>
<a name="ln988">                {</a>
<a name="ln989">                    explore_stopped_pos = newpos;</a>
<a name="ln990">                    stop_running();</a>
<a name="ln991">                    return direction_to_command(*move_x, *move_y);</a>
<a name="ln992">                }</a>
<a name="ln993">            }</a>
<a name="ln994">        }</a>
<a name="ln995"> </a>
<a name="ln996">        if (!*move_x &amp;&amp; !*move_y)</a>
<a name="ln997">        {</a>
<a name="ln998">            // Re-apply the runmode, which allows for continue exploration or</a>
<a name="ln999">            // proper triggering of lua hooks when running ceases. We don't</a>
<a name="ln1000">            // directly call stop_running() without restoring this because</a>
<a name="ln1001">            // you.running is probably 0, and stop_running() won't notify Lua</a>
<a name="ln1002">            // hooks if you.running == 0.</a>
<a name="ln1003">            you.running = runmode;</a>
<a name="ln1004"> </a>
<a name="ln1005">            result = _get_non_move_command();</a>
<a name="ln1006">            if (result == CMD_NO_CMD)</a>
<a name="ln1007">                stop_running();</a>
<a name="ln1008">            // If taking stairs, the running destination will no longer be</a>
<a name="ln1009">            // valid on the new level. Reset the running pos so travel will</a>
<a name="ln1010">            // search for a new travel square next turn.</a>
<a name="ln1011">            else if (you.running == RMODE_INTERLEVEL)</a>
<a name="ln1012">                you.running.pos.reset();</a>
<a name="ln1013"> </a>
<a name="ln1014">            return result;</a>
<a name="ln1015"> </a>
<a name="ln1016">        }</a>
<a name="ln1017">        else if (you.running.is_explore() &amp;&amp; Options.explore_delay &gt; -1)</a>
<a name="ln1018">            delay(Options.explore_delay);</a>
<a name="ln1019">        else if (Options.travel_delay &gt; 0)</a>
<a name="ln1020">            delay(Options.travel_delay);</a>
<a name="ln1021">    }</a>
<a name="ln1022"> </a>
<a name="ln1023">    if (!you.running)</a>
<a name="ln1024">        return CMD_NO_CMD;</a>
<a name="ln1025"> </a>
<a name="ln1026">    if (result != CMD_NO_CMD)</a>
<a name="ln1027">        return result; // TODO: apparently unreachable?</a>
<a name="ln1028"> </a>
<a name="ln1029">    return direction_to_command(*move_x, *move_y);</a>
<a name="ln1030">}</a>
<a name="ln1031"> </a>
<a name="ln1032">command_type direction_to_command(int x, int y)</a>
<a name="ln1033">{</a>
<a name="ln1034">    if (x == -1 &amp;&amp; y == -1) return CMD_MOVE_UP_LEFT;</a>
<a name="ln1035">    if (x == -1 &amp;&amp; y ==  0) return CMD_MOVE_LEFT;</a>
<a name="ln1036">    if (x == -1 &amp;&amp; y ==  1) return CMD_MOVE_DOWN_LEFT;</a>
<a name="ln1037">    if (x ==  0 &amp;&amp; y == -1) return CMD_MOVE_UP;</a>
<a name="ln1038">    if (x ==  0 &amp;&amp; y ==  1) return CMD_MOVE_DOWN;</a>
<a name="ln1039">    if (x ==  1 &amp;&amp; y == -1) return CMD_MOVE_UP_RIGHT;</a>
<a name="ln1040">    if (x ==  1 &amp;&amp; y ==  0) return CMD_MOVE_RIGHT;</a>
<a name="ln1041">    if (x ==  1 &amp;&amp; y ==  1) return CMD_MOVE_DOWN_RIGHT;</a>
<a name="ln1042"> </a>
<a name="ln1043">    ASSERT(0);</a>
<a name="ln1044">    return CMD_NO_CMD;</a>
<a name="ln1045">}</a>
<a name="ln1046"> </a>
<a name="ln1047">static void _fill_exclude_radius(const travel_exclude &amp;exc)</a>
<a name="ln1048">{</a>
<a name="ln1049">    const int radius = exc.radius;</a>
<a name="ln1050">    const coord_def &amp;c = exc.pos;</a>
<a name="ln1051">    for (int y = c.y - radius; y &lt;= c.y + radius; ++y)</a>
<a name="ln1052">        for (int x = c.x - radius; x &lt;= c.x + radius; ++x)</a>
<a name="ln1053">        {</a>
<a name="ln1054">            const coord_def p(x, y);</a>
<a name="ln1055">            if (!map_bounds(x, y) || travel_point_distance[x][y])</a>
<a name="ln1056">                continue;</a>
<a name="ln1057"> </a>
<a name="ln1058">            if (is_exclude_root(p))</a>
<a name="ln1059">                travel_point_distance[x][y] = PD_EXCLUDED;</a>
<a name="ln1060">            else if (is_excluded(p) &amp;&amp; env.map_knowledge(p).known())</a>
<a name="ln1061">                travel_point_distance[x][y] = PD_EXCLUDED_RADIUS;</a>
<a name="ln1062">        }</a>
<a name="ln1063">}</a>
<a name="ln1064"> </a>
<a name="ln1065">/////////////////////////////////////////////////////////////////////////////</a>
<a name="ln1066">// travel_pathfind</a>
<a name="ln1067"> </a>
<a name="ln1068">FixedVector&lt;coord_def, GXM * GYM&gt; travel_pathfind::circumference[2];</a>
<a name="ln1069"> </a>
<a name="ln1070">// already defined in header</a>
<a name="ln1071">// const int travel_pathfind::UNFOUND_DIST;</a>
<a name="ln1072">// const int travel_pathfind::INFINITE_DIST;</a>
<a name="ln1073"> </a>
<a name="ln1074">travel_pathfind::travel_pathfind()</a>
<a name="ln1075">    : runmode(RMODE_NOT_RUNNING), start(), dest(), next_travel_move(),</a>
<a name="ln1076">      floodout(false), double_flood(false), ignore_hostile(false),</a>
<a name="ln1077">      ignore_danger(false), annotate_map(false), ls(nullptr),</a>
<a name="ln1078">      need_for_greed(false), autopickup(false),</a>
<a name="ln1079">      unexplored_place(), greedy_place(), unexplored_dist(0), greedy_dist(0),</a>
<a name="ln1080">      refdist(nullptr), reseed_points(), features(nullptr), unreachables(),</a>
<a name="ln1081">      point_distance(travel_point_distance), points(0), next_iter_points(0),</a>
<a name="ln1082">      traveled_distance(0), circ_index(0)</a>
<a name="ln1083">{</a>
<a name="ln1084">}</a>
<a name="ln1085"> </a>
<a name="ln1086">travel_pathfind::~travel_pathfind()</a>
<a name="ln1087">{</a>
<a name="ln1088">}</a>
<a name="ln1089"> </a>
<a name="ln1090">static bool _is_greed_inducing_square(const LevelStashes *ls,</a>
<a name="ln1091">                                      const coord_def &amp;c, bool autopickup)</a>
<a name="ln1092">{</a>
<a name="ln1093">    return ls &amp;&amp; ls-&gt;needs_visit(c, autopickup);</a>
<a name="ln1094">}</a>
<a name="ln1095"> </a>
<a name="ln1096">bool travel_pathfind::is_greed_inducing_square(const coord_def &amp;c) const</a>
<a name="ln1097">{</a>
<a name="ln1098">    return _is_greed_inducing_square(ls, c, autopickup);</a>
<a name="ln1099">}</a>
<a name="ln1100"> </a>
<a name="ln1101">void travel_pathfind::set_src_dst(const coord_def &amp;src, const coord_def &amp;dst)</a>
<a name="ln1102">{</a>
<a name="ln1103">    // Yes, this is backwards - for travel, we always start from the destination</a>
<a name="ln1104">    // and search outwards for the starting position.</a>
<a name="ln1105">    start = dst;</a>
<a name="ln1106">    dest  = src;</a>
<a name="ln1107"> </a>
<a name="ln1108">    floodout = double_flood = false;</a>
<a name="ln1109">}</a>
<a name="ln1110"> </a>
<a name="ln1111">void travel_pathfind::set_floodseed(const coord_def &amp;seed, bool dblflood)</a>
<a name="ln1112">{</a>
<a name="ln1113">    start = seed;</a>
<a name="ln1114">    dest.reset();</a>
<a name="ln1115"> </a>
<a name="ln1116">    floodout = true;</a>
<a name="ln1117">    double_flood = dblflood;</a>
<a name="ln1118">}</a>
<a name="ln1119"> </a>
<a name="ln1120">void travel_pathfind::set_annotate_map(bool annotate)</a>
<a name="ln1121">{</a>
<a name="ln1122">    annotate_map = annotate;</a>
<a name="ln1123">}</a>
<a name="ln1124"> </a>
<a name="ln1125">void travel_pathfind::set_distance_grid(travel_distance_grid_t grid)</a>
<a name="ln1126">{</a>
<a name="ln1127">    point_distance = grid;</a>
<a name="ln1128">}</a>
<a name="ln1129"> </a>
<a name="ln1130">void travel_pathfind::set_feature_vector(vector&lt;coord_def&gt; *feats)</a>
<a name="ln1131">{</a>
<a name="ln1132">    features = feats;</a>
<a name="ln1133"> </a>
<a name="ln1134">    if (features)</a>
<a name="ln1135">    {</a>
<a name="ln1136">        double_flood = true;</a>
<a name="ln1137">        annotate_map = true;</a>
<a name="ln1138">    }</a>
<a name="ln1139">}</a>
<a name="ln1140"> </a>
<a name="ln1141">const coord_def travel_pathfind::travel_move() const</a>
<a name="ln1142">{</a>
<a name="ln1143">    return next_travel_move;</a>
<a name="ln1144">}</a>
<a name="ln1145"> </a>
<a name="ln1146">const coord_def travel_pathfind::explore_target() const</a>
<a name="ln1147">{</a>
<a name="ln1148">    if (unexplored_dist != UNFOUND_DIST &amp;&amp; greedy_dist != UNFOUND_DIST)</a>
<a name="ln1149">    {</a>
<a name="ln1150">        return unexplored_dist &lt; greedy_dist ? unexplored_place</a>
<a name="ln1151">                                             : greedy_place;</a>
<a name="ln1152">    }</a>
<a name="ln1153">    else if (unexplored_dist != UNFOUND_DIST)</a>
<a name="ln1154">        return unexplored_place;</a>
<a name="ln1155">    else if (greedy_dist != UNFOUND_DIST)</a>
<a name="ln1156">        return greedy_place;</a>
<a name="ln1157"> </a>
<a name="ln1158">    return coord_def(0, 0);</a>
<a name="ln1159">}</a>
<a name="ln1160"> </a>
<a name="ln1161">const coord_def travel_pathfind::greedy_square() const</a>
<a name="ln1162">{</a>
<a name="ln1163">    return greedy_place;</a>
<a name="ln1164">}</a>
<a name="ln1165"> </a>
<a name="ln1166">const coord_def travel_pathfind::unexplored_square() const</a>
<a name="ln1167">{</a>
<a name="ln1168">    return unexplored_place;</a>
<a name="ln1169">}</a>
<a name="ln1170"> </a>
<a name="ln1171">// The travel algorithm is based on the NetHack travel code written by Warwick</a>
<a name="ln1172">// Allison - used with his permission.</a>
<a name="ln1173">coord_def travel_pathfind::pathfind(run_mode_type rmode, bool fallback_explore)</a>
<a name="ln1174">{</a>
<a name="ln1175">    unwind_bool saved_ipt(ignore_player_traversability);</a>
<a name="ln1176"> </a>
<a name="ln1177">    if (rmode == RMODE_INTERLEVEL)</a>
<a name="ln1178">        rmode = RMODE_TRAVEL;</a>
<a name="ln1179"> </a>
<a name="ln1180">    runmode = rmode;</a>
<a name="ln1181"> </a>
<a name="ln1182">    try_fallback = fallback_explore;</a>
<a name="ln1183"> </a>
<a name="ln1184">    if (runmode == RMODE_CONNECTIVITY)</a>
<a name="ln1185">        ignore_player_traversability = true;</a>
<a name="ln1186">    else</a>
<a name="ln1187">    {</a>
<a name="ln1188">        ASSERTM(crawl_state.need_save,</a>
<a name="ln1189">                &quot;Pathfind with mode %d without a game?&quot;, runmode);</a>
<a name="ln1190"> </a>
<a name="ln1191">        if (runmode == RMODE_EXPLORE_GREEDY)</a>
<a name="ln1192">        {</a>
<a name="ln1193">            autopickup = can_autopickup();</a>
<a name="ln1194">            need_for_greed = autopickup;</a>
<a name="ln1195">        }</a>
<a name="ln1196">    }</a>
<a name="ln1197"> </a>
<a name="ln1198">    if (!ls &amp;&amp; (annotate_map || need_for_greed))</a>
<a name="ln1199">        ls = StashTrack.find_current_level();</a>
<a name="ln1200"> </a>
<a name="ln1201">    next_travel_move.reset();</a>
<a name="ln1202"> </a>
<a name="ln1203">    // For greedy explore, keep track of the closest unexplored territory and</a>
<a name="ln1204">    // the closest greedy square. Exploring to the nearest (unexplored / greedy)</a>
<a name="ln1205">    // square is easier, but it produces unintuitive explore behaviour where</a>
<a name="ln1206">    // grabbing items is not favoured over simple exploring.</a>
<a name="ln1207">    //</a>
<a name="ln1208">    // Greedy explore instead uses the explore_item_greed option to weight</a>
<a name="ln1209">    // greedy explore towards grabbing items over exploring. An</a>
<a name="ln1210">    // explore_item_greed set to 10, for instance, forces explore to prefer</a>
<a name="ln1211">    // items that are less than 10 squares farther away from the player than the</a>
<a name="ln1212">    // nearest unmapped square. Negative explore_item_greed values force greedy</a>
<a name="ln1213">    // explore to favour unexplored territory over picking up items. For the</a>
<a name="ln1214">    // most natural greedy explore behaviour, explore_item_greed should be set</a>
<a name="ln1215">    // to 10 or more.</a>
<a name="ln1216">    //</a>
<a name="ln1217">    unexplored_place = greedy_place = coord_def(0, 0);</a>
<a name="ln1218">    unexplored_dist  = greedy_dist  = UNFOUND_DIST;</a>
<a name="ln1219"> </a>
<a name="ln1220">    refdist = (runmode == RMODE_CONNECTIVITY || Options.explore_item_greed &gt; 0)</a>
<a name="ln1221">                ? &amp;unexplored_dist : &amp;greedy_dist;</a>
<a name="ln1222"> </a>
<a name="ln1223">    // Zap out previous distances array: this must happen before the</a>
<a name="ln1224">    // early exit checks below, since callers may want to inspect</a>
<a name="ln1225">    // point_distance after this call returns.</a>
<a name="ln1226">    //</a>
<a name="ln1227">    // point_distance will hold the distance of all points from the starting</a>
<a name="ln1228">    // point, i.e. the distance travelled to get there.</a>
<a name="ln1229">    memset(point_distance, 0, sizeof(travel_distance_grid_t));</a>
<a name="ln1230"> </a>
<a name="ln1231">    if (!in_bounds(start))</a>
<a name="ln1232">        return coord_def();</a>
<a name="ln1233"> </a>
<a name="ln1234">    // Abort run if we're trying to go someplace evil. Travel to traps is</a>
<a name="ln1235">    // specifically allowed here if the player insists on it.</a>
<a name="ln1236">    if (!floodout</a>
<a name="ln1237">        &amp;&amp; !_is_travelsafe_square(start, false, ignore_danger, true)</a>
<a name="ln1238">        &amp;&amp; !is_trap(start))          // player likes pain</a>
<a name="ln1239">    {</a>
<a name="ln1240">        return coord_def();</a>
<a name="ln1241">    }</a>
<a name="ln1242"> </a>
<a name="ln1243">    // Nothing to do?</a>
<a name="ln1244">    if (!floodout &amp;&amp; start == dest)</a>
<a name="ln1245">        return start;</a>
<a name="ln1246"> </a>
<a name="ln1247">    unwind_bool slime_wall_check(g_Slime_Wall_Check,</a>
<a name="ln1248">                                 !actor_slime_wall_immune(&amp;you));</a>
<a name="ln1249">    unwind_slime_wall_precomputer slime_neighbours(g_Slime_Wall_Check);</a>
<a name="ln1250"> </a>
<a name="ln1251">    // How many points are we currently considering? We start off with just one</a>
<a name="ln1252">    // point, and spread outwards like a flood-filler.</a>
<a name="ln1253">    points = 1;</a>
<a name="ln1254"> </a>
<a name="ln1255">    // How many points we'll consider next iteration.</a>
<a name="ln1256">    next_iter_points = 0;</a>
<a name="ln1257"> </a>
<a name="ln1258">    // How far we've travelled from (start_x, start_y), in moves (a diagonal move</a>
<a name="ln1259">    // is no longer than an orthogonal move).</a>
<a name="ln1260">    traveled_distance = 1;</a>
<a name="ln1261"> </a>
<a name="ln1262">    // Which index of the circumference array are we currently looking at?</a>
<a name="ln1263">    circ_index = 0;</a>
<a name="ln1264"> </a>
<a name="ln1265">    ignore_hostile = false;</a>
<a name="ln1266"> </a>
<a name="ln1267">    // For each round, circumference will store all points that were discovered</a>
<a name="ln1268">    // in the previous round of a given distance. Because we check all grids of</a>
<a name="ln1269">    // a certain distance from the starting point in one round, and move</a>
<a name="ln1270">    // outwards in concentric circles, this is an implementation of Dijkstra.</a>
<a name="ln1271">    // We use an array of size 2, so we can comfortably switch between the list</a>
<a name="ln1272">    // of points to be investigated this round and the slowly growing list of</a>
<a name="ln1273">    // points to be inspected next round. Once we've finished with the current</a>
<a name="ln1274">    // round, i.e. there are no more points to be looked at in the current</a>
<a name="ln1275">    // array, we switch circ_index over to !circ_index (between 0 and 1), so</a>
<a name="ln1276">    // the &quot;next round&quot; becomes the current one, and the old points can be</a>
<a name="ln1277">    // overwritten with newer ones. Since we count the number of points for</a>
<a name="ln1278">    // next round in next_iter_points, we don't even need to reset the array.</a>
<a name="ln1279">    circumference[circ_index][0] = start;</a>
<a name="ln1280"> </a>
<a name="ln1281">    bool found_target = false;</a>
<a name="ln1282"> </a>
<a name="ln1283">    for (; points &gt; 0; ++traveled_distance, circ_index = !circ_index,</a>
<a name="ln1284">                        points = next_iter_points, next_iter_points = 0)</a>
<a name="ln1285">    {</a>
<a name="ln1286">        for (int i = 0; i &lt; points; ++i)</a>
<a name="ln1287">        {</a>
<a name="ln1288">            // Look at all neighbours of the current grid.</a>
<a name="ln1289">            // path_examine_point() returns true if the target is reached</a>
<a name="ln1290">            // and marked as such.</a>
<a name="ln1291">            if (path_examine_point(circumference[circ_index][i]))</a>
<a name="ln1292">            {</a>
<a name="ln1293">                if (runmode == RMODE_TRAVEL)</a>
<a name="ln1294">                    return travel_move();</a>
<a name="ln1295">                else if (runmode == RMODE_CONNECTIVITY</a>
<a name="ln1296">                         || !Options.explore_wall_bias)</a>
<a name="ln1297">                {</a>
<a name="ln1298">                    return explore_target();</a>
<a name="ln1299">                }</a>
<a name="ln1300">                else</a>
<a name="ln1301">                    found_target = true;</a>
<a name="ln1302">            }</a>
<a name="ln1303">        }</a>
<a name="ln1304"> </a>
<a name="ln1305">        // Handle exploration with wall bias</a>
<a name="ln1306">        if (next_iter_points == 0 &amp;&amp; found_target)</a>
<a name="ln1307">            return explore_target();</a>
<a name="ln1308"> </a>
<a name="ln1309">        // If there are no more points to look at, we're done, but we did</a>
<a name="ln1310">        // not find a path to our target.</a>
<a name="ln1311">        if (next_iter_points == 0)</a>
<a name="ln1312">        {</a>
<a name="ln1313">            // Don't reseed unless we've found no target for explore, OR</a>
<a name="ln1314">            // we're doing map annotation or feature tracking.</a>
<a name="ln1315">            if ((runmode == RMODE_EXPLORE || runmode == RMODE_EXPLORE_GREEDY</a>
<a name="ln1316">                 || runmode == RMODE_CONNECTIVITY)</a>
<a name="ln1317">                &amp;&amp; double_flood</a>
<a name="ln1318">                &amp;&amp; !ignore_hostile</a>
<a name="ln1319">                &amp;&amp; !features</a>
<a name="ln1320">                &amp;&amp; !annotate_map</a>
<a name="ln1321">                &amp;&amp; (unexplored_dist != UNFOUND_DIST</a>
<a name="ln1322">                    || greedy_dist != UNFOUND_DIST))</a>
<a name="ln1323">            {</a>
<a name="ln1324">                break;</a>
<a name="ln1325">            }</a>
<a name="ln1326"> </a>
<a name="ln1327">            if (double_flood</a>
<a name="ln1328">                &amp;&amp; !ignore_hostile</a>
<a name="ln1329">                &amp;&amp; !reseed_points.empty())</a>
<a name="ln1330">            {</a>
<a name="ln1331">                // Reseed here</a>
<a name="ln1332">                for (unsigned i = 0, size = reseed_points.size(); i &lt; size; ++i)</a>
<a name="ln1333">                    circumference[!circ_index][i] = reseed_points[i];</a>
<a name="ln1334"> </a>
<a name="ln1335">                next_iter_points  = reseed_points.size();</a>
<a name="ln1336">                ignore_hostile    = true;</a>
<a name="ln1337">            }</a>
<a name="ln1338">        }</a>
<a name="ln1339">    } // for (; points &gt; 0 ...</a>
<a name="ln1340"> </a>
<a name="ln1341">    if (features &amp;&amp; floodout)</a>
<a name="ln1342">    {</a>
<a name="ln1343">        for (const auto &amp;entry : curr_excludes)</a>
<a name="ln1344">        {</a>
<a name="ln1345">            const travel_exclude &amp;exc = entry.second;</a>
<a name="ln1346">            // An exclude - wherever it is - is always a feature.</a>
<a name="ln1347">            if (find(features-&gt;begin(), features-&gt;end(), exc.pos)</a>
<a name="ln1348">                    == features-&gt;end())</a>
<a name="ln1349">            {</a>
<a name="ln1350">                features-&gt;push_back(exc.pos);</a>
<a name="ln1351">            }</a>
<a name="ln1352"> </a>
<a name="ln1353">            _fill_exclude_radius(exc);</a>
<a name="ln1354">        }</a>
<a name="ln1355">    }</a>
<a name="ln1356"> </a>
<a name="ln1357">    return runmode == RMODE_TRAVEL ? travel_move()</a>
<a name="ln1358">                                   : explore_target();</a>
<a name="ln1359">}</a>
<a name="ln1360"> </a>
<a name="ln1361">void travel_pathfind::get_features()</a>
<a name="ln1362">{</a>
<a name="ln1363">    ASSERT(features);</a>
<a name="ln1364"> </a>
<a name="ln1365">    if (!ls &amp;&amp; (annotate_map || need_for_greed))</a>
<a name="ln1366">        ls = StashTrack.find_current_level();</a>
<a name="ln1367"> </a>
<a name="ln1368">    memset(point_distance, 0, sizeof(travel_distance_grid_t));</a>
<a name="ln1369"> </a>
<a name="ln1370">    coord_def dc;</a>
<a name="ln1371">    for (dc.x = X_BOUND_1; dc.x &lt;= X_BOUND_2; ++dc.x)</a>
<a name="ln1372">        for (dc.y = Y_BOUND_1; dc.y &lt;= Y_BOUND_2; ++dc.y)</a>
<a name="ln1373">        {</a>
<a name="ln1374">            const dungeon_feature_type feature = env.map_knowledge(dc).feat();</a>
<a name="ln1375"> </a>
<a name="ln1376">            if ((feature != DNGN_FLOOR</a>
<a name="ln1377">                    &amp;&amp; !feat_is_water(feature)</a>
<a name="ln1378">                    &amp;&amp; feature != DNGN_LAVA)</a>
<a name="ln1379">                || is_waypoint(dc)</a>
<a name="ln1380">                || is_stash(ls, dc)</a>
<a name="ln1381">                || is_trap(dc))</a>
<a name="ln1382">            {</a>
<a name="ln1383">                features-&gt;push_back(dc);</a>
<a name="ln1384">            }</a>
<a name="ln1385">        }</a>
<a name="ln1386"> </a>
<a name="ln1387">    for (const auto &amp;entry : curr_excludes)</a>
<a name="ln1388">    {</a>
<a name="ln1389">        const travel_exclude &amp;exc = entry.second;</a>
<a name="ln1390"> </a>
<a name="ln1391">        // An exclude - wherever it is - is always a feature.</a>
<a name="ln1392">        if (find(features-&gt;begin(), features-&gt;end(), exc.pos) == features-&gt;end())</a>
<a name="ln1393">            features-&gt;push_back(exc.pos);</a>
<a name="ln1394"> </a>
<a name="ln1395">        _fill_exclude_radius(exc);</a>
<a name="ln1396">    }</a>
<a name="ln1397">}</a>
<a name="ln1398"> </a>
<a name="ln1399">const set&lt;coord_def&gt; travel_pathfind::get_unreachables() const</a>
<a name="ln1400">{</a>
<a name="ln1401">    return unreachables;</a>
<a name="ln1402">}</a>
<a name="ln1403"> </a>
<a name="ln1404">bool travel_pathfind::square_slows_movement(const coord_def &amp;c)</a>
<a name="ln1405">{</a>
<a name="ln1406">    // c is a known (explored) location - we never put unknown points in the</a>
<a name="ln1407">    // circumference vector, so we don't need to examine the map array, just the</a>
<a name="ln1408">    // grid array.</a>
<a name="ln1409">    const dungeon_feature_type feature = env.map_knowledge(c).feat();</a>
<a name="ln1410"> </a>
<a name="ln1411">    // If this is a feature that'll take time to travel past, we simulate that</a>
<a name="ln1412">    // extra turn by taking this feature next turn, thereby artificially</a>
<a name="ln1413">    // increasing traveled_distance.</a>
<a name="ln1414">    //</a>
<a name="ln1415">    // Walking through shallow water and opening closed doors is considered to</a>
<a name="ln1416">    // have the cost of two normal moves for travel purposes.</a>
<a name="ln1417">    const int feat_cost = _feature_traverse_cost(feature);</a>
<a name="ln1418">    if (feat_cost &gt; 1</a>
<a name="ln1419">        &amp;&amp; point_distance[c.x][c.y] &gt; traveled_distance - feat_cost)</a>
<a name="ln1420">    {</a>
<a name="ln1421">        circumference[!circ_index][next_iter_points++] = c;</a>
<a name="ln1422">        return true;</a>
<a name="ln1423">    }</a>
<a name="ln1424"> </a>
<a name="ln1425">    return false;</a>
<a name="ln1426">}</a>
<a name="ln1427"> </a>
<a name="ln1428">void travel_pathfind::check_square_greed(const coord_def &amp;c)</a>
<a name="ln1429">{</a>
<a name="ln1430">    if (greedy_dist == UNFOUND_DIST</a>
<a name="ln1431">        &amp;&amp; is_greed_inducing_square(c)</a>
<a name="ln1432">        &amp;&amp; _is_travelsafe_square(c, ignore_hostile, ignore_danger))</a>
<a name="ln1433">    {</a>
<a name="ln1434">        int dist = traveled_distance;</a>
<a name="ln1435"> </a>
<a name="ln1436">        // Penalize distance for negative explore_item_greed</a>
<a name="ln1437">        if (Options.explore_item_greed &lt; 0)</a>
<a name="ln1438">            dist -= Options.explore_item_greed;</a>
<a name="ln1439"> </a>
<a name="ln1440">        // The addition of explore_wall_bias makes items as interesting</a>
<a name="ln1441">        // as a room's perimeter (with one of four known adjacent walls).</a>
<a name="ln1442">        if (Options.explore_wall_bias)</a>
<a name="ln1443">            dist += Options.explore_wall_bias * 3;</a>
<a name="ln1444"> </a>
<a name="ln1445">        greedy_dist = dist;</a>
<a name="ln1446">        greedy_place = c;</a>
<a name="ln1447">    }</a>
<a name="ln1448">}</a>
<a name="ln1449"> </a>
<a name="ln1450">bool travel_pathfind::path_flood(const coord_def &amp;c, const coord_def &amp;dc)</a>
<a name="ln1451">{</a>
<a name="ln1452">    if (!in_bounds(dc) || unreachables.count(dc))</a>
<a name="ln1453">        return false;</a>
<a name="ln1454"> </a>
<a name="ln1455">    if (floodout</a>
<a name="ln1456">        &amp;&amp; (runmode == RMODE_EXPLORE || runmode == RMODE_EXPLORE_GREEDY))</a>
<a name="ln1457">    {</a>
<a name="ln1458">        if (!env.map_knowledge(dc).seen())</a>
<a name="ln1459">        {</a>
<a name="ln1460">            if (ignore_hostile &amp;&amp; !player_in_branch(BRANCH_SHOALS))</a>
<a name="ln1461">            {</a>
<a name="ln1462">                // This point is unexplored but unreachable. Let's find a</a>
<a name="ln1463">                // place from where we can see it.</a>
<a name="ln1464">                for (radius_iterator ri(dc, LOS_DEFAULT, true); ri; ++ri)</a>
<a name="ln1465">                {</a>
<a name="ln1466">                    const int dist = point_distance[ri-&gt;x][ri-&gt;y];</a>
<a name="ln1467">                    if (dist &gt; 0</a>
<a name="ln1468">                        &amp;&amp; (dist &lt; unexplored_dist || unexplored_dist &lt; 0))</a>
<a name="ln1469">                    {</a>
<a name="ln1470">                        unexplored_dist = dist;</a>
<a name="ln1471">                        unexplored_place = *ri;</a>
<a name="ln1472">                    }</a>
<a name="ln1473"> </a>
<a name="ln1474">                    // We can't do better than that.</a>
<a name="ln1475">                    if (unexplored_dist == 1)</a>
<a name="ln1476">                    {</a>
<a name="ln1477">                        _set_target_square(unexplored_place);</a>
<a name="ln1478">                        return true;</a>
<a name="ln1479">                    }</a>
<a name="ln1480">                }</a>
<a name="ln1481"> </a>
<a name="ln1482">                // We can't even see the place.</a>
<a name="ln1483">                // Let's store it and look for another.</a>
<a name="ln1484">                if (unexplored_dist &lt; 0)</a>
<a name="ln1485">                    unreachables.insert(dc);</a>
<a name="ln1486">                else</a>
<a name="ln1487">                    _set_target_square(unexplored_place);</a>
<a name="ln1488">            }</a>
<a name="ln1489">            else</a>
<a name="ln1490">            {</a>
<a name="ln1491">                // Found explore target!</a>
<a name="ln1492">                int dist = traveled_distance;</a>
<a name="ln1493"> </a>
<a name="ln1494">                if (need_for_greed &amp;&amp; Options.explore_item_greed &gt; 0)</a>
<a name="ln1495">                {</a>
<a name="ln1496">                    // Penalize distance to favour item pickup</a>
<a name="ln1497">                    dist += Options.explore_item_greed;</a>
<a name="ln1498">                }</a>
<a name="ln1499"> </a>
<a name="ln1500">                if (Options.explore_wall_bias)</a>
<a name="ln1501">                {</a>
<a name="ln1502">                    dist += Options.explore_wall_bias * 4;</a>
<a name="ln1503"> </a>
<a name="ln1504">                    // Favour squares directly adjacent to walls</a>
<a name="ln1505">                    for (int dir = 0; dir &lt; 8; dir += 2)</a>
<a name="ln1506">                    {</a>
<a name="ln1507">                        const coord_def ddc = dc + Compass[dir];</a>
<a name="ln1508"> </a>
<a name="ln1509">                        if (feat_is_wall(env.map_knowledge(ddc).feat()))</a>
<a name="ln1510">                            dist -= Options.explore_wall_bias;</a>
<a name="ln1511">                    }</a>
<a name="ln1512">                }</a>
<a name="ln1513"> </a>
<a name="ln1514">                // Replace old target if nearer (or less penalized)</a>
<a name="ln1515">                if (dist &lt; unexplored_dist || unexplored_dist &lt; 0)</a>
<a name="ln1516">                {</a>
<a name="ln1517">                    unexplored_dist = dist;</a>
<a name="ln1518">                    unexplored_place = c;</a>
<a name="ln1519">                }</a>
<a name="ln1520">            }</a>
<a name="ln1521">        }</a>
<a name="ln1522"> </a>
<a name="ln1523">        // Short-circuit if we can. If traveled_distance (the current</a>
<a name="ln1524">        // distance from the centre of the floodfill) is greater</a>
<a name="ln1525">        // than the adjusted distance to the nearest greedy explore</a>
<a name="ln1526">        // target, we have a target. Note the adjusted distance is</a>
<a name="ln1527">        // the distance with explore_item_greed applied (if</a>
<a name="ln1528">        // explore_item_greed &gt; 0, it is added to the distance to</a>
<a name="ln1529">        // unexplored terrain, if explore_item_greed &lt; 0, it is</a>
<a name="ln1530">        // added to the distance to interesting items.</a>
<a name="ln1531">        //</a>
<a name="ln1532">        // We never short-circuit if ignore_hostile is true. This is</a>
<a name="ln1533">        // important so we don't need to do multiple floods to work out</a>
<a name="ln1534">        // whether explore is complete.</a>
<a name="ln1535">        if (need_for_greed</a>
<a name="ln1536">            &amp;&amp; !ignore_hostile</a>
<a name="ln1537">            &amp;&amp; *refdist != UNFOUND_DIST</a>
<a name="ln1538">            &amp;&amp; traveled_distance &gt; *refdist)</a>
<a name="ln1539">        {</a>
<a name="ln1540">            if (Options.explore_item_greed &gt; 0)</a>
<a name="ln1541">                greedy_dist = INFINITE_DIST;</a>
<a name="ln1542">            else</a>
<a name="ln1543">                unexplored_dist = INFINITE_DIST;</a>
<a name="ln1544">        }</a>
<a name="ln1545"> </a>
<a name="ln1546">        // greedy_dist is only ever set in greedy-explore so this check</a>
<a name="ln1547">        // implies greedy-explore.</a>
<a name="ln1548">        if (unexplored_dist != UNFOUND_DIST &amp;&amp; greedy_dist != UNFOUND_DIST)</a>
<a name="ln1549">            return true;</a>
<a name="ln1550">    }</a>
<a name="ln1551"> </a>
<a name="ln1552">    // We don't want to follow the transporter at c if it's excluded. We also</a>
<a name="ln1553">    // don't want to update point_distance for the destination based on</a>
<a name="ln1554">    // taking this transporter.</a>
<a name="ln1555">    if (!ignore_danger</a>
<a name="ln1556">        &amp;&amp; is_excluded(c)</a>
<a name="ln1557">        &amp;&amp; env.map_knowledge(c).feat() == DNGN_TRANSPORTER</a>
<a name="ln1558">        // We have to actually take the transporter to go from c to dc.</a>
<a name="ln1559">        &amp;&amp; !adjacent(c, dc))</a>
<a name="ln1560">    {</a>
<a name="ln1561">        return false;</a>
<a name="ln1562">    }</a>
<a name="ln1563">    else if (dc == dest)</a>
<a name="ln1564">    {</a>
<a name="ln1565">        // Hallelujah, we're home!</a>
<a name="ln1566">        if (_is_safe_move(c))</a>
<a name="ln1567">            next_travel_move = c;</a>
<a name="ln1568"> </a>
<a name="ln1569">        return true;</a>
<a name="ln1570">    }</a>
<a name="ln1571">    else if (!_is_travelsafe_square(dc, ignore_hostile, ignore_danger, try_fallback))</a>
<a name="ln1572">    {</a>
<a name="ln1573">        // This point is not okay to travel on, but if this is a</a>
<a name="ln1574">        // trap, we'll want to put it on the feature vector anyway.</a>
<a name="ln1575">        if (_is_reseedable(dc, ignore_danger)</a>
<a name="ln1576">            &amp;&amp; !point_distance[dc.x][dc.y]</a>
<a name="ln1577">            &amp;&amp; dc != start)</a>
<a name="ln1578">        {</a>
<a name="ln1579">            if (features &amp;&amp; (is_trap(dc) || is_exclude_root(dc))</a>
<a name="ln1580">                &amp;&amp; find(features-&gt;begin(), features-&gt;end(), dc)</a>
<a name="ln1581">                   == features-&gt;end())</a>
<a name="ln1582">            {</a>
<a name="ln1583">                features-&gt;push_back(dc);</a>
<a name="ln1584">            }</a>
<a name="ln1585"> </a>
<a name="ln1586">            if (double_flood)</a>
<a name="ln1587">                reseed_points.push_back(dc);</a>
<a name="ln1588"> </a>
<a name="ln1589">            // Appropriate mystic number. Nobody else should check</a>
<a name="ln1590">            // this number, since this square is unsafe for travel.</a>
<a name="ln1591">            point_distance[dc.x][dc.y] =</a>
<a name="ln1592">                is_exclude_root(dc)   ? PD_EXCLUDED :</a>
<a name="ln1593">                is_excluded(dc)       ? PD_EXCLUDED_RADIUS :</a>
<a name="ln1594">                !_is_safe_cloud(dc)   ? PD_CLOUD</a>
<a name="ln1595">                                      : PD_TRAP;</a>
<a name="ln1596">        }</a>
<a name="ln1597">        return false;</a>
<a name="ln1598">    }</a>
<a name="ln1599"> </a>
<a name="ln1600">    if (!point_distance[dc.x][dc.y])</a>
<a name="ln1601">    {</a>
<a name="ln1602">        // This point is going to be on the agenda for the next</a>
<a name="ln1603">        // iteration</a>
<a name="ln1604">        circumference[!circ_index][next_iter_points++] = dc;</a>
<a name="ln1605">        point_distance[dc.x][dc.y] = traveled_distance;</a>
<a name="ln1606"> </a>
<a name="ln1607">        // Negative distances here so that show_map can colour</a>
<a name="ln1608">        // the map differently for these squares.</a>
<a name="ln1609">        if (ignore_hostile)</a>
<a name="ln1610">        {</a>
<a name="ln1611">            point_distance[dc.x][dc.y] = -point_distance[dc.x][dc.y];</a>
<a name="ln1612">            if (is_exclude_root(dc))</a>
<a name="ln1613">                point_distance[dc.x][dc.y] = PD_EXCLUDED;</a>
<a name="ln1614">            else if (is_excluded(dc))</a>
<a name="ln1615">                point_distance[dc.x][dc.y] = PD_EXCLUDED_RADIUS;</a>
<a name="ln1616">        }</a>
<a name="ln1617"> </a>
<a name="ln1618">        if (features &amp;&amp; !ignore_hostile)</a>
<a name="ln1619">        {</a>
<a name="ln1620">            dungeon_feature_type feature = env.map_knowledge(dc).feat();</a>
<a name="ln1621"> </a>
<a name="ln1622">            if (dc != start</a>
<a name="ln1623">                &amp;&amp; (feature != DNGN_FLOOR</a>
<a name="ln1624">                       &amp;&amp; !feat_is_water(feature)</a>
<a name="ln1625">                       &amp;&amp; feature != DNGN_LAVA</a>
<a name="ln1626">                    || is_waypoint(dc)</a>
<a name="ln1627">                    || is_stash(ls, dc))</a>
<a name="ln1628">                &amp;&amp; find(features-&gt;begin(), features-&gt;end(), dc)</a>
<a name="ln1629">                   == features-&gt;end())</a>
<a name="ln1630">            {</a>
<a name="ln1631">                features-&gt;push_back(dc);</a>
<a name="ln1632">            }</a>
<a name="ln1633">        }</a>
<a name="ln1634"> </a>
<a name="ln1635">        if (features &amp;&amp; dc != start &amp;&amp; is_exclude_root(dc)</a>
<a name="ln1636">            &amp;&amp; find(features-&gt;begin(), features-&gt;end(), dc)</a>
<a name="ln1637">               == features-&gt;end())</a>
<a name="ln1638">        {</a>
<a name="ln1639">            features-&gt;push_back(dc);</a>
<a name="ln1640">        }</a>
<a name="ln1641">    }</a>
<a name="ln1642"> </a>
<a name="ln1643">    return false;</a>
<a name="ln1644">}</a>
<a name="ln1645"> </a>
<a name="ln1646">void travel_pathfind::good_square(const coord_def &amp;c)</a>
<a name="ln1647">{</a>
<a name="ln1648">    if (!point_distance[c.x][c.y])</a>
<a name="ln1649">    {</a>
<a name="ln1650">        // This point is going to be on the agenda for the next iteration.</a>
<a name="ln1651">        circumference[!circ_index][next_iter_points++] = c;</a>
<a name="ln1652">        point_distance[c.x][c.y] = traveled_distance;</a>
<a name="ln1653">    }</a>
<a name="ln1654">}</a>
<a name="ln1655"> </a>
<a name="ln1656">bool travel_pathfind::point_traverse_delay(const coord_def &amp;c)</a>
<a name="ln1657">{</a>
<a name="ln1658">    if (square_slows_movement(c))</a>
<a name="ln1659">        return true;</a>
<a name="ln1660"> </a>
<a name="ln1661">    // Greedy explore check should happen on (x,y), not (dx,dy) as for</a>
<a name="ln1662">    // regular explore.</a>
<a name="ln1663">    if (need_for_greed)</a>
<a name="ln1664">        check_square_greed(c);</a>
<a name="ln1665"> </a>
<a name="ln1666">    return false;</a>
<a name="ln1667">}</a>
<a name="ln1668"> </a>
<a name="ln1669">// Checks all neighbours of c, adds them to next round's list of points</a>
<a name="ln1670">// - happens in path_flood() - and returns true if one of them turns out</a>
<a name="ln1671">// to be the target; otherwise, false.</a>
<a name="ln1672">bool travel_pathfind::path_examine_point(const coord_def &amp;c)</a>
<a name="ln1673">{</a>
<a name="ln1674">    // If we've run off the map, or are pathfinding from nowhere in particular</a>
<a name="ln1675">    if (!in_bounds(c))</a>
<a name="ln1676">        return false;</a>
<a name="ln1677"> </a>
<a name="ln1678">    if (point_traverse_delay(c))</a>
<a name="ln1679">        return false;</a>
<a name="ln1680"> </a>
<a name="ln1681">    bool found_target = false;</a>
<a name="ln1682"> </a>
<a name="ln1683">    // For each point, we look at all surrounding points. Take them orthogonals</a>
<a name="ln1684">    // first so that the travel path doesn't zigzag all over the map. Note the</a>
<a name="ln1685">    // (dir = 1) is intentional assignment.</a>
<a name="ln1686">    for (int dir = 0; dir &lt; 8; (dir += 2) == 8 &amp;&amp; (dir = 1))</a>
<a name="ln1687">        if (path_flood(c, c + Compass[dir]))</a>
<a name="ln1688">            found_target = true;</a>
<a name="ln1689"> </a>
<a name="ln1690">    // For travel, we want to pathfind through transporters. Floodout mode</a>
<a name="ln1691">    // proceeds from source, so we take transporters, but for determining moves</a>
<a name="ln1692">    // we work in reverse from destination back to source, so we pathfind</a>
<a name="ln1693">    // through the landing sites.</a>
<a name="ln1694">    if (runmode == RMODE_TRAVEL || runmode == RMODE_NOT_RUNNING)</a>
<a name="ln1695">    {</a>
<a name="ln1696">        if (floodout &amp;&amp; grd(c) == DNGN_TRANSPORTER)</a>
<a name="ln1697">        {</a>
<a name="ln1698">            LevelInfo &amp;li = travel_cache.get_level_info(level_id::current());</a>
<a name="ln1699">            transporter_info *ti = li.get_transporter(c);</a>
<a name="ln1700">            if (ti &amp;&amp; ti-&gt;destination != INVALID_COORD)</a>
<a name="ln1701">            {</a>
<a name="ln1702">                if (path_flood(c, ti-&gt;destination))</a>
<a name="ln1703">                    found_target = true;</a>
<a name="ln1704">            }</a>
<a name="ln1705">        }</a>
<a name="ln1706">        else if (!floodout &amp;&amp; grd(c) == DNGN_TRANSPORTER_LANDING)</a>
<a name="ln1707">        {</a>
<a name="ln1708">            LevelInfo &amp;li = travel_cache.get_level_info(level_id::current());</a>
<a name="ln1709">            vector&lt;transporter_info&gt; transporters = li.get_transporters();</a>
<a name="ln1710">            for (auto ti : transporters)</a>
<a name="ln1711">            {</a>
<a name="ln1712">                if (ti.destination == c)</a>
<a name="ln1713">                    if (path_flood(c, ti.position))</a>
<a name="ln1714">                         found_target = true;</a>
<a name="ln1715">            }</a>
<a name="ln1716">        }</a>
<a name="ln1717">    }</a>
<a name="ln1718"> </a>
<a name="ln1719">    return found_target;</a>
<a name="ln1720">}</a>
<a name="ln1721"> </a>
<a name="ln1722">/**</a>
<a name="ln1723"> * Run the travel_pathfind algorithm, either from the given position in</a>
<a name="ln1724"> * floodout mode to populate travel_point_distance relative to that starting</a>
<a name="ln1725"> * point, or with a destination with the aim of determining the next travel</a>
<a name="ln1726"> * move. In the latter case, try to avoid to let travel (including autoexplore)</a>
<a name="ln1727"> * move the player right next to a lurking (previously unseen) monster.</a>
<a name="ln1728"> *</a>
<a name="ln1729"> * If move_x and move_y are given, pathfinding runs from you.running.pos to</a>
<a name="ln1730"> * youpos, and the move contains the next movement relative to youpos to move</a>
<a name="ln1731"> * closer to you.running.pos. If a runed door is encountered or a transporter</a>
<a name="ln1732"> * needs to be taken, these are set to 0, and the caller checks for this.</a>
<a name="ln1733"> *</a>
<a name="ln1734"> * XXX The two modes of this function (with and without move_x/move_y) should</a>
<a name="ln1735"> * be split into two different functions, since they aren't really related.</a>
<a name="ln1736"> *</a>
<a name="ln1737"> * @param      youpos The starting position.</a>
<a name="ln1738"> * @param[out] move_x If we want a travel move, the x coordinate.</a>
<a name="ln1739"> * @param[out] move_y If we want a travel move, the y coordinate.</a>
<a name="ln1740"> * @param[in]  features A vector of features to give to travel_pathfind.</a>
<a name="ln1741"> */</a>
<a name="ln1742">void find_travel_pos(const coord_def&amp; youpos,</a>
<a name="ln1743">                     int *move_x, int *move_y,</a>
<a name="ln1744">                     vector&lt;coord_def&gt;* features)</a>
<a name="ln1745">{</a>
<a name="ln1746">    const bool need_move = move_x &amp;&amp; move_y;</a>
<a name="ln1747">    travel_pathfind tp;</a>
<a name="ln1748"> </a>
<a name="ln1749">    if (need_move)</a>
<a name="ln1750">        tp.set_src_dst(youpos, you.running.pos);</a>
<a name="ln1751">    else</a>
<a name="ln1752">        tp.set_floodseed(youpos);</a>
<a name="ln1753"> </a>
<a name="ln1754">    tp.set_feature_vector(features);</a>
<a name="ln1755"> </a>
<a name="ln1756">    run_mode_type rmode = (need_move) ? RMODE_TRAVEL : RMODE_NOT_RUNNING;</a>
<a name="ln1757"> </a>
<a name="ln1758">    coord_def dest = tp.pathfind(rmode, false);</a>
<a name="ln1759">    if (dest.origin())</a>
<a name="ln1760">        dest = tp.pathfind(rmode, true);</a>
<a name="ln1761">    coord_def new_dest = dest;</a>
<a name="ln1762"> </a>
<a name="ln1763">    // We'd either have to travel through a runed door, in which case we'll be</a>
<a name="ln1764">    // stopping, or a transporter, in which case we need to issue a command to</a>
<a name="ln1765">    // enter.</a>
<a name="ln1766">    if (need_move</a>
<a name="ln1767">        &amp;&amp; (cell_is_runed(new_dest)</a>
<a name="ln1768">            || grd(youpos) == DNGN_TRANSPORTER</a>
<a name="ln1769">               &amp;&amp; grd(new_dest) == DNGN_TRANSPORTER_LANDING</a>
<a name="ln1770">               &amp;&amp; youpos.distance_from(new_dest) &gt; 1))</a>
<a name="ln1771">    {</a>
<a name="ln1772">        *move_x = 0;</a>
<a name="ln1773">        *move_y = 0;</a>
<a name="ln1774">        return;</a>
<a name="ln1775">    }</a>
<a name="ln1776"> </a>
<a name="ln1777">    // Check whether this step puts us adjacent to any grid we haven't ever</a>
<a name="ln1778">    // seen or any non-wall grid we cannot currently see.</a>
<a name="ln1779">    //</a>
<a name="ln1780">    // .tx      Moving onto t puts us adjacent to an unseen grid.</a>
<a name="ln1781">    // ?#@      --&gt; Pick x instead.</a>
<a name="ln1782"> </a>
<a name="ln1783">    // Only applies to diagonal moves.</a>
<a name="ln1784">    if (rmode == RMODE_TRAVEL &amp;&amp; *move_x != 0 &amp;&amp; *move_y != 0)</a>
<a name="ln1785">    {</a>
<a name="ln1786">        coord_def unseen = coord_def();</a>
<a name="ln1787">        for (adjacent_iterator ai(dest); ai; ++ai)</a>
<a name="ln1788">            if (!you.see_cell(*ai)</a>
<a name="ln1789">                &amp;&amp; (!env.map_knowledge(*ai).seen()</a>
<a name="ln1790">                    || !feat_is_wall(env.map_knowledge(*ai).feat())))</a>
<a name="ln1791">            {</a>
<a name="ln1792">                unseen = *ai;</a>
<a name="ln1793">                break;</a>
<a name="ln1794">            }</a>
<a name="ln1795"> </a>
<a name="ln1796">        if (unseen != coord_def())</a>
<a name="ln1797">        {</a>
<a name="ln1798">            // If so, try to use an orthogonally adjacent grid that is safe to</a>
<a name="ln1799">            // enter.</a>
<a name="ln1800">            if (youpos.x == unseen.x)</a>
<a name="ln1801">                new_dest.y = youpos.y;</a>
<a name="ln1802">            else if (youpos.y == unseen.y)</a>
<a name="ln1803">                new_dest.x = youpos.x;</a>
<a name="ln1804"> </a>
<a name="ln1805">            // If the new grid cannot be entered, reset to dest. This means</a>
<a name="ln1806">            // that autoexplore will still sometimes move you next to a</a>
<a name="ln1807">            // previously unseen monster but the same would happen by manual</a>
<a name="ln1808">            // movement, so I don't think we need to worry about this. (jpeg)</a>
<a name="ln1809">            if (!_is_travelsafe_square(new_dest)</a>
<a name="ln1810">                || !feat_is_traversable_now(env.map_knowledge(new_dest).feat()))</a>
<a name="ln1811">            {</a>
<a name="ln1812">                new_dest = dest;</a>
<a name="ln1813">            }</a>
<a name="ln1814">#ifdef DEBUG_SAFE_EXPLORE</a>
<a name="ln1815">            mprf(MSGCH_DIAGNOSTICS, &quot;youpos: (%d, %d), dest: (%d, %d), &quot;</a>
<a name="ln1816">                     &quot;unseen: (%d, %d), new_dest: (%d, %d)&quot;,</a>
<a name="ln1817">                 youpos.x, youpos.y, dest.x, dest.y, unseen.x, unseen.y,</a>
<a name="ln1818">                 new_dest.x, new_dest.y);</a>
<a name="ln1819">            more();</a>
<a name="ln1820">#endif</a>
<a name="ln1821">        }</a>
<a name="ln1822">    }</a>
<a name="ln1823"> </a>
<a name="ln1824">    if (new_dest.origin())</a>
<a name="ln1825">    {</a>
<a name="ln1826">        if (need_move)</a>
<a name="ln1827">            you.running = RMODE_NOT_RUNNING;</a>
<a name="ln1828">    }</a>
<a name="ln1829"> </a>
<a name="ln1830">    if (need_move)</a>
<a name="ln1831">    {</a>
<a name="ln1832">        *move_x = new_dest.x - youpos.x;</a>
<a name="ln1833">        *move_y = new_dest.y - youpos.y;</a>
<a name="ln1834">    }</a>
<a name="ln1835">}</a>
<a name="ln1836"> </a>
<a name="ln1837">extern map&lt;branch_type, set&lt;level_id&gt; &gt; stair_level;</a>
<a name="ln1838"> </a>
<a name="ln1839">static void _find_parent_branch(branch_type br, branch_type *pb, int *pd)</a>
<a name="ln1840">{</a>
<a name="ln1841">    *pb = parent_branch(br);   // Check depth before using *pb.</a>
<a name="ln1842"> </a>
<a name="ln1843">    if (auto levels = map_find(stair_level, br))</a>
<a name="ln1844">    {</a>
<a name="ln1845">        if (levels-&gt;size() &gt; 0)</a>
<a name="ln1846">        {</a>
<a name="ln1847">            *pd = levels-&gt;begin()-&gt;depth;</a>
<a name="ln1848">            return;</a>
<a name="ln1849">        }</a>
<a name="ln1850">    }</a>
<a name="ln1851">    *pd = 0;</a>
<a name="ln1852">}</a>
<a name="ln1853"> </a>
<a name="ln1854">// Appends the passed in branch/depth to the given vector, then attempts to</a>
<a name="ln1855">// repeat the operation with the parent branch of the given branch.</a>
<a name="ln1856">//</a>
<a name="ln1857">// As an example of what it does, assume this dungeon structure</a>
<a name="ln1858">//   Stairs to lair on D:11</a>
<a name="ln1859">//   Stairs to snake pit on lair:5</a>
<a name="ln1860">//</a>
<a name="ln1861">// If level 3 of the snake pit is the level we want to track back from,</a>
<a name="ln1862">// we'd call _trackback(vec, BRANCH_SNAKE, 3), and the resulting vector will</a>
<a name="ln1863">// look like:</a>
<a name="ln1864">// { BRANCH_SNAKE, 3 }, { BRANCH_LAIR, 5 }, { BRANCH_DUNGEON, 11 }</a>
<a name="ln1865">// (Assuming, of course, that the vector started out empty.)</a>
<a name="ln1866">//</a>
<a name="ln1867">static void _trackback(vector&lt;level_id&gt; &amp;vec, branch_type branch, int subdepth)</a>
<a name="ln1868">{</a>
<a name="ln1869">    if (subdepth &lt; 1)</a>
<a name="ln1870">        return;</a>
<a name="ln1871">    ASSERT(subdepth &lt;= 27);</a>
<a name="ln1872"> </a>
<a name="ln1873">    vec.emplace_back(branch, subdepth);</a>
<a name="ln1874"> </a>
<a name="ln1875">    if (branch != root_branch)</a>
<a name="ln1876">    {</a>
<a name="ln1877">        branch_type pb;</a>
<a name="ln1878">        int pd;</a>
<a name="ln1879">        _find_parent_branch(branch, &amp;pb, &amp;pd);</a>
<a name="ln1880">        if (pd)</a>
<a name="ln1881">            _trackback(vec, pb, pd);</a>
<a name="ln1882">    }</a>
<a name="ln1883">}</a>
<a name="ln1884"> </a>
<a name="ln1885">static void _track_intersect(vector&lt;level_id&gt; &amp;cur, vector&lt;level_id&gt; &amp;targ,</a>
<a name="ln1886">                             level_id *cx)</a>
<a name="ln1887">{</a>
<a name="ln1888">    cx-&gt;branch = BRANCH_DUNGEON;</a>
<a name="ln1889">    cx-&gt;depth  = -1;</a>
<a name="ln1890"> </a>
<a name="ln1891">    int us = int(cur.size()) - 1, them = int(targ.size()) - 1;</a>
<a name="ln1892"> </a>
<a name="ln1893">    for (; us &gt;= 0 &amp;&amp; them &gt;= 0; us--, them--)</a>
<a name="ln1894">        if (cur[us].branch != targ[them].branch)</a>
<a name="ln1895">            break;</a>
<a name="ln1896"> </a>
<a name="ln1897">    us++, them++;</a>
<a name="ln1898"> </a>
<a name="ln1899">    if (us &lt; (int) cur.size() &amp;&amp; them &lt; (int) targ.size() &amp;&amp; us &gt;= 0</a>
<a name="ln1900">        &amp;&amp; them &gt;= 0)</a>
<a name="ln1901">    {</a>
<a name="ln1902">        *cx = targ[them];</a>
<a name="ln1903">    }</a>
<a name="ln1904">}</a>
<a name="ln1905"> </a>
<a name="ln1906">// Returns the number of stairs the player would need to take to go from</a>
<a name="ln1907">// the 'first' level to the 'second' level. If there's no obvious route between</a>
<a name="ln1908">// 'first' and 'second', returns -1. If first == second, returns 0.</a>
<a name="ln1909">int level_distance(level_id first, level_id second)</a>
<a name="ln1910">{</a>
<a name="ln1911">    if (first == second)</a>
<a name="ln1912">        return 0;</a>
<a name="ln1913"> </a>
<a name="ln1914">    vector&lt;level_id&gt; fv, sv;</a>
<a name="ln1915"> </a>
<a name="ln1916">    // If in the same branch, easy.</a>
<a name="ln1917">    if (first.branch == second.branch)</a>
<a name="ln1918">        return abs(first.depth - second.depth);</a>
<a name="ln1919"> </a>
<a name="ln1920">    // Figure out the dungeon structure between the two levels.</a>
<a name="ln1921">    _trackback(fv, first.branch, first.depth);</a>
<a name="ln1922">    _trackback(sv, second.branch, second.depth);</a>
<a name="ln1923"> </a>
<a name="ln1924">    level_id intersect;</a>
<a name="ln1925">    _track_intersect(fv, sv, &amp;intersect);</a>
<a name="ln1926"> </a>
<a name="ln1927">    if (intersect.depth == -1)          // No common ground?</a>
<a name="ln1928">        return -1;</a>
<a name="ln1929"> </a>
<a name="ln1930">    int distance = 0;</a>
<a name="ln1931">    // If the common branch is not the same as the current branch, we'll</a>
<a name="ln1932">    // have to walk up the branch tree until we get to the common branch.</a>
<a name="ln1933">    while (first.branch != intersect.branch)</a>
<a name="ln1934">    {</a>
<a name="ln1935">        distance += first.depth;</a>
<a name="ln1936"> </a>
<a name="ln1937">        _find_parent_branch(first.branch, &amp;first.branch, &amp;first.depth);</a>
<a name="ln1938">        if (!first.depth)</a>
<a name="ln1939">            return -1;</a>
<a name="ln1940">    }</a>
<a name="ln1941"> </a>
<a name="ln1942">    // Now first.branch == intersect.branch</a>
<a name="ln1943">    distance += abs(first.depth - intersect.depth);</a>
<a name="ln1944"> </a>
<a name="ln1945">    bool ignore_end = true;</a>
<a name="ln1946">    for (int i = sv.size() - 1; i &gt;= 0; --i)</a>
<a name="ln1947">    {</a>
<a name="ln1948">        if (ignore_end)</a>
<a name="ln1949">        {</a>
<a name="ln1950">            if (sv[i].branch == intersect.branch)</a>
<a name="ln1951">                ignore_end = false;</a>
<a name="ln1952">            continue;</a>
<a name="ln1953">        }</a>
<a name="ln1954">        distance += sv[i].depth;</a>
<a name="ln1955">    }</a>
<a name="ln1956"> </a>
<a name="ln1957">    return distance;</a>
<a name="ln1958">}</a>
<a name="ln1959"> </a>
<a name="ln1960">static string _get_trans_travel_dest(const level_pos &amp;target,</a>
<a name="ln1961">                                     bool skip_branch = false,</a>
<a name="ln1962">                                     bool skip_coord = false)</a>
<a name="ln1963">{</a>
<a name="ln1964">    const int branch_id = target.id.branch;</a>
<a name="ln1965">    const char *branch = branches[branch_id].abbrevname;</a>
<a name="ln1966"> </a>
<a name="ln1967">    if (!branch)</a>
<a name="ln1968">        return &quot;&quot;;</a>
<a name="ln1969"> </a>
<a name="ln1970">    ostringstream dest;</a>
<a name="ln1971"> </a>
<a name="ln1972">    if (!skip_branch)</a>
<a name="ln1973">        dest &lt;&lt; branch;</a>
<a name="ln1974">    if (brdepth[branch_id] != 1)</a>
<a name="ln1975">    {</a>
<a name="ln1976">        if (!skip_branch)</a>
<a name="ln1977">            dest &lt;&lt; &quot;:&quot;;</a>
<a name="ln1978">        dest &lt;&lt; target.id.depth;</a>
<a name="ln1979">    }</a>
<a name="ln1980">    if (target.pos.x != -1 &amp;&amp; !skip_coord)</a>
<a name="ln1981">        dest &lt;&lt; &quot; @ (x,y)&quot;;</a>
<a name="ln1982"> </a>
<a name="ln1983">    return dest.str();</a>
<a name="ln1984">}</a>
<a name="ln1985"> </a>
<a name="ln1986">// Returns the level on the given branch that's closest to the player's</a>
<a name="ln1987">// current location.</a>
<a name="ln1988">static int _get_nearest_level_depth(uint8_t branch)</a>
<a name="ln1989">{</a>
<a name="ln1990">    int depth = 1;</a>
<a name="ln1991"> </a>
<a name="ln1992">    // Hell needs special treatment, because we can't walk up</a>
<a name="ln1993">    // Hell and its branches to the main dungeon.</a>
<a name="ln1994">    if (branch == BRANCH_DEPTHS</a>
<a name="ln1995">        &amp;&amp; (player_in_branch(BRANCH_VESTIBULE)</a>
<a name="ln1996">            || player_in_branch(BRANCH_COCYTUS)</a>
<a name="ln1997">            || player_in_branch(BRANCH_TARTARUS)</a>
<a name="ln1998">            || player_in_branch(BRANCH_DIS)</a>
<a name="ln1999">            || player_in_branch(BRANCH_GEHENNA)))</a>
<a name="ln2000">    {</a>
<a name="ln2001">        // BUG: hell gates in the Lair</a>
<a name="ln2002">        return brentry[BRANCH_VESTIBULE].depth;</a>
<a name="ln2003">    }</a>
<a name="ln2004"> </a>
<a name="ln2005">    level_id id = level_id::current();</a>
<a name="ln2006">    do</a>
<a name="ln2007">    {</a>
<a name="ln2008">        _find_parent_branch(id.branch, &amp;id.branch, &amp;id.depth);</a>
<a name="ln2009">        if (id.depth &amp;&amp; id.branch == branch)</a>
<a name="ln2010">        {</a>
<a name="ln2011">            depth = id.depth;</a>
<a name="ln2012">            break;</a>
<a name="ln2013">        }</a>
<a name="ln2014">    }</a>
<a name="ln2015">    while (id.depth);</a>
<a name="ln2016"> </a>
<a name="ln2017">    return depth;</a>
<a name="ln2018">}</a>
<a name="ln2019"> </a>
<a name="ln2020">// Returns true if the player character knows of the existence of the given</a>
<a name="ln2021">// branch (which would make the branch a valid target for interlevel travel).</a>
<a name="ln2022">bool is_known_branch_id(branch_type branch)</a>
<a name="ln2023">{</a>
<a name="ln2024">    // The main dungeon is always known</a>
<a name="ln2025">    if (branch == root_branch)</a>
<a name="ln2026">        return true;</a>
<a name="ln2027"> </a>
<a name="ln2028">    // If we're in the branch, it darn well is known.</a>
<a name="ln2029">    if (player_in_branch(branch))</a>
<a name="ln2030">        return true;</a>
<a name="ln2031"> </a>
<a name="ln2032">    // The Vestibule is special: there are no stairs to it, just a</a>
<a name="ln2033">    // portal.</a>
<a name="ln2034">    if (branch == BRANCH_VESTIBULE)</a>
<a name="ln2035">        return overview_knows_portal(branch);</a>
<a name="ln2036"> </a>
<a name="ln2037">    // Guaranteed portal vault, don't show in interlevel travel.</a>
<a name="ln2038">    if (branch == BRANCH_ZIGGURAT)</a>
<a name="ln2039">        return false;</a>
<a name="ln2040"> </a>
<a name="ln2041">    // If the overview knows the stairs to this branch, we know the branch.</a>
<a name="ln2042">    return stair_level.find(static_cast&lt;branch_type&gt;(branch))</a>
<a name="ln2043">           != stair_level.end() &amp;&amp; stair_level[branch].size();</a>
<a name="ln2044">}</a>
<a name="ln2045"> </a>
<a name="ln2046">static bool _is_known_branch(const Branch &amp;br)</a>
<a name="ln2047">{</a>
<a name="ln2048">    return is_known_branch_id(br.id);</a>
<a name="ln2049">}</a>
<a name="ln2050"> </a>
<a name="ln2051">// Returns a list of the branches that the player knows the location of the</a>
<a name="ln2052">// stairs to, in the same order as dgn-overview.cc lists them.</a>
<a name="ln2053">static vector&lt;branch_type&gt; _get_branches(bool (*selector)(const Branch &amp;))</a>
<a name="ln2054">{</a>
<a name="ln2055">    vector&lt;branch_type&gt; result;</a>
<a name="ln2056"> </a>
<a name="ln2057">    for (branch_iterator it; it; ++it)</a>
<a name="ln2058">        if (selector(**it))</a>
<a name="ln2059">            result.push_back(it-&gt;id);</a>
<a name="ln2060"> </a>
<a name="ln2061">    return result;</a>
<a name="ln2062">}</a>
<a name="ln2063"> </a>
<a name="ln2064">static bool _is_valid_branch(const Branch &amp;br)</a>
<a name="ln2065">{</a>
<a name="ln2066">    return br.shortname != nullptr &amp;&amp; brdepth[br.id] != -1;</a>
<a name="ln2067">}</a>
<a name="ln2068"> </a>
<a name="ln2069">static bool _is_disconnected_branch(const Branch &amp;br)</a>
<a name="ln2070">{</a>
<a name="ln2071">    return !is_connected_branch(br.id);</a>
<a name="ln2072">}</a>
<a name="ln2073"> </a>
<a name="ln2074">static int _prompt_travel_branch(int prompt_flags)</a>
<a name="ln2075">{</a>
<a name="ln2076">    int branch = BRANCH_DUNGEON;     // Default</a>
<a name="ln2077">    vector&lt;branch_type&gt; brs =</a>
<a name="ln2078">        _get_branches(</a>
<a name="ln2079">            (prompt_flags &amp; TPF_SHOW_ALL_BRANCHES) ? _is_valid_branch :</a>
<a name="ln2080">            (prompt_flags &amp; TPF_SHOW_PORTALS_ONLY) ? _is_disconnected_branch</a>
<a name="ln2081">                                                   : _is_known_branch);</a>
<a name="ln2082"> </a>
<a name="ln2083">    // Don't kill the prompt even if the only branch we know is the main dungeon</a>
<a name="ln2084">    // This keeps things consistent for the player.</a>
<a name="ln2085">    if (brs.size() &lt; 1)</a>
<a name="ln2086">        return branch;</a>
<a name="ln2087"> </a>
<a name="ln2088">    const bool allow_waypoints = (prompt_flags &amp; TPF_ALLOW_WAYPOINTS);</a>
<a name="ln2089">    const bool allow_updown    = (prompt_flags &amp; TPF_ALLOW_UPDOWN);</a>
<a name="ln2090">    const bool remember_targ   = (prompt_flags &amp; TPF_REMEMBER_TARGET);</a>
<a name="ln2091"> </a>
<a name="ln2092">    bool waypoint_list = false;</a>
<a name="ln2093">    const int waycount = allow_waypoints? travel_cache.get_waypoint_count() : 0;</a>
<a name="ln2094"> </a>
<a name="ln2095">    level_id curr = level_id::current();</a>
<a name="ln2096">    while (true)</a>
<a name="ln2097">    {</a>
<a name="ln2098">        clear_messages();</a>
<a name="ln2099"> </a>
<a name="ln2100">        if (waypoint_list)</a>
<a name="ln2101">            travel_cache.list_waypoints();</a>
<a name="ln2102">        else</a>
<a name="ln2103">        {</a>
<a name="ln2104">            int linec = 0;</a>
<a name="ln2105">            string line;</a>
<a name="ln2106">            for (branch_type br : brs)</a>
<a name="ln2107">            {</a>
<a name="ln2108">                if (linec == 4)</a>
<a name="ln2109">                {</a>
<a name="ln2110">                    linec = 0;</a>
<a name="ln2111">                    mpr(line);</a>
<a name="ln2112">                    line = &quot;&quot;;</a>
<a name="ln2113">                }</a>
<a name="ln2114">                line += make_stringf(&quot;(%c) %-14s &quot;,</a>
<a name="ln2115">                                     branches[br].travel_shortcut,</a>
<a name="ln2116">                                     branches[br].shortname);</a>
<a name="ln2117">                ++linec;</a>
<a name="ln2118">            }</a>
<a name="ln2119">            if (!line.empty())</a>
<a name="ln2120">                mpr(line);</a>
<a name="ln2121">        }</a>
<a name="ln2122"> </a>
<a name="ln2123">        string shortcuts = &quot;(&quot;;</a>
<a name="ln2124">        {</a>
<a name="ln2125">            vector&lt;string&gt; segs;</a>
<a name="ln2126">            if (allow_waypoints)</a>
<a name="ln2127">            {</a>
<a name="ln2128">                if (waypoint_list)</a>
<a name="ln2129">                    segs.emplace_back(&quot;* - list branches&quot;);</a>
<a name="ln2130">                else if (waycount)</a>
<a name="ln2131">                    segs.emplace_back(&quot;* - list waypoints&quot;);</a>
<a name="ln2132">            }</a>
<a name="ln2133"> </a>
<a name="ln2134">            if (!trans_travel_dest.empty() &amp;&amp; remember_targ)</a>
<a name="ln2135">            {</a>
<a name="ln2136">                segs.push_back(</a>
<a name="ln2137">                    make_stringf(&quot;Enter - %s&quot;, trans_travel_dest.c_str()));</a>
<a name="ln2138">            }</a>
<a name="ln2139"> </a>
<a name="ln2140">            segs.emplace_back(&quot;? - help&quot;);</a>
<a name="ln2141"> </a>
<a name="ln2142">            shortcuts += comma_separated_line(segs.begin(), segs.end(),</a>
<a name="ln2143">                                              &quot;, &quot;, &quot;, &quot;);</a>
<a name="ln2144">            shortcuts += &quot;) &quot;;</a>
<a name="ln2145">        }</a>
<a name="ln2146">        mprf(MSGCH_PROMPT, &quot;Where to? %s&quot;,</a>
<a name="ln2147">             shortcuts.c_str());</a>
<a name="ln2148"> </a>
<a name="ln2149">        int keyin = get_ch();</a>
<a name="ln2150">        switch (keyin)</a>
<a name="ln2151">        {</a>
<a name="ln2152">        CASE_ESCAPE</a>
<a name="ln2153">            return ID_CANCEL;</a>
<a name="ln2154">        case '?':</a>
<a name="ln2155">            show_interlevel_travel_branch_help();</a>
<a name="ln2156">            redraw_screen();</a>
<a name="ln2157">            break;</a>
<a name="ln2158">        case '_':</a>
<a name="ln2159">            return ID_ALTAR;</a>
<a name="ln2160">        case '\n': case '\r':</a>
<a name="ln2161">            return ID_REPEAT;</a>
<a name="ln2162">        case '&lt;':</a>
<a name="ln2163">            return allow_updown ? ID_UP : ID_CANCEL;</a>
<a name="ln2164">        case '&gt;':</a>
<a name="ln2165">            return allow_updown ? ID_DOWN : ID_CANCEL;</a>
<a name="ln2166">        case CONTROL('P'):</a>
<a name="ln2167">            {</a>
<a name="ln2168">                const branch_type parent = parent_branch(curr.branch);</a>
<a name="ln2169">                if (parent &lt; NUM_BRANCHES)</a>
<a name="ln2170">                    return parent;</a>
<a name="ln2171">            }</a>
<a name="ln2172">            break;</a>
<a name="ln2173">        case '.':</a>
<a name="ln2174">            return curr.branch;</a>
<a name="ln2175">        case '*':</a>
<a name="ln2176">            if (waypoint_list || waycount)</a>
<a name="ln2177">                waypoint_list = !waypoint_list;</a>
<a name="ln2178">            break;</a>
<a name="ln2179">        default:</a>
<a name="ln2180">            // Is this a branch hotkey?</a>
<a name="ln2181">            for (branch_type br : brs)</a>
<a name="ln2182">            {</a>
<a name="ln2183">                if (toupper_safe(keyin) == branches[br].travel_shortcut)</a>
<a name="ln2184">                {</a>
<a name="ln2185">#ifdef WIZARD</a>
<a name="ln2186">                    const Branch &amp;target = branches[br];</a>
<a name="ln2187">                    string msg;</a>
<a name="ln2188"> </a>
<a name="ln2189">                    if (!brentry[br].is_valid()</a>
<a name="ln2190">                        &amp;&amp; is_random_subbranch(br)</a>
<a name="ln2191">                        &amp;&amp; you.wizard) // don't leak mimics</a>
<a name="ln2192">                    {</a>
<a name="ln2193">                        msg += &quot;Branch not generated this game. &quot;;</a>
<a name="ln2194">                    }</a>
<a name="ln2195"> </a>
<a name="ln2196">                    if (target.entry_stairs == NUM_FEATURES</a>
<a name="ln2197">                        &amp;&amp; br != BRANCH_DUNGEON)</a>
<a name="ln2198">                    {</a>
<a name="ln2199">                        msg += &quot;Branch has no entry stairs. &quot;;</a>
<a name="ln2200">                    }</a>
<a name="ln2201"> </a>
<a name="ln2202">                    if (!msg.empty())</a>
<a name="ln2203">                    {</a>
<a name="ln2204">                        msg += &quot;Go there anyway?&quot;;</a>
<a name="ln2205">                        if (!yesno(msg.c_str(), true, 'n'))</a>
<a name="ln2206">                            return ID_CANCEL;</a>
<a name="ln2207">                    }</a>
<a name="ln2208">#endif</a>
<a name="ln2209">                    return br;</a>
<a name="ln2210">                }</a>
<a name="ln2211">            }</a>
<a name="ln2212"> </a>
<a name="ln2213">            // Possibly a waypoint number?</a>
<a name="ln2214">            if (allow_waypoints &amp;&amp; keyin &gt;= '0' &amp;&amp; keyin &lt;= '9')</a>
<a name="ln2215">                return -1 - (keyin - '0');</a>
<a name="ln2216"> </a>
<a name="ln2217">            return ID_CANCEL;</a>
<a name="ln2218">        }</a>
<a name="ln2219">    }</a>
<a name="ln2220">}</a>
<a name="ln2221"> </a>
<a name="ln2222">static god_type _god_from_initial(const char god_initial)</a>
<a name="ln2223">{</a>
<a name="ln2224">    switch (toupper_safe(god_initial))</a>
<a name="ln2225">    {</a>
<a name="ln2226">        case '1': return GOD_SHINING_ONE;</a>
<a name="ln2227">        case 'A': return GOD_ASHENZARI;</a>
<a name="ln2228">        case 'B': return GOD_BEOGH;</a>
<a name="ln2229">        case 'C': return GOD_CHEIBRIADOS;</a>
<a name="ln2230">        case 'D': return GOD_DITHMENOS;</a>
<a name="ln2231">        case 'E': return GOD_ELYVILON;</a>
<a name="ln2232">        case 'F': return GOD_FEDHAS;</a>
<a name="ln2233">        case 'G': return GOD_GOZAG;</a>
<a name="ln2234">        case 'H': return GOD_HEPLIAKLQANA;</a>
<a name="ln2235">        case 'J': return GOD_JIYVA;</a>
<a name="ln2236">        case 'K': return GOD_KIKUBAAQUDGHA;</a>
<a name="ln2237">        case 'L': return GOD_LUGONU;</a>
<a name="ln2238">        case 'M': return GOD_MAKHLEB;</a>
<a name="ln2239">        case 'N': return GOD_NEMELEX_XOBEH;</a>
<a name="ln2240">        case 'O': return GOD_OKAWARU;</a>
<a name="ln2241">#if TAG_MAJOR_VERSION == 34</a>
<a name="ln2242">        case 'P': return GOD_PAKELLAS;</a>
<a name="ln2243">#endif</a>
<a name="ln2244">        case 'Q': return GOD_QAZLAL;</a>
<a name="ln2245">        case 'R': return GOD_RU;</a>
<a name="ln2246">        case 'S': return GOD_SIF_MUNA;</a>
<a name="ln2247">        case 'T': return GOD_TROG;</a>
<a name="ln2248">        case 'U': return GOD_USKAYAW;</a>
<a name="ln2249">        case 'V': return GOD_VEHUMET;</a>
<a name="ln2250">        case 'W': return GOD_WU_JIAN;</a>
<a name="ln2251">        case 'X': return GOD_XOM;</a>
<a name="ln2252">        case 'Y': return GOD_YREDELEMNUL;</a>
<a name="ln2253">        case 'Z': return GOD_ZIN;</a>
<a name="ln2254">        default:  return GOD_NO_GOD;</a>
<a name="ln2255">    }</a>
<a name="ln2256">}</a>
<a name="ln2257"> </a>
<a name="ln2258">static level_pos _prompt_travel_altar()</a>
<a name="ln2259">{</a>
<a name="ln2260">    extern map&lt;level_pos, god_type&gt; altars_present;</a>
<a name="ln2261"> </a>
<a name="ln2262">    if (altars_present.empty())</a>
<a name="ln2263">        return level_pos();</a>
<a name="ln2264"> </a>
<a name="ln2265">    level_pos nearest_altars[NUM_GODS];</a>
<a name="ln2266">    const level_id curr = level_id::current();</a>
<a name="ln2267"> </a>
<a name="ln2268">    // Populate nearest_altars[] with nearest altars</a>
<a name="ln2269">    for (const auto &amp;entry : altars_present)</a>
<a name="ln2270">    {</a>
<a name="ln2271">        // This is necessary because faded altars (i.e., GOD_ECUMENICAL)</a>
<a name="ln2272">        // are also recorded in altars_present</a>
<a name="ln2273">        if (entry.second &gt;= NUM_GODS)</a>
<a name="ln2274">            continue;</a>
<a name="ln2275"> </a>
<a name="ln2276">        int dist = level_distance(curr, entry.first.id);</a>
<a name="ln2277">        if (dist == -1)</a>
<a name="ln2278">            continue;</a>
<a name="ln2279"> </a>
<a name="ln2280">        level_pos *best = &amp;nearest_altars[entry.second];</a>
<a name="ln2281">        int old_dist = best-&gt;id.is_valid() ? level_distance(curr, best-&gt;id) : INT_MAX;</a>
<a name="ln2282"> </a>
<a name="ln2283">        if (dist &lt; old_dist)</a>
<a name="ln2284">            *best = entry.first;</a>
<a name="ln2285">    }</a>
<a name="ln2286"> </a>
<a name="ln2287">    while (true)</a>
<a name="ln2288">    {</a>
<a name="ln2289">        clear_messages();</a>
<a name="ln2290"> </a>
<a name="ln2291">        int col = 0;</a>
<a name="ln2292">        string line;</a>
<a name="ln2293">        string altar_name;</a>
<a name="ln2294">        char god_initial;</a>
<a name="ln2295">        vector&lt;god_type&gt; god_list = temple_god_list();</a>
<a name="ln2296">        vector&lt;god_type&gt; nt_god_list = nontemple_god_list();</a>
<a name="ln2297">        god_list.insert(god_list.end(), nt_god_list.begin(), nt_god_list.end());</a>
<a name="ln2298"> </a>
<a name="ln2299">        // list gods in the same order as dgn-overview.cc lists them.</a>
<a name="ln2300">        for (const god_type god : god_list)</a>
<a name="ln2301">        {</a>
<a name="ln2302">            if (!nearest_altars[god].is_valid())</a>
<a name="ln2303">                continue;</a>
<a name="ln2304"> </a>
<a name="ln2305">            // &quot;The Shining One&quot; is too long to keep the same G menu layout</a>
<a name="ln2306">            altar_name  = god == GOD_SHINING_ONE ? &quot;TSO&quot; : god_name(god);</a>
<a name="ln2307">            god_initial = god == GOD_SHINING_ONE ? '1'   : altar_name.at(0);</a>
<a name="ln2308"> </a>
<a name="ln2309">            if (col == 4)</a>
<a name="ln2310">            {</a>
<a name="ln2311">                col = 0;</a>
<a name="ln2312">                mpr(line);</a>
<a name="ln2313">                line = &quot;&quot;;</a>
<a name="ln2314">            }</a>
<a name="ln2315">            line += make_stringf(&quot;(%c) %-14s &quot;, god_initial, altar_name.c_str());</a>
<a name="ln2316">            ++col;</a>
<a name="ln2317">        }</a>
<a name="ln2318">        if (!line.empty())</a>
<a name="ln2319">            mpr(line);</a>
<a name="ln2320"> </a>
<a name="ln2321">        mprf(MSGCH_PROMPT, &quot;Go to which altar? (? - help) &quot;);</a>
<a name="ln2322"> </a>
<a name="ln2323">        int keyin = get_ch();</a>
<a name="ln2324">        switch (keyin)</a>
<a name="ln2325">        {</a>
<a name="ln2326">            CASE_ESCAPE</a>
<a name="ln2327">                return level_pos();</a>
<a name="ln2328">            case '?':</a>
<a name="ln2329">                show_interlevel_travel_altar_help();</a>
<a name="ln2330">                redraw_screen();</a>
<a name="ln2331">                break;</a>
<a name="ln2332">            case '\n': case '\r':</a>
<a name="ln2333">                return level_target;</a>
<a name="ln2334">            default:</a>
<a name="ln2335">                const level_pos altar_pos = nearest_altars[_god_from_initial(keyin)];</a>
<a name="ln2336">                if (altar_pos.is_valid())</a>
<a name="ln2337">                    return altar_pos;</a>
<a name="ln2338"> </a>
<a name="ln2339">                return level_pos();</a>
<a name="ln2340">        }</a>
<a name="ln2341">    }</a>
<a name="ln2342">}</a>
<a name="ln2343"> </a>
<a name="ln2344">level_id find_up_level(level_id curr, bool up_branch)</a>
<a name="ln2345">{</a>
<a name="ln2346">    --curr.depth;</a>
<a name="ln2347"> </a>
<a name="ln2348">    if (up_branch)</a>
<a name="ln2349">        curr.depth = 0;</a>
<a name="ln2350"> </a>
<a name="ln2351">    if (curr.depth &lt; 1)</a>
<a name="ln2352">    {</a>
<a name="ln2353">        if (curr.branch != BRANCH_DUNGEON &amp;&amp; curr.branch != root_branch)</a>
<a name="ln2354">        {</a>
<a name="ln2355">            level_id parent;</a>
<a name="ln2356">            _find_parent_branch(curr.branch, &amp;parent.branch, &amp;parent.depth);</a>
<a name="ln2357">            if (parent.depth &gt; 0)</a>
<a name="ln2358">                return parent;</a>
<a name="ln2359">            else if (curr.branch == BRANCH_VESTIBULE)</a>
<a name="ln2360">                return brentry[BRANCH_VESTIBULE];</a>
<a name="ln2361">        }</a>
<a name="ln2362">        return level_id();</a>
<a name="ln2363">    }</a>
<a name="ln2364"> </a>
<a name="ln2365">    return curr;</a>
<a name="ln2366">}</a>
<a name="ln2367"> </a>
<a name="ln2368">static level_id _find_up_level()</a>
<a name="ln2369">{</a>
<a name="ln2370">    return find_up_level(level_id::current());</a>
<a name="ln2371">}</a>
<a name="ln2372"> </a>
<a name="ln2373">level_id find_down_level(level_id curr)</a>
<a name="ln2374">{</a>
<a name="ln2375">    if (curr.depth &lt; brdepth[curr.branch])</a>
<a name="ln2376">        ++curr.depth;</a>
<a name="ln2377">    return curr;</a>
<a name="ln2378">}</a>
<a name="ln2379"> </a>
<a name="ln2380">level_id find_deepest_explored(level_id curr)</a>
<a name="ln2381">{</a>
<a name="ln2382">    ASSERT(curr.branch != NUM_BRANCHES);</a>
<a name="ln2383"> </a>
<a name="ln2384">    for (int i = brdepth[curr.branch]; i &gt; 0; --i)</a>
<a name="ln2385">    {</a>
<a name="ln2386">        const level_id lid(curr.branch, i);</a>
<a name="ln2387">        LevelInfo *linf = travel_cache.find_level_info(lid);</a>
<a name="ln2388">        if (linf &amp;&amp; !linf-&gt;empty())</a>
<a name="ln2389">            return lid;</a>
<a name="ln2390">    }</a>
<a name="ln2391"> </a>
<a name="ln2392">    // If the player's currently in the same place, report their current</a>
<a name="ln2393">    // level_id if the travel cache hasn't been updated.</a>
<a name="ln2394">    const level_id player_level = level_id::current();</a>
<a name="ln2395">    if (player_level == curr.branch)</a>
<a name="ln2396">        return player_level;</a>
<a name="ln2397"> </a>
<a name="ln2398">    return curr;</a>
<a name="ln2399">}</a>
<a name="ln2400"> </a>
<a name="ln2401">bool branch_entered(branch_type branch)</a>
<a name="ln2402">{</a>
<a name="ln2403">    const level_id lid(branch, 1);</a>
<a name="ln2404">    LevelInfo *linf = travel_cache.find_level_info(lid);</a>
<a name="ln2405">    return linf &amp;&amp; !linf-&gt;empty();</a>
<a name="ln2406">}</a>
<a name="ln2407"> </a>
<a name="ln2408">static level_id _find_down_level()</a>
<a name="ln2409">{</a>
<a name="ln2410">    return find_down_level(level_id::current());</a>
<a name="ln2411">}</a>
<a name="ln2412"> </a>
<a name="ln2413">static keyfun_action _travel_depth_keyfilter(int &amp;c)</a>
<a name="ln2414">{</a>
<a name="ln2415">    switch (c)</a>
<a name="ln2416">    {</a>
<a name="ln2417">    case '&lt;': case '&gt;': case '?': case '$': case '^':</a>
<a name="ln2418">        return KEYFUN_BREAK;</a>
<a name="ln2419">    case '-':</a>
<a name="ln2420">    case CONTROL('P'): case 'p':</a>
<a name="ln2421">        c = '-';  // Make uniform.</a>
<a name="ln2422">        return KEYFUN_BREAK;</a>
<a name="ln2423">    default:</a>
<a name="ln2424">        return KEYFUN_PROCESS;</a>
<a name="ln2425">    }</a>
<a name="ln2426">}</a>
<a name="ln2427"> </a>
<a name="ln2428">static level_pos _find_entrance(const level_pos &amp;from)</a>
<a name="ln2429">{</a>
<a name="ln2430">    level_id lid(from.id);</a>
<a name="ln2431">    coord_def pos(-1, -1);</a>
<a name="ln2432">    branch_type target_branch = lid.branch;</a>
<a name="ln2433"> </a>
<a name="ln2434">    lid.depth = 1;</a>
<a name="ln2435">    level_id new_lid = find_up_level(lid);</a>
<a name="ln2436"> </a>
<a name="ln2437">    if (new_lid.is_valid())</a>
<a name="ln2438">    {</a>
<a name="ln2439">        LevelInfo &amp;li = travel_cache.get_level_info(new_lid);</a>
<a name="ln2440">        vector&lt;stair_info&gt; &amp;stairs = li.get_stairs();</a>
<a name="ln2441">        for (const auto &amp;stair : stairs)</a>
<a name="ln2442">            if (stair.destination.id.branch == target_branch)</a>
<a name="ln2443">            {</a>
<a name="ln2444">                pos = stair.position;</a>
<a name="ln2445">                break;</a>
<a name="ln2446">            }</a>
<a name="ln2447">#ifdef DEBUG_TRAVEL</a>
<a name="ln2448">        dprf(&quot;found entrance in %d depth %d at %d,%d&quot;, new_lid.branch,</a>
<a name="ln2449">            new_lid.depth, pos.x, pos.y);</a>
<a name="ln2450">#endif</a>
<a name="ln2451">        return level_pos(new_lid, pos);</a>
<a name="ln2452">    }</a>
<a name="ln2453">    else</a>
<a name="ln2454">    {</a>
<a name="ln2455">        LevelInfo &amp;li = travel_cache.get_level_info(lid);</a>
<a name="ln2456">        vector&lt;stair_info&gt; &amp;stairs = li.get_stairs();</a>
<a name="ln2457">        for (const auto &amp;stair : stairs)</a>
<a name="ln2458">            if (!stair.destination.id.is_valid())</a>
<a name="ln2459">            {</a>
<a name="ln2460">                pos = stair.position;</a>
<a name="ln2461">                break;</a>
<a name="ln2462">            }</a>
<a name="ln2463">#ifdef DEBUG_TRAVEL</a>
<a name="ln2464">        dprf(&quot;found entrance in %d depth %d at %d,%d&quot;, lid.branch, lid.depth,</a>
<a name="ln2465">            pos.x, pos.y);</a>
<a name="ln2466">#endif</a>
<a name="ln2467">        return level_pos(lid, pos);</a>
<a name="ln2468">    }</a>
<a name="ln2469">}</a>
<a name="ln2470"> </a>
<a name="ln2471">/*</a>
<a name="ln2472"> * Given a string and a starting target, find a `level_pos` to travel to.</a>
<a name="ln2473"> *</a>
<a name="ln2474"> * @param s a string consisting of a number representing depth, or 0 to go to</a>
<a name="ln2475"> *          the branch entrance.</a>
<a name="ln2476"> * @param targ an initial default `level_pos` to potentially modify.</a>
<a name="ln2477"> *</a>
<a name="ln2478"> * @return the resulting `level_pos`.</a>
<a name="ln2479"> */</a>
<a name="ln2480">static level_pos _parse_travel_target(string s, const level_pos &amp;targ)</a>
<a name="ln2481">{</a>
<a name="ln2482">    trim_string(s);</a>
<a name="ln2483">    level_pos result(targ);</a>
<a name="ln2484"> </a>
<a name="ln2485">    if (!s.empty())</a>
<a name="ln2486">    {</a>
<a name="ln2487">        result.id.depth = atoi(s.c_str());</a>
<a name="ln2488">        result.pos.x = result.pos.y = -1;</a>
<a name="ln2489">    }</a>
<a name="ln2490"> </a>
<a name="ln2491">    if (!result.id.depth)</a>
<a name="ln2492">        result = _find_entrance(result);</a>
<a name="ln2493"> </a>
<a name="ln2494">    return result;</a>
<a name="ln2495">}</a>
<a name="ln2496"> </a>
<a name="ln2497">/*</a>
<a name="ln2498"> * Interpret the player's input to the interlevel travel prompt.</a>
<a name="ln2499"> * This input consists either of a numeric string, or one of several special</a>
<a name="ln2500"> * characters that manipulate a destination that can be triggered by enter.</a>
<a name="ln2501"> * This function can process both at the same time, though simple numeric input</a>
<a name="ln2502"> * without a special key is handled separately in `_prompt_travel_depth`.</a>
<a name="ln2503"> *</a>
<a name="ln2504"> * @param munge_method  a non-level special key input at the prompt to process.</a>
<a name="ln2505"> * @param s             a numeric depth input at the prompt to process.</a>
<a name="ln2506"> * @param targ          an input `level_pos` representing the current default</a>
<a name="ln2507"> *                      target.</a>
<a name="ln2508"> *</a>
<a name="ln2509"> * @return a `level_pos` indicating the resulting target, potentially the same</a>
<a name="ln2510"> *                       as `targ`.</a>
<a name="ln2511"> */</a>
<a name="ln2512">static level_pos _travel_depth_munge(int munge_method, const string &amp;s,</a>
<a name="ln2513">                                const level_pos &amp;targ)</a>
<a name="ln2514">{</a>
<a name="ln2515">    level_pos result(targ.id); // drop any coords in `targ`.</a>
<a name="ln2516">    result = _parse_travel_target(s, result);</a>
<a name="ln2517"> </a>
<a name="ln2518">    switch (munge_method)</a>
<a name="ln2519">    {</a>
<a name="ln2520">    case '?':</a>
<a name="ln2521">        show_interlevel_travel_depth_help();</a>
<a name="ln2522">        redraw_screen();</a>
<a name="ln2523">        return level_pos(targ); // no change</a>
<a name="ln2524">    case '&lt;':</a>
<a name="ln2525">        result.id = find_up_level(result.id);</a>
<a name="ln2526">        break;</a>
<a name="ln2527">    case '&gt;':</a>
<a name="ln2528">        result.id = find_down_level(result.id);</a>
<a name="ln2529">        break;</a>
<a name="ln2530">    case '-':</a>
<a name="ln2531">        result.id = find_up_level(result.id, true);</a>
<a name="ln2532">        break;</a>
<a name="ln2533">    case '$':</a>
<a name="ln2534">        result.id = find_deepest_explored(result.id);</a>
<a name="ln2535">        break;</a>
<a name="ln2536">    case '^':</a>
<a name="ln2537">        result = _find_entrance(result);</a>
<a name="ln2538">        break;</a>
<a name="ln2539">    }</a>
<a name="ln2540">    if (result.id.depth &lt; 1)</a>
<a name="ln2541">        result.id.depth = 1;</a>
<a name="ln2542">    return result;</a>
<a name="ln2543">}</a>
<a name="ln2544"> </a>
<a name="ln2545">static level_pos _prompt_travel_depth(const level_id &amp;id)</a>
<a name="ln2546">{</a>
<a name="ln2547">    level_pos target = level_pos(id);</a>
<a name="ln2548"> </a>
<a name="ln2549">    // Handle one-level branches by not prompting.</a>
<a name="ln2550">    if (single_level_branch(target.id.branch))</a>
<a name="ln2551">        return level_pos(level_id(target.id.branch, 1));</a>
<a name="ln2552"> </a>
<a name="ln2553">    target.id.depth = _get_nearest_level_depth(target.id.branch);</a>
<a name="ln2554">    while (true)</a>
<a name="ln2555">    {</a>
<a name="ln2556">        clear_messages();</a>
<a name="ln2557">        mprf(MSGCH_PROMPT, &quot;What level of %s? &quot;</a>
<a name="ln2558">             &quot;(default %s, ? - help) &quot;,</a>
<a name="ln2559">             branches[target.id.branch].longname,</a>
<a name="ln2560">             _get_trans_travel_dest(target, true).c_str());</a>
<a name="ln2561"> </a>
<a name="ln2562">        char buf[100];</a>
<a name="ln2563">        const int response =</a>
<a name="ln2564">            cancellable_get_line(buf, sizeof buf, nullptr,</a>
<a name="ln2565">                                 _travel_depth_keyfilter, &quot;&quot;, &quot;travel_depth&quot;);</a>
<a name="ln2566"> </a>
<a name="ln2567">        if (!response)</a>
<a name="ln2568">            return _parse_travel_target(buf, target);</a>
<a name="ln2569"> </a>
<a name="ln2570">        if (key_is_escape(response))</a>
<a name="ln2571">            return level_pos(level_id(BRANCH_DUNGEON, 0));</a>
<a name="ln2572"> </a>
<a name="ln2573">        target = _travel_depth_munge(response, buf, target);</a>
<a name="ln2574">    }</a>
<a name="ln2575">}</a>
<a name="ln2576"> </a>
<a name="ln2577">level_pos prompt_translevel_target(int prompt_flags, string&amp; dest_name)</a>
<a name="ln2578">{</a>
<a name="ln2579">    level_pos target;</a>
<a name="ln2580">    int branch = _prompt_travel_branch(prompt_flags);</a>
<a name="ln2581">    const bool remember_targ = (prompt_flags &amp; TPF_REMEMBER_TARGET);</a>
<a name="ln2582"> </a>
<a name="ln2583">    if (branch == ID_CANCEL)</a>
<a name="ln2584">        return target;</a>
<a name="ln2585"> </a>
<a name="ln2586">    if (branch == ID_ALTAR)</a>
<a name="ln2587">        return _prompt_travel_altar();</a>
<a name="ln2588"> </a>
<a name="ln2589">    // If user chose to repeat last travel, return that.</a>
<a name="ln2590">    if (branch == ID_REPEAT)</a>
<a name="ln2591">        return level_target;</a>
<a name="ln2592"> </a>
<a name="ln2593">    if (branch == ID_UP)</a>
<a name="ln2594">    {</a>
<a name="ln2595">        target = _find_up_level();</a>
<a name="ln2596">        if (target.id.depth &gt; 0 &amp;&amp; remember_targ)</a>
<a name="ln2597">            dest_name = _get_trans_travel_dest(target);</a>
<a name="ln2598">        return target;</a>
<a name="ln2599">    }</a>
<a name="ln2600"> </a>
<a name="ln2601">    if (branch == ID_DOWN)</a>
<a name="ln2602">    {</a>
<a name="ln2603">        target = _find_down_level();</a>
<a name="ln2604">        if (target.id.depth &gt; 0 &amp;&amp; remember_targ)</a>
<a name="ln2605">            dest_name = _get_trans_travel_dest(target);</a>
<a name="ln2606">        return target;</a>
<a name="ln2607">    }</a>
<a name="ln2608"> </a>
<a name="ln2609">    if (branch &lt; 0)</a>
<a name="ln2610">    {</a>
<a name="ln2611">        target = travel_cache.get_waypoint(-branch - 1);</a>
<a name="ln2612">        if (target.id.depth &gt; 0 &amp;&amp; remember_targ)</a>
<a name="ln2613">            dest_name = _get_trans_travel_dest(target);</a>
<a name="ln2614">        return target;</a>
<a name="ln2615">    }</a>
<a name="ln2616"> </a>
<a name="ln2617">    target.id.branch = static_cast&lt;branch_type&gt;(branch);</a>
<a name="ln2618"> </a>
<a name="ln2619">    // User's chosen a branch, so now we ask for a level.</a>
<a name="ln2620">    target = _prompt_travel_depth(target.id);</a>
<a name="ln2621"> </a>
<a name="ln2622">    if (target.id.depth &lt; 1</a>
<a name="ln2623">        || target.id.depth &gt; brdepth[target.id.branch])</a>
<a name="ln2624">    {</a>
<a name="ln2625">        target.id.depth = -1;</a>
<a name="ln2626">    }</a>
<a name="ln2627"> </a>
<a name="ln2628">    if (target.id.depth &gt; -1 &amp;&amp; remember_targ)</a>
<a name="ln2629">        dest_name = _get_trans_travel_dest(target);</a>
<a name="ln2630"> </a>
<a name="ln2631">#ifdef DEBUG_TRAVEL</a>
<a name="ln2632">    dprf(&quot;level target is %d depth %d, pos %d,%d&quot;, target.id.branch,</a>
<a name="ln2633">        target.id.branch, target.pos.x, target.pos.y);</a>
<a name="ln2634">#endif</a>
<a name="ln2635"> </a>
<a name="ln2636">    return target;</a>
<a name="ln2637">}</a>
<a name="ln2638"> </a>
<a name="ln2639">static void _start_translevel_travel()</a>
<a name="ln2640">{</a>
<a name="ln2641">    // Update information for this level.</a>
<a name="ln2642">    travel_cache.get_level_info(level_id::current()).update();</a>
<a name="ln2643"> </a>
<a name="ln2644">    if (level_id::current() == level_target.id)</a>
<a name="ln2645">    {</a>
<a name="ln2646">        if (level_target.pos.x == -1 &amp;&amp;</a>
<a name="ln2647">            level_target.id.depth == branches[level_target.id.branch].numlevels)</a>
<a name="ln2648">        {</a>
<a name="ln2649">            mpr(&quot;You're already at the bottom of this branch!&quot;);</a>
<a name="ln2650">            return;</a>
<a name="ln2651">        }</a>
<a name="ln2652">        else if (level_target.pos.x == -1 || level_target.pos == you.pos())</a>
<a name="ln2653">        {</a>
<a name="ln2654">            mpr(&quot;You're already here!&quot;);</a>
<a name="ln2655">            return;</a>
<a name="ln2656">        }</a>
<a name="ln2657">    }</a>
<a name="ln2658"> </a>
<a name="ln2659">#ifdef DEBUG_TRAVEL</a>
<a name="ln2660">    dprf(&quot;starting translevel travel, branch %d depth %d, pos %d,%d&quot;,</a>
<a name="ln2661">        level_target.id.branch, level_target.id.depth, level_target.pos.x,</a>
<a name="ln2662">        level_target.pos.y);</a>
<a name="ln2663">#endif</a>
<a name="ln2664"> </a>
<a name="ln2665">    if (level_target.id.depth &gt; 0)</a>
<a name="ln2666">    {</a>
<a name="ln2667">        you.running = RMODE_INTERLEVEL;</a>
<a name="ln2668">        you.running.pos.reset();</a>
<a name="ln2669">        last_stair.id.depth = -1;</a>
<a name="ln2670">        last_stair.pos.reset();</a>
<a name="ln2671"> </a>
<a name="ln2672">        _Route_Warning.new_dest(level_target);</a>
<a name="ln2673"> </a>
<a name="ln2674">        _Src_Level = level_id::current();</a>
<a name="ln2675">        _Src_Dest_Level_Delta = level_distance(_Src_Level,</a>
<a name="ln2676">                                               level_target.id);</a>
<a name="ln2677"> </a>
<a name="ln2678">        _start_running();</a>
<a name="ln2679">    }</a>
<a name="ln2680">}</a>
<a name="ln2681"> </a>
<a name="ln2682">void start_translevel_travel(const level_pos &amp;pos)</a>
<a name="ln2683">{</a>
<a name="ln2684">    if (!can_travel_to(pos.id))</a>
<a name="ln2685">    {</a>
<a name="ln2686">        if (!can_travel_interlevel())</a>
<a name="ln2687">            mpr(&quot;Sorry, you can't auto-travel out of here.&quot;);</a>
<a name="ln2688">        else</a>
<a name="ln2689">            mpr(&quot;Sorry, I don't know how to get there.&quot;);</a>
<a name="ln2690">        return;</a>
<a name="ln2691">    }</a>
<a name="ln2692"> </a>
<a name="ln2693">    if (pos.is_valid() &amp;&amp; !in_bounds(pos.pos))</a>
<a name="ln2694">    {</a>
<a name="ln2695">        mpr(&quot;Sorry, I don't know how to get there.&quot;);</a>
<a name="ln2696">        return;</a>
<a name="ln2697">    }</a>
<a name="ln2698"> </a>
<a name="ln2699">    // Remember where we're going so we can easily go back if interrupted.</a>
<a name="ln2700">    you.travel_x = pos.pos.x;</a>
<a name="ln2701">    you.travel_y = pos.pos.y;</a>
<a name="ln2702">    you.travel_z = pos.id;</a>
<a name="ln2703"> </a>
<a name="ln2704">#ifdef DEBUG_TRAVEL</a>
<a name="ln2705">    dprf(&quot;going to %d depth %d, pos %d,%d&quot;, pos.id.branch, pos.id.depth,</a>
<a name="ln2706">        pos.pos.x, pos.pos.y);</a>
<a name="ln2707">#endif</a>
<a name="ln2708"> </a>
<a name="ln2709">    if (!can_travel_interlevel())</a>
<a name="ln2710">    {</a>
<a name="ln2711">        start_travel(pos.pos);</a>
<a name="ln2712">        return;</a>
<a name="ln2713">    }</a>
<a name="ln2714"> </a>
<a name="ln2715">    level_target = pos;</a>
<a name="ln2716"> </a>
<a name="ln2717">    // Check that it's level + position, not just level.</a>
<a name="ln2718">    if (pos.is_valid())</a>
<a name="ln2719">    {</a>
<a name="ln2720">        if (pos.id != level_id::current())</a>
<a name="ln2721">        {</a>
<a name="ln2722">            if (!_loadlev_populate_stair_distances(pos))</a>
<a name="ln2723">            {</a>
<a name="ln2724">                mpr(&quot;Level memory is imperfect, aborting.&quot;);</a>
<a name="ln2725">                return ;</a>
<a name="ln2726">            }</a>
<a name="ln2727">        }</a>
<a name="ln2728">        else</a>
<a name="ln2729">            _populate_stair_distances(pos);</a>
<a name="ln2730">    }</a>
<a name="ln2731"> </a>
<a name="ln2732">    trans_travel_dest = _get_trans_travel_dest(level_target);</a>
<a name="ln2733"> </a>
<a name="ln2734">    if (!i_feel_safe(true, true))</a>
<a name="ln2735">        return;</a>
<a name="ln2736">    if (you.confused())</a>
<a name="ln2737">    {</a>
<a name="ln2738">        canned_msg(MSG_TOO_CONFUSED);</a>
<a name="ln2739">        return;</a>
<a name="ln2740">    }</a>
<a name="ln2741"> </a>
<a name="ln2742">    _start_translevel_travel();</a>
<a name="ln2743">}</a>
<a name="ln2744"> </a>
<a name="ln2745">static void _start_translevel_travel_prompt()</a>
<a name="ln2746">{</a>
<a name="ln2747">    // Update information for this level. We need it even for the prompts, so</a>
<a name="ln2748">    // we can't wait to confirm that the user chose to initiate travel.</a>
<a name="ln2749">    travel_cache.get_level_info(level_id::current()).update();</a>
<a name="ln2750"> </a>
<a name="ln2751">    level_pos target = prompt_translevel_target(TPF_DEFAULT_OPTIONS,</a>
<a name="ln2752">            trans_travel_dest);</a>
<a name="ln2753">    if (target.id.depth &lt;= 0)</a>
<a name="ln2754">    {</a>
<a name="ln2755">        canned_msg(MSG_OK);</a>
<a name="ln2756">        return;</a>
<a name="ln2757">    }</a>
<a name="ln2758"> </a>
<a name="ln2759">    start_translevel_travel(target);</a>
<a name="ln2760">}</a>
<a name="ln2761"> </a>
<a name="ln2762">static int _target_distance_from(const coord_def &amp;pos)</a>
<a name="ln2763">{</a>
<a name="ln2764">    for (const stair_info &amp;stair : curr_stairs)</a>
<a name="ln2765">        if (stair.position == pos)</a>
<a name="ln2766">            return stair.distance;</a>
<a name="ln2767"> </a>
<a name="ln2768">    return -1;</a>
<a name="ln2769">}</a>
<a name="ln2770"> </a>
<a name="ln2771">/*</a>
<a name="ln2772"> * Sets best_stair to the coordinates of the best stair on the player's current</a>
<a name="ln2773"> * level to take to get to the 'target' level. Should be called with 'distance'</a>
<a name="ln2774"> * set to 0, 'stair' set to (you.x_pos, you.y_pos) and 'best_distance' set to</a>
<a name="ln2775"> * -1. 'cur' should be the player's current level.</a>
<a name="ln2776"> *</a>
<a name="ln2777"> * If best_stair remains unchanged when this function returns, there is no</a>
<a name="ln2778"> * travel-safe path between the player's current level and the target level OR</a>
<a name="ln2779"> * the player's current level *is* the target level.</a>
<a name="ln2780"> *</a>
<a name="ln2781"> * This function relies on the travel_point_distance array being correctly</a>
<a name="ln2782"> * populated with a floodout call to find_travel_pos starting from the player's</a>
<a name="ln2783"> * location.</a>
<a name="ln2784"> *</a>
<a name="ln2785"> * This function has undefined behaviour when the target position is not</a>
<a name="ln2786"> * traversable.</a>
<a name="ln2787"> */</a>
<a name="ln2788">static int _find_transtravel_stair(const level_id &amp;cur,</a>
<a name="ln2789">                                    const level_pos &amp;target,</a>
<a name="ln2790">                                    int distance,</a>
<a name="ln2791">                                    // This is actually the current position</a>
<a name="ln2792">                                    // on cur, not necessarily a stair.</a>
<a name="ln2793">                                    const coord_def &amp;stair,</a>
<a name="ln2794">                                    level_id &amp;closest_level,</a>
<a name="ln2795">                                    int &amp;best_level_distance,</a>
<a name="ln2796">                                    coord_def &amp;best_stair,</a>
<a name="ln2797">                                    int search_depth = 0)</a>
<a name="ln2798">{</a>
<a name="ln2799">    int local_distance = -1;</a>
<a name="ln2800">    level_id player_level = level_id::current();</a>
<a name="ln2801"> </a>
<a name="ln2802">    LevelInfo &amp;li = travel_cache.get_level_info(cur);</a>
<a name="ln2803"> </a>
<a name="ln2804">    // Have we reached the target level?</a>
<a name="ln2805">    if (cur == target.id)</a>
<a name="ln2806">    {</a>
<a name="ln2807">        // Are we in an exclude? If so, bail out. Unless it is just a stair exclusion.</a>
<a name="ln2808">        if (is_excluded(stair, li.get_excludes()) &amp;&amp; !is_stair_exclusion(stair))</a>
<a name="ln2809">            return -1;</a>
<a name="ln2810"> </a>
<a name="ln2811">        // If there's no target position on the target level, or we're on the</a>
<a name="ln2812">        // target, we're home.</a>
<a name="ln2813">        if (target.pos.x == -1 || target.pos == stair)</a>
<a name="ln2814">            return distance;</a>
<a name="ln2815"> </a>
<a name="ln2816">        // If there *is* a target position, we need to work out our distance</a>
<a name="ln2817">        // from it.</a>
<a name="ln2818">        int deltadist = _target_distance_from(stair);</a>
<a name="ln2819"> </a>
<a name="ln2820">        if (deltadist == -1 &amp;&amp; cur == player_level)</a>
<a name="ln2821">        {</a>
<a name="ln2822">            // Okay, we don't seem to have a distance available to us, which</a>
<a name="ln2823">            // means we're either (a) not standing on stairs or (b) whoever</a>
<a name="ln2824">            // initiated interlevel travel didn't call</a>
<a name="ln2825">            // _populate_stair_distances. Assuming we're not on stairs, that</a>
<a name="ln2826">            // situation can arise only if interlevel travel has been triggered</a>
<a name="ln2827">            // for a location on the same level. If that's the case, we can get</a>
<a name="ln2828">            // the distance off the travel_point_distance matrix.</a>
<a name="ln2829">            deltadist = travel_point_distance[target.pos.x][target.pos.y];</a>
<a name="ln2830">            if (!deltadist &amp;&amp; stair != target.pos)</a>
<a name="ln2831">                deltadist = -1;</a>
<a name="ln2832">        }</a>
<a name="ln2833"> </a>
<a name="ln2834">        if (deltadist != -1)</a>
<a name="ln2835">        {</a>
<a name="ln2836">            local_distance = distance + deltadist;</a>
<a name="ln2837"> </a>
<a name="ln2838">            // See if this is a degenerate case of interlevel travel:</a>
<a name="ln2839">            // A degenerate case of interlevel travel decays to normal travel;</a>
<a name="ln2840">            // we identify this by checking if:</a>
<a name="ln2841">            // a. The current level is the target level.</a>
<a name="ln2842">            // b. The target square is reachable from the 'current' square.</a>
<a name="ln2843">            // c. The current square is where the player is.</a>
<a name="ln2844">            //</a>
<a name="ln2845">            // Note that even if this *is* degenerate, interlevel travel may</a>
<a name="ln2846">            // still be able to find a shorter route, since it can consider</a>
<a name="ln2847">            // routes that leave and reenter the current level.</a>
<a name="ln2848">            if (player_level == target.id &amp;&amp; stair == you.pos())</a>
<a name="ln2849">                best_stair = target.pos;</a>
<a name="ln2850"> </a>
<a name="ln2851">            // The local_distance is already set, but there may actually be</a>
<a name="ln2852">            // stairs we can take that'll get us to the target faster than the</a>
<a name="ln2853">            // direct route, so we also try the stairs.</a>
<a name="ln2854">        }</a>
<a name="ln2855">    }</a>
<a name="ln2856"> </a>
<a name="ln2857">    vector&lt;stair_info&gt; &amp;stairs = li.get_stairs();</a>
<a name="ln2858"> </a>
<a name="ln2859">    // this_stair being nullptr is perfectly acceptable, since we start with</a>
<a name="ln2860">    // coords as the player coords, and the player need not be standing on</a>
<a name="ln2861">    // stairs.</a>
<a name="ln2862">    stair_info *this_stair = li.get_stair(stair);</a>
<a name="ln2863"> </a>
<a name="ln2864">    if (!this_stair &amp;&amp; cur != player_level)</a>
<a name="ln2865">    {</a>
<a name="ln2866">        // Whoops, there's no stair in the travel cache for the current</a>
<a name="ln2867">        // position, and we're not on the player's current level (i.e., there</a>
<a name="ln2868">        // certainly *should* be a stair here). Since we can't proceed in any</a>
<a name="ln2869">        // reasonable way, bail out.</a>
<a name="ln2870">        return local_distance;</a>
<a name="ln2871">    }</a>
<a name="ln2872"> </a>
<a name="ln2873">    for (stair_info &amp;si : stairs)</a>
<a name="ln2874">    {</a>
<a name="ln2875">        if (stairs_destination_is_excluded(si))</a>
<a name="ln2876">            continue;</a>
<a name="ln2877"> </a>
<a name="ln2878">        // Skip placeholders and excluded stairs.</a>
<a name="ln2879">        if (!si.can_travel() || is_excluded(si.position, li.get_excludes()))</a>
<a name="ln2880">            continue;</a>
<a name="ln2881"> </a>
<a name="ln2882">        int deltadist = li.distance_between(this_stair, &amp;si);</a>
<a name="ln2883"> </a>
<a name="ln2884">        if (!this_stair)</a>
<a name="ln2885">        {</a>
<a name="ln2886">            deltadist = travel_point_distance[si.position.x][si.position.y];</a>
<a name="ln2887">            if (!deltadist &amp;&amp; you.pos() != si.position)</a>
<a name="ln2888">                deltadist = -1;</a>
<a name="ln2889">        }</a>
<a name="ln2890">        // deltadist == 0 is legal (if this_stair is nullptr), since the player</a>
<a name="ln2891">        // may be standing on the stairs. If two stairs are disconnected,</a>
<a name="ln2892">        // deltadist has to be negative.</a>
<a name="ln2893">        if (deltadist &lt; 0)</a>
<a name="ln2894">            continue;</a>
<a name="ln2895"> </a>
<a name="ln2896">        int dist2stair = distance + deltadist;</a>
<a name="ln2897">        if (si.distance == -1 || si.distance &gt; dist2stair)</a>
<a name="ln2898">        {</a>
<a name="ln2899">            si.distance = dist2stair;</a>
<a name="ln2900"> </a>
<a name="ln2901">            // Account for the cost of taking the stairs</a>
<a name="ln2902">            dist2stair += 500; // XXX: this seems large?</a>
<a name="ln2903"> </a>
<a name="ln2904">            // Already too expensive? Short-circuit.</a>
<a name="ln2905">            if (local_distance != -1 &amp;&amp; dist2stair &gt;= local_distance)</a>
<a name="ln2906">                continue;</a>
<a name="ln2907"> </a>
<a name="ln2908">            const level_pos &amp;dest = si.destination;</a>
<a name="ln2909"> </a>
<a name="ln2910">            // Never use escape hatches as the last leg of the trip, since</a>
<a name="ln2911">            // that will leave the player unable to retrace their path.</a>
<a name="ln2912">            // This does not apply if we have a destination with a specific</a>
<a name="ln2913">            // position on the target level travel wants to get to.</a>
<a name="ln2914">            if (feat_is_escape_hatch(si.grid)</a>
<a name="ln2915">                &amp;&amp; target.pos.x == -1</a>
<a name="ln2916">                &amp;&amp; dest.id == target.id)</a>
<a name="ln2917">            {</a>
<a name="ln2918">                continue;</a>
<a name="ln2919">            }</a>
<a name="ln2920"> </a>
<a name="ln2921">            // We can only short-circuit the stair-following process if we</a>
<a name="ln2922">            // have no exact target location. If there *is* an exact target</a>
<a name="ln2923">            // location, we can't follow stairs for which we have incomplete</a>
<a name="ln2924">            // information.</a>
<a name="ln2925">            if (target.pos.x == -1</a>
<a name="ln2926">                &amp;&amp; dest.id == target.id)</a>
<a name="ln2927">            {</a>
<a name="ln2928">                if (local_distance == -1 || local_distance &gt; dist2stair)</a>
<a name="ln2929">                {</a>
<a name="ln2930">                    local_distance = dist2stair;</a>
<a name="ln2931">                    if (cur == player_level &amp;&amp; you.pos() == stair)</a>
<a name="ln2932">                        best_stair = si.position;</a>
<a name="ln2933">                }</a>
<a name="ln2934">                continue;</a>
<a name="ln2935">            }</a>
<a name="ln2936"> </a>
<a name="ln2937">            if (dest.id.depth &gt; -1) // We have a valid level descriptor.</a>
<a name="ln2938">            {</a>
<a name="ln2939">                int dist = level_distance(dest.id, target.id);</a>
<a name="ln2940">                if (dist != -1 &amp;&amp; (dist &lt; best_level_distance</a>
<a name="ln2941">                                   || best_level_distance == -1))</a>
<a name="ln2942">                {</a>
<a name="ln2943">                    best_level_distance = dist;</a>
<a name="ln2944">                    closest_level       = dest.id;</a>
<a name="ln2945">                }</a>
<a name="ln2946">            }</a>
<a name="ln2947"> </a>
<a name="ln2948">            // If we don't know where these stairs go, we can't take them.</a>
<a name="ln2949">            if (!dest.is_valid())</a>
<a name="ln2950">                continue;</a>
<a name="ln2951"> </a>
<a name="ln2952">            // Don't try hell branches if we are not already in one or targeting</a>
<a name="ln2953">            // one. When you actually enter the vestibule, the branch entry</a>
<a name="ln2954">            // point is adjusted to be the portal you entered through, but</a>
<a name="ln2955">            // autotravel needs to simulate this somehow, or it can find (fake)</a>
<a name="ln2956">            // paths through hell that are shortcuts in depths, because the</a>
<a name="ln2957">            // vestibule side of the portals do map to particular portals</a>
<a name="ln2958">            // scattered throughout depths, even if those mappings won't be</a>
<a name="ln2959">            // used while exiting from the vestibule.</a>
<a name="ln2960">            if (is_hell_branch(dest.id.branch)</a>
<a name="ln2961">                            &amp;&amp; !(is_hell_branch(target.id.branch)</a>
<a name="ln2962">                                 || is_hell_branch(cur.branch)))</a>
<a name="ln2963">            {</a>
<a name="ln2964">                continue;</a>
<a name="ln2965">            }</a>
<a name="ln2966"> </a>
<a name="ln2967">            // We need to get the stairs at the new location and set the</a>
<a name="ln2968">            // distance on them as well.</a>
<a name="ln2969">            LevelInfo &amp;lo = travel_cache.get_level_info(dest.id);</a>
<a name="ln2970">            if (stair_info *so = lo.get_stair(dest.pos))</a>
<a name="ln2971">            {</a>
<a name="ln2972">                if (so-&gt;distance == -1 || so-&gt;distance &gt; dist2stair)</a>
<a name="ln2973">                    so-&gt;distance = dist2stair;</a>
<a name="ln2974">                else</a>
<a name="ln2975">                    continue;   // We've already been here.</a>
<a name="ln2976">            }</a>
<a name="ln2977">#ifdef DEBUG_TRAVEL</a>
<a name="ln2978">            string indent(search_depth, '.');</a>
<a name="ln2979">            dprf(&quot;%strying stairs at %d,%d, dest is %d depth %d, pos %d,%d&quot;,</a>
<a name="ln2980">                indent.c_str(), si.position.x, si.position.y, dest.id.branch,</a>
<a name="ln2981">                dest.id.depth, dest.pos.x, dest.pos.y);</a>
<a name="ln2982">#endif</a>
<a name="ln2983"> </a>
<a name="ln2984">            // Okay, take these stairs and keep going.</a>
<a name="ln2985">            const int newdist =</a>
<a name="ln2986">                _find_transtravel_stair(dest.id, target,</a>
<a name="ln2987">                                        dist2stair, dest.pos, closest_level,</a>
<a name="ln2988">                                        best_level_distance, best_stair,</a>
<a name="ln2989">                                        search_depth + 1);</a>
<a name="ln2990">            if (newdist != -1</a>
<a name="ln2991">                &amp;&amp; (local_distance == -1 || local_distance &gt; newdist))</a>
<a name="ln2992">            {</a>
<a name="ln2993">                local_distance = newdist;</a>
<a name="ln2994">                if (cur == player_level &amp;&amp; you.pos() == stair)</a>
<a name="ln2995">                    best_stair = si.position;</a>
<a name="ln2996">            }</a>
<a name="ln2997">        }</a>
<a name="ln2998">    }</a>
<a name="ln2999">    return local_distance;</a>
<a name="ln3000">}</a>
<a name="ln3001"> </a>
<a name="ln3002">static bool _loadlev_populate_stair_distances(const level_pos &amp;target)</a>
<a name="ln3003">{</a>
<a name="ln3004">    level_excursion excursion;</a>
<a name="ln3005">    excursion.go_to(target.id);</a>
<a name="ln3006">    _populate_stair_distances(target);</a>
<a name="ln3007">    return true;</a>
<a name="ln3008">}</a>
<a name="ln3009"> </a>
<a name="ln3010">static void _populate_stair_distances(const level_pos &amp;target)</a>
<a name="ln3011">{</a>
<a name="ln3012">    // Populate travel_point_distance.</a>
<a name="ln3013">    find_travel_pos(target.pos, nullptr, nullptr, nullptr);</a>
<a name="ln3014"> </a>
<a name="ln3015">    curr_stairs.clear();</a>
<a name="ln3016">    for (stair_info si : travel_cache.get_level_info(target.id).get_stairs())</a>
<a name="ln3017">    {</a>
<a name="ln3018">        si.distance = travel_point_distance[si.position.x][si.position.y];</a>
<a name="ln3019">        if (!si.distance &amp;&amp; target.pos != si.position</a>
<a name="ln3020">            || si.distance &lt; -1)</a>
<a name="ln3021">        {</a>
<a name="ln3022">            si.distance = -1;</a>
<a name="ln3023">        }</a>
<a name="ln3024"> </a>
<a name="ln3025">        curr_stairs.push_back(si);</a>
<a name="ln3026">    }</a>
<a name="ln3027">}</a>
<a name="ln3028"> </a>
<a name="ln3029">static bool _find_transtravel_square(const level_pos &amp;target, bool verbose)</a>
<a name="ln3030">{</a>
<a name="ln3031">    level_id current = level_id::current();</a>
<a name="ln3032"> </a>
<a name="ln3033">    coord_def best_stair(-1, -1);</a>
<a name="ln3034">    coord_def cur_stair(you.pos());</a>
<a name="ln3035"> </a>
<a name="ln3036">    level_id closest_level;</a>
<a name="ln3037">    int best_level_distance = -1;</a>
<a name="ln3038">    travel_cache.clear_distances();</a>
<a name="ln3039"> </a>
<a name="ln3040">    find_travel_pos(you.pos(), nullptr, nullptr, nullptr);</a>
<a name="ln3041"> </a>
<a name="ln3042">    // either off-level, or traversable and on-level</a>
<a name="ln3043">    // TODO: actually check this when the square is off-level? The current</a>
<a name="ln3044">    // behaviour is that it will go to the level and then fail.</a>
<a name="ln3045">    const bool maybe_traversable = (target.id != current</a>
<a name="ln3046">                                    || (in_bounds(target.pos)</a>
<a name="ln3047">                                        &amp;&amp; feat_is_traversable_now(env.map_knowledge(target.pos).feat())));</a>
<a name="ln3048"> </a>
<a name="ln3049">    if (maybe_traversable)</a>
<a name="ln3050">    {</a>
<a name="ln3051">        _find_transtravel_stair(current, target,</a>
<a name="ln3052">                                0, cur_stair, closest_level,</a>
<a name="ln3053">                                best_level_distance, best_stair);</a>
<a name="ln3054">        dprf(&quot;found stair at %d,%d&quot;, best_stair.x, best_stair.y);</a>
<a name="ln3055">    }</a>
<a name="ln3056">    // even without _find_transtravel_stair called, the values are initialized</a>
<a name="ln3057">    // enough for the rest of this to go forward.</a>
<a name="ln3058"> </a>
<a name="ln3059">    if (best_stair.x != -1 &amp;&amp; best_stair.y != -1)</a>
<a name="ln3060">    {</a>
<a name="ln3061">        // Is this stair going offlevel?</a>
<a name="ln3062">        if ((level_target.id != current</a>
<a name="ln3063">             || level_target.pos != best_stair)</a>
<a name="ln3064">            &amp;&amp; _Src_Dest_Level_Delta != -1)</a>
<a name="ln3065">        {</a>
<a name="ln3066">            // If so, is the original level closer to the target level than</a>
<a name="ln3067">            // the destination of the stair?</a>
<a name="ln3068">            LevelInfo &amp;li = travel_cache.get_level_info(current);</a>
<a name="ln3069">            const stair_info *dest_stair = li.get_stair(best_stair);</a>
<a name="ln3070"> </a>
<a name="ln3071">            if (dest_stair &amp;&amp; dest_stair-&gt;destination.id.is_valid())</a>
<a name="ln3072">            {</a>
<a name="ln3073">                if ((_Src_Dest_Level_Delta &lt;</a>
<a name="ln3074">                     level_distance(dest_stair-&gt;destination.id,</a>
<a name="ln3075">                                    level_target.id)</a>
<a name="ln3076">                        || _Src_Dest_Level_Delta &lt;</a>
<a name="ln3077">                           level_distance(dest_stair-&gt;destination.id,</a>
<a name="ln3078">                                          _Src_Level))</a>
<a name="ln3079">                    &amp;&amp; !_Route_Warning.warn_continue_travel(</a>
<a name="ln3080">                        level_target,</a>
<a name="ln3081">                        dest_stair-&gt;destination.id))</a>
<a name="ln3082">                {</a>
<a name="ln3083">                    canned_msg(MSG_OK);</a>
<a name="ln3084">                    return false;</a>
<a name="ln3085">                }</a>
<a name="ln3086">            }</a>
<a name="ln3087">        }</a>
<a name="ln3088"> </a>
<a name="ln3089">        you.running.pos = best_stair;</a>
<a name="ln3090">        return true;</a>
<a name="ln3091">    }</a>
<a name="ln3092">    else if (best_level_distance != -1 &amp;&amp; closest_level != current</a>
<a name="ln3093">             &amp;&amp; target.pos.x == -1)</a>
<a name="ln3094">    {</a>
<a name="ln3095">        int current_dist = level_distance(current, target.id);</a>
<a name="ln3096">        level_pos newlev;</a>
<a name="ln3097">        newlev.id = closest_level;</a>
<a name="ln3098">        if (newlev.id != target.id</a>
<a name="ln3099">            &amp;&amp; (current_dist == -1 || best_level_distance &lt; current_dist))</a>
<a name="ln3100">        {</a>
<a name="ln3101">            return _find_transtravel_square(newlev, verbose);</a>
<a name="ln3102">        }</a>
<a name="ln3103">    }</a>
<a name="ln3104"> </a>
<a name="ln3105">    if (verbose)</a>
<a name="ln3106">    {</a>
<a name="ln3107">        if (target.id != current</a>
<a name="ln3108">            || target.pos.x != -1 &amp;&amp; target.pos != you.pos())</a>
<a name="ln3109">        {</a>
<a name="ln3110">            if (!maybe_traversable)</a>
<a name="ln3111">                mpr(&quot;Sorry, I don't know how to traverse that place.&quot;);</a>
<a name="ln3112">            else</a>
<a name="ln3113">                mpr(&quot;Sorry, I don't know how to get there.&quot;);</a>
<a name="ln3114">        }</a>
<a name="ln3115">    }</a>
<a name="ln3116"> </a>
<a name="ln3117">    return false;</a>
<a name="ln3118">}</a>
<a name="ln3119"> </a>
<a name="ln3120">void start_travel(const coord_def&amp; p)</a>
<a name="ln3121">{</a>
<a name="ln3122">    // Redundant target?</a>
<a name="ln3123">    if (p == you.pos())</a>
<a name="ln3124">        return;</a>
<a name="ln3125"> </a>
<a name="ln3126">    // Can we even travel to this square?</a>
<a name="ln3127">    if (!in_bounds(p))</a>
<a name="ln3128">        return;</a>
<a name="ln3129"> </a>
<a name="ln3130">    if (!_is_travelsafe_square(p, true))</a>
<a name="ln3131">        return;</a>
<a name="ln3132"> </a>
<a name="ln3133">    you.travel_x = p.x;</a>
<a name="ln3134">    you.travel_y = p.y;</a>
<a name="ln3135">    you.travel_z = level_id::current();</a>
<a name="ln3136"> </a>
<a name="ln3137">    you.running.pos = p;</a>
<a name="ln3138">    level_target  = level_pos(level_id::current(), p);</a>
<a name="ln3139"> </a>
<a name="ln3140">    if (!can_travel_interlevel())</a>
<a name="ln3141">    {</a>
<a name="ln3142">        if (!i_feel_safe(true, true))</a>
<a name="ln3143">            return;</a>
<a name="ln3144">        if (you.confused())</a>
<a name="ln3145">        {</a>
<a name="ln3146">            canned_msg(MSG_TOO_CONFUSED);</a>
<a name="ln3147">            return;</a>
<a name="ln3148">        }</a>
<a name="ln3149"> </a>
<a name="ln3150">        // Start running</a>
<a name="ln3151">        you.running = RMODE_TRAVEL;</a>
<a name="ln3152">        _start_running();</a>
<a name="ln3153">    }</a>
<a name="ln3154">    else</a>
<a name="ln3155">        start_translevel_travel(level_target);</a>
<a name="ln3156">}</a>
<a name="ln3157"> </a>
<a name="ln3158">void start_explore(bool grab_items)</a>
<a name="ln3159">{</a>
<a name="ln3160">    if (Hints.hints_explored)</a>
<a name="ln3161">        Hints.hints_explored = false;</a>
<a name="ln3162"> </a>
<a name="ln3163">    if (!i_feel_safe(true, true))</a>
<a name="ln3164">        return;</a>
<a name="ln3165"> </a>
<a name="ln3166">    you.running = (grab_items ? RMODE_EXPLORE_GREEDY : RMODE_EXPLORE);</a>
<a name="ln3167"> </a>
<a name="ln3168">    for (rectangle_iterator ri(0); ri; ++ri)</a>
<a name="ln3169">        if (env.map_knowledge(*ri).seen())</a>
<a name="ln3170">            env.map_seen.set(*ri);</a>
<a name="ln3171"> </a>
<a name="ln3172">    you.running.pos.reset();</a>
<a name="ln3173">    _start_running();</a>
<a name="ln3174">}</a>
<a name="ln3175"> </a>
<a name="ln3176">void do_explore_cmd()</a>
<a name="ln3177">{</a>
<a name="ln3178">    if (apply_starvation_penalties())</a>
<a name="ln3179">        mpr(&quot;You need to eat something NOW!&quot;);</a>
<a name="ln3180">    else if (you.berserk())</a>
<a name="ln3181">        mpr(&quot;Calm down first, please.&quot;);</a>
<a name="ln3182">    else                        // Start exploring</a>
<a name="ln3183">        start_explore(Options.explore_greedy);</a>
<a name="ln3184">}</a>
<a name="ln3185"> </a>
<a name="ln3186">//////////////////////////////////////////////////////////////////////////</a>
<a name="ln3187">// Interlevel travel classes</a>
<a name="ln3188"> </a>
<a name="ln3189">level_id level_id::current()</a>
<a name="ln3190">{</a>
<a name="ln3191">    const level_id id(you.where_are_you, you.depth);</a>
<a name="ln3192">    return id;</a>
<a name="ln3193">}</a>
<a name="ln3194"> </a>
<a name="ln3195">int level_id::absdepth() const</a>
<a name="ln3196">{</a>
<a name="ln3197">    return absdungeon_depth(branch, depth);</a>
<a name="ln3198">}</a>
<a name="ln3199"> </a>
<a name="ln3200">level_id level_id::get_next_level_id(const coord_def &amp;pos)</a>
<a name="ln3201">{</a>
<a name="ln3202">    int gridc = grd(pos);</a>
<a name="ln3203">    level_id id = current();</a>
<a name="ln3204"> </a>
<a name="ln3205">    if (gridc == branches[id.branch].exit_stairs)</a>
<a name="ln3206">        return stair_destination(pos);</a>
<a name="ln3207">#if TAG_MAJOR_VERSION == 34</a>
<a name="ln3208">    if (gridc == DNGN_ENTER_PORTAL_VAULT)</a>
<a name="ln3209">        return stair_destination(pos);</a>
<a name="ln3210">#endif</a>
<a name="ln3211">    if (gridc == DNGN_EXIT_THROUGH_ABYSS)</a>
<a name="ln3212">        return level_id(BRANCH_ABYSS, 1);</a>
<a name="ln3213"> </a>
<a name="ln3214">    for (branch_iterator it; it; ++it)</a>
<a name="ln3215">    {</a>
<a name="ln3216">        if (gridc == it-&gt;entry_stairs)</a>
<a name="ln3217">        {</a>
<a name="ln3218">            id.branch = it-&gt;id;</a>
<a name="ln3219">            id.depth = 1;</a>
<a name="ln3220">            break;</a>
<a name="ln3221">        }</a>
<a name="ln3222">    }</a>
<a name="ln3223"> </a>
<a name="ln3224">    switch (gridc)</a>
<a name="ln3225">    {</a>
<a name="ln3226">    case DNGN_STONE_STAIRS_DOWN_I:   case DNGN_STONE_STAIRS_DOWN_II:</a>
<a name="ln3227">    case DNGN_STONE_STAIRS_DOWN_III: case DNGN_ESCAPE_HATCH_DOWN:</a>
<a name="ln3228">    case DNGN_ABYSSAL_STAIR:</a>
<a name="ln3229">        id.depth++;</a>
<a name="ln3230">        break;</a>
<a name="ln3231">    case DNGN_STONE_STAIRS_UP_I:     case DNGN_STONE_STAIRS_UP_II:</a>
<a name="ln3232">    case DNGN_STONE_STAIRS_UP_III:   case DNGN_ESCAPE_HATCH_UP:</a>
<a name="ln3233">        id.depth--;</a>
<a name="ln3234">        break;</a>
<a name="ln3235">    default:</a>
<a name="ln3236">        break;</a>
<a name="ln3237">    }</a>
<a name="ln3238">    return id;</a>
<a name="ln3239">}</a>
<a name="ln3240"> </a>
<a name="ln3241">string level_id::describe(bool long_name, bool with_number) const</a>
<a name="ln3242">{</a>
<a name="ln3243">    string result = (long_name ? branches[branch].longname</a>
<a name="ln3244">                               : branches[branch].abbrevname);</a>
<a name="ln3245"> </a>
<a name="ln3246">    if (with_number &amp;&amp; brdepth[branch] != 1)</a>
<a name="ln3247">    {</a>
<a name="ln3248">        if (long_name)</a>
<a name="ln3249">        {</a>
<a name="ln3250">            // decapitalise 'the'</a>
<a name="ln3251">            if (starts_with(result, &quot;The&quot;))</a>
<a name="ln3252">                result[0] = 't';</a>
<a name="ln3253">            result = make_stringf(&quot;Level %d of %s&quot;,</a>
<a name="ln3254">                      depth, result.c_str());</a>
<a name="ln3255">        }</a>
<a name="ln3256">        else if (depth)</a>
<a name="ln3257">            result = make_stringf(&quot;%s:%d&quot;, result.c_str(), depth);</a>
<a name="ln3258">        else</a>
<a name="ln3259">            result = make_stringf(&quot;%s:$&quot;, result.c_str());</a>
<a name="ln3260">    }</a>
<a name="ln3261">    return result;</a>
<a name="ln3262">}</a>
<a name="ln3263"> </a>
<a name="ln3264">level_id level_id::parse_level_id(const string &amp;s)</a>
<a name="ln3265">{</a>
<a name="ln3266">    string::size_type cpos = s.find(':');</a>
<a name="ln3267">    string brname  = (cpos != string::npos? s.substr(0, cpos)  : s);</a>
<a name="ln3268">    string brlev   = (cpos != string::npos? s.substr(cpos + 1) : &quot;&quot;);</a>
<a name="ln3269"> </a>
<a name="ln3270">    branch_type br = branch_by_abbrevname(brname);</a>
<a name="ln3271"> </a>
<a name="ln3272">    if (br == NUM_BRANCHES)</a>
<a name="ln3273">    {</a>
<a name="ln3274">        throw bad_level_id_f(&quot;Invalid branch \&quot;%s\&quot; in spec \&quot;%s\&quot;&quot;,</a>
<a name="ln3275">                             brname.c_str(), s.c_str());</a>
<a name="ln3276">    }</a>
<a name="ln3277"> </a>
<a name="ln3278">    // Branch:$ uses static data -- it never comes from the current game.</a>
<a name="ln3279">    const int dep = (brlev.empty() ? 1 :</a>
<a name="ln3280">                     brlev == &quot;$&quot;  ? branches[br].numlevels</a>
<a name="ln3281">                                   : atoi(brlev.c_str()));</a>
<a name="ln3282"> </a>
<a name="ln3283">    // The branch might have been longer when the save has been created.</a>
<a name="ln3284">    if (dep &lt; 0 || dep &gt; brdepth[br] &amp;&amp; dep &gt; branches[br].numlevels)</a>
<a name="ln3285">    {</a>
<a name="ln3286">        throw bad_level_id_f(&quot;Invalid depth for %s in spec \&quot;%s\&quot;&quot;,</a>
<a name="ln3287">                             brname.c_str(), s.c_str());</a>
<a name="ln3288">    }</a>
<a name="ln3289"> </a>
<a name="ln3290">    return level_id(br, dep);</a>
<a name="ln3291">}</a>
<a name="ln3292"> </a>
<a name="ln3293">void level_id::save(writer&amp; outf) const</a>
<a name="ln3294">{</a>
<a name="ln3295">    marshall_level_id(outf, *this);</a>
<a name="ln3296">}</a>
<a name="ln3297"> </a>
<a name="ln3298">void level_id::load(reader&amp; inf)</a>
<a name="ln3299">{</a>
<a name="ln3300">    (*this) = unmarshall_level_id(inf);</a>
<a name="ln3301">}</a>
<a name="ln3302"> </a>
<a name="ln3303">level_pos level_pos::current()</a>
<a name="ln3304">{</a>
<a name="ln3305">    return level_pos(level_id::current(), you.pos());</a>
<a name="ln3306">}</a>
<a name="ln3307"> </a>
<a name="ln3308">// NOTE: see also marshall_level_pos</a>
<a name="ln3309">void level_pos::save(writer&amp; outf) const</a>
<a name="ln3310">{</a>
<a name="ln3311">    id.save(outf);</a>
<a name="ln3312">    marshallCoord(outf, pos);</a>
<a name="ln3313">}</a>
<a name="ln3314"> </a>
<a name="ln3315">void level_pos::load(reader&amp; inf)</a>
<a name="ln3316">{</a>
<a name="ln3317">    id.load(inf);</a>
<a name="ln3318">    pos = unmarshallCoord(inf);</a>
<a name="ln3319">}</a>
<a name="ln3320"> </a>
<a name="ln3321">void transporter_info::save(writer&amp; outf) const</a>
<a name="ln3322">{</a>
<a name="ln3323">    marshallCoord(outf, position);</a>
<a name="ln3324">    marshallCoord(outf, destination);</a>
<a name="ln3325">    marshallByte(outf, type);</a>
<a name="ln3326">}</a>
<a name="ln3327"> </a>
<a name="ln3328">void stair_info::save(writer&amp; outf) const</a>
<a name="ln3329">{</a>
<a name="ln3330">    marshallCoord(outf, position);</a>
<a name="ln3331">    marshallShort(outf, grid);</a>
<a name="ln3332">    destination.save(outf);</a>
<a name="ln3333">    marshallByte(outf, guessed_pos? 1 : 0);</a>
<a name="ln3334">    marshallByte(outf, type);</a>
<a name="ln3335">}</a>
<a name="ln3336"> </a>
<a name="ln3337">void transporter_info::load(reader&amp; inf)</a>
<a name="ln3338">{</a>
<a name="ln3339">    position = unmarshallCoord(inf);</a>
<a name="ln3340">    destination = unmarshallCoord(inf);</a>
<a name="ln3341">    type = static_cast&lt;transporter_type&gt;(unmarshallByte(inf));</a>
<a name="ln3342">}</a>
<a name="ln3343"> </a>
<a name="ln3344">void stair_info::load(reader&amp; inf)</a>
<a name="ln3345">{</a>
<a name="ln3346">    position = unmarshallCoord(inf);</a>
<a name="ln3347">    grid = static_cast&lt;dungeon_feature_type&gt;(unmarshallShort(inf));</a>
<a name="ln3348">    destination.load(inf);</a>
<a name="ln3349">    guessed_pos = unmarshallByte(inf) != 0;</a>
<a name="ln3350">    type = static_cast&lt;stair_type&gt;(unmarshallByte(inf));</a>
<a name="ln3351">}</a>
<a name="ln3352"> </a>
<a name="ln3353">string stair_info::describe() const</a>
<a name="ln3354">{</a>
<a name="ln3355">    if (destination.is_valid())</a>
<a name="ln3356">    {</a>
<a name="ln3357">        const level_pos &amp;lp(destination);</a>
<a name="ln3358">        return make_stringf(&quot; (-&gt; %s@(%d,%d)%s%s)&quot;, lp.id.describe().c_str(),</a>
<a name="ln3359">                             lp.pos.x, lp.pos.y,</a>
<a name="ln3360">                             guessed_pos? &quot; guess&quot; : &quot;&quot;,</a>
<a name="ln3361">                             type == PLACEHOLDER ? &quot; placeholder&quot; : &quot;&quot;);</a>
<a name="ln3362">    }</a>
<a name="ln3363">    else if (destination.id.is_valid())</a>
<a name="ln3364">        return make_stringf(&quot; (-&gt;%s (?))&quot;, destination.id.describe().c_str());</a>
<a name="ln3365"> </a>
<a name="ln3366">    return &quot; (?)&quot;;</a>
<a name="ln3367">}</a>
<a name="ln3368"> </a>
<a name="ln3369">void LevelInfo::set_level_excludes()</a>
<a name="ln3370">{</a>
<a name="ln3371">    curr_excludes = excludes;</a>
<a name="ln3372">    init_exclusion_los();</a>
<a name="ln3373">}</a>
<a name="ln3374"> </a>
<a name="ln3375">bool LevelInfo::empty() const</a>
<a name="ln3376">{</a>
<a name="ln3377">    return stairs.empty() &amp;&amp; excludes.empty();</a>
<a name="ln3378">}</a>
<a name="ln3379"> </a>
<a name="ln3380">void LevelInfo::update_excludes()</a>
<a name="ln3381">{</a>
<a name="ln3382">    excludes = curr_excludes;</a>
<a name="ln3383">}</a>
<a name="ln3384"> </a>
<a name="ln3385">void LevelInfo::update()</a>
<a name="ln3386">{</a>
<a name="ln3387">    // First, set excludes, so that stair distances will be correctly populated.</a>
<a name="ln3388">    excludes = curr_excludes;</a>
<a name="ln3389"> </a>
<a name="ln3390">    // First, we get all known stairs.</a>
<a name="ln3391">    vector&lt;coord_def&gt; stair_positions;</a>
<a name="ln3392">    get_stairs(stair_positions);</a>
<a name="ln3393"> </a>
<a name="ln3394">    // Make sure our stair list is correct.</a>
<a name="ln3395">    correct_stair_list(stair_positions);</a>
<a name="ln3396"> </a>
<a name="ln3397">    sync_all_branch_stairs();</a>
<a name="ln3398"> </a>
<a name="ln3399">    // If the player isn't immune to slimy walls, precalculate</a>
<a name="ln3400">    // neighbours of slimy walls now.</a>
<a name="ln3401">    unwind_slime_wall_precomputer slime_wall_neighbours(</a>
<a name="ln3402">        !actor_slime_wall_immune(&amp;you));</a>
<a name="ln3403">    precompute_travel_safety_grid travel_safety_calc;</a>
<a name="ln3404">    update_stair_distances();</a>
<a name="ln3405"> </a>
<a name="ln3406">    vector&lt;coord_def&gt; transporter_positions;</a>
<a name="ln3407">    get_transporters(transporter_positions);</a>
<a name="ln3408">    correct_transporter_list(transporter_positions);</a>
<a name="ln3409"> </a>
<a name="ln3410">    update_daction_counters(this);</a>
<a name="ln3411">}</a>
<a name="ln3412"> </a>
<a name="ln3413">void LevelInfo::set_distance_between_stairs(int a, int b, int dist)</a>
<a name="ln3414">{</a>
<a name="ln3415">    // Note dist == 0 is illegal because we can't have two stairs on</a>
<a name="ln3416">    // the same square.</a>
<a name="ln3417">    if (dist &lt;= 0 &amp;&amp; a != b)</a>
<a name="ln3418">        dist = -1;</a>
<a name="ln3419">    stair_distances[a * stairs.size() + b] = dist;</a>
<a name="ln3420">    stair_distances[b * stairs.size() + a] = dist;</a>
<a name="ln3421">}</a>
<a name="ln3422"> </a>
<a name="ln3423">void LevelInfo::update_stair_distances()</a>
<a name="ln3424">{</a>
<a name="ln3425">    const int nstairs = stairs.size();</a>
<a name="ln3426">    // Now we update distances for all the stairs, relative to all other</a>
<a name="ln3427">    // stairs.</a>
<a name="ln3428">    for (int s = 0; s &lt; nstairs - 1; ++s)</a>
<a name="ln3429">    {</a>
<a name="ln3430">        set_distance_between_stairs(s, s, 0);</a>
<a name="ln3431"> </a>
<a name="ln3432">        // For each stair, we need to ask travel to populate the distance</a>
<a name="ln3433">        // array.</a>
<a name="ln3434">        find_travel_pos(stairs[s].position, nullptr, nullptr, nullptr);</a>
<a name="ln3435"> </a>
<a name="ln3436">        // Assume movement distance between stairs is commutative,</a>
<a name="ln3437">        // i.e. going from a-&gt;b is the same distance as b-&gt;a.</a>
<a name="ln3438">        for (int other = s + 1; other &lt; nstairs; ++other)</a>
<a name="ln3439">        {</a>
<a name="ln3440">            const coord_def op = stairs[other].position;</a>
<a name="ln3441">            const int dist = travel_point_distance[op.x][op.y];</a>
<a name="ln3442">            set_distance_between_stairs(s, other, dist);</a>
<a name="ln3443">        }</a>
<a name="ln3444">    }</a>
<a name="ln3445">    if (nstairs)</a>
<a name="ln3446">        set_distance_between_stairs(nstairs - 1, nstairs - 1, 0);</a>
<a name="ln3447">}</a>
<a name="ln3448"> </a>
<a name="ln3449">void LevelInfo::update_transporter(const coord_def&amp; transpos,</a>
<a name="ln3450">                                   const coord_def&amp; dest)</a>
<a name="ln3451">{</a>
<a name="ln3452">    transporter_info *si = get_transporter(transpos);</a>
<a name="ln3453">    if (si)</a>
<a name="ln3454">        si-&gt;destination = dest;</a>
<a name="ln3455">    else</a>
<a name="ln3456">        transporters.push_back(transporter_info(transpos, dest,</a>
<a name="ln3457">                               transporter_info::PHYSICAL));</a>
<a name="ln3458">}</a>
<a name="ln3459"> </a>
<a name="ln3460">void LevelInfo::update_stair(const coord_def&amp; stairpos, const level_pos &amp;p,</a>
<a name="ln3461">                             bool guess)</a>
<a name="ln3462">{</a>
<a name="ln3463">    stair_info *si = get_stair(stairpos);</a>
<a name="ln3464"> </a>
<a name="ln3465">    // What 'guess' signifies: whenever you take a stair from A to B, the</a>
<a name="ln3466">    // travel code knows that the stair takes you from A-&gt;B. In that case,</a>
<a name="ln3467">    // update_stair() is called with guess == false.</a>
<a name="ln3468">    //</a>
<a name="ln3469">    // Unfortunately, Crawl doesn't guarantee that A-&gt;B implies B-&gt;A, but the</a>
<a name="ln3470">    // travel code has to assume that anyway (because that's what the player</a>
<a name="ln3471">    // will expect), and call update_stair() again with guess == true.</a>
<a name="ln3472">    //</a>
<a name="ln3473">    // The idea of using 'guess' is that we'll update the stair's destination</a>
<a name="ln3474">    // with a guess only if we know that the currently set destination is</a>
<a name="ln3475">    // itself a guess.</a>
<a name="ln3476">    //</a>
<a name="ln3477">    if (si &amp;&amp; (si-&gt;guessed_pos || !guess))</a>
<a name="ln3478">    {</a>
<a name="ln3479">        si-&gt;destination = p;</a>
<a name="ln3480">        si-&gt;guessed_pos = guess;</a>
<a name="ln3481"> </a>
<a name="ln3482">        if (!guess &amp;&amp; p.id.branch == BRANCH_VESTIBULE</a>
<a name="ln3483">            &amp;&amp; id.branch == BRANCH_DEPTHS)</a>
<a name="ln3484">        {</a>
<a name="ln3485">            travel_hell_entry = p;</a>
<a name="ln3486">        }</a>
<a name="ln3487"> </a>
<a name="ln3488">        // All branch stairs land on the same place on the destination level,</a>
<a name="ln3489">        // update the cache accordingly (but leave guessed_pos = true). This</a>
<a name="ln3490">        // applies for both branch exits (the usual case) and branch entrances.</a>
<a name="ln3491">        if (si-&gt;destination.id.branch != id.branch)</a>
<a name="ln3492">            sync_branch_stairs(si);</a>
<a name="ln3493">    }</a>
<a name="ln3494">    else if (!si &amp;&amp; guess)</a>
<a name="ln3495">        create_placeholder_stair(stairpos, p);</a>
<a name="ln3496">}</a>
<a name="ln3497"> </a>
<a name="ln3498">void LevelInfo::create_placeholder_stair(const coord_def &amp;stair,</a>
<a name="ln3499">                                         const level_pos &amp;dest)</a>
<a name="ln3500">{</a>
<a name="ln3501">    // If there are any existing placeholders with the same 'dest', zap them.</a>
<a name="ln3502">    erase_if(stairs, [&amp;dest](const stair_info&amp; old_stair)</a>
<a name="ln3503">                     { return old_stair.type == stair_info::PLACEHOLDER</a>
<a name="ln3504">                              &amp;&amp; old_stair.destination == dest; });</a>
<a name="ln3505"> </a>
<a name="ln3506">    stair_info placeholder;</a>
<a name="ln3507">    placeholder.position    = stair;</a>
<a name="ln3508">    placeholder.grid        = DNGN_FLOOR;</a>
<a name="ln3509">    placeholder.destination = dest;</a>
<a name="ln3510">    placeholder.type        = stair_info::PLACEHOLDER;</a>
<a name="ln3511">    stairs.push_back(placeholder);</a>
<a name="ln3512"> </a>
<a name="ln3513">    resize_stair_distances();</a>
<a name="ln3514">}</a>
<a name="ln3515"> </a>
<a name="ln3516">// If a stair leading out of or into a branch has a known destination, all</a>
<a name="ln3517">// stairs of the same type on this level should have the same destination set</a>
<a name="ln3518">// as guessed_pos == true.</a>
<a name="ln3519">void LevelInfo::sync_all_branch_stairs()</a>
<a name="ln3520">{</a>
<a name="ln3521">    set&lt;int&gt; synced;</a>
<a name="ln3522"> </a>
<a name="ln3523">    for (const stair_info&amp; si : stairs)</a>
<a name="ln3524">    {</a>
<a name="ln3525">        if (si.destination.id.branch != id.branch &amp;&amp; si.destination.is_valid()</a>
<a name="ln3526">            &amp;&amp; !synced.count(si.grid))</a>
<a name="ln3527">        {</a>
<a name="ln3528">            synced.insert(si.grid);</a>
<a name="ln3529">            sync_branch_stairs(&amp;si);</a>
<a name="ln3530">        }</a>
<a name="ln3531">    }</a>
<a name="ln3532">}</a>
<a name="ln3533"> </a>
<a name="ln3534">void LevelInfo::sync_branch_stairs(const stair_info *si)</a>
<a name="ln3535">{</a>
<a name="ln3536">    for (stair_info &amp;sother : stairs)</a>
<a name="ln3537">    {</a>
<a name="ln3538">        if (si == &amp;sother || !sother.guessed_pos || si-&gt;grid != sother.grid</a>
<a name="ln3539">            || sother.destination.is_valid())</a>
<a name="ln3540">        {</a>
<a name="ln3541">            continue;</a>
<a name="ln3542">        }</a>
<a name="ln3543">        sother.destination = si-&gt;destination;</a>
<a name="ln3544">    }</a>
<a name="ln3545">}</a>
<a name="ln3546"> </a>
<a name="ln3547">void LevelInfo::clear_stairs(dungeon_feature_type grid)</a>
<a name="ln3548">{</a>
<a name="ln3549">    for (stair_info &amp;si : stairs)</a>
<a name="ln3550">    {</a>
<a name="ln3551">        if (si.grid != grid)</a>
<a name="ln3552">            continue;</a>
<a name="ln3553"> </a>
<a name="ln3554">        si.destination.id.depth = -1;</a>
<a name="ln3555">        si.destination.pos.x = -1;</a>
<a name="ln3556">        si.destination.pos.y = -1;</a>
<a name="ln3557">        si.guessed_pos = true;</a>
<a name="ln3558">    }</a>
<a name="ln3559">}</a>
<a name="ln3560"> </a>
<a name="ln3561">bool LevelInfo::know_transporter(const coord_def &amp;c) const</a>
<a name="ln3562">{</a>
<a name="ln3563">    const int index = get_transporter_index(c);</a>
<a name="ln3564">    if (index == -1)</a>
<a name="ln3565">        return false;</a>
<a name="ln3566"> </a>
<a name="ln3567">    return !transporters[index].destination.origin();</a>
<a name="ln3568">}</a>
<a name="ln3569"> </a>
<a name="ln3570">bool LevelInfo::know_stair(const coord_def &amp;c) const</a>
<a name="ln3571">{</a>
<a name="ln3572">    const int index = get_stair_index(c);</a>
<a name="ln3573">    if (index == -1)</a>
<a name="ln3574">        return false;</a>
<a name="ln3575"> </a>
<a name="ln3576">    const level_pos &amp;lp = stairs[index].destination;</a>
<a name="ln3577">    return lp.is_valid();</a>
<a name="ln3578">}</a>
<a name="ln3579"> </a>
<a name="ln3580">transporter_info *LevelInfo::get_transporter(const coord_def &amp;pos)</a>
<a name="ln3581">{</a>
<a name="ln3582">    int index = get_transporter_index(pos);</a>
<a name="ln3583">    return index != -1 ? &amp;transporters[index] : nullptr;</a>
<a name="ln3584">}</a>
<a name="ln3585"> </a>
<a name="ln3586">stair_info *LevelInfo::get_stair(const coord_def &amp;pos)</a>
<a name="ln3587">{</a>
<a name="ln3588">    int index = get_stair_index(pos);</a>
<a name="ln3589">    return index != -1? &amp;stairs[index] : nullptr;</a>
<a name="ln3590">}</a>
<a name="ln3591"> </a>
<a name="ln3592">int LevelInfo::get_transporter_index(const coord_def &amp;pos) const</a>
<a name="ln3593">{</a>
<a name="ln3594">    for (int i = static_cast&lt;int&gt;(transporters.size()) - 1; i &gt;= 0; --i)</a>
<a name="ln3595">        if (transporters[i].position == pos)</a>
<a name="ln3596">            return i;</a>
<a name="ln3597"> </a>
<a name="ln3598">    return -1;</a>
<a name="ln3599">}</a>
<a name="ln3600"> </a>
<a name="ln3601">int LevelInfo::get_stair_index(const coord_def &amp;pos) const</a>
<a name="ln3602">{</a>
<a name="ln3603">    for (int i = static_cast&lt;int&gt;(stairs.size()) - 1; i &gt;= 0; --i)</a>
<a name="ln3604">        if (stairs[i].position == pos)</a>
<a name="ln3605">            return i;</a>
<a name="ln3606"> </a>
<a name="ln3607">    return -1;</a>
<a name="ln3608">}</a>
<a name="ln3609"> </a>
<a name="ln3610">void LevelInfo::correct_stair_list(const vector&lt;coord_def&gt; &amp;s)</a>
<a name="ln3611">{</a>
<a name="ln3612">    stair_distances.clear();</a>
<a name="ln3613"> </a>
<a name="ln3614">    // Fix up the grid for the placeholder stair.</a>
<a name="ln3615">    for (stair_info &amp;stair : stairs)</a>
<a name="ln3616">        stair.grid = grd(stair.position);</a>
<a name="ln3617"> </a>
<a name="ln3618">    // First we kill any stairs in 'stairs' that aren't there in 's'.</a>
<a name="ln3619">    for (int i = ((int) stairs.size()) - 1; i &gt;= 0; --i)</a>
<a name="ln3620">    {</a>
<a name="ln3621">        if (stairs[i].type == stair_info::PLACEHOLDER)</a>
<a name="ln3622">            continue;</a>
<a name="ln3623"> </a>
<a name="ln3624">        bool found = false;</a>
<a name="ln3625">        for (int j = s.size() - 1; j &gt;= 0; --j)</a>
<a name="ln3626">        {</a>
<a name="ln3627">            if (s[j] == stairs[i].position)</a>
<a name="ln3628">            {</a>
<a name="ln3629">                found = true;</a>
<a name="ln3630">                break;</a>
<a name="ln3631">            }</a>
<a name="ln3632">        }</a>
<a name="ln3633"> </a>
<a name="ln3634">        if (!found)</a>
<a name="ln3635">            stairs.erase(stairs.begin() + i);</a>
<a name="ln3636">    }</a>
<a name="ln3637"> </a>
<a name="ln3638">    // For each stair in 's', make sure we have a corresponding stair</a>
<a name="ln3639">    // in 'stairs'.</a>
<a name="ln3640">    for (coord_def pos : s)</a>
<a name="ln3641">    {</a>
<a name="ln3642">        int found = -1;</a>
<a name="ln3643">        for (int j = stairs.size() - 1; j &gt;= 0; --j)</a>
<a name="ln3644">        {</a>
<a name="ln3645">            if (pos == stairs[j].position)</a>
<a name="ln3646">            {</a>
<a name="ln3647">                found = j;</a>
<a name="ln3648">                break;</a>
<a name="ln3649">            }</a>
<a name="ln3650">        }</a>
<a name="ln3651"> </a>
<a name="ln3652">        if (found == -1)</a>
<a name="ln3653">        {</a>
<a name="ln3654">            stair_info si;</a>
<a name="ln3655">            si.position = pos;</a>
<a name="ln3656">            si.grid     = grd(si.position);</a>
<a name="ln3657">            si.destination.id = level_id::get_next_level_id(pos);</a>
<a name="ln3658">            if (si.destination.id.branch == BRANCH_VESTIBULE</a>
<a name="ln3659">                &amp;&amp; id.branch == BRANCH_DEPTHS</a>
<a name="ln3660">                &amp;&amp; travel_hell_entry.is_valid())</a>
<a name="ln3661">            {</a>
<a name="ln3662">                si.destination = travel_hell_entry;</a>
<a name="ln3663">            }</a>
<a name="ln3664">            if (!env.map_knowledge(pos).seen())</a>
<a name="ln3665">                si.type = stair_info::MAPPED;</a>
<a name="ln3666"> </a>
<a name="ln3667">            // We don't know where on the next level these stairs go to, but</a>
<a name="ln3668">            // that can't be helped. That information will have to be filled</a>
<a name="ln3669">            // in whenever the player takes these stairs.</a>
<a name="ln3670">            stairs.push_back(si);</a>
<a name="ln3671">        }</a>
<a name="ln3672">        else</a>
<a name="ln3673">            stairs[found].type = env.map_knowledge(pos).seen() ? stair_info::PHYSICAL : stair_info::MAPPED;</a>
<a name="ln3674">    }</a>
<a name="ln3675"> </a>
<a name="ln3676">    resize_stair_distances();</a>
<a name="ln3677">}</a>
<a name="ln3678"> </a>
<a name="ln3679">void LevelInfo::correct_transporter_list(const vector&lt;coord_def&gt; &amp;t)</a>
<a name="ln3680">{</a>
<a name="ln3681">    // First we kill any transporters in 'transporters' that aren't there in 't'.</a>
<a name="ln3682">    for (int i = ((int) transporters.size()) - 1; i &gt;= 0; --i)</a>
<a name="ln3683">    {</a>
<a name="ln3684">        bool found = false;</a>
<a name="ln3685">        for (int j = t.size() - 1; j &gt;= 0; --j)</a>
<a name="ln3686">        {</a>
<a name="ln3687">            if (t[j] == transporters[i].position)</a>
<a name="ln3688">            {</a>
<a name="ln3689">                found = true;</a>
<a name="ln3690">                break;</a>
<a name="ln3691">            }</a>
<a name="ln3692">        }</a>
<a name="ln3693"> </a>
<a name="ln3694">        if (!found)</a>
<a name="ln3695">            transporters.erase(transporters.begin() + i);</a>
<a name="ln3696">    }</a>
<a name="ln3697"> </a>
<a name="ln3698">    // For each transporter in 't', make sure we have a corresponding stair</a>
<a name="ln3699">    // in 'transporters'.</a>
<a name="ln3700">    for (coord_def pos : t)</a>
<a name="ln3701">    {</a>
<a name="ln3702">        int found = -1;</a>
<a name="ln3703">        for (int j = transporters.size() - 1; j &gt;= 0; --j)</a>
<a name="ln3704">        {</a>
<a name="ln3705">            if (pos == transporters[j].position)</a>
<a name="ln3706">            {</a>
<a name="ln3707">                found = j;</a>
<a name="ln3708">                break;</a>
<a name="ln3709">            }</a>
<a name="ln3710">        }</a>
<a name="ln3711"> </a>
<a name="ln3712">        transporter_info::transporter_type type =</a>
<a name="ln3713">            env.map_knowledge(pos).seen() ? transporter_info::PHYSICAL</a>
<a name="ln3714">                                          : transporter_info::MAPPED;</a>
<a name="ln3715">        if (found == -1)</a>
<a name="ln3716">            transporters.push_back(transporter_info(pos, coord_def(), type));</a>
<a name="ln3717">        else</a>
<a name="ln3718">            transporters[found].type = type;</a>
<a name="ln3719">    }</a>
<a name="ln3720">}</a>
<a name="ln3721"> </a>
<a name="ln3722">void LevelInfo::resize_stair_distances()</a>
<a name="ln3723">{</a>
<a name="ln3724">    const int nstairs = stairs.size();</a>
<a name="ln3725">    stair_distances.reserve(nstairs * nstairs);</a>
<a name="ln3726">    stair_distances.resize(nstairs * nstairs, 0);</a>
<a name="ln3727">}</a>
<a name="ln3728"> </a>
<a name="ln3729">int LevelInfo::distance_between(const stair_info *s1, const stair_info *s2)</a>
<a name="ln3730">                    const</a>
<a name="ln3731">{</a>
<a name="ln3732">    if (!s1 || !s2)</a>
<a name="ln3733">        return 0;</a>
<a name="ln3734">    if (s1 == s2)</a>
<a name="ln3735">        return 0;</a>
<a name="ln3736"> </a>
<a name="ln3737">    int i1 = get_stair_index(s1-&gt;position),</a>
<a name="ln3738">        i2 = get_stair_index(s2-&gt;position);</a>
<a name="ln3739">    if (i1 == -1 || i2 == -1)</a>
<a name="ln3740">        return 0;</a>
<a name="ln3741"> </a>
<a name="ln3742">    return stair_distances[ i1 * stairs.size() + i2 ];</a>
<a name="ln3743">}</a>
<a name="ln3744"> </a>
<a name="ln3745">void LevelInfo::get_transporters(vector&lt;coord_def&gt; &amp;tr)</a>
<a name="ln3746">{</a>
<a name="ln3747">    for (rectangle_iterator ri(1); ri; ++ri)</a>
<a name="ln3748">    {</a>
<a name="ln3749">        const dungeon_feature_type feat = grd(*ri);</a>
<a name="ln3750"> </a>
<a name="ln3751">        if (feat == DNGN_TRANSPORTER</a>
<a name="ln3752">            &amp;&amp; (*ri == you.pos() || env.map_knowledge(*ri).known())</a>
<a name="ln3753">            &amp;&amp; env.map_knowledge(*ri).seen())</a>
<a name="ln3754">        {</a>
<a name="ln3755">            tr.push_back(*ri);</a>
<a name="ln3756">        }</a>
<a name="ln3757">    }</a>
<a name="ln3758">}</a>
<a name="ln3759"> </a>
<a name="ln3760">void LevelInfo::get_stairs(vector&lt;coord_def&gt; &amp;st)</a>
<a name="ln3761">{</a>
<a name="ln3762">    for (rectangle_iterator ri(1); ri; ++ri)</a>
<a name="ln3763">    {</a>
<a name="ln3764">        const dungeon_feature_type feat = grd(*ri);</a>
<a name="ln3765"> </a>
<a name="ln3766">        if ((*ri == you.pos() || env.map_knowledge(*ri).known())</a>
<a name="ln3767">            &amp;&amp; feat_is_travelable_stair(feat)</a>
<a name="ln3768">            &amp;&amp; (env.map_knowledge(*ri).seen() || !_is_branch_stair(*ri)))</a>
<a name="ln3769">        {</a>
<a name="ln3770">            st.push_back(*ri);</a>
<a name="ln3771">        }</a>
<a name="ln3772">    }</a>
<a name="ln3773">}</a>
<a name="ln3774"> </a>
<a name="ln3775">void LevelInfo::clear_distances()</a>
<a name="ln3776">{</a>
<a name="ln3777">    for (stair_info &amp;stair : stairs)</a>
<a name="ln3778">        stair.clear_distance();</a>
<a name="ln3779">}</a>
<a name="ln3780"> </a>
<a name="ln3781">bool LevelInfo::is_known_branch(uint8_t branch) const</a>
<a name="ln3782">{</a>
<a name="ln3783">    for (const stair_info &amp;stair : stairs)</a>
<a name="ln3784">        if (stair.destination.id.branch == branch)</a>
<a name="ln3785">            return true;</a>
<a name="ln3786"> </a>
<a name="ln3787">    return false;</a>
<a name="ln3788">}</a>
<a name="ln3789"> </a>
<a name="ln3790">void LevelInfo::save(writer&amp; outf) const</a>
<a name="ln3791">{</a>
<a name="ln3792">    int stair_count = stairs.size();</a>
<a name="ln3793">    // How many stairs do we know of?</a>
<a name="ln3794">    marshallShort(outf, stair_count);</a>
<a name="ln3795">    for (int i = 0; i &lt; stair_count; ++i)</a>
<a name="ln3796">        stairs[i].save(outf);</a>
<a name="ln3797"> </a>
<a name="ln3798">    if (stair_count)</a>
<a name="ln3799">    {</a>
<a name="ln3800">        // Save stair distances as short ints.</a>
<a name="ln3801">        const int sz = stair_distances.size();</a>
<a name="ln3802">        for (int i = 0, n = stair_count * stair_count; i &lt; n; ++i)</a>
<a name="ln3803">        {</a>
<a name="ln3804">            if (i &gt;= sz)</a>
<a name="ln3805">                marshallShort(outf, -1);</a>
<a name="ln3806">            else</a>
<a name="ln3807">                marshallShort(outf, stair_distances[i]);</a>
<a name="ln3808">        }</a>
<a name="ln3809">    }</a>
<a name="ln3810"> </a>
<a name="ln3811">    int transporter_count = transporters.size();</a>
<a name="ln3812">    marshallShort(outf, transporter_count);</a>
<a name="ln3813">    for (int i = 0; i &lt; transporter_count; ++i)</a>
<a name="ln3814">        transporters[i].save(outf);</a>
<a name="ln3815"> </a>
<a name="ln3816">    marshallExcludes(outf, excludes);</a>
<a name="ln3817"> </a>
<a name="ln3818">    marshallByte(outf, NUM_DACTION_COUNTERS);</a>
<a name="ln3819">    for (int i = 0; i &lt; NUM_DACTION_COUNTERS; i++)</a>
<a name="ln3820">        marshallShort(outf, daction_counters[i]);</a>
<a name="ln3821">}</a>
<a name="ln3822"> </a>
<a name="ln3823">void LevelInfo::load(reader&amp; inf, int minorVersion)</a>
<a name="ln3824">{</a>
<a name="ln3825">    stairs.clear();</a>
<a name="ln3826">    int stair_count = unmarshallShort(inf);</a>
<a name="ln3827">    for (int i = 0; i &lt; stair_count; ++i)</a>
<a name="ln3828">    {</a>
<a name="ln3829">        stair_info si;</a>
<a name="ln3830">        si.load(inf);</a>
<a name="ln3831">        stairs.push_back(si);</a>
<a name="ln3832"> </a>
<a name="ln3833">        if (id.branch == BRANCH_DUNGEON</a>
<a name="ln3834">            &amp;&amp; si.destination.id.branch == BRANCH_VESTIBULE</a>
<a name="ln3835">            &amp;&amp; !travel_hell_entry.is_valid()</a>
<a name="ln3836">            &amp;&amp; si.destination.is_valid())</a>
<a name="ln3837">        {</a>
<a name="ln3838">            travel_hell_entry = si.destination;</a>
<a name="ln3839">        }</a>
<a name="ln3840">    }</a>
<a name="ln3841"> </a>
<a name="ln3842">    stair_distances.clear();</a>
<a name="ln3843">    if (stair_count)</a>
<a name="ln3844">    {</a>
<a name="ln3845">        stair_distances.reserve(stair_count * stair_count);</a>
<a name="ln3846">        for (int i = stair_count * stair_count - 1; i &gt;= 0; --i)</a>
<a name="ln3847">            stair_distances.push_back(unmarshallShort(inf));</a>
<a name="ln3848">    }</a>
<a name="ln3849"> </a>
<a name="ln3850">    transporters.clear();</a>
<a name="ln3851">#if TAG_MAJOR_VERSION == 34</a>
<a name="ln3852">    if (minorVersion &gt;= TAG_MINOR_TRANSPORTERS)</a>
<a name="ln3853">    {</a>
<a name="ln3854">#endif</a>
<a name="ln3855">    int transporter_count = unmarshallShort(inf);</a>
<a name="ln3856">    for (int i = 0; i &lt; transporter_count; ++i)</a>
<a name="ln3857">    {</a>
<a name="ln3858">        transporter_info ti;</a>
<a name="ln3859">        ti.load(inf);</a>
<a name="ln3860">        transporters.push_back(ti);</a>
<a name="ln3861">    }</a>
<a name="ln3862">#if TAG_MAJOR_VERSION == 34</a>
<a name="ln3863">    }</a>
<a name="ln3864">#endif</a>
<a name="ln3865"> </a>
<a name="ln3866">    unmarshallExcludes(inf, minorVersion, excludes);</a>
<a name="ln3867"> </a>
<a name="ln3868">    int n_count = unmarshallByte(inf);</a>
<a name="ln3869">    ASSERT_RANGE(n_count, 0, NUM_DACTION_COUNTERS + 1);</a>
<a name="ln3870">    for (int i = 0; i &lt; n_count; i++)</a>
<a name="ln3871">        daction_counters[i] = unmarshallShort(inf);</a>
<a name="ln3872">}</a>
<a name="ln3873"> </a>
<a name="ln3874">void LevelInfo::fixup()</a>
<a name="ln3875">{</a>
<a name="ln3876">    // The only fixup we do now is for the hell entry.</a>
<a name="ln3877">    if (id.branch != BRANCH_DEPTHS || !travel_hell_entry.is_valid())</a>
<a name="ln3878">        return;</a>
<a name="ln3879"> </a>
<a name="ln3880">    for (stair_info &amp;si : stairs)</a>
<a name="ln3881">    {</a>
<a name="ln3882">        if (si.destination.id.branch == BRANCH_VESTIBULE</a>
<a name="ln3883">            &amp;&amp; !si.destination.is_valid())</a>
<a name="ln3884">        {</a>
<a name="ln3885">            si.destination = travel_hell_entry;</a>
<a name="ln3886">        }</a>
<a name="ln3887">    }</a>
<a name="ln3888">}</a>
<a name="ln3889"> </a>
<a name="ln3890">void TravelCache::update_stone_stair(const coord_def &amp;c)</a>
<a name="ln3891">{</a>
<a name="ln3892">    if (!env.map_knowledge(c).seen())</a>
<a name="ln3893">        return;</a>
<a name="ln3894">    LevelInfo *li = find_level_info(level_id::current());</a>
<a name="ln3895">    if (!li)</a>
<a name="ln3896">        return;</a>
<a name="ln3897">    stair_info *si = li-&gt;get_stair(c);</a>
<a name="ln3898">    // Don't bother proceeding further if we already know where the stair goes.</a>
<a name="ln3899">    if (si &amp;&amp; si-&gt;destination.is_valid())</a>
<a name="ln3900">        return;</a>
<a name="ln3901">    const dungeon_feature_type feat1 = grd(c);</a>
<a name="ln3902">    ASSERT(feat_is_stone_stair(feat1));</a>
<a name="ln3903">    // Compute the corresponding feature type on the other side of the stairs.</a>
<a name="ln3904">    const dungeon_feature_type feat2 = (dungeon_feature_type)</a>
<a name="ln3905">          (feat1 + (feat_is_stone_stair_up(feat1) ? 1 : -1)</a>
<a name="ln3906">                   * (DNGN_STONE_STAIRS_DOWN_I - DNGN_STONE_STAIRS_UP_I));</a>
<a name="ln3907">    LevelInfo *li2 = find_level_info(level_id::get_next_level_id(c));</a>
<a name="ln3908">    if (!li2)</a>
<a name="ln3909">        return;</a>
<a name="ln3910">    for (int i = static_cast&lt;int&gt;(li2-&gt;stairs.size()) - 1; i &gt;= 0; --i)</a>
<a name="ln3911">    {</a>
<a name="ln3912">        if (li2-&gt;stairs[i].grid == feat2)</a>
<a name="ln3913">        {</a>
<a name="ln3914">            if (li2-&gt;stairs[i].type == stair_info::MAPPED)</a>
<a name="ln3915">                return;</a>
<a name="ln3916">            // If we haven't added these stairs to our LevelInfo yet, do so</a>
<a name="ln3917">            // before trying to update them.</a>
<a name="ln3918">            if (!si)</a>
<a name="ln3919">            {</a>
<a name="ln3920">                stair_info si2;</a>
<a name="ln3921">                si2.position = c;</a>
<a name="ln3922">                si2.grid = grd(si2.position);</a>
<a name="ln3923">                li-&gt;stairs.push_back(si2);</a>
<a name="ln3924">            }</a>
<a name="ln3925">            li-&gt;update_stair(c,level_pos(li2-&gt;id,li2-&gt;stairs[i].position));</a>
<a name="ln3926">            // Add the other stair direction too so that X[]ing to the other</a>
<a name="ln3927">            // level will be correct immediately.</a>
<a name="ln3928">            li2-&gt;update_stair(li2-&gt;stairs[i].position,level_pos(li-&gt;id,c));</a>
<a name="ln3929">            return;</a>
<a name="ln3930">        }</a>
<a name="ln3931">    }</a>
<a name="ln3932">}</a>
<a name="ln3933"> </a>
<a name="ln3934">void TravelCache::update_transporter(const coord_def &amp;c)</a>
<a name="ln3935">{</a>
<a name="ln3936">    const dungeon_feature_type feat = grd(c);</a>
<a name="ln3937">    ASSERT(feat == DNGN_TRANSPORTER);</a>
<a name="ln3938"> </a>
<a name="ln3939">    if (!env.map_knowledge(c).seen())</a>
<a name="ln3940">        return;</a>
<a name="ln3941"> </a>
<a name="ln3942">    LevelInfo *li = find_level_info(level_id::current());</a>
<a name="ln3943">    if (!li)</a>
<a name="ln3944">        return;</a>
<a name="ln3945"> </a>
<a name="ln3946">    transporter_info *ti = li-&gt;get_transporter(c);</a>
<a name="ln3947">    if (!ti)</a>
<a name="ln3948">    {</a>
<a name="ln3949">        li-&gt;transporters.push_back(transporter_info(c, coord_def(),</a>
<a name="ln3950">                                   transporter_info::transporter_type::PHYSICAL));</a>
<a name="ln3951">    }</a>
<a name="ln3952">}</a>
<a name="ln3953"> </a>
<a name="ln3954">bool TravelCache::know_transporter(const coord_def &amp;c)</a>
<a name="ln3955">{</a>
<a name="ln3956">    if (grd(c) == DNGN_TRANSPORTER)</a>
<a name="ln3957">        update_transporter(c);</a>
<a name="ln3958">    auto i = levels.find(level_id::current());</a>
<a name="ln3959">    return i == levels.end() ? false : i-&gt;second.know_transporter(c);</a>
<a name="ln3960">}</a>
<a name="ln3961"> </a>
<a name="ln3962">bool TravelCache::know_stair(const coord_def &amp;c)</a>
<a name="ln3963">{</a>
<a name="ln3964">     if (feat_is_stone_stair(grd(c)))</a>
<a name="ln3965">         update_stone_stair(c);</a>
<a name="ln3966">    auto i = levels.find(level_id::current());</a>
<a name="ln3967">    return i == levels.end() ? false : i-&gt;second.know_stair(c);</a>
<a name="ln3968">}</a>
<a name="ln3969"> </a>
<a name="ln3970">void TravelCache::list_waypoints() const</a>
<a name="ln3971">{</a>
<a name="ln3972">    string line;</a>
<a name="ln3973">    string dest;</a>
<a name="ln3974">    char choice[50];</a>
<a name="ln3975">    int count = 0;</a>
<a name="ln3976"> </a>
<a name="ln3977">    for (int i = 0; i &lt; TRAVEL_WAYPOINT_COUNT; ++i)</a>
<a name="ln3978">    {</a>
<a name="ln3979">        if (waypoints[i].id.depth == -1)</a>
<a name="ln3980">            continue;</a>
<a name="ln3981"> </a>
<a name="ln3982">        dest = _get_trans_travel_dest(waypoints[i], false, true);</a>
<a name="ln3983"> </a>
<a name="ln3984">        snprintf(choice, sizeof choice, &quot;(%d) %-9s&quot;, i, dest.c_str());</a>
<a name="ln3985">        line += choice;</a>
<a name="ln3986">        if (!(++count % 5))</a>
<a name="ln3987">        {</a>
<a name="ln3988">            mpr(line);</a>
<a name="ln3989">            line = &quot;&quot;;</a>
<a name="ln3990">        }</a>
<a name="ln3991">    }</a>
<a name="ln3992">    if (!line.empty())</a>
<a name="ln3993">        mpr(line);</a>
<a name="ln3994">}</a>
<a name="ln3995"> </a>
<a name="ln3996">uint8_t TravelCache::is_waypoint(const level_pos &amp;lp) const</a>
<a name="ln3997">{</a>
<a name="ln3998">    for (int i = 0; i &lt; TRAVEL_WAYPOINT_COUNT; ++i)</a>
<a name="ln3999">        if (lp == waypoints[i])</a>
<a name="ln4000">            return '0' + i;</a>
<a name="ln4001"> </a>
<a name="ln4002">    return 0;</a>
<a name="ln4003">}</a>
<a name="ln4004"> </a>
<a name="ln4005">void TravelCache::update_waypoints() const</a>
<a name="ln4006">{</a>
<a name="ln4007">    level_pos lp;</a>
<a name="ln4008">    lp.id = level_id::current();</a>
<a name="ln4009"> </a>
<a name="ln4010">    memset(curr_waypoints, 0, sizeof curr_waypoints);</a>
<a name="ln4011">    for (lp.pos.x = 1; lp.pos.x &lt; GXM; ++lp.pos.x)</a>
<a name="ln4012">        for (lp.pos.y = 1; lp.pos.y &lt; GYM; ++lp.pos.y)</a>
<a name="ln4013">        {</a>
<a name="ln4014">            uint8_t wpc = is_waypoint(lp);</a>
<a name="ln4015">            if (wpc)</a>
<a name="ln4016">                curr_waypoints[lp.pos.x][lp.pos.y] = wpc;</a>
<a name="ln4017">        }</a>
<a name="ln4018">}</a>
<a name="ln4019"> </a>
<a name="ln4020">void TravelCache::delete_waypoint()</a>
<a name="ln4021">{</a>
<a name="ln4022">    if (!get_waypoint_count())</a>
<a name="ln4023">        return;</a>
<a name="ln4024"> </a>
<a name="ln4025">    while (get_waypoint_count())</a>
<a name="ln4026">    {</a>
<a name="ln4027">        clear_messages();</a>
<a name="ln4028">        mpr(&quot;Existing waypoints:&quot;);</a>
<a name="ln4029">        list_waypoints();</a>
<a name="ln4030">        mprf(MSGCH_PROMPT, &quot;Delete which waypoint? (* - delete all, Esc - exit) &quot;);</a>
<a name="ln4031"> </a>
<a name="ln4032">        int key = getchm();</a>
<a name="ln4033">        if (key &gt;= '0' &amp;&amp; key &lt;= '9')</a>
<a name="ln4034">        {</a>
<a name="ln4035">            key -= '0';</a>
<a name="ln4036">            if (waypoints[key].is_valid())</a>
<a name="ln4037">            {</a>
<a name="ln4038">                waypoints[key].clear();</a>
<a name="ln4039">                update_waypoints();</a>
<a name="ln4040">                continue;</a>
<a name="ln4041">            }</a>
<a name="ln4042">        }</a>
<a name="ln4043">        else if (key == '*')</a>
<a name="ln4044">        {</a>
<a name="ln4045">            for (int i = 0; i &lt; TRAVEL_WAYPOINT_COUNT; ++i)</a>
<a name="ln4046">                waypoints[i].clear();</a>
<a name="ln4047"> </a>
<a name="ln4048">            update_waypoints();</a>
<a name="ln4049">            break;</a>
<a name="ln4050">        }</a>
<a name="ln4051"> </a>
<a name="ln4052">        canned_msg(MSG_OK);</a>
<a name="ln4053">        return;</a>
<a name="ln4054">    }</a>
<a name="ln4055"> </a>
<a name="ln4056">    clear_messages();</a>
<a name="ln4057">    mpr(&quot;All waypoints deleted. Have a nice day!&quot;);</a>
<a name="ln4058">}</a>
<a name="ln4059"> </a>
<a name="ln4060">void TravelCache::add_waypoint(int x, int y)</a>
<a name="ln4061">{</a>
<a name="ln4062">    if (!can_travel_interlevel())</a>
<a name="ln4063">    {</a>
<a name="ln4064">        mpr(&quot;Sorry, you can't set a waypoint here.&quot;);</a>
<a name="ln4065">        return;</a>
<a name="ln4066">    }</a>
<a name="ln4067"> </a>
<a name="ln4068">    clear_messages();</a>
<a name="ln4069"> </a>
<a name="ln4070">    const bool waypoints_exist = get_waypoint_count();</a>
<a name="ln4071">    if (waypoints_exist)</a>
<a name="ln4072">    {</a>
<a name="ln4073">        mpr(&quot;Existing waypoints:&quot;);</a>
<a name="ln4074">        list_waypoints();</a>
<a name="ln4075">    }</a>
<a name="ln4076"> </a>
<a name="ln4077">    mprf(MSGCH_PROMPT, &quot;Assign waypoint to what number? (0-9%s) &quot;,</a>
<a name="ln4078">         waypoints_exist? &quot;, D - delete waypoint&quot; : &quot;&quot;);</a>
<a name="ln4079"> </a>
<a name="ln4080">    int keyin = toalower(get_ch());</a>
<a name="ln4081"> </a>
<a name="ln4082">    if (waypoints_exist &amp;&amp; keyin == 'd')</a>
<a name="ln4083">    {</a>
<a name="ln4084">        delete_waypoint();</a>
<a name="ln4085">        return;</a>
<a name="ln4086">    }</a>
<a name="ln4087"> </a>
<a name="ln4088">    if (keyin &lt; '0' || keyin &gt; '9')</a>
<a name="ln4089">    {</a>
<a name="ln4090">        canned_msg(MSG_OK);</a>
<a name="ln4091">        return;</a>
<a name="ln4092">    }</a>
<a name="ln4093"> </a>
<a name="ln4094">    set_waypoint(keyin - '0', x, y);</a>
<a name="ln4095"> </a>
<a name="ln4096">}</a>
<a name="ln4097"> </a>
<a name="ln4098">void TravelCache::set_waypoint(int waynum, int x, int y)</a>
<a name="ln4099">{</a>
<a name="ln4100">    ASSERT_RANGE(waynum, 0, TRAVEL_WAYPOINT_COUNT);</a>
<a name="ln4101">    coord_def pos(x,y);</a>
<a name="ln4102">    if (x == -1 || y == -1)</a>
<a name="ln4103">        pos = you.pos();</a>
<a name="ln4104"> </a>
<a name="ln4105">    const level_id &amp;lid = level_id::current();</a>
<a name="ln4106"> </a>
<a name="ln4107">    const bool overwrite = waypoints[waynum].is_valid();</a>
<a name="ln4108"> </a>
<a name="ln4109">    string old_dest =</a>
<a name="ln4110">        overwrite ? _get_trans_travel_dest(waypoints[waynum], false, true) : &quot;&quot;;</a>
<a name="ln4111">    level_id old_lid = (overwrite ? waypoints[waynum].id : lid);</a>
<a name="ln4112"> </a>
<a name="ln4113">    waypoints[waynum].id  = lid;</a>
<a name="ln4114">    waypoints[waynum].pos = pos;</a>
<a name="ln4115"> </a>
<a name="ln4116">    string new_dest = _get_trans_travel_dest(waypoints[waynum], false, true);</a>
<a name="ln4117">    clear_messages();</a>
<a name="ln4118">    if (overwrite)</a>
<a name="ln4119">    {</a>
<a name="ln4120">        if (lid == old_lid) // same level</a>
<a name="ln4121">            mprf(&quot;Waypoint %d re-assigned to %s.&quot;, waynum, new_dest.c_str());</a>
<a name="ln4122">        else</a>
<a name="ln4123">        {</a>
<a name="ln4124">            mprf(&quot;Waypoint %d re-assigned from %s to %s.&quot;,</a>
<a name="ln4125">                 waynum, old_dest.c_str(), new_dest.c_str());</a>
<a name="ln4126">        }</a>
<a name="ln4127">    }</a>
<a name="ln4128">    else</a>
<a name="ln4129">        mprf(&quot;Waypoint %d assigned to %s.&quot;, waynum, new_dest.c_str());</a>
<a name="ln4130"> </a>
<a name="ln4131">    update_waypoints();</a>
<a name="ln4132">}</a>
<a name="ln4133"> </a>
<a name="ln4134">int TravelCache::get_waypoint_count() const</a>
<a name="ln4135">{</a>
<a name="ln4136">    int count = 0;</a>
<a name="ln4137">    for (int i = 0; i &lt; TRAVEL_WAYPOINT_COUNT; ++i)</a>
<a name="ln4138">        if (waypoints[i].is_valid())</a>
<a name="ln4139">            count++;</a>
<a name="ln4140"> </a>
<a name="ln4141">    return count;</a>
<a name="ln4142">}</a>
<a name="ln4143"> </a>
<a name="ln4144">void TravelCache::clear_distances()</a>
<a name="ln4145">{</a>
<a name="ln4146">    for (auto &amp;entry : levels)</a>
<a name="ln4147">        entry.second.clear_distances();</a>
<a name="ln4148">}</a>
<a name="ln4149"> </a>
<a name="ln4150">bool TravelCache::is_known_branch(uint8_t branch) const</a>
<a name="ln4151">{</a>
<a name="ln4152">    return any_of(begin(levels), end(levels),</a>
<a name="ln4153">            [branch] (const pair&lt;level_id, LevelInfo&gt; &amp;entry)</a>
<a name="ln4154">            { return entry.second.is_known_branch(branch); });</a>
<a name="ln4155">}</a>
<a name="ln4156"> </a>
<a name="ln4157">void TravelCache::save(writer&amp; outf) const</a>
<a name="ln4158">{</a>
<a name="ln4159">    write_save_version(outf, save_version::current());</a>
<a name="ln4160"> </a>
<a name="ln4161">    // Write level count.</a>
<a name="ln4162">    marshallShort(outf, levels.size());</a>
<a name="ln4163"> </a>
<a name="ln4164">    for (const auto &amp;entry : levels)</a>
<a name="ln4165">    {</a>
<a name="ln4166">        entry.first.save(outf);</a>
<a name="ln4167">        entry.second.save(outf);</a>
<a name="ln4168">    }</a>
<a name="ln4169"> </a>
<a name="ln4170">    for (int wp = 0; wp &lt; TRAVEL_WAYPOINT_COUNT; ++wp)</a>
<a name="ln4171">        waypoints[wp].save(outf);</a>
<a name="ln4172">}</a>
<a name="ln4173"> </a>
<a name="ln4174">void TravelCache::load(reader&amp; inf, int minorVersion)</a>
<a name="ln4175">{</a>
<a name="ln4176">    levels.clear();</a>
<a name="ln4177"> </a>
<a name="ln4178">    // Check version. If not compatible, we just ignore the file altogether.</a>
<a name="ln4179">    const auto version = get_save_version(inf);</a>
<a name="ln4180">    const auto major = version.major, minor = version.minor;</a>
<a name="ln4181">    if (major != TAG_MAJOR_VERSION || minor &gt; TAG_MINOR_VERSION)</a>
<a name="ln4182">        return;</a>
<a name="ln4183"> </a>
<a name="ln4184">    int level_count = unmarshallShort(inf);</a>
<a name="ln4185">    for (int i = 0; i &lt; level_count; ++i)</a>
<a name="ln4186">    {</a>
<a name="ln4187">        level_id id;</a>
<a name="ln4188">        id.load(inf);</a>
<a name="ln4189"> </a>
<a name="ln4190">        LevelInfo linfo;</a>
<a name="ln4191">        // Must set id before load, or travel_hell_entry will not be</a>
<a name="ln4192">        // correctly set.</a>
<a name="ln4193">        linfo.id = id;</a>
<a name="ln4194">        linfo.load(inf, minorVersion);</a>
<a name="ln4195"> </a>
<a name="ln4196">        levels[id] = linfo;</a>
<a name="ln4197">    }</a>
<a name="ln4198"> </a>
<a name="ln4199">    for (int wp = 0; wp &lt; TRAVEL_WAYPOINT_COUNT; ++wp)</a>
<a name="ln4200">        waypoints[wp].load(inf);</a>
<a name="ln4201"> </a>
<a name="ln4202">    fixup_levels();</a>
<a name="ln4203">}</a>
<a name="ln4204"> </a>
<a name="ln4205">void TravelCache::set_level_excludes()</a>
<a name="ln4206">{</a>
<a name="ln4207">    get_level_info(level_id::current()).set_level_excludes();</a>
<a name="ln4208">}</a>
<a name="ln4209"> </a>
<a name="ln4210">void TravelCache::update_excludes()</a>
<a name="ln4211">{</a>
<a name="ln4212">    get_level_info(level_id::current()).update_excludes();</a>
<a name="ln4213">}</a>
<a name="ln4214"> </a>
<a name="ln4215">void TravelCache::update()</a>
<a name="ln4216">{</a>
<a name="ln4217">    get_level_info(level_id::current()).update();</a>
<a name="ln4218">}</a>
<a name="ln4219"> </a>
<a name="ln4220">void TravelCache::update_daction_counters()</a>
<a name="ln4221">{</a>
<a name="ln4222">    ::update_daction_counters(&amp;get_level_info(level_id::current()));</a>
<a name="ln4223">}</a>
<a name="ln4224"> </a>
<a name="ln4225">unsigned int TravelCache::query_daction_counter(daction_type c)</a>
<a name="ln4226">{</a>
<a name="ln4227">    // other levels are up to date, the current one not necessarily so</a>
<a name="ln4228">    update_daction_counters();</a>
<a name="ln4229"> </a>
<a name="ln4230">    unsigned int sum = 0;</a>
<a name="ln4231"> </a>
<a name="ln4232">    for (const auto &amp;entry : levels)</a>
<a name="ln4233">        sum += entry.second.daction_counters[c];</a>
<a name="ln4234"> </a>
<a name="ln4235">    return sum;</a>
<a name="ln4236">}</a>
<a name="ln4237"> </a>
<a name="ln4238">void TravelCache::clear_daction_counter(daction_type c)</a>
<a name="ln4239">{</a>
<a name="ln4240">    for (auto &amp;entry : levels)</a>
<a name="ln4241">        entry.second.daction_counters[c] = 0;</a>
<a name="ln4242">}</a>
<a name="ln4243"> </a>
<a name="ln4244">void TravelCache::fixup_levels()</a>
<a name="ln4245">{</a>
<a name="ln4246">    for (auto &amp;entry : levels)</a>
<a name="ln4247">        entry.second.fixup();</a>
<a name="ln4248">}</a>
<a name="ln4249"> </a>
<a name="ln4250">vector&lt;level_id&gt; TravelCache::known_levels() const</a>
<a name="ln4251">{</a>
<a name="ln4252">    vector&lt;level_id&gt; levs;</a>
<a name="ln4253"> </a>
<a name="ln4254">    for (const auto &amp;entry : levels)</a>
<a name="ln4255">        levs.push_back(entry.first);</a>
<a name="ln4256"> </a>
<a name="ln4257">    return levs;</a>
<a name="ln4258">}</a>
<a name="ln4259"> </a>
<a name="ln4260">bool can_travel_to(const level_id &amp;id)</a>
<a name="ln4261">{</a>
<a name="ln4262">    return is_connected_branch(id) &amp;&amp; can_travel_interlevel()</a>
<a name="ln4263">           || id == level_id::current();</a>
<a name="ln4264">}</a>
<a name="ln4265"> </a>
<a name="ln4266">bool can_travel_interlevel()</a>
<a name="ln4267">{</a>
<a name="ln4268">    return player_in_connected_branch();</a>
<a name="ln4269">}</a>
<a name="ln4270"> </a>
<a name="ln4271">/////////////////////////////////////////////////////////////////////////////</a>
<a name="ln4272">// Shift-running and resting.</a>
<a name="ln4273"> </a>
<a name="ln4274">runrest::runrest()</a>
<a name="ln4275">    : runmode(0), mp(0), hp(0), pos(0,0)</a>
<a name="ln4276">{</a>
<a name="ln4277">}</a>
<a name="ln4278"> </a>
<a name="ln4279">// Initialise is only called for resting/shift-running. We should eventually</a>
<a name="ln4280">// include travel and wrap it all in.</a>
<a name="ln4281">void runrest::initialise(int dir, int mode)</a>
<a name="ln4282">{</a>
<a name="ln4283">    // Note HP and MP for reference.</a>
<a name="ln4284">    hp = you.hp;</a>
<a name="ln4285">    mp = you.magic_points;</a>
<a name="ln4286">    direction = dir;</a>
<a name="ln4287">    notified_hp_full = false;</a>
<a name="ln4288">    notified_mp_full = false;</a>
<a name="ln4289">    notified_ancestor_hp_full = false;</a>
<a name="ln4290">    init_travel_speed();</a>
<a name="ln4291"> </a>
<a name="ln4292">    if (dir == RDIR_REST)</a>
<a name="ln4293">    {</a>
<a name="ln4294">        pos.reset();</a>
<a name="ln4295">        runmode = mode;</a>
<a name="ln4296">    }</a>
<a name="ln4297">    else</a>
<a name="ln4298">    {</a>
<a name="ln4299">        ASSERT_RANGE(dir, 0, 8);</a>
<a name="ln4300"> </a>
<a name="ln4301">        pos = Compass[dir];</a>
<a name="ln4302">        runmode = mode;</a>
<a name="ln4303"> </a>
<a name="ln4304">        // Get the compass point to the left/right of intended travel:</a>
<a name="ln4305">        const int left  = (dir - 1 &lt; 0) ? 7 : (dir - 1);</a>
<a name="ln4306">        const int right = (dir + 1 &gt; 7) ? 0 : (dir + 1);</a>
<a name="ln4307"> </a>
<a name="ln4308">        // Record the direction and starting tile type for later reference:</a>
<a name="ln4309">        set_run_check(0, left);</a>
<a name="ln4310">        set_run_check(1, dir);</a>
<a name="ln4311">        set_run_check(2, right);</a>
<a name="ln4312">    }</a>
<a name="ln4313"> </a>
<a name="ln4314">    if (runmode == RMODE_REST_DURATION || runmode == RMODE_WAIT_DURATION)</a>
<a name="ln4315">        start_delay&lt;RestDelay&gt;();</a>
<a name="ln4316">    else</a>
<a name="ln4317">        start_delay&lt;RunDelay&gt;();</a>
<a name="ln4318">}</a>
<a name="ln4319"> </a>
<a name="ln4320">void runrest::init_travel_speed()</a>
<a name="ln4321">{</a>
<a name="ln4322">    if (you.travel_ally_pace)</a>
<a name="ln4323">        travel_speed = _slowest_ally_speed();</a>
<a name="ln4324">    else</a>
<a name="ln4325">        travel_speed = 0;</a>
<a name="ln4326">}</a>
<a name="ln4327"> </a>
<a name="ln4328">runrest::operator int () const</a>
<a name="ln4329">{</a>
<a name="ln4330">    return runmode;</a>
<a name="ln4331">}</a>
<a name="ln4332"> </a>
<a name="ln4333">const runrest &amp;runrest::operator = (int newrunmode)</a>
<a name="ln4334">{</a>
<a name="ln4335">    runmode = newrunmode;</a>
<a name="ln4336">    return *this;</a>
<a name="ln4337">}</a>
<a name="ln4338"> </a>
<a name="ln4339">static dungeon_feature_type _base_feat_type(dungeon_feature_type grid)</a>
<a name="ln4340">{</a>
<a name="ln4341">    // Merge walls.</a>
<a name="ln4342">    if (feat_is_wall(grid))</a>
<a name="ln4343">        return DNGN_ROCK_WALL;</a>
<a name="ln4344"> </a>
<a name="ln4345">    return grid;</a>
<a name="ln4346">}</a>
<a name="ln4347"> </a>
<a name="ln4348">void runrest::set_run_check(int index, int dir)</a>
<a name="ln4349">{</a>
<a name="ln4350">    run_check[index].delta = Compass[dir];</a>
<a name="ln4351"> </a>
<a name="ln4352">    const coord_def p = you.pos() + Compass[dir];</a>
<a name="ln4353">    run_check[index].grid = _base_feat_type(env.map_knowledge(p).feat());</a>
<a name="ln4354">}</a>
<a name="ln4355"> </a>
<a name="ln4356">bool runrest::check_stop_running()</a>
<a name="ln4357">{</a>
<a name="ln4358">    if (runmode &gt; 0 &amp;&amp; runmode != RMODE_START &amp;&amp; run_should_stop())</a>
<a name="ln4359">    {</a>
<a name="ln4360">        stop();</a>
<a name="ln4361">        return true;</a>
<a name="ln4362">    }</a>
<a name="ln4363">    return false;</a>
<a name="ln4364">}</a>
<a name="ln4365"> </a>
<a name="ln4366">// This function creates &quot;equivalence classes&quot; so that changes</a>
<a name="ln4367">// in wall and floor type aren't running stopping points.</a>
<a name="ln4368">bool runrest::run_should_stop() const</a>
<a name="ln4369">{</a>
<a name="ln4370">    const coord_def targ = you.pos() + pos;</a>
<a name="ln4371">    const map_cell&amp; tcell = env.map_knowledge(targ);</a>
<a name="ln4372"> </a>
<a name="ln4373">    // XXX: probably this should ignore cosmetic clouds (non-opaque)</a>
<a name="ln4374">    if (tcell.cloud() != CLOUD_NONE</a>
<a name="ln4375">        &amp;&amp; !you.cloud_immune())</a>
<a name="ln4376">    {</a>
<a name="ln4377">        return true;</a>
<a name="ln4378">    }</a>
<a name="ln4379"> </a>
<a name="ln4380">    if (is_excluded(targ) &amp;&amp; !is_stair_exclusion(targ))</a>
<a name="ln4381">    {</a>
<a name="ln4382">#ifndef USE_TILE_LOCAL</a>
<a name="ln4383">        // XXX: Remove this once exclusions are visible.</a>
<a name="ln4384">        mprf(MSGCH_WARN, &quot;Stopped running for exclusion.&quot;);</a>
<a name="ln4385">#endif</a>
<a name="ln4386">        return true;</a>
<a name="ln4387">    }</a>
<a name="ln4388"> </a>
<a name="ln4389">    const monster_info* mon = tcell.monsterinfo();</a>
<a name="ln4390">    if (mon &amp;&amp; !fedhas_passthrough(tcell.monsterinfo()))</a>
<a name="ln4391">        return true;</a>
<a name="ln4392"> </a>
<a name="ln4393">    if (count_adjacent_slime_walls(targ))</a>
<a name="ln4394">        return true;</a>
<a name="ln4395"> </a>
<a name="ln4396">    for (int i = 0; i &lt; 3; i++)</a>
<a name="ln4397">    {</a>
<a name="ln4398">        const coord_def p = you.pos() + run_check[i].delta;</a>
<a name="ln4399">        const dungeon_feature_type feat =</a>
<a name="ln4400">            _base_feat_type(env.map_knowledge(p).feat());</a>
<a name="ln4401"> </a>
<a name="ln4402">        if (run_check[i].grid != feat)</a>
<a name="ln4403">            return true;</a>
<a name="ln4404">    }</a>
<a name="ln4405"> </a>
<a name="ln4406">    bool is_running_diag = (direction % 2 == 1);</a>
<a name="ln4407">    if (is_running_diag &amp;&amp; diag_run_passes_door())</a>
<a name="ln4408">        return true;</a>
<a name="ln4409"> </a>
<a name="ln4410">    return false;</a>
<a name="ln4411">}</a>
<a name="ln4412"> </a>
<a name="ln4413">// Checks whether the player passes a door when running diagonally, since</a>
<a name="ln4414">// in certain situations those could be overlooked by only checking &quot;left&quot;</a>
<a name="ln4415">// and &quot;right&quot;.</a>
<a name="ln4416">// Can be extended if other features should lead to stopping as well.</a>
<a name="ln4417">bool runrest::diag_run_passes_door() const</a>
<a name="ln4418">{</a>
<a name="ln4419">    const int diag_left = (direction + 6) % 8;</a>
<a name="ln4420">    const int diag_right = (direction + 2) % 8;</a>
<a name="ln4421">    const int diag_dirs[2] = { diag_left, diag_right };</a>
<a name="ln4422">    for (int dir : diag_dirs)</a>
<a name="ln4423">    {</a>
<a name="ln4424">        const coord_def p = you.pos() + Compass[dir];</a>
<a name="ln4425">        const auto feat = env.map_knowledge(p).feat();</a>
<a name="ln4426">        if (feat_is_door(feat))</a>
<a name="ln4427">            return true;</a>
<a name="ln4428">    }</a>
<a name="ln4429"> </a>
<a name="ln4430">    return false;</a>
<a name="ln4431">}</a>
<a name="ln4432"> </a>
<a name="ln4433">void runrest::stop(bool clear_delays)</a>
<a name="ln4434">{</a>
<a name="ln4435">    bool need_redraw =</a>
<a name="ln4436">        (runmode &gt; 0 || runmode &lt; 0 &amp;&amp; Options.travel_delay == -1);</a>
<a name="ln4437">    _userdef_run_stoprunning_hook();</a>
<a name="ln4438">    runmode = RMODE_NOT_RUNNING;</a>
<a name="ln4439"> </a>
<a name="ln4440">    // Kill the delay; this is fine because it's not possible to stack</a>
<a name="ln4441">    // run/rest/travel on top of other delays.</a>
<a name="ln4442">    if (clear_delays)</a>
<a name="ln4443">        stop_delay();</a>
<a name="ln4444"> </a>
<a name="ln4445">#ifdef USE_TILE_LOCAL</a>
<a name="ln4446">    if (Options.tile_runrest_rate &gt; 0)</a>
<a name="ln4447">        tiles.set_need_redraw();</a>
<a name="ln4448">#endif</a>
<a name="ln4449"> </a>
<a name="ln4450">    if (need_redraw)</a>
<a name="ln4451">        viewwindow();</a>
<a name="ln4452">}</a>
<a name="ln4453"> </a>
<a name="ln4454">bool runrest::is_rest() const</a>
<a name="ln4455">{</a>
<a name="ln4456">    return runmode &gt; 0 &amp;&amp; pos.origin();</a>
<a name="ln4457">}</a>
<a name="ln4458"> </a>
<a name="ln4459">bool runrest::is_explore() const</a>
<a name="ln4460">{</a>
<a name="ln4461">    return runmode == RMODE_EXPLORE || runmode == RMODE_EXPLORE_GREEDY;</a>
<a name="ln4462">}</a>
<a name="ln4463"> </a>
<a name="ln4464">bool runrest::is_any_travel() const</a>
<a name="ln4465">{</a>
<a name="ln4466">    switch (runmode)</a>
<a name="ln4467">    {</a>
<a name="ln4468">    case RMODE_INTERLEVEL:</a>
<a name="ln4469">    case RMODE_EXPLORE_GREEDY:</a>
<a name="ln4470">    case RMODE_EXPLORE:</a>
<a name="ln4471">    case RMODE_TRAVEL:</a>
<a name="ln4472">        return true;</a>
<a name="ln4473">    default:</a>
<a name="ln4474">        return false;</a>
<a name="ln4475">    }</a>
<a name="ln4476">}</a>
<a name="ln4477"> </a>
<a name="ln4478">string runrest::runmode_name() const</a>
<a name="ln4479">{</a>
<a name="ln4480">    switch (runmode)</a>
<a name="ln4481">    {</a>
<a name="ln4482">    case RMODE_EXPLORE:</a>
<a name="ln4483">    case RMODE_EXPLORE_GREEDY:</a>
<a name="ln4484">        return &quot;explore&quot;;</a>
<a name="ln4485">    case RMODE_INTERLEVEL:</a>
<a name="ln4486">    case RMODE_TRAVEL:</a>
<a name="ln4487">        return &quot;travel&quot;;</a>
<a name="ln4488">    default:</a>
<a name="ln4489">        if (runmode &gt; 0)</a>
<a name="ln4490">            return pos.origin()? &quot;rest&quot; : &quot;run&quot;;</a>
<a name="ln4491">        return &quot;&quot;;</a>
<a name="ln4492">    }</a>
<a name="ln4493">}</a>
<a name="ln4494"> </a>
<a name="ln4495">void runrest::rest()</a>
<a name="ln4496">{</a>
<a name="ln4497">    // stop_running() Lua hooks will never see rest stops.</a>
<a name="ln4498">    if (runmode &gt; 0)</a>
<a name="ln4499">        --runmode;</a>
<a name="ln4500">}</a>
<a name="ln4501"> </a>
<a name="ln4502">void runrest::clear()</a>
<a name="ln4503">{</a>
<a name="ln4504">    runmode = RMODE_NOT_RUNNING;</a>
<a name="ln4505">    pos.reset();</a>
<a name="ln4506">    mp = hp = travel_speed = 0;</a>
<a name="ln4507">    notified_hp_full = false;</a>
<a name="ln4508">    notified_mp_full = false;</a>
<a name="ln4509">    notified_ancestor_hp_full = false;</a>
<a name="ln4510">}</a>
<a name="ln4511"> </a>
<a name="ln4512">/////////////////////////////////////////////////////////////////////////////</a>
<a name="ln4513">// explore_discoveries</a>
<a name="ln4514"> </a>
<a name="ln4515">explore_discoveries::explore_discoveries()</a>
<a name="ln4516">    : can_autopickup(::can_autopickup()),</a>
<a name="ln4517">      es_flags(0),</a>
<a name="ln4518">      current_level(nullptr), items(), stairs(), portals(), shops(), altars(),</a>
<a name="ln4519">      runed_doors()</a>
<a name="ln4520">{</a>
<a name="ln4521">}</a>
<a name="ln4522"> </a>
<a name="ln4523">string explore_discoveries::cleaned_feature_description(</a>
<a name="ln4524">    const coord_def &amp;pos) const</a>
<a name="ln4525">{</a>
<a name="ln4526">    string s = lowercase_first(feature_description_at(pos));</a>
<a name="ln4527">    // TODO: can feature_description_at()'s return value still end in '.'?</a>
<a name="ln4528">    if (s.length() &amp;&amp; s[s.length() - 1] == '.')</a>
<a name="ln4529">        s.erase(s.length() - 1);</a>
<a name="ln4530">    if (starts_with(s, &quot;a &quot;))</a>
<a name="ln4531">        s = s.substr(2);</a>
<a name="ln4532">    else if (starts_with(s, &quot;an &quot;))</a>
<a name="ln4533">        s = s.substr(3);</a>
<a name="ln4534">    return s;</a>
<a name="ln4535">}</a>
<a name="ln4536"> </a>
<a name="ln4537">bool explore_discoveries::merge_feature(</a>
<a name="ln4538">    vector&lt; explore_discoveries::named_thing&lt;int&gt; &gt; &amp;v,</a>
<a name="ln4539">    const explore_discoveries::named_thing&lt;int&gt; &amp;feat) const</a>
<a name="ln4540">{</a>
<a name="ln4541">    for (explore_discoveries::named_thing&lt;int&gt; &amp;nt: v)</a>
<a name="ln4542">        if (feat == nt)</a>
<a name="ln4543">        {</a>
<a name="ln4544">            ++nt.thing;</a>
<a name="ln4545">            return true;</a>
<a name="ln4546">        }</a>
<a name="ln4547"> </a>
<a name="ln4548">    return false;</a>
<a name="ln4549">}</a>
<a name="ln4550"> </a>
<a name="ln4551">static bool _feat_is_branchlike(dungeon_feature_type feat)</a>
<a name="ln4552">{</a>
<a name="ln4553">    return feat_is_branch_entrance(feat)</a>
<a name="ln4554">        || feat == DNGN_ENTER_HELL</a>
<a name="ln4555">        || feat == DNGN_ENTER_ABYSS</a>
<a name="ln4556">        || feat == DNGN_EXIT_THROUGH_ABYSS</a>
<a name="ln4557">        || feat == DNGN_ENTER_PANDEMONIUM;</a>
<a name="ln4558">}</a>
<a name="ln4559"> </a>
<a name="ln4560">void explore_discoveries::found_feature(const coord_def &amp;pos,</a>
<a name="ln4561">                                        dungeon_feature_type feat)</a>
<a name="ln4562">{</a>
<a name="ln4563">    if (feat == DNGN_ENTER_SHOP &amp;&amp; ES_shop)</a>
<a name="ln4564">    {</a>
<a name="ln4565">        shops.emplace_back(shop_name(*shop_at(pos)), feat);</a>
<a name="ln4566">        es_flags |= ES_SHOP;</a>
<a name="ln4567">    }</a>
<a name="ln4568">    else if (feat_is_stair(feat) &amp;&amp; ES_stair)</a>
<a name="ln4569">    {</a>
<a name="ln4570">        const named_thing&lt;int&gt; stair(cleaned_feature_description(pos), 1);</a>
<a name="ln4571">        add_stair(stair);</a>
<a name="ln4572">        es_flags |= ES_STAIR;</a>
<a name="ln4573">    }</a>
<a name="ln4574">    else if (_feat_is_branchlike(feat) &amp;&amp; ES_branch)</a>
<a name="ln4575">    {</a>
<a name="ln4576">        const named_thing&lt;int&gt; stair(cleaned_feature_description(pos), 1);</a>
<a name="ln4577">        add_stair(stair);</a>
<a name="ln4578">        es_flags |= ES_BRANCH;</a>
<a name="ln4579">    }</a>
<a name="ln4580">    else if (feat_is_portal(feat) &amp;&amp; ES_portal)</a>
<a name="ln4581">    {</a>
<a name="ln4582">        const named_thing&lt;int&gt; portal(cleaned_feature_description(pos), 1);</a>
<a name="ln4583">        add_stair(portal);</a>
<a name="ln4584">        es_flags |= ES_PORTAL;</a>
<a name="ln4585">    }</a>
<a name="ln4586">    else if (feat_is_runed(feat))</a>
<a name="ln4587">    {</a>
<a name="ln4588">        seen_tracked_feature(feat);</a>
<a name="ln4589">        if (ES_rdoor)</a>
<a name="ln4590">        {</a>
<a name="ln4591">            for (orth_adjacent_iterator ai(pos); ai; ++ai)</a>
<a name="ln4592">            {</a>
<a name="ln4593">                // If any neighbours have been seen (and thus announced)</a>
<a name="ln4594">                // before, skip. For parts seen for the first time this turn,</a>
<a name="ln4595">                // announce only the upper leftmost cell.</a>
<a name="ln4596">                if (feat_is_runed(env.map_knowledge(*ai).feat())</a>
<a name="ln4597">                    &amp;&amp; (env.map_seen(*ai) || *ai &lt; pos))</a>
<a name="ln4598">                {</a>
<a name="ln4599">                    return;</a>
<a name="ln4600">                }</a>
<a name="ln4601">            }</a>
<a name="ln4602"> </a>
<a name="ln4603">            string desc = env.markers.property_at(pos, MAT_ANY, &quot;stop_explore&quot;);</a>
<a name="ln4604">            if (desc.empty())</a>
<a name="ln4605">                desc = cleaned_feature_description(pos);</a>
<a name="ln4606">            runed_doors.emplace_back(desc, 1);</a>
<a name="ln4607">            es_flags |= ES_RUNED_DOOR;</a>
<a name="ln4608">        }</a>
<a name="ln4609">    }</a>
<a name="ln4610">    else if (feat == DNGN_TRANSPORTER)</a>
<a name="ln4611">    {</a>
<a name="ln4612">        seen_tracked_feature(feat);</a>
<a name="ln4613">        if (ES_transporter)</a>
<a name="ln4614">        {</a>
<a name="ln4615">            for (orth_adjacent_iterator ai(pos); ai; ++ai)</a>
<a name="ln4616">            {</a>
<a name="ln4617">                // If any neighbours have been seen (and thus announced) before,</a>
<a name="ln4618">                // skip. For parts seen for the first time this turn, announce</a>
<a name="ln4619">                // only the upper leftmost cell.</a>
<a name="ln4620">                if (env.map_knowledge(*ai).feat() == DNGN_TRANSPORTER</a>
<a name="ln4621">                    &amp;&amp; (env.map_seen(*ai) || *ai &lt; pos))</a>
<a name="ln4622">                {</a>
<a name="ln4623">                    return;</a>
<a name="ln4624">                }</a>
<a name="ln4625">            }</a>
<a name="ln4626"> </a>
<a name="ln4627">            string desc = env.markers.property_at(pos, MAT_ANY, &quot;stop_explore&quot;);</a>
<a name="ln4628">            if (desc.empty())</a>
<a name="ln4629">                desc = cleaned_feature_description(pos);</a>
<a name="ln4630">            transporters.emplace_back(desc, 1);</a>
<a name="ln4631">            es_flags |= ES_TRANSPORTER;</a>
<a name="ln4632">        }</a>
<a name="ln4633">    }</a>
<a name="ln4634">    else if (feat_is_altar(feat) &amp;&amp; ES_altar)</a>
<a name="ln4635">    {</a>
<a name="ln4636">        const named_thing&lt;int&gt; altar(cleaned_feature_description(pos), 1);</a>
<a name="ln4637">        if (!merge_feature(altars, altar))</a>
<a name="ln4638">            altars.push_back(altar);</a>
<a name="ln4639">        es_flags |= ES_ALTAR;</a>
<a name="ln4640">    }</a>
<a name="ln4641">    // Would checking for a marker for all discovered cells slow things</a>
<a name="ln4642">    // down too much?</a>
<a name="ln4643">    else if (feat_is_statuelike(feat))</a>
<a name="ln4644">    {</a>
<a name="ln4645">        const string feat_stop_msg =</a>
<a name="ln4646">            env.markers.property_at(pos, MAT_ANY, &quot;stop_explore_msg&quot;);</a>
<a name="ln4647">        if (!feat_stop_msg.empty())</a>
<a name="ln4648">        {</a>
<a name="ln4649">            marker_msgs.push_back(feat_stop_msg);</a>
<a name="ln4650">            return;</a>
<a name="ln4651">        }</a>
<a name="ln4652"> </a>
<a name="ln4653">        const string feat_stop = env.markers.property_at(pos, MAT_ANY,</a>
<a name="ln4654">                                                         &quot;stop_explore&quot;);</a>
<a name="ln4655">        if (!feat_stop.empty())</a>
<a name="ln4656">        {</a>
<a name="ln4657">            string desc = lowercase_first(feature_description_at(pos));</a>
<a name="ln4658">            marked_feats.push_back(desc + &quot;.&quot;);</a>
<a name="ln4659">            return;</a>
<a name="ln4660">        }</a>
<a name="ln4661">    }</a>
<a name="ln4662">}</a>
<a name="ln4663"> </a>
<a name="ln4664">void explore_discoveries::add_stair(</a>
<a name="ln4665">    const explore_discoveries::named_thing&lt;int&gt; &amp;stair)</a>
<a name="ln4666">{</a>
<a name="ln4667">    if (merge_feature(stairs, stair) || merge_feature(portals, stair))</a>
<a name="ln4668">        return;</a>
<a name="ln4669"> </a>
<a name="ln4670">    // Hackadelic</a>
<a name="ln4671">    if (stair.name.find(&quot;stair&quot;) != string::npos)</a>
<a name="ln4672">        stairs.push_back(stair);</a>
<a name="ln4673">    else</a>
<a name="ln4674">        portals.push_back(stair);</a>
<a name="ln4675">}</a>
<a name="ln4676"> </a>
<a name="ln4677">void explore_discoveries::add_item(const item_def &amp;i)</a>
<a name="ln4678">{</a>
<a name="ln4679">    item_def copy = i;</a>
<a name="ln4680">    copy.quantity = 1;</a>
<a name="ln4681">    const string cname = copy.name(DESC_PLAIN);</a>
<a name="ln4682"> </a>
<a name="ln4683">    // Try to find something to stack it with, stacking by name.</a>
<a name="ln4684">    for (named_thing&lt;item_def&gt; &amp;item : items)</a>
<a name="ln4685">    {</a>
<a name="ln4686">        const int orig_quantity = item.thing.quantity;</a>
<a name="ln4687">        item.thing.quantity = 1;</a>
<a name="ln4688">        if (cname == item.thing.name(DESC_PLAIN))</a>
<a name="ln4689">        {</a>
<a name="ln4690">            item.thing.quantity = orig_quantity + i.quantity;</a>
<a name="ln4691">            item.name = item.thing.name(DESC_A, false, false, true,</a>
<a name="ln4692">                                        !is_stackable_item(i));</a>
<a name="ln4693">            return;</a>
<a name="ln4694">        }</a>
<a name="ln4695">        item.thing.quantity = orig_quantity;</a>
<a name="ln4696">    }</a>
<a name="ln4697"> </a>
<a name="ln4698">    string itemname = menu_colour_item_name(i, DESC_A);</a>
<a name="ln4699">    monster* mon = monster_at(i.pos);</a>
<a name="ln4700">    if (mon &amp;&amp; mons_species(mon-&gt;type) == MONS_BUSH)</a>
<a name="ln4701">        itemname += &quot; (under bush)&quot;;</a>
<a name="ln4702">    else if (mon &amp;&amp; mon-&gt;type == MONS_PLANT)</a>
<a name="ln4703">        itemname += &quot; (under plant)&quot;;</a>
<a name="ln4704"> </a>
<a name="ln4705">    items.emplace_back(itemname, i);</a>
<a name="ln4706"> </a>
<a name="ln4707">    // First item of this type?</a>
<a name="ln4708">    // XXX: Only works when travelling.</a>
<a name="ln4709">    hints_first_item(i);</a>
<a name="ln4710">}</a>
<a name="ln4711"> </a>
<a name="ln4712">void explore_discoveries::found_item(const coord_def &amp;pos, const item_def &amp;i)</a>
<a name="ln4713">{</a>
<a name="ln4714">    if (you.running == RMODE_EXPLORE_GREEDY)</a>
<a name="ln4715">    {</a>
<a name="ln4716">        // The things we need to do...</a>
<a name="ln4717">        if (!current_level)</a>
<a name="ln4718">            current_level = StashTrack.find_current_level();</a>
<a name="ln4719"> </a>
<a name="ln4720">        if (current_level)</a>
<a name="ln4721">        {</a>
<a name="ln4722">            const bool greed_inducing = _is_greed_inducing_square(current_level,</a>
<a name="ln4723">                                                                  pos,</a>
<a name="ln4724">                                                                  can_autopickup);</a>
<a name="ln4725"> </a>
<a name="ln4726">            if (greed_inducing &amp;&amp; (Options.explore_stop &amp; ES_GREEDY_ITEM))</a>
<a name="ln4727">                ; // Stop for this condition</a>
<a name="ln4728">            else if (!greed_inducing</a>
<a name="ln4729">                     &amp;&amp; (Options.explore_stop &amp; ES_ITEM</a>
<a name="ln4730">                         || Options.explore_stop &amp; ES_GLOWING_ITEM</a>
<a name="ln4731">                            &amp;&amp; i.flags &amp; ISFLAG_COSMETIC_MASK</a>
<a name="ln4732">                         || Options.explore_stop &amp; ES_ARTEFACT</a>
<a name="ln4733">                            &amp;&amp; i.flags &amp; ISFLAG_ARTEFACT_MASK</a>
<a name="ln4734">                         || Options.explore_stop &amp; ES_RUNE</a>
<a name="ln4735">                            &amp;&amp; i.base_type == OBJ_RUNES))</a>
<a name="ln4736">            {</a>
<a name="ln4737">                ; // More conditions to stop for</a>
<a name="ln4738">            }</a>
<a name="ln4739">            else</a>
<a name="ln4740">                return; // No conditions met, don't stop for this item</a>
<a name="ln4741">        }</a>
<a name="ln4742">    } // if (you.running == RMODE_EXPLORE_GREEDY)</a>
<a name="ln4743"> </a>
<a name="ln4744">    add_item(i);</a>
<a name="ln4745">    es_flags |=</a>
<a name="ln4746">        (you.running == RMODE_EXPLORE_GREEDY) ? ES_GREEDY_PICKUP_MASK :</a>
<a name="ln4747">        (Options.explore_stop &amp; ES_ITEM) ? ES_ITEM : ES_NONE;</a>
<a name="ln4748">}</a>
<a name="ln4749"> </a>
<a name="ln4750">// Expensive O(n^2) duplicate search, but we can live with that.</a>
<a name="ln4751">template &lt;class citer&gt; bool explore_discoveries::has_duplicates(</a>
<a name="ln4752">    citer begin, citer end) const</a>
<a name="ln4753">{</a>
<a name="ln4754">    for (citer s = begin; s != end; ++s)</a>
<a name="ln4755">        for (citer z = s + 1; z != end; ++z)</a>
<a name="ln4756">        {</a>
<a name="ln4757">            if (*s == *z)</a>
<a name="ln4758">                return true;</a>
<a name="ln4759">        }</a>
<a name="ln4760"> </a>
<a name="ln4761">    return false;</a>
<a name="ln4762">}</a>
<a name="ln4763"> </a>
<a name="ln4764">template &lt;class C&gt; void explore_discoveries::say_any(</a>
<a name="ln4765">    const C &amp;coll, const char *category) const</a>
<a name="ln4766">{</a>
<a name="ln4767">    if (coll.empty())</a>
<a name="ln4768">        return;</a>
<a name="ln4769"> </a>
<a name="ln4770">    const int size = coll.size();</a>
<a name="ln4771"> </a>
<a name="ln4772">    string plural = pluralise(category);</a>
<a name="ln4773">    if (size != 1)</a>
<a name="ln4774">        category = plural.c_str();</a>
<a name="ln4775"> </a>
<a name="ln4776">    if (has_duplicates(coll.begin(), coll.end()))</a>
<a name="ln4777">    {</a>
<a name="ln4778">        mprf(&quot;Found %s %s.&quot;, number_in_words(size).c_str(), category);</a>
<a name="ln4779">        return;</a>
<a name="ln4780">    }</a>
<a name="ln4781"> </a>
<a name="ln4782">    const auto message = formatted_string::parse_string(&quot;Found &quot; +</a>
<a name="ln4783">                           comma_separated_line(coll.begin(), coll.end()) + &quot;.&quot;);</a>
<a name="ln4784"> </a>
<a name="ln4785">    if (message.width() &gt;= get_number_of_cols())</a>
<a name="ln4786">        mprf(&quot;Found %s %s.&quot;, number_in_words(size).c_str(), category);</a>
<a name="ln4787">    else</a>
<a name="ln4788">        mpr(message);</a>
<a name="ln4789">}</a>
<a name="ln4790"> </a>
<a name="ln4791">vector&lt;string&gt; explore_discoveries::apply_quantities(</a>
<a name="ln4792">    const vector&lt; named_thing&lt;int&gt; &gt; &amp;v) const</a>
<a name="ln4793">{</a>
<a name="ln4794">    static const char *feature_plural_qualifiers[] =</a>
<a name="ln4795">    {</a>
<a name="ln4796">        &quot; leading &quot;, &quot; back to &quot;, &quot; to &quot;, &quot; of &quot;, &quot; in &quot;, &quot; out of&quot;,</a>
<a name="ln4797">        &quot; from &quot;, &quot; back into &quot;, nullptr</a>
<a name="ln4798">    };</a>
<a name="ln4799"> </a>
<a name="ln4800">    vector&lt;string&gt; things;</a>
<a name="ln4801">    for (const named_thing&lt;int&gt; &amp;nt : v)</a>
<a name="ln4802">    {</a>
<a name="ln4803">        if (nt.thing == 1)</a>
<a name="ln4804">            things.push_back(article_a(nt.name));</a>
<a name="ln4805">        else</a>
<a name="ln4806">        {</a>
<a name="ln4807">            things.push_back(number_in_words(nt.thing)</a>
<a name="ln4808">                             + &quot; &quot;</a>
<a name="ln4809">                             + pluralise(nt.name, feature_plural_qualifiers));</a>
<a name="ln4810">        }</a>
<a name="ln4811">    }</a>
<a name="ln4812">    return things;</a>
<a name="ln4813">}</a>
<a name="ln4814"> </a>
<a name="ln4815">bool explore_discoveries::stop_explore() const</a>
<a name="ln4816">{</a>
<a name="ln4817">    const bool marker_stop = !marker_msgs.empty() || !marked_feats.empty();</a>
<a name="ln4818"> </a>
<a name="ln4819">    for (const string &amp;msg : marker_msgs)</a>
<a name="ln4820">        mpr(msg);</a>
<a name="ln4821"> </a>
<a name="ln4822">    for (const string &amp;marked : marked_feats)</a>
<a name="ln4823">        mprf(&quot;Found %s&quot;, marked.c_str());</a>
<a name="ln4824"> </a>
<a name="ln4825">    if (!es_flags)</a>
<a name="ln4826">        return marker_stop;</a>
<a name="ln4827"> </a>
<a name="ln4828">    say_any(items, &quot;item&quot;);</a>
<a name="ln4829">    say_any(shops, &quot;shop&quot;);</a>
<a name="ln4830">    say_any(apply_quantities(altars), &quot;altar&quot;);</a>
<a name="ln4831">    say_any(apply_quantities(portals), &quot;portal&quot;);</a>
<a name="ln4832">    say_any(apply_quantities(stairs), &quot;stair&quot;);</a>
<a name="ln4833">    say_any(apply_quantities(transporters), &quot;transporter&quot;);</a>
<a name="ln4834">    say_any(apply_quantities(runed_doors), &quot;runed door&quot;);</a>
<a name="ln4835"> </a>
<a name="ln4836">    return true;</a>
<a name="ln4837">}</a>
<a name="ln4838"> </a>
<a name="ln4839">void do_interlevel_travel()</a>
<a name="ln4840">{</a>
<a name="ln4841">    if (Hints.hints_travel)</a>
<a name="ln4842">        Hints.hints_travel = 0;</a>
<a name="ln4843"> </a>
<a name="ln4844">    if (!can_travel_interlevel())</a>
<a name="ln4845">    {</a>
<a name="ln4846">        if (you.running.pos == you.pos())</a>
<a name="ln4847">        {</a>
<a name="ln4848">            mpr(&quot;You're already here!&quot;);</a>
<a name="ln4849">            return;</a>
<a name="ln4850">        }</a>
<a name="ln4851">        else if (!you.running.pos.x || !you.running.pos.y)</a>
<a name="ln4852">        {</a>
<a name="ln4853">            mpr(&quot;Sorry, you can't auto-travel out of here.&quot;);</a>
<a name="ln4854">            return;</a>
<a name="ln4855">        }</a>
<a name="ln4856"> </a>
<a name="ln4857">        // Don't ask for a destination if you can only travel</a>
<a name="ln4858">        // within level anyway.</a>
<a name="ln4859">        start_travel(you.running.pos);</a>
<a name="ln4860">    }</a>
<a name="ln4861">    else</a>
<a name="ln4862">        _start_translevel_travel_prompt();</a>
<a name="ln4863"> </a>
<a name="ln4864">    if (you.running)</a>
<a name="ln4865">        clear_messages();</a>
<a name="ln4866">}</a>
<a name="ln4867"> </a>
<a name="ln4868">#ifdef USE_TILE</a>
<a name="ln4869">// (0,0) = same position is handled elsewhere.</a>
<a name="ln4870">const int dir_dx[8] = {-1, 0, 1, -1, 1, -1,  0,  1};</a>
<a name="ln4871">const int dir_dy[8] = { 1, 1, 1,  0, 0, -1, -1, -1};</a>
<a name="ln4872"> </a>
<a name="ln4873">const int cmd_array[8] =</a>
<a name="ln4874">{</a>
<a name="ln4875">    CMD_MOVE_DOWN_LEFT,  CMD_MOVE_DOWN,  CMD_MOVE_DOWN_RIGHT,</a>
<a name="ln4876">    CMD_MOVE_LEFT,                       CMD_MOVE_RIGHT,</a>
<a name="ln4877">    CMD_MOVE_UP_LEFT,    CMD_MOVE_UP,    CMD_MOVE_UP_RIGHT,</a>
<a name="ln4878">};</a>
<a name="ln4879"> </a>
<a name="ln4880">static int _adjacent_cmd(const coord_def &amp;gc, bool force)</a>
<a name="ln4881">{</a>
<a name="ln4882">    const coord_def dir = gc - you.pos();</a>
<a name="ln4883">    for (int i = 0; i &lt; 8; i++)</a>
<a name="ln4884">    {</a>
<a name="ln4885">        if (dir_dx[i] != dir.x || dir_dy[i] != dir.y)</a>
<a name="ln4886">            continue;</a>
<a name="ln4887"> </a>
<a name="ln4888">        int cmd = cmd_array[i];</a>
<a name="ln4889">        if (force)</a>
<a name="ln4890">        {</a>
<a name="ln4891">            if (feat_is_open_door(grd(gc))</a>
<a name="ln4892">                &amp;&amp; !env.map_knowledge(gc).monsterinfo())</a>
<a name="ln4893">            {</a>
<a name="ln4894">                cmd += CMD_CLOSE_DOOR_LEFT - CMD_MOVE_LEFT;</a>
<a name="ln4895">            }</a>
<a name="ln4896">            else</a>
<a name="ln4897">                cmd += CMD_ATTACK_LEFT - CMD_MOVE_LEFT;</a>
<a name="ln4898">        }</a>
<a name="ln4899"> </a>
<a name="ln4900">        return cmd;</a>
<a name="ln4901">    }</a>
<a name="ln4902"> </a>
<a name="ln4903">    return CK_MOUSE_CMD;</a>
<a name="ln4904">}</a>
<a name="ln4905"> </a>
<a name="ln4906">int click_travel(const coord_def &amp;gc, bool force)</a>
<a name="ln4907">{</a>
<a name="ln4908">    if (!in_bounds(gc))</a>
<a name="ln4909">        return CK_MOUSE_CMD;</a>
<a name="ln4910"> </a>
<a name="ln4911">    const int cmd = _adjacent_cmd(gc, force);</a>
<a name="ln4912">    if (cmd != CK_MOUSE_CMD)</a>
<a name="ln4913">        return cmd;</a>
<a name="ln4914"> </a>
<a name="ln4915">    if ((!is_excluded(gc) || is_stair_exclusion(gc))</a>
<a name="ln4916">        &amp;&amp; (!is_excluded(you.pos()) || is_stair_exclusion(you.pos()))</a>
<a name="ln4917">        &amp;&amp; i_feel_safe(false, false, false, false))</a>
<a name="ln4918">    {</a>
<a name="ln4919">        map_cell &amp;cell(env.map_knowledge(gc));</a>
<a name="ln4920">        // If there's a monster that would block travel,</a>
<a name="ln4921">        // don't start traveling.</a>
<a name="ln4922">        if (!_monster_blocks_travel(cell.monsterinfo()))</a>
<a name="ln4923">        {</a>
<a name="ln4924">            start_travel(gc);</a>
<a name="ln4925">            return CK_MOUSE_CMD;</a>
<a name="ln4926">        }</a>
<a name="ln4927">    }</a>
<a name="ln4928"> </a>
<a name="ln4929">    // If not safe, then take one step towards the click.</a>
<a name="ln4930">    travel_pathfind tp;</a>
<a name="ln4931">    tp.set_src_dst(you.pos(), gc);</a>
<a name="ln4932">    tp.set_ignore_danger();</a>
<a name="ln4933">    const coord_def dest = tp.pathfind(RMODE_TRAVEL);</a>
<a name="ln4934"> </a>
<a name="ln4935">    if (!dest.x &amp;&amp; !dest.y)</a>
<a name="ln4936">        return CK_MOUSE_CMD;</a>
<a name="ln4937"> </a>
<a name="ln4938">    return _adjacent_cmd(dest, force);</a>
<a name="ln4939">}</a>
<a name="ln4940">#endif</a>
<a name="ln4941"> </a>
<a name="ln4942">bool check_for_interesting_features()</a>
<a name="ln4943">{</a>
<a name="ln4944">    // Scan through the shadow map, compare it with the actual map, and if</a>
<a name="ln4945">    // there are any squares of the shadow map that have just been</a>
<a name="ln4946">    // discovered and contain an item, or have an interesting dungeon</a>
<a name="ln4947">    // feature, stop exploring.</a>
<a name="ln4948">    explore_discoveries discoveries;</a>
<a name="ln4949">    for (radius_iterator ri(you.pos(),</a>
<a name="ln4950">                            you.xray_vision ? LOS_NONE : LOS_DEFAULT); ri; ++ri)</a>
<a name="ln4951">    {</a>
<a name="ln4952">        const coord_def p(*ri);</a>
<a name="ln4953"> </a>
<a name="ln4954">        // Find just noticed squares.</a>
<a name="ln4955">        if (env.map_knowledge(p).flags &amp; MAP_SEEN_FLAG</a>
<a name="ln4956">            &amp;&amp; !env.map_seen(p))</a>
<a name="ln4957">        {</a>
<a name="ln4958">            // Update the shadow map</a>
<a name="ln4959">            env.map_seen.set(p);</a>
<a name="ln4960"> </a>
<a name="ln4961">            // But don't stop if we knew about it previously</a>
<a name="ln4962">            if (!env.map_forgotten</a>
<a name="ln4963">                || !((*env.map_forgotten)(p).flags &amp; MAP_SEEN_FLAG))</a>
<a name="ln4964">            {</a>
<a name="ln4965">                _check_interesting_square(p, discoveries);</a>
<a name="ln4966">            }</a>
<a name="ln4967">        }</a>
<a name="ln4968">    }</a>
<a name="ln4969"> </a>
<a name="ln4970">    return discoveries.stop_explore();</a>
<a name="ln4971">}</a>
<a name="ln4972"> </a>
<a name="ln4973">void clear_level_target()</a>
<a name="ln4974">{</a>
<a name="ln4975">    level_target.clear();</a>
<a name="ln4976">    trans_travel_dest.clear();</a>
<a name="ln4977">}</a>
<a name="ln4978"> </a>
<a name="ln4979">void clear_travel_trail()</a>
<a name="ln4980">{</a>
<a name="ln4981">#ifdef USE_TILE_WEB</a>
<a name="ln4982">    for (coord_def c : env.travel_trail)</a>
<a name="ln4983">        tiles.update_minimap(c);</a>
<a name="ln4984">#endif</a>
<a name="ln4985">    env.travel_trail.clear();</a>
<a name="ln4986">}</a>
<a name="ln4987"> </a>
<a name="ln4988">int travel_trail_index(const coord_def&amp; gc)</a>
<a name="ln4989">{</a>
<a name="ln4990">    unsigned int idx = find(env.travel_trail.begin(), env.travel_trail.end(), gc)</a>
<a name="ln4991">        - env.travel_trail.begin();</a>
<a name="ln4992">    if (idx &lt; env.travel_trail.size())</a>
<a name="ln4993">        return idx;</a>
<a name="ln4994">    else</a>
<a name="ln4995">        return -1;</a>
<a name="ln4996">}</a>
<a name="ln4997"> </a>
<a name="ln4998">bool stairs_destination_is_excluded(const stair_info &amp;si)</a>
<a name="ln4999">{</a>
<a name="ln5000">    level_pos dest = si.destination;</a>
<a name="ln5001">    if (LevelInfo *dest_li = travel_cache.find_level_info(dest.id))</a>
<a name="ln5002">    {</a>
<a name="ln5003">        if (is_unknown_stair(si.position)</a>
<a name="ln5004">            || !is_excluded(dest.pos, dest_li-&gt;get_excludes()))</a>
<a name="ln5005">        {</a>
<a name="ln5006">            return false;</a>
<a name="ln5007">        }</a>
<a name="ln5008"> </a>
<a name="ln5009">        // Check for exclusions that cover the stair destination, but ignore</a>
<a name="ln5010">        // those that have radius 1: those exclude travel in the _other_</a>
<a name="ln5011">        // direction only (from the destination to here, not from here to the</a>
<a name="ln5012">        // destination)</a>
<a name="ln5013">        const exclude_set &amp;excludes = dest_li-&gt;get_excludes();</a>
<a name="ln5014">        for (auto entry : excludes)</a>
<a name="ln5015">        {</a>
<a name="ln5016">            const travel_exclude &amp;ex = entry.second;</a>
<a name="ln5017">            if (ex.in_bounds(dest.pos) &amp;&amp; ex.radius &gt; 1)</a>
<a name="ln5018">                return true;</a>
<a name="ln5019">        }</a>
<a name="ln5020">    }</a>
<a name="ln5021"> </a>
<a name="ln5022">    return false;</a>
<a name="ln5023">}</a>

</code></pre>
<div class="balloon" rel="218"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v648/" target="_blank">V648</a> Priority of the '&&' operation is higher than that of the '||' operation.</p></div>
<div class="balloon" rel="298"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v648/" target="_blank">V648</a> Priority of the '&&' operation is higher than that of the '||' operation.</p></div>
<div class="balloon" rel="362"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v648/" target="_blank">V648</a> Priority of the '&&' operation is higher than that of the '||' operation.</p></div>
<div class="balloon" rel="1026"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v547/" target="_blank">V547</a> Expression 'result != CMD_NO_CMD' is always false.</p></div>
<div class="balloon" rel="1686"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v560/" target="_blank">V560</a> A part of conditional expression is always true: (dir = 1).</p></div>
<div class="balloon" rel="3108"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v648/" target="_blank">V648</a> Priority of the '&&' operation is higher than that of the '||' operation.</p></div>
<div class="balloon" rel="3284"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v648/" target="_blank">V648</a> Priority of the '&&' operation is higher than that of the '||' operation.</p></div>
<div class="balloon" rel="4730"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v648/" target="_blank">V648</a> Priority of the '&&' operation is higher than that of the '||' operation.</p></div>
<div class="balloon" rel="4274"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v730/" target="_blank">V730</a> Not all members of a class are initialized inside the constructor. Consider inspecting: notified_mp_full, notified_hp_full, notified_ancestor_hp_full, travel_speed, direction.</p></div>
<div class="balloon" rel="1074"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v730/" target="_blank">V730</a> Not all members of a class are initialized inside the constructor. Consider inspecting: try_fallback.</p></div>

<link rel="stylesheet" href="highlight.css">
<script src="highlight.pack.js"></script>
<script src="highlightjs-line-numbers.js"></script>
<script>hljs.initHighlightingOnLoad();</script>
<script>hljs.initLineNumbersOnLoad();</script>
<script>
  $(document).ready(function() {
      $('.balloon').each(function () {
          var bl = $(this);
          var line = bl.attr('rel');
          var text = $('a[name="ln'+line+'"]').text();

          var space_count = 0;
          for(var i = 0; i<text.length; i++){
              var char = text[i];
              if((char !== ' ')&&(char !== '\t'))break;
              if(char === '\t')space_count++;
              space_count++;
          }

          bl.css('margin-left', space_count*8);
          $('a[name="ln'+line+'"]').after(bl);
      });

      window.location = window.location;
  });
</script>
</body>
</html>
