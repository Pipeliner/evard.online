
<html>
<head>

  <meta http-equiv="Content-Type" content="text/html; charset=US-ASCII" />
  <title>spl-cast.cc</title>

  <link rel="stylesheet" href="../style.css"/>
  <script src="../jquery-3.2.1.min.js"></script>
</head>
<body>

<pre><code class = "cpp">
<a name="ln1">/**</a>
<a name="ln2"> * @file</a>
<a name="ln3"> * @brief Spell casting and miscast functions.</a>
<a name="ln4">**/</a>
<a name="ln5"> </a>
<a name="ln6">#include &quot;AppHdr.h&quot;</a>
<a name="ln7"> </a>
<a name="ln8">#include &quot;spl-cast.h&quot;</a>
<a name="ln9"> </a>
<a name="ln10">#include &lt;iomanip&gt;</a>
<a name="ln11">#include &lt;sstream&gt;</a>
<a name="ln12">#include &lt;cmath&gt;</a>
<a name="ln13"> </a>
<a name="ln14">#include &quot;areas.h&quot;</a>
<a name="ln15">#include &quot;art-enum.h&quot;</a>
<a name="ln16">#include &quot;beam.h&quot;</a>
<a name="ln17">#include &quot;chardump.h&quot;</a>
<a name="ln18">#include &quot;colour.h&quot;</a>
<a name="ln19">#include &quot;database.h&quot;</a>
<a name="ln20">#include &quot;describe.h&quot;</a>
<a name="ln21">#include &quot;directn.h&quot;</a>
<a name="ln22">#include &quot;english.h&quot;</a>
<a name="ln23">#include &quot;env.h&quot;</a>
<a name="ln24">#include &quot;evoke.h&quot;</a>
<a name="ln25">#include &quot;exercise.h&quot;</a>
<a name="ln26">#include &quot;food.h&quot;</a>
<a name="ln27">#include &quot;format.h&quot;</a>
<a name="ln28">#include &quot;god-abil.h&quot;</a>
<a name="ln29">#include &quot;god-conduct.h&quot;</a>
<a name="ln30">#include &quot;god-item.h&quot;</a>
<a name="ln31">#include &quot;god-passive.h&quot; // passive_t::shadow_spells</a>
<a name="ln32">#include &quot;hints.h&quot;</a>
<a name="ln33">#include &quot;item-prop.h&quot;</a>
<a name="ln34">#include &quot;item-use.h&quot;</a>
<a name="ln35">#include &quot;libutil.h&quot;</a>
<a name="ln36">#include &quot;macro.h&quot;</a>
<a name="ln37">#include &quot;menu.h&quot;</a>
<a name="ln38">#include &quot;message.h&quot;</a>
<a name="ln39">#include &quot;misc.h&quot;</a>
<a name="ln40">#include &quot;mon-behv.h&quot;</a>
<a name="ln41">#include &quot;mon-cast.h&quot;</a>
<a name="ln42">#include &quot;mon-place.h&quot;</a>
<a name="ln43">#include &quot;mon-project.h&quot;</a>
<a name="ln44">#include &quot;mon-util.h&quot;</a>
<a name="ln45">#include &quot;mutation.h&quot;</a>
<a name="ln46">#include &quot;options.h&quot;</a>
<a name="ln47">#include &quot;ouch.h&quot;</a>
<a name="ln48">#include &quot;output.h&quot;</a>
<a name="ln49">#include &quot;player.h&quot;</a>
<a name="ln50">#include &quot;prompt.h&quot;</a>
<a name="ln51">#include &quot;religion.h&quot;</a>
<a name="ln52">#include &quot;shout.h&quot;</a>
<a name="ln53">#include &quot;skills.h&quot;</a>
<a name="ln54">#include &quot;spl-book.h&quot;</a>
<a name="ln55">#include &quot;spl-clouds.h&quot;</a>
<a name="ln56">#include &quot;spl-damage.h&quot;</a>
<a name="ln57">#include &quot;spl-goditem.h&quot;</a>
<a name="ln58">#include &quot;spl-miscast.h&quot;</a>
<a name="ln59">#include &quot;spl-monench.h&quot;</a>
<a name="ln60">#include &quot;spl-other.h&quot;</a>
<a name="ln61">#include &quot;spl-selfench.h&quot;</a>
<a name="ln62">#include &quot;spl-summoning.h&quot;</a>
<a name="ln63">#include &quot;spl-transloc.h&quot;</a>
<a name="ln64">#include &quot;spl-wpnench.h&quot;</a>
<a name="ln65">#include &quot;spl-zap.h&quot;</a>
<a name="ln66">#include &quot;state.h&quot;</a>
<a name="ln67">#include &quot;stepdown.h&quot;</a>
<a name="ln68">#include &quot;stringutil.h&quot;</a>
<a name="ln69">#include &quot;target.h&quot;</a>
<a name="ln70">#include &quot;terrain.h&quot;</a>
<a name="ln71">#ifdef USE_TILE</a>
<a name="ln72"> #include &quot;tilepick.h&quot;</a>
<a name="ln73">#endif</a>
<a name="ln74">#include &quot;transform.h&quot;</a>
<a name="ln75">#include &quot;unicode.h&quot;</a>
<a name="ln76">#include &quot;unwind.h&quot;</a>
<a name="ln77">#include &quot;view.h&quot;</a>
<a name="ln78">#include &quot;viewchar.h&quot; // stringize_glyph</a>
<a name="ln79"> </a>
<a name="ln80">static int _spell_enhancement(spell_type spell);</a>
<a name="ln81">static string _spell_failure_rate_description(spell_type spell);</a>
<a name="ln82"> </a>
<a name="ln83">#if TAG_MAJOR_VERSION == 34</a>
<a name="ln84">void surge_power(const int enhanced)</a>
<a name="ln85">{</a>
<a name="ln86">    if (enhanced)               // one way or the other {dlb}</a>
<a name="ln87">    {</a>
<a name="ln88">        const string modifier = (enhanced  &lt; -2) ? &quot;extraordinarily&quot; :</a>
<a name="ln89">                                (enhanced == -2) ? &quot;extremely&quot; :</a>
<a name="ln90">                                (enhanced ==  2) ? &quot;strong&quot; :</a>
<a name="ln91">                                (enhanced  &gt;  2) ? &quot;huge&quot;</a>
<a name="ln92">                                                 : &quot;&quot;;</a>
<a name="ln93">        mprf(&quot;You feel %s %s&quot;,</a>
<a name="ln94">             !modifier.length() ? &quot;a&quot;</a>
<a name="ln95">                                : article_a(modifier).c_str(),</a>
<a name="ln96">             (enhanced &lt; 0) ? &quot;numb sensation.&quot;</a>
<a name="ln97">                            : &quot;surge of power!&quot;);</a>
<a name="ln98">    }</a>
<a name="ln99">}</a>
<a name="ln100"> </a>
<a name="ln101">void surge_power_wand(const int mp_cost)</a>
<a name="ln102">{</a>
<a name="ln103">    if (mp_cost)</a>
<a name="ln104">    {</a>
<a name="ln105">        const bool slight = mp_cost &lt; 3;</a>
<a name="ln106">        mprf(&quot;You feel a %ssurge of power%s&quot;,</a>
<a name="ln107">             slight ? &quot;slight &quot; : &quot;&quot;,</a>
<a name="ln108">             slight ? &quot;.&quot;      : &quot;!&quot;);</a>
<a name="ln109">    }</a>
<a name="ln110">}</a>
<a name="ln111">#endif</a>
<a name="ln112"> </a>
<a name="ln113">static string _spell_base_description(spell_type spell, bool viewing)</a>
<a name="ln114">{</a>
<a name="ln115">    ostringstream desc;</a>
<a name="ln116"> </a>
<a name="ln117">    int highlight =  spell_highlight_by_utility(spell, COL_UNKNOWN, !viewing);</a>
<a name="ln118"> </a>
<a name="ln119">    desc &lt;&lt; &quot;&lt;&quot; &lt;&lt; colour_to_str(highlight) &lt;&lt; &quot;&gt;&quot; &lt;&lt; left;</a>
<a name="ln120"> </a>
<a name="ln121">    // spell name</a>
<a name="ln122">    desc &lt;&lt; chop_string(spell_title(spell), 30);</a>
<a name="ln123"> </a>
<a name="ln124">    // spell schools</a>
<a name="ln125">    desc &lt;&lt; spell_schools_string(spell);</a>
<a name="ln126"> </a>
<a name="ln127">    const int so_far = strwidth(desc.str()) - (strwidth(colour_to_str(highlight))+2);</a>
<a name="ln128">    if (so_far &lt; 60)</a>
<a name="ln129">        desc &lt;&lt; string(60 - so_far, ' ');</a>
<a name="ln130">    desc &lt;&lt; &quot;&lt;/&quot; &lt;&lt; colour_to_str(highlight) &lt;&lt;&quot;&gt;&quot;;</a>
<a name="ln131"> </a>
<a name="ln132">    // spell fail rate, level</a>
<a name="ln133">    const string failure_rate = spell_failure_rate_string(spell);</a>
<a name="ln134">    const int width = strwidth(formatted_string::parse_string(failure_rate).tostring());</a>
<a name="ln135">    desc &lt;&lt; failure_rate &lt;&lt; string(12-width, ' ');</a>
<a name="ln136">    desc &lt;&lt; spell_difficulty(spell);</a>
<a name="ln137">    desc &lt;&lt; &quot; &quot;;</a>
<a name="ln138"> </a>
<a name="ln139">    return desc.str();</a>
<a name="ln140">}</a>
<a name="ln141"> </a>
<a name="ln142">static string _spell_extra_description(spell_type spell, bool viewing)</a>
<a name="ln143">{</a>
<a name="ln144">    ostringstream desc;</a>
<a name="ln145"> </a>
<a name="ln146">    int highlight =  spell_highlight_by_utility(spell, COL_UNKNOWN, !viewing);</a>
<a name="ln147"> </a>
<a name="ln148">    desc &lt;&lt; &quot;&lt;&quot; &lt;&lt; colour_to_str(highlight) &lt;&lt; &quot;&gt;&quot; &lt;&lt; left;</a>
<a name="ln149"> </a>
<a name="ln150">    // spell name</a>
<a name="ln151">    desc &lt;&lt; chop_string(spell_title(spell), 30);</a>
<a name="ln152"> </a>
<a name="ln153">    // spell power, spell range, hunger level, noise</a>
<a name="ln154">    const string rangestring = spell_range_string(spell);</a>
<a name="ln155"> </a>
<a name="ln156">    desc &lt;&lt; chop_string(spell_power_string(spell), 13)</a>
<a name="ln157">         &lt;&lt; chop_string(rangestring, 9)</a>
<a name="ln158">         &lt;&lt; chop_string(spell_hunger_string(spell), 8)</a>
<a name="ln159">         &lt;&lt; chop_string(spell_noise_string(spell, 10), 14);</a>
<a name="ln160"> </a>
<a name="ln161">    desc &lt;&lt; &quot;&lt;/&quot; &lt;&lt; colour_to_str(highlight) &lt;&lt;&quot;&gt;&quot;;</a>
<a name="ln162"> </a>
<a name="ln163">    return desc.str();</a>
<a name="ln164">}</a>
<a name="ln165"> </a>
<a name="ln166">// selector is a boolean function that filters spells according</a>
<a name="ln167">// to certain criteria. Currently used for Tiles to distinguish</a>
<a name="ln168">// spells targeted on player vs. spells targeted on monsters.</a>
<a name="ln169">int list_spells(bool toggle_with_I, bool viewing, bool allow_preselect,</a>
<a name="ln170">                const string &amp;title, spell_selector selector)</a>
<a name="ln171">{</a>
<a name="ln172">    if (toggle_with_I &amp;&amp; get_spell_by_letter('I') != SPELL_NO_SPELL)</a>
<a name="ln173">        toggle_with_I = false;</a>
<a name="ln174"> </a>
<a name="ln175">    ToggleableMenu spell_menu(MF_SINGLESELECT | MF_ANYPRINTABLE</a>
<a name="ln176">            | MF_NO_WRAP_ROWS | MF_ALWAYS_SHOW_MORE | MF_ALLOW_FORMATTING);</a>
<a name="ln177">    string titlestring = make_stringf(&quot;%-25.25s&quot;, title.c_str());</a>
<a name="ln178">    {</a>
<a name="ln179">        ToggleableMenuEntry* me =</a>
<a name="ln180">            new ToggleableMenuEntry(</a>
<a name="ln181">                titlestring + &quot;         Type                          Failure  Level&quot;,</a>
<a name="ln182">                titlestring + &quot;         Power        Range    Hunger  Noise         &quot;,</a>
<a name="ln183">                MEL_TITLE);</a>
<a name="ln184">        spell_menu.set_title(me, true, true);</a>
<a name="ln185">    }</a>
<a name="ln186">    spell_menu.set_highlighter(nullptr);</a>
<a name="ln187">    spell_menu.set_tag(&quot;spell&quot;);</a>
<a name="ln188">    spell_menu.add_toggle_key('!');</a>
<a name="ln189"> </a>
<a name="ln190">    string more_str = &quot;Press '&lt;w&gt;!&lt;/w&gt;' &quot;;</a>
<a name="ln191">    if (toggle_with_I)</a>
<a name="ln192">    {</a>
<a name="ln193">        spell_menu.add_toggle_key('I');</a>
<a name="ln194">        more_str += &quot;or '&lt;w&gt;I&lt;/w&gt;' &quot;;</a>
<a name="ln195">    }</a>
<a name="ln196">    if (!viewing)</a>
<a name="ln197">        spell_menu.menu_action = Menu::ACT_EXECUTE;</a>
<a name="ln198">    more_str += &quot;to toggle spell view.&quot;;</a>
<a name="ln199">    spell_menu.set_more(formatted_string::parse_string(more_str));</a>
<a name="ln200"> </a>
<a name="ln201">    // If there's only a single spell in the offered spell list,</a>
<a name="ln202">    // taking the selector function into account, preselect that one.</a>
<a name="ln203">    bool preselect_first = false;</a>
<a name="ln204">    if (allow_preselect)</a>
<a name="ln205">    {</a>
<a name="ln206">        int count = 0;</a>
<a name="ln207">        if (you.spell_no == 1)</a>
<a name="ln208">            count = 1;</a>
<a name="ln209">        else if (selector)</a>
<a name="ln210">        {</a>
<a name="ln211">            for (int i = 0; i &lt; 52; ++i)</a>
<a name="ln212">            {</a>
<a name="ln213">                const char letter = index_to_letter(i);</a>
<a name="ln214">                const spell_type spell = get_spell_by_letter(letter);</a>
<a name="ln215">                if (!is_valid_spell(spell) || !(*selector)(spell))</a>
<a name="ln216">                    continue;</a>
<a name="ln217"> </a>
<a name="ln218">                // Break out early if we've got &gt; 1 spells.</a>
<a name="ln219">                if (++count &gt; 1)</a>
<a name="ln220">                    break;</a>
<a name="ln221">            }</a>
<a name="ln222">        }</a>
<a name="ln223">        // Preselect the first spell if it's only spell applicable.</a>
<a name="ln224">        preselect_first = (count == 1);</a>
<a name="ln225">    }</a>
<a name="ln226">    if (allow_preselect || preselect_first</a>
<a name="ln227">                           &amp;&amp; you.last_cast_spell != SPELL_NO_SPELL)</a>
<a name="ln228">    {</a>
<a name="ln229">        spell_menu.set_flags(spell_menu.get_flags() | MF_PRESELECTED);</a>
<a name="ln230">    }</a>
<a name="ln231"> </a>
<a name="ln232">    for (int i = 0; i &lt; 52; ++i)</a>
<a name="ln233">    {</a>
<a name="ln234">        const char letter = index_to_letter(i);</a>
<a name="ln235">        const spell_type spell = get_spell_by_letter(letter);</a>
<a name="ln236"> </a>
<a name="ln237">        if (!is_valid_spell(spell))</a>
<a name="ln238">            continue;</a>
<a name="ln239"> </a>
<a name="ln240">        if (selector &amp;&amp; !(*selector)(spell))</a>
<a name="ln241">            continue;</a>
<a name="ln242"> </a>
<a name="ln243">        bool preselect = (preselect_first</a>
<a name="ln244">                          || allow_preselect &amp;&amp; you.last_cast_spell == spell);</a>
<a name="ln245"> </a>
<a name="ln246">        ToggleableMenuEntry* me =</a>
<a name="ln247">            new ToggleableMenuEntry(_spell_base_description(spell, viewing),</a>
<a name="ln248">                                    _spell_extra_description(spell, viewing),</a>
<a name="ln249">                                    MEL_ITEM, 1, letter, preselect);</a>
<a name="ln250"> </a>
<a name="ln251">#ifdef USE_TILE</a>
<a name="ln252">        me-&gt;add_tile(tile_def(tileidx_spell(spell), TEX_GUI));</a>
<a name="ln253">#endif</a>
<a name="ln254">        spell_menu.add_entry(me);</a>
<a name="ln255">    }</a>
<a name="ln256"> </a>
<a name="ln257">    int choice = 0;</a>
<a name="ln258">    spell_menu.on_single_selection = [&amp;choice, &amp;spell_menu](const MenuEntry&amp; item)</a>
<a name="ln259">    {</a>
<a name="ln260">        ASSERT(item.hotkeys.size() == 1);</a>
<a name="ln261">        if (spell_menu.menu_action == Menu::ACT_EXAMINE)</a>
<a name="ln262">        {</a>
<a name="ln263">            describe_spell(get_spell_by_letter(item.hotkeys[0]), nullptr);</a>
<a name="ln264">            return true;</a>
<a name="ln265">        }</a>
<a name="ln266">        else</a>
<a name="ln267">        {</a>
<a name="ln268">            choice = item.hotkeys[0];</a>
<a name="ln269">            return false;</a>
<a name="ln270">        }</a>
<a name="ln271">    };</a>
<a name="ln272"> </a>
<a name="ln273">    spell_menu.show();</a>
<a name="ln274">    if (!crawl_state.doing_prev_cmd_again)</a>
<a name="ln275">        redraw_screen();</a>
<a name="ln276">    return choice;</a>
<a name="ln277">}</a>
<a name="ln278"> </a>
<a name="ln279">static int _apply_spellcasting_success_boosts(spell_type spell, int chance)</a>
<a name="ln280">{</a>
<a name="ln281">    int fail_reduce = 100;</a>
<a name="ln282"> </a>
<a name="ln283">    if (have_passive(passive_t::spells_success) &amp;&amp; vehumet_supports_spell(spell))</a>
<a name="ln284">    {</a>
<a name="ln285">        // [dshaligram] Fail rate multiplier used to be .5, scaled</a>
<a name="ln286">        // back to 67%.</a>
<a name="ln287">        fail_reduce = fail_reduce * 2 / 3;</a>
<a name="ln288">    }</a>
<a name="ln289"> </a>
<a name="ln290">    const int wizardry = player_wizardry(spell);</a>
<a name="ln291"> </a>
<a name="ln292">    if (wizardry &gt; 0)</a>
<a name="ln293">      fail_reduce = fail_reduce * 6 / (7 + wizardry);</a>
<a name="ln294"> </a>
<a name="ln295">    // Hard cap on fail rate reduction.</a>
<a name="ln296">    if (fail_reduce &lt; 50)</a>
<a name="ln297">        fail_reduce = 50;</a>
<a name="ln298"> </a>
<a name="ln299">    return chance * fail_reduce / 100;</a>
<a name="ln300">}</a>
<a name="ln301"> </a>
<a name="ln302">/**</a>
<a name="ln303"> * Calculate the player's failure rate with the given spell, including all</a>
<a name="ln304"> * modifiers. (Armour, mutations, statuses effects, etc.)</a>
<a name="ln305"> *</a>
<a name="ln306"> * @param spell     The spell in question.</a>
<a name="ln307"> * @return          A failure rate. This is *not* a percentage - for a human-</a>
<a name="ln308"> *                  readable version, call _get_true_fail_rate().</a>
<a name="ln309"> */</a>
<a name="ln310">int raw_spell_fail(spell_type spell)</a>
<a name="ln311">{</a>
<a name="ln312">    int chance = 60;</a>
<a name="ln313"> </a>
<a name="ln314">    // Don't cap power for failure rate purposes.</a>
<a name="ln315">    // scale by 6, which I guess was chosen because it seems to work.</a>
<a name="ln316">    // realistic range for spellpower: -6 to -366 (before scale -1 to -61)</a>
<a name="ln317">    chance -= calc_spell_power(spell, false, true, false, 6);</a>
<a name="ln318">    chance -= (you.intel() * 2); // realistic range: -2 to -70</a>
<a name="ln319"> </a>
<a name="ln320">    const int armour_shield_penalty = player_armour_shield_spell_penalty();</a>
<a name="ln321">    dprf(&quot;Armour+Shield spell failure penalty: %d&quot;, armour_shield_penalty);</a>
<a name="ln322">    chance += armour_shield_penalty; // range: 0 to 500 in extreme cases.</a>
<a name="ln323">                                     // A midlevel melee character in plate</a>
<a name="ln324">                                     // might have 40 or 50, and a caster in a</a>
<a name="ln325">                                     // robe would usually have 0.</a>
<a name="ln326"> </a>
<a name="ln327">    static const int difficulty_by_level[] =</a>
<a name="ln328">    {</a>
<a name="ln329">        0,</a>
<a name="ln330">        3,</a>
<a name="ln331">        15,</a>
<a name="ln332">        35,</a>
<a name="ln333"> </a>
<a name="ln334">        70,</a>
<a name="ln335">        100,</a>
<a name="ln336">        150,</a>
<a name="ln337"> </a>
<a name="ln338">        200,</a>
<a name="ln339">        260,</a>
<a name="ln340">        340,</a>
<a name="ln341">    };</a>
<a name="ln342">    const int spell_level = spell_difficulty(spell);</a>
<a name="ln343">    ASSERT_RANGE(spell_level, 0, (int) ARRAYSZ(difficulty_by_level));</a>
<a name="ln344">    chance += difficulty_by_level[spell_level]; // between 0 and 330</a>
<a name="ln345"> </a>
<a name="ln346">    // This polynomial is a smoother approximation of a breakpoint-based</a>
<a name="ln347">    // calculation that originates pre-DCSS, mapping `chance` at this point to</a>
<a name="ln348">    // values from around 0 to around 45. (see</a>
<a name="ln349">    // https://crawl.develz.org/tavern/viewtopic.php?f=8&amp;t=23414 for some of</a>
<a name="ln350">    // the history.)  It was calculated by |amethyst (based on one from minmay</a>
<a name="ln351">    // in that thread) and converted to integer values using 262144 as a</a>
<a name="ln352">    // convenient power of 2 denominator, then converted to its current form</a>
<a name="ln353">    // by Horner's rule, and then tweaked slightly.</a>
<a name="ln354">    //</a>
<a name="ln355">    // The regular (integer) polynomial form before Horner's rule is:</a>
<a name="ln356">    //          (x*x*x + 426*x*x + 82670*x + 7245398) / 262144</a>
<a name="ln357">    //</a>
<a name="ln358">    // https://www.wolframalpha.com/input/?i=graph+of+y%3D(((x+%2B+426)*x+%2B+82670)*x+%2B+7245398)+%2F+262144+and+y%3D100+and+x%3D125.1+with+x+from+-192+to+126.1</a>
<a name="ln359">    //</a>
<a name="ln360">    // If you think this is weird, you should see what was here before.</a>
<a name="ln361">    int chance2 = max((((chance + 426) * chance + 82670) * chance + 7245398)</a>
<a name="ln362">                      / 262144, 0);</a>
<a name="ln363"> </a>
<a name="ln364">    chance2 += get_form()-&gt;spellcasting_penalty;</a>
<a name="ln365"> </a>
<a name="ln366">    chance2 -= 2 * you.get_mutation_level(MUT_SUBDUED_MAGIC);</a>
<a name="ln367">    chance2 += 4 * you.get_mutation_level(MUT_WILD_MAGIC);</a>
<a name="ln368">    chance2 += 4 * you.get_mutation_level(MUT_ANTI_WIZARDRY);</a>
<a name="ln369"> </a>
<a name="ln370">    if (you.props.exists(SAP_MAGIC_KEY))</a>
<a name="ln371">        chance2 += you.props[SAP_MAGIC_KEY].get_int() * 12;</a>
<a name="ln372"> </a>
<a name="ln373">    chance2 += you.duration[DUR_VERTIGO] ? 7 : 0;</a>
<a name="ln374"> </a>
<a name="ln375">    // Apply the effects of Vehumet and items of wizardry.</a>
<a name="ln376">    chance2 = _apply_spellcasting_success_boosts(spell, chance2);</a>
<a name="ln377"> </a>
<a name="ln378">    return min(max(chance2, 0), 100);</a>
<a name="ln379">}</a>
<a name="ln380"> </a>
<a name="ln381">/*</a>
<a name="ln382"> * Given some spellpower in centis, do a stepdown at around 50 (5000 in centis)</a>
<a name="ln383"> * and return a rescaled value.</a>
<a name="ln384"> *</a>
<a name="ln385"> * @param power the input spellpower in centis.</a>
<a name="ln386"> * @param scale a value to scale the result by, between 1 and 1000. Default is</a>
<a name="ln387"> *        1, which returns a regular spellpower. 1000 gives you millis, 100</a>
<a name="ln388"> *        centis.</a>
<a name="ln389"> */</a>
<a name="ln390">int stepdown_spellpower(int power, int scale)</a>
<a name="ln391">{</a>
<a name="ln392">    // use millis internally</a>
<a name="ln393">    ASSERT_RANGE(scale, 1, 1000);</a>
<a name="ln394">    const int divisor = 1000 / scale;</a>
<a name="ln395">    int result = stepdown_value(power * 10, 50000, 50000, 150000, 200000)</a>
<a name="ln396">                    / divisor;</a>
<a name="ln397">    return result;</a>
<a name="ln398">}</a>
<a name="ln399"> </a>
<a name="ln400">/*</a>
<a name="ln401"> * Calculate spell power.</a>
<a name="ln402"> *</a>
<a name="ln403"> * @param spell         the spell to check</a>
<a name="ln404"> * @param apply_intel   whether to include intelligence in the calculation</a>
<a name="ln405"> * @param fail_rate_check is this just a plain failure rate check or should it</a>
<a name="ln406"> *                      incorporate situational facts and mutations?</a>
<a name="ln407"> * @param cap_power     whether to apply the power cap for the spell (from</a>
<a name="ln408"> *                      `spell_power_cap(spell)`)</a>
<a name="ln409"> * @param scale         what scale to apply to the result internally?  This</a>
<a name="ln410"> *                      function has higher internal resolution than the default</a>
<a name="ln411"> *                      argument, so use this rather than dividing. This must be</a>
<a name="ln412"> *                      between 1 and 1000.</a>
<a name="ln413"> *</a>
<a name="ln414"> * @return the resulting spell power.</a>
<a name="ln415"> */</a>
<a name="ln416">int calc_spell_power(spell_type spell, bool apply_intel, bool fail_rate_check,</a>
<a name="ln417">                     bool cap_power, int scale)</a>
<a name="ln418">{</a>
<a name="ln419">    int power = 0;</a>
<a name="ln420"> </a>
<a name="ln421">    const spschools_type disciplines = get_spell_disciplines(spell);</a>
<a name="ln422"> </a>
<a name="ln423">    int skillcount = count_bits(disciplines);</a>
<a name="ln424">    if (skillcount)</a>
<a name="ln425">    {</a>
<a name="ln426">        for (const auto bit : spschools_type::range())</a>
<a name="ln427">            if (disciplines &amp; bit)</a>
<a name="ln428">                power += you.skill(spell_type2skill(bit), 200);</a>
<a name="ln429">        power /= skillcount;</a>
<a name="ln430">    }</a>
<a name="ln431"> </a>
<a name="ln432">    power += you.skill(SK_SPELLCASTING, 50);</a>
<a name="ln433"> </a>
<a name="ln434">    if (you.divine_exegesis)</a>
<a name="ln435">        power += you.skill(SK_INVOCATIONS, 300);</a>
<a name="ln436"> </a>
<a name="ln437">    if (fail_rate_check)</a>
<a name="ln438">    {</a>
<a name="ln439">        // Scale appropriately.</a>
<a name="ln440">        // The stepdown performs this step in the else block.</a>
<a name="ln441">        power *= scale;</a>
<a name="ln442">        power /= 100;</a>
<a name="ln443">    }</a>
<a name="ln444">    else</a>
<a name="ln445">    {</a>
<a name="ln446">        if (apply_intel)</a>
<a name="ln447">            power = (power * you.intel()) / 10;</a>
<a name="ln448"> </a>
<a name="ln449">        // [dshaligram] Enhancers don't affect fail rates any more, only spell</a>
<a name="ln450">        // power. Note that this does not affect Vehumet's boost in castability.</a>
<a name="ln451">        power = apply_enhancement(power, _spell_enhancement(spell));</a>
<a name="ln452"> </a>
<a name="ln453">        // Wild magic boosts spell power but decreases success rate.</a>
<a name="ln454">        power *= (10 + 3 * you.get_mutation_level(MUT_WILD_MAGIC));</a>
<a name="ln455">        power /= (10 + 3 * you.get_mutation_level(MUT_SUBDUED_MAGIC));</a>
<a name="ln456"> </a>
<a name="ln457">        // Augmentation boosts spell power at high HP.</a>
<a name="ln458">        power *= 10 + 4 * augmentation_amount();</a>
<a name="ln459">        power /= 10;</a>
<a name="ln460"> </a>
<a name="ln461">        // Each level of horror reduces spellpower by 10%</a>
<a name="ln462">        if (you.duration[DUR_HORROR])</a>
<a name="ln463">        {</a>
<a name="ln464">            power *= 10;</a>
<a name="ln465">            power /= 10 + (you.props[HORROR_PENALTY_KEY].get_int() * 3) / 2;</a>
<a name="ln466">        }</a>
<a name="ln467"> </a>
<a name="ln468">        // at this point, `power` is assumed to be basically in centis.</a>
<a name="ln469">        // apply a stepdown, and scale.</a>
<a name="ln470">        power = stepdown_spellpower(power, scale);</a>
<a name="ln471">    }</a>
<a name="ln472"> </a>
<a name="ln473">    const int cap = spell_power_cap(spell);</a>
<a name="ln474">    if (cap &gt; 0 &amp;&amp; cap_power)</a>
<a name="ln475">        power = min(power, cap * scale);</a>
<a name="ln476"> </a>
<a name="ln477">    return power;</a>
<a name="ln478">}</a>
<a name="ln479"> </a>
<a name="ln480">static int _spell_enhancement(spell_type spell)</a>
<a name="ln481">{</a>
<a name="ln482">    const spschools_type typeflags = get_spell_disciplines(spell);</a>
<a name="ln483">    int enhanced = 0;</a>
<a name="ln484"> </a>
<a name="ln485">    if (typeflags &amp; spschool::conjuration)</a>
<a name="ln486">        enhanced += player_spec_conj();</a>
<a name="ln487"> </a>
<a name="ln488">    if (typeflags &amp; spschool::hexes)</a>
<a name="ln489">        enhanced += player_spec_hex();</a>
<a name="ln490"> </a>
<a name="ln491">    if (typeflags &amp; spschool::charms)</a>
<a name="ln492">        enhanced += player_spec_charm();</a>
<a name="ln493"> </a>
<a name="ln494">    if (typeflags &amp; spschool::summoning)</a>
<a name="ln495">        enhanced += player_spec_summ();</a>
<a name="ln496"> </a>
<a name="ln497">    if (typeflags &amp; spschool::poison)</a>
<a name="ln498">        enhanced += player_spec_poison();</a>
<a name="ln499"> </a>
<a name="ln500">    if (typeflags &amp; spschool::necromancy)</a>
<a name="ln501">        enhanced += player_spec_death();</a>
<a name="ln502"> </a>
<a name="ln503">    if (typeflags &amp; spschool::fire)</a>
<a name="ln504">        enhanced += player_spec_fire();</a>
<a name="ln505"> </a>
<a name="ln506">    if (typeflags &amp; spschool::ice)</a>
<a name="ln507">        enhanced += player_spec_cold();</a>
<a name="ln508"> </a>
<a name="ln509">    if (typeflags &amp; spschool::earth)</a>
<a name="ln510">        enhanced += player_spec_earth();</a>
<a name="ln511"> </a>
<a name="ln512">    if (typeflags &amp; spschool::air)</a>
<a name="ln513">        enhanced += player_spec_air();</a>
<a name="ln514"> </a>
<a name="ln515">    if (you.form == transformation::shadow)</a>
<a name="ln516">        enhanced -= 2;</a>
<a name="ln517"> </a>
<a name="ln518">    enhanced += you.archmagi();</a>
<a name="ln519">    enhanced += player_equip_unrand(UNRAND_MAJIN);</a>
<a name="ln520">    enhanced += you.duration[DUR_BRILLIANCE] &gt; 0;</a>
<a name="ln521"> </a>
<a name="ln522">    // These are used in an exponential way, so we'll limit them a bit. -- bwr</a>
<a name="ln523">    if (enhanced &gt; 3)</a>
<a name="ln524">        enhanced = 3;</a>
<a name="ln525">    else if (enhanced &lt; -3)</a>
<a name="ln526">        enhanced = -3;</a>
<a name="ln527"> </a>
<a name="ln528">    return enhanced;</a>
<a name="ln529">}</a>
<a name="ln530"> </a>
<a name="ln531">/**</a>
<a name="ln532"> * Apply the effects of spell enhancers (and de-enhancers) on spellpower.</a>
<a name="ln533"> *</a>
<a name="ln534"> * @param initial_power     The power of the spell before enhancers are added.</a>
<a name="ln535"> * @param enhancer_levels   The number of enhancements levels to apply.</a>
<a name="ln536"> * @return                  The power of the spell with enhancers considered.</a>
<a name="ln537"> */</a>
<a name="ln538">int apply_enhancement(const int initial_power, const int enhancer_levels)</a>
<a name="ln539">{</a>
<a name="ln540">    int power = initial_power;</a>
<a name="ln541"> </a>
<a name="ln542">    if (enhancer_levels &gt; 0)</a>
<a name="ln543">    {</a>
<a name="ln544">        for (int i = 0; i &lt; enhancer_levels; i++)</a>
<a name="ln545">        {</a>
<a name="ln546">            power *= 15;</a>
<a name="ln547">            power /= 10;</a>
<a name="ln548">        }</a>
<a name="ln549">    }</a>
<a name="ln550">    else if (enhancer_levels &lt; 0)</a>
<a name="ln551">    {</a>
<a name="ln552">        for (int i = enhancer_levels; i &lt; 0; i++)</a>
<a name="ln553">            power /= 2;</a>
<a name="ln554">    }</a>
<a name="ln555"> </a>
<a name="ln556">    return power;</a>
<a name="ln557">}</a>
<a name="ln558"> </a>
<a name="ln559">void inspect_spells()</a>
<a name="ln560">{</a>
<a name="ln561">    if (!you.spell_no)</a>
<a name="ln562">    {</a>
<a name="ln563">        canned_msg(MSG_NO_SPELLS);</a>
<a name="ln564">        return;</a>
<a name="ln565">    }</a>
<a name="ln566"> </a>
<a name="ln567">    list_spells(true, true);</a>
<a name="ln568">}</a>
<a name="ln569"> </a>
<a name="ln570">/**</a>
<a name="ln571"> * Can the player cast any spell at all? Checks for things that limit</a>
<a name="ln572"> * spellcasting regardless of the specific spell we want to cast.</a>
<a name="ln573"> *</a>
<a name="ln574"> * @param quiet    If true, don't print a reason why no spell can be cast.</a>
<a name="ln575"> * @param exegesis If true, we're considering casting under Divine Exegesis.</a>
<a name="ln576"> * @return True if we could cast a spell, false otherwise.</a>
<a name="ln577">*/</a>
<a name="ln578">bool can_cast_spells(bool quiet, bool exegesis)</a>
<a name="ln579">{</a>
<a name="ln580">    if (!get_form()-&gt;can_cast)</a>
<a name="ln581">    {</a>
<a name="ln582">        if (!quiet)</a>
<a name="ln583">            canned_msg(MSG_PRESENT_FORM);</a>
<a name="ln584">        return false;</a>
<a name="ln585">    }</a>
<a name="ln586"> </a>
<a name="ln587">    if (you.duration[DUR_WATER_HOLD] &amp;&amp; !you.res_water_drowning())</a>
<a name="ln588">    {</a>
<a name="ln589">        if (!quiet)</a>
<a name="ln590">            mpr(&quot;You cannot cast spells while unable to breathe!&quot;);</a>
<a name="ln591">        return false;</a>
<a name="ln592">    }</a>
<a name="ln593"> </a>
<a name="ln594">    if (you.duration[DUR_BRAINLESS])</a>
<a name="ln595">    {</a>
<a name="ln596">        if (!quiet)</a>
<a name="ln597">            mpr(&quot;You lack the mental capacity to cast spells.&quot;);</a>
<a name="ln598">        return false;</a>
<a name="ln599">    }</a>
<a name="ln600"> </a>
<a name="ln601">    // Randart weapons.</a>
<a name="ln602">    if (you.no_cast())</a>
<a name="ln603">    {</a>
<a name="ln604">        if (!quiet)</a>
<a name="ln605">            mpr(&quot;Something interferes with your magic!&quot;);</a>
<a name="ln606">        return false;</a>
<a name="ln607">    }</a>
<a name="ln608"> </a>
<a name="ln609">    // Check that we have a spell memorised. Divine Exegesis does not need this</a>
<a name="ln610">    // condition, but we can't just check you.divine_exegesis in all cases, as</a>
<a name="ln611">    // it may not be set yet. Check a passed parameter instead.</a>
<a name="ln612">    if (!exegesis &amp;&amp; !you.spell_no)</a>
<a name="ln613">    {</a>
<a name="ln614">        if (!quiet)</a>
<a name="ln615">            canned_msg(MSG_NO_SPELLS);</a>
<a name="ln616">        return false;</a>
<a name="ln617">    }</a>
<a name="ln618"> </a>
<a name="ln619">    if (you.berserk())</a>
<a name="ln620">    {</a>
<a name="ln621">        if (!quiet)</a>
<a name="ln622">            canned_msg(MSG_TOO_BERSERK);</a>
<a name="ln623">        return false;</a>
<a name="ln624">    }</a>
<a name="ln625"> </a>
<a name="ln626">    if (you.confused())</a>
<a name="ln627">    {</a>
<a name="ln628">        if (!quiet)</a>
<a name="ln629">            mpr(&quot;You're too confused to cast spells.&quot;);</a>
<a name="ln630">        return false;</a>
<a name="ln631">    }</a>
<a name="ln632"> </a>
<a name="ln633">    if (silenced(you.pos()))</a>
<a name="ln634">    {</a>
<a name="ln635">        if (!quiet)</a>
<a name="ln636">            mpr(&quot;You cannot cast spells when silenced!&quot;);</a>
<a name="ln637">        // included in default force_more_message</a>
<a name="ln638">        return false;</a>
<a name="ln639">    }</a>
<a name="ln640"> </a>
<a name="ln641">    if (apply_starvation_penalties())</a>
<a name="ln642">    {</a>
<a name="ln643">        if (!quiet)</a>
<a name="ln644">            canned_msg(MSG_NO_ENERGY);</a>
<a name="ln645">        return false;</a>
<a name="ln646">    }</a>
<a name="ln647"> </a>
<a name="ln648">    return true;</a>
<a name="ln649">}</a>
<a name="ln650"> </a>
<a name="ln651">void do_cast_spell_cmd(bool force)</a>
<a name="ln652">{</a>
<a name="ln653">    if (!cast_a_spell(!force))</a>
<a name="ln654">        flush_input_buffer(FLUSH_ON_FAILURE);</a>
<a name="ln655">}</a>
<a name="ln656"> </a>
<a name="ln657">/**</a>
<a name="ln658"> * Cast a spell.</a>
<a name="ln659"> *</a>
<a name="ln660"> * Handles general preconditions &amp; costs.</a>
<a name="ln661"> *</a>
<a name="ln662"> * @param check_range   If true, abort if no targets are in range. (z vs Z)</a>
<a name="ln663"> * @param spell         The type of spell to be cast.</a>
<a name="ln664"> * @return              Whether the spell was successfully cast.</a>
<a name="ln665"> **/</a>
<a name="ln666">bool cast_a_spell(bool check_range, spell_type spell)</a>
<a name="ln667">{</a>
<a name="ln668">    if (!can_cast_spells(false, you.divine_exegesis))</a>
<a name="ln669">    {</a>
<a name="ln670">        crawl_state.zero_turns_taken();</a>
<a name="ln671">        return false;</a>
<a name="ln672">    }</a>
<a name="ln673"> </a>
<a name="ln674">    if (crawl_state.game_is_hints())</a>
<a name="ln675">        Hints.hints_spell_counter++;</a>
<a name="ln676"> </a>
<a name="ln677">    if (spell == SPELL_NO_SPELL)</a>
<a name="ln678">    {</a>
<a name="ln679">        int keyin = 0;</a>
<a name="ln680"> </a>
<a name="ln681">        while (true)</a>
<a name="ln682">        {</a>
<a name="ln683">#ifdef TOUCH_UI</a>
<a name="ln684">            keyin = list_spells(true, false);</a>
<a name="ln685">            if (!keyin)</a>
<a name="ln686">                keyin = ESCAPE;</a>
<a name="ln687"> </a>
<a name="ln688">            if (!crawl_state.doing_prev_cmd_again)</a>
<a name="ln689">                redraw_screen();</a>
<a name="ln690"> </a>
<a name="ln691">            if (isaalpha(keyin) || key_is_escape(keyin))</a>
<a name="ln692">                break;</a>
<a name="ln693">            else</a>
<a name="ln694">                clear_messages();</a>
<a name="ln695"> </a>
<a name="ln696">            keyin = 0;</a>
<a name="ln697">#else</a>
<a name="ln698">            if (keyin == 0)</a>
<a name="ln699">            {</a>
<a name="ln700">                if (you.spell_no == 1)</a>
<a name="ln701">                {</a>
<a name="ln702">                    // Set last_cast_spell to the current only spell.</a>
<a name="ln703">                    for (int i = 0; i &lt; 52; ++i)</a>
<a name="ln704">                    {</a>
<a name="ln705">                        const char letter = index_to_letter(i);</a>
<a name="ln706">                        const spell_type spl = get_spell_by_letter(letter);</a>
<a name="ln707"> </a>
<a name="ln708">                        if (!is_valid_spell(spl))</a>
<a name="ln709">                            continue;</a>
<a name="ln710"> </a>
<a name="ln711">                        you.last_cast_spell = spl;</a>
<a name="ln712">                        break;</a>
<a name="ln713">                    }</a>
<a name="ln714">                }</a>
<a name="ln715"> </a>
<a name="ln716">                // We allow setting last cast spell by Divine Exegesis, but we</a>
<a name="ln717">                // don't allow recasting it with the UI unless we actually have</a>
<a name="ln718">                // the spell memorized.</a>
<a name="ln719">                if (you.last_cast_spell != SPELL_NO_SPELL</a>
<a name="ln720">                    &amp;&amp; !you.has_spell(you.last_cast_spell))</a>
<a name="ln721">                {</a>
<a name="ln722">                    you.last_cast_spell = SPELL_NO_SPELL;</a>
<a name="ln723">                }</a>
<a name="ln724"> </a>
<a name="ln725">                if (you.last_cast_spell == SPELL_NO_SPELL</a>
<a name="ln726">                    || !Options.enable_recast_spell)</a>
<a name="ln727">                {</a>
<a name="ln728">                    mprf(MSGCH_PROMPT, &quot;Cast which spell? (? or * to list) &quot;);</a>
<a name="ln729">                }</a>
<a name="ln730">                else</a>
<a name="ln731">                {</a>
<a name="ln732">                    mprf(MSGCH_PROMPT, &quot;Casting: &lt;w&gt;%s&lt;/w&gt; &lt;lightgrey&gt;(%s)&lt;/lightgrey&gt;&quot;,</a>
<a name="ln733">                                       spell_title(you.last_cast_spell),</a>
<a name="ln734">                                       _spell_failure_rate_description(you.last_cast_spell).c_str());</a>
<a name="ln735">                    mprf(MSGCH_PROMPT, &quot;Confirm with . or Enter, or press &quot;</a>
<a name="ln736">                                       &quot;? or * to list all spells.&quot;);</a>
<a name="ln737">                }</a>
<a name="ln738"> </a>
<a name="ln739">                keyin = get_ch();</a>
<a name="ln740">            }</a>
<a name="ln741"> </a>
<a name="ln742">            if (keyin == '?' || keyin == '*')</a>
<a name="ln743">            {</a>
<a name="ln744">                keyin = list_spells(true, false);</a>
<a name="ln745">                if (!keyin)</a>
<a name="ln746">                    keyin = ESCAPE;</a>
<a name="ln747"> </a>
<a name="ln748">                if (!crawl_state.doing_prev_cmd_again)</a>
<a name="ln749">                    redraw_screen();</a>
<a name="ln750"> </a>
<a name="ln751">                if (isaalpha(keyin) || key_is_escape(keyin))</a>
<a name="ln752">                    break;</a>
<a name="ln753">                else</a>
<a name="ln754">                    clear_messages();</a>
<a name="ln755"> </a>
<a name="ln756">                keyin = 0;</a>
<a name="ln757">            }</a>
<a name="ln758">            else</a>
<a name="ln759">                break;</a>
<a name="ln760">#endif</a>
<a name="ln761">        }</a>
<a name="ln762"> </a>
<a name="ln763">        if (key_is_escape(keyin))</a>
<a name="ln764">        {</a>
<a name="ln765">            canned_msg(MSG_OK);</a>
<a name="ln766">            crawl_state.zero_turns_taken();</a>
<a name="ln767">            return false;</a>
<a name="ln768">        }</a>
<a name="ln769">        else if (Options.enable_recast_spell</a>
<a name="ln770">                 &amp;&amp; (keyin == '.' || keyin == CK_ENTER))</a>
<a name="ln771">        {</a>
<a name="ln772">            spell = you.last_cast_spell;</a>
<a name="ln773">        }</a>
<a name="ln774">        else if (!isaalpha(keyin))</a>
<a name="ln775">        {</a>
<a name="ln776">            mpr(&quot;You don't know that spell.&quot;);</a>
<a name="ln777">            crawl_state.zero_turns_taken();</a>
<a name="ln778">            return false;</a>
<a name="ln779">        }</a>
<a name="ln780">        else</a>
<a name="ln781">            spell = get_spell_by_letter(keyin);</a>
<a name="ln782">    }</a>
<a name="ln783"> </a>
<a name="ln784">    if (spell == SPELL_NO_SPELL)</a>
<a name="ln785">    {</a>
<a name="ln786">        mpr(&quot;You don't know that spell.&quot;);</a>
<a name="ln787">        crawl_state.zero_turns_taken();</a>
<a name="ln788">        return false;</a>
<a name="ln789">    }</a>
<a name="ln790"> </a>
<a name="ln791">    int cost = spell_mana(spell);</a>
<a name="ln792">    if (!enough_mp(cost, true))</a>
<a name="ln793">    {</a>
<a name="ln794">        mpr(&quot;You don't have enough magic to cast that spell.&quot;);</a>
<a name="ln795">        crawl_state.zero_turns_taken();</a>
<a name="ln796">        return false;</a>
<a name="ln797">    }</a>
<a name="ln798"> </a>
<a name="ln799">    if (check_range &amp;&amp; spell_no_hostile_in_range(spell))</a>
<a name="ln800">    {</a>
<a name="ln801">        // Abort if there are no hostiles within range, but flash the range</a>
<a name="ln802">        // markers for a short while.</a>
<a name="ln803">        mpr(&quot;You can't see any susceptible monsters within range! &quot;</a>
<a name="ln804">            &quot;(Use &lt;w&gt;Z&lt;/w&gt; to cast anyway.)&quot;);</a>
<a name="ln805"> </a>
<a name="ln806">        if ((Options.use_animations &amp; UA_RANGE) &amp;&amp; Options.darken_beyond_range)</a>
<a name="ln807">        {</a>
<a name="ln808">            targeter_smite range(&amp;you, calc_spell_range(spell), 0, 0, true);</a>
<a name="ln809">            range_view_annotator show_range(&amp;range);</a>
<a name="ln810">            delay(50);</a>
<a name="ln811">        }</a>
<a name="ln812">        crawl_state.zero_turns_taken();</a>
<a name="ln813">        return false;</a>
<a name="ln814">    }</a>
<a name="ln815"> </a>
<a name="ln816">    if (you.undead_state() == US_ALIVE &amp;&amp; !you_foodless()</a>
<a name="ln817">        &amp;&amp; you.hunger &lt;= spell_hunger(spell))</a>
<a name="ln818">    {</a>
<a name="ln819">        canned_msg(MSG_NO_ENERGY);</a>
<a name="ln820">        crawl_state.zero_turns_taken();</a>
<a name="ln821">        return false;</a>
<a name="ln822">    }</a>
<a name="ln823"> </a>
<a name="ln824">    // This needs more work: there are spells which are hated but allowed if</a>
<a name="ln825">    // they don't have a certain effect. You may use Poison Arrow on those</a>
<a name="ln826">    // immune, use Mephitic Cloud to shield yourself from other clouds, and</a>
<a name="ln827">    // thus we don't prompt for them. It would be nice to prompt for them</a>
<a name="ln828">    // during the targeting phase, perhaps.</a>
<a name="ln829">    if (god_punishes_spell(spell, you.religion)</a>
<a name="ln830">        &amp;&amp; !crawl_state.disables[DIS_CONFIRMATIONS])</a>
<a name="ln831">    {</a>
<a name="ln832">        // None currently dock just piety, right?</a>
<a name="ln833">        if (!yesno(god_loathes_spell(spell, you.religion) ?</a>
<a name="ln834">            &quot;Casting this spell will cause instant excommunication! &quot;</a>
<a name="ln835">            &quot;Really cast?&quot; :</a>
<a name="ln836">            &quot;Casting this spell will place you under penance. Really cast?&quot;,</a>
<a name="ln837">            true, 'n'))</a>
<a name="ln838">        {</a>
<a name="ln839">            canned_msg(MSG_OK);</a>
<a name="ln840">            crawl_state.zero_turns_taken();</a>
<a name="ln841">            return false;</a>
<a name="ln842">        }</a>
<a name="ln843">    }</a>
<a name="ln844"> </a>
<a name="ln845">    const bool hungerless = hungerless_spells();</a>
<a name="ln846">    you.last_cast_spell = spell;</a>
<a name="ln847">    // Silently take MP before the spell.</a>
<a name="ln848">    dec_mp(cost, true);</a>
<a name="ln849"> </a>
<a name="ln850">    const spret cast_result = your_spells(spell, 0, !you.divine_exegesis,</a>
<a name="ln851">                                          nullptr);</a>
<a name="ln852">    if (cast_result == spret::abort)</a>
<a name="ln853">    {</a>
<a name="ln854">        crawl_state.zero_turns_taken();</a>
<a name="ln855">        // Return the MP since the spell is aborted.</a>
<a name="ln856">        inc_mp(cost, true);</a>
<a name="ln857">        redraw_screen();</a>
<a name="ln858">        return false;</a>
<a name="ln859">    }</a>
<a name="ln860"> </a>
<a name="ln861">    practise_casting(spell, cast_result == spret::success);</a>
<a name="ln862">    if (cast_result == spret::success)</a>
<a name="ln863">    {</a>
<a name="ln864">        did_god_conduct(DID_SPELL_CASTING, 1 + random2(5));</a>
<a name="ln865">        count_action(CACT_CAST, spell);</a>
<a name="ln866">    }</a>
<a name="ln867"> </a>
<a name="ln868">    flush_mp();</a>
<a name="ln869"> </a>
<a name="ln870">    if (!hungerless &amp;&amp; you.undead_state() != US_UNDEAD)</a>
<a name="ln871">    {</a>
<a name="ln872">        const int spellh = spell_hunger(spell);</a>
<a name="ln873">        if (calc_hunger(spellh) &gt; 0)</a>
<a name="ln874">        {</a>
<a name="ln875">            make_hungry(spellh, true, true);</a>
<a name="ln876">            learned_something_new(HINT_SPELL_HUNGER);</a>
<a name="ln877">        }</a>
<a name="ln878">    }</a>
<a name="ln879"> </a>
<a name="ln880">    you.turn_is_over = true;</a>
<a name="ln881">    alert_nearby_monsters();</a>
<a name="ln882"> </a>
<a name="ln883">    return true;</a>
<a name="ln884">}</a>
<a name="ln885"> </a>
<a name="ln886">/**</a>
<a name="ln887"> * Handles divine response to spellcasting.</a>
<a name="ln888"> *</a>
<a name="ln889"> * @param spell         The type of spell just cast.</a>
<a name="ln890"> */</a>
<a name="ln891">static void _spellcasting_god_conduct(spell_type spell)</a>
<a name="ln892">{</a>
<a name="ln893">    // If you are casting while a god is acting, then don't do conducts.</a>
<a name="ln894">    // (Presumably Xom is forcing you to cast a spell.)</a>
<a name="ln895">    if (crawl_state.is_god_acting())</a>
<a name="ln896">        return;</a>
<a name="ln897"> </a>
<a name="ln898">    const int conduct_level = 10 + spell_difficulty(spell);</a>
<a name="ln899"> </a>
<a name="ln900">    if (is_evil_spell(spell) || you.spellcasting_unholy())</a>
<a name="ln901">        did_god_conduct(DID_EVIL, conduct_level);</a>
<a name="ln902"> </a>
<a name="ln903">    if (is_unclean_spell(spell))</a>
<a name="ln904">        did_god_conduct(DID_UNCLEAN, conduct_level);</a>
<a name="ln905"> </a>
<a name="ln906">    if (is_chaotic_spell(spell))</a>
<a name="ln907">        did_god_conduct(DID_CHAOS, conduct_level);</a>
<a name="ln908"> </a>
<a name="ln909">    // not is_hasty_spell since the other ones handle the conduct themselves.</a>
<a name="ln910">    if (spell == SPELL_SWIFTNESS)</a>
<a name="ln911">        did_god_conduct(DID_HASTY, conduct_level);</a>
<a name="ln912"> </a>
<a name="ln913">    if (spell == SPELL_SUBLIMATION_OF_BLOOD)</a>
<a name="ln914">        did_god_conduct(DID_CHANNEL, conduct_level);</a>
<a name="ln915"> </a>
<a name="ln916">    if (god_loathes_spell(spell, you.religion))</a>
<a name="ln917">        excommunication();</a>
<a name="ln918">}</a>
<a name="ln919"> </a>
<a name="ln920">/**</a>
<a name="ln921"> * Let the Majin-Bo congratulate you on casting a spell while using it.</a>
<a name="ln922"> *</a>
<a name="ln923"> * @param spell     The spell just successfully cast.</a>
<a name="ln924"> */</a>
<a name="ln925">static void _majin_speak(spell_type spell)</a>
<a name="ln926">{</a>
<a name="ln927">    // since this isn't obviously mental communication, let it be silenced</a>
<a name="ln928">    if (silenced(you.pos()))</a>
<a name="ln929">        return;</a>
<a name="ln930"> </a>
<a name="ln931">    const int level = spell_difficulty(spell);</a>
<a name="ln932">    const bool weak = level &lt;= 4;</a>
<a name="ln933">    const string lookup = weak ? &quot;majin-bo cast weak&quot; : &quot;majin-bo cast&quot;;</a>
<a name="ln934">    const string msg = &quot;A voice whispers, \&quot;&quot; + getSpeakString(lookup) + &quot;\&quot;&quot;;</a>
<a name="ln935">    mprf(MSGCH_TALK, &quot;%s&quot;, msg.c_str());</a>
<a name="ln936">}</a>
<a name="ln937"> </a>
<a name="ln938">/**</a>
<a name="ln939"> * Handles side effects of successfully casting a spell.</a>
<a name="ln940"> *</a>
<a name="ln941"> * Spell noise, magic 'sap' effects, and god conducts.</a>
<a name="ln942"> *</a>
<a name="ln943"> * @param spell         The type of spell just cast.</a>
<a name="ln944"> * @param god           Which god is casting the spell; NO_GOD if it's you.</a>
<a name="ln945"> * @param fake_spell    true if the spell is evoked or from an innate or divine ability</a>
<a name="ln946"> *                      false if it is a spell being cast normally.</a>
<a name="ln947"> */</a>
<a name="ln948">static void _spellcasting_side_effects(spell_type spell, god_type god,</a>
<a name="ln949">                                       bool fake_spell)</a>
<a name="ln950">{</a>
<a name="ln951">    _spellcasting_god_conduct(spell);</a>
<a name="ln952"> </a>
<a name="ln953">    if (god == GOD_NO_GOD)</a>
<a name="ln954">    {</a>
<a name="ln955">        // Casting pain costs 1 hp.</a>
<a name="ln956">        // Deep Dwarves' damage reduction always blocks at least 1 hp.</a>
<a name="ln957">        if (spell == SPELL_PAIN</a>
<a name="ln958">            &amp;&amp; (you.species != SP_DEEP_DWARF &amp;&amp; !player_res_torment()))</a>
<a name="ln959">        {</a>
<a name="ln960">            dec_hp(1, false);</a>
<a name="ln961">        }</a>
<a name="ln962"> </a>
<a name="ln963">        if (you.duration[DUR_SAP_MAGIC]</a>
<a name="ln964">            &amp;&amp; you.props[SAP_MAGIC_KEY].get_int() &lt; 3</a>
<a name="ln965">            &amp;&amp; !fake_spell &amp;&amp; coinflip())</a>
<a name="ln966">        {</a>
<a name="ln967">            mprf(MSGCH_WARN, &quot;Your control over your magic is sapped.&quot;);</a>
<a name="ln968">            you.props[SAP_MAGIC_KEY].get_int()++;</a>
<a name="ln969">        }</a>
<a name="ln970"> </a>
<a name="ln971">        // Make some noise if it's actually the player casting.</a>
<a name="ln972">        noisy(spell_noise(spell), you.pos());</a>
<a name="ln973"> </a>
<a name="ln974">        if (!fake_spell &amp;&amp; player_equip_unrand(UNRAND_MAJIN))</a>
<a name="ln975">        {</a>
<a name="ln976">            // never kill the player (directly)</a>
<a name="ln977">            int hp_cost = min(spell_mana(spell), you.hp - 1);</a>
<a name="ln978">            ouch(hp_cost, KILLED_BY_SOMETHING, MID_NOBODY, &quot;the Majin-Bo&quot;);</a>
<a name="ln979">            if (one_chance_in(500))</a>
<a name="ln980">                _majin_speak(spell);</a>
<a name="ln981">        }</a>
<a name="ln982">    }</a>
<a name="ln983"> </a>
<a name="ln984">    alert_nearby_monsters();</a>
<a name="ln985"> </a>
<a name="ln986">}</a>
<a name="ln987"> </a>
<a name="ln988">#ifdef WIZARD</a>
<a name="ln989">static void _try_monster_cast(spell_type spell, int /*powc*/,</a>
<a name="ln990">                              dist &amp;spd, bolt &amp;beam)</a>
<a name="ln991">{</a>
<a name="ln992">    if (monster_at(you.pos()))</a>
<a name="ln993">    {</a>
<a name="ln994">        mpr(&quot;Couldn't try casting monster spell because you're &quot;</a>
<a name="ln995">            &quot;on top of a monster.&quot;);</a>
<a name="ln996">        return;</a>
<a name="ln997">    }</a>
<a name="ln998"> </a>
<a name="ln999">    monster* mon = get_free_monster();</a>
<a name="ln1000">    if (!mon)</a>
<a name="ln1001">    {</a>
<a name="ln1002">        mpr(&quot;Couldn't try casting monster spell because there is &quot;</a>
<a name="ln1003">            &quot;no empty monster slot.&quot;);</a>
<a name="ln1004">        return;</a>
<a name="ln1005">    }</a>
<a name="ln1006"> </a>
<a name="ln1007">    mpr(&quot;Invalid player spell, attempting to cast it as monster spell.&quot;);</a>
<a name="ln1008"> </a>
<a name="ln1009">    mon-&gt;mname      = &quot;Dummy Monster&quot;;</a>
<a name="ln1010">    mon-&gt;type       = MONS_HUMAN;</a>
<a name="ln1011">    mon-&gt;behaviour  = BEH_SEEK;</a>
<a name="ln1012">    mon-&gt;attitude   = ATT_FRIENDLY;</a>
<a name="ln1013">    mon-&gt;flags      = (MF_NO_REWARD | MF_JUST_SUMMONED | MF_SEEN</a>
<a name="ln1014">                       | MF_WAS_IN_VIEW | MF_HARD_RESET);</a>
<a name="ln1015">    mon-&gt;hit_points = you.hp;</a>
<a name="ln1016">    mon-&gt;set_hit_dice(you.experience_level);</a>
<a name="ln1017">    mon-&gt;set_position(you.pos());</a>
<a name="ln1018">    mon-&gt;target     = spd.target;</a>
<a name="ln1019">    mon-&gt;mid        = MID_PLAYER;</a>
<a name="ln1020"> </a>
<a name="ln1021">    if (!spd.isTarget)</a>
<a name="ln1022">        mon-&gt;foe = MHITNOT;</a>
<a name="ln1023">    else if (!monster_at(spd.target))</a>
<a name="ln1024">    {</a>
<a name="ln1025">        if (spd.isMe())</a>
<a name="ln1026">            mon-&gt;foe = MHITYOU;</a>
<a name="ln1027">        else</a>
<a name="ln1028">            mon-&gt;foe = MHITNOT;</a>
<a name="ln1029">    }</a>
<a name="ln1030">    else</a>
<a name="ln1031">        mon-&gt;foe = mgrd(spd.target);</a>
<a name="ln1032"> </a>
<a name="ln1033">    mgrd(you.pos()) = mon-&gt;mindex();</a>
<a name="ln1034"> </a>
<a name="ln1035">    mons_cast(mon, beam, spell, MON_SPELL_NO_FLAGS);</a>
<a name="ln1036"> </a>
<a name="ln1037">    mon-&gt;reset();</a>
<a name="ln1038">}</a>
<a name="ln1039">#endif // WIZARD</a>
<a name="ln1040"> </a>
<a name="ln1041">static spret _do_cast(spell_type spell, int powc, const dist&amp; spd,</a>
<a name="ln1042">                           bolt&amp; beam, god_type god, bool fail);</a>
<a name="ln1043"> </a>
<a name="ln1044">/**</a>
<a name="ln1045"> * Should this spell be aborted before casting properly starts, either because</a>
<a name="ln1046"> * it can't legally be cast in this circumstance, or because the player opts</a>
<a name="ln1047"> * to cancel it in response to a prompt?</a>
<a name="ln1048"> *</a>
<a name="ln1049"> * @param spell         The spell to be checked</a>
<a name="ln1050"> * @param fake_spell    true if the spell is evoked or from an innate or divine ability</a>
<a name="ln1051"> *                      false if it is a spell being cast normally.</a>
<a name="ln1052"> * @return              Whether the spellcasting should be aborted.</a>
<a name="ln1053"> */</a>
<a name="ln1054">static bool _spellcasting_aborted(spell_type spell, bool fake_spell)</a>
<a name="ln1055">{</a>
<a name="ln1056">    string msg;</a>
<a name="ln1057"> </a>
<a name="ln1058">    {</a>
<a name="ln1059">        // FIXME: we might be called in a situation ([a]bilities, Xom) that</a>
<a name="ln1060">        // isn't evoked but still doesn't use the spell's MP. your_spells,</a>
<a name="ln1061">        // this function, and spell_uselessness_reason should take a flag</a>
<a name="ln1062">        // indicating whether MP should be checked (or should never check).</a>
<a name="ln1063">        const int rest_mp = fake_spell ? 0 : spell_mana(spell);</a>
<a name="ln1064"> </a>
<a name="ln1065">        // Temporarily restore MP so that we're not uncastable for lack of MP.</a>
<a name="ln1066">        unwind_var&lt;int&gt; fake_mp(you.magic_points, you.magic_points + rest_mp);</a>
<a name="ln1067">        msg = spell_uselessness_reason(spell, true, true, fake_spell);</a>
<a name="ln1068">    }</a>
<a name="ln1069"> </a>
<a name="ln1070">    if (!msg.empty())</a>
<a name="ln1071">    {</a>
<a name="ln1072">        mpr(msg);</a>
<a name="ln1073">        return true;</a>
<a name="ln1074">    }</a>
<a name="ln1075"> </a>
<a name="ln1076">    vector&lt;text_pattern&gt; &amp;actions = Options.confirm_action;</a>
<a name="ln1077">    if (!actions.empty())</a>
<a name="ln1078">    {</a>
<a name="ln1079">        const char* name = spell_title(spell);</a>
<a name="ln1080">        for (const text_pattern &amp;action : actions)</a>
<a name="ln1081">        {</a>
<a name="ln1082">            if (!action.matches(name))</a>
<a name="ln1083">                continue;</a>
<a name="ln1084"> </a>
<a name="ln1085">            string prompt = &quot;Really cast &quot; + string(name) + &quot;?&quot;;</a>
<a name="ln1086">            if (!yesno(prompt.c_str(), false, 'n'))</a>
<a name="ln1087">            {</a>
<a name="ln1088">                canned_msg(MSG_OK);</a>
<a name="ln1089">                return true;</a>
<a name="ln1090">            }</a>
<a name="ln1091">            break;</a>
<a name="ln1092">        }</a>
<a name="ln1093">    }</a>
<a name="ln1094"> </a>
<a name="ln1095">    const int severity = fail_severity(spell);</a>
<a name="ln1096">    const string failure_rate = spell_failure_rate_string(spell);</a>
<a name="ln1097">    if (Options.fail_severity_to_confirm &gt; 0</a>
<a name="ln1098">        &amp;&amp; Options.fail_severity_to_confirm &lt;= severity</a>
<a name="ln1099">        &amp;&amp; !crawl_state.disables[DIS_CONFIRMATIONS]</a>
<a name="ln1100">        &amp;&amp; !fake_spell)</a>
<a name="ln1101">    {</a>
<a name="ln1102">        if (failure_rate_to_int(raw_spell_fail(spell)) == 100)</a>
<a name="ln1103">        {</a>
<a name="ln1104">            mprf(MSGCH_WARN, &quot;It is impossible to cast this spell &quot;</a>
<a name="ln1105">                    &quot;(100%% risk of failure)!&quot;);</a>
<a name="ln1106">            return true;</a>
<a name="ln1107">        }</a>
<a name="ln1108"> </a>
<a name="ln1109">        string prompt = make_stringf(&quot;The spell is %s to cast &quot;</a>
<a name="ln1110">                                     &quot;(%s risk of failure)%s&quot;,</a>
<a name="ln1111">                                     fail_severity_adjs[severity],</a>
<a name="ln1112">                                     failure_rate.c_str(),</a>
<a name="ln1113">                                     severity &gt; 1 ? &quot;!&quot; : &quot;.&quot;);</a>
<a name="ln1114"> </a>
<a name="ln1115">        prompt = make_stringf(&quot;%s Continue anyway?&quot;, prompt.c_str());</a>
<a name="ln1116">        if (!yesno(prompt.c_str(), false, 'n'))</a>
<a name="ln1117">        {</a>
<a name="ln1118">            canned_msg(MSG_OK);</a>
<a name="ln1119">            return true;</a>
<a name="ln1120">        }</a>
<a name="ln1121">    }</a>
<a name="ln1122"> </a>
<a name="ln1123">    return false;</a>
<a name="ln1124">}</a>
<a name="ln1125"> </a>
<a name="ln1126">static unique_ptr&lt;targeter&gt; _spell_targeter(spell_type spell, int pow,</a>
<a name="ln1127">                                              int range)</a>
<a name="ln1128">{</a>
<a name="ln1129">    switch (spell)</a>
<a name="ln1130">    {</a>
<a name="ln1131">    case SPELL_FIREBALL:</a>
<a name="ln1132">        return make_unique&lt;targeter_beam&gt;(&amp;you, range, ZAP_FIREBALL, pow,</a>
<a name="ln1133">                                          1, 1);</a>
<a name="ln1134">    case SPELL_ICEBLAST:</a>
<a name="ln1135">        return make_unique&lt;targeter_beam&gt;(&amp;you, range, ZAP_ICEBLAST, pow,</a>
<a name="ln1136">                                          1, 1);</a>
<a name="ln1137">    case SPELL_HURL_DAMNATION:</a>
<a name="ln1138">        return make_unique&lt;targeter_beam&gt;(&amp;you, range, ZAP_DAMNATION, pow,</a>
<a name="ln1139">                                          1, 1);</a>
<a name="ln1140">    case SPELL_MEPHITIC_CLOUD:</a>
<a name="ln1141">        return make_unique&lt;targeter_beam&gt;(&amp;you, range, ZAP_MEPHITIC, pow,</a>
<a name="ln1142">                                          pow &gt;= 100 ? 1 : 0, 1);</a>
<a name="ln1143">    case SPELL_FIRE_STORM:</a>
<a name="ln1144">        return make_unique&lt;targeter_smite&gt;(&amp;you, range, 2, pow &gt; 76 ? 3 : 2);</a>
<a name="ln1145">    case SPELL_FREEZING_CLOUD:</a>
<a name="ln1146">    case SPELL_POISONOUS_CLOUD:</a>
<a name="ln1147">    case SPELL_HOLY_BREATH:</a>
<a name="ln1148">        return make_unique&lt;targeter_cloud&gt;(&amp;you, range);</a>
<a name="ln1149">    case SPELL_THUNDERBOLT:</a>
<a name="ln1150">        return make_unique&lt;targeter_thunderbolt&gt;(&amp;you, range,</a>
<a name="ln1151">            (you.props.exists(THUNDERBOLT_LAST_KEY)</a>
<a name="ln1152">             &amp;&amp; you.props[THUNDERBOLT_LAST_KEY].get_int() + 1 == you.num_turns) ?</a>
<a name="ln1153">                you.props[THUNDERBOLT_AIM_KEY].get_coord() : coord_def());</a>
<a name="ln1154">    case SPELL_LRD:</a>
<a name="ln1155">        return make_unique&lt;targeter_fragment&gt;(&amp;you, pow, range);</a>
<a name="ln1156">    case SPELL_FULMINANT_PRISM:</a>
<a name="ln1157">        return make_unique&lt;targeter_smite&gt;(&amp;you, range, 0, 2);</a>
<a name="ln1158">    case SPELL_GLACIATE:</a>
<a name="ln1159">        return make_unique&lt;targeter_cone&gt;(&amp;you, range);</a>
<a name="ln1160">    case SPELL_CLOUD_CONE:</a>
<a name="ln1161">        return make_unique&lt;targeter_shotgun&gt;(&amp;you, CLOUD_CONE_BEAM_COUNT,</a>
<a name="ln1162">                                             range, true);</a>
<a name="ln1163">    case SPELL_SCATTERSHOT:</a>
<a name="ln1164">        return make_unique&lt;targeter_shotgun&gt;(&amp;you, shotgun_beam_count(pow),</a>
<a name="ln1165">                                             range);</a>
<a name="ln1166">    case SPELL_GRAVITAS:</a>
<a name="ln1167">        return make_unique&lt;targeter_smite&gt;(&amp;you, range,</a>
<a name="ln1168">                                           gravitas_range(pow),</a>
<a name="ln1169">                                           gravitas_range(pow),</a>
<a name="ln1170">                                           false,</a>
<a name="ln1171">                                           [](const coord_def&amp; p) -&gt; bool {</a>
<a name="ln1172">                                              return you.pos() != p; });</a>
<a name="ln1173">    case SPELL_VIOLENT_UNRAVELLING:</a>
<a name="ln1174">        return make_unique&lt;targeter_unravelling&gt;(&amp;you, range, pow);</a>
<a name="ln1175">    case SPELL_RANDOM_BOLT:</a>
<a name="ln1176">        return make_unique&lt;targeter_beam&gt;(&amp;you, range, ZAP_CRYSTAL_BOLT, pow,</a>
<a name="ln1177">                                          0, 0);</a>
<a name="ln1178">    case SPELL_INFESTATION:</a>
<a name="ln1179">        return make_unique&lt;targeter_smite&gt;(&amp;you, range, 2, 2, false,</a>
<a name="ln1180">                                           [](const coord_def&amp; p) -&gt; bool {</a>
<a name="ln1181">                                              return you.pos() != p; });</a>
<a name="ln1182">    case SPELL_PASSWALL:</a>
<a name="ln1183">        return make_unique&lt;targeter_passwall&gt;(range);</a>
<a name="ln1184">    case SPELL_DIG:</a>
<a name="ln1185">        return make_unique&lt;targeter_dig&gt;(range);</a>
<a name="ln1186">    default:</a>
<a name="ln1187">        break;</a>
<a name="ln1188">    }</a>
<a name="ln1189"> </a>
<a name="ln1190">    if (spell_to_zap(spell) != NUM_ZAPS)</a>
<a name="ln1191">    {</a>
<a name="ln1192">        return make_unique&lt;targeter_beam&gt;(&amp;you, range, spell_to_zap(spell),</a>
<a name="ln1193">                                          pow, 0, 0);</a>
<a name="ln1194">    }</a>
<a name="ln1195"> </a>
<a name="ln1196">    return nullptr;</a>
<a name="ln1197">}</a>
<a name="ln1198"> </a>
<a name="ln1199">// Returns the nth triangular number.</a>
<a name="ln1200">static int _triangular_number(int n)</a>
<a name="ln1201">{</a>
<a name="ln1202">    return n * (n+1) / 2;</a>
<a name="ln1203">}</a>
<a name="ln1204"> </a>
<a name="ln1205">/**</a>
<a name="ln1206"> * Compute success chance for MR-checking spells and abilities.</a>
<a name="ln1207"> *</a>
<a name="ln1208"> * @param mr The magic resistance of the target.</a>
<a name="ln1209"> * @param powc The enchantment power.</a>
<a name="ln1210"> * @param scale The denominator of the result.</a>
<a name="ln1211"> * @param round_up Should the resulting chance be rounded up (true) or</a>
<a name="ln1212"> *        down (false, the default)?</a>
<a name="ln1213"> *</a>
<a name="ln1214"> * @return The chance, out of scale, that the enchantment affects the target.</a>
<a name="ln1215"> */</a>
<a name="ln1216">int hex_success_chance(const int mr, int powc, int scale, bool round_up)</a>
<a name="ln1217">{</a>
<a name="ln1218">    const int pow = ench_power_stepdown(powc);</a>
<a name="ln1219">    const int target = mr + 100 - pow;</a>
<a name="ln1220">    const int denom = 101 * 100;</a>
<a name="ln1221">    const int adjust = round_up ? denom - 1 : 0;</a>
<a name="ln1222"> </a>
<a name="ln1223">    if (target &lt;= 0)</a>
<a name="ln1224">        return scale;</a>
<a name="ln1225">    if (target &gt; 200)</a>
<a name="ln1226">        return 0;</a>
<a name="ln1227">    if (target &lt;= 100)</a>
<a name="ln1228">        return (scale * (denom - _triangular_number(target)) + adjust) / denom;</a>
<a name="ln1229">    return (scale * _triangular_number(201 - target) + adjust) / denom;</a>
<a name="ln1230">}</a>
<a name="ln1231"> </a>
<a name="ln1232">// Include success chance in targeter for spells checking monster MR.</a>
<a name="ln1233">vector&lt;string&gt; desc_success_chance(const monster_info&amp; mi, int pow, bool evoked,</a>
<a name="ln1234">                                   targeter* hitfunc)</a>
<a name="ln1235">{</a>
<a name="ln1236">    targeter_beam* beam_hitf = dynamic_cast&lt;targeter_beam*&gt;(hitfunc);</a>
<a name="ln1237">    vector&lt;string&gt; descs;</a>
<a name="ln1238">    const int mr = mi.res_magic();</a>
<a name="ln1239">    if (mr == MAG_IMMUNE)</a>
<a name="ln1240">        descs.push_back(&quot;magic immune&quot;);</a>
<a name="ln1241">    else if (hitfunc &amp;&amp; !hitfunc-&gt;affects_monster(mi))</a>
<a name="ln1242">        descs.push_back(&quot;not susceptible&quot;);</a>
<a name="ln1243">    // Polymorph has a special effect on ugly things and shapeshifters that</a>
<a name="ln1244">    // does not require passing an MR check.</a>
<a name="ln1245">    else if (beam_hitf &amp;&amp; beam_hitf-&gt;beam.flavour == BEAM_POLYMORPH</a>
<a name="ln1246">             &amp;&amp; (mi.type == MONS_UGLY_THING || mi.type == MONS_VERY_UGLY_THING</a>
<a name="ln1247">                 || mi.is(MB_SHAPESHIFTER)))</a>
<a name="ln1248">    {</a>
<a name="ln1249">        descs.push_back(make_stringf(&quot;will change %s&quot;,</a>
<a name="ln1250">                                     mi.is(MB_SHAPESHIFTER) ? &quot;shape&quot;</a>
<a name="ln1251">                                     /* ugly things */      : &quot;colour&quot;));</a>
<a name="ln1252">    }</a>
<a name="ln1253">    else</a>
<a name="ln1254">    {</a>
<a name="ln1255">#if TAG_MAJOR_VERSION == 34</a>
<a name="ln1256">        const int adj_pow = evoked ? pakellas_effective_hex_power(pow)</a>
<a name="ln1257">                                   : pow;</a>
<a name="ln1258">#else</a>
<a name="ln1259">        const int adj_pow = pow;</a>
<a name="ln1260">#endif</a>
<a name="ln1261">        const int success = hex_success_chance(mr, adj_pow, 100);</a>
<a name="ln1262">        descs.push_back(make_stringf(&quot;chance to defeat MR: %d%%&quot;, success));</a>
<a name="ln1263">    }</a>
<a name="ln1264">    return descs;</a>
<a name="ln1265">}</a>
<a name="ln1266"> </a>
<a name="ln1267">/**</a>
<a name="ln1268"> * Targets and fires player-cast spells &amp; spell-like effects.</a>
<a name="ln1269"> *</a>
<a name="ln1270"> * Not all of these are actually real spells; invocations, decks or misc.</a>
<a name="ln1271"> * effects might also land us here.</a>
<a name="ln1272"> * Others are currently unused or unimplemented.</a>
<a name="ln1273"> *</a>
<a name="ln1274"> * @param spell         The type of spell being cast.</a>
<a name="ln1275"> * @param powc          Spellpower.</a>
<a name="ln1276"> * @param allow_fail    true if it is a spell being cast normally.</a>
<a name="ln1277"> *                      false if the spell is evoked or from an innate or divine ability</a>
<a name="ln1278"> *</a>
<a name="ln1279"> * @param evoked_item   The wand the spell was evoked from if applicable, or</a>
<a name="ln1280">                        nullptr.</a>
<a name="ln1281"> * @return spret::success if spell is successfully cast for purposes of</a>
<a name="ln1282"> * exercising, spret::fail otherwise, or spret::abort if the player cancelled</a>
<a name="ln1283"> * the casting.</a>
<a name="ln1284"> **/</a>
<a name="ln1285">spret your_spells(spell_type spell, int powc, bool allow_fail,</a>
<a name="ln1286">                       const item_def* const evoked_item)</a>
<a name="ln1287">{</a>
<a name="ln1288">    ASSERT(!crawl_state.game_is_arena());</a>
<a name="ln1289">    ASSERT(!evoked_item || evoked_item-&gt;base_type == OBJ_WANDS);</a>
<a name="ln1290"> </a>
<a name="ln1291">    const bool wiz_cast = (crawl_state.prev_cmd == CMD_WIZARD &amp;&amp; !allow_fail);</a>
<a name="ln1292"> </a>
<a name="ln1293">    dist spd;</a>
<a name="ln1294">    bolt beam;</a>
<a name="ln1295">    beam.origin_spell = spell;</a>
<a name="ln1296"> </a>
<a name="ln1297">    // [dshaligram] Any action that depends on the spellcasting attempt to have</a>
<a name="ln1298">    // succeeded must be performed after the switch.</a>
<a name="ln1299">    if (!wiz_cast &amp;&amp; _spellcasting_aborted(spell, !allow_fail))</a>
<a name="ln1300">        return spret::abort;</a>
<a name="ln1301"> </a>
<a name="ln1302">    const spell_flags flags = get_spell_flags(spell);</a>
<a name="ln1303"> </a>
<a name="ln1304">    ASSERT(wiz_cast || !(flags &amp; spflag::testing));</a>
<a name="ln1305"> </a>
<a name="ln1306">    if (!powc)</a>
<a name="ln1307">        powc = calc_spell_power(spell, true);</a>
<a name="ln1308"> </a>
<a name="ln1309">    const int range = calc_spell_range(spell, powc, allow_fail);</a>
<a name="ln1310">    beam.range = range;</a>
<a name="ln1311"> </a>
<a name="ln1312">    // XXX: This handles only some of the cases where spells need</a>
<a name="ln1313">    // targeting. There are others that do their own that will be</a>
<a name="ln1314">    // missed by this (and thus will not properly ESC without cost</a>
<a name="ln1315">    // because of it). Hopefully, those will eventually be fixed. - bwr</a>
<a name="ln1316">    if (flags &amp; spflag::targeting_mask)</a>
<a name="ln1317">    {</a>
<a name="ln1318">        const targ_mode_type targ =</a>
<a name="ln1319">              testbits(flags, spflag::neutral)    ? TARG_ANY :</a>
<a name="ln1320">              testbits(flags, spflag::helpful)    ? TARG_FRIEND :</a>
<a name="ln1321">              testbits(flags, spflag::obj)        ? TARG_MOVABLE_OBJECT :</a>
<a name="ln1322">                                                   TARG_HOSTILE;</a>
<a name="ln1323"> </a>
<a name="ln1324">        const targeting_type dir =</a>
<a name="ln1325">             testbits(flags, spflag::target) ? DIR_TARGET :</a>
<a name="ln1326">             testbits(flags, spflag::dir)    ? DIR_DIR    :</a>
<a name="ln1327">                                              DIR_NONE;</a>
<a name="ln1328"> </a>
<a name="ln1329">        const char *prompt = get_spell_target_prompt(spell);</a>
<a name="ln1330">        if (dir == DIR_DIR)</a>
<a name="ln1331">            mprf(MSGCH_PROMPT, &quot;%s&quot;, prompt ? prompt : &quot;Which direction?&quot;);</a>
<a name="ln1332"> </a>
<a name="ln1333">        const bool needs_path = !testbits(flags, spflag::target)</a>
<a name="ln1334">                                // Apportation must be spflag::target, since a</a>
<a name="ln1335">                                // shift-direction makes no sense for it, but</a>
<a name="ln1336">                                // it nevertheless requires line-of-fire.</a>
<a name="ln1337">                                || spell == SPELL_APPORTATION;</a>
<a name="ln1338"> </a>
<a name="ln1339">        unique_ptr&lt;targeter&gt; hitfunc = _spell_targeter(spell, powc, range);</a>
<a name="ln1340"> </a>
<a name="ln1341">        // Add success chance to targeted spells checking monster MR</a>
<a name="ln1342">        const bool mr_check = testbits(flags, spflag::MR_check)</a>
<a name="ln1343">                              &amp;&amp; testbits(flags, spflag::dir_or_target)</a>
<a name="ln1344">                              &amp;&amp; !testbits(flags, spflag::helpful);</a>
<a name="ln1345">        desc_filter additional_desc = nullptr;</a>
<a name="ln1346">        if (mr_check)</a>
<a name="ln1347">        {</a>
<a name="ln1348">            const zap_type zap = spell_to_zap(spell);</a>
<a name="ln1349">            const int eff_pow = zap == NUM_ZAPS ? powc</a>
<a name="ln1350">                                                : zap_ench_power(zap, powc,</a>
<a name="ln1351">                                                                 false);</a>
<a name="ln1352">            additional_desc = bind(desc_success_chance, placeholders::_1,</a>
<a name="ln1353">                                   eff_pow, evoked_item, hitfunc.get());</a>
<a name="ln1354">        }</a>
<a name="ln1355"> </a>
<a name="ln1356">        string title = make_stringf(&quot;Aiming: &lt;w&gt;%s&lt;/w&gt;&quot;, spell_title(spell));</a>
<a name="ln1357">        if (allow_fail)</a>
<a name="ln1358">        {</a>
<a name="ln1359">            title += make_stringf(&quot; &lt;lightgrey&gt;(%s)&lt;/lightgrey&gt;&quot;,</a>
<a name="ln1360">                _spell_failure_rate_description(spell).c_str());</a>
<a name="ln1361">        }</a>
<a name="ln1362"> </a>
<a name="ln1363">        direction_chooser_args args;</a>
<a name="ln1364">        args.hitfunc = hitfunc.get();</a>
<a name="ln1365">        args.restricts = dir;</a>
<a name="ln1366">        args.mode = targ;</a>
<a name="ln1367">        args.range = range;</a>
<a name="ln1368">        args.needs_path = needs_path;</a>
<a name="ln1369">        args.target_prefix = prompt;</a>
<a name="ln1370">        args.top_prompt = title;</a>
<a name="ln1371">        if (hitfunc &amp;&amp; hitfunc-&gt;can_affect_walls())</a>
<a name="ln1372">        {</a>
<a name="ln1373">            args.show_floor_desc = true;</a>
<a name="ln1374">            args.show_boring_feats = false; // don't show &quot;The floor.&quot;</a>
<a name="ln1375">        }</a>
<a name="ln1376">        if (testbits(flags, spflag::not_self))</a>
<a name="ln1377">            args.self = confirm_prompt_type::cancel;</a>
<a name="ln1378">        else</a>
<a name="ln1379">            args.self = confirm_prompt_type::none;</a>
<a name="ln1380">        args.get_desc_func = additional_desc;</a>
<a name="ln1381">        if (!spell_direction(spd, beam, &amp;args))</a>
<a name="ln1382">            return spret::abort;</a>
<a name="ln1383"> </a>
<a name="ln1384">        if (testbits(flags, spflag::not_self) &amp;&amp; spd.isMe())</a>
<a name="ln1385">        {</a>
<a name="ln1386">            if (spell == SPELL_TELEPORT_OTHER)</a>
<a name="ln1387">                mpr(&quot;Sorry, this spell works on others only.&quot;);</a>
<a name="ln1388">            else</a>
<a name="ln1389">                canned_msg(MSG_UNTHINKING_ACT);</a>
<a name="ln1390"> </a>
<a name="ln1391">            return spret::abort;</a>
<a name="ln1392">        }</a>
<a name="ln1393"> </a>
<a name="ln1394">        if (spd.isMe() &amp;&amp; spell == SPELL_INVISIBILITY &amp;&amp; !invis_allowed())</a>
<a name="ln1395">            return spret::abort;</a>
<a name="ln1396">    }</a>
<a name="ln1397"> </a>
<a name="ln1398">    if (evoked_item)</a>
<a name="ln1399">    {</a>
<a name="ln1400">#if TAG_MAJOR_VERSION == 34</a>
<a name="ln1401">        const int surge = pakellas_surge_devices();</a>
<a name="ln1402">#else</a>
<a name="ln1403">        const int surge = 0;</a>
<a name="ln1404">#endif</a>
<a name="ln1405">        powc = player_adjust_evoc_power(powc, surge);</a>
<a name="ln1406">#if TAG_MAJOR_VERSION == 34</a>
<a name="ln1407">        int mp_cost_of_wand = evoked_item-&gt;base_type == OBJ_WANDS</a>
<a name="ln1408">                              ? wand_mp_cost() : 0;</a>
<a name="ln1409">        surge_power_wand(mp_cost_of_wand + surge * 3);</a>
<a name="ln1410">#endif</a>
<a name="ln1411">    }</a>
<a name="ln1412">#if TAG_MAJOR_VERSION == 34</a>
<a name="ln1413">    else if (allow_fail)</a>
<a name="ln1414">        surge_power(_spell_enhancement(spell));</a>
<a name="ln1415">#endif</a>
<a name="ln1416">    // Enhancers only matter for calc_spell_power() and raw_spell_fail().</a>
<a name="ln1417">    // Not sure about this: is it flavour or misleading? (jpeg)</a>
<a name="ln1418"> </a>
<a name="ln1419">    const god_type god =</a>
<a name="ln1420">        (crawl_state.is_god_acting()) ? crawl_state.which_god_acting()</a>
<a name="ln1421">                                      : GOD_NO_GOD;</a>
<a name="ln1422"> </a>
<a name="ln1423">    int fail = 0;</a>
<a name="ln1424">#if TAG_MAJOR_VERSION == 34</a>
<a name="ln1425">    bool antimagic = false; // lost time but no other penalty</a>
<a name="ln1426"> </a>
<a name="ln1427">    if (allow_fail &amp;&amp; you.duration[DUR_ANTIMAGIC]</a>
<a name="ln1428">        &amp;&amp; x_chance_in_y(you.duration[DUR_ANTIMAGIC] / 3, you.hp_max))</a>
<a name="ln1429">    {</a>
<a name="ln1430">        mpr(&quot;You fail to access your magic.&quot;);</a>
<a name="ln1431">        fail = antimagic = true;</a>
<a name="ln1432">    }</a>
<a name="ln1433">    else</a>
<a name="ln1434">#endif</a>
<a name="ln1435">    if (evoked_item &amp;&amp; evoked_item-&gt;charges == 0)</a>
<a name="ln1436">        return spret::fail;</a>
<a name="ln1437">    else if (allow_fail)</a>
<a name="ln1438">    {</a>
<a name="ln1439">        int spfl = random2avg(100, 3);</a>
<a name="ln1440"> </a>
<a name="ln1441">        if (!you_worship(GOD_SIF_MUNA)</a>
<a name="ln1442">            &amp;&amp; you.penance[GOD_SIF_MUNA] &amp;&amp; one_chance_in(20))</a>
<a name="ln1443">        {</a>
<a name="ln1444">            god_speaks(GOD_SIF_MUNA, &quot;You feel a surge of divine spite.&quot;);</a>
<a name="ln1445"> </a>
<a name="ln1446">            // This will cause failure and increase the miscast effect.</a>
<a name="ln1447">            spfl = -you.penance[GOD_SIF_MUNA];</a>
<a name="ln1448">        }</a>
<a name="ln1449">        else if (spell_typematch(spell, spschool::necromancy)</a>
<a name="ln1450">                 &amp;&amp; !you_worship(GOD_KIKUBAAQUDGHA)</a>
<a name="ln1451">                 &amp;&amp; you.penance[GOD_KIKUBAAQUDGHA]</a>
<a name="ln1452">                 &amp;&amp; one_chance_in(20))</a>
<a name="ln1453">        {</a>
<a name="ln1454">            // And you thought you'd Necromutate your way out of penance...</a>
<a name="ln1455">            simple_god_message(&quot; does not allow the disloyal to dabble in &quot;</a>
<a name="ln1456">                               &quot;death!&quot;, GOD_KIKUBAAQUDGHA);</a>
<a name="ln1457"> </a>
<a name="ln1458">            // The spell still goes through, but you get a miscast anyway.</a>
<a name="ln1459">            miscast_effect(you, nullptr,</a>
<a name="ln1460">                           {miscast_source::god, GOD_KIKUBAAQUDGHA},</a>
<a name="ln1461">                           spschool::necromancy,</a>
<a name="ln1462">                           spell_difficulty(spell),</a>
<a name="ln1463">                           you.experience_level,</a>
<a name="ln1464">                           &quot;the malice of Kikubaaqudgha&quot;);</a>
<a name="ln1465">        }</a>
<a name="ln1466">        else if (vehumet_supports_spell(spell)</a>
<a name="ln1467">                 &amp;&amp; !you_worship(GOD_VEHUMET)</a>
<a name="ln1468">                 &amp;&amp; you.penance[GOD_VEHUMET]</a>
<a name="ln1469">                 &amp;&amp; one_chance_in(20))</a>
<a name="ln1470">        {</a>
<a name="ln1471">            // And you thought you'd Fire Storm your way out of penance...</a>
<a name="ln1472">            simple_god_message(&quot; does not allow the disloyal to dabble in &quot;</a>
<a name="ln1473">                               &quot;destruction!&quot;, GOD_VEHUMET);</a>
<a name="ln1474"> </a>
<a name="ln1475">            // The spell still goes through, but you get a miscast anyway.</a>
<a name="ln1476">            miscast_effect(you, nullptr, {miscast_source::god, GOD_VEHUMET},</a>
<a name="ln1477">                           spschool::conjuration,</a>
<a name="ln1478">                           spell_difficulty(spell),</a>
<a name="ln1479">                           you.experience_level,</a>
<a name="ln1480">                           &quot;the malice of Vehumet&quot;);</a>
<a name="ln1481">        }</a>
<a name="ln1482"> </a>
<a name="ln1483">        const int spfail_chance = raw_spell_fail(spell);</a>
<a name="ln1484"> </a>
<a name="ln1485">        if (spfl &lt; spfail_chance)</a>
<a name="ln1486">            fail = spfail_chance - spfl;</a>
<a name="ln1487">    }</a>
<a name="ln1488"> </a>
<a name="ln1489">    dprf(&quot;Spell #%d, power=%d&quot;, spell, powc);</a>
<a name="ln1490"> </a>
<a name="ln1491">    // Have to set aim first, in case the spellcast kills its first target</a>
<a name="ln1492">    if (you.props.exists(&quot;battlesphere&quot;) &amp;&amp; allow_fail)</a>
<a name="ln1493">        aim_battlesphere(&amp;you, spell, powc, beam);</a>
<a name="ln1494"> </a>
<a name="ln1495">    const auto orig_target = monster_at(beam.target);</a>
<a name="ln1496">    const bool self_target = you.pos() == beam.target;</a>
<a name="ln1497">    const bool had_tele = orig_target &amp;&amp; orig_target-&gt;has_ench(ENCH_TP);</a>
<a name="ln1498"> </a>
<a name="ln1499">    spret cast_result = _do_cast(spell, powc, spd, beam, god, fail);</a>
<a name="ln1500"> </a>
<a name="ln1501">    switch (cast_result)</a>
<a name="ln1502">    {</a>
<a name="ln1503">    case spret::success:</a>
<a name="ln1504">    {</a>
<a name="ln1505">        if (you.props.exists(&quot;battlesphere&quot;) &amp;&amp; allow_fail)</a>
<a name="ln1506">            trigger_battlesphere(&amp;you, beam);</a>
<a name="ln1507"> </a>
<a name="ln1508">        const auto victim = monster_at(beam.target);</a>
<a name="ln1509">        if (will_have_passive(passive_t::shadow_spells)</a>
<a name="ln1510">            &amp;&amp; allow_fail</a>
<a name="ln1511">            &amp;&amp; !god_hates_spell(spell, you.religion, !allow_fail)</a>
<a name="ln1512">            &amp;&amp; (flags &amp; spflag::targeting_mask)</a>
<a name="ln1513">            &amp;&amp; !(flags &amp; spflag::neutral)</a>
<a name="ln1514">            &amp;&amp; (beam.is_enchantment()</a>
<a name="ln1515">                || battlesphere_can_mirror(spell))</a>
<a name="ln1516">            // Must have a target, but that can't be the player.</a>
<a name="ln1517">            &amp;&amp; !self_target</a>
<a name="ln1518">            &amp;&amp; orig_target</a>
<a name="ln1519">            // For teleport other, only mimic if the spell hit who we</a>
<a name="ln1520">            // originally targeted and if we failed to change the target's</a>
<a name="ln1521">            // teleport status. This way the mimic won't just undo the effect</a>
<a name="ln1522">            // of a successful cast.</a>
<a name="ln1523">            &amp;&amp; (spell != SPELL_TELEPORT_OTHER</a>
<a name="ln1524">                || (orig_target == victim</a>
<a name="ln1525">                    &amp;&amp; had_tele == victim-&gt;has_ench(ENCH_TP))))</a>
<a name="ln1526">        {</a>
<a name="ln1527">            dithmenos_shadow_spell(&amp;beam, spell);</a>
<a name="ln1528">        }</a>
<a name="ln1529">        _spellcasting_side_effects(spell, god, !allow_fail);</a>
<a name="ln1530">        return spret::success;</a>
<a name="ln1531">    }</a>
<a name="ln1532">    case spret::fail:</a>
<a name="ln1533">    {</a>
<a name="ln1534">#if TAG_MAJOR_VERSION == 34</a>
<a name="ln1535">        if (antimagic)</a>
<a name="ln1536">            return spret::fail;</a>
<a name="ln1537">#endif</a>
<a name="ln1538"> </a>
<a name="ln1539">        mprf(&quot;You miscast %s.&quot;, spell_title(spell));</a>
<a name="ln1540">        flush_input_buffer(FLUSH_ON_FAILURE);</a>
<a name="ln1541">        learned_something_new(HINT_SPELL_MISCAST);</a>
<a name="ln1542">        miscast_effect(spell, fail);</a>
<a name="ln1543"> </a>
<a name="ln1544">        return spret::fail;</a>
<a name="ln1545">    }</a>
<a name="ln1546"> </a>
<a name="ln1547">    case spret::abort:</a>
<a name="ln1548">        return spret::abort;</a>
<a name="ln1549"> </a>
<a name="ln1550">    case spret::none:</a>
<a name="ln1551">#ifdef WIZARD</a>
<a name="ln1552">        if (you.wizard &amp;&amp; !allow_fail &amp;&amp; is_valid_spell(spell)</a>
<a name="ln1553">            &amp;&amp; (flags &amp; spflag::monster))</a>
<a name="ln1554">        {</a>
<a name="ln1555">            _try_monster_cast(spell, powc, spd, beam);</a>
<a name="ln1556">            return spret::success;</a>
<a name="ln1557">        }</a>
<a name="ln1558">#endif</a>
<a name="ln1559"> </a>
<a name="ln1560">        if (is_valid_spell(spell))</a>
<a name="ln1561">        {</a>
<a name="ln1562">            mprf(MSGCH_ERROR, &quot;Spell '%s' is not a player castable spell.&quot;,</a>
<a name="ln1563">                 spell_title(spell));</a>
<a name="ln1564">        }</a>
<a name="ln1565">        else</a>
<a name="ln1566">            mprf(MSGCH_ERROR, &quot;Invalid spell!&quot;);</a>
<a name="ln1567"> </a>
<a name="ln1568">        return spret::abort;</a>
<a name="ln1569">    }</a>
<a name="ln1570"> </a>
<a name="ln1571">    return spret::success;</a>
<a name="ln1572">}</a>
<a name="ln1573"> </a>
<a name="ln1574">// Returns spret::success, spret::abort, spret::fail</a>
<a name="ln1575">// or spret::none (not a player spell).</a>
<a name="ln1576">static spret _do_cast(spell_type spell, int powc, const dist&amp; spd,</a>
<a name="ln1577">                           bolt&amp; beam, god_type god, bool fail)</a>
<a name="ln1578">{</a>
<a name="ln1579">    const coord_def target = spd.isTarget ? beam.target : you.pos() + spd.delta;</a>
<a name="ln1580">    if (spell == SPELL_FREEZE || spell == SPELL_VAMPIRIC_DRAINING)</a>
<a name="ln1581">    {</a>
<a name="ln1582">        if (!adjacent(you.pos(), target))</a>
<a name="ln1583">            return spret::abort;</a>
<a name="ln1584">    }</a>
<a name="ln1585"> </a>
<a name="ln1586">    switch (spell)</a>
<a name="ln1587">    {</a>
<a name="ln1588">    case SPELL_FREEZE:</a>
<a name="ln1589">        return cast_freeze(powc, monster_at(target), fail);</a>
<a name="ln1590"> </a>
<a name="ln1591">    case SPELL_SANDBLAST:</a>
<a name="ln1592">        return cast_sandblast(powc, beam, fail);</a>
<a name="ln1593"> </a>
<a name="ln1594">    case SPELL_VAMPIRIC_DRAINING:</a>
<a name="ln1595">        return vampiric_drain(powc, monster_at(target), fail);</a>
<a name="ln1596"> </a>
<a name="ln1597">    case SPELL_IOOD:</a>
<a name="ln1598">        return cast_iood(&amp;you, powc, &amp;beam, 0, 0, MHITNOT, fail);</a>
<a name="ln1599"> </a>
<a name="ln1600">    // Clouds and explosions.</a>
<a name="ln1601">    case SPELL_POISONOUS_CLOUD:</a>
<a name="ln1602">    case SPELL_HOLY_BREATH:</a>
<a name="ln1603">    case SPELL_FREEZING_CLOUD:</a>
<a name="ln1604">        return cast_big_c(powc, spell, &amp;you, beam, fail);</a>
<a name="ln1605"> </a>
<a name="ln1606">    case SPELL_FIRE_STORM:</a>
<a name="ln1607">        return cast_fire_storm(powc, beam, fail);</a>
<a name="ln1608"> </a>
<a name="ln1609">    // Demonspawn ability, no failure.</a>
<a name="ln1610">    case SPELL_CALL_DOWN_DAMNATION:</a>
<a name="ln1611">        return cast_smitey_damnation(powc, beam) ? spret::success : spret::abort;</a>
<a name="ln1612"> </a>
<a name="ln1613">    // LOS spells</a>
<a name="ln1614"> </a>
<a name="ln1615">    // Beogh ability, no failure.</a>
<a name="ln1616">    case SPELL_SMITING:</a>
<a name="ln1617">        return cast_smiting(powc, monster_at(target)) ? spret::success</a>
<a name="ln1618">                                                      : spret::abort;</a>
<a name="ln1619"> </a>
<a name="ln1620">    case SPELL_AIRSTRIKE:</a>
<a name="ln1621">        return cast_airstrike(powc, spd, fail);</a>
<a name="ln1622"> </a>
<a name="ln1623">    case SPELL_LRD:</a>
<a name="ln1624">        return cast_fragmentation(powc, &amp;you, spd.target, fail);</a>
<a name="ln1625"> </a>
<a name="ln1626">    case SPELL_GRAVITAS:</a>
<a name="ln1627">        return cast_gravitas(powc, beam.target, fail);</a>
<a name="ln1628"> </a>
<a name="ln1629">    // other effects</a>
<a name="ln1630">    case SPELL_DISCHARGE:</a>
<a name="ln1631">        return cast_discharge(powc, you, fail);</a>
<a name="ln1632"> </a>
<a name="ln1633">    case SPELL_CHAIN_LIGHTNING:</a>
<a name="ln1634">        return cast_chain_spell(SPELL_CHAIN_LIGHTNING, powc, &amp;you, fail);</a>
<a name="ln1635"> </a>
<a name="ln1636">    case SPELL_DISPERSAL:</a>
<a name="ln1637">        return cast_dispersal(powc, fail);</a>
<a name="ln1638"> </a>
<a name="ln1639">    case SPELL_SHATTER:</a>
<a name="ln1640">        return cast_shatter(powc, fail);</a>
<a name="ln1641"> </a>
<a name="ln1642">    case SPELL_IRRADIATE:</a>
<a name="ln1643">        return cast_irradiate(powc, &amp;you, fail);</a>
<a name="ln1644"> </a>
<a name="ln1645">    case SPELL_LEDAS_LIQUEFACTION:</a>
<a name="ln1646">        return cast_liquefaction(powc, fail);</a>
<a name="ln1647"> </a>
<a name="ln1648">    case SPELL_OZOCUBUS_REFRIGERATION:</a>
<a name="ln1649">        return fire_los_attack_spell(spell, powc, &amp;you, fail);</a>
<a name="ln1650"> </a>
<a name="ln1651">    case SPELL_OLGREBS_TOXIC_RADIANCE:</a>
<a name="ln1652">        return cast_toxic_radiance(&amp;you, powc, fail);</a>
<a name="ln1653"> </a>
<a name="ln1654">    case SPELL_IGNITE_POISON:</a>
<a name="ln1655">        return cast_ignite_poison(&amp;you, powc, fail);</a>
<a name="ln1656"> </a>
<a name="ln1657">    case SPELL_TORNADO:</a>
<a name="ln1658">        return cast_tornado(powc, fail);</a>
<a name="ln1659"> </a>
<a name="ln1660">    case SPELL_THUNDERBOLT:</a>
<a name="ln1661">        return cast_thunderbolt(&amp;you, powc, target, fail);</a>
<a name="ln1662"> </a>
<a name="ln1663">    case SPELL_DAZZLING_FLASH:</a>
<a name="ln1664">        return cast_dazzling_flash(powc, fail);</a>
<a name="ln1665"> </a>
<a name="ln1666">    case SPELL_CHAIN_OF_CHAOS:</a>
<a name="ln1667">        return cast_chain_spell(SPELL_CHAIN_OF_CHAOS, powc, &amp;you, fail);</a>
<a name="ln1668"> </a>
<a name="ln1669">    case SPELL_CLOUD_CONE:</a>
<a name="ln1670">        return cast_cloud_cone(&amp;you, powc, target, fail);</a>
<a name="ln1671"> </a>
<a name="ln1672">    case SPELL_IGNITION:</a>
<a name="ln1673">        return cast_ignition(&amp;you, powc, fail);</a>
<a name="ln1674"> </a>
<a name="ln1675">    case SPELL_FROZEN_RAMPARTS:</a>
<a name="ln1676">        return cast_frozen_ramparts(powc, fail);</a>
<a name="ln1677"> </a>
<a name="ln1678">    // Summoning spells, and other spells that create new monsters.</a>
<a name="ln1679">    // If a god is making you cast one of these spells, any monsters</a>
<a name="ln1680">    // produced will count as god gifts.</a>
<a name="ln1681">    case SPELL_SUMMON_BUTTERFLIES:</a>
<a name="ln1682">        return cast_summon_butterflies(powc, god, fail);</a>
<a name="ln1683"> </a>
<a name="ln1684">    case SPELL_SUMMON_SMALL_MAMMAL:</a>
<a name="ln1685">        return cast_summon_small_mammal(powc, god, fail);</a>
<a name="ln1686"> </a>
<a name="ln1687">    case SPELL_STICKS_TO_SNAKES:</a>
<a name="ln1688">        return cast_sticks_to_snakes(powc, god, fail);</a>
<a name="ln1689"> </a>
<a name="ln1690">    case SPELL_CALL_CANINE_FAMILIAR:</a>
<a name="ln1691">        return cast_call_canine_familiar(powc, god, fail);</a>
<a name="ln1692"> </a>
<a name="ln1693">    case SPELL_SUMMON_ICE_BEAST:</a>
<a name="ln1694">        return cast_summon_ice_beast(powc, god, fail);</a>
<a name="ln1695"> </a>
<a name="ln1696">    case SPELL_MONSTROUS_MENAGERIE:</a>
<a name="ln1697">        return cast_monstrous_menagerie(&amp;you, powc, god, fail);</a>
<a name="ln1698"> </a>
<a name="ln1699">    case SPELL_SUMMON_DRAGON:</a>
<a name="ln1700">        return cast_summon_dragon(&amp;you, powc, god, fail);</a>
<a name="ln1701"> </a>
<a name="ln1702">    case SPELL_DRAGON_CALL:</a>
<a name="ln1703">        return cast_dragon_call(powc, fail);</a>
<a name="ln1704"> </a>
<a name="ln1705">    case SPELL_SUMMON_HYDRA:</a>
<a name="ln1706">        return cast_summon_hydra(&amp;you, powc, god, fail);</a>
<a name="ln1707"> </a>
<a name="ln1708">    case SPELL_SUMMON_MANA_VIPER:</a>
<a name="ln1709">        return cast_summon_mana_viper(powc, god, fail);</a>
<a name="ln1710"> </a>
<a name="ln1711">    case SPELL_CONJURE_BALL_LIGHTNING:</a>
<a name="ln1712">        return cast_conjure_ball_lightning(powc, god, fail);</a>
<a name="ln1713"> </a>
<a name="ln1714">    case SPELL_SUMMON_LIGHTNING_SPIRE:</a>
<a name="ln1715">        return cast_summon_lightning_spire(powc, god, fail);</a>
<a name="ln1716"> </a>
<a name="ln1717">    case SPELL_SUMMON_GUARDIAN_GOLEM:</a>
<a name="ln1718">        return cast_summon_guardian_golem(powc, god, fail);</a>
<a name="ln1719"> </a>
<a name="ln1720">    case SPELL_CALL_IMP:</a>
<a name="ln1721">        return cast_call_imp(powc, god, fail);</a>
<a name="ln1722"> </a>
<a name="ln1723">    case SPELL_SUMMON_DEMON:</a>
<a name="ln1724">        return cast_summon_demon(powc, god, fail);</a>
<a name="ln1725"> </a>
<a name="ln1726">    case SPELL_SUMMON_GREATER_DEMON:</a>
<a name="ln1727">        return cast_summon_greater_demon(powc, god, fail);</a>
<a name="ln1728"> </a>
<a name="ln1729">    case SPELL_SHADOW_CREATURES:</a>
<a name="ln1730">        return cast_shadow_creatures(spell, god, level_id::current(), fail);</a>
<a name="ln1731"> </a>
<a name="ln1732">    case SPELL_SUMMON_HORRIBLE_THINGS:</a>
<a name="ln1733">        return cast_summon_horrible_things(powc, god, fail);</a>
<a name="ln1734"> </a>
<a name="ln1735">    case SPELL_MALIGN_GATEWAY:</a>
<a name="ln1736">        return cast_malign_gateway(&amp;you, powc, god, fail);</a>
<a name="ln1737"> </a>
<a name="ln1738">    case SPELL_SUMMON_FOREST:</a>
<a name="ln1739">        return cast_summon_forest(&amp;you, powc, god, fail);</a>
<a name="ln1740"> </a>
<a name="ln1741">    case SPELL_ANIMATE_SKELETON:</a>
<a name="ln1742">        return cast_animate_skeleton(god, fail);</a>
<a name="ln1743"> </a>
<a name="ln1744">    case SPELL_ANIMATE_DEAD:</a>
<a name="ln1745">        return cast_animate_dead(powc, god, fail);</a>
<a name="ln1746"> </a>
<a name="ln1747">    case SPELL_SIMULACRUM:</a>
<a name="ln1748">        return cast_simulacrum(powc, god, fail);</a>
<a name="ln1749"> </a>
<a name="ln1750">    case SPELL_HAUNT:</a>
<a name="ln1751">        return cast_haunt(powc, beam.target, god, fail);</a>
<a name="ln1752"> </a>
<a name="ln1753">    case SPELL_DEATH_CHANNEL:</a>
<a name="ln1754">        return cast_death_channel(powc, god, fail);</a>
<a name="ln1755"> </a>
<a name="ln1756">    case SPELL_SPELLFORGED_SERVITOR:</a>
<a name="ln1757">        return cast_spellforged_servitor(powc, god, fail);</a>
<a name="ln1758"> </a>
<a name="ln1759">    case SPELL_SPECTRAL_WEAPON:</a>
<a name="ln1760">        return cast_spectral_weapon(&amp;you, powc, god, fail);</a>
<a name="ln1761"> </a>
<a name="ln1762">    case SPELL_BATTLESPHERE:</a>
<a name="ln1763">        return cast_battlesphere(&amp;you, powc, god, fail);</a>
<a name="ln1764"> </a>
<a name="ln1765">    case SPELL_INFESTATION:</a>
<a name="ln1766">        return cast_infestation(powc, beam, fail);</a>
<a name="ln1767"> </a>
<a name="ln1768">    case SPELL_FOXFIRE:</a>
<a name="ln1769">        return cast_foxfire(powc, god, fail);</a>
<a name="ln1770"> </a>
<a name="ln1771">    case SPELL_NOXIOUS_BOG:</a>
<a name="ln1772">        return cast_noxious_bog(powc, fail);</a>
<a name="ln1773"> </a>
<a name="ln1774">    // Enchantments.</a>
<a name="ln1775">    case SPELL_CONFUSING_TOUCH:</a>
<a name="ln1776">        return cast_confusing_touch(powc, fail);</a>
<a name="ln1777"> </a>
<a name="ln1778">    case SPELL_CAUSE_FEAR:</a>
<a name="ln1779">        return mass_enchantment(ENCH_FEAR, powc, fail);</a>
<a name="ln1780"> </a>
<a name="ln1781">    case SPELL_INTOXICATE:</a>
<a name="ln1782">        return cast_intoxicate(powc, fail);</a>
<a name="ln1783"> </a>
<a name="ln1784">    case SPELL_DISCORD:</a>
<a name="ln1785">        return mass_enchantment(ENCH_INSANE, powc, fail);</a>
<a name="ln1786"> </a>
<a name="ln1787">    case SPELL_ENGLACIATION:</a>
<a name="ln1788">        return cast_englaciation(powc, fail);</a>
<a name="ln1789"> </a>
<a name="ln1790">    case SPELL_AURA_OF_ABJURATION:</a>
<a name="ln1791">        return cast_aura_of_abjuration(powc, fail);</a>
<a name="ln1792"> </a>
<a name="ln1793">    case SPELL_EXCRUCIATING_WOUNDS:</a>
<a name="ln1794">        return cast_excruciating_wounds(powc, fail);</a>
<a name="ln1795"> </a>
<a name="ln1796">    // Transformations.</a>
<a name="ln1797">    case SPELL_BEASTLY_APPENDAGE:</a>
<a name="ln1798">        return cast_transform(powc, transformation::appendage, fail);</a>
<a name="ln1799"> </a>
<a name="ln1800">    case SPELL_BLADE_HANDS:</a>
<a name="ln1801">        return cast_transform(powc, transformation::blade_hands, fail);</a>
<a name="ln1802"> </a>
<a name="ln1803">    case SPELL_SPIDER_FORM:</a>
<a name="ln1804">        return cast_transform(powc, transformation::spider, fail);</a>
<a name="ln1805"> </a>
<a name="ln1806">    case SPELL_STATUE_FORM:</a>
<a name="ln1807">        return cast_transform(powc, transformation::statue, fail);</a>
<a name="ln1808"> </a>
<a name="ln1809">    case SPELL_ICE_FORM:</a>
<a name="ln1810">        return cast_transform(powc, transformation::ice_beast, fail);</a>
<a name="ln1811"> </a>
<a name="ln1812">    case SPELL_HYDRA_FORM:</a>
<a name="ln1813">        return cast_transform(powc, transformation::hydra, fail);</a>
<a name="ln1814"> </a>
<a name="ln1815">    case SPELL_DRAGON_FORM:</a>
<a name="ln1816">        return cast_transform(powc, transformation::dragon, fail);</a>
<a name="ln1817"> </a>
<a name="ln1818">    case SPELL_NECROMUTATION:</a>
<a name="ln1819">        return cast_transform(powc, transformation::lich, fail);</a>
<a name="ln1820"> </a>
<a name="ln1821">    case SPELL_SWIFTNESS:</a>
<a name="ln1822">        return cast_swiftness(powc, fail);</a>
<a name="ln1823"> </a>
<a name="ln1824">    case SPELL_OZOCUBUS_ARMOUR:</a>
<a name="ln1825">        return ice_armour(powc, fail);</a>
<a name="ln1826"> </a>
<a name="ln1827">    case SPELL_SILENCE:</a>
<a name="ln1828">        return cast_silence(powc, fail);</a>
<a name="ln1829"> </a>
<a name="ln1830">    case SPELL_INFUSION:</a>
<a name="ln1831">        return cast_infusion(powc, fail);</a>
<a name="ln1832"> </a>
<a name="ln1833">    case SPELL_SONG_OF_SLAYING:</a>
<a name="ln1834">        return cast_song_of_slaying(powc, fail);</a>
<a name="ln1835"> </a>
<a name="ln1836">    case SPELL_PORTAL_PROJECTILE:</a>
<a name="ln1837">        return cast_portal_projectile(powc, fail);</a>
<a name="ln1838"> </a>
<a name="ln1839">    // other</a>
<a name="ln1840">    case SPELL_BORGNJORS_REVIVIFICATION:</a>
<a name="ln1841">        return cast_revivification(powc, fail);</a>
<a name="ln1842"> </a>
<a name="ln1843">    case SPELL_SUBLIMATION_OF_BLOOD:</a>
<a name="ln1844">        return cast_sublimation_of_blood(powc, fail);</a>
<a name="ln1845"> </a>
<a name="ln1846">    case SPELL_DEATHS_DOOR:</a>
<a name="ln1847">        return cast_deaths_door(powc, fail);</a>
<a name="ln1848"> </a>
<a name="ln1849">    case SPELL_RING_OF_FLAMES:</a>
<a name="ln1850">        return cast_ring_of_flames(powc, fail);</a>
<a name="ln1851"> </a>
<a name="ln1852">    // Escape spells.</a>
<a name="ln1853">    case SPELL_BLINK:</a>
<a name="ln1854">        return cast_blink(fail);</a>
<a name="ln1855"> </a>
<a name="ln1856">    case SPELL_CONTROLLED_BLINK:</a>
<a name="ln1857">        return cast_controlled_blink(fail);</a>
<a name="ln1858"> </a>
<a name="ln1859">    case SPELL_CONJURE_FLAME:</a>
<a name="ln1860">        return conjure_flame(powc, fail);</a>
<a name="ln1861"> </a>
<a name="ln1862">    case SPELL_PASSWALL:</a>
<a name="ln1863">        return cast_passwall(beam.target, powc, fail);</a>
<a name="ln1864"> </a>
<a name="ln1865">    case SPELL_APPORTATION:</a>
<a name="ln1866">        return cast_apportation(powc, beam, fail);</a>
<a name="ln1867"> </a>
<a name="ln1868">    case SPELL_RECALL:</a>
<a name="ln1869">        return cast_recall(fail);</a>
<a name="ln1870"> </a>
<a name="ln1871">    case SPELL_DISJUNCTION:</a>
<a name="ln1872">        return cast_disjunction(powc, fail);</a>
<a name="ln1873"> </a>
<a name="ln1874">    case SPELL_CORPSE_ROT:</a>
<a name="ln1875">        return cast_corpse_rot(fail);</a>
<a name="ln1876"> </a>
<a name="ln1877">    case SPELL_GOLUBRIAS_PASSAGE:</a>
<a name="ln1878">        return cast_golubrias_passage(beam.target, fail);</a>
<a name="ln1879"> </a>
<a name="ln1880">    case SPELL_DARKNESS:</a>
<a name="ln1881">        return cast_darkness(powc, fail);</a>
<a name="ln1882"> </a>
<a name="ln1883">    case SPELL_SHROUD_OF_GOLUBRIA:</a>
<a name="ln1884">        return cast_shroud_of_golubria(powc, fail);</a>
<a name="ln1885"> </a>
<a name="ln1886">    case SPELL_FULMINANT_PRISM:</a>
<a name="ln1887">        return cast_fulminating_prism(&amp;you, powc, beam.target, fail);</a>
<a name="ln1888"> </a>
<a name="ln1889">    case SPELL_SEARING_RAY:</a>
<a name="ln1890">        return cast_searing_ray(powc, beam, fail);</a>
<a name="ln1891"> </a>
<a name="ln1892">    case SPELL_GLACIATE:</a>
<a name="ln1893">        return cast_glaciate(&amp;you, powc, target, fail);</a>
<a name="ln1894"> </a>
<a name="ln1895">    case SPELL_RANDOM_BOLT:</a>
<a name="ln1896">        return cast_random_bolt(powc, beam, fail);</a>
<a name="ln1897"> </a>
<a name="ln1898">    case SPELL_SCATTERSHOT:</a>
<a name="ln1899">        return cast_scattershot(&amp;you, powc, target, fail);</a>
<a name="ln1900"> </a>
<a name="ln1901">    case SPELL_RANDOM_EFFECTS:</a>
<a name="ln1902">        return cast_random_effects(powc, beam, fail);</a>
<a name="ln1903"> </a>
<a name="ln1904">    case SPELL_POISONOUS_VAPOURS:</a>
<a name="ln1905">        return cast_poisonous_vapours(powc, spd, fail);</a>
<a name="ln1906"> </a>
<a name="ln1907">    case SPELL_STARBURST:</a>
<a name="ln1908">        return cast_starburst(powc, fail);</a>
<a name="ln1909"> </a>
<a name="ln1910">    case SPELL_HAILSTORM:</a>
<a name="ln1911">        return cast_hailstorm(powc, fail);</a>
<a name="ln1912"> </a>
<a name="ln1913">    case SPELL_ABSOLUTE_ZERO:</a>
<a name="ln1914">        return cast_absolute_zero(powc, fail);</a>
<a name="ln1915"> </a>
<a name="ln1916">    case SPELL_ISKENDERUNS_MYSTIC_BLAST:</a>
<a name="ln1917">        return cast_imb(powc, fail);</a>
<a name="ln1918"> </a>
<a name="ln1919">    // non-player spells that have a zap, but that shouldn't be called (e.g</a>
<a name="ln1920">    // because they will crash as a player zap).</a>
<a name="ln1921">    case SPELL_DRAIN_LIFE:</a>
<a name="ln1922">        return spret::none;</a>
<a name="ln1923"> </a>
<a name="ln1924">    default:</a>
<a name="ln1925">        if (spell_removed(spell))</a>
<a name="ln1926">        {</a>
<a name="ln1927">            mpr(&quot;Sorry, this spell is gone!&quot;);</a>
<a name="ln1928">            return spret::abort;</a>
<a name="ln1929">        }</a>
<a name="ln1930">        break;</a>
<a name="ln1931">    }</a>
<a name="ln1932"> </a>
<a name="ln1933">    // Finally, try zaps.</a>
<a name="ln1934">    zap_type zap = spell_to_zap(spell);</a>
<a name="ln1935">    if (zap != NUM_ZAPS)</a>
<a name="ln1936">    {</a>
<a name="ln1937">        return zapping(zap, spell_zap_power(spell, powc), beam, true, nullptr,</a>
<a name="ln1938">                       fail);</a>
<a name="ln1939">    }</a>
<a name="ln1940"> </a>
<a name="ln1941">    return spret::none;</a>
<a name="ln1942">}</a>
<a name="ln1943"> </a>
<a name="ln1944">// _tetrahedral_number: returns the nth tetrahedral number.</a>
<a name="ln1945">// This is the number of triples of nonnegative integers with sum &lt; n.</a>
<a name="ln1946">// Called only by get_true_fail_rate.</a>
<a name="ln1947">static int _tetrahedral_number(int n)</a>
<a name="ln1948">{</a>
<a name="ln1949">    return n * (n+1) * (n+2) / 6;</a>
<a name="ln1950">}</a>
<a name="ln1951"> </a>
<a name="ln1952">// get_true_fail_rate: Takes the raw failure to-beat number</a>
<a name="ln1953">// and converts it to the actual chance of failure:</a>
<a name="ln1954">// the probability that random2avg(100,3) &lt; raw_fail.</a>
<a name="ln1955">// Should probably use more constants, though I doubt the spell</a>
<a name="ln1956">// success algorithms will really change *that* much.</a>
<a name="ln1957">// Called only by failure_rate_to_int</a>
<a name="ln1958">static double _get_true_fail_rate(int raw_fail)</a>
<a name="ln1959">{</a>
<a name="ln1960">    // Need 3*random2avg(100,3) = random2(101) + random2(101) + random2(100)</a>
<a name="ln1961">    // to be (strictly) less than 3*raw_fail. Fun with tetrahedral numbers!</a>
<a name="ln1962"> </a>
<a name="ln1963">    // How many possible outcomes, considering all three dice?</a>
<a name="ln1964">    const int outcomes = 101 * 101 * 100;</a>
<a name="ln1965">    const int target = raw_fail * 3;</a>
<a name="ln1966"> </a>
<a name="ln1967">    if (target &lt;= 100)</a>
<a name="ln1968">    {</a>
<a name="ln1969">        // The failures are exactly the triples of nonnegative integers</a>
<a name="ln1970">        // that sum to &lt; target.</a>
<a name="ln1971">        return double(_tetrahedral_number(target)) / outcomes;</a>
<a name="ln1972">    }</a>
<a name="ln1973">    if (target &lt;= 200)</a>
<a name="ln1974">    {</a>
<a name="ln1975">        // Some of the triples that sum to &lt; target would have numbers</a>
<a name="ln1976">        // greater than 100, or a last number greater than 99, so aren't</a>
<a name="ln1977">        // possible outcomes. Apply the principle of inclusion-exclusion</a>
<a name="ln1978">        // by subtracting out these cases. The set of triples with first</a>
<a name="ln1979">        // number &gt; 100 is isomorphic to the set of triples that sum to</a>
<a name="ln1980">        // 101 less; likewise for the second and third numbers (100 less</a>
<a name="ln1981">        // in the last case). Two or more out-of-range numbers would have</a>
<a name="ln1982">        // resulted in a sum of at least 201, so there is no overlap</a>
<a name="ln1983">        // among the three cases we are subtracting.</a>
<a name="ln1984">        return double(_tetrahedral_number(target)</a>
<a name="ln1985">                      - 2 * _tetrahedral_number(target - 101)</a>
<a name="ln1986">                      - _tetrahedral_number(target - 100)) / outcomes;</a>
<a name="ln1987">    }</a>
<a name="ln1988">    // The random2avg distribution is symmetric, so the last interval is</a>
<a name="ln1989">    // essentially the same as the first interval.</a>
<a name="ln1990">    return double(outcomes - _tetrahedral_number(300 - target)) / outcomes;</a>
<a name="ln1991">}</a>
<a name="ln1992"> </a>
<a name="ln1993">const double fail_hp_fraction[] =</a>
<a name="ln1994">{</a>
<a name="ln1995">    .10,</a>
<a name="ln1996">    .30,</a>
<a name="ln1997">    .50,</a>
<a name="ln1998">    .70,</a>
<a name="ln1999">};</a>
<a name="ln2000">/**</a>
<a name="ln2001"> * Compute the maximum miscast damage from the given spell</a>
<a name="ln2002"> *</a>
<a name="ln2003"> * The miscast code uses</a>
<a name="ln2004"> *     dam = div_rand_round(roll_dice(level, level * fail), MISCAST_DIVISOR)</a>
<a name="ln2005"> */</a>
<a name="ln2006">int max_miscast_damage(spell_type spell)</a>
<a name="ln2007">{</a>
<a name="ln2008">    int raw_fail = raw_spell_fail(spell);</a>
<a name="ln2009">    int level = spell_difficulty(spell);</a>
<a name="ln2010"> </a>
<a name="ln2011">    // Impossible to get a damaging miscast</a>
<a name="ln2012">    if (level * level * raw_fail &lt;= MISCAST_THRESHOLD)</a>
<a name="ln2013">        return 0;</a>
<a name="ln2014"> </a>
<a name="ln2015">    return div_round_up(level * (raw_fail + level), MISCAST_DIVISOR);</a>
<a name="ln2016">}</a>
<a name="ln2017"> </a>
<a name="ln2018"> </a>
<a name="ln2019">/**</a>
<a name="ln2020"> * Compute the tier of maximum severity of a miscast</a>
<a name="ln2021"> * @param spell     The spell to be checked.</a>
<a name="ln2022"> *</a>
<a name="ln2023"> * Tiers are defined by the relation between the maximum miscast damage</a>
<a name="ln2024"> * (given a miscast occurs):</a>
<a name="ln2025"> *</a>
<a name="ln2026"> * - safe, no chance of dangerous effect</a>
<a name="ln2027"> * - slightly dangerous, mdam &lt;= 10% mhp</a>
<a name="ln2028"> * - dangerous, mdam &lt;= 30% mhp</a>
<a name="ln2029"> * - quite dangerous, mdam &lt;= 50% mhp</a>
<a name="ln2030"> * - extremely dangerous, mdam &lt;= 70% mhp</a>
<a name="ln2031"> * - potentially lethal, higher mdam</a>
<a name="ln2032"> */</a>
<a name="ln2033">int fail_severity(spell_type spell)</a>
<a name="ln2034">{</a>
<a name="ln2035">    const int raw_fail = raw_spell_fail(spell);</a>
<a name="ln2036">    const int level = spell_difficulty(spell);</a>
<a name="ln2037"> </a>
<a name="ln2038">    // Impossible to get a damaging miscast</a>
<a name="ln2039">    if (level * level * raw_fail &lt;= 150)</a>
<a name="ln2040">        return 0;</a>
<a name="ln2041"> </a>
<a name="ln2042">    const int max_damage = max_miscast_damage(spell);</a>
<a name="ln2043"> </a>
<a name="ln2044">    for (int i = 0; i &lt; 4; ++i)</a>
<a name="ln2045">        if (max_damage &lt;= fail_hp_fraction[i] * get_real_hp(true))</a>
<a name="ln2046">            return i + 1;</a>
<a name="ln2047"> </a>
<a name="ln2048">    return 5;</a>
<a name="ln2049">}</a>
<a name="ln2050"> </a>
<a name="ln2051">const char *fail_severity_adjs[] =</a>
<a name="ln2052">{</a>
<a name="ln2053">    &quot;safe&quot;,</a>
<a name="ln2054">    &quot;mildly dangerous&quot;,</a>
<a name="ln2055">    &quot;dangerous&quot;,</a>
<a name="ln2056">    &quot;quite dangerous&quot;,</a>
<a name="ln2057">    &quot;extremely dangerous&quot;,</a>
<a name="ln2058">    &quot;potentially lethal&quot;,</a>
<a name="ln2059">};</a>
<a name="ln2060">COMPILE_CHECK(ARRAYSZ(fail_severity_adjs) &gt; 3);</a>
<a name="ln2061"> </a>
<a name="ln2062">// Chooses a colour for the failure rate display for a spell. The colour is</a>
<a name="ln2063">// based on the chance of getting a severity &gt;= 2 miscast.</a>
<a name="ln2064">int failure_rate_colour(spell_type spell)</a>
<a name="ln2065">{</a>
<a name="ln2066">    const int severity = fail_severity(spell);</a>
<a name="ln2067">    return severity == 0 ? LIGHTGREY :</a>
<a name="ln2068">           severity == 1 ? WHITE :</a>
<a name="ln2069">           severity == 2 ? YELLOW :</a>
<a name="ln2070">           severity == 3 ? LIGHTRED :</a>
<a name="ln2071">           severity == 4 ? RED</a>
<a name="ln2072">                         : MAGENTA;</a>
<a name="ln2073">}</a>
<a name="ln2074"> </a>
<a name="ln2075">//Converts the raw failure rate into a number to be displayed.</a>
<a name="ln2076">int failure_rate_to_int(int fail)</a>
<a name="ln2077">{</a>
<a name="ln2078">    if (fail &lt;= 0)</a>
<a name="ln2079">        return 0;</a>
<a name="ln2080">    else if (fail &gt;= 100)</a>
<a name="ln2081">        return (fail + 100)/2;</a>
<a name="ln2082">    else</a>
<a name="ln2083">        return max(1, (int) (100 * _get_true_fail_rate(fail)));</a>
<a name="ln2084">}</a>
<a name="ln2085"> </a>
<a name="ln2086">/**</a>
<a name="ln2087"> * Convert the given failure rate into a percent, and return it as a string.</a>
<a name="ln2088"> *</a>
<a name="ln2089"> * @param fail      A raw failure rate (not a percent!)</a>
<a name="ln2090"> * @return          E.g. &quot;79%&quot;.</a>
<a name="ln2091"> */</a>
<a name="ln2092">string failure_rate_to_string(int fail)</a>
<a name="ln2093">{</a>
<a name="ln2094">    return make_stringf(&quot;%d%%&quot;, failure_rate_to_int(fail));</a>
<a name="ln2095">}</a>
<a name="ln2096"> </a>
<a name="ln2097">string spell_hunger_string(spell_type spell)</a>
<a name="ln2098">{</a>
<a name="ln2099">    return hunger_cost_string(spell_hunger(spell));</a>
<a name="ln2100">}</a>
<a name="ln2101"> </a>
<a name="ln2102">string spell_failure_rate_string(spell_type spell)</a>
<a name="ln2103">{</a>
<a name="ln2104">    const string failure = failure_rate_to_string(raw_spell_fail(spell));</a>
<a name="ln2105">    const string colour = colour_to_str(failure_rate_colour(spell));</a>
<a name="ln2106">    return make_stringf(&quot;&lt;%s&gt;%s&lt;/%s&gt;&quot;,</a>
<a name="ln2107">            colour.c_str(), failure.c_str(), colour.c_str());</a>
<a name="ln2108">}</a>
<a name="ln2109"> </a>
<a name="ln2110">static string _spell_failure_rate_description(spell_type spell)</a>
<a name="ln2111">{</a>
<a name="ln2112">    const string failure = failure_rate_to_string(raw_spell_fail(spell));</a>
<a name="ln2113">    const char *severity_adj = fail_severity_adjs[fail_severity(spell)];</a>
<a name="ln2114">    const string colour = colour_to_str(failure_rate_colour(spell));</a>
<a name="ln2115">    const char *col = colour.c_str();</a>
<a name="ln2116"> </a>
<a name="ln2117">    return make_stringf(&quot;&lt;%s&gt;%s&lt;/%s&gt;; &lt;%s&gt;%s&lt;/%s&gt; risk of failure&quot;,</a>
<a name="ln2118">            col, severity_adj, col, col, failure.c_str(), col);</a>
<a name="ln2119">}</a>
<a name="ln2120"> </a>
<a name="ln2121">string spell_noise_string(spell_type spell, int chop_wiz_display_width)</a>
<a name="ln2122">{</a>
<a name="ln2123">    const int casting_noise = spell_noise(spell);</a>
<a name="ln2124">    int effect_noise = spell_effect_noise(spell, false);</a>
<a name="ln2125">    zap_type zap = spell_to_zap(spell);</a>
<a name="ln2126">    if (effect_noise == 0 &amp;&amp; zap != NUM_ZAPS)</a>
<a name="ln2127">    {</a>
<a name="ln2128">        bolt beem;</a>
<a name="ln2129">        zappy(zap, 0, false, beem);</a>
<a name="ln2130">        effect_noise = beem.loudness;</a>
<a name="ln2131">    }</a>
<a name="ln2132"> </a>
<a name="ln2133">    // A typical amount of noise.</a>
<a name="ln2134">    if (spell == SPELL_TORNADO)</a>
<a name="ln2135">        effect_noise = 15;</a>
<a name="ln2136"> </a>
<a name="ln2137">    const int noise = max(casting_noise, effect_noise);</a>
<a name="ln2138"> </a>
<a name="ln2139">    const char* noise_descriptions[] =</a>
<a name="ln2140">    {</a>
<a name="ln2141">        &quot;Silent&quot;, &quot;Almost silent&quot;, &quot;Quiet&quot;, &quot;A bit loud&quot;, &quot;Loud&quot;, &quot;Very loud&quot;,</a>
<a name="ln2142">        &quot;Extremely loud&quot;, &quot;Deafening&quot;</a>
<a name="ln2143">    };</a>
<a name="ln2144"> </a>
<a name="ln2145">    const int breakpoints[] = { 1, 2, 4, 8, 15, 20, 30 };</a>
<a name="ln2146">    COMPILE_CHECK(ARRAYSZ(noise_descriptions) == 1 + ARRAYSZ(breakpoints));</a>
<a name="ln2147"> </a>
<a name="ln2148">    const char* desc = noise_descriptions[breakpoint_rank(noise, breakpoints,</a>
<a name="ln2149">                                                ARRAYSZ(breakpoints))];</a>
<a name="ln2150"> </a>
<a name="ln2151">#ifdef WIZARD</a>
<a name="ln2152">    if (you.wizard)</a>
<a name="ln2153">    {</a>
<a name="ln2154">        if (chop_wiz_display_width &gt; 0)</a>
<a name="ln2155">        {</a>
<a name="ln2156">            ostringstream shortdesc;</a>
<a name="ln2157">            shortdesc &lt;&lt; chop_string(desc, chop_wiz_display_width)</a>
<a name="ln2158">                      &lt;&lt; &quot;(&quot; &lt;&lt; to_string(noise) &lt;&lt; &quot;)&quot;;</a>
<a name="ln2159">            return shortdesc.str();</a>
<a name="ln2160">        }</a>
<a name="ln2161">        else</a>
<a name="ln2162">            return make_stringf(&quot;%s (%d)&quot;, desc, noise);</a>
<a name="ln2163">    }</a>
<a name="ln2164">    else</a>
<a name="ln2165">#endif</a>
<a name="ln2166">        return desc;</a>
<a name="ln2167">}</a>
<a name="ln2168"> </a>
<a name="ln2169">int power_to_barcount(int power)</a>
<a name="ln2170">{</a>
<a name="ln2171">    if (power == -1)</a>
<a name="ln2172">        return -1;</a>
<a name="ln2173"> </a>
<a name="ln2174">    const int breakpoints[] = { 10, 15, 25, 35, 50, 75, 100, 150, 200 };</a>
<a name="ln2175">    return breakpoint_rank(power, breakpoints, ARRAYSZ(breakpoints)) + 1;</a>
<a name="ln2176">}</a>
<a name="ln2177"> </a>
<a name="ln2178">static int _spell_power_bars(spell_type spell)</a>
<a name="ln2179">{</a>
<a name="ln2180">    const int cap = spell_power_cap(spell);</a>
<a name="ln2181">    if (cap == 0)</a>
<a name="ln2182">        return -1;</a>
<a name="ln2183">    const int power = min(calc_spell_power(spell, true, false, false), cap);</a>
<a name="ln2184">    return power_to_barcount(power);</a>
<a name="ln2185">}</a>
<a name="ln2186"> </a>
<a name="ln2187">#ifdef WIZARD</a>
<a name="ln2188">static string _wizard_spell_power_numeric_string(spell_type spell)</a>
<a name="ln2189">{</a>
<a name="ln2190">    const int cap = spell_power_cap(spell);</a>
<a name="ln2191">    if (cap == 0)</a>
<a name="ln2192">        return &quot;N/A&quot;;</a>
<a name="ln2193">    const int power = min(calc_spell_power(spell, true, false, false), cap);</a>
<a name="ln2194">    return make_stringf(&quot;%d (%d)&quot;, power, cap);</a>
<a name="ln2195">}</a>
<a name="ln2196">#endif</a>
<a name="ln2197"> </a>
<a name="ln2198">string spell_power_string(spell_type spell)</a>
<a name="ln2199">{</a>
<a name="ln2200">#ifdef WIZARD</a>
<a name="ln2201">    if (you.wizard)</a>
<a name="ln2202">        return _wizard_spell_power_numeric_string(spell);</a>
<a name="ln2203">#endif</a>
<a name="ln2204"> </a>
<a name="ln2205">    const int numbars = _spell_power_bars(spell);</a>
<a name="ln2206">    const int capbars = power_to_barcount(spell_power_cap(spell));</a>
<a name="ln2207">    ASSERT(numbars &lt;= capbars);</a>
<a name="ln2208">    if (numbars &lt; 0)</a>
<a name="ln2209">        return &quot;N/A&quot;;</a>
<a name="ln2210">    else</a>
<a name="ln2211">        return string(numbars, '#') + string(capbars - numbars, '.');</a>
<a name="ln2212">}</a>
<a name="ln2213"> </a>
<a name="ln2214">int calc_spell_range(spell_type spell, int power, bool allow_bonus)</a>
<a name="ln2215">{</a>
<a name="ln2216">    if (power == 0)</a>
<a name="ln2217">        power = calc_spell_power(spell, true, false, false);</a>
<a name="ln2218">    const int range = spell_range(spell, power, allow_bonus);</a>
<a name="ln2219"> </a>
<a name="ln2220">    return range;</a>
<a name="ln2221">}</a>
<a name="ln2222"> </a>
<a name="ln2223">/**</a>
<a name="ln2224"> * Give a string visually describing a given spell's range, as cast by the</a>
<a name="ln2225"> * player.</a>
<a name="ln2226"> *</a>
<a name="ln2227"> * @param spell     The spell in question.</a>
<a name="ln2228"> * @return          Something like &quot;@--&gt;..&quot;</a>
<a name="ln2229"> */</a>
<a name="ln2230">string spell_range_string(spell_type spell)</a>
<a name="ln2231">{</a>
<a name="ln2232">    if (spell == SPELL_HAILSTORM)</a>
<a name="ln2233">        return &quot;@.-&gt;&quot;; // Special case: hailstorm is a ring</a>
<a name="ln2234"> </a>
<a name="ln2235">    const int cap      = spell_power_cap(spell);</a>
<a name="ln2236">    const int range    = calc_spell_range(spell, 0);</a>
<a name="ln2237">    const int maxrange = spell_range(spell, cap);</a>
<a name="ln2238"> </a>
<a name="ln2239">    return range_string(range, maxrange, '@');</a>
<a name="ln2240">}</a>
<a name="ln2241"> </a>
<a name="ln2242">/**</a>
<a name="ln2243"> * Give a string visually describing a given spell's range.</a>
<a name="ln2244"> *</a>
<a name="ln2245"> * E.g., for a spell of fixed range 1 (melee), &quot;@&gt;&quot;</a>
<a name="ln2246"> *       for a spell of range 3, max range 5, &quot;@--&gt;..&quot;</a>
<a name="ln2247"> *</a>
<a name="ln2248"> * @param range         The current range of the spell.</a>
<a name="ln2249"> * @param maxrange      The range the spell would have at max power.</a>
<a name="ln2250"> * @param caster_char   The character used to represent the caster.</a>
<a name="ln2251"> *                      Usually @ for the player.</a>
<a name="ln2252"> * @return              See above.</a>
<a name="ln2253"> */</a>
<a name="ln2254">string range_string(int range, int maxrange, char32_t caster_char)</a>
<a name="ln2255">{</a>
<a name="ln2256">    if (range &lt;= 0)</a>
<a name="ln2257">        return &quot;N/A&quot;;</a>
<a name="ln2258"> </a>
<a name="ln2259">    return stringize_glyph(caster_char) + string(range - 1, '-')</a>
<a name="ln2260">           + string(&quot;&gt;&quot;) + string(maxrange - range, '.');</a>
<a name="ln2261">}</a>
<a name="ln2262"> </a>
<a name="ln2263">string spell_schools_string(spell_type spell)</a>
<a name="ln2264">{</a>
<a name="ln2265">    string desc;</a>
<a name="ln2266"> </a>
<a name="ln2267">    bool already = false;</a>
<a name="ln2268">    for (const auto bit : spschools_type::range())</a>
<a name="ln2269">    {</a>
<a name="ln2270">        if (spell_typematch(spell, bit))</a>
<a name="ln2271">        {</a>
<a name="ln2272">            if (already)</a>
<a name="ln2273">                desc += &quot;/&quot;;</a>
<a name="ln2274">            desc += spelltype_long_name(bit);</a>
<a name="ln2275">            already = true;</a>
<a name="ln2276">        }</a>
<a name="ln2277">    }</a>
<a name="ln2278"> </a>
<a name="ln2279">    return desc;</a>
<a name="ln2280">}</a>
<a name="ln2281"> </a>
<a name="ln2282">void spell_skills(spell_type spell, set&lt;skill_type&gt; &amp;skills)</a>
<a name="ln2283">{</a>
<a name="ln2284">    const spschools_type disciplines = get_spell_disciplines(spell);</a>
<a name="ln2285">    for (const auto bit : spschools_type::range())</a>
<a name="ln2286">        if (disciplines &amp; bit)</a>
<a name="ln2287">            skills.insert(spell_type2skill(bit));</a>
<a name="ln2288">}</a>
<a name="ln2289"> </a>
<a name="ln2290">/* How to regenerate this:</a>
<a name="ln2291">   comm -2 -3 \</a>
<a name="ln2292">    &lt;(clang -P -E -nostdinc -nobuiltininc spell-type.h -DTAG_MAJOR_VERSION=34 | sort) \</a>
<a name="ln2293">    &lt;(clang -P -E -nostdinc -nobuiltininc spell-type.h -DTAG_MAJOR_VERSION=35 | sort) \</a>
<a name="ln2294">    | grep SPELL</a>
<a name="ln2295">*/</a>
<a name="ln2296">const set&lt;spell_type&gt; removed_spells =</a>
<a name="ln2297">{</a>
<a name="ln2298">#if TAG_MAJOR_VERSION == 34</a>
<a name="ln2299">    SPELL_BOLT_OF_INACCURACY,</a>
<a name="ln2300">    SPELL_CHANT_FIRE_STORM,</a>
<a name="ln2301">    SPELL_CIGOTUVIS_DEGENERATION,</a>
<a name="ln2302">    SPELL_CIGOTUVIS_EMBRACE,</a>
<a name="ln2303">    SPELL_CONDENSATION_SHIELD,</a>
<a name="ln2304">    SPELL_CONTROL_TELEPORT,</a>
<a name="ln2305">    SPELL_CONTROL_UNDEAD,</a>
<a name="ln2306">    SPELL_CONTROL_WINDS,</a>
<a name="ln2307">    SPELL_CORRUPT_BODY,</a>
<a name="ln2308">    SPELL_CURE_POISON,</a>
<a name="ln2309">    SPELL_DEFLECT_MISSILES,</a>
<a name="ln2310">    SPELL_DELAYED_FIREBALL,</a>
<a name="ln2311">    SPELL_DEMONIC_HORDE,</a>
<a name="ln2312">    SPELL_DRACONIAN_BREATH,</a>
<a name="ln2313">    SPELL_EPHEMERAL_INFUSION,</a>
<a name="ln2314">    SPELL_EVAPORATE,</a>
<a name="ln2315">    SPELL_EXPLOSIVE_BOLT,</a>
<a name="ln2316">    SPELL_FAKE_RAKSHASA_SUMMON,</a>
<a name="ln2317">    SPELL_FIRE_BRAND,</a>
<a name="ln2318">    SPELL_FIRE_CLOUD,</a>
<a name="ln2319">    SPELL_FLY,</a>
<a name="ln2320">    SPELL_FORCEFUL_DISMISSAL,</a>
<a name="ln2321">    SPELL_FREEZING_AURA,</a>
<a name="ln2322">    SPELL_FRENZY,</a>
<a name="ln2323">    SPELL_FULSOME_DISTILLATION,</a>
<a name="ln2324">    SPELL_GRAND_AVATAR,</a>
<a name="ln2325">    SPELL_HASTE_PLANTS,</a>
<a name="ln2326">    SPELL_HOLY_LIGHT,</a>
<a name="ln2327">    SPELL_HOLY_WORD,</a>
<a name="ln2328">    SPELL_HOMUNCULUS,</a>
<a name="ln2329">    SPELL_HUNTING_CRY,</a>
<a name="ln2330">    SPELL_IGNITE_POISON_SINGLE,</a>
<a name="ln2331">    SPELL_INSULATION,</a>
<a name="ln2332">    SPELL_IRON_ELEMENTALS,</a>
<a name="ln2333">    SPELL_LETHAL_INFUSION,</a>
<a name="ln2334">    SPELL_MELEE,</a>
<a name="ln2335">    SPELL_MIASMA_CLOUD,</a>
<a name="ln2336">    SPELL_MISLEAD,</a>
<a name="ln2337">    SPELL_PHASE_SHIFT,</a>
<a name="ln2338">    SPELL_POISON_CLOUD,</a>
<a name="ln2339">    SPELL_POISON_WEAPON,</a>
<a name="ln2340">    SPELL_REARRANGE_PIECES,</a>
<a name="ln2341">    SPELL_REGENERATION,</a>
<a name="ln2342">    SPELL_RESURRECT,</a>
<a name="ln2343">    SPELL_SACRIFICE,</a>
<a name="ln2344">    SPELL_SEE_INVISIBLE,</a>
<a name="ln2345">    SPELL_SERPENT_OF_HELL_BREATH_REMOVED,</a>
<a name="ln2346">    SPELL_SHAFT_SELF,</a>
<a name="ln2347">    SPELL_SILVER_BLAST,</a>
<a name="ln2348">    SPELL_SINGULARITY,</a>
<a name="ln2349">    SPELL_SONG_OF_SHIELDING,</a>
<a name="ln2350">    SPELL_STEAM_CLOUD,</a>
<a name="ln2351">    SPELL_STONESKIN,</a>
<a name="ln2352">    SPELL_STRIKING,</a>
<a name="ln2353">    SPELL_SUMMON_ELEMENTAL,</a>
<a name="ln2354">    SPELL_SUMMON_RAKSHASA,</a>
<a name="ln2355">    SPELL_SUMMON_SCORPIONS,</a>
<a name="ln2356">    SPELL_SUMMON_TWISTER,</a>
<a name="ln2357">    SPELL_SUNRAY,</a>
<a name="ln2358">    SPELL_SURE_BLADE,</a>
<a name="ln2359">    SPELL_THROW,</a>
<a name="ln2360">    SPELL_VAMPIRE_SUMMON,</a>
<a name="ln2361">    SPELL_WARP_BRAND,</a>
<a name="ln2362">    SPELL_WEAVE_SHADOWS,</a>
<a name="ln2363">#endif</a>
<a name="ln2364">};</a>
<a name="ln2365"> </a>
<a name="ln2366">bool spell_removed(spell_type spell)</a>
<a name="ln2367">{</a>
<a name="ln2368">    return removed_spells.count(spell) != 0;</a>
<a name="ln2369">}</a>

</code></pre>
<div class="balloon" rel="226"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v648/" target="_blank">V648</a> Priority of the '&&' operation is higher than that of the '||' operation.</p></div>
<div class="balloon" rel="244"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v648/" target="_blank">V648</a> Priority of the '&&' operation is higher than that of the '||' operation.</p></div>
<div class="balloon" rel="1511"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v547/" target="_blank">V547</a> Expression '!allow_fail' is always false.</p></div>

<link rel="stylesheet" href="highlight.css">
<script src="highlight.pack.js"></script>
<script src="highlightjs-line-numbers.js"></script>
<script>hljs.initHighlightingOnLoad();</script>
<script>hljs.initLineNumbersOnLoad();</script>
<script>
  $(document).ready(function() {
      $('.balloon').each(function () {
          var bl = $(this);
          var line = bl.attr('rel');
          var text = $('a[name="ln'+line+'"]').text();

          var space_count = 0;
          for(var i = 0; i<text.length; i++){
              var char = text[i];
              if((char !== ' ')&&(char !== '\t'))break;
              if(char === '\t')space_count++;
              space_count++;
          }

          bl.css('margin-left', space_count*8);
          $('a[name="ln'+line+'"]').after(bl);
      });

      window.location = window.location;
  });
</script>
</body>
</html>
