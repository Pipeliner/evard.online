
<html>
<head>

  <meta http-equiv="Content-Type" content="text/html; charset=US-ASCII" />
  <title>item-use.cc</title>

  <link rel="stylesheet" href="../style.css"/>
  <script src="../jquery-3.2.1.min.js"></script>
</head>
<body>

<pre><code class = "cpp">
<a name="ln1">/**</a>
<a name="ln2"> * @file</a>
<a name="ln3"> * @brief Functions for making use of inventory items.</a>
<a name="ln4">**/</a>
<a name="ln5"> </a>
<a name="ln6">#include &quot;AppHdr.h&quot;</a>
<a name="ln7"> </a>
<a name="ln8">#include &quot;item-use.h&quot;</a>
<a name="ln9"> </a>
<a name="ln10">#include &quot;ability.h&quot;</a>
<a name="ln11">#include &quot;acquire.h&quot;</a>
<a name="ln12">#include &quot;act-iter.h&quot;</a>
<a name="ln13">#include &quot;areas.h&quot;</a>
<a name="ln14">#include &quot;artefact.h&quot;</a>
<a name="ln15">#include &quot;art-enum.h&quot;</a>
<a name="ln16">#include &quot;butcher.h&quot;</a>
<a name="ln17">#include &quot;chardump.h&quot;</a>
<a name="ln18">#include &quot;cloud.h&quot;</a>
<a name="ln19">#include &quot;colour.h&quot;</a>
<a name="ln20">#include &quot;coordit.h&quot;</a>
<a name="ln21">#include &quot;database.h&quot;</a>
<a name="ln22">#include &quot;delay.h&quot;</a>
<a name="ln23">#include &quot;describe.h&quot;</a>
<a name="ln24">#include &quot;english.h&quot;</a>
<a name="ln25">#include &quot;env.h&quot;</a>
<a name="ln26">#include &quot;evoke.h&quot;</a>
<a name="ln27">#include &quot;fight.h&quot;</a>
<a name="ln28">#include &quot;food.h&quot;</a>
<a name="ln29">#include &quot;god-conduct.h&quot;</a>
<a name="ln30">#include &quot;god-item.h&quot;</a>
<a name="ln31">#include &quot;god-passive.h&quot;</a>
<a name="ln32">#include &quot;hints.h&quot;</a>
<a name="ln33">#include &quot;invent.h&quot;</a>
<a name="ln34">#include &quot;item-prop.h&quot;</a>
<a name="ln35">#include &quot;item-status-flag-type.h&quot;</a>
<a name="ln36">#include &quot;items.h&quot;</a>
<a name="ln37">#include &quot;known-items.h&quot;</a>
<a name="ln38">#include &quot;level-state-type.h&quot;</a>
<a name="ln39">#include &quot;libutil.h&quot;</a>
<a name="ln40">#include &quot;macro.h&quot;</a>
<a name="ln41">#include &quot;makeitem.h&quot;</a>
<a name="ln42">#include &quot;message.h&quot;</a>
<a name="ln43">#include &quot;misc.h&quot;</a>
<a name="ln44">#include &quot;mon-behv.h&quot;</a>
<a name="ln45">#include &quot;mutation.h&quot;</a>
<a name="ln46">#include &quot;nearby-danger.h&quot;</a>
<a name="ln47">#include &quot;orb.h&quot;</a>
<a name="ln48">#include &quot;output.h&quot;</a>
<a name="ln49">#include &quot;player-equip.h&quot;</a>
<a name="ln50">#include &quot;player-stats.h&quot;</a>
<a name="ln51">#include &quot;potion.h&quot;</a>
<a name="ln52">#include &quot;prompt.h&quot;</a>
<a name="ln53">#include &quot;religion.h&quot;</a>
<a name="ln54">#include &quot;shout.h&quot;</a>
<a name="ln55">#include &quot;skills.h&quot;</a>
<a name="ln56">#include &quot;sound.h&quot;</a>
<a name="ln57">#include &quot;spl-book.h&quot;</a>
<a name="ln58">#include &quot;spl-clouds.h&quot;</a>
<a name="ln59">#include &quot;spl-goditem.h&quot;</a>
<a name="ln60">#include &quot;spl-selfench.h&quot;</a>
<a name="ln61">#include &quot;spl-summoning.h&quot;</a>
<a name="ln62">#include &quot;spl-transloc.h&quot;</a>
<a name="ln63">#include &quot;spl-wpnench.h&quot;</a>
<a name="ln64">#include &quot;state.h&quot;</a>
<a name="ln65">#include &quot;stringutil.h&quot;</a>
<a name="ln66">#include &quot;target.h&quot;</a>
<a name="ln67">#include &quot;terrain.h&quot;</a>
<a name="ln68">#include &quot;throw.h&quot;</a>
<a name="ln69">#include &quot;tiles-build-specific.h&quot;</a>
<a name="ln70">#include &quot;transform.h&quot;</a>
<a name="ln71">#include &quot;uncancel.h&quot;</a>
<a name="ln72">#include &quot;unwind.h&quot;</a>
<a name="ln73">#include &quot;view.h&quot;</a>
<a name="ln74">#include &quot;xom.h&quot;</a>
<a name="ln75"> </a>
<a name="ln76">// The menu class for using items from either inv or floor.</a>
<a name="ln77">// Derivative of InvMenu</a>
<a name="ln78"> </a>
<a name="ln79">class UseItemMenu : public InvMenu</a>
<a name="ln80">{</a>
<a name="ln81">    void populate_list();</a>
<a name="ln82">    void populate_menu();</a>
<a name="ln83">    bool process_key(int key) override;</a>
<a name="ln84">    void repopulate_menu();</a>
<a name="ln85"> </a>
<a name="ln86">public:</a>
<a name="ln87">    bool display_all;</a>
<a name="ln88">    bool is_inventory;</a>
<a name="ln89">    int item_type_filter;</a>
<a name="ln90"> </a>
<a name="ln91">    vector&lt;const item_def*&gt; item_inv;</a>
<a name="ln92">    vector&lt;const item_def*&gt; item_floor;</a>
<a name="ln93"> </a>
<a name="ln94">    // Constructor</a>
<a name="ln95">    // Requires int for item filter.</a>
<a name="ln96">    // Accepts:</a>
<a name="ln97">    //      OBJ_POTIONS</a>
<a name="ln98">    //      OBJ_SCROLLS</a>
<a name="ln99">    //      OSEL_WIELD</a>
<a name="ln100">    //      OBJ_ARMOUR</a>
<a name="ln101">    //      OBJ_FOOD</a>
<a name="ln102">    UseItemMenu(int selector, const char* prompt);</a>
<a name="ln103"> </a>
<a name="ln104">    void toggle_display_all();</a>
<a name="ln105">    void toggle_inv_or_floor();</a>
<a name="ln106">};</a>
<a name="ln107"> </a>
<a name="ln108">UseItemMenu::UseItemMenu(int item_type, const char* prompt)</a>
<a name="ln109">    : InvMenu(MF_SINGLESELECT), display_all(false), is_inventory(true),</a>
<a name="ln110">      item_type_filter(item_type)</a>
<a name="ln111">{</a>
<a name="ln112">    set_title(prompt);</a>
<a name="ln113">    populate_list();</a>
<a name="ln114">    populate_menu();</a>
<a name="ln115">}</a>
<a name="ln116"> </a>
<a name="ln117">void UseItemMenu::populate_list()</a>
<a name="ln118">{</a>
<a name="ln119">    // Load inv items first</a>
<a name="ln120">    for (const auto &amp;item : you.inv)</a>
<a name="ln121">    {</a>
<a name="ln122">        if (item.defined())</a>
<a name="ln123">            item_inv.push_back(&amp;item);</a>
<a name="ln124">    }</a>
<a name="ln125">    // Load floor items...</a>
<a name="ln126">    item_floor = item_list_on_square(you.visible_igrd(you.pos()));</a>
<a name="ln127">    // ...only stuff that can go into your inventory though</a>
<a name="ln128">    erase_if(item_floor, [=](const item_def* it)</a>
<a name="ln129">    {</a>
<a name="ln130">        // Did we get them all...?</a>
<a name="ln131">        return !it-&gt;defined() || item_is_stationary(*it) || item_is_orb(*it)</a>
<a name="ln132">            || item_is_spellbook(*it) || it-&gt;base_type == OBJ_GOLD</a>
<a name="ln133">            || it-&gt;base_type == OBJ_RUNES;</a>
<a name="ln134">    });</a>
<a name="ln135"> </a>
<a name="ln136">    // Filter by type</a>
<a name="ln137">    if (!display_all)</a>
<a name="ln138">    {</a>
<a name="ln139">        erase_if(item_inv, [=](const item_def* item)</a>
<a name="ln140">        {</a>
<a name="ln141">            return !item_is_selected(*item, item_type_filter);</a>
<a name="ln142">        });</a>
<a name="ln143">        erase_if(item_floor, [=](const item_def* item)</a>
<a name="ln144">        {</a>
<a name="ln145">            return !item_is_selected(*item, item_type_filter);</a>
<a name="ln146">        });</a>
<a name="ln147">    }</a>
<a name="ln148">}</a>
<a name="ln149"> </a>
<a name="ln150">void UseItemMenu::populate_menu()</a>
<a name="ln151">{</a>
<a name="ln152">    if (item_inv.empty())</a>
<a name="ln153">        is_inventory = false;</a>
<a name="ln154">    else if (item_floor.empty())</a>
<a name="ln155">        is_inventory = true;</a>
<a name="ln156"> </a>
<a name="ln157">    // Entry for unarmed</a>
<a name="ln158">    if (item_type_filter == OSEL_WIELD)</a>
<a name="ln159">    {</a>
<a name="ln160">        string hands_title = &quot; -   unarmed&quot;;</a>
<a name="ln161">        MenuEntry *hands = new MenuEntry (hands_title, MEL_ITEM);</a>
<a name="ln162">        add_entry(hands);</a>
<a name="ln163">    }</a>
<a name="ln164"> </a>
<a name="ln165">    if (!item_inv.empty())</a>
<a name="ln166">    {</a>
<a name="ln167">        // Only clarify that these are inventory items if there are also floor</a>
<a name="ln168">        // items.</a>
<a name="ln169">        if (!item_floor.empty())</a>
<a name="ln170">        {</a>
<a name="ln171">            string subtitle_text = &quot;Inventory Items&quot;;</a>
<a name="ln172">            if (!is_inventory)</a>
<a name="ln173">                subtitle_text += &quot; (',' to select)&quot;;</a>
<a name="ln174">            auto subtitle = new MenuEntry(subtitle_text, MEL_TITLE);</a>
<a name="ln175">            subtitle-&gt;colour = LIGHTGREY;</a>
<a name="ln176">            add_entry(subtitle);</a>
<a name="ln177">        }</a>
<a name="ln178"> </a>
<a name="ln179">        // nullptr means using the items' normal hotkeys</a>
<a name="ln180">        if (is_inventory)</a>
<a name="ln181">            load_items(item_inv);</a>
<a name="ln182">        else</a>
<a name="ln183">        {</a>
<a name="ln184">            load_items(item_inv,</a>
<a name="ln185">                        [&amp;](MenuEntry* entry) -&gt; MenuEntry*</a>
<a name="ln186">                        {</a>
<a name="ln187">                            entry-&gt;hotkeys.clear();</a>
<a name="ln188">                            return entry;</a>
<a name="ln189">                        });</a>
<a name="ln190">        }</a>
<a name="ln191">    }</a>
<a name="ln192"> </a>
<a name="ln193">    if (!item_floor.empty())</a>
<a name="ln194">    {</a>
<a name="ln195">#ifndef USE_TILE</a>
<a name="ln196">        // vertical padding for console</a>
<a name="ln197">        if (!item_inv.empty())</a>
<a name="ln198">            add_entry(new MenuEntry(&quot;&quot;, MEL_TITLE));</a>
<a name="ln199">#endif</a>
<a name="ln200">        // Load floor items to menu</a>
<a name="ln201">        string subtitle_text = &quot;Floor Items&quot;;</a>
<a name="ln202">        if (is_inventory)</a>
<a name="ln203">            subtitle_text += &quot; (',' to select)&quot;;</a>
<a name="ln204">        auto subtitle = new MenuEntry(subtitle_text, MEL_TITLE);</a>
<a name="ln205">        subtitle-&gt;colour = LIGHTGREY;</a>
<a name="ln206">        add_entry(subtitle);</a>
<a name="ln207"> </a>
<a name="ln208">        // nullptr means using a-zA-Z</a>
<a name="ln209">        if (is_inventory)</a>
<a name="ln210">        {</a>
<a name="ln211">            load_items(item_floor,</a>
<a name="ln212">                        [&amp;](MenuEntry* entry) -&gt; MenuEntry*</a>
<a name="ln213">                        {</a>
<a name="ln214">                            entry-&gt;hotkeys.clear();</a>
<a name="ln215">                            return entry;</a>
<a name="ln216">                        });</a>
<a name="ln217">        }</a>
<a name="ln218">        else</a>
<a name="ln219">            load_items(item_floor);</a>
<a name="ln220">    }</a>
<a name="ln221">}</a>
<a name="ln222"> </a>
<a name="ln223">void UseItemMenu::repopulate_menu()</a>
<a name="ln224">{</a>
<a name="ln225">    deleteAll(items);</a>
<a name="ln226">    populate_menu();</a>
<a name="ln227">}</a>
<a name="ln228"> </a>
<a name="ln229">void UseItemMenu::toggle_display_all()</a>
<a name="ln230">{</a>
<a name="ln231">    display_all = !display_all;</a>
<a name="ln232">    item_inv.clear();</a>
<a name="ln233">    item_floor.clear();</a>
<a name="ln234">    populate_list();</a>
<a name="ln235">    repopulate_menu();</a>
<a name="ln236">}</a>
<a name="ln237"> </a>
<a name="ln238">void UseItemMenu::toggle_inv_or_floor()</a>
<a name="ln239">{</a>
<a name="ln240">    is_inventory = !is_inventory;</a>
<a name="ln241">    repopulate_menu();</a>
<a name="ln242">}</a>
<a name="ln243"> </a>
<a name="ln244">bool UseItemMenu::process_key(int key)</a>
<a name="ln245">{</a>
<a name="ln246">    if (isadigit(key) || key == '*' || key == '\\' || key == ','</a>
<a name="ln247">        || key == '-' &amp;&amp; item_type_filter == OSEL_WIELD)</a>
<a name="ln248">    {</a>
<a name="ln249">        lastch = key;</a>
<a name="ln250">        return false;</a>
<a name="ln251">    }</a>
<a name="ln252">    return Menu::process_key(key);</a>
<a name="ln253">}</a>
<a name="ln254"> </a>
<a name="ln255">static string _weird_smell()</a>
<a name="ln256">{</a>
<a name="ln257">    return getMiscString(&quot;smell_name&quot;);</a>
<a name="ln258">}</a>
<a name="ln259"> </a>
<a name="ln260">static string _weird_sound()</a>
<a name="ln261">{</a>
<a name="ln262">    return getMiscString(&quot;sound_name&quot;);</a>
<a name="ln263">}</a>
<a name="ln264"> </a>
<a name="ln265">/**</a>
<a name="ln266"> * Prompt use of an item from either player inventory or the floor.</a>
<a name="ln267"> *</a>
<a name="ln268"> * This function generates a menu containing type_expect items based on the</a>
<a name="ln269"> * object_class_type to be acted on by another function. First it will list</a>
<a name="ln270"> * items in inventory, then items on the floor. If the prompt is cancelled,</a>
<a name="ln271"> * false is returned. If something is successfully choosen, then true is</a>
<a name="ln272"> * returned, and at function exit the parameter target points to the object the</a>
<a name="ln273"> * player chose or to nullptr if the player chose to wield bare hands (this is</a>
<a name="ln274"> * only possible if item_type is OSEL_WIELD).</a>
<a name="ln275"> *</a>
<a name="ln276"> * @param target A pointer by reference to indicate the object selected.</a>
<a name="ln277"> * @param item_type The object_class_type or OSEL_* of items to list.</a>
<a name="ln278"> * @param oper The operation being done to the selected item.</a>
<a name="ln279"> * @param prompt The prompt on the menu title</a>
<a name="ln280"> * @param allowcancel If the user tries to cancel out of the prompt, run this</a>
<a name="ln281"> *                    function. If it returns false, continue the prompt rather</a>
<a name="ln282"> *                    than returning null.</a>
<a name="ln283"> *</a>
<a name="ln284"> * @return boolean true if something was chosen, false if the process failed and</a>
<a name="ln285"> *                 no choice was made</a>
<a name="ln286"> */</a>
<a name="ln287">bool use_an_item(item_def *&amp;target, int item_type, operation_types oper,</a>
<a name="ln288">                      const char* prompt, function&lt;bool ()&gt; allowcancel)</a>
<a name="ln289">{</a>
<a name="ln290">    // First bail if there's nothing appropriate to choose in inv or on floor</a>
<a name="ln291">    // (if choosing weapons, then bare hands are always a possibility)</a>
<a name="ln292">    if (item_type != OSEL_WIELD &amp;&amp; !any_items_of_type(item_type, -1, true))</a>
<a name="ln293">    {</a>
<a name="ln294">        mprf(MSGCH_PROMPT, &quot;%s&quot;,</a>
<a name="ln295">             no_selectables_message(item_type).c_str());</a>
<a name="ln296">        return false;</a>
<a name="ln297">    }</a>
<a name="ln298"> </a>
<a name="ln299">    bool choice_made = false;</a>
<a name="ln300">    item_def *tmp_tgt = nullptr; // We'll change target only if the player</a>
<a name="ln301">                                 // actually chooses</a>
<a name="ln302"> </a>
<a name="ln303">    // Init the menu</a>
<a name="ln304">    UseItemMenu menu(item_type, prompt);</a>
<a name="ln305"> </a>
<a name="ln306">    while (true)</a>
<a name="ln307">    {</a>
<a name="ln308">        vector&lt;MenuEntry*&gt; sel = menu.show(true);</a>
<a name="ln309">        int keyin = menu.getkey();</a>
<a name="ln310"> </a>
<a name="ln311">        // Handle inscribed item keys</a>
<a name="ln312">        if (isadigit(keyin))</a>
<a name="ln313">        {</a>
<a name="ln314">        // This allows you to select stuff by inscription that is not on the</a>
<a name="ln315">        // screen, but only if you couldn't by default use it for that operation</a>
<a name="ln316">        // anyway. It's a bit weird, but it does save a '*' keypress for</a>
<a name="ln317">        // bread-swingers.</a>
<a name="ln318">            tmp_tgt = digit_inscription_to_item(keyin, oper);</a>
<a name="ln319">            if (tmp_tgt)</a>
<a name="ln320">                choice_made = true;</a>
<a name="ln321">        }</a>
<a name="ln322">        else if (keyin == '*')</a>
<a name="ln323">        {</a>
<a name="ln324">            menu.toggle_display_all();</a>
<a name="ln325">            continue;</a>
<a name="ln326">        }</a>
<a name="ln327">        else if (keyin == ',')</a>
<a name="ln328">        {</a>
<a name="ln329">            if (Options.easy_floor_use &amp;&amp; menu.item_floor.size() == 1)</a>
<a name="ln330">            {</a>
<a name="ln331">                choice_made = true;</a>
<a name="ln332">                tmp_tgt = const_cast&lt;item_def*&gt;(menu.item_floor[0]);</a>
<a name="ln333">            }</a>
<a name="ln334">            else</a>
<a name="ln335">            {</a>
<a name="ln336">                menu.toggle_inv_or_floor();</a>
<a name="ln337">                continue;</a>
<a name="ln338">            }</a>
<a name="ln339">        }</a>
<a name="ln340">        else if (keyin == '\\')</a>
<a name="ln341">        {</a>
<a name="ln342">            check_item_knowledge();</a>
<a name="ln343">            continue;</a>
<a name="ln344">        }</a>
<a name="ln345">        else if (keyin == '-' &amp;&amp; menu.item_type_filter == OSEL_WIELD)</a>
<a name="ln346">        {</a>
<a name="ln347">            choice_made = true;</a>
<a name="ln348">            tmp_tgt = nullptr;</a>
<a name="ln349">        }</a>
<a name="ln350">        else if (!sel.empty())</a>
<a name="ln351">        {</a>
<a name="ln352">            ASSERT(sel.size() == 1);</a>
<a name="ln353"> </a>
<a name="ln354">            choice_made = true;</a>
<a name="ln355">            auto ie = dynamic_cast&lt;InvEntry *&gt;(sel[0]);</a>
<a name="ln356">            tmp_tgt = const_cast&lt;item_def*&gt;(ie-&gt;item);</a>
<a name="ln357">        }</a>
<a name="ln358"> </a>
<a name="ln359">        redraw_screen();</a>
<a name="ln360">        // For weapons, armour, and jewellery this is handled in wield_weapon,</a>
<a name="ln361">        // wear_armour, and _puton_item after selection</a>
<a name="ln362">        if (item_type != OSEL_WIELD &amp;&amp; item_type != OBJ_ARMOUR</a>
<a name="ln363">            &amp;&amp; item_type != OBJ_JEWELLERY &amp;&amp; choice_made &amp;&amp; tmp_tgt</a>
<a name="ln364">            &amp;&amp; !check_warning_inscriptions(*tmp_tgt, oper))</a>
<a name="ln365">        {</a>
<a name="ln366">            choice_made = false;</a>
<a name="ln367">        }</a>
<a name="ln368"> </a>
<a name="ln369">        if (choice_made)</a>
<a name="ln370">            break;</a>
<a name="ln371">        else if (allowcancel())</a>
<a name="ln372">        {</a>
<a name="ln373">            prompt_failed(PROMPT_ABORT);</a>
<a name="ln374">            break;</a>
<a name="ln375">        }</a>
<a name="ln376">        else</a>
<a name="ln377">            continue;</a>
<a name="ln378">    }</a>
<a name="ln379">    if (choice_made)</a>
<a name="ln380">        target = tmp_tgt;</a>
<a name="ln381"> </a>
<a name="ln382">    ASSERT(!choice_made || target || item_type == OSEL_WIELD);</a>
<a name="ln383">    return choice_made;</a>
<a name="ln384">}</a>
<a name="ln385"> </a>
<a name="ln386">static bool _safe_to_remove_or_wear(const item_def &amp;item, bool remove,</a>
<a name="ln387">                                    bool quiet = false);</a>
<a name="ln388"> </a>
<a name="ln389">// Rather messy - we've gathered all the can't-wield logic from wield_weapon()</a>
<a name="ln390">// here.</a>
<a name="ln391">bool can_wield(const item_def *weapon, bool say_reason,</a>
<a name="ln392">               bool ignore_temporary_disability, bool unwield, bool only_known)</a>
<a name="ln393">{</a>
<a name="ln394">#define SAY(x) {if (say_reason) { x; }}</a>
<a name="ln395">    if (you.melded[EQ_WEAPON] &amp;&amp; unwield)</a>
<a name="ln396">    {</a>
<a name="ln397">        SAY(mpr(&quot;Your weapon is melded into your body!&quot;));</a>
<a name="ln398">        return false;</a>
<a name="ln399">    }</a>
<a name="ln400"> </a>
<a name="ln401">    if (!ignore_temporary_disability &amp;&amp; !form_can_wield(you.form))</a>
<a name="ln402">    {</a>
<a name="ln403">        SAY(mpr(&quot;You can't wield anything in your present form.&quot;));</a>
<a name="ln404">        return false;</a>
<a name="ln405">    }</a>
<a name="ln406"> </a>
<a name="ln407">    if (!ignore_temporary_disability</a>
<a name="ln408">        &amp;&amp; you.weapon()</a>
<a name="ln409">        &amp;&amp; is_weapon(*you.weapon())</a>
<a name="ln410">        &amp;&amp; you.weapon()-&gt;cursed())</a>
<a name="ln411">    {</a>
<a name="ln412">        SAY(mprf(&quot;You can't unwield your weapon%s!&quot;,</a>
<a name="ln413">                 !unwield ? &quot; to draw a new one&quot; : &quot;&quot;));</a>
<a name="ln414">        return false;</a>
<a name="ln415">    }</a>
<a name="ln416"> </a>
<a name="ln417">    // If we don't have an actual weapon to check, return now.</a>
<a name="ln418">    if (!weapon)</a>
<a name="ln419">        return true;</a>
<a name="ln420"> </a>
<a name="ln421">    if (you.get_mutation_level(MUT_MISSING_HAND)</a>
<a name="ln422">            &amp;&amp; you.hands_reqd(*weapon) == HANDS_TWO)</a>
<a name="ln423">    {</a>
<a name="ln424">        SAY(mpr(&quot;You can't wield that without your missing limb.&quot;));</a>
<a name="ln425">        return false;</a>
<a name="ln426">    }</a>
<a name="ln427"> </a>
<a name="ln428">    for (int i = EQ_MIN_ARMOUR; i &lt;= EQ_MAX_WORN; i++)</a>
<a name="ln429">    {</a>
<a name="ln430">        if (you.equip[i] != -1 &amp;&amp; &amp;you.inv[you.equip[i]] == weapon)</a>
<a name="ln431">        {</a>
<a name="ln432">            SAY(mpr(&quot;You are wearing that object!&quot;));</a>
<a name="ln433">            return false;</a>
<a name="ln434">        }</a>
<a name="ln435">    }</a>
<a name="ln436"> </a>
<a name="ln437">    if (!you.could_wield(*weapon, true, true, !say_reason))</a>
<a name="ln438">        return false;</a>
<a name="ln439"> </a>
<a name="ln440">    // All non-weapons only need a shield check.</a>
<a name="ln441">    if (weapon-&gt;base_type != OBJ_WEAPONS)</a>
<a name="ln442">    {</a>
<a name="ln443">        if (!ignore_temporary_disability &amp;&amp; is_shield_incompatible(*weapon))</a>
<a name="ln444">        {</a>
<a name="ln445">            SAY(mpr(&quot;You can't wield that with a shield.&quot;));</a>
<a name="ln446">            return false;</a>
<a name="ln447">        }</a>
<a name="ln448">        else</a>
<a name="ln449">            return true;</a>
<a name="ln450">    }</a>
<a name="ln451"> </a>
<a name="ln452">    bool id_brand = false;</a>
<a name="ln453"> </a>
<a name="ln454">    if (you.undead_or_demonic() &amp;&amp; is_holy_item(*weapon)</a>
<a name="ln455">        &amp;&amp; (item_type_known(*weapon) || !only_known))</a>
<a name="ln456">    {</a>
<a name="ln457">        if (say_reason)</a>
<a name="ln458">        {</a>
<a name="ln459">            mpr(&quot;This weapon is holy and will not allow you to wield it.&quot;);</a>
<a name="ln460">            id_brand = true;</a>
<a name="ln461">        }</a>
<a name="ln462">        else</a>
<a name="ln463">            return false;</a>
<a name="ln464">    }</a>
<a name="ln465">    if (id_brand)</a>
<a name="ln466">    {</a>
<a name="ln467">        auto wwpn = const_cast&lt;item_def*&gt;(weapon);</a>
<a name="ln468">        if (!is_artefact(*weapon) &amp;&amp; !is_blessed(*weapon)</a>
<a name="ln469">            &amp;&amp; !item_type_known(*weapon))</a>
<a name="ln470">        {</a>
<a name="ln471">            set_ident_flags(*wwpn, ISFLAG_KNOW_TYPE);</a>
<a name="ln472">            if (in_inventory(*weapon))</a>
<a name="ln473">                mprf_nocap(&quot;%s&quot;, weapon-&gt;name(DESC_INVENTORY_EQUIP).c_str());</a>
<a name="ln474">        }</a>
<a name="ln475">        else if (is_artefact(*weapon) &amp;&amp; !item_type_known(*weapon))</a>
<a name="ln476">            artefact_learn_prop(*wwpn, ARTP_BRAND);</a>
<a name="ln477">        return false;</a>
<a name="ln478">    }</a>
<a name="ln479"> </a>
<a name="ln480">    if (!ignore_temporary_disability &amp;&amp; is_shield_incompatible(*weapon))</a>
<a name="ln481">    {</a>
<a name="ln482">        SAY(mpr(&quot;You can't wield that with a shield.&quot;));</a>
<a name="ln483">        return false;</a>
<a name="ln484">    }</a>
<a name="ln485"> </a>
<a name="ln486">    // We can wield this weapon. Phew!</a>
<a name="ln487">    return true;</a>
<a name="ln488"> </a>
<a name="ln489">#undef SAY</a>
<a name="ln490">}</a>
<a name="ln491"> </a>
<a name="ln492">/**</a>
<a name="ln493"> * Helper function for wield_weapon, wear_armour, and puton_ring</a>
<a name="ln494"> * @param  item    item on floor (where the player is standing)</a>
<a name="ln495"> * @param  quiet   print message or not</a>
<a name="ln496"> * @return boolean can the player move the item into their inventory, or are</a>
<a name="ln497"> *                 they out of space?</a>
<a name="ln498"> */</a>
<a name="ln499">static bool _can_move_item_from_floor_to_inv(const item_def &amp;item)</a>
<a name="ln500">{</a>
<a name="ln501">    if (inv_count() &lt; ENDOFPACK)</a>
<a name="ln502">        return true;</a>
<a name="ln503">    if (!is_stackable_item(item))</a>
<a name="ln504">    {</a>
<a name="ln505">        mpr(&quot;You can't carry that many items.&quot;);</a>
<a name="ln506">        return false;</a>
<a name="ln507">    }</a>
<a name="ln508">    for (int i = 0; i &lt; ENDOFPACK; ++i)</a>
<a name="ln509">    {</a>
<a name="ln510">        if (items_stack(you.inv[i], item))</a>
<a name="ln511">            return true;</a>
<a name="ln512">    }</a>
<a name="ln513">    mpr(&quot;You can't carry that many items.&quot;);</a>
<a name="ln514">    return false;</a>
<a name="ln515">}</a>
<a name="ln516"> </a>
<a name="ln517">/**</a>
<a name="ln518"> * Helper function for wield_weapon, wear_armour, and puton_ring</a>
<a name="ln519"> * @param  to_get item on floor (where the player is standing) to move into</a>
<a name="ln520">                  inventory</a>
<a name="ln521"> * @return int -1 if failure due to already full inventory; otherwise, index in</a>
<a name="ln522"> *             you.inv where the item ended up</a>
<a name="ln523"> */</a>
<a name="ln524">static int _move_item_from_floor_to_inv(const item_def &amp;to_get)</a>
<a name="ln525">{</a>
<a name="ln526">    map&lt;int,int&gt; tmp_l_p = you.last_pickup; // if we need to restore</a>
<a name="ln527">    you.last_pickup.clear();</a>
<a name="ln528"> </a>
<a name="ln529">    if (!move_item_to_inv(to_get.index(), to_get.quantity, true))</a>
<a name="ln530">    {</a>
<a name="ln531">        mpr(&quot;You can't carry that many items.&quot;);</a>
<a name="ln532">        you.last_pickup = tmp_l_p;</a>
<a name="ln533">    }</a>
<a name="ln534">    // Get the slot of the last thing picked up</a>
<a name="ln535">    // TODO: this is a bit hacky---perhaps it's worth making a function like</a>
<a name="ln536">    // move_item_to_inv that returns the slot the item moved into</a>
<a name="ln537">    else</a>
<a name="ln538">    {</a>
<a name="ln539">        ASSERT(you.last_pickup.size() == 1); // Sanity check...</a>
<a name="ln540">        return you.last_pickup.begin()-&gt;first;</a>
<a name="ln541">    }</a>
<a name="ln542">    return -1;</a>
<a name="ln543">}</a>
<a name="ln544"> </a>
<a name="ln545">/**</a>
<a name="ln546"> * Helper function for wield_weapon, wear_armour, and puton_ring</a>
<a name="ln547"> * @param  item  item on floor (where the player is standing) or in inventory</a>
<a name="ln548"> * @return ret index in you.inv where the item is (either because it was already</a>
<a name="ln549"> *               there or just got moved there), or -1 if we tried and failed to</a>
<a name="ln550"> *               move the item into inventory</a>
<a name="ln551"> */</a>
<a name="ln552">static int _get_item_slot_maybe_with_move(const item_def &amp;item)</a>
<a name="ln553">{</a>
<a name="ln554">    int ret = item.pos == ITEM_IN_INVENTORY</a>
<a name="ln555">        ? item.link : _move_item_from_floor_to_inv(item);</a>
<a name="ln556">    return ret;</a>
<a name="ln557">}</a>
<a name="ln558">/**</a>
<a name="ln559"> * @param auto_wield false if this was initiated by the wield weapon command (w)</a>
<a name="ln560"> *      true otherwise (e.g. switching between ranged and melee with the</a>
<a name="ln561"> *      auto_switch option)</a>
<a name="ln562"> * @param slot Index into inventory of item to equip. Or one of following</a>
<a name="ln563"> *     special values:</a>
<a name="ln564"> *      - -1 (default): meaning no particular weapon. We'll either prompt for a</a>
<a name="ln565"> *        choice of weapon (if auto_wield is false) or choose one by default.</a>
<a name="ln566"> *      - SLOT_BARE_HANDS: equip nothing (unwielding current weapon, if any)</a>
<a name="ln567"> */</a>
<a name="ln568">bool wield_weapon(bool auto_wield, int slot, bool show_weff_messages,</a>
<a name="ln569">                  bool show_unwield_msg, bool show_wield_msg,</a>
<a name="ln570">                  bool adjust_time_taken)</a>
<a name="ln571">{</a>
<a name="ln572">    // Abort immediately if there's some condition that could prevent wielding</a>
<a name="ln573">    // weapons.</a>
<a name="ln574">    if (!can_wield(nullptr, true, false, slot == SLOT_BARE_HANDS))</a>
<a name="ln575">        return false;</a>
<a name="ln576"> </a>
<a name="ln577">    item_def *to_wield = &amp;you.inv[0]; // default is 'a'</a>
<a name="ln578">        // we'll set this to nullptr to indicate bare hands</a>
<a name="ln579"> </a>
<a name="ln580">    if (auto_wield)</a>
<a name="ln581">    {</a>
<a name="ln582">        if (to_wield == you.weapon()</a>
<a name="ln583">            || you.equip[EQ_WEAPON] == -1 &amp;&amp; !item_is_wieldable(*to_wield))</a>
<a name="ln584">        {</a>
<a name="ln585">            to_wield = &amp;you.inv[1];      // backup is 'b'</a>
<a name="ln586">        }</a>
<a name="ln587"> </a>
<a name="ln588">        if (slot != -1)         // allow external override</a>
<a name="ln589">        {</a>
<a name="ln590">            if (slot == SLOT_BARE_HANDS)</a>
<a name="ln591">                to_wield = nullptr;</a>
<a name="ln592">            else</a>
<a name="ln593">                to_wield = &amp;you.inv[slot];</a>
<a name="ln594">        }</a>
<a name="ln595">    }</a>
<a name="ln596"> </a>
<a name="ln597">    if (to_wield)</a>
<a name="ln598">    {</a>
<a name="ln599">    // Prompt if not using the auto swap command</a>
<a name="ln600">        if (!auto_wield)</a>
<a name="ln601">        {</a>
<a name="ln602">            if (!use_an_item(to_wield, OSEL_WIELD, OPER_WIELD, &quot;Wield &quot;</a>
<a name="ln603">                             &quot;which item (- for none, * to show all)?&quot;))</a>
<a name="ln604">            {</a>
<a name="ln605">                return false;</a>
<a name="ln606">            }</a>
<a name="ln607">    // We abort if trying to wield from the floor with full inventory. We could</a>
<a name="ln608">    // try something more sophisticated, e.g., drop the currently held weapon,</a>
<a name="ln609">    // but that's surely not always what's wanted, and the problem persists if</a>
<a name="ln610">    // the player's hands are empty. For now, let's stick with simple behaviour</a>
<a name="ln611">    // over trying to guess what the player would like.</a>
<a name="ln612">            if (to_wield &amp;&amp; to_wield-&gt;pos != ITEM_IN_INVENTORY</a>
<a name="ln613">                &amp;&amp; !_can_move_item_from_floor_to_inv(*to_wield))</a>
<a name="ln614">            {</a>
<a name="ln615">                return false;</a>
<a name="ln616">            }</a>
<a name="ln617">        }</a>
<a name="ln618"> </a>
<a name="ln619">    // If autowielding and the swap slot has a bad or invalid item in it, the</a>
<a name="ln620">    // swap will be to bare hands.</a>
<a name="ln621">        else if (!to_wield-&gt;defined() || !item_is_wieldable(*to_wield))</a>
<a name="ln622">            to_wield = nullptr;</a>
<a name="ln623">    }</a>
<a name="ln624"> </a>
<a name="ln625">    if (to_wield &amp;&amp; to_wield == you.weapon())</a>
<a name="ln626">    {</a>
<a name="ln627">        if (Options.equip_unequip)</a>
<a name="ln628">            to_wield = nullptr;</a>
<a name="ln629">        else</a>
<a name="ln630">        {</a>
<a name="ln631">            mpr(&quot;You are already wielding that!&quot;);</a>
<a name="ln632">            return true;</a>
<a name="ln633">        }</a>
<a name="ln634">    }</a>
<a name="ln635"> </a>
<a name="ln636">    // Reset the warning counter.</a>
<a name="ln637">    you.received_weapon_warning = false;</a>
<a name="ln638"> </a>
<a name="ln639">    if (!to_wield)</a>
<a name="ln640">    {</a>
<a name="ln641">        if (const item_def* wpn = you.weapon())</a>
<a name="ln642">        {</a>
<a name="ln643">            bool penance = false;</a>
<a name="ln644">            // Can we safely unwield this item?</a>
<a name="ln645">            if (needs_handle_warning(*wpn, OPER_WIELD, penance))</a>
<a name="ln646">            {</a>
<a name="ln647">                string prompt =</a>
<a name="ln648">                    &quot;Really unwield &quot; + wpn-&gt;name(DESC_INVENTORY) + &quot;?&quot;;</a>
<a name="ln649">                if (penance)</a>
<a name="ln650">                    prompt += &quot; This could place you under penance!&quot;;</a>
<a name="ln651"> </a>
<a name="ln652">                if (!yesno(prompt.c_str(), false, 'n'))</a>
<a name="ln653">                {</a>
<a name="ln654">                    canned_msg(MSG_OK);</a>
<a name="ln655">                    return false;</a>
<a name="ln656">                }</a>
<a name="ln657">            }</a>
<a name="ln658"> </a>
<a name="ln659">            // check if you'd get stat-zeroed</a>
<a name="ln660">            if (!_safe_to_remove_or_wear(*wpn, true))</a>
<a name="ln661">                return false;</a>
<a name="ln662"> </a>
<a name="ln663">            if (!unwield_item(show_weff_messages))</a>
<a name="ln664">                return false;</a>
<a name="ln665"> </a>
<a name="ln666">            if (show_unwield_msg)</a>
<a name="ln667">            {</a>
<a name="ln668">#ifdef USE_SOUND</a>
<a name="ln669">                parse_sound(WIELD_NOTHING_SOUND);</a>
<a name="ln670">#endif</a>
<a name="ln671">                canned_msg(MSG_EMPTY_HANDED_NOW);</a>
<a name="ln672">            }</a>
<a name="ln673"> </a>
<a name="ln674">            // Switching to bare hands is extra fast.</a>
<a name="ln675">            you.turn_is_over = true;</a>
<a name="ln676">            if (adjust_time_taken)</a>
<a name="ln677">            {</a>
<a name="ln678">                you.time_taken *= 3;</a>
<a name="ln679">                you.time_taken /= 10;</a>
<a name="ln680">            }</a>
<a name="ln681">        }</a>
<a name="ln682">        else</a>
<a name="ln683">            canned_msg(MSG_EMPTY_HANDED_ALREADY);</a>
<a name="ln684"> </a>
<a name="ln685">        return true;</a>
<a name="ln686">    }</a>
<a name="ln687"> </a>
<a name="ln688">    // By now we're sure we're swapping to a real weapon, not bare hands</a>
<a name="ln689"> </a>
<a name="ln690">    item_def&amp; new_wpn = *to_wield;</a>
<a name="ln691"> </a>
<a name="ln692">    // Switching to a launcher while berserk is likely a mistake.</a>
<a name="ln693">    if (you.berserk() &amp;&amp; is_range_weapon(new_wpn))</a>
<a name="ln694">    {</a>
<a name="ln695">        string prompt = &quot;You can't shoot while berserk! Really wield &quot; +</a>
<a name="ln696">                        new_wpn.name(DESC_INVENTORY) + &quot;?&quot;;</a>
<a name="ln697">        if (!yesno(prompt.c_str(), false, 'n'))</a>
<a name="ln698">        {</a>
<a name="ln699">            canned_msg(MSG_OK);</a>
<a name="ln700">            return false;</a>
<a name="ln701">        }</a>
<a name="ln702">    }</a>
<a name="ln703"> </a>
<a name="ln704">    // Ensure wieldable</a>
<a name="ln705">    if (!can_wield(&amp;new_wpn, true))</a>
<a name="ln706">        return false;</a>
<a name="ln707"> </a>
<a name="ln708">    // Really ensure wieldable, even unknown brand</a>
<a name="ln709">    if (!can_wield(&amp;new_wpn, true, false, false, false))</a>
<a name="ln710">        return false;</a>
<a name="ln711"> </a>
<a name="ln712">    // At this point, we know it's possible to equip this item. However, there</a>
<a name="ln713">    // might be reasons it's not advisable.</a>
<a name="ln714">    if (!check_warning_inscriptions(new_wpn, OPER_WIELD)</a>
<a name="ln715">        || !_safe_to_remove_or_wear(new_wpn, false))</a>
<a name="ln716">    {</a>
<a name="ln717">        canned_msg(MSG_OK);</a>
<a name="ln718">        return false;</a>
<a name="ln719">    }</a>
<a name="ln720"> </a>
<a name="ln721">    // Unwield any old weapon.</a>
<a name="ln722">    if (you.weapon())</a>
<a name="ln723">    {</a>
<a name="ln724">        if (unwield_item(show_weff_messages))</a>
<a name="ln725">        {</a>
<a name="ln726">            // Enable skills so they can be re-disabled later</a>
<a name="ln727">            update_can_currently_train();</a>
<a name="ln728">        }</a>
<a name="ln729">        else</a>
<a name="ln730">            return false;</a>
<a name="ln731">    }</a>
<a name="ln732"> </a>
<a name="ln733">    const unsigned int old_talents = your_talents(false).size();</a>
<a name="ln734"> </a>
<a name="ln735">    // If it's on the ground, pick it up. Once it's picked up, there should be</a>
<a name="ln736">    // no aborting, lest we introduce a way to instantly pick things up</a>
<a name="ln737">    // NB we already made sure there was space for the item</a>
<a name="ln738">    int item_slot = _get_item_slot_maybe_with_move(new_wpn);</a>
<a name="ln739"> </a>
<a name="ln740">    // At this point new_wpn is potentially not the right thing anymore (the</a>
<a name="ln741">    // thing actually in the player's inventory), that is, in the case where the</a>
<a name="ln742">    // player chose something from the floor. So use item_slot from here on.</a>
<a name="ln743"> </a>
<a name="ln744">    // Go ahead and wield the weapon.</a>
<a name="ln745">    equip_item(EQ_WEAPON, item_slot, show_weff_messages);</a>
<a name="ln746"> </a>
<a name="ln747">    if (show_wield_msg)</a>
<a name="ln748">    {</a>
<a name="ln749">#ifdef USE_SOUND</a>
<a name="ln750">        parse_sound(WIELD_WEAPON_SOUND);</a>
<a name="ln751">#endif</a>
<a name="ln752">        mprf_nocap(&quot;%s&quot;, you.inv[item_slot].name(DESC_INVENTORY_EQUIP).c_str());</a>
<a name="ln753">    }</a>
<a name="ln754"> </a>
<a name="ln755">    check_item_hint(you.inv[item_slot], old_talents);</a>
<a name="ln756"> </a>
<a name="ln757">    // Time calculations.</a>
<a name="ln758">    if (adjust_time_taken)</a>
<a name="ln759">        you.time_taken /= 2;</a>
<a name="ln760"> </a>
<a name="ln761">    you.wield_change  = true;</a>
<a name="ln762">    you.m_quiver.on_weapon_changed();</a>
<a name="ln763">    you.turn_is_over  = true;</a>
<a name="ln764"> </a>
<a name="ln765">    return true;</a>
<a name="ln766">}</a>
<a name="ln767"> </a>
<a name="ln768">bool item_is_worn(int inv_slot)</a>
<a name="ln769">{</a>
<a name="ln770">    for (int i = EQ_MIN_ARMOUR; i &lt;= EQ_MAX_WORN; ++i)</a>
<a name="ln771">        if (inv_slot == you.equip[i])</a>
<a name="ln772">            return true;</a>
<a name="ln773"> </a>
<a name="ln774">    return false;</a>
<a name="ln775">}</a>
<a name="ln776"> </a>
<a name="ln777">/**</a>
<a name="ln778"> * Prompt user for carried armour.</a>
<a name="ln779"> *</a>
<a name="ln780"> * @param mesg Title for the prompt</a>
<a name="ln781"> * @param index[out] the inventory slot of the item chosen; not initialised</a>
<a name="ln782"> *                   if a valid item was not chosen.</a>
<a name="ln783"> * @param oper if equal to OPER_TAKEOFF, only show items relevant to the 'T'</a>
<a name="ln784"> *             command.</a>
<a name="ln785"> * @return whether a valid armour item was chosen.</a>
<a name="ln786"> */</a>
<a name="ln787">bool armour_prompt(const string &amp; mesg, int *index, operation_types oper)</a>
<a name="ln788">{</a>
<a name="ln789">    ASSERT(index != nullptr);</a>
<a name="ln790"> </a>
<a name="ln791">    if (you.berserk())</a>
<a name="ln792">        canned_msg(MSG_TOO_BERSERK);</a>
<a name="ln793">    else</a>
<a name="ln794">    {</a>
<a name="ln795">        int selector = OBJ_ARMOUR;</a>
<a name="ln796">        if (oper == OPER_TAKEOFF &amp;&amp; !Options.equip_unequip)</a>
<a name="ln797">            selector = OSEL_WORN_ARMOUR;</a>
<a name="ln798">        int slot = prompt_invent_item(mesg.c_str(), menu_type::invlist,</a>
<a name="ln799">                                      selector, oper);</a>
<a name="ln800"> </a>
<a name="ln801">        if (!prompt_failed(slot))</a>
<a name="ln802">        {</a>
<a name="ln803">            *index = slot;</a>
<a name="ln804">            return true;</a>
<a name="ln805">        }</a>
<a name="ln806">    }</a>
<a name="ln807"> </a>
<a name="ln808">    return false;</a>
<a name="ln809">}</a>
<a name="ln810"> </a>
<a name="ln811">/**</a>
<a name="ln812"> * The number of turns it takes to put on or take off a given piece of armour.</a>
<a name="ln813"> *</a>
<a name="ln814"> * @param item      The armour in question.</a>
<a name="ln815"> * @return          The number of turns it takes to don or doff the item.</a>
<a name="ln816"> */</a>
<a name="ln817">static int armour_equip_delay(const item_def &amp;/*item*/)</a>
<a name="ln818">{</a>
<a name="ln819">    return 5;</a>
<a name="ln820">}</a>
<a name="ln821"> </a>
<a name="ln822">/**</a>
<a name="ln823"> * Can you wear this item of armour currently?</a>
<a name="ln824"> *</a>
<a name="ln825"> * Ignores whether or not an item is equipped in its slot already.</a>
<a name="ln826"> * If the item is Lear's hauberk, some of this comment may be incorrect.</a>
<a name="ln827"> *</a>
<a name="ln828"> * @param item The item. Only the base_type and sub_type really should get</a>
<a name="ln829"> *             checked, since you_can_wear passes in a dummy item.</a>
<a name="ln830"> * @param verbose Whether to print a message about your inability to wear item.</a>
<a name="ln831"> * @param ignore_temporary Whether to take into account forms/fishtail/2handers.</a>
<a name="ln832"> *                         Note that no matter what this is set to, all</a>
<a name="ln833"> *                         mutations will be taken into account, except for</a>
<a name="ln834"> *                         ones from Beastly Appendage, which are only checked</a>
<a name="ln835"> *                         if this is false.</a>
<a name="ln836"> */</a>
<a name="ln837">bool can_wear_armour(const item_def &amp;item, bool verbose, bool ignore_temporary)</a>
<a name="ln838">{</a>
<a name="ln839">    const object_class_type base_type = item.base_type;</a>
<a name="ln840">    if (base_type != OBJ_ARMOUR || you.species == SP_FELID)</a>
<a name="ln841">    {</a>
<a name="ln842">        if (verbose)</a>
<a name="ln843">            mpr(&quot;You can't wear that.&quot;);</a>
<a name="ln844"> </a>
<a name="ln845">        return false;</a>
<a name="ln846">    }</a>
<a name="ln847"> </a>
<a name="ln848">    const int sub_type = item.sub_type;</a>
<a name="ln849">    const equipment_type slot = get_armour_slot(item);</a>
<a name="ln850"> </a>
<a name="ln851">    if (you.species == SP_OCTOPODE &amp;&amp; slot != EQ_HELMET &amp;&amp; slot != EQ_SHIELD)</a>
<a name="ln852">    {</a>
<a name="ln853">        if (verbose)</a>
<a name="ln854">            mpr(&quot;You can't wear that!&quot;);</a>
<a name="ln855">        return false;</a>
<a name="ln856">    }</a>
<a name="ln857"> </a>
<a name="ln858">    if (species_is_draconian(you.species) &amp;&amp; slot == EQ_BODY_ARMOUR)</a>
<a name="ln859">    {</a>
<a name="ln860">        if (verbose)</a>
<a name="ln861">        {</a>
<a name="ln862">            mprf(&quot;Your wings%s won't fit in that.&quot;, you.has_mutation(MUT_BIG_WINGS)</a>
<a name="ln863">                 ? &quot;&quot; : &quot;, even vestigial as they are,&quot;);</a>
<a name="ln864">        }</a>
<a name="ln865">        return false;</a>
<a name="ln866">    }</a>
<a name="ln867"> </a>
<a name="ln868">    if (sub_type == ARM_NAGA_BARDING || sub_type == ARM_CENTAUR_BARDING)</a>
<a name="ln869">    {</a>
<a name="ln870">        if (you.species == SP_NAGA &amp;&amp; sub_type == ARM_NAGA_BARDING</a>
<a name="ln871">            || you.species == SP_CENTAUR &amp;&amp; sub_type == ARM_CENTAUR_BARDING)</a>
<a name="ln872">        {</a>
<a name="ln873">            if (ignore_temporary || !player_is_shapechanged())</a>
<a name="ln874">                return true;</a>
<a name="ln875">            else if (verbose)</a>
<a name="ln876">                mpr(&quot;You can wear that only in your normal form.&quot;);</a>
<a name="ln877">        }</a>
<a name="ln878">        else if (verbose)</a>
<a name="ln879">            mpr(&quot;You can't wear that!&quot;);</a>
<a name="ln880">        return false;</a>
<a name="ln881">    }</a>
<a name="ln882"> </a>
<a name="ln883">    if (you.get_mutation_level(MUT_MISSING_HAND) &amp;&amp; is_shield(item))</a>
<a name="ln884">    {</a>
<a name="ln885">        if (verbose)</a>
<a name="ln886">        {</a>
<a name="ln887">            if (you.species == SP_OCTOPODE)</a>
<a name="ln888">                mpr(&quot;You need the rest of your tentacles for walking.&quot;);</a>
<a name="ln889">            else</a>
<a name="ln890">                mprf(&quot;You'd need another %s to do that!&quot;, you.hand_name(false).c_str());</a>
<a name="ln891">        }</a>
<a name="ln892">        return false;</a>
<a name="ln893">    }</a>
<a name="ln894"> </a>
<a name="ln895">    if (!ignore_temporary &amp;&amp; you.weapon()</a>
<a name="ln896">        &amp;&amp; is_shield(item)</a>
<a name="ln897">        &amp;&amp; is_shield_incompatible(*you.weapon(), &amp;item))</a>
<a name="ln898">    {</a>
<a name="ln899">        if (verbose)</a>
<a name="ln900">        {</a>
<a name="ln901">            if (you.species == SP_OCTOPODE)</a>
<a name="ln902">                mpr(&quot;You need the rest of your tentacles for walking.&quot;);</a>
<a name="ln903">            else</a>
<a name="ln904">            {</a>
<a name="ln905">                // Singular hand should have already been handled above.</a>
<a name="ln906">                mprf(&quot;You'd need three %s to do that!&quot;,</a>
<a name="ln907">                     you.hand_name(true).c_str());</a>
<a name="ln908">            }</a>
<a name="ln909">        }</a>
<a name="ln910">        return false;</a>
<a name="ln911">    }</a>
<a name="ln912"> </a>
<a name="ln913">    // Lear's hauberk covers also head, hands and legs.</a>
<a name="ln914">    if (is_unrandom_artefact(item, UNRAND_LEAR))</a>
<a name="ln915">    {</a>
<a name="ln916">        if (!player_has_feet(!ignore_temporary))</a>
<a name="ln917">        {</a>
<a name="ln918">            if (verbose)</a>
<a name="ln919">                mpr(&quot;You have no feet.&quot;);</a>
<a name="ln920">            return false;</a>
<a name="ln921">        }</a>
<a name="ln922"> </a>
<a name="ln923">        if (you.get_mutation_level(MUT_CLAWS, !ignore_temporary) &gt;= 3)</a>
<a name="ln924">        {</a>
<a name="ln925">            if (verbose)</a>
<a name="ln926">            {</a>
<a name="ln927">                mprf(&quot;The hauberk won't fit your %s.&quot;,</a>
<a name="ln928">                     you.hand_name(true).c_str());</a>
<a name="ln929">            }</a>
<a name="ln930">            return false;</a>
<a name="ln931">        }</a>
<a name="ln932"> </a>
<a name="ln933">        if (you.get_mutation_level(MUT_HORNS, !ignore_temporary) &gt;= 3</a>
<a name="ln934">            || you.get_mutation_level(MUT_ANTENNAE, !ignore_temporary) &gt;= 3)</a>
<a name="ln935">        {</a>
<a name="ln936">            if (verbose)</a>
<a name="ln937">                mpr(&quot;The hauberk won't fit your head.&quot;);</a>
<a name="ln938">            return false;</a>
<a name="ln939">        }</a>
<a name="ln940"> </a>
<a name="ln941">        if (!ignore_temporary)</a>
<a name="ln942">        {</a>
<a name="ln943">            for (int s = EQ_HELMET; s &lt;= EQ_BOOTS; s++)</a>
<a name="ln944">            {</a>
<a name="ln945">                // No strange race can wear this.</a>
<a name="ln946">                const string parts[] = { &quot;head&quot;, you.hand_name(true),</a>
<a name="ln947">                                         you.foot_name(true) };</a>
<a name="ln948">                COMPILE_CHECK(ARRAYSZ(parts) == EQ_BOOTS - EQ_HELMET + 1);</a>
<a name="ln949"> </a>
<a name="ln950">                // Auto-disrobing would be nice.</a>
<a name="ln951">                if (you.equip[s] != -1)</a>
<a name="ln952">                {</a>
<a name="ln953">                    if (verbose)</a>
<a name="ln954">                    {</a>
<a name="ln955">                        mprf(&quot;You'd need your %s free.&quot;,</a>
<a name="ln956">                             parts[s - EQ_HELMET].c_str());</a>
<a name="ln957">                    }</a>
<a name="ln958">                    return false;</a>
<a name="ln959">                }</a>
<a name="ln960"> </a>
<a name="ln961">                if (!get_form()-&gt;slot_available(s))</a>
<a name="ln962">                {</a>
<a name="ln963">                    if (verbose)</a>
<a name="ln964">                    {</a>
<a name="ln965">                        mprf(&quot;The hauberk won't fit your %s.&quot;,</a>
<a name="ln966">                             parts[s - EQ_HELMET].c_str());</a>
<a name="ln967">                    }</a>
<a name="ln968">                    return false;</a>
<a name="ln969">                }</a>
<a name="ln970">            }</a>
<a name="ln971">        }</a>
<a name="ln972">    }</a>
<a name="ln973">    else if (slot &gt;= EQ_HELMET &amp;&amp; slot &lt;= EQ_BOOTS</a>
<a name="ln974">             &amp;&amp; !ignore_temporary</a>
<a name="ln975">             &amp;&amp; player_equip_unrand(UNRAND_LEAR))</a>
<a name="ln976">    {</a>
<a name="ln977">        // The explanation is iffy for loose headgear, especially crowns:</a>
<a name="ln978">        // kings loved hooded hauberks, according to portraits.</a>
<a name="ln979">        if (verbose)</a>
<a name="ln980">            mpr(&quot;You can't wear this over your hauberk.&quot;);</a>
<a name="ln981">        return false;</a>
<a name="ln982">    }</a>
<a name="ln983"> </a>
<a name="ln984">    size_type player_size = you.body_size(PSIZE_TORSO, ignore_temporary);</a>
<a name="ln985">    int bad_size = fit_armour_size(item, player_size);</a>
<a name="ln986">#if TAG_MAJOR_VERSION == 34</a>
<a name="ln987">    if (is_unrandom_artefact(item, UNRAND_TALOS))</a>
<a name="ln988">    {</a>
<a name="ln989">        // adjust bad_size for the oversized plate armour</a>
<a name="ln990">        // negative means levels too small, positive means levels too large</a>
<a name="ln991">        bad_size = SIZE_LARGE - player_size;</a>
<a name="ln992">    }</a>
<a name="ln993">#endif</a>
<a name="ln994"> </a>
<a name="ln995">    if (bad_size)</a>
<a name="ln996">    {</a>
<a name="ln997">        if (verbose)</a>
<a name="ln998">        {</a>
<a name="ln999">            mprf(&quot;This armour is too %s for you!&quot;,</a>
<a name="ln1000">                 (bad_size &gt; 0) ? &quot;big&quot; : &quot;small&quot;);</a>
<a name="ln1001">        }</a>
<a name="ln1002"> </a>
<a name="ln1003">        return false;</a>
<a name="ln1004">    }</a>
<a name="ln1005"> </a>
<a name="ln1006">    if (you.form == transformation::appendage</a>
<a name="ln1007">        &amp;&amp; ignore_temporary</a>
<a name="ln1008">        &amp;&amp; slot == beastly_slot(you.attribute[ATTR_APPENDAGE])</a>
<a name="ln1009">        &amp;&amp; you.has_mutation(static_cast&lt;mutation_type&gt;(you.attribute[ATTR_APPENDAGE])))</a>
<a name="ln1010">    {</a>
<a name="ln1011">        unwind_var&lt;uint8_t&gt; mutv(you.mutation[you.attribute[ATTR_APPENDAGE]], 0);</a>
<a name="ln1012">        // disable the mutation then check again</a>
<a name="ln1013">        return can_wear_armour(item, verbose, ignore_temporary);</a>
<a name="ln1014">    }</a>
<a name="ln1015"> </a>
<a name="ln1016">    if (sub_type == ARM_GLOVES)</a>
<a name="ln1017">    {</a>
<a name="ln1018">        if (you.has_claws(false) == 3)</a>
<a name="ln1019">        {</a>
<a name="ln1020">            if (verbose)</a>
<a name="ln1021">            {</a>
<a name="ln1022">                mprf(&quot;You can't wear a glove with your huge claw%s!&quot;,</a>
<a name="ln1023">                     you.get_mutation_level(MUT_MISSING_HAND) ? &quot;&quot; : &quot;s&quot;);</a>
<a name="ln1024">            }</a>
<a name="ln1025">            return false;</a>
<a name="ln1026">        }</a>
<a name="ln1027">    }</a>
<a name="ln1028"> </a>
<a name="ln1029">    if (sub_type == ARM_BOOTS)</a>
<a name="ln1030">    {</a>
<a name="ln1031">        if (you.get_mutation_level(MUT_HOOVES, false) == 3)</a>
<a name="ln1032">        {</a>
<a name="ln1033">            if (verbose)</a>
<a name="ln1034">                mpr(&quot;You can't wear boots with hooves!&quot;);</a>
<a name="ln1035">            return false;</a>
<a name="ln1036">        }</a>
<a name="ln1037"> </a>
<a name="ln1038">        if (you.has_talons(false) == 3)</a>
<a name="ln1039">        {</a>
<a name="ln1040">            if (verbose)</a>
<a name="ln1041">                mpr(&quot;Boots don't fit your talons!&quot;);</a>
<a name="ln1042">            return false;</a>
<a name="ln1043">        }</a>
<a name="ln1044"> </a>
<a name="ln1045">        if (you.species == SP_NAGA)</a>
<a name="ln1046">        {</a>
<a name="ln1047">            if (verbose)</a>
<a name="ln1048">                mpr(&quot;You have no legs!&quot;);</a>
<a name="ln1049">            return false;</a>
<a name="ln1050">        }</a>
<a name="ln1051"> </a>
<a name="ln1052">        if (!ignore_temporary &amp;&amp; you.fishtail)</a>
<a name="ln1053">        {</a>
<a name="ln1054">            if (verbose)</a>
<a name="ln1055">                mpr(&quot;You don't currently have feet!&quot;);</a>
<a name="ln1056">            return false;</a>
<a name="ln1057">        }</a>
<a name="ln1058">    }</a>
<a name="ln1059"> </a>
<a name="ln1060">    if (slot == EQ_HELMET)</a>
<a name="ln1061">    {</a>
<a name="ln1062">        // Horns 3 &amp; Antennae 3 mutations disallow all headgear</a>
<a name="ln1063">        if (you.get_mutation_level(MUT_HORNS, false) == 3)</a>
<a name="ln1064">        {</a>
<a name="ln1065">            if (verbose)</a>
<a name="ln1066">                mpr(&quot;You can't wear any headgear with your large horns!&quot;);</a>
<a name="ln1067">            return false;</a>
<a name="ln1068">        }</a>
<a name="ln1069"> </a>
<a name="ln1070">        if (you.get_mutation_level(MUT_ANTENNAE, false) == 3)</a>
<a name="ln1071">        {</a>
<a name="ln1072">            if (verbose)</a>
<a name="ln1073">                mpr(&quot;You can't wear any headgear with your large antennae!&quot;);</a>
<a name="ln1074">            return false;</a>
<a name="ln1075">        }</a>
<a name="ln1076"> </a>
<a name="ln1077">        // Soft helmets (caps and wizard hats) always fit, otherwise.</a>
<a name="ln1078">        if (is_hard_helmet(item))</a>
<a name="ln1079">        {</a>
<a name="ln1080">            if (you.get_mutation_level(MUT_HORNS, false))</a>
<a name="ln1081">            {</a>
<a name="ln1082">                if (verbose)</a>
<a name="ln1083">                    mpr(&quot;You can't wear that with your horns!&quot;);</a>
<a name="ln1084">                return false;</a>
<a name="ln1085">            }</a>
<a name="ln1086"> </a>
<a name="ln1087">            if (you.get_mutation_level(MUT_BEAK, false))</a>
<a name="ln1088">            {</a>
<a name="ln1089">                if (verbose)</a>
<a name="ln1090">                    mpr(&quot;You can't wear that with your beak!&quot;);</a>
<a name="ln1091">                return false;</a>
<a name="ln1092">            }</a>
<a name="ln1093"> </a>
<a name="ln1094">            if (you.get_mutation_level(MUT_ANTENNAE, false))</a>
<a name="ln1095">            {</a>
<a name="ln1096">                if (verbose)</a>
<a name="ln1097">                    mpr(&quot;You can't wear that with your antennae!&quot;);</a>
<a name="ln1098">                return false;</a>
<a name="ln1099">            }</a>
<a name="ln1100"> </a>
<a name="ln1101">            if (species_is_draconian(you.species))</a>
<a name="ln1102">            {</a>
<a name="ln1103">                if (verbose)</a>
<a name="ln1104">                    mpr(&quot;You can't wear that with your reptilian head.&quot;);</a>
<a name="ln1105">                return false;</a>
<a name="ln1106">            }</a>
<a name="ln1107"> </a>
<a name="ln1108">            if (you.species == SP_OCTOPODE)</a>
<a name="ln1109">            {</a>
<a name="ln1110">                if (verbose)</a>
<a name="ln1111">                    mpr(&quot;You can't wear that!&quot;);</a>
<a name="ln1112">                return false;</a>
<a name="ln1113">            }</a>
<a name="ln1114">        }</a>
<a name="ln1115">    }</a>
<a name="ln1116"> </a>
<a name="ln1117">    // Can't just use Form::slot_available because of shroom caps.</a>
<a name="ln1118">    if (!ignore_temporary &amp;&amp; !get_form()-&gt;can_wear_item(item))</a>
<a name="ln1119">    {</a>
<a name="ln1120">        if (verbose)</a>
<a name="ln1121">            mpr(&quot;You can't wear that in your present form.&quot;);</a>
<a name="ln1122">        return false;</a>
<a name="ln1123">    }</a>
<a name="ln1124"> </a>
<a name="ln1125">    return true;</a>
<a name="ln1126">}</a>
<a name="ln1127"> </a>
<a name="ln1128">static bool _can_takeoff_armour(int item);</a>
<a name="ln1129"> </a>
<a name="ln1130">// Like can_wear_armour, but also takes into account currently worn equipment.</a>
<a name="ln1131">// e.g. you may be able to *wear* that robe, but you can't equip it if your</a>
<a name="ln1132">// currently worn armour is cursed, or melded.</a>
<a name="ln1133">// precondition: item is not already worn</a>
<a name="ln1134">static bool _can_equip_armour(const item_def &amp;item)</a>
<a name="ln1135">{</a>
<a name="ln1136">    const object_class_type base_type = item.base_type;</a>
<a name="ln1137">    if (base_type != OBJ_ARMOUR)</a>
<a name="ln1138">    {</a>
<a name="ln1139">        mpr(&quot;You can't wear that.&quot;);</a>
<a name="ln1140">        return false;</a>
<a name="ln1141">    }</a>
<a name="ln1142"> </a>
<a name="ln1143">    const equipment_type slot = get_armour_slot(item);</a>
<a name="ln1144">    const int equipped = you.equip[slot];</a>
<a name="ln1145">    if (equipped != -1 &amp;&amp; !_can_takeoff_armour(equipped))</a>
<a name="ln1146">        return false;</a>
<a name="ln1147">    return can_wear_armour(item, true, false);</a>
<a name="ln1148">}</a>
<a name="ln1149"> </a>
<a name="ln1150">// Try to equip the armour in the given inventory slot (or, if slot is -1,</a>
<a name="ln1151">// prompt for a choice of item, then try to wear it).</a>
<a name="ln1152">bool wear_armour(int item)</a>
<a name="ln1153">{</a>
<a name="ln1154">    // Before (possibly) prompting for which item to wear, check for some</a>
<a name="ln1155">    // conditions that would make it impossible to wear any type of armour.</a>
<a name="ln1156">    // TODO: perhaps also worth checking here whether all available armour slots</a>
<a name="ln1157">    // are cursed. Same with jewellery.</a>
<a name="ln1158">    if (you.species == SP_FELID)</a>
<a name="ln1159">    {</a>
<a name="ln1160">        mpr(&quot;You can't wear anything.&quot;);</a>
<a name="ln1161">        return false;</a>
<a name="ln1162">    }</a>
<a name="ln1163"> </a>
<a name="ln1164">    if (!form_can_wear())</a>
<a name="ln1165">    {</a>
<a name="ln1166">        mpr(&quot;You can't wear anything in your present form.&quot;);</a>
<a name="ln1167">        return false;</a>
<a name="ln1168">    }</a>
<a name="ln1169"> </a>
<a name="ln1170">    if (you.berserk())</a>
<a name="ln1171">    {</a>
<a name="ln1172">        canned_msg(MSG_TOO_BERSERK);</a>
<a name="ln1173">        return false;</a>
<a name="ln1174">    }</a>
<a name="ln1175"> </a>
<a name="ln1176">    item_def *to_wear = nullptr;</a>
<a name="ln1177"> </a>
<a name="ln1178">    if (item == -1)</a>
<a name="ln1179">    {</a>
<a name="ln1180">        if (!use_an_item(to_wear, OBJ_ARMOUR, OPER_WEAR,</a>
<a name="ln1181">                         &quot;Wear which item (* to show all)?&quot;))</a>
<a name="ln1182">        {</a>
<a name="ln1183">            return false;</a>
<a name="ln1184">        }</a>
<a name="ln1185">        // use_an_item on armour should never return true and leave to_wear</a>
<a name="ln1186">        // nullptr</a>
<a name="ln1187">        if (to_wear-&gt;pos != ITEM_IN_INVENTORY</a>
<a name="ln1188">            &amp;&amp; !_can_move_item_from_floor_to_inv(*to_wear))</a>
<a name="ln1189">        {</a>
<a name="ln1190">            return false;</a>
<a name="ln1191">        }</a>
<a name="ln1192">    }</a>
<a name="ln1193">    else</a>
<a name="ln1194">        to_wear = &amp;you.inv[item];</a>
<a name="ln1195"> </a>
<a name="ln1196">    // First, let's check for any conditions that would make it impossible to</a>
<a name="ln1197">    // equip the given item</a>
<a name="ln1198">    if (!to_wear-&gt;defined())</a>
<a name="ln1199">    {</a>
<a name="ln1200">        mpr(&quot;You don't have any such object.&quot;);</a>
<a name="ln1201">        return false;</a>
<a name="ln1202">    }</a>
<a name="ln1203"> </a>
<a name="ln1204">    if (to_wear == you.weapon())</a>
<a name="ln1205">    {</a>
<a name="ln1206">        mpr(&quot;You are wielding that object!&quot;);</a>
<a name="ln1207">        return false;</a>
<a name="ln1208">    }</a>
<a name="ln1209"> </a>
<a name="ln1210">    if (to_wear-&gt;pos == ITEM_IN_INVENTORY &amp;&amp; item_is_worn(to_wear-&gt;link))</a>
<a name="ln1211">    {</a>
<a name="ln1212">        if (Options.equip_unequip)</a>
<a name="ln1213">            // TODO: huh? Why are we inverting the return value?</a>
<a name="ln1214">            return !takeoff_armour(to_wear-&gt;link);</a>
<a name="ln1215">        else</a>
<a name="ln1216">        {</a>
<a name="ln1217">            mpr(&quot;You're already wearing that object!&quot;);</a>
<a name="ln1218">            return false;</a>
<a name="ln1219">        }</a>
<a name="ln1220">    }</a>
<a name="ln1221"> </a>
<a name="ln1222">    if (!_can_equip_armour(*to_wear))</a>
<a name="ln1223">        return false;</a>
<a name="ln1224"> </a>
<a name="ln1225">    // At this point, we know it's possible to equip this item. However, there</a>
<a name="ln1226">    // might be reasons it's not advisable. Warn about any dangerous</a>
<a name="ln1227">    // inscriptions, giving the player an opportunity to bail out.</a>
<a name="ln1228">    if (!check_warning_inscriptions(*to_wear, OPER_WEAR))</a>
<a name="ln1229">    {</a>
<a name="ln1230">        canned_msg(MSG_OK);</a>
<a name="ln1231">        return false;</a>
<a name="ln1232">    }</a>
<a name="ln1233"> </a>
<a name="ln1234">    bool swapping = false;</a>
<a name="ln1235">    const equipment_type slot = get_armour_slot(*to_wear);</a>
<a name="ln1236">    if ((slot == EQ_CLOAK</a>
<a name="ln1237">           || slot == EQ_HELMET</a>
<a name="ln1238">           || slot == EQ_GLOVES</a>
<a name="ln1239">           || slot == EQ_BOOTS</a>
<a name="ln1240">           || slot == EQ_SHIELD</a>
<a name="ln1241">           || slot == EQ_BODY_ARMOUR)</a>
<a name="ln1242">        &amp;&amp; you.equip[slot] != -1)</a>
<a name="ln1243">    {</a>
<a name="ln1244">        if (!takeoff_armour(you.equip[slot]))</a>
<a name="ln1245">            return false;</a>
<a name="ln1246">        swapping = true;</a>
<a name="ln1247">    }</a>
<a name="ln1248"> </a>
<a name="ln1249">    you.turn_is_over = true;</a>
<a name="ln1250"> </a>
<a name="ln1251">    // TODO: It would be nice if we checked this before taking off the item</a>
<a name="ln1252">    // currently in the slot. But doing so is not quite trivial. Also applies</a>
<a name="ln1253">    // to jewellery.</a>
<a name="ln1254">    if (!_safe_to_remove_or_wear(*to_wear, false))</a>
<a name="ln1255">        return false;</a>
<a name="ln1256"> </a>
<a name="ln1257">    // If it's on the ground, pick it up. Once it's picked up, there should be</a>
<a name="ln1258">    // no aborting</a>
<a name="ln1259">    // NB we already made sure there was space for the item</a>
<a name="ln1260">    int item_slot = _get_item_slot_maybe_with_move(*to_wear);</a>
<a name="ln1261"> </a>
<a name="ln1262">    const int delay = armour_equip_delay(*to_wear);</a>
<a name="ln1263">    if (delay)</a>
<a name="ln1264">    {</a>
<a name="ln1265">        start_delay&lt;ArmourOnDelay&gt;(delay - (swapping ? 0 : 1),</a>
<a name="ln1266">                                   you.inv[item_slot]);</a>
<a name="ln1267">    }</a>
<a name="ln1268"> </a>
<a name="ln1269">    return true;</a>
<a name="ln1270">}</a>
<a name="ln1271"> </a>
<a name="ln1272">static bool _can_takeoff_armour(int item)</a>
<a name="ln1273">{</a>
<a name="ln1274">    item_def&amp; invitem = you.inv[item];</a>
<a name="ln1275">    if (invitem.base_type != OBJ_ARMOUR)</a>
<a name="ln1276">    {</a>
<a name="ln1277">        mpr(&quot;You aren't wearing that!&quot;);</a>
<a name="ln1278">        return false;</a>
<a name="ln1279">    }</a>
<a name="ln1280"> </a>
<a name="ln1281">    if (you.berserk())</a>
<a name="ln1282">    {</a>
<a name="ln1283">        canned_msg(MSG_TOO_BERSERK);</a>
<a name="ln1284">        return false;</a>
<a name="ln1285">    }</a>
<a name="ln1286"> </a>
<a name="ln1287">    const equipment_type slot = get_armour_slot(invitem);</a>
<a name="ln1288">    if (item == you.equip[slot] &amp;&amp; you.melded[slot])</a>
<a name="ln1289">    {</a>
<a name="ln1290">        mprf(&quot;%s is melded into your body!&quot;,</a>
<a name="ln1291">             invitem.name(DESC_YOUR).c_str());</a>
<a name="ln1292">        return false;</a>
<a name="ln1293">    }</a>
<a name="ln1294"> </a>
<a name="ln1295">    if (!item_is_worn(item))</a>
<a name="ln1296">    {</a>
<a name="ln1297">        mpr(&quot;You aren't wearing that object!&quot;);</a>
<a name="ln1298">        return false;</a>
<a name="ln1299">    }</a>
<a name="ln1300"> </a>
<a name="ln1301">    // If we get here, we're wearing the item.</a>
<a name="ln1302">    if (invitem.cursed())</a>
<a name="ln1303">    {</a>
<a name="ln1304">        mprf(&quot;%s is stuck to your body!&quot;, invitem.name(DESC_YOUR).c_str());</a>
<a name="ln1305">        return false;</a>
<a name="ln1306">    }</a>
<a name="ln1307">    return true;</a>
<a name="ln1308">}</a>
<a name="ln1309"> </a>
<a name="ln1310">// TODO: It would be nice if this were made consistent with wear_armour,</a>
<a name="ln1311">// wield_weapon, puton_ring, etc. in terms of taking a default value of -1,</a>
<a name="ln1312">// which has the effect of prompting for an item to take off.</a>
<a name="ln1313">bool takeoff_armour(int item)</a>
<a name="ln1314">{</a>
<a name="ln1315">    if (!_can_takeoff_armour(item))</a>
<a name="ln1316">        return false;</a>
<a name="ln1317"> </a>
<a name="ln1318">    item_def&amp; invitem = you.inv[item];</a>
<a name="ln1319"> </a>
<a name="ln1320">    // It's possible to take this thing off, but if it would drop a stat</a>
<a name="ln1321">    // below 0, we should get confirmation.</a>
<a name="ln1322">    if (!_safe_to_remove_or_wear(invitem, true))</a>
<a name="ln1323">        return false;</a>
<a name="ln1324"> </a>
<a name="ln1325">    const equipment_type slot = get_armour_slot(invitem);</a>
<a name="ln1326"> </a>
<a name="ln1327">    // TODO: isn't this check covered above by the call to item_is_worn? The</a>
<a name="ln1328">    // only way to return false inside this switch would be if the player is</a>
<a name="ln1329">    // wearing a hat on their feet or something like that.</a>
<a name="ln1330">    switch (slot)</a>
<a name="ln1331">    {</a>
<a name="ln1332">    case EQ_BODY_ARMOUR:</a>
<a name="ln1333">    case EQ_SHIELD:</a>
<a name="ln1334">    case EQ_CLOAK:</a>
<a name="ln1335">    case EQ_HELMET:</a>
<a name="ln1336">    case EQ_GLOVES:</a>
<a name="ln1337">    case EQ_BOOTS:</a>
<a name="ln1338">        if (item != you.equip[slot])</a>
<a name="ln1339">        {</a>
<a name="ln1340">            mpr(&quot;You aren't wearing that!&quot;);</a>
<a name="ln1341">            return false;</a>
<a name="ln1342">        }</a>
<a name="ln1343">        break;</a>
<a name="ln1344"> </a>
<a name="ln1345">    default:</a>
<a name="ln1346">        break;</a>
<a name="ln1347">    }</a>
<a name="ln1348"> </a>
<a name="ln1349">    you.turn_is_over = true;</a>
<a name="ln1350"> </a>
<a name="ln1351">    const int delay = armour_equip_delay(invitem);</a>
<a name="ln1352">    start_delay&lt;ArmourOffDelay&gt;(delay - 1, invitem);</a>
<a name="ln1353"> </a>
<a name="ln1354">    return true;</a>
<a name="ln1355">}</a>
<a name="ln1356"> </a>
<a name="ln1357">// Returns a list of possible ring slots.</a>
<a name="ln1358">static vector&lt;equipment_type&gt; _current_ring_types()</a>
<a name="ln1359">{</a>
<a name="ln1360">    vector&lt;equipment_type&gt; ret;</a>
<a name="ln1361">    if (you.species == SP_OCTOPODE)</a>
<a name="ln1362">    {</a>
<a name="ln1363">        for (int i = 0; i &lt; 8; ++i)</a>
<a name="ln1364">        {</a>
<a name="ln1365">            const equipment_type slot = (equipment_type)(EQ_RING_ONE + i);</a>
<a name="ln1366"> </a>
<a name="ln1367">            if (you.get_mutation_level(MUT_MISSING_HAND)</a>
<a name="ln1368">                &amp;&amp; slot == EQ_RING_EIGHT)</a>
<a name="ln1369">            {</a>
<a name="ln1370">                continue;</a>
<a name="ln1371">            }</a>
<a name="ln1372"> </a>
<a name="ln1373">            if (get_form()-&gt;slot_available(slot))</a>
<a name="ln1374">                ret.push_back(slot);</a>
<a name="ln1375">        }</a>
<a name="ln1376">    }</a>
<a name="ln1377">    else</a>
<a name="ln1378">    {</a>
<a name="ln1379">        if (you.get_mutation_level(MUT_MISSING_HAND) == 0)</a>
<a name="ln1380">            ret.push_back(EQ_LEFT_RING);</a>
<a name="ln1381">        ret.push_back(EQ_RIGHT_RING);</a>
<a name="ln1382">    }</a>
<a name="ln1383">    if (player_equip_unrand(UNRAND_FINGER_AMULET))</a>
<a name="ln1384">        ret.push_back(EQ_RING_AMULET);</a>
<a name="ln1385">    return ret;</a>
<a name="ln1386">}</a>
<a name="ln1387"> </a>
<a name="ln1388">static vector&lt;equipment_type&gt; _current_jewellery_types()</a>
<a name="ln1389">{</a>
<a name="ln1390">    vector&lt;equipment_type&gt; ret = _current_ring_types();</a>
<a name="ln1391">    ret.push_back(EQ_AMULET);</a>
<a name="ln1392">    return ret;</a>
<a name="ln1393">}</a>
<a name="ln1394"> </a>
<a name="ln1395">static char _ring_slot_key(equipment_type slot)</a>
<a name="ln1396">{</a>
<a name="ln1397">    switch (slot)</a>
<a name="ln1398">    {</a>
<a name="ln1399">    case EQ_LEFT_RING:      return '&lt;';</a>
<a name="ln1400">    case EQ_RIGHT_RING:     return '&gt;';</a>
<a name="ln1401">    case EQ_RING_AMULET:    return '^';</a>
<a name="ln1402">    case EQ_RING_ONE:       return '1';</a>
<a name="ln1403">    case EQ_RING_TWO:       return '2';</a>
<a name="ln1404">    case EQ_RING_THREE:     return '3';</a>
<a name="ln1405">    case EQ_RING_FOUR:      return '4';</a>
<a name="ln1406">    case EQ_RING_FIVE:      return '5';</a>
<a name="ln1407">    case EQ_RING_SIX:       return '6';</a>
<a name="ln1408">    case EQ_RING_SEVEN:     return '7';</a>
<a name="ln1409">    case EQ_RING_EIGHT:     return '8';</a>
<a name="ln1410">    default:</a>
<a name="ln1411">        die(&quot;Invalid ring slot&quot;);</a>
<a name="ln1412">    }</a>
<a name="ln1413">}</a>
<a name="ln1414"> </a>
<a name="ln1415">static int _prompt_ring_to_remove()</a>
<a name="ln1416">{</a>
<a name="ln1417">    const vector&lt;equipment_type&gt; ring_types = _current_ring_types();</a>
<a name="ln1418">    vector&lt;char&gt; slot_chars;</a>
<a name="ln1419">    vector&lt;item_def*&gt; rings;</a>
<a name="ln1420">    for (auto eq : ring_types)</a>
<a name="ln1421">    {</a>
<a name="ln1422">        rings.push_back(you.slot_item(eq, true));</a>
<a name="ln1423">        ASSERT(rings.back());</a>
<a name="ln1424">        slot_chars.push_back(index_to_letter(rings.back()-&gt;link));</a>
<a name="ln1425">    }</a>
<a name="ln1426"> </a>
<a name="ln1427">    if (slot_chars.size() + 2 &gt; msgwin_lines() || ui::has_layout())</a>
<a name="ln1428">    {</a>
<a name="ln1429">        // force a menu rather than a more().</a>
<a name="ln1430">        return EQ_NONE;</a>
<a name="ln1431">    }</a>
<a name="ln1432"> </a>
<a name="ln1433">    clear_messages();</a>
<a name="ln1434"> </a>
<a name="ln1435">    mprf(MSGCH_PROMPT,</a>
<a name="ln1436">         &quot;You're wearing all the rings you can. Remove which one?&quot;);</a>
<a name="ln1437">    mprf(MSGCH_PROMPT, &quot;(&lt;w&gt;?&lt;/w&gt; for menu, &lt;w&gt;Esc&lt;/w&gt; to cancel)&quot;);</a>
<a name="ln1438"> </a>
<a name="ln1439">    // FIXME: Needs TOUCH_UI version</a>
<a name="ln1440"> </a>
<a name="ln1441">    for (size_t i = 0; i &lt; rings.size(); i++)</a>
<a name="ln1442">    {</a>
<a name="ln1443">        string m = &quot;&lt;w&gt;&quot;;</a>
<a name="ln1444">        const char key = _ring_slot_key(ring_types[i]);</a>
<a name="ln1445">        m += key;</a>
<a name="ln1446">        if (key == '&lt;')</a>
<a name="ln1447">            m += '&lt;';</a>
<a name="ln1448"> </a>
<a name="ln1449">        m += &quot;&lt;/w&gt; or &quot; + rings[i]-&gt;name(DESC_INVENTORY);</a>
<a name="ln1450">        mprf_nocap(&quot;%s&quot;, m.c_str());</a>
<a name="ln1451">    }</a>
<a name="ln1452">    flush_prev_message();</a>
<a name="ln1453"> </a>
<a name="ln1454">    // Deactivate choice from tile inventory.</a>
<a name="ln1455">    // FIXME: We need to be able to get the choice (item letter)n</a>
<a name="ln1456">    //        *without* the choice taking action by itself!</a>
<a name="ln1457">    int eqslot = EQ_NONE;</a>
<a name="ln1458"> </a>
<a name="ln1459">    mouse_control mc(MOUSE_MODE_PROMPT);</a>
<a name="ln1460">    int c;</a>
<a name="ln1461">    do</a>
<a name="ln1462">    {</a>
<a name="ln1463">        c = getchm();</a>
<a name="ln1464">        for (size_t i = 0; i &lt; slot_chars.size(); i++)</a>
<a name="ln1465">        {</a>
<a name="ln1466">            if (c == slot_chars[i]</a>
<a name="ln1467">                || c == _ring_slot_key(ring_types[i]))</a>
<a name="ln1468">            {</a>
<a name="ln1469">                eqslot = ring_types[i];</a>
<a name="ln1470">                c = ' ';</a>
<a name="ln1471">                break;</a>
<a name="ln1472">            }</a>
<a name="ln1473">        }</a>
<a name="ln1474">    } while (!key_is_escape(c) &amp;&amp; c != ' ' &amp;&amp; c != '?');</a>
<a name="ln1475"> </a>
<a name="ln1476">    clear_messages();</a>
<a name="ln1477"> </a>
<a name="ln1478">    if (c == '?')</a>
<a name="ln1479">        return EQ_NONE;</a>
<a name="ln1480">    else if (key_is_escape(c) || eqslot == EQ_NONE)</a>
<a name="ln1481">        return -2;</a>
<a name="ln1482"> </a>
<a name="ln1483">    return you.equip[eqslot];</a>
<a name="ln1484">}</a>
<a name="ln1485"> </a>
<a name="ln1486">// Checks whether a to-be-worn or to-be-removed item affects</a>
<a name="ln1487">// character stats and whether wearing/removing it could be fatal.</a>
<a name="ln1488">// If so, warns the player, or just returns false if quiet is true.</a>
<a name="ln1489">static bool _safe_to_remove_or_wear(const item_def &amp;item, bool remove, bool quiet)</a>
<a name="ln1490">{</a>
<a name="ln1491">    if (remove &amp;&amp; !safe_to_remove(item, quiet))</a>
<a name="ln1492">        return false;</a>
<a name="ln1493"> </a>
<a name="ln1494">    int prop_str = 0;</a>
<a name="ln1495">    int prop_dex = 0;</a>
<a name="ln1496">    int prop_int = 0;</a>
<a name="ln1497">    if (item.base_type == OBJ_JEWELLERY</a>
<a name="ln1498">        &amp;&amp; item_ident(item, ISFLAG_KNOW_PLUSES))</a>
<a name="ln1499">    {</a>
<a name="ln1500">        switch (item.sub_type)</a>
<a name="ln1501">        {</a>
<a name="ln1502">        case RING_STRENGTH:</a>
<a name="ln1503">            if (item.plus != 0)</a>
<a name="ln1504">                prop_str = item.plus;</a>
<a name="ln1505">            break;</a>
<a name="ln1506">        case RING_DEXTERITY:</a>
<a name="ln1507">            if (item.plus != 0)</a>
<a name="ln1508">                prop_dex = item.plus;</a>
<a name="ln1509">            break;</a>
<a name="ln1510">        case RING_INTELLIGENCE:</a>
<a name="ln1511">            if (item.plus != 0)</a>
<a name="ln1512">                prop_int = item.plus;</a>
<a name="ln1513">            break;</a>
<a name="ln1514">        default:</a>
<a name="ln1515">            break;</a>
<a name="ln1516">        }</a>
<a name="ln1517">    }</a>
<a name="ln1518">    else if (item.base_type == OBJ_ARMOUR &amp;&amp; item_type_known(item))</a>
<a name="ln1519">    {</a>
<a name="ln1520">        switch (item.brand)</a>
<a name="ln1521">        {</a>
<a name="ln1522">        case SPARM_STRENGTH:</a>
<a name="ln1523">            prop_str = 3;</a>
<a name="ln1524">            break;</a>
<a name="ln1525">        case SPARM_INTELLIGENCE:</a>
<a name="ln1526">            prop_int = 3;</a>
<a name="ln1527">            break;</a>
<a name="ln1528">        case SPARM_DEXTERITY:</a>
<a name="ln1529">            prop_dex = 3;</a>
<a name="ln1530">            break;</a>
<a name="ln1531">        default:</a>
<a name="ln1532">            break;</a>
<a name="ln1533">        }</a>
<a name="ln1534">    }</a>
<a name="ln1535"> </a>
<a name="ln1536">    if (is_artefact(item))</a>
<a name="ln1537">    {</a>
<a name="ln1538">        prop_str += artefact_known_property(item, ARTP_STRENGTH);</a>
<a name="ln1539">        prop_int += artefact_known_property(item, ARTP_INTELLIGENCE);</a>
<a name="ln1540">        prop_dex += artefact_known_property(item, ARTP_DEXTERITY);</a>
<a name="ln1541">    }</a>
<a name="ln1542"> </a>
<a name="ln1543">    if (!remove)</a>
<a name="ln1544">    {</a>
<a name="ln1545">        prop_str *= -1;</a>
<a name="ln1546">        prop_int *= -1;</a>
<a name="ln1547">        prop_dex *= -1;</a>
<a name="ln1548">    }</a>
<a name="ln1549">    stat_type red_stat = NUM_STATS;</a>
<a name="ln1550">    if (prop_str &gt;= you.strength() &amp;&amp; you.strength() &gt; 0)</a>
<a name="ln1551">        red_stat = STAT_STR;</a>
<a name="ln1552">    else if (prop_int &gt;= you.intel() &amp;&amp; you.intel() &gt; 0)</a>
<a name="ln1553">        red_stat = STAT_INT;</a>
<a name="ln1554">    else if (prop_dex &gt;= you.dex() &amp;&amp; you.dex() &gt; 0)</a>
<a name="ln1555">        red_stat = STAT_DEX;</a>
<a name="ln1556"> </a>
<a name="ln1557">    if (red_stat == NUM_STATS)</a>
<a name="ln1558">        return true;</a>
<a name="ln1559"> </a>
<a name="ln1560">    if (quiet)</a>
<a name="ln1561">        return false;</a>
<a name="ln1562"> </a>
<a name="ln1563">    string verb = &quot;&quot;;</a>
<a name="ln1564">    if (remove)</a>
<a name="ln1565">    {</a>
<a name="ln1566">        if (item.base_type == OBJ_WEAPONS)</a>
<a name="ln1567">            verb = &quot;Unwield&quot;;</a>
<a name="ln1568">        else</a>
<a name="ln1569">            verb = &quot;Remov&quot;; // -ing, not a typo</a>
<a name="ln1570">    }</a>
<a name="ln1571">    else</a>
<a name="ln1572">    {</a>
<a name="ln1573">        if (item.base_type == OBJ_WEAPONS)</a>
<a name="ln1574">            verb = &quot;Wield&quot;;</a>
<a name="ln1575">        else</a>
<a name="ln1576">            verb = &quot;Wear&quot;;</a>
<a name="ln1577">    }</a>
<a name="ln1578"> </a>
<a name="ln1579">    string prompt = make_stringf(&quot;%sing this item will reduce your %s to zero &quot;</a>
<a name="ln1580">                                 &quot;or below. Continue?&quot;, verb.c_str(),</a>
<a name="ln1581">                                 stat_desc(red_stat, SD_NAME));</a>
<a name="ln1582">    if (!yesno(prompt.c_str(), true, 'n', true, false))</a>
<a name="ln1583">    {</a>
<a name="ln1584">        canned_msg(MSG_OK);</a>
<a name="ln1585">        return false;</a>
<a name="ln1586">    }</a>
<a name="ln1587">    return true;</a>
<a name="ln1588">}</a>
<a name="ln1589"> </a>
<a name="ln1590">// Checks whether removing an item would cause flight to end and the</a>
<a name="ln1591">// player to fall to their death.</a>
<a name="ln1592">bool safe_to_remove(const item_def &amp;item, bool quiet)</a>
<a name="ln1593">{</a>
<a name="ln1594">    item_info inf = get_item_info(item);</a>
<a name="ln1595"> </a>
<a name="ln1596">    const bool grants_flight =</a>
<a name="ln1597">         inf.is_type(OBJ_JEWELLERY, RING_FLIGHT)</a>
<a name="ln1598">         || inf.base_type == OBJ_ARMOUR &amp;&amp; inf.brand == SPARM_FLYING</a>
<a name="ln1599">         || is_artefact(inf)</a>
<a name="ln1600">            &amp;&amp; artefact_known_property(inf, ARTP_FLY);</a>
<a name="ln1601"> </a>
<a name="ln1602">    // assumes item can't grant flight twice</a>
<a name="ln1603">    const bool removing_ends_flight = you.airborne()</a>
<a name="ln1604">          &amp;&amp; !you.racial_permanent_flight()</a>
<a name="ln1605">          &amp;&amp; !you.attribute[ATTR_FLIGHT_UNCANCELLABLE]</a>
<a name="ln1606">          &amp;&amp; (you.evokable_flight() == 1);</a>
<a name="ln1607"> </a>
<a name="ln1608">    const dungeon_feature_type feat = grd(you.pos());</a>
<a name="ln1609"> </a>
<a name="ln1610">    if (grants_flight &amp;&amp; removing_ends_flight</a>
<a name="ln1611">        &amp;&amp; is_feat_dangerous(feat, false, true))</a>
<a name="ln1612">    {</a>
<a name="ln1613">        if (!quiet)</a>
<a name="ln1614">            mpr(&quot;Losing flight right now would be fatal!&quot;);</a>
<a name="ln1615">        return false;</a>
<a name="ln1616">    }</a>
<a name="ln1617"> </a>
<a name="ln1618">    return true;</a>
<a name="ln1619">}</a>
<a name="ln1620"> </a>
<a name="ln1621">// Assumptions:</a>
<a name="ln1622">// item is an item in inventory or on the floor where the player is standing</a>
<a name="ln1623">// EQ_LEFT_RING and EQ_RIGHT_RING are both occupied, and item is not</a>
<a name="ln1624">// in one of those slots.</a>
<a name="ln1625">//</a>
<a name="ln1626">// Does not do amulets.</a>
<a name="ln1627">static bool _swap_rings(const item_def&amp; to_puton)</a>
<a name="ln1628">{</a>
<a name="ln1629">    vector&lt;equipment_type&gt; ring_types = _current_ring_types();</a>
<a name="ln1630">    const int num_rings = ring_types.size();</a>
<a name="ln1631">    int unwanted = 0;</a>
<a name="ln1632">    int last_inscribed = 0;</a>
<a name="ln1633">    int cursed = 0;</a>
<a name="ln1634">    int inscribed = 0;</a>
<a name="ln1635">    int melded = 0; // Both melded rings and unavailable slots.</a>
<a name="ln1636">    int available = 0;</a>
<a name="ln1637">    bool all_same = true;</a>
<a name="ln1638">    item_def* first_ring = nullptr;</a>
<a name="ln1639">    for (auto eq : ring_types)</a>
<a name="ln1640">    {</a>
<a name="ln1641">        item_def* ring = you.slot_item(eq, true);</a>
<a name="ln1642">        if (!you_can_wear(eq, true) || you.melded[eq])</a>
<a name="ln1643">            melded++;</a>
<a name="ln1644">        else if (ring != nullptr)</a>
<a name="ln1645">        {</a>
<a name="ln1646">            if (first_ring == nullptr)</a>
<a name="ln1647">                first_ring = ring;</a>
<a name="ln1648">            else if (all_same)</a>
<a name="ln1649">            {</a>
<a name="ln1650">                if (ring-&gt;sub_type != first_ring-&gt;sub_type</a>
<a name="ln1651">                    || ring-&gt;plus  != first_ring-&gt;plus</a>
<a name="ln1652">                    || is_artefact(*ring) || is_artefact(*first_ring))</a>
<a name="ln1653">                {</a>
<a name="ln1654">                    all_same = false;</a>
<a name="ln1655">                }</a>
<a name="ln1656">            }</a>
<a name="ln1657"> </a>
<a name="ln1658">            if (ring-&gt;cursed())</a>
<a name="ln1659">                cursed++;</a>
<a name="ln1660">            else if (strstr(ring-&gt;inscription.c_str(), &quot;=R&quot;))</a>
<a name="ln1661">            {</a>
<a name="ln1662">                inscribed++;</a>
<a name="ln1663">                last_inscribed = you.equip[eq];</a>
<a name="ln1664">            }</a>
<a name="ln1665">            else</a>
<a name="ln1666">            {</a>
<a name="ln1667">                available++;</a>
<a name="ln1668">                unwanted = you.equip[eq];</a>
<a name="ln1669">            }</a>
<a name="ln1670">        }</a>
<a name="ln1671">    }</a>
<a name="ln1672"> </a>
<a name="ln1673">    // If the only swappable rings are inscribed =R, go ahead and use them.</a>
<a name="ln1674">    if (available == 0 &amp;&amp; inscribed &gt; 0)</a>
<a name="ln1675">    {</a>
<a name="ln1676">        available += inscribed;</a>
<a name="ln1677">        unwanted = last_inscribed;</a>
<a name="ln1678">    }</a>
<a name="ln1679"> </a>
<a name="ln1680">    // We can't put a ring on, because we're wearing all cursed ones.</a>
<a name="ln1681">    if (melded == num_rings)</a>
<a name="ln1682">    {</a>
<a name="ln1683">        // Shouldn't happen, because hogs and bats can't put on jewellery at</a>
<a name="ln1684">        // all and thus won't get this far.</a>
<a name="ln1685">        mpr(&quot;You can't wear that in your present form.&quot;);</a>
<a name="ln1686">        return false;</a>
<a name="ln1687">    }</a>
<a name="ln1688">    else if (available == 0)</a>
<a name="ln1689">    {</a>
<a name="ln1690">        mprf(&quot;You're already wearing %s cursed ring%s!%s&quot;,</a>
<a name="ln1691">             number_in_words(cursed).c_str(),</a>
<a name="ln1692">             (cursed == 1 ? &quot;&quot; : &quot;s&quot;),</a>
<a name="ln1693">             (cursed &gt; 2 ? &quot; Isn't that enough for you?&quot; : &quot;&quot;));</a>
<a name="ln1694">        return false;</a>
<a name="ln1695">    }</a>
<a name="ln1696">    // The simple case - only one available ring.</a>
<a name="ln1697">    // If the jewellery_prompt option is true, always allow choosing the</a>
<a name="ln1698">    // ring slot (even if we still have empty slots).</a>
<a name="ln1699">    else if (available == 1 &amp;&amp; !Options.jewellery_prompt)</a>
<a name="ln1700">    {</a>
<a name="ln1701">        if (!remove_ring(unwanted, false))</a>
<a name="ln1702">            return false;</a>
<a name="ln1703">    }</a>
<a name="ln1704">    // We can't put a ring on without swapping - because we found</a>
<a name="ln1705">    // multiple available rings.</a>
<a name="ln1706">    else</a>
<a name="ln1707">    {</a>
<a name="ln1708">        // Don't prompt if all the rings are the same.</a>
<a name="ln1709">        if (!all_same || Options.jewellery_prompt)</a>
<a name="ln1710">            unwanted = _prompt_ring_to_remove();</a>
<a name="ln1711"> </a>
<a name="ln1712">        if (unwanted == EQ_NONE)</a>
<a name="ln1713">        {</a>
<a name="ln1714">            // do this here rather than in remove_ring so that the custom</a>
<a name="ln1715">            // message is visible.</a>
<a name="ln1716">            unwanted = prompt_invent_item(</a>
<a name="ln1717">                    &quot;You're wearing all the rings you can. Remove which one?&quot;,</a>
<a name="ln1718">                    menu_type::invlist, OSEL_UNCURSED_WORN_RINGS, OPER_REMOVE,</a>
<a name="ln1719">                    invprompt_flag::no_warning | invprompt_flag::hide_known);</a>
<a name="ln1720">        }</a>
<a name="ln1721"> </a>
<a name="ln1722">        // Cancelled:</a>
<a name="ln1723">        if (unwanted &lt; 0)</a>
<a name="ln1724">        {</a>
<a name="ln1725">            canned_msg(MSG_OK);</a>
<a name="ln1726">            return false;</a>
<a name="ln1727">        }</a>
<a name="ln1728"> </a>
<a name="ln1729">        if (!remove_ring(unwanted, false))</a>
<a name="ln1730">            return false;</a>
<a name="ln1731">    }</a>
<a name="ln1732"> </a>
<a name="ln1733">    // Put on the new ring.</a>
<a name="ln1734">    start_delay&lt;JewelleryOnDelay&gt;(1, to_puton);</a>
<a name="ln1735"> </a>
<a name="ln1736">    return true;</a>
<a name="ln1737">}</a>
<a name="ln1738"> </a>
<a name="ln1739">static equipment_type _choose_ring_slot()</a>
<a name="ln1740">{</a>
<a name="ln1741">    clear_messages();</a>
<a name="ln1742"> </a>
<a name="ln1743">    mprf(MSGCH_PROMPT,</a>
<a name="ln1744">         &quot;Put ring on which %s? (&lt;w&gt;Esc&lt;/w&gt; to cancel)&quot;, you.hand_name(false).c_str());</a>
<a name="ln1745"> </a>
<a name="ln1746">    const vector&lt;equipment_type&gt; slots = _current_ring_types();</a>
<a name="ln1747">    for (auto eq : slots)</a>
<a name="ln1748">    {</a>
<a name="ln1749">        string msg = &quot;&lt;w&gt;&quot;;</a>
<a name="ln1750">        const char key = _ring_slot_key(eq);</a>
<a name="ln1751">        msg += key;</a>
<a name="ln1752">        if (key == '&lt;')</a>
<a name="ln1753">            msg += '&lt;';</a>
<a name="ln1754"> </a>
<a name="ln1755">        item_def* ring = you.slot_item(eq, true);</a>
<a name="ln1756">        if (ring)</a>
<a name="ln1757">            msg += &quot;&lt;/w&gt; or &quot; + ring-&gt;name(DESC_INVENTORY);</a>
<a name="ln1758">        else</a>
<a name="ln1759">            msg += &quot;&lt;/w&gt; - no ring&quot;;</a>
<a name="ln1760"> </a>
<a name="ln1761">        if (eq == EQ_LEFT_RING)</a>
<a name="ln1762">            msg += &quot; (left)&quot;;</a>
<a name="ln1763">        else if (eq == EQ_RIGHT_RING)</a>
<a name="ln1764">            msg += &quot; (right)&quot;;</a>
<a name="ln1765">        else if (eq == EQ_RING_AMULET)</a>
<a name="ln1766">            msg += &quot; (amulet)&quot;;</a>
<a name="ln1767">        mprf_nocap(&quot;%s&quot;, msg.c_str());</a>
<a name="ln1768">    }</a>
<a name="ln1769">    flush_prev_message();</a>
<a name="ln1770"> </a>
<a name="ln1771">    equipment_type eqslot = EQ_NONE;</a>
<a name="ln1772">    mouse_control mc(MOUSE_MODE_PROMPT);</a>
<a name="ln1773">    int c;</a>
<a name="ln1774">    do</a>
<a name="ln1775">    {</a>
<a name="ln1776">        c = getchm();</a>
<a name="ln1777">        for (auto eq : slots)</a>
<a name="ln1778">        {</a>
<a name="ln1779">            if (c == _ring_slot_key(eq)</a>
<a name="ln1780">                || (you.slot_item(eq, true)</a>
<a name="ln1781">                    &amp;&amp; c == index_to_letter(you.slot_item(eq, true)-&gt;link)))</a>
<a name="ln1782">            {</a>
<a name="ln1783">                eqslot = eq;</a>
<a name="ln1784">                c = ' ';</a>
<a name="ln1785">                break;</a>
<a name="ln1786">            }</a>
<a name="ln1787">        }</a>
<a name="ln1788">    } while (!key_is_escape(c) &amp;&amp; c != ' ');</a>
<a name="ln1789"> </a>
<a name="ln1790">    clear_messages();</a>
<a name="ln1791"> </a>
<a name="ln1792">    return eqslot;</a>
<a name="ln1793">}</a>
<a name="ln1794"> </a>
<a name="ln1795">// Is it possible to put on the given item in a jewellery slot?</a>
<a name="ln1796">// Preconditions:</a>
<a name="ln1797">// - item is not already equipped in a jewellery slot</a>
<a name="ln1798">static bool _can_puton_jewellery(const item_def &amp;item)</a>
<a name="ln1799">{</a>
<a name="ln1800">    // TODO: between this function, _puton_item, _swap_rings, and remove_ring,</a>
<a name="ln1801">    // there's a bit of duplicated work, and sep. of concerns not clear</a>
<a name="ln1802">    if (&amp;item == you.weapon())</a>
<a name="ln1803">    {</a>
<a name="ln1804">        mpr(&quot;You are wielding that object.&quot;);</a>
<a name="ln1805">        return false;</a>
<a name="ln1806">    }</a>
<a name="ln1807"> </a>
<a name="ln1808">    if (item.base_type != OBJ_JEWELLERY)</a>
<a name="ln1809">    {</a>
<a name="ln1810">        mpr(&quot;You can only put on jewellery.&quot;);</a>
<a name="ln1811">        return false;</a>
<a name="ln1812">    }</a>
<a name="ln1813"> </a>
<a name="ln1814">    const bool is_amulet = jewellery_is_amulet(item);</a>
<a name="ln1815"> </a>
<a name="ln1816">    if (is_amulet &amp;&amp; !you_can_wear(EQ_AMULET, true)</a>
<a name="ln1817">        || !is_amulet &amp;&amp; !you_can_wear(EQ_RINGS, true))</a>
<a name="ln1818">    {</a>
<a name="ln1819">        mpr(&quot;You can't wear that in your present form.&quot;);</a>
<a name="ln1820">        return false;</a>
<a name="ln1821">    }</a>
<a name="ln1822"> </a>
<a name="ln1823">    // Make sure there's at least one slot where we could equip this item</a>
<a name="ln1824">    if (is_amulet)</a>
<a name="ln1825">    {</a>
<a name="ln1826">        int existing = you.equip[EQ_AMULET];</a>
<a name="ln1827">        if (existing != -1 &amp;&amp; you.inv[existing].cursed())</a>
<a name="ln1828">        {</a>
<a name="ln1829">            mprf(&quot;%s is stuck to you!&quot;,</a>
<a name="ln1830">                 you.inv[existing].name(DESC_YOUR).c_str());</a>
<a name="ln1831">            return false;</a>
<a name="ln1832">        }</a>
<a name="ln1833">        else</a>
<a name="ln1834">            return true;</a>
<a name="ln1835">    }</a>
<a name="ln1836">    // The ring case is a bit more complicated</a>
<a name="ln1837">    else</a>
<a name="ln1838">    {</a>
<a name="ln1839">        const vector&lt;equipment_type&gt; slots = _current_ring_types();</a>
<a name="ln1840">        int melded = 0;</a>
<a name="ln1841">        int cursed = 0;</a>
<a name="ln1842">        for (auto eq : slots)</a>
<a name="ln1843">        {</a>
<a name="ln1844">            if (!you_can_wear(eq, true) || you.melded[eq])</a>
<a name="ln1845">            {</a>
<a name="ln1846">                melded++;</a>
<a name="ln1847">                continue;</a>
<a name="ln1848">            }</a>
<a name="ln1849">            int existing = you.equip[eq];</a>
<a name="ln1850">            if (existing != -1 &amp;&amp; you.inv[existing].cursed())</a>
<a name="ln1851">                cursed++;</a>
<a name="ln1852">            else</a>
<a name="ln1853">                // We found an available slot. We're done.</a>
<a name="ln1854">                return true;</a>
<a name="ln1855">        }</a>
<a name="ln1856">        // If we got this far, there are no available slots.</a>
<a name="ln1857">        if (melded == (int)slots.size())</a>
<a name="ln1858">            mpr(&quot;You can't wear that in your present form.&quot;);</a>
<a name="ln1859">        else</a>
<a name="ln1860">            mprf(&quot;You're already wearing %s cursed ring%s!%s&quot;,</a>
<a name="ln1861">                 number_in_words(cursed).c_str(),</a>
<a name="ln1862">                 (cursed == 1 ? &quot;&quot; : &quot;s&quot;),</a>
<a name="ln1863">                 (cursed &gt; 2 ? &quot; Isn't that enough for you?&quot; : &quot;&quot;));</a>
<a name="ln1864">        return false;</a>
<a name="ln1865">    }</a>
<a name="ln1866">}</a>
<a name="ln1867"> </a>
<a name="ln1868">// Put on a particular ring or amulet</a>
<a name="ln1869">static bool _puton_item(const item_def &amp;item, bool prompt_slot,</a>
<a name="ln1870">                        bool check_for_inscriptions)</a>
<a name="ln1871">{</a>
<a name="ln1872">    vector&lt;equipment_type&gt; current_jewellery = _current_ring_types();</a>
<a name="ln1873">    current_jewellery.push_back(EQ_AMULET);</a>
<a name="ln1874"> </a>
<a name="ln1875">    for (auto eq : current_jewellery)</a>
<a name="ln1876">        if (&amp;item == you.slot_item(eq, true))</a>
<a name="ln1877">        {</a>
<a name="ln1878">            // &quot;Putting on&quot; an equipped item means taking it off.</a>
<a name="ln1879">            if (Options.equip_unequip)</a>
<a name="ln1880">                // TODO: why invert the return value here? failing to remove</a>
<a name="ln1881">                // a ring is equivalent to successfully putting one on?</a>
<a name="ln1882">                return !remove_ring(item.link);</a>
<a name="ln1883">            else</a>
<a name="ln1884">            {</a>
<a name="ln1885">                mpr(&quot;You're already wearing that object!&quot;);</a>
<a name="ln1886">                return false;</a>
<a name="ln1887">            }</a>
<a name="ln1888">        }</a>
<a name="ln1889"> </a>
<a name="ln1890">    if (!_can_puton_jewellery(item))</a>
<a name="ln1891">        return false;</a>
<a name="ln1892"> </a>
<a name="ln1893">    // It looks to be possible to equip this item. Before going any further,</a>
<a name="ln1894">    // we should prompt the user with any warnings that come with trying to</a>
<a name="ln1895">    // put it on, except when they have already been prompted with them</a>
<a name="ln1896">    // from switching rings.</a>
<a name="ln1897">    if (check_for_inscriptions &amp;&amp; !check_warning_inscriptions(item, OPER_PUTON))</a>
<a name="ln1898">    {</a>
<a name="ln1899">        canned_msg(MSG_OK);</a>
<a name="ln1900">        return false;</a>
<a name="ln1901">    }</a>
<a name="ln1902"> </a>
<a name="ln1903">    const bool is_amulet = jewellery_is_amulet(item);</a>
<a name="ln1904"> </a>
<a name="ln1905">    const vector&lt;equipment_type&gt; ring_types = _current_ring_types();</a>
<a name="ln1906"> </a>
<a name="ln1907">    if (!is_amulet)     // i.e. it's a ring</a>
<a name="ln1908">    {</a>
<a name="ln1909">        // Check whether there are any unused ring slots</a>
<a name="ln1910">        bool need_swap = true;</a>
<a name="ln1911">        for (auto eq : ring_types)</a>
<a name="ln1912">        {</a>
<a name="ln1913">            if (!you.slot_item(eq, true))</a>
<a name="ln1914">            {</a>
<a name="ln1915">                need_swap = false;</a>
<a name="ln1916">                break;</a>
<a name="ln1917">            }</a>
<a name="ln1918">        }</a>
<a name="ln1919"> </a>
<a name="ln1920">        // No unused ring slots. Swap out a worn ring for the new one.</a>
<a name="ln1921">        if (need_swap)</a>
<a name="ln1922">            return _swap_rings(item);</a>
<a name="ln1923">    }</a>
<a name="ln1924">    else if (you.slot_item(EQ_AMULET, true))</a>
<a name="ln1925">    {</a>
<a name="ln1926">        // Remove the previous one.</a>
<a name="ln1927">        if (!remove_ring(you.equip[EQ_AMULET], true))</a>
<a name="ln1928">            return false;</a>
<a name="ln1929"> </a>
<a name="ln1930">        // Check for stat loss.</a>
<a name="ln1931">        if (!_safe_to_remove_or_wear(item, false))</a>
<a name="ln1932">            return false;</a>
<a name="ln1933"> </a>
<a name="ln1934">        // Put on the new amulet.</a>
<a name="ln1935">        start_delay&lt;JewelleryOnDelay&gt;(1, item);</a>
<a name="ln1936"> </a>
<a name="ln1937">        // Assume it's going to succeed.</a>
<a name="ln1938">        return true;</a>
<a name="ln1939">    }</a>
<a name="ln1940">    // At this point, we know there's an empty slot for the ring/amulet we're</a>
<a name="ln1941">    // trying to equip.</a>
<a name="ln1942"> </a>
<a name="ln1943">    // Check for stat loss.</a>
<a name="ln1944">    if (!_safe_to_remove_or_wear(item, false))</a>
<a name="ln1945">        return false;</a>
<a name="ln1946"> </a>
<a name="ln1947">    equipment_type hand_used = EQ_NONE;</a>
<a name="ln1948"> </a>
<a name="ln1949">    if (is_amulet)</a>
<a name="ln1950">        hand_used = EQ_AMULET;</a>
<a name="ln1951">    else if (prompt_slot)</a>
<a name="ln1952">    {</a>
<a name="ln1953">        // Prompt for a slot, even if we have empty ring slots.</a>
<a name="ln1954">        hand_used = _choose_ring_slot();</a>
<a name="ln1955"> </a>
<a name="ln1956">        if (hand_used == EQ_NONE)</a>
<a name="ln1957">        {</a>
<a name="ln1958">            canned_msg(MSG_OK);</a>
<a name="ln1959">            return false;</a>
<a name="ln1960">        }</a>
<a name="ln1961">        // Allow swapping out a ring.</a>
<a name="ln1962">        else if (you.slot_item(hand_used, true))</a>
<a name="ln1963">        {</a>
<a name="ln1964">            if (!remove_ring(you.equip[hand_used], false))</a>
<a name="ln1965">                return false;</a>
<a name="ln1966"> </a>
<a name="ln1967">            start_delay&lt;JewelleryOnDelay&gt;(1, item);</a>
<a name="ln1968">            return true;</a>
<a name="ln1969">        }</a>
<a name="ln1970">    }</a>
<a name="ln1971">    else</a>
<a name="ln1972">    {</a>
<a name="ln1973">        for (auto eq : ring_types)</a>
<a name="ln1974">        {</a>
<a name="ln1975">            if (!you.slot_item(eq, true))</a>
<a name="ln1976">            {</a>
<a name="ln1977">                hand_used = eq;</a>
<a name="ln1978">                break;</a>
<a name="ln1979">            }</a>
<a name="ln1980">        }</a>
<a name="ln1981">    }</a>
<a name="ln1982"> </a>
<a name="ln1983">    const unsigned int old_talents = your_talents(false).size();</a>
<a name="ln1984"> </a>
<a name="ln1985">    // Actually equip the item.</a>
<a name="ln1986">    int item_slot = _get_item_slot_maybe_with_move(item);</a>
<a name="ln1987">    equip_item(hand_used, item_slot);</a>
<a name="ln1988"> </a>
<a name="ln1989">    check_item_hint(you.inv[item_slot], old_talents);</a>
<a name="ln1990">#ifdef USE_TILE_LOCAL</a>
<a name="ln1991">    if (your_talents(false).size() != old_talents)</a>
<a name="ln1992">    {</a>
<a name="ln1993">        tiles.layout_statcol();</a>
<a name="ln1994">        redraw_screen();</a>
<a name="ln1995">    }</a>
<a name="ln1996">#endif</a>
<a name="ln1997"> </a>
<a name="ln1998">    // Putting on jewellery is fast.</a>
<a name="ln1999">    you.time_taken /= 2;</a>
<a name="ln2000">    you.turn_is_over = true;</a>
<a name="ln2001"> </a>
<a name="ln2002">    return true;</a>
<a name="ln2003">}</a>
<a name="ln2004"> </a>
<a name="ln2005">// Put on a ring or amulet. (Most of the work is in _puton_item.)</a>
<a name="ln2006">bool puton_ring(const item_def &amp;to_puton, bool allow_prompt,</a>
<a name="ln2007">                bool check_for_inscriptions)</a>
<a name="ln2008">{</a>
<a name="ln2009">    if (you.berserk())</a>
<a name="ln2010">    {</a>
<a name="ln2011">        canned_msg(MSG_TOO_BERSERK);</a>
<a name="ln2012">        return false;</a>
<a name="ln2013">    }</a>
<a name="ln2014">    if (!to_puton.defined())</a>
<a name="ln2015">    {</a>
<a name="ln2016">        mpr(&quot;You don't have any such object.&quot;);</a>
<a name="ln2017">        return false;</a>
<a name="ln2018">    }</a>
<a name="ln2019">    if (to_puton.pos != ITEM_IN_INVENTORY</a>
<a name="ln2020">        &amp;&amp; !_can_move_item_from_floor_to_inv(to_puton))</a>
<a name="ln2021">    {</a>
<a name="ln2022">        return false;</a>
<a name="ln2023">    }</a>
<a name="ln2024"> </a>
<a name="ln2025">    bool prompt = allow_prompt ? Options.jewellery_prompt : false;</a>
<a name="ln2026">    return _puton_item(to_puton, prompt, check_for_inscriptions);</a>
<a name="ln2027">}</a>
<a name="ln2028"> </a>
<a name="ln2029">// Wraps version of puton_ring with item_def param. If slot is -1, prompt for</a>
<a name="ln2030">// which item to put on; otherwise, pass on the item in inventory slot</a>
<a name="ln2031">bool puton_ring(int slot, bool allow_prompt, bool check_for_inscriptions)</a>
<a name="ln2032">{</a>
<a name="ln2033">    item_def *to_puton_ptr = nullptr;</a>
<a name="ln2034">    if (slot == -1)</a>
<a name="ln2035">    {</a>
<a name="ln2036">        if (!use_an_item(to_puton_ptr, OBJ_JEWELLERY, OPER_PUTON,</a>
<a name="ln2037">                        &quot;Put on which piece of jewellery (* to show all)?&quot;))</a>
<a name="ln2038">        {</a>
<a name="ln2039">            return false;</a>
<a name="ln2040">        }</a>
<a name="ln2041">    }</a>
<a name="ln2042">    else</a>
<a name="ln2043">        to_puton_ptr = &amp;you.inv[slot];</a>
<a name="ln2044"> </a>
<a name="ln2045">    return puton_ring(*to_puton_ptr, allow_prompt, check_for_inscriptions);</a>
<a name="ln2046">}</a>
<a name="ln2047"> </a>
<a name="ln2048">// Remove the amulet/ring at given inventory slot (or, if slot is -1, prompt</a>
<a name="ln2049">// for which piece of jewellery to remove)</a>
<a name="ln2050">bool remove_ring(int slot, bool announce)</a>
<a name="ln2051">{</a>
<a name="ln2052">    equipment_type hand_used = EQ_NONE;</a>
<a name="ln2053">    int ring_wear_2;</a>
<a name="ln2054">    bool has_jewellery = false;</a>
<a name="ln2055">    bool has_melded = false;</a>
<a name="ln2056">    const vector&lt;equipment_type&gt; jewellery_slots = _current_jewellery_types();</a>
<a name="ln2057"> </a>
<a name="ln2058">    for (auto eq : jewellery_slots)</a>
<a name="ln2059">    {</a>
<a name="ln2060">        if (you.slot_item(eq))</a>
<a name="ln2061">        {</a>
<a name="ln2062">            if (has_jewellery || Options.jewellery_prompt)</a>
<a name="ln2063">            {</a>
<a name="ln2064">                // At least one other piece, which means we'll have to ask</a>
<a name="ln2065">                hand_used = EQ_NONE;</a>
<a name="ln2066">            }</a>
<a name="ln2067">            else</a>
<a name="ln2068">                hand_used = eq;</a>
<a name="ln2069"> </a>
<a name="ln2070">            has_jewellery = true;</a>
<a name="ln2071">        }</a>
<a name="ln2072">        else if (you.melded[eq])</a>
<a name="ln2073">            has_melded = true;</a>
<a name="ln2074">    }</a>
<a name="ln2075"> </a>
<a name="ln2076">    if (!has_jewellery)</a>
<a name="ln2077">    {</a>
<a name="ln2078">        if (has_melded)</a>
<a name="ln2079">            mpr(&quot;You aren't wearing any unmelded rings or amulets.&quot;);</a>
<a name="ln2080">        else</a>
<a name="ln2081">            mpr(&quot;You aren't wearing any rings or amulets.&quot;);</a>
<a name="ln2082"> </a>
<a name="ln2083">        return false;</a>
<a name="ln2084">    }</a>
<a name="ln2085"> </a>
<a name="ln2086">    if (you.berserk())</a>
<a name="ln2087">    {</a>
<a name="ln2088">        canned_msg(MSG_TOO_BERSERK);</a>
<a name="ln2089">        return false;</a>
<a name="ln2090">    }</a>
<a name="ln2091"> </a>
<a name="ln2092">    // If more than one equipment slot had jewellery, we need to figure out</a>
<a name="ln2093">    // which one to remove from.</a>
<a name="ln2094">    if (hand_used == EQ_NONE)</a>
<a name="ln2095">    {</a>
<a name="ln2096">        const int equipn =</a>
<a name="ln2097">            (slot == -1)? prompt_invent_item(&quot;Remove which piece of jewellery?&quot;,</a>
<a name="ln2098">                                             menu_type::invlist,</a>
<a name="ln2099">                                             OBJ_JEWELLERY,</a>
<a name="ln2100">                                             OPER_REMOVE,</a>
<a name="ln2101">                                             invprompt_flag::no_warning</a>
<a name="ln2102">                                                | invprompt_flag::hide_known)</a>
<a name="ln2103">                        : slot;</a>
<a name="ln2104"> </a>
<a name="ln2105">        if (prompt_failed(equipn))</a>
<a name="ln2106">            return false;</a>
<a name="ln2107"> </a>
<a name="ln2108">        hand_used = item_equip_slot(you.inv[equipn]);</a>
<a name="ln2109">        if (hand_used == EQ_NONE)</a>
<a name="ln2110">        {</a>
<a name="ln2111">            mpr(&quot;You aren't wearing that.&quot;);</a>
<a name="ln2112">            return false;</a>
<a name="ln2113">        }</a>
<a name="ln2114">        else if (you.inv[equipn].base_type != OBJ_JEWELLERY)</a>
<a name="ln2115">        {</a>
<a name="ln2116">            mpr(&quot;That isn't a piece of jewellery.&quot;);</a>
<a name="ln2117">            return false;</a>
<a name="ln2118">        }</a>
<a name="ln2119">    }</a>
<a name="ln2120"> </a>
<a name="ln2121">    if (you.equip[hand_used] == -1)</a>
<a name="ln2122">    {</a>
<a name="ln2123">        mpr(&quot;I don't think you really meant that.&quot;);</a>
<a name="ln2124">        return false;</a>
<a name="ln2125">    }</a>
<a name="ln2126">    else if (you.melded[hand_used])</a>
<a name="ln2127">    {</a>
<a name="ln2128">        mpr(&quot;You can't take that off while it's melded.&quot;);</a>
<a name="ln2129">        return false;</a>
<a name="ln2130">    }</a>
<a name="ln2131">    else if (hand_used == EQ_AMULET</a>
<a name="ln2132">        &amp;&amp; you.equip[EQ_RING_AMULET] != -1)</a>
<a name="ln2133">    {</a>
<a name="ln2134">        // This can be removed in the future if more ring amulets are added.</a>
<a name="ln2135">        ASSERT(player_equip_unrand(UNRAND_FINGER_AMULET));</a>
<a name="ln2136"> </a>
<a name="ln2137">        mpr(&quot;The amulet cannot be taken off without first removing the ring!&quot;);</a>
<a name="ln2138">        return false;</a>
<a name="ln2139">    }</a>
<a name="ln2140"> </a>
<a name="ln2141">    if (!check_warning_inscriptions(you.inv[you.equip[hand_used]],</a>
<a name="ln2142">                                    OPER_REMOVE))</a>
<a name="ln2143">    {</a>
<a name="ln2144">        canned_msg(MSG_OK);</a>
<a name="ln2145">        return false;</a>
<a name="ln2146">    }</a>
<a name="ln2147"> </a>
<a name="ln2148">    if (you.inv[you.equip[hand_used]].cursed())</a>
<a name="ln2149">    {</a>
<a name="ln2150">        if (announce)</a>
<a name="ln2151">        {</a>
<a name="ln2152">            mprf(&quot;%s is stuck to you!&quot;,</a>
<a name="ln2153">                 you.inv[you.equip[hand_used]].name(DESC_YOUR).c_str());</a>
<a name="ln2154">        }</a>
<a name="ln2155">        else</a>
<a name="ln2156">            mpr(&quot;It's stuck to you!&quot;);</a>
<a name="ln2157"> </a>
<a name="ln2158">        set_ident_flags(you.inv[you.equip[hand_used]], ISFLAG_KNOW_CURSE);</a>
<a name="ln2159">        return false;</a>
<a name="ln2160">    }</a>
<a name="ln2161"> </a>
<a name="ln2162">    ring_wear_2 = you.equip[hand_used];</a>
<a name="ln2163"> </a>
<a name="ln2164">    // Remove the ring.</a>
<a name="ln2165">    if (!_safe_to_remove_or_wear(you.inv[ring_wear_2], true))</a>
<a name="ln2166">        return false;</a>
<a name="ln2167"> </a>
<a name="ln2168">#ifdef USE_SOUND</a>
<a name="ln2169">    parse_sound(REMOVE_JEWELLERY_SOUND);</a>
<a name="ln2170">#endif</a>
<a name="ln2171">    mprf(&quot;You remove %s.&quot;, you.inv[ring_wear_2].name(DESC_YOUR).c_str());</a>
<a name="ln2172">#ifdef USE_TILE_LOCAL</a>
<a name="ln2173">    const unsigned int old_talents = your_talents(false).size();</a>
<a name="ln2174">#endif</a>
<a name="ln2175">    unequip_item(hand_used);</a>
<a name="ln2176">#ifdef USE_TILE_LOCAL</a>
<a name="ln2177">    if (your_talents(false).size() != old_talents)</a>
<a name="ln2178">    {</a>
<a name="ln2179">        tiles.layout_statcol();</a>
<a name="ln2180">        redraw_screen();</a>
<a name="ln2181">    }</a>
<a name="ln2182">#endif</a>
<a name="ln2183"> </a>
<a name="ln2184">    you.time_taken /= 2;</a>
<a name="ln2185">    you.turn_is_over = true;</a>
<a name="ln2186"> </a>
<a name="ln2187">    return true;</a>
<a name="ln2188">}</a>
<a name="ln2189"> </a>
<a name="ln2190">void prompt_inscribe_item()</a>
<a name="ln2191">{</a>
<a name="ln2192">    if (inv_count() &lt; 1)</a>
<a name="ln2193">    {</a>
<a name="ln2194">        mpr(&quot;You don't have anything to inscribe.&quot;);</a>
<a name="ln2195">        return;</a>
<a name="ln2196">    }</a>
<a name="ln2197"> </a>
<a name="ln2198">    int item_slot = prompt_invent_item(&quot;Inscribe which item?&quot;,</a>
<a name="ln2199">                                       menu_type::invlist, OSEL_ANY);</a>
<a name="ln2200"> </a>
<a name="ln2201">    if (prompt_failed(item_slot))</a>
<a name="ln2202">        return;</a>
<a name="ln2203"> </a>
<a name="ln2204">    inscribe_item(you.inv[item_slot]);</a>
<a name="ln2205">}</a>
<a name="ln2206"> </a>
<a name="ln2207">void drink(item_def* potion)</a>
<a name="ln2208">{</a>
<a name="ln2209">    if (you_foodless() &amp;&amp; you.species != SP_VAMPIRE)</a>
<a name="ln2210">    {</a>
<a name="ln2211">        mpr(&quot;You can't drink.&quot;);</a>
<a name="ln2212">        return;</a>
<a name="ln2213">    }</a>
<a name="ln2214"> </a>
<a name="ln2215">    if (you.berserk())</a>
<a name="ln2216">    {</a>
<a name="ln2217">        canned_msg(MSG_TOO_BERSERK);</a>
<a name="ln2218">        return;</a>
<a name="ln2219">    }</a>
<a name="ln2220"> </a>
<a name="ln2221">    if (you.duration[DUR_NO_POTIONS])</a>
<a name="ln2222">    {</a>
<a name="ln2223">        mpr(&quot;You cannot drink potions in your current state!&quot;);</a>
<a name="ln2224">        return;</a>
<a name="ln2225">    }</a>
<a name="ln2226"> </a>
<a name="ln2227">    if (!potion)</a>
<a name="ln2228">    {</a>
<a name="ln2229">        if (!use_an_item(potion, OBJ_POTIONS, OPER_QUAFF, &quot;Drink which item (* to show all)?&quot;))</a>
<a name="ln2230">            return;</a>
<a name="ln2231">    }</a>
<a name="ln2232"> </a>
<a name="ln2233">    if (potion-&gt;base_type != OBJ_POTIONS)</a>
<a name="ln2234">    {</a>
<a name="ln2235">        mpr(&quot;You can't drink that!&quot;);</a>
<a name="ln2236">        return;</a>
<a name="ln2237">    }</a>
<a name="ln2238"> </a>
<a name="ln2239">    const bool alreadyknown = item_type_known(*potion);</a>
<a name="ln2240"> </a>
<a name="ln2241">    if (alreadyknown &amp;&amp; is_bad_item(*potion))</a>
<a name="ln2242">    {</a>
<a name="ln2243">        canned_msg(MSG_UNTHINKING_ACT);</a>
<a name="ln2244">        return;</a>
<a name="ln2245">    }</a>
<a name="ln2246"> </a>
<a name="ln2247">    bool penance = god_hates_item(*potion);</a>
<a name="ln2248">    string prompt = make_stringf(&quot;Really quaff the %s?%s&quot;,</a>
<a name="ln2249">                                 potion-&gt;name(DESC_DBNAME).c_str(),</a>
<a name="ln2250">                                 penance ? &quot; This action would place&quot;</a>
<a name="ln2251">                                           &quot; you under penance!&quot; : &quot;&quot;);</a>
<a name="ln2252">    if (alreadyknown &amp;&amp; (is_dangerous_item(*potion, true) || penance)</a>
<a name="ln2253">        &amp;&amp; Options.bad_item_prompt</a>
<a name="ln2254">        &amp;&amp; !yesno(prompt.c_str(), false, 'n'))</a>
<a name="ln2255">    {</a>
<a name="ln2256">        canned_msg(MSG_OK);</a>
<a name="ln2257">        return;</a>
<a name="ln2258">    }</a>
<a name="ln2259"> </a>
<a name="ln2260">    // The &quot;&gt; 1&quot; part is to reduce the amount of times that Xom is</a>
<a name="ln2261">    // stimulated when you are a low-level 1 trying your first unknown</a>
<a name="ln2262">    // potions on monsters.</a>
<a name="ln2263">    const bool dangerous = (player_in_a_dangerous_place()</a>
<a name="ln2264">                            &amp;&amp; you.experience_level &gt; 1);</a>
<a name="ln2265"> </a>
<a name="ln2266">    if (player_under_penance(GOD_GOZAG) &amp;&amp; one_chance_in(3))</a>
<a name="ln2267">    {</a>
<a name="ln2268">        simple_god_message(&quot; petitions for your drink to fail.&quot;, GOD_GOZAG);</a>
<a name="ln2269">        you.turn_is_over = true;</a>
<a name="ln2270">        return;</a>
<a name="ln2271">    }</a>
<a name="ln2272"> </a>
<a name="ln2273">    if (!quaff_potion(*potion))</a>
<a name="ln2274">        return;</a>
<a name="ln2275"> </a>
<a name="ln2276">    if (!alreadyknown &amp;&amp; dangerous)</a>
<a name="ln2277">    {</a>
<a name="ln2278">        // Xom loves it when you drink an unknown potion and there is</a>
<a name="ln2279">        // a dangerous monster nearby...</a>
<a name="ln2280">        xom_is_stimulated(200);</a>
<a name="ln2281">    }</a>
<a name="ln2282"> </a>
<a name="ln2283">    // We'll need this later, after destroying the item.</a>
<a name="ln2284">    const bool was_exp = potion-&gt;sub_type == POT_EXPERIENCE;</a>
<a name="ln2285">    if (in_inventory(*potion))</a>
<a name="ln2286">    {</a>
<a name="ln2287">        dec_inv_item_quantity(potion-&gt;link, 1);</a>
<a name="ln2288">        auto_assign_item_slot(*potion);</a>
<a name="ln2289">    }</a>
<a name="ln2290">    else</a>
<a name="ln2291">        dec_mitm_item_quantity(potion-&gt;index(), 1);</a>
<a name="ln2292">    count_action(CACT_USE, OBJ_POTIONS);</a>
<a name="ln2293">    you.turn_is_over = true;</a>
<a name="ln2294"> </a>
<a name="ln2295">    // This got deferred from PotionExperience::effect to prevent SIGHUP abuse.</a>
<a name="ln2296">    if (was_exp)</a>
<a name="ln2297">        level_change();</a>
<a name="ln2298">}</a>
<a name="ln2299"> </a>
<a name="ln2300">// XXX: there's probably a nicer way of doing this.</a>
<a name="ln2301">bool god_hates_brand(const int brand)</a>
<a name="ln2302">{</a>
<a name="ln2303">    if (is_good_god(you.religion)</a>
<a name="ln2304">        &amp;&amp; (brand == SPWPN_DRAINING</a>
<a name="ln2305">            || brand == SPWPN_VAMPIRISM</a>
<a name="ln2306">            || brand == SPWPN_CHAOS</a>
<a name="ln2307">            || brand == SPWPN_PAIN))</a>
<a name="ln2308">    {</a>
<a name="ln2309">        return true;</a>
<a name="ln2310">    }</a>
<a name="ln2311"> </a>
<a name="ln2312">    if (you_worship(GOD_CHEIBRIADOS) &amp;&amp; (brand == SPWPN_CHAOS</a>
<a name="ln2313">                                         || brand == SPWPN_SPEED))</a>
<a name="ln2314">    {</a>
<a name="ln2315">        return true;</a>
<a name="ln2316">    }</a>
<a name="ln2317"> </a>
<a name="ln2318">    if (you_worship(GOD_YREDELEMNUL) &amp;&amp; brand == SPWPN_HOLY_WRATH)</a>
<a name="ln2319">        return true;</a>
<a name="ln2320"> </a>
<a name="ln2321">    return false;</a>
<a name="ln2322">}</a>
<a name="ln2323"> </a>
<a name="ln2324">static void _rebrand_weapon(item_def&amp; wpn)</a>
<a name="ln2325">{</a>
<a name="ln2326">    if (&amp;wpn == you.weapon() &amp;&amp; you.duration[DUR_EXCRUCIATING_WOUNDS])</a>
<a name="ln2327">        end_weapon_brand(wpn);</a>
<a name="ln2328">    const brand_type old_brand = get_weapon_brand(wpn);</a>
<a name="ln2329">    brand_type new_brand = old_brand;</a>
<a name="ln2330"> </a>
<a name="ln2331">    // now try and find an appropriate brand</a>
<a name="ln2332">    while (old_brand == new_brand || god_hates_brand(new_brand))</a>
<a name="ln2333">    {</a>
<a name="ln2334">        if (is_range_weapon(wpn))</a>
<a name="ln2335">        {</a>
<a name="ln2336">            new_brand = random_choose_weighted(</a>
<a name="ln2337">                                    33, SPWPN_FLAMING,</a>
<a name="ln2338">                                    33, SPWPN_FREEZING,</a>
<a name="ln2339">                                    23, SPWPN_VENOM,</a>
<a name="ln2340">                                    23, SPWPN_VORPAL,</a>
<a name="ln2341">                                    5, SPWPN_ELECTROCUTION,</a>
<a name="ln2342">                                    3, SPWPN_CHAOS);</a>
<a name="ln2343">        }</a>
<a name="ln2344">        else</a>
<a name="ln2345">        {</a>
<a name="ln2346">            new_brand = random_choose_weighted(</a>
<a name="ln2347">                                    30, SPWPN_FLAMING,</a>
<a name="ln2348">                                    30, SPWPN_FREEZING,</a>
<a name="ln2349">                                    25, SPWPN_VORPAL,</a>
<a name="ln2350">                                    20, SPWPN_VENOM,</a>
<a name="ln2351">                                    15, SPWPN_DRAINING,</a>
<a name="ln2352">                                    15, SPWPN_ELECTROCUTION,</a>
<a name="ln2353">                                    12, SPWPN_PROTECTION,</a>
<a name="ln2354">                                    8, SPWPN_VAMPIRISM,</a>
<a name="ln2355">                                    3, SPWPN_CHAOS);</a>
<a name="ln2356">        }</a>
<a name="ln2357">    }</a>
<a name="ln2358"> </a>
<a name="ln2359">    set_item_ego_type(wpn, OBJ_WEAPONS, new_brand);</a>
<a name="ln2360">    convert2bad(wpn);</a>
<a name="ln2361">}</a>
<a name="ln2362"> </a>
<a name="ln2363">static string _item_name(item_def &amp;item)</a>
<a name="ln2364">{</a>
<a name="ln2365">    return item.name(in_inventory(item) ? DESC_YOUR : DESC_THE);</a>
<a name="ln2366">}</a>
<a name="ln2367"> </a>
<a name="ln2368">static void _brand_weapon(item_def &amp;wpn)</a>
<a name="ln2369">{</a>
<a name="ln2370">    you.wield_change = true;</a>
<a name="ln2371"> </a>
<a name="ln2372">    const string itname = _item_name(wpn);</a>
<a name="ln2373"> </a>
<a name="ln2374">    _rebrand_weapon(wpn);</a>
<a name="ln2375"> </a>
<a name="ln2376">    bool success = true;</a>
<a name="ln2377">    colour_t flash_colour = BLACK;</a>
<a name="ln2378"> </a>
<a name="ln2379">    switch (get_weapon_brand(wpn))</a>
<a name="ln2380">    {</a>
<a name="ln2381">    case SPWPN_VORPAL:</a>
<a name="ln2382">        flash_colour = YELLOW;</a>
<a name="ln2383">        mprf(&quot;%s emits a brilliant flash of light!&quot;,itname.c_str());</a>
<a name="ln2384">        break;</a>
<a name="ln2385"> </a>
<a name="ln2386">    case SPWPN_PROTECTION:</a>
<a name="ln2387">        flash_colour = YELLOW;</a>
<a name="ln2388">        mprf(&quot;%s projects an invisible shield of force!&quot;,itname.c_str());</a>
<a name="ln2389">        break;</a>
<a name="ln2390"> </a>
<a name="ln2391">    case SPWPN_FLAMING:</a>
<a name="ln2392">        flash_colour = RED;</a>
<a name="ln2393">        mprf(&quot;%s is engulfed in flames!&quot;, itname.c_str());</a>
<a name="ln2394">        break;</a>
<a name="ln2395"> </a>
<a name="ln2396">    case SPWPN_FREEZING:</a>
<a name="ln2397">        flash_colour = LIGHTCYAN;</a>
<a name="ln2398">        mprf(&quot;%s is covered with a thin layer of ice!&quot;, itname.c_str());</a>
<a name="ln2399">        break;</a>
<a name="ln2400"> </a>
<a name="ln2401">    case SPWPN_DRAINING:</a>
<a name="ln2402">        flash_colour = DARKGREY;</a>
<a name="ln2403">        mprf(&quot;%s craves living souls!&quot;, itname.c_str());</a>
<a name="ln2404">        break;</a>
<a name="ln2405"> </a>
<a name="ln2406">    case SPWPN_VAMPIRISM:</a>
<a name="ln2407">        flash_colour = DARKGREY;</a>
<a name="ln2408">        mprf(&quot;%s thirsts for the lives of mortals!&quot;, itname.c_str());</a>
<a name="ln2409">        break;</a>
<a name="ln2410"> </a>
<a name="ln2411">    case SPWPN_VENOM:</a>
<a name="ln2412">        flash_colour = GREEN;</a>
<a name="ln2413">        mprf(&quot;%s drips with poison.&quot;, itname.c_str());</a>
<a name="ln2414">        break;</a>
<a name="ln2415"> </a>
<a name="ln2416">    case SPWPN_ELECTROCUTION:</a>
<a name="ln2417">        flash_colour = LIGHTCYAN;</a>
<a name="ln2418">        mprf(&quot;%s crackles with electricity.&quot;, itname.c_str());</a>
<a name="ln2419">        break;</a>
<a name="ln2420"> </a>
<a name="ln2421">    case SPWPN_CHAOS:</a>
<a name="ln2422">        flash_colour = random_colour();</a>
<a name="ln2423">        mprf(&quot;%s erupts in a glittering mayhem of colour.&quot;, itname.c_str());</a>
<a name="ln2424">        break;</a>
<a name="ln2425"> </a>
<a name="ln2426">    case SPWPN_ACID:</a>
<a name="ln2427">        flash_colour = ETC_SLIME;</a>
<a name="ln2428">        mprf(&quot;%s oozes corrosive slime.&quot;, itname.c_str());</a>
<a name="ln2429">        break;</a>
<a name="ln2430"> </a>
<a name="ln2431">    default:</a>
<a name="ln2432">        success = false;</a>
<a name="ln2433">        break;</a>
<a name="ln2434">    }</a>
<a name="ln2435"> </a>
<a name="ln2436">    if (success)</a>
<a name="ln2437">    {</a>
<a name="ln2438">        item_set_appearance(wpn);</a>
<a name="ln2439">        // Message would spoil this even if we didn't identify.</a>
<a name="ln2440">        set_ident_flags(wpn, ISFLAG_KNOW_TYPE);</a>
<a name="ln2441">        mprf_nocap(&quot;%s&quot;, wpn.name(DESC_INVENTORY_EQUIP).c_str());</a>
<a name="ln2442">        // Might be rebranding to/from protection or evasion.</a>
<a name="ln2443">        you.redraw_armour_class = true;</a>
<a name="ln2444">        you.redraw_evasion = true;</a>
<a name="ln2445">        // Might be removing antimagic.</a>
<a name="ln2446">        calc_mp();</a>
<a name="ln2447">        flash_view_delay(UA_PLAYER, flash_colour, 300);</a>
<a name="ln2448">    }</a>
<a name="ln2449">    return;</a>
<a name="ln2450">}</a>
<a name="ln2451"> </a>
<a name="ln2452">static item_def* _choose_target_item_for_scroll(bool scroll_known, object_selector selector,</a>
<a name="ln2453">                                                const char* prompt)</a>
<a name="ln2454">{</a>
<a name="ln2455">    item_def *target = nullptr;</a>
<a name="ln2456">    bool success = false;</a>
<a name="ln2457"> </a>
<a name="ln2458">    success = use_an_item(target, selector, OPER_ANY, prompt,</a>
<a name="ln2459">                       [=]()</a>
<a name="ln2460">                       {</a>
<a name="ln2461">                           if (scroll_known</a>
<a name="ln2462">                               || crawl_state.seen_hups</a>
<a name="ln2463">                               || yesno(&quot;Really abort (and waste the scroll)?&quot;, false, 0))</a>
<a name="ln2464">                           {</a>
<a name="ln2465">                               return true;</a>
<a name="ln2466">                           }</a>
<a name="ln2467">                           return false;</a>
<a name="ln2468">                       });</a>
<a name="ln2469">    return success ? target : nullptr;</a>
<a name="ln2470">}</a>
<a name="ln2471"> </a>
<a name="ln2472">static object_selector _enchant_selector(scroll_type scroll)</a>
<a name="ln2473">{</a>
<a name="ln2474">    if (scroll == SCR_BRAND_WEAPON)</a>
<a name="ln2475">        return OSEL_BRANDABLE_WEAPON;</a>
<a name="ln2476">    else if (scroll == SCR_ENCHANT_WEAPON)</a>
<a name="ln2477">        return OSEL_ENCHANTABLE_WEAPON;</a>
<a name="ln2478">    die(&quot;Invalid scroll type %d for _enchant_selector&quot;, (int)scroll);</a>
<a name="ln2479">}</a>
<a name="ln2480"> </a>
<a name="ln2481">// Returns nullptr if no weapon was chosen.</a>
<a name="ln2482">static item_def* _scroll_choose_weapon(bool alreadyknown, const string &amp;pre_msg,</a>
<a name="ln2483">                                       scroll_type scroll)</a>
<a name="ln2484">{</a>
<a name="ln2485">    const bool branding = scroll == SCR_BRAND_WEAPON;</a>
<a name="ln2486"> </a>
<a name="ln2487">    item_def* target = _choose_target_item_for_scroll(alreadyknown, _enchant_selector(scroll),</a>
<a name="ln2488">                                                      branding ? &quot;Brand which weapon?&quot;</a>
<a name="ln2489">                                                               : &quot;Enchant which weapon?&quot;);</a>
<a name="ln2490">    if (!target)</a>
<a name="ln2491">        return target;</a>
<a name="ln2492"> </a>
<a name="ln2493">    if (alreadyknown)</a>
<a name="ln2494">        mpr(pre_msg);</a>
<a name="ln2495"> </a>
<a name="ln2496">    return target;</a>
<a name="ln2497">}</a>
<a name="ln2498"> </a>
<a name="ln2499">// Returns true if the scroll is used up.</a>
<a name="ln2500">static bool _handle_brand_weapon(bool alreadyknown, const string &amp;pre_msg)</a>
<a name="ln2501">{</a>
<a name="ln2502">    item_def* weapon = _scroll_choose_weapon(alreadyknown, pre_msg,</a>
<a name="ln2503">                                             SCR_BRAND_WEAPON);</a>
<a name="ln2504">    if (!weapon)</a>
<a name="ln2505">        return !alreadyknown;</a>
<a name="ln2506"> </a>
<a name="ln2507">    _brand_weapon(*weapon);</a>
<a name="ln2508">    return true;</a>
<a name="ln2509">}</a>
<a name="ln2510"> </a>
<a name="ln2511">bool enchant_weapon(item_def &amp;wpn, bool quiet)</a>
<a name="ln2512">{</a>
<a name="ln2513">    bool success = false;</a>
<a name="ln2514"> </a>
<a name="ln2515">    // Get item name now before changing enchantment.</a>
<a name="ln2516">    string iname = _item_name(wpn);</a>
<a name="ln2517"> </a>
<a name="ln2518">    if (is_weapon(wpn)</a>
<a name="ln2519">        &amp;&amp; !is_artefact(wpn)</a>
<a name="ln2520">        &amp;&amp; wpn.base_type == OBJ_WEAPONS</a>
<a name="ln2521">        &amp;&amp; wpn.plus &lt; MAX_WPN_ENCHANT)</a>
<a name="ln2522">    {</a>
<a name="ln2523">        wpn.plus++;</a>
<a name="ln2524">        success = true;</a>
<a name="ln2525">        if (!quiet)</a>
<a name="ln2526">            mprf(&quot;%s glows red for a moment.&quot;, iname.c_str());</a>
<a name="ln2527">    }</a>
<a name="ln2528"> </a>
<a name="ln2529">    if (!success &amp;&amp; !quiet)</a>
<a name="ln2530">        canned_msg(MSG_NOTHING_HAPPENS);</a>
<a name="ln2531"> </a>
<a name="ln2532">    if (success)</a>
<a name="ln2533">        you.wield_change = true;</a>
<a name="ln2534"> </a>
<a name="ln2535">    return success;</a>
<a name="ln2536">}</a>
<a name="ln2537"> </a>
<a name="ln2538">/**</a>
<a name="ln2539"> * Prompt for an item to identify (either in the player's inventory or in</a>
<a name="ln2540"> * the ground), and then, if one is chosen, identify it.</a>
<a name="ln2541"> *</a>
<a name="ln2542"> * @param alreadyknown  Did we know that this was an ID scroll before we</a>
<a name="ln2543"> *                      started reading it?</a>
<a name="ln2544"> * @param pre_msg       'As you read the scroll of foo, it crumbles to dust.'</a>
<a name="ln2545"> * @param link[in,out]  The location of the ID scroll in the player's inventory</a>
<a name="ln2546"> *                      or, if it's on the floor, -1.</a>
<a name="ln2547"> *                      auto_assign_item_slot() may require us to update this.</a>
<a name="ln2548"> * @return  true if the scroll is used up. (That is, whether it was used or</a>
<a name="ln2549"> *          whether it was previously unknown (&amp; thus uncancellable).)</a>
<a name="ln2550"> */</a>
<a name="ln2551">static bool _identify(bool alreadyknown, const string &amp;pre_msg, int &amp;link)</a>
<a name="ln2552">{</a>
<a name="ln2553">    item_def* itemp = _choose_target_item_for_scroll(alreadyknown, OSEL_UNIDENT,</a>
<a name="ln2554">                       &quot;Identify which item? (\\ to view known items)&quot;);</a>
<a name="ln2555"> </a>
<a name="ln2556">    if (!itemp)</a>
<a name="ln2557">        return !alreadyknown;</a>
<a name="ln2558"> </a>
<a name="ln2559">    item_def&amp; item = *itemp;</a>
<a name="ln2560">    if (alreadyknown)</a>
<a name="ln2561">        mpr(pre_msg);</a>
<a name="ln2562"> </a>
<a name="ln2563">    set_ident_type(item, true);</a>
<a name="ln2564">    set_ident_flags(item, ISFLAG_IDENT_MASK);</a>
<a name="ln2565"> </a>
<a name="ln2566">    // Output identified item.</a>
<a name="ln2567">    mprf_nocap(&quot;%s&quot;, menu_colour_item_name(item, DESC_INVENTORY_EQUIP).c_str());</a>
<a name="ln2568">    if (in_inventory(item))</a>
<a name="ln2569">    {</a>
<a name="ln2570">        if (item.link == you.equip[EQ_WEAPON])</a>
<a name="ln2571">            you.wield_change = true;</a>
<a name="ln2572"> </a>
<a name="ln2573">        if (item.is_type(OBJ_JEWELLERY, AMU_INACCURACY)</a>
<a name="ln2574">            &amp;&amp; item.link == you.equip[EQ_AMULET]</a>
<a name="ln2575">            &amp;&amp; !item_known_cursed(item))</a>
<a name="ln2576">        {</a>
<a name="ln2577">            learned_something_new(HINT_INACCURACY);</a>
<a name="ln2578">        }</a>
<a name="ln2579"> </a>
<a name="ln2580">        const int target_link = item.link;</a>
<a name="ln2581">        item_def* moved_target = auto_assign_item_slot(item);</a>
<a name="ln2582">        if (moved_target != nullptr &amp;&amp; moved_target-&gt;link == link)</a>
<a name="ln2583">        {</a>
<a name="ln2584">            // auto-swapped ID'd item with scrolls being used to ID it</a>
<a name="ln2585">            // correct input 'link' to the new location of the ID scroll stack</a>
<a name="ln2586">            // so that we decrement *it* instead of the ID'd item (10663)</a>
<a name="ln2587">            ASSERT(you.inv[target_link].defined());</a>
<a name="ln2588">            ASSERT(you.inv[target_link].is_type(OBJ_SCROLLS, SCR_IDENTIFY));</a>
<a name="ln2589">            link = target_link;</a>
<a name="ln2590">        }</a>
<a name="ln2591">    }</a>
<a name="ln2592">    return true;</a>
<a name="ln2593">}</a>
<a name="ln2594"> </a>
<a name="ln2595">static bool _handle_enchant_weapon(bool alreadyknown, const string &amp;pre_msg)</a>
<a name="ln2596">{</a>
<a name="ln2597">    item_def* weapon = _scroll_choose_weapon(alreadyknown, pre_msg,</a>
<a name="ln2598">                                             SCR_ENCHANT_WEAPON);</a>
<a name="ln2599">    if (!weapon)</a>
<a name="ln2600">        return !alreadyknown;</a>
<a name="ln2601"> </a>
<a name="ln2602">    enchant_weapon(*weapon, false);</a>
<a name="ln2603">    return true;</a>
<a name="ln2604">}</a>
<a name="ln2605"> </a>
<a name="ln2606">bool enchant_armour(int &amp;ac_change, bool quiet, item_def &amp;arm)</a>
<a name="ln2607">{</a>
<a name="ln2608">    ASSERT(arm.defined());</a>
<a name="ln2609">    ASSERT(arm.base_type == OBJ_ARMOUR);</a>
<a name="ln2610"> </a>
<a name="ln2611">    ac_change = 0;</a>
<a name="ln2612"> </a>
<a name="ln2613">    // Cannot be enchanted.</a>
<a name="ln2614">    if (!is_enchantable_armour(arm))</a>
<a name="ln2615">    {</a>
<a name="ln2616">        if (!quiet)</a>
<a name="ln2617">            canned_msg(MSG_NOTHING_HAPPENS);</a>
<a name="ln2618">        return false;</a>
<a name="ln2619">    }</a>
<a name="ln2620"> </a>
<a name="ln2621">    // Output message before changing enchantment and curse status.</a>
<a name="ln2622">    if (!quiet)</a>
<a name="ln2623">    {</a>
<a name="ln2624">        const bool plural = armour_is_hide(arm)</a>
<a name="ln2625">                            &amp;&amp; arm.sub_type != ARM_TROLL_LEATHER_ARMOUR;</a>
<a name="ln2626">        mprf(&quot;%s %s green for a moment.&quot;,</a>
<a name="ln2627">             _item_name(arm).c_str(),</a>
<a name="ln2628">             conjugate_verb(&quot;glow&quot;, plural).c_str());</a>
<a name="ln2629">    }</a>
<a name="ln2630"> </a>
<a name="ln2631">    arm.plus++;</a>
<a name="ln2632">    ac_change++;</a>
<a name="ln2633"> </a>
<a name="ln2634">    return true;</a>
<a name="ln2635">}</a>
<a name="ln2636"> </a>
<a name="ln2637">static int _handle_enchant_armour(bool alreadyknown, const string &amp;pre_msg)</a>
<a name="ln2638">{</a>
<a name="ln2639">    item_def* target = _choose_target_item_for_scroll(alreadyknown, OSEL_ENCHANTABLE_ARMOUR,</a>
<a name="ln2640">                                                      &quot;Enchant which item?&quot;);</a>
<a name="ln2641"> </a>
<a name="ln2642">    if (!target)</a>
<a name="ln2643">        return alreadyknown ? -1 : 0;</a>
<a name="ln2644"> </a>
<a name="ln2645">    // Okay, we may actually (attempt to) enchant something.</a>
<a name="ln2646">    if (alreadyknown)</a>
<a name="ln2647">        mpr(pre_msg);</a>
<a name="ln2648"> </a>
<a name="ln2649">    int ac_change;</a>
<a name="ln2650">    bool result = enchant_armour(ac_change, false, *target);</a>
<a name="ln2651"> </a>
<a name="ln2652">    if (ac_change)</a>
<a name="ln2653">        you.redraw_armour_class = true;</a>
<a name="ln2654"> </a>
<a name="ln2655">    return result ? 1 : 0;</a>
<a name="ln2656">}</a>
<a name="ln2657"> </a>
<a name="ln2658">void random_uselessness()</a>
<a name="ln2659">{</a>
<a name="ln2660">    ASSERT(!crawl_state.game_is_arena());</a>
<a name="ln2661"> </a>
<a name="ln2662">    switch (random2(8))</a>
<a name="ln2663">    {</a>
<a name="ln2664">    case 0:</a>
<a name="ln2665">    case 1:</a>
<a name="ln2666">        mprf(&quot;The dust glows %s!&quot;, weird_glowing_colour().c_str());</a>
<a name="ln2667">        break;</a>
<a name="ln2668"> </a>
<a name="ln2669">    case 2:</a>
<a name="ln2670">        if (you.weapon())</a>
<a name="ln2671">        {</a>
<a name="ln2672">            mprf(&quot;%s glows %s for a moment.&quot;,</a>
<a name="ln2673">                 you.weapon()-&gt;name(DESC_YOUR).c_str(),</a>
<a name="ln2674">                 weird_glowing_colour().c_str());</a>
<a name="ln2675">        }</a>
<a name="ln2676">        else</a>
<a name="ln2677">        {</a>
<a name="ln2678">            mpr(you.hands_act(&quot;glow&quot;, weird_glowing_colour()</a>
<a name="ln2679">                                      + &quot; for a moment.&quot;));</a>
<a name="ln2680">        }</a>
<a name="ln2681">        break;</a>
<a name="ln2682"> </a>
<a name="ln2683">    case 3:</a>
<a name="ln2684">        if (you.species == SP_MUMMY)</a>
<a name="ln2685">            mpr(&quot;Your bandages flutter.&quot;);</a>
<a name="ln2686">        else // if (you.can_smell())</a>
<a name="ln2687">            mprf(&quot;You smell %s.&quot;, _weird_smell().c_str());</a>
<a name="ln2688">        break;</a>
<a name="ln2689"> </a>
<a name="ln2690">    case 4:</a>
<a name="ln2691">        mpr(&quot;You experience a momentary feeling of inescapable doom!&quot;);</a>
<a name="ln2692">        break;</a>
<a name="ln2693"> </a>
<a name="ln2694">    case 5:</a>
<a name="ln2695">        if (you.get_mutation_level(MUT_BEAK) || one_chance_in(3))</a>
<a name="ln2696">            mpr(&quot;Your brain hurts!&quot;);</a>
<a name="ln2697">        else if (you.species == SP_MUMMY || coinflip())</a>
<a name="ln2698">            mpr(&quot;Your ears itch!&quot;);</a>
<a name="ln2699">        else</a>
<a name="ln2700">            mpr(&quot;Your nose twitches suddenly!&quot;);</a>
<a name="ln2701">        break;</a>
<a name="ln2702"> </a>
<a name="ln2703">    case 6:</a>
<a name="ln2704">    case 7:</a>
<a name="ln2705">        mprf(MSGCH_SOUND, &quot;You hear %s.&quot;, _weird_sound().c_str());</a>
<a name="ln2706">        noisy(2, you.pos());</a>
<a name="ln2707">        break;</a>
<a name="ln2708">    }</a>
<a name="ln2709">}</a>
<a name="ln2710"> </a>
<a name="ln2711">static void _handle_read_book(item_def&amp; book)</a>
<a name="ln2712">{</a>
<a name="ln2713">    if (you.berserk())</a>
<a name="ln2714">    {</a>
<a name="ln2715">        canned_msg(MSG_TOO_BERSERK);</a>
<a name="ln2716">        return;</a>
<a name="ln2717">    }</a>
<a name="ln2718"> </a>
<a name="ln2719">    if (you.duration[DUR_BRAINLESS])</a>
<a name="ln2720">    {</a>
<a name="ln2721">        mpr(&quot;Reading books requires mental cohesion, which you lack.&quot;);</a>
<a name="ln2722">        return;</a>
<a name="ln2723">    }</a>
<a name="ln2724"> </a>
<a name="ln2725">    ASSERT(book.sub_type != BOOK_MANUAL);</a>
<a name="ln2726"> </a>
<a name="ln2727">#if TAG_MAJOR_VERSION == 34</a>
<a name="ln2728">    if (book.sub_type == BOOK_BUGGY_DESTRUCTION)</a>
<a name="ln2729">    {</a>
<a name="ln2730">        mpr(&quot;This item has been removed, sorry!&quot;);</a>
<a name="ln2731">        return;</a>
<a name="ln2732">    }</a>
<a name="ln2733">#endif</a>
<a name="ln2734"> </a>
<a name="ln2735">    set_ident_flags(book, ISFLAG_IDENT_MASK);</a>
<a name="ln2736">    read_book(book);</a>
<a name="ln2737">}</a>
<a name="ln2738"> </a>
<a name="ln2739">static void _vulnerability_scroll()</a>
<a name="ln2740">{</a>
<a name="ln2741">    mon_enchant lowered_mr(ENCH_LOWERED_MR, 1, &amp;you, 400);</a>
<a name="ln2742"> </a>
<a name="ln2743">    // Go over all creatures in LOS.</a>
<a name="ln2744">    for (radius_iterator ri(you.pos(), LOS_NO_TRANS); ri; ++ri)</a>
<a name="ln2745">    {</a>
<a name="ln2746">        if (monster* mon = monster_at(*ri))</a>
<a name="ln2747">        {</a>
<a name="ln2748">            // If relevant, monsters have their MR halved.</a>
<a name="ln2749">            if (!mons_immune_magic(*mon))</a>
<a name="ln2750">                mon-&gt;add_ench(lowered_mr);</a>
<a name="ln2751"> </a>
<a name="ln2752">            // Annoying but not enough to turn friendlies against you.</a>
<a name="ln2753">            if (!mon-&gt;wont_attack())</a>
<a name="ln2754">                behaviour_event(mon, ME_ANNOY, &amp;you);</a>
<a name="ln2755">        }</a>
<a name="ln2756">    }</a>
<a name="ln2757"> </a>
<a name="ln2758">    you.set_duration(DUR_LOWERED_MR, 40, 0, &quot;Magic quickly surges around you.&quot;);</a>
<a name="ln2759">}</a>
<a name="ln2760"> </a>
<a name="ln2761">static bool _is_cancellable_scroll(scroll_type scroll)</a>
<a name="ln2762">{</a>
<a name="ln2763">    return scroll == SCR_IDENTIFY</a>
<a name="ln2764">           || scroll == SCR_BLINKING</a>
<a name="ln2765">           || scroll == SCR_ENCHANT_ARMOUR</a>
<a name="ln2766">           || scroll == SCR_AMNESIA</a>
<a name="ln2767">           || scroll == SCR_REMOVE_CURSE</a>
<a name="ln2768">#if TAG_MAJOR_VERSION == 34</a>
<a name="ln2769">           || scroll == SCR_CURSE_ARMOUR</a>
<a name="ln2770">           || scroll == SCR_CURSE_JEWELLERY</a>
<a name="ln2771">           || scroll == SCR_RECHARGING</a>
<a name="ln2772">#endif</a>
<a name="ln2773">           || scroll == SCR_BRAND_WEAPON</a>
<a name="ln2774">           || scroll == SCR_ENCHANT_WEAPON</a>
<a name="ln2775">           || scroll == SCR_MAGIC_MAPPING</a>
<a name="ln2776">           || scroll == SCR_ACQUIREMENT;</a>
<a name="ln2777">}</a>
<a name="ln2778"> </a>
<a name="ln2779">/**</a>
<a name="ln2780"> * Is the player currently able to use the 'r' command (to read books or</a>
<a name="ln2781"> * scrolls). Being too berserk, confused, or having no reading material will</a>
<a name="ln2782"> * prevent this.</a>
<a name="ln2783"> *</a>
<a name="ln2784"> * Prints corresponding messages. (Thanks, canned_msg().)</a>
<a name="ln2785"> */</a>
<a name="ln2786">bool player_can_read()</a>
<a name="ln2787">{</a>
<a name="ln2788">    if (you.berserk())</a>
<a name="ln2789">    {</a>
<a name="ln2790">        canned_msg(MSG_TOO_BERSERK);</a>
<a name="ln2791">        return false;</a>
<a name="ln2792">    }</a>
<a name="ln2793"> </a>
<a name="ln2794">    if (you.confused())</a>
<a name="ln2795">    {</a>
<a name="ln2796">        canned_msg(MSG_TOO_CONFUSED);</a>
<a name="ln2797">        return false;</a>
<a name="ln2798">    }</a>
<a name="ln2799"> </a>
<a name="ln2800">    return true;</a>
<a name="ln2801">}</a>
<a name="ln2802"> </a>
<a name="ln2803">/**</a>
<a name="ln2804"> * If the player has no items matching the given selector, give an appropriate</a>
<a name="ln2805"> * response to print. Otherwise, if they do have such items, return the empty</a>
<a name="ln2806"> * string.</a>
<a name="ln2807"> */</a>
<a name="ln2808">static string _no_items_reason(object_selector type, bool check_floor = false)</a>
<a name="ln2809">{</a>
<a name="ln2810">    if (!any_items_of_type(type, -1, check_floor))</a>
<a name="ln2811">        return no_selectables_message(type);</a>
<a name="ln2812">    return &quot;&quot;;</a>
<a name="ln2813">}</a>
<a name="ln2814"> </a>
<a name="ln2815">/**</a>
<a name="ln2816"> * If the player is unable to (r)ead the item in the given slot, return the</a>
<a name="ln2817"> * reason why. Otherwise (if they are able to read it), returns &quot;&quot;, the empty</a>
<a name="ln2818"> * string.</a>
<a name="ln2819"> */</a>
<a name="ln2820">string cannot_read_item_reason(const item_def &amp;item)</a>
<a name="ln2821">{</a>
<a name="ln2822">    // can read books, except for manuals...</a>
<a name="ln2823">    if (item.base_type == OBJ_BOOKS)</a>
<a name="ln2824">    {</a>
<a name="ln2825">        if (item.sub_type == BOOK_MANUAL)</a>
<a name="ln2826">            return &quot;You can't read that!&quot;;</a>
<a name="ln2827">        return &quot;&quot;;</a>
<a name="ln2828">    }</a>
<a name="ln2829"> </a>
<a name="ln2830">    // and scrolls - but nothing else.</a>
<a name="ln2831">    if (item.base_type != OBJ_SCROLLS)</a>
<a name="ln2832">        return &quot;You can't read that!&quot;;</a>
<a name="ln2833"> </a>
<a name="ln2834">    // the below only applies to scrolls. (it's easier to read books, since</a>
<a name="ln2835">    // that's just a UI/strategic thing.)</a>
<a name="ln2836"> </a>
<a name="ln2837">    if (silenced(you.pos()))</a>
<a name="ln2838">        return &quot;Magic scrolls do not work when you're silenced!&quot;;</a>
<a name="ln2839"> </a>
<a name="ln2840">    // water elementals</a>
<a name="ln2841">    if (you.duration[DUR_WATER_HOLD] &amp;&amp; !you.res_water_drowning())</a>
<a name="ln2842">        return &quot;You cannot read scrolls while unable to breathe!&quot;;</a>
<a name="ln2843"> </a>
<a name="ln2844">    // ru</a>
<a name="ln2845">    if (you.duration[DUR_NO_SCROLLS])</a>
<a name="ln2846">        return &quot;You cannot read scrolls in your current state!&quot;;</a>
<a name="ln2847"> </a>
<a name="ln2848">    // don't waste the player's time reading known scrolls in situations where</a>
<a name="ln2849">    // they'd be useless</a>
<a name="ln2850"> </a>
<a name="ln2851">    if (!item_type_known(item))</a>
<a name="ln2852">        return &quot;&quot;;</a>
<a name="ln2853"> </a>
<a name="ln2854">    switch (item.sub_type)</a>
<a name="ln2855">    {</a>
<a name="ln2856">        case SCR_BLINKING:</a>
<a name="ln2857">        case SCR_TELEPORTATION:</a>
<a name="ln2858">            return you.no_tele_reason(false, item.sub_type == SCR_BLINKING);</a>
<a name="ln2859"> </a>
<a name="ln2860">        case SCR_AMNESIA:</a>
<a name="ln2861">            if (you.spell_no == 0)</a>
<a name="ln2862">                return &quot;You have no spells to forget!&quot;;</a>
<a name="ln2863">            return &quot;&quot;;</a>
<a name="ln2864"> </a>
<a name="ln2865">        case SCR_ENCHANT_ARMOUR:</a>
<a name="ln2866">            return _no_items_reason(OSEL_ENCHANTABLE_ARMOUR, true);</a>
<a name="ln2867"> </a>
<a name="ln2868">        case SCR_ENCHANT_WEAPON:</a>
<a name="ln2869">            return _no_items_reason(OSEL_ENCHANTABLE_WEAPON, true);</a>
<a name="ln2870"> </a>
<a name="ln2871">        case SCR_IDENTIFY:</a>
<a name="ln2872">            return _no_items_reason(OSEL_UNIDENT, true);</a>
<a name="ln2873"> </a>
<a name="ln2874">        case SCR_REMOVE_CURSE:</a>
<a name="ln2875">            return _no_items_reason(OSEL_CURSED_WORN);</a>
<a name="ln2876"> </a>
<a name="ln2877">#if TAG_MAJOR_VERSION == 34</a>
<a name="ln2878">        case SCR_CURSE_WEAPON:</a>
<a name="ln2879">            if (!you.weapon())</a>
<a name="ln2880">                return &quot;This scroll only affects a wielded weapon!&quot;;</a>
<a name="ln2881"> </a>
<a name="ln2882">            // assumption: wielded weapons always have their curse &amp; brand known</a>
<a name="ln2883">            if (you.weapon()-&gt;cursed())</a>
<a name="ln2884">                return &quot;Your weapon is already cursed!&quot;;</a>
<a name="ln2885"> </a>
<a name="ln2886">            if (get_weapon_brand(*you.weapon()) == SPWPN_HOLY_WRATH)</a>
<a name="ln2887">                return &quot;Holy weapons cannot be cursed!&quot;;</a>
<a name="ln2888">            return &quot;&quot;;</a>
<a name="ln2889"> </a>
<a name="ln2890">        case SCR_CURSE_ARMOUR:</a>
<a name="ln2891">            return _no_items_reason(OSEL_UNCURSED_WORN_ARMOUR);</a>
<a name="ln2892"> </a>
<a name="ln2893">        case SCR_CURSE_JEWELLERY:</a>
<a name="ln2894">            return _no_items_reason(OSEL_UNCURSED_WORN_JEWELLERY);</a>
<a name="ln2895">#endif</a>
<a name="ln2896"> </a>
<a name="ln2897">        default:</a>
<a name="ln2898">            return &quot;&quot;;</a>
<a name="ln2899">    }</a>
<a name="ln2900">}</a>
<a name="ln2901"> </a>
<a name="ln2902">/**</a>
<a name="ln2903"> * Check if a particular scroll type would hurt a monster.</a>
<a name="ln2904"> *</a>
<a name="ln2905"> * @param scr           Scroll type in question</a>
<a name="ln2906"> * @param m             Actor as a potential victim to the scroll</a>
<a name="ln2907"> * @return  true if the provided scroll type is harmful to the actor.</a>
<a name="ln2908"> */</a>
<a name="ln2909">static bool _scroll_will_harm(const scroll_type scr, const actor &amp;m)</a>
<a name="ln2910">{</a>
<a name="ln2911">    if (!m.alive())</a>
<a name="ln2912">        return false;</a>
<a name="ln2913"> </a>
<a name="ln2914">    switch (scr)</a>
<a name="ln2915">    {</a>
<a name="ln2916">        case SCR_HOLY_WORD:</a>
<a name="ln2917">            if (m.undead_or_demonic())</a>
<a name="ln2918">                return true;</a>
<a name="ln2919">            break;</a>
<a name="ln2920">        case SCR_TORMENT:</a>
<a name="ln2921">            if (!m.res_torment())</a>
<a name="ln2922">                return true;</a>
<a name="ln2923">            break;</a>
<a name="ln2924">        default: break;</a>
<a name="ln2925">    }</a>
<a name="ln2926"> </a>
<a name="ln2927">    return false;</a>
<a name="ln2928">}</a>
<a name="ln2929"> </a>
<a name="ln2930">/**</a>
<a name="ln2931"> * Check to see if the player can read the item in the given slot, and if so,</a>
<a name="ln2932"> * reads it. (Examining books and using scrolls.)</a>
<a name="ln2933"> *</a>
<a name="ln2934"> * @param slot      The slot of the item in the player's inventory. If -1, the</a>
<a name="ln2935"> *                  player is prompted to choose a slot.</a>
<a name="ln2936"> */</a>
<a name="ln2937">void read(item_def* scroll)</a>
<a name="ln2938">{</a>
<a name="ln2939">    if (!player_can_read())</a>
<a name="ln2940">        return;</a>
<a name="ln2941"> </a>
<a name="ln2942">    if (!scroll)</a>
<a name="ln2943">    {</a>
<a name="ln2944">        if (!use_an_item(scroll, OBJ_SCROLLS, OPER_READ, &quot;Read which item (* to show all)?&quot;))</a>
<a name="ln2945">            return;</a>
<a name="ln2946">    }</a>
<a name="ln2947"> </a>
<a name="ln2948">    const string failure_reason = cannot_read_item_reason(*scroll);</a>
<a name="ln2949">    if (!failure_reason.empty())</a>
<a name="ln2950">    {</a>
<a name="ln2951">        mprf(MSGCH_PROMPT, &quot;%s&quot;, failure_reason.c_str());</a>
<a name="ln2952">        return;</a>
<a name="ln2953">    }</a>
<a name="ln2954"> </a>
<a name="ln2955">    if (scroll-&gt;base_type == OBJ_BOOKS)</a>
<a name="ln2956">    {</a>
<a name="ln2957">        _handle_read_book(*scroll);</a>
<a name="ln2958">        return;</a>
<a name="ln2959">    }</a>
<a name="ln2960"> </a>
<a name="ln2961">    const scroll_type which_scroll = static_cast&lt;scroll_type&gt;(scroll-&gt;sub_type);</a>
<a name="ln2962">    // Handle player cancels before we waste time (with e.g. blurryvis)</a>
<a name="ln2963">    if (item_type_known(*scroll)) {</a>
<a name="ln2964">        bool penance = god_hates_item(*scroll);</a>
<a name="ln2965">        string verb_object = &quot;read the &quot; + scroll-&gt;name(DESC_DBNAME);</a>
<a name="ln2966"> </a>
<a name="ln2967">        string penance_prompt = make_stringf(&quot;Really %s? This action would&quot;</a>
<a name="ln2968">                                             &quot; place you under penance!&quot;,</a>
<a name="ln2969">                                             verb_object.c_str());</a>
<a name="ln2970"> </a>
<a name="ln2971">        targeter_radius hitfunc(&amp;you, LOS_NO_TRANS);</a>
<a name="ln2972"> </a>
<a name="ln2973">        if (stop_attack_prompt(hitfunc, verb_object.c_str(),</a>
<a name="ln2974">                               [which_scroll] (const actor* m)</a>
<a name="ln2975">                               {</a>
<a name="ln2976">                                   return _scroll_will_harm(which_scroll, *m);</a>
<a name="ln2977">                               },</a>
<a name="ln2978">                               nullptr, nullptr))</a>
<a name="ln2979">        {</a>
<a name="ln2980">            return;</a>
<a name="ln2981">        }</a>
<a name="ln2982">        else if (penance &amp;&amp; !yesno(penance_prompt.c_str(), false, 'n'))</a>
<a name="ln2983">        {</a>
<a name="ln2984">            canned_msg(MSG_OK);</a>
<a name="ln2985">            return;</a>
<a name="ln2986">        }</a>
<a name="ln2987">        else if ((is_dangerous_item(*scroll, true)</a>
<a name="ln2988">                  || is_bad_item(*scroll))</a>
<a name="ln2989">                 &amp;&amp; Options.bad_item_prompt</a>
<a name="ln2990">                 &amp;&amp; !yesno(make_stringf(&quot;Really %s?&quot;,</a>
<a name="ln2991">                                        verb_object.c_str()).c_str(),</a>
<a name="ln2992">                           false, 'n'))</a>
<a name="ln2993">        {</a>
<a name="ln2994">            canned_msg(MSG_OK);</a>
<a name="ln2995">            return;</a>
<a name="ln2996">        }</a>
<a name="ln2997"> </a>
<a name="ln2998">        if (scroll-&gt;sub_type == SCR_BLINKING</a>
<a name="ln2999">            &amp;&amp; orb_limits_translocation()</a>
<a name="ln3000">            &amp;&amp; !yesno(&quot;Your blink will be uncontrolled - continue anyway?&quot;,</a>
<a name="ln3001">                      false, 'n'))</a>
<a name="ln3002">        {</a>
<a name="ln3003">            canned_msg(MSG_OK);</a>
<a name="ln3004">            return;</a>
<a name="ln3005">        }</a>
<a name="ln3006">    }</a>
<a name="ln3007"> </a>
<a name="ln3008">    if (you.get_mutation_level(MUT_BLURRY_VISION)</a>
<a name="ln3009">        &amp;&amp; !i_feel_safe(false, false, true)</a>
<a name="ln3010">        &amp;&amp; !yesno(&quot;Really read with blurry vision while enemies are nearby?&quot;,</a>
<a name="ln3011">                  false, 'n'))</a>
<a name="ln3012">    {</a>
<a name="ln3013">        canned_msg(MSG_OK);</a>
<a name="ln3014">        return;</a>
<a name="ln3015">    }</a>
<a name="ln3016"> </a>
<a name="ln3017">    // Ok - now we FINALLY get to read a scroll !!! {dlb}</a>
<a name="ln3018">    you.turn_is_over = true;</a>
<a name="ln3019"> </a>
<a name="ln3020">    if (you.duration[DUR_BRAINLESS] &amp;&amp; !one_chance_in(5))</a>
<a name="ln3021">    {</a>
<a name="ln3022">        mpr(&quot;You almost manage to decipher the scroll,&quot;</a>
<a name="ln3023">            &quot; but fail in this attempt.&quot;);</a>
<a name="ln3024">        return;</a>
<a name="ln3025">    }</a>
<a name="ln3026"> </a>
<a name="ln3027">    // if we have blurry vision, we need to start a delay before the actual</a>
<a name="ln3028">    // scroll effect kicks in.</a>
<a name="ln3029">    if (you.get_mutation_level(MUT_BLURRY_VISION))</a>
<a name="ln3030">    {</a>
<a name="ln3031">        // takes 0.5, 1, 2 extra turns</a>
<a name="ln3032">        const int turns = max(1, you.get_mutation_level(MUT_BLURRY_VISION) - 1);</a>
<a name="ln3033">        start_delay&lt;BlurryScrollDelay&gt;(turns, *scroll);</a>
<a name="ln3034">        if (you.get_mutation_level(MUT_BLURRY_VISION) == 1)</a>
<a name="ln3035">            you.time_taken /= 2;</a>
<a name="ln3036">    }</a>
<a name="ln3037">    else</a>
<a name="ln3038">        read_scroll(*scroll);</a>
<a name="ln3039">}</a>
<a name="ln3040"> </a>
<a name="ln3041">/**</a>
<a name="ln3042"> * Read the provided scroll.</a>
<a name="ln3043"> *</a>
<a name="ln3044"> * Does NOT check whether the player can currently read, whether the scroll is</a>
<a name="ln3045"> * currently useless, etc. Likewise doesn't handle blurry vision, setting</a>
<a name="ln3046"> * you.turn_is_over, and other externals. DOES destroy one scroll, unless the</a>
<a name="ln3047"> * player chooses to cancel at the last moment.</a>
<a name="ln3048"> *</a>
<a name="ln3049"> * @param scroll The scroll to be read.</a>
<a name="ln3050"> */</a>
<a name="ln3051">void read_scroll(item_def&amp; scroll)</a>
<a name="ln3052">{</a>
<a name="ln3053">    const scroll_type which_scroll = static_cast&lt;scroll_type&gt;(scroll.sub_type);</a>
<a name="ln3054">    const int prev_quantity = scroll.quantity;</a>
<a name="ln3055">    int link = in_inventory(scroll) ? scroll.link : -1;</a>
<a name="ln3056">    const bool alreadyknown = item_type_known(scroll);</a>
<a name="ln3057"> </a>
<a name="ln3058">    // For cancellable scrolls leave printing this message to their</a>
<a name="ln3059">    // respective functions.</a>
<a name="ln3060">    const string pre_succ_msg =</a>
<a name="ln3061">            make_stringf(&quot;As you read the %s, it crumbles to dust.&quot;,</a>
<a name="ln3062">                          scroll.name(DESC_QUALNAME).c_str());</a>
<a name="ln3063">    if (!_is_cancellable_scroll(which_scroll))</a>
<a name="ln3064">    {</a>
<a name="ln3065">        mpr(pre_succ_msg);</a>
<a name="ln3066">        // Actual removal of scroll done afterwards. -- bwr</a>
<a name="ln3067">    }</a>
<a name="ln3068"> </a>
<a name="ln3069">    const bool dangerous = player_in_a_dangerous_place();</a>
<a name="ln3070"> </a>
<a name="ln3071">    // ... but some scrolls may still be cancelled afterwards.</a>
<a name="ln3072">    bool cancel_scroll = false;</a>
<a name="ln3073">    bool bad_effect = false; // for Xom: result is bad (or at least dangerous)</a>
<a name="ln3074"> </a>
<a name="ln3075">    switch (which_scroll)</a>
<a name="ln3076">    {</a>
<a name="ln3077">    case SCR_RANDOM_USELESSNESS:</a>
<a name="ln3078">        random_uselessness();</a>
<a name="ln3079">        break;</a>
<a name="ln3080"> </a>
<a name="ln3081">    case SCR_BLINKING:</a>
<a name="ln3082">    {</a>
<a name="ln3083">        const string reason = you.no_tele_reason(true, true);</a>
<a name="ln3084">        if (!reason.empty())</a>
<a name="ln3085">        {</a>
<a name="ln3086">            mpr(pre_succ_msg);</a>
<a name="ln3087">            mpr(reason);</a>
<a name="ln3088">            break;</a>
<a name="ln3089">        }</a>
<a name="ln3090"> </a>
<a name="ln3091">        const bool safely_cancellable</a>
<a name="ln3092">            = alreadyknown &amp;&amp; !you.get_mutation_level(MUT_BLURRY_VISION);</a>
<a name="ln3093"> </a>
<a name="ln3094">        if (orb_limits_translocation())</a>
<a name="ln3095">        {</a>
<a name="ln3096">            mprf(MSGCH_ORB, &quot;The Orb prevents control of your translocation!&quot;);</a>
<a name="ln3097">            uncontrolled_blink();</a>
<a name="ln3098">        }</a>
<a name="ln3099">        else</a>
<a name="ln3100">        {</a>
<a name="ln3101">            cancel_scroll = (cast_controlled_blink(false, safely_cancellable)</a>
<a name="ln3102">                             == spret::abort) &amp;&amp; alreadyknown;</a>
<a name="ln3103">        }</a>
<a name="ln3104"> </a>
<a name="ln3105">        if (!cancel_scroll)</a>
<a name="ln3106">            mpr(pre_succ_msg); // ordering is iffy but w/e</a>
<a name="ln3107">    }</a>
<a name="ln3108">        break;</a>
<a name="ln3109"> </a>
<a name="ln3110">    case SCR_TELEPORTATION:</a>
<a name="ln3111">        you_teleport();</a>
<a name="ln3112">        break;</a>
<a name="ln3113"> </a>
<a name="ln3114">    case SCR_REMOVE_CURSE:</a>
<a name="ln3115">        if (!alreadyknown)</a>
<a name="ln3116">        {</a>
<a name="ln3117">            mpr(pre_succ_msg);</a>
<a name="ln3118">            remove_curse(false);</a>
<a name="ln3119">        }</a>
<a name="ln3120">        else</a>
<a name="ln3121">            cancel_scroll = !remove_curse(true, pre_succ_msg);</a>
<a name="ln3122">        break;</a>
<a name="ln3123"> </a>
<a name="ln3124">    case SCR_ACQUIREMENT:</a>
<a name="ln3125">        if (!alreadyknown)</a>
<a name="ln3126">        {</a>
<a name="ln3127">            mpr(pre_succ_msg);</a>
<a name="ln3128">            mpr(&quot;This is a scroll of acquirement!&quot;);</a>
<a name="ln3129">        }</a>
<a name="ln3130"> </a>
<a name="ln3131">        // included in default force_more_message</a>
<a name="ln3132">        // Identify it early in case the player checks the '\' screen.</a>
<a name="ln3133">        set_ident_type(scroll, true);</a>
<a name="ln3134"> </a>
<a name="ln3135">        if (feat_eliminates_items(grd(you.pos())))</a>
<a name="ln3136">        {</a>
<a name="ln3137">            mpr(&quot;Anything you acquired here would fall and be lost!&quot;);</a>
<a name="ln3138">            cancel_scroll = true;</a>
<a name="ln3139">            break;</a>
<a name="ln3140">            // yes, we cancel out even if the scroll wasn't known beforehand.</a>
<a name="ln3141">            // there's no plausible abuse of this, and it's much better to</a>
<a name="ln3142">            // never have to worry about &quot;am i over dangerous terrain?&quot; while</a>
<a name="ln3143">            // IDing scrolls. (Not an interesting ID game mechanic!)</a>
<a name="ln3144">        }</a>
<a name="ln3145"> </a>
<a name="ln3146">        run_uncancel(UNC_ACQUIREMENT, AQ_SCROLL);</a>
<a name="ln3147">        break;</a>
<a name="ln3148"> </a>
<a name="ln3149">    case SCR_FEAR:</a>
<a name="ln3150">        mpr(&quot;You assume a fearsome visage.&quot;);</a>
<a name="ln3151">        mass_enchantment(ENCH_FEAR, 1000);</a>
<a name="ln3152">        break;</a>
<a name="ln3153"> </a>
<a name="ln3154">    case SCR_NOISE:</a>
<a name="ln3155">        noisy(25, you.pos(), &quot;You hear a loud clanging noise!&quot;);</a>
<a name="ln3156">        break;</a>
<a name="ln3157"> </a>
<a name="ln3158">    case SCR_SUMMONING:</a>
<a name="ln3159">        cast_shadow_creatures(MON_SUMM_SCROLL);</a>
<a name="ln3160">        break;</a>
<a name="ln3161"> </a>
<a name="ln3162">    case SCR_FOG:</a>
<a name="ln3163">    {</a>
<a name="ln3164">        if (alreadyknown &amp;&amp; (env.level_state &amp; LSTATE_STILL_WINDS))</a>
<a name="ln3165">        {</a>
<a name="ln3166">            mpr(&quot;The air is too still for clouds to form.&quot;);</a>
<a name="ln3167">            cancel_scroll = true;</a>
<a name="ln3168">            break;</a>
<a name="ln3169">        }</a>
<a name="ln3170">        mpr(&quot;The scroll dissolves into smoke.&quot;);</a>
<a name="ln3171">        auto smoke = random_smoke_type();</a>
<a name="ln3172">        big_cloud(smoke, &amp;you, you.pos(), 50, 8 + random2(8));</a>
<a name="ln3173">        break;</a>
<a name="ln3174">    }</a>
<a name="ln3175"> </a>
<a name="ln3176">    case SCR_MAGIC_MAPPING:</a>
<a name="ln3177">        if (alreadyknown &amp;&amp; !is_map_persistent())</a>
<a name="ln3178">        {</a>
<a name="ln3179">            cancel_scroll = true;</a>
<a name="ln3180">            mpr(&quot;It would have no effect in this place.&quot;);</a>
<a name="ln3181">            break;</a>
<a name="ln3182">        }</a>
<a name="ln3183">        mpr(pre_succ_msg);</a>
<a name="ln3184">        magic_mapping(500, 100, false);</a>
<a name="ln3185">        break;</a>
<a name="ln3186"> </a>
<a name="ln3187">    case SCR_TORMENT:</a>
<a name="ln3188">        torment(&amp;you, TORMENT_SCROLL, you.pos());</a>
<a name="ln3189"> </a>
<a name="ln3190">        // This is only naughty if you know you're doing it.</a>
<a name="ln3191">        did_god_conduct(DID_EVIL, 10, item_type_known(scroll));</a>
<a name="ln3192">        bad_effect = !player_res_torment(false);</a>
<a name="ln3193">        break;</a>
<a name="ln3194"> </a>
<a name="ln3195">    case SCR_IMMOLATION:</a>
<a name="ln3196">    {</a>
<a name="ln3197">        bool had_effect = false;</a>
<a name="ln3198">        for (monster_near_iterator mi(you.pos(), LOS_NO_TRANS); mi; ++mi)</a>
<a name="ln3199">        {</a>
<a name="ln3200">            if (mons_immune_magic(**mi))</a>
<a name="ln3201">                continue;</a>
<a name="ln3202"> </a>
<a name="ln3203">            if (mi-&gt;add_ench(mon_enchant(ENCH_INNER_FLAME, 0, &amp;you)))</a>
<a name="ln3204">                had_effect = true;</a>
<a name="ln3205">        }</a>
<a name="ln3206"> </a>
<a name="ln3207">        if (had_effect)</a>
<a name="ln3208">            mpr(&quot;The creatures around you are filled with an inner flame!&quot;);</a>
<a name="ln3209">        else</a>
<a name="ln3210">            mpr(&quot;The air around you briefly surges with heat, but it dissipates.&quot;);</a>
<a name="ln3211"> </a>
<a name="ln3212">        bad_effect = true;</a>
<a name="ln3213">        break;</a>
<a name="ln3214">    }</a>
<a name="ln3215"> </a>
<a name="ln3216">#if TAG_MAJOR_VERSION == 34</a>
<a name="ln3217">    case SCR_CURSE_WEAPON:</a>
<a name="ln3218">    {</a>
<a name="ln3219">        // Not you.weapon() because we want to handle melded weapons too.</a>
<a name="ln3220">        item_def * const weapon = you.slot_item(EQ_WEAPON, true);</a>
<a name="ln3221">        if (!weapon || !is_weapon(*weapon) || weapon-&gt;cursed())</a>
<a name="ln3222">        {</a>
<a name="ln3223">            bool plural = false;</a>
<a name="ln3224">            const string weapon_name =</a>
<a name="ln3225">                weapon ? weapon-&gt;name(DESC_YOUR)</a>
<a name="ln3226">                       : &quot;Your &quot; + you.hand_name(true, &amp;plural);</a>
<a name="ln3227">            mprf(&quot;%s very briefly gain%s a black sheen.&quot;,</a>
<a name="ln3228">                 weapon_name.c_str(), plural ? &quot;&quot; : &quot;s&quot;);</a>
<a name="ln3229">        }</a>
<a name="ln3230">        else</a>
<a name="ln3231">        {</a>
<a name="ln3232">            // Also sets wield_change.</a>
<a name="ln3233">            do_curse_item(*weapon, false);</a>
<a name="ln3234">            learned_something_new(HINT_YOU_CURSED);</a>
<a name="ln3235">            bad_effect = true;</a>
<a name="ln3236">        }</a>
<a name="ln3237">        break;</a>
<a name="ln3238">    }</a>
<a name="ln3239">#endif</a>
<a name="ln3240"> </a>
<a name="ln3241">    case SCR_ENCHANT_WEAPON:</a>
<a name="ln3242">        if (!alreadyknown)</a>
<a name="ln3243">        {</a>
<a name="ln3244">            mpr(pre_succ_msg);</a>
<a name="ln3245">            mpr(&quot;It is a scroll of enchant weapon.&quot;);</a>
<a name="ln3246">            // included in default force_more_message (to show it before menu)</a>
<a name="ln3247">        }</a>
<a name="ln3248"> </a>
<a name="ln3249">        cancel_scroll = !_handle_enchant_weapon(alreadyknown, pre_succ_msg);</a>
<a name="ln3250">        break;</a>
<a name="ln3251"> </a>
<a name="ln3252">    case SCR_BRAND_WEAPON:</a>
<a name="ln3253">        if (!alreadyknown)</a>
<a name="ln3254">        {</a>
<a name="ln3255">            mpr(pre_succ_msg);</a>
<a name="ln3256">            mpr(&quot;It is a scroll of brand weapon.&quot;);</a>
<a name="ln3257">            // included in default force_more_message (to show it before menu)</a>
<a name="ln3258">        }</a>
<a name="ln3259"> </a>
<a name="ln3260">        cancel_scroll = !_handle_brand_weapon(alreadyknown, pre_succ_msg);</a>
<a name="ln3261">        break;</a>
<a name="ln3262"> </a>
<a name="ln3263">    case SCR_IDENTIFY:</a>
<a name="ln3264">        if (!alreadyknown)</a>
<a name="ln3265">        {</a>
<a name="ln3266">            mpr(pre_succ_msg);</a>
<a name="ln3267">            mpr(&quot;It is a scroll of identify.&quot;);</a>
<a name="ln3268">            // included in default force_more_message (to show it before menu)</a>
<a name="ln3269">            // Do this here so it doesn't turn up in the ID menu.</a>
<a name="ln3270">            set_ident_type(scroll, true);</a>
<a name="ln3271">        }</a>
<a name="ln3272">        cancel_scroll = !_identify(alreadyknown, pre_succ_msg, link);</a>
<a name="ln3273">        break;</a>
<a name="ln3274"> </a>
<a name="ln3275">    case SCR_ENCHANT_ARMOUR:</a>
<a name="ln3276">        if (!alreadyknown)</a>
<a name="ln3277">        {</a>
<a name="ln3278">            mpr(pre_succ_msg);</a>
<a name="ln3279">            mpr(&quot;It is a scroll of enchant armour.&quot;);</a>
<a name="ln3280">            // included in default force_more_message (to show it before menu)</a>
<a name="ln3281">        }</a>
<a name="ln3282">        cancel_scroll =</a>
<a name="ln3283">            (_handle_enchant_armour(alreadyknown, pre_succ_msg) == -1);</a>
<a name="ln3284">        break;</a>
<a name="ln3285">#if TAG_MAJOR_VERSION == 34</a>
<a name="ln3286">    // Should always be identified by Ashenzari.</a>
<a name="ln3287">    case SCR_CURSE_ARMOUR:</a>
<a name="ln3288">    case SCR_CURSE_JEWELLERY:</a>
<a name="ln3289">    {</a>
<a name="ln3290">        const bool armour = which_scroll == SCR_CURSE_ARMOUR;</a>
<a name="ln3291">        cancel_scroll = !curse_item(armour, pre_succ_msg);</a>
<a name="ln3292">        break;</a>
<a name="ln3293">    }</a>
<a name="ln3294"> </a>
<a name="ln3295">    case SCR_RECHARGING:</a>
<a name="ln3296">    {</a>
<a name="ln3297">        mpr(&quot;This item has been removed, sorry!&quot;);</a>
<a name="ln3298">        cancel_scroll = true;</a>
<a name="ln3299">        break;</a>
<a name="ln3300">    }</a>
<a name="ln3301">#endif</a>
<a name="ln3302"> </a>
<a name="ln3303">    case SCR_HOLY_WORD:</a>
<a name="ln3304">    {</a>
<a name="ln3305">        holy_word(100, HOLY_WORD_SCROLL, you.pos(), false, &amp;you);</a>
<a name="ln3306"> </a>
<a name="ln3307">        // This is always naughty, even if you didn't affect anyone.</a>
<a name="ln3308">        // Don't speak those foul holy words even in jest!</a>
<a name="ln3309">        did_god_conduct(DID_HOLY, 10, item_type_known(scroll));</a>
<a name="ln3310">        bad_effect = you.undead_or_demonic();</a>
<a name="ln3311">        break;</a>
<a name="ln3312">    }</a>
<a name="ln3313"> </a>
<a name="ln3314">    case SCR_SILENCE:</a>
<a name="ln3315">        cast_silence(30);</a>
<a name="ln3316">        break;</a>
<a name="ln3317"> </a>
<a name="ln3318">    case SCR_VULNERABILITY:</a>
<a name="ln3319">        _vulnerability_scroll();</a>
<a name="ln3320">        break;</a>
<a name="ln3321"> </a>
<a name="ln3322">    case SCR_AMNESIA:</a>
<a name="ln3323">        if (!alreadyknown)</a>
<a name="ln3324">        {</a>
<a name="ln3325">            mpr(pre_succ_msg);</a>
<a name="ln3326">            mpr(&quot;It is a scroll of amnesia.&quot;);</a>
<a name="ln3327">            // included in default force_more_message (to show it before menu)</a>
<a name="ln3328">        }</a>
<a name="ln3329">        if (you.spell_no == 0)</a>
<a name="ln3330">            mpr(&quot;You feel forgetful for a moment.&quot;);</a>
<a name="ln3331">        else</a>
<a name="ln3332">        {</a>
<a name="ln3333">            bool done;</a>
<a name="ln3334">            bool aborted;</a>
<a name="ln3335">            do</a>
<a name="ln3336">            {</a>
<a name="ln3337">                aborted = cast_selective_amnesia() == -1;</a>
<a name="ln3338">                done = !aborted</a>
<a name="ln3339">                       || alreadyknown</a>
<a name="ln3340">                       || crawl_state.seen_hups</a>
<a name="ln3341">                       || yesno(&quot;Really abort (and waste the scroll)?&quot;,</a>
<a name="ln3342">                                false, 0);</a>
<a name="ln3343">                cancel_scroll = aborted &amp;&amp; alreadyknown;</a>
<a name="ln3344">            } while (!done);</a>
<a name="ln3345">            if (aborted)</a>
<a name="ln3346">                canned_msg(MSG_OK);</a>
<a name="ln3347">        }</a>
<a name="ln3348">        break;</a>
<a name="ln3349"> </a>
<a name="ln3350">    default:</a>
<a name="ln3351">        mpr(&quot;Read a buggy scroll, please report this.&quot;);</a>
<a name="ln3352">        break;</a>
<a name="ln3353">    }</a>
<a name="ln3354"> </a>
<a name="ln3355">    if (cancel_scroll)</a>
<a name="ln3356">        you.turn_is_over = false;</a>
<a name="ln3357"> </a>
<a name="ln3358">    set_ident_type(scroll, true);</a>
<a name="ln3359">    set_ident_flags(scroll, ISFLAG_KNOW_TYPE); // for notes</a>
<a name="ln3360"> </a>
<a name="ln3361">    string scroll_name = scroll.name(DESC_QUALNAME);</a>
<a name="ln3362"> </a>
<a name="ln3363">    if (!cancel_scroll)</a>
<a name="ln3364">    {</a>
<a name="ln3365">        if (in_inventory(scroll))</a>
<a name="ln3366">            dec_inv_item_quantity(link, 1);</a>
<a name="ln3367">        else</a>
<a name="ln3368">            dec_mitm_item_quantity(scroll.index(), 1);</a>
<a name="ln3369">        count_action(CACT_USE, OBJ_SCROLLS);</a>
<a name="ln3370">    }</a>
<a name="ln3371"> </a>
<a name="ln3372">    if (!alreadyknown</a>
<a name="ln3373">        &amp;&amp; which_scroll != SCR_ACQUIREMENT</a>
<a name="ln3374">        &amp;&amp; which_scroll != SCR_BRAND_WEAPON</a>
<a name="ln3375">        &amp;&amp; which_scroll != SCR_ENCHANT_WEAPON</a>
<a name="ln3376">        &amp;&amp; which_scroll != SCR_IDENTIFY</a>
<a name="ln3377">        &amp;&amp; which_scroll != SCR_ENCHANT_ARMOUR</a>
<a name="ln3378">#if TAG_MAJOR_VERSION == 34</a>
<a name="ln3379">        &amp;&amp; which_scroll != SCR_RECHARGING</a>
<a name="ln3380">#endif</a>
<a name="ln3381">        &amp;&amp; which_scroll != SCR_AMNESIA)</a>
<a name="ln3382">    {</a>
<a name="ln3383">        mprf(&quot;It %s a %s.&quot;,</a>
<a name="ln3384">             scroll.quantity &lt; prev_quantity ? &quot;was&quot; : &quot;is&quot;,</a>
<a name="ln3385">             scroll_name.c_str());</a>
<a name="ln3386">    }</a>
<a name="ln3387"> </a>
<a name="ln3388">    if (!alreadyknown &amp;&amp; dangerous)</a>
<a name="ln3389">    {</a>
<a name="ln3390">        // Xom loves it when you read an unknown scroll and there is a</a>
<a name="ln3391">        // dangerous monster nearby... (though not as much as potions</a>
<a name="ln3392">        // since there are no *really* bad scrolls, merely useless ones).</a>
<a name="ln3393">        xom_is_stimulated(bad_effect ? 100 : 50);</a>
<a name="ln3394">    }</a>
<a name="ln3395"> </a>
<a name="ln3396">    if (!alreadyknown)</a>
<a name="ln3397">        auto_assign_item_slot(scroll);</a>
<a name="ln3398"> </a>
<a name="ln3399">}</a>
<a name="ln3400"> </a>
<a name="ln3401">#ifdef USE_TILE</a>
<a name="ln3402">// Interactive menu for item drop/use.</a>
<a name="ln3403"> </a>
<a name="ln3404">void tile_item_use_floor(int idx)</a>
<a name="ln3405">{</a>
<a name="ln3406">    if (mitm[idx].is_type(OBJ_CORPSES, CORPSE_BODY))</a>
<a name="ln3407">        butchery(&amp;mitm[idx]);</a>
<a name="ln3408">}</a>
<a name="ln3409"> </a>
<a name="ln3410">void tile_item_pickup(int idx, bool part)</a>
<a name="ln3411">{</a>
<a name="ln3412">    if (item_is_stationary(mitm[idx]))</a>
<a name="ln3413">    {</a>
<a name="ln3414">        mpr(&quot;You can't pick that up.&quot;);</a>
<a name="ln3415">        return;</a>
<a name="ln3416">    }</a>
<a name="ln3417"> </a>
<a name="ln3418">    if (part)</a>
<a name="ln3419">    {</a>
<a name="ln3420">        pickup_menu(idx);</a>
<a name="ln3421">        return;</a>
<a name="ln3422">    }</a>
<a name="ln3423">    pickup_single_item(idx, -1);</a>
<a name="ln3424">}</a>
<a name="ln3425"> </a>
<a name="ln3426">void tile_item_drop(int idx, bool partdrop)</a>
<a name="ln3427">{</a>
<a name="ln3428">    int quantity = you.inv[idx].quantity;</a>
<a name="ln3429">    if (partdrop &amp;&amp; quantity &gt; 1)</a>
<a name="ln3430">    {</a>
<a name="ln3431">        quantity = prompt_for_int(&quot;Drop how many? &quot;, true);</a>
<a name="ln3432">        if (quantity &lt; 1)</a>
<a name="ln3433">        {</a>
<a name="ln3434">            canned_msg(MSG_OK);</a>
<a name="ln3435">            return;</a>
<a name="ln3436">        }</a>
<a name="ln3437">        if (quantity &gt; you.inv[idx].quantity)</a>
<a name="ln3438">            quantity = you.inv[idx].quantity;</a>
<a name="ln3439">    }</a>
<a name="ln3440">    drop_item(idx, quantity);</a>
<a name="ln3441">}</a>
<a name="ln3442"> </a>
<a name="ln3443">void tile_item_eat_floor(int idx)</a>
<a name="ln3444">{</a>
<a name="ln3445">    if (can_eat(mitm[idx], false))</a>
<a name="ln3446">        eat_item(mitm[idx]);</a>
<a name="ln3447">}</a>
<a name="ln3448"> </a>
<a name="ln3449">void tile_item_use_secondary(int idx)</a>
<a name="ln3450">{</a>
<a name="ln3451">    const item_def item = you.inv[idx];</a>
<a name="ln3452"> </a>
<a name="ln3453">    if (item.base_type == OBJ_WEAPONS &amp;&amp; is_throwable(&amp;you, item))</a>
<a name="ln3454">    {</a>
<a name="ln3455">        if (check_warning_inscriptions(item, OPER_FIRE))</a>
<a name="ln3456">            fire_thing(idx); // fire weapons</a>
<a name="ln3457">    }</a>
<a name="ln3458">    else if (you.equip[EQ_WEAPON] == idx)</a>
<a name="ln3459">        wield_weapon(true, SLOT_BARE_HANDS);</a>
<a name="ln3460">    else if (item_is_wieldable(item))</a>
<a name="ln3461">    {</a>
<a name="ln3462">        // secondary wield for several spells and such</a>
<a name="ln3463">        wield_weapon(true, idx); // wield</a>
<a name="ln3464">    }</a>
<a name="ln3465">}</a>
<a name="ln3466"> </a>
<a name="ln3467">void tile_item_use(int idx)</a>
<a name="ln3468">{</a>
<a name="ln3469">    const item_def item = you.inv[idx];</a>
<a name="ln3470"> </a>
<a name="ln3471">    // Equipped?</a>
<a name="ln3472">    bool equipped = false;</a>
<a name="ln3473">    bool equipped_weapon = false;</a>
<a name="ln3474">    for (unsigned int i = EQ_FIRST_EQUIP; i &lt; NUM_EQUIP; i++)</a>
<a name="ln3475">    {</a>
<a name="ln3476">        if (you.equip[i] == idx)</a>
<a name="ln3477">        {</a>
<a name="ln3478">            equipped = true;</a>
<a name="ln3479">            if (i == EQ_WEAPON)</a>
<a name="ln3480">                equipped_weapon = true;</a>
<a name="ln3481">            break;</a>
<a name="ln3482">        }</a>
<a name="ln3483">    }</a>
<a name="ln3484"> </a>
<a name="ln3485">    // Special case for folks who are wielding something</a>
<a name="ln3486">    // that they shouldn't be wielding.</a>
<a name="ln3487">    // Note that this is only a problem for equipables</a>
<a name="ln3488">    // (otherwise it would only waste a turn)</a>
<a name="ln3489">    if (you.equip[EQ_WEAPON] == idx</a>
<a name="ln3490">        &amp;&amp; (item.base_type == OBJ_ARMOUR</a>
<a name="ln3491">            || item.base_type == OBJ_JEWELLERY))</a>
<a name="ln3492">    {</a>
<a name="ln3493">        wield_weapon(true, SLOT_BARE_HANDS);</a>
<a name="ln3494">        return;</a>
<a name="ln3495">    }</a>
<a name="ln3496"> </a>
<a name="ln3497">    const int type = item.base_type;</a>
<a name="ln3498"> </a>
<a name="ln3499">    // Use it</a>
<a name="ln3500">    switch (type)</a>
<a name="ln3501">    {</a>
<a name="ln3502">        case OBJ_WEAPONS:</a>
<a name="ln3503">        case OBJ_STAVES:</a>
<a name="ln3504">        case OBJ_MISCELLANY:</a>
<a name="ln3505">        case OBJ_WANDS:</a>
<a name="ln3506">            // Wield any unwielded item of these types.</a>
<a name="ln3507">            if (!equipped &amp;&amp; item_is_wieldable(item))</a>
<a name="ln3508">            {</a>
<a name="ln3509">                wield_weapon(true, idx);</a>
<a name="ln3510">                return;</a>
<a name="ln3511">            }</a>
<a name="ln3512">            // Evoke misc. items or wands.</a>
<a name="ln3513">            if (item_is_evokable(item, false))</a>
<a name="ln3514">            {</a>
<a name="ln3515">                evoke_item(idx);</a>
<a name="ln3516">                return;</a>
<a name="ln3517">            }</a>
<a name="ln3518">            // Unwield wielded items.</a>
<a name="ln3519">            if (equipped)</a>
<a name="ln3520">                wield_weapon(true, SLOT_BARE_HANDS);</a>
<a name="ln3521">            return;</a>
<a name="ln3522"> </a>
<a name="ln3523">        case OBJ_MISSILES:</a>
<a name="ln3524">            if (check_warning_inscriptions(item, OPER_FIRE))</a>
<a name="ln3525">                fire_thing(idx);</a>
<a name="ln3526">            return;</a>
<a name="ln3527"> </a>
<a name="ln3528">        case OBJ_ARMOUR:</a>
<a name="ln3529">            if (!form_can_wear())</a>
<a name="ln3530">            {</a>
<a name="ln3531">                mpr(&quot;You can't wear or remove anything in your present form.&quot;);</a>
<a name="ln3532">                return;</a>
<a name="ln3533">            }</a>
<a name="ln3534">            if (equipped &amp;&amp; !equipped_weapon)</a>
<a name="ln3535">            {</a>
<a name="ln3536">                if (check_warning_inscriptions(item, OPER_TAKEOFF))</a>
<a name="ln3537">                    takeoff_armour(idx);</a>
<a name="ln3538">            }</a>
<a name="ln3539">            else if (check_warning_inscriptions(item, OPER_WEAR))</a>
<a name="ln3540">                wear_armour(idx);</a>
<a name="ln3541">            return;</a>
<a name="ln3542"> </a>
<a name="ln3543">        case OBJ_FOOD:</a>
<a name="ln3544">            if (check_warning_inscriptions(item, OPER_EAT))</a>
<a name="ln3545">                eat_food(idx);</a>
<a name="ln3546">            return;</a>
<a name="ln3547"> </a>
<a name="ln3548">        case OBJ_SCROLLS:</a>
<a name="ln3549">            if (check_warning_inscriptions(item, OPER_READ))</a>
<a name="ln3550">                read(&amp;you.inv[idx]);</a>
<a name="ln3551">            return;</a>
<a name="ln3552"> </a>
<a name="ln3553">        case OBJ_JEWELLERY:</a>
<a name="ln3554">            if (equipped &amp;&amp; !equipped_weapon)</a>
<a name="ln3555">                remove_ring(idx);</a>
<a name="ln3556">            else if (check_warning_inscriptions(item, OPER_PUTON))</a>
<a name="ln3557">                puton_ring(idx);</a>
<a name="ln3558">            return;</a>
<a name="ln3559"> </a>
<a name="ln3560">        case OBJ_POTIONS:</a>
<a name="ln3561">            if (check_warning_inscriptions(item, OPER_QUAFF))</a>
<a name="ln3562">                drink(&amp;you.inv[idx]);</a>
<a name="ln3563">            return;</a>
<a name="ln3564"> </a>
<a name="ln3565">        default:</a>
<a name="ln3566">            return;</a>
<a name="ln3567">    }</a>
<a name="ln3568">}</a>
<a name="ln3569">#endif</a>

</code></pre>
<div class="balloon" rel="247"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v648/" target="_blank">V648</a> Priority of the '&&' operation is higher than that of the '||' operation.</p></div>
<div class="balloon" rel="356"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v522/" target="_blank">V522</a> There might be dereferencing of a potential null pointer 'ie'.</p></div>
<div class="balloon" rel="583"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v648/" target="_blank">V648</a> Priority of the '&&' operation is higher than that of the '||' operation.</p></div>
<div class="balloon" rel="1598"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v648/" target="_blank">V648</a> Priority of the '&&' operation is higher than that of the '||' operation.</p></div>

<link rel="stylesheet" href="highlight.css">
<script src="highlight.pack.js"></script>
<script src="highlightjs-line-numbers.js"></script>
<script>hljs.initHighlightingOnLoad();</script>
<script>hljs.initLineNumbersOnLoad();</script>
<script>
  $(document).ready(function() {
      $('.balloon').each(function () {
          var bl = $(this);
          var line = bl.attr('rel');
          var text = $('a[name="ln'+line+'"]').text();

          var space_count = 0;
          for(var i = 0; i<text.length; i++){
              var char = text[i];
              if((char !== ' ')&&(char !== '\t'))break;
              if(char === '\t')space_count++;
              space_count++;
          }

          bl.css('margin-left', space_count*8);
          $('a[name="ln'+line+'"]').after(bl);
      });

      window.location = window.location;
  });
</script>
</body>
</html>
