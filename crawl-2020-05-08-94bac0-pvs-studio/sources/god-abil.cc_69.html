
<html>
<head>

  <meta http-equiv="Content-Type" content="text/html; charset=US-ASCII" />
  <title>god-abil.cc</title>

  <link rel="stylesheet" href="../style.css"/>
  <script src="../jquery-3.2.1.min.js"></script>
</head>
<body>

<pre><code class = "cpp">
<a name="ln1">/**</a>
<a name="ln2"> * @file</a>
<a name="ln3"> * @brief God-granted abilities.</a>
<a name="ln4">**/</a>
<a name="ln5"> </a>
<a name="ln6">#include &quot;AppHdr.h&quot;</a>
<a name="ln7"> </a>
<a name="ln8">#include &quot;god-abil.h&quot;</a>
<a name="ln9"> </a>
<a name="ln10">#include &lt;cmath&gt;</a>
<a name="ln11">#include &lt;numeric&gt;</a>
<a name="ln12">#include &lt;sstream&gt;</a>
<a name="ln13"> </a>
<a name="ln14">#include &quot;act-iter.h&quot;</a>
<a name="ln15">#include &quot;areas.h&quot;</a>
<a name="ln16">#include &quot;attitude-change.h&quot;</a>
<a name="ln17">#include &quot;bloodspatter.h&quot;</a>
<a name="ln18">#include &quot;branch.h&quot;</a>
<a name="ln19">#include &quot;chardump.h&quot;</a>
<a name="ln20">#include &quot;cloud.h&quot;</a>
<a name="ln21">#include &quot;colour.h&quot;</a>
<a name="ln22">#include &quot;coordit.h&quot;</a>
<a name="ln23">#include &quot;dactions.h&quot;</a>
<a name="ln24">#include &quot;database.h&quot;</a>
<a name="ln25">#include &quot;dgn-overview.h&quot;</a>
<a name="ln26">#include &quot;directn.h&quot;</a>
<a name="ln27">#include &quot;dungeon.h&quot;</a>
<a name="ln28">#include &quot;english.h&quot;</a>
<a name="ln29">#include &quot;fight.h&quot;</a>
<a name="ln30">#include &quot;files.h&quot;</a>
<a name="ln31">#include &quot;fineff.h&quot;</a>
<a name="ln32">#include &quot;food.h&quot;</a>
<a name="ln33">#include &quot;format.h&quot; // formatted_string</a>
<a name="ln34">#include &quot;god-blessing.h&quot;</a>
<a name="ln35">#include &quot;god-companions.h&quot;</a>
<a name="ln36">#include &quot;god-item.h&quot;</a>
<a name="ln37">#include &quot;god-passive.h&quot;</a>
<a name="ln38">#include &quot;hints.h&quot;</a>
<a name="ln39">#include &quot;hiscores.h&quot;</a>
<a name="ln40">#include &quot;invent.h&quot;</a>
<a name="ln41">#include &quot;item-prop.h&quot;</a>
<a name="ln42">#include &quot;item-status-flag-type.h&quot;</a>
<a name="ln43">#include &quot;items.h&quot;</a>
<a name="ln44">#include &quot;item-use.h&quot;</a>
<a name="ln45">#include &quot;libutil.h&quot;</a>
<a name="ln46">#include &quot;losglobal.h&quot;</a>
<a name="ln47">#include &quot;macro.h&quot;</a>
<a name="ln48">#include &quot;mapmark.h&quot;</a>
<a name="ln49">#include &quot;maps.h&quot;</a>
<a name="ln50">#include &quot;message.h&quot;</a>
<a name="ln51">#include &quot;mon-act.h&quot;</a>
<a name="ln52">#include &quot;mon-behv.h&quot;</a>
<a name="ln53">#include &quot;mon-death.h&quot;</a>
<a name="ln54">#include &quot;mon-gear.h&quot; // H: give_weapon()/give_armour()</a>
<a name="ln55">#include &quot;mon-place.h&quot;</a>
<a name="ln56">#include &quot;mon-poly.h&quot;</a>
<a name="ln57">#include &quot;mon-tentacle.h&quot;</a>
<a name="ln58">#include &quot;mon-util.h&quot;</a>
<a name="ln59">#include &quot;movement.h&quot;</a>
<a name="ln60">#include &quot;mutation.h&quot;</a>
<a name="ln61">#include &quot;notes.h&quot;</a>
<a name="ln62">#include &quot;ouch.h&quot;</a>
<a name="ln63">#include &quot;output.h&quot;</a>
<a name="ln64">#include &quot;place.h&quot;</a>
<a name="ln65">#include &quot;player-equip.h&quot;</a>
<a name="ln66">#include &quot;player-stats.h&quot;</a>
<a name="ln67">#include &quot;potion.h&quot;</a>
<a name="ln68">#include &quot;prompt.h&quot;</a>
<a name="ln69">#include &quot;religion.h&quot;</a>
<a name="ln70">#include &quot;shout.h&quot;</a>
<a name="ln71">#include &quot;skill-menu.h&quot;</a>
<a name="ln72">#include &quot;spl-book.h&quot;</a>
<a name="ln73">#include &quot;spl-goditem.h&quot;</a>
<a name="ln74">#include &quot;spl-monench.h&quot;</a>
<a name="ln75">#include &quot;spl-transloc.h&quot;</a>
<a name="ln76">#include &quot;spl-util.h&quot;</a>
<a name="ln77">#include &quot;spl-wpnench.h&quot;</a>
<a name="ln78">#include &quot;sprint.h&quot;</a>
<a name="ln79">#include &quot;state.h&quot;</a>
<a name="ln80">#include &quot;stringutil.h&quot;</a>
<a name="ln81">#include &quot;target.h&quot;</a>
<a name="ln82">#include &quot;teleport.h&quot; // monster_teleport</a>
<a name="ln83">#include &quot;terrain.h&quot;</a>
<a name="ln84">#ifdef USE_TILE</a>
<a name="ln85"> #include &quot;rltiles/tiledef-main.h&quot;</a>
<a name="ln86">#endif</a>
<a name="ln87">#include &quot;timed-effects.h&quot;</a>
<a name="ln88">#include &quot;traps.h&quot;</a>
<a name="ln89">#include &quot;viewchar.h&quot;</a>
<a name="ln90">#include &quot;view.h&quot;</a>
<a name="ln91"> </a>
<a name="ln92">static bool _player_sacrificed_arcana();</a>
<a name="ln93"> </a>
<a name="ln94">// Load the sacrifice_def definition and the sac_data array.</a>
<a name="ln95">#include &quot;sacrifice-data.h&quot;</a>
<a name="ln96"> </a>
<a name="ln97">/** Would a god currently allow using a one-time six-star ability?</a>
<a name="ln98"> * Does not check whether the god actually grants such an ability.</a>
<a name="ln99"> */</a>
<a name="ln100">bool can_do_capstone_ability(god_type god)</a>
<a name="ln101">{</a>
<a name="ln102">   return in_good_standing(god, 5) &amp;&amp; !you.one_time_ability_used[god];</a>
<a name="ln103">}</a>
<a name="ln104"> </a>
<a name="ln105">static const char *_god_blessing_description(god_type god)</a>
<a name="ln106">{</a>
<a name="ln107">    switch (god)</a>
<a name="ln108">    {</a>
<a name="ln109">    case GOD_SHINING_ONE:</a>
<a name="ln110">        return &quot;blessed by the Shining One&quot;;</a>
<a name="ln111">    case GOD_LUGONU:</a>
<a name="ln112">        return &quot;corrupted by Lugonu&quot;;</a>
<a name="ln113">    case GOD_KIKUBAAQUDGHA:</a>
<a name="ln114">        return &quot;bloodied by Kikubaaqudgha&quot;;</a>
<a name="ln115">    default:</a>
<a name="ln116">        return &quot;touched by the gods&quot;;</a>
<a name="ln117">    }</a>
<a name="ln118">}</a>
<a name="ln119"> </a>
<a name="ln120">/**</a>
<a name="ln121"> * Perform a capstone god ability that blesses a weapon with the god's</a>
<a name="ln122"> * brand.</a>
<a name="ln123"> </a>
<a name="ln124"> * @param god    The god performing the blessing.</a>
<a name="ln125"> * @param brand  The brand being granted.</a>
<a name="ln126"> * @param colour The colour to flash when the weapon is branded.</a>
<a name="ln127"> * @returns True if the weapon was successfully branded, false otherwise.</a>
<a name="ln128">*/</a>
<a name="ln129">bool bless_weapon(god_type god, brand_type brand, colour_t colour)</a>
<a name="ln130">{</a>
<a name="ln131">    ASSERT(can_do_capstone_ability(god));</a>
<a name="ln132"> </a>
<a name="ln133">    int item_slot = prompt_invent_item(&quot;Brand which weapon?&quot;,</a>
<a name="ln134">                                       menu_type::invlist,</a>
<a name="ln135">                                       OSEL_BLESSABLE_WEAPON, OPER_ANY,</a>
<a name="ln136">                                       invprompt_flag::escape_only);</a>
<a name="ln137"> </a>
<a name="ln138">    if (item_slot == PROMPT_NOTHING || item_slot == PROMPT_ABORT)</a>
<a name="ln139">    {</a>
<a name="ln140">        canned_msg(MSG_OK);</a>
<a name="ln141">        return false;</a>
<a name="ln142">    }</a>
<a name="ln143"> </a>
<a name="ln144">    item_def&amp; wpn(you.inv[item_slot]);</a>
<a name="ln145">    // Only TSO allows blessing ranged weapons.</a>
<a name="ln146">    if (!is_brandable_weapon(wpn, brand == SPWPN_HOLY_WRATH, true))</a>
<a name="ln147">        return false;</a>
<a name="ln148"> </a>
<a name="ln149">    string prompt = &quot;Do you wish to have &quot; + wpn.name(DESC_YOUR)</a>
<a name="ln150">                       + &quot; &quot;;</a>
<a name="ln151">    if (brand == SPWPN_PAIN)</a>
<a name="ln152">        prompt += &quot;bloodied with pain&quot;;</a>
<a name="ln153">    else if (brand == SPWPN_DISTORTION)</a>
<a name="ln154">        prompt += &quot;corrupted with distortion&quot;;</a>
<a name="ln155">    else</a>
<a name="ln156">        prompt += &quot;blessed with holy wrath&quot;;</a>
<a name="ln157">    prompt += &quot;?&quot;;</a>
<a name="ln158">    if (!yesno(prompt.c_str(), true, 'n'))</a>
<a name="ln159">    {</a>
<a name="ln160">        canned_msg(MSG_OK);</a>
<a name="ln161">        return false;</a>
<a name="ln162">    }</a>
<a name="ln163"> </a>
<a name="ln164">    if (you.duration[DUR_EXCRUCIATING_WOUNDS]) // just in case</a>
<a name="ln165">    {</a>
<a name="ln166">        ASSERT(you.weapon());</a>
<a name="ln167">        end_weapon_brand(*you.weapon());</a>
<a name="ln168">    }</a>
<a name="ln169"> </a>
<a name="ln170">    string old_name = wpn.name(DESC_A);</a>
<a name="ln171">    set_equip_desc(wpn, ISFLAG_GLOWING);</a>
<a name="ln172">    set_item_ego_type(wpn, OBJ_WEAPONS, brand);</a>
<a name="ln173">    enchant_weapon(wpn, true);</a>
<a name="ln174">    enchant_weapon(wpn, true);</a>
<a name="ln175">    if (wpn.cursed())</a>
<a name="ln176">        do_uncurse_item(wpn);</a>
<a name="ln177"> </a>
<a name="ln178">    if (god == GOD_SHINING_ONE)</a>
<a name="ln179">    {</a>
<a name="ln180">        convert2good(wpn);</a>
<a name="ln181"> </a>
<a name="ln182">        if (is_blessed_convertible(wpn))</a>
<a name="ln183">            origin_acquired(wpn, GOD_SHINING_ONE);</a>
<a name="ln184">    }</a>
<a name="ln185">    else if (is_evil_god(god))</a>
<a name="ln186">        convert2bad(wpn);</a>
<a name="ln187"> </a>
<a name="ln188">    you.wield_change = true;</a>
<a name="ln189">    you.one_time_ability_used.set(god);</a>
<a name="ln190">    calc_mp(); // in case the old brand was antimagic,</a>
<a name="ln191">    you.redraw_armour_class = true; // protection,</a>
<a name="ln192">    you.redraw_evasion = true;      // or evasion</a>
<a name="ln193">    const string desc = old_name + &quot; &quot; + _god_blessing_description(god);</a>
<a name="ln194">    take_note(Note(NOTE_ID_ITEM, 0, 0, wpn.name(DESC_A), desc));</a>
<a name="ln195">    wpn.flags |= ISFLAG_NOTED_ID;</a>
<a name="ln196">    wpn.props[FORCED_ITEM_COLOUR_KEY] = colour;</a>
<a name="ln197"> </a>
<a name="ln198">    mprf(MSGCH_GOD, &quot;Your %s shines brightly!&quot;, wpn.name(DESC_QUALNAME).c_str());</a>
<a name="ln199">    flash_view(UA_PLAYER, colour);</a>
<a name="ln200">    simple_god_message(&quot; booms: Use this gift wisely!&quot;);</a>
<a name="ln201">    you.one_time_ability_used.set(you.religion);</a>
<a name="ln202">    take_note(Note(NOTE_GOD_GIFT, you.religion));</a>
<a name="ln203"> </a>
<a name="ln204">    if (god == GOD_SHINING_ONE)</a>
<a name="ln205">    {</a>
<a name="ln206">        holy_word(100, HOLY_WORD_TSO, you.pos(), true);</a>
<a name="ln207">        // Un-bloodify surrounding squares.</a>
<a name="ln208">        for (radius_iterator ri(you.pos(), 3, C_SQUARE, LOS_SOLID); ri; ++ri)</a>
<a name="ln209">            if (is_bloodcovered(*ri))</a>
<a name="ln210">                env.pgrid(*ri) &amp;= ~FPROP_BLOODY;</a>
<a name="ln211">    }</a>
<a name="ln212">    else if (god == GOD_KIKUBAAQUDGHA)</a>
<a name="ln213">    {</a>
<a name="ln214">        you.gift_timeout = 1; // no protection during pain branding weapon</a>
<a name="ln215">        torment(&amp;you, TORMENT_KIKUBAAQUDGHA, you.pos());</a>
<a name="ln216">        you.gift_timeout = 0; // protection after pain branding weapon</a>
<a name="ln217">        // Bloodify surrounding squares (75% chance).</a>
<a name="ln218">        for (radius_iterator ri(you.pos(), 2, C_SQUARE, LOS_SOLID); ri; ++ri)</a>
<a name="ln219">            if (!one_chance_in(4))</a>
<a name="ln220">                maybe_bloodify_square(*ri);</a>
<a name="ln221">    }</a>
<a name="ln222"> </a>
<a name="ln223">#ifndef USE_TILE_LOCAL</a>
<a name="ln224">    // Allow extra time for the flash to linger.</a>
<a name="ln225">    scaled_delay(1000);</a>
<a name="ln226">#endif</a>
<a name="ln227">    return true;</a>
<a name="ln228">}</a>
<a name="ln229"> </a>
<a name="ln230">static int _gold_to_donation(int gold)</a>
<a name="ln231">{</a>
<a name="ln232">    return static_cast&lt;int&gt;((gold * log((float)gold)) / MAX_PIETY);</a>
<a name="ln233">}</a>
<a name="ln234"> </a>
<a name="ln235">// donate gold to gain piety distributed over time</a>
<a name="ln236">bool zin_donate_gold()</a>
<a name="ln237">{</a>
<a name="ln238">    if (you.gold == 0)</a>
<a name="ln239">    {</a>
<a name="ln240">        mpr(&quot;You don't have anything to sacrifice.&quot;);</a>
<a name="ln241">        return false;</a>
<a name="ln242">    }</a>
<a name="ln243"> </a>
<a name="ln244">    if (!yesno(&quot;Do you wish to donate half of your money?&quot;, true, 'n'))</a>
<a name="ln245">    {</a>
<a name="ln246">        canned_msg(MSG_OK);</a>
<a name="ln247">        return false;</a>
<a name="ln248">    }</a>
<a name="ln249"> </a>
<a name="ln250">    const int donation_cost = (you.gold / 2) + 1;</a>
<a name="ln251">    const int donation = _gold_to_donation(donation_cost);</a>
<a name="ln252"> </a>
<a name="ln253">#if defined(DEBUG_DIAGNOSTICS) || defined(DEBUG_SACRIFICE) || defined(DEBUG_PIETY)</a>
<a name="ln254">    mprf(MSGCH_DIAGNOSTICS, &quot;A donation of $%d amounts to an &quot;</a>
<a name="ln255">         &quot;increase of piety by %d.&quot;, donation_cost, donation);</a>
<a name="ln256">#endif</a>
<a name="ln257">    // Take a note of the donation.</a>
<a name="ln258">    take_note(Note(NOTE_DONATE_MONEY, donation_cost));</a>
<a name="ln259"> </a>
<a name="ln260">    you.attribute[ATTR_DONATIONS] += donation_cost;</a>
<a name="ln261"> </a>
<a name="ln262">    you.del_gold(donation_cost);</a>
<a name="ln263"> </a>
<a name="ln264">    if (donation &lt; 1)</a>
<a name="ln265">    {</a>
<a name="ln266">        simple_god_message(&quot; finds your generosity lacking.&quot;);</a>
<a name="ln267">        return false;</a>
<a name="ln268">    }</a>
<a name="ln269"> </a>
<a name="ln270">    you.duration[DUR_PIETY_POOL] += donation;</a>
<a name="ln271">    if (you.duration[DUR_PIETY_POOL] &gt; 30000)</a>
<a name="ln272">        you.duration[DUR_PIETY_POOL] = 30000;</a>
<a name="ln273"> </a>
<a name="ln274">    const int estimated_piety =</a>
<a name="ln275">        min(MAX_PENANCE + MAX_PIETY, you.piety + you.duration[DUR_PIETY_POOL]);</a>
<a name="ln276"> </a>
<a name="ln277">    if (player_under_penance())</a>
<a name="ln278">    {</a>
<a name="ln279">        if (estimated_piety &gt;= you.penance[GOD_ZIN])</a>
<a name="ln280">            mpr(&quot;You feel that you will soon be absolved of all your sins.&quot;);</a>
<a name="ln281">        else</a>
<a name="ln282">            mpr(&quot;You feel that your burden of sins will soon be lighter.&quot;);</a>
<a name="ln283">    }</a>
<a name="ln284">    else</a>
<a name="ln285">    {</a>
<a name="ln286">        string result = &quot;You feel that &quot; + god_name(GOD_ZIN) + &quot; will soon be &quot;;</a>
<a name="ln287">        result +=</a>
<a name="ln288">            (estimated_piety &gt;= piety_breakpoint(5)) ? &quot;exalted by your worship&quot; :</a>
<a name="ln289">            (estimated_piety &gt;= piety_breakpoint(4)) ? &quot;extremely pleased with you&quot; :</a>
<a name="ln290">            (estimated_piety &gt;= piety_breakpoint(3)) ? &quot;greatly pleased with you&quot; :</a>
<a name="ln291">            (estimated_piety &gt;= piety_breakpoint(2)) ? &quot;most pleased with you&quot; :</a>
<a name="ln292">            (estimated_piety &gt;= piety_breakpoint(1)) ? &quot;pleased with you&quot; :</a>
<a name="ln293">            (estimated_piety &gt;= piety_breakpoint(0)) ? &quot;aware of your devotion&quot;</a>
<a name="ln294">                                                     : &quot;noncommittal&quot;;</a>
<a name="ln295">        result += (donation &gt;= 30 &amp;&amp; you.piety &lt; piety_breakpoint(5)) ? &quot;!&quot; : &quot;.&quot;;</a>
<a name="ln296"> </a>
<a name="ln297">        mpr(result);</a>
<a name="ln298">    }</a>
<a name="ln299"> </a>
<a name="ln300">    return true;</a>
<a name="ln301">}</a>
<a name="ln302"> </a>
<a name="ln303">static void _zin_saltify(monster* mon);</a>
<a name="ln304"> </a>
<a name="ln305">static const char * const book_of_zin[][3] =</a>
<a name="ln306">{</a>
<a name="ln307">    {</a>
<a name="ln308">        &quot;It was the word of Zin that there would not be @sin_noun@...&quot;,</a>
<a name="ln309">        &quot;...and did the people not suffer until they had @smitten@...&quot;,</a>
<a name="ln310">        &quot;...the @sinners@, after which all was well?&quot;,</a>
<a name="ln311">    },</a>
<a name="ln312"> </a>
<a name="ln313">    {</a>
<a name="ln314">        &quot;The voice of Zin, pure and clear, did say that the @sinners@...&quot;,</a>
<a name="ln315">        &quot;...were not @virtuous@! And hearing this, the people rose up...&quot;,</a>
<a name="ln316">        &quot;...and embraced @virtue@, for they feared Zin's wrath.&quot;,</a>
<a name="ln317">    },</a>
<a name="ln318"> </a>
<a name="ln319">    {</a>
<a name="ln320">        &quot;Zin spoke of the doctrine of @virtue@, and...&quot;,</a>
<a name="ln321">        &quot;...saw the @sinners@ filled with fear, for they were...&quot;,</a>
<a name="ln322">        &quot;...@sin_adj@ and knew Zin's wrath would come for them.&quot;,</a>
<a name="ln323">    },</a>
<a name="ln324"> </a>
<a name="ln325">    {</a>
<a name="ln326">        &quot;And so Zin bade the @sinners@ to come before...&quot;,</a>
<a name="ln327">        &quot;...the altar, that judgement might be passed...&quot;,</a>
<a name="ln328">        &quot;...upon those who were not @virtuous@.&quot;,</a>
<a name="ln329">    },</a>
<a name="ln330"> </a>
<a name="ln331">    {</a>
<a name="ln332">        &quot;To the devout, Zin provideth. From the rest...&quot;,</a>
<a name="ln333">        &quot;...ye @sinners@, ye guilty...&quot;,</a>
<a name="ln334">        &quot;...of @sin_noun@, Zin taketh.&quot;,</a>
<a name="ln335">    },</a>
<a name="ln336"> </a>
<a name="ln337">    {</a>
<a name="ln338">        &quot;Zin saw the @sin_noun@ of the @sinners@, and...&quot;,</a>
<a name="ln339">        &quot;...was displeased, for did the law not say that...&quot;,</a>
<a name="ln340">        &quot;...those who did not become @virtuous@ would be @smitten@?&quot;,</a>
<a name="ln341">    },</a>
<a name="ln342"> </a>
<a name="ln343">    {</a>
<a name="ln344">        &quot;Zin said that @virtue@ shall be the law of the land, and...&quot;,</a>
<a name="ln345">        &quot;...those who turn to @sin_noun@ will be @smitten@. This was fair...&quot;,</a>
<a name="ln346">        &quot;...and just, and not a voice dissented.&quot;,</a>
<a name="ln347">    },</a>
<a name="ln348"> </a>
<a name="ln349">    {</a>
<a name="ln350">        &quot;Damned, damned be the @sinners@ and...&quot;,</a>
<a name="ln351">        &quot;...all else who abandon @virtue@! Let them...&quot;,</a>
<a name="ln352">        &quot;...be @smitten@ by the jurisprudence of Zin!&quot;,</a>
<a name="ln353">    },</a>
<a name="ln354"> </a>
<a name="ln355">    {</a>
<a name="ln356"> </a>
<a name="ln357">        &quot;And Zin said to all in attendance, 'Which of ye...&quot;,</a>
<a name="ln358">        &quot;...number among the @sinners@? Come before me, that...&quot;,</a>
<a name="ln359">        &quot;...I may @smite@ you now for your @sin_noun@!'&quot;,</a>
<a name="ln360">    },</a>
<a name="ln361"> </a>
<a name="ln362">    {</a>
<a name="ln363">        &quot;Yea, I say unto thee, bring forth...&quot;,</a>
<a name="ln364">        &quot;...the @sinners@ that they may know...&quot;,</a>
<a name="ln365">        &quot;...the wrath of Zin, and thus be @smitten@!&quot;,</a>
<a name="ln366">    },</a>
<a name="ln367"> </a>
<a name="ln368">    {</a>
<a name="ln369">        &quot;In a great set of silver scales are weighed the...&quot;,</a>
<a name="ln370">        &quot;...souls of the @sinners@, and with their @sin_adj@...&quot;,</a>
<a name="ln371">        &quot;...ways, the balance hath tipped against them!&quot;,</a>
<a name="ln372">    },</a>
<a name="ln373"> </a>
<a name="ln374">    {</a>
<a name="ln375">        &quot;It is just that the @sinners@ shall be @smitten@...&quot;,</a>
<a name="ln376">        &quot;...in due time, for @virtue@ is what Zin has declared...&quot;,</a>
<a name="ln377">        &quot;...the law of the land, and Zin's word is law!&quot;,</a>
<a name="ln378">    },</a>
<a name="ln379"> </a>
<a name="ln380">    {</a>
<a name="ln381">        &quot;Thus the people made the covenant of @virtue@ with...&quot;,</a>
<a name="ln382">        &quot;...Zin, and all was good, for they knew that the...&quot;,</a>
<a name="ln383">        &quot;...@sinners@ would trouble them no longer.&quot;,</a>
<a name="ln384">    },</a>
<a name="ln385"> </a>
<a name="ln386">    {</a>
<a name="ln387">        &quot;What of the @sinners@? @Smitten@ for their...&quot;,</a>
<a name="ln388">        &quot;...@sin_noun@ they shall be! Zin will @smite@ them again...&quot;,</a>
<a name="ln389">        &quot;...and again, and again!&quot;,</a>
<a name="ln390">    },</a>
<a name="ln391"> </a>
<a name="ln392">    {</a>
<a name="ln393">        &quot;And lo, the wrath of Zin did find...&quot;,</a>
<a name="ln394">        &quot;...them wherever they hid, and the @sinners@...&quot;,</a>
<a name="ln395">        &quot;...were @smitten@ for their @sin_noun@!&quot;,</a>
<a name="ln396">    },</a>
<a name="ln397"> </a>
<a name="ln398">    {</a>
<a name="ln399">        &quot;Zin looked out upon the remains of the @sinners@...&quot;,</a>
<a name="ln400">        &quot;...and declared it good that they had been...&quot;,</a>
<a name="ln401">        &quot;...@smitten@. And thus justice was done.&quot;,</a>
<a name="ln402">    },</a>
<a name="ln403"> </a>
<a name="ln404">    {</a>
<a name="ln405">        &quot;The law of Zin demands thee...&quot;,</a>
<a name="ln406">        &quot;...be @virtuous@, and that the punishment for @sin_noun@...&quot;,</a>
<a name="ln407">        &quot;...shall be swift and harsh!&quot;,</a>
<a name="ln408">    },</a>
<a name="ln409"> </a>
<a name="ln410">    {</a>
<a name="ln411">        &quot;It was then that Zin bade them...&quot;,</a>
<a name="ln412">        &quot;...not to stray from @virtue@, lest...&quot;,</a>
<a name="ln413">        &quot;...they become as damned as the @sinners@.&quot;,</a>
<a name="ln414">    },</a>
<a name="ln415"> </a>
<a name="ln416">    {</a>
<a name="ln417">        &quot;Only the @virtuous@ shall be judged worthy, and...&quot;,</a>
<a name="ln418">        &quot;...all the @sinners@ will be found wanting. Such is...&quot;,</a>
<a name="ln419">        &quot;...the word of Zin, and such is the law!&quot;,</a>
<a name="ln420">    },</a>
<a name="ln421"> </a>
<a name="ln422">    {</a>
<a name="ln423">        &quot;To those who would swear an oath of @virtue@ on my altar...&quot;,</a>
<a name="ln424">        &quot;...I bring ye salvation. To the rest, ye @sinners@...&quot;,</a>
<a name="ln425">        &quot;...and the @sin_adj@, the name of Zin shall be thy damnation.&quot;,</a>
<a name="ln426">    },</a>
<a name="ln427"> </a>
<a name="ln428">    {</a>
<a name="ln429">        &quot;And Zin decreed that the people would be...&quot;,</a>
<a name="ln430">        &quot;...protected from @sin_noun@ in all its forms, and...&quot;,</a>
<a name="ln431">        &quot;...preserved in their @virtue@ for all the days to come.&quot;,</a>
<a name="ln432">    },</a>
<a name="ln433"> </a>
<a name="ln434">    {</a>
<a name="ln435">        &quot;For those who would enter Zin's holy bosom...&quot;,</a>
<a name="ln436">        &quot;...and live in @virtue@, Zin provideth. Such is...&quot;,</a>
<a name="ln437">        &quot;...the covenant, and such is the way of things.&quot;,</a>
<a name="ln438">    },</a>
<a name="ln439"> </a>
<a name="ln440">    {</a>
<a name="ln441">        &quot;Zin hath not damned the @sinners@, but it is they...&quot;,</a>
<a name="ln442">        &quot;...that have damned themselves for their @sin_noun@, for...&quot;,</a>
<a name="ln443">        &quot;...did Zin not decree that to be @sin_adj@ was wrong?&quot;,</a>
<a name="ln444">    },</a>
<a name="ln445"> </a>
<a name="ln446">    {</a>
<a name="ln447">        &quot;And Zin, furious at their @sin_noun@, held...&quot;,</a>
<a name="ln448">        &quot;...aloft a silver sceptre! The @sinners@...&quot;,</a>
<a name="ln449">        &quot;...were @smitten@, and thus the way of things was maintained.&quot;,</a>
<a name="ln450">    },</a>
<a name="ln451"> </a>
<a name="ln452">    {</a>
<a name="ln453">        &quot;When the law of the land faltered, Zin rose...&quot;,</a>
<a name="ln454">        &quot;...from the silver throne, and the @sinners@ were...&quot;,</a>
<a name="ln455">        &quot;...@smitten@. And it was thus that the law was made good.&quot;,</a>
<a name="ln456">    },</a>
<a name="ln457"> </a>
<a name="ln458">    {</a>
<a name="ln459">        &quot;Zin descended from on high in a silver chariot...&quot;,</a>
<a name="ln460">        &quot;...to @smite@ the @sinners@ for their...&quot;,</a>
<a name="ln461">        &quot;...@sin_noun@, and thus judgement was rendered.&quot;,</a>
<a name="ln462">    },</a>
<a name="ln463"> </a>
<a name="ln464">    {</a>
<a name="ln465">        &quot;The @sinners@ stood before Zin, and in that instant...&quot;,</a>
<a name="ln466">        &quot;...they knew they would be found guilty of @sin_noun@...&quot;,</a>
<a name="ln467">        &quot;...for that is the word of Zin, and Zin's word is law.&quot;,</a>
<a name="ln468">    },</a>
<a name="ln469">};</a>
<a name="ln470"> </a>
<a name="ln471">static const char * const sinner_text[] =</a>
<a name="ln472">{</a>
<a name="ln473">    &quot;hordes of the Abyss&quot;,</a>
<a name="ln474">    &quot;bastard children of Xom&quot;,</a>
<a name="ln475">    &quot;amorphous wretches&quot;,</a>
<a name="ln476">    &quot;fetid masses&quot;,</a>
<a name="ln477">    &quot;agents of filth&quot;,</a>
<a name="ln478">    &quot;squalid dregs&quot;,</a>
<a name="ln479">    &quot;unbelievers&quot;,</a>
<a name="ln480">    &quot;heretics&quot;,</a>
<a name="ln481">    &quot;guilty&quot;,</a>
<a name="ln482">    &quot;legions of the damned&quot;,</a>
<a name="ln483">    &quot;servants of Hell&quot;,</a>
<a name="ln484">    &quot;forces of darkness&quot;,</a>
<a name="ln485">};</a>
<a name="ln486"> </a>
<a name="ln487">// First column is adjective, then noun.</a>
<a name="ln488">static const char * const sin_text[][2] =</a>
<a name="ln489">{</a>
<a name="ln490">    { &quot;chaotic&quot;,      &quot;chaos&quot; },</a>
<a name="ln491">    { &quot;discordant&quot;,   &quot;discord&quot; },</a>
<a name="ln492">    { &quot;anarchic&quot;,     &quot;anarchy&quot; },</a>
<a name="ln493">    { &quot;unclean&quot;,      &quot;uncleanliness&quot; },</a>
<a name="ln494">    { &quot;impure&quot;,       &quot;impurity&quot; },</a>
<a name="ln495">    { &quot;contaminated&quot;, &quot;contamination&quot; },</a>
<a name="ln496">    { &quot;unfaithful&quot;,   &quot;unfaithfulness&quot; },</a>
<a name="ln497">    { &quot;disloyal&quot;,     &quot;disloyalty&quot; },</a>
<a name="ln498">    { &quot;doubting&quot;,     &quot;doubt&quot; },</a>
<a name="ln499">    { &quot;profane&quot;,      &quot;profanity&quot; },</a>
<a name="ln500">    { &quot;blasphemous&quot;,  &quot;blasphemy&quot; },</a>
<a name="ln501">    { &quot;sacrilegious&quot;, &quot;sacrilege&quot; },</a>
<a name="ln502">};</a>
<a name="ln503"> </a>
<a name="ln504">// First column is adjective, then noun.</a>
<a name="ln505">static const char * const virtue_text[][2] =</a>
<a name="ln506">{</a>
<a name="ln507">    { &quot;ordered&quot;,   &quot;order&quot; },</a>
<a name="ln508">    { &quot;harmonic&quot;,  &quot;harmony&quot; },</a>
<a name="ln509">    { &quot;lawful&quot;,    &quot;lawfulness&quot; },</a>
<a name="ln510">    { &quot;clean&quot;,     &quot;cleanliness&quot; },</a>
<a name="ln511">    { &quot;pure&quot;,      &quot;purity&quot; },</a>
<a name="ln512">    { &quot;hygienic&quot;,  &quot;hygiene&quot; },</a>
<a name="ln513">    { &quot;faithful&quot;,  &quot;faithfulness&quot; },</a>
<a name="ln514">    { &quot;loyal&quot;,     &quot;loyalty&quot; },</a>
<a name="ln515">    { &quot;believing&quot;, &quot;belief&quot; },</a>
<a name="ln516">    { &quot;reverent&quot;,  &quot;reverence&quot; },</a>
<a name="ln517">    { &quot;pious&quot;,     &quot;piety&quot; },</a>
<a name="ln518">    { &quot;obedient&quot;,  &quot;obedience&quot; },</a>
<a name="ln519">};</a>
<a name="ln520"> </a>
<a name="ln521">// First column is infinitive, then gerund.</a>
<a name="ln522">static const char * const smite_text[][2] =</a>
<a name="ln523">{</a>
<a name="ln524">    { &quot;purify&quot;,      &quot;purified&quot; },</a>
<a name="ln525">    { &quot;censure&quot;,     &quot;censured&quot; },</a>
<a name="ln526">    { &quot;condemn&quot;,     &quot;condemned&quot; },</a>
<a name="ln527">    { &quot;strike down&quot;, &quot;struck down&quot; },</a>
<a name="ln528">    { &quot;expel&quot;,       &quot;expelled&quot; },</a>
<a name="ln529">    { &quot;oust&quot;,        &quot;ousted&quot; },</a>
<a name="ln530">    { &quot;smite&quot;,       &quot;smitten&quot; },</a>
<a name="ln531">    { &quot;castigate&quot;,   &quot;castigated&quot; },</a>
<a name="ln532">    { &quot;rebuke&quot;,      &quot;rebuked&quot; },</a>
<a name="ln533">};</a>
<a name="ln534"> </a>
<a name="ln535">/** Get the verse to recite this turn.</a>
<a name="ln536"> *</a>
<a name="ln537"> *  @param seed       The seed to keep the book coherent between turns.</a>
<a name="ln538"> *  @param prayertype One of the four recite types.</a>
<a name="ln539"> *  @param step       -1: We're either starting or stopping, so we just want the passage name.</a>
<a name="ln540"> *                    2/1/0: That many rounds are left. So, if step = 2, we want to show the passage #1/3.</a>
<a name="ln541"> *  @returns the verse to be said this turn, or if step == -1, which verse it is.</a>
<a name="ln542"> */</a>
<a name="ln543">string zin_recite_text(const int seed, const int prayertype, int step)</a>
<a name="ln544">{</a>
<a name="ln545">    // To have deterministic passages we extract portions of the seed.</a>
<a name="ln546">    // We use trits: &quot;digits&quot; in the base-3 expansion of seed.</a>
<a name="ln547"> </a>
<a name="ln548">    COMPILE_CHECK(ARRAYSZ(book_of_zin) == 27);</a>
<a name="ln549">    const int chapter = seed % 27;</a>
<a name="ln550">    const int verse = (seed/27) % 81;</a>
<a name="ln551"> </a>
<a name="ln552">    // Change step to turn 1, turn 2, or turn 3.</a>
<a name="ln553">    if (step &gt; -1)</a>
<a name="ln554">    {</a>
<a name="ln555">        step = abs(step-3);</a>
<a name="ln556">        if (step &gt; 3)</a>
<a name="ln557">            step = 1;</a>
<a name="ln558">    }</a>
<a name="ln559">    else</a>
<a name="ln560">    {</a>
<a name="ln561">        const string bookname = (prayertype == RECITE_CHAOTIC)  ?  &quot;Abominations&quot; :</a>
<a name="ln562">                                (prayertype == RECITE_IMPURE)   ?  &quot;Ablutions&quot;    :</a>
<a name="ln563">                                (prayertype == RECITE_HERETIC)  ?  &quot;Apostates&quot;    :</a>
<a name="ln564">                                (prayertype == RECITE_UNHOLY)   ?  &quot;Anathema&quot;     :</a>
<a name="ln565">                                                                   &quot;Bugginess&quot;;</a>
<a name="ln566">        ostringstream out;</a>
<a name="ln567">        out &lt;&lt; bookname &lt;&lt; ' ' &lt;&lt; (chapter + 1) &lt;&lt; ':' &lt;&lt; (verse + 1);</a>
<a name="ln568">        return out.str();</a>
<a name="ln569">    }</a>
<a name="ln570"> </a>
<a name="ln571">    // These mad-libs are deterministically derived from the verse number</a>
<a name="ln572">    // and prayer type. Sins and virtues are paired, so use the same sub-</a>
<a name="ln573">    // seed. Sinners, sins, and smites are uncorrelated so do not share</a>
<a name="ln574">    // trits.</a>
<a name="ln575">    COMPILE_CHECK(ARRAYSZ(sinner_text) == 12);</a>
<a name="ln576">    COMPILE_CHECK(ARRAYSZ(sin_text) == 12);</a>
<a name="ln577">    COMPILE_CHECK(ARRAYSZ(virtue_text) == 12);</a>
<a name="ln578">    const int sinner_seed = verse % 3 + prayertype * 3;</a>
<a name="ln579">    const int sin_seed = (verse/27) % 3 + prayertype * 3;</a>
<a name="ln580">    const int virtue_seed = sin_seed;</a>
<a name="ln581"> </a>
<a name="ln582">    COMPILE_CHECK(ARRAYSZ(smite_text) == 9);</a>
<a name="ln583">    const int smite_seed = (verse/3) % 9;</a>
<a name="ln584"> </a>
<a name="ln585">    string recite = book_of_zin[chapter][step-1];</a>
<a name="ln586"> </a>
<a name="ln587">    const map&lt;string, string&gt; replacements =</a>
<a name="ln588">    {</a>
<a name="ln589">        { &quot;sinners&quot;, sinner_text[sinner_seed] },</a>
<a name="ln590"> </a>
<a name="ln591">        { &quot;sin_adj&quot;,  sin_text[sin_seed][0] },</a>
<a name="ln592">        { &quot;sin_noun&quot;, sin_text[sin_seed][1] },</a>
<a name="ln593"> </a>
<a name="ln594">        { &quot;virtuous&quot;, virtue_text[virtue_seed][0] },</a>
<a name="ln595">        { &quot;virtue&quot;,   virtue_text[virtue_seed][1] },</a>
<a name="ln596"> </a>
<a name="ln597">        { &quot;smite&quot;,   smite_text[smite_seed][0] },</a>
<a name="ln598">        { &quot;smitten&quot;, smite_text[smite_seed][1] },</a>
<a name="ln599">        { &quot;Smitten&quot;, uppercase_first(smite_text[smite_seed][1]) },</a>
<a name="ln600">    };</a>
<a name="ln601"> </a>
<a name="ln602">    return replace_keys(recite, replacements);</a>
<a name="ln603">}</a>
<a name="ln604"> </a>
<a name="ln605">/** How vulnerable to RECITE_HERETIC is this monster?</a>
<a name="ln606"> *</a>
<a name="ln607"> * @param[in] mon The monster to check.</a>
<a name="ln608"> * @returns the susceptibility.</a>
<a name="ln609"> */</a>
<a name="ln610">static int _heretic_recite_weakness(const monster *mon)</a>
<a name="ln611">{</a>
<a name="ln612">    int degree = 0;</a>
<a name="ln613"> </a>
<a name="ln614">    // Sleeping or paralyzed monsters will wake up or still perceive their</a>
<a name="ln615">    // surroundings, respectively. So, you can still recite to them.</a>
<a name="ln616">    if (mons_intel(*mon) &gt;= I_HUMAN</a>
<a name="ln617">        &amp;&amp; !(mon-&gt;has_ench(ENCH_DUMB) || mons_is_confused(*mon)))</a>
<a name="ln618">    {</a>
<a name="ln619">        // In the eyes of Zin, everyone is a sinner until proven otherwise!</a>
<a name="ln620">        degree++;</a>
<a name="ln621"> </a>
<a name="ln622">        // Any priest is a heretic...</a>
<a name="ln623">        if (mon-&gt;is_priest())</a>
<a name="ln624">            degree++;</a>
<a name="ln625"> </a>
<a name="ln626">        // Or those who believe in themselves...</a>
<a name="ln627">        if (mon-&gt;type == MONS_DEMIGOD)</a>
<a name="ln628">            degree++;</a>
<a name="ln629"> </a>
<a name="ln630">        // ...but evil gods are worse.</a>
<a name="ln631">        if (is_evil_god(mon-&gt;god) || is_unknown_god(mon-&gt;god))</a>
<a name="ln632">            degree++;</a>
<a name="ln633"> </a>
<a name="ln634">        // (The above mean that worshipers will be treated as</a>
<a name="ln635">        // priests for reciting, even if they aren't actually.)</a>
<a name="ln636"> </a>
<a name="ln637"> </a>
<a name="ln638">        // Sanity check: monsters that won't attack you, and aren't</a>
<a name="ln639">        // priests/evil, don't get recited against.</a>
<a name="ln640">        if (mon-&gt;wont_attack() &amp;&amp; degree &lt;= 1)</a>
<a name="ln641">            degree = 0;</a>
<a name="ln642"> </a>
<a name="ln643">        // Sanity check: monsters that are holy, know holy spells, or worship</a>
<a name="ln644">        // holy gods aren't heretics.</a>
<a name="ln645">        if (mon-&gt;is_holy() || is_good_god(mon-&gt;god))</a>
<a name="ln646">            degree = 0;</a>
<a name="ln647">    }</a>
<a name="ln648"> </a>
<a name="ln649">    return degree;</a>
<a name="ln650">}</a>
<a name="ln651"> </a>
<a name="ln652">/** Check whether this monster might be influenced by Recite.</a>
<a name="ln653"> *</a>
<a name="ln654"> * @param[in] mon The monster to check.</a>
<a name="ln655"> * @param[out] eligibility A vector, indexed by recite_type, that indicates</a>
<a name="ln656"> *             which recitation types the monster is affected by, if any:</a>
<a name="ln657"> *             eligibility[RECITE_FOO] is nonzero if the monster is affected</a>
<a name="ln658"> *             by RECITE_FOO.</a>
<a name="ln659"> * @param quiet[in]     Whether to suppress messaging.</a>
<a name="ln660"> * @returns Whether the monster is eligible for recite. If the monster can be</a>
<a name="ln661"> *          recited to, the eligibility vector indicates the valid types of</a>
<a name="ln662"> *          recite.</a>
<a name="ln663"> */</a>
<a name="ln664">recite_eligibility zin_check_recite_to_single_monster(const monster *mon,</a>
<a name="ln665">                                                  recite_counts &amp;eligibility,</a>
<a name="ln666">                                                  bool quiet)</a>
<a name="ln667">{</a>
<a name="ln668">    ASSERT(mon);</a>
<a name="ln669"> </a>
<a name="ln670">    // Can't recite anyway if they were recently recited to.</a>
<a name="ln671">    if (mon-&gt;has_ench(ENCH_RECITE_TIMER))</a>
<a name="ln672">        return RE_RECITE_TIMER;</a>
<a name="ln673"> </a>
<a name="ln674">    const mon_holy_type holiness = mon-&gt;holiness();</a>
<a name="ln675">    eligibility.init(0);</a>
<a name="ln676"> </a>
<a name="ln677">    // Anti-chaos prayer: Hits things vulnerable to silver, or with chaotic spells/gods.</a>
<a name="ln678">    eligibility[RECITE_CHAOTIC] = mon-&gt;how_chaotic(true);</a>
<a name="ln679"> </a>
<a name="ln680">    // Anti-impure prayer: Hits things that Zin hates in general.</a>
<a name="ln681">    // Don't look at the monster's god; that's what RECITE_HERETIC is for.</a>
<a name="ln682">    eligibility[RECITE_IMPURE] = mon-&gt;how_unclean(false);</a>
<a name="ln683"> </a>
<a name="ln684">    // Anti-unholy prayer: Hits demons and incorporeal undead.</a>
<a name="ln685">    if (holiness &amp; MH_UNDEAD &amp;&amp; mon-&gt;is_insubstantial()</a>
<a name="ln686">        || holiness &amp; MH_DEMONIC)</a>
<a name="ln687">    {</a>
<a name="ln688">        eligibility[RECITE_UNHOLY]++;</a>
<a name="ln689">    }</a>
<a name="ln690"> </a>
<a name="ln691">    // Anti-heretic prayer: Hits intelligent monsters, especially priests.</a>
<a name="ln692">    eligibility[RECITE_HERETIC] = _heretic_recite_weakness(mon);</a>
<a name="ln693"> </a>
<a name="ln694">#ifdef DEBUG_DIAGNOSTICS</a>
<a name="ln695">    if (!quiet)</a>
<a name="ln696">    {</a>
<a name="ln697">        string elig;</a>
<a name="ln698">        for (int i = 0; i &lt; NUM_RECITE_TYPES; i++)</a>
<a name="ln699">            elig += '0' + eligibility[i];</a>
<a name="ln700">        dprf(&quot;Eligibility: %s&quot;, elig.c_str());</a>
<a name="ln701">    }</a>
<a name="ln702">#else</a>
<a name="ln703">    UNUSED(quiet);</a>
<a name="ln704">#endif</a>
<a name="ln705"> </a>
<a name="ln706">    bool maybe_eligible = false;</a>
<a name="ln707">    // Checking to see whether they were eligible for anything at all.</a>
<a name="ln708">    for (int i = 0; i &lt; NUM_RECITE_TYPES; i++)</a>
<a name="ln709">        if (eligibility[i] &gt; 0)</a>
<a name="ln710">            maybe_eligible = true;</a>
<a name="ln711"> </a>
<a name="ln712">    if (maybe_eligible)</a>
<a name="ln713">    {</a>
<a name="ln714">        // Too high HD to be affected at current power.</a>
<a name="ln715">        if (mon-&gt;get_hit_dice() &gt;= zin_recite_power())</a>
<a name="ln716">            return RE_TOO_STRONG;</a>
<a name="ln717">        return RE_ELIGIBLE;</a>
<a name="ln718">    }</a>
<a name="ln719"> </a>
<a name="ln720">    return RE_INELIGIBLE;</a>
<a name="ln721">}</a>
<a name="ln722"> </a>
<a name="ln723">int zin_recite_power()</a>
<a name="ln724">{</a>
<a name="ln725">    // Resistance is now based on HD.</a>
<a name="ln726">    // Anything at or above (30+30)/2 = 30 'power' (HD) is completely immune.</a>
<a name="ln727">    const int power_mult = 10;</a>
<a name="ln728">    const int invo_power = you.skill_rdiv(SK_INVOCATIONS, power_mult)</a>
<a name="ln729">                           + 3 * power_mult;</a>
<a name="ln730">    const int piety_power = you.piety * 3 / 2;</a>
<a name="ln731">    return (invo_power + piety_power) / 2 / power_mult;</a>
<a name="ln732">}</a>
<a name="ln733"> </a>
<a name="ln734">bool zin_check_able_to_recite(bool quiet)</a>
<a name="ln735">{</a>
<a name="ln736">    if (you.duration[DUR_RECITE])</a>
<a name="ln737">    {</a>
<a name="ln738">        if (!quiet)</a>
<a name="ln739">            mpr(&quot;Finish your current sermon first, please.&quot;);</a>
<a name="ln740">        return false;</a>
<a name="ln741">    }</a>
<a name="ln742"> </a>
<a name="ln743">    if (you.duration[DUR_RECITE_COOLDOWN])</a>
<a name="ln744">    {</a>
<a name="ln745">        if (!quiet)</a>
<a name="ln746">            mpr(&quot;You're not ready to recite again yet.&quot;);</a>
<a name="ln747">        return false;</a>
<a name="ln748">    }</a>
<a name="ln749"> </a>
<a name="ln750">    return true;</a>
<a name="ln751">}</a>
<a name="ln752"> </a>
<a name="ln753">/**</a>
<a name="ln754"> * Check whether there are monsters who might be influenced by Recite.</a>
<a name="ln755"> * If prayertype is null, we're just checking whether we can.</a>
<a name="ln756"> * Otherwise we're actually reciting, and may need to present a menu.</a>
<a name="ln757"> *</a>
<a name="ln758"> * @param quiet     Whether to suppress messages.</a>
<a name="ln759"> * @return  0 if no eligible monsters were found.</a>
<a name="ln760"> * @return  1 if an eligible audience was found.</a>
<a name="ln761"> * @return  -1 if the only monsters found cannot currently be affected (either</a>
<a name="ln762"> *          due to lack of recite power, or already having been affected)</a>
<a name="ln763"> *</a>
<a name="ln764"> */</a>
<a name="ln765">int zin_check_recite_to_monsters(bool quiet)</a>
<a name="ln766">{</a>
<a name="ln767">    bool found_temp_ineligible = false;</a>
<a name="ln768">    bool found_eligible = false;</a>
<a name="ln769"> </a>
<a name="ln770">    for (radius_iterator ri(you.pos(), LOS_DEFAULT); ri; ++ri)</a>
<a name="ln771">    {</a>
<a name="ln772">        const monster *mon = monster_at(*ri);</a>
<a name="ln773">        if (!mon || !you.can_see(*mon))</a>
<a name="ln774">            continue;</a>
<a name="ln775"> </a>
<a name="ln776">        recite_counts retval;</a>
<a name="ln777">        switch (zin_check_recite_to_single_monster(mon, retval, quiet))</a>
<a name="ln778">        {</a>
<a name="ln779">        case RE_TOO_STRONG:</a>
<a name="ln780">        case RE_RECITE_TIMER:</a>
<a name="ln781">            found_temp_ineligible = true;</a>
<a name="ln782">        // Intentional fallthrough</a>
<a name="ln783">        case RE_INELIGIBLE:</a>
<a name="ln784">            continue;</a>
<a name="ln785"> </a>
<a name="ln786">        case RE_ELIGIBLE:</a>
<a name="ln787">            found_eligible = true;</a>
<a name="ln788">        }</a>
<a name="ln789">    }</a>
<a name="ln790"> </a>
<a name="ln791">    if (!found_eligible &amp;&amp; !found_temp_ineligible)</a>
<a name="ln792">    {</a>
<a name="ln793">        if (!quiet)</a>
<a name="ln794">            dprf(&quot;No audience found!&quot;);</a>
<a name="ln795">        return 0;</a>
<a name="ln796">    }</a>
<a name="ln797">    else if (!found_eligible &amp;&amp; found_temp_ineligible)</a>
<a name="ln798">    {</a>
<a name="ln799">        if (!quiet)</a>
<a name="ln800">            dprf(&quot;No sensible audience found!&quot;);</a>
<a name="ln801">        return -1;</a>
<a name="ln802">    }</a>
<a name="ln803">    else</a>
<a name="ln804">        return 1; // We just recite against everything.</a>
<a name="ln805">}</a>
<a name="ln806"> </a>
<a name="ln807">enum class zin_eff</a>
<a name="ln808">{</a>
<a name="ln809">    nothing,</a>
<a name="ln810">    daze,</a>
<a name="ln811">    confuse,</a>
<a name="ln812">    paralyse,</a>
<a name="ln813">    smite,</a>
<a name="ln814">    blind,</a>
<a name="ln815">    silver_corona,</a>
<a name="ln816">    antimagic,</a>
<a name="ln817">    mute,</a>
<a name="ln818">    mad,</a>
<a name="ln819">    dumb,</a>
<a name="ln820">    ignite_chaos,</a>
<a name="ln821">    saltify,</a>
<a name="ln822">    rot,</a>
<a name="ln823">    holy_word,</a>
<a name="ln824">};</a>
<a name="ln825"> </a>
<a name="ln826">bool zin_recite_to_single_monster(const coord_def&amp; where)</a>
<a name="ln827">{</a>
<a name="ln828">    // That's a pretty good sanity check, I guess.</a>
<a name="ln829">    ASSERT(you_worship(GOD_ZIN));</a>
<a name="ln830"> </a>
<a name="ln831">    monster* mon = monster_at(where);</a>
<a name="ln832"> </a>
<a name="ln833">    // Once you're already reciting, invis is ok.</a>
<a name="ln834">    if (!mon || !cell_see_cell(where, you.pos(), LOS_DEFAULT))</a>
<a name="ln835">        return false;</a>
<a name="ln836"> </a>
<a name="ln837">    recite_counts eligibility;</a>
<a name="ln838">    bool affected = false;</a>
<a name="ln839"> </a>
<a name="ln840">    if (zin_check_recite_to_single_monster(mon, eligibility) != RE_ELIGIBLE)</a>
<a name="ln841">        return false;</a>
<a name="ln842"> </a>
<a name="ln843">    recite_type prayertype = RECITE_HERETIC;</a>
<a name="ln844">    for (int i = NUM_RECITE_TYPES - 1; i &gt;= RECITE_HERETIC; i--)</a>
<a name="ln845">    {</a>
<a name="ln846">        if (eligibility[i] &gt; 0)</a>
<a name="ln847">        {</a>
<a name="ln848">            prayertype = static_cast &lt;recite_type&gt;(i);</a>
<a name="ln849">            break;</a>
<a name="ln850">        }</a>
<a name="ln851">    }</a>
<a name="ln852"> </a>
<a name="ln853">    // Second check: because this affects the whole screen over several turns,</a>
<a name="ln854">    // its effects are staggered. There's a 50% chance per monster, per turn,</a>
<a name="ln855">    // that nothing will happen - so the cumulative odds of nothing happening</a>
<a name="ln856">    // are one in eight, since you recite three times.</a>
<a name="ln857">    if (coinflip())</a>
<a name="ln858">        return false;</a>
<a name="ln859"> </a>
<a name="ln860">    const int power = zin_recite_power();</a>
<a name="ln861">    // Old recite was mostly deterministic, which is bad.</a>
<a name="ln862">    const int resist = mon-&gt;get_hit_dice() + random2(6);</a>
<a name="ln863">    const int check = power - resist;</a>
<a name="ln864"> </a>
<a name="ln865">    // We abort if we didn't *beat* their HD - but first we might get a cute message.</a>
<a name="ln866">    if (mon-&gt;can_speak() &amp;&amp; one_chance_in(5))</a>
<a name="ln867">    {</a>
<a name="ln868">        if (check &lt; -10)</a>
<a name="ln869">            simple_monster_message(*mon, &quot; guffaws at your puny god.&quot;);</a>
<a name="ln870">        else if (check &lt; -5)</a>
<a name="ln871">            simple_monster_message(*mon, &quot; sneers at your recitation.&quot;);</a>
<a name="ln872">    }</a>
<a name="ln873"> </a>
<a name="ln874">    if (check &lt;= 0)</a>
<a name="ln875">        return false;</a>
<a name="ln876"> </a>
<a name="ln877">    // To what degree are they eligible for this prayertype?</a>
<a name="ln878">    const int degree = eligibility[prayertype];</a>
<a name="ln879">    const bool minor = degree &lt;= (prayertype == RECITE_HERETIC ? 2 : 1);</a>
<a name="ln880">    const int spellpower = power * 2 + degree * 20;</a>
<a name="ln881">    zin_eff effect = zin_eff::nothing;</a>
<a name="ln882"> </a>
<a name="ln883">    switch (prayertype)</a>
<a name="ln884">    {</a>
<a name="ln885">    case RECITE_HERETIC:</a>
<a name="ln886">        if (degree == 1)</a>
<a name="ln887">        {</a>
<a name="ln888">            if (mon-&gt;asleep())</a>
<a name="ln889">                break;</a>
<a name="ln890">            // This is the path for 'conversion' effects.</a>
<a name="ln891">            // Their degree is only 1 if they weren't a priest,</a>
<a name="ln892">            // a worshiper of an evil or chaotic god, etc.</a>
<a name="ln893"> </a>
<a name="ln894">            // Right now, it only has the 'failed conversion' effects, though.</a>
<a name="ln895">            // This branch can't hit sleeping monsters - until they wake up.</a>
<a name="ln896"> </a>
<a name="ln897">            if (check &lt; 5)</a>
<a name="ln898">                effect = zin_eff::daze;</a>
<a name="ln899">            else if (check &lt; 10)</a>
<a name="ln900">            {</a>
<a name="ln901">                if (coinflip())</a>
<a name="ln902">                    effect = zin_eff::confuse;</a>
<a name="ln903">                else</a>
<a name="ln904">                    effect = zin_eff::daze;</a>
<a name="ln905">            }</a>
<a name="ln906">            else if (check &lt; 15)</a>
<a name="ln907">                effect = zin_eff::confuse;</a>
<a name="ln908">            else</a>
<a name="ln909">            {</a>
<a name="ln910">                if (one_chance_in(3))</a>
<a name="ln911">                    effect = zin_eff::paralyse;</a>
<a name="ln912">                else</a>
<a name="ln913">                    effect = zin_eff::confuse;</a>
<a name="ln914">            }</a>
<a name="ln915">        }</a>
<a name="ln916">        else</a>
<a name="ln917">        {</a>
<a name="ln918">            // This is the path for 'smiting' effects.</a>
<a name="ln919">            // Their degree is only greater than 1 if</a>
<a name="ln920">            // they're unable to be redeemed.</a>
<a name="ln921">            if (check &lt; 5)</a>
<a name="ln922">            {</a>
<a name="ln923">                if (coinflip())</a>
<a name="ln924">                    effect = zin_eff::confuse;</a>
<a name="ln925">                else</a>
<a name="ln926">                    effect = zin_eff::smite;</a>
<a name="ln927">            }</a>
<a name="ln928">            else if (check &lt; 10)</a>
<a name="ln929">            {</a>
<a name="ln930">                if (one_chance_in(3))</a>
<a name="ln931">                    effect = zin_eff::blind;</a>
<a name="ln932">                else if (mon-&gt;antimagic_susceptible())</a>
<a name="ln933">                    effect = zin_eff::antimagic;</a>
<a name="ln934">                else</a>
<a name="ln935">                    effect = zin_eff::silver_corona;</a>
<a name="ln936">            }</a>
<a name="ln937">            else if (check &lt; 15)</a>
<a name="ln938">            {</a>
<a name="ln939">                if (one_chance_in(3))</a>
<a name="ln940">                    effect = zin_eff::blind;</a>
<a name="ln941">                else if (coinflip())</a>
<a name="ln942">                    effect = zin_eff::paralyse;</a>
<a name="ln943">                else</a>
<a name="ln944">                    effect = zin_eff::mute;</a>
<a name="ln945">            }</a>
<a name="ln946">            else</a>
<a name="ln947">            {</a>
<a name="ln948">                if (coinflip())</a>
<a name="ln949">                    effect = zin_eff::mad;</a>
<a name="ln950">                else</a>
<a name="ln951">                    effect = zin_eff::dumb;</a>
<a name="ln952">            }</a>
<a name="ln953">        }</a>
<a name="ln954">        break;</a>
<a name="ln955"> </a>
<a name="ln956">    case RECITE_CHAOTIC:</a>
<a name="ln957">        if (check &lt; 5)</a>
<a name="ln958">        {</a>
<a name="ln959">            // nastier -- fallthrough if immune</a>
<a name="ln960">            if (coinflip() &amp;&amp; mon-&gt;res_rotting() &lt; ROT_RESIST_FULL)</a>
<a name="ln961">                effect = zin_eff::rot;</a>
<a name="ln962">            else</a>
<a name="ln963">                effect = zin_eff::smite;</a>
<a name="ln964">        }</a>
<a name="ln965">        else if (check &lt; 10)</a>
<a name="ln966">        {</a>
<a name="ln967">            if (coinflip())</a>
<a name="ln968">                effect = zin_eff::silver_corona;</a>
<a name="ln969">            else</a>
<a name="ln970">                effect = zin_eff::smite;</a>
<a name="ln971">        }</a>
<a name="ln972">        else if (check &lt; 15)</a>
<a name="ln973">        {</a>
<a name="ln974">            if (coinflip())</a>
<a name="ln975">                effect = zin_eff::ignite_chaos;</a>
<a name="ln976">            else</a>
<a name="ln977">                effect = zin_eff::silver_corona;</a>
<a name="ln978">        }</a>
<a name="ln979">        else</a>
<a name="ln980">            effect = zin_eff::saltify;</a>
<a name="ln981">        break;</a>
<a name="ln982"> </a>
<a name="ln983">    case RECITE_IMPURE:</a>
<a name="ln984">        // Many creatures normally resistant to rotting are still affected,</a>
<a name="ln985">        // because this is divine punishment. Those with no real flesh are</a>
<a name="ln986">        // immune, of course.</a>
<a name="ln987">        if (check &lt; 5)</a>
<a name="ln988">        {</a>
<a name="ln989">            if (coinflip() &amp;&amp; mon-&gt;res_rotting() &lt; ROT_RESIST_FULL)</a>
<a name="ln990">                effect = zin_eff::rot;</a>
<a name="ln991">            else</a>
<a name="ln992">                effect = zin_eff::smite;</a>
<a name="ln993">        }</a>
<a name="ln994">        else if (check &lt; 10)</a>
<a name="ln995">        {</a>
<a name="ln996">            if (coinflip())</a>
<a name="ln997">                effect = zin_eff::smite;</a>
<a name="ln998">            else</a>
<a name="ln999">                effect = zin_eff::silver_corona;</a>
<a name="ln1000">        }</a>
<a name="ln1001">        else if (check &lt; 15)</a>
<a name="ln1002">        {</a>
<a name="ln1003">            if (mon-&gt;undead_or_demonic() &amp;&amp; coinflip())</a>
<a name="ln1004">                effect = zin_eff::holy_word;</a>
<a name="ln1005">            else</a>
<a name="ln1006">                effect = zin_eff::silver_corona;</a>
<a name="ln1007">        }</a>
<a name="ln1008">        else</a>
<a name="ln1009">            effect = zin_eff::saltify;</a>
<a name="ln1010">        break;</a>
<a name="ln1011"> </a>
<a name="ln1012">    case RECITE_UNHOLY:</a>
<a name="ln1013">        if (check &lt; 5)</a>
<a name="ln1014">        {</a>
<a name="ln1015">            if (coinflip())</a>
<a name="ln1016">                effect = zin_eff::daze;</a>
<a name="ln1017">            else</a>
<a name="ln1018">                effect = zin_eff::confuse;</a>
<a name="ln1019">        }</a>
<a name="ln1020">        else if (check &lt; 10)</a>
<a name="ln1021">        {</a>
<a name="ln1022">            if (coinflip())</a>
<a name="ln1023">                effect = zin_eff::confuse;</a>
<a name="ln1024">            else</a>
<a name="ln1025">                effect = zin_eff::silver_corona;</a>
<a name="ln1026">        }</a>
<a name="ln1027">        // Half of the time, the anti-unholy prayer will be capped at this</a>
<a name="ln1028">        // level of effect.</a>
<a name="ln1029">        else if (check &lt; 15 || coinflip())</a>
<a name="ln1030">        {</a>
<a name="ln1031">            if (coinflip())</a>
<a name="ln1032">                effect = zin_eff::holy_word;</a>
<a name="ln1033">            else</a>
<a name="ln1034">                effect = zin_eff::silver_corona;</a>
<a name="ln1035">        }</a>
<a name="ln1036">        else</a>
<a name="ln1037">            effect = zin_eff::saltify;</a>
<a name="ln1038">        break;</a>
<a name="ln1039"> </a>
<a name="ln1040">    case NUM_RECITE_TYPES:</a>
<a name="ln1041">        die(&quot;invalid recite type&quot;);</a>
<a name="ln1042">    }</a>
<a name="ln1043"> </a>
<a name="ln1044">    // And the actual effects...</a>
<a name="ln1045">    switch (effect)</a>
<a name="ln1046">    {</a>
<a name="ln1047">    case zin_eff::nothing:</a>
<a name="ln1048">        break;</a>
<a name="ln1049"> </a>
<a name="ln1050">    case zin_eff::daze:</a>
<a name="ln1051">        if (mon-&gt;add_ench(mon_enchant(ENCH_DAZED, degree, &amp;you,</a>
<a name="ln1052">                          (degree + random2(spellpower)) * BASELINE_DELAY)))</a>
<a name="ln1053">        {</a>
<a name="ln1054">            simple_monster_message(*mon, &quot; is dazed by your recitation.&quot;);</a>
<a name="ln1055">            affected = true;</a>
<a name="ln1056">        }</a>
<a name="ln1057">        break;</a>
<a name="ln1058"> </a>
<a name="ln1059">    case zin_eff::confuse:</a>
<a name="ln1060">        if (!mon-&gt;check_clarity()</a>
<a name="ln1061">            &amp;&amp; mon-&gt;add_ench(mon_enchant(ENCH_CONFUSION, degree, &amp;you,</a>
<a name="ln1062">                             (degree + random2(spellpower)) * BASELINE_DELAY)))</a>
<a name="ln1063">        {</a>
<a name="ln1064">            if (prayertype == RECITE_HERETIC)</a>
<a name="ln1065">                simple_monster_message(*mon, &quot; is confused by your recitation.&quot;);</a>
<a name="ln1066">            else</a>
<a name="ln1067">                simple_monster_message(*mon, &quot; stumbles about in disarray.&quot;);</a>
<a name="ln1068">            affected = true;</a>
<a name="ln1069">        }</a>
<a name="ln1070">        break;</a>
<a name="ln1071"> </a>
<a name="ln1072">    case zin_eff::paralyse:</a>
<a name="ln1073">        if (mon-&gt;add_ench(mon_enchant(ENCH_PARALYSIS, 0, &amp;you,</a>
<a name="ln1074">                          (degree + random2(spellpower)) * BASELINE_DELAY)))</a>
<a name="ln1075">        {</a>
<a name="ln1076">            simple_monster_message(*mon,</a>
<a name="ln1077">                minor ? &quot; is awed by your recitation.&quot;</a>
<a name="ln1078">                      : &quot; is aghast at the heresy of your recitation.&quot;);</a>
<a name="ln1079">            affected = true;</a>
<a name="ln1080">        }</a>
<a name="ln1081">        break;</a>
<a name="ln1082"> </a>
<a name="ln1083">    case zin_eff::smite:</a>
<a name="ln1084">        if (minor)</a>
<a name="ln1085">            simple_monster_message(*mon, &quot; is smitten by the wrath of Zin.&quot;);</a>
<a name="ln1086">        else</a>
<a name="ln1087">            simple_monster_message(*mon, &quot; is blasted by the fury of Zin!&quot;);</a>
<a name="ln1088">        // XXX: This duplicates code in cast_smiting().</a>
<a name="ln1089">        mon-&gt;hurt(&amp;you, 7 + (random2(spellpower) * 33 / 191));</a>
<a name="ln1090">        if (mon-&gt;alive())</a>
<a name="ln1091">            print_wounds(*mon);</a>
<a name="ln1092">        affected = true;</a>
<a name="ln1093">        break;</a>
<a name="ln1094"> </a>
<a name="ln1095">    case zin_eff::blind:</a>
<a name="ln1096">        if (mon-&gt;add_ench(mon_enchant(ENCH_BLIND, degree, &amp;you, INFINITE_DURATION)))</a>
<a name="ln1097">        {</a>
<a name="ln1098">            simple_monster_message(*mon, &quot; is struck blind by the wrath of Zin!&quot;);</a>
<a name="ln1099">            affected = true;</a>
<a name="ln1100">        }</a>
<a name="ln1101">        break;</a>
<a name="ln1102"> </a>
<a name="ln1103">    case zin_eff::silver_corona:</a>
<a name="ln1104">        if (mon-&gt;add_ench(mon_enchant(ENCH_SILVER_CORONA, degree, &amp;you,</a>
<a name="ln1105">                          (degree + random2(spellpower)) * BASELINE_DELAY)))</a>
<a name="ln1106">        {</a>
<a name="ln1107">            simple_monster_message(*mon, &quot; is limned with silver light.&quot;);</a>
<a name="ln1108">            affected = true;</a>
<a name="ln1109">        }</a>
<a name="ln1110">        break;</a>
<a name="ln1111"> </a>
<a name="ln1112">    case zin_eff::antimagic:</a>
<a name="ln1113">        ASSERT(prayertype == RECITE_HERETIC);</a>
<a name="ln1114">        if (mon-&gt;add_ench(mon_enchant(ENCH_ANTIMAGIC, degree, &amp;you,</a>
<a name="ln1115">                          (degree + random2(spellpower)) * BASELINE_DELAY)))</a>
<a name="ln1116">        {</a>
<a name="ln1117">            simple_monster_message(*mon,</a>
<a name="ln1118">                minor ? &quot; quails at your recitation.&quot;</a>
<a name="ln1119">                      : &quot; looks feeble and powerless before your recitation.&quot;);</a>
<a name="ln1120">            affected = true;</a>
<a name="ln1121">        }</a>
<a name="ln1122">        break;</a>
<a name="ln1123"> </a>
<a name="ln1124">    case zin_eff::mute:</a>
<a name="ln1125">        if (mon-&gt;add_ench(mon_enchant(ENCH_MUTE, degree, &amp;you, INFINITE_DURATION)))</a>
<a name="ln1126">        {</a>
<a name="ln1127">            simple_monster_message(*mon, &quot; is struck mute by the wrath of Zin!&quot;);</a>
<a name="ln1128">            affected = true;</a>
<a name="ln1129">        }</a>
<a name="ln1130">        break;</a>
<a name="ln1131"> </a>
<a name="ln1132">    case zin_eff::mad:</a>
<a name="ln1133">        if (mon-&gt;add_ench(mon_enchant(ENCH_MAD, degree, &amp;you, INFINITE_DURATION)))</a>
<a name="ln1134">        {</a>
<a name="ln1135">            simple_monster_message(*mon, &quot; is driven mad by the wrath of Zin!&quot;);</a>
<a name="ln1136">            affected = true;</a>
<a name="ln1137">        }</a>
<a name="ln1138">        break;</a>
<a name="ln1139"> </a>
<a name="ln1140">    case zin_eff::dumb:</a>
<a name="ln1141">        if (mon-&gt;add_ench(mon_enchant(ENCH_DUMB, degree, &amp;you, INFINITE_DURATION)))</a>
<a name="ln1142">        {</a>
<a name="ln1143">            simple_monster_message(*mon, &quot; is left stupefied by the wrath of Zin!&quot;);</a>
<a name="ln1144">            affected = true;</a>
<a name="ln1145">        }</a>
<a name="ln1146">        break;</a>
<a name="ln1147"> </a>
<a name="ln1148">    case zin_eff::ignite_chaos:</a>
<a name="ln1149">        ASSERT(prayertype == RECITE_CHAOTIC);</a>
<a name="ln1150">        {</a>
<a name="ln1151">            bolt beam;</a>
<a name="ln1152">            dice_def dam_dice(0, 5 + spellpower/7);  // Dice added below if applicable.</a>
<a name="ln1153">            dam_dice.num = degree;</a>
<a name="ln1154"> </a>
<a name="ln1155">            int damage = dam_dice.roll();</a>
<a name="ln1156">            if (damage &gt; 0)</a>
<a name="ln1157">            {</a>
<a name="ln1158">                mon-&gt;hurt(&amp;you, damage, BEAM_MISSILE, KILLED_BY_BEAM,</a>
<a name="ln1159">                          &quot;&quot;, &quot;&quot;, false);</a>
<a name="ln1160"> </a>
<a name="ln1161">                if (mon-&gt;alive())</a>
<a name="ln1162">                {</a>
<a name="ln1163">                    simple_monster_message(*mon,</a>
<a name="ln1164">                      (damage &lt; 25) ? &quot;'s chaotic flesh sizzles and spatters!&quot; :</a>
<a name="ln1165">                      (damage &lt; 50) ? &quot;'s chaotic flesh bubbles and boils.&quot;</a>
<a name="ln1166">                                    : &quot;'s chaotic flesh runs like molten wax.&quot;);</a>
<a name="ln1167"> </a>
<a name="ln1168">                    print_wounds(*mon);</a>
<a name="ln1169">                    behaviour_event(mon, ME_WHACK, &amp;you);</a>
<a name="ln1170">                    affected = true;</a>
<a name="ln1171">                }</a>
<a name="ln1172">                else</a>
<a name="ln1173">                {</a>
<a name="ln1174">                    simple_monster_message(*mon,</a>
<a name="ln1175">                        &quot; melts away into a sizzling puddle of chaotic flesh.&quot;);</a>
<a name="ln1176">                    monster_die(*mon, KILL_YOU, NON_MONSTER);</a>
<a name="ln1177">                }</a>
<a name="ln1178">            }</a>
<a name="ln1179">        }</a>
<a name="ln1180">        break;</a>
<a name="ln1181"> </a>
<a name="ln1182">    case zin_eff::saltify:</a>
<a name="ln1183">        _zin_saltify(mon);</a>
<a name="ln1184">        break;</a>
<a name="ln1185"> </a>
<a name="ln1186">    case zin_eff::rot:</a>
<a name="ln1187">        // FIXME: no message (other than &quot;You kill X!&quot;) is produced if the</a>
<a name="ln1188">        // rotting kills the monster.</a>
<a name="ln1189">        if (mon-&gt;res_rotting() &lt;= 1</a>
<a name="ln1190">            &amp;&amp; mon-&gt;rot(&amp;you, 1 + roll_dice(2, degree), true))</a>
<a name="ln1191">        {</a>
<a name="ln1192">            mon-&gt;add_ench(mon_enchant(ENCH_SICK, degree, &amp;you,</a>
<a name="ln1193">                          (degree + random2(spellpower)) * BASELINE_DELAY));</a>
<a name="ln1194">            switch (prayertype)</a>
<a name="ln1195">            {</a>
<a name="ln1196">            case RECITE_CHAOTIC:</a>
<a name="ln1197">                simple_monster_message(*mon,</a>
<a name="ln1198">                    minor ? &quot;'s chaotic flesh is covered in bleeding sores.&quot;</a>
<a name="ln1199">                          : &quot;'s chaotic flesh erupts into weeping sores!&quot;);</a>
<a name="ln1200">                break;</a>
<a name="ln1201">            case RECITE_IMPURE:</a>
<a name="ln1202">                simple_monster_message(*mon,</a>
<a name="ln1203">                    minor ? &quot;'s impure flesh rots away.&quot;</a>
<a name="ln1204">                          : &quot;'s impure flesh sloughs off!&quot;);</a>
<a name="ln1205">                break;</a>
<a name="ln1206"> </a>
<a name="ln1207">            default:</a>
<a name="ln1208">                die(&quot;bad recite rot&quot;);</a>
<a name="ln1209">            }</a>
<a name="ln1210">            affected = true;</a>
<a name="ln1211">        }</a>
<a name="ln1212">        break;</a>
<a name="ln1213"> </a>
<a name="ln1214">    case zin_eff::holy_word:</a>
<a name="ln1215">        holy_word_monsters(where, spellpower, HOLY_WORD_ZIN, &amp;you);</a>
<a name="ln1216">        affected = true;</a>
<a name="ln1217">        break;</a>
<a name="ln1218">    }</a>
<a name="ln1219"> </a>
<a name="ln1220">    // Recite time, to prevent monsters from being recited against</a>
<a name="ln1221">    // more than once in a given recite instance.</a>
<a name="ln1222">    if (affected)</a>
<a name="ln1223">        mon-&gt;add_ench(mon_enchant(ENCH_RECITE_TIMER, degree, &amp;you, 40));</a>
<a name="ln1224"> </a>
<a name="ln1225">    // Monsters that have been affected may shout.</a>
<a name="ln1226">    if (affected</a>
<a name="ln1227">        &amp;&amp; one_chance_in(3)</a>
<a name="ln1228">        &amp;&amp; mon-&gt;alive()</a>
<a name="ln1229">        &amp;&amp; mons_can_shout(mon-&gt;type))</a>
<a name="ln1230">    {</a>
<a name="ln1231">        monster_attempt_shout(*mon);</a>
<a name="ln1232">    }</a>
<a name="ln1233"> </a>
<a name="ln1234">    return true;</a>
<a name="ln1235">}</a>
<a name="ln1236"> </a>
<a name="ln1237">static void _zin_saltify(monster* mon)</a>
<a name="ln1238">{</a>
<a name="ln1239">    const coord_def where = mon-&gt;pos();</a>
<a name="ln1240">    const monster_type pillar_type =</a>
<a name="ln1241">        mons_is_zombified(*mon) ? mons_zombie_base(*mon)</a>
<a name="ln1242">                                : mons_species(mon-&gt;type);</a>
<a name="ln1243">    const int hd = mon-&gt;get_hit_dice();</a>
<a name="ln1244"> </a>
<a name="ln1245">    simple_monster_message(*mon, &quot; is turned into a pillar of salt by the wrath of Zin!&quot;);</a>
<a name="ln1246"> </a>
<a name="ln1247">    // If the monster leaves a corpse when it dies, destroy the corpse.</a>
<a name="ln1248">    item_def* corpse = monster_die(*mon, KILL_YOU, NON_MONSTER);</a>
<a name="ln1249">    if (corpse)</a>
<a name="ln1250">        destroy_item(corpse-&gt;index());</a>
<a name="ln1251"> </a>
<a name="ln1252">    if (monster *pillar = create_monster(</a>
<a name="ln1253">                        mgen_data(MONS_PILLAR_OF_SALT,</a>
<a name="ln1254">                                  BEH_HOSTILE,</a>
<a name="ln1255">                                  where,</a>
<a name="ln1256">                                  MHITNOT,</a>
<a name="ln1257">                                  MG_FORCE_PLACE).set_base(pillar_type),</a>
<a name="ln1258">                                  false))</a>
<a name="ln1259">    {</a>
<a name="ln1260">        // Enemies with more HD leave longer-lasting pillars of salt.</a>
<a name="ln1261">        int time_left = (random2(8) + hd) * BASELINE_DELAY;</a>
<a name="ln1262">        mon_enchant temp_en(ENCH_SLOWLY_DYING, 1, 0, time_left);</a>
<a name="ln1263">        pillar-&gt;update_ench(temp_en);</a>
<a name="ln1264">    }</a>
<a name="ln1265">}</a>
<a name="ln1266"> </a>
<a name="ln1267">bool zin_vitalisation()</a>
<a name="ln1268">{</a>
<a name="ln1269">    simple_god_message(&quot; grants you divine stamina.&quot;);</a>
<a name="ln1270"> </a>
<a name="ln1271">    // Add divine stamina.</a>
<a name="ln1272">    const int stamina_amt =</a>
<a name="ln1273">        max(1, you.skill_rdiv(SK_INVOCATIONS, 1, 3));</a>
<a name="ln1274">    you.attribute[ATTR_DIVINE_STAMINA] = stamina_amt;</a>
<a name="ln1275">    you.set_duration(DUR_DIVINE_STAMINA, 60 + roll_dice(2, 10));</a>
<a name="ln1276"> </a>
<a name="ln1277">    notify_stat_change(STAT_STR, stamina_amt, true);</a>
<a name="ln1278">    notify_stat_change(STAT_INT, stamina_amt, true);</a>
<a name="ln1279">    notify_stat_change(STAT_DEX, stamina_amt, true);</a>
<a name="ln1280"> </a>
<a name="ln1281">    return true;</a>
<a name="ln1282">}</a>
<a name="ln1283"> </a>
<a name="ln1284">void zin_remove_divine_stamina()</a>
<a name="ln1285">{</a>
<a name="ln1286">    mprf(MSGCH_DURATION, &quot;Your divine stamina fades away.&quot;);</a>
<a name="ln1287">    notify_stat_change(STAT_STR, -you.attribute[ATTR_DIVINE_STAMINA], true);</a>
<a name="ln1288">    notify_stat_change(STAT_INT, -you.attribute[ATTR_DIVINE_STAMINA], true);</a>
<a name="ln1289">    notify_stat_change(STAT_DEX, -you.attribute[ATTR_DIVINE_STAMINA], true);</a>
<a name="ln1290">    you.duration[DUR_DIVINE_STAMINA] = 0;</a>
<a name="ln1291">    you.attribute[ATTR_DIVINE_STAMINA] = 0;</a>
<a name="ln1292">}</a>
<a name="ln1293"> </a>
<a name="ln1294">bool zin_remove_all_mutations()</a>
<a name="ln1295">{</a>
<a name="ln1296">    ASSERT(you.how_mutated());</a>
<a name="ln1297">    ASSERT(can_do_capstone_ability(you.religion));</a>
<a name="ln1298"> </a>
<a name="ln1299">    if (!yesno(&quot;Do you wish to cure all of your mutations?&quot;, true, 'n'))</a>
<a name="ln1300">    {</a>
<a name="ln1301">        canned_msg(MSG_OK);</a>
<a name="ln1302">        return false;</a>
<a name="ln1303">    }</a>
<a name="ln1304">    flash_view(UA_PLAYER, WHITE);</a>
<a name="ln1305">#ifndef USE_TILE_LOCAL</a>
<a name="ln1306">    // Allow extra time for the flash to linger.</a>
<a name="ln1307">    scaled_delay(1000);</a>
<a name="ln1308">#endif</a>
<a name="ln1309"> </a>
<a name="ln1310">    you.one_time_ability_used.set(GOD_ZIN);</a>
<a name="ln1311">    take_note(Note(NOTE_GOD_GIFT, you.religion));</a>
<a name="ln1312">    simple_god_message(&quot; draws all chaos from your body!&quot;);</a>
<a name="ln1313">    delete_all_mutations(&quot;Zin's power&quot;);</a>
<a name="ln1314">    return true;</a>
<a name="ln1315">}</a>
<a name="ln1316"> </a>
<a name="ln1317">void zin_sanctuary()</a>
<a name="ln1318">{</a>
<a name="ln1319">    ASSERT(!env.sanctuary_time);</a>
<a name="ln1320"> </a>
<a name="ln1321">    // Yes, shamelessly stolen from NetHack...</a>
<a name="ln1322">    if (!silenced(you.pos())) // How did you manage that?</a>
<a name="ln1323">        mprf(MSGCH_SOUND, &quot;You hear a choir sing!&quot;);</a>
<a name="ln1324">    else</a>
<a name="ln1325">        mpr(&quot;You are suddenly bathed in radiance!&quot;);</a>
<a name="ln1326"> </a>
<a name="ln1327">    flash_view(UA_PLAYER, WHITE);</a>
<a name="ln1328">    holy_word(100, HOLY_WORD_ZIN, you.pos(), true, &amp;you);</a>
<a name="ln1329">#ifndef USE_TILE_LOCAL</a>
<a name="ln1330">    // Allow extra time for the flash to linger.</a>
<a name="ln1331">    scaled_delay(1000);</a>
<a name="ln1332">#endif</a>
<a name="ln1333"> </a>
<a name="ln1334">    // Pets stop attacking and converge on you.</a>
<a name="ln1335">    you.pet_target = MHITYOU;</a>
<a name="ln1336">    create_sanctuary(you.pos(), 7 + you.skill_rdiv(SK_INVOCATIONS) / 2);</a>
<a name="ln1337"> </a>
<a name="ln1338">}</a>
<a name="ln1339"> </a>
<a name="ln1340">// shield bonus = attribute for duration turns, then decreasing by 1</a>
<a name="ln1341">//                every two out of three turns</a>
<a name="ln1342">// overall shield duration = duration + attribute</a>
<a name="ln1343">// recasting simply resets those two values (to better values, presumably)</a>
<a name="ln1344">void tso_divine_shield()</a>
<a name="ln1345">{</a>
<a name="ln1346">    if (!you.duration[DUR_DIVINE_SHIELD])</a>
<a name="ln1347">    {</a>
<a name="ln1348">        if (you.shield())</a>
<a name="ln1349">        {</a>
<a name="ln1350">            mprf(&quot;Your shield is strengthened by %s divine power.&quot;,</a>
<a name="ln1351">                 apostrophise(god_name(GOD_SHINING_ONE)).c_str());</a>
<a name="ln1352">        }</a>
<a name="ln1353">        else</a>
<a name="ln1354">            mpr(&quot;A divine shield forms around you!&quot;);</a>
<a name="ln1355">    }</a>
<a name="ln1356">    else</a>
<a name="ln1357">        mpr(&quot;Your divine shield is renewed.&quot;);</a>
<a name="ln1358"> </a>
<a name="ln1359">    // Duration from 35-80 turns.</a>
<a name="ln1360">    you.set_duration(DUR_DIVINE_SHIELD,</a>
<a name="ln1361">                     35 + you.skill_rdiv(SK_INVOCATIONS, 5, 3));</a>
<a name="ln1362"> </a>
<a name="ln1363">    // Size of SH bonus.</a>
<a name="ln1364">    you.attribute[ATTR_DIVINE_SHIELD] =</a>
<a name="ln1365">        12 + you.skill_rdiv(SK_INVOCATIONS, 4, 5);</a>
<a name="ln1366"> </a>
<a name="ln1367">    you.redraw_armour_class = true;</a>
<a name="ln1368">}</a>
<a name="ln1369"> </a>
<a name="ln1370">void tso_remove_divine_shield()</a>
<a name="ln1371">{</a>
<a name="ln1372">    mprf(MSGCH_DURATION, &quot;Your divine shield fades away.&quot;);</a>
<a name="ln1373">    you.duration[DUR_DIVINE_SHIELD] = 0;</a>
<a name="ln1374">    you.attribute[ATTR_DIVINE_SHIELD] = 0;</a>
<a name="ln1375">    you.redraw_armour_class = true;</a>
<a name="ln1376">}</a>
<a name="ln1377"> </a>
<a name="ln1378">void elyvilon_purification()</a>
<a name="ln1379">{</a>
<a name="ln1380">    mpr(&quot;You feel purified!&quot;);</a>
<a name="ln1381"> </a>
<a name="ln1382">    you.disease = 0;</a>
<a name="ln1383">    you.duration[DUR_POISONING] = 0;</a>
<a name="ln1384">    you.duration[DUR_CONF] = 0;</a>
<a name="ln1385">    you.duration[DUR_SLOW] = 0;</a>
<a name="ln1386">    you.duration[DUR_PETRIFYING] = 0;</a>
<a name="ln1387">    you.duration[DUR_WEAK] = 0;</a>
<a name="ln1388">    restore_stat(STAT_ALL, 0, false);</a>
<a name="ln1389">    unrot_hp(9999);</a>
<a name="ln1390">    you.redraw_evasion = true;</a>
<a name="ln1391">}</a>
<a name="ln1392"> </a>
<a name="ln1393">bool elyvilon_divine_vigour()</a>
<a name="ln1394">{</a>
<a name="ln1395">    bool success = false;</a>
<a name="ln1396"> </a>
<a name="ln1397">    if (!you.duration[DUR_DIVINE_VIGOUR])</a>
<a name="ln1398">    {</a>
<a name="ln1399">        mprf(&quot;%s grants you divine vigour.&quot;,</a>
<a name="ln1400">             god_name(GOD_ELYVILON).c_str());</a>
<a name="ln1401"> </a>
<a name="ln1402">        const int vigour_amt = 1 + you.skill_rdiv(SK_INVOCATIONS, 1, 3);</a>
<a name="ln1403">        const int old_hp_max = you.hp_max;</a>
<a name="ln1404">        const int old_mp_max = you.max_magic_points;</a>
<a name="ln1405">        you.attribute[ATTR_DIVINE_VIGOUR] = vigour_amt;</a>
<a name="ln1406">        you.set_duration(DUR_DIVINE_VIGOUR,</a>
<a name="ln1407">                         40 + you.skill_rdiv(SK_INVOCATIONS, 5, 2));</a>
<a name="ln1408"> </a>
<a name="ln1409">        calc_hp();</a>
<a name="ln1410">        inc_hp((you.hp_max * you.hp + old_hp_max - 1)/old_hp_max - you.hp);</a>
<a name="ln1411">        calc_mp();</a>
<a name="ln1412">        if (old_mp_max &gt; 0)</a>
<a name="ln1413">        {</a>
<a name="ln1414">            inc_mp((you.max_magic_points * you.magic_points + old_mp_max - 1)</a>
<a name="ln1415">                     / old_mp_max</a>
<a name="ln1416">                   - you.magic_points);</a>
<a name="ln1417">        }</a>
<a name="ln1418"> </a>
<a name="ln1419">        success = true;</a>
<a name="ln1420">    }</a>
<a name="ln1421">    else</a>
<a name="ln1422">        canned_msg(MSG_NOTHING_HAPPENS);</a>
<a name="ln1423"> </a>
<a name="ln1424">    return success;</a>
<a name="ln1425">}</a>
<a name="ln1426"> </a>
<a name="ln1427">void elyvilon_remove_divine_vigour()</a>
<a name="ln1428">{</a>
<a name="ln1429">    mprf(MSGCH_DURATION, &quot;Your divine vigour fades away.&quot;);</a>
<a name="ln1430">    you.duration[DUR_DIVINE_VIGOUR] = 0;</a>
<a name="ln1431">    you.attribute[ATTR_DIVINE_VIGOUR] = 0;</a>
<a name="ln1432">    calc_hp();</a>
<a name="ln1433">    calc_mp();</a>
<a name="ln1434">}</a>
<a name="ln1435"> </a>
<a name="ln1436">bool vehumet_supports_spell(spell_type spell)</a>
<a name="ln1437">{</a>
<a name="ln1438">    if (spell_typematch(spell, spschool::conjuration))</a>
<a name="ln1439">        return true;</a>
<a name="ln1440"> </a>
<a name="ln1441">    // Conjurations work by conjuring up a chunk of short-lived matter and</a>
<a name="ln1442">    // propelling it towards the victim. This is the most popular way, but</a>
<a name="ln1443">    // by no means it has a monopoly for being destructive.</a>
<a name="ln1444">    // Vehumet loves all direct physical destruction.</a>
<a name="ln1445">    if (spell == SPELL_SHATTER</a>
<a name="ln1446">        || spell == SPELL_LRD</a>
<a name="ln1447">        || spell == SPELL_SANDBLAST</a>
<a name="ln1448">        || spell == SPELL_AIRSTRIKE</a>
<a name="ln1449">        || spell == SPELL_TORNADO</a>
<a name="ln1450">        || spell == SPELL_FREEZE</a>
<a name="ln1451">        || spell == SPELL_IGNITE_POISON</a>
<a name="ln1452">        || spell == SPELL_OZOCUBUS_REFRIGERATION</a>
<a name="ln1453">        || spell == SPELL_OLGREBS_TOXIC_RADIANCE</a>
<a name="ln1454">        || spell == SPELL_VIOLENT_UNRAVELLING</a>
<a name="ln1455">        || spell == SPELL_INNER_FLAME</a>
<a name="ln1456">        || spell == SPELL_IGNITION</a>
<a name="ln1457">        || spell == SPELL_FROZEN_RAMPARTS</a>
<a name="ln1458">        || spell == SPELL_ABSOLUTE_ZERO)</a>
<a name="ln1459">    {</a>
<a name="ln1460">        return true;</a>
<a name="ln1461">    }</a>
<a name="ln1462"> </a>
<a name="ln1463">    return false;</a>
<a name="ln1464">}</a>
<a name="ln1465"> </a>
<a name="ln1466">void trog_do_trogs_hand(int pow)</a>
<a name="ln1467">{</a>
<a name="ln1468">    you.increase_duration(DUR_TROGS_HAND,</a>
<a name="ln1469">                          5 + roll_dice(2, pow / 3 + 1), 100,</a>
<a name="ln1470">                          &quot;Your skin crawls.&quot;);</a>
<a name="ln1471">    mprf(MSGCH_DURATION, &quot;You feel resistant to hostile enchantments.&quot;);</a>
<a name="ln1472">}</a>
<a name="ln1473"> </a>
<a name="ln1474">void trog_remove_trogs_hand()</a>
<a name="ln1475">{</a>
<a name="ln1476">    mprf(MSGCH_DURATION, &quot;Your skin stops crawling.&quot;);</a>
<a name="ln1477">    mprf(MSGCH_DURATION, &quot;You feel less resistant to hostile enchantments.&quot;);</a>
<a name="ln1478">    you.duration[DUR_TROGS_HAND] = 0;</a>
<a name="ln1479">}</a>
<a name="ln1480"> </a>
<a name="ln1481">/**</a>
<a name="ln1482"> * Has the monster been given a Beogh gift?</a>
<a name="ln1483"> *</a>
<a name="ln1484"> * @param mon the orc in question.</a>
<a name="ln1485"> * @returns whether you have given the monster a Beogh gift before now.</a>
<a name="ln1486"> */</a>
<a name="ln1487">bool given_gift(const monster* mon)</a>
<a name="ln1488">{</a>
<a name="ln1489">    return mon-&gt;props.exists(BEOGH_RANGE_WPN_GIFT_KEY)</a>
<a name="ln1490">            || mon-&gt;props.exists(BEOGH_MELEE_WPN_GIFT_KEY)</a>
<a name="ln1491">            || mon-&gt;props.exists(BEOGH_ARM_GIFT_KEY)</a>
<a name="ln1492">            || mon-&gt;props.exists(BEOGH_SH_GIFT_KEY);</a>
<a name="ln1493">}</a>
<a name="ln1494"> </a>
<a name="ln1495">/**</a>
<a name="ln1496"> * Checks whether the target monster is a valid target for beogh item-gifts.</a>
<a name="ln1497"> *</a>
<a name="ln1498"> * @param mons[in]  The monster to consider giving an item to.</a>
<a name="ln1499"> * @param quiet     Whether to print messages if the target is invalid.</a>
<a name="ln1500"> * @return          Whether the player can give an item to the monster.</a>
<a name="ln1501"> */</a>
<a name="ln1502">bool beogh_can_gift_items_to(const monster* mons, bool quiet)</a>
<a name="ln1503">{</a>
<a name="ln1504">    if (!mons || !mons-&gt;visible_to(&amp;you))</a>
<a name="ln1505">    {</a>
<a name="ln1506">        if (!quiet)</a>
<a name="ln1507">            canned_msg(MSG_NOTHING_THERE);</a>
<a name="ln1508">        return false;</a>
<a name="ln1509">    }</a>
<a name="ln1510"> </a>
<a name="ln1511">    if (!is_orcish_follower(*mons) || mons_genus(mons-&gt;type) != MONS_ORC)</a>
<a name="ln1512">    {</a>
<a name="ln1513">        if (!quiet)</a>
<a name="ln1514">            mpr(&quot;That's not an orcish ally!&quot;);</a>
<a name="ln1515">        return false;</a>
<a name="ln1516">    }</a>
<a name="ln1517"> </a>
<a name="ln1518">    if (!mons-&gt;is_named())</a>
<a name="ln1519">    {</a>
<a name="ln1520">        if (!quiet)</a>
<a name="ln1521">            mpr(&quot;That orc has not proved itself worthy of your gift.&quot;);</a>
<a name="ln1522">        return false;</a>
<a name="ln1523">    }</a>
<a name="ln1524"> </a>
<a name="ln1525">    if (given_gift(mons))</a>
<a name="ln1526">    {</a>
<a name="ln1527">        if (!quiet)</a>
<a name="ln1528">        {</a>
<a name="ln1529">            mprf(&quot;%s has already been given a gift.&quot;,</a>
<a name="ln1530">                 mons-&gt;name(DESC_THE, false).c_str());</a>
<a name="ln1531">        }</a>
<a name="ln1532">        return false;</a>
<a name="ln1533">    }</a>
<a name="ln1534"> </a>
<a name="ln1535">    return true;</a>
<a name="ln1536">}</a>
<a name="ln1537"> </a>
<a name="ln1538">/**</a>
<a name="ln1539"> * Checks whether there are any valid targets for beogh gifts in LOS.</a>
<a name="ln1540"> */</a>
<a name="ln1541">static bool _valid_beogh_gift_targets_in_sight()</a>
<a name="ln1542">{</a>
<a name="ln1543">    for (monster_near_iterator rad(you.pos(), LOS_NO_TRANS); rad; ++rad)</a>
<a name="ln1544">        if (beogh_can_gift_items_to(*rad))</a>
<a name="ln1545">            return true;</a>
<a name="ln1546">    return false;</a>
<a name="ln1547">}</a>
<a name="ln1548"> </a>
<a name="ln1549">/**</a>
<a name="ln1550"> * Allow the player to give an item to a named orcish ally that hasn't</a>
<a name="ln1551"> * been given a gift before</a>
<a name="ln1552"> *</a>
<a name="ln1553"> * @returns whether an item was given.</a>
<a name="ln1554"> */</a>
<a name="ln1555">bool beogh_gift_item()</a>
<a name="ln1556">{</a>
<a name="ln1557">    if (!_valid_beogh_gift_targets_in_sight())</a>
<a name="ln1558">    {</a>
<a name="ln1559">        mpr(&quot;No worthy followers in sight.&quot;);</a>
<a name="ln1560">        return false;</a>
<a name="ln1561">    }</a>
<a name="ln1562"> </a>
<a name="ln1563">    dist spd;</a>
<a name="ln1564"> </a>
<a name="ln1565">    direction_chooser_args args;</a>
<a name="ln1566">    args.restricts = DIR_TARGET;</a>
<a name="ln1567">    args.mode = TARG_BEOGH_GIFTABLE;</a>
<a name="ln1568">    args.range = LOS_RADIUS;</a>
<a name="ln1569">    args.needs_path = false;</a>
<a name="ln1570">    args.self = confirm_prompt_type::cancel;</a>
<a name="ln1571">    args.show_floor_desc = true;</a>
<a name="ln1572">    args.top_prompt = &quot;Select a follower to give a gift to.&quot;;</a>
<a name="ln1573"> </a>
<a name="ln1574">    direction(spd, args);</a>
<a name="ln1575"> </a>
<a name="ln1576">    if (!spd.isValid)</a>
<a name="ln1577">        return false;</a>
<a name="ln1578"> </a>
<a name="ln1579">    monster* mons = monster_at(spd.target);</a>
<a name="ln1580">    if (!beogh_can_gift_items_to(mons, false))</a>
<a name="ln1581">        return false;</a>
<a name="ln1582"> </a>
<a name="ln1583">    int item_slot = prompt_invent_item(&quot;Give which item?&quot;,</a>
<a name="ln1584">                                       menu_type::invlist, OSEL_BEOGH_GIFT);</a>
<a name="ln1585"> </a>
<a name="ln1586">    if (item_slot == PROMPT_ABORT || item_slot == PROMPT_NOTHING)</a>
<a name="ln1587">    {</a>
<a name="ln1588">        canned_msg(MSG_OK);</a>
<a name="ln1589">        return false;</a>
<a name="ln1590">    }</a>
<a name="ln1591"> </a>
<a name="ln1592">    item_def&amp; gift = you.inv[item_slot];</a>
<a name="ln1593"> </a>
<a name="ln1594">    const bool shield = is_shield(gift);</a>
<a name="ln1595">    const bool body_armour = gift.base_type == OBJ_ARMOUR</a>
<a name="ln1596">                             &amp;&amp; get_armour_slot(gift) == EQ_BODY_ARMOUR;</a>
<a name="ln1597">    const bool weapon = gift.base_type == OBJ_WEAPONS;</a>
<a name="ln1598">    const bool range_weapon = weapon &amp;&amp; is_range_weapon(gift);</a>
<a name="ln1599">    const item_def* mons_weapon = mons-&gt;weapon();</a>
<a name="ln1600">    const item_def* mons_alt_weapon = mons-&gt;mslot_item(MSLOT_ALT_WEAPON);</a>
<a name="ln1601"> </a>
<a name="ln1602">    if (weapon &amp;&amp; !mons-&gt;could_wield(gift)</a>
<a name="ln1603">        || body_armour &amp;&amp; !check_armour_size(gift, mons-&gt;body_size())</a>
<a name="ln1604">        || !item_is_selected(gift, OSEL_BEOGH_GIFT))</a>
<a name="ln1605">    {</a>
<a name="ln1606">        mprf(&quot;You can't give that to %s.&quot;, mons-&gt;name(DESC_THE, false).c_str());</a>
<a name="ln1607"> </a>
<a name="ln1608">        return false;</a>
<a name="ln1609">    }</a>
<a name="ln1610">    else if (shield</a>
<a name="ln1611">             &amp;&amp; (mons_weapon &amp;&amp; mons-&gt;hands_reqd(*mons_weapon) == HANDS_TWO</a>
<a name="ln1612">                 || mons_alt_weapon</a>
<a name="ln1613">                    &amp;&amp; mons-&gt;hands_reqd(*mons_alt_weapon) == HANDS_TWO))</a>
<a name="ln1614">    {</a>
<a name="ln1615">        mprf(&quot;%s can't equip that with a two-handed weapon.&quot;,</a>
<a name="ln1616">             mons-&gt;name(DESC_THE, false).c_str());</a>
<a name="ln1617">        return false;</a>
<a name="ln1618">    }</a>
<a name="ln1619"> </a>
<a name="ln1620">    // if we're giving a ranged weapon to an orc holding a melee weapon in</a>
<a name="ln1621">    // their hands, or vice versa, put it in their carried slot instead.</a>
<a name="ln1622">    // this will of course drop anything that's there.</a>
<a name="ln1623">    const bool use_alt_slot = weapon &amp;&amp; mons_weapon</a>
<a name="ln1624">                              &amp;&amp; is_range_weapon(gift) !=</a>
<a name="ln1625">                                 is_range_weapon(*mons_weapon);</a>
<a name="ln1626"> </a>
<a name="ln1627">    const auto mslot = body_armour ? MSLOT_ARMOUR :</a>
<a name="ln1628">                                    shield ? MSLOT_SHIELD :</a>
<a name="ln1629">                              use_alt_slot ? MSLOT_ALT_WEAPON :</a>
<a name="ln1630">                                             MSLOT_WEAPON;</a>
<a name="ln1631"> </a>
<a name="ln1632">    // need to remove any curses so that drop_item won't fail</a>
<a name="ln1633">    item_def* item_to_drop = mons-&gt;mslot_item(mslot);</a>
<a name="ln1634">    if (item_to_drop &amp;&amp; item_to_drop-&gt;cursed())</a>
<a name="ln1635">    {</a>
<a name="ln1636">        mprf(&quot;%s removes the curse on %s.&quot;, god_name(GOD_BEOGH).c_str(),</a>
<a name="ln1637">                                item_to_drop-&gt;name(DESC_THE).c_str());</a>
<a name="ln1638">        do_uncurse_item(*item_to_drop);</a>
<a name="ln1639">    }</a>
<a name="ln1640"> </a>
<a name="ln1641">    item_def *shield_slot = mons-&gt;mslot_item(MSLOT_SHIELD);</a>
<a name="ln1642">    if ((mslot == MSLOT_WEAPON || mslot == MSLOT_ALT_WEAPON)</a>
<a name="ln1643">        &amp;&amp; shield_slot</a>
<a name="ln1644">        &amp;&amp; mons-&gt;hands_reqd(gift) == HANDS_TWO</a>
<a name="ln1645">        &amp;&amp; shield_slot-&gt;cursed())</a>
<a name="ln1646">    {</a>
<a name="ln1647">        // TODO: this doesn't seem to describe the shield as uncursed to the</a>
<a name="ln1648">        // player. The weapon case works properly.</a>
<a name="ln1649">        mprf(&quot;%s removes the curse on %s.&quot;, god_name(GOD_BEOGH).c_str(),</a>
<a name="ln1650">                                shield_slot-&gt;name(DESC_THE).c_str());</a>
<a name="ln1651">        do_uncurse_item(*shield_slot);</a>
<a name="ln1652">    }</a>
<a name="ln1653"> </a>
<a name="ln1654">    item_def *floor_item = mons-&gt;take_item(item_slot, mslot);</a>
<a name="ln1655">    if (!floor_item)</a>
<a name="ln1656">    {</a>
<a name="ln1657">        // this probably means move_to_grid in drop_item failed?</a>
<a name="ln1658">        mprf(MSGCH_ERROR, &quot;Gift failed: %s is unable to take %s.&quot;,</a>
<a name="ln1659">                                        mons-&gt;name(DESC_THE, false).c_str(),</a>
<a name="ln1660">                                        gift.name(DESC_THE, false).c_str());</a>
<a name="ln1661">        return false;</a>
<a name="ln1662">    }</a>
<a name="ln1663">    if (use_alt_slot)</a>
<a name="ln1664">        mons-&gt;swap_weapons();</a>
<a name="ln1665"> </a>
<a name="ln1666">    dprf(&quot;is_ranged weap: %d&quot;, range_weapon);</a>
<a name="ln1667">    if (range_weapon)</a>
<a name="ln1668">        gift_ammo_to_orc(mons, true); // give a small initial ammo freebie</a>
<a name="ln1669"> </a>
<a name="ln1670"> </a>
<a name="ln1671">    if (shield)</a>
<a name="ln1672">        mons-&gt;props[BEOGH_SH_GIFT_KEY] = true;</a>
<a name="ln1673">    else if (body_armour)</a>
<a name="ln1674">        mons-&gt;props[BEOGH_ARM_GIFT_KEY] = true;</a>
<a name="ln1675">    else if (range_weapon)</a>
<a name="ln1676">        mons-&gt;props[BEOGH_RANGE_WPN_GIFT_KEY] = true;</a>
<a name="ln1677">    else</a>
<a name="ln1678">        mons-&gt;props[BEOGH_MELEE_WPN_GIFT_KEY] = true;</a>
<a name="ln1679"> </a>
<a name="ln1680">    return true;</a>
<a name="ln1681">}</a>
<a name="ln1682"> </a>
<a name="ln1683">bool beogh_resurrect()</a>
<a name="ln1684">{</a>
<a name="ln1685">    item_def* corpse = nullptr;</a>
<a name="ln1686">    bool found_any = false;</a>
<a name="ln1687">    for (stack_iterator si(you.pos()); si; ++si)</a>
<a name="ln1688">        if (si-&gt;props.exists(ORC_CORPSE_KEY))</a>
<a name="ln1689">        {</a>
<a name="ln1690">            found_any = true;</a>
<a name="ln1691">            if (yesno((&quot;Resurrect &quot;</a>
<a name="ln1692">                       + si-&gt;props[ORC_CORPSE_KEY].get_monster().name(DESC_THE)</a>
<a name="ln1693">                       + &quot;?&quot;).c_str(), true, 'n'))</a>
<a name="ln1694">            {</a>
<a name="ln1695">                corpse = &amp;*si;</a>
<a name="ln1696">                break;</a>
<a name="ln1697">            }</a>
<a name="ln1698">        }</a>
<a name="ln1699">    if (!corpse)</a>
<a name="ln1700">    {</a>
<a name="ln1701">        mprf(&quot;There's nobody %shere you can resurrect.&quot;,</a>
<a name="ln1702">             found_any ? &quot;else &quot; : &quot;&quot;);</a>
<a name="ln1703">        return false;</a>
<a name="ln1704">    }</a>
<a name="ln1705"> </a>
<a name="ln1706">    coord_def pos;</a>
<a name="ln1707">    ASSERT(corpse-&gt;props.exists(ORC_CORPSE_KEY));</a>
<a name="ln1708">    for (fair_adjacent_iterator ai(you.pos()); ai; ++ai)</a>
<a name="ln1709">    {</a>
<a name="ln1710">        if (!actor_at(*ai)</a>
<a name="ln1711">            &amp;&amp; corpse-&gt;props[ORC_CORPSE_KEY].get_monster().is_location_safe(*ai))</a>
<a name="ln1712">        {</a>
<a name="ln1713">            pos = *ai;</a>
<a name="ln1714">        }</a>
<a name="ln1715">    }</a>
<a name="ln1716">    if (pos.origin())</a>
<a name="ln1717">    {</a>
<a name="ln1718">        mpr(&quot;There's no room!&quot;);</a>
<a name="ln1719">        return false;</a>
<a name="ln1720">    }</a>
<a name="ln1721"> </a>
<a name="ln1722">    monster* mon = get_free_monster();</a>
<a name="ln1723">    *mon = corpse-&gt;props[ORC_CORPSE_KEY];</a>
<a name="ln1724">    destroy_item(corpse-&gt;index());</a>
<a name="ln1725">    env.mid_cache[mon-&gt;mid] = mon-&gt;mindex();</a>
<a name="ln1726">    mon-&gt;hit_points = mon-&gt;max_hit_points;</a>
<a name="ln1727">    mon-&gt;inv.init(NON_ITEM);</a>
<a name="ln1728">    for (stack_iterator si(you.pos()); si; ++si)</a>
<a name="ln1729">    {</a>
<a name="ln1730">        if (!si-&gt;props.exists(DROPPER_MID_KEY)</a>
<a name="ln1731">            || si-&gt;props[DROPPER_MID_KEY].get_int() != int(mon-&gt;mid))</a>
<a name="ln1732">        {</a>
<a name="ln1733">            continue;</a>
<a name="ln1734">        }</a>
<a name="ln1735">        unwind_var&lt;int&gt; save_speedinc(mon-&gt;speed_increment);</a>
<a name="ln1736">        mon-&gt;pickup_item(*si, false, true);</a>
<a name="ln1737">    }</a>
<a name="ln1738">    mon-&gt;move_to_pos(pos);</a>
<a name="ln1739">    mon-&gt;timeout_enchantments(100);</a>
<a name="ln1740">    beogh_convert_orc(mon, conv_t::resurrection);</a>
<a name="ln1741"> </a>
<a name="ln1742">    return true;</a>
<a name="ln1743">}</a>
<a name="ln1744"> </a>
<a name="ln1745">bool jiyva_remove_bad_mutation()</a>
<a name="ln1746">{</a>
<a name="ln1747">    if (!you.how_mutated())</a>
<a name="ln1748">    {</a>
<a name="ln1749">        mpr(&quot;You have no bad mutations to be cured!&quot;);</a>
<a name="ln1750">        return false;</a>
<a name="ln1751">    }</a>
<a name="ln1752"> </a>
<a name="ln1753">    // Ensure that only bad mutations are removed.</a>
<a name="ln1754">    if (!delete_mutation(RANDOM_BAD_MUTATION, &quot;Jiyva's power&quot;, true, false, true, true))</a>
<a name="ln1755">    {</a>
<a name="ln1756">        canned_msg(MSG_NOTHING_HAPPENS);</a>
<a name="ln1757">        return false;</a>
<a name="ln1758">    }</a>
<a name="ln1759"> </a>
<a name="ln1760">    mpr(&quot;You feel cleansed.&quot;);</a>
<a name="ln1761">    return true;</a>
<a name="ln1762">}</a>
<a name="ln1763"> </a>
<a name="ln1764">bool yred_injury_mirror()</a>
<a name="ln1765">{</a>
<a name="ln1766">    return in_good_standing(GOD_YREDELEMNUL, 1)</a>
<a name="ln1767">           &amp;&amp; you.duration[DUR_MIRROR_DAMAGE]</a>
<a name="ln1768">           &amp;&amp; crawl_state.which_god_acting() != GOD_YREDELEMNUL;</a>
<a name="ln1769">}</a>
<a name="ln1770"> </a>
<a name="ln1771">bool yred_can_enslave_soul(monster* mon)</a>
<a name="ln1772">{</a>
<a name="ln1773">    return (mon-&gt;holiness() &amp; MH_NATURAL</a>
<a name="ln1774">            || mon-&gt;holiness() &amp; MH_DEMONIC</a>
<a name="ln1775">            || mon-&gt;holiness() &amp; MH_HOLY)</a>
<a name="ln1776">           &amp;&amp; !mon-&gt;is_summoned()</a>
<a name="ln1777">           &amp;&amp; !mons_enslaved_body_and_soul(*mon)</a>
<a name="ln1778">           &amp;&amp; mon-&gt;attitude != ATT_FRIENDLY</a>
<a name="ln1779">           &amp;&amp; mons_intel(*mon) &gt;= I_HUMAN</a>
<a name="ln1780">           &amp;&amp; mon-&gt;type != MONS_PANDEMONIUM_LORD;</a>
<a name="ln1781">}</a>
<a name="ln1782"> </a>
<a name="ln1783">void yred_make_enslaved_soul(monster* mon, bool force_hostile)</a>
<a name="ln1784">{</a>
<a name="ln1785">    ASSERT(mon); // XXX: change to monster &amp;mon</a>
<a name="ln1786">    ASSERT(mons_enslaved_body_and_soul(*mon));</a>
<a name="ln1787"> </a>
<a name="ln1788">    add_daction(DACT_OLD_ENSLAVED_SOULS_POOF);</a>
<a name="ln1789">    remove_enslaved_soul_companion();</a>
<a name="ln1790"> </a>
<a name="ln1791">    const string whose = you.can_see(*mon) ? apostrophise(mon-&gt;name(DESC_THE))</a>
<a name="ln1792">                                           : mon-&gt;pronoun(PRONOUN_POSSESSIVE);</a>
<a name="ln1793"> </a>
<a name="ln1794">    // Remove the monster's soul-enslaving enchantment, as it's no</a>
<a name="ln1795">    // longer needed.</a>
<a name="ln1796">    mon-&gt;del_ench(ENCH_SOUL_RIPE, false, false);</a>
<a name="ln1797"> </a>
<a name="ln1798">    // Remove the monster's invisibility enchantment. If we don't do</a>
<a name="ln1799">    // this, it'll stay invisible after being remade as a spectral thing</a>
<a name="ln1800">    // below.</a>
<a name="ln1801">    mon-&gt;del_ench(ENCH_INVIS, false, false);</a>
<a name="ln1802"> </a>
<a name="ln1803">    // If the monster's held in a net, get it out.</a>
<a name="ln1804">    mons_clear_trapping_net(mon);</a>
<a name="ln1805"> </a>
<a name="ln1806">    // Rebrand or drop any holy equipment, and keep wielding the rest. Also</a>
<a name="ln1807">    // remove any active avatars.</a>
<a name="ln1808">    for (int slot = MSLOT_WEAPON; slot &lt;= MSLOT_ALT_WEAPON; slot++)</a>
<a name="ln1809">    {</a>
<a name="ln1810">        item_def *wpn = mon-&gt;mslot_item(static_cast&lt;mon_inv_type&gt;(slot));</a>
<a name="ln1811">        if (wpn &amp;&amp; get_weapon_brand(*wpn) == SPWPN_HOLY_WRATH)</a>
<a name="ln1812">        {</a>
<a name="ln1813">            set_item_ego_type(*wpn, OBJ_WEAPONS, SPWPN_DRAINING);</a>
<a name="ln1814">            convert2bad(*wpn);</a>
<a name="ln1815">        }</a>
<a name="ln1816">    }</a>
<a name="ln1817">    monster_drop_things(mon, false, [](const item_def&amp; item)</a>
<a name="ln1818">                                    { return is_holy_item(item); });</a>
<a name="ln1819">    mon-&gt;remove_summons();</a>
<a name="ln1820"> </a>
<a name="ln1821">    const monster orig = *mon;</a>
<a name="ln1822"> </a>
<a name="ln1823">    // Use the original monster type as the zombified type here, to get</a>
<a name="ln1824">    // the proper stats from it.</a>
<a name="ln1825">    define_zombie(mon, mon-&gt;type, MONS_SPECTRAL_THING);</a>
<a name="ln1826"> </a>
<a name="ln1827">    // If the original monster has been levelled up, its HD might be different</a>
<a name="ln1828">    // from its class HD, in which case its HP should be rerolled to match.</a>
<a name="ln1829">    if (mon-&gt;get_experience_level() != orig.get_experience_level())</a>
<a name="ln1830">    {</a>
<a name="ln1831">        mon-&gt;set_hit_dice(max(orig.get_experience_level(), 1));</a>
<a name="ln1832">        roll_zombie_hp(mon);</a>
<a name="ln1833">    }</a>
<a name="ln1834"> </a>
<a name="ln1835">    mon-&gt;colour = ETC_UNHOLY;</a>
<a name="ln1836"> </a>
<a name="ln1837">    mon-&gt;flags |= MF_NO_REWARD;</a>
<a name="ln1838">    mon-&gt;flags |= MF_ENSLAVED_SOUL;</a>
<a name="ln1839"> </a>
<a name="ln1840">    // If the original monster type has melee abilities, make sure</a>
<a name="ln1841">    // its spectral thing has them as well.</a>
<a name="ln1842">    mon-&gt;flags |= orig.flags &amp; MF_MELEE_MASK;</a>
<a name="ln1843">    monster_spells spl = orig.spells;</a>
<a name="ln1844">    for (const mon_spell_slot &amp;slot : spl)</a>
<a name="ln1845">        if (!(get_spell_flags(slot.spell) &amp; spflag::holy))</a>
<a name="ln1846">            mon-&gt;spells.push_back(slot);</a>
<a name="ln1847">    if (mon-&gt;spells.size())</a>
<a name="ln1848">        mon-&gt;props[CUSTOM_SPELLS_KEY] = true;</a>
<a name="ln1849"> </a>
<a name="ln1850">    name_zombie(*mon, orig);</a>
<a name="ln1851"> </a>
<a name="ln1852">    mons_make_god_gift(*mon, GOD_YREDELEMNUL);</a>
<a name="ln1853">    add_companion(mon);</a>
<a name="ln1854"> </a>
<a name="ln1855">    mon-&gt;attitude = !force_hostile ? ATT_FRIENDLY : ATT_HOSTILE;</a>
<a name="ln1856">    behaviour_event(mon, ME_ALERT, force_hostile ? &amp;you : 0);</a>
<a name="ln1857"> </a>
<a name="ln1858">    mon-&gt;stop_constricting_all();</a>
<a name="ln1859">    mon-&gt;stop_being_constricted();</a>
<a name="ln1860"> </a>
<a name="ln1861">    if (orig.halo_radius()</a>
<a name="ln1862">        || orig.umbra_radius()</a>
<a name="ln1863">        || orig.silence_radius())</a>
<a name="ln1864">    {</a>
<a name="ln1865">        invalidate_agrid();</a>
<a name="ln1866">    }</a>
<a name="ln1867"> </a>
<a name="ln1868">    mprf(&quot;%s soul %s.&quot;, whose.c_str(),</a>
<a name="ln1869">         !force_hostile ? &quot;is now yours&quot; : &quot;fights you&quot;);</a>
<a name="ln1870">}</a>
<a name="ln1871"> </a>
<a name="ln1872">bool kiku_receive_corpses(int pow)</a>
<a name="ln1873">{</a>
<a name="ln1874">    // pow = necromancy * 4, ranges from 0 to 108</a>
<a name="ln1875">    dprf(&quot;kiku_receive_corpses() power: %d&quot;, pow);</a>
<a name="ln1876"> </a>
<a name="ln1877">    // Kiku gives branch-appropriate corpses (like shadow creatures).</a>
<a name="ln1878">    // 1d2 at 0 Nec, up to 8 at 27 Nec.</a>
<a name="ln1879">    int expected_extra_corpses = 1 + random2(2) + random2(pow / 18);</a>
<a name="ln1880">    int corpse_delivery_radius = 1;</a>
<a name="ln1881"> </a>
<a name="ln1882">    // We should get the same number of corpses</a>
<a name="ln1883">    // in a hallway as in an open room.</a>
<a name="ln1884">    int spaces_for_corpses = 0;</a>
<a name="ln1885">    for (radius_iterator ri(you.pos(), corpse_delivery_radius, C_SQUARE,</a>
<a name="ln1886">                            LOS_NO_TRANS, true); ri; ++ri)</a>
<a name="ln1887">    {</a>
<a name="ln1888">        if (mons_class_can_pass(MONS_HUMAN, grd(*ri)))</a>
<a name="ln1889">            spaces_for_corpses++;</a>
<a name="ln1890">    }</a>
<a name="ln1891">    // floating over lava, heavy tomb abuse, etc</a>
<a name="ln1892">    if (!spaces_for_corpses)</a>
<a name="ln1893">        spaces_for_corpses++;</a>
<a name="ln1894"> </a>
<a name="ln1895">    int percent_chance_a_square_receives_extra_corpse = // can be &gt; 100</a>
<a name="ln1896">        int(float(expected_extra_corpses) / float(spaces_for_corpses) * 100.0);</a>
<a name="ln1897"> </a>
<a name="ln1898">    int corpses_created = 0;</a>
<a name="ln1899"> </a>
<a name="ln1900">    for (radius_iterator ri(you.pos(), corpse_delivery_radius, C_SQUARE,</a>
<a name="ln1901">                            LOS_NO_TRANS); ri; ++ri)</a>
<a name="ln1902">    {</a>
<a name="ln1903">        bool square_is_walkable = mons_class_can_pass(MONS_HUMAN, grd(*ri));</a>
<a name="ln1904">        bool square_is_player_square = (*ri == you.pos());</a>
<a name="ln1905">        bool square_gets_corpse =</a>
<a name="ln1906">            random2(100) &lt; percent_chance_a_square_receives_extra_corpse</a>
<a name="ln1907">            || square_is_player_square &amp;&amp; random2(100) &lt; 97;</a>
<a name="ln1908"> </a>
<a name="ln1909">        if (!square_is_walkable || !square_gets_corpse)</a>
<a name="ln1910">            continue;</a>
<a name="ln1911"> </a>
<a name="ln1912">        corpses_created++;</a>
<a name="ln1913"> </a>
<a name="ln1914">        // Find an appropriate monster corpse for level and power.</a>
<a name="ln1915">        const int adjusted_power = min(pow / 4, random2(random2(pow)));</a>
<a name="ln1916">        // Pick a place based on the power. This may be below the branch's</a>
<a name="ln1917">        // start, that's ok.</a>
<a name="ln1918">        const level_id lev(you.where_are_you, adjusted_power</a>
<a name="ln1919">                           - absdungeon_depth(you.where_are_you, 0));</a>
<a name="ln1920">        const monster_type mon_type = pick_local_corpsey_monster(lev);</a>
<a name="ln1921">        ASSERT(mons_class_can_be_zombified(mons_species(mon_type)));</a>
<a name="ln1922"> </a>
<a name="ln1923">        // Create corpse object.</a>
<a name="ln1924">        monster dummy;</a>
<a name="ln1925">        dummy.type = mon_type;</a>
<a name="ln1926">        define_monster(dummy);</a>
<a name="ln1927">        dummy.position = *ri;</a>
<a name="ln1928"> </a>
<a name="ln1929">        item_def* corpse = place_monster_corpse(dummy, true, true);</a>
<a name="ln1930">        if (!corpse)</a>
<a name="ln1931">            continue;</a>
<a name="ln1932"> </a>
<a name="ln1933">        // Higher piety means fresher corpses.</a>
<a name="ln1934">        int rottedness = 200 -</a>
<a name="ln1935">            (!one_chance_in(10) ? random2(200 - you.piety)</a>
<a name="ln1936">                                : random2(100 + random2(75)));</a>
<a name="ln1937">        corpse-&gt;freshness = rottedness;</a>
<a name="ln1938">    }</a>
<a name="ln1939"> </a>
<a name="ln1940">    if (corpses_created)</a>
<a name="ln1941">    {</a>
<a name="ln1942">        if (you_worship(GOD_KIKUBAAQUDGHA))</a>
<a name="ln1943">        {</a>
<a name="ln1944">            simple_god_message(corpses_created &gt; 1 ? &quot; delivers you corpses!&quot;</a>
<a name="ln1945">                                                   : &quot; delivers you a corpse!&quot;);</a>
<a name="ln1946">        }</a>
<a name="ln1947">        maybe_update_stashes();</a>
<a name="ln1948">        return true;</a>
<a name="ln1949">    }</a>
<a name="ln1950">    else</a>
<a name="ln1951">    {</a>
<a name="ln1952">        if (you_worship(GOD_KIKUBAAQUDGHA))</a>
<a name="ln1953">            simple_god_message(&quot; can find no cadavers for you!&quot;);</a>
<a name="ln1954">        return false;</a>
<a name="ln1955">    }</a>
<a name="ln1956">}</a>
<a name="ln1957"> </a>
<a name="ln1958">/**</a>
<a name="ln1959"> * Destroy a corpse at the player's location</a>
<a name="ln1960"> *</a>
<a name="ln1961"> * @return  True if a corpse was destroyed, false otherwise.</a>
<a name="ln1962">*/</a>
<a name="ln1963">bool kiku_take_corpse()</a>
<a name="ln1964">{</a>
<a name="ln1965">    for (int i = you.visible_igrd(you.pos()); i != NON_ITEM; i = mitm[i].link)</a>
<a name="ln1966">    {</a>
<a name="ln1967">        item_def &amp;item(mitm[i]);</a>
<a name="ln1968"> </a>
<a name="ln1969">        if (item.base_type != OBJ_CORPSES || item.sub_type != CORPSE_BODY)</a>
<a name="ln1970">            continue;</a>
<a name="ln1971">        item_was_destroyed(item);</a>
<a name="ln1972">        destroy_item(i);</a>
<a name="ln1973">        return true;</a>
<a name="ln1974">    }</a>
<a name="ln1975"> </a>
<a name="ln1976">    return false;</a>
<a name="ln1977">}</a>
<a name="ln1978"> </a>
<a name="ln1979">bool kiku_gift_necronomicon()</a>
<a name="ln1980">{</a>
<a name="ln1981">    ASSERT(can_do_capstone_ability(you.religion));</a>
<a name="ln1982"> </a>
<a name="ln1983">    if (!yesno(&quot;Do you wish to receive a Necronomicon?&quot;, true, 'n'))</a>
<a name="ln1984">    {</a>
<a name="ln1985">        canned_msg(MSG_OK);</a>
<a name="ln1986">        return false;</a>
<a name="ln1987">    }</a>
<a name="ln1988">    int thing_created = items(true, OBJ_BOOKS, BOOK_NECRONOMICON, 1, 0,</a>
<a name="ln1989">                              you.religion);</a>
<a name="ln1990">    if (thing_created == NON_ITEM</a>
<a name="ln1991">        || !move_item_to_grid(&amp;thing_created, you.pos()))</a>
<a name="ln1992">    {</a>
<a name="ln1993">        return false;</a>
<a name="ln1994">    }</a>
<a name="ln1995">    set_ident_type(mitm[thing_created], true);</a>
<a name="ln1996">    simple_god_message(&quot; grants you a gift!&quot;);</a>
<a name="ln1997">    flash_view(UA_PLAYER, RED);</a>
<a name="ln1998">#ifndef USE_TILE_LOCAL</a>
<a name="ln1999">    // Allow extra time for the flash to linger.</a>
<a name="ln2000">    scaled_delay(1000);</a>
<a name="ln2001">#endif</a>
<a name="ln2002">    more();</a>
<a name="ln2003">    you.one_time_ability_used.set(you.religion);</a>
<a name="ln2004">    take_note(Note(NOTE_GOD_GIFT, you.religion));</a>
<a name="ln2005">    return true;</a>
<a name="ln2006">}</a>
<a name="ln2007"> </a>
<a name="ln2008">bool fedhas_passthrough_class(const monster_type mc)</a>
<a name="ln2009">{</a>
<a name="ln2010">    return have_passive(passive_t::pass_through_plants)</a>
<a name="ln2011">           &amp;&amp; mons_class_is_plant(mc)</a>
<a name="ln2012">           &amp;&amp; mons_class_is_stationary(mc)</a>
<a name="ln2013">           &amp;&amp; mc != MONS_SNAPLASHER_VINE</a>
<a name="ln2014">           &amp;&amp; mc != MONS_SNAPLASHER_VINE_SEGMENT;</a>
<a name="ln2015">}</a>
<a name="ln2016"> </a>
<a name="ln2017">// Fedhas allows worshipers to walk on top of stationary plants and</a>
<a name="ln2018">// fungi.</a>
<a name="ln2019">bool fedhas_passthrough(const monster* target)</a>
<a name="ln2020">{</a>
<a name="ln2021">    return target</a>
<a name="ln2022">           &amp;&amp; fedhas_passthrough_class(target-&gt;type)</a>
<a name="ln2023">           &amp;&amp; (mons_species(target-&gt;type) != MONS_OKLOB_PLANT</a>
<a name="ln2024">               || target-&gt;attitude != ATT_HOSTILE);</a>
<a name="ln2025">}</a>
<a name="ln2026"> </a>
<a name="ln2027">bool fedhas_passthrough(const monster_info* target)</a>
<a name="ln2028">{</a>
<a name="ln2029">    return target</a>
<a name="ln2030">           &amp;&amp; fedhas_passthrough_class(target-&gt;type)</a>
<a name="ln2031">           &amp;&amp; (mons_species(target-&gt;type) != MONS_OKLOB_PLANT</a>
<a name="ln2032">               || target-&gt;attitude != ATT_HOSTILE);</a>
<a name="ln2033">}</a>
<a name="ln2034"> </a>
<a name="ln2035">static bool _lugonu_warp_monster(monster&amp; mon, int pow)</a>
<a name="ln2036">{</a>
<a name="ln2037">    if (coinflip())</a>
<a name="ln2038">        return false;</a>
<a name="ln2039"> </a>
<a name="ln2040">    if (!mon.friendly())</a>
<a name="ln2041">        behaviour_event(&amp;mon, ME_ANNOY, &amp;you);</a>
<a name="ln2042"> </a>
<a name="ln2043">    mon.hurt(&amp;you, 1 + random2(pow / 6));</a>
<a name="ln2044"> </a>
<a name="ln2045">    if (mon.alive() &amp;&amp; !mon.no_tele(true, false))</a>
<a name="ln2046">        mon.blink();</a>
<a name="ln2047"> </a>
<a name="ln2048">    return true;</a>
<a name="ln2049">}</a>
<a name="ln2050"> </a>
<a name="ln2051">static void _lugonu_warp_area(int pow)</a>
<a name="ln2052">{</a>
<a name="ln2053">    apply_monsters_around_square([pow] (monster&amp; mon) {</a>
<a name="ln2054">        return _lugonu_warp_monster(mon, pow);</a>
<a name="ln2055">    }, you.pos());</a>
<a name="ln2056">}</a>
<a name="ln2057"> </a>
<a name="ln2058">void lugonu_bend_space()</a>
<a name="ln2059">{</a>
<a name="ln2060">    const int pow = 4 + skill_bump(SK_INVOCATIONS);</a>
<a name="ln2061">    const bool area_warp = random2(pow) &gt; 9;</a>
<a name="ln2062"> </a>
<a name="ln2063">    mprf(&quot;Space bends %saround you!&quot;, area_warp ? &quot;sharply &quot; : &quot;&quot;);</a>
<a name="ln2064"> </a>
<a name="ln2065">    if (area_warp)</a>
<a name="ln2066">        _lugonu_warp_area(pow);</a>
<a name="ln2067"> </a>
<a name="ln2068">    uncontrolled_blink(true);</a>
<a name="ln2069">}</a>
<a name="ln2070"> </a>
<a name="ln2071">void cheibriados_time_bend(int pow)</a>
<a name="ln2072">{</a>
<a name="ln2073">    mpr(&quot;The flow of time bends around you.&quot;);</a>
<a name="ln2074"> </a>
<a name="ln2075">    for (adjacent_iterator ai(you.pos()); ai; ++ai)</a>
<a name="ln2076">    {</a>
<a name="ln2077">        monster* mon = monster_at(*ai);</a>
<a name="ln2078">        if (mon &amp;&amp; !mon-&gt;is_stationary())</a>
<a name="ln2079">        {</a>
<a name="ln2080">            int res_margin = roll_dice(mon-&gt;get_hit_dice(), 3);</a>
<a name="ln2081">            res_margin -= random2avg(pow, 2);</a>
<a name="ln2082">            if (res_margin &gt; 0)</a>
<a name="ln2083">            {</a>
<a name="ln2084">                mprf(&quot;%s%s&quot;,</a>
<a name="ln2085">                     mon-&gt;name(DESC_THE).c_str(),</a>
<a name="ln2086">                     mon-&gt;resist_margin_phrase(res_margin).c_str());</a>
<a name="ln2087">                continue;</a>
<a name="ln2088">            }</a>
<a name="ln2089"> </a>
<a name="ln2090">            simple_god_message(</a>
<a name="ln2091">                make_stringf(&quot; rebukes %s.&quot;,</a>
<a name="ln2092">                             mon-&gt;name(DESC_THE).c_str()).c_str(),</a>
<a name="ln2093">                             GOD_CHEIBRIADOS);</a>
<a name="ln2094">            do_slow_monster(*mon, &amp;you);</a>
<a name="ln2095">        }</a>
<a name="ln2096">    }</a>
<a name="ln2097">}</a>
<a name="ln2098"> </a>
<a name="ln2099">static int _slouch_damage(monster *mon)</a>
<a name="ln2100">{</a>
<a name="ln2101">    // Please change handle_monster_move in mon-act.cc to match.</a>
<a name="ln2102">    const int jerk_num = mon-&gt;type == MONS_SIXFIRHY ? 8</a>
<a name="ln2103">                       : mon-&gt;type == MONS_JIANGSHI ? 48</a>
<a name="ln2104">                                                    : 1;</a>
<a name="ln2105"> </a>
<a name="ln2106">    const int jerk_denom = mon-&gt;type == MONS_SIXFIRHY ? 24</a>
<a name="ln2107">                         : mon-&gt;type == MONS_JIANGSHI ? 90</a>
<a name="ln2108">                                                      : 1;</a>
<a name="ln2109"> </a>
<a name="ln2110">    const int player_numer = BASELINE_DELAY * BASELINE_DELAY * BASELINE_DELAY;</a>
<a name="ln2111">    return 4 * (mon-&gt;speed * BASELINE_DELAY * jerk_num</a>
<a name="ln2112">                           / mon-&gt;action_energy(EUT_MOVE) / jerk_denom</a>
<a name="ln2113">                - player_numer / player_movement_speed() / player_speed());</a>
<a name="ln2114">}</a>
<a name="ln2115"> </a>
<a name="ln2116">static bool _slouchable(coord_def where)</a>
<a name="ln2117">{</a>
<a name="ln2118">    monster* mon = monster_at(where);</a>
<a name="ln2119">    if (mon == nullptr || mon-&gt;is_stationary() || mon-&gt;cannot_move()</a>
<a name="ln2120">        || mons_is_projectile(mon-&gt;type)</a>
<a name="ln2121">        || mon-&gt;asleep() &amp;&amp; !mons_is_confused(*mon))</a>
<a name="ln2122">    {</a>
<a name="ln2123">        return false;</a>
<a name="ln2124">    }</a>
<a name="ln2125"> </a>
<a name="ln2126">    return _slouch_damage(mon) &gt; 0;</a>
<a name="ln2127">}</a>
<a name="ln2128"> </a>
<a name="ln2129">static bool _act_slouchable(const actor *act)</a>
<a name="ln2130">{</a>
<a name="ln2131">    if (act-&gt;is_player())</a>
<a name="ln2132">        return false;  // too slow-witted</a>
<a name="ln2133">    return _slouchable(act-&gt;pos());</a>
<a name="ln2134">}</a>
<a name="ln2135"> </a>
<a name="ln2136">static int _slouch_monsters(coord_def where)</a>
<a name="ln2137">{</a>
<a name="ln2138">    if (!_slouchable(where))</a>
<a name="ln2139">        return 0;</a>
<a name="ln2140"> </a>
<a name="ln2141">    monster* mon = monster_at(where);</a>
<a name="ln2142">    ASSERT(mon);</a>
<a name="ln2143"> </a>
<a name="ln2144">    // Between 1/2 and 3/2 of _slouch_damage(), but weighted strongly</a>
<a name="ln2145">    // towards the middle.</a>
<a name="ln2146">    const int dmg = roll_dice(_slouch_damage(mon), 3) / 2;</a>
<a name="ln2147"> </a>
<a name="ln2148">    mon-&gt;hurt(&amp;you, dmg, BEAM_MMISSILE, KILLED_BY_BEAM, &quot;&quot;, &quot;&quot;, true);</a>
<a name="ln2149">    return 1;</a>
<a name="ln2150">}</a>
<a name="ln2151"> </a>
<a name="ln2152">bool cheibriados_slouch()</a>
<a name="ln2153">{</a>
<a name="ln2154">    int count = apply_area_visible(_slouchable, you.pos());</a>
<a name="ln2155">    if (!count)</a>
<a name="ln2156">        if (!yesno(&quot;There's no one hasty visible. Invoke Slouch anyway?&quot;,</a>
<a name="ln2157">                   true, 'n'))</a>
<a name="ln2158">        {</a>
<a name="ln2159">            canned_msg(MSG_OK);</a>
<a name="ln2160">            return false;</a>
<a name="ln2161">        }</a>
<a name="ln2162"> </a>
<a name="ln2163">    targeter_radius hitfunc(&amp;you, LOS_DEFAULT);</a>
<a name="ln2164">    if (stop_attack_prompt(hitfunc, &quot;harm&quot;, _act_slouchable))</a>
<a name="ln2165">        return false;</a>
<a name="ln2166"> </a>
<a name="ln2167">    mpr(&quot;You can feel time thicken for a moment.&quot;);</a>
<a name="ln2168">    dprf(&quot;your speed is %d&quot;, player_movement_speed());</a>
<a name="ln2169"> </a>
<a name="ln2170">    apply_area_visible(_slouch_monsters, you.pos());</a>
<a name="ln2171">    return true;</a>
<a name="ln2172">}</a>
<a name="ln2173"> </a>
<a name="ln2174">static void _run_time_step()</a>
<a name="ln2175">{</a>
<a name="ln2176">    ASSERT(you.duration[DUR_TIME_STEP] &gt; 0);</a>
<a name="ln2177">    do</a>
<a name="ln2178">    {</a>
<a name="ln2179">        run_environment_effects();</a>
<a name="ln2180">        handle_monsters();</a>
<a name="ln2181">        manage_clouds();</a>
<a name="ln2182">    }</a>
<a name="ln2183">    while (--you.duration[DUR_TIME_STEP] &gt; 0);</a>
<a name="ln2184">}</a>
<a name="ln2185"> </a>
<a name="ln2186">// A low-duration step from time, allowing monsters to get closer</a>
<a name="ln2187">// to the player safely.</a>
<a name="ln2188">void cheibriados_temporal_distortion()</a>
<a name="ln2189">{</a>
<a name="ln2190">    const coord_def old_pos = you.pos();</a>
<a name="ln2191"> </a>
<a name="ln2192">    you.duration[DUR_TIME_STEP] = 3 + random2(3);</a>
<a name="ln2193">    you.moveto(coord_def(0, 0));</a>
<a name="ln2194"> </a>
<a name="ln2195">    _run_time_step();</a>
<a name="ln2196"> </a>
<a name="ln2197">    you.los_noise_level = 0;</a>
<a name="ln2198">    you.los_noise_last_turn = 0;</a>
<a name="ln2199"> </a>
<a name="ln2200">    if (monster *mon = monster_at(old_pos))</a>
<a name="ln2201">    {</a>
<a name="ln2202">        mon-&gt;props[FAKE_BLINK_KEY].get_bool() = true;</a>
<a name="ln2203">        mon-&gt;blink();</a>
<a name="ln2204">        mon-&gt;props.erase(FAKE_BLINK_KEY);</a>
<a name="ln2205">        if (monster *stubborn = monster_at(old_pos))</a>
<a name="ln2206">            monster_teleport(stubborn, true, true);</a>
<a name="ln2207">    }</a>
<a name="ln2208"> </a>
<a name="ln2209">    you.moveto(old_pos);</a>
<a name="ln2210">    you.duration[DUR_TIME_STEP] = 0;</a>
<a name="ln2211"> </a>
<a name="ln2212">    mpr(&quot;You warp the flow of time around you!&quot;);</a>
<a name="ln2213">}</a>
<a name="ln2214"> </a>
<a name="ln2215">void cheibriados_time_step(int pow) // pow is the number of turns to skip</a>
<a name="ln2216">{</a>
<a name="ln2217">    const coord_def old_pos = you.pos();</a>
<a name="ln2218"> </a>
<a name="ln2219">    mpr(&quot;You step out of the flow of time.&quot;);</a>
<a name="ln2220">    flash_view(UA_PLAYER, LIGHTBLUE);</a>
<a name="ln2221">    you.duration[DUR_TIME_STEP] = pow;</a>
<a name="ln2222">    you.moveto(coord_def(0, 0));</a>
<a name="ln2223"> </a>
<a name="ln2224">    you.time_taken = 10;</a>
<a name="ln2225">    _run_time_step();</a>
<a name="ln2226">    // Update corpses, etc. This does also shift monsters, but only by</a>
<a name="ln2227">    // a tiny bit.</a>
<a name="ln2228">    update_level(pow * 10);</a>
<a name="ln2229"> </a>
<a name="ln2230">#ifndef USE_TILE_LOCAL</a>
<a name="ln2231">    scaled_delay(1000);</a>
<a name="ln2232">#endif</a>
<a name="ln2233"> </a>
<a name="ln2234">    if (monster *mon = monster_at(old_pos))</a>
<a name="ln2235">    {</a>
<a name="ln2236">        mon-&gt;props[FAKE_BLINK_KEY].get_bool() = true;</a>
<a name="ln2237">        mon-&gt;blink();</a>
<a name="ln2238">        mon-&gt;props.erase(FAKE_BLINK_KEY);</a>
<a name="ln2239">        if (monster *stubborn = monster_at(old_pos))</a>
<a name="ln2240">            monster_teleport(stubborn, true, true);</a>
<a name="ln2241">    }</a>
<a name="ln2242"> </a>
<a name="ln2243">    you.moveto(old_pos);</a>
<a name="ln2244">    you.duration[DUR_TIME_STEP] = 0;</a>
<a name="ln2245"> </a>
<a name="ln2246">    flash_view(UA_PLAYER, 0);</a>
<a name="ln2247">    mpr(&quot;You return to the normal time flow.&quot;);</a>
<a name="ln2248">}</a>
<a name="ln2249"> </a>
<a name="ln2250">bool ashenzari_transfer_knowledge()</a>
<a name="ln2251">{</a>
<a name="ln2252">    if (you.transfer_skill_points &gt; 0 &amp;&amp; !ashenzari_end_transfer())</a>
<a name="ln2253">        return false;</a>
<a name="ln2254"> </a>
<a name="ln2255">    while (true)</a>
<a name="ln2256">    {</a>
<a name="ln2257">        skill_menu(SKMF_RESKILL_FROM);</a>
<a name="ln2258">        if (is_invalid_skill(you.transfer_from_skill))</a>
<a name="ln2259">        {</a>
<a name="ln2260">            redraw_screen();</a>
<a name="ln2261">            return false;</a>
<a name="ln2262">        }</a>
<a name="ln2263"> </a>
<a name="ln2264">        you.transfer_skill_points = skill_transfer_amount(</a>
<a name="ln2265">                                                    you.transfer_from_skill);</a>
<a name="ln2266"> </a>
<a name="ln2267">        skill_menu(SKMF_RESKILL_TO);</a>
<a name="ln2268">        if (is_invalid_skill(you.transfer_to_skill))</a>
<a name="ln2269">        {</a>
<a name="ln2270">            you.transfer_from_skill = SK_NONE;</a>
<a name="ln2271">            you.transfer_skill_points = 0;</a>
<a name="ln2272">            continue;</a>
<a name="ln2273">        }</a>
<a name="ln2274"> </a>
<a name="ln2275">        break;</a>
<a name="ln2276">    }</a>
<a name="ln2277"> </a>
<a name="ln2278">    // We reset the view to force view transfer next time.</a>
<a name="ln2279">    you.skill_menu_view = SKM_NONE;</a>
<a name="ln2280"> </a>
<a name="ln2281">    mprf(&quot;As you forget about %s, you feel ready to understand %s.&quot;,</a>
<a name="ln2282">         skill_name(you.transfer_from_skill),</a>
<a name="ln2283">         skill_name(you.transfer_to_skill));</a>
<a name="ln2284"> </a>
<a name="ln2285">    you.transfer_total_skill_points = you.transfer_skill_points;</a>
<a name="ln2286"> </a>
<a name="ln2287">    redraw_screen();</a>
<a name="ln2288">    return true;</a>
<a name="ln2289">}</a>
<a name="ln2290"> </a>
<a name="ln2291">bool ashenzari_end_transfer(bool finished, bool force)</a>
<a name="ln2292">{</a>
<a name="ln2293">    if (!force &amp;&amp; !finished)</a>
<a name="ln2294">    {</a>
<a name="ln2295">        mprf(&quot;You are currently transferring knowledge from %s to %s.&quot;,</a>
<a name="ln2296">             skill_name(you.transfer_from_skill),</a>
<a name="ln2297">             skill_name(you.transfer_to_skill));</a>
<a name="ln2298">        if (!yesno(&quot;Are you sure you want to cancel the transfer?&quot;, false, 'n'))</a>
<a name="ln2299">            return false;</a>
<a name="ln2300">    }</a>
<a name="ln2301"> </a>
<a name="ln2302">    mprf(&quot;You %s forgetting about %s and learning about %s.&quot;,</a>
<a name="ln2303">         finished ? &quot;have finished&quot; : &quot;stop&quot;,</a>
<a name="ln2304">         skill_name(you.transfer_from_skill),</a>
<a name="ln2305">         skill_name(you.transfer_to_skill));</a>
<a name="ln2306">    you.transfer_from_skill = SK_NONE;</a>
<a name="ln2307">    you.transfer_to_skill = SK_NONE;</a>
<a name="ln2308">    you.transfer_skill_points = 0;</a>
<a name="ln2309">    you.transfer_total_skill_points = 0;</a>
<a name="ln2310">    return true;</a>
<a name="ln2311">}</a>
<a name="ln2312"> </a>
<a name="ln2313">/**</a>
<a name="ln2314"> * Give a prompt to curse an item.</a>
<a name="ln2315"> *</a>
<a name="ln2316"> * This is the core logic behind Ash's Curse Item ability.</a>
<a name="ln2317"> * Player can abort without penalty.</a>
<a name="ln2318"> * Player can curse any cursable item (not just worn ones).</a>
<a name="ln2319"> *</a>
<a name="ln2320"> * @param num_rc Number of remove curse scrolls available.</a>
<a name="ln2321"> * @return       Whether the player cursed anything.</a>
<a name="ln2322"> */</a>
<a name="ln2323">bool ashenzari_curse_item(int num_rc)</a>
<a name="ln2324">{</a>
<a name="ln2325">    ASSERT(num_rc &gt; 0);</a>
<a name="ln2326">    const string prompt_msg = make_stringf(</a>
<a name="ln2327">            &quot;Curse which item? (%d remove curse scroll%s left)&quot;</a>
<a name="ln2328">            &quot; (Esc to abort)&quot;,</a>
<a name="ln2329">            num_rc, num_rc == 1 ? &quot;&quot; : &quot;s&quot;);</a>
<a name="ln2330">    const int item_slot = prompt_invent_item(prompt_msg.c_str(),</a>
<a name="ln2331">                                             menu_type::invlist,</a>
<a name="ln2332">                                             OSEL_CURSABLE, OPER_ANY,</a>
<a name="ln2333">                                             invprompt_flag::escape_only);</a>
<a name="ln2334">    if (prompt_failed(item_slot))</a>
<a name="ln2335">        return false;</a>
<a name="ln2336"> </a>
<a name="ln2337">    item_def&amp; item(you.inv[item_slot]);</a>
<a name="ln2338"> </a>
<a name="ln2339">    if (!item_is_cursable(item))</a>
<a name="ln2340">    {</a>
<a name="ln2341">        mpr(&quot;You can't curse that!&quot;);</a>
<a name="ln2342">        return false;</a>
<a name="ln2343">    }</a>
<a name="ln2344"> </a>
<a name="ln2345">    do_curse_item(item, false);</a>
<a name="ln2346">    learned_something_new(HINT_YOU_CURSED);</a>
<a name="ln2347">    return true;</a>
<a name="ln2348">}</a>
<a name="ln2349"> </a>
<a name="ln2350">bool can_convert_to_beogh()</a>
<a name="ln2351">{</a>
<a name="ln2352">    if (silenced(you.pos()))</a>
<a name="ln2353">        return false;</a>
<a name="ln2354"> </a>
<a name="ln2355">    for (monster* m : monster_near_iterator(you.pos(), LOS_NO_TRANS))</a>
<a name="ln2356">        if (mons_allows_beogh_now(*m))</a>
<a name="ln2357">            return true;</a>
<a name="ln2358"> </a>
<a name="ln2359">    return false;</a>
<a name="ln2360">}</a>
<a name="ln2361"> </a>
<a name="ln2362">void spare_beogh_convert()</a>
<a name="ln2363">{</a>
<a name="ln2364">    if (you.one_time_ability_used[GOD_BEOGH])</a>
<a name="ln2365">    {</a>
<a name="ln2366">        // You still get to convert, but orcs will remain hostile.</a>
<a name="ln2367">        mprf(MSGCH_TALK, &quot;%s&quot;, getSpeakString(&quot;orc_priest_apostate&quot;).c_str());</a>
<a name="ln2368">        return;</a>
<a name="ln2369">    }</a>
<a name="ln2370"> </a>
<a name="ln2371">    set&lt;mid_t&gt; witnesses;</a>
<a name="ln2372"> </a>
<a name="ln2373">    you.religion = GOD_NO_GOD;</a>
<a name="ln2374">    for (radius_iterator ri(you.pos(), LOS_DEFAULT); ri; ++ri)</a>
<a name="ln2375">    {</a>
<a name="ln2376">        const monster *mon = monster_at(*ri);</a>
<a name="ln2377">        // An invis player converting is ok, for simplicity.</a>
<a name="ln2378">        if (!mon || !cell_see_cell(you.pos(), *ri, LOS_DEFAULT))</a>
<a name="ln2379">            continue;</a>
<a name="ln2380">        if (mon-&gt;attitude != ATT_HOSTILE)</a>
<a name="ln2381">            continue;</a>
<a name="ln2382">        if (mons_genus(mon-&gt;type) != MONS_ORC)</a>
<a name="ln2383">            continue;</a>
<a name="ln2384">        witnesses.insert(mon-&gt;mid);</a>
<a name="ln2385"> </a>
<a name="ln2386">        // Anyone who has seen the priest perform the ceremony will spare you</a>
<a name="ln2387">        // as well.</a>
<a name="ln2388">        if (mons_allows_beogh(*mon))</a>
<a name="ln2389">        {</a>
<a name="ln2390">            for (radius_iterator pi(you.pos(), LOS_DEFAULT); pi; ++pi)</a>
<a name="ln2391">            {</a>
<a name="ln2392">                const monster *orc = monster_at(*pi);</a>
<a name="ln2393">                if (!orc || !cell_see_cell(*ri, *pi, LOS_DEFAULT))</a>
<a name="ln2394">                    continue;</a>
<a name="ln2395">                if (mons_genus(orc-&gt;type) != MONS_ORC)</a>
<a name="ln2396">                    continue;</a>
<a name="ln2397">                if (mon-&gt;attitude != ATT_HOSTILE)</a>
<a name="ln2398">                    continue;</a>
<a name="ln2399">                witnesses.insert(orc-&gt;mid);</a>
<a name="ln2400">            }</a>
<a name="ln2401">        }</a>
<a name="ln2402">    }</a>
<a name="ln2403"> </a>
<a name="ln2404">    int witc = 0;</a>
<a name="ln2405">    for (auto wit : witnesses)</a>
<a name="ln2406">    {</a>
<a name="ln2407">        monster *orc = monster_by_mid(wit);</a>
<a name="ln2408">        if (!orc || !orc-&gt;alive())</a>
<a name="ln2409">            continue;</a>
<a name="ln2410"> </a>
<a name="ln2411">        ++witc;</a>
<a name="ln2412">        orc-&gt;del_ench(ENCH_CHARM);</a>
<a name="ln2413">        mons_pacify(*orc, ATT_GOOD_NEUTRAL, true);</a>
<a name="ln2414">    }</a>
<a name="ln2415"> </a>
<a name="ln2416">    you.religion = GOD_BEOGH;</a>
<a name="ln2417">    you.one_time_ability_used.set(GOD_BEOGH);</a>
<a name="ln2418"> </a>
<a name="ln2419">    if (witc == 1)</a>
<a name="ln2420">        mpr(&quot;The priest welcomes you and lets you live.&quot;);</a>
<a name="ln2421">    else</a>
<a name="ln2422">    {</a>
<a name="ln2423">        mpr(&quot;With a roar of approval, the orcs welcome you as one of their own,&quot;</a>
<a name="ln2424">            &quot; and spare your life.&quot;);</a>
<a name="ln2425">    }</a>
<a name="ln2426">}</a>
<a name="ln2427"> </a>
<a name="ln2428">bool dithmenos_shadow_step()</a>
<a name="ln2429">{</a>
<a name="ln2430">    // You can shadow-step anywhere within your umbra.</a>
<a name="ln2431">    ASSERT(you.umbra_radius() &gt; -1);</a>
<a name="ln2432">    const int range = you.umbra_radius();</a>
<a name="ln2433"> </a>
<a name="ln2434">    targeter_shadow_step tgt(&amp;you, you.umbra_radius());</a>
<a name="ln2435">    direction_chooser_args args;</a>
<a name="ln2436">    args.hitfunc = &amp;tgt;</a>
<a name="ln2437">    args.restricts = DIR_SHADOW_STEP;</a>
<a name="ln2438">    args.mode = TARG_HOSTILE;</a>
<a name="ln2439">    args.range = range;</a>
<a name="ln2440">    args.just_looking = false;</a>
<a name="ln2441">    args.needs_path = false;</a>
<a name="ln2442">    args.top_prompt = &quot;Aiming: &lt;white&gt;Shadow Step&lt;/white&gt;&quot;;</a>
<a name="ln2443">    dist sdirect;</a>
<a name="ln2444">    direction(sdirect, args);</a>
<a name="ln2445">    if (!sdirect.isValid || tgt.landing_site.origin())</a>
<a name="ln2446">        return false;</a>
<a name="ln2447"> </a>
<a name="ln2448">    // Check for hazards.</a>
<a name="ln2449">    bool zot_trap_prompted = false,</a>
<a name="ln2450">         trap_prompted = false,</a>
<a name="ln2451">         exclusion_prompted = false,</a>
<a name="ln2452">         cloud_prompted = false,</a>
<a name="ln2453">         terrain_prompted = false;</a>
<a name="ln2454"> </a>
<a name="ln2455">    for (auto site : tgt.additional_sites)</a>
<a name="ln2456">    {</a>
<a name="ln2457">        if (!cloud_prompted</a>
<a name="ln2458">            &amp;&amp; !check_moveto_cloud(site, &quot;shadow step&quot;, &amp;cloud_prompted))</a>
<a name="ln2459">        {</a>
<a name="ln2460">            return false;</a>
<a name="ln2461">        }</a>
<a name="ln2462"> </a>
<a name="ln2463">        if (!zot_trap_prompted)</a>
<a name="ln2464">        {</a>
<a name="ln2465">            trap_def* trap = trap_at(site);</a>
<a name="ln2466">            if (trap &amp;&amp; trap-&gt;type == TRAP_ZOT)</a>
<a name="ln2467">            {</a>
<a name="ln2468">                if (!check_moveto_trap(site, &quot;shadow step&quot;,</a>
<a name="ln2469">                                       &amp;trap_prompted))</a>
<a name="ln2470">                {</a>
<a name="ln2471">                    you.turn_is_over = false;</a>
<a name="ln2472">                    return false;</a>
<a name="ln2473">                }</a>
<a name="ln2474">                zot_trap_prompted = true;</a>
<a name="ln2475">            }</a>
<a name="ln2476">            else if (!trap_prompted</a>
<a name="ln2477">                     &amp;&amp; !check_moveto_trap(site, &quot;shadow step&quot;,</a>
<a name="ln2478">                                           &amp;trap_prompted))</a>
<a name="ln2479">            {</a>
<a name="ln2480">                you.turn_is_over = false;</a>
<a name="ln2481">                return false;</a>
<a name="ln2482">            }</a>
<a name="ln2483">        }</a>
<a name="ln2484"> </a>
<a name="ln2485">        if (!exclusion_prompted</a>
<a name="ln2486">            &amp;&amp; !check_moveto_exclusion(site, &quot;shadow step&quot;,</a>
<a name="ln2487">                                       &amp;exclusion_prompted))</a>
<a name="ln2488">        {</a>
<a name="ln2489">            return false;</a>
<a name="ln2490">        }</a>
<a name="ln2491"> </a>
<a name="ln2492">        if (!terrain_prompted</a>
<a name="ln2493">            &amp;&amp; !check_moveto_terrain(site, &quot;shadow step&quot;, &quot;&quot;,</a>
<a name="ln2494">                                     &amp;terrain_prompted))</a>
<a name="ln2495">        {</a>
<a name="ln2496">            return false;</a>
<a name="ln2497">        }</a>
<a name="ln2498">    }</a>
<a name="ln2499"> </a>
<a name="ln2500">    const coord_def old_pos = you.pos();</a>
<a name="ln2501">    // XXX: This only ever fails if something's on the landing site;</a>
<a name="ln2502">    // perhaps this should be handled more gracefully.</a>
<a name="ln2503">    if (!you.move_to_pos(tgt.landing_site))</a>
<a name="ln2504">    {</a>
<a name="ln2505">        mpr(&quot;Something blocks your shadow step.&quot;);</a>
<a name="ln2506">        return true;</a>
<a name="ln2507">    }</a>
<a name="ln2508"> </a>
<a name="ln2509">    const actor *victim = actor_at(sdirect.target);</a>
<a name="ln2510">    mprf(&quot;You step into %s shadow.&quot;,</a>
<a name="ln2511">         apostrophise(victim-&gt;name(DESC_THE)).c_str());</a>
<a name="ln2512">    // Using 'stepped = true' here because it's Shadow *Step*.</a>
<a name="ln2513">    // This helps to evade splash upon landing on water.</a>
<a name="ln2514">    moveto_location_effects(grd(old_pos), true, old_pos);</a>
<a name="ln2515"> </a>
<a name="ln2516">    return true;</a>
<a name="ln2517">}</a>
<a name="ln2518"> </a>
<a name="ln2519">static potion_type _gozag_potion_list[][4] =</a>
<a name="ln2520">{</a>
<a name="ln2521">    { POT_HEAL_WOUNDS, NUM_POTIONS, NUM_POTIONS, NUM_POTIONS },</a>
<a name="ln2522">    { POT_HEAL_WOUNDS, POT_CURING, NUM_POTIONS, NUM_POTIONS },</a>
<a name="ln2523">    { POT_HEAL_WOUNDS, POT_MAGIC, NUM_POTIONS, NUM_POTIONS, },</a>
<a name="ln2524">    { POT_CURING, POT_MAGIC, NUM_POTIONS, NUM_POTIONS },</a>
<a name="ln2525">    { POT_HEAL_WOUNDS, POT_BERSERK_RAGE, NUM_POTIONS, NUM_POTIONS },</a>
<a name="ln2526">    { POT_HASTE, POT_HEAL_WOUNDS, NUM_POTIONS, NUM_POTIONS },</a>
<a name="ln2527">    { POT_HASTE, POT_BRILLIANCE, NUM_POTIONS, NUM_POTIONS },</a>
<a name="ln2528">    { POT_HASTE, POT_FLIGHT, NUM_POTIONS, NUM_POTIONS },</a>
<a name="ln2529">    { POT_HASTE, POT_RESISTANCE, NUM_POTIONS, NUM_POTIONS },</a>
<a name="ln2530">    { POT_MIGHT, POT_STABBING, NUM_POTIONS, NUM_POTIONS },</a>
<a name="ln2531">    { POT_RESISTANCE, POT_FLIGHT, NUM_POTIONS, NUM_POTIONS },</a>
<a name="ln2532">    { POT_INVISIBILITY, POT_STABBING, NUM_POTIONS , NUM_POTIONS },</a>
<a name="ln2533">    { POT_INVISIBILITY, POT_STABBING, POT_MIGHT, NUM_POTIONS },</a>
<a name="ln2534">    { POT_HEAL_WOUNDS, POT_CURING, POT_MAGIC, NUM_POTIONS },</a>
<a name="ln2535">    { POT_HEAL_WOUNDS, POT_CURING, POT_BERSERK_RAGE, NUM_POTIONS },</a>
<a name="ln2536">    { POT_MIGHT, POT_BRILLIANCE, NUM_POTIONS, NUM_POTIONS },</a>
<a name="ln2537">    { POT_FLIGHT, POT_STABBING, POT_INVISIBILITY, NUM_POTIONS },</a>
<a name="ln2538">    { POT_RESISTANCE, POT_MIGHT, POT_STABBING, NUM_POTIONS },</a>
<a name="ln2539">    { POT_RESISTANCE, POT_MIGHT, POT_HASTE, NUM_POTIONS },</a>
<a name="ln2540">    { POT_RESISTANCE, POT_INVISIBILITY, POT_STABBING, NUM_POTIONS },</a>
<a name="ln2541">};</a>
<a name="ln2542"> </a>
<a name="ln2543">static void _gozag_add_potions(CrawlVector &amp;vec, potion_type *which)</a>
<a name="ln2544">{</a>
<a name="ln2545">    for (; *which != NUM_POTIONS; which++)</a>
<a name="ln2546">    {</a>
<a name="ln2547">        // Even god powers cannot override racial berserk/haste restrictions.</a>
<a name="ln2548">        if (*which == POT_BERSERK_RAGE</a>
<a name="ln2549">            &amp;&amp; !you.can_go_berserk(true, false, true, nullptr, false))</a>
<a name="ln2550">        {</a>
<a name="ln2551">            continue;</a>
<a name="ln2552">        }</a>
<a name="ln2553">        if (*which == POT_HASTE &amp;&amp; you.stasis())</a>
<a name="ln2554">            continue;</a>
<a name="ln2555">        // Don't add potions which are already in the list</a>
<a name="ln2556">        bool dup = false;</a>
<a name="ln2557">        for (unsigned int i = 0; i &lt; vec.size(); i++)</a>
<a name="ln2558">            if (vec[i].get_int() == *which)</a>
<a name="ln2559">            {</a>
<a name="ln2560">                dup = true;</a>
<a name="ln2561">                break;</a>
<a name="ln2562">            }</a>
<a name="ln2563">        if (!dup)</a>
<a name="ln2564">            vec.push_back(*which);</a>
<a name="ln2565">    }</a>
<a name="ln2566">}</a>
<a name="ln2567"> </a>
<a name="ln2568">#define ADD_POTIONS(a,b) _gozag_add_potions(a, b[random2(ARRAYSZ(b))])</a>
<a name="ln2569"> </a>
<a name="ln2570">int gozag_potion_price()</a>
<a name="ln2571">{</a>
<a name="ln2572">    if (!you.attribute[ATTR_GOZAG_FIRST_POTION])</a>
<a name="ln2573">        return 0;</a>
<a name="ln2574"> </a>
<a name="ln2575">    return GOZAG_POTION_PETITION_AMOUNT;</a>
<a name="ln2576">}</a>
<a name="ln2577"> </a>
<a name="ln2578">bool gozag_setup_potion_petition(bool quiet)</a>
<a name="ln2579">{</a>
<a name="ln2580">    const int gold_min = gozag_potion_price();</a>
<a name="ln2581">    if (you.gold &lt; gold_min)</a>
<a name="ln2582">    {</a>
<a name="ln2583">        if (!quiet)</a>
<a name="ln2584">        {</a>
<a name="ln2585">            mprf(&quot;You need at least %d gold to purchase potions right now!&quot;,</a>
<a name="ln2586">                 gold_min);</a>
<a name="ln2587">        }</a>
<a name="ln2588">        return false;</a>
<a name="ln2589">    }</a>
<a name="ln2590"> </a>
<a name="ln2591">    return true;</a>
<a name="ln2592">}</a>
<a name="ln2593"> </a>
<a name="ln2594">bool gozag_potion_petition()</a>
<a name="ln2595">{</a>
<a name="ln2596">    CrawlVector *pots[GOZAG_MAX_POTIONS];</a>
<a name="ln2597">    int prices[GOZAG_MAX_POTIONS];</a>
<a name="ln2598"> </a>
<a name="ln2599">    item_def dummy;</a>
<a name="ln2600">    dummy.base_type = OBJ_POTIONS;</a>
<a name="ln2601">    dummy.quantity = 1;</a>
<a name="ln2602"> </a>
<a name="ln2603">    if (!you.props.exists(make_stringf(GOZAG_POTIONS_KEY, 0)))</a>
<a name="ln2604">    {</a>
<a name="ln2605">        bool affordable_potions = false;</a>
<a name="ln2606">        while (!affordable_potions)</a>
<a name="ln2607">        {</a>
<a name="ln2608">            for (int i = 0; i &lt; GOZAG_MAX_POTIONS; i++)</a>
<a name="ln2609">            {</a>
<a name="ln2610">                prices[i] = 0;</a>
<a name="ln2611">                int multiplier = random_range(20, 30); // arbitrary</a>
<a name="ln2612"> </a>
<a name="ln2613">                if (!you.attribute[ATTR_GOZAG_FIRST_POTION])</a>
<a name="ln2614">                    multiplier = 0;</a>
<a name="ln2615"> </a>
<a name="ln2616">                string key = make_stringf(GOZAG_POTIONS_KEY, i);</a>
<a name="ln2617">                you.props.erase(key);</a>
<a name="ln2618">                you.props[key].new_vector(SV_INT, SFLAG_CONST_TYPE);</a>
<a name="ln2619">                pots[i] = &amp;you.props[key].get_vector();</a>
<a name="ln2620"> </a>
<a name="ln2621">                ADD_POTIONS(*pots[i], _gozag_potion_list);</a>
<a name="ln2622">                if (coinflip())</a>
<a name="ln2623">                    ADD_POTIONS(*pots[i], _gozag_potion_list);</a>
<a name="ln2624"> </a>
<a name="ln2625">                for (const CrawlStoreValue&amp; store : *pots[i])</a>
<a name="ln2626">                {</a>
<a name="ln2627">                    dummy.sub_type = store.get_int();</a>
<a name="ln2628">                    prices[i] += item_value(dummy, true);</a>
<a name="ln2629">                    dprf(&quot;%d&quot;, item_value(dummy, true));</a>
<a name="ln2630">                }</a>
<a name="ln2631">                dprf(&quot;pre: %d&quot;, prices[i]);</a>
<a name="ln2632">                prices[i] *= multiplier;</a>
<a name="ln2633">                dprf(&quot;mid: %d&quot;, prices[i]);</a>
<a name="ln2634">                prices[i] /= 10;</a>
<a name="ln2635">                dprf(&quot;post: %d&quot;, prices[i]);</a>
<a name="ln2636">                key = make_stringf(GOZAG_PRICE_KEY, i);</a>
<a name="ln2637">                you.props[key].get_int() = prices[i];</a>
<a name="ln2638"> </a>
<a name="ln2639">                if (prices[i] &lt;= gozag_potion_price())</a>
<a name="ln2640">                    affordable_potions = true;</a>
<a name="ln2641">            }</a>
<a name="ln2642">        }</a>
<a name="ln2643">    }</a>
<a name="ln2644">    else</a>
<a name="ln2645">    {</a>
<a name="ln2646">        for (int i = 0; i &lt; GOZAG_MAX_POTIONS; i++)</a>
<a name="ln2647">        {</a>
<a name="ln2648">            string key = make_stringf(GOZAG_POTIONS_KEY, i);</a>
<a name="ln2649">            pots[i] = &amp;you.props[key].get_vector();</a>
<a name="ln2650">            key = make_stringf(GOZAG_PRICE_KEY, i);</a>
<a name="ln2651">            prices[i] = you.props[key].get_int();</a>
<a name="ln2652">        }</a>
<a name="ln2653">    }</a>
<a name="ln2654"> </a>
<a name="ln2655">    int keyin = 0;</a>
<a name="ln2656"> </a>
<a name="ln2657">    while (true)</a>
<a name="ln2658">    {</a>
<a name="ln2659">        if (crawl_state.seen_hups)</a>
<a name="ln2660">            return false;</a>
<a name="ln2661"> </a>
<a name="ln2662">        clear_messages();</a>
<a name="ln2663">        for (int i = 0; i &lt; GOZAG_MAX_POTIONS; i++)</a>
<a name="ln2664">        {</a>
<a name="ln2665">            string line = make_stringf(&quot;  [%c] - %d gold - &quot;, i + 'a',</a>
<a name="ln2666">                                       prices[i]);</a>
<a name="ln2667">            vector&lt;string&gt; pot_names;</a>
<a name="ln2668">            for (const CrawlStoreValue&amp; store : *pots[i])</a>
<a name="ln2669">                pot_names.emplace_back(potion_type_name(store.get_int()));</a>
<a name="ln2670">            line += comma_separated_line(pot_names.begin(), pot_names.end());</a>
<a name="ln2671">            mpr_nojoin(MSGCH_PLAIN, line);</a>
<a name="ln2672">        }</a>
<a name="ln2673">        mprf(MSGCH_PROMPT, &quot;Purchase which effect?&quot;);</a>
<a name="ln2674">        keyin = toalower(get_ch()) - 'a';</a>
<a name="ln2675">        if (keyin &lt; 0 || keyin &gt; GOZAG_MAX_POTIONS - 1)</a>
<a name="ln2676">            continue;</a>
<a name="ln2677"> </a>
<a name="ln2678">        if (you.gold &lt; prices[keyin])</a>
<a name="ln2679">        {</a>
<a name="ln2680">            mpr(&quot;You don't have enough gold for that!&quot;);</a>
<a name="ln2681">            more();</a>
<a name="ln2682">            continue;</a>
<a name="ln2683">        }</a>
<a name="ln2684"> </a>
<a name="ln2685">        break;</a>
<a name="ln2686">    }</a>
<a name="ln2687"> </a>
<a name="ln2688">    ASSERT(you.gold &gt;= prices[keyin]);</a>
<a name="ln2689">    you.del_gold(prices[keyin]);</a>
<a name="ln2690">    you.attribute[ATTR_GOZAG_GOLD_USED] += prices[keyin];</a>
<a name="ln2691"> </a>
<a name="ln2692">    for (auto pot : *pots[keyin])</a>
<a name="ln2693">        potionlike_effect(static_cast&lt;potion_type&gt;(pot.get_int()), 40);</a>
<a name="ln2694"> </a>
<a name="ln2695">    if (!you.attribute[ATTR_GOZAG_FIRST_POTION])</a>
<a name="ln2696">        you.attribute[ATTR_GOZAG_FIRST_POTION] = 1;</a>
<a name="ln2697"> </a>
<a name="ln2698">    for (int i = 0; i &lt; GOZAG_MAX_POTIONS; i++)</a>
<a name="ln2699">    {</a>
<a name="ln2700">        string key = make_stringf(GOZAG_POTIONS_KEY, i);</a>
<a name="ln2701">        you.props.erase(key);</a>
<a name="ln2702">        key = make_stringf(GOZAG_PRICE_KEY, i);</a>
<a name="ln2703">        you.props.erase(key);</a>
<a name="ln2704">    }</a>
<a name="ln2705"> </a>
<a name="ln2706">    return true;</a>
<a name="ln2707">}</a>
<a name="ln2708"> </a>
<a name="ln2709">/**</a>
<a name="ln2710"> * How many shop types are offered with each use of Call Merchant?</a>
<a name="ln2711"> */</a>
<a name="ln2712">static int _gozag_max_shops()</a>
<a name="ln2713">{</a>
<a name="ln2714">    const int max_non_food_shops = 3;</a>
<a name="ln2715"> </a>
<a name="ln2716">    // add a food shop if you can eat (non-mu/dj)</a>
<a name="ln2717">    if (!you_foodless(false))</a>
<a name="ln2718">        return max_non_food_shops + 1;</a>
<a name="ln2719">    return max_non_food_shops;</a>
<a name="ln2720">}</a>
<a name="ln2721"> </a>
<a name="ln2722">/**</a>
<a name="ln2723"> * The price to order a merchant from Gozag. Doesn't depend on the shop's</a>
<a name="ln2724"> * type or contents. The maximum possible price is used as the minimum amount</a>
<a name="ln2725"> * of gold you need to use the ability.</a>
<a name="ln2726"> */</a>
<a name="ln2727">int gozag_price_for_shop(bool max)</a>
<a name="ln2728">{</a>
<a name="ln2729">    // This value probably needs tweaking.</a>
<a name="ln2730">    const int max_base = 800;</a>
<a name="ln2731">    const int base = max ? max_base : random_range(max_base/2, max_base);</a>
<a name="ln2732">    const int price = base</a>
<a name="ln2733">                      * (GOZAG_SHOP_BASE_MULTIPLIER</a>
<a name="ln2734">                         + GOZAG_SHOP_MOD_MULTIPLIER</a>
<a name="ln2735">                           * you.attribute[ATTR_GOZAG_SHOPS])</a>
<a name="ln2736">                      / GOZAG_SHOP_BASE_MULTIPLIER;</a>
<a name="ln2737">    return price;</a>
<a name="ln2738">}</a>
<a name="ln2739"> </a>
<a name="ln2740">bool gozag_setup_call_merchant(bool quiet)</a>
<a name="ln2741">{</a>
<a name="ln2742">    const int gold_min = gozag_price_for_shop(true);</a>
<a name="ln2743">    if (you.gold &lt; gold_min)</a>
<a name="ln2744">    {</a>
<a name="ln2745">        if (!quiet)</a>
<a name="ln2746">        {</a>
<a name="ln2747">            mprf(&quot;You currently need %d gold to open negotiations with a &quot;</a>
<a name="ln2748">                 &quot;merchant.&quot;, gold_min);</a>
<a name="ln2749">        }</a>
<a name="ln2750">        return false;</a>
<a name="ln2751">    }</a>
<a name="ln2752">    if (!is_connected_branch(level_id::current().branch))</a>
<a name="ln2753">    {</a>
<a name="ln2754">        if (!quiet)</a>
<a name="ln2755">        {</a>
<a name="ln2756">            mprf(&quot;No merchants are willing to come to this location.&quot;);</a>
<a name="ln2757">            return false;</a>
<a name="ln2758">        }</a>
<a name="ln2759">    }</a>
<a name="ln2760">    if (grd(you.pos()) != DNGN_FLOOR)</a>
<a name="ln2761">    {</a>
<a name="ln2762">        if (!quiet)</a>
<a name="ln2763">        {</a>
<a name="ln2764">            mprf(&quot;You need to be standing on open floor to call a merchant.&quot;);</a>
<a name="ln2765">            return false;</a>
<a name="ln2766">        }</a>
<a name="ln2767">    }</a>
<a name="ln2768"> </a>
<a name="ln2769">    return true;</a>
<a name="ln2770">}</a>
<a name="ln2771"> </a>
<a name="ln2772">/**</a>
<a name="ln2773"> * Is the given index within the valid range for gozag shop offers?</a>
<a name="ln2774"> */</a>
<a name="ln2775">static bool _gozag_valid_shop_index(int index)</a>
<a name="ln2776">{</a>
<a name="ln2777">    return index &gt;= 0 &amp;&amp; index &lt; _gozag_max_shops();</a>
<a name="ln2778">}</a>
<a name="ln2779"> </a>
<a name="ln2780">/**</a>
<a name="ln2781"> * What is the type of shop that gozag is offering at the given index?</a>
<a name="ln2782"> */</a>
<a name="ln2783">static shop_type _gozag_shop_type(int index)</a>
<a name="ln2784">{</a>
<a name="ln2785">    ASSERT(_gozag_valid_shop_index(index));</a>
<a name="ln2786">    const int type =</a>
<a name="ln2787">        you.props[make_stringf(GOZAG_SHOP_TYPE_KEY, index)].get_int();</a>
<a name="ln2788">    return static_cast&lt;shop_type&gt;(type);</a>
<a name="ln2789">}</a>
<a name="ln2790"> </a>
<a name="ln2791">/**</a>
<a name="ln2792"> * What is the price of calling the shop that gozag is offering at the given</a>
<a name="ln2793"> * index?</a>
<a name="ln2794"> */</a>
<a name="ln2795">static int _gozag_shop_price(int index)</a>
<a name="ln2796">{</a>
<a name="ln2797">    ASSERT(_gozag_valid_shop_index(index));</a>
<a name="ln2798"> </a>
<a name="ln2799">    return you.props[make_stringf(GOZAG_SHOP_COST_KEY, index)].get_int();</a>
<a name="ln2800">}</a>
<a name="ln2801"> </a>
<a name="ln2802">/**</a>
<a name="ln2803"> * Initialize the set of shops currently offered to the player through Call</a>
<a name="ln2804"> * Merchant.</a>
<a name="ln2805"> *</a>
<a name="ln2806"> * @param index       The index of the shop offer to be defined.</a>
<a name="ln2807"> * @param valid_shops Vector of acceptable shop types based on the player and</a>
<a name="ln2808"> *                    previous choices for this merchant call.</a>
<a name="ln2809">*/</a>
<a name="ln2810">static void _setup_gozag_shop(int index, vector&lt;shop_type&gt; &amp;valid_shops)</a>
<a name="ln2811">{</a>
<a name="ln2812">    ASSERT(!you.props.exists(make_stringf(GOZAG_SHOPKEEPER_NAME_KEY, index)));</a>
<a name="ln2813"> </a>
<a name="ln2814">    shop_type type = NUM_SHOPS;</a>
<a name="ln2815">    if (index == 0 &amp;&amp; !you_foodless(false))</a>
<a name="ln2816">        type = SHOP_FOOD;</a>
<a name="ln2817">    else</a>
<a name="ln2818">    {</a>
<a name="ln2819">        int choice = random2(valid_shops.size());</a>
<a name="ln2820">        type = valid_shops[choice];</a>
<a name="ln2821">        // Don't choose this shop type again for this merchant call.</a>
<a name="ln2822">        valid_shops.erase(valid_shops.begin() + choice);</a>
<a name="ln2823">    }</a>
<a name="ln2824">    you.props[make_stringf(GOZAG_SHOP_TYPE_KEY, index)].get_int() = type;</a>
<a name="ln2825"> </a>
<a name="ln2826">    you.props[make_stringf(GOZAG_SHOPKEEPER_NAME_KEY, index)].get_string()</a>
<a name="ln2827">                                    = make_name();</a>
<a name="ln2828"> </a>
<a name="ln2829">    const bool need_suffix = type != SHOP_GENERAL</a>
<a name="ln2830">                             &amp;&amp; type != SHOP_GENERAL_ANTIQUE</a>
<a name="ln2831">                             &amp;&amp; type != SHOP_DISTILLERY;</a>
<a name="ln2832">    you.props[make_stringf(GOZAG_SHOP_SUFFIX_KEY, index)].get_string()</a>
<a name="ln2833">                                    = need_suffix</a>
<a name="ln2834">                                      ? random_choose(&quot;Shoppe&quot;, &quot;Boutique&quot;,</a>
<a name="ln2835">                                                      &quot;Emporium&quot;, &quot;Shop&quot;)</a>
<a name="ln2836">                                      : &quot;&quot;;</a>
<a name="ln2837"> </a>
<a name="ln2838">    you.props[make_stringf(GOZAG_SHOP_COST_KEY, index)].get_int()</a>
<a name="ln2839">        = gozag_price_for_shop();</a>
<a name="ln2840">}</a>
<a name="ln2841"> </a>
<a name="ln2842">/**</a>
<a name="ln2843"> * If Gozag's version of a given shop type has a special name, what is it?</a>
<a name="ln2844"> *</a>
<a name="ln2845"> * @param type      The type of shop in question.</a>
<a name="ln2846"> * @return          A special name for the shop (replacing its type-name) if</a>
<a name="ln2847"> *                  appropriate, or an empty string otherwise.</a>
<a name="ln2848"> */</a>
<a name="ln2849">static string _gozag_special_shop_name(shop_type type)</a>
<a name="ln2850">{</a>
<a name="ln2851">    if (type == SHOP_FOOD)</a>
<a name="ln2852">    {</a>
<a name="ln2853">        if (you.species == SP_GHOUL)</a>
<a name="ln2854">            return &quot;Carrion&quot;; // yum!</a>
<a name="ln2855">    }</a>
<a name="ln2856"> </a>
<a name="ln2857">    return &quot;&quot;;</a>
<a name="ln2858">}</a>
<a name="ln2859"> </a>
<a name="ln2860">/**</a>
<a name="ln2861"> * Build a string describing the name, price &amp; type of the shop being offered</a>
<a name="ln2862"> * at the given index.</a>
<a name="ln2863"> *</a>
<a name="ln2864"> * @param index     The index of the shop to be described.</a>
<a name="ln2865"> * @return          The shop description.</a>
<a name="ln2866"> *                  E.g. &quot;[a]   973 gold - Cranius' Magic Scroll Boutique&quot;</a>
<a name="ln2867"> */</a>
<a name="ln2868">static string _describe_gozag_shop(int index)</a>
<a name="ln2869">{</a>
<a name="ln2870">    const int cost = _gozag_shop_price(index);</a>
<a name="ln2871"> </a>
<a name="ln2872">    const char offer_letter = 'a' + index;</a>
<a name="ln2873">    const string shop_name =</a>
<a name="ln2874">        apostrophise(you.props[make_stringf(GOZAG_SHOPKEEPER_NAME_KEY,</a>
<a name="ln2875">                                            index)].get_string());</a>
<a name="ln2876">    const shop_type type = _gozag_shop_type(index);</a>
<a name="ln2877">    const string special_name = _gozag_special_shop_name(type);</a>
<a name="ln2878">    const string type_name = !special_name.empty() ?</a>
<a name="ln2879">                                special_name :</a>
<a name="ln2880">                                shop_type_name(type);</a>
<a name="ln2881">    const string suffix =</a>
<a name="ln2882">        you.props[make_stringf(GOZAG_SHOP_SUFFIX_KEY, index)].get_string();</a>
<a name="ln2883"> </a>
<a name="ln2884">    return make_stringf(&quot;  [%c] %5d gold - %s %s %s&quot;,</a>
<a name="ln2885">                        offer_letter,</a>
<a name="ln2886">                        cost,</a>
<a name="ln2887">                        shop_name.c_str(),</a>
<a name="ln2888">                        type_name.c_str(),</a>
<a name="ln2889">                        suffix.c_str());</a>
<a name="ln2890">}</a>
<a name="ln2891"> </a>
<a name="ln2892">/**</a>
<a name="ln2893"> * Let the player choose from the currently available merchants to call.</a>
<a name="ln2894"> *</a>
<a name="ln2895"> * @param   The index of the chosen shop; -1 if none was chosen (due to e.g.</a>
<a name="ln2896"> *          a seen_hup).</a>
<a name="ln2897"> */</a>
<a name="ln2898">static int _gozag_choose_shop()</a>
<a name="ln2899">{</a>
<a name="ln2900">    if (crawl_state.seen_hups)</a>
<a name="ln2901">        return -1;</a>
<a name="ln2902"> </a>
<a name="ln2903">    clear_messages();</a>
<a name="ln2904">    for (int i = 0; i &lt; _gozag_max_shops(); i++)</a>
<a name="ln2905">        mpr_nojoin(MSGCH_PLAIN, _describe_gozag_shop(i).c_str());</a>
<a name="ln2906"> </a>
<a name="ln2907">    mprf(MSGCH_PROMPT, &quot;Fund which merchant?&quot;);</a>
<a name="ln2908">    const int shop_index = toalower(get_ch()) - 'a';</a>
<a name="ln2909">    if (shop_index &lt; 0 || shop_index &gt; _gozag_max_shops() - 1)</a>
<a name="ln2910">        return _gozag_choose_shop(); // tail recurse</a>
<a name="ln2911"> </a>
<a name="ln2912">    if (you.gold &lt; _gozag_shop_price(shop_index))</a>
<a name="ln2913">    {</a>
<a name="ln2914">        mpr(&quot;You don't have enough gold to fund that merchant!&quot;);</a>
<a name="ln2915">        more();</a>
<a name="ln2916">        return _gozag_choose_shop(); // tail recurse</a>
<a name="ln2917">    }</a>
<a name="ln2918"> </a>
<a name="ln2919">    return shop_index;</a>
<a name="ln2920">}</a>
<a name="ln2921"> </a>
<a name="ln2922">/**</a>
<a name="ln2923"> * Make a vault spec for the gozag shop offer at the given index.</a>
<a name="ln2924"> */</a>
<a name="ln2925">static string _gozag_shop_spec(int index)</a>
<a name="ln2926">{</a>
<a name="ln2927">    const shop_type type = _gozag_shop_type(index);</a>
<a name="ln2928">    const string name =</a>
<a name="ln2929">        you.props[make_stringf(GOZAG_SHOPKEEPER_NAME_KEY, index)];</a>
<a name="ln2930"> </a>
<a name="ln2931">    string suffix = replace_all(</a>
<a name="ln2932">                                you.props[make_stringf(GOZAG_SHOP_SUFFIX_KEY,</a>
<a name="ln2933">                                                       index)]</a>
<a name="ln2934">                                .get_string(), &quot; &quot;, &quot;_&quot;);</a>
<a name="ln2935">    if (!suffix.empty())</a>
<a name="ln2936">        suffix = &quot; suffix:&quot; + suffix;</a>
<a name="ln2937"> </a>
<a name="ln2938">    string spec_type = _gozag_special_shop_name(type);</a>
<a name="ln2939">    if (!spec_type.empty())</a>
<a name="ln2940">        spec_type = &quot; type:&quot; + spec_type;</a>
<a name="ln2941"> </a>
<a name="ln2942">    return make_stringf(&quot;%s shop name:%s%s%s gozag&quot;,</a>
<a name="ln2943">                        shoptype_to_str(type),</a>
<a name="ln2944">                        replace_all(name, &quot; &quot;, &quot;_&quot;).c_str(),</a>
<a name="ln2945">                        suffix.c_str(),</a>
<a name="ln2946">                        spec_type.c_str());</a>
<a name="ln2947"> </a>
<a name="ln2948">}</a>
<a name="ln2949"> </a>
<a name="ln2950">/**</a>
<a name="ln2951"> * Attempt to call the shop specified at the given index at your position.</a>
<a name="ln2952"> *</a>
<a name="ln2953"> * @param index     The index of the shop (in gozag props)</a>
<a name="ln2954"> */</a>
<a name="ln2955">static void _gozag_place_shop(int index)</a>
<a name="ln2956">{</a>
<a name="ln2957">    ASSERT(grd(you.pos()) == DNGN_FLOOR);</a>
<a name="ln2958">    keyed_mapspec kmspec;</a>
<a name="ln2959">    kmspec.set_feat(_gozag_shop_spec(index), false);</a>
<a name="ln2960"> </a>
<a name="ln2961">    feature_spec feat = kmspec.get_feat();</a>
<a name="ln2962">    if (!feat.shop)</a>
<a name="ln2963">        die(&quot;Invalid shop spec?&quot;);</a>
<a name="ln2964">    place_spec_shop(you.pos(), *feat.shop, you.experience_level);</a>
<a name="ln2965"> </a>
<a name="ln2966">    link_items();</a>
<a name="ln2967">    env.markers.add(new map_feature_marker(you.pos(), DNGN_ABANDONED_SHOP));</a>
<a name="ln2968">    env.markers.clear_need_activate();</a>
<a name="ln2969"> </a>
<a name="ln2970">    shop_struct *shop = shop_at(you.pos());</a>
<a name="ln2971">    ASSERT(shop);</a>
<a name="ln2972"> </a>
<a name="ln2973">    const gender_type gender = random_choose(GENDER_FEMALE, GENDER_MALE,</a>
<a name="ln2974">                                             GENDER_NEUTRAL);</a>
<a name="ln2975"> </a>
<a name="ln2976">    mprf(MSGCH_GOD, &quot;%s invites you to visit %s %s%s%s.&quot;,</a>
<a name="ln2977">                    shop-&gt;shop_name.c_str(),</a>
<a name="ln2978">                    decline_pronoun(gender, PRONOUN_POSSESSIVE),</a>
<a name="ln2979">                    shop_type_name(shop-&gt;type).c_str(),</a>
<a name="ln2980">                    !shop-&gt;shop_suffix_name.empty() ? &quot; &quot; : &quot;&quot;,</a>
<a name="ln2981">                    shop-&gt;shop_suffix_name.c_str());</a>
<a name="ln2982">}</a>
<a name="ln2983"> </a>
<a name="ln2984">bool gozag_call_merchant()</a>
<a name="ln2985">{</a>
<a name="ln2986">    // Only offer useful shops.</a>
<a name="ln2987">    vector&lt;shop_type&gt; valid_shops;</a>
<a name="ln2988">    for (int i = 0; i &lt; NUM_SHOPS; i++)</a>
<a name="ln2989">    {</a>
<a name="ln2990">        shop_type type = static_cast&lt;shop_type&gt;(i);</a>
<a name="ln2991">        // if they are useful to the player, food shops are handled through the</a>
<a name="ln2992">        // first index.</a>
<a name="ln2993">        if (type == SHOP_FOOD)</a>
<a name="ln2994">            continue;</a>
<a name="ln2995">        if (type == SHOP_DISTILLERY &amp;&amp; you.species == SP_MUMMY)</a>
<a name="ln2996">            continue;</a>
<a name="ln2997">        if (type == SHOP_EVOKABLES &amp;&amp; you.get_mutation_level(MUT_NO_ARTIFICE))</a>
<a name="ln2998">            continue;</a>
<a name="ln2999">        if (you.species == SP_FELID &amp;&amp;</a>
<a name="ln3000">            (type == SHOP_ARMOUR</a>
<a name="ln3001">             || type == SHOP_ARMOUR_ANTIQUE</a>
<a name="ln3002">             || type == SHOP_WEAPON</a>
<a name="ln3003">             || type == SHOP_WEAPON_ANTIQUE))</a>
<a name="ln3004">        {</a>
<a name="ln3005">            continue;</a>
<a name="ln3006">        }</a>
<a name="ln3007">        valid_shops.push_back(type);</a>
<a name="ln3008">    }</a>
<a name="ln3009"> </a>
<a name="ln3010">    // Set up some dummy shops.</a>
<a name="ln3011">    // Generate some shop inventory and store it as a store spec.</a>
<a name="ln3012">    // We still set up the shops in advance in case of hups.</a>
<a name="ln3013">    for (int i = 0; i &lt; _gozag_max_shops(); i++)</a>
<a name="ln3014">        if (!you.props.exists(make_stringf(GOZAG_SHOPKEEPER_NAME_KEY, i)))</a>
<a name="ln3015">            _setup_gozag_shop(i, valid_shops);</a>
<a name="ln3016"> </a>
<a name="ln3017">    const int shop_index = _gozag_choose_shop();</a>
<a name="ln3018">    if (shop_index == -1) // hup!</a>
<a name="ln3019">        return false;</a>
<a name="ln3020"> </a>
<a name="ln3021">    ASSERT(shop_index &gt;= 0 &amp;&amp; shop_index &lt; _gozag_max_shops());</a>
<a name="ln3022"> </a>
<a name="ln3023">    const int cost = _gozag_shop_price(shop_index);</a>
<a name="ln3024">    ASSERT(you.gold &gt;= cost);</a>
<a name="ln3025"> </a>
<a name="ln3026">    you.del_gold(cost);</a>
<a name="ln3027">    you.attribute[ATTR_GOZAG_GOLD_USED] += cost;</a>
<a name="ln3028"> </a>
<a name="ln3029">    _gozag_place_shop(shop_index);</a>
<a name="ln3030"> </a>
<a name="ln3031">    you.attribute[ATTR_GOZAG_SHOPS]++;</a>
<a name="ln3032">    you.attribute[ATTR_GOZAG_SHOPS_CURRENT]++;</a>
<a name="ln3033"> </a>
<a name="ln3034">    for (int j = 0; j &lt; _gozag_max_shops(); j++)</a>
<a name="ln3035">    {</a>
<a name="ln3036">        you.props.erase(make_stringf(GOZAG_SHOPKEEPER_NAME_KEY, j));</a>
<a name="ln3037">        you.props.erase(make_stringf(GOZAG_SHOP_TYPE_KEY, j));</a>
<a name="ln3038">        you.props.erase(make_stringf(GOZAG_SHOP_SUFFIX_KEY, j));</a>
<a name="ln3039">        you.props.erase(make_stringf(GOZAG_SHOP_COST_KEY, j));</a>
<a name="ln3040">    }</a>
<a name="ln3041"> </a>
<a name="ln3042">    return true;</a>
<a name="ln3043">}</a>
<a name="ln3044"> </a>
<a name="ln3045">branch_type gozag_fixup_branch(branch_type branch)</a>
<a name="ln3046">{</a>
<a name="ln3047">    if (is_hell_subbranch(branch))</a>
<a name="ln3048">        return BRANCH_VESTIBULE;</a>
<a name="ln3049"> </a>
<a name="ln3050">    return branch;</a>
<a name="ln3051">}</a>
<a name="ln3052"> </a>
<a name="ln3053">static const map&lt;branch_type, int&gt; branch_bribability_factor =</a>
<a name="ln3054">{</a>
<a name="ln3055">    { BRANCH_DUNGEON,     2 },</a>
<a name="ln3056">    { BRANCH_ORC,         2 },</a>
<a name="ln3057">    { BRANCH_ELF,         3 },</a>
<a name="ln3058">    { BRANCH_SNAKE,       3 },</a>
<a name="ln3059">    { BRANCH_SHOALS,      3 },</a>
<a name="ln3060">    { BRANCH_CRYPT,       3 },</a>
<a name="ln3061">    { BRANCH_TOMB,        3 },</a>
<a name="ln3062">    { BRANCH_DEPTHS,      4 },</a>
<a name="ln3063">    { BRANCH_VAULTS,      4 },</a>
<a name="ln3064">    { BRANCH_ZOT,         4 },</a>
<a name="ln3065">    { BRANCH_VESTIBULE,   4 },</a>
<a name="ln3066">    { BRANCH_PANDEMONIUM, 4 },</a>
<a name="ln3067">};</a>
<a name="ln3068"> </a>
<a name="ln3069">// An x-in-8 chance of a monster of the given type being bribed.</a>
<a name="ln3070">// Tougher monsters have a stronger chance of being bribed.</a>
<a name="ln3071">int gozag_type_bribable(monster_type type)</a>
<a name="ln3072">{</a>
<a name="ln3073">    if (!you_worship(GOD_GOZAG))</a>
<a name="ln3074">        return 0;</a>
<a name="ln3075"> </a>
<a name="ln3076">    if (mons_class_intel(type) &lt; I_HUMAN)</a>
<a name="ln3077">        return 0;</a>
<a name="ln3078"> </a>
<a name="ln3079">    // Unique rune guardians can't be bribed, sorry!</a>
<a name="ln3080">    if (mons_is_unique(type)</a>
<a name="ln3081">        &amp;&amp; (mons_genus(type) == MONS_HELL_LORD</a>
<a name="ln3082">            || mons_genus(type) == MONS_PANDEMONIUM_LORD</a>
<a name="ln3083">            || type == MONS_ANTAEUS))</a>
<a name="ln3084">    {</a>
<a name="ln3085">        return 0;</a>
<a name="ln3086">    }</a>
<a name="ln3087"> </a>
<a name="ln3088">    const int *factor = map_find(branch_bribability_factor,</a>
<a name="ln3089">                                 gozag_fixup_branch(you.where_are_you));</a>
<a name="ln3090">    if (!factor)</a>
<a name="ln3091">        return 0;</a>
<a name="ln3092"> </a>
<a name="ln3093">    const int chance = max(mons_class_hit_dice(type) / *factor, 1);</a>
<a name="ln3094">    dprf(&quot;%s, bribe chance: %d&quot;, mons_type_name(type, DESC_PLAIN).c_str(),</a>
<a name="ln3095">                                 chance);</a>
<a name="ln3096"> </a>
<a name="ln3097">    return chance;</a>
<a name="ln3098">}</a>
<a name="ln3099"> </a>
<a name="ln3100">bool gozag_branch_bribable(branch_type branch)</a>
<a name="ln3101">{</a>
<a name="ln3102">    return map_find(branch_bribability_factor, gozag_fixup_branch(branch));</a>
<a name="ln3103">}</a>
<a name="ln3104"> </a>
<a name="ln3105">void gozag_deduct_bribe(branch_type br, int amount)</a>
<a name="ln3106">{</a>
<a name="ln3107">    if (branch_bribe[br] &lt;= 0)</a>
<a name="ln3108">        return;</a>
<a name="ln3109"> </a>
<a name="ln3110">    branch_bribe[br] = max(0, branch_bribe[br] - amount);</a>
<a name="ln3111">    if (branch_bribe[br] &lt;= 0)</a>
<a name="ln3112">    {</a>
<a name="ln3113">        mprf(MSGCH_DURATION, &quot;Your bribe of %s has been exhausted.&quot;,</a>
<a name="ln3114">             branches[br].longname);</a>
<a name="ln3115">        add_daction(DACT_BRIBE_TIMEOUT);</a>
<a name="ln3116">    }</a>
<a name="ln3117">}</a>
<a name="ln3118"> </a>
<a name="ln3119">bool gozag_check_bribe_branch(bool quiet)</a>
<a name="ln3120">{</a>
<a name="ln3121">    const int bribe_amount = GOZAG_BRIBE_AMOUNT;</a>
<a name="ln3122">    if (you.gold &lt; bribe_amount)</a>
<a name="ln3123">    {</a>
<a name="ln3124">        if (!quiet)</a>
<a name="ln3125">            mprf(&quot;You need at least %d gold to offer a bribe.&quot;, bribe_amount);</a>
<a name="ln3126">        return false;</a>
<a name="ln3127">    }</a>
<a name="ln3128">    branch_type branch = you.where_are_you;</a>
<a name="ln3129">    branch_type branch2 = NUM_BRANCHES;</a>
<a name="ln3130">    if (feat_is_branch_entrance(grd(you.pos())))</a>
<a name="ln3131">    {</a>
<a name="ln3132">        for (branch_iterator it; it; ++it)</a>
<a name="ln3133">            if (it-&gt;entry_stairs == grd(you.pos())</a>
<a name="ln3134">                &amp;&amp; gozag_branch_bribable(it-&gt;id))</a>
<a name="ln3135">            {</a>
<a name="ln3136">                branch2 = it-&gt;id;</a>
<a name="ln3137">                break;</a>
<a name="ln3138">            }</a>
<a name="ln3139">    }</a>
<a name="ln3140">    const string who = make_stringf(&quot;the denizens of %s&quot;,</a>
<a name="ln3141">                                   branches[branch].longname);</a>
<a name="ln3142">    const string who2 = branch2 != NUM_BRANCHES</a>
<a name="ln3143">                        ? make_stringf(&quot;the denizens of %s&quot;,</a>
<a name="ln3144">                                       branches[branch2].longname)</a>
<a name="ln3145">                        : &quot;&quot;;</a>
<a name="ln3146">    if (!gozag_branch_bribable(branch)</a>
<a name="ln3147">        &amp;&amp; (branch2 == NUM_BRANCHES</a>
<a name="ln3148">            || !gozag_branch_bribable(branch2)))</a>
<a name="ln3149">    {</a>
<a name="ln3150">        if (!quiet)</a>
<a name="ln3151">        {</a>
<a name="ln3152">            if (branch2 != NUM_BRANCHES)</a>
<a name="ln3153">                mprf(&quot;You can't bribe %s or %s.&quot;, who.c_str(), who2.c_str());</a>
<a name="ln3154">            else</a>
<a name="ln3155">                mprf(&quot;You can't bribe %s.&quot;, who.c_str());</a>
<a name="ln3156">        }</a>
<a name="ln3157">        return false;</a>
<a name="ln3158">    }</a>
<a name="ln3159">    return true;</a>
<a name="ln3160">}</a>
<a name="ln3161"> </a>
<a name="ln3162">bool gozag_bribe_branch()</a>
<a name="ln3163">{</a>
<a name="ln3164">    const int bribe_amount = GOZAG_BRIBE_AMOUNT;</a>
<a name="ln3165">    ASSERT(you.gold &gt;= bribe_amount);</a>
<a name="ln3166">    bool prompted = false;</a>
<a name="ln3167">    branch_type branch = gozag_fixup_branch(you.where_are_you);</a>
<a name="ln3168">    if (feat_is_branch_entrance(grd(you.pos())))</a>
<a name="ln3169">    {</a>
<a name="ln3170">        for (branch_iterator it; it; ++it)</a>
<a name="ln3171">            if (it-&gt;entry_stairs == grd(you.pos())</a>
<a name="ln3172">                &amp;&amp; gozag_branch_bribable(it-&gt;id))</a>
<a name="ln3173">            {</a>
<a name="ln3174">                branch_type stair_branch = gozag_fixup_branch(it-&gt;id);</a>
<a name="ln3175">                string prompt =</a>
<a name="ln3176">                    make_stringf(&quot;Do you want to bribe the denizens of %s?&quot;,</a>
<a name="ln3177">                                 stair_branch == BRANCH_VESTIBULE ? &quot;the Hells&quot;</a>
<a name="ln3178">                                 : branches[stair_branch].longname);</a>
<a name="ln3179">                if (yesno(prompt.c_str(), true, 'n'))</a>
<a name="ln3180">                {</a>
<a name="ln3181">                    branch = stair_branch;</a>
<a name="ln3182">                    prompted = true;</a>
<a name="ln3183">                }</a>
<a name="ln3184">                // If we're in the Vestibule, standing on a portal to a Hell</a>
<a name="ln3185">                // sub-branch, don't prompt twice to bribe the Hells.</a>
<a name="ln3186">                else if (branch == stair_branch)</a>
<a name="ln3187">                {</a>
<a name="ln3188">                    canned_msg(MSG_OK);</a>
<a name="ln3189">                    return false;</a>
<a name="ln3190">                }</a>
<a name="ln3191">                break;</a>
<a name="ln3192">            }</a>
<a name="ln3193">    }</a>
<a name="ln3194">    string who = make_stringf(&quot;the denizens of %s&quot;,</a>
<a name="ln3195">                              branches[branch].longname);</a>
<a name="ln3196">    if (!gozag_branch_bribable(branch))</a>
<a name="ln3197">    {</a>
<a name="ln3198">        mprf(&quot;You can't bribe %s.&quot;, who.c_str());</a>
<a name="ln3199">        return false;</a>
<a name="ln3200">    }</a>
<a name="ln3201"> </a>
<a name="ln3202">    string prompt =</a>
<a name="ln3203">        make_stringf(&quot;Do you want to bribe the denizens of %s?&quot;,</a>
<a name="ln3204">                     branch == BRANCH_VESTIBULE ? &quot;the Hells&quot; :</a>
<a name="ln3205">                     branches[branch].longname);</a>
<a name="ln3206"> </a>
<a name="ln3207">    if (prompted || yesno(prompt.c_str(), true, 'n'))</a>
<a name="ln3208">    {</a>
<a name="ln3209">        you.del_gold(bribe_amount);</a>
<a name="ln3210">        you.attribute[ATTR_GOZAG_GOLD_USED] += bribe_amount;</a>
<a name="ln3211">        branch_bribe[branch] += bribe_amount;</a>
<a name="ln3212">        string msg = make_stringf(&quot; spreads your bribe to %s!&quot;,</a>
<a name="ln3213">                                  branch == BRANCH_VESTIBULE ? &quot;the Hells&quot; :</a>
<a name="ln3214">                                  branches[branch].longname);</a>
<a name="ln3215">        simple_god_message(msg.c_str());</a>
<a name="ln3216">        add_daction(DACT_SET_BRIBES);</a>
<a name="ln3217">        return true;</a>
<a name="ln3218">    }</a>
<a name="ln3219"> </a>
<a name="ln3220">    canned_msg(MSG_OK);</a>
<a name="ln3221">    return false;</a>
<a name="ln3222">}</a>
<a name="ln3223"> </a>
<a name="ln3224">static int _upheaval_radius(int pow)</a>
<a name="ln3225">{</a>
<a name="ln3226">    return pow &gt;= 100 ? 2 : 1;</a>
<a name="ln3227">}</a>
<a name="ln3228"> </a>
<a name="ln3229">spret qazlal_upheaval(coord_def target, bool quiet, bool fail)</a>
<a name="ln3230">{</a>
<a name="ln3231">    int pow = you.skill(SK_INVOCATIONS, 6);</a>
<a name="ln3232">    const int max_radius = _upheaval_radius(pow);</a>
<a name="ln3233"> </a>
<a name="ln3234">    bolt beam;</a>
<a name="ln3235">    beam.name        = &quot;****&quot;;</a>
<a name="ln3236">    beam.source_id   = MID_PLAYER;</a>
<a name="ln3237">    beam.source_name = &quot;you&quot;;</a>
<a name="ln3238">    beam.thrower     = KILL_YOU;</a>
<a name="ln3239">    beam.range       = LOS_RADIUS;</a>
<a name="ln3240">    beam.damage      = calc_dice(3, 27 + div_rand_round(2 * pow, 5));</a>
<a name="ln3241">    beam.hit         = AUTOMATIC_HIT;</a>
<a name="ln3242">    beam.glyph       = dchar_glyph(DCHAR_EXPLOSION);</a>
<a name="ln3243">    beam.loudness    = 10;</a>
<a name="ln3244">#ifdef USE_TILE</a>
<a name="ln3245">    beam.tile_beam = -1;</a>
<a name="ln3246">#endif</a>
<a name="ln3247">    beam.draw_delay  = 0;</a>
<a name="ln3248"> </a>
<a name="ln3249">    if (target.origin())</a>
<a name="ln3250">    {</a>
<a name="ln3251">        dist spd;</a>
<a name="ln3252">        targeter_smite tgt(&amp;you, LOS_RADIUS, 0, max_radius);</a>
<a name="ln3253">        direction_chooser_args args;</a>
<a name="ln3254">        args.restricts = DIR_TARGET;</a>
<a name="ln3255">        args.mode = TARG_HOSTILE;</a>
<a name="ln3256">        args.needs_path = false;</a>
<a name="ln3257">        args.top_prompt = &quot;Aiming: &lt;white&gt;Upheaval&lt;/white&gt;&quot;;</a>
<a name="ln3258">        args.self = confirm_prompt_type::cancel;</a>
<a name="ln3259">        args.hitfunc = &amp;tgt;</a>
<a name="ln3260">        if (!spell_direction(spd, beam, &amp;args))</a>
<a name="ln3261">            return spret::abort;</a>
<a name="ln3262"> </a>
<a name="ln3263">        if (cell_is_solid(beam.target))</a>
<a name="ln3264">        {</a>
<a name="ln3265">            mprf(&quot;There is %s there.&quot;,</a>
<a name="ln3266">                 article_a(feat_type_name(grd(beam.target))).c_str());</a>
<a name="ln3267">            return spret::abort;</a>
<a name="ln3268">        }</a>
<a name="ln3269"> </a>
<a name="ln3270">        bolt tempbeam;</a>
<a name="ln3271">        tempbeam.source    = beam.target;</a>
<a name="ln3272">        tempbeam.target    = beam.target;</a>
<a name="ln3273">        tempbeam.flavour   = BEAM_MISSILE;</a>
<a name="ln3274">        tempbeam.ex_size   = max_radius;</a>
<a name="ln3275">        tempbeam.hit       = AUTOMATIC_HIT;</a>
<a name="ln3276">        tempbeam.damage    = dice_def(AUTOMATIC_HIT, 1);</a>
<a name="ln3277">        tempbeam.thrower   = KILL_YOU;</a>
<a name="ln3278">        tempbeam.is_tracer = true;</a>
<a name="ln3279">        tempbeam.explode(false);</a>
<a name="ln3280">        if (tempbeam.beam_cancelled)</a>
<a name="ln3281">            return spret::abort;</a>
<a name="ln3282">    }</a>
<a name="ln3283">    else</a>
<a name="ln3284">        beam.target = target;</a>
<a name="ln3285"> </a>
<a name="ln3286">    fail_check();</a>
<a name="ln3287"> </a>
<a name="ln3288">    string message = &quot;&quot;;</a>
<a name="ln3289"> </a>
<a name="ln3290">    switch (random2(4))</a>
<a name="ln3291">    {</a>
<a name="ln3292">        case 0:</a>
<a name="ln3293">            beam.name     = &quot;blast of magma&quot;;</a>
<a name="ln3294">            beam.flavour  = BEAM_LAVA;</a>
<a name="ln3295">            beam.colour   = RED;</a>
<a name="ln3296">            beam.hit_verb = &quot;engulfs&quot;;</a>
<a name="ln3297">            message       = &quot;Magma suddenly erupts from the ground!&quot;;</a>
<a name="ln3298">            break;</a>
<a name="ln3299">        case 1:</a>
<a name="ln3300">            beam.name    = &quot;blast of ice&quot;;</a>
<a name="ln3301">            beam.flavour = BEAM_ICE;</a>
<a name="ln3302">            beam.colour  = WHITE;</a>
<a name="ln3303">            message      = &quot;A blizzard blasts the area with ice!&quot;;</a>
<a name="ln3304">            break;</a>
<a name="ln3305">        case 2:</a>
<a name="ln3306">            beam.name    = &quot;cutting wind&quot;;</a>
<a name="ln3307">            beam.flavour = BEAM_AIR;</a>
<a name="ln3308">            beam.colour  = LIGHTGRAY;</a>
<a name="ln3309">            message      = &quot;A storm cloud blasts the area with cutting wind!&quot;;</a>
<a name="ln3310">            break;</a>
<a name="ln3311">        case 3:</a>
<a name="ln3312">            beam.name    = &quot;blast of rubble&quot;;</a>
<a name="ln3313">            beam.flavour = BEAM_FRAG;</a>
<a name="ln3314">            beam.colour  = BROWN;</a>
<a name="ln3315">            message      = &quot;The ground shakes violently, spewing rubble!&quot;;</a>
<a name="ln3316">            break;</a>
<a name="ln3317">        default:</a>
<a name="ln3318">            break;</a>
<a name="ln3319">    }</a>
<a name="ln3320"> </a>
<a name="ln3321">    vector&lt;coord_def&gt; affected;</a>
<a name="ln3322">    affected.push_back(beam.target);</a>
<a name="ln3323">    for (radius_iterator ri(beam.target, max_radius, C_SQUARE, LOS_SOLID, true);</a>
<a name="ln3324">         ri; ++ri)</a>
<a name="ln3325">    {</a>
<a name="ln3326">        if (!in_bounds(*ri) || cell_is_solid(*ri))</a>
<a name="ln3327">            continue;</a>
<a name="ln3328"> </a>
<a name="ln3329">        int chance = pow;</a>
<a name="ln3330"> </a>
<a name="ln3331">        bool adj = adjacent(beam.target, *ri);</a>
<a name="ln3332">        if (!adj &amp;&amp; max_radius &gt; 1)</a>
<a name="ln3333">            chance -= 100;</a>
<a name="ln3334">        if (adj &amp;&amp; max_radius &gt; 1 || x_chance_in_y(chance, 100))</a>
<a name="ln3335">        {</a>
<a name="ln3336">            if (beam.flavour == BEAM_FRAG || !cell_is_solid(*ri))</a>
<a name="ln3337">                affected.push_back(*ri);</a>
<a name="ln3338">        }</a>
<a name="ln3339">    }</a>
<a name="ln3340"> </a>
<a name="ln3341">    for (coord_def pos : affected)</a>
<a name="ln3342">    {</a>
<a name="ln3343">        beam.draw(pos);</a>
<a name="ln3344">        if (!quiet)</a>
<a name="ln3345">            scaled_delay(25);</a>
<a name="ln3346">    }</a>
<a name="ln3347">    if (!quiet)</a>
<a name="ln3348">    {</a>
<a name="ln3349">        scaled_delay(100);</a>
<a name="ln3350">        mprf(MSGCH_GOD, &quot;%s&quot;, message.c_str());</a>
<a name="ln3351">    }</a>
<a name="ln3352">    else</a>
<a name="ln3353">        scaled_delay(25);</a>
<a name="ln3354"> </a>
<a name="ln3355">    int wall_count = 0;</a>
<a name="ln3356"> </a>
<a name="ln3357">    for (coord_def pos : affected)</a>
<a name="ln3358">    {</a>
<a name="ln3359">        beam.source = pos;</a>
<a name="ln3360">        beam.target = pos;</a>
<a name="ln3361">        beam.fire();</a>
<a name="ln3362"> </a>
<a name="ln3363">        switch (beam.flavour)</a>
<a name="ln3364">        {</a>
<a name="ln3365">            case BEAM_LAVA:</a>
<a name="ln3366">                if (grd(pos) == DNGN_FLOOR &amp;&amp; !actor_at(pos) &amp;&amp; coinflip())</a>
<a name="ln3367">                {</a>
<a name="ln3368">                    temp_change_terrain(</a>
<a name="ln3369">                        pos, DNGN_LAVA,</a>
<a name="ln3370">                        random2(you.skill(SK_INVOCATIONS, BASELINE_DELAY)),</a>
<a name="ln3371">                        TERRAIN_CHANGE_FLOOD);</a>
<a name="ln3372">                }</a>
<a name="ln3373">                break;</a>
<a name="ln3374">            case BEAM_AIR:</a>
<a name="ln3375">                if (!cell_is_solid(pos) &amp;&amp; !cloud_at(pos) &amp;&amp; coinflip())</a>
<a name="ln3376">                {</a>
<a name="ln3377">                    place_cloud(CLOUD_STORM, pos,</a>
<a name="ln3378">                                random2(you.skill_rdiv(SK_INVOCATIONS, 1, 4)),</a>
<a name="ln3379">                                &amp;you);</a>
<a name="ln3380">                }</a>
<a name="ln3381">                break;</a>
<a name="ln3382">            case BEAM_FRAG:</a>
<a name="ln3383">                if (((grd(pos) == DNGN_ROCK_WALL</a>
<a name="ln3384">                     || grd(pos) == DNGN_CLEAR_ROCK_WALL</a>
<a name="ln3385">                     || grd(pos) == DNGN_SLIMY_WALL)</a>
<a name="ln3386">                     &amp;&amp; x_chance_in_y(pow / 4, 100)</a>
<a name="ln3387">                    || feat_is_door(grd(pos))</a>
<a name="ln3388">                    || grd(pos) == DNGN_GRATE))</a>
<a name="ln3389">                {</a>
<a name="ln3390">                    noisy(30, pos);</a>
<a name="ln3391">                    destroy_wall(pos);</a>
<a name="ln3392">                    wall_count++;</a>
<a name="ln3393">                }</a>
<a name="ln3394">                break;</a>
<a name="ln3395">            default:</a>
<a name="ln3396">                break;</a>
<a name="ln3397">        }</a>
<a name="ln3398">    }</a>
<a name="ln3399"> </a>
<a name="ln3400">    if (wall_count &amp;&amp; !quiet)</a>
<a name="ln3401">        mpr(&quot;Ka-crash!&quot;);</a>
<a name="ln3402"> </a>
<a name="ln3403">    return spret::success;</a>
<a name="ln3404">}</a>
<a name="ln3405"> </a>
<a name="ln3406">spret qazlal_elemental_force(bool fail)</a>
<a name="ln3407">{</a>
<a name="ln3408">    static const map&lt;cloud_type, monster_type&gt; elemental_clouds = {</a>
<a name="ln3409">        { CLOUD_FIRE,           MONS_FIRE_ELEMENTAL },</a>
<a name="ln3410">        { CLOUD_FOREST_FIRE,    MONS_FIRE_ELEMENTAL },</a>
<a name="ln3411">        { CLOUD_COLD,           MONS_WATER_ELEMENTAL },</a>
<a name="ln3412">        { CLOUD_RAIN,           MONS_WATER_ELEMENTAL },</a>
<a name="ln3413">        { CLOUD_DUST,           MONS_EARTH_ELEMENTAL },</a>
<a name="ln3414">        { CLOUD_PETRIFY,        MONS_EARTH_ELEMENTAL },</a>
<a name="ln3415">        { CLOUD_BLACK_SMOKE,    MONS_AIR_ELEMENTAL },</a>
<a name="ln3416">        { CLOUD_GREY_SMOKE,     MONS_AIR_ELEMENTAL },</a>
<a name="ln3417">        { CLOUD_BLUE_SMOKE,     MONS_AIR_ELEMENTAL },</a>
<a name="ln3418">        { CLOUD_PURPLE_SMOKE,   MONS_AIR_ELEMENTAL },</a>
<a name="ln3419">        { CLOUD_STORM,          MONS_AIR_ELEMENTAL },</a>
<a name="ln3420">    };</a>
<a name="ln3421"> </a>
<a name="ln3422">    vector&lt;coord_def&gt; targets;</a>
<a name="ln3423">    for (radius_iterator ri(you.pos(), LOS_RADIUS, C_SQUARE, true); ri; ++ri)</a>
<a name="ln3424">    {</a>
<a name="ln3425">        const cloud_struct* cloud = cloud_at(*ri);</a>
<a name="ln3426">        if (!cloud || !elemental_clouds.count(cloud-&gt;type))</a>
<a name="ln3427">            continue;</a>
<a name="ln3428"> </a>
<a name="ln3429">        const actor *agent = actor_by_mid(cloud-&gt;source);</a>
<a name="ln3430">        if (agent &amp;&amp; agent-&gt;is_player())</a>
<a name="ln3431">            targets.push_back(*ri);</a>
<a name="ln3432">    }</a>
<a name="ln3433"> </a>
<a name="ln3434">    if (targets.empty())</a>
<a name="ln3435">    {</a>
<a name="ln3436">        mpr(&quot;You can't see any clouds you can empower.&quot;);</a>
<a name="ln3437">        return spret::abort;</a>
<a name="ln3438">    }</a>
<a name="ln3439"> </a>
<a name="ln3440">    fail_check();</a>
<a name="ln3441"> </a>
<a name="ln3442">    shuffle_array(targets);</a>
<a name="ln3443">    const int count = max(1, min((int)targets.size(),</a>
<a name="ln3444">                                 random2avg(you.skill(SK_INVOCATIONS), 2)));</a>
<a name="ln3445">    mgen_data mg;</a>
<a name="ln3446">    mg.summon_type = MON_SUMM_AID;</a>
<a name="ln3447">    mg.abjuration_duration = 1;</a>
<a name="ln3448">    mg.flags |= MG_FORCE_PLACE | MG_AUTOFOE;</a>
<a name="ln3449">    mg.summoner = &amp;you;</a>
<a name="ln3450">    int placed = 0;</a>
<a name="ln3451">    for (unsigned int i = 0; placed &lt; count &amp;&amp; i &lt; targets.size(); i++)</a>
<a name="ln3452">    {</a>
<a name="ln3453">        coord_def pos = targets[i];</a>
<a name="ln3454">        ASSERT(cloud_at(pos));</a>
<a name="ln3455">        const cloud_struct &amp;cl = *cloud_at(pos);</a>
<a name="ln3456">        mg.behaviour = BEH_FRIENDLY;</a>
<a name="ln3457">        mg.pos       = pos;</a>
<a name="ln3458">        auto mons_type = map_find(elemental_clouds, cl.type);</a>
<a name="ln3459">        // it is not impossible that earlier placements caused new clouds not</a>
<a name="ln3460">        // in the map.</a>
<a name="ln3461">        if (!mons_type)</a>
<a name="ln3462">            continue;</a>
<a name="ln3463">        mg.cls = *mons_type;</a>
<a name="ln3464">        if (!create_monster(mg))</a>
<a name="ln3465">            continue;</a>
<a name="ln3466">        delete_cloud(pos);</a>
<a name="ln3467">        placed++;</a>
<a name="ln3468">    }</a>
<a name="ln3469"> </a>
<a name="ln3470">    if (placed)</a>
<a name="ln3471">        mprf(MSGCH_GOD, &quot;Clouds arounds you coalesce and take form!&quot;);</a>
<a name="ln3472">    else</a>
<a name="ln3473">        canned_msg(MSG_NOTHING_HAPPENS); // can this ever happen?</a>
<a name="ln3474"> </a>
<a name="ln3475">    return spret::success;</a>
<a name="ln3476">}</a>
<a name="ln3477"> </a>
<a name="ln3478">bool qazlal_disaster_area()</a>
<a name="ln3479">{</a>
<a name="ln3480">    bool friendlies = false;</a>
<a name="ln3481">    vector&lt;coord_def&gt; targets;</a>
<a name="ln3482">    vector&lt;int&gt; weights;</a>
<a name="ln3483">    const int pow = you.skill(SK_INVOCATIONS, 6);</a>
<a name="ln3484">    const int upheaval_radius = _upheaval_radius(pow);</a>
<a name="ln3485">    for (radius_iterator ri(you.pos(), LOS_RADIUS, C_SQUARE, LOS_NO_TRANS, true);</a>
<a name="ln3486">         ri; ++ri)</a>
<a name="ln3487">    {</a>
<a name="ln3488">        if (!in_bounds(*ri) || cell_is_solid(*ri))</a>
<a name="ln3489">            continue;</a>
<a name="ln3490"> </a>
<a name="ln3491">        const monster_info* m = env.map_knowledge(*ri).monsterinfo();</a>
<a name="ln3492">        if (m &amp;&amp; mons_att_wont_attack(m-&gt;attitude)</a>
<a name="ln3493">            &amp;&amp; !mons_is_projectile(m-&gt;type))</a>
<a name="ln3494">        {</a>
<a name="ln3495">            friendlies = true;</a>
<a name="ln3496">        }</a>
<a name="ln3497"> </a>
<a name="ln3498">        const int range = you.pos().distance_from(*ri);</a>
<a name="ln3499">        const int dist = grid_distance(you.pos(), *ri);</a>
<a name="ln3500">        if (range &lt;= upheaval_radius)</a>
<a name="ln3501">            continue;</a>
<a name="ln3502"> </a>
<a name="ln3503">        targets.push_back(*ri);</a>
<a name="ln3504">        // We weight using the square of grid distance, so monsters fewer tiles</a>
<a name="ln3505">        // away are more likely to be hit.</a>
<a name="ln3506">        int weight = LOS_RADIUS * LOS_RADIUS + 1 - dist * dist;</a>
<a name="ln3507">        if (actor_at(*ri))</a>
<a name="ln3508">            weight *= 10;</a>
<a name="ln3509">        weights.push_back(weight);</a>
<a name="ln3510">    }</a>
<a name="ln3511"> </a>
<a name="ln3512">    if (targets.empty())</a>
<a name="ln3513">    {</a>
<a name="ln3514">        mpr(&quot;There isn't enough space here!&quot;);</a>
<a name="ln3515">        return false;</a>
<a name="ln3516">    }</a>
<a name="ln3517"> </a>
<a name="ln3518">    if (friendlies</a>
<a name="ln3519">        &amp;&amp; !yesno(&quot;There are friendlies around; are you sure you want to hurt &quot;</a>
<a name="ln3520">                  &quot;them?&quot;, true, 'n'))</a>
<a name="ln3521">    {</a>
<a name="ln3522">        canned_msg(MSG_OK);</a>
<a name="ln3523">        return false;</a>
<a name="ln3524">    }</a>
<a name="ln3525"> </a>
<a name="ln3526">    mprf(MSGCH_GOD, &quot;Nature churns violently around you!&quot;);</a>
<a name="ln3527"> </a>
<a name="ln3528">    // TODO: should count get a cap proportional to targets.size()?</a>
<a name="ln3529">    int count = max(1, min((int)targets.size(),</a>
<a name="ln3530">                            max(you.skill_rdiv(SK_INVOCATIONS, 1, 2),</a>
<a name="ln3531">                                random2avg(you.skill(SK_INVOCATIONS, 2), 2))));</a>
<a name="ln3532"> </a>
<a name="ln3533">    for (int i = 0; i &lt; count; i++)</a>
<a name="ln3534">    {</a>
<a name="ln3535">        if (targets.size() == 0)</a>
<a name="ln3536">            break;</a>
<a name="ln3537">        int which = choose_random_weighted(weights.begin(), weights.end());</a>
<a name="ln3538">        // Downweight adjacent potential targets (but don't rule them out</a>
<a name="ln3539">        // entirely).</a>
<a name="ln3540">        for (unsigned int j = 0; j &lt; targets.size(); j++)</a>
<a name="ln3541">            if (adjacent(targets[which], targets[j]))</a>
<a name="ln3542">                weights[j] = max(weights[j] / 2, 1);</a>
<a name="ln3543">        qazlal_upheaval(targets[which], true);</a>
<a name="ln3544">        targets.erase(targets.begin() + which);</a>
<a name="ln3545">        weights.erase(weights.begin() + which);</a>
<a name="ln3546">    }</a>
<a name="ln3547">    scaled_delay(100);</a>
<a name="ln3548"> </a>
<a name="ln3549">    return true;</a>
<a name="ln3550">}</a>
<a name="ln3551"> </a>
<a name="ln3552">static map&lt;ability_type, const sacrifice_def *&gt; sacrifice_data_map;</a>
<a name="ln3553"> </a>
<a name="ln3554">void init_sac_index()</a>
<a name="ln3555">{</a>
<a name="ln3556">    for (unsigned int i = ABIL_FIRST_SACRIFICE; i &lt;= ABIL_FINAL_SACRIFICE; ++i)</a>
<a name="ln3557">    {</a>
<a name="ln3558">        unsigned int sac_index = i - ABIL_FIRST_SACRIFICE;</a>
<a name="ln3559">        sacrifice_data_map[static_cast&lt;ability_type&gt;(i)] = &amp;sac_data[sac_index];</a>
<a name="ln3560">    }</a>
<a name="ln3561">}</a>
<a name="ln3562"> </a>
<a name="ln3563">static const sacrifice_def &amp;_get_sacrifice_def(ability_type sac)</a>
<a name="ln3564">{</a>
<a name="ln3565">    ASSERT_RANGE(sac, ABIL_FIRST_SACRIFICE, ABIL_FINAL_SACRIFICE+1);</a>
<a name="ln3566">    return *sacrifice_data_map[sac];</a>
<a name="ln3567">}</a>
<a name="ln3568"> </a>
<a name="ln3569">/// A map between sacrifice_def.sacrifice_vector strings &amp; possible mut lists</a>
<a name="ln3570">static map&lt;const char*, vector&lt;mutation_type&gt;&gt; sacrifice_vector_map =</a>
<a name="ln3571">{</a>
<a name="ln3572">    /// Mutations granted by ABIL_RU_SACRIFICE_HEALTH</a>
<a name="ln3573">    { HEALTH_SAC_KEY, {</a>
<a name="ln3574">        MUT_FRAIL,</a>
<a name="ln3575">        MUT_PHYSICAL_VULNERABILITY,</a>
<a name="ln3576">        MUT_SLOW_REFLEXES,</a>
<a name="ln3577">    }},</a>
<a name="ln3578">    /// Mutations granted by ABIL_RU_SACRIFICE_ESSENCE</a>
<a name="ln3579">    { ESSENCE_SAC_KEY, {</a>
<a name="ln3580">        MUT_ANTI_WIZARDRY,</a>
<a name="ln3581">        MUT_MAGICAL_VULNERABILITY,</a>
<a name="ln3582">        MUT_MAGICAL_VULNERABILITY,</a>
<a name="ln3583">        MUT_LOW_MAGIC,</a>
<a name="ln3584">    }},</a>
<a name="ln3585">    /// Mutations granted by ABIL_RU_SACRIFICE_PURITY</a>
<a name="ln3586">    { PURITY_SAC_KEY, {</a>
<a name="ln3587">        MUT_SCREAM,</a>
<a name="ln3588">        MUT_INHIBITED_REGENERATION,</a>
<a name="ln3589">        MUT_NO_POTION_HEAL,</a>
<a name="ln3590">        MUT_DOPEY,</a>
<a name="ln3591">        MUT_CLUMSY,</a>
<a name="ln3592">        MUT_WEAK,</a>
<a name="ln3593">    }},</a>
<a name="ln3594">};</a>
<a name="ln3595"> </a>
<a name="ln3596">/// School-disabling mutations that will be painful for most characters.</a>
<a name="ln3597">static const vector&lt;mutation_type&gt; _major_arcane_sacrifices =</a>
<a name="ln3598">{</a>
<a name="ln3599">    MUT_NO_CHARM_MAGIC,</a>
<a name="ln3600">    MUT_NO_CONJURATION_MAGIC,</a>
<a name="ln3601">    MUT_NO_SUMMONING_MAGIC,</a>
<a name="ln3602">    MUT_NO_TRANSLOCATION_MAGIC,</a>
<a name="ln3603">};</a>
<a name="ln3604"> </a>
<a name="ln3605">/// School-disabling mutations that are unfortunate for most characters.</a>
<a name="ln3606">static const vector&lt;mutation_type&gt; _moderate_arcane_sacrifices =</a>
<a name="ln3607">{</a>
<a name="ln3608">    MUT_NO_TRANSMUTATION_MAGIC,</a>
<a name="ln3609">    MUT_NO_NECROMANCY_MAGIC,</a>
<a name="ln3610">    MUT_NO_HEXES_MAGIC,</a>
<a name="ln3611">};</a>
<a name="ln3612"> </a>
<a name="ln3613">/// School-disabling mutations that are mostly easy to deal with.</a>
<a name="ln3614">static const vector&lt;mutation_type&gt; _minor_arcane_sacrifices =</a>
<a name="ln3615">{</a>
<a name="ln3616">    MUT_NO_AIR_MAGIC,</a>
<a name="ln3617">    MUT_NO_FIRE_MAGIC,</a>
<a name="ln3618">    MUT_NO_ICE_MAGIC,</a>
<a name="ln3619">    MUT_NO_EARTH_MAGIC,</a>
<a name="ln3620">    MUT_NO_POISON_MAGIC,</a>
<a name="ln3621">};</a>
<a name="ln3622"> </a>
<a name="ln3623">/// The list of all lists of arcana sacrifice mutations.</a>
<a name="ln3624">static const vector&lt;mutation_type&gt; _arcane_sacrifice_lists[] =</a>
<a name="ln3625">{</a>
<a name="ln3626">    _minor_arcane_sacrifices,</a>
<a name="ln3627">    _moderate_arcane_sacrifices,</a>
<a name="ln3628">    _major_arcane_sacrifices,</a>
<a name="ln3629">};</a>
<a name="ln3630"> </a>
<a name="ln3631">/**</a>
<a name="ln3632"> * Choose a random mutation from the given list, only including those that are</a>
<a name="ln3633"> * valid choices for a Ru sacrifice. (Not already at the max level, not</a>
<a name="ln3634"> * conflicting with an innate mut.)</a>
<a name="ln3635"> *</a>
<a name="ln3636"> * @param muts      The list of possible sacrifice mutations.</a>
<a name="ln3637"> * @return          A mutation from the list, or MUT_NON_MUTATION if no valid</a>
<a name="ln3638"> *                  result was found.</a>
<a name="ln3639"> */</a>
<a name="ln3640">static mutation_type _random_valid_sacrifice(const vector&lt;mutation_type&gt; &amp;muts)</a>
<a name="ln3641">{</a>
<a name="ln3642">    int valid_sacrifices = 0;</a>
<a name="ln3643">    mutation_type chosen_sacrifice = MUT_NON_MUTATION;</a>
<a name="ln3644">    for (auto mut : muts)</a>
<a name="ln3645">    {</a>
<a name="ln3646">        // can't give the player this if they're already at max</a>
<a name="ln3647">        if (you.get_mutation_level(mut) &gt;= mutation_max_levels(mut))</a>
<a name="ln3648">            continue;</a>
<a name="ln3649"> </a>
<a name="ln3650">        // can't give the player this if they have an innate mut that conflicts</a>
<a name="ln3651">        if (mut_check_conflict(mut, true))</a>
<a name="ln3652">            continue;</a>
<a name="ln3653"> </a>
<a name="ln3654">        // Special case a few weird interactions:</a>
<a name="ln3655"> </a>
<a name="ln3656">        // Vampires can't get inhibited regeneration for some reason related</a>
<a name="ln3657">        // to their existing regen silliness.</a>
<a name="ln3658">        // Neither can deep dwarf, for obvious reasons.</a>
<a name="ln3659">        if (mut == MUT_INHIBITED_REGENERATION &amp;&amp; you.species == SP_VAMPIRE)</a>
<a name="ln3660">            continue;</a>
<a name="ln3661"> </a>
<a name="ln3662">        // demonspawn can't get frail if they have a robust facet</a>
<a name="ln3663">        if (you.species == SP_DEMONSPAWN &amp;&amp; mut == MUT_FRAIL</a>
<a name="ln3664">            &amp;&amp; any_of(begin(you.demonic_traits), end(you.demonic_traits),</a>
<a name="ln3665">                      [] (player::demon_trait t)</a>
<a name="ln3666">                      { return t.mutation == MUT_ROBUST; }))</a>
<a name="ln3667">        {</a>
<a name="ln3668">            continue;</a>
<a name="ln3669">        }</a>
<a name="ln3670"> </a>
<a name="ln3671">        // No potion heal doesn't affect mummies since they can't quaff potions</a>
<a name="ln3672">        if (mut == MUT_NO_POTION_HEAL &amp;&amp; you.species == SP_MUMMY)</a>
<a name="ln3673">            continue;</a>
<a name="ln3674"> </a>
<a name="ln3675">        // The Grunt Algorithm</a>
<a name="ln3676">        // (choose a random element from a set of unknown size without building</a>
<a name="ln3677">        // an explicit list, by giving each one a chance to be chosen equal to</a>
<a name="ln3678">        // the size of the known list so far, but not returning until the whole</a>
<a name="ln3679">        // set has been seen.)</a>
<a name="ln3680">        // TODO: export this to a function?</a>
<a name="ln3681">        ++valid_sacrifices;</a>
<a name="ln3682">        if (one_chance_in(valid_sacrifices))</a>
<a name="ln3683">            chosen_sacrifice = mut;</a>
<a name="ln3684">    }</a>
<a name="ln3685"> </a>
<a name="ln3686">    return chosen_sacrifice;</a>
<a name="ln3687">}</a>
<a name="ln3688"> </a>
<a name="ln3689">/**</a>
<a name="ln3690"> * Choose a random valid mutation from the given list &amp; insert it into the</a>
<a name="ln3691"> * single-element vector player prop.</a>
<a name="ln3692"> *</a>
<a name="ln3693"> * @param key           The key of the player prop to insert the mut into.</a>
<a name="ln3694"> */</a>
<a name="ln3695">static void _choose_sacrifice_mutation(const char *key)</a>
<a name="ln3696">{</a>
<a name="ln3697">    ASSERT(you.props.exists(key));</a>
<a name="ln3698">    CrawlVector &amp;current_sacrifice = you.props[key].get_vector();</a>
<a name="ln3699">    ASSERT(current_sacrifice.empty());</a>
<a name="ln3700"> </a>
<a name="ln3701">    const mutation_type mut</a>
<a name="ln3702">        = _random_valid_sacrifice(sacrifice_vector_map[key]);</a>
<a name="ln3703">    if (mut != MUT_NON_MUTATION)</a>
<a name="ln3704">    {</a>
<a name="ln3705">        // XXX: why on earth is this a one-element vector?</a>
<a name="ln3706">        current_sacrifice.push_back(static_cast&lt;int&gt;(mut));</a>
<a name="ln3707">    }</a>
<a name="ln3708">}</a>
<a name="ln3709"> </a>
<a name="ln3710">/**</a>
<a name="ln3711"> * Choose a set of three spellschools to sacrifice: one major, one moderate,</a>
<a name="ln3712"> * and one minor.</a>
<a name="ln3713"> */</a>
<a name="ln3714">static void _choose_arcana_mutations()</a>
<a name="ln3715">{</a>
<a name="ln3716">    ASSERT(you.props.exists(ARCANA_SAC_KEY));</a>
<a name="ln3717">    CrawlVector &amp;current_arcane_sacrifices</a>
<a name="ln3718">        = you.props[ARCANA_SAC_KEY].get_vector();</a>
<a name="ln3719">    ASSERT(current_arcane_sacrifices.empty());</a>
<a name="ln3720"> </a>
<a name="ln3721">    for (const vector&lt;mutation_type&gt; arcane_sacrifice_list :</a>
<a name="ln3722">                                    _arcane_sacrifice_lists)</a>
<a name="ln3723">    {</a>
<a name="ln3724">        const mutation_type sacrifice =</a>
<a name="ln3725">            _random_valid_sacrifice(arcane_sacrifice_list);</a>
<a name="ln3726"> </a>
<a name="ln3727">        if (sacrifice == MUT_NON_MUTATION)</a>
<a name="ln3728">            return;  // don't bother filling out the others, we failed</a>
<a name="ln3729">        current_arcane_sacrifices.push_back(sacrifice);</a>
<a name="ln3730">    }</a>
<a name="ln3731"> </a>
<a name="ln3732">    ASSERT(current_arcane_sacrifices.size()</a>
<a name="ln3733">           == ARRAYSZ(_arcane_sacrifice_lists));</a>
<a name="ln3734">}</a>
<a name="ln3735"> </a>
<a name="ln3736">/**</a>
<a name="ln3737"> * Has the player sacrificed any arcana?</a>
<a name="ln3738"> */</a>
<a name="ln3739">static bool _player_sacrificed_arcana()</a>
<a name="ln3740">{</a>
<a name="ln3741">    for (const vector&lt;mutation_type&gt; arcane_sacrifice_list :</a>
<a name="ln3742">                                    _arcane_sacrifice_lists)</a>
<a name="ln3743">    {</a>
<a name="ln3744">        for (mutation_type sacrifice : arcane_sacrifice_list)</a>
<a name="ln3745">            if (you.get_mutation_level(sacrifice))</a>
<a name="ln3746">                return true;</a>
<a name="ln3747">    }</a>
<a name="ln3748">    return false;</a>
<a name="ln3749">}</a>
<a name="ln3750"> </a>
<a name="ln3751">/**</a>
<a name="ln3752"> * Is the given sacrifice a valid one for Ru to offer to the player right now?</a>
<a name="ln3753"> *</a>
<a name="ln3754"> * @param sacrifice     The sacrifice in question.</a>
<a name="ln3755"> * @return              Whether Ru can offer the player that sacrifice, or</a>
<a name="ln3756"> *                      whether something is blocking it (e.g. no sacrificing</a>
<a name="ln3757"> *                      armour for races that can't wear any...)</a>
<a name="ln3758"> */</a>
<a name="ln3759">static bool _sacrifice_is_possible(sacrifice_def &amp;sacrifice)</a>
<a name="ln3760">{</a>
<a name="ln3761">    if (sacrifice.mutation != MUT_NON_MUTATION</a>
<a name="ln3762">        &amp;&amp; you.get_mutation_level(sacrifice.mutation))</a>
<a name="ln3763">    {</a>
<a name="ln3764">        return false;</a>
<a name="ln3765">    }</a>
<a name="ln3766"> </a>
<a name="ln3767">    if (sacrifice.sacrifice_vector)</a>
<a name="ln3768">    {</a>
<a name="ln3769">        const char* key = sacrifice.sacrifice_vector;</a>
<a name="ln3770">        // XXX: changing state in this function seems sketchy</a>
<a name="ln3771">        if (sacrifice.sacrifice == ABIL_RU_SACRIFICE_ARCANA)</a>
<a name="ln3772">            _choose_arcana_mutations();</a>
<a name="ln3773">        else</a>
<a name="ln3774">            _choose_sacrifice_mutation(sacrifice.sacrifice_vector);</a>
<a name="ln3775"> </a>
<a name="ln3776">        if (you.props[key].get_vector().empty())</a>
<a name="ln3777">            return false;</a>
<a name="ln3778">    }</a>
<a name="ln3779"> </a>
<a name="ln3780">    if (sacrifice.valid != nullptr &amp;&amp; !sacrifice.valid())</a>
<a name="ln3781">        return false;</a>
<a name="ln3782"> </a>
<a name="ln3783">    return true;</a>
<a name="ln3784">}</a>
<a name="ln3785"> </a>
<a name="ln3786">/**</a>
<a name="ln3787"> * Which sacrifices are valid for Ru to potentially present to the player?</a>
<a name="ln3788"> *</a>
<a name="ln3789"> * @return      A list of potential sacrifices (e.g. ABIL_RU_SACRIFICE_WORDS).</a>
<a name="ln3790"> */</a>
<a name="ln3791">static vector&lt;ability_type&gt; _get_possible_sacrifices()</a>
<a name="ln3792">{</a>
<a name="ln3793">    vector&lt;ability_type&gt; possible_sacrifices;</a>
<a name="ln3794"> </a>
<a name="ln3795">    for (auto sacrifice : sac_data)</a>
<a name="ln3796">        if (_sacrifice_is_possible(sacrifice))</a>
<a name="ln3797">            possible_sacrifices.push_back(sacrifice.sacrifice);</a>
<a name="ln3798"> </a>
<a name="ln3799">    return possible_sacrifices;</a>
<a name="ln3800">}</a>
<a name="ln3801"> </a>
<a name="ln3802">/**</a>
<a name="ln3803"> * What's the name of the spell school corresponding to the given Ru mutation?</a>
<a name="ln3804"> *</a>
<a name="ln3805"> * @param mutation  The variety of MUT_NO_*_MAGIC in question.</a>
<a name="ln3806"> * @return          A long school name (&quot;Summoning&quot;, &quot;Translocations&quot;, etc.)</a>
<a name="ln3807"> */</a>
<a name="ln3808">static const char* _arcane_mutation_to_school_name(mutation_type mutation)</a>
<a name="ln3809">{</a>
<a name="ln3810">    // XXX: this does a really silly dance back and forth between school &amp;</a>
<a name="ln3811">    // spelltype.</a>
<a name="ln3812">    const skill_type sk = arcane_mutation_to_skill(mutation);</a>
<a name="ln3813">    const spschool school = skill2spell_type(sk);</a>
<a name="ln3814">    return spelltype_long_name(school);</a>
<a name="ln3815">}</a>
<a name="ln3816"> </a>
<a name="ln3817">/**</a>
<a name="ln3818"> * What's the abbreviation of the spell school corresponding to the given Ru</a>
<a name="ln3819"> * mutation?</a>
<a name="ln3820"> *</a>
<a name="ln3821"> * @param mutation  The variety of MUT_NO_*_MAGIC in question.</a>
<a name="ln3822"> * @return          A school abbreviation (&quot;Summ&quot;, &quot;Tloc&quot;, etc.)</a>
<a name="ln3823"> */</a>
<a name="ln3824">static const char* _arcane_mutation_to_school_abbr(mutation_type mutation)</a>
<a name="ln3825">{</a>
<a name="ln3826">    // XXX: this does a really silly dance back and forth between school &amp;</a>
<a name="ln3827">    // spelltype.</a>
<a name="ln3828">    const auto school = skill2spell_type(arcane_mutation_to_skill(mutation));</a>
<a name="ln3829">    return spelltype_short_name(school);</a>
<a name="ln3830">}</a>
<a name="ln3831"> </a>
<a name="ln3832">static int _piety_for_skill(skill_type skill)</a>
<a name="ln3833">{</a>
<a name="ln3834">    // Gnolls didn't have a choice about training the skill, so don't give</a>
<a name="ln3835">    // them more piety for waiting longer before taking the sacrifice.</a>
<a name="ln3836">    if (you.species == SP_GNOLL)</a>
<a name="ln3837">        return 0;</a>
<a name="ln3838">    return skill_exp_needed(you.skills[skill], skill, you.species) / 500;</a>
<a name="ln3839">}</a>
<a name="ln3840"> </a>
<a name="ln3841">static int _piety_for_skill_by_sacrifice(ability_type sacrifice)</a>
<a name="ln3842">{</a>
<a name="ln3843">    int piety_gain = 0;</a>
<a name="ln3844">    const sacrifice_def &amp;sac_def = _get_sacrifice_def(sacrifice);</a>
<a name="ln3845"> </a>
<a name="ln3846">    piety_gain += _piety_for_skill(sac_def.sacrifice_skill);</a>
<a name="ln3847">    if (sacrifice == ABIL_RU_SACRIFICE_HAND)</a>
<a name="ln3848">    {</a>
<a name="ln3849">        // No one-handed staves for small races.</a>
<a name="ln3850">        if (species_size(you.species, PSIZE_TORSO) &lt;= SIZE_SMALL)</a>
<a name="ln3851">            piety_gain += _piety_for_skill(SK_STAVES);</a>
<a name="ln3852">        // No one-handed bows.</a>
<a name="ln3853">        if (you.species != SP_FORMICID)</a>
<a name="ln3854">            piety_gain += _piety_for_skill(SK_BOWS);</a>
<a name="ln3855">    }</a>
<a name="ln3856">    return piety_gain;</a>
<a name="ln3857">}</a>
<a name="ln3858"> </a>
<a name="ln3859">#define AS_MUT(csv) (static_cast&lt;mutation_type&gt;((csv).get_int()))</a>
<a name="ln3860"> </a>
<a name="ln3861">/**</a>
<a name="ln3862"> * Adjust piety based on stat ranking. You get less piety if you're looking at</a>
<a name="ln3863"> * your lower stats.</a>
<a name="ln3864"> *</a>
<a name="ln3865"> * @param stat_type input_stat The stat we're checking.</a>
<a name="ln3866"> * @param int       multiplier How much piety for each rank position off.</a>
<a name="ln3867"> * @return          The piety to add.</a>
<a name="ln3868"> */</a>
<a name="ln3869">static int _get_stat_piety(stat_type input_stat, int multiplier)</a>
<a name="ln3870">{</a>
<a name="ln3871">    int stat_val = 3; // If this is your highest stat.</a>
<a name="ln3872">    if (you.base_stats[STAT_INT] &gt; you.base_stats[input_stat])</a>
<a name="ln3873">            stat_val -= 1;</a>
<a name="ln3874">    if (you.base_stats[STAT_STR] &gt; you.base_stats[input_stat])</a>
<a name="ln3875">            stat_val -= 1;</a>
<a name="ln3876">    if (you.base_stats[STAT_DEX] &gt; you.base_stats[input_stat])</a>
<a name="ln3877">            stat_val -= 1;</a>
<a name="ln3878">    return stat_val * multiplier;</a>
<a name="ln3879">}</a>
<a name="ln3880"> </a>
<a name="ln3881">int get_sacrifice_piety(ability_type sac, bool include_skill)</a>
<a name="ln3882">{</a>
<a name="ln3883">    if (sac == ABIL_RU_REJECT_SACRIFICES)</a>
<a name="ln3884">        return INT_MAX; // used as the null sacrifice</a>
<a name="ln3885"> </a>
<a name="ln3886">    const sacrifice_def &amp;sac_def = _get_sacrifice_def(sac);</a>
<a name="ln3887">    int piety_gain = sac_def.base_piety;</a>
<a name="ln3888">    ability_type sacrifice = sac_def.sacrifice;</a>
<a name="ln3889">    mutation_type mut = MUT_NON_MUTATION;</a>
<a name="ln3890">    int num_sacrifices = 0;</a>
<a name="ln3891"> </a>
<a name="ln3892">    // Initialize data</a>
<a name="ln3893">    if (sac_def.sacrifice_vector)</a>
<a name="ln3894">    {</a>
<a name="ln3895">        ASSERT(you.props.exists(sac_def.sacrifice_vector));</a>
<a name="ln3896">        CrawlVector &amp;sacrifice_muts =</a>
<a name="ln3897">            you.props[sac_def.sacrifice_vector].get_vector();</a>
<a name="ln3898">        num_sacrifices = sacrifice_muts.size();</a>
<a name="ln3899">        // mut can only meaningfully be set here if we have exactly one.</a>
<a name="ln3900">        if (num_sacrifices == 1)</a>
<a name="ln3901">            mut = AS_MUT(sacrifice_muts[0]);</a>
<a name="ln3902">    }</a>
<a name="ln3903">    else</a>
<a name="ln3904">        mut = sac_def.mutation;</a>
<a name="ln3905"> </a>
<a name="ln3906">    // Increase piety each skill point removed.</a>
<a name="ln3907">    if (sacrifice == ABIL_RU_SACRIFICE_ARCANA)</a>
<a name="ln3908">    {</a>
<a name="ln3909">        skill_type arcane_skill;</a>
<a name="ln3910">        mutation_type arcane_mut;</a>
<a name="ln3911">        CrawlVector &amp;sacrifice_muts =</a>
<a name="ln3912">            you.props[sac_def.sacrifice_vector].get_vector();</a>
<a name="ln3913">        for (int i = 0; i &lt; num_sacrifices; i++)</a>
<a name="ln3914">        {</a>
<a name="ln3915">            arcane_mut = AS_MUT(sacrifice_muts[i]);</a>
<a name="ln3916">            arcane_skill = arcane_mutation_to_skill(arcane_mut);</a>
<a name="ln3917">            piety_gain += _piety_for_skill(arcane_skill);</a>
<a name="ln3918">        }</a>
<a name="ln3919">    }</a>
<a name="ln3920">    else if (sac_def.sacrifice_skill != SK_NONE &amp;&amp; include_skill)</a>
<a name="ln3921">        piety_gain += _piety_for_skill_by_sacrifice(sac_def.sacrifice);</a>
<a name="ln3922"> </a>
<a name="ln3923">    switch (sacrifice)</a>
<a name="ln3924">    {</a>
<a name="ln3925">        case ABIL_RU_SACRIFICE_HEALTH:</a>
<a name="ln3926">            if (mut == MUT_FRAIL)</a>
<a name="ln3927">                piety_gain += 20; // -health is pretty much always quite bad.</a>
<a name="ln3928">            else if (mut == MUT_PHYSICAL_VULNERABILITY)</a>
<a name="ln3929">                piety_gain += 5; // -AC is a bit worse than -EV</a>
<a name="ln3930">            break;</a>
<a name="ln3931">        case ABIL_RU_SACRIFICE_ESSENCE:</a>
<a name="ln3932">            if (mut == MUT_LOW_MAGIC)</a>
<a name="ln3933">            {</a>
<a name="ln3934">                piety_gain += 10 + max(you.skill_rdiv(SK_INVOCATIONS, 1, 2),</a>
<a name="ln3935">                                       max( you.skill_rdiv(SK_SPELLCASTING, 1, 2),</a>
<a name="ln3936">                                            you.skill_rdiv(SK_EVOCATIONS, 1, 2)));</a>
<a name="ln3937">            }</a>
<a name="ln3938">            else if (mut == MUT_MAGICAL_VULNERABILITY)</a>
<a name="ln3939">                piety_gain += 28;</a>
<a name="ln3940">            else</a>
<a name="ln3941">                piety_gain += 2 + _get_stat_piety(STAT_INT, 6);</a>
<a name="ln3942">            break;</a>
<a name="ln3943">        case ABIL_RU_SACRIFICE_PURITY:</a>
<a name="ln3944">            if (mut == MUT_WEAK || mut == MUT_DOPEY || mut == MUT_CLUMSY)</a>
<a name="ln3945">            {</a>
<a name="ln3946">                const stat_type stat = mut == MUT_WEAK   ? STAT_STR</a>
<a name="ln3947">                                     : mut == MUT_CLUMSY ? STAT_DEX</a>
<a name="ln3948">                                     : mut == MUT_DOPEY  ? STAT_INT</a>
<a name="ln3949">                                                         : NUM_STATS;</a>
<a name="ln3950">                piety_gain += 4 + _get_stat_piety(stat, 4);</a>
<a name="ln3951">            }</a>
<a name="ln3952">            // the other sacrifices get sharply worse if you already</a>
<a name="ln3953">            // have levels of them.</a>
<a name="ln3954">            else if (you.get_mutation_level(mut) == 2)</a>
<a name="ln3955">                piety_gain += 28;</a>
<a name="ln3956">            else if (you.get_mutation_level(mut) == 1)</a>
<a name="ln3957">                piety_gain += 21;</a>
<a name="ln3958">            else</a>
<a name="ln3959">                piety_gain += 14;</a>
<a name="ln3960"> </a>
<a name="ln3961">            if (mut == MUT_SCREAM)</a>
<a name="ln3962">                piety_gain /= 2; // screaming just isn't that bad.</a>
<a name="ln3963"> </a>
<a name="ln3964">            break;</a>
<a name="ln3965">        case ABIL_RU_SACRIFICE_ARTIFICE:</a>
<a name="ln3966">            if (you.get_mutation_level(MUT_NO_LOVE))</a>
<a name="ln3967">                piety_gain -= 10; // You've already lost some value here</a>
<a name="ln3968">            break;</a>
<a name="ln3969">        case ABIL_RU_SACRIFICE_NIMBLENESS:</a>
<a name="ln3970">            if (you.get_mutation_level(MUT_NO_ARMOUR))</a>
<a name="ln3971">                piety_gain += 20;</a>
<a name="ln3972">            else if (species_apt(SK_ARMOUR) == UNUSABLE_SKILL)</a>
<a name="ln3973">                piety_gain += 28; // this sacrifice is worse for these races</a>
<a name="ln3974">            break;</a>
<a name="ln3975">        case ABIL_RU_SACRIFICE_DURABILITY:</a>
<a name="ln3976">            if (you.get_mutation_level(MUT_NO_DODGING))</a>
<a name="ln3977">                piety_gain += 20;</a>
<a name="ln3978">            break;</a>
<a name="ln3979">        case ABIL_RU_SACRIFICE_LOVE:</a>
<a name="ln3980">            if (you.get_mutation_level(MUT_NO_SUMMONING_MAGIC)</a>
<a name="ln3981">                &amp;&amp; you.get_mutation_level(MUT_NO_ARTIFICE))</a>
<a name="ln3982">            {</a>
<a name="ln3983">                // this is virtually useless, aside from zot_tub</a>
<a name="ln3984">                piety_gain = 1;</a>
<a name="ln3985">            }</a>
<a name="ln3986">            else if (you.get_mutation_level(MUT_NO_SUMMONING_MAGIC)</a>
<a name="ln3987">                || you.get_mutation_level(MUT_NO_ARTIFICE))</a>
<a name="ln3988">            {</a>
<a name="ln3989">                piety_gain /= 2;</a>
<a name="ln3990">            }</a>
<a name="ln3991">            break;</a>
<a name="ln3992">        case ABIL_RU_SACRIFICE_EXPERIENCE:</a>
<a name="ln3993">            if (you.get_mutation_level(MUT_COWARDICE))</a>
<a name="ln3994">                piety_gain += 15;</a>
<a name="ln3995">            // Ds are highly likely to miss at least one mutation. This isn't</a>
<a name="ln3996">            // absolutely certain, but it's very likely and they should still</a>
<a name="ln3997">            // get a bonus for the risk. Could check the exact mutation</a>
<a name="ln3998">            // schedule, but this seems too leaky.</a>
<a name="ln3999">            if (you.species == SP_DEMONSPAWN)</a>
<a name="ln4000">                piety_gain += 28;</a>
<a name="ln4001">            break;</a>
<a name="ln4002">        case ABIL_RU_SACRIFICE_COURAGE:</a>
<a name="ln4003">            if (you.get_mutation_level(MUT_INEXPERIENCED))</a>
<a name="ln4004">                piety_gain += 15;</a>
<a name="ln4005"> </a>
<a name="ln4006">        default:</a>
<a name="ln4007">            break;</a>
<a name="ln4008">    }</a>
<a name="ln4009"> </a>
<a name="ln4010">    // Award piety for any mutations removed by adding new innate muts</a>
<a name="ln4011">    // These can only be removed positive mutations, so we'll always give piety.</a>
<a name="ln4012">    if (sacrifice == ABIL_RU_SACRIFICE_PURITY</a>
<a name="ln4013">        || sacrifice == ABIL_RU_SACRIFICE_HEALTH</a>
<a name="ln4014">        || sacrifice == ABIL_RU_SACRIFICE_ESSENCE)</a>
<a name="ln4015">    {</a>
<a name="ln4016">        piety_gain *= 1 + mut_check_conflict(mut);</a>
<a name="ln4017">    }</a>
<a name="ln4018"> </a>
<a name="ln4019">    // Randomize piety gain very slightly to prevent counting.</a>
<a name="ln4020">    // We fuzz the piety gain by up to +-10%, or 5 piety, whichever is smaller.</a>
<a name="ln4021">    int piety_blur_inc = min(5, piety_gain / 10);</a>
<a name="ln4022">    int piety_blur = random2((2 * piety_blur_inc) + 1) - piety_blur_inc;</a>
<a name="ln4023"> </a>
<a name="ln4024">    return piety_gain + piety_blur;</a>
<a name="ln4025">}</a>
<a name="ln4026"> </a>
<a name="ln4027">// Remove the offer of sacrifices after they've been offered for sufficient</a>
<a name="ln4028">// time or it's time to offer something new.</a>
<a name="ln4029">static void _ru_expire_sacrifices()</a>
<a name="ln4030">{</a>
<a name="ln4031">    static const char *sacrifice_keys[] =</a>
<a name="ln4032">    {</a>
<a name="ln4033">        AVAILABLE_SAC_KEY,</a>
<a name="ln4034">        ESSENCE_SAC_KEY,</a>
<a name="ln4035">        HEALTH_SAC_KEY,</a>
<a name="ln4036">        PURITY_SAC_KEY,</a>
<a name="ln4037">        ARCANA_SAC_KEY,</a>
<a name="ln4038">    };</a>
<a name="ln4039"> </a>
<a name="ln4040">    for (auto key : sacrifice_keys)</a>
<a name="ln4041">    {</a>
<a name="ln4042">        ASSERT(you.props.exists(key));</a>
<a name="ln4043">        you.props[key].get_vector().clear();</a>
<a name="ln4044">    }</a>
<a name="ln4045"> </a>
<a name="ln4046">    // Clear out stored sacrfiice values.</a>
<a name="ln4047">    for (int i = 0; i &lt; NUM_ABILITIES; ++i)</a>
<a name="ln4048">        you.sacrifice_piety[i] = 0;</a>
<a name="ln4049">}</a>
<a name="ln4050"> </a>
<a name="ln4051">/**</a>
<a name="ln4052"> * Choose a random sacrifice from those in the list, filtering to only those</a>
<a name="ln4053"> * with piety values &lt;= the given cap.</a>
<a name="ln4054"> *</a>
<a name="ln4055"> * @param possible_sacrifices   The list of sacrifices to choose from.</a>
<a name="ln4056"> * @param min_piety             The maximum sac piety cost to accept.</a>
<a name="ln4057"> * @return                      The ability_type of a valid sacrifice, or</a>
<a name="ln4058"> *                              ABIL_RU_REJECT_SACRIFICES if none were found</a>
<a name="ln4059"> *                              (should never happen!)</a>
<a name="ln4060"> */</a>
<a name="ln4061">static ability_type _random_cheap_sacrifice(</a>
<a name="ln4062">        const vector&lt;ability_type&gt; &amp;possible_sacrifices,</a>
<a name="ln4063">                                            int piety_cap)</a>
<a name="ln4064">{</a>
<a name="ln4065">    // XXX: replace this with random_if when that's merged</a>
<a name="ln4066">    ability_type chosen_sacrifice = ABIL_RU_REJECT_SACRIFICES;</a>
<a name="ln4067">    int valid_sacrifices = 0;</a>
<a name="ln4068">    for (auto sacrifice : possible_sacrifices)</a>
<a name="ln4069">    {</a>
<a name="ln4070">        if (get_sacrifice_piety(sacrifice) + you.piety &gt; piety_cap)</a>
<a name="ln4071">            continue;</a>
<a name="ln4072"> </a>
<a name="ln4073">        ++valid_sacrifices;</a>
<a name="ln4074">        if (one_chance_in(valid_sacrifices))</a>
<a name="ln4075">            chosen_sacrifice = sacrifice;</a>
<a name="ln4076">    }</a>
<a name="ln4077"> </a>
<a name="ln4078">    dprf(&quot;found %d valid sacrifices; chose %d&quot;,</a>
<a name="ln4079">         valid_sacrifices, chosen_sacrifice);</a>
<a name="ln4080"> </a>
<a name="ln4081">    return chosen_sacrifice;</a>
<a name="ln4082">}</a>
<a name="ln4083"> </a>
<a name="ln4084">/**</a>
<a name="ln4085"> * Choose the cheapest remaining sacrifice. This is used when the cheapest</a>
<a name="ln4086"> * remaining sacrifice is over the piety cap and we still need to fill out 3</a>
<a name="ln4087"> * options.</a>
<a name="ln4088"> *</a>
<a name="ln4089"> * @param possible_sacrifices   The list of sacrifices to choose from.</a>
<a name="ln4090"> * @return                      The ability_type of the cheapest remaining</a>
<a name="ln4091"> *                              sacrifice.</a>
<a name="ln4092"> */</a>
<a name="ln4093">static ability_type _get_cheapest_sacrifice(</a>
<a name="ln4094">        const vector&lt;ability_type&gt; &amp;possible_sacrifices)</a>
<a name="ln4095">{</a>
<a name="ln4096">    // XXX: replace this with random_if when that's merged</a>
<a name="ln4097">    ability_type chosen_sacrifice = ABIL_RU_REJECT_SACRIFICES;</a>
<a name="ln4098">    int last_piety = 999;</a>
<a name="ln4099">    int cheapest_sacrifices = 0;</a>
<a name="ln4100">    for (auto sacrifice : possible_sacrifices)</a>
<a name="ln4101">    {</a>
<a name="ln4102">        int sac_piety = get_sacrifice_piety(sacrifice);</a>
<a name="ln4103">        if (sac_piety &gt;= last_piety)</a>
<a name="ln4104">            continue;</a>
<a name="ln4105"> </a>
<a name="ln4106">        ++cheapest_sacrifices;</a>
<a name="ln4107">        if (one_chance_in(cheapest_sacrifices))</a>
<a name="ln4108">        {</a>
<a name="ln4109">            chosen_sacrifice = sacrifice;</a>
<a name="ln4110">            last_piety = sac_piety;</a>
<a name="ln4111">        }</a>
<a name="ln4112">    }</a>
<a name="ln4113"> </a>
<a name="ln4114">    dprf(&quot;found %d cheapest sacrifices; chose %d&quot;,</a>
<a name="ln4115">         cheapest_sacrifices, chosen_sacrifice);</a>
<a name="ln4116"> </a>
<a name="ln4117">    return chosen_sacrifice;</a>
<a name="ln4118">}</a>
<a name="ln4119"> </a>
<a name="ln4120">/**</a>
<a name="ln4121"> * Chooses three distinct sacrifices to offer the player, store them in</a>
<a name="ln4122"> * available_sacrifices, and print a message to the player letting them</a>
<a name="ln4123"> * know that their new sacrifices are ready.</a>
<a name="ln4124"> */</a>
<a name="ln4125">void ru_offer_new_sacrifices()</a>
<a name="ln4126">{</a>
<a name="ln4127">    _ru_expire_sacrifices();</a>
<a name="ln4128"> </a>
<a name="ln4129">    vector&lt;ability_type&gt; possible_sacrifices = _get_possible_sacrifices();</a>
<a name="ln4130"> </a>
<a name="ln4131">    // for now we'll just pick three at random</a>
<a name="ln4132">    int num_sacrifices = possible_sacrifices.size();</a>
<a name="ln4133"> </a>
<a name="ln4134">    const int num_expected_offers = 3;</a>
<a name="ln4135"> </a>
<a name="ln4136">    // This can't happen outside wizmode, but may as well handle gracefully</a>
<a name="ln4137">    if (num_sacrifices &lt; num_expected_offers)</a>
<a name="ln4138">        return;</a>
<a name="ln4139"> </a>
<a name="ln4140">    ASSERT(you.props.exists(AVAILABLE_SAC_KEY));</a>
<a name="ln4141">    CrawlVector &amp;available_sacrifices</a>
<a name="ln4142">        = you.props[AVAILABLE_SAC_KEY].get_vector();</a>
<a name="ln4143"> </a>
<a name="ln4144">    for (int sac_num = 0; sac_num &lt; num_expected_offers; ++sac_num)</a>
<a name="ln4145">    {</a>
<a name="ln4146">        // find the cheapest available sacrifice, in case we're close to ru's</a>
<a name="ln4147">        // max piety. (minimize 'wasted' piety in those cases.)</a>
<a name="ln4148">        const ability_type min_piety_sacrifice</a>
<a name="ln4149">            = accumulate(possible_sacrifices.begin(),</a>
<a name="ln4150">                         possible_sacrifices.end(),</a>
<a name="ln4151">                         ABIL_RU_REJECT_SACRIFICES,</a>
<a name="ln4152">                         [](ability_type a, ability_type b) {</a>
<a name="ln4153">                             return get_sacrifice_piety(a)</a>
<a name="ln4154">                                  &lt; get_sacrifice_piety(b) ? a : b;</a>
<a name="ln4155">                         });</a>
<a name="ln4156">        const int min_piety = get_sacrifice_piety(min_piety_sacrifice);</a>
<a name="ln4157">        const int piety_cap = max(179, you.piety + min_piety);</a>
<a name="ln4158"> </a>
<a name="ln4159">        dprf(&quot;cheapest sac %d (%d piety); cap %d&quot;,</a>
<a name="ln4160">             min_piety_sacrifice, min_piety, piety_cap);</a>
<a name="ln4161"> </a>
<a name="ln4162">        // XXX: replace this with random_if when that's merged</a>
<a name="ln4163">        ability_type chosen_sacrifice</a>
<a name="ln4164">            = _random_cheap_sacrifice(possible_sacrifices, piety_cap);</a>
<a name="ln4165"> </a>
<a name="ln4166">        if (chosen_sacrifice &lt; ABIL_FIRST_SACRIFICE ||</a>
<a name="ln4167">                chosen_sacrifice &gt; ABIL_FINAL_SACRIFICE)</a>
<a name="ln4168">        {</a>
<a name="ln4169">           chosen_sacrifice = _get_cheapest_sacrifice(possible_sacrifices);</a>
<a name="ln4170">        }</a>
<a name="ln4171"> </a>
<a name="ln4172">        if (chosen_sacrifice &gt; ABIL_FINAL_SACRIFICE)</a>
<a name="ln4173">        {</a>
<a name="ln4174">            // We don't have three sacrifices to offer for some reason.</a>
<a name="ln4175">            // Either the player is messing around in wizmode or has rejoined</a>
<a name="ln4176">            // Ru repeatedly. In either case, we'll just stop offering</a>
<a name="ln4177">            // sacrifices rather than crashing.</a>
<a name="ln4178">            _ru_expire_sacrifices();</a>
<a name="ln4179">            ru_reset_sacrifice_timer(false);</a>
<a name="ln4180">            return;</a>
<a name="ln4181">        }</a>
<a name="ln4182"> </a>
<a name="ln4183">        // add it to the list of chosen sacrifices to offer, and remove it from</a>
<a name="ln4184">        // the list of possibilities for the later sacrifices</a>
<a name="ln4185">        available_sacrifices.push_back(chosen_sacrifice);</a>
<a name="ln4186">        you.sacrifice_piety[chosen_sacrifice] =</a>
<a name="ln4187">                                get_sacrifice_piety(chosen_sacrifice, false);</a>
<a name="ln4188">        possible_sacrifices.erase(remove(possible_sacrifices.begin(),</a>
<a name="ln4189">                                         possible_sacrifices.end(),</a>
<a name="ln4190">                                         chosen_sacrifice),</a>
<a name="ln4191">                                  possible_sacrifices.end());</a>
<a name="ln4192">    }</a>
<a name="ln4193"> </a>
<a name="ln4194">    simple_god_message(&quot; believes you are ready to make a new sacrifice.&quot;);</a>
<a name="ln4195">    // included in default force_more_message</a>
<a name="ln4196">}</a>
<a name="ln4197"> </a>
<a name="ln4198">/// What key corresponds to the potential/chosen mut(s) for this sacrifice?</a>
<a name="ln4199">string ru_sacrifice_vector(ability_type sac)</a>
<a name="ln4200">{</a>
<a name="ln4201">    const sacrifice_def &amp;sac_def = _get_sacrifice_def(sac);</a>
<a name="ln4202">    return sac_def.sacrifice_vector ? sac_def.sacrifice_vector : &quot;&quot;;</a>
<a name="ln4203">}</a>
<a name="ln4204"> </a>
<a name="ln4205">static const char* _describe_sacrifice_piety_gain(int piety_gain)</a>
<a name="ln4206">{</a>
<a name="ln4207">    if (piety_gain &gt;= 40)</a>
<a name="ln4208">        return &quot;an incredible&quot;;</a>
<a name="ln4209">    else if (piety_gain &gt;= 29)</a>
<a name="ln4210">        return &quot;a major&quot;;</a>
<a name="ln4211">    else if (piety_gain &gt;= 21)</a>
<a name="ln4212">        return &quot;a significant&quot;;</a>
<a name="ln4213">    else if (piety_gain &gt;= 13)</a>
<a name="ln4214">        return &quot;a modest&quot;;</a>
<a name="ln4215">    else</a>
<a name="ln4216">        return &quot;a trivial&quot;;</a>
<a name="ln4217">}</a>
<a name="ln4218"> </a>
<a name="ln4219">static const string _piety_asterisks(int piety)</a>
<a name="ln4220">{</a>
<a name="ln4221">    const int prank = piety_rank(piety);</a>
<a name="ln4222">    return string(prank, '*') + string(NUM_PIETY_STARS - prank, '.');</a>
<a name="ln4223">}</a>
<a name="ln4224"> </a>
<a name="ln4225">static void _apply_ru_sacrifice(mutation_type sacrifice)</a>
<a name="ln4226">{</a>
<a name="ln4227">    perma_mutate(sacrifice, 1, &quot;Ru sacrifice&quot;);</a>
<a name="ln4228">    you.sacrifices[sacrifice] += 1;</a>
<a name="ln4229">}</a>
<a name="ln4230"> </a>
<a name="ln4231">static bool _execute_sacrifice(ability_type sac, const char* message)</a>
<a name="ln4232">{</a>
<a name="ln4233">    mprf(&quot;Ru asks you to %s.&quot;, message);</a>
<a name="ln4234">    mpr(ru_sacrifice_description(sac));</a>
<a name="ln4235">    if (!yesno(&quot;Do you really want to make this sacrifice?&quot;,</a>
<a name="ln4236">               false, 'n'))</a>
<a name="ln4237">    {</a>
<a name="ln4238">        canned_msg(MSG_OK);</a>
<a name="ln4239">        return false;</a>
<a name="ln4240">    }</a>
<a name="ln4241">    return true;</a>
<a name="ln4242">}</a>
<a name="ln4243"> </a>
<a name="ln4244">static void _ru_kill_skill(skill_type skill)</a>
<a name="ln4245">{</a>
<a name="ln4246">    change_skill_points(skill, -you.skill_points[skill], true);</a>
<a name="ln4247">    you.can_currently_train.set(skill, false);</a>
<a name="ln4248">    reset_training();</a>
<a name="ln4249">    check_selected_skills();</a>
<a name="ln4250">}</a>
<a name="ln4251"> </a>
<a name="ln4252">static void _extra_sacrifice_code(ability_type sac)</a>
<a name="ln4253">{</a>
<a name="ln4254">    const sacrifice_def &amp;sac_def = _get_sacrifice_def(sac);</a>
<a name="ln4255">    if (sac_def.sacrifice == ABIL_RU_SACRIFICE_HAND)</a>
<a name="ln4256">    {</a>
<a name="ln4257">        equipment_type ring_slot;</a>
<a name="ln4258"> </a>
<a name="ln4259">        if (you.species == SP_OCTOPODE)</a>
<a name="ln4260">            ring_slot = EQ_RING_EIGHT;</a>
<a name="ln4261">        else</a>
<a name="ln4262">            ring_slot = EQ_LEFT_RING;</a>
<a name="ln4263"> </a>
<a name="ln4264">        item_def* const shield = you.slot_item(EQ_SHIELD, true);</a>
<a name="ln4265">        item_def* const weapon = you.slot_item(EQ_WEAPON, true);</a>
<a name="ln4266">        item_def* const ring = you.slot_item(ring_slot, true);</a>
<a name="ln4267">        int ring_inv_slot = you.equip[ring_slot];</a>
<a name="ln4268">        bool open_ring_slot = false;</a>
<a name="ln4269"> </a>
<a name="ln4270">        // Drop your shield if there is one</a>
<a name="ln4271">        if (shield != nullptr)</a>
<a name="ln4272">        {</a>
<a name="ln4273">            mprf(&quot;You can no longer hold %s!&quot;,</a>
<a name="ln4274">                shield-&gt;name(DESC_YOUR).c_str());</a>
<a name="ln4275">            unequip_item(EQ_SHIELD);</a>
<a name="ln4276">        }</a>
<a name="ln4277"> </a>
<a name="ln4278">        // And your two-handed weapon</a>
<a name="ln4279">        if (weapon != nullptr)</a>
<a name="ln4280">        {</a>
<a name="ln4281">            if (you.hands_reqd(*weapon) == HANDS_TWO)</a>
<a name="ln4282">            {</a>
<a name="ln4283">                mprf(&quot;You can no longer hold %s!&quot;,</a>
<a name="ln4284">                    weapon-&gt;name(DESC_YOUR).c_str());</a>
<a name="ln4285">                unequip_item(EQ_WEAPON);</a>
<a name="ln4286">            }</a>
<a name="ln4287">        }</a>
<a name="ln4288"> </a>
<a name="ln4289">        // And one ring</a>
<a name="ln4290">        if (ring != nullptr)</a>
<a name="ln4291">        {</a>
<a name="ln4292">            if (you.species == SP_OCTOPODE)</a>
<a name="ln4293">            {</a>
<a name="ln4294">                for (int eq = EQ_RING_ONE; eq &lt;= EQ_RING_SEVEN; eq++)</a>
<a name="ln4295">                {</a>
<a name="ln4296">                    if (!you.slot_item(static_cast&lt;equipment_type&gt;(eq), true))</a>
<a name="ln4297">                    {</a>
<a name="ln4298">                        open_ring_slot = true;</a>
<a name="ln4299">                        break;</a>
<a name="ln4300">                    }</a>
<a name="ln4301">                }</a>
<a name="ln4302">            }</a>
<a name="ln4303">            else</a>
<a name="ln4304">            {</a>
<a name="ln4305">                if (!you.slot_item(static_cast&lt;equipment_type&gt;(</a>
<a name="ln4306">                    EQ_RIGHT_RING), true))</a>
<a name="ln4307">                {</a>
<a name="ln4308">                    open_ring_slot = true;</a>
<a name="ln4309">                }</a>
<a name="ln4310">            }</a>
<a name="ln4311"> </a>
<a name="ln4312">            mprf(&quot;You can no longer wear %s!&quot;,</a>
<a name="ln4313">                ring-&gt;name(DESC_YOUR).c_str());</a>
<a name="ln4314">            unequip_item(ring_slot);</a>
<a name="ln4315">            if (open_ring_slot)</a>
<a name="ln4316">            {</a>
<a name="ln4317">                mprf(&quot;You put %s back on %s %s!&quot;,</a>
<a name="ln4318">                     ring-&gt;name(DESC_YOUR).c_str(),</a>
<a name="ln4319">                     (you.species == SP_OCTOPODE ? &quot;another&quot; : &quot;your other&quot;),</a>
<a name="ln4320">                     you.hand_name(true).c_str());</a>
<a name="ln4321">                puton_ring(ring_inv_slot, false);</a>
<a name="ln4322">            }</a>
<a name="ln4323">        }</a>
<a name="ln4324">    }</a>
<a name="ln4325">    else if (sac_def.sacrifice == ABIL_RU_SACRIFICE_EXPERIENCE)</a>
<a name="ln4326">        adjust_level(-RU_SAC_XP_LEVELS);</a>
<a name="ln4327">    else if (sac_def.sacrifice == ABIL_RU_SACRIFICE_SKILL)</a>
<a name="ln4328">    {</a>
<a name="ln4329">        uint8_t saved_skills[NUM_SKILLS];</a>
<a name="ln4330">        for (skill_type sk = SK_FIRST_SKILL; sk &lt; NUM_SKILLS; ++sk)</a>
<a name="ln4331">        {</a>
<a name="ln4332">            saved_skills[sk] = you.skills[sk];</a>
<a name="ln4333">            check_skill_level_change(sk, false);</a>
<a name="ln4334">        }</a>
<a name="ln4335"> </a>
<a name="ln4336">        // Produce messages about skill increases/decreases. We</a>
<a name="ln4337">        // restore one skill level at a time so that at most the</a>
<a name="ln4338">        // skill being checked is at the wrong level.</a>
<a name="ln4339">        for (skill_type sk = SK_FIRST_SKILL; sk &lt; NUM_SKILLS; ++sk)</a>
<a name="ln4340">        {</a>
<a name="ln4341">            you.skills[sk] = saved_skills[sk];</a>
<a name="ln4342">            check_skill_level_change(sk);</a>
<a name="ln4343">        }</a>
<a name="ln4344"> </a>
<a name="ln4345">        redraw_screen();</a>
<a name="ln4346">    }</a>
<a name="ln4347">}</a>
<a name="ln4348"> </a>
<a name="ln4349">/**</a>
<a name="ln4350"> * Describe variable costs for a given Ru sacrifice being offered.</a>
<a name="ln4351"> *</a>
<a name="ln4352"> * @param sac       The sacrifice in question.</a>
<a name="ln4353"> * @return          Extra costs.</a>
<a name="ln4354"> *                  For ABIL_RU_SACRIFICE_ARCANA: e.g. &quot; (Tloc/Air/Fire)&quot;</a>
<a name="ln4355"> *                  For other variable muts: e.g. &quot; (frail)&quot;</a>
<a name="ln4356"> *                  Otherwise, &quot;&quot;.</a>
<a name="ln4357"> */</a>
<a name="ln4358">string ru_sac_text(ability_type sac)</a>
<a name="ln4359">{</a>
<a name="ln4360">    const sacrifice_def &amp;sac_def = _get_sacrifice_def(sac);</a>
<a name="ln4361">    if (!sac_def.sacrifice_vector)</a>
<a name="ln4362">        return &quot;&quot;;</a>
<a name="ln4363"> </a>
<a name="ln4364">    ASSERT(you.props.exists(sac_def.sacrifice_vector));</a>
<a name="ln4365">    const CrawlVector &amp;sacrifice_muts =</a>
<a name="ln4366">        you.props[sac_def.sacrifice_vector].get_vector();</a>
<a name="ln4367"> </a>
<a name="ln4368">    if (sac != ABIL_RU_SACRIFICE_ARCANA)</a>
<a name="ln4369">    {</a>
<a name="ln4370">        ASSERT(sacrifice_muts.size() == 1);</a>
<a name="ln4371">        const mutation_type mut = AS_MUT(sacrifice_muts[0]);</a>
<a name="ln4372">        return make_stringf(&quot; (%s)&quot;, mutation_name(mut));</a>
<a name="ln4373">    }</a>
<a name="ln4374"> </a>
<a name="ln4375">    // &quot;Tloc/Fire/Ice&quot;</a>
<a name="ln4376">    const string school_names</a>
<a name="ln4377">        = comma_separated_fn(sacrifice_muts.begin(), sacrifice_muts.end(),</a>
<a name="ln4378">                [](CrawlStoreValue mut) {</a>
<a name="ln4379">                    return _arcane_mutation_to_school_abbr(AS_MUT(mut));</a>
<a name="ln4380">                }, &quot;/&quot;, &quot;/&quot;);</a>
<a name="ln4381"> </a>
<a name="ln4382">    return make_stringf(&quot; (%s)&quot;, school_names.c_str());</a>
<a name="ln4383">}</a>
<a name="ln4384"> </a>
<a name="ln4385">static int _ru_get_sac_piety_gain(ability_type sac)</a>
<a name="ln4386">{</a>
<a name="ln4387">    const sacrifice_def &amp;sac_def = _get_sacrifice_def(sac);</a>
<a name="ln4388"> </a>
<a name="ln4389">    // If we're haven't yet calculated piety gain, get it now. Otherwise,</a>
<a name="ln4390">    // use the calculated value and then add in the skill piety, which isn't</a>
<a name="ln4391">    // saved because it can change over time.</a>
<a name="ln4392">    const int base_piety_gain = you.sacrifice_piety[sac];</a>
<a name="ln4393"> </a>
<a name="ln4394">    if (base_piety_gain == 0)</a>
<a name="ln4395">        return get_sacrifice_piety(sac);</a>
<a name="ln4396"> </a>
<a name="ln4397">    if (sac_def.sacrifice_skill != SK_NONE)</a>
<a name="ln4398">        return base_piety_gain + _piety_for_skill_by_sacrifice(sac);</a>
<a name="ln4399"> </a>
<a name="ln4400">    return base_piety_gain;</a>
<a name="ln4401">}</a>
<a name="ln4402"> </a>
<a name="ln4403">string ru_sacrifice_description(ability_type sac)</a>
<a name="ln4404">{</a>
<a name="ln4405">    if (!you_worship(GOD_RU))</a>
<a name="ln4406">        return &quot;&quot;;</a>
<a name="ln4407"> </a>
<a name="ln4408">    const int piety_gain = _ru_get_sac_piety_gain(sac);</a>
<a name="ln4409">    return make_stringf(&quot;This is %s sacrifice. Piety after sacrifice: %s&quot;,</a>
<a name="ln4410">                        _describe_sacrifice_piety_gain(piety_gain),</a>
<a name="ln4411">                        _piety_asterisks(you.piety + piety_gain).c_str());</a>
<a name="ln4412">}</a>
<a name="ln4413"> </a>
<a name="ln4414"> </a>
<a name="ln4415">bool ru_do_sacrifice(ability_type sac)</a>
<a name="ln4416">{</a>
<a name="ln4417">    const sacrifice_def &amp;sac_def = _get_sacrifice_def(sac);</a>
<a name="ln4418">    bool variable_sac;</a>
<a name="ln4419">    mutation_type mut = MUT_NON_MUTATION;</a>
<a name="ln4420">    int num_sacrifices;</a>
<a name="ln4421">    string offer_text;</a>
<a name="ln4422">    string mile_text;</a>
<a name="ln4423">    string sac_text;</a>
<a name="ln4424">    const bool is_sac_arcana = sac == ABIL_RU_SACRIFICE_ARCANA;</a>
<a name="ln4425"> </a>
<a name="ln4426">    // For variable sacrifices, we need to compose the text that will be</a>
<a name="ln4427">    // displayed at the time of sacrifice offer and as a milestone if the</a>
<a name="ln4428">    // sacrifice is accepted. We also need to figure out piety.</a>
<a name="ln4429">    if (sac_def.sacrifice_vector)</a>
<a name="ln4430">    {</a>
<a name="ln4431">        variable_sac = true;</a>
<a name="ln4432">        ASSERT(you.props.exists(sac_def.sacrifice_vector));</a>
<a name="ln4433">        CrawlVector &amp;sacrifice_muts =</a>
<a name="ln4434">            you.props[sac_def.sacrifice_vector].get_vector();</a>
<a name="ln4435">        num_sacrifices = sacrifice_muts.size();</a>
<a name="ln4436"> </a>
<a name="ln4437">        for (int i = 0; i &lt; num_sacrifices; i++)</a>
<a name="ln4438">        {</a>
<a name="ln4439">            mut = AS_MUT(sacrifice_muts[i]);</a>
<a name="ln4440"> </a>
<a name="ln4441">            // format the text that will be displayed</a>
<a name="ln4442">            if (is_sac_arcana)</a>
<a name="ln4443">            {</a>
<a name="ln4444">                if (i == num_sacrifices - 1)</a>
<a name="ln4445">                {</a>
<a name="ln4446">                    sac_text = make_stringf(&quot;%sand %s&quot;, sac_text.c_str(),</a>
<a name="ln4447">                        _arcane_mutation_to_school_name(mut));</a>
<a name="ln4448">                }</a>
<a name="ln4449">                else</a>
<a name="ln4450">                {</a>
<a name="ln4451">                    sac_text = make_stringf(&quot;%s%s, &quot;, sac_text.c_str(),</a>
<a name="ln4452">                        _arcane_mutation_to_school_name(mut));</a>
<a name="ln4453">                }</a>
<a name="ln4454">            }</a>
<a name="ln4455">            else</a>
<a name="ln4456">                sac_text = mut_upgrade_summary(mut);</a>
<a name="ln4457">        }</a>
<a name="ln4458">        offer_text = make_stringf(&quot;%s: %s&quot;, sac_def.sacrifice_text,</a>
<a name="ln4459">            sac_text.c_str());</a>
<a name="ln4460">        mile_text = make_stringf(&quot;%s: %s.&quot;, sac_def.milestone_text,</a>
<a name="ln4461">            sac_text.c_str());</a>
<a name="ln4462">    }</a>
<a name="ln4463">    else</a>
<a name="ln4464">    {</a>
<a name="ln4465">        variable_sac = false;</a>
<a name="ln4466">        mut = sac_def.mutation;</a>
<a name="ln4467">        num_sacrifices = 1;</a>
<a name="ln4468">        string handtxt = &quot;&quot;;</a>
<a name="ln4469">        if (sac == ABIL_RU_SACRIFICE_HAND)</a>
<a name="ln4470">            handtxt = you.hand_name(true);</a>
<a name="ln4471"> </a>
<a name="ln4472">        offer_text = sac_def.sacrifice_text + handtxt;</a>
<a name="ln4473">        mile_text = make_stringf(&quot;%s.&quot;, sac_def.milestone_text);</a>
<a name="ln4474">    }</a>
<a name="ln4475"> </a>
<a name="ln4476">    // get confirmation that the sacrifice is desired.</a>
<a name="ln4477">    if (!_execute_sacrifice(sac, offer_text.c_str()))</a>
<a name="ln4478">        return false;</a>
<a name="ln4479">    // save piety gain, since sacrificing skills can lower the piety gain</a>
<a name="ln4480">    const int piety_gain = _ru_get_sac_piety_gain(sac);</a>
<a name="ln4481">    // Apply the sacrifice, starting by mutating the player.</a>
<a name="ln4482">    if (variable_sac)</a>
<a name="ln4483">    {</a>
<a name="ln4484">        CrawlVector &amp;sacrifice_muts =</a>
<a name="ln4485">            you.props[sac_def.sacrifice_vector].get_vector();</a>
<a name="ln4486">        for (int i = 0; i &lt; num_sacrifices; i++)</a>
<a name="ln4487">        {</a>
<a name="ln4488">            mut = AS_MUT(sacrifice_muts[i]);</a>
<a name="ln4489">            _apply_ru_sacrifice(mut);</a>
<a name="ln4490">        }</a>
<a name="ln4491">    }</a>
<a name="ln4492">    else</a>
<a name="ln4493">        _apply_ru_sacrifice(mut);</a>
<a name="ln4494"> </a>
<a name="ln4495">    // Remove any no-longer-usable skills.</a>
<a name="ln4496">    if (is_sac_arcana)</a>
<a name="ln4497">    {</a>
<a name="ln4498">        skill_type arcane_skill;</a>
<a name="ln4499">        mutation_type arcane_mut;</a>
<a name="ln4500">        CrawlVector &amp;sacrifice_muts =</a>
<a name="ln4501">            you.props[sac_def.sacrifice_vector].get_vector();</a>
<a name="ln4502">        for (int i = 0; i &lt; num_sacrifices; i++)</a>
<a name="ln4503">        {</a>
<a name="ln4504">            arcane_mut = AS_MUT(sacrifice_muts[i]);</a>
<a name="ln4505">            arcane_skill = arcane_mutation_to_skill(arcane_mut);</a>
<a name="ln4506">            _ru_kill_skill(arcane_skill);</a>
<a name="ln4507">        }</a>
<a name="ln4508">    }</a>
<a name="ln4509">    else if (sac_def.sacrifice_skill != SK_NONE)</a>
<a name="ln4510">        _ru_kill_skill(sac_def.sacrifice_skill);</a>
<a name="ln4511"> </a>
<a name="ln4512">    // Maybe this should go in _extra_sacrifice_code, but it would be</a>
<a name="ln4513">    // inconsistent for the milestone to have reduced Shields skill</a>
<a name="ln4514">    // but not the others.</a>
<a name="ln4515">    if (sac == ABIL_RU_SACRIFICE_HAND)</a>
<a name="ln4516">    {</a>
<a name="ln4517">        // No one-handed staves for small races.</a>
<a name="ln4518">        if (species_size(you.species, PSIZE_TORSO) &lt;= SIZE_SMALL)</a>
<a name="ln4519">            _ru_kill_skill(SK_STAVES);</a>
<a name="ln4520">        // No one-handed bows.</a>
<a name="ln4521">        if (you.species != SP_FORMICID)</a>
<a name="ln4522">            _ru_kill_skill(SK_BOWS);</a>
<a name="ln4523">    }</a>
<a name="ln4524"> </a>
<a name="ln4525">    mark_milestone(&quot;sacrifice&quot;, mile_text);</a>
<a name="ln4526"> </a>
<a name="ln4527">    // Any special handling that's needed.</a>
<a name="ln4528">    _extra_sacrifice_code(sac);</a>
<a name="ln4529"> </a>
<a name="ln4530">    // Update how many Ru sacrifices you have. This is used to avoid giving the</a>
<a name="ln4531">    // player extra silver damage.</a>
<a name="ln4532">    if (you.props.exists(&quot;num_sacrifice_muts&quot;))</a>
<a name="ln4533">    {</a>
<a name="ln4534">        you.props[&quot;num_sacrifice_muts&quot;] = num_sacrifices +</a>
<a name="ln4535">            you.props[&quot;num_sacrifice_muts&quot;].get_int();</a>
<a name="ln4536">    }</a>
<a name="ln4537">    else</a>
<a name="ln4538">        you.props[&quot;num_sacrifice_muts&quot;] = num_sacrifices;</a>
<a name="ln4539"> </a>
<a name="ln4540">    // Actually give the piety for this sacrifice.</a>
<a name="ln4541">    set_piety(min(piety_breakpoint(5), you.piety + piety_gain));</a>
<a name="ln4542"> </a>
<a name="ln4543">    if (you.piety == piety_breakpoint(5))</a>
<a name="ln4544">        simple_god_message(&quot; indicates that your awakening is complete.&quot;);</a>
<a name="ln4545"> </a>
<a name="ln4546">    // Clean up.</a>
<a name="ln4547">    _ru_expire_sacrifices();</a>
<a name="ln4548">    ru_reset_sacrifice_timer(true);</a>
<a name="ln4549">    redraw_screen(); // pretty much everything could have changed</a>
<a name="ln4550">    return true;</a>
<a name="ln4551">}</a>
<a name="ln4552"> </a>
<a name="ln4553">/**</a>
<a name="ln4554"> * If forced_rejection is false, prompt the player if they want to reject the</a>
<a name="ln4555"> * currently offered sacrifices. If true, or if the prompt is accepted,</a>
<a name="ln4556"> * remove the currently offered sacrifices &amp; increase the time until the next</a>
<a name="ln4557"> * sacrifices will be offered.</a>
<a name="ln4558"> *</a>
<a name="ln4559"> * @param forced_rejection      Whether the rejection is caused by the removal</a>
<a name="ln4560"> *                              of an amulet of faith, in which case there's</a>
<a name="ln4561"> *                              no prompt &amp; an increased sac time penalty.</a>
<a name="ln4562"> * @return                      Whether the sacrifices were actually rejected.</a>
<a name="ln4563"> */</a>
<a name="ln4564">bool ru_reject_sacrifices(bool forced_rejection)</a>
<a name="ln4565">{</a>
<a name="ln4566">    if (!forced_rejection &amp;&amp;</a>
<a name="ln4567">        !yesno(&quot;Do you really want to reject the sacrifices Ru is offering?&quot;,</a>
<a name="ln4568">               false, 'n'))</a>
<a name="ln4569">    {</a>
<a name="ln4570">        canned_msg(MSG_OK);</a>
<a name="ln4571">        return false;</a>
<a name="ln4572">    }</a>
<a name="ln4573"> </a>
<a name="ln4574">    ru_reset_sacrifice_timer(false, true);</a>
<a name="ln4575">    _ru_expire_sacrifices();</a>
<a name="ln4576">    simple_god_message(&quot; will take longer to evaluate your readiness.&quot;);</a>
<a name="ln4577">    return true;</a>
<a name="ln4578">}</a>
<a name="ln4579"> </a>
<a name="ln4580">/**</a>
<a name="ln4581"> * Reset the time until the next set of Ru sacrifices are offered.</a>
<a name="ln4582"> *</a>
<a name="ln4583"> * @param clear_timer       Whether to reset the timer to the base time-between-</a>
<a name="ln4584"> *                          sacrifices, rather than adding to it.</a>
<a name="ln4585"> * @param faith_penalty     Whether this is a penalty for removing &quot;faith.</a>
<a name="ln4586"> */</a>
<a name="ln4587">void ru_reset_sacrifice_timer(bool clear_timer, bool faith_penalty)</a>
<a name="ln4588">{</a>
<a name="ln4589">    ASSERT(you.props.exists(RU_SACRIFICE_PROGRESS_KEY));</a>
<a name="ln4590">    ASSERT(you.props.exists(RU_SACRIFICE_DELAY_KEY));</a>
<a name="ln4591">    ASSERT(you.props.exists(RU_SACRIFICE_PENALTY_KEY));</a>
<a name="ln4592"> </a>
<a name="ln4593">    // raise the delay if there's an active sacrifice, and more so the more</a>
<a name="ln4594">    // often you pass on a sacrifice and the more piety you have.</a>
<a name="ln4595">    const int base_delay = 80;</a>
<a name="ln4596">    int delay = you.props[RU_SACRIFICE_DELAY_KEY].get_int();</a>
<a name="ln4597">    int added_delay;</a>
<a name="ln4598">    if (clear_timer)</a>
<a name="ln4599">    {</a>
<a name="ln4600">        added_delay = 0;</a>
<a name="ln4601">        delay = base_delay;</a>
<a name="ln4602">        you.props[RU_SACRIFICE_PENALTY_KEY] = 0;</a>
<a name="ln4603">    }</a>
<a name="ln4604">    else</a>
<a name="ln4605">    {</a>
<a name="ln4606">        // if you rejected a sacrifice, add between 33 and 53 to the timer,</a>
<a name="ln4607">        // based on piety. This extra delay stacks with any added delay for</a>
<a name="ln4608">        // previous rejections.</a>
<a name="ln4609">        added_delay = you.props[RU_SACRIFICE_PENALTY_KEY].get_int();</a>
<a name="ln4610">        const int new_penalty = (max(100, static_cast&lt;int&gt;(you.piety))) / 3;</a>
<a name="ln4611">        added_delay += new_penalty;</a>
<a name="ln4612"> </a>
<a name="ln4613">        // longer delay for each real rejection</a>
<a name="ln4614">        if (!you.props[AVAILABLE_SAC_KEY].get_vector().empty())</a>
<a name="ln4615">            you.props[RU_SACRIFICE_PENALTY_KEY] = added_delay;</a>
<a name="ln4616"> </a>
<a name="ln4617">        if (faith_penalty)</a>
<a name="ln4618">        {</a>
<a name="ln4619">            // the player will end up waiting longer than they would otherwise,</a>
<a name="ln4620">            // but multiple removals of the amulet of faith won't stack -</a>
<a name="ln4621">            // they'll just put the player back to around the same delay</a>
<a name="ln4622">            // each time.</a>
<a name="ln4623">            added_delay += new_penalty * 2;</a>
<a name="ln4624">            delay = base_delay;</a>
<a name="ln4625">        }</a>
<a name="ln4626">    }</a>
<a name="ln4627"> </a>
<a name="ln4628">    delay = div_rand_round((delay + added_delay) * (3 - you.faith()), 3);</a>
<a name="ln4629">    if (crawl_state.game_is_sprint())</a>
<a name="ln4630">        delay /= SPRINT_MULTIPLIER;</a>
<a name="ln4631"> </a>
<a name="ln4632">    you.props[RU_SACRIFICE_DELAY_KEY] = delay;</a>
<a name="ln4633">    you.props[RU_SACRIFICE_PROGRESS_KEY] = 0;</a>
<a name="ln4634">}</a>
<a name="ln4635"> </a>
<a name="ln4636">// Check to see if you're eligible to retaliate.</a>
<a name="ln4637">//Your chance of eligiblity scales with piety.</a>
<a name="ln4638">bool will_ru_retaliate()</a>
<a name="ln4639">{</a>
<a name="ln4640">    // Scales up to a 25% chance of retribution</a>
<a name="ln4641">    return have_passive(passive_t::upgraded_aura_of_power)</a>
<a name="ln4642">           &amp;&amp; crawl_state.which_god_acting() != GOD_RU</a>
<a name="ln4643">           &amp;&amp; one_chance_in(div_rand_round(640, you.piety));</a>
<a name="ln4644">}</a>
<a name="ln4645"> </a>
<a name="ln4646">// Power of retribution increases with damage, decreases with monster HD.</a>
<a name="ln4647">void ru_do_retribution(monster* mons, int damage)</a>
<a name="ln4648">{</a>
<a name="ln4649">    int power = max(0, random2(div_rand_round(you.piety*10, 32))</a>
<a name="ln4650">        + damage - (2 * mons-&gt;get_hit_dice()));</a>
<a name="ln4651">    const actor* act = &amp;you;</a>
<a name="ln4652"> </a>
<a name="ln4653">    if (power &gt; 50 &amp;&amp; (mons-&gt;antimagic_susceptible()))</a>
<a name="ln4654">    {</a>
<a name="ln4655">        mprf(MSGCH_GOD, &quot;You focus your will and drain %s's magic in &quot;</a>
<a name="ln4656">                &quot;retribution!&quot;, mons-&gt;name(DESC_THE).c_str());</a>
<a name="ln4657">        mons-&gt;add_ench(mon_enchant(ENCH_ANTIMAGIC, 1, act, power+random2(320)));</a>
<a name="ln4658">    }</a>
<a name="ln4659">    else if (power &gt; 35)</a>
<a name="ln4660">    {</a>
<a name="ln4661">        mprf(MSGCH_GOD, &quot;You focus your will and paralyse %s in retribution!&quot;,</a>
<a name="ln4662">                mons-&gt;name(DESC_THE).c_str());</a>
<a name="ln4663">        mons-&gt;add_ench(mon_enchant(ENCH_PARALYSIS, 1, act, power+random2(60)));</a>
<a name="ln4664">    }</a>
<a name="ln4665">    else if (power &gt; 25)</a>
<a name="ln4666">    {</a>
<a name="ln4667">        mprf(MSGCH_GOD, &quot;You focus your will and slow %s in retribution!&quot;,</a>
<a name="ln4668">                mons-&gt;name(DESC_THE).c_str());</a>
<a name="ln4669">        mons-&gt;add_ench(mon_enchant(ENCH_SLOW, 1, act, power+random2(100)));</a>
<a name="ln4670">    }</a>
<a name="ln4671">    else if (power &gt; 10 &amp;&amp; mons_can_be_blinded(mons-&gt;type))</a>
<a name="ln4672">    {</a>
<a name="ln4673">        mprf(MSGCH_GOD, &quot;You focus your will and blind %s in retribution!&quot;,</a>
<a name="ln4674">                mons-&gt;name(DESC_THE).c_str());</a>
<a name="ln4675">        mons-&gt;add_ench(mon_enchant(ENCH_BLIND, 1, act, power+random2(100)));</a>
<a name="ln4676">    }</a>
<a name="ln4677">    else if (power &gt; 0)</a>
<a name="ln4678">    {</a>
<a name="ln4679">        mprf(MSGCH_GOD, &quot;You focus your will and illuminate %s in retribution!&quot;,</a>
<a name="ln4680">                mons-&gt;name(DESC_THE).c_str());</a>
<a name="ln4681">        mons-&gt;add_ench(mon_enchant(ENCH_CORONA, 1, act, power+random2(150)));</a>
<a name="ln4682">    }</a>
<a name="ln4683">}</a>
<a name="ln4684"> </a>
<a name="ln4685">void ru_draw_out_power()</a>
<a name="ln4686">{</a>
<a name="ln4687">    mpr(&quot;You are restored by drawing out deep reserves of power within.&quot;);</a>
<a name="ln4688"> </a>
<a name="ln4689">    //Escape nets and webs</a>
<a name="ln4690">    int net = get_trapping_net(you.pos());</a>
<a name="ln4691">    if (net == NON_ITEM)</a>
<a name="ln4692">    {</a>
<a name="ln4693">        trap_def *trap = trap_at(you.pos());</a>
<a name="ln4694">        if (trap &amp;&amp; trap-&gt;type == TRAP_WEB)</a>
<a name="ln4695">        {</a>
<a name="ln4696">            destroy_trap(you.pos());</a>
<a name="ln4697">            // XXX: destroying them is dubious in general - abuseable by loons?</a>
<a name="ln4698">            // (but definitely destroy if ammo == 1, per trap-def.h!)</a>
<a name="ln4699">            mpr(&quot;You burst free from the webs!&quot;);</a>
<a name="ln4700">        }</a>
<a name="ln4701">    }</a>
<a name="ln4702">    else</a>
<a name="ln4703">    {</a>
<a name="ln4704">        destroy_item(net);</a>
<a name="ln4705">        mpr(&quot;You burst free from the net!&quot;);</a>
<a name="ln4706">    }</a>
<a name="ln4707">    stop_being_held();</a>
<a name="ln4708"> </a>
<a name="ln4709">    // Escape constriction</a>
<a name="ln4710">    you.stop_being_constricted(false);</a>
<a name="ln4711"> </a>
<a name="ln4712">    // cancel petrification/confusion/slow</a>
<a name="ln4713">    you.duration[DUR_CONF] = 0;</a>
<a name="ln4714">    you.duration[DUR_SLOW] = 0;</a>
<a name="ln4715">    you.duration[DUR_PETRIFYING] = 0;</a>
<a name="ln4716"> </a>
<a name="ln4717">    int hp_inc = div_rand_round(you.piety, 16);</a>
<a name="ln4718">    hp_inc += roll_dice(div_rand_round(you.piety, 20), 6);</a>
<a name="ln4719">    inc_hp(hp_inc);</a>
<a name="ln4720">    int mp_inc = div_rand_round(you.piety, 48);</a>
<a name="ln4721">    mp_inc += roll_dice(div_rand_round(you.piety, 40), 4);</a>
<a name="ln4722">    inc_mp(mp_inc);</a>
<a name="ln4723">    drain_player(30, false, true);</a>
<a name="ln4724">}</a>
<a name="ln4725"> </a>
<a name="ln4726">bool ru_power_leap()</a>
<a name="ln4727">{</a>
<a name="ln4728">    ASSERT(!crawl_state.game_is_arena());</a>
<a name="ln4729"> </a>
<a name="ln4730">    if (crawl_state.is_repeating_cmd())</a>
<a name="ln4731">    {</a>
<a name="ln4732">        crawl_state.cant_cmd_repeat(&quot;You can't repeat power leap.&quot;);</a>
<a name="ln4733">        crawl_state.cancel_cmd_again();</a>
<a name="ln4734">        crawl_state.cancel_cmd_repeat();</a>
<a name="ln4735">        return false;</a>
<a name="ln4736">    }</a>
<a name="ln4737">    if (you.is_nervous())</a>
<a name="ln4738">    {</a>
<a name="ln4739">        mpr(&quot;You are too terrified to leap around!&quot;);</a>
<a name="ln4740">        return false;</a>
<a name="ln4741">    }</a>
<a name="ln4742"> </a>
<a name="ln4743">    // query for location:</a>
<a name="ln4744">    dist beam;</a>
<a name="ln4745"> </a>
<a name="ln4746">    while (1)</a>
<a name="ln4747">    {</a>
<a name="ln4748">        direction_chooser_args args;</a>
<a name="ln4749">        args.restricts = DIR_LEAP;</a>
<a name="ln4750">        args.mode = TARG_ANY;</a>
<a name="ln4751">        args.range = 3;</a>
<a name="ln4752">        args.needs_path = false;</a>
<a name="ln4753">        args.top_prompt = &quot;Aiming: &lt;white&gt;Power Leap&lt;/white&gt;&quot;;</a>
<a name="ln4754">        args.self = confirm_prompt_type::cancel;</a>
<a name="ln4755">        const int explosion_size = 1;</a>
<a name="ln4756">        targeter_smite tgt(&amp;you, args.range, explosion_size, explosion_size);</a>
<a name="ln4757">        tgt.obeys_mesmerise = true;</a>
<a name="ln4758">        args.hitfunc = &amp;tgt;</a>
<a name="ln4759">        direction(beam, args);</a>
<a name="ln4760">        if (crawl_state.seen_hups)</a>
<a name="ln4761">        {</a>
<a name="ln4762">            clear_messages();</a>
<a name="ln4763">            mpr(&quot;Cancelling leap due to HUP.&quot;);</a>
<a name="ln4764">            return false;</a>
<a name="ln4765">        }</a>
<a name="ln4766"> </a>
<a name="ln4767">        if (!beam.isValid || beam.target == you.pos())</a>
<a name="ln4768">            return false;         // early return</a>
<a name="ln4769"> </a>
<a name="ln4770">        monster* beholder = you.get_beholder(beam.target);</a>
<a name="ln4771">        if (beholder)</a>
<a name="ln4772">        {</a>
<a name="ln4773">            clear_messages();</a>
<a name="ln4774">            mprf(&quot;You cannot leap away from %s!&quot;,</a>
<a name="ln4775">                 beholder-&gt;name(DESC_THE, true).c_str());</a>
<a name="ln4776">            continue;</a>
<a name="ln4777">        }</a>
<a name="ln4778"> </a>
<a name="ln4779">        monster* fearmonger = you.get_fearmonger(beam.target);</a>
<a name="ln4780">        if (fearmonger)</a>
<a name="ln4781">        {</a>
<a name="ln4782">            clear_messages();</a>
<a name="ln4783">            mprf(&quot;You cannot leap closer to %s!&quot;,</a>
<a name="ln4784">                 fearmonger-&gt;name(DESC_THE, true).c_str());</a>
<a name="ln4785">            continue;</a>
<a name="ln4786">        }</a>
<a name="ln4787"> </a>
<a name="ln4788">        monster* mons = monster_at(beam.target);</a>
<a name="ln4789">        if (mons &amp;&amp; you.can_see(*mons))</a>
<a name="ln4790">        {</a>
<a name="ln4791">            clear_messages();</a>
<a name="ln4792">            mpr(&quot;You can't leap on top of the monster!&quot;);</a>
<a name="ln4793">            continue;</a>
<a name="ln4794">        }</a>
<a name="ln4795"> </a>
<a name="ln4796">        if (grd(beam.target) == DNGN_OPEN_SEA)</a>
<a name="ln4797">        {</a>
<a name="ln4798">            clear_messages();</a>
<a name="ln4799">            mpr(&quot;You can't leap into the sea!&quot;);</a>
<a name="ln4800">            continue;</a>
<a name="ln4801">        }</a>
<a name="ln4802">        else if (grd(beam.target) == DNGN_LAVA_SEA)</a>
<a name="ln4803">        {</a>
<a name="ln4804">            clear_messages();</a>
<a name="ln4805">            mpr(&quot;You can't leap into the sea of lava!&quot;);</a>
<a name="ln4806">            continue;</a>
<a name="ln4807">        }</a>
<a name="ln4808">        else if (!check_moveto(beam.target, &quot;leap&quot;))</a>
<a name="ln4809">        {</a>
<a name="ln4810">            // try again (messages handled by check_moveto)</a>
<a name="ln4811">        }</a>
<a name="ln4812">        else if (you.see_cell_no_trans(beam.target))</a>
<a name="ln4813">        {</a>
<a name="ln4814">            // Grid in los, no problem.</a>
<a name="ln4815">            break;</a>
<a name="ln4816">        }</a>
<a name="ln4817">        else if (you.trans_wall_blocking(beam.target))</a>
<a name="ln4818">        {</a>
<a name="ln4819">            clear_messages();</a>
<a name="ln4820">            canned_msg(MSG_SOMETHING_IN_WAY);</a>
<a name="ln4821">        }</a>
<a name="ln4822">        else</a>
<a name="ln4823">        {</a>
<a name="ln4824">            clear_messages();</a>
<a name="ln4825">            canned_msg(MSG_CANNOT_SEE);</a>
<a name="ln4826">        }</a>
<a name="ln4827">    }</a>
<a name="ln4828"> </a>
<a name="ln4829">    if (!you.attempt_escape(2)) // returns true if not constricted</a>
<a name="ln4830">        return true;</a>
<a name="ln4831"> </a>
<a name="ln4832">    if (cell_is_solid(beam.target) || monster_at(beam.target))</a>
<a name="ln4833">    {</a>
<a name="ln4834">        // XXX: try to jump somewhere nearby?</a>
<a name="ln4835">        mpr(&quot;Something unexpectedly blocked you, preventing you from leaping!&quot;);</a>
<a name="ln4836">        return true;</a>
<a name="ln4837">    }</a>
<a name="ln4838"> </a>
<a name="ln4839">    move_player_to_grid(beam.target, false);</a>
<a name="ln4840"> </a>
<a name="ln4841">    crawl_state.cancel_cmd_again();</a>
<a name="ln4842">    crawl_state.cancel_cmd_repeat();</a>
<a name="ln4843"> </a>
<a name="ln4844">    bolt wave;</a>
<a name="ln4845">    wave.thrower = KILL_YOU;</a>
<a name="ln4846">    wave.name = &quot;power leap&quot;;</a>
<a name="ln4847">    wave.source_name = &quot;you&quot;;</a>
<a name="ln4848">    wave.source_id = MID_PLAYER;</a>
<a name="ln4849">    wave.flavour = BEAM_VISUAL;</a>
<a name="ln4850">    wave.colour = BROWN;</a>
<a name="ln4851">    wave.glyph = dchar_glyph(DCHAR_EXPLOSION);</a>
<a name="ln4852">    wave.range = 1;</a>
<a name="ln4853">    wave.ex_size = 1;</a>
<a name="ln4854">    wave.is_explosion = true;</a>
<a name="ln4855">    wave.source = you.pos();</a>
<a name="ln4856">    wave.target = you.pos();</a>
<a name="ln4857">    wave.hit = AUTOMATIC_HIT;</a>
<a name="ln4858">    wave.loudness = 2;</a>
<a name="ln4859">    wave.explode();</a>
<a name="ln4860"> </a>
<a name="ln4861">    // we need to exempt the player from damage.</a>
<a name="ln4862">    for (adjacent_iterator ai(you.pos(), false); ai; ++ai)</a>
<a name="ln4863">    {</a>
<a name="ln4864">        monster* mon = monster_at(*ai);</a>
<a name="ln4865">        if (mon == nullptr || mons_is_projectile(mon-&gt;type) || mon-&gt;friendly())</a>
<a name="ln4866">            continue;</a>
<a name="ln4867">        ASSERT(mon);</a>
<a name="ln4868"> </a>
<a name="ln4869">        //damage scales with XL amd piety</a>
<a name="ln4870">        mon-&gt;hurt((actor*)&amp;you, roll_dice(1 + div_rand_round(you.piety *</a>
<a name="ln4871">            (54 + you.experience_level), 777), 3),</a>
<a name="ln4872">            BEAM_ENERGY, KILLED_BY_BEAM, &quot;&quot;, &quot;&quot;, true);</a>
<a name="ln4873">    }</a>
<a name="ln4874"> </a>
<a name="ln4875">    return true;</a>
<a name="ln4876">}</a>
<a name="ln4877"> </a>
<a name="ln4878">int cell_has_valid_target(coord_def where)</a>
<a name="ln4879">{</a>
<a name="ln4880">    monster* mon = monster_at(where);</a>
<a name="ln4881">    if (mon == nullptr || mons_is_projectile(mon-&gt;type) || mon-&gt;friendly())</a>
<a name="ln4882">        return 0;</a>
<a name="ln4883">    return 1;</a>
<a name="ln4884">}</a>
<a name="ln4885"> </a>
<a name="ln4886">static int _apply_apocalypse(coord_def where)</a>
<a name="ln4887">{</a>
<a name="ln4888">    if (!cell_has_valid_target(where))</a>
<a name="ln4889">        return 0;</a>
<a name="ln4890">    monster* mons = monster_at(where);</a>
<a name="ln4891">    ASSERT(mons);</a>
<a name="ln4892"> </a>
<a name="ln4893">    int duration = 0;</a>
<a name="ln4894">    string message = &quot;&quot;;</a>
<a name="ln4895">    enchant_type enchantment = ENCH_NONE;</a>
<a name="ln4896"> </a>
<a name="ln4897">    int effect = random2(4);</a>
<a name="ln4898">    if (mons_is_firewood(*mons))</a>
<a name="ln4899">        effect = 99; // &gt; 2 is just damage -- no slowed toadstools</a>
<a name="ln4900"> </a>
<a name="ln4901">    int num_dice;</a>
<a name="ln4902">    switch (effect)</a>
<a name="ln4903">    {</a>
<a name="ln4904">        case 0:</a>
<a name="ln4905">            if (mons-&gt;antimagic_susceptible())</a>
<a name="ln4906">            {</a>
<a name="ln4907">                message = &quot; doubts &quot; + mons-&gt;pronoun(PRONOUN_POSSESSIVE)</a>
<a name="ln4908">                          + &quot; magic when faced with ultimate truth!&quot;;</a>
<a name="ln4909">                enchantment = ENCH_ANTIMAGIC;</a>
<a name="ln4910">                duration = 500 + random2(200);</a>
<a name="ln4911">                num_dice = 4;</a>
<a name="ln4912">                break;</a>
<a name="ln4913">            } // if not antimagicable, fall through to paralysis.</a>
<a name="ln4914">        case 1:</a>
<a name="ln4915">            message = &quot; is paralysed by terrible understanding!&quot;;</a>
<a name="ln4916">            enchantment = ENCH_PARALYSIS;</a>
<a name="ln4917">            duration = 80 + random2(60);</a>
<a name="ln4918">            num_dice = 4;</a>
<a name="ln4919">            break;</a>
<a name="ln4920"> </a>
<a name="ln4921">        case 2:</a>
<a name="ln4922">            message = &quot; slows down under the weight of truth!&quot;;</a>
<a name="ln4923">            enchantment = ENCH_SLOW;</a>
<a name="ln4924">            duration = 300 + random2(100);</a>
<a name="ln4925">            num_dice = 6;</a>
<a name="ln4926">            break;</a>
<a name="ln4927"> </a>
<a name="ln4928">        default:</a>
<a name="ln4929">            num_dice = 8;</a>
<a name="ln4930">            break;</a>
<a name="ln4931">    }</a>
<a name="ln4932"> </a>
<a name="ln4933">    //damage scales with XL and piety</a>
<a name="ln4934">    const int pow = you.piety;</a>
<a name="ln4935">    int die_size = 1 + div_rand_round(pow * (54 + you.experience_level), 584);</a>
<a name="ln4936">    int dmg = 10 + roll_dice(num_dice, die_size);</a>
<a name="ln4937"> </a>
<a name="ln4938">    mons-&gt;hurt(&amp;you, dmg, BEAM_ENERGY, KILLED_BY_BEAM, &quot;&quot;, &quot;&quot;, true);</a>
<a name="ln4939"> </a>
<a name="ln4940">    if (mons-&gt;alive() &amp;&amp; enchantment != ENCH_NONE)</a>
<a name="ln4941">    {</a>
<a name="ln4942">        simple_monster_message(*mons, message.c_str());</a>
<a name="ln4943">        mons-&gt;add_ench(mon_enchant(enchantment, 1, &amp;you, duration));</a>
<a name="ln4944">    }</a>
<a name="ln4945">    return 1;</a>
<a name="ln4946">}</a>
<a name="ln4947"> </a>
<a name="ln4948">bool ru_apocalypse()</a>
<a name="ln4949">{</a>
<a name="ln4950">    int count = apply_area_visible(cell_has_valid_target, you.pos());</a>
<a name="ln4951">    if (!count)</a>
<a name="ln4952">    {</a>
<a name="ln4953">        if (!yesno(&quot;There are no visible enemies. Unleash your apocalypse anyway?&quot;,</a>
<a name="ln4954">            true, 'n'))</a>
<a name="ln4955">        {</a>
<a name="ln4956">            return false;</a>
<a name="ln4957">        }</a>
<a name="ln4958">    }</a>
<a name="ln4959">    mpr(&quot;You reveal the great annihilating truth to your foes!&quot;);</a>
<a name="ln4960">    noisy(30, you.pos());</a>
<a name="ln4961">    apply_area_visible(_apply_apocalypse, you.pos());</a>
<a name="ln4962">    drain_player(100, false, true);</a>
<a name="ln4963">    return true;</a>
<a name="ln4964">}</a>
<a name="ln4965"> </a>
<a name="ln4966">#if TAG_MAJOR_VERSION == 34</a>
<a name="ln4967">/**</a>
<a name="ln4968"> * Calculate the effective power of a surged hex wand.</a>
<a name="ln4969"> * Works by iterating over the possible rolls from random2avg().</a>
<a name="ln4970"> * A much nicer way of computing this would be appreciated.</a>
<a name="ln4971"> *</a>
<a name="ln4972"> * @param   pow The base power.</a>
<a name="ln4973"> * @returns     The effective spellpower of a hex wand.</a>
<a name="ln4974"> */</a>
<a name="ln4975">int pakellas_effective_hex_power(int pow)</a>
<a name="ln4976">{</a>
<a name="ln4977">    if (!you_worship(GOD_PAKELLAS) || !you.duration[DUR_DEVICE_SURGE])</a>
<a name="ln4978">        return pow;</a>
<a name="ln4979"> </a>
<a name="ln4980">    if (you.magic_points == 0)</a>
<a name="ln4981">        return 0;</a>
<a name="ln4982"> </a>
<a name="ln4983">    const int die_size = you.piety * 9 / piety_breakpoint(5);</a>
<a name="ln4984">    const int max_roll = max(3, 2 * die_size);</a>
<a name="ln4985">    vector&lt;int&gt; rolls(max_roll + 1, 0);</a>
<a name="ln4986"> </a>
<a name="ln4987">    // i is the first random2(); j is the second random2()</a>
<a name="ln4988">    int i = 0;</a>
<a name="ln4989">    for (; i &lt; die_size; i++)</a>
<a name="ln4990">        for (int j = 0; j &lt; die_size; j++)</a>
<a name="ln4991">        {</a>
<a name="ln4992">            // This should be the same as the formula in pakellas_device_surge()</a>
<a name="ln4993">            int roll = min(you.magic_points,</a>
<a name="ln4994">                              min(9,</a>
<a name="ln4995">                                  max(3,</a>
<a name="ln4996">                                      1 + (i + j) / 2)));</a>
<a name="ln4997">            rolls[roll] = rolls[roll] + 1;</a>
<a name="ln4998">        }</a>
<a name="ln4999"> </a>
<a name="ln5000">    if (die_size == 0)</a>
<a name="ln5001">        rolls[min(3, you.magic_points)] = 1;</a>
<a name="ln5002"> </a>
<a name="ln5003">    int total_pow = 0;</a>
<a name="ln5004">    int weight = 0;</a>
<a name="ln5005"> </a>
<a name="ln5006">    for (i = 1; i &lt;= max_roll; i++)</a>
<a name="ln5007">    {</a>
<a name="ln5008">        if (i &gt; 9)</a>
<a name="ln5009">            break;</a>
<a name="ln5010"> </a>
<a name="ln5011">        int base_sev = i / 3;</a>
<a name="ln5012">        int mod = i % 3;</a>
<a name="ln5013">        int base_power = (base_sev == 0)</a>
<a name="ln5014">            ? 0 // fizzle</a>
<a name="ln5015">            : stepdown_spellpower(100*apply_enhancement(pow, base_sev));</a>
<a name="ln5016">        weight += 3 * rolls[i];</a>
<a name="ln5017">        total_pow +=</a>
<a name="ln5018">            rolls[i] *</a>
<a name="ln5019">            (base_power * (3 - mod)</a>
<a name="ln5020">             + stepdown_spellpower(100*apply_enhancement(pow, base_sev+1))</a>
<a name="ln5021">               * mod);</a>
<a name="ln5022">    }</a>
<a name="ln5023">    total_pow /= weight;</a>
<a name="ln5024">    return total_pow;</a>
<a name="ln5025">}</a>
<a name="ln5026"> </a>
<a name="ln5027">/**</a>
<a name="ln5028"> * Trigger a readied Device Surge, spending MP to multiply evocations power.</a>
<a name="ln5029"> *</a>
<a name="ln5030"> * @return  A number of enhancers (!) to multiply evo power by.</a>
<a name="ln5031"> */</a>
<a name="ln5032">int pakellas_surge_devices()</a>
<a name="ln5033">{</a>
<a name="ln5034">    if (!you_worship(GOD_PAKELLAS) || !you.duration[DUR_DEVICE_SURGE])</a>
<a name="ln5035">        return 0;</a>
<a name="ln5036"> </a>
<a name="ln5037">    const int mp = min(you.magic_points, min(9, max(3,</a>
<a name="ln5038">                       1 + random2avg(you.piety * 9 / piety_breakpoint(5),</a>
<a name="ln5039">                                      2))));</a>
<a name="ln5040"> </a>
<a name="ln5041">    const int severity = div_rand_round(mp, 3);</a>
<a name="ln5042">    dec_mp(mp);</a>
<a name="ln5043">    you.duration[DUR_DEVICE_SURGE] = 0;</a>
<a name="ln5044">    if (severity == 0)</a>
<a name="ln5045">    {</a>
<a name="ln5046">        mprf(MSGCH_GOD, &quot;The surge fizzles.&quot;);</a>
<a name="ln5047">        return -1;</a>
<a name="ln5048">    }</a>
<a name="ln5049">    return severity;</a>
<a name="ln5050">}</a>
<a name="ln5051">#endif</a>
<a name="ln5052"> </a>
<a name="ln5053">static bool _mons_stompable(const monster &amp;mons)</a>
<a name="ln5054">{</a>
<a name="ln5055">    // Don't hurt your own demonic guardians</a>
<a name="ln5056">    return !testbits(mons.flags, MF_DEMONIC_GUARDIAN) || !mons.friendly();</a>
<a name="ln5057">}</a>
<a name="ln5058"> </a>
<a name="ln5059">static bool _get_stomped(monster&amp; mons)</a>
<a name="ln5060">{</a>
<a name="ln5061">    if (!_mons_stompable(mons))</a>
<a name="ln5062">        return false;</a>
<a name="ln5063"> </a>
<a name="ln5064">    behaviour_event(&amp;mons, ME_ANNOY, &amp;you);</a>
<a name="ln5065"> </a>
<a name="ln5066">    // Damage starts at 1/6th of monster current HP, then gets some damage</a>
<a name="ln5067">    // scaling off Invo power.</a>
<a name="ln5068">    int damage = div_rand_round(mons.hit_points, 6);</a>
<a name="ln5069">    int die_size = 2 + div_rand_round(you.skill(SK_INVOCATIONS), 2);</a>
<a name="ln5070">    damage += roll_dice(2, die_size);</a>
<a name="ln5071"> </a>
<a name="ln5072">    mons.hurt(&amp;you, damage, BEAM_ENERGY, KILLED_BY_BEAM, &quot;&quot;, &quot;&quot;, true);</a>
<a name="ln5073"> </a>
<a name="ln5074">    if (mons.alive() &amp;&amp; you.can_see(mons))</a>
<a name="ln5075">        print_wounds(mons);</a>
<a name="ln5076"> </a>
<a name="ln5077">    return true;</a>
<a name="ln5078">}</a>
<a name="ln5079"> </a>
<a name="ln5080">bool uskayaw_stomp()</a>
<a name="ln5081">{</a>
<a name="ln5082">    // Demonic guardians are immune but check for other friendlies</a>
<a name="ln5083">    const bool friendlies = apply_monsters_around_square([] (monster&amp; mons) {</a>
<a name="ln5084">        return _mons_stompable(mons) &amp;&amp; mons_att_wont_attack(mons.attitude);</a>
<a name="ln5085">    }, you.pos());</a>
<a name="ln5086"> </a>
<a name="ln5087">    // XXX: this 'friendlies' wording feels a little odd, but we do use it in a</a>
<a name="ln5088">    // a few places already; see spl_tornado.cc, disaster area, etc.</a>
<a name="ln5089">    if (friendlies</a>
<a name="ln5090">        &amp;&amp; !yesno(&quot;There are friendlies around, &quot;</a>
<a name="ln5091">                  &quot;are you sure you want to hurt them?&quot;,</a>
<a name="ln5092">                  true, 'n'))</a>
<a name="ln5093">    {</a>
<a name="ln5094">        canned_msg(MSG_OK);</a>
<a name="ln5095">        return false;</a>
<a name="ln5096">    }</a>
<a name="ln5097"> </a>
<a name="ln5098">    mpr(&quot;You stomp with the beat, sending a shockwave through the revelers &quot;</a>
<a name="ln5099">            &quot;around you!&quot;);</a>
<a name="ln5100">    apply_monsters_around_square(_get_stomped, you.pos());</a>
<a name="ln5101">    return true;</a>
<a name="ln5102">}</a>
<a name="ln5103"> </a>
<a name="ln5104">bool uskayaw_line_pass()</a>
<a name="ln5105">{</a>
<a name="ln5106">    ASSERT(!crawl_state.game_is_arena());</a>
<a name="ln5107"> </a>
<a name="ln5108">    if (crawl_state.is_repeating_cmd())</a>
<a name="ln5109">    {</a>
<a name="ln5110">        crawl_state.cant_cmd_repeat(&quot;You can't repeat line pass.&quot;);</a>
<a name="ln5111">        crawl_state.cancel_cmd_again();</a>
<a name="ln5112">        crawl_state.cancel_cmd_repeat();</a>
<a name="ln5113">        return false;</a>
<a name="ln5114">    }</a>
<a name="ln5115"> </a>
<a name="ln5116">    // query for location:</a>
<a name="ln5117">    int range = 8;</a>
<a name="ln5118">    int invo_skill = you.skill(SK_INVOCATIONS);</a>
<a name="ln5119">    int pow = (25 + invo_skill + random2(invo_skill));</a>
<a name="ln5120">    dist beam;</a>
<a name="ln5121">    bolt line_pass;</a>
<a name="ln5122">    line_pass.thrower = KILL_YOU;</a>
<a name="ln5123">    line_pass.name = &quot;line pass&quot;;</a>
<a name="ln5124">    line_pass.source_name = &quot;you&quot;;</a>
<a name="ln5125">    line_pass.source_id = MID_PLAYER;</a>
<a name="ln5126">    line_pass.flavour = BEAM_IRRESISTIBLE_CONFUSION;</a>
<a name="ln5127">    line_pass.source = you.pos();</a>
<a name="ln5128">    line_pass.hit = AUTOMATIC_HIT;</a>
<a name="ln5129">    line_pass.range = range;</a>
<a name="ln5130">    line_pass.ench_power = pow;</a>
<a name="ln5131">    line_pass.pierce = true;</a>
<a name="ln5132"> </a>
<a name="ln5133">    while (1)</a>
<a name="ln5134">    {</a>
<a name="ln5135">        unique_ptr&lt;targeter&gt; hitfunc;</a>
<a name="ln5136">        hitfunc = make_unique&lt;targeter_monster_sequence&gt;(&amp;you, pow, range);</a>
<a name="ln5137"> </a>
<a name="ln5138">        direction_chooser_args args;</a>
<a name="ln5139">        args.hitfunc = hitfunc.get();</a>
<a name="ln5140">        args.restricts = DIR_LEAP;</a>
<a name="ln5141">        args.mode = TARG_ANY;</a>
<a name="ln5142">        args.needs_path = false;</a>
<a name="ln5143">        args.top_prompt = &quot;Aiming: &lt;white&gt;Line Pass&lt;/white&gt;&quot;;</a>
<a name="ln5144">        args.range = 8;</a>
<a name="ln5145"> </a>
<a name="ln5146">        if (!spell_direction(beam, line_pass, &amp;args))</a>
<a name="ln5147">            return false;</a>
<a name="ln5148"> </a>
<a name="ln5149">        if (crawl_state.seen_hups)</a>
<a name="ln5150">        {</a>
<a name="ln5151">            clear_messages();</a>
<a name="ln5152">            mpr(&quot;Cancelling line pass due to HUP.&quot;);</a>
<a name="ln5153">            return false;</a>
<a name="ln5154">        }</a>
<a name="ln5155"> </a>
<a name="ln5156">        if (!beam.isValid || beam.target == you.pos())</a>
<a name="ln5157">            return false;         // early return</a>
<a name="ln5158"> </a>
<a name="ln5159">        monster* beholder = you.get_beholder(beam.target);</a>
<a name="ln5160">        if (beholder)</a>
<a name="ln5161">        {</a>
<a name="ln5162">            clear_messages();</a>
<a name="ln5163">            mprf(&quot;You cannot move away from %s!&quot;,</a>
<a name="ln5164">                 beholder-&gt;name(DESC_THE, true).c_str());</a>
<a name="ln5165">            continue;</a>
<a name="ln5166">        }</a>
<a name="ln5167"> </a>
<a name="ln5168">        monster* fearmonger = you.get_fearmonger(beam.target);</a>
<a name="ln5169">        if (fearmonger)</a>
<a name="ln5170">        {</a>
<a name="ln5171">            clear_messages();</a>
<a name="ln5172">            mprf(&quot;You cannot move closer to %s!&quot;,</a>
<a name="ln5173">                 fearmonger-&gt;name(DESC_THE, true).c_str());</a>
<a name="ln5174">            continue;</a>
<a name="ln5175">        }</a>
<a name="ln5176"> </a>
<a name="ln5177">        monster* mons = monster_at(beam.target);</a>
<a name="ln5178">        if (mons &amp;&amp; you.can_see(*mons))</a>
<a name="ln5179">        {</a>
<a name="ln5180">            clear_messages();</a>
<a name="ln5181">            mpr(&quot;You can't stand on top of the monster!&quot;);</a>
<a name="ln5182">            continue;</a>
<a name="ln5183">        }</a>
<a name="ln5184"> </a>
<a name="ln5185">        if (grd(beam.target) == DNGN_OPEN_SEA)</a>
<a name="ln5186">        {</a>
<a name="ln5187">            clear_messages();</a>
<a name="ln5188">            mpr(&quot;You can't line pass into the sea!&quot;);</a>
<a name="ln5189">            continue;</a>
<a name="ln5190">        }</a>
<a name="ln5191">        else if (grd(beam.target) == DNGN_LAVA_SEA)</a>
<a name="ln5192">        {</a>
<a name="ln5193">            clear_messages();</a>
<a name="ln5194">            mpr(&quot;You can't line pass into the sea of lava!&quot;);</a>
<a name="ln5195">            continue;</a>
<a name="ln5196">        }</a>
<a name="ln5197">        else if (cell_is_solid(beam.target))</a>
<a name="ln5198">        {</a>
<a name="ln5199">            clear_messages();</a>
<a name="ln5200">            mpr(&quot;You can't walk through walls!&quot;);</a>
<a name="ln5201">            continue;</a>
<a name="ln5202">        }</a>
<a name="ln5203">        else if (!check_moveto(beam.target, &quot;line pass&quot;))</a>
<a name="ln5204">        {</a>
<a name="ln5205">            // try again (messages handled by check_moveto)</a>
<a name="ln5206">        }</a>
<a name="ln5207">        else if (you.see_cell_no_trans(beam.target))</a>
<a name="ln5208">        {</a>
<a name="ln5209">            // Grid in los, no problem.</a>
<a name="ln5210">            break;</a>
<a name="ln5211">        }</a>
<a name="ln5212">        else if (you.trans_wall_blocking(beam.target))</a>
<a name="ln5213">        {</a>
<a name="ln5214">            clear_messages();</a>
<a name="ln5215">            canned_msg(MSG_SOMETHING_IN_WAY);</a>
<a name="ln5216">        }</a>
<a name="ln5217">        else</a>
<a name="ln5218">        {</a>
<a name="ln5219">            clear_messages();</a>
<a name="ln5220">            canned_msg(MSG_CANNOT_SEE);</a>
<a name="ln5221">        }</a>
<a name="ln5222">    }</a>
<a name="ln5223"> </a>
<a name="ln5224">    if (monster_at(beam.target))</a>
<a name="ln5225">        mpr(&quot;Something unexpectedly blocked you, preventing you from passing!&quot;);</a>
<a name="ln5226">    else</a>
<a name="ln5227">    {</a>
<a name="ln5228">        line_pass.fire();</a>
<a name="ln5229">        you.stop_being_constricted(false);</a>
<a name="ln5230">        move_player_to_grid(beam.target, false);</a>
<a name="ln5231">    }</a>
<a name="ln5232"> </a>
<a name="ln5233">    crawl_state.cancel_cmd_again();</a>
<a name="ln5234">    crawl_state.cancel_cmd_repeat();</a>
<a name="ln5235"> </a>
<a name="ln5236">    return true;</a>
<a name="ln5237">}</a>
<a name="ln5238"> </a>
<a name="ln5239">spret uskayaw_grand_finale(bool fail)</a>
<a name="ln5240">{</a>
<a name="ln5241">    ASSERT(!crawl_state.game_is_arena());</a>
<a name="ln5242"> </a>
<a name="ln5243">    if (crawl_state.is_repeating_cmd())</a>
<a name="ln5244">    {</a>
<a name="ln5245">        crawl_state.cant_cmd_repeat(&quot;No encores!&quot;);</a>
<a name="ln5246">        crawl_state.cancel_cmd_again();</a>
<a name="ln5247">        crawl_state.cancel_cmd_repeat();</a>
<a name="ln5248">        return spret::abort;</a>
<a name="ln5249">    }</a>
<a name="ln5250"> </a>
<a name="ln5251">    // query for location:</a>
<a name="ln5252">    dist beam;</a>
<a name="ln5253"> </a>
<a name="ln5254">    monster* mons;</a>
<a name="ln5255"> </a>
<a name="ln5256">    while (1)</a>
<a name="ln5257">    {</a>
<a name="ln5258">        direction_chooser_args args;</a>
<a name="ln5259">        args.mode = TARG_HOSTILE;</a>
<a name="ln5260">        args.needs_path = false;</a>
<a name="ln5261">        args.top_prompt = &quot;Aiming: &lt;white&gt;Grand Finale&lt;/white&gt;&quot;;</a>
<a name="ln5262">        args.self = confirm_prompt_type::cancel;</a>
<a name="ln5263">        targeter_smite tgt(&amp;you);</a>
<a name="ln5264">        args.hitfunc = &amp;tgt;</a>
<a name="ln5265">        direction(beam, args);</a>
<a name="ln5266">        if (crawl_state.seen_hups)</a>
<a name="ln5267">        {</a>
<a name="ln5268">            clear_messages();</a>
<a name="ln5269">            mpr(&quot;Cancelling grand finale due to HUP.&quot;);</a>
<a name="ln5270">            return spret::abort;</a>
<a name="ln5271">        }</a>
<a name="ln5272"> </a>
<a name="ln5273">        if (!beam.isValid || beam.target == you.pos())</a>
<a name="ln5274">            return spret::abort;   // early return</a>
<a name="ln5275"> </a>
<a name="ln5276">        mons = monster_at(beam.target);</a>
<a name="ln5277">        if (!mons || !you.can_see(*mons))</a>
<a name="ln5278">        {</a>
<a name="ln5279">            clear_messages();</a>
<a name="ln5280">            mpr(&quot;You can't perceive a target there!&quot;);</a>
<a name="ln5281">            continue;</a>
<a name="ln5282">        }</a>
<a name="ln5283"> </a>
<a name="ln5284">        if (!check_moveto(beam.target, &quot;move&quot;))</a>
<a name="ln5285">        {</a>
<a name="ln5286">            // try again (messages handled by check_moveto)</a>
<a name="ln5287">        }</a>
<a name="ln5288">        else if (you.see_cell_no_trans(beam.target))</a>
<a name="ln5289">        {</a>
<a name="ln5290">            // Grid in los, no problem.</a>
<a name="ln5291">            break;</a>
<a name="ln5292">        }</a>
<a name="ln5293">        else if (you.trans_wall_blocking(beam.target))</a>
<a name="ln5294">        {</a>
<a name="ln5295">            clear_messages();</a>
<a name="ln5296">            canned_msg(MSG_SOMETHING_IN_WAY);</a>
<a name="ln5297">        }</a>
<a name="ln5298">        else</a>
<a name="ln5299">        {</a>
<a name="ln5300">            clear_messages();</a>
<a name="ln5301">            canned_msg(MSG_CANNOT_SEE);</a>
<a name="ln5302">        }</a>
<a name="ln5303">    }</a>
<a name="ln5304"> </a>
<a name="ln5305">    fail_check();</a>
<a name="ln5306"> </a>
<a name="ln5307">    ASSERT(mons);</a>
<a name="ln5308"> </a>
<a name="ln5309">    // kill the target</a>
<a name="ln5310">    if (mons-&gt;type == MONS_ROYAL_JELLY &amp;&amp; !mons-&gt;is_summoned())</a>
<a name="ln5311">    {</a>
<a name="ln5312">        // need to do this here, because react_to_damage is never called</a>
<a name="ln5313">        mprf(&quot;%s explodes violently into a cloud of jellies!&quot;,</a>
<a name="ln5314">                                        mons-&gt;name(DESC_THE, false).c_str());</a>
<a name="ln5315">        trj_spawn_fineff::schedule(&amp;you, mons, mons-&gt;pos(), mons-&gt;hit_points);</a>
<a name="ln5316">    }</a>
<a name="ln5317">    else</a>
<a name="ln5318">        mprf(&quot;%s explodes violently!&quot;, mons-&gt;name(DESC_THE, false).c_str());</a>
<a name="ln5319">    mons-&gt;flags |= MF_EXPLODE_KILL;</a>
<a name="ln5320">    if (!mons-&gt;is_insubstantial())</a>
<a name="ln5321">    {</a>
<a name="ln5322">        blood_spray(mons-&gt;pos(), mons-&gt;mons_species(), mons-&gt;hit_points / 5);</a>
<a name="ln5323">        throw_monster_bits(*mons); // have some fun while we're at it</a>
<a name="ln5324">    }</a>
<a name="ln5325"> </a>
<a name="ln5326">    monster_die(*mons, KILL_YOU, NON_MONSTER, false);</a>
<a name="ln5327"> </a>
<a name="ln5328">    if (!mons-&gt;alive())</a>
<a name="ln5329">        move_player_to_grid(beam.target, false);</a>
<a name="ln5330">    else</a>
<a name="ln5331">        mpr(&quot;You spring back to your original position.&quot;);</a>
<a name="ln5332"> </a>
<a name="ln5333">    crawl_state.cancel_cmd_again();</a>
<a name="ln5334">    crawl_state.cancel_cmd_repeat();</a>
<a name="ln5335"> </a>
<a name="ln5336">    set_piety(piety_breakpoint(0)); // Reset piety to 1*.</a>
<a name="ln5337"> </a>
<a name="ln5338">    return spret::success;</a>
<a name="ln5339">}</a>
<a name="ln5340"> </a>
<a name="ln5341">/**</a>
<a name="ln5342"> * Permanently choose a class for the player's companion,</a>
<a name="ln5343"> * after prompting to make sure the player is certain.</a>
<a name="ln5344"> *</a>
<a name="ln5345"> * @param ancestor_choice     The ancestor's class; should be an ability enum.</a>
<a name="ln5346"> * @return                  Whether the player went through with the choice.</a>
<a name="ln5347"> */</a>
<a name="ln5348">bool hepliaklqana_choose_ancestor_type(int ancestor_choice)</a>
<a name="ln5349">{</a>
<a name="ln5350">    if (hepliaklqana_ancestor()</a>
<a name="ln5351">        &amp;&amp; companion_is_elsewhere(hepliaklqana_ancestor()))</a>
<a name="ln5352">    {</a>
<a name="ln5353">        // ugly hack to avoid dealing with upgrading offlevel ancestors</a>
<a name="ln5354">        mpr(&quot;You can't make this choice while your ancestor is elsewhere.&quot;);</a>
<a name="ln5355">        return false;</a>
<a name="ln5356">    }</a>
<a name="ln5357"> </a>
<a name="ln5358">    static const map&lt;int, monster_type&gt; ancestor_types = {</a>
<a name="ln5359">        { ABIL_HEPLIAKLQANA_TYPE_KNIGHT, MONS_ANCESTOR_KNIGHT },</a>
<a name="ln5360">        { ABIL_HEPLIAKLQANA_TYPE_BATTLEMAGE, MONS_ANCESTOR_BATTLEMAGE },</a>
<a name="ln5361">        { ABIL_HEPLIAKLQANA_TYPE_HEXER, MONS_ANCESTOR_HEXER },</a>
<a name="ln5362">    };</a>
<a name="ln5363"> </a>
<a name="ln5364">    auto ancestor_mapped = map_find(ancestor_types, ancestor_choice);</a>
<a name="ln5365">    ASSERT(ancestor_mapped);</a>
<a name="ln5366">    const auto ancestor_type = *ancestor_mapped;</a>
<a name="ln5367">    const string ancestor_type_name = mons_type_name(ancestor_type, DESC_A);</a>
<a name="ln5368"> </a>
<a name="ln5369">    if (!yesno(make_stringf(&quot;Are you sure you want to remember your ancestor &quot;</a>
<a name="ln5370">                            &quot;as %s?&quot;, ancestor_type_name.c_str()).c_str(),</a>
<a name="ln5371">               false, 'n'))</a>
<a name="ln5372">    {</a>
<a name="ln5373">        canned_msg(MSG_OK);</a>
<a name="ln5374">        return false;</a>
<a name="ln5375">    }</a>
<a name="ln5376"> </a>
<a name="ln5377">    you.props[HEPLIAKLQANA_ALLY_TYPE_KEY] = ancestor_type;</a>
<a name="ln5378"> </a>
<a name="ln5379">    if (monster* ancestor = hepliaklqana_ancestor_mon())</a>
<a name="ln5380">    {</a>
<a name="ln5381">        ancestor-&gt;type = ancestor_type;</a>
<a name="ln5382">        give_weapon(ancestor, -1);</a>
<a name="ln5383">        ASSERT(ancestor-&gt;weapon());</a>
<a name="ln5384">        give_shield(ancestor);</a>
<a name="ln5385">        set_ancestor_spells(*ancestor);</a>
<a name="ln5386">    }</a>
<a name="ln5387"> </a>
<a name="ln5388">    god_speaks(you.religion, &quot;It is so.&quot;);</a>
<a name="ln5389">    take_note(Note(NOTE_ANCESTOR_TYPE, 0, 0, ancestor_type_name));</a>
<a name="ln5390">    const string mile_text</a>
<a name="ln5391">        = make_stringf(&quot;remembered their ancestor %s as %s.&quot;,</a>
<a name="ln5392">                       hepliaklqana_ally_name().c_str(),</a>
<a name="ln5393">                       ancestor_type_name.c_str());</a>
<a name="ln5394">    mark_milestone(&quot;ancestor.class&quot;, mile_text);</a>
<a name="ln5395"> </a>
<a name="ln5396">    return true;</a>
<a name="ln5397">}</a>
<a name="ln5398"> </a>
<a name="ln5399"> </a>
<a name="ln5400">/**</a>
<a name="ln5401"> * Heal the player's ancestor, and apply the Idealised buff for a few turns.</a>
<a name="ln5402"> *</a>
<a name="ln5403"> * @param fail      Whether the effect should fail after checking validity.</a>
<a name="ln5404"> * @return          Whether the healing succeeded, failed, or was aborted.</a>
<a name="ln5405"> */</a>
<a name="ln5406">spret hepliaklqana_idealise(bool fail)</a>
<a name="ln5407">{</a>
<a name="ln5408">    const mid_t ancestor_mid = hepliaklqana_ancestor();</a>
<a name="ln5409">    if (ancestor_mid == MID_NOBODY)</a>
<a name="ln5410">    {</a>
<a name="ln5411">        mpr(&quot;You have no ancestor to preserve!&quot;);</a>
<a name="ln5412">        return spret::abort;</a>
<a name="ln5413">    }</a>
<a name="ln5414"> </a>
<a name="ln5415">    monster *ancestor = monster_by_mid(ancestor_mid);</a>
<a name="ln5416">    if (!ancestor || !you.can_see(*ancestor))</a>
<a name="ln5417">    {</a>
<a name="ln5418">        mprf(&quot;%s is not nearby!&quot;, hepliaklqana_ally_name().c_str());</a>
<a name="ln5419">        return spret::abort;</a>
<a name="ln5420">    }</a>
<a name="ln5421"> </a>
<a name="ln5422">    fail_check();</a>
<a name="ln5423"> </a>
<a name="ln5424">    simple_god_message(make_stringf(&quot; grants %s healing and protection!&quot;,</a>
<a name="ln5425">                                    ancestor-&gt;name(DESC_YOUR).c_str()).c_str());</a>
<a name="ln5426"> </a>
<a name="ln5427">    // 1/3 mhp healed at 0 skill, full at 27 invo</a>
<a name="ln5428">    const int healing = ancestor-&gt;max_hit_points</a>
<a name="ln5429">                         * (9 + you.skill(SK_INVOCATIONS)) / 36;</a>
<a name="ln5430"> </a>
<a name="ln5431">    if (ancestor-&gt;heal(healing))</a>
<a name="ln5432">    {</a>
<a name="ln5433">        if (ancestor-&gt;hit_points == ancestor-&gt;max_hit_points)</a>
<a name="ln5434">            simple_monster_message(*ancestor, &quot; is fully restored!&quot;);</a>
<a name="ln5435">        else</a>
<a name="ln5436">            simple_monster_message(*ancestor, &quot; is healed somewhat.&quot;);</a>
<a name="ln5437">    }</a>
<a name="ln5438"> </a>
<a name="ln5439">    const int dur = random_range(50, 80)</a>
<a name="ln5440">                    + random2avg(you.skill(SK_INVOCATIONS, 20), 2);</a>
<a name="ln5441">    ancestor-&gt;add_ench({ ENCH_IDEALISED, 1, &amp;you, dur});</a>
<a name="ln5442">    return spret::success;</a>
<a name="ln5443">}</a>
<a name="ln5444"> </a>
<a name="ln5445">/**</a>
<a name="ln5446"> * Prompt to allow the player to choose a target for the Transference ability.</a>
<a name="ln5447"> *</a>
<a name="ln5448"> * @return  The chosen target, or the origin if none was chosen.</a>
<a name="ln5449"> */</a>
<a name="ln5450">static coord_def _get_transference_target()</a>
<a name="ln5451">{</a>
<a name="ln5452">    dist spd;</a>
<a name="ln5453"> </a>
<a name="ln5454">    const int aoe_radius = have_passive(passive_t::transfer_drain) ? 1 : 0;</a>
<a name="ln5455">    targeter_transference tgt(&amp;you, aoe_radius);</a>
<a name="ln5456">    direction_chooser_args args;</a>
<a name="ln5457">    args.hitfunc = &amp;tgt;</a>
<a name="ln5458">    args.restricts = DIR_TARGET;</a>
<a name="ln5459">    args.mode = TARG_MOBILE_MONSTER;</a>
<a name="ln5460">    args.range = LOS_RADIUS;</a>
<a name="ln5461">    args.needs_path = false;</a>
<a name="ln5462">    args.self = confirm_prompt_type::none;</a>
<a name="ln5463">    args.show_floor_desc = true;</a>
<a name="ln5464">    args.top_prompt = &quot;Select a target.&quot;;</a>
<a name="ln5465"> </a>
<a name="ln5466">    direction(spd, args);</a>
<a name="ln5467"> </a>
<a name="ln5468">    if (!spd.isValid)</a>
<a name="ln5469">        return coord_def();</a>
<a name="ln5470">    return spd.target;</a>
<a name="ln5471">}</a>
<a name="ln5472"> </a>
<a name="ln5473">/// Drain any monsters near the destination of Tranference.</a>
<a name="ln5474">static void _transfer_drain_nearby(coord_def destination)</a>
<a name="ln5475">{</a>
<a name="ln5476">    for (adjacent_iterator it(destination); it; ++it)</a>
<a name="ln5477">    {</a>
<a name="ln5478">        monster* mon = monster_at(*it);</a>
<a name="ln5479">        if (!mon || mons_is_hepliaklqana_ancestor(mon-&gt;type))</a>
<a name="ln5480">            continue;</a>
<a name="ln5481"> </a>
<a name="ln5482">        const int dur = random_range(60, 150);</a>
<a name="ln5483">        // 1-2 at 0 skill, 2-6 at 27 skill.</a>
<a name="ln5484">        const int degree</a>
<a name="ln5485">            = random_range(1 + you.skill_rdiv(SK_INVOCATIONS, 1, 27),</a>
<a name="ln5486">                           2 + you.skill_rdiv(SK_INVOCATIONS, 4, 27));</a>
<a name="ln5487">        if (mon-&gt;add_ench(mon_enchant(ENCH_DRAINED, degree, &amp;you, dur)))</a>
<a name="ln5488">            simple_monster_message(*mon, &quot; is drained by nostalgia.&quot;);</a>
<a name="ln5489">    }</a>
<a name="ln5490">}</a>
<a name="ln5491"> </a>
<a name="ln5492">/**</a>
<a name="ln5493"> * Activate Hepliaklqana's Transference ability, swapping the player's</a>
<a name="ln5494"> * ancestor with a targeted creature &amp; potentially slowing monsters adjacent</a>
<a name="ln5495"> * to the target.</a>
<a name="ln5496"> *</a>
<a name="ln5497"> * @param fail      Whether the effect should fail after checking validity.</a>
<a name="ln5498"> * @return          Whether the ability succeeded, failed, or was aborted.</a>
<a name="ln5499"> */</a>
<a name="ln5500">spret hepliaklqana_transference(bool fail)</a>
<a name="ln5501">{</a>
<a name="ln5502">    monster *ancestor = hepliaklqana_ancestor_mon();</a>
<a name="ln5503">    if (!ancestor || !you.can_see(*ancestor))</a>
<a name="ln5504">    {</a>
<a name="ln5505">        mprf(&quot;%s is not nearby!&quot;, hepliaklqana_ally_name().c_str());</a>
<a name="ln5506">        return spret::abort;</a>
<a name="ln5507">    }</a>
<a name="ln5508"> </a>
<a name="ln5509">    coord_def target = _get_transference_target();</a>
<a name="ln5510">    if (target.origin())</a>
<a name="ln5511">    {</a>
<a name="ln5512">        canned_msg(MSG_OK);</a>
<a name="ln5513">        return spret::abort;</a>
<a name="ln5514">    }</a>
<a name="ln5515"> </a>
<a name="ln5516">    actor* victim = actor_at(target);</a>
<a name="ln5517">    const bool victim_visible = victim &amp;&amp; you.can_see(*victim);</a>
<a name="ln5518">    if ((!victim || !victim_visible)</a>
<a name="ln5519">        &amp;&amp; !yesno(&quot;You can't see anything there. Try transferring anyway?&quot;,</a>
<a name="ln5520">                  true, 'n'))</a>
<a name="ln5521">    {</a>
<a name="ln5522">        canned_msg(MSG_OK);</a>
<a name="ln5523">        return spret::abort;</a>
<a name="ln5524">    }</a>
<a name="ln5525"> </a>
<a name="ln5526">    if (victim == ancestor)</a>
<a name="ln5527">    {</a>
<a name="ln5528">        mpr(&quot;You can't transfer your ancestor with themself.&quot;);</a>
<a name="ln5529">        return spret::abort;</a>
<a name="ln5530">    }</a>
<a name="ln5531"> </a>
<a name="ln5532">    const bool victim_immovable</a>
<a name="ln5533">        = victim &amp;&amp; (mons_is_tentacle_or_tentacle_segment(victim-&gt;type)</a>
<a name="ln5534">                     || victim-&gt;is_stationary());</a>
<a name="ln5535">    if (victim_visible &amp;&amp; victim_immovable)</a>
<a name="ln5536">    {</a>
<a name="ln5537">        mpr(&quot;You can't transfer that.&quot;);</a>
<a name="ln5538">        return spret::abort;</a>
<a name="ln5539">    }</a>
<a name="ln5540"> </a>
<a name="ln5541">    const coord_def destination = ancestor-&gt;pos();</a>
<a name="ln5542">    if (victim == &amp;you &amp;&amp; !check_moveto(destination, &quot;transfer&quot;))</a>
<a name="ln5543">        return spret::abort;</a>
<a name="ln5544"> </a>
<a name="ln5545">    const bool uninhabitable = victim &amp;&amp; !victim-&gt;is_habitable(destination);</a>
<a name="ln5546">    if (uninhabitable &amp;&amp; victim_visible)</a>
<a name="ln5547">    {</a>
<a name="ln5548">        mprf(&quot;%s can't be transferred into %s.&quot;,</a>
<a name="ln5549">             victim-&gt;name(DESC_THE).c_str(), feat_type_name(grd(destination)));</a>
<a name="ln5550">        return spret::abort;</a>
<a name="ln5551">    }</a>
<a name="ln5552"> </a>
<a name="ln5553">    // we assume the ancestor flies &amp; so can survive anywhere anything can.</a>
<a name="ln5554"> </a>
<a name="ln5555">    fail_check();</a>
<a name="ln5556"> </a>
<a name="ln5557">    if (!victim || uninhabitable || victim_immovable)</a>
<a name="ln5558">    {</a>
<a name="ln5559">        canned_msg(MSG_NOTHING_HAPPENS);</a>
<a name="ln5560">        return spret::success;</a>
<a name="ln5561">    }</a>
<a name="ln5562"> </a>
<a name="ln5563">    if (victim-&gt;is_player())</a>
<a name="ln5564">    {</a>
<a name="ln5565">        ancestor-&gt;move_to_pos(target, true, true);</a>
<a name="ln5566">        victim-&gt;move_to_pos(destination, true, true);</a>
<a name="ln5567">    }</a>
<a name="ln5568">    else</a>
<a name="ln5569">        ancestor-&gt;swap_with(victim-&gt;as_monster());</a>
<a name="ln5570"> </a>
<a name="ln5571">    mprf(&quot;%s swap%s with %s!&quot;,</a>
<a name="ln5572">         victim-&gt;name(DESC_THE).c_str(),</a>
<a name="ln5573">         victim-&gt;is_player() ? &quot;&quot; : &quot;s&quot;,</a>
<a name="ln5574">         ancestor-&gt;name(DESC_YOUR).c_str());</a>
<a name="ln5575"> </a>
<a name="ln5576">    check_place_cloud(CLOUD_MIST, target, random_range(10,20), ancestor);</a>
<a name="ln5577">    check_place_cloud(CLOUD_MIST, destination, random_range(10,20), ancestor);</a>
<a name="ln5578"> </a>
<a name="ln5579">    if (victim-&gt;is_monster())</a>
<a name="ln5580">        mons_relocated(victim-&gt;as_monster());</a>
<a name="ln5581"> </a>
<a name="ln5582">    ancestor-&gt;apply_location_effects(destination);</a>
<a name="ln5583">    victim-&gt;apply_location_effects(target);</a>
<a name="ln5584">    if (victim-&gt;is_monster())</a>
<a name="ln5585">        behaviour_event(victim-&gt;as_monster(), ME_DISTURB, &amp;you, target);</a>
<a name="ln5586"> </a>
<a name="ln5587">    if (have_passive(passive_t::transfer_drain))</a>
<a name="ln5588">        _transfer_drain_nearby(target);</a>
<a name="ln5589"> </a>
<a name="ln5590">    return spret::success;</a>
<a name="ln5591">}</a>
<a name="ln5592"> </a>
<a name="ln5593">/// Prompt to rename your ancestor.</a>
<a name="ln5594">static void _hepliaklqana_choose_name()</a>
<a name="ln5595">{</a>
<a name="ln5596">    const string old_name = hepliaklqana_ally_name();</a>
<a name="ln5597">    string prompt  = make_stringf(&quot;Remember %s name as what? &quot;,</a>
<a name="ln5598">                                  apostrophise(old_name).c_str());</a>
<a name="ln5599"> </a>
<a name="ln5600">    char buf[18];</a>
<a name="ln5601">    int ret = msgwin_get_line(prompt, buf, sizeof buf, nullptr, old_name);</a>
<a name="ln5602">    if (ret)</a>
<a name="ln5603">    {</a>
<a name="ln5604">        canned_msg(MSG_OK);</a>
<a name="ln5605">        return;</a>
<a name="ln5606">    }</a>
<a name="ln5607"> </a>
<a name="ln5608">    // strip whitespace &amp; colour tags</a>
<a name="ln5609">    const string new_name</a>
<a name="ln5610">        = trimmed_string(formatted_string::parse_string(buf).tostring());</a>
<a name="ln5611">    if (old_name == new_name || !new_name.size())</a>
<a name="ln5612">    {</a>
<a name="ln5613">        canned_msg(MSG_OK);</a>
<a name="ln5614">        return;</a>
<a name="ln5615">    }</a>
<a name="ln5616"> </a>
<a name="ln5617">    you.props[HEPLIAKLQANA_ALLY_NAME_KEY] = new_name;</a>
<a name="ln5618">    mprf(&quot;Yes, %s is definitely a better name.&quot;, new_name.c_str());</a>
<a name="ln5619">    upgrade_hepliaklqana_ancestor(true);</a>
<a name="ln5620">}</a>
<a name="ln5621"> </a>
<a name="ln5622">static void _hepliaklqana_choose_gender()</a>
<a name="ln5623">{</a>
<a name="ln5624">    static const map&lt;gender_type, string&gt; gender_map =</a>
<a name="ln5625">    {</a>
<a name="ln5626">        { GENDER_NEUTRAL, &quot;neither&quot; },</a>
<a name="ln5627">        { GENDER_MALE,    &quot;male&quot;    },</a>
<a name="ln5628">        { GENDER_FEMALE,  &quot;female&quot;  },</a>
<a name="ln5629">    };</a>
<a name="ln5630"> </a>
<a name="ln5631">    const gender_type current_gender =</a>
<a name="ln5632">        (gender_type)you.props[HEPLIAKLQANA_ALLY_GENDER_KEY].get_int();</a>
<a name="ln5633">    const string* desc = map_find(gender_map, current_gender);</a>
<a name="ln5634">    ASSERT(desc);</a>
<a name="ln5635"> </a>
<a name="ln5636">    mprf(MSGCH_PROMPT,</a>
<a name="ln5637">         &quot;Was %s a) male, b) female, or c) neither? (Currently %s.)&quot;,</a>
<a name="ln5638">         hepliaklqana_ally_name().c_str(),</a>
<a name="ln5639">         desc-&gt;c_str());</a>
<a name="ln5640"> </a>
<a name="ln5641">    int keyin = toalower(get_ch());</a>
<a name="ln5642">    if (!isaalpha(keyin))</a>
<a name="ln5643">    {</a>
<a name="ln5644">        canned_msg(MSG_OK);</a>
<a name="ln5645">        return;</a>
<a name="ln5646">    }</a>
<a name="ln5647"> </a>
<a name="ln5648">    static const gender_type gender_options[] = { GENDER_MALE,</a>
<a name="ln5649">                                                  GENDER_FEMALE,</a>
<a name="ln5650">                                                  GENDER_NEUTRAL };</a>
<a name="ln5651"> </a>
<a name="ln5652">    const uint32_t choice = keyin - 'a';</a>
<a name="ln5653">    if (choice &gt;= ARRAYSZ(gender_options))</a>
<a name="ln5654">    {</a>
<a name="ln5655">        canned_msg(MSG_OK);</a>
<a name="ln5656">        return;</a>
<a name="ln5657">    }</a>
<a name="ln5658"> </a>
<a name="ln5659">    const gender_type new_gender = gender_options[choice];</a>
<a name="ln5660"> </a>
<a name="ln5661">    if (new_gender == current_gender)</a>
<a name="ln5662">    {</a>
<a name="ln5663">        canned_msg(MSG_OK);</a>
<a name="ln5664">        return;</a>
<a name="ln5665">    }</a>
<a name="ln5666"> </a>
<a name="ln5667">    you.props[HEPLIAKLQANA_ALLY_GENDER_KEY] = new_gender;</a>
<a name="ln5668">    mprf(&quot;%s was always %s, you're pretty sure.&quot;,</a>
<a name="ln5669">         hepliaklqana_ally_name().c_str(),</a>
<a name="ln5670">         map_find(gender_map, new_gender)-&gt;c_str());</a>
<a name="ln5671">    upgrade_hepliaklqana_ancestor(true);</a>
<a name="ln5672">}</a>
<a name="ln5673"> </a>
<a name="ln5674">/// Rename and/or re-gender your ancestor.</a>
<a name="ln5675">void hepliaklqana_choose_identity()</a>
<a name="ln5676">{</a>
<a name="ln5677">    _hepliaklqana_choose_name();</a>
<a name="ln5678">    _hepliaklqana_choose_gender();</a>
<a name="ln5679">}</a>
<a name="ln5680"> </a>
<a name="ln5681">bool wu_jian_can_wall_jump_in_principle(const coord_def&amp; target)</a>
<a name="ln5682">{</a>
<a name="ln5683">    if (!have_passive(passive_t::wu_jian_wall_jump)</a>
<a name="ln5684">        || !feat_can_wall_jump_against(grd(target))</a>
<a name="ln5685">        || you.is_stationary()</a>
<a name="ln5686">        || you.digging)</a>
<a name="ln5687">    {</a>
<a name="ln5688">        return false;</a>
<a name="ln5689">    }</a>
<a name="ln5690">    return true;</a>
<a name="ln5691">}</a>
<a name="ln5692"> </a>
<a name="ln5693">bool wu_jian_can_wall_jump(const coord_def&amp; target, string &amp;error_ret)</a>
<a name="ln5694">{</a>
<a name="ln5695">    if (target.distance_from(you.pos()) != 1)</a>
<a name="ln5696">    {</a>
<a name="ln5697">        error_ret = &quot;Please select an adjacent position to wall jump against.&quot;;</a>
<a name="ln5698">        return false;</a>
<a name="ln5699">    }</a>
<a name="ln5700"> </a>
<a name="ln5701">    if (!wu_jian_can_wall_jump_in_principle(target))</a>
<a name="ln5702">    {</a>
<a name="ln5703">        if (!feat_can_wall_jump_against(grd(target)))</a>
<a name="ln5704">        {</a>
<a name="ln5705">            error_ret = string(&quot;You cannot wall jump against &quot;) +</a>
<a name="ln5706">                feature_description_at(target, false, DESC_THE) + &quot;.&quot;;</a>
<a name="ln5707">        }</a>
<a name="ln5708">        else</a>
<a name="ln5709">            error_ret = &quot;&quot;;</a>
<a name="ln5710">        return false;</a>
<a name="ln5711">    }</a>
<a name="ln5712"> </a>
<a name="ln5713">    auto wall_jump_direction = (you.pos() - target).sgn();</a>
<a name="ln5714">    auto wall_jump_landing_spot = (you.pos() + wall_jump_direction</a>
<a name="ln5715">                                   + wall_jump_direction);</a>
<a name="ln5716"> </a>
<a name="ln5717">    monster* beholder = you.get_beholder(target);</a>
<a name="ln5718">    if (beholder)</a>
<a name="ln5719">    {</a>
<a name="ln5720">        error_ret = make_stringf(&quot;You cannot move your %s away from %s to wall jump!&quot;,</a>
<a name="ln5721">             you.foot_name(true).c_str(),</a>
<a name="ln5722">             beholder-&gt;name(DESC_THE, true).c_str());</a>
<a name="ln5723">        return false;</a>
<a name="ln5724">    }</a>
<a name="ln5725"> </a>
<a name="ln5726">    monster* fearmonger = you.get_fearmonger(wall_jump_landing_spot);</a>
<a name="ln5727">    if (fearmonger)</a>
<a name="ln5728">    {</a>
<a name="ln5729">        error_ret = make_stringf(&quot;You are too afraid to wall jump closer to %s!&quot;,</a>
<a name="ln5730">             fearmonger-&gt;name(DESC_THE, true).c_str());</a>
<a name="ln5731">        return false;</a>
<a name="ln5732">    }</a>
<a name="ln5733"> </a>
<a name="ln5734">    const actor* landing_actor = actor_at(wall_jump_landing_spot);</a>
<a name="ln5735">    if (feat_is_solid(grd(you.pos() + wall_jump_direction))</a>
<a name="ln5736">        || !in_bounds(wall_jump_landing_spot)</a>
<a name="ln5737">        || !you.is_habitable(wall_jump_landing_spot)</a>
<a name="ln5738">        || landing_actor)</a>
<a name="ln5739">    {</a>
<a name="ln5740">        if (landing_actor)</a>
<a name="ln5741">        {</a>
<a name="ln5742">            error_ret = make_stringf(</a>
<a name="ln5743">                &quot;You have no room to wall jump there; %s is in the way.&quot;,</a>
<a name="ln5744">                landing_actor-&gt;observable()</a>
<a name="ln5745">                            ? landing_actor-&gt;name(DESC_THE).c_str()</a>
<a name="ln5746">                            : &quot;something you can't see&quot;);</a>
<a name="ln5747">        }</a>
<a name="ln5748">        else</a>
<a name="ln5749">            error_ret = &quot;You have no room to wall jump there.&quot;;</a>
<a name="ln5750">        return false;</a>
<a name="ln5751">    }</a>
<a name="ln5752">    error_ret = &quot;&quot;;</a>
<a name="ln5753">    return true;</a>
<a name="ln5754">}</a>
<a name="ln5755"> </a>
<a name="ln5756">/**</a>
<a name="ln5757"> * Do a walljump.</a>
<a name="ln5758"> *</a>
<a name="ln5759"> * This doesn't check whether there's space; see `wu_jian_can_wall_jump`.</a>
<a name="ln5760"> * It does check whether the landing spot is safe, excluded, etc.</a>
<a name="ln5761"> *</a>
<a name="ln5762"> * @param targ the movement target (i.e. the wall being moved against).</a>
<a name="ln5763"> * @return whether the jump culminated.</a>
<a name="ln5764"> */</a>
<a name="ln5765">bool wu_jian_do_wall_jump(coord_def targ)</a>
<a name="ln5766">{</a>
<a name="ln5767">    // whether there's space in the first place is checked earlier</a>
<a name="ln5768">    // in wu_jian_can_wall_jump.</a>
<a name="ln5769">    auto wall_jump_direction = (you.pos() - targ).sgn();</a>
<a name="ln5770">    auto wall_jump_landing_spot = (you.pos() + wall_jump_direction</a>
<a name="ln5771">                                   + wall_jump_direction);</a>
<a name="ln5772">    if (!check_moveto(wall_jump_landing_spot, &quot;wall jump&quot;))</a>
<a name="ln5773">    {</a>
<a name="ln5774">        you.turn_is_over = false;</a>
<a name="ln5775">        return false;</a>
<a name="ln5776">    }</a>
<a name="ln5777"> </a>
<a name="ln5778">    auto initial_position = you.pos();</a>
<a name="ln5779">    move_player_to_grid(wall_jump_landing_spot, false);</a>
<a name="ln5780">    wu_jian_wall_jump_effects();</a>
<a name="ln5781"> </a>
<a name="ln5782">    if (you.duration[DUR_WATER_HOLD])</a>
<a name="ln5783">    {</a>
<a name="ln5784">        mpr(&quot;You slip free of the water engulfing you.&quot;);</a>
<a name="ln5785">        you.props.erase(&quot;water_holder&quot;);</a>
<a name="ln5786">        you.clear_far_engulf();</a>
<a name="ln5787">    }</a>
<a name="ln5788"> </a>
<a name="ln5789">    int wall_jump_modifier = (you.attribute[ATTR_SERPENTS_LASH] != 1) ? 2</a>
<a name="ln5790">                                                                      : 1;</a>
<a name="ln5791"> </a>
<a name="ln5792">    you.time_taken = player_speed() * wall_jump_modifier</a>
<a name="ln5793">                     * player_movement_speed();</a>
<a name="ln5794">    you.time_taken = div_rand_round(you.time_taken, 10);</a>
<a name="ln5795"> </a>
<a name="ln5796">    // need to set this here in case serpent's lash isn't active</a>
<a name="ln5797">    you.turn_is_over = true;</a>
<a name="ln5798">    request_autopickup();</a>
<a name="ln5799">    wu_jian_post_move_effects(true, initial_position);</a>
<a name="ln5800"> </a>
<a name="ln5801">    return true;</a>
<a name="ln5802">}</a>
<a name="ln5803"> </a>
<a name="ln5804">spret wu_jian_wall_jump_ability()</a>
<a name="ln5805">{</a>
<a name="ln5806">    ASSERT(!crawl_state.game_is_arena());</a>
<a name="ln5807"> </a>
<a name="ln5808">    if (crawl_state.is_repeating_cmd())</a>
<a name="ln5809">    {</a>
<a name="ln5810">        crawl_state.cant_cmd_repeat(&quot;You can't repeat a wall jump.&quot;);</a>
<a name="ln5811">        crawl_state.cancel_cmd_again();</a>
<a name="ln5812">        crawl_state.cancel_cmd_repeat();</a>
<a name="ln5813">        return spret::abort;</a>
<a name="ln5814">    }</a>
<a name="ln5815"> </a>
<a name="ln5816">    if (cancel_barbed_move())</a>
<a name="ln5817">        return spret::abort;</a>
<a name="ln5818"> </a>
<a name="ln5819">    if (you.digging)</a>
<a name="ln5820">    {</a>
<a name="ln5821">        you.digging = false;</a>
<a name="ln5822">        mpr(&quot;You retract your mandibles.&quot;);</a>
<a name="ln5823">    }</a>
<a name="ln5824"> </a>
<a name="ln5825">    string wj_error;</a>
<a name="ln5826">    bool has_targets = false;</a>
<a name="ln5827"> </a>
<a name="ln5828">    for (adjacent_iterator ai(you.pos()); ai; ++ai)</a>
<a name="ln5829">        if (wu_jian_can_wall_jump(*ai, wj_error))</a>
<a name="ln5830">        {</a>
<a name="ln5831">            has_targets = true;</a>
<a name="ln5832">            break;</a>
<a name="ln5833">        }</a>
<a name="ln5834"> </a>
<a name="ln5835">    if (!has_targets)</a>
<a name="ln5836">    {</a>
<a name="ln5837">        mpr(&quot;There is nothing to wall jump against here.&quot;);</a>
<a name="ln5838">        return spret::abort;</a>
<a name="ln5839">    }</a>
<a name="ln5840"> </a>
<a name="ln5841">    if (you.is_nervous())</a>
<a name="ln5842">    {</a>
<a name="ln5843">        mpr(&quot;You are too terrified to wall jump!&quot;);</a>
<a name="ln5844">        return spret::abort;</a>
<a name="ln5845">    }</a>
<a name="ln5846"> </a>
<a name="ln5847">    if (you.attribute[ATTR_HELD])</a>
<a name="ln5848">    {</a>
<a name="ln5849">        mprf(&quot;You cannot wall jump while caught in a %s.&quot;,</a>
<a name="ln5850">             get_trapping_net(you.pos()) == NON_ITEM ? &quot;web&quot; : &quot;net&quot;);</a>
<a name="ln5851">        return spret::abort;</a>
<a name="ln5852">    }</a>
<a name="ln5853"> </a>
<a name="ln5854">    if (!you.attempt_escape())</a>
<a name="ln5855">        return spret::fail;</a>
<a name="ln5856"> </a>
<a name="ln5857">    // query for location:</a>
<a name="ln5858">    dist beam;</a>
<a name="ln5859"> </a>
<a name="ln5860">    while (1)</a>
<a name="ln5861">    {</a>
<a name="ln5862">        direction_chooser_args args;</a>
<a name="ln5863">        args.restricts = DIR_TARGET;</a>
<a name="ln5864">        args.mode = TARG_ANY;</a>
<a name="ln5865">        args.range = 1;</a>
<a name="ln5866">        args.needs_path = false; // TODO: overridden by hitfunc?</a>
<a name="ln5867">        args.top_prompt = &quot;Aiming: &lt;white&gt;Wall Jump&lt;/white&gt;&quot;;</a>
<a name="ln5868">        args.self = confirm_prompt_type::cancel;</a>
<a name="ln5869">        targeter_walljump tgt;</a>
<a name="ln5870">        tgt.obeys_mesmerise = true;</a>
<a name="ln5871">        args.hitfunc = &amp;tgt;</a>
<a name="ln5872">        {</a>
<a name="ln5873">            // TODO: make this unnecessary</a>
<a name="ln5874">            direction_chooser dc(beam, args);</a>
<a name="ln5875">            dc.needs_path = false;</a>
<a name="ln5876">            dc.choose_direction();</a>
<a name="ln5877">        }</a>
<a name="ln5878">        if (crawl_state.seen_hups)</a>
<a name="ln5879">        {</a>
<a name="ln5880">            clear_messages();</a>
<a name="ln5881">            mpr(&quot;Cancelling wall jump due to HUP.&quot;);</a>
<a name="ln5882">            return spret::abort;</a>
<a name="ln5883">        }</a>
<a name="ln5884"> </a>
<a name="ln5885">        if (!beam.isValid || beam.target == you.pos())</a>
<a name="ln5886">            return spret::abort; // early return</a>
<a name="ln5887"> </a>
<a name="ln5888">        if (wu_jian_can_wall_jump(beam.target, wj_error))</a>
<a name="ln5889">            break;</a>
<a name="ln5890">    }</a>
<a name="ln5891"> </a>
<a name="ln5892">    if (!wu_jian_do_wall_jump(beam.target))</a>
<a name="ln5893">        return spret::abort;</a>
<a name="ln5894"> </a>
<a name="ln5895">    crawl_state.cancel_cmd_again();</a>
<a name="ln5896">    crawl_state.cancel_cmd_repeat();</a>
<a name="ln5897"> </a>
<a name="ln5898">    apply_barbs_damage();</a>
<a name="ln5899">    remove_ice_armour_movement();</a>
<a name="ln5900">    return spret::success;</a>
<a name="ln5901">}</a>
<a name="ln5902"> </a>
<a name="ln5903">void wu_jian_heavenly_storm()</a>
<a name="ln5904">{</a>
<a name="ln5905">    mprf(MSGCH_GOD, &quot;The air is filled with shimmering golden clouds!&quot;);</a>
<a name="ln5906">    wu_jian_sifu_message(&quot; says: The storm will not cease as long as you &quot;</a>
<a name="ln5907">                         &quot;keep fighting, disciple!&quot;);</a>
<a name="ln5908"> </a>
<a name="ln5909">    for (radius_iterator ai(you.pos(), 2, C_SQUARE, LOS_SOLID); ai; ++ai)</a>
<a name="ln5910">        if (!cell_is_solid(*ai))</a>
<a name="ln5911">            place_cloud(CLOUD_GOLD_DUST, *ai, 5 + random2(5), &amp;you);</a>
<a name="ln5912"> </a>
<a name="ln5913">    you.set_duration(DUR_HEAVENLY_STORM, random_range(2, 3));</a>
<a name="ln5914">    you.props[WU_JIAN_HEAVENLY_STORM_KEY] = WU_JIAN_HEAVENLY_STORM_INITIAL;</a>
<a name="ln5915">    invalidate_agrid(true);</a>
<a name="ln5916">}</a>

</code></pre>
<div class="balloon" rel="1907"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v648/" target="_blank">V648</a> Priority of the '&&' operation is higher than that of the '||' operation.</p></div>
<div class="balloon" rel="2121"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v648/" target="_blank">V648</a> Priority of the '&&' operation is higher than that of the '||' operation.</p></div>
<div class="balloon" rel="3948"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v547/" target="_blank">V547</a> Expression 'mut == MUT_DOPEY' is always true.</p></div>

<link rel="stylesheet" href="highlight.css">
<script src="highlight.pack.js"></script>
<script src="highlightjs-line-numbers.js"></script>
<script>hljs.initHighlightingOnLoad();</script>
<script>hljs.initLineNumbersOnLoad();</script>
<script>
  $(document).ready(function() {
      $('.balloon').each(function () {
          var bl = $(this);
          var line = bl.attr('rel');
          var text = $('a[name="ln'+line+'"]').text();

          var space_count = 0;
          for(var i = 0; i<text.length; i++){
              var char = text[i];
              if((char !== ' ')&&(char !== '\t'))break;
              if(char === '\t')space_count++;
              space_count++;
          }

          bl.css('margin-left', space_count*8);
          $('a[name="ln'+line+'"]').after(bl);
      });

      window.location = window.location;
  });
</script>
</body>
</html>
