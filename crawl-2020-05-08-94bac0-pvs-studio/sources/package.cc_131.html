
<html>
<head>

  <meta http-equiv="Content-Type" content="text/html; charset=US-ASCII" />
  <title>package.cc</title>

  <link rel="stylesheet" href="../style.css"/>
  <script src="../jquery-3.2.1.min.js"></script>
</head>
<body>

<pre><code class = "cpp">
<a name="ln1">/**</a>
<a name="ln2"> * @file</a>
<a name="ln3"> * @brief A container for chunks that make up the save file.</a>
<a name="ln4">**/</a>
<a name="ln5"> </a>
<a name="ln6">/*</a>
<a name="ln7">Guarantees:</a>
<a name="ln8">* A crash at any moment may not cause corruption -- the save will return to</a>
<a name="ln9">  the exact state it had at the last commit().</a>
<a name="ln10"> </a>
<a name="ln11">Notes:</a>
<a name="ln12">* Unless DO_FSYNC is defined, crashes that put down the operating system</a>
<a name="ln13">  may break the consistency guarantee.</a>
<a name="ln14">* Incomplete writes don't have any effects, but don't break commits or reads</a>
<a name="ln15">  (which both use the last complete write).</a>
<a name="ln16">* Readers always get the last complete (but not necessarily committed) write</a>
<a name="ln17">  (ie, READ_UNCOMMITTED) at the time they started; it is safe to continue</a>
<a name="ln18">  reading even if the chunk has been changed since.</a>
<a name="ln19">*/</a>
<a name="ln20"> </a>
<a name="ln21">#include &quot;AppHdr.h&quot;</a>
<a name="ln22"> </a>
<a name="ln23">#include &quot;package.h&quot;</a>
<a name="ln24"> </a>
<a name="ln25">#include &lt;cstdio&gt;</a>
<a name="ln26">#include &lt;cstdlib&gt;</a>
<a name="ln27">#include &lt;cstring&gt;</a>
<a name="ln28">#include &lt;sstream&gt;</a>
<a name="ln29">#include &lt;fcntl.h&gt;</a>
<a name="ln30">#include &lt;sys/stat.h&gt;</a>
<a name="ln31">#include &lt;sys/types.h&gt;</a>
<a name="ln32">#include &lt;unistd.h&gt;</a>
<a name="ln33"> </a>
<a name="ln34">#include &quot;end.h&quot;</a>
<a name="ln35">#include &quot;endianness.h&quot;</a>
<a name="ln36">#include &quot;errors.h&quot;</a>
<a name="ln37">#include &quot;syscalls.h&quot;</a>
<a name="ln38">#include &quot;libutil.h&quot; // map_find</a>
<a name="ln39"> </a>
<a name="ln40">// debugging defines</a>
<a name="ln41">#undef  FSCK_VERBOSE</a>
<a name="ln42">#undef  COSTLY_ASSERTS</a>
<a name="ln43">#undef  DEBUG_PACKAGE</a>
<a name="ln44"> </a>
<a name="ln45">static plen_t htole(plen_t x)</a>
<a name="ln46">{</a>
<a name="ln47">    if (sizeof(plen_t) == 4)</a>
<a name="ln48">        return htole32(x);</a>
<a name="ln49">    if (sizeof(plen_t) == 8)</a>
<a name="ln50">        return htole64(x);</a>
<a name="ln51">    die(&quot;unsupported plen_t size&quot;);</a>
<a name="ln52">}</a>
<a name="ln53"> </a>
<a name="ln54">#ifdef DEBUG_PACKAGE</a>
<a name="ln55">#define dprintf(...) printf(__VA_ARGS__)</a>
<a name="ln56">#else</a>
<a name="ln57">#define dprintf(...) do {} while (0)</a>
<a name="ln58">#endif</a>
<a name="ln59"> </a>
<a name="ln60">#define PACKAGE_VERSION 1</a>
<a name="ln61">#define PACKAGE_MAGIC   0x53534344 /* &quot;DCSS&quot; */</a>
<a name="ln62"> </a>
<a name="ln63">struct file_header</a>
<a name="ln64">{</a>
<a name="ln65">    uint32_t magic;</a>
<a name="ln66">    uint8_t version;</a>
<a name="ln67">    char padding[3];</a>
<a name="ln68">    plen_t start;</a>
<a name="ln69">};</a>
<a name="ln70"> </a>
<a name="ln71">struct block_header</a>
<a name="ln72">{</a>
<a name="ln73">    plen_t len;</a>
<a name="ln74">    plen_t next;</a>
<a name="ln75">};</a>
<a name="ln76"> </a>
<a name="ln77">typedef map&lt;string, plen_t&gt; directory_t;</a>
<a name="ln78">typedef pair&lt;plen_t, plen_t&gt; bm_p;</a>
<a name="ln79">typedef map&lt;plen_t, bm_p&gt; bm_t;</a>
<a name="ln80">typedef map&lt;plen_t, plen_t&gt; fb_t;</a>
<a name="ln81"> </a>
<a name="ln82">package::package(const char* file, bool writeable, bool empty)</a>
<a name="ln83">  : n_users(0), dirty(false), aborted(false)</a>
<a name="ln84">#ifdef DO_FSYNC</a>
<a name="ln85">    , tmp(false)</a>
<a name="ln86">#endif</a>
<a name="ln87">{</a>
<a name="ln88">    dprintf(&quot;package: initializing file=\&quot;%s\&quot; rw=%d\n&quot;, file, writeable);</a>
<a name="ln89">    ASSERT(writeable || !empty);</a>
<a name="ln90">    filename = file;</a>
<a name="ln91">    rw = writeable;</a>
<a name="ln92"> </a>
<a name="ln93">    if (empty)</a>
<a name="ln94">    {</a>
<a name="ln95">        fd = open_u(file, O_RDWR | O_CREAT | O_TRUNC | O_BINARY, 0666);</a>
<a name="ln96">        if (fd == -1)</a>
<a name="ln97">            sysfail(&quot;can't create save file (%s)&quot;, file);</a>
<a name="ln98"> </a>
<a name="ln99">        if (!lock_file(fd, true))</a>
<a name="ln100">        {</a>
<a name="ln101">            close(fd);</a>
<a name="ln102">            sysfail(&quot;failed to lock newly created save (%s)&quot;, file);</a>
<a name="ln103">        }</a>
<a name="ln104"> </a>
<a name="ln105">        dirty = true;</a>
<a name="ln106">        file_len = sizeof(file_header);</a>
<a name="ln107">    }</a>
<a name="ln108">    else</a>
<a name="ln109">    {</a>
<a name="ln110">        fd = open_u(file, (writeable? O_RDWR : O_RDONLY) | O_BINARY, 0666);</a>
<a name="ln111">        if (fd == -1)</a>
<a name="ln112">            sysfail(&quot;can't open save file (%s)&quot;, file);</a>
<a name="ln113"> </a>
<a name="ln114">        try</a>
<a name="ln115">        {</a>
<a name="ln116">            if (!lock_file(fd, writeable))</a>
<a name="ln117">            {</a>
<a name="ln118">                game_ended(game_exit::abort,</a>
<a name="ln119">                    &quot;Another game is already in progress using this save!&quot;);</a>
<a name="ln120">            }</a>
<a name="ln121"> </a>
<a name="ln122">            load();</a>
<a name="ln123">        }</a>
<a name="ln124">        catch (exception &amp;e)</a>
<a name="ln125">        {</a>
<a name="ln126">            close(fd);</a>
<a name="ln127">            throw;</a>
<a name="ln128">        }</a>
<a name="ln129">    }</a>
<a name="ln130">}</a>
<a name="ln131"> </a>
<a name="ln132">package::package()</a>
<a name="ln133">  : rw(true), n_users(0), dirty(false), aborted(false)</a>
<a name="ln134">#ifdef DO_FSYNC</a>
<a name="ln135">    , tmp(true)</a>
<a name="ln136">#endif</a>
<a name="ln137">{</a>
<a name="ln138">    dprintf(&quot;package: initializing tmp file\n&quot;);</a>
<a name="ln139">    filename = &quot;[tmp]&quot;;</a>
<a name="ln140"> </a>
<a name="ln141">    char file[7] = &quot;XXXXXX&quot;;</a>
<a name="ln142">    fd = mkstemp(file);</a>
<a name="ln143">    if (fd == -1)</a>
<a name="ln144">        sysfail(&quot;can't create temporary save file&quot;);</a>
<a name="ln145"> </a>
<a name="ln146">    ::unlink(file); // FIXME: won't work on Windows</a>
<a name="ln147"> </a>
<a name="ln148">    if (!lock_file(fd, true))</a>
<a name="ln149">    {</a>
<a name="ln150">        close(fd);</a>
<a name="ln151">        sysfail(&quot;failed to lock newly created save (%s)&quot;, file);</a>
<a name="ln152">    }</a>
<a name="ln153"> </a>
<a name="ln154">    dirty = true;</a>
<a name="ln155">    file_len = sizeof(file_header);</a>
<a name="ln156">}</a>
<a name="ln157"> </a>
<a name="ln158">void package::load()</a>
<a name="ln159">{</a>
<a name="ln160">    file_header head;</a>
<a name="ln161">    ssize_t res = ::read(fd, &amp;head, sizeof(file_header));</a>
<a name="ln162">    if (res &lt; 0)</a>
<a name="ln163">        sysfail(&quot;error reading the save file (%s)&quot;, filename.c_str());</a>
<a name="ln164">    if (!res || !(head.magic || head.version || head.padding[0]</a>
<a name="ln165">                  || head.padding[1] || head.padding[2] || head.start))</a>
<a name="ln166">    {</a>
<a name="ln167">        corrupted(&quot;The save file (%s) is empty!&quot;, filename.c_str());</a>
<a name="ln168">    }</a>
<a name="ln169">    if (res != sizeof(file_header))</a>
<a name="ln170">        corrupted(&quot;save file (%s) corrupted -- header truncated&quot;, filename.c_str());</a>
<a name="ln171"> </a>
<a name="ln172">    if (htole(head.magic) != PACKAGE_MAGIC)</a>
<a name="ln173">    {</a>
<a name="ln174">        corrupted(&quot;save file (%s) corrupted -- not a DCSS save file&quot;,</a>
<a name="ln175">             filename.c_str());</a>
<a name="ln176">    }</a>
<a name="ln177">    off_t len = lseek(fd, 0, SEEK_END);</a>
<a name="ln178">    if (len == -1)</a>
<a name="ln179">        sysfail(&quot;save file (%s) is not seekable&quot;, filename.c_str());</a>
<a name="ln180">    file_len = len;</a>
<a name="ln181">    read_directory(htole(head.start), head.version);</a>
<a name="ln182"> </a>
<a name="ln183">    if (rw)</a>
<a name="ln184">        load_traces();</a>
<a name="ln185">}</a>
<a name="ln186"> </a>
<a name="ln187">void package::load_traces()</a>
<a name="ln188">{</a>
<a name="ln189">    ASSERT(!dirty);</a>
<a name="ln190">    ASSERT(!n_users);</a>
<a name="ln191">    if (directory.empty() || !block_map.empty())</a>
<a name="ln192">        return;</a>
<a name="ln193"> </a>
<a name="ln194">    free_blocks[sizeof(file_header)] = file_len - sizeof(file_header);</a>
<a name="ln195"> </a>
<a name="ln196">    for (const auto &amp;entry : directory)</a>
<a name="ln197">        trace_chunk(entry.second);</a>
<a name="ln198"> </a>
<a name="ln199">#ifdef COSTLY_ASSERTS</a>
<a name="ln200">    // any inconsitency in the save is guaranteed to be already found</a>
<a name="ln201">    // by this time -- this checks only for internal bugs</a>
<a name="ln202">    fsck();</a>
<a name="ln203">#endif</a>
<a name="ln204">}</a>
<a name="ln205"> </a>
<a name="ln206">package::~package()</a>
<a name="ln207">{</a>
<a name="ln208">    dprintf(&quot;package: finalizing\n&quot;);</a>
<a name="ln209">    ASSERT(!n_users || CrawlIsCrashing); // not merely aborted, there are</a>
<a name="ln210">        // live pointers to us. With normal stack unwinding, destructors</a>
<a name="ln211">        // will make sure this never happens and this assert is good for</a>
<a name="ln212">        // catching missing manual deletes. The C++ exit handler is the</a>
<a name="ln213">        // only place that can be legitimately call things in wrong order.</a>
<a name="ln214"> </a>
<a name="ln215">    if (rw &amp;&amp; !aborted)</a>
<a name="ln216">    {</a>
<a name="ln217">        commit();</a>
<a name="ln218">        if (ftruncate(fd, file_len))</a>
<a name="ln219">            sysfail(&quot;failed to update save file&quot;);</a>
<a name="ln220">    }</a>
<a name="ln221"> </a>
<a name="ln222">    // all errors here should be cached write errors</a>
<a name="ln223">    if (fd != -1)</a>
<a name="ln224">        if (close(fd) &amp;&amp; !aborted)</a>
<a name="ln225">        {</a>
<a name="ln226">            sysfail(rw ? &quot;write error while saving&quot;</a>
<a name="ln227">                       : &quot;can't close the save I've just read???&quot;);</a>
<a name="ln228">        }</a>
<a name="ln229">    dprintf(&quot;package: closed\n&quot;);</a>
<a name="ln230">}</a>
<a name="ln231"> </a>
<a name="ln232">void package::commit()</a>
<a name="ln233">{</a>
<a name="ln234">    ASSERT(rw);</a>
<a name="ln235">    if (!dirty)</a>
<a name="ln236">        return;</a>
<a name="ln237">    ASSERT(!aborted);</a>
<a name="ln238"> </a>
<a name="ln239">#ifdef COSTLY_ASSERTS</a>
<a name="ln240">    fsck();</a>
<a name="ln241">#endif</a>
<a name="ln242"> </a>
<a name="ln243">    file_header head;</a>
<a name="ln244">    head.magic = htole(PACKAGE_MAGIC);</a>
<a name="ln245">    head.version = PACKAGE_VERSION;</a>
<a name="ln246">    memset(&amp;head.padding, 0, sizeof(head.padding));</a>
<a name="ln247">    head.start = htole(write_directory());</a>
<a name="ln248">#ifdef DO_FSYNC</a>
<a name="ln249">    // We need a barrier before updating the link to point at the new directory.</a>
<a name="ln250">    if (!tmp &amp;&amp; fdatasync(fd))</a>
<a name="ln251">        sysfail(&quot;flush error while saving&quot;);</a>
<a name="ln252">#endif</a>
<a name="ln253">    seek(0);</a>
<a name="ln254">    if (write(fd, &amp;head, sizeof(head)) != sizeof(head))</a>
<a name="ln255">        sysfail(&quot;write error while saving&quot;);</a>
<a name="ln256">#ifdef DO_FSYNC</a>
<a name="ln257">    if (!tmp &amp;&amp; fdatasync(fd))</a>
<a name="ln258">        sysfail(&quot;flush error while saving&quot;);</a>
<a name="ln259">#endif</a>
<a name="ln260"> </a>
<a name="ln261">    new_chunks.clear();</a>
<a name="ln262">    collect_blocks();</a>
<a name="ln263">    dirty = false;</a>
<a name="ln264"> </a>
<a name="ln265">#ifdef COSTLY_ASSERTS</a>
<a name="ln266">    fsck();</a>
<a name="ln267">#endif</a>
<a name="ln268">}</a>
<a name="ln269"> </a>
<a name="ln270">void package::seek(plen_t to)</a>
<a name="ln271">{</a>
<a name="ln272">    ASSERT(!aborted);</a>
<a name="ln273"> </a>
<a name="ln274">    if (to &gt; file_len)</a>
<a name="ln275">        corrupted(&quot;save file corrupted -- invalid offset&quot;);</a>
<a name="ln276">    if (lseek(fd, to, SEEK_SET) != (off_t)to)</a>
<a name="ln277">        sysfail(&quot;failed to seek inside the save file&quot;);</a>
<a name="ln278">}</a>
<a name="ln279"> </a>
<a name="ln280">chunk_writer* package::writer(const string &amp;name)</a>
<a name="ln281">{</a>
<a name="ln282">    return new chunk_writer(this, name);</a>
<a name="ln283">}</a>
<a name="ln284"> </a>
<a name="ln285">chunk_reader* package::reader(const string &amp;name)</a>
<a name="ln286">{</a>
<a name="ln287">    if (plen_t *ch = map_find(directory, name))</a>
<a name="ln288">        return new chunk_reader(this, *ch);</a>
<a name="ln289">    return 0;</a>
<a name="ln290">}</a>
<a name="ln291"> </a>
<a name="ln292">plen_t package::extend_block(plen_t at, plen_t size, plen_t by)</a>
<a name="ln293">{</a>
<a name="ln294">    // the header is not counted into the block's size, yet takes space</a>
<a name="ln295">    size += sizeof(block_header);</a>
<a name="ln296">    if (at + size == file_len)</a>
<a name="ln297">    {</a>
<a name="ln298">        // at the end of file</a>
<a name="ln299">        file_len += by;</a>
<a name="ln300">        return by;</a>
<a name="ln301">    }</a>
<a name="ln302"> </a>
<a name="ln303">    auto bl = free_blocks.find(at + size);</a>
<a name="ln304">    if (bl == free_blocks.end())</a>
<a name="ln305">        return 0;</a>
<a name="ln306"> </a>
<a name="ln307">    plen_t free = bl-&gt;second;</a>
<a name="ln308">    dprintf(&quot;reusing %u of %u at %u\n&quot;, by, free, bl-&gt;first);</a>
<a name="ln309">    if (free &lt;= by)</a>
<a name="ln310">    {</a>
<a name="ln311">        // we consume the entire block</a>
<a name="ln312">        by = free;</a>
<a name="ln313">        free_blocks.erase(bl);</a>
<a name="ln314">        return by;</a>
<a name="ln315">    }</a>
<a name="ln316"> </a>
<a name="ln317">    free_blocks.erase(bl);</a>
<a name="ln318">    free_blocks[at + size + by] = free - by;</a>
<a name="ln319"> </a>
<a name="ln320">    return by;</a>
<a name="ln321">}</a>
<a name="ln322"> </a>
<a name="ln323">plen_t package::alloc_block(plen_t &amp;size)</a>
<a name="ln324">{</a>
<a name="ln325">    fb_t::iterator bl, best_big, best_small;</a>
<a name="ln326">    plen_t bb_size = (plen_t)-1, bs_size = 0;</a>
<a name="ln327">    for (bl = free_blocks.begin(); bl!=free_blocks.end(); ++bl)</a>
<a name="ln328">    {</a>
<a name="ln329">        if (bl-&gt;second &lt; bb_size &amp;&amp; bl-&gt;second &gt;= size + sizeof(block_header))</a>
<a name="ln330">            best_big = bl, bb_size = bl-&gt;second;</a>
<a name="ln331">        // don't reuse very small blocks unless they're big enough</a>
<a name="ln332">        else if (bl-&gt;second &gt;= 16 &amp;&amp; bl-&gt;second &gt; bs_size)</a>
<a name="ln333">            best_small = bl, bs_size = bl-&gt;second;</a>
<a name="ln334">    }</a>
<a name="ln335">    if (bb_size != (plen_t)-1)</a>
<a name="ln336">        bl = best_big;</a>
<a name="ln337">    else if (bs_size != 0)</a>
<a name="ln338">        bl = best_small;</a>
<a name="ln339">    else</a>
<a name="ln340">    {</a>
<a name="ln341">        plen_t at = file_len;</a>
<a name="ln342"> </a>
<a name="ln343">        file_len += sizeof(block_header) + size;</a>
<a name="ln344">        return at;</a>
<a name="ln345">    }</a>
<a name="ln346"> </a>
<a name="ln347">    plen_t at = bl-&gt;first;</a>
<a name="ln348">    plen_t free = bl-&gt;second;</a>
<a name="ln349">    dprintf(&quot;found a block for reuse at %u size %u\n&quot;, at, free);</a>
<a name="ln350">    free_blocks.erase(bl);</a>
<a name="ln351">    free -= sizeof(block_header);</a>
<a name="ln352">    if (size &gt; free)</a>
<a name="ln353">        size = free;</a>
<a name="ln354">    if ((free -= size))</a>
<a name="ln355">        free_blocks[at + sizeof(block_header) + size] = free;</a>
<a name="ln356"> </a>
<a name="ln357">    return at;</a>
<a name="ln358">}</a>
<a name="ln359"> </a>
<a name="ln360">void package::finish_chunk(const string &amp;name, plen_t at)</a>
<a name="ln361">{</a>
<a name="ln362">    free_chunk(name);</a>
<a name="ln363">    directory[name] = at;</a>
<a name="ln364">    new_chunks.insert(at);</a>
<a name="ln365">    dirty = true;</a>
<a name="ln366">}</a>
<a name="ln367"> </a>
<a name="ln368">void package::free_chunk(const string &amp;name)</a>
<a name="ln369">{</a>
<a name="ln370">    auto ci = directory.find(name);</a>
<a name="ln371">    if (ci == directory.end())</a>
<a name="ln372">        return;</a>
<a name="ln373"> </a>
<a name="ln374">    dprintf(&quot;freeing chunk(%s)\n&quot;, name.c_str());</a>
<a name="ln375">    if (new_chunks.count(ci-&gt;second))</a>
<a name="ln376">        free_block_chain(ci-&gt;second);</a>
<a name="ln377">    else // can't free committed blocks yet</a>
<a name="ln378">        unlinked_blocks.push_back(ci-&gt;second);</a>
<a name="ln379"> </a>
<a name="ln380">    dirty = true;</a>
<a name="ln381">}</a>
<a name="ln382"> </a>
<a name="ln383">void package::delete_chunk(const string &amp;name)</a>
<a name="ln384">{</a>
<a name="ln385">    free_chunk(name);</a>
<a name="ln386">    directory.erase(name);</a>
<a name="ln387">}</a>
<a name="ln388"> </a>
<a name="ln389">plen_t package::write_directory()</a>
<a name="ln390">{</a>
<a name="ln391">    delete_chunk(&quot;&quot;);</a>
<a name="ln392"> </a>
<a name="ln393">    stringstream dir;</a>
<a name="ln394">    for (const auto &amp;entry : directory)</a>
<a name="ln395">    {</a>
<a name="ln396">        uint8_t name_len = entry.first.length();</a>
<a name="ln397">        dir.write((const char*)&amp;name_len, sizeof(name_len));</a>
<a name="ln398">        dir.write(&amp;entry.first[0], entry.first.length());</a>
<a name="ln399">        plen_t start = htole(entry.second);</a>
<a name="ln400">        dir.write((const char*)&amp;start, sizeof(plen_t));</a>
<a name="ln401">    }</a>
<a name="ln402"> </a>
<a name="ln403">    ASSERT(dir.str().size());</a>
<a name="ln404">    dprintf(&quot;writing directory (%u bytes)\n&quot;, (unsigned int)dir.str().size());</a>
<a name="ln405">    {</a>
<a name="ln406">        chunk_writer dch(this, &quot;&quot;);</a>
<a name="ln407">        dch.write(&amp;dir.str()[0], dir.str().size());</a>
<a name="ln408">    }</a>
<a name="ln409"> </a>
<a name="ln410">    return directory[&quot;&quot;];</a>
<a name="ln411">}</a>
<a name="ln412"> </a>
<a name="ln413">void package::collect_blocks()</a>
<a name="ln414">{</a>
<a name="ln415">    for (ssize_t i = unlinked_blocks.size() - 1; i &gt;= 0; --i)</a>
<a name="ln416">    {</a>
<a name="ln417">        plen_t at = unlinked_blocks[i];</a>
<a name="ln418">        // Blocks may be re-added onto the list if they're in use.</a>
<a name="ln419">        if (i != (ssize_t)unlinked_blocks.size() - 1)</a>
<a name="ln420">            unlinked_blocks[i] = unlinked_blocks[unlinked_blocks.size() - 1];</a>
<a name="ln421">        unlinked_blocks.pop_back();</a>
<a name="ln422">        free_block_chain(at);</a>
<a name="ln423">    }</a>
<a name="ln424">}</a>
<a name="ln425"> </a>
<a name="ln426">void package::free_block_chain(plen_t at)</a>
<a name="ln427">{</a>
<a name="ln428">    if (reader_count.count(at))</a>
<a name="ln429">    {</a>
<a name="ln430">        dprintf(&quot;deleting an in-use chain at %d\n&quot;, at);</a>
<a name="ln431">        unlinked_blocks.push_back(at);</a>
<a name="ln432">        return;</a>
<a name="ln433">    }</a>
<a name="ln434"> </a>
<a name="ln435">    dprintf(&quot;freeing an unlinked chain at %d\n&quot;, at);</a>
<a name="ln436">    while (at)</a>
<a name="ln437">    {</a>
<a name="ln438">        auto bl = block_map.find(at);</a>
<a name="ln439">        ASSERT(bl != block_map.end());</a>
<a name="ln440">        dprintf(&quot;+- at %d size=%d+header\n&quot;, at, bl-&gt;second.first);</a>
<a name="ln441">        free_block(at, bl-&gt;second.first + sizeof(block_header));</a>
<a name="ln442">        at = bl-&gt;second.second;</a>
<a name="ln443">        block_map.erase(bl);</a>
<a name="ln444">    }</a>
<a name="ln445">}</a>
<a name="ln446"> </a>
<a name="ln447">void package::free_block(plen_t at, plen_t size)</a>
<a name="ln448">{</a>
<a name="ln449">    ASSERT(at &gt;= sizeof(file_header));</a>
<a name="ln450">    ASSERT(at + size &lt;= file_len);</a>
<a name="ln451"> </a>
<a name="ln452">    auto neigh = free_blocks.lower_bound(at);</a>
<a name="ln453">    if (neigh != free_blocks.begin())</a>
<a name="ln454">    {</a>
<a name="ln455">        --neigh;</a>
<a name="ln456">        ASSERT(neigh-&gt;first + neigh-&gt;second &lt;= at);</a>
<a name="ln457">        if (neigh-&gt;first + neigh-&gt;second == at)</a>
<a name="ln458">        {</a>
<a name="ln459">            // combine with the left neighbour</a>
<a name="ln460">            at = neigh-&gt;first;</a>
<a name="ln461">            size += neigh-&gt;second;</a>
<a name="ln462">            free_blocks.erase(neigh);</a>
<a name="ln463">        }</a>
<a name="ln464">    }</a>
<a name="ln465"> </a>
<a name="ln466">    neigh = free_blocks.lower_bound(at);</a>
<a name="ln467">    if (neigh != free_blocks.end())</a>
<a name="ln468">    {</a>
<a name="ln469">        ASSERT(neigh-&gt;first &gt;= at + size);</a>
<a name="ln470">        if (neigh-&gt;first == at + size)</a>
<a name="ln471">        {</a>
<a name="ln472">            // combine with the right neighbour</a>
<a name="ln473">            size += neigh-&gt;second;</a>
<a name="ln474">            free_blocks.erase(neigh);</a>
<a name="ln475">        }</a>
<a name="ln476">    }</a>
<a name="ln477"> </a>
<a name="ln478">    if (at + size == file_len)</a>
<a name="ln479">        file_len -= size;</a>
<a name="ln480">    else</a>
<a name="ln481">        free_blocks[at] = size;</a>
<a name="ln482">}</a>
<a name="ln483"> </a>
<a name="ln484">void package::fsck()</a>
<a name="ln485">{</a>
<a name="ln486">    fb_t  save_free_blocks = free_blocks;</a>
<a name="ln487">    plen_t save_file_len = file_len;</a>
<a name="ln488"> </a>
<a name="ln489">#ifdef FSCK_VERBOSE</a>
<a name="ln490">    printf(&quot;Fsck starting.  %u chunks, %u used blocks, %u free ones, file size %u\n&quot;,</a>
<a name="ln491">           (unsigned int)directory.size(), (unsigned int)block_map.size(),</a>
<a name="ln492">           (unsigned int)free_blocks.size(), file_len);</a>
<a name="ln493"> </a>
<a name="ln494">    for (const auto &amp;bl : free_blocks)</a>
<a name="ln495">        printf(&quot;&lt;at %u size %u&gt;\n&quot;, bl.first, bl.second);</a>
<a name="ln496">#endif</a>
<a name="ln497">    for (const auto &amp;bl : block_map)</a>
<a name="ln498">    {</a>
<a name="ln499">#ifdef FSCK_VERBOSE</a>
<a name="ln500">        printf(&quot;[at %u size %u+header]\n&quot;, bl.first, bl.second.first);</a>
<a name="ln501">#endif</a>
<a name="ln502">        free_block(bl.first, bl.second.first + sizeof(block_header));</a>
<a name="ln503">    }</a>
<a name="ln504">    // after freeing everything, the file should be empty</a>
<a name="ln505">    ASSERT(free_blocks.empty());</a>
<a name="ln506">    ASSERT(file_len == sizeof(file_header));</a>
<a name="ln507"> </a>
<a name="ln508">    free_blocks = save_free_blocks;</a>
<a name="ln509">    file_len = save_file_len;</a>
<a name="ln510">}</a>
<a name="ln511"> </a>
<a name="ln512">struct dir_entry0</a>
<a name="ln513">{</a>
<a name="ln514">    char name[sizeof(plen_t)];</a>
<a name="ln515">    plen_t start;</a>
<a name="ln516">};</a>
<a name="ln517"> </a>
<a name="ln518">void package::read_directory(plen_t start, uint8_t version)</a>
<a name="ln519">{</a>
<a name="ln520">    ASSERT(directory.empty());</a>
<a name="ln521">    directory[&quot;&quot;] = start;</a>
<a name="ln522"> </a>
<a name="ln523">    dprintf(&quot;package: reading directory\n&quot;);</a>
<a name="ln524">    chunk_reader rd(this, start);</a>
<a name="ln525"> </a>
<a name="ln526">    switch (version)</a>
<a name="ln527">    {</a>
<a name="ln528">    case 0:</a>
<a name="ln529">        dir_entry0 ch0;</a>
<a name="ln530">        while (plen_t res = rd.read(&amp;ch0, sizeof(dir_entry0)))</a>
<a name="ln531">        {</a>
<a name="ln532">            if (res != sizeof(dir_entry0))</a>
<a name="ln533">                corrupted(&quot;save file corrupted -- truncated directory&quot;);</a>
<a name="ln534">            string chname(ch0.name, 4);</a>
<a name="ln535">            chname.resize(strlen(chname.c_str()));</a>
<a name="ln536">            directory[chname] = htole(ch0.start);</a>
<a name="ln537">            dprintf(&quot;* %s\n&quot;, chname.c_str());</a>
<a name="ln538">        }</a>
<a name="ln539">        break;</a>
<a name="ln540">    case 1:</a>
<a name="ln541">        uint8_t name_len;</a>
<a name="ln542">        plen_t bstart;</a>
<a name="ln543">        while (plen_t res = rd.read(&amp;name_len, sizeof(name_len)))</a>
<a name="ln544">        {</a>
<a name="ln545">            if (res != sizeof(name_len))</a>
<a name="ln546">                corrupted(&quot;save file corrupted -- truncated directory&quot;);</a>
<a name="ln547">            string chname;</a>
<a name="ln548">            chname.resize(name_len);</a>
<a name="ln549">            if (rd.read(&amp;chname[0], name_len) != name_len)</a>
<a name="ln550">                corrupted(&quot;save file corrupted -- truncated directory&quot;);</a>
<a name="ln551">            if (rd.read(&amp;bstart, sizeof(bstart)) != sizeof(bstart))</a>
<a name="ln552">                corrupted(&quot;save file corrupted -- truncated directory&quot;);</a>
<a name="ln553">            directory[chname] = htole(bstart);</a>
<a name="ln554">            dprintf(&quot;* %s\n&quot;, chname.c_str());</a>
<a name="ln555">        }</a>
<a name="ln556">        break;</a>
<a name="ln557">    default:</a>
<a name="ln558">        corrupted(&quot;save file (%s) uses an unknown format %u&quot;, filename.c_str(),</a>
<a name="ln559">             version);</a>
<a name="ln560">    }</a>
<a name="ln561">}</a>
<a name="ln562"> </a>
<a name="ln563">bool package::has_chunk(const string &amp;name)</a>
<a name="ln564">{</a>
<a name="ln565">    return !name.empty() &amp;&amp; directory.count(name);</a>
<a name="ln566">}</a>
<a name="ln567"> </a>
<a name="ln568">vector&lt;string&gt; package::list_chunks()</a>
<a name="ln569">{</a>
<a name="ln570">    vector&lt;string&gt; list;</a>
<a name="ln571">    list.reserve(directory.size());</a>
<a name="ln572">    for (const auto &amp;entry : directory)</a>
<a name="ln573">        if (!entry.first.empty())</a>
<a name="ln574">            list.push_back(entry.first);</a>
<a name="ln575"> </a>
<a name="ln576">    return list;</a>
<a name="ln577">}</a>
<a name="ln578"> </a>
<a name="ln579">void package::trace_chunk(plen_t start)</a>
<a name="ln580">{</a>
<a name="ln581">    while (start)</a>
<a name="ln582">    {</a>
<a name="ln583">        block_header bl;</a>
<a name="ln584">        seek(start);</a>
<a name="ln585">        ssize_t res = ::read(fd, &amp;bl, sizeof(block_header));</a>
<a name="ln586">        if (res &lt; 0)</a>
<a name="ln587">            sysfail(&quot;error reading the save file&quot;);</a>
<a name="ln588">        if (res != sizeof(block_header))</a>
<a name="ln589">            corrupted(&quot;save file corrupted -- block past eof&quot;);</a>
<a name="ln590"> </a>
<a name="ln591">        plen_t len  = htole(bl.len);</a>
<a name="ln592">        plen_t next = htole(bl.next);</a>
<a name="ln593">        plen_t end  = start + len + sizeof(block_header);</a>
<a name="ln594">        dprintf(&quot;{at %u size %u+header}\n&quot;, start, len);</a>
<a name="ln595"> </a>
<a name="ln596">        auto sp = free_blocks.upper_bound(start);</a>
<a name="ln597">        if (sp == free_blocks.begin())</a>
<a name="ln598">            corrupted(&quot;save file corrupted -- overlapping blocks&quot;);</a>
<a name="ln599">        --sp;</a>
<a name="ln600">        plen_t sp_start = sp-&gt;first;</a>
<a name="ln601">        plen_t sp_size  = sp-&gt;second;</a>
<a name="ln602">        if (sp_start &gt; start || sp_start + sp_size &lt; end)</a>
<a name="ln603">            corrupted(&quot;save file corrupted -- overlapping blocks&quot;);</a>
<a name="ln604">        free_blocks.erase(sp);</a>
<a name="ln605">        if (sp_start &lt; start)</a>
<a name="ln606">            free_blocks[sp_start] = start - sp_start;</a>
<a name="ln607">        if (sp_start + sp_size &gt; end)</a>
<a name="ln608">            free_blocks[end] = sp_start + sp_size - end;</a>
<a name="ln609"> </a>
<a name="ln610">        block_map[start] = bm_p(len, next);</a>
<a name="ln611">        start = next;</a>
<a name="ln612">    }</a>
<a name="ln613">}</a>
<a name="ln614"> </a>
<a name="ln615">void package::abort()</a>
<a name="ln616">{</a>
<a name="ln617">    // Disable any further operations, allow a shutdown. All errors past</a>
<a name="ln618">    // this point are ignored (assuming we already failed). All writes since</a>
<a name="ln619">    // the last commit() are lost.</a>
<a name="ln620">    aborted = true;</a>
<a name="ln621">}</a>
<a name="ln622"> </a>
<a name="ln623">void package::unlink()</a>
<a name="ln624">{</a>
<a name="ln625">    abort();</a>
<a name="ln626">    close(fd);</a>
<a name="ln627">    fd = -1;</a>
<a name="ln628">    ::unlink_u(filename.c_str());</a>
<a name="ln629">}</a>
<a name="ln630"> </a>
<a name="ln631">// the amount of free space not at the end of file</a>
<a name="ln632">plen_t package::get_slack()</a>
<a name="ln633">{</a>
<a name="ln634">    load_traces();</a>
<a name="ln635"> </a>
<a name="ln636">    plen_t slack = 0;</a>
<a name="ln637">    for (const auto &amp;bl : free_blocks)</a>
<a name="ln638">        slack += bl.second;</a>
<a name="ln639">    return slack;</a>
<a name="ln640">}</a>
<a name="ln641"> </a>
<a name="ln642">plen_t package::get_chunk_fragmentation(const string &amp;name)</a>
<a name="ln643">{</a>
<a name="ln644">    load_traces();</a>
<a name="ln645">    ASSERT(directory.count(name)); // not has_chunk(), &quot;&quot; is valid</a>
<a name="ln646">    plen_t frags = 0;</a>
<a name="ln647">    plen_t at = directory[name];</a>
<a name="ln648">    while (at)</a>
<a name="ln649">    {</a>
<a name="ln650">        auto bl = block_map.find(at);</a>
<a name="ln651">        ASSERT(bl != block_map.end());</a>
<a name="ln652">        frags ++;</a>
<a name="ln653">        at = bl-&gt;second.second;</a>
<a name="ln654">    }</a>
<a name="ln655">    return frags;</a>
<a name="ln656">}</a>
<a name="ln657"> </a>
<a name="ln658">plen_t package::get_chunk_compressed_length(const string &amp;name)</a>
<a name="ln659">{</a>
<a name="ln660">    load_traces();</a>
<a name="ln661">    ASSERT(directory.count(name)); // not has_chunk(), &quot;&quot; is valid</a>
<a name="ln662">    plen_t len = 0;</a>
<a name="ln663">    plen_t at = directory[name];</a>
<a name="ln664">    while (at)</a>
<a name="ln665">    {</a>
<a name="ln666">        auto bl = block_map.find(at);</a>
<a name="ln667">        ASSERT(bl != block_map.end());</a>
<a name="ln668">        len += bl-&gt;second.first;</a>
<a name="ln669">        at = bl-&gt;second.second;</a>
<a name="ln670">    }</a>
<a name="ln671">    return len;</a>
<a name="ln672">}</a>
<a name="ln673"> </a>
<a name="ln674">chunk_writer::chunk_writer(package *parent, const string &amp;_name)</a>
<a name="ln675">    : first_block(0), cur_block(0), block_len(0)</a>
<a name="ln676">{</a>
<a name="ln677">    ASSERT(parent);</a>
<a name="ln678">    ASSERT(!parent-&gt;aborted);</a>
<a name="ln679"> </a>
<a name="ln680">    // If you need more, please change {read,write}_directory().</a>
<a name="ln681">    ASSERT(MAX_CHUNK_NAME_LENGTH &lt; 256);</a>
<a name="ln682">    ASSERT(_name.length() &lt; MAX_CHUNK_NAME_LENGTH);</a>
<a name="ln683"> </a>
<a name="ln684">    dprintf(&quot;chunk_writer(%s): starting\n&quot;, _name.c_str());</a>
<a name="ln685">    pkg = parent;</a>
<a name="ln686">    pkg-&gt;n_users++;</a>
<a name="ln687">    name = _name;</a>
<a name="ln688"> </a>
<a name="ln689">#ifdef USE_ZLIB</a>
<a name="ln690">    zs.data_type = Z_BINARY;</a>
<a name="ln691">    zs.zalloc    = 0;</a>
<a name="ln692">    zs.zfree     = 0;</a>
<a name="ln693">    zs.opaque    = Z_NULL;</a>
<a name="ln694">    if (deflateInit(&amp;zs, Z_DEFAULT_COMPRESSION))</a>
<a name="ln695">        fail(&quot;save file compression failed during init: %s&quot;, zs.msg);</a>
<a name="ln696">#define ZB_SIZE 32768</a>
<a name="ln697">    zs.next_out  = z_buffer = (Bytef*)malloc(ZB_SIZE);</a>
<a name="ln698">    zs.avail_out = ZB_SIZE;</a>
<a name="ln699">#endif</a>
<a name="ln700">}</a>
<a name="ln701"> </a>
<a name="ln702">chunk_writer::~chunk_writer()</a>
<a name="ln703">{</a>
<a name="ln704">    dprintf(&quot;chunk_writer(%s): closing\n&quot;, name.c_str());</a>
<a name="ln705"> </a>
<a name="ln706">    ASSERT(pkg-&gt;n_users &gt; 0);</a>
<a name="ln707">    pkg-&gt;n_users--;</a>
<a name="ln708">    if (pkg-&gt;aborted)</a>
<a name="ln709">    {</a>
<a name="ln710">#ifdef USE_ZLIB</a>
<a name="ln711">        // ignore errors, they're not relevant anymore</a>
<a name="ln712">        deflateEnd(&amp;zs);</a>
<a name="ln713">        free(z_buffer);</a>
<a name="ln714">#endif</a>
<a name="ln715">        return;</a>
<a name="ln716">    }</a>
<a name="ln717"> </a>
<a name="ln718">#ifdef USE_ZLIB</a>
<a name="ln719">    zs.avail_in = 0;</a>
<a name="ln720">    int res;</a>
<a name="ln721">    do</a>
<a name="ln722">    {</a>
<a name="ln723">        res = deflate(&amp;zs, Z_FINISH);</a>
<a name="ln724">        if (res != Z_STREAM_END &amp;&amp; res != Z_OK &amp;&amp; res != Z_BUF_ERROR)</a>
<a name="ln725">            fail(&quot;save file compression failed: %s&quot;, zs.msg);</a>
<a name="ln726">        raw_write(z_buffer, zs.next_out - z_buffer);</a>
<a name="ln727">        zs.next_out = z_buffer;</a>
<a name="ln728">        zs.avail_out = ZB_SIZE;</a>
<a name="ln729">    } while (res != Z_STREAM_END);</a>
<a name="ln730">    if (deflateEnd(&amp;zs) != Z_OK)</a>
<a name="ln731">        fail(&quot;save file compression failed during clean-up: %s&quot;, zs.msg);</a>
<a name="ln732">    free(z_buffer);</a>
<a name="ln733">#endif</a>
<a name="ln734">    if (cur_block)</a>
<a name="ln735">        finish_block(0);</a>
<a name="ln736">    pkg-&gt;finish_chunk(name, first_block);</a>
<a name="ln737">}</a>
<a name="ln738"> </a>
<a name="ln739">void chunk_writer::raw_write(const void *data, plen_t len)</a>
<a name="ln740">{</a>
<a name="ln741">    while (len &gt; 0)</a>
<a name="ln742">    {</a>
<a name="ln743">        plen_t space = pkg-&gt;extend_block(cur_block, block_len, len);</a>
<a name="ln744">        if (!space)</a>
<a name="ln745">        {</a>
<a name="ln746">            plen_t next_block = pkg-&gt;alloc_block(space = len);</a>
<a name="ln747">            ASSERT(space &gt; 0);</a>
<a name="ln748">            if (cur_block)</a>
<a name="ln749">                finish_block(next_block);</a>
<a name="ln750">            cur_block = next_block;</a>
<a name="ln751">            if (!first_block)</a>
<a name="ln752">                first_block = next_block;</a>
<a name="ln753">            block_len = 0;</a>
<a name="ln754">        }</a>
<a name="ln755"> </a>
<a name="ln756">        pkg-&gt;seek(cur_block + block_len + sizeof(block_header));</a>
<a name="ln757">        if (::write(pkg-&gt;fd, data, space) != (ssize_t)space)</a>
<a name="ln758">            sysfail(&quot;write error while saving&quot;);</a>
<a name="ln759">        data = (char*)data + space;</a>
<a name="ln760">        block_len += space;</a>
<a name="ln761">        len -= space;</a>
<a name="ln762">    }</a>
<a name="ln763">}</a>
<a name="ln764"> </a>
<a name="ln765">void chunk_writer::finish_block(plen_t next)</a>
<a name="ln766">{</a>
<a name="ln767">    block_header head;</a>
<a name="ln768">    head.len = htole(block_len);</a>
<a name="ln769">    head.next = htole(next);</a>
<a name="ln770"> </a>
<a name="ln771">    pkg-&gt;seek(cur_block);</a>
<a name="ln772">    if (::write(pkg-&gt;fd, &amp;head, sizeof(head)) != sizeof(head))</a>
<a name="ln773">        sysfail(&quot;write error while saving&quot;);</a>
<a name="ln774"> </a>
<a name="ln775">    pkg-&gt;block_map[cur_block] = bm_p(block_len, next);</a>
<a name="ln776">}</a>
<a name="ln777"> </a>
<a name="ln778">void chunk_writer::write(const void *data, plen_t len)</a>
<a name="ln779">{</a>
<a name="ln780">    ASSERT(data);</a>
<a name="ln781">    ASSERT(!pkg-&gt;aborted);</a>
<a name="ln782"> </a>
<a name="ln783">#ifdef USE_ZLIB</a>
<a name="ln784">    zs.next_in  = (Bytef*)data;</a>
<a name="ln785">    zs.avail_in = len;</a>
<a name="ln786">    while (zs.avail_in)</a>
<a name="ln787">    {</a>
<a name="ln788">        if (!zs.avail_out)</a>
<a name="ln789">        {</a>
<a name="ln790">            raw_write(z_buffer, zs.next_out - z_buffer);</a>
<a name="ln791">            zs.next_out  = z_buffer;</a>
<a name="ln792">            zs.avail_out = ZB_SIZE;</a>
<a name="ln793">        }</a>
<a name="ln794">        // we don't allow Z_BUF_ERROR, so it's fatal for us</a>
<a name="ln795">        if (deflate(&amp;zs, Z_NO_FLUSH) != Z_OK)</a>
<a name="ln796">            fail(&quot;save file compression failed: %s&quot;, zs.msg);</a>
<a name="ln797">    }</a>
<a name="ln798">#else</a>
<a name="ln799">    raw_write(data, len);</a>
<a name="ln800">#endif</a>
<a name="ln801">}</a>
<a name="ln802"> </a>
<a name="ln803">void chunk_reader::init(plen_t start)</a>
<a name="ln804">{</a>
<a name="ln805">    ASSERT(!pkg-&gt;aborted);</a>
<a name="ln806">    pkg-&gt;n_users++;</a>
<a name="ln807">    pkg-&gt;reader_count[start]++;</a>
<a name="ln808">    first_block = next_block = start;</a>
<a name="ln809">    block_left = 0;</a>
<a name="ln810"> </a>
<a name="ln811">#ifdef USE_ZLIB</a>
<a name="ln812">    if (!start)</a>
<a name="ln813">        corrupted(&quot;save file corrupted -- zlib header missing&quot;);</a>
<a name="ln814"> </a>
<a name="ln815">    zs.zalloc    = 0;</a>
<a name="ln816">    zs.zfree     = 0;</a>
<a name="ln817">    zs.opaque    = Z_NULL;</a>
<a name="ln818">    zs.next_in   = Z_NULL;</a>
<a name="ln819">    zs.avail_in  = 0;</a>
<a name="ln820">    if (inflateInit(&amp;zs))</a>
<a name="ln821">        fail(&quot;save file decompression failed during init: %s&quot;, zs.msg);</a>
<a name="ln822">    eof = false;</a>
<a name="ln823">#endif</a>
<a name="ln824">}</a>
<a name="ln825"> </a>
<a name="ln826">chunk_reader::chunk_reader(package *parent, plen_t start)</a>
<a name="ln827">{</a>
<a name="ln828">    ASSERT(parent);</a>
<a name="ln829">    dprintf(&quot;chunk_reader[%u]: starting\n&quot;, start);</a>
<a name="ln830">    pkg = parent;</a>
<a name="ln831">    init(start);</a>
<a name="ln832">}</a>
<a name="ln833"> </a>
<a name="ln834">chunk_reader::chunk_reader(package *parent, const string &amp;_name)</a>
<a name="ln835">{</a>
<a name="ln836">    ASSERT(parent);</a>
<a name="ln837">    if (!parent-&gt;has_chunk(_name))</a>
<a name="ln838">        corrupted(&quot;save file corrupted -- chunk \&quot;%s\&quot; missing&quot;, _name.c_str());</a>
<a name="ln839">    dprintf(&quot;chunk_reader(%s): starting\n&quot;, _name.c_str());</a>
<a name="ln840">    pkg = parent;</a>
<a name="ln841">    init(parent-&gt;directory[_name]);</a>
<a name="ln842">}</a>
<a name="ln843"> </a>
<a name="ln844">chunk_reader::~chunk_reader()</a>
<a name="ln845">{</a>
<a name="ln846">    dprintf(&quot;chunk_reader: closing\n&quot;);</a>
<a name="ln847"> </a>
<a name="ln848">#ifdef USE_ZLIB</a>
<a name="ln849">    if (inflateEnd(&amp;zs) != Z_OK)</a>
<a name="ln850">        fail(&quot;save file decompression failed during clean-up: %s&quot;, zs.msg);</a>
<a name="ln851">#endif</a>
<a name="ln852">    ASSERT(pkg-&gt;reader_count[first_block] &gt; 0);</a>
<a name="ln853">    if (!--pkg-&gt;reader_count[first_block])</a>
<a name="ln854">        pkg-&gt;reader_count.erase(first_block);</a>
<a name="ln855">    ASSERT(pkg-&gt;n_users &gt; 0);</a>
<a name="ln856">    pkg-&gt;n_users--;</a>
<a name="ln857">}</a>
<a name="ln858"> </a>
<a name="ln859">plen_t chunk_reader::raw_read(void *data, plen_t len)</a>
<a name="ln860">{</a>
<a name="ln861">    void *buf = data;</a>
<a name="ln862">    while (len)</a>
<a name="ln863">    {</a>
<a name="ln864">        if (!block_left)</a>
<a name="ln865">        {</a>
<a name="ln866">            if (!next_block)</a>
<a name="ln867">                return (char*)buf - (char*)data;</a>
<a name="ln868"> </a>
<a name="ln869">            block_header bl;</a>
<a name="ln870">            pkg-&gt;seek(next_block);</a>
<a name="ln871">            ssize_t res = ::read(pkg-&gt;fd, &amp;bl, sizeof(block_header));</a>
<a name="ln872">            if (res &lt; 0)</a>
<a name="ln873">                sysfail(&quot;error reading the save file&quot;);</a>
<a name="ln874">            if (res != sizeof(block_header))</a>
<a name="ln875">                corrupted(&quot;save file corrupted -- block past eof&quot;);</a>
<a name="ln876"> </a>
<a name="ln877">            off = next_block + sizeof(block_header);</a>
<a name="ln878">            block_left = htole(bl.len);</a>
<a name="ln879">            next_block = htole(bl.next);</a>
<a name="ln880">            // This reeks of on-disk corruption (zeroed data).</a>
<a name="ln881">            if (!block_left)</a>
<a name="ln882">                corrupted(&quot;save file corrupted -- empty block&quot;);</a>
<a name="ln883">        }</a>
<a name="ln884">        else</a>
<a name="ln885">            pkg-&gt;seek(off);</a>
<a name="ln886"> </a>
<a name="ln887">        plen_t s = len;</a>
<a name="ln888">        if (s &gt; block_left)</a>
<a name="ln889">            s = block_left;</a>
<a name="ln890">        ssize_t res = ::read(pkg-&gt;fd, buf, s);</a>
<a name="ln891">        if (res &lt; 0)</a>
<a name="ln892">            sysfail(&quot;error reading the save file&quot;);</a>
<a name="ln893">        if ((plen_t)res != s)</a>
<a name="ln894">            corrupted(&quot;save file corrupted -- block past eof&quot;);</a>
<a name="ln895"> </a>
<a name="ln896">        buf = (char*)buf + s;</a>
<a name="ln897">        off += s;</a>
<a name="ln898">        len -= s;</a>
<a name="ln899">        block_left -= s;</a>
<a name="ln900">    }</a>
<a name="ln901"> </a>
<a name="ln902">    return (char*)buf - (char*)data;</a>
<a name="ln903">}</a>
<a name="ln904"> </a>
<a name="ln905">plen_t chunk_reader::read(void *data, plen_t len)</a>
<a name="ln906">{</a>
<a name="ln907">    ASSERT(data);</a>
<a name="ln908">    if (pkg-&gt;aborted)</a>
<a name="ln909">        return 0;</a>
<a name="ln910"> </a>
<a name="ln911">#ifdef USE_ZLIB</a>
<a name="ln912">    if (!len)</a>
<a name="ln913">        return 0;</a>
<a name="ln914">    if (eof)</a>
<a name="ln915">        return 0;</a>
<a name="ln916"> </a>
<a name="ln917">    zs.next_out  = (Bytef*)data;</a>
<a name="ln918">    zs.avail_out = len;</a>
<a name="ln919">    while (zs.avail_out)</a>
<a name="ln920">    {</a>
<a name="ln921">        if (!zs.avail_in)</a>
<a name="ln922">        {</a>
<a name="ln923">            zs.next_in  = z_buffer;</a>
<a name="ln924">            zs.avail_in = raw_read(z_buffer, sizeof(z_buffer));</a>
<a name="ln925">            if (!zs.avail_in)</a>
<a name="ln926">                corrupted(&quot;save file corrupted -- block truncated&quot;);</a>
<a name="ln927">        }</a>
<a name="ln928">        int res = inflate(&amp;zs, Z_NO_FLUSH);</a>
<a name="ln929">        if (res == Z_STREAM_END)</a>
<a name="ln930">        {</a>
<a name="ln931">            eof = true;</a>
<a name="ln932">            return zs.next_out - (Bytef*)data;</a>
<a name="ln933">        }</a>
<a name="ln934">        if (res != Z_OK)</a>
<a name="ln935">            corrupted(&quot;save file decompression failed: %s&quot;, zs.msg);</a>
<a name="ln936">    }</a>
<a name="ln937">    return zs.next_out - (Bytef*)data;</a>
<a name="ln938">#else</a>
<a name="ln939">    return raw_read(data, len);</a>
<a name="ln940">#endif</a>
<a name="ln941">}</a>
<a name="ln942"> </a>
<a name="ln943">void chunk_reader::read_all(vector&lt;char&gt; &amp;data)</a>
<a name="ln944">{</a>
<a name="ln945">#define SPACE 1024</a>
<a name="ln946">    plen_t s, at;</a>
<a name="ln947">    do</a>
<a name="ln948">    {</a>
<a name="ln949">        at = data.size();</a>
<a name="ln950">        data.resize(at + SPACE);</a>
<a name="ln951">        s = read(&amp;data[at], SPACE);</a>
<a name="ln952">    } while (s == SPACE);</a>
<a name="ln953">    data.resize(at + s);</a>
<a name="ln954">#undef SPACE</a>
<a name="ln955">}</a>

</code></pre>
<div class="balloon" rel="626"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v779/" target="_blank">V779</a> Unreachable code detected. It is possible that an error is present.</p></div>
<div class="balloon" rel="826"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v730/" target="_blank">V730</a> It is possible that not all members of a class are initialized inside the constructor. Consider inspecting: off, z_buffer.</p></div>
<div class="balloon" rel="834"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v730/" target="_blank">V730</a> It is possible that not all members of a class are initialized inside the constructor. Consider inspecting: off, z_buffer.</p></div>

<link rel="stylesheet" href="highlight.css">
<script src="highlight.pack.js"></script>
<script src="highlightjs-line-numbers.js"></script>
<script>hljs.initHighlightingOnLoad();</script>
<script>hljs.initLineNumbersOnLoad();</script>
<script>
  $(document).ready(function() {
      $('.balloon').each(function () {
          var bl = $(this);
          var line = bl.attr('rel');
          var text = $('a[name="ln'+line+'"]').text();

          var space_count = 0;
          for(var i = 0; i<text.length; i++){
              var char = text[i];
              if((char !== ' ')&&(char !== '\t'))break;
              if(char === '\t')space_count++;
              space_count++;
          }

          bl.css('margin-left', space_count*8);
          $('a[name="ln'+line+'"]').after(bl);
      });

      window.location = window.location;
  });
</script>
</body>
</html>
