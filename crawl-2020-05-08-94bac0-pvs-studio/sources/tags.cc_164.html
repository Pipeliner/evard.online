
<html>
<head>

  <meta http-equiv="Content-Type" content="text/html; charset=US-ASCII" />
  <title>tags.cc</title>

  <link rel="stylesheet" href="../style.css"/>
  <script src="../jquery-3.2.1.min.js"></script>
</head>
<body>

<pre><code class = "cpp">
<a name="ln1">/**</a>
<a name="ln2"> * @file</a>
<a name="ln3"> * @brief Auxiliary functions to make savefile versioning simpler.</a>
<a name="ln4">**/</a>
<a name="ln5"> </a>
<a name="ln6">/*</a>
<a name="ln7">   The marshalling and unmarshalling of data is done in big endian and</a>
<a name="ln8">   is meant to keep savefiles cross-platform. Note also that the marshalling</a>
<a name="ln9">   sizes are 1, 2, and 4 for byte, short, and int. If a strange platform</a>
<a name="ln10">   with different sizes of these basic types pops up, please sed it to fixed-</a>
<a name="ln11">   width ones. For now, that wasn't done in order to keep things convenient.</a>
<a name="ln12">*/</a>
<a name="ln13"> </a>
<a name="ln14">#include &quot;AppHdr.h&quot;</a>
<a name="ln15"> </a>
<a name="ln16">#include &quot;tags.h&quot;</a>
<a name="ln17"> </a>
<a name="ln18">#include &lt;algorithm&gt;</a>
<a name="ln19">#include &lt;cstdio&gt;</a>
<a name="ln20">#include &lt;cstdlib&gt;</a>
<a name="ln21">#include &lt;cstring&gt;</a>
<a name="ln22">#include &lt;iterator&gt;</a>
<a name="ln23">#include &lt;vector&gt;</a>
<a name="ln24">#ifdef UNIX</a>
<a name="ln25">#include &lt;fcntl.h&gt;</a>
<a name="ln26">#include &lt;sys/stat.h&gt;</a>
<a name="ln27">#include &lt;sys/types.h&gt;</a>
<a name="ln28">#include &lt;unistd.h&gt;</a>
<a name="ln29">#endif</a>
<a name="ln30"> </a>
<a name="ln31">#include &quot;abyss.h&quot;</a>
<a name="ln32">#include &quot;act-iter.h&quot;</a>
<a name="ln33">#include &quot;artefact.h&quot;</a>
<a name="ln34">#include &quot;art-enum.h&quot;</a>
<a name="ln35">#include &quot;branch.h&quot;</a>
<a name="ln36">#if TAG_MAJOR_VERSION == 34</a>
<a name="ln37"> #include &quot;decks.h&quot;</a>
<a name="ln38"> #include &quot;food.h&quot;</a>
<a name="ln39"> #include &quot;hunger-state-t.h&quot;</a>
<a name="ln40">#endif</a>
<a name="ln41">#include &quot;colour.h&quot;</a>
<a name="ln42">#include &quot;coordit.h&quot;</a>
<a name="ln43">#include &quot;dbg-scan.h&quot;</a>
<a name="ln44">#include &quot;dbg-util.h&quot;</a>
<a name="ln45">#include &quot;describe.h&quot;</a>
<a name="ln46">#include &quot;dgn-overview.h&quot;</a>
<a name="ln47">#include &quot;dungeon.h&quot;</a>
<a name="ln48">#include &quot;end.h&quot;</a>
<a name="ln49">#include &quot;errors.h&quot;</a>
<a name="ln50">#include &quot;ghost.h&quot;</a>
<a name="ln51">#include &quot;god-abil.h&quot; // just for the Ru sac penalty key</a>
<a name="ln52">#include &quot;god-companions.h&quot;</a>
<a name="ln53">#include &quot;item-name.h&quot;</a>
<a name="ln54">#include &quot;item-prop.h&quot;</a>
<a name="ln55">#include &quot;item-status-flag-type.h&quot;</a>
<a name="ln56">#include &quot;item-type-id-state-type.h&quot;</a>
<a name="ln57">#include &quot;items.h&quot;</a>
<a name="ln58">#include &quot;jobs.h&quot;</a>
<a name="ln59">#include &quot;mapmark.h&quot;</a>
<a name="ln60">#include &quot;misc.h&quot;</a>
<a name="ln61">#include &quot;mon-death.h&quot;</a>
<a name="ln62">#if TAG_MAJOR_VERSION == 34</a>
<a name="ln63"> #include &quot;mon-place.h&quot;</a>
<a name="ln64"> #include &quot;mon-poly.h&quot;</a>
<a name="ln65"> #include &quot;mon-tentacle.h&quot;</a>
<a name="ln66"> #include &quot;mon-util.h&quot;</a>
<a name="ln67">#endif</a>
<a name="ln68">#include &quot;place.h&quot;</a>
<a name="ln69">#include &quot;player-stats.h&quot;</a>
<a name="ln70">#include &quot;prompt.h&quot; // index_to_letter</a>
<a name="ln71">#include &quot;religion.h&quot;</a>
<a name="ln72">#include &quot;skills.h&quot;</a>
<a name="ln73">#include &quot;species.h&quot;</a>
<a name="ln74">#include &quot;spl-wpnench.h&quot;</a>
<a name="ln75">#include &quot;state.h&quot;</a>
<a name="ln76">#include &quot;stringutil.h&quot;</a>
<a name="ln77">#include &quot;syscalls.h&quot;</a>
<a name="ln78">#include &quot;terrain.h&quot;</a>
<a name="ln79">#include &quot;rltiles/tiledef-dngn.h&quot;</a>
<a name="ln80">#include &quot;rltiles/tiledef-player.h&quot;</a>
<a name="ln81">#include &quot;tilepick.h&quot;</a>
<a name="ln82">#include &quot;tileview.h&quot;</a>
<a name="ln83">#ifdef USE_TILE</a>
<a name="ln84"> #include &quot;tilemcache.h&quot;</a>
<a name="ln85">#endif</a>
<a name="ln86">#include &quot;transform.h&quot;</a>
<a name="ln87">#include &quot;unwind.h&quot;</a>
<a name="ln88">#include &quot;version.h&quot;</a>
<a name="ln89"> </a>
<a name="ln90">vector&lt;ghost_demon&gt; global_ghosts; // only for reading/writing</a>
<a name="ln91"> </a>
<a name="ln92">// defined in dgn-overview.cc</a>
<a name="ln93">extern map&lt;branch_type, set&lt;level_id&gt; &gt; stair_level;</a>
<a name="ln94">extern map&lt;level_pos, shop_type&gt; shops_present;</a>
<a name="ln95">extern map&lt;level_pos, god_type&gt; altars_present;</a>
<a name="ln96">extern map&lt;level_pos, branch_type&gt; portals_present;</a>
<a name="ln97">extern map&lt;level_pos, string&gt; portal_notes;</a>
<a name="ln98">extern map&lt;level_id, string&gt; level_annotations;</a>
<a name="ln99">extern map&lt;level_id, string&gt; level_exclusions;</a>
<a name="ln100">extern map&lt;level_id, string&gt; level_uniques;</a>
<a name="ln101">extern set&lt;pair&lt;string, level_id&gt; &gt; auto_unique_annotations;</a>
<a name="ln102"> </a>
<a name="ln103">// defined in abyss.cc</a>
<a name="ln104">extern abyss_state abyssal_state;</a>
<a name="ln105"> </a>
<a name="ln106">reader::reader(const string &amp;_read_filename, int minorVersion)</a>
<a name="ln107">    : _filename(_read_filename), _chunk(0), _pbuf(nullptr), _read_offset(0),</a>
<a name="ln108">      _minorVersion(minorVersion), _safe_read(false)</a>
<a name="ln109">{</a>
<a name="ln110">    _file       = fopen_u(_filename.c_str(), &quot;rb&quot;);</a>
<a name="ln111">    opened_file = !!_file;</a>
<a name="ln112">}</a>
<a name="ln113"> </a>
<a name="ln114">reader::reader(package *save, const string &amp;chunkname, int minorVersion)</a>
<a name="ln115">    : _file(0), _chunk(0), opened_file(false), _pbuf(0), _read_offset(0),</a>
<a name="ln116">     _minorVersion(minorVersion), _safe_read(false)</a>
<a name="ln117">{</a>
<a name="ln118">    ASSERT(save);</a>
<a name="ln119">    _chunk = new chunk_reader(save, chunkname);</a>
<a name="ln120">}</a>
<a name="ln121"> </a>
<a name="ln122">reader::~reader()</a>
<a name="ln123">{</a>
<a name="ln124">    if (_chunk)</a>
<a name="ln125">        delete _chunk;</a>
<a name="ln126">    close();</a>
<a name="ln127">}</a>
<a name="ln128"> </a>
<a name="ln129">void reader::close()</a>
<a name="ln130">{</a>
<a name="ln131">    if (opened_file &amp;&amp; _file)</a>
<a name="ln132">        fclose(_file);</a>
<a name="ln133">    _file = nullptr;</a>
<a name="ln134">}</a>
<a name="ln135"> </a>
<a name="ln136">void reader::advance(size_t offset)</a>
<a name="ln137">{</a>
<a name="ln138">    char junk[128];</a>
<a name="ln139"> </a>
<a name="ln140">    while (offset)</a>
<a name="ln141">    {</a>
<a name="ln142">        const size_t junklen = min(sizeof(junk), offset);</a>
<a name="ln143">        offset -= junklen;</a>
<a name="ln144">        read(junk, junklen);</a>
<a name="ln145">    }</a>
<a name="ln146">}</a>
<a name="ln147"> </a>
<a name="ln148">bool reader::valid() const</a>
<a name="ln149">{</a>
<a name="ln150">    return (_file &amp;&amp; !feof(_file)) ||</a>
<a name="ln151">           (_pbuf &amp;&amp; _read_offset &lt; _pbuf-&gt;size());</a>
<a name="ln152">}</a>
<a name="ln153"> </a>
<a name="ln154">static NORETURN void _short_read(bool safe_read)</a>
<a name="ln155">{</a>
<a name="ln156">    if (!crawl_state.need_save || safe_read)</a>
<a name="ln157">        throw short_read_exception();</a>
<a name="ln158">    // Would be nice to name the save chunk here, but in interesting cases</a>
<a name="ln159">    // we're reading a copy from memory (why?).</a>
<a name="ln160">    die_noline(&quot;short read while reading save&quot;);</a>
<a name="ln161">}</a>
<a name="ln162"> </a>
<a name="ln163">// Reads input in network byte order, from a file or buffer.</a>
<a name="ln164">unsigned char reader::readByte()</a>
<a name="ln165">{</a>
<a name="ln166">    if (_file)</a>
<a name="ln167">    {</a>
<a name="ln168">        int b = fgetc(_file);</a>
<a name="ln169">        if (b == EOF)</a>
<a name="ln170">            _short_read(_safe_read);</a>
<a name="ln171">        return b;</a>
<a name="ln172">    }</a>
<a name="ln173">    else if (_chunk)</a>
<a name="ln174">    {</a>
<a name="ln175">        unsigned char buf;</a>
<a name="ln176">        if (_chunk-&gt;read(&amp;buf, 1) != 1)</a>
<a name="ln177">            _short_read(_safe_read);</a>
<a name="ln178">        return buf;</a>
<a name="ln179">    }</a>
<a name="ln180">    else</a>
<a name="ln181">    {</a>
<a name="ln182">        if (_read_offset &gt;= _pbuf-&gt;size())</a>
<a name="ln183">            _short_read(_safe_read);</a>
<a name="ln184">        return (*_pbuf)[_read_offset++];</a>
<a name="ln185">    }</a>
<a name="ln186">}</a>
<a name="ln187"> </a>
<a name="ln188">void reader::read(void *data, size_t size)</a>
<a name="ln189">{</a>
<a name="ln190">    if (_file)</a>
<a name="ln191">    {</a>
<a name="ln192">        if (data)</a>
<a name="ln193">        {</a>
<a name="ln194">            if (fread(data, 1, size, _file) != size)</a>
<a name="ln195">                _short_read(_safe_read);</a>
<a name="ln196">        }</a>
<a name="ln197">        else</a>
<a name="ln198">            fseek(_file, (long)size, SEEK_CUR);</a>
<a name="ln199">    }</a>
<a name="ln200">    else if (_chunk)</a>
<a name="ln201">    {</a>
<a name="ln202">        if (_chunk-&gt;read(data, size) != size)</a>
<a name="ln203">            _short_read(_safe_read);</a>
<a name="ln204">    }</a>
<a name="ln205">    else</a>
<a name="ln206">    {</a>
<a name="ln207">        if (_read_offset+size &gt; _pbuf-&gt;size())</a>
<a name="ln208">            _short_read(_safe_read);</a>
<a name="ln209">        if (data &amp;&amp; size)</a>
<a name="ln210">            memcpy(data, &amp;(*_pbuf)[_read_offset], size);</a>
<a name="ln211"> </a>
<a name="ln212">        _read_offset += size;</a>
<a name="ln213">    }</a>
<a name="ln214">}</a>
<a name="ln215"> </a>
<a name="ln216">int reader::getMinorVersion() const</a>
<a name="ln217">{</a>
<a name="ln218">    ASSERT(_minorVersion != TAG_MINOR_INVALID);</a>
<a name="ln219">    return _minorVersion;</a>
<a name="ln220">}</a>
<a name="ln221"> </a>
<a name="ln222">void reader::setMinorVersion(int minorVersion)</a>
<a name="ln223">{</a>
<a name="ln224">    _minorVersion = minorVersion;</a>
<a name="ln225">}</a>
<a name="ln226"> </a>
<a name="ln227">void reader::fail_if_not_eof(const string &amp;name)</a>
<a name="ln228">{</a>
<a name="ln229">    char dummy;</a>
<a name="ln230">    if (_chunk ? _chunk-&gt;read(&amp;dummy, 1) :</a>
<a name="ln231">        _file ? (fgetc(_file) != EOF) :</a>
<a name="ln232">        _read_offset &gt;= _pbuf-&gt;size())</a>
<a name="ln233">    {</a>
<a name="ln234">        fail(&quot;Incomplete read of \&quot;%s\&quot; - aborting.&quot;, name.c_str());</a>
<a name="ln235">    }</a>
<a name="ln236">}</a>
<a name="ln237"> </a>
<a name="ln238">void writer::check_ok(bool ok)</a>
<a name="ln239">{</a>
<a name="ln240">    if (!ok &amp;&amp; !failed)</a>
<a name="ln241">    {</a>
<a name="ln242">        failed = true;</a>
<a name="ln243">        if (!_ignore_errors)</a>
<a name="ln244">            end(1, true, &quot;Error writing to %s&quot;, _filename.c_str());</a>
<a name="ln245">    }</a>
<a name="ln246">}</a>
<a name="ln247"> </a>
<a name="ln248">void writer::writeByte(unsigned char ch)</a>
<a name="ln249">{</a>
<a name="ln250">    if (failed)</a>
<a name="ln251">        return;</a>
<a name="ln252"> </a>
<a name="ln253">    if (_chunk)</a>
<a name="ln254">        _chunk-&gt;write(&amp;ch, 1);</a>
<a name="ln255">    else if (_file)</a>
<a name="ln256">        check_ok(fputc(ch, _file) != EOF);</a>
<a name="ln257">    else</a>
<a name="ln258">        _pbuf-&gt;push_back(ch);</a>
<a name="ln259">}</a>
<a name="ln260"> </a>
<a name="ln261">void writer::write(const void *data, size_t size)</a>
<a name="ln262">{</a>
<a name="ln263">    if (failed)</a>
<a name="ln264">        return;</a>
<a name="ln265"> </a>
<a name="ln266">    if (_chunk)</a>
<a name="ln267">        _chunk-&gt;write(data, size);</a>
<a name="ln268">    else if (_file)</a>
<a name="ln269">        check_ok(fwrite(data, 1, size, _file) == size);</a>
<a name="ln270">    else</a>
<a name="ln271">    {</a>
<a name="ln272">        const unsigned char* cdata = static_cast&lt;const unsigned char*&gt;(data);</a>
<a name="ln273">        _pbuf-&gt;insert(_pbuf-&gt;end(), cdata, cdata+size);</a>
<a name="ln274">    }</a>
<a name="ln275">}</a>
<a name="ln276"> </a>
<a name="ln277">long writer::tell()</a>
<a name="ln278">{</a>
<a name="ln279">    ASSERT(!_chunk);</a>
<a name="ln280">    return _file? ftell(_file) : _pbuf-&gt;size();</a>
<a name="ln281">}</a>
<a name="ln282"> </a>
<a name="ln283">#ifdef DEBUG_GLOBALS</a>
<a name="ln284">// Force a conditional jump valgrind may pick up, no matter the optimizations.</a>
<a name="ln285">static volatile uint32_t hashroll;</a>
<a name="ln286">static void CHECK_INITIALIZED(uint32_t x)</a>
<a name="ln287">{</a>
<a name="ln288">    hashroll = 0;</a>
<a name="ln289">    if ((hashroll += x) &amp; 1)</a>
<a name="ln290">        hashroll += 2;</a>
<a name="ln291">}</a>
<a name="ln292">#else</a>
<a name="ln293">#define CHECK_INITIALIZED(x)</a>
<a name="ln294">#endif</a>
<a name="ln295"> </a>
<a name="ln296">// static helper declarations</a>
<a name="ln297">static void _tag_construct_char(writer &amp;th);</a>
<a name="ln298">static void _tag_construct_you(writer &amp;th);</a>
<a name="ln299">static void _tag_construct_you_items(writer &amp;th);</a>
<a name="ln300">static void _tag_construct_you_dungeon(writer &amp;th);</a>
<a name="ln301">static void _tag_construct_lost_monsters(writer &amp;th);</a>
<a name="ln302">static void _tag_construct_companions(writer &amp;th);</a>
<a name="ln303">static void _tag_read_you(reader &amp;th);</a>
<a name="ln304">static void _tag_read_you_items(reader &amp;th);</a>
<a name="ln305">static void _tag_read_you_dungeon(reader &amp;th);</a>
<a name="ln306">static void _tag_read_lost_monsters(reader &amp;th);</a>
<a name="ln307">#if TAG_MAJOR_VERSION == 34</a>
<a name="ln308">static void _tag_read_lost_items(reader &amp;th);</a>
<a name="ln309">#endif</a>
<a name="ln310">static void _tag_read_companions(reader &amp;th);</a>
<a name="ln311"> </a>
<a name="ln312">static void _tag_construct_level(writer &amp;th);</a>
<a name="ln313">static void _tag_construct_level_items(writer &amp;th);</a>
<a name="ln314">static void _tag_construct_level_monsters(writer &amp;th);</a>
<a name="ln315">static void _tag_construct_level_tiles(writer &amp;th);</a>
<a name="ln316">static void _tag_read_level(reader &amp;th);</a>
<a name="ln317">static void _tag_read_level_items(reader &amp;th);</a>
<a name="ln318">static void _tag_read_level_monsters(reader &amp;th);</a>
<a name="ln319">static void _tag_read_level_tiles(reader &amp;th);</a>
<a name="ln320">static void _regenerate_tile_flavour();</a>
<a name="ln321">static void _draw_tiles();</a>
<a name="ln322"> </a>
<a name="ln323">static void _tag_construct_ghost(writer &amp;th, vector&lt;ghost_demon&gt; &amp;);</a>
<a name="ln324">static vector&lt;ghost_demon&gt; _tag_read_ghost(reader &amp;th);</a>
<a name="ln325"> </a>
<a name="ln326">static void _marshallGhost(writer &amp;th, const ghost_demon &amp;ghost);</a>
<a name="ln327">static ghost_demon _unmarshallGhost(reader &amp;th);</a>
<a name="ln328"> </a>
<a name="ln329">static void _marshallSpells(writer &amp;, const monster_spells &amp;);</a>
<a name="ln330"> </a>
<a name="ln331">static void _marshallMonsterInfo (writer &amp;, const monster_info &amp;);</a>
<a name="ln332">static void _unmarshallMonsterInfo (reader &amp;, monster_info &amp;mi);</a>
<a name="ln333"> </a>
<a name="ln334">template&lt;typename T, typename T_iter, typename T_marshal&gt;</a>
<a name="ln335">static void _marshall_iterator(writer &amp;th, T_iter beg, T_iter end,</a>
<a name="ln336">                               T_marshal marshal);</a>
<a name="ln337">template&lt;typename T, typename U&gt;</a>
<a name="ln338">static void _unmarshall_vector(reader&amp; th, vector&lt;T&gt;&amp; vec, U T_unmarshall);</a>
<a name="ln339"> </a>
<a name="ln340">template&lt;int SIZE&gt;</a>
<a name="ln341">static void _marshallFixedBitVector(writer&amp; th, const FixedBitVector&lt;SIZE&gt;&amp; arr);</a>
<a name="ln342">template&lt;int SIZE&gt;</a>
<a name="ln343">static void _unmarshallFixedBitVector(reader&amp; th, FixedBitVector&lt;SIZE&gt;&amp; arr);</a>
<a name="ln344"> </a>
<a name="ln345">void marshallByte(writer &amp;th, int8_t data)</a>
<a name="ln346">{</a>
<a name="ln347">    CHECK_INITIALIZED(data);</a>
<a name="ln348">    th.writeByte(data);</a>
<a name="ln349">}</a>
<a name="ln350"> </a>
<a name="ln351">int8_t unmarshallByte(reader &amp;th)</a>
<a name="ln352">{</a>
<a name="ln353">    return th.readByte();</a>
<a name="ln354">}</a>
<a name="ln355"> </a>
<a name="ln356">void marshallUByte(writer &amp;th, uint8_t data)</a>
<a name="ln357">{</a>
<a name="ln358">    CHECK_INITIALIZED(data);</a>
<a name="ln359">    th.writeByte(data);</a>
<a name="ln360">}</a>
<a name="ln361"> </a>
<a name="ln362">uint8_t unmarshallUByte(reader &amp;th)</a>
<a name="ln363">{</a>
<a name="ln364">    return th.readByte();</a>
<a name="ln365">}</a>
<a name="ln366"> </a>
<a name="ln367">// Marshall 2 byte short in network order.</a>
<a name="ln368">void marshallShort(writer &amp;th, short data)</a>
<a name="ln369">{</a>
<a name="ln370">    // TODO: why does this use `short` and `char` when unmarshall uses int16_t??</a>
<a name="ln371">    CHECK_INITIALIZED(data);</a>
<a name="ln372">    const char b2 = (char)(data &amp; 0x00FF);</a>
<a name="ln373">    const char b1 = (char)((data &amp; 0xFF00) &gt;&gt; 8);</a>
<a name="ln374">    th.writeByte(b1);</a>
<a name="ln375">    th.writeByte(b2);</a>
<a name="ln376">}</a>
<a name="ln377"> </a>
<a name="ln378">// Unmarshall 2 byte short in network order.</a>
<a name="ln379">int16_t unmarshallShort(reader &amp;th)</a>
<a name="ln380">{</a>
<a name="ln381">    int16_t b1 = th.readByte();</a>
<a name="ln382">    int16_t b2 = th.readByte();</a>
<a name="ln383">    int16_t data = (b1 &lt;&lt; 8) | (b2 &amp; 0x00FF);</a>
<a name="ln384">    return data;</a>
<a name="ln385">}</a>
<a name="ln386"> </a>
<a name="ln387">// Marshall 4 byte int in network order.</a>
<a name="ln388">void marshallInt(writer &amp;th, int32_t data)</a>
<a name="ln389">{</a>
<a name="ln390">    CHECK_INITIALIZED(data);</a>
<a name="ln391">    char b4 = (char) (data &amp; 0x000000FF);</a>
<a name="ln392">    char b3 = (char)((data &amp; 0x0000FF00) &gt;&gt; 8);</a>
<a name="ln393">    char b2 = (char)((data &amp; 0x00FF0000) &gt;&gt; 16);</a>
<a name="ln394">    char b1 = (char)((data &amp; 0xFF000000) &gt;&gt; 24);</a>
<a name="ln395"> </a>
<a name="ln396">    th.writeByte(b1);</a>
<a name="ln397">    th.writeByte(b2);</a>
<a name="ln398">    th.writeByte(b3);</a>
<a name="ln399">    th.writeByte(b4);</a>
<a name="ln400">}</a>
<a name="ln401"> </a>
<a name="ln402">// Unmarshall 4 byte signed int in network order.</a>
<a name="ln403">int32_t unmarshallInt(reader &amp;th)</a>
<a name="ln404">{</a>
<a name="ln405">    int32_t b1 = th.readByte();</a>
<a name="ln406">    int32_t b2 = th.readByte();</a>
<a name="ln407">    int32_t b3 = th.readByte();</a>
<a name="ln408">    int32_t b4 = th.readByte();</a>
<a name="ln409"> </a>
<a name="ln410">    int32_t data = (b1 &lt;&lt; 24) | ((b2 &amp; 0x000000FF) &lt;&lt; 16);</a>
<a name="ln411">    data |= ((b3 &amp; 0x000000FF) &lt;&lt; 8) | (b4 &amp; 0x000000FF);</a>
<a name="ln412">    return data;</a>
<a name="ln413">}</a>
<a name="ln414"> </a>
<a name="ln415">void marshallUnsigned(writer&amp; th, uint64_t v)</a>
<a name="ln416">{</a>
<a name="ln417">    do</a>
<a name="ln418">    {</a>
<a name="ln419">        unsigned char b = (unsigned char)(v &amp; 0x7f);</a>
<a name="ln420">        v &gt;&gt;= 7;</a>
<a name="ln421">        if (v)</a>
<a name="ln422">            b |= 0x80;</a>
<a name="ln423">        th.writeByte(b);</a>
<a name="ln424">    }</a>
<a name="ln425">    while (v);</a>
<a name="ln426">}</a>
<a name="ln427"> </a>
<a name="ln428">uint64_t unmarshallUnsigned(reader&amp; th)</a>
<a name="ln429">{</a>
<a name="ln430">    unsigned i = 0;</a>
<a name="ln431">    uint64_t v = 0;</a>
<a name="ln432">    for (;;)</a>
<a name="ln433">    {</a>
<a name="ln434">        unsigned char b = th.readByte();</a>
<a name="ln435">        v |= (uint64_t)(b &amp; 0x7f) &lt;&lt; i;</a>
<a name="ln436">        i += 7;</a>
<a name="ln437">        if (!(b &amp; 0x80))</a>
<a name="ln438">            break;</a>
<a name="ln439">    }</a>
<a name="ln440">    return v;</a>
<a name="ln441">}</a>
<a name="ln442"> </a>
<a name="ln443">void marshallSigned(writer&amp; th, int64_t v)</a>
<a name="ln444">{</a>
<a name="ln445">    if (v &lt; 0)</a>
<a name="ln446">        marshallUnsigned(th, (uint64_t)((-v - 1) &lt;&lt; 1) | 1);</a>
<a name="ln447">    else</a>
<a name="ln448">        marshallUnsigned(th, (uint64_t)(v &lt;&lt; 1));</a>
<a name="ln449">}</a>
<a name="ln450"> </a>
<a name="ln451">int64_t unmarshallSigned(reader&amp; th)</a>
<a name="ln452">{</a>
<a name="ln453">    uint64_t u;</a>
<a name="ln454">    unmarshallUnsigned(th, u);</a>
<a name="ln455">    if (u &amp; 1)</a>
<a name="ln456">        return (int64_t)(-(u &gt;&gt; 1) - 1);</a>
<a name="ln457">    else</a>
<a name="ln458">        return (int64_t)(u &gt;&gt; 1);</a>
<a name="ln459">}</a>
<a name="ln460"> </a>
<a name="ln461">// Optimized for short vectors that have only the first few bits set, and</a>
<a name="ln462">// can have invalid length. For long ones you might want to do this</a>
<a name="ln463">// differently to not lose 1/8 bits and speed.</a>
<a name="ln464">template&lt;int SIZE&gt;</a>
<a name="ln465">void _marshallFixedBitVector(writer&amp; th, const FixedBitVector&lt;SIZE&gt;&amp; arr)</a>
<a name="ln466">{</a>
<a name="ln467">    int last_bit;</a>
<a name="ln468">    for (last_bit = SIZE - 1; last_bit &gt; 0; last_bit--)</a>
<a name="ln469">        if (arr[last_bit])</a>
<a name="ln470">            break;</a>
<a name="ln471"> </a>
<a name="ln472">    int i = 0;</a>
<a name="ln473">    while (1)</a>
<a name="ln474">    {</a>
<a name="ln475">        uint8_t byte = 0;</a>
<a name="ln476">        for (int j = 0; j &lt; 7; j++)</a>
<a name="ln477">            if (i &lt; SIZE &amp;&amp; arr[i++])</a>
<a name="ln478">                byte |= 1 &lt;&lt; j;</a>
<a name="ln479">        if (i &lt;= last_bit)</a>
<a name="ln480">            marshallUByte(th, byte);</a>
<a name="ln481">        else</a>
<a name="ln482">        {</a>
<a name="ln483">            marshallUByte(th, byte | 0x80);</a>
<a name="ln484">            break;</a>
<a name="ln485">        }</a>
<a name="ln486">    }</a>
<a name="ln487">}</a>
<a name="ln488"> </a>
<a name="ln489">template&lt;int SIZE&gt;</a>
<a name="ln490">void _unmarshallFixedBitVector(reader&amp; th, FixedBitVector&lt;SIZE&gt;&amp; arr)</a>
<a name="ln491">{</a>
<a name="ln492">    arr.reset();</a>
<a name="ln493"> </a>
<a name="ln494">    int i = 0;</a>
<a name="ln495">    while (1)</a>
<a name="ln496">    {</a>
<a name="ln497">        uint8_t byte = unmarshallUByte(th);</a>
<a name="ln498">        for (int j = 0; j &lt; 7; j++)</a>
<a name="ln499">            if (i &lt; SIZE)</a>
<a name="ln500">                arr.set(i++, !!(byte &amp; (1 &lt;&lt; j)));</a>
<a name="ln501">        if (byte &amp; 0x80)</a>
<a name="ln502">            break;</a>
<a name="ln503">    }</a>
<a name="ln504">}</a>
<a name="ln505"> </a>
<a name="ln506">// FIXME: Kill this abomination - it will break!</a>
<a name="ln507">template&lt;typename T&gt;</a>
<a name="ln508">static void _marshall_as_int(writer&amp; th, const T&amp; t)</a>
<a name="ln509">{</a>
<a name="ln510">    marshallInt(th, static_cast&lt;int&gt;(t));</a>
<a name="ln511">}</a>
<a name="ln512"> </a>
<a name="ln513">template &lt;typename data&gt;</a>
<a name="ln514">void marshallSet(writer &amp;th, const set&lt;data&gt; &amp;s,</a>
<a name="ln515">                 void (*marshall)(writer &amp;, const data &amp;))</a>
<a name="ln516">{</a>
<a name="ln517">    marshallInt(th, s.size());</a>
<a name="ln518">    for (const data &amp;elt : s)</a>
<a name="ln519">        marshall(th, elt);</a>
<a name="ln520">}</a>
<a name="ln521"> </a>
<a name="ln522">template&lt;typename key, typename value&gt;</a>
<a name="ln523">void marshallMap(writer &amp;th, const map&lt;key,value&gt;&amp; data,</a>
<a name="ln524">                 void (*key_marshall)(writer&amp;, const key&amp;),</a>
<a name="ln525">                 void (*value_marshall)(writer&amp;, const value&amp;))</a>
<a name="ln526">{</a>
<a name="ln527">    marshallInt(th, data.size());</a>
<a name="ln528">    for (const auto &amp;entry : data)</a>
<a name="ln529">    {</a>
<a name="ln530">        key_marshall(th, entry.first);</a>
<a name="ln531">        value_marshall(th, entry.second);</a>
<a name="ln532">    }</a>
<a name="ln533">}</a>
<a name="ln534"> </a>
<a name="ln535">template&lt;typename T_iter, typename T_marshall_t&gt;</a>
<a name="ln536">static void _marshall_iterator(writer &amp;th, T_iter beg, T_iter end,</a>
<a name="ln537">                               T_marshall_t T_marshall)</a>
<a name="ln538">{</a>
<a name="ln539">    marshallInt(th, distance(beg, end));</a>
<a name="ln540">    while (beg != end)</a>
<a name="ln541">    {</a>
<a name="ln542">        T_marshall(th, *beg);</a>
<a name="ln543">        ++beg;</a>
<a name="ln544">    }</a>
<a name="ln545">}</a>
<a name="ln546"> </a>
<a name="ln547">template&lt;typename T, typename U&gt;</a>
<a name="ln548">static void _unmarshall_vector(reader&amp; th, vector&lt;T&gt;&amp; vec, U T_unmarshall)</a>
<a name="ln549">{</a>
<a name="ln550">    vec.clear();</a>
<a name="ln551">    const int num_to_read = unmarshallInt(th);</a>
<a name="ln552">    for (int i = 0; i &lt; num_to_read; ++i)</a>
<a name="ln553">        vec.push_back(T_unmarshall(th));</a>
<a name="ln554">}</a>
<a name="ln555"> </a>
<a name="ln556">template &lt;typename T_container, typename T_inserter, typename T_unmarshall&gt;</a>
<a name="ln557">static void unmarshall_container(reader &amp;th, T_container &amp;container,</a>
<a name="ln558">                                 T_inserter inserter, T_unmarshall unmarshal)</a>
<a name="ln559">{</a>
<a name="ln560">    container.clear();</a>
<a name="ln561">    const int num_to_read = unmarshallInt(th);</a>
<a name="ln562">    for (int i = 0; i &lt; num_to_read; ++i)</a>
<a name="ln563">        (container.*inserter)(unmarshal(th));</a>
<a name="ln564">}</a>
<a name="ln565"> </a>
<a name="ln566">static unsigned short _pack(const level_id&amp; id)</a>
<a name="ln567">{</a>
<a name="ln568">    return (static_cast&lt;int&gt;(id.branch) &lt;&lt; 8) | (id.depth &amp; 0xFF);</a>
<a name="ln569">}</a>
<a name="ln570"> </a>
<a name="ln571">void marshall_level_id(writer&amp; th, const level_id&amp; id)</a>
<a name="ln572">{</a>
<a name="ln573">    marshallShort(th, _pack(id));</a>
<a name="ln574">}</a>
<a name="ln575"> </a>
<a name="ln576">static void _marshall_level_id_set(writer&amp; th, const set&lt;level_id&gt;&amp; id)</a>
<a name="ln577">{</a>
<a name="ln578">    marshallSet(th, id, marshall_level_id);</a>
<a name="ln579">}</a>
<a name="ln580"> </a>
<a name="ln581">// XXX: Redundant with level_pos.save()/load().</a>
<a name="ln582">static void _marshall_level_pos(writer&amp; th, const level_pos&amp; lpos)</a>
<a name="ln583">{</a>
<a name="ln584">    marshallInt(th, lpos.pos.x);</a>
<a name="ln585">    marshallInt(th, lpos.pos.y);</a>
<a name="ln586">    marshall_level_id(th, lpos.id);</a>
<a name="ln587">}</a>
<a name="ln588"> </a>
<a name="ln589">template &lt;typename data, typename set&gt;</a>
<a name="ln590">void unmarshallSet(reader &amp;th, set &amp;dset,</a>
<a name="ln591">                   data (*data_unmarshall)(reader &amp;))</a>
<a name="ln592">{</a>
<a name="ln593">    dset.clear();</a>
<a name="ln594">    int len = unmarshallInt(th);</a>
<a name="ln595">    for (int i = 0; i &lt; len; ++i)</a>
<a name="ln596">        dset.insert(data_unmarshall(th));</a>
<a name="ln597">}</a>
<a name="ln598"> </a>
<a name="ln599">template&lt;typename key, typename value, typename map&gt;</a>
<a name="ln600">void unmarshallMap(reader&amp; th, map&amp; data,</a>
<a name="ln601">                   key   (*key_unmarshall)  (reader&amp;),</a>
<a name="ln602">                   value (*value_unmarshall)(reader&amp;))</a>
<a name="ln603">{</a>
<a name="ln604">    const int len = unmarshallInt(th);</a>
<a name="ln605">    key k;</a>
<a name="ln606">    for (int i = 0; i &lt; len; ++i)</a>
<a name="ln607">    {</a>
<a name="ln608">        k = key_unmarshall(th);</a>
<a name="ln609">        pair&lt;key, value&gt; p(k, value_unmarshall(th));</a>
<a name="ln610">        data.insert(p);</a>
<a name="ln611">    }</a>
<a name="ln612">}</a>
<a name="ln613"> </a>
<a name="ln614">template&lt;typename T&gt;</a>
<a name="ln615">static T unmarshall_int_as(reader&amp; th)</a>
<a name="ln616">{</a>
<a name="ln617">    return static_cast&lt;T&gt;(unmarshallInt(th));</a>
<a name="ln618">}</a>
<a name="ln619"> </a>
<a name="ln620">#if TAG_MAJOR_VERSION == 34</a>
<a name="ln621">level_id level_id::from_packed_place(unsigned short place)</a>
<a name="ln622">#else</a>
<a name="ln623">level_id _unpack(unsigned short place)</a>
<a name="ln624">#endif</a>
<a name="ln625">{</a>
<a name="ln626">    level_id id;</a>
<a name="ln627"> </a>
<a name="ln628">    id.branch     = static_cast&lt;branch_type&gt;((place &gt;&gt; 8) &amp; 0xFF);</a>
<a name="ln629">    id.depth      = (int8_t)(place &amp; 0xFF);</a>
<a name="ln630"> </a>
<a name="ln631">    return id;</a>
<a name="ln632">}</a>
<a name="ln633"> </a>
<a name="ln634">level_id unmarshall_level_id(reader&amp; th)</a>
<a name="ln635">{</a>
<a name="ln636">#if TAG_MAJOR_VERSION == 34</a>
<a name="ln637">    return level_id::from_packed_place(unmarshallShort(th));</a>
<a name="ln638">#else</a>
<a name="ln639">    return _unpack(unmarshallShort(th));</a>
<a name="ln640">#endif</a>
<a name="ln641">}</a>
<a name="ln642"> </a>
<a name="ln643">static set&lt;level_id&gt; _unmarshall_level_id_set(reader&amp; th)</a>
<a name="ln644">{</a>
<a name="ln645">    set&lt;level_id&gt; id;</a>
<a name="ln646">    unmarshallSet(th, id, unmarshall_level_id);</a>
<a name="ln647">    return id;</a>
<a name="ln648">}</a>
<a name="ln649"> </a>
<a name="ln650">static level_pos _unmarshall_level_pos(reader&amp; th)</a>
<a name="ln651">{</a>
<a name="ln652">    level_pos lpos;</a>
<a name="ln653">    lpos.pos.x = unmarshallInt(th);</a>
<a name="ln654">    lpos.pos.y = unmarshallInt(th);</a>
<a name="ln655">    lpos.id    = unmarshall_level_id(th);</a>
<a name="ln656">    return lpos;</a>
<a name="ln657">}</a>
<a name="ln658"> </a>
<a name="ln659">void marshallCoord(writer &amp;th, const coord_def &amp;c)</a>
<a name="ln660">{</a>
<a name="ln661">    marshallInt(th, c.x);</a>
<a name="ln662">    marshallInt(th, c.y);</a>
<a name="ln663">}</a>
<a name="ln664"> </a>
<a name="ln665">coord_def unmarshallCoord(reader &amp;th)</a>
<a name="ln666">{</a>
<a name="ln667">    coord_def c;</a>
<a name="ln668">#if TAG_MAJOR_VERSION == 34</a>
<a name="ln669">    if (th.getMinorVersion() &gt;= TAG_MINOR_COORD_SERIALIZER</a>
<a name="ln670">        &amp;&amp; th.getMinorVersion() != TAG_MINOR_0_11)</a>
<a name="ln671">    {</a>
<a name="ln672">#endif</a>
<a name="ln673">        c.x = unmarshallInt(th);</a>
<a name="ln674">        c.y = unmarshallInt(th);</a>
<a name="ln675">#if TAG_MAJOR_VERSION == 34</a>
<a name="ln676">    }</a>
<a name="ln677">    else</a>
<a name="ln678">    {</a>
<a name="ln679">        c.x = unmarshallShort(th);</a>
<a name="ln680">        c.y = unmarshallShort(th);</a>
<a name="ln681">    }</a>
<a name="ln682">#endif</a>
<a name="ln683">    return c;</a>
<a name="ln684">}</a>
<a name="ln685"> </a>
<a name="ln686">#if TAG_MAJOR_VERSION == 34</a>
<a name="ln687">// Between TAG_MINOR_OPTIONAL_PARTS and TAG_MINOR_FIXED_CONSTRICTION</a>
<a name="ln688">// we neglected to marshall the constricting[] map of monsters. Fix</a>
<a name="ln689">// those up.</a>
<a name="ln690">static void _fix_missing_constrictions()</a>
<a name="ln691">{</a>
<a name="ln692">    for (int i = -1; i &lt; MAX_MONSTERS; ++i)</a>
<a name="ln693">    {</a>
<a name="ln694">        const actor* m = i &lt; 0 ? (actor*)&amp;you : (actor*)&amp;menv[i];</a>
<a name="ln695">        if (!m-&gt;alive())</a>
<a name="ln696">            continue;</a>
<a name="ln697">        if (!m-&gt;constricted_by)</a>
<a name="ln698">            continue;</a>
<a name="ln699">        actor *h = actor_by_mid(m-&gt;constricted_by);</a>
<a name="ln700">        // Not a known bug, so don't fix this up.</a>
<a name="ln701">        if (!h)</a>
<a name="ln702">            continue;</a>
<a name="ln703"> </a>
<a name="ln704">        if (!h-&gt;constricting)</a>
<a name="ln705">            h-&gt;constricting = new actor::constricting_t;</a>
<a name="ln706">        if (h-&gt;constricting-&gt;find(m-&gt;mid) == h-&gt;constricting-&gt;end())</a>
<a name="ln707">        {</a>
<a name="ln708">            dprf(&quot;Fixing missing constriction for %s (mindex=%d mid=%d)&quot;</a>
<a name="ln709">                 &quot; of %s (mindex=%d mid=%d)&quot;,</a>
<a name="ln710">                 h-&gt;name(DESC_PLAIN, true).c_str(), h-&gt;mindex(), h-&gt;mid,</a>
<a name="ln711">                 m-&gt;name(DESC_PLAIN, true).c_str(), m-&gt;mindex(), m-&gt;mid);</a>
<a name="ln712"> </a>
<a name="ln713">            (*h-&gt;constricting)[m-&gt;mid] = 0;</a>
<a name="ln714">        }</a>
<a name="ln715">    }</a>
<a name="ln716">}</a>
<a name="ln717">#endif</a>
<a name="ln718"> </a>
<a name="ln719">static void _marshall_constriction(writer &amp;th, const actor *who)</a>
<a name="ln720">{</a>
<a name="ln721">    marshallInt(th, who-&gt;constricted_by);</a>
<a name="ln722">    marshallInt(th, who-&gt;escape_attempts);</a>
<a name="ln723"> </a>
<a name="ln724">    // Assumes an empty map is marshalled as just the int 0.</a>
<a name="ln725">    const actor::constricting_t * const cmap = who-&gt;constricting;</a>
<a name="ln726">    if (cmap)</a>
<a name="ln727">        marshallMap(th, *cmap, _marshall_as_int&lt;mid_t&gt;, _marshall_as_int&lt;int&gt;);</a>
<a name="ln728">    else</a>
<a name="ln729">        marshallInt(th, 0);</a>
<a name="ln730">}</a>
<a name="ln731"> </a>
<a name="ln732">static void _unmarshall_constriction(reader &amp;th, actor *who)</a>
<a name="ln733">{</a>
<a name="ln734">#if TAG_MAJOR_VERSION == 34</a>
<a name="ln735">    if (th.getMinorVersion() &lt; TAG_MINOR_NO_ACTOR_HELD)</a>
<a name="ln736">        unmarshallInt(th);</a>
<a name="ln737">#endif</a>
<a name="ln738">    who-&gt;constricted_by = unmarshallInt(th);</a>
<a name="ln739">    who-&gt;escape_attempts = unmarshallInt(th);</a>
<a name="ln740"> </a>
<a name="ln741">    actor::constricting_t cmap;</a>
<a name="ln742">    unmarshallMap(th, cmap, unmarshall_int_as&lt;mid_t&gt;, unmarshallInt);</a>
<a name="ln743"> </a>
<a name="ln744">    if (cmap.size() == 0)</a>
<a name="ln745">        who-&gt;constricting = 0;</a>
<a name="ln746">    else</a>
<a name="ln747">        who-&gt;constricting = new actor::constricting_t(cmap);</a>
<a name="ln748">}</a>
<a name="ln749"> </a>
<a name="ln750">template &lt;typename marshall, typename grid&gt;</a>
<a name="ln751">static void _run_length_encode(writer &amp;th, marshall m, const grid &amp;g,</a>
<a name="ln752">                               int width, int height)</a>
<a name="ln753">{</a>
<a name="ln754">    int last = 0, nlast = 0;</a>
<a name="ln755">    for (int y = 0; y &lt; height; ++y)</a>
<a name="ln756">        for (int x = 0; x &lt; width; ++x)</a>
<a name="ln757">        {</a>
<a name="ln758">            if (!nlast)</a>
<a name="ln759">                last = g[x][y];</a>
<a name="ln760">            if (last == g[x][y] &amp;&amp; nlast &lt; 255)</a>
<a name="ln761">            {</a>
<a name="ln762">                nlast++;</a>
<a name="ln763">                continue;</a>
<a name="ln764">            }</a>
<a name="ln765"> </a>
<a name="ln766">            marshallByte(th, nlast);</a>
<a name="ln767">            m(th, last);</a>
<a name="ln768"> </a>
<a name="ln769">            last = g[x][y];</a>
<a name="ln770">            nlast = 1;</a>
<a name="ln771">        }</a>
<a name="ln772"> </a>
<a name="ln773">    marshallByte(th, nlast);</a>
<a name="ln774">    m(th, last);</a>
<a name="ln775">}</a>
<a name="ln776"> </a>
<a name="ln777">template &lt;typename unmarshall, typename grid&gt;</a>
<a name="ln778">static void _run_length_decode(reader &amp;th, unmarshall um, grid &amp;g,</a>
<a name="ln779">                               int width, int height)</a>
<a name="ln780">{</a>
<a name="ln781">    const int end = width * height;</a>
<a name="ln782">    int offset = 0;</a>
<a name="ln783">    while (offset &lt; end)</a>
<a name="ln784">    {</a>
<a name="ln785">        const int run = unmarshallUByte(th);</a>
<a name="ln786">        const int value = um(th);</a>
<a name="ln787"> </a>
<a name="ln788">        for (int i = 0; i &lt; run; ++i)</a>
<a name="ln789">        {</a>
<a name="ln790">            const int y = offset / width;</a>
<a name="ln791">            const int x = offset % width;</a>
<a name="ln792">            g[x][y] = value;</a>
<a name="ln793">            ++offset;</a>
<a name="ln794">        }</a>
<a name="ln795">    }</a>
<a name="ln796">}</a>
<a name="ln797"> </a>
<a name="ln798">union float_marshall_kludge</a>
<a name="ln799">{</a>
<a name="ln800">    float    f_num;</a>
<a name="ln801">    int32_t  l_num;</a>
<a name="ln802">};</a>
<a name="ln803">COMPILE_CHECK(sizeof(float) == sizeof(int32_t));</a>
<a name="ln804"> </a>
<a name="ln805">// single precision float -- marshall in network order.</a>
<a name="ln806">void marshallFloat(writer &amp;th, float data)</a>
<a name="ln807">{</a>
<a name="ln808">    float_marshall_kludge k;</a>
<a name="ln809">    k.f_num = data;</a>
<a name="ln810">    marshallInt(th, k.l_num);</a>
<a name="ln811">}</a>
<a name="ln812"> </a>
<a name="ln813">// single precision float -- unmarshall in network order.</a>
<a name="ln814">float unmarshallFloat(reader &amp;th)</a>
<a name="ln815">{</a>
<a name="ln816">    float_marshall_kludge k;</a>
<a name="ln817">    k.l_num = unmarshallInt(th);</a>
<a name="ln818">    return k.f_num;</a>
<a name="ln819">}</a>
<a name="ln820"> </a>
<a name="ln821">// string -- 2 byte length, string data</a>
<a name="ln822">void marshallString(writer &amp;th, const string &amp;data)</a>
<a name="ln823">{</a>
<a name="ln824">    size_t len = data.length();</a>
<a name="ln825">    // A limit of 32K. TODO: why doesn't this use int16_t?</a>
<a name="ln826">    if (len &gt; SHRT_MAX)</a>
<a name="ln827">        die(&quot;trying to marshall too long a string (len=%ld)&quot;, (long int)len);</a>
<a name="ln828">    marshallShort(th, len);</a>
<a name="ln829"> </a>
<a name="ln830">    th.write(data.c_str(), len);</a>
<a name="ln831">}</a>
<a name="ln832"> </a>
<a name="ln833">string unmarshallString(reader &amp;th)</a>
<a name="ln834">{</a>
<a name="ln835">    char buffer[SHRT_MAX]; // TODO: why doesn't this use int16_t?</a>
<a name="ln836"> </a>
<a name="ln837">    short len = unmarshallShort(th);</a>
<a name="ln838">    ASSERT(len &gt;= 0);</a>
<a name="ln839">    ASSERT(len &lt;= (ssize_t)sizeof(buffer));</a>
<a name="ln840"> </a>
<a name="ln841">    th.read(buffer, len);</a>
<a name="ln842"> </a>
<a name="ln843">    return string(buffer, len);</a>
<a name="ln844">}</a>
<a name="ln845"> </a>
<a name="ln846">// This one must stay with a 16 bit signed big-endian length tag, to allow</a>
<a name="ln847">// older versions to browse and list newer saves.</a>
<a name="ln848">static void marshallString2(writer &amp;th, const string &amp;data)</a>
<a name="ln849">{</a>
<a name="ln850">    marshallString(th, data);</a>
<a name="ln851">}</a>
<a name="ln852"> </a>
<a name="ln853">static string unmarshallString2(reader &amp;th)</a>
<a name="ln854">{</a>
<a name="ln855">    return unmarshallString(th);</a>
<a name="ln856">}</a>
<a name="ln857"> </a>
<a name="ln858">// string -- 4 byte length, non-terminated string data.</a>
<a name="ln859">void marshallString4(writer &amp;th, const string &amp;data)</a>
<a name="ln860">{</a>
<a name="ln861">    const size_t len = data.length();</a>
<a name="ln862">    if (len &gt; static_cast&lt;size_t&gt;(numeric_limits&lt;int32_t&gt;::max()))</a>
<a name="ln863">        die(&quot;trying to marshall too long a string (len=%ld)&quot;, (long int) len);</a>
<a name="ln864">    marshallInt(th, len);</a>
<a name="ln865">    th.write(data.c_str(), len);</a>
<a name="ln866">}</a>
<a name="ln867"> </a>
<a name="ln868">void unmarshallString4(reader &amp;th, string&amp; s)</a>
<a name="ln869">{</a>
<a name="ln870">    const int len = unmarshallInt(th);</a>
<a name="ln871">    ASSERT(len &gt;= 0);</a>
<a name="ln872">    s.resize(len);</a>
<a name="ln873">    if (len)</a>
<a name="ln874">        th.read(&amp;s.at(0), len);</a>
<a name="ln875">}</a>
<a name="ln876"> </a>
<a name="ln877">// boolean (to avoid system-dependent bool implementations)</a>
<a name="ln878">void marshallBoolean(writer &amp;th, bool data)</a>
<a name="ln879">{</a>
<a name="ln880">    th.writeByte(data ? 1 : 0);</a>
<a name="ln881">}</a>
<a name="ln882"> </a>
<a name="ln883">// boolean (to avoid system-dependent bool implementations)</a>
<a name="ln884">bool unmarshallBoolean(reader &amp;th)</a>
<a name="ln885">{</a>
<a name="ln886">    return th.readByte() != 0;</a>
<a name="ln887">}</a>
<a name="ln888"> </a>
<a name="ln889">// Saving the date as a string so we're not reliant on a particular epoch.</a>
<a name="ln890">string make_date_string(time_t in_date)</a>
<a name="ln891">{</a>
<a name="ln892">    if (in_date &lt;= 0)</a>
<a name="ln893">        return &quot;&quot;;</a>
<a name="ln894"> </a>
<a name="ln895">    struct tm *date = TIME_FN(&amp;in_date);</a>
<a name="ln896"> </a>
<a name="ln897">    return make_stringf(</a>
<a name="ln898">              &quot;%4d%02d%02d%02d%02d%02d%s&quot;,</a>
<a name="ln899">              date-&gt;tm_year + 1900, date-&gt;tm_mon, date-&gt;tm_mday,</a>
<a name="ln900">              date-&gt;tm_hour, date-&gt;tm_min, date-&gt;tm_sec,</a>
<a name="ln901">              ((date-&gt;tm_isdst &gt; 0) ? &quot;D&quot; : &quot;S&quot;));</a>
<a name="ln902">}</a>
<a name="ln903"> </a>
<a name="ln904">static void marshallStringVector(writer &amp;th, const vector&lt;string&gt; &amp;vec)</a>
<a name="ln905">{</a>
<a name="ln906">    _marshall_iterator(th, vec.begin(), vec.end(), marshallString);</a>
<a name="ln907">}</a>
<a name="ln908"> </a>
<a name="ln909">static vector&lt;string&gt; unmarshallStringVector(reader &amp;th)</a>
<a name="ln910">{</a>
<a name="ln911">    vector&lt;string&gt; vec;</a>
<a name="ln912">    _unmarshall_vector(th, vec, unmarshallString);</a>
<a name="ln913">    return vec;</a>
<a name="ln914">}</a>
<a name="ln915"> </a>
<a name="ln916">static monster_type unmarshallMonType(reader &amp;th)</a>
<a name="ln917">{</a>
<a name="ln918">    monster_type x = static_cast&lt;monster_type&gt;(unmarshallShort(th));</a>
<a name="ln919"> </a>
<a name="ln920">    if (x &gt;= MONS_NO_MONSTER)</a>
<a name="ln921">        return x;</a>
<a name="ln922"> </a>
<a name="ln923">#if TAG_MAJOR_VERSION == 34</a>
<a name="ln924"># define AXED(a) if (x &gt; a) --x</a>
<a name="ln925">    if (th.getMinorVersion() == TAG_MINOR_0_11)</a>
<a name="ln926">    {</a>
<a name="ln927">        AXED(MONS_KILLER_BEE); // killer bee larva</a>
<a name="ln928">        AXED(MONS_SHADOW_IMP); // midge</a>
<a name="ln929">        AXED(MONS_AGNES);      // Jozef</a>
<a name="ln930">    }</a>
<a name="ln931">#endif</a>
<a name="ln932"> </a>
<a name="ln933">    return x;</a>
<a name="ln934">}</a>
<a name="ln935"> </a>
<a name="ln936">#if TAG_MAJOR_VERSION == 34</a>
<a name="ln937">// yay marshalling inconsistencies</a>
<a name="ln938">static monster_type unmarshallMonType_Info(reader &amp;th)</a>
<a name="ln939">{</a>
<a name="ln940">    monster_type x = static_cast&lt;monster_type&gt;(unmarshallUnsigned(th));</a>
<a name="ln941"> </a>
<a name="ln942">    if (x &gt;= MONS_NO_MONSTER)</a>
<a name="ln943">        return x;</a>
<a name="ln944"> </a>
<a name="ln945">    if (th.getMinorVersion() == TAG_MINOR_0_11)</a>
<a name="ln946">    {</a>
<a name="ln947">        AXED(MONS_KILLER_BEE); // killer bee larva</a>
<a name="ln948">        AXED(MONS_SHADOW_IMP); // midge</a>
<a name="ln949">        AXED(MONS_AGNES);      // Jozef</a>
<a name="ln950">    }</a>
<a name="ln951"> </a>
<a name="ln952">    return x;</a>
<a name="ln953">}</a>
<a name="ln954">#endif</a>
<a name="ln955"> </a>
<a name="ln956">static spell_type unmarshallSpellType(reader &amp;th</a>
<a name="ln957">#if TAG_MAJOR_VERSION == 34</a>
<a name="ln958">                                      , bool mons = false</a>
<a name="ln959">#endif</a>
<a name="ln960">                                      )</a>
<a name="ln961">{</a>
<a name="ln962">    spell_type x = SPELL_NO_SPELL;</a>
<a name="ln963">#if TAG_MAJOR_VERSION == 34</a>
<a name="ln964">    if (!mons &amp;&amp; th.getMinorVersion() &lt; TAG_MINOR_SHORT_SPELL_TYPE)</a>
<a name="ln965">        x = static_cast&lt;spell_type&gt;(unmarshallUByte(th));</a>
<a name="ln966">    else</a>
<a name="ln967">#endif</a>
<a name="ln968">        x = static_cast&lt;spell_type&gt;(unmarshallShort(th));</a>
<a name="ln969"> </a>
<a name="ln970">#if TAG_MAJOR_VERSION == 34</a>
<a name="ln971">    if (th.getMinorVersion() == TAG_MINOR_0_11)</a>
<a name="ln972">    {</a>
<a name="ln973">        AXED(SPELL_DEBUGGING_RAY); // projected noise</a>
<a name="ln974">        AXED(SPELL_HEAL_OTHER);    // summon greater holy</a>
<a name="ln975">    }</a>
<a name="ln976">#endif</a>
<a name="ln977"> </a>
<a name="ln978">    return x;</a>
<a name="ln979">}</a>
<a name="ln980"> </a>
<a name="ln981">static dungeon_feature_type rewrite_feature(dungeon_feature_type x,</a>
<a name="ln982">                                            int minor_version)</a>
<a name="ln983">{</a>
<a name="ln984">#if TAG_MAJOR_VERSION == 34</a>
<a name="ln985">    if (minor_version == TAG_MINOR_0_11)</a>
<a name="ln986">    {</a>
<a name="ln987">        // turn old trees into...trees</a>
<a name="ln988">        if (x == DNGN_OPEN_SEA)</a>
<a name="ln989">            x = DNGN_TREE;</a>
<a name="ln990">        else if (x &gt;= DNGN_LAVA_SEA &amp;&amp; x &lt; 30)</a>
<a name="ln991">            x = (dungeon_feature_type)(x - 1);</a>
<a name="ln992">    }</a>
<a name="ln993">    // turn mangroves into trees</a>
<a name="ln994">    else if (minor_version &lt; TAG_MINOR_MANGROVES &amp;&amp; x == DNGN_OPEN_SEA)</a>
<a name="ln995">        x = DNGN_TREE;</a>
<a name="ln996">    else if (minor_version &lt; TAG_MINOR_FIX_FEAT_SHIFT</a>
<a name="ln997">             &amp;&amp; x &gt; DNGN_OPEN_SEA &amp;&amp; x &lt; DNGN_LAVA)</a>
<a name="ln998">    {</a>
<a name="ln999">        x = static_cast&lt;dungeon_feature_type&gt;(x - 1);</a>
<a name="ln1000">    }</a>
<a name="ln1001"> </a>
<a name="ln1002">    if (x &gt;= DNGN_DRY_FOUNTAIN_BLUE &amp;&amp; x &lt;= DNGN_DRY_FOUNTAIN_BLOOD)</a>
<a name="ln1003">        x = DNGN_DRY_FOUNTAIN;</a>
<a name="ln1004"> </a>
<a name="ln1005">    if (x == DNGN_SEALED_DOOR &amp;&amp; minor_version &lt; TAG_MINOR_0_12)</a>
<a name="ln1006">        x = DNGN_CLOSED_DOOR;</a>
<a name="ln1007">    if (x == DNGN_BADLY_SEALED_DOOR)</a>
<a name="ln1008">        x = DNGN_SEALED_DOOR;</a>
<a name="ln1009">    if (x == DNGN_ESCAPE_HATCH_UP &amp;&amp; player_in_branch(BRANCH_LABYRINTH))</a>
<a name="ln1010">        x = DNGN_EXIT_LABYRINTH;</a>
<a name="ln1011">    if (x == DNGN_DEEP_WATER &amp;&amp; player_in_branch(BRANCH_SHOALS)</a>
<a name="ln1012">        &amp;&amp; minor_version &lt; TAG_MINOR_SHOALS_LITE)</a>
<a name="ln1013">    {</a>
<a name="ln1014">        x = DNGN_SHALLOW_WATER;</a>
<a name="ln1015">    }</a>
<a name="ln1016"> </a>
<a name="ln1017">    // ensure that killing TRJ opens the slime:$ vaults</a>
<a name="ln1018">    if (you.where_are_you == BRANCH_SLIME &amp;&amp; you.depth == brdepth[BRANCH_SLIME]</a>
<a name="ln1019">        &amp;&amp; minor_version &lt; TAG_MINOR_SLIME_WALL_CLEAR</a>
<a name="ln1020">        &amp;&amp; x == DNGN_STONE_WALL)</a>
<a name="ln1021">    {</a>
<a name="ln1022">        x = DNGN_CLEAR_STONE_WALL;</a>
<a name="ln1023">    }</a>
<a name="ln1024"> </a>
<a name="ln1025">    if (x == DNGN_ENTER_LABYRINTH)</a>
<a name="ln1026">        x = DNGN_ENTER_GAUNTLET;</a>
<a name="ln1027">#endif</a>
<a name="ln1028"> </a>
<a name="ln1029">    return x;</a>
<a name="ln1030">}</a>
<a name="ln1031"> </a>
<a name="ln1032">dungeon_feature_type unmarshallFeatureType(reader &amp;th)</a>
<a name="ln1033">{</a>
<a name="ln1034">    dungeon_feature_type x = static_cast&lt;dungeon_feature_type&gt;(unmarshallUByte(th));</a>
<a name="ln1035">    return rewrite_feature(x, th.getMinorVersion());</a>
<a name="ln1036">}</a>
<a name="ln1037"> </a>
<a name="ln1038">#if TAG_MAJOR_VERSION == 34</a>
<a name="ln1039">// yay marshalling inconsistencies</a>
<a name="ln1040">static dungeon_feature_type unmarshallFeatureType_Info(reader &amp;th)</a>
<a name="ln1041">{</a>
<a name="ln1042">    dungeon_feature_type x = static_cast&lt;dungeon_feature_type&gt;(unmarshallUnsigned(th));</a>
<a name="ln1043">    x = rewrite_feature(x, th.getMinorVersion());</a>
<a name="ln1044"> </a>
<a name="ln1045">    // There was a period of time when this function (only this one, not</a>
<a name="ln1046">    // unmarshallFeatureType) lacked some of the conversions now done by</a>
<a name="ln1047">    // rewrite_feature. In case any saves were transferred through those</a>
<a name="ln1048">    // versions, replace bad features with DNGN_UNSEEN. Questionable, but</a>
<a name="ln1049">    // this is just map_knowledge so the impact should be low.</a>
<a name="ln1050">    return is_valid_feature_type(x) ? x : DNGN_UNSEEN;</a>
<a name="ln1051">}</a>
<a name="ln1052">#endif</a>
<a name="ln1053"> </a>
<a name="ln1054">#define CANARY     marshallUByte(th, 171)</a>
<a name="ln1055">#if TAG_MAJOR_VERSION == 34</a>
<a name="ln1056">#define EAT_CANARY do if (th.getMinorVersion() &gt;= TAG_MINOR_CANARIES    \</a>
<a name="ln1057">                          &amp;&amp; unmarshallUByte(th) != 171)                \</a>
<a name="ln1058">                   {                                                    \</a>
<a name="ln1059">                       die(&quot;save corrupted: canary gone&quot;);              \</a>
<a name="ln1060">                   } while (0)</a>
<a name="ln1061">#else</a>
<a name="ln1062">#define EAT_CANARY do if ( unmarshallUByte(th) != 171)                  \</a>
<a name="ln1063">                   {                                                    \</a>
<a name="ln1064">                       die(&quot;save corrupted: canary gone&quot;);              \</a>
<a name="ln1065">                   } while (0)</a>
<a name="ln1066">#endif</a>
<a name="ln1067"> </a>
<a name="ln1068">#if TAG_MAJOR_VERSION == 34</a>
<a name="ln1069">static void _ensure_entry(branch_type br)</a>
<a name="ln1070">{</a>
<a name="ln1071">    dungeon_feature_type entry = branches[br].entry_stairs;</a>
<a name="ln1072">    for (rectangle_iterator ri(1); ri; ++ri)</a>
<a name="ln1073">        if (orig_terrain(*ri) == entry)</a>
<a name="ln1074">            return;</a>
<a name="ln1075"> </a>
<a name="ln1076">    // Find primary upstairs.</a>
<a name="ln1077">    for (rectangle_iterator ri(1); ri; ++ri)</a>
<a name="ln1078">        if (orig_terrain(*ri) == DNGN_STONE_STAIRS_UP_I)</a>
<a name="ln1079">        {</a>
<a name="ln1080">            for (distance_iterator di(*ri); di; ++di)</a>
<a name="ln1081">                if (in_bounds(*di) &amp;&amp; grd(*di) == DNGN_FLOOR)</a>
<a name="ln1082">                {</a>
<a name="ln1083">                    grd(*di) = entry; // No need to update LOS, etc.</a>
<a name="ln1084">                    // Announce the repair even in non-debug builds.</a>
<a name="ln1085">                    mprf(MSGCH_ERROR, &quot;Placing missing branch entry: %s.&quot;,</a>
<a name="ln1086">                         dungeon_feature_name(entry));</a>
<a name="ln1087">                    return;</a>
<a name="ln1088">                }</a>
<a name="ln1089">            die(&quot;no floor to place a branch entrance&quot;);</a>
<a name="ln1090">        }</a>
<a name="ln1091">    die(&quot;no upstairs on %s???&quot;, level_id::current().describe().c_str());</a>
<a name="ln1092">}</a>
<a name="ln1093"> </a>
<a name="ln1094">static void _add_missing_branches()</a>
<a name="ln1095">{</a>
<a name="ln1096">    const level_id lc = level_id::current();</a>
<a name="ln1097"> </a>
<a name="ln1098">    // Could do all just in case, but this seems safer:</a>
<a name="ln1099">    if (brentry[BRANCH_VAULTS] == lc)</a>
<a name="ln1100">        _ensure_entry(BRANCH_VAULTS);</a>
<a name="ln1101">    if (brentry[BRANCH_ZOT] == lc)</a>
<a name="ln1102">        _ensure_entry(BRANCH_ZOT);</a>
<a name="ln1103">    if (lc == level_id(BRANCH_DEPTHS, 2) || lc == level_id(BRANCH_DUNGEON, 21))</a>
<a name="ln1104">        _ensure_entry(BRANCH_VESTIBULE);</a>
<a name="ln1105">    if (lc == level_id(BRANCH_DEPTHS, 3) || lc == level_id(BRANCH_DUNGEON, 24))</a>
<a name="ln1106">        _ensure_entry(BRANCH_PANDEMONIUM);</a>
<a name="ln1107">    if (lc == level_id(BRANCH_DEPTHS, 4) || lc == level_id(BRANCH_DUNGEON, 25))</a>
<a name="ln1108">        _ensure_entry(BRANCH_ABYSS);</a>
<a name="ln1109">    if (player_in_branch(BRANCH_VESTIBULE))</a>
<a name="ln1110">    {</a>
<a name="ln1111">        for (rectangle_iterator ri(0); ri; ++ri)</a>
<a name="ln1112">        {</a>
<a name="ln1113">            if (grd(*ri) == DNGN_STONE_ARCH)</a>
<a name="ln1114">            {</a>
<a name="ln1115">                map_marker *marker = env.markers.find(*ri, MAT_FEATURE);</a>
<a name="ln1116">                if (marker)</a>
<a name="ln1117">                {</a>
<a name="ln1118">                    map_feature_marker *featm =</a>
<a name="ln1119">                        dynamic_cast&lt;map_feature_marker*&gt;(marker);</a>
<a name="ln1120">                    // [ds] Ensure we're activating the correct feature</a>
<a name="ln1121">                    // markers. Feature markers are also used for other things,</a>
<a name="ln1122">                    // notably to indicate the return point from a portal</a>
<a name="ln1123">                    // vault.</a>
<a name="ln1124">                    switch (featm-&gt;feat)</a>
<a name="ln1125">                    {</a>
<a name="ln1126">                    case DNGN_ENTER_COCYTUS:</a>
<a name="ln1127">                    case DNGN_ENTER_DIS:</a>
<a name="ln1128">                    case DNGN_ENTER_GEHENNA:</a>
<a name="ln1129">                    case DNGN_ENTER_TARTARUS:</a>
<a name="ln1130">                        grd(*ri) = featm-&gt;feat;</a>
<a name="ln1131">                        dprf(&quot;opened %s&quot;, dungeon_feature_name(featm-&gt;feat));</a>
<a name="ln1132">                        env.markers.remove(marker);</a>
<a name="ln1133">                        break;</a>
<a name="ln1134">                    default:</a>
<a name="ln1135">                        break;</a>
<a name="ln1136">                    }</a>
<a name="ln1137">                }</a>
<a name="ln1138">            }</a>
<a name="ln1139">        }</a>
<a name="ln1140">    }</a>
<a name="ln1141">}</a>
<a name="ln1142">#endif</a>
<a name="ln1143"> </a>
<a name="ln1144"> </a>
<a name="ln1145">// Write a tagged chunk of data to the FILE*.</a>
<a name="ln1146">// tagId specifies what to write.</a>
<a name="ln1147">void tag_write(tag_type tagID, writer &amp;outf)</a>
<a name="ln1148">{</a>
<a name="ln1149">    vector&lt;unsigned char&gt; buf;</a>
<a name="ln1150">    writer th(&amp;buf);</a>
<a name="ln1151">    switch (tagID)</a>
<a name="ln1152">    {</a>
<a name="ln1153">    case TAG_CHR:</a>
<a name="ln1154">        _tag_construct_char(th);</a>
<a name="ln1155">        break;</a>
<a name="ln1156">    case TAG_YOU:</a>
<a name="ln1157">        _tag_construct_you(th);</a>
<a name="ln1158">        CANARY;</a>
<a name="ln1159">        _tag_construct_you_items(th);</a>
<a name="ln1160">        CANARY;</a>
<a name="ln1161">        _tag_construct_you_dungeon(th);</a>
<a name="ln1162">        CANARY;</a>
<a name="ln1163">        _tag_construct_lost_monsters(th);</a>
<a name="ln1164">        CANARY;</a>
<a name="ln1165">        _tag_construct_companions(th);</a>
<a name="ln1166">        break;</a>
<a name="ln1167">    case TAG_LEVEL:</a>
<a name="ln1168">        _tag_construct_level(th);</a>
<a name="ln1169">        CANARY;</a>
<a name="ln1170">        _tag_construct_level_items(th);</a>
<a name="ln1171">        CANARY;</a>
<a name="ln1172">        _tag_construct_level_monsters(th);</a>
<a name="ln1173">        CANARY;</a>
<a name="ln1174">        _tag_construct_level_tiles(th);</a>
<a name="ln1175">        break;</a>
<a name="ln1176">    case TAG_GHOST:</a>
<a name="ln1177">        _tag_construct_ghost(th, global_ghosts);</a>
<a name="ln1178">        break;</a>
<a name="ln1179">    default:</a>
<a name="ln1180">        // I don't know how to make that!</a>
<a name="ln1181">        break;</a>
<a name="ln1182">    }</a>
<a name="ln1183"> </a>
<a name="ln1184">    // make sure there is some data to write!</a>
<a name="ln1185">    if (buf.empty())</a>
<a name="ln1186">        return;</a>
<a name="ln1187"> </a>
<a name="ln1188">    // Write tag header.</a>
<a name="ln1189">    marshallInt(outf, buf.size());</a>
<a name="ln1190"> </a>
<a name="ln1191">    // Write tag data.</a>
<a name="ln1192">    outf.write(&amp;buf[0], buf.size());</a>
<a name="ln1193">}</a>
<a name="ln1194"> </a>
<a name="ln1195">static void _shunt_monsters_out_of_walls()</a>
<a name="ln1196">{</a>
<a name="ln1197">    for (int i = 0; i &lt; MAX_MONSTERS; ++i)</a>
<a name="ln1198">    {</a>
<a name="ln1199">        monster &amp;m(menv[i]);</a>
<a name="ln1200">        if (m.alive() &amp;&amp; in_bounds(m.pos()) &amp;&amp; cell_is_solid(m.pos())</a>
<a name="ln1201">            &amp;&amp; (grd(m.pos()) != DNGN_MALIGN_GATEWAY</a>
<a name="ln1202">                || mons_genus(m.type) != MONS_ELDRITCH_TENTACLE))</a>
<a name="ln1203">        {</a>
<a name="ln1204">            for (distance_iterator di(m.pos()); di; ++di)</a>
<a name="ln1205">                if (!actor_at(*di) &amp;&amp; !cell_is_solid(*di))</a>
<a name="ln1206">                {</a>
<a name="ln1207">#if TAG_MAJOR_VERSION == 34</a>
<a name="ln1208">                    // Could have been a rock worm or a dryad.</a>
<a name="ln1209">                    if (m.type != MONS_GHOST)</a>
<a name="ln1210">#endif</a>
<a name="ln1211">                    mprf(MSGCH_ERROR, &quot;Error: monster %s in %s at (%d,%d)&quot;,</a>
<a name="ln1212">                         m.name(DESC_PLAIN, true).c_str(),</a>
<a name="ln1213">                         dungeon_feature_name(grd(m.pos())),</a>
<a name="ln1214">                         m.pos().x, m.pos().y);</a>
<a name="ln1215">                    env.mgrid(m.pos()) = NON_MONSTER;</a>
<a name="ln1216">                    m.position = *di;</a>
<a name="ln1217">                    env.mgrid(*di) = i;</a>
<a name="ln1218">                    break;</a>
<a name="ln1219">                }</a>
<a name="ln1220">        }</a>
<a name="ln1221">    }</a>
<a name="ln1222">}</a>
<a name="ln1223"> </a>
<a name="ln1224">// Read a piece of data from inf into memory, then run the appropriate reader.</a>
<a name="ln1225">//</a>
<a name="ln1226">// minorVersion is available for any sub-readers that need it</a>
<a name="ln1227">void tag_read(reader &amp;inf, tag_type tag_id)</a>
<a name="ln1228">{</a>
<a name="ln1229">    // Read header info and data</a>
<a name="ln1230">    vector&lt;unsigned char&gt; buf;</a>
<a name="ln1231">    const int data_size = unmarshallInt(inf);</a>
<a name="ln1232">    ASSERT(data_size &gt;= 0);</a>
<a name="ln1233"> </a>
<a name="ln1234">    // Fetch data in one go</a>
<a name="ln1235">    buf.resize(data_size);</a>
<a name="ln1236">    inf.read(&amp;buf[0], buf.size());</a>
<a name="ln1237"> </a>
<a name="ln1238">    // Ok, we have data now.</a>
<a name="ln1239">    reader th(buf, inf.getMinorVersion());</a>
<a name="ln1240">    switch (tag_id)</a>
<a name="ln1241">    {</a>
<a name="ln1242">    case TAG_YOU:</a>
<a name="ln1243">        _tag_read_you(th);</a>
<a name="ln1244">        EAT_CANARY;</a>
<a name="ln1245">        _tag_read_you_items(th);</a>
<a name="ln1246">        EAT_CANARY;</a>
<a name="ln1247">        _tag_read_you_dungeon(th);</a>
<a name="ln1248">        EAT_CANARY;</a>
<a name="ln1249">        _tag_read_lost_monsters(th);</a>
<a name="ln1250">        EAT_CANARY;</a>
<a name="ln1251">#if TAG_MAJOR_VERSION == 34</a>
<a name="ln1252">        if (th.getMinorVersion() &lt; TAG_MINOR_NO_ITEM_TRANSIT)</a>
<a name="ln1253">        {</a>
<a name="ln1254">            _tag_read_lost_items(th);</a>
<a name="ln1255">            EAT_CANARY;</a>
<a name="ln1256">        }</a>
<a name="ln1257">        if (th.getMinorVersion() &gt;= TAG_MINOR_COMPANION_LIST)</a>
<a name="ln1258">#endif</a>
<a name="ln1259">        _tag_read_companions(th);</a>
<a name="ln1260"> </a>
<a name="ln1261">        // If somebody SIGHUP'ed out of the skill menu with every skill</a>
<a name="ln1262">        // disabled. Doing this here rather in _tag_read_you() because</a>
<a name="ln1263">        // you.can_currently_train() requires the player's equipment be loaded.</a>
<a name="ln1264">        init_can_currently_train();</a>
<a name="ln1265">        check_selected_skills();</a>
<a name="ln1266">        break;</a>
<a name="ln1267">    case TAG_LEVEL:</a>
<a name="ln1268">        _tag_read_level(th);</a>
<a name="ln1269">        EAT_CANARY;</a>
<a name="ln1270">        _tag_read_level_items(th);</a>
<a name="ln1271">        // We have to do this here because _tag_read_level_monsters()</a>
<a name="ln1272">        // might kill an elsewhere Ilsuiw follower, which ends up calling</a>
<a name="ln1273">        // terrain.cc:_dgn_check_terrain_items, which checks mitm.</a>
<a name="ln1274">        link_items();</a>
<a name="ln1275">        EAT_CANARY;</a>
<a name="ln1276">        _tag_read_level_monsters(th);</a>
<a name="ln1277">        EAT_CANARY;</a>
<a name="ln1278">#if TAG_MAJOR_VERSION == 34</a>
<a name="ln1279">        _add_missing_branches();</a>
<a name="ln1280">#endif</a>
<a name="ln1281">        _shunt_monsters_out_of_walls();</a>
<a name="ln1282">        // The Abyss needs to visit other levels during level gen, before</a>
<a name="ln1283">        // all cells have been filled. We mustn't crash when it returns</a>
<a name="ln1284">        // from those excursions, and generate_abyss will check_map_validity</a>
<a name="ln1285">        // itself after the grid is fully populated.</a>
<a name="ln1286">        if (!player_in_branch(BRANCH_ABYSS))</a>
<a name="ln1287">        {</a>
<a name="ln1288">            unwind_var&lt;coord_def&gt; you_pos(you.position, coord_def());</a>
<a name="ln1289">            check_map_validity();</a>
<a name="ln1290">        }</a>
<a name="ln1291">        _tag_read_level_tiles(th);</a>
<a name="ln1292">#if TAG_MAJOR_VERSION == 34</a>
<a name="ln1293">        if (you.where_are_you == BRANCH_GAUNTLET</a>
<a name="ln1294">            &amp;&amp; th.getMinorVersion() &lt; TAG_MINOR_GAUNTLET_TRAPPED)</a>
<a name="ln1295">        {</a>
<a name="ln1296">            vault_placement *place = dgn_vault_at(you.pos());</a>
<a name="ln1297">            if (place &amp;&amp; place-&gt;map.desc_or_name()</a>
<a name="ln1298">                         == &quot;gammafunk_gauntlet_branching&quot;)</a>
<a name="ln1299">            {</a>
<a name="ln1300">                auto exit = DNGN_EXIT_GAUNTLET;</a>
<a name="ln1301">                grd(you.pos()) = exit;</a>
<a name="ln1302">                // Announce the repair even in non-debug builds.</a>
<a name="ln1303">                mprf(MSGCH_ERROR, &quot;Placing emergency exit: %s.&quot;,</a>
<a name="ln1304">                     dungeon_feature_name(exit));</a>
<a name="ln1305">            }</a>
<a name="ln1306">        }</a>
<a name="ln1307"> </a>
<a name="ln1308">        // We can't do this when we unmarshall shops, since we haven't</a>
<a name="ln1309">        // unmarshalled items yet...</a>
<a name="ln1310">        if (th.getMinorVersion() &lt; TAG_MINOR_SHOP_HACK)</a>
<a name="ln1311">            for (auto&amp; entry : env.shop)</a>
<a name="ln1312">            {</a>
<a name="ln1313">                // Shop items were heaped up at this cell.</a>
<a name="ln1314">                for (stack_iterator si(coord_def(0, entry.second.num+5)); si; ++si)</a>
<a name="ln1315">                {</a>
<a name="ln1316">                    entry.second.stock.push_back(*si);</a>
<a name="ln1317">                    dec_mitm_item_quantity(si.index(), si-&gt;quantity);</a>
<a name="ln1318">                }</a>
<a name="ln1319">            }</a>
<a name="ln1320">#endif</a>
<a name="ln1321">        break;</a>
<a name="ln1322">    case TAG_GHOST:</a>
<a name="ln1323">        global_ghosts = _tag_read_ghost(th);</a>
<a name="ln1324">        break;</a>
<a name="ln1325">    default:</a>
<a name="ln1326">        // I don't know how to read that!</a>
<a name="ln1327">        die(&quot;unknown tag type&quot;);</a>
<a name="ln1328">    }</a>
<a name="ln1329">}</a>
<a name="ln1330"> </a>
<a name="ln1331">static void _tag_construct_char(writer &amp;th)</a>
<a name="ln1332">{</a>
<a name="ln1333">    marshallByte(th, TAG_CHR_FORMAT);</a>
<a name="ln1334">    // Important: you may never remove or alter a field without bumping</a>
<a name="ln1335">    // CHR_FORMAT. Bumping it makes all saves invisible when browsed in an</a>
<a name="ln1336">    // older version.</a>
<a name="ln1337">    // Please keep this compatible even over major version breaks!</a>
<a name="ln1338"> </a>
<a name="ln1339">    // Appending fields is fine, but inserting new fields anywhere other than</a>
<a name="ln1340">    // the end of this function is not!</a>
<a name="ln1341"> </a>
<a name="ln1342">    marshallString2(th, you.your_name);</a>
<a name="ln1343">    marshallString2(th, Version::Long);</a>
<a name="ln1344"> </a>
<a name="ln1345">    marshallByte(th, you.species);</a>
<a name="ln1346">    marshallByte(th, you.char_class);</a>
<a name="ln1347">    marshallByte(th, you.experience_level);</a>
<a name="ln1348">    marshallString2(th, string(get_job_name(you.char_class)));</a>
<a name="ln1349">    marshallByte(th, you.religion);</a>
<a name="ln1350">    marshallString2(th, you.jiyva_second_name);</a>
<a name="ln1351"> </a>
<a name="ln1352">    // don't save wizmode suppression</a>
<a name="ln1353">    marshallByte(th, you.wizard || you.suppress_wizard);</a>
<a name="ln1354"> </a>
<a name="ln1355">    marshallByte(th, crawl_state.type);</a>
<a name="ln1356">    if (crawl_state.game_is_tutorial())</a>
<a name="ln1357">        marshallString2(th, crawl_state.map);</a>
<a name="ln1358"> </a>
<a name="ln1359">    marshallString2(th, species_name(you.species));</a>
<a name="ln1360">    marshallString2(th, you.religion ? god_name(you.religion) : &quot;&quot;);</a>
<a name="ln1361"> </a>
<a name="ln1362">    // separate from the tutorial so we don't have to bump TAG_CHR_FORMAT</a>
<a name="ln1363">    marshallString2(th, crawl_state.map);</a>
<a name="ln1364"> </a>
<a name="ln1365">    marshallByte(th, you.explore);</a>
<a name="ln1366">}</a>
<a name="ln1367"> </a>
<a name="ln1368">/// is a custom scoring mechanism being stored?</a>
<a name="ln1369">static bool _calc_score_exists()</a>
<a name="ln1370">{</a>
<a name="ln1371">    lua_stack_cleaner clean(dlua);</a>
<a name="ln1372">    dlua.pushglobal(&quot;dgn.persist.calc_score&quot;);</a>
<a name="ln1373">    return !lua_isnil(dlua, -1);</a>
<a name="ln1374">}</a>
<a name="ln1375"> </a>
<a name="ln1376">static void _tag_construct_you(writer &amp;th)</a>
<a name="ln1377">{</a>
<a name="ln1378">    marshallInt(th, you.last_mid);</a>
<a name="ln1379">    marshallByte(th, you.piety);</a>
<a name="ln1380">    marshallShort(th, you.pet_target);</a>
<a name="ln1381"> </a>
<a name="ln1382">    marshallByte(th, you.max_level);</a>
<a name="ln1383">    marshallByte(th, you.where_are_you);</a>
<a name="ln1384">    marshallByte(th, you.depth);</a>
<a name="ln1385">    marshallByte(th, you.chapter);</a>
<a name="ln1386">    marshallByte(th, you.royal_jelly_dead);</a>
<a name="ln1387">    marshallByte(th, you.transform_uncancellable);</a>
<a name="ln1388">    marshallByte(th, you.berserk_penalty);</a>
<a name="ln1389">    marshallInt(th, you.abyss_speed);</a>
<a name="ln1390"> </a>
<a name="ln1391">    marshallInt(th, you.disease);</a>
<a name="ln1392">    ASSERT(you.hp &gt; 0 || you.pending_revival);</a>
<a name="ln1393">    marshallShort(th, you.pending_revival ? 0 : you.hp);</a>
<a name="ln1394"> </a>
<a name="ln1395">    marshallShort(th, you.hunger);</a>
<a name="ln1396">    marshallBoolean(th, you.fishtail);</a>
<a name="ln1397">    marshallBoolean(th, you.vampire_alive);</a>
<a name="ln1398">    _marshall_as_int(th, you.form);</a>
<a name="ln1399">    CANARY;</a>
<a name="ln1400"> </a>
<a name="ln1401">    // how many you.equip?</a>
<a name="ln1402">    marshallByte(th, NUM_EQUIP - EQ_FIRST_EQUIP);</a>
<a name="ln1403">    for (int i = EQ_FIRST_EQUIP; i &lt; NUM_EQUIP; ++i)</a>
<a name="ln1404">        marshallByte(th, you.equip[i]);</a>
<a name="ln1405">    for (int i = EQ_FIRST_EQUIP; i &lt; NUM_EQUIP; ++i)</a>
<a name="ln1406">        marshallBoolean(th, you.melded[i]);</a>
<a name="ln1407">    for (int i = EQ_FIRST_EQUIP; i &lt; NUM_EQUIP; ++i)</a>
<a name="ln1408">        marshallBoolean(th, you.activated[i]);</a>
<a name="ln1409"> </a>
<a name="ln1410">    ASSERT_RANGE(you.magic_points, 0, you.max_magic_points + 1);</a>
<a name="ln1411">    marshallUByte(th, you.magic_points);</a>
<a name="ln1412">    marshallByte(th, you.max_magic_points);</a>
<a name="ln1413"> </a>
<a name="ln1414">    COMPILE_CHECK(NUM_STATS == 3);</a>
<a name="ln1415">    for (int i = 0; i &lt; NUM_STATS; ++i)</a>
<a name="ln1416">        marshallByte(th, you.base_stats[i]);</a>
<a name="ln1417">    for (int i = 0; i &lt; NUM_STATS; ++i)</a>
<a name="ln1418">        marshallByte(th, you.stat_loss[i]);</a>
<a name="ln1419"> </a>
<a name="ln1420">    CANARY;</a>
<a name="ln1421"> </a>
<a name="ln1422">    marshallInt(th, you.hit_points_regeneration);</a>
<a name="ln1423">    marshallInt(th, you.magic_points_regeneration);</a>
<a name="ln1424"> </a>
<a name="ln1425">    marshallInt(th, you.experience);</a>
<a name="ln1426">    marshallInt(th, you.total_experience);</a>
<a name="ln1427">    marshallInt(th, you.gold);</a>
<a name="ln1428"> </a>
<a name="ln1429">    marshallInt(th, you.exp_available);</a>
<a name="ln1430"> </a>
<a name="ln1431">    marshallInt(th, you.zigs_completed);</a>
<a name="ln1432">    marshallByte(th, you.zig_max);</a>
<a name="ln1433"> </a>
<a name="ln1434">    marshallString(th, you.banished_by);</a>
<a name="ln1435"> </a>
<a name="ln1436">    marshallShort(th, you.hp_max_adj_temp);</a>
<a name="ln1437">    marshallShort(th, you.hp_max_adj_perm);</a>
<a name="ln1438">    marshallShort(th, you.mp_max_adj);</a>
<a name="ln1439"> </a>
<a name="ln1440">    marshallShort(th, you.pos().x);</a>
<a name="ln1441">    marshallShort(th, you.pos().y);</a>
<a name="ln1442"> </a>
<a name="ln1443">    _marshallFixedBitVector&lt;NUM_SPELLS&gt;(th, you.spell_library);</a>
<a name="ln1444">    _marshallFixedBitVector&lt;NUM_SPELLS&gt;(th, you.hidden_spells);</a>
<a name="ln1445"> </a>
<a name="ln1446">    // how many spells?</a>
<a name="ln1447">    marshallUByte(th, MAX_KNOWN_SPELLS);</a>
<a name="ln1448">    for (int i = 0; i &lt; MAX_KNOWN_SPELLS; ++i)</a>
<a name="ln1449">        marshallShort(th, you.spells[i]);</a>
<a name="ln1450"> </a>
<a name="ln1451">    marshallByte(th, 52);</a>
<a name="ln1452">    for (int i = 0; i &lt; 52; i++)</a>
<a name="ln1453">        marshallByte(th, you.spell_letter_table[i]);</a>
<a name="ln1454"> </a>
<a name="ln1455">    marshallByte(th, 52);</a>
<a name="ln1456">    for (int i = 0; i &lt; 52; i++)</a>
<a name="ln1457">        marshallShort(th, you.ability_letter_table[i]);</a>
<a name="ln1458"> </a>
<a name="ln1459">    marshallUByte(th, you.old_vehumet_gifts.size());</a>
<a name="ln1460">    for (auto spell : you.old_vehumet_gifts)</a>
<a name="ln1461">        marshallShort(th, spell);</a>
<a name="ln1462"> </a>
<a name="ln1463">    marshallUByte(th, you.vehumet_gifts.size());</a>
<a name="ln1464">    for (auto spell : you.vehumet_gifts)</a>
<a name="ln1465">        marshallShort(th, spell);</a>
<a name="ln1466"> </a>
<a name="ln1467">    CANARY;</a>
<a name="ln1468"> </a>
<a name="ln1469">    // how many skills?</a>
<a name="ln1470">    marshallByte(th, NUM_SKILLS);</a>
<a name="ln1471">    for (int j = 0; j &lt; NUM_SKILLS; ++j)</a>
<a name="ln1472">    {</a>
<a name="ln1473">        marshallUByte(th, you.skills[j]);</a>
<a name="ln1474">        marshallByte(th, you.train[j]);</a>
<a name="ln1475">        marshallByte(th, you.train_alt[j]);</a>
<a name="ln1476">        marshallInt(th, you.training[j]);</a>
<a name="ln1477">        marshallInt(th, you.skill_points[j]);</a>
<a name="ln1478">        marshallInt(th, you.ct_skill_points[j]);</a>
<a name="ln1479">        marshallByte(th, you.skill_order[j]);   // skills ordering</a>
<a name="ln1480">        marshallInt(th, you.training_targets[j]);</a>
<a name="ln1481">    }</a>
<a name="ln1482"> </a>
<a name="ln1483">    marshallBoolean(th, you.auto_training);</a>
<a name="ln1484">    marshallByte(th, you.exercises.size());</a>
<a name="ln1485">    for (auto sk : you.exercises)</a>
<a name="ln1486">        marshallInt(th, sk);</a>
<a name="ln1487"> </a>
<a name="ln1488">    marshallByte(th, you.exercises_all.size());</a>
<a name="ln1489">    for (auto sk : you.exercises_all)</a>
<a name="ln1490">        marshallInt(th, sk);</a>
<a name="ln1491"> </a>
<a name="ln1492">    marshallByte(th, you.skill_menu_do);</a>
<a name="ln1493">    marshallByte(th, you.skill_menu_view);</a>
<a name="ln1494"> </a>
<a name="ln1495">    marshallInt(th, you.transfer_from_skill);</a>
<a name="ln1496">    marshallInt(th, you.transfer_to_skill);</a>
<a name="ln1497">    marshallInt(th, you.transfer_skill_points);</a>
<a name="ln1498">    marshallInt(th, you.transfer_total_skill_points);</a>
<a name="ln1499"> </a>
<a name="ln1500">    CANARY;</a>
<a name="ln1501"> </a>
<a name="ln1502">    // how many durations?</a>
<a name="ln1503">    marshallUByte(th, NUM_DURATIONS);</a>
<a name="ln1504">    for (int j = 0; j &lt; NUM_DURATIONS; ++j)</a>
<a name="ln1505">        marshallInt(th, you.duration[j]);</a>
<a name="ln1506"> </a>
<a name="ln1507">    // how many attributes?</a>
<a name="ln1508">    marshallByte(th, NUM_ATTRIBUTES);</a>
<a name="ln1509">    for (int j = 0; j &lt; NUM_ATTRIBUTES; ++j)</a>
<a name="ln1510">        marshallInt(th, you.attribute[j]);</a>
<a name="ln1511"> </a>
<a name="ln1512">    // Event timers.</a>
<a name="ln1513">    marshallByte(th, NUM_TIMERS);</a>
<a name="ln1514">    for (int j = 0; j &lt; NUM_TIMERS; ++j)</a>
<a name="ln1515">    {</a>
<a name="ln1516">        marshallInt(th, you.last_timer_effect[j]);</a>
<a name="ln1517">        marshallInt(th, you.next_timer_effect[j]);</a>
<a name="ln1518">    }</a>
<a name="ln1519"> </a>
<a name="ln1520">    // how many mutations/demon powers?</a>
<a name="ln1521">    marshallShort(th, NUM_MUTATIONS);</a>
<a name="ln1522">    for (int j = 0; j &lt; NUM_MUTATIONS; ++j)</a>
<a name="ln1523">    {</a>
<a name="ln1524">        marshallByte(th, you.mutation[j]);</a>
<a name="ln1525">        marshallByte(th, you.innate_mutation[j]);</a>
<a name="ln1526">        marshallByte(th, you.temp_mutation[j]);</a>
<a name="ln1527">        marshallByte(th, you.sacrifices[j]);</a>
<a name="ln1528">    }</a>
<a name="ln1529"> </a>
<a name="ln1530">    marshallByte(th, you.demonic_traits.size());</a>
<a name="ln1531">    for (int j = 0; j &lt; int(you.demonic_traits.size()); ++j)</a>
<a name="ln1532">    {</a>
<a name="ln1533">        marshallByte(th, you.demonic_traits[j].level_gained);</a>
<a name="ln1534">        marshallShort(th, you.demonic_traits[j].mutation);</a>
<a name="ln1535">    }</a>
<a name="ln1536"> </a>
<a name="ln1537">    // set up sacrifice piety by ability</a>
<a name="ln1538">    marshallShort(th, 1 + ABIL_FINAL_SACRIFICE - ABIL_FIRST_SACRIFICE);</a>
<a name="ln1539">    for (int j = ABIL_FIRST_SACRIFICE; j &lt;= ABIL_FINAL_SACRIFICE; ++j)</a>
<a name="ln1540">        marshallByte(th, you.sacrifice_piety[j]);</a>
<a name="ln1541"> </a>
<a name="ln1542">    CANARY;</a>
<a name="ln1543"> </a>
<a name="ln1544">    // how many penances?</a>
<a name="ln1545">    marshallByte(th, NUM_GODS);</a>
<a name="ln1546">    for (god_iterator it; it; ++it)</a>
<a name="ln1547">        marshallByte(th, you.penance[*it]);</a>
<a name="ln1548"> </a>
<a name="ln1549">    // which gods have been worshipped by this character?</a>
<a name="ln1550">    for (god_iterator it; it; ++it)</a>
<a name="ln1551">        marshallByte(th, you.worshipped[*it]);</a>
<a name="ln1552"> </a>
<a name="ln1553">    // what is the extent of divine generosity?</a>
<a name="ln1554">    for (god_iterator it; it; ++it)</a>
<a name="ln1555">        marshallShort(th, you.num_current_gifts[*it]);</a>
<a name="ln1556">    for (god_iterator it; it; ++it)</a>
<a name="ln1557">        marshallShort(th, you.num_total_gifts[*it]);</a>
<a name="ln1558">    for (god_iterator it; it; ++it)</a>
<a name="ln1559">        marshallBoolean(th, you.one_time_ability_used[*it]);</a>
<a name="ln1560"> </a>
<a name="ln1561">    // how much piety have you achieved at highest with each god?</a>
<a name="ln1562">    for (god_iterator it; it; ++it)</a>
<a name="ln1563">        marshallByte(th, you.piety_max[*it]);</a>
<a name="ln1564"> </a>
<a name="ln1565">    marshallByte(th, you.gift_timeout);</a>
<a name="ln1566">    marshallUByte(th, you.saved_good_god_piety);</a>
<a name="ln1567">    marshallByte(th, you.previous_good_god);</a>
<a name="ln1568"> </a>
<a name="ln1569">    for (god_iterator it; it; ++it)</a>
<a name="ln1570">        marshallInt(th, you.exp_docked[*it]);</a>
<a name="ln1571">    for (god_iterator it; it; ++it)</a>
<a name="ln1572">        marshallInt(th, you.exp_docked_total[*it]);</a>
<a name="ln1573"> </a>
<a name="ln1574">    // elapsed time</a>
<a name="ln1575">    marshallInt(th, you.elapsed_time);</a>
<a name="ln1576"> </a>
<a name="ln1577">    // time of game start</a>
<a name="ln1578">    marshallInt(th, you.birth_time);</a>
<a name="ln1579"> </a>
<a name="ln1580">    handle_real_time();</a>
<a name="ln1581"> </a>
<a name="ln1582">    // TODO: maybe switch to marshalling real_time_ms.</a>
<a name="ln1583">    marshallInt(th, you.real_time());</a>
<a name="ln1584">    marshallInt(th, you.num_turns);</a>
<a name="ln1585">    marshallInt(th, you.exploration);</a>
<a name="ln1586"> </a>
<a name="ln1587">    marshallInt(th, you.magic_contamination);</a>
<a name="ln1588"> </a>
<a name="ln1589">#if TAG_MAJOR_VERSION == 34</a>
<a name="ln1590">    marshallUByte(th, 0);</a>
<a name="ln1591">#endif</a>
<a name="ln1592">    marshallUByte(th, you.transit_stair);</a>
<a name="ln1593">    marshallByte(th, you.entering_level);</a>
<a name="ln1594">    marshallBoolean(th, you.travel_ally_pace);</a>
<a name="ln1595"> </a>
<a name="ln1596">    marshallByte(th, you.deaths);</a>
<a name="ln1597">    marshallByte(th, you.lives);</a>
<a name="ln1598"> </a>
<a name="ln1599">    CANARY;</a>
<a name="ln1600"> </a>
<a name="ln1601">    marshallInt(th, you.dactions.size());</a>
<a name="ln1602">    for (daction_type da : you.dactions)</a>
<a name="ln1603">        marshallByte(th, da);</a>
<a name="ln1604"> </a>
<a name="ln1605">    marshallInt(th, you.level_stack.size());</a>
<a name="ln1606">    for (const level_pos &amp;lvl : you.level_stack)</a>
<a name="ln1607">        lvl.save(th);</a>
<a name="ln1608"> </a>
<a name="ln1609">    // List of currently beholding monsters (usually empty).</a>
<a name="ln1610">    marshallShort(th, you.beholders.size());</a>
<a name="ln1611">    for (mid_t beh : you.beholders)</a>
<a name="ln1612">         _marshall_as_int(th, beh);</a>
<a name="ln1613"> </a>
<a name="ln1614">    marshallShort(th, you.fearmongers.size());</a>
<a name="ln1615">    for (mid_t monger : you.fearmongers)</a>
<a name="ln1616">        _marshall_as_int(th, monger);</a>
<a name="ln1617"> </a>
<a name="ln1618">    marshallByte(th, you.piety_hysteresis);</a>
<a name="ln1619"> </a>
<a name="ln1620">    you.m_quiver.save(th);</a>
<a name="ln1621"> </a>
<a name="ln1622">    CANARY;</a>
<a name="ln1623"> </a>
<a name="ln1624">    // Action counts.</a>
<a name="ln1625">    marshallShort(th, you.action_count.size());</a>
<a name="ln1626">    for (const auto &amp;ac : you.action_count)</a>
<a name="ln1627">    {</a>
<a name="ln1628">        marshallShort(th, ac.first.first);</a>
<a name="ln1629">        marshallInt(th, ac.first.second);</a>
<a name="ln1630">        for (int k = 0; k &lt; 27; k++)</a>
<a name="ln1631">            marshallInt(th, ac.second[k]);</a>
<a name="ln1632">    }</a>
<a name="ln1633"> </a>
<a name="ln1634">    marshallByte(th, NUM_BRANCHES);</a>
<a name="ln1635">    for (int i = 0; i &lt; NUM_BRANCHES; i++)</a>
<a name="ln1636">        marshallBoolean(th, you.branches_left[i]);</a>
<a name="ln1637"> </a>
<a name="ln1638">    marshallCoord(th, abyssal_state.major_coord);</a>
<a name="ln1639">    marshallInt(th, abyssal_state.seed);</a>
<a name="ln1640">    marshallInt(th, abyssal_state.depth);</a>
<a name="ln1641">    marshallFloat(th, abyssal_state.phase);</a>
<a name="ln1642">    marshall_level_id(th, abyssal_state.level);</a>
<a name="ln1643"> </a>
<a name="ln1644">#if TAG_MAJOR_VERSION == 34</a>
<a name="ln1645">    if (abyssal_state.level.branch == BRANCH_DWARF || !abyssal_state.level.is_valid())</a>
<a name="ln1646">        abyssal_state.level = level_id(static_cast&lt;branch_type&gt;(BRANCH_DUNGEON), 19);</a>
<a name="ln1647">#endif</a>
<a name="ln1648"> </a>
<a name="ln1649">    _marshall_constriction(th, &amp;you);</a>
<a name="ln1650"> </a>
<a name="ln1651">    marshallUByte(th, you.octopus_king_rings);</a>
<a name="ln1652"> </a>
<a name="ln1653">    marshallUnsigned(th, you.uncancel.size());</a>
<a name="ln1654">    for (const pair&lt;uncancellable_type, int&gt;&amp; unc : you.uncancel)</a>
<a name="ln1655">    {</a>
<a name="ln1656">        marshallUByte(th, unc.first);</a>
<a name="ln1657">        marshallInt(th, unc.second);</a>
<a name="ln1658">    }</a>
<a name="ln1659"> </a>
<a name="ln1660">    marshallUnsigned(th, you.recall_list.size());</a>
<a name="ln1661">    for (mid_t recallee : you.recall_list)</a>
<a name="ln1662">        _marshall_as_int(th, recallee);</a>
<a name="ln1663"> </a>
<a name="ln1664">    marshallUByte(th, 1); // number of seeds, for historical reasons: always 1</a>
<a name="ln1665">    marshallUnsigned(th, you.game_seed);</a>
<a name="ln1666">    marshallBoolean(th, you.fully_seeded); // TODO: remove on major version inc?</a>
<a name="ln1667">    marshallBoolean(th, you.deterministic_levelgen);</a>
<a name="ln1668">    CrawlVector rng_states = rng::generators_to_vector();</a>
<a name="ln1669">    rng_states.write(th);</a>
<a name="ln1670"> </a>
<a name="ln1671">    CANARY;</a>
<a name="ln1672"> </a>
<a name="ln1673">    // don't let vault caching errors leave a normal game with sprint scoring</a>
<a name="ln1674">    if (!crawl_state.game_is_sprint())</a>
<a name="ln1675">        ASSERT(!_calc_score_exists());</a>
<a name="ln1676"> </a>
<a name="ln1677">    if (!dlua.callfn(&quot;dgn_save_data&quot;, &quot;u&quot;, &amp;th))</a>
<a name="ln1678">        mprf(MSGCH_ERROR, &quot;Failed to save Lua data: %s&quot;, dlua.error.c_str());</a>
<a name="ln1679"> </a>
<a name="ln1680">    CANARY;</a>
<a name="ln1681"> </a>
<a name="ln1682">    // Write a human-readable string out on the off chance that</a>
<a name="ln1683">    // we fail to be able to read this file back in using some later version.</a>
<a name="ln1684">    string revision = &quot;Git:&quot;;</a>
<a name="ln1685">    revision += Version::Long;</a>
<a name="ln1686">    marshallString(th, revision);</a>
<a name="ln1687"> </a>
<a name="ln1688">    you.props.write(th);</a>
<a name="ln1689">}</a>
<a name="ln1690"> </a>
<a name="ln1691">static void _tag_construct_you_items(writer &amp;th)</a>
<a name="ln1692">{</a>
<a name="ln1693">    // how many inventory slots?</a>
<a name="ln1694">    marshallByte(th, ENDOFPACK);</a>
<a name="ln1695">    for (const auto &amp;item : you.inv)</a>
<a name="ln1696">        marshallItem(th, item);</a>
<a name="ln1697"> </a>
<a name="ln1698">    _marshallFixedBitVector&lt;NUM_RUNE_TYPES&gt;(th, you.runes);</a>
<a name="ln1699">    marshallByte(th, you.obtainable_runes);</a>
<a name="ln1700"> </a>
<a name="ln1701">    // Item descrip for each type &amp; subtype.</a>
<a name="ln1702">    // how many types?</a>
<a name="ln1703">    marshallUByte(th, NUM_IDESC);</a>
<a name="ln1704">    // how many subtypes?</a>
<a name="ln1705">    marshallUByte(th, MAX_SUBTYPES);</a>
<a name="ln1706">    for (int i = 0; i &lt; NUM_IDESC; ++i)</a>
<a name="ln1707">        for (int j = 0; j &lt; MAX_SUBTYPES; ++j)</a>
<a name="ln1708">            marshallInt(th, you.item_description[i][j]);</a>
<a name="ln1709"> </a>
<a name="ln1710">    marshallUByte(th, NUM_OBJECT_CLASSES);</a>
<a name="ln1711">    for (int i = 0; i &lt; NUM_OBJECT_CLASSES; ++i)</a>
<a name="ln1712">    {</a>
<a name="ln1713">        if (!item_type_has_ids((object_class_type)i))</a>
<a name="ln1714">            continue;</a>
<a name="ln1715">        for (int j = 0; j &lt; MAX_SUBTYPES; ++j)</a>
<a name="ln1716">            marshallBoolean(th, you.type_ids[i][j]);</a>
<a name="ln1717">    }</a>
<a name="ln1718"> </a>
<a name="ln1719">    CANARY;</a>
<a name="ln1720"> </a>
<a name="ln1721">    // how many unique items?</a>
<a name="ln1722">    marshallUByte(th, MAX_UNRANDARTS);</a>
<a name="ln1723">    for (int j = 0; j &lt; MAX_UNRANDARTS; ++j)</a>
<a name="ln1724">        marshallByte(th,you.unique_items[j]);</a>
<a name="ln1725"> </a>
<a name="ln1726">    marshallShort(th, NUM_WEAPONS);</a>
<a name="ln1727">    for (int j = 0; j &lt; NUM_WEAPONS; ++j)</a>
<a name="ln1728">        marshallInt(th,you.seen_weapon[j]);</a>
<a name="ln1729"> </a>
<a name="ln1730">    marshallShort(th, NUM_ARMOURS);</a>
<a name="ln1731">    for (int j = 0; j &lt; NUM_ARMOURS; ++j)</a>
<a name="ln1732">        marshallInt(th,you.seen_armour[j]);</a>
<a name="ln1733"> </a>
<a name="ln1734">    _marshallFixedBitVector&lt;NUM_MISCELLANY&gt;(th, you.seen_misc);</a>
<a name="ln1735"> </a>
<a name="ln1736">    for (int i = 0; i &lt; NUM_OBJECT_CLASSES; i++)</a>
<a name="ln1737">        for (int j = 0; j &lt; MAX_SUBTYPES; j++)</a>
<a name="ln1738">            marshallInt(th, you.force_autopickup[i][j]);</a>
<a name="ln1739">}</a>
<a name="ln1740"> </a>
<a name="ln1741">static void marshallPlaceInfo(writer &amp;th, PlaceInfo place_info)</a>
<a name="ln1742">{</a>
<a name="ln1743">    marshallInt(th, place_info.branch);</a>
<a name="ln1744"> </a>
<a name="ln1745">    marshallInt(th, place_info.num_visits);</a>
<a name="ln1746">    marshallInt(th, place_info.levels_seen);</a>
<a name="ln1747"> </a>
<a name="ln1748">    marshallInt(th, place_info.mon_kill_exp);</a>
<a name="ln1749"> </a>
<a name="ln1750">    for (int i = 0; i &lt; KC_NCATEGORIES; i++)</a>
<a name="ln1751">        marshallInt(th, place_info.mon_kill_num[i]);</a>
<a name="ln1752"> </a>
<a name="ln1753">    marshallInt(th, place_info.turns_total);</a>
<a name="ln1754">    marshallInt(th, place_info.turns_explore);</a>
<a name="ln1755">    marshallInt(th, place_info.turns_travel);</a>
<a name="ln1756">    marshallInt(th, place_info.turns_interlevel);</a>
<a name="ln1757">    marshallInt(th, place_info.turns_resting);</a>
<a name="ln1758">    marshallInt(th, place_info.turns_other);</a>
<a name="ln1759"> </a>
<a name="ln1760">    marshallInt(th, place_info.elapsed_total);</a>
<a name="ln1761">    marshallInt(th, place_info.elapsed_explore);</a>
<a name="ln1762">    marshallInt(th, place_info.elapsed_travel);</a>
<a name="ln1763">    marshallInt(th, place_info.elapsed_interlevel);</a>
<a name="ln1764">    marshallInt(th, place_info.elapsed_resting);</a>
<a name="ln1765">    marshallInt(th, place_info.elapsed_other);</a>
<a name="ln1766">}</a>
<a name="ln1767"> </a>
<a name="ln1768">static void marshallLevelXPInfo(writer &amp;th, LevelXPInfo xp_info)</a>
<a name="ln1769">{</a>
<a name="ln1770">    marshall_level_id(th, xp_info.level);</a>
<a name="ln1771"> </a>
<a name="ln1772">    marshallInt(th, xp_info.non_vault_xp);</a>
<a name="ln1773">    marshallInt(th, xp_info.non_vault_count);</a>
<a name="ln1774">    marshallInt(th, xp_info.vault_xp);</a>
<a name="ln1775">    marshallInt(th, xp_info.vault_count);</a>
<a name="ln1776">}</a>
<a name="ln1777"> </a>
<a name="ln1778">static void _tag_construct_you_dungeon(writer &amp;th)</a>
<a name="ln1779">{</a>
<a name="ln1780">    // how many unique creatures?</a>
<a name="ln1781">    marshallShort(th, NUM_MONSTERS);</a>
<a name="ln1782">    for (int j = 0; j &lt; NUM_MONSTERS; ++j)</a>
<a name="ln1783">        marshallByte(th,you.unique_creatures[j]); // unique beasties</a>
<a name="ln1784"> </a>
<a name="ln1785">    // how many branches?</a>
<a name="ln1786">    marshallByte(th, NUM_BRANCHES);</a>
<a name="ln1787">    for (int j = 0; j &lt; NUM_BRANCHES; ++j)</a>
<a name="ln1788">    {</a>
<a name="ln1789">        marshallInt(th, brdepth[j]);</a>
<a name="ln1790">        marshall_level_id(th, brentry[j]);</a>
<a name="ln1791">        marshallInt(th, branch_bribe[j]);</a>
<a name="ln1792">    }</a>
<a name="ln1793"> </a>
<a name="ln1794">    // Root of the dungeon; usually BRANCH_DUNGEON.</a>
<a name="ln1795">    marshallInt(th, root_branch);</a>
<a name="ln1796"> </a>
<a name="ln1797">    marshallMap(th, stair_level,</a>
<a name="ln1798">                _marshall_as_int&lt;branch_type&gt;, _marshall_level_id_set);</a>
<a name="ln1799">    marshallMap(th, shops_present,</a>
<a name="ln1800">                _marshall_level_pos, _marshall_as_int&lt;shop_type&gt;);</a>
<a name="ln1801">    marshallMap(th, altars_present,</a>
<a name="ln1802">                _marshall_level_pos, _marshall_as_int&lt;god_type&gt;);</a>
<a name="ln1803">    marshallMap(th, portals_present,</a>
<a name="ln1804">                _marshall_level_pos, _marshall_as_int&lt;branch_type&gt;);</a>
<a name="ln1805">    marshallMap(th, portal_notes,</a>
<a name="ln1806">                _marshall_level_pos, marshallString);</a>
<a name="ln1807">    marshallMap(th, level_annotations,</a>
<a name="ln1808">                marshall_level_id, marshallString);</a>
<a name="ln1809">    marshallMap(th, level_exclusions,</a>
<a name="ln1810">                marshall_level_id, marshallString);</a>
<a name="ln1811">    marshallMap(th, level_uniques,</a>
<a name="ln1812">            marshall_level_id, marshallString);</a>
<a name="ln1813">    marshallUniqueAnnotations(th);</a>
<a name="ln1814"> </a>
<a name="ln1815">    marshallPlaceInfo(th, you.global_info);</a>
<a name="ln1816">    vector&lt;PlaceInfo&gt; list = you.get_all_place_info();</a>
<a name="ln1817">    // How many different places we have info on?</a>
<a name="ln1818">    marshallShort(th, list.size());</a>
<a name="ln1819"> </a>
<a name="ln1820">    for (const PlaceInfo &amp;place : list)</a>
<a name="ln1821">        marshallPlaceInfo(th, place);</a>
<a name="ln1822"> </a>
<a name="ln1823">    marshallLevelXPInfo(th, you.global_xp_info);</a>
<a name="ln1824"> </a>
<a name="ln1825">    vector&lt;LevelXPInfo&gt; xp_info_list = you.get_all_xp_info();</a>
<a name="ln1826">    // How many different levels do we have info on?</a>
<a name="ln1827">    marshallShort(th, xp_info_list.size());</a>
<a name="ln1828">    for (const auto info: xp_info_list)</a>
<a name="ln1829">        marshallLevelXPInfo(th, info);</a>
<a name="ln1830"> </a>
<a name="ln1831">    _marshall_iterator(th, you.uniq_map_tags.begin(), you.uniq_map_tags.end(),</a>
<a name="ln1832">                       marshallString);</a>
<a name="ln1833">    _marshall_iterator(th, you.uniq_map_names.begin(), you.uniq_map_names.end(),</a>
<a name="ln1834">                       marshallString);</a>
<a name="ln1835">    _marshall_iterator(th, you.uniq_map_tags_abyss.begin(),</a>
<a name="ln1836">                       you.uniq_map_tags_abyss.end(), marshallString);</a>
<a name="ln1837">    _marshall_iterator(th, you.uniq_map_names_abyss.begin(),</a>
<a name="ln1838">                       you.uniq_map_names_abyss.end(), marshallString);</a>
<a name="ln1839">    marshallMap(th, you.vault_list, marshall_level_id, marshallStringVector);</a>
<a name="ln1840"> </a>
<a name="ln1841">    write_level_connectivity(th);</a>
<a name="ln1842">}</a>
<a name="ln1843"> </a>
<a name="ln1844">static void marshall_follower(writer &amp;th, const follower &amp;f)</a>
<a name="ln1845">{</a>
<a name="ln1846">    ASSERT(!invalid_monster_type(f.mons.type));</a>
<a name="ln1847">    ASSERT(f.mons.alive());</a>
<a name="ln1848">    marshallMonster(th, f.mons);</a>
<a name="ln1849">    marshallInt(th, f.transit_start_time);</a>
<a name="ln1850">    for (int i = 0; i &lt; NUM_MONSTER_SLOTS; ++i)</a>
<a name="ln1851">        marshallItem(th, f.items[i]);</a>
<a name="ln1852">}</a>
<a name="ln1853"> </a>
<a name="ln1854">static follower unmarshall_follower(reader &amp;th)</a>
<a name="ln1855">{</a>
<a name="ln1856">    follower f;</a>
<a name="ln1857">    unmarshallMonster(th, f.mons);</a>
<a name="ln1858">#if TAG_MAJOR_VERSION == 34</a>
<a name="ln1859">    if (th.getMinorVersion() &gt;= TAG_MINOR_FOLLOWER_TRANSIT_TIME)</a>
<a name="ln1860">#endif</a>
<a name="ln1861">        f.transit_start_time = unmarshallInt(th);</a>
<a name="ln1862">#if TAG_MAJOR_VERSION == 34</a>
<a name="ln1863">    else</a>
<a name="ln1864">    {</a>
<a name="ln1865">        //Set transit_start_time to 0 and let follower heal completely</a>
<a name="ln1866">        f.transit_start_time = 0;</a>
<a name="ln1867">    }</a>
<a name="ln1868">#endif</a>
<a name="ln1869">    for (int i = 0; i &lt; NUM_MONSTER_SLOTS; ++i)</a>
<a name="ln1870">        unmarshallItem(th, f.items[i]);</a>
<a name="ln1871">    return f;</a>
<a name="ln1872">}</a>
<a name="ln1873"> </a>
<a name="ln1874">static void marshall_companion(writer &amp;th, const companion &amp;c)</a>
<a name="ln1875">{</a>
<a name="ln1876">    marshall_follower(th, c.mons);</a>
<a name="ln1877">    marshall_level_id(th, c.level);</a>
<a name="ln1878">    marshallInt(th, c.timestamp);</a>
<a name="ln1879">}</a>
<a name="ln1880"> </a>
<a name="ln1881">static companion unmarshall_companion(reader &amp;th)</a>
<a name="ln1882">{</a>
<a name="ln1883">    companion c;</a>
<a name="ln1884">    c.mons = unmarshall_follower(th);</a>
<a name="ln1885">    c.level = unmarshall_level_id(th);</a>
<a name="ln1886">    c.timestamp = unmarshallInt(th);</a>
<a name="ln1887">    return c;</a>
<a name="ln1888">}</a>
<a name="ln1889"> </a>
<a name="ln1890">static void marshall_follower_list(writer &amp;th, const m_transit_list &amp;mlist)</a>
<a name="ln1891">{</a>
<a name="ln1892">    marshallShort(th, mlist.size());</a>
<a name="ln1893"> </a>
<a name="ln1894">    for (const auto &amp;follower : mlist)</a>
<a name="ln1895">        marshall_follower(th, follower);</a>
<a name="ln1896">}</a>
<a name="ln1897"> </a>
<a name="ln1898">static m_transit_list unmarshall_follower_list(reader &amp;th)</a>
<a name="ln1899">{</a>
<a name="ln1900">    m_transit_list mlist;</a>
<a name="ln1901"> </a>
<a name="ln1902">    const int size = unmarshallShort(th);</a>
<a name="ln1903"> </a>
<a name="ln1904">    for (int i = 0; i &lt; size; ++i)</a>
<a name="ln1905">    {</a>
<a name="ln1906">        follower f = unmarshall_follower(th);</a>
<a name="ln1907">        if (!f.mons.alive())</a>
<a name="ln1908">        {</a>
<a name="ln1909">            mprf(MSGCH_ERROR,</a>
<a name="ln1910">                 &quot;Dead monster %s in transit list in saved game, ignoring.&quot;,</a>
<a name="ln1911">                 f.mons.name(DESC_PLAIN, true).c_str());</a>
<a name="ln1912">        }</a>
<a name="ln1913">        else</a>
<a name="ln1914">            mlist.push_back(f);</a>
<a name="ln1915">    }</a>
<a name="ln1916"> </a>
<a name="ln1917">    return mlist;</a>
<a name="ln1918">}</a>
<a name="ln1919"> </a>
<a name="ln1920">#if TAG_MAJOR_VERSION == 34</a>
<a name="ln1921">static i_transit_list unmarshall_item_list(reader &amp;th)</a>
<a name="ln1922">{</a>
<a name="ln1923">    i_transit_list ilist;</a>
<a name="ln1924"> </a>
<a name="ln1925">    const int size = unmarshallShort(th);</a>
<a name="ln1926"> </a>
<a name="ln1927">    for (int i = 0; i &lt; size; ++i)</a>
<a name="ln1928">    {</a>
<a name="ln1929">        item_def item;</a>
<a name="ln1930">        unmarshallItem(th, item);</a>
<a name="ln1931">        ilist.push_back(item);</a>
<a name="ln1932">    }</a>
<a name="ln1933"> </a>
<a name="ln1934">    return ilist;</a>
<a name="ln1935">}</a>
<a name="ln1936">#endif</a>
<a name="ln1937"> </a>
<a name="ln1938">static void marshall_level_map_masks(writer &amp;th)</a>
<a name="ln1939">{</a>
<a name="ln1940">    for (rectangle_iterator ri(0); ri; ++ri)</a>
<a name="ln1941">    {</a>
<a name="ln1942">        marshallInt(th, env.level_map_mask(*ri));</a>
<a name="ln1943">        marshallInt(th, env.level_map_ids(*ri));</a>
<a name="ln1944">    }</a>
<a name="ln1945">}</a>
<a name="ln1946"> </a>
<a name="ln1947">static void unmarshall_level_map_masks(reader &amp;th)</a>
<a name="ln1948">{</a>
<a name="ln1949">    for (rectangle_iterator ri(0); ri; ++ri)</a>
<a name="ln1950">    {</a>
<a name="ln1951">        env.level_map_mask(*ri) = unmarshallInt(th);</a>
<a name="ln1952">        env.level_map_ids(*ri)  = unmarshallInt(th);</a>
<a name="ln1953">    }</a>
<a name="ln1954">}</a>
<a name="ln1955"> </a>
<a name="ln1956">static void marshall_level_map_unique_ids(writer &amp;th)</a>
<a name="ln1957">{</a>
<a name="ln1958">    marshallSet(th, env.level_uniq_maps, marshallString);</a>
<a name="ln1959">    marshallSet(th, env.level_uniq_map_tags, marshallString);</a>
<a name="ln1960">}</a>
<a name="ln1961"> </a>
<a name="ln1962">static void unmarshall_level_map_unique_ids(reader &amp;th)</a>
<a name="ln1963">{</a>
<a name="ln1964">    unmarshallSet(th, env.level_uniq_maps, unmarshallString);</a>
<a name="ln1965">    unmarshallSet(th, env.level_uniq_map_tags, unmarshallString);</a>
<a name="ln1966">}</a>
<a name="ln1967"> </a>
<a name="ln1968">static void marshall_subvault_place(writer &amp;th,</a>
<a name="ln1969">                                    const subvault_place &amp;subvault_place);</a>
<a name="ln1970"> </a>
<a name="ln1971">static void marshall_mapdef(writer &amp;th, const map_def &amp;map)</a>
<a name="ln1972">{</a>
<a name="ln1973">    marshallString(th, map.name);</a>
<a name="ln1974">    map.write_index(th);</a>
<a name="ln1975">    map.write_maplines(th);</a>
<a name="ln1976">    marshallString(th, map.description);</a>
<a name="ln1977">    marshallMap(th, map.feat_renames,</a>
<a name="ln1978">                _marshall_as_int&lt;dungeon_feature_type&gt;, marshallString);</a>
<a name="ln1979">    _marshall_iterator(th,</a>
<a name="ln1980">                       map.subvault_places.begin(),</a>
<a name="ln1981">                       map.subvault_places.end(),</a>
<a name="ln1982">                       marshall_subvault_place);</a>
<a name="ln1983">}</a>
<a name="ln1984"> </a>
<a name="ln1985">static void marshall_subvault_place(writer &amp;th,</a>
<a name="ln1986">                                    const subvault_place &amp;subvault_place)</a>
<a name="ln1987">{</a>
<a name="ln1988">    marshallCoord(th, subvault_place.tl);</a>
<a name="ln1989">    marshallCoord(th, subvault_place.br);</a>
<a name="ln1990">    marshall_mapdef(th, *subvault_place.subvault);</a>
<a name="ln1991">}</a>
<a name="ln1992"> </a>
<a name="ln1993">static subvault_place unmarshall_subvault_place(reader &amp;th);</a>
<a name="ln1994">static map_def unmarshall_mapdef(reader &amp;th)</a>
<a name="ln1995">{</a>
<a name="ln1996">    map_def map;</a>
<a name="ln1997">    map.name = unmarshallString(th);</a>
<a name="ln1998">    map.read_index(th);</a>
<a name="ln1999">    map.read_maplines(th);</a>
<a name="ln2000">    map.description = unmarshallString(th);</a>
<a name="ln2001">    unmarshallMap(th, map.feat_renames,</a>
<a name="ln2002">                  unmarshall_int_as&lt;dungeon_feature_type&gt;,</a>
<a name="ln2003">                  unmarshallString);</a>
<a name="ln2004">#if TAG_MAJOR_VERSION == 34</a>
<a name="ln2005">    if (th.getMinorVersion() &gt;= TAG_MINOR_REIFY_SUBVAULTS</a>
<a name="ln2006">        &amp;&amp; th.getMinorVersion() != TAG_MINOR_0_11)</a>
<a name="ln2007">#endif</a>
<a name="ln2008">        _unmarshall_vector(th, map.subvault_places, unmarshall_subvault_place);</a>
<a name="ln2009"> </a>
<a name="ln2010">    // reload the map epilogue from the current cache in case it hasn't yet</a>
<a name="ln2011">    // been run.</a>
<a name="ln2012">    // it would probably be better game-design-wise to marshall the epilogue,</a>
<a name="ln2013">    // but currently I don't think we marshall any lua code and I'm not sure</a>
<a name="ln2014">    // this is the best practice to get into.</a>
<a name="ln2015">    map.reload_epilogue();</a>
<a name="ln2016">    return map;</a>
<a name="ln2017">}</a>
<a name="ln2018"> </a>
<a name="ln2019">static subvault_place unmarshall_subvault_place(reader &amp;th)</a>
<a name="ln2020">{</a>
<a name="ln2021">    subvault_place subvault;</a>
<a name="ln2022">    subvault.tl = unmarshallCoord(th);</a>
<a name="ln2023">    subvault.br = unmarshallCoord(th);</a>
<a name="ln2024">    subvault.set_subvault(unmarshall_mapdef(th));</a>
<a name="ln2025">    return subvault;</a>
<a name="ln2026">}</a>
<a name="ln2027"> </a>
<a name="ln2028">static void marshall_vault_placement(writer &amp;th, const vault_placement &amp;vp)</a>
<a name="ln2029">{</a>
<a name="ln2030">    marshallCoord(th, vp.pos);</a>
<a name="ln2031">    marshallCoord(th, vp.size);</a>
<a name="ln2032">    marshallShort(th, vp.orient);</a>
<a name="ln2033">    marshall_mapdef(th, vp.map);</a>
<a name="ln2034">    _marshall_iterator(th, vp.exits.begin(), vp.exits.end(), marshallCoord);</a>
<a name="ln2035">#if TAG_MAJOR_VERSION == 34</a>
<a name="ln2036">    marshallShort(th, -1);</a>
<a name="ln2037">#endif</a>
<a name="ln2038">    marshallByte(th, vp.seen);</a>
<a name="ln2039">}</a>
<a name="ln2040"> </a>
<a name="ln2041">static vault_placement unmarshall_vault_placement(reader &amp;th)</a>
<a name="ln2042">{</a>
<a name="ln2043">    vault_placement vp;</a>
<a name="ln2044">    vp.pos = unmarshallCoord(th);</a>
<a name="ln2045">    vp.size = unmarshallCoord(th);</a>
<a name="ln2046">    vp.orient = static_cast&lt;map_section_type&gt;(unmarshallShort(th));</a>
<a name="ln2047">    vp.map = unmarshall_mapdef(th);</a>
<a name="ln2048">    _unmarshall_vector(th, vp.exits, unmarshallCoord);</a>
<a name="ln2049">#if TAG_MAJOR_VERSION == 34</a>
<a name="ln2050">    unmarshallShort(th);</a>
<a name="ln2051">#endif</a>
<a name="ln2052">    vp.seen = !!unmarshallByte(th);</a>
<a name="ln2053"> </a>
<a name="ln2054">    return vp;</a>
<a name="ln2055">}</a>
<a name="ln2056"> </a>
<a name="ln2057">static void marshall_level_vault_placements(writer &amp;th)</a>
<a name="ln2058">{</a>
<a name="ln2059">    marshallShort(th, env.level_vaults.size());</a>
<a name="ln2060">    for (unique_ptr&lt;vault_placement&gt; &amp;vp : env.level_vaults)</a>
<a name="ln2061">        marshall_vault_placement(th, *vp);</a>
<a name="ln2062">}</a>
<a name="ln2063"> </a>
<a name="ln2064">static void unmarshall_level_vault_placements(reader &amp;th)</a>
<a name="ln2065">{</a>
<a name="ln2066">    const int nvaults = unmarshallShort(th);</a>
<a name="ln2067">    ASSERT(nvaults &gt;= 0);</a>
<a name="ln2068">    dgn_clear_vault_placements();</a>
<a name="ln2069">    for (int i = 0; i &lt; nvaults; ++i)</a>
<a name="ln2070">    {</a>
<a name="ln2071">        env.level_vaults.emplace_back(</a>
<a name="ln2072">            new vault_placement(unmarshall_vault_placement(th)));</a>
<a name="ln2073">    }</a>
<a name="ln2074">}</a>
<a name="ln2075"> </a>
<a name="ln2076">static void marshall_level_vault_data(writer &amp;th)</a>
<a name="ln2077">{</a>
<a name="ln2078">    marshallString(th, env.level_build_method);</a>
<a name="ln2079">    marshallSet(th, env.level_layout_types, marshallString);</a>
<a name="ln2080"> </a>
<a name="ln2081">    marshall_level_map_masks(th);</a>
<a name="ln2082">    marshall_level_map_unique_ids(th);</a>
<a name="ln2083">#if TAG_MAJOR_VERSION == 34</a>
<a name="ln2084">    marshallInt(th, 0);</a>
<a name="ln2085">#endif</a>
<a name="ln2086">    marshall_level_vault_placements(th);</a>
<a name="ln2087">}</a>
<a name="ln2088"> </a>
<a name="ln2089">static void unmarshall_level_vault_data(reader &amp;th)</a>
<a name="ln2090">{</a>
<a name="ln2091">    env.level_build_method = unmarshallString(th);</a>
<a name="ln2092">    unmarshallSet(th, env.level_layout_types, unmarshallString);</a>
<a name="ln2093"> </a>
<a name="ln2094">    unmarshall_level_map_masks(th);</a>
<a name="ln2095">    unmarshall_level_map_unique_ids(th);</a>
<a name="ln2096">#if TAG_MAJOR_VERSION == 34</a>
<a name="ln2097">    if (th.getMinorVersion() &gt;= TAG_MINOR_VAULT_LIST) // 33:17 has it</a>
<a name="ln2098">        unmarshallStringVector(th);</a>
<a name="ln2099">#endif</a>
<a name="ln2100">    unmarshall_level_vault_placements(th);</a>
<a name="ln2101">}</a>
<a name="ln2102"> </a>
<a name="ln2103">static void marshall_shop(writer &amp;th, const shop_struct&amp; shop)</a>
<a name="ln2104">{</a>
<a name="ln2105">    marshallByte(th, shop.type);</a>
<a name="ln2106">    marshallByte(th, shop.keeper_name[0]);</a>
<a name="ln2107">    marshallByte(th, shop.keeper_name[1]);</a>
<a name="ln2108">    marshallByte(th, shop.keeper_name[2]);</a>
<a name="ln2109">    marshallByte(th, shop.pos.x);</a>
<a name="ln2110">    marshallByte(th, shop.pos.y);</a>
<a name="ln2111">    marshallByte(th, shop.greed);</a>
<a name="ln2112">    marshallByte(th, shop.level);</a>
<a name="ln2113">    marshallString(th, shop.shop_name);</a>
<a name="ln2114">    marshallString(th, shop.shop_type_name);</a>
<a name="ln2115">    marshallString(th, shop.shop_suffix_name);</a>
<a name="ln2116">    _marshall_iterator(th, shop.stock.begin(), shop.stock.end(),</a>
<a name="ln2117">                       bind(marshallItem, placeholders::_1, placeholders::_2,</a>
<a name="ln2118">                            false));</a>
<a name="ln2119">}</a>
<a name="ln2120"> </a>
<a name="ln2121">static void unmarshall_shop(reader &amp;th, shop_struct&amp; shop)</a>
<a name="ln2122">{</a>
<a name="ln2123">    shop.type  = static_cast&lt;shop_type&gt;(unmarshallByte(th));</a>
<a name="ln2124">#if TAG_MAJOR_VERSION == 34</a>
<a name="ln2125">    if (shop.type == SHOP_UNASSIGNED)</a>
<a name="ln2126">        return;</a>
<a name="ln2127">    if (th.getMinorVersion() &lt; TAG_MINOR_MISC_SHOP_CHANGE</a>
<a name="ln2128">        &amp;&amp; shop.type == NUM_SHOPS)</a>
<a name="ln2129">    {</a>
<a name="ln2130">        // This was SHOP_MISCELLANY, which is now part of SHOP_EVOKABLES.</a>
<a name="ln2131">        shop.type = SHOP_EVOKABLES;</a>
<a name="ln2132">    }</a>
<a name="ln2133">#else</a>
<a name="ln2134">    ASSERT(shop.type != SHOP_UNASSIGNED);</a>
<a name="ln2135">#endif</a>
<a name="ln2136">    shop.keeper_name[0] = unmarshallUByte(th);</a>
<a name="ln2137">    shop.keeper_name[1] = unmarshallUByte(th);</a>
<a name="ln2138">    shop.keeper_name[2] = unmarshallUByte(th);</a>
<a name="ln2139">    shop.pos.x = unmarshallByte(th);</a>
<a name="ln2140">    shop.pos.y = unmarshallByte(th);</a>
<a name="ln2141">    shop.greed = unmarshallByte(th);</a>
<a name="ln2142">    shop.level = unmarshallByte(th);</a>
<a name="ln2143">    shop.shop_name = unmarshallString(th);</a>
<a name="ln2144">    shop.shop_type_name = unmarshallString(th);</a>
<a name="ln2145">    shop.shop_suffix_name = unmarshallString(th);</a>
<a name="ln2146">#if TAG_MAJOR_VERSION == 34</a>
<a name="ln2147">    if (th.getMinorVersion() &lt; TAG_MINOR_SHOP_HACK)</a>
<a name="ln2148">        shop.stock.clear();</a>
<a name="ln2149">    else</a>
<a name="ln2150">#endif</a>
<a name="ln2151">    _unmarshall_vector(th, shop.stock, [] (reader&amp; r) -&gt; item_def</a>
<a name="ln2152">                                       {</a>
<a name="ln2153">                                           item_def ret;</a>
<a name="ln2154">                                           unmarshallItem(r, ret);</a>
<a name="ln2155">                                           return ret;</a>
<a name="ln2156">                                       });</a>
<a name="ln2157">}</a>
<a name="ln2158"> </a>
<a name="ln2159">void ShopInfo::save(writer&amp; outf) const</a>
<a name="ln2160">{</a>
<a name="ln2161">    marshall_shop(outf, shop);</a>
<a name="ln2162">}</a>
<a name="ln2163"> </a>
<a name="ln2164">void ShopInfo::load(reader&amp; inf)</a>
<a name="ln2165">{</a>
<a name="ln2166">#if TAG_MAJOR_VERSION == 34</a>
<a name="ln2167">    if (inf.getMinorVersion() &lt; TAG_MINOR_SHOPINFO</a>
<a name="ln2168">        || inf.getMinorVersion() == TAG_MINOR_UNSHOPINFO)</a>
<a name="ln2169">    {</a>
<a name="ln2170">        shop.type = static_cast&lt;shop_type&gt;(unmarshallShort(inf));</a>
<a name="ln2171"> </a>
<a name="ln2172">        shop.pos.x = unmarshallShort(inf);</a>
<a name="ln2173">        shop.pos.x &amp;= 0xFF;</a>
<a name="ln2174"> </a>
<a name="ln2175">        shop.pos.y = unmarshallShort(inf);</a>
<a name="ln2176"> </a>
<a name="ln2177">        int itemcount = unmarshallShort(inf);</a>
<a name="ln2178"> </a>
<a name="ln2179">        // xref hack in shopping.cc:shop_name()</a>
<a name="ln2180">        shop.shop_name = &quot; &quot;;</a>
<a name="ln2181">        unmarshallString4(inf, shop.shop_type_name);</a>
<a name="ln2182">        for (int i = 0; i &lt; itemcount; ++i)</a>
<a name="ln2183">        {</a>
<a name="ln2184">            shop.stock.emplace_back();</a>
<a name="ln2185">            unmarshallItem(inf, shop.stock.back());</a>
<a name="ln2186">            int cost = unmarshallShort(inf);</a>
<a name="ln2187">            shop.greed = cost * 10 / item_value(shop.stock.back(),</a>
<a name="ln2188">                shoptype_identifies_stock(shop.type));</a>
<a name="ln2189">        }</a>
<a name="ln2190">    }</a>
<a name="ln2191">    else</a>
<a name="ln2192">#endif</a>
<a name="ln2193">    unmarshall_shop(inf, shop);</a>
<a name="ln2194">}</a>
<a name="ln2195"> </a>
<a name="ln2196">static void _tag_construct_lost_monsters(writer &amp;th)</a>
<a name="ln2197">{</a>
<a name="ln2198">    marshallMap(th, the_lost_ones, marshall_level_id,</a>
<a name="ln2199">                 marshall_follower_list);</a>
<a name="ln2200">}</a>
<a name="ln2201"> </a>
<a name="ln2202">static void _tag_construct_companions(writer &amp;th)</a>
<a name="ln2203">{</a>
<a name="ln2204">#if TAG_MAJOR_VERSION == 34</a>
<a name="ln2205">    fixup_bad_companions();</a>
<a name="ln2206">#endif</a>
<a name="ln2207">    marshallMap(th, companion_list, _marshall_as_int&lt;mid_t&gt;,</a>
<a name="ln2208">                 marshall_companion);</a>
<a name="ln2209">}</a>
<a name="ln2210"> </a>
<a name="ln2211">// Save versions 30-32.26 are readable but don't store the names.</a>
<a name="ln2212">static const char* old_species[]=</a>
<a name="ln2213">{</a>
<a name="ln2214">    &quot;Human&quot;, &quot;High Elf&quot;, &quot;Deep Elf&quot;, &quot;Sludge Elf&quot;, &quot;Mountain Dwarf&quot;, &quot;Halfling&quot;,</a>
<a name="ln2215">    &quot;Hill Orc&quot;, &quot;Kobold&quot;, &quot;Mummy&quot;, &quot;Naga&quot;, &quot;Ogre&quot;, &quot;Troll&quot;,</a>
<a name="ln2216">    &quot;Red Draconian&quot;, &quot;White Draconian&quot;, &quot;Green Draconian&quot;, &quot;Yellow Draconian&quot;,</a>
<a name="ln2217">    &quot;Grey Draconian&quot;, &quot;Black Draconian&quot;, &quot;Purple Draconian&quot;, &quot;Mottled Draconian&quot;,</a>
<a name="ln2218">    &quot;Pale Draconian&quot;, &quot;Draconian&quot;, &quot;Centaur&quot;, &quot;Demigod&quot;, &quot;Spriggan&quot;, &quot;Minotaur&quot;,</a>
<a name="ln2219">    &quot;Demonspawn&quot;, &quot;Ghoul&quot;, &quot;Tengu&quot;, &quot;Merfolk&quot;, &quot;Vampire&quot;, &quot;Deep Dwarf&quot;, &quot;Felid&quot;,</a>
<a name="ln2220">    &quot;Octopode&quot;,</a>
<a name="ln2221">};</a>
<a name="ln2222"> </a>
<a name="ln2223">static const char* old_gods[]=</a>
<a name="ln2224">{</a>
<a name="ln2225">    &quot;&quot;, &quot;Zin&quot;, &quot;The Shining One&quot;, &quot;Kikubaaqudgha&quot;, &quot;Yredelemnul&quot;, &quot;Xom&quot;,</a>
<a name="ln2226">    &quot;Vehumet&quot;, &quot;Okawaru&quot;, &quot;Makhleb&quot;, &quot;Sif Muna&quot;, &quot;Trog&quot;, &quot;Nemelex Xobeh&quot;,</a>
<a name="ln2227">    &quot;Elyvilon&quot;, &quot;Lugonu&quot;, &quot;Beogh&quot;, &quot;Jiyva&quot;, &quot;Fedhas&quot;, &quot;Cheibriados&quot;,</a>
<a name="ln2228">    &quot;Ashenzari&quot;,</a>
<a name="ln2229">};</a>
<a name="ln2230"> </a>
<a name="ln2231">void tag_read_char(reader &amp;th, uint8_t /*format*/, uint8_t major, uint8_t minor)</a>
<a name="ln2232">{</a>
<a name="ln2233">    // Important: values out of bounds are good here, the save browser needs to</a>
<a name="ln2234">    // be forward-compatible. We validate them only on an actual restore.</a>
<a name="ln2235">    you.your_name         = unmarshallString2(th);</a>
<a name="ln2236">    you.prev_save_version = unmarshallString2(th);</a>
<a name="ln2237">    dprf(&quot;Saved character %s, version: %s&quot;, you.your_name.c_str(),</a>
<a name="ln2238">                                            you.prev_save_version.c_str());</a>
<a name="ln2239"> </a>
<a name="ln2240">    you.species           = static_cast&lt;species_type&gt;(unmarshallUByte(th));</a>
<a name="ln2241">    you.char_class        = static_cast&lt;job_type&gt;(unmarshallUByte(th));</a>
<a name="ln2242">    you.experience_level  = unmarshallByte(th);</a>
<a name="ln2243">    you.chr_class_name    = unmarshallString2(th);</a>
<a name="ln2244">    you.religion          = static_cast&lt;god_type&gt;(unmarshallUByte(th));</a>
<a name="ln2245">    you.jiyva_second_name = unmarshallString2(th);</a>
<a name="ln2246"> </a>
<a name="ln2247">    you.wizard            = unmarshallBoolean(th);</a>
<a name="ln2248"> </a>
<a name="ln2249">    // this was mistakenly inserted in the middle for a few tag versions - this</a>
<a name="ln2250">    // just makes sure that games generated in that time period are still</a>
<a name="ln2251">    // readable, but should not be used for new games</a>
<a name="ln2252">#if TAG_CHR_FORMAT == 0</a>
<a name="ln2253">    // TAG_MINOR_EXPLORE_MODE and TAG_MINOR_FIX_EXPLORE_MODE</a>
<a name="ln2254">    if (major == 34 &amp;&amp; (minor &gt;= 121 &amp;&amp; minor &lt; 130))</a>
<a name="ln2255">        you.explore = unmarshallBoolean(th);</a>
<a name="ln2256">#endif</a>
<a name="ln2257"> </a>
<a name="ln2258">    crawl_state.type = (game_type) unmarshallUByte(th);</a>
<a name="ln2259">    // normalize invalid game types so they can be treated uniformly elsewhere</a>
<a name="ln2260">    if (crawl_state.type &gt; NUM_GAME_TYPE)</a>
<a name="ln2261">        crawl_state.type = NUM_GAME_TYPE;</a>
<a name="ln2262"> </a>
<a name="ln2263">    // prevent an ASSERT in game_is_tutorial on game types from the future</a>
<a name="ln2264">    if (crawl_state.game_is_valid_type() &amp;&amp; crawl_state.game_is_tutorial())</a>
<a name="ln2265">        crawl_state.map = unmarshallString2(th);</a>
<a name="ln2266">    else</a>
<a name="ln2267">        crawl_state.map = &quot;&quot;;</a>
<a name="ln2268"> </a>
<a name="ln2269">    if (major &gt; 32 || major == 32 &amp;&amp; minor &gt; 26)</a>
<a name="ln2270">    {</a>
<a name="ln2271">        you.chr_species_name = unmarshallString2(th);</a>
<a name="ln2272">        you.chr_god_name     = unmarshallString2(th);</a>
<a name="ln2273">    }</a>
<a name="ln2274">    else</a>
<a name="ln2275">    {</a>
<a name="ln2276">        if (you.species &gt;= 0 &amp;&amp; you.species &lt; (int)ARRAYSZ(old_species))</a>
<a name="ln2277">            you.chr_species_name = old_species[you.species];</a>
<a name="ln2278">        else</a>
<a name="ln2279">            you.chr_species_name = &quot;Yak&quot;;</a>
<a name="ln2280">        if (you.religion &gt;= 0 &amp;&amp; you.religion &lt; (int)ARRAYSZ(old_gods))</a>
<a name="ln2281">            you.chr_god_name = old_gods[you.religion];</a>
<a name="ln2282">        else</a>
<a name="ln2283">            you.chr_god_name = &quot;Marduk&quot;;</a>
<a name="ln2284">    }</a>
<a name="ln2285"> </a>
<a name="ln2286">    if (major &gt; 34 || major == 34 &amp;&amp; minor &gt;= 29)</a>
<a name="ln2287">        crawl_state.map = unmarshallString2(th);</a>
<a name="ln2288"> </a>
<a name="ln2289">    if (major &gt; 34 || major == 34 &amp;&amp; minor &gt;= 130)</a>
<a name="ln2290">        you.explore = unmarshallBoolean(th);</a>
<a name="ln2291">}</a>
<a name="ln2292"> </a>
<a name="ln2293">#if TAG_MAJOR_VERSION == 34</a>
<a name="ln2294">static void _cap_mutation_at(mutation_type mut, int cap)</a>
<a name="ln2295">{</a>
<a name="ln2296">    if (you.mutation[mut] &gt; cap)</a>
<a name="ln2297">    {</a>
<a name="ln2298">        // Don't convert real mutation levels to temporary.</a>
<a name="ln2299">        int real_levels = you.get_base_mutation_level(mut, true, false, true);</a>
<a name="ln2300">        you.temp_mutation[mut] = max(cap - real_levels, 0);</a>
<a name="ln2301"> </a>
<a name="ln2302">        you.mutation[mut] = cap;</a>
<a name="ln2303">    }</a>
<a name="ln2304">    if (you.innate_mutation[mut] &gt; cap)</a>
<a name="ln2305">        you.innate_mutation[mut] = cap;</a>
<a name="ln2306">}</a>
<a name="ln2307"> </a>
<a name="ln2308">static spell_type _fixup_positional_player_spell(spell_type s)</a>
<a name="ln2309">{</a>
<a name="ln2310">    switch (s)</a>
<a name="ln2311">    {</a>
<a name="ln2312">        case SPELL_FORCE_LANCE:</a>
<a name="ln2313">        case SPELL_VENOM_BOLT:</a>
<a name="ln2314">        case SPELL_POISON_ARROW:</a>
<a name="ln2315">        case SPELL_BOLT_OF_COLD:</a>
<a name="ln2316">        case SPELL_BOLT_OF_DRAINING:</a>
<a name="ln2317">        case SPELL_THROW_FLAME:</a>
<a name="ln2318">        case SPELL_THROW_FROST:</a>
<a name="ln2319">            return SPELL_NO_SPELL;</a>
<a name="ln2320"> </a>
<a name="ln2321">        case SPELL_FLAME_TONGUE:</a>
<a name="ln2322">            return SPELL_FOXFIRE;</a>
<a name="ln2323"> </a>
<a name="ln2324">        case SPELL_THROW_ICICLE:</a>
<a name="ln2325">            return SPELL_HAILSTORM;</a>
<a name="ln2326"> </a>
<a name="ln2327">        case SPELL_BOLT_OF_FIRE:</a>
<a name="ln2328">            return SPELL_STARBURST;</a>
<a name="ln2329"> </a>
<a name="ln2330">        case SPELL_CONFUSE:</a>
<a name="ln2331">            return SPELL_CONFUSING_TOUCH;</a>
<a name="ln2332"> </a>
<a name="ln2333">        default:</a>
<a name="ln2334">            return s;</a>
<a name="ln2335">    }</a>
<a name="ln2336">}</a>
<a name="ln2337"> </a>
<a name="ln2338">static spell_type _fixup_positional_monster_spell(spell_type s)</a>
<a name="ln2339">{</a>
<a name="ln2340">    switch (s)</a>
<a name="ln2341">    {</a>
<a name="ln2342">        case SPELL_DAZZLING_FLASH:</a>
<a name="ln2343">        case SPELL_INNER_FLAME:</a>
<a name="ln2344">        case SPELL_CONJURE_FLAME:</a>
<a name="ln2345">            return SPELL_NO_SPELL;</a>
<a name="ln2346"> </a>
<a name="ln2347">        case SPELL_ISKENDERUNS_MYSTIC_BLAST:</a>
<a name="ln2348">            return SPELL_FORCE_LANCE;</a>
<a name="ln2349"> </a>
<a name="ln2350">        case SPELL_AGONY:</a>
<a name="ln2351">            return SPELL_AGONY_RANGE;</a>
<a name="ln2352"> </a>
<a name="ln2353">        case SPELL_DISPEL_UNDEAD:</a>
<a name="ln2354">            return SPELL_DISPEL_UNDEAD_RANGE;</a>
<a name="ln2355"> </a>
<a name="ln2356">        default:</a>
<a name="ln2357">            return s;</a>
<a name="ln2358">    }</a>
<a name="ln2359">}</a>
<a name="ln2360"> </a>
<a name="ln2361">static void _fixup_library_spells(FixedBitVector&lt;NUM_SPELLS&gt;&amp; lib)</a>
<a name="ln2362">{</a>
<a name="ln2363">    for (int i = 0; i &lt; NUM_SPELLS; ++i)</a>
<a name="ln2364">    {</a>
<a name="ln2365">        spell_type newspell = _fixup_positional_player_spell((spell_type) i);</a>
<a name="ln2366"> </a>
<a name="ln2367">        if (newspell == SPELL_NO_SPELL)</a>
<a name="ln2368">            lib.set(i, false);</a>
<a name="ln2369">        else if (newspell != (spell_type) i)</a>
<a name="ln2370">        {</a>
<a name="ln2371">            lib.set(newspell, lib[i]);</a>
<a name="ln2372">            lib.set(i, false);</a>
<a name="ln2373">        }</a>
<a name="ln2374">    }</a>
<a name="ln2375">}</a>
<a name="ln2376">#endif</a>
<a name="ln2377"> </a>
<a name="ln2378">void unmarshall_vehumet_spells(reader &amp;th, set&lt;spell_type&gt;&amp; old_gifts,</a>
<a name="ln2379">        set&lt;spell_type&gt;&amp; gifts)</a>
<a name="ln2380">{</a>
<a name="ln2381">#if TAG_MAJOR_VERSION == 34</a>
<a name="ln2382">    if (th.getMinorVersion() &gt;= TAG_MINOR_VEHUMET_SPELL_GIFT</a>
<a name="ln2383">        &amp;&amp; th.getMinorVersion() != TAG_MINOR_0_11)</a>
<a name="ln2384">    {</a>
<a name="ln2385">#endif</a>
<a name="ln2386">        const auto num_old_gifts = unmarshallUByte(th);</a>
<a name="ln2387">        for (int i = 0; i &lt; num_old_gifts; ++i)</a>
<a name="ln2388">        {</a>
<a name="ln2389">            const auto spell = unmarshallSpellType(th);</a>
<a name="ln2390">            if (!spell_removed(spell))</a>
<a name="ln2391">                old_gifts.insert(spell);</a>
<a name="ln2392">        }</a>
<a name="ln2393"> </a>
<a name="ln2394">#if TAG_MAJOR_VERSION == 34</a>
<a name="ln2395">        if (th.getMinorVersion() &lt; TAG_MINOR_VEHUMET_MULTI_GIFTS)</a>
<a name="ln2396">        {</a>
<a name="ln2397">            const auto spell = unmarshallSpellType(th);</a>
<a name="ln2398">            if (!spell_removed(spell))</a>
<a name="ln2399">                gifts.insert(spell);</a>
<a name="ln2400">        }</a>
<a name="ln2401">        else</a>
<a name="ln2402">        {</a>
<a name="ln2403">#endif</a>
<a name="ln2404">            const auto num_gifts = unmarshallUByte(th);</a>
<a name="ln2405">            for (int i = 0; i &lt; num_gifts; ++i)</a>
<a name="ln2406">            {</a>
<a name="ln2407">                const auto spell = unmarshallSpellType(th);</a>
<a name="ln2408">                if (!spell_removed(spell))</a>
<a name="ln2409">                    gifts.insert(spell);</a>
<a name="ln2410">            }</a>
<a name="ln2411">#if TAG_MAJOR_VERSION == 34</a>
<a name="ln2412">        }</a>
<a name="ln2413">    }</a>
<a name="ln2414">#endif</a>
<a name="ln2415">}</a>
<a name="ln2416"> </a>
<a name="ln2417">FixedVector&lt;spell_type, MAX_KNOWN_SPELLS&gt; unmarshall_player_spells(reader &amp;th)</a>
<a name="ln2418">{</a>
<a name="ln2419">    FixedVector&lt;spell_type, MAX_KNOWN_SPELLS&gt; spells(SPELL_NO_SPELL);</a>
<a name="ln2420"> </a>
<a name="ln2421">    const auto count = unmarshallUByte(th);</a>
<a name="ln2422">    ASSERT(count &gt;= 0);</a>
<a name="ln2423"> </a>
<a name="ln2424">    for (int i = 0; i &lt; count &amp;&amp; i &lt; MAX_KNOWN_SPELLS; ++i)</a>
<a name="ln2425">    {</a>
<a name="ln2426">        spells[i] = unmarshallSpellType(th);</a>
<a name="ln2427">#if TAG_MAJOR_VERSION == 34</a>
<a name="ln2428">        spells[i] = _fixup_positional_player_spell(spells[i]);</a>
<a name="ln2429">#endif</a>
<a name="ln2430">        if (spell_removed(spells[i]))</a>
<a name="ln2431">            spells[i] = SPELL_NO_SPELL;</a>
<a name="ln2432">    }</a>
<a name="ln2433"> </a>
<a name="ln2434">    for (int i = MAX_KNOWN_SPELLS; i &lt; count; ++i)</a>
<a name="ln2435">        unmarshallSpellType(th);</a>
<a name="ln2436"> </a>
<a name="ln2437">    return spells;</a>
<a name="ln2438">}</a>
<a name="ln2439"> </a>
<a name="ln2440">FixedVector&lt;int, 52&gt; unmarshall_player_spell_letter_table(reader &amp;th)</a>
<a name="ln2441">{</a>
<a name="ln2442">    FixedVector&lt;int, 52&gt; spell_letter_table;</a>
<a name="ln2443"> </a>
<a name="ln2444">    const auto count = unmarshallByte(th);</a>
<a name="ln2445">    ASSERT(count == (int)spell_letter_table.size());</a>
<a name="ln2446"> </a>
<a name="ln2447">    for (int i = 0; i &lt; count; i++)</a>
<a name="ln2448">    {</a>
<a name="ln2449">        int s = unmarshallByte(th);</a>
<a name="ln2450">        ASSERT_RANGE(s, -1, MAX_KNOWN_SPELLS);</a>
<a name="ln2451">        spell_letter_table[i] = s;</a>
<a name="ln2452">    }</a>
<a name="ln2453"> </a>
<a name="ln2454">    return spell_letter_table;</a>
<a name="ln2455">}</a>
<a name="ln2456"> </a>
<a name="ln2457"> </a>
<a name="ln2458">void remove_removed_library_spells(FixedBitVector&lt;NUM_SPELLS&gt;&amp; lib)</a>
<a name="ln2459">{</a>
<a name="ln2460">    for (int i = 0; i &lt; NUM_SPELLS; ++i)</a>
<a name="ln2461">        lib.set(i, lib[i] &amp;&amp; !spell_removed(static_cast&lt;spell_type&gt;(i)));</a>
<a name="ln2462">}</a>
<a name="ln2463"> </a>
<a name="ln2464">static void _tag_read_you(reader &amp;th)</a>
<a name="ln2465">{</a>
<a name="ln2466">    int count;</a>
<a name="ln2467"> </a>
<a name="ln2468">    ASSERT(species_type_valid(you.species));</a>
<a name="ln2469">    ASSERT(job_type_valid(you.char_class));</a>
<a name="ln2470">    ASSERT_RANGE(you.experience_level, 1, 28);</a>
<a name="ln2471">    ASSERT(you.religion &lt; NUM_GODS);</a>
<a name="ln2472">    ASSERT_RANGE(crawl_state.type, GAME_TYPE_UNSPECIFIED + 1, NUM_GAME_TYPE);</a>
<a name="ln2473">    you.last_mid          = unmarshallInt(th);</a>
<a name="ln2474">    you.piety             = unmarshallUByte(th);</a>
<a name="ln2475">    ASSERT(you.piety &lt;= MAX_PIETY);</a>
<a name="ln2476">#if TAG_MAJOR_VERSION == 34</a>
<a name="ln2477">    if (th.getMinorVersion() &lt; TAG_MINOR_ROTTING)</a>
<a name="ln2478">        unmarshallUByte(th);</a>
<a name="ln2479">#endif</a>
<a name="ln2480">    you.pet_target        = unmarshallShort(th);</a>
<a name="ln2481"> </a>
<a name="ln2482">    you.max_level         = unmarshallByte(th);</a>
<a name="ln2483">    you.where_are_you     = static_cast&lt;branch_type&gt;(unmarshallUByte(th));</a>
<a name="ln2484">    ASSERT(you.where_are_you &lt; NUM_BRANCHES);</a>
<a name="ln2485">    you.depth             = unmarshallByte(th);</a>
<a name="ln2486">    ASSERT(you.depth &gt; 0);</a>
<a name="ln2487">    you.chapter           = static_cast&lt;game_chapter&gt;(unmarshallUByte(th));</a>
<a name="ln2488">    ASSERT(you.chapter &lt; NUM_CHAPTERS);</a>
<a name="ln2489"> </a>
<a name="ln2490">#if TAG_MAJOR_VERSION == 34</a>
<a name="ln2491">    if (th.getMinorVersion() &lt; TAG_MINOR_ZOT_OPEN)</a>
<a name="ln2492">        unmarshallBoolean(th);</a>
<a name="ln2493">#endif</a>
<a name="ln2494">    you.royal_jelly_dead = unmarshallBoolean(th);</a>
<a name="ln2495">    you.transform_uncancellable = unmarshallBoolean(th);</a>
<a name="ln2496"> </a>
<a name="ln2497">#if TAG_MAJOR_VERSION == 34</a>
<a name="ln2498">    if (th.getMinorVersion() &lt; TAG_MINOR_IS_UNDEAD)</a>
<a name="ln2499">        unmarshallUByte(th);</a>
<a name="ln2500">    if (th.getMinorVersion() &lt; TAG_MINOR_CALC_UNRAND_REACTS)</a>
<a name="ln2501">        unmarshallShort(th);</a>
<a name="ln2502">#endif</a>
<a name="ln2503">    you.berserk_penalty   = unmarshallByte(th);</a>
<a name="ln2504">#if TAG_MAJOR_VERSION == 34</a>
<a name="ln2505">    if (th.getMinorVersion() &gt;= TAG_MINOR_GARGOYLE_DR</a>
<a name="ln2506">      &amp;&amp; th.getMinorVersion() &lt; TAG_MINOR_RM_GARGOYLE_DR)</a>
<a name="ln2507">    {</a>
<a name="ln2508">        unmarshallInt(th); // Slough an integer.</a>
<a name="ln2509">    }</a>
<a name="ln2510"> </a>
<a name="ln2511">    if (th.getMinorVersion() &lt; TAG_MINOR_AUTOMATIC_MANUALS)</a>
<a name="ln2512">    {</a>
<a name="ln2513">        unmarshallShort(th);</a>
<a name="ln2514">        unmarshallInt(th);</a>
<a name="ln2515">    }</a>
<a name="ln2516">#endif</a>
<a name="ln2517"> </a>
<a name="ln2518">    you.abyss_speed = unmarshallInt(th);</a>
<a name="ln2519"> </a>
<a name="ln2520">    you.disease         = unmarshallInt(th);</a>
<a name="ln2521">    you.hp              = unmarshallShort(th);</a>
<a name="ln2522">    you.hunger          = unmarshallShort(th);</a>
<a name="ln2523">    you.fishtail        = unmarshallBoolean(th);</a>
<a name="ln2524">#if TAG_MAJOR_VERSION == 34</a>
<a name="ln2525">    if (th.getMinorVersion() &gt;= TAG_MINOR_VAMPIRE_NO_EAT)</a>
<a name="ln2526">        you.vampire_alive = unmarshallBoolean(th);</a>
<a name="ln2527">    else</a>
<a name="ln2528">        you.vampire_alive = calc_hunger_state() &gt; HS_STARVING;</a>
<a name="ln2529">#else</a>
<a name="ln2530">    you.vampire_alive   = unmarshallBoolean(th);</a>
<a name="ln2531">#endif</a>
<a name="ln2532">#if TAG_MAJOR_VERSION == 34</a>
<a name="ln2533">    if (th.getMinorVersion() &lt; TAG_MINOR_NOME_NO_MORE)</a>
<a name="ln2534">        unmarshallInt(th);</a>
<a name="ln2535">#endif</a>
<a name="ln2536">    you.form            = unmarshall_int_as&lt;transformation&gt;(th);</a>
<a name="ln2537">    ASSERT_RANGE(static_cast&lt;int&gt;(you.form), 0, NUM_TRANSFORMS);</a>
<a name="ln2538">#if TAG_MAJOR_VERSION == 34</a>
<a name="ln2539">    // Fix the effects of #7668 (Vampire lose undead trait once coming back</a>
<a name="ln2540">    // from lich form).</a>
<a name="ln2541">    if (you.form == transformation::none)</a>
<a name="ln2542">        you.transform_uncancellable = false;</a>
<a name="ln2543">#else</a>
<a name="ln2544">    ASSERT(you.form != transformation::none || !you.transform_uncancellable);</a>
<a name="ln2545">#endif</a>
<a name="ln2546">    EAT_CANARY;</a>
<a name="ln2547"> </a>
<a name="ln2548">#if TAG_MAJOR_VERSION == 34</a>
<a name="ln2549">    if (th.getMinorVersion() &lt; TAG_MINOR_SAGE_REMOVAL)</a>
<a name="ln2550">    {</a>
<a name="ln2551">        count = unmarshallShort(th);</a>
<a name="ln2552">        ASSERT_RANGE(count, 0, 32768);</a>
<a name="ln2553">        for (int i = 0; i &lt; count; ++i)</a>
<a name="ln2554">        {</a>
<a name="ln2555">            unmarshallByte(th);</a>
<a name="ln2556">            unmarshallInt(th);</a>
<a name="ln2557">            unmarshallInt(th);</a>
<a name="ln2558">        }</a>
<a name="ln2559">    }</a>
<a name="ln2560">#endif</a>
<a name="ln2561"> </a>
<a name="ln2562">    // How many you.equip?</a>
<a name="ln2563">    count = unmarshallByte(th);</a>
<a name="ln2564">    ASSERT(count &lt;= NUM_EQUIP);</a>
<a name="ln2565">    for (int i = EQ_FIRST_EQUIP; i &lt; count; ++i)</a>
<a name="ln2566">    {</a>
<a name="ln2567">        you.equip[i] = unmarshallByte(th);</a>
<a name="ln2568">        ASSERT_RANGE(you.equip[i], -1, ENDOFPACK);</a>
<a name="ln2569">    }</a>
<a name="ln2570">    for (int i = count; i &lt; NUM_EQUIP; ++i)</a>
<a name="ln2571">        you.equip[i] = -1;</a>
<a name="ln2572">    for (int i = 0; i &lt; count; ++i)</a>
<a name="ln2573">        you.melded.set(i, unmarshallBoolean(th));</a>
<a name="ln2574">    for (int i = count; i &lt; NUM_EQUIP; ++i)</a>
<a name="ln2575">        you.melded.set(i, false);</a>
<a name="ln2576">#if TAG_MAJOR_VERSION == 34</a>
<a name="ln2577">    if (th.getMinorVersion() &gt;= TAG_MINOR_TRACK_REGEN_ITEMS)</a>
<a name="ln2578">    {</a>
<a name="ln2579">#endif</a>
<a name="ln2580">        for (int i = 0; i &lt; count; ++i)</a>
<a name="ln2581">            you.activated.set(i, unmarshallBoolean(th));</a>
<a name="ln2582">        for (int i = count; i &lt; NUM_EQUIP; ++i)</a>
<a name="ln2583">            you.activated.set(i, false);</a>
<a name="ln2584">#if TAG_MAJOR_VERSION == 34</a>
<a name="ln2585">    }</a>
<a name="ln2586">#endif</a>
<a name="ln2587"> </a>
<a name="ln2588">    you.magic_points              = unmarshallUByte(th);</a>
<a name="ln2589">    you.max_magic_points          = unmarshallByte(th);</a>
<a name="ln2590"> </a>
<a name="ln2591">    for (int i = 0; i &lt; NUM_STATS; ++i)</a>
<a name="ln2592">        you.base_stats[i] = unmarshallByte(th);</a>
<a name="ln2593">#if TAG_MAJOR_VERSION == 34</a>
<a name="ln2594">    // Gnolls previously had stats fixed at 7/7/7, so randomly award them stats</a>
<a name="ln2595">    // based on the points they'd have gotten from XL/3 selection and XL/4</a>
<a name="ln2596">    // random SID.</a>
<a name="ln2597">    if (th.getMinorVersion() &gt;= TAG_MINOR_STATLOCKED_GNOLLS</a>
<a name="ln2598">        &amp;&amp; th.getMinorVersion() &lt; TAG_MINOR_GNOLLS_REDUX</a>
<a name="ln2599">        &amp;&amp; you.species == SP_GNOLL)</a>
<a name="ln2600">    {</a>
<a name="ln2601">        const species_def&amp; sd = get_species_def(you.species);</a>
<a name="ln2602"> </a>
<a name="ln2603">        // Give base stat points.</a>
<a name="ln2604">        species_stat_init(you.species);</a>
<a name="ln2605"> </a>
<a name="ln2606">        const set&lt;stat_type&gt; all_stats = {STAT_STR, STAT_INT, STAT_DEX};</a>
<a name="ln2607">        int num_points = you.experience_level / 3;</a>
<a name="ln2608">        for (int i = 0; i &lt; num_points; ++i)</a>
<a name="ln2609">            modify_stat(*random_iterator(all_stats), 1, false);</a>
<a name="ln2610"> </a>
<a name="ln2611">        num_points = you.experience_level / sd.how_often;</a>
<a name="ln2612">        for (int i = 0; i &lt; num_points; ++i)</a>
<a name="ln2613">            modify_stat(*random_iterator(sd.level_stats), 1, false);</a>
<a name="ln2614">    }</a>
<a name="ln2615">#endif</a>
<a name="ln2616"> </a>
<a name="ln2617">    for (int i = 0; i &lt; NUM_STATS; ++i)</a>
<a name="ln2618">        you.stat_loss[i] = unmarshallByte(th);</a>
<a name="ln2619"> </a>
<a name="ln2620">#if TAG_MAJOR_VERSION == 34</a>
<a name="ln2621">    if (th.getMinorVersion() &lt; TAG_MINOR_STAT_ZERO_DURATION)</a>
<a name="ln2622">    {</a>
<a name="ln2623">        for (int i = 0; i &lt; NUM_STATS; ++i)</a>
<a name="ln2624">            unmarshallUByte(th);</a>
<a name="ln2625">    }</a>
<a name="ln2626">    if (th.getMinorVersion() &lt; TAG_MINOR_STAT_ZERO)</a>
<a name="ln2627">    {</a>
<a name="ln2628">        for (int i = 0; i &lt; NUM_STATS; ++i)</a>
<a name="ln2629">            unmarshallString(th);</a>
<a name="ln2630">    }</a>
<a name="ln2631">#endif</a>
<a name="ln2632">    EAT_CANARY;</a>
<a name="ln2633"> </a>
<a name="ln2634">#if TAG_MAJOR_VERSION == 34</a>
<a name="ln2635">    if (th.getMinorVersion() &lt; TAG_MINOR_INT_REGEN)</a>
<a name="ln2636">    {</a>
<a name="ln2637">        you.hit_points_regeneration   = unmarshallByte(th);</a>
<a name="ln2638">        you.magic_points_regeneration = unmarshallByte(th);</a>
<a name="ln2639">        unmarshallShort(th);</a>
<a name="ln2640">    }</a>
<a name="ln2641">    else</a>
<a name="ln2642">    {</a>
<a name="ln2643">#endif</a>
<a name="ln2644">    you.hit_points_regeneration   = unmarshallInt(th);</a>
<a name="ln2645">    you.magic_points_regeneration = unmarshallInt(th);</a>
<a name="ln2646">#if TAG_MAJOR_VERSION == 34</a>
<a name="ln2647">    }</a>
<a name="ln2648">#endif</a>
<a name="ln2649"> </a>
<a name="ln2650">    you.experience                = unmarshallInt(th);</a>
<a name="ln2651">    you.total_experience = unmarshallInt(th);</a>
<a name="ln2652">    you.gold                      = unmarshallInt(th);</a>
<a name="ln2653">    you.exp_available             = unmarshallInt(th);</a>
<a name="ln2654">#if TAG_MAJOR_VERSION == 34</a>
<a name="ln2655">    if (th.getMinorVersion() &lt; TAG_MINOR_XP_SCALING)</a>
<a name="ln2656">    {</a>
<a name="ln2657">        you.total_experience *= 10;</a>
<a name="ln2658">        you.exp_available *= 10;</a>
<a name="ln2659">    }</a>
<a name="ln2660">    if (th.getMinorVersion() &lt; TAG_MINOR_NO_ZOTDEF)</a>
<a name="ln2661">        unmarshallInt(th);</a>
<a name="ln2662">#endif</a>
<a name="ln2663">    you.zigs_completed            = unmarshallInt(th);</a>
<a name="ln2664">    you.zig_max                   = unmarshallByte(th);</a>
<a name="ln2665">#if TAG_MAJOR_VERSION == 34</a>
<a name="ln2666">    if (th.getMinorVersion() &lt; TAG_MINOR_TRACK_BANISHER)</a>
<a name="ln2667">        you.banished_by = &quot;&quot;;</a>
<a name="ln2668">    else</a>
<a name="ln2669">#endif</a>
<a name="ln2670">        you.banished_by           = unmarshallString(th);</a>
<a name="ln2671"> </a>
<a name="ln2672">    you.hp_max_adj_temp           = unmarshallShort(th);</a>
<a name="ln2673">    you.hp_max_adj_perm           = unmarshallShort(th);</a>
<a name="ln2674">    you.mp_max_adj                = unmarshallShort(th);</a>
<a name="ln2675">#if TAG_MAJOR_VERSION == 34</a>
<a name="ln2676">    if (th.getMinorVersion() &lt; TAG_MINOR_REMOVE_BASE_MP)</a>
<a name="ln2677">    {</a>
<a name="ln2678">        int baseadj = unmarshallShort(th);</a>
<a name="ln2679">        you.mp_max_adj += baseadj;</a>
<a name="ln2680">    }</a>
<a name="ln2681">    if (th.getMinorVersion() &lt; TAG_MINOR_CLASS_HP_0)</a>
<a name="ln2682">        you.hp_max_adj_perm -= 8;</a>
<a name="ln2683">#endif</a>
<a name="ln2684"> </a>
<a name="ln2685">    const int x = unmarshallShort(th);</a>
<a name="ln2686">    const int y = unmarshallShort(th);</a>
<a name="ln2687">    // SIGHUP during Step from Time/etc is ok.</a>
<a name="ln2688">    ASSERT(!x &amp;&amp; !y || in_bounds(x, y));</a>
<a name="ln2689">    you.moveto(coord_def(x, y));</a>
<a name="ln2690"> </a>
<a name="ln2691">#if TAG_MAJOR_VERSION == 34</a>
<a name="ln2692">    if (th.getMinorVersion() &lt; TAG_MINOR_WEIGHTLESS)</a>
<a name="ln2693">        unmarshallShort(th);</a>
<a name="ln2694">#endif</a>
<a name="ln2695"> </a>
<a name="ln2696">#if TAG_MAJOR_VERSION == 34</a>
<a name="ln2697">    if (th.getMinorVersion() &gt;= TAG_MINOR_GOLDIFY_BOOKS)</a>
<a name="ln2698">    {</a>
<a name="ln2699">#endif</a>
<a name="ln2700">    _unmarshallFixedBitVector&lt;NUM_SPELLS&gt;(th, you.spell_library);</a>
<a name="ln2701">    _unmarshallFixedBitVector&lt;NUM_SPELLS&gt;(th, you.hidden_spells);</a>
<a name="ln2702">#if TAG_MAJOR_VERSION == 34</a>
<a name="ln2703">        if (th.getMinorVersion() &lt; TAG_MINOR_POSITIONAL_MAGIC)</a>
<a name="ln2704">        {</a>
<a name="ln2705">            _fixup_library_spells(you.spell_library);</a>
<a name="ln2706">            _fixup_library_spells(you.hidden_spells);</a>
<a name="ln2707">        }</a>
<a name="ln2708">    }</a>
<a name="ln2709">#endif</a>
<a name="ln2710"> </a>
<a name="ln2711">    remove_removed_library_spells(you.spell_library);</a>
<a name="ln2712">    remove_removed_library_spells(you.hidden_spells);</a>
<a name="ln2713"> </a>
<a name="ln2714">    you.spells = unmarshall_player_spells(th);</a>
<a name="ln2715">    you.spell_letter_table = unmarshall_player_spell_letter_table(th);</a>
<a name="ln2716">    you.spell_no = count_if(begin(you.spells), end(you.spells),</a>
<a name="ln2717">            [](const spell_type spell) { return spell != SPELL_NO_SPELL; });</a>
<a name="ln2718"> </a>
<a name="ln2719">    count = unmarshallByte(th);</a>
<a name="ln2720">    ASSERT(count == (int)you.ability_letter_table.size());</a>
<a name="ln2721">#if TAG_MAJOR_VERSION == 34</a>
<a name="ln2722">    bool found_fly = false;</a>
<a name="ln2723">    bool found_stop_flying = false;</a>
<a name="ln2724">#endif</a>
<a name="ln2725">    for (int i = 0; i &lt; count; i++)</a>
<a name="ln2726">    {</a>
<a name="ln2727">        int a = unmarshallShort(th);</a>
<a name="ln2728">#if TAG_MAJOR_VERSION == 34</a>
<a name="ln2729">        if (th.getMinorVersion() &lt; TAG_MINOR_ABIL_1000)</a>
<a name="ln2730">        {</a>
<a name="ln2731">            if (a &gt;= 230)</a>
<a name="ln2732">                a += 2000 - 230;</a>
<a name="ln2733">            else if (a &gt;= 50)</a>
<a name="ln2734">                a += 1000 - 50;</a>
<a name="ln2735">        }</a>
<a name="ln2736">        if (th.getMinorVersion() &lt; TAG_MINOR_ABIL_GOD_FIXUP)</a>
<a name="ln2737">        {</a>
<a name="ln2738">            if (a &gt;= ABIL_ASHENZARI_END_TRANSFER + 1</a>
<a name="ln2739">                &amp;&amp; a &lt;= ABIL_ASHENZARI_END_TRANSFER + 3)</a>
<a name="ln2740">            {</a>
<a name="ln2741">                a += ABIL_STOP_RECALL - ABIL_ASHENZARI_END_TRANSFER - 1;</a>
<a name="ln2742">            }</a>
<a name="ln2743">        }</a>
<a name="ln2744">        if (a == ABIL_FLY</a>
<a name="ln2745">            || a == ABIL_WISP_BLINK // was ABIL_FLY_II</a>
<a name="ln2746">               &amp;&amp; th.getMinorVersion() &lt; TAG_MINOR_0_12)</a>
<a name="ln2747">        {</a>
<a name="ln2748">            if (found_fly)</a>
<a name="ln2749">                a = ABIL_NON_ABILITY;</a>
<a name="ln2750">            else</a>
<a name="ln2751">                a = ABIL_FLY;</a>
<a name="ln2752">            found_fly = true;</a>
<a name="ln2753">        }</a>
<a name="ln2754">        if (a == ABIL_EVOKE_STOP_LEVITATING</a>
<a name="ln2755">            || a == ABIL_STOP_FLYING)</a>
<a name="ln2756">        {</a>
<a name="ln2757">            if (found_stop_flying)</a>
<a name="ln2758">                a = ABIL_NON_ABILITY;</a>
<a name="ln2759">            else</a>
<a name="ln2760">                a = ABIL_STOP_FLYING;</a>
<a name="ln2761">            found_stop_flying = true;</a>
<a name="ln2762">        }</a>
<a name="ln2763"> </a>
<a name="ln2764">        if (th.getMinorVersion() &lt; TAG_MINOR_NO_JUMP)</a>
<a name="ln2765">        {</a>
<a name="ln2766">            // ABIL_JUMP deleted (ABIL_DIG has its old spot), map it</a>
<a name="ln2767">            // away and shift following intrinsic abilities down.</a>
<a name="ln2768">            // ABIL_EVOKE_JUMP was also deleted, but was the last</a>
<a name="ln2769">            // evocable ability, so just map it away.</a>
<a name="ln2770">            if (a == ABIL_DIG || a == ABIL_EVOKE_TELEPORT_CONTROL + 1)</a>
<a name="ln2771">                a = ABIL_NON_ABILITY;</a>
<a name="ln2772">            else if (a &gt; ABIL_DIG &amp;&amp; a &lt; ABIL_MIN_EVOKE)</a>
<a name="ln2773">                a -= 1;</a>
<a name="ln2774">        }</a>
<a name="ln2775"> </a>
<a name="ln2776">        if (th.getMinorVersion() &lt; TAG_MINOR_MOTTLED_REMOVAL)</a>
<a name="ln2777">        {</a>
<a name="ln2778">            if (a == ABIL_BREATHE_STICKY_FLAME)</a>
<a name="ln2779">                a = ABIL_BREATHE_FIRE;</a>
<a name="ln2780">        }</a>
<a name="ln2781"> </a>
<a name="ln2782">        // Bad offset from games transferred prior to 0.17-a0-2121-g4af814f.</a>
<a name="ln2783">        if (a == NUM_ABILITIES)</a>
<a name="ln2784">            a = ABIL_NON_ABILITY;</a>
<a name="ln2785">#endif</a>
<a name="ln2786">        ASSERT_RANGE(a, ABIL_NON_ABILITY, NUM_ABILITIES);</a>
<a name="ln2787">        ASSERT(a != 0);</a>
<a name="ln2788">        you.ability_letter_table[i] = static_cast&lt;ability_type&gt;(a);</a>
<a name="ln2789">    }</a>
<a name="ln2790"> </a>
<a name="ln2791">    unmarshall_vehumet_spells(th, you.old_vehumet_gifts, you.vehumet_gifts);</a>
<a name="ln2792">    EAT_CANARY;</a>
<a name="ln2793"> </a>
<a name="ln2794">    // how many skills?</a>
<a name="ln2795">    count = unmarshallUByte(th);</a>
<a name="ln2796">    ASSERT(count &lt;= NUM_SKILLS);</a>
<a name="ln2797">    for (int j = 0; j &lt; count; ++j)</a>
<a name="ln2798">    {</a>
<a name="ln2799">        you.skills[j]          = unmarshallUByte(th);</a>
<a name="ln2800">        ASSERT(you.skills[j] &lt;= 27 || you.wizard);</a>
<a name="ln2801"> </a>
<a name="ln2802">        you.train[j]    = (training_status)unmarshallByte(th);</a>
<a name="ln2803">        you.train_alt[j]    = (training_status)unmarshallByte(th);</a>
<a name="ln2804">#if TAG_MAJOR_VERSION == 34</a>
<a name="ln2805">        // Gnolls always train all skills.</a>
<a name="ln2806">        if (th.getMinorVersion() &lt; TAG_MINOR_GNOLLS_REDUX</a>
<a name="ln2807">            &amp;&amp; you.species == SP_GNOLL)</a>
<a name="ln2808">        {</a>
<a name="ln2809">            you.train[j] = you.train_alt[j] = TRAINING_ENABLED;</a>
<a name="ln2810">        }</a>
<a name="ln2811">#endif</a>
<a name="ln2812">        you.training[j] = unmarshallInt(th);</a>
<a name="ln2813">        you.skill_points[j]    = unmarshallInt(th);</a>
<a name="ln2814">        you.ct_skill_points[j] = unmarshallInt(th);</a>
<a name="ln2815">        you.skill_order[j]     = unmarshallByte(th);</a>
<a name="ln2816">#if TAG_MAJOR_VERSION == 34</a>
<a name="ln2817">        if (th.getMinorVersion() &gt;= TAG_MINOR_TRAINING_TARGETS)</a>
<a name="ln2818">        {</a>
<a name="ln2819">#endif</a>
<a name="ln2820">            you.training_targets[j] = unmarshallInt(th);</a>
<a name="ln2821">#if TAG_MAJOR_VERSION == 34</a>
<a name="ln2822">        }</a>
<a name="ln2823">        else</a>
<a name="ln2824">            you.training_targets[j] = 0;</a>
<a name="ln2825">#endif</a>
<a name="ln2826">    }</a>
<a name="ln2827"> </a>
<a name="ln2828">    you.auto_training = unmarshallBoolean(th);</a>
<a name="ln2829"> </a>
<a name="ln2830">    count = unmarshallByte(th);</a>
<a name="ln2831">    for (int i = 0; i &lt; count; i++)</a>
<a name="ln2832">        you.exercises.push_back((skill_type)unmarshallInt(th));</a>
<a name="ln2833"> </a>
<a name="ln2834">    count = unmarshallByte(th);</a>
<a name="ln2835">    for (int i = 0; i &lt; count; i++)</a>
<a name="ln2836">        you.exercises_all.push_back((skill_type)unmarshallInt(th));</a>
<a name="ln2837"> </a>
<a name="ln2838">    you.skill_menu_do = static_cast&lt;skill_menu_state&gt;(unmarshallByte(th));</a>
<a name="ln2839">    you.skill_menu_view = static_cast&lt;skill_menu_state&gt;(unmarshallByte(th));</a>
<a name="ln2840">    you.transfer_from_skill = static_cast&lt;skill_type&gt;(unmarshallInt(th));</a>
<a name="ln2841">    ASSERT(you.transfer_from_skill == SK_NONE || you.transfer_from_skill &lt; NUM_SKILLS);</a>
<a name="ln2842">    you.transfer_to_skill = static_cast&lt;skill_type&gt;(unmarshallInt(th));</a>
<a name="ln2843">    ASSERT(you.transfer_to_skill == SK_NONE || you.transfer_to_skill &lt; NUM_SKILLS);</a>
<a name="ln2844">    you.transfer_skill_points = unmarshallInt(th);</a>
<a name="ln2845">    you.transfer_total_skill_points = unmarshallInt(th);</a>
<a name="ln2846"> </a>
<a name="ln2847">    // Set up you.skill_cost_level.</a>
<a name="ln2848">    you.skill_cost_level = 0;</a>
<a name="ln2849">    check_skill_cost_change();</a>
<a name="ln2850"> </a>
<a name="ln2851">    EAT_CANARY;</a>
<a name="ln2852"> </a>
<a name="ln2853">    // how many durations?</a>
<a name="ln2854">    count = unmarshallUByte(th);</a>
<a name="ln2855">    COMPILE_CHECK(NUM_DURATIONS &lt; 256);</a>
<a name="ln2856">    for (int j = 0; j &lt; count &amp;&amp; j &lt; NUM_DURATIONS; ++j)</a>
<a name="ln2857">        you.duration[j] = unmarshallInt(th);</a>
<a name="ln2858">    for (int j = NUM_DURATIONS; j &lt; count; ++j)</a>
<a name="ln2859">        unmarshallInt(th);</a>
<a name="ln2860">#if TAG_MAJOR_VERSION == 34</a>
<a name="ln2861">    if (you.species == SP_LAVA_ORC)</a>
<a name="ln2862">        you.duration[DUR_MAGIC_ARMOUR] = 0;</a>
<a name="ln2863"> </a>
<a name="ln2864">    if (th.getMinorVersion() &lt; TAG_MINOR_FUNGUS_FORM</a>
<a name="ln2865">        &amp;&amp; you.form == transformation::fungus)</a>
<a name="ln2866">    {</a>
<a name="ln2867">        you.duration[DUR_CONFUSING_TOUCH] = 0;</a>
<a name="ln2868">    }</a>
<a name="ln2869"> </a>
<a name="ln2870">    you.duration[DUR_JELLY_PRAYER] = 0;</a>
<a name="ln2871">#endif</a>
<a name="ln2872"> </a>
<a name="ln2873">    // how many attributes?</a>
<a name="ln2874">    count = unmarshallUByte(th);</a>
<a name="ln2875">    COMPILE_CHECK(NUM_ATTRIBUTES &lt; 256);</a>
<a name="ln2876">    for (int j = 0; j &lt; count &amp;&amp; j &lt; NUM_ATTRIBUTES; ++j)</a>
<a name="ln2877">    {</a>
<a name="ln2878">#if TAG_MAJOR_VERSION == 34</a>
<a name="ln2879">        if (j == ATTR_BANISHMENT_IMMUNITY &amp;&amp; th.getMinorVersion() == TAG_MINOR_0_11)</a>
<a name="ln2880">        {</a>
<a name="ln2881">            unmarshallInt(th); // ATTR_UNUSED_1</a>
<a name="ln2882">            count--;</a>
<a name="ln2883">        }</a>
<a name="ln2884">        if (j == ATTR_NOISES &amp;&amp; th.getMinorVersion() == TAG_MINOR_CLASS_HP_0</a>
<a name="ln2885">            &amp;&amp; count == 40)</a>
<a name="ln2886">        {</a>
<a name="ln2887">            dprf(&quot;recovering ATTR_NOISES&quot;);</a>
<a name="ln2888">            j++, count++;</a>
<a name="ln2889">        }</a>
<a name="ln2890">#endif</a>
<a name="ln2891">        you.attribute[j] = unmarshallInt(th);</a>
<a name="ln2892">    }</a>
<a name="ln2893">#if TAG_MAJOR_VERSION == 34</a>
<a name="ln2894">    if (count == ATTR_PAKELLAS_EXTRA_MP &amp;&amp; you_worship(GOD_PAKELLAS))</a>
<a name="ln2895">        you.attribute[ATTR_PAKELLAS_EXTRA_MP] = POT_MAGIC_MP;</a>
<a name="ln2896">#endif</a>
<a name="ln2897">    for (int j = count; j &lt; NUM_ATTRIBUTES; ++j)</a>
<a name="ln2898">        you.attribute[j] = 0;</a>
<a name="ln2899">    for (int j = NUM_ATTRIBUTES; j &lt; count; ++j)</a>
<a name="ln2900">        unmarshallInt(th);</a>
<a name="ln2901"> </a>
<a name="ln2902">#if TAG_MAJOR_VERSION == 34</a>
<a name="ln2903">    if (you.attribute[ATTR_DIVINE_REGENERATION])</a>
<a name="ln2904">    {</a>
<a name="ln2905">        you.attribute[ATTR_DIVINE_REGENERATION] = 0;</a>
<a name="ln2906">        you.duration[DUR_TROGS_HAND] = max(you.duration[DUR_TROGS_HAND],</a>
<a name="ln2907">                                           you.duration[DUR_REGENERATION]);</a>
<a name="ln2908">        you.duration[DUR_REGENERATION] = 0;</a>
<a name="ln2909">    }</a>
<a name="ln2910">    if (you.attribute[ATTR_SEARING_RAY] &gt; 3)</a>
<a name="ln2911">        you.attribute[ATTR_SEARING_RAY] = 0;</a>
<a name="ln2912"> </a>
<a name="ln2913">    if (you.attribute[ATTR_DELAYED_FIREBALL])</a>
<a name="ln2914">        you.attribute[ATTR_DELAYED_FIREBALL] = 0;</a>
<a name="ln2915"> </a>
<a name="ln2916">    if (th.getMinorVersion() &lt; TAG_MINOR_STAT_LOSS_XP)</a>
<a name="ln2917">    {</a>
<a name="ln2918">        for (int i = 0; i &lt; NUM_STATS; ++i)</a>
<a name="ln2919">        {</a>
<a name="ln2920">            if (you.stat_loss[i] &gt; 0)</a>
<a name="ln2921">            {</a>
<a name="ln2922">                you.attribute[ATTR_STAT_LOSS_XP] = stat_loss_roll();</a>
<a name="ln2923">                break;</a>
<a name="ln2924">            }</a>
<a name="ln2925">        }</a>
<a name="ln2926">    }</a>
<a name="ln2927"> </a>
<a name="ln2928">#endif</a>
<a name="ln2929"> </a>
<a name="ln2930">#if TAG_MAJOR_VERSION == 34</a>
<a name="ln2931">    // Nemelex item type sacrifice toggles.</a>
<a name="ln2932">    if (th.getMinorVersion() &lt; TAG_MINOR_NEMELEX_WEIGHTS)</a>
<a name="ln2933">    {</a>
<a name="ln2934">        count = unmarshallByte(th);</a>
<a name="ln2935">        ASSERT(count &lt;= NUM_OBJECT_CLASSES);</a>
<a name="ln2936">        for (int j = 0; j &lt; count; ++j)</a>
<a name="ln2937">            unmarshallInt(th);</a>
<a name="ln2938">    }</a>
<a name="ln2939">#endif</a>
<a name="ln2940"> </a>
<a name="ln2941">    int timer_count = 0;</a>
<a name="ln2942">#if TAG_MAJOR_VERSION == 34</a>
<a name="ln2943">    if (th.getMinorVersion() &gt;= TAG_MINOR_EVENT_TIMERS)</a>
<a name="ln2944">    {</a>
<a name="ln2945">#endif</a>
<a name="ln2946">    timer_count = unmarshallByte(th);</a>
<a name="ln2947">    ASSERT(timer_count &lt;= NUM_TIMERS);</a>
<a name="ln2948">    for (int j = 0; j &lt; timer_count; ++j)</a>
<a name="ln2949">    {</a>
<a name="ln2950">        you.last_timer_effect[j] = unmarshallInt(th);</a>
<a name="ln2951">        you.next_timer_effect[j] = unmarshallInt(th);</a>
<a name="ln2952">    }</a>
<a name="ln2953">#if TAG_MAJOR_VERSION == 34</a>
<a name="ln2954">    }</a>
<a name="ln2955">    else</a>
<a name="ln2956">        timer_count = 0;</a>
<a name="ln2957">#endif</a>
<a name="ln2958">    // We'll have to fix up missing/broken timer entries after</a>
<a name="ln2959">    // we unmarshall you.elapsed_time.</a>
<a name="ln2960"> </a>
<a name="ln2961">    // how many mutations/demon powers?</a>
<a name="ln2962">    count = unmarshallShort(th);</a>
<a name="ln2963">    ASSERT_RANGE(count, 0, NUM_MUTATIONS + 1);</a>
<a name="ln2964">    for (int j = 0; j &lt; count; ++j)</a>
<a name="ln2965">    {</a>
<a name="ln2966">        you.mutation[j]         = unmarshallUByte(th);</a>
<a name="ln2967">        you.innate_mutation[j]  = unmarshallUByte(th);</a>
<a name="ln2968">#if TAG_MAJOR_VERSION == 34</a>
<a name="ln2969">        if (th.getMinorVersion() &gt;= TAG_MINOR_TEMP_MUTATIONS</a>
<a name="ln2970">            &amp;&amp; th.getMinorVersion() != TAG_MINOR_0_11)</a>
<a name="ln2971">        {</a>
<a name="ln2972">#endif</a>
<a name="ln2973">        you.temp_mutation[j]    = unmarshallUByte(th);</a>
<a name="ln2974">#if TAG_MAJOR_VERSION == 34</a>
<a name="ln2975">        }</a>
<a name="ln2976">        if (th.getMinorVersion() &lt; TAG_MINOR_RU_SACRIFICES)</a>
<a name="ln2977">            you.sacrifices[j]   = 0;</a>
<a name="ln2978">        else</a>
<a name="ln2979">        {</a>
<a name="ln2980">#endif</a>
<a name="ln2981">        you.sacrifices[j]       = unmarshallUByte(th);</a>
<a name="ln2982">#if TAG_MAJOR_VERSION == 34</a>
<a name="ln2983">        }</a>
<a name="ln2984"> </a>
<a name="ln2985">        if (you.innate_mutation[j] + you.temp_mutation[j] &gt; you.mutation[j])</a>
<a name="ln2986">        {</a>
<a name="ln2987">            if (th.getMinorVersion() &gt;= TAG_MINOR_SPIT_POISON_AGAIN</a>
<a name="ln2988">                &amp;&amp; th.getMinorVersion() &lt; TAG_MINOR_SPIT_POISON_AGAIN_AGAIN</a>
<a name="ln2989">                &amp;&amp; j == MUT_SPIT_POISON)</a>
<a name="ln2990">            {</a>
<a name="ln2991">                // this special case needs to be handled diferently or</a>
<a name="ln2992">                // the level will be set too high; innate is what's corrupted.</a>
<a name="ln2993">                you.mutation[j] = you.innate_mutation[j] = 1;</a>
<a name="ln2994">                you.temp_mutation[j] = 0;</a>
<a name="ln2995">            }</a>
<a name="ln2996">            else</a>
<a name="ln2997">            {</a>
<a name="ln2998">                mprf(MSGCH_ERROR, &quot;Mutation #%d out of sync, fixing up.&quot;, j);</a>
<a name="ln2999">                you.mutation[j] = you.innate_mutation[j] + you.temp_mutation[j];</a>
<a name="ln3000">            }</a>
<a name="ln3001">        }</a>
<a name="ln3002">#endif</a>
<a name="ln3003">    }</a>
<a name="ln3004"> </a>
<a name="ln3005"> </a>
<a name="ln3006">    // mutation fixups happen below here.</a>
<a name="ln3007">    // *REMINDER*: if you fix up an innate mutation, remember to adjust both</a>
<a name="ln3008">    // `you.mutation` and `you.innate_mutation`.</a>
<a name="ln3009"> </a>
<a name="ln3010">#if TAG_MAJOR_VERSION == 34</a>
<a name="ln3011">    if (th.getMinorVersion() &lt; TAG_MINOR_STAT_MUT)</a>
<a name="ln3012">    {</a>
<a name="ln3013">        // Convert excess mutational stats into base stats.</a>
<a name="ln3014">        mutation_type stat_mutations[] = { MUT_STRONG, MUT_CLEVER, MUT_AGILE };</a>
<a name="ln3015">        stat_type stat_types[] = { STAT_STR, STAT_INT, STAT_DEX };</a>
<a name="ln3016">        for (int j = 0; j &lt; 3; ++j)</a>
<a name="ln3017">        {</a>
<a name="ln3018">            mutation_type mut = stat_mutations[j];</a>
<a name="ln3019">            stat_type stat = stat_types[j];</a>
<a name="ln3020">            int total_mutation_level = you.temp_mutation[mut] + you.mutation[mut];</a>
<a name="ln3021">            if (total_mutation_level &gt; 2)</a>
<a name="ln3022">            {</a>
<a name="ln3023">                int new_level = max(0, min(you.temp_mutation[mut] - you.mutation[mut], 2));</a>
<a name="ln3024">                you.temp_mutation[mut] = new_level;</a>
<a name="ln3025">            }</a>
<a name="ln3026">            if (you.mutation[mut] &gt; 2)</a>
<a name="ln3027">            {</a>
<a name="ln3028">                int excess = you.mutation[mut] - 4;</a>
<a name="ln3029">                if (excess &gt; 0)</a>
<a name="ln3030">                    you.base_stats[stat] += excess;</a>
<a name="ln3031">                you.mutation[mut] = 2;</a>
<a name="ln3032">            }</a>
<a name="ln3033">        }</a>
<a name="ln3034">        mutation_type bad_stat_mutations[] = { MUT_WEAK, MUT_DOPEY, MUT_CLUMSY };</a>
<a name="ln3035">        for (int j = 0; j &lt; 3; ++j)</a>
<a name="ln3036">        {</a>
<a name="ln3037">            mutation_type mut = bad_stat_mutations[j];</a>
<a name="ln3038">            int level = you.mutation[mut];</a>
<a name="ln3039">            switch (level)</a>
<a name="ln3040">            {</a>
<a name="ln3041">            case 0:</a>
<a name="ln3042">            case 1:</a>
<a name="ln3043">                you.mutation[mut] = 0;</a>
<a name="ln3044">                break;</a>
<a name="ln3045">            case 2:</a>
<a name="ln3046">            case 3:</a>
<a name="ln3047">                you.mutation[mut] = 1;</a>
<a name="ln3048">                break;</a>
<a name="ln3049">            default:</a>
<a name="ln3050">                you.mutation[mut] = 2;</a>
<a name="ln3051">                break;</a>
<a name="ln3052">            };</a>
<a name="ln3053">            if (you.temp_mutation[mut] &gt; 2 &amp;&amp; you.mutation[mut] &lt; 2)</a>
<a name="ln3054">                you.temp_mutation[mut] = 1;</a>
<a name="ln3055">            else</a>
<a name="ln3056">                you.temp_mutation[mut] = 0;</a>
<a name="ln3057">        }</a>
<a name="ln3058">    }</a>
<a name="ln3059">    you.mutation[MUT_FAST] = you.innate_mutation[MUT_FAST];</a>
<a name="ln3060">    you.mutation[MUT_SLOW] = you.innate_mutation[MUT_SLOW];</a>
<a name="ln3061">    you.mutation[MUT_BREATHE_FLAMES] = 0;</a>
<a name="ln3062">    if (you.species != SP_NAGA)</a>
<a name="ln3063">        you.mutation[MUT_SPIT_POISON] = 0;</a>
<a name="ln3064">#endif</a>
<a name="ln3065"> </a>
<a name="ln3066">    for (int j = count; j &lt; NUM_MUTATIONS; ++j)</a>
<a name="ln3067">        you.mutation[j] = you.innate_mutation[j] = you.sacrifices[j];</a>
<a name="ln3068"> </a>
<a name="ln3069">#if TAG_MAJOR_VERSION == 34</a>
<a name="ln3070">    if (th.getMinorVersion() &lt; TAG_MINOR_NO_POTION_HEAL)</a>
<a name="ln3071">    {   // These use to apply no matter what the minor tag</a>
<a name="ln3072">        // was, so when TAG_MINOR_NO_POTION_HEAL was added</a>
<a name="ln3073">        // these were all moved to only apply to previous</a>
<a name="ln3074">        // tags.</a>
<a name="ln3075">        if (you.mutation[MUT_TELEPORT_CONTROL] == 1)</a>
<a name="ln3076">            you.mutation[MUT_TELEPORT_CONTROL] = 0;</a>
<a name="ln3077">        if (you.mutation[MUT_TRAMPLE_RESISTANCE] &gt; 0</a>
<a name="ln3078">            || you.innate_mutation[MUT_TRAMPLE_RESISTANCE] &gt; 0)</a>
<a name="ln3079">        {</a>
<a name="ln3080">            you.mutation[MUT_TRAMPLE_RESISTANCE] = 0;</a>
<a name="ln3081">            you.innate_mutation[MUT_TRAMPLE_RESISTANCE] = 0;</a>
<a name="ln3082">        }</a>
<a name="ln3083">        if (you.mutation[MUT_CLING] == 1)</a>
<a name="ln3084">            you.mutation[MUT_CLING] = 0;</a>
<a name="ln3085">        if (you.species == SP_GARGOYLE)</a>
<a name="ln3086">        {</a>
<a name="ln3087">            you.mutation[MUT_POISON_RESISTANCE] =</a>
<a name="ln3088">            you.innate_mutation[MUT_POISON_RESISTANCE] = 0;</a>
<a name="ln3089">        }</a>
<a name="ln3090">        if (you.species == SP_FORMICID)</a>
<a name="ln3091">        {</a>
<a name="ln3092">            you.mutation[MUT_ANTENNAE] = you.innate_mutation[MUT_ANTENNAE] = 3;</a>
<a name="ln3093">            you.mutation[MUT_EXOSKELETON] =</a>
<a name="ln3094">            you.innate_mutation[MUT_EXOSKELETON] = 0;</a>
<a name="ln3095">        }</a>
<a name="ln3096">    }</a>
<a name="ln3097"> </a>
<a name="ln3098">    if (th.getMinorVersion() &lt; TAG_MINOR_DIET_MUT)</a>
<a name="ln3099">    {</a>
<a name="ln3100">        you.mutation[MUT_CARNIVOROUS] = you.innate_mutation[MUT_CARNIVOROUS];</a>
<a name="ln3101">        you.mutation[MUT_HERBIVOROUS] = you.innate_mutation[MUT_HERBIVOROUS];</a>
<a name="ln3102">    }</a>
<a name="ln3103"> </a>
<a name="ln3104">    if (th.getMinorVersion() &lt; TAG_MINOR_SAPROVOROUS</a>
<a name="ln3105">        &amp;&amp; you.species == SP_OGRE)</a>
<a name="ln3106">    {</a>
<a name="ln3107">        // Remove the innate level of fast metabolism</a>
<a name="ln3108">        you.mutation[MUT_FAST_METABOLISM] -= 1;</a>
<a name="ln3109">        you.innate_mutation[MUT_FAST_METABOLISM] -= 1;</a>
<a name="ln3110">    }</a>
<a name="ln3111"> </a>
<a name="ln3112">    if (th.getMinorVersion() &lt; TAG_MINOR_CE_HA_DIET)</a>
<a name="ln3113">    {</a>
<a name="ln3114">        if (you.species == SP_CENTAUR)</a>
<a name="ln3115">        {</a>
<a name="ln3116">            you.mutation[MUT_FAST_METABOLISM] -= 1;</a>
<a name="ln3117">            you.innate_mutation[MUT_FAST_METABOLISM] -= 1;</a>
<a name="ln3118"> </a>
<a name="ln3119">            you.mutation[MUT_HERBIVOROUS] = 1;</a>
<a name="ln3120">            you.innate_mutation[MUT_HERBIVOROUS] = 1;</a>
<a name="ln3121">        }</a>
<a name="ln3122">        else if (you.species == SP_HALFLING)</a>
<a name="ln3123">        {</a>
<a name="ln3124">            you.mutation[MUT_SLOW_METABOLISM] -= 1;</a>
<a name="ln3125">            you.innate_mutation[MUT_SLOW_METABOLISM] -= 1;</a>
<a name="ln3126">        }</a>
<a name="ln3127">    }</a>
<a name="ln3128"> </a>
<a name="ln3129">    if (th.getMinorVersion() &lt; TAG_MINOR_ROT_IMMUNITY)</a>
<a name="ln3130">    {</a>
<a name="ln3131">        if (you.species == SP_VINE_STALKER)</a>
<a name="ln3132">        {</a>
<a name="ln3133">            you.mutation[MUT_NO_POTION_HEAL] =</a>
<a name="ln3134">            you.innate_mutation[MUT_NO_POTION_HEAL] = 3;</a>
<a name="ln3135">        }</a>
<a name="ln3136"> </a>
<a name="ln3137">        if (you.species == SP_VINE_STALKER</a>
<a name="ln3138">            || you.species == SP_GARGOYLE)</a>
<a name="ln3139">        {</a>
<a name="ln3140">            you.mutation[MUT_ROT_IMMUNITY] =</a>
<a name="ln3141">            you.innate_mutation[MUT_ROT_IMMUNITY] = 1;</a>
<a name="ln3142">        }</a>
<a name="ln3143">    }</a>
<a name="ln3144"> </a>
<a name="ln3145">    if (th.getMinorVersion() &lt; TAG_MINOR_FOUL_STENCH</a>
<a name="ln3146">        &amp;&amp; you.species == SP_DEMONSPAWN</a>
<a name="ln3147">        &amp;&amp; you.innate_mutation[MUT_SAPROVOROUS])</a>
<a name="ln3148">    {</a>
<a name="ln3149">        you.mutation[MUT_ROT_IMMUNITY] =</a>
<a name="ln3150">        you.innate_mutation[MUT_ROT_IMMUNITY] = 1;</a>
<a name="ln3151">    }</a>
<a name="ln3152"> </a>
<a name="ln3153">    you.mutation[MUT_SAPROVOROUS] =</a>
<a name="ln3154">    you.innate_mutation[MUT_SAPROVOROUS] = 0;</a>
<a name="ln3155"> </a>
<a name="ln3156">    if (th.getMinorVersion() &lt; TAG_MINOR_DS_CLOUD_MUTATIONS</a>
<a name="ln3157">        &amp;&amp; you.species == SP_DEMONSPAWN)</a>
<a name="ln3158">    {</a>
<a name="ln3159">        if (you.innate_mutation[MUT_CONSERVE_POTIONS])</a>
<a name="ln3160">        {</a>
<a name="ln3161">            you.mutation[MUT_CONSERVE_POTIONS] =</a>
<a name="ln3162">            you.innate_mutation[MUT_CONSERVE_POTIONS] = 0;</a>
<a name="ln3163"> </a>
<a name="ln3164">            you.mutation[MUT_FREEZING_CLOUD_IMMUNITY] =</a>
<a name="ln3165">            you.innate_mutation[MUT_FREEZING_CLOUD_IMMUNITY] = 1;</a>
<a name="ln3166">        }</a>
<a name="ln3167">        if (you.innate_mutation[MUT_CONSERVE_SCROLLS])</a>
<a name="ln3168">        {</a>
<a name="ln3169">            you.mutation[MUT_CONSERVE_SCROLLS] =</a>
<a name="ln3170">            you.innate_mutation[MUT_CONSERVE_SCROLLS] = 0;</a>
<a name="ln3171"> </a>
<a name="ln3172">            you.mutation[MUT_FLAME_CLOUD_IMMUNITY] =</a>
<a name="ln3173">            you.innate_mutation[MUT_FLAME_CLOUD_IMMUNITY] = 1;</a>
<a name="ln3174">        }</a>
<a name="ln3175">    }</a>
<a name="ln3176"> </a>
<a name="ln3177">    if (th.getMinorVersion() &lt; TAG_MINOR_METABOLISM)</a>
<a name="ln3178">    {</a>
<a name="ln3179">        you.mutation[MUT_FAST_METABOLISM] =</a>
<a name="ln3180">        you.innate_mutation[MUT_FAST_METABOLISM];</a>
<a name="ln3181"> </a>
<a name="ln3182">        you.mutation[MUT_SLOW_METABOLISM] =</a>
<a name="ln3183">        you.innate_mutation[MUT_SLOW_METABOLISM];</a>
<a name="ln3184">    }</a>
<a name="ln3185"> </a>
<a name="ln3186">    if (th.getMinorVersion() &lt; TAG_MINOR_NO_JUMP</a>
<a name="ln3187">        &amp;&amp; you.species == SP_FELID &amp;&amp; you.innate_mutation[MUT_JUMP] != 0)</a>
<a name="ln3188">    {</a>
<a name="ln3189">        you.mutation[MUT_JUMP] = 0;</a>
<a name="ln3190">    }</a>
<a name="ln3191"> </a>
<a name="ln3192">    // No minor version needed: all old felids should get MUT_PAWS.</a>
<a name="ln3193">    if (you.species == SP_FELID &amp;&amp; you.innate_mutation[MUT_PAWS] &lt; 1)</a>
<a name="ln3194">        you.mutation[MUT_PAWS] = you.innate_mutation[MUT_PAWS] = 1;</a>
<a name="ln3195"> </a>
<a name="ln3196">    if (th.getMinorVersion() &lt; TAG_MINOR_SPIT_POISON</a>
<a name="ln3197">        &amp;&amp; you.species == SP_NAGA)</a>
<a name="ln3198">    {</a>
<a name="ln3199">        if (you.innate_mutation[MUT_SPIT_POISON] &lt; 2)</a>
<a name="ln3200">        {</a>
<a name="ln3201">            you.mutation[MUT_SPIT_POISON] =</a>
<a name="ln3202">            you.innate_mutation[MUT_SPIT_POISON] = 2;</a>
<a name="ln3203">        }</a>
<a name="ln3204">        if (you.mutation[MUT_BREATHE_POISON])</a>
<a name="ln3205">        {</a>
<a name="ln3206">            you.mutation[MUT_BREATHE_POISON] = 0;</a>
<a name="ln3207">            you.mutation[MUT_SPIT_POISON] = 3;</a>
<a name="ln3208">        }</a>
<a name="ln3209">    }</a>
<a name="ln3210"> </a>
<a name="ln3211">    // Give nagas constrict, tengu flight, and mummies restoration/enhancers.</a>
<a name="ln3212">    if (th.getMinorVersion() &lt; TAG_MINOR_REAL_MUTS</a>
<a name="ln3213">        &amp;&amp; (you.species == SP_NAGA</a>
<a name="ln3214">            || you.species == SP_TENGU</a>
<a name="ln3215">            || you.species == SP_MUMMY))</a>
<a name="ln3216">    {</a>
<a name="ln3217">        for (int xl = 2; xl &lt;= you.experience_level; ++xl)</a>
<a name="ln3218">            give_level_mutations(you.species, xl);</a>
<a name="ln3219">    }</a>
<a name="ln3220"> </a>
<a name="ln3221">    if (th.getMinorVersion() &lt; TAG_MINOR_NO_FORLORN)</a>
<a name="ln3222">    {</a>
<a name="ln3223">        if (you.mutation[MUT_FORLORN])</a>
<a name="ln3224">            you.mutation[MUT_FORLORN] = 0;</a>
<a name="ln3225">    }</a>
<a name="ln3226"> </a>
<a name="ln3227">    if (th.getMinorVersion() &lt; TAG_MINOR_MP_WANDS)</a>
<a name="ln3228">    {</a>
<a name="ln3229">        if (you.mutation[MUT_MP_WANDS] &gt; 1)</a>
<a name="ln3230">            you.mutation[MUT_MP_WANDS] = 1;</a>
<a name="ln3231">    }</a>
<a name="ln3232"> </a>
<a name="ln3233">    if (th.getMinorVersion() &lt; TAG_MINOR_NAGA_METABOLISM)</a>
<a name="ln3234">    {</a>
<a name="ln3235">        if (you.species == SP_NAGA)</a>
<a name="ln3236">        {</a>
<a name="ln3237">            you.mutation[MUT_SLOW_METABOLISM] =</a>
<a name="ln3238">                you.innate_mutation[MUT_SLOW_METABOLISM] = 1;</a>
<a name="ln3239">        }</a>
<a name="ln3240">    }</a>
<a name="ln3241"> </a>
<a name="ln3242">    if (th.getMinorVersion() &lt; TAG_MINOR_DETERIORATION)</a>
<a name="ln3243">    {</a>
<a name="ln3244">        if (you.mutation[MUT_DETERIORATION] &gt; 2)</a>
<a name="ln3245">            you.mutation[MUT_DETERIORATION] = 2;</a>
<a name="ln3246">    }</a>
<a name="ln3247"> </a>
<a name="ln3248">    if (th.getMinorVersion() &lt; TAG_MINOR_BLINK_MUT)</a>
<a name="ln3249">    {</a>
<a name="ln3250">        if (you.mutation[MUT_BLINK] &gt; 1)</a>
<a name="ln3251">            you.mutation[MUT_BLINK] = 1;</a>
<a name="ln3252">    }</a>
<a name="ln3253"> </a>
<a name="ln3254">    if (th.getMinorVersion() &lt; TAG_MINOR_MUMMY_RESTORATION)</a>
<a name="ln3255">    {</a>
<a name="ln3256">        if (you.mutation[MUT_MUMMY_RESTORATION])</a>
<a name="ln3257">        {</a>
<a name="ln3258">            you.mutation[MUT_MUMMY_RESTORATION] = 0;</a>
<a name="ln3259">            you.innate_mutation[MUT_MUMMY_RESTORATION] = 0;</a>
<a name="ln3260">        }</a>
<a name="ln3261">        if (you.mutation[MUT_SUSTAIN_ATTRIBUTES])</a>
<a name="ln3262">        {</a>
<a name="ln3263">            you.mutation[MUT_SUSTAIN_ATTRIBUTES] = 0;</a>
<a name="ln3264">            you.innate_mutation[MUT_SUSTAIN_ATTRIBUTES] = 0;</a>
<a name="ln3265">        }</a>
<a name="ln3266">    }</a>
<a name="ln3267">    else</a>
<a name="ln3268">    {</a>
<a name="ln3269">        // need another fixup due to save compat issues; the first version</a>
<a name="ln3270">        // above forgot to deal with innate mutations. The mutation might</a>
<a name="ln3271">        // have been readded in the generic fixup code.</a>
<a name="ln3272">        if (you.innate_mutation[MUT_MUMMY_RESTORATION])</a>
<a name="ln3273">        {</a>
<a name="ln3274">            you.mutation[MUT_MUMMY_RESTORATION] = 0;</a>
<a name="ln3275">            you.innate_mutation[MUT_MUMMY_RESTORATION] = 0;</a>
<a name="ln3276">        }</a>
<a name="ln3277">        if (you.innate_mutation[MUT_SUSTAIN_ATTRIBUTES])</a>
<a name="ln3278">        {</a>
<a name="ln3279">            you.mutation[MUT_SUSTAIN_ATTRIBUTES] = 0;</a>
<a name="ln3280">            you.innate_mutation[MUT_SUSTAIN_ATTRIBUTES] = 0;</a>
<a name="ln3281">        }</a>
<a name="ln3282">    }</a>
<a name="ln3283"> </a>
<a name="ln3284">    if (th.getMinorVersion() &lt; TAG_MINOR_SPIT_POISON_AGAIN)</a>
<a name="ln3285">    {</a>
<a name="ln3286">        if (you.mutation[MUT_SPIT_POISON] &gt; 1)</a>
<a name="ln3287">            you.mutation[MUT_SPIT_POISON] -= 1;</a>
<a name="ln3288">        // Before TAG_MINOR_SPIT_POISON_AGAIN_AGAIN this second if was missing.</a>
<a name="ln3289">        if (you.innate_mutation[MUT_SPIT_POISON] &gt; 1)</a>
<a name="ln3290">            you.innate_mutation[MUT_SPIT_POISON] -= 1;</a>
<a name="ln3291">    }</a>
<a name="ln3292">    else if (th.getMinorVersion() &lt; TAG_MINOR_SPIT_POISON_AGAIN_AGAIN)</a>
<a name="ln3293">    {</a>
<a name="ln3294">        // Between these two tags the value for you.innate_mutation could get</a>
<a name="ln3295">        // corrupted. No valid save after TAG_MINOR_SPIT_POISON_AGAIN should</a>
<a name="ln3296">        // have innate set to 2 for this for this mutation.</a>
<a name="ln3297"> </a>
<a name="ln3298">        // this doesn't correct you.mutation, because the 2,2 configuration</a>
<a name="ln3299">        // can result from two cases: (i) a save was upgraded across</a>
<a name="ln3300">        // TAG_MINOR_SPIT_POISON_AGAIN, had its mutations corrupted, and</a>
<a name="ln3301">        // then was fixed up to 2,2 on load, or (ii) a save-pre-</a>
<a name="ln3302">        // TAG_MINOR_SPIT_POISON_AGAIN had exhale poison, had 1 subtracted</a>
<a name="ln3303">        // from mutation, and ends up as 2,2. So, some lucky upgrades will get</a>
<a name="ln3304">        // exhale poison.</a>
<a name="ln3305"> </a>
<a name="ln3306">        if (you.innate_mutation[MUT_SPIT_POISON] == 2)</a>
<a name="ln3307">            you.innate_mutation[MUT_SPIT_POISON] = 1;</a>
<a name="ln3308">    }</a>
<a name="ln3309"> </a>
<a name="ln3310">    // Carnivore and herbivore used to be 3-level mutations.</a>
<a name="ln3311">    _cap_mutation_at(MUT_HERBIVOROUS, 1);</a>
<a name="ln3312">    _cap_mutation_at(MUT_CARNIVOROUS, 1);</a>
<a name="ln3313"> </a>
<a name="ln3314">    // Slow regeneration split into two single-level muts:</a>
<a name="ln3315">    // * Inhibited regeneration (no regen in los of monsters, what Gh get)</a>
<a name="ln3316">    // * No regeneration (what DDs get)</a>
<a name="ln3317">    {</a>
<a name="ln3318">        if (you.species == SP_DEEP_DWARF</a>
<a name="ln3319">            &amp;&amp; (you.mutation[MUT_INHIBITED_REGENERATION] &gt; 0</a>
<a name="ln3320">                || you.mutation[MUT_NO_REGENERATION] != 1))</a>
<a name="ln3321">        {</a>
<a name="ln3322">            you.innate_mutation[MUT_INHIBITED_REGENERATION] = 0;</a>
<a name="ln3323">            you.mutation[MUT_INHIBITED_REGENERATION] = 0;</a>
<a name="ln3324">            you.innate_mutation[MUT_NO_REGENERATION] = 1;</a>
<a name="ln3325">            you.mutation[MUT_NO_REGENERATION] = 1;</a>
<a name="ln3326">        }</a>
<a name="ln3327">        else if (you.species == SP_GHOUL</a>
<a name="ln3328">                 &amp;&amp; you.mutation[MUT_INHIBITED_REGENERATION] &gt; 1)</a>
<a name="ln3329">        {</a>
<a name="ln3330">            you.innate_mutation[MUT_INHIBITED_REGENERATION] = 1;</a>
<a name="ln3331">            you.mutation[MUT_INHIBITED_REGENERATION] = 1;</a>
<a name="ln3332">        }</a>
<a name="ln3333">        else if (you.mutation[MUT_INHIBITED_REGENERATION] &gt; 1)</a>
<a name="ln3334">            you.mutation[MUT_INHIBITED_REGENERATION] = 1;</a>
<a name="ln3335">    }</a>
<a name="ln3336"> </a>
<a name="ln3337">    if (th.getMinorVersion() &lt; TAG_MINOR_YELLOW_DRACONIAN_RACID</a>
<a name="ln3338">        &amp;&amp; you.species == SP_YELLOW_DRACONIAN)</a>
<a name="ln3339">    {</a>
<a name="ln3340">        you.mutation[MUT_ACID_RESISTANCE] = 1;</a>
<a name="ln3341">        you.innate_mutation[MUT_ACID_RESISTANCE] = 1;</a>
<a name="ln3342">    }</a>
<a name="ln3343"> </a>
<a name="ln3344">    // Fixup for Sacrifice XP from XL 27 (#9895). No minor tag, but this</a>
<a name="ln3345">    // should still be removed on a major bump.</a>
<a name="ln3346">    const int xl_remaining = you.get_max_xl() - you.experience_level;</a>
<a name="ln3347">    if (xl_remaining &lt; 0)</a>
<a name="ln3348">        adjust_level(xl_remaining);</a>
<a name="ln3349">#endif</a>
<a name="ln3350"> </a>
<a name="ln3351">    count = unmarshallUByte(th);</a>
<a name="ln3352">    you.demonic_traits.clear();</a>
<a name="ln3353">    for (int j = 0; j &lt; count; ++j)</a>
<a name="ln3354">    {</a>
<a name="ln3355">        player::demon_trait dt;</a>
<a name="ln3356">        dt.level_gained = unmarshallByte(th);</a>
<a name="ln3357">        ASSERT_RANGE(dt.level_gained, 1, 28);</a>
<a name="ln3358">        dt.mutation = static_cast&lt;mutation_type&gt;(unmarshallShort(th));</a>
<a name="ln3359">#if TAG_MAJOR_VERSION == 34</a>
<a name="ln3360">        if (dt.mutation == MUT_CONSERVE_POTIONS)</a>
<a name="ln3361">            dt.mutation = MUT_FREEZING_CLOUD_IMMUNITY;</a>
<a name="ln3362">        else if (dt.mutation == MUT_CONSERVE_SCROLLS)</a>
<a name="ln3363">            dt.mutation = MUT_FLAME_CLOUD_IMMUNITY;</a>
<a name="ln3364">#endif</a>
<a name="ln3365">        ASSERT_RANGE(dt.mutation, 0, NUM_MUTATIONS);</a>
<a name="ln3366">        you.demonic_traits.push_back(dt);</a>
<a name="ln3367">    }</a>
<a name="ln3368"> </a>
<a name="ln3369">#if TAG_MAJOR_VERSION == 34</a>
<a name="ln3370">    if (th.getMinorVersion() &lt; TAG_MINOR_SAC_PIETY_LEN)</a>
<a name="ln3371">    {</a>
<a name="ln3372">        const int OLD_NUM_ABILITIES = 1503;</a>
<a name="ln3373"> </a>
<a name="ln3374">        // set up sacrifice piety by abilities</a>
<a name="ln3375">        for (int j = 0; j &lt; NUM_ABILITIES; ++j)</a>
<a name="ln3376">        {</a>
<a name="ln3377">            if (th.getMinorVersion() &lt; TAG_MINOR_RU_PIETY_CONSISTENCY</a>
<a name="ln3378">                || j &gt;= OLD_NUM_ABILITIES) // NUM_ABILITIES may have increased</a>
<a name="ln3379">            {</a>
<a name="ln3380">                you.sacrifice_piety[j] = 0;</a>
<a name="ln3381">            }</a>
<a name="ln3382">            else</a>
<a name="ln3383">                you.sacrifice_piety[j] = unmarshallUByte(th);</a>
<a name="ln3384">        }</a>
<a name="ln3385"> </a>
<a name="ln3386">        // If NUM_ABILITIES decreased, discard the extras.</a>
<a name="ln3387">        if (th.getMinorVersion() &gt;= TAG_MINOR_RU_PIETY_CONSISTENCY)</a>
<a name="ln3388">        {</a>
<a name="ln3389">            for (int j = NUM_ABILITIES; j &lt; OLD_NUM_ABILITIES; ++j)</a>
<a name="ln3390">                (void) unmarshallUByte(th);</a>
<a name="ln3391">        }</a>
<a name="ln3392">    }</a>
<a name="ln3393">    else</a>
<a name="ln3394">#endif</a>
<a name="ln3395">    {</a>
<a name="ln3396">        const int num_saved = unmarshallShort(th);</a>
<a name="ln3397"> </a>
<a name="ln3398">        you.sacrifice_piety.init(0);</a>
<a name="ln3399">        for (int j = 0; j &lt; num_saved; ++j)</a>
<a name="ln3400">        {</a>
<a name="ln3401">            const int idx = ABIL_FIRST_SACRIFICE + j;</a>
<a name="ln3402">            const uint8_t val = unmarshallUByte(th);</a>
<a name="ln3403">            if (idx &lt;= ABIL_FINAL_SACRIFICE)</a>
<a name="ln3404">                you.sacrifice_piety[idx] = val;</a>
<a name="ln3405">        }</a>
<a name="ln3406">    }</a>
<a name="ln3407"> </a>
<a name="ln3408">    EAT_CANARY;</a>
<a name="ln3409"> </a>
<a name="ln3410">    // how many penances?</a>
<a name="ln3411">    count = unmarshallUByte(th);</a>
<a name="ln3412">    ASSERT(count &lt;= NUM_GODS);</a>
<a name="ln3413">    for (int i = 0; i &lt; count; i++)</a>
<a name="ln3414">    {</a>
<a name="ln3415">#if TAG_MAJOR_VERSION == 34</a>
<a name="ln3416">        if (th.getMinorVersion() &lt; TAG_MINOR_XP_PENANCE &amp;&amp; i == GOD_GOZAG)</a>
<a name="ln3417">        {</a>
<a name="ln3418">            unmarshallUByte(th);</a>
<a name="ln3419">            you.penance[i] = 0;</a>
<a name="ln3420">            continue;</a>
<a name="ln3421">        }</a>
<a name="ln3422">#endif</a>
<a name="ln3423">        you.penance[i] = unmarshallUByte(th);</a>
<a name="ln3424">#if TAG_MAJOR_VERSION == 34</a>
<a name="ln3425">        if (th.getMinorVersion() &lt; TAG_MINOR_NEMELEX_WRATH</a>
<a name="ln3426">            &amp;&amp; player_under_penance(GOD_NEMELEX_XOBEH)</a>
<a name="ln3427">            &amp;&amp; i == GOD_NEMELEX_XOBEH)</a>
<a name="ln3428">        {</a>
<a name="ln3429">            you.penance[i] = max(you.penance[i] - 100, 0);</a>
<a name="ln3430">        }</a>
<a name="ln3431">#endif</a>
<a name="ln3432">        ASSERT(you.penance[i] &lt;= MAX_PENANCE);</a>
<a name="ln3433">    }</a>
<a name="ln3434"> </a>
<a name="ln3435">#if TAG_MAJOR_VERSION == 34</a>
<a name="ln3436">    // Fix invalid ATTR_GOD_WRATH_XP if no god is giving penance.</a>
<a name="ln3437">    // cf. 0.14-a0-2640-g5c5a558</a>
<a name="ln3438">    if (you.attribute[ATTR_GOD_WRATH_XP] != 0</a>
<a name="ln3439">        || you.attribute[ATTR_GOD_WRATH_COUNT] != 0)</a>
<a name="ln3440">    {</a>
<a name="ln3441">        god_iterator it;</a>
<a name="ln3442">        for (; it; ++it)</a>
<a name="ln3443">        {</a>
<a name="ln3444">            if (player_under_penance(*it))</a>
<a name="ln3445">                break;</a>
<a name="ln3446">        }</a>
<a name="ln3447">        if (!it)</a>
<a name="ln3448">        {</a>
<a name="ln3449">            you.attribute[ATTR_GOD_WRATH_XP] = 0;</a>
<a name="ln3450">            you.attribute[ATTR_GOD_WRATH_COUNT] = 0;</a>
<a name="ln3451">        }</a>
<a name="ln3452">    }</a>
<a name="ln3453">#endif</a>
<a name="ln3454"> </a>
<a name="ln3455">    for (int i = 0; i &lt; count; i++)</a>
<a name="ln3456">        you.worshipped[i] = unmarshallByte(th);</a>
<a name="ln3457"> </a>
<a name="ln3458">    for (int i = 0; i &lt; count; i++)</a>
<a name="ln3459">        you.num_current_gifts[i] = unmarshallShort(th);</a>
<a name="ln3460">    for (int i = 0; i &lt; count; i++)</a>
<a name="ln3461">        you.num_total_gifts[i] = unmarshallShort(th);</a>
<a name="ln3462">    for (int i = 0; i &lt; count; i++)</a>
<a name="ln3463">        you.one_time_ability_used.set(i, unmarshallBoolean(th));</a>
<a name="ln3464">    for (int i = 0; i &lt; count; i++)</a>
<a name="ln3465">        you.piety_max[i] = unmarshallByte(th);</a>
<a name="ln3466">#if TAG_MAJOR_VERSION == 34</a>
<a name="ln3467">    if (th.getMinorVersion() &lt; TAG_MINOR_NEMELEX_DUNGEONS)</a>
<a name="ln3468">    {</a>
<a name="ln3469">        unmarshallByte(th);</a>
<a name="ln3470">        for (int i = 0; i &lt; NEM_GIFT_SUMMONING; i++)</a>
<a name="ln3471">            unmarshallBoolean(th);</a>
<a name="ln3472">        unmarshallBoolean(th); // dungeons weight</a>
<a name="ln3473">        for (int i = NEM_GIFT_SUMMONING; i &lt; NUM_NEMELEX_GIFT_TYPES; i++)</a>
<a name="ln3474">            unmarshallBoolean(th);</a>
<a name="ln3475">    }</a>
<a name="ln3476">    else if (th.getMinorVersion() &lt; TAG_MINOR_NEMELEX_WEIGHTS)</a>
<a name="ln3477">    {</a>
<a name="ln3478">        count = unmarshallByte(th);</a>
<a name="ln3479">        ASSERT(count == NUM_NEMELEX_GIFT_TYPES);</a>
<a name="ln3480">        for (int i = 0; i &lt; count; i++)</a>
<a name="ln3481">            unmarshallBoolean(th);</a>
<a name="ln3482">    }</a>
<a name="ln3483">#endif</a>
<a name="ln3484"> </a>
<a name="ln3485">    you.gift_timeout   = unmarshallByte(th);</a>
<a name="ln3486">#if TAG_MAJOR_VERSION == 34</a>
<a name="ln3487">    if (th.getMinorVersion() &lt; TAG_MINOR_SAVED_PIETY)</a>
<a name="ln3488">    {</a>
<a name="ln3489">        you.saved_good_god_piety = 0;</a>
<a name="ln3490">        you.previous_good_god = GOD_NO_GOD;</a>
<a name="ln3491">    }</a>
<a name="ln3492">    else</a>
<a name="ln3493">    {</a>
<a name="ln3494">#endif</a>
<a name="ln3495">    you.saved_good_god_piety = unmarshallUByte(th);</a>
<a name="ln3496">    you.previous_good_god = static_cast&lt;god_type&gt;(unmarshallByte(th));</a>
<a name="ln3497">#if TAG_MAJOR_VERSION == 34</a>
<a name="ln3498">    }</a>
<a name="ln3499">#endif</a>
<a name="ln3500"> </a>
<a name="ln3501">#if TAG_MAJOR_VERSION == 34</a>
<a name="ln3502">    if (th.getMinorVersion() &lt; TAG_MINOR_BRANCH_ENTRY)</a>
<a name="ln3503">    {</a>
<a name="ln3504">        int depth = unmarshallByte(th);</a>
<a name="ln3505">        branch_type br = static_cast&lt;branch_type&gt;(unmarshallByte(th));</a>
<a name="ln3506">        ASSERT(br &lt; NUM_BRANCHES);</a>
<a name="ln3507">        brentry[BRANCH_VESTIBULE] = level_id(br, depth);</a>
<a name="ln3508">    }</a>
<a name="ln3509">#endif</a>
<a name="ln3510"> </a>
<a name="ln3511">#if TAG_MAJOR_VERSION == 34</a>
<a name="ln3512">    if (th.getMinorVersion() &lt; TAG_MINOR_XP_PENANCE)</a>
<a name="ln3513">    {</a>
<a name="ln3514">        for (god_iterator it; it; ++it)</a>
<a name="ln3515">        {</a>
<a name="ln3516">            if (*it == GOD_ASHENZARI)</a>
<a name="ln3517">                you.exp_docked[*it] = unmarshallInt(th);</a>
<a name="ln3518">            else</a>
<a name="ln3519">                you.exp_docked[*it] = 0;</a>
<a name="ln3520">        }</a>
<a name="ln3521">        for (god_iterator it; it; ++it)</a>
<a name="ln3522">        {</a>
<a name="ln3523">            if (*it == GOD_ASHENZARI)</a>
<a name="ln3524">                you.exp_docked_total[*it] = unmarshallInt(th);</a>
<a name="ln3525">            else</a>
<a name="ln3526">                you.exp_docked_total[*it] = 0;</a>
<a name="ln3527">        }</a>
<a name="ln3528">    }</a>
<a name="ln3529">    else</a>
<a name="ln3530">    {</a>
<a name="ln3531">#endif</a>
<a name="ln3532">    for (int i = 0; i &lt; count; i++)</a>
<a name="ln3533">        you.exp_docked[i] = unmarshallInt(th);</a>
<a name="ln3534">    for (int i = 0; i &lt; count; i++)</a>
<a name="ln3535">        you.exp_docked_total[i] = unmarshallInt(th);</a>
<a name="ln3536">#if TAG_MAJOR_VERSION == 34</a>
<a name="ln3537">    }</a>
<a name="ln3538">    if (th.getMinorVersion() &lt; TAG_MINOR_PAKELLAS_WRATH</a>
<a name="ln3539">        &amp;&amp; player_under_penance(GOD_PAKELLAS))</a>
<a name="ln3540">    {</a>
<a name="ln3541">        you.exp_docked[GOD_PAKELLAS] = exp_needed(min&lt;int&gt;(you.max_level, 27) + 1)</a>
<a name="ln3542">                                  - exp_needed(min&lt;int&gt;(you.max_level, 27));</a>
<a name="ln3543">        you.exp_docked_total[GOD_PAKELLAS] = you.exp_docked[GOD_PAKELLAS];</a>
<a name="ln3544">    }</a>
<a name="ln3545">    if (th.getMinorVersion() &lt; TAG_MINOR_ELYVILON_WRATH</a>
<a name="ln3546">        &amp;&amp; player_under_penance(GOD_ELYVILON))</a>
<a name="ln3547">    {</a>
<a name="ln3548">        you.exp_docked[GOD_ELYVILON] = exp_needed(min&lt;int&gt;(you.max_level, 27) + 1)</a>
<a name="ln3549">                                  - exp_needed(min&lt;int&gt;(you.max_level, 27));</a>
<a name="ln3550">        you.exp_docked_total[GOD_ELYVILON] = you.exp_docked[GOD_ELYVILON];</a>
<a name="ln3551">    }</a>
<a name="ln3552"> </a>
<a name="ln3553">#endif</a>
<a name="ln3554"> </a>
<a name="ln3555">    // elapsed time</a>
<a name="ln3556">    you.elapsed_time   = unmarshallInt(th);</a>
<a name="ln3557">    you.elapsed_time_at_last_input = you.elapsed_time;</a>
<a name="ln3558"> </a>
<a name="ln3559">    // Initialize new timers now that we know the time.</a>
<a name="ln3560">    const int last_20_turns = you.elapsed_time - (you.elapsed_time % 200);</a>
<a name="ln3561">    for (int j = timer_count; j &lt; NUM_TIMERS; ++j)</a>
<a name="ln3562">    {</a>
<a name="ln3563">        you.last_timer_effect[j] = last_20_turns;</a>
<a name="ln3564">        you.next_timer_effect[j] = last_20_turns + 200;</a>
<a name="ln3565">    }</a>
<a name="ln3566"> </a>
<a name="ln3567">    // Verify that timers aren't scheduled for the past.</a>
<a name="ln3568">    for (int j = 0; j &lt; NUM_TIMERS; ++j)</a>
<a name="ln3569">    {</a>
<a name="ln3570">        if (you.next_timer_effect[j] &lt; you.elapsed_time)</a>
<a name="ln3571">        {</a>
<a name="ln3572">#if TAG_MAJOR_VERSION == 34</a>
<a name="ln3573">            if (th.getMinorVersion() &gt;= TAG_MINOR_EVENT_TIMERS</a>
<a name="ln3574">                &amp;&amp; th.getMinorVersion() &lt; TAG_MINOR_EVENT_TIMER_FIX)</a>
<a name="ln3575">            {</a>
<a name="ln3576">                dprf(&quot;Fixing up timer %d from %d to %d&quot;,</a>
<a name="ln3577">                     j, you.next_timer_effect[j], last_20_turns + 200);</a>
<a name="ln3578">                you.last_timer_effect[j] = last_20_turns;</a>
<a name="ln3579">                you.next_timer_effect[j] = last_20_turns + 200;</a>
<a name="ln3580">            }</a>
<a name="ln3581">            else</a>
<a name="ln3582">#endif</a>
<a name="ln3583">            die(&quot;Timer %d next trigger in the past [%d &lt; %d]&quot;,</a>
<a name="ln3584">                j, you.next_timer_effect[j], you.elapsed_time);</a>
<a name="ln3585">        }</a>
<a name="ln3586">    }</a>
<a name="ln3587"> </a>
<a name="ln3588">    // time of character creation</a>
<a name="ln3589">    you.birth_time = unmarshallInt(th);</a>
<a name="ln3590"> </a>
<a name="ln3591">    const int real_time  = unmarshallInt(th);</a>
<a name="ln3592">    you.real_time_ms = chrono::milliseconds(real_time * 1000);</a>
<a name="ln3593">    you.num_turns  = unmarshallInt(th);</a>
<a name="ln3594">    you.exploration = unmarshallInt(th);</a>
<a name="ln3595"> </a>
<a name="ln3596">#if TAG_MAJOR_VERSION == 34</a>
<a name="ln3597">    if (th.getMinorVersion() &lt; TAG_MINOR_CONTAM_SCALE)</a>
<a name="ln3598">        you.magic_contamination = unmarshallShort(th) * 1000;</a>
<a name="ln3599">    else</a>
<a name="ln3600">#endif</a>
<a name="ln3601">        you.magic_contamination = unmarshallInt(th);</a>
<a name="ln3602"> </a>
<a name="ln3603">#if TAG_MAJOR_VERSION == 34</a>
<a name="ln3604">    unmarshallUByte(th);</a>
<a name="ln3605">#endif</a>
<a name="ln3606">    you.transit_stair  = unmarshallFeatureType(th);</a>
<a name="ln3607">    you.entering_level = unmarshallByte(th);</a>
<a name="ln3608">#if TAG_MAJOR_VERSION == 34</a>
<a name="ln3609">    if (th.getMinorVersion() &gt;= TAG_MINOR_TRAVEL_ALLY_PACE)</a>
<a name="ln3610">    {</a>
<a name="ln3611">#endif</a>
<a name="ln3612">        you.travel_ally_pace = unmarshallBoolean(th);</a>
<a name="ln3613">#if TAG_MAJOR_VERSION == 34</a>
<a name="ln3614">    }</a>
<a name="ln3615">#endif</a>
<a name="ln3616"> </a>
<a name="ln3617">    you.deaths = unmarshallByte(th);</a>
<a name="ln3618">    you.lives = unmarshallByte(th);</a>
<a name="ln3619"> </a>
<a name="ln3620">#if TAG_MAJOR_VERSION == 34</a>
<a name="ln3621">    if (th.getMinorVersion() &gt;= TAG_MINOR_LORC_TEMPERATURE &amp;&amp;</a>
<a name="ln3622">        th.getMinorVersion() &lt; TAG_MINOR_NO_MORE_LORC)</a>
<a name="ln3623">    {</a>
<a name="ln3624">        // These were once the temperature fields on player for lava orcs.</a>
<a name="ln3625">        // Still need to unmarshall them from older saves.</a>
<a name="ln3626">        unmarshallFloat(th); // was you.temperature</a>
<a name="ln3627">        unmarshallFloat(th); // was you.temperature_last</a>
<a name="ln3628">    }</a>
<a name="ln3629">#endif</a>
<a name="ln3630"> </a>
<a name="ln3631">    you.pending_revival = !you.hp;</a>
<a name="ln3632"> </a>
<a name="ln3633">    EAT_CANARY;</a>
<a name="ln3634"> </a>
<a name="ln3635">    int n_dact = unmarshallInt(th);</a>
<a name="ln3636">    ASSERT_RANGE(n_dact, 0, 100000); // arbitrary, sanity check</a>
<a name="ln3637">    you.dactions.resize(n_dact, NUM_DACTIONS);</a>
<a name="ln3638">    for (int i = 0; i &lt; n_dact; i++)</a>
<a name="ln3639">    {</a>
<a name="ln3640">        int a = unmarshallUByte(th);</a>
<a name="ln3641">        ASSERT(a &lt; NUM_DACTIONS);</a>
<a name="ln3642">        you.dactions[i] = static_cast&lt;daction_type&gt;(a);</a>
<a name="ln3643">    }</a>
<a name="ln3644"> </a>
<a name="ln3645">    you.level_stack.clear();</a>
<a name="ln3646">    int n_levs = unmarshallInt(th);</a>
<a name="ln3647">    for (int k = 0; k &lt; n_levs; k++)</a>
<a name="ln3648">    {</a>
<a name="ln3649">        level_pos pos;</a>
<a name="ln3650">        pos.load(th);</a>
<a name="ln3651">        you.level_stack.push_back(pos);</a>
<a name="ln3652">    }</a>
<a name="ln3653"> </a>
<a name="ln3654">    // List of currently beholding monsters (usually empty).</a>
<a name="ln3655">    count = unmarshallShort(th);</a>
<a name="ln3656">    ASSERT(count &gt;= 0);</a>
<a name="ln3657">    for (int i = 0; i &lt; count; i++)</a>
<a name="ln3658">    {</a>
<a name="ln3659">#if TAG_MAJOR_VERSION == 34</a>
<a name="ln3660">    if (th.getMinorVersion() &lt; TAG_MINOR_MID_BEHOLDERS)</a>
<a name="ln3661">    {</a>
<a name="ln3662">        unmarshallShort(th);</a>
<a name="ln3663">        you.duration[DUR_MESMERISED] = 0;</a>
<a name="ln3664">    }</a>
<a name="ln3665">    else</a>
<a name="ln3666">#endif</a>
<a name="ln3667">        you.beholders.push_back(unmarshall_int_as&lt;mid_t&gt;(th));</a>
<a name="ln3668">    }</a>
<a name="ln3669"> </a>
<a name="ln3670">    // Also usually empty.</a>
<a name="ln3671">    count = unmarshallShort(th);</a>
<a name="ln3672">    ASSERT(count &gt;= 0);</a>
<a name="ln3673">    for (int i = 0; i &lt; count; i++)</a>
<a name="ln3674">    {</a>
<a name="ln3675">#if TAG_MAJOR_VERSION == 34</a>
<a name="ln3676">    if (th.getMinorVersion() &lt; TAG_MINOR_MID_BEHOLDERS)</a>
<a name="ln3677">    {</a>
<a name="ln3678">        unmarshallShort(th);</a>
<a name="ln3679">        you.duration[DUR_AFRAID] = 0;</a>
<a name="ln3680">    }</a>
<a name="ln3681">    else</a>
<a name="ln3682">#endif</a>
<a name="ln3683">        you.fearmongers.push_back(unmarshall_int_as&lt;mid_t&gt;(th));</a>
<a name="ln3684">    }</a>
<a name="ln3685"> </a>
<a name="ln3686">    you.piety_hysteresis = unmarshallByte(th);</a>
<a name="ln3687"> </a>
<a name="ln3688">    you.m_quiver.load(th);</a>
<a name="ln3689"> </a>
<a name="ln3690">#if TAG_MAJOR_VERSION == 34</a>
<a name="ln3691">    if (th.getMinorVersion() &lt; TAG_MINOR_FRIENDLY_PICKUP)</a>
<a name="ln3692">        unmarshallByte(th);</a>
<a name="ln3693">    if (th.getMinorVersion() &lt; TAG_MINOR_NO_ZOTDEF)</a>
<a name="ln3694">        unmarshallString(th);</a>
<a name="ln3695">#endif</a>
<a name="ln3696"> </a>
<a name="ln3697">    EAT_CANARY;</a>
<a name="ln3698"> </a>
<a name="ln3699">#if TAG_MAJOR_VERSION == 34</a>
<a name="ln3700">    if (th.getMinorVersion() == TAG_MINOR_0_11)</a>
<a name="ln3701">    {</a>
<a name="ln3702">        for (unsigned int k = 0; k &lt; 5; k++)</a>
<a name="ln3703">            unmarshallInt(th);</a>
<a name="ln3704">    }</a>
<a name="ln3705">#endif</a>
<a name="ln3706"> </a>
<a name="ln3707">    // Counts of actions made, by type.</a>
<a name="ln3708">    count = unmarshallShort(th);</a>
<a name="ln3709">    for (int i = 0; i &lt; count; i++)</a>
<a name="ln3710">    {</a>
<a name="ln3711">        caction_type caction = (caction_type)unmarshallShort(th);</a>
<a name="ln3712">        int subtype = unmarshallInt(th);</a>
<a name="ln3713">#if TAG_MAJOR_VERSION == 34</a>
<a name="ln3714">        if ((th.getMinorVersion() &lt; TAG_MINOR_ACTION_THROW</a>
<a name="ln3715">             || th.getMinorVersion() == TAG_MINOR_0_11) &amp;&amp; caction == CACT_THROW)</a>
<a name="ln3716">        {</a>
<a name="ln3717">            subtype = subtype | (OBJ_MISSILES &lt;&lt; 16);</a>
<a name="ln3718">        }</a>
<a name="ln3719">#endif</a>
<a name="ln3720">        for (int j = 0; j &lt; 27; j++)</a>
<a name="ln3721">            you.action_count[make_pair(caction, subtype)][j] = unmarshallInt(th);</a>
<a name="ln3722">    }</a>
<a name="ln3723"> </a>
<a name="ln3724">#if TAG_MAJOR_VERSION == 34</a>
<a name="ln3725">    if (th.getMinorVersion() &gt;= TAG_MINOR_BRANCHES_LEFT) // 33:17 has it</a>
<a name="ln3726">    {</a>
<a name="ln3727">#endif</a>
<a name="ln3728">    count = unmarshallByte(th);</a>
<a name="ln3729">    for (int i = 0; i &lt; count; i++)</a>
<a name="ln3730">        you.branches_left.set(i, unmarshallBoolean(th));</a>
<a name="ln3731">#if TAG_MAJOR_VERSION == 34</a>
<a name="ln3732">    }</a>
<a name="ln3733">    else</a>
<a name="ln3734">    {</a>
<a name="ln3735">        // Assume all branches already exited in transferred games.</a>
<a name="ln3736">        you.branches_left.init(true);</a>
<a name="ln3737">    }</a>
<a name="ln3738">#endif</a>
<a name="ln3739"> </a>
<a name="ln3740">    abyssal_state.major_coord = unmarshallCoord(th);</a>
<a name="ln3741">#if TAG_MAJOR_VERSION == 34</a>
<a name="ln3742">    if (th.getMinorVersion() &gt;= TAG_MINOR_DEEP_ABYSS</a>
<a name="ln3743">        &amp;&amp; th.getMinorVersion() != TAG_MINOR_0_11)</a>
<a name="ln3744">    {</a>
<a name="ln3745">        if (th.getMinorVersion() &gt;= TAG_MINOR_REMOVE_ABYSS_SEED</a>
<a name="ln3746">            &amp;&amp; th.getMinorVersion() &lt; TAG_MINOR_ADD_ABYSS_SEED)</a>
<a name="ln3747">        {</a>
<a name="ln3748">            abyssal_state.seed = rng::get_uint32();</a>
<a name="ln3749">        }</a>
<a name="ln3750">        else</a>
<a name="ln3751">#endif</a>
<a name="ln3752">            abyssal_state.seed = unmarshallInt(th);</a>
<a name="ln3753">        abyssal_state.depth = unmarshallInt(th);</a>
<a name="ln3754">        abyssal_state.destroy_all_terrain = false;</a>
<a name="ln3755">#if TAG_MAJOR_VERSION == 34</a>
<a name="ln3756">    }</a>
<a name="ln3757">    else</a>
<a name="ln3758">    {</a>
<a name="ln3759">        unmarshallFloat(th); // converted abyssal_state.depth to int.</a>
<a name="ln3760">        abyssal_state.depth = 0;</a>
<a name="ln3761">        abyssal_state.destroy_all_terrain = true;</a>
<a name="ln3762">        abyssal_state.seed = rng::get_uint32();</a>
<a name="ln3763">    }</a>
<a name="ln3764">#endif</a>
<a name="ln3765">    abyssal_state.phase = unmarshallFloat(th);</a>
<a name="ln3766"> </a>
<a name="ln3767">#if TAG_MAJOR_VERSION == 34</a>
<a name="ln3768">    if (th.getMinorVersion() &gt;= TAG_MINOR_ABYSS_BRANCHES)</a>
<a name="ln3769">        abyssal_state.level = unmarshall_level_id(th);</a>
<a name="ln3770">    if (!abyssal_state.level.is_valid())</a>
<a name="ln3771">    {</a>
<a name="ln3772">        abyssal_state.level.branch = BRANCH_DEPTHS;</a>
<a name="ln3773">        abyssal_state.level.depth = 1;</a>
<a name="ln3774">    }</a>
<a name="ln3775">#else</a>
<a name="ln3776">    abyssal_state.level = unmarshall_level_id(th);</a>
<a name="ln3777">#endif</a>
<a name="ln3778"> </a>
<a name="ln3779">    _unmarshall_constriction(th, &amp;you);</a>
<a name="ln3780"> </a>
<a name="ln3781">    you.octopus_king_rings = unmarshallUByte(th);</a>
<a name="ln3782"> </a>
<a name="ln3783">#if TAG_MAJOR_VERSION == 34</a>
<a name="ln3784">    if (th.getMinorVersion() &gt;= TAG_MINOR_UNCANCELLABLES</a>
<a name="ln3785">        &amp;&amp; th.getMinorVersion() != TAG_MINOR_0_11)</a>
<a name="ln3786">    {</a>
<a name="ln3787">#endif</a>
<a name="ln3788">    count = unmarshallUnsigned(th);</a>
<a name="ln3789">    ASSERT_RANGE(count, 0, 16); // sanity check</a>
<a name="ln3790">    you.uncancel.resize(count);</a>
<a name="ln3791">    for (int i = 0; i &lt; count; i++)</a>
<a name="ln3792">    {</a>
<a name="ln3793">        you.uncancel[i].first = (uncancellable_type)unmarshallUByte(th);</a>
<a name="ln3794">        you.uncancel[i].second = unmarshallInt(th);</a>
<a name="ln3795">    }</a>
<a name="ln3796">#if TAG_MAJOR_VERSION == 34</a>
<a name="ln3797">    // Cancel any item-based deck manipulations</a>
<a name="ln3798">    if (th.getMinorVersion() &lt; TAG_MINOR_REMOVE_DECKS)</a>
<a name="ln3799">    {</a>
<a name="ln3800">        erase_if(you.uncancel,</a>
<a name="ln3801">                 [](const pair&lt;uncancellable_type, int&gt; uc) {</a>
<a name="ln3802">                    return uc.first == UNC_DRAW_THREE</a>
<a name="ln3803">                           || uc.first == UNC_STACK_FIVE;</a>
<a name="ln3804">                });</a>
<a name="ln3805">    }</a>
<a name="ln3806">    }</a>
<a name="ln3807"> </a>
<a name="ln3808">    if (th.getMinorVersion() &gt;= TAG_MINOR_INCREMENTAL_RECALL)</a>
<a name="ln3809">    {</a>
<a name="ln3810">#endif</a>
<a name="ln3811">    count = unmarshallUnsigned(th);</a>
<a name="ln3812">    you.recall_list.resize(count);</a>
<a name="ln3813">    for (int i = 0; i &lt; count; i++)</a>
<a name="ln3814">        you.recall_list[i] = unmarshall_int_as&lt;mid_t&gt;(th);</a>
<a name="ln3815">#if TAG_MAJOR_VERSION == 34</a>
<a name="ln3816">    }</a>
<a name="ln3817"> </a>
<a name="ln3818">    if (th.getMinorVersion() &gt;= TAG_MINOR_SEEDS)</a>
<a name="ln3819">    {</a>
<a name="ln3820">#endif</a>
<a name="ln3821">    count = unmarshallUByte(th);</a>
<a name="ln3822"> </a>
<a name="ln3823">#if TAG_MAJOR_VERSION == 34</a>
<a name="ln3824">    ASSERT(th.getMinorVersion() &lt; TAG_MINOR_GAMESEEDS || count == 1);</a>
<a name="ln3825">    if (th.getMinorVersion() &lt; TAG_MINOR_GAMESEEDS)</a>
<a name="ln3826">    {</a>
<a name="ln3827">        you.game_seed = count &gt; 0 ? unmarshallInt(th) : rng::get_uint64();</a>
<a name="ln3828">        dprf(&quot;Upgrading from unseeded game.&quot;);</a>
<a name="ln3829">        crawl_state.seed = you.game_seed;</a>
<a name="ln3830">        you.fully_seeded = false;</a>
<a name="ln3831">        for (int i = 1; i &lt; count; i++)</a>
<a name="ln3832">            unmarshallInt(th);</a>
<a name="ln3833">    }</a>
<a name="ln3834">    else</a>
<a name="ln3835">    {</a>
<a name="ln3836">#endif</a>
<a name="ln3837">        // RNG block: game seed (uint64), whether the game is properly seeded,</a>
<a name="ln3838">        // and then internal RNG states stored as a vector.</a>
<a name="ln3839">        ASSERT(count == 1);</a>
<a name="ln3840">        you.game_seed = unmarshallUnsigned(th);</a>
<a name="ln3841">        dprf(&quot;Unmarshalling seed %&quot; PRIu64, you.game_seed);</a>
<a name="ln3842">        crawl_state.seed = you.game_seed;</a>
<a name="ln3843">        you.fully_seeded = unmarshallBoolean(th);</a>
<a name="ln3844">#if TAG_MAJOR_VERSION == 34</a>
<a name="ln3845">        // there is no way to tell the levelgen method for games before this</a>
<a name="ln3846">        // tag, unfortunately. Though if there are unvisited generated levels,</a>
<a name="ln3847">        // that guarantees some form of deterministic pregen.</a>
<a name="ln3848">        if (th.getMinorVersion() &lt; TAG_MINOR_INCREMENTAL_PREGEN)</a>
<a name="ln3849">            you.deterministic_levelgen = false;</a>
<a name="ln3850">        else</a>
<a name="ln3851">#endif</a>
<a name="ln3852">        you.deterministic_levelgen = unmarshallBoolean(th);</a>
<a name="ln3853">        CrawlVector rng_states;</a>
<a name="ln3854">        rng_states.read(th);</a>
<a name="ln3855">        rng::load_generators(rng_states);</a>
<a name="ln3856">#if TAG_MAJOR_VERSION == 34</a>
<a name="ln3857">    }</a>
<a name="ln3858">#endif</a>
<a name="ln3859"> </a>
<a name="ln3860">#if TAG_MAJOR_VERSION == 34</a>
<a name="ln3861">    }</a>
<a name="ln3862">#endif</a>
<a name="ln3863"> </a>
<a name="ln3864">    EAT_CANARY;</a>
<a name="ln3865"> </a>
<a name="ln3866">    if (!dlua.callfn(&quot;dgn_load_data&quot;, &quot;u&quot;, &amp;th))</a>
<a name="ln3867">    {</a>
<a name="ln3868">        mprf(MSGCH_ERROR, &quot;Failed to load Lua persist table: %s&quot;,</a>
<a name="ln3869">             dlua.error.c_str());</a>
<a name="ln3870">    }</a>
<a name="ln3871"> </a>
<a name="ln3872">    EAT_CANARY;</a>
<a name="ln3873"> </a>
<a name="ln3874">    crawl_state.save_rcs_version = unmarshallString(th);</a>
<a name="ln3875"> </a>
<a name="ln3876">    you.props.clear();</a>
<a name="ln3877">    you.props.read(th);</a>
<a name="ln3878">#if TAG_MAJOR_VERSION == 34</a>
<a name="ln3879">    if (th.getMinorVersion() &lt; TAG_MINOR_STICKY_FLAME)</a>
<a name="ln3880">    {</a>
<a name="ln3881">        if (you.props.exists(&quot;napalmer&quot;))</a>
<a name="ln3882">            you.props[&quot;sticky_flame_source&quot;] = you.props[&quot;napalmer&quot;];</a>
<a name="ln3883">        if (you.props.exists(&quot;napalm_aux&quot;))</a>
<a name="ln3884">            you.props[&quot;sticky_flame_aux&quot;] = you.props[&quot;napalm_aux&quot;];</a>
<a name="ln3885">    }</a>
<a name="ln3886"> </a>
<a name="ln3887">    if (you.duration[DUR_EXCRUCIATING_WOUNDS] &amp;&amp; !you.props.exists(ORIGINAL_BRAND_KEY))</a>
<a name="ln3888">        you.props[ORIGINAL_BRAND_KEY] = SPWPN_NORMAL;</a>
<a name="ln3889"> </a>
<a name="ln3890">    // Both saves prior to TAG_MINOR_RU_DELAY_STACKING, and saves transferred</a>
<a name="ln3891">    // from before that tag to a version where this minor tag was backwards.</a>
<a name="ln3892">    if (!you.props.exists(RU_SACRIFICE_PENALTY_KEY))</a>
<a name="ln3893">        you.props[RU_SACRIFICE_PENALTY_KEY] = 0;</a>
<a name="ln3894">    if (th.getMinorVersion() &lt; TAG_MINOR_ZIGFIGS)</a>
<a name="ln3895">        you.props[&quot;zig-fixup&quot;] = true;</a>
<a name="ln3896"> </a>
<a name="ln3897">    // For partially used lightning rods, set the XP debt based on charges.</a>
<a name="ln3898">    if (th.getMinorVersion() &lt; TAG_MINOR_LIGHTNING_ROD_XP_FIX</a>
<a name="ln3899">        &amp;&amp; you.props.exists(THUNDERBOLT_CHARGES_KEY)</a>
<a name="ln3900">        &amp;&amp; evoker_debt(MISC_LIGHTNING_ROD) == 0)</a>
<a name="ln3901">    {</a>
<a name="ln3902">        for (int i = 0; i &lt; you.props[THUNDERBOLT_CHARGES_KEY].get_int(); i++)</a>
<a name="ln3903">            expend_xp_evoker(MISC_LIGHTNING_ROD);</a>
<a name="ln3904">    }</a>
<a name="ln3905">    if (th.getMinorVersion() &lt; TAG_MINOR_SINGULAR_THEY</a>
<a name="ln3906">        &amp;&amp; you.props.exists(HEPLIAKLQANA_ALLY_GENDER_KEY))</a>
<a name="ln3907">    {</a>
<a name="ln3908">        if (you.props[HEPLIAKLQANA_ALLY_GENDER_KEY].get_int() == GENDER_NEUTER)</a>
<a name="ln3909">            you.props[HEPLIAKLQANA_ALLY_GENDER_KEY] = GENDER_NEUTRAL;</a>
<a name="ln3910">    }</a>
<a name="ln3911">#endif</a>
<a name="ln3912">}</a>
<a name="ln3913"> </a>
<a name="ln3914">static void _tag_read_you_items(reader &amp;th)</a>
<a name="ln3915">{</a>
<a name="ln3916">    int count, count2;</a>
<a name="ln3917"> </a>
<a name="ln3918">    // how many inventory slots?</a>
<a name="ln3919">    count = unmarshallByte(th);</a>
<a name="ln3920">    ASSERT(count == ENDOFPACK); // not supposed to change</a>
<a name="ln3921">#if TAG_MAJOR_VERSION == 34</a>
<a name="ln3922">    string bad_slots;</a>
<a name="ln3923">#endif</a>
<a name="ln3924">    for (int i = 0; i &lt; count; ++i)</a>
<a name="ln3925">    {</a>
<a name="ln3926">        item_def &amp;it = you.inv[i];</a>
<a name="ln3927">        unmarshallItem(th, it);</a>
<a name="ln3928">#if TAG_MAJOR_VERSION == 34</a>
<a name="ln3929">        // Fixups for actual items.</a>
<a name="ln3930">        if (it.defined())</a>
<a name="ln3931">        {</a>
<a name="ln3932">            // From 0.18-a0-273-gf174401 to 0.18-a0-290-gf199c8b, stash</a>
<a name="ln3933">            // search would change the position of items in inventory.</a>
<a name="ln3934">            if (it.pos != ITEM_IN_INVENTORY)</a>
<a name="ln3935">            {</a>
<a name="ln3936">                bad_slots += index_to_letter(i);</a>
<a name="ln3937">                it.pos = ITEM_IN_INVENTORY;</a>
<a name="ln3938">            }</a>
<a name="ln3939"> </a>
<a name="ln3940">            // Items in inventory have already been handled.</a>
<a name="ln3941">            if (th.getMinorVersion() &lt; TAG_MINOR_ISFLAG_HANDLED)</a>
<a name="ln3942">                it.flags |= ISFLAG_HANDLED;</a>
<a name="ln3943">        }</a>
<a name="ln3944">#endif</a>
<a name="ln3945">    }</a>
<a name="ln3946">#if TAG_MAJOR_VERSION == 34</a>
<a name="ln3947">    if (!bad_slots.empty())</a>
<a name="ln3948">    {</a>
<a name="ln3949">        mprf(MSGCH_ERROR, &quot;Fixed bad positions for inventory slots %s&quot;,</a>
<a name="ln3950">                          bad_slots.c_str());</a>
<a name="ln3951">    }</a>
<a name="ln3952">#endif</a>
<a name="ln3953"> </a>
<a name="ln3954">    // Initialize cache of equipped unrand functions</a>
<a name="ln3955">    for (int i = EQ_FIRST_EQUIP; i &lt; NUM_EQUIP; ++i)</a>
<a name="ln3956">    {</a>
<a name="ln3957">        const item_def *item = you.slot_item(static_cast&lt;equipment_type&gt;(i));</a>
<a name="ln3958"> </a>
<a name="ln3959">        if (item &amp;&amp; is_unrandom_artefact(*item))</a>
<a name="ln3960">        {</a>
<a name="ln3961">#if TAG_MAJOR_VERSION == 34</a>
<a name="ln3962">            // save-compat: if the player was wearing the Ring of Vitality before</a>
<a name="ln3963">            // it turned into an amulet, take it off safely</a>
<a name="ln3964">            if (is_unrandom_artefact(*item, UNRAND_VITALITY) &amp;&amp; i != EQ_AMULET)</a>
<a name="ln3965">            {</a>
<a name="ln3966">                you.equip[i] = -1;</a>
<a name="ln3967">                you.melded.set(i, false);</a>
<a name="ln3968">                // XXX: need to update ash bondage, or is this too early?</a>
<a name="ln3969">                continue;</a>
<a name="ln3970">            }</a>
<a name="ln3971">            // likewise the boots of the Assassin before it became a hat</a>
<a name="ln3972">            if (is_unrandom_artefact(*item, UNRAND_HOOD_ASSASSIN)</a>
<a name="ln3973">                &amp;&amp; i != EQ_HELMET)</a>
<a name="ln3974">            {</a>
<a name="ln3975">                you.equip[i] = -1;</a>
<a name="ln3976">                you.melded.set(i, false);</a>
<a name="ln3977">                continue;</a>
<a name="ln3978">            }</a>
<a name="ln3979">#endif</a>
<a name="ln3980"> </a>
<a name="ln3981">            const unrandart_entry *entry = get_unrand_entry(item-&gt;unrand_idx);</a>
<a name="ln3982"> </a>
<a name="ln3983">            if (entry-&gt;world_reacts_func)</a>
<a name="ln3984">                you.unrand_reacts.set(i);</a>
<a name="ln3985">        }</a>
<a name="ln3986">    }</a>
<a name="ln3987"> </a>
<a name="ln3988">    _unmarshallFixedBitVector&lt;NUM_RUNE_TYPES&gt;(th, you.runes);</a>
<a name="ln3989">    you.obtainable_runes = unmarshallByte(th);</a>
<a name="ln3990"> </a>
<a name="ln3991">    // Item descrip for each type &amp; subtype.</a>
<a name="ln3992">    // how many types?</a>
<a name="ln3993">    count = unmarshallUByte(th);</a>
<a name="ln3994">    ASSERT(count &lt;= NUM_IDESC);</a>
<a name="ln3995">    // how many subtypes?</a>
<a name="ln3996">    count2 = unmarshallUByte(th);</a>
<a name="ln3997">    ASSERT(count2 &lt;= MAX_SUBTYPES);</a>
<a name="ln3998">    for (int i = 0; i &lt; count; ++i)</a>
<a name="ln3999">        for (int j = 0; j &lt; count2; ++j)</a>
<a name="ln4000">#if TAG_MAJOR_VERSION == 34</a>
<a name="ln4001">        {</a>
<a name="ln4002">            if (th.getMinorVersion() &lt; TAG_MINOR_CONSUM_APPEARANCE)</a>
<a name="ln4003">                you.item_description[i][j] = unmarshallUByte(th);</a>
<a name="ln4004">            else</a>
<a name="ln4005">#endif</a>
<a name="ln4006">                you.item_description[i][j] = unmarshallInt(th);</a>
<a name="ln4007">#if TAG_MAJOR_VERSION == 34</a>
<a name="ln4008">            // We briefly had a problem where we sign-extended the old</a>
<a name="ln4009">            // 8-bit item_descriptions on conversion. Fix those up.</a>
<a name="ln4010">            if (th.getMinorVersion() &lt; TAG_MINOR_NEG_IDESC</a>
<a name="ln4011">                &amp;&amp; (int)you.item_description[i][j] &lt; 0)</a>
<a name="ln4012">            {</a>
<a name="ln4013">                you.item_description[i][j] &amp;= 0xff;</a>
<a name="ln4014">            }</a>
<a name="ln4015">        }</a>
<a name="ln4016">#endif</a>
<a name="ln4017">    for (int i = 0; i &lt; count; ++i)</a>
<a name="ln4018">        for (int j = count2; j &lt; MAX_SUBTYPES; ++j)</a>
<a name="ln4019">            you.item_description[i][j] = 0;</a>
<a name="ln4020">    int iclasses = unmarshallUByte(th);</a>
<a name="ln4021">    ASSERT(iclasses &lt;= NUM_OBJECT_CLASSES);</a>
<a name="ln4022"> </a>
<a name="ln4023">    // Identification status.</a>
<a name="ln4024">    for (int i = 0; i &lt; iclasses; ++i)</a>
<a name="ln4025">    {</a>
<a name="ln4026">        if (!item_type_has_ids((object_class_type)i))</a>
<a name="ln4027">            continue;</a>
<a name="ln4028">        for (int j = 0; j &lt; count2; ++j)</a>
<a name="ln4029">        {</a>
<a name="ln4030">#if TAG_MAJOR_VERSION == 34</a>
<a name="ln4031">            if (th.getMinorVersion() &lt; TAG_MINOR_ID_STATES)</a>
<a name="ln4032">            {</a>
<a name="ln4033">                uint8_t x;</a>
<a name="ln4034"> </a>
<a name="ln4035">                if (th.getMinorVersion() &lt; TAG_MINOR_BOOK_ID &amp;&amp; i == OBJ_BOOKS)</a>
<a name="ln4036">                    x = ID_UNKNOWN_TYPE;</a>
<a name="ln4037">                else</a>
<a name="ln4038">                    x = unmarshallUByte(th);</a>
<a name="ln4039"> </a>
<a name="ln4040">                ASSERT(x &lt; NUM_ID_STATE_TYPES);</a>
<a name="ln4041">                if (x &gt; ID_UNKNOWN_TYPE)</a>
<a name="ln4042">                    you.type_ids[i][j] = true;</a>
<a name="ln4043">                else</a>
<a name="ln4044">                    you.type_ids[i][j] = false;</a>
<a name="ln4045">            }</a>
<a name="ln4046">            else</a>
<a name="ln4047">#endif</a>
<a name="ln4048">            you.type_ids[i][j] = unmarshallBoolean(th);</a>
<a name="ln4049">        }</a>
<a name="ln4050">        for (int j = count2; j &lt; MAX_SUBTYPES; ++j)</a>
<a name="ln4051">            you.type_ids[i][j] = false;</a>
<a name="ln4052">    }</a>
<a name="ln4053"> </a>
<a name="ln4054">#if TAG_MAJOR_VERSION == 34</a>
<a name="ln4055">    if (th.getMinorVersion() &lt; TAG_MINOR_ID_STATES)</a>
<a name="ln4056">    {</a>
<a name="ln4057">        CrawlHashTable old_type_id_props;</a>
<a name="ln4058">        old_type_id_props.read(th);</a>
<a name="ln4059">    }</a>
<a name="ln4060">#endif</a>
<a name="ln4061"> </a>
<a name="ln4062">    EAT_CANARY;</a>
<a name="ln4063"> </a>
<a name="ln4064">    // how many unique items?</a>
<a name="ln4065">    count = unmarshallUByte(th);</a>
<a name="ln4066">    COMPILE_CHECK(NUM_UNRANDARTS &lt;= 256);</a>
<a name="ln4067">    for (int j = 0; j &lt; count &amp;&amp; j &lt; NUM_UNRANDARTS; ++j)</a>
<a name="ln4068">    {</a>
<a name="ln4069">        you.unique_items[j] =</a>
<a name="ln4070">            static_cast&lt;unique_item_status_type&gt;(unmarshallByte(th));</a>
<a name="ln4071">    }</a>
<a name="ln4072">    // # of unrandarts could certainly change.</a>
<a name="ln4073">    // If it does, the new ones won't exist yet - zero them out.</a>
<a name="ln4074">    for (int j = count; j &lt; NUM_UNRANDARTS; j++)</a>
<a name="ln4075">        you.unique_items[j] = UNIQ_NOT_EXISTS;</a>
<a name="ln4076">    for (int j = NUM_UNRANDARTS; j &lt; count; j++)</a>
<a name="ln4077">        unmarshallByte(th);</a>
<a name="ln4078"> </a>
<a name="ln4079">#if TAG_MAJOR_VERSION == 34</a>
<a name="ln4080">    if (th.getMinorVersion() &lt; TAG_MINOR_GOLDIFY_BOOKS)</a>
<a name="ln4081">    {</a>
<a name="ln4082">        // how many books?</a>
<a name="ln4083">        count = unmarshallUByte(th);</a>
<a name="ln4084">        COMPILE_CHECK(NUM_FIXED_BOOKS &lt;= 256);</a>
<a name="ln4085">        for (int j = 0; j &lt; count &amp;&amp; j &lt; NUM_FIXED_BOOKS; ++j)</a>
<a name="ln4086">            unmarshallByte(th);</a>
<a name="ln4087">        for (int j = NUM_FIXED_BOOKS; j &lt; count; ++j)</a>
<a name="ln4088">            unmarshallByte(th);</a>
<a name="ln4089"> </a>
<a name="ln4090">        // how many spells?</a>
<a name="ln4091">        count = unmarshallShort(th);</a>
<a name="ln4092">        ASSERT(count &gt;= 0);</a>
<a name="ln4093">        for (int j = 0; j &lt; count &amp;&amp; j &lt; NUM_SPELLS; ++j)</a>
<a name="ln4094">            unmarshallByte(th);</a>
<a name="ln4095">        for (int j = NUM_SPELLS; j &lt; count; ++j)</a>
<a name="ln4096">            unmarshallByte(th);</a>
<a name="ln4097">    }</a>
<a name="ln4098">#endif</a>
<a name="ln4099"> </a>
<a name="ln4100">    count = unmarshallShort(th);</a>
<a name="ln4101">    ASSERT(count &gt;= 0);</a>
<a name="ln4102">    for (int j = 0; j &lt; count &amp;&amp; j &lt; NUM_WEAPONS; ++j)</a>
<a name="ln4103">        you.seen_weapon[j] = unmarshallInt(th);</a>
<a name="ln4104">    for (int j = count; j &lt; NUM_WEAPONS; ++j)</a>
<a name="ln4105">        you.seen_weapon[j] = 0;</a>
<a name="ln4106">    for (int j = NUM_WEAPONS; j &lt; count; ++j)</a>
<a name="ln4107">        unmarshallInt(th);</a>
<a name="ln4108"> </a>
<a name="ln4109">    count = unmarshallShort(th);</a>
<a name="ln4110">    ASSERT(count &gt;= 0);</a>
<a name="ln4111">    for (int j = 0; j &lt; count &amp;&amp; j &lt; NUM_ARMOURS; ++j)</a>
<a name="ln4112">        you.seen_armour[j] = unmarshallInt(th);</a>
<a name="ln4113">    for (int j = count; j &lt; NUM_ARMOURS; ++j)</a>
<a name="ln4114">        you.seen_armour[j] = 0;</a>
<a name="ln4115">    for (int j = NUM_ARMOURS; j &lt; count; ++j)</a>
<a name="ln4116">        unmarshallInt(th);</a>
<a name="ln4117">    _unmarshallFixedBitVector&lt;NUM_MISCELLANY&gt;(th, you.seen_misc);</a>
<a name="ln4118"> </a>
<a name="ln4119">    for (int i = 0; i &lt; iclasses; i++)</a>
<a name="ln4120">        for (int j = 0; j &lt; count2; j++)</a>
<a name="ln4121">            you.force_autopickup[i][j] = unmarshallInt(th);</a>
<a name="ln4122">#if TAG_MAJOR_VERSION == 34</a>
<a name="ln4123">    if (th.getMinorVersion() &lt; TAG_MINOR_FOOD_AUTOPICKUP)</a>
<a name="ln4124">    {</a>
<a name="ln4125">        const int oldstate = you.force_autopickup[OBJ_FOOD][NUM_FOODS];</a>
<a name="ln4126">        you.force_autopickup[OBJ_FOOD][FOOD_RATION] = oldstate;</a>
<a name="ln4127"> </a>
<a name="ln4128">        you.force_autopickup[OBJ_BOOKS][BOOK_MANUAL] =</a>
<a name="ln4129">            you.force_autopickup[OBJ_BOOKS][NUM_BOOKS];</a>
<a name="ln4130">    }</a>
<a name="ln4131">    if (th.getMinorVersion() &lt; TAG_MINOR_FOOD_PURGE_AP_FIX)</a>
<a name="ln4132">    {</a>
<a name="ln4133">        FixedVector&lt;int, MAX_SUBTYPES&gt; &amp;food_pickups =</a>
<a name="ln4134">            you.force_autopickup[OBJ_FOOD];</a>
<a name="ln4135"> </a>
<a name="ln4136">        // If fruit pickup was not set explicitly during the time between</a>
<a name="ln4137">        // FOOD_PURGE and FOOD_PURGE_AP_FIX, copy the old exemplar FOOD_PEAR.</a>
<a name="ln4138">        if (food_pickups[FOOD_FRUIT] == AP_FORCE_NONE)</a>
<a name="ln4139">            food_pickups[FOOD_FRUIT] = food_pickups[FOOD_PEAR];</a>
<a name="ln4140">    }</a>
<a name="ln4141">    if (you.species == SP_FORMICID)</a>
<a name="ln4142">        remove_one_equip(EQ_HELMET, false, true);</a>
<a name="ln4143"> </a>
<a name="ln4144">    if (th.getMinorVersion() &lt; TAG_MINOR_CONSUM_APPEARANCE)</a>
<a name="ln4145">    {</a>
<a name="ln4146">        // merge scroll seeds</a>
<a name="ln4147">        for (int subtype = 0; subtype &lt; MAX_SUBTYPES; subtype++)</a>
<a name="ln4148">        {</a>
<a name="ln4149">            const int seed1 = you.item_description[IDESC_SCROLLS][subtype]</a>
<a name="ln4150">                              &amp; 0xff;</a>
<a name="ln4151">            const int seed2 = you.item_description[IDESC_SCROLLS_II][subtype]</a>
<a name="ln4152">                              &amp; 0xff;</a>
<a name="ln4153">            const int seed3 = OBJ_SCROLLS &amp; 0xff;</a>
<a name="ln4154">            you.item_description[IDESC_SCROLLS][subtype] =    seed1</a>
<a name="ln4155">                                                           | (seed2 &lt;&lt; 8)</a>
<a name="ln4156">                                                           | (seed3 &lt;&lt; 16);</a>
<a name="ln4157">        }</a>
<a name="ln4158">    }</a>
<a name="ln4159"> </a>
<a name="ln4160">    // Remove any decks now that items have been loaded.</a>
<a name="ln4161">    if (th.getMinorVersion() &lt; TAG_MINOR_REMOVE_DECKS)</a>
<a name="ln4162">        reclaim_decks();</a>
<a name="ln4163"> </a>
<a name="ln4164">    // Reset training arrays for transfered gnolls that didn't train all skills.</a>
<a name="ln4165">    if (th.getMinorVersion() &lt; TAG_MINOR_GNOLLS_REDUX)</a>
<a name="ln4166">        reset_training();</a>
<a name="ln4167"> </a>
<a name="ln4168">    // Move any books from inventory into the player's library.</a>
<a name="ln4169">    if (th.getMinorVersion() &lt; TAG_MINOR_GOLDIFY_BOOKS)</a>
<a name="ln4170">        add_held_books_to_library();</a>
<a name="ln4171">#endif</a>
<a name="ln4172">}</a>
<a name="ln4173"> </a>
<a name="ln4174">static PlaceInfo unmarshallPlaceInfo(reader &amp;th)</a>
<a name="ln4175">{</a>
<a name="ln4176">    PlaceInfo place_info;</a>
<a name="ln4177"> </a>
<a name="ln4178">#if TAG_MAJOR_VERSION == 34</a>
<a name="ln4179">    int br = unmarshallInt(th);</a>
<a name="ln4180">    // This is for extremely old saves that predate NUM_BRANCHES, probably only</a>
<a name="ln4181">    // a very small window of time in the 34 major version.</a>
<a name="ln4182">    if (br == -1)</a>
<a name="ln4183">        br = GLOBAL_BRANCH_INFO;</a>
<a name="ln4184">    ASSERT(br &gt;= 0);</a>
<a name="ln4185">    // at the time NUM_BRANCHES was one above BRANCH_DEPTHS, so we check that</a>
<a name="ln4186">    if (th.getMinorVersion() &lt; TAG_MINOR_GLOBAL_BR_INFO &amp;&amp; br == BRANCH_DEPTHS+1)</a>
<a name="ln4187">        br = GLOBAL_BRANCH_INFO;</a>
<a name="ln4188">    place_info.branch      = static_cast&lt;branch_type&gt;(br);</a>
<a name="ln4189">#else</a>
<a name="ln4190">    place_info.branch      = static_cast&lt;branch_type&gt;(unmarshallInt(th));</a>
<a name="ln4191">#endif</a>
<a name="ln4192"> </a>
<a name="ln4193">    place_info.num_visits  = unmarshallInt(th);</a>
<a name="ln4194">    place_info.levels_seen = unmarshallInt(th);</a>
<a name="ln4195"> </a>
<a name="ln4196">    place_info.mon_kill_exp       = unmarshallInt(th);</a>
<a name="ln4197"> </a>
<a name="ln4198">    for (int i = 0; i &lt; KC_NCATEGORIES; i++)</a>
<a name="ln4199">        place_info.mon_kill_num[i] = unmarshallInt(th);</a>
<a name="ln4200"> </a>
<a name="ln4201">    place_info.turns_total      = unmarshallInt(th);</a>
<a name="ln4202">    place_info.turns_explore    = unmarshallInt(th);</a>
<a name="ln4203">    place_info.turns_travel     = unmarshallInt(th);</a>
<a name="ln4204">    place_info.turns_interlevel = unmarshallInt(th);</a>
<a name="ln4205">    place_info.turns_resting    = unmarshallInt(th);</a>
<a name="ln4206">    place_info.turns_other      = unmarshallInt(th);</a>
<a name="ln4207"> </a>
<a name="ln4208">    place_info.elapsed_total      = unmarshallInt(th);</a>
<a name="ln4209">    place_info.elapsed_explore    = unmarshallInt(th);</a>
<a name="ln4210">    place_info.elapsed_travel     = unmarshallInt(th);</a>
<a name="ln4211">    place_info.elapsed_interlevel = unmarshallInt(th);</a>
<a name="ln4212">    place_info.elapsed_resting    = unmarshallInt(th);</a>
<a name="ln4213">    place_info.elapsed_other      = unmarshallInt(th);</a>
<a name="ln4214"> </a>
<a name="ln4215">    return place_info;</a>
<a name="ln4216">}</a>
<a name="ln4217"> </a>
<a name="ln4218">static LevelXPInfo unmarshallLevelXPInfo(reader &amp;th)</a>
<a name="ln4219">{</a>
<a name="ln4220">    LevelXPInfo xp_info;</a>
<a name="ln4221"> </a>
<a name="ln4222">    xp_info.level = unmarshall_level_id(th);</a>
<a name="ln4223"> </a>
<a name="ln4224">#if TAG_MAJOR_VERSION == 34</a>
<a name="ln4225">    // Track monster placement from vaults instead of tracking spawns.</a>
<a name="ln4226">    if (th.getMinorVersion() &lt; TAG_MINOR_LEVEL_XP_VAULTS)</a>
<a name="ln4227">    {</a>
<a name="ln4228">        // Spawned/generated xp and counts have to be combined as non-vault</a>
<a name="ln4229">        // info. We have no vault info on dead monsters, so this is the best we</a>
<a name="ln4230">        // can do.</a>
<a name="ln4231">        xp_info.non_vault_xp     = unmarshallInt(th);</a>
<a name="ln4232">        xp_info.non_vault_xp    += unmarshallInt(th);</a>
<a name="ln4233">        xp_info.non_vault_count  = unmarshallInt(th);</a>
<a name="ln4234">        xp_info.non_vault_count += unmarshallInt(th);</a>
<a name="ln4235">        // turns spent on level, which we don't need.</a>
<a name="ln4236">        unmarshallInt(th);</a>
<a name="ln4237">    }</a>
<a name="ln4238">    else</a>
<a name="ln4239">    {</a>
<a name="ln4240">#endif</a>
<a name="ln4241">    xp_info.non_vault_xp    = unmarshallInt(th);</a>
<a name="ln4242">    xp_info.non_vault_count = unmarshallInt(th);</a>
<a name="ln4243">    xp_info.vault_xp        = unmarshallInt(th);</a>
<a name="ln4244">    xp_info.vault_count     = unmarshallInt(th);</a>
<a name="ln4245">#if TAG_MAJOR_VERSION == 34</a>
<a name="ln4246">    }</a>
<a name="ln4247">#endif</a>
<a name="ln4248"> </a>
<a name="ln4249">    return xp_info;</a>
<a name="ln4250">}</a>
<a name="ln4251"> </a>
<a name="ln4252">#if TAG_MAJOR_VERSION == 34</a>
<a name="ln4253">static branch_type old_entries[] =</a>
<a name="ln4254">{</a>
<a name="ln4255">    /* D */      NUM_BRANCHES,</a>
<a name="ln4256">    /* Temple */ BRANCH_DUNGEON,</a>
<a name="ln4257">    /* Orc */    BRANCH_DUNGEON,</a>
<a name="ln4258">    /* Elf */    BRANCH_ORC,</a>
<a name="ln4259">    /* Dwarf */  BRANCH_ELF,</a>
<a name="ln4260">    /* Lair */   BRANCH_DUNGEON,</a>
<a name="ln4261">    /* Swamp */  BRANCH_LAIR,</a>
<a name="ln4262">    /* Shoals */ BRANCH_LAIR,</a>
<a name="ln4263">    /* Snake */  BRANCH_LAIR,</a>
<a name="ln4264">    /* Spider */ BRANCH_LAIR,</a>
<a name="ln4265">    /* Slime */  BRANCH_LAIR,</a>
<a name="ln4266">    /* Vaults */ BRANCH_DUNGEON,</a>
<a name="ln4267">    /* Blade */  BRANCH_VAULTS,</a>
<a name="ln4268">    /* Crypt */  BRANCH_VAULTS,</a>
<a name="ln4269">    /* Tomb */   BRANCH_CRYPT, // or Forest</a>
<a name="ln4270">    /* Hell */   NUM_BRANCHES,</a>
<a name="ln4271">    /* Dis */    BRANCH_VESTIBULE,</a>
<a name="ln4272">    /* Geh */    BRANCH_VESTIBULE,</a>
<a name="ln4273">    /* Coc */    BRANCH_VESTIBULE,</a>
<a name="ln4274">    /* Tar */    BRANCH_VESTIBULE,</a>
<a name="ln4275">    /* Zot */    BRANCH_DUNGEON,</a>
<a name="ln4276">    /* Forest */ BRANCH_VAULTS,</a>
<a name="ln4277">    /* Abyss */  NUM_BRANCHES,</a>
<a name="ln4278">    /* Pan */    NUM_BRANCHES,</a>
<a name="ln4279">    /* various portal branches */ NUM_BRANCHES,</a>
<a name="ln4280">    NUM_BRANCHES, NUM_BRANCHES, NUM_BRANCHES, NUM_BRANCHES, NUM_BRANCHES,</a>
<a name="ln4281">    NUM_BRANCHES, NUM_BRANCHES, NUM_BRANCHES, NUM_BRANCHES, NUM_BRANCHES,</a>
<a name="ln4282">    NUM_BRANCHES,</a>
<a name="ln4283">};</a>
<a name="ln4284">#endif</a>
<a name="ln4285"> </a>
<a name="ln4286">static void _tag_read_you_dungeon(reader &amp;th)</a>
<a name="ln4287">{</a>
<a name="ln4288">    // how many unique creatures?</a>
<a name="ln4289">    int count = unmarshallShort(th);</a>
<a name="ln4290">    you.unique_creatures.reset();</a>
<a name="ln4291">    for (int j = 0; j &lt; count; ++j)</a>
<a name="ln4292">    {</a>
<a name="ln4293">        const bool created = unmarshallBoolean(th);</a>
<a name="ln4294"> </a>
<a name="ln4295">        if (j &lt; NUM_MONSTERS)</a>
<a name="ln4296">            you.unique_creatures.set(j, created);</a>
<a name="ln4297">    }</a>
<a name="ln4298"> </a>
<a name="ln4299">    // how many branches?</a>
<a name="ln4300">    count = unmarshallUByte(th);</a>
<a name="ln4301">    ASSERT(count &lt;= NUM_BRANCHES);</a>
<a name="ln4302">    for (int j = 0; j &lt; count; ++j)</a>
<a name="ln4303">    {</a>
<a name="ln4304">        brdepth[j]    = unmarshallInt(th);</a>
<a name="ln4305">        ASSERT_RANGE(brdepth[j], -1, MAX_BRANCH_DEPTH + 1);</a>
<a name="ln4306">#if TAG_MAJOR_VERSION == 34</a>
<a name="ln4307">        if (th.getMinorVersion() &lt; TAG_MINOR_BRANCH_ENTRY)</a>
<a name="ln4308">        {</a>
<a name="ln4309">            int depth = unmarshallInt(th);</a>
<a name="ln4310">            if (j != BRANCH_VESTIBULE)</a>
<a name="ln4311">                brentry[j] = level_id(old_entries[j], depth);</a>
<a name="ln4312">        }</a>
<a name="ln4313">        else</a>
<a name="ln4314">#endif</a>
<a name="ln4315">        brentry[j]    = unmarshall_level_id(th);</a>
<a name="ln4316">#if TAG_MAJOR_VERSION == 34</a>
<a name="ln4317">        if (th.getMinorVersion() &lt; TAG_MINOR_BRIBE_BRANCH)</a>
<a name="ln4318">            branch_bribe[j] = 0;</a>
<a name="ln4319">        else</a>
<a name="ln4320">#endif</a>
<a name="ln4321">        branch_bribe[j] = unmarshallInt(th);</a>
<a name="ln4322">    }</a>
<a name="ln4323">    // Initialize data for any branches added after this save version.</a>
<a name="ln4324">    for (int j = count; j &lt; NUM_BRANCHES; ++j)</a>
<a name="ln4325">    {</a>
<a name="ln4326">        brdepth[j] = branches[j].numlevels;</a>
<a name="ln4327">        brentry[j] = level_id(branches[j].parent_branch, branches[j].mindepth);</a>
<a name="ln4328">        branch_bribe[j] = 0;</a>
<a name="ln4329">    }</a>
<a name="ln4330"> </a>
<a name="ln4331">#if TAG_MAJOR_VERSION == 34</a>
<a name="ln4332">    // Deepen the Abyss; this is okay since new abyssal stairs will be</a>
<a name="ln4333">    // generated as the place shifts.</a>
<a name="ln4334">    if (crawl_state.game_is_normal() &amp;&amp; th.getMinorVersion() &lt;= TAG_MINOR_ORIG_MONNUM)</a>
<a name="ln4335">        brdepth[BRANCH_ABYSS] = 5;</a>
<a name="ln4336">#endif</a>
<a name="ln4337"> </a>
<a name="ln4338">    ASSERT(you.depth &lt;= brdepth[you.where_are_you]);</a>
<a name="ln4339"> </a>
<a name="ln4340">    // Root of the dungeon; usually BRANCH_DUNGEON.</a>
<a name="ln4341">    root_branch = static_cast&lt;branch_type&gt;(unmarshallInt(th));</a>
<a name="ln4342">#if TAG_MAJOR_VERSION == 34</a>
<a name="ln4343">    if (th.getMinorVersion() &lt; TAG_MINOR_BRANCH_ENTRY)</a>
<a name="ln4344">    {</a>
<a name="ln4345">        brentry[root_branch].clear();</a>
<a name="ln4346">        if (brentry[BRANCH_FOREST].is_valid())</a>
<a name="ln4347">            brentry[BRANCH_TOMB].branch = BRANCH_FOREST;</a>
<a name="ln4348">    }</a>
<a name="ln4349">#endif</a>
<a name="ln4350"> </a>
<a name="ln4351">    unmarshallMap(th, stair_level,</a>
<a name="ln4352">                  unmarshall_int_as&lt;branch_type&gt;,</a>
<a name="ln4353">                  _unmarshall_level_id_set);</a>
<a name="ln4354">    unmarshallMap(th, shops_present,</a>
<a name="ln4355">                  _unmarshall_level_pos, unmarshall_int_as&lt;shop_type&gt;);</a>
<a name="ln4356">    unmarshallMap(th, altars_present,</a>
<a name="ln4357">                  _unmarshall_level_pos, unmarshall_int_as&lt;god_type&gt;);</a>
<a name="ln4358">    unmarshallMap(th, portals_present,</a>
<a name="ln4359">                  _unmarshall_level_pos, unmarshall_int_as&lt;branch_type&gt;);</a>
<a name="ln4360">    unmarshallMap(th, portal_notes,</a>
<a name="ln4361">                  _unmarshall_level_pos, unmarshallString);</a>
<a name="ln4362">    unmarshallMap(th, level_annotations,</a>
<a name="ln4363">                  unmarshall_level_id, unmarshallString);</a>
<a name="ln4364">    unmarshallMap(th, level_exclusions,</a>
<a name="ln4365">                  unmarshall_level_id, unmarshallString);</a>
<a name="ln4366">    unmarshallMap(th, level_uniques,</a>
<a name="ln4367">                  unmarshall_level_id, unmarshallString);</a>
<a name="ln4368">    unmarshallUniqueAnnotations(th);</a>
<a name="ln4369"> </a>
<a name="ln4370">    PlaceInfo place_info = unmarshallPlaceInfo(th);</a>
<a name="ln4371">    ASSERT(place_info.is_global());</a>
<a name="ln4372">    you.set_place_info(place_info);</a>
<a name="ln4373"> </a>
<a name="ln4374">    unsigned short count_p = (unsigned short) unmarshallShort(th);</a>
<a name="ln4375"> </a>
<a name="ln4376">    auto places = you.get_all_place_info();</a>
<a name="ln4377">    // Use &quot;&lt;=&quot; so that adding more branches or non-dungeon places</a>
<a name="ln4378">    // won't break save-file compatibility.</a>
<a name="ln4379">    ASSERT(count_p &lt;= places.size());</a>
<a name="ln4380"> </a>
<a name="ln4381">    for (int i = 0; i &lt; count_p; i++)</a>
<a name="ln4382">    {</a>
<a name="ln4383">        place_info = unmarshallPlaceInfo(th);</a>
<a name="ln4384">#if TAG_MAJOR_VERSION == 34</a>
<a name="ln4385">        if (place_info.is_global())</a>
<a name="ln4386">        {</a>
<a name="ln4387">            // This is to fix some crashing saves that didn't import</a>
<a name="ln4388">            // correctly, where under certain circumstances upgrading</a>
<a name="ln4389">            // a game to a version with an added branch could fail to</a>
<a name="ln4390">            // initialize the branch number. This has happened at least three</a>
<a name="ln4391">            // times now for slightly different reasons, for depths,</a>
<a name="ln4392">            // desolation, and gauntlet. The depths fixup is old enough that</a>
<a name="ln4393">            // it is handled differently.</a>
<a name="ln4394">            //</a>
<a name="ln4395">            // The basic assumption is that if a place is marked as global, it's</a>
<a name="ln4396">            // not properly initialized. The fixup assumes that logical branch</a>
<a name="ln4397">            // order (used by get_all_place_info) has not changed since the</a>
<a name="ln4398">            // save except at the end.</a>
<a name="ln4399"> </a>
<a name="ln4400">            const branch_type branch_to_fix = places[i].branch;</a>
<a name="ln4401">            mprf(MSGCH_ERROR,</a>
<a name="ln4402">                &quot;Save file has uninitialized PlaceInfo for branch %s&quot;,</a>
<a name="ln4403">                branches[places[i].branch].shortname);</a>
<a name="ln4404">            // these are the known cases where this fix applies. It would</a>
<a name="ln4405">            // probably be possible to drop this ASSERT...</a>
<a name="ln4406">            ASSERT(branch_to_fix == BRANCH_DESOLATION ||</a>
<a name="ln4407">                   branch_to_fix == BRANCH_GAUNTLET);</a>
<a name="ln4408">            place_info.branch = branch_to_fix;</a>
<a name="ln4409">        }</a>
<a name="ln4410">#endif</a>
<a name="ln4411">        ASSERT(!place_info.is_global());</a>
<a name="ln4412">        you.set_place_info(place_info);</a>
<a name="ln4413">    }</a>
<a name="ln4414"> </a>
<a name="ln4415">#if TAG_MAJOR_VERSION == 34</a>
<a name="ln4416">    if (th.getMinorVersion() &lt; TAG_MINOR_TOMB_HATCHES)</a>
<a name="ln4417">    {</a>
<a name="ln4418">        PlaceInfo pinfo = you.get_place_info(BRANCH_TOMB);</a>
<a name="ln4419">        if (pinfo.levels_seen &gt; 0)</a>
<a name="ln4420">            you.props[TOMB_STONE_STAIRS_KEY] = true;</a>
<a name="ln4421">    }</a>
<a name="ln4422">#endif</a>
<a name="ln4423"> </a>
<a name="ln4424">#if TAG_MAJOR_VERSION == 34</a>
<a name="ln4425">    if (th.getMinorVersion() &gt;= TAG_MINOR_LEVEL_XP_INFO)</a>
<a name="ln4426">    {</a>
<a name="ln4427">#endif</a>
<a name="ln4428">    auto xp_info = unmarshallLevelXPInfo(th);</a>
<a name="ln4429">    ASSERT(xp_info.is_global());</a>
<a name="ln4430">    you.set_level_xp_info(xp_info);</a>
<a name="ln4431"> </a>
<a name="ln4432">    count_p = (unsigned short) unmarshallShort(th);</a>
<a name="ln4433">    for (int i = 0; i &lt; count_p; i++)</a>
<a name="ln4434">    {</a>
<a name="ln4435">        xp_info = unmarshallLevelXPInfo(th);</a>
<a name="ln4436">        ASSERT(!xp_info.is_global());</a>
<a name="ln4437">        you.set_level_xp_info(xp_info);</a>
<a name="ln4438">    }</a>
<a name="ln4439">#if TAG_MAJOR_VERSION == 34</a>
<a name="ln4440">    }</a>
<a name="ln4441">#endif</a>
<a name="ln4442"> </a>
<a name="ln4443">    typedef pair&lt;string_set::iterator, bool&gt; ssipair;</a>
<a name="ln4444">    unmarshall_container(th, you.uniq_map_tags,</a>
<a name="ln4445">                         (ssipair (string_set::*)(const string &amp;))</a>
<a name="ln4446">                         &amp;string_set::insert,</a>
<a name="ln4447">                         unmarshallString);</a>
<a name="ln4448">    unmarshall_container(th, you.uniq_map_names,</a>
<a name="ln4449">                         (ssipair (string_set::*)(const string &amp;))</a>
<a name="ln4450">                         &amp;string_set::insert,</a>
<a name="ln4451">                         unmarshallString);</a>
<a name="ln4452">#if TAG_MAJOR_VERSION == 34</a>
<a name="ln4453">    if (th.getMinorVersion() &gt;= TAG_MINOR_ABYSS_UNIQUE_VAULTS)</a>
<a name="ln4454">    {</a>
<a name="ln4455">#endif</a>
<a name="ln4456">    unmarshall_container(th, you.uniq_map_tags_abyss,</a>
<a name="ln4457">                         (ssipair (string_set::*)(const string &amp;))</a>
<a name="ln4458">                         &amp;string_set::insert,</a>
<a name="ln4459">                         unmarshallString);</a>
<a name="ln4460">    unmarshall_container(th, you.uniq_map_names_abyss,</a>
<a name="ln4461">                         (ssipair (string_set::*)(const string &amp;))</a>
<a name="ln4462">                         &amp;string_set::insert,</a>
<a name="ln4463">                         unmarshallString);</a>
<a name="ln4464">#if TAG_MAJOR_VERSION == 34</a>
<a name="ln4465">    }</a>
<a name="ln4466">    if (th.getMinorVersion() &gt;= TAG_MINOR_VAULT_LIST) // 33:17 has it</a>
<a name="ln4467">#endif</a>
<a name="ln4468">    unmarshallMap(th, you.vault_list, unmarshall_level_id,</a>
<a name="ln4469">                  unmarshallStringVector);</a>
<a name="ln4470"> </a>
<a name="ln4471">    read_level_connectivity(th);</a>
<a name="ln4472">}</a>
<a name="ln4473"> </a>
<a name="ln4474">static void _tag_read_lost_monsters(reader &amp;th)</a>
<a name="ln4475">{</a>
<a name="ln4476">    the_lost_ones.clear();</a>
<a name="ln4477">    unmarshallMap(th, the_lost_ones,</a>
<a name="ln4478">                  unmarshall_level_id, unmarshall_follower_list);</a>
<a name="ln4479">}</a>
<a name="ln4480"> </a>
<a name="ln4481">#if TAG_MAJOR_VERSION == 34</a>
<a name="ln4482">static void _tag_read_lost_items(reader &amp;th)</a>
<a name="ln4483">{</a>
<a name="ln4484">    items_in_transit transiting_items;</a>
<a name="ln4485"> </a>
<a name="ln4486">    unmarshallMap(th, transiting_items,</a>
<a name="ln4487">                  unmarshall_level_id, unmarshall_item_list);</a>
<a name="ln4488">}</a>
<a name="ln4489">#endif</a>
<a name="ln4490"> </a>
<a name="ln4491">static void _tag_read_companions(reader &amp;th)</a>
<a name="ln4492">{</a>
<a name="ln4493">    companion_list.clear();</a>
<a name="ln4494"> </a>
<a name="ln4495">    unmarshallMap(th, companion_list, unmarshall_int_as&lt;mid_t&gt;,</a>
<a name="ln4496">                  unmarshall_companion);</a>
<a name="ln4497">}</a>
<a name="ln4498"> </a>
<a name="ln4499">template &lt;typename Z&gt;</a>
<a name="ln4500">static int _last_used_index(const Z &amp;thinglist, int max_things)</a>
<a name="ln4501">{</a>
<a name="ln4502">    for (int i = max_things - 1; i &gt;= 0; --i)</a>
<a name="ln4503">        if (thinglist[i].defined())</a>
<a name="ln4504">            return i + 1;</a>
<a name="ln4505">    return 0;</a>
<a name="ln4506">}</a>
<a name="ln4507"> </a>
<a name="ln4508">// ------------------------------- level tags ---------------------------- //</a>
<a name="ln4509"> </a>
<a name="ln4510">static void _tag_construct_level(writer &amp;th)</a>
<a name="ln4511">{</a>
<a name="ln4512">    marshallByte(th, env.floor_colour);</a>
<a name="ln4513">    marshallByte(th, env.rock_colour);</a>
<a name="ln4514"> </a>
<a name="ln4515">    marshallInt(th, you.on_current_level ? you.elapsed_time : env.elapsed_time);</a>
<a name="ln4516">    marshallCoord(th, you.pos());</a>
<a name="ln4517"> </a>
<a name="ln4518">    // Map grids.</a>
<a name="ln4519">    // how many X?</a>
<a name="ln4520">    marshallShort(th, GXM);</a>
<a name="ln4521">    // how many Y?</a>
<a name="ln4522">    marshallShort(th, GYM);</a>
<a name="ln4523"> </a>
<a name="ln4524">    marshallInt(th, env.turns_on_level);</a>
<a name="ln4525"> </a>
<a name="ln4526">    CANARY;</a>
<a name="ln4527"> </a>
<a name="ln4528">    for (int count_x = 0; count_x &lt; GXM; count_x++)</a>
<a name="ln4529">        for (int count_y = 0; count_y &lt; GYM; count_y++)</a>
<a name="ln4530">        {</a>
<a name="ln4531">            marshallByte(th, grd[count_x][count_y]);</a>
<a name="ln4532">            marshallMapCell(th, env.map_knowledge[count_x][count_y]);</a>
<a name="ln4533">            marshallInt(th, env.pgrid[count_x][count_y].flags);</a>
<a name="ln4534">        }</a>
<a name="ln4535"> </a>
<a name="ln4536">    marshallBoolean(th, !!env.map_forgotten);</a>
<a name="ln4537">    if (env.map_forgotten)</a>
<a name="ln4538">        for (int x = 0; x &lt; GXM; x++)</a>
<a name="ln4539">            for (int y = 0; y &lt; GYM; y++)</a>
<a name="ln4540">                marshallMapCell(th, (*env.map_forgotten)[x][y]);</a>
<a name="ln4541"> </a>
<a name="ln4542">    _run_length_encode(th, marshallByte, env.grid_colours, GXM, GYM);</a>
<a name="ln4543"> </a>
<a name="ln4544">    CANARY;</a>
<a name="ln4545"> </a>
<a name="ln4546">    // how many clouds?</a>
<a name="ln4547">    marshallShort(th, env.cloud.size());</a>
<a name="ln4548">    for (const auto&amp; entry : env.cloud)</a>
<a name="ln4549">    {</a>
<a name="ln4550">        const cloud_struct&amp; cloud = entry.second;</a>
<a name="ln4551">        marshallByte(th, cloud.type);</a>
<a name="ln4552">        ASSERT(cloud.type != CLOUD_NONE);</a>
<a name="ln4553">        ASSERT_IN_BOUNDS(cloud.pos);</a>
<a name="ln4554">        marshallByte(th, cloud.pos.x);</a>
<a name="ln4555">        marshallByte(th, cloud.pos.y);</a>
<a name="ln4556">        marshallShort(th, cloud.decay);</a>
<a name="ln4557">        marshallByte(th, cloud.spread_rate);</a>
<a name="ln4558">        marshallByte(th, cloud.whose);</a>
<a name="ln4559">        marshallByte(th, cloud.killer);</a>
<a name="ln4560">        marshallInt(th, cloud.source);</a>
<a name="ln4561">        marshallInt(th, cloud.excl_rad);</a>
<a name="ln4562">    }</a>
<a name="ln4563"> </a>
<a name="ln4564">    CANARY;</a>
<a name="ln4565"> </a>
<a name="ln4566">    // how many shops?</a>
<a name="ln4567">    marshallShort(th, env.shop.size());</a>
<a name="ln4568">    for (const auto&amp; entry : env.shop)</a>
<a name="ln4569">        marshall_shop(th, entry.second);</a>
<a name="ln4570"> </a>
<a name="ln4571">    CANARY;</a>
<a name="ln4572"> </a>
<a name="ln4573">    marshallCoord(th, env.sanctuary_pos);</a>
<a name="ln4574">    marshallByte(th, env.sanctuary_time);</a>
<a name="ln4575"> </a>
<a name="ln4576">    marshallInt(th, env.spawn_random_rate);</a>
<a name="ln4577"> </a>
<a name="ln4578">    env.markers.write(th);</a>
<a name="ln4579">    env.properties.write(th);</a>
<a name="ln4580"> </a>
<a name="ln4581">    // number of completed dactions. Assume, apparently, that a level can only</a>
<a name="ln4582">    // be saved if they're complete? TODO: logic is kind of weird.</a>
<a name="ln4583">    marshallInt(th, you.dactions.size());</a>
<a name="ln4584"> </a>
<a name="ln4585">    // Save heightmap, if present.</a>
<a name="ln4586">    marshallByte(th, !!env.heightmap);</a>
<a name="ln4587">    if (env.heightmap)</a>
<a name="ln4588">    {</a>
<a name="ln4589">        grid_heightmap &amp;heightmap(*env.heightmap);</a>
<a name="ln4590">        for (rectangle_iterator ri(0); ri; ++ri)</a>
<a name="ln4591">            marshallShort(th, heightmap(*ri));</a>
<a name="ln4592">    }</a>
<a name="ln4593"> </a>
<a name="ln4594">    CANARY;</a>
<a name="ln4595"> </a>
<a name="ln4596">    marshallInt(th, env.forest_awoken_until);</a>
<a name="ln4597">    marshall_level_vault_data(th);</a>
<a name="ln4598">    marshallInt(th, env.density);</a>
<a name="ln4599">}</a>
<a name="ln4600"> </a>
<a name="ln4601">void marshallItem(writer &amp;th, const item_def &amp;item, bool iinfo)</a>
<a name="ln4602">{</a>
<a name="ln4603">    marshallByte(th, item.base_type);</a>
<a name="ln4604">    if (item.base_type == OBJ_UNASSIGNED)</a>
<a name="ln4605">        return;</a>
<a name="ln4606"> </a>
<a name="ln4607">#if TAG_MAJOR_VERSION == 34</a>
<a name="ln4608">    if (!item.is_valid(iinfo))</a>
<a name="ln4609">    {</a>
<a name="ln4610">        string name;</a>
<a name="ln4611">        item_def dummy = item;</a>
<a name="ln4612">        if (!item.quantity)</a>
<a name="ln4613">            name = &quot;(quantity: 0) &quot;, dummy.quantity = 1;</a>
<a name="ln4614">        name += dummy.name(DESC_PLAIN, true);</a>
<a name="ln4615">        die(&quot;Invalid item: %s&quot;, name.c_str());</a>
<a name="ln4616">    }</a>
<a name="ln4617">#endif</a>
<a name="ln4618">    ASSERT(item.is_valid(iinfo));</a>
<a name="ln4619"> </a>
<a name="ln4620">    marshallByte(th, item.sub_type);</a>
<a name="ln4621">    marshallShort(th, item.plus);</a>
<a name="ln4622">    marshallShort(th, item.plus2);</a>
<a name="ln4623">    marshallInt(th, item.special);</a>
<a name="ln4624">    marshallShort(th, item.quantity);</a>
<a name="ln4625"> </a>
<a name="ln4626">    marshallByte(th, item.rnd);</a>
<a name="ln4627">    marshallShort(th, item.pos.x);</a>
<a name="ln4628">    marshallShort(th, item.pos.y);</a>
<a name="ln4629">    marshallInt(th, item.flags);</a>
<a name="ln4630"> </a>
<a name="ln4631">    marshallShort(th, item.link);</a>
<a name="ln4632">    if (item.pos.x &gt;= 0 &amp;&amp; item.pos.y &gt;= 0)</a>
<a name="ln4633">        marshallShort(th, igrd(item.pos));  //  unused</a>
<a name="ln4634">    else</a>
<a name="ln4635">        marshallShort(th, -1); // unused</a>
<a name="ln4636"> </a>
<a name="ln4637">    marshallByte(th, item.slot);</a>
<a name="ln4638"> </a>
<a name="ln4639">    item.orig_place.save(th);</a>
<a name="ln4640">    marshallShort(th, item.orig_monnum);</a>
<a name="ln4641">    marshallString(th, item.inscription);</a>
<a name="ln4642"> </a>
<a name="ln4643">    item.props.write(th);</a>
<a name="ln4644">}</a>
<a name="ln4645"> </a>
<a name="ln4646">#if TAG_MAJOR_VERSION == 34</a>
<a name="ln4647">static void _trim_god_gift_inscrip(item_def&amp; item)</a>
<a name="ln4648">{</a>
<a name="ln4649">    item.inscription = replace_all(item.inscription, &quot;god gift, &quot;, &quot;&quot;);</a>
<a name="ln4650">    item.inscription = replace_all(item.inscription, &quot;god gift&quot;, &quot;&quot;);</a>
<a name="ln4651">    item.inscription = replace_all(item.inscription, &quot;Psyche&quot;, &quot;&quot;);</a>
<a name="ln4652">    item.inscription = replace_all(item.inscription, &quot;Sonja&quot;, &quot;&quot;);</a>
<a name="ln4653">    item.inscription = replace_all(item.inscription, &quot;Donald&quot;, &quot;&quot;);</a>
<a name="ln4654">}</a>
<a name="ln4655"> </a>
<a name="ln4656">/// Replace &quot;dragon armour&quot; with &quot;dragon scales&quot; in an artefact's name.</a>
<a name="ln4657">static void _fixup_dragon_artefact_name(item_def &amp;item, string name_key)</a>
<a name="ln4658">{</a>
<a name="ln4659">    if (!item.props.exists(name_key))</a>
<a name="ln4660">        return;</a>
<a name="ln4661"> </a>
<a name="ln4662">    string &amp;name = item.props[name_key].get_string();</a>
<a name="ln4663">    static const string to_repl = &quot;dragon armour&quot;;</a>
<a name="ln4664">    string::size_type found = name.find(to_repl, 0);</a>
<a name="ln4665">    if (found != string::npos)</a>
<a name="ln4666">        name.replace(found, to_repl.length(), &quot;dragon scales&quot;);</a>
<a name="ln4667">}</a>
<a name="ln4668">#endif</a>
<a name="ln4669"> </a>
<a name="ln4670">void unmarshallItem(reader &amp;th, item_def &amp;item)</a>
<a name="ln4671">{</a>
<a name="ln4672">    item.base_type   = static_cast&lt;object_class_type&gt;(unmarshallByte(th));</a>
<a name="ln4673">    if (item.base_type == OBJ_UNASSIGNED)</a>
<a name="ln4674">        return;</a>
<a name="ln4675">    item.sub_type    = unmarshallUByte(th);</a>
<a name="ln4676">    item.plus        = unmarshallShort(th);</a>
<a name="ln4677">#if TAG_MAJOR_VERSION == 34</a>
<a name="ln4678">    if (th.getMinorVersion() &lt; TAG_MINOR_RUNE_TYPE</a>
<a name="ln4679">        &amp;&amp; item.is_type(OBJ_MISCELLANY, MISC_RUNE_OF_ZOT))</a>
<a name="ln4680">    {</a>
<a name="ln4681">        item.base_type = OBJ_RUNES;</a>
<a name="ln4682">        item.sub_type = item.plus;</a>
<a name="ln4683">        item.plus = 0;</a>
<a name="ln4684">    }</a>
<a name="ln4685">    if (th.getMinorVersion() &lt; TAG_MINOR_ZIGFIGS</a>
<a name="ln4686">        // enum was accidentally inserted in the middle</a>
<a name="ln4687">        &amp;&amp; item.is_type(OBJ_MISCELLANY, MISC_ZIGGURAT))</a>
<a name="ln4688">    {</a>
<a name="ln4689">        item.sub_type = MISC_PHANTOM_MIRROR;</a>
<a name="ln4690">    }</a>
<a name="ln4691">#endif</a>
<a name="ln4692">    item.plus2       = unmarshallShort(th);</a>
<a name="ln4693">    item.special     = unmarshallInt(th);</a>
<a name="ln4694">    item.quantity    = unmarshallShort(th);</a>
<a name="ln4695">#if TAG_MAJOR_VERSION == 34</a>
<a name="ln4696">    // These used to come in stacks in monster inventory as throwing weapons.</a>
<a name="ln4697">    // Replace said stacks (but not single items) with boomerangs.</a>
<a name="ln4698">    if (item.quantity &gt; 1 &amp;&amp; item.base_type == OBJ_WEAPONS</a>
<a name="ln4699">        &amp;&amp; (item.sub_type == WPN_CLUB || item.sub_type == WPN_HAND_AXE</a>
<a name="ln4700">            || item.sub_type == WPN_DAGGER || item.sub_type == WPN_SPEAR))</a>
<a name="ln4701">    {</a>
<a name="ln4702">        item.base_type = OBJ_MISSILES;</a>
<a name="ln4703">        item.sub_type = MI_BOOMERANG;</a>
<a name="ln4704">        item.plus = item.plus2 = 0;</a>
<a name="ln4705">        item.brand = SPMSL_NORMAL;</a>
<a name="ln4706">    }</a>
<a name="ln4707"> </a>
<a name="ln4708">    // Strip vestiges of distracting gold.</a>
<a name="ln4709">    if (item.base_type == OBJ_GOLD)</a>
<a name="ln4710">        item.special = 0;</a>
<a name="ln4711"> </a>
<a name="ln4712">    if (th.getMinorVersion() &lt; TAG_MINOR_REMOVE_ITEM_COLOUR)</a>
<a name="ln4713">        /* item.colour = */ unmarshallUByte(th);</a>
<a name="ln4714">#endif</a>
<a name="ln4715"> </a>
<a name="ln4716">    item.rnd          = unmarshallUByte(th);</a>
<a name="ln4717"> </a>
<a name="ln4718">    item.pos.x       = unmarshallShort(th);</a>
<a name="ln4719">    item.pos.y       = unmarshallShort(th);</a>
<a name="ln4720">    item.flags       = unmarshallInt(th);</a>
<a name="ln4721">    item.link        = unmarshallShort(th);</a>
<a name="ln4722">#if TAG_MAJOR_VERSION == 34</a>
<a name="ln4723">    // ITEM_IN_SHOP was briefly NON_ITEM + NON_ITEM (1e85cf0), but that</a>
<a name="ln4724">    // doesn't fit in a short.</a>
<a name="ln4725">    if (item.link == static_cast&lt;signed short&gt;(54000))</a>
<a name="ln4726">        item.link = ITEM_IN_SHOP;</a>
<a name="ln4727">#endif</a>
<a name="ln4728"> </a>
<a name="ln4729">    unmarshallShort(th);  // igrd[item.x][item.y] -- unused</a>
<a name="ln4730"> </a>
<a name="ln4731">    item.slot        = unmarshallByte(th);</a>
<a name="ln4732"> </a>
<a name="ln4733">#if TAG_MAJOR_VERSION == 34</a>
<a name="ln4734">    if (th.getMinorVersion() &lt; TAG_MINOR_PLACE_UNPACK)</a>
<a name="ln4735">    {</a>
<a name="ln4736">        unsigned short packed = unmarshallShort(th);</a>
<a name="ln4737">        if (packed == 0)</a>
<a name="ln4738">            item.orig_place.clear();</a>
<a name="ln4739">        else if (packed == 0xFFFF)</a>
<a name="ln4740">            item.orig_place = level_id(BRANCH_DUNGEON, 0);</a>
<a name="ln4741">        else</a>
<a name="ln4742">            item.orig_place = level_id::from_packed_place(packed);</a>
<a name="ln4743">    }</a>
<a name="ln4744">    else</a>
<a name="ln4745">#endif</a>
<a name="ln4746">    item.orig_place.load(th);</a>
<a name="ln4747"> </a>
<a name="ln4748">    item.orig_monnum = unmarshallShort(th);</a>
<a name="ln4749">#if TAG_MAJOR_VERSION == 34</a>
<a name="ln4750">    if (th.getMinorVersion() &lt; TAG_MINOR_ORIG_MONNUM &amp;&amp; item.orig_monnum &gt; 0)</a>
<a name="ln4751">        item.orig_monnum--;</a>
<a name="ln4752">#endif</a>
<a name="ln4753">    item.inscription = unmarshallString(th);</a>
<a name="ln4754"> </a>
<a name="ln4755">    item.props.clear();</a>
<a name="ln4756">    item.props.read(th);</a>
<a name="ln4757">#if TAG_MAJOR_VERSION == 34</a>
<a name="ln4758">    if (th.getMinorVersion() &lt; TAG_MINOR_CORPSE_COLOUR</a>
<a name="ln4759">        &amp;&amp; item.base_type == OBJ_CORPSES</a>
<a name="ln4760">        &amp;&amp; item.props.exists(FORCED_ITEM_COLOUR_KEY)</a>
<a name="ln4761">        &amp;&amp; !item.props[FORCED_ITEM_COLOUR_KEY].get_int())</a>
<a name="ln4762">    {</a>
<a name="ln4763">        item.props[FORCED_ITEM_COLOUR_KEY] = LIGHTRED;</a>
<a name="ln4764">    }</a>
<a name="ln4765"> </a>
<a name="ln4766">    // If we lost the monster held in an orc corpse because we marshalled</a>
<a name="ln4767">    // it as a dead monster, clear out the prop.</a>
<a name="ln4768">    if (item.props.exists(ORC_CORPSE_KEY)</a>
<a name="ln4769">        &amp;&amp; item.props[ORC_CORPSE_KEY].get_monster().type == MONS_NO_MONSTER)</a>
<a name="ln4770">    {</a>
<a name="ln4771">        item.props.erase(ORC_CORPSE_KEY);</a>
<a name="ln4772">    }</a>
<a name="ln4773">#endif</a>
<a name="ln4774">    // Fixup artefact props to handle reloading items when the new version</a>
<a name="ln4775">    // of Crawl has more artefact props.</a>
<a name="ln4776">    if (is_artefact(item))</a>
<a name="ln4777">        artefact_fixup_props(item);</a>
<a name="ln4778"> </a>
<a name="ln4779">#if TAG_MAJOR_VERSION == 34</a>
<a name="ln4780">    // Remove artefact autoinscriptions from the saved inscription.</a>
<a name="ln4781">    if ((th.getMinorVersion() &lt; TAG_MINOR_AUTOINSCRIPTIONS</a>
<a name="ln4782">         || th.getMinorVersion() == TAG_MINOR_0_11) &amp;&amp; is_artefact(item))</a>
<a name="ln4783">    {</a>
<a name="ln4784">        string art_ins = artefact_inscription(item);</a>
<a name="ln4785">        if (!art_ins.empty())</a>
<a name="ln4786">        {</a>
<a name="ln4787">            item.inscription = replace_all(item.inscription, art_ins + &quot;,&quot;, &quot;&quot;);</a>
<a name="ln4788">            item.inscription = replace_all(item.inscription, art_ins, &quot;&quot;);</a>
<a name="ln4789"> </a>
<a name="ln4790">            // Avoid q - the ring &quot;Foo&quot; {+Fly rF+, +Lev rF+}</a>
<a name="ln4791">            art_ins = replace_all(art_ins, &quot;+Fly&quot;, &quot;+Lev&quot;);</a>
<a name="ln4792">            item.inscription = replace_all(item.inscription, art_ins + &quot;,&quot;, &quot;&quot;);</a>
<a name="ln4793">            item.inscription = replace_all(item.inscription, art_ins, &quot;&quot;);</a>
<a name="ln4794"> </a>
<a name="ln4795">            trim_string(item.inscription);</a>
<a name="ln4796">        }</a>
<a name="ln4797">    }</a>
<a name="ln4798"> </a>
<a name="ln4799">    // Upgrade item knowledge to cope with the fix for #1083</a>
<a name="ln4800">    if (item.base_type == OBJ_JEWELLERY)</a>
<a name="ln4801">    {</a>
<a name="ln4802">        if (item.flags &amp; ISFLAG_KNOW_PROPERTIES)</a>
<a name="ln4803">            item.flags |= ISFLAG_KNOW_TYPE;</a>
<a name="ln4804">    }</a>
<a name="ln4805"> </a>
<a name="ln4806">    if (item.base_type == OBJ_POTIONS)</a>
<a name="ln4807">    {</a>
<a name="ln4808">        switch (item.sub_type)</a>
<a name="ln4809">        {</a>
<a name="ln4810">            case POT_GAIN_STRENGTH:</a>
<a name="ln4811">            case POT_GAIN_DEXTERITY:</a>
<a name="ln4812">            case POT_GAIN_INTELLIGENCE:</a>
<a name="ln4813">            case POT_POISON:</a>
<a name="ln4814">            case POT_SLOWING:</a>
<a name="ln4815">            case POT_PORRIDGE:</a>
<a name="ln4816">            case POT_DECAY:</a>
<a name="ln4817">            case POT_WATER:</a>
<a name="ln4818">            case POT_RESTORE_ABILITIES:</a>
<a name="ln4819">            case POT_STRONG_POISON:</a>
<a name="ln4820">            case POT_BLOOD:</a>
<a name="ln4821">            case POT_BLOOD_COAGULATED:</a>
<a name="ln4822">                item.sub_type = POT_DEGENERATION;</a>
<a name="ln4823">                break;</a>
<a name="ln4824">            case POT_CURE_MUTATION:</a>
<a name="ln4825">            case POT_BENEFICIAL_MUTATION:</a>
<a name="ln4826">                item.sub_type = POT_MUTATION;</a>
<a name="ln4827">                break;</a>
<a name="ln4828">            case POT_DUMMY_AGILITY:</a>
<a name="ln4829">                item.sub_type = POT_STABBING;</a>
<a name="ln4830">                break;</a>
<a name="ln4831">            default:</a>
<a name="ln4832">                break;</a>
<a name="ln4833">        }</a>
<a name="ln4834"> </a>
<a name="ln4835">        // Check on save load that the above switch has</a>
<a name="ln4836">        // converted all removed potion types.</a>
<a name="ln4837">        switch (item.sub_type)</a>
<a name="ln4838">        {</a>
<a name="ln4839">            default:</a>
<a name="ln4840">                break;</a>
<a name="ln4841">            CASE_REMOVED_POTIONS(item.sub_type)</a>
<a name="ln4842">        }</a>
<a name="ln4843">    }</a>
<a name="ln4844"> </a>
<a name="ln4845">    if (item.is_type(OBJ_STAVES, STAFF_CHANNELING))</a>
<a name="ln4846">        item.sub_type = STAFF_ENERGY;</a>
<a name="ln4847"> </a>
<a name="ln4848">    if (th.getMinorVersion() &lt; TAG_MINOR_GOD_GIFT)</a>
<a name="ln4849">    {</a>
<a name="ln4850">        _trim_god_gift_inscrip(item);</a>
<a name="ln4851">        if (is_stackable_item(item))</a>
<a name="ln4852">            origin_reset(item);</a>
<a name="ln4853">    }</a>
<a name="ln4854"> </a>
<a name="ln4855">    if (th.getMinorVersion() &lt; TAG_MINOR_NO_SPLINT</a>
<a name="ln4856">        &amp;&amp; item.base_type == OBJ_ARMOUR &amp;&amp; item.sub_type &gt; ARM_CHAIN_MAIL)</a>
<a name="ln4857">    {</a>
<a name="ln4858">        --item.sub_type;</a>
<a name="ln4859">    }</a>
<a name="ln4860"> </a>
<a name="ln4861">    if (th.getMinorVersion() &lt; TAG_MINOR_BOX_OF_BEASTS_CHARGES</a>
<a name="ln4862">        &amp;&amp; item.is_type(OBJ_MISCELLANY, MISC_BOX_OF_BEASTS))</a>
<a name="ln4863">    {</a>
<a name="ln4864">        // Give charges to box of beasts. If the player used it</a>
<a name="ln4865">        // already then, well, they got some freebies.</a>
<a name="ln4866">        item.plus = random_range(5, 15, 2);</a>
<a name="ln4867">    }</a>
<a name="ln4868"> </a>
<a name="ln4869">    if (item.is_type(OBJ_MISCELLANY, MISC_BUGGY_EBONY_CASKET))</a>
<a name="ln4870">    {</a>
<a name="ln4871">        item.sub_type = MISC_BOX_OF_BEASTS;</a>
<a name="ln4872">        item.plus = 1;</a>
<a name="ln4873">    }</a>
<a name="ln4874"> </a>
<a name="ln4875">    // was spiked flail</a>
<a name="ln4876">    if (item.is_type(OBJ_WEAPONS, WPN_SPIKED_FLAIL)</a>
<a name="ln4877">        &amp;&amp; th.getMinorVersion() &lt;= TAG_MINOR_FORGOTTEN_MAP)</a>
<a name="ln4878">    {</a>
<a name="ln4879">        item.sub_type = WPN_FLAIL;</a>
<a name="ln4880">    }</a>
<a name="ln4881"> </a>
<a name="ln4882">    if (item.base_type == OBJ_WEAPONS</a>
<a name="ln4883">        &amp;&amp; (item.brand == SPWPN_RETURNING</a>
<a name="ln4884">            || item.brand == SPWPN_REACHING</a>
<a name="ln4885">            || item.brand == SPWPN_ORC_SLAYING</a>
<a name="ln4886">            || item.brand == SPWPN_DRAGON_SLAYING</a>
<a name="ln4887">            || item.brand == SPWPN_EVASION))</a>
<a name="ln4888">    {</a>
<a name="ln4889">        item.brand = SPWPN_NORMAL;</a>
<a name="ln4890">    }</a>
<a name="ln4891"> </a>
<a name="ln4892">    // Not putting these in a minor tag since it's possible for an old</a>
<a name="ln4893">    // random monster spawn list to place flame/frost weapons.</a>
<a name="ln4894">    if (item.base_type == OBJ_WEAPONS &amp;&amp; get_weapon_brand(item) == SPWPN_FROST)</a>
<a name="ln4895">    {</a>
<a name="ln4896">        if (is_artefact(item))</a>
<a name="ln4897">            artefact_set_property(item, ARTP_BRAND, SPWPN_FREEZING);</a>
<a name="ln4898">        else</a>
<a name="ln4899">            item.brand = SPWPN_FREEZING;</a>
<a name="ln4900">    }</a>
<a name="ln4901">    if (item.base_type == OBJ_WEAPONS &amp;&amp; get_weapon_brand(item) == SPWPN_FLAME)</a>
<a name="ln4902">    {</a>
<a name="ln4903">        if (is_artefact(item))</a>
<a name="ln4904">            artefact_set_property(item, ARTP_BRAND, SPWPN_FLAMING);</a>
<a name="ln4905">        else</a>
<a name="ln4906">            item.brand = SPWPN_FLAMING;</a>
<a name="ln4907">    }</a>
<a name="ln4908"> </a>
<a name="ln4909">    // Rescale old MR (range 35-99) to new discrete steps (40/80/120)</a>
<a name="ln4910">    // Negative MR was only supposed to exist for Folly, but paranoia.</a>
<a name="ln4911">    if (th.getMinorVersion() &lt; TAG_MINOR_MR_ITEM_RESCALE</a>
<a name="ln4912">        &amp;&amp; is_artefact(item)</a>
<a name="ln4913">        &amp;&amp; artefact_property(item, ARTP_MAGIC_RESISTANCE))</a>
<a name="ln4914">    {</a>
<a name="ln4915">        int prop_mr = artefact_property(item, ARTP_MAGIC_RESISTANCE);</a>
<a name="ln4916">        if (prop_mr &gt; 99)</a>
<a name="ln4917">            artefact_set_property(item, ARTP_MAGIC_RESISTANCE, 3);</a>
<a name="ln4918">        else if (prop_mr &gt; 79)</a>
<a name="ln4919">            artefact_set_property(item, ARTP_MAGIC_RESISTANCE, 2);</a>
<a name="ln4920">        else if (prop_mr &lt; -40)</a>
<a name="ln4921">            artefact_set_property(item, ARTP_MAGIC_RESISTANCE, -2);</a>
<a name="ln4922">        else if (prop_mr &lt; 0)</a>
<a name="ln4923">            artefact_set_property(item, ARTP_MAGIC_RESISTANCE, -1);</a>
<a name="ln4924">        else</a>
<a name="ln4925">            artefact_set_property(item, ARTP_MAGIC_RESISTANCE, 1);</a>
<a name="ln4926">    }</a>
<a name="ln4927"> </a>
<a name="ln4928">    // Rescale stealth (range 10..79 and -10..-98) to discrete steps (+-50/100)</a>
<a name="ln4929">    if (th.getMinorVersion() &lt; TAG_MINOR_STEALTH_RESCALE &amp;&amp; is_artefact(item))</a>
<a name="ln4930">    {</a>
<a name="ln4931">        if (artefact_property(item, ARTP_STEALTH))</a>
<a name="ln4932">        {</a>
<a name="ln4933">            int prop_st = artefact_property(item, ARTP_STEALTH);</a>
<a name="ln4934">            if (prop_st &gt; 60)</a>
<a name="ln4935">                artefact_set_property(item, ARTP_STEALTH, 2);</a>
<a name="ln4936">            else if (prop_st &lt; -70)</a>
<a name="ln4937">                artefact_set_property(item, ARTP_STEALTH, -2);</a>
<a name="ln4938">            else if (prop_st &lt; 0)</a>
<a name="ln4939">                artefact_set_property(item, ARTP_STEALTH, -1);</a>
<a name="ln4940">            else</a>
<a name="ln4941">                artefact_set_property(item, ARTP_STEALTH, 1);</a>
<a name="ln4942">        }</a>
<a name="ln4943"> </a>
<a name="ln4944">        // Remove fast metabolism property</a>
<a name="ln4945">        if (artefact_property(item, ARTP_METABOLISM))</a>
<a name="ln4946">        {</a>
<a name="ln4947">            artefact_set_property(item, ARTP_METABOLISM, 0);</a>
<a name="ln4948">            artefact_set_property(item, ARTP_STEALTH, -1);</a>
<a name="ln4949">        }</a>
<a name="ln4950"> </a>
<a name="ln4951">        // Make sure no weird fake-rap combinations are produced by the upgrade</a>
<a name="ln4952">        // from rings of sustenance/hunger with {Stlth} to stealth/attention</a>
<a name="ln4953">        if (item.base_type == OBJ_JEWELLERY</a>
<a name="ln4954">            &amp;&amp; (item.sub_type == RING_STEALTH</a>
<a name="ln4955">                || item.sub_type == RING_ATTENTION))</a>
<a name="ln4956">        {</a>
<a name="ln4957">            artefact_set_property(item, ARTP_STEALTH, 0);</a>
<a name="ln4958">        }</a>
<a name="ln4959">    }</a>
<a name="ln4960"> </a>
<a name="ln4961">    if (th.getMinorVersion() &lt; TAG_MINOR_NO_POT_FOOD)</a>
<a name="ln4962">    {</a>
<a name="ln4963">        // Replace War Chants with Battle to avoid empty-book errors.</a>
<a name="ln4964"> </a>
<a name="ln4965">        // Moved under TAG_MINOR_NO_POT_FOOD because it was formerly</a>
<a name="ln4966">        // not restricted to a particular range of minor tags.</a>
<a name="ln4967">        if (item.is_type(OBJ_BOOKS, BOOK_WAR_CHANTS))</a>
<a name="ln4968">            item.sub_type = BOOK_BATTLE;</a>
<a name="ln4969"> </a>
<a name="ln4970">        if (item.base_type == OBJ_FOOD &amp;&amp; (item.sub_type == FOOD_UNUSED</a>
<a name="ln4971">                                           || item.sub_type == FOOD_AMBROSIA))</a>
<a name="ln4972">        {</a>
<a name="ln4973">            item.sub_type = FOOD_ROYAL_JELLY; // will be fixed up later</a>
<a name="ln4974">        }</a>
<a name="ln4975">    }</a>
<a name="ln4976"> </a>
<a name="ln4977">    if (th.getMinorVersion() &lt; TAG_MINOR_FOOD_PURGE)</a>
<a name="ln4978">    {</a>
<a name="ln4979">        if (item.base_type == OBJ_FOOD)</a>
<a name="ln4980">        {</a>
<a name="ln4981">            if (item.sub_type == FOOD_SAUSAGE)</a>
<a name="ln4982">                item.sub_type = FOOD_BEEF_JERKY;</a>
<a name="ln4983">            if (item.sub_type == FOOD_CHEESE)</a>
<a name="ln4984">                item.sub_type = FOOD_PIZZA;</a>
<a name="ln4985">            if (item.sub_type == FOOD_PEAR</a>
<a name="ln4986">                || item.sub_type == FOOD_APPLE</a>
<a name="ln4987">                || item.sub_type == FOOD_CHOKO</a>
<a name="ln4988">                || item.sub_type == FOOD_APRICOT</a>
<a name="ln4989">                || item.sub_type == FOOD_ORANGE</a>
<a name="ln4990">                || item.sub_type == FOOD_BANANA</a>
<a name="ln4991">                || item.sub_type == FOOD_STRAWBERRY</a>
<a name="ln4992">                || item.sub_type == FOOD_RAMBUTAN</a>
<a name="ln4993">                || item.sub_type == FOOD_GRAPE</a>
<a name="ln4994">                || item.sub_type == FOOD_SULTANA</a>
<a name="ln4995">                || item.sub_type == FOOD_LYCHEE</a>
<a name="ln4996">                || item.sub_type == FOOD_LEMON)</a>
<a name="ln4997">            {</a>
<a name="ln4998">                item.sub_type = FOOD_FRUIT; // will be fixed up later</a>
<a name="ln4999">            }</a>
<a name="ln5000">        }</a>
<a name="ln5001">    }</a>
<a name="ln5002">    if (th.getMinorVersion() &lt; TAG_MINOR_FOOD_PURGE_RELOADED)</a>
<a name="ln5003">    {</a>
<a name="ln5004">        if (item.base_type == OBJ_FOOD)</a>
<a name="ln5005">        {</a>
<a name="ln5006">            if (item.sub_type == FOOD_BEEF_JERKY</a>
<a name="ln5007">                || item.sub_type == FOOD_PIZZA)</a>
<a name="ln5008">            {</a>
<a name="ln5009">                item.sub_type = FOOD_ROYAL_JELLY; // will be fixed up later</a>
<a name="ln5010">            }</a>
<a name="ln5011">        }</a>
<a name="ln5012">    }</a>
<a name="ln5013"> </a>
<a name="ln5014">    // Combine old rings of slaying (Acc/Dam) to new (Dam).</a>
<a name="ln5015">    // Also handle the changes to the respective ARTP_.</a>
<a name="ln5016">    if (th.getMinorVersion() &lt; TAG_MINOR_SLAYRING_PLUSES)</a>
<a name="ln5017">    {</a>
<a name="ln5018">        int acc, dam, slay = 0;</a>
<a name="ln5019"> </a>
<a name="ln5020">        if (item.props.exists(ARTEFACT_PROPS_KEY))</a>
<a name="ln5021">        {</a>
<a name="ln5022">            acc = artefact_property(item, ARTP_ACCURACY);</a>
<a name="ln5023">            dam = artefact_property(item, ARTP_SLAYING);</a>
<a name="ln5024">            slay = dam &lt; 0 ? dam : max(acc, dam);</a>
<a name="ln5025"> </a>
<a name="ln5026">            artefact_set_property(item, ARTP_SLAYING, slay);</a>
<a name="ln5027">        }</a>
<a name="ln5028"> </a>
<a name="ln5029">        if (item.is_type(OBJ_JEWELLERY, RING_SLAYING))</a>
<a name="ln5030">        {</a>
<a name="ln5031">            acc = item.plus;</a>
<a name="ln5032">            dam = item.plus2;</a>
<a name="ln5033">            slay = dam &lt; 0 ? dam : max(acc, dam);</a>
<a name="ln5034"> </a>
<a name="ln5035">            item.plus = slay;</a>
<a name="ln5036">            item.plus2 = 0; // probably harmless but might as well</a>
<a name="ln5037">        }</a>
<a name="ln5038">    }</a>
<a name="ln5039"> </a>
<a name="ln5040">    if (th.getMinorVersion() &lt; TAG_MINOR_MERGE_EW)</a>
<a name="ln5041">    {</a>
<a name="ln5042">        // Combine EW1/EW2/EW3 scrolls into single enchant weapon scroll.</a>
<a name="ln5043">        if (item.base_type == OBJ_SCROLLS</a>
<a name="ln5044">            &amp;&amp; (item.sub_type == SCR_ENCHANT_WEAPON_II</a>
<a name="ln5045">                || item.sub_type == SCR_ENCHANT_WEAPON_III))</a>
<a name="ln5046">        {</a>
<a name="ln5047">            item.sub_type = SCR_ENCHANT_WEAPON;</a>
<a name="ln5048">        }</a>
<a name="ln5049">    }</a>
<a name="ln5050"> </a>
<a name="ln5051">    if (th.getMinorVersion() &lt; TAG_MINOR_WEAPON_PLUSES)</a>
<a name="ln5052">    {</a>
<a name="ln5053">        int acc, dam, slay = 0;</a>
<a name="ln5054"> </a>
<a name="ln5055">        if (item.base_type == OBJ_WEAPONS)</a>
<a name="ln5056">        {</a>
<a name="ln5057">            acc = item.plus;</a>
<a name="ln5058">            dam = item.plus2;</a>
<a name="ln5059">            slay = dam &lt; 0 ? dam : max(acc,dam);</a>
<a name="ln5060"> </a>
<a name="ln5061">            item.plus = slay;</a>
<a name="ln5062">            item.plus2 = 0; // probably harmless but might as well</a>
<a name="ln5063">        }</a>
<a name="ln5064">    }</a>
<a name="ln5065"> </a>
<a name="ln5066">    if (th.getMinorVersion() &lt; TAG_MINOR_CUT_CUTLASSES)</a>
<a name="ln5067">    {</a>
<a name="ln5068">        if (item.is_type(OBJ_WEAPONS, WPN_CUTLASS))</a>
<a name="ln5069">            item.sub_type = WPN_RAPIER;</a>
<a name="ln5070">    }</a>
<a name="ln5071"> </a>
<a name="ln5072">    if (th.getMinorVersion() &lt; TAG_MINOR_INIT_RND)</a>
<a name="ln5073">    {</a>
<a name="ln5074">        // 0 is now reserved to indicate that rnd is uninitialized</a>
<a name="ln5075">        if (item.rnd == 0)</a>
<a name="ln5076">            item.rnd = 1 + random2(255);</a>
<a name="ln5077">    }</a>
<a name="ln5078"> </a>
<a name="ln5079">    if (th.getMinorVersion() &lt; TAG_MINOR_RING_PLUSSES)</a>
<a name="ln5080">        if (item.base_type == OBJ_JEWELLERY &amp;&amp; item.plus &gt; 6)</a>
<a name="ln5081">            item.plus = 6;</a>
<a name="ln5082"> </a>
<a name="ln5083">    if (th.getMinorVersion() &lt; TAG_MINOR_BLESSED_WPNS</a>
<a name="ln5084">        &amp;&amp; item.base_type == OBJ_WEAPONS)</a>
<a name="ln5085">    {</a>
<a name="ln5086">        const int initial_type = item.sub_type;</a>
<a name="ln5087">        switch (item.sub_type)</a>
<a name="ln5088">        {</a>
<a name="ln5089">        case WPN_BLESSED_FALCHION:     item.sub_type = WPN_FALCHION; break;</a>
<a name="ln5090">        case WPN_BLESSED_LONG_SWORD:   item.sub_type = WPN_LONG_SWORD; break;</a>
<a name="ln5091">        case WPN_BLESSED_SCIMITAR:     item.sub_type = WPN_SCIMITAR; break;</a>
<a name="ln5092">        case WPN_BLESSED_DOUBLE_SWORD: item.sub_type = WPN_DOUBLE_SWORD; break;</a>
<a name="ln5093">        case WPN_BLESSED_GREAT_SWORD:  item.sub_type = WPN_GREAT_SWORD; break;</a>
<a name="ln5094">        case WPN_BLESSED_TRIPLE_SWORD: item.sub_type = WPN_TRIPLE_SWORD; break;</a>
<a name="ln5095">        default:                       break;</a>
<a name="ln5096">        }</a>
<a name="ln5097">        if (initial_type != item.sub_type)</a>
<a name="ln5098">            set_item_ego_type(item, OBJ_WEAPONS, SPWPN_HOLY_WRATH);</a>
<a name="ln5099">    }</a>
<a name="ln5100"> </a>
<a name="ln5101">    if (th.getMinorVersion() &lt; TAG_MINOR_CONSUM_APPEARANCE)</a>
<a name="ln5102">    {</a>
<a name="ln5103">        if (item.base_type == OBJ_POTIONS)</a>
<a name="ln5104">            item.subtype_rnd = item.plus; // was consum_desc</a>
<a name="ln5105">        else if (item.base_type == OBJ_SCROLLS)</a>
<a name="ln5106">        {</a>
<a name="ln5107">            // faithfully preserve weirdness</a>
<a name="ln5108">            item.subtype_rnd = item.subtype_rnd</a>
<a name="ln5109">                               | (item.plus &lt;&lt; 8) // was consum_desc</a>
<a name="ln5110">                               | (OBJ_SCROLLS &lt;&lt; 16);</a>
<a name="ln5111">        }</a>
<a name="ln5112">    }</a>
<a name="ln5113"> </a>
<a name="ln5114">    if (th.getMinorVersion() &lt; TAG_MINOR_MANGLE_CORPSES)</a>
<a name="ln5115">        if (item.props.exists(&quot;never_hide&quot;))</a>
<a name="ln5116">            item.props.erase(&quot;never_hide&quot;);</a>
<a name="ln5117"> </a>
<a name="ln5118">    if (th.getMinorVersion() &lt; TAG_MINOR_ISFLAG_HANDLED</a>
<a name="ln5119">        &amp;&amp; item.flags &amp; (ISFLAG_DROPPED | ISFLAG_THROWN))</a>
<a name="ln5120">    {</a>
<a name="ln5121">       // Items we've dropped or thrown have been handled already.</a>
<a name="ln5122">       item.flags |= ISFLAG_HANDLED;</a>
<a name="ln5123">    }</a>
<a name="ln5124"> </a>
<a name="ln5125">    if (th.getMinorVersion() &lt; TAG_MINOR_UNSTACKABLE_EVOKERS</a>
<a name="ln5126">        &amp;&amp; is_xp_evoker(item))</a>
<a name="ln5127">    {</a>
<a name="ln5128">        item.quantity = 1;</a>
<a name="ln5129">    }</a>
<a name="ln5130"> </a>
<a name="ln5131">    if (th.getMinorVersion() &lt; TAG_MINOR_NO_NEGATIVE_VULN</a>
<a name="ln5132">        &amp;&amp; is_artefact(item)</a>
<a name="ln5133">        &amp;&amp; artefact_property(item, ARTP_NEGATIVE_ENERGY))</a>
<a name="ln5134">    {</a>
<a name="ln5135">        if (artefact_property(item, ARTP_NEGATIVE_ENERGY) &lt; 0)</a>
<a name="ln5136">            artefact_set_property(item, ARTP_NEGATIVE_ENERGY, 0);</a>
<a name="ln5137">    }</a>
<a name="ln5138"> </a>
<a name="ln5139">    if (th.getMinorVersion() &lt; TAG_MINOR_NO_RPOIS_MINUS</a>
<a name="ln5140">        &amp;&amp; is_artefact(item)</a>
<a name="ln5141">        &amp;&amp; artefact_property(item, ARTP_POISON))</a>
<a name="ln5142">    {</a>
<a name="ln5143">        if (artefact_property(item, ARTP_POISON) &lt; 0)</a>
<a name="ln5144">            artefact_set_property(item, ARTP_POISON, 0);</a>
<a name="ln5145">    }</a>
<a name="ln5146"> </a>
<a name="ln5147">    if (th.getMinorVersion() &lt; TAG_MINOR_TELEPORTITIS</a>
<a name="ln5148">        &amp;&amp; is_artefact(item)</a>
<a name="ln5149">        &amp;&amp; artefact_property(item, ARTP_CAUSE_TELEPORTATION) &gt; 1)</a>
<a name="ln5150">    {</a>
<a name="ln5151">        artefact_set_property(item, ARTP_CAUSE_TELEPORTATION, 1);</a>
<a name="ln5152">    }</a>
<a name="ln5153"> </a>
<a name="ln5154">    if (th.getMinorVersion() &lt; TAG_MINOR_NO_TWISTER</a>
<a name="ln5155">        &amp;&amp; is_artefact(item)</a>
<a name="ln5156">        &amp;&amp; artefact_property(item, ARTP_TWISTER))</a>
<a name="ln5157">    {</a>
<a name="ln5158">        artefact_set_property(item, ARTP_TWISTER, 0);</a>
<a name="ln5159">    }</a>
<a name="ln5160"> </a>
<a name="ln5161">    // Monsters could zap wands below zero from</a>
<a name="ln5162">    // 0.17-a0-739-g965e8eb to 0.17-a0-912-g3e33c8f.</a>
<a name="ln5163">    if (item.base_type == OBJ_WANDS &amp;&amp; item.charges &lt; 0)</a>
<a name="ln5164">        item.charges = 0;</a>
<a name="ln5165"> </a>
<a name="ln5166">    if (item.base_type == OBJ_RODS &amp;&amp; item.cursed())</a>
<a name="ln5167">        do_uncurse_item(item); // rods can't be cursed anymore</a>
<a name="ln5168"> </a>
<a name="ln5169">    // turn old hides into the corresponding armour</a>
<a name="ln5170">    static const map&lt;int, armour_type&gt; hide_to_armour = {</a>
<a name="ln5171">        { ARM_TROLL_HIDE,               ARM_TROLL_LEATHER_ARMOUR },</a>
<a name="ln5172">        { ARM_FIRE_DRAGON_HIDE,         ARM_FIRE_DRAGON_ARMOUR },</a>
<a name="ln5173">        { ARM_ICE_DRAGON_HIDE,          ARM_ICE_DRAGON_ARMOUR },</a>
<a name="ln5174">        { ARM_STEAM_DRAGON_HIDE,        ARM_STEAM_DRAGON_ARMOUR },</a>
<a name="ln5175">        { ARM_STORM_DRAGON_HIDE,        ARM_STORM_DRAGON_ARMOUR },</a>
<a name="ln5176">        { ARM_GOLD_DRAGON_HIDE,         ARM_GOLD_DRAGON_ARMOUR },</a>
<a name="ln5177">        { ARM_SWAMP_DRAGON_HIDE,        ARM_SWAMP_DRAGON_ARMOUR },</a>
<a name="ln5178">        { ARM_PEARL_DRAGON_HIDE,        ARM_PEARL_DRAGON_ARMOUR },</a>
<a name="ln5179">        { ARM_SHADOW_DRAGON_HIDE,       ARM_SHADOW_DRAGON_ARMOUR },</a>
<a name="ln5180">        { ARM_QUICKSILVER_DRAGON_HIDE,  ARM_QUICKSILVER_DRAGON_ARMOUR },</a>
<a name="ln5181">    };</a>
<a name="ln5182">    // ASSUMPTION: there was no such thing as an artefact hide</a>
<a name="ln5183">    if (item.base_type == OBJ_ARMOUR &amp;&amp; hide_to_armour.count(item.sub_type))</a>
<a name="ln5184">    {</a>
<a name="ln5185">        auto subtype_ptr = map_find(hide_to_armour, item.sub_type);</a>
<a name="ln5186">        ASSERT(subtype_ptr);</a>
<a name="ln5187">        item.sub_type = *subtype_ptr;</a>
<a name="ln5188">    }</a>
<a name="ln5189"> </a>
<a name="ln5190">    if (th.getMinorVersion() &lt; TAG_MINOR_HIDE_TO_SCALE &amp;&amp; armour_is_hide(item))</a>
<a name="ln5191">    {</a>
<a name="ln5192">        _fixup_dragon_artefact_name(item, ARTEFACT_NAME_KEY);</a>
<a name="ln5193">        _fixup_dragon_artefact_name(item, ARTEFACT_APPEAR_KEY);</a>
<a name="ln5194">    }</a>
<a name="ln5195"> </a>
<a name="ln5196">    if (item.is_type(OBJ_FOOD, FOOD_BREAD_RATION))</a>
<a name="ln5197">        item.sub_type = FOOD_RATION;</a>
<a name="ln5198">    else if (item.is_type(OBJ_FOOD, FOOD_ROYAL_JELLY))</a>
<a name="ln5199">    {</a>
<a name="ln5200">        item.sub_type = FOOD_RATION;</a>
<a name="ln5201">        item.quantity = max(1, div_rand_round(item.quantity, 3));</a>
<a name="ln5202">    }</a>
<a name="ln5203">    else if (item.is_type(OBJ_FOOD, FOOD_FRUIT))</a>
<a name="ln5204">    {</a>
<a name="ln5205">        item.sub_type = FOOD_RATION;</a>
<a name="ln5206">        item.quantity = max(1, div_rand_round(item.quantity, 5));</a>
<a name="ln5207">    }</a>
<a name="ln5208">    if (item.is_type(OBJ_FOOD, FOOD_RATION) &amp;&amp; item.pos == ITEM_IN_INVENTORY)</a>
<a name="ln5209">    {</a>
<a name="ln5210">        item.props[&quot;item_tile_name&quot;] = &quot;food_ration_inventory&quot;;</a>
<a name="ln5211">        bind_item_tile(item);</a>
<a name="ln5212">    }</a>
<a name="ln5213"> </a>
<a name="ln5214">    if (th.getMinorVersion() &lt; TAG_MINOR_THROW_CONSOLIDATION</a>
<a name="ln5215">        &amp;&amp; item.base_type == OBJ_MISSILES)</a>
<a name="ln5216">    {</a>
<a name="ln5217">        if (item.sub_type == MI_NEEDLE)</a>
<a name="ln5218">        {</a>
<a name="ln5219">            item.sub_type = MI_DART;</a>
<a name="ln5220"> </a>
<a name="ln5221">            switch (item.brand)</a>
<a name="ln5222">            {</a>
<a name="ln5223">                case SPMSL_PARALYSIS:</a>
<a name="ln5224">                case SPMSL_SLOW:</a>
<a name="ln5225">                case SPMSL_SLEEP:</a>
<a name="ln5226">                case SPMSL_CONFUSION:</a>
<a name="ln5227">                case SPMSL_SICKNESS:</a>
<a name="ln5228">                    item.brand = SPMSL_BLINDING;</a>
<a name="ln5229">                    break;</a>
<a name="ln5230">                default: break;</a>
<a name="ln5231">            }</a>
<a name="ln5232">        }</a>
<a name="ln5233">        else if (item.sub_type == MI_BOOMERANG || item.sub_type == MI_JAVELIN)</a>
<a name="ln5234">        {</a>
<a name="ln5235">            switch (item.brand)</a>
<a name="ln5236">            {</a>
<a name="ln5237">                case SPMSL_RETURNING:</a>
<a name="ln5238">                case SPMSL_EXPLODING:</a>
<a name="ln5239">                case SPMSL_POISONED:</a>
<a name="ln5240">                case SPMSL_PENETRATION:</a>
<a name="ln5241">                    item.brand = SPMSL_NORMAL;</a>
<a name="ln5242">                    break;</a>
<a name="ln5243">                case SPMSL_STEEL:</a>
<a name="ln5244">                    item.brand = SPMSL_SILVER;</a>
<a name="ln5245">                    break;</a>
<a name="ln5246">            }</a>
<a name="ln5247">        }</a>
<a name="ln5248">    }</a>
<a name="ln5249"> </a>
<a name="ln5250">#endif</a>
<a name="ln5251"> </a>
<a name="ln5252">    if (is_unrandom_artefact(item))</a>
<a name="ln5253">        setup_unrandart(item, false);</a>
<a name="ln5254"> </a>
<a name="ln5255">    bind_item_tile(item);</a>
<a name="ln5256">}</a>
<a name="ln5257"> </a>
<a name="ln5258">#define MAP_SERIALIZE_FLAGS_MASK 3</a>
<a name="ln5259">#define MAP_SERIALIZE_FLAGS_8 1</a>
<a name="ln5260">#define MAP_SERIALIZE_FLAGS_16 2</a>
<a name="ln5261">#define MAP_SERIALIZE_FLAGS_32 3</a>
<a name="ln5262"> </a>
<a name="ln5263">#define MAP_SERIALIZE_FEATURE 4</a>
<a name="ln5264">#define MAP_SERIALIZE_FEATURE_COLOUR 8</a>
<a name="ln5265">#define MAP_SERIALIZE_ITEM 0x10</a>
<a name="ln5266">#define MAP_SERIALIZE_CLOUD 0x20</a>
<a name="ln5267">#define MAP_SERIALIZE_MONSTER 0x40</a>
<a name="ln5268"> </a>
<a name="ln5269">void marshallMapCell(writer &amp;th, const map_cell &amp;cell)</a>
<a name="ln5270">{</a>
<a name="ln5271">    unsigned flags = 0;</a>
<a name="ln5272"> </a>
<a name="ln5273">    if (cell.flags &gt; 0xffff)</a>
<a name="ln5274">        flags |= MAP_SERIALIZE_FLAGS_32;</a>
<a name="ln5275">    else if (cell.flags &gt; 0xff)</a>
<a name="ln5276">        flags |= MAP_SERIALIZE_FLAGS_16;</a>
<a name="ln5277">    else if (cell.flags)</a>
<a name="ln5278">        flags |= MAP_SERIALIZE_FLAGS_8;</a>
<a name="ln5279"> </a>
<a name="ln5280">    if (cell.feat() != DNGN_UNSEEN)</a>
<a name="ln5281">        flags |= MAP_SERIALIZE_FEATURE;</a>
<a name="ln5282"> </a>
<a name="ln5283">    if (cell.feat_colour())</a>
<a name="ln5284">        flags |= MAP_SERIALIZE_FEATURE_COLOUR;</a>
<a name="ln5285"> </a>
<a name="ln5286">    if (cell.cloud() != CLOUD_NONE)</a>
<a name="ln5287">        flags |= MAP_SERIALIZE_CLOUD;</a>
<a name="ln5288"> </a>
<a name="ln5289">    if (cell.item())</a>
<a name="ln5290">        flags |= MAP_SERIALIZE_ITEM;</a>
<a name="ln5291"> </a>
<a name="ln5292">    if (cell.monster() != MONS_NO_MONSTER)</a>
<a name="ln5293">        flags |= MAP_SERIALIZE_MONSTER;</a>
<a name="ln5294"> </a>
<a name="ln5295">    marshallUnsigned(th, flags);</a>
<a name="ln5296"> </a>
<a name="ln5297">    switch (flags &amp; MAP_SERIALIZE_FLAGS_MASK)</a>
<a name="ln5298">    {</a>
<a name="ln5299">    case MAP_SERIALIZE_FLAGS_8:</a>
<a name="ln5300">        marshallByte(th, static_cast&lt;int8_t&gt;(cell.flags));</a>
<a name="ln5301">        break;</a>
<a name="ln5302">    case MAP_SERIALIZE_FLAGS_16:</a>
<a name="ln5303">        marshallShort(th, static_cast&lt;int16_t&gt;(cell.flags));</a>
<a name="ln5304">        break;</a>
<a name="ln5305">    case MAP_SERIALIZE_FLAGS_32:</a>
<a name="ln5306">        marshallInt(th, static_cast&lt;int32_t&gt;(cell.flags));</a>
<a name="ln5307">        break;</a>
<a name="ln5308">    }</a>
<a name="ln5309"> </a>
<a name="ln5310">    if (flags &amp; MAP_SERIALIZE_FEATURE)</a>
<a name="ln5311">#if TAG_MAJOR_VERSION == 34</a>
<a name="ln5312">        marshallUnsigned(th, cell.feat());</a>
<a name="ln5313">#else</a>
<a name="ln5314">        marshallUByte(th, cell.feat());</a>
<a name="ln5315">#endif</a>
<a name="ln5316"> </a>
<a name="ln5317">    if (flags &amp; MAP_SERIALIZE_FEATURE_COLOUR)</a>
<a name="ln5318">        marshallUnsigned(th, cell.feat_colour());</a>
<a name="ln5319"> </a>
<a name="ln5320">    if (feat_is_trap(cell.feat()))</a>
<a name="ln5321">        marshallByte(th, cell.trap());</a>
<a name="ln5322"> </a>
<a name="ln5323">    if (flags &amp; MAP_SERIALIZE_CLOUD)</a>
<a name="ln5324">    {</a>
<a name="ln5325">        cloud_info* ci = cell.cloudinfo();</a>
<a name="ln5326">        marshallUnsigned(th, ci-&gt;type);</a>
<a name="ln5327">        marshallUnsigned(th, ci-&gt;colour);</a>
<a name="ln5328">        marshallUnsigned(th, ci-&gt;duration);</a>
<a name="ln5329">        marshallShort(th, ci-&gt;tile);</a>
<a name="ln5330">        marshallUByte(th, ci-&gt;killer);</a>
<a name="ln5331">    }</a>
<a name="ln5332"> </a>
<a name="ln5333">    if (flags &amp; MAP_SERIALIZE_ITEM)</a>
<a name="ln5334">        marshallItem(th, *cell.item(), true);</a>
<a name="ln5335"> </a>
<a name="ln5336">    if (flags &amp; MAP_SERIALIZE_MONSTER)</a>
<a name="ln5337">        _marshallMonsterInfo(th, *cell.monsterinfo());</a>
<a name="ln5338">}</a>
<a name="ln5339"> </a>
<a name="ln5340">void unmarshallMapCell(reader &amp;th, map_cell&amp; cell)</a>
<a name="ln5341">{</a>
<a name="ln5342">    unsigned flags = unmarshallUnsigned(th);</a>
<a name="ln5343">    unsigned cell_flags = 0;</a>
<a name="ln5344">    trap_type trap = TRAP_UNASSIGNED;</a>
<a name="ln5345"> </a>
<a name="ln5346">    cell.clear();</a>
<a name="ln5347"> </a>
<a name="ln5348">    switch (flags &amp; MAP_SERIALIZE_FLAGS_MASK)</a>
<a name="ln5349">    {</a>
<a name="ln5350">    case MAP_SERIALIZE_FLAGS_8:</a>
<a name="ln5351">        cell_flags = static_cast&lt;uint8_t&gt;(unmarshallByte(th));</a>
<a name="ln5352">        break;</a>
<a name="ln5353">    case MAP_SERIALIZE_FLAGS_16:</a>
<a name="ln5354">        cell_flags = static_cast&lt;uint16_t&gt;(unmarshallShort(th));</a>
<a name="ln5355">        break;</a>
<a name="ln5356">    case MAP_SERIALIZE_FLAGS_32:</a>
<a name="ln5357">        cell_flags = static_cast&lt;uint32_t&gt;(unmarshallInt(th));</a>
<a name="ln5358">        break;</a>
<a name="ln5359">    }</a>
<a name="ln5360"> </a>
<a name="ln5361">    dungeon_feature_type feature = DNGN_UNSEEN;</a>
<a name="ln5362">    unsigned feat_colour = 0;</a>
<a name="ln5363"> </a>
<a name="ln5364">    if (flags &amp; MAP_SERIALIZE_FEATURE)</a>
<a name="ln5365">#if TAG_MAJOR_VERSION == 34</a>
<a name="ln5366">        feature = unmarshallFeatureType_Info(th);</a>
<a name="ln5367">#else</a>
<a name="ln5368">        feature = unmarshallFeatureType(th);</a>
<a name="ln5369">#endif</a>
<a name="ln5370"> </a>
<a name="ln5371">    if (flags &amp; MAP_SERIALIZE_FEATURE_COLOUR)</a>
<a name="ln5372">        feat_colour = unmarshallUnsigned(th);</a>
<a name="ln5373"> </a>
<a name="ln5374">    if (feat_is_trap(feature))</a>
<a name="ln5375">    {</a>
<a name="ln5376">        trap = (trap_type)unmarshallByte(th);</a>
<a name="ln5377">#if TAG_MAJOR_VERSION == 34</a>
<a name="ln5378">        if (th.getMinorVersion() == TAG_MINOR_0_11 &amp;&amp; trap &gt;= TRAP_TELEPORT)</a>
<a name="ln5379">            trap = (trap_type)(trap - 1);</a>
<a name="ln5380">        if (trap == TRAP_ALARM)</a>
<a name="ln5381">            feature = DNGN_TRAP_ALARM;</a>
<a name="ln5382">        else if (trap == TRAP_ZOT)</a>
<a name="ln5383">            feature = DNGN_TRAP_ZOT;</a>
<a name="ln5384">        else if (trap == TRAP_GOLUBRIA)</a>
<a name="ln5385">            feature = DNGN_PASSAGE_OF_GOLUBRIA;</a>
<a name="ln5386">#endif</a>
<a name="ln5387">    }</a>
<a name="ln5388"> </a>
<a name="ln5389">    cell.set_feature(feature, feat_colour, trap);</a>
<a name="ln5390"> </a>
<a name="ln5391">    if (flags &amp; MAP_SERIALIZE_CLOUD)</a>
<a name="ln5392">    {</a>
<a name="ln5393">        cloud_info ci;</a>
<a name="ln5394">        ci.type = (cloud_type)unmarshallUnsigned(th);</a>
<a name="ln5395">        unmarshallUnsigned(th, ci.colour);</a>
<a name="ln5396">        unmarshallUnsigned(th, ci.duration);</a>
<a name="ln5397">        ci.tile = unmarshallShort(th);</a>
<a name="ln5398">#if TAG_MAJOR_VERSION == 34</a>
<a name="ln5399">        if (th.getMinorVersion() &gt;= TAG_MINOR_CLOUD_OWNER)</a>
<a name="ln5400">#endif</a>
<a name="ln5401">        ci.killer = static_cast&lt;killer_type&gt;(unmarshallUByte(th));</a>
<a name="ln5402">        cell.set_cloud(ci);</a>
<a name="ln5403">    }</a>
<a name="ln5404"> </a>
<a name="ln5405">    if (flags &amp; MAP_SERIALIZE_ITEM)</a>
<a name="ln5406">    {</a>
<a name="ln5407">        item_def item;</a>
<a name="ln5408">        unmarshallItem(th, item);</a>
<a name="ln5409">        cell.set_item(item, false);</a>
<a name="ln5410">    }</a>
<a name="ln5411"> </a>
<a name="ln5412">    if (flags &amp; MAP_SERIALIZE_MONSTER)</a>
<a name="ln5413">    {</a>
<a name="ln5414">        monster_info mi;</a>
<a name="ln5415">        _unmarshallMonsterInfo(th, mi);</a>
<a name="ln5416">        cell.set_monster(mi);</a>
<a name="ln5417">    }</a>
<a name="ln5418"> </a>
<a name="ln5419">    // set this last so the other sets don't override this</a>
<a name="ln5420">    cell.flags = cell_flags;</a>
<a name="ln5421">}</a>
<a name="ln5422"> </a>
<a name="ln5423">static void _tag_construct_level_items(writer &amp;th)</a>
<a name="ln5424">{</a>
<a name="ln5425">    // how many traps?</a>
<a name="ln5426">    marshallShort(th, env.trap.size());</a>
<a name="ln5427">    for (const auto&amp; entry : env.trap)</a>
<a name="ln5428">    {</a>
<a name="ln5429">        const trap_def&amp; trap = entry.second;</a>
<a name="ln5430">        marshallByte(th, trap.type);</a>
<a name="ln5431">        marshallCoord(th, trap.pos);</a>
<a name="ln5432">        marshallShort(th, trap.ammo_qty);</a>
<a name="ln5433">        marshallUByte(th, trap.skill_rnd);</a>
<a name="ln5434">    }</a>
<a name="ln5435"> </a>
<a name="ln5436">    // how many items?</a>
<a name="ln5437">    const int ni = _last_used_index(mitm, MAX_ITEMS);</a>
<a name="ln5438">    marshallShort(th, ni);</a>
<a name="ln5439">    for (int i = 0; i &lt; ni; ++i)</a>
<a name="ln5440">        marshallItem(th, mitm[i]);</a>
<a name="ln5441">}</a>
<a name="ln5442"> </a>
<a name="ln5443">static void marshall_mon_enchant(writer &amp;th, const mon_enchant &amp;me)</a>
<a name="ln5444">{</a>
<a name="ln5445">    marshallShort(th, me.ench);</a>
<a name="ln5446">    marshallShort(th, me.degree);</a>
<a name="ln5447">    marshallShort(th, me.who);</a>
<a name="ln5448">    marshallInt(th, me.source);</a>
<a name="ln5449">    marshallShort(th, min(me.duration, INFINITE_DURATION));</a>
<a name="ln5450">    marshallShort(th, min(me.maxduration, INFINITE_DURATION));</a>
<a name="ln5451">}</a>
<a name="ln5452"> </a>
<a name="ln5453">static mon_enchant unmarshall_mon_enchant(reader &amp;th)</a>
<a name="ln5454">{</a>
<a name="ln5455">    mon_enchant me;</a>
<a name="ln5456">    me.ench        = static_cast&lt;enchant_type&gt;(unmarshallShort(th));</a>
<a name="ln5457">    me.degree      = unmarshallShort(th);</a>
<a name="ln5458">    me.who         = static_cast&lt;kill_category&gt;(unmarshallShort(th));</a>
<a name="ln5459">    me.source      = unmarshallInt(th);</a>
<a name="ln5460">    me.duration    = unmarshallShort(th);</a>
<a name="ln5461">    me.maxduration = unmarshallShort(th);</a>
<a name="ln5462">    return me;</a>
<a name="ln5463">}</a>
<a name="ln5464"> </a>
<a name="ln5465">enum mon_part_t</a>
<a name="ln5466">{</a>
<a name="ln5467">    MP_GHOST_DEMON      = BIT(0),</a>
<a name="ln5468">    MP_CONSTRICTION     = BIT(1),</a>
<a name="ln5469">    MP_ITEMS            = BIT(2),</a>
<a name="ln5470">    MP_SPELLS           = BIT(3),</a>
<a name="ln5471">};</a>
<a name="ln5472"> </a>
<a name="ln5473">void marshallMonster(writer &amp;th, const monster&amp; m)</a>
<a name="ln5474">{</a>
<a name="ln5475">    if (!m.alive())</a>
<a name="ln5476">    {</a>
<a name="ln5477">        marshallShort(th, MONS_NO_MONSTER);</a>
<a name="ln5478">        return;</a>
<a name="ln5479">    }</a>
<a name="ln5480"> </a>
<a name="ln5481">    uint32_t parts = 0;</a>
<a name="ln5482">    if (mons_is_ghost_demon(m.type))</a>
<a name="ln5483">        parts |= MP_GHOST_DEMON;</a>
<a name="ln5484">    if (m.is_constricted() || m.is_constricting())</a>
<a name="ln5485">        parts |= MP_CONSTRICTION;</a>
<a name="ln5486">    for (int i = 0; i &lt; NUM_MONSTER_SLOTS; i++)</a>
<a name="ln5487">        if (m.inv[i] != NON_ITEM)</a>
<a name="ln5488">            parts |= MP_ITEMS;</a>
<a name="ln5489">    if (m.spells.size() &gt; 0)</a>
<a name="ln5490">        parts |= MP_SPELLS;</a>
<a name="ln5491"> </a>
<a name="ln5492">    marshallShort(th, m.type);</a>
<a name="ln5493">    marshallUnsigned(th, parts);</a>
<a name="ln5494">    ASSERT(m.mid &gt; 0);</a>
<a name="ln5495">    marshallInt(th, m.mid);</a>
<a name="ln5496">    marshallString(th, m.mname);</a>
<a name="ln5497">    marshallByte(th, m.xp_tracking);</a>
<a name="ln5498">    marshallByte(th, m.get_experience_level());</a>
<a name="ln5499">    marshallByte(th, m.speed);</a>
<a name="ln5500">    marshallByte(th, m.speed_increment);</a>
<a name="ln5501">    marshallByte(th, m.behaviour);</a>
<a name="ln5502">    marshallByte(th, m.pos().x);</a>
<a name="ln5503">    marshallByte(th, m.pos().y);</a>
<a name="ln5504">    marshallByte(th, m.target.x);</a>
<a name="ln5505">    marshallByte(th, m.target.y);</a>
<a name="ln5506">    marshallCoord(th, m.firing_pos);</a>
<a name="ln5507">    marshallCoord(th, m.patrol_point);</a>
<a name="ln5508">    int help = m.travel_target;</a>
<a name="ln5509">    marshallByte(th, help);</a>
<a name="ln5510"> </a>
<a name="ln5511">    marshallShort(th, m.travel_path.size());</a>
<a name="ln5512">    for (coord_def pos : m.travel_path)</a>
<a name="ln5513">        marshallCoord(th, pos);</a>
<a name="ln5514"> </a>
<a name="ln5515">    marshallUnsigned(th, m.flags.flags);</a>
<a name="ln5516">    marshallInt(th, m.experience);</a>
<a name="ln5517"> </a>
<a name="ln5518">    marshallShort(th, m.enchantments.size());</a>
<a name="ln5519">    for (const auto &amp;entry : m.enchantments)</a>
<a name="ln5520">        marshall_mon_enchant(th, entry.second);</a>
<a name="ln5521">    marshallByte(th, m.ench_countdown);</a>
<a name="ln5522"> </a>
<a name="ln5523">    marshallShort(th, min(m.hit_points, MAX_MONSTER_HP));</a>
<a name="ln5524">    marshallShort(th, min(m.max_hit_points, MAX_MONSTER_HP));</a>
<a name="ln5525">    marshallInt(th, m.number);</a>
<a name="ln5526">    marshallShort(th, m.base_monster);</a>
<a name="ln5527">    marshallShort(th, m.colour);</a>
<a name="ln5528">    marshallInt(th, m.summoner);</a>
<a name="ln5529"> </a>
<a name="ln5530">    if (parts &amp; MP_ITEMS)</a>
<a name="ln5531">        for (int j = 0; j &lt; NUM_MONSTER_SLOTS; j++)</a>
<a name="ln5532">            marshallShort(th, m.inv[j]);</a>
<a name="ln5533">    if (parts &amp; MP_SPELLS)</a>
<a name="ln5534">        _marshallSpells(th, m.spells);</a>
<a name="ln5535">    marshallByte(th, m.god);</a>
<a name="ln5536">    marshallByte(th, m.attitude);</a>
<a name="ln5537">    marshallShort(th, m.foe);</a>
<a name="ln5538">    marshallInt(th, m.foe_memory);</a>
<a name="ln5539">    marshallShort(th, m.damage_friendly);</a>
<a name="ln5540">    marshallShort(th, m.damage_total);</a>
<a name="ln5541">    marshallByte(th, m.went_unseen_this_turn);</a>
<a name="ln5542">    marshallCoord(th, m.unseen_pos);</a>
<a name="ln5543"> </a>
<a name="ln5544">    if (parts &amp; MP_GHOST_DEMON)</a>
<a name="ln5545">    {</a>
<a name="ln5546">        // *Must* have ghost field set.</a>
<a name="ln5547">        ASSERT(m.ghost);</a>
<a name="ln5548">        _marshallGhost(th, *m.ghost);</a>
<a name="ln5549">    }</a>
<a name="ln5550"> </a>
<a name="ln5551">    if (parts &amp; MP_CONSTRICTION)</a>
<a name="ln5552">        _marshall_constriction(th, &amp;m);</a>
<a name="ln5553"> </a>
<a name="ln5554">    m.props.write(th);</a>
<a name="ln5555">}</a>
<a name="ln5556"> </a>
<a name="ln5557">static void _marshall_mi_attack(writer &amp;th, const mon_attack_def &amp;attk)</a>
<a name="ln5558">{</a>
<a name="ln5559">    marshallInt(th, attk.type);</a>
<a name="ln5560">    marshallInt(th, attk.flavour);</a>
<a name="ln5561">    marshallInt(th, attk.damage);</a>
<a name="ln5562">}</a>
<a name="ln5563"> </a>
<a name="ln5564">static mon_attack_def _unmarshall_mi_attack(reader &amp;th)</a>
<a name="ln5565">{</a>
<a name="ln5566">    mon_attack_def attk;</a>
<a name="ln5567">    attk.type = static_cast&lt;attack_type&gt;(unmarshallInt(th));</a>
<a name="ln5568">    attk.flavour = static_cast&lt;attack_flavour&gt;(unmarshallInt(th));</a>
<a name="ln5569">    attk.damage = unmarshallInt(th);</a>
<a name="ln5570"> </a>
<a name="ln5571">    return attk;</a>
<a name="ln5572">}</a>
<a name="ln5573"> </a>
<a name="ln5574">void _marshallMonsterInfo(writer &amp;th, const monster_info&amp; mi)</a>
<a name="ln5575">{</a>
<a name="ln5576">    _marshallFixedBitVector&lt;NUM_MB_FLAGS&gt;(th, mi.mb);</a>
<a name="ln5577">    marshallString(th, mi.mname);</a>
<a name="ln5578">#if TAG_MAJOR_VERSION == 34</a>
<a name="ln5579">    marshallUnsigned(th, mi.type);</a>
<a name="ln5580">    marshallUnsigned(th, mi.base_type);</a>
<a name="ln5581">#else</a>
<a name="ln5582">    marshallShort(th, mi.type);</a>
<a name="ln5583">    marshallShort(th, mi.base_type);</a>
<a name="ln5584">#endif</a>
<a name="ln5585">    marshallUnsigned(th, mi.number);</a>
<a name="ln5586">    marshallInt(th, mi._colour);</a>
<a name="ln5587">    marshallUnsigned(th, mi.attitude);</a>
<a name="ln5588">    marshallUnsigned(th, mi.threat);</a>
<a name="ln5589">    marshallUnsigned(th, mi.dam);</a>
<a name="ln5590">    marshallUnsigned(th, mi.fire_blocker);</a>
<a name="ln5591">    marshallString(th, mi.description);</a>
<a name="ln5592">    marshallString(th, mi.quote);</a>
<a name="ln5593">    marshallUnsigned(th, mi.holi.flags);</a>
<a name="ln5594">    marshallUnsigned(th, mi.mintel);</a>
<a name="ln5595">    marshallUnsigned(th, mi.hd);</a>
<a name="ln5596">    marshallUnsigned(th, mi.ac);</a>
<a name="ln5597">    marshallUnsigned(th, mi.ev);</a>
<a name="ln5598">    marshallUnsigned(th, mi.base_ev);</a>
<a name="ln5599">    marshallInt(th, mi.mresists);</a>
<a name="ln5600">    marshallUnsigned(th, mi.mitemuse);</a>
<a name="ln5601">    marshallByte(th, mi.mbase_speed);</a>
<a name="ln5602">    marshallByte(th, mi.menergy.move);</a>
<a name="ln5603">    marshallByte(th, mi.menergy.swim);</a>
<a name="ln5604">    marshallByte(th, mi.menergy.attack);</a>
<a name="ln5605">    marshallByte(th, mi.menergy.missile);</a>
<a name="ln5606">    marshallByte(th, mi.menergy.spell);</a>
<a name="ln5607">    marshallByte(th, mi.menergy.special);</a>
<a name="ln5608">    marshallByte(th, mi.menergy.item);</a>
<a name="ln5609">    marshallByte(th, mi.menergy.pickup_percent);</a>
<a name="ln5610">    for (int i = 0; i &lt; MAX_NUM_ATTACKS; ++i)</a>
<a name="ln5611">        _marshall_mi_attack(th, mi.attack[i]);</a>
<a name="ln5612">    for (unsigned int i = 0; i &lt;= MSLOT_LAST_VISIBLE_SLOT; ++i)</a>
<a name="ln5613">    {</a>
<a name="ln5614">        if (mi.inv[i])</a>
<a name="ln5615">        {</a>
<a name="ln5616">            marshallBoolean(th, true);</a>
<a name="ln5617">            marshallItem(th, *mi.inv[i], true);</a>
<a name="ln5618">        }</a>
<a name="ln5619">        else</a>
<a name="ln5620">            marshallBoolean(th, false);</a>
<a name="ln5621">    }</a>
<a name="ln5622">    if (mons_is_pghost(mi.type))</a>
<a name="ln5623">    {</a>
<a name="ln5624">        marshallUnsigned(th, mi.i_ghost.species);</a>
<a name="ln5625">        marshallUnsigned(th, mi.i_ghost.job);</a>
<a name="ln5626">        marshallUnsigned(th, mi.i_ghost.religion);</a>
<a name="ln5627">        marshallUnsigned(th, mi.i_ghost.best_skill);</a>
<a name="ln5628">        marshallShort(th, mi.i_ghost.best_skill_rank);</a>
<a name="ln5629">        marshallShort(th, mi.i_ghost.xl_rank);</a>
<a name="ln5630">        marshallShort(th, mi.i_ghost.damage);</a>
<a name="ln5631">        marshallShort(th, mi.i_ghost.ac);</a>
<a name="ln5632">    }</a>
<a name="ln5633"> </a>
<a name="ln5634">    mi.props.write(th);</a>
<a name="ln5635">}</a>
<a name="ln5636"> </a>
<a name="ln5637">void _unmarshallMonsterInfo(reader &amp;th, monster_info&amp; mi)</a>
<a name="ln5638">{</a>
<a name="ln5639">    _unmarshallFixedBitVector&lt;NUM_MB_FLAGS&gt;(th, mi.mb);</a>
<a name="ln5640">    mi.mname = unmarshallString(th);</a>
<a name="ln5641">#if TAG_MAJOR_VERSION == 34</a>
<a name="ln5642">    mi.type = unmarshallMonType_Info(th);</a>
<a name="ln5643">    ASSERT(!invalid_monster_type(mi.type));</a>
<a name="ln5644">    mi.base_type = unmarshallMonType_Info(th);</a>
<a name="ln5645">    if ((mons_genus(mi.type) == MONS_DRACONIAN</a>
<a name="ln5646">        || (mons_genus(mi.type) == MONS_DEMONSPAWN</a>
<a name="ln5647">            &amp;&amp; th.getMinorVersion() &gt;= TAG_MINOR_DEMONSPAWN))</a>
<a name="ln5648">        &amp;&amp; th.getMinorVersion() &lt; TAG_MINOR_NO_DRACO_TYPE)</a>
<a name="ln5649">    {</a>
<a name="ln5650">        unmarshallMonType_Info(th); // was draco_type</a>
<a name="ln5651">    }</a>
<a name="ln5652">#else</a>
<a name="ln5653">    mi.type = unmarshallMonType(th);</a>
<a name="ln5654">    ASSERT(!invalid_monster_type(mi.type));</a>
<a name="ln5655">    mi.base_type = unmarshallMonType(th);</a>
<a name="ln5656">#endif</a>
<a name="ln5657">    unmarshallUnsigned(th, mi.number);</a>
<a name="ln5658">#if TAG_MAJOR_VERSION == 34</a>
<a name="ln5659">    if (th.getMinorVersion() &lt; TAG_MINOR_MON_COLOUR_LOOKUP)</a>
<a name="ln5660">        mi._colour = int(unmarshallUnsigned(th));</a>
<a name="ln5661">    else</a>
<a name="ln5662">#endif</a>
<a name="ln5663">        mi._colour = unmarshallInt(th);</a>
<a name="ln5664">    unmarshallUnsigned(th, mi.attitude);</a>
<a name="ln5665">    unmarshallUnsigned(th, mi.threat);</a>
<a name="ln5666">    unmarshallUnsigned(th, mi.dam);</a>
<a name="ln5667">    unmarshallUnsigned(th, mi.fire_blocker);</a>
<a name="ln5668">    mi.description = unmarshallString(th);</a>
<a name="ln5669">    mi.quote = unmarshallString(th);</a>
<a name="ln5670"> </a>
<a name="ln5671">    uint64_t holi_flags = unmarshallUnsigned(th);</a>
<a name="ln5672">#if TAG_MAJOR_VERSION == 34</a>
<a name="ln5673">    if (th.getMinorVersion() &gt;= TAG_MINOR_MULTI_HOLI)</a>
<a name="ln5674">    {</a>
<a name="ln5675">#endif</a>
<a name="ln5676">        mi.holi.flags = holi_flags;</a>
<a name="ln5677">#if TAG_MAJOR_VERSION == 34</a>
<a name="ln5678">    }</a>
<a name="ln5679">    else</a>
<a name="ln5680">        mi.holi.flags = 1&lt;&lt;holi_flags;</a>
<a name="ln5681">#endif</a>
<a name="ln5682"> </a>
<a name="ln5683">#if TAG_MAJOR_VERSION == 34</a>
<a name="ln5684">    // XXX: special case MH_UNDEAD becoming MH_UNDEAD | MH_NATURAL</a>
<a name="ln5685">    // to save MF_FAKE_UNDEAD. Beware if you add a NATURAL bit</a>
<a name="ln5686">    // to an undead monster.</a>
<a name="ln5687">    if (mons_class_holiness(mi.type) &amp; ~mi.holi</a>
<a name="ln5688">        &amp;&amp; !(mi.holi &amp; MH_UNDEAD) &amp;&amp; !(mons_class_holiness(mi.type) &amp; MH_NATURAL))</a>
<a name="ln5689">    {</a>
<a name="ln5690">        mi.holi |= mons_class_holiness(mi.type);</a>
<a name="ln5691">    }</a>
<a name="ln5692">#endif</a>
<a name="ln5693"> </a>
<a name="ln5694">    unmarshallUnsigned(th, mi.mintel);</a>
<a name="ln5695"> </a>
<a name="ln5696">#if TAG_MAJOR_VERSION == 34</a>
<a name="ln5697">    if (th.getMinorVersion() &gt;= TAG_MINOR_MON_HD_INFO)</a>
<a name="ln5698">    {</a>
<a name="ln5699">#endif</a>
<a name="ln5700">        unmarshallUnsigned(th, mi.hd);</a>
<a name="ln5701">#if TAG_MAJOR_VERSION == 34</a>
<a name="ln5702">    }</a>
<a name="ln5703">    else</a>
<a name="ln5704">        mi.hd = mons_class_hit_dice(mi.type);</a>
<a name="ln5705"> </a>
<a name="ln5706">    if (th.getMinorVersion() &gt;= TAG_MINOR_DISPLAY_MON_AC_EV)</a>
<a name="ln5707">    {</a>
<a name="ln5708">#endif</a>
<a name="ln5709">        unmarshallUnsigned(th, mi.ac);</a>
<a name="ln5710">        unmarshallUnsigned(th, mi.ev);</a>
<a name="ln5711">        unmarshallUnsigned(th, mi.base_ev);</a>
<a name="ln5712">#if TAG_MAJOR_VERSION == 34</a>
<a name="ln5713">    }</a>
<a name="ln5714">    else</a>
<a name="ln5715">    {</a>
<a name="ln5716">        mi.ac = get_mons_class_ac(mi.type);</a>
<a name="ln5717">        mi.ev = mi.base_ev = get_mons_class_ev(mi.type);</a>
<a name="ln5718">    }</a>
<a name="ln5719">#endif</a>
<a name="ln5720"> </a>
<a name="ln5721">    mi.mr = mons_class_res_magic(mi.type, mi.base_type);</a>
<a name="ln5722">    mi.can_see_invis = mons_class_sees_invis(mi.type, mi.base_type);</a>
<a name="ln5723"> </a>
<a name="ln5724">    mi.mresists = unmarshallInt(th);</a>
<a name="ln5725">#if TAG_MAJOR_VERSION == 34</a>
<a name="ln5726">    if (mi.mresists &amp; MR_OLD_RES_ACID)</a>
<a name="ln5727">        set_resist(mi.mresists, MR_RES_ACID, 3);</a>
<a name="ln5728">#endif</a>
<a name="ln5729">    unmarshallUnsigned(th, mi.mitemuse);</a>
<a name="ln5730">    mi.mbase_speed = unmarshallByte(th);</a>
<a name="ln5731"> </a>
<a name="ln5732">#if TAG_MAJOR_VERSION == 34</a>
<a name="ln5733">    // See comment in unmarshallMonster(): this could be an elemental</a>
<a name="ln5734">    // wellspring masquerading as a spectral weapon, or a polymoth masquerading</a>
<a name="ln5735">    // as a wellspring.</a>
<a name="ln5736">    if (th.getMinorVersion() &lt; TAG_MINOR_CANARIES</a>
<a name="ln5737">        &amp;&amp; th.getMinorVersion() &gt;= TAG_MINOR_WAR_DOG_REMOVAL</a>
<a name="ln5738">        &amp;&amp; mi.type &gt;= MONS_SPECTRAL_WEAPON</a>
<a name="ln5739">        &amp;&amp; mi.type &lt;= MONS_POLYMOTH)</a>
<a name="ln5740">    {</a>
<a name="ln5741">        switch (mi.base_speed())</a>
<a name="ln5742">        {</a>
<a name="ln5743">        case 10:</a>
<a name="ln5744">            mi.type = MONS_ELEMENTAL_WELLSPRING;</a>
<a name="ln5745">            break;</a>
<a name="ln5746">        case 12:</a>
<a name="ln5747">            mi.type = MONS_POLYMOTH;</a>
<a name="ln5748">            break;</a>
<a name="ln5749">        case 25:</a>
<a name="ln5750">        case 30:</a>
<a name="ln5751">            mi.type = MONS_SPECTRAL_WEAPON;</a>
<a name="ln5752">            break;</a>
<a name="ln5753">        default:</a>
<a name="ln5754">            die(&quot;Unexpected monster_info with type %d and speed %d&quot;,</a>
<a name="ln5755">                mi.type, mi.base_speed());</a>
<a name="ln5756">        }</a>
<a name="ln5757">    }</a>
<a name="ln5758"> </a>
<a name="ln5759">    // As above; this could be one of several monsters.</a>
<a name="ln5760">    if (th.getMinorVersion() &lt; TAG_MINOR_DEMONSPAWN</a>
<a name="ln5761">        &amp;&amp; mi.type &gt;= MONS_MONSTROUS_DEMONSPAWN</a>
<a name="ln5762">        &amp;&amp; mi.type &lt;= MONS_SALAMANDER_MYSTIC)</a>
<a name="ln5763">    {</a>
<a name="ln5764">        switch (mi.colour(true))</a>
<a name="ln5765">        {</a>
<a name="ln5766">        case BROWN:        // monstrous demonspawn, naga ritualist</a>
<a name="ln5767">            if (mi.spells[0].spell == SPELL_FORCE_LANCE)</a>
<a name="ln5768">                mi.type = MONS_NAGA_RITUALIST;</a>
<a name="ln5769">            else</a>
<a name="ln5770">                mi.type = MONS_MONSTROUS_DEMONSPAWN;</a>
<a name="ln5771">            break;</a>
<a name="ln5772">        case BLUE:         // gelid demonspawn</a>
<a name="ln5773">            mi.type = MONS_GELID_DEMONSPAWN;</a>
<a name="ln5774">            break;</a>
<a name="ln5775">        case RED:          // infernal demonspawn</a>
<a name="ln5776">            mi.type = MONS_INFERNAL_DEMONSPAWN;</a>
<a name="ln5777">            break;</a>
<a name="ln5778">        case LIGHTGRAY:    // torturous demonspawn, naga sharpshooter</a>
<a name="ln5779">            if (mi.spells[0].spell == SPELL_PORTAL_PROJECTILE)</a>
<a name="ln5780">                mi.type = MONS_NAGA_SHARPSHOOTER;</a>
<a name="ln5781">            else</a>
<a name="ln5782">                mi.type = MONS_TORTUROUS_DEMONSPAWN;</a>
<a name="ln5783">            break;</a>
<a name="ln5784">        case LIGHTBLUE:    // blood saint, shock serpent</a>
<a name="ln5785">            if (mi.base_type != MONS_NO_MONSTER)</a>
<a name="ln5786">                mi.type = MONS_BLOOD_SAINT;</a>
<a name="ln5787">            else</a>
<a name="ln5788">                mi.type = MONS_SHOCK_SERPENT;</a>
<a name="ln5789">            break;</a>
<a name="ln5790">        case LIGHTCYAN:    // warmonger, drowned soul</a>
<a name="ln5791">            if (mi.base_type != MONS_NO_MONSTER)</a>
<a name="ln5792">                mi.type = MONS_WARMONGER;</a>
<a name="ln5793">            else</a>
<a name="ln5794">                mi.type = MONS_DROWNED_SOUL;</a>
<a name="ln5795">            break;</a>
<a name="ln5796">        case LIGHTGREEN:   // corrupter</a>
<a name="ln5797">            mi.type = MONS_CORRUPTER;</a>
<a name="ln5798">            break;</a>
<a name="ln5799">        case LIGHTMAGENTA: // black sun</a>
<a name="ln5800">            mi.type = MONS_BLACK_SUN;</a>
<a name="ln5801">            break;</a>
<a name="ln5802">        case CYAN:         // worldbinder</a>
<a name="ln5803">            mi.type = MONS_WORLDBINDER;</a>
<a name="ln5804">            break;</a>
<a name="ln5805">        case MAGENTA:      // vine stalker, mana viper, grand avatar</a>
<a name="ln5806">            if (mi.base_speed() == 30)</a>
<a name="ln5807">                mi.type = MONS_GRAND_AVATAR;</a>
<a name="ln5808">            else</a>
<a name="ln5809">                mi.type = MONS_MANA_VIPER;</a>
<a name="ln5810">            break;</a>
<a name="ln5811">        case WHITE:        // salamander firebrand</a>
<a name="ln5812">            mi.type = MONS_SALAMANDER_FIREBRAND;</a>
<a name="ln5813">            break;</a>
<a name="ln5814">        case YELLOW:       // salamander mystic</a>
<a name="ln5815">            mi.type = MONS_SALAMANDER_MYSTIC;</a>
<a name="ln5816">            break;</a>
<a name="ln5817">        default:</a>
<a name="ln5818">            die(&quot;Unexpected monster with type %d and colour %d&quot;,</a>
<a name="ln5819">                mi.type, mi.colour(true));</a>
<a name="ln5820">        }</a>
<a name="ln5821">        if (mons_is_demonspawn(mi.type)</a>
<a name="ln5822">            &amp;&amp; mons_species(mi.type) == MONS_DEMONSPAWN</a>
<a name="ln5823">            &amp;&amp; mi.type != MONS_DEMONSPAWN)</a>
<a name="ln5824">        {</a>
<a name="ln5825">            ASSERT(mi.base_type != MONS_NO_MONSTER);</a>
<a name="ln5826">        }</a>
<a name="ln5827">    }</a>
<a name="ln5828"> </a>
<a name="ln5829">    if (th.getMinorVersion() &lt; TAG_MINOR_MONINFO_ENERGY)</a>
<a name="ln5830">        mi.menergy = mons_class_energy(mi.type);</a>
<a name="ln5831">    else</a>
<a name="ln5832">    {</a>
<a name="ln5833">#endif</a>
<a name="ln5834">    mi.menergy.move = unmarshallByte(th);</a>
<a name="ln5835">    mi.menergy.swim = unmarshallByte(th);</a>
<a name="ln5836">    mi.menergy.attack = unmarshallByte(th);</a>
<a name="ln5837">    mi.menergy.missile = unmarshallByte(th);</a>
<a name="ln5838">    mi.menergy.spell = unmarshallByte(th);</a>
<a name="ln5839">    mi.menergy.special = unmarshallByte(th);</a>
<a name="ln5840">    mi.menergy.item = unmarshallByte(th);</a>
<a name="ln5841">    mi.menergy.pickup_percent = unmarshallByte(th);</a>
<a name="ln5842">#if TAG_MAJOR_VERSION == 34</a>
<a name="ln5843">    }</a>
<a name="ln5844">#endif</a>
<a name="ln5845"> </a>
<a name="ln5846">    // Some TAG_MAJOR_VERSION == 34 saves suffered data loss here, beware.</a>
<a name="ln5847">    // Should be harmless, hopefully.</a>
<a name="ln5848">#if TAG_MAJOR_VERSION == 34</a>
<a name="ln5849">    if (th.getMinorVersion() &lt; TAG_MINOR_BOOL_FLIGHT)</a>
<a name="ln5850">        unmarshallUnsigned(th);</a>
<a name="ln5851">#endif</a>
<a name="ln5852">#if TAG_MAJOR_VERSION == 34</a>
<a name="ln5853">    if (th.getMinorVersion() &lt; TAG_MINOR_ATTACK_DESCS)</a>
<a name="ln5854">    {</a>
<a name="ln5855">        for (int i = 0; i &lt; MAX_NUM_ATTACKS; ++i)</a>
<a name="ln5856">        {</a>
<a name="ln5857">            mi.attack[i] = get_monster_data(mi.type)-&gt;attack[i];</a>
<a name="ln5858">            mi.attack[i].damage = 0;</a>
<a name="ln5859">        }</a>
<a name="ln5860">    }</a>
<a name="ln5861">    else</a>
<a name="ln5862">#endif</a>
<a name="ln5863">    for (int i = 0; i &lt; MAX_NUM_ATTACKS; ++i)</a>
<a name="ln5864">        mi.attack[i] = _unmarshall_mi_attack(th);</a>
<a name="ln5865"> </a>
<a name="ln5866">    for (unsigned int i = 0; i &lt;= MSLOT_LAST_VISIBLE_SLOT; ++i)</a>
<a name="ln5867">    {</a>
<a name="ln5868">        if (unmarshallBoolean(th))</a>
<a name="ln5869">        {</a>
<a name="ln5870">            mi.inv[i].reset(new item_def());</a>
<a name="ln5871">            unmarshallItem(th, *mi.inv[i]);</a>
<a name="ln5872">        }</a>
<a name="ln5873">    }</a>
<a name="ln5874"> </a>
<a name="ln5875">    if (mons_is_pghost(mi.type))</a>
<a name="ln5876">    {</a>
<a name="ln5877">        unmarshallUnsigned(th, mi.i_ghost.species);</a>
<a name="ln5878">        unmarshallUnsigned(th, mi.i_ghost.job);</a>
<a name="ln5879">        unmarshallUnsigned(th, mi.i_ghost.religion);</a>
<a name="ln5880">        unmarshallUnsigned(th, mi.i_ghost.best_skill);</a>
<a name="ln5881">        mi.i_ghost.best_skill_rank = unmarshallShort(th);</a>
<a name="ln5882">        mi.i_ghost.xl_rank = unmarshallShort(th);</a>
<a name="ln5883">        mi.i_ghost.damage = unmarshallShort(th);</a>
<a name="ln5884">        mi.i_ghost.ac = unmarshallShort(th);</a>
<a name="ln5885">    }</a>
<a name="ln5886">#if TAG_MAJOR_VERSION == 34</a>
<a name="ln5887">    if ((mons_is_ghost_demon(mi.type)</a>
<a name="ln5888">         || (mi.type == MONS_LICH || mi.type == MONS_ANCIENT_LICH</a>
<a name="ln5889">             || mi.type == MONS_SPELLFORGED_SERVITOR)</a>
<a name="ln5890">            &amp;&amp; th.getMinorVersion() &lt; TAG_MINOR_EXORCISE)</a>
<a name="ln5891">        &amp;&amp; th.getMinorVersion() &gt;= TAG_MINOR_GHOST_SINV</a>
<a name="ln5892">        &amp;&amp; th.getMinorVersion() &lt; TAG_MINOR_GHOST_NOSINV)</a>
<a name="ln5893">    {</a>
<a name="ln5894">        unmarshallBoolean(th); // was can_sinv</a>
<a name="ln5895">    }</a>
<a name="ln5896">#endif</a>
<a name="ln5897"> </a>
<a name="ln5898">    mi.props.clear();</a>
<a name="ln5899">    mi.props.read(th);</a>
<a name="ln5900"> </a>
<a name="ln5901">#if TAG_MAJOR_VERSION == 34</a>
<a name="ln5902">    if (mi.type == MONS_ZOMBIE_SMALL || mi.type == MONS_ZOMBIE_LARGE)</a>
<a name="ln5903">        mi.type = MONS_ZOMBIE;</a>
<a name="ln5904">    if (mi.type == MONS_SKELETON_SMALL || mi.type == MONS_SKELETON_LARGE)</a>
<a name="ln5905">        mi.type = MONS_SKELETON;</a>
<a name="ln5906">    if (mi.type == MONS_SIMULACRUM_SMALL || mi.type == MONS_SIMULACRUM_LARGE)</a>
<a name="ln5907">        mi.type = MONS_SIMULACRUM;</a>
<a name="ln5908">    if (th.getMinorVersion() &lt; TAG_MINOR_WAR_DOG_REMOVAL)</a>
<a name="ln5909">    {</a>
<a name="ln5910">        if (mi.type == MONS_WAR_DOG)</a>
<a name="ln5911">            mi.type = MONS_WOLF;</a>
<a name="ln5912">    }</a>
<a name="ln5913">#endif</a>
<a name="ln5914"> </a>
<a name="ln5915">    if (mons_is_removed(mi.type))</a>
<a name="ln5916">    {</a>
<a name="ln5917">        mi.type = MONS_GHOST;</a>
<a name="ln5918">        mi.props.clear();</a>
<a name="ln5919">    }</a>
<a name="ln5920">}</a>
<a name="ln5921"> </a>
<a name="ln5922">static void _tag_construct_level_monsters(writer &amp;th)</a>
<a name="ln5923">{</a>
<a name="ln5924">    int nm = 0;</a>
<a name="ln5925">    for (int i = 0; i &lt; MAX_MONS_ALLOC; ++i)</a>
<a name="ln5926">        if (env.mons_alloc[i] != MONS_NO_MONSTER)</a>
<a name="ln5927">            nm = i + 1;</a>
<a name="ln5928"> </a>
<a name="ln5929">    // how many mons_alloc?</a>
<a name="ln5930">    marshallByte(th, nm);</a>
<a name="ln5931">    for (int i = 0; i &lt; nm; ++i)</a>
<a name="ln5932">        marshallShort(th, env.mons_alloc[i]);</a>
<a name="ln5933"> </a>
<a name="ln5934">    // how many monsters?</a>
<a name="ln5935">    nm = _last_used_index(menv, MAX_MONSTERS);</a>
<a name="ln5936">    marshallShort(th, nm);</a>
<a name="ln5937"> </a>
<a name="ln5938">    for (int i = 0; i &lt; nm; i++)</a>
<a name="ln5939">    {</a>
<a name="ln5940">        monster&amp; m(menv[i]);</a>
<a name="ln5941"> </a>
<a name="ln5942">#if defined(DEBUG) || defined(DEBUG_MONS_SCAN)</a>
<a name="ln5943">        if (m.type != MONS_NO_MONSTER)</a>
<a name="ln5944">        {</a>
<a name="ln5945">            if (invalid_monster_type(m.type))</a>
<a name="ln5946">            {</a>
<a name="ln5947">                mprf(MSGCH_ERROR, &quot;Marshalled monster #%d %s&quot;,</a>
<a name="ln5948">                     i, m.name(DESC_PLAIN, true).c_str());</a>
<a name="ln5949">            }</a>
<a name="ln5950">            if (!in_bounds(m.pos()))</a>
<a name="ln5951">            {</a>
<a name="ln5952">                mprf(MSGCH_ERROR,</a>
<a name="ln5953">                     &quot;Marshalled monster #%d %s out of bounds at (%d, %d)&quot;,</a>
<a name="ln5954">                     i, m.name(DESC_PLAIN, true).c_str(),</a>
<a name="ln5955">                     m.pos().x, m.pos().y);</a>
<a name="ln5956">            }</a>
<a name="ln5957">        }</a>
<a name="ln5958">#endif</a>
<a name="ln5959">        marshallMonster(th, m);</a>
<a name="ln5960">    }</a>
<a name="ln5961">}</a>
<a name="ln5962"> </a>
<a name="ln5963">void _tag_construct_level_tiles(writer &amp;th)</a>
<a name="ln5964">{</a>
<a name="ln5965">    // Map grids.</a>
<a name="ln5966">    // how many X?</a>
<a name="ln5967">    marshallShort(th, GXM);</a>
<a name="ln5968">    // how many Y?</a>
<a name="ln5969">    marshallShort(th, GYM);</a>
<a name="ln5970"> </a>
<a name="ln5971">    marshallShort(th, env.tile_names.size());</a>
<a name="ln5972">    for (const string &amp;name : env.tile_names)</a>
<a name="ln5973">    {</a>
<a name="ln5974">        marshallString(th, name);</a>
<a name="ln5975">#ifdef DEBUG_TILE_NAMES</a>
<a name="ln5976">        mprf(&quot;Writing '%s' into save.&quot;, name.c_str());</a>
<a name="ln5977">#endif</a>
<a name="ln5978">    }</a>
<a name="ln5979"> </a>
<a name="ln5980">    // flavour</a>
<a name="ln5981">    marshallShort(th, env.tile_default.wall_idx);</a>
<a name="ln5982">    marshallShort(th, env.tile_default.floor_idx);</a>
<a name="ln5983"> </a>
<a name="ln5984">    marshallShort(th, env.tile_default.wall);</a>
<a name="ln5985">    marshallShort(th, env.tile_default.floor);</a>
<a name="ln5986">    marshallShort(th, env.tile_default.special);</a>
<a name="ln5987"> </a>
<a name="ln5988">    for (int count_x = 0; count_x &lt; GXM; count_x++)</a>
<a name="ln5989">        for (int count_y = 0; count_y &lt; GYM; count_y++)</a>
<a name="ln5990">        {</a>
<a name="ln5991">            marshallShort(th, env.tile_flv[count_x][count_y].wall_idx);</a>
<a name="ln5992">            marshallShort(th, env.tile_flv[count_x][count_y].floor_idx);</a>
<a name="ln5993">            marshallShort(th, env.tile_flv[count_x][count_y].feat_idx);</a>
<a name="ln5994"> </a>
<a name="ln5995">            marshallShort(th, env.tile_flv[count_x][count_y].wall);</a>
<a name="ln5996">            marshallShort(th, env.tile_flv[count_x][count_y].floor);</a>
<a name="ln5997">            marshallShort(th, env.tile_flv[count_x][count_y].feat);</a>
<a name="ln5998">            marshallShort(th, env.tile_flv[count_x][count_y].special);</a>
<a name="ln5999">        }</a>
<a name="ln6000"> </a>
<a name="ln6001">    marshallInt(th, TILE_WALL_MAX);</a>
<a name="ln6002">}</a>
<a name="ln6003"> </a>
<a name="ln6004">static void _tag_read_level(reader &amp;th)</a>
<a name="ln6005">{</a>
<a name="ln6006">    env.floor_colour = unmarshallUByte(th);</a>
<a name="ln6007">    env.rock_colour  = unmarshallUByte(th);</a>
<a name="ln6008"> </a>
<a name="ln6009">#if TAG_MAJOR_VERSION == 34</a>
<a name="ln6010">    if (th.getMinorVersion() &lt; TAG_MINOR_NO_LEVEL_FLAGS)</a>
<a name="ln6011">        unmarshallInt(th);</a>
<a name="ln6012">#endif</a>
<a name="ln6013"> </a>
<a name="ln6014">    env.elapsed_time = unmarshallInt(th);</a>
<a name="ln6015">    env.old_player_pos = unmarshallCoord(th);</a>
<a name="ln6016">    env.absdepth0 = absdungeon_depth(you.where_are_you, you.depth);</a>
<a name="ln6017"> </a>
<a name="ln6018">    // Map grids.</a>
<a name="ln6019">    // how many X?</a>
<a name="ln6020">    const int gx = unmarshallShort(th);</a>
<a name="ln6021">    // how many Y?</a>
<a name="ln6022">    const int gy = unmarshallShort(th);</a>
<a name="ln6023">    ASSERT(gx == GXM);</a>
<a name="ln6024">    ASSERT(gy == GYM);</a>
<a name="ln6025"> </a>
<a name="ln6026">    env.turns_on_level = unmarshallInt(th);</a>
<a name="ln6027"> </a>
<a name="ln6028">    EAT_CANARY;</a>
<a name="ln6029"> </a>
<a name="ln6030">    env.map_seen.reset();</a>
<a name="ln6031">#if TAG_MAJOR_VERSION == 34</a>
<a name="ln6032">    vector&lt;coord_def&gt; transporters;</a>
<a name="ln6033">#endif</a>
<a name="ln6034">    for (int i = 0; i &lt; gx; i++)</a>
<a name="ln6035">        for (int j = 0; j &lt; gy; j++)</a>
<a name="ln6036">        {</a>
<a name="ln6037">            dungeon_feature_type feat = unmarshallFeatureType(th);</a>
<a name="ln6038">            grd[i][j] = feat;</a>
<a name="ln6039">            ASSERT(feat &lt; NUM_FEATURES);</a>
<a name="ln6040"> </a>
<a name="ln6041">#if TAG_MAJOR_VERSION == 34</a>
<a name="ln6042">            // Save these for potential destination clean up.</a>
<a name="ln6043">            if (grd[i][j] == DNGN_TRANSPORTER)</a>
<a name="ln6044">                transporters.push_back(coord_def(i, j));</a>
<a name="ln6045">#endif</a>
<a name="ln6046">            unmarshallMapCell(th, env.map_knowledge[i][j]);</a>
<a name="ln6047">            // Fixup positions</a>
<a name="ln6048">            if (env.map_knowledge[i][j].monsterinfo())</a>
<a name="ln6049">                env.map_knowledge[i][j].monsterinfo()-&gt;pos = coord_def(i, j);</a>
<a name="ln6050">            if (env.map_knowledge[i][j].cloudinfo())</a>
<a name="ln6051">                env.map_knowledge[i][j].cloudinfo()-&gt;pos = coord_def(i, j);</a>
<a name="ln6052"> </a>
<a name="ln6053">            env.map_knowledge[i][j].flags &amp;= ~MAP_VISIBLE_FLAG;</a>
<a name="ln6054">            if (env.map_knowledge[i][j].seen())</a>
<a name="ln6055">                env.map_seen.set(i, j);</a>
<a name="ln6056">            env.pgrid[i][j].flags = unmarshallInt(th);</a>
<a name="ln6057"> </a>
<a name="ln6058">            mgrd[i][j] = NON_MONSTER;</a>
<a name="ln6059">        }</a>
<a name="ln6060"> </a>
<a name="ln6061">#if TAG_MAJOR_VERSION == 34</a>
<a name="ln6062">    if (th.getMinorVersion() &lt; TAG_MINOR_FORGOTTEN_MAP)</a>
<a name="ln6063">        env.map_forgotten.reset();</a>
<a name="ln6064">    else</a>
<a name="ln6065">#endif</a>
<a name="ln6066">    if (unmarshallBoolean(th))</a>
<a name="ln6067">    {</a>
<a name="ln6068">        MapKnowledge *f = new MapKnowledge();</a>
<a name="ln6069">        for (int x = 0; x &lt; GXM; x++)</a>
<a name="ln6070">            for (int y = 0; y &lt; GYM; y++)</a>
<a name="ln6071">                unmarshallMapCell(th, (*f)[x][y]);</a>
<a name="ln6072">        env.map_forgotten.reset(f);</a>
<a name="ln6073">    }</a>
<a name="ln6074">    else</a>
<a name="ln6075">        env.map_forgotten.reset();</a>
<a name="ln6076"> </a>
<a name="ln6077">    env.grid_colours.init(BLACK);</a>
<a name="ln6078">    _run_length_decode(th, unmarshallByte, env.grid_colours, GXM, GYM);</a>
<a name="ln6079"> </a>
<a name="ln6080">    EAT_CANARY;</a>
<a name="ln6081"> </a>
<a name="ln6082">    env.cloud.clear();</a>
<a name="ln6083">    // how many clouds?</a>
<a name="ln6084">    const int num_clouds = unmarshallShort(th);</a>
<a name="ln6085">    cloud_struct cloud;</a>
<a name="ln6086">    for (int i = 0; i &lt; num_clouds; i++)</a>
<a name="ln6087">    {</a>
<a name="ln6088">        cloud.type  = static_cast&lt;cloud_type&gt;(unmarshallByte(th));</a>
<a name="ln6089">#if TAG_MAJOR_VERSION == 34</a>
<a name="ln6090">        // old system marshalled empty clouds this way</a>
<a name="ln6091">        if (cloud.type == CLOUD_NONE)</a>
<a name="ln6092">            continue;</a>
<a name="ln6093">#else</a>
<a name="ln6094">        ASSERT(cloud.type != CLOUD_NONE);</a>
<a name="ln6095">#endif</a>
<a name="ln6096">        cloud.pos.x = unmarshallByte(th);</a>
<a name="ln6097">        cloud.pos.y = unmarshallByte(th);</a>
<a name="ln6098">        ASSERT_IN_BOUNDS(cloud.pos);</a>
<a name="ln6099">        cloud.decay = unmarshallShort(th);</a>
<a name="ln6100">        cloud.spread_rate = unmarshallUByte(th);</a>
<a name="ln6101">        cloud.whose = static_cast&lt;kill_category&gt;(unmarshallUByte(th));</a>
<a name="ln6102">        cloud.killer = static_cast&lt;killer_type&gt;(unmarshallUByte(th));</a>
<a name="ln6103">        cloud.source = unmarshallInt(th);</a>
<a name="ln6104">#if TAG_MAJOR_VERSION == 34</a>
<a name="ln6105">        if (th.getMinorVersion() &lt; TAG_MINOR_DECUSTOM_CLOUDS)</a>
<a name="ln6106">        {</a>
<a name="ln6107">            unmarshallShort(th); // was cloud.colour</a>
<a name="ln6108">            unmarshallString(th); // was cloud.name</a>
<a name="ln6109">            unmarshallString(th); // was cloud.tile</a>
<a name="ln6110">        }</a>
<a name="ln6111">#endif</a>
<a name="ln6112">        cloud.excl_rad = unmarshallInt(th);</a>
<a name="ln6113"> </a>
<a name="ln6114">#if TAG_MAJOR_VERSION == 34</a>
<a name="ln6115">        // Remove clouds stuck in walls, from 0.18-a0-603-g332275c to</a>
<a name="ln6116">        // 0.18-a0-629-g16988c9.</a>
<a name="ln6117">        if (!cell_is_solid(cloud.pos))</a>
<a name="ln6118">#endif</a>
<a name="ln6119">            env.cloud[cloud.pos] = cloud;</a>
<a name="ln6120">    }</a>
<a name="ln6121"> </a>
<a name="ln6122">    EAT_CANARY;</a>
<a name="ln6123"> </a>
<a name="ln6124">    // how many shops?</a>
<a name="ln6125">    const int num_shops = unmarshallShort(th);</a>
<a name="ln6126">    shop_struct shop;</a>
<a name="ln6127">    for (int i = 0; i &lt; num_shops; i++)</a>
<a name="ln6128">    {</a>
<a name="ln6129">        unmarshall_shop(th, shop);</a>
<a name="ln6130">        if (shop.type == SHOP_UNASSIGNED)</a>
<a name="ln6131">            continue;</a>
<a name="ln6132">#if TAG_MAJOR_VERSION == 34</a>
<a name="ln6133">        shop.num = i;</a>
<a name="ln6134">#endif</a>
<a name="ln6135">        env.shop[shop.pos] = shop;</a>
<a name="ln6136">    }</a>
<a name="ln6137"> </a>
<a name="ln6138">    EAT_CANARY;</a>
<a name="ln6139"> </a>
<a name="ln6140">    env.sanctuary_pos  = unmarshallCoord(th);</a>
<a name="ln6141">    env.sanctuary_time = unmarshallByte(th);</a>
<a name="ln6142"> </a>
<a name="ln6143">    env.spawn_random_rate = unmarshallInt(th);</a>
<a name="ln6144"> </a>
<a name="ln6145">    env.markers.read(th);</a>
<a name="ln6146">#if TAG_MAJOR_VERSION == 34</a>
<a name="ln6147">    if (th.getMinorVersion() &lt; TAG_MINOR_TRANSPORTER_LANDING)</a>
<a name="ln6148">    {</a>
<a name="ln6149">        for (auto&amp; tr : transporters)</a>
<a name="ln6150">        {</a>
<a name="ln6151">            if (grd(tr) != DNGN_TRANSPORTER)</a>
<a name="ln6152">                continue;</a>
<a name="ln6153"> </a>
<a name="ln6154">            const coord_def dest = get_transporter_dest(tr);</a>
<a name="ln6155">            if (dest != INVALID_COORD)</a>
<a name="ln6156">                grd(dest) = DNGN_TRANSPORTER_LANDING;</a>
<a name="ln6157">        }</a>
<a name="ln6158">    }</a>
<a name="ln6159">    if (th.getMinorVersion() &lt; TAG_MINOR_VETO_DISINT)</a>
<a name="ln6160">    {</a>
<a name="ln6161">        for (map_marker *mark : env.markers.get_all(MAT_ANY))</a>
<a name="ln6162">        {</a>
<a name="ln6163">            if (mark-&gt;property(&quot;veto_disintegrate&quot;) == &quot;veto&quot;)</a>
<a name="ln6164">            {</a>
<a name="ln6165">                map_wiz_props_marker *marker =</a>
<a name="ln6166">                    new map_wiz_props_marker(mark-&gt;pos);</a>
<a name="ln6167">                marker-&gt;set_property(&quot;veto_dig&quot;, &quot;veto&quot;);</a>
<a name="ln6168">                env.markers.add(marker);</a>
<a name="ln6169">            }</a>
<a name="ln6170">        }</a>
<a name="ln6171">    }</a>
<a name="ln6172">#endif</a>
<a name="ln6173"> </a>
<a name="ln6174">    env.properties.clear();</a>
<a name="ln6175">    env.properties.read(th);</a>
<a name="ln6176">#if TAG_MAJOR_VERSION == 34</a>
<a name="ln6177">    if (th.getMinorVersion() &lt; TAG_MINOR_PLACE_UNPACK)</a>
<a name="ln6178">    {</a>
<a name="ln6179">        CrawlHashTable &amp;props = env.properties;</a>
<a name="ln6180">        if (props.exists(VAULT_MON_BASES_KEY))</a>
<a name="ln6181">        {</a>
<a name="ln6182">            ASSERT(!props.exists(VAULT_MON_PLACES_KEY));</a>
<a name="ln6183">            CrawlVector &amp;type_vec = props[VAULT_MON_TYPES_KEY].get_vector();</a>
<a name="ln6184">            CrawlVector &amp;base_vec = props[VAULT_MON_BASES_KEY].get_vector();</a>
<a name="ln6185">            size_t size = type_vec.size();</a>
<a name="ln6186">            props[VAULT_MON_PLACES_KEY].new_vector(SV_LEV_ID).resize(size);</a>
<a name="ln6187">            CrawlVector &amp;place_vec = props[VAULT_MON_PLACES_KEY].get_vector();</a>
<a name="ln6188">            for (size_t i = 0; i &lt; size; i++)</a>
<a name="ln6189">            {</a>
<a name="ln6190">                if (type_vec[i].get_int() == -1)</a>
<a name="ln6191">                   place_vec[i] = level_id::from_packed_place(base_vec[i].get_int());</a>
<a name="ln6192">                else</a>
<a name="ln6193">                   place_vec[i] = level_id();</a>
<a name="ln6194">            }</a>
<a name="ln6195">        }</a>
<a name="ln6196">    }</a>
<a name="ln6197">#endif</a>
<a name="ln6198"> </a>
<a name="ln6199">    env.dactions_done = unmarshallInt(th);</a>
<a name="ln6200"> </a>
<a name="ln6201">    // Restore heightmap</a>
<a name="ln6202">    env.heightmap.reset(nullptr);</a>
<a name="ln6203">    const bool have_heightmap = unmarshallBoolean(th);</a>
<a name="ln6204">    if (have_heightmap)</a>
<a name="ln6205">    {</a>
<a name="ln6206">        env.heightmap.reset(new grid_heightmap);</a>
<a name="ln6207">        grid_heightmap &amp;heightmap(*env.heightmap);</a>
<a name="ln6208">        for (rectangle_iterator ri(0); ri; ++ri)</a>
<a name="ln6209">            heightmap(*ri) = unmarshallShort(th);</a>
<a name="ln6210">    }</a>
<a name="ln6211"> </a>
<a name="ln6212">    EAT_CANARY;</a>
<a name="ln6213"> </a>
<a name="ln6214">    env.forest_awoken_until = unmarshallInt(th);</a>
<a name="ln6215">    unmarshall_level_vault_data(th);</a>
<a name="ln6216">    env.density = unmarshallInt(th);</a>
<a name="ln6217">#if TAG_MAJOR_VERSION == 34</a>
<a name="ln6218"> </a>
<a name="ln6219">    if (th.getMinorVersion() &lt; TAG_MINOR_NO_SUNLIGHT)</a>
<a name="ln6220">    {</a>
<a name="ln6221">        int num_lights = unmarshallShort(th);</a>
<a name="ln6222">        ASSERT(num_lights &gt;= 0);</a>
<a name="ln6223">        while (num_lights-- &gt; 0)</a>
<a name="ln6224">        {</a>
<a name="ln6225">            unmarshallCoord(th);</a>
<a name="ln6226">            unmarshallInt(th);</a>
<a name="ln6227">        }</a>
<a name="ln6228">    }</a>
<a name="ln6229">#endif</a>
<a name="ln6230">}</a>
<a name="ln6231"> </a>
<a name="ln6232">#if TAG_MAJOR_VERSION == 34</a>
<a name="ln6233">static spell_type _fixup_soh_breath(monster_type mtyp)</a>
<a name="ln6234">{</a>
<a name="ln6235">    switch (mtyp)</a>
<a name="ln6236">    {</a>
<a name="ln6237">        case MONS_SERPENT_OF_HELL:</a>
<a name="ln6238">        default:</a>
<a name="ln6239">            return SPELL_SERPENT_OF_HELL_GEH_BREATH;</a>
<a name="ln6240">        case MONS_SERPENT_OF_HELL_COCYTUS:</a>
<a name="ln6241">            return SPELL_SERPENT_OF_HELL_COC_BREATH;</a>
<a name="ln6242">        case MONS_SERPENT_OF_HELL_DIS:</a>
<a name="ln6243">            return SPELL_SERPENT_OF_HELL_DIS_BREATH;</a>
<a name="ln6244">        case MONS_SERPENT_OF_HELL_TARTARUS:</a>
<a name="ln6245">            return SPELL_SERPENT_OF_HELL_TAR_BREATH;</a>
<a name="ln6246">    }</a>
<a name="ln6247">}</a>
<a name="ln6248">#endif</a>
<a name="ln6249"> </a>
<a name="ln6250">static void _tag_read_level_items(reader &amp;th)</a>
<a name="ln6251">{</a>
<a name="ln6252">    unwind_bool dont_scan(crawl_state.crash_debug_scans_safe, false);</a>
<a name="ln6253">    env.trap.clear();</a>
<a name="ln6254">    // how many traps?</a>
<a name="ln6255">    const int trap_count = unmarshallShort(th);</a>
<a name="ln6256">    trap_def trap;</a>
<a name="ln6257">    for (int i = 0; i &lt; trap_count; ++i)</a>
<a name="ln6258">    {</a>
<a name="ln6259">        trap.type = static_cast&lt;trap_type&gt;(unmarshallUByte(th));</a>
<a name="ln6260">#if TAG_MAJOR_VERSION == 34</a>
<a name="ln6261">        if (trap.type == TRAP_UNASSIGNED)</a>
<a name="ln6262">            continue;</a>
<a name="ln6263">#else</a>
<a name="ln6264">        ASSERT(trap.type != TRAP_UNASSIGNED);</a>
<a name="ln6265">#endif</a>
<a name="ln6266">        trap.pos      = unmarshallCoord(th);</a>
<a name="ln6267">        trap.ammo_qty = unmarshallShort(th);</a>
<a name="ln6268">#if TAG_MAJOR_VERSION == 34</a>
<a name="ln6269">        if (th.getMinorVersion() == TAG_MINOR_0_11 &amp;&amp; trap.type &gt;= TRAP_TELEPORT)</a>
<a name="ln6270">            trap.type = (trap_type)(trap.type - 1);</a>
<a name="ln6271">        if (th.getMinorVersion() &lt; TAG_MINOR_REVEAL_TRAPS)</a>
<a name="ln6272">            grd(trap.pos) = trap.feature();</a>
<a name="ln6273">        if (th.getMinorVersion() &lt; TAG_MINOR_TRAPS_DETERM</a>
<a name="ln6274">            || th.getMinorVersion() == TAG_MINOR_0_11)</a>
<a name="ln6275">        {</a>
<a name="ln6276">            trap.skill_rnd = random2(256);</a>
<a name="ln6277">        }</a>
<a name="ln6278">        else</a>
<a name="ln6279">#endif</a>
<a name="ln6280">        trap.skill_rnd = unmarshallUByte(th);</a>
<a name="ln6281">        env.trap[trap.pos] = trap;</a>
<a name="ln6282">    }</a>
<a name="ln6283"> </a>
<a name="ln6284">#if TAG_MAJOR_VERSION == 34</a>
<a name="ln6285">    // Fix up floor that trap_def::destroy left as a trap (from</a>
<a name="ln6286">    // 0.18-a0-605-g5e852a4 to 0.18-a0-614-gc92b81f).</a>
<a name="ln6287">    for (int i = 0; i &lt; GXM; i++)</a>
<a name="ln6288">        for (int j = 0; j &lt; GYM; j++)</a>
<a name="ln6289">        {</a>
<a name="ln6290">            coord_def pos(i, j);</a>
<a name="ln6291">            if (feat_is_trap(grd(pos)) &amp;&amp; !map_find(env.trap, pos))</a>
<a name="ln6292">                grd(pos) = DNGN_FLOOR;</a>
<a name="ln6293">        }</a>
<a name="ln6294"> </a>
<a name="ln6295">#endif</a>
<a name="ln6296"> </a>
<a name="ln6297">    // how many items?</a>
<a name="ln6298">    const int item_count = unmarshallShort(th);</a>
<a name="ln6299">    ASSERT_RANGE(item_count, 0, MAX_ITEMS + 1);</a>
<a name="ln6300">    for (int i = 0; i &lt; item_count; ++i)</a>
<a name="ln6301">        unmarshallItem(th, mitm[i]);</a>
<a name="ln6302">    for (int i = item_count; i &lt; MAX_ITEMS; ++i)</a>
<a name="ln6303">        mitm[i].clear();</a>
<a name="ln6304"> </a>
<a name="ln6305">#ifdef DEBUG_ITEM_SCAN</a>
<a name="ln6306">    // There's no way to fix this, even with wizard commands, so get</a>
<a name="ln6307">    // rid of it when restoring the game.</a>
<a name="ln6308">    for (int i = 0; i &lt; item_count; ++i)</a>
<a name="ln6309">    {</a>
<a name="ln6310">        if (mitm[i].defined() &amp;&amp; mitm[i].pos.origin())</a>
<a name="ln6311">        {</a>
<a name="ln6312">            debug_dump_item(mitm[i].name(DESC_PLAIN).c_str(), i, mitm[i],</a>
<a name="ln6313">                                        &quot;Fixing up unlinked temporary item:&quot;);</a>
<a name="ln6314">            mitm[i].clear();</a>
<a name="ln6315">        }</a>
<a name="ln6316">    }</a>
<a name="ln6317">#endif</a>
<a name="ln6318">}</a>
<a name="ln6319"> </a>
<a name="ln6320">void unmarshallMonster(reader &amp;th, monster&amp; m)</a>
<a name="ln6321">{</a>
<a name="ln6322">    m.reset();</a>
<a name="ln6323"> </a>
<a name="ln6324">    m.type           = unmarshallMonType(th);</a>
<a name="ln6325">    if (m.type == MONS_NO_MONSTER)</a>
<a name="ln6326">        return;</a>
<a name="ln6327"> </a>
<a name="ln6328">    ASSERT(!invalid_monster_type(m.type));</a>
<a name="ln6329"> </a>
<a name="ln6330">#if TAG_MAJOR_VERSION == 34</a>
<a name="ln6331">    uint32_t parts    = 0;</a>
<a name="ln6332">    if (th.getMinorVersion() &lt; TAG_MINOR_MONSTER_PARTS)</a>
<a name="ln6333">    {</a>
<a name="ln6334">        if (mons_is_ghost_demon(m.type))</a>
<a name="ln6335">            parts |= MP_GHOST_DEMON;</a>
<a name="ln6336">    }</a>
<a name="ln6337">    else</a>
<a name="ln6338">        parts         = unmarshallUnsigned(th);</a>
<a name="ln6339">    if (th.getMinorVersion() &lt; TAG_MINOR_OPTIONAL_PARTS)</a>
<a name="ln6340">        parts |= MP_CONSTRICTION | MP_ITEMS | MP_SPELLS;</a>
<a name="ln6341">#else</a>
<a name="ln6342">    uint32_t parts    = unmarshallUnsigned(th);</a>
<a name="ln6343">#endif</a>
<a name="ln6344">    m.mid             = unmarshallInt(th);</a>
<a name="ln6345">    ASSERT(m.mid &gt; 0);</a>
<a name="ln6346">    m.mname           = unmarshallString(th);</a>
<a name="ln6347">#if TAG_MAJOR_VERSION == 34</a>
<a name="ln6348">    if (th.getMinorVersion() &gt;= TAG_MINOR_LEVEL_XP_INFO)</a>
<a name="ln6349">    {</a>
<a name="ln6350">        // This was monster::is_spawn before the level XP info fix.</a>
<a name="ln6351">        if (th.getMinorVersion() &lt; TAG_MINOR_LEVEL_XP_INFO_FIX)</a>
<a name="ln6352">        {</a>
<a name="ln6353">            // We no longer track spawns but instead whether the monster comes</a>
<a name="ln6354">            // from a vault. This gets determined from props below for</a>
<a name="ln6355">            // transferred games.</a>
<a name="ln6356">            unmarshallByte(th);</a>
<a name="ln6357">            m.xp_tracking = XP_NON_VAULT;</a>
<a name="ln6358">        }</a>
<a name="ln6359">        else</a>
<a name="ln6360">#endif</a>
<a name="ln6361">    m.xp_tracking     = static_cast&lt;xp_tracking_type&gt;(unmarshallUByte(th));</a>
<a name="ln6362">#if TAG_MAJOR_VERSION == 34</a>
<a name="ln6363">    }</a>
<a name="ln6364">    // Don't track monsters generated before TAG_MINOR_LEVEL_XP_INFO.</a>
<a name="ln6365">    else</a>
<a name="ln6366">        m.xp_tracking = XP_UNTRACKED;</a>
<a name="ln6367"> </a>
<a name="ln6368"> </a>
<a name="ln6369">    if (th.getMinorVersion() &lt; TAG_MINOR_REMOVE_MON_AC_EV)</a>
<a name="ln6370">    {</a>
<a name="ln6371">        unmarshallByte(th);</a>
<a name="ln6372">        unmarshallByte(th);</a>
<a name="ln6373">    }</a>
<a name="ln6374">#endif</a>
<a name="ln6375">    m.set_hit_dice(     unmarshallByte(th));</a>
<a name="ln6376">#if TAG_MAJOR_VERSION == 34</a>
<a name="ln6377">    // Draining used to be able to take a monster to 0 HD, but that</a>
<a name="ln6378">    // caused crashes if they tried to cast spells.</a>
<a name="ln6379">    m.set_hit_dice(max(m.get_experience_level(), 1));</a>
<a name="ln6380">#else</a>
<a name="ln6381">    ASSERT(m.get_experience_level() &gt; 0);</a>
<a name="ln6382">#endif</a>
<a name="ln6383">    m.speed           = unmarshallByte(th);</a>
<a name="ln6384">    // Avoid sign extension when loading files (Elethiomel's hang)</a>
<a name="ln6385">    m.speed_increment = unmarshallUByte(th);</a>
<a name="ln6386">    m.behaviour       = static_cast&lt;beh_type&gt;(unmarshallUByte(th));</a>
<a name="ln6387">    int x             = unmarshallByte(th);</a>
<a name="ln6388">    int y             = unmarshallByte(th);</a>
<a name="ln6389">    m.set_position(coord_def(x,y));</a>
<a name="ln6390">    m.target.x        = unmarshallByte(th);</a>
<a name="ln6391">    m.target.y        = unmarshallByte(th);</a>
<a name="ln6392"> </a>
<a name="ln6393">    m.firing_pos      = unmarshallCoord(th);</a>
<a name="ln6394">    m.patrol_point    = unmarshallCoord(th);</a>
<a name="ln6395"> </a>
<a name="ln6396">    int help = unmarshallByte(th);</a>
<a name="ln6397">    m.travel_target = static_cast&lt;montravel_target_type&gt;(help);</a>
<a name="ln6398"> </a>
<a name="ln6399">    const int len = unmarshallShort(th);</a>
<a name="ln6400">    for (int i = 0; i &lt; len; ++i)</a>
<a name="ln6401">        m.travel_path.push_back(unmarshallCoord(th));</a>
<a name="ln6402"> </a>
<a name="ln6403">    m.flags.flags = unmarshallUnsigned(th);</a>
<a name="ln6404">    m.experience  = unmarshallInt(th);</a>
<a name="ln6405"> </a>
<a name="ln6406">    m.enchantments.clear();</a>
<a name="ln6407">    const int nenchs = unmarshallShort(th);</a>
<a name="ln6408">    for (int i = 0; i &lt; nenchs; ++i)</a>
<a name="ln6409">    {</a>
<a name="ln6410">        mon_enchant me = unmarshall_mon_enchant(th);</a>
<a name="ln6411">        m.enchantments[me.ench] = me;</a>
<a name="ln6412">        m.ench_cache.set(me.ench, true);</a>
<a name="ln6413">    }</a>
<a name="ln6414">    m.ench_countdown = unmarshallByte(th);</a>
<a name="ln6415"> </a>
<a name="ln6416">    m.hit_points     = unmarshallShort(th);</a>
<a name="ln6417">    m.max_hit_points = unmarshallShort(th);</a>
<a name="ln6418">    m.number         = unmarshallInt(th);</a>
<a name="ln6419">    m.base_monster   = unmarshallMonType(th);</a>
<a name="ln6420">    m.colour         = unmarshallShort(th);</a>
<a name="ln6421">#if TAG_MAJOR_VERSION == 34</a>
<a name="ln6422">    if (th.getMinorVersion() &lt; TAG_MINOR_SUMMONER)</a>
<a name="ln6423">        m.summoner = 0;</a>
<a name="ln6424">    else</a>
<a name="ln6425">#endif</a>
<a name="ln6426">    m.summoner       = unmarshallInt(th);</a>
<a name="ln6427"> </a>
<a name="ln6428">    if (parts &amp; MP_ITEMS)</a>
<a name="ln6429">        for (int j = 0; j &lt; NUM_MONSTER_SLOTS; j++)</a>
<a name="ln6430">            m.inv[j] = unmarshallShort(th);</a>
<a name="ln6431"> </a>
<a name="ln6432">    if (parts &amp; MP_SPELLS)</a>
<a name="ln6433">    {</a>
<a name="ln6434">        unmarshallSpells(th, m.spells</a>
<a name="ln6435">#if TAG_MAJOR_VERSION == 34</a>
<a name="ln6436">                         , m.get_experience_level()</a>
<a name="ln6437">#endif</a>
<a name="ln6438">                         );</a>
<a name="ln6439">#if TAG_MAJOR_VERSION == 34</a>
<a name="ln6440">    monster_spells oldspells = m.spells;</a>
<a name="ln6441">    m.spells.clear();</a>
<a name="ln6442">    for (mon_spell_slot &amp;slot : oldspells)</a>
<a name="ln6443">    {</a>
<a name="ln6444">        if (th.getMinorVersion() &lt; TAG_MINOR_MORE_GHOST_MAGIC)</a>
<a name="ln6445">            slot.spell = _fixup_positional_monster_spell(slot.spell);</a>
<a name="ln6446"> </a>
<a name="ln6447">        if (mons_is_zombified(m) &amp;&amp; !mons_enslaved_soul(m)</a>
<a name="ln6448">            &amp;&amp; slot.spell != SPELL_CREATE_TENTACLES)</a>
<a name="ln6449">        {</a>
<a name="ln6450">            // zombies shouldn't have (most) spells</a>
<a name="ln6451">        }</a>
<a name="ln6452">        else if (slot.spell == SPELL_DRACONIAN_BREATH)</a>
<a name="ln6453">        {</a>
<a name="ln6454">            // Replace Draconian Breath with the colour-specific spell,</a>
<a name="ln6455">            // and remove Azrael's bad breath while we're at it.</a>
<a name="ln6456">            if (mons_genus(m.type) == MONS_DRACONIAN)</a>
<a name="ln6457">                m.spells.push_back(drac_breath(draco_or_demonspawn_subspecies(m)));</a>
<a name="ln6458">        }</a>
<a name="ln6459">        // Give Mnoleg back malign gateway in place of tentacles.</a>
<a name="ln6460">        else if (slot.spell == SPELL_CREATE_TENTACLES</a>
<a name="ln6461">                 &amp;&amp; m.type == MONS_MNOLEG)</a>
<a name="ln6462">        {</a>
<a name="ln6463">            slot.spell = SPELL_MALIGN_GATEWAY;</a>
<a name="ln6464">            slot.freq = 27;</a>
<a name="ln6465">            m.spells.push_back(slot);</a>
<a name="ln6466">        }</a>
<a name="ln6467">        else if (slot.spell == SPELL_CHANT_FIRE_STORM)</a>
<a name="ln6468">        {</a>
<a name="ln6469">            slot.spell = SPELL_FIRE_STORM;</a>
<a name="ln6470">            m.spells.push_back(slot);</a>
<a name="ln6471">        }</a>
<a name="ln6472">        else if (slot.spell == SPELL_SERPENT_OF_HELL_BREATH_REMOVED)</a>
<a name="ln6473">        {</a>
<a name="ln6474">            slot.spell = _fixup_soh_breath(m.type);</a>
<a name="ln6475">            m.spells.push_back(slot);</a>
<a name="ln6476">        }</a>
<a name="ln6477">#if TAG_MAJOR_VERSION == 34</a>
<a name="ln6478">        else if (slot.spell != SPELL_DELAYED_FIREBALL</a>
<a name="ln6479">                 &amp;&amp; slot.spell != SPELL_MELEE</a>
<a name="ln6480">                 &amp;&amp; slot.spell != SPELL_NO_SPELL)</a>
<a name="ln6481">        {</a>
<a name="ln6482">            m.spells.push_back(slot);</a>
<a name="ln6483">        }</a>
<a name="ln6484">#endif</a>
<a name="ln6485">        else if (slot.spell == SPELL_CORRUPT_BODY)</a>
<a name="ln6486">        {</a>
<a name="ln6487">            slot.spell = SPELL_CORRUPTING_PULSE;</a>
<a name="ln6488">            m.spells.push_back(slot);</a>
<a name="ln6489">        }</a>
<a name="ln6490">    }</a>
<a name="ln6491">#endif</a>
<a name="ln6492">    }</a>
<a name="ln6493"> </a>
<a name="ln6494">    m.god      = static_cast&lt;god_type&gt;(unmarshallByte(th));</a>
<a name="ln6495">    m.attitude = static_cast&lt;mon_attitude_type&gt;(unmarshallByte(th));</a>
<a name="ln6496">    m.foe      = unmarshallShort(th);</a>
<a name="ln6497">#if TAG_MAJOR_VERSION == 34</a>
<a name="ln6498">    // In 0.16 alpha we briefly allowed YOU_FAULTLESS as a monster's foe.</a>
<a name="ln6499">    if (m.foe == YOU_FAULTLESS)</a>
<a name="ln6500">        m.foe = MHITYOU;</a>
<a name="ln6501">#endif</a>
<a name="ln6502">    m.foe_memory = unmarshallInt(th);</a>
<a name="ln6503"> </a>
<a name="ln6504">    m.damage_friendly = unmarshallShort(th);</a>
<a name="ln6505">    m.damage_total = unmarshallShort(th);</a>
<a name="ln6506"> </a>
<a name="ln6507">#if TAG_MAJOR_VERSION == 34</a>
<a name="ln6508">    if (th.getMinorVersion() &lt; TAG_MINOR_UNSEEN_MONSTER)</a>
<a name="ln6509">    {</a>
<a name="ln6510">        m.went_unseen_this_turn = false;</a>
<a name="ln6511">        m.unseen_pos = coord_def(0, 0);</a>
<a name="ln6512">    }</a>
<a name="ln6513">    else</a>
<a name="ln6514">    {</a>
<a name="ln6515">#endif</a>
<a name="ln6516">    m.went_unseen_this_turn = unmarshallByte(th);</a>
<a name="ln6517">    m.unseen_pos = unmarshallCoord(th);</a>
<a name="ln6518">#if TAG_MAJOR_VERSION == 34</a>
<a name="ln6519">    }</a>
<a name="ln6520">#endif</a>
<a name="ln6521"> </a>
<a name="ln6522">#if TAG_MAJOR_VERSION == 34</a>
<a name="ln6523">    if (m.type == MONS_LABORATORY_RAT)</a>
<a name="ln6524">        _unmarshallGhost(th), m.type = MONS_RAT;</a>
<a name="ln6525"> </a>
<a name="ln6526">    // MONS_SPECTRAL_WEAPON was inserted into the wrong place</a>
<a name="ln6527">    // (0.13-a0-1964-g2fab1c1, merged into trunk in 0.13-a0-1981-g9e80fb2),</a>
<a name="ln6528">    // and then had a ghost_demon structure added (0.13-a0-2055-g6cfaa00).</a>
<a name="ln6529">    // Neither event had an associated tag, but both were between the</a>
<a name="ln6530">    // same two adjacent tags.</a>
<a name="ln6531">    if (th.getMinorVersion() &lt; TAG_MINOR_CANARIES</a>
<a name="ln6532">        &amp;&amp; th.getMinorVersion() &gt;= TAG_MINOR_WAR_DOG_REMOVAL</a>
<a name="ln6533">        &amp;&amp; m.type &gt;= MONS_SPECTRAL_WEAPON</a>
<a name="ln6534">        &amp;&amp; m.type &lt;= MONS_POLYMOTH)</a>
<a name="ln6535">    {</a>
<a name="ln6536">        // But fortunately the three monsters it could be all have different</a>
<a name="ln6537">        // speeds, and none of those speeds are 3/2 or 2/3 any others. We will</a>
<a name="ln6538">        // assume that none of these had the wretched enchantment. Ugh.</a>
<a name="ln6539">        switch (m.speed)</a>
<a name="ln6540">        {</a>
<a name="ln6541">        case 6: case 7: // slowed</a>
<a name="ln6542">        case 10:</a>
<a name="ln6543">        case 15: // hasted/berserked</a>
<a name="ln6544">            m.type = MONS_GHOST; // wellspring</a>
<a name="ln6545">            break;</a>
<a name="ln6546">        case 8: // slowed</a>
<a name="ln6547">        case 12:</a>
<a name="ln6548">        case 18: // hasted/berserked</a>
<a name="ln6549">            m.type = MONS_POLYMOTH;</a>
<a name="ln6550">            break;</a>
<a name="ln6551">        case 16: case 17: case 20: // slowed</a>
<a name="ln6552">        case 25:</a>
<a name="ln6553">        case 30:</a>
<a name="ln6554">        case 37: case 38: case 45: // hasted/berserked</a>
<a name="ln6555">            m.type = MONS_SPECTRAL_WEAPON;</a>
<a name="ln6556">            break;</a>
<a name="ln6557">        default:</a>
<a name="ln6558">            die(&quot;Unexpected monster with type %d and speed %d&quot;,</a>
<a name="ln6559">                m.type, m.speed);</a>
<a name="ln6560">        }</a>
<a name="ln6561">    }</a>
<a name="ln6562"> </a>
<a name="ln6563">    // Spectral weapons became speed 30 in the commit immediately preceding</a>
<a name="ln6564">    // the one that added the ghost_demon. Since the commits were in the</a>
<a name="ln6565">    // same batch, no one should have saves where the speed is 30 and the</a>
<a name="ln6566">    // spectral weapon didn't have a ghost_demon, or where the speed is</a>
<a name="ln6567">    // 25 and it did.</a>
<a name="ln6568">    if (th.getMinorVersion() &lt; TAG_MINOR_CANARIES</a>
<a name="ln6569">        &amp;&amp; m.type == MONS_SPECTRAL_WEAPON</a>
<a name="ln6570">        // normal, slowed, and hasted, respectively.</a>
<a name="ln6571">        &amp;&amp; m.speed != 30 &amp;&amp; m.speed != 20 &amp;&amp; m.speed != 45)</a>
<a name="ln6572">    {</a>
<a name="ln6573">        // Don't bother trying to fix it up.</a>
<a name="ln6574">        m.type = MONS_WOOD_GOLEM; // anything removed</a>
<a name="ln6575">        m.mid = ++you.last_mid;   // sabotage the bond</a>
<a name="ln6576">        ASSERT(m.mid &lt; MID_FIRST_NON_MONSTER);</a>
<a name="ln6577">        parts &amp;= MP_GHOST_DEMON;</a>
<a name="ln6578">    }</a>
<a name="ln6579">    else if (m.type == MONS_CHIMERA</a>
<a name="ln6580">             &amp;&amp; th.getMinorVersion() &lt; TAG_MINOR_CHIMERA_GHOST_DEMON)</a>
<a name="ln6581">    {</a>
<a name="ln6582">        // Don't unmarshall the ghost demon if this is an invalid chimera</a>
<a name="ln6583">    }</a>
<a name="ln6584">    else if (th.getMinorVersion() &lt; TAG_MINOR_DEMONSPAWN</a>
<a name="ln6585">             &amp;&amp; m.type &gt;= MONS_MONSTROUS_DEMONSPAWN</a>
<a name="ln6586">             &amp;&amp; m.type &lt;= MONS_SALAMANDER_MYSTIC)</a>
<a name="ln6587">    {</a>
<a name="ln6588">        // The demonspawn-enemies branch was merged in such a fashion</a>
<a name="ln6589">        // that it bumped several monster enums (see merge commit:</a>
<a name="ln6590">        // 0.14-a0-2321-gdab6825).</a>
<a name="ln6591">        // Try to figure out what it is.</a>
<a name="ln6592">        switch (m.colour)</a>
<a name="ln6593">        {</a>
<a name="ln6594">        case BROWN:        // monstrous demonspawn, naga ritualist</a>
<a name="ln6595">            if (m.spells[0].spell == SPELL_FORCE_LANCE)</a>
<a name="ln6596">                m.type = MONS_NAGA_RITUALIST;</a>
<a name="ln6597">            else</a>
<a name="ln6598">                m.type = MONS_MONSTROUS_DEMONSPAWN;</a>
<a name="ln6599">            break;</a>
<a name="ln6600">        case BLUE:         // gelid demonspawn</a>
<a name="ln6601">            m.type = MONS_GELID_DEMONSPAWN;</a>
<a name="ln6602">            break;</a>
<a name="ln6603">        case RED:          // infernal demonspawn</a>
<a name="ln6604">            m.type = MONS_INFERNAL_DEMONSPAWN;</a>
<a name="ln6605">            break;</a>
<a name="ln6606">        case LIGHTGRAY:    // torturous demonspawn, naga sharpshooter</a>
<a name="ln6607">            if (m.spells[0].spell == SPELL_PORTAL_PROJECTILE)</a>
<a name="ln6608">                m.type = MONS_NAGA_SHARPSHOOTER;</a>
<a name="ln6609">            else</a>
<a name="ln6610">                m.type = MONS_TORTUROUS_DEMONSPAWN;</a>
<a name="ln6611">            break;</a>
<a name="ln6612">        case LIGHTBLUE:    // blood saint, shock serpent</a>
<a name="ln6613">            if (m.base_monster != MONS_NO_MONSTER)</a>
<a name="ln6614">                m.type = MONS_BLOOD_SAINT;</a>
<a name="ln6615">            else</a>
<a name="ln6616">                m.type = MONS_SHOCK_SERPENT;</a>
<a name="ln6617">            break;</a>
<a name="ln6618">        case LIGHTCYAN:    // warmonger, drowned soul</a>
<a name="ln6619">            if (m.base_monster != MONS_NO_MONSTER)</a>
<a name="ln6620">                m.type = MONS_WARMONGER;</a>
<a name="ln6621">            else</a>
<a name="ln6622">                m.type = MONS_DROWNED_SOUL;</a>
<a name="ln6623">            break;</a>
<a name="ln6624">        case LIGHTGREEN:   // corrupter</a>
<a name="ln6625">            m.type = MONS_CORRUPTER;</a>
<a name="ln6626">            break;</a>
<a name="ln6627">        case LIGHTMAGENTA: // black sun</a>
<a name="ln6628">            m.type = MONS_BLACK_SUN;</a>
<a name="ln6629">            break;</a>
<a name="ln6630">        case CYAN:         // worldbinder</a>
<a name="ln6631">            m.type = MONS_WORLDBINDER;</a>
<a name="ln6632">            break;</a>
<a name="ln6633">        case MAGENTA:      // vine stalker, mana viper, grand avatar</a>
<a name="ln6634">            switch (m.speed)</a>
<a name="ln6635">            {</a>
<a name="ln6636">                case 20:</a>
<a name="ln6637">                case 30:</a>
<a name="ln6638">                case 45:</a>
<a name="ln6639">                    m.type = MONS_GRAND_AVATAR;</a>
<a name="ln6640">                    break;</a>
<a name="ln6641">                case 9:</a>
<a name="ln6642">                case 10:</a>
<a name="ln6643">                case 14:</a>
<a name="ln6644">                case 21:</a>
<a name="ln6645">                    m.type = MONS_MANA_VIPER;</a>
<a name="ln6646">                    break;</a>
<a name="ln6647">                default:</a>
<a name="ln6648">                    die(&quot;Unexpected monster with type %d and speed %d&quot;,</a>
<a name="ln6649">                        m.type, m.speed);</a>
<a name="ln6650">            }</a>
<a name="ln6651">            break;</a>
<a name="ln6652">        case WHITE:        // salamander firebrand</a>
<a name="ln6653">            m.type = MONS_SALAMANDER_FIREBRAND;</a>
<a name="ln6654">            break;</a>
<a name="ln6655">        case YELLOW:       // salamander mystic</a>
<a name="ln6656">            m.type = MONS_SALAMANDER_MYSTIC;</a>
<a name="ln6657">            break;</a>
<a name="ln6658">        default:</a>
<a name="ln6659">            die(&quot;Unexpected monster with type %d and colour %d&quot;,</a>
<a name="ln6660">                m.type, m.colour);</a>
<a name="ln6661">        }</a>
<a name="ln6662">        if (mons_is_demonspawn(m.type)</a>
<a name="ln6663">            &amp;&amp; mons_species(m.type) == MONS_DEMONSPAWN</a>
<a name="ln6664">            &amp;&amp; m.type != MONS_DEMONSPAWN)</a>
<a name="ln6665">        {</a>
<a name="ln6666">            ASSERT(m.base_monster != MONS_NO_MONSTER);</a>
<a name="ln6667">        }</a>
<a name="ln6668">    }</a>
<a name="ln6669">    else if (th.getMinorVersion() &lt; TAG_MINOR_EXORCISE</a>
<a name="ln6670">        &amp;&amp; th.getMinorVersion() &gt;= TAG_MINOR_RANDLICHES</a>
<a name="ln6671">        &amp;&amp; (m.type == MONS_LICH || m.type == MONS_ANCIENT_LICH</a>
<a name="ln6672">            || m.type == MONS_SPELLFORGED_SERVITOR))</a>
<a name="ln6673">    {</a>
<a name="ln6674">        m.spells = _unmarshallGhost(th).spells;</a>
<a name="ln6675">    }</a>
<a name="ln6676">    else</a>
<a name="ln6677">#endif</a>
<a name="ln6678">    if (parts &amp; MP_GHOST_DEMON)</a>
<a name="ln6679">        m.set_ghost(_unmarshallGhost(th));</a>
<a name="ln6680"> </a>
<a name="ln6681">#if TAG_MAJOR_VERSION == 34</a>
<a name="ln6682">    // Turn elephant slugs into ghosts because they are dummies now.</a>
<a name="ln6683">    if (m.type == MONS_ELEPHANT_SLUG)</a>
<a name="ln6684">        m.type = MONS_GHOST;</a>
<a name="ln6685">#endif</a>
<a name="ln6686"> </a>
<a name="ln6687">    if (parts &amp; MP_CONSTRICTION)</a>
<a name="ln6688">        _unmarshall_constriction(th, &amp;m);</a>
<a name="ln6689"> </a>
<a name="ln6690">    m.props.clear();</a>
<a name="ln6691">    m.props.read(th);</a>
<a name="ln6692"> </a>
<a name="ln6693">    if (m.props.exists(&quot;monster_tile_name&quot;))</a>
<a name="ln6694">    {</a>
<a name="ln6695">        string tile = m.props[&quot;monster_tile_name&quot;].get_string();</a>
<a name="ln6696">        tileidx_t index;</a>
<a name="ln6697">        if (!tile_player_index(tile.c_str(), &amp;index))</a>
<a name="ln6698">        {</a>
<a name="ln6699">            // If invalid tile name, complain and discard the props.</a>
<a name="ln6700">            dprf(&quot;bad tile name: \&quot;%s\&quot;.&quot;, tile.c_str());</a>
<a name="ln6701">            m.props.erase(&quot;monster_tile_name&quot;);</a>
<a name="ln6702">            if (m.props.exists(&quot;monster_tile&quot;))</a>
<a name="ln6703">                m.props.erase(&quot;monster_tile&quot;);</a>
<a name="ln6704">        }</a>
<a name="ln6705">        else // Update monster tile.</a>
<a name="ln6706">            m.props[&quot;monster_tile&quot;] = short(index);</a>
<a name="ln6707">    }</a>
<a name="ln6708"> </a>
<a name="ln6709">#if TAG_MAJOR_VERSION == 34</a>
<a name="ln6710">    // Forget seen spells if the monster doesn't have any, most likely because</a>
<a name="ln6711">    // of a polymorph that happened before polymorph began removing this key.</a>
<a name="ln6712">    if (m.spells.empty())</a>
<a name="ln6713">        m.props.erase(SEEN_SPELLS_KEY);</a>
<a name="ln6714"> </a>
<a name="ln6715">    // Battlespheres that don't know their creator's mid must have belonged</a>
<a name="ln6716">    // to the player pre-monster-battlesphere.</a>
<a name="ln6717">    if (th.getMinorVersion() &lt; TAG_MINOR_BATTLESPHERE_MID</a>
<a name="ln6718">        &amp;&amp; m.type == MONS_BATTLESPHERE &amp;&amp; !m.props.exists(&quot;bs_mid&quot;))</a>
<a name="ln6719">    {</a>
<a name="ln6720">        // It must have belonged to the player.</a>
<a name="ln6721">        m.summoner = MID_PLAYER;</a>
<a name="ln6722">    }</a>
<a name="ln6723">    else if (m.props.exists(&quot;bs_mid&quot;))</a>
<a name="ln6724">    {</a>
<a name="ln6725">        m.summoner = m.props[&quot;bs_mid&quot;].get_int();</a>
<a name="ln6726">        m.props.erase(&quot;bs_mid&quot;);</a>
<a name="ln6727">    }</a>
<a name="ln6728"> </a>
<a name="ln6729">    if (m.props.exists(IOOD_MID))</a>
<a name="ln6730">        m.summoner = m.props[IOOD_MID].get_int(), m.props.erase(IOOD_MID);</a>
<a name="ln6731"> </a>
<a name="ln6732">    if (m.props.exists(&quot;siren_call&quot;))</a>
<a name="ln6733">    {</a>
<a name="ln6734">        m.props[&quot;merfolk_avatar_call&quot;] = m.props[&quot;siren_call&quot;].get_bool();</a>
<a name="ln6735">        m.props.erase(&quot;siren_call&quot;);</a>
<a name="ln6736">    }</a>
<a name="ln6737"> </a>
<a name="ln6738">    if (m.type == MONS_ZOMBIE_SMALL || m.type == MONS_ZOMBIE_LARGE)</a>
<a name="ln6739">        m.type = MONS_ZOMBIE;</a>
<a name="ln6740">    if (m.type == MONS_SKELETON_SMALL || m.type == MONS_SKELETON_LARGE)</a>
<a name="ln6741">        m.type = MONS_SKELETON;</a>
<a name="ln6742">    if (m.type == MONS_SIMULACRUM_SMALL || m.type == MONS_SIMULACRUM_LARGE)</a>
<a name="ln6743">        m.type = MONS_SIMULACRUM;</a>
<a name="ln6744"> </a>
<a name="ln6745">    if (th.getMinorVersion() &lt; TAG_MINOR_WAR_DOG_REMOVAL)</a>
<a name="ln6746">    {</a>
<a name="ln6747">        if (m.type == MONS_WAR_DOG)</a>
<a name="ln6748">            m.type = MONS_WOLF;</a>
<a name="ln6749">    }</a>
<a name="ln6750"> </a>
<a name="ln6751">    if (m.props.exists(&quot;no_hide&quot;))</a>
<a name="ln6752">        m.props.erase(&quot;no_hide&quot;);</a>
<a name="ln6753"> </a>
<a name="ln6754">    if (m.props.exists(&quot;original_name&quot;))</a>
<a name="ln6755">    {</a>
<a name="ln6756">        m.props[ORIGINAL_TYPE_KEY].get_int() =</a>
<a name="ln6757">            get_monster_by_name(m.props[&quot;original_name&quot;].get_string());</a>
<a name="ln6758">    }</a>
<a name="ln6759"> </a>
<a name="ln6760">    if (m.props.exists(&quot;given beogh shield&quot;))</a>
<a name="ln6761">    {</a>
<a name="ln6762">        m.props.erase(&quot;given beogh shield&quot;);</a>
<a name="ln6763">        m.props[BEOGH_SH_GIFT_KEY] = true;</a>
<a name="ln6764">    }</a>
<a name="ln6765"> </a>
<a name="ln6766">    if (m.props.exists(&quot;given beogh armour&quot;))</a>
<a name="ln6767">    {</a>
<a name="ln6768">        m.props.erase(&quot;given beogh armour&quot;);</a>
<a name="ln6769">        m.props[BEOGH_ARM_GIFT_KEY] = true;</a>
<a name="ln6770">    }</a>
<a name="ln6771"> </a>
<a name="ln6772">    if (m.props.exists(&quot;given beogh weapon&quot;))</a>
<a name="ln6773">    {</a>
<a name="ln6774">        m.props.erase(&quot;given beogh weapon&quot;);</a>
<a name="ln6775">        m.props[BEOGH_MELEE_WPN_GIFT_KEY] = true;</a>
<a name="ln6776">    }</a>
<a name="ln6777"> </a>
<a name="ln6778">    if (m.props.exists(&quot;given beogh range weapon&quot;))</a>
<a name="ln6779">    {</a>
<a name="ln6780">        m.props.erase(&quot;given beogh range weapon&quot;);</a>
<a name="ln6781">        m.props[BEOGH_RANGE_WPN_GIFT_KEY] = true;</a>
<a name="ln6782">    }</a>
<a name="ln6783"> </a>
<a name="ln6784">    // fixup for versions of frenzy that involved a permanent attitude change,</a>
<a name="ln6785">    // with the original attitude stored in a prop.</a>
<a name="ln6786">    if (m.props.exists(&quot;old_attitude&quot;))</a>
<a name="ln6787">    {</a>
<a name="ln6788">        m.attitude = static_cast&lt;mon_attitude_type&gt;(</a>
<a name="ln6789">                                        m.props[&quot;old_attitude&quot;].get_short());</a>
<a name="ln6790">        m.props.erase(&quot;old_attitude&quot;);</a>
<a name="ln6791">    }</a>
<a name="ln6792"> </a>
<a name="ln6793">    if (th.getMinorVersion() &lt; TAG_MINOR_LEVEL_XP_VAULTS</a>
<a name="ln6794">        &amp;&amp; m.props.exists(&quot;map&quot;))</a>
<a name="ln6795">    {</a>
<a name="ln6796">        m.xp_tracking = XP_VAULT;</a>
<a name="ln6797">    }</a>
<a name="ln6798">#endif</a>
<a name="ln6799"> </a>
<a name="ln6800">    if (m.type != MONS_PROGRAM_BUG &amp;&amp; mons_species(m.type) == MONS_PROGRAM_BUG)</a>
<a name="ln6801">    {</a>
<a name="ln6802">        m.type = MONS_GHOST;</a>
<a name="ln6803">        m.props.clear();</a>
<a name="ln6804">    }</a>
<a name="ln6805"> </a>
<a name="ln6806">    // If an upgrade synthesizes ghost_demon, please mark it in &quot;parts&quot; above.</a>
<a name="ln6807">    ASSERT(parts &amp; MP_GHOST_DEMON || !mons_is_ghost_demon(m.type));</a>
<a name="ln6808"> </a>
<a name="ln6809">    m.check_speed();</a>
<a name="ln6810">}</a>
<a name="ln6811"> </a>
<a name="ln6812">static void _tag_read_level_monsters(reader &amp;th)</a>
<a name="ln6813">{</a>
<a name="ln6814">    unwind_bool dont_scan(crawl_state.crash_debug_scans_safe, false);</a>
<a name="ln6815">    int count;</a>
<a name="ln6816"> </a>
<a name="ln6817">    reset_all_monsters();</a>
<a name="ln6818"> </a>
<a name="ln6819">    // how many mons_alloc?</a>
<a name="ln6820">    count = unmarshallByte(th);</a>
<a name="ln6821">    ASSERT(count &gt;= 0);</a>
<a name="ln6822">    for (int i = 0; i &lt; count &amp;&amp; i &lt; MAX_MONS_ALLOC; ++i)</a>
<a name="ln6823">        env.mons_alloc[i] = unmarshallMonType(th);</a>
<a name="ln6824">    for (int i = MAX_MONS_ALLOC; i &lt; count; ++i)</a>
<a name="ln6825">        unmarshallShort(th);</a>
<a name="ln6826">    for (int i = count; i &lt; MAX_MONS_ALLOC; ++i)</a>
<a name="ln6827">        env.mons_alloc[i] = MONS_NO_MONSTER;</a>
<a name="ln6828"> </a>
<a name="ln6829">    // how many monsters?</a>
<a name="ln6830">    count = unmarshallShort(th);</a>
<a name="ln6831">    ASSERT_RANGE(count, 0, MAX_MONSTERS + 1);</a>
<a name="ln6832"> </a>
<a name="ln6833">    for (int i = 0; i &lt; count; i++)</a>
<a name="ln6834">    {</a>
<a name="ln6835">        monster&amp; m = menv[i];</a>
<a name="ln6836">        unmarshallMonster(th, m);</a>
<a name="ln6837"> </a>
<a name="ln6838">        // place monster</a>
<a name="ln6839">        if (!m.alive())</a>
<a name="ln6840">            continue;</a>
<a name="ln6841"> </a>
<a name="ln6842">        monster *dup_m = monster_by_mid(m.mid);</a>
<a name="ln6843"> </a>
<a name="ln6844">#if TAG_MAJOR_VERSION == 34</a>
<a name="ln6845">        // clear duplicates of followers who got their god cleared as the result</a>
<a name="ln6846">        // of a bad polymorph prior to e6d7efa92cb0. This only fires on level</a>
<a name="ln6847">        // load *when there are duplicate mids*, because otherwise the clones</a>
<a name="ln6848">        // aren't uniquely identifiable. This fix may still result in duplicate</a>
<a name="ln6849">        // mid errors from time to time, but should never crash; saving and</a>
<a name="ln6850">        // loading will fix up the duplicate errors. A similar check also</a>
<a name="ln6851">        // happens in follower::place (since that runs after the level is</a>
<a name="ln6852">        // loaded).</a>
<a name="ln6853">        if (dup_m)</a>
<a name="ln6854">        {</a>
<a name="ln6855">            if (maybe_bad_priest_monster(*dup_m))</a>
<a name="ln6856">                fixup_bad_priest_monster(*dup_m);</a>
<a name="ln6857">            else if (maybe_bad_priest_monster(m))</a>
<a name="ln6858">            {</a>
<a name="ln6859">                fixup_bad_priest_monster(m);</a>
<a name="ln6860">                env.mid_cache[dup_m-&gt;mid] = dup_m-&gt;mindex();</a>
<a name="ln6861">                // dup_m should already be placed, so nothing else is needed.</a>
<a name="ln6862">                continue;</a>
<a name="ln6863">            }</a>
<a name="ln6864">            // we could print an error on the else case, but this is already</a>
<a name="ln6865">            // going to be handled by debug_mons_scan.</a>
<a name="ln6866">        }</a>
<a name="ln6867">#endif</a>
<a name="ln6868"> </a>
<a name="ln6869">        // companion_is_elsewhere checks the mid cache</a>
<a name="ln6870">        env.mid_cache[m.mid] = i;</a>
<a name="ln6871">        if (m.is_divine_companion() &amp;&amp; companion_is_elsewhere(m.mid))</a>
<a name="ln6872">        {</a>
<a name="ln6873">            dprf(&quot;Killed elsewhere companion %s(%d) on %s&quot;,</a>
<a name="ln6874">                    m.name(DESC_PLAIN, true).c_str(), m.mid,</a>
<a name="ln6875">                    level_id::current().describe(false, true).c_str());</a>
<a name="ln6876">            monster_die(m, KILL_RESET, -1, true, false);</a>
<a name="ln6877">            // avoid &quot;mid cache bogosity&quot; if there's an unhandled clone bug</a>
<a name="ln6878">            if (dup_m &amp;&amp; dup_m-&gt;alive())</a>
<a name="ln6879">            {</a>
<a name="ln6880">                mprf(MSGCH_ERROR, &quot;elsewhere companion has duplicate mid %d: %s&quot;,</a>
<a name="ln6881">                    dup_m-&gt;mid, dup_m-&gt;full_name(DESC_PLAIN).c_str());</a>
<a name="ln6882">                env.mid_cache[dup_m-&gt;mid] = dup_m-&gt;mindex();</a>
<a name="ln6883">            }</a>
<a name="ln6884">            continue;</a>
<a name="ln6885">        }</a>
<a name="ln6886"> </a>
<a name="ln6887">#if defined(DEBUG) || defined(DEBUG_MONS_SCAN)</a>
<a name="ln6888">        if (invalid_monster_type(m.type))</a>
<a name="ln6889">        {</a>
<a name="ln6890">            mprf(MSGCH_ERROR, &quot;Unmarshalled monster #%d %s&quot;,</a>
<a name="ln6891">                 i, m.name(DESC_PLAIN, true).c_str());</a>
<a name="ln6892">        }</a>
<a name="ln6893">        if (!in_bounds(m.pos()))</a>
<a name="ln6894">        {</a>
<a name="ln6895">            mprf(MSGCH_ERROR,</a>
<a name="ln6896">                 &quot;Unmarshalled monster #%d %s out of bounds at (%d, %d)&quot;,</a>
<a name="ln6897">                 i, m.name(DESC_PLAIN, true).c_str(),</a>
<a name="ln6898">                 m.pos().x, m.pos().y);</a>
<a name="ln6899">        }</a>
<a name="ln6900">        int midx = mgrd(m.pos());</a>
<a name="ln6901">        if (midx != NON_MONSTER)</a>
<a name="ln6902">        {</a>
<a name="ln6903">            mprf(MSGCH_ERROR, &quot;(%d, %d) for %s already occupied by %s&quot;,</a>
<a name="ln6904">                 m.pos().x, m.pos().y,</a>
<a name="ln6905">                 m.name(DESC_PLAIN, true).c_str(),</a>
<a name="ln6906">                 menv[midx].name(DESC_PLAIN, true).c_str());</a>
<a name="ln6907">        }</a>
<a name="ln6908">#endif</a>
<a name="ln6909">        mgrd(m.pos()) = i;</a>
<a name="ln6910">    }</a>
<a name="ln6911">#if TAG_MAJOR_VERSION == 34</a>
<a name="ln6912">    // This relies on TAG_YOU (including lost monsters) being unmarshalled</a>
<a name="ln6913">    // on game load before the initial level.</a>
<a name="ln6914">    if (th.getMinorVersion() &lt; TAG_MINOR_FIXED_CONSTRICTION</a>
<a name="ln6915">        &amp;&amp; th.getMinorVersion() &gt;= TAG_MINOR_OPTIONAL_PARTS)</a>
<a name="ln6916">    {</a>
<a name="ln6917">        _fix_missing_constrictions();</a>
<a name="ln6918">    }</a>
<a name="ln6919">    if (th.getMinorVersion() &lt; TAG_MINOR_TENTACLE_MID)</a>
<a name="ln6920">    {</a>
<a name="ln6921">        for (monster_iterator mi; mi; ++mi)</a>
<a name="ln6922">        {</a>
<a name="ln6923">            if (mi-&gt;props.exists(&quot;inwards&quot;))</a>
<a name="ln6924">            {</a>
<a name="ln6925">                const int old_midx = mi-&gt;props[&quot;inwards&quot;].get_int();</a>
<a name="ln6926">                if (invalid_monster_index(old_midx))</a>
<a name="ln6927">                    mi-&gt;props[&quot;inwards&quot;].get_int() = MID_NOBODY;</a>
<a name="ln6928">                else</a>
<a name="ln6929">                    mi-&gt;props[&quot;inwards&quot;].get_int() = menv[old_midx].mid;</a>
<a name="ln6930">            }</a>
<a name="ln6931">            if (mi-&gt;props.exists(&quot;outwards&quot;))</a>
<a name="ln6932">            {</a>
<a name="ln6933">                const int old_midx = mi-&gt;props[&quot;outwards&quot;].get_int();</a>
<a name="ln6934">                if (invalid_monster_index(old_midx))</a>
<a name="ln6935">                    mi-&gt;props[&quot;outwards&quot;].get_int() = MID_NOBODY;</a>
<a name="ln6936">                else</a>
<a name="ln6937">                    mi-&gt;props[&quot;outwards&quot;].get_int() = menv[old_midx].mid;</a>
<a name="ln6938">            }</a>
<a name="ln6939">            if (mons_is_tentacle_or_tentacle_segment(mi-&gt;type))</a>
<a name="ln6940">                mi-&gt;tentacle_connect = menv[mi-&gt;tentacle_connect].mid;</a>
<a name="ln6941">        }</a>
<a name="ln6942">    }</a>
<a name="ln6943">#endif</a>
<a name="ln6944">}</a>
<a name="ln6945"> </a>
<a name="ln6946">static void _debug_count_tiles()</a>
<a name="ln6947">{</a>
<a name="ln6948">#ifdef DEBUG_DIAGNOSTICS</a>
<a name="ln6949"># ifdef USE_TILE</a>
<a name="ln6950">    map&lt;int,bool&gt; found;</a>
<a name="ln6951">    int t, cnt = 0;</a>
<a name="ln6952">    for (int i = 0; i &lt; GXM; i++)</a>
<a name="ln6953">        for (int j = 0; j &lt; GYM; j++)</a>
<a name="ln6954">        {</a>
<a name="ln6955">            t = env.tile_bk_bg[i][j];</a>
<a name="ln6956">            if (!found.count(t))</a>
<a name="ln6957">                cnt++, found[t] = true;</a>
<a name="ln6958">            t = env.tile_bk_fg[i][j];</a>
<a name="ln6959">            if (!found.count(t))</a>
<a name="ln6960">                cnt++, found[t] = true;</a>
<a name="ln6961">            t = env.tile_bk_cloud[i][j];</a>
<a name="ln6962">            if (!found.count(t))</a>
<a name="ln6963">                cnt++, found[t] = true;</a>
<a name="ln6964">        }</a>
<a name="ln6965">    dprf(&quot;Unique tiles found: %d&quot;, cnt);</a>
<a name="ln6966"># endif</a>
<a name="ln6967">#endif</a>
<a name="ln6968">}</a>
<a name="ln6969"> </a>
<a name="ln6970">void _tag_read_level_tiles(reader &amp;th)</a>
<a name="ln6971">{</a>
<a name="ln6972">    // Map grids.</a>
<a name="ln6973">    // how many X?</a>
<a name="ln6974">    const int gx = unmarshallShort(th);</a>
<a name="ln6975">    // how many Y?</a>
<a name="ln6976">    const int gy = unmarshallShort(th);</a>
<a name="ln6977"> </a>
<a name="ln6978">    env.tile_names.clear();</a>
<a name="ln6979">    unsigned int num_tilenames = unmarshallShort(th);</a>
<a name="ln6980">    for (unsigned int i = 0; i &lt; num_tilenames; ++i)</a>
<a name="ln6981">    {</a>
<a name="ln6982">#ifdef DEBUG_TILE_NAMES</a>
<a name="ln6983">        string temp = unmarshallString(th);</a>
<a name="ln6984">        mprf(&quot;Reading tile_names[%d] = %s&quot;, i, temp.c_str());</a>
<a name="ln6985">        env.tile_names.push_back(temp);</a>
<a name="ln6986">#else</a>
<a name="ln6987">        env.tile_names.push_back(unmarshallString(th));</a>
<a name="ln6988">#endif</a>
<a name="ln6989">    }</a>
<a name="ln6990"> </a>
<a name="ln6991">    // flavour</a>
<a name="ln6992">    env.tile_default.wall_idx  = unmarshallShort(th);</a>
<a name="ln6993">    env.tile_default.floor_idx = unmarshallShort(th);</a>
<a name="ln6994">    env.tile_default.wall      = unmarshallShort(th);</a>
<a name="ln6995">    env.tile_default.floor     = unmarshallShort(th);</a>
<a name="ln6996">    env.tile_default.special   = unmarshallShort(th);</a>
<a name="ln6997"> </a>
<a name="ln6998">    for (int x = 0; x &lt; gx; x++)</a>
<a name="ln6999">        for (int y = 0; y &lt; gy; y++)</a>
<a name="ln7000">        {</a>
<a name="ln7001">            env.tile_flv[x][y].wall_idx  = unmarshallShort(th);</a>
<a name="ln7002">            env.tile_flv[x][y].floor_idx = unmarshallShort(th);</a>
<a name="ln7003">            env.tile_flv[x][y].feat_idx  = unmarshallShort(th);</a>
<a name="ln7004"> </a>
<a name="ln7005">            // These get overwritten by _regenerate_tile_flavour</a>
<a name="ln7006">            env.tile_flv[x][y].wall    = unmarshallShort(th);</a>
<a name="ln7007">            env.tile_flv[x][y].floor   = unmarshallShort(th);</a>
<a name="ln7008">            env.tile_flv[x][y].feat    = unmarshallShort(th);</a>
<a name="ln7009">            env.tile_flv[x][y].special = unmarshallShort(th);</a>
<a name="ln7010">        }</a>
<a name="ln7011"> </a>
<a name="ln7012">    _debug_count_tiles();</a>
<a name="ln7013"> </a>
<a name="ln7014">    _regenerate_tile_flavour();</a>
<a name="ln7015"> </a>
<a name="ln7016">    // Draw remembered map</a>
<a name="ln7017">    _draw_tiles();</a>
<a name="ln7018">}</a>
<a name="ln7019"> </a>
<a name="ln7020">static tileidx_t _get_tile_from_vector(const unsigned int idx)</a>
<a name="ln7021">{</a>
<a name="ln7022">    if (idx &lt;= 0 || idx &gt; env.tile_names.size())</a>
<a name="ln7023">    {</a>
<a name="ln7024">#ifdef DEBUG_TILE_NAMES</a>
<a name="ln7025">        mprf(&quot;Index out of bounds: idx = %d - 1, size(tile_names) = %d&quot;,</a>
<a name="ln7026">            idx, env.tile_names.size());</a>
<a name="ln7027">#endif</a>
<a name="ln7028">        return 0;</a>
<a name="ln7029">    }</a>
<a name="ln7030">    string tilename = env.tile_names[idx - 1];</a>
<a name="ln7031"> </a>
<a name="ln7032">    tileidx_t tile;</a>
<a name="ln7033">    if (!tile_dngn_index(tilename.c_str(), &amp;tile))</a>
<a name="ln7034">    {</a>
<a name="ln7035">#ifdef DEBUG_TILE_NAMES</a>
<a name="ln7036">        mprf(&quot;tilename %s (index %d) not found&quot;,</a>
<a name="ln7037">             tilename.c_str(), idx - 1);</a>
<a name="ln7038">#endif</a>
<a name="ln7039">        return 0;</a>
<a name="ln7040">    }</a>
<a name="ln7041">#ifdef DEBUG_TILE_NAMES</a>
<a name="ln7042">    mprf(&quot;tilename %s (index %d) resolves to tile %d&quot;,</a>
<a name="ln7043">         tilename.c_str(), idx - 1, (int) tile);</a>
<a name="ln7044">#endif</a>
<a name="ln7045"> </a>
<a name="ln7046">    return tile;</a>
<a name="ln7047">}</a>
<a name="ln7048"> </a>
<a name="ln7049">static void _regenerate_tile_flavour()</a>
<a name="ln7050">{</a>
<a name="ln7051">    /* Remember the wall_idx and floor_idx; tile_init_default_flavour</a>
<a name="ln7052">       sets them to 0 */</a>
<a name="ln7053">    tileidx_t default_wall_idx = env.tile_default.wall_idx;</a>
<a name="ln7054">    tileidx_t default_floor_idx = env.tile_default.floor_idx;</a>
<a name="ln7055">    tile_init_default_flavour();</a>
<a name="ln7056">    if (default_wall_idx)</a>
<a name="ln7057">    {</a>
<a name="ln7058">        tileidx_t new_wall = _get_tile_from_vector(default_wall_idx);</a>
<a name="ln7059">        if (new_wall)</a>
<a name="ln7060">        {</a>
<a name="ln7061">            env.tile_default.wall_idx = default_wall_idx;</a>
<a name="ln7062">            env.tile_default.wall = new_wall;</a>
<a name="ln7063">        }</a>
<a name="ln7064">    }</a>
<a name="ln7065">    if (default_floor_idx)</a>
<a name="ln7066">    {</a>
<a name="ln7067">        tileidx_t new_floor = _get_tile_from_vector(default_floor_idx);</a>
<a name="ln7068">        if (new_floor)</a>
<a name="ln7069">        {</a>
<a name="ln7070">            env.tile_default.floor_idx = default_floor_idx;</a>
<a name="ln7071">            env.tile_default.floor = new_floor;</a>
<a name="ln7072">        }</a>
<a name="ln7073">    }</a>
<a name="ln7074"> </a>
<a name="ln7075">    for (rectangle_iterator ri(coord_def(0, 0), coord_def(GXM-1, GYM-1));</a>
<a name="ln7076">         ri; ++ri)</a>
<a name="ln7077">    {</a>
<a name="ln7078">        tile_flavour &amp;flv = env.tile_flv(*ri);</a>
<a name="ln7079">        flv.wall = 0;</a>
<a name="ln7080">        flv.floor = 0;</a>
<a name="ln7081">        flv.feat = 0;</a>
<a name="ln7082">        flv.special = 0;</a>
<a name="ln7083"> </a>
<a name="ln7084">        if (flv.wall_idx)</a>
<a name="ln7085">        {</a>
<a name="ln7086">            tileidx_t new_wall = _get_tile_from_vector(flv.wall_idx);</a>
<a name="ln7087">            if (!new_wall)</a>
<a name="ln7088">                flv.wall_idx = 0;</a>
<a name="ln7089">            else</a>
<a name="ln7090">                flv.wall = new_wall;</a>
<a name="ln7091">        }</a>
<a name="ln7092">        if (flv.floor_idx)</a>
<a name="ln7093">        {</a>
<a name="ln7094">            tileidx_t new_floor = _get_tile_from_vector(flv.floor_idx);</a>
<a name="ln7095">            if (!new_floor)</a>
<a name="ln7096">                flv.floor_idx = 0;</a>
<a name="ln7097">            else</a>
<a name="ln7098">                flv.floor = new_floor;</a>
<a name="ln7099">        }</a>
<a name="ln7100">        if (flv.feat_idx)</a>
<a name="ln7101">        {</a>
<a name="ln7102">            tileidx_t new_feat = _get_tile_from_vector(flv.feat_idx);</a>
<a name="ln7103">            if (!new_feat)</a>
<a name="ln7104">                flv.feat_idx = 0;</a>
<a name="ln7105">            else</a>
<a name="ln7106">                flv.feat = new_feat;</a>
<a name="ln7107">        }</a>
<a name="ln7108">    }</a>
<a name="ln7109"> </a>
<a name="ln7110">    tile_new_level(true, false);</a>
<a name="ln7111">}</a>
<a name="ln7112"> </a>
<a name="ln7113">static void _draw_tiles()</a>
<a name="ln7114">{</a>
<a name="ln7115">#ifdef USE_TILE</a>
<a name="ln7116">    for (rectangle_iterator ri(coord_def(0, 0), coord_def(GXM-1, GYM-1));</a>
<a name="ln7117">         ri; ++ri)</a>
<a name="ln7118">    {</a>
<a name="ln7119">        tile_draw_map_cell(*ri);</a>
<a name="ln7120">    }</a>
<a name="ln7121">#endif</a>
<a name="ln7122">}</a>
<a name="ln7123">// ------------------------------- ghost tags ---------------------------- //</a>
<a name="ln7124"> </a>
<a name="ln7125">static void _marshallSpells(writer &amp;th, const monster_spells &amp;spells)</a>
<a name="ln7126">{</a>
<a name="ln7127">    const uint8_t spellsize = spells.size();</a>
<a name="ln7128">    marshallByte(th, spellsize);</a>
<a name="ln7129">    for (int j = 0; j &lt; spellsize; ++j)</a>
<a name="ln7130">    {</a>
<a name="ln7131">        marshallShort(th, spells[j].spell);</a>
<a name="ln7132">        marshallByte(th, spells[j].freq);</a>
<a name="ln7133">        marshallShort(th, spells[j].flags.flags);</a>
<a name="ln7134">    }</a>
<a name="ln7135">}</a>
<a name="ln7136"> </a>
<a name="ln7137">#if TAG_MAJOR_VERSION == 34</a>
<a name="ln7138">static const int NUM_MONSTER_SPELL_SLOTS = 6;</a>
<a name="ln7139"> </a>
<a name="ln7140">static void _fixup_spells(monster_spells &amp;spells, int hd)</a>
<a name="ln7141">{</a>
<a name="ln7142">    for (auto&amp; slot : spells)</a>
<a name="ln7143">        slot.flags |= MON_SPELL_WIZARD;</a>
<a name="ln7144"> </a>
<a name="ln7145">    if (spells.size() &gt;= NUM_MONSTER_SPELL_SLOTS)</a>
<a name="ln7146">        spells[NUM_MONSTER_SPELL_SLOTS-1].flags |= MON_SPELL_EMERGENCY;</a>
<a name="ln7147"> </a>
<a name="ln7148">    for (auto&amp; slot : spells)</a>
<a name="ln7149">        slot.freq = (hd + 50) / spells.size();</a>
<a name="ln7150">}</a>
<a name="ln7151">#endif</a>
<a name="ln7152"> </a>
<a name="ln7153">void unmarshallSpells(reader &amp;th, monster_spells &amp;spells</a>
<a name="ln7154">#if TAG_MAJOR_VERSION == 34</a>
<a name="ln7155">                             , unsigned hd</a>
<a name="ln7156">#endif</a>
<a name="ln7157">                            )</a>
<a name="ln7158">{</a>
<a name="ln7159">    const uint8_t spellsize =</a>
<a name="ln7160">#if TAG_MAJOR_VERSION == 34</a>
<a name="ln7161"> </a>
<a name="ln7162">        (th.getMinorVersion() &lt; TAG_MINOR_ARB_SPELL_SLOTS)</a>
<a name="ln7163">            ? NUM_MONSTER_SPELL_SLOTS :</a>
<a name="ln7164">#endif</a>
<a name="ln7165">        unmarshallByte(th);</a>
<a name="ln7166">    spells.clear();</a>
<a name="ln7167">    spells.resize(spellsize);</a>
<a name="ln7168">    for (int j = 0; j &lt; spellsize; ++j)</a>
<a name="ln7169">    {</a>
<a name="ln7170">        spells[j].spell = unmarshallSpellType(th</a>
<a name="ln7171"> </a>
<a name="ln7172">#if TAG_MAJOR_VERSION == 34</a>
<a name="ln7173">            , true</a>
<a name="ln7174">#endif</a>
<a name="ln7175">            );</a>
<a name="ln7176">#if TAG_MAJOR_VERSION == 34</a>
<a name="ln7177">        if (th.getMinorVersion() &lt; TAG_MINOR_MALMUTATE</a>
<a name="ln7178">            &amp;&amp; spells[j].spell == SPELL_POLYMORPH)</a>
<a name="ln7179">        {</a>
<a name="ln7180">            spells[j].spell = SPELL_MALMUTATE;</a>
<a name="ln7181">        }</a>
<a name="ln7182"> </a>
<a name="ln7183">        if (spells[j].spell == SPELL_FAKE_RAKSHASA_SUMMON)</a>
<a name="ln7184">            spells[j].spell = SPELL_PHANTOM_MIRROR;</a>
<a name="ln7185"> </a>
<a name="ln7186">        if (spells[j].spell == SPELL_SUNRAY)</a>
<a name="ln7187">            spells[j].spell = SPELL_STONE_ARROW;</a>
<a name="ln7188"> </a>
<a name="ln7189">        if (th.getMinorVersion() &gt;= TAG_MINOR_MONSTER_SPELL_SLOTS)</a>
<a name="ln7190">        {</a>
<a name="ln7191">#endif</a>
<a name="ln7192">            spells[j].freq = unmarshallByte(th);</a>
<a name="ln7193">            spells[j].flags.flags = unmarshallShort(th);</a>
<a name="ln7194">#if TAG_MAJOR_VERSION == 34</a>
<a name="ln7195">            if (th.getMinorVersion() &lt; TAG_MINOR_DEMONIC_SPELLS)</a>
<a name="ln7196">            {</a>
<a name="ln7197">                if (spells[j].flags &amp; MON_SPELL_DEMONIC)</a>
<a name="ln7198">                {</a>
<a name="ln7199">                    spells[j].flags &amp;= ~MON_SPELL_DEMONIC;</a>
<a name="ln7200">                    spells[j].flags |= MON_SPELL_MAGICAL;</a>
<a name="ln7201">                }</a>
<a name="ln7202">            }</a>
<a name="ln7203">        }</a>
<a name="ln7204">#endif</a>
<a name="ln7205"> </a>
<a name="ln7206">        if (spell_removed(spells[j].spell))</a>
<a name="ln7207">            spells[j].spell = SPELL_NO_SPELL;</a>
<a name="ln7208">    }</a>
<a name="ln7209"> </a>
<a name="ln7210">    int total_given_freq = 0;</a>
<a name="ln7211">    for (const auto &amp;slot : spells)</a>
<a name="ln7212">        total_given_freq += slot.freq;</a>
<a name="ln7213"> </a>
<a name="ln7214">    erase_if(spells, [](const mon_spell_slot &amp;t) {</a>
<a name="ln7215">        return t.spell == SPELL_NO_SPELL;</a>
<a name="ln7216">    });</a>
<a name="ln7217"> </a>
<a name="ln7218">#if TAG_MAJOR_VERSION == 34</a>
<a name="ln7219">    // This will turn all old spells into wizard spells, which</a>
<a name="ln7220">    // isn't right but is the simplest way to do this.</a>
<a name="ln7221">    if (th.getMinorVersion() &lt; TAG_MINOR_MONSTER_SPELL_SLOTS)</a>
<a name="ln7222">    {</a>
<a name="ln7223">        _fixup_spells(spells, hd);</a>
<a name="ln7224">        total_given_freq = spell_freq_for_hd(hd);  // would be zero otherwise</a>
<a name="ln7225">    }</a>
<a name="ln7226">#endif</a>
<a name="ln7227"> </a>
<a name="ln7228">    normalize_spell_freq(spells, total_given_freq);</a>
<a name="ln7229">}</a>
<a name="ln7230"> </a>
<a name="ln7231">static void _marshallGhost(writer &amp;th, const ghost_demon &amp;ghost)</a>
<a name="ln7232">{</a>
<a name="ln7233">    // save compat changes with minor tags here must be added to bones_minor_tags</a>
<a name="ln7234">    marshallString(th, ghost.name);</a>
<a name="ln7235"> </a>
<a name="ln7236">    marshallShort(th, ghost.species);</a>
<a name="ln7237">    marshallShort(th, ghost.job);</a>
<a name="ln7238">    marshallByte(th, ghost.religion);</a>
<a name="ln7239">    marshallShort(th, ghost.best_skill);</a>
<a name="ln7240">    marshallShort(th, ghost.best_skill_level);</a>
<a name="ln7241">    marshallShort(th, ghost.xl);</a>
<a name="ln7242">    marshallShort(th, ghost.max_hp);</a>
<a name="ln7243">    marshallShort(th, ghost.ev);</a>
<a name="ln7244">    marshallShort(th, ghost.ac);</a>
<a name="ln7245">    marshallShort(th, ghost.damage);</a>
<a name="ln7246">    marshallShort(th, ghost.speed);</a>
<a name="ln7247">    marshallShort(th, ghost.move_energy);</a>
<a name="ln7248">    marshallByte(th, ghost.see_invis);</a>
<a name="ln7249">    marshallShort(th, ghost.brand);</a>
<a name="ln7250">    marshallShort(th, ghost.att_type);</a>
<a name="ln7251">    marshallShort(th, ghost.att_flav);</a>
<a name="ln7252">    marshallInt(th, ghost.resists);</a>
<a name="ln7253">    marshallByte(th, ghost.colour);</a>
<a name="ln7254">    marshallBoolean(th, ghost.flies);</a>
<a name="ln7255"> </a>
<a name="ln7256">    _marshallSpells(th, ghost.spells);</a>
<a name="ln7257">}</a>
<a name="ln7258"> </a>
<a name="ln7259">static ghost_demon _unmarshallGhost(reader &amp;th)</a>
<a name="ln7260">{</a>
<a name="ln7261">    // save compat changes with minor tags here must be added to bones_minor_tags</a>
<a name="ln7262">    ghost_demon ghost;</a>
<a name="ln7263"> </a>
<a name="ln7264">    ghost.name             = unmarshallString(th);</a>
<a name="ln7265">    ghost.species          = static_cast&lt;species_type&gt;(unmarshallShort(th));</a>
<a name="ln7266">    ghost.job              = static_cast&lt;job_type&gt;(unmarshallShort(th));</a>
<a name="ln7267">    ghost.religion         = static_cast&lt;god_type&gt;(unmarshallByte(th));</a>
<a name="ln7268">    ghost.best_skill       = static_cast&lt;skill_type&gt;(unmarshallShort(th));</a>
<a name="ln7269">    ghost.best_skill_level = unmarshallShort(th);</a>
<a name="ln7270">    ghost.xl               = unmarshallShort(th);</a>
<a name="ln7271">    ghost.max_hp           = unmarshallShort(th);</a>
<a name="ln7272">    ghost.ev               = unmarshallShort(th);</a>
<a name="ln7273">    ghost.ac               = unmarshallShort(th);</a>
<a name="ln7274">    ghost.damage           = unmarshallShort(th);</a>
<a name="ln7275">    ghost.speed            = unmarshallShort(th);</a>
<a name="ln7276">#if TAG_MAJOR_VERSION == 34</a>
<a name="ln7277">    if (th.getMinorVersion() &lt; TAG_MINOR_GHOST_ENERGY)</a>
<a name="ln7278">        ghost.move_energy  = 10;</a>
<a name="ln7279">    else</a>
<a name="ln7280">#endif</a>
<a name="ln7281">    ghost.move_energy      = unmarshallShort(th);</a>
<a name="ln7282">    // fix up ghost_demons that forgot to have move_energy initialized</a>
<a name="ln7283">    if (ghost.move_energy &lt; FASTEST_PLAYER_MOVE_SPEED</a>
<a name="ln7284">        || ghost.move_energy &gt; 15) // Ponderous naga</a>
<a name="ln7285">    {</a>
<a name="ln7286">        ghost.move_energy = 10;</a>
<a name="ln7287">    }</a>
<a name="ln7288">    ghost.see_invis        = unmarshallByte(th);</a>
<a name="ln7289">    ghost.brand            = static_cast&lt;brand_type&gt;(unmarshallShort(th));</a>
<a name="ln7290">    ghost.att_type = static_cast&lt;attack_type&gt;(unmarshallShort(th));</a>
<a name="ln7291">    ghost.att_flav = static_cast&lt;attack_flavour&gt;(unmarshallShort(th));</a>
<a name="ln7292">    ghost.resists          = unmarshallInt(th);</a>
<a name="ln7293">#if TAG_MAJOR_VERSION == 34</a>
<a name="ln7294">    if (ghost.resists &amp; MR_OLD_RES_ACID)</a>
<a name="ln7295">        set_resist(ghost.resists, MR_RES_ACID, 3);</a>
<a name="ln7296">    if (th.getMinorVersion() &lt; TAG_MINOR_NO_GHOST_SPELLCASTER)</a>
<a name="ln7297">        unmarshallByte(th);</a>
<a name="ln7298">    if (th.getMinorVersion() &lt; TAG_MINOR_MON_COLOUR_LOOKUP)</a>
<a name="ln7299">        unmarshallByte(th);</a>
<a name="ln7300">#endif</a>
<a name="ln7301">    ghost.colour           = unmarshallByte(th);</a>
<a name="ln7302"> </a>
<a name="ln7303">#if TAG_MAJOR_VERSION == 34</a>
<a name="ln7304">    if (th.getMinorVersion() &lt; TAG_MINOR_BOOL_FLIGHT)</a>
<a name="ln7305">        ghost.flies        = unmarshallShort(th);</a>
<a name="ln7306">    else</a>
<a name="ln7307">#endif</a>
<a name="ln7308">    ghost.flies        = unmarshallBoolean(th);</a>
<a name="ln7309"> </a>
<a name="ln7310">    unmarshallSpells(th, ghost.spells</a>
<a name="ln7311">#if TAG_MAJOR_VERSION == 34</a>
<a name="ln7312">                     , ghost.xl</a>
<a name="ln7313">#endif</a>
<a name="ln7314">                    );</a>
<a name="ln7315"> </a>
<a name="ln7316">#if TAG_MAJOR_VERSION == 34</a>
<a name="ln7317">    monster_spells oldspells = ghost.spells;</a>
<a name="ln7318">    ghost.spells.clear();</a>
<a name="ln7319">    for (mon_spell_slot &amp;slot : oldspells)</a>
<a name="ln7320">    {</a>
<a name="ln7321">        if (th.getMinorVersion() &lt; TAG_MINOR_GHOST_MAGIC)</a>
<a name="ln7322">            slot.spell = _fixup_positional_monster_spell(slot.spell);</a>
<a name="ln7323"> </a>
<a name="ln7324">        ghost.spells.push_back(slot);</a>
<a name="ln7325">    }</a>
<a name="ln7326">#endif</a>
<a name="ln7327"> </a>
<a name="ln7328">    return ghost;</a>
<a name="ln7329">}</a>
<a name="ln7330"> </a>
<a name="ln7331">static void _tag_construct_ghost(writer &amp;th, vector&lt;ghost_demon&gt; &amp;ghosts)</a>
<a name="ln7332">{</a>
<a name="ln7333">    // How many ghosts?</a>
<a name="ln7334">    marshallShort(th, ghosts.size());</a>
<a name="ln7335"> </a>
<a name="ln7336">    for (const ghost_demon &amp;ghost : ghosts)</a>
<a name="ln7337">        _marshallGhost(th, ghost);</a>
<a name="ln7338">}</a>
<a name="ln7339"> </a>
<a name="ln7340">static vector&lt;ghost_demon&gt; _tag_read_ghost(reader &amp;th)</a>
<a name="ln7341">{</a>
<a name="ln7342">    vector&lt;ghost_demon&gt; result;</a>
<a name="ln7343">    int nghosts = unmarshallShort(th);</a>
<a name="ln7344"> </a>
<a name="ln7345">    if (nghosts &lt; 1 || nghosts &gt; MAX_GHOSTS)</a>
<a name="ln7346">    {</a>
<a name="ln7347">        string error = &quot;Bones file has an invalid ghost count (&quot; +</a>
<a name="ln7348">                                                    to_string(nghosts) + &quot;)&quot;;</a>
<a name="ln7349">        throw corrupted_save(error);</a>
<a name="ln7350">    }</a>
<a name="ln7351"> </a>
<a name="ln7352">    for (int i = 0; i &lt; nghosts; ++i)</a>
<a name="ln7353">        result.push_back(_unmarshallGhost(th));</a>
<a name="ln7354">    return result;</a>
<a name="ln7355">}</a>
<a name="ln7356"> </a>
<a name="ln7357">vector&lt;ghost_demon&gt; tag_read_ghosts(reader &amp;th)</a>
<a name="ln7358">{</a>
<a name="ln7359">    global_ghosts.clear();</a>
<a name="ln7360">    tag_read(th, TAG_GHOST);</a>
<a name="ln7361">    return global_ghosts; // should use copy semantics?</a>
<a name="ln7362">}</a>
<a name="ln7363"> </a>
<a name="ln7364">void tag_write_ghosts(writer &amp;th, const vector&lt;ghost_demon&gt; &amp;ghosts)</a>
<a name="ln7365">{</a>
<a name="ln7366">    global_ghosts = ghosts;</a>
<a name="ln7367">    tag_write(TAG_GHOST, th);</a>
<a name="ln7368">}</a>

</code></pre>
<div class="balloon" rel="1124"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v522/" target="_blank">V522</a> There might be dereferencing of a potential null pointer 'featm'.</p></div>
<div class="balloon" rel="2071"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v1023/" target="_blank">V1023</a> A pointer without owner is added to the 'env.level_vaults' container by the 'emplace_back' method. A memory leak will occur in case of an exception.</p></div>
<div class="balloon" rel="2280"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v1016/" target="_blank">V1016</a> Expression 'you.religion >= 0' is always true.</p></div>
<div class="balloon" rel="2422"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v547/" target="_blank">V547</a> Expression 'count >= 0' is always true. Unsigned type value is always >= 0.</p></div>
<div class="balloon" rel="2745"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v648/" target="_blank">V648</a> Priority of the '&&' operation is higher than that of the '||' operation.</p></div>
<div class="balloon" rel="3378"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v560/" target="_blank">V560</a> A part of conditional expression is always false: j >= OLD_NUM_ABILITIES.</p></div>
<div class="balloon" rel="3389"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v654/" target="_blank">V654</a> The condition 'j < OLD_NUM_ABILITIES' of loop is always false.</p></div>
<div class="balloon" rel="3389"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v621/" target="_blank">V621</a> Consider inspecting the 'for' operator. It's possible that the loop will be executed incorrectly or won't be executed at all.</p></div>
<div class="balloon" rel="5646"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v1051/" target="_blank">V1051</a> Consider checking for misprints. It's possible that the 'mi.base_type' should be used inside 'mons_genus' function.</p></div>
<div class="balloon" rel="5888"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v648/" target="_blank">V648</a> Priority of the '&&' operation is higher than that of the '||' operation.</p></div>
<div class="balloon" rel="6485"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v547/" target="_blank">V547</a> Expression 'slot.spell == SPELL_CORRUPT_BODY' is always false.</p></div>
<div class="balloon" rel="7127"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v1029/" target="_blank">V1029</a> Numeric Truncation Error. Return value of the 'size' function is written to the 8-bit variable.</p></div>

<link rel="stylesheet" href="highlight.css">
<script src="highlight.pack.js"></script>
<script src="highlightjs-line-numbers.js"></script>
<script>hljs.initHighlightingOnLoad();</script>
<script>hljs.initLineNumbersOnLoad();</script>
<script>
  $(document).ready(function() {
      $('.balloon').each(function () {
          var bl = $(this);
          var line = bl.attr('rel');
          var text = $('a[name="ln'+line+'"]').text();

          var space_count = 0;
          for(var i = 0; i<text.length; i++){
              var char = text[i];
              if((char !== ' ')&&(char !== '\t'))break;
              if(char === '\t')space_count++;
              space_count++;
          }

          bl.css('margin-left', space_count*8);
          $('a[name="ln'+line+'"]').after(bl);
      });

      window.location = window.location;
  });
</script>
</body>
</html>
