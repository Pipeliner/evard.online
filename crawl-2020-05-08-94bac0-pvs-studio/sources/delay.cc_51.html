
<html>
<head>

  <meta http-equiv="Content-Type" content="text/html; charset=US-ASCII" />
  <title>delay.cc</title>

  <link rel="stylesheet" href="../style.css"/>
  <script src="../jquery-3.2.1.min.js"></script>
</head>
<body>

<pre><code class = "cpp">
<a name="ln1">/**</a>
<a name="ln2"> * @file</a>
<a name="ln3"> * @brief Functions for handling multi-turn actions.</a>
<a name="ln4">**/</a>
<a name="ln5"> </a>
<a name="ln6">#include &quot;AppHdr.h&quot;</a>
<a name="ln7"> </a>
<a name="ln8">#include &quot;delay.h&quot;</a>
<a name="ln9"> </a>
<a name="ln10">#include &lt;cstdio&gt;</a>
<a name="ln11">#include &lt;cstring&gt;</a>
<a name="ln12"> </a>
<a name="ln13">#include &quot;ability.h&quot;</a>
<a name="ln14">#include &quot;areas.h&quot;</a>
<a name="ln15">#include &quot;artefact.h&quot;</a>
<a name="ln16">#include &quot;bloodspatter.h&quot;</a>
<a name="ln17">#include &quot;butcher.h&quot;</a>
<a name="ln18">#include &quot;clua.h&quot;</a>
<a name="ln19">#include &quot;command.h&quot;</a>
<a name="ln20">#include &quot;coord.h&quot;</a>
<a name="ln21">#include &quot;database.h&quot;</a>
<a name="ln22">#include &quot;describe.h&quot;</a>
<a name="ln23">#include &quot;directn.h&quot;</a>
<a name="ln24">#include &quot;dungeon.h&quot;</a>
<a name="ln25">#include &quot;english.h&quot;</a>
<a name="ln26">#include &quot;env.h&quot;</a>
<a name="ln27">#include &quot;fineff.h&quot;</a>
<a name="ln28">#include &quot;food.h&quot;</a>
<a name="ln29">#include &quot;fprop.h&quot;</a>
<a name="ln30">#include &quot;god-companions.h&quot;</a>
<a name="ln31">#include &quot;god-passive.h&quot;</a>
<a name="ln32">#include &quot;god-wrath.h&quot;</a>
<a name="ln33">#include &quot;hints.h&quot;</a>
<a name="ln34">#include &quot;invent.h&quot;</a>
<a name="ln35">#include &quot;item-prop.h&quot;</a>
<a name="ln36">#include &quot;items.h&quot;</a>
<a name="ln37">#include &quot;item-use.h&quot;</a>
<a name="ln38">#include &quot;item-status-flag-type.h&quot;</a>
<a name="ln39">#include &quot;libutil.h&quot;</a>
<a name="ln40">#include &quot;macro.h&quot;</a>
<a name="ln41">#include &quot;message.h&quot;</a>
<a name="ln42">#include &quot;mon-act.h&quot;</a>
<a name="ln43">#include &quot;mon-behv.h&quot;</a>
<a name="ln44">#include &quot;mon-gear.h&quot;</a>
<a name="ln45">#include &quot;mon-tentacle.h&quot;</a>
<a name="ln46">#include &quot;mon-util.h&quot;</a>
<a name="ln47">#include &quot;mutation.h&quot;</a>
<a name="ln48">#include &quot;nearby-danger.h&quot;</a>
<a name="ln49">#include &quot;notes.h&quot;</a>
<a name="ln50">#include &quot;options.h&quot;</a>
<a name="ln51">#include &quot;ouch.h&quot;</a>
<a name="ln52">#include &quot;output.h&quot;</a>
<a name="ln53">#include &quot;player-equip.h&quot;</a>
<a name="ln54">#include &quot;player.h&quot;</a>
<a name="ln55">#include &quot;prompt.h&quot;</a>
<a name="ln56">#include &quot;random.h&quot;</a>
<a name="ln57">#include &quot;religion.h&quot;</a>
<a name="ln58">#include &quot;shout.h&quot;</a>
<a name="ln59">#include &quot;sound.h&quot;</a>
<a name="ln60">#include &quot;spl-selfench.h&quot;</a>
<a name="ln61">#include &quot;spl-util.h&quot;</a>
<a name="ln62">#include &quot;stairs.h&quot;</a>
<a name="ln63">#include &quot;state.h&quot;</a>
<a name="ln64">#include &quot;stringutil.h&quot;</a>
<a name="ln65">#include &quot;teleport.h&quot;</a>
<a name="ln66">#include &quot;terrain.h&quot;</a>
<a name="ln67">#include &quot;transform.h&quot;</a>
<a name="ln68">#include &quot;traps.h&quot;</a>
<a name="ln69">#include &quot;travel.h&quot;</a>
<a name="ln70">#include &quot;xom.h&quot;</a>
<a name="ln71"> </a>
<a name="ln72">int interrupt_block::interrupts_blocked = 0;</a>
<a name="ln73"> </a>
<a name="ln74">static void _xom_check_corpse_waste();</a>
<a name="ln75">static const char *_activity_interrupt_name(activity_interrupt ai);</a>
<a name="ln76"> </a>
<a name="ln77">void push_delay(shared_ptr&lt;Delay&gt; delay)</a>
<a name="ln78">{</a>
<a name="ln79">    if (delay-&gt;is_run())</a>
<a name="ln80">        clear_travel_trail();</a>
<a name="ln81">    for (auto i = you.delay_queue.begin(); i != you.delay_queue.end(); ++i)</a>
<a name="ln82">    {</a>
<a name="ln83">        if ((*i)-&gt;is_parent())</a>
<a name="ln84">        {</a>
<a name="ln85">            you.delay_queue.insert(i, delay);</a>
<a name="ln86">            you.redraw_evasion = true;</a>
<a name="ln87">            return;</a>
<a name="ln88">        }</a>
<a name="ln89">    }</a>
<a name="ln90">    you.delay_queue.push_back(delay);</a>
<a name="ln91">    you.redraw_evasion = true;</a>
<a name="ln92">}</a>
<a name="ln93"> </a>
<a name="ln94">static void _pop_delay()</a>
<a name="ln95">{</a>
<a name="ln96">    if (!you.delay_queue.empty())</a>
<a name="ln97">        you.delay_queue.erase(you.delay_queue.begin());</a>
<a name="ln98"> </a>
<a name="ln99">    you.redraw_evasion = true;</a>
<a name="ln100">}</a>
<a name="ln101"> </a>
<a name="ln102">static void _clear_pending_delays(size_t after_index = 1)</a>
<a name="ln103">{</a>
<a name="ln104">    while (you.delay_queue.size() &gt; after_index)</a>
<a name="ln105">    {</a>
<a name="ln106">        auto delay = you.delay_queue.back();</a>
<a name="ln107"> </a>
<a name="ln108">        you.delay_queue.pop_back();</a>
<a name="ln109"> </a>
<a name="ln110">        if (delay-&gt;is_run() &amp;&amp; you.running)</a>
<a name="ln111">            // If you got here, you're already clearing the delays and there's</a>
<a name="ln112">            // no need to clear them again.</a>
<a name="ln113">            stop_running(false);</a>
<a name="ln114">    }</a>
<a name="ln115">}</a>
<a name="ln116"> </a>
<a name="ln117">static void _interrupt_butchering(const char* action)</a>
<a name="ln118">{</a>
<a name="ln119">    const bool multiple_corpses =</a>
<a name="ln120">        // + 1 to avoid the first delay in the queue, which we know is</a>
<a name="ln121">        // butchering.</a>
<a name="ln122">        any_of(you.delay_queue.begin() + 1, you.delay_queue.end(),</a>
<a name="ln123">               [] (const shared_ptr&lt;Delay&gt; d)</a>
<a name="ln124">               {</a>
<a name="ln125">                   return d-&gt;is_butcher();</a>
<a name="ln126">               });</a>
<a name="ln127">    mprf(&quot;You stop %s the corpse%s.&quot;, action, multiple_corpses ? &quot;s&quot; : &quot;&quot;);</a>
<a name="ln128">}</a>
<a name="ln129"> </a>
<a name="ln130">bool ButcherDelay::try_interrupt()</a>
<a name="ln131">{</a>
<a name="ln132">    _interrupt_butchering(&quot;butchering&quot;);</a>
<a name="ln133">    return true;</a>
<a name="ln134">}</a>
<a name="ln135"> </a>
<a name="ln136">bool MemoriseDelay::try_interrupt()</a>
<a name="ln137">{</a>
<a name="ln138">    // Losing work here is okay... having to start from</a>
<a name="ln139">    // scratch is a reasonable behaviour. -- bwr</a>
<a name="ln140">    mpr(&quot;Your memorisation is interrupted.&quot;);</a>
<a name="ln141">    return true;</a>
<a name="ln142">}</a>
<a name="ln143"> </a>
<a name="ln144">bool MultidropDelay::try_interrupt()</a>
<a name="ln145">{</a>
<a name="ln146">    // No work lost</a>
<a name="ln147">    if (!items.empty())</a>
<a name="ln148">        mpr(&quot;You stop dropping stuff.&quot;);</a>
<a name="ln149">    return true;</a>
<a name="ln150">}</a>
<a name="ln151"> </a>
<a name="ln152">bool BaseRunDelay::try_interrupt()</a>
<a name="ln153">{</a>
<a name="ln154">    // Keep things consistent, otherwise disturbing phenomena can occur.</a>
<a name="ln155">    if (you.running)</a>
<a name="ln156">        stop_running(false);</a>
<a name="ln157">    update_turn_count();</a>
<a name="ln158"> </a>
<a name="ln159">    // Always interruptible.</a>
<a name="ln160">    return true;</a>
<a name="ln161">}</a>
<a name="ln162"> </a>
<a name="ln163">bool MacroDelay::try_interrupt()</a>
<a name="ln164">{</a>
<a name="ln165">    // Always interruptible.</a>
<a name="ln166">    return true;</a>
<a name="ln167">    // There's no special action needed for macros - if we don't call out</a>
<a name="ln168">    // to the Lua function, it can't do damage.</a>
<a name="ln169">}</a>
<a name="ln170"> </a>
<a name="ln171">bool ArmourOnDelay::try_interrupt()</a>
<a name="ln172">{</a>
<a name="ln173">    if (duration &gt; 1 &amp;&amp; !was_prompted)</a>
<a name="ln174">    {</a>
<a name="ln175">        if (!crawl_state.disables[DIS_CONFIRMATIONS]</a>
<a name="ln176">            &amp;&amp; !yesno(&quot;Keep equipping yourself?&quot;, false, 0, false))</a>
<a name="ln177">        {</a>
<a name="ln178">            mpr(&quot;You stop putting on your armour.&quot;);</a>
<a name="ln179">            return true;</a>
<a name="ln180">        }</a>
<a name="ln181">        else</a>
<a name="ln182">            was_prompted = true;</a>
<a name="ln183">    }</a>
<a name="ln184">    return false;</a>
<a name="ln185">}</a>
<a name="ln186"> </a>
<a name="ln187">bool ArmourOffDelay::try_interrupt()</a>
<a name="ln188">{</a>
<a name="ln189">    if (duration &gt; 1 &amp;&amp; !was_prompted)</a>
<a name="ln190">    {</a>
<a name="ln191">        if (!crawl_state.disables[DIS_CONFIRMATIONS]</a>
<a name="ln192">            &amp;&amp; !yesno(&quot;Keep disrobing?&quot;, false, 0, false))</a>
<a name="ln193">        {</a>
<a name="ln194">            mpr(&quot;You stop removing your armour.&quot;);</a>
<a name="ln195">            return true;</a>
<a name="ln196">        }</a>
<a name="ln197">        else</a>
<a name="ln198">            was_prompted = true;</a>
<a name="ln199">    }</a>
<a name="ln200">    return false;</a>
<a name="ln201">}</a>
<a name="ln202"> </a>
<a name="ln203">bool BlurryScrollDelay::try_interrupt()</a>
<a name="ln204">{</a>
<a name="ln205">    if (duration &gt; 1 &amp;&amp; !was_prompted)</a>
<a name="ln206">    {</a>
<a name="ln207">        if (!crawl_state.disables[DIS_CONFIRMATIONS]</a>
<a name="ln208">            &amp;&amp; !yesno(&quot;Keep reading the scroll?&quot;, false, 0, false))</a>
<a name="ln209">        {</a>
<a name="ln210">            mpr(&quot;You stop reading the scroll.&quot;);</a>
<a name="ln211">            return true;</a>
<a name="ln212">        }</a>
<a name="ln213">        else</a>
<a name="ln214">            was_prompted = true;</a>
<a name="ln215">    }</a>
<a name="ln216">    return false;</a>
<a name="ln217">}</a>
<a name="ln218"> </a>
<a name="ln219">bool AscendingStairsDelay::try_interrupt()</a>
<a name="ln220">{</a>
<a name="ln221">    mpr(&quot;You stop ascending the stairs.&quot;);</a>
<a name="ln222">    return true;  // short... and probably what people want</a>
<a name="ln223">}</a>
<a name="ln224"> </a>
<a name="ln225">bool DescendingStairsDelay::try_interrupt()</a>
<a name="ln226">{</a>
<a name="ln227">    mpr(&quot;You stop descending the stairs.&quot;);</a>
<a name="ln228">    return true;  // short... and probably what people want</a>
<a name="ln229">}</a>
<a name="ln230"> </a>
<a name="ln231">bool PasswallDelay::try_interrupt()</a>
<a name="ln232">{</a>
<a name="ln233">    mpr(&quot;Your meditation is interrupted.&quot;);</a>
<a name="ln234">    return true;</a>
<a name="ln235">}</a>
<a name="ln236"> </a>
<a name="ln237">bool ShaftSelfDelay::try_interrupt()</a>
<a name="ln238">{</a>
<a name="ln239">    mpr(&quot;You stop digging.&quot;);</a>
<a name="ln240">    return true;</a>
<a name="ln241">}</a>
<a name="ln242"> </a>
<a name="ln243">bool ExsanguinateDelay::try_interrupt()</a>
<a name="ln244">{</a>
<a name="ln245">    if (duration &gt; 1 &amp;&amp; !was_prompted)</a>
<a name="ln246">    {</a>
<a name="ln247">        if (!crawl_state.disables[DIS_CONFIRMATIONS]</a>
<a name="ln248">            &amp;&amp; !yesno(&quot;Keep bloodletting?&quot;, false, 0, false))</a>
<a name="ln249">        {</a>
<a name="ln250">            mpr(&quot;You stop emptying yourself of blood.&quot;);</a>
<a name="ln251">            return true;</a>
<a name="ln252">        }</a>
<a name="ln253">        else</a>
<a name="ln254">            was_prompted = true;</a>
<a name="ln255">    }</a>
<a name="ln256">    return false;</a>
<a name="ln257">}</a>
<a name="ln258"> </a>
<a name="ln259">bool RevivifyDelay::try_interrupt()</a>
<a name="ln260">{</a>
<a name="ln261">    if (duration &gt; 1 &amp;&amp; !was_prompted)</a>
<a name="ln262">    {</a>
<a name="ln263">        if (!crawl_state.disables[DIS_CONFIRMATIONS]</a>
<a name="ln264">            &amp;&amp; !yesno(&quot;Continue your ritual?&quot;, false, 0, false))</a>
<a name="ln265">        {</a>
<a name="ln266">            mpr(&quot;You stop revivifying.&quot;);</a>
<a name="ln267">            return true;</a>
<a name="ln268">        }</a>
<a name="ln269">        else</a>
<a name="ln270">            was_prompted = true;</a>
<a name="ln271">    }</a>
<a name="ln272">    return false;</a>
<a name="ln273">}</a>
<a name="ln274"> </a>
<a name="ln275">void stop_delay(bool stop_stair_travel)</a>
<a name="ln276">{</a>
<a name="ln277">    if (you.delay_queue.empty())</a>
<a name="ln278">        return;</a>
<a name="ln279"> </a>
<a name="ln280">    set_more_autoclear(false);</a>
<a name="ln281"> </a>
<a name="ln282">    ASSERT(!crawl_state.game_is_arena());</a>
<a name="ln283"> </a>
<a name="ln284">    auto delay = current_delay();</a>
<a name="ln285"> </a>
<a name="ln286">    // At the very least we can remove any queued delays, right</a>
<a name="ln287">    // now there is no problem with doing this... note that</a>
<a name="ln288">    // any queuing here can only happen from a single command,</a>
<a name="ln289">    // as the effect of a delay doesn't normally allow interaction</a>
<a name="ln290">    // until it is done... it merely chains up individual actions</a>
<a name="ln291">    // into a single action.  -- bwr</a>
<a name="ln292">    // Butcher delays do this on their own, in order to determine the old</a>
<a name="ln293">    // list of delays before clearing it.</a>
<a name="ln294">    if (!delay-&gt;is_butcher())</a>
<a name="ln295">        _clear_pending_delays();</a>
<a name="ln296"> </a>
<a name="ln297">    if ((!delay-&gt;is_stair_travel() || stop_stair_travel)</a>
<a name="ln298">        &amp;&amp; delay-&gt;try_interrupt())</a>
<a name="ln299">    {</a>
<a name="ln300">        _pop_delay();</a>
<a name="ln301">    }</a>
<a name="ln302">}</a>
<a name="ln303"> </a>
<a name="ln304">bool you_are_delayed()</a>
<a name="ln305">{</a>
<a name="ln306">    return !you.delay_queue.empty();</a>
<a name="ln307">}</a>
<a name="ln308"> </a>
<a name="ln309">shared_ptr&lt;Delay&gt; current_delay()</a>
<a name="ln310">{</a>
<a name="ln311">    return you_are_delayed() ? you.delay_queue.front()</a>
<a name="ln312">                             : nullptr;</a>
<a name="ln313">}</a>
<a name="ln314"> </a>
<a name="ln315">bool is_being_drained(const item_def &amp;item)</a>
<a name="ln316">{</a>
<a name="ln317">    if (!you_are_delayed())</a>
<a name="ln318">        return false;</a>
<a name="ln319"> </a>
<a name="ln320">    return current_delay()-&gt;is_being_used(&amp;item, OPER_EAT);</a>
<a name="ln321">}</a>
<a name="ln322"> </a>
<a name="ln323">bool is_being_butchered(const item_def &amp;item, bool just_first)</a>
<a name="ln324">{</a>
<a name="ln325">    for (const auto delay : you.delay_queue)</a>
<a name="ln326">    {</a>
<a name="ln327">        if (delay-&gt;is_being_used(&amp;item, OPER_BUTCHER))</a>
<a name="ln328">            return true;</a>
<a name="ln329"> </a>
<a name="ln330">        if (just_first)</a>
<a name="ln331">            break;</a>
<a name="ln332">    }</a>
<a name="ln333"> </a>
<a name="ln334">    return false;</a>
<a name="ln335">}</a>
<a name="ln336"> </a>
<a name="ln337">bool is_vampire_feeding()</a>
<a name="ln338">{</a>
<a name="ln339">    if (!you_are_delayed())</a>
<a name="ln340">        return false;</a>
<a name="ln341"> </a>
<a name="ln342">    return current_delay()-&gt;is_being_used(nullptr, OPER_EAT);</a>
<a name="ln343">}</a>
<a name="ln344"> </a>
<a name="ln345">bool player_stair_delay()</a>
<a name="ln346">{</a>
<a name="ln347">    auto delay = current_delay();</a>
<a name="ln348">    return delay &amp;&amp; delay-&gt;is_stairs();</a>
<a name="ln349">}</a>
<a name="ln350"> </a>
<a name="ln351">/**</a>
<a name="ln352"> * Is the player currently in the middle of memorising a spell?</a>
<a name="ln353"> *</a>
<a name="ln354"> * @param spell     A specific spell, or -1 to check if we're memorising any</a>
<a name="ln355"> *                  spell at all.</a>
<a name="ln356"> * @return          Whether the player is currently memorising the given type</a>
<a name="ln357"> *                  of spell.</a>
<a name="ln358"> */</a>
<a name="ln359">bool already_learning_spell(int spell)</a>
<a name="ln360">{</a>
<a name="ln361">    for (const auto delay : you.delay_queue)</a>
<a name="ln362">    {</a>
<a name="ln363">        auto mem = dynamic_cast&lt;MemoriseDelay*&gt;(delay.get());</a>
<a name="ln364">        if (!mem)</a>
<a name="ln365">            continue;</a>
<a name="ln366"> </a>
<a name="ln367">        if (spell == -1 || mem-&gt;spell == spell)</a>
<a name="ln368">            return true;</a>
<a name="ln369">    }</a>
<a name="ln370">    return false;</a>
<a name="ln371">}</a>
<a name="ln372"> </a>
<a name="ln373">static command_type _get_running_command()</a>
<a name="ln374">{</a>
<a name="ln375">    if (Options.travel_key_stop &amp;&amp; kbhit()</a>
<a name="ln376">        || !in_bounds(you.pos() + you.running.pos))</a>
<a name="ln377">    {</a>
<a name="ln378">        stop_running();</a>
<a name="ln379">        return CMD_NO_CMD;</a>
<a name="ln380">    }</a>
<a name="ln381"> </a>
<a name="ln382">    if (is_resting())</a>
<a name="ln383">    {</a>
<a name="ln384">        you.running.rest();</a>
<a name="ln385"> </a>
<a name="ln386">#ifdef USE_TILE</a>
<a name="ln387">        if (Options.rest_delay &gt;= 0 &amp;&amp; tiles.need_redraw())</a>
<a name="ln388">            tiles.redraw();</a>
<a name="ln389">#endif</a>
<a name="ln390"> </a>
<a name="ln391">        if (!is_resting() &amp;&amp; you.running.hp == you.hp</a>
<a name="ln392">            &amp;&amp; you.running.mp == you.magic_points)</a>
<a name="ln393">        {</a>
<a name="ln394">            mpr(&quot;Done waiting.&quot;);</a>
<a name="ln395">        }</a>
<a name="ln396"> </a>
<a name="ln397">        if (Options.rest_delay &gt; 0)</a>
<a name="ln398">            delay(Options.rest_delay);</a>
<a name="ln399"> </a>
<a name="ln400">        return CMD_WAIT;</a>
<a name="ln401">    }</a>
<a name="ln402">    else if (you.running.is_explore() &amp;&amp; Options.explore_delay &gt; -1)</a>
<a name="ln403">        delay(Options.explore_delay);</a>
<a name="ln404">    else if (Options.travel_delay &gt; 0)</a>
<a name="ln405">        delay(Options.travel_delay);</a>
<a name="ln406"> </a>
<a name="ln407">    return direction_to_command(you.running.pos.x, you.running.pos.y);</a>
<a name="ln408">}</a>
<a name="ln409"> </a>
<a name="ln410">/**</a>
<a name="ln411"> * Can the player currently read the given scroll?</a>
<a name="ln412"> *</a>
<a name="ln413"> * Prints corresponding messages if the answer is false.</a>
<a name="ln414"> *</a>
<a name="ln415"> * @param inv_slot      The scroll in question.</a>
<a name="ln416"> * @return              false if the player is confused, berserk, silenced,</a>
<a name="ln417"> *                      etc; true otherwise.</a>
<a name="ln418"> */</a>
<a name="ln419">static bool _can_read_scroll(const item_def&amp; scroll)</a>
<a name="ln420">{</a>
<a name="ln421">    // prints its own messages</a>
<a name="ln422">    if (!player_can_read())</a>
<a name="ln423">        return false;</a>
<a name="ln424"> </a>
<a name="ln425">    const string illiteracy_reason = cannot_read_item_reason(scroll);</a>
<a name="ln426">    if (illiteracy_reason.empty())</a>
<a name="ln427">        return true;</a>
<a name="ln428"> </a>
<a name="ln429">    mpr(illiteracy_reason);</a>
<a name="ln430">    return false;</a>
<a name="ln431">}</a>
<a name="ln432"> </a>
<a name="ln433">// Xom is amused by a potential food source going to waste, and is</a>
<a name="ln434">// more amused the hungrier you are.</a>
<a name="ln435">static void _xom_check_corpse_waste()</a>
<a name="ln436">{</a>
<a name="ln437">    const int food_need = max(HUNGER_SATIATED - you.hunger, 0);</a>
<a name="ln438">    xom_is_stimulated(50 + (151 * food_need / 6000));</a>
<a name="ln439">}</a>
<a name="ln440"> </a>
<a name="ln441">static bool _auto_eat()</a>
<a name="ln442">{</a>
<a name="ln443">    return Options.auto_eat_chunks</a>
<a name="ln444">           &amp;&amp; Options.autopickup_on &gt; 0</a>
<a name="ln445">           &amp;&amp; (player_likes_chunks(true)</a>
<a name="ln446">               || !you.gourmand()</a>
<a name="ln447">               || you.duration[DUR_GOURMAND] &gt;= GOURMAND_MAX / 4</a>
<a name="ln448">               || you.hunger_state &lt; HS_SATIATED);</a>
<a name="ln449">}</a>
<a name="ln450"> </a>
<a name="ln451">void clear_macro_process_key_delay()</a>
<a name="ln452">{</a>
<a name="ln453">    if (dynamic_cast&lt;MacroProcessKeyDelay*&gt;(current_delay().get()))</a>
<a name="ln454">        _pop_delay();</a>
<a name="ln455">}</a>
<a name="ln456"> </a>
<a name="ln457">void ArmourOnDelay::start()</a>
<a name="ln458">{</a>
<a name="ln459">    mprf(MSGCH_MULTITURN_ACTION, &quot;You start putting on your armour.&quot;);</a>
<a name="ln460">}</a>
<a name="ln461"> </a>
<a name="ln462">void ArmourOffDelay::start()</a>
<a name="ln463">{</a>
<a name="ln464">    mprf(MSGCH_MULTITURN_ACTION, &quot;You start removing your armour.&quot;);</a>
<a name="ln465">}</a>
<a name="ln466"> </a>
<a name="ln467">void MemoriseDelay::start()</a>
<a name="ln468">{</a>
<a name="ln469">    if (vehumet_is_offering(spell))</a>
<a name="ln470">    {</a>
<a name="ln471">        string message = make_stringf(&quot; grants you knowledge of %s.&quot;,</a>
<a name="ln472">            spell_title(spell));</a>
<a name="ln473">        simple_god_message(message.c_str());</a>
<a name="ln474">    }</a>
<a name="ln475">    mprf(MSGCH_MULTITURN_ACTION, &quot;You start memorising the spell.&quot;);</a>
<a name="ln476">}</a>
<a name="ln477"> </a>
<a name="ln478">void PasswallDelay::start()</a>
<a name="ln479">{</a>
<a name="ln480">    mprf(MSGCH_MULTITURN_ACTION, &quot;You begin to meditate on the wall.&quot;);</a>
<a name="ln481">}</a>
<a name="ln482"> </a>
<a name="ln483">void ShaftSelfDelay::start()</a>
<a name="ln484">{</a>
<a name="ln485">    mprf(MSGCH_MULTITURN_ACTION, &quot;You begin to dig a shaft.&quot;);</a>
<a name="ln486">}</a>
<a name="ln487"> </a>
<a name="ln488">void BlurryScrollDelay::start()</a>
<a name="ln489">{</a>
<a name="ln490">    mprf(MSGCH_MULTITURN_ACTION, &quot;You begin reading the scroll.&quot;);</a>
<a name="ln491">}</a>
<a name="ln492"> </a>
<a name="ln493">void ExsanguinateDelay::start()</a>
<a name="ln494">{</a>
<a name="ln495">    mprf(MSGCH_MULTITURN_ACTION, &quot;You begin bloodletting.&quot;);</a>
<a name="ln496">}</a>
<a name="ln497"> </a>
<a name="ln498">void RevivifyDelay::start()</a>
<a name="ln499">{</a>
<a name="ln500">    mprf(MSGCH_MULTITURN_ACTION, &quot;You begin the revivification ritual.&quot;);</a>
<a name="ln501">}</a>
<a name="ln502"> </a>
<a name="ln503">command_type RunDelay::move_cmd() const</a>
<a name="ln504">{</a>
<a name="ln505">    return _get_running_command();</a>
<a name="ln506">}</a>
<a name="ln507"> </a>
<a name="ln508">command_type RestDelay::move_cmd() const</a>
<a name="ln509">{</a>
<a name="ln510">    return _get_running_command();</a>
<a name="ln511">}</a>
<a name="ln512"> </a>
<a name="ln513">command_type TravelDelay::move_cmd() const</a>
<a name="ln514">{</a>
<a name="ln515">    return travel();</a>
<a name="ln516">}</a>
<a name="ln517"> </a>
<a name="ln518">void BaseRunDelay::handle()</a>
<a name="ln519">{</a>
<a name="ln520">    if (!started)</a>
<a name="ln521">        started = true;</a>
<a name="ln522">    // Handle inconsistencies between the delay queue and you.running.</a>
<a name="ln523">    // We don't want to send the game into a deadlock.</a>
<a name="ln524">    if (!you.running)</a>
<a name="ln525">    {</a>
<a name="ln526">        update_turn_count();</a>
<a name="ln527">        _pop_delay();</a>
<a name="ln528">        return;</a>
<a name="ln529">    }</a>
<a name="ln530"> </a>
<a name="ln531">    if (you.turn_is_over)</a>
<a name="ln532">        return;</a>
<a name="ln533"> </a>
<a name="ln534">    command_type cmd = CMD_NO_CMD;</a>
<a name="ln535"> </a>
<a name="ln536">    if ((want_move() &amp;&amp; you.confused()) || !i_feel_safe(true, want_move()))</a>
<a name="ln537">        stop_running();</a>
<a name="ln538">    else</a>
<a name="ln539">    {</a>
<a name="ln540">        if (want_autoeat() &amp;&amp; _auto_eat())</a>
<a name="ln541">        {</a>
<a name="ln542">            const interrupt_block block_interrupts;</a>
<a name="ln543">            if (prompt_eat_chunks(true) == 1)</a>
<a name="ln544">                return;</a>
<a name="ln545">        }</a>
<a name="ln546"> </a>
<a name="ln547">        cmd = move_cmd();</a>
<a name="ln548">    }</a>
<a name="ln549"> </a>
<a name="ln550">    if (cmd != CMD_NO_CMD)</a>
<a name="ln551">    {</a>
<a name="ln552">        if (want_clear_messages())</a>
<a name="ln553">            clear_messages();</a>
<a name="ln554">        process_command(cmd);</a>
<a name="ln555">    }</a>
<a name="ln556"> </a>
<a name="ln557">    if (!you.turn_is_over)</a>
<a name="ln558">        you.time_taken = 0;</a>
<a name="ln559"> </a>
<a name="ln560">    // If you.running has gone to zero, and the run delay was not</a>
<a name="ln561">    // removed, remove it now. This is needed to clean up after</a>
<a name="ln562">    // find_travel_pos() function in travel.cc.</a>
<a name="ln563">    if (!you.running</a>
<a name="ln564">        &amp;&amp; !you.delay_queue.empty()</a>
<a name="ln565">        &amp;&amp; you.delay_queue.front()-&gt;is_run())</a>
<a name="ln566">    {</a>
<a name="ln567">        update_turn_count();</a>
<a name="ln568">        _pop_delay();</a>
<a name="ln569">    }</a>
<a name="ln570">}</a>
<a name="ln571"> </a>
<a name="ln572">void MacroDelay::handle()</a>
<a name="ln573">{</a>
<a name="ln574">    if (!started)</a>
<a name="ln575">        started = true;</a>
<a name="ln576">    if (!duration)</a>
<a name="ln577">    {</a>
<a name="ln578">        dprf(&quot;Expiring macro delay on turn: %d&quot;, you.num_turns);</a>
<a name="ln579">        stop_delay();</a>
<a name="ln580">    }</a>
<a name="ln581">    else</a>
<a name="ln582">        run_macro();</a>
<a name="ln583"> </a>
<a name="ln584">    // Macros may not use up turns, but unless we zero time_taken,</a>
<a name="ln585">    // main.cc will call world_reacts and increase turn count.</a>
<a name="ln586">    if (!you.turn_is_over &amp;&amp; you.time_taken)</a>
<a name="ln587">        you.time_taken = 0;</a>
<a name="ln588">}</a>
<a name="ln589"> </a>
<a name="ln590">static bool _check_corpse_gone(item_def&amp; item, const char* action)</a>
<a name="ln591">{</a>
<a name="ln592">    // A monster may have raised the corpse you're chopping up! -- bwr</a>
<a name="ln593">    // Note that a monster could have raised the corpse and another</a>
<a name="ln594">    // monster could die and create a corpse with the same ID number...</a>
<a name="ln595">    // However, it would not be at the player's square like the</a>
<a name="ln596">    // original and that's why we do it this way.</a>
<a name="ln597">    if (!item.defined()</a>
<a name="ln598">        || item.base_type != OBJ_CORPSES</a>
<a name="ln599">        || item.pos != you.pos())</a>
<a name="ln600">    {</a>
<a name="ln601">        // There being no item at all could have happened for several</a>
<a name="ln602">        // reasons, so don't bother to give a message.</a>
<a name="ln603">        return true;</a>
<a name="ln604">    }</a>
<a name="ln605">    else if (item.is_type(OBJ_CORPSES, CORPSE_SKELETON))</a>
<a name="ln606">    {</a>
<a name="ln607">        mprf(&quot;The corpse has rotted away into a skeleton before &quot;</a>
<a name="ln608">             &quot;you could %s!&quot;, action);</a>
<a name="ln609">        _xom_check_corpse_waste();</a>
<a name="ln610">        return true;</a>
<a name="ln611">    }</a>
<a name="ln612"> </a>
<a name="ln613">    return false;</a>
<a name="ln614">}</a>
<a name="ln615"> </a>
<a name="ln616">bool ButcherDelay::invalidated()</a>
<a name="ln617">{</a>
<a name="ln618">    return _check_corpse_gone(corpse, &quot;butcher it&quot;);</a>
<a name="ln619">}</a>
<a name="ln620"> </a>
<a name="ln621">bool MultidropDelay::invalidated()</a>
<a name="ln622">{</a>
<a name="ln623">    // Throw away invalid items. XXX: what are they?</a>
<a name="ln624">    while (!items.empty()</a>
<a name="ln625">           // Don't look for gold in inventory</a>
<a name="ln626">           &amp;&amp; items[0].slot != PROMPT_GOT_SPECIAL</a>
<a name="ln627">           &amp;&amp; !you.inv[items[0].slot].defined())</a>
<a name="ln628">    {</a>
<a name="ln629">        items.erase(items.begin());</a>
<a name="ln630">    }</a>
<a name="ln631"> </a>
<a name="ln632">    if (items.empty())</a>
<a name="ln633">    {</a>
<a name="ln634">        // Ran out of things to drop.</a>
<a name="ln635">        you.turn_is_over = false;</a>
<a name="ln636">        you.time_taken = 0;</a>
<a name="ln637">        return true;</a>
<a name="ln638">    }</a>
<a name="ln639">    return false;</a>
<a name="ln640">}</a>
<a name="ln641"> </a>
<a name="ln642">bool BlurryScrollDelay::invalidated()</a>
<a name="ln643">{</a>
<a name="ln644">    if (!_can_read_scroll(scroll))</a>
<a name="ln645">    {</a>
<a name="ln646">        you.time_taken = 0;</a>
<a name="ln647">        return true;</a>
<a name="ln648">    }</a>
<a name="ln649">    return false;</a>
<a name="ln650">}</a>
<a name="ln651"> </a>
<a name="ln652">void MultidropDelay::tick()</a>
<a name="ln653">{</a>
<a name="ln654">    if (!drop_item(items[0].slot, items[0].quantity))</a>
<a name="ln655">    {</a>
<a name="ln656">        you.turn_is_over = false;</a>
<a name="ln657">        you.time_taken = 0;</a>
<a name="ln658">    }</a>
<a name="ln659">    items.erase(items.begin());</a>
<a name="ln660">}</a>
<a name="ln661"> </a>
<a name="ln662">void JewelleryOnDelay::tick()</a>
<a name="ln663">{</a>
<a name="ln664">    // This is a 1-turn delay where the time cost is handled</a>
<a name="ln665">    // in finish().</a>
<a name="ln666">    // FIXME: get rid of this hack!</a>
<a name="ln667">    you.time_taken = 0;</a>
<a name="ln668">}</a>
<a name="ln669"> </a>
<a name="ln670">void DropItemDelay::tick()</a>
<a name="ln671">{</a>
<a name="ln672">    // This is a 1-turn delay where the time cost is handled</a>
<a name="ln673">    // in finish().</a>
<a name="ln674">    // FIXME: get rid of this hack!</a>
<a name="ln675">    you.time_taken = 0;</a>
<a name="ln676">}</a>
<a name="ln677"> </a>
<a name="ln678">void Delay::handle()</a>
<a name="ln679">{</a>
<a name="ln680">    if (!started)</a>
<a name="ln681">    {</a>
<a name="ln682">        started = true;</a>
<a name="ln683">        start();</a>
<a name="ln684">    }</a>
<a name="ln685"> </a>
<a name="ln686">    // First check cases where delay may no longer be valid:</a>
<a name="ln687">    // XXX: need to handle PasswallDelay when monster digs -- bwr</a>
<a name="ln688">    if (invalidated())</a>
<a name="ln689">    {</a>
<a name="ln690">        _pop_delay();</a>
<a name="ln691">        return;</a>
<a name="ln692">    }</a>
<a name="ln693"> </a>
<a name="ln694">    // Actually handle delay:</a>
<a name="ln695">    if (duration &gt; 0)</a>
<a name="ln696">    {</a>
<a name="ln697">        dprf(&quot;Delay type: %s, duration: %d&quot;, name(), duration);</a>
<a name="ln698">        --duration;</a>
<a name="ln699">        tick();</a>
<a name="ln700">    }</a>
<a name="ln701">    else</a>
<a name="ln702">    {</a>
<a name="ln703">        finish();</a>
<a name="ln704">        you.wield_change = true;</a>
<a name="ln705">        _pop_delay();</a>
<a name="ln706">        print_stats();  // force redraw of the stats</a>
<a name="ln707">#ifdef USE_TILE</a>
<a name="ln708">        tiles.update_tabs();</a>
<a name="ln709">#endif</a>
<a name="ln710">        if (!you.turn_is_over)</a>
<a name="ln711">            you.time_taken = 0;</a>
<a name="ln712">    }</a>
<a name="ln713">}</a>
<a name="ln714"> </a>
<a name="ln715">void handle_delay()</a>
<a name="ln716">{</a>
<a name="ln717">    if (!you_are_delayed())</a>
<a name="ln718">        return;</a>
<a name="ln719"> </a>
<a name="ln720">    shared_ptr&lt;Delay&gt; delay = current_delay();</a>
<a name="ln721">    delay-&gt;handle();</a>
<a name="ln722">}</a>
<a name="ln723"> </a>
<a name="ln724">void JewelleryOnDelay::finish()</a>
<a name="ln725">{</a>
<a name="ln726">    // Recheck -Tele here, since our condition may have changed since starting</a>
<a name="ln727">    // the amulet swap process.</a>
<a name="ln728">    // Just breaking here is okay because swapping jewellery is a one-turn</a>
<a name="ln729">    // action, so conceptually there is nothing to interrupt - in other words,</a>
<a name="ln730">    // this is equivalent to if the user took off the previous amulet and was</a>
<a name="ln731">    // affected by tele other before putting the -Tele amulet on as a separate</a>
<a name="ln732">    // action on the next turn.</a>
<a name="ln733">    // XXX: duplicates a check in invent.cc:check_warning_inscriptions()</a>
<a name="ln734">    if (!crawl_state.disables[DIS_CONFIRMATIONS]</a>
<a name="ln735">        &amp;&amp; needs_notele_warning(jewellery, OPER_PUTON)</a>
<a name="ln736">        &amp;&amp; item_ident(jewellery, ISFLAG_KNOW_TYPE))</a>
<a name="ln737">    {</a>
<a name="ln738">        string prompt = &quot;Really put on &quot;;</a>
<a name="ln739">        prompt += jewellery.name(DESC_INVENTORY);</a>
<a name="ln740">        prompt += &quot; while about to teleport?&quot;;</a>
<a name="ln741">        if (!yesno(prompt.c_str(), false, 'n'))</a>
<a name="ln742">            return;</a>
<a name="ln743">    }</a>
<a name="ln744"> </a>
<a name="ln745">#ifdef USE_SOUND</a>
<a name="ln746">    parse_sound(WEAR_JEWELLERY_SOUND);</a>
<a name="ln747">#endif</a>
<a name="ln748">    puton_ring(jewellery, false, false);</a>
<a name="ln749">}</a>
<a name="ln750"> </a>
<a name="ln751">void ArmourOnDelay::finish()</a>
<a name="ln752">{</a>
<a name="ln753">    const unsigned int old_talents = your_talents(false).size();</a>
<a name="ln754"> </a>
<a name="ln755">    set_ident_flags(armour, ISFLAG_IDENT_MASK);</a>
<a name="ln756">    if (is_artefact(armour))</a>
<a name="ln757">        armour.flags |= ISFLAG_NOTED_ID;</a>
<a name="ln758"> </a>
<a name="ln759">    const equipment_type eq_slot = get_armour_slot(armour);</a>
<a name="ln760"> </a>
<a name="ln761">#ifdef USE_SOUND</a>
<a name="ln762">    parse_sound(EQUIP_ARMOUR_SOUND);</a>
<a name="ln763">#endif</a>
<a name="ln764">    mprf(&quot;You finish putting on %s.&quot;, armour.name(DESC_YOUR).c_str());</a>
<a name="ln765"> </a>
<a name="ln766">    if (eq_slot == EQ_BODY_ARMOUR)</a>
<a name="ln767">    {</a>
<a name="ln768">        if (you.duration[DUR_ICY_ARMOUR] != 0</a>
<a name="ln769">            &amp;&amp; !is_effectively_light_armour(&amp;armour))</a>
<a name="ln770">        {</a>
<a name="ln771">            remove_ice_armour();</a>
<a name="ln772">        }</a>
<a name="ln773">    }</a>
<a name="ln774"> </a>
<a name="ln775">    equip_item(eq_slot, armour.link);</a>
<a name="ln776"> </a>
<a name="ln777">    check_item_hint(armour, old_talents);</a>
<a name="ln778">}</a>
<a name="ln779"> </a>
<a name="ln780">bool ArmourOffDelay::invalidated()</a>
<a name="ln781">{</a>
<a name="ln782">    return !armour.defined();</a>
<a name="ln783">}</a>
<a name="ln784"> </a>
<a name="ln785">void ArmourOffDelay::finish()</a>
<a name="ln786">{</a>
<a name="ln787">    const equipment_type slot = get_armour_slot(armour);</a>
<a name="ln788">    ASSERT(you.equip[slot] == armour.link);</a>
<a name="ln789"> </a>
<a name="ln790">#ifdef USE_SOUND</a>
<a name="ln791">    parse_sound(DEQUIP_ARMOUR_SOUND);</a>
<a name="ln792">#endif</a>
<a name="ln793">    mprf(&quot;You finish taking off %s.&quot;, armour.name(DESC_YOUR).c_str());</a>
<a name="ln794">    unequip_item(slot);</a>
<a name="ln795">}</a>
<a name="ln796"> </a>
<a name="ln797">void MemoriseDelay::finish()</a>
<a name="ln798">{</a>
<a name="ln799">#ifdef USE_SOUND</a>
<a name="ln800">    parse_sound(MEMORISE_SPELL_SOUND);</a>
<a name="ln801">#endif</a>
<a name="ln802">    mpr(&quot;You finish memorising.&quot;);</a>
<a name="ln803">    add_spell_to_memory(spell);</a>
<a name="ln804">    vehumet_accept_gift(spell);</a>
<a name="ln805">}</a>
<a name="ln806"> </a>
<a name="ln807">void PasswallDelay::finish()</a>
<a name="ln808">{</a>
<a name="ln809">    mpr(&quot;You finish merging with the rock.&quot;);</a>
<a name="ln810">    // included in default force_more_message</a>
<a name="ln811"> </a>
<a name="ln812">    if (dest.x == 0 || dest.y == 0)</a>
<a name="ln813">        return;</a>
<a name="ln814"> </a>
<a name="ln815">    switch (grd(dest))</a>
<a name="ln816">    {</a>
<a name="ln817">    default:</a>
<a name="ln818">        if (!you.is_habitable(dest))</a>
<a name="ln819">        {</a>
<a name="ln820">            mpr(&quot;...yet there is something new on the other side. &quot;</a>
<a name="ln821">                &quot;You quickly turn back.&quot;);</a>
<a name="ln822">            redraw_screen();</a>
<a name="ln823">            return;</a>
<a name="ln824">        }</a>
<a name="ln825">        break;</a>
<a name="ln826"> </a>
<a name="ln827">    case DNGN_CLOSED_DOOR:      // open the door</a>
<a name="ln828">    case DNGN_CLOSED_CLEAR_DOOR:</a>
<a name="ln829">    case DNGN_RUNED_DOOR:</a>
<a name="ln830">    case DNGN_RUNED_CLEAR_DOOR:</a>
<a name="ln831">        // Once opened, former runed doors become normal doors.</a>
<a name="ln832">        dgn_open_door(dest);</a>
<a name="ln833">        break;</a>
<a name="ln834">    }</a>
<a name="ln835"> </a>
<a name="ln836">    // Move any monsters out of the way.</a>
<a name="ln837">    if (monster* m = monster_at(dest))</a>
<a name="ln838">    {</a>
<a name="ln839">        // One square, a few squares, anywhere...</a>
<a name="ln840">        if (!m-&gt;shift() &amp;&amp; !monster_blink(m, true))</a>
<a name="ln841">            monster_teleport(m, true, true);</a>
<a name="ln842">        // Might still fail.</a>
<a name="ln843">        if (monster_at(dest))</a>
<a name="ln844">        {</a>
<a name="ln845">            mpr(&quot;...and sense your way blocked. You quickly turn back.&quot;);</a>
<a name="ln846">            redraw_screen();</a>
<a name="ln847">            return;</a>
<a name="ln848">        }</a>
<a name="ln849"> </a>
<a name="ln850">        move_player_to_grid(dest, false);</a>
<a name="ln851"> </a>
<a name="ln852">        // Wake the monster if it's asleep.</a>
<a name="ln853">        if (m)</a>
<a name="ln854">            behaviour_event(m, ME_ALERT, &amp;you);</a>
<a name="ln855">    }</a>
<a name="ln856">    else</a>
<a name="ln857">        move_player_to_grid(dest, false);</a>
<a name="ln858"> </a>
<a name="ln859">    // the last phase of the delay is a fake (0-time) turn, so world_reacts</a>
<a name="ln860">    // and player_reacts aren't triggered. Need to do a tiny bit of cleanup.</a>
<a name="ln861">    // This isn't very elegant, and perhaps a version of player_reacts that is</a>
<a name="ln862">    // triggered by changing location would be better (per Pleasingfungus),</a>
<a name="ln863">    // but player_reacts is very sensitive to order and can't be easily</a>
<a name="ln864">    // refactored in this way.</a>
<a name="ln865">    you.update_beholders();</a>
<a name="ln866">    you.update_fearmongers();</a>
<a name="ln867">}</a>
<a name="ln868"> </a>
<a name="ln869">void ShaftSelfDelay::finish()</a>
<a name="ln870">{</a>
<a name="ln871">    you.do_shaft_ability();</a>
<a name="ln872">}</a>
<a name="ln873"> </a>
<a name="ln874">void BlurryScrollDelay::finish()</a>
<a name="ln875">{</a>
<a name="ln876">    // Make sure the scroll still exists, the player isn't confused, etc</a>
<a name="ln877">    if (_can_read_scroll(scroll))</a>
<a name="ln878">    {</a>
<a name="ln879">        read_scroll(scroll);</a>
<a name="ln880">        // we are now probably out of sync with regular world_reacts timing, so</a>
<a name="ln881">        // trigger any fineffs that might have been caused by reading this</a>
<a name="ln882">        // scroll, e.g. torment vs. TRJ. Otherwise they'd have to wait until</a>
<a name="ln883">        // the next world_reacts.</a>
<a name="ln884">        // TODO: is there a more general condition that this can be triggered</a>
<a name="ln885">        // under? it might impact other obscure cases, e.g. passwalling with</a>
<a name="ln886">        // spiny.</a>
<a name="ln887">        fire_final_effects();</a>
<a name="ln888">    }</a>
<a name="ln889">}</a>
<a name="ln890"> </a>
<a name="ln891">static void _finish_butcher_delay(item_def&amp; corpse)</a>
<a name="ln892">{</a>
<a name="ln893">    // We know the item is valid and a real corpse, because invalidated()</a>
<a name="ln894">    // checked for that.</a>
<a name="ln895">    finish_butchering(corpse);</a>
<a name="ln896">    // Don't waste time picking up chunks if you're already</a>
<a name="ln897">    // starving. (jpeg)</a>
<a name="ln898">    if (you.hunger_state &gt; HS_STARVING</a>
<a name="ln899">        // Only pick up chunks if this is the last delay...</a>
<a name="ln900">        &amp;&amp; (you.delay_queue.size() == 1</a>
<a name="ln901">        // ...Or, equivalently, if it's the last butcher one.</a>
<a name="ln902">            || !you.delay_queue[1]-&gt;is_butcher()))</a>
<a name="ln903">    {</a>
<a name="ln904">        request_autopickup();</a>
<a name="ln905">    }</a>
<a name="ln906">    you.turn_is_over = true;</a>
<a name="ln907">}</a>
<a name="ln908"> </a>
<a name="ln909">void ButcherDelay::finish()</a>
<a name="ln910">{</a>
<a name="ln911">    _finish_butcher_delay(corpse);</a>
<a name="ln912">}</a>
<a name="ln913"> </a>
<a name="ln914">void DropItemDelay::finish()</a>
<a name="ln915">{</a>
<a name="ln916">    // We're here if dropping the item required some action to be done</a>
<a name="ln917">    // first, like removing armour. At this point, it should be droppable</a>
<a name="ln918">    // immediately.</a>
<a name="ln919"> </a>
<a name="ln920">    // Make sure item still exists.</a>
<a name="ln921">    if (!item.defined())</a>
<a name="ln922">        return;</a>
<a name="ln923"> </a>
<a name="ln924">    if (!drop_item(item.link, 1))</a>
<a name="ln925">    {</a>
<a name="ln926">        you.turn_is_over = false;</a>
<a name="ln927">        you.time_taken = 0;</a>
<a name="ln928">    }</a>
<a name="ln929">}</a>
<a name="ln930"> </a>
<a name="ln931">void AscendingStairsDelay::finish()</a>
<a name="ln932">{</a>
<a name="ln933">    up_stairs();</a>
<a name="ln934">}</a>
<a name="ln935"> </a>
<a name="ln936">void DescendingStairsDelay::finish()</a>
<a name="ln937">{</a>
<a name="ln938">    down_stairs();</a>
<a name="ln939">}</a>
<a name="ln940"> </a>
<a name="ln941">void ExsanguinateDelay::finish()</a>
<a name="ln942">{</a>
<a name="ln943">    blood_spray(you.pos(), MONS_PLAYER, 10);</a>
<a name="ln944">    you.vampire_alive = false;</a>
<a name="ln945">    you.redraw_status_lights = true;</a>
<a name="ln946">    calc_hp(true);</a>
<a name="ln947">    mpr(&quot;Now bloodless.&quot;);</a>
<a name="ln948">    vampire_update_transformations();</a>
<a name="ln949">}</a>
<a name="ln950"> </a>
<a name="ln951">void RevivifyDelay::finish()</a>
<a name="ln952">{</a>
<a name="ln953">    you.vampire_alive = true;</a>
<a name="ln954">    you.redraw_status_lights = true;</a>
<a name="ln955">    mpr(&quot;Now alive.&quot;);</a>
<a name="ln956">    temp_mutate(MUT_FRAIL, &quot;vampire revification&quot;);</a>
<a name="ln957">    vampire_update_transformations();</a>
<a name="ln958">}</a>
<a name="ln959"> </a>
<a name="ln960">void run_macro(const char *macroname)</a>
<a name="ln961">{</a>
<a name="ln962">#ifdef CLUA_BINDINGS</a>
<a name="ln963">    if (!clua)</a>
<a name="ln964">    {</a>
<a name="ln965">        mprf(MSGCH_DIAGNOSTICS, &quot;Lua not initialised&quot;);</a>
<a name="ln966">        stop_delay();</a>
<a name="ln967">        return;</a>
<a name="ln968">    }</a>
<a name="ln969"> </a>
<a name="ln970">    shared_ptr&lt;Delay&gt; delay;</a>
<a name="ln971">    if (!macroname)</a>
<a name="ln972">    {</a>
<a name="ln973">        delay = current_delay();</a>
<a name="ln974">        ASSERT(delay-&gt;is_macro());</a>
<a name="ln975">    }</a>
<a name="ln976">    else</a>
<a name="ln977">        delay = start_delay&lt;MacroDelay&gt;();</a>
<a name="ln978"> </a>
<a name="ln979">    // If callbooleanfn returns false, that means the macro either exited</a>
<a name="ln980">    // normally by returning or by calling coroutine.yield(false). Either way,</a>
<a name="ln981">    // decrement the macro duration.</a>
<a name="ln982">    if (!clua.callbooleanfn(false, &quot;c_macro&quot;, &quot;s&quot;, macroname))</a>
<a name="ln983">    {</a>
<a name="ln984">        if (!clua.error.empty())</a>
<a name="ln985">        {</a>
<a name="ln986">            mprf(MSGCH_ERROR, &quot;Lua error: %s&quot;, clua.error.c_str());</a>
<a name="ln987">            stop_delay();</a>
<a name="ln988">        }</a>
<a name="ln989">        else if (delay-&gt;duration &gt; 0)</a>
<a name="ln990">            --delay-&gt;duration;</a>
<a name="ln991">    }</a>
<a name="ln992">#else</a>
<a name="ln993">    UNUSED(macroname);</a>
<a name="ln994">    stop_delay();</a>
<a name="ln995">#endif</a>
<a name="ln996">}</a>
<a name="ln997"> </a>
<a name="ln998">// Returns TRUE if the delay should be interrupted, MAYBE if the user function</a>
<a name="ln999">// had no opinion on the matter, FALSE if the delay should not be interrupted.</a>
<a name="ln1000">static maybe_bool _userdef_interrupt_activity(Delay* delay,</a>
<a name="ln1001">                                              activity_interrupt ai,</a>
<a name="ln1002">                                              const activity_interrupt_data &amp;at)</a>
<a name="ln1003">{</a>
<a name="ln1004">#ifdef CLUA_BINDINGS</a>
<a name="ln1005">    lua_State *ls = clua.state();</a>
<a name="ln1006">    if (!ls || ai == activity_interrupt::force)</a>
<a name="ln1007">        return MB_TRUE;</a>
<a name="ln1008"> </a>
<a name="ln1009">    const char *interrupt_name = _activity_interrupt_name(ai);</a>
<a name="ln1010"> </a>
<a name="ln1011">    bool ran = clua.callfn(&quot;c_interrupt_activity&quot;, &quot;1:ssA&quot;,</a>
<a name="ln1012">                           delay-&gt;name(), interrupt_name, &amp;at);</a>
<a name="ln1013">    if (ran)</a>
<a name="ln1014">    {</a>
<a name="ln1015">        // If the function returned nil, we want to cease processing.</a>
<a name="ln1016">        if (lua_isnil(ls, -1))</a>
<a name="ln1017">        {</a>
<a name="ln1018">            lua_pop(ls, 1);</a>
<a name="ln1019">            return MB_FALSE;</a>
<a name="ln1020">        }</a>
<a name="ln1021"> </a>
<a name="ln1022">        bool stopact = lua_toboolean(ls, -1);</a>
<a name="ln1023">        lua_pop(ls, 1);</a>
<a name="ln1024">        if (stopact)</a>
<a name="ln1025">            return MB_TRUE;</a>
<a name="ln1026">    }</a>
<a name="ln1027"> </a>
<a name="ln1028">    if (delay-&gt;is_macro() &amp;&amp; clua.callbooleanfn(true, &quot;c_interrupt_macro&quot;,</a>
<a name="ln1029">                                                &quot;sA&quot;, interrupt_name, &amp;at))</a>
<a name="ln1030">    {</a>
<a name="ln1031">        return MB_TRUE;</a>
<a name="ln1032">    }</a>
<a name="ln1033">#else</a>
<a name="ln1034">    UNUSED(_activity_interrupt_name);</a>
<a name="ln1035">#endif</a>
<a name="ln1036">    return MB_MAYBE;</a>
<a name="ln1037">}</a>
<a name="ln1038"> </a>
<a name="ln1039">// Returns true if the activity should be interrupted, false otherwise.</a>
<a name="ln1040">static bool _should_stop_activity(Delay* delay,</a>
<a name="ln1041">                                  activity_interrupt ai,</a>
<a name="ln1042">                                  const activity_interrupt_data &amp;at)</a>
<a name="ln1043">{</a>
<a name="ln1044">    switch (_userdef_interrupt_activity(delay, ai, at))</a>
<a name="ln1045">    {</a>
<a name="ln1046">    case MB_TRUE:</a>
<a name="ln1047">        return true;</a>
<a name="ln1048">    case MB_FALSE:</a>
<a name="ln1049">        return false;</a>
<a name="ln1050">    case MB_MAYBE:</a>
<a name="ln1051">        break;</a>
<a name="ln1052">    }</a>
<a name="ln1053"> </a>
<a name="ln1054">    // Don't interrupt player on monster's turn, they might wander off.</a>
<a name="ln1055">    if (you.turn_is_over</a>
<a name="ln1056">        &amp;&amp; (at.context == SC_ALREADY_SEEN || at.context == SC_UNCHARM))</a>
<a name="ln1057">    {</a>
<a name="ln1058">        return false;</a>
<a name="ln1059">    }</a>
<a name="ln1060"> </a>
<a name="ln1061">    // No monster will attack you inside a sanctuary,</a>
<a name="ln1062">    // so presence of monsters won't matter.</a>
<a name="ln1063">    if (ai == activity_interrupt::see_monster &amp;&amp; is_sanctuary(you.pos()))</a>
<a name="ln1064">        return false;</a>
<a name="ln1065"> </a>
<a name="ln1066">    auto curr = current_delay(); // Not necessarily what we were passed.</a>
<a name="ln1067"> </a>
<a name="ln1068">    if ((ai == activity_interrupt::see_monster</a>
<a name="ln1069">         || ai == activity_interrupt::mimic)</a>
<a name="ln1070">        &amp;&amp; player_stair_delay())</a>
<a name="ln1071">    {</a>
<a name="ln1072">        return false;</a>
<a name="ln1073">    }</a>
<a name="ln1074"> </a>
<a name="ln1075">    if (ai == activity_interrupt::full_hp || ai == activity_interrupt::full_mp</a>
<a name="ln1076">        || ai == activity_interrupt::ancestor_hp)</a>
<a name="ln1077">    {</a>
<a name="ln1078">        if ((Options.rest_wait_both &amp;&amp; curr-&gt;is_resting()</a>
<a name="ln1079">             &amp;&amp; !you.is_sufficiently_rested())</a>
<a name="ln1080">            || (Options.rest_wait_ancestor &amp;&amp; curr-&gt;is_resting()</a>
<a name="ln1081">                &amp;&amp; !ancestor_full_hp()))</a>
<a name="ln1082">        {</a>
<a name="ln1083">            return false;</a>
<a name="ln1084">        }</a>
<a name="ln1085">    }</a>
<a name="ln1086"> </a>
<a name="ln1087">    // Don't interrupt feeding or butchering for monsters already in view.</a>
<a name="ln1088">    if (curr-&gt;is_butcher() &amp;&amp; ai == activity_interrupt::see_monster</a>
<a name="ln1089">        &amp;&amp; testbits(at.mons_data-&gt;flags, MF_WAS_IN_VIEW))</a>
<a name="ln1090">    {</a>
<a name="ln1091">        return false;</a>
<a name="ln1092">    }</a>
<a name="ln1093"> </a>
<a name="ln1094">    return ai == activity_interrupt::force</a>
<a name="ln1095">           || Options.activity_interrupts[delay-&gt;name()][static_cast&lt;int&gt;(ai)];</a>
<a name="ln1096">}</a>
<a name="ln1097"> </a>
<a name="ln1098">static string _abyss_monster_creation_message(const monster* mon)</a>
<a name="ln1099">{</a>
<a name="ln1100">    if (mon-&gt;type == MONS_DEATH_COB)</a>
<a name="ln1101">    {</a>
<a name="ln1102">        return coinflip() ? &quot; appears in a burst of microwaves!&quot;</a>
<a name="ln1103">                          : &quot; pops from nullspace!&quot;;</a>
<a name="ln1104">    }</a>
<a name="ln1105"> </a>
<a name="ln1106">    // You may ask: &quot;Why these weights?&quot; So would I!</a>
<a name="ln1107">    const vector&lt;pair&lt;string, int&gt;&gt; messages = {</a>
<a name="ln1108">        { &quot; appears in a shower of translocational energy.&quot;, 17 },</a>
<a name="ln1109">        { &quot; appears in a shower of sparks.&quot;, 34 },</a>
<a name="ln1110">        { &quot; materialises.&quot;, 45 },</a>
<a name="ln1111">        { &quot; emerges from chaos.&quot;, 13 },</a>
<a name="ln1112">        { &quot; emerges from the beyond.&quot;, 26 },</a>
<a name="ln1113">        { make_stringf(&quot; assembles %s!&quot;,</a>
<a name="ln1114">                       mon-&gt;pronoun(PRONOUN_REFLEXIVE).c_str()), 33 },</a>
<a name="ln1115">        { &quot; erupts from nowhere.&quot;, 9 },</a>
<a name="ln1116">        { &quot; bursts from nowhere.&quot;, 18 },</a>
<a name="ln1117">        { &quot; is cast out of space.&quot;, 7 },</a>
<a name="ln1118">        { &quot; is cast out of reality.&quot;, 14 },</a>
<a name="ln1119">        { &quot; coalesces out of pure chaos.&quot;, 5 },</a>
<a name="ln1120">        { &quot; coalesces out of seething chaos.&quot;, 10 },</a>
<a name="ln1121">        { &quot; punctures the fabric of time!&quot;, 2 },</a>
<a name="ln1122">        { &quot; punctures the fabric of the universe.&quot;, 7 },</a>
<a name="ln1123">        { make_stringf(&quot; manifests%s!&quot;,</a>
<a name="ln1124">                       silenced(you.pos()) ? &quot;&quot; : &quot; with a bang&quot;), 3 },</a>
<a name="ln1125"> </a>
<a name="ln1126"> </a>
<a name="ln1127">    };</a>
<a name="ln1128"> </a>
<a name="ln1129">    return *random_choose_weighted(messages);</a>
<a name="ln1130">}</a>
<a name="ln1131"> </a>
<a name="ln1132">static inline bool _monster_warning(activity_interrupt ai,</a>
<a name="ln1133">                                    const activity_interrupt_data &amp;at,</a>
<a name="ln1134">                                    shared_ptr&lt;Delay&gt; delay,</a>
<a name="ln1135">                                    vector&lt;string&gt;* msgs_buf = nullptr)</a>
<a name="ln1136">{</a>
<a name="ln1137">    if (ai == activity_interrupt::sense_monster)</a>
<a name="ln1138">    {</a>
<a name="ln1139">        mprf(MSGCH_WARN, &quot;You sense a monster nearby.&quot;);</a>
<a name="ln1140">        return true;</a>
<a name="ln1141">    }</a>
<a name="ln1142">    if (ai != activity_interrupt::see_monster)</a>
<a name="ln1143">        return false;</a>
<a name="ln1144">    if (delay &amp;&amp; !delay-&gt;is_run() &amp;&amp; !delay-&gt;is_butcher())</a>
<a name="ln1145">        return false;</a>
<a name="ln1146">    if (at.context != SC_NEWLY_SEEN &amp;&amp; !delay)</a>
<a name="ln1147">        return false;</a>
<a name="ln1148"> </a>
<a name="ln1149">    ASSERT(at.apt == ai_payload::monster);</a>
<a name="ln1150">    monster* mon = at.mons_data;</a>
<a name="ln1151">    ASSERT(mon);</a>
<a name="ln1152">    if (!you.can_see(*mon))</a>
<a name="ln1153">        return false;</a>
<a name="ln1154"> </a>
<a name="ln1155">    // Disable message for summons.</a>
<a name="ln1156">    if (mon-&gt;is_summoned() &amp;&amp; !delay)</a>
<a name="ln1157">        return false;</a>
<a name="ln1158"> </a>
<a name="ln1159">    if (at.context == SC_ALREADY_SEEN || at.context == SC_UNCHARM)</a>
<a name="ln1160">    {</a>
<a name="ln1161">        // Only say &quot;comes into view&quot; if the monster wasn't in view</a>
<a name="ln1162">        // during the previous turn.</a>
<a name="ln1163">        if (testbits(mon-&gt;flags, MF_WAS_IN_VIEW) &amp;&amp; delay)</a>
<a name="ln1164">        {</a>
<a name="ln1165">            mprf(MSGCH_WARN, &quot;%s is too close now for your liking.&quot;,</a>
<a name="ln1166">                 mon-&gt;name(DESC_THE).c_str());</a>
<a name="ln1167">        }</a>
<a name="ln1168">    }</a>
<a name="ln1169">    else if (mon-&gt;seen_context == SC_JUST_SEEN)</a>
<a name="ln1170">        return false;</a>
<a name="ln1171">    else</a>
<a name="ln1172">    {</a>
<a name="ln1173">        // XXX: This needs to be here to ensure correct messaging for</a>
<a name="ln1174">        // autoexplore, even though the correct place to process it is</a>
<a name="ln1175">        // seen_monster</a>
<a name="ln1176">        view_monster_equipment(mon);</a>
<a name="ln1177"> </a>
<a name="ln1178">        string text = getMiscString(mon-&gt;name(DESC_DBNAME) + &quot; title&quot;);</a>
<a name="ln1179">        if (text.empty())</a>
<a name="ln1180">            text = mon-&gt;full_name(DESC_A);</a>
<a name="ln1181">        if (mon-&gt;type == MONS_PLAYER_GHOST)</a>
<a name="ln1182">        {</a>
<a name="ln1183">            text += make_stringf(&quot; (%s)&quot;,</a>
<a name="ln1184">                                 short_ghost_description(mon).c_str());</a>
<a name="ln1185">        }</a>
<a name="ln1186"> </a>
<a name="ln1187">        if (at.context == SC_DOOR)</a>
<a name="ln1188">            text += &quot; opens the door.&quot;;</a>
<a name="ln1189">        else if (at.context == SC_GATE)</a>
<a name="ln1190">            text += &quot; opens the gate.&quot;;</a>
<a name="ln1191">        else if (at.context == SC_TELEPORT_IN)</a>
<a name="ln1192">            text += &quot; appears from thin air!&quot;;</a>
<a name="ln1193">        else if (at.context == SC_LEAP_IN)</a>
<a name="ln1194">            text += &quot; leaps into view!&quot;;</a>
<a name="ln1195">        else if (at.context == SC_FISH_SURFACES)</a>
<a name="ln1196">        {</a>
<a name="ln1197">            text += &quot; bursts forth from the &quot;;</a>
<a name="ln1198">            if (mons_primary_habitat(*mon) == HT_LAVA)</a>
<a name="ln1199">                text += &quot;lava&quot;;</a>
<a name="ln1200">            else if (mons_primary_habitat(*mon) == HT_WATER)</a>
<a name="ln1201">                text += &quot;water&quot;;</a>
<a name="ln1202">            else</a>
<a name="ln1203">                text += &quot;realm of bugdom&quot;;</a>
<a name="ln1204">            text += &quot;.&quot;;</a>
<a name="ln1205">        }</a>
<a name="ln1206">        else if (at.context == SC_NONSWIMMER_SURFACES_FROM_DEEP)</a>
<a name="ln1207">            text += &quot; emerges from the water.&quot;;</a>
<a name="ln1208">        else if (at.context == SC_UPSTAIRS)</a>
<a name="ln1209">            text += &quot; comes up the stairs.&quot;;</a>
<a name="ln1210">        else if (at.context == SC_DOWNSTAIRS)</a>
<a name="ln1211">            text += &quot; comes down the stairs.&quot;;</a>
<a name="ln1212">        else if (at.context == SC_ARCH)</a>
<a name="ln1213">            text += &quot; comes through the gate.&quot;;</a>
<a name="ln1214">        else if (at.context == SC_ABYSS)</a>
<a name="ln1215">            text += _abyss_monster_creation_message(mon);</a>
<a name="ln1216">        else if (at.context == SC_THROWN_IN)</a>
<a name="ln1217">            text += &quot; is thrown into view!&quot;;</a>
<a name="ln1218">        else</a>
<a name="ln1219">            text += &quot; comes into view.&quot;;</a>
<a name="ln1220"> </a>
<a name="ln1221">        bool zin_id = false;</a>
<a name="ln1222">        string god_warning;</a>
<a name="ln1223"> </a>
<a name="ln1224">        if (have_passive(passive_t::warn_shapeshifter)</a>
<a name="ln1225">            &amp;&amp; mon-&gt;is_shapeshifter()</a>
<a name="ln1226">            &amp;&amp; !(mon-&gt;flags &amp; MF_KNOWN_SHIFTER))</a>
<a name="ln1227">        {</a>
<a name="ln1228">            zin_id = true;</a>
<a name="ln1229">            mon-&gt;props[&quot;zin_id&quot;] = true;</a>
<a name="ln1230">            discover_shifter(*mon);</a>
<a name="ln1231">            god_warning = uppercase_first(god_name(you.religion))</a>
<a name="ln1232">                          + &quot; warns you: &quot;</a>
<a name="ln1233">                          + uppercase_first(mon-&gt;pronoun(PRONOUN_SUBJECTIVE))</a>
<a name="ln1234">                          + &quot; &quot;</a>
<a name="ln1235">                          + conjugate_verb(&quot;are&quot;, mon-&gt;pronoun_plurality())</a>
<a name="ln1236">                          + &quot; a foul &quot;;</a>
<a name="ln1237">            if (mon-&gt;has_ench(ENCH_GLOWING_SHAPESHIFTER))</a>
<a name="ln1238">                god_warning += &quot;glowing &quot;;</a>
<a name="ln1239">            god_warning += &quot;shapeshifter.&quot;;</a>
<a name="ln1240">        }</a>
<a name="ln1241"> </a>
<a name="ln1242">        monster_info mi(mon);</a>
<a name="ln1243"> </a>
<a name="ln1244">        const string mweap = get_monster_equipment_desc(mi, DESC_IDENTIFIED,</a>
<a name="ln1245">                                                        DESC_NONE);</a>
<a name="ln1246"> </a>
<a name="ln1247">        if (!mweap.empty())</a>
<a name="ln1248">        {</a>
<a name="ln1249">            text += &quot; &quot; + uppercase_first(mon-&gt;pronoun(PRONOUN_SUBJECTIVE))</a>
<a name="ln1250">                + &quot; &quot; + conjugate_verb(&quot;are&quot;, mi.pronoun_plurality())</a>
<a name="ln1251">                + (mweap[0] != ' ' ? &quot; &quot; : &quot;&quot;)</a>
<a name="ln1252">                + mweap + &quot;.&quot;;</a>
<a name="ln1253">        }</a>
<a name="ln1254"> </a>
<a name="ln1255">        if (msgs_buf)</a>
<a name="ln1256">            msgs_buf-&gt;push_back(text);</a>
<a name="ln1257">        else</a>
<a name="ln1258">        {</a>
<a name="ln1259">            mprf(MSGCH_MONSTER_WARNING, &quot;%s&quot;, text.c_str());</a>
<a name="ln1260">            if (zin_id)</a>
<a name="ln1261">                mprf(MSGCH_GOD, &quot;%s&quot;, god_warning.c_str());</a>
<a name="ln1262">#ifndef USE_TILE_LOCAL</a>
<a name="ln1263">            if (zin_id)</a>
<a name="ln1264">                update_monster_pane();</a>
<a name="ln1265">#endif</a>
<a name="ln1266">            if (player_under_penance(GOD_GOZAG)</a>
<a name="ln1267">                &amp;&amp; !mon-&gt;wont_attack()</a>
<a name="ln1268">                &amp;&amp; !mon-&gt;is_stationary()</a>
<a name="ln1269">                &amp;&amp; !mons_is_object(mon-&gt;type)</a>
<a name="ln1270">                &amp;&amp; !mons_is_tentacle_or_tentacle_segment(mon-&gt;type))</a>
<a name="ln1271">            {</a>
<a name="ln1272">                if (coinflip()</a>
<a name="ln1273">                    &amp;&amp; mon-&gt;get_experience_level() &gt;=</a>
<a name="ln1274">                       random2(you.experience_level))</a>
<a name="ln1275">                {</a>
<a name="ln1276">                    mprf(MSGCH_GOD, GOD_GOZAG, &quot;Gozag incites %s against you.&quot;,</a>
<a name="ln1277">                         mon-&gt;name(DESC_THE).c_str());</a>
<a name="ln1278">                    gozag_incite(mon);</a>
<a name="ln1279">                }</a>
<a name="ln1280">            }</a>
<a name="ln1281">        }</a>
<a name="ln1282">        if (you.has_mutation(MUT_SCREAM)</a>
<a name="ln1283">            &amp;&amp; x_chance_in_y(3 + you.get_mutation_level(MUT_SCREAM) * 3, 100))</a>
<a name="ln1284">        {</a>
<a name="ln1285">            yell(mon);</a>
<a name="ln1286">        }</a>
<a name="ln1287">        mons_set_just_seen(mon);</a>
<a name="ln1288">    }</a>
<a name="ln1289"> </a>
<a name="ln1290">    if (crawl_state.game_is_hints())</a>
<a name="ln1291">        hints_monster_seen(*mon);</a>
<a name="ln1292"> </a>
<a name="ln1293">    return true;</a>
<a name="ln1294">}</a>
<a name="ln1295"> </a>
<a name="ln1296">// Turns autopickup off if we ran into an invisible monster or saw a monster</a>
<a name="ln1297">// turn invisible.</a>
<a name="ln1298">// Turns autopickup on if we saw an invisible monster become visible or</a>
<a name="ln1299">// killed an invisible monster.</a>
<a name="ln1300">void autotoggle_autopickup(bool off)</a>
<a name="ln1301">{</a>
<a name="ln1302">    if (off)</a>
<a name="ln1303">    {</a>
<a name="ln1304">        if (Options.autopickup_on &gt; 0)</a>
<a name="ln1305">        {</a>
<a name="ln1306">            Options.autopickup_on = -1;</a>
<a name="ln1307">            mprf(MSGCH_WARN,</a>
<a name="ln1308">                 &quot;Deactivating autopickup; reactivate with &lt;w&gt;%s&lt;/w&gt;.&quot;,</a>
<a name="ln1309">                 command_to_string(CMD_TOGGLE_AUTOPICKUP).c_str());</a>
<a name="ln1310">        }</a>
<a name="ln1311">        if (crawl_state.game_is_hints())</a>
<a name="ln1312">        {</a>
<a name="ln1313">            learned_something_new(HINT_INVISIBLE_DANGER);</a>
<a name="ln1314">            Hints.hints_seen_invisible = you.num_turns;</a>
<a name="ln1315">        }</a>
<a name="ln1316">    }</a>
<a name="ln1317">    else if (Options.autopickup_on &lt; 0) // was turned off automatically</a>
<a name="ln1318">    {</a>
<a name="ln1319">        Options.autopickup_on = 1;</a>
<a name="ln1320">        mprf(MSGCH_WARN, &quot;Reactivating autopickup.&quot;);</a>
<a name="ln1321">    }</a>
<a name="ln1322">}</a>
<a name="ln1323"> </a>
<a name="ln1324">// Returns true if any activity was stopped. Not reentrant.</a>
<a name="ln1325">bool interrupt_activity(activity_interrupt ai,</a>
<a name="ln1326">                        const activity_interrupt_data &amp;at,</a>
<a name="ln1327">                        vector&lt;string&gt;* msgs_buf)</a>
<a name="ln1328">{</a>
<a name="ln1329">    if (interrupt_block::blocked())</a>
<a name="ln1330">        return false;</a>
<a name="ln1331"> </a>
<a name="ln1332">    const interrupt_block block_recursive_interrupts;</a>
<a name="ln1333">    if (ai == activity_interrupt::hit_monster</a>
<a name="ln1334">        || ai == activity_interrupt::monster_attacks)</a>
<a name="ln1335">    {</a>
<a name="ln1336">        const monster* mon = at.mons_data;</a>
<a name="ln1337">        if (mon &amp;&amp; !mon-&gt;visible_to(&amp;you) &amp;&amp; !mon-&gt;submerged())</a>
<a name="ln1338">            autotoggle_autopickup(true);</a>
<a name="ln1339">    }</a>
<a name="ln1340"> </a>
<a name="ln1341">    if (crawl_state.is_repeating_cmd())</a>
<a name="ln1342">        return interrupt_cmd_repeat(ai, at);</a>
<a name="ln1343"> </a>
<a name="ln1344">    if (!you_are_delayed())</a>
<a name="ln1345">    {</a>
<a name="ln1346">        // Printing &quot;[foo] comes into view.&quot; messages even when not</a>
<a name="ln1347">        // auto-exploring/travelling.</a>
<a name="ln1348">        if (ai == activity_interrupt::see_monster)</a>
<a name="ln1349">            return _monster_warning(ai, at, nullptr, msgs_buf);</a>
<a name="ln1350">        else</a>
<a name="ln1351">            return false;</a>
<a name="ln1352">    }</a>
<a name="ln1353"> </a>
<a name="ln1354">    const auto delay = current_delay();</a>
<a name="ln1355"> </a>
<a name="ln1356">    // If we get hungry while traveling, let's try to auto-eat a chunk.</a>
<a name="ln1357">    if (ai == activity_interrupt::hungry &amp;&amp; delay-&gt;want_autoeat() &amp;&amp; _auto_eat()</a>
<a name="ln1358">        &amp;&amp; prompt_eat_chunks(true) == 1)</a>
<a name="ln1359">    {</a>
<a name="ln1360">        return false;</a>
<a name="ln1361">    }</a>
<a name="ln1362"> </a>
<a name="ln1363">    dprf(&quot;Activity interrupt: %s&quot;, _activity_interrupt_name(ai));</a>
<a name="ln1364"> </a>
<a name="ln1365">    // First try to stop the current delay.</a>
<a name="ln1366">    if (ai == activity_interrupt::full_hp &amp;&amp; !you.running.notified_hp_full)</a>
<a name="ln1367">    {</a>
<a name="ln1368">        you.running.notified_hp_full = true;</a>
<a name="ln1369">        mpr(&quot;HP restored.&quot;);</a>
<a name="ln1370">    }</a>
<a name="ln1371">    else if (ai == activity_interrupt::full_mp &amp;&amp; !you.running.notified_mp_full)</a>
<a name="ln1372">    {</a>
<a name="ln1373">        you.running.notified_mp_full = true;</a>
<a name="ln1374">        mpr(&quot;Magic restored.&quot;);</a>
<a name="ln1375">    }</a>
<a name="ln1376">    else if (ai == activity_interrupt::ancestor_hp</a>
<a name="ln1377">             &amp;&amp; !you.running.notified_ancestor_hp_full)</a>
<a name="ln1378">    {</a>
<a name="ln1379">        // This interrupt only triggers when the ancestor is in LOS,</a>
<a name="ln1380">        // so this message does not leak information.</a>
<a name="ln1381">        you.running.notified_ancestor_hp_full = true;</a>
<a name="ln1382">        mpr(&quot;Ancestor HP restored.&quot;);</a>
<a name="ln1383">    }</a>
<a name="ln1384"> </a>
<a name="ln1385">    if (_should_stop_activity(delay.get(), ai, at))</a>
<a name="ln1386">    {</a>
<a name="ln1387">        _monster_warning(ai, at, delay, msgs_buf);</a>
<a name="ln1388">        // Teleport stops stair delays.</a>
<a name="ln1389">        stop_delay(ai == activity_interrupt::teleport);</a>
<a name="ln1390"> </a>
<a name="ln1391">        return true;</a>
<a name="ln1392">    }</a>
<a name="ln1393"> </a>
<a name="ln1394">    // Check the other queued delays; the first delay that is interruptible</a>
<a name="ln1395">    // will kill itself and all subsequent delays. This is so that a travel</a>
<a name="ln1396">    // delay stacked behind a delay such as stair/autopickup will be killed</a>
<a name="ln1397">    // correctly by interrupts that the simple stair/autopickup delay ignores.</a>
<a name="ln1398">    for (int i = 1, size = you.delay_queue.size(); i &lt; size; ++i)</a>
<a name="ln1399">    {</a>
<a name="ln1400">        if (_should_stop_activity(you.delay_queue[i].get(), ai, at))</a>
<a name="ln1401">        {</a>
<a name="ln1402">            // Do we have a queued run delay? If we do, flush the delay queue</a>
<a name="ln1403">            // so that stop running Lua notifications happen.</a>
<a name="ln1404">            for (int j = i; j &lt; size; ++j)</a>
<a name="ln1405">            {</a>
<a name="ln1406">                if (you.delay_queue[j]-&gt;is_run())</a>
<a name="ln1407">                {</a>
<a name="ln1408">                    _monster_warning(ai, at, you.delay_queue[j], msgs_buf);</a>
<a name="ln1409">                    _clear_pending_delays(i);</a>
<a name="ln1410">                    return true;</a>
<a name="ln1411">                }</a>
<a name="ln1412">            }</a>
<a name="ln1413"> </a>
<a name="ln1414">            // Non-run queued delays can be discarded without any processing.</a>
<a name="ln1415">            you.delay_queue.erase(you.delay_queue.begin() + i,</a>
<a name="ln1416">                                  you.delay_queue.end());</a>
<a name="ln1417">            return true;</a>
<a name="ln1418">        }</a>
<a name="ln1419">    }</a>
<a name="ln1420"> </a>
<a name="ln1421">    return false;</a>
<a name="ln1422">}</a>
<a name="ln1423"> </a>
<a name="ln1424">// Must match the order of activity_interrupt.h!</a>
<a name="ln1425">static const char *activity_interrupt_names[] =</a>
<a name="ln1426">{</a>
<a name="ln1427">    &quot;force&quot;, &quot;keypress&quot;, &quot;full_hp&quot;, &quot;full_mp&quot;, &quot;ancestor_hp&quot;, &quot;hungry&quot;, &quot;message&quot;,</a>
<a name="ln1428">    &quot;hp_loss&quot;, &quot;stat&quot;, &quot;monster&quot;, &quot;monster_attack&quot;, &quot;teleport&quot;, &quot;hit_monster&quot;,</a>
<a name="ln1429">    &quot;sense_monster&quot;, &quot;mimic&quot;</a>
<a name="ln1430">};</a>
<a name="ln1431"> </a>
<a name="ln1432">static const char *_activity_interrupt_name(activity_interrupt ai)</a>
<a name="ln1433">{</a>
<a name="ln1434">    COMPILE_CHECK(ARRAYSZ(activity_interrupt_names) == NUM_ACTIVITY_INTERRUPTS);</a>
<a name="ln1435"> </a>
<a name="ln1436">    if (ai == activity_interrupt::COUNT)</a>
<a name="ln1437">        return &quot;&quot;;</a>
<a name="ln1438"> </a>
<a name="ln1439">    return activity_interrupt_names[static_cast&lt;int&gt;(ai)];</a>
<a name="ln1440">}</a>
<a name="ln1441"> </a>
<a name="ln1442">activity_interrupt get_activity_interrupt(const string &amp;name)</a>
<a name="ln1443">{</a>
<a name="ln1444">    COMPILE_CHECK(ARRAYSZ(activity_interrupt_names) == NUM_ACTIVITY_INTERRUPTS);</a>
<a name="ln1445"> </a>
<a name="ln1446">    for (int i = 0; i &lt; NUM_ACTIVITY_INTERRUPTS; ++i)</a>
<a name="ln1447">        if (name == activity_interrupt_names[i])</a>
<a name="ln1448">            return activity_interrupt(i);</a>
<a name="ln1449"> </a>
<a name="ln1450">    return activity_interrupt::COUNT;</a>
<a name="ln1451">}</a>

</code></pre>
<div class="balloon" rel="853"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v547/" target="_blank">V547</a> Expression 'm' is always true.</p></div>

<link rel="stylesheet" href="highlight.css">
<script src="highlight.pack.js"></script>
<script src="highlightjs-line-numbers.js"></script>
<script>hljs.initHighlightingOnLoad();</script>
<script>hljs.initLineNumbersOnLoad();</script>
<script>
  $(document).ready(function() {
      $('.balloon').each(function () {
          var bl = $(this);
          var line = bl.attr('rel');
          var text = $('a[name="ln'+line+'"]').text();

          var space_count = 0;
          for(var i = 0; i<text.length; i++){
              var char = text[i];
              if((char !== ' ')&&(char !== '\t'))break;
              if(char === '\t')space_count++;
              space_count++;
          }

          bl.css('margin-left', space_count*8);
          $('a[name="ln'+line+'"]').after(bl);
      });

      window.location = window.location;
  });
</script>
</body>
</html>
