
<html>
<head>

  <meta http-equiv="Content-Type" content="text/html; charset=US-ASCII" />
  <title>tilesdl.cc</title>

  <link rel="stylesheet" href="../style.css"/>
  <script src="../jquery-3.2.1.min.js"></script>
</head>
<body>

<pre><code class = "cpp">
<a name="ln1">#include &quot;AppHdr.h&quot;</a>
<a name="ln2"> </a>
<a name="ln3">#ifdef USE_TILE_LOCAL</a>
<a name="ln4"> </a>
<a name="ln5">#include &quot;tilesdl.h&quot;</a>
<a name="ln6"> </a>
<a name="ln7">#include &quot;ability.h&quot;</a>
<a name="ln8">#include &quot;artefact.h&quot;</a>
<a name="ln9">#include &quot;cio.h&quot;</a>
<a name="ln10">#include &quot;command.h&quot;</a>
<a name="ln11">#include &quot;coord.h&quot;</a>
<a name="ln12">#include &quot;env.h&quot;</a>
<a name="ln13">#include &quot;files.h&quot;</a>
<a name="ln14">#include &quot;glwrapper.h&quot;</a>
<a name="ln15">#include &quot;libutil.h&quot;</a>
<a name="ln16">#include &quot;map-knowledge.h&quot;</a>
<a name="ln17">#include &quot;menu.h&quot;</a>
<a name="ln18">#include &quot;message.h&quot;</a>
<a name="ln19">#include &quot;mon-util.h&quot;</a>
<a name="ln20">#include &quot;options.h&quot;</a>
<a name="ln21">#include &quot;output.h&quot;</a>
<a name="ln22">#include &quot;player.h&quot;</a>
<a name="ln23">#include &quot;state.h&quot;</a>
<a name="ln24">#include &quot;rltiles/tiledef-dngn.h&quot;</a>
<a name="ln25">#include &quot;rltiles/tiledef-gui.h&quot;</a>
<a name="ln26">#include &quot;rltiles/tiledef-main.h&quot;</a>
<a name="ln27">#include &quot;tilefont.h&quot;</a>
<a name="ln28">#include &quot;tilereg-abl.h&quot;</a>
<a name="ln29">#include &quot;tilereg-cmd.h&quot;</a>
<a name="ln30">#include &quot;tilereg-crt.h&quot;</a>
<a name="ln31">#include &quot;tilereg-dgn.h&quot;</a>
<a name="ln32">#include &quot;tilereg-doll.h&quot;</a>
<a name="ln33">#include &quot;tilereg.h&quot;</a>
<a name="ln34">#include &quot;tilereg-inv.h&quot;</a>
<a name="ln35">#include &quot;tilereg-map.h&quot;</a>
<a name="ln36">#include &quot;tilereg-mem.h&quot;</a>
<a name="ln37">#include &quot;tilereg-mon.h&quot;</a>
<a name="ln38">#include &quot;tilereg-msg.h&quot;</a>
<a name="ln39">#include &quot;tilereg-skl.h&quot;</a>
<a name="ln40">#include &quot;tilereg-spl.h&quot;</a>
<a name="ln41">#include &quot;tilereg-stat.h&quot;</a>
<a name="ln42">#include &quot;tilereg-tab.h&quot;</a>
<a name="ln43">#include &quot;tilereg-text.h&quot;</a>
<a name="ln44">#include &quot;tileview.h&quot;</a>
<a name="ln45">#include &quot;travel.h&quot;</a>
<a name="ln46">#include &quot;ui.h&quot;</a>
<a name="ln47">#include &quot;unwind.h&quot;</a>
<a name="ln48">#include &quot;version.h&quot;</a>
<a name="ln49">#include &quot;viewgeom.h&quot;</a>
<a name="ln50">#include &quot;view.h&quot;</a>
<a name="ln51">#include &quot;windowmanager.h&quot;</a>
<a name="ln52"> </a>
<a name="ln53">#ifdef __ANDROID__</a>
<a name="ln54">#include &lt;android/log.h&gt;</a>
<a name="ln55">#include &lt;GLES/gl.h&gt;</a>
<a name="ln56">//#include &lt;SDL_android.h&gt;</a>
<a name="ln57">#endif</a>
<a name="ln58"> </a>
<a name="ln59">#ifdef TARGET_OS_WINDOWS</a>
<a name="ln60"># include &lt;windows.h&gt;</a>
<a name="ln61">#endif</a>
<a name="ln62"> </a>
<a name="ln63">// Default Screen Settings</a>
<a name="ln64">// width, height, map, crt, stat, msg, tip, lbl</a>
<a name="ln65">#ifdef TOUCH_UI</a>
<a name="ln66">static int _screen_sizes[6][8] =</a>
<a name="ln67">#else</a>
<a name="ln68">static int _screen_sizes[4][8] =</a>
<a name="ln69">#endif</a>
<a name="ln70">{</a>
<a name="ln71">    // Default</a>
<a name="ln72">    {1024, 700, 3, 15, 16, 14, 15, 14},</a>
<a name="ln73">    // Eee PC 900+</a>
<a name="ln74">    {1024, 600, 2, 14, 14, 12, 13, 12},</a>
<a name="ln75">    // Small screen</a>
<a name="ln76">    {800, 600, 2, 14, 11, 12, 13, 12},</a>
<a name="ln77">    // Eee PC</a>
<a name="ln78">    {800, 480, 2, 13, 12, 10, 13, 11}</a>
<a name="ln79">#ifdef TOUCH_UI</a>
<a name="ln80">    // puny mobile screens</a>
<a name="ln81">    ,{480, 320, 2, 9, 8, 8, 9, 8}</a>
<a name="ln82">    ,{320, 240, 1, 8, 8, 6, 8, 6} // :(</a>
<a name="ln83">#endif</a>
<a name="ln84">};</a>
<a name="ln85"> </a>
<a name="ln86">HiDPIState display_density(1,1);</a>
<a name="ln87"> </a>
<a name="ln88">TilesFramework tiles;</a>
<a name="ln89"> </a>
<a name="ln90"> </a>
<a name="ln91">HiDPIState::HiDPIState(int device_density, int logical_density) :</a>
<a name="ln92">        device(device_density), logical(logical_density)</a>
<a name="ln93">{</a>
<a name="ln94">}</a>
<a name="ln95"> </a>
<a name="ln96">/**</a>
<a name="ln97"> * Calculate the device pixels given the logical pixels; the two may be</a>
<a name="ln98"> * different on high-DPI devices (such as retina displays).</a>
<a name="ln99"> *</a>
<a name="ln100"> * @param n a value in logical pixels</a>
<a name="ln101"> * @return the result in device pixels. May be the same, if the device isn't</a>
<a name="ln102"> *          high-DPI.</a>
<a name="ln103"> */</a>
<a name="ln104">int HiDPIState::logical_to_device(int n) const</a>
<a name="ln105">{</a>
<a name="ln106">    return n * device / logical;</a>
<a name="ln107">}</a>
<a name="ln108"> </a>
<a name="ln109">/**</a>
<a name="ln110"> * Calculate logical pixels given device pixels; the two may be</a>
<a name="ln111"> * different on high-DPI devices (such as retina displays).</a>
<a name="ln112"> *</a>
<a name="ln113"> * @param n a value in device pixels</a>
<a name="ln114"> * @param round whether to round (or truncate); defaults to true. Rounding is</a>
<a name="ln115"> *        safer, as truncating may lead to underestimating dimensions.</a>
<a name="ln116"> * @return the result in logical pixels. May be the same, if the device isn't</a>
<a name="ln117"> *          high-DPI.</a>
<a name="ln118"> */</a>
<a name="ln119">int HiDPIState::device_to_logical(int n, bool round) const</a>
<a name="ln120">{</a>
<a name="ln121">    return (n * logical + (round ?  device - 1 : 0)) / device;</a>
<a name="ln122">}</a>
<a name="ln123"> </a>
<a name="ln124">/*</a>
<a name="ln125"> * Return a float multiplier such that device * multiplier = logical.</a>
<a name="ln126"> * for high-dpi displays, will be fractional.</a>
<a name="ln127"> */</a>
<a name="ln128">float HiDPIState::scale_to_logical() const</a>
<a name="ln129">{</a>
<a name="ln130">    return (float) logical / (float) device;</a>
<a name="ln131">}</a>
<a name="ln132"> </a>
<a name="ln133">/*</a>
<a name="ln134"> * Return a float multiplier such that logical * multiplier = device.</a>
<a name="ln135"> */</a>
<a name="ln136">float HiDPIState::scale_to_device() const</a>
<a name="ln137">{</a>
<a name="ln138">    return (float) device / (float) logical;</a>
<a name="ln139">}</a>
<a name="ln140"> </a>
<a name="ln141">/**</a>
<a name="ln142"> * Update the DPI, e.g. after a window move.</a>
<a name="ln143"> *</a>
<a name="ln144"> * @return whether the ratio changed.</a>
<a name="ln145"> */</a>
<a name="ln146">bool HiDPIState::update(int ndevice, int nlogical)</a>
<a name="ln147">{</a>
<a name="ln148">    HiDPIState old = *this;</a>
<a name="ln149">    if (nlogical == ndevice)</a>
<a name="ln150">        logical = device = 1;</a>
<a name="ln151">    else</a>
<a name="ln152">    {</a>
<a name="ln153">        device = ndevice;</a>
<a name="ln154">        logical = nlogical;</a>
<a name="ln155">    }</a>
<a name="ln156">    // check if the ratios remain the same.</a>
<a name="ln157">    // yes, this is kind of a dumb way to do it.</a>
<a name="ln158">    return (old.device * 100 / old.logical) != (device * 100 / logical);</a>
<a name="ln159">}</a>
<a name="ln160"> </a>
<a name="ln161">TilesFramework::TilesFramework() :</a>
<a name="ln162">    m_windowsz(1024, 768),</a>
<a name="ln163">    m_fullscreen(false),</a>
<a name="ln164">    m_need_redraw(false),</a>
<a name="ln165">    m_active_layer(LAYER_CRT),</a>
<a name="ln166">    m_mouse(-1, -1),</a>
<a name="ln167">    m_last_tick_redraw(0)</a>
<a name="ln168">{</a>
<a name="ln169">}</a>
<a name="ln170"> </a>
<a name="ln171">TilesFramework::~TilesFramework()</a>
<a name="ln172">{</a>
<a name="ln173">}</a>
<a name="ln174"> </a>
<a name="ln175">bool TilesFramework::fonts_initialized()</a>
<a name="ln176">{</a>
<a name="ln177">    // TODO should in principle check the m_fonts vector as well</a>
<a name="ln178">    return m_crt_font &amp;&amp; m_msg_font &amp;&amp; m_stat_font &amp;&amp; m_tip_font &amp;&amp; m_lbl_font;</a>
<a name="ln179">}</a>
<a name="ln180"> </a>
<a name="ln181">static void _init_consoles()</a>
<a name="ln182">{</a>
<a name="ln183">#ifdef TARGET_OS_WINDOWS</a>
<a name="ln184">    // Windows has an annoying habbit of disconnecting GUI apps from</a>
<a name="ln185">    // consoles at startup, and insisting that console apps start with</a>
<a name="ln186">    // consoles.</a>
<a name="ln187">    //</a>
<a name="ln188">    // We build tiles as a GUI app, so we work around this by</a>
<a name="ln189">    // reconnecting ourselves to the parent process's console (if</a>
<a name="ln190">    // any), on capable systems.</a>
<a name="ln191"> </a>
<a name="ln192">    // The AttachConsole() function is XP/2003 Server and up, so we</a>
<a name="ln193">    // need to do the GetModuleHandle()/GetProcAddress() dance.</a>
<a name="ln194">    typedef BOOL (WINAPI *ac_func)(DWORD);</a>
<a name="ln195">    ac_func attach_console = (ac_func)GetProcAddress(</a>
<a name="ln196">        GetModuleHandle(TEXT(&quot;kernel32.dll&quot;)), &quot;AttachConsole&quot;);</a>
<a name="ln197"> </a>
<a name="ln198">    if (attach_console)</a>
<a name="ln199">    {</a>
<a name="ln200">        // Direct output to the console if it isn't already directed</a>
<a name="ln201">        // somewhere.</a>
<a name="ln202"> </a>
<a name="ln203">        // Grab our parent's console (if any), unless we somehow</a>
<a name="ln204">        // already have a console.</a>
<a name="ln205">        attach_console((DWORD)-1); // ATTACH_PARENT_PROCESS</a>
<a name="ln206"> </a>
<a name="ln207">        // FIXME: this overrides redirection.</a>
<a name="ln208">        //</a>
<a name="ln209">        // We can get the current stdout/stderr handles with</a>
<a name="ln210">        // GetStdHandle, but we can't check their validity by</a>
<a name="ln211">        // comparing against either INVALID_HANDLE_VALUE or 0 ...</a>
<a name="ln212">        freopen(&quot;CONOUT$&quot;, &quot;wb&quot;, stdout);</a>
<a name="ln213">        freopen(&quot;CONOUT$&quot;, &quot;wb&quot;, stderr);</a>
<a name="ln214">    }</a>
<a name="ln215">#endif</a>
<a name="ln216">}</a>
<a name="ln217"> </a>
<a name="ln218">static void _shutdown_console()</a>
<a name="ln219">{</a>
<a name="ln220">#ifdef TARGET_OS_WINDOWS</a>
<a name="ln221">    typedef BOOL (WINAPI *fc_func)();</a>
<a name="ln222">    fc_func free_console = (fc_func)GetProcAddress(</a>
<a name="ln223">        GetModuleHandle(TEXT(&quot;kernel32.dll&quot;)), &quot;FreeConsole&quot;);</a>
<a name="ln224">    if (free_console)</a>
<a name="ln225">        free_console();</a>
<a name="ln226">#endif</a>
<a name="ln227">}</a>
<a name="ln228">void TilesFramework::shutdown()</a>
<a name="ln229">{</a>
<a name="ln230">    delete m_region_tile;</a>
<a name="ln231">    delete m_region_stat;</a>
<a name="ln232">    delete m_region_msg;</a>
<a name="ln233">    delete m_region_map;</a>
<a name="ln234">    delete m_region_tab;</a>
<a name="ln235">    delete m_region_inv;</a>
<a name="ln236">    delete m_region_abl;</a>
<a name="ln237">    delete m_region_spl;</a>
<a name="ln238">    delete m_region_mem;</a>
<a name="ln239">    delete m_region_mon;</a>
<a name="ln240">    delete m_region_cmd;</a>
<a name="ln241">    delete m_region_cmd_meta;</a>
<a name="ln242">    delete m_region_cmd_map;</a>
<a name="ln243">    delete m_region_crt;</a>
<a name="ln244"> </a>
<a name="ln245">    m_region_tile  = nullptr;</a>
<a name="ln246">    m_region_stat  = nullptr;</a>
<a name="ln247">    m_region_msg   = nullptr;</a>
<a name="ln248">    m_region_map   = nullptr;</a>
<a name="ln249">    m_region_tab   = nullptr;</a>
<a name="ln250">    m_region_inv   = nullptr;</a>
<a name="ln251">    m_region_abl   = nullptr;</a>
<a name="ln252">    m_region_spl   = nullptr;</a>
<a name="ln253">    m_region_mem   = nullptr;</a>
<a name="ln254">    m_region_mon   = nullptr;</a>
<a name="ln255">    m_region_cmd   = nullptr;</a>
<a name="ln256">    m_region_cmd_meta = nullptr;</a>
<a name="ln257">    m_region_cmd_map  = nullptr;</a>
<a name="ln258">    m_region_crt   = nullptr;</a>
<a name="ln259"> </a>
<a name="ln260">    for (tab_iterator it = m_tabs.begin(); it != m_tabs.end(); ++it)</a>
<a name="ln261">        delete it-&gt;second;</a>
<a name="ln262"> </a>
<a name="ln263">    m_tabs.clear();</a>
<a name="ln264"> </a>
<a name="ln265">    for (Layer &amp;layer : m_layers)</a>
<a name="ln266">        layer.m_regions.clear();</a>
<a name="ln267"> </a>
<a name="ln268">    for (font_info &amp;font : m_fonts)</a>
<a name="ln269">    {</a>
<a name="ln270">        delete font.font;</a>
<a name="ln271">        font.font = nullptr;</a>
<a name="ln272">    }</a>
<a name="ln273"> </a>
<a name="ln274">    delete m_image;</a>
<a name="ln275"> </a>
<a name="ln276">    GLStateManager::shutdown();</a>
<a name="ln277">    WindowManager::shutdown();</a>
<a name="ln278"> </a>
<a name="ln279">    _shutdown_console();</a>
<a name="ln280">}</a>
<a name="ln281"> </a>
<a name="ln282">void TilesFramework::draw_doll_edit()</a>
<a name="ln283">{</a>
<a name="ln284">    DollEditRegion reg(m_image, m_msg_font);</a>
<a name="ln285">    reg.run();</a>
<a name="ln286">}</a>
<a name="ln287"> </a>
<a name="ln288">void TilesFramework::set_map_display(const bool display)</a>
<a name="ln289">{</a>
<a name="ln290">    m_map_mode_enabled = display;</a>
<a name="ln291">    if (!display &amp;&amp; !tiles.is_using_small_layout())</a>
<a name="ln292">        m_region_tab-&gt;activate_tab(TAB_ITEM);</a>
<a name="ln293">    do_layout(); // recalculate the viewport setup for zoom levels</a>
<a name="ln294">    redraw_screen(false);</a>
<a name="ln295">}</a>
<a name="ln296"> </a>
<a name="ln297">bool TilesFramework::get_map_display()</a>
<a name="ln298">{</a>
<a name="ln299">    return m_map_mode_enabled;</a>
<a name="ln300">}</a>
<a name="ln301"> </a>
<a name="ln302">void TilesFramework::do_map_display()</a>
<a name="ln303">{</a>
<a name="ln304">    m_map_mode_enabled = true;</a>
<a name="ln305">    do_layout(); // recalculate the viewport setup for zoom levels</a>
<a name="ln306">    redraw_screen(false);</a>
<a name="ln307">    m_region_tab-&gt;activate_tab(TAB_NAVIGATION);</a>
<a name="ln308">}</a>
<a name="ln309"> </a>
<a name="ln310">void TilesFramework::calculate_default_options()</a>
<a name="ln311">{</a>
<a name="ln312">    // Find which set of _screen_sizes to use.</a>
<a name="ln313">    int auto_size = 0;</a>
<a name="ln314">    int num_screen_sizes = ARRAYSZ(_screen_sizes);</a>
<a name="ln315">    do</a>
<a name="ln316">    {</a>
<a name="ln317">        if (m_windowsz.x &gt;= _screen_sizes[auto_size][0]</a>
<a name="ln318">            &amp;&amp; m_windowsz.y &gt;= _screen_sizes[auto_size][1])</a>
<a name="ln319">        {</a>
<a name="ln320">            break;</a>
<a name="ln321">        }</a>
<a name="ln322">    }</a>
<a name="ln323">    while (++auto_size &lt; num_screen_sizes - 1);</a>
<a name="ln324"> </a>
<a name="ln325">    m_map_pixels = Options.tile_map_pixels;</a>
<a name="ln326">    // Auto pick map and font sizes if option is zero.</a>
<a name="ln327">#define AUTO(x,y) (x = (x) ? (x) : _screen_sizes[auto_size][(y)])</a>
<a name="ln328">    AUTO(m_map_pixels, 2);</a>
<a name="ln329">    AUTO(Options.tile_font_crt_size, 3);</a>
<a name="ln330">    AUTO(Options.tile_font_stat_size, 4);</a>
<a name="ln331">    AUTO(Options.tile_font_msg_size, 5);</a>
<a name="ln332">    AUTO(Options.tile_font_tip_size, 6);</a>
<a name="ln333">    AUTO(Options.tile_font_lbl_size, 7);</a>
<a name="ln334">#undef AUTO</a>
<a name="ln335"> </a>
<a name="ln336">    m_tab_margin = Options.tile_font_lbl_size + 4;</a>
<a name="ln337">}</a>
<a name="ln338"> </a>
<a name="ln339">bool TilesFramework::initialise()</a>
<a name="ln340">{</a>
<a name="ln341">    if (crawl_state.tiles_disabled)</a>
<a name="ln342">        return true;</a>
<a name="ln343">    _init_consoles();</a>
<a name="ln344"> </a>
<a name="ln345">    const char *icon_name =</a>
<a name="ln346">#ifdef DATA_DIR_PATH</a>
<a name="ln347">#ifndef __ANDROID__</a>
<a name="ln348">    DATA_DIR_PATH</a>
<a name="ln349">#endif</a>
<a name="ln350">#endif</a>
<a name="ln351">    &quot;dat/tiles/stone_soup_icon-512x512.png&quot;;</a>
<a name="ln352"> </a>
<a name="ln353">    string title = string(CRAWL &quot; &quot;) + Version::Long;</a>
<a name="ln354"> </a>
<a name="ln355">    // Do our initialization here.</a>
<a name="ln356"> </a>
<a name="ln357">    // Create an instance of UIWrapper for the library we were compiled for</a>
<a name="ln358">    WindowManager::create();</a>
<a name="ln359">    if (!wm)</a>
<a name="ln360">        return false;</a>
<a name="ln361"> </a>
<a name="ln362">    // Initialize the wrapper</a>
<a name="ln363">    // hidpi initialization happens here</a>
<a name="ln364">    if (!wm-&gt;init(&amp;m_windowsz))</a>
<a name="ln365">        return false;</a>
<a name="ln366"> </a>
<a name="ln367">    wm-&gt;set_window_title(title.c_str());</a>
<a name="ln368">    wm-&gt;set_window_icon(icon_name);</a>
<a name="ln369"> </a>
<a name="ln370">    // Copy over constants that need to have been set by the wrapper</a>
<a name="ln371">    m_screen_width = wm-&gt;screen_width();</a>
<a name="ln372">    m_screen_height = wm-&gt;screen_height();</a>
<a name="ln373"> </a>
<a name="ln374">    GLStateManager::init();</a>
<a name="ln375"> </a>
<a name="ln376">    // TODO: what is the minimal startup here needed so that an error dialog</a>
<a name="ln377">    // can be shown on not found files?</a>
<a name="ln378"> </a>
<a name="ln379">    m_image = new ImageManager();</a>
<a name="ln380"> </a>
<a name="ln381">    // If the window size is less than the view height, the textures will</a>
<a name="ln382">    // have to be shrunk. If this isn't the case, then don't create mipmaps,</a>
<a name="ln383">    // as this appears to make things blurry on some users machines.</a>
<a name="ln384">    bool need_mips = (m_windowsz.y &lt; 32 * VIEW_MIN_HEIGHT);</a>
<a name="ln385">    if (!m_image-&gt;load_textures(need_mips))</a>
<a name="ln386">        return false;</a>
<a name="ln387"> </a>
<a name="ln388">    calculate_default_options();</a>
<a name="ln389"> </a>
<a name="ln390">    m_crt_font    = load_font(Options.tile_font_crt_file.c_str(),</a>
<a name="ln391">                              Options.tile_font_crt_size, true);</a>
<a name="ln392">    m_msg_font    = load_font(Options.tile_font_msg_file.c_str(),</a>
<a name="ln393">                              Options.tile_font_msg_size, true);</a>
<a name="ln394">    m_stat_font   = load_font(Options.tile_font_stat_file.c_str(),</a>
<a name="ln395">                              Options.tile_font_stat_size, true);</a>
<a name="ln396">    m_tip_font    = load_font(Options.tile_font_tip_file.c_str(),</a>
<a name="ln397">                              Options.tile_font_tip_size, true);</a>
<a name="ln398">    m_lbl_font    = load_font(Options.tile_font_lbl_file.c_str(),</a>
<a name="ln399">                              Options.tile_font_lbl_size, true);</a>
<a name="ln400"> </a>
<a name="ln401">    if (!fonts_initialized())</a>
<a name="ln402">        return false;</a>
<a name="ln403"> </a>
<a name="ln404">    const auto font = tiles.is_using_small_layout() ? m_crt_font : m_lbl_font;</a>
<a name="ln405">    m_init = TileRegionInit(m_image, font, TILE_X, TILE_Y);</a>
<a name="ln406">    m_region_tile = new DungeonRegion(m_init);</a>
<a name="ln407">    m_region_tab  = new TabbedRegion(m_init);</a>
<a name="ln408">    m_region_inv  = new InventoryRegion(m_init);</a>
<a name="ln409">    m_region_spl  = new SpellRegion(m_init);</a>
<a name="ln410">    m_region_mem  = new MemoriseRegion(m_init);</a>
<a name="ln411">    m_region_abl  = new AbilityRegion(m_init);</a>
<a name="ln412">    m_region_mon  = new MonsterRegion(m_init);</a>
<a name="ln413">    m_region_skl  = new SkillRegion(m_init);</a>
<a name="ln414">    m_region_cmd  = new CommandRegion(m_init, ct_action_commands,</a>
<a name="ln415">                                      ARRAYSZ(ct_action_commands));</a>
<a name="ln416">    m_region_cmd_meta = new CommandRegion(m_init, ct_system_commands,</a>
<a name="ln417">                                          ARRAYSZ(ct_system_commands),</a>
<a name="ln418">                                          &quot;System Commands&quot;,</a>
<a name="ln419">                                          &quot;Execute system commands&quot;);</a>
<a name="ln420">    m_region_cmd_map = new CommandRegion(m_init, ct_map_commands,</a>
<a name="ln421">                                         ARRAYSZ(ct_map_commands),</a>
<a name="ln422">                                         &quot;Navigation&quot;, &quot;Navigate around map&quot;);</a>
<a name="ln423"> </a>
<a name="ln424">#ifdef TOUCH_UI</a>
<a name="ln425">    if (tiles.is_using_small_layout())</a>
<a name="ln426">        m_region_tab-&gt;push_tab_button(CMD_EXPLORE, TILEG_CMD_EXPLORE);</a>
<a name="ln427">    TAB_ITEM    = m_region_tab-&gt;push_tab_region(m_region_inv, TILEG_TAB_ITEM);</a>
<a name="ln428">    TAB_SPELL   = m_region_tab-&gt;push_tab_region(m_region_spl, TILEG_TAB_SPELL);</a>
<a name="ln429">    TAB_ABILITY = m_region_tab-&gt;push_tab_region(m_region_abl, TILEG_TAB_ABILITY);</a>
<a name="ln430">    m_region_tab-&gt;push_tab_region(m_region_mon, TILEG_TAB_MONSTER);</a>
<a name="ln431">    TAB_COMMAND = m_region_tab-&gt;push_tab_region(m_region_cmd, TILEG_TAB_COMMAND);</a>
<a name="ln432">    m_region_tab-&gt;push_tab_region(m_region_cmd_meta,</a>
<a name="ln433">                                  TILEG_TAB_COMMAND2);</a>
<a name="ln434">    TAB_NAVIGATION = m_region_tab-&gt;push_tab_region(m_region_cmd_map,</a>
<a name="ln435">                                  TILEG_TAB_NAVIGATION);</a>
<a name="ln436">    m_region_tab-&gt;activate_tab(TAB_COMMAND);</a>
<a name="ln437">#else</a>
<a name="ln438">    TAB_ITEM    = m_region_tab-&gt;push_tab_region(m_region_inv, TILEG_TAB_ITEM);</a>
<a name="ln439">    TAB_SPELL   = m_region_tab-&gt;push_tab_region(m_region_spl, TILEG_TAB_SPELL);</a>
<a name="ln440">    m_region_tab-&gt;push_tab_region(m_region_mem, TILEG_TAB_MEMORISE);</a>
<a name="ln441">    TAB_ABILITY = m_region_tab-&gt;push_tab_region(m_region_abl, TILEG_TAB_ABILITY);</a>
<a name="ln442">    m_region_tab-&gt;push_tab_region(m_region_mon, TILEG_TAB_MONSTER);</a>
<a name="ln443">    m_region_tab-&gt;push_tab_region(m_region_skl, TILEG_TAB_SKILL);</a>
<a name="ln444">    TAB_COMMAND = m_region_tab-&gt;push_tab_region(m_region_cmd, TILEG_TAB_COMMAND);</a>
<a name="ln445">    m_region_tab-&gt;push_tab_region(m_region_cmd_meta,</a>
<a name="ln446">                                  TILEG_TAB_COMMAND2);</a>
<a name="ln447">    TAB_NAVIGATION = m_region_tab-&gt;push_tab_region(m_region_cmd_map,</a>
<a name="ln448">                                                   TILEG_TAB_NAVIGATION);</a>
<a name="ln449">    m_region_tab-&gt;activate_tab(TAB_ITEM);</a>
<a name="ln450">#endif</a>
<a name="ln451"> </a>
<a name="ln452">    m_region_msg  = new MessageRegion(m_msg_font);</a>
<a name="ln453">    m_region_stat = new StatRegion(m_stat_font);</a>
<a name="ln454">    m_region_crt  = new CRTRegion(m_crt_font);</a>
<a name="ln455"> </a>
<a name="ln456">    m_layers[LAYER_NORMAL].m_regions.push_back(m_region_tile);</a>
<a name="ln457">    m_layers[LAYER_NORMAL].m_regions.push_back(m_region_msg);</a>
<a name="ln458">    m_layers[LAYER_NORMAL].m_regions.push_back(m_region_stat);</a>
<a name="ln459">    m_layers[LAYER_NORMAL].m_regions.push_back(m_region_tab);</a>
<a name="ln460"> </a>
<a name="ln461">    m_layers[LAYER_CRT].m_regions.push_back(m_region_crt);</a>
<a name="ln462"> </a>
<a name="ln463">    cgotoxy(1, 1, GOTO_CRT);</a>
<a name="ln464"> </a>
<a name="ln465">    resize();</a>
<a name="ln466"> </a>
<a name="ln467">    return true;</a>
<a name="ln468">}</a>
<a name="ln469"> </a>
<a name="ln470">void TilesFramework::reconfigure_fonts()</a>
<a name="ln471">{</a>
<a name="ln472">    // call this if DPI changes to regenerate the font</a>
<a name="ln473">    for (auto finfo : m_fonts)</a>
<a name="ln474">        finfo.font-&gt;configure_font();</a>
<a name="ln475">}</a>
<a name="ln476"> </a>
<a name="ln477">FontWrapper* TilesFramework::load_font(const char *font_file, int font_size,</a>
<a name="ln478">                              bool default_on_fail)</a>
<a name="ln479">{</a>
<a name="ln480">    for (unsigned int i = 0; i &lt; m_fonts.size(); i++)</a>
<a name="ln481">    {</a>
<a name="ln482">        font_info &amp;finfo = m_fonts[i];</a>
<a name="ln483">        if (finfo.name == font_file &amp;&amp; finfo.size == font_size)</a>
<a name="ln484">            return finfo.font;</a>
<a name="ln485">    }</a>
<a name="ln486"> </a>
<a name="ln487">    FontWrapper *font = FontWrapper::create();</a>
<a name="ln488"> </a>
<a name="ln489">    if (!font-&gt;load_font(font_file, font_size))</a>
<a name="ln490">    {</a>
<a name="ln491">        delete font;</a>
<a name="ln492">        if (default_on_fail)</a>
<a name="ln493">        {</a>
<a name="ln494">            // TODO: this never happens because load_font will die on a missing</a>
<a name="ln495">            // font file. This setup needs to be smoothed out, but also maybe</a>
<a name="ln496">            // MONOSPACE_FONT needs to be validated first.</a>
<a name="ln497">            mprf(MSGCH_ERROR, &quot;Couldn't find font '%s', falling back on '%s'&quot;,</a>
<a name="ln498">                                            font_file, MONOSPACED_FONT);</a>
<a name="ln499">            return load_font(MONOSPACED_FONT, 12, false);</a>
<a name="ln500">        }</a>
<a name="ln501">        else</a>
<a name="ln502">            return nullptr;</a>
<a name="ln503">    }</a>
<a name="ln504"> </a>
<a name="ln505">    font_info finfo;</a>
<a name="ln506">    finfo.font = font;</a>
<a name="ln507">    finfo.name = font_file;</a>
<a name="ln508">    finfo.size = font_size;</a>
<a name="ln509">    m_fonts.push_back(finfo);</a>
<a name="ln510"> </a>
<a name="ln511">    return font;</a>
<a name="ln512">}</a>
<a name="ln513">void TilesFramework::load_dungeon(const crawl_view_buffer &amp;vbuf,</a>
<a name="ln514">                                  const coord_def &amp;gc)</a>
<a name="ln515">{</a>
<a name="ln516">    m_active_layer = LAYER_NORMAL;</a>
<a name="ln517"> </a>
<a name="ln518">    m_region_tile-&gt;load_dungeon(vbuf, gc);</a>
<a name="ln519"> </a>
<a name="ln520">    if (m_region_map)</a>
<a name="ln521">    {</a>
<a name="ln522">        int ox = m_region_tile-&gt;mx/2;</a>
<a name="ln523">        int oy = m_region_tile-&gt;my/2;</a>
<a name="ln524">        coord_def win_start(gc.x - ox, gc.y - oy);</a>
<a name="ln525">        coord_def win_end(gc.x + ox + 1, gc.y + oy + 1);</a>
<a name="ln526">        m_region_map-&gt;set_window(win_start, win_end);</a>
<a name="ln527">    }</a>
<a name="ln528">}</a>
<a name="ln529"> </a>
<a name="ln530">void TilesFramework::load_dungeon(const coord_def &amp;cen)</a>
<a name="ln531">{</a>
<a name="ln532">    unwind_var&lt;coord_def&gt; viewp(crawl_view.viewp, cen - crawl_view.viewhalfsz);</a>
<a name="ln533">    unwind_var&lt;coord_def&gt; vgrdc(crawl_view.vgrdc, cen);</a>
<a name="ln534">    unwind_var&lt;coord_def&gt; vlos1(crawl_view.vlos1);</a>
<a name="ln535">    unwind_var&lt;coord_def&gt; vlos2(crawl_view.vlos2);</a>
<a name="ln536"> </a>
<a name="ln537">    crawl_view.calc_vlos();</a>
<a name="ln538">    viewwindow(false);</a>
<a name="ln539">    tiles.place_cursor(CURSOR_MAP, cen);</a>
<a name="ln540">}</a>
<a name="ln541"> </a>
<a name="ln542">bool TilesFramework::update_dpi()</a>
<a name="ln543">{</a>
<a name="ln544">    if (wm-&gt;init_hidpi())</a>
<a name="ln545">    {</a>
<a name="ln546">        reconfigure_fonts();</a>
<a name="ln547">        return true;</a>
<a name="ln548">    }</a>
<a name="ln549">    return false;</a>
<a name="ln550">}</a>
<a name="ln551"> </a>
<a name="ln552">void TilesFramework::resize()</a>
<a name="ln553">{</a>
<a name="ln554">    update_dpi();</a>
<a name="ln555">    calculate_default_options();</a>
<a name="ln556">    do_layout();</a>
<a name="ln557">    ui::resize(m_windowsz.x, m_windowsz.y);</a>
<a name="ln558">    wm-&gt;resize(m_windowsz);</a>
<a name="ln559">}</a>
<a name="ln560"> </a>
<a name="ln561">void TilesFramework::resize_event(int w, int h)</a>
<a name="ln562">{</a>
<a name="ln563">    m_windowsz.x = w;</a>
<a name="ln564">    m_windowsz.y = h;</a>
<a name="ln565"> </a>
<a name="ln566">    update_dpi();</a>
<a name="ln567">    calculate_default_options();</a>
<a name="ln568">    do_layout();</a>
<a name="ln569">    wm-&gt;resize(m_windowsz);</a>
<a name="ln570">}</a>
<a name="ln571"> </a>
<a name="ln572">int TilesFramework::handle_mouse(wm_mouse_event &amp;event)</a>
<a name="ln573">{</a>
<a name="ln574">    // Note: the mouse event goes to all regions in the active layer because</a>
<a name="ln575">    // we want to be able to start some GUI event (e.g. far viewing) and</a>
<a name="ln576">    // stop if it moves to another region.</a>
<a name="ln577">    int return_key = 0;</a>
<a name="ln578">    for (int i = m_layers[m_active_layer].m_regions.size() - 1; i &gt;= 0 ; --i)</a>
<a name="ln579">    {</a>
<a name="ln580">        // TODO enne - what if two regions give a key?</a>
<a name="ln581">        return_key = m_layers[m_active_layer].m_regions[i]-&gt;handle_mouse(event);</a>
<a name="ln582">        // break after first key handled; to (a) prevent UI cues from</a>
<a name="ln583">        // interfering with one another and (b) make popups work nicely :D</a>
<a name="ln584">        if (return_key)</a>
<a name="ln585">            break;</a>
<a name="ln586">    }</a>
<a name="ln587">    // more popup botching - i want the top layer to return a key (to prevent</a>
<a name="ln588">    // other layers from trying to handle mouse event) and then return zero</a>
<a name="ln589">    // anyway</a>
<a name="ln590">    if (return_key == CK_NO_KEY)</a>
<a name="ln591">        return 0;</a>
<a name="ln592"> </a>
<a name="ln593">    // Let regions take priority in any mouse mode.</a>
<a name="ln594">    if (return_key)</a>
<a name="ln595">        return return_key;</a>
<a name="ln596"> </a>
<a name="ln597">    // Handle &quot;more&quot; mode globally here, rather than duplicate across regions.</a>
<a name="ln598">    if ((mouse_control::current_mode() == MOUSE_MODE_MORE</a>
<a name="ln599">         || mouse_control::current_mode() == MOUSE_MODE_PROMPT</a>
<a name="ln600">         || mouse_control::current_mode() == MOUSE_MODE_YESNO)</a>
<a name="ln601">        &amp;&amp; event.event == wm_mouse_event::PRESS)</a>
<a name="ln602">    {</a>
<a name="ln603">        if (event.button == wm_mouse_event::LEFT)</a>
<a name="ln604">            return CK_MOUSE_CLICK;</a>
<a name="ln605">        else if (event.button == wm_mouse_event::RIGHT)</a>
<a name="ln606">            return CK_MOUSE_CMD;</a>
<a name="ln607">    }</a>
<a name="ln608"> </a>
<a name="ln609">    return 0;</a>
<a name="ln610">}</a>
<a name="ln611"> </a>
<a name="ln612">static unsigned int _timer_callback(unsigned int ticks, void *param)</a>
<a name="ln613">{</a>
<a name="ln614">    UNUSED(ticks, param);</a>
<a name="ln615"> </a>
<a name="ln616"> </a>
<a name="ln617">    return 0;</a>
<a name="ln618">}</a>
<a name="ln619"> </a>
<a name="ln620">int TilesFramework::getch_ck()</a>
<a name="ln621">{</a>
<a name="ln622">    wm_event event;</a>
<a name="ln623">    cursor_loc last_redraw_loc = m_cur_loc;</a>
<a name="ln624"> </a>
<a name="ln625">    int key = 0;</a>
<a name="ln626"> </a>
<a name="ln627">    // Don't update tool tips etc. in targeting mode.</a>
<a name="ln628">    const bool mouse_target_mode</a>
<a name="ln629">                = (mouse_control::current_mode() == MOUSE_MODE_TARGET_PATH</a>
<a name="ln630">                   || mouse_control::current_mode() == MOUSE_MODE_TARGET_DIR);</a>
<a name="ln631"> </a>
<a name="ln632">    const unsigned int ticks_per_screen_redraw = Options.tile_update_rate;</a>
<a name="ln633"> </a>
<a name="ln634"> </a>
<a name="ln635">    m_tooltip.clear();</a>
<a name="ln636">    m_region_msg-&gt;alt_text().clear();</a>
<a name="ln637">    string prev_msg_alt_text = &quot;&quot;;</a>
<a name="ln638"> </a>
<a name="ln639">    if (need_redraw())</a>
<a name="ln640">        redraw();</a>
<a name="ln641"> </a>
<a name="ln642">    while (!key)</a>
<a name="ln643">    {</a>
<a name="ln644">        if (crawl_state.seen_hups)</a>
<a name="ln645">            return ESCAPE;</a>
<a name="ln646"> </a>
<a name="ln647">        unsigned int ticks = 0;</a>
<a name="ln648"> </a>
<a name="ln649">        if (wm-&gt;wait_event(&amp;event, INT_MAX))</a>
<a name="ln650">        {</a>
<a name="ln651">            ticks = wm-&gt;get_ticks();</a>
<a name="ln652">            if (!mouse_target_mode &amp;&amp; event.type != WME_CUSTOMEVENT)</a>
<a name="ln653">            {</a>
<a name="ln654">                tiles.clear_text_tags(TAG_CELL_DESC);</a>
<a name="ln655">                m_region_msg-&gt;alt_text().clear();</a>
<a name="ln656">            }</a>
<a name="ln657"> </a>
<a name="ln658">            switch (event.type)</a>
<a name="ln659">            {</a>
<a name="ln660">            case WME_ACTIVEEVENT:</a>
<a name="ln661">#ifdef __ANDROID__</a>
<a name="ln662">                // short-term: when crawl is 'iconified' in android,</a>
<a name="ln663">                // close it</a>
<a name="ln664">                if (/*event.active.state == 0x04 SDL_APPACTIVE &amp;&amp;*/ event.active.gain == 0)</a>
<a name="ln665">                {</a>
<a name="ln666">                    crawl_state.seen_hups++;</a>
<a name="ln667">                    return ESCAPE;</a>
<a name="ln668">                }</a>
<a name="ln669">                // long-term pseudo-code:</a>
<a name="ln670">                /*</a>
<a name="ln671">                if (event.active.state == SDL_APPACTIVE)</a>
<a name="ln672">                {</a>
<a name="ln673">                    if (event.active.gain == 0)</a>
<a name="ln674">                    {</a>
<a name="ln675">                        if (crawl_state.need_save)</a>
<a name="ln676">                            save_game(true);</a>
<a name="ln677">                        do_no_SDL_or_GL_calls();</a>
<a name="ln678">                    }</a>
<a name="ln679">                    else</a>
<a name="ln680">                    {</a>
<a name="ln681">                        reload_gl_textures();</a>
<a name="ln682">                        reset_gl_state();</a>
<a name="ln683">                        wm-&gt;set_mod_state(TILES_MOD_NONE);</a>
<a name="ln684">                        set_need_redraw();</a>
<a name="ln685">                    }</a>
<a name="ln686">                }</a>
<a name="ln687">                 */</a>
<a name="ln688">#else</a>
<a name="ln689">                // When game gains focus back then set mod state clean</a>
<a name="ln690">                // to get rid of stupid Windows/SDL bug with Alt-Tab.</a>
<a name="ln691">                if (event.active.gain != 0)</a>
<a name="ln692">                {</a>
<a name="ln693">                    wm-&gt;set_mod_state(TILES_MOD_NONE);</a>
<a name="ln694">                    set_need_redraw();</a>
<a name="ln695">                }</a>
<a name="ln696">#endif</a>
<a name="ln697">                break;</a>
<a name="ln698">            case WME_KEYDOWN:</a>
<a name="ln699">                key        = event.key.keysym.sym;</a>
<a name="ln700">                m_region_tile-&gt;place_cursor(CURSOR_MOUSE, NO_CURSOR);</a>
<a name="ln701"> </a>
<a name="ln702">                // If you hit a key, disable tooltips until the mouse</a>
<a name="ln703">                // is moved again.</a>
<a name="ln704">                m_show_tooltip = false;</a>
<a name="ln705">                wm-&gt;remove_timer(m_tooltip_timer_id);</a>
<a name="ln706">                break;</a>
<a name="ln707"> </a>
<a name="ln708">            case WME_KEYUP:</a>
<a name="ln709">                m_show_tooltip = false;</a>
<a name="ln710">                wm-&gt;remove_timer(m_tooltip_timer_id);</a>
<a name="ln711">                break;</a>
<a name="ln712"> </a>
<a name="ln713">            case WME_MOUSEMOTION:</a>
<a name="ln714">                {</a>
<a name="ln715">                    // For consecutive mouse events, ignore all but the last,</a>
<a name="ln716">                    // since these can come in faster than crawl can redraw.</a>
<a name="ln717">                    if (wm-&gt;next_event_is(WME_MOUSEMOTION))</a>
<a name="ln718">                        continue;</a>
<a name="ln719"> </a>
<a name="ln720">                    // Record mouse pos for tooltip timer</a>
<a name="ln721">                    m_mouse.x = event.mouse_event.px;</a>
<a name="ln722">                    m_mouse.y = event.mouse_event.py;</a>
<a name="ln723"> </a>
<a name="ln724">                    // Find the new mouse location</a>
<a name="ln725">                    m_cur_loc.reg = nullptr;</a>
<a name="ln726">                    for (Region *reg : m_layers[m_active_layer].m_regions)</a>
<a name="ln727">                    {</a>
<a name="ln728">                        // inside() can return false here for DungeonRegion</a>
<a name="ln729">                        // order is important: either way, cx and cy need to be set</a>
<a name="ln730">                        if (reg-&gt;mouse_pos(m_mouse.x, m_mouse.y, m_cur_loc.cx, m_cur_loc.cy)</a>
<a name="ln731">                            &amp;&amp; reg-&gt;inside(m_mouse.x, m_mouse.y)) {</a>
<a name="ln732">                            m_cur_loc.reg = reg;</a>
<a name="ln733">                            m_cur_loc.mode = mouse_control::current_mode();</a>
<a name="ln734">                            break;</a>
<a name="ln735">                        }</a>
<a name="ln736">                    }</a>
<a name="ln737"> </a>
<a name="ln738">                    // If the mouse has left a region, clear any cursors left behind</a>
<a name="ln739">                    // handle_mouse() is called after this, since it might place cursors</a>
<a name="ln740">                    if (m_cur_loc.reg != last_redraw_loc.reg)</a>
<a name="ln741">                    {</a>
<a name="ln742">                        for (int i = 0; i &lt; CURSOR_MAX; i++)</a>
<a name="ln743">                            tiles.place_cursor((cursor_type)i, NO_CURSOR);</a>
<a name="ln744">                    }</a>
<a name="ln745"> </a>
<a name="ln746">                    key = handle_mouse(event.mouse_event);</a>
<a name="ln747"> </a>
<a name="ln748">                    // update_alt_text() handlers may depend on data set in handle_mouse() handler</a>
<a name="ln749">                    m_region_msg-&gt;alt_text().clear();</a>
<a name="ln750">                    if (m_cur_loc.reg)</a>
<a name="ln751">                        m_cur_loc.reg-&gt;update_alt_text(m_region_msg-&gt;alt_text());</a>
<a name="ln752">                    if (prev_msg_alt_text != m_region_msg-&gt;alt_text())</a>
<a name="ln753">                    {</a>
<a name="ln754">                        prev_msg_alt_text = m_region_msg-&gt;alt_text();</a>
<a name="ln755">                        set_need_redraw();</a>
<a name="ln756">                    }</a>
<a name="ln757"> </a>
<a name="ln758">                    wm-&gt;remove_timer(m_tooltip_timer_id);</a>
<a name="ln759">                    m_tooltip_timer_id = wm-&gt;set_timer(Options.tile_tooltip_ms, &amp;_timer_callback);</a>
<a name="ln760">                    m_show_tooltip = false;</a>
<a name="ln761">                }</a>
<a name="ln762">               break;</a>
<a name="ln763"> </a>
<a name="ln764">            case WME_MOUSEBUTTONUP:</a>
<a name="ln765">            case WME_MOUSEBUTTONDOWN:</a>
<a name="ln766">                key = handle_mouse(event.mouse_event);</a>
<a name="ln767">                break;</a>
<a name="ln768"> </a>
<a name="ln769">            case WME_QUIT:</a>
<a name="ln770">                crawl_state.seen_hups++;</a>
<a name="ln771">                return ESCAPE;</a>
<a name="ln772"> </a>
<a name="ln773">            case WME_RESIZE:</a>
<a name="ln774">                m_windowsz.x = event.resize.w;</a>
<a name="ln775">                m_windowsz.y = event.resize.h;</a>
<a name="ln776">                resize();</a>
<a name="ln777">                set_need_redraw();</a>
<a name="ln778">                return CK_REDRAW;</a>
<a name="ln779"> </a>
<a name="ln780">            case WME_MOVE:</a>
<a name="ln781">                if (update_dpi())</a>
<a name="ln782">                {</a>
<a name="ln783">                    resize();</a>
<a name="ln784">                    set_need_redraw();</a>
<a name="ln785">                    return CK_REDRAW;</a>
<a name="ln786">                }</a>
<a name="ln787">                // intentional fallthrough</a>
<a name="ln788">            case WME_EXPOSE:</a>
<a name="ln789">                set_need_redraw();</a>
<a name="ln790">                // AFAIK no need to return CK_REDRAW, as resize() hasn't been called</a>
<a name="ln791">                break;</a>
<a name="ln792"> </a>
<a name="ln793">            case WME_CUSTOMEVENT:</a>
<a name="ln794">            default:</a>
<a name="ln795">                // This is only used to refresh the tooltip.</a>
<a name="ln796">                m_show_tooltip = true;</a>
<a name="ln797">                break;</a>
<a name="ln798">            }</a>
<a name="ln799">        }</a>
<a name="ln800"> </a>
<a name="ln801">        if (!mouse_target_mode)</a>
<a name="ln802">        {</a>
<a name="ln803">            if (m_show_tooltip)</a>
<a name="ln804">            {</a>
<a name="ln805">                tiles.clear_text_tags(TAG_CELL_DESC);</a>
<a name="ln806">                if (Options.tile_tooltip_ms &gt; 0 &amp;&amp; m_tooltip.empty())</a>
<a name="ln807">                {</a>
<a name="ln808">                    for (Region *reg : m_layers[m_active_layer].m_regions)</a>
<a name="ln809">                    {</a>
<a name="ln810">                        if (!reg-&gt;inside(m_mouse.x, m_mouse.y))</a>
<a name="ln811">                            continue;</a>
<a name="ln812">                        if (reg-&gt;update_tip_text(m_tooltip))</a>
<a name="ln813">                        {</a>
<a name="ln814">                            set_need_redraw();</a>
<a name="ln815">                            break;</a>
<a name="ln816">                        }</a>
<a name="ln817">                    }</a>
<a name="ln818">                }</a>
<a name="ln819">            }</a>
<a name="ln820">            else</a>
<a name="ln821">            {</a>
<a name="ln822">                if (last_redraw_loc != m_cur_loc)</a>
<a name="ln823">                    set_need_redraw();</a>
<a name="ln824"> </a>
<a name="ln825">                m_tooltip.clear();</a>
<a name="ln826">            }</a>
<a name="ln827"> </a>
<a name="ln828">            if (need_redraw()</a>
<a name="ln829">                || ticks &gt; m_last_tick_redraw</a>
<a name="ln830">                   &amp;&amp; ticks - m_last_tick_redraw &gt; ticks_per_screen_redraw)</a>
<a name="ln831">            {</a>
<a name="ln832">                last_redraw_loc = m_cur_loc;</a>
<a name="ln833">                redraw();</a>
<a name="ln834">            }</a>
<a name="ln835">        }</a>
<a name="ln836">    }</a>
<a name="ln837"> </a>
<a name="ln838">    // We got some input, so we'll probably have to redraw something.</a>
<a name="ln839">    set_need_redraw();</a>
<a name="ln840"> </a>
<a name="ln841">    return key;</a>
<a name="ln842">}</a>
<a name="ln843"> </a>
<a name="ln844">static const int map_margin      = 2;</a>
<a name="ln845">static const int map_stat_margin = 4;</a>
<a name="ln846">static const int min_stat_height = 12;</a>
<a name="ln847">static const int min_inv_height  = 4;</a>
<a name="ln848">static const int max_inv_height  = 6;</a>
<a name="ln849">static const int max_mon_height  = 3;</a>
<a name="ln850"> </a>
<a name="ln851">// Width of status area in characters.</a>
<a name="ln852">static const int stat_width      = 42;</a>
<a name="ln853"> </a>
<a name="ln854">static int round_up_to_multiple(int a, int b)</a>
<a name="ln855">{</a>
<a name="ln856">    int m = a % b;</a>
<a name="ln857">    return m == 0 ? a : a + b-m;</a>
<a name="ln858">}</a>
<a name="ln859"> </a>
<a name="ln860">/**</a>
<a name="ln861"> * Calculates and sets the layout of the main game screen, based on the</a>
<a name="ln862"> * available screen estate (window or screensize) and options.</a>
<a name="ln863"> */</a>
<a name="ln864">void TilesFramework::do_layout()</a>
<a name="ln865">{</a>
<a name="ln866">    /**</a>
<a name="ln867">     * XXX: don't layout unless we're in a game / arena</a>
<a name="ln868">     * this is to prevent layout code from accessing `you` while it's invalid.</a>
<a name="ln869">     */</a>
<a name="ln870">    if (!species_type_valid(you.species))</a>
<a name="ln871">    {</a>
<a name="ln872">        /* HACK: some code called while loading the game calls mprf(), so even</a>
<a name="ln873">         * if we're not ready to do an actual layout, we should still give the</a>
<a name="ln874">         * message region a size, to prevent a crash. */</a>
<a name="ln875">        m_region_msg-&gt;place(0, 0, 0);</a>
<a name="ln876">        m_region_msg-&gt;resize_to_fit(10000, 10000);</a>
<a name="ln877">        return;</a>
<a name="ln878">    }</a>
<a name="ln879"> </a>
<a name="ln880">    // View size in pixels is ((dx, dy) * crawl_view.viewsz)</a>
<a name="ln881">    const int scale = m_map_mode_enabled ? Options.tile_map_scale</a>
<a name="ln882">                                         : Options.tile_viewport_scale;</a>
<a name="ln883">    m_region_tile-&gt;dx = Options.tile_cell_pixels * scale / 100;</a>
<a name="ln884">    m_region_tile-&gt;dy = Options.tile_cell_pixels * scale / 100;</a>
<a name="ln885"> </a>
<a name="ln886">    int message_y_divider = 0;</a>
<a name="ln887">    int sidebar_pw;</a>
<a name="ln888"> </a>
<a name="ln889">    // if the screen estate is very small, or if the option is set, choose</a>
<a name="ln890">    // a layout that is optimal for very small screens</a>
<a name="ln891">    bool use_small_layout = is_using_small_layout();</a>
<a name="ln892">    bool message_overlay = Options.tile_force_overlay ? true : use_small_layout;</a>
<a name="ln893"> </a>
<a name="ln894">    const int min_msg_h =</a>
<a name="ln895">                m_region_msg-&gt;grid_height_to_pixels(Options.msg_min_height);</a>
<a name="ln896">    const int max_tile_h =</a>
<a name="ln897">                m_region_tile-&gt;grid_height_to_pixels(</a>
<a name="ln898">                            max(Options.view_max_height, ENV_SHOW_DIAMETER));</a>
<a name="ln899"> </a>
<a name="ln900">    if (use_small_layout)</a>
<a name="ln901">    {</a>
<a name="ln902">        // for now assuming that width &gt; height:</a>
<a name="ln903">        //   * dungeon view, on left, is full height of screen and square</a>
<a name="ln904">        //   * message area is overlaid on dungeon view</a>
<a name="ln905">        //   * command tabs are scaled to height of screen and put to far right</a>
<a name="ln906">        //   * command boxes are hidden (appear when tabs pressed, covering screen)</a>
<a name="ln907">        //   * stats region squeezed between dungeon and command tabs</a>
<a name="ln908"> </a>
<a name="ln909">        // scale dungeon region to fit *height* of window</a>
<a name="ln910">        int available_height_in_tiles = m_windowsz.y / m_region_tile-&gt;dy;</a>
<a name="ln911">        if (available_height_in_tiles &lt; ENV_SHOW_DIAMETER)</a>
<a name="ln912">        {</a>
<a name="ln913">            m_region_tile-&gt;dy = m_windowsz.y / ENV_SHOW_DIAMETER;</a>
<a name="ln914">            m_region_tile-&gt;dx = m_region_tile-&gt;dy;</a>
<a name="ln915"> </a>
<a name="ln916">            available_height_in_tiles = ENV_SHOW_DIAMETER;</a>
<a name="ln917">        }</a>
<a name="ln918"> </a>
<a name="ln919">        // let's make stats region exactly 9 chars wide, so non 4:3 ratio screens look ok</a>
<a name="ln920">        //  * this sets the tab region width</a>
<a name="ln921">        m_region_tab-&gt;set_small_layout(true, m_windowsz);</a>
<a name="ln922">        m_region_tab-&gt;resize_to_fit(m_windowsz.x, m_windowsz.y);</a>
<a name="ln923">        //  * ox tells us the width of screen obscured by the tabs</a>
<a name="ln924">        sidebar_pw = m_region_tab-&gt;grid_width_to_pixels(m_region_tab-&gt;ox) / 32</a>
<a name="ln925">                        + m_region_stat-&gt;font().max_width(10);</a>
<a name="ln926">        m_stat_x_divider = m_windowsz.x - sidebar_pw;</a>
<a name="ln927">        // old logic, if we're going to impinge upon a nice square dregion</a>
<a name="ln928">        if (m_region_tile-&gt;grid_width_to_pixels(</a>
<a name="ln929">                            available_height_in_tiles) &gt; m_stat_x_divider)</a>
<a name="ln930">        {</a>
<a name="ln931">            m_stat_x_divider =</a>
<a name="ln932">                m_region_tile-&gt;grid_width_to_pixels(available_height_in_tiles);</a>
<a name="ln933">        }</a>
<a name="ln934">        // always overlay message area on dungeon</a>
<a name="ln935">        message_y_divider = m_windowsz.y;</a>
<a name="ln936"> </a>
<a name="ln937">        //printf(&quot;window x = %d; x div = %d; x button = +%d; x dreg = %d; font w = %d; y div = %d\n&quot;,m_windowsz.x,m_stat_x_divider,m_region_tab-&gt;ox,available_height_in_tiles*m_region_tile-&gt;dx,Options.tile_font_stat_size,message_y_divider);</a>
<a name="ln938">        //printf(&quot;m_region_tab dx = %d; ox = %d; wx = %d; sx = %d\n&quot;,m_region_tab-&gt;dx,m_region_tab-&gt;ox,m_region_tab-&gt;wx,m_region_tab-&gt;sx);</a>
<a name="ln939">    }</a>
<a name="ln940">    else</a>
<a name="ln941">    {</a>
<a name="ln942">        // normal layout code</a>
<a name="ln943"> </a>
<a name="ln944">        const int sidebar_min_pw = m_region_stat-&gt;grid_width_to_pixels(</a>
<a name="ln945">                                                                stat_width);</a>
<a name="ln946">        sidebar_pw = m_region_tab-&gt;grid_width_to_pixels(14) - 10;</a>
<a name="ln947">        if (sidebar_pw &gt; m_windowsz.x / 3)</a>
<a name="ln948">            sidebar_pw = m_region_tab-&gt;grid_width_to_pixels(7) - 10;</a>
<a name="ln949">        while (sidebar_pw &lt; sidebar_min_pw)</a>
<a name="ln950">            sidebar_pw += m_region_tab-&gt;grid_width_to_pixels(1);</a>
<a name="ln951"> </a>
<a name="ln952">        // Locations in pixels. stat_x_divider is the dividing vertical line</a>
<a name="ln953">        // between dungeon view on the left and status area on the right.</a>
<a name="ln954">        // message_y_divider is the horizontal line between dungeon view on</a>
<a name="ln955">        // the top and message window at the bottom.</a>
<a name="ln956">        m_stat_x_divider = m_windowsz.x - sidebar_pw - map_stat_margin;</a>
<a name="ln957"> </a>
<a name="ln958">        // Calculate message_y_divider. First off, if we have already decided to</a>
<a name="ln959">        // use the overlay, we can place the divider to the bottom of the screen.</a>
<a name="ln960">        if (message_overlay)</a>
<a name="ln961">            message_y_divider = m_windowsz.y;</a>
<a name="ln962"> </a>
<a name="ln963">        // Then, the optimal situation without the overlay - we can fit both</a>
<a name="ln964">        // Options.view_max_height and at least Options.msg_min_height in the space.</a>
<a name="ln965"> </a>
<a name="ln966">        if (max_tile_h + min_msg_h &lt;= m_windowsz.y &amp;&amp; !message_overlay)</a>
<a name="ln967">        {</a>
<a name="ln968">            message_y_divider = max_tile_h;</a>
<a name="ln969">            message_y_divider = max(message_y_divider, m_windowsz.y -</a>
<a name="ln970">                m_region_msg-&gt;grid_height_to_pixels(Options.msg_max_height));</a>
<a name="ln971">        }</a>
<a name="ln972">        else</a>
<a name="ln973">        {</a>
<a name="ln974">            int available_height_in_tiles = 0;</a>
<a name="ln975">            available_height_in_tiles =</a>
<a name="ln976">                (m_windowsz.y - (message_overlay ? 0 : min_msg_h))</a>
<a name="ln977">                        / m_region_tile-&gt;dy;</a>
<a name="ln978"> </a>
<a name="ln979">            // If we can't fit the full LOS to the available space, try using the</a>
<a name="ln980">            // message overlay.</a>
<a name="ln981">            if (available_height_in_tiles &lt; ENV_SHOW_DIAMETER)</a>
<a name="ln982">            {</a>
<a name="ln983">                message_y_divider = m_windowsz.y;</a>
<a name="ln984">                message_overlay = true;</a>
<a name="ln985"> </a>
<a name="ln986">                // If using message_overlay isn't enough, scale the dungeon region</a>
<a name="ln987">                // tiles to fit full LOS into the available space.</a>
<a name="ln988">                if (m_windowsz.y / m_region_tile-&gt;dy &lt; ENV_SHOW_DIAMETER)</a>
<a name="ln989">                {</a>
<a name="ln990">                    m_region_tile-&gt;dy = m_windowsz.y / ENV_SHOW_DIAMETER;</a>
<a name="ln991">                    m_region_tile-&gt;dx = m_region_tile-&gt;dy;</a>
<a name="ln992">                }</a>
<a name="ln993">            }</a>
<a name="ln994">            else</a>
<a name="ln995">                message_y_divider = m_windowsz.y - min_msg_h;</a>
<a name="ln996">        }</a>
<a name="ln997">    }</a>
<a name="ln998"> </a>
<a name="ln999">    // stick message display to the bottom of the window</a>
<a name="ln1000">    int msg_height = m_windowsz.y-message_y_divider;</a>
<a name="ln1001">    // this is very slightly off on high-dpi displays, but it should be taken</a>
<a name="ln1002">    // care of by resize_to_fit later</a>
<a name="ln1003">    msg_height = msg_height / m_region_msg-&gt;dy * m_region_msg-&gt;dy;</a>
<a name="ln1004">    message_y_divider = m_windowsz.y - msg_height;</a>
<a name="ln1005"> </a>
<a name="ln1006">    // Expand dungeon region to cover partial tiles, then offset to keep player centred</a>
<a name="ln1007">    int tile_iw = m_stat_x_divider;</a>
<a name="ln1008">    int tile_ih = message_y_divider;</a>
<a name="ln1009">    int tile_ow = round_up_to_multiple(tile_iw, m_region_tile-&gt;dx*2) + m_region_tile-&gt;dx;</a>
<a name="ln1010">    int tile_oh = round_up_to_multiple(tile_ih, m_region_tile-&gt;dy*2) + m_region_tile-&gt;dx;</a>
<a name="ln1011">    m_region_tile-&gt;resize_to_fit(tile_ow, tile_oh);</a>
<a name="ln1012">    m_region_tile-&gt;place(-(tile_ow - tile_iw)/2, -(tile_oh - tile_ih)/2, 0);</a>
<a name="ln1013">    m_region_tile-&gt;tile_iw = tile_iw;</a>
<a name="ln1014">    m_region_tile-&gt;tile_ih = tile_ih;</a>
<a name="ln1015"> </a>
<a name="ln1016">    // Resize and place the message window.</a>
<a name="ln1017">    m_region_msg-&gt;set_overlay(message_overlay);</a>
<a name="ln1018">    if (message_overlay)</a>
<a name="ln1019">    {</a>
<a name="ln1020">        m_region_msg-&gt;place(0, 0, 0); // TODO: Maybe add an option to place</a>
<a name="ln1021">                                      // overlay at the bottom.</a>
<a name="ln1022">        m_region_msg-&gt;resize_to_fit(m_stat_x_divider, min_msg_h);</a>
<a name="ln1023">    }</a>
<a name="ln1024">    else</a>
<a name="ln1025">    {</a>
<a name="ln1026">        m_region_msg-&gt;resize_to_fit(m_stat_x_divider, m_windowsz.y</a>
<a name="ln1027">                                    - message_y_divider);</a>
<a name="ln1028">        m_region_msg-&gt;place(0, tile_ih, 0);</a>
<a name="ln1029">    }</a>
<a name="ln1030"> </a>
<a name="ln1031">    if (use_small_layout)</a>
<a name="ln1032">        m_stat_col = m_stat_x_divider;</a>
<a name="ln1033">    else</a>
<a name="ln1034">        m_stat_col = m_stat_x_divider + map_stat_margin;</a>
<a name="ln1035">    m_region_stat-&gt;resize_to_fit(sidebar_pw, m_windowsz.y);</a>
<a name="ln1036">    m_region_stat-&gt;place(m_stat_col, 0, 0);</a>
<a name="ln1037">    m_region_stat-&gt;resize(m_region_stat-&gt;mx, min_stat_height);</a>
<a name="ln1038"> </a>
<a name="ln1039">    layout_statcol();</a>
<a name="ln1040"> </a>
<a name="ln1041">    m_region_crt-&gt;place(0, 0, 0);</a>
<a name="ln1042">    m_region_crt-&gt;resize_to_fit(m_windowsz.x, m_windowsz.y);</a>
<a name="ln1043"> </a>
<a name="ln1044">    crawl_view.viewsz.x = m_region_tile-&gt;mx;</a>
<a name="ln1045">    crawl_view.viewsz.y = m_region_tile-&gt;my;</a>
<a name="ln1046">    crawl_view.msgsz.x = m_region_msg-&gt;mx;</a>
<a name="ln1047">    crawl_view.msgsz.y = m_region_msg-&gt;my;</a>
<a name="ln1048">    crawl_view.hudsz.x = m_region_stat-&gt;mx;</a>
<a name="ln1049">    crawl_view.hudsz.y = m_region_stat-&gt;my;</a>
<a name="ln1050">    crawl_view.init_view();</a>
<a name="ln1051">}</a>
<a name="ln1052"> </a>
<a name="ln1053">bool TilesFramework::is_using_small_layout()</a>
<a name="ln1054">{</a>
<a name="ln1055">    // automatically use small layout at low resolutions if TOUCH_UI enabled,</a>
<a name="ln1056">    // otherwise only if forced to</a>
<a name="ln1057">#ifdef TOUCH_UI</a>
<a name="ln1058">    switch (Options.tile_use_small_layout)</a>
<a name="ln1059">    {</a>
<a name="ln1060">    case MB_TRUE:</a>
<a name="ln1061">        return true;</a>
<a name="ln1062">    case MB_FALSE:</a>
<a name="ln1063">        return false;</a>
<a name="ln1064">    case MB_MAYBE:</a>
<a name="ln1065">    default:</a>
<a name="ln1066">        Options.tile_use_small_layout = (m_windowsz.x&lt;=480) ? MB_TRUE : MB_FALSE;</a>
<a name="ln1067">        return Options.tile_use_small_layout == MB_TRUE;</a>
<a name="ln1068">    }</a>
<a name="ln1069">#else</a>
<a name="ln1070">    return Options.tile_use_small_layout == MB_TRUE;</a>
<a name="ln1071">#endif</a>
<a name="ln1072">}</a>
<a name="ln1073"> </a>
<a name="ln1074">#define ZOOM_INC 10</a>
<a name="ln1075"> </a>
<a name="ln1076">void TilesFramework::zoom_dungeon(bool in)</a>
<a name="ln1077">{</a>
<a name="ln1078">#ifdef TOUCH_UI</a>
<a name="ln1079">    m_region_tile-&gt;zoom(in);</a>
<a name="ln1080">#elif defined(USE_TILE_LOCAL)</a>
<a name="ln1081">    int &amp;current_scale = m_map_mode_enabled ?  Options.tile_map_scale</a>
<a name="ln1082">                                            :  Options.tile_viewport_scale;</a>
<a name="ln1083">    // max zoom relative to to tile size that keeps LOS in view</a>
<a name="ln1084">    int max_zoom = 100 * m_windowsz.y / Options.tile_cell_pixels</a>
<a name="ln1085">                                      / ENV_SHOW_DIAMETER;</a>
<a name="ln1086">    if (max_zoom % ZOOM_INC != 0)</a>
<a name="ln1087">        max_zoom += ZOOM_INC - max_zoom % ZOOM_INC; // round up</a>
<a name="ln1088">    current_scale = min(max_zoom, max(20,</a>
<a name="ln1089">                    current_scale + (in ? ZOOM_INC : -ZOOM_INC)));</a>
<a name="ln1090">    do_layout(); // recalculate the viewport setup</a>
<a name="ln1091">    dprf(&quot;Zooming to %d&quot;, current_scale);</a>
<a name="ln1092">    redraw_screen(false);</a>
<a name="ln1093">#endif</a>
<a name="ln1094">}</a>
<a name="ln1095"> </a>
<a name="ln1096">bool TilesFramework::zoom_to_minimap()</a>
<a name="ln1097">{</a>
<a name="ln1098">    // don't zoom to the minimap if it's already on the screen</a>
<a name="ln1099">    if (m_region_map || !tiles.is_using_small_layout())</a>
<a name="ln1100">        return false;</a>
<a name="ln1101"> </a>
<a name="ln1102">    m_region_map  = new MapRegion(m_map_pixels);</a>
<a name="ln1103">    m_region_map-&gt;dx = m_region_map-&gt;dy = min((m_windowsz.x-2*map_margin)/GXM,(m_windowsz.y-2*map_margin)/GYM);</a>
<a name="ln1104">    m_region_map-&gt;resize(GXM, GYM);</a>
<a name="ln1105">    m_region_map-&gt;place(0, 0, map_margin);</a>
<a name="ln1106">    // put the minimap at the beginning so that menus get drawn over it</a>
<a name="ln1107">    m_layers[LAYER_NORMAL].m_regions.insert(m_layers[LAYER_NORMAL].m_regions.begin(),m_region_map);</a>
<a name="ln1108"> </a>
<a name="ln1109">    // move the dregion out of the way</a>
<a name="ln1110">    m_region_tile-&gt;place(m_region_tile-&gt;sx,m_windowsz.y,0);</a>
<a name="ln1111"> </a>
<a name="ln1112">    set_need_redraw();</a>
<a name="ln1113"> </a>
<a name="ln1114">    // force the minimap to be redrawn properly</a>
<a name="ln1115">    //  - not sure why this is necessary :(</a>
<a name="ln1116">    clear_map();</a>
<a name="ln1117"> </a>
<a name="ln1118">    // force UI into map mode</a>
<a name="ln1119">//    set_map_display(true);</a>
<a name="ln1120">//    process_command(CMD_DISPLAY_MAP);</a>
<a name="ln1121">    return true;</a>
<a name="ln1122">}</a>
<a name="ln1123"> </a>
<a name="ln1124">bool TilesFramework::zoom_from_minimap()</a>
<a name="ln1125">{</a>
<a name="ln1126">    // don't try to zap the overlaid minimap twice</a>
<a name="ln1127">    if (!m_region_map || !tiles.is_using_small_layout())</a>
<a name="ln1128">        return false;</a>
<a name="ln1129">    delete m_region_map;</a>
<a name="ln1130">    m_region_map = nullptr;</a>
<a name="ln1131"> </a>
<a name="ln1132">    // remove minimap from layers again (was at top of vector)</a>
<a name="ln1133">    m_layers[LAYER_NORMAL].m_regions.erase(m_layers[LAYER_NORMAL].m_regions.begin());</a>
<a name="ln1134"> </a>
<a name="ln1135">    // take UI out of map mode again</a>
<a name="ln1136">//    set_map_display(false);</a>
<a name="ln1137"> </a>
<a name="ln1138">    // put the dregion back (not at 0,0 because we scaled it!)</a>
<a name="ln1139">    // NB. this assumes that we can work out sy again based on the ratio of wx to wy :O</a>
<a name="ln1140">    m_region_tile-&gt;place(m_region_tile-&gt;sx,m_region_tile-&gt;sx*m_region_tile-&gt;wy/m_region_tile-&gt;wx,0);</a>
<a name="ln1141"> </a>
<a name="ln1142">    set_need_redraw();</a>
<a name="ln1143">    return true;</a>
<a name="ln1144">}</a>
<a name="ln1145"> </a>
<a name="ln1146">void TilesFramework::deactivate_tab()</a>
<a name="ln1147">{</a>
<a name="ln1148">    m_region_tab-&gt;deactivate_tab();</a>
<a name="ln1149">}</a>
<a name="ln1150"> </a>
<a name="ln1151">void TilesFramework::autosize_minimap()</a>
<a name="ln1152">{</a>
<a name="ln1153">    const int horiz = (m_windowsz.x - m_stat_col - map_margin * 2) / GXM;</a>
<a name="ln1154">    const int vert = (m_statcol_bottom - (m_region_map-&gt;sy ? m_region_map-&gt;sy</a>
<a name="ln1155">                                                           : m_statcol_top)</a>
<a name="ln1156">                     - map_margin * 2) / GYM;</a>
<a name="ln1157"> </a>
<a name="ln1158">    int sz = min(horiz, vert);</a>
<a name="ln1159">    if (Options.tile_map_pixels)</a>
<a name="ln1160">        sz = min(sz, Options.tile_map_pixels);</a>
<a name="ln1161">    m_region_map-&gt;dx = m_region_map-&gt;dy = sz;</a>
<a name="ln1162">}</a>
<a name="ln1163"> </a>
<a name="ln1164">void TilesFramework::place_minimap()</a>
<a name="ln1165">{</a>
<a name="ln1166">    m_region_map  = new MapRegion(m_map_pixels);</a>
<a name="ln1167"> </a>
<a name="ln1168">    if (GXM * m_region_map-&gt;dx &gt; m_windowsz.x - m_stat_col)</a>
<a name="ln1169">        autosize_minimap();</a>
<a name="ln1170"> </a>
<a name="ln1171">    m_region_map-&gt;resize(GXM, GYM);</a>
<a name="ln1172">    if (m_region_map-&gt;dy * GYM &gt; m_statcol_bottom - m_statcol_top)</a>
<a name="ln1173">    {</a>
<a name="ln1174">        delete m_region_map;</a>
<a name="ln1175">        m_region_map = nullptr;</a>
<a name="ln1176">        return;</a>
<a name="ln1177">    }</a>
<a name="ln1178"> </a>
<a name="ln1179">    m_layers[LAYER_NORMAL].m_regions.push_back(m_region_map);</a>
<a name="ln1180">    m_region_map-&gt;place(m_stat_col, m_region_stat-&gt;ey, map_margin);</a>
<a name="ln1181"> </a>
<a name="ln1182">    m_statcol_top = m_region_map-&gt;ey;</a>
<a name="ln1183">}</a>
<a name="ln1184"> </a>
<a name="ln1185">int TilesFramework::calc_tab_lines(const int num_elements)</a>
<a name="ln1186">{</a>
<a name="ln1187">    // Integer division rounded up</a>
<a name="ln1188">    return (num_elements - 1) / m_region_tab-&gt;mx + 1;</a>
<a name="ln1189">}</a>
<a name="ln1190"> </a>
<a name="ln1191">void TilesFramework::place_tab(int idx)</a>
<a name="ln1192">{</a>
<a name="ln1193">    if (idx == -1)</a>
<a name="ln1194">        return;</a>
<a name="ln1195"> </a>
<a name="ln1196">    int min_ln = 1, max_ln = 1;</a>
<a name="ln1197">    if (idx == TAB_SPELL)</a>
<a name="ln1198">    {</a>
<a name="ln1199">        if (you.spell_no == 0)</a>
<a name="ln1200">        {</a>
<a name="ln1201">            m_region_tab-&gt;enable_tab(TAB_SPELL);</a>
<a name="ln1202">            return;</a>
<a name="ln1203">        }</a>
<a name="ln1204">        max_ln = calc_tab_lines(you.spell_no);</a>
<a name="ln1205">    }</a>
<a name="ln1206">    else if (idx == TAB_ABILITY)</a>
<a name="ln1207">    {</a>
<a name="ln1208">        unsigned int talents = your_talents(false).size();</a>
<a name="ln1209">        if (talents == 0)</a>
<a name="ln1210">        {</a>
<a name="ln1211">            m_region_tab-&gt;enable_tab(TAB_ABILITY);</a>
<a name="ln1212">            return;</a>
<a name="ln1213">        }</a>
<a name="ln1214">        max_ln = calc_tab_lines(talents);</a>
<a name="ln1215">    }</a>
<a name="ln1216">    else if (idx == TAB_MONSTER)</a>
<a name="ln1217">        max_ln = max_mon_height;</a>
<a name="ln1218">    else if (idx == TAB_COMMAND)</a>
<a name="ln1219">        min_ln = max_ln = calc_tab_lines(m_region_cmd-&gt;n_common_commands);</a>
<a name="ln1220">    else if (idx == TAB_COMMAND2)</a>
<a name="ln1221">        min_ln = max_ln = calc_tab_lines(m_region_cmd_meta-&gt;n_common_commands);</a>
<a name="ln1222">    else if (idx == TAB_NAVIGATION)</a>
<a name="ln1223">        min_ln = max_ln = calc_tab_lines(m_region_cmd_map-&gt;n_common_commands);</a>
<a name="ln1224">    else if (idx == TAB_SKILL)</a>
<a name="ln1225">        min_ln = max_ln = calc_tab_lines(NUM_SKILLS);</a>
<a name="ln1226"> </a>
<a name="ln1227">    int lines = min(max_ln, (m_statcol_bottom - m_statcol_top - m_tab_margin)</a>
<a name="ln1228">                            / m_region_tab-&gt;dy);</a>
<a name="ln1229">    if (lines &gt;= min_ln)</a>
<a name="ln1230">    {</a>
<a name="ln1231">        TabbedRegion* region_tab = new TabbedRegion(m_init);</a>
<a name="ln1232">        region_tab-&gt;push_tab_region(m_region_tab-&gt;get_tab_region(idx),</a>
<a name="ln1233">                                    m_region_tab-&gt;get_tab_tile(idx));</a>
<a name="ln1234">        m_tabs[idx] = region_tab;</a>
<a name="ln1235">        region_tab-&gt;activate_tab(0);</a>
<a name="ln1236">        m_region_tab-&gt;disable_tab(idx);</a>
<a name="ln1237">        m_layers[LAYER_NORMAL].m_regions.push_back(region_tab);</a>
<a name="ln1238">        region_tab-&gt;place(m_stat_col, m_statcol_bottom</a>
<a name="ln1239">                                     - lines * m_region_tab-&gt;dy);</a>
<a name="ln1240">        region_tab-&gt;resize(m_region_tab-&gt;mx, lines);</a>
<a name="ln1241">        m_statcol_bottom = region_tab-&gt;sy - m_tab_margin;</a>
<a name="ln1242">    }</a>
<a name="ln1243">    else</a>
<a name="ln1244">        m_region_tab-&gt;enable_tab(idx);</a>
<a name="ln1245">}</a>
<a name="ln1246"> </a>
<a name="ln1247">void TilesFramework::resize_inventory()</a>
<a name="ln1248">{</a>
<a name="ln1249">    int lines = min(max_inv_height - min_inv_height,</a>
<a name="ln1250">                    (m_statcol_bottom - m_statcol_top) / m_region_tab-&gt;dy);</a>
<a name="ln1251"> </a>
<a name="ln1252">    int prev_size = m_region_tab-&gt;wy;</a>
<a name="ln1253"> </a>
<a name="ln1254">    int tabs_height = m_region_tab-&gt;min_height_for_items();</a>
<a name="ln1255">    tabs_height = round_up_to_multiple(tabs_height, m_region_tab-&gt;dx)/m_region_tab-&gt;dx;</a>
<a name="ln1256"> </a>
<a name="ln1257">    m_region_tab-&gt;resize(m_region_tab-&gt;mx, max(min_inv_height + lines, tabs_height));</a>
<a name="ln1258">    m_region_tab-&gt;place(m_stat_col, m_windowsz.y - m_region_tab-&gt;wy);</a>
<a name="ln1259"> </a>
<a name="ln1260">    int delta_y = m_region_tab-&gt;wy - prev_size;</a>
<a name="ln1261">    for (tab_iterator it = m_tabs.begin(); it != m_tabs.end(); ++it)</a>
<a name="ln1262">        it-&gt;second-&gt;place(it-&gt;second-&gt;sx, it-&gt;second-&gt;sy - delta_y);</a>
<a name="ln1263"> </a>
<a name="ln1264">    m_statcol_bottom -= delta_y;</a>
<a name="ln1265">}</a>
<a name="ln1266"> </a>
<a name="ln1267">void TilesFramework::layout_statcol()</a>
<a name="ln1268">{</a>
<a name="ln1269">    bool use_small_layout = is_using_small_layout();</a>
<a name="ln1270"> </a>
<a name="ln1271">    for (tab_iterator it = m_tabs.begin(); it != m_tabs.end(); ++it)</a>
<a name="ln1272">    {</a>
<a name="ln1273">        delete it-&gt;second;</a>
<a name="ln1274">        m_layers[LAYER_NORMAL].m_regions.pop_back();</a>
<a name="ln1275">    }</a>
<a name="ln1276">    m_tabs.clear();</a>
<a name="ln1277"> </a>
<a name="ln1278">    if (m_region_map)</a>
<a name="ln1279">    {</a>
<a name="ln1280">        delete m_region_map;</a>
<a name="ln1281">        m_region_map = nullptr;</a>
<a name="ln1282">        m_layers[LAYER_NORMAL].m_regions.pop_back();</a>
<a name="ln1283">    }</a>
<a name="ln1284"> </a>
<a name="ln1285">    if (use_small_layout)</a>
<a name="ln1286">    {</a>
<a name="ln1287">        // * commands will be on right as tabs</a>
<a name="ln1288">        // * stats will be squeezed in gap between dungeon and commands</a>
<a name="ln1289">        m_statcol_top = 0;</a>
<a name="ln1290">        m_statcol_bottom = m_windowsz.y;</a>
<a name="ln1291"> </a>
<a name="ln1292">        // place tabs (covering whole screen)</a>
<a name="ln1293">        m_region_tab-&gt;set_small_layout(true, m_windowsz);</a>
<a name="ln1294">        m_region_tab-&gt;resize_to_fit(m_windowsz.x, m_windowsz.y);</a>
<a name="ln1295"> </a>
<a name="ln1296">        // place tabs waay to the right (all offsets will be negative)</a>
<a name="ln1297">        m_region_tab-&gt;place(m_windowsz.x-m_region_tab-&gt;ox, 0);</a>
<a name="ln1298"> </a>
<a name="ln1299">        // close any open tab</a>
<a name="ln1300">        m_region_tab-&gt;deactivate_tab();</a>
<a name="ln1301"> </a>
<a name="ln1302">        // resize stats to be up to beginning of command tabs</a>
<a name="ln1303">        //  ... this works because the margin (ox) on m_region_tab contains the tabs themselves</a>
<a name="ln1304">        m_region_stat-&gt;resize_to_fit((m_windowsz.x - m_stat_x_divider) - m_region_tab-&gt;ox*m_region_tab-&gt;dx/32, m_statcol_bottom-m_statcol_top);</a>
<a name="ln1305">    }</a>
<a name="ln1306">    else</a>
<a name="ln1307">    {</a>
<a name="ln1308">        m_region_stat-&gt;resize(m_region_stat-&gt;mx, min_stat_height);</a>
<a name="ln1309"> </a>
<a name="ln1310">        m_statcol_top = m_region_stat-&gt;ey;</a>
<a name="ln1311"> </a>
<a name="ln1312">        // Set the inventory region to minimal size.</a>
<a name="ln1313">        m_region_tab-&gt;set_small_layout(false, m_windowsz);</a>
<a name="ln1314">        m_region_tab-&gt;place(m_stat_col, m_statcol_top);</a>
<a name="ln1315">        m_region_tab-&gt;resize_to_fit(m_windowsz.x - m_region_tab-&gt;sx,</a>
<a name="ln1316">                                    m_windowsz.y - m_region_tab-&gt;sy);</a>
<a name="ln1317">        // region extends ~1/2-tile beyond window (rendered area touches right edge)</a>
<a name="ln1318">        m_region_tab-&gt;resize(m_region_tab-&gt;mx+1, min_inv_height);</a>
<a name="ln1319">        m_region_tab-&gt;place(m_stat_col, m_windowsz.y - m_region_tab-&gt;wy);</a>
<a name="ln1320">        m_statcol_bottom = m_region_tab-&gt;sy - m_tab_margin;</a>
<a name="ln1321"> </a>
<a name="ln1322">        m_region_stat-&gt;resize(m_region_stat-&gt;mx, min_stat_height);</a>
<a name="ln1323">        m_statcol_top += m_region_stat-&gt;dy;</a>
<a name="ln1324">        bool resized_inventory = false;</a>
<a name="ln1325"> </a>
<a name="ln1326">        for (const string &amp;str : Options.tile_layout_priority)</a>
<a name="ln1327">        {</a>
<a name="ln1328">            if (str == &quot;inventory&quot;)</a>
<a name="ln1329">            {</a>
<a name="ln1330">                resize_inventory();</a>
<a name="ln1331">                resized_inventory = true;</a>
<a name="ln1332">            }</a>
<a name="ln1333">            else if (str == &quot;minimap&quot; || str == &quot;map&quot;)</a>
<a name="ln1334">            {</a>
<a name="ln1335">                if (!resized_inventory)</a>
<a name="ln1336">                {</a>
<a name="ln1337">                    resize_inventory();</a>
<a name="ln1338">                    resized_inventory = true;</a>
<a name="ln1339">                }</a>
<a name="ln1340">                place_minimap();</a>
<a name="ln1341">            }</a>
<a name="ln1342">            else if (!(str == &quot;gold_turn&quot; || str == &quot;gold_turns&quot;)) // gold_turns no longer does anything</a>
<a name="ln1343">                place_tab(m_region_tab-&gt;find_tab(str));</a>
<a name="ln1344">        }</a>
<a name="ln1345">        // We stretch the minimap so it is centered in the space left.</a>
<a name="ln1346">        if (m_region_map)</a>
<a name="ln1347">        {</a>
<a name="ln1348">            autosize_minimap();</a>
<a name="ln1349"> </a>
<a name="ln1350">            m_region_map-&gt;place(m_region_stat-&gt;sx, m_region_stat-&gt;ey,</a>
<a name="ln1351">                                m_region_stat-&gt;ex, m_statcol_bottom,</a>
<a name="ln1352">                                map_margin);</a>
<a name="ln1353">            tile_new_level(false, false);</a>
<a name="ln1354">        }</a>
<a name="ln1355">    }</a>
<a name="ln1356">}</a>
<a name="ln1357"> </a>
<a name="ln1358">void TilesFramework::clrscr()</a>
<a name="ln1359">{</a>
<a name="ln1360">    TextRegion::cursor_region = nullptr;</a>
<a name="ln1361"> </a>
<a name="ln1362">    if (m_region_stat)</a>
<a name="ln1363">        m_region_stat-&gt;clear();</a>
<a name="ln1364">    if (m_region_msg)</a>
<a name="ln1365">        m_region_msg-&gt;clear();</a>
<a name="ln1366">    if (m_region_crt)</a>
<a name="ln1367">        m_region_crt-&gt;clear();</a>
<a name="ln1368"> </a>
<a name="ln1369">    cgotoxy(1,1);</a>
<a name="ln1370"> </a>
<a name="ln1371">    set_need_redraw();</a>
<a name="ln1372">}</a>
<a name="ln1373"> </a>
<a name="ln1374">int TilesFramework::get_number_of_lines()</a>
<a name="ln1375">{</a>
<a name="ln1376">    return m_region_crt-&gt;my;</a>
<a name="ln1377">}</a>
<a name="ln1378"> </a>
<a name="ln1379">int TilesFramework::get_number_of_cols()</a>
<a name="ln1380">{</a>
<a name="ln1381">    switch (m_active_layer)</a>
<a name="ln1382">    {</a>
<a name="ln1383">    default:</a>
<a name="ln1384">        return 0;</a>
<a name="ln1385">    case LAYER_NORMAL:</a>
<a name="ln1386">        return m_region_msg-&gt;mx;</a>
<a name="ln1387">    case LAYER_CRT:</a>
<a name="ln1388">        return m_region_crt-&gt;mx;</a>
<a name="ln1389">    }</a>
<a name="ln1390">}</a>
<a name="ln1391"> </a>
<a name="ln1392">void TilesFramework::cgotoxy(int x, int y, GotoRegion region)</a>
<a name="ln1393">{</a>
<a name="ln1394">    set_cursor_region(region);</a>
<a name="ln1395">    TextRegion::cgotoxy(x, y);</a>
<a name="ln1396">}</a>
<a name="ln1397"> </a>
<a name="ln1398">GotoRegion TilesFramework::get_cursor_region() const</a>
<a name="ln1399">{</a>
<a name="ln1400">    if (TextRegion::text_mode == m_region_crt)</a>
<a name="ln1401">        return GOTO_CRT;</a>
<a name="ln1402">    if (TextRegion::text_mode == m_region_msg)</a>
<a name="ln1403">        return GOTO_MSG;</a>
<a name="ln1404">    if (TextRegion::text_mode == m_region_stat)</a>
<a name="ln1405">        return GOTO_STAT;</a>
<a name="ln1406"> </a>
<a name="ln1407">    die(&quot;Bogus region&quot;);</a>
<a name="ln1408">    return GOTO_CRT;</a>
<a name="ln1409">}</a>
<a name="ln1410"> </a>
<a name="ln1411">void TilesFramework::set_cursor_region(GotoRegion region)</a>
<a name="ln1412">{</a>
<a name="ln1413">    switch (region)</a>
<a name="ln1414">    {</a>
<a name="ln1415">    case GOTO_CRT:</a>
<a name="ln1416">        m_active_layer = LAYER_CRT;</a>
<a name="ln1417">        TextRegion::text_mode = m_region_crt;</a>
<a name="ln1418">        break;</a>
<a name="ln1419">    case GOTO_MSG:</a>
<a name="ln1420">        m_active_layer = LAYER_NORMAL;</a>
<a name="ln1421">        TextRegion::text_mode = m_region_msg;</a>
<a name="ln1422">        break;</a>
<a name="ln1423">    case GOTO_STAT:</a>
<a name="ln1424">        m_active_layer = LAYER_NORMAL;</a>
<a name="ln1425">        TextRegion::text_mode = m_region_stat;</a>
<a name="ln1426">        break;</a>
<a name="ln1427">    default:</a>
<a name="ln1428">        die(&quot;invalid cgotoxy region in tiles: %d&quot;, region);</a>
<a name="ln1429">        break;</a>
<a name="ln1430">    }</a>
<a name="ln1431">}</a>
<a name="ln1432"> </a>
<a name="ln1433">// #define DEBUG_TILES_REDRAW</a>
<a name="ln1434">void TilesFramework::redraw()</a>
<a name="ln1435">{</a>
<a name="ln1436">#ifdef DEBUG_TILES_REDRAW</a>
<a name="ln1437">    cprintf(&quot;\nredrawing tiles&quot;);</a>
<a name="ln1438">#endif</a>
<a name="ln1439">    m_need_redraw = false;</a>
<a name="ln1440"> </a>
<a name="ln1441">    glmanager-&gt;reset_view_for_redraw();</a>
<a name="ln1442"> </a>
<a name="ln1443">    for (Region *region : m_layers[m_active_layer].m_regions)</a>
<a name="ln1444">        region-&gt;render();</a>
<a name="ln1445"> </a>
<a name="ln1446">    // Draw tooltip</a>
<a name="ln1447">    if (Options.tile_tooltip_ms &gt; 0 &amp;&amp; !m_tooltip.empty())</a>
<a name="ln1448">    {</a>
<a name="ln1449">        const int buffer = 5;</a>
<a name="ln1450">        const coord_def min_pos = coord_def() + buffer;</a>
<a name="ln1451">        const coord_def max_pos = m_windowsz - buffer;</a>
<a name="ln1452">        m_tip_font-&gt;render_tooltip(m_mouse.x, m_mouse.y,</a>
<a name="ln1453">                formatted_string(m_tooltip), min_pos, max_pos);</a>
<a name="ln1454">    }</a>
<a name="ln1455">    wm-&gt;swap_buffers();</a>
<a name="ln1456"> </a>
<a name="ln1457">#ifdef __ANDROID__</a>
<a name="ln1458">    glmanager-&gt;fixup_gl_state();</a>
<a name="ln1459">#endif</a>
<a name="ln1460"> </a>
<a name="ln1461">    m_last_tick_redraw = wm-&gt;get_ticks();</a>
<a name="ln1462">}</a>
<a name="ln1463"> </a>
<a name="ln1464">void TilesFramework::render_current_regions()</a>
<a name="ln1465">{</a>
<a name="ln1466">    // need to call with show_updates=false, which is passed to viewwindow</a>
<a name="ln1467">    if (m_active_layer == LAYER_NORMAL &amp;&amp; !crawl_state.game_is_arena())</a>
<a name="ln1468">        redraw_screen(false);</a>
<a name="ln1469"> </a>
<a name="ln1470">    for (Region *region : m_layers[m_active_layer].m_regions)</a>
<a name="ln1471">        region-&gt;render();</a>
<a name="ln1472">}</a>
<a name="ln1473"> </a>
<a name="ln1474">void TilesFramework::update_minimap(const coord_def&amp; gc)</a>
<a name="ln1475">{</a>
<a name="ln1476">    if (!m_region_map || !map_bounds(gc))</a>
<a name="ln1477">        return;</a>
<a name="ln1478"> </a>
<a name="ln1479">    map_feature mf;</a>
<a name="ln1480"> </a>
<a name="ln1481">    if (!crawl_state.game_is_arena() &amp;&amp; gc == you.pos() &amp;&amp; you.on_current_level)</a>
<a name="ln1482">        mf = MF_PLAYER;</a>
<a name="ln1483">    else</a>
<a name="ln1484">        mf = get_cell_map_feature(gc);</a>
<a name="ln1485"> </a>
<a name="ln1486">    // XXX: map_cell show have exclusion info</a>
<a name="ln1487">    if (mf == MF_FLOOR || mf == MF_MAP_FLOOR || mf == MF_WATER</a>
<a name="ln1488">        || mf == MF_DEEP_WATER || mf == MF_LAVA)</a>
<a name="ln1489">    {</a>
<a name="ln1490">        if (is_exclude_root(gc))</a>
<a name="ln1491">            mf = MF_EXCL_ROOT;</a>
<a name="ln1492">        else if (is_excluded(gc))</a>
<a name="ln1493">            mf = MF_EXCL;</a>
<a name="ln1494">    }</a>
<a name="ln1495"> </a>
<a name="ln1496">    m_region_map-&gt;set(gc, mf);</a>
<a name="ln1497">}</a>
<a name="ln1498"> </a>
<a name="ln1499">void TilesFramework::clear_minimap()</a>
<a name="ln1500">{</a>
<a name="ln1501">    if (m_region_map)</a>
<a name="ln1502">        m_region_map-&gt;clear();</a>
<a name="ln1503">}</a>
<a name="ln1504"> </a>
<a name="ln1505">void TilesFramework::update_minimap_bounds()</a>
<a name="ln1506">{</a>
<a name="ln1507">    if (m_region_map)</a>
<a name="ln1508">        m_region_map-&gt;update_bounds();</a>
<a name="ln1509">}</a>
<a name="ln1510"> </a>
<a name="ln1511">void TilesFramework::update_tabs()</a>
<a name="ln1512">{</a>
<a name="ln1513">    if (Options.tile_show_items.empty() || crawl_state.game_is_arena())</a>
<a name="ln1514">        return;</a>
<a name="ln1515"> </a>
<a name="ln1516">    m_region_tab-&gt;update();</a>
<a name="ln1517">    for (tab_iterator it = m_tabs.begin(); it != m_tabs.end(); ++it)</a>
<a name="ln1518">        it-&gt;second-&gt;update();</a>
<a name="ln1519">}</a>
<a name="ln1520"> </a>
<a name="ln1521">void TilesFramework::toggle_inventory_display()</a>
<a name="ln1522">{</a>
<a name="ln1523">    int idx = m_region_tab-&gt;active_tab();</a>
<a name="ln1524">    m_region_tab-&gt;activate_tab((idx + 1) % m_region_tab-&gt;num_tabs());</a>
<a name="ln1525">}</a>
<a name="ln1526"> </a>
<a name="ln1527">void TilesFramework::place_cursor(cursor_type type, const coord_def &amp;gc)</a>
<a name="ln1528">{</a>
<a name="ln1529">    m_region_tile-&gt;place_cursor(type, gc);</a>
<a name="ln1530">}</a>
<a name="ln1531"> </a>
<a name="ln1532">void TilesFramework::clear_text_tags(text_tag_type type)</a>
<a name="ln1533">{</a>
<a name="ln1534">    m_region_tile-&gt;clear_text_tags(type);</a>
<a name="ln1535">}</a>
<a name="ln1536"> </a>
<a name="ln1537">void TilesFramework::add_text_tag(text_tag_type type, const string &amp;tag,</a>
<a name="ln1538">                                  const coord_def &amp;gc)</a>
<a name="ln1539">{</a>
<a name="ln1540">    m_region_tile-&gt;add_text_tag(type, tag, gc);</a>
<a name="ln1541">}</a>
<a name="ln1542"> </a>
<a name="ln1543">void TilesFramework::add_text_tag(text_tag_type /*type*/, const monster_info&amp; mon)</a>
<a name="ln1544">{</a>
<a name="ln1545">    // HACK. Large-tile monsters don't interact well with name tags.</a>
<a name="ln1546">    if (mons_class_flag(mon.type, M_TALL_TILE)</a>
<a name="ln1547">        || mons_class_flag(mon.base_type, M_TALL_TILE)</a>
<a name="ln1548">        || mon.mb[MB_NO_NAME_TAG])</a>
<a name="ln1549">    {</a>
<a name="ln1550">        return;</a>
<a name="ln1551">    }</a>
<a name="ln1552"> </a>
<a name="ln1553">    const coord_def &amp;gc = mon.pos;</a>
<a name="ln1554"> </a>
<a name="ln1555">    if (mons_is_pghost(mon.type))</a>
<a name="ln1556">    {</a>
<a name="ln1557">        // Beautification hack. &quot;Foo's ghost&quot; is a little bit</a>
<a name="ln1558">        // verbose as a tag. &quot;Foo&quot; on its own should be sufficient.</a>
<a name="ln1559">        tiles.add_text_tag(TAG_NAMED_MONSTER, mon.mname, gc);</a>
<a name="ln1560">    }</a>
<a name="ln1561">    else</a>
<a name="ln1562">        tiles.add_text_tag(TAG_NAMED_MONSTER, mon.proper_name(DESC_PLAIN), gc);</a>
<a name="ln1563">}</a>
<a name="ln1564"> </a>
<a name="ln1565">const coord_def &amp;TilesFramework::get_cursor() const</a>
<a name="ln1566">{</a>
<a name="ln1567">    return m_region_tile-&gt;get_cursor();</a>
<a name="ln1568">}</a>
<a name="ln1569"> </a>
<a name="ln1570">void TilesFramework::add_overlay(const coord_def &amp;gc, tileidx_t idx)</a>
<a name="ln1571">{</a>
<a name="ln1572">    m_region_tile-&gt;add_overlay(gc, idx);</a>
<a name="ln1573">}</a>
<a name="ln1574"> </a>
<a name="ln1575">void TilesFramework::clear_overlays()</a>
<a name="ln1576">{</a>
<a name="ln1577">    m_region_tile-&gt;clear_overlays();</a>
<a name="ln1578">}</a>
<a name="ln1579"> </a>
<a name="ln1580">void TilesFramework::set_need_redraw(unsigned int min_tick_delay)</a>
<a name="ln1581">{</a>
<a name="ln1582">    unsigned int ticks = (wm-&gt;get_ticks() - m_last_tick_redraw);</a>
<a name="ln1583">    if (min_tick_delay &amp;&amp; ticks &lt;= min_tick_delay)</a>
<a name="ln1584">        return;</a>
<a name="ln1585"> </a>
<a name="ln1586">    m_need_redraw = true;</a>
<a name="ln1587">}</a>
<a name="ln1588"> </a>
<a name="ln1589">bool TilesFramework::need_redraw() const</a>
<a name="ln1590">{</a>
<a name="ln1591">    return m_need_redraw;</a>
<a name="ln1592">}</a>
<a name="ln1593"> </a>
<a name="ln1594">int TilesFramework::to_lines(int num_tiles, int tile_height)</a>
<a name="ln1595">{</a>
<a name="ln1596">    return num_tiles * tile_height / get_crt_font()-&gt;char_height();</a>
<a name="ln1597">}</a>
<a name="ln1598">#endif</a>

</code></pre>
<div class="balloon" rel="829"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v648/" target="_blank">V648</a> Priority of the '&&' operation is higher than that of the '||' operation.</p></div>
<div class="balloon" rel="173"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v773/" target="_blank">V773</a> The 'm_image' pointer was not released in destructor. A memory leak is possible.</p></div>

<link rel="stylesheet" href="highlight.css">
<script src="highlight.pack.js"></script>
<script src="highlightjs-line-numbers.js"></script>
<script>hljs.initHighlightingOnLoad();</script>
<script>hljs.initLineNumbersOnLoad();</script>
<script>
  $(document).ready(function() {
      $('.balloon').each(function () {
          var bl = $(this);
          var line = bl.attr('rel');
          var text = $('a[name="ln'+line+'"]').text();

          var space_count = 0;
          for(var i = 0; i<text.length; i++){
              var char = text[i];
              if((char !== ' ')&&(char !== '\t'))break;
              if(char === '\t')space_count++;
              space_count++;
          }

          bl.css('margin-left', space_count*8);
          $('a[name="ln'+line+'"]').after(bl);
      });

      window.location = window.location;
  });
</script>
</body>
</html>
