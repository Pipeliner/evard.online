
<html>
<head>

  <meta http-equiv="Content-Type" content="text/html; charset=US-ASCII" />
  <title>evoke.cc</title>

  <link rel="stylesheet" href="../style.css"/>
  <script src="../jquery-3.2.1.min.js"></script>
</head>
<body>

<pre><code class = "cpp">
<a name="ln1">/**</a>
<a name="ln2"> * @file</a>
<a name="ln3"> * @brief Functions for using some of the wackier inventory items.</a>
<a name="ln4">**/</a>
<a name="ln5"> </a>
<a name="ln6">#include &quot;AppHdr.h&quot;</a>
<a name="ln7"> </a>
<a name="ln8">#include &quot;evoke.h&quot;</a>
<a name="ln9"> </a>
<a name="ln10">#include &lt;algorithm&gt;</a>
<a name="ln11">#include &lt;cmath&gt;</a>
<a name="ln12">#include &lt;cstdlib&gt;</a>
<a name="ln13">#include &lt;cstring&gt;</a>
<a name="ln14"> </a>
<a name="ln15">#include &quot;act-iter.h&quot;</a>
<a name="ln16">#include &quot;areas.h&quot;</a>
<a name="ln17">#include &quot;artefact.h&quot;</a>
<a name="ln18">#include &quot;branch.h&quot;</a>
<a name="ln19">#include &quot;chardump.h&quot;</a>
<a name="ln20">#include &quot;cloud.h&quot;</a>
<a name="ln21">#include &quot;coordit.h&quot;</a>
<a name="ln22">#include &quot;delay.h&quot;</a>
<a name="ln23">#include &quot;directn.h&quot;</a>
<a name="ln24">#include &quot;dungeon.h&quot;</a>
<a name="ln25">#include &quot;english.h&quot;</a>
<a name="ln26">#include &quot;env.h&quot;</a>
<a name="ln27">#include &quot;exercise.h&quot;</a>
<a name="ln28">#include &quot;fight.h&quot;</a>
<a name="ln29">#include &quot;food.h&quot;</a>
<a name="ln30">#include &quot;god-abil.h&quot;</a>
<a name="ln31">#include &quot;god-conduct.h&quot;</a>
<a name="ln32">#include &quot;invent.h&quot;</a>
<a name="ln33">#include &quot;item-prop.h&quot;</a>
<a name="ln34">#include &quot;items.h&quot;</a>
<a name="ln35">#include &quot;libutil.h&quot;</a>
<a name="ln36">#include &quot;losglobal.h&quot;</a>
<a name="ln37">#include &quot;message.h&quot;</a>
<a name="ln38">#include &quot;mgen-data.h&quot;</a>
<a name="ln39">#include &quot;misc.h&quot;</a>
<a name="ln40">#include &quot;mon-behv.h&quot;</a>
<a name="ln41">#include &quot;mon-clone.h&quot;</a>
<a name="ln42">#include &quot;mon-pick.h&quot;</a>
<a name="ln43">#include &quot;mon-place.h&quot;</a>
<a name="ln44">#include &quot;mutant-beast.h&quot;</a>
<a name="ln45">#include &quot;place.h&quot;</a>
<a name="ln46">#include &quot;player.h&quot;</a>
<a name="ln47">#include &quot;player-stats.h&quot;</a>
<a name="ln48">#include &quot;religion.h&quot;</a>
<a name="ln49">#include &quot;shout.h&quot;</a>
<a name="ln50">#include &quot;skills.h&quot;</a>
<a name="ln51">#include &quot;spl-book.h&quot;</a>
<a name="ln52">#include &quot;spl-cast.h&quot;</a>
<a name="ln53">#include &quot;spl-clouds.h&quot;</a>
<a name="ln54">#include &quot;spl-util.h&quot;</a>
<a name="ln55">#include &quot;state.h&quot;</a>
<a name="ln56">#include &quot;stringutil.h&quot;</a>
<a name="ln57">#include &quot;target.h&quot;</a>
<a name="ln58">#include &quot;terrain.h&quot;</a>
<a name="ln59">#include &quot;throw.h&quot;</a>
<a name="ln60">#ifdef USE_TILE</a>
<a name="ln61"> #include &quot;tilepick.h&quot;</a>
<a name="ln62">#endif</a>
<a name="ln63">#include &quot;transform.h&quot;</a>
<a name="ln64">#include &quot;traps.h&quot;</a>
<a name="ln65">#include &quot;unicode.h&quot;</a>
<a name="ln66">#include &quot;view.h&quot;</a>
<a name="ln67"> </a>
<a name="ln68">static bool _reaching_weapon_attack(const item_def&amp; wpn)</a>
<a name="ln69">{</a>
<a name="ln70">    if (you.confused())</a>
<a name="ln71">    {</a>
<a name="ln72">        canned_msg(MSG_TOO_CONFUSED);</a>
<a name="ln73">        return false;</a>
<a name="ln74">    }</a>
<a name="ln75"> </a>
<a name="ln76">    if (you.caught())</a>
<a name="ln77">    {</a>
<a name="ln78">        mprf(&quot;You cannot attack while %s.&quot;, held_status());</a>
<a name="ln79">        return false;</a>
<a name="ln80">    }</a>
<a name="ln81"> </a>
<a name="ln82">    bool targ_mid = false;</a>
<a name="ln83">    dist beam;</a>
<a name="ln84">    const reach_type reach_range = weapon_reach(wpn);</a>
<a name="ln85"> </a>
<a name="ln86">    direction_chooser_args args;</a>
<a name="ln87">    args.restricts = DIR_TARGET;</a>
<a name="ln88">    args.mode = TARG_HOSTILE;</a>
<a name="ln89">    args.range = reach_range;</a>
<a name="ln90">    args.top_prompt = &quot;Attack whom?&quot;;</a>
<a name="ln91">    args.self = confirm_prompt_type::cancel;</a>
<a name="ln92"> </a>
<a name="ln93">    unique_ptr&lt;targeter&gt; hitfunc;</a>
<a name="ln94">    if (reach_range == REACH_TWO)</a>
<a name="ln95">        hitfunc = make_unique&lt;targeter_reach&gt;(&amp;you, reach_range);</a>
<a name="ln96">    // Assume all longer forms of reach use smite targeting.</a>
<a name="ln97">    else</a>
<a name="ln98">    {</a>
<a name="ln99">        hitfunc = make_unique&lt;targeter_smite&gt;(&amp;you, reach_range, 0, 0, false,</a>
<a name="ln100">                                              [](const coord_def&amp; p) -&gt; bool {</a>
<a name="ln101">                                              return you.pos() != p; });</a>
<a name="ln102">    }</a>
<a name="ln103">    args.hitfunc = hitfunc.get();</a>
<a name="ln104"> </a>
<a name="ln105">    direction(beam, args);</a>
<a name="ln106">    if (!beam.isValid)</a>
<a name="ln107">    {</a>
<a name="ln108">        if (beam.isCancel)</a>
<a name="ln109">            canned_msg(MSG_OK);</a>
<a name="ln110">        return false;</a>
<a name="ln111">    }</a>
<a name="ln112"> </a>
<a name="ln113">    if (beam.isMe())</a>
<a name="ln114">    {</a>
<a name="ln115">        canned_msg(MSG_UNTHINKING_ACT);</a>
<a name="ln116">        return false;</a>
<a name="ln117">    }</a>
<a name="ln118"> </a>
<a name="ln119">    const coord_def delta = beam.target - you.pos();</a>
<a name="ln120">    const int x_distance  = abs(delta.x);</a>
<a name="ln121">    const int y_distance  = abs(delta.y);</a>
<a name="ln122">    monster* mons = monster_at(beam.target);</a>
<a name="ln123">    // don't allow targeting of submerged monsters</a>
<a name="ln124">    if (mons &amp;&amp; mons-&gt;submerged())</a>
<a name="ln125">        mons = nullptr;</a>
<a name="ln126"> </a>
<a name="ln127">    if (x_distance &gt; reach_range || y_distance &gt; reach_range)</a>
<a name="ln128">    {</a>
<a name="ln129">        mpr(&quot;Your weapon cannot reach that far!&quot;);</a>
<a name="ln130">        return false;</a>
<a name="ln131">    }</a>
<a name="ln132"> </a>
<a name="ln133">    // Failing to hit someone due to a friend blocking is infuriating,</a>
<a name="ln134">    // shadow-boxing empty space is not (and would be abusable to wait</a>
<a name="ln135">    // with no penalty).</a>
<a name="ln136">    if (mons)</a>
<a name="ln137">        you.apply_berserk_penalty = false;</a>
<a name="ln138"> </a>
<a name="ln139">    // Calculate attack delay now in case we have to apply it.</a>
<a name="ln140">    const int attack_delay = you.attack_delay().roll();</a>
<a name="ln141"> </a>
<a name="ln142">    // Check for a monster in the way. If there is one, it blocks the reaching</a>
<a name="ln143">    // attack 50% of the time, and the attack tries to hit it if it is hostile.</a>
<a name="ln144">    if (reach_range &lt; REACH_THREE &amp;&amp; (x_distance &gt; 1 || y_distance &gt; 1))</a>
<a name="ln145">    {</a>
<a name="ln146">        const int x_first_middle = you.pos().x + (delta.x) / 2;</a>
<a name="ln147">        const int y_first_middle = you.pos().y + (delta.y) / 2;</a>
<a name="ln148">        const int x_second_middle = beam.target.x - (delta.x) / 2;</a>
<a name="ln149">        const int y_second_middle = beam.target.y - (delta.y) / 2;</a>
<a name="ln150">        const coord_def first_middle(x_first_middle, y_first_middle);</a>
<a name="ln151">        const coord_def second_middle(x_second_middle, y_second_middle);</a>
<a name="ln152"> </a>
<a name="ln153">        if (!feat_is_reachable_past(grd(first_middle))</a>
<a name="ln154">            &amp;&amp; !feat_is_reachable_past(grd(second_middle)))</a>
<a name="ln155">        {</a>
<a name="ln156">            canned_msg(MSG_SOMETHING_IN_WAY);</a>
<a name="ln157">            return false;</a>
<a name="ln158">        }</a>
<a name="ln159"> </a>
<a name="ln160">        // Choose one of the two middle squares (which might be the same).</a>
<a name="ln161">        const coord_def middle =</a>
<a name="ln162">            !feat_is_reachable_past(grd(first_middle)) ? second_middle :</a>
<a name="ln163">            !feat_is_reachable_past(grd(second_middle)) ? first_middle :</a>
<a name="ln164">        random_choose(first_middle, second_middle);</a>
<a name="ln165"> </a>
<a name="ln166">        bool success = true;</a>
<a name="ln167">        monster *midmons;</a>
<a name="ln168">        if ((midmons = monster_at(middle))</a>
<a name="ln169">            &amp;&amp; !midmons-&gt;submerged()</a>
<a name="ln170">            &amp;&amp; coinflip())</a>
<a name="ln171">        {</a>
<a name="ln172">            success = false;</a>
<a name="ln173">            beam.target = middle;</a>
<a name="ln174">            mons = midmons;</a>
<a name="ln175">            targ_mid = true;</a>
<a name="ln176">            if (mons-&gt;wont_attack())</a>
<a name="ln177">            {</a>
<a name="ln178">                // Let's assume friendlies cooperate.</a>
<a name="ln179">                mpr(&quot;You could not reach far enough!&quot;);</a>
<a name="ln180">                you.time_taken = attack_delay;</a>
<a name="ln181">                make_hungry(3, true);</a>
<a name="ln182">                return true;</a>
<a name="ln183">            }</a>
<a name="ln184">        }</a>
<a name="ln185"> </a>
<a name="ln186">        if (success)</a>
<a name="ln187">            mpr(&quot;You reach to attack!&quot;);</a>
<a name="ln188">        else</a>
<a name="ln189">        {</a>
<a name="ln190">            mprf(&quot;%s is in the way.&quot;,</a>
<a name="ln191">                 mons-&gt;observable() ? mons-&gt;name(DESC_THE).c_str()</a>
<a name="ln192">                                    : &quot;Something you can't see&quot;);</a>
<a name="ln193">        }</a>
<a name="ln194">    }</a>
<a name="ln195"> </a>
<a name="ln196">    if (mons == nullptr)</a>
<a name="ln197">    {</a>
<a name="ln198">        // Must return true, otherwise you get a free discovery</a>
<a name="ln199">        // of invisible monsters.</a>
<a name="ln200">        mpr(&quot;You attack empty space.&quot;);</a>
<a name="ln201">        you.time_taken = attack_delay;</a>
<a name="ln202">        make_hungry(3, true);</a>
<a name="ln203">        return true;</a>
<a name="ln204">    }</a>
<a name="ln205">    else if (!fight_melee(&amp;you, mons))</a>
<a name="ln206">    {</a>
<a name="ln207">        if (targ_mid)</a>
<a name="ln208">        {</a>
<a name="ln209">            // turn_is_over may have been reset to false by fight_melee, but</a>
<a name="ln210">            // a failed attempt to reach further should not be free; instead,</a>
<a name="ln211">            // charge the same as a successful attempt.</a>
<a name="ln212">            you.time_taken = attack_delay;</a>
<a name="ln213">            make_hungry(3, true);</a>
<a name="ln214">            you.turn_is_over = true;</a>
<a name="ln215">        }</a>
<a name="ln216">        else</a>
<a name="ln217">            return false;</a>
<a name="ln218">    }</a>
<a name="ln219"> </a>
<a name="ln220">    return true;</a>
<a name="ln221">}</a>
<a name="ln222"> </a>
<a name="ln223">static bool _evoke_horn_of_geryon()</a>
<a name="ln224">{</a>
<a name="ln225">    bool created = false;</a>
<a name="ln226"> </a>
<a name="ln227">    if (silenced(you.pos()))</a>
<a name="ln228">    {</a>
<a name="ln229">        mpr(&quot;You can't produce a sound!&quot;);</a>
<a name="ln230">        return false;</a>
<a name="ln231">    }</a>
<a name="ln232"> </a>
<a name="ln233">#if TAG_MAJOR_VERSION == 34</a>
<a name="ln234">    const int surge = pakellas_surge_devices();</a>
<a name="ln235">    surge_power(you.spec_evoke() + surge);</a>
<a name="ln236">#else</a>
<a name="ln237">    const int surge = 0;</a>
<a name="ln238">#endif</a>
<a name="ln239">    mprf(MSGCH_SOUND, &quot;You produce a hideous howling noise!&quot;);</a>
<a name="ln240">    did_god_conduct(DID_EVIL, 3);</a>
<a name="ln241">    int num = 1;</a>
<a name="ln242">    const int adjusted_power =</a>
<a name="ln243">        player_adjust_evoc_power(you.skill(SK_EVOCATIONS, 10), surge);</a>
<a name="ln244">    if (adjusted_power + random2(90) &gt; 130)</a>
<a name="ln245">        ++num;</a>
<a name="ln246">    if (adjusted_power + random2(90) &gt; 180)</a>
<a name="ln247">        ++num;</a>
<a name="ln248">    if (adjusted_power + random2(90) &gt; 230)</a>
<a name="ln249">        ++num;</a>
<a name="ln250">    for (int n = 0; n &lt; num; ++n)</a>
<a name="ln251">    {</a>
<a name="ln252">        monster* mon;</a>
<a name="ln253">        beh_type beh = BEH_HOSTILE;</a>
<a name="ln254">        bool will_anger = player_will_anger_monster(MONS_HELL_BEAST);</a>
<a name="ln255"> </a>
<a name="ln256">        if (!will_anger &amp;&amp; random2(adjusted_power) &gt; 7)</a>
<a name="ln257">            beh = BEH_FRIENDLY;</a>
<a name="ln258">        mgen_data mg(MONS_HELL_BEAST, beh, you.pos(), MHITYOU, MG_FORCE_BEH);</a>
<a name="ln259">        mg.set_summoned(&amp;you, 3, SPELL_NO_SPELL);</a>
<a name="ln260">        mg.set_prox(PROX_CLOSE_TO_PLAYER);</a>
<a name="ln261">        mon = create_monster(mg);</a>
<a name="ln262">        if (mon)</a>
<a name="ln263">            created = true;</a>
<a name="ln264">        if (mon &amp;&amp; will_anger)</a>
<a name="ln265">        {</a>
<a name="ln266">            mprf(&quot;%s is enraged by your holy aura!&quot;,</a>
<a name="ln267">                 mon-&gt;name(DESC_THE).c_str());</a>
<a name="ln268">        }</a>
<a name="ln269">    }</a>
<a name="ln270">    if (!created)</a>
<a name="ln271">        mpr(&quot;Nothing answers your call.&quot;);</a>
<a name="ln272">    return true;</a>
<a name="ln273">}</a>
<a name="ln274"> </a>
<a name="ln275">/**</a>
<a name="ln276"> * Spray lightning in all directions. (Randomly: shock, lightning bolt, OoE.)</a>
<a name="ln277"> *</a>
<a name="ln278"> * @param range         The range of the beams. (As with all beams, eventually</a>
<a name="ln279"> *                      capped at LOS.)</a>
<a name="ln280"> * @param power         The power of the beams. (Affects damage.)</a>
<a name="ln281"> */</a>
<a name="ln282">static void _spray_lightning(int range, int power)</a>
<a name="ln283">{</a>
<a name="ln284">    const zap_type which_zap = random_choose(ZAP_SHOCK,</a>
<a name="ln285">                                             ZAP_LIGHTNING_BOLT,</a>
<a name="ln286">                                             ZAP_ORB_OF_ELECTRICITY);</a>
<a name="ln287"> </a>
<a name="ln288">    bolt beam;</a>
<a name="ln289">    // range has no tracer, so randomness is ok</a>
<a name="ln290">    beam.range = range;</a>
<a name="ln291">    beam.source = you.pos();</a>
<a name="ln292">    beam.target = you.pos();</a>
<a name="ln293">    beam.target.x += random2(13) - 6;</a>
<a name="ln294">    beam.target.y += random2(13) - 6;</a>
<a name="ln295">    // Non-controlleable, so no player tracer.</a>
<a name="ln296">    zapping(which_zap, power, beam);</a>
<a name="ln297">}</a>
<a name="ln298"> </a>
<a name="ln299">/**</a>
<a name="ln300"> * Evoke a lightning rod, creating an arc of lightning that can be sustained</a>
<a name="ln301"> * by continuing to evoke.</a>
<a name="ln302"> *</a>
<a name="ln303"> * @return  Whether anything happened.</a>
<a name="ln304"> */</a>
<a name="ln305">static bool _lightning_rod()</a>
<a name="ln306">{</a>
<a name="ln307">    if (you.confused())</a>
<a name="ln308">    {</a>
<a name="ln309">        canned_msg(MSG_TOO_CONFUSED);</a>
<a name="ln310">        return false;</a>
<a name="ln311">    }</a>
<a name="ln312"> </a>
<a name="ln313">#if TAG_MAJOR_VERSION == 34</a>
<a name="ln314">    const int surge = pakellas_surge_devices();</a>
<a name="ln315">    surge_power(you.spec_evoke() + surge);</a>
<a name="ln316">#else</a>
<a name="ln317">    const int surge = 0;</a>
<a name="ln318">#endif</a>
<a name="ln319">    const int power =</a>
<a name="ln320">        player_adjust_evoc_power(5 + you.skill(SK_EVOCATIONS, 3), surge);</a>
<a name="ln321"> </a>
<a name="ln322">    const spret ret = your_spells(SPELL_THUNDERBOLT, power, false);</a>
<a name="ln323"> </a>
<a name="ln324">    if (ret == spret::abort)</a>
<a name="ln325">        return false;</a>
<a name="ln326"> </a>
<a name="ln327">    return true;</a>
<a name="ln328">}</a>
<a name="ln329"> </a>
<a name="ln330">/**</a>
<a name="ln331"> * Spray lightning in all directions around the player.</a>
<a name="ln332"> *</a>
<a name="ln333"> * Quantity, range &amp; power increase with level.</a>
<a name="ln334"> */</a>
<a name="ln335">void black_drac_breath()</a>
<a name="ln336">{</a>
<a name="ln337">    const int num_shots = roll_dice(2, 1 + you.experience_level / 7);</a>
<a name="ln338">    const int range = you.experience_level / 3 + 5; // 5--14</a>
<a name="ln339">    const int power = 25 + you.experience_level; // 25-52</a>
<a name="ln340">    for (int i = 0; i &lt; num_shots; ++i)</a>
<a name="ln341">        _spray_lightning(range, power);</a>
<a name="ln342">}</a>
<a name="ln343"> </a>
<a name="ln344">/**</a>
<a name="ln345"> * Returns the MP cost of zapping a wand:</a>
<a name="ln346"> *     3 if player has MP-powered wands and enough MP available,</a>
<a name="ln347"> *     1-2 if player has MP-powered wands and only 1-2 MP left,</a>
<a name="ln348"> *     0 otherwise.</a>
<a name="ln349"> */</a>
<a name="ln350">int wand_mp_cost()</a>
<a name="ln351">{</a>
<a name="ln352">    // Update mutation-data.h when updating this value.</a>
<a name="ln353">    return min(you.magic_points, you.get_mutation_level(MUT_MP_WANDS) * 3);</a>
<a name="ln354">}</a>
<a name="ln355"> </a>
<a name="ln356">void zap_wand(int slot)</a>
<a name="ln357">{</a>
<a name="ln358">    if (inv_count() &lt; 1)</a>
<a name="ln359">    {</a>
<a name="ln360">        canned_msg(MSG_NOTHING_CARRIED);</a>
<a name="ln361">        return;</a>
<a name="ln362">    }</a>
<a name="ln363"> </a>
<a name="ln364">    if (you.confused())</a>
<a name="ln365">    {</a>
<a name="ln366">        canned_msg(MSG_TOO_CONFUSED);</a>
<a name="ln367">        return;</a>
<a name="ln368">    }</a>
<a name="ln369"> </a>
<a name="ln370">    if (you.berserk())</a>
<a name="ln371">    {</a>
<a name="ln372">        canned_msg(MSG_TOO_BERSERK);</a>
<a name="ln373">        return;</a>
<a name="ln374">    }</a>
<a name="ln375"> </a>
<a name="ln376">    if (you.get_mutation_level(MUT_NO_ARTIFICE))</a>
<a name="ln377">    {</a>
<a name="ln378">        mpr(&quot;You cannot evoke magical items.&quot;);</a>
<a name="ln379">        return;</a>
<a name="ln380">    }</a>
<a name="ln381"> </a>
<a name="ln382">#if TAG_MAJOR_VERSION == 34</a>
<a name="ln383">    if (player_under_penance(GOD_PAKELLAS))</a>
<a name="ln384">    {</a>
<a name="ln385">        simple_god_message(&quot;'s wrath prevents you from evoking devices!&quot;,</a>
<a name="ln386">                           GOD_PAKELLAS);</a>
<a name="ln387">        return;</a>
<a name="ln388">    }</a>
<a name="ln389">#endif</a>
<a name="ln390"> </a>
<a name="ln391">    const int mp_cost = wand_mp_cost();</a>
<a name="ln392"> </a>
<a name="ln393">    int item_slot;</a>
<a name="ln394">    if (slot != -1)</a>
<a name="ln395">        item_slot = slot;</a>
<a name="ln396">    else</a>
<a name="ln397">    {</a>
<a name="ln398">        item_slot = prompt_invent_item(&quot;Zap which item?&quot;,</a>
<a name="ln399">                                       menu_type::invlist,</a>
<a name="ln400">                                       OBJ_WANDS,</a>
<a name="ln401">                                       OPER_ZAP);</a>
<a name="ln402">    }</a>
<a name="ln403"> </a>
<a name="ln404">    if (prompt_failed(item_slot))</a>
<a name="ln405">        return;</a>
<a name="ln406"> </a>
<a name="ln407">    item_def&amp; wand = you.inv[item_slot];</a>
<a name="ln408">    if (wand.base_type != OBJ_WANDS)</a>
<a name="ln409">    {</a>
<a name="ln410">        mpr(&quot;You can't zap that!&quot;);</a>
<a name="ln411">        return;</a>
<a name="ln412">    }</a>
<a name="ln413">    if (item_type_removed(wand.base_type, wand.sub_type))</a>
<a name="ln414">    {</a>
<a name="ln415">        mpr(&quot;Sorry, this wand was removed!&quot;);</a>
<a name="ln416">        return;</a>
<a name="ln417">    }</a>
<a name="ln418">    // If you happen to be wielding the wand, its display might change.</a>
<a name="ln419">    if (you.equip[EQ_WEAPON] == item_slot)</a>
<a name="ln420">        you.wield_change = true;</a>
<a name="ln421"> </a>
<a name="ln422">    if (wand.charges &lt;= 0)</a>
<a name="ln423">    {</a>
<a name="ln424">        mpr(&quot;This wand has no charges.&quot;);</a>
<a name="ln425">        return;</a>
<a name="ln426">    }</a>
<a name="ln427"> </a>
<a name="ln428">    int power = (15 + you.skill(SK_EVOCATIONS, 7) / 2) * (mp_cost + 9) / 9;</a>
<a name="ln429"> </a>
<a name="ln430">    const spell_type spell =</a>
<a name="ln431">        spell_in_wand(static_cast&lt;wand_type&gt;(wand.sub_type));</a>
<a name="ln432"> </a>
<a name="ln433">    spret ret = your_spells(spell, power, false, &amp;wand);</a>
<a name="ln434"> </a>
<a name="ln435">    if (ret == spret::abort)</a>
<a name="ln436">        return;</a>
<a name="ln437">    else if (ret == spret::fail)</a>
<a name="ln438">    {</a>
<a name="ln439">        canned_msg(MSG_NOTHING_HAPPENS);</a>
<a name="ln440">        you.turn_is_over = true;</a>
<a name="ln441">        return;</a>
<a name="ln442">    }</a>
<a name="ln443"> </a>
<a name="ln444">    // Spend MP.</a>
<a name="ln445">    if (mp_cost)</a>
<a name="ln446">        dec_mp(mp_cost, false);</a>
<a name="ln447"> </a>
<a name="ln448">    // Take off a charge.</a>
<a name="ln449">    wand.charges--;</a>
<a name="ln450"> </a>
<a name="ln451">    if (wand.charges == 0)</a>
<a name="ln452">    {</a>
<a name="ln453">        ASSERT(in_inventory(wand));</a>
<a name="ln454"> </a>
<a name="ln455">        mpr(&quot;The now-empty wand crumbles to dust.&quot;);</a>
<a name="ln456">        dec_inv_item_quantity(wand.link, 1);</a>
<a name="ln457">    }</a>
<a name="ln458"> </a>
<a name="ln459">    practise_evoking(1);</a>
<a name="ln460">    count_action(CACT_EVOKE, EVOC_WAND);</a>
<a name="ln461">    alert_nearby_monsters();</a>
<a name="ln462"> </a>
<a name="ln463">    you.turn_is_over = true;</a>
<a name="ln464">}</a>
<a name="ln465"> </a>
<a name="ln466">// return a slot that has manual for given skill, or -1 if none exists</a>
<a name="ln467">// in case of multiple manuals the one with the fewest charges is returned</a>
<a name="ln468">int manual_slot_for_skill(skill_type skill)</a>
<a name="ln469">{</a>
<a name="ln470">    int slot = -1;</a>
<a name="ln471">    int charges = -1;</a>
<a name="ln472"> </a>
<a name="ln473">    FixedVector&lt;item_def,ENDOFPACK&gt;::const_pointer iter = you.inv.begin();</a>
<a name="ln474">    for (;iter!=you.inv.end(); ++iter)</a>
<a name="ln475">    {</a>
<a name="ln476">        if (iter-&gt;base_type != OBJ_BOOKS || iter-&gt;sub_type != BOOK_MANUAL)</a>
<a name="ln477">            continue;</a>
<a name="ln478"> </a>
<a name="ln479">        if (iter-&gt;skill != skill || iter-&gt;skill_points == 0)</a>
<a name="ln480">            continue;</a>
<a name="ln481"> </a>
<a name="ln482">        if (slot != -1 &amp;&amp; iter-&gt;skill_points &gt; charges)</a>
<a name="ln483">            continue;</a>
<a name="ln484"> </a>
<a name="ln485">        slot = iter - you.inv.begin();</a>
<a name="ln486">        charges = iter-&gt;skill_points;</a>
<a name="ln487">    }</a>
<a name="ln488"> </a>
<a name="ln489">    return slot;</a>
<a name="ln490">}</a>
<a name="ln491"> </a>
<a name="ln492">int get_all_manual_charges_for_skill(skill_type skill)</a>
<a name="ln493">{</a>
<a name="ln494">    int charges = 0;</a>
<a name="ln495"> </a>
<a name="ln496">    FixedVector&lt;item_def,ENDOFPACK&gt;::const_pointer iter = you.inv.begin();</a>
<a name="ln497">    for (;iter!=you.inv.end(); ++iter)</a>
<a name="ln498">    {</a>
<a name="ln499">        if (iter-&gt;base_type != OBJ_BOOKS || iter-&gt;sub_type != BOOK_MANUAL)</a>
<a name="ln500">            continue;</a>
<a name="ln501"> </a>
<a name="ln502">        if (iter-&gt;skill != skill || iter-&gt;skill_points == 0)</a>
<a name="ln503">            continue;</a>
<a name="ln504"> </a>
<a name="ln505">        charges += iter-&gt;skill_points;</a>
<a name="ln506">    }</a>
<a name="ln507"> </a>
<a name="ln508">    return charges;</a>
<a name="ln509">}</a>
<a name="ln510"> </a>
<a name="ln511">bool skill_has_manual(skill_type skill)</a>
<a name="ln512">{</a>
<a name="ln513">    return manual_slot_for_skill(skill) != -1;</a>
<a name="ln514">}</a>
<a name="ln515"> </a>
<a name="ln516">void finish_manual(int slot)</a>
<a name="ln517">{</a>
<a name="ln518">    item_def&amp; manual(you.inv[slot]);</a>
<a name="ln519">    const skill_type skill = static_cast&lt;skill_type&gt;(manual.plus);</a>
<a name="ln520"> </a>
<a name="ln521">    mprf(&quot;You have finished your manual of %s and toss it away.&quot;,</a>
<a name="ln522">         skill_name(skill));</a>
<a name="ln523">    dec_inv_item_quantity(slot, 1);</a>
<a name="ln524">}</a>
<a name="ln525"> </a>
<a name="ln526">void get_all_manual_charges(vector&lt;int&gt; &amp;charges)</a>
<a name="ln527">{</a>
<a name="ln528">    charges.clear();</a>
<a name="ln529"> </a>
<a name="ln530">    FixedVector&lt;item_def,ENDOFPACK&gt;::const_pointer iter = you.inv.begin();</a>
<a name="ln531">    for (;iter!=you.inv.end(); ++iter)</a>
<a name="ln532">    {</a>
<a name="ln533">        if (iter-&gt;base_type != OBJ_BOOKS || iter-&gt;sub_type != BOOK_MANUAL)</a>
<a name="ln534">            continue;</a>
<a name="ln535"> </a>
<a name="ln536">        charges.push_back(iter-&gt;skill_points);</a>
<a name="ln537">    }</a>
<a name="ln538">}</a>
<a name="ln539"> </a>
<a name="ln540">void set_all_manual_charges(const vector&lt;int&gt; &amp;charges)</a>
<a name="ln541">{</a>
<a name="ln542">    auto charge_iter = charges.begin();</a>
<a name="ln543">    for (item_def &amp;item : you.inv)</a>
<a name="ln544">    {</a>
<a name="ln545">        if (item.base_type != OBJ_BOOKS || item.sub_type != BOOK_MANUAL)</a>
<a name="ln546">            continue;</a>
<a name="ln547"> </a>
<a name="ln548">        ASSERT(charge_iter != charges.end());</a>
<a name="ln549">        item.skill_points = *charge_iter;</a>
<a name="ln550">        charge_iter++;</a>
<a name="ln551">    }</a>
<a name="ln552">    ASSERT(charge_iter == charges.end());</a>
<a name="ln553">}</a>
<a name="ln554"> </a>
<a name="ln555">string manual_skill_names(bool short_text)</a>
<a name="ln556">{</a>
<a name="ln557">    skill_set skills;</a>
<a name="ln558"> </a>
<a name="ln559">    FixedVector&lt;item_def,ENDOFPACK&gt;::const_pointer iter = you.inv.begin();</a>
<a name="ln560">    for (;iter!=you.inv.end(); ++iter)</a>
<a name="ln561">    {</a>
<a name="ln562">        if (iter-&gt;base_type != OBJ_BOOKS</a>
<a name="ln563">            || iter-&gt;sub_type != BOOK_MANUAL</a>
<a name="ln564">            || is_useless_item(*iter))</a>
<a name="ln565">        {</a>
<a name="ln566">            continue;</a>
<a name="ln567">        }</a>
<a name="ln568"> </a>
<a name="ln569">        skills.insert(static_cast&lt;skill_type&gt;(iter-&gt;plus));</a>
<a name="ln570">    }</a>
<a name="ln571"> </a>
<a name="ln572">    if (short_text &amp;&amp; skills.size() &gt; 1)</a>
<a name="ln573">    {</a>
<a name="ln574">        char buf[40];</a>
<a name="ln575">        sprintf(buf, &quot;%lu skills&quot;, (unsigned long) skills.size());</a>
<a name="ln576">        return string(buf);</a>
<a name="ln577">    }</a>
<a name="ln578">    else</a>
<a name="ln579">        return skill_names(skills);</a>
<a name="ln580">}</a>
<a name="ln581"> </a>
<a name="ln582">static bool _box_of_beasts(item_def &amp;box)</a>
<a name="ln583">{</a>
<a name="ln584">#if TAG_MAJOR_VERSION == 34</a>
<a name="ln585">    const int surge = pakellas_surge_devices();</a>
<a name="ln586">    surge_power(you.spec_evoke() + surge);</a>
<a name="ln587">#else</a>
<a name="ln588">    const int surge = 0;</a>
<a name="ln589">#endif</a>
<a name="ln590">    mpr(&quot;You open the lid...&quot;);</a>
<a name="ln591"> </a>
<a name="ln592">    // two rolls to reduce std deviation - +-6 so can get &lt; max even at 27 sk</a>
<a name="ln593">    int rnd_factor = random2(7);</a>
<a name="ln594">    rnd_factor -= random2(7);</a>
<a name="ln595">    const int hd_min = min(27,</a>
<a name="ln596">                           player_adjust_evoc_power(</a>
<a name="ln597">                               you.skill(SK_EVOCATIONS)</a>
<a name="ln598">                               + rnd_factor, surge));</a>
<a name="ln599">    const int tier = mutant_beast_tier(hd_min);</a>
<a name="ln600">    ASSERT(tier &lt; NUM_BEAST_TIERS);</a>
<a name="ln601"> </a>
<a name="ln602">    mgen_data mg(MONS_MUTANT_BEAST, BEH_FRIENDLY, you.pos(), MHITYOU,</a>
<a name="ln603">                 MG_AUTOFOE);</a>
<a name="ln604">    mg.set_summoned(&amp;you, 3 + random2(3), 0);</a>
<a name="ln605"> </a>
<a name="ln606">    mg.hd = beast_tiers[tier];</a>
<a name="ln607">    dprf(&quot;hd %d (min %d, tier %d)&quot;, mg.hd, hd_min, tier);</a>
<a name="ln608">    const monster* mons = create_monster(mg);</a>
<a name="ln609"> </a>
<a name="ln610">    if (!mons)</a>
<a name="ln611">    {</a>
<a name="ln612">        // Failed to create monster for some reason</a>
<a name="ln613">        mpr(&quot;...but nothing happens.&quot;);</a>
<a name="ln614">        return false;</a>
<a name="ln615">    }</a>
<a name="ln616"> </a>
<a name="ln617">    mprf(&quot;...and %s %s out!&quot;,</a>
<a name="ln618">         mons-&gt;name(DESC_A).c_str(), mons-&gt;airborne() ? &quot;flies&quot; : &quot;leaps&quot;);</a>
<a name="ln619">    did_god_conduct(DID_CHAOS, random_range(5,10));</a>
<a name="ln620"> </a>
<a name="ln621">    // After unboxing a beast, chance to break.</a>
<a name="ln622">    if (one_chance_in(3))</a>
<a name="ln623">    {</a>
<a name="ln624">        mpr(&quot;The now-empty box falls apart.&quot;);</a>
<a name="ln625">        ASSERT(in_inventory(box));</a>
<a name="ln626">        dec_inv_item_quantity(box.link, 1);</a>
<a name="ln627">    }</a>
<a name="ln628"> </a>
<a name="ln629">    return true;</a>
<a name="ln630">}</a>
<a name="ln631"> </a>
<a name="ln632">static bool _make_zig(item_def &amp;zig)</a>
<a name="ln633">{</a>
<a name="ln634">    if (feat_is_critical(grd(you.pos())))</a>
<a name="ln635">    {</a>
<a name="ln636">        mpr(&quot;You can't place a gateway to a ziggurat here.&quot;);</a>
<a name="ln637">        return false;</a>
<a name="ln638">    }</a>
<a name="ln639">    for (int lev = 1; lev &lt;= brdepth[BRANCH_ZIGGURAT]; lev++)</a>
<a name="ln640">    {</a>
<a name="ln641">        if (is_level_on_stack(level_id(BRANCH_ZIGGURAT, lev))</a>
<a name="ln642">            || you.where_are_you == BRANCH_ZIGGURAT)</a>
<a name="ln643">        {</a>
<a name="ln644">            mpr(&quot;Finish your current ziggurat first!&quot;);</a>
<a name="ln645">            return false;</a>
<a name="ln646">        }</a>
<a name="ln647">    }</a>
<a name="ln648"> </a>
<a name="ln649">    ASSERT(in_inventory(zig));</a>
<a name="ln650">    dec_inv_item_quantity(zig.link, 1);</a>
<a name="ln651">    dungeon_terrain_changed(you.pos(), DNGN_ENTER_ZIGGURAT);</a>
<a name="ln652">    mpr(&quot;You set the figurine down, and a mystic portal to a ziggurat forms.&quot;);</a>
<a name="ln653">    return true;</a>
<a name="ln654">}</a>
<a name="ln655"> </a>
<a name="ln656">struct dist_sorter</a>
<a name="ln657">{</a>
<a name="ln658">    coord_def pos;</a>
<a name="ln659">    bool operator()(const actor* a, const actor* b)</a>
<a name="ln660">    {</a>
<a name="ln661">        return a-&gt;pos().distance_from(pos) &gt; b-&gt;pos().distance_from(pos);</a>
<a name="ln662">    }</a>
<a name="ln663">};</a>
<a name="ln664"> </a>
<a name="ln665">static int _gale_push_dist(const actor* agent, const actor* victim, int pow)</a>
<a name="ln666">{</a>
<a name="ln667">    int dist = 1 + random2(pow / 20);</a>
<a name="ln668"> </a>
<a name="ln669">    if (victim-&gt;airborne())</a>
<a name="ln670">        dist++;</a>
<a name="ln671"> </a>
<a name="ln672">    if (victim-&gt;body_size(PSIZE_BODY) &lt; SIZE_MEDIUM)</a>
<a name="ln673">        dist++;</a>
<a name="ln674">    else if (victim-&gt;body_size(PSIZE_BODY) &gt; SIZE_BIG)</a>
<a name="ln675">        dist /= 2;</a>
<a name="ln676">    else if (victim-&gt;body_size(PSIZE_BODY) &gt; SIZE_MEDIUM)</a>
<a name="ln677">        dist -= 1;</a>
<a name="ln678"> </a>
<a name="ln679">    int range = victim-&gt;pos().distance_from(agent-&gt;pos());</a>
<a name="ln680">    if (range &gt; 5)</a>
<a name="ln681">        dist -= 2;</a>
<a name="ln682">    else if (range &gt; 2)</a>
<a name="ln683">        dist--;</a>
<a name="ln684"> </a>
<a name="ln685">    if (dist &lt; 0)</a>
<a name="ln686">        return 0;</a>
<a name="ln687">    else</a>
<a name="ln688">        return dist;</a>
<a name="ln689">}</a>
<a name="ln690"> </a>
<a name="ln691">static double _angle_between(coord_def origin, coord_def p1, coord_def p2)</a>
<a name="ln692">{</a>
<a name="ln693">    double ang0 = atan2(p1.x - origin.x, p1.y - origin.y);</a>
<a name="ln694">    double ang  = atan2(p2.x - origin.x, p2.y - origin.y);</a>
<a name="ln695">    return min(fabs(ang - ang0), fabs(ang - ang0 + 2 * PI));</a>
<a name="ln696">}</a>
<a name="ln697"> </a>
<a name="ln698">void wind_blast(actor* agent, int pow, coord_def target, bool card)</a>
<a name="ln699">{</a>
<a name="ln700">    vector&lt;actor *&gt; act_list;</a>
<a name="ln701"> </a>
<a name="ln702">    int radius = min(5, 4 + div_rand_round(pow, 60));</a>
<a name="ln703"> </a>
<a name="ln704">    for (actor_near_iterator ai(agent-&gt;pos(), LOS_SOLID); ai; ++ai)</a>
<a name="ln705">    {</a>
<a name="ln706">        if (ai-&gt;is_stationary()</a>
<a name="ln707">            || ai-&gt;pos().distance_from(agent-&gt;pos()) &gt; radius</a>
<a name="ln708">            || ai-&gt;pos() == agent-&gt;pos() // so it's never aimed_at_feet</a>
<a name="ln709">            || !target.origin()</a>
<a name="ln710">               &amp;&amp; _angle_between(agent-&gt;pos(), target, ai-&gt;pos()) &gt; PI/4.0)</a>
<a name="ln711">        {</a>
<a name="ln712">            continue;</a>
<a name="ln713">        }</a>
<a name="ln714"> </a>
<a name="ln715">        act_list.push_back(*ai);</a>
<a name="ln716">    }</a>
<a name="ln717"> </a>
<a name="ln718">    dist_sorter sorter = {agent-&gt;pos()};</a>
<a name="ln719">    sort(act_list.begin(), act_list.end(), sorter);</a>
<a name="ln720"> </a>
<a name="ln721">    bolt wind_beam;</a>
<a name="ln722">    wind_beam.hit             = AUTOMATIC_HIT;</a>
<a name="ln723">    wind_beam.pierce          = true;</a>
<a name="ln724">    wind_beam.affects_nothing = true;</a>
<a name="ln725">    wind_beam.source          = agent-&gt;pos();</a>
<a name="ln726">    wind_beam.range           = LOS_RADIUS;</a>
<a name="ln727">    wind_beam.is_tracer       = true;</a>
<a name="ln728"> </a>
<a name="ln729">    map&lt;actor *, coord_def&gt; collisions;</a>
<a name="ln730"> </a>
<a name="ln731">    bool player_affected = false;</a>
<a name="ln732">    counted_monster_list affected_monsters;</a>
<a name="ln733"> </a>
<a name="ln734">    for (actor *act : act_list)</a>
<a name="ln735">    {</a>
<a name="ln736">        wind_beam.target = act-&gt;pos();</a>
<a name="ln737">        wind_beam.fire();</a>
<a name="ln738"> </a>
<a name="ln739">        int push = _gale_push_dist(agent, act, pow);</a>
<a name="ln740">        bool pushed = false;</a>
<a name="ln741"> </a>
<a name="ln742">        for (unsigned int j = 0; j &lt; wind_beam.path_taken.size() - 1 &amp;&amp; push;</a>
<a name="ln743">             ++j)</a>
<a name="ln744">        {</a>
<a name="ln745">            if (wind_beam.path_taken[j] == act-&gt;pos())</a>
<a name="ln746">            {</a>
<a name="ln747">                coord_def newpos = wind_beam.path_taken[j+1];</a>
<a name="ln748">                if (!actor_at(newpos) &amp;&amp; !cell_is_solid(newpos)</a>
<a name="ln749">                    &amp;&amp; act-&gt;can_pass_through(newpos)</a>
<a name="ln750">                    &amp;&amp; act-&gt;is_habitable(newpos))</a>
<a name="ln751">                {</a>
<a name="ln752">                    act-&gt;move_to_pos(newpos);</a>
<a name="ln753">                    if (act-&gt;is_player())</a>
<a name="ln754">                        stop_delay(true);</a>
<a name="ln755">                    --push;</a>
<a name="ln756">                    pushed = true;</a>
<a name="ln757">                }</a>
<a name="ln758">                else //Try to find an alternate route to push</a>
<a name="ln759">                {</a>
<a name="ln760">                    bool success = false;</a>
<a name="ln761">                    for (adjacent_iterator di(newpos); di; ++di)</a>
<a name="ln762">                    {</a>
<a name="ln763">                        if (adjacent(*di, act-&gt;pos())</a>
<a name="ln764">                            &amp;&amp; di-&gt;distance_from(agent-&gt;pos())</a>
<a name="ln765">                                == newpos.distance_from(agent-&gt;pos())</a>
<a name="ln766">                            &amp;&amp; !actor_at(*di) &amp;&amp; !cell_is_solid(*di)</a>
<a name="ln767">                            &amp;&amp; act-&gt;can_pass_through(*di)</a>
<a name="ln768">                            &amp;&amp; act-&gt;is_habitable(*di))</a>
<a name="ln769">                        {</a>
<a name="ln770">                            act-&gt;move_to_pos(*di);</a>
<a name="ln771">                            if (act-&gt;is_player())</a>
<a name="ln772">                                stop_delay(true);</a>
<a name="ln773"> </a>
<a name="ln774">                            --push;</a>
<a name="ln775">                            pushed = true;</a>
<a name="ln776"> </a>
<a name="ln777">                            // Adjust wind path for moved monster</a>
<a name="ln778">                            wind_beam.target = *di;</a>
<a name="ln779">                            wind_beam.fire();</a>
<a name="ln780">                            success = true;</a>
<a name="ln781">                            break;</a>
<a name="ln782">                        }</a>
<a name="ln783">                    }</a>
<a name="ln784"> </a>
<a name="ln785">                    // If no luck, they slam into something.</a>
<a name="ln786">                    if (!success)</a>
<a name="ln787">                        collisions.insert(make_pair(act, newpos));</a>
<a name="ln788">                }</a>
<a name="ln789">            }</a>
<a name="ln790">        }</a>
<a name="ln791"> </a>
<a name="ln792">        if (pushed)</a>
<a name="ln793">        {</a>
<a name="ln794">            if (act-&gt;is_monster())</a>
<a name="ln795">            {</a>
<a name="ln796">                act-&gt;as_monster()-&gt;speed_increment -= random2(6) + 4;</a>
<a name="ln797">                if (you.can_see(*act))</a>
<a name="ln798">                    affected_monsters.add(act-&gt;as_monster());</a>
<a name="ln799">            }</a>
<a name="ln800">            else</a>
<a name="ln801">                player_affected = true;</a>
<a name="ln802">        }</a>
<a name="ln803">    }</a>
<a name="ln804"> </a>
<a name="ln805">    // Now move clouds</a>
<a name="ln806">    vector&lt;coord_def&gt; cloud_list;</a>
<a name="ln807">    for (distance_iterator di(agent-&gt;pos(), true, false, radius + 2); di; ++di)</a>
<a name="ln808">    {</a>
<a name="ln809">        if (cloud_at(*di)</a>
<a name="ln810">            &amp;&amp; cell_see_cell(agent-&gt;pos(), *di, LOS_SOLID)</a>
<a name="ln811">            &amp;&amp; (target.origin()</a>
<a name="ln812">                || _angle_between(agent-&gt;pos(), target, *di) &lt;= PI/4.0))</a>
<a name="ln813">        {</a>
<a name="ln814">            cloud_list.push_back(*di);</a>
<a name="ln815">        }</a>
<a name="ln816">    }</a>
<a name="ln817"> </a>
<a name="ln818">    for (int i = cloud_list.size() - 1; i &gt;= 0; --i)</a>
<a name="ln819">    {</a>
<a name="ln820">        wind_beam.target = cloud_list[i];</a>
<a name="ln821">        wind_beam.fire();</a>
<a name="ln822"> </a>
<a name="ln823">        int dist = cloud_list[i].distance_from(agent-&gt;pos());</a>
<a name="ln824">        int push = (dist &gt; 5 ? 2 : dist &gt; 2 ? 3 : 4);</a>
<a name="ln825"> </a>
<a name="ln826">        if (dist == 0 &amp;&amp; agent-&gt;is_player())</a>
<a name="ln827">        {</a>
<a name="ln828">            delete_cloud(agent-&gt;pos());</a>
<a name="ln829">            break;</a>
<a name="ln830">        }</a>
<a name="ln831"> </a>
<a name="ln832">        for (unsigned int j = 0;</a>
<a name="ln833">             j &lt; wind_beam.path_taken.size() - 1 &amp;&amp; push;</a>
<a name="ln834">             ++j)</a>
<a name="ln835">        {</a>
<a name="ln836">            if (wind_beam.path_taken[j] == cloud_list[i])</a>
<a name="ln837">            {</a>
<a name="ln838">                coord_def newpos = wind_beam.path_taken[j+1];</a>
<a name="ln839">                if (!cell_is_solid(newpos)</a>
<a name="ln840">                    &amp;&amp; !cloud_at(newpos))</a>
<a name="ln841">                {</a>
<a name="ln842">                    swap_clouds(newpos, wind_beam.path_taken[j]);</a>
<a name="ln843">                    --push;</a>
<a name="ln844">                }</a>
<a name="ln845">                else //Try to find an alternate route to push</a>
<a name="ln846">                {</a>
<a name="ln847">                    for (distance_iterator di(wind_beam.path_taken[j],</a>
<a name="ln848">                         false, true, 1); di; ++di)</a>
<a name="ln849">                    {</a>
<a name="ln850">                        if (di-&gt;distance_from(agent-&gt;pos())</a>
<a name="ln851">                                == newpos.distance_from(agent-&gt;pos())</a>
<a name="ln852">                            &amp;&amp; *di != agent-&gt;pos() // never aimed_at_feet</a>
<a name="ln853">                            &amp;&amp; !cell_is_solid(*di)</a>
<a name="ln854">                            &amp;&amp; !cloud_at(*di))</a>
<a name="ln855">                        {</a>
<a name="ln856">                            swap_clouds(*di, wind_beam.path_taken[j]);</a>
<a name="ln857">                            --push;</a>
<a name="ln858">                            wind_beam.target = *di;</a>
<a name="ln859">                            wind_beam.fire();</a>
<a name="ln860">                            j--;</a>
<a name="ln861">                            break;</a>
<a name="ln862">                        }</a>
<a name="ln863">                    }</a>
<a name="ln864">                }</a>
<a name="ln865">            }</a>
<a name="ln866">        }</a>
<a name="ln867">    }</a>
<a name="ln868"> </a>
<a name="ln869">    if (agent-&gt;is_player())</a>
<a name="ln870">    {</a>
<a name="ln871">        const string source = card ? &quot;card&quot; : &quot;fan&quot;;</a>
<a name="ln872"> </a>
<a name="ln873">        if (pow &gt; 120)</a>
<a name="ln874">            mprf(&quot;A mighty gale blasts forth from the %s!&quot;, source.c_str());</a>
<a name="ln875">        else</a>
<a name="ln876">            mprf(&quot;A fierce wind blows from the %s.&quot;, source.c_str());</a>
<a name="ln877">    }</a>
<a name="ln878"> </a>
<a name="ln879">    noisy(8, agent-&gt;pos());</a>
<a name="ln880"> </a>
<a name="ln881">    if (player_affected)</a>
<a name="ln882">        mpr(&quot;You are blown backwards!&quot;);</a>
<a name="ln883"> </a>
<a name="ln884">    if (!affected_monsters.empty())</a>
<a name="ln885">    {</a>
<a name="ln886">        const string message =</a>
<a name="ln887">            make_stringf(&quot;%s %s blown away by the wind.&quot;,</a>
<a name="ln888">                         affected_monsters.describe().c_str(),</a>
<a name="ln889">                         conjugate_verb(&quot;be&quot;, affected_monsters.count() &gt; 1).c_str());</a>
<a name="ln890">        if (strwidth(message) &lt; get_number_of_cols() - 2)</a>
<a name="ln891">            mpr(message);</a>
<a name="ln892">        else</a>
<a name="ln893">            mpr(&quot;The monsters around you are blown away!&quot;);</a>
<a name="ln894">    }</a>
<a name="ln895"> </a>
<a name="ln896">    for (auto it : collisions)</a>
<a name="ln897">        if (it.first-&gt;alive())</a>
<a name="ln898">            it.first-&gt;collide(it.second, agent, pow);</a>
<a name="ln899">}</a>
<a name="ln900"> </a>
<a name="ln901">static bool _phial_of_floods()</a>
<a name="ln902">{</a>
<a name="ln903">    if (you.confused())</a>
<a name="ln904">    {</a>
<a name="ln905">        canned_msg(MSG_TOO_CONFUSED);</a>
<a name="ln906">        return false;</a>
<a name="ln907">    }</a>
<a name="ln908"> </a>
<a name="ln909">    dist target;</a>
<a name="ln910">    bolt beam;</a>
<a name="ln911"> </a>
<a name="ln912">    if (you.confused())</a>
<a name="ln913">    {</a>
<a name="ln914">        canned_msg(MSG_TOO_CONFUSED);</a>
<a name="ln915">        return false;</a>
<a name="ln916">    }</a>
<a name="ln917"> </a>
<a name="ln918">    const int base_pow = 10 + you.skill(SK_EVOCATIONS, 4); // placeholder?</a>
<a name="ln919">    zappy(ZAP_PRIMAL_WAVE, base_pow, false, beam);</a>
<a name="ln920">    beam.range = LOS_RADIUS;</a>
<a name="ln921">    beam.aimed_at_spot = true;</a>
<a name="ln922"> </a>
<a name="ln923">    direction_chooser_args args;</a>
<a name="ln924">    args.mode = TARG_HOSTILE;</a>
<a name="ln925">    args.top_prompt = &quot;Aim the phial where?&quot;;</a>
<a name="ln926"> </a>
<a name="ln927">    if (spell_direction(target, beam, &amp;args)</a>
<a name="ln928">        &amp;&amp; player_tracer(ZAP_PRIMAL_WAVE, base_pow, beam))</a>
<a name="ln929">    {</a>
<a name="ln930">#if TAG_MAJOR_VERSION == 34</a>
<a name="ln931">        const int surge = pakellas_surge_devices();</a>
<a name="ln932">        surge_power(you.spec_evoke() + surge);</a>
<a name="ln933">#else</a>
<a name="ln934">        const int surge = 0;</a>
<a name="ln935">#endif</a>
<a name="ln936">        const int power = player_adjust_evoc_power(base_pow, surge);</a>
<a name="ln937">        // use real power to recalc hit/dam</a>
<a name="ln938">        zappy(ZAP_PRIMAL_WAVE, power, false, beam);</a>
<a name="ln939"> </a>
<a name="ln940">        beam.fire();</a>
<a name="ln941"> </a>
<a name="ln942">        // Flood the endpoint</a>
<a name="ln943">        coord_def center = beam.path_taken.back();</a>
<a name="ln944">        const int rnd_factor = random2(7);</a>
<a name="ln945">        int num = player_adjust_evoc_power(</a>
<a name="ln946">                      5 + you.skill_rdiv(SK_EVOCATIONS, 3, 5) + rnd_factor,</a>
<a name="ln947">                      surge);</a>
<a name="ln948">        int dur = player_adjust_evoc_power(</a>
<a name="ln949">                      40 + you.skill_rdiv(SK_EVOCATIONS, 8, 3),</a>
<a name="ln950">                      surge);</a>
<a name="ln951">        for (distance_iterator di(center, true, false, 2); di &amp;&amp; num &gt; 0; ++di)</a>
<a name="ln952">        {</a>
<a name="ln953">            const dungeon_feature_type feat = grd(*di);</a>
<a name="ln954">            if ((feat == DNGN_FLOOR || feat == DNGN_SHALLOW_WATER)</a>
<a name="ln955">                &amp;&amp; cell_see_cell(center, *di, LOS_NO_TRANS))</a>
<a name="ln956">            {</a>
<a name="ln957">                num--;</a>
<a name="ln958">                int time = random_range(dur * 2, dur * 3) - (di.radius() * 20);</a>
<a name="ln959">                temp_change_terrain(*di, DNGN_SHALLOW_WATER, time,</a>
<a name="ln960">                                    TERRAIN_CHANGE_FLOOD);</a>
<a name="ln961"> </a>
<a name="ln962">                monster* mons = monster_at(*di);</a>
<a name="ln963">                if (mons &amp;&amp; !mons-&gt;res_water_drowning())</a>
<a name="ln964">                {</a>
<a name="ln965">                    simple_monster_message(*mons, &quot; is engulfed in water.&quot;);</a>
<a name="ln966">                    mons-&gt;add_ench(mon_enchant(ENCH_WATERLOGGED, 0, &amp;you,</a>
<a name="ln967">                                               time));</a>
<a name="ln968">                }</a>
<a name="ln969">            }</a>
<a name="ln970">        }</a>
<a name="ln971"> </a>
<a name="ln972">        return true;</a>
<a name="ln973">    }</a>
<a name="ln974"> </a>
<a name="ln975">    return false;</a>
<a name="ln976">}</a>
<a name="ln977"> </a>
<a name="ln978">static spret _phantom_mirror()</a>
<a name="ln979">{</a>
<a name="ln980">    bolt beam;</a>
<a name="ln981">    monster* victim = nullptr;</a>
<a name="ln982">    dist spd;</a>
<a name="ln983">    targeter_smite tgt(&amp;you, LOS_RADIUS, 0, 0);</a>
<a name="ln984"> </a>
<a name="ln985">    direction_chooser_args args;</a>
<a name="ln986">    args.restricts = DIR_TARGET;</a>
<a name="ln987">    args.needs_path = false;</a>
<a name="ln988">    args.self = confirm_prompt_type::cancel;</a>
<a name="ln989">    args.top_prompt = &quot;Aiming: &lt;white&gt;Phantom Mirror&lt;/white&gt;&quot;;</a>
<a name="ln990">    args.hitfunc = &amp;tgt;</a>
<a name="ln991">    if (!spell_direction(spd, beam, &amp;args))</a>
<a name="ln992">        return spret::abort;</a>
<a name="ln993">    victim = monster_at(beam.target);</a>
<a name="ln994">    if (!victim || !you.can_see(*victim))</a>
<a name="ln995">    {</a>
<a name="ln996">        if (beam.target == you.pos())</a>
<a name="ln997">            mpr(&quot;You can't use the mirror on yourself.&quot;);</a>
<a name="ln998">        else</a>
<a name="ln999">            mpr(&quot;You can't see anything there to clone.&quot;);</a>
<a name="ln1000">        return spret::abort;</a>
<a name="ln1001">    }</a>
<a name="ln1002"> </a>
<a name="ln1003">    // Mirrored monsters (including by Mara, rakshasas) can still be</a>
<a name="ln1004">    // re-reflected.</a>
<a name="ln1005">    if (!actor_is_illusion_cloneable(victim)</a>
<a name="ln1006">        &amp;&amp; !victim-&gt;has_ench(ENCH_PHANTOM_MIRROR))</a>
<a name="ln1007">    {</a>
<a name="ln1008">        mpr(&quot;The mirror can't reflect that.&quot;);</a>
<a name="ln1009">        return spret::abort;</a>
<a name="ln1010">    }</a>
<a name="ln1011"> </a>
<a name="ln1012">    if (player_angers_monster(victim, false))</a>
<a name="ln1013">        return spret::abort;</a>
<a name="ln1014"> </a>
<a name="ln1015">#if TAG_MAJOR_VERSION == 34</a>
<a name="ln1016">    const int surge = pakellas_surge_devices();</a>
<a name="ln1017">    surge_power(you.spec_evoke() + surge);</a>
<a name="ln1018">#else</a>
<a name="ln1019">    const int surge = 0;</a>
<a name="ln1020">#endif</a>
<a name="ln1021"> </a>
<a name="ln1022">    monster* mon = clone_mons(victim, true, nullptr, ATT_FRIENDLY);</a>
<a name="ln1023">    if (!mon)</a>
<a name="ln1024">    {</a>
<a name="ln1025">        canned_msg(MSG_NOTHING_HAPPENS);</a>
<a name="ln1026">        return spret::fail;</a>
<a name="ln1027">    }</a>
<a name="ln1028">    const int power = player_adjust_evoc_power(5 + you.skill(SK_EVOCATIONS, 3),</a>
<a name="ln1029">                                               surge);</a>
<a name="ln1030">    int dur = min(6, max(1,</a>
<a name="ln1031">                         player_adjust_evoc_power(</a>
<a name="ln1032">                             you.skill(SK_EVOCATIONS, 1) / 4 + 1,</a>
<a name="ln1033">                             surge)</a>
<a name="ln1034">                         * (100 - victim-&gt;check_res_magic(power)) / 100));</a>
<a name="ln1035"> </a>
<a name="ln1036">    mon-&gt;mark_summoned(dur, true, SPELL_PHANTOM_MIRROR);</a>
<a name="ln1037"> </a>
<a name="ln1038">    mon-&gt;summoner = MID_PLAYER;</a>
<a name="ln1039">    mons_add_blame(mon, &quot;mirrored by the player character&quot;);</a>
<a name="ln1040">    mon-&gt;add_ench(ENCH_PHANTOM_MIRROR);</a>
<a name="ln1041">    mon-&gt;add_ench(mon_enchant(ENCH_DRAINED,</a>
<a name="ln1042">                              div_rand_round(mon-&gt;get_experience_level(), 3),</a>
<a name="ln1043">                              &amp;you, INFINITE_DURATION));</a>
<a name="ln1044"> </a>
<a name="ln1045">    mon-&gt;behaviour = BEH_SEEK;</a>
<a name="ln1046">    set_nearest_monster_foe(mon);</a>
<a name="ln1047"> </a>
<a name="ln1048">    mprf(&quot;You reflect %s with the mirror, and the mirror shatters!&quot;,</a>
<a name="ln1049">         victim-&gt;name(DESC_THE).c_str());</a>
<a name="ln1050"> </a>
<a name="ln1051">    return spret::success;</a>
<a name="ln1052">}</a>
<a name="ln1053"> </a>
<a name="ln1054">/**</a>
<a name="ln1055"> * Find an adjacent tile for a tremorstone explosion to go off in.</a>
<a name="ln1056"> *</a>
<a name="ln1057"> * @param center    The original target of the stone.</a>
<a name="ln1058"> * @return          The new, final origin of the stone's explosion.</a>
<a name="ln1059"> */</a>
<a name="ln1060">static coord_def _get_tremorstone_target(coord_def center)</a>
<a name="ln1061">{</a>
<a name="ln1062">    coord_def chosen = center;</a>
<a name="ln1063">    int seen = 1;</a>
<a name="ln1064">    for (adjacent_iterator ai(center); ai; ++ai)</a>
<a name="ln1065">        if (!cell_is_solid(*ai) &amp;&amp; one_chance_in(++seen))</a>
<a name="ln1066">            chosen = *ai;</a>
<a name="ln1067">    return chosen;</a>
<a name="ln1068">}</a>
<a name="ln1069"> </a>
<a name="ln1070">/**</a>
<a name="ln1071"> * Evokes a tremorstone, blasting something in the general area of a</a>
<a name="ln1072"> * chosen target.</a>
<a name="ln1073"> *</a>
<a name="ln1074"> * @return          spret::abort if the player cancels, spret::fail if they</a>
<a name="ln1075"> *                  try to evoke but fail, and spret::success otherwise.</a>
<a name="ln1076"> */</a>
<a name="ln1077">static spret _tremorstone()</a>
<a name="ln1078">{</a>
<a name="ln1079">    if (you.confused())</a>
<a name="ln1080">    {</a>
<a name="ln1081">        canned_msg(MSG_TOO_CONFUSED);</a>
<a name="ln1082">        return spret::abort;</a>
<a name="ln1083">    }</a>
<a name="ln1084"> </a>
<a name="ln1085">    dist target;</a>
<a name="ln1086">    bolt beam;</a>
<a name="ln1087"> </a>
<a name="ln1088">    static const int RADIUS = 2;</a>
<a name="ln1089">    static const int SPREAD = 1;</a>
<a name="ln1090">    static const int RANGE = RADIUS + SPREAD;</a>
<a name="ln1091"> </a>
<a name="ln1092">    beam.source_id  = MID_PLAYER;</a>
<a name="ln1093">    beam.thrower    = KILL_YOU;</a>
<a name="ln1094">    zappy(ZAP_TREMORSTONE, 1, false, beam);</a>
<a name="ln1095">    beam.range = RANGE;</a>
<a name="ln1096">    beam.ex_size = RADIUS;</a>
<a name="ln1097"> </a>
<a name="ln1098">    direction_chooser_args args;</a>
<a name="ln1099">    args.mode = TARG_HOSTILE;</a>
<a name="ln1100">    args.top_prompt = &quot;Throw a tremorstone where?&quot;;</a>
<a name="ln1101">    unique_ptr&lt;targeter&gt; hitfunc =</a>
<a name="ln1102">        make_unique&lt;targeter_beam&gt;(&amp;you, RANGE, ZAP_TREMORSTONE, 1, 1, 3);</a>
<a name="ln1103">    args.hitfunc = hitfunc.get();</a>
<a name="ln1104">    if (!spell_direction(target, beam, &amp;args))</a>
<a name="ln1105">        return spret::abort;</a>
<a name="ln1106"> </a>
<a name="ln1107">    if (grid_distance(beam.target, beam.source) &gt; beam.range)</a>
<a name="ln1108">    {</a>
<a name="ln1109">        mpr(&quot;That is beyond the maximum range.&quot;);</a>
<a name="ln1110">        return spret::abort;</a>
<a name="ln1111">    }</a>
<a name="ln1112"> </a>
<a name="ln1113">    if (cell_is_solid(beam.target))</a>
<a name="ln1114">    {</a>
<a name="ln1115">        const char *feat = feat_type_name(grd(beam.target));</a>
<a name="ln1116">        mprf(&quot;There's %s there.&quot;, article_a(feat).c_str());</a>
<a name="ln1117">        return spret::abort;</a>
<a name="ln1118">    }</a>
<a name="ln1119"> </a>
<a name="ln1120">    bolt tracer = beam;</a>
<a name="ln1121">    tracer.is_tracer = true;</a>
<a name="ln1122">    tracer.ex_size = RADIUS + SPREAD;</a>
<a name="ln1123">    tracer.explode(false);</a>
<a name="ln1124">    if (tracer.beam_cancelled)</a>
<a name="ln1125">        return spret::abort;</a>
<a name="ln1126"> </a>
<a name="ln1127">    mpr(&quot;The tremorstone explodes into fragments!&quot;);</a>
<a name="ln1128">    const coord_def center = beam.target;</a>
<a name="ln1129">    for (int i = 0; i &lt; 2; i++)</a>
<a name="ln1130">    {</a>
<a name="ln1131">        bolt explosion = beam;</a>
<a name="ln1132">        explosion.target = _get_tremorstone_target(center);</a>
<a name="ln1133">        explosion.explode(i == 1);</a>
<a name="ln1134">    }</a>
<a name="ln1135"> </a>
<a name="ln1136">    return spret::success;</a>
<a name="ln1137">}</a>
<a name="ln1138"> </a>
<a name="ln1139">bool evoke_check(int slot, bool quiet)</a>
<a name="ln1140">{</a>
<a name="ln1141">    const bool reaching = slot != -1 &amp;&amp; slot == you.equip[EQ_WEAPON]</a>
<a name="ln1142">                          &amp;&amp; !you.melded[EQ_WEAPON]</a>
<a name="ln1143">                          &amp;&amp; weapon_reach(*you.weapon()) &gt; REACH_NONE;</a>
<a name="ln1144"> </a>
<a name="ln1145">    if (you.berserk() &amp;&amp; !reaching)</a>
<a name="ln1146">    {</a>
<a name="ln1147">        if (!quiet)</a>
<a name="ln1148">            canned_msg(MSG_TOO_BERSERK);</a>
<a name="ln1149">        return false;</a>
<a name="ln1150">    }</a>
<a name="ln1151">    return true;</a>
<a name="ln1152">}</a>
<a name="ln1153"> </a>
<a name="ln1154">bool evoke_item(int slot)</a>
<a name="ln1155">{</a>
<a name="ln1156">    if (!evoke_check(slot))</a>
<a name="ln1157">        return false;</a>
<a name="ln1158"> </a>
<a name="ln1159">    if (slot == -1)</a>
<a name="ln1160">    {</a>
<a name="ln1161">        slot = prompt_invent_item(&quot;Evoke which item? (* to show all)&quot;,</a>
<a name="ln1162">                                   menu_type::invlist,</a>
<a name="ln1163">                                   OSEL_EVOKABLE, OPER_EVOKE);</a>
<a name="ln1164"> </a>
<a name="ln1165">        if (prompt_failed(slot))</a>
<a name="ln1166">            return false;</a>
<a name="ln1167">    }</a>
<a name="ln1168">    else if (!check_warning_inscriptions(you.inv[slot], OPER_EVOKE))</a>
<a name="ln1169">        return false;</a>
<a name="ln1170"> </a>
<a name="ln1171">    ASSERT(slot &gt;= 0);</a>
<a name="ln1172"> </a>
<a name="ln1173">#ifdef ASSERTS // Used only by an assert</a>
<a name="ln1174">    const bool wielded = (you.equip[EQ_WEAPON] == slot);</a>
<a name="ln1175">#endif /* DEBUG */</a>
<a name="ln1176"> </a>
<a name="ln1177">    item_def&amp; item = you.inv[slot];</a>
<a name="ln1178">    // Also handles messages.</a>
<a name="ln1179">    if (!item_is_evokable(item, true, false, true))</a>
<a name="ln1180">        return false;</a>
<a name="ln1181"> </a>
<a name="ln1182">    bool did_work   = false;  // &quot;Nothing happens&quot; message</a>
<a name="ln1183">    bool unevokable = false;</a>
<a name="ln1184"> </a>
<a name="ln1185">    const unrandart_entry *entry = is_unrandom_artefact(item)</a>
<a name="ln1186">        ? get_unrand_entry(item.unrand_idx) : nullptr;</a>
<a name="ln1187"> </a>
<a name="ln1188">    if (entry &amp;&amp; entry-&gt;evoke_func)</a>
<a name="ln1189">    {</a>
<a name="ln1190">        ASSERT(item_is_equipped(item));</a>
<a name="ln1191"> </a>
<a name="ln1192">        if (you.confused())</a>
<a name="ln1193">        {</a>
<a name="ln1194">            canned_msg(MSG_TOO_CONFUSED);</a>
<a name="ln1195">            return false;</a>
<a name="ln1196">        }</a>
<a name="ln1197"> </a>
<a name="ln1198">        bool qret = entry-&gt;evoke_func(&amp;item, &amp;did_work, &amp;unevokable);</a>
<a name="ln1199"> </a>
<a name="ln1200">        if (!unevokable)</a>
<a name="ln1201">            count_action(CACT_EVOKE, item.unrand_idx);</a>
<a name="ln1202"> </a>
<a name="ln1203">        // what even _is_ this return value?</a>
<a name="ln1204">        if (qret)</a>
<a name="ln1205">            return did_work;</a>
<a name="ln1206">    }</a>
<a name="ln1207">    else switch (item.base_type)</a>
<a name="ln1208">    {</a>
<a name="ln1209">    case OBJ_WANDS:</a>
<a name="ln1210">        zap_wand(slot);</a>
<a name="ln1211">        return true;</a>
<a name="ln1212"> </a>
<a name="ln1213">    case OBJ_WEAPONS:</a>
<a name="ln1214">        ASSERT(wielded);</a>
<a name="ln1215"> </a>
<a name="ln1216">        if (weapon_reach(item) &gt; REACH_NONE)</a>
<a name="ln1217">        {</a>
<a name="ln1218">            if (_reaching_weapon_attack(item))</a>
<a name="ln1219">                did_work = true;</a>
<a name="ln1220">            else</a>
<a name="ln1221">                return false;</a>
<a name="ln1222">        }</a>
<a name="ln1223">        else</a>
<a name="ln1224">            unevokable = true;</a>
<a name="ln1225">        break;</a>
<a name="ln1226"> </a>
<a name="ln1227">    case OBJ_STAVES:</a>
<a name="ln1228">        ASSERT(wielded);</a>
<a name="ln1229">        if (item.sub_type != STAFF_ENERGY)</a>
<a name="ln1230">        {</a>
<a name="ln1231">            unevokable = true;</a>
<a name="ln1232">            break;</a>
<a name="ln1233">        }</a>
<a name="ln1234"> </a>
<a name="ln1235">        if (you.confused())</a>
<a name="ln1236">        {</a>
<a name="ln1237">            canned_msg(MSG_TOO_CONFUSED);</a>
<a name="ln1238">            return false;</a>
<a name="ln1239">        }</a>
<a name="ln1240"> </a>
<a name="ln1241">        if (apply_starvation_penalties())</a>
<a name="ln1242">        {</a>
<a name="ln1243">            canned_msg(MSG_TOO_HUNGRY);</a>
<a name="ln1244">            return false;</a>
<a name="ln1245">        }</a>
<a name="ln1246">        else if (you.magic_points &gt;= you.max_magic_points)</a>
<a name="ln1247">        {</a>
<a name="ln1248">            canned_msg(MSG_FULL_MAGIC);</a>
<a name="ln1249">            return false;</a>
<a name="ln1250">        }</a>
<a name="ln1251">        else if (x_chance_in_y(apply_enhancement(</a>
<a name="ln1252">                                   you.skill(SK_EVOCATIONS, 100) + 1100,</a>
<a name="ln1253">                                   you.spec_evoke()),</a>
<a name="ln1254">                               4000))</a>
<a name="ln1255">        {</a>
<a name="ln1256">            mpr(&quot;You channel some magical energy.&quot;);</a>
<a name="ln1257">            inc_mp(1 + random2(3));</a>
<a name="ln1258">            make_hungry(50, false, true);</a>
<a name="ln1259">            did_work = true;</a>
<a name="ln1260">            practise_evoking(1);</a>
<a name="ln1261">            count_action(CACT_EVOKE, STAFF_ENERGY, OBJ_STAVES);</a>
<a name="ln1262"> </a>
<a name="ln1263">            did_god_conduct(DID_WIZARDLY_ITEM, 10);</a>
<a name="ln1264">            did_god_conduct(DID_CHANNEL, 1, true);</a>
<a name="ln1265">        }</a>
<a name="ln1266">        break;</a>
<a name="ln1267"> </a>
<a name="ln1268">    case OBJ_MISCELLANY:</a>
<a name="ln1269">        did_work = true; // easier to do it this way for misc items</a>
<a name="ln1270"> </a>
<a name="ln1271">        if (item.sub_type != MISC_ZIGGURAT)</a>
<a name="ln1272">        {</a>
<a name="ln1273">            if (you.get_mutation_level(MUT_NO_ARTIFICE))</a>
<a name="ln1274">            {</a>
<a name="ln1275">                mpr(&quot;You cannot evoke magical items.&quot;);</a>
<a name="ln1276">                return false;</a>
<a name="ln1277">            }</a>
<a name="ln1278">#if TAG_MAJOR_VERSION == 34</a>
<a name="ln1279">            if (player_under_penance(GOD_PAKELLAS))</a>
<a name="ln1280">            {</a>
<a name="ln1281">                simple_god_message(&quot;'s wrath prevents you from evoking &quot;</a>
<a name="ln1282">                                   &quot;devices!&quot;, GOD_PAKELLAS);</a>
<a name="ln1283">                return false;</a>
<a name="ln1284">            }</a>
<a name="ln1285">#endif</a>
<a name="ln1286">        }</a>
<a name="ln1287"> </a>
<a name="ln1288">        switch (item.sub_type)</a>
<a name="ln1289">        {</a>
<a name="ln1290">#if TAG_MAJOR_VERSION == 34</a>
<a name="ln1291">        case MISC_BOTTLED_EFREET:</a>
<a name="ln1292">            canned_msg(MSG_NOTHING_HAPPENS);</a>
<a name="ln1293">            return false;</a>
<a name="ln1294"> </a>
<a name="ln1295">        case MISC_FAN_OF_GALES:</a>
<a name="ln1296">            canned_msg(MSG_NOTHING_HAPPENS);</a>
<a name="ln1297">            return false;</a>
<a name="ln1298"> </a>
<a name="ln1299">        case MISC_LAMP_OF_FIRE:</a>
<a name="ln1300">            canned_msg(MSG_NOTHING_HAPPENS);</a>
<a name="ln1301">            return false;</a>
<a name="ln1302"> </a>
<a name="ln1303">        case MISC_STONE_OF_TREMORS:</a>
<a name="ln1304">            canned_msg(MSG_NOTHING_HAPPENS);</a>
<a name="ln1305">            return false;</a>
<a name="ln1306">#endif</a>
<a name="ln1307"> </a>
<a name="ln1308">        case MISC_PHIAL_OF_FLOODS:</a>
<a name="ln1309">            if (!evoker_charges(item.sub_type))</a>
<a name="ln1310">            {</a>
<a name="ln1311">                mpr(&quot;That is presently inert.&quot;);</a>
<a name="ln1312">                return false;</a>
<a name="ln1313">            }</a>
<a name="ln1314">            if (_phial_of_floods())</a>
<a name="ln1315">            {</a>
<a name="ln1316">                expend_xp_evoker(item.sub_type);</a>
<a name="ln1317">                practise_evoking(3);</a>
<a name="ln1318">            }</a>
<a name="ln1319">            else</a>
<a name="ln1320">                return false;</a>
<a name="ln1321">            break;</a>
<a name="ln1322"> </a>
<a name="ln1323">        case MISC_HORN_OF_GERYON:</a>
<a name="ln1324">            if (!evoker_charges(item.sub_type))</a>
<a name="ln1325">            {</a>
<a name="ln1326">                mpr(&quot;That is presently inert.&quot;);</a>
<a name="ln1327">                return false;</a>
<a name="ln1328">            }</a>
<a name="ln1329">            if (_evoke_horn_of_geryon())</a>
<a name="ln1330">            {</a>
<a name="ln1331">                expend_xp_evoker(item.sub_type);</a>
<a name="ln1332">                practise_evoking(3);</a>
<a name="ln1333">            }</a>
<a name="ln1334">            else</a>
<a name="ln1335">                return false;</a>
<a name="ln1336">            break;</a>
<a name="ln1337"> </a>
<a name="ln1338">        case MISC_BOX_OF_BEASTS:</a>
<a name="ln1339">            if (_box_of_beasts(item))</a>
<a name="ln1340">                practise_evoking(1);</a>
<a name="ln1341">            break;</a>
<a name="ln1342"> </a>
<a name="ln1343">#if TAG_MAJOR_VERSION == 34</a>
<a name="ln1344">        case MISC_SACK_OF_SPIDERS:</a>
<a name="ln1345">            canned_msg(MSG_NOTHING_HAPPENS);</a>
<a name="ln1346">            return false;</a>
<a name="ln1347"> </a>
<a name="ln1348">        case MISC_CRYSTAL_BALL_OF_ENERGY:</a>
<a name="ln1349">            canned_msg(MSG_NOTHING_HAPPENS);</a>
<a name="ln1350">            return false;</a>
<a name="ln1351">#endif</a>
<a name="ln1352"> </a>
<a name="ln1353">        case MISC_LIGHTNING_ROD:</a>
<a name="ln1354">            if (!evoker_charges(item.sub_type))</a>
<a name="ln1355">            {</a>
<a name="ln1356">                mpr(&quot;That is presently inert.&quot;);</a>
<a name="ln1357">                return false;</a>
<a name="ln1358">            }</a>
<a name="ln1359">            if (_lightning_rod())</a>
<a name="ln1360">            {</a>
<a name="ln1361">                practise_evoking(1);</a>
<a name="ln1362">                expend_xp_evoker(item.sub_type);</a>
<a name="ln1363">                if (!evoker_charges(item.sub_type))</a>
<a name="ln1364">                    mpr(&quot;The lightning rod overheats!&quot;);</a>
<a name="ln1365">            }</a>
<a name="ln1366">            else</a>
<a name="ln1367">                return false;</a>
<a name="ln1368">            break;</a>
<a name="ln1369"> </a>
<a name="ln1370">        case MISC_QUAD_DAMAGE:</a>
<a name="ln1371">            mpr(&quot;QUAD DAMAGE!&quot;);</a>
<a name="ln1372">            you.duration[DUR_QUAD_DAMAGE] = 30 * BASELINE_DELAY;</a>
<a name="ln1373">            ASSERT(in_inventory(item));</a>
<a name="ln1374">            dec_inv_item_quantity(item.link, 1);</a>
<a name="ln1375">            invalidate_agrid(true);</a>
<a name="ln1376">            break;</a>
<a name="ln1377"> </a>
<a name="ln1378">        case MISC_PHANTOM_MIRROR:</a>
<a name="ln1379">            switch (_phantom_mirror())</a>
<a name="ln1380">            {</a>
<a name="ln1381">                default:</a>
<a name="ln1382">                case spret::abort:</a>
<a name="ln1383">                    return false;</a>
<a name="ln1384"> </a>
<a name="ln1385">                case spret::success:</a>
<a name="ln1386">                    ASSERT(in_inventory(item));</a>
<a name="ln1387">                    dec_inv_item_quantity(item.link, 1);</a>
<a name="ln1388">                    // deliberate fall-through</a>
<a name="ln1389">                case spret::fail:</a>
<a name="ln1390">                    practise_evoking(1);</a>
<a name="ln1391">                    break;</a>
<a name="ln1392">            }</a>
<a name="ln1393">            break;</a>
<a name="ln1394"> </a>
<a name="ln1395">        case MISC_ZIGGURAT:</a>
<a name="ln1396">            // Don't set did_work to false, _make_zig handles the message.</a>
<a name="ln1397">            unevokable = !_make_zig(item);</a>
<a name="ln1398">            break;</a>
<a name="ln1399"> </a>
<a name="ln1400">        case MISC_TIN_OF_TREMORSTONES:</a>
<a name="ln1401">            switch (_tremorstone())</a>
<a name="ln1402">            {</a>
<a name="ln1403">                default:</a>
<a name="ln1404">                case spret::abort:</a>
<a name="ln1405">                    return false;</a>
<a name="ln1406"> </a>
<a name="ln1407">                case spret::success:</a>
<a name="ln1408">                    if (one_chance_in(3))</a>
<a name="ln1409">                    {</a>
<a name="ln1410">                        mpr(&quot;The tin disintegrates.&quot;);</a>
<a name="ln1411">                        ASSERT(in_inventory(item));</a>
<a name="ln1412">                        dec_inv_item_quantity(item.link, 1);</a>
<a name="ln1413">                    }</a>
<a name="ln1414">                    break;</a>
<a name="ln1415"> </a>
<a name="ln1416">                case spret::fail:</a>
<a name="ln1417">                    break;</a>
<a name="ln1418">            }</a>
<a name="ln1419">            break;</a>
<a name="ln1420"> </a>
<a name="ln1421">        default:</a>
<a name="ln1422">            did_work = false;</a>
<a name="ln1423">            unevokable = true;</a>
<a name="ln1424">            break;</a>
<a name="ln1425">        }</a>
<a name="ln1426">        if (did_work &amp;&amp; !unevokable)</a>
<a name="ln1427">            count_action(CACT_EVOKE, item.sub_type, OBJ_MISCELLANY);</a>
<a name="ln1428">        break;</a>
<a name="ln1429"> </a>
<a name="ln1430">    default:</a>
<a name="ln1431">        unevokable = true;</a>
<a name="ln1432">        break;</a>
<a name="ln1433">    }</a>
<a name="ln1434"> </a>
<a name="ln1435">    if (!did_work)</a>
<a name="ln1436">        canned_msg(MSG_NOTHING_HAPPENS);</a>
<a name="ln1437"> </a>
<a name="ln1438">    if (!unevokable)</a>
<a name="ln1439">        you.turn_is_over = true;</a>
<a name="ln1440">    else</a>
<a name="ln1441">        crawl_state.zero_turns_taken();</a>
<a name="ln1442"> </a>
<a name="ln1443">    return did_work;</a>
<a name="ln1444">}</a>

</code></pre>
<div class="balloon" rel="709"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v648/" target="_blank">V648</a> Priority of the '&&' operation is higher than that of the '||' operation.</p></div>

<link rel="stylesheet" href="highlight.css">
<script src="highlight.pack.js"></script>
<script src="highlightjs-line-numbers.js"></script>
<script>hljs.initHighlightingOnLoad();</script>
<script>hljs.initLineNumbersOnLoad();</script>
<script>
  $(document).ready(function() {
      $('.balloon').each(function () {
          var bl = $(this);
          var line = bl.attr('rel');
          var text = $('a[name="ln'+line+'"]').text();

          var space_count = 0;
          for(var i = 0; i<text.length; i++){
              var char = text[i];
              if((char !== ' ')&&(char !== '\t'))break;
              if(char === '\t')space_count++;
              space_count++;
          }

          bl.css('margin-left', space_count*8);
          $('a[name="ln'+line+'"]').after(bl);
      });

      window.location = window.location;
  });
</script>
</body>
</html>
