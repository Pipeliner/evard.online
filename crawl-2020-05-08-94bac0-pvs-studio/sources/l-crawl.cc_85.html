
<html>
<head>

  <meta http-equiv="Content-Type" content="text/html; charset=US-ASCII" />
  <title>l-crawl.cc</title>

  <link rel="stylesheet" href="../style.css"/>
  <script src="../jquery-3.2.1.min.js"></script>
</head>
<body>

<pre><code class = "cpp">
<a name="ln1">/*** General crawl related functions, including interaction.</a>
<a name="ln2"> * @module crawl</a>
<a name="ln3"> */</a>
<a name="ln4"> </a>
<a name="ln5">#include &quot;AppHdr.h&quot;</a>
<a name="ln6"> </a>
<a name="ln7">#include &quot;l-libs.h&quot;</a>
<a name="ln8"> </a>
<a name="ln9">#include &quot;branch.h&quot;</a>
<a name="ln10">#include &quot;chardump.h&quot;</a>
<a name="ln11">#include &quot;cluautil.h&quot;</a>
<a name="ln12">#include &quot;command.h&quot;</a>
<a name="ln13">#include &quot;delay.h&quot;</a>
<a name="ln14">#include &quot;directn.h&quot;</a>
<a name="ln15">#include &quot;dlua.h&quot;</a>
<a name="ln16">#include &quot;end.h&quot;</a>
<a name="ln17">#include &quot;english.h&quot;</a>
<a name="ln18">#include &quot;fight.h&quot;</a>
<a name="ln19">#include &quot;hints.h&quot;</a>
<a name="ln20">#include &quot;initfile.h&quot;</a>
<a name="ln21">#include &quot;item-name.h&quot;</a>
<a name="ln22">#include &quot;libutil.h&quot;</a>
<a name="ln23">#include &quot;macro.h&quot;</a>
<a name="ln24">#include &quot;menu.h&quot;</a>
<a name="ln25">#include &quot;message.h&quot;</a>
<a name="ln26">#include &quot;notes.h&quot;</a>
<a name="ln27">#include &quot;output.h&quot;</a>
<a name="ln28">#include &quot;perlin.h&quot;</a>
<a name="ln29">#include &quot;prompt.h&quot;</a>
<a name="ln30">#include &quot;religion.h&quot;</a>
<a name="ln31">#include &quot;sound.h&quot;</a>
<a name="ln32">#include &quot;state.h&quot;</a>
<a name="ln33">#include &quot;state.h&quot;</a>
<a name="ln34">#include &quot;stringutil.h&quot;</a>
<a name="ln35">#include &quot;tutorial.h&quot;</a>
<a name="ln36">#include &quot;unwind.h&quot;</a>
<a name="ln37">#include &quot;version.h&quot;</a>
<a name="ln38">#include &quot;view.h&quot;</a>
<a name="ln39">#include &quot;worley.h&quot;</a>
<a name="ln40"> </a>
<a name="ln41">#ifdef TARGET_OS_WINDOWS</a>
<a name="ln42"># include &quot;windows.h&quot;</a>
<a name="ln43">#else</a>
<a name="ln44"># include &lt;sys/time.h&gt;</a>
<a name="ln45"># include &lt;time.h&gt;</a>
<a name="ln46">#endif</a>
<a name="ln47"> </a>
<a name="ln48">//</a>
<a name="ln49">// User accessible (clua) functions</a>
<a name="ln50">//</a>
<a name="ln51"> </a>
<a name="ln52">/*** Print a message.</a>
<a name="ln53"> * @tparam string message message to print</a>
<a name="ln54"> * @param channel channel to print on; defaults to 0 (&lt;code&gt;MSGCH_PLAIN&lt;/code&gt;)</a>
<a name="ln55"> * @function mpr</a>
<a name="ln56"> */</a>
<a name="ln57">static int crawl_mpr(lua_State *ls)</a>
<a name="ln58">{</a>
<a name="ln59">    if (!crawl_state.io_inited)</a>
<a name="ln60">        return 0;</a>
<a name="ln61"> </a>
<a name="ln62">    const char *message = luaL_checkstring(ls, 1);</a>
<a name="ln63">    if (!message)</a>
<a name="ln64">        return 0;</a>
<a name="ln65"> </a>
<a name="ln66">    int ch = MSGCH_PLAIN;</a>
<a name="ln67">    if (lua_isnumber(ls, 2))</a>
<a name="ln68">        ch = luaL_safe_checkint(ls, 2);</a>
<a name="ln69">    else</a>
<a name="ln70">    {</a>
<a name="ln71">        const char *channel = lua_tostring(ls, 2);</a>
<a name="ln72">        if (channel)</a>
<a name="ln73">            ch = str_to_channel(channel);</a>
<a name="ln74">    }</a>
<a name="ln75"> </a>
<a name="ln76">    if (ch &lt; 0 || ch &gt;= NUM_MESSAGE_CHANNELS)</a>
<a name="ln77">        ch = MSGCH_PLAIN;</a>
<a name="ln78"> </a>
<a name="ln79">    mprf(static_cast&lt;msg_channel_type&gt;(ch), &quot;%s&quot;, message);</a>
<a name="ln80">    return 0;</a>
<a name="ln81">}</a>
<a name="ln82"> </a>
<a name="ln83">/*** Print a formatted message.</a>
<a name="ln84"> * @tparam string message message to print</a>
<a name="ln85"> * @param channel channel to print on; defaults to 0 (&lt;code&gt;MSGCH_PLAIN&lt;/code&gt;)</a>
<a name="ln86"> * @function formatted_mpr</a>
<a name="ln87"> */</a>
<a name="ln88">static int crawl_formatted_mpr(lua_State *ls)</a>
<a name="ln89">{</a>
<a name="ln90">    if (!crawl_state.io_inited)</a>
<a name="ln91">        return 0;</a>
<a name="ln92"> </a>
<a name="ln93">    const char *message = luaL_checkstring(ls, 1);</a>
<a name="ln94">    if (!message)</a>
<a name="ln95">        return 0;</a>
<a name="ln96"> </a>
<a name="ln97">    int ch = MSGCH_PLAIN;</a>
<a name="ln98">    if (lua_isnumber(ls, 2))</a>
<a name="ln99">        ch = luaL_safe_checkint(ls, 2);</a>
<a name="ln100">    else</a>
<a name="ln101">    {</a>
<a name="ln102">        const char *channel = lua_tostring(ls, 2);</a>
<a name="ln103">        if (channel)</a>
<a name="ln104">            ch = str_to_channel(channel);</a>
<a name="ln105">    }</a>
<a name="ln106"> </a>
<a name="ln107">    if (ch &lt; 0 || ch &gt;= NUM_MESSAGE_CHANNELS)</a>
<a name="ln108">        ch = MSGCH_PLAIN;</a>
<a name="ln109"> </a>
<a name="ln110">    formatted_mpr(formatted_string::parse_string(message),</a>
<a name="ln111">                  static_cast&lt;msg_channel_type&gt;(ch));</a>
<a name="ln112">    return 0;</a>
<a name="ln113">}</a>
<a name="ln114"> </a>
<a name="ln115">/*** Print to stderr for debugging hooks.</a>
<a name="ln116"> * @tparam string text</a>
<a name="ln117"> * @function stderr</a>
<a name="ln118"> */</a>
<a name="ln119">LUAFN(crawl_stderr)</a>
<a name="ln120">{</a>
<a name="ln121">    const char *text = luaL_checkstring(ls, 1);</a>
<a name="ln122">    fprintf(stderr, &quot;%s\n&quot;, text);</a>
<a name="ln123">    return 0;</a>
<a name="ln124">}</a>
<a name="ln125"> </a>
<a name="ln126">/*** Print to the debugging channel, which is desplayed only for debug builds.</a>
<a name="ln127"> * @tparam string text</a>
<a name="ln128"> * @function dpr</a>
<a name="ln129"> */</a>
<a name="ln130">LUAFN(crawl_dpr)</a>
<a name="ln131">{</a>
<a name="ln132">#ifdef DEBUG_DIAGNOSTICS</a>
<a name="ln133">    const char *text = luaL_checkstring(ls, 1);</a>
<a name="ln134">    if (crawl_state.io_inited)</a>
<a name="ln135">        dprf(&quot;%s&quot;, text);</a>
<a name="ln136">#else</a>
<a name="ln137">    UNUSED(ls);</a>
<a name="ln138">#endif</a>
<a name="ln139">    return 0;</a>
<a name="ln140">}</a>
<a name="ln141"> </a>
<a name="ln142">/*** Delay the display.</a>
<a name="ln143"> * @tparam int ms delay in milliseconds</a>
<a name="ln144"> * @function delay</a>
<a name="ln145"> */</a>
<a name="ln146">LUAWRAP(crawl_delay, delay(luaL_safe_checkint(ls, 1)))</a>
<a name="ln147">/*** Display a `--- more ---` prompt</a>
<a name="ln148"> * @function more</a>
<a name="ln149"> */</a>
<a name="ln150">LUAWRAP(crawl_more, more())</a>
<a name="ln151">/*** Flush the previous message to the window.</a>
<a name="ln152"> * @function flush_prev_message</a>
<a name="ln153"> */</a>
<a name="ln154">LUAWRAP(crawl_flush_prev_message, flush_prev_message())</a>
<a name="ln155">/*** Clear the message window.</a>
<a name="ln156"> * @tparam boolean force</a>
<a name="ln157"> * @function clear_messages</a>
<a name="ln158"> * */</a>
<a name="ln159">LUAWRAP(crawl_clear_messages,</a>
<a name="ln160">clear_messages(lua_isboolean(ls, 1) ? lua_toboolean(ls, 1) : false))</a>
<a name="ln161">/*** Redraw the screen.</a>
<a name="ln162"> * @function redraw_screen */</a>
<a name="ln163">LUAWRAP(crawl_redraw_screen, redraw_screen())</a>
<a name="ln164"> </a>
<a name="ln165">/*** Toggle autoclearing of `--- more ---` prompts.</a>
<a name="ln166"> * @tparam boolean flag</a>
<a name="ln167"> * @function set_more_autoclear</a>
<a name="ln168"> */</a>
<a name="ln169">static int crawl_set_more_autoclear(lua_State *ls)</a>
<a name="ln170">{</a>
<a name="ln171">    if (lua_isnone(ls, 1))</a>
<a name="ln172">    {</a>
<a name="ln173">        luaL_argerror(ls, 1, &quot;needs a boolean argument&quot;);</a>
<a name="ln174">        return 0;</a>
<a name="ln175">    }</a>
<a name="ln176">    set_more_autoclear(lua_toboolean(ls, 1));</a>
<a name="ln177"> </a>
<a name="ln178">    return 0;</a>
<a name="ln179">}</a>
<a name="ln180"> </a>
<a name="ln181">/*** Toggle the use of `--- more ---` prompts.</a>
<a name="ln182"> * @tparam boolean flag</a>
<a name="ln183"> * @function enable_more</a>
<a name="ln184"> */</a>
<a name="ln185">static int crawl_enable_more(lua_State *ls)</a>
<a name="ln186">{</a>
<a name="ln187">    if (lua_isnone(ls, 1))</a>
<a name="ln188">    {</a>
<a name="ln189">        luaL_argerror(ls, 1, &quot;needs a boolean argument&quot;);</a>
<a name="ln190">        return 0;</a>
<a name="ln191">    }</a>
<a name="ln192">    crawl_state.show_more_prompt = lua_toboolean(ls, 1);</a>
<a name="ln193"> </a>
<a name="ln194">    return 0;</a>
<a name="ln195">}</a>
<a name="ln196"> </a>
<a name="ln197">/*** Cancellably prompt the user for a line of input.</a>
<a name="ln198"> * The line is limited to 500 characters.</a>
<a name="ln199"> * @treturn string|nil a string if one is input or nil if input is cancelled</a>
<a name="ln200"> * @function c_input_line</a>
<a name="ln201"> */</a>
<a name="ln202">static int crawl_c_input_line(lua_State *ls)</a>
<a name="ln203">{</a>
<a name="ln204">    char linebuf[500];</a>
<a name="ln205"> </a>
<a name="ln206">    bool valid = !cancellable_get_line(linebuf, sizeof linebuf);</a>
<a name="ln207">    if (valid)</a>
<a name="ln208">        lua_pushstring(ls, linebuf);</a>
<a name="ln209">    else</a>
<a name="ln210">        lua_pushnil(ls);</a>
<a name="ln211">    return 1;</a>
<a name="ln212">}</a>
<a name="ln213"> </a>
<a name="ln214">/*** Prompt the user to choose a location via the targeting screen.</a>
<a name="ln215"> * This is useful for scripts that require a user-selected target. For example,</a>
<a name="ln216"> * one could imagine a &quot;mark dangerous monster&quot; script that would place a large</a>
<a name="ln217"> * exclusion around a user-chosen monster that would then be deleted if the</a>
<a name="ln218"> * monster moved or died. This function could be used for the user to select</a>
<a name="ln219"> * a target monster.</a>
<a name="ln220"> * @treturn int, int the relative position of the chosen location to the user</a>
<a name="ln221"> * @function get_target</a>
<a name="ln222"> */</a>
<a name="ln223">LUAFN(crawl_get_target) {</a>
<a name="ln224">    coord_def out;</a>
<a name="ln225"> </a>
<a name="ln226">    if (!get_look_position(&amp;out))</a>
<a name="ln227">        return 0;</a>
<a name="ln228"> </a>
<a name="ln229">    lua_pushinteger(ls, out.x - you.position.x);</a>
<a name="ln230">    lua_pushinteger(ls, out.y - you.position.y);</a>
<a name="ln231"> </a>
<a name="ln232">    return 2;</a>
<a name="ln233">}</a>
<a name="ln234"> </a>
<a name="ln235">/*** Get input key (combo).</a>
<a name="ln236"> * @treturn int the key (combo) input</a>
<a name="ln237"> * @function getch */</a>
<a name="ln238">LUARET1(crawl_getch, number, getchm())</a>
<a name="ln239">/*** Check for pending input.</a>
<a name="ln240"> * @return int 1 if there is, 0 otherwise</a>
<a name="ln241"> * @function kbhit</a>
<a name="ln242"> */</a>
<a name="ln243">LUARET1(crawl_kbhit, number, kbhit())</a>
<a name="ln244">/*** Flush the input buffer (typeahead).</a>
<a name="ln245"> * @function flush_input</a>
<a name="ln246"> */</a>
<a name="ln247">LUAWRAP(crawl_flush_input, flush_input_buffer(FLUSH_LUA))</a>
<a name="ln248"> </a>
<a name="ln249">static char _lua_char(lua_State *ls, int ndx, char defval = 0)</a>
<a name="ln250">{</a>
<a name="ln251">    return lua_isnone(ls, ndx) || !lua_isstring(ls, ndx)? defval</a>
<a name="ln252">           : lua_tostring(ls, ndx)[0];</a>
<a name="ln253">}</a>
<a name="ln254"> </a>
<a name="ln255">/*** Ask the player a yes/no question.</a>
<a name="ln256"> * The player is supposed to answer by pressing Y or N.</a>
<a name="ln257"> * @tparam string prompt question for the user</a>
<a name="ln258"> * @tparam boolean safe accept lowercase answers</a>
<a name="ln259"> * @tparam[opt] string|nil safeanswer if a letter, this will be considered a</a>
<a name="ln260"> * safe default</a>
<a name="ln261"> * @tparam[optchain=true] boolean clear_after clear the question after the user</a>
<a name="ln262"> * answers</a>
<a name="ln263"> * @tparam[optchain=true] boolean interrupt_delays interrupt any ongoing delays</a>
<a name="ln264"> * to ask the question</a>
<a name="ln265"> * @tparam[optchain=false] boolean noprompt skip asking the question;</a>
<a name="ln266"> * just wait for the answer</a>
<a name="ln267"> * @function yesno</a>
<a name="ln268"> */</a>
<a name="ln269">static int crawl_yesno(lua_State *ls)</a>
<a name="ln270">{</a>
<a name="ln271">    const char *prompt = luaL_checkstring(ls, 1);</a>
<a name="ln272">    const bool safe = lua_toboolean(ls, 2);</a>
<a name="ln273">    const int safeanswer = _lua_char(ls, 3);</a>
<a name="ln274">    const bool clear_after =</a>
<a name="ln275">        lua_isnone(ls, 4) ? true : lua_toboolean(ls, 4);</a>
<a name="ln276">    const bool interrupt_delays =</a>
<a name="ln277">        lua_isnone(ls, 5) ? true : lua_toboolean(ls, 5);</a>
<a name="ln278">    const bool noprompt =</a>
<a name="ln279">        lua_isnone(ls, 6) ? false : lua_toboolean(ls, 6);</a>
<a name="ln280"> </a>
<a name="ln281">    lua_pushboolean(ls, yesno(prompt, safe, safeanswer, clear_after,</a>
<a name="ln282">                              interrupt_delays, noprompt));</a>
<a name="ln283">    return 1;</a>
<a name="ln284">}</a>
<a name="ln285"> </a>
<a name="ln286">/*** Ask the player a yes/no/quit question.</a>
<a name="ln287"> * Mostly like yesno(), but doesn't support as many</a>
<a name="ln288"> * parameters in this Lua binding.</a>
<a name="ln289"> * @tparam string prompt question for the user</a>
<a name="ln290"> * @tparam boolean safe accept lowercase answers</a>
<a name="ln291"> * @tparam[opt] string|nil safeanswer if a letter, this will be considered a</a>
<a name="ln292"> * safe default</a>
<a name="ln293"> * @tparam[optchain=false] boolean allow_all actually ask a yes/no/quit/all</a>
<a name="ln294"> * question</a>
<a name="ln295"> * @tparam[optchain=true] boolean clear_after clear the question after the user</a>
<a name="ln296"> * answers</a>
<a name="ln297"> * @function yesnoquit</a>
<a name="ln298"> */</a>
<a name="ln299">static int crawl_yesnoquit(lua_State *ls)</a>
<a name="ln300">{</a>
<a name="ln301">    const char *prompt = luaL_checkstring(ls, 1);</a>
<a name="ln302">    const bool safe = lua_toboolean(ls, 2);</a>
<a name="ln303">    const int safeanswer = _lua_char(ls, 3);</a>
<a name="ln304">    const bool allow_all =</a>
<a name="ln305">        lua_isnone(ls, 4) ? false : lua_toboolean(ls, 4);</a>
<a name="ln306">    const bool clear_after =</a>
<a name="ln307">        lua_isnone(ls, 5) ? true : lua_toboolean(ls, 5);</a>
<a name="ln308"> </a>
<a name="ln309">    // Skipping the other params until somebody needs them.</a>
<a name="ln310"> </a>
<a name="ln311">    lua_pushnumber(ls, yesnoquit(prompt, safe, safeanswer, allow_all,</a>
<a name="ln312">                                 clear_after));</a>
<a name="ln313">    return 1;</a>
<a name="ln314">}</a>
<a name="ln315"> </a>
<a name="ln316">static void crawl_sendkeys_proc(lua_State *ls, int argi)</a>
<a name="ln317">{</a>
<a name="ln318">    if (lua_isstring(ls, argi))</a>
<a name="ln319">    {</a>
<a name="ln320">        const char *keys = luaL_checkstring(ls, argi);</a>
<a name="ln321">        if (!keys)</a>
<a name="ln322">            return;</a>
<a name="ln323"> </a>
<a name="ln324">        char32_t wc;</a>
<a name="ln325">        while (int len = utf8towc(&amp;wc, keys))</a>
<a name="ln326">        {</a>
<a name="ln327">            macro_sendkeys_end_add_expanded(wc);</a>
<a name="ln328">            keys += len;</a>
<a name="ln329">        }</a>
<a name="ln330">    }</a>
<a name="ln331">    else if (lua_istable(ls, argi))</a>
<a name="ln332">    {</a>
<a name="ln333">        for (int i = 1; ; ++i)</a>
<a name="ln334">        {</a>
<a name="ln335">            lua_rawgeti(ls, argi, i);</a>
<a name="ln336">            if (lua_isnil(ls, -1))</a>
<a name="ln337">            {</a>
<a name="ln338">                lua_pop(ls, 1);</a>
<a name="ln339">                return;</a>
<a name="ln340">            }</a>
<a name="ln341"> </a>
<a name="ln342">            crawl_sendkeys_proc(ls, lua_gettop(ls));</a>
<a name="ln343">            lua_pop(ls, 1);</a>
<a name="ln344">        }</a>
<a name="ln345">    }</a>
<a name="ln346">    else if (lua_isnumber(ls, argi))</a>
<a name="ln347">        macro_sendkeys_end_add_expanded(luaL_safe_checkint(ls, argi));</a>
<a name="ln348">}</a>
<a name="ln349"> </a>
<a name="ln350">/*** Send keypresses to crawl.</a>
<a name="ln351"> * A flexible variadic function to send input to crawl. Will process any number</a>
<a name="ln352"> * of arguments. Each argument can be a string, keycode number, or array of the</a>
<a name="ln353"> * previous two types. They are processed in left-to-right order.</a>
<a name="ln354"> * @tparam string|int|array keys</a>
<a name="ln355"> * @param[opt] ...</a>
<a name="ln356"> * @function sendkeys</a>
<a name="ln357"> */</a>
<a name="ln358">static int crawl_sendkeys(lua_State *ls)</a>
<a name="ln359">{</a>
<a name="ln360">    int top = lua_gettop(ls);</a>
<a name="ln361">    for (int i = 1; i &lt;= top; ++i)</a>
<a name="ln362">        crawl_sendkeys_proc(ls, i);</a>
<a name="ln363">    return 0;</a>
<a name="ln364">}</a>
<a name="ln365"> </a>
<a name="ln366">/*** Tell crawl to process a current macro delay.</a>
<a name="ln367"> * @return boolean whether it will actually do so</a>
<a name="ln368"> * @function process_command</a>
<a name="ln369"> */</a>
<a name="ln370">static int crawl_process_command(lua_State *ls)</a>
<a name="ln371">{</a>
<a name="ln372">    const bool will_process =</a>
<a name="ln373">        !you_are_delayed() || current_delay()-&gt;is_macro();</a>
<a name="ln374"> </a>
<a name="ln375">    if (will_process)</a>
<a name="ln376">    {</a>
<a name="ln377">        // This should only be called from a macro delay, but run_macro</a>
<a name="ln378">        // may not have started the macro delay; do so now.</a>
<a name="ln379">        if (!you_are_delayed())</a>
<a name="ln380">            start_delay&lt;MacroDelay&gt;();</a>
<a name="ln381">        start_delay&lt;MacroProcessKeyDelay&gt;();</a>
<a name="ln382">    }</a>
<a name="ln383"> </a>
<a name="ln384">    lua_pushboolean(ls, will_process);</a>
<a name="ln385">    return 1;</a>
<a name="ln386">}</a>
<a name="ln387"> </a>
<a name="ln388">static bool _check_can_do_command(lua_State *ls)</a>
<a name="ln389">{</a>
<a name="ln390">    auto delay = current_delay();</a>
<a name="ln391">    if (delay &amp;&amp; !delay-&gt;is_macro())</a>
<a name="ln392">    {</a>
<a name="ln393">        luaL_error(ls, &quot;Cannot currently process new keys (%s delay active)&quot;,</a>
<a name="ln394">                   delay-&gt;name());</a>
<a name="ln395">        return false;</a>
<a name="ln396">    }</a>
<a name="ln397"> </a>
<a name="ln398">    if (you.turn_is_over)</a>
<a name="ln399">    {</a>
<a name="ln400">        luaL_error(ls, &quot;Cannot currently process new keys (turn is over)&quot;);</a>
<a name="ln401">        return false;</a>
<a name="ln402">    }</a>
<a name="ln403"> </a>
<a name="ln404">    return true;</a>
<a name="ln405">}</a>
<a name="ln406"> </a>
<a name="ln407">/*** Process a string of input keys</a>
<a name="ln408"> * The first key of the first argument must be a command key in the default key</a>
<a name="ln409"> * context. The subsequent keys are processed as in sendkeys().</a>
<a name="ln410"> * @tparam string keys</a>
<a name="ln411"> * @tparam[opt=false] boolean hide hide targeter while processing</a>
<a name="ln412"> * @function process_keys</a>
<a name="ln413"> */</a>
<a name="ln414">static int crawl_process_keys(lua_State *ls)</a>
<a name="ln415">{</a>
<a name="ln416">    if (!_check_can_do_command(ls))</a>
<a name="ln417">        return 0;</a>
<a name="ln418"> </a>
<a name="ln419">    // if there's pending input, pushing to the end of the buffer may separate</a>
<a name="ln420">    // the first element of the sequence from the rest. TODO: should this be</a>
<a name="ln421">    // changed to push the key sequence to the beginning of the buffer? See</a>
<a name="ln422">    // crawl_do_commands below.</a>
<a name="ln423">    if (has_pending_input())</a>
<a name="ln424">    {</a>
<a name="ln425">        luaL_error(ls,</a>
<a name="ln426">                &quot;Cannot currently process new keys (there is pending input)&quot;);</a>
<a name="ln427">        return 0;</a>
<a name="ln428">    }</a>
<a name="ln429"> </a>
<a name="ln430"> </a>
<a name="ln431">    const char* keys = luaL_checkstring(ls, 1);</a>
<a name="ln432"> </a>
<a name="ln433">    if (strlen(keys) == 0)</a>
<a name="ln434">    {</a>
<a name="ln435">        luaL_argerror(ls, 1, &quot;Must have at least one key to process.&quot;);</a>
<a name="ln436">        return 0;</a>
<a name="ln437">    }</a>
<a name="ln438"> </a>
<a name="ln439">    command_type cmd = key_to_command(keys[0], KMC_DEFAULT);</a>
<a name="ln440"> </a>
<a name="ln441">    if (cmd == CMD_NO_CMD)</a>
<a name="ln442">    {</a>
<a name="ln443">        luaL_argerror(ls, 1, &quot;First key is invalid command&quot;);</a>
<a name="ln444">        return 0;</a>
<a name="ln445">    }</a>
<a name="ln446"> </a>
<a name="ln447">    unwind_bool gen(crawl_state.invisible_targeting,</a>
<a name="ln448">            lua_isboolean(ls, 2) &amp;&amp; lua_toboolean(ls, 2));</a>
<a name="ln449"> </a>
<a name="ln450">    flush_input_buffer(FLUSH_BEFORE_COMMAND);</a>
<a name="ln451">    for (int i = 1, len = strlen(keys); i &lt; len; i++)</a>
<a name="ln452">        macro_sendkeys_end_add_expanded(keys[i]);</a>
<a name="ln453"> </a>
<a name="ln454">    process_command_on_record(cmd);</a>
<a name="ln455"> </a>
<a name="ln456">    return 0;</a>
<a name="ln457">}</a>
<a name="ln458"> </a>
<a name="ln459">/*** Enable or disable crashing on an incomplete buffer.</a>
<a name="ln460"> * Used for tests, not generally useful in real life. Crashing only happens in</a>
<a name="ln461"> * wizmode.</a>
<a name="ln462"> * @tparam boolean param</a>
<a name="ln463"> * @function set_sendkeys_errors</a>
<a name="ln464"> */</a>
<a name="ln465">static int crawl_set_sendkeys_errors(lua_State *ls)</a>
<a name="ln466">{</a>
<a name="ln467">    const bool errors = lua_toboolean(ls, 1);</a>
<a name="ln468">    crawl_state.nonempty_buffer_flush_errors = errors;</a>
<a name="ln469">    return 0;</a>
<a name="ln470">}</a>
<a name="ln471"> </a>
<a name="ln472">/*** Execute a sequence of named crawl commands</a>
<a name="ln473"> * The array must be the command names as they appear in cmd-name.h, they are</a>
<a name="ln474"> * processed in order by the macro internal command buffer. The input buffer is</a>
<a name="ln475"> * flushed before execution.</a>
<a name="ln476"> * @tparam array commands</a>
<a name="ln477"> * @tparam[opt=false] boolean hide hide targeter while processing</a>
<a name="ln478"> * @function do_commands</a>
<a name="ln479"> */</a>
<a name="ln480">static int crawl_do_commands(lua_State *ls)</a>
<a name="ln481">{</a>
<a name="ln482">    if (!_check_can_do_command(ls))</a>
<a name="ln483">        return 0;</a>
<a name="ln484"> </a>
<a name="ln485">    unwind_bool gen(crawl_state.invisible_targeting,</a>
<a name="ln486">                    lua_isboolean(ls, 2) &amp;&amp; lua_toboolean(ls, 2));</a>
<a name="ln487">    if (lua_isboolean(ls, 2))</a>
<a name="ln488">        lua_pop(ls, 1);</a>
<a name="ln489">    if (!lua_istable(ls, 1))</a>
<a name="ln490">    {</a>
<a name="ln491">        luaL_argerror(ls, 1, &quot;Must be an array&quot;);</a>
<a name="ln492">        return 0;</a>
<a name="ln493">    }</a>
<a name="ln494">    map&lt;int,string&gt; command_map; // ordered by key</a>
<a name="ln495"> </a>
<a name="ln496">    lua_pushnil(ls);</a>
<a name="ln497">    while (lua_next(ls, 1)) // in general, no guaranteed order for this</a>
<a name="ln498">    {</a>
<a name="ln499">        if (!lua_isstring(ls, -1))</a>
<a name="ln500">        {</a>
<a name="ln501">            luaL_argerror(ls, 1, &quot;Table contains non-string&quot;);</a>
<a name="ln502">            return 0;</a>
<a name="ln503">        }</a>
<a name="ln504">        if (!lua_isnumber(ls, -2))</a>
<a name="ln505">        {</a>
<a name="ln506">            luaL_argerror(ls, 1, &quot;Must be an array&quot;);</a>
<a name="ln507">            return 0;</a>
<a name="ln508">        }</a>
<a name="ln509">        command_map[lua_tonumber(ls, -2)] = lua_tostring(ls, -1);</a>
<a name="ln510">        lua_pop(ls, 1);</a>
<a name="ln511">    }</a>
<a name="ln512"> </a>
<a name="ln513">    bool first = true;</a>
<a name="ln514">    command_type firstcmd = CMD_NO_CMD;</a>
<a name="ln515">    deque&lt;command_type&gt; cmd_seq;</a>
<a name="ln516"> </a>
<a name="ln517">    for (const auto&amp; pair : command_map)</a>
<a name="ln518">    {</a>
<a name="ln519">        const auto&amp; command = pair.second;</a>
<a name="ln520">        command_type cmd = name_to_command(command);</a>
<a name="ln521">        if (cmd == CMD_NO_CMD)</a>
<a name="ln522">        {</a>
<a name="ln523">            luaL_argerror(ls, 1, (&quot;Invalid command: &quot; + command).c_str());</a>
<a name="ln524">            return 0;</a>
<a name="ln525">        }</a>
<a name="ln526"> </a>
<a name="ln527">        if (first)</a>
<a name="ln528">        {</a>
<a name="ln529">            firstcmd = cmd;</a>
<a name="ln530">            first = false;</a>
<a name="ln531">        }</a>
<a name="ln532">        else</a>
<a name="ln533">            cmd_seq.push_front(cmd); // reverse order for adding below</a>
<a name="ln534">    }</a>
<a name="ln535"> </a>
<a name="ln536">    flush_input_buffer(FLUSH_BEFORE_COMMAND);</a>
<a name="ln537"> </a>
<a name="ln538">    // insert commands to the front of the macro buffer so that they are</a>
<a name="ln539">    // guaranteed to be processed adjacent to firstcmd</a>
<a name="ln540">    for (auto c : cmd_seq)</a>
<a name="ln541">        macro_buf_add_cmd(c, true);</a>
<a name="ln542"> </a>
<a name="ln543">    process_command_on_record(firstcmd);</a>
<a name="ln544"> </a>
<a name="ln545">    return 0;</a>
<a name="ln546">}</a>
<a name="ln547"> </a>
<a name="ln548">#ifdef USE_SOUND</a>
<a name="ln549">/*** Play a sound.</a>
<a name="ln550"> * Only available when crawl is compiled with sound.</a>
<a name="ln551"> * @tparam string sf filename of sound to play</a>
<a name="ln552"> * @function playsound</a>
<a name="ln553"> */</a>
<a name="ln554">static int crawl_playsound(lua_State *ls)</a>
<a name="ln555">{</a>
<a name="ln556">    const char *sf = luaL_checkstring(ls, 1);</a>
<a name="ln557">    if (!sf)</a>
<a name="ln558">        return 0;</a>
<a name="ln559">    play_sound(sf);</a>
<a name="ln560">    return 0;</a>
<a name="ln561">}</a>
<a name="ln562">#endif</a>
<a name="ln563"> </a>
<a name="ln564">/*** Run a macro.</a>
<a name="ln565"> * @tparam string macroname name of macro to run</a>
<a name="ln566"> * @function runmacro</a>
<a name="ln567"> */</a>
<a name="ln568">static int crawl_runmacro(lua_State *ls)</a>
<a name="ln569">{</a>
<a name="ln570">    const char *macroname = luaL_checkstring(ls, 1);</a>
<a name="ln571">    if (!macroname)</a>
<a name="ln572">        return 0;</a>
<a name="ln573">    run_macro(macroname);</a>
<a name="ln574">    return 0;</a>
<a name="ln575">}</a>
<a name="ln576"> </a>
<a name="ln577">/*** Set user options from string.</a>
<a name="ln578"> * @tparam string opt an option string in the same format as &lt;tt&gt;init.txt&lt;/tt&gt;/&lt;tt&gt;.crawlrc&lt;/tt&gt;</a>
<a name="ln579"> * @function setopt</a>
<a name="ln580"> */</a>
<a name="ln581">static int crawl_setopt(lua_State *ls)</a>
<a name="ln582">{</a>
<a name="ln583">    if (!lua_isstring(ls, 1))</a>
<a name="ln584">        return 0;</a>
<a name="ln585"> </a>
<a name="ln586">    const char *s = lua_tostring(ls, 1);</a>
<a name="ln587">    if (s)</a>
<a name="ln588">    {</a>
<a name="ln589">        // Note that the conditional script can contain nested Lua[ ]Lua code.</a>
<a name="ln590">        read_options(s, true);</a>
<a name="ln591">    }</a>
<a name="ln592"> </a>
<a name="ln593">    return 0;</a>
<a name="ln594">}</a>
<a name="ln595"> </a>
<a name="ln596">/*** Read options from file.</a>
<a name="ln597"> * @tparam string filename name of file to read from</a>
<a name="ln598"> * @function read_options */</a>
<a name="ln599">static int crawl_read_options(lua_State *ls)</a>
<a name="ln600">{</a>
<a name="ln601">    if (!lua_isstring(ls, 1))</a>
<a name="ln602">        return 0;</a>
<a name="ln603"> </a>
<a name="ln604">    const char* filename = lua_tostring(ls, 1);</a>
<a name="ln605">    Options.include(filename, true, true);</a>
<a name="ln606">    return 0;</a>
<a name="ln607">}</a>
<a name="ln608"> </a>
<a name="ln609">static int crawl_bindkey(lua_State *ls)</a>
<a name="ln610">{</a>
<a name="ln611">    const char *s = nullptr;</a>
<a name="ln612">    if (lua_isstring(ls, 1))</a>
<a name="ln613">        s = lua_tostring(ls, 1);</a>
<a name="ln614"> </a>
<a name="ln615">    if (!s || !lua_isfunction(ls, 2) || lua_gettop(ls) != 2)</a>
<a name="ln616">        return 0;</a>
<a name="ln617"> </a>
<a name="ln618">    lua_pushvalue(ls, 2);</a>
<a name="ln619">    string name = clua.setuniqregistry();</a>
<a name="ln620">    if (lua_gettop(ls) != 2)</a>
<a name="ln621">    {</a>
<a name="ln622">        fprintf(stderr, &quot;Stack top has changed!\n&quot;);</a>
<a name="ln623">        lua_settop(ls, 2);</a>
<a name="ln624">    }</a>
<a name="ln625">    // TODO: This function is a stub, so this whole binding is.</a>
<a name="ln626">    macro_userfn(s, name.c_str());</a>
<a name="ln627">    return 0;</a>
<a name="ln628">}</a>
<a name="ln629"> </a>
<a name="ln630">/*** Get the number of a message channel.</a>
<a name="ln631"> * @tparam string name channel name</a>
<a name="ln632"> * @treturn int channel number</a>
<a name="ln633"> * @function msgch_num</a>
<a name="ln634"> */</a>
<a name="ln635">static int crawl_msgch_num(lua_State *ls)</a>
<a name="ln636">{</a>
<a name="ln637">    const char *s = luaL_checkstring(ls, 1);</a>
<a name="ln638">    if (!s)</a>
<a name="ln639">        return 0;</a>
<a name="ln640">    int ch = str_to_channel(s);</a>
<a name="ln641">    if (ch == -1)</a>
<a name="ln642">        return 0;</a>
<a name="ln643"> </a>
<a name="ln644">    lua_pushnumber(ls, ch);</a>
<a name="ln645">    return 1;</a>
<a name="ln646">}</a>
<a name="ln647"> </a>
<a name="ln648">/*** Get the name of a message channel.</a>
<a name="ln649"> * @tparam int num channel number</a>
<a name="ln650"> * @treturn string channel name</a>
<a name="ln651"> * @function msgch_name</a>
<a name="ln652"> */</a>
<a name="ln653">static int crawl_msgch_name(lua_State *ls)</a>
<a name="ln654">{</a>
<a name="ln655">    int num = luaL_safe_checkint(ls, 1);</a>
<a name="ln656">    string name = channel_to_str(num);</a>
<a name="ln657">    lua_pushstring(ls, name.c_str());</a>
<a name="ln658">    return 1;</a>
<a name="ln659">}</a>
<a name="ln660"> </a>
<a name="ln661">/*** Make a note.</a>
<a name="ln662"> * @tparam string note</a>
<a name="ln663"> * @function take_note</a>
<a name="ln664"> */</a>
<a name="ln665">static int crawl_take_note(lua_State *ls)</a>
<a name="ln666">{</a>
<a name="ln667">    const char* msg = luaL_checkstring(ls, 1);</a>
<a name="ln668">    take_note(Note(NOTE_MESSAGE, 0, 0, msg));</a>
<a name="ln669">    return 0;</a>
<a name="ln670">}</a>
<a name="ln671"> </a>
<a name="ln672">/*** Retrieve the message buffer.</a>
<a name="ln673"> * @tparam int num how many lines back to go</a>
<a name="ln674"> * @treturn strong</a>
<a name="ln675"> * @function messages</a>
<a name="ln676"> */</a>
<a name="ln677">static int crawl_messages(lua_State *ls)</a>
<a name="ln678">{</a>
<a name="ln679">    const int count = luaL_safe_checkint(ls, 1);</a>
<a name="ln680">    lua_pushstring(ls, get_last_messages(count).c_str());</a>
<a name="ln681">    return 1;</a>
<a name="ln682">}</a>
<a name="ln683"> </a>
<a name="ln684">#define REGEX_METATABLE &quot;crawl.regex&quot;</a>
<a name="ln685">#define MESSF_METATABLE &quot;crawl.messf&quot;</a>
<a name="ln686"> </a>
<a name="ln687">/*** Compile a regular expression</a>
<a name="ln688"> * @tparam string pat the pattern string (PCRE)</a>
<a name="ln689"> * @treturn Regex|nil</a>
<a name="ln690"> * @function regex</a>
<a name="ln691"> */</a>
<a name="ln692">static int crawl_regex(lua_State *ls)</a>
<a name="ln693">{</a>
<a name="ln694">    const char *s = luaL_checkstring(ls, 1);</a>
<a name="ln695">    if (!s)</a>
<a name="ln696">        return 0;</a>
<a name="ln697"> </a>
<a name="ln698">    text_pattern **tpudata =</a>
<a name="ln699">            clua_new_userdata&lt; text_pattern* &gt;(ls, REGEX_METATABLE);</a>
<a name="ln700">    if (tpudata)</a>
<a name="ln701">    {</a>
<a name="ln702">        *tpudata = new text_pattern(s);</a>
<a name="ln703">        return 1;</a>
<a name="ln704">    }</a>
<a name="ln705">    return 0;</a>
<a name="ln706">}</a>
<a name="ln707"> </a>
<a name="ln708"> </a>
<a name="ln709">/*** Regular expression objects</a>
<a name="ln710"> * @type Regex</a>
<a name="ln711"> */</a>
<a name="ln712">/*** Test against a string.</a>
<a name="ln713"> * Returns nil if the pattern object does not exist or if a non-string is</a>
<a name="ln714"> * passed.</a>
<a name="ln715"> * @tparam string s</a>
<a name="ln716"> * @treturn boolean|nil</a>
<a name="ln717"> * @function Regex:find</a>
<a name="ln718"> */</a>
<a name="ln719">static int crawl_regex_find(lua_State *ls)</a>
<a name="ln720">{</a>
<a name="ln721">    text_pattern **pattern =</a>
<a name="ln722">            clua_get_userdata&lt; text_pattern* &gt;(ls, REGEX_METATABLE);</a>
<a name="ln723">    if (!pattern || !*pattern)</a>
<a name="ln724">    {</a>
<a name="ln725">        luaL_argerror(ls, 1, &quot;Invalid regex object&quot;);</a>
<a name="ln726">        return 0;</a>
<a name="ln727">    }</a>
<a name="ln728"> </a>
<a name="ln729">    const char *text = luaL_checkstring(ls, -1);</a>
<a name="ln730">    if (!text)</a>
<a name="ln731">        return 0;</a>
<a name="ln732"> </a>
<a name="ln733">    lua_pushboolean(ls, (*pattern)-&gt;matches(text));</a>
<a name="ln734">    return 1;</a>
<a name="ln735">}</a>
<a name="ln736"> </a>
<a name="ln737">/*** Test equality</a>
<a name="ln738"> * Tests if the two lua variables are the same underlying compiled pattern</a>
<a name="ln739"> * @tparam regex pat</a>
<a name="ln740"> * @treturn boolean</a>
<a name="ln741"> * @function Regex:equals</a>
<a name="ln742"> */</a>
<a name="ln743">static int crawl_regex_equals(lua_State *ls)</a>
<a name="ln744">{</a>
<a name="ln745">    text_pattern **pattern =</a>
<a name="ln746">            clua_get_userdata&lt; text_pattern* &gt;(ls, REGEX_METATABLE);</a>
<a name="ln747">    text_pattern **arg =</a>
<a name="ln748">            clua_get_userdata&lt; text_pattern* &gt;(ls, REGEX_METATABLE, 2);</a>
<a name="ln749"> </a>
<a name="ln750">    if (!pattern || !*pattern || !arg || !*arg)</a>
<a name="ln751">    {</a>
<a name="ln752">        // TODO: explain which one</a>
<a name="ln753">        luaL_error(ls, &quot;Invalid regex object&quot;);</a>
<a name="ln754">        return 0;</a>
<a name="ln755">    }</a>
<a name="ln756"> </a>
<a name="ln757">    lua_pushboolean(ls, **pattern == **arg);</a>
<a name="ln758">    return 1;</a>
<a name="ln759">}</a>
<a name="ln760">static const luaL_reg crawl_regex_ops[] =</a>
<a name="ln761">{</a>
<a name="ln762">    { &quot;matches&quot;,        crawl_regex_find },</a>
<a name="ln763">    { &quot;equals&quot;,         crawl_regex_equals },</a>
<a name="ln764">    { nullptr, nullptr }</a>
<a name="ln765">};</a>
<a name="ln766">/*** @section end</a>
<a name="ln767"> */</a>
<a name="ln768"> </a>
<a name="ln769">/*** Create a message filter</a>
<a name="ln770"> * @tparam string pat filter pattern</a>
<a name="ln771"> * @tparam[opt=-1] int ch channel number, -1 for anu</a>
<a name="ln772"> * @treturn MessageFilter|nil</a>
<a name="ln773"> * @function message_filter</a>
<a name="ln774"> */</a>
<a name="ln775">/*** Message filter object.</a>
<a name="ln776"> * @type MessageFilter</a>
<a name="ln777"> */</a>
<a name="ln778">static int crawl_message_filter(lua_State *ls)</a>
<a name="ln779">{</a>
<a name="ln780">    const char *pattern = luaL_checkstring(ls, 1);</a>
<a name="ln781">    if (!pattern)</a>
<a name="ln782">        return 0;</a>
<a name="ln783"> </a>
<a name="ln784">    int num = lua_isnumber(ls, 2)? luaL_safe_checkint(ls, 2) : -1;</a>
<a name="ln785">    message_filter **mf =</a>
<a name="ln786">            clua_new_userdata&lt; message_filter* &gt;(ls, MESSF_METATABLE);</a>
<a name="ln787">    if (mf)</a>
<a name="ln788">    {</a>
<a name="ln789">        *mf = new message_filter(num, pattern);</a>
<a name="ln790">        return 1;</a>
<a name="ln791">    }</a>
<a name="ln792">    return 0;</a>
<a name="ln793">}</a>
<a name="ln794"> </a>
<a name="ln795">/*** Check a message against a filter.</a>
<a name="ln796"> * @tparam string msg</a>
<a name="ln797"> * @tparam int ch message channel</a>
<a name="ln798"> * @treturn boolean</a>
<a name="ln799"> * @function MessageFilter:matches</a>
<a name="ln800"> */</a>
<a name="ln801">static int crawl_messf_matches(lua_State *ls)</a>
<a name="ln802">{</a>
<a name="ln803">    message_filter **mf =</a>
<a name="ln804">            clua_get_userdata&lt; message_filter* &gt;(ls, MESSF_METATABLE);</a>
<a name="ln805">    if (!mf || !*mf)</a>
<a name="ln806">    {</a>
<a name="ln807">        luaL_argerror(ls, 1, &quot;Invalid message filter object&quot;);</a>
<a name="ln808">        return 0;</a>
<a name="ln809">    }</a>
<a name="ln810"> </a>
<a name="ln811">    const char *pattern = luaL_checkstring(ls, 2);</a>
<a name="ln812">    int ch = luaL_safe_checkint(ls, 3);</a>
<a name="ln813">    if (pattern)</a>
<a name="ln814">    {</a>
<a name="ln815">        bool filt = (*mf)-&gt;is_filtered(ch, pattern);</a>
<a name="ln816">        lua_pushboolean(ls, filt);</a>
<a name="ln817">        return 1;</a>
<a name="ln818">    }</a>
<a name="ln819">    return 0;</a>
<a name="ln820">}</a>
<a name="ln821"> </a>
<a name="ln822">/*** Test equality</a>
<a name="ln823"> * Tests if the two lua variables are the same underlying compiled pattern</a>
<a name="ln824"> * @tparam regex pat</a>
<a name="ln825"> * @treturn boolean</a>
<a name="ln826"> * @function MessageFilter:equals</a>
<a name="ln827"> */</a>
<a name="ln828">static int crawl_messf_equals(lua_State *ls)</a>
<a name="ln829">{</a>
<a name="ln830">    message_filter **mf =</a>
<a name="ln831">            clua_get_userdata&lt; message_filter* &gt;(ls, MESSF_METATABLE);</a>
<a name="ln832">    message_filter **arg =</a>
<a name="ln833">            clua_get_userdata&lt; message_filter* &gt;(ls, MESSF_METATABLE, 2);</a>
<a name="ln834">    if (!mf || !*mf || !arg || !*arg)</a>
<a name="ln835">    {</a>
<a name="ln836">        // TODO: explain which one</a>
<a name="ln837">        luaL_error(ls, &quot;Invalid message filter object&quot;);</a>
<a name="ln838">        return 0;</a>
<a name="ln839">    }</a>
<a name="ln840">    lua_pushboolean(ls, **mf == **arg);</a>
<a name="ln841">    return 1;</a>
<a name="ln842">}</a>
<a name="ln843"> </a>
<a name="ln844">static const luaL_reg crawl_messf_ops[] =</a>
<a name="ln845">{</a>
<a name="ln846">    { &quot;matches&quot;,        crawl_messf_matches },</a>
<a name="ln847">    { &quot;equals&quot;,         crawl_messf_equals },</a>
<a name="ln848">    { nullptr, nullptr }</a>
<a name="ln849">};</a>
<a name="ln850">/*** @section end</a>
<a name="ln851"> */</a>
<a name="ln852"> </a>
<a name="ln853">/*** Trim newlines and trailing whitespace.</a>
<a name="ln854"> * @tparam string s</a>
<a name="ln855"> * @treturn string</a>
<a name="ln856"> * @function trim</a>
<a name="ln857"> */</a>
<a name="ln858">static int crawl_trim(lua_State *ls)</a>
<a name="ln859">{</a>
<a name="ln860">    const char *s = luaL_checkstring(ls, 1);</a>
<a name="ln861">    if (!s)</a>
<a name="ln862">        return 0;</a>
<a name="ln863">    string text = s;</a>
<a name="ln864">    trim_string(text);</a>
<a name="ln865">    lua_pushstring(ls, text.c_str());</a>
<a name="ln866">    return 1;</a>
<a name="ln867">}</a>
<a name="ln868"> </a>
<a name="ln869">/*** Split a string at a token.</a>
<a name="ln870"> * @tparam string s</a>
<a name="ln871"> * @tparam string split</a>
<a name="ln872"> * @treturn {string,...}</a>
<a name="ln873"> * @function split</a>
<a name="ln874"> */</a>
<a name="ln875">static int crawl_split(lua_State *ls)</a>
<a name="ln876">{</a>
<a name="ln877">    const char *s = luaL_checkstring(ls, 1),</a>
<a name="ln878">               *token = luaL_checkstring(ls, 2);</a>
<a name="ln879">    if (!s || !token)</a>
<a name="ln880">        return 0;</a>
<a name="ln881"> </a>
<a name="ln882">    vector&lt;string&gt; segs = split_string(token, s);</a>
<a name="ln883">    if (lua_isboolean(ls, 3) &amp;&amp; lua_toboolean(ls, 3))</a>
<a name="ln884">        reverse(segs.begin(), segs.end());</a>
<a name="ln885">    lua_newtable(ls);</a>
<a name="ln886">    for (int i = 0, count = segs.size(); i &lt; count; ++i)</a>
<a name="ln887">    {</a>
<a name="ln888">        lua_pushstring(ls, segs[i].c_str());</a>
<a name="ln889">        lua_rawseti(ls, -2, i + 1);</a>
<a name="ln890">    }</a>
<a name="ln891">    return 1;</a>
<a name="ln892">}</a>
<a name="ln893"> </a>
<a name="ln894">/*** Compare two strings in a locale-independent way.</a>
<a name="ln895"> * Lua's built in comparison operations for strings are dependent on locale,</a>
<a name="ln896"> * which isn't always desireable. This is just a wrapper on</a>
<a name="ln897"> * std::basic_string::compare.</a>
<a name="ln898"> *</a>
<a name="ln899"> * @tparam string s1 the first string.</a>
<a name="ln900"> * @tparam string s2 the second sring.</a>
<a name="ln901"> * @treturn -1 if s1 &lt; s2, 1 if s2 &lt; s1, 0 if s1 == s2.</a>
<a name="ln902"> */</a>
<a name="ln903">static int crawl_string_compare(lua_State *ls)</a>
<a name="ln904">{</a>
<a name="ln905">    const string s1 = luaL_checkstring(ls, 1),</a>
<a name="ln906">                 s2 = luaL_checkstring(ls, 2);</a>
<a name="ln907">    lua_pushnumber(ls, s1.compare(s2));</a>
<a name="ln908">    return 1;</a>
<a name="ln909">}</a>
<a name="ln910"> </a>
<a name="ln911">/*** Grammatically describe something.</a>
<a name="ln912"> * Crawl provides the following description types:</a>
<a name="ln913"> *</a>
<a name="ln914"> *  - &quot;plain&quot;: just give the name</a>
<a name="ln915"> *  - &quot;the&quot;: use the definite article</a>
<a name="ln916"> *  - &quot;a&quot;: use the indefinite article</a>
<a name="ln917"> *  - &quot;your&quot;: use the second person posessive</a>
<a name="ln918"> *  - &quot;its&quot;: use the third person posessive</a>
<a name="ln919"> *  - &quot;worn&quot;: how it is equipped</a>
<a name="ln920"> *  - &quot;inv&quot;: describe something carried</a>
<a name="ln921"> *  - &quot;none&quot;: return the empty string</a>
<a name="ln922"> *</a>
<a name="ln923"> * And some specific types for partial item naming:</a>
<a name="ln924"> *</a>
<a name="ln925"> *  - &quot;base&quot;: base name of the item subtype</a>
<a name="ln926"> *  - &quot;qualname&quot;: name without articles, quantities, or enchantments</a>
<a name="ln927"> *</a>
<a name="ln928"> * These are used as the allowable values for how.</a>
<a name="ln929"> * @tparam string what thing to describe</a>
<a name="ln930"> * @tparam[opt=&quot;plain&quot;] string how crawl description type</a>
<a name="ln931"> * @treturn string grammatical description</a>
<a name="ln932"> * @function grammar</a>
<a name="ln933"> */</a>
<a name="ln934">static int _crawl_grammar(lua_State *ls)</a>
<a name="ln935">{</a>
<a name="ln936">    description_level_type ndesc = DESC_PLAIN;</a>
<a name="ln937">    if (lua_isstring(ls, 2))</a>
<a name="ln938">        ndesc = description_type_by_name(lua_tostring(ls, 2));</a>
<a name="ln939">    PLUARET(string, thing_do_grammar(ndesc, luaL_checkstring(ls, 1)).c_str()); }</a>
<a name="ln940"> </a>
<a name="ln941">/*** Correctly attach the article 'a'.</a>
<a name="ln942"> * @tparam string s</a>
<a name="ln943"> * @tparam[opt=true] bool lowercase</a>
<a name="ln944"> * @treturn string</a>
<a name="ln945"> * @function article_a</a>
<a name="ln946"> */</a>
<a name="ln947">static int crawl_article_a(lua_State *ls)</a>
<a name="ln948">{</a>
<a name="ln949">    const char *s = luaL_checkstring(ls, 1);</a>
<a name="ln950"> </a>
<a name="ln951">    bool lowercase = true;</a>
<a name="ln952">    if (lua_isboolean(ls, 2))</a>
<a name="ln953">        lowercase = lua_toboolean(ls, 2);</a>
<a name="ln954"> </a>
<a name="ln955">    lua_pushstring(ls, article_a(s, lowercase).c_str());</a>
<a name="ln956"> </a>
<a name="ln957">    return 1;</a>
<a name="ln958">}</a>
<a name="ln959"> </a>
<a name="ln960">/*** Has the game started?</a>
<a name="ln961"> * @treturn boolean</a>
<a name="ln962"> * @function game_started</a>
<a name="ln963"> */</a>
<a name="ln964">LUARET1(crawl_game_started, boolean, crawl_state.need_save</a>
<a name="ln965">                                     || crawl_state.map_stat_gen</a>
<a name="ln966">                                     || crawl_state.obj_stat_gen</a>
<a name="ln967">                                     || crawl_state.test)</a>
<a name="ln968">/*** Is crawl asking us to choose a stat?</a>
<a name="ln969"> * @treturn boolean</a>
<a name="ln970"> * @function stat_gain_prompt</a>
<a name="ln971"> */</a>
<a name="ln972">LUARET1(crawl_stat_gain_prompt, boolean, crawl_state.stat_gain_prompt)</a>
<a name="ln973">/*** Return a random number from [0, max).</a>
<a name="ln974"> * @tparam int max</a>
<a name="ln975"> * @treturn int</a>
<a name="ln976"> * @function random2</a>
<a name="ln977"> * */</a>
<a name="ln978">LUARET1(crawl_random2, number, random2(luaL_safe_checkint(ls, 1)))</a>
<a name="ln979">/*** Perform a weighted coinflip.</a>
<a name="ln980"> * @tparam int in</a>
<a name="ln981"> * @treturn boolean</a>
<a name="ln982"> * @function one_chance_in</a>
<a name="ln983"> */</a>
<a name="ln984">LUARET1(crawl_one_chance_in, boolean, one_chance_in(luaL_safe_checkint(ls, 1)))</a>
<a name="ln985">/*** Average num random rolls from [0, max).</a>
<a name="ln986"> * @tparam int max</a>
<a name="ln987"> * @tparam int num</a>
<a name="ln988"> * @treturn int</a>
<a name="ln989"> * @function random2avg</a>
<a name="ln990"> */</a>
<a name="ln991">LUARET1(crawl_random2avg, number,</a>
<a name="ln992">        random2avg(luaL_safe_checkint(ls, 1), luaL_safe_checkint(ls, 2)))</a>
<a name="ln993">/*** Random number in a range.</a>
<a name="ln994"> * @tparam int min</a>
<a name="ln995"> * @tparam int max</a>
<a name="ln996"> * @tparam[opt=1] int rolls Average over multiple rolls</a>
<a name="ln997"> * @function random_range</a>
<a name="ln998"> */</a>
<a name="ln999">LUARET1(crawl_random_range, number,</a>
<a name="ln1000">        random_range(luaL_safe_checkint(ls, 1), luaL_safe_checkint(ls, 2),</a>
<a name="ln1001">                      lua_isnumber(ls, 3)? luaL_safe_checkint(ls, 3) : 1))</a>
<a name="ln1002">/*** Flip a coin.</a>
<a name="ln1003"> * @treturn boolean</a>
<a name="ln1004"> * @function coinflip</a>
<a name="ln1005"> */</a>
<a name="ln1006">LUARET1(crawl_coinflip, boolean, coinflip())</a>
<a name="ln1007">/*** Roll dice.</a>
<a name="ln1008"> * @tparam[opt=1] int num_dice</a>
<a name="ln1009"> * @tparam int sides</a>
<a name="ln1010"> * @treturn int</a>
<a name="ln1011"> * @function roll_dice</a>
<a name="ln1012"> */</a>
<a name="ln1013">LUARET1(crawl_roll_dice, number,</a>
<a name="ln1014">        lua_gettop(ls) == 1</a>
<a name="ln1015">        ? roll_dice(1, luaL_safe_checkint(ls, 1))</a>
<a name="ln1016">        : roll_dice(luaL_safe_checkint(ls, 1), luaL_safe_checkint(ls, 2)))</a>
<a name="ln1017">/*** Do a random draw.</a>
<a name="ln1018"> * @tparam int x</a>
<a name="ln1019"> * @tparam int y</a>
<a name="ln1020"> * @treturn boolean</a>
<a name="ln1021"> * @function x_chance_in_y</a>
<a name="ln1022"> */</a>
<a name="ln1023">LUARET1(crawl_x_chance_in_y, boolean, x_chance_in_y(luaL_safe_checkint(ls, 1),</a>
<a name="ln1024">                                                    luaL_safe_checkint(ls, 2)))</a>
<a name="ln1025">/*** Random-round integer division.</a>
<a name="ln1026"> * @tparam int numerator</a>
<a name="ln1027"> * @tparam int denominator</a>
<a name="ln1028"> * @treturn int</a>
<a name="ln1029"> * @function div_rand_round</a>
<a name="ln1030"> */</a>
<a name="ln1031">LUARET1(crawl_div_rand_round, number, div_rand_round(luaL_safe_checkint(ls, 1),</a>
<a name="ln1032">                                                     luaL_safe_checkint(ls, 2)))</a>
<a name="ln1033">/*** A random floating point number in [0,1.0)</a>
<a name="ln1034"> * @treturn number</a>
<a name="ln1035"> * @function random_real</a>
<a name="ln1036"> */</a>
<a name="ln1037">LUARET1(crawl_random_real, number, random_real())</a>
<a name="ln1038">/*** Check if the player really wants to use their weapon.</a>
<a name="ln1039"> * @treturn boolean</a>
<a name="ln1040"> * @function weapon_check</a>
<a name="ln1041"> */</a>
<a name="ln1042">LUARET1(crawl_weapon_check, boolean, wielded_weapon_check(you.weapon()))</a>
<a name="ln1043"> </a>
<a name="ln1044">/*** Get the full Worley noise datum for a given point</a>
<a name="ln1045"> * @tparam number px</a>
<a name="ln1046"> * @tparam number py</a>
<a name="ln1047"> * @tparam number pz</a>
<a name="ln1048"> * @treturn number distance1</a>
<a name="ln1049"> * @treturn number distance2</a>
<a name="ln1050"> * @treturn number id1</a>
<a name="ln1051"> * @treturn number id2</a>
<a name="ln1052"> * @treturn number id1</a>
<a name="ln1053"> * @treturn number pos1x</a>
<a name="ln1054"> * @treturn number pos1y</a>
<a name="ln1055"> * @treturn number pos1z</a>
<a name="ln1056"> * @treturn number pos2x</a>
<a name="ln1057"> * @treturn number pos2y</a>
<a name="ln1058"> * @treturn number pos2z</a>
<a name="ln1059"> * @function worley</a>
<a name="ln1060"> */</a>
<a name="ln1061">static int crawl_worley(lua_State *ls)</a>
<a name="ln1062">{</a>
<a name="ln1063">    double px = lua_tonumber(ls,1);</a>
<a name="ln1064">    double py = lua_tonumber(ls,2);</a>
<a name="ln1065">    double pz = lua_tonumber(ls,3);</a>
<a name="ln1066"> </a>
<a name="ln1067">    worley::noise_datum n = worley::noise(px,py,pz);</a>
<a name="ln1068">    lua_pushnumber(ls, n.distance[0]);</a>
<a name="ln1069">    lua_pushnumber(ls, n.distance[1]);</a>
<a name="ln1070">    lua_pushnumber(ls, n.id[0]);</a>
<a name="ln1071">    lua_pushnumber(ls, n.id[1]);</a>
<a name="ln1072">    lua_pushnumber(ls, n.pos[0][0]);</a>
<a name="ln1073">    lua_pushnumber(ls, n.pos[0][1]);</a>
<a name="ln1074">    lua_pushnumber(ls, n.pos[0][2]);</a>
<a name="ln1075">    lua_pushnumber(ls, n.pos[1][0]);</a>
<a name="ln1076">    lua_pushnumber(ls, n.pos[1][1]);</a>
<a name="ln1077">    lua_pushnumber(ls, n.pos[1][2]);</a>
<a name="ln1078">    return 10;</a>
<a name="ln1079">}</a>
<a name="ln1080"> </a>
<a name="ln1081">/*** Difference between nearest point Worley distances.</a>
<a name="ln1082"> * @tparam number px</a>
<a name="ln1083"> * @tparam number py</a>
<a name="ln1084"> * @tparam number pz</a>
<a name="ln1085"> * @treturn number diff</a>
<a name="ln1086"> * @treturn number id1</a>
<a name="ln1087"> * @function worley_diff</a>
<a name="ln1088"> */</a>
<a name="ln1089">static int crawl_worley_diff(lua_State *ls)</a>
<a name="ln1090">{</a>
<a name="ln1091">    double px = lua_tonumber(ls,1);</a>
<a name="ln1092">    double py = lua_tonumber(ls,2);</a>
<a name="ln1093">    double pz = lua_tonumber(ls,3);</a>
<a name="ln1094"> </a>
<a name="ln1095">    worley::noise_datum n = worley::noise(px,py,pz);</a>
<a name="ln1096">    lua_pushnumber(ls, n.distance[1]-n.distance[0]);</a>
<a name="ln1097">    lua_pushnumber(ls, n.id[0]);</a>
<a name="ln1098"> </a>
<a name="ln1099">    return 2;</a>
<a name="ln1100">}</a>
<a name="ln1101"> </a>
<a name="ln1102">/*** Splits a 32-bit integer into four bytes.</a>
<a name="ln1103"> * This is useful in conjunction with worley ids to get four random numbers</a>
<a name="ln1104"> * instead of one from the current node id.</a>
<a name="ln1105"> * @tparam int num</a>
<a name="ln1106"> * @treturn byte</a>
<a name="ln1107"> * @treturn byte</a>
<a name="ln1108"> * @treturn byte</a>
<a name="ln1109"> * @treturn byte</a>
<a name="ln1110"> * @function split_bytes</a>
<a name="ln1111"> */</a>
<a name="ln1112">static int crawl_split_bytes(lua_State *ls)</a>
<a name="ln1113">{</a>
<a name="ln1114">    uint32_t val = lua_tonumber(ls,1);</a>
<a name="ln1115">    uint8_t bytes[4] =</a>
<a name="ln1116">    {</a>
<a name="ln1117">        (uint8_t)(val &gt;&gt; 24),</a>
<a name="ln1118">        (uint8_t)(val &gt;&gt; 16),</a>
<a name="ln1119">        (uint8_t)(val &gt;&gt; 8),</a>
<a name="ln1120">        (uint8_t)(val)</a>
<a name="ln1121">    };</a>
<a name="ln1122">    lua_pushnumber(ls, bytes[0]);</a>
<a name="ln1123">    lua_pushnumber(ls, bytes[1]);</a>
<a name="ln1124">    lua_pushnumber(ls, bytes[2]);</a>
<a name="ln1125">    lua_pushnumber(ls, bytes[3]);</a>
<a name="ln1126">    return 4;</a>
<a name="ln1127">}</a>
<a name="ln1128"> </a>
<a name="ln1129">/*** 2D-4D Simplex noise.</a>
<a name="ln1130"> * The first two parameters are required for 2D noise, the next two are</a>
<a name="ln1131"> * optional for and specify 3D or 4D, respectively.</a>
<a name="ln1132"> * @tparam number x</a>
<a name="ln1133"> * @tparam number y</a>
<a name="ln1134"> * @tparam[opt] number z</a>
<a name="ln1135"> * @tparam[optchain] number w</a>
<a name="ln1136"> * @treturn number</a>
<a name="ln1137"> * @function simplex</a>
<a name="ln1138"> */</a>
<a name="ln1139">// TODO: Could support octaves here but maybe it can be handled more</a>
<a name="ln1140">// flexibly in lua</a>
<a name="ln1141">static int crawl_simplex(lua_State *ls)</a>
<a name="ln1142">{</a>
<a name="ln1143">    int dims = 0;</a>
<a name="ln1144">    double vals[4];</a>
<a name="ln1145">    if (lua_isnumber(ls,1))</a>
<a name="ln1146">    {</a>
<a name="ln1147">        vals[dims] = lua_tonumber(ls,1);</a>
<a name="ln1148">        dims++;</a>
<a name="ln1149">    }</a>
<a name="ln1150">    if (lua_isnumber(ls,2))</a>
<a name="ln1151">    {</a>
<a name="ln1152">        vals[dims] = lua_tonumber(ls,2);</a>
<a name="ln1153">        dims++;</a>
<a name="ln1154">    }</a>
<a name="ln1155">    if (lua_isnumber(ls,3))</a>
<a name="ln1156">    {</a>
<a name="ln1157">        vals[dims] = lua_tonumber(ls,3);</a>
<a name="ln1158">        dims++;</a>
<a name="ln1159">    }</a>
<a name="ln1160">    if (lua_isnumber(ls,4))</a>
<a name="ln1161">    {</a>
<a name="ln1162">        vals[dims] = lua_tonumber(ls,4);</a>
<a name="ln1163">        dims++;</a>
<a name="ln1164">    }</a>
<a name="ln1165"> </a>
<a name="ln1166">    double result;</a>
<a name="ln1167">    switch (dims)</a>
<a name="ln1168">    {</a>
<a name="ln1169">    case 2:</a>
<a name="ln1170">        result = perlin::noise(vals[0],vals[1]);</a>
<a name="ln1171">        break;</a>
<a name="ln1172">    case 3:</a>
<a name="ln1173">        result = perlin::noise(vals[0],vals[1],vals[2]);</a>
<a name="ln1174">        break;</a>
<a name="ln1175">    case 4:</a>
<a name="ln1176">        result = perlin::noise(vals[0],vals[1],vals[2],vals[3]);</a>
<a name="ln1177">        break;</a>
<a name="ln1178">    default:</a>
<a name="ln1179">        return 0; // TODO: Throw error?</a>
<a name="ln1180">    }</a>
<a name="ln1181">    lua_pushnumber(ls, result);</a>
<a name="ln1182"> </a>
<a name="ln1183">    return 1;</a>
<a name="ln1184">}</a>
<a name="ln1185"> </a>
<a name="ln1186">/*** Are we running under tiles?</a>
<a name="ln1187"> * @treturn boolean</a>
<a name="ln1188"> * @function is_tiles</a>
<a name="ln1189"> */</a>
<a name="ln1190">static int crawl_is_tiles(lua_State *ls)</a>
<a name="ln1191">{</a>
<a name="ln1192">    lua_pushboolean(ls, is_tiles());</a>
<a name="ln1193"> </a>
<a name="ln1194">    return 1;</a>
<a name="ln1195">}</a>
<a name="ln1196"> </a>
<a name="ln1197">/*** Are we running under webtiles?</a>
<a name="ln1198"> * Note: returns true if the crawl binary is a webtiles build, even if the</a>
<a name="ln1199"> * player is currently using console.</a>
<a name="ln1200"> * @treturn boolean</a>
<a name="ln1201"> * @function is_webtiles</a>
<a name="ln1202"> */</a>
<a name="ln1203">static int crawl_is_webtiles(lua_State *ls)</a>
<a name="ln1204">{</a>
<a name="ln1205">#ifdef USE_TILE_WEB</a>
<a name="ln1206">    lua_pushboolean(ls, true);</a>
<a name="ln1207">#else</a>
<a name="ln1208">    lua_pushboolean(ls, false);</a>
<a name="ln1209">#endif</a>
<a name="ln1210"> </a>
<a name="ln1211">    return 1;</a>
<a name="ln1212">}</a>
<a name="ln1213"> </a>
<a name="ln1214">/*** Are we using the touch ui?</a>
<a name="ln1215"> * @treturn boolean</a>
<a name="ln1216"> * @function is_touch_ui</a>
<a name="ln1217"> */</a>
<a name="ln1218">static int crawl_is_touch_ui(lua_State *ls)</a>
<a name="ln1219">{</a>
<a name="ln1220">#ifdef TOUCH_UI</a>
<a name="ln1221">    lua_pushboolean(ls, true);</a>
<a name="ln1222">#else</a>
<a name="ln1223">    lua_pushboolean(ls, false);</a>
<a name="ln1224">#endif</a>
<a name="ln1225"> </a>
<a name="ln1226">    return 1;</a>
<a name="ln1227">}</a>
<a name="ln1228"> </a>
<a name="ln1229">/*** Look up the current key bound to a command.</a>
<a name="ln1230"> * @tparam string name Name as in cmd-name.h</a>
<a name="ln1231"> * @treturn string|nil</a>
<a name="ln1232"> * @function get_command</a>
<a name="ln1233"> */</a>
<a name="ln1234">static int crawl_get_command(lua_State *ls)</a>
<a name="ln1235">{</a>
<a name="ln1236">    if (lua_gettop(ls) == 0)</a>
<a name="ln1237">    {</a>
<a name="ln1238">        lua_pushnil(ls);</a>
<a name="ln1239">        return 1;</a>
<a name="ln1240">    }</a>
<a name="ln1241"> </a>
<a name="ln1242">    const command_type cmd = name_to_command(luaL_checkstring(ls, 1));</a>
<a name="ln1243"> </a>
<a name="ln1244">    string cmd_name = command_to_string(cmd, true);</a>
<a name="ln1245">    if (strcmp(cmd_name.c_str(), &quot;&lt;&quot;) == 0)</a>
<a name="ln1246">        cmd_name = &quot;&lt;&lt;&quot;;</a>
<a name="ln1247"> </a>
<a name="ln1248">    lua_pushstring(ls, cmd_name.c_str());</a>
<a name="ln1249">    return 1;</a>
<a name="ln1250">}</a>
<a name="ln1251"> </a>
<a name="ln1252">LUAWRAP(crawl_endgame, screen_end_game(luaL_checkstring(ls, 1)))</a>
<a name="ln1253">LUAWRAP(crawl_tutorial_hunger, set_tutorial_hunger(luaL_safe_checkint(ls, 1)))</a>
<a name="ln1254">LUAWRAP(crawl_tutorial_skill, set_tutorial_skill(luaL_checkstring(ls, 1), luaL_safe_checkint(ls, 2)))</a>
<a name="ln1255">LUAWRAP(crawl_tutorial_hint, tutorial_init_hint(luaL_checkstring(ls, 1)))</a>
<a name="ln1256">LUAWRAP(crawl_print_hint, print_hint(luaL_checkstring(ls, 1)))</a>
<a name="ln1257"> </a>
<a name="ln1258">/*** Lua error trace a call</a>
<a name="ln1259"> * Attempts to call-trace a lua function that is producing an error.</a>
<a name="ln1260"> * Returns normally if the function runs normally, otherwise sends</a>
<a name="ln1261"> * @param function</a>
<a name="ln1262"> * @param args</a>
<a name="ln1263"> * @return the result of the call if successful</a>
<a name="ln1264"> * @function err_trace</a>
<a name="ln1265"> */</a>
<a name="ln1266">static int crawl_err_trace(lua_State *ls)</a>
<a name="ln1267">{</a>
<a name="ln1268">    const int nargs = lua_gettop(ls);</a>
<a name="ln1269">    const int err = lua_pcall(ls, nargs - 1, LUA_MULTRET, 0);</a>
<a name="ln1270"> </a>
<a name="ln1271">    if (err)</a>
<a name="ln1272">    {</a>
<a name="ln1273">        // This code from lua.c:traceback() (mostly)</a>
<a name="ln1274">        (void) lua_tostring(ls, 1);</a>
<a name="ln1275">        lua_getfield(ls, LUA_GLOBALSINDEX, &quot;debug&quot;);</a>
<a name="ln1276">        if (!lua_istable(ls, -1))</a>
<a name="ln1277">        {</a>
<a name="ln1278">            lua_pop(ls, 1);</a>
<a name="ln1279">            return lua_error(ls);</a>
<a name="ln1280">        }</a>
<a name="ln1281">        lua_getfield(ls, -1, &quot;traceback&quot;);</a>
<a name="ln1282">        if (!lua_isfunction(ls, -1))</a>
<a name="ln1283">        {</a>
<a name="ln1284">            lua_pop(ls, 2);</a>
<a name="ln1285">            return lua_error(ls);</a>
<a name="ln1286">        }</a>
<a name="ln1287">        lua_pushvalue(ls, 1);</a>
<a name="ln1288">        lua_pushinteger(ls, 2); // Skip crawl_err_trace and traceback.</a>
<a name="ln1289">        lua_call(ls, 2, 1);</a>
<a name="ln1290"> </a>
<a name="ln1291">        // What's on top should be the error.</a>
<a name="ln1292">        lua_error(ls);</a>
<a name="ln1293">    }</a>
<a name="ln1294"> </a>
<a name="ln1295">    return lua_gettop(ls);</a>
<a name="ln1296">}</a>
<a name="ln1297"> </a>
<a name="ln1298">static int crawl_tutorial_msg(lua_State *ls)</a>
<a name="ln1299">{</a>
<a name="ln1300">    const char *key = luaL_checkstring(ls, 1);</a>
<a name="ln1301">    if (!key)</a>
<a name="ln1302">        return 0;</a>
<a name="ln1303">    tutorial_msg(key, lua_isboolean(ls, 2) &amp;&amp; lua_toboolean(ls, 2));</a>
<a name="ln1304">    return 0;</a>
<a name="ln1305">}</a>
<a name="ln1306"> </a>
<a name="ln1307">/*** Produce a character dump</a>
<a name="ln1308"> * @function dump_char</a>
<a name="ln1309"> */</a>
<a name="ln1310">LUAWRAP(crawl_dump_char, dump_char(you.your_name, true))</a>
<a name="ln1311"> </a>
<a name="ln1312">/*** Call lua in dungeon (dlua) context.</a>
<a name="ln1313"> *</a>
<a name="ln1314"> * @tparam string chunk code run</a>
<a name="ln1315"> * @return a scalar return value from dlua context</a>
<a name="ln1316"> * @function call_dlua</a>
<a name="ln1317"> */</a>
<a name="ln1318">#ifdef WIZARD</a>
<a name="ln1319">static int crawl_call_dlua(lua_State *ls)</a>
<a name="ln1320">{</a>
<a name="ln1321">    if (!you.wizard)</a>
<a name="ln1322">        luaL_error(ls, &quot;This function is wizard mode only.&quot;);</a>
<a name="ln1323"> </a>
<a name="ln1324">    const char* code = luaL_checkstring(ls, 1);</a>
<a name="ln1325">    if (!code)</a>
<a name="ln1326">        return 0;</a>
<a name="ln1327"> </a>
<a name="ln1328">    luaL_loadbuffer(dlua, code, strlen(code), &quot;call_dlua&quot;);</a>
<a name="ln1329">    int status = lua_pcall(dlua, 0, LUA_MULTRET, 0);</a>
<a name="ln1330"> </a>
<a name="ln1331">    if (status)</a>
<a name="ln1332">    {</a>
<a name="ln1333">        if (!lua_isnil(dlua, -1))</a>
<a name="ln1334">        {</a>
<a name="ln1335">            const char *msg = lua_tostring(dlua, -1);</a>
<a name="ln1336">            if (msg == nullptr)</a>
<a name="ln1337">                msg = &quot;(error object is not a string)&quot;;</a>
<a name="ln1338">            mprf(MSGCH_ERROR, &quot;%s&quot;, msg);</a>
<a name="ln1339">        }</a>
<a name="ln1340"> </a>
<a name="ln1341">        lua_settop(dlua, 0); // don't bother unwinding, just nuke the stack</a>
<a name="ln1342">        return 0;</a>
<a name="ln1343">    }</a>
<a name="ln1344"> </a>
<a name="ln1345">    if (lua_gettop(dlua) &gt; 0)</a>
<a name="ln1346">    {</a>
<a name="ln1347">        // TODO: shuttle things other than a single scalar value</a>
<a name="ln1348">        if (lua_isnil(dlua, -1))</a>
<a name="ln1349">            lua_pushnil(ls);</a>
<a name="ln1350">        else if (lua_isboolean(dlua, -1))</a>
<a name="ln1351">            lua_pushboolean(ls, lua_toboolean(dlua, -1));</a>
<a name="ln1352">        else if (lua_isnumber(dlua, -1))</a>
<a name="ln1353">            lua_pushnumber(ls, lua_tonumber(dlua, -1));</a>
<a name="ln1354">        else if (const char *ret = lua_tostring(dlua, -1))</a>
<a name="ln1355">            lua_pushstring(ls, ret);</a>
<a name="ln1356">        else</a>
<a name="ln1357">        {</a>
<a name="ln1358">            mprf(MSGCH_ERROR, &quot;call_dlua: cannot pass non-scalars yet (TODO)&quot;);</a>
<a name="ln1359">            lua_pushnil(ls);</a>
<a name="ln1360">        }</a>
<a name="ln1361"> </a>
<a name="ln1362">        lua_settop(dlua, 0); // clear the stack</a>
<a name="ln1363">        return 1;</a>
<a name="ln1364">    }</a>
<a name="ln1365"> </a>
<a name="ln1366">    return 0;</a>
<a name="ln1367">}</a>
<a name="ln1368">#endif</a>
<a name="ln1369"> </a>
<a name="ln1370">/*** Get the crawl version</a>
<a name="ln1371"> * The optional argument is a string from &quot;long&quot;, &quot;major&quot;, or &quot;short&quot; to</a>
<a name="ln1372"> * determine which version type to return. The argument * check is</a>
<a name="ln1373"> * case-insensitive.</a>
<a name="ln1374"> * @tparam[opt=&quot;long&quot;] string fmt</a>
<a name="ln1375"> * @treturn string</a>
<a name="ln1376"> * @function version</a>
<a name="ln1377"> */</a>
<a name="ln1378">static int crawl_version(lua_State *ls)</a>
<a name="ln1379">{</a>
<a name="ln1380">    string type = &quot;long&quot;;</a>
<a name="ln1381">    if (lua_gettop(ls) &gt; 0)</a>
<a name="ln1382">    {</a>
<a name="ln1383">        const char *ltype = luaL_checkstring(ls, 1);</a>
<a name="ln1384">        if (ltype)</a>
<a name="ln1385">            type = lowercase_string(ltype);</a>
<a name="ln1386">    }</a>
<a name="ln1387"> </a>
<a name="ln1388">    if (type == &quot;long&quot;)</a>
<a name="ln1389">        lua_pushstring(ls, Version::Long);</a>
<a name="ln1390">    else if (type == &quot;short&quot;)</a>
<a name="ln1391">        lua_pushstring(ls, Version::Short);</a>
<a name="ln1392">    else if (type == &quot;major&quot;)</a>
<a name="ln1393">        lua_pushstring(ls, Version::Major);</a>
<a name="ln1394">    else</a>
<a name="ln1395">    {</a>
<a name="ln1396">        luaL_argerror(ls, 1,</a>
<a name="ln1397">                      &quot;must be a string \&quot;long\&quot;, \&quot;short\&quot;, or \&quot;major\&quot;&quot;); return 0;</a>
<a name="ln1398">    }</a>
<a name="ln1399">    return 1;</a>
<a name="ln1400">}</a>
<a name="ln1401"> </a>
<a name="ln1402">static const struct luaL_reg crawl_clib[] =</a>
<a name="ln1403">{</a>
<a name="ln1404">    { &quot;mpr&quot;,                crawl_mpr },</a>
<a name="ln1405">    { &quot;formatted_mpr&quot;,      crawl_formatted_mpr },</a>
<a name="ln1406">    { &quot;dpr&quot;,                crawl_dpr },</a>
<a name="ln1407">    { &quot;stderr&quot;,             crawl_stderr },</a>
<a name="ln1408">    { &quot;more&quot;,               crawl_more },</a>
<a name="ln1409">    { &quot;more_autoclear&quot;,     crawl_set_more_autoclear },</a>
<a name="ln1410">    { &quot;enable_more&quot;,        crawl_enable_more },</a>
<a name="ln1411">    { &quot;flush_prev_message&quot;, crawl_flush_prev_message },</a>
<a name="ln1412">    { &quot;clear_messages&quot;,     crawl_clear_messages },</a>
<a name="ln1413">    { &quot;delay&quot;,              crawl_delay },</a>
<a name="ln1414">    { &quot;random2&quot;,            crawl_random2 },</a>
<a name="ln1415">    { &quot;one_chance_in&quot;,      crawl_one_chance_in },</a>
<a name="ln1416">    { &quot;random2avg&quot;,         crawl_random2avg },</a>
<a name="ln1417">    { &quot;coinflip&quot;,           crawl_coinflip },</a>
<a name="ln1418">    { &quot;roll_dice&quot;,          crawl_roll_dice },</a>
<a name="ln1419">    { &quot;x_chance_in_y&quot;,      crawl_x_chance_in_y },</a>
<a name="ln1420">    { &quot;random_range&quot;,       crawl_random_range },</a>
<a name="ln1421">    { &quot;div_rand_round&quot;,     crawl_div_rand_round },</a>
<a name="ln1422">    { &quot;random_real&quot;,        crawl_random_real },</a>
<a name="ln1423">    { &quot;worley&quot;,             crawl_worley },</a>
<a name="ln1424">    { &quot;worley_diff&quot;,        crawl_worley_diff },</a>
<a name="ln1425">    { &quot;split_bytes&quot;,        crawl_split_bytes },</a>
<a name="ln1426">    { &quot;simplex&quot;,            crawl_simplex },</a>
<a name="ln1427"> </a>
<a name="ln1428">    { &quot;redraw_screen&quot;,      crawl_redraw_screen },</a>
<a name="ln1429">    { &quot;c_input_line&quot;,       crawl_c_input_line},</a>
<a name="ln1430">    { &quot;get_target&quot;,         crawl_get_target },</a>
<a name="ln1431">    { &quot;getch&quot;,              crawl_getch },</a>
<a name="ln1432">    { &quot;yesno&quot;,              crawl_yesno },</a>
<a name="ln1433">    { &quot;yesnoquit&quot;,          crawl_yesnoquit },</a>
<a name="ln1434">    { &quot;kbhit&quot;,              crawl_kbhit },</a>
<a name="ln1435">    { &quot;flush_input&quot;,        crawl_flush_input },</a>
<a name="ln1436">    { &quot;sendkeys&quot;,           crawl_sendkeys },</a>
<a name="ln1437">    { &quot;process_command&quot;,    crawl_process_command },</a>
<a name="ln1438">    { &quot;process_keys&quot;,       crawl_process_keys },</a>
<a name="ln1439">    { &quot;set_sendkeys_errors&quot;, crawl_set_sendkeys_errors },</a>
<a name="ln1440">    { &quot;do_commands&quot;,        crawl_do_commands },</a>
<a name="ln1441">#ifdef USE_SOUND</a>
<a name="ln1442">    { &quot;playsound&quot;,          crawl_playsound },</a>
<a name="ln1443">#endif</a>
<a name="ln1444">    { &quot;runmacro&quot;,           crawl_runmacro },</a>
<a name="ln1445">    { &quot;bindkey&quot;,            crawl_bindkey },</a>
<a name="ln1446">    { &quot;setopt&quot;,             crawl_setopt },</a>
<a name="ln1447">    { &quot;read_options&quot;,       crawl_read_options },</a>
<a name="ln1448">    { &quot;msgch_num&quot;,          crawl_msgch_num },</a>
<a name="ln1449">    { &quot;msgch_name&quot;,         crawl_msgch_name },</a>
<a name="ln1450">    { &quot;take_note&quot;,          crawl_take_note },</a>
<a name="ln1451">    { &quot;messages&quot;,           crawl_messages },</a>
<a name="ln1452">    { &quot;regex&quot;,              crawl_regex },</a>
<a name="ln1453">    { &quot;message_filter&quot;,     crawl_message_filter },</a>
<a name="ln1454">    { &quot;trim&quot;,               crawl_trim },</a>
<a name="ln1455">    { &quot;split&quot;,              crawl_split },</a>
<a name="ln1456">    { &quot;string_compare&quot;,     crawl_string_compare },</a>
<a name="ln1457">    { &quot;grammar&quot;,            _crawl_grammar },</a>
<a name="ln1458">    { &quot;article_a&quot;,          crawl_article_a },</a>
<a name="ln1459">    { &quot;game_started&quot;,       crawl_game_started },</a>
<a name="ln1460">    { &quot;stat_gain_prompt&quot;,   crawl_stat_gain_prompt },</a>
<a name="ln1461">    { &quot;is_tiles&quot;,           crawl_is_tiles },</a>
<a name="ln1462">    { &quot;is_webtiles&quot;,        crawl_is_webtiles },</a>
<a name="ln1463">    { &quot;is_touch_ui&quot;,        crawl_is_touch_ui },</a>
<a name="ln1464">    { &quot;err_trace&quot;,          crawl_err_trace },</a>
<a name="ln1465">    { &quot;get_command&quot;,        crawl_get_command },</a>
<a name="ln1466">    { &quot;endgame&quot;,            crawl_endgame },</a>
<a name="ln1467">    { &quot;tutorial_msg&quot;,       crawl_tutorial_msg },</a>
<a name="ln1468">    { &quot;dump_char&quot;,          crawl_dump_char },</a>
<a name="ln1469">#ifdef WIZARD</a>
<a name="ln1470">    { &quot;call_dlua&quot;,          crawl_call_dlua },</a>
<a name="ln1471">#endif</a>
<a name="ln1472">    { &quot;version&quot;,            crawl_version },</a>
<a name="ln1473">    { &quot;weapon_check&quot;,       crawl_weapon_check},</a>
<a name="ln1474">    { nullptr, nullptr },</a>
<a name="ln1475">};</a>
<a name="ln1476"> </a>
<a name="ln1477">void cluaopen_crawl(lua_State *ls)</a>
<a name="ln1478">{</a>
<a name="ln1479">    clua_register_metatable(ls, REGEX_METATABLE, crawl_regex_ops,</a>
<a name="ln1480">                            lua_object_gc&lt;text_pattern&gt;);</a>
<a name="ln1481">    clua_register_metatable(ls, MESSF_METATABLE, crawl_messf_ops,</a>
<a name="ln1482">                            lua_object_gc&lt;message_filter&gt;);</a>
<a name="ln1483"> </a>
<a name="ln1484">    luaL_openlib(ls, &quot;crawl&quot;, crawl_clib, 0);</a>
<a name="ln1485">}</a>
<a name="ln1486"> </a>
<a name="ln1487">//</a>
<a name="ln1488">// Non-user-accessible bindings (dlua).</a>
<a name="ln1489">//</a>
<a name="ln1490"> </a>
<a name="ln1491">/*** Get the commandline arguments</a>
<a name="ln1492"> * @within dlua</a>
<a name="ln1493"> * @treturn table</a>
<a name="ln1494"> * @function args</a>
<a name="ln1495"> */</a>
<a name="ln1496">LUAFN(_crawl_args)</a>
<a name="ln1497">{</a>
<a name="ln1498">    return clua_stringtable(ls, SysEnv.cmd_args);</a>
<a name="ln1499">}</a>
<a name="ln1500"> </a>
<a name="ln1501">/*** Mark a milestone</a>
<a name="ln1502"> * Register a dgl milestone. No op if not a dgl game.</a>
<a name="ln1503"> * @within dlua</a>
<a name="ln1504"> * @tparam string type</a>
<a name="ln1505"> * @tparam string milestone</a>
<a name="ln1506"> * @tparam string origin</a>
<a name="ln1507"> * @function milestone</a>
<a name="ln1508"> */</a>
<a name="ln1509">LUAFN(_crawl_milestone)</a>
<a name="ln1510">{</a>
<a name="ln1511">    mark_milestone(luaL_checkstring(ls, 1),</a>
<a name="ln1512">                   luaL_checkstring(ls, 2),</a>
<a name="ln1513">                   luaL_checkstring(ls, 3));</a>
<a name="ln1514">    return 0;</a>
<a name="ln1515">}</a>
<a name="ln1516"> </a>
<a name="ln1517">/*** Redraw the viewwindow.</a>
<a name="ln1518"> * You probably want @{redraw_screen} unless you specifically want only the</a>
<a name="ln1519"> * view window.</a>
<a name="ln1520"> * @within dlua</a>
<a name="ln1521"> * @function redraw_view</a>
<a name="ln1522"> */</a>
<a name="ln1523">LUAWRAP(_crawl_redraw_view, viewwindow())</a>
<a name="ln1524"> </a>
<a name="ln1525">/*** Redraw the player stats.</a>
<a name="ln1526"> * You probably want @{redraw_screen} unless you specifically want only the</a>
<a name="ln1527"> * player stats.</a>
<a name="ln1528"> * @within dlua</a>
<a name="ln1529"> * @function redraw_stats</a>
<a name="ln1530"> */</a>
<a name="ln1531">LUAFN(_crawl_redraw_stats)</a>
<a name="ln1532">{</a>
<a name="ln1533">    UNUSED(ls);</a>
<a name="ln1534"> </a>
<a name="ln1535">    you.wield_change         = true;</a>
<a name="ln1536">    you.redraw_title         = true;</a>
<a name="ln1537">    you.redraw_quiver        = true;</a>
<a name="ln1538">    you.redraw_hit_points    = true;</a>
<a name="ln1539">    you.redraw_magic_points  = true;</a>
<a name="ln1540">    you.redraw_stats.init(true);</a>
<a name="ln1541">    you.redraw_experience    = true;</a>
<a name="ln1542">    you.redraw_armour_class  = true;</a>
<a name="ln1543">    you.redraw_evasion       = true;</a>
<a name="ln1544">    you.redraw_status_lights = true;</a>
<a name="ln1545"> </a>
<a name="ln1546">    print_stats();</a>
<a name="ln1547">    return 0;</a>
<a name="ln1548">}</a>
<a name="ln1549"> </a>
<a name="ln1550">/*** Current milliseconds.</a>
<a name="ln1551"> * Gives the current milliseconds of the time of day.</a>
<a name="ln1552"> * @within dlua</a>
<a name="ln1553"> * @treturn int</a>
<a name="ln1554"> * @function millis</a>
<a name="ln1555"> */</a>
<a name="ln1556">LUAFN(_crawl_millis)</a>
<a name="ln1557">{</a>
<a name="ln1558">#ifdef TARGET_OS_WINDOWS</a>
<a name="ln1559">    // MSVC has no gettimeofday().</a>
<a name="ln1560">    FILETIME ft;</a>
<a name="ln1561">    GetSystemTimeAsFileTime(&amp;ft);</a>
<a name="ln1562">    uint64_t tt = ft.dwHighDateTime;</a>
<a name="ln1563">    tt &lt;&lt;= 32;</a>
<a name="ln1564">    tt |= ft.dwLowDateTime;</a>
<a name="ln1565">    tt /= 10000;</a>
<a name="ln1566">    tt -= 11644473600000ULL;</a>
<a name="ln1567">    lua_pushnumber(ls, tt);</a>
<a name="ln1568">#else</a>
<a name="ln1569">    struct timeval tv;</a>
<a name="ln1570">    gettimeofday(&amp;tv, nullptr);</a>
<a name="ln1571">    lua_pushnumber(ls, tv.tv_sec * 1000 + tv.tv_usec / 1000);</a>
<a name="ln1572">#endif</a>
<a name="ln1573">    return 1;</a>
<a name="ln1574">}</a>
<a name="ln1575">static string _crawl_make_name(lua_State */*ls*/)</a>
<a name="ln1576">{</a>
<a name="ln1577">    // A quick wrapper around itemname:make_name.</a>
<a name="ln1578">    return make_name();</a>
<a name="ln1579">}</a>
<a name="ln1580"> </a>
<a name="ln1581"> </a>
<a name="ln1582">/*** Make an item name at random.</a>
<a name="ln1583"> * @within dlua</a>
<a name="ln1584"> * @treturn string</a>
<a name="ln1585"> * @function make_name</a>
<a name="ln1586"> */</a>
<a name="ln1587">LUARET1(crawl_make_name, string, _crawl_make_name(ls).c_str())</a>
<a name="ln1588"> </a>
<a name="ln1589">/* Check that a Lua argument is a god name, and store that god's enum in</a>
<a name="ln1590"> *  a variable.</a>
<a name="ln1591"> *</a>
<a name="ln1592"> *  @param argno  The Lua argument number of the god name. Evaluated once.</a>
<a name="ln1593"> *  @param godvar An existing writable lvalue to hold the enumeration value</a>
<a name="ln1594"> *                of the god. Evaluated zero or one times.</a>
<a name="ln1595"> *  @param fn     The identifier to use as the function name in an error</a>
<a name="ln1596"> *                message. Should generally be the Lua name of the calling</a>
<a name="ln1597"> *                function. Stringified, not evaluated.</a>
<a name="ln1598"> *</a>
<a name="ln1599"> *  @post If argument (argno) was not a string containing a valid god name,</a>
<a name="ln1600"> *        we returned from the calling function with a Lua argument error.</a>
<a name="ln1601"> *        godvar may or may not have been evaluated and/or assigned to.</a>
<a name="ln1602"> *  @post If argument (argno) was a valid god name, godvar was evaluated</a>
<a name="ln1603"> *        exactly once and assigned that god's enum value.</a>
<a name="ln1604"> */</a>
<a name="ln1605">#define CHECK_GOD_ARG(argno, godvar, fn) do                              \</a>
<a name="ln1606">    {                                                                    \</a>
<a name="ln1607">        int _cg_arg = (argno);                                           \</a>
<a name="ln1608">        const char *_cg_name = luaL_checkstring(ls, _cg_arg);            \</a>
<a name="ln1609">        if (!_cg_name)                                                   \</a>
<a name="ln1610">            return luaL_argerror(ls, _cg_arg, #fn &quot; requires a god!&quot;);   \</a>
<a name="ln1611">        if (((godvar) = str_to_god(_cg_name)) == GOD_NO_GOD)             \</a>
<a name="ln1612">        {                                                                \</a>
<a name="ln1613">            return luaL_argerror(ls, _cg_arg,                            \</a>
<a name="ln1614">                       make_stringf(&quot;'%s' matches no god.&quot;,              \</a>
<a name="ln1615">                                    _cg_name).c_str());                  \</a>
<a name="ln1616">        }                                                                \</a>
<a name="ln1617">    } while (0)</a>
<a name="ln1618"> </a>
<a name="ln1619">/*** Check if a god is still available.</a>
<a name="ln1620"> * For gods that are no longer appearing in new games, and Jiyva if its been</a>
<a name="ln1621"> * killed by the player.</a>
<a name="ln1622"> * @within dlua</a>
<a name="ln1623"> * @tparam string godname</a>
<a name="ln1624"> * @treturn boolean</a>
<a name="ln1625"> * @function unavailable_god</a>
<a name="ln1626"> */</a>
<a name="ln1627">LUAFN(_crawl_unavailable_god)</a>
<a name="ln1628">{</a>
<a name="ln1629">    god_type god = GOD_NO_GOD;</a>
<a name="ln1630">    CHECK_GOD_ARG(1, god, unavailable_god);</a>
<a name="ln1631">    lua_pushboolean(ls, is_unavailable_god(god));</a>
<a name="ln1632">    return 1;</a>
<a name="ln1633">}</a>
<a name="ln1634"> </a>
<a name="ln1635">/*** Divine voices.</a>
<a name="ln1636"> * @within dlua</a>
<a name="ln1637"> * @tparam string Name of a current crawl god.</a>
<a name="ln1638"> * @tparam string Speach</a>
<a name="ln1639"> * @function god_speaks</a>
<a name="ln1640"> */</a>
<a name="ln1641">LUAFN(_crawl_god_speaks)</a>
<a name="ln1642">{</a>
<a name="ln1643">    if (!crawl_state.io_inited)</a>
<a name="ln1644">        return 0;</a>
<a name="ln1645"> </a>
<a name="ln1646">    god_type god = GOD_NO_GOD;</a>
<a name="ln1647">    CHECK_GOD_ARG(1, god, god_speaks);</a>
<a name="ln1648"> </a>
<a name="ln1649">    const char *message = luaL_checkstring(ls, 2);</a>
<a name="ln1650">    if (!message)</a>
<a name="ln1651">        return 0;</a>
<a name="ln1652"> </a>
<a name="ln1653">    god_speaks(god, message);</a>
<a name="ln1654">    return 0;</a>
<a name="ln1655">}</a>
<a name="ln1656"> </a>
<a name="ln1657">/*** Set Max Runes</a>
<a name="ln1658"> * Modify the total number of obtainable runes.</a>
<a name="ln1659"> * @within dlua</a>
<a name="ln1660"> * @tparam int nrune</a>
<a name="ln1661"> * @function set_max_runes</a>
<a name="ln1662"> */</a>
<a name="ln1663">LUAFN(_crawl_set_max_runes)</a>
<a name="ln1664">{</a>
<a name="ln1665">    int max_runes = luaL_safe_checkint(ls, 1);</a>
<a name="ln1666">    if (max_runes &lt; 0 || max_runes &gt; NUM_RUNE_TYPES)</a>
<a name="ln1667">        luaL_error(ls, make_stringf(&quot;Bad number of max runes: %d&quot;, max_runes).c_str());</a>
<a name="ln1668">    else</a>
<a name="ln1669">        you.obtainable_runes = max_runes;</a>
<a name="ln1670">    return 0;</a>
<a name="ln1671">}</a>
<a name="ln1672"> </a>
<a name="ln1673">LUAWRAP(_crawl_mark_game_won, crawl_state.mark_last_game_won())</a>
<a name="ln1674"> </a>
<a name="ln1675">LUAFN(crawl_hints_type)</a>
<a name="ln1676">{</a>
<a name="ln1677">    if (crawl_state.game_is_tutorial())</a>
<a name="ln1678">        lua_pushstring(ls, &quot;tutorial&quot;);</a>
<a name="ln1679">    else if (!crawl_state.game_is_hints())</a>
<a name="ln1680">        lua_pushstring(ls, &quot;&quot;);</a>
<a name="ln1681">    else</a>
<a name="ln1682">        switch (Hints.hints_type)</a>
<a name="ln1683">        {</a>
<a name="ln1684">        case HINT_BERSERK_CHAR:</a>
<a name="ln1685">            lua_pushstring(ls, &quot;berserk&quot;);</a>
<a name="ln1686">            break;</a>
<a name="ln1687">        case HINT_RANGER_CHAR:</a>
<a name="ln1688">            lua_pushstring(ls, &quot;ranger&quot;);</a>
<a name="ln1689">            break;</a>
<a name="ln1690">        case HINT_MAGIC_CHAR:</a>
<a name="ln1691">            lua_pushstring(ls, &quot;magic&quot;);</a>
<a name="ln1692">            break;</a>
<a name="ln1693">        default:</a>
<a name="ln1694">            die(&quot;invalid hints_type&quot;);</a>
<a name="ln1695">        }</a>
<a name="ln1696">    return 1;</a>
<a name="ln1697">}</a>
<a name="ln1698"> </a>
<a name="ln1699">LUAFN(crawl_rng_wrap)</a>
<a name="ln1700">{</a>
<a name="ln1701">    if (!lua_isstring(ls, 2))</a>
<a name="ln1702">        luaL_error(ls, &quot;rng_wrap missing rng name&quot;);</a>
<a name="ln1703">    string rng_name = lua_tostring(ls, 2);</a>
<a name="ln1704">    if (!rng_name.size())</a>
<a name="ln1705">        luaL_error(ls, &quot;rng_wrap missing rng name&quot;);</a>
<a name="ln1706">    rng::rng_type r = rng::NUM_RNGS;</a>
<a name="ln1707">    if (rng_name == &quot;gameplay&quot;)</a>
<a name="ln1708">        r = rng::GAMEPLAY;</a>
<a name="ln1709">    else if (rng_name == &quot;ui&quot;)</a>
<a name="ln1710">        r = rng::UI;</a>
<a name="ln1711">    else if (rng_name == &quot;system_specific&quot;)</a>
<a name="ln1712">        r = rng::SYSTEM_SPECIFIC;</a>
<a name="ln1713">    else if (rng_name == &quot;subgenerator&quot;)</a>
<a name="ln1714">        r = rng::SUB_GENERATOR;</a>
<a name="ln1715">    else</a>
<a name="ln1716">    {</a>
<a name="ln1717">        branch_type b = NUM_BRANCHES;</a>
<a name="ln1718">        if ((b = branch_by_shortname(rng_name)) == NUM_BRANCHES)</a>
<a name="ln1719">            if ((b = branch_by_abbrevname(rng_name)) == NUM_BRANCHES)</a>
<a name="ln1720">                luaL_error(ls, &quot;Unknown rng name %s&quot;, rng_name.c_str());</a>
<a name="ln1721">        r = rng::get_branch_generator(b);</a>
<a name="ln1722">    }</a>
<a name="ln1723"> </a>
<a name="ln1724">    lua_pop(ls, 1); // get rid of the rng name</a>
<a name="ln1725">    if (!lua_isfunction(ls, 1))</a>
<a name="ln1726">        luaL_error(ls, &quot;rng_wrap missing function&quot;);</a>
<a name="ln1727">    int result;</a>
<a name="ln1728">    if (r == rng::SUB_GENERATOR)</a>
<a name="ln1729">    {</a>
<a name="ln1730">        rng::subgenerator subgen; // TODO: implement seed + seq?</a>
<a name="ln1731">        result = lua_pcall(ls, 0, LUA_MULTRET, 0);</a>
<a name="ln1732">    }</a>
<a name="ln1733">    else</a>
<a name="ln1734">    {</a>
<a name="ln1735">        rng::generator gen(r); // generator to use</a>
<a name="ln1736">        result = lua_pcall(ls, 0, LUA_MULTRET, 0);</a>
<a name="ln1737">    }</a>
<a name="ln1738">    if (result != 0)</a>
<a name="ln1739">        luaL_error(ls, &quot;Failed to run rng-wrapped function (%d)&quot;, result);</a>
<a name="ln1740">    return lua_gettop(ls);</a>
<a name="ln1741">}</a>
<a name="ln1742"> </a>
<a name="ln1743">static const struct luaL_reg crawl_dlib[] =</a>
<a name="ln1744">{</a>
<a name="ln1745">{ &quot;args&quot;, _crawl_args },</a>
<a name="ln1746">{ &quot;mark_milestone&quot;, _crawl_milestone },</a>
<a name="ln1747">{ &quot;redraw_view&quot;, _crawl_redraw_view },</a>
<a name="ln1748">{ &quot;redraw_stats&quot;, _crawl_redraw_stats },</a>
<a name="ln1749">{ &quot;god_speaks&quot;, _crawl_god_speaks },</a>
<a name="ln1750">{ &quot;millis&quot;, _crawl_millis },</a>
<a name="ln1751">{ &quot;make_name&quot;, crawl_make_name },</a>
<a name="ln1752">{ &quot;set_max_runes&quot;, _crawl_set_max_runes },</a>
<a name="ln1753">{ &quot;tutorial_hunger&quot;, crawl_tutorial_hunger },</a>
<a name="ln1754">{ &quot;tutorial_skill&quot;,  crawl_tutorial_skill },</a>
<a name="ln1755">{ &quot;tutorial_hint&quot;,   crawl_tutorial_hint },</a>
<a name="ln1756">{ &quot;print_hint&quot;, crawl_print_hint },</a>
<a name="ln1757">{ &quot;mark_game_won&quot;, _crawl_mark_game_won },</a>
<a name="ln1758">{ &quot;hints_type&quot;, crawl_hints_type },</a>
<a name="ln1759">{ &quot;unavailable_god&quot;, _crawl_unavailable_god },</a>
<a name="ln1760">{ &quot;rng_wrap&quot;, crawl_rng_wrap },</a>
<a name="ln1761"> </a>
<a name="ln1762">{ nullptr, nullptr }</a>
<a name="ln1763">};</a>
<a name="ln1764"> </a>
<a name="ln1765">void dluaopen_crawl(lua_State *ls)</a>
<a name="ln1766">{</a>
<a name="ln1767">    luaL_openlib(ls, &quot;crawl&quot;, crawl_dlib, 0);</a>
<a name="ln1768">}</a>

</code></pre>
<div class="balloon" rel="243"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v601/" target="_blank">V601</a> The bool type is implicitly cast to the double type. Inspect the second argument.</p></div>

<link rel="stylesheet" href="highlight.css">
<script src="highlight.pack.js"></script>
<script src="highlightjs-line-numbers.js"></script>
<script>hljs.initHighlightingOnLoad();</script>
<script>hljs.initLineNumbersOnLoad();</script>
<script>
  $(document).ready(function() {
      $('.balloon').each(function () {
          var bl = $(this);
          var line = bl.attr('rel');
          var text = $('a[name="ln'+line+'"]').text();

          var space_count = 0;
          for(var i = 0; i<text.length; i++){
              var char = text[i];
              if((char !== ' ')&&(char !== '\t'))break;
              if(char === '\t')space_count++;
              space_count++;
          }

          bl.css('margin-left', space_count*8);
          $('a[name="ln'+line+'"]').after(bl);
      });

      window.location = window.location;
  });
</script>
</body>
</html>
