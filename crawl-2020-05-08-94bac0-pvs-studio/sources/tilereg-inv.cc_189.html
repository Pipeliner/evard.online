
<html>
<head>

  <meta http-equiv="Content-Type" content="text/html; charset=US-ASCII" />
  <title>tilereg-inv.cc</title>

  <link rel="stylesheet" href="../style.css"/>
  <script src="../jquery-3.2.1.min.js"></script>
</head>
<body>

<pre><code class = "cpp">
<a name="ln1">#include &quot;AppHdr.h&quot;</a>
<a name="ln2"> </a>
<a name="ln3">#ifdef USE_TILE_LOCAL</a>
<a name="ln4"> </a>
<a name="ln5">#include &quot;tilereg-inv.h&quot;</a>
<a name="ln6"> </a>
<a name="ln7">#include &quot;cio.h&quot;</a>
<a name="ln8">#include &quot;describe.h&quot;</a>
<a name="ln9">#include &quot;env.h&quot;</a>
<a name="ln10">#include &quot;food.h&quot;</a>
<a name="ln11">#include &quot;invent.h&quot;</a>
<a name="ln12">#include &quot;item-name.h&quot;</a>
<a name="ln13">#include &quot;item-prop.h&quot;</a>
<a name="ln14">#include &quot;items.h&quot;</a>
<a name="ln15">#include &quot;item-status-flag-type.h&quot;</a>
<a name="ln16">#include &quot;item-use.h&quot;</a>
<a name="ln17">#include &quot;libutil.h&quot;</a>
<a name="ln18">#include &quot;macro.h&quot;</a>
<a name="ln19">#include &quot;message.h&quot;</a>
<a name="ln20">#include &quot;options.h&quot;</a>
<a name="ln21">#include &quot;output.h&quot;</a>
<a name="ln22">#include &quot;spl-book.h&quot;</a>
<a name="ln23">#include &quot;stringutil.h&quot;</a>
<a name="ln24">#include &quot;terrain.h&quot;</a>
<a name="ln25">#include &quot;tile-inventory-flags.h&quot;</a>
<a name="ln26">#include &quot;rltiles/tiledef-dngn.h&quot;</a>
<a name="ln27">#include &quot;rltiles/tiledef-icons.h&quot;</a>
<a name="ln28">#include &quot;rltiles/tiledef-icons.h&quot;</a>
<a name="ln29">#include &quot;rltiles/tiledef-main.h&quot;</a>
<a name="ln30">#include &quot;tilepick.h&quot;</a>
<a name="ln31">#include &quot;unicode.h&quot;</a>
<a name="ln32"> </a>
<a name="ln33">InventoryRegion::InventoryRegion(const TileRegionInit &amp;init) : GridRegion(init)</a>
<a name="ln34">{</a>
<a name="ln35">}</a>
<a name="ln36"> </a>
<a name="ln37">void InventoryRegion::pack_buffers()</a>
<a name="ln38">{</a>
<a name="ln39">    unsigned int i = 0 + (m_grid_page*mx*my - m_grid_page*2); // this has to match the logic in cursor_index()</a>
<a name="ln40">    for (int y = 0; y &lt; my; y++)</a>
<a name="ln41">    {</a>
<a name="ln42">        for (int x = 0; x &lt; mx; x++)</a>
<a name="ln43">        {</a>
<a name="ln44">            if (i &gt;= m_items.size())</a>
<a name="ln45">                break;</a>
<a name="ln46"> </a>
<a name="ln47">            InventoryTile &amp;item = m_items[i++];</a>
<a name="ln48"> </a>
<a name="ln49">            if (item.flag &amp; TILEI_FLAG_FLOOR)</a>
<a name="ln50">            {</a>
<a name="ln51">                if (i &gt; (unsigned int) mx * my * (m_grid_page+1) &amp;&amp; item.tile)</a>
<a name="ln52">                    break;</a>
<a name="ln53"> </a>
<a name="ln54">                int num_floor = tile_dngn_count(env.tile_default.floor);</a>
<a name="ln55">                tileidx_t t = env.tile_default.floor + i % num_floor;</a>
<a name="ln56">                m_buf.add_dngn_tile(t, x, y);</a>
<a name="ln57">            }</a>
<a name="ln58">            else</a>
<a name="ln59">                m_buf.add_main_tile(TILE_ITEM_SLOT, x, y);</a>
<a name="ln60">        }</a>
<a name="ln61">    }</a>
<a name="ln62"> </a>
<a name="ln63">    i = 0 + (m_grid_page*mx*my - m_grid_page*2); // this also has to match the logic in cursor_index()</a>
<a name="ln64">    for (int y = 0; y &lt; my; y++)</a>
<a name="ln65">    {</a>
<a name="ln66">        for (int x = 0; x &lt; mx; x++)</a>
<a name="ln67">        {</a>
<a name="ln68">            if (i &gt;= m_items.size())</a>
<a name="ln69">                break;</a>
<a name="ln70"> </a>
<a name="ln71">            InventoryTile &amp;item = m_items[i++];</a>
<a name="ln72"> </a>
<a name="ln73">            if (_is_next_button(i-1))</a>
<a name="ln74">            {</a>
<a name="ln75">                // continuation to next page icon</a>
<a name="ln76">                m_buf.add_main_tile(TILE_UNSEEN_ITEM, x, y);</a>
<a name="ln77">                continue;</a>
<a name="ln78">            }</a>
<a name="ln79">            else if (y==0 &amp;&amp; x==0 &amp;&amp; m_grid_page&gt;0)</a>
<a name="ln80">            {</a>
<a name="ln81">                // previous page icon</a>
<a name="ln82">                m_buf.add_main_tile(TILE_UNSEEN_ITEM, x, y);</a>
<a name="ln83">                continue;</a>
<a name="ln84">            }</a>
<a name="ln85"> </a>
<a name="ln86">            if (item.flag &amp; TILEI_FLAG_EQUIP)</a>
<a name="ln87">            {</a>
<a name="ln88">                if (item.flag &amp; TILEI_FLAG_CURSE)</a>
<a name="ln89">                    m_buf.add_main_tile(TILE_ITEM_SLOT_EQUIP_CURSED, x, y);</a>
<a name="ln90">                else</a>
<a name="ln91">                    m_buf.add_main_tile(TILE_ITEM_SLOT_EQUIP, x, y);</a>
<a name="ln92"> </a>
<a name="ln93">                if (item.flag &amp; TILEI_FLAG_MELDED)</a>
<a name="ln94">                    m_buf.add_icons_tile(TILEI_MESH, x, y);</a>
<a name="ln95">            }</a>
<a name="ln96">            else if (item.flag &amp; TILEI_FLAG_CURSE)</a>
<a name="ln97">                m_buf.add_main_tile(TILE_ITEM_SLOT_CURSED, x, y);</a>
<a name="ln98"> </a>
<a name="ln99">            if (item.flag &amp; TILEI_FLAG_SELECT)</a>
<a name="ln100">                m_buf.add_icons_tile(TILEI_ITEM_SLOT_SELECTED, x, y);</a>
<a name="ln101"> </a>
<a name="ln102">            if (item.flag &amp; TILEI_FLAG_CURSOR)</a>
<a name="ln103">                m_buf.add_icons_tile(TILEI_CURSOR, x, y);</a>
<a name="ln104"> </a>
<a name="ln105">            if (item.tile)</a>
<a name="ln106">                m_buf.add_main_tile(item.tile, x, y);</a>
<a name="ln107"> </a>
<a name="ln108">            if (item.quantity != -1)</a>
<a name="ln109">                draw_number(x, y, item.quantity);</a>
<a name="ln110"> </a>
<a name="ln111">            if (item.special)</a>
<a name="ln112">                m_buf.add_main_tile(item.special, x, y, 0, 0);</a>
<a name="ln113"> </a>
<a name="ln114">            if (item.flag &amp; TILEI_FLAG_INVALID)</a>
<a name="ln115">                m_buf.add_icons_tile(TILEI_MESH, x, y);</a>
<a name="ln116">        }</a>
<a name="ln117">    }</a>
<a name="ln118">}</a>
<a name="ln119"> </a>
<a name="ln120">int InventoryRegion::handle_mouse(wm_mouse_event &amp;event)</a>
<a name="ln121">{</a>
<a name="ln122">    unsigned int item_idx;</a>
<a name="ln123">    if (!place_cursor(event, item_idx))</a>
<a name="ln124">        return 0;</a>
<a name="ln125"> </a>
<a name="ln126">    // handle paging</a>
<a name="ln127">    if (_is_next_button(cursor_index()) &amp;&amp; event.button==wm_mouse_event::LEFT)</a>
<a name="ln128">    {</a>
<a name="ln129">        // next page</a>
<a name="ln130">        m_grid_page++;</a>
<a name="ln131">        update();</a>
<a name="ln132">        return CK_NO_KEY;</a>
<a name="ln133">    }</a>
<a name="ln134">    else if (m_cursor.x==0 &amp;&amp; m_cursor.y==0 &amp;&amp; m_grid_page&gt;0 &amp;&amp; event.button==wm_mouse_event::LEFT)</a>
<a name="ln135">    {</a>
<a name="ln136">        // prev page</a>
<a name="ln137">        m_grid_page--;</a>
<a name="ln138">        update();</a>
<a name="ln139">        return CK_NO_KEY;</a>
<a name="ln140">    }</a>
<a name="ln141"> </a>
<a name="ln142">    int idx = m_items[item_idx].idx;</a>
<a name="ln143"> </a>
<a name="ln144">    bool on_floor = m_items[item_idx].flag &amp; TILEI_FLAG_FLOOR;</a>
<a name="ln145"> </a>
<a name="ln146">    ASSERT(idx &gt;= 0);</a>
<a name="ln147"> </a>
<a name="ln148">    if (tiles.is_using_small_layout())</a>
<a name="ln149">    {</a>
<a name="ln150">        // close the inventory tab after successfully clicking on an item</a>
<a name="ln151">        tiles.deactivate_tab();</a>
<a name="ln152">    }</a>
<a name="ln153"> </a>
<a name="ln154">    // TODO enne - this is all really only valid for the on-screen inventory</a>
<a name="ln155">    // Do we subclass InventoryRegion for the onscreen and offscreen versions?</a>
<a name="ln156">    char key = m_items[item_idx].key;</a>
<a name="ln157">    if (key)</a>
<a name="ln158">        return key;</a>
<a name="ln159"> </a>
<a name="ln160">    if (event.button == wm_mouse_event::LEFT)</a>
<a name="ln161">    {</a>
<a name="ln162">        m_last_clicked_item = item_idx;</a>
<a name="ln163">        tiles.set_need_redraw();</a>
<a name="ln164">        if (on_floor)</a>
<a name="ln165">        {</a>
<a name="ln166">            if (event.mod &amp; TILES_MOD_SHIFT)</a>
<a name="ln167">                tile_item_use_floor(idx);</a>
<a name="ln168">            else</a>
<a name="ln169">                tile_item_pickup(idx, (event.mod &amp; TILES_MOD_CTRL));</a>
<a name="ln170">        }</a>
<a name="ln171">        else</a>
<a name="ln172">        {</a>
<a name="ln173">            if (event.mod &amp; TILES_MOD_SHIFT)</a>
<a name="ln174">                tile_item_drop(idx, (event.mod &amp; TILES_MOD_CTRL));</a>
<a name="ln175">            else if (event.mod &amp; TILES_MOD_CTRL)</a>
<a name="ln176">                tile_item_use_secondary(idx);</a>
<a name="ln177">            else</a>
<a name="ln178">                tile_item_use(idx);</a>
<a name="ln179">        }</a>
<a name="ln180">        update();</a>
<a name="ln181">        return CK_MOUSE_CMD;</a>
<a name="ln182">    }</a>
<a name="ln183">    else if (event.button == wm_mouse_event::RIGHT)</a>
<a name="ln184">    {</a>
<a name="ln185">        if (on_floor)</a>
<a name="ln186">        {</a>
<a name="ln187">            if (event.mod &amp; TILES_MOD_SHIFT)</a>
<a name="ln188">            {</a>
<a name="ln189">                m_last_clicked_item = item_idx;</a>
<a name="ln190">                tiles.set_need_redraw();</a>
<a name="ln191">                tile_item_eat_floor(idx);</a>
<a name="ln192">            }</a>
<a name="ln193">            else</a>
<a name="ln194">            {</a>
<a name="ln195">                describe_item(mitm[idx]);</a>
<a name="ln196">                redraw_screen();</a>
<a name="ln197">            }</a>
<a name="ln198">        }</a>
<a name="ln199">        else // in inventory</a>
<a name="ln200">        {</a>
<a name="ln201">            describe_item(you.inv[idx]);</a>
<a name="ln202">            redraw_screen();</a>
<a name="ln203">        }</a>
<a name="ln204">        return CK_MOUSE_CMD;</a>
<a name="ln205">    }</a>
<a name="ln206"> </a>
<a name="ln207">    return 0;</a>
<a name="ln208">}</a>
<a name="ln209"> </a>
<a name="ln210">// NOTE: Assumes the item is equipped in the first place!</a>
<a name="ln211">static bool _is_true_equipped_item(const item_def &amp;item)</a>
<a name="ln212">{</a>
<a name="ln213">    // Weapons and staves are only truly equipped if wielded.</a>
<a name="ln214">    if (item.link == you.equip[EQ_WEAPON])</a>
<a name="ln215">        return is_weapon(item);</a>
<a name="ln216"> </a>
<a name="ln217">    // Cursed armour and rings are only truly equipped if *not* wielded.</a>
<a name="ln218">    return item.link != you.equip[EQ_WEAPON];</a>
<a name="ln219">}</a>
<a name="ln220"> </a>
<a name="ln221">// Returns whether there's any action you can take with an item in inventory</a>
<a name="ln222">// apart from dropping it.</a>
<a name="ln223">static bool _can_use_item(const item_def &amp;item, bool equipped)</a>
<a name="ln224">{</a>
<a name="ln225">#if TAG_MAJOR_VERSION == 34</a>
<a name="ln226">    // There's nothing you can do with an empty box if you can't unwield it.</a>
<a name="ln227">    if (!equipped &amp;&amp; item.sub_type == MISC_BUGGY_EBONY_CASKET)</a>
<a name="ln228">        return false;</a>
<a name="ln229">#endif</a>
<a name="ln230"> </a>
<a name="ln231">    if (equipped &amp;&amp; item.cursed())</a>
<a name="ln232">    {</a>
<a name="ln233">        // Evocable items (e.g. dispater staff) are still evocable when cursed.</a>
<a name="ln234">        if (item_is_evokable(item))</a>
<a name="ln235">            return true;</a>
<a name="ln236"> </a>
<a name="ln237">        // You can't unwield/fire a wielded cursed weapon/staff</a>
<a name="ln238">        // but cursed armour and rings can be unwielded without problems.</a>
<a name="ln239">        return !_is_true_equipped_item(item);</a>
<a name="ln240">    }</a>
<a name="ln241"> </a>
<a name="ln242">    // Mummies can't do anything with food or potions.</a>
<a name="ln243">    if (you.species == SP_MUMMY)</a>
<a name="ln244">        return item.base_type != OBJ_POTIONS &amp;&amp; item.base_type != OBJ_FOOD;</a>
<a name="ln245"> </a>
<a name="ln246">    // In all other cases you can use the item in some way.</a>
<a name="ln247">    return true;</a>
<a name="ln248">}</a>
<a name="ln249"> </a>
<a name="ln250">static void _handle_wield_tip(string &amp;tip, vector&lt;command_type&gt; &amp;cmd,</a>
<a name="ln251">                              const string prefix = &quot;&quot;, bool unwield = false)</a>
<a name="ln252">{</a>
<a name="ln253">    tip += prefix;</a>
<a name="ln254">    if (unwield)</a>
<a name="ln255">        tip += &quot;Unwield (%-)&quot;;</a>
<a name="ln256">    else</a>
<a name="ln257">        tip += &quot;Wield (%)&quot;;</a>
<a name="ln258">    cmd.push_back(CMD_WIELD_WEAPON);</a>
<a name="ln259">}</a>
<a name="ln260"> </a>
<a name="ln261">bool InventoryRegion::update_tab_tip_text(string &amp;tip, bool active)</a>
<a name="ln262">{</a>
<a name="ln263">    const char *prefix1 = active ? &quot;&quot; : &quot;[L-Click] &quot;;</a>
<a name="ln264">    const char *prefix2 = active ? &quot;&quot; : &quot;          &quot;;</a>
<a name="ln265"> </a>
<a name="ln266">    tip = make_stringf(&quot;%s%s\n%s%s&quot;,</a>
<a name="ln267">                       prefix1, &quot;Display inventory&quot;,</a>
<a name="ln268">                       prefix2, &quot;Use items&quot;);</a>
<a name="ln269"> </a>
<a name="ln270">    return true;</a>
<a name="ln271">}</a>
<a name="ln272"> </a>
<a name="ln273">bool InventoryRegion::update_tip_text(string&amp; tip)</a>
<a name="ln274">{</a>
<a name="ln275">    if (m_cursor == NO_CURSOR)</a>
<a name="ln276">        return false;</a>
<a name="ln277"> </a>
<a name="ln278">    unsigned int item_idx = cursor_index();</a>
<a name="ln279">    if (item_idx &gt;= m_items.size() || m_items[item_idx].empty())</a>
<a name="ln280">        return false;</a>
<a name="ln281"> </a>
<a name="ln282">    // page next/prev</a>
<a name="ln283">    if (_is_next_button(item_idx))</a>
<a name="ln284">    {</a>
<a name="ln285">        tip = &quot;Next page\n[L-Click] Show next page of items&quot;;</a>
<a name="ln286">        return true;</a>
<a name="ln287">    }</a>
<a name="ln288">    else if (_is_prev_button(item_idx))</a>
<a name="ln289">    {</a>
<a name="ln290">        tip = &quot;Previous page\n[L-Click] Show previous page of items&quot;;</a>
<a name="ln291">        return true;</a>
<a name="ln292">    }</a>
<a name="ln293"> </a>
<a name="ln294">    int idx = m_items[item_idx].idx;</a>
<a name="ln295"> </a>
<a name="ln296">    // TODO enne - consider subclassing this class, rather than depending</a>
<a name="ln297">    // on &quot;key&quot; to determine if this is the crt inventory or the on screen one.</a>
<a name="ln298">    bool display_actions = (m_items[item_idx].key == 0</a>
<a name="ln299">                    &amp;&amp; mouse_control::current_mode() == MOUSE_MODE_COMMAND);</a>
<a name="ln300"> </a>
<a name="ln301">    // TODO enne - should the command keys here respect keymaps?</a>
<a name="ln302">    vector&lt;command_type&gt; cmd;</a>
<a name="ln303">    if (m_items[item_idx].flag &amp; TILEI_FLAG_FLOOR)</a>
<a name="ln304">    {</a>
<a name="ln305">        const item_def &amp;item = mitm[idx];</a>
<a name="ln306"> </a>
<a name="ln307">        if (!item.defined())</a>
<a name="ln308">            return false;</a>
<a name="ln309"> </a>
<a name="ln310">        tip = &quot;&quot;;</a>
<a name="ln311">        if (m_items[item_idx].key)</a>
<a name="ln312">        {</a>
<a name="ln313">            tip = m_items[item_idx].key;</a>
<a name="ln314">            tip += &quot; - &quot;;</a>
<a name="ln315">        }</a>
<a name="ln316"> </a>
<a name="ln317">        tip += item.name(DESC_A);</a>
<a name="ln318"> </a>
<a name="ln319">        if (!display_actions)</a>
<a name="ln320">            return true;</a>
<a name="ln321"> </a>
<a name="ln322">        if (item_is_stationary_net(item))</a>
<a name="ln323">        {</a>
<a name="ln324">            actor *trapped = actor_at(item.pos);</a>
<a name="ln325">            tip += make_stringf(&quot; (holding %s)&quot;,</a>
<a name="ln326">                            trapped ? trapped-&gt;name(DESC_A).c_str()</a>
<a name="ln327">                                    : &quot;nobody&quot;); // buggy net, but don't crash</a>
<a name="ln328">        }</a>
<a name="ln329"> </a>
<a name="ln330">        if (!item_is_stationary(item))</a>
<a name="ln331">        {</a>
<a name="ln332">            tip += &quot;\n[L-Click] Pick up (%)&quot;;</a>
<a name="ln333">            cmd.push_back(CMD_PICKUP);</a>
<a name="ln334">            if (item.quantity &gt; 1)</a>
<a name="ln335">            {</a>
<a name="ln336">                tip += &quot;\n[Ctrl + L-Click] Partial pick up (%)&quot;;</a>
<a name="ln337">                cmd.push_back(CMD_PICKUP_QUANTITY);</a>
<a name="ln338">            }</a>
<a name="ln339">        }</a>
<a name="ln340">        if (item.base_type == OBJ_CORPSES</a>
<a name="ln341">            &amp;&amp; item.sub_type != CORPSE_SKELETON)</a>
<a name="ln342">        {</a>
<a name="ln343">            tip += &quot;\n[Shift + L-Click] Chop up (%)&quot;;</a>
<a name="ln344">            cmd.push_back(CMD_BUTCHER);</a>
<a name="ln345">        }</a>
<a name="ln346">        else if (item.base_type == OBJ_FOOD</a>
<a name="ln347">                 &amp;&amp; !you_foodless())</a>
<a name="ln348">        {</a>
<a name="ln349">            tip += &quot;\n[Shift + R-Click] Eat (e)&quot;;</a>
<a name="ln350">            cmd.push_back(CMD_EAT);</a>
<a name="ln351">        }</a>
<a name="ln352">    }</a>
<a name="ln353">    else</a>
<a name="ln354">    {</a>
<a name="ln355">        const item_def &amp;item = you.inv[idx];</a>
<a name="ln356">        if (!item.defined())</a>
<a name="ln357">            return false;</a>
<a name="ln358"> </a>
<a name="ln359">        tip = item.name(DESC_INVENTORY_EQUIP);</a>
<a name="ln360"> </a>
<a name="ln361">        if (!display_actions)</a>
<a name="ln362">            return true;</a>
<a name="ln363"> </a>
<a name="ln364">        int type = item.base_type;</a>
<a name="ln365">        const bool equipped = m_items[item_idx].flag &amp; TILEI_FLAG_EQUIP;</a>
<a name="ln366">        bool wielded = (you.equip[EQ_WEAPON] == idx);</a>
<a name="ln367"> </a>
<a name="ln368">        const int EQUIP_OFFSET = NUM_OBJECT_CLASSES;</a>
<a name="ln369"> </a>
<a name="ln370">        if (_can_use_item(item, equipped))</a>
<a name="ln371">        {</a>
<a name="ln372">            string tip_prefix = &quot;\n[L-Click] &quot;;</a>
<a name="ln373">            string tmp = &quot;&quot;;</a>
<a name="ln374">            if (equipped)</a>
<a name="ln375">            {</a>
<a name="ln376">                if (wielded &amp;&amp; !item_is_evokable(item))</a>
<a name="ln377">                {</a>
<a name="ln378">                    if (type == OBJ_JEWELLERY || type == OBJ_ARMOUR</a>
<a name="ln379">                        || is_weapon(item))</a>
<a name="ln380">                    {</a>
<a name="ln381">                        type = OBJ_WEAPONS + EQUIP_OFFSET;</a>
<a name="ln382">                    }</a>
<a name="ln383">                }</a>
<a name="ln384">                else</a>
<a name="ln385">                    type += EQUIP_OFFSET;</a>
<a name="ln386">            }</a>
<a name="ln387"> </a>
<a name="ln388">            switch (type)</a>
<a name="ln389">            {</a>
<a name="ln390">            // first equipable categories</a>
<a name="ln391">            case OBJ_WEAPONS:</a>
<a name="ln392">            case OBJ_STAVES:</a>
<a name="ln393">                if (you.species != SP_FELID)</a>
<a name="ln394">                {</a>
<a name="ln395">                    _handle_wield_tip(tmp, cmd);</a>
<a name="ln396">                    if (is_throwable(&amp;you, item))</a>
<a name="ln397">                    {</a>
<a name="ln398">                        tmp += &quot;\n[Ctrl + L-Click] Fire (f)&quot;;</a>
<a name="ln399">                        cmd.push_back(CMD_FIRE);</a>
<a name="ln400">                    }</a>
<a name="ln401">                }</a>
<a name="ln402">                break;</a>
<a name="ln403">            case OBJ_WEAPONS + EQUIP_OFFSET:</a>
<a name="ln404">                _handle_wield_tip(tmp, cmd, &quot;&quot;, true);</a>
<a name="ln405">                if (is_throwable(&amp;you, item))</a>
<a name="ln406">                {</a>
<a name="ln407">                    tmp += &quot;\n[Ctrl + L-Click] Fire (f)&quot;;</a>
<a name="ln408">                    cmd.push_back(CMD_FIRE);</a>
<a name="ln409">                }</a>
<a name="ln410">                break;</a>
<a name="ln411">            case OBJ_MISCELLANY:</a>
<a name="ln412">                tmp += &quot;Evoke (V)&quot;;</a>
<a name="ln413">                cmd.push_back(CMD_EVOKE);</a>
<a name="ln414">                break;</a>
<a name="ln415">            case OBJ_MISCELLANY + EQUIP_OFFSET:</a>
<a name="ln416">#if TAG_MAJOR_VERSION == 34</a>
<a name="ln417">            case OBJ_RODS + EQUIP_OFFSET:</a>
<a name="ln418">                tmp += &quot;Evoke (%)&quot;;</a>
<a name="ln419">                cmd.push_back(CMD_EVOKE_WIELDED);</a>
<a name="ln420">                _handle_wield_tip(tmp, cmd, &quot;\n[Ctrl + L-Click] &quot;, true);</a>
<a name="ln421">                break;</a>
<a name="ln422">#endif</a>
<a name="ln423">            case OBJ_ARMOUR:</a>
<a name="ln424">                if (you.species != SP_FELID)</a>
<a name="ln425">                {</a>
<a name="ln426">                    tmp += &quot;Wear (%)&quot;;</a>
<a name="ln427">                    cmd.push_back(CMD_WEAR_ARMOUR);</a>
<a name="ln428">                }</a>
<a name="ln429">                break;</a>
<a name="ln430">            case OBJ_ARMOUR + EQUIP_OFFSET:</a>
<a name="ln431">                tmp += &quot;Take off (%)&quot;;</a>
<a name="ln432">                cmd.push_back(CMD_REMOVE_ARMOUR);</a>
<a name="ln433">                break;</a>
<a name="ln434">            case OBJ_JEWELLERY:</a>
<a name="ln435">                tmp += &quot;Put on (%)&quot;;</a>
<a name="ln436">                cmd.push_back(CMD_WEAR_JEWELLERY);</a>
<a name="ln437">                break;</a>
<a name="ln438">            case OBJ_JEWELLERY + EQUIP_OFFSET:</a>
<a name="ln439">                tmp += &quot;Remove (%)&quot;;</a>
<a name="ln440">                cmd.push_back(CMD_REMOVE_JEWELLERY);</a>
<a name="ln441">                break;</a>
<a name="ln442">            case OBJ_MISSILES:</a>
<a name="ln443">                if (you.species != SP_FELID)</a>
<a name="ln444">                {</a>
<a name="ln445">                    tmp += &quot;Fire (%)&quot;;</a>
<a name="ln446">                    cmd.push_back(CMD_FIRE);</a>
<a name="ln447"> </a>
<a name="ln448">                    if (wielded || you.can_wield(item))</a>
<a name="ln449">                        _handle_wield_tip(tmp, cmd, &quot;\n[Ctrl + L-Click] &quot;, wielded);</a>
<a name="ln450">                }</a>
<a name="ln451">                break;</a>
<a name="ln452">            case OBJ_WANDS:</a>
<a name="ln453">                if (you.species != SP_FELID)</a>
<a name="ln454">                {</a>
<a name="ln455">                    tmp += &quot;Evoke (%)&quot;;</a>
<a name="ln456">                    cmd.push_back(CMD_EVOKE);</a>
<a name="ln457">                    if (wielded)</a>
<a name="ln458">                        _handle_wield_tip(tmp, cmd, &quot;\n[Ctrl + L-Click] &quot;, true);</a>
<a name="ln459">                }</a>
<a name="ln460">                break;</a>
<a name="ln461">            case OBJ_BOOKS:</a>
<a name="ln462">                if (item_type_known(item) &amp;&amp; item_is_spellbook(item)</a>
<a name="ln463">                    &amp;&amp; can_learn_spell(true))</a>
<a name="ln464">                {</a>
<a name="ln465">                    tmp += &quot;Memorise (%)&quot;;</a>
<a name="ln466">                    cmd.push_back(CMD_MEMORISE_SPELL);</a>
<a name="ln467">                    if (wielded)</a>
<a name="ln468">                        _handle_wield_tip(tmp, cmd, &quot;\n[Ctrl + L-Click] &quot;, true);</a>
<a name="ln469">                    break;</a>
<a name="ln470">                }</a>
<a name="ln471">                if (item.sub_type == BOOK_MANUAL)</a>
<a name="ln472">                    break;</a>
<a name="ln473">                // else fall-through</a>
<a name="ln474">            case OBJ_SCROLLS:</a>
<a name="ln475">                tmp += &quot;Read (%)&quot;;</a>
<a name="ln476">                cmd.push_back(CMD_READ);</a>
<a name="ln477">                if (wielded)</a>
<a name="ln478">                    _handle_wield_tip(tmp, cmd, &quot;\n[Ctrl + L-Click] &quot;, true);</a>
<a name="ln479">                break;</a>
<a name="ln480">            case OBJ_POTIONS:</a>
<a name="ln481">                tmp += &quot;Quaff (%)&quot;;</a>
<a name="ln482">                cmd.push_back(CMD_QUAFF);</a>
<a name="ln483">                if (wielded)</a>
<a name="ln484">                    _handle_wield_tip(tmp, cmd, &quot;\n[Ctrl + L-Click] &quot;, true);</a>
<a name="ln485">                break;</a>
<a name="ln486">            case OBJ_FOOD:</a>
<a name="ln487">                tmp += &quot;Eat (%)&quot;;</a>
<a name="ln488">                cmd.push_back(CMD_EAT);</a>
<a name="ln489">                if (wielded)</a>
<a name="ln490">                    _handle_wield_tip(tmp, cmd, &quot;\n[Ctrl + L-Click] &quot;, true);</a>
<a name="ln491">                break;</a>
<a name="ln492">            case OBJ_CORPSES:</a>
<a name="ln493">                if (wielded)</a>
<a name="ln494">                    _handle_wield_tip(tmp, cmd, &quot;\n[Ctrl + L-Click] &quot;, true);</a>
<a name="ln495">                break;</a>
<a name="ln496">            default:</a>
<a name="ln497">                tmp += &quot;Use&quot;;</a>
<a name="ln498">            }</a>
<a name="ln499"> </a>
<a name="ln500">            if (!tmp.empty())</a>
<a name="ln501">                tip += tip_prefix + tmp;</a>
<a name="ln502">        }</a>
<a name="ln503"> </a>
<a name="ln504">        tip += &quot;\n[R-Click] Describe&quot;;</a>
<a name="ln505">        // Has to be non-equipped or non-cursed to drop.</a>
<a name="ln506">        if (!equipped || !_is_true_equipped_item(you.inv[idx])</a>
<a name="ln507">            || !you.inv[idx].cursed())</a>
<a name="ln508">        {</a>
<a name="ln509">            tip += &quot;\n[Shift + L-Click] Drop (%)&quot;;</a>
<a name="ln510">            cmd.push_back(CMD_DROP);</a>
<a name="ln511">            if (you.inv[idx].quantity &gt; 1)</a>
<a name="ln512">            {</a>
<a name="ln513">                tip += &quot;\n[Ctrl-Shift + L-Click] Drop quantity (%#)&quot;;</a>
<a name="ln514">                cmd.push_back(CMD_DROP);</a>
<a name="ln515">            }</a>
<a name="ln516">        }</a>
<a name="ln517">    }</a>
<a name="ln518"> </a>
<a name="ln519">    insert_commands(tip, cmd);</a>
<a name="ln520">    return true;</a>
<a name="ln521">}</a>
<a name="ln522"> </a>
<a name="ln523">bool InventoryRegion::update_alt_text(string &amp;alt)</a>
<a name="ln524">{</a>
<a name="ln525">    if (m_cursor == NO_CURSOR)</a>
<a name="ln526">        return false;</a>
<a name="ln527"> </a>
<a name="ln528">    unsigned int item_idx = cursor_index();</a>
<a name="ln529">    if (item_idx &gt;= m_items.size() || m_items[item_idx].empty())</a>
<a name="ln530">        return false;</a>
<a name="ln531"> </a>
<a name="ln532">    if (m_last_clicked_item &gt;= 0</a>
<a name="ln533">        &amp;&amp; item_idx == (unsigned int) m_last_clicked_item)</a>
<a name="ln534">    {</a>
<a name="ln535">        return false;</a>
<a name="ln536">    }</a>
<a name="ln537"> </a>
<a name="ln538">    int idx = m_items[item_idx].idx;</a>
<a name="ln539">    const item_def *item;</a>
<a name="ln540"> </a>
<a name="ln541">    if (m_items[item_idx].flag &amp; TILEI_FLAG_FLOOR)</a>
<a name="ln542">        item = &amp;mitm[idx];</a>
<a name="ln543">    else</a>
<a name="ln544">        item = &amp;you.inv[idx];</a>
<a name="ln545"> </a>
<a name="ln546">    if (!item-&gt;defined())</a>
<a name="ln547">        return false;</a>
<a name="ln548"> </a>
<a name="ln549">    describe_info inf;</a>
<a name="ln550">    if (_is_next_button(item_idx))</a>
<a name="ln551">    {</a>
<a name="ln552">        // alt text for next page button</a>
<a name="ln553">        inf.title = &quot;Next page&quot;;</a>
<a name="ln554">    }</a>
<a name="ln555">    else if (_is_prev_button(item_idx))</a>
<a name="ln556">    {</a>
<a name="ln557">        // alt text for prev page button</a>
<a name="ln558">        inf.title = &quot;Previous page&quot;;</a>
<a name="ln559">    }</a>
<a name="ln560">    else</a>
<a name="ln561">        get_item_desc(*item, inf);</a>
<a name="ln562"> </a>
<a name="ln563">    alt = process_description(inf);</a>
<a name="ln564">    return true;</a>
<a name="ln565">}</a>
<a name="ln566"> </a>
<a name="ln567">void InventoryRegion::draw_tag()</a>
<a name="ln568">{</a>
<a name="ln569">    if (m_cursor == NO_CURSOR)</a>
<a name="ln570">        return;</a>
<a name="ln571">    int curs_index = cursor_index();</a>
<a name="ln572">    if (curs_index &gt;= (int)m_items.size())</a>
<a name="ln573">        return;</a>
<a name="ln574">    int idx = m_items[curs_index].idx;</a>
<a name="ln575">    if (idx == -1)</a>
<a name="ln576">        return;</a>
<a name="ln577"> </a>
<a name="ln578">    bool floor = m_items[curs_index].flag &amp; TILEI_FLAG_FLOOR;</a>
<a name="ln579"> </a>
<a name="ln580">    if (_is_next_button(curs_index))</a>
<a name="ln581">        draw_desc(&quot;Next page&quot;);</a>
<a name="ln582">    else if (_is_prev_button(curs_index))</a>
<a name="ln583">        draw_desc(&quot;Previous page&quot;);</a>
<a name="ln584">    else if (floor &amp;&amp; mitm[idx].defined())</a>
<a name="ln585">        draw_desc(mitm[idx].name(DESC_PLAIN).c_str());</a>
<a name="ln586">    else if (!floor &amp;&amp; you.inv[idx].defined())</a>
<a name="ln587">        draw_desc(you.inv[idx].name(DESC_INVENTORY_EQUIP).c_str());</a>
<a name="ln588">}</a>
<a name="ln589"> </a>
<a name="ln590">void InventoryRegion::activate()</a>
<a name="ln591">{</a>
<a name="ln592">    if (inv_count() &lt; 1 &amp;&amp; you.num_turns &gt; 0)</a>
<a name="ln593">    {</a>
<a name="ln594">        canned_msg(MSG_NOTHING_CARRIED);</a>
<a name="ln595">        flush_prev_message();</a>
<a name="ln596">    }</a>
<a name="ln597"> </a>
<a name="ln598">    // switch to first page on activation</a>
<a name="ln599">    m_grid_page = 0;</a>
<a name="ln600">}</a>
<a name="ln601"> </a>
<a name="ln602">static void _fill_item_info(InventoryTile &amp;desc, const item_info &amp;item)</a>
<a name="ln603">{</a>
<a name="ln604">    desc.tile = tileidx_item(item);</a>
<a name="ln605"> </a>
<a name="ln606">    int type = item.base_type;</a>
<a name="ln607">    if (is_stackable_item(item))</a>
<a name="ln608">    {</a>
<a name="ln609">        // -1 specifies don't display anything</a>
<a name="ln610">        desc.quantity = (item.quantity == 1) ? -1 : item.quantity;</a>
<a name="ln611">    }</a>
<a name="ln612">    else if (type == OBJ_WANDS &amp;&amp; item.flags &amp; ISFLAG_KNOW_TYPE)</a>
<a name="ln613">        desc.quantity = item.charges;</a>
<a name="ln614">    else</a>
<a name="ln615">        desc.quantity = -1;</a>
<a name="ln616"> </a>
<a name="ln617">    if (type == OBJ_WEAPONS || type == OBJ_MISSILES</a>
<a name="ln618">        || type == OBJ_ARMOUR</a>
<a name="ln619">#if TAG_MAJOR_VERSION == 34</a>
<a name="ln620">        || type == OBJ_RODS</a>
<a name="ln621">#endif</a>
<a name="ln622">       )</a>
<a name="ln623">    {</a>
<a name="ln624">        desc.special = tileidx_known_brand(item);</a>
<a name="ln625">    }</a>
<a name="ln626">    else if (type == OBJ_CORPSES)</a>
<a name="ln627">        desc.special = tileidx_corpse_brand(item);</a>
<a name="ln628"> </a>
<a name="ln629">    desc.flag = 0;</a>
<a name="ln630">    if (item.cursed())</a>
<a name="ln631">        desc.flag |= TILEI_FLAG_CURSE;</a>
<a name="ln632">    if (item.pos.x != -1)</a>
<a name="ln633">        desc.flag |= TILEI_FLAG_FLOOR;</a>
<a name="ln634">}</a>
<a name="ln635"> </a>
<a name="ln636">void InventoryRegion::update()</a>
<a name="ln637">{</a>
<a name="ln638">    m_items.clear();</a>
<a name="ln639">    m_dirty = true;</a>
<a name="ln640"> </a>
<a name="ln641">    if (mx * my == 0)</a>
<a name="ln642">        return;</a>
<a name="ln643"> </a>
<a name="ln644">    const int max_pack_items = ENDOFPACK;</a>
<a name="ln645"> </a>
<a name="ln646">    bool inv_shown[ENDOFPACK];</a>
<a name="ln647">    memset(inv_shown, 0, sizeof(inv_shown));</a>
<a name="ln648"> </a>
<a name="ln649">    int num_ground = 0;</a>
<a name="ln650">    for (int i = you.visible_igrd(you.pos()); i != NON_ITEM; i = mitm[i].link)</a>
<a name="ln651">        num_ground++;</a>
<a name="ln652"> </a>
<a name="ln653">    char32_t c;</a>
<a name="ln654">    const char *tp = Options.tile_show_items.c_str();</a>
<a name="ln655">    int s;</a>
<a name="ln656">    do // Do one last iteration with the 0 char at the end.</a>
<a name="ln657">    {</a>
<a name="ln658">        tp += s = utf8towc(&amp;c, tp); // could be better to store this pre-parsed</a>
<a name="ln659"> </a>
<a name="ln660">        if ((int)m_items.size() &gt;= max_pack_items)</a>
<a name="ln661">            break;</a>
<a name="ln662"> </a>
<a name="ln663">        bool show_any = !c;</a>
<a name="ln664">        object_class_type type = item_class_by_sym(c);</a>
<a name="ln665"> </a>
<a name="ln666">        // First, normal inventory</a>
<a name="ln667">        for (int i = 0; i &lt; ENDOFPACK; ++i)</a>
<a name="ln668">        {</a>
<a name="ln669">            if ((int)m_items.size() &gt;= max_pack_items)</a>
<a name="ln670">                break;</a>
<a name="ln671"> </a>
<a name="ln672">            if (inv_shown[i]</a>
<a name="ln673">                || !you.inv[i].defined()</a>
<a name="ln674">                || you.inv[i].quantity == 0</a>
<a name="ln675">                || (!show_any &amp;&amp; you.inv[i].base_type != type))</a>
<a name="ln676">            {</a>
<a name="ln677">                continue;</a>
<a name="ln678">            }</a>
<a name="ln679"> </a>
<a name="ln680">            InventoryTile desc;</a>
<a name="ln681">            _fill_item_info(desc, get_item_info(you.inv[i]));</a>
<a name="ln682">            desc.idx = i;</a>
<a name="ln683"> </a>
<a name="ln684">            for (int eq = EQ_FIRST_EQUIP; eq &lt; NUM_EQUIP; ++eq)</a>
<a name="ln685">            {</a>
<a name="ln686">                if (you.equip[eq] == i)</a>
<a name="ln687">                {</a>
<a name="ln688">                    desc.flag |= TILEI_FLAG_EQUIP;</a>
<a name="ln689">                    if (you.melded[eq])</a>
<a name="ln690">                        desc.flag |= TILEI_FLAG_MELDED;</a>
<a name="ln691">                    break;</a>
<a name="ln692">                }</a>
<a name="ln693">            }</a>
<a name="ln694"> </a>
<a name="ln695">            inv_shown[i] = true;</a>
<a name="ln696">            m_items.push_back(desc);</a>
<a name="ln697">        }</a>
<a name="ln698">    } while (s);</a>
<a name="ln699"> </a>
<a name="ln700">    // ensure we don't end up stuck on a later page.</a>
<a name="ln701">    const int total_items = m_items.size() + num_ground;</a>
<a name="ln702">    // can store mx*my items on first page, but lose 2 for each following page</a>
<a name="ln703">    // (next &amp; prev buttons)</a>
<a name="ln704">    const int max_page = max(0, (total_items - 2)) / (mx*my - 2);</a>
<a name="ln705">    m_grid_page = min(m_grid_page, max_page);</a>
<a name="ln706"> </a>
<a name="ln707">    const int remaining = mx*my - m_items.size();</a>
<a name="ln708">    const int empty_on_this_row = mx - m_items.size() % mx;</a>
<a name="ln709"> </a>
<a name="ln710">    // If we're not on the last row...</a>
<a name="ln711">    if ((int)m_items.size() &lt; mx * (my-1))</a>
<a name="ln712">        // let's deliberately not do this on page 2</a>
<a name="ln713">    {</a>
<a name="ln714">        if (num_ground &gt; remaining - empty_on_this_row)</a>
<a name="ln715">        {</a>
<a name="ln716">            // Fill out part of this row.</a>
<a name="ln717">            const int fill = remaining - num_ground;</a>
<a name="ln718">            for (int i = 0; i &lt; fill; ++i)</a>
<a name="ln719">            {</a>
<a name="ln720">                InventoryTile desc;</a>
<a name="ln721">                if ((int)m_items.size() &gt;= max_pack_items)</a>
<a name="ln722">                    desc.flag |= TILEI_FLAG_INVALID;</a>
<a name="ln723">                m_items.push_back(desc);</a>
<a name="ln724">            }</a>
<a name="ln725">        }</a>
<a name="ln726">        else</a>
<a name="ln727">        {</a>
<a name="ln728">            // Fill out the rest of this row.</a>
<a name="ln729">            while (m_items.size() % mx != 0)</a>
<a name="ln730">            {</a>
<a name="ln731">                InventoryTile desc;</a>
<a name="ln732">                if ((int)m_items.size() &gt;= max_pack_items)</a>
<a name="ln733">                    desc.flag |= TILEI_FLAG_INVALID;</a>
<a name="ln734">                m_items.push_back(desc);</a>
<a name="ln735">            }</a>
<a name="ln736"> </a>
<a name="ln737">            // Add extra rows, if needed.</a>
<a name="ln738">            unsigned int ground_rows = max((num_ground-1) / mx + 1, 1);</a>
<a name="ln739"> </a>
<a name="ln740">            while ((int)(m_items.size() / mx + ground_rows) &lt; my</a>
<a name="ln741">                   &amp;&amp; ((int)m_items.size()) &lt; max_pack_items)</a>
<a name="ln742">            {</a>
<a name="ln743">                for (int i = 0; i &lt; mx; i++)</a>
<a name="ln744">                {</a>
<a name="ln745">                    InventoryTile desc;</a>
<a name="ln746">                    if ((int)m_items.size() &gt;= max_pack_items)</a>
<a name="ln747">                        desc.flag |= TILEI_FLAG_INVALID;</a>
<a name="ln748">                    m_items.push_back(desc);</a>
<a name="ln749">                }</a>
<a name="ln750">            }</a>
<a name="ln751">        }</a>
<a name="ln752">    }</a>
<a name="ln753"> </a>
<a name="ln754">    // Then, as many ground items as we can fit.</a>
<a name="ln755">    bool ground_shown[MAX_ITEMS];</a>
<a name="ln756">    memset(ground_shown, 0, sizeof(ground_shown));</a>
<a name="ln757"> </a>
<a name="ln758">    tp = Options.tile_show_items.c_str();</a>
<a name="ln759">    do</a>
<a name="ln760">    {</a>
<a name="ln761">        tp += s = utf8towc(&amp;c, tp);</a>
<a name="ln762"> </a>
<a name="ln763">        if ((int)m_items.size() &gt;= mx * my * (m_grid_page+1))</a>
<a name="ln764">            break;</a>
<a name="ln765"> </a>
<a name="ln766">        bool show_any = !c;</a>
<a name="ln767">        object_class_type type = item_class_by_sym(c);</a>
<a name="ln768"> </a>
<a name="ln769">        for (int i = you.visible_igrd(you.pos()); i != NON_ITEM;</a>
<a name="ln770">             i = mitm[i].link)</a>
<a name="ln771">        {</a>
<a name="ln772">            if ((int)m_items.size() &gt;= mx * my * (m_grid_page+1))</a>
<a name="ln773">                break;</a>
<a name="ln774"> </a>
<a name="ln775">            if (ground_shown[i] || !show_any &amp;&amp; mitm[i].base_type != type)</a>
<a name="ln776">                continue;</a>
<a name="ln777"> </a>
<a name="ln778">            InventoryTile desc;</a>
<a name="ln779">            _fill_item_info(desc, get_item_info(mitm[i]));</a>
<a name="ln780">            desc.idx = i;</a>
<a name="ln781">            ground_shown[i] = true;</a>
<a name="ln782"> </a>
<a name="ln783">            m_items.push_back(desc);</a>
<a name="ln784">        }</a>
<a name="ln785">    } while (s);</a>
<a name="ln786"> </a>
<a name="ln787">    while ((int)m_items.size() &lt; mx * my)</a>
<a name="ln788">        // let's not do this for p2 either</a>
<a name="ln789">    {</a>
<a name="ln790">        InventoryTile desc;</a>
<a name="ln791">        desc.flag = TILEI_FLAG_FLOOR;</a>
<a name="ln792">        m_items.push_back(desc);</a>
<a name="ln793">    }</a>
<a name="ln794">}</a>
<a name="ln795"> </a>
<a name="ln796">bool InventoryRegion::_is_prev_button(int idx)</a>
<a name="ln797">{</a>
<a name="ln798">    // idx is an index in m_items as returned by cursor_index()</a>
<a name="ln799">    return m_grid_page&gt;0 &amp;&amp; idx == mx*my*m_grid_page-2*m_grid_page;</a>
<a name="ln800">}</a>
<a name="ln801"> </a>
<a name="ln802">/**</a>
<a name="ln803"> * How many items are we actually looking at (inv+floor), not counting fake</a>
<a name="ln804"> * padding items inserted on the first page?</a>
<a name="ln805"> *</a>
<a name="ln806"> * Only valid for page 1.</a>
<a name="ln807"> */</a>
<a name="ln808">int InventoryRegion::_real_item_count()</a>
<a name="ln809">{</a>
<a name="ln810">    // xxx: this seems like a classic reduce()...</a>
<a name="ln811">    int total = 0;</a>
<a name="ln812">    for (auto desc : m_items)</a>
<a name="ln813">        if (desc.idx != -1)</a>
<a name="ln814">            ++total;</a>
<a name="ln815">    return total;</a>
<a name="ln816">}</a>
<a name="ln817"> </a>
<a name="ln818">bool InventoryRegion::_is_next_button(int idx)</a>
<a name="ln819">{</a>
<a name="ln820">    // idx is an index in m_items as returned by cursor_index()</a>
<a name="ln821">    return idx == (mx*my - 2)*(m_grid_page+1) - 1 + 2</a>
<a name="ln822">            &amp;&amp; _real_item_count() &gt;= mx*my;</a>
<a name="ln823">}</a>
<a name="ln824">#endif</a>

</code></pre>
<div class="balloon" rel="775"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v648/" target="_blank">V648</a> Priority of the '&&' operation is higher than that of the '||' operation.</p></div>

<link rel="stylesheet" href="highlight.css">
<script src="highlight.pack.js"></script>
<script src="highlightjs-line-numbers.js"></script>
<script>hljs.initHighlightingOnLoad();</script>
<script>hljs.initLineNumbersOnLoad();</script>
<script>
  $(document).ready(function() {
      $('.balloon').each(function () {
          var bl = $(this);
          var line = bl.attr('rel');
          var text = $('a[name="ln'+line+'"]').text();

          var space_count = 0;
          for(var i = 0; i<text.length; i++){
              var char = text[i];
              if((char !== ' ')&&(char !== '\t'))break;
              if(char === '\t')space_count++;
              space_count++;
          }

          bl.css('margin-left', space_count*8);
          $('a[name="ln'+line+'"]').after(bl);
      });

      window.location = window.location;
  });
</script>
</body>
</html>
