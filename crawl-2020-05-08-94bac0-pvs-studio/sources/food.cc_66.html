
<html>
<head>

  <meta http-equiv="Content-Type" content="text/html; charset=US-ASCII" />
  <title>food.cc</title>

  <link rel="stylesheet" href="../style.css"/>
  <script src="../jquery-3.2.1.min.js"></script>
</head>
<body>

<pre><code class = "cpp">
<a name="ln1">/**</a>
<a name="ln2"> * @file</a>
<a name="ln3"> * @brief Functions for eating.</a>
<a name="ln4">**/</a>
<a name="ln5"> </a>
<a name="ln6">#include &quot;AppHdr.h&quot;</a>
<a name="ln7"> </a>
<a name="ln8">#include &quot;food.h&quot;</a>
<a name="ln9"> </a>
<a name="ln10">#include &lt;cctype&gt;</a>
<a name="ln11">#include &lt;cstdio&gt;</a>
<a name="ln12">#include &lt;cstdlib&gt;</a>
<a name="ln13">#include &lt;cstring&gt;</a>
<a name="ln14">#include &lt;sstream&gt;</a>
<a name="ln15"> </a>
<a name="ln16">#include &quot;chardump.h&quot;</a>
<a name="ln17">#include &quot;database.h&quot;</a>
<a name="ln18">#include &quot;delay.h&quot;</a>
<a name="ln19">#include &quot;env.h&quot;</a>
<a name="ln20">#include &quot;god-abil.h&quot;</a>
<a name="ln21">#include &quot;hints.h&quot;</a>
<a name="ln22">#include &quot;invent.h&quot;</a>
<a name="ln23">#include &quot;item-prop.h&quot;</a>
<a name="ln24">#include &quot;items.h&quot;</a>
<a name="ln25">#include &quot;item-use.h&quot;</a>
<a name="ln26">#include &quot;libutil.h&quot;</a>
<a name="ln27">#include &quot;macro.h&quot;</a>
<a name="ln28">#include &quot;message.h&quot;</a>
<a name="ln29">#include &quot;misc.h&quot;</a>
<a name="ln30">#include &quot;mutation.h&quot;</a>
<a name="ln31">#include &quot;nearby-danger.h&quot;</a>
<a name="ln32">#include &quot;notes.h&quot;</a>
<a name="ln33">#include &quot;options.h&quot;</a>
<a name="ln34">#include &quot;religion.h&quot;</a>
<a name="ln35">#include &quot;rot.h&quot;</a>
<a name="ln36">#include &quot;state.h&quot;</a>
<a name="ln37">#include &quot;stepdown.h&quot;</a>
<a name="ln38">#include &quot;stringutil.h&quot;</a>
<a name="ln39">#include &quot;travel.h&quot;</a>
<a name="ln40">#include &quot;transform.h&quot;</a>
<a name="ln41">#include &quot;xom.h&quot;</a>
<a name="ln42"> </a>
<a name="ln43">static void _describe_food_change(int hunger_increment);</a>
<a name="ln44">static void _heal_from_food(int hp_amt);</a>
<a name="ln45"> </a>
<a name="ln46">void make_hungry(int hunger_amount, bool suppress_msg,</a>
<a name="ln47">                 bool magic)</a>
<a name="ln48">{</a>
<a name="ln49">    if (crawl_state.disables[DIS_HUNGER])</a>
<a name="ln50">        return;</a>
<a name="ln51"> </a>
<a name="ln52">    if (you_foodless())</a>
<a name="ln53">        return;</a>
<a name="ln54"> </a>
<a name="ln55">    if (magic)</a>
<a name="ln56">        hunger_amount = calc_hunger(hunger_amount);</a>
<a name="ln57"> </a>
<a name="ln58">    if (hunger_amount == 0 &amp;&amp; !suppress_msg)</a>
<a name="ln59">        return;</a>
<a name="ln60"> </a>
<a name="ln61">    you.hunger -= hunger_amount;</a>
<a name="ln62"> </a>
<a name="ln63">    if (you.hunger &lt; 0)</a>
<a name="ln64">        you.hunger = 0;</a>
<a name="ln65"> </a>
<a name="ln66">    // So we don't get two messages, ever.</a>
<a name="ln67">    bool state_message = food_change();</a>
<a name="ln68"> </a>
<a name="ln69">    if (!suppress_msg &amp;&amp; !state_message)</a>
<a name="ln70">        _describe_food_change(-hunger_amount);</a>
<a name="ln71">}</a>
<a name="ln72"> </a>
<a name="ln73">/**</a>
<a name="ln74"> * Attempt to reduce the player's hunger.</a>
<a name="ln75"> *</a>
<a name="ln76"> * @param satiated_amount       The amount by which to reduce hunger by.</a>
<a name="ln77"> * @param suppress_msg          Whether to squelch messages about hunger</a>
<a name="ln78"> *                              decreasing.</a>
<a name="ln79"> * @param max                   The maximum hunger state which the player may</a>
<a name="ln80"> *                              reach. If -1, defaults to HUNGER_MAXIMUM.</a>
<a name="ln81"> */</a>
<a name="ln82">void lessen_hunger(int satiated_amount, bool suppress_msg, int max)</a>
<a name="ln83">{</a>
<a name="ln84">    if (you_foodless())</a>
<a name="ln85">        return;</a>
<a name="ln86"> </a>
<a name="ln87">    you.hunger += satiated_amount;</a>
<a name="ln88"> </a>
<a name="ln89">    const hunger_state_t max_hunger_state = max == -1 ? HS_ENGORGED</a>
<a name="ln90">                                                      : (hunger_state_t) max;</a>
<a name="ln91">    ASSERT_RANGE(max_hunger_state, 0, HS_ENGORGED + 1);</a>
<a name="ln92">    const int max_hunger = min(HUNGER_MAXIMUM,</a>
<a name="ln93">                               hunger_threshold[max_hunger_state]);</a>
<a name="ln94">    if (you.hunger &gt; max_hunger)</a>
<a name="ln95">        you.hunger = max_hunger;</a>
<a name="ln96"> </a>
<a name="ln97">    // So we don't get two messages, ever.</a>
<a name="ln98">    const bool state_message = food_change();</a>
<a name="ln99"> </a>
<a name="ln100">    if (!suppress_msg &amp;&amp; !state_message)</a>
<a name="ln101">        _describe_food_change(satiated_amount);</a>
<a name="ln102">}</a>
<a name="ln103"> </a>
<a name="ln104">void set_hunger(int new_hunger_level, bool suppress_msg)</a>
<a name="ln105">{</a>
<a name="ln106">    if (you_foodless())</a>
<a name="ln107">        return;</a>
<a name="ln108"> </a>
<a name="ln109">    int hunger_difference = (new_hunger_level - you.hunger);</a>
<a name="ln110"> </a>
<a name="ln111">    if (hunger_difference &lt; 0)</a>
<a name="ln112">        make_hungry(-hunger_difference, suppress_msg);</a>
<a name="ln113">    else if (hunger_difference &gt; 0)</a>
<a name="ln114">        lessen_hunger(hunger_difference, suppress_msg);</a>
<a name="ln115">}</a>
<a name="ln116"> </a>
<a name="ln117">bool you_foodless(bool temp)</a>
<a name="ln118">{</a>
<a name="ln119">    return you.undead_state(temp) == US_UNDEAD</a>
<a name="ln120">        || you.undead_state(temp) == US_SEMI_UNDEAD;</a>
<a name="ln121">}</a>
<a name="ln122"> </a>
<a name="ln123">bool prompt_eat_item(int slot)</a>
<a name="ln124">{</a>
<a name="ln125">    item_def* item = nullptr;</a>
<a name="ln126">    if (slot == -1)</a>
<a name="ln127">    {</a>
<a name="ln128">        if (!use_an_item(item, OBJ_FOOD, OPER_EAT, &quot;Eat which item (* to show all)?&quot;))</a>
<a name="ln129">            return false;</a>
<a name="ln130">    }</a>
<a name="ln131">    else</a>
<a name="ln132">        item = &amp;you.inv[slot];</a>
<a name="ln133"> </a>
<a name="ln134">    ASSERT(item);</a>
<a name="ln135">    if (!can_eat(*item, false))</a>
<a name="ln136">        return false;</a>
<a name="ln137"> </a>
<a name="ln138">    eat_item(*item);</a>
<a name="ln139"> </a>
<a name="ln140">    return true;</a>
<a name="ln141">}</a>
<a name="ln142"> </a>
<a name="ln143">static bool _eat_check(bool check_hunger = true, bool silent = false,</a>
<a name="ln144">                                                            bool temp = true)</a>
<a name="ln145">{</a>
<a name="ln146">    if (you_foodless(temp))</a>
<a name="ln147">    {</a>
<a name="ln148">        if (!silent)</a>
<a name="ln149">        {</a>
<a name="ln150">            mpr(&quot;You can't eat.&quot;);</a>
<a name="ln151">            crawl_state.zero_turns_taken();</a>
<a name="ln152">        }</a>
<a name="ln153">        return false;</a>
<a name="ln154">    }</a>
<a name="ln155"> </a>
<a name="ln156">    if (!check_hunger)</a>
<a name="ln157">        return true;</a>
<a name="ln158"> </a>
<a name="ln159">    if (you.hunger_state &gt;= HS_ENGORGED)</a>
<a name="ln160">    {</a>
<a name="ln161">        if (!silent)</a>
<a name="ln162">        {</a>
<a name="ln163">            mprf(&quot;You're too full to eat anything.&quot;);</a>
<a name="ln164">            crawl_state.zero_turns_taken();</a>
<a name="ln165">        }</a>
<a name="ln166">        return false;</a>
<a name="ln167">    }</a>
<a name="ln168">    return true;</a>
<a name="ln169">}</a>
<a name="ln170"> </a>
<a name="ln171">// [ds] Returns true if something was eaten.</a>
<a name="ln172">bool eat_food(int slot)</a>
<a name="ln173">{</a>
<a name="ln174">    if (!_eat_check())</a>
<a name="ln175">        return false;</a>
<a name="ln176"> </a>
<a name="ln177">    // Skip the prompts if we already know what we're eating.</a>
<a name="ln178">    if (slot == -1)</a>
<a name="ln179">    {</a>
<a name="ln180">        int result = prompt_eat_chunks();</a>
<a name="ln181">        if (result == 1)</a>
<a name="ln182">            return true;</a>
<a name="ln183">        else if (result == -1)</a>
<a name="ln184">            return false;</a>
<a name="ln185">    }</a>
<a name="ln186"> </a>
<a name="ln187">    return prompt_eat_item(slot);</a>
<a name="ln188">}</a>
<a name="ln189"> </a>
<a name="ln190">static string _how_hungry()</a>
<a name="ln191">{</a>
<a name="ln192">    if (you.hunger_state &gt; HS_SATIATED)</a>
<a name="ln193">        return &quot;full&quot;;</a>
<a name="ln194">    return &quot;hungry&quot;;</a>
<a name="ln195">}</a>
<a name="ln196"> </a>
<a name="ln197">hunger_state_t calc_hunger_state()</a>
<a name="ln198">{</a>
<a name="ln199">    // Get new hunger state.</a>
<a name="ln200">    hunger_state_t newstate = HS_FAINTING;</a>
<a name="ln201">    while (newstate &lt; HS_ENGORGED &amp;&amp; you.hunger &gt; hunger_threshold[newstate])</a>
<a name="ln202">        newstate = (hunger_state_t)(newstate + 1);</a>
<a name="ln203">    return newstate;</a>
<a name="ln204">}</a>
<a name="ln205"> </a>
<a name="ln206">// &quot;initial&quot; is true when setting the player's initial hunger state on game</a>
<a name="ln207">// start or load: in that case it's not really a change, so we suppress the</a>
<a name="ln208">// state change message and don't identify rings or stimulate Xom.</a>
<a name="ln209">bool food_change(bool initial)</a>
<a name="ln210">{</a>
<a name="ln211">    bool state_changed = false;</a>
<a name="ln212">    bool less_hungry   = false;</a>
<a name="ln213"> </a>
<a name="ln214">    you.hunger = max(you_min_hunger(), you.hunger);</a>
<a name="ln215">    you.hunger = min(you_max_hunger(), you.hunger);</a>
<a name="ln216"> </a>
<a name="ln217">    hunger_state_t newstate = calc_hunger_state();</a>
<a name="ln218"> </a>
<a name="ln219">    if (newstate != you.hunger_state)</a>
<a name="ln220">    {</a>
<a name="ln221">        state_changed = true;</a>
<a name="ln222">        if (newstate &gt; you.hunger_state)</a>
<a name="ln223">            less_hungry = true;</a>
<a name="ln224"> </a>
<a name="ln225">        you.hunger_state = newstate;</a>
<a name="ln226">        you.redraw_status_lights = true;</a>
<a name="ln227"> </a>
<a name="ln228">        if (newstate &lt; HS_SATIATED)</a>
<a name="ln229">            interrupt_activity(activity_interrupt::hungry);</a>
<a name="ln230"> </a>
<a name="ln231">        if (!initial)</a>
<a name="ln232">        {</a>
<a name="ln233">            string msg = &quot;You &quot;;</a>
<a name="ln234">            switch (you.hunger_state)</a>
<a name="ln235">            {</a>
<a name="ln236">            case HS_FAINTING:</a>
<a name="ln237">                msg += &quot;are fainting from starvation!&quot;;</a>
<a name="ln238">                mprf(MSGCH_FOOD, less_hungry, &quot;%s&quot;, msg.c_str());</a>
<a name="ln239">                break;</a>
<a name="ln240"> </a>
<a name="ln241">            case HS_STARVING:</a>
<a name="ln242">                msg += &quot;are starving!&quot;;</a>
<a name="ln243"> </a>
<a name="ln244">                mprf(MSGCH_FOOD, less_hungry, &quot;%s&quot;, msg.c_str());</a>
<a name="ln245"> </a>
<a name="ln246">                learned_something_new(HINT_YOU_STARVING);</a>
<a name="ln247">                you.check_awaken(500);</a>
<a name="ln248">                break;</a>
<a name="ln249"> </a>
<a name="ln250">            case HS_NEAR_STARVING:</a>
<a name="ln251">                msg += &quot;are near starving!&quot;;</a>
<a name="ln252"> </a>
<a name="ln253">                mprf(MSGCH_FOOD, less_hungry, &quot;%s&quot;, msg.c_str());</a>
<a name="ln254"> </a>
<a name="ln255">                learned_something_new(HINT_YOU_HUNGRY);</a>
<a name="ln256">                break;</a>
<a name="ln257"> </a>
<a name="ln258">            case HS_VERY_HUNGRY:</a>
<a name="ln259">            case HS_HUNGRY:</a>
<a name="ln260">                msg += &quot;are feeling &quot;;</a>
<a name="ln261">                if (you.hunger_state == HS_VERY_HUNGRY)</a>
<a name="ln262">                    msg += &quot;very &quot;;</a>
<a name="ln263">                msg += _how_hungry();</a>
<a name="ln264">                msg += &quot;.&quot;;</a>
<a name="ln265"> </a>
<a name="ln266">                mprf(MSGCH_FOOD, less_hungry, &quot;%s&quot;, msg.c_str());</a>
<a name="ln267"> </a>
<a name="ln268">                learned_something_new(HINT_YOU_HUNGRY);</a>
<a name="ln269">                break;</a>
<a name="ln270"> </a>
<a name="ln271">            default:</a>
<a name="ln272">                return state_changed;</a>
<a name="ln273">            }</a>
<a name="ln274">        }</a>
<a name="ln275">    }</a>
<a name="ln276"> </a>
<a name="ln277">    return state_changed;</a>
<a name="ln278">}</a>
<a name="ln279"> </a>
<a name="ln280">// food_increment is positive for eating, negative for hungering</a>
<a name="ln281">static void _describe_food_change(int food_increment)</a>
<a name="ln282">{</a>
<a name="ln283">    const int magnitude = abs(food_increment);</a>
<a name="ln284">    string msg;</a>
<a name="ln285"> </a>
<a name="ln286">    if (magnitude == 0)</a>
<a name="ln287">        return;</a>
<a name="ln288"> </a>
<a name="ln289">    msg = &quot;You feel &quot;;</a>
<a name="ln290"> </a>
<a name="ln291">    if (magnitude &lt;= 100)</a>
<a name="ln292">        msg += &quot;slightly &quot;;</a>
<a name="ln293">    else if (magnitude &lt;= 350)</a>
<a name="ln294">        msg += &quot;somewhat &quot;;</a>
<a name="ln295">    else if (magnitude &lt;= 800)</a>
<a name="ln296">        msg += &quot;quite a bit &quot;;</a>
<a name="ln297">    else</a>
<a name="ln298">        msg += &quot;a lot &quot;;</a>
<a name="ln299"> </a>
<a name="ln300">    if ((you.hunger_state &gt; HS_SATIATED) ^ (food_increment &lt; 0))</a>
<a name="ln301">        msg += &quot;more &quot;;</a>
<a name="ln302">    else</a>
<a name="ln303">        msg += &quot;less &quot;;</a>
<a name="ln304"> </a>
<a name="ln305">    msg += _how_hungry().c_str();</a>
<a name="ln306">    msg += &quot;.&quot;;</a>
<a name="ln307">    mpr(msg);</a>
<a name="ln308">}</a>
<a name="ln309"> </a>
<a name="ln310">// Handle messaging at the end of eating.</a>
<a name="ln311">// Some food types may not get a message.</a>
<a name="ln312">static void _finished_eating_message(food_type type)</a>
<a name="ln313">{</a>
<a name="ln314">    const bool herbivorous = you.get_mutation_level(MUT_HERBIVOROUS) &gt; 0;</a>
<a name="ln315"> </a>
<a name="ln316">    if (type == FOOD_RATION)</a>
<a name="ln317">    {</a>
<a name="ln318">        mpr(&quot;That ration really hit the spot!&quot;);</a>
<a name="ln319">        return;</a>
<a name="ln320">    }</a>
<a name="ln321">    else if (herbivorous &amp;&amp; food_is_meaty(type))</a>
<a name="ln322">    {</a>
<a name="ln323">        mpr(&quot;Blech - you need greens!&quot;);</a>
<a name="ln324">        return;</a>
<a name="ln325">    }</a>
<a name="ln326">}</a>
<a name="ln327"> </a>
<a name="ln328">// Returns which of two food items is older (true for first, else false).</a>
<a name="ln329">static bool _compare_by_freshness(const item_def *food1, const item_def *food2)</a>
<a name="ln330">{</a>
<a name="ln331">    ASSERT(food1-&gt;base_type == OBJ_CORPSES || food1-&gt;base_type == OBJ_FOOD);</a>
<a name="ln332">    ASSERT(food2-&gt;base_type == OBJ_CORPSES || food2-&gt;base_type == OBJ_FOOD);</a>
<a name="ln333">    ASSERT(food1-&gt;base_type == food2-&gt;base_type);</a>
<a name="ln334"> </a>
<a name="ln335">    if (is_inedible(*food1))</a>
<a name="ln336">        return false;</a>
<a name="ln337"> </a>
<a name="ln338">    if (is_inedible(*food2))</a>
<a name="ln339">        return true;</a>
<a name="ln340"> </a>
<a name="ln341">    // Permafood can last longest, skip it if possible.</a>
<a name="ln342">    if (food1-&gt;base_type == OBJ_FOOD &amp;&amp; food1-&gt;sub_type != FOOD_CHUNK)</a>
<a name="ln343">        return false;</a>
<a name="ln344">    if (food2-&gt;base_type == OBJ_FOOD &amp;&amp; food2-&gt;sub_type != FOOD_CHUNK)</a>
<a name="ln345">        return true;</a>
<a name="ln346"> </a>
<a name="ln347">    // At this point, we know both are corpses or chunks, edible</a>
<a name="ln348"> </a>
<a name="ln349">    // Always offer inedible chunks last.</a>
<a name="ln350">    if (is_bad_food(*food1) &amp;&amp; !is_bad_food(*food2))</a>
<a name="ln351">        return false;</a>
<a name="ln352">    if (is_bad_food(*food2) &amp;&amp; !is_bad_food(*food1))</a>
<a name="ln353">        return true;</a>
<a name="ln354"> </a>
<a name="ln355">    return food1-&gt;freshness &lt; food2-&gt;freshness;</a>
<a name="ln356">}</a>
<a name="ln357"> </a>
<a name="ln358">static hunger_state_t _max_chunk_state(bool like_chunks = player_likes_chunks())</a>
<a name="ln359">{</a>
<a name="ln360">    return like_chunks ? HS_VERY_FULL : HS_HUNGRY;</a>
<a name="ln361">}</a>
<a name="ln362"> </a>
<a name="ln363">/** Make the prompt for chunk eating/corpse draining.</a>
<a name="ln364"> *</a>
<a name="ln365"> *  @param only_auto Don't actually make a prompt: if there are</a>
<a name="ln366"> *                   things to auto_eat, eat them, and exit otherwise.</a>
<a name="ln367"> *  @returns -1 for cancel, 1 for eaten, 0 for not eaten,</a>
<a name="ln368"> */</a>
<a name="ln369">int prompt_eat_chunks(bool only_auto)</a>
<a name="ln370">{</a>
<a name="ln371">    // Full herbivores cannot eat chunks.</a>
<a name="ln372">    if (you.get_mutation_level(MUT_HERBIVOROUS) &gt; 0)</a>
<a name="ln373">        return 0;</a>
<a name="ln374"> </a>
<a name="ln375">    // If we *know* the player can eat chunks, doesn't have the gourmand</a>
<a name="ln376">    // effect and isn't hungry, don't prompt for chunks.</a>
<a name="ln377">    if (you.hunger_state &gt; _max_chunk_state())</a>
<a name="ln378">        return 0;</a>
<a name="ln379"> </a>
<a name="ln380">    bool found_valid = false;</a>
<a name="ln381">    vector&lt;item_def *&gt; chunks;</a>
<a name="ln382"> </a>
<a name="ln383">    for (stack_iterator si(you.pos(), true); si; ++si)</a>
<a name="ln384">    {</a>
<a name="ln385">        if (si-&gt;base_type != OBJ_FOOD</a>
<a name="ln386">                 || si-&gt;sub_type != FOOD_CHUNK</a>
<a name="ln387">                 || is_bad_food(*si))</a>
<a name="ln388">        {</a>
<a name="ln389">            continue;</a>
<a name="ln390">        }</a>
<a name="ln391"> </a>
<a name="ln392">        found_valid = true;</a>
<a name="ln393">        chunks.push_back(&amp;(*si));</a>
<a name="ln394">    }</a>
<a name="ln395"> </a>
<a name="ln396">    // Then search through the inventory.</a>
<a name="ln397">    for (auto &amp;item : you.inv)</a>
<a name="ln398">    {</a>
<a name="ln399">        if (!item.defined())</a>
<a name="ln400">            continue;</a>
<a name="ln401"> </a>
<a name="ln402">        if (item.base_type != OBJ_FOOD || item.sub_type != FOOD_CHUNK)</a>
<a name="ln403">            continue;</a>
<a name="ln404"> </a>
<a name="ln405">        // Don't prompt for bad food types.</a>
<a name="ln406">        if (is_bad_food(item))</a>
<a name="ln407">            continue;</a>
<a name="ln408"> </a>
<a name="ln409">        found_valid = true;</a>
<a name="ln410">        chunks.push_back(&amp;item);</a>
<a name="ln411">    }</a>
<a name="ln412"> </a>
<a name="ln413">    const bool easy_eat = Options.easy_eat_chunks || only_auto;</a>
<a name="ln414"> </a>
<a name="ln415">    if (found_valid)</a>
<a name="ln416">    {</a>
<a name="ln417">        sort(chunks.begin(), chunks.end(), _compare_by_freshness);</a>
<a name="ln418">        for (item_def *item : chunks)</a>
<a name="ln419">        {</a>
<a name="ln420">            bool autoeat = false;</a>
<a name="ln421">            string item_name = menu_colour_item_name(*item, DESC_A);</a>
<a name="ln422"> </a>
<a name="ln423">            const bool bad = is_bad_food(*item);</a>
<a name="ln424"> </a>
<a name="ln425">            // Allow undead to use easy_eat, but not auto_eat, since the player</a>
<a name="ln426">            // might not want to drink blood as a vampire and might want to save</a>
<a name="ln427">            // chunks as a ghoul. Ghouls can auto_eat if they have rotted hp.</a>
<a name="ln428">            const bool no_auto = you.undead_state()</a>
<a name="ln429">                &amp;&amp; !(you.species == SP_GHOUL &amp;&amp; player_rotted());</a>
<a name="ln430"> </a>
<a name="ln431">            // If this chunk is safe to eat, just do so without prompting.</a>
<a name="ln432">            if (easy_eat &amp;&amp; !bad &amp;&amp; i_feel_safe() &amp;&amp; !(only_auto &amp;&amp; no_auto))</a>
<a name="ln433">                autoeat = true;</a>
<a name="ln434">            else if (only_auto)</a>
<a name="ln435">                return 0;</a>
<a name="ln436">            else</a>
<a name="ln437">            {</a>
<a name="ln438">                mprf(MSGCH_PROMPT, &quot;Eat %s%s? (ye/n/q)&quot;,</a>
<a name="ln439">                     ((item-&gt;quantity &gt; 1) ? &quot;one of &quot; : &quot;&quot;),</a>
<a name="ln440">                     item_name.c_str());</a>
<a name="ln441">            }</a>
<a name="ln442"> </a>
<a name="ln443">            int keyin = autoeat ? 'y' : toalower(getchm(KMC_CONFIRM));</a>
<a name="ln444">            switch (keyin)</a>
<a name="ln445">            {</a>
<a name="ln446">            case 'q':</a>
<a name="ln447">            CASE_ESCAPE</a>
<a name="ln448">                canned_msg(MSG_OK);</a>
<a name="ln449">                return -1;</a>
<a name="ln450">            case 'i':</a>
<a name="ln451">            case '?':</a>
<a name="ln452">                // Skip ahead to the inventory.</a>
<a name="ln453">                return 0;</a>
<a name="ln454">            case 'e':</a>
<a name="ln455">            case 'y':</a>
<a name="ln456">                if (can_eat(*item, false))</a>
<a name="ln457">                {</a>
<a name="ln458">                    if (autoeat)</a>
<a name="ln459">                    {</a>
<a name="ln460">                        mprf(&quot;Eating %s%s.&quot;,</a>
<a name="ln461">                             ((item-&gt;quantity &gt; 1) ? &quot;one of &quot; : &quot;&quot;),</a>
<a name="ln462">                             item_name.c_str());</a>
<a name="ln463">                    }</a>
<a name="ln464"> </a>
<a name="ln465">                    return eat_item(*item) ? 1 : 0;</a>
<a name="ln466">                }</a>
<a name="ln467">                break;</a>
<a name="ln468">            default:</a>
<a name="ln469">                // Else no: try next one.</a>
<a name="ln470">                break;</a>
<a name="ln471">            }</a>
<a name="ln472">        }</a>
<a name="ln473">    }</a>
<a name="ln474"> </a>
<a name="ln475">    return 0;</a>
<a name="ln476">}</a>
<a name="ln477"> </a>
<a name="ln478">static const char *_chunk_flavour_phrase(bool likes_chunks)</a>
<a name="ln479">{</a>
<a name="ln480">    const char *phrase = &quot;tastes terrible.&quot;;</a>
<a name="ln481"> </a>
<a name="ln482">    if (you.species == SP_GHOUL)</a>
<a name="ln483">        phrase = &quot;tastes great!&quot;;</a>
<a name="ln484">    else if (likes_chunks)</a>
<a name="ln485">        phrase = &quot;tastes great.&quot;;</a>
<a name="ln486">    else</a>
<a name="ln487">    {</a>
<a name="ln488">        const int gourmand = you.duration[DUR_GOURMAND];</a>
<a name="ln489">        if (gourmand &gt;= GOURMAND_MAX)</a>
<a name="ln490">        {</a>
<a name="ln491">            phrase = one_chance_in(1000) ? &quot;tastes like chicken!&quot;</a>
<a name="ln492">                                         : &quot;tastes great.&quot;;</a>
<a name="ln493">        }</a>
<a name="ln494">        else if (gourmand &gt; GOURMAND_MAX * 75 / 100)</a>
<a name="ln495">            phrase = &quot;tastes very good.&quot;;</a>
<a name="ln496">        else if (gourmand &gt; GOURMAND_MAX * 50 / 100)</a>
<a name="ln497">            phrase = &quot;tastes good.&quot;;</a>
<a name="ln498">        else if (gourmand &gt; GOURMAND_MAX * 25 / 100)</a>
<a name="ln499">            phrase = &quot;is not very appetising.&quot;;</a>
<a name="ln500">    }</a>
<a name="ln501"> </a>
<a name="ln502">    return phrase;</a>
<a name="ln503">}</a>
<a name="ln504"> </a>
<a name="ln505">static void _chunk_nutrition_message(int nutrition)</a>
<a name="ln506">{</a>
<a name="ln507">    int perc_nutrition = nutrition * 100 / CHUNK_BASE_NUTRITION;</a>
<a name="ln508">    if (perc_nutrition &lt; 15)</a>
<a name="ln509">        mpr(&quot;That was extremely unsatisfying.&quot;);</a>
<a name="ln510">    else if (perc_nutrition &lt; 35)</a>
<a name="ln511">        mpr(&quot;That was not very filling.&quot;);</a>
<a name="ln512">}</a>
<a name="ln513"> </a>
<a name="ln514">static int _apply_herbivore_nutrition_effects(int nutrition)</a>
<a name="ln515">{</a>
<a name="ln516">    if (you.get_mutation_level(MUT_HERBIVOROUS) &gt; 0)</a>
<a name="ln517">        return nutrition * 5 / 12; // Was 42.2% with Herb 3, now 41.7%</a>
<a name="ln518">    else</a>
<a name="ln519">        return nutrition;</a>
<a name="ln520">}</a>
<a name="ln521"> </a>
<a name="ln522">static int _apply_gourmand_nutrition_effects(int nutrition, int gourmand)</a>
<a name="ln523">{</a>
<a name="ln524">    return nutrition * (gourmand + GOURMAND_NUTRITION_BASE)</a>
<a name="ln525">                     / (GOURMAND_MAX + GOURMAND_NUTRITION_BASE);</a>
<a name="ln526">}</a>
<a name="ln527"> </a>
<a name="ln528">static int _chunk_nutrition(bool likes_chunks)</a>
<a name="ln529">{</a>
<a name="ln530">    int nutrition = CHUNK_BASE_NUTRITION;</a>
<a name="ln531"> </a>
<a name="ln532">    if (you.hunger_state &lt;= _max_chunk_state(likes_chunks))</a>
<a name="ln533">    {</a>
<a name="ln534">        return likes_chunks ? nutrition</a>
<a name="ln535">                            : _apply_herbivore_nutrition_effects(nutrition);</a>
<a name="ln536">    }</a>
<a name="ln537"> </a>
<a name="ln538">    const int gourmand = you.gourmand() ? you.duration[DUR_GOURMAND] : 0;</a>
<a name="ln539">    const int effective_nutrition =</a>
<a name="ln540">        _apply_gourmand_nutrition_effects(nutrition, gourmand);</a>
<a name="ln541"> </a>
<a name="ln542">#ifdef DEBUG_DIAGNOSTICS</a>
<a name="ln543">    const int epercent = effective_nutrition * 100 / nutrition;</a>
<a name="ln544">    mprf(MSGCH_DIAGNOSTICS,</a>
<a name="ln545">            &quot;Gourmand factor: %d, chunk base: %d, effective: %d, %%: %d&quot;,</a>
<a name="ln546">                gourmand, nutrition, effective_nutrition, epercent);</a>
<a name="ln547">#endif</a>
<a name="ln548"> </a>
<a name="ln549">    return _apply_herbivore_nutrition_effects(effective_nutrition);</a>
<a name="ln550">}</a>
<a name="ln551"> </a>
<a name="ln552">/**</a>
<a name="ln553"> * How intelligent was the monster that the given corpse came from?</a>
<a name="ln554"> *</a>
<a name="ln555"> * @param   The corpse being examined.</a>
<a name="ln556"> * @return  The mon_intel_type of the monster that the given corpse was</a>
<a name="ln557"> *          produced from.</a>
<a name="ln558"> */</a>
<a name="ln559">mon_intel_type corpse_intelligence(const item_def &amp;corpse)</a>
<a name="ln560">{</a>
<a name="ln561">    // An optimising compiler can assume an enum value is in range, so</a>
<a name="ln562">    // check the range on the uncast value.</a>
<a name="ln563">    const bool bad = corpse.orig_monnum &lt; 0</a>
<a name="ln564">                     || corpse.orig_monnum &gt;= NUM_MONSTERS;</a>
<a name="ln565">    const monster_type orig_mt = static_cast&lt;monster_type&gt;(corpse.orig_monnum);</a>
<a name="ln566">    const monster_type type = bad || invalid_monster_type(orig_mt)</a>
<a name="ln567">                                ? corpse.mon_type</a>
<a name="ln568">                                : orig_mt;</a>
<a name="ln569">    return mons_class_intel(type);</a>
<a name="ln570">}</a>
<a name="ln571"> </a>
<a name="ln572">// Never called directly - chunk_effect values must pass</a>
<a name="ln573">// through food:determine_chunk_effect() first. {dlb}:</a>
<a name="ln574">static void _eat_chunk(item_def&amp; food)</a>
<a name="ln575">{</a>
<a name="ln576">    const corpse_effect_type chunk_effect = determine_chunk_effect(food);</a>
<a name="ln577"> </a>
<a name="ln578">    bool likes_chunks = player_likes_chunks(true);</a>
<a name="ln579">    int nutrition     = _chunk_nutrition(likes_chunks);</a>
<a name="ln580">    bool suppress_msg = false; // do we display the chunk nutrition message?</a>
<a name="ln581">    bool do_eat       = false;</a>
<a name="ln582"> </a>
<a name="ln583">    switch (chunk_effect)</a>
<a name="ln584">    {</a>
<a name="ln585">    case CE_CLEAN:</a>
<a name="ln586">    {</a>
<a name="ln587">        if (you.species == SP_GHOUL)</a>
<a name="ln588">        {</a>
<a name="ln589">            suppress_msg = true;</a>
<a name="ln590">            const int hp_amt = 1 + random2avg(5 + you.experience_level, 3);</a>
<a name="ln591">            _heal_from_food(hp_amt);</a>
<a name="ln592">        }</a>
<a name="ln593"> </a>
<a name="ln594">        mprf(&quot;This raw flesh %s&quot;, _chunk_flavour_phrase(likes_chunks));</a>
<a name="ln595">        do_eat = true;</a>
<a name="ln596">        break;</a>
<a name="ln597">    }</a>
<a name="ln598"> </a>
<a name="ln599">    case CE_NOXIOUS:</a>
<a name="ln600">    case CE_NOCORPSE:</a>
<a name="ln601">        mprf(MSGCH_ERROR, &quot;This flesh (%d) tastes buggy!&quot;, chunk_effect);</a>
<a name="ln602">        break;</a>
<a name="ln603">    }</a>
<a name="ln604"> </a>
<a name="ln605">    if (do_eat)</a>
<a name="ln606">    {</a>
<a name="ln607">        dprf(&quot;nutrition: %d&quot;, nutrition);</a>
<a name="ln608">        lessen_hunger(nutrition, true);</a>
<a name="ln609">        if (!suppress_msg)</a>
<a name="ln610">            _chunk_nutrition_message(nutrition);</a>
<a name="ln611">    }</a>
<a name="ln612">}</a>
<a name="ln613"> </a>
<a name="ln614">bool eat_item(item_def &amp;food)</a>
<a name="ln615">{</a>
<a name="ln616">    if (food.is_type(OBJ_CORPSES, CORPSE_BODY))</a>
<a name="ln617">        return false;</a>
<a name="ln618"> </a>
<a name="ln619">    mprf(&quot;You eat %s%s.&quot;, food.quantity &gt; 1 ? &quot;one of &quot; : &quot;&quot;,</a>
<a name="ln620">                          food.name(DESC_THE).c_str());</a>
<a name="ln621"> </a>
<a name="ln622">    if (food.sub_type == FOOD_CHUNK)</a>
<a name="ln623">        _eat_chunk(food);</a>
<a name="ln624">    else</a>
<a name="ln625">    {</a>
<a name="ln626">        int value = food_value(food);</a>
<a name="ln627">        ASSERT(value &gt; 0);</a>
<a name="ln628">        lessen_hunger(value, true);</a>
<a name="ln629">        _finished_eating_message(static_cast&lt;food_type&gt;(food.sub_type));</a>
<a name="ln630">    }</a>
<a name="ln631"> </a>
<a name="ln632">    count_action(CACT_EAT, food.sub_type);</a>
<a name="ln633"> </a>
<a name="ln634">    if (is_perishable_stack(food)) // chunks</a>
<a name="ln635">        remove_oldest_perishable_item(food);</a>
<a name="ln636">    if (in_inventory(food))</a>
<a name="ln637">        dec_inv_item_quantity(food.link, 1);</a>
<a name="ln638">    else</a>
<a name="ln639">        dec_mitm_item_quantity(food.index(), 1);</a>
<a name="ln640"> </a>
<a name="ln641">    you.turn_is_over = true;</a>
<a name="ln642">    return true;</a>
<a name="ln643">}</a>
<a name="ln644"> </a>
<a name="ln645">bool is_bad_food(const item_def &amp;food)</a>
<a name="ln646">{</a>
<a name="ln647">    return is_forbidden_food(food) || is_noxious(food);</a>
<a name="ln648">}</a>
<a name="ln649"> </a>
<a name="ln650">// Returns true if a food item (or corpse) is totally inedible.</a>
<a name="ln651">bool is_noxious(const item_def &amp;food)</a>
<a name="ln652">{</a>
<a name="ln653">    if (food.base_type != OBJ_FOOD &amp;&amp; food.base_type != OBJ_CORPSES)</a>
<a name="ln654">        return false;</a>
<a name="ln655"> </a>
<a name="ln656">    return determine_chunk_effect(food) == CE_NOXIOUS;</a>
<a name="ln657">}</a>
<a name="ln658"> </a>
<a name="ln659">// Returns true if an item of basetype FOOD or CORPSES cannot currently</a>
<a name="ln660">// be eaten (respecting species and mutations set).</a>
<a name="ln661">bool is_inedible(const item_def &amp;item, bool temp)</a>
<a name="ln662">{</a>
<a name="ln663">    // Mummies and liches don't eat.</a>
<a name="ln664">    if (you_foodless(temp))</a>
<a name="ln665">        return true;</a>
<a name="ln666"> </a>
<a name="ln667">    if (item.base_type == OBJ_FOOD // XXX: removeme?</a>
<a name="ln668">        &amp;&amp; !can_eat(item, true, false, temp))</a>
<a name="ln669">    {</a>
<a name="ln670">        return true;</a>
<a name="ln671">    }</a>
<a name="ln672"> </a>
<a name="ln673">    if (item.base_type == OBJ_CORPSES)</a>
<a name="ln674">    {</a>
<a name="ln675">        if (item.sub_type == CORPSE_SKELETON)</a>
<a name="ln676">            return true;</a>
<a name="ln677"> </a>
<a name="ln678">        item_def chunk = item;</a>
<a name="ln679">        chunk.base_type = OBJ_FOOD;</a>
<a name="ln680">        chunk.sub_type  = FOOD_CHUNK;</a>
<a name="ln681">        if (is_inedible(chunk, temp))</a>
<a name="ln682">            return true;</a>
<a name="ln683">    }</a>
<a name="ln684"> </a>
<a name="ln685">    return false;</a>
<a name="ln686">}</a>
<a name="ln687"> </a>
<a name="ln688">// As we want to avoid autocolouring the entire food selection, this should</a>
<a name="ln689">// be restricted to the absolute highlights, even though other stuff may</a>
<a name="ln690">// still be edible or even delicious.</a>
<a name="ln691">bool is_preferred_food(const item_def &amp;food)</a>
<a name="ln692">{</a>
<a name="ln693">    if (you.species == SP_GHOUL)</a>
<a name="ln694">        return food.is_type(OBJ_FOOD, FOOD_CHUNK);</a>
<a name="ln695"> </a>
<a name="ln696">    return false;</a>
<a name="ln697">}</a>
<a name="ln698"> </a>
<a name="ln699">/**</a>
<a name="ln700"> * Is the given food item forbidden to the player by their god?</a>
<a name="ln701"> *</a>
<a name="ln702"> * @param food  The food item in question.</a>
<a name="ln703"> * @return      Whether your god hates you eating it.</a>
<a name="ln704"> */</a>
<a name="ln705">bool is_forbidden_food(const item_def &amp;food)</a>
<a name="ln706">{</a>
<a name="ln707">    // no food is forbidden to the player who does not yet exist</a>
<a name="ln708">    if (!crawl_state.need_save)</a>
<a name="ln709">        return false;</a>
<a name="ln710"> </a>
<a name="ln711">    // Only corpses are only forbidden, now.</a>
<a name="ln712">    if (food.base_type != OBJ_CORPSES)</a>
<a name="ln713">        return false;</a>
<a name="ln714"> </a>
<a name="ln715">    // Specific handling for intelligent monsters like Gastronok and Xtahua</a>
<a name="ln716">    // of a normally unintelligent class.</a>
<a name="ln717">    if (you_worship(GOD_ZIN) &amp;&amp; corpse_intelligence(food) &gt;= I_HUMAN)</a>
<a name="ln718">        return true;</a>
<a name="ln719"> </a>
<a name="ln720">    return god_hates_eating(you.religion, food.mon_type);</a>
<a name="ln721">}</a>
<a name="ln722"> </a>
<a name="ln723">/** Can the player eat this item?</a>
<a name="ln724"> *</a>
<a name="ln725"> *  @param food the item (must be a corpse or food item)</a>
<a name="ln726"> *  @param suppress_msg whether to print why you can't eat it</a>
<a name="ln727"> *  @param check_hunger whether to check how hungry you are currently</a>
<a name="ln728"> *  @param temp whether to factor in temporary forms</a>
<a name="ln729"> */</a>
<a name="ln730">bool can_eat(const item_def &amp;food, bool suppress_msg, bool check_hunger,</a>
<a name="ln731">                                                                bool temp)</a>
<a name="ln732">{</a>
<a name="ln733">#define FAIL(msg) { if (!suppress_msg) mpr(msg); return false; }</a>
<a name="ln734">    if (food.base_type != OBJ_FOOD &amp;&amp; food.base_type != OBJ_CORPSES)</a>
<a name="ln735">        FAIL(&quot;That's not food!&quot;);</a>
<a name="ln736"> </a>
<a name="ln737">    // [ds] These redundant checks are now necessary - Lua might be calling us.</a>
<a name="ln738">    if (!_eat_check(check_hunger, suppress_msg, temp))</a>
<a name="ln739">        return false;</a>
<a name="ln740"> </a>
<a name="ln741">    if (is_noxious(food))</a>
<a name="ln742">        FAIL(&quot;It is completely inedible.&quot;);</a>
<a name="ln743"> </a>
<a name="ln744">    if (food.base_type == OBJ_CORPSES)</a>
<a name="ln745">        return false;</a>
<a name="ln746"> </a>
<a name="ln747">    if (food_is_meaty(food))</a>
<a name="ln748">    {</a>
<a name="ln749">        if (you.get_mutation_level(MUT_HERBIVOROUS) &gt; 0)</a>
<a name="ln750">            FAIL(&quot;Sorry, you're a herbivore.&quot;)</a>
<a name="ln751">        else if (food.sub_type == FOOD_CHUNK)</a>
<a name="ln752">        {</a>
<a name="ln753">            if (!check_hunger</a>
<a name="ln754">                || you.hunger_state &lt; HS_SATIATED</a>
<a name="ln755">                || player_likes_chunks())</a>
<a name="ln756">            {</a>
<a name="ln757">                return true;</a>
<a name="ln758">            }</a>
<a name="ln759"> </a>
<a name="ln760">            FAIL(&quot;You aren't quite hungry enough to eat that!&quot;)</a>
<a name="ln761">        }</a>
<a name="ln762">    }</a>
<a name="ln763"> </a>
<a name="ln764">    // Any food types not specifically handled until here (e.g. meat</a>
<a name="ln765">    // rations for non-herbivores) are okay.</a>
<a name="ln766">    return true;</a>
<a name="ln767">}</a>
<a name="ln768"> </a>
<a name="ln769">/**</a>
<a name="ln770"> * Determine the 'effective' chunk type for a given piece of carrion (chunk or</a>
<a name="ln771"> * corpse), for the player.</a>
<a name="ln772"> * E.g., ghouls treat rotting and poisonous chunks as normal chunks.</a>
<a name="ln773"> *</a>
<a name="ln774"> * @param carrion       The actual chunk or corpse.</a>
<a name="ln775"> * @return              A chunk type corresponding to the effect eating the</a>
<a name="ln776"> *                      given item will have on the player.</a>
<a name="ln777"> */</a>
<a name="ln778">corpse_effect_type determine_chunk_effect(const item_def &amp;carrion)</a>
<a name="ln779">{</a>
<a name="ln780">    return determine_chunk_effect(mons_corpse_effect(carrion.mon_type));</a>
<a name="ln781">}</a>
<a name="ln782"> </a>
<a name="ln783">/**</a>
<a name="ln784"> * Determine the 'effective' chunk type for a given input for the player.</a>
<a name="ln785"> * E.g., ghouls/vampires treat rotting and poisonous chunks as normal chunks.</a>
<a name="ln786"> *</a>
<a name="ln787"> * @param chunktype     The actual chunk type.</a>
<a name="ln788"> * @return              A chunk type corresponding to the effect eating a chunk</a>
<a name="ln789"> *                      of the given type will have on the player.</a>
<a name="ln790"> */</a>
<a name="ln791">corpse_effect_type determine_chunk_effect(corpse_effect_type chunktype)</a>
<a name="ln792">{</a>
<a name="ln793">    switch (chunktype)</a>
<a name="ln794">    {</a>
<a name="ln795">    case CE_NOXIOUS:</a>
<a name="ln796">        if (you.species == SP_GHOUL)</a>
<a name="ln797">            chunktype = CE_CLEAN;</a>
<a name="ln798">        break;</a>
<a name="ln799"> </a>
<a name="ln800">    default:</a>
<a name="ln801">        break;</a>
<a name="ln802">    }</a>
<a name="ln803"> </a>
<a name="ln804">    return chunktype;</a>
<a name="ln805">}</a>
<a name="ln806"> </a>
<a name="ln807">static void _heal_from_food(int hp_amt)</a>
<a name="ln808">{</a>
<a name="ln809">    if (hp_amt &gt; 0)</a>
<a name="ln810">        inc_hp(hp_amt);</a>
<a name="ln811"> </a>
<a name="ln812">    if (player_rotted())</a>
<a name="ln813">    {</a>
<a name="ln814">        mpr(&quot;You feel more resilient.&quot;);</a>
<a name="ln815">        unrot_hp(1);</a>
<a name="ln816">    }</a>
<a name="ln817"> </a>
<a name="ln818">    calc_hp();</a>
<a name="ln819">    calc_mp();</a>
<a name="ln820">}</a>
<a name="ln821"> </a>
<a name="ln822">int you_max_hunger()</a>
<a name="ln823">{</a>
<a name="ln824">    if (you_foodless())</a>
<a name="ln825">        return HUNGER_DEFAULT;</a>
<a name="ln826"> </a>
<a name="ln827">    // Ghouls can never be full or above.</a>
<a name="ln828">    if (you.species == SP_GHOUL)</a>
<a name="ln829">        return hunger_threshold[HS_SATIATED];</a>
<a name="ln830"> </a>
<a name="ln831">    return hunger_threshold[HS_ENGORGED];</a>
<a name="ln832">}</a>
<a name="ln833"> </a>
<a name="ln834">int you_min_hunger()</a>
<a name="ln835">{</a>
<a name="ln836">    // This case shouldn't actually happen.</a>
<a name="ln837">    if (you_foodless())</a>
<a name="ln838">        return HUNGER_DEFAULT;</a>
<a name="ln839"> </a>
<a name="ln840">    // Vampires can never starve to death. Ghouls will just rot much faster.</a>
<a name="ln841">    if (you.undead_state() != US_ALIVE)</a>
<a name="ln842">        return (HUNGER_FAINTING + HUNGER_STARVING) / 2; // midpoint</a>
<a name="ln843"> </a>
<a name="ln844">    return 0;</a>
<a name="ln845">}</a>
<a name="ln846"> </a>
<a name="ln847">// General starvation penalties (such as inability to use spells/abilities and</a>
<a name="ln848">// reduced accuracy) don't apply to bloodless vampires or starving ghouls.</a>
<a name="ln849">bool apply_starvation_penalties()</a>
<a name="ln850">{</a>
<a name="ln851">    return you.hunger_state &lt;= HS_STARVING &amp;&amp; !you_min_hunger();</a>
<a name="ln852">}</a>
<a name="ln853"> </a>
<a name="ln854">static item_def* _get_emergency_food()</a>
<a name="ln855">{</a>
<a name="ln856">    // Look for food on floor</a>
<a name="ln857">    for (stack_iterator si(you.pos(), true); si; ++si)</a>
<a name="ln858">    {</a>
<a name="ln859">        if (can_eat(*si, true))</a>
<a name="ln860">            return &amp;*si;</a>
<a name="ln861">    }</a>
<a name="ln862"> </a>
<a name="ln863">    // Look in inventory</a>
<a name="ln864">    auto it = find_if(begin(you.inv), end(you.inv),</a>
<a name="ln865">                      [](const item_def&amp; inv_item) -&gt; bool</a>
<a name="ln866">                          {</a>
<a name="ln867">                              return can_eat(inv_item, true);</a>
<a name="ln868">                          });</a>
<a name="ln869">    if (it != end(you.inv))</a>
<a name="ln870">        return &amp;*it;</a>
<a name="ln871"> </a>
<a name="ln872">    return nullptr;</a>
<a name="ln873">}</a>
<a name="ln874"> </a>
<a name="ln875">void handle_starvation()</a>
<a name="ln876">{</a>
<a name="ln877">    // Don't faint or die while eating.</a>
<a name="ln878">    if (current_delay() &amp;&amp; current_delay()-&gt;is_being_used(nullptr, OPER_EAT))</a>
<a name="ln879">        return;</a>
<a name="ln880"> </a>
<a name="ln881">    if (!you_foodless() &amp;&amp; you.hunger &lt;= HUNGER_FAINTING)</a>
<a name="ln882">    {</a>
<a name="ln883">        if (!you.cannot_act() &amp;&amp; one_chance_in(40))</a>
<a name="ln884">        {</a>
<a name="ln885">            mprf(MSGCH_FOOD, &quot;You lose consciousness!&quot;);</a>
<a name="ln886">            stop_running();</a>
<a name="ln887"> </a>
<a name="ln888">            int turns = 5 + random2(8);</a>
<a name="ln889">            if (!you.duration[DUR_PARALYSIS])</a>
<a name="ln890">                take_note(Note(NOTE_PARALYSIS, min(turns, 13), 0, &quot;fainting&quot;));</a>
<a name="ln891">            you.increase_duration(DUR_PARALYSIS, turns, 13);</a>
<a name="ln892">            xom_is_stimulated(get_tension() &gt; 0 ? 200 : 100);</a>
<a name="ln893">        }</a>
<a name="ln894"> </a>
<a name="ln895">        if (you.hunger &lt;= 0 &amp;&amp; !you.duration[DUR_DEATHS_DOOR])</a>
<a name="ln896">        {</a>
<a name="ln897">            if (item_def* emergency_food = _get_emergency_food())</a>
<a name="ln898">            {</a>
<a name="ln899">                mpr(&quot;As you are about to starve, you manage to eat something.&quot;);</a>
<a name="ln900">                eat_item(*emergency_food);</a>
<a name="ln901">                return;</a>
<a name="ln902">            }</a>
<a name="ln903">            mprf(MSGCH_FOOD, &quot;You have starved to death.&quot;);</a>
<a name="ln904">            ouch(INSTANT_DEATH, KILLED_BY_STARVATION);</a>
<a name="ln905">            if (!you.pending_revival) // if we're still here...</a>
<a name="ln906">                set_hunger(HUNGER_DEFAULT, true);</a>
<a name="ln907">        }</a>
<a name="ln908">    }</a>
<a name="ln909">}</a>
<a name="ln910"> </a>
<a name="ln911">static const int hunger_breakpoints[] = { 1, 21, 61, 121, 201, 301, 421 };</a>
<a name="ln912"> </a>
<a name="ln913">int hunger_bars(const int hunger)</a>
<a name="ln914">{</a>
<a name="ln915">    return breakpoint_rank(hunger, hunger_breakpoints,</a>
<a name="ln916">                           ARRAYSZ(hunger_breakpoints));</a>
<a name="ln917">}</a>
<a name="ln918"> </a>
<a name="ln919">string hunger_cost_string(const int hunger)</a>
<a name="ln920">{</a>
<a name="ln921">    if (you_foodless())</a>
<a name="ln922">        return &quot;N/A&quot;;</a>
<a name="ln923"> </a>
<a name="ln924">#ifdef WIZARD</a>
<a name="ln925">    if (you.wizard)</a>
<a name="ln926">        return to_string(hunger);</a>
<a name="ln927">#endif</a>
<a name="ln928"> </a>
<a name="ln929">    const int numbars = hunger_bars(hunger);</a>
<a name="ln930"> </a>
<a name="ln931">    if (numbars &gt; 0)</a>
<a name="ln932">    {</a>
<a name="ln933">        return string(numbars, '#')</a>
<a name="ln934">               + string(ARRAYSZ(hunger_breakpoints) - numbars, '.');</a>
<a name="ln935">    }</a>
<a name="ln936">    else</a>
<a name="ln937">        return &quot;None&quot;;</a>
<a name="ln938">}</a>

</code></pre>
<div class="balloon" rel="300"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v602/" target="_blank">V602</a> Consider inspecting the '(you.hunger_state > HS_SATIATED)' expression. '>' possibly should be replaced with '>>'.</p></div>
<div class="balloon" rel="428"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v768/" target="_blank">V768</a> The expression 'you.undead_state()' is of enum type. It is odd that it is used as an expression of a Boolean-type.</p></div>

<link rel="stylesheet" href="highlight.css">
<script src="highlight.pack.js"></script>
<script src="highlightjs-line-numbers.js"></script>
<script>hljs.initHighlightingOnLoad();</script>
<script>hljs.initLineNumbersOnLoad();</script>
<script>
  $(document).ready(function() {
      $('.balloon').each(function () {
          var bl = $(this);
          var line = bl.attr('rel');
          var text = $('a[name="ln'+line+'"]').text();

          var space_count = 0;
          for(var i = 0; i<text.length; i++){
              var char = text[i];
              if((char !== ' ')&&(char !== '\t'))break;
              if(char === '\t')space_count++;
              space_count++;
          }

          bl.css('margin-left', space_count*8);
          $('a[name="ln'+line+'"]').after(bl);
      });

      window.location = window.location;
  });
</script>
</body>
</html>
