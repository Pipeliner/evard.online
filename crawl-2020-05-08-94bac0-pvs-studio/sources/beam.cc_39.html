
<html>
<head>

  <meta http-equiv="Content-Type" content="text/html; charset=US-ASCII" />
  <title>beam.cc</title>

  <link rel="stylesheet" href="../style.css"/>
  <script src="../jquery-3.2.1.min.js"></script>
</head>
<body>

<pre><code class = "cpp">
<a name="ln1">/**</a>
<a name="ln2"> * @file</a>
<a name="ln3"> * @brief Functions related to ranged attacks.</a>
<a name="ln4">**/</a>
<a name="ln5"> </a>
<a name="ln6">#include &quot;AppHdr.h&quot;</a>
<a name="ln7"> </a>
<a name="ln8">#include &quot;beam.h&quot;</a>
<a name="ln9"> </a>
<a name="ln10">#include &lt;algorithm&gt;</a>
<a name="ln11">#include &lt;cmath&gt;</a>
<a name="ln12">#include &lt;cstdarg&gt;</a>
<a name="ln13">#include &lt;cstdio&gt;</a>
<a name="ln14">#include &lt;cstdlib&gt;</a>
<a name="ln15">#include &lt;cstring&gt;</a>
<a name="ln16">#include &lt;iostream&gt;</a>
<a name="ln17">#include &lt;set&gt;</a>
<a name="ln18"> </a>
<a name="ln19">#include &quot;act-iter.h&quot;</a>
<a name="ln20">#include &quot;areas.h&quot;</a>
<a name="ln21">#include &quot;attack.h&quot;</a>
<a name="ln22">#include &quot;attitude-change.h&quot;</a>
<a name="ln23">#include &quot;bloodspatter.h&quot;</a>
<a name="ln24">#include &quot;chardump.h&quot;</a>
<a name="ln25">#include &quot;cloud.h&quot;</a>
<a name="ln26">#include &quot;colour.h&quot;</a>
<a name="ln27">#include &quot;coordit.h&quot;</a>
<a name="ln28">#include &quot;delay.h&quot;</a>
<a name="ln29">#include &quot;directn.h&quot;</a>
<a name="ln30">#include &quot;dungeon.h&quot;</a>
<a name="ln31">#include &quot;english.h&quot;</a>
<a name="ln32">#include &quot;exercise.h&quot;</a>
<a name="ln33">#include &quot;fight.h&quot;</a>
<a name="ln34">#include &quot;food.h&quot;</a>
<a name="ln35">#include &quot;god-conduct.h&quot;</a>
<a name="ln36">#include &quot;god-item.h&quot;</a>
<a name="ln37">#include &quot;god-passive.h&quot; // passive_t::convert_orcs</a>
<a name="ln38">#include &quot;item-use.h&quot;</a>
<a name="ln39">#include &quot;item-prop.h&quot;</a>
<a name="ln40">#include &quot;items.h&quot;</a>
<a name="ln41">#include &quot;libutil.h&quot;</a>
<a name="ln42">#include &quot;losglobal.h&quot;</a>
<a name="ln43">#include &quot;los.h&quot;</a>
<a name="ln44">#include &quot;message.h&quot;</a>
<a name="ln45">#include &quot;mon-behv.h&quot;</a>
<a name="ln46">#include &quot;mon-death.h&quot;</a>
<a name="ln47">#include &quot;mon-place.h&quot;</a>
<a name="ln48">#include &quot;mon-poly.h&quot;</a>
<a name="ln49">#include &quot;mon-util.h&quot;</a>
<a name="ln50">#include &quot;mutation.h&quot;</a>
<a name="ln51">#include &quot;nearby-danger.h&quot;</a>
<a name="ln52">#include &quot;player-stats.h&quot;</a>
<a name="ln53">#include &quot;potion.h&quot;</a>
<a name="ln54">#include &quot;prompt.h&quot;</a>
<a name="ln55">#include &quot;ranged-attack.h&quot;</a>
<a name="ln56">#include &quot;religion.h&quot;</a>
<a name="ln57">#include &quot;shout.h&quot;</a>
<a name="ln58">#include &quot;spl-clouds.h&quot;</a>
<a name="ln59">#include &quot;spl-damage.h&quot;</a>
<a name="ln60">#include &quot;spl-goditem.h&quot;</a>
<a name="ln61">#include &quot;spl-monench.h&quot;</a>
<a name="ln62">#include &quot;spl-summoning.h&quot;</a>
<a name="ln63">#include &quot;spl-transloc.h&quot;</a>
<a name="ln64">#include &quot;spl-util.h&quot;</a>
<a name="ln65">#include &quot;spl-zap.h&quot;</a>
<a name="ln66">#include &quot;state.h&quot;</a>
<a name="ln67">#include &quot;stepdown.h&quot;</a>
<a name="ln68">#include &quot;stringutil.h&quot;</a>
<a name="ln69">#include &quot;target.h&quot;</a>
<a name="ln70">#include &quot;teleport.h&quot;</a>
<a name="ln71">#include &quot;terrain.h&quot;</a>
<a name="ln72">#include &quot;throw.h&quot;</a>
<a name="ln73">#ifdef USE_TILE</a>
<a name="ln74"> #include &quot;tilepick.h&quot;</a>
<a name="ln75">#endif</a>
<a name="ln76">#include &quot;tiles-build-specific.h&quot;</a>
<a name="ln77">#include &quot;transform.h&quot;</a>
<a name="ln78">#include &quot;traps.h&quot;</a>
<a name="ln79">#include &quot;viewchar.h&quot;</a>
<a name="ln80">#include &quot;view.h&quot;</a>
<a name="ln81">#include &quot;xom.h&quot;</a>
<a name="ln82"> </a>
<a name="ln83">#define SAP_MAGIC_CHANCE() x_chance_in_y(7, 10)</a>
<a name="ln84"> </a>
<a name="ln85">// Helper functions (some of these should probably be public).</a>
<a name="ln86">static void _ench_animation(int flavour, const monster* mon = nullptr,</a>
<a name="ln87">                            bool force = false);</a>
<a name="ln88">static beam_type _chaos_beam_flavour(bolt* beam);</a>
<a name="ln89">static string _beam_type_name(beam_type type);</a>
<a name="ln90">int _ench_pow_to_dur(int pow);</a>
<a name="ln91"> </a>
<a name="ln92">tracer_info::tracer_info()</a>
<a name="ln93">{</a>
<a name="ln94">    reset();</a>
<a name="ln95">}</a>
<a name="ln96"> </a>
<a name="ln97">void tracer_info::reset()</a>
<a name="ln98">{</a>
<a name="ln99">    count = power = hurt = helped = 0;</a>
<a name="ln100">    dont_stop = false;</a>
<a name="ln101">}</a>
<a name="ln102"> </a>
<a name="ln103">const tracer_info&amp; tracer_info::operator+=(const tracer_info &amp;other)</a>
<a name="ln104">{</a>
<a name="ln105">    count  += other.count;</a>
<a name="ln106">    power  += other.power;</a>
<a name="ln107">    hurt   += other.hurt;</a>
<a name="ln108">    helped += other.helped;</a>
<a name="ln109"> </a>
<a name="ln110">    dont_stop = dont_stop || other.dont_stop;</a>
<a name="ln111"> </a>
<a name="ln112">    return *this;</a>
<a name="ln113">}</a>
<a name="ln114"> </a>
<a name="ln115">bool bolt::is_blockable() const</a>
<a name="ln116">{</a>
<a name="ln117">    // BEAM_ELECTRICITY is added here because chain lightning is not</a>
<a name="ln118">    // a true beam (stops at the first target it gets to and redirects</a>
<a name="ln119">    // from there)... but we don't want it shield blockable.</a>
<a name="ln120">    return !pierce &amp;&amp; !is_explosion &amp;&amp; flavour != BEAM_ELECTRICITY</a>
<a name="ln121">           &amp;&amp; hit != AUTOMATIC_HIT &amp;&amp; flavour != BEAM_VISUAL;</a>
<a name="ln122">}</a>
<a name="ln123"> </a>
<a name="ln124">/// Can 'omnireflection' (from the Warlock's Mirror) potentially reflect this?</a>
<a name="ln125">bool bolt::is_omnireflectable() const</a>
<a name="ln126">{</a>
<a name="ln127">    return !is_explosion &amp;&amp; flavour != BEAM_VISUAL</a>
<a name="ln128">            &amp;&amp; origin_spell != SPELL_GLACIATE;</a>
<a name="ln129">}</a>
<a name="ln130"> </a>
<a name="ln131">void bolt::emit_message(const char* m)</a>
<a name="ln132">{</a>
<a name="ln133">    const string message = m;</a>
<a name="ln134">    if (!message_cache.count(message))</a>
<a name="ln135">        mpr(m);</a>
<a name="ln136"> </a>
<a name="ln137">    message_cache.insert(message);</a>
<a name="ln138">}</a>
<a name="ln139"> </a>
<a name="ln140">kill_category bolt::whose_kill() const</a>
<a name="ln141">{</a>
<a name="ln142">    if (YOU_KILL(thrower) || source_id == MID_YOU_FAULTLESS)</a>
<a name="ln143">        return KC_YOU;</a>
<a name="ln144">    else if (MON_KILL(thrower))</a>
<a name="ln145">    {</a>
<a name="ln146">        if (source_id == MID_ANON_FRIEND)</a>
<a name="ln147">            return KC_FRIENDLY;</a>
<a name="ln148">        const monster* mon = monster_by_mid(source_id);</a>
<a name="ln149">        if (mon &amp;&amp; mon-&gt;friendly())</a>
<a name="ln150">            return KC_FRIENDLY;</a>
<a name="ln151">    }</a>
<a name="ln152">    return KC_OTHER;</a>
<a name="ln153">}</a>
<a name="ln154"> </a>
<a name="ln155">// A simple animated flash from Rupert Smith (expanded to be more</a>
<a name="ln156">// generic).</a>
<a name="ln157">static void _zap_animation(int colour, const monster* mon = nullptr,</a>
<a name="ln158">                           bool force = false)</a>
<a name="ln159">{</a>
<a name="ln160">    coord_def p = you.pos();</a>
<a name="ln161"> </a>
<a name="ln162">    if (mon)</a>
<a name="ln163">    {</a>
<a name="ln164">        if (!force &amp;&amp; !mon-&gt;visible_to(&amp;you))</a>
<a name="ln165">            return;</a>
<a name="ln166"> </a>
<a name="ln167">        p = mon-&gt;pos();</a>
<a name="ln168">    }</a>
<a name="ln169"> </a>
<a name="ln170">    if (!you.see_cell(p))</a>
<a name="ln171">        return;</a>
<a name="ln172"> </a>
<a name="ln173">    const coord_def drawp = grid2view(p);</a>
<a name="ln174"> </a>
<a name="ln175">    if (in_los_bounds_v(drawp))</a>
<a name="ln176">    {</a>
<a name="ln177">#ifdef USE_TILE</a>
<a name="ln178">        tiles.add_overlay(p, tileidx_zap(colour));</a>
<a name="ln179">#endif</a>
<a name="ln180">#ifndef USE_TILE_LOCAL</a>
<a name="ln181">        view_update();</a>
<a name="ln182">        cgotoxy(drawp.x, drawp.y, GOTO_DNGN);</a>
<a name="ln183">        put_colour_ch(colour, dchar_glyph(DCHAR_FIRED_ZAP));</a>
<a name="ln184">#endif</a>
<a name="ln185"> </a>
<a name="ln186">        update_screen();</a>
<a name="ln187"> </a>
<a name="ln188">        scaled_delay(50);</a>
<a name="ln189">    }</a>
<a name="ln190">}</a>
<a name="ln191"> </a>
<a name="ln192">// Special front function for zap_animation to interpret enchantment flavours.</a>
<a name="ln193">static void _ench_animation(int flavour, const monster* mon, bool force)</a>
<a name="ln194">{</a>
<a name="ln195">    element_type elem;</a>
<a name="ln196">    switch (flavour)</a>
<a name="ln197">    {</a>
<a name="ln198">    case BEAM_HEALING:</a>
<a name="ln199">        elem = ETC_HEAL;</a>
<a name="ln200">        break;</a>
<a name="ln201">    case BEAM_INFESTATION:</a>
<a name="ln202">    case BEAM_PAIN:</a>
<a name="ln203">    case BEAM_AGONY:</a>
<a name="ln204">    case BEAM_VILE_CLUTCH:</a>
<a name="ln205">        elem = ETC_UNHOLY;</a>
<a name="ln206">        break;</a>
<a name="ln207">    case BEAM_DISPEL_UNDEAD:</a>
<a name="ln208">        elem = ETC_HOLY;</a>
<a name="ln209">        break;</a>
<a name="ln210">    case BEAM_POLYMORPH:</a>
<a name="ln211">    case BEAM_MALMUTATE:</a>
<a name="ln212">        elem = ETC_MUTAGENIC;</a>
<a name="ln213">        break;</a>
<a name="ln214">    case BEAM_CHAOS:</a>
<a name="ln215">        elem = ETC_RANDOM;</a>
<a name="ln216">        break;</a>
<a name="ln217">    case BEAM_TELEPORT:</a>
<a name="ln218">    case BEAM_BANISH:</a>
<a name="ln219">    case BEAM_BLINK:</a>
<a name="ln220">    case BEAM_BLINK_CLOSE:</a>
<a name="ln221">    case BEAM_BECKONING:</a>
<a name="ln222">        elem = ETC_WARP;</a>
<a name="ln223">        break;</a>
<a name="ln224">    case BEAM_MAGIC:</a>
<a name="ln225">        elem = ETC_MAGIC;</a>
<a name="ln226">        break;</a>
<a name="ln227">    default:</a>
<a name="ln228">        elem = ETC_ENCHANT;</a>
<a name="ln229">        break;</a>
<a name="ln230">    }</a>
<a name="ln231"> </a>
<a name="ln232">    _zap_animation(element_colour(elem), mon, force);</a>
<a name="ln233">}</a>
<a name="ln234"> </a>
<a name="ln235">// If needs_tracer is true, we need to check the beam path for friendly</a>
<a name="ln236">// monsters.</a>
<a name="ln237">spret zapping(zap_type ztype, int power, bolt &amp;pbolt,</a>
<a name="ln238">                   bool needs_tracer, const char* msg, bool fail)</a>
<a name="ln239">{</a>
<a name="ln240">    dprf(DIAG_BEAM, &quot;zapping: power=%d&quot;, power);</a>
<a name="ln241"> </a>
<a name="ln242">    pbolt.thrower = KILL_YOU_MISSILE;</a>
<a name="ln243"> </a>
<a name="ln244">    // Check whether tracer goes through friendlies.</a>
<a name="ln245">    // NOTE: Whenever zapping() is called with a randomised value for power</a>
<a name="ln246">    // (or effect), player_tracer should be called directly with the highest</a>
<a name="ln247">    // power possible respecting current skill, experience level, etc.</a>
<a name="ln248">    if (needs_tracer &amp;&amp; !player_tracer(ztype, power, pbolt))</a>
<a name="ln249">        return spret::abort;</a>
<a name="ln250"> </a>
<a name="ln251">    fail_check();</a>
<a name="ln252">    // Fill in the bolt structure.</a>
<a name="ln253">    zappy(ztype, power, false, pbolt);</a>
<a name="ln254"> </a>
<a name="ln255">    if (msg)</a>
<a name="ln256">        mpr(msg);</a>
<a name="ln257"> </a>
<a name="ln258">    if (ztype == ZAP_LIGHTNING_BOLT)</a>
<a name="ln259">    {</a>
<a name="ln260">        noisy(spell_effect_noise(SPELL_LIGHTNING_BOLT),</a>
<a name="ln261">               you.pos(), &quot;You hear a mighty clap of thunder!&quot;);</a>
<a name="ln262">        pbolt.heard = true;</a>
<a name="ln263">    }</a>
<a name="ln264"> </a>
<a name="ln265">    if (ztype == ZAP_DIG)</a>
<a name="ln266">        pbolt.aimed_at_spot = false;</a>
<a name="ln267"> </a>
<a name="ln268">    pbolt.fire();</a>
<a name="ln269"> </a>
<a name="ln270">    return spret::success;</a>
<a name="ln271">}</a>
<a name="ln272"> </a>
<a name="ln273">// Returns true if the path is considered &quot;safe&quot;, and false if there are</a>
<a name="ln274">// monsters in the way the player doesn't want to hit.</a>
<a name="ln275">bool player_tracer(zap_type ztype, int power, bolt &amp;pbolt, int range)</a>
<a name="ln276">{</a>
<a name="ln277">    // Non-controlleable during confusion.</a>
<a name="ln278">    // (We'll shoot in a different direction anyway.)</a>
<a name="ln279">    if (you.confused())</a>
<a name="ln280">        return true;</a>
<a name="ln281"> </a>
<a name="ln282">    zappy(ztype, power, false, pbolt);</a>
<a name="ln283"> </a>
<a name="ln284">    pbolt.is_tracer     = true;</a>
<a name="ln285">    pbolt.source        = you.pos();</a>
<a name="ln286">    pbolt.source_id     = MID_PLAYER;</a>
<a name="ln287">    pbolt.attitude      = ATT_FRIENDLY;</a>
<a name="ln288">    pbolt.thrower       = KILL_YOU_MISSILE;</a>
<a name="ln289"> </a>
<a name="ln290"> </a>
<a name="ln291">    // Init tracer variables.</a>
<a name="ln292">    pbolt.friend_info.reset();</a>
<a name="ln293">    pbolt.foe_info.reset();</a>
<a name="ln294"> </a>
<a name="ln295">    pbolt.foe_ratio        = 100;</a>
<a name="ln296">    pbolt.beam_cancelled   = false;</a>
<a name="ln297">    pbolt.dont_stop_player = false;</a>
<a name="ln298">    pbolt.dont_stop_trees  = false;</a>
<a name="ln299"> </a>
<a name="ln300">    // Clear misc</a>
<a name="ln301">    pbolt.seen          = false;</a>
<a name="ln302">    pbolt.heard         = false;</a>
<a name="ln303">    pbolt.reflections   = 0;</a>
<a name="ln304">    pbolt.bounces       = 0;</a>
<a name="ln305"> </a>
<a name="ln306">    // Save range before overriding it</a>
<a name="ln307">    const int old_range = pbolt.range;</a>
<a name="ln308">    if (range)</a>
<a name="ln309">        pbolt.range = range;</a>
<a name="ln310"> </a>
<a name="ln311">    pbolt.fire();</a>
<a name="ln312"> </a>
<a name="ln313">    if (range)</a>
<a name="ln314">        pbolt.range = old_range;</a>
<a name="ln315"> </a>
<a name="ln316">    // Should only happen if the player answered 'n' to one of those</a>
<a name="ln317">    // &quot;Fire through friendly?&quot; prompts.</a>
<a name="ln318">    if (pbolt.beam_cancelled)</a>
<a name="ln319">    {</a>
<a name="ln320">        dprf(DIAG_BEAM, &quot;Beam cancelled.&quot;);</a>
<a name="ln321">        you.turn_is_over = false;</a>
<a name="ln322">        return false;</a>
<a name="ln323">    }</a>
<a name="ln324"> </a>
<a name="ln325">    // Set to non-tracing for actual firing.</a>
<a name="ln326">    pbolt.is_tracer = false;</a>
<a name="ln327">    return true;</a>
<a name="ln328">}</a>
<a name="ln329"> </a>
<a name="ln330">// Returns true if the player wants / needs to abort based on god displeasure</a>
<a name="ln331">// with targeting this target with this spell. Returns false otherwise.</a>
<a name="ln332">static bool _stop_because_god_hates_target_prompt(monster* mon,</a>
<a name="ln333">                                                  spell_type spell)</a>
<a name="ln334">{</a>
<a name="ln335">    if (spell == SPELL_TUKIMAS_DANCE)</a>
<a name="ln336">    {</a>
<a name="ln337">        const item_def * const first = mon-&gt;weapon(0);</a>
<a name="ln338">        const item_def * const second = mon-&gt;weapon(1);</a>
<a name="ln339">        bool prompt = first &amp;&amp; god_hates_item(*first)</a>
<a name="ln340">                      || second &amp;&amp; god_hates_item(*second);</a>
<a name="ln341">        if (prompt</a>
<a name="ln342">            &amp;&amp; !yesno(&quot;Animating this weapon would place you under penance. &quot;</a>
<a name="ln343">            &quot;Really cast this spell?&quot;, false, 'n'))</a>
<a name="ln344">        {</a>
<a name="ln345">            return true;</a>
<a name="ln346">        }</a>
<a name="ln347">    }</a>
<a name="ln348"> </a>
<a name="ln349">    return false;</a>
<a name="ln350">}</a>
<a name="ln351"> </a>
<a name="ln352">template&lt;typename T&gt;</a>
<a name="ln353">class power_deducer</a>
<a name="ln354">{</a>
<a name="ln355">public:</a>
<a name="ln356">    virtual T operator()(int pow) const = 0;</a>
<a name="ln357">    virtual ~power_deducer() {}</a>
<a name="ln358">};</a>
<a name="ln359"> </a>
<a name="ln360">typedef power_deducer&lt;int&gt; tohit_deducer;</a>
<a name="ln361"> </a>
<a name="ln362">template&lt;int adder, int mult_num = 0, int mult_denom = 1&gt;</a>
<a name="ln363">class tohit_calculator : public tohit_deducer</a>
<a name="ln364">{</a>
<a name="ln365">public:</a>
<a name="ln366">    int operator()(int pow) const override</a>
<a name="ln367">    {</a>
<a name="ln368">        return adder + pow * mult_num / mult_denom;</a>
<a name="ln369">    }</a>
<a name="ln370">};</a>
<a name="ln371"> </a>
<a name="ln372">typedef power_deducer&lt;dice_def&gt; dam_deducer;</a>
<a name="ln373"> </a>
<a name="ln374">template&lt;int numdice, int adder, int mult_num, int mult_denom&gt;</a>
<a name="ln375">class dicedef_calculator : public dam_deducer</a>
<a name="ln376">{</a>
<a name="ln377">public:</a>
<a name="ln378">    dice_def operator()(int pow) const override</a>
<a name="ln379">    {</a>
<a name="ln380">        return dice_def(numdice, adder + pow * mult_num / mult_denom);</a>
<a name="ln381">    }</a>
<a name="ln382">};</a>
<a name="ln383"> </a>
<a name="ln384">template&lt;int numdice, int adder, int mult_num, int mult_denom&gt;</a>
<a name="ln385">class calcdice_calculator : public dam_deducer</a>
<a name="ln386">{</a>
<a name="ln387">public:</a>
<a name="ln388">    dice_def operator()(int pow) const override</a>
<a name="ln389">    {</a>
<a name="ln390">        return calc_dice(numdice, adder + pow * mult_num / mult_denom);</a>
<a name="ln391">    }</a>
<a name="ln392">};</a>
<a name="ln393"> </a>
<a name="ln394">struct zap_info</a>
<a name="ln395">{</a>
<a name="ln396">    zap_type ztype;</a>
<a name="ln397">    const char* name;           // nullptr means handled specially</a>
<a name="ln398">    int player_power_cap;</a>
<a name="ln399">    dam_deducer* player_damage;</a>
<a name="ln400">    tohit_deducer* player_tohit;    // Enchantments have power modifier here</a>
<a name="ln401">    dam_deducer* monster_damage;</a>
<a name="ln402">    tohit_deducer* monster_tohit;</a>
<a name="ln403">    colour_t colour;</a>
<a name="ln404">    bool is_enchantment;</a>
<a name="ln405">    beam_type flavour;</a>
<a name="ln406">    dungeon_char_type glyph;</a>
<a name="ln407">    bool always_obvious;</a>
<a name="ln408">    bool can_beam;</a>
<a name="ln409">    bool is_explosion;</a>
<a name="ln410">    int hit_loudness;</a>
<a name="ln411">};</a>
<a name="ln412"> </a>
<a name="ln413">#include &quot;zap-data.h&quot;</a>
<a name="ln414"> </a>
<a name="ln415">static int zap_index[NUM_ZAPS];</a>
<a name="ln416"> </a>
<a name="ln417">void init_zap_index()</a>
<a name="ln418">{</a>
<a name="ln419">    for (int i = 0; i &lt; NUM_ZAPS; ++i)</a>
<a name="ln420">        zap_index[i] = -1;</a>
<a name="ln421"> </a>
<a name="ln422">    for (unsigned int i = 0; i &lt; ARRAYSZ(zap_data); ++i)</a>
<a name="ln423">        zap_index[zap_data[i].ztype] = i;</a>
<a name="ln424">}</a>
<a name="ln425"> </a>
<a name="ln426">static const zap_info* _seek_zap(zap_type z_type)</a>
<a name="ln427">{</a>
<a name="ln428">    ASSERT_RANGE(z_type, 0, NUM_ZAPS);</a>
<a name="ln429">    if (zap_index[z_type] == -1)</a>
<a name="ln430">        return nullptr;</a>
<a name="ln431">    else</a>
<a name="ln432">        return &amp;zap_data[zap_index[z_type]];</a>
<a name="ln433">}</a>
<a name="ln434"> </a>
<a name="ln435">int zap_power_cap(zap_type z_type)</a>
<a name="ln436">{</a>
<a name="ln437">    const zap_info* zinfo = _seek_zap(z_type);</a>
<a name="ln438"> </a>
<a name="ln439">    return zinfo ? zinfo-&gt;player_power_cap : 0;</a>
<a name="ln440">}</a>
<a name="ln441"> </a>
<a name="ln442">int zap_ench_power(zap_type z_type, int pow, bool is_monster)</a>
<a name="ln443">{</a>
<a name="ln444">    const zap_info* zinfo = _seek_zap(z_type);</a>
<a name="ln445">    if (!zinfo)</a>
<a name="ln446">        return pow;</a>
<a name="ln447"> </a>
<a name="ln448">    if (zinfo-&gt;player_power_cap &gt; 0 &amp;&amp; !is_monster)</a>
<a name="ln449">        pow = min(zinfo-&gt;player_power_cap, pow);</a>
<a name="ln450"> </a>
<a name="ln451">    tohit_deducer* ench_calc = is_monster ? zinfo-&gt;monster_tohit</a>
<a name="ln452">                                          : zinfo-&gt;player_tohit;</a>
<a name="ln453">    if (zinfo-&gt;is_enchantment &amp;&amp; ench_calc)</a>
<a name="ln454">        return (*ench_calc)(pow);</a>
<a name="ln455">    else</a>
<a name="ln456">        return pow;</a>
<a name="ln457">}</a>
<a name="ln458"> </a>
<a name="ln459">void zappy(zap_type z_type, int power, bool is_monster, bolt &amp;pbolt)</a>
<a name="ln460">{</a>
<a name="ln461">    const zap_info* zinfo = _seek_zap(z_type);</a>
<a name="ln462"> </a>
<a name="ln463">    // None found?</a>
<a name="ln464">    if (zinfo == nullptr)</a>
<a name="ln465">    {</a>
<a name="ln466">        dprf(&quot;Couldn't find zap type %d&quot;, z_type);</a>
<a name="ln467">        return;</a>
<a name="ln468">    }</a>
<a name="ln469"> </a>
<a name="ln470">    // Fill</a>
<a name="ln471">    pbolt.name           = zinfo-&gt;name;</a>
<a name="ln472">    pbolt.flavour        = zinfo-&gt;flavour;</a>
<a name="ln473">    pbolt.real_flavour   = zinfo-&gt;flavour;</a>
<a name="ln474">    pbolt.colour         = zinfo-&gt;colour;</a>
<a name="ln475">    pbolt.glyph          = dchar_glyph(zinfo-&gt;glyph);</a>
<a name="ln476">    pbolt.obvious_effect = zinfo-&gt;always_obvious;</a>
<a name="ln477">    pbolt.pierce         = zinfo-&gt;can_beam;</a>
<a name="ln478">    pbolt.is_explosion   = zinfo-&gt;is_explosion;</a>
<a name="ln479"> </a>
<a name="ln480">    if (zinfo-&gt;player_power_cap &gt; 0 &amp;&amp; !is_monster)</a>
<a name="ln481">        power = min(zinfo-&gt;player_power_cap, power);</a>
<a name="ln482"> </a>
<a name="ln483">    ASSERT(zinfo-&gt;is_enchantment == pbolt.is_enchantment());</a>
<a name="ln484"> </a>
<a name="ln485">    pbolt.ench_power = zap_ench_power(z_type, power, is_monster);</a>
<a name="ln486"> </a>
<a name="ln487">    if (zinfo-&gt;is_enchantment)</a>
<a name="ln488">        pbolt.hit = AUTOMATIC_HIT;</a>
<a name="ln489">    else</a>
<a name="ln490">    {</a>
<a name="ln491">        tohit_deducer* hit_calc = is_monster ? zinfo-&gt;monster_tohit</a>
<a name="ln492">                                             : zinfo-&gt;player_tohit;</a>
<a name="ln493">        ASSERT(hit_calc);</a>
<a name="ln494">        pbolt.hit = (*hit_calc)(power);</a>
<a name="ln495">        if (pbolt.hit != AUTOMATIC_HIT &amp;&amp; !is_monster)</a>
<a name="ln496">            pbolt.hit = max(0, pbolt.hit - 5 * you.inaccuracy());</a>
<a name="ln497">    }</a>
<a name="ln498"> </a>
<a name="ln499">    dam_deducer* dam_calc = is_monster ? zinfo-&gt;monster_damage</a>
<a name="ln500">                                       : zinfo-&gt;player_damage;</a>
<a name="ln501">    if (dam_calc)</a>
<a name="ln502">        pbolt.damage = (*dam_calc)(power);</a>
<a name="ln503"> </a>
<a name="ln504">    if (pbolt.origin_spell == SPELL_NO_SPELL)</a>
<a name="ln505">        pbolt.origin_spell = zap_to_spell(z_type);</a>
<a name="ln506"> </a>
<a name="ln507">    if (z_type == ZAP_BREATHE_FIRE &amp;&amp; you.species == SP_RED_DRACONIAN</a>
<a name="ln508">        &amp;&amp; !is_monster)</a>
<a name="ln509">    {</a>
<a name="ln510">        pbolt.origin_spell = SPELL_SEARING_BREATH;</a>
<a name="ln511">    }</a>
<a name="ln512"> </a>
<a name="ln513">    if (pbolt.loudness == 0)</a>
<a name="ln514">        pbolt.loudness = zinfo-&gt;hit_loudness;</a>
<a name="ln515">}</a>
<a name="ln516"> </a>
<a name="ln517">bool bolt::can_affect_actor(const actor *act) const</a>
<a name="ln518">{</a>
<a name="ln519">    // Blinkbolt doesn't hit its caster, since they are the bolt.</a>
<a name="ln520">    if (origin_spell == SPELL_BLINKBOLT &amp;&amp; act-&gt;mid == source_id)</a>
<a name="ln521">        return false;</a>
<a name="ln522">    auto cnt = hit_count.find(act-&gt;mid);</a>
<a name="ln523">    if (cnt != hit_count.end() &amp;&amp; cnt-&gt;second &gt;= 2)</a>
<a name="ln524">    {</a>
<a name="ln525">        // Note: this is done for balance, even if it hurts realism a bit.</a>
<a name="ln526">        // It is arcane knowledge which wall patterns will cause lightning</a>
<a name="ln527">        // to bounce thrice, double damage for ordinary bounces is enough.</a>
<a name="ln528">#ifdef DEBUG_DIAGNOSTICS</a>
<a name="ln529">        if (!quiet_debug)</a>
<a name="ln530">            dprf(DIAG_BEAM, &quot;skipping beam hit, affected them twice already&quot;);</a>
<a name="ln531">#endif</a>
<a name="ln532">        return false;</a>
<a name="ln533">    }</a>
<a name="ln534"> </a>
<a name="ln535">    return !act-&gt;submerged();</a>
<a name="ln536">}</a>
<a name="ln537"> </a>
<a name="ln538">// Choose the beam effect for BEAM_CHAOS that's analogous to the effect used by</a>
<a name="ln539">// SPWPN_CHAOS, with weightings similar to those use by that brand. XXX: Rework</a>
<a name="ln540">// this and SPWPN_CHAOS to use the same tables.</a>
<a name="ln541">static beam_type _chaos_beam_flavour(bolt* beam)</a>
<a name="ln542">{</a>
<a name="ln543">    UNUSED(beam);</a>
<a name="ln544"> </a>
<a name="ln545">    beam_type flavour;</a>
<a name="ln546">    flavour = random_choose_weighted(</a>
<a name="ln547">         // SPWPN_CHAOS randomizes to brands analogous to these beam effects</a>
<a name="ln548">         // with similar weights.</a>
<a name="ln549">         70, BEAM_FIRE,</a>
<a name="ln550">         70, BEAM_COLD,</a>
<a name="ln551">         70, BEAM_ELECTRICITY,</a>
<a name="ln552">         70, BEAM_POISON,</a>
<a name="ln553">         // Combined weight from drain + vamp.</a>
<a name="ln554">         70, BEAM_NEG,</a>
<a name="ln555">         35, BEAM_HOLY,</a>
<a name="ln556">         14, BEAM_CONFUSION,</a>
<a name="ln557">         // We don't have a distortion beam, so choose from the three effects</a>
<a name="ln558">         // we can use, based on the lower weight distortion has.</a>
<a name="ln559">          5, BEAM_BANISH,</a>
<a name="ln560">          5, BEAM_BLINK,</a>
<a name="ln561">          5, BEAM_TELEPORT,</a>
<a name="ln562">         // From here are beam effects analogous to effects that happen when</a>
<a name="ln563">         // SPWPN_CHAOS chooses itself again as the ego (roughly 1/7 chance).</a>
<a name="ln564">         // Weights similar to those from chaos_effects in attack.cc</a>
<a name="ln565">         10, BEAM_SLOW,</a>
<a name="ln566">         10, BEAM_HASTE,</a>
<a name="ln567">         10, BEAM_INVISIBILITY,</a>
<a name="ln568">          5, BEAM_PARALYSIS,</a>
<a name="ln569">          5, BEAM_PETRIFY,</a>
<a name="ln570">          5, BEAM_BERSERK,</a>
<a name="ln571">         // Combined weight for poly, clone, and &quot;shapeshifter&quot; effects.</a>
<a name="ln572">          5, BEAM_POLYMORPH,</a>
<a name="ln573">         // Seen through miscast effects.</a>
<a name="ln574">          5, BEAM_ACID,</a>
<a name="ln575">          5, BEAM_DAMNATION,</a>
<a name="ln576">          5, BEAM_STICKY_FLAME,</a>
<a name="ln577">          5, BEAM_DISINTEGRATION,</a>
<a name="ln578">         // These are not actualy used by SPWPN_CHAOS, but are here to augment</a>
<a name="ln579">         // the list of effects, since not every SPWN_CHAOS effect has an</a>
<a name="ln580">         // analogous BEAM_ type.</a>
<a name="ln581">          4, BEAM_MIGHT,</a>
<a name="ln582">          4, BEAM_HEALING,</a>
<a name="ln583">          4, BEAM_AGILITY,</a>
<a name="ln584">          4, BEAM_ENSNARE);</a>
<a name="ln585"> </a>
<a name="ln586">    return flavour;</a>
<a name="ln587">}</a>
<a name="ln588"> </a>
<a name="ln589">bool bolt::visible() const</a>
<a name="ln590">{</a>
<a name="ln591">    return !is_tracer &amp;&amp; glyph != 0 &amp;&amp; !is_enchantment();</a>
<a name="ln592">}</a>
<a name="ln593"> </a>
<a name="ln594">void bolt::initialise_fire()</a>
<a name="ln595">{</a>
<a name="ln596">    // Fix some things which the tracer might have set.</a>
<a name="ln597">    extra_range_used   = 0;</a>
<a name="ln598">    in_explosion_phase = false;</a>
<a name="ln599">    use_target_as_pos  = false;</a>
<a name="ln600">    hit_count.clear();</a>
<a name="ln601"> </a>
<a name="ln602">    if (special_explosion != nullptr)</a>
<a name="ln603">    {</a>
<a name="ln604">        ASSERT(!is_explosion);</a>
<a name="ln605">        ASSERT(special_explosion-&gt;is_explosion);</a>
<a name="ln606">        ASSERT(special_explosion-&gt;special_explosion == nullptr);</a>
<a name="ln607">        special_explosion-&gt;in_explosion_phase = false;</a>
<a name="ln608">        special_explosion-&gt;use_target_as_pos  = false;</a>
<a name="ln609">    }</a>
<a name="ln610"> </a>
<a name="ln611">    if (chose_ray)</a>
<a name="ln612">    {</a>
<a name="ln613">        ASSERT_IN_BOUNDS(ray.pos());</a>
<a name="ln614"> </a>
<a name="ln615">        if (source == coord_def())</a>
<a name="ln616">            source = ray.pos();</a>
<a name="ln617">    }</a>
<a name="ln618"> </a>
<a name="ln619">    if (target == source)</a>
<a name="ln620">    {</a>
<a name="ln621">        range             = 0;</a>
<a name="ln622">        aimed_at_feet     = true;</a>
<a name="ln623">        auto_hit          = true;</a>
<a name="ln624">        aimed_at_spot     = true;</a>
<a name="ln625">        use_target_as_pos = true;</a>
<a name="ln626">    }</a>
<a name="ln627"> </a>
<a name="ln628">    ASSERT_IN_BOUNDS(source);</a>
<a name="ln629">    ASSERT_RANGE(flavour, BEAM_NONE + 1, BEAM_FIRST_PSEUDO);</a>
<a name="ln630">    ASSERT(!drop_item || item &amp;&amp; item-&gt;defined());</a>
<a name="ln631">    ASSERTM(range &gt;= 0, &quot;beam '%s', source '%s', item '%s'; has range -1&quot;,</a>
<a name="ln632">            name.c_str(),</a>
<a name="ln633">            (source_id == MID_PLAYER ? &quot;player&quot; :</a>
<a name="ln634">                          monster_by_mid(source_id) ?</a>
<a name="ln635">                             monster_by_mid(source_id)-&gt;name(DESC_PLAIN, true) :</a>
<a name="ln636">                          &quot;unknown&quot;).c_str(),</a>
<a name="ln637">            (item ? item-&gt;name(DESC_PLAIN, false, true) : &quot;none&quot;).c_str());</a>
<a name="ln638">    ASSERT(!aimed_at_feet || source == target);</a>
<a name="ln639"> </a>
<a name="ln640">    real_flavour = flavour;</a>
<a name="ln641"> </a>
<a name="ln642">    message_cache.clear();</a>
<a name="ln643"> </a>
<a name="ln644">    // seen might be set by caller to suppress this.</a>
<a name="ln645">    if (!seen &amp;&amp; you.see_cell(source) &amp;&amp; range &gt; 0 &amp;&amp; visible())</a>
<a name="ln646">    {</a>
<a name="ln647">        seen = true;</a>
<a name="ln648">        const monster* mon = monster_at(source);</a>
<a name="ln649"> </a>
<a name="ln650">        if (flavour != BEAM_VISUAL</a>
<a name="ln651">            &amp;&amp; !YOU_KILL(thrower)</a>
<a name="ln652">            &amp;&amp; !crawl_state.is_god_acting()</a>
<a name="ln653">            &amp;&amp; (!mon || !mon-&gt;observable()))</a>
<a name="ln654">        {</a>
<a name="ln655">            mprf(&quot;%s appears from out of thin air!&quot;,</a>
<a name="ln656">                 article_a(name, false).c_str());</a>
<a name="ln657">        }</a>
<a name="ln658">    }</a>
<a name="ln659"> </a>
<a name="ln660">    // Visible self-targeted beams are always seen, even though they don't</a>
<a name="ln661">    // leave a path.</a>
<a name="ln662">    if (you.see_cell(source) &amp;&amp; target == source &amp;&amp; visible())</a>
<a name="ln663">        seen = true;</a>
<a name="ln664"> </a>
<a name="ln665">    // The agent may die during the beam's firing, need to save these now.</a>
<a name="ln666">    // If the beam was reflected, assume it can &quot;see&quot; anything, since neither</a>
<a name="ln667">    // the reflector nor the original source was particularly aiming for this</a>
<a name="ln668">    // target. WARNING: if you change this logic, keep in mind that</a>
<a name="ln669">    // menv[YOU_FAULTLESS] cannot be safely queried for properties like</a>
<a name="ln670">    // can_see_invisible.</a>
<a name="ln671">    if (reflections &gt; 0)</a>
<a name="ln672">        nightvision = can_see_invis = true;</a>
<a name="ln673">    else</a>
<a name="ln674">    {</a>
<a name="ln675">        // XXX: Should non-agents count as seeing invisible?</a>
<a name="ln676">        nightvision = agent() &amp;&amp; agent()-&gt;nightvision();</a>
<a name="ln677">        can_see_invis = agent() &amp;&amp; agent()-&gt;can_see_invisible();</a>
<a name="ln678">    }</a>
<a name="ln679"> </a>
<a name="ln680">#ifdef DEBUG_DIAGNOSTICS</a>
<a name="ln681">    // Not a &quot;real&quot; tracer, merely a range/reachability check.</a>
<a name="ln682">    if (quiet_debug)</a>
<a name="ln683">        return;</a>
<a name="ln684"> </a>
<a name="ln685">    dprf(DIAG_BEAM, &quot;%s%s%s [%s] (%d,%d) to (%d,%d): &quot;</a>
<a name="ln686">          &quot;gl=%d col=%d flav=%d hit=%d dam=%dd%d range=%d&quot;,</a>
<a name="ln687">          (pierce) ? &quot;beam&quot; : &quot;missile&quot;,</a>
<a name="ln688">          (is_explosion) ? &quot;*&quot; :</a>
<a name="ln689">          (is_big_cloud()) ? &quot;+&quot; : &quot;&quot;,</a>
<a name="ln690">          (is_tracer) ? &quot; tracer&quot; : &quot;&quot;,</a>
<a name="ln691">          name.c_str(),</a>
<a name="ln692">          source.x, source.y,</a>
<a name="ln693">          target.x, target.y,</a>
<a name="ln694">          glyph, colour, flavour,</a>
<a name="ln695">          hit, damage.num, damage.size,</a>
<a name="ln696">          range);</a>
<a name="ln697">#endif</a>
<a name="ln698">}</a>
<a name="ln699"> </a>
<a name="ln700">void bolt::apply_beam_conducts()</a>
<a name="ln701">{</a>
<a name="ln702">    if (!is_tracer &amp;&amp; YOU_KILL(thrower))</a>
<a name="ln703">    {</a>
<a name="ln704">        switch (flavour)</a>
<a name="ln705">        {</a>
<a name="ln706">        case BEAM_DAMNATION:</a>
<a name="ln707">        {</a>
<a name="ln708">            const int level = 2 + random2(3);</a>
<a name="ln709">            did_god_conduct(DID_EVIL, level, god_cares());</a>
<a name="ln710">            break;</a>
<a name="ln711">        }</a>
<a name="ln712">        default:</a>
<a name="ln713">            break;</a>
<a name="ln714">        }</a>
<a name="ln715">    }</a>
<a name="ln716">}</a>
<a name="ln717"> </a>
<a name="ln718">void bolt::choose_ray()</a>
<a name="ln719">{</a>
<a name="ln720">    if ((!chose_ray || reflections &gt; 0)</a>
<a name="ln721">        &amp;&amp; !find_ray(source, target, ray, opc_solid_see)</a>
<a name="ln722">        // If fire is blocked, at least try a visible path so the</a>
<a name="ln723">        // error message is better.</a>
<a name="ln724">        &amp;&amp; !find_ray(source, target, ray, opc_default))</a>
<a name="ln725">    {</a>
<a name="ln726">        fallback_ray(source, target, ray);</a>
<a name="ln727">    }</a>
<a name="ln728">}</a>
<a name="ln729"> </a>
<a name="ln730">// Draw the bolt at p if needed.</a>
<a name="ln731">void bolt::draw(const coord_def&amp; p)</a>
<a name="ln732">{</a>
<a name="ln733">    if (is_tracer || is_enchantment() || !you.see_cell(p))</a>
<a name="ln734">        return;</a>
<a name="ln735"> </a>
<a name="ln736">    // We don't clean up the old position.</a>
<a name="ln737">    // First, most people like to see the full path,</a>
<a name="ln738">    // and second, it is hard to do it right with</a>
<a name="ln739">    // respect to killed monsters, cloud trails, etc.</a>
<a name="ln740"> </a>
<a name="ln741">    const coord_def drawpos = grid2view(p);</a>
<a name="ln742"> </a>
<a name="ln743">    if (!in_los_bounds_v(drawpos))</a>
<a name="ln744">        return;</a>
<a name="ln745"> </a>
<a name="ln746">#ifdef USE_TILE</a>
<a name="ln747">    if (tile_beam == -1)</a>
<a name="ln748">        tile_beam = tileidx_bolt(*this);</a>
<a name="ln749"> </a>
<a name="ln750">    if (tile_beam != -1)</a>
<a name="ln751">    {</a>
<a name="ln752">        int dist = (p - source).rdist();</a>
<a name="ln753">        tiles.add_overlay(p, vary_bolt_tile(tile_beam, dist));</a>
<a name="ln754">    }</a>
<a name="ln755">#endif</a>
<a name="ln756">#ifndef USE_TILE_LOCAL</a>
<a name="ln757">    cgotoxy(drawpos.x, drawpos.y, GOTO_DNGN);</a>
<a name="ln758">    put_colour_ch(colour == BLACK ? random_colour(true)</a>
<a name="ln759">                                  : element_colour(colour),</a>
<a name="ln760">                  glyph);</a>
<a name="ln761"> </a>
<a name="ln762">    // Get curses to update the screen so we can see the beam.</a>
<a name="ln763">    update_screen();</a>
<a name="ln764">#endif</a>
<a name="ln765">    scaled_delay(draw_delay);</a>
<a name="ln766">}</a>
<a name="ln767"> </a>
<a name="ln768">// Bounce a bolt off a solid feature.</a>
<a name="ln769">// The ray is assumed to have just been advanced into</a>
<a name="ln770">// the feature.</a>
<a name="ln771">void bolt::bounce()</a>
<a name="ln772">{</a>
<a name="ln773">    ASSERT(cell_is_solid(ray.pos()));</a>
<a name="ln774">    // Don't bounce player tracers off unknown cells, or cells that we</a>
<a name="ln775">    // incorrectly thought were non-bouncy.</a>
<a name="ln776">    if (is_tracer &amp;&amp; agent() == &amp;you)</a>
<a name="ln777">    {</a>
<a name="ln778">        const dungeon_feature_type feat = env.map_knowledge(ray.pos()).feat();</a>
<a name="ln779"> </a>
<a name="ln780">        if (feat == DNGN_UNSEEN || !feat_is_solid(feat) || !is_bouncy(feat))</a>
<a name="ln781">        {</a>
<a name="ln782">            ray.regress();</a>
<a name="ln783">            finish_beam();</a>
<a name="ln784">            return;</a>
<a name="ln785">        }</a>
<a name="ln786">    }</a>
<a name="ln787"> </a>
<a name="ln788">    do</a>
<a name="ln789">    {</a>
<a name="ln790">        ray.regress();</a>
<a name="ln791">    }</a>
<a name="ln792">    while (cell_is_solid(ray.pos()));</a>
<a name="ln793"> </a>
<a name="ln794">    extra_range_used += range_used(true);</a>
<a name="ln795">    bounce_pos = ray.pos();</a>
<a name="ln796">    bounces++;</a>
<a name="ln797">    reflect_grid rg;</a>
<a name="ln798">    for (adjacent_iterator ai(ray.pos(), false); ai; ++ai)</a>
<a name="ln799">        rg(*ai - ray.pos()) = cell_is_solid(*ai);</a>
<a name="ln800">    ray.bounce(rg);</a>
<a name="ln801">    extra_range_used += 2;</a>
<a name="ln802"> </a>
<a name="ln803">    ASSERT(!cell_is_solid(ray.pos()));</a>
<a name="ln804">}</a>
<a name="ln805"> </a>
<a name="ln806">void bolt::fake_flavour()</a>
<a name="ln807">{</a>
<a name="ln808">    if (real_flavour == BEAM_RANDOM)</a>
<a name="ln809">        flavour = static_cast&lt;beam_type&gt;(random_range(BEAM_FIRE, BEAM_ACID));</a>
<a name="ln810">    else if (real_flavour == BEAM_CHAOS)</a>
<a name="ln811">        flavour = _chaos_beam_flavour(this);</a>
<a name="ln812">    else if (real_flavour == BEAM_CRYSTAL &amp;&amp; flavour == BEAM_CRYSTAL)</a>
<a name="ln813">    {</a>
<a name="ln814">        flavour = random_choose(BEAM_FIRE, BEAM_COLD);</a>
<a name="ln815">        hit_verb = (flavour == BEAM_FIRE) ? &quot;burns&quot; :</a>
<a name="ln816">                   (flavour == BEAM_COLD) ? &quot;freezes&quot;</a>
<a name="ln817">                                          : &quot;bugs&quot;;</a>
<a name="ln818">    }</a>
<a name="ln819">}</a>
<a name="ln820"> </a>
<a name="ln821">void bolt::digging_wall_effect()</a>
<a name="ln822">{</a>
<a name="ln823">    if (env.markers.property_at(pos(), MAT_ANY, &quot;veto_dig&quot;) == &quot;veto&quot;)</a>
<a name="ln824">    {</a>
<a name="ln825">        finish_beam();</a>
<a name="ln826">        return;</a>
<a name="ln827">    }</a>
<a name="ln828"> </a>
<a name="ln829">    const dungeon_feature_type feat = grd(pos());</a>
<a name="ln830">    if (feat_is_diggable(feat))</a>
<a name="ln831">    {</a>
<a name="ln832">        destroy_wall(pos());</a>
<a name="ln833">        if (!msg_generated)</a>
<a name="ln834">        {</a>
<a name="ln835">            if (!you.see_cell(pos()))</a>
<a name="ln836">            {</a>
<a name="ln837">                if (!silenced(you.pos()))</a>
<a name="ln838">                {</a>
<a name="ln839">                    mprf(MSGCH_SOUND, &quot;You hear a grinding noise.&quot;);</a>
<a name="ln840">                    obvious_effect = true; // You may still see the caster.</a>
<a name="ln841">                    msg_generated = true;</a>
<a name="ln842">                }</a>
<a name="ln843">                return;</a>
<a name="ln844">            }</a>
<a name="ln845"> </a>
<a name="ln846">            obvious_effect = true;</a>
<a name="ln847">            msg_generated = true;</a>
<a name="ln848"> </a>
<a name="ln849">            string wall;</a>
<a name="ln850">            if (feat == DNGN_GRATE)</a>
<a name="ln851">            {</a>
<a name="ln852">                // XXX: should this change for monsters?</a>
<a name="ln853">                mpr(&quot;The damaged grate falls apart.&quot;);</a>
<a name="ln854">                return;</a>
<a name="ln855">            }</a>
<a name="ln856">            else if (feat == DNGN_SLIMY_WALL)</a>
<a name="ln857">                wall = &quot;slime&quot;;</a>
<a name="ln858">            else if (player_in_branch(BRANCH_PANDEMONIUM))</a>
<a name="ln859">                wall = &quot;weird stuff&quot;;</a>
<a name="ln860">            else</a>
<a name="ln861">                wall = &quot;rock&quot;;</a>
<a name="ln862"> </a>
<a name="ln863">            mprf(&quot;%s %s shatters into small pieces.&quot;,</a>
<a name="ln864">                 agent() &amp;&amp; agent()-&gt;is_player() ? &quot;The&quot; : &quot;Some&quot;,</a>
<a name="ln865">                 wall.c_str());</a>
<a name="ln866">        }</a>
<a name="ln867">    }</a>
<a name="ln868">    else if (feat_is_wall(feat))</a>
<a name="ln869">        finish_beam();</a>
<a name="ln870">}</a>
<a name="ln871"> </a>
<a name="ln872">void bolt::burn_wall_effect()</a>
<a name="ln873">{</a>
<a name="ln874">    dungeon_feature_type feat = grd(pos());</a>
<a name="ln875">    // Fire only affects trees.</a>
<a name="ln876">    if (!feat_is_tree(feat)</a>
<a name="ln877">        || env.markers.property_at(pos(), MAT_ANY, &quot;veto_fire&quot;) == &quot;veto&quot;</a>
<a name="ln878">        || !can_burn_trees()) // sanity</a>
<a name="ln879">    {</a>
<a name="ln880">        finish_beam();</a>
<a name="ln881">        return;</a>
<a name="ln882">    }</a>
<a name="ln883"> </a>
<a name="ln884">    // Destroy the wall.</a>
<a name="ln885">    destroy_wall(pos());</a>
<a name="ln886">    if (you.see_cell(pos()))</a>
<a name="ln887">    {</a>
<a name="ln888">        if (player_in_branch(BRANCH_SWAMP))</a>
<a name="ln889">            emit_message(&quot;The tree smoulders and burns.&quot;);</a>
<a name="ln890">        else</a>
<a name="ln891">            emit_message(&quot;The tree burns like a torch!&quot;);</a>
<a name="ln892">    }</a>
<a name="ln893">    else if (you.can_smell())</a>
<a name="ln894">        emit_message(&quot;You smell burning wood.&quot;);</a>
<a name="ln895">    if (whose_kill() == KC_YOU)</a>
<a name="ln896">        did_god_conduct(DID_KILL_PLANT, 1, god_cares());</a>
<a name="ln897">    else if (whose_kill() == KC_FRIENDLY &amp;&amp; !crawl_state.game_is_arena())</a>
<a name="ln898">        did_god_conduct(DID_KILL_PLANT, 1, god_cares());</a>
<a name="ln899"> </a>
<a name="ln900">    // Trees do not burn so readily in a wet environment.</a>
<a name="ln901">    if (player_in_branch(BRANCH_SWAMP))</a>
<a name="ln902">        place_cloud(CLOUD_FIRE, pos(), random2(12)+5, agent());</a>
<a name="ln903">    else</a>
<a name="ln904">        place_cloud(CLOUD_FOREST_FIRE, pos(), random2(30)+25, agent());</a>
<a name="ln905">    obvious_effect = true;</a>
<a name="ln906"> </a>
<a name="ln907">    finish_beam();</a>
<a name="ln908">}</a>
<a name="ln909"> </a>
<a name="ln910">int bolt::range_used(bool leg_only) const</a>
<a name="ln911">{</a>
<a name="ln912">    const int leg_length = pos().distance_from(leg_source());</a>
<a name="ln913">    return leg_only ? leg_length : leg_length + extra_range_used;</a>
<a name="ln914">}</a>
<a name="ln915"> </a>
<a name="ln916">void bolt::finish_beam()</a>
<a name="ln917">{</a>
<a name="ln918">    extra_range_used = BEAM_STOP;</a>
<a name="ln919">}</a>
<a name="ln920"> </a>
<a name="ln921">void bolt::affect_wall()</a>
<a name="ln922">{</a>
<a name="ln923">    if (is_tracer)</a>
<a name="ln924">    {</a>
<a name="ln925">        if (!in_bounds(pos()) || !can_affect_wall(pos(), true))</a>
<a name="ln926">            finish_beam();</a>
<a name="ln927"> </a>
<a name="ln928">        // potentially warn about offending your god by burning trees</a>
<a name="ln929">        const bool god_relevant = you.religion == GOD_FEDHAS</a>
<a name="ln930">                                  &amp;&amp; can_burn_trees();</a>
<a name="ln931">        const bool vetoed = env.markers.property_at(pos(), MAT_ANY, &quot;veto_fire&quot;)</a>
<a name="ln932">                            == &quot;veto&quot;;</a>
<a name="ln933">        // XXX: should check env knowledge for feat_is_tree()</a>
<a name="ln934">        if (god_relevant &amp;&amp; feat_is_tree(grd(pos())) &amp;&amp; !vetoed</a>
<a name="ln935">            &amp;&amp; !is_targeting &amp;&amp; YOU_KILL(thrower) &amp;&amp; !dont_stop_trees)</a>
<a name="ln936">        {</a>
<a name="ln937">            const string prompt =</a>
<a name="ln938">                make_stringf(&quot;Are you sure you want to burn %s?&quot;,</a>
<a name="ln939">                             feature_description_at(pos(), false, DESC_THE).c_str());</a>
<a name="ln940"> </a>
<a name="ln941">            if (yesno(prompt.c_str(), false, 'n'))</a>
<a name="ln942">                dont_stop_trees = true;</a>
<a name="ln943">            else</a>
<a name="ln944">            {</a>
<a name="ln945">                canned_msg(MSG_OK);</a>
<a name="ln946">                beam_cancelled = true;</a>
<a name="ln947">                finish_beam();</a>
<a name="ln948">            }</a>
<a name="ln949">        }</a>
<a name="ln950"> </a>
<a name="ln951">        // The only thing that doesn't stop at walls.</a>
<a name="ln952">        if (flavour != BEAM_DIGGING)</a>
<a name="ln953">            finish_beam();</a>
<a name="ln954">        return;</a>
<a name="ln955">    }</a>
<a name="ln956">    if (in_bounds(pos()))</a>
<a name="ln957">    {</a>
<a name="ln958">        if (flavour == BEAM_DIGGING)</a>
<a name="ln959">            digging_wall_effect();</a>
<a name="ln960">        else if (can_burn_trees())</a>
<a name="ln961">            burn_wall_effect();</a>
<a name="ln962">    }</a>
<a name="ln963">    if (cell_is_solid(pos()))</a>
<a name="ln964">        finish_beam();</a>
<a name="ln965">}</a>
<a name="ln966"> </a>
<a name="ln967">coord_def bolt::pos() const</a>
<a name="ln968">{</a>
<a name="ln969">    if (in_explosion_phase || use_target_as_pos)</a>
<a name="ln970">        return target;</a>
<a name="ln971">    else</a>
<a name="ln972">        return ray.pos();</a>
<a name="ln973">}</a>
<a name="ln974"> </a>
<a name="ln975">bool bolt::need_regress() const</a>
<a name="ln976">{</a>
<a name="ln977">    // XXX: The affects_wall check probably makes some of the</a>
<a name="ln978">    //      others obsolete.</a>
<a name="ln979">    return (is_explosion &amp;&amp; !in_explosion_phase)</a>
<a name="ln980">           || drop_item</a>
<a name="ln981">           || cell_is_solid(pos()) &amp;&amp; !can_affect_wall(pos())</a>
<a name="ln982">           || origin_spell == SPELL_PRIMAL_WAVE;</a>
<a name="ln983">}</a>
<a name="ln984"> </a>
<a name="ln985">void bolt::affect_cell()</a>
<a name="ln986">{</a>
<a name="ln987">    // Shooting through clouds affects accuracy.</a>
<a name="ln988">    if (cloud_at(pos()) &amp;&amp; hit != AUTOMATIC_HIT)</a>
<a name="ln989">        hit = max(hit - 2, 0);</a>
<a name="ln990"> </a>
<a name="ln991">    fake_flavour();</a>
<a name="ln992"> </a>
<a name="ln993">    // Note that this can change the solidity of the wall.</a>
<a name="ln994">    if (cell_is_solid(pos()))</a>
<a name="ln995">        affect_wall();</a>
<a name="ln996"> </a>
<a name="ln997">    // If the player can ever walk through walls, this will need</a>
<a name="ln998">    // special-casing too.</a>
<a name="ln999">    bool hit_player = found_player();</a>
<a name="ln1000">    if (hit_player &amp;&amp; can_affect_actor(&amp;you))</a>
<a name="ln1001">    {</a>
<a name="ln1002">        const int prev_reflections = reflections;</a>
<a name="ln1003">        affect_player();</a>
<a name="ln1004">        if (reflections != prev_reflections)</a>
<a name="ln1005">            return;</a>
<a name="ln1006">        if (hit == AUTOMATIC_HIT &amp;&amp; !pierce)</a>
<a name="ln1007">            finish_beam();</a>
<a name="ln1008">    }</a>
<a name="ln1009"> </a>
<a name="ln1010">    // Stop single target beams from affecting a monster if they already</a>
<a name="ln1011">    // affected the player on this square. -cao</a>
<a name="ln1012">    if (!hit_player || pierce || is_explosion)</a>
<a name="ln1013">    {</a>
<a name="ln1014">        monster *m = monster_at(pos());</a>
<a name="ln1015">        if (m &amp;&amp; can_affect_actor(m))</a>
<a name="ln1016">        {</a>
<a name="ln1017">            const bool ignored = ignores_monster(m);</a>
<a name="ln1018">            affect_monster(m);</a>
<a name="ln1019">            if (hit == AUTOMATIC_HIT &amp;&amp; !pierce &amp;&amp; !ignored</a>
<a name="ln1020">                // Assumes tracers will always have an agent!</a>
<a name="ln1021">                &amp;&amp; (!is_tracer || m-&gt;visible_to(agent())))</a>
<a name="ln1022">            {</a>
<a name="ln1023">                finish_beam();</a>
<a name="ln1024">            }</a>
<a name="ln1025">        }</a>
<a name="ln1026">    }</a>
<a name="ln1027"> </a>
<a name="ln1028">    if (!cell_is_solid(pos()))</a>
<a name="ln1029">        affect_ground();</a>
<a name="ln1030">}</a>
<a name="ln1031"> </a>
<a name="ln1032">static void _undo_tracer(bolt &amp;orig, bolt &amp;copy)</a>
<a name="ln1033">{</a>
<a name="ln1034">    // FIXME: we should have a better idea of what gets changed!</a>
<a name="ln1035">    orig.target           = copy.target;</a>
<a name="ln1036">    orig.source           = copy.source;</a>
<a name="ln1037">    orig.aimed_at_spot    = copy.aimed_at_spot;</a>
<a name="ln1038">    orig.extra_range_used = copy.extra_range_used;</a>
<a name="ln1039">    orig.auto_hit         = copy.auto_hit;</a>
<a name="ln1040">    orig.ray              = copy.ray;</a>
<a name="ln1041">    orig.colour           = copy.colour;</a>
<a name="ln1042">    orig.flavour          = copy.flavour;</a>
<a name="ln1043">    orig.real_flavour     = copy.real_flavour;</a>
<a name="ln1044">    orig.bounces          = copy.bounces;</a>
<a name="ln1045">    orig.bounce_pos       = copy.bounce_pos;</a>
<a name="ln1046">}</a>
<a name="ln1047"> </a>
<a name="ln1048">// This saves some important things before calling fire().</a>
<a name="ln1049">void bolt::fire()</a>
<a name="ln1050">{</a>
<a name="ln1051">    path_taken.clear();</a>
<a name="ln1052"> </a>
<a name="ln1053">    if (special_explosion)</a>
<a name="ln1054">        special_explosion-&gt;is_tracer = is_tracer;</a>
<a name="ln1055"> </a>
<a name="ln1056">    if (is_tracer)</a>
<a name="ln1057">    {</a>
<a name="ln1058">        bolt boltcopy = *this;</a>
<a name="ln1059">        if (special_explosion != nullptr)</a>
<a name="ln1060">            boltcopy.special_explosion = new bolt(*special_explosion);</a>
<a name="ln1061"> </a>
<a name="ln1062">        do_fire();</a>
<a name="ln1063"> </a>
<a name="ln1064">        if (special_explosion != nullptr)</a>
<a name="ln1065">        {</a>
<a name="ln1066">            _undo_tracer(*special_explosion, *boltcopy.special_explosion);</a>
<a name="ln1067">            delete boltcopy.special_explosion;</a>
<a name="ln1068">        }</a>
<a name="ln1069"> </a>
<a name="ln1070">        _undo_tracer(*this, boltcopy);</a>
<a name="ln1071">    }</a>
<a name="ln1072">    else</a>
<a name="ln1073">        do_fire();</a>
<a name="ln1074"> </a>
<a name="ln1075">    //XXX: suspect, but code relies on path_taken being non-empty</a>
<a name="ln1076">    if (path_taken.empty())</a>
<a name="ln1077">        path_taken.push_back(source);</a>
<a name="ln1078"> </a>
<a name="ln1079">    if (special_explosion != nullptr)</a>
<a name="ln1080">    {</a>
<a name="ln1081">        seen           = seen  || special_explosion-&gt;seen;</a>
<a name="ln1082">        heard          = heard || special_explosion-&gt;heard;</a>
<a name="ln1083">    }</a>
<a name="ln1084">}</a>
<a name="ln1085"> </a>
<a name="ln1086">void bolt::do_fire()</a>
<a name="ln1087">{</a>
<a name="ln1088">    initialise_fire();</a>
<a name="ln1089"> </a>
<a name="ln1090">    if (range &lt; extra_range_used &amp;&amp; range &gt; 0)</a>
<a name="ln1091">    {</a>
<a name="ln1092">#ifdef DEBUG</a>
<a name="ln1093">        dprf(DIAG_BEAM, &quot;fire_beam() called on already done beam &quot;</a>
<a name="ln1094">             &quot;'%s' (item = '%s')&quot;, name.c_str(),</a>
<a name="ln1095">             item ? item-&gt;name(DESC_PLAIN).c_str() : &quot;none&quot;);</a>
<a name="ln1096">#endif</a>
<a name="ln1097">        return;</a>
<a name="ln1098">    }</a>
<a name="ln1099"> </a>
<a name="ln1100">    apply_beam_conducts();</a>
<a name="ln1101">    cursor_control coff(false);</a>
<a name="ln1102"> </a>
<a name="ln1103">#ifdef USE_TILE</a>
<a name="ln1104">    tile_beam = -1;</a>
<a name="ln1105"> </a>
<a name="ln1106">    if (item &amp;&amp; !is_tracer &amp;&amp; (flavour == BEAM_MISSILE</a>
<a name="ln1107">                               || flavour == BEAM_VISUAL))</a>
<a name="ln1108">    {</a>
<a name="ln1109">        const coord_def diff = target - source;</a>
<a name="ln1110">        tile_beam = tileidx_item_throw(get_item_info(*item), diff.x, diff.y);</a>
<a name="ln1111">    }</a>
<a name="ln1112">#endif</a>
<a name="ln1113"> </a>
<a name="ln1114">    msg_generated = false;</a>
<a name="ln1115">    if (!aimed_at_feet)</a>
<a name="ln1116">    {</a>
<a name="ln1117">        choose_ray();</a>
<a name="ln1118">        // Take *one* step, so as not to hurt the source.</a>
<a name="ln1119">        ray.advance();</a>
<a name="ln1120">    }</a>
<a name="ln1121"> </a>
<a name="ln1122">    // Note: nothing but this loop should be changing the ray.</a>
<a name="ln1123">    while (map_bounds(pos()))</a>
<a name="ln1124">    {</a>
<a name="ln1125">        if (range_used() &gt; range)</a>
<a name="ln1126">        {</a>
<a name="ln1127">            ray.regress();</a>
<a name="ln1128">            extra_range_used++;</a>
<a name="ln1129">            ASSERT(range_used() &gt;= range);</a>
<a name="ln1130">            break;</a>
<a name="ln1131">        }</a>
<a name="ln1132"> </a>
<a name="ln1133">        const dungeon_feature_type feat = grd(pos());</a>
<a name="ln1134"> </a>
<a name="ln1135">        if (in_bounds(target)</a>
<a name="ln1136">            // We ran into a solid wall with a real beam...</a>
<a name="ln1137">            &amp;&amp; (feat_is_solid(feat)</a>
<a name="ln1138">                &amp;&amp; flavour != BEAM_DIGGING &amp;&amp; flavour &lt;= BEAM_LAST_REAL</a>
<a name="ln1139">                &amp;&amp; !cell_is_solid(target)</a>
<a name="ln1140">            // or visible firewood with a non-penetrating beam...</a>
<a name="ln1141">                || !pierce</a>
<a name="ln1142">                   &amp;&amp; monster_at(pos())</a>
<a name="ln1143">                   &amp;&amp; you.can_see(*monster_at(pos()))</a>
<a name="ln1144">                   &amp;&amp; !ignores_monster(monster_at(pos()))</a>
<a name="ln1145">                   &amp;&amp; mons_is_firewood(*monster_at(pos())))</a>
<a name="ln1146">            // and it's a player tracer...</a>
<a name="ln1147">            // (!is_targeting so you don't get prompted while adjusting the aim)</a>
<a name="ln1148">            &amp;&amp; is_tracer &amp;&amp; !is_targeting &amp;&amp; YOU_KILL(thrower)</a>
<a name="ln1149">            // and we're actually between you and the target...</a>
<a name="ln1150">            &amp;&amp; !passed_target &amp;&amp; pos() != target &amp;&amp; pos() != source</a>
<a name="ln1151">            // ?</a>
<a name="ln1152">            &amp;&amp; foe_info.count == 0 &amp;&amp; bounces == 0 &amp;&amp; reflections == 0</a>
<a name="ln1153">            // and you aren't shooting out of LOS.</a>
<a name="ln1154">            &amp;&amp; you.see_cell(target))</a>
<a name="ln1155">        {</a>
<a name="ln1156">            // Okay, with all those tests passed, this is probably an instance</a>
<a name="ln1157">            // of the player manually targeting something whose line of fire</a>
<a name="ln1158">            // is blocked, even though its line of sight isn't blocked. Give</a>
<a name="ln1159">            // a warning about this fact.</a>
<a name="ln1160">            string prompt = &quot;Your line of fire to &quot;;</a>
<a name="ln1161">            const monster* mon = monster_at(target);</a>
<a name="ln1162"> </a>
<a name="ln1163">            if (mon &amp;&amp; mon-&gt;observable())</a>
<a name="ln1164">                prompt += mon-&gt;name(DESC_THE);</a>
<a name="ln1165">            else</a>
<a name="ln1166">            {</a>
<a name="ln1167">                prompt += &quot;the targeted &quot;</a>
<a name="ln1168">                        + feature_description_at(target, false, DESC_PLAIN);</a>
<a name="ln1169">            }</a>
<a name="ln1170"> </a>
<a name="ln1171">            prompt += &quot; is blocked by &quot;</a>
<a name="ln1172">                    + (feat_is_solid(feat) ?</a>
<a name="ln1173">                        feature_description_at(pos(), false, DESC_A) :</a>
<a name="ln1174">                        monster_at(pos())-&gt;name(DESC_A));</a>
<a name="ln1175"> </a>
<a name="ln1176">            prompt += &quot;. Continue anyway?&quot;;</a>
<a name="ln1177"> </a>
<a name="ln1178">            if (!yesno(prompt.c_str(), false, 'n'))</a>
<a name="ln1179">            {</a>
<a name="ln1180">                canned_msg(MSG_OK);</a>
<a name="ln1181">                beam_cancelled = true;</a>
<a name="ln1182">                finish_beam();</a>
<a name="ln1183">                return;</a>
<a name="ln1184">            }</a>
<a name="ln1185"> </a>
<a name="ln1186">            // Well, we warned them.</a>
<a name="ln1187">        }</a>
<a name="ln1188"> </a>
<a name="ln1189">        // digging is taken care of in affect_cell</a>
<a name="ln1190">        if (feat_is_solid(feat) &amp;&amp; !can_affect_wall(pos())</a>
<a name="ln1191">                                                    &amp;&amp; flavour != BEAM_DIGGING)</a>
<a name="ln1192">        {</a>
<a name="ln1193">            if (is_bouncy(feat))</a>
<a name="ln1194">            {</a>
<a name="ln1195">                bounce();</a>
<a name="ln1196">                // see comment in bounce(); the beam will be cancelled if this</a>
<a name="ln1197">                // is a tracer and showing the bounce would be an info leak.</a>
<a name="ln1198">                // In that case, we have to break early to avoid adding this</a>
<a name="ln1199">                // square to path_taken twice, which would make it look like a</a>
<a name="ln1200">                // a bounce ANYWAY.</a>
<a name="ln1201">                if (range_used() &gt; range)</a>
<a name="ln1202">                    break;</a>
<a name="ln1203">            }</a>
<a name="ln1204">            else</a>
<a name="ln1205">            {</a>
<a name="ln1206">                // Regress for explosions: blow up in an open grid (if regressing</a>
<a name="ln1207">                // makes any sense). Also regress when dropping items.</a>
<a name="ln1208">                if (pos() != source &amp;&amp; need_regress())</a>
<a name="ln1209">                {</a>
<a name="ln1210">                    do</a>
<a name="ln1211">                    {</a>
<a name="ln1212">                        ray.regress();</a>
<a name="ln1213">                    }</a>
<a name="ln1214">                    while (ray.pos() != source &amp;&amp; cell_is_solid(ray.pos()));</a>
<a name="ln1215"> </a>
<a name="ln1216">                    // target is where the explosion is centered, so update it.</a>
<a name="ln1217">                    if (is_explosion &amp;&amp; !is_tracer)</a>
<a name="ln1218">                        target = ray.pos();</a>
<a name="ln1219">                }</a>
<a name="ln1220">                break;</a>
<a name="ln1221">            }</a>
<a name="ln1222">        }</a>
<a name="ln1223"> </a>
<a name="ln1224">        path_taken.push_back(pos());</a>
<a name="ln1225"> </a>
<a name="ln1226">        if (!affects_nothing)</a>
<a name="ln1227">            affect_cell();</a>
<a name="ln1228"> </a>
<a name="ln1229">        if (range_used() &gt; range)</a>
<a name="ln1230">            break;</a>
<a name="ln1231"> </a>
<a name="ln1232">        if (beam_cancelled)</a>
<a name="ln1233">            return;</a>
<a name="ln1234"> </a>
<a name="ln1235">        // Weapons of returning should find an inverse ray</a>
<a name="ln1236">        // through find_ray and setup_retrace, but they didn't</a>
<a name="ln1237">        // always in the past, and we don't want to crash</a>
<a name="ln1238">        // if they accidentally pass through a corner.</a>
<a name="ln1239">        // Dig tracers continue through unseen cells.</a>
<a name="ln1240">        ASSERT(!cell_is_solid(pos())</a>
<a name="ln1241">               || is_tracer &amp;&amp; can_affect_wall(pos(), true)</a>
<a name="ln1242">               || affects_nothing); // returning weapons</a>
<a name="ln1243"> </a>
<a name="ln1244">        const bool was_seen = seen;</a>
<a name="ln1245">        if (!was_seen &amp;&amp; range &gt; 0 &amp;&amp; visible() &amp;&amp; you.see_cell(pos()))</a>
<a name="ln1246">            seen = true;</a>
<a name="ln1247"> </a>
<a name="ln1248">        if (flavour != BEAM_VISUAL &amp;&amp; !was_seen &amp;&amp; seen &amp;&amp; !is_tracer)</a>
<a name="ln1249">        {</a>
<a name="ln1250">            mprf(&quot;%s appears from out of your range of vision.&quot;,</a>
<a name="ln1251">                 article_a(name, false).c_str());</a>
<a name="ln1252">        }</a>
<a name="ln1253"> </a>
<a name="ln1254">        // Reset chaos beams so that it won't be considered an invisible</a>
<a name="ln1255">        // enchantment beam for the purposes of animation.</a>
<a name="ln1256">        if (real_flavour == BEAM_CHAOS)</a>
<a name="ln1257">            flavour = real_flavour;</a>
<a name="ln1258"> </a>
<a name="ln1259">        // Actually draw the beam/missile/whatever, if the player can see</a>
<a name="ln1260">        // the cell.</a>
<a name="ln1261">        if (animate)</a>
<a name="ln1262">            draw(pos());</a>
<a name="ln1263"> </a>
<a name="ln1264">        if (pos() == target)</a>
<a name="ln1265">        {</a>
<a name="ln1266">            passed_target = true;</a>
<a name="ln1267">            if (stop_at_target())</a>
<a name="ln1268">                break;</a>
<a name="ln1269">        }</a>
<a name="ln1270"> </a>
<a name="ln1271">        noise_generated = false;</a>
<a name="ln1272"> </a>
<a name="ln1273">        ray.advance();</a>
<a name="ln1274">    }</a>
<a name="ln1275"> </a>
<a name="ln1276">    if (!map_bounds(pos()))</a>
<a name="ln1277">    {</a>
<a name="ln1278">        ASSERT(!aimed_at_spot);</a>
<a name="ln1279"> </a>
<a name="ln1280">        int tries = max(GXM, GYM);</a>
<a name="ln1281">        while (!map_bounds(ray.pos()) &amp;&amp; tries-- &gt; 0)</a>
<a name="ln1282">            ray.regress();</a>
<a name="ln1283"> </a>
<a name="ln1284">        // Something bizarre happening if we can't get back onto the map.</a>
<a name="ln1285">        ASSERT(map_bounds(pos()));</a>
<a name="ln1286">    }</a>
<a name="ln1287"> </a>
<a name="ln1288">    // The beam has terminated.</a>
<a name="ln1289">    if (!affects_nothing)</a>
<a name="ln1290">        affect_endpoint();</a>
<a name="ln1291"> </a>
<a name="ln1292">    // Tracers need nothing further.</a>
<a name="ln1293">    if (is_tracer || affects_nothing)</a>
<a name="ln1294">        return;</a>
<a name="ln1295"> </a>
<a name="ln1296">    // Canned msg for enchantments that affected no-one, but only if the</a>
<a name="ln1297">    // enchantment is yours (and it wasn't a chaos beam, since with chaos</a>
<a name="ln1298">    // enchantments are entirely random, and if it randomly attempts</a>
<a name="ln1299">    // something which ends up having no obvious effect then the player</a>
<a name="ln1300">    // isn't going to realise it).</a>
<a name="ln1301">    if (!msg_generated &amp;&amp; !obvious_effect &amp;&amp; is_enchantment()</a>
<a name="ln1302">        &amp;&amp; real_flavour != BEAM_CHAOS</a>
<a name="ln1303">        &amp;&amp; YOU_KILL(thrower))</a>
<a name="ln1304">    {</a>
<a name="ln1305">        canned_msg(MSG_NOTHING_HAPPENS);</a>
<a name="ln1306">    }</a>
<a name="ln1307"> </a>
<a name="ln1308">    // Reactions if a monster zapped the beam.</a>
<a name="ln1309">    if (monster_by_mid(source_id))</a>
<a name="ln1310">    {</a>
<a name="ln1311">        if (foe_info.hurt == 0 &amp;&amp; friend_info.hurt &gt; 0)</a>
<a name="ln1312">            xom_is_stimulated(100);</a>
<a name="ln1313">        else if (foe_info.helped &gt; 0 &amp;&amp; friend_info.helped == 0)</a>
<a name="ln1314">            xom_is_stimulated(100);</a>
<a name="ln1315"> </a>
<a name="ln1316">        // Allow friendlies to react to projectiles, except when in</a>
<a name="ln1317">        // sanctuary when pet_target can only be explicitly changed by</a>
<a name="ln1318">        // the player.</a>
<a name="ln1319">        const monster* mon = monster_by_mid(source_id);</a>
<a name="ln1320">        if (foe_info.hurt &gt; 0 &amp;&amp; !mon-&gt;wont_attack() &amp;&amp; !crawl_state.game_is_arena()</a>
<a name="ln1321">            &amp;&amp; you.pet_target == MHITNOT &amp;&amp; env.sanctuary_time &lt;= 0)</a>
<a name="ln1322">        {</a>
<a name="ln1323">            you.pet_target = mon-&gt;mindex();</a>
<a name="ln1324">        }</a>
<a name="ln1325">    }</a>
<a name="ln1326">}</a>
<a name="ln1327"> </a>
<a name="ln1328">// Returns damage taken by a monster from a &quot;flavoured&quot; (fire, ice, etc.)</a>
<a name="ln1329">// attack -- damage from clouds and branded weapons handled elsewhere.</a>
<a name="ln1330">int mons_adjust_flavoured(monster* mons, bolt &amp;pbolt, int hurted,</a>
<a name="ln1331">                          bool doFlavouredEffects)</a>
<a name="ln1332">{</a>
<a name="ln1333">    // If we're not doing flavoured effects, must be preliminary</a>
<a name="ln1334">    // damage check only.</a>
<a name="ln1335">    // Do not print messages or apply any side effects!</a>
<a name="ln1336">    int original = hurted;</a>
<a name="ln1337"> </a>
<a name="ln1338">    switch (pbolt.flavour)</a>
<a name="ln1339">    {</a>
<a name="ln1340">    case BEAM_FIRE:</a>
<a name="ln1341">    case BEAM_STEAM:</a>
<a name="ln1342">        hurted = resist_adjust_damage(mons, pbolt.flavour, hurted);</a>
<a name="ln1343"> </a>
<a name="ln1344">        if (!hurted)</a>
<a name="ln1345">        {</a>
<a name="ln1346">            if (original &gt; 0 &amp;&amp; doFlavouredEffects)</a>
<a name="ln1347">                simple_monster_message(*mons, &quot; completely resists.&quot;);</a>
<a name="ln1348">        }</a>
<a name="ln1349">        else if (original &gt; hurted)</a>
<a name="ln1350">        {</a>
<a name="ln1351">            if (doFlavouredEffects)</a>
<a name="ln1352">                simple_monster_message(*mons, &quot; resists.&quot;);</a>
<a name="ln1353">        }</a>
<a name="ln1354">        else if (original &lt; hurted &amp;&amp; doFlavouredEffects)</a>
<a name="ln1355">        {</a>
<a name="ln1356">            if (mons-&gt;is_icy())</a>
<a name="ln1357">                simple_monster_message(*mons, &quot; melts!&quot;);</a>
<a name="ln1358">            else if (mons_species(mons-&gt;type) == MONS_BUSH</a>
<a name="ln1359">                     &amp;&amp; mons-&gt;res_fire() &lt; 0)</a>
<a name="ln1360">            {</a>
<a name="ln1361">                simple_monster_message(*mons, &quot; is on fire!&quot;);</a>
<a name="ln1362">            }</a>
<a name="ln1363">            else if (pbolt.flavour == BEAM_FIRE)</a>
<a name="ln1364">                simple_monster_message(*mons, &quot; is burned terribly!&quot;);</a>
<a name="ln1365">            else</a>
<a name="ln1366">                simple_monster_message(*mons, &quot; is scalded terribly!&quot;);</a>
<a name="ln1367">        }</a>
<a name="ln1368">        break;</a>
<a name="ln1369"> </a>
<a name="ln1370">    case BEAM_WATER:</a>
<a name="ln1371">        hurted = resist_adjust_damage(mons, pbolt.flavour, hurted);</a>
<a name="ln1372">        if (hurted &gt; original &amp;&amp; doFlavouredEffects)</a>
<a name="ln1373">            simple_monster_message(*mons, &quot; is doused terribly!&quot;);</a>
<a name="ln1374">        break;</a>
<a name="ln1375"> </a>
<a name="ln1376">    case BEAM_COLD:</a>
<a name="ln1377">        hurted = resist_adjust_damage(mons, pbolt.flavour, hurted);</a>
<a name="ln1378">        if (!hurted)</a>
<a name="ln1379">        {</a>
<a name="ln1380">            if (original &gt; 0 &amp;&amp; doFlavouredEffects)</a>
<a name="ln1381">                simple_monster_message(*mons, &quot; completely resists.&quot;);</a>
<a name="ln1382">        }</a>
<a name="ln1383">        else if (original &gt; hurted)</a>
<a name="ln1384">        {</a>
<a name="ln1385">            if (doFlavouredEffects)</a>
<a name="ln1386">                simple_monster_message(*mons, &quot; resists.&quot;);</a>
<a name="ln1387">        }</a>
<a name="ln1388">        else if (original &lt; hurted)</a>
<a name="ln1389">        {</a>
<a name="ln1390">            if (doFlavouredEffects)</a>
<a name="ln1391">                simple_monster_message(*mons, &quot; is frozen!&quot;);</a>
<a name="ln1392">        }</a>
<a name="ln1393">        break;</a>
<a name="ln1394"> </a>
<a name="ln1395">    case BEAM_ELECTRICITY:</a>
<a name="ln1396">        hurted = resist_adjust_damage(mons, pbolt.flavour, hurted);</a>
<a name="ln1397">        if (!hurted)</a>
<a name="ln1398">        {</a>
<a name="ln1399">            if (original &gt; 0 &amp;&amp; doFlavouredEffects)</a>
<a name="ln1400">                simple_monster_message(*mons, &quot; completely resists.&quot;);</a>
<a name="ln1401">        }</a>
<a name="ln1402">        else if (original &gt; hurted)</a>
<a name="ln1403">        {</a>
<a name="ln1404">            if (doFlavouredEffects)</a>
<a name="ln1405">                simple_monster_message(*mons, &quot; resists.&quot;);</a>
<a name="ln1406">        }</a>
<a name="ln1407">        else if (original &lt; hurted)</a>
<a name="ln1408">        {</a>
<a name="ln1409">            if (doFlavouredEffects)</a>
<a name="ln1410">                simple_monster_message(*mons, &quot; is electrocuted!&quot;);</a>
<a name="ln1411">        }</a>
<a name="ln1412">        break;</a>
<a name="ln1413"> </a>
<a name="ln1414">    case BEAM_ACID:</a>
<a name="ln1415">    {</a>
<a name="ln1416">        hurted = resist_adjust_damage(mons, pbolt.flavour, hurted);</a>
<a name="ln1417">        if (!hurted)</a>
<a name="ln1418">        {</a>
<a name="ln1419">            if (original &gt; 0 &amp;&amp; doFlavouredEffects)</a>
<a name="ln1420">                simple_monster_message(*mons, &quot; completely resists.&quot;);</a>
<a name="ln1421">        }</a>
<a name="ln1422">        else if (mons-&gt;res_acid() &lt;= 0 &amp;&amp; doFlavouredEffects)</a>
<a name="ln1423">            mons-&gt;splash_with_acid(pbolt.agent());</a>
<a name="ln1424">        break;</a>
<a name="ln1425">    }</a>
<a name="ln1426"> </a>
<a name="ln1427">    case BEAM_POISON:</a>
<a name="ln1428">    {</a>
<a name="ln1429">        hurted = resist_adjust_damage(mons, pbolt.flavour, hurted);</a>
<a name="ln1430"> </a>
<a name="ln1431">        if (!hurted &amp;&amp; doFlavouredEffects &amp;&amp; original &gt; 0)</a>
<a name="ln1432">            simple_monster_message(*mons, &quot; completely resists.&quot;);</a>
<a name="ln1433">        else if (doFlavouredEffects &amp;&amp; !one_chance_in(3))</a>
<a name="ln1434">            poison_monster(mons, pbolt.agent());</a>
<a name="ln1435"> </a>
<a name="ln1436">        break;</a>
<a name="ln1437">    }</a>
<a name="ln1438"> </a>
<a name="ln1439">    case BEAM_POISON_ARROW:</a>
<a name="ln1440">    {</a>
<a name="ln1441">        hurted = resist_adjust_damage(mons, pbolt.flavour, hurted);</a>
<a name="ln1442">        const int stacks = pbolt.origin_spell == SPELL_STING ? 1 : 4;</a>
<a name="ln1443">        if (hurted &lt; original)</a>
<a name="ln1444">        {</a>
<a name="ln1445">            if (doFlavouredEffects)</a>
<a name="ln1446">            {</a>
<a name="ln1447">                simple_monster_message(*mons, &quot; partially resists.&quot;);</a>
<a name="ln1448">                poison_monster(mons, pbolt.agent(), div_rand_round(stacks, 2),</a>
<a name="ln1449">                               true);</a>
<a name="ln1450">            }</a>
<a name="ln1451">        }</a>
<a name="ln1452">        else if (doFlavouredEffects)</a>
<a name="ln1453">            poison_monster(mons, pbolt.agent(), stacks , true);</a>
<a name="ln1454"> </a>
<a name="ln1455">        break;</a>
<a name="ln1456">    }</a>
<a name="ln1457"> </a>
<a name="ln1458">    case BEAM_NEG:</a>
<a name="ln1459">        if (mons-&gt;res_negative_energy() == 3)</a>
<a name="ln1460">        {</a>
<a name="ln1461">            if (doFlavouredEffects)</a>
<a name="ln1462">                simple_monster_message(*mons, &quot; completely resists.&quot;);</a>
<a name="ln1463"> </a>
<a name="ln1464">            hurted = 0;</a>
<a name="ln1465">        }</a>
<a name="ln1466">        else</a>
<a name="ln1467">        {</a>
<a name="ln1468">            hurted = resist_adjust_damage(mons, pbolt.flavour, hurted);</a>
<a name="ln1469"> </a>
<a name="ln1470">            // Early out if no side effects.</a>
<a name="ln1471">            if (!doFlavouredEffects)</a>
<a name="ln1472">                return hurted;</a>
<a name="ln1473"> </a>
<a name="ln1474">            if (original &gt; hurted)</a>
<a name="ln1475">                simple_monster_message(*mons, &quot; resists.&quot;);</a>
<a name="ln1476">            else if (original &lt; hurted)</a>
<a name="ln1477">                simple_monster_message(*mons, &quot; is drained terribly!&quot;);</a>
<a name="ln1478"> </a>
<a name="ln1479">            if (mons-&gt;observable())</a>
<a name="ln1480">                pbolt.obvious_effect = true;</a>
<a name="ln1481"> </a>
<a name="ln1482">            mons-&gt;drain_exp(pbolt.agent());</a>
<a name="ln1483"> </a>
<a name="ln1484">            if (YOU_KILL(pbolt.thrower))</a>
<a name="ln1485">                did_god_conduct(DID_EVIL, 2, pbolt.god_cares());</a>
<a name="ln1486">        }</a>
<a name="ln1487">        break;</a>
<a name="ln1488"> </a>
<a name="ln1489">    case BEAM_MIASMA:</a>
<a name="ln1490">        if (mons-&gt;res_rotting())</a>
<a name="ln1491">        {</a>
<a name="ln1492">            if (doFlavouredEffects)</a>
<a name="ln1493">                simple_monster_message(*mons, &quot; completely resists.&quot;);</a>
<a name="ln1494"> </a>
<a name="ln1495">            hurted = 0;</a>
<a name="ln1496">        }</a>
<a name="ln1497">        else</a>
<a name="ln1498">        {</a>
<a name="ln1499">            // Early out for tracer/no side effects.</a>
<a name="ln1500">            if (!doFlavouredEffects)</a>
<a name="ln1501">                return hurted;</a>
<a name="ln1502"> </a>
<a name="ln1503">            miasma_monster(mons, pbolt.agent());</a>
<a name="ln1504"> </a>
<a name="ln1505">            if (YOU_KILL(pbolt.thrower))</a>
<a name="ln1506">                did_god_conduct(DID_UNCLEAN, 2, pbolt.god_cares());</a>
<a name="ln1507">        }</a>
<a name="ln1508">        break;</a>
<a name="ln1509"> </a>
<a name="ln1510">    case BEAM_HOLY:</a>
<a name="ln1511">    {</a>
<a name="ln1512">        hurted = resist_adjust_damage(mons, pbolt.flavour, hurted);</a>
<a name="ln1513">        if (doFlavouredEffects &amp;&amp; original &gt; 0</a>
<a name="ln1514">            &amp;&amp; (!hurted || hurted != original))</a>
<a name="ln1515">        {</a>
<a name="ln1516">            simple_monster_message(*mons, hurted == 0 ? &quot; completely resists.&quot; :</a>
<a name="ln1517">                                    hurted &lt; original ? &quot; resists.&quot; :</a>
<a name="ln1518">                                    &quot; writhes in agony!&quot;);</a>
<a name="ln1519"> </a>
<a name="ln1520">        }</a>
<a name="ln1521">        break;</a>
<a name="ln1522">    }</a>
<a name="ln1523"> </a>
<a name="ln1524">    case BEAM_ICE:</a>
<a name="ln1525">        // ice - 40% of damage is cold, other 60% is impact and</a>
<a name="ln1526">        // can't be resisted (except by AC, of course)</a>
<a name="ln1527">        hurted = resist_adjust_damage(mons, pbolt.flavour, hurted);</a>
<a name="ln1528">        if (hurted &lt; original)</a>
<a name="ln1529">        {</a>
<a name="ln1530">            if (doFlavouredEffects)</a>
<a name="ln1531">                simple_monster_message(*mons, &quot; partially resists.&quot;);</a>
<a name="ln1532">        }</a>
<a name="ln1533">        else if (hurted &gt; original)</a>
<a name="ln1534">        {</a>
<a name="ln1535">            if (doFlavouredEffects)</a>
<a name="ln1536">                simple_monster_message(*mons, &quot; is frozen!&quot;);</a>
<a name="ln1537">        }</a>
<a name="ln1538">        break;</a>
<a name="ln1539"> </a>
<a name="ln1540">    case BEAM_LAVA:</a>
<a name="ln1541">        hurted = resist_adjust_damage(mons, pbolt.flavour, hurted);</a>
<a name="ln1542"> </a>
<a name="ln1543">        if (hurted &lt; original)</a>
<a name="ln1544">        {</a>
<a name="ln1545">            if (doFlavouredEffects)</a>
<a name="ln1546">                simple_monster_message(*mons, &quot; partially resists.&quot;);</a>
<a name="ln1547">        }</a>
<a name="ln1548">        else if (hurted &gt; original)</a>
<a name="ln1549">        {</a>
<a name="ln1550">            if (mons-&gt;is_icy())</a>
<a name="ln1551">            {</a>
<a name="ln1552">                if (doFlavouredEffects)</a>
<a name="ln1553">                    simple_monster_message(*mons, &quot; melts!&quot;);</a>
<a name="ln1554">            }</a>
<a name="ln1555">            else</a>
<a name="ln1556">            {</a>
<a name="ln1557">                if (doFlavouredEffects)</a>
<a name="ln1558">                    simple_monster_message(*mons, &quot; is burned terribly!&quot;);</a>
<a name="ln1559">            }</a>
<a name="ln1560">        }</a>
<a name="ln1561">        break;</a>
<a name="ln1562"> </a>
<a name="ln1563">    case BEAM_DAMNATION:</a>
<a name="ln1564">        if (mons-&gt;res_damnation())</a>
<a name="ln1565">        {</a>
<a name="ln1566">            if (doFlavouredEffects)</a>
<a name="ln1567">                simple_monster_message(*mons, &quot; completely resists.&quot;);</a>
<a name="ln1568"> </a>
<a name="ln1569">            hurted = 0;</a>
<a name="ln1570">        }</a>
<a name="ln1571">        break;</a>
<a name="ln1572"> </a>
<a name="ln1573">    case BEAM_MEPHITIC:</a>
<a name="ln1574">        if (mons-&gt;res_poison() &gt; 0)</a>
<a name="ln1575">        {</a>
<a name="ln1576">            if (original &gt; 0 &amp;&amp; doFlavouredEffects)</a>
<a name="ln1577">                simple_monster_message(*mons, &quot; completely resists.&quot;);</a>
<a name="ln1578"> </a>
<a name="ln1579">            hurted = 0;</a>
<a name="ln1580">        }</a>
<a name="ln1581">        break;</a>
<a name="ln1582"> </a>
<a name="ln1583">    case BEAM_SPORE:</a>
<a name="ln1584">        if (mons-&gt;type == MONS_BALLISTOMYCETE)</a>
<a name="ln1585">            hurted = 0;</a>
<a name="ln1586">        break;</a>
<a name="ln1587"> </a>
<a name="ln1588">    case BEAM_AIR:</a>
<a name="ln1589">        if (mons-&gt;airborne())</a>
<a name="ln1590">            hurted += hurted / 2;</a>
<a name="ln1591">        if (original &lt; hurted)</a>
<a name="ln1592">        {</a>
<a name="ln1593">            if (doFlavouredEffects)</a>
<a name="ln1594">                simple_monster_message(*mons, &quot; gets badly buffeted.&quot;);</a>
<a name="ln1595">        }</a>
<a name="ln1596">        break;</a>
<a name="ln1597"> </a>
<a name="ln1598">    case BEAM_ENSNARE:</a>
<a name="ln1599">        if (doFlavouredEffects)</a>
<a name="ln1600">            ensnare(mons);</a>
<a name="ln1601">        break;</a>
<a name="ln1602"> </a>
<a name="ln1603">    default:</a>
<a name="ln1604">        break;</a>
<a name="ln1605">    }</a>
<a name="ln1606"> </a>
<a name="ln1607">    if (doFlavouredEffects)</a>
<a name="ln1608">    {</a>
<a name="ln1609">        const int burn_power = (pbolt.is_explosion) ? 5 :</a>
<a name="ln1610">                               (pbolt.pierce)       ? 3</a>
<a name="ln1611">                                                    : 2;</a>
<a name="ln1612">        mons-&gt;expose_to_element(pbolt.flavour, burn_power, false);</a>
<a name="ln1613">    }</a>
<a name="ln1614"> </a>
<a name="ln1615">    return hurted;</a>
<a name="ln1616">}</a>
<a name="ln1617"> </a>
<a name="ln1618">static bool _monster_resists_mass_enchantment(monster* mons,</a>
<a name="ln1619">                                              enchant_type wh_enchant,</a>
<a name="ln1620">                                              int pow,</a>
<a name="ln1621">                                              bool* did_msg)</a>
<a name="ln1622">{</a>
<a name="ln1623">    // Assuming that the only mass charm is control undead.</a>
<a name="ln1624">    if (wh_enchant == ENCH_CHARM)</a>
<a name="ln1625">    {</a>
<a name="ln1626">        if (you.get_mutation_level(MUT_NO_LOVE))</a>
<a name="ln1627">            return true;</a>
<a name="ln1628"> </a>
<a name="ln1629">        if (mons-&gt;friendly())</a>
<a name="ln1630">            return true;</a>
<a name="ln1631"> </a>
<a name="ln1632">        if (!(mons-&gt;holiness() &amp; MH_UNDEAD))</a>
<a name="ln1633">            return true;</a>
<a name="ln1634"> </a>
<a name="ln1635">        int res_margin = mons-&gt;check_res_magic(pow);</a>
<a name="ln1636">        if (res_margin &gt; 0)</a>
<a name="ln1637">        {</a>
<a name="ln1638">            if (simple_monster_message(*mons,</a>
<a name="ln1639">                    mons-&gt;resist_margin_phrase(res_margin).c_str()))</a>
<a name="ln1640">            {</a>
<a name="ln1641">                *did_msg = true;</a>
<a name="ln1642">            }</a>
<a name="ln1643">            return true;</a>
<a name="ln1644">        }</a>
<a name="ln1645">    }</a>
<a name="ln1646">    else if (wh_enchant == ENCH_INSANE</a>
<a name="ln1647">             || mons-&gt;holiness() &amp; MH_NATURAL)</a>
<a name="ln1648">    {</a>
<a name="ln1649">        if (wh_enchant == ENCH_FEAR</a>
<a name="ln1650">            &amp;&amp; mons-&gt;friendly())</a>
<a name="ln1651">        {</a>
<a name="ln1652">            return true;</a>
<a name="ln1653">        }</a>
<a name="ln1654"> </a>
<a name="ln1655">        if (wh_enchant == ENCH_INSANE</a>
<a name="ln1656">            &amp;&amp; !mons-&gt;can_go_frenzy())</a>
<a name="ln1657">        {</a>
<a name="ln1658">            return true;</a>
<a name="ln1659">        }</a>
<a name="ln1660"> </a>
<a name="ln1661">        int res_margin = mons-&gt;check_res_magic(pow);</a>
<a name="ln1662">        if (res_margin &gt; 0)</a>
<a name="ln1663">        {</a>
<a name="ln1664">            if (simple_monster_message(*mons,</a>
<a name="ln1665">                    mons-&gt;resist_margin_phrase(res_margin).c_str()))</a>
<a name="ln1666">            {</a>
<a name="ln1667">                *did_msg = true;</a>
<a name="ln1668">            }</a>
<a name="ln1669">            return true;</a>
<a name="ln1670">        }</a>
<a name="ln1671">    }</a>
<a name="ln1672">    // Mass enchantments around lots of plants/fungi shouldn't cause a flood</a>
<a name="ln1673">    // of &quot;is unaffected&quot; messages. --Eino</a>
<a name="ln1674">    else if (mons_is_firewood(*mons))</a>
<a name="ln1675">        return true;</a>
<a name="ln1676">    else  // trying to enchant an unnatural creature doesn't work</a>
<a name="ln1677">    {</a>
<a name="ln1678">        if (simple_monster_message(*mons, &quot; is unaffected.&quot;))</a>
<a name="ln1679">            *did_msg = true;</a>
<a name="ln1680">        return true;</a>
<a name="ln1681">    }</a>
<a name="ln1682"> </a>
<a name="ln1683">    // If monster was affected, then there was a message.</a>
<a name="ln1684">    *did_msg = true;</a>
<a name="ln1685">    return false;</a>
<a name="ln1686">}</a>
<a name="ln1687"> </a>
<a name="ln1688">// Enchants all monsters in player's sight.</a>
<a name="ln1689">// If m_succumbed is non-nullptr, will be set to the number of monsters that</a>
<a name="ln1690">// were enchanted. If m_attempted is not nullptr, will be set to the number of</a>
<a name="ln1691">// monsters that we tried to enchant.</a>
<a name="ln1692">spret mass_enchantment(enchant_type wh_enchant, int pow, bool fail)</a>
<a name="ln1693">{</a>
<a name="ln1694">    fail_check();</a>
<a name="ln1695">    bool did_msg = false;</a>
<a name="ln1696"> </a>
<a name="ln1697">    // Give mass enchantments a power multiplier.</a>
<a name="ln1698">    pow *= 3;</a>
<a name="ln1699">    pow /= 2;</a>
<a name="ln1700"> </a>
<a name="ln1701">    pow = min(pow, 200);</a>
<a name="ln1702"> </a>
<a name="ln1703">    for (monster_iterator mi; mi; ++mi)</a>
<a name="ln1704">    {</a>
<a name="ln1705">        if (!you.see_cell_no_trans(mi-&gt;pos()))</a>
<a name="ln1706">            continue;</a>
<a name="ln1707"> </a>
<a name="ln1708">        if (mi-&gt;has_ench(wh_enchant))</a>
<a name="ln1709">            continue;</a>
<a name="ln1710"> </a>
<a name="ln1711">        bool resisted = _monster_resists_mass_enchantment(*mi, wh_enchant,</a>
<a name="ln1712">                                                          pow, &amp;did_msg);</a>
<a name="ln1713"> </a>
<a name="ln1714">        if (resisted)</a>
<a name="ln1715">            continue;</a>
<a name="ln1716"> </a>
<a name="ln1717">        if ((wh_enchant == ENCH_INSANE &amp;&amp; mi-&gt;go_frenzy(&amp;you))</a>
<a name="ln1718">            || (wh_enchant == ENCH_CHARM &amp;&amp; mi-&gt;has_ench(ENCH_HEXED))</a>
<a name="ln1719">            || (wh_enchant != ENCH_INSANE</a>
<a name="ln1720">                &amp;&amp; mi-&gt;add_ench(mon_enchant(wh_enchant, 0, &amp;you))))</a>
<a name="ln1721">        {</a>
<a name="ln1722">            // Do messaging.</a>
<a name="ln1723">            const char* msg;</a>
<a name="ln1724">            switch (wh_enchant)</a>
<a name="ln1725">            {</a>
<a name="ln1726">            case ENCH_FEAR:      msg = &quot; looks frightened!&quot;;      break;</a>
<a name="ln1727">            case ENCH_CHARM:     msg = &quot; submits to your will.&quot;;  break;</a>
<a name="ln1728">            default:             msg = nullptr;                   break;</a>
<a name="ln1729">            }</a>
<a name="ln1730">            if (msg &amp;&amp; simple_monster_message(**mi, msg))</a>
<a name="ln1731">                did_msg = true;</a>
<a name="ln1732"> </a>
<a name="ln1733">            // Reassert control over hexed undead.</a>
<a name="ln1734">            if (wh_enchant == ENCH_CHARM &amp;&amp; mi-&gt;has_ench(ENCH_HEXED))</a>
<a name="ln1735">                mi-&gt;del_ench(ENCH_HEXED);</a>
<a name="ln1736"> </a>
<a name="ln1737">            // Extra check for fear (monster needs to reevaluate behaviour).</a>
<a name="ln1738">            if (wh_enchant == ENCH_FEAR)</a>
<a name="ln1739">                behaviour_event(*mi, ME_SCARE, &amp;you);</a>
<a name="ln1740">        }</a>
<a name="ln1741">    }</a>
<a name="ln1742"> </a>
<a name="ln1743">    if (!did_msg)</a>
<a name="ln1744">        canned_msg(MSG_NOTHING_HAPPENS);</a>
<a name="ln1745"> </a>
<a name="ln1746">    if (wh_enchant == ENCH_INSANE)</a>
<a name="ln1747">        did_god_conduct(DID_HASTY, 8, true);</a>
<a name="ln1748"> </a>
<a name="ln1749">    return spret::success;</a>
<a name="ln1750">}</a>
<a name="ln1751"> </a>
<a name="ln1752">void bolt::apply_bolt_paralysis(monster* mons)</a>
<a name="ln1753">{</a>
<a name="ln1754">    if (mons-&gt;paralysed() || mons-&gt;stasis())</a>
<a name="ln1755">        return;</a>
<a name="ln1756">    // asleep monsters can still be paralysed (and will be always woken by</a>
<a name="ln1757">    // trying to resist); the message might seem wrong but paralysis is</a>
<a name="ln1758">    // always visible.</a>
<a name="ln1759">    if (!mons_is_immotile(*mons)</a>
<a name="ln1760">        &amp;&amp; simple_monster_message(*mons, &quot; suddenly stops moving!&quot;))</a>
<a name="ln1761">    {</a>
<a name="ln1762">        mons-&gt;stop_directly_constricting_all();</a>
<a name="ln1763">        obvious_effect = true;</a>
<a name="ln1764">    }</a>
<a name="ln1765"> </a>
<a name="ln1766">    mons-&gt;add_ench(mon_enchant(ENCH_PARALYSIS, 0, agent(),</a>
<a name="ln1767">                               _ench_pow_to_dur(ench_power)));</a>
<a name="ln1768">}</a>
<a name="ln1769"> </a>
<a name="ln1770">// Petrification works in two stages. First the monster is slowed down in</a>
<a name="ln1771">// all of its actions, and when that times out it remains properly petrified</a>
<a name="ln1772">// (no movement or actions). The second part is similar to paralysis,</a>
<a name="ln1773">// except that insubstantial monsters can't be affected and damage is</a>
<a name="ln1774">// drastically reduced.</a>
<a name="ln1775">void bolt::apply_bolt_petrify(monster* mons)</a>
<a name="ln1776">{</a>
<a name="ln1777">    if (mons-&gt;petrified())</a>
<a name="ln1778">        return;</a>
<a name="ln1779"> </a>
<a name="ln1780">    if (mons-&gt;petrifying())</a>
<a name="ln1781">    {</a>
<a name="ln1782">        // If the petrifying is not yet finished, we can force it to happen</a>
<a name="ln1783">        // right away by casting again. Otherwise, the spell has no further</a>
<a name="ln1784">        // effect.</a>
<a name="ln1785">        mons-&gt;del_ench(ENCH_PETRIFYING, true, false);</a>
<a name="ln1786">        // del_ench() would do it, but let's call it ourselves for proper agent</a>
<a name="ln1787">        // blaming and messaging.</a>
<a name="ln1788">        if (mons-&gt;fully_petrify(agent()))</a>
<a name="ln1789">            obvious_effect = true;</a>
<a name="ln1790">    }</a>
<a name="ln1791">    else if (mons-&gt;add_ench(mon_enchant(ENCH_PETRIFYING, 0, agent())))</a>
<a name="ln1792">    {</a>
<a name="ln1793">        if (!mons_is_immotile(*mons)</a>
<a name="ln1794">            &amp;&amp; simple_monster_message(*mons, &quot; is moving more slowly.&quot;))</a>
<a name="ln1795">        {</a>
<a name="ln1796">            obvious_effect = true;</a>
<a name="ln1797">        }</a>
<a name="ln1798">    }</a>
<a name="ln1799">}</a>
<a name="ln1800"> </a>
<a name="ln1801">static bool _curare_hits_monster(actor *agent, monster* mons, int levels)</a>
<a name="ln1802">{</a>
<a name="ln1803">    if (!mons-&gt;alive())</a>
<a name="ln1804">        return false;</a>
<a name="ln1805"> </a>
<a name="ln1806">    if (mons-&gt;res_poison() &gt; 0)</a>
<a name="ln1807">        return false;</a>
<a name="ln1808"> </a>
<a name="ln1809">    poison_monster(mons, agent, levels, false);</a>
<a name="ln1810"> </a>
<a name="ln1811">    int hurted = 0;</a>
<a name="ln1812"> </a>
<a name="ln1813">    if (!mons-&gt;is_unbreathing())</a>
<a name="ln1814">    {</a>
<a name="ln1815">        hurted = roll_dice(levels, 6);</a>
<a name="ln1816"> </a>
<a name="ln1817">        if (hurted)</a>
<a name="ln1818">        {</a>
<a name="ln1819">            simple_monster_message(*mons, &quot; convulses.&quot;);</a>
<a name="ln1820">            mons-&gt;hurt(agent, hurted, BEAM_POISON);</a>
<a name="ln1821">        }</a>
<a name="ln1822">    }</a>
<a name="ln1823"> </a>
<a name="ln1824">    if (mons-&gt;alive())</a>
<a name="ln1825">    {</a>
<a name="ln1826">        if (!mons-&gt;cannot_move())</a>
<a name="ln1827">        {</a>
<a name="ln1828">            simple_monster_message(*mons, mons-&gt;has_ench(ENCH_SLOW)</a>
<a name="ln1829">                                         ? &quot; seems to be slow for longer.&quot;</a>
<a name="ln1830">                                         : &quot; seems to slow down.&quot;);</a>
<a name="ln1831">        }</a>
<a name="ln1832">        // FIXME: calculate the slow duration more cleanly</a>
<a name="ln1833">        mon_enchant me(ENCH_SLOW, 0, agent);</a>
<a name="ln1834">        levels -= 2;</a>
<a name="ln1835">        while (levels &gt; 0)</a>
<a name="ln1836">        {</a>
<a name="ln1837">            mon_enchant me2(ENCH_SLOW, 0, agent);</a>
<a name="ln1838">            me.set_duration(mons, &amp;me2);</a>
<a name="ln1839">            levels -= 2;</a>
<a name="ln1840">        }</a>
<a name="ln1841">        mons-&gt;add_ench(me);</a>
<a name="ln1842">    }</a>
<a name="ln1843"> </a>
<a name="ln1844">    return hurted &gt; 0;</a>
<a name="ln1845">}</a>
<a name="ln1846"> </a>
<a name="ln1847">// Actually poisons a monster (with message).</a>
<a name="ln1848">bool poison_monster(monster* mons, const actor *who, int levels,</a>
<a name="ln1849">                    bool force, bool verbose)</a>
<a name="ln1850">{</a>
<a name="ln1851">    if (!mons-&gt;alive() || levels &lt;= 0)</a>
<a name="ln1852">        return false;</a>
<a name="ln1853"> </a>
<a name="ln1854">    if (monster_resists_this_poison(*mons, force))</a>
<a name="ln1855">        return false;</a>
<a name="ln1856"> </a>
<a name="ln1857">    const mon_enchant old_pois = mons-&gt;get_ench(ENCH_POISON);</a>
<a name="ln1858">    mons-&gt;add_ench(mon_enchant(ENCH_POISON, levels, who));</a>
<a name="ln1859">    const mon_enchant new_pois = mons-&gt;get_ench(ENCH_POISON);</a>
<a name="ln1860"> </a>
<a name="ln1861">    // Actually do the poisoning. The order is important here.</a>
<a name="ln1862">    if (new_pois.degree &gt; old_pois.degree</a>
<a name="ln1863">        || new_pois.degree &gt;= MAX_ENCH_DEGREE_DEFAULT)</a>
<a name="ln1864">    {</a>
<a name="ln1865">        if (verbose)</a>
<a name="ln1866">        {</a>
<a name="ln1867">            const char* msg;</a>
<a name="ln1868">            if (new_pois.degree &gt;= MAX_ENCH_DEGREE_DEFAULT)</a>
<a name="ln1869">                msg = &quot; looks as sick as possible!&quot;;</a>
<a name="ln1870">            else if (old_pois.degree &gt; 0)</a>
<a name="ln1871">                msg = &quot; looks even sicker.&quot;;</a>
<a name="ln1872">            else</a>
<a name="ln1873">                msg = &quot; is poisoned.&quot;;</a>
<a name="ln1874"> </a>
<a name="ln1875">            simple_monster_message(*mons, msg);</a>
<a name="ln1876">        }</a>
<a name="ln1877">    }</a>
<a name="ln1878"> </a>
<a name="ln1879">    return new_pois.duration &gt; old_pois.duration;</a>
<a name="ln1880">}</a>
<a name="ln1881"> </a>
<a name="ln1882">// Actually poisons, rots, and/or slows a monster with miasma (with</a>
<a name="ln1883">// message).</a>
<a name="ln1884">bool miasma_monster(monster* mons, const actor* who)</a>
<a name="ln1885">{</a>
<a name="ln1886">    if (!mons-&gt;alive())</a>
<a name="ln1887">        return false;</a>
<a name="ln1888"> </a>
<a name="ln1889">    if (mons-&gt;res_rotting())</a>
<a name="ln1890">        return false;</a>
<a name="ln1891"> </a>
<a name="ln1892">    bool success = poison_monster(mons, who);</a>
<a name="ln1893"> </a>
<a name="ln1894">    if (who &amp;&amp; who-&gt;is_player()</a>
<a name="ln1895">        &amp;&amp; is_good_god(you.religion)</a>
<a name="ln1896">        &amp;&amp; !(success &amp;&amp; you_worship(GOD_SHINING_ONE))) // already penalized</a>
<a name="ln1897">    {</a>
<a name="ln1898">        did_god_conduct(DID_EVIL, 5 + random2(3));</a>
<a name="ln1899">    }</a>
<a name="ln1900"> </a>
<a name="ln1901">    if (mons-&gt;max_hit_points &gt; 4 &amp;&amp; coinflip())</a>
<a name="ln1902">    {</a>
<a name="ln1903">        mons-&gt;max_hit_points--;</a>
<a name="ln1904">        mons-&gt;hit_points = min(mons-&gt;max_hit_points, mons-&gt;hit_points);</a>
<a name="ln1905">        success = true;</a>
<a name="ln1906">    }</a>
<a name="ln1907"> </a>
<a name="ln1908">    if (one_chance_in(3))</a>
<a name="ln1909">    {</a>
<a name="ln1910">        bolt beam;</a>
<a name="ln1911">        beam.flavour = BEAM_SLOW;</a>
<a name="ln1912">        beam.apply_enchantment_to_monster(mons);</a>
<a name="ln1913">        success = true;</a>
<a name="ln1914">    }</a>
<a name="ln1915"> </a>
<a name="ln1916">    return success;</a>
<a name="ln1917">}</a>
<a name="ln1918"> </a>
<a name="ln1919">// Actually napalms a monster (with message).</a>
<a name="ln1920">bool napalm_monster(monster* mons, const actor *who, int levels, bool verbose)</a>
<a name="ln1921">{</a>
<a name="ln1922">    if (!mons-&gt;alive())</a>
<a name="ln1923">        return false;</a>
<a name="ln1924"> </a>
<a name="ln1925">    if (mons-&gt;res_sticky_flame() || levels &lt;= 0 || mons-&gt;has_ench(ENCH_WATER_HOLD))</a>
<a name="ln1926">        return false;</a>
<a name="ln1927"> </a>
<a name="ln1928">    const mon_enchant old_flame = mons-&gt;get_ench(ENCH_STICKY_FLAME);</a>
<a name="ln1929">    mons-&gt;add_ench(mon_enchant(ENCH_STICKY_FLAME, levels, who));</a>
<a name="ln1930">    const mon_enchant new_flame = mons-&gt;get_ench(ENCH_STICKY_FLAME);</a>
<a name="ln1931"> </a>
<a name="ln1932">    // Actually do the napalming. The order is important here.</a>
<a name="ln1933">    if (new_flame.degree &gt; old_flame.degree)</a>
<a name="ln1934">    {</a>
<a name="ln1935">        if (verbose)</a>
<a name="ln1936">            simple_monster_message(*mons, &quot; is covered in liquid flames!&quot;);</a>
<a name="ln1937">        if (who)</a>
<a name="ln1938">            behaviour_event(mons, ME_WHACK, who);</a>
<a name="ln1939">    }</a>
<a name="ln1940"> </a>
<a name="ln1941">    return new_flame.degree &gt; old_flame.degree;</a>
<a name="ln1942">}</a>
<a name="ln1943"> </a>
<a name="ln1944">static bool _curare_hits_player(actor* agent, int levels, string name,</a>
<a name="ln1945">                                string source_name)</a>
<a name="ln1946">{</a>
<a name="ln1947">    ASSERT(!crawl_state.game_is_arena());</a>
<a name="ln1948"> </a>
<a name="ln1949">    if (player_res_poison() &gt;= 3</a>
<a name="ln1950">        || player_res_poison() &gt; 0 &amp;&amp; !one_chance_in(3))</a>
<a name="ln1951">    {</a>
<a name="ln1952">        return false;</a>
<a name="ln1953">    }</a>
<a name="ln1954"> </a>
<a name="ln1955">    poison_player(roll_dice(levels, 12) + 1, source_name, name);</a>
<a name="ln1956"> </a>
<a name="ln1957">    int hurted = 0;</a>
<a name="ln1958"> </a>
<a name="ln1959">    if (!you.is_unbreathing())</a>
<a name="ln1960">    {</a>
<a name="ln1961">        hurted = roll_dice(levels, 6);</a>
<a name="ln1962"> </a>
<a name="ln1963">        if (hurted)</a>
<a name="ln1964">        {</a>
<a name="ln1965">            mpr(&quot;You have difficulty breathing.&quot;);</a>
<a name="ln1966">            ouch(hurted, KILLED_BY_CURARE, agent-&gt;mid,</a>
<a name="ln1967">                 &quot;curare-induced apnoea&quot;);</a>
<a name="ln1968">        }</a>
<a name="ln1969">    }</a>
<a name="ln1970"> </a>
<a name="ln1971">    slow_player(10 + random2(levels + random2(3 * levels)));</a>
<a name="ln1972"> </a>
<a name="ln1973">    return hurted &gt; 0;</a>
<a name="ln1974">}</a>
<a name="ln1975"> </a>
<a name="ln1976"> </a>
<a name="ln1977">bool curare_actor(actor* source, actor* target, int levels, string name,</a>
<a name="ln1978">                  string source_name)</a>
<a name="ln1979">{</a>
<a name="ln1980">    if (target-&gt;is_player())</a>
<a name="ln1981">        return _curare_hits_player(source, levels, name, source_name);</a>
<a name="ln1982">    else</a>
<a name="ln1983">        return _curare_hits_monster(source, target-&gt;as_monster(), levels);</a>
<a name="ln1984">}</a>
<a name="ln1985"> </a>
<a name="ln1986">// XXX: This is a terrible place for this, but it at least does go with</a>
<a name="ln1987">// curare_actor().</a>
<a name="ln1988">int silver_damages_victim(actor* victim, int damage, string &amp;dmg_msg)</a>
<a name="ln1989">{</a>
<a name="ln1990">    int ret = 0;</a>
<a name="ln1991">    if (victim-&gt;how_chaotic()</a>
<a name="ln1992">        || victim-&gt;is_player() &amp;&amp; player_is_shapechanged())</a>
<a name="ln1993">    {</a>
<a name="ln1994">        ret = damage * 3 / 4;</a>
<a name="ln1995">    }</a>
<a name="ln1996">    else if (victim-&gt;is_player())</a>
<a name="ln1997">    {</a>
<a name="ln1998">        // For mutation damage, we want to count innate mutations for</a>
<a name="ln1999">        // demonspawn but not other species.</a>
<a name="ln2000">        int multiplier = 5 * you.how_mutated(you.species == SP_DEMONSPAWN, true);</a>
<a name="ln2001">        if (multiplier == 0)</a>
<a name="ln2002">            return 0;</a>
<a name="ln2003"> </a>
<a name="ln2004">        if (multiplier &gt; 75)</a>
<a name="ln2005">            multiplier = 75;</a>
<a name="ln2006"> </a>
<a name="ln2007">        ret = damage * multiplier / 100;</a>
<a name="ln2008">    }</a>
<a name="ln2009">    else</a>
<a name="ln2010">        return 0;</a>
<a name="ln2011"> </a>
<a name="ln2012">    dmg_msg = &quot;The silver sears &quot; + victim-&gt;name(DESC_THE) + &quot;!&quot;;</a>
<a name="ln2013">    return ret;</a>
<a name="ln2014">}</a>
<a name="ln2015"> </a>
<a name="ln2016">//  Used by monsters in &quot;planning&quot; which spell to cast. Fires off a &quot;tracer&quot;</a>
<a name="ln2017">//  which tells the monster what it'll hit if it breathes/casts etc.</a>
<a name="ln2018">//</a>
<a name="ln2019">//  The output from this tracer function is written into the</a>
<a name="ln2020">//  tracer_info variables (friend_info and foe_info).</a>
<a name="ln2021">//</a>
<a name="ln2022">//  Note that beam properties must be set, as the tracer will take them</a>
<a name="ln2023">//  into account, as well as the monster's intelligence.</a>
<a name="ln2024">void fire_tracer(const monster* mons, bolt &amp;pbolt, bool explode_only,</a>
<a name="ln2025">                 bool explosion_hole)</a>
<a name="ln2026">{</a>
<a name="ln2027">    // Don't fiddle with any input parameters other than tracer stuff!</a>
<a name="ln2028">    pbolt.is_tracer     = true;</a>
<a name="ln2029">    pbolt.source        = mons-&gt;pos();</a>
<a name="ln2030">    pbolt.source_id     = mons-&gt;mid;</a>
<a name="ln2031">    pbolt.attitude      = mons_attitude(*mons);</a>
<a name="ln2032"> </a>
<a name="ln2033">    // Init tracer variables.</a>
<a name="ln2034">    pbolt.foe_info.reset();</a>
<a name="ln2035">    pbolt.friend_info.reset();</a>
<a name="ln2036"> </a>
<a name="ln2037">    // Clear misc</a>
<a name="ln2038">    pbolt.reflections   = 0;</a>
<a name="ln2039">    pbolt.bounces       = 0;</a>
<a name="ln2040"> </a>
<a name="ln2041">    // If there's a specifically requested foe_ratio, honour it.</a>
<a name="ln2042">    if (!pbolt.foe_ratio)</a>
<a name="ln2043">    {</a>
<a name="ln2044">        pbolt.foe_ratio     = 80;        // default - see mons_should_fire()</a>
<a name="ln2045"> </a>
<a name="ln2046">        if (mons_is_hepliaklqana_ancestor(mons-&gt;type))</a>
<a name="ln2047">            pbolt.foe_ratio = 100; // do not harm the player!</a>
<a name="ln2048">        // Foe ratio for summoning greater demons &amp; undead -- they may be</a>
<a name="ln2049">        // summoned, but they're hostile and would love nothing better</a>
<a name="ln2050">        // than to nuke the player and his minions.</a>
<a name="ln2051">        else if (mons_att_wont_attack(pbolt.attitude)</a>
<a name="ln2052">            &amp;&amp; !mons_att_wont_attack(mons-&gt;attitude))</a>
<a name="ln2053">        {</a>
<a name="ln2054">            pbolt.foe_ratio = 25;</a>
<a name="ln2055">        }</a>
<a name="ln2056">    }</a>
<a name="ln2057"> </a>
<a name="ln2058">    pbolt.in_explosion_phase = false;</a>
<a name="ln2059"> </a>
<a name="ln2060">    // Fire!</a>
<a name="ln2061">    if (explode_only)</a>
<a name="ln2062">        pbolt.explode(false, explosion_hole);</a>
<a name="ln2063">    else</a>
<a name="ln2064">        pbolt.fire();</a>
<a name="ln2065"> </a>
<a name="ln2066">    // Unset tracer flag (convenience).</a>
<a name="ln2067">    pbolt.is_tracer = false;</a>
<a name="ln2068">}</a>
<a name="ln2069"> </a>
<a name="ln2070">static coord_def _random_point_hittable_from(const coord_def &amp;c,</a>
<a name="ln2071">                                            int radius,</a>
<a name="ln2072">                                            int margin = 1,</a>
<a name="ln2073">                                            int tries = 5)</a>
<a name="ln2074">{</a>
<a name="ln2075">    while (tries-- &gt; 0)</a>
<a name="ln2076">    {</a>
<a name="ln2077">        const coord_def point = dgn_random_point_from(c, radius, margin);</a>
<a name="ln2078">        if (point.origin())</a>
<a name="ln2079">            continue;</a>
<a name="ln2080">        if (!cell_see_cell(c, point, LOS_SOLID))</a>
<a name="ln2081">            continue;</a>
<a name="ln2082">        return point;</a>
<a name="ln2083">    }</a>
<a name="ln2084">    return coord_def();</a>
<a name="ln2085">}</a>
<a name="ln2086"> </a>
<a name="ln2087">void create_feat_splash(coord_def center,</a>
<a name="ln2088">                                int radius,</a>
<a name="ln2089">                                int nattempts)</a>
<a name="ln2090">{</a>
<a name="ln2091">    // Always affect center, if compatible</a>
<a name="ln2092">    if ((grd(center) == DNGN_FLOOR || grd(center) == DNGN_SHALLOW_WATER))</a>
<a name="ln2093">    {</a>
<a name="ln2094">        temp_change_terrain(center, DNGN_SHALLOW_WATER, 100 + random2(100),</a>
<a name="ln2095">                            TERRAIN_CHANGE_FLOOD);</a>
<a name="ln2096">    }</a>
<a name="ln2097"> </a>
<a name="ln2098">    for (int i = 0; i &lt; nattempts; ++i)</a>
<a name="ln2099">    {</a>
<a name="ln2100">        const coord_def newp(_random_point_hittable_from(center, radius));</a>
<a name="ln2101">        if (newp.origin() || (grd(newp) != DNGN_FLOOR &amp;&amp; grd(newp) != DNGN_SHALLOW_WATER))</a>
<a name="ln2102">            continue;</a>
<a name="ln2103">        temp_change_terrain(newp, DNGN_SHALLOW_WATER, 100 + random2(100),</a>
<a name="ln2104">                            TERRAIN_CHANGE_FLOOD);</a>
<a name="ln2105">    }</a>
<a name="ln2106">}</a>
<a name="ln2107"> </a>
<a name="ln2108">void bolt_parent_init(const bolt &amp;parent, bolt &amp;child)</a>
<a name="ln2109">{</a>
<a name="ln2110">    child.name           = parent.name;</a>
<a name="ln2111">    child.short_name     = parent.short_name;</a>
<a name="ln2112">    child.aux_source     = parent.aux_source;</a>
<a name="ln2113">    child.source_id      = parent.source_id;</a>
<a name="ln2114">    child.origin_spell   = parent.origin_spell;</a>
<a name="ln2115">    child.glyph          = parent.glyph;</a>
<a name="ln2116">    child.colour         = parent.colour;</a>
<a name="ln2117"> </a>
<a name="ln2118">    child.flavour        = parent.flavour;</a>
<a name="ln2119"> </a>
<a name="ln2120">    // We don't copy target since that is often overriden.</a>
<a name="ln2121">    child.thrower        = parent.thrower;</a>
<a name="ln2122">    child.source         = parent.source;</a>
<a name="ln2123">    child.source_name    = parent.source_name;</a>
<a name="ln2124">    child.attitude       = parent.attitude;</a>
<a name="ln2125"> </a>
<a name="ln2126">    child.pierce         = parent.pierce ;</a>
<a name="ln2127">    child.is_explosion   = parent.is_explosion;</a>
<a name="ln2128">    child.ex_size        = parent.ex_size;</a>
<a name="ln2129">    child.foe_ratio      = parent.foe_ratio;</a>
<a name="ln2130"> </a>
<a name="ln2131">    child.is_tracer      = parent.is_tracer;</a>
<a name="ln2132">    child.is_targeting   = parent.is_targeting;</a>
<a name="ln2133"> </a>
<a name="ln2134">    child.range          = parent.range;</a>
<a name="ln2135">    child.hit            = parent.hit;</a>
<a name="ln2136">    child.damage         = parent.damage;</a>
<a name="ln2137">    if (parent.ench_power != -1)</a>
<a name="ln2138">        child.ench_power = parent.ench_power;</a>
<a name="ln2139"> </a>
<a name="ln2140">    child.friend_info.dont_stop = parent.friend_info.dont_stop;</a>
<a name="ln2141">    child.foe_info.dont_stop    = parent.foe_info.dont_stop;</a>
<a name="ln2142">    child.dont_stop_player      = parent.dont_stop_player;</a>
<a name="ln2143">    child.dont_stop_trees       = parent.dont_stop_trees;</a>
<a name="ln2144"> </a>
<a name="ln2145">#ifdef DEBUG_DIAGNOSTICS</a>
<a name="ln2146">    child.quiet_debug    = parent.quiet_debug;</a>
<a name="ln2147">#endif</a>
<a name="ln2148">}</a>
<a name="ln2149"> </a>
<a name="ln2150">static void _malign_offering_effect(actor* victim, const actor* agent, int damage)</a>
<a name="ln2151">{</a>
<a name="ln2152">    if (!agent || damage &lt; 1)</a>
<a name="ln2153">        return;</a>
<a name="ln2154"> </a>
<a name="ln2155">    // The victim may die.</a>
<a name="ln2156">    coord_def c = victim-&gt;pos();</a>
<a name="ln2157"> </a>
<a name="ln2158">    mprf(&quot;%s life force is offered up.&quot;, victim-&gt;name(DESC_ITS).c_str());</a>
<a name="ln2159">    damage = victim-&gt;hurt(agent, damage, BEAM_MALIGN_OFFERING, KILLED_BY_BEAM,</a>
<a name="ln2160">                          &quot;&quot;, &quot;by a malign offering&quot;);</a>
<a name="ln2161"> </a>
<a name="ln2162">    // Actors that had LOS to the victim (blocked by glass, clouds, etc),</a>
<a name="ln2163">    // even if they couldn't actually see each other because of blindness</a>
<a name="ln2164">    // or invisibility.</a>
<a name="ln2165">    for (actor_near_iterator ai(c, LOS_NO_TRANS); ai; ++ai)</a>
<a name="ln2166">    {</a>
<a name="ln2167">        if (mons_aligned(agent, *ai) &amp;&amp; !(ai-&gt;holiness() &amp; MH_NONLIVING)</a>
<a name="ln2168">            &amp;&amp; *ai != victim)</a>
<a name="ln2169">        {</a>
<a name="ln2170">            if (ai-&gt;heal(max(1, damage * 2 / 3)) &amp;&amp; you.can_see(**ai))</a>
<a name="ln2171">            {</a>
<a name="ln2172">                mprf(&quot;%s %s healed.&quot;, ai-&gt;name(DESC_THE).c_str(),</a>
<a name="ln2173">                                      ai-&gt;conj_verb(&quot;are&quot;).c_str());</a>
<a name="ln2174">            }</a>
<a name="ln2175">        }</a>
<a name="ln2176">    }</a>
<a name="ln2177">}</a>
<a name="ln2178"> </a>
<a name="ln2179">/**</a>
<a name="ln2180"> * Turn a BEAM_UNRAVELLING beam into a BEAM_UNRAVELLED_MAGIC beam, and make</a>
<a name="ln2181"> * it explode appropriately.</a>
<a name="ln2182"> *</a>
<a name="ln2183"> * @param[in,out] beam      The beam being turned into an explosion.</a>
<a name="ln2184"> */</a>
<a name="ln2185">static void _unravelling_explode(bolt &amp;beam)</a>
<a name="ln2186">{</a>
<a name="ln2187">    beam.damage       = dice_def(3, 3 + div_rand_round(beam.ench_power, 6));</a>
<a name="ln2188">    beam.colour       = ETC_MUTAGENIC;</a>
<a name="ln2189">    beam.flavour      = BEAM_UNRAVELLED_MAGIC;</a>
<a name="ln2190">    beam.ex_size      = 1;</a>
<a name="ln2191">    beam.is_explosion = true;</a>
<a name="ln2192">    // and it'll explode 'naturally' a little later.</a>
<a name="ln2193">}</a>
<a name="ln2194"> </a>
<a name="ln2195">bool bolt::is_bouncy(dungeon_feature_type feat) const</a>
<a name="ln2196">{</a>
<a name="ln2197">    // Don't bounce off open sea.</a>
<a name="ln2198">    if (feat_is_endless(feat))</a>
<a name="ln2199">        return false;</a>
<a name="ln2200"> </a>
<a name="ln2201">    if (real_flavour == BEAM_CHAOS</a>
<a name="ln2202">        &amp;&amp; feat_is_solid(feat))</a>
<a name="ln2203">    {</a>
<a name="ln2204">        return true;</a>
<a name="ln2205">    }</a>
<a name="ln2206"> </a>
<a name="ln2207">    if ((flavour == BEAM_CRYSTAL || real_flavour == BEAM_CRYSTAL</a>
<a name="ln2208">         || flavour == BEAM_BOUNCY_TRACER)</a>
<a name="ln2209">        &amp;&amp; feat_is_solid(feat)</a>
<a name="ln2210">        &amp;&amp; !feat_is_tree(feat))</a>
<a name="ln2211">    {</a>
<a name="ln2212">        return true;</a>
<a name="ln2213">    }</a>
<a name="ln2214"> </a>
<a name="ln2215">    if (is_enchantment())</a>
<a name="ln2216">        return false;</a>
<a name="ln2217"> </a>
<a name="ln2218">    if (flavour == BEAM_ELECTRICITY &amp;&amp; !feat_is_metal(feat)</a>
<a name="ln2219">        &amp;&amp; !feat_is_tree(feat))</a>
<a name="ln2220">    {</a>
<a name="ln2221">        return true;</a>
<a name="ln2222">    }</a>
<a name="ln2223"> </a>
<a name="ln2224">    if ((flavour == BEAM_FIRE || flavour == BEAM_COLD)</a>
<a name="ln2225">        &amp;&amp; feat == DNGN_CRYSTAL_WALL)</a>
<a name="ln2226">    {</a>
<a name="ln2227">        return true;</a>
<a name="ln2228">    }</a>
<a name="ln2229"> </a>
<a name="ln2230">    return false;</a>
<a name="ln2231">}</a>
<a name="ln2232"> </a>
<a name="ln2233">cloud_type bolt::get_cloud_type() const</a>
<a name="ln2234">{</a>
<a name="ln2235">    if (origin_spell == SPELL_NOXIOUS_CLOUD)</a>
<a name="ln2236">        return CLOUD_MEPHITIC;</a>
<a name="ln2237"> </a>
<a name="ln2238">    if (origin_spell == SPELL_POISONOUS_CLOUD)</a>
<a name="ln2239">        return CLOUD_POISON;</a>
<a name="ln2240"> </a>
<a name="ln2241">    if (origin_spell == SPELL_HOLY_BREATH)</a>
<a name="ln2242">        return CLOUD_HOLY;</a>
<a name="ln2243"> </a>
<a name="ln2244">    if (origin_spell == SPELL_FLAMING_CLOUD)</a>
<a name="ln2245">        return CLOUD_FIRE;</a>
<a name="ln2246"> </a>
<a name="ln2247">    if (origin_spell == SPELL_CHAOS_BREATH)</a>
<a name="ln2248">        return CLOUD_CHAOS;</a>
<a name="ln2249"> </a>
<a name="ln2250">    if (origin_spell == SPELL_MIASMA_BREATH)</a>
<a name="ln2251">        return CLOUD_MIASMA;</a>
<a name="ln2252"> </a>
<a name="ln2253">    if (origin_spell == SPELL_FREEZING_CLOUD)</a>
<a name="ln2254">        return CLOUD_COLD;</a>
<a name="ln2255"> </a>
<a name="ln2256">    if (origin_spell == SPELL_SPECTRAL_CLOUD)</a>
<a name="ln2257">        return CLOUD_SPECTRAL;</a>
<a name="ln2258"> </a>
<a name="ln2259">    return CLOUD_NONE;</a>
<a name="ln2260">}</a>
<a name="ln2261"> </a>
<a name="ln2262">int bolt::get_cloud_pow() const</a>
<a name="ln2263">{</a>
<a name="ln2264">    if (origin_spell == SPELL_FREEZING_CLOUD</a>
<a name="ln2265">        || origin_spell == SPELL_POISONOUS_CLOUD)</a>
<a name="ln2266">    {</a>
<a name="ln2267">        return random_range(10, 15);</a>
<a name="ln2268">    }</a>
<a name="ln2269"> </a>
<a name="ln2270">    if (origin_spell == SPELL_SPECTRAL_CLOUD)</a>
<a name="ln2271">        return random_range(12, 20);</a>
<a name="ln2272"> </a>
<a name="ln2273">    return 0;</a>
<a name="ln2274">}</a>
<a name="ln2275"> </a>
<a name="ln2276">int bolt::get_cloud_size(bool min, bool max) const</a>
<a name="ln2277">{</a>
<a name="ln2278">    if (origin_spell == SPELL_MEPHITIC_CLOUD</a>
<a name="ln2279">        || origin_spell == SPELL_MIASMA_BREATH</a>
<a name="ln2280">        || origin_spell == SPELL_FREEZING_CLOUD)</a>
<a name="ln2281">    {</a>
<a name="ln2282">        return 10;</a>
<a name="ln2283">    }</a>
<a name="ln2284"> </a>
<a name="ln2285">    if (min)</a>
<a name="ln2286">        return 8;</a>
<a name="ln2287">    if (max)</a>
<a name="ln2288">        return 12;</a>
<a name="ln2289"> </a>
<a name="ln2290">    return 8 + random2(5);</a>
<a name="ln2291">}</a>
<a name="ln2292"> </a>
<a name="ln2293">void bolt::affect_endpoint()</a>
<a name="ln2294">{</a>
<a name="ln2295">    if (special_explosion)</a>
<a name="ln2296">    {</a>
<a name="ln2297">        special_explosion-&gt;target = pos();</a>
<a name="ln2298">        special_explosion-&gt;refine_for_explosion();</a>
<a name="ln2299">        special_explosion-&gt;explode();</a>
<a name="ln2300"> </a>
<a name="ln2301">        // XXX: we're significantly overcounting here.</a>
<a name="ln2302">        foe_info      += special_explosion-&gt;foe_info;</a>
<a name="ln2303">        friend_info   += special_explosion-&gt;friend_info;</a>
<a name="ln2304">        beam_cancelled = beam_cancelled || special_explosion-&gt;beam_cancelled;</a>
<a name="ln2305">    }</a>
<a name="ln2306"> </a>
<a name="ln2307">    // Leave an object, if applicable.</a>
<a name="ln2308">    if (drop_item &amp;&amp; item)</a>
<a name="ln2309">        drop_object();</a>
<a name="ln2310"> </a>
<a name="ln2311">    if (is_explosion)</a>
<a name="ln2312">    {</a>
<a name="ln2313">        target = pos();</a>
<a name="ln2314">        refine_for_explosion();</a>
<a name="ln2315">        explode();</a>
<a name="ln2316">        return;</a>
<a name="ln2317">    }</a>
<a name="ln2318"> </a>
<a name="ln2319">    const cloud_type cloud = get_cloud_type();</a>
<a name="ln2320"> </a>
<a name="ln2321">    if (is_tracer)</a>
<a name="ln2322">    {</a>
<a name="ln2323">        if (cloud == CLOUD_NONE)</a>
<a name="ln2324">            return;</a>
<a name="ln2325"> </a>
<a name="ln2326">        targeter_cloud tgt(agent(), range, get_cloud_size(true),</a>
<a name="ln2327">                            get_cloud_size(false, true));</a>
<a name="ln2328">        tgt.set_aim(pos());</a>
<a name="ln2329">        for (const auto &amp;entry : tgt.seen)</a>
<a name="ln2330">        {</a>
<a name="ln2331">            if (entry.second != AFF_YES &amp;&amp; entry.second != AFF_MAYBE)</a>
<a name="ln2332">                continue;</a>
<a name="ln2333"> </a>
<a name="ln2334">            if (entry.first == you.pos())</a>
<a name="ln2335">                tracer_affect_player();</a>
<a name="ln2336">            else if (monster* mon = monster_at(entry.first))</a>
<a name="ln2337">                tracer_affect_monster(mon);</a>
<a name="ln2338"> </a>
<a name="ln2339">            if (agent()-&gt;is_player() &amp;&amp; beam_cancelled)</a>
<a name="ln2340">                return;</a>
<a name="ln2341">        }</a>
<a name="ln2342"> </a>
<a name="ln2343">        return;</a>
<a name="ln2344">    }</a>
<a name="ln2345"> </a>
<a name="ln2346">    if (!is_explosion &amp;&amp; !noise_generated &amp;&amp; loudness)</a>
<a name="ln2347">    {</a>
<a name="ln2348">        // Digging can target squares on the map boundary, though it</a>
<a name="ln2349">        // won't remove them of course.</a>
<a name="ln2350">        const coord_def noise_position = clamp_in_bounds(pos());</a>
<a name="ln2351">        noisy(loudness, noise_position, source_id);</a>
<a name="ln2352">        noise_generated = true;</a>
<a name="ln2353">    }</a>
<a name="ln2354"> </a>
<a name="ln2355">    if (cloud != CLOUD_NONE)</a>
<a name="ln2356">        big_cloud(cloud, agent(), pos(), get_cloud_pow(), get_cloud_size());</a>
<a name="ln2357"> </a>
<a name="ln2358">    // you like special cases, right?</a>
<a name="ln2359">    switch (origin_spell)</a>
<a name="ln2360">    {</a>
<a name="ln2361">    case SPELL_PRIMAL_WAVE:</a>
<a name="ln2362">        if (you.see_cell(pos()))</a>
<a name="ln2363">        {</a>
<a name="ln2364">            mpr(&quot;The wave splashes down.&quot;);</a>
<a name="ln2365">            noisy(spell_effect_noise(SPELL_PRIMAL_WAVE), pos());</a>
<a name="ln2366">        }</a>
<a name="ln2367">        else</a>
<a name="ln2368">        {</a>
<a name="ln2369">            noisy(spell_effect_noise(SPELL_PRIMAL_WAVE),</a>
<a name="ln2370">                  pos(), &quot;You hear a splash.&quot;);</a>
<a name="ln2371">        }</a>
<a name="ln2372">        create_feat_splash(pos(), 2, random_range(3, 12, 2));</a>
<a name="ln2373">        break;</a>
<a name="ln2374"> </a>
<a name="ln2375">    case SPELL_BLINKBOLT:</a>
<a name="ln2376">    {</a>
<a name="ln2377">        actor *act = agent(true); // use orig actor even when reflected</a>
<a name="ln2378">        if (!act || !act-&gt;alive())</a>
<a name="ln2379">            return;</a>
<a name="ln2380"> </a>
<a name="ln2381">        for (vector&lt;coord_def&gt;::reverse_iterator citr = path_taken.rbegin();</a>
<a name="ln2382">             citr != path_taken.rend(); ++citr)</a>
<a name="ln2383">        {</a>
<a name="ln2384">            if (act-&gt;is_habitable(*citr) &amp;&amp; act-&gt;blink_to(*citr, false))</a>
<a name="ln2385">                return;</a>
<a name="ln2386">        }</a>
<a name="ln2387">        return;</a>
<a name="ln2388">    }</a>
<a name="ln2389"> </a>
<a name="ln2390">    case SPELL_SEARING_BREATH:</a>
<a name="ln2391">        if (!path_taken.empty())</a>
<a name="ln2392">            place_cloud(CLOUD_FIRE, pos(), 5 + random2(5), agent());</a>
<a name="ln2393"> </a>
<a name="ln2394">    default:</a>
<a name="ln2395">        break;</a>
<a name="ln2396">    }</a>
<a name="ln2397">}</a>
<a name="ln2398"> </a>
<a name="ln2399">bool bolt::stop_at_target() const</a>
<a name="ln2400">{</a>
<a name="ln2401">    // the pos check is to avoid a ray.cc assert for a ray that goes nowhere</a>
<a name="ln2402">    return is_explosion || is_big_cloud() ||</a>
<a name="ln2403">            (aimed_at_spot &amp;&amp; (pos() == source || flavour != BEAM_DIGGING));</a>
<a name="ln2404">}</a>
<a name="ln2405"> </a>
<a name="ln2406">void bolt::drop_object()</a>
<a name="ln2407">{</a>
<a name="ln2408">    ASSERT(item != nullptr);</a>
<a name="ln2409">    ASSERT(item-&gt;defined());</a>
<a name="ln2410"> </a>
<a name="ln2411">    // Conditions: beam is missile and not tracer.</a>
<a name="ln2412">    if (is_tracer || !was_missile)</a>
<a name="ln2413">        return;</a>
<a name="ln2414"> </a>
<a name="ln2415">    // Summoned creatures' thrown items disappear.</a>
<a name="ln2416">    if (item-&gt;flags &amp; ISFLAG_SUMMONED)</a>
<a name="ln2417">    {</a>
<a name="ln2418">        if (you.see_cell(pos()))</a>
<a name="ln2419">        {</a>
<a name="ln2420">            mprf(&quot;%s %s!&quot;,</a>
<a name="ln2421">                 item-&gt;name(DESC_THE).c_str(),</a>
<a name="ln2422">                 summoned_poof_msg(agent() ? agent()-&gt;as_monster() : nullptr,</a>
<a name="ln2423">                                   *item).c_str());</a>
<a name="ln2424">        }</a>
<a name="ln2425">        item_was_destroyed(*item);</a>
<a name="ln2426">        return;</a>
<a name="ln2427">    }</a>
<a name="ln2428"> </a>
<a name="ln2429">    if (!thrown_object_destroyed(item))</a>
<a name="ln2430">    {</a>
<a name="ln2431">        if (item-&gt;sub_type == MI_THROWING_NET)</a>
<a name="ln2432">        {</a>
<a name="ln2433">            monster* m = monster_at(pos());</a>
<a name="ln2434">            // Player or monster at position is caught in net.</a>
<a name="ln2435">            if (you.pos() == pos() &amp;&amp; you.attribute[ATTR_HELD]</a>
<a name="ln2436">                || m &amp;&amp; m-&gt;caught())</a>
<a name="ln2437">            {</a>
<a name="ln2438">                // If no trapping net found mark this one.</a>
<a name="ln2439">                if (get_trapping_net(pos(), true) == NON_ITEM)</a>
<a name="ln2440">                    set_net_stationary(*item);</a>
<a name="ln2441">            }</a>
<a name="ln2442">        }</a>
<a name="ln2443"> </a>
<a name="ln2444">        copy_item_to_grid(*item, pos(), 1);</a>
<a name="ln2445">    }</a>
<a name="ln2446">    else</a>
<a name="ln2447">        item_was_destroyed(*item);</a>
<a name="ln2448">}</a>
<a name="ln2449"> </a>
<a name="ln2450">// Returns true if the beam hits the player, fuzzing the beam if necessary</a>
<a name="ln2451">// for monsters without see invis firing tracers at the player.</a>
<a name="ln2452">bool bolt::found_player() const</a>
<a name="ln2453">{</a>
<a name="ln2454">    const bool needs_fuzz = (is_tracer &amp;&amp; !can_see_invis</a>
<a name="ln2455">                             &amp;&amp; you.invisible() &amp;&amp; !YOU_KILL(thrower));</a>
<a name="ln2456">    const int dist = needs_fuzz? 2 : 0;</a>
<a name="ln2457"> </a>
<a name="ln2458">    return grid_distance(pos(), you.pos()) &lt;= dist;</a>
<a name="ln2459">}</a>
<a name="ln2460"> </a>
<a name="ln2461">void bolt::affect_ground()</a>
<a name="ln2462">{</a>
<a name="ln2463">    // Explosions only have an effect during their explosion phase.</a>
<a name="ln2464">    // Special cases can be handled here.</a>
<a name="ln2465">    if (is_explosion &amp;&amp; !in_explosion_phase)</a>
<a name="ln2466">        return;</a>
<a name="ln2467"> </a>
<a name="ln2468">    if (is_tracer)</a>
<a name="ln2469">        return;</a>
<a name="ln2470"> </a>
<a name="ln2471">    affect_place_clouds();</a>
<a name="ln2472">}</a>
<a name="ln2473"> </a>
<a name="ln2474">bool bolt::is_fiery() const</a>
<a name="ln2475">{</a>
<a name="ln2476">    return flavour == BEAM_FIRE || flavour == BEAM_LAVA;</a>
<a name="ln2477">}</a>
<a name="ln2478"> </a>
<a name="ln2479">/// Can this bolt burn trees it hits?</a>
<a name="ln2480">bool bolt::can_burn_trees() const</a>
<a name="ln2481">{</a>
<a name="ln2482">    // XXX: rethink this</a>
<a name="ln2483">    return origin_spell == SPELL_LIGHTNING_BOLT</a>
<a name="ln2484">           || origin_spell == SPELL_BOLT_OF_FIRE</a>
<a name="ln2485">           || origin_spell == SPELL_BOLT_OF_MAGMA</a>
<a name="ln2486">           || origin_spell == SPELL_FIREBALL</a>
<a name="ln2487">           || origin_spell == SPELL_FIRE_STORM</a>
<a name="ln2488">           || origin_spell == SPELL_IGNITION</a>
<a name="ln2489">           || origin_spell == SPELL_INNER_FLAME</a>
<a name="ln2490">           || origin_spell == SPELL_STARBURST;</a>
<a name="ln2491">}</a>
<a name="ln2492"> </a>
<a name="ln2493">bool bolt::can_affect_wall(const coord_def&amp; p, bool map_knowledge) const</a>
<a name="ln2494">{</a>
<a name="ln2495">    dungeon_feature_type wall = grd(p);</a>
<a name="ln2496"> </a>
<a name="ln2497">    // digging might affect unseen squares, as far as the player knows</a>
<a name="ln2498">    if (map_knowledge &amp;&amp; flavour == BEAM_DIGGING &amp;&amp;</a>
<a name="ln2499">                                        !env.map_knowledge(pos()).seen())</a>
<a name="ln2500">    {</a>
<a name="ln2501">        return true;</a>
<a name="ln2502">    }</a>
<a name="ln2503"> </a>
<a name="ln2504">    // Temporary trees (from Summon Forest) can't be burned.</a>
<a name="ln2505">    if (feat_is_tree(wall) &amp;&amp; is_temp_terrain(p))</a>
<a name="ln2506">        return false;</a>
<a name="ln2507"> </a>
<a name="ln2508">    // digging</a>
<a name="ln2509">    if (flavour == BEAM_DIGGING &amp;&amp; feat_is_diggable(wall))</a>
<a name="ln2510">        return true;</a>
<a name="ln2511"> </a>
<a name="ln2512">    if (can_burn_trees())</a>
<a name="ln2513">        return feat_is_tree(wall);</a>
<a name="ln2514"> </a>
<a name="ln2515">    // Lee's Rapid Deconstruction</a>
<a name="ln2516">    if (flavour == BEAM_FRAG)</a>
<a name="ln2517">        return true; // smite targeting, we don't care</a>
<a name="ln2518"> </a>
<a name="ln2519">    return false;</a>
<a name="ln2520">}</a>
<a name="ln2521"> </a>
<a name="ln2522">void bolt::affect_place_clouds()</a>
<a name="ln2523">{</a>
<a name="ln2524">    if (in_explosion_phase)</a>
<a name="ln2525">        affect_place_explosion_clouds();</a>
<a name="ln2526"> </a>
<a name="ln2527">    const coord_def p = pos();</a>
<a name="ln2528"> </a>
<a name="ln2529">    // Is there already a cloud here?</a>
<a name="ln2530">    if (cloud_struct* cloud = cloud_at(p))</a>
<a name="ln2531">    {</a>
<a name="ln2532">        // fire cancelling cold &amp; vice versa</a>
<a name="ln2533">        if ((cloud-&gt;type == CLOUD_COLD</a>
<a name="ln2534">             &amp;&amp; (flavour == BEAM_FIRE || flavour == BEAM_LAVA))</a>
<a name="ln2535">            || (cloud-&gt;type == CLOUD_FIRE &amp;&amp; flavour == BEAM_COLD))</a>
<a name="ln2536">        {</a>
<a name="ln2537">            if (player_can_hear(p))</a>
<a name="ln2538">                mprf(MSGCH_SOUND, &quot;You hear a sizzling sound!&quot;);</a>
<a name="ln2539"> </a>
<a name="ln2540">            delete_cloud(p);</a>
<a name="ln2541">            extra_range_used += 5;</a>
<a name="ln2542">        }</a>
<a name="ln2543">        return;</a>
<a name="ln2544">    }</a>
<a name="ln2545"> </a>
<a name="ln2546">    // No clouds here, free to make new ones.</a>
<a name="ln2547">    const dungeon_feature_type feat = grd(p);</a>
<a name="ln2548"> </a>
<a name="ln2549">    if (origin_spell == SPELL_POISONOUS_CLOUD)</a>
<a name="ln2550">        place_cloud(CLOUD_POISON, p, random2(5) + 3, agent());</a>
<a name="ln2551"> </a>
<a name="ln2552">    if (origin_spell == SPELL_HOLY_BREATH)</a>
<a name="ln2553">        place_cloud(CLOUD_HOLY, p, random2(4) + 2, agent());</a>
<a name="ln2554"> </a>
<a name="ln2555">    if (origin_spell == SPELL_FLAMING_CLOUD)</a>
<a name="ln2556">        place_cloud(CLOUD_FIRE, p, random2(4) + 2, agent());</a>
<a name="ln2557"> </a>
<a name="ln2558">    // Fire/cold over water/lava</a>
<a name="ln2559">    if (feat == DNGN_LAVA &amp;&amp; flavour == BEAM_COLD</a>
<a name="ln2560">        || feat_is_watery(feat) &amp;&amp; is_fiery())</a>
<a name="ln2561">    {</a>
<a name="ln2562">        place_cloud(CLOUD_STEAM, p, 2 + random2(5), agent(), 11);</a>
<a name="ln2563">    }</a>
<a name="ln2564"> </a>
<a name="ln2565">    if (feat_is_watery(feat) &amp;&amp; flavour == BEAM_COLD</a>
<a name="ln2566">        &amp;&amp; damage.num * damage.size &gt; 35)</a>
<a name="ln2567">    {</a>
<a name="ln2568">        place_cloud(CLOUD_COLD, p, damage.num * damage.size / 30 + 1, agent());</a>
<a name="ln2569">    }</a>
<a name="ln2570"> </a>
<a name="ln2571">    if (flavour == BEAM_MIASMA)</a>
<a name="ln2572">        place_cloud(CLOUD_MIASMA, p, random2(5) + 2, agent());</a>
<a name="ln2573"> </a>
<a name="ln2574">    //XXX: these use the name for a gameplay effect.</a>
<a name="ln2575">    if (name == &quot;ball of steam&quot;)</a>
<a name="ln2576">        place_cloud(CLOUD_STEAM, p, random2(5) + 2, agent());</a>
<a name="ln2577"> </a>
<a name="ln2578">    if (name == &quot;poison gas&quot;)</a>
<a name="ln2579">        place_cloud(CLOUD_POISON, p, random2(4) + 3, agent());</a>
<a name="ln2580"> </a>
<a name="ln2581">    if (name == &quot;blast of choking fumes&quot;)</a>
<a name="ln2582">        place_cloud(CLOUD_MEPHITIC, p, random2(4) + 3, agent());</a>
<a name="ln2583"> </a>
<a name="ln2584">    if (name == &quot;trail of fire&quot;)</a>
<a name="ln2585">        place_cloud(CLOUD_FIRE, p, random2(ench_power) + ench_power, agent());</a>
<a name="ln2586"> </a>
<a name="ln2587">    if (origin_spell == SPELL_PETRIFYING_CLOUD)</a>
<a name="ln2588">        place_cloud(CLOUD_PETRIFY, p, random2(4) + 4, agent());</a>
<a name="ln2589"> </a>
<a name="ln2590">    if (origin_spell == SPELL_SPECTRAL_CLOUD)</a>
<a name="ln2591">        place_cloud(CLOUD_SPECTRAL, p, random2(6) + 5, agent());</a>
<a name="ln2592"> </a>
<a name="ln2593">    if (origin_spell == SPELL_DEATH_RATTLE)</a>
<a name="ln2594">        place_cloud(CLOUD_MIASMA, p, random2(4) + 4, agent());</a>
<a name="ln2595">}</a>
<a name="ln2596"> </a>
<a name="ln2597">void bolt::affect_place_explosion_clouds()</a>
<a name="ln2598">{</a>
<a name="ln2599">    const coord_def p = pos();</a>
<a name="ln2600"> </a>
<a name="ln2601">    // First check: fire/cold over water/lava.</a>
<a name="ln2602">    if (grd(p) == DNGN_LAVA &amp;&amp; flavour == BEAM_COLD</a>
<a name="ln2603">        || feat_is_watery(grd(p)) &amp;&amp; is_fiery())</a>
<a name="ln2604">    {</a>
<a name="ln2605">        place_cloud(CLOUD_STEAM, p, 2 + random2(5), agent());</a>
<a name="ln2606">        return;</a>
<a name="ln2607">    }</a>
<a name="ln2608"> </a>
<a name="ln2609">    if (flavour == BEAM_MEPHITIC)</a>
<a name="ln2610">    {</a>
<a name="ln2611">        const coord_def center = (aimed_at_feet ? source : ray.pos());</a>
<a name="ln2612">        if (p == center || x_chance_in_y(125 + ench_power, 225))</a>
<a name="ln2613">        {</a>
<a name="ln2614">            place_cloud(CLOUD_MEPHITIC, p, roll_dice(2, 3 + ench_power / 20),</a>
<a name="ln2615">                        agent());</a>
<a name="ln2616">        }</a>
<a name="ln2617">    }</a>
<a name="ln2618"> </a>
<a name="ln2619">    if (origin_spell == SPELL_FIRE_STORM)</a>
<a name="ln2620">    {</a>
<a name="ln2621">        place_cloud(CLOUD_FIRE, p, 2 + random2avg(5,2), agent());</a>
<a name="ln2622"> </a>
<a name="ln2623">        // XXX: affect other open spaces?</a>
<a name="ln2624">        if (grd(p) == DNGN_FLOOR &amp;&amp; !monster_at(p) &amp;&amp; one_chance_in(4))</a>
<a name="ln2625">        {</a>
<a name="ln2626">            const god_type god =</a>
<a name="ln2627">                (crawl_state.is_god_acting()) ? crawl_state.which_god_acting()</a>
<a name="ln2628">                                              : GOD_NO_GOD;</a>
<a name="ln2629">            const beh_type att =</a>
<a name="ln2630">                (whose_kill() == KC_OTHER ? BEH_HOSTILE : BEH_FRIENDLY);</a>
<a name="ln2631"> </a>
<a name="ln2632">            actor* summ = agent();</a>
<a name="ln2633">            mgen_data mg(MONS_FIRE_VORTEX, att, p, MHITNOT, MG_NONE, god);</a>
<a name="ln2634">            mg.set_summoned(summ, 1, SPELL_FIRE_STORM);</a>
<a name="ln2635"> </a>
<a name="ln2636">            // Spell-summoned monsters need to have a live summoner.</a>
<a name="ln2637">            if (summ == nullptr || !summ-&gt;alive())</a>
<a name="ln2638">            {</a>
<a name="ln2639">                if (!source_name.empty())</a>
<a name="ln2640">                    mg.non_actor_summoner = source_name;</a>
<a name="ln2641">                else if (god != GOD_NO_GOD)</a>
<a name="ln2642">                    mg.non_actor_summoner = god_name(god);</a>
<a name="ln2643">            }</a>
<a name="ln2644"> </a>
<a name="ln2645">            mons_place(mg);</a>
<a name="ln2646">        }</a>
<a name="ln2647">    }</a>
<a name="ln2648">}</a>
<a name="ln2649"> </a>
<a name="ln2650">// A little helper function to handle the calling of ouch()...</a>
<a name="ln2651">void bolt::internal_ouch(int dam)</a>
<a name="ln2652">{</a>
<a name="ln2653">    monster* monst = monster_by_mid(source_id);</a>
<a name="ln2654"> </a>
<a name="ln2655">    const char *what = aux_source.empty() ? name.c_str() : aux_source.c_str();</a>
<a name="ln2656"> </a>
<a name="ln2657">    if (YOU_KILL(thrower) &amp;&amp; you.duration[DUR_QUAD_DAMAGE])</a>
<a name="ln2658">        dam *= 4;</a>
<a name="ln2659"> </a>
<a name="ln2660">    // The order of this is important.</a>
<a name="ln2661">    if (monst &amp;&amp; monst-&gt;type == MONS_PLAYER_SHADOW</a>
<a name="ln2662">        &amp;&amp; !monst-&gt;mname.empty())</a>
<a name="ln2663">    {</a>
<a name="ln2664">        ouch(dam, KILLED_BY_DIVINE_WRATH, MID_NOBODY,</a>
<a name="ln2665">             aux_source.empty() ? nullptr : aux_source.c_str(), true,</a>
<a name="ln2666">             source_name.empty() ? nullptr : source_name.c_str());</a>
<a name="ln2667">    }</a>
<a name="ln2668">    else if (monst &amp;&amp; (monst-&gt;type == MONS_BALLISTOMYCETE_SPORE</a>
<a name="ln2669">                       || monst-&gt;type == MONS_BALL_LIGHTNING</a>
<a name="ln2670">                       || monst-&gt;type == MONS_FULMINANT_PRISM</a>
<a name="ln2671">                       || monst-&gt;type == MONS_BENNU // death flames</a>
<a name="ln2672">                       ))</a>
<a name="ln2673">    {</a>
<a name="ln2674">        ouch(dam, KILLED_BY_SPORE, source_id,</a>
<a name="ln2675">             aux_source.c_str(), true,</a>
<a name="ln2676">             source_name.empty() ? nullptr : source_name.c_str());</a>
<a name="ln2677">    }</a>
<a name="ln2678">    else if (flavour == BEAM_DISINTEGRATION || flavour == BEAM_DEVASTATION)</a>
<a name="ln2679">    {</a>
<a name="ln2680">        ouch(dam, KILLED_BY_DISINT, source_id, what, true,</a>
<a name="ln2681">             source_name.empty() ? nullptr : source_name.c_str());</a>
<a name="ln2682">    }</a>
<a name="ln2683">    else if (YOU_KILL(thrower) &amp;&amp; aux_source.empty())</a>
<a name="ln2684">    {</a>
<a name="ln2685">        if (reflections &gt; 0)</a>
<a name="ln2686">            ouch(dam, KILLED_BY_REFLECTION, reflector, name.c_str());</a>
<a name="ln2687">        else if (bounces &gt; 0)</a>
<a name="ln2688">            ouch(dam, KILLED_BY_BOUNCE, MID_PLAYER, name.c_str());</a>
<a name="ln2689">        else</a>
<a name="ln2690">        {</a>
<a name="ln2691">            if (aimed_at_feet &amp;&amp; effect_known)</a>
<a name="ln2692">                ouch(dam, KILLED_BY_SELF_AIMED, MID_PLAYER, name.c_str());</a>
<a name="ln2693">            else</a>
<a name="ln2694">                ouch(dam, KILLED_BY_TARGETING, MID_PLAYER, name.c_str());</a>
<a name="ln2695">        }</a>
<a name="ln2696">    }</a>
<a name="ln2697">    else if (MON_KILL(thrower) || aux_source == &quot;exploding inner flame&quot;)</a>
<a name="ln2698">        ouch(dam, KILLED_BY_BEAM, source_id,</a>
<a name="ln2699">             aux_source.c_str(), true,</a>
<a name="ln2700">             source_name.empty() ? nullptr : source_name.c_str());</a>
<a name="ln2701">    else // KILL_MISC || (YOU_KILL &amp;&amp; aux_source)</a>
<a name="ln2702">        ouch(dam, KILLED_BY_WILD_MAGIC, source_id, aux_source.c_str());</a>
<a name="ln2703">}</a>
<a name="ln2704"> </a>
<a name="ln2705">// [ds] Apply a fuzz if the monster lacks see invisible and is trying to target</a>
<a name="ln2706">// an invisible player. This makes invisibility slightly more powerful.</a>
<a name="ln2707">bool bolt::fuzz_invis_tracer()</a>
<a name="ln2708">{</a>
<a name="ln2709">    // Did the monster have a rough idea of where you are?</a>
<a name="ln2710">    int dist = grid_distance(target, you.pos());</a>
<a name="ln2711"> </a>
<a name="ln2712">    // No, ditch this.</a>
<a name="ln2713">    if (dist &gt; 2)</a>
<a name="ln2714">        return false;</a>
<a name="ln2715"> </a>
<a name="ln2716">    // Apply fuzz now.</a>
<a name="ln2717">    coord_def fuzz;</a>
<a name="ln2718">    fuzz.x = random_range(-2, 2);</a>
<a name="ln2719">    fuzz.y = random_range(-2, 2);</a>
<a name="ln2720">    coord_def newtarget = target + fuzz;</a>
<a name="ln2721"> </a>
<a name="ln2722">    if (in_bounds(newtarget))</a>
<a name="ln2723">        target = newtarget;</a>
<a name="ln2724"> </a>
<a name="ln2725">    // Fire away!</a>
<a name="ln2726">    return true;</a>
<a name="ln2727">}</a>
<a name="ln2728"> </a>
<a name="ln2729">// A first step towards to-hit sanity for beams. We're still being</a>
<a name="ln2730">// very kind to the player, but it should be fairer to monsters than</a>
<a name="ln2731">// 4.0.</a>
<a name="ln2732">static bool _test_beam_hit(int attack, int defence, bool pierce,</a>
<a name="ln2733">                           bool repel, defer_rand &amp;r)</a>
<a name="ln2734">{</a>
<a name="ln2735">    if (attack == AUTOMATIC_HIT)</a>
<a name="ln2736">        return true;</a>
<a name="ln2737"> </a>
<a name="ln2738">    if (pierce)</a>
<a name="ln2739">    {</a>
<a name="ln2740">        if (repel &amp;&amp; attack &gt;= 2) // don't increase acc of 0</a>
<a name="ln2741">            attack = r[0].random_range((attack + 1) / 2 + 1, attack);</a>
<a name="ln2742">    }</a>
<a name="ln2743">    else if (repel)</a>
<a name="ln2744">        attack = r[0].random2(attack);</a>
<a name="ln2745"> </a>
<a name="ln2746">    dprf(DIAG_BEAM, &quot;Beam attack: %d, defence: %d&quot;, attack, defence);</a>
<a name="ln2747"> </a>
<a name="ln2748">    attack = r[1].random2(attack);</a>
<a name="ln2749">    defence = r[2].random2avg(defence, 2);</a>
<a name="ln2750"> </a>
<a name="ln2751">    dprf(DIAG_BEAM, &quot;Beam new attack: %d, defence: %d&quot;, attack, defence);</a>
<a name="ln2752"> </a>
<a name="ln2753">    return attack &gt;= defence;</a>
<a name="ln2754">}</a>
<a name="ln2755"> </a>
<a name="ln2756">bool bolt::is_harmless(const monster* mon) const</a>
<a name="ln2757">{</a>
<a name="ln2758">    // For enchantments, this is already handled in nasty_to().</a>
<a name="ln2759">    if (is_enchantment())</a>
<a name="ln2760">        return !nasty_to(mon);</a>
<a name="ln2761"> </a>
<a name="ln2762">    // The others are handled here.</a>
<a name="ln2763">    switch (flavour)</a>
<a name="ln2764">    {</a>
<a name="ln2765">    case BEAM_VISUAL:</a>
<a name="ln2766">    case BEAM_DIGGING:</a>
<a name="ln2767">        return true;</a>
<a name="ln2768"> </a>
<a name="ln2769">    case BEAM_HOLY:</a>
<a name="ln2770">        return mon-&gt;res_holy_energy() &gt;= 3;</a>
<a name="ln2771"> </a>
<a name="ln2772">    case BEAM_STEAM:</a>
<a name="ln2773">        return mon-&gt;res_steam() &gt;= 3;</a>
<a name="ln2774"> </a>
<a name="ln2775">    case BEAM_FIRE:</a>
<a name="ln2776">        return mon-&gt;res_fire() &gt;= 3;</a>
<a name="ln2777"> </a>
<a name="ln2778">    case BEAM_COLD:</a>
<a name="ln2779">        return mon-&gt;res_cold() &gt;= 3;</a>
<a name="ln2780"> </a>
<a name="ln2781">    case BEAM_MIASMA:</a>
<a name="ln2782">        return mon-&gt;res_rotting();</a>
<a name="ln2783"> </a>
<a name="ln2784">    case BEAM_NEG:</a>
<a name="ln2785">        return mon-&gt;res_negative_energy() == 3;</a>
<a name="ln2786"> </a>
<a name="ln2787">    case BEAM_ELECTRICITY:</a>
<a name="ln2788">        return mon-&gt;res_elec() &gt;= 3;</a>
<a name="ln2789"> </a>
<a name="ln2790">    case BEAM_POISON:</a>
<a name="ln2791">        return mon-&gt;res_poison() &gt;= 3;</a>
<a name="ln2792"> </a>
<a name="ln2793">    case BEAM_ACID:</a>
<a name="ln2794">        return mon-&gt;res_acid() &gt;= 3;</a>
<a name="ln2795"> </a>
<a name="ln2796">    case BEAM_MEPHITIC:</a>
<a name="ln2797">        return mon-&gt;res_poison() &gt; 0 || mon-&gt;is_unbreathing();</a>
<a name="ln2798"> </a>
<a name="ln2799">    default:</a>
<a name="ln2800">        return false;</a>
<a name="ln2801">    }</a>
<a name="ln2802">}</a>
<a name="ln2803"> </a>
<a name="ln2804">// N.b. only called for player-originated beams; if that is changed,</a>
<a name="ln2805">// be sure to adjust various assumptions based on the spells/abilities</a>
<a name="ln2806">// available to the player.</a>
<a name="ln2807">bool bolt::harmless_to_player() const</a>
<a name="ln2808">{</a>
<a name="ln2809">    dprf(DIAG_BEAM, &quot;beam flavour: %d&quot;, flavour);</a>
<a name="ln2810"> </a>
<a name="ln2811">    if (you.cloud_immune() &amp;&amp; is_big_cloud())</a>
<a name="ln2812">        return true;</a>
<a name="ln2813"> </a>
<a name="ln2814">    switch (flavour)</a>
<a name="ln2815">    {</a>
<a name="ln2816">    case BEAM_VISUAL:</a>
<a name="ln2817">    case BEAM_DIGGING:</a>
<a name="ln2818">        return true;</a>
<a name="ln2819"> </a>
<a name="ln2820">    // Positive enchantments.</a>
<a name="ln2821">    case BEAM_HASTE:</a>
<a name="ln2822">    case BEAM_HEALING:</a>
<a name="ln2823">    case BEAM_MIGHT:</a>
<a name="ln2824">    case BEAM_AGILITY:</a>
<a name="ln2825">    case BEAM_INVISIBILITY:</a>
<a name="ln2826">    case BEAM_RESISTANCE:</a>
<a name="ln2827">        return true;</a>
<a name="ln2828"> </a>
<a name="ln2829">    case BEAM_HOLY:</a>
<a name="ln2830">        return you.res_holy_energy() &gt;= 3;</a>
<a name="ln2831"> </a>
<a name="ln2832">    case BEAM_MIASMA:</a>
<a name="ln2833">        return you.res_rotting();</a>
<a name="ln2834"> </a>
<a name="ln2835">    case BEAM_NEG:</a>
<a name="ln2836">        return player_prot_life(false) &gt;= 3;</a>
<a name="ln2837"> </a>
<a name="ln2838">    case BEAM_POISON:</a>
<a name="ln2839">        return player_res_poison(false) &gt;= 3</a>
<a name="ln2840">               || is_big_cloud() &amp;&amp; player_res_poison(false) &gt; 0;</a>
<a name="ln2841"> </a>
<a name="ln2842">    case BEAM_MEPHITIC:</a>
<a name="ln2843">        // With clarity, meph still does a tiny amount of damage (1d3 - 1).</a>
<a name="ln2844">        // Normally we'd just ignore it, but we shouldn't let a player</a>
<a name="ln2845">        // kill themselves without a warning.</a>
<a name="ln2846">        return player_res_poison(false) &gt; 0 || you.is_unbreathing()</a>
<a name="ln2847">            || you.clarity(false) &amp;&amp; you.hp &gt; 2;</a>
<a name="ln2848"> </a>
<a name="ln2849">    case BEAM_ELECTRICITY:</a>
<a name="ln2850">        return player_res_electricity(false);</a>
<a name="ln2851"> </a>
<a name="ln2852">    case BEAM_PETRIFY:</a>
<a name="ln2853">        return you.res_petrify() || you.petrified();</a>
<a name="ln2854"> </a>
<a name="ln2855">    case BEAM_COLD:</a>
<a name="ln2856">        return is_big_cloud() &amp;&amp; you.has_mutation(MUT_FREEZING_CLOUD_IMMUNITY);</a>
<a name="ln2857"> </a>
<a name="ln2858">    case BEAM_VIRULENCE:</a>
<a name="ln2859">        return player_res_poison(false) &gt;= 3;</a>
<a name="ln2860"> </a>
<a name="ln2861">    default:</a>
<a name="ln2862">        return false;</a>
<a name="ln2863">    }</a>
<a name="ln2864">}</a>
<a name="ln2865"> </a>
<a name="ln2866">bool bolt::is_reflectable(const actor &amp;whom) const</a>
<a name="ln2867">{</a>
<a name="ln2868">    if (range_used() &gt; range)</a>
<a name="ln2869">        return false;</a>
<a name="ln2870"> </a>
<a name="ln2871">    const item_def *it = whom.shield();</a>
<a name="ln2872">    return (it &amp;&amp; is_shield(*it) &amp;&amp; shield_reflects(*it)) || whom.reflection();</a>
<a name="ln2873">}</a>
<a name="ln2874"> </a>
<a name="ln2875">bool bolt::is_big_cloud() const</a>
<a name="ln2876">{</a>
<a name="ln2877">    return testbits(get_spell_flags(origin_spell), spflag::cloud);</a>
<a name="ln2878">}</a>
<a name="ln2879"> </a>
<a name="ln2880">coord_def bolt::leg_source() const</a>
<a name="ln2881">{</a>
<a name="ln2882">    if (bounces &gt; 0 &amp;&amp; map_bounds(bounce_pos))</a>
<a name="ln2883">        return bounce_pos;</a>
<a name="ln2884">    else</a>
<a name="ln2885">        return source;</a>
<a name="ln2886">}</a>
<a name="ln2887"> </a>
<a name="ln2888">// Reflect a beam back the direction it came. This is used</a>
<a name="ln2889">// by shields of reflection.</a>
<a name="ln2890">void bolt::reflect()</a>
<a name="ln2891">{</a>
<a name="ln2892">    reflections++;</a>
<a name="ln2893"> </a>
<a name="ln2894">    target = leg_source();</a>
<a name="ln2895">    source = pos();</a>
<a name="ln2896"> </a>
<a name="ln2897">    // Reset bounce_pos, so that if we somehow reflect again before reaching</a>
<a name="ln2898">    // the wall that we won't keep heading towards the wall.</a>
<a name="ln2899">    bounce_pos.reset();</a>
<a name="ln2900"> </a>
<a name="ln2901">    if (pos() == you.pos())</a>
<a name="ln2902">    {</a>
<a name="ln2903">        reflector = MID_PLAYER;</a>
<a name="ln2904">        count_action(CACT_BLOCK, -1, BLOCK_REFLECT);</a>
<a name="ln2905">    }</a>
<a name="ln2906">    else if (monster* m = monster_at(pos()))</a>
<a name="ln2907">        reflector = m-&gt;mid;</a>
<a name="ln2908">    else</a>
<a name="ln2909">    {</a>
<a name="ln2910">        reflector = MID_NOBODY;</a>
<a name="ln2911">#ifdef DEBUG</a>
<a name="ln2912">        dprf(DIAG_BEAM, &quot;Bolt reflected by neither player nor &quot;</a>
<a name="ln2913">             &quot;monster (bolt = %s, item = %s)&quot;, name.c_str(),</a>
<a name="ln2914">             item ? item-&gt;name(DESC_PLAIN).c_str() : &quot;none&quot;);</a>
<a name="ln2915">#endif</a>
<a name="ln2916">    }</a>
<a name="ln2917"> </a>
<a name="ln2918">    flavour = real_flavour;</a>
<a name="ln2919">    choose_ray();</a>
<a name="ln2920">}</a>
<a name="ln2921"> </a>
<a name="ln2922">void bolt::tracer_affect_player()</a>
<a name="ln2923">{</a>
<a name="ln2924">    if (flavour == BEAM_UNRAVELLING &amp;&amp; player_is_debuffable())</a>
<a name="ln2925">        is_explosion = true;</a>
<a name="ln2926"> </a>
<a name="ln2927">    // Check whether thrower can see player, unless thrower == player.</a>
<a name="ln2928">    if (YOU_KILL(thrower))</a>
<a name="ln2929">    {</a>
<a name="ln2930">        if (!dont_stop_player &amp;&amp; !harmless_to_player())</a>
<a name="ln2931">        {</a>
<a name="ln2932">            string prompt = make_stringf(&quot;That %s is likely to hit you. Continue anyway?&quot;,</a>
<a name="ln2933">                                         item ? name.c_str() : &quot;beam&quot;);</a>
<a name="ln2934"> </a>
<a name="ln2935">            if (yesno(prompt.c_str(), false, 'n'))</a>
<a name="ln2936">            {</a>
<a name="ln2937">                friend_info.count++;</a>
<a name="ln2938">                friend_info.power += you.experience_level;</a>
<a name="ln2939">                // Don't ask about aiming at ourself twice.</a>
<a name="ln2940">                dont_stop_player = true;</a>
<a name="ln2941">            }</a>
<a name="ln2942">            else</a>
<a name="ln2943">            {</a>
<a name="ln2944">                canned_msg(MSG_OK);</a>
<a name="ln2945">                beam_cancelled = true;</a>
<a name="ln2946">                finish_beam();</a>
<a name="ln2947">            }</a>
<a name="ln2948">        }</a>
<a name="ln2949">    }</a>
<a name="ln2950">    else if (can_see_invis || !you.invisible() || fuzz_invis_tracer())</a>
<a name="ln2951">    {</a>
<a name="ln2952">        if (mons_att_wont_attack(attitude))</a>
<a name="ln2953">        {</a>
<a name="ln2954">            friend_info.count++;</a>
<a name="ln2955">            friend_info.power += you.experience_level;</a>
<a name="ln2956">        }</a>
<a name="ln2957">        else</a>
<a name="ln2958">        {</a>
<a name="ln2959">            foe_info.count++;</a>
<a name="ln2960">            foe_info.power += you.experience_level;</a>
<a name="ln2961">        }</a>
<a name="ln2962">    }</a>
<a name="ln2963"> </a>
<a name="ln2964">    extra_range_used += range_used_on_hit();</a>
<a name="ln2965">}</a>
<a name="ln2966"> </a>
<a name="ln2967">/* Determine whether the beam hit or missed the player, and tell them if it</a>
<a name="ln2968"> * missed.</a>
<a name="ln2969"> *</a>
<a name="ln2970"> * @return  true if the beam missed, false if the beam hit the player.</a>
<a name="ln2971"> */</a>
<a name="ln2972">bool bolt::misses_player()</a>
<a name="ln2973">{</a>
<a name="ln2974">    if (flavour == BEAM_VISUAL)</a>
<a name="ln2975">        return true;</a>
<a name="ln2976"> </a>
<a name="ln2977">    if (is_explosion || aimed_at_feet || auto_hit)</a>
<a name="ln2978">        return false;</a>
<a name="ln2979"> </a>
<a name="ln2980">    const int dodge = you.evasion();</a>
<a name="ln2981">    int real_tohit  = hit;</a>
<a name="ln2982"> </a>
<a name="ln2983">    if (real_tohit != AUTOMATIC_HIT)</a>
<a name="ln2984">    {</a>
<a name="ln2985">        // Monsters shooting at an invisible player are very inaccurate.</a>
<a name="ln2986">        if (you.invisible() &amp;&amp; !can_see_invis)</a>
<a name="ln2987">            real_tohit /= 2;</a>
<a name="ln2988"> </a>
<a name="ln2989">        // Backlit is easier to hit:</a>
<a name="ln2990">        if (you.backlit(false))</a>
<a name="ln2991">            real_tohit += 2 + random2(8);</a>
<a name="ln2992"> </a>
<a name="ln2993">        // Umbra is harder to hit:</a>
<a name="ln2994">        if (!nightvision &amp;&amp; you.umbra())</a>
<a name="ln2995">            real_tohit -= 2 + random2(4);</a>
<a name="ln2996">    }</a>
<a name="ln2997"> </a>
<a name="ln2998">    const int SH = player_shield_class();</a>
<a name="ln2999">    if ((player_omnireflects() &amp;&amp; is_omnireflectable()</a>
<a name="ln3000">         || is_blockable())</a>
<a name="ln3001">        &amp;&amp; you.shielded()</a>
<a name="ln3002">        &amp;&amp; !aimed_at_feet</a>
<a name="ln3003">        &amp;&amp; SH &gt; 0)</a>
<a name="ln3004">    {</a>
<a name="ln3005">        // We use the original to-hit here.</a>
<a name="ln3006">        // (so that effects increasing dodge chance don't increase block...?)</a>
<a name="ln3007">        const int testhit = random2(hit * 130 / 100</a>
<a name="ln3008">                                    + you.shield_block_penalty());</a>
<a name="ln3009"> </a>
<a name="ln3010">        const int block = you.shield_bonus();</a>
<a name="ln3011"> </a>
<a name="ln3012">        // 50% chance of blocking ench-type effects at 20 displayed sh</a>
<a name="ln3013">        const bool omnireflected</a>
<a name="ln3014">            = hit == AUTOMATIC_HIT</a>
<a name="ln3015">              &amp;&amp; x_chance_in_y(SH, omnireflect_chance_denom(SH));</a>
<a name="ln3016"> </a>
<a name="ln3017">        dprf(DIAG_BEAM, &quot;Beamshield: hit: %d, block %d&quot;, testhit, block);</a>
<a name="ln3018">        if ((testhit &lt; block &amp;&amp; hit != AUTOMATIC_HIT) || omnireflected)</a>
<a name="ln3019">        {</a>
<a name="ln3020">            const string refl_name = name.empty() &amp;&amp;</a>
<a name="ln3021">                                     origin_spell != SPELL_NO_SPELL ?</a>
<a name="ln3022">                                        spell_title(origin_spell) :</a>
<a name="ln3023">                                        name;</a>
<a name="ln3024"> </a>
<a name="ln3025">            const item_def *shield = you.shield();</a>
<a name="ln3026">            if (is_reflectable(you))</a>
<a name="ln3027">            {</a>
<a name="ln3028">                if (shield &amp;&amp; is_shield(*shield) &amp;&amp; shield_reflects(*shield))</a>
<a name="ln3029">                {</a>
<a name="ln3030">                    mprf(&quot;Your %s reflects the %s!&quot;,</a>
<a name="ln3031">                            shield-&gt;name(DESC_PLAIN).c_str(),</a>
<a name="ln3032">                            refl_name.c_str());</a>
<a name="ln3033">                }</a>
<a name="ln3034">                else</a>
<a name="ln3035">                {</a>
<a name="ln3036">                    mprf(&quot;The %s reflects off an invisible shield around you!&quot;,</a>
<a name="ln3037">                            refl_name.c_str());</a>
<a name="ln3038">                }</a>
<a name="ln3039">                reflect();</a>
<a name="ln3040">            }</a>
<a name="ln3041">            else</a>
<a name="ln3042">            {</a>
<a name="ln3043">                mprf(&quot;You block the %s.&quot;, name.c_str());</a>
<a name="ln3044">                finish_beam();</a>
<a name="ln3045">            }</a>
<a name="ln3046">            you.shield_block_succeeded(agent());</a>
<a name="ln3047">            return true;</a>
<a name="ln3048">        }</a>
<a name="ln3049"> </a>
<a name="ln3050">        // Some training just for the &quot;attempt&quot;.</a>
<a name="ln3051">        practise_shield_block(false);</a>
<a name="ln3052">    }</a>
<a name="ln3053"> </a>
<a name="ln3054">    if (is_enchantment())</a>
<a name="ln3055">        return false;</a>
<a name="ln3056"> </a>
<a name="ln3057">    if (!aimed_at_feet)</a>
<a name="ln3058">        practise_being_shot_at();</a>
<a name="ln3059"> </a>
<a name="ln3060">    defer_rand r;</a>
<a name="ln3061"> </a>
<a name="ln3062">    bool repel = you.missile_repulsion();</a>
<a name="ln3063"> </a>
<a name="ln3064">    if (!_test_beam_hit(real_tohit, dodge, pierce, 0, r))</a>
<a name="ln3065">    {</a>
<a name="ln3066">        mprf(&quot;The %s misses you.&quot;, name.c_str());</a>
<a name="ln3067">        count_action(CACT_DODGE, DODGE_EVASION);</a>
<a name="ln3068">    }</a>
<a name="ln3069">    else if (repel &amp;&amp; !_test_beam_hit(real_tohit, dodge, pierce, repel, r))</a>
<a name="ln3070">    {</a>
<a name="ln3071">        mprf(&quot;The %s is repelled.&quot;, name.c_str());</a>
<a name="ln3072">        count_action(CACT_DODGE, DODGE_REPEL);</a>
<a name="ln3073">    }</a>
<a name="ln3074">    else</a>
<a name="ln3075">        return false;</a>
<a name="ln3076"> </a>
<a name="ln3077">    return true;</a>
<a name="ln3078">}</a>
<a name="ln3079"> </a>
<a name="ln3080">void bolt::affect_player_enchantment(bool resistible)</a>
<a name="ln3081">{</a>
<a name="ln3082">    if (resistible</a>
<a name="ln3083">        &amp;&amp; has_saving_throw()</a>
<a name="ln3084">        &amp;&amp; you.check_res_magic(ench_power) &gt; 0)</a>
<a name="ln3085">    {</a>
<a name="ln3086">        // You resisted it.</a>
<a name="ln3087"> </a>
<a name="ln3088">        // Give a message.</a>
<a name="ln3089">        bool need_msg = true;</a>
<a name="ln3090">        if (thrower != KILL_YOU_MISSILE)</a>
<a name="ln3091">        {</a>
<a name="ln3092">            const monster* mon = monster_by_mid(source_id);</a>
<a name="ln3093">            if (mon &amp;&amp; !mon-&gt;observable())</a>
<a name="ln3094">            {</a>
<a name="ln3095">                mprf(&quot;Something tries to affect you, but you %s.&quot;,</a>
<a name="ln3096">                     you.res_magic() == MAG_IMMUNE ? &quot;are unaffected&quot;</a>
<a name="ln3097">                                                   : &quot;resist&quot;);</a>
<a name="ln3098">                need_msg = false;</a>
<a name="ln3099">            }</a>
<a name="ln3100">        }</a>
<a name="ln3101">        if (need_msg)</a>
<a name="ln3102">        {</a>
<a name="ln3103">            if (you.res_magic() == MAG_IMMUNE)</a>
<a name="ln3104">                canned_msg(MSG_YOU_UNAFFECTED);</a>
<a name="ln3105">            else</a>
<a name="ln3106">            {</a>
<a name="ln3107">                // the message reflects the level of difficulty resisting.</a>
<a name="ln3108">                const int margin = you.res_magic() - ench_power;</a>
<a name="ln3109">                mprf(&quot;You%s&quot;, you.resist_margin_phrase(margin).c_str());</a>
<a name="ln3110">            }</a>
<a name="ln3111">        }</a>
<a name="ln3112">        // You *could* have gotten a free teleportation in the Abyss,</a>
<a name="ln3113">        // but no, you resisted.</a>
<a name="ln3114">        if (flavour == BEAM_TELEPORT &amp;&amp; player_in_branch(BRANCH_ABYSS))</a>
<a name="ln3115">            xom_is_stimulated(200);</a>
<a name="ln3116"> </a>
<a name="ln3117">        extra_range_used += range_used_on_hit();</a>
<a name="ln3118">        return;</a>
<a name="ln3119">    }</a>
<a name="ln3120"> </a>
<a name="ln3121">    // Never affects the player.</a>
<a name="ln3122">    if (flavour == BEAM_INFESTATION || flavour == BEAM_VILE_CLUTCH)</a>
<a name="ln3123">        return;</a>
<a name="ln3124"> </a>
<a name="ln3125">    // You didn't resist it.</a>
<a name="ln3126">    if (animate)</a>
<a name="ln3127">        _ench_animation(effect_known ? real_flavour : BEAM_MAGIC);</a>
<a name="ln3128"> </a>
<a name="ln3129">    bool nasty = true, nice = false;</a>
<a name="ln3130"> </a>
<a name="ln3131">    const bool blame_player = god_cares() &amp;&amp; YOU_KILL(thrower);</a>
<a name="ln3132"> </a>
<a name="ln3133">    switch (flavour)</a>
<a name="ln3134">    {</a>
<a name="ln3135">    case BEAM_HIBERNATION:</a>
<a name="ln3136">    case BEAM_SLEEP:</a>
<a name="ln3137">        you.put_to_sleep(nullptr, ench_power, flavour == BEAM_HIBERNATION);</a>
<a name="ln3138">        break;</a>
<a name="ln3139"> </a>
<a name="ln3140">    case BEAM_CORONA:</a>
<a name="ln3141">        you.backlight();</a>
<a name="ln3142">        obvious_effect = true;</a>
<a name="ln3143">        break;</a>
<a name="ln3144"> </a>
<a name="ln3145">    case BEAM_POLYMORPH:</a>
<a name="ln3146">        obvious_effect = you.polymorph(ench_power);</a>
<a name="ln3147">        break;</a>
<a name="ln3148"> </a>
<a name="ln3149">    case BEAM_MALMUTATE:</a>
<a name="ln3150">    case BEAM_UNRAVELLED_MAGIC:</a>
<a name="ln3151">        mpr(&quot;Strange energies course through your body.&quot;);</a>
<a name="ln3152">        you.malmutate(aux_source.empty() ? get_source_name() :</a>
<a name="ln3153">                      (get_source_name() + &quot;/&quot; + aux_source));</a>
<a name="ln3154">        obvious_effect = true;</a>
<a name="ln3155">        break;</a>
<a name="ln3156"> </a>
<a name="ln3157">    case BEAM_SLOW:</a>
<a name="ln3158">        slow_player(10 + random2(ench_power));</a>
<a name="ln3159">        obvious_effect = true;</a>
<a name="ln3160">        break;</a>
<a name="ln3161"> </a>
<a name="ln3162">    case BEAM_HASTE:</a>
<a name="ln3163">        haste_player(40 + random2(ench_power));</a>
<a name="ln3164">        did_god_conduct(DID_HASTY, 10, blame_player);</a>
<a name="ln3165">        obvious_effect = true;</a>
<a name="ln3166">        nasty = false;</a>
<a name="ln3167">        nice  = true;</a>
<a name="ln3168">        break;</a>
<a name="ln3169"> </a>
<a name="ln3170">    case BEAM_HEALING:</a>
<a name="ln3171">        potionlike_effect(POT_HEAL_WOUNDS, ench_power, true);</a>
<a name="ln3172">        obvious_effect = true;</a>
<a name="ln3173">        nasty = false;</a>
<a name="ln3174">        nice  = true;</a>
<a name="ln3175">        break;</a>
<a name="ln3176"> </a>
<a name="ln3177">    case BEAM_MIGHT:</a>
<a name="ln3178">        potionlike_effect(POT_MIGHT, ench_power);</a>
<a name="ln3179">        obvious_effect = true;</a>
<a name="ln3180">        nasty = false;</a>
<a name="ln3181">        nice  = true;</a>
<a name="ln3182">        break;</a>
<a name="ln3183"> </a>
<a name="ln3184">    case BEAM_INVISIBILITY:</a>
<a name="ln3185">        you.attribute[ATTR_INVIS_UNCANCELLABLE] = 1;</a>
<a name="ln3186">        potionlike_effect(POT_INVISIBILITY, ench_power);</a>
<a name="ln3187">        contaminate_player(1000 + random2(1000), blame_player);</a>
<a name="ln3188">        obvious_effect = true;</a>
<a name="ln3189">        nasty = false;</a>
<a name="ln3190">        nice  = true;</a>
<a name="ln3191">        break;</a>
<a name="ln3192"> </a>
<a name="ln3193">    case BEAM_PARALYSIS:</a>
<a name="ln3194">        you.paralyse(agent(), 2 + random2(6));</a>
<a name="ln3195">        obvious_effect = true;</a>
<a name="ln3196">        break;</a>
<a name="ln3197"> </a>
<a name="ln3198">    case BEAM_PETRIFY:</a>
<a name="ln3199">        you.petrify(agent());</a>
<a name="ln3200">        obvious_effect = true;</a>
<a name="ln3201">        break;</a>
<a name="ln3202"> </a>
<a name="ln3203">    case BEAM_CONFUSION:</a>
<a name="ln3204">        confuse_player(5 + random2(3));</a>
<a name="ln3205">        obvious_effect = true;</a>
<a name="ln3206">        break;</a>
<a name="ln3207"> </a>
<a name="ln3208">    case BEAM_TELEPORT:</a>
<a name="ln3209">        you_teleport();</a>
<a name="ln3210"> </a>
<a name="ln3211">        // An enemy helping you escape while in the Abyss, or an</a>
<a name="ln3212">        // enemy stabilizing a teleport that was about to happen.</a>
<a name="ln3213">        if (!mons_att_wont_attack(attitude) &amp;&amp; player_in_branch(BRANCH_ABYSS))</a>
<a name="ln3214">            xom_is_stimulated(200);</a>
<a name="ln3215"> </a>
<a name="ln3216">        obvious_effect = true;</a>
<a name="ln3217">        break;</a>
<a name="ln3218"> </a>
<a name="ln3219">    case BEAM_BLINK:</a>
<a name="ln3220">        uncontrolled_blink();</a>
<a name="ln3221">        obvious_effect = true;</a>
<a name="ln3222">        break;</a>
<a name="ln3223"> </a>
<a name="ln3224">    case BEAM_BLINK_CLOSE:</a>
<a name="ln3225">        blink_other_close(&amp;you, source);</a>
<a name="ln3226">        obvious_effect = true;</a>
<a name="ln3227">        break;</a>
<a name="ln3228"> </a>
<a name="ln3229">    case BEAM_BECKONING:</a>
<a name="ln3230">        obvious_effect = beckon(you, *this);</a>
<a name="ln3231">        break;</a>
<a name="ln3232"> </a>
<a name="ln3233">    case BEAM_ENSLAVE:</a>
<a name="ln3234">        mprf(MSGCH_WARN, &quot;Your will is overpowered!&quot;);</a>
<a name="ln3235">        confuse_player(5 + random2(3));</a>
<a name="ln3236">        obvious_effect = true;</a>
<a name="ln3237">        break;     // enslavement - confusion?</a>
<a name="ln3238"> </a>
<a name="ln3239">    case BEAM_BANISH:</a>
<a name="ln3240">        if (YOU_KILL(thrower))</a>
<a name="ln3241">        {</a>
<a name="ln3242">            mpr(&quot;This spell isn't strong enough to banish yourself.&quot;);</a>
<a name="ln3243">            break;</a>
<a name="ln3244">        }</a>
<a name="ln3245">        you.banish(agent(), get_source_name(),</a>
<a name="ln3246">                   agent()-&gt;get_experience_level());</a>
<a name="ln3247">        obvious_effect = true;</a>
<a name="ln3248">        break;</a>
<a name="ln3249"> </a>
<a name="ln3250">    case BEAM_PAIN:</a>
<a name="ln3251">    {</a>
<a name="ln3252">        if (aux_source.empty())</a>
<a name="ln3253">            aux_source = &quot;by nerve-wracking pain&quot;;</a>
<a name="ln3254"> </a>
<a name="ln3255">        const int dam = resist_adjust_damage(&amp;you, flavour, damage.roll());</a>
<a name="ln3256">        if (dam)</a>
<a name="ln3257">        {</a>
<a name="ln3258">            mpr(&quot;Pain shoots through your body!&quot;);</a>
<a name="ln3259">            internal_ouch(dam);</a>
<a name="ln3260">            obvious_effect = true;</a>
<a name="ln3261">        }</a>
<a name="ln3262">        else</a>
<a name="ln3263">            canned_msg(MSG_YOU_UNAFFECTED);</a>
<a name="ln3264">        break;</a>
<a name="ln3265">    }</a>
<a name="ln3266"> </a>
<a name="ln3267">    case BEAM_AGONY:</a>
<a name="ln3268">        torment_player(agent(), TORMENT_AGONY);</a>
<a name="ln3269">        obvious_effect = true;</a>
<a name="ln3270">        break;</a>
<a name="ln3271"> </a>
<a name="ln3272">    case BEAM_DISPEL_UNDEAD:</a>
<a name="ln3273">        if (you.undead_state() == US_ALIVE)</a>
<a name="ln3274">        {</a>
<a name="ln3275">            canned_msg(MSG_YOU_UNAFFECTED);</a>
<a name="ln3276">            break;</a>
<a name="ln3277">        }</a>
<a name="ln3278"> </a>
<a name="ln3279">        mpr(&quot;You convulse!&quot;);</a>
<a name="ln3280"> </a>
<a name="ln3281">        if (aux_source.empty())</a>
<a name="ln3282">            aux_source = &quot;by dispel undead&quot;;</a>
<a name="ln3283"> </a>
<a name="ln3284">        internal_ouch(damage.roll());</a>
<a name="ln3285">        obvious_effect = true;</a>
<a name="ln3286">        break;</a>
<a name="ln3287"> </a>
<a name="ln3288">    case BEAM_DISINTEGRATION:</a>
<a name="ln3289">        mpr(&quot;You are blasted!&quot;);</a>
<a name="ln3290"> </a>
<a name="ln3291">        if (aux_source.empty())</a>
<a name="ln3292">            aux_source = &quot;disintegration bolt&quot;;</a>
<a name="ln3293"> </a>
<a name="ln3294">        {</a>
<a name="ln3295">            int amt = damage.roll();</a>
<a name="ln3296">            internal_ouch(amt);</a>
<a name="ln3297"> </a>
<a name="ln3298">            if (you.can_bleed())</a>
<a name="ln3299">                blood_spray(you.pos(), MONS_PLAYER, amt / 5);</a>
<a name="ln3300">        }</a>
<a name="ln3301"> </a>
<a name="ln3302">        obvious_effect = true;</a>
<a name="ln3303">        break;</a>
<a name="ln3304"> </a>
<a name="ln3305">    case BEAM_PORKALATOR:</a>
<a name="ln3306">        if (!transform(ench_power, transformation::pig, true))</a>
<a name="ln3307">        {</a>
<a name="ln3308">            mpr(&quot;You feel a momentary urge to oink.&quot;);</a>
<a name="ln3309">            break;</a>
<a name="ln3310">        }</a>
<a name="ln3311"> </a>
<a name="ln3312">        you.transform_uncancellable = true;</a>
<a name="ln3313">        obvious_effect = true;</a>
<a name="ln3314">        break;</a>
<a name="ln3315"> </a>
<a name="ln3316">    case BEAM_BERSERK:</a>
<a name="ln3317">        you.go_berserk(blame_player);</a>
<a name="ln3318">        obvious_effect = true;</a>
<a name="ln3319">        break;</a>
<a name="ln3320"> </a>
<a name="ln3321">    case BEAM_SENTINEL_MARK:</a>
<a name="ln3322">        you.sentinel_mark();</a>
<a name="ln3323">        obvious_effect = true;</a>
<a name="ln3324">        break;</a>
<a name="ln3325"> </a>
<a name="ln3326">    case BEAM_DIMENSION_ANCHOR:</a>
<a name="ln3327">        mprf(&quot;You feel %sfirmly anchored in space.&quot;,</a>
<a name="ln3328">             you.duration[DUR_DIMENSION_ANCHOR] ? &quot;more &quot; : &quot;&quot;);</a>
<a name="ln3329">        you.increase_duration(DUR_DIMENSION_ANCHOR, 12 + random2(15), 50);</a>
<a name="ln3330">        if (you.duration[DUR_TELEPORT])</a>
<a name="ln3331">        {</a>
<a name="ln3332">            you.duration[DUR_TELEPORT] = 0;</a>
<a name="ln3333">            mpr(&quot;Your teleport is interrupted.&quot;);</a>
<a name="ln3334">        }</a>
<a name="ln3335">        you.redraw_evasion = true;</a>
<a name="ln3336">        obvious_effect = true;</a>
<a name="ln3337">        break;</a>
<a name="ln3338"> </a>
<a name="ln3339">    case BEAM_VULNERABILITY:</a>
<a name="ln3340">        if (!you.duration[DUR_LOWERED_MR])</a>
<a name="ln3341">            mpr(&quot;Your magical defenses are stripped away!&quot;);</a>
<a name="ln3342">        you.increase_duration(DUR_LOWERED_MR, 12 + random2(18), 50);</a>
<a name="ln3343">        obvious_effect = true;</a>
<a name="ln3344">        break;</a>
<a name="ln3345"> </a>
<a name="ln3346">    case BEAM_MALIGN_OFFERING:</a>
<a name="ln3347">    {</a>
<a name="ln3348">        const int dam = resist_adjust_damage(&amp;you, flavour, damage.roll());</a>
<a name="ln3349">        if (dam)</a>
<a name="ln3350">        {</a>
<a name="ln3351">            _malign_offering_effect(&amp;you, agent(), dam);</a>
<a name="ln3352">            obvious_effect = true;</a>
<a name="ln3353">        }</a>
<a name="ln3354">        else</a>
<a name="ln3355">            canned_msg(MSG_YOU_UNAFFECTED);</a>
<a name="ln3356">        break;</a>
<a name="ln3357">    }</a>
<a name="ln3358"> </a>
<a name="ln3359">    case BEAM_VIRULENCE:</a>
<a name="ln3360">        // Those completely immune cannot be made more susceptible this way</a>
<a name="ln3361">        if (you.res_poison(false) &gt;= 3)</a>
<a name="ln3362">        {</a>
<a name="ln3363">            canned_msg(MSG_YOU_UNAFFECTED);</a>
<a name="ln3364">            break;</a>
<a name="ln3365">        }</a>
<a name="ln3366"> </a>
<a name="ln3367">        mpr(&quot;You feel yourself grow more vulnerable to poison.&quot;);</a>
<a name="ln3368">        you.increase_duration(DUR_POISON_VULN, 12 + random2(18), 50);</a>
<a name="ln3369">        obvious_effect = true;</a>
<a name="ln3370">        break;</a>
<a name="ln3371"> </a>
<a name="ln3372">    case BEAM_AGILITY:</a>
<a name="ln3373">        you.be_agile(ench_power);</a>
<a name="ln3374">        obvious_effect = true;</a>
<a name="ln3375">        nasty = false;</a>
<a name="ln3376">        nice  = true;</a>
<a name="ln3377">        break;</a>
<a name="ln3378"> </a>
<a name="ln3379">    case BEAM_SAP_MAGIC:</a>
<a name="ln3380">        if (!SAP_MAGIC_CHANCE())</a>
<a name="ln3381">        {</a>
<a name="ln3382">            canned_msg(MSG_NOTHING_HAPPENS);</a>
<a name="ln3383">            break;</a>
<a name="ln3384">        }</a>
<a name="ln3385">        mprf(MSGCH_WARN, &quot;Your magic feels %stainted.&quot;,</a>
<a name="ln3386">             you.duration[DUR_SAP_MAGIC] ? &quot;more &quot; : &quot;&quot;);</a>
<a name="ln3387">        you.increase_duration(DUR_SAP_MAGIC, random_range(20, 30), 50);</a>
<a name="ln3388">        break;</a>
<a name="ln3389"> </a>
<a name="ln3390">    case BEAM_DRAIN_MAGIC:</a>
<a name="ln3391">    {</a>
<a name="ln3392">        int amount = min(you.magic_points, random2avg(ench_power / 8, 3));</a>
<a name="ln3393">        if (!amount)</a>
<a name="ln3394">            break;</a>
<a name="ln3395">        mprf(MSGCH_WARN, &quot;You feel your power leaking away.&quot;);</a>
<a name="ln3396">        dec_mp(amount);</a>
<a name="ln3397">        if (agent() &amp;&amp; (agent()-&gt;type == MONS_EYE_OF_DRAINING</a>
<a name="ln3398">                        || agent()-&gt;type == MONS_GHOST_MOTH))</a>
<a name="ln3399">        {</a>
<a name="ln3400">            agent()-&gt;heal(amount);</a>
<a name="ln3401">        }</a>
<a name="ln3402">        obvious_effect = true;</a>
<a name="ln3403">        break;</a>
<a name="ln3404">    }</a>
<a name="ln3405"> </a>
<a name="ln3406">    case BEAM_TUKIMAS_DANCE:</a>
<a name="ln3407">        cast_tukimas_dance(ench_power, &amp;you);</a>
<a name="ln3408">        obvious_effect = true;</a>
<a name="ln3409">        break;</a>
<a name="ln3410"> </a>
<a name="ln3411">    case BEAM_RESISTANCE:</a>
<a name="ln3412">        potionlike_effect(POT_RESISTANCE, min(ench_power, 200));</a>
<a name="ln3413">        obvious_effect = true;</a>
<a name="ln3414">        nasty = false;</a>
<a name="ln3415">        nice  = true;</a>
<a name="ln3416">        break;</a>
<a name="ln3417"> </a>
<a name="ln3418">    case BEAM_UNRAVELLING:</a>
<a name="ln3419">        if (!player_is_debuffable())</a>
<a name="ln3420">            break;</a>
<a name="ln3421"> </a>
<a name="ln3422">        debuff_player();</a>
<a name="ln3423">        _unravelling_explode(*this);</a>
<a name="ln3424">        obvious_effect = true;</a>
<a name="ln3425">        break;</a>
<a name="ln3426"> </a>
<a name="ln3427">    default:</a>
<a name="ln3428">        // _All_ enchantments should be enumerated here!</a>
<a name="ln3429">        mpr(&quot;Software bugs nibble your toes!&quot;);</a>
<a name="ln3430">        break;</a>
<a name="ln3431">    }</a>
<a name="ln3432"> </a>
<a name="ln3433">    if (nasty)</a>
<a name="ln3434">    {</a>
<a name="ln3435">        if (mons_att_wont_attack(attitude))</a>
<a name="ln3436">        {</a>
<a name="ln3437">            friend_info.hurt++;</a>
<a name="ln3438">            if (source_id == MID_PLAYER)</a>
<a name="ln3439">            {</a>
<a name="ln3440">                // Beam from player rebounded and hit player.</a>
<a name="ln3441">                if (!aimed_at_feet)</a>
<a name="ln3442">                    xom_is_stimulated(200);</a>
<a name="ln3443">            }</a>
<a name="ln3444">            else</a>
<a name="ln3445">            {</a>
<a name="ln3446">                // Beam from an ally or neutral.</a>
<a name="ln3447">                xom_is_stimulated(100);</a>
<a name="ln3448">            }</a>
<a name="ln3449">        }</a>
<a name="ln3450">        else</a>
<a name="ln3451">            foe_info.hurt++;</a>
<a name="ln3452">    }</a>
<a name="ln3453">    else if (nice)</a>
<a name="ln3454">    {</a>
<a name="ln3455">        if (mons_att_wont_attack(attitude))</a>
<a name="ln3456">            friend_info.helped++;</a>
<a name="ln3457">        else</a>
<a name="ln3458">        {</a>
<a name="ln3459">            foe_info.helped++;</a>
<a name="ln3460">            xom_is_stimulated(100);</a>
<a name="ln3461">        }</a>
<a name="ln3462">    }</a>
<a name="ln3463"> </a>
<a name="ln3464">    // Regardless of effect, we need to know if this is a stopper</a>
<a name="ln3465">    // or not - it seems all of the above are.</a>
<a name="ln3466">    extra_range_used += range_used_on_hit();</a>
<a name="ln3467">}</a>
<a name="ln3468"> </a>
<a name="ln3469">void bolt::affect_actor(actor *act)</a>
<a name="ln3470">{</a>
<a name="ln3471">    if (act-&gt;is_monster())</a>
<a name="ln3472">        affect_monster(act-&gt;as_monster());</a>
<a name="ln3473">    else</a>
<a name="ln3474">        affect_player();</a>
<a name="ln3475">}</a>
<a name="ln3476"> </a>
<a name="ln3477">struct pie_effect</a>
<a name="ln3478">{</a>
<a name="ln3479">    const char* desc;</a>
<a name="ln3480">    function&lt;bool(const actor&amp; def)&gt; valid;</a>
<a name="ln3481">    function&lt;void (actor&amp; def, const bolt &amp;beam)&gt; effect;</a>
<a name="ln3482">    int weight;</a>
<a name="ln3483">};</a>
<a name="ln3484"> </a>
<a name="ln3485">static const vector&lt;pie_effect&gt; pie_effects = {</a>
<a name="ln3486">    {</a>
<a name="ln3487">        &quot;plum&quot;,</a>
<a name="ln3488">        [](const actor &amp;defender) {</a>
<a name="ln3489">            return defender.is_player();</a>
<a name="ln3490">        },</a>
<a name="ln3491">        [](actor &amp;/*defender*/, const bolt &amp;/*beam*/) {</a>
<a name="ln3492">            if (you.duration[DUR_VERTIGO])</a>
<a name="ln3493">                mpr(&quot;You feel your light-headedness will last longer.&quot;);</a>
<a name="ln3494">            else</a>
<a name="ln3495">                mpr(&quot;You feel light-headed.&quot;);</a>
<a name="ln3496"> </a>
<a name="ln3497">            you.increase_duration(DUR_VERTIGO, 10 + random2(11), 50);</a>
<a name="ln3498">        },</a>
<a name="ln3499">        10</a>
<a name="ln3500">    },</a>
<a name="ln3501">    {</a>
<a name="ln3502">        &quot;lemon&quot;,</a>
<a name="ln3503">        [](const actor &amp;defender) {</a>
<a name="ln3504">            return defender.is_player() &amp;&amp; !you_foodless();</a>
<a name="ln3505">        },</a>
<a name="ln3506">        [](actor &amp;/*defender*/, const bolt &amp;/*beam*/) {</a>
<a name="ln3507">            if (you.duration[DUR_NO_POTIONS])</a>
<a name="ln3508">                mpr(&quot;You feel your inability to drink will last longer.&quot;);</a>
<a name="ln3509">            else</a>
<a name="ln3510">                mpr(&quot;You feel unable to drink.&quot;);</a>
<a name="ln3511"> </a>
<a name="ln3512">            you.increase_duration(DUR_NO_POTIONS, 10 + random2(11), 50);</a>
<a name="ln3513">        },</a>
<a name="ln3514">        10</a>
<a name="ln3515">    },</a>
<a name="ln3516">    {</a>
<a name="ln3517">        &quot;blueberry&quot;,</a>
<a name="ln3518">        nullptr,</a>
<a name="ln3519">        [](actor &amp;defender, const bolt &amp;beam) {</a>
<a name="ln3520">            if (defender.is_monster())</a>
<a name="ln3521">            {</a>
<a name="ln3522">                monster *mons = defender.as_monster();</a>
<a name="ln3523">                simple_monster_message(*mons, &quot; loses the ability to speak.&quot;);</a>
<a name="ln3524">                mons-&gt;add_ench(mon_enchant(ENCH_MUTE, 0, beam.agent(),</a>
<a name="ln3525">                            4 + random2(7) * BASELINE_DELAY));</a>
<a name="ln3526">            }</a>
<a name="ln3527">            else</a>
<a name="ln3528">            {</a>
<a name="ln3529">                if (you.duration[DUR_SILENCE])</a>
<a name="ln3530">                    mpr(&quot;You feel your silence will last longer.&quot;);</a>
<a name="ln3531">                else</a>
<a name="ln3532">                    mpr(&quot;An unnatural silence engulfs you.&quot;);</a>
<a name="ln3533"> </a>
<a name="ln3534">                you.increase_duration(DUR_SILENCE, 4 + random2(7), 10);</a>
<a name="ln3535">                invalidate_agrid(true);</a>
<a name="ln3536"> </a>
<a name="ln3537">                if (you.beheld())</a>
<a name="ln3538">                    you.update_beholders();</a>
<a name="ln3539">            }</a>
<a name="ln3540">        },</a>
<a name="ln3541">        10</a>
<a name="ln3542">    },</a>
<a name="ln3543">    {</a>
<a name="ln3544">        &quot;raspberry&quot;,</a>
<a name="ln3545">        [](const actor &amp;defender) {</a>
<a name="ln3546">            return defender.is_player();</a>
<a name="ln3547">        },</a>
<a name="ln3548">        [](actor &amp;/*defender*/, const bolt &amp;/*beam*/) {</a>
<a name="ln3549">            for (int i = 0; i &lt; NUM_STATS; ++i)</a>
<a name="ln3550">                lose_stat(static_cast&lt;stat_type&gt;(i), 1 + random2(3));</a>
<a name="ln3551">        },</a>
<a name="ln3552">        10</a>
<a name="ln3553">    },</a>
<a name="ln3554">    {</a>
<a name="ln3555">        &quot;cherry&quot;,</a>
<a name="ln3556">        [](const actor &amp;defender) {</a>
<a name="ln3557">            return defender.is_player() || defender.res_fire() &lt; 3;</a>
<a name="ln3558">        },</a>
<a name="ln3559">        [](actor &amp;defender, const bolt &amp;beam) {</a>
<a name="ln3560">            if (defender.is_monster())</a>
<a name="ln3561">            {</a>
<a name="ln3562">                monster *mons = defender.as_monster();</a>
<a name="ln3563">                simple_monster_message(*mons,</a>
<a name="ln3564">                        &quot; looks more vulnerable to fire.&quot;);</a>
<a name="ln3565">                mons-&gt;add_ench(mon_enchant(ENCH_FIRE_VULN, 0,</a>
<a name="ln3566">                             beam.agent(),</a>
<a name="ln3567">                             15 + random2(11) * BASELINE_DELAY));</a>
<a name="ln3568">            }</a>
<a name="ln3569">            else</a>
<a name="ln3570">            {</a>
<a name="ln3571">                if (you.duration[DUR_FIRE_VULN])</a>
<a name="ln3572">                {</a>
<a name="ln3573">                    mpr(&quot;You feel your vulnerability to fire will last &quot;</a>
<a name="ln3574">                        &quot;longer.&quot;);</a>
<a name="ln3575">                }</a>
<a name="ln3576">                else</a>
<a name="ln3577">                    mpr(&quot;Cherry-coloured flames burn away your fire &quot;</a>
<a name="ln3578">                        &quot;resistance!&quot;);</a>
<a name="ln3579"> </a>
<a name="ln3580">                you.increase_duration(DUR_FIRE_VULN, 15 + random2(11), 50);</a>
<a name="ln3581">            }</a>
<a name="ln3582">        },</a>
<a name="ln3583">        6</a>
<a name="ln3584">    },</a>
<a name="ln3585">    {</a>
<a name="ln3586">        &quot;moon pie&quot;,</a>
<a name="ln3587">        [](const actor &amp;defender) {</a>
<a name="ln3588">            return defender.can_polymorph();</a>
<a name="ln3589">        },</a>
<a name="ln3590">        [](actor &amp;defender, const bolt &amp;/*beam*/) {</a>
<a name="ln3591">            defender.polymorph(100, false);</a>
<a name="ln3592">        },</a>
<a name="ln3593">        4</a>
<a name="ln3594">    },</a>
<a name="ln3595">};</a>
<a name="ln3596"> </a>
<a name="ln3597">static pie_effect _random_pie_effect(const actor &amp;defender)</a>
<a name="ln3598">{</a>
<a name="ln3599">    vector&lt;pair&lt;const pie_effect&amp;, int&gt;&gt; weights;</a>
<a name="ln3600">    for (const pie_effect &amp;effect : pie_effects)</a>
<a name="ln3601">        if (!effect.valid || effect.valid(defender))</a>
<a name="ln3602">            weights.push_back({effect, effect.weight});</a>
<a name="ln3603"> </a>
<a name="ln3604">    ASSERT(!weights.empty());</a>
<a name="ln3605"> </a>
<a name="ln3606">    return *random_choose_weighted(weights);</a>
<a name="ln3607">}</a>
<a name="ln3608"> </a>
<a name="ln3609">void bolt::affect_player()</a>
<a name="ln3610">{</a>
<a name="ln3611">    hit_count[MID_PLAYER]++;</a>
<a name="ln3612"> </a>
<a name="ln3613">    // Explosions only have an effect during their explosion phase.</a>
<a name="ln3614">    // Special cases can be handled here.</a>
<a name="ln3615">    if (is_explosion &amp;&amp; !in_explosion_phase)</a>
<a name="ln3616">    {</a>
<a name="ln3617">        // Trigger the explosion.</a>
<a name="ln3618">        finish_beam();</a>
<a name="ln3619">        return;</a>
<a name="ln3620">    }</a>
<a name="ln3621"> </a>
<a name="ln3622">    // Digging -- don't care.</a>
<a name="ln3623">    if (flavour == BEAM_DIGGING)</a>
<a name="ln3624">        return;</a>
<a name="ln3625"> </a>
<a name="ln3626">    if (is_tracer)</a>
<a name="ln3627">    {</a>
<a name="ln3628">        tracer_affect_player();</a>
<a name="ln3629">        return;</a>
<a name="ln3630">    }</a>
<a name="ln3631"> </a>
<a name="ln3632">    // Trigger an interrupt, so travel will stop on misses which</a>
<a name="ln3633">    // generate smoke.</a>
<a name="ln3634">    if (!YOU_KILL(thrower))</a>
<a name="ln3635">    {</a>
<a name="ln3636">        if (agent() &amp;&amp; agent()-&gt;is_monster())</a>
<a name="ln3637">        {</a>
<a name="ln3638">            interrupt_activity(activity_interrupt::monster_attacks,</a>
<a name="ln3639">                               agent()-&gt;as_monster());</a>
<a name="ln3640">        }</a>
<a name="ln3641">        else</a>
<a name="ln3642">            interrupt_activity(activity_interrupt::monster_attacks);</a>
<a name="ln3643">    }</a>
<a name="ln3644"> </a>
<a name="ln3645">    if (flavour == BEAM_MISSILE &amp;&amp; item)</a>
<a name="ln3646">    {</a>
<a name="ln3647">        ranged_attack attk(agent(true), &amp;you, item, use_target_as_pos, agent());</a>
<a name="ln3648">        attk.attack();</a>
<a name="ln3649">        // fsim purposes - throw_it detects if an attack connected through</a>
<a name="ln3650">        // hit_verb</a>
<a name="ln3651">        if (attk.ev_margin &gt;= 0 &amp;&amp; hit_verb.empty())</a>
<a name="ln3652">            hit_verb = attk.attack_verb;</a>
<a name="ln3653">        if (attk.reflected)</a>
<a name="ln3654">            reflect();</a>
<a name="ln3655">        extra_range_used += attk.range_used;</a>
<a name="ln3656">        return;</a>
<a name="ln3657">    }</a>
<a name="ln3658"> </a>
<a name="ln3659">    if (misses_player())</a>
<a name="ln3660">        return;</a>
<a name="ln3661"> </a>
<a name="ln3662">    const bool engulfs = is_explosion || is_big_cloud();</a>
<a name="ln3663"> </a>
<a name="ln3664">    if (is_enchantment())</a>
<a name="ln3665">    {</a>
<a name="ln3666">        if (real_flavour == BEAM_CHAOS || real_flavour == BEAM_RANDOM)</a>
<a name="ln3667">        {</a>
<a name="ln3668">            if (hit_verb.empty())</a>
<a name="ln3669">                hit_verb = engulfs ? &quot;engulfs&quot; : &quot;hits&quot;;</a>
<a name="ln3670">            mprf(&quot;The %s %s you!&quot;, name.c_str(), hit_verb.c_str());</a>
<a name="ln3671">        }</a>
<a name="ln3672"> </a>
<a name="ln3673">        affect_player_enchantment();</a>
<a name="ln3674">        return;</a>
<a name="ln3675">    }</a>
<a name="ln3676"> </a>
<a name="ln3677">    msg_generated = true;</a>
<a name="ln3678"> </a>
<a name="ln3679">    // FIXME: Lots of duplicated code here (compare handling of</a>
<a name="ln3680">    // monsters)</a>
<a name="ln3681">    int pre_ac_dam = 0;</a>
<a name="ln3682"> </a>
<a name="ln3683">    // Roll the damage.</a>
<a name="ln3684">    if (!(origin_spell == SPELL_FLASH_FREEZE &amp;&amp; you.duration[DUR_FROZEN]))</a>
<a name="ln3685">        pre_ac_dam += damage.roll();</a>
<a name="ln3686"> </a>
<a name="ln3687">    int pre_res_dam = apply_AC(&amp;you, pre_ac_dam);</a>
<a name="ln3688"> </a>
<a name="ln3689">#ifdef DEBUG_DIAGNOSTICS</a>
<a name="ln3690">    dprf(DIAG_BEAM, &quot;Player damage: before AC=%d; after AC=%d&quot;,</a>
<a name="ln3691">                    pre_ac_dam, pre_res_dam);</a>
<a name="ln3692">#endif</a>
<a name="ln3693"> </a>
<a name="ln3694">    practise_being_shot();</a>
<a name="ln3695"> </a>
<a name="ln3696">    bool was_affected = false;</a>
<a name="ln3697">    int  old_hp       = you.hp;</a>
<a name="ln3698"> </a>
<a name="ln3699">    pre_res_dam = max(0, pre_res_dam);</a>
<a name="ln3700"> </a>
<a name="ln3701">    // If the beam is an actual missile or of the MMISSILE type (Earth magic)</a>
<a name="ln3702">    // we might bleed on the floor.</a>
<a name="ln3703">    if (!engulfs</a>
<a name="ln3704">        &amp;&amp; (flavour == BEAM_MISSILE || flavour == BEAM_MMISSILE))</a>
<a name="ln3705">    {</a>
<a name="ln3706">        // assumes DVORP_PIERCING, factor: 0.5</a>
<a name="ln3707">        int blood = min(you.hp, pre_res_dam / 2);</a>
<a name="ln3708">        bleed_onto_floor(you.pos(), MONS_PLAYER, blood, true);</a>
<a name="ln3709">    }</a>
<a name="ln3710"> </a>
<a name="ln3711">    // Apply resistances to damage, but don't print &quot;You resist&quot; messages yet</a>
<a name="ln3712">    int final_dam = check_your_resists(pre_res_dam, flavour, &quot;&quot;, this, false);</a>
<a name="ln3713"> </a>
<a name="ln3714">    // Tell the player the beam hit</a>
<a name="ln3715">    if (hit_verb.empty())</a>
<a name="ln3716">        hit_verb = engulfs ? &quot;engulfs&quot; : &quot;hits&quot;;</a>
<a name="ln3717"> </a>
<a name="ln3718">    if (flavour != BEAM_VISUAL &amp;&amp; !is_enchantment())</a>
<a name="ln3719">    {</a>
<a name="ln3720">        mprf(&quot;The %s %s you%s%s&quot;, name.c_str(), hit_verb.c_str(),</a>
<a name="ln3721">             final_dam ? &quot;&quot; : &quot; but does no damage&quot;,</a>
<a name="ln3722">             attack_strength_punctuation(final_dam).c_str());</a>
<a name="ln3723">    }</a>
<a name="ln3724"> </a>
<a name="ln3725">    // Now print the messages associated with checking resistances, so that</a>
<a name="ln3726">    // these come after the beam actually hitting.</a>
<a name="ln3727">    // Note that this must be called with the pre-resistance damage, so that</a>
<a name="ln3728">    // poison effects etc work properly.</a>
<a name="ln3729">    check_your_resists(pre_res_dam, flavour, &quot;&quot;, this, true);</a>
<a name="ln3730"> </a>
<a name="ln3731">    if (flavour == BEAM_MIASMA &amp;&amp; final_dam &gt; 0)</a>
<a name="ln3732">        was_affected = miasma_player(agent(), name);</a>
<a name="ln3733"> </a>
<a name="ln3734">    if (flavour == BEAM_DEVASTATION) // DISINTEGRATION already handled</a>
<a name="ln3735">        blood_spray(you.pos(), MONS_PLAYER, final_dam / 5);</a>
<a name="ln3736"> </a>
<a name="ln3737">    // Confusion effect for spore explosions</a>
<a name="ln3738">    if (flavour == BEAM_SPORE &amp;&amp; final_dam</a>
<a name="ln3739">        &amp;&amp; !(you.holiness() &amp; MH_UNDEAD)</a>
<a name="ln3740">        &amp;&amp; !you.is_unbreathing())</a>
<a name="ln3741">    {</a>
<a name="ln3742">        confuse_player(2 + random2(3));</a>
<a name="ln3743">    }</a>
<a name="ln3744"> </a>
<a name="ln3745">    if (flavour == BEAM_UNRAVELLED_MAGIC)</a>
<a name="ln3746">        affect_player_enchantment();</a>
<a name="ln3747"> </a>
<a name="ln3748">    // handling of missiles</a>
<a name="ln3749">    if (item &amp;&amp; item-&gt;base_type == OBJ_MISSILES)</a>
<a name="ln3750">    {</a>
<a name="ln3751">        if (item-&gt;sub_type == MI_THROWING_NET)</a>
<a name="ln3752">        {</a>
<a name="ln3753">            if (player_caught_in_net())</a>
<a name="ln3754">            {</a>
<a name="ln3755">                if (monster_by_mid(source_id))</a>
<a name="ln3756">                    xom_is_stimulated(50);</a>
<a name="ln3757">                was_affected = true;</a>
<a name="ln3758">            }</a>
<a name="ln3759">        }</a>
<a name="ln3760">        else if (item-&gt;brand == SPMSL_CURARE)</a>
<a name="ln3761">        {</a>
<a name="ln3762">            if (x_chance_in_y(90 - 3 * you.armour_class(), 100))</a>
<a name="ln3763">            {</a>
<a name="ln3764">                curare_actor(agent(), (actor*) &amp;you, 2, name, source_name);</a>
<a name="ln3765">                was_affected = true;</a>
<a name="ln3766">            }</a>
<a name="ln3767">        }</a>
<a name="ln3768"> </a>
<a name="ln3769">        if (you.has_mutation(MUT_JELLY_MISSILE)</a>
<a name="ln3770">            &amp;&amp; you.hp &lt; you.hp_max</a>
<a name="ln3771">            &amp;&amp; !you.duration[DUR_DEATHS_DOOR]</a>
<a name="ln3772">            &amp;&amp; item_is_jelly_edible(*item)</a>
<a name="ln3773">            &amp;&amp; coinflip())</a>
<a name="ln3774">        {</a>
<a name="ln3775">            mprf(&quot;Your attached jelly eats %s!&quot;, item-&gt;name(DESC_THE).c_str());</a>
<a name="ln3776">            inc_hp(random2(final_dam / 2));</a>
<a name="ln3777">            canned_msg(MSG_GAIN_HEALTH);</a>
<a name="ln3778">            drop_item = false;</a>
<a name="ln3779">        }</a>
<a name="ln3780">    }</a>
<a name="ln3781"> </a>
<a name="ln3782">    // Sticky flame.</a>
<a name="ln3783">    if (origin_spell == SPELL_STICKY_FLAME</a>
<a name="ln3784">        || origin_spell == SPELL_STICKY_FLAME_RANGE)</a>
<a name="ln3785">    {</a>
<a name="ln3786">        if (!player_res_sticky_flame())</a>
<a name="ln3787">        {</a>
<a name="ln3788">            napalm_player(random2avg(7, 3) + 1, get_source_name(), aux_source);</a>
<a name="ln3789">            was_affected = true;</a>
<a name="ln3790">        }</a>
<a name="ln3791">    }</a>
<a name="ln3792"> </a>
<a name="ln3793">    // need to trigger qaz resists after reducing damage from ac/resists.</a>
<a name="ln3794">    //    for some reason, strength 2 is the standard. This leads to qaz's</a>
<a name="ln3795">    //    resists triggering 2 in 5 times at max piety.</a>
<a name="ln3796">    //    perhaps this should scale with damage?</a>
<a name="ln3797">    // what to do for hybrid damage?  E.g. bolt of magma, icicle, poison arrow?</a>
<a name="ln3798">    // Right now just ignore the physical component.</a>
<a name="ln3799">    // what about acid?</a>
<a name="ln3800">    you.expose_to_element(flavour, 2, false);</a>
<a name="ln3801"> </a>
<a name="ln3802"> </a>
<a name="ln3803">    // Manticore spikes</a>
<a name="ln3804">    if (origin_spell == SPELL_THROW_BARBS &amp;&amp; final_dam &gt; 0)</a>
<a name="ln3805">    {</a>
<a name="ln3806">        mpr(&quot;The barbed spikes become lodged in your body.&quot;);</a>
<a name="ln3807">        if (!you.duration[DUR_BARBS])</a>
<a name="ln3808">            you.set_duration(DUR_BARBS, random_range(4, 8));</a>
<a name="ln3809">        else</a>
<a name="ln3810">            you.increase_duration(DUR_BARBS, random_range(2, 4), 12);</a>
<a name="ln3811"> </a>
<a name="ln3812">        if (you.attribute[ATTR_BARBS_POW])</a>
<a name="ln3813">        {</a>
<a name="ln3814">            you.attribute[ATTR_BARBS_POW] =</a>
<a name="ln3815">                min(6, you.attribute[ATTR_BARBS_POW]++);</a>
<a name="ln3816">        }</a>
<a name="ln3817">        else</a>
<a name="ln3818">            you.attribute[ATTR_BARBS_POW] = 4;</a>
<a name="ln3819">    }</a>
<a name="ln3820"> </a>
<a name="ln3821">    if (flavour == BEAM_ENSNARE)</a>
<a name="ln3822">        was_affected = ensnare(&amp;you) || was_affected;</a>
<a name="ln3823"> </a>
<a name="ln3824">    if (origin_spell == SPELL_QUICKSILVER_BOLT)</a>
<a name="ln3825">        debuff_player();</a>
<a name="ln3826"> </a>
<a name="ln3827">    if (origin_spell == SPELL_THROW_PIE &amp;&amp; final_dam &gt; 0)</a>
<a name="ln3828">    {</a>
<a name="ln3829">        const pie_effect effect = _random_pie_effect(you);</a>
<a name="ln3830">        mprf(&quot;%s!&quot;, effect.desc);</a>
<a name="ln3831">        effect.effect(you, *this);</a>
<a name="ln3832">    }</a>
<a name="ln3833"> </a>
<a name="ln3834">    dprf(DIAG_BEAM, &quot;Damage: %d&quot;, final_dam);</a>
<a name="ln3835"> </a>
<a name="ln3836">    if (final_dam &gt; 0 || old_hp &lt; you.hp || was_affected)</a>
<a name="ln3837">    {</a>
<a name="ln3838">        if (mons_att_wont_attack(attitude))</a>
<a name="ln3839">        {</a>
<a name="ln3840">            friend_info.hurt++;</a>
<a name="ln3841"> </a>
<a name="ln3842">            // Beam from player rebounded and hit player.</a>
<a name="ln3843">            // Xom's amusement at the player's being damaged is handled</a>
<a name="ln3844">            // elsewhere.</a>
<a name="ln3845">            if (source_id == MID_PLAYER)</a>
<a name="ln3846">            {</a>
<a name="ln3847">                if (!aimed_at_feet)</a>
<a name="ln3848">                    xom_is_stimulated(200);</a>
<a name="ln3849">            }</a>
<a name="ln3850">            else if (was_affected)</a>
<a name="ln3851">                xom_is_stimulated(100);</a>
<a name="ln3852">        }</a>
<a name="ln3853">        else</a>
<a name="ln3854">            foe_info.hurt++;</a>
<a name="ln3855">    }</a>
<a name="ln3856"> </a>
<a name="ln3857">    internal_ouch(final_dam);</a>
<a name="ln3858"> </a>
<a name="ln3859">    // Acid. (Apply this afterward, to avoid bad message ordering.)</a>
<a name="ln3860">    if (flavour == BEAM_ACID)</a>
<a name="ln3861">        you.splash_with_acid(agent(), 5, true);</a>
<a name="ln3862"> </a>
<a name="ln3863">    extra_range_used += range_used_on_hit();</a>
<a name="ln3864"> </a>
<a name="ln3865">    knockback_actor(&amp;you, final_dam);</a>
<a name="ln3866">    pull_actor(&amp;you, final_dam);</a>
<a name="ln3867"> </a>
<a name="ln3868">    if (origin_spell == SPELL_FLASH_FREEZE</a>
<a name="ln3869">        || name == &quot;blast of ice&quot;</a>
<a name="ln3870">        || origin_spell == SPELL_GLACIATE &amp;&amp; !is_explosion)</a>
<a name="ln3871">    {</a>
<a name="ln3872">        if (you.duration[DUR_FROZEN])</a>
<a name="ln3873">        {</a>
<a name="ln3874">            if (origin_spell == SPELL_FLASH_FREEZE)</a>
<a name="ln3875">                canned_msg(MSG_YOU_UNAFFECTED);</a>
<a name="ln3876">        }</a>
<a name="ln3877">        else</a>
<a name="ln3878">        {</a>
<a name="ln3879">            mprf(MSGCH_WARN, &quot;You are encased in ice.&quot;);</a>
<a name="ln3880">            you.duration[DUR_FROZEN] = (2 + random2(3)) * BASELINE_DELAY;</a>
<a name="ln3881">        }</a>
<a name="ln3882">    }</a>
<a name="ln3883">}</a>
<a name="ln3884"> </a>
<a name="ln3885">int bolt::apply_AC(const actor *victim, int hurted)</a>
<a name="ln3886">{</a>
<a name="ln3887">    switch (flavour)</a>
<a name="ln3888">    {</a>
<a name="ln3889">    case BEAM_DAMNATION:</a>
<a name="ln3890">        ac_rule = ac_type::none; break;</a>
<a name="ln3891">    case BEAM_ELECTRICITY:</a>
<a name="ln3892">        ac_rule = ac_type::half; break;</a>
<a name="ln3893">    case BEAM_FRAG:</a>
<a name="ln3894">        ac_rule = ac_type::triple; break;</a>
<a name="ln3895">    default: ;</a>
<a name="ln3896">    }</a>
<a name="ln3897"> </a>
<a name="ln3898">    // beams don't obey GDR -&gt; max_damage is 0</a>
<a name="ln3899">    return victim-&gt;apply_ac(hurted, 0, ac_rule, 0, !is_tracer);</a>
<a name="ln3900">}</a>
<a name="ln3901"> </a>
<a name="ln3902">void bolt::update_hurt_or_helped(monster* mon)</a>
<a name="ln3903">{</a>
<a name="ln3904">    if (!mons_atts_aligned(attitude, mons_attitude(*mon)))</a>
<a name="ln3905">    {</a>
<a name="ln3906">        if (nasty_to(mon))</a>
<a name="ln3907">            foe_info.hurt++;</a>
<a name="ln3908">        else if (nice_to(monster_info(mon)))</a>
<a name="ln3909">        {</a>
<a name="ln3910">            foe_info.helped++;</a>
<a name="ln3911">            // Accidentally helped a foe.</a>
<a name="ln3912">            if (!is_tracer &amp;&amp; !effect_known &amp;&amp; mons_is_threatening(*mon))</a>
<a name="ln3913">            {</a>
<a name="ln3914">                const int interest =</a>
<a name="ln3915">                    (flavour == BEAM_INVISIBILITY &amp;&amp; can_see_invis) ? 25 : 100;</a>
<a name="ln3916">                xom_is_stimulated(interest);</a>
<a name="ln3917">            }</a>
<a name="ln3918">        }</a>
<a name="ln3919">    }</a>
<a name="ln3920">    else</a>
<a name="ln3921">    {</a>
<a name="ln3922">        if (nasty_to(mon))</a>
<a name="ln3923">        {</a>
<a name="ln3924">            friend_info.hurt++;</a>
<a name="ln3925"> </a>
<a name="ln3926">            // Harmful beam from this monster rebounded and hit the monster.</a>
<a name="ln3927">            if (!is_tracer &amp;&amp; mon-&gt;mid == source_id)</a>
<a name="ln3928">                xom_is_stimulated(100);</a>
<a name="ln3929">        }</a>
<a name="ln3930">        else if (nice_to(monster_info(mon)))</a>
<a name="ln3931">            friend_info.helped++;</a>
<a name="ln3932">    }</a>
<a name="ln3933">}</a>
<a name="ln3934"> </a>
<a name="ln3935">void bolt::tracer_enchantment_affect_monster(monster* mon)</a>
<a name="ln3936">{</a>
<a name="ln3937">    // Only count tracers as hitting creatures they could potentially affect</a>
<a name="ln3938">    if (ench_flavour_affects_monster(flavour, mon, true)</a>
<a name="ln3939">        &amp;&amp; !(has_saving_throw() &amp;&amp; mons_immune_magic(*mon)))</a>
<a name="ln3940">    {</a>
<a name="ln3941">        // Update friend or foe encountered.</a>
<a name="ln3942">        if (!mons_atts_aligned(attitude, mons_attitude(*mon)))</a>
<a name="ln3943">        {</a>
<a name="ln3944">            foe_info.count++;</a>
<a name="ln3945">            foe_info.power += mon-&gt;get_experience_level();</a>
<a name="ln3946">        }</a>
<a name="ln3947">        else</a>
<a name="ln3948">        {</a>
<a name="ln3949">            friend_info.count++;</a>
<a name="ln3950">            friend_info.power += mon-&gt;get_experience_level();</a>
<a name="ln3951">        }</a>
<a name="ln3952">    }</a>
<a name="ln3953"> </a>
<a name="ln3954">    handle_stop_attack_prompt(mon);</a>
<a name="ln3955">    if (!beam_cancelled)</a>
<a name="ln3956">        extra_range_used += range_used_on_hit();</a>
<a name="ln3957">}</a>
<a name="ln3958"> </a>
<a name="ln3959">// Return false if we should skip handling this monster.</a>
<a name="ln3960">bool bolt::determine_damage(monster* mon, int&amp; preac, int&amp; postac, int&amp; final)</a>
<a name="ln3961">{</a>
<a name="ln3962">    preac = postac = final = 0;</a>
<a name="ln3963"> </a>
<a name="ln3964">    const bool freeze_immune =</a>
<a name="ln3965">        origin_spell == SPELL_FLASH_FREEZE &amp;&amp; mon-&gt;has_ench(ENCH_FROZEN);</a>
<a name="ln3966"> </a>
<a name="ln3967">    // [ds] Changed how tracers determined damage: the old tracer</a>
<a name="ln3968">    // model took the average damage potential, subtracted the average</a>
<a name="ln3969">    // AC damage reduction and called that the average damage output.</a>
<a name="ln3970">    // This could easily predict an average damage output of 0 for</a>
<a name="ln3971">    // high AC monsters, with the result that monsters often didn't</a>
<a name="ln3972">    // bother using ranged attacks at high AC targets.</a>
<a name="ln3973">    //</a>
<a name="ln3974">    // The new model rounds up average damage at every stage, so it</a>
<a name="ln3975">    // will predict a damage output of 1 even if the average damage</a>
<a name="ln3976">    // expected is much closer to 0. This will allow monsters to use</a>
<a name="ln3977">    // ranged attacks vs high AC targets.</a>
<a name="ln3978">      // [1KB] What ds' code actually does is taking the max damage minus</a>
<a name="ln3979">      // average AC. This does work well, even using no AC would. An</a>
<a name="ln3980">      // attack that _usually_ does no damage but can possibly do some means</a>
<a name="ln3981">      // we'll ultimately get it through. And monsters with weak ranged</a>
<a name="ln3982">      // almost always would do no better in melee.</a>
<a name="ln3983">    //</a>
<a name="ln3984">    // This is not an entirely beneficial change; the old tracer</a>
<a name="ln3985">    // damage system would make monsters with weak ranged attacks</a>
<a name="ln3986">    // close in to their foes, while the new system will make it more</a>
<a name="ln3987">    // likely that such monsters will hang back and make ineffective</a>
<a name="ln3988">    // ranged attacks. Thus the new tracer damage calculation will</a>
<a name="ln3989">    // hurt monsters with low-damage ranged attacks and high-damage</a>
<a name="ln3990">    // melee attacks. I judge this an acceptable compromise (for now).</a>
<a name="ln3991">    //</a>
<a name="ln3992">    const int preac_max_damage =</a>
<a name="ln3993">        (freeze_immune) ? 0</a>
<a name="ln3994">                        : damage.num * damage.size;</a>
<a name="ln3995"> </a>
<a name="ln3996">    // preac: damage before AC modifier</a>
<a name="ln3997">    // postac: damage after AC modifier</a>
<a name="ln3998">    // final: damage after AC and resists</a>
<a name="ln3999">    // All these are invalid if we return false.</a>
<a name="ln4000"> </a>
<a name="ln4001">    if (is_tracer)</a>
<a name="ln4002">    {</a>
<a name="ln4003">        // Was mean between min and max;</a>
<a name="ln4004">        preac = preac_max_damage;</a>
<a name="ln4005">    }</a>
<a name="ln4006">    else if (!freeze_immune)</a>
<a name="ln4007">        preac = damage.roll();</a>
<a name="ln4008"> </a>
<a name="ln4009">    int tracer_postac_max = preac_max_damage;</a>
<a name="ln4010"> </a>
<a name="ln4011">    postac = apply_AC(mon, preac);</a>
<a name="ln4012"> </a>
<a name="ln4013">    if (is_tracer)</a>
<a name="ln4014">    {</a>
<a name="ln4015">        postac = div_round_up(tracer_postac_max, 2);</a>
<a name="ln4016"> </a>
<a name="ln4017">        const int adjusted_postac_max =</a>
<a name="ln4018">            mons_adjust_flavoured(mon, *this, tracer_postac_max, false);</a>
<a name="ln4019"> </a>
<a name="ln4020">        final = div_round_up(adjusted_postac_max, 2);</a>
<a name="ln4021">    }</a>
<a name="ln4022">    else</a>
<a name="ln4023">    {</a>
<a name="ln4024">        postac = max(0, postac);</a>
<a name="ln4025">        // Don't do side effects (beam might miss or be a tracer).</a>
<a name="ln4026">        final = mons_adjust_flavoured(mon, *this, postac, false);</a>
<a name="ln4027">    }</a>
<a name="ln4028"> </a>
<a name="ln4029">    // Sanity check. Importantly for</a>
<a name="ln4030">    // tracer_nonenchantment_affect_monster, final &gt; 0</a>
<a name="ln4031">    // implies preac &gt; 0.</a>
<a name="ln4032">    ASSERT(0 &lt;= postac);</a>
<a name="ln4033">    ASSERT(postac &lt;= preac);</a>
<a name="ln4034">    ASSERT(0 &lt;= final);</a>
<a name="ln4035">    ASSERT(preac &gt; 0 || final == 0);</a>
<a name="ln4036"> </a>
<a name="ln4037">    return true;</a>
<a name="ln4038">}</a>
<a name="ln4039"> </a>
<a name="ln4040">void bolt::handle_stop_attack_prompt(monster* mon)</a>
<a name="ln4041">{</a>
<a name="ln4042">    if (thrower != KILL_YOU_MISSILE &amp;&amp; thrower != KILL_YOU</a>
<a name="ln4043">        || is_harmless(mon)</a>
<a name="ln4044">        || friend_info.dont_stop &amp;&amp; foe_info.dont_stop)</a>
<a name="ln4045">    {</a>
<a name="ln4046">        return;</a>
<a name="ln4047">    }</a>
<a name="ln4048"> </a>
<a name="ln4049">    bool prompted = false;</a>
<a name="ln4050"> </a>
<a name="ln4051">    if (stop_attack_prompt(mon, true, target, &amp;prompted)</a>
<a name="ln4052">        || _stop_because_god_hates_target_prompt(mon, origin_spell))</a>
<a name="ln4053">    {</a>
<a name="ln4054">        beam_cancelled = true;</a>
<a name="ln4055">        finish_beam();</a>
<a name="ln4056">    }</a>
<a name="ln4057">    // Handle enslaving monsters when OTR is up: give a prompt for attempting</a>
<a name="ln4058">    // to enslave monsters that don't have rPois with Toxic status.</a>
<a name="ln4059">    else if (flavour == BEAM_ENSLAVE &amp;&amp; you.duration[DUR_TOXIC_RADIANCE]</a>
<a name="ln4060">             &amp;&amp; mon-&gt;res_poison() &lt;= 0)</a>
<a name="ln4061">    {</a>
<a name="ln4062">        string verb = make_stringf(&quot;enslave %s&quot;, mon-&gt;name(DESC_THE).c_str());</a>
<a name="ln4063">        if (otr_stop_summoning_prompt(verb))</a>
<a name="ln4064">        {</a>
<a name="ln4065">            beam_cancelled = true;</a>
<a name="ln4066">            finish_beam();</a>
<a name="ln4067">            prompted = true;</a>
<a name="ln4068">        }</a>
<a name="ln4069">    }</a>
<a name="ln4070"> </a>
<a name="ln4071">    if (prompted)</a>
<a name="ln4072">    {</a>
<a name="ln4073">        friend_info.dont_stop = true;</a>
<a name="ln4074">        foe_info.dont_stop = true;</a>
<a name="ln4075">    }</a>
<a name="ln4076">}</a>
<a name="ln4077"> </a>
<a name="ln4078">void bolt::tracer_nonenchantment_affect_monster(monster* mon)</a>
<a name="ln4079">{</a>
<a name="ln4080">    int preac, post, final;</a>
<a name="ln4081"> </a>
<a name="ln4082">    if (!determine_damage(mon, preac, post, final))</a>
<a name="ln4083">        return;</a>
<a name="ln4084"> </a>
<a name="ln4085">    // Check only if actual damage and the monster is worth caring about.</a>
<a name="ln4086">    if (final &gt; 0 &amp;&amp; mons_is_threatening(*mon))</a>
<a name="ln4087">    {</a>
<a name="ln4088">        ASSERT(preac &gt; 0);</a>
<a name="ln4089"> </a>
<a name="ln4090">        // Monster could be hurt somewhat, but only apply the</a>
<a name="ln4091">        // monster's power based on how badly it is affected.</a>
<a name="ln4092">        // For example, if a fire giant (power 16) threw a</a>
<a name="ln4093">        // fireball at another fire giant, and it only took</a>
<a name="ln4094">        // 1/3 damage, then power of 5 would be applied.</a>
<a name="ln4095"> </a>
<a name="ln4096">        // Counting foes is only important for monster tracers.</a>
<a name="ln4097">        if (!mons_atts_aligned(attitude, mons_attitude(*mon)))</a>
<a name="ln4098">        {</a>
<a name="ln4099">            foe_info.power += 2 * final * mon-&gt;get_experience_level() / preac;</a>
<a name="ln4100">            foe_info.count++;</a>
<a name="ln4101">        }</a>
<a name="ln4102">        else</a>
<a name="ln4103">        {</a>
<a name="ln4104">            // Discourage summoned monsters firing on their summoner.</a>
<a name="ln4105">            const monster* mon_source = agent()-&gt;as_monster();</a>
<a name="ln4106">            if (mon_source &amp;&amp; mon_source-&gt;summoner == mon-&gt;mid)</a>
<a name="ln4107">                friend_info.power = 100;</a>
<a name="ln4108">            else</a>
<a name="ln4109">            {</a>
<a name="ln4110">                friend_info.power</a>
<a name="ln4111">                    += 2 * final * mon-&gt;get_experience_level() / preac;</a>
<a name="ln4112">            }</a>
<a name="ln4113">            friend_info.count++;</a>
<a name="ln4114">        }</a>
<a name="ln4115">    }</a>
<a name="ln4116"> </a>
<a name="ln4117">    // Maybe the user wants to cancel at this point.</a>
<a name="ln4118">    handle_stop_attack_prompt(mon);</a>
<a name="ln4119">    if (beam_cancelled)</a>
<a name="ln4120">        return;</a>
<a name="ln4121"> </a>
<a name="ln4122">    // Either way, we could hit this monster, so update range used.</a>
<a name="ln4123">    extra_range_used += range_used_on_hit();</a>
<a name="ln4124">}</a>
<a name="ln4125"> </a>
<a name="ln4126">void bolt::tracer_affect_monster(monster* mon)</a>
<a name="ln4127">{</a>
<a name="ln4128">    // Ignore unseen monsters.</a>
<a name="ln4129">    if (!agent() || !agent()-&gt;can_see(*mon))</a>
<a name="ln4130">        return;</a>
<a name="ln4131"> </a>
<a name="ln4132">    if (flavour == BEAM_UNRAVELLING &amp;&amp; monster_is_debuffable(*mon))</a>
<a name="ln4133">        is_explosion = true;</a>
<a name="ln4134"> </a>
<a name="ln4135">    // Trigger explosion on exploding beams.</a>
<a name="ln4136">    if (is_explosion &amp;&amp; !in_explosion_phase)</a>
<a name="ln4137">    {</a>
<a name="ln4138">        finish_beam();</a>
<a name="ln4139">        return;</a>
<a name="ln4140">    }</a>
<a name="ln4141"> </a>
<a name="ln4142">    // Special explosions (current exploding missiles) aren't</a>
<a name="ln4143">    // auto-hit, so we need to explode them at every possible</a>
<a name="ln4144">    // end-point?</a>
<a name="ln4145">    if (special_explosion)</a>
<a name="ln4146">    {</a>
<a name="ln4147">        bolt orig = *special_explosion;</a>
<a name="ln4148">        affect_endpoint();</a>
<a name="ln4149">        *special_explosion = orig;</a>
<a name="ln4150">    }</a>
<a name="ln4151"> </a>
<a name="ln4152">    if (is_enchantment())</a>
<a name="ln4153">        tracer_enchantment_affect_monster(mon);</a>
<a name="ln4154">    else</a>
<a name="ln4155">        tracer_nonenchantment_affect_monster(mon);</a>
<a name="ln4156">}</a>
<a name="ln4157"> </a>
<a name="ln4158">void bolt::enchantment_affect_monster(monster* mon)</a>
<a name="ln4159">{</a>
<a name="ln4160">    god_conduct_trigger conducts[3];</a>
<a name="ln4161"> </a>
<a name="ln4162">    bool hit_woke_orc = false;</a>
<a name="ln4163"> </a>
<a name="ln4164">    // Nasty enchantments will annoy the monster, and are considered</a>
<a name="ln4165">    // naughty (even if a monster might resist).</a>
<a name="ln4166">    if (nasty_to(mon))</a>
<a name="ln4167">    {</a>
<a name="ln4168">        if (YOU_KILL(thrower))</a>
<a name="ln4169">        {</a>
<a name="ln4170">            set_attack_conducts(conducts, *mon, you.can_see(*mon));</a>
<a name="ln4171"> </a>
<a name="ln4172">            if (have_passive(passive_t::convert_orcs)</a>
<a name="ln4173">                &amp;&amp; mons_genus(mon-&gt;type) == MONS_ORC</a>
<a name="ln4174">                &amp;&amp; mon-&gt;asleep() &amp;&amp; you.see_cell(mon-&gt;pos()))</a>
<a name="ln4175">            {</a>
<a name="ln4176">                hit_woke_orc = true;</a>
<a name="ln4177">            }</a>
<a name="ln4178">        }</a>
<a name="ln4179">        behaviour_event(mon, ME_ANNOY, agent());</a>
<a name="ln4180">    }</a>
<a name="ln4181">    else if (flavour != BEAM_HIBERNATION || !mon-&gt;asleep())</a>
<a name="ln4182">        behaviour_event(mon, ME_ALERT, agent());</a>
<a name="ln4183"> </a>
<a name="ln4184">    // Doing this here so that the player gets to see monsters</a>
<a name="ln4185">    // &quot;flicker and vanish&quot; when turning invisible....</a>
<a name="ln4186">    if (animate)</a>
<a name="ln4187">    {</a>
<a name="ln4188">        _ench_animation(effect_known ? real_flavour</a>
<a name="ln4189">                                     : BEAM_MAGIC,</a>
<a name="ln4190">                        mon, effect_known);</a>
<a name="ln4191">    }</a>
<a name="ln4192"> </a>
<a name="ln4193">    // Try to hit the monster with the enchantment. The behaviour_event above</a>
<a name="ln4194">    // may have caused a pacified monster to leave the level, so only try to</a>
<a name="ln4195">    // enchant it if it's still here. If the monster did leave the level, set</a>
<a name="ln4196">    // obvious_effect so we don't get &quot;Nothing appears to happen&quot;.</a>
<a name="ln4197">    int res_margin = 0;</a>
<a name="ln4198">    const mon_resist_type ench_result = mon-&gt;alive()</a>
<a name="ln4199">                                      ? try_enchant_monster(mon, res_margin)</a>
<a name="ln4200">                                      : (obvious_effect = true, MON_OTHER);</a>
<a name="ln4201"> </a>
<a name="ln4202">    if (mon-&gt;alive())           // Aftereffects.</a>
<a name="ln4203">    {</a>
<a name="ln4204">        // Message or record the success/failure.</a>
<a name="ln4205">        switch (ench_result)</a>
<a name="ln4206">        {</a>
<a name="ln4207">        case MON_RESIST:</a>
<a name="ln4208">            if (simple_monster_message(*mon,</a>
<a name="ln4209">                                   mon-&gt;resist_margin_phrase(res_margin).c_str()))</a>
<a name="ln4210">            {</a>
<a name="ln4211">                msg_generated = true;</a>
<a name="ln4212">            }</a>
<a name="ln4213">            break;</a>
<a name="ln4214">        case MON_UNAFFECTED:</a>
<a name="ln4215">            if (simple_monster_message(*mon, &quot; is unaffected.&quot;))</a>
<a name="ln4216">                msg_generated = true;</a>
<a name="ln4217">            break;</a>
<a name="ln4218">        case MON_AFFECTED:</a>
<a name="ln4219">        case MON_OTHER:         // Should this really be here?</a>
<a name="ln4220">            update_hurt_or_helped(mon);</a>
<a name="ln4221">            break;</a>
<a name="ln4222">        }</a>
<a name="ln4223"> </a>
<a name="ln4224">        if (hit_woke_orc)</a>
<a name="ln4225">            beogh_follower_convert(mon, true);</a>
<a name="ln4226">    }</a>
<a name="ln4227"> </a>
<a name="ln4228">    extra_range_used += range_used_on_hit();</a>
<a name="ln4229">}</a>
<a name="ln4230"> </a>
<a name="ln4231">void glaciate_freeze(monster* mon, killer_type englaciator,</a>
<a name="ln4232">                             int kindex)</a>
<a name="ln4233">{</a>
<a name="ln4234">    const coord_def where = mon-&gt;pos();</a>
<a name="ln4235">    const monster_type pillar_type =</a>
<a name="ln4236">        mons_is_zombified(*mon) ? mons_zombie_base(*mon)</a>
<a name="ln4237">                                : mons_species(mon-&gt;type);</a>
<a name="ln4238">    const int hd = mon-&gt;get_experience_level();</a>
<a name="ln4239"> </a>
<a name="ln4240">    simple_monster_message(*mon, &quot; is frozen into a solid block of ice!&quot;);</a>
<a name="ln4241"> </a>
<a name="ln4242">    // If the monster leaves a corpse when it dies, destroy the corpse.</a>
<a name="ln4243">    item_def* corpse = monster_die(*mon, englaciator, kindex);</a>
<a name="ln4244">    if (corpse)</a>
<a name="ln4245">        destroy_item(corpse-&gt;index());</a>
<a name="ln4246"> </a>
<a name="ln4247">    if (monster *pillar = create_monster(</a>
<a name="ln4248">                        mgen_data(MONS_BLOCK_OF_ICE,</a>
<a name="ln4249">                                  BEH_HOSTILE,</a>
<a name="ln4250">                                  where,</a>
<a name="ln4251">                                  MHITNOT,</a>
<a name="ln4252">                                  MG_FORCE_PLACE).set_base(pillar_type),</a>
<a name="ln4253">                                  false))</a>
<a name="ln4254">    {</a>
<a name="ln4255">        // Enemies with more HD leave longer-lasting blocks of ice.</a>
<a name="ln4256">        int time_left = (random2(8) + hd) * BASELINE_DELAY;</a>
<a name="ln4257">        mon_enchant temp_en(ENCH_SLOWLY_DYING, 1, 0, time_left);</a>
<a name="ln4258">        pillar-&gt;update_ench(temp_en);</a>
<a name="ln4259">    }</a>
<a name="ln4260">}</a>
<a name="ln4261"> </a>
<a name="ln4262">void bolt::monster_post_hit(monster* mon, int dmg)</a>
<a name="ln4263">{</a>
<a name="ln4264">    // Suppress the message for scattershot.</a>
<a name="ln4265">    if (YOU_KILL(thrower) &amp;&amp; you.see_cell(mon-&gt;pos())</a>
<a name="ln4266">        &amp;&amp; name != &quot;burst of metal fragments&quot;)</a>
<a name="ln4267">    {</a>
<a name="ln4268">        print_wounds(*mon);</a>
<a name="ln4269">    }</a>
<a name="ln4270"> </a>
<a name="ln4271">    // Don't annoy friendlies or good neutrals if the player's beam</a>
<a name="ln4272">    // did no damage. Hostiles will still take umbrage.</a>
<a name="ln4273">    if (dmg &gt; 0 || !mon-&gt;wont_attack() || !YOU_KILL(thrower))</a>
<a name="ln4274">    {</a>
<a name="ln4275">        special_missile_type m_brand = SPMSL_FORBID_BRAND;</a>
<a name="ln4276">        if (item &amp;&amp; item-&gt;base_type == OBJ_MISSILES)</a>
<a name="ln4277">            m_brand = get_ammo_brand(*item);</a>
<a name="ln4278"> </a>
<a name="ln4279">        // Don't immediately turn insane monsters hostile.</a>
<a name="ln4280">        if (m_brand != SPMSL_FRENZY)</a>
<a name="ln4281">        {</a>
<a name="ln4282">            behaviour_event(mon, ME_ANNOY, agent());</a>
<a name="ln4283">            // behaviour_event can make a monster leave the level or vanish.</a>
<a name="ln4284">            if (!mon-&gt;alive())</a>
<a name="ln4285">                return;</a>
<a name="ln4286">        }</a>
<a name="ln4287">    }</a>
<a name="ln4288"> </a>
<a name="ln4289">    if (YOU_KILL(thrower) &amp;&amp; !mon-&gt;wont_attack() &amp;&amp; !mons_is_firewood(*mon))</a>
<a name="ln4290">        you.pet_target = mon-&gt;mindex();</a>
<a name="ln4291"> </a>
<a name="ln4292">    // Sticky flame.</a>
<a name="ln4293">    if (origin_spell == SPELL_STICKY_FLAME</a>
<a name="ln4294">        || origin_spell == SPELL_STICKY_FLAME_RANGE)</a>
<a name="ln4295">    {</a>
<a name="ln4296">        const int levels = min(4, 1 + random2(dmg) / 2);</a>
<a name="ln4297">        napalm_monster(mon, agent(), levels);</a>
<a name="ln4298">    }</a>
<a name="ln4299"> </a>
<a name="ln4300">    // Acid splash from yellow draconians / acid dragons</a>
<a name="ln4301">    if (origin_spell == SPELL_ACID_SPLASH)</a>
<a name="ln4302">    {</a>
<a name="ln4303">        mon-&gt;splash_with_acid(agent(), 3);</a>
<a name="ln4304"> </a>
<a name="ln4305">        for (adjacent_iterator ai(source); ai; ++ai)</a>
<a name="ln4306">        {</a>
<a name="ln4307">            // the acid can splash onto adjacent targets</a>
<a name="ln4308">            if (grid_distance(*ai, target) != 1)</a>
<a name="ln4309">                continue;</a>
<a name="ln4310">            if (actor *victim = actor_at(*ai))</a>
<a name="ln4311">            {</a>
<a name="ln4312">                if (you.see_cell(*ai))</a>
<a name="ln4313">                {</a>
<a name="ln4314">                    mprf(&quot;The acid splashes onto %s!&quot;,</a>
<a name="ln4315">                         victim-&gt;name(DESC_THE).c_str());</a>
<a name="ln4316">                }</a>
<a name="ln4317"> </a>
<a name="ln4318">                victim-&gt;splash_with_acid(agent(), 3);</a>
<a name="ln4319">            }</a>
<a name="ln4320">        }</a>
<a name="ln4321">    }</a>
<a name="ln4322"> </a>
<a name="ln4323">    // Handle missile effects.</a>
<a name="ln4324">    if (item &amp;&amp; item-&gt;base_type == OBJ_MISSILES</a>
<a name="ln4325">        &amp;&amp; item-&gt;brand == SPMSL_CURARE &amp;&amp; ench_power == AUTOMATIC_HIT)</a>
<a name="ln4326">    {</a>
<a name="ln4327">        curare_actor(agent(), mon, 2, name, source_name);</a>
<a name="ln4328">    }</a>
<a name="ln4329"> </a>
<a name="ln4330">    // purple draconian breath</a>
<a name="ln4331">    if (origin_spell == SPELL_QUICKSILVER_BOLT)</a>
<a name="ln4332">        debuff_monster(*mon);</a>
<a name="ln4333"> </a>
<a name="ln4334">    if (dmg)</a>
<a name="ln4335">        beogh_follower_convert(mon, true);</a>
<a name="ln4336"> </a>
<a name="ln4337">    knockback_actor(mon, dmg);</a>
<a name="ln4338"> </a>
<a name="ln4339">    if (origin_spell == SPELL_FLASH_FREEZE</a>
<a name="ln4340">             || name == &quot;blast of ice&quot;</a>
<a name="ln4341">             || origin_spell == SPELL_GLACIATE &amp;&amp; !is_explosion)</a>
<a name="ln4342">    {</a>
<a name="ln4343">        if (mon-&gt;has_ench(ENCH_FROZEN))</a>
<a name="ln4344">        {</a>
<a name="ln4345">            if (origin_spell == SPELL_FLASH_FREEZE)</a>
<a name="ln4346">                simple_monster_message(*mon, &quot; is unaffected.&quot;);</a>
<a name="ln4347">        }</a>
<a name="ln4348">        else</a>
<a name="ln4349">        {</a>
<a name="ln4350">            simple_monster_message(*mon, &quot; is flash-frozen.&quot;);</a>
<a name="ln4351">            mon-&gt;add_ench(ENCH_FROZEN);</a>
<a name="ln4352">        }</a>
<a name="ln4353">    }</a>
<a name="ln4354"> </a>
<a name="ln4355">    if (origin_spell == SPELL_THROW_BARBS &amp;&amp; dmg &gt; 0</a>
<a name="ln4356">        &amp;&amp; !(mon-&gt;is_insubstantial() || mons_genus(mon-&gt;type) == MONS_JELLY))</a>
<a name="ln4357">    {</a>
<a name="ln4358">        mon-&gt;add_ench(mon_enchant(ENCH_BARBS, 1, agent(),</a>
<a name="ln4359">                                  random_range(5, 7) * BASELINE_DELAY));</a>
<a name="ln4360">    }</a>
<a name="ln4361"> </a>
<a name="ln4362">    if (origin_spell == SPELL_THROW_PIE &amp;&amp; dmg &gt; 0)</a>
<a name="ln4363">    {</a>
<a name="ln4364">        const pie_effect effect = _random_pie_effect(*mon);</a>
<a name="ln4365">        if (you.see_cell(mon-&gt;pos()))</a>
<a name="ln4366">            mprf(&quot;%s!&quot;, effect.desc);</a>
<a name="ln4367">        effect.effect(*mon, *this);</a>
<a name="ln4368">    }</a>
<a name="ln4369">}</a>
<a name="ln4370"> </a>
<a name="ln4371">void bolt::knockback_actor(actor *act, int dam)</a>
<a name="ln4372">{</a>
<a name="ln4373">    if (!act || !can_knockback(*act, dam))</a>
<a name="ln4374">        return;</a>
<a name="ln4375"> </a>
<a name="ln4376">    const int distance =</a>
<a name="ln4377">        (origin_spell == SPELL_FORCE_LANCE</a>
<a name="ln4378">         || origin_spell == SPELL_ISKENDERUNS_MYSTIC_BLAST)</a>
<a name="ln4379">            ? 2 + div_rand_round(ench_power, 50) :</a>
<a name="ln4380">        (origin_spell == SPELL_CHILLING_BREATH) ? 2 : 1;</a>
<a name="ln4381"> </a>
<a name="ln4382">    const int roll = origin_spell == SPELL_FORCE_LANCE</a>
<a name="ln4383">                     ? 7 + 0.27 * ench_power</a>
<a name="ln4384">                     : 17;</a>
<a name="ln4385">    const int weight = max_corpse_chunks(act-&gt;is_monster() ? act-&gt;type :</a>
<a name="ln4386">                                   player_species_to_mons_species(you.species));</a>
<a name="ln4387"> </a>
<a name="ln4388">    const coord_def oldpos = act-&gt;pos();</a>
<a name="ln4389"> </a>
<a name="ln4390">    if (act-&gt;is_stationary())</a>
<a name="ln4391">        return;</a>
<a name="ln4392">    // We can't do knockback if the beam starts and ends on the same space</a>
<a name="ln4393">    if (source == oldpos)</a>
<a name="ln4394">        return;</a>
<a name="ln4395">    ASSERT(ray.pos() == oldpos);</a>
<a name="ln4396"> </a>
<a name="ln4397">    coord_def newpos = oldpos;</a>
<a name="ln4398">    for (int dist_travelled = 0; dist_travelled &lt; distance; ++dist_travelled)</a>
<a name="ln4399">    {</a>
<a name="ln4400">        if (x_chance_in_y(weight, roll))</a>
<a name="ln4401">            continue;</a>
<a name="ln4402"> </a>
<a name="ln4403">        const ray_def oldray(ray);</a>
<a name="ln4404"> </a>
<a name="ln4405">        ray.advance();</a>
<a name="ln4406"> </a>
<a name="ln4407">        newpos = ray.pos();</a>
<a name="ln4408">        if (newpos == oldray.pos()</a>
<a name="ln4409">            || cell_is_solid(newpos)</a>
<a name="ln4410">            || actor_at(newpos)</a>
<a name="ln4411">            || !act-&gt;can_pass_through(newpos)</a>
<a name="ln4412">            || !act-&gt;is_habitable(newpos))</a>
<a name="ln4413">        {</a>
<a name="ln4414">            ray = oldray;</a>
<a name="ln4415">            break;</a>
<a name="ln4416">        }</a>
<a name="ln4417"> </a>
<a name="ln4418">        act-&gt;move_to_pos(newpos);</a>
<a name="ln4419">        if (act-&gt;is_player())</a>
<a name="ln4420">            stop_delay(true);</a>
<a name="ln4421">    }</a>
<a name="ln4422"> </a>
<a name="ln4423">    if (newpos == oldpos)</a>
<a name="ln4424">        return;</a>
<a name="ln4425"> </a>
<a name="ln4426">    if (you.can_see(*act))</a>
<a name="ln4427">    {</a>
<a name="ln4428">        if (origin_spell == SPELL_CHILLING_BREATH)</a>
<a name="ln4429">        {</a>
<a name="ln4430">            mprf(&quot;%s %s blown backwards by the freezing wind.&quot;,</a>
<a name="ln4431">                 act-&gt;name(DESC_THE).c_str(),</a>
<a name="ln4432">                 act-&gt;conj_verb(&quot;are&quot;).c_str());</a>
<a name="ln4433">        }</a>
<a name="ln4434">        else</a>
<a name="ln4435">        {</a>
<a name="ln4436">            mprf(&quot;%s %s knocked back by the %s.&quot;,</a>
<a name="ln4437">                 act-&gt;name(DESC_THE).c_str(),</a>
<a name="ln4438">                 act-&gt;conj_verb(&quot;are&quot;).c_str(),</a>
<a name="ln4439">                 name.c_str());</a>
<a name="ln4440">        }</a>
<a name="ln4441">    }</a>
<a name="ln4442"> </a>
<a name="ln4443">    if (act-&gt;pos() != newpos)</a>
<a name="ln4444">        act-&gt;collide(newpos, agent(), ench_power);</a>
<a name="ln4445"> </a>
<a name="ln4446">    // Stun the monster briefly so that it doesn't look as though it wasn't</a>
<a name="ln4447">    // knocked back at all</a>
<a name="ln4448">    if (act-&gt;is_monster())</a>
<a name="ln4449">        act-&gt;as_monster()-&gt;speed_increment -= random2(6) + 4;</a>
<a name="ln4450"> </a>
<a name="ln4451">    act-&gt;apply_location_effects(oldpos, killer(),</a>
<a name="ln4452">                                actor_to_death_source(agent()));</a>
<a name="ln4453">}</a>
<a name="ln4454"> </a>
<a name="ln4455">void bolt::pull_actor(actor *act, int dam)</a>
<a name="ln4456">{</a>
<a name="ln4457">    if (!act || !can_pull(*act, dam))</a>
<a name="ln4458">        return;</a>
<a name="ln4459"> </a>
<a name="ln4460">    // How far we'll try to pull the actor to make them adjacent to the source.</a>
<a name="ln4461">    const int distance = (act-&gt;pos() - source).rdist() - 1;</a>
<a name="ln4462">    ASSERT(distance &gt; 0);</a>
<a name="ln4463"> </a>
<a name="ln4464">    const coord_def oldpos = act-&gt;pos();</a>
<a name="ln4465">    ASSERT(ray.pos() == oldpos);</a>
<a name="ln4466"> </a>
<a name="ln4467">    coord_def newpos = oldpos;</a>
<a name="ln4468">    for (int dist_travelled = 0; dist_travelled &lt; distance; ++dist_travelled)</a>
<a name="ln4469">    {</a>
<a name="ln4470">        const ray_def oldray(ray);</a>
<a name="ln4471"> </a>
<a name="ln4472">        ray.regress();</a>
<a name="ln4473"> </a>
<a name="ln4474">        newpos = ray.pos();</a>
<a name="ln4475">        if (newpos == oldray.pos()</a>
<a name="ln4476">            || cell_is_solid(newpos)</a>
<a name="ln4477">            || actor_at(newpos)</a>
<a name="ln4478">            || !act-&gt;can_pass_through(newpos)</a>
<a name="ln4479">            || !act-&gt;is_habitable(newpos))</a>
<a name="ln4480">        {</a>
<a name="ln4481">            ray = oldray;</a>
<a name="ln4482">            break;</a>
<a name="ln4483">        }</a>
<a name="ln4484"> </a>
<a name="ln4485">        act-&gt;move_to_pos(newpos);</a>
<a name="ln4486">        if (act-&gt;is_player())</a>
<a name="ln4487">            stop_delay(true);</a>
<a name="ln4488">    }</a>
<a name="ln4489"> </a>
<a name="ln4490">    if (newpos == oldpos)</a>
<a name="ln4491">        return;</a>
<a name="ln4492"> </a>
<a name="ln4493">    if (you.can_see(*act))</a>
<a name="ln4494">    {</a>
<a name="ln4495">        mprf(&quot;%s %s yanked forward by the %s.&quot;, act-&gt;name(DESC_THE).c_str(),</a>
<a name="ln4496">             act-&gt;conj_verb(&quot;are&quot;).c_str(), name.c_str());</a>
<a name="ln4497">    }</a>
<a name="ln4498"> </a>
<a name="ln4499">    if (act-&gt;pos() != newpos)</a>
<a name="ln4500">        act-&gt;collide(newpos, agent(), ench_power);</a>
<a name="ln4501"> </a>
<a name="ln4502">    act-&gt;apply_location_effects(oldpos, killer(),</a>
<a name="ln4503">                                actor_to_death_source(agent()));</a>
<a name="ln4504">}</a>
<a name="ln4505"> </a>
<a name="ln4506">// Return true if the player's god will be unforgiving about the effects</a>
<a name="ln4507">// of this beam.</a>
<a name="ln4508">bool bolt::god_cares() const</a>
<a name="ln4509">{</a>
<a name="ln4510">    return effect_known || effect_wanton;</a>
<a name="ln4511">}</a>
<a name="ln4512"> </a>
<a name="ln4513">// Return true if the block succeeded (including reflections.)</a>
<a name="ln4514">bool bolt::attempt_block(monster* mon)</a>
<a name="ln4515">{</a>
<a name="ln4516">    const int shield_block = mon-&gt;shield_bonus();</a>
<a name="ln4517">    if (shield_block &lt;= 0)</a>
<a name="ln4518">        return false;</a>
<a name="ln4519"> </a>
<a name="ln4520">    const int sh_hit = random2(hit * 130 / 100 + mon-&gt;shield_block_penalty());</a>
<a name="ln4521">    if (sh_hit &gt;= shield_block)</a>
<a name="ln4522">        return false;</a>
<a name="ln4523"> </a>
<a name="ln4524">    item_def *shield = mon-&gt;mslot_item(MSLOT_SHIELD);</a>
<a name="ln4525">    if (is_reflectable(*mon))</a>
<a name="ln4526">    {</a>
<a name="ln4527">        if (mon-&gt;observable())</a>
<a name="ln4528">        {</a>
<a name="ln4529">            if (shield &amp;&amp; is_shield(*shield) &amp;&amp; shield_reflects(*shield))</a>
<a name="ln4530">            {</a>
<a name="ln4531">                mprf(&quot;%s reflects the %s off %s %s!&quot;,</a>
<a name="ln4532">                     mon-&gt;name(DESC_THE).c_str(),</a>
<a name="ln4533">                     name.c_str(),</a>
<a name="ln4534">                     mon-&gt;pronoun(PRONOUN_POSSESSIVE).c_str(),</a>
<a name="ln4535">                     shield-&gt;name(DESC_PLAIN).c_str());</a>
<a name="ln4536">                ident_reflector(shield);</a>
<a name="ln4537">            }</a>
<a name="ln4538">            else</a>
<a name="ln4539">            {</a>
<a name="ln4540">                mprf(&quot;The %s reflects off an invisible shield around %s!&quot;,</a>
<a name="ln4541">                     name.c_str(),</a>
<a name="ln4542">                     mon-&gt;name(DESC_THE).c_str());</a>
<a name="ln4543"> </a>
<a name="ln4544">                item_def *amulet = mon-&gt;mslot_item(MSLOT_JEWELLERY);</a>
<a name="ln4545">                if (amulet)</a>
<a name="ln4546">                    ident_reflector(amulet);</a>
<a name="ln4547">            }</a>
<a name="ln4548">        }</a>
<a name="ln4549">        else if (you.see_cell(pos()))</a>
<a name="ln4550">            mprf(&quot;The %s bounces off of thin air!&quot;, name.c_str());</a>
<a name="ln4551"> </a>
<a name="ln4552">        reflect();</a>
<a name="ln4553">    }</a>
<a name="ln4554">    else if (you.see_cell(pos()))</a>
<a name="ln4555">    {</a>
<a name="ln4556">        mprf(&quot;%s blocks the %s.&quot;,</a>
<a name="ln4557">             mon-&gt;name(DESC_THE).c_str(), name.c_str());</a>
<a name="ln4558">        finish_beam();</a>
<a name="ln4559">    }</a>
<a name="ln4560"> </a>
<a name="ln4561">    mon-&gt;shield_block_succeeded(agent());</a>
<a name="ln4562">    return true;</a>
<a name="ln4563">}</a>
<a name="ln4564"> </a>
<a name="ln4565">/// Is the given monster a bush or bush-like 'monster', and can the given beam</a>
<a name="ln4566">/// travel through it without harm?</a>
<a name="ln4567">bool bolt::bush_immune(const monster &amp;mons) const</a>
<a name="ln4568">{</a>
<a name="ln4569">    return</a>
<a name="ln4570">        (mons_species(mons.type) == MONS_BUSH || mons.type == MONS_BRIAR_PATCH)</a>
<a name="ln4571">        &amp;&amp; !pierce &amp;&amp; !is_explosion</a>
<a name="ln4572">        &amp;&amp; !is_enchantment()</a>
<a name="ln4573">        &amp;&amp; target != mons.pos()</a>
<a name="ln4574">        &amp;&amp; origin_spell != SPELL_STICKY_FLAME</a>
<a name="ln4575">        &amp;&amp; origin_spell != SPELL_STICKY_FLAME_RANGE</a>
<a name="ln4576">        &amp;&amp; origin_spell != SPELL_CHAIN_LIGHTNING;</a>
<a name="ln4577">}</a>
<a name="ln4578"> </a>
<a name="ln4579">void bolt::affect_monster(monster* mon)</a>
<a name="ln4580">{</a>
<a name="ln4581">    // Don't hit dead monsters.</a>
<a name="ln4582">    if (!mon-&gt;alive() || mon-&gt;type == MONS_PLAYER_SHADOW)</a>
<a name="ln4583">        return;</a>
<a name="ln4584"> </a>
<a name="ln4585">    hit_count[mon-&gt;mid]++;</a>
<a name="ln4586"> </a>
<a name="ln4587">    if (shoot_through_monster(*this, mon) &amp;&amp; !is_tracer)</a>
<a name="ln4588">    {</a>
<a name="ln4589">        // FIXME: Could use a better message, something about</a>
<a name="ln4590">        // dodging that doesn't sound excessively weird would be</a>
<a name="ln4591">        // nice.</a>
<a name="ln4592">        if (you.see_cell(mon-&gt;pos()))</a>
<a name="ln4593">        {</a>
<a name="ln4594">            if (testbits(mon-&gt;flags, MF_DEMONIC_GUARDIAN))</a>
<a name="ln4595">                mpr(&quot;Your demonic guardian avoids your attack.&quot;);</a>
<a name="ln4596">            else if (!bush_immune(*mon))</a>
<a name="ln4597">            {</a>
<a name="ln4598">                simple_god_message(</a>
<a name="ln4599">                    make_stringf(&quot; protects %s plant from harm.&quot;,</a>
<a name="ln4600">                        attitude == ATT_FRIENDLY ? &quot;your&quot; : &quot;a&quot;).c_str(),</a>
<a name="ln4601">                    GOD_FEDHAS);</a>
<a name="ln4602">            }</a>
<a name="ln4603">        }</a>
<a name="ln4604">    }</a>
<a name="ln4605"> </a>
<a name="ln4606">    if (flavour == BEAM_WATER &amp;&amp; mon-&gt;type == MONS_WATER_ELEMENTAL &amp;&amp; !is_tracer)</a>
<a name="ln4607">    {</a>
<a name="ln4608">        if (you.see_cell(mon-&gt;pos()))</a>
<a name="ln4609">            mprf(&quot;The %s passes through %s.&quot;, name.c_str(), mon-&gt;name(DESC_THE).c_str());</a>
<a name="ln4610">    }</a>
<a name="ln4611"> </a>
<a name="ln4612">    if (ignores_monster(mon))</a>
<a name="ln4613">        return;</a>
<a name="ln4614"> </a>
<a name="ln4615">    // Handle tracers separately.</a>
<a name="ln4616">    if (is_tracer)</a>
<a name="ln4617">    {</a>
<a name="ln4618">        tracer_affect_monster(mon);</a>
<a name="ln4619">        return;</a>
<a name="ln4620">    }</a>
<a name="ln4621"> </a>
<a name="ln4622">    // Visual - wake monsters.</a>
<a name="ln4623">    if (flavour == BEAM_VISUAL)</a>
<a name="ln4624">    {</a>
<a name="ln4625">        behaviour_event(mon, ME_DISTURB, agent(), source);</a>
<a name="ln4626">        return;</a>
<a name="ln4627">    }</a>
<a name="ln4628"> </a>
<a name="ln4629">    if (flavour == BEAM_MISSILE &amp;&amp; item)</a>
<a name="ln4630">    {</a>
<a name="ln4631">        actor *ag = agent(true);</a>
<a name="ln4632">        // if the agent is now dead, check to see if we can get a usable agent</a>
<a name="ln4633">        // by factoring in reflections. This case will cause</a>
<a name="ln4634">        // &quot;INVALID YOU_FAULTLESS&quot; to show up in dprfs and mess up the to-hit,</a>
<a name="ln4635">        // but it otherwise works.</a>
<a name="ln4636">        // TODO Possibly what should happen is that the thrower's death should</a>
<a name="ln4637">        // be special-cased as a fineff, but this seemed very tricky to</a>
<a name="ln4638">        // implement...</a>
<a name="ln4639">        if (!ag)</a>
<a name="ln4640">            ag = agent(false);</a>
<a name="ln4641">        ASSERT(ag);</a>
<a name="ln4642">        ranged_attack attk(ag, mon, item, use_target_as_pos, agent());</a>
<a name="ln4643">        attk.attack();</a>
<a name="ln4644">        // fsim purposes - throw_it detects if an attack connected through</a>
<a name="ln4645">        // hit_verb</a>
<a name="ln4646">        if (attk.ev_margin &gt;= 0 &amp;&amp; hit_verb.empty())</a>
<a name="ln4647">            hit_verb = attk.attack_verb;</a>
<a name="ln4648">        if (attk.reflected)</a>
<a name="ln4649">            reflect();</a>
<a name="ln4650">        extra_range_used += attk.range_used;</a>
<a name="ln4651">        return;</a>
<a name="ln4652">    }</a>
<a name="ln4653"> </a>
<a name="ln4654">    // Explosions always 'hit'.</a>
<a name="ln4655">    const bool engulfs = (is_explosion || is_big_cloud());</a>
<a name="ln4656"> </a>
<a name="ln4657">    if (is_enchantment())</a>
<a name="ln4658">    {</a>
<a name="ln4659">        if (real_flavour == BEAM_CHAOS || real_flavour == BEAM_RANDOM)</a>
<a name="ln4660">        {</a>
<a name="ln4661">            if (hit_verb.empty())</a>
<a name="ln4662">                hit_verb = engulfs ? &quot;engulfs&quot; : &quot;hits&quot;;</a>
<a name="ln4663">            if (you.see_cell(mon-&gt;pos()))</a>
<a name="ln4664">            {</a>
<a name="ln4665">                mprf(&quot;The %s %s %s.&quot;, name.c_str(), hit_verb.c_str(),</a>
<a name="ln4666">                     mon-&gt;name(DESC_THE).c_str());</a>
<a name="ln4667">            }</a>
<a name="ln4668">            else if (heard &amp;&amp; !hit_noise_msg.empty())</a>
<a name="ln4669">                mprf(MSGCH_SOUND, &quot;%s&quot;, hit_noise_msg.c_str());</a>
<a name="ln4670">        }</a>
<a name="ln4671">        // no to-hit check</a>
<a name="ln4672">        enchantment_affect_monster(mon);</a>
<a name="ln4673">        return;</a>
<a name="ln4674">    }</a>
<a name="ln4675"> </a>
<a name="ln4676">    if (is_explosion &amp;&amp; !in_explosion_phase)</a>
<a name="ln4677">    {</a>
<a name="ln4678">        // It hit a monster, so the beam should terminate.</a>
<a name="ln4679">        // Don't actually affect the monster; the explosion</a>
<a name="ln4680">        // will take care of that.</a>
<a name="ln4681">        finish_beam();</a>
<a name="ln4682">        return;</a>
<a name="ln4683">    }</a>
<a name="ln4684"> </a>
<a name="ln4685">    // We need to know how much the monster _would_ be hurt by this,</a>
<a name="ln4686">    // before we decide if it actually hits.</a>
<a name="ln4687">    int preac, postac, final;</a>
<a name="ln4688">    if (!determine_damage(mon, preac, postac, final))</a>
<a name="ln4689">        return;</a>
<a name="ln4690"> </a>
<a name="ln4691">#ifdef DEBUG_DIAGNOSTICS</a>
<a name="ln4692">    dprf(DIAG_BEAM, &quot;Monster: %s; Damage: pre-AC: %d; post-AC: %d; post-resist: %d&quot;,</a>
<a name="ln4693">         mon-&gt;name(DESC_PLAIN).c_str(), preac, postac, final);</a>
<a name="ln4694">#endif</a>
<a name="ln4695"> </a>
<a name="ln4696">    // Player beams which hit friendlies or good neutrals will annoy</a>
<a name="ln4697">    // them and be considered naughty if they do damage (this is so as</a>
<a name="ln4698">    // not to penalise players that fling fireballs into a melee with</a>
<a name="ln4699">    // fire elementals on their side - the elementals won't give a sh*t,</a>
<a name="ln4700">    // after all).</a>
<a name="ln4701"> </a>
<a name="ln4702">    god_conduct_trigger conducts[3];</a>
<a name="ln4703"> </a>
<a name="ln4704">    if (nasty_to(mon))</a>
<a name="ln4705">    {</a>
<a name="ln4706">        if (YOU_KILL(thrower) &amp;&amp; final &gt; 0)</a>
<a name="ln4707">            set_attack_conducts(conducts, *mon, you.can_see(*mon));</a>
<a name="ln4708">    }</a>
<a name="ln4709"> </a>
<a name="ln4710">    if (engulfs &amp;&amp; flavour == BEAM_SPORE // XXX: engulfs is redundant?</a>
<a name="ln4711">        &amp;&amp; mon-&gt;holiness() &amp; MH_NATURAL</a>
<a name="ln4712">        &amp;&amp; !mon-&gt;is_unbreathing())</a>
<a name="ln4713">    {</a>
<a name="ln4714">        apply_enchantment_to_monster(mon);</a>
<a name="ln4715">    }</a>
<a name="ln4716"> </a>
<a name="ln4717">    if (flavour == BEAM_UNRAVELLED_MAGIC)</a>
<a name="ln4718">    {</a>
<a name="ln4719">        int unused; // res_margin</a>
<a name="ln4720">        try_enchant_monster(mon, unused);</a>
<a name="ln4721">    }</a>
<a name="ln4722"> </a>
<a name="ln4723">    // Make a copy of the to-hit before we modify it.</a>
<a name="ln4724">    int beam_hit = hit;</a>
<a name="ln4725"> </a>
<a name="ln4726">    if (beam_hit != AUTOMATIC_HIT)</a>
<a name="ln4727">    {</a>
<a name="ln4728">        if (mon-&gt;invisible() &amp;&amp; !can_see_invis)</a>
<a name="ln4729">            beam_hit /= 2;</a>
<a name="ln4730"> </a>
<a name="ln4731">        // Backlit is easier to hit:</a>
<a name="ln4732">        if (mon-&gt;backlit(false))</a>
<a name="ln4733">            beam_hit += 2 + random2(8);</a>
<a name="ln4734"> </a>
<a name="ln4735">        // Umbra is harder to hit:</a>
<a name="ln4736">        if (!nightvision &amp;&amp; mon-&gt;umbra())</a>
<a name="ln4737">            beam_hit -= 2 + random2(4);</a>
<a name="ln4738">    }</a>
<a name="ln4739"> </a>
<a name="ln4740">    // The monster may block the beam.</a>
<a name="ln4741">    if (!engulfs &amp;&amp; is_blockable() &amp;&amp; attempt_block(mon))</a>
<a name="ln4742">        return;</a>
<a name="ln4743"> </a>
<a name="ln4744">    defer_rand r;</a>
<a name="ln4745">    int rand_ev = random2(mon-&gt;evasion());</a>
<a name="ln4746">    bool repel = mon-&gt;missile_repulsion();</a>
<a name="ln4747"> </a>
<a name="ln4748">    // FIXME: We're randomising mon-&gt;evasion, which is further</a>
<a name="ln4749">    // randomised inside test_beam_hit. This is so we stay close to the</a>
<a name="ln4750">    // 4.0 to-hit system (which had very little love for monsters).</a>
<a name="ln4751">    if (!engulfs &amp;&amp; !_test_beam_hit(beam_hit, rand_ev, pierce, repel, r))</a>
<a name="ln4752">    {</a>
<a name="ln4753">        const bool repelled = _test_beam_hit(beam_hit, rand_ev, pierce, 0, r);</a>
<a name="ln4754">        // If the PLAYER cannot see the monster, don't tell them anything!</a>
<a name="ln4755">        if (mon-&gt;observable() &amp;&amp; name != &quot;burst of metal fragments&quot;)</a>
<a name="ln4756">        {</a>
<a name="ln4757">            // if it would have hit otherwise...</a>
<a name="ln4758">            if (_test_beam_hit(beam_hit, rand_ev, pierce, 0, r))</a>
<a name="ln4759">            {</a>
<a name="ln4760">                msg::stream &lt;&lt; mon-&gt;name(DESC_THE) &lt;&lt; &quot; &quot;</a>
<a name="ln4761">                            &lt;&lt; &quot;repels the &quot; &lt;&lt; name</a>
<a name="ln4762">                            &lt;&lt; '!' &lt;&lt; endl;</a>
<a name="ln4763">            }</a>
<a name="ln4764">            else</a>
<a name="ln4765">            {</a>
<a name="ln4766">                msg::stream &lt;&lt; &quot;The &quot; &lt;&lt; name &lt;&lt; &quot; misses &quot;</a>
<a name="ln4767">                            &lt;&lt; mon-&gt;name(DESC_THE) &lt;&lt; '.' &lt;&lt; endl;</a>
<a name="ln4768">            }</a>
<a name="ln4769">        }</a>
<a name="ln4770">        if (repelled)</a>
<a name="ln4771">            mon-&gt;ablate_repulsion();</a>
<a name="ln4772">        return;</a>
<a name="ln4773">    }</a>
<a name="ln4774"> </a>
<a name="ln4775">    update_hurt_or_helped(mon);</a>
<a name="ln4776"> </a>
<a name="ln4777">    // We'll say ballistomycete spore explosions don't trigger the ally attack</a>
<a name="ln4778">    // conduct for Fedhas worshipers. Mostly because you can accidentally blow</a>
<a name="ln4779">    // up a group of 8 plants and get placed under penance until the end of</a>
<a name="ln4780">    // time otherwise. I'd prefer to do this elsewhere but the beam information</a>
<a name="ln4781">    // goes out of scope.</a>
<a name="ln4782">    if (you_worship(GOD_FEDHAS) &amp;&amp; flavour == BEAM_SPORE)</a>
<a name="ln4783">        conducts[0].set();</a>
<a name="ln4784"> </a>
<a name="ln4785">    if (!is_explosion &amp;&amp; !noise_generated)</a>
<a name="ln4786">    {</a>
<a name="ln4787">        heard = noisy(loudness, pos(), source_id) || heard;</a>
<a name="ln4788">        noise_generated = true;</a>
<a name="ln4789">    }</a>
<a name="ln4790"> </a>
<a name="ln4791">    if (!mon-&gt;alive())</a>
<a name="ln4792">        return;</a>
<a name="ln4793"> </a>
<a name="ln4794">    // The beam hit.</a>
<a name="ln4795">    if (you.see_cell(mon-&gt;pos()))</a>
<a name="ln4796">    {</a>
<a name="ln4797">        // Monsters are never currently helpless in ranged combat.</a>
<a name="ln4798">        if (hit_verb.empty())</a>
<a name="ln4799">            hit_verb = engulfs ? &quot;engulfs&quot; : &quot;hits&quot;;</a>
<a name="ln4800"> </a>
<a name="ln4801">        // If the beam did no damage because of resistances,</a>
<a name="ln4802">        // mons_adjust_flavoured below will print &quot;%s completely resists&quot;, so</a>
<a name="ln4803">        // no need to also say &quot;does no damage&quot; here.</a>
<a name="ln4804">        mprf(&quot;The %s %s %s%s%s&quot;,</a>
<a name="ln4805">             name.c_str(),</a>
<a name="ln4806">             hit_verb.c_str(),</a>
<a name="ln4807">             mon-&gt;name(DESC_THE).c_str(),</a>
<a name="ln4808">             postac ? &quot;&quot; : &quot; but does no damage&quot;,</a>
<a name="ln4809">             attack_strength_punctuation(final).c_str());</a>
<a name="ln4810"> </a>
<a name="ln4811">    }</a>
<a name="ln4812">    else if (heard &amp;&amp; !hit_noise_msg.empty())</a>
<a name="ln4813">        mprf(MSGCH_SOUND, &quot;%s&quot;, hit_noise_msg.c_str());</a>
<a name="ln4814">    // The player might hear something, if _they_ fired a missile</a>
<a name="ln4815">    // (not magic beam).</a>
<a name="ln4816">    else if (!silenced(you.pos()) &amp;&amp; flavour == BEAM_MISSILE</a>
<a name="ln4817">             &amp;&amp; YOU_KILL(thrower))</a>
<a name="ln4818">    {</a>
<a name="ln4819">        mprf(MSGCH_SOUND, &quot;The %s hits something.&quot;, name.c_str());</a>
<a name="ln4820">    }</a>
<a name="ln4821"> </a>
<a name="ln4822">    // Apply flavoured specials.</a>
<a name="ln4823">    mons_adjust_flavoured(mon, *this, postac, true);</a>
<a name="ln4824"> </a>
<a name="ln4825">    // mons_adjust_flavoured may kill the monster directly.</a>
<a name="ln4826">    if (mon-&gt;alive())</a>
<a name="ln4827">    {</a>
<a name="ln4828">        // If the beam is an actual missile or of the MMISSILE type</a>
<a name="ln4829">        // (Earth magic) we might bleed on the floor.</a>
<a name="ln4830">        if (!engulfs</a>
<a name="ln4831">            &amp;&amp; (flavour == BEAM_MISSILE || flavour == BEAM_MMISSILE)</a>
<a name="ln4832">            &amp;&amp; !mon-&gt;is_summoned())</a>
<a name="ln4833">        {</a>
<a name="ln4834">            // Using raw_damage instead of the flavoured one!</a>
<a name="ln4835">            // assumes DVORP_PIERCING, factor: 0.5</a>
<a name="ln4836">            const int blood = min(postac/2, mon-&gt;hit_points);</a>
<a name="ln4837">            bleed_onto_floor(mon-&gt;pos(), mon-&gt;type, blood, true);</a>
<a name="ln4838">        }</a>
<a name="ln4839">        // Now hurt monster.</a>
<a name="ln4840">        mon-&gt;hurt(agent(), final, flavour, KILLED_BY_BEAM, &quot;&quot;, &quot;&quot;, false);</a>
<a name="ln4841">    }</a>
<a name="ln4842"> </a>
<a name="ln4843">    if (mon-&gt;alive())</a>
<a name="ln4844">        monster_post_hit(mon, final);</a>
<a name="ln4845">    // The monster (e.g. a spectral weapon) might have self-destructed in its</a>
<a name="ln4846">    // behaviour_event called from mon-&gt;hurt() above. If that happened, it</a>
<a name="ln4847">    // will have been cleaned up already (and is therefore invalid now).</a>
<a name="ln4848">    else if (!invalid_monster(mon))</a>
<a name="ln4849">    {</a>
<a name="ln4850">        // Preserve name of the source monster if it winds up killing</a>
<a name="ln4851">        // itself.</a>
<a name="ln4852">        if (mon-&gt;mid == source_id &amp;&amp; source_name.empty())</a>
<a name="ln4853">            source_name = mon-&gt;name(DESC_A, true);</a>
<a name="ln4854"> </a>
<a name="ln4855">        int kindex = actor_to_death_source(agent());</a>
<a name="ln4856">        if (origin_spell == SPELL_GLACIATE</a>
<a name="ln4857">            &amp;&amp; !mon-&gt;is_insubstantial()</a>
<a name="ln4858">            &amp;&amp; x_chance_in_y(3, 5))</a>
<a name="ln4859">        {</a>
<a name="ln4860">            // Includes monster_die as part of converting to block of ice.</a>
<a name="ln4861">            glaciate_freeze(mon, thrower, kindex);</a>
<a name="ln4862">        }</a>
<a name="ln4863">        // Prevent spore explosions killing plants from being registered</a>
<a name="ln4864">        // as a Fedhas misconduct. Deaths can trigger the ally dying or</a>
<a name="ln4865">        // plant dying conducts, but spore explosions shouldn't count</a>
<a name="ln4866">        // for either of those.</a>
<a name="ln4867">        //</a>
<a name="ln4868">        // FIXME: Should be a better way of doing this. For now, we are</a>
<a name="ln4869">        // just falsifying the death report... -cao</a>
<a name="ln4870">        else if (you_worship(GOD_FEDHAS) &amp;&amp; flavour == BEAM_SPORE</a>
<a name="ln4871">            &amp;&amp; fedhas_protects(mon))</a>
<a name="ln4872">        {</a>
<a name="ln4873">            if (mon-&gt;attitude == ATT_FRIENDLY)</a>
<a name="ln4874">                mon-&gt;attitude = ATT_HOSTILE;</a>
<a name="ln4875">            monster_die(*mon, KILL_MON, kindex);</a>
<a name="ln4876">        }</a>
<a name="ln4877">        else</a>
<a name="ln4878">        {</a>
<a name="ln4879">            killer_type ref_killer = thrower;</a>
<a name="ln4880">            if (!YOU_KILL(thrower) &amp;&amp; reflector == MID_PLAYER)</a>
<a name="ln4881">            {</a>
<a name="ln4882">                ref_killer = KILL_YOU_MISSILE;</a>
<a name="ln4883">                kindex = YOU_FAULTLESS;</a>
<a name="ln4884">            }</a>
<a name="ln4885">            monster_die(*mon, ref_killer, kindex);</a>
<a name="ln4886">        }</a>
<a name="ln4887">    }</a>
<a name="ln4888"> </a>
<a name="ln4889">    extra_range_used += range_used_on_hit();</a>
<a name="ln4890">}</a>
<a name="ln4891"> </a>
<a name="ln4892">bool bolt::ignores_monster(const monster* mon) const</a>
<a name="ln4893">{</a>
<a name="ln4894">    // Digging doesn't affect monsters (should it harm earth elementals?).</a>
<a name="ln4895">    if (flavour == BEAM_DIGGING)</a>
<a name="ln4896">        return true;</a>
<a name="ln4897"> </a>
<a name="ln4898">    // The targeters might call us with nullptr in the event of a remembered</a>
<a name="ln4899">    // monster that is no longer there. Treat it as opaque.</a>
<a name="ln4900">    if (!mon)</a>
<a name="ln4901">        return false;</a>
<a name="ln4902"> </a>
<a name="ln4903">    // All kinds of beams go past orbs of destruction and friendly</a>
<a name="ln4904">    // battlespheres.</a>
<a name="ln4905">    if (mons_is_projectile(*mon)</a>
<a name="ln4906">        || (mons_is_avatar(mon-&gt;type) &amp;&amp; mons_aligned(agent(), mon)))</a>
<a name="ln4907">    {</a>
<a name="ln4908">        return true;</a>
<a name="ln4909">    }</a>
<a name="ln4910"> </a>
<a name="ln4911">    // Missiles go past bushes and briar patches, unless aimed directly at them</a>
<a name="ln4912">    if (bush_immune(*mon))</a>
<a name="ln4913">        return true;</a>
<a name="ln4914"> </a>
<a name="ln4915">    if (shoot_through_monster(*this, mon))</a>
<a name="ln4916">        return true;</a>
<a name="ln4917"> </a>
<a name="ln4918">    // Fire storm creates these, so we'll avoid affecting them.</a>
<a name="ln4919">    if (origin_spell == SPELL_FIRE_STORM &amp;&amp; mon-&gt;type == MONS_FIRE_VORTEX)</a>
<a name="ln4920">        return true;</a>
<a name="ln4921"> </a>
<a name="ln4922">    // Don't blow up blocks of ice with the spell that creates them.</a>
<a name="ln4923">    if (origin_spell == SPELL_GLACIATE &amp;&amp; mon-&gt;type == MONS_BLOCK_OF_ICE)</a>
<a name="ln4924">        return true;</a>
<a name="ln4925"> </a>
<a name="ln4926">    if (flavour == BEAM_WATER &amp;&amp; mon-&gt;type == MONS_WATER_ELEMENTAL)</a>
<a name="ln4927">        return true;</a>
<a name="ln4928"> </a>
<a name="ln4929">    return false;</a>
<a name="ln4930">}</a>
<a name="ln4931"> </a>
<a name="ln4932">bool bolt::has_saving_throw() const</a>
<a name="ln4933">{</a>
<a name="ln4934">    if (aimed_at_feet)</a>
<a name="ln4935">        return false;</a>
<a name="ln4936"> </a>
<a name="ln4937">    switch (flavour)</a>
<a name="ln4938">    {</a>
<a name="ln4939">    case BEAM_HASTE:</a>
<a name="ln4940">    case BEAM_MIGHT:</a>
<a name="ln4941">    case BEAM_BERSERK:</a>
<a name="ln4942">    case BEAM_HEALING:</a>
<a name="ln4943">    case BEAM_INVISIBILITY:</a>
<a name="ln4944">    case BEAM_DISPEL_UNDEAD:</a>
<a name="ln4945">    case BEAM_BLINK_CLOSE:</a>
<a name="ln4946">    case BEAM_BLINK:</a>
<a name="ln4947">    case BEAM_BECKONING:</a>
<a name="ln4948">    case BEAM_MALIGN_OFFERING:</a>
<a name="ln4949">    case BEAM_AGILITY:</a>
<a name="ln4950">    case BEAM_RESISTANCE:</a>
<a name="ln4951">    case BEAM_MALMUTATE:</a>
<a name="ln4952">    case BEAM_SAP_MAGIC:</a>
<a name="ln4953">    case BEAM_UNRAVELLING:</a>
<a name="ln4954">    case BEAM_UNRAVELLED_MAGIC:</a>
<a name="ln4955">    case BEAM_INFESTATION:</a>
<a name="ln4956">    case BEAM_IRRESISTIBLE_CONFUSION:</a>
<a name="ln4957">    case BEAM_VILE_CLUTCH:</a>
<a name="ln4958">        return false;</a>
<a name="ln4959">    case BEAM_VULNERABILITY:</a>
<a name="ln4960">        return !one_chance_in(3);  // Ignores MR 1/3 of the time</a>
<a name="ln4961">    case BEAM_PARALYSIS:        // Giant eyeball paralysis is irresistible</a>
<a name="ln4962">        return !(agent() &amp;&amp; agent()-&gt;type == MONS_FLOATING_EYE);</a>
<a name="ln4963">    default:</a>
<a name="ln4964">        return true;</a>
<a name="ln4965">    }</a>
<a name="ln4966">}</a>
<a name="ln4967"> </a>
<a name="ln4968">bool ench_flavour_affects_monster(beam_type flavour, const monster* mon,</a>
<a name="ln4969">                                  bool intrinsic_only)</a>
<a name="ln4970">{</a>
<a name="ln4971">    bool rc = true;</a>
<a name="ln4972">    switch (flavour)</a>
<a name="ln4973">    {</a>
<a name="ln4974">    case BEAM_MALMUTATE:</a>
<a name="ln4975">    case BEAM_UNRAVELLED_MAGIC:</a>
<a name="ln4976">        rc = mon-&gt;can_mutate();</a>
<a name="ln4977">        break;</a>
<a name="ln4978"> </a>
<a name="ln4979">    case BEAM_SLOW:</a>
<a name="ln4980">    case BEAM_HASTE:</a>
<a name="ln4981">    case BEAM_PARALYSIS:</a>
<a name="ln4982">        rc = !mon-&gt;stasis();</a>
<a name="ln4983">        break;</a>
<a name="ln4984"> </a>
<a name="ln4985">    case BEAM_POLYMORPH:</a>
<a name="ln4986">        rc = mon-&gt;can_polymorph();</a>
<a name="ln4987">        break;</a>
<a name="ln4988"> </a>
<a name="ln4989">    case BEAM_DISPEL_UNDEAD:</a>
<a name="ln4990">        rc = bool(mon-&gt;holiness() &amp; MH_UNDEAD);</a>
<a name="ln4991">        break;</a>
<a name="ln4992"> </a>
<a name="ln4993">    case BEAM_PAIN:</a>
<a name="ln4994">        rc = mon-&gt;res_negative_energy(intrinsic_only) &lt; 3;</a>
<a name="ln4995">        break;</a>
<a name="ln4996"> </a>
<a name="ln4997">    case BEAM_AGONY:</a>
<a name="ln4998">        rc = !mon-&gt;res_torment();</a>
<a name="ln4999">        break;</a>
<a name="ln5000"> </a>
<a name="ln5001">    case BEAM_HIBERNATION:</a>
<a name="ln5002">        rc = mon-&gt;can_hibernate(false, intrinsic_only);</a>
<a name="ln5003">        break;</a>
<a name="ln5004"> </a>
<a name="ln5005">    case BEAM_PORKALATOR:</a>
<a name="ln5006">        rc = (mon-&gt;holiness() &amp; MH_DEMONIC &amp;&amp; mon-&gt;type != MONS_HELL_HOG)</a>
<a name="ln5007">              || (mon-&gt;holiness() &amp; MH_NATURAL &amp;&amp; mon-&gt;type != MONS_HOG)</a>
<a name="ln5008">              || (mon-&gt;holiness() &amp; MH_HOLY &amp;&amp; mon-&gt;type != MONS_HOLY_SWINE);</a>
<a name="ln5009">        break;</a>
<a name="ln5010"> </a>
<a name="ln5011">    case BEAM_SENTINEL_MARK:</a>
<a name="ln5012">        rc = false;</a>
<a name="ln5013">        break;</a>
<a name="ln5014"> </a>
<a name="ln5015">    case BEAM_MALIGN_OFFERING:</a>
<a name="ln5016">        rc = (mon-&gt;res_negative_energy(intrinsic_only) &lt; 3);</a>
<a name="ln5017">        break;</a>
<a name="ln5018"> </a>
<a name="ln5019">    case BEAM_VIRULENCE:</a>
<a name="ln5020">        rc = (mon-&gt;res_poison() &lt; 3);</a>
<a name="ln5021">        break;</a>
<a name="ln5022"> </a>
<a name="ln5023">    case BEAM_DRAIN_MAGIC:</a>
<a name="ln5024">        rc = mon-&gt;antimagic_susceptible();</a>
<a name="ln5025">        break;</a>
<a name="ln5026"> </a>
<a name="ln5027">    case BEAM_INNER_FLAME:</a>
<a name="ln5028">        rc = !mon-&gt;has_ench(ENCH_INNER_FLAME);</a>
<a name="ln5029">        break;</a>
<a name="ln5030"> </a>
<a name="ln5031">    case BEAM_PETRIFY:</a>
<a name="ln5032">        rc = !mon-&gt;res_petrify();</a>
<a name="ln5033">        break;</a>
<a name="ln5034"> </a>
<a name="ln5035">    case BEAM_INFESTATION:</a>
<a name="ln5036">        rc = mons_gives_xp(*mon, you) &amp;&amp; !mon-&gt;has_ench(ENCH_INFESTATION);</a>
<a name="ln5037">        break;</a>
<a name="ln5038"> </a>
<a name="ln5039">    case BEAM_VILE_CLUTCH:</a>
<a name="ln5040">        rc = !mons_aligned(&amp;you, mon) &amp;&amp; you.can_constrict(mon, false);</a>
<a name="ln5041">        break;</a>
<a name="ln5042"> </a>
<a name="ln5043">    // These are special allies whose loyalty can't be so easily bent</a>
<a name="ln5044">    case BEAM_ENSLAVE:</a>
<a name="ln5045">        rc = !(mons_is_hepliaklqana_ancestor(mon-&gt;type)</a>
<a name="ln5046">               || testbits(mon-&gt;flags, MF_DEMONIC_GUARDIAN));</a>
<a name="ln5047">        break;</a>
<a name="ln5048"> </a>
<a name="ln5049">    default:</a>
<a name="ln5050">        break;</a>
<a name="ln5051">    }</a>
<a name="ln5052"> </a>
<a name="ln5053">    return rc;</a>
<a name="ln5054">}</a>
<a name="ln5055"> </a>
<a name="ln5056">bool enchant_actor_with_flavour(actor* victim, const actor *foe,</a>
<a name="ln5057">                                beam_type flavour, int powc)</a>
<a name="ln5058">{</a>
<a name="ln5059">    bolt dummy;</a>
<a name="ln5060">    dummy.flavour = flavour;</a>
<a name="ln5061">    dummy.ench_power = powc;</a>
<a name="ln5062">    dummy.set_agent(foe);</a>
<a name="ln5063">    dummy.animate = false;</a>
<a name="ln5064">    if (victim-&gt;is_player())</a>
<a name="ln5065">        dummy.affect_player_enchantment(false);</a>
<a name="ln5066">    else</a>
<a name="ln5067">        dummy.apply_enchantment_to_monster(victim-&gt;as_monster());</a>
<a name="ln5068">    return dummy.obvious_effect;</a>
<a name="ln5069">}</a>
<a name="ln5070"> </a>
<a name="ln5071">bool enchant_monster_invisible(monster* mon, const string &amp;how)</a>
<a name="ln5072">{</a>
<a name="ln5073">    // Store the monster name before it becomes an &quot;it&quot;. - bwr</a>
<a name="ln5074">    const string monster_name = mon-&gt;name(DESC_THE);</a>
<a name="ln5075">    const bool could_see = you.can_see(*mon);</a>
<a name="ln5076"> </a>
<a name="ln5077">    if (mon-&gt;has_ench(ENCH_INVIS) || !mon-&gt;add_ench(ENCH_INVIS))</a>
<a name="ln5078">        return false;</a>
<a name="ln5079"> </a>
<a name="ln5080">    if (could_see)</a>
<a name="ln5081">    {</a>
<a name="ln5082">        const bool is_visible = mon-&gt;visible_to(&amp;you);</a>
<a name="ln5083"> </a>
<a name="ln5084">        // Can't use simple_monster_message(*) here, since it checks</a>
<a name="ln5085">        // for visibility of the monster (and it's now invisible).</a>
<a name="ln5086">        // - bwr</a>
<a name="ln5087">        mprf(&quot;%s %s%s&quot;,</a>
<a name="ln5088">             monster_name.c_str(),</a>
<a name="ln5089">             how.c_str(),</a>
<a name="ln5090">             is_visible ? &quot; for a moment.&quot;</a>
<a name="ln5091">                        : &quot;!&quot;);</a>
<a name="ln5092"> </a>
<a name="ln5093">        if (!is_visible &amp;&amp; !mons_is_safe(mon))</a>
<a name="ln5094">            autotoggle_autopickup(true);</a>
<a name="ln5095">    }</a>
<a name="ln5096"> </a>
<a name="ln5097">    return true;</a>
<a name="ln5098">}</a>
<a name="ln5099"> </a>
<a name="ln5100">mon_resist_type bolt::try_enchant_monster(monster* mon, int &amp;res_margin)</a>
<a name="ln5101">{</a>
<a name="ln5102">    // Early out if the enchantment is meaningless.</a>
<a name="ln5103">    if (!ench_flavour_affects_monster(flavour, mon))</a>
<a name="ln5104">        return MON_UNAFFECTED;</a>
<a name="ln5105"> </a>
<a name="ln5106">    // Check magic resistance.</a>
<a name="ln5107">    if (has_saving_throw())</a>
<a name="ln5108">    {</a>
<a name="ln5109">        if (mons_immune_magic(*mon))</a>
<a name="ln5110">            return MON_UNAFFECTED;</a>
<a name="ln5111"> </a>
<a name="ln5112">        // (Very) ugly things and shapeshifters will never resist</a>
<a name="ln5113">        // polymorph beams.</a>
<a name="ln5114">        if (flavour == BEAM_POLYMORPH</a>
<a name="ln5115">            &amp;&amp; (mon-&gt;type == MONS_UGLY_THING</a>
<a name="ln5116">                || mon-&gt;type == MONS_VERY_UGLY_THING</a>
<a name="ln5117">                || mon-&gt;is_shapeshifter()))</a>
<a name="ln5118">        {</a>
<a name="ln5119">            ;</a>
<a name="ln5120">        }</a>
<a name="ln5121">        // Chaos effects don't get a resistance check to match melee chaos.</a>
<a name="ln5122">        else if (real_flavour != BEAM_CHAOS)</a>
<a name="ln5123">        {</a>
<a name="ln5124">            if (mon-&gt;check_res_magic(ench_power) &gt; 0)</a>
<a name="ln5125">            {</a>
<a name="ln5126">                // Note only actually used by messages in this case.</a>
<a name="ln5127">                res_margin = mon-&gt;res_magic() - ench_power_stepdown(ench_power);</a>
<a name="ln5128">                return MON_RESIST;</a>
<a name="ln5129">            }</a>
<a name="ln5130">        }</a>
<a name="ln5131">    }</a>
<a name="ln5132"> </a>
<a name="ln5133">    return apply_enchantment_to_monster(mon);</a>
<a name="ln5134">}</a>
<a name="ln5135"> </a>
<a name="ln5136">mon_resist_type bolt::apply_enchantment_to_monster(monster* mon)</a>
<a name="ln5137">{</a>
<a name="ln5138">    // Gigantic-switches-R-Us</a>
<a name="ln5139">    switch (flavour)</a>
<a name="ln5140">    {</a>
<a name="ln5141">    case BEAM_TELEPORT:</a>
<a name="ln5142">        if (mon-&gt;no_tele())</a>
<a name="ln5143">            return MON_UNAFFECTED;</a>
<a name="ln5144">        if (mon-&gt;observable())</a>
<a name="ln5145">            obvious_effect = true;</a>
<a name="ln5146">        monster_teleport(mon, false);</a>
<a name="ln5147">        return MON_AFFECTED;</a>
<a name="ln5148"> </a>
<a name="ln5149">    case BEAM_BLINK:</a>
<a name="ln5150">        if (mon-&gt;no_tele())</a>
<a name="ln5151">            return MON_UNAFFECTED;</a>
<a name="ln5152">        if (mon-&gt;observable())</a>
<a name="ln5153">            obvious_effect = true;</a>
<a name="ln5154">        monster_blink(mon);</a>
<a name="ln5155">        return MON_AFFECTED;</a>
<a name="ln5156"> </a>
<a name="ln5157">    case BEAM_BLINK_CLOSE:</a>
<a name="ln5158">        if (mon-&gt;no_tele())</a>
<a name="ln5159">            return MON_UNAFFECTED;</a>
<a name="ln5160">        if (mon-&gt;observable())</a>
<a name="ln5161">            obvious_effect = true;</a>
<a name="ln5162">        blink_other_close(mon, source);</a>
<a name="ln5163">        return MON_AFFECTED;</a>
<a name="ln5164"> </a>
<a name="ln5165">    case BEAM_BECKONING:</a>
<a name="ln5166">        obvious_effect = beckon(*mon, *this);</a>
<a name="ln5167">        return obvious_effect ? MON_AFFECTED : MON_OTHER; // ?</a>
<a name="ln5168"> </a>
<a name="ln5169">    case BEAM_POLYMORPH:</a>
<a name="ln5170">        if (mon-&gt;polymorph(ench_power))</a>
<a name="ln5171">            obvious_effect = true;</a>
<a name="ln5172">        if (YOU_KILL(thrower))</a>
<a name="ln5173">        {</a>
<a name="ln5174">            const int level = 2 + random2(3);</a>
<a name="ln5175">            did_god_conduct(DID_DELIBERATE_MUTATING, level, god_cares());</a>
<a name="ln5176">        }</a>
<a name="ln5177">        return MON_AFFECTED;</a>
<a name="ln5178"> </a>
<a name="ln5179">    case BEAM_MALMUTATE:</a>
<a name="ln5180">    case BEAM_UNRAVELLED_MAGIC:</a>
<a name="ln5181">        if (mon-&gt;malmutate(&quot;&quot;)) // exact source doesn't matter</a>
<a name="ln5182">            obvious_effect = true;</a>
<a name="ln5183">        if (YOU_KILL(thrower))</a>
<a name="ln5184">        {</a>
<a name="ln5185">            const int level = 2 + random2(3);</a>
<a name="ln5186">            did_god_conduct(DID_DELIBERATE_MUTATING, level, god_cares());</a>
<a name="ln5187">        }</a>
<a name="ln5188">        return MON_AFFECTED;</a>
<a name="ln5189"> </a>
<a name="ln5190">    case BEAM_BANISH:</a>
<a name="ln5191">        mon-&gt;banish(agent());</a>
<a name="ln5192">        obvious_effect = true;</a>
<a name="ln5193">        return MON_AFFECTED;</a>
<a name="ln5194"> </a>
<a name="ln5195">    case BEAM_DISPEL_UNDEAD:</a>
<a name="ln5196">    {</a>
<a name="ln5197">        const int dam = damage.roll();</a>
<a name="ln5198">        if (you.see_cell(mon-&gt;pos()))</a>
<a name="ln5199">        {</a>
<a name="ln5200">            mprf(&quot;%s is dispelled%s&quot;,</a>
<a name="ln5201">                 mon-&gt;name(DESC_THE).c_str(),</a>
<a name="ln5202">                 attack_strength_punctuation(dam).c_str());</a>
<a name="ln5203">            obvious_effect = true;</a>
<a name="ln5204">        }</a>
<a name="ln5205">        mon-&gt;hurt(agent(), dam);</a>
<a name="ln5206">        return MON_AFFECTED;</a>
<a name="ln5207">    }</a>
<a name="ln5208"> </a>
<a name="ln5209">    case BEAM_PAIN:</a>
<a name="ln5210">    {</a>
<a name="ln5211">        const int dam = resist_adjust_damage(mon, flavour, damage.roll());</a>
<a name="ln5212">        if (dam)</a>
<a name="ln5213">        {</a>
<a name="ln5214">            if (you.see_cell(mon-&gt;pos()))</a>
<a name="ln5215">            {</a>
<a name="ln5216">                mprf(&quot;%s writhes in agony%s&quot;,</a>
<a name="ln5217">                     mon-&gt;name(DESC_THE).c_str(),</a>
<a name="ln5218">                     attack_strength_punctuation(dam).c_str());</a>
<a name="ln5219">                obvious_effect = true;</a>
<a name="ln5220">            }</a>
<a name="ln5221">            mon-&gt;hurt(agent(), dam, flavour);</a>
<a name="ln5222">            return MON_AFFECTED;</a>
<a name="ln5223">        }</a>
<a name="ln5224">        return MON_UNAFFECTED;</a>
<a name="ln5225">    }</a>
<a name="ln5226"> </a>
<a name="ln5227">    case BEAM_AGONY:</a>
<a name="ln5228">        torment_cell(mon-&gt;pos(), agent(), TORMENT_AGONY);</a>
<a name="ln5229">        obvious_effect = true;</a>
<a name="ln5230">        return MON_AFFECTED;</a>
<a name="ln5231"> </a>
<a name="ln5232">    case BEAM_DISINTEGRATION:   // disrupt/disintegrate</a>
<a name="ln5233">    {</a>
<a name="ln5234">        const int dam = damage.roll();</a>
<a name="ln5235">        if (you.see_cell(mon-&gt;pos()))</a>
<a name="ln5236">        {</a>
<a name="ln5237">            mprf(&quot;%s is blasted%s&quot;,</a>
<a name="ln5238">                 mon-&gt;name(DESC_THE).c_str(),</a>
<a name="ln5239">                 attack_strength_punctuation(dam).c_str());</a>
<a name="ln5240">            obvious_effect = true;</a>
<a name="ln5241">        }</a>
<a name="ln5242">        mon-&gt;hurt(agent(), dam, flavour);</a>
<a name="ln5243">        return MON_AFFECTED;</a>
<a name="ln5244">    }</a>
<a name="ln5245"> </a>
<a name="ln5246">    case BEAM_HIBERNATION:</a>
<a name="ln5247">        if (mon-&gt;can_hibernate())</a>
<a name="ln5248">        {</a>
<a name="ln5249">            if (simple_monster_message(*mon, &quot; looks drowsy...&quot;))</a>
<a name="ln5250">                obvious_effect = true;</a>
<a name="ln5251">            mon-&gt;put_to_sleep(agent(), ench_power, true);</a>
<a name="ln5252">            return MON_AFFECTED;</a>
<a name="ln5253">        }</a>
<a name="ln5254">        return MON_UNAFFECTED;</a>
<a name="ln5255"> </a>
<a name="ln5256">    case BEAM_CORONA:</a>
<a name="ln5257">        if (backlight_monster(mon))</a>
<a name="ln5258">        {</a>
<a name="ln5259">            obvious_effect = true;</a>
<a name="ln5260">            return MON_AFFECTED;</a>
<a name="ln5261">        }</a>
<a name="ln5262">        return MON_UNAFFECTED;</a>
<a name="ln5263"> </a>
<a name="ln5264">    case BEAM_SLOW:</a>
<a name="ln5265">        obvious_effect = do_slow_monster(*mon, agent(),</a>
<a name="ln5266">                                         ench_power * BASELINE_DELAY);</a>
<a name="ln5267">        return MON_AFFECTED;</a>
<a name="ln5268"> </a>
<a name="ln5269">    case BEAM_HASTE:</a>
<a name="ln5270">        if (YOU_KILL(thrower))</a>
<a name="ln5271">            did_god_conduct(DID_HASTY, 6, god_cares());</a>
<a name="ln5272"> </a>
<a name="ln5273">        if (mon-&gt;stasis())</a>
<a name="ln5274">            return MON_AFFECTED;</a>
<a name="ln5275"> </a>
<a name="ln5276">        if (!mon-&gt;has_ench(ENCH_HASTE)</a>
<a name="ln5277">            &amp;&amp; !mon-&gt;is_stationary()</a>
<a name="ln5278">            &amp;&amp; mon-&gt;add_ench(ENCH_HASTE))</a>
<a name="ln5279">        {</a>
<a name="ln5280">            if (!mons_is_immotile(*mon)</a>
<a name="ln5281">                &amp;&amp; simple_monster_message(*mon, &quot; seems to speed up.&quot;))</a>
<a name="ln5282">            {</a>
<a name="ln5283">                obvious_effect = true;</a>
<a name="ln5284">            }</a>
<a name="ln5285">        }</a>
<a name="ln5286">        return MON_AFFECTED;</a>
<a name="ln5287"> </a>
<a name="ln5288">    case BEAM_MIGHT:</a>
<a name="ln5289">        if (!mon-&gt;has_ench(ENCH_MIGHT)</a>
<a name="ln5290">            &amp;&amp; !mon-&gt;is_stationary()</a>
<a name="ln5291">            &amp;&amp; mon-&gt;add_ench(ENCH_MIGHT))</a>
<a name="ln5292">        {</a>
<a name="ln5293">            if (simple_monster_message(*mon, &quot; seems to grow stronger.&quot;))</a>
<a name="ln5294">                obvious_effect = true;</a>
<a name="ln5295">        }</a>
<a name="ln5296">        return MON_AFFECTED;</a>
<a name="ln5297"> </a>
<a name="ln5298">    case BEAM_BERSERK:</a>
<a name="ln5299">        if (!mon-&gt;berserk_or_insane())</a>
<a name="ln5300">        {</a>
<a name="ln5301">            // currently from potion, hence voluntary</a>
<a name="ln5302">            mon-&gt;go_berserk(true);</a>
<a name="ln5303">            // can't return this from go_berserk, unfortunately</a>
<a name="ln5304">            obvious_effect = you.can_see(*mon);</a>
<a name="ln5305">        }</a>
<a name="ln5306">        return MON_AFFECTED;</a>
<a name="ln5307"> </a>
<a name="ln5308">    case BEAM_HEALING:</a>
<a name="ln5309">        // No KILL_YOU_CONF, or we get &quot;You heal ...&quot;</a>
<a name="ln5310">        if (thrower == KILL_YOU || thrower == KILL_YOU_MISSILE)</a>
<a name="ln5311">        {</a>
<a name="ln5312">            const int pow = min(50, 3 + damage.roll());</a>
<a name="ln5313">            const int amount = pow + roll_dice(2, pow) - 2;</a>
<a name="ln5314">            if (heal_monster(*mon, amount))</a>
<a name="ln5315">                obvious_effect = true;</a>
<a name="ln5316">            msg_generated = true; // to avoid duplicate &quot;nothing happens&quot;</a>
<a name="ln5317">        }</a>
<a name="ln5318">        else if (mon-&gt;heal(3 + damage.roll()))</a>
<a name="ln5319">        {</a>
<a name="ln5320">            if (mon-&gt;hit_points == mon-&gt;max_hit_points)</a>
<a name="ln5321">            {</a>
<a name="ln5322">                if (simple_monster_message(*mon, &quot;'s wounds heal themselves!&quot;))</a>
<a name="ln5323">                    obvious_effect = true;</a>
<a name="ln5324">            }</a>
<a name="ln5325">            else if (simple_monster_message(*mon, &quot; is healed somewhat.&quot;))</a>
<a name="ln5326">                obvious_effect = true;</a>
<a name="ln5327">        }</a>
<a name="ln5328">        return MON_AFFECTED;</a>
<a name="ln5329"> </a>
<a name="ln5330">    case BEAM_PARALYSIS:</a>
<a name="ln5331">        apply_bolt_paralysis(mon);</a>
<a name="ln5332">        return MON_AFFECTED;</a>
<a name="ln5333"> </a>
<a name="ln5334">    case BEAM_PETRIFY:</a>
<a name="ln5335">        if (mon-&gt;res_petrify())</a>
<a name="ln5336">            return MON_UNAFFECTED;</a>
<a name="ln5337"> </a>
<a name="ln5338">        apply_bolt_petrify(mon);</a>
<a name="ln5339">        return MON_AFFECTED;</a>
<a name="ln5340"> </a>
<a name="ln5341">    case BEAM_SPORE:</a>
<a name="ln5342">    case BEAM_CONFUSION:</a>
<a name="ln5343">    case BEAM_IRRESISTIBLE_CONFUSION:</a>
<a name="ln5344">        if (mon-&gt;check_clarity())</a>
<a name="ln5345">        {</a>
<a name="ln5346">            if (you.can_see(*mon))</a>
<a name="ln5347">                obvious_effect = true;</a>
<a name="ln5348">            return MON_AFFECTED;</a>
<a name="ln5349">        }</a>
<a name="ln5350">        {</a>
<a name="ln5351">            // irresistible confusion has a shorter duration and is weaker</a>
<a name="ln5352">            // against strong monsters</a>
<a name="ln5353">            int dur = ench_power;</a>
<a name="ln5354">            if (flavour == BEAM_IRRESISTIBLE_CONFUSION)</a>
<a name="ln5355">                dur = max(10, dur - mon-&gt;get_hit_dice());</a>
<a name="ln5356">            else</a>
<a name="ln5357">                dur = _ench_pow_to_dur(dur);</a>
<a name="ln5358"> </a>
<a name="ln5359">            if (mon-&gt;add_ench(mon_enchant(ENCH_CONFUSION, 0, agent(), dur)))</a>
<a name="ln5360">            {</a>
<a name="ln5361">                // FIXME: Put in an exception for things you won't notice</a>
<a name="ln5362">                // becoming confused.</a>
<a name="ln5363">                if (simple_monster_message(*mon, &quot; appears confused.&quot;))</a>
<a name="ln5364">                    obvious_effect = true;</a>
<a name="ln5365">            }</a>
<a name="ln5366">        }</a>
<a name="ln5367">        return MON_AFFECTED;</a>
<a name="ln5368"> </a>
<a name="ln5369">    case BEAM_SLEEP:</a>
<a name="ln5370">        if (mons_just_slept(*mon))</a>
<a name="ln5371">            return MON_UNAFFECTED;</a>
<a name="ln5372"> </a>
<a name="ln5373">        mon-&gt;put_to_sleep(agent(), ench_power);</a>
<a name="ln5374">        if (simple_monster_message(*mon, &quot; falls asleep!&quot;))</a>
<a name="ln5375">            obvious_effect = true;</a>
<a name="ln5376"> </a>
<a name="ln5377">        return MON_AFFECTED;</a>
<a name="ln5378"> </a>
<a name="ln5379">    case BEAM_INVISIBILITY:</a>
<a name="ln5380">    {</a>
<a name="ln5381">        if (enchant_monster_invisible(mon, &quot;flickers and vanishes&quot;))</a>
<a name="ln5382">            obvious_effect = true;</a>
<a name="ln5383"> </a>
<a name="ln5384">        return MON_AFFECTED;</a>
<a name="ln5385">    }</a>
<a name="ln5386"> </a>
<a name="ln5387">    case BEAM_ENSLAVE:</a>
<a name="ln5388">        if (agent() &amp;&amp; agent()-&gt;is_monster())</a>
<a name="ln5389">        {</a>
<a name="ln5390">            enchant_type good = (agent()-&gt;wont_attack()) ? ENCH_CHARM</a>
<a name="ln5391">                                                         : ENCH_HEXED;</a>
<a name="ln5392">            enchant_type bad  = (agent()-&gt;wont_attack()) ? ENCH_HEXED</a>
<a name="ln5393">                                                         : ENCH_CHARM;</a>
<a name="ln5394"> </a>
<a name="ln5395">            const bool could_see = you.can_see(*mon);</a>
<a name="ln5396">            if (mon-&gt;has_ench(bad))</a>
<a name="ln5397">            {</a>
<a name="ln5398">                obvious_effect = mon-&gt;del_ench(bad);</a>
<a name="ln5399">                return MON_AFFECTED;</a>
<a name="ln5400">            }</a>
<a name="ln5401">            if (simple_monster_message(*mon, &quot; is enslaved!&quot;))</a>
<a name="ln5402">                obvious_effect = true;</a>
<a name="ln5403">            mon-&gt;add_ench(mon_enchant(good, 0, agent()));</a>
<a name="ln5404">            if (!obvious_effect &amp;&amp; could_see &amp;&amp; !you.can_see(*mon))</a>
<a name="ln5405">                obvious_effect = true;</a>
<a name="ln5406">            return MON_AFFECTED;</a>
<a name="ln5407">        }</a>
<a name="ln5408"> </a>
<a name="ln5409">        // Being a puppet on magic strings is a nasty thing.</a>
<a name="ln5410">        // Mindless creatures shouldn't probably mind, but because of complex</a>
<a name="ln5411">        // behaviour of enslaved neutrals, let's disallow that for now.</a>
<a name="ln5412">        mon-&gt;attitude = ATT_HOSTILE;</a>
<a name="ln5413"> </a>
<a name="ln5414">        // XXX: Another hackish thing for Pikel's band neutrality.</a>
<a name="ln5415">        if (mons_is_mons_class(mon, MONS_PIKEL))</a>
<a name="ln5416">            pikel_band_neutralise();</a>
<a name="ln5417"> </a>
<a name="ln5418">        if (simple_monster_message(*mon, &quot; is charmed.&quot;))</a>
<a name="ln5419">            obvious_effect = true;</a>
<a name="ln5420">        mon-&gt;add_ench(ENCH_CHARM);</a>
<a name="ln5421">        if (you.can_see(*mon))</a>
<a name="ln5422">            obvious_effect = true;</a>
<a name="ln5423">        return MON_AFFECTED;</a>
<a name="ln5424"> </a>
<a name="ln5425">    case BEAM_PORKALATOR:</a>
<a name="ln5426">    {</a>
<a name="ln5427">        // Monsters which use the ghost structure can't be properly</a>
<a name="ln5428">        // restored from hog form.</a>
<a name="ln5429">        if (mons_is_ghost_demon(mon-&gt;type))</a>
<a name="ln5430">            return MON_UNAFFECTED;</a>
<a name="ln5431"> </a>
<a name="ln5432">        monster orig_mon(*mon);</a>
<a name="ln5433">        if (monster_polymorph(mon, mon-&gt;holiness() &amp; MH_DEMONIC ?</a>
<a name="ln5434">                      MONS_HELL_HOG : mon-&gt;holiness() &amp; MH_HOLY ?</a>
<a name="ln5435">                      MONS_HOLY_SWINE : MONS_HOG))</a>
<a name="ln5436">        {</a>
<a name="ln5437">            obvious_effect = true;</a>
<a name="ln5438"> </a>
<a name="ln5439">            // Don't restore items to monster if it reverts.</a>
<a name="ln5440">            orig_mon.inv = mon-&gt;inv;</a>
<a name="ln5441"> </a>
<a name="ln5442">            // monsters can't cast spells in hog form either -doy</a>
<a name="ln5443">            mon-&gt;spells.clear();</a>
<a name="ln5444"> </a>
<a name="ln5445">            // For monster reverting to original form.</a>
<a name="ln5446">            mon-&gt;props[ORIG_MONSTER_KEY] = orig_mon;</a>
<a name="ln5447">        }</a>
<a name="ln5448"> </a>
<a name="ln5449">        return MON_AFFECTED;</a>
<a name="ln5450">    }</a>
<a name="ln5451"> </a>
<a name="ln5452">    case BEAM_INNER_FLAME:</a>
<a name="ln5453">        if (!mon-&gt;has_ench(ENCH_INNER_FLAME)</a>
<a name="ln5454">            &amp;&amp; mon-&gt;add_ench(mon_enchant(ENCH_INNER_FLAME, 0, agent())))</a>
<a name="ln5455">        {</a>
<a name="ln5456">            if (simple_monster_message(*mon,</a>
<a name="ln5457">                                       (mon-&gt;body_size(PSIZE_BODY) &gt; SIZE_BIG)</a>
<a name="ln5458">                                        ? &quot; is filled with an intense inner flame!&quot;</a>
<a name="ln5459">                                        : &quot; is filled with an inner flame.&quot;))</a>
<a name="ln5460">            {</a>
<a name="ln5461">                obvious_effect = true;</a>
<a name="ln5462">            }</a>
<a name="ln5463">        }</a>
<a name="ln5464">        return MON_AFFECTED;</a>
<a name="ln5465"> </a>
<a name="ln5466">    case BEAM_DIMENSION_ANCHOR:</a>
<a name="ln5467">        if (!mon-&gt;has_ench(ENCH_DIMENSION_ANCHOR)</a>
<a name="ln5468">            &amp;&amp; mon-&gt;add_ench(mon_enchant(ENCH_DIMENSION_ANCHOR, 0, agent(),</a>
<a name="ln5469">                                         random_range(20, 30) * BASELINE_DELAY)))</a>
<a name="ln5470">        {</a>
<a name="ln5471">            if (simple_monster_message(*mon, &quot; is firmly anchored in space.&quot;))</a>
<a name="ln5472">                obvious_effect = true;</a>
<a name="ln5473">        }</a>
<a name="ln5474">        return MON_AFFECTED;</a>
<a name="ln5475"> </a>
<a name="ln5476">    case BEAM_VULNERABILITY:</a>
<a name="ln5477">        if (!mon-&gt;has_ench(ENCH_LOWERED_MR)</a>
<a name="ln5478">            &amp;&amp; mon-&gt;add_ench(mon_enchant(ENCH_LOWERED_MR, 0, agent(),</a>
<a name="ln5479">                                         random_range(20, 30) * BASELINE_DELAY)))</a>
<a name="ln5480">        {</a>
<a name="ln5481">            if (you.can_see(*mon))</a>
<a name="ln5482">            {</a>
<a name="ln5483">                mprf(&quot;%s magical defenses are stripped away.&quot;,</a>
<a name="ln5484">                     mon-&gt;name(DESC_ITS).c_str());</a>
<a name="ln5485">                obvious_effect = true;</a>
<a name="ln5486">            }</a>
<a name="ln5487">        }</a>
<a name="ln5488">        return MON_AFFECTED;</a>
<a name="ln5489"> </a>
<a name="ln5490">    case BEAM_MALIGN_OFFERING:</a>
<a name="ln5491">    {</a>
<a name="ln5492">        const int dam = resist_adjust_damage(mon, flavour, damage.roll());</a>
<a name="ln5493">        if (dam)</a>
<a name="ln5494">        {</a>
<a name="ln5495">            _malign_offering_effect(mon, agent(), dam);</a>
<a name="ln5496">            obvious_effect = true;</a>
<a name="ln5497">            return MON_AFFECTED;</a>
<a name="ln5498">        }</a>
<a name="ln5499">        else</a>
<a name="ln5500">        {</a>
<a name="ln5501">            simple_monster_message(*mon, &quot; is unaffected.&quot;);</a>
<a name="ln5502">            return MON_UNAFFECTED;</a>
<a name="ln5503">        }</a>
<a name="ln5504">    }</a>
<a name="ln5505"> </a>
<a name="ln5506">    case BEAM_VIRULENCE:</a>
<a name="ln5507">        if (!mon-&gt;has_ench(ENCH_POISON_VULN)</a>
<a name="ln5508">            &amp;&amp; mon-&gt;add_ench(mon_enchant(ENCH_POISON_VULN, 0, agent(),</a>
<a name="ln5509">                                         random_range(20, 30) * BASELINE_DELAY)))</a>
<a name="ln5510">        {</a>
<a name="ln5511">            if (simple_monster_message(*mon,</a>
<a name="ln5512">                                       &quot; grows more vulnerable to poison.&quot;))</a>
<a name="ln5513">            {</a>
<a name="ln5514">                obvious_effect = true;</a>
<a name="ln5515">            }</a>
<a name="ln5516">        }</a>
<a name="ln5517">        return MON_AFFECTED;</a>
<a name="ln5518"> </a>
<a name="ln5519">    case BEAM_AGILITY:</a>
<a name="ln5520">        if (!mon-&gt;has_ench(ENCH_AGILE)</a>
<a name="ln5521">            &amp;&amp; !mon-&gt;is_stationary()</a>
<a name="ln5522">            &amp;&amp; mon-&gt;add_ench(ENCH_AGILE))</a>
<a name="ln5523">        {</a>
<a name="ln5524">            if (simple_monster_message(*mon, &quot; suddenly seems more agile.&quot;))</a>
<a name="ln5525">                obvious_effect = true;</a>
<a name="ln5526">        }</a>
<a name="ln5527">        return MON_AFFECTED;</a>
<a name="ln5528"> </a>
<a name="ln5529">    case BEAM_SAP_MAGIC:</a>
<a name="ln5530">        if (!SAP_MAGIC_CHANCE())</a>
<a name="ln5531">        {</a>
<a name="ln5532">            if (you.can_see(*mon))</a>
<a name="ln5533">                canned_msg(MSG_NOTHING_HAPPENS);</a>
<a name="ln5534">            break;</a>
<a name="ln5535">        }</a>
<a name="ln5536">        if (!mon-&gt;has_ench(ENCH_SAP_MAGIC)</a>
<a name="ln5537">            &amp;&amp; mon-&gt;add_ench(mon_enchant(ENCH_SAP_MAGIC, 0, agent())))</a>
<a name="ln5538">        {</a>
<a name="ln5539">            if (you.can_see(*mon))</a>
<a name="ln5540">            {</a>
<a name="ln5541">                mprf(&quot;%s seems less certain of %s magic.&quot;,</a>
<a name="ln5542">                     mon-&gt;name(DESC_THE).c_str(), mon-&gt;pronoun(PRONOUN_POSSESSIVE).c_str());</a>
<a name="ln5543">                obvious_effect = true;</a>
<a name="ln5544">            }</a>
<a name="ln5545">        }</a>
<a name="ln5546">        return MON_AFFECTED;</a>
<a name="ln5547"> </a>
<a name="ln5548">    case BEAM_DRAIN_MAGIC:</a>
<a name="ln5549">    {</a>
<a name="ln5550">        if (!mon-&gt;antimagic_susceptible())</a>
<a name="ln5551">            break;</a>
<a name="ln5552"> </a>
<a name="ln5553">        const int dur =</a>
<a name="ln5554">            random2(div_rand_round(ench_power, mon-&gt;get_hit_dice()) + 1)</a>
<a name="ln5555">                    * BASELINE_DELAY;</a>
<a name="ln5556">        mon-&gt;add_ench(mon_enchant(ENCH_ANTIMAGIC, 0,</a>
<a name="ln5557">                                  agent(), // doesn't matter</a>
<a name="ln5558">                                  dur));</a>
<a name="ln5559">        if (you.can_see(*mon))</a>
<a name="ln5560">        {</a>
<a name="ln5561">            mprf(&quot;%s magic leaks into the air.&quot;,</a>
<a name="ln5562">                 apostrophise(mon-&gt;name(DESC_THE)).c_str());</a>
<a name="ln5563">        }</a>
<a name="ln5564"> </a>
<a name="ln5565">        if (agent() &amp;&amp; (agent()-&gt;type == MONS_EYE_OF_DRAINING</a>
<a name="ln5566">                        || agent()-&gt;type == MONS_GHOST_MOTH))</a>
<a name="ln5567">        {</a>
<a name="ln5568">            agent()-&gt;heal(dur / BASELINE_DELAY);</a>
<a name="ln5569">        }</a>
<a name="ln5570">        obvious_effect = true;</a>
<a name="ln5571">        break;</a>
<a name="ln5572">    }</a>
<a name="ln5573"> </a>
<a name="ln5574">    case BEAM_TUKIMAS_DANCE:</a>
<a name="ln5575">        cast_tukimas_dance(ench_power, mon);</a>
<a name="ln5576">        obvious_effect = true;</a>
<a name="ln5577">        break;</a>
<a name="ln5578"> </a>
<a name="ln5579">    case BEAM_RESISTANCE:</a>
<a name="ln5580">        if (!mon-&gt;has_ench(ENCH_RESISTANCE)</a>
<a name="ln5581">            &amp;&amp; mon-&gt;add_ench(ENCH_RESISTANCE))</a>
<a name="ln5582">        {</a>
<a name="ln5583">            if (simple_monster_message(*mon, &quot; suddenly seems more resistant.&quot;))</a>
<a name="ln5584">                obvious_effect = true;</a>
<a name="ln5585">        }</a>
<a name="ln5586">        return MON_AFFECTED;</a>
<a name="ln5587"> </a>
<a name="ln5588">    case BEAM_UNRAVELLING:</a>
<a name="ln5589">        if (!monster_is_debuffable(*mon))</a>
<a name="ln5590">            return MON_UNAFFECTED;</a>
<a name="ln5591"> </a>
<a name="ln5592">        debuff_monster(*mon);</a>
<a name="ln5593">        _unravelling_explode(*this);</a>
<a name="ln5594">        return MON_AFFECTED;</a>
<a name="ln5595"> </a>
<a name="ln5596">    case BEAM_INFESTATION:</a>
<a name="ln5597">    {</a>
<a name="ln5598">        const int dur = (5 + random2avg(ench_power / 2, 2)) * BASELINE_DELAY;</a>
<a name="ln5599">        mon-&gt;add_ench(mon_enchant(ENCH_INFESTATION, 0, &amp;you, dur));</a>
<a name="ln5600">        if (simple_monster_message(*mon, &quot; is infested!&quot;))</a>
<a name="ln5601">            obvious_effect = true;</a>
<a name="ln5602">        return MON_AFFECTED;</a>
<a name="ln5603">    }</a>
<a name="ln5604"> </a>
<a name="ln5605">    case BEAM_VILE_CLUTCH:</a>
<a name="ln5606">    {</a>
<a name="ln5607">        const int dur = (4 + random2avg(div_rand_round(ench_power, 10), 2))</a>
<a name="ln5608">            * BASELINE_DELAY;</a>
<a name="ln5609">        dprf(&quot;Vile clutch duration: %d&quot;, dur);</a>
<a name="ln5610">        mon-&gt;add_ench(mon_enchant(ENCH_VILE_CLUTCH, 0, &amp;you, dur));</a>
<a name="ln5611">        obvious_effect = true;</a>
<a name="ln5612">        return MON_AFFECTED;</a>
<a name="ln5613">    }</a>
<a name="ln5614"> </a>
<a name="ln5615">    default:</a>
<a name="ln5616">        break;</a>
<a name="ln5617">    }</a>
<a name="ln5618"> </a>
<a name="ln5619">    return MON_AFFECTED;</a>
<a name="ln5620">}</a>
<a name="ln5621"> </a>
<a name="ln5622">// Extra range used on hit.</a>
<a name="ln5623">int bolt::range_used_on_hit() const</a>
<a name="ln5624">{</a>
<a name="ln5625">    int used = 0;</a>
<a name="ln5626"> </a>
<a name="ln5627">    // Non-beams can only affect one thing (player/monster).</a>
<a name="ln5628">    if (!pierce)</a>
<a name="ln5629">        used = BEAM_STOP;</a>
<a name="ln5630">    // These beams fully penetrate regardless of anything else.</a>
<a name="ln5631">    else if (flavour == BEAM_DAMNATION</a>
<a name="ln5632">             || flavour == BEAM_DIGGING</a>
<a name="ln5633">             || flavour == BEAM_VILE_CLUTCH)</a>
<a name="ln5634">    {</a>
<a name="ln5635">        used = 0;</a>
<a name="ln5636">    }</a>
<a name="ln5637">    // Other enchants that aren't Line Pass and explosions/clouds stop.</a>
<a name="ln5638">    else if (is_enchantment() &amp;&amp; name != &quot;line pass&quot;</a>
<a name="ln5639">             || is_explosion</a>
<a name="ln5640">             || is_big_cloud())</a>
<a name="ln5641">    {</a>
<a name="ln5642">        used = BEAM_STOP;</a>
<a name="ln5643">    }</a>
<a name="ln5644">    // Lightning that isn't an explosion goes through things.</a>
<a name="ln5645">    else if (flavour == BEAM_ELECTRICITY)</a>
<a name="ln5646">        used = 0;</a>
<a name="ln5647">    else</a>
<a name="ln5648">        used = 1;</a>
<a name="ln5649"> </a>
<a name="ln5650">    // Assume we didn't hit, after all.</a>
<a name="ln5651">    if (is_tracer &amp;&amp; source_id == MID_PLAYER &amp;&amp; used &gt; 0</a>
<a name="ln5652">        &amp;&amp; hit &lt; AUTOMATIC_HIT)</a>
<a name="ln5653">    {</a>
<a name="ln5654">        return 0;</a>
<a name="ln5655">    }</a>
<a name="ln5656"> </a>
<a name="ln5657">    if (in_explosion_phase)</a>
<a name="ln5658">        return used;</a>
<a name="ln5659"> </a>
<a name="ln5660">    return used;</a>
<a name="ln5661">}</a>
<a name="ln5662"> </a>
<a name="ln5663">// Information for how various explosions look &amp; sound.</a>
<a name="ln5664">struct explosion_sfx</a>
<a name="ln5665">{</a>
<a name="ln5666">    // A message printed when the player sees the explosion.</a>
<a name="ln5667">    const char *seeMsg;</a>
<a name="ln5668">    // What the player hears when the explosion goes off unseen.</a>
<a name="ln5669">    const char *sound;</a>
<a name="ln5670">};</a>
<a name="ln5671"> </a>
<a name="ln5672">// A map from origin_spells to special explosion info for each.</a>
<a name="ln5673">const map&lt;spell_type, explosion_sfx&gt; spell_explosions = {</a>
<a name="ln5674">    { SPELL_HURL_DAMNATION, {</a>
<a name="ln5675">        &quot;The sphere of damnation explodes!&quot;,</a>
<a name="ln5676">        &quot;the wailing of the damned&quot;,</a>
<a name="ln5677">    } },</a>
<a name="ln5678">    { SPELL_CALL_DOWN_DAMNATION, {</a>
<a name="ln5679">        &quot;The sphere of damnation explodes!&quot;,</a>
<a name="ln5680">        &quot;the wailing of the damned&quot;,</a>
<a name="ln5681">    } },</a>
<a name="ln5682">    { SPELL_FIREBALL, {</a>
<a name="ln5683">        &quot;The fireball explodes!&quot;,</a>
<a name="ln5684">        &quot;an explosion&quot;,</a>
<a name="ln5685">    } },</a>
<a name="ln5686">    { SPELL_ORB_OF_ELECTRICITY, {</a>
<a name="ln5687">        &quot;The orb of electricity explodes!&quot;,</a>
<a name="ln5688">        &quot;a clap of thunder&quot;,</a>
<a name="ln5689">    } },</a>
<a name="ln5690">    { SPELL_FIRE_STORM, {</a>
<a name="ln5691">        &quot;A raging storm of fire appears!&quot;,</a>
<a name="ln5692">        &quot;a raging storm&quot;,</a>
<a name="ln5693">    } },</a>
<a name="ln5694">    { SPELL_MEPHITIC_CLOUD, {</a>
<a name="ln5695">        &quot;The ball explodes into a vile cloud!&quot;,</a>
<a name="ln5696">        &quot;a loud \'bang\'&quot;,</a>
<a name="ln5697">    } },</a>
<a name="ln5698">    { SPELL_GHOSTLY_FIREBALL, {</a>
<a name="ln5699">        &quot;The ghostly flame explodes!&quot;,</a>
<a name="ln5700">        &quot;the shriek of haunting fire&quot;,</a>
<a name="ln5701">    } },</a>
<a name="ln5702">    { SPELL_VIOLENT_UNRAVELLING, {</a>
<a name="ln5703">        &quot;The enchantments explode!&quot;,</a>
<a name="ln5704">        &quot;a sharp crackling&quot;, // radiation = geiger counter</a>
<a name="ln5705">    } },</a>
<a name="ln5706">    { SPELL_ICEBLAST, {</a>
<a name="ln5707">        &quot;The mass of ice explodes!&quot;,</a>
<a name="ln5708">        &quot;an explosion&quot;,</a>
<a name="ln5709">    } },</a>
<a name="ln5710">    { SPELL_GHOSTLY_SACRIFICE, {</a>
<a name="ln5711">        &quot;The ghostly flame explodes!&quot;,</a>
<a name="ln5712">        &quot;the shriek of haunting fire&quot;,</a>
<a name="ln5713">    } },</a>
<a name="ln5714">};</a>
<a name="ln5715"> </a>
<a name="ln5716">// Takes a bolt and refines it for use in the explosion function.</a>
<a name="ln5717">// Explosions which do not follow from beams bypass this function.</a>
<a name="ln5718">void bolt::refine_for_explosion()</a>
<a name="ln5719">{</a>
<a name="ln5720">    ASSERT(!special_explosion);</a>
<a name="ln5721"> </a>
<a name="ln5722">    string seeMsg;</a>
<a name="ln5723">    string hearMsg;</a>
<a name="ln5724"> </a>
<a name="ln5725">    if (ex_size == 0)</a>
<a name="ln5726">        ex_size = 1;</a>
<a name="ln5727">    glyph   = dchar_glyph(DCHAR_FIRED_BURST);</a>
<a name="ln5728"> </a>
<a name="ln5729">    // Assume that the player can see/hear the explosion, or</a>
<a name="ln5730">    // gets burned by it anyway.  :)</a>
<a name="ln5731">    msg_generated = true;</a>
<a name="ln5732"> </a>
<a name="ln5733">    if (item != nullptr)</a>
<a name="ln5734">    {</a>
<a name="ln5735">        seeMsg  = &quot;The &quot; + item-&gt;name(DESC_PLAIN, false, false, false)</a>
<a name="ln5736">                  + &quot; explodes!&quot;;</a>
<a name="ln5737">        hearMsg = &quot;You hear an explosion!&quot;;</a>
<a name="ln5738">    }</a>
<a name="ln5739">    else</a>
<a name="ln5740">    {</a>
<a name="ln5741">        const explosion_sfx *explosion = map_find(spell_explosions,</a>
<a name="ln5742">                                                  origin_spell);</a>
<a name="ln5743">        if (explosion)</a>
<a name="ln5744">        {</a>
<a name="ln5745">            seeMsg = explosion-&gt;seeMsg;</a>
<a name="ln5746">            hearMsg = make_stringf(&quot;You hear %s!&quot;, explosion-&gt;sound);</a>
<a name="ln5747">        }</a>
<a name="ln5748">        else</a>
<a name="ln5749">        {</a>
<a name="ln5750">            seeMsg  = &quot;The beam explodes into a cloud of software bugs!&quot;;</a>
<a name="ln5751">            hearMsg = &quot;You hear the sound of one hand!&quot;;</a>
<a name="ln5752">        }</a>
<a name="ln5753">    }</a>
<a name="ln5754"> </a>
<a name="ln5755">    if (origin_spell == SPELL_ORB_OF_ELECTRICITY)</a>
<a name="ln5756">    {</a>
<a name="ln5757">        colour     = LIGHTCYAN;</a>
<a name="ln5758">        ex_size    = 2;</a>
<a name="ln5759">    }</a>
<a name="ln5760"> </a>
<a name="ln5761">    if (!is_tracer &amp;&amp; !seeMsg.empty() &amp;&amp; !hearMsg.empty())</a>
<a name="ln5762">    {</a>
<a name="ln5763">        heard = player_can_hear(target);</a>
<a name="ln5764">        // Check for see/hear/no msg.</a>
<a name="ln5765">        if (you.see_cell(target) || target == you.pos())</a>
<a name="ln5766">            mpr(seeMsg);</a>
<a name="ln5767">        else</a>
<a name="ln5768">        {</a>
<a name="ln5769">            if (!heard)</a>
<a name="ln5770">                msg_generated = false;</a>
<a name="ln5771">            else</a>
<a name="ln5772">                mprf(MSGCH_SOUND, &quot;%s&quot;, hearMsg.c_str());</a>
<a name="ln5773">        }</a>
<a name="ln5774">    }</a>
<a name="ln5775">}</a>
<a name="ln5776"> </a>
<a name="ln5777">typedef vector&lt; vector&lt;coord_def&gt; &gt; sweep_type;</a>
<a name="ln5778"> </a>
<a name="ln5779">static sweep_type _radial_sweep(int r)</a>
<a name="ln5780">{</a>
<a name="ln5781">    sweep_type result;</a>
<a name="ln5782"> </a>
<a name="ln5783">    // Center first.</a>
<a name="ln5784">    result.emplace_back(1, coord_def(0,0));</a>
<a name="ln5785"> </a>
<a name="ln5786">    for (int rad = 1; rad &lt;= r; ++rad)</a>
<a name="ln5787">    {</a>
<a name="ln5788">        sweep_type::value_type work;</a>
<a name="ln5789"> </a>
<a name="ln5790">        for (int d = -rad; d &lt;= rad; ++d)</a>
<a name="ln5791">        {</a>
<a name="ln5792">            // Don't put the corners in twice!</a>
<a name="ln5793">            if (d != rad &amp;&amp; d != -rad)</a>
<a name="ln5794">            {</a>
<a name="ln5795">                work.emplace_back(-rad, d);</a>
<a name="ln5796">                work.emplace_back(+rad, d);</a>
<a name="ln5797">            }</a>
<a name="ln5798"> </a>
<a name="ln5799">            work.emplace_back(d, -rad);</a>
<a name="ln5800">            work.emplace_back(d, +rad);</a>
<a name="ln5801">        }</a>
<a name="ln5802">        result.push_back(work);</a>
<a name="ln5803">    }</a>
<a name="ln5804">    return result;</a>
<a name="ln5805">}</a>
<a name="ln5806"> </a>
<a name="ln5807">/** How much noise does an explosion this big make?</a>
<a name="ln5808"> *</a>
<a name="ln5809"> *  @param the size of the explosion (radius, not diamater)</a>
<a name="ln5810"> *  @returns how much noise it would make.</a>
<a name="ln5811"> */</a>
<a name="ln5812">int explosion_noise(int rad)</a>
<a name="ln5813">{</a>
<a name="ln5814">    return 10 + rad * 5;</a>
<a name="ln5815">}</a>
<a name="ln5816"> </a>
<a name="ln5817">#define MAX_EXPLOSION_RADIUS 9</a>
<a name="ln5818">// Returns true if we saw something happening.</a>
<a name="ln5819">bool bolt::explode(bool show_more, bool hole_in_the_middle)</a>
<a name="ln5820">{</a>
<a name="ln5821">    ASSERT(!special_explosion);</a>
<a name="ln5822">    ASSERT(!in_explosion_phase);</a>
<a name="ln5823">    ASSERT(ex_size &gt;= 0);</a>
<a name="ln5824"> </a>
<a name="ln5825">    // explode() can be called manually without setting real_flavour.</a>
<a name="ln5826">    // FIXME: The entire flavour/real_flavour thing needs some</a>
<a name="ln5827">    // rewriting!</a>
<a name="ln5828">    if (real_flavour == BEAM_CHAOS</a>
<a name="ln5829">        || real_flavour == BEAM_RANDOM</a>
<a name="ln5830">        || real_flavour == BEAM_CRYSTAL)</a>
<a name="ln5831">    {</a>
<a name="ln5832">        flavour = real_flavour;</a>
<a name="ln5833">    }</a>
<a name="ln5834">    else</a>
<a name="ln5835">        real_flavour = flavour;</a>
<a name="ln5836"> </a>
<a name="ln5837">    const int r = min(ex_size, MAX_EXPLOSION_RADIUS);</a>
<a name="ln5838">    in_explosion_phase = true;</a>
<a name="ln5839">    // being hit by bounces doesn't exempt you from the explosion (not that it</a>
<a name="ln5840">    // currently ever matters)</a>
<a name="ln5841">    hit_count.clear();</a>
<a name="ln5842"> </a>
<a name="ln5843">    if (is_sanctuary(pos()) &amp;&amp; flavour != BEAM_VISUAL)</a>
<a name="ln5844">    {</a>
<a name="ln5845">        if (!is_tracer &amp;&amp; you.see_cell(pos()) &amp;&amp; !name.empty())</a>
<a name="ln5846">        {</a>
<a name="ln5847">            mprf(MSGCH_GOD, &quot;By Zin's power, the %s is contained.&quot;,</a>
<a name="ln5848">                 name.c_str());</a>
<a name="ln5849">            return true;</a>
<a name="ln5850">        }</a>
<a name="ln5851">        return false;</a>
<a name="ln5852">    }</a>
<a name="ln5853"> </a>
<a name="ln5854">#ifdef DEBUG_DIAGNOSTICS</a>
<a name="ln5855">    if (!quiet_debug)</a>
<a name="ln5856">    {</a>
<a name="ln5857">        dprf(DIAG_BEAM, &quot;explosion at (%d, %d) : g=%d c=%d f=%d hit=%d dam=%dd%d r=%d&quot;,</a>
<a name="ln5858">             pos().x, pos().y, glyph, colour, flavour, hit, damage.num, damage.size, r);</a>
<a name="ln5859">    }</a>
<a name="ln5860">#endif</a>
<a name="ln5861"> </a>
<a name="ln5862">    if (!is_tracer)</a>
<a name="ln5863">    {</a>
<a name="ln5864">        loudness = explosion_noise(r);</a>
<a name="ln5865"> </a>
<a name="ln5866">        // Not an &quot;explosion&quot;, but still a bit noisy at the target location.</a>
<a name="ln5867">        if (origin_spell == SPELL_INFESTATION</a>
<a name="ln5868">            || origin_spell == SPELL_DAZZLING_FLASH)</a>
<a name="ln5869">        {</a>
<a name="ln5870">            loudness = spell_effect_noise(origin_spell);</a>
<a name="ln5871">        }</a>
<a name="ln5872"> </a>
<a name="ln5873">        // Lee's Rapid Deconstruction can target the tiles on the map</a>
<a name="ln5874">        // boundary.</a>
<a name="ln5875">        const coord_def noise_position = clamp_in_bounds(pos());</a>
<a name="ln5876">        bool heard_expl = noisy(loudness, noise_position, source_id);</a>
<a name="ln5877"> </a>
<a name="ln5878">        heard = heard || heard_expl;</a>
<a name="ln5879"> </a>
<a name="ln5880">        if (heard_expl &amp;&amp; !explode_noise_msg.empty() &amp;&amp; !you.see_cell(pos()))</a>
<a name="ln5881">            mprf(MSGCH_SOUND, &quot;%s&quot;, explode_noise_msg.c_str());</a>
<a name="ln5882">    }</a>
<a name="ln5883"> </a>
<a name="ln5884">    // Run DFS to determine which cells are influenced</a>
<a name="ln5885">    explosion_map exp_map;</a>
<a name="ln5886">    exp_map.init(INT_MAX);</a>
<a name="ln5887">    determine_affected_cells(exp_map, coord_def(), 0, r, true, true);</a>
<a name="ln5888"> </a>
<a name="ln5889">    // We get a bit fancy, drawing all radius 0 effects, then radius</a>
<a name="ln5890">    // 1, radius 2, etc. It looks a bit better that way.</a>
<a name="ln5891">    const vector&lt; vector&lt;coord_def&gt; &gt; sweep = _radial_sweep(r);</a>
<a name="ln5892">    const coord_def centre(9,9);</a>
<a name="ln5893"> </a>
<a name="ln5894">    // Draw pass.</a>
<a name="ln5895">    if (!is_tracer)</a>
<a name="ln5896">    {</a>
<a name="ln5897">        for (const auto &amp;line : sweep)</a>
<a name="ln5898">        {</a>
<a name="ln5899">            bool pass_visible = false;</a>
<a name="ln5900">            for (const coord_def delta : line)</a>
<a name="ln5901">            {</a>
<a name="ln5902">                if (delta.origin() &amp;&amp; hole_in_the_middle)</a>
<a name="ln5903">                    continue;</a>
<a name="ln5904"> </a>
<a name="ln5905">                if (exp_map(delta + centre) &lt; INT_MAX)</a>
<a name="ln5906">                    pass_visible |= explosion_draw_cell(delta + pos());</a>
<a name="ln5907">            }</a>
<a name="ln5908">            if (pass_visible)</a>
<a name="ln5909">            {</a>
<a name="ln5910">                update_screen();</a>
<a name="ln5911">                scaled_delay(explode_delay);</a>
<a name="ln5912">            }</a>
<a name="ln5913">        }</a>
<a name="ln5914">    }</a>
<a name="ln5915"> </a>
<a name="ln5916">    // Affect pass.</a>
<a name="ln5917">    int cells_seen = 0;</a>
<a name="ln5918">    for (const auto &amp;line : sweep)</a>
<a name="ln5919">    {</a>
<a name="ln5920">        for (const coord_def delta : line)</a>
<a name="ln5921">        {</a>
<a name="ln5922">            if (delta.origin() &amp;&amp; hole_in_the_middle)</a>
<a name="ln5923">                continue;</a>
<a name="ln5924"> </a>
<a name="ln5925">            if (exp_map(delta + centre) &lt; INT_MAX)</a>
<a name="ln5926">            {</a>
<a name="ln5927">                if (you.see_cell(delta + pos()))</a>
<a name="ln5928">                    ++cells_seen;</a>
<a name="ln5929"> </a>
<a name="ln5930">                explosion_affect_cell(delta + pos());</a>
<a name="ln5931"> </a>
<a name="ln5932">                if (beam_cancelled) // don't spam prompts</a>
<a name="ln5933">                    return false;</a>
<a name="ln5934">            }</a>
<a name="ln5935">        }</a>
<a name="ln5936">    }</a>
<a name="ln5937"> </a>
<a name="ln5938">    // Delay after entire explosion has been drawn.</a>
<a name="ln5939">    if (!is_tracer &amp;&amp; cells_seen &gt; 0 &amp;&amp; show_more)</a>
<a name="ln5940">        scaled_delay(explode_delay * 3);</a>
<a name="ln5941"> </a>
<a name="ln5942">    return cells_seen &gt; 0;</a>
<a name="ln5943">}</a>
<a name="ln5944"> </a>
<a name="ln5945">/**</a>
<a name="ln5946"> * Draw one tile of an explosion, if that cell is visible.</a>
<a name="ln5947"> *</a>
<a name="ln5948"> * @param p The cell to draw, in grid coordinates.</a>
<a name="ln5949"> * @return True if the cell was actually drawn.</a>
<a name="ln5950"> */</a>
<a name="ln5951">bool bolt::explosion_draw_cell(const coord_def&amp; p)</a>
<a name="ln5952">{</a>
<a name="ln5953">    if (you.see_cell(p))</a>
<a name="ln5954">    {</a>
<a name="ln5955">        const coord_def drawpos = grid2view(p);</a>
<a name="ln5956">        // bounds check</a>
<a name="ln5957">        if (in_los_bounds_v(drawpos))</a>
<a name="ln5958">        {</a>
<a name="ln5959">#ifdef USE_TILE</a>
<a name="ln5960">            int dist = (p - source).rdist();</a>
<a name="ln5961">            tileidx_t tile = tileidx_bolt(*this);</a>
<a name="ln5962">            tiles.add_overlay(p, vary_bolt_tile(tile, dist));</a>
<a name="ln5963">#endif</a>
<a name="ln5964">#ifndef USE_TILE_LOCAL</a>
<a name="ln5965">            cgotoxy(drawpos.x, drawpos.y, GOTO_DNGN);</a>
<a name="ln5966">            put_colour_ch(colour == BLACK ? random_colour(true)</a>
<a name="ln5967">                                          : element_colour(colour, false, p),</a>
<a name="ln5968">                          dchar_glyph(DCHAR_EXPLOSION));</a>
<a name="ln5969">#endif</a>
<a name="ln5970">            return true;</a>
<a name="ln5971">        }</a>
<a name="ln5972">    }</a>
<a name="ln5973">    return false;</a>
<a name="ln5974">}</a>
<a name="ln5975"> </a>
<a name="ln5976">void bolt::explosion_affect_cell(const coord_def&amp; p)</a>
<a name="ln5977">{</a>
<a name="ln5978">    // pos() = target during an explosion, so restore it after affecting</a>
<a name="ln5979">    // the cell.</a>
<a name="ln5980">    const coord_def orig_pos = target;</a>
<a name="ln5981"> </a>
<a name="ln5982">    fake_flavour();</a>
<a name="ln5983">    target = p;</a>
<a name="ln5984">    affect_cell();</a>
<a name="ln5985">    flavour = real_flavour;</a>
<a name="ln5986"> </a>
<a name="ln5987">    target = orig_pos;</a>
<a name="ln5988">}</a>
<a name="ln5989"> </a>
<a name="ln5990">// Uses DFS</a>
<a name="ln5991">void bolt::determine_affected_cells(explosion_map&amp; m, const coord_def&amp; delta,</a>
<a name="ln5992">                                    int count, int r,</a>
<a name="ln5993">                                    bool stop_at_statues, bool stop_at_walls)</a>
<a name="ln5994">{</a>
<a name="ln5995">    const coord_def centre(9,9);</a>
<a name="ln5996">    const coord_def loc = pos() + delta;</a>
<a name="ln5997"> </a>
<a name="ln5998">    // A bunch of tests for edge cases.</a>
<a name="ln5999">    if (delta.rdist() &gt; centre.rdist()</a>
<a name="ln6000">        || delta.rdist() &gt; r</a>
<a name="ln6001">        || count &gt; 10*r</a>
<a name="ln6002">        || !map_bounds(loc)</a>
<a name="ln6003">        || is_sanctuary(loc) &amp;&amp; flavour != BEAM_VISUAL)</a>
<a name="ln6004">    {</a>
<a name="ln6005">        return;</a>
<a name="ln6006">    }</a>
<a name="ln6007"> </a>
<a name="ln6008">    const dungeon_feature_type dngn_feat = grd(loc);</a>
<a name="ln6009"> </a>
<a name="ln6010">    bool at_wall = false;</a>
<a name="ln6011"> </a>
<a name="ln6012">    // Check to see if we're blocked by a wall or a tree. Can't use</a>
<a name="ln6013">    // feat_is_solid here, since that includes statues which are a separate</a>
<a name="ln6014">    // check, nor feat_is_opaque, since that excludes transparent walls, which</a>
<a name="ln6015">    // we want. -ebering</a>
<a name="ln6016">    // XXX: We could just include trees as wall features, but this currently</a>
<a name="ln6017">    // would have some unintended side-effects. Would be ideal to deal with</a>
<a name="ln6018">    // those and simplify feat_is_wall() to return true for trees. -gammafunk</a>
<a name="ln6019">    if (feat_is_wall(dngn_feat)</a>
<a name="ln6020">        || feat_is_tree(dngn_feat)</a>
<a name="ln6021">           &amp;&amp; !can_burn_trees()</a>
<a name="ln6022">        || feat_is_closed_door(dngn_feat))</a>
<a name="ln6023">    {</a>
<a name="ln6024">        // Special case: explosion originates from rock/statue</a>
<a name="ln6025">        // (e.g. Lee's Rapid Deconstruction) - in this case, ignore</a>
<a name="ln6026">        // solid cells at the center of the explosion.</a>
<a name="ln6027">        if (stop_at_walls &amp;&amp; !(delta.origin() &amp;&amp; can_affect_wall(loc)))</a>
<a name="ln6028">            return;</a>
<a name="ln6029">        // But remember that we are at a wall.</a>
<a name="ln6030">        if (flavour != BEAM_DIGGING)</a>
<a name="ln6031">            at_wall = true;</a>
<a name="ln6032">    }</a>
<a name="ln6033"> </a>
<a name="ln6034">    if (feat_is_solid(dngn_feat) &amp;&amp; !feat_is_wall(dngn_feat)</a>
<a name="ln6035">        &amp;&amp; !can_affect_wall(loc) &amp;&amp; stop_at_statues)</a>
<a name="ln6036">    {</a>
<a name="ln6037">        return;</a>
<a name="ln6038">    }</a>
<a name="ln6039"> </a>
<a name="ln6040">    m(delta + centre) = min(count, m(delta + centre));</a>
<a name="ln6041"> </a>
<a name="ln6042">    // Now recurse in every direction.</a>
<a name="ln6043">    for (int i = 0; i &lt; 8; ++i)</a>
<a name="ln6044">    {</a>
<a name="ln6045">        const coord_def new_delta = delta + Compass[i];</a>
<a name="ln6046"> </a>
<a name="ln6047">        if (new_delta.rdist() &gt; centre.rdist())</a>
<a name="ln6048">            continue;</a>
<a name="ln6049"> </a>
<a name="ln6050">        // Is that cell already covered?</a>
<a name="ln6051">        if (m(new_delta + centre) &lt;= count)</a>
<a name="ln6052">            continue;</a>
<a name="ln6053"> </a>
<a name="ln6054">        // If we were at a wall, only move to visible squares.</a>
<a name="ln6055">        coord_def caster_pos = actor_by_mid(source_id) ?</a>
<a name="ln6056">                                   actor_by_mid(source_id)-&gt;pos() :</a>
<a name="ln6057">                                   you.pos();</a>
<a name="ln6058"> </a>
<a name="ln6059">        if (at_wall &amp;&amp; !cell_see_cell(caster_pos, loc + Compass[i], LOS_NO_TRANS))</a>
<a name="ln6060">            continue;</a>
<a name="ln6061"> </a>
<a name="ln6062">        int cadd = 5;</a>
<a name="ln6063">        // Circling around the center is always free.</a>
<a name="ln6064">        if (delta.rdist() == 1 &amp;&amp; new_delta.rdist() == 1)</a>
<a name="ln6065">            cadd = 0;</a>
<a name="ln6066">        // Otherwise changing direction (e.g. looking around a wall) costs more.</a>
<a name="ln6067">        else if (delta.x * Compass[i].x &lt; 0 || delta.y * Compass[i].y &lt; 0)</a>
<a name="ln6068">            cadd = 17;</a>
<a name="ln6069"> </a>
<a name="ln6070">        determine_affected_cells(m, new_delta, count + cadd, r,</a>
<a name="ln6071">                                 stop_at_statues, stop_at_walls);</a>
<a name="ln6072">    }</a>
<a name="ln6073">}</a>
<a name="ln6074"> </a>
<a name="ln6075">// Returns true if the beam is harmful ((mostly) ignoring monster</a>
<a name="ln6076">// resists) -- mon is given for 'special' cases where,</a>
<a name="ln6077">// for example, &quot;Heal&quot; might actually hurt undead, or</a>
<a name="ln6078">// &quot;Holy Word&quot; being ignored by holy monsters, etc.</a>
<a name="ln6079">//</a>
<a name="ln6080">// Only enchantments should need the actual monster type</a>
<a name="ln6081">// to determine this; non-enchantments are pretty</a>
<a name="ln6082">// straightforward.</a>
<a name="ln6083">bool bolt::nasty_to(const monster* mon) const</a>
<a name="ln6084">{</a>
<a name="ln6085">    // Cleansing flame.</a>
<a name="ln6086">    if (flavour == BEAM_HOLY)</a>
<a name="ln6087">        return mon-&gt;res_holy_energy() &lt; 3;</a>
<a name="ln6088"> </a>
<a name="ln6089">    // The orbs are made of pure disintegration energy. This also has the side</a>
<a name="ln6090">    // effect of not stopping us from firing further orbs when the previous one</a>
<a name="ln6091">    // is still flying.</a>
<a name="ln6092">    if (flavour == BEAM_DISINTEGRATION || flavour == BEAM_DEVASTATION)</a>
<a name="ln6093">        return mon-&gt;type != MONS_ORB_OF_DESTRUCTION;</a>
<a name="ln6094"> </a>
<a name="ln6095">    // Take care of other non-enchantments.</a>
<a name="ln6096">    if (!is_enchantment())</a>
<a name="ln6097">        return true;</a>
<a name="ln6098"> </a>
<a name="ln6099">    // Positive effects.</a>
<a name="ln6100">    if (nice_to(monster_info(mon)))</a>
<a name="ln6101">        return false;</a>
<a name="ln6102"> </a>
<a name="ln6103">    switch (flavour)</a>
<a name="ln6104">    {</a>
<a name="ln6105">        case BEAM_DIGGING:</a>
<a name="ln6106">            return false;</a>
<a name="ln6107">        case BEAM_INNER_FLAME:</a>
<a name="ln6108">            // Co-aligned inner flame is fine.</a>
<a name="ln6109">            return !mons_aligned(mon, agent());</a>
<a name="ln6110">        case BEAM_TELEPORT:</a>
<a name="ln6111">        case BEAM_BECKONING:</a>
<a name="ln6112">        case BEAM_INFESTATION:</a>
<a name="ln6113">        case BEAM_VILE_CLUTCH:</a>
<a name="ln6114">        case BEAM_SLOW:</a>
<a name="ln6115">        case BEAM_PARALYSIS:</a>
<a name="ln6116">        case BEAM_PETRIFY:</a>
<a name="ln6117">        case BEAM_POLYMORPH:</a>
<a name="ln6118">        case BEAM_DISPEL_UNDEAD:</a>
<a name="ln6119">        case BEAM_PAIN:</a>
<a name="ln6120">        case BEAM_AGONY:</a>
<a name="ln6121">        case BEAM_HIBERNATION:</a>
<a name="ln6122">            return ench_flavour_affects_monster(flavour, mon);</a>
<a name="ln6123">        case BEAM_TUKIMAS_DANCE:</a>
<a name="ln6124">            return tukima_affects(*mon); // XXX: move to ench_flavour_affects?</a>
<a name="ln6125">        case BEAM_UNRAVELLING:</a>
<a name="ln6126">            return monster_is_debuffable(*mon); // XXX: as tukima's</a>
<a name="ln6127">        default:</a>
<a name="ln6128">            break;</a>
<a name="ln6129">    }</a>
<a name="ln6130"> </a>
<a name="ln6131">    // everything else is considered nasty by everyone</a>
<a name="ln6132">    return true;</a>
<a name="ln6133">}</a>
<a name="ln6134"> </a>
<a name="ln6135">// Return true if the bolt is considered nice by mon.</a>
<a name="ln6136">// This is not the inverse of nasty_to(): the bolt needs to be</a>
<a name="ln6137">// actively positive.</a>
<a name="ln6138">bool bolt::nice_to(const monster_info&amp; mi) const</a>
<a name="ln6139">{</a>
<a name="ln6140">    // Polymorphing a (very) ugly thing will mutate it into a different</a>
<a name="ln6141">    // (very) ugly thing.</a>
<a name="ln6142">    if (flavour == BEAM_POLYMORPH)</a>
<a name="ln6143">    {</a>
<a name="ln6144">        return mi.type == MONS_UGLY_THING</a>
<a name="ln6145">               || mi.type == MONS_VERY_UGLY_THING;</a>
<a name="ln6146">    }</a>
<a name="ln6147"> </a>
<a name="ln6148">    if (flavour == BEAM_HASTE</a>
<a name="ln6149">        || flavour == BEAM_HEALING</a>
<a name="ln6150">        || flavour == BEAM_MIGHT</a>
<a name="ln6151">        || flavour == BEAM_AGILITY</a>
<a name="ln6152">        || flavour == BEAM_INVISIBILITY</a>
<a name="ln6153">        || flavour == BEAM_RESISTANCE)</a>
<a name="ln6154">    {</a>
<a name="ln6155">        return true;</a>
<a name="ln6156">    }</a>
<a name="ln6157"> </a>
<a name="ln6158">    return false;</a>
<a name="ln6159">}</a>
<a name="ln6160"> </a>
<a name="ln6161">////////////////////////////////////////////////////////////////////////////</a>
<a name="ln6162">// bolt</a>
<a name="ln6163">// TODO: Eventually it'd be nice to have a proper factory for these things</a>
<a name="ln6164">// (extended from setup_mons_cast() and zapping() which act as limited ones).</a>
<a name="ln6165"> </a>
<a name="ln6166">killer_type bolt::killer() const</a>
<a name="ln6167">{</a>
<a name="ln6168">    if (flavour == BEAM_BANISH)</a>
<a name="ln6169">        return KILL_BANISHED;</a>
<a name="ln6170"> </a>
<a name="ln6171">    switch (thrower)</a>
<a name="ln6172">    {</a>
<a name="ln6173">    case KILL_YOU:</a>
<a name="ln6174">    case KILL_YOU_MISSILE:</a>
<a name="ln6175">        return (flavour == BEAM_PARALYSIS</a>
<a name="ln6176">                || flavour == BEAM_PETRIFY) ? KILL_YOU : KILL_YOU_MISSILE;</a>
<a name="ln6177"> </a>
<a name="ln6178">    case KILL_MON:</a>
<a name="ln6179">    case KILL_MON_MISSILE:</a>
<a name="ln6180">        return KILL_MON_MISSILE;</a>
<a name="ln6181"> </a>
<a name="ln6182">    case KILL_YOU_CONF:</a>
<a name="ln6183">        return KILL_YOU_CONF;</a>
<a name="ln6184"> </a>
<a name="ln6185">    default:</a>
<a name="ln6186">        return KILL_MON_MISSILE;</a>
<a name="ln6187">    }</a>
<a name="ln6188">}</a>
<a name="ln6189"> </a>
<a name="ln6190">void bolt::set_target(const dist &amp;d)</a>
<a name="ln6191">{</a>
<a name="ln6192">    if (!d.isValid)</a>
<a name="ln6193">        return;</a>
<a name="ln6194"> </a>
<a name="ln6195">    target = d.target;</a>
<a name="ln6196"> </a>
<a name="ln6197">    chose_ray = d.choseRay;</a>
<a name="ln6198">    if (d.choseRay)</a>
<a name="ln6199">        ray = d.ray;</a>
<a name="ln6200"> </a>
<a name="ln6201">    if (d.isEndpoint)</a>
<a name="ln6202">        aimed_at_spot = true;</a>
<a name="ln6203">}</a>
<a name="ln6204"> </a>
<a name="ln6205">void bolt::setup_retrace()</a>
<a name="ln6206">{</a>
<a name="ln6207">    if (pos().x &amp;&amp; pos().y)</a>
<a name="ln6208">        target = pos();</a>
<a name="ln6209"> </a>
<a name="ln6210">    swap(source, target);</a>
<a name="ln6211">    chose_ray        = false;</a>
<a name="ln6212">    affects_nothing  = true;</a>
<a name="ln6213">    aimed_at_spot    = true;</a>
<a name="ln6214">    extra_range_used = 0;</a>
<a name="ln6215">}</a>
<a name="ln6216"> </a>
<a name="ln6217">void bolt::set_agent(const actor *actor)</a>
<a name="ln6218">{</a>
<a name="ln6219">    // nullptr actor is fine by us.</a>
<a name="ln6220">    if (!actor)</a>
<a name="ln6221">        return;</a>
<a name="ln6222"> </a>
<a name="ln6223">    source_id = actor-&gt;mid;</a>
<a name="ln6224"> </a>
<a name="ln6225">    if (actor-&gt;is_player())</a>
<a name="ln6226">        thrower = KILL_YOU_MISSILE;</a>
<a name="ln6227">    else</a>
<a name="ln6228">        thrower = KILL_MON_MISSILE;</a>
<a name="ln6229">}</a>
<a name="ln6230"> </a>
<a name="ln6231">/**</a>
<a name="ln6232"> * Who caused this beam?</a>
<a name="ln6233"> *</a>
<a name="ln6234"> * @param ignore_reflection If true, look all the way back to the original</a>
<a name="ln6235"> *                          source; if false (the default), treat the latest</a>
<a name="ln6236"> *                          actor to reflect this as the source.</a>
<a name="ln6237"> * @returns The actor that can be treated as the source. May be null if</a>
<a name="ln6238"> *          it's a now-dead monster, or if neither the player nor a monster</a>
<a name="ln6239"> *          caused it (for example, divine retribution).</a>
<a name="ln6240"> */</a>
<a name="ln6241">actor* bolt::agent(bool ignore_reflection) const</a>
<a name="ln6242">{</a>
<a name="ln6243">    killer_type nominal_ktype = thrower;</a>
<a name="ln6244">    mid_t nominal_source = source_id;</a>
<a name="ln6245"> </a>
<a name="ln6246">    // If the beam was reflected report a different point of origin</a>
<a name="ln6247">    if (reflections &gt; 0 &amp;&amp; !ignore_reflection)</a>
<a name="ln6248">    {</a>
<a name="ln6249">        if (reflector == MID_PLAYER || source_id == MID_PLAYER)</a>
<a name="ln6250">            return &amp;menv[YOU_FAULTLESS];</a>
<a name="ln6251">        nominal_source = reflector;</a>
<a name="ln6252">    }</a>
<a name="ln6253"> </a>
<a name="ln6254">    // Check for whether this is actually a dith shadow, not you</a>
<a name="ln6255">    if (monster* shadow = monster_at(you.pos()))</a>
<a name="ln6256">        if (shadow-&gt;type == MONS_PLAYER_SHADOW &amp;&amp; nominal_source == MID_PLAYER)</a>
<a name="ln6257">            return shadow;</a>
<a name="ln6258"> </a>
<a name="ln6259">    if (YOU_KILL(nominal_ktype))</a>
<a name="ln6260">        return &amp;you;</a>
<a name="ln6261">    else</a>
<a name="ln6262">        return actor_by_mid(nominal_source);</a>
<a name="ln6263">}</a>
<a name="ln6264"> </a>
<a name="ln6265">bool bolt::is_enchantment() const</a>
<a name="ln6266">{</a>
<a name="ln6267">    return flavour &gt;= BEAM_FIRST_ENCHANTMENT</a>
<a name="ln6268">           &amp;&amp; flavour &lt;= BEAM_LAST_ENCHANTMENT;</a>
<a name="ln6269">}</a>
<a name="ln6270"> </a>
<a name="ln6271">string bolt::get_short_name() const</a>
<a name="ln6272">{</a>
<a name="ln6273">    if (!short_name.empty())</a>
<a name="ln6274">        return short_name;</a>
<a name="ln6275"> </a>
<a name="ln6276">    if (item != nullptr &amp;&amp; item-&gt;defined())</a>
<a name="ln6277">    {</a>
<a name="ln6278">        return item-&gt;name(DESC_A, false, false, false, false,</a>
<a name="ln6279">                          ISFLAG_IDENT_MASK | ISFLAG_COSMETIC_MASK);</a>
<a name="ln6280">    }</a>
<a name="ln6281"> </a>
<a name="ln6282">    if (real_flavour == BEAM_RANDOM</a>
<a name="ln6283">        || real_flavour == BEAM_CHAOS</a>
<a name="ln6284">        || real_flavour == BEAM_CRYSTAL)</a>
<a name="ln6285">    {</a>
<a name="ln6286">        return _beam_type_name(real_flavour);</a>
<a name="ln6287">    }</a>
<a name="ln6288"> </a>
<a name="ln6289">    if (flavour == BEAM_FIRE</a>
<a name="ln6290">        &amp;&amp; (origin_spell == SPELL_STICKY_FLAME</a>
<a name="ln6291">            || origin_spell == SPELL_STICKY_FLAME_RANGE))</a>
<a name="ln6292">    {</a>
<a name="ln6293">        return &quot;sticky fire&quot;;</a>
<a name="ln6294">    }</a>
<a name="ln6295"> </a>
<a name="ln6296">    if (flavour == BEAM_ELECTRICITY &amp;&amp; pierce)</a>
<a name="ln6297">        return &quot;lightning&quot;;</a>
<a name="ln6298"> </a>
<a name="ln6299">    if (name == &quot;bolt of dispelling energy&quot;)</a>
<a name="ln6300">        return &quot;dispelling energy&quot;;</a>
<a name="ln6301"> </a>
<a name="ln6302">    if (flavour == BEAM_NONE || flavour == BEAM_MISSILE</a>
<a name="ln6303">        || flavour == BEAM_MMISSILE)</a>
<a name="ln6304">    {</a>
<a name="ln6305">        return name;</a>
<a name="ln6306">    }</a>
<a name="ln6307"> </a>
<a name="ln6308">    return _beam_type_name(flavour);</a>
<a name="ln6309">}</a>
<a name="ln6310"> </a>
<a name="ln6311">static string _beam_type_name(beam_type type)</a>
<a name="ln6312">{</a>
<a name="ln6313">    switch (type)</a>
<a name="ln6314">    {</a>
<a name="ln6315">    case BEAM_NONE:                  return &quot;none&quot;;</a>
<a name="ln6316">    case BEAM_MISSILE:               return &quot;missile&quot;;</a>
<a name="ln6317">    case BEAM_MMISSILE:              return &quot;magic missile&quot;;</a>
<a name="ln6318">    case BEAM_FIRE:                  return &quot;fire&quot;;</a>
<a name="ln6319">    case BEAM_COLD:                  return &quot;cold&quot;;</a>
<a name="ln6320">    case BEAM_WATER:                 return &quot;water&quot;;</a>
<a name="ln6321">    case BEAM_MAGIC:                 return &quot;magic&quot;;</a>
<a name="ln6322">    case BEAM_ELECTRICITY:           return &quot;electricity&quot;;</a>
<a name="ln6323">    case BEAM_MEPHITIC:              return &quot;noxious fumes&quot;;</a>
<a name="ln6324">    case BEAM_POISON:                return &quot;poison&quot;;</a>
<a name="ln6325">    case BEAM_NEG:                   return &quot;negative energy&quot;;</a>
<a name="ln6326">    case BEAM_ACID:                  return &quot;acid&quot;;</a>
<a name="ln6327">    case BEAM_MIASMA:                return &quot;miasma&quot;;</a>
<a name="ln6328">    case BEAM_SPORE:                 return &quot;spores&quot;;</a>
<a name="ln6329">    case BEAM_POISON_ARROW:          return &quot;poison sting&quot;;</a>
<a name="ln6330">    case BEAM_DAMNATION:             return &quot;damnation&quot;;</a>
<a name="ln6331">    case BEAM_STICKY_FLAME:          return &quot;sticky fire&quot;;</a>
<a name="ln6332">    case BEAM_STEAM:                 return &quot;steam&quot;;</a>
<a name="ln6333">    case BEAM_ENERGY:                return &quot;energy&quot;;</a>
<a name="ln6334">    case BEAM_HOLY:                  return &quot;cleansing flame&quot;;</a>
<a name="ln6335">    case BEAM_FRAG:                  return &quot;fragments&quot;;</a>
<a name="ln6336">    case BEAM_LAVA:                  return &quot;magma&quot;;</a>
<a name="ln6337">    case BEAM_ICE:                   return &quot;ice&quot;;</a>
<a name="ln6338">    case BEAM_DEVASTATION:           return &quot;devastation&quot;;</a>
<a name="ln6339">    case BEAM_RANDOM:                return &quot;random&quot;;</a>
<a name="ln6340">    case BEAM_CHAOS:                 return &quot;chaos&quot;;</a>
<a name="ln6341">    case BEAM_SLOW:                  return &quot;slow&quot;;</a>
<a name="ln6342">    case BEAM_HASTE:                 return &quot;haste&quot;;</a>
<a name="ln6343">    case BEAM_MIGHT:                 return &quot;might&quot;;</a>
<a name="ln6344">    case BEAM_HEALING:               return &quot;healing&quot;;</a>
<a name="ln6345">    case BEAM_PARALYSIS:             return &quot;paralysis&quot;;</a>
<a name="ln6346">    case BEAM_CONFUSION:             return &quot;confusion&quot;;</a>
<a name="ln6347">    case BEAM_INVISIBILITY:          return &quot;invisibility&quot;;</a>
<a name="ln6348">    case BEAM_DIGGING:               return &quot;digging&quot;;</a>
<a name="ln6349">    case BEAM_TELEPORT:              return &quot;teleportation&quot;;</a>
<a name="ln6350">    case BEAM_POLYMORPH:             return &quot;polymorph&quot;;</a>
<a name="ln6351">    case BEAM_MALMUTATE:             return &quot;malmutation&quot;;</a>
<a name="ln6352">    case BEAM_ENSLAVE:               return &quot;enslave&quot;;</a>
<a name="ln6353">    case BEAM_BANISH:                return &quot;banishment&quot;;</a>
<a name="ln6354">    case BEAM_PAIN:                  return &quot;pain&quot;;</a>
<a name="ln6355">    case BEAM_AGONY:                 return &quot;agony&quot;;</a>
<a name="ln6356">    case BEAM_DISPEL_UNDEAD:         return &quot;dispel undead&quot;;</a>
<a name="ln6357">    case BEAM_DISINTEGRATION:        return &quot;disintegration&quot;;</a>
<a name="ln6358">    case BEAM_BLINK:                 return &quot;blink&quot;;</a>
<a name="ln6359">    case BEAM_BLINK_CLOSE:           return &quot;blink close&quot;;</a>
<a name="ln6360">    case BEAM_BECKONING:             return &quot;beckoning&quot;;</a>
<a name="ln6361">    case BEAM_PETRIFY:               return &quot;petrify&quot;;</a>
<a name="ln6362">    case BEAM_CORONA:                return &quot;backlight&quot;;</a>
<a name="ln6363">    case BEAM_PORKALATOR:            return &quot;porkalator&quot;;</a>
<a name="ln6364">    case BEAM_HIBERNATION:           return &quot;hibernation&quot;;</a>
<a name="ln6365">    case BEAM_SLEEP:                 return &quot;sleep&quot;;</a>
<a name="ln6366">    case BEAM_BERSERK:               return &quot;berserk&quot;;</a>
<a name="ln6367">    case BEAM_VISUAL:                return &quot;visual effects&quot;;</a>
<a name="ln6368">    case BEAM_TORMENT_DAMAGE:        return &quot;torment damage&quot;;</a>
<a name="ln6369">    case BEAM_AIR:                   return &quot;air&quot;;</a>
<a name="ln6370">    case BEAM_INNER_FLAME:           return &quot;inner flame&quot;;</a>
<a name="ln6371">    case BEAM_PETRIFYING_CLOUD:      return &quot;calcifying dust&quot;;</a>
<a name="ln6372">    case BEAM_ENSNARE:               return &quot;magic web&quot;;</a>
<a name="ln6373">    case BEAM_SENTINEL_MARK:         return &quot;sentinel's mark&quot;;</a>
<a name="ln6374">    case BEAM_DIMENSION_ANCHOR:      return &quot;dimension anchor&quot;;</a>
<a name="ln6375">    case BEAM_VULNERABILITY:         return &quot;vulnerability&quot;;</a>
<a name="ln6376">    case BEAM_MALIGN_OFFERING:       return &quot;malign offering&quot;;</a>
<a name="ln6377">    case BEAM_VIRULENCE:             return &quot;virulence&quot;;</a>
<a name="ln6378">    case BEAM_AGILITY:               return &quot;agility&quot;;</a>
<a name="ln6379">    case BEAM_SAP_MAGIC:             return &quot;sap magic&quot;;</a>
<a name="ln6380">    case BEAM_CRYSTAL:               return &quot;crystal bolt&quot;;</a>
<a name="ln6381">    case BEAM_DRAIN_MAGIC:           return &quot;drain magic&quot;;</a>
<a name="ln6382">    case BEAM_TUKIMAS_DANCE:         return &quot;tukima's dance&quot;;</a>
<a name="ln6383">    case BEAM_BOUNCY_TRACER:         return &quot;bouncy tracer&quot;;</a>
<a name="ln6384">    case BEAM_DEATH_RATTLE:          return &quot;breath of the dead&quot;;</a>
<a name="ln6385">    case BEAM_RESISTANCE:            return &quot;resistance&quot;;</a>
<a name="ln6386">    case BEAM_UNRAVELLING:           return &quot;unravelling&quot;;</a>
<a name="ln6387">    case BEAM_UNRAVELLED_MAGIC:      return &quot;unravelled magic&quot;;</a>
<a name="ln6388">    case BEAM_SHARED_PAIN:           return &quot;shared pain&quot;;</a>
<a name="ln6389">    case BEAM_IRRESISTIBLE_CONFUSION:return &quot;confusion&quot;;</a>
<a name="ln6390">    case BEAM_INFESTATION:           return &quot;infestation&quot;;</a>
<a name="ln6391">    case BEAM_VILE_CLUTCH:           return &quot;vile clutch&quot;;</a>
<a name="ln6392"> </a>
<a name="ln6393">    case NUM_BEAMS:                  die(&quot;invalid beam type&quot;);</a>
<a name="ln6394">    }</a>
<a name="ln6395">    die(&quot;unknown beam type&quot;);</a>
<a name="ln6396">}</a>
<a name="ln6397"> </a>
<a name="ln6398">string bolt::get_source_name() const</a>
<a name="ln6399">{</a>
<a name="ln6400">    if (!source_name.empty())</a>
<a name="ln6401">        return source_name;</a>
<a name="ln6402">    const actor *a = agent();</a>
<a name="ln6403">    if (a)</a>
<a name="ln6404">        return a-&gt;name(DESC_A, true);</a>
<a name="ln6405">    return &quot;&quot;;</a>
<a name="ln6406">}</a>
<a name="ln6407"> </a>
<a name="ln6408">/**</a>
<a name="ln6409"> * Can this bolt knock back an actor?</a>
<a name="ln6410"> *</a>
<a name="ln6411"> * The bolts that knockback flying actors or actors only when damage is dealt</a>
<a name="ln6412"> * will return true when conditions are met.</a>
<a name="ln6413"> *</a>
<a name="ln6414"> * @param act The target actor. Check if the actor is flying for bolts that</a>
<a name="ln6415"> *            knockback flying actors.</a>
<a name="ln6416"> * @param dam The damage dealt. If non-negative, check that dam &gt; 0 for bolts</a>
<a name="ln6417"> *             like force bolt that only push back upon damage.</a>
<a name="ln6418"> * @return True if the bolt could knockback the actor, false otherwise.</a>
<a name="ln6419">*/</a>
<a name="ln6420">bool bolt::can_knockback(const actor &amp;act, int dam) const</a>
<a name="ln6421">{</a>
<a name="ln6422">    if (act.is_stationary())</a>
<a name="ln6423">        return false;</a>
<a name="ln6424"> </a>
<a name="ln6425">    return flavour == BEAM_WATER &amp;&amp; origin_spell == SPELL_PRIMAL_WAVE</a>
<a name="ln6426">           || origin_spell == SPELL_CHILLING_BREATH &amp;&amp; act.airborne()</a>
<a name="ln6427">           || origin_spell == SPELL_FORCE_LANCE &amp;&amp; dam</a>
<a name="ln6428">           || origin_spell == SPELL_ISKENDERUNS_MYSTIC_BLAST &amp;&amp; dam;</a>
<a name="ln6429">}</a>
<a name="ln6430"> </a>
<a name="ln6431">/**</a>
<a name="ln6432"> * Can this bolt pull an actor?</a>
<a name="ln6433"> *</a>
<a name="ln6434"> * If a bolt is capable of pulling actors and the given actor can be pulled,</a>
<a name="ln6435"> * return true.</a>
<a name="ln6436"> *</a>
<a name="ln6437"> * @param act The target actor. Check if the actor is non-stationary and not</a>
<a name="ln6438"> *            already adjacent.</a>
<a name="ln6439"> * @param dam The damage dealt. Check that dam &gt; 0.</a>
<a name="ln6440"> * @return True if the bolt could pull the actor, false otherwise.</a>
<a name="ln6441">*/</a>
<a name="ln6442">bool bolt::can_pull(const actor &amp;act, int dam) const</a>
<a name="ln6443">{</a>
<a name="ln6444">    if (act.is_stationary() || adjacent(source, act.pos()))</a>
<a name="ln6445">        return false;</a>
<a name="ln6446"> </a>
<a name="ln6447">    return origin_spell == SPELL_HARPOON_SHOT &amp;&amp; dam;</a>
<a name="ln6448">}</a>
<a name="ln6449"> </a>
<a name="ln6450">void clear_zap_info_on_exit()</a>
<a name="ln6451">{</a>
<a name="ln6452">    for (const zap_info &amp;zap : zap_data)</a>
<a name="ln6453">    {</a>
<a name="ln6454">        delete zap.player_damage;</a>
<a name="ln6455">        delete zap.player_tohit;</a>
<a name="ln6456">        delete zap.monster_damage;</a>
<a name="ln6457">        delete zap.monster_tohit;</a>
<a name="ln6458">    }</a>
<a name="ln6459">}</a>
<a name="ln6460"> </a>
<a name="ln6461">int ench_power_stepdown(int pow)</a>
<a name="ln6462">{</a>
<a name="ln6463">    return stepdown_value(pow, 30, 40, 100, 120);</a>
<a name="ln6464">}</a>
<a name="ln6465"> </a>
<a name="ln6466">/// Translate a given ench power to a duration, in aut.</a>
<a name="ln6467">int _ench_pow_to_dur(int pow)</a>
<a name="ln6468">{</a>
<a name="ln6469">    // ~15 turns at 25 pow, ~21 turns at 50 pow, ~27 turns at 100 pow</a>
<a name="ln6470">    return stepdown(pow * BASELINE_DELAY, 70);</a>
<a name="ln6471">}</a>
<a name="ln6472"> </a>
<a name="ln6473">// Can a particular beam go through a particular monster?</a>
<a name="ln6474">// Fedhas worshipers can shoot through non-hostile plants,</a>
<a name="ln6475">// and players can shoot through their demonic guardians.</a>
<a name="ln6476">bool shoot_through_monster(const bolt&amp; beam, const monster* victim)</a>
<a name="ln6477">{</a>
<a name="ln6478">    actor *originator = beam.agent();</a>
<a name="ln6479">    if (!victim || !originator)</a>
<a name="ln6480">        return false;</a>
<a name="ln6481"> </a>
<a name="ln6482">    bool origin_worships_fedhas;</a>
<a name="ln6483">    mon_attitude_type origin_attitude;</a>
<a name="ln6484">    if (originator-&gt;is_player())</a>
<a name="ln6485">    {</a>
<a name="ln6486">        origin_worships_fedhas = have_passive(passive_t::shoot_through_plants);</a>
<a name="ln6487">        origin_attitude = ATT_FRIENDLY;</a>
<a name="ln6488">    }</a>
<a name="ln6489">    else</a>
<a name="ln6490">    {</a>
<a name="ln6491">        monster* temp = originator-&gt;as_monster();</a>
<a name="ln6492">        if (!temp)</a>
<a name="ln6493">            return false;</a>
<a name="ln6494">        origin_worships_fedhas = (temp-&gt;god == GOD_FEDHAS</a>
<a name="ln6495">            || (temp-&gt;friendly()</a>
<a name="ln6496">                &amp;&amp; have_passive(passive_t::shoot_through_plants)));</a>
<a name="ln6497">        origin_attitude = temp-&gt;attitude;</a>
<a name="ln6498">    }</a>
<a name="ln6499"> </a>
<a name="ln6500">    return (origin_worships_fedhas</a>
<a name="ln6501">            &amp;&amp; fedhas_protects(victim))</a>
<a name="ln6502">           || (originator-&gt;is_player()</a>
<a name="ln6503">               &amp;&amp; testbits(victim-&gt;flags, MF_DEMONIC_GUARDIAN))</a>
<a name="ln6504">           &amp;&amp; !beam.is_enchantment()</a>
<a name="ln6505">           &amp;&amp; beam.origin_spell != SPELL_CHAIN_LIGHTNING</a>
<a name="ln6506">           &amp;&amp; (mons_atts_aligned(victim-&gt;attitude, origin_attitude)</a>
<a name="ln6507">               || victim-&gt;neutral());</a>
<a name="ln6508">}</a>
<a name="ln6509"> </a>
<a name="ln6510">/**</a>
<a name="ln6511"> * Given some shield value, what is the chance that omnireflect will activate</a>
<a name="ln6512"> * on an AUTOMATIC_HIT attack?</a>
<a name="ln6513"> *</a>
<a name="ln6514"> * E.g., if 40 is returned, there is a SH in 40 chance of a given attack being</a>
<a name="ln6515"> * reflected.</a>
<a name="ln6516"> *</a>
<a name="ln6517"> * @param SH        The SH (shield) value of the omnireflect user.</a>
<a name="ln6518"> * @return          A denominator to the chance of omnireflect activating.</a>
<a name="ln6519"> */</a>
<a name="ln6520">int omnireflect_chance_denom(int SH)</a>
<a name="ln6521">{</a>
<a name="ln6522">    return SH + 20;</a>
<a name="ln6523">}</a>
<a name="ln6524"> </a>
<a name="ln6525">/// Set up a beam aiming from the given monster to their target.</a>
<a name="ln6526">bolt setup_targetting_beam(const monster &amp;mons)</a>
<a name="ln6527">{</a>
<a name="ln6528">    bolt beem;</a>
<a name="ln6529"> </a>
<a name="ln6530">    beem.source    = mons.pos();</a>
<a name="ln6531">    beem.target    = mons.target;</a>
<a name="ln6532">    beem.source_id = mons.mid;</a>
<a name="ln6533"> </a>
<a name="ln6534">    return beem;</a>
<a name="ln6535">}</a>

</code></pre>
<div class="balloon" rel="981"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v648/" target="_blank">V648</a> Priority of the '&&' operation is higher than that of the '||' operation.</p></div>
<div class="balloon" rel="1240"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v648/" target="_blank">V648</a> Priority of the '&&' operation is higher than that of the '||' operation.</p></div>
<div class="balloon" rel="1950"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v648/" target="_blank">V648</a> Priority of the '&&' operation is higher than that of the '||' operation.</p></div>
<div class="balloon" rel="1992"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v648/" target="_blank">V648</a> Priority of the '&&' operation is higher than that of the '||' operation.</p></div>
<div class="balloon" rel="2346"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v560/" target="_blank">V560</a> A part of conditional expression is always true: !is_explosion.</p></div>
<div class="balloon" rel="2840"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v648/" target="_blank">V648</a> Priority of the '&&' operation is higher than that of the '||' operation.</p></div>
<div class="balloon" rel="2847"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v648/" target="_blank">V648</a> Priority of the '&&' operation is higher than that of the '||' operation.</p></div>
<div class="balloon" rel="3870"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v648/" target="_blank">V648</a> Priority of the '&&' operation is higher than that of the '||' operation.</p></div>
<div class="balloon" rel="4044"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v648/" target="_blank">V648</a> Priority of the '&&' operation is higher than that of the '||' operation.</p></div>
<div class="balloon" rel="4341"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v648/" target="_blank">V648</a> Priority of the '&&' operation is higher than that of the '||' operation.</p></div>
<div class="balloon" rel="6003"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v648/" target="_blank">V648</a> Priority of the '&&' operation is higher than that of the '||' operation.</p></div>
<div class="balloon" rel="6020"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v648/" target="_blank">V648</a> Priority of the '&&' operation is higher than that of the '||' operation.</p></div>

<link rel="stylesheet" href="highlight.css">
<script src="highlight.pack.js"></script>
<script src="highlightjs-line-numbers.js"></script>
<script>hljs.initHighlightingOnLoad();</script>
<script>hljs.initLineNumbersOnLoad();</script>
<script>
  $(document).ready(function() {
      $('.balloon').each(function () {
          var bl = $(this);
          var line = bl.attr('rel');
          var text = $('a[name="ln'+line+'"]').text();

          var space_count = 0;
          for(var i = 0; i<text.length; i++){
              var char = text[i];
              if((char !== ' ')&&(char !== '\t'))break;
              if(char === '\t')space_count++;
              space_count++;
          }

          bl.css('margin-left', space_count*8);
          $('a[name="ln'+line+'"]').after(bl);
      });

      window.location = window.location;
  });
</script>
</body>
</html>
