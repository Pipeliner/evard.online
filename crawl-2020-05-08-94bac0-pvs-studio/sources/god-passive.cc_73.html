
<html>
<head>

  <meta http-equiv="Content-Type" content="text/html; charset=US-ASCII" />
  <title>god-passive.cc</title>

  <link rel="stylesheet" href="../style.css"/>
  <script src="../jquery-3.2.1.min.js"></script>
</head>
<body>

<pre><code class = "cpp">
<a name="ln1">#include &quot;AppHdr.h&quot;</a>
<a name="ln2"> </a>
<a name="ln3">#include &quot;god-passive.h&quot;</a>
<a name="ln4"> </a>
<a name="ln5">#include &lt;algorithm&gt;</a>
<a name="ln6">#include &lt;cmath&gt;</a>
<a name="ln7"> </a>
<a name="ln8">#include &quot;act-iter.h&quot;</a>
<a name="ln9">#include &quot;areas.h&quot;</a>
<a name="ln10">#include &quot;artefact.h&quot;</a>
<a name="ln11">#include &quot;art-enum.h&quot;</a>
<a name="ln12">#include &quot;branch.h&quot;</a>
<a name="ln13">#include &quot;chardump.h&quot;</a>
<a name="ln14">#include &quot;cloud.h&quot;</a>
<a name="ln15">#include &quot;coordit.h&quot;</a>
<a name="ln16">#include &quot;directn.h&quot;</a>
<a name="ln17">#include &quot;env.h&quot;</a>
<a name="ln18">#include &quot;eq-type-flags.h&quot;</a>
<a name="ln19">#include &quot;fight.h&quot;</a>
<a name="ln20">#include &quot;files.h&quot;</a>
<a name="ln21">#include &quot;fprop.h&quot;</a>
<a name="ln22">#include &quot;god-abil.h&quot;</a>
<a name="ln23">#include &quot;god-prayer.h&quot;</a>
<a name="ln24">#include &quot;invent.h&quot; // in_inventory</a>
<a name="ln25">#include &quot;item-name.h&quot;</a>
<a name="ln26">#include &quot;item-prop.h&quot;</a>
<a name="ln27">#include &quot;item-status-flag-type.h&quot;</a>
<a name="ln28">#include &quot;items.h&quot;</a>
<a name="ln29">#include &quot;libutil.h&quot;</a>
<a name="ln30">#include &quot;map-knowledge.h&quot;</a>
<a name="ln31">#include &quot;melee-attack.h&quot;</a>
<a name="ln32">#include &quot;message.h&quot;</a>
<a name="ln33">#include &quot;mon-cast.h&quot;</a>
<a name="ln34">#include &quot;mon-place.h&quot;</a>
<a name="ln35">#include &quot;mon-util.h&quot;</a>
<a name="ln36">#include &quot;output.h&quot;</a>
<a name="ln37">#include &quot;religion.h&quot;</a>
<a name="ln38">#include &quot;shout.h&quot;</a>
<a name="ln39">#include &quot;skills.h&quot;</a>
<a name="ln40">#include &quot;spl-clouds.h&quot;</a>
<a name="ln41">#include &quot;state.h&quot;</a>
<a name="ln42">#include &quot;stringutil.h&quot;</a>
<a name="ln43">#include &quot;terrain.h&quot;</a>
<a name="ln44">#include &quot;throw.h&quot;</a>
<a name="ln45">#include &quot;unwind.h&quot;</a>
<a name="ln46"> </a>
<a name="ln47">// TODO: template out the differences between this and god_power.</a>
<a name="ln48">// TODO: use the display method rather than dummy powers in god_powers.</a>
<a name="ln49">// TODO: finish using these for implementing passive abilities.</a>
<a name="ln50">struct god_passive</a>
<a name="ln51">{</a>
<a name="ln52">    // 1-6 means it unlocks at that many stars of piety;</a>
<a name="ln53">    // 0 means it is always present when in good standing with the god;</a>
<a name="ln54">    // -1 means it is present even under penance;</a>
<a name="ln55">    int rank;</a>
<a name="ln56">    passive_t pasv;</a>
<a name="ln57">    /** Message to be given on gain of this passive.</a>
<a name="ln58">     *</a>
<a name="ln59">     * If the string begins with an uppercase letter, it is treated as</a>
<a name="ln60">     * a complete sentence. Otherwise, if it contains the substring &quot; NOW &quot;,</a>
<a name="ln61">     * the string &quot;You &quot; is prepended. Otherwise, the string &quot;You NOW &quot; is</a>
<a name="ln62">     * prepended to the message, with the &quot; NOW &quot; then being replaced.</a>
<a name="ln63">     *</a>
<a name="ln64">     * The substring &quot;GOD&quot; is replaced with the name of the god.</a>
<a name="ln65">     * The substring &quot; NOW &quot; is replaced with &quot; now &quot; for messages about</a>
<a name="ln66">     * gaining the ability, or &quot; &quot; for messages about having the ability.</a>
<a name="ln67">     *</a>
<a name="ln68">     * Examples:</a>
<a name="ln69">     *   &quot;have super powers&quot;</a>
<a name="ln70">     *     =&gt; &quot;You have super powers&quot;, &quot;You now have super powers.&quot;</a>
<a name="ln71">     *   &quot;are NOW powerful&quot;</a>
<a name="ln72">     *     =&gt; &quot;You are powerful&quot;, &quot;You are now powerful.&quot;</a>
<a name="ln73">     *   &quot;Your power is NOW great&quot;</a>
<a name="ln74">     *     =&gt; &quot;Your power is great&quot;, &quot;Your power is now great&quot;</a>
<a name="ln75">     *   &quot;GOD NOW makes you powerful&quot;</a>
<a name="ln76">     *     =&gt; &quot;Moloch makes you powerful&quot;, &quot;Moloch now makes you powerful&quot;</a>
<a name="ln77">     *   &quot;GOD grants you a boon&quot;</a>
<a name="ln78">     *     =&gt; &quot;Moloch grants you a boon&quot; (in all situations)</a>
<a name="ln79">     *</a>
<a name="ln80">     * FIXME: This member is currently unused.</a>
<a name="ln81">     *</a>
<a name="ln82">     * @see god_passive::loss.</a>
<a name="ln83">     */</a>
<a name="ln84">    const char* gain;</a>
<a name="ln85">    /** Message to be given on loss of this passive.</a>
<a name="ln86">     *</a>
<a name="ln87">     * If empty, use the gain message. This makes sense only if the message</a>
<a name="ln88">     * contains &quot; NOW &quot;, either explicitly or implicitly through not</a>
<a name="ln89">     * beginning with a capital letter.</a>
<a name="ln90">     *</a>
<a name="ln91">     * The substring &quot;GOD&quot; is replaced with the name of the god.</a>
<a name="ln92">     * The substring &quot; NOW &quot; is replaced with &quot; no longer &quot;.</a>
<a name="ln93">     *</a>
<a name="ln94">     * Examples:</a>
<a name="ln95">     *   &quot;have super powers&quot;</a>
<a name="ln96">     *     =&gt; &quot;You no longer have super powers&quot;</a>
<a name="ln97">     *   &quot;are NOW powerful&quot;</a>
<a name="ln98">     *     =&gt; &quot;You are no longer powerful&quot;</a>
<a name="ln99">     *   &quot;Your power is NOW great&quot;</a>
<a name="ln100">     *     =&gt; &quot;Your power is no longer great&quot;</a>
<a name="ln101">     *   &quot;GOD NOW makes you powerful&quot;</a>
<a name="ln102">     *     =&gt; &quot;Moloch no longer makes you powerful&quot;</a>
<a name="ln103">     *   &quot;GOD grants you a boon&quot;</a>
<a name="ln104">     *     =&gt; &quot;Moloch grants you a boon&quot; (probably incorrect)</a>
<a name="ln105">     *</a>
<a name="ln106">     * FIXME: This member is currently unused.</a>
<a name="ln107">     *</a>
<a name="ln108">     * @see god_passive::gain.</a>
<a name="ln109">     */</a>
<a name="ln110">    const char* loss;</a>
<a name="ln111"> </a>
<a name="ln112">    god_passive(int rank_, passive_t pasv_, const char* gain_,</a>
<a name="ln113">                const char* loss_ = &quot;&quot;)</a>
<a name="ln114">        : rank{rank_}, pasv{pasv_}, gain{gain_}, loss{*loss_ ? loss_ : gain_}</a>
<a name="ln115">    { }</a>
<a name="ln116"> </a>
<a name="ln117">    god_passive(int rank_, const char* gain_, const char* loss_ = &quot;&quot;)</a>
<a name="ln118">        : god_passive(rank_, passive_t::none, gain_, loss_)</a>
<a name="ln119">    { }</a>
<a name="ln120"> </a>
<a name="ln121">    void display(bool gaining, const char* fmt) const</a>
<a name="ln122">    {</a>
<a name="ln123">        const char * const str = gaining ? gain : loss;</a>
<a name="ln124">        if (isupper(str[0]))</a>
<a name="ln125">            god_speaks(you.religion, str);</a>
<a name="ln126">        else</a>
<a name="ln127">            god_speaks(you.religion, make_stringf(fmt, str).c_str());</a>
<a name="ln128">    }</a>
<a name="ln129">};</a>
<a name="ln130"> </a>
<a name="ln131">static const vector&lt;god_passive&gt; god_passives[] =</a>
<a name="ln132">{</a>
<a name="ln133">    // no god</a>
<a name="ln134">    { },</a>
<a name="ln135"> </a>
<a name="ln136">    // Zin</a>
<a name="ln137">    {</a>
<a name="ln138">        { -1, passive_t::protect_from_harm,</a>
<a name="ln139">              &quot;GOD sometimes watches over you&quot;,</a>
<a name="ln140">              &quot;GOD no longer watches over you&quot;</a>
<a name="ln141">        },</a>
<a name="ln142">        { -1, passive_t::resist_mutation,</a>
<a name="ln143">              &quot;GOD can shield you from mutations&quot;,</a>
<a name="ln144">              &quot;GOD NOW you from mutations&quot;</a>
<a name="ln145">        },</a>
<a name="ln146">        { -1, passive_t::resist_polymorph,</a>
<a name="ln147">              &quot;GOD can protect you from unnatural transformations&quot;,</a>
<a name="ln148">              &quot;GOD NOW protects you from unnatural transformations&quot;,</a>
<a name="ln149">        },</a>
<a name="ln150">        { -1, passive_t::resist_hell_effects,</a>
<a name="ln151">              &quot;GOD can protect you from effects of Hell&quot;,</a>
<a name="ln152">              &quot;GOD NOW protects you from effects of Hell&quot;</a>
<a name="ln153">        },</a>
<a name="ln154">        { -1, passive_t::warn_shapeshifter,</a>
<a name="ln155">              &quot;GOD will NOW warn you about shapeshifters&quot;</a>
<a name="ln156">        },</a>
<a name="ln157">        {</a>
<a name="ln158">          6, passive_t::cleanse_mut_potions,</a>
<a name="ln159">              &quot;GOD cleanses your potions of mutation&quot;,</a>
<a name="ln160">              &quot;GOD no longer cleanses your potions of mutation&quot;,</a>
<a name="ln161">        }</a>
<a name="ln162">    },</a>
<a name="ln163"> </a>
<a name="ln164">    // TSO</a>
<a name="ln165">    {</a>
<a name="ln166">        { -1, passive_t::protect_from_harm,</a>
<a name="ln167">              &quot;GOD sometimes watches over you&quot;,</a>
<a name="ln168">              &quot;GOD no longer watches over you&quot;</a>
<a name="ln169">        },</a>
<a name="ln170">        { -1, passive_t::abjuration_protection_hd,</a>
<a name="ln171">              &quot;GOD NOW protects your summons from abjuration&quot; },</a>
<a name="ln172">        { -1, passive_t::bless_followers_vs_evil,</a>
<a name="ln173">              &quot;GOD NOW blesses your followers when they kill evil beings&quot; },</a>
<a name="ln174">        { -1, passive_t::restore_hp_mp_vs_evil,</a>
<a name="ln175">              &quot;gain health and magic from killing evil beings&quot; },</a>
<a name="ln176">        { -1, passive_t::no_stabbing,</a>
<a name="ln177">              &quot;are NOW prevented from stabbing unaware creatures&quot; },</a>
<a name="ln178">        {  0, passive_t::halo, &quot;are NOW surrounded by divine halo&quot; },</a>
<a name="ln179">    },</a>
<a name="ln180"> </a>
<a name="ln181">    // Kikubaaqudgha</a>
<a name="ln182">    {</a>
<a name="ln183">        {  2, passive_t::miscast_protection_necromancy,</a>
<a name="ln184">              &quot;GOD NOW protects you from necromancy miscasts&quot;</a>
<a name="ln185">              &quot; and mummy death curses&quot;</a>
<a name="ln186">        },</a>
<a name="ln187">        {  4, passive_t::resist_torment,</a>
<a name="ln188">              &quot;GOD NOW protects you from torment&quot; },</a>
<a name="ln189">    },</a>
<a name="ln190"> </a>
<a name="ln191">    // Yredelemnul</a>
<a name="ln192">    {</a>
<a name="ln193">        {  3, passive_t::nightvision, &quot;can NOW see well in the dark&quot; },</a>
<a name="ln194">    },</a>
<a name="ln195"> </a>
<a name="ln196">    // Xom</a>
<a name="ln197">    { },</a>
<a name="ln198"> </a>
<a name="ln199">    // Vehumet</a>
<a name="ln200">    {</a>
<a name="ln201">        { -1, passive_t::mp_on_kill,</a>
<a name="ln202">              &quot;have a chance to gain magical power from killing&quot; },</a>
<a name="ln203">        {  3, passive_t::spells_success,</a>
<a name="ln204">              &quot;are NOW less likely to miscast destructive spells&quot; },</a>
<a name="ln205">        {  4, passive_t::spells_range,</a>
<a name="ln206">              &quot;can NOW cast destructive spells farther&quot; },</a>
<a name="ln207">    },</a>
<a name="ln208"> </a>
<a name="ln209">    // Okawaru</a>
<a name="ln210">    {</a>
<a name="ln211">        // None</a>
<a name="ln212">    },</a>
<a name="ln213"> </a>
<a name="ln214">    // Makhleb</a>
<a name="ln215">    {</a>
<a name="ln216">        { -1, passive_t::restore_hp, &quot;gain health from killing&quot; },</a>
<a name="ln217">    },</a>
<a name="ln218"> </a>
<a name="ln219">    // Sif Muna</a>
<a name="ln220">    { },</a>
<a name="ln221"> </a>
<a name="ln222">    // Trog</a>
<a name="ln223">    {</a>
<a name="ln224">        { -1, passive_t::abjuration_protection,</a>
<a name="ln225">              &quot;GOD NOW protects your allies from abjuration&quot;</a>
<a name="ln226">        },</a>
<a name="ln227">        {  0, passive_t::extend_berserk,</a>
<a name="ln228">              &quot;can NOW maintain berserk longer, and are less likely to pass out&quot;,</a>
<a name="ln229">              &quot;can NOW maintain berserk as long, and are more likely to pass out&quot;</a>
<a name="ln230">        },</a>
<a name="ln231">    },</a>
<a name="ln232"> </a>
<a name="ln233">    // Nemelex</a>
<a name="ln234">    {</a>
<a name="ln235">        // None</a>
<a name="ln236">    },</a>
<a name="ln237"> </a>
<a name="ln238">    // Elyvilon</a>
<a name="ln239">    {</a>
<a name="ln240">        { -1, passive_t::protect_from_harm,</a>
<a name="ln241">              &quot;GOD sometimes watches over you&quot;,</a>
<a name="ln242">              &quot;GOD no longer watches over you&quot;</a>
<a name="ln243">        },</a>
<a name="ln244">        { -1, passive_t::protect_ally,</a>
<a name="ln245">              &quot;GOD can protect the life of your allies&quot;,</a>
<a name="ln246">              &quot;GOD NOW protects the life of your allies&quot;</a>
<a name="ln247">        },</a>
<a name="ln248">    },</a>
<a name="ln249"> </a>
<a name="ln250">    // Lugonu</a>
<a name="ln251">    {</a>
<a name="ln252">        { -1, passive_t::safe_distortion,</a>
<a name="ln253">              &quot;are NOW protected from distortion unwield effects&quot; },</a>
<a name="ln254">        { -1, passive_t::map_rot_res_abyss,</a>
<a name="ln255">              &quot;remember the shape of the Abyss better&quot; },</a>
<a name="ln256">        {  5, passive_t::attract_abyssal_rune,</a>
<a name="ln257">              &quot;GOD will NOW help you find the Abyssal rune&quot; },</a>
<a name="ln258">    },</a>
<a name="ln259"> </a>
<a name="ln260">    // Beogh</a>
<a name="ln261">    {</a>
<a name="ln262">        { -1, passive_t::share_exp, &quot;share experience with your followers&quot; },</a>
<a name="ln263">        {  3, passive_t::convert_orcs, &quot;inspire orcs to join your side&quot; },</a>
<a name="ln264">        {  3, passive_t::bless_followers,</a>
<a name="ln265">              &quot;GOD will bless your followers&quot;,</a>
<a name="ln266">              &quot;GOD will no longer bless your followers&quot;</a>
<a name="ln267">        },</a>
<a name="ln268">        {  5, passive_t::water_walk, &quot;walk on water&quot; },</a>
<a name="ln269">    },</a>
<a name="ln270"> </a>
<a name="ln271">    // Jiyva</a>
<a name="ln272">    {</a>
<a name="ln273">        { -1, passive_t::neutral_slimes,</a>
<a name="ln274">              &quot;Slimes and eye monsters are NOW neutral towards you&quot; },</a>
<a name="ln275">        { -1, passive_t::jellies_army,</a>
<a name="ln276">              &quot;GOD NOW summons jellies to protect you&quot; },</a>
<a name="ln277">        { -1, passive_t::jelly_eating,</a>
<a name="ln278">              &quot;GOD NOW allows jellies to devour items&quot; },</a>
<a name="ln279">        { -1, passive_t::fluid_stats,</a>
<a name="ln280">              &quot;GOD NOW adjusts your attributes periodically&quot; },</a>
<a name="ln281">        {  0, passive_t::slime_wall_immune,</a>
<a name="ln282">              &quot;are NOW immune to slime covered walls&quot; },</a>
<a name="ln283">        {  2, passive_t::slime_feed,</a>
<a name="ln284">              &quot;Items consumed by your fellow slimes NOW feed you&quot; },</a>
<a name="ln285">        {  3, passive_t::resist_corrosion,</a>
<a name="ln286">              &quot;GOD NOW protects you from corrosion&quot; },</a>
<a name="ln287">        {  4, passive_t::slime_mp,</a>
<a name="ln288">              &quot;Items consumed by your fellow slimes NOW restore&quot;</a>
<a name="ln289">              &quot; your magical power&quot;</a>
<a name="ln290">        },</a>
<a name="ln291">        {  5, passive_t::slime_hp,</a>
<a name="ln292">              &quot;Items consumed by your fellow slimes NOW restore&quot;</a>
<a name="ln293">              &quot; your health&quot;</a>
<a name="ln294">        },</a>
<a name="ln295">        {  6, passive_t::spawn_slimes_on_hit,</a>
<a name="ln296">              &quot;spawn slimes when struck by massive blows&quot; },</a>
<a name="ln297">        {  6, passive_t::unlock_slime_vaults,</a>
<a name="ln298">              &quot;GOD NOW grants you access to the hidden treasures&quot;</a>
<a name="ln299">              &quot; of the Slime Pits&quot;</a>
<a name="ln300">        },</a>
<a name="ln301">    },</a>
<a name="ln302"> </a>
<a name="ln303">    // Fedhas</a>
<a name="ln304">    {</a>
<a name="ln305">        { -1, passive_t::pass_through_plants,</a>
<a name="ln306">              &quot;can NOW walk through plants&quot; },</a>
<a name="ln307">        { -1, passive_t::shoot_through_plants,</a>
<a name="ln308">              &quot;can NOW safely fire through allied plants&quot; },</a>
<a name="ln309">        {  0, passive_t::friendly_plants,</a>
<a name="ln310">              &quot;Allied plants are NOW friendly towards you&quot; },</a>
<a name="ln311">    },</a>
<a name="ln312"> </a>
<a name="ln313">    // Cheibriados</a>
<a name="ln314">    {</a>
<a name="ln315">        { -1, passive_t::no_haste,</a>
<a name="ln316">              &quot;are NOW protected from inadvertent hurry&quot; },</a>
<a name="ln317">        { -1, passive_t::slowed, &quot;move less quickly&quot; },</a>
<a name="ln318">        {  0, passive_t::slow_orb_run,</a>
<a name="ln319">              &quot;GOD will NOW aid your escape with the Orb of Zot&quot;,</a>
<a name="ln320">        },</a>
<a name="ln321">        {  0, passive_t::stat_boost,</a>
<a name="ln322">              &quot;GOD NOW supports your attributes&quot;</a>
<a name="ln323">        },</a>
<a name="ln324">        {  0, passive_t::slow_abyss,</a>
<a name="ln325">              &quot;GOD will NOW slow the Abyss&quot;</a>
<a name="ln326">        },</a>
<a name="ln327">        // TODO: this one should work regardless of penance</a>
<a name="ln328">        {  1, passive_t::slow_metabolism, &quot;have a slowed metabolism&quot; },</a>
<a name="ln329">    },</a>
<a name="ln330"> </a>
<a name="ln331">    // Ashenzari</a>
<a name="ln332">    {</a>
<a name="ln333">        { -1, passive_t::want_curses, &quot;prefer cursed items&quot; },</a>
<a name="ln334">        { -1, passive_t::detect_portals, &quot;sense portals&quot; },</a>
<a name="ln335">        { -1, passive_t::identify_items, &quot;sense the properties of items&quot; },</a>
<a name="ln336">        {  0, passive_t::auto_map, &quot;have improved mapping abilities&quot; },</a>
<a name="ln337">        {  0, passive_t::detect_montier, &quot;sense threats&quot; },</a>
<a name="ln338">        {  0, passive_t::detect_items, &quot;sense items&quot; },</a>
<a name="ln339">        {  0, passive_t::avoid_traps,</a>
<a name="ln340">              &quot;avoid traps&quot; },</a>
<a name="ln341">        {  2, passive_t::bondage_skill_boost,</a>
<a name="ln342">              &quot;get a skill boost from cursed items&quot; },</a>
<a name="ln343">        {  3, passive_t::sinv, &quot;are NOW clear of vision&quot; },</a>
<a name="ln344">        {  4, passive_t::clarity, &quot;are NOW clear of mind&quot; },</a>
<a name="ln345">    },</a>
<a name="ln346"> </a>
<a name="ln347">    // Dithmenos</a>
<a name="ln348">    {</a>
<a name="ln349">        {  1, passive_t::nightvision, &quot;can NOW see well in the dark&quot; },</a>
<a name="ln350">        {  1, passive_t::umbra, &quot;are NOW surrounded by an umbra&quot; },</a>
<a name="ln351">        // TODO: this one should work regardless of penance.</a>
<a name="ln352">        {  3, passive_t::hit_smoke, &quot;emit smoke when hit&quot; },</a>
<a name="ln353">        {  4, passive_t::shadow_attacks,</a>
<a name="ln354">              &quot;Your attacks are NOW mimicked by a shadow&quot; },</a>
<a name="ln355">        {  4, passive_t::shadow_spells,</a>
<a name="ln356">              &quot;Your attack spells are NOW mimicked by a shadow&quot; },</a>
<a name="ln357">    },</a>
<a name="ln358"> </a>
<a name="ln359">    // Gozag</a>
<a name="ln360">    {</a>
<a name="ln361">        { -1, passive_t::detect_gold, &quot;detect gold&quot; },</a>
<a name="ln362">        {  0, passive_t::goldify_corpses,</a>
<a name="ln363">              &quot;GOD NOW turns all corpses to gold&quot; },</a>
<a name="ln364">        {  0, passive_t::gold_aura, &quot;have a gold aura&quot; },</a>
<a name="ln365">    },</a>
<a name="ln366"> </a>
<a name="ln367">    // Qazlal</a>
<a name="ln368">    {</a>
<a name="ln369">        {  0, passive_t::cloud_immunity, &quot;and your divine allies are ADV immune to clouds&quot; },</a>
<a name="ln370">        {  1, passive_t::storm_shield,</a>
<a name="ln371">              &quot;generate elemental clouds to protect yourself&quot; },</a>
<a name="ln372">        {  4, passive_t::upgraded_storm_shield,</a>
<a name="ln373">              &quot;Your chances to be struck by projectiles are NOW reduced&quot; },</a>
<a name="ln374">        {  5, passive_t::elemental_adaptation,</a>
<a name="ln375">              &quot;Elemental attacks NOW leave you somewhat more resistant&quot;</a>
<a name="ln376">              &quot; to them&quot;</a>
<a name="ln377">        }</a>
<a name="ln378">    },</a>
<a name="ln379"> </a>
<a name="ln380">    // Ru</a>
<a name="ln381">    {</a>
<a name="ln382">        {  1, passive_t::aura_of_power,</a>
<a name="ln383">              &quot;Your enemies will sometimes fail their attack or even hit themselves&quot;,</a>
<a name="ln384">              &quot;Your enemies will NOW fail their attack or hit themselves&quot;</a>
<a name="ln385">        },</a>
<a name="ln386">        {  2, passive_t::upgraded_aura_of_power,</a>
<a name="ln387">              &quot;Enemies that inflict damage upon you will sometimes receive&quot;</a>
<a name="ln388">              &quot; a detrimental status effect&quot;,</a>
<a name="ln389">              &quot;Enemies that inflict damage upon you will NOW receive&quot;</a>
<a name="ln390">              &quot; a detrimental status effect&quot;</a>
<a name="ln391">        },</a>
<a name="ln392">    },</a>
<a name="ln393"> </a>
<a name="ln394">#if TAG_MAJOR_VERSION == 34</a>
<a name="ln395">    // Pakellas</a>
<a name="ln396">    {</a>
<a name="ln397">        { -1, passive_t::no_mp_regen,</a>
<a name="ln398">              &quot;GOD NOW prevents you from regenerating your magical power&quot; },</a>
<a name="ln399">        { -1, passive_t::mp_on_kill, &quot;have a chance to gain magical power from&quot;</a>
<a name="ln400">                                     &quot; killing&quot; },</a>
<a name="ln401">        {  1, passive_t::bottle_mp,</a>
<a name="ln402">              &quot;GOD NOW collects and distills excess magic from your kills&quot;</a>
<a name="ln403">        },</a>
<a name="ln404">    },</a>
<a name="ln405">#endif</a>
<a name="ln406"> </a>
<a name="ln407">    // Uskayaw</a>
<a name="ln408">    { },</a>
<a name="ln409"> </a>
<a name="ln410">    // Hepliaklqana</a>
<a name="ln411">    {</a>
<a name="ln412">        { -1, passive_t::frail,</a>
<a name="ln413">              &quot;GOD NOW siphons a part of your essence into your ancestor&quot; },</a>
<a name="ln414">        {  5, passive_t::transfer_drain,</a>
<a name="ln415">              &quot;drain nearby creatures when transferring your ancestor&quot; },</a>
<a name="ln416">    },</a>
<a name="ln417"> </a>
<a name="ln418">    // Wu Jian</a>
<a name="ln419">    {</a>
<a name="ln420">        { 0, passive_t::wu_jian_lunge, &quot;perform damaging attacks by moving towards foes.&quot; },</a>
<a name="ln421">        { 1, passive_t::wu_jian_whirlwind, &quot;lightly attack monsters by moving around them.&quot; },</a>
<a name="ln422">        { 2, passive_t::wu_jian_wall_jump, &quot;perform airborne attacks in an area by jumping off a solid obstacle.&quot; },</a>
<a name="ln423">    },</a>
<a name="ln424">};</a>
<a name="ln425">COMPILE_CHECK(ARRAYSZ(god_passives) == NUM_GODS);</a>
<a name="ln426"> </a>
<a name="ln427">bool have_passive(passive_t passive)</a>
<a name="ln428">{</a>
<a name="ln429">    const auto &amp;pasvec = god_passives[you.religion];</a>
<a name="ln430">    return any_of(begin(pasvec), end(pasvec),</a>
<a name="ln431">                  [passive] (const god_passive &amp;p) -&gt; bool</a>
<a name="ln432">                  {</a>
<a name="ln433">                      return p.pasv == passive</a>
<a name="ln434">                          &amp;&amp; piety_rank() &gt;= p.rank</a>
<a name="ln435">                          &amp;&amp; (!player_under_penance() || p.rank &lt; 0);</a>
<a name="ln436">                  });</a>
<a name="ln437">}</a>
<a name="ln438"> </a>
<a name="ln439">bool will_have_passive(passive_t passive)</a>
<a name="ln440">{</a>
<a name="ln441">    const auto &amp;pasvec = god_passives[you.religion];</a>
<a name="ln442">    return any_of(begin(pasvec), end(pasvec),</a>
<a name="ln443">                  [passive] (const god_passive &amp;p) -&gt; bool</a>
<a name="ln444">                  {</a>
<a name="ln445">                      return p.pasv == passive;</a>
<a name="ln446">                  });</a>
<a name="ln447">}</a>
<a name="ln448"> </a>
<a name="ln449">// Returns a large number (10) if we will never get this passive.</a>
<a name="ln450">int rank_for_passive(passive_t passive)</a>
<a name="ln451">{</a>
<a name="ln452">    const auto &amp;pasvec = god_passives[you.religion];</a>
<a name="ln453">    const auto found = find_if(begin(pasvec), end(pasvec),</a>
<a name="ln454">                              [passive] (const god_passive &amp;p) -&gt; bool</a>
<a name="ln455">                              {</a>
<a name="ln456">                                  return p.pasv == passive;</a>
<a name="ln457">                              });</a>
<a name="ln458">    return found == end(pasvec) ? 10 : found-&gt;rank;</a>
<a name="ln459">}</a>
<a name="ln460"> </a>
<a name="ln461">int chei_stat_boost(int piety)</a>
<a name="ln462">{</a>
<a name="ln463">    if (!have_passive(passive_t::stat_boost))</a>
<a name="ln464">        return 0;</a>
<a name="ln465">    if (piety &lt; piety_breakpoint(0))  // Since you've already begun to slow down.</a>
<a name="ln466">        return 1;</a>
<a name="ln467">    if (piety &gt;= piety_breakpoint(5))</a>
<a name="ln468">        return 15;</a>
<a name="ln469">    return (piety - 10) / 10;</a>
<a name="ln470">}</a>
<a name="ln471"> </a>
<a name="ln472">// Eat from one random off-level item stack.</a>
<a name="ln473">void jiyva_eat_offlevel_items()</a>
<a name="ln474">{</a>
<a name="ln475">    // For wizard mode 'J' command</a>
<a name="ln476">    if (!have_passive(passive_t::jelly_eating))</a>
<a name="ln477">        return;</a>
<a name="ln478"> </a>
<a name="ln479">    if (crawl_state.game_is_sprint())</a>
<a name="ln480">        return;</a>
<a name="ln481"> </a>
<a name="ln482">    while (true)</a>
<a name="ln483">    {</a>
<a name="ln484">        if (one_chance_in(200))</a>
<a name="ln485">            break;</a>
<a name="ln486"> </a>
<a name="ln487">        const int branch = random2(NUM_BRANCHES);</a>
<a name="ln488"> </a>
<a name="ln489">        // Choose level based on main dungeon depth so that levels of</a>
<a name="ln490">        // short branches aren't picked more often.</a>
<a name="ln491">        ASSERT(brdepth[branch] &lt;= MAX_BRANCH_DEPTH);</a>
<a name="ln492">        const int level = random2(MAX_BRANCH_DEPTH) + 1;</a>
<a name="ln493"> </a>
<a name="ln494">        const level_id lid(static_cast&lt;branch_type&gt;(branch), level);</a>
<a name="ln495"> </a>
<a name="ln496">        if (lid == level_id::current() || !you.level_visited(lid))</a>
<a name="ln497">            continue;</a>
<a name="ln498"> </a>
<a name="ln499">        dprf(&quot;Checking %s&quot;, lid.describe().c_str());</a>
<a name="ln500"> </a>
<a name="ln501">        level_excursion le;</a>
<a name="ln502">        le.go_to(lid);</a>
<a name="ln503">        while (true)</a>
<a name="ln504">        {</a>
<a name="ln505">            if (one_chance_in(200))</a>
<a name="ln506">                break;</a>
<a name="ln507"> </a>
<a name="ln508">            const coord_def p = random_in_bounds();</a>
<a name="ln509"> </a>
<a name="ln510">            if (igrd(p) == NON_ITEM || testbits(env.pgrid(p), FPROP_NO_JIYVA))</a>
<a name="ln511">                continue;</a>
<a name="ln512"> </a>
<a name="ln513">            for (stack_iterator si(p); si; ++si)</a>
<a name="ln514">            {</a>
<a name="ln515">                if (!item_is_jelly_edible(*si) || one_chance_in(4))</a>
<a name="ln516">                    continue;</a>
<a name="ln517"> </a>
<a name="ln518">                if (one_chance_in(4))</a>
<a name="ln519">                    break;</a>
<a name="ln520"> </a>
<a name="ln521">                dprf(&quot;Eating %s on %s&quot;,</a>
<a name="ln522">                     si-&gt;name(DESC_PLAIN).c_str(), lid.describe().c_str());</a>
<a name="ln523"> </a>
<a name="ln524">                // Needs a message now to explain possible hp or mp</a>
<a name="ln525">                // gain from jiyva_slurp_bonus()</a>
<a name="ln526">                mpr(&quot;You hear a distant slurping noise.&quot;);</a>
<a name="ln527">                jiyva_slurp_item_stack(*si);</a>
<a name="ln528">                item_was_destroyed(*si);</a>
<a name="ln529">                destroy_item(si.index());</a>
<a name="ln530">            }</a>
<a name="ln531">            return;</a>
<a name="ln532">        }</a>
<a name="ln533">    }</a>
<a name="ln534">}</a>
<a name="ln535"> </a>
<a name="ln536">void ash_init_bondage(player *y)</a>
<a name="ln537">{</a>
<a name="ln538">    y-&gt;bondage_level = 0;</a>
<a name="ln539">    for (int i = ET_WEAPON; i &lt; NUM_ET; ++i)</a>
<a name="ln540">        y-&gt;bondage[i] = 0;</a>
<a name="ln541">}</a>
<a name="ln542"> </a>
<a name="ln543">static bool _two_handed()</a>
<a name="ln544">{</a>
<a name="ln545">    const item_def* wpn = you.slot_item(EQ_WEAPON, true);</a>
<a name="ln546">    if (!wpn)</a>
<a name="ln547">        return false;</a>
<a name="ln548"> </a>
<a name="ln549">    hands_reqd_type wep_type = you.hands_reqd(*wpn, true);</a>
<a name="ln550">    return wep_type == HANDS_TWO;</a>
<a name="ln551">}</a>
<a name="ln552"> </a>
<a name="ln553">void ash_check_bondage(bool msg)</a>
<a name="ln554">{</a>
<a name="ln555">    if (!will_have_passive(passive_t::bondage_skill_boost))</a>
<a name="ln556">        return;</a>
<a name="ln557"> </a>
<a name="ln558">    int cursed[NUM_ET] = {0}, slots[NUM_ET] = {0};</a>
<a name="ln559"> </a>
<a name="ln560">    for (int j = EQ_FIRST_EQUIP; j &lt; NUM_EQUIP; j++)</a>
<a name="ln561">    {</a>
<a name="ln562">        const equipment_type i = static_cast&lt;equipment_type&gt;(j);</a>
<a name="ln563">        eq_type s;</a>
<a name="ln564">        if (i == EQ_WEAPON)</a>
<a name="ln565">            s = ET_WEAPON;</a>
<a name="ln566">        else if (i == EQ_SHIELD)</a>
<a name="ln567">            s = ET_SHIELD;</a>
<a name="ln568">        else if (i &lt;= EQ_MAX_ARMOUR)</a>
<a name="ln569">            s = ET_ARMOUR;</a>
<a name="ln570">        // Missing hands mean fewer rings</a>
<a name="ln571">        else if (you.species != SP_OCTOPODE &amp;&amp; i == EQ_LEFT_RING</a>
<a name="ln572">                 &amp;&amp; you.get_mutation_level(MUT_MISSING_HAND))</a>
<a name="ln573">        {</a>
<a name="ln574">            continue;</a>
<a name="ln575">        }</a>
<a name="ln576">        // Octopodes don't count these slots:</a>
<a name="ln577">        else if (you.species == SP_OCTOPODE</a>
<a name="ln578">                 &amp;&amp; ((i == EQ_LEFT_RING || i == EQ_RIGHT_RING)</a>
<a name="ln579">                     || (i == EQ_RING_EIGHT</a>
<a name="ln580">                         &amp;&amp; you.get_mutation_level(MUT_MISSING_HAND))))</a>
<a name="ln581">        {</a>
<a name="ln582">            continue;</a>
<a name="ln583">        }</a>
<a name="ln584">        // *Only* octopodes count these slots:</a>
<a name="ln585">        else if (you.species != SP_OCTOPODE</a>
<a name="ln586">                 &amp;&amp; i &gt;= EQ_RING_ONE &amp;&amp; i &lt;= EQ_RING_EIGHT)</a>
<a name="ln587">        {</a>
<a name="ln588">            continue;</a>
<a name="ln589">        }</a>
<a name="ln590">        // The macabre finger necklace's extra slot does count if equipped.</a>
<a name="ln591">        else if (!player_equip_unrand(UNRAND_FINGER_AMULET)</a>
<a name="ln592">                 &amp;&amp; i == EQ_RING_AMULET)</a>
<a name="ln593">        {</a>
<a name="ln594">            continue;</a>
<a name="ln595">        }</a>
<a name="ln596">        else</a>
<a name="ln597">            s = ET_JEWELS;</a>
<a name="ln598"> </a>
<a name="ln599">        // transformed away slots are still considered to be possibly bound</a>
<a name="ln600">        if (you_can_wear(i))</a>
<a name="ln601">        {</a>
<a name="ln602">            slots[s]++;</a>
<a name="ln603">            if (you.equip[i] != -1)</a>
<a name="ln604">            {</a>
<a name="ln605">                const item_def&amp; item = you.inv[you.equip[i]];</a>
<a name="ln606">                if (item.cursed() &amp;&amp; (i != EQ_WEAPON || is_weapon(item)))</a>
<a name="ln607">                {</a>
<a name="ln608">                    if (s == ET_WEAPON</a>
<a name="ln609">                        &amp;&amp; (_two_handed()</a>
<a name="ln610">                            || you.get_mutation_level(MUT_MISSING_HAND)))</a>
<a name="ln611">                    {</a>
<a name="ln612">                        cursed[ET_WEAPON] = 3;</a>
<a name="ln613">                        cursed[ET_SHIELD] = 3;</a>
<a name="ln614">                    }</a>
<a name="ln615">                    else</a>
<a name="ln616">                    {</a>
<a name="ln617">                        cursed[s]++;</a>
<a name="ln618">                        if (i == EQ_BODY_ARMOUR &amp;&amp; is_unrandom_artefact(item, UNRAND_LEAR))</a>
<a name="ln619">                            cursed[s] += 3;</a>
<a name="ln620">                    }</a>
<a name="ln621">                }</a>
<a name="ln622">            }</a>
<a name="ln623">        }</a>
<a name="ln624">    }</a>
<a name="ln625"> </a>
<a name="ln626">    int8_t new_bondage[NUM_ET];</a>
<a name="ln627">    int old_level = you.bondage_level;</a>
<a name="ln628">    for (int s = ET_WEAPON; s &lt; NUM_ET; s++)</a>
<a name="ln629">    {</a>
<a name="ln630">        if (slots[s] == 0)</a>
<a name="ln631">            new_bondage[s] = -1;</a>
<a name="ln632">        // That's only for 2 handed weapons.</a>
<a name="ln633">        else if (cursed[s] &gt; slots[s])</a>
<a name="ln634">            new_bondage[s] = 3;</a>
<a name="ln635">        else if (cursed[s] == slots[s])</a>
<a name="ln636">            new_bondage[s] = 2;</a>
<a name="ln637">        else if (cursed[s] &gt; slots[s] / 2)</a>
<a name="ln638">            new_bondage[s] = 1;</a>
<a name="ln639">        else</a>
<a name="ln640">            new_bondage[s] = 0;</a>
<a name="ln641">    }</a>
<a name="ln642"> </a>
<a name="ln643">    you.bondage_level = 0;</a>
<a name="ln644">    // kittehs don't obey hoomie rules!</a>
<a name="ln645">    if (you.species == SP_FELID)</a>
<a name="ln646">    {</a>
<a name="ln647">        for (int i = EQ_LEFT_RING; i &lt;= EQ_AMULET; ++i)</a>
<a name="ln648">            if (you.equip[i] != -1 &amp;&amp; you.inv[you.equip[i]].cursed())</a>
<a name="ln649">                ++you.bondage_level;</a>
<a name="ln650"> </a>
<a name="ln651">        // Allow full bondage when all available slots are cursed.</a>
<a name="ln652">        if (you.bondage_level == 3)</a>
<a name="ln653">            ++you.bondage_level;</a>
<a name="ln654">    }</a>
<a name="ln655">    else</a>
<a name="ln656">        for (int i = ET_WEAPON; i &lt; NUM_ET; ++i)</a>
<a name="ln657">            if (new_bondage[i] &gt; 0)</a>
<a name="ln658">                ++you.bondage_level;</a>
<a name="ln659"> </a>
<a name="ln660">    int flags = 0;</a>
<a name="ln661">    if (msg)</a>
<a name="ln662">    {</a>
<a name="ln663">        for (int s = ET_WEAPON; s &lt; NUM_ET; s++)</a>
<a name="ln664">            if (new_bondage[s] != you.bondage[s])</a>
<a name="ln665">                flags |= 1 &lt;&lt; s;</a>
<a name="ln666">    }</a>
<a name="ln667"> </a>
<a name="ln668">    you.skill_boost.clear();</a>
<a name="ln669">    for (int s = ET_WEAPON; s &lt; NUM_ET; s++)</a>
<a name="ln670">    {</a>
<a name="ln671">        you.bondage[s] = new_bondage[s];</a>
<a name="ln672">        map&lt;skill_type, int8_t&gt; boosted_skills = ash_get_boosted_skills(eq_type(s));</a>
<a name="ln673">        for (const auto &amp;entry : boosted_skills)</a>
<a name="ln674">        {</a>
<a name="ln675">            you.skill_boost[entry.first] += entry.second;</a>
<a name="ln676">            if (you.skill_boost[entry.first] &gt; 3)</a>
<a name="ln677">                you.skill_boost[entry.first] = 3;</a>
<a name="ln678">        }</a>
<a name="ln679"> </a>
<a name="ln680">    }</a>
<a name="ln681"> </a>
<a name="ln682">    if (msg)</a>
<a name="ln683">    {</a>
<a name="ln684">        string desc = ash_describe_bondage(flags, you.bondage_level != old_level);</a>
<a name="ln685">        if (!desc.empty())</a>
<a name="ln686">            mprf(MSGCH_GOD, &quot;%s&quot;, desc.c_str());</a>
<a name="ln687">    }</a>
<a name="ln688">}</a>
<a name="ln689"> </a>
<a name="ln690">string ash_describe_bondage(int flags, bool level)</a>
<a name="ln691">{</a>
<a name="ln692">    string desc;</a>
<a name="ln693">    if (flags &amp; ETF_WEAPON &amp;&amp; flags &amp; ETF_SHIELD</a>
<a name="ln694">        &amp;&amp; you.bondage[ET_WEAPON] != -1)</a>
<a name="ln695">    {</a>
<a name="ln696">        if (you.bondage[ET_WEAPON] == you.bondage[ET_SHIELD])</a>
<a name="ln697">        {</a>
<a name="ln698">            const string verb = make_stringf(&quot;are%s&quot;,</a>
<a name="ln699">                                             you.bondage[ET_WEAPON] ? &quot;&quot;</a>
<a name="ln700">                                                                    : &quot; not&quot;);</a>
<a name="ln701">            desc = you.hands_act(verb, &quot;bound.\n&quot;);</a>
<a name="ln702">        }</a>
<a name="ln703">        else</a>
<a name="ln704">        {</a>
<a name="ln705">            // FIXME: what if you sacrificed a hand?</a>
<a name="ln706">            desc = make_stringf(&quot;Your %s %s is bound but not your %s %s.\n&quot;,</a>
<a name="ln707">                                you.bondage[ET_WEAPON] ? &quot;weapon&quot; : &quot;shield&quot;,</a>
<a name="ln708">                                you.hand_name(false).c_str(),</a>
<a name="ln709">                                you.bondage[ET_WEAPON] ? &quot;shield&quot; : &quot;weapon&quot;,</a>
<a name="ln710">                                you.hand_name(false).c_str());</a>
<a name="ln711">        }</a>
<a name="ln712">    }</a>
<a name="ln713">    else if (flags &amp; ETF_WEAPON &amp;&amp; you.bondage[ET_WEAPON] != -1)</a>
<a name="ln714">    {</a>
<a name="ln715">        desc = make_stringf(&quot;Your weapon %s is %sbound.\n&quot;,</a>
<a name="ln716">                            you.hand_name(false).c_str(),</a>
<a name="ln717">                            you.bondage[ET_WEAPON] ? &quot;&quot; : &quot;not &quot;);</a>
<a name="ln718">    }</a>
<a name="ln719">    else if (flags &amp; ETF_SHIELD &amp;&amp; you.bondage[ET_SHIELD] != -1)</a>
<a name="ln720">    {</a>
<a name="ln721">        desc = make_stringf(&quot;Your shield %s is %sbound.\n&quot;,</a>
<a name="ln722">                            you.hand_name(false).c_str(),</a>
<a name="ln723">                            you.bondage[ET_SHIELD] ? &quot;&quot; : &quot;not &quot;);</a>
<a name="ln724">    }</a>
<a name="ln725"> </a>
<a name="ln726">    if (flags &amp; ETF_ARMOUR &amp;&amp; flags &amp; ETF_JEWELS</a>
<a name="ln727">        &amp;&amp; you.bondage[ET_ARMOUR] == you.bondage[ET_JEWELS]</a>
<a name="ln728">        &amp;&amp; you.bondage[ET_ARMOUR] != -1)</a>
<a name="ln729">    {</a>
<a name="ln730">        desc += make_stringf(&quot;You are %s bound in armour %s jewellery.\n&quot;,</a>
<a name="ln731">                             you.bondage[ET_ARMOUR] == 0 ? &quot;not&quot; :</a>
<a name="ln732">                             you.bondage[ET_ARMOUR] == 1 ? &quot;partially&quot;</a>
<a name="ln733">                                                         : &quot;fully&quot;,</a>
<a name="ln734">                             you.bondage[ET_ARMOUR] == 0 ? &quot;or&quot; : &quot;and&quot;);</a>
<a name="ln735">    }</a>
<a name="ln736">    else</a>
<a name="ln737">    {</a>
<a name="ln738">        if (flags &amp; ETF_ARMOUR &amp;&amp; you.bondage[ET_ARMOUR] != -1)</a>
<a name="ln739">        {</a>
<a name="ln740">            desc += make_stringf(&quot;You are %s bound in armour.\n&quot;,</a>
<a name="ln741">                                 you.bondage[ET_ARMOUR] == 0 ? &quot;not&quot; :</a>
<a name="ln742">                                 you.bondage[ET_ARMOUR] == 1 ? &quot;partially&quot;</a>
<a name="ln743">                                                             : &quot;fully&quot;);</a>
<a name="ln744">        }</a>
<a name="ln745"> </a>
<a name="ln746">        if (flags &amp; ETF_JEWELS &amp;&amp; you.bondage[ET_JEWELS] != -1)</a>
<a name="ln747">        {</a>
<a name="ln748">            desc += make_stringf(&quot;You are %s bound in jewellery.\n&quot;,</a>
<a name="ln749">                                 you.bondage[ET_JEWELS] == 0 ? &quot;not&quot; :</a>
<a name="ln750">                                 you.bondage[ET_JEWELS] == 1 ? &quot;partially&quot;</a>
<a name="ln751">                                                             : &quot;fully&quot;);</a>
<a name="ln752">        }</a>
<a name="ln753">    }</a>
<a name="ln754"> </a>
<a name="ln755">    if (level)</a>
<a name="ln756">    {</a>
<a name="ln757">        desc += make_stringf(&quot;You are %s bound.&quot;,</a>
<a name="ln758">                             you.bondage_level == 0 ? &quot;not&quot; :</a>
<a name="ln759">                             you.bondage_level == 1 ? &quot;slightly&quot; :</a>
<a name="ln760">                             you.bondage_level == 2 ? &quot;moderately&quot; :</a>
<a name="ln761">                             you.bondage_level == 3 ? &quot;seriously&quot; :</a>
<a name="ln762">                             you.bondage_level == 4 ? &quot;fully&quot;</a>
<a name="ln763">                                                    : &quot;buggily&quot;);</a>
<a name="ln764">    }</a>
<a name="ln765"> </a>
<a name="ln766">    return trim_string(desc);</a>
<a name="ln767">}</a>
<a name="ln768"> </a>
<a name="ln769">static bool _is_slot_cursed(equipment_type eq)</a>
<a name="ln770">{</a>
<a name="ln771">    const item_def *worn = you.slot_item(eq, true);</a>
<a name="ln772">    if (!worn || !worn-&gt;cursed())</a>
<a name="ln773">        return false;</a>
<a name="ln774"> </a>
<a name="ln775">    if (eq == EQ_WEAPON)</a>
<a name="ln776">        return is_weapon(*worn);</a>
<a name="ln777">    return true;</a>
<a name="ln778">}</a>
<a name="ln779"> </a>
<a name="ln780">bool god_id_item(item_def&amp; item, bool silent)</a>
<a name="ln781">{</a>
<a name="ln782">    iflags_t old_ided = item.flags &amp; ISFLAG_IDENT_MASK;</a>
<a name="ln783">    iflags_t ided = 0;</a>
<a name="ln784"> </a>
<a name="ln785">    if (have_passive(passive_t::identify_items))</a>
<a name="ln786">    {</a>
<a name="ln787">        // Ashenzari (and other gods with both identify_items and want_curses)</a>
<a name="ln788">        // ties identification of weapon/armour plusses to cursed slots.</a>
<a name="ln789">        const bool ash = have_passive(passive_t::want_curses);</a>
<a name="ln790"> </a>
<a name="ln791">        // Don't identify runes or the orb, since this has no gameplay purpose</a>
<a name="ln792">        // and might mess up other things.</a>
<a name="ln793">        if (item.base_type == OBJ_RUNES || item_is_orb(item))</a>
<a name="ln794">            return false;</a>
<a name="ln795"> </a>
<a name="ln796">        ided = ISFLAG_KNOW_CURSE;</a>
<a name="ln797"> </a>
<a name="ln798">        if ((item.base_type == OBJ_JEWELLERY || item.base_type == OBJ_STAVES)</a>
<a name="ln799">            &amp;&amp; item_needs_autopickup(item))</a>
<a name="ln800">        {</a>
<a name="ln801">            item.props[&quot;needs_autopickup&quot;] = true;</a>
<a name="ln802">        }</a>
<a name="ln803"> </a>
<a name="ln804">        if (is_weapon(item) || item.base_type == OBJ_ARMOUR)</a>
<a name="ln805">            ided |= ISFLAG_KNOW_PROPERTIES | ISFLAG_KNOW_TYPE;</a>
<a name="ln806"> </a>
<a name="ln807">        if (item.base_type == OBJ_JEWELLERY)</a>
<a name="ln808">            ided |= ISFLAG_IDENT_MASK;</a>
<a name="ln809"> </a>
<a name="ln810">        if (item.base_type == OBJ_ARMOUR</a>
<a name="ln811">            &amp;&amp; (!ash || _is_slot_cursed(get_armour_slot(item))))</a>
<a name="ln812">        {</a>
<a name="ln813">            ided |= ISFLAG_KNOW_PLUSES;</a>
<a name="ln814">        }</a>
<a name="ln815"> </a>
<a name="ln816">        if (is_weapon(item)</a>
<a name="ln817">            &amp;&amp; (!ash || _is_slot_cursed(EQ_WEAPON)))</a>
<a name="ln818">        {</a>
<a name="ln819">            ided |= ISFLAG_KNOW_PLUSES;</a>
<a name="ln820">        }</a>
<a name="ln821">    }</a>
<a name="ln822"> </a>
<a name="ln823">    if (ided &amp; ~old_ided)</a>
<a name="ln824">    {</a>
<a name="ln825">        if (ided &amp; ISFLAG_KNOW_TYPE)</a>
<a name="ln826">            set_ident_type(item, true);</a>
<a name="ln827">        set_ident_flags(item, ided);</a>
<a name="ln828"> </a>
<a name="ln829">        if (item.props.exists(&quot;needs_autopickup&quot;) &amp;&amp; is_useless_item(item))</a>
<a name="ln830">            item.props.erase(&quot;needs_autopickup&quot;);</a>
<a name="ln831"> </a>
<a name="ln832">        if (&amp;item == you.weapon())</a>
<a name="ln833">            you.wield_change = true;</a>
<a name="ln834"> </a>
<a name="ln835">        if (!silent)</a>
<a name="ln836">            mprf_nocap(&quot;%s&quot;, item.name(DESC_INVENTORY_EQUIP).c_str());</a>
<a name="ln837"> </a>
<a name="ln838">        seen_item(item);</a>
<a name="ln839">        if (in_inventory(item))</a>
<a name="ln840">            auto_assign_item_slot(item);</a>
<a name="ln841">        return true;</a>
<a name="ln842">    }</a>
<a name="ln843"> </a>
<a name="ln844">    // nothing new</a>
<a name="ln845">    return false;</a>
<a name="ln846">}</a>
<a name="ln847"> </a>
<a name="ln848">static bool is_ash_portal(dungeon_feature_type feat)</a>
<a name="ln849">{</a>
<a name="ln850">    if (feat_is_portal_entrance(feat))</a>
<a name="ln851">        return true;</a>
<a name="ln852">    switch (feat)</a>
<a name="ln853">    {</a>
<a name="ln854">    case DNGN_ENTER_HELL:</a>
<a name="ln855">    case DNGN_ENTER_ABYSS: // for completeness</a>
<a name="ln856">    case DNGN_EXIT_THROUGH_ABYSS:</a>
<a name="ln857">    case DNGN_EXIT_ABYSS:</a>
<a name="ln858">    case DNGN_ENTER_PANDEMONIUM:</a>
<a name="ln859">    case DNGN_EXIT_PANDEMONIUM:</a>
<a name="ln860">    // DNGN_TRANSIT_PANDEMONIUM is too mundane</a>
<a name="ln861">        return true;</a>
<a name="ln862">    default:</a>
<a name="ln863">        return false;</a>
<a name="ln864">    }</a>
<a name="ln865">}</a>
<a name="ln866"> </a>
<a name="ln867">// Yay for rectangle_iterator and radius_iterator not sharing a base type</a>
<a name="ln868">static bool _check_portal(coord_def where)</a>
<a name="ln869">{</a>
<a name="ln870">    const dungeon_feature_type feat = grd(where);</a>
<a name="ln871">    if (feat != env.map_knowledge(where).feat() &amp;&amp; is_ash_portal(feat))</a>
<a name="ln872">    {</a>
<a name="ln873">        env.map_knowledge(where).set_feature(feat);</a>
<a name="ln874">        set_terrain_mapped(where);</a>
<a name="ln875"> </a>
<a name="ln876">        if (!testbits(env.pgrid(where), FPROP_SEEN_OR_NOEXP))</a>
<a name="ln877">        {</a>
<a name="ln878">            env.pgrid(where) |= FPROP_SEEN_OR_NOEXP;</a>
<a name="ln879">            if (!you.see_cell(where))</a>
<a name="ln880">                return true;</a>
<a name="ln881">        }</a>
<a name="ln882">    }</a>
<a name="ln883">    return false;</a>
<a name="ln884">}</a>
<a name="ln885"> </a>
<a name="ln886">int ash_detect_portals(bool all)</a>
<a name="ln887">{</a>
<a name="ln888">    if (!have_passive(passive_t::detect_portals))</a>
<a name="ln889">        return 0;</a>
<a name="ln890"> </a>
<a name="ln891">    int portals_found = 0;</a>
<a name="ln892">    const int map_radius = LOS_DEFAULT_RANGE + 1;</a>
<a name="ln893"> </a>
<a name="ln894">    if (all)</a>
<a name="ln895">    {</a>
<a name="ln896">        for (rectangle_iterator ri(0); ri; ++ri)</a>
<a name="ln897">        {</a>
<a name="ln898">            if (_check_portal(*ri))</a>
<a name="ln899">                portals_found++;</a>
<a name="ln900">        }</a>
<a name="ln901">    }</a>
<a name="ln902">    else</a>
<a name="ln903">    {</a>
<a name="ln904">        for (radius_iterator ri(you.pos(), map_radius, C_SQUARE); ri; ++ri)</a>
<a name="ln905">        {</a>
<a name="ln906">            if (_check_portal(*ri))</a>
<a name="ln907">                portals_found++;</a>
<a name="ln908">        }</a>
<a name="ln909">    }</a>
<a name="ln910"> </a>
<a name="ln911">    you.seen_portals += portals_found;</a>
<a name="ln912">    return portals_found;</a>
<a name="ln913">}</a>
<a name="ln914"> </a>
<a name="ln915">monster_type ash_monster_tier(const monster *mon)</a>
<a name="ln916">{</a>
<a name="ln917">    return monster_type(MONS_SENSED_TRIVIAL + monster_info(mon).threat);</a>
<a name="ln918">}</a>
<a name="ln919"> </a>
<a name="ln920">map&lt;skill_type, int8_t&gt; ash_get_boosted_skills(eq_type type)</a>
<a name="ln921">{</a>
<a name="ln922">    const int bondage = you.bondage[type];</a>
<a name="ln923">    map&lt;skill_type, int8_t&gt; boost;</a>
<a name="ln924">    if (bondage &lt;= 0)</a>
<a name="ln925">        return boost;</a>
<a name="ln926"> </a>
<a name="ln927">    // Include melded.</a>
<a name="ln928">    const item_def* wpn = you.slot_item(EQ_WEAPON, true);</a>
<a name="ln929">    const item_def* armour = you.slot_item(EQ_BODY_ARMOUR, true);</a>
<a name="ln930">    const int evp = armour ? -property(*armour, PARM_EVASION) / 10 : 0;</a>
<a name="ln931">    switch (type)</a>
<a name="ln932">    {</a>
<a name="ln933">    case (ET_WEAPON):</a>
<a name="ln934">        ASSERT(wpn);</a>
<a name="ln935"> </a>
<a name="ln936">        // Boost weapon skill. Plain &quot;staff&quot; means an unrand magical staff,</a>
<a name="ln937">        // boosted later.</a>
<a name="ln938">        if (wpn-&gt;base_type == OBJ_WEAPONS</a>
<a name="ln939">            &amp;&amp; wpn-&gt;sub_type != WPN_STAFF)</a>
<a name="ln940">        {</a>
<a name="ln941">            boost[item_attack_skill(*wpn)] = bondage;</a>
<a name="ln942">        }</a>
<a name="ln943">        // Staves that have a melee effect, powered by evocations.</a>
<a name="ln944">        if (staff_uses_evocations(*wpn))</a>
<a name="ln945">        {</a>
<a name="ln946">            boost[SK_EVOCATIONS] = 1;</a>
<a name="ln947">            boost[SK_STAVES] = 1;</a>
<a name="ln948"> </a>
<a name="ln949">        }</a>
<a name="ln950">        // Staves with an evokable ability but no melee effect.</a>
<a name="ln951">        else if (is_weapon(*wpn)</a>
<a name="ln952">                 &amp;&amp; item_is_evokable(*wpn, false, false, false, false))</a>
<a name="ln953">        {</a>
<a name="ln954">            boost[SK_EVOCATIONS] = 2;</a>
<a name="ln955">        }</a>
<a name="ln956">        // Other magical staves.</a>
<a name="ln957">        else if (wpn-&gt;base_type == OBJ_STAVES)</a>
<a name="ln958">            boost[SK_SPELLCASTING] = 2;</a>
<a name="ln959">        break;</a>
<a name="ln960"> </a>
<a name="ln961">    case (ET_SHIELD):</a>
<a name="ln962">        if (bondage == 2)</a>
<a name="ln963">            boost[SK_SHIELDS] = 1;</a>
<a name="ln964">        break;</a>
<a name="ln965"> </a>
<a name="ln966">    // Bonus for bounded armour depends on body armour type.</a>
<a name="ln967">    case (ET_ARMOUR):</a>
<a name="ln968">        if (evp &lt; 6)</a>
<a name="ln969">        {</a>
<a name="ln970">            boost[SK_STEALTH] = bondage;</a>
<a name="ln971">            boost[SK_DODGING] = bondage;</a>
<a name="ln972">        }</a>
<a name="ln973">        else if (evp &lt; 12)</a>
<a name="ln974">        {</a>
<a name="ln975">            boost[SK_DODGING] = bondage;</a>
<a name="ln976">            boost[SK_ARMOUR] = bondage;</a>
<a name="ln977">        }</a>
<a name="ln978">        else</a>
<a name="ln979">            boost[SK_ARMOUR] = bondage + 1;</a>
<a name="ln980">        break;</a>
<a name="ln981"> </a>
<a name="ln982">    // Boost all spell schools and evoc (to give some appeal to melee).</a>
<a name="ln983">    case (ET_JEWELS):</a>
<a name="ln984">        for (skill_type sk = SK_FIRST_MAGIC_SCHOOL; sk &lt;= SK_LAST_MAGIC; ++sk)</a>
<a name="ln985">            boost[sk] = bondage;</a>
<a name="ln986">        boost[SK_EVOCATIONS] = bondage;</a>
<a name="ln987">        break;</a>
<a name="ln988"> </a>
<a name="ln989">    default:</a>
<a name="ln990">        die(&quot;Unknown equipment type.&quot;);</a>
<a name="ln991">    }</a>
<a name="ln992"> </a>
<a name="ln993">    return boost;</a>
<a name="ln994">}</a>
<a name="ln995"> </a>
<a name="ln996">/**</a>
<a name="ln997"> * Does the player have an ash skill boost for a particular skill?</a>
<a name="ln998"> */</a>
<a name="ln999">bool ash_has_skill_boost(skill_type sk)</a>
<a name="ln1000">{</a>
<a name="ln1001">    return have_passive(passive_t::bondage_skill_boost)</a>
<a name="ln1002">           &amp;&amp; you.skill_boost.count(sk) &amp;&amp; you.skill_boost.find(sk)-&gt;second;</a>
<a name="ln1003">}</a>
<a name="ln1004"> </a>
<a name="ln1005">/**</a>
<a name="ln1006"> * Calculate the ash skill point boost for skill sk.</a>
<a name="ln1007"> *</a>
<a name="ln1008"> * @param scaled_skill the skill level to calculate it for, scaled by 10.</a>
<a name="ln1009"> *</a>
<a name="ln1010"> * @return the skill point bonus to use.</a>
<a name="ln1011"> */</a>
<a name="ln1012">unsigned int ash_skill_point_boost(skill_type sk, int scaled_skill)</a>
<a name="ln1013">{</a>
<a name="ln1014">    unsigned int skill_points = 0;</a>
<a name="ln1015"> </a>
<a name="ln1016">    skill_points += (you.skill_boost[sk] * 2 + 1) * (piety_rank() + 1)</a>
<a name="ln1017">                    * max(scaled_skill, 1) * species_apt_factor(sk);</a>
<a name="ln1018">    return skill_points;</a>
<a name="ln1019">}</a>
<a name="ln1020"> </a>
<a name="ln1021">int ash_skill_boost(skill_type sk, int scale)</a>
<a name="ln1022">{</a>
<a name="ln1023">    // It gives a bonus to skill points. The formula is:</a>
<a name="ln1024">    // factor * (piety_rank + 1) * skill_level</a>
<a name="ln1025">    // low bonus    -&gt; factor = 3</a>
<a name="ln1026">    // medium bonus -&gt; factor = 5</a>
<a name="ln1027">    // high bonus   -&gt; factor = 7</a>
<a name="ln1028"> </a>
<a name="ln1029">    unsigned int skill_points = you.skill_points[sk]</a>
<a name="ln1030">                  + get_crosstrain_points(sk)</a>
<a name="ln1031">                  + ash_skill_point_boost(sk, you.skill(sk, 10, true));</a>
<a name="ln1032"> </a>
<a name="ln1033">    int level = you.skills[sk];</a>
<a name="ln1034">    while (level &lt; MAX_SKILL_LEVEL &amp;&amp; skill_points &gt;= skill_exp_needed(level + 1, sk))</a>
<a name="ln1035">        ++level;</a>
<a name="ln1036"> </a>
<a name="ln1037">    level = level * scale + get_skill_progress(sk, level, skill_points, scale);</a>
<a name="ln1038"> </a>
<a name="ln1039">    return min(level, MAX_SKILL_LEVEL * scale);</a>
<a name="ln1040">}</a>
<a name="ln1041"> </a>
<a name="ln1042">int gozag_gold_in_los(actor *whom)</a>
<a name="ln1043">{</a>
<a name="ln1044">    if (!have_passive(passive_t::gold_aura))</a>
<a name="ln1045">        return 0;</a>
<a name="ln1046"> </a>
<a name="ln1047">    int gold_count = 0;</a>
<a name="ln1048"> </a>
<a name="ln1049">    for (radius_iterator ri(whom-&gt;pos(), LOS_RADIUS, C_SQUARE, LOS_DEFAULT);</a>
<a name="ln1050">         ri; ++ri)</a>
<a name="ln1051">    {</a>
<a name="ln1052">        for (stack_iterator j(*ri); j; ++j)</a>
<a name="ln1053">        {</a>
<a name="ln1054">            if (j-&gt;base_type == OBJ_GOLD)</a>
<a name="ln1055">                ++gold_count;</a>
<a name="ln1056">        }</a>
<a name="ln1057">    }</a>
<a name="ln1058"> </a>
<a name="ln1059">    return gold_count;</a>
<a name="ln1060">}</a>
<a name="ln1061"> </a>
<a name="ln1062">void gozag_detect_level_gold(bool count)</a>
<a name="ln1063">{</a>
<a name="ln1064">    vector&lt;item_def *&gt; gold_piles;</a>
<a name="ln1065">    vector&lt;coord_def&gt; gold_places;</a>
<a name="ln1066">    int gold = 0;</a>
<a name="ln1067">    for (rectangle_iterator ri(0); ri; ++ri)</a>
<a name="ln1068">    {</a>
<a name="ln1069">        for (stack_iterator j(*ri); j; ++j)</a>
<a name="ln1070">        {</a>
<a name="ln1071">            if (j-&gt;base_type == OBJ_GOLD &amp;&amp; !(j-&gt;flags &amp; ISFLAG_UNOBTAINABLE))</a>
<a name="ln1072">            {</a>
<a name="ln1073">                gold += j-&gt;quantity;</a>
<a name="ln1074">                gold_piles.push_back(&amp;(*j));</a>
<a name="ln1075">                gold_places.push_back(*ri);</a>
<a name="ln1076">            }</a>
<a name="ln1077">        }</a>
<a name="ln1078">    }</a>
<a name="ln1079"> </a>
<a name="ln1080">    if (!player_in_branch(BRANCH_ABYSS) &amp;&amp; count)</a>
<a name="ln1081">        you.attribute[ATTR_GOLD_GENERATED] += gold;</a>
<a name="ln1082"> </a>
<a name="ln1083">    if (have_passive(passive_t::detect_gold))</a>
<a name="ln1084">    {</a>
<a name="ln1085">        for (unsigned int i = 0; i &lt; gold_places.size(); i++)</a>
<a name="ln1086">        {</a>
<a name="ln1087">            bool detected = false;</a>
<a name="ln1088">            int dummy = gold_piles[i]-&gt;index();</a>
<a name="ln1089">            coord_def &amp;pos = gold_places[i];</a>
<a name="ln1090">            unlink_item(dummy);</a>
<a name="ln1091">            move_item_to_grid(&amp;dummy, pos, true);</a>
<a name="ln1092">            if (!env.map_knowledge(pos).item()</a>
<a name="ln1093">                || env.map_knowledge(pos).item()-&gt;base_type != OBJ_GOLD)</a>
<a name="ln1094">            {</a>
<a name="ln1095">                detected = true;</a>
<a name="ln1096">                update_item_at(pos, true);</a>
<a name="ln1097">            }</a>
<a name="ln1098">            // the pile can still remain undetected if it is not in</a>
<a name="ln1099">            // you.visible_igrd, for example if it is under deep water and the</a>
<a name="ln1100">            // player will not be able to see it.</a>
<a name="ln1101">            if (detected &amp;&amp; env.map_knowledge(pos).item())</a>
<a name="ln1102">            {</a>
<a name="ln1103">                env.map_knowledge(pos).flags |= MAP_DETECTED_ITEM;</a>
<a name="ln1104">#ifdef USE_TILE</a>
<a name="ln1105">                // force an update for gold generated during Abyss shifts</a>
<a name="ln1106">                tiles.update_minimap(pos);</a>
<a name="ln1107">#endif</a>
<a name="ln1108">            }</a>
<a name="ln1109">        }</a>
<a name="ln1110">    }</a>
<a name="ln1111">}</a>
<a name="ln1112"> </a>
<a name="ln1113">int qazlal_sh_boost(int piety)</a>
<a name="ln1114">{</a>
<a name="ln1115">    if (!have_passive(passive_t::storm_shield))</a>
<a name="ln1116">        return 0;</a>
<a name="ln1117"> </a>
<a name="ln1118">    return min(piety, piety_breakpoint(5)) / 10;</a>
<a name="ln1119">}</a>
<a name="ln1120"> </a>
<a name="ln1121">// Not actually passive, but placing it here so that it can be easily compared</a>
<a name="ln1122">// with Qazlal's boost.</a>
<a name="ln1123">int tso_sh_boost()</a>
<a name="ln1124">{</a>
<a name="ln1125">    if (!you.duration[DUR_DIVINE_SHIELD])</a>
<a name="ln1126">        return 0;</a>
<a name="ln1127"> </a>
<a name="ln1128">    return you.attribute[ATTR_DIVINE_SHIELD];</a>
<a name="ln1129">}</a>
<a name="ln1130"> </a>
<a name="ln1131">void qazlal_storm_clouds()</a>
<a name="ln1132">{</a>
<a name="ln1133">    if (!have_passive(passive_t::storm_shield))</a>
<a name="ln1134">        return;</a>
<a name="ln1135"> </a>
<a name="ln1136">    // You are a *storm*. You are pretty loud!</a>
<a name="ln1137">    noisy(min((int)you.piety, piety_breakpoint(5)) / 10, you.pos());</a>
<a name="ln1138"> </a>
<a name="ln1139">    const int radius = you.piety &gt;= piety_breakpoint(3) ? 2 : 1;</a>
<a name="ln1140"> </a>
<a name="ln1141">    vector&lt;coord_def&gt; candidates;</a>
<a name="ln1142">    for (radius_iterator ri(you.pos(), radius, C_SQUARE, LOS_SOLID, true);</a>
<a name="ln1143">         ri; ++ri)</a>
<a name="ln1144">    {</a>
<a name="ln1145">        int count = 0;</a>
<a name="ln1146">        if (cell_is_solid(*ri) || cloud_at(*ri))</a>
<a name="ln1147">            continue;</a>
<a name="ln1148"> </a>
<a name="ln1149">        // Don't create clouds over firewood</a>
<a name="ln1150">        const monster * mon = monster_at(*ri);</a>
<a name="ln1151">        if (mon != nullptr &amp;&amp; mons_is_firewood(*mon))</a>
<a name="ln1152">            continue;</a>
<a name="ln1153"> </a>
<a name="ln1154">        // No clouds in corridors.</a>
<a name="ln1155">        for (adjacent_iterator ai(*ri); ai; ++ai)</a>
<a name="ln1156">            if (!cell_is_solid(*ai))</a>
<a name="ln1157">                count++;</a>
<a name="ln1158"> </a>
<a name="ln1159">        if (count &gt;= 5)</a>
<a name="ln1160">            candidates.push_back(*ri);</a>
<a name="ln1161">    }</a>
<a name="ln1162">    const int count =</a>
<a name="ln1163">        div_rand_round(min((int)you.piety, piety_breakpoint(5))</a>
<a name="ln1164">                       * candidates.size() * you.time_taken,</a>
<a name="ln1165">                       piety_breakpoint(5) * 7 * BASELINE_DELAY);</a>
<a name="ln1166">    if (count &lt; 0)</a>
<a name="ln1167">        return;</a>
<a name="ln1168">    shuffle_array(candidates);</a>
<a name="ln1169">    int placed = 0;</a>
<a name="ln1170">    for (unsigned int i = 0; placed &lt; count &amp;&amp; i &lt; candidates.size(); i++)</a>
<a name="ln1171">    {</a>
<a name="ln1172">        bool water = false;</a>
<a name="ln1173">        for (adjacent_iterator ai(candidates[i]); ai; ++ai)</a>
<a name="ln1174">        {</a>
<a name="ln1175">            if (feat_is_watery(grd(*ai)))</a>
<a name="ln1176">                water = true;</a>
<a name="ln1177">        }</a>
<a name="ln1178"> </a>
<a name="ln1179">        // No flame clouds over water to avoid steam generation.</a>
<a name="ln1180">        cloud_type ctype;</a>
<a name="ln1181">        do</a>
<a name="ln1182">        {</a>
<a name="ln1183">            ctype = random_choose(CLOUD_FIRE, CLOUD_COLD, CLOUD_STORM,</a>
<a name="ln1184">                                  CLOUD_DUST);</a>
<a name="ln1185">        } while (water &amp;&amp; ctype == CLOUD_FIRE);</a>
<a name="ln1186"> </a>
<a name="ln1187">        place_cloud(ctype, candidates[i], random_range(3, 5), &amp;you);</a>
<a name="ln1188">        placed++;</a>
<a name="ln1189">    }</a>
<a name="ln1190">}</a>
<a name="ln1191"> </a>
<a name="ln1192">/**</a>
<a name="ln1193"> * Handle Qazlal's elemental adaptation.</a>
<a name="ln1194"> * This should be called (exactly once) for physical, fire, cold, and electrical damage.</a>
<a name="ln1195"> * Right now, it is called only from expose_player_to_element. This may merit refactoring.</a>
<a name="ln1196"> *</a>
<a name="ln1197"> * @param flavour the beam type.</a>
<a name="ln1198"> * @param strength The adaptations will trigger strength in (11 - piety_rank()) times. In practice, this is mostly called with a value of 2.</a>
<a name="ln1199"> */</a>
<a name="ln1200">void qazlal_element_adapt(beam_type flavour, int strength)</a>
<a name="ln1201">{</a>
<a name="ln1202">    if (strength &lt;= 0</a>
<a name="ln1203">        || !have_passive(passive_t::elemental_adaptation)</a>
<a name="ln1204">        || !x_chance_in_y(strength, 11 - piety_rank()))</a>
<a name="ln1205">    {</a>
<a name="ln1206">        return;</a>
<a name="ln1207">    }</a>
<a name="ln1208"> </a>
<a name="ln1209">    beam_type what = BEAM_NONE;</a>
<a name="ln1210">    duration_type dur = NUM_DURATIONS;</a>
<a name="ln1211">    string descript = &quot;&quot;;</a>
<a name="ln1212">    switch (flavour)</a>
<a name="ln1213">    {</a>
<a name="ln1214">        case BEAM_FIRE:</a>
<a name="ln1215">        case BEAM_LAVA:</a>
<a name="ln1216">        case BEAM_STICKY_FLAME:</a>
<a name="ln1217">        case BEAM_STEAM:</a>
<a name="ln1218">            what = BEAM_FIRE;</a>
<a name="ln1219">            dur = DUR_QAZLAL_FIRE_RES;</a>
<a name="ln1220">            descript = &quot;fire&quot;;</a>
<a name="ln1221">            break;</a>
<a name="ln1222">        case BEAM_COLD:</a>
<a name="ln1223">        case BEAM_ICE:</a>
<a name="ln1224">            what = BEAM_COLD;</a>
<a name="ln1225">            dur = DUR_QAZLAL_COLD_RES;</a>
<a name="ln1226">            descript = &quot;cold&quot;;</a>
<a name="ln1227">            break;</a>
<a name="ln1228">        case BEAM_ELECTRICITY:</a>
<a name="ln1229">            what = BEAM_ELECTRICITY;</a>
<a name="ln1230">            dur = DUR_QAZLAL_ELEC_RES;</a>
<a name="ln1231">            descript = &quot;electricity&quot;;</a>
<a name="ln1232">            break;</a>
<a name="ln1233">        case BEAM_MMISSILE: // for LCS, iron shot</a>
<a name="ln1234">        case BEAM_MISSILE:</a>
<a name="ln1235">        case BEAM_FRAG:</a>
<a name="ln1236">            what = BEAM_MISSILE;</a>
<a name="ln1237">            dur = DUR_QAZLAL_AC;</a>
<a name="ln1238">            descript = &quot;physical attacks&quot;;</a>
<a name="ln1239">            break;</a>
<a name="ln1240">        default:</a>
<a name="ln1241">            return;</a>
<a name="ln1242">    }</a>
<a name="ln1243"> </a>
<a name="ln1244">    if (what != BEAM_FIRE &amp;&amp; you.duration[DUR_QAZLAL_FIRE_RES])</a>
<a name="ln1245">    {</a>
<a name="ln1246">        mprf(MSGCH_DURATION, &quot;Your resistance to fire fades away.&quot;);</a>
<a name="ln1247">        you.duration[DUR_QAZLAL_FIRE_RES] = 0;</a>
<a name="ln1248">    }</a>
<a name="ln1249"> </a>
<a name="ln1250">    if (what != BEAM_COLD &amp;&amp; you.duration[DUR_QAZLAL_COLD_RES])</a>
<a name="ln1251">    {</a>
<a name="ln1252">        mprf(MSGCH_DURATION, &quot;Your resistance to cold fades away.&quot;);</a>
<a name="ln1253">        you.duration[DUR_QAZLAL_COLD_RES] = 0;</a>
<a name="ln1254">    }</a>
<a name="ln1255"> </a>
<a name="ln1256">    if (what != BEAM_ELECTRICITY &amp;&amp; you.duration[DUR_QAZLAL_ELEC_RES])</a>
<a name="ln1257">    {</a>
<a name="ln1258">        mprf(MSGCH_DURATION, &quot;Your resistance to electricity fades away.&quot;);</a>
<a name="ln1259">        you.duration[DUR_QAZLAL_ELEC_RES] = 0;</a>
<a name="ln1260">    }</a>
<a name="ln1261"> </a>
<a name="ln1262">    if (what != BEAM_MISSILE &amp;&amp; you.duration[DUR_QAZLAL_AC])</a>
<a name="ln1263">    {</a>
<a name="ln1264">        mprf(MSGCH_DURATION, &quot;Your resistance to physical damage fades away.&quot;);</a>
<a name="ln1265">        you.duration[DUR_QAZLAL_AC] = 0;</a>
<a name="ln1266">        you.redraw_armour_class = true;</a>
<a name="ln1267">    }</a>
<a name="ln1268"> </a>
<a name="ln1269">    mprf(MSGCH_GOD, &quot;You feel %sprotected from %s.&quot;,</a>
<a name="ln1270">         you.duration[dur] &gt; 0 ? &quot;more &quot; : &quot;&quot;, descript.c_str());</a>
<a name="ln1271"> </a>
<a name="ln1272">    // was scaled by 10 * strength. But the strength parameter is used so inconsistently that</a>
<a name="ln1273">    // it seems like a constant would be better, based on the typical value of 2.</a>
<a name="ln1274">    you.increase_duration(dur, 20, 80);</a>
<a name="ln1275"> </a>
<a name="ln1276">    if (what == BEAM_MISSILE)</a>
<a name="ln1277">        you.redraw_armour_class = true;</a>
<a name="ln1278">}</a>
<a name="ln1279"> </a>
<a name="ln1280">/**</a>
<a name="ln1281"> * Determine whether a Ru worshipper will attempt to interfere with an attack</a>
<a name="ln1282"> * against the player.</a>
<a name="ln1283"> *</a>
<a name="ln1284"> * @return bool Whether or not whether the worshipper will attempt to interfere.</a>
<a name="ln1285"> */</a>
<a name="ln1286">bool does_ru_wanna_redirect(monster* mon)</a>
<a name="ln1287">{</a>
<a name="ln1288">    return have_passive(passive_t::aura_of_power)</a>
<a name="ln1289">            &amp;&amp; !mon-&gt;friendly()</a>
<a name="ln1290">            &amp;&amp; you.see_cell_no_trans(mon-&gt;pos())</a>
<a name="ln1291">            &amp;&amp; !mons_is_firewood(*mon)</a>
<a name="ln1292">            &amp;&amp; !mon-&gt;submerged()</a>
<a name="ln1293">            &amp;&amp; !mons_is_projectile(mon-&gt;type);</a>
<a name="ln1294">}</a>
<a name="ln1295"> </a>
<a name="ln1296">/**</a>
<a name="ln1297"> * Determine which, if any, action Ru takes on a possible attack.</a>
<a name="ln1298"> *</a>
<a name="ln1299"> * @return ru_interference</a>
<a name="ln1300"> */</a>
<a name="ln1301">ru_interference get_ru_attack_interference_level()</a>
<a name="ln1302">{</a>
<a name="ln1303">    int r = random2(100);</a>
<a name="ln1304">    int chance = div_rand_round(you.piety, 16);</a>
<a name="ln1305"> </a>
<a name="ln1306">    // 10% chance of stopping any attack at max piety</a>
<a name="ln1307">    if (r &lt; chance)</a>
<a name="ln1308">        return DO_BLOCK_ATTACK;</a>
<a name="ln1309"> </a>
<a name="ln1310">    // 5% chance of redirect at max piety</a>
<a name="ln1311">    else if (r &lt; chance + div_rand_round(chance, 2))</a>
<a name="ln1312">        return DO_REDIRECT_ATTACK;</a>
<a name="ln1313"> </a>
<a name="ln1314">    else</a>
<a name="ln1315">        return DO_NOTHING;</a>
<a name="ln1316">}</a>
<a name="ln1317"> </a>
<a name="ln1318">static bool _shadow_acts(bool spell)</a>
<a name="ln1319">{</a>
<a name="ln1320">    const passive_t pasv = spell ? passive_t::shadow_spells</a>
<a name="ln1321">                                 : passive_t::shadow_attacks;</a>
<a name="ln1322">    if (!have_passive(pasv))</a>
<a name="ln1323">        return false;</a>
<a name="ln1324"> </a>
<a name="ln1325">    const int minpiety = piety_breakpoint(rank_for_passive(pasv) - 1);</a>
<a name="ln1326"> </a>
<a name="ln1327">    // 10% chance at minimum piety; 50% chance at 200 piety.</a>
<a name="ln1328">    const int range = MAX_PIETY - minpiety;</a>
<a name="ln1329">    const int min   = range / 5;</a>
<a name="ln1330">    return x_chance_in_y(min + ((range - min)</a>
<a name="ln1331">                                * (you.piety - minpiety)</a>
<a name="ln1332">                                / (MAX_PIETY - minpiety)),</a>
<a name="ln1333">                         2 * range);</a>
<a name="ln1334">}</a>
<a name="ln1335"> </a>
<a name="ln1336">monster* shadow_monster(bool equip)</a>
<a name="ln1337">{</a>
<a name="ln1338">    if (monster_at(you.pos()))</a>
<a name="ln1339">        return nullptr;</a>
<a name="ln1340"> </a>
<a name="ln1341">    int wpn_index  = NON_ITEM;</a>
<a name="ln1342"> </a>
<a name="ln1343">    // Do a basic clone of the weapon.</a>
<a name="ln1344">    item_def* wpn = you.weapon();</a>
<a name="ln1345">    if (equip</a>
<a name="ln1346">        &amp;&amp; wpn</a>
<a name="ln1347">        &amp;&amp; is_weapon(*wpn))</a>
<a name="ln1348">    {</a>
<a name="ln1349">        wpn_index = get_mitm_slot(10);</a>
<a name="ln1350">        if (wpn_index == NON_ITEM)</a>
<a name="ln1351">            return nullptr;</a>
<a name="ln1352">        item_def&amp; new_item = mitm[wpn_index];</a>
<a name="ln1353">        if (wpn-&gt;base_type == OBJ_STAVES)</a>
<a name="ln1354">        {</a>
<a name="ln1355">            new_item.base_type = OBJ_WEAPONS;</a>
<a name="ln1356">            new_item.sub_type  = WPN_STAFF;</a>
<a name="ln1357">        }</a>
<a name="ln1358">        else</a>
<a name="ln1359">        {</a>
<a name="ln1360">            new_item.base_type = wpn-&gt;base_type;</a>
<a name="ln1361">            new_item.sub_type  = wpn-&gt;sub_type;</a>
<a name="ln1362">        }</a>
<a name="ln1363">        new_item.quantity = 1;</a>
<a name="ln1364">        new_item.rnd = 1;</a>
<a name="ln1365">        new_item.flags   |= ISFLAG_SUMMONED;</a>
<a name="ln1366">    }</a>
<a name="ln1367"> </a>
<a name="ln1368">    monster* mon = get_free_monster();</a>
<a name="ln1369">    if (!mon)</a>
<a name="ln1370">    {</a>
<a name="ln1371">        if (wpn_index)</a>
<a name="ln1372">            destroy_item(wpn_index);</a>
<a name="ln1373">        return nullptr;</a>
<a name="ln1374">    }</a>
<a name="ln1375"> </a>
<a name="ln1376">    mon-&gt;type       = MONS_PLAYER_SHADOW;</a>
<a name="ln1377">    mon-&gt;behaviour  = BEH_SEEK;</a>
<a name="ln1378">    mon-&gt;attitude   = ATT_FRIENDLY;</a>
<a name="ln1379">    mon-&gt;flags      = MF_NO_REWARD | MF_JUST_SUMMONED | MF_SEEN</a>
<a name="ln1380">                    | MF_WAS_IN_VIEW | MF_HARD_RESET;</a>
<a name="ln1381">    mon-&gt;hit_points = you.hp;</a>
<a name="ln1382">    mon-&gt;set_hit_dice(min(27, max(1,</a>
<a name="ln1383">                                  you.skill_rdiv(wpn_index != NON_ITEM</a>
<a name="ln1384">                                                 ? item_attack_skill(mitm[wpn_index])</a>
<a name="ln1385">                                                 : SK_UNARMED_COMBAT, 10, 20)</a>
<a name="ln1386">                                  + you.skill_rdiv(SK_FIGHTING, 10, 20))));</a>
<a name="ln1387">    mon-&gt;set_position(you.pos());</a>
<a name="ln1388">    mon-&gt;mid        = MID_PLAYER;</a>
<a name="ln1389">    mon-&gt;inv[MSLOT_WEAPON]  = wpn_index;</a>
<a name="ln1390">    mon-&gt;inv[MSLOT_MISSILE] = NON_ITEM;</a>
<a name="ln1391"> </a>
<a name="ln1392">    mgrd(you.pos()) = mon-&gt;mindex();</a>
<a name="ln1393"> </a>
<a name="ln1394">    return mon;</a>
<a name="ln1395">}</a>
<a name="ln1396"> </a>
<a name="ln1397">void shadow_monster_reset(monster *mon)</a>
<a name="ln1398">{</a>
<a name="ln1399">    if (mon-&gt;inv[MSLOT_WEAPON] != NON_ITEM)</a>
<a name="ln1400">        destroy_item(mon-&gt;inv[MSLOT_WEAPON]);</a>
<a name="ln1401">    // in case the shadow unwields for some reason, e.g. you clumsily bash with</a>
<a name="ln1402">    // a ranged weapon:</a>
<a name="ln1403">    if (mon-&gt;inv[MSLOT_ALT_WEAPON] != NON_ITEM)</a>
<a name="ln1404">        destroy_item(mon-&gt;inv[MSLOT_ALT_WEAPON]);</a>
<a name="ln1405">    if (mon-&gt;inv[MSLOT_MISSILE] != NON_ITEM)</a>
<a name="ln1406">        destroy_item(mon-&gt;inv[MSLOT_MISSILE]);</a>
<a name="ln1407"> </a>
<a name="ln1408">    mon-&gt;reset();</a>
<a name="ln1409">}</a>
<a name="ln1410"> </a>
<a name="ln1411">/**</a>
<a name="ln1412"> * Check if the player is in melee range of the target.</a>
<a name="ln1413"> *</a>
<a name="ln1414"> * Certain effects, e.g. distortion blink, can cause monsters to leave melee</a>
<a name="ln1415"> * range between the initial hit &amp; the shadow mimic.</a>
<a name="ln1416"> *</a>
<a name="ln1417"> * XXX: refactor this with attack/fight code!</a>
<a name="ln1418"> *</a>
<a name="ln1419"> * @param target    The creature to be struck.</a>
<a name="ln1420"> * @return          Whether the player is melee range of the target, using</a>
<a name="ln1421"> *                  their current weapon.</a>
<a name="ln1422"> */</a>
<a name="ln1423">static bool _in_melee_range(actor* target)</a>
<a name="ln1424">{</a>
<a name="ln1425">    const int dist = (you.pos() - target-&gt;pos()).rdist();</a>
<a name="ln1426">    return dist &lt;= you.reach_range();</a>
<a name="ln1427">}</a>
<a name="ln1428"> </a>
<a name="ln1429">void dithmenos_shadow_melee(actor* target)</a>
<a name="ln1430">{</a>
<a name="ln1431">    if (!target</a>
<a name="ln1432">        || !target-&gt;alive()</a>
<a name="ln1433">        || !_in_melee_range(target)</a>
<a name="ln1434">        || !_shadow_acts(false))</a>
<a name="ln1435">    {</a>
<a name="ln1436">        return;</a>
<a name="ln1437">    }</a>
<a name="ln1438"> </a>
<a name="ln1439">    monster* mon = shadow_monster();</a>
<a name="ln1440">    if (!mon)</a>
<a name="ln1441">        return;</a>
<a name="ln1442"> </a>
<a name="ln1443">    mon-&gt;target     = target-&gt;pos();</a>
<a name="ln1444">    mon-&gt;foe        = target-&gt;mindex();</a>
<a name="ln1445"> </a>
<a name="ln1446">    fight_melee(mon, target);</a>
<a name="ln1447"> </a>
<a name="ln1448">    shadow_monster_reset(mon);</a>
<a name="ln1449">}</a>
<a name="ln1450"> </a>
<a name="ln1451">void dithmenos_shadow_throw(const dist &amp;d, const item_def &amp;item)</a>
<a name="ln1452">{</a>
<a name="ln1453">    ASSERT(d.isValid);</a>
<a name="ln1454">    if (!_shadow_acts(false))</a>
<a name="ln1455">        return;</a>
<a name="ln1456"> </a>
<a name="ln1457">    monster* mon = shadow_monster();</a>
<a name="ln1458">    if (!mon)</a>
<a name="ln1459">        return;</a>
<a name="ln1460"> </a>
<a name="ln1461">    int ammo_index = get_mitm_slot(10);</a>
<a name="ln1462">    if (ammo_index != NON_ITEM)</a>
<a name="ln1463">    {</a>
<a name="ln1464">        item_def&amp; new_item = mitm[ammo_index];</a>
<a name="ln1465">        new_item.base_type = item.base_type;</a>
<a name="ln1466">        new_item.sub_type  = item.sub_type;</a>
<a name="ln1467">        new_item.quantity  = 1;</a>
<a name="ln1468">        new_item.rnd = 1;</a>
<a name="ln1469">        new_item.flags    |= ISFLAG_SUMMONED;</a>
<a name="ln1470">        mon-&gt;inv[MSLOT_MISSILE] = ammo_index;</a>
<a name="ln1471"> </a>
<a name="ln1472">        mon-&gt;target = clamp_in_bounds(d.target);</a>
<a name="ln1473"> </a>
<a name="ln1474">        bolt beem;</a>
<a name="ln1475">        beem.set_target(d);</a>
<a name="ln1476">        setup_monster_throw_beam(mon, beem);</a>
<a name="ln1477">        beem.item = &amp;mitm[mon-&gt;inv[MSLOT_MISSILE]];</a>
<a name="ln1478">        mons_throw(mon, beem, mon-&gt;inv[MSLOT_MISSILE]);</a>
<a name="ln1479">    }</a>
<a name="ln1480"> </a>
<a name="ln1481">    shadow_monster_reset(mon);</a>
<a name="ln1482">}</a>
<a name="ln1483"> </a>
<a name="ln1484">void dithmenos_shadow_spell(bolt* orig_beam, spell_type spell)</a>
<a name="ln1485">{</a>
<a name="ln1486">    if (!orig_beam)</a>
<a name="ln1487">        return;</a>
<a name="ln1488"> </a>
<a name="ln1489">    const coord_def target = orig_beam-&gt;target;</a>
<a name="ln1490"> </a>
<a name="ln1491">    if (orig_beam-&gt;target.origin()</a>
<a name="ln1492">        || (orig_beam-&gt;is_enchantment() &amp;&amp; !is_valid_mon_spell(spell))</a>
<a name="ln1493">        || orig_beam-&gt;flavour == BEAM_ENSLAVE</a>
<a name="ln1494">           &amp;&amp; monster_at(target) &amp;&amp; monster_at(target)-&gt;friendly()</a>
<a name="ln1495">        || !_shadow_acts(true))</a>
<a name="ln1496">    {</a>
<a name="ln1497">        return;</a>
<a name="ln1498">    }</a>
<a name="ln1499"> </a>
<a name="ln1500">    monster* mon = shadow_monster();</a>
<a name="ln1501">    if (!mon)</a>
<a name="ln1502">        return;</a>
<a name="ln1503"> </a>
<a name="ln1504">    // Don't let shadow spells get too powerful.</a>
<a name="ln1505">    mon-&gt;set_hit_dice(max(1,</a>
<a name="ln1506">                          min(3 * spell_difficulty(spell),</a>
<a name="ln1507">                              you.experience_level) / 2));</a>
<a name="ln1508"> </a>
<a name="ln1509">    mon-&gt;target = clamp_in_bounds(target);</a>
<a name="ln1510">    if (actor_at(target))</a>
<a name="ln1511">        mon-&gt;foe = actor_at(target)-&gt;mindex();</a>
<a name="ln1512"> </a>
<a name="ln1513">    spell_type shadow_spell = spell;</a>
<a name="ln1514">    if (!orig_beam-&gt;is_enchantment())</a>
<a name="ln1515">    {</a>
<a name="ln1516">        shadow_spell = (orig_beam-&gt;pierce) ? SPELL_SHADOW_BOLT</a>
<a name="ln1517">                                           : SPELL_SHADOW_SHARD;</a>
<a name="ln1518">    }</a>
<a name="ln1519"> </a>
<a name="ln1520">    bolt beem;</a>
<a name="ln1521">    beem.target = target;</a>
<a name="ln1522">    beem.aimed_at_spot = orig_beam-&gt;aimed_at_spot;</a>
<a name="ln1523"> </a>
<a name="ln1524">    mprf(MSGCH_FRIEND_SPELL, &quot;%s mimicks your spell!&quot;,</a>
<a name="ln1525">         mon-&gt;name(DESC_THE).c_str());</a>
<a name="ln1526">    mons_cast(mon, beem, shadow_spell, MON_SPELL_WIZARD, false);</a>
<a name="ln1527"> </a>
<a name="ln1528">    shadow_monster_reset(mon);</a>
<a name="ln1529">}</a>
<a name="ln1530"> </a>
<a name="ln1531">static void _wu_jian_trigger_serpents_lash(const coord_def&amp; old_pos,</a>
<a name="ln1532">                                           bool wall_jump)</a>
<a name="ln1533">{</a>
<a name="ln1534">    if (you.attribute[ATTR_SERPENTS_LASH] == 0)</a>
<a name="ln1535">       return;</a>
<a name="ln1536"> </a>
<a name="ln1537">    if (wall_jump &amp;&amp; you.attribute[ATTR_SERPENTS_LASH] == 1)</a>
<a name="ln1538">    {</a>
<a name="ln1539">        // No turn manipulation, since we are only refunding half a wall jump's</a>
<a name="ln1540">        // time (the walk speed modifier for this special case is already</a>
<a name="ln1541">        // factored in main.cc)</a>
<a name="ln1542">        you.attribute[ATTR_SERPENTS_LASH] = 0;</a>
<a name="ln1543">    }</a>
<a name="ln1544">    else</a>
<a name="ln1545">    {</a>
<a name="ln1546">        you.turn_is_over = false;</a>
<a name="ln1547">        you.elapsed_time_at_last_input = you.elapsed_time;</a>
<a name="ln1548">        you.attribute[ATTR_SERPENTS_LASH] -= wall_jump ? 2 : 1;</a>
<a name="ln1549">        you.redraw_status_lights = true;</a>
<a name="ln1550">        update_turn_count();</a>
<a name="ln1551">    }</a>
<a name="ln1552"> </a>
<a name="ln1553">    if (you.attribute[ATTR_SERPENTS_LASH] == 0)</a>
<a name="ln1554">    {</a>
<a name="ln1555">        you.increase_duration(DUR_EXHAUSTED, 12 + random2(5));</a>
<a name="ln1556">        mpr(&quot;Your supernatural speed expires.&quot;);</a>
<a name="ln1557">    }</a>
<a name="ln1558"> </a>
<a name="ln1559">    if (!cell_is_solid(old_pos))</a>
<a name="ln1560">        check_place_cloud(CLOUD_DUST, old_pos, 2 + random2(3) , &amp;you, 1, -1);</a>
<a name="ln1561">}</a>
<a name="ln1562"> </a>
<a name="ln1563">static void _wu_jian_increment_heavenly_storm()</a>
<a name="ln1564">{</a>
<a name="ln1565">    int storm = you.props[WU_JIAN_HEAVENLY_STORM_KEY].get_int();</a>
<a name="ln1566">    if (storm &lt; WU_JIAN_HEAVENLY_STORM_MAX)</a>
<a name="ln1567">        you.props[WU_JIAN_HEAVENLY_STORM_KEY].get_int()++;</a>
<a name="ln1568">}</a>
<a name="ln1569"> </a>
<a name="ln1570">void wu_jian_heaven_tick()</a>
<a name="ln1571">{</a>
<a name="ln1572">    for (radius_iterator ai(you.pos(), 2, C_SQUARE, LOS_SOLID); ai; ++ai)</a>
<a name="ln1573">        if (!cell_is_solid(*ai))</a>
<a name="ln1574">            place_cloud(CLOUD_GOLD_DUST, *ai, 5 + random2(5), &amp;you);</a>
<a name="ln1575"> </a>
<a name="ln1576">    noisy(15, you.pos());</a>
<a name="ln1577">}</a>
<a name="ln1578"> </a>
<a name="ln1579">void wu_jian_decrement_heavenly_storm()</a>
<a name="ln1580">{</a>
<a name="ln1581">    int storm = you.props[WU_JIAN_HEAVENLY_STORM_KEY].get_int();</a>
<a name="ln1582"> </a>
<a name="ln1583">    if (storm &gt; 1)</a>
<a name="ln1584">    {</a>
<a name="ln1585">        you.props[WU_JIAN_HEAVENLY_STORM_KEY].get_int()--;</a>
<a name="ln1586">        you.set_duration(DUR_HEAVENLY_STORM, random_range(2, 3));</a>
<a name="ln1587">    }</a>
<a name="ln1588">    else</a>
<a name="ln1589">        wu_jian_end_heavenly_storm();</a>
<a name="ln1590">}</a>
<a name="ln1591"> </a>
<a name="ln1592">void wu_jian_end_heavenly_storm()</a>
<a name="ln1593">{</a>
<a name="ln1594">    you.props.erase(WU_JIAN_HEAVENLY_STORM_KEY);</a>
<a name="ln1595">    you.duration[DUR_HEAVENLY_STORM] = 0;</a>
<a name="ln1596">    invalidate_agrid(true);</a>
<a name="ln1597">    mprf(MSGCH_GOD, &quot;The heavenly storm settles.&quot;);</a>
<a name="ln1598">}</a>
<a name="ln1599"> </a>
<a name="ln1600">bool wu_jian_has_momentum(wu_jian_attack_type attack_type)</a>
<a name="ln1601">{</a>
<a name="ln1602">    return you.attribute[ATTR_SERPENTS_LASH]</a>
<a name="ln1603">           &amp;&amp; attack_type != WU_JIAN_ATTACK_NONE</a>
<a name="ln1604">           &amp;&amp; attack_type != WU_JIAN_ATTACK_TRIGGERED_AUX;</a>
<a name="ln1605">}</a>
<a name="ln1606"> </a>
<a name="ln1607">static bool _can_attack_martial(const monster* mons)</a>
<a name="ln1608">{</a>
<a name="ln1609">    return !(mons-&gt;wont_attack()</a>
<a name="ln1610">             || mons_is_firewood(*mons)</a>
<a name="ln1611">             || mons_is_projectile(mons-&gt;type)</a>
<a name="ln1612">             || !you.can_see(*mons));</a>
<a name="ln1613">}</a>
<a name="ln1614"> </a>
<a name="ln1615">// A mismatch between attack speed and move speed may cause any particular</a>
<a name="ln1616">// martial attack to be doubled, tripled, or not happen at all. Given enough</a>
<a name="ln1617">// time moving, you would have made the same amount of attacks as tabbing.</a>
<a name="ln1618">static int _wu_jian_number_of_attacks(bool wall_jump)</a>
<a name="ln1619">{</a>
<a name="ln1620">    // Under the effect of serpent's lash, move delay is normalized to</a>
<a name="ln1621">    // 10 aut for every character, to avoid punishing fast races.</a>
<a name="ln1622">    const int move_delay = you.attribute[ATTR_SERPENTS_LASH]</a>
<a name="ln1623">                           ? 100</a>
<a name="ln1624">                           : player_movement_speed() * player_speed();</a>
<a name="ln1625"> </a>
<a name="ln1626">    int attack_delay;</a>
<a name="ln1627"> </a>
<a name="ln1628">    {</a>
<a name="ln1629">        // attack_delay() is dependent on you.time_taken, which won't be set</a>
<a name="ln1630">        // appropriately during a movement turn. This temporarily resets</a>
<a name="ln1631">        // you.time_taken to the initial value (see `_prep_input`) used for</a>
<a name="ln1632">        // basic, simple, melee attacks.</a>
<a name="ln1633">        // TODO: can `attack_delay` be changed to not depend on you.time_taken?</a>
<a name="ln1634">        unwind_var&lt;int&gt; reset_speed(you.time_taken, player_speed());</a>
<a name="ln1635">        attack_delay = you.attack_delay().roll();</a>
<a name="ln1636">    }</a>
<a name="ln1637"> </a>
<a name="ln1638">    return div_rand_round(wall_jump ? 2 * move_delay : move_delay,</a>
<a name="ln1639">                          attack_delay * BASELINE_DELAY);</a>
<a name="ln1640">}</a>
<a name="ln1641"> </a>
<a name="ln1642">static bool _wu_jian_lunge(const coord_def&amp; old_pos)</a>
<a name="ln1643">{</a>
<a name="ln1644">    coord_def lunge_direction = (you.pos() - old_pos).sgn();</a>
<a name="ln1645">    coord_def potential_target = you.pos() + lunge_direction;</a>
<a name="ln1646">    monster* mons = monster_at(potential_target);</a>
<a name="ln1647"> </a>
<a name="ln1648">    if (!mons || !_can_attack_martial(mons) || !mons-&gt;alive())</a>
<a name="ln1649">        return false;</a>
<a name="ln1650"> </a>
<a name="ln1651">    if (you.props.exists(WU_JIAN_HEAVENLY_STORM_KEY))</a>
<a name="ln1652">        _wu_jian_increment_heavenly_storm();</a>
<a name="ln1653"> </a>
<a name="ln1654">    you.apply_berserk_penalty = false;</a>
<a name="ln1655"> </a>
<a name="ln1656">    const int number_of_attacks = _wu_jian_number_of_attacks(false);</a>
<a name="ln1657"> </a>
<a name="ln1658">    if (number_of_attacks == 0)</a>
<a name="ln1659">    {</a>
<a name="ln1660">        mprf(&quot;You lunge at %s, but your attack speed is too slow for a blow &quot;</a>
<a name="ln1661">             &quot;to land.&quot;, mons-&gt;name(DESC_THE).c_str());</a>
<a name="ln1662">        return false;</a>
<a name="ln1663">    }</a>
<a name="ln1664">    else</a>
<a name="ln1665">    {</a>
<a name="ln1666">        mprf(&quot;You lunge%s at %s%s.&quot;,</a>
<a name="ln1667">             wu_jian_has_momentum(WU_JIAN_ATTACK_LUNGE) ?</a>
<a name="ln1668">                 &quot; with incredible momentum&quot; : &quot;&quot;,</a>
<a name="ln1669">             mons-&gt;name(DESC_THE).c_str(),</a>
<a name="ln1670">             number_of_attacks &gt; 1 ? &quot;, in a flurry of attacks&quot; : &quot;&quot;);</a>
<a name="ln1671">    }</a>
<a name="ln1672"> </a>
<a name="ln1673">    count_action(CACT_INVOKE, ABIL_WU_JIAN_LUNGE);</a>
<a name="ln1674"> </a>
<a name="ln1675">    for (int i = 0; i &lt; number_of_attacks; i++)</a>
<a name="ln1676">    {</a>
<a name="ln1677">        if (!mons-&gt;alive())</a>
<a name="ln1678">            break;</a>
<a name="ln1679">        melee_attack lunge(&amp;you, mons);</a>
<a name="ln1680">        lunge.wu_jian_attack = WU_JIAN_ATTACK_LUNGE;</a>
<a name="ln1681">        lunge.attack();</a>
<a name="ln1682">    }</a>
<a name="ln1683"> </a>
<a name="ln1684">    return true;</a>
<a name="ln1685">}</a>
<a name="ln1686"> </a>
<a name="ln1687">// Monsters adjacent to the given pos that are valid targets for whirlwind.</a>
<a name="ln1688">static vector&lt;monster*&gt; _get_whirlwind_targets(coord_def pos)</a>
<a name="ln1689">{</a>
<a name="ln1690">    vector&lt;monster*&gt; targets;</a>
<a name="ln1691">    for (adjacent_iterator ai(pos, true); ai; ++ai)</a>
<a name="ln1692">        if (monster_at(*ai) &amp;&amp; _can_attack_martial(monster_at(*ai)))</a>
<a name="ln1693">            targets.push_back(monster_at(*ai));</a>
<a name="ln1694">    sort(targets.begin(), targets.end());</a>
<a name="ln1695">    return targets;</a>
<a name="ln1696">}</a>
<a name="ln1697"> </a>
<a name="ln1698">static bool _wu_jian_whirlwind(const coord_def&amp; old_pos)</a>
<a name="ln1699">{</a>
<a name="ln1700">    bool did_at_least_one_attack = false;</a>
<a name="ln1701"> </a>
<a name="ln1702">    const vector&lt;monster*&gt; targets = _get_whirlwind_targets(you.pos());</a>
<a name="ln1703">    if (targets.empty())</a>
<a name="ln1704">        return did_at_least_one_attack;</a>
<a name="ln1705"> </a>
<a name="ln1706">    const vector&lt;monster*&gt; old_targets = _get_whirlwind_targets(old_pos);</a>
<a name="ln1707">    vector&lt;monster*&gt; common_targets;</a>
<a name="ln1708">    set_intersection(targets.begin(), targets.end(),</a>
<a name="ln1709">                     old_targets.begin(), old_targets.end(),</a>
<a name="ln1710">                     back_inserter(common_targets));</a>
<a name="ln1711"> </a>
<a name="ln1712">    for (auto mons : common_targets)</a>
<a name="ln1713">    {</a>
<a name="ln1714">        if (!mons-&gt;alive())</a>
<a name="ln1715">            continue;</a>
<a name="ln1716"> </a>
<a name="ln1717">        if (you.props.exists(WU_JIAN_HEAVENLY_STORM_KEY))</a>
<a name="ln1718">            _wu_jian_increment_heavenly_storm();</a>
<a name="ln1719"> </a>
<a name="ln1720">        you.apply_berserk_penalty = false;</a>
<a name="ln1721"> </a>
<a name="ln1722">        const int number_of_attacks = _wu_jian_number_of_attacks(false);</a>
<a name="ln1723">        if (number_of_attacks == 0)</a>
<a name="ln1724">        {</a>
<a name="ln1725">            mprf(&quot;You spin to attack %s, but your attack speed is too slow for &quot;</a>
<a name="ln1726">                 &quot;a blow to land.&quot;, mons-&gt;name(DESC_THE).c_str());</a>
<a name="ln1727">            continue;</a>
<a name="ln1728">        }</a>
<a name="ln1729">        else</a>
<a name="ln1730">        {</a>
<a name="ln1731">            mprf(&quot;You spin and attack %s%s%s.&quot;,</a>
<a name="ln1732">                 mons-&gt;name(DESC_THE).c_str(),</a>
<a name="ln1733">                 number_of_attacks &gt; 1 ? &quot; repeatedly&quot; : &quot;&quot;,</a>
<a name="ln1734">                 wu_jian_has_momentum(WU_JIAN_ATTACK_WHIRLWIND) ?</a>
<a name="ln1735">                     &quot;, with incredible momentum&quot; : &quot;&quot;);</a>
<a name="ln1736">        }</a>
<a name="ln1737"> </a>
<a name="ln1738">        count_action(CACT_INVOKE, ABIL_WU_JIAN_WHIRLWIND);</a>
<a name="ln1739"> </a>
<a name="ln1740">        for (int i = 0; i &lt; number_of_attacks; i++)</a>
<a name="ln1741">        {</a>
<a name="ln1742">            if (!mons-&gt;alive())</a>
<a name="ln1743">                break;</a>
<a name="ln1744">            melee_attack whirlwind(&amp;you, mons);</a>
<a name="ln1745">            whirlwind.wu_jian_attack = WU_JIAN_ATTACK_WHIRLWIND;</a>
<a name="ln1746">            whirlwind.wu_jian_number_of_targets = common_targets.size();</a>
<a name="ln1747">            whirlwind.attack();</a>
<a name="ln1748">            if (!did_at_least_one_attack)</a>
<a name="ln1749">              did_at_least_one_attack = true;</a>
<a name="ln1750">        }</a>
<a name="ln1751">    }</a>
<a name="ln1752"> </a>
<a name="ln1753">    return did_at_least_one_attack;</a>
<a name="ln1754">}</a>
<a name="ln1755"> </a>
<a name="ln1756">static bool _wu_jian_trigger_martial_arts(const coord_def&amp; old_pos)</a>
<a name="ln1757">{</a>
<a name="ln1758">    bool did_wu_jian_attacks = false;</a>
<a name="ln1759"> </a>
<a name="ln1760">    if (you.pos() == old_pos || you.duration[DUR_CONF])</a>
<a name="ln1761">        return did_wu_jian_attacks;</a>
<a name="ln1762"> </a>
<a name="ln1763">    if (have_passive(passive_t::wu_jian_lunge))</a>
<a name="ln1764">        did_wu_jian_attacks = _wu_jian_lunge(old_pos);</a>
<a name="ln1765"> </a>
<a name="ln1766">    if (have_passive(passive_t::wu_jian_whirlwind))</a>
<a name="ln1767">        did_wu_jian_attacks |= _wu_jian_whirlwind(old_pos);</a>
<a name="ln1768"> </a>
<a name="ln1769">    return did_wu_jian_attacks;</a>
<a name="ln1770">}</a>
<a name="ln1771"> </a>
<a name="ln1772">void wu_jian_wall_jump_effects()</a>
<a name="ln1773">{</a>
<a name="ln1774">    vector&lt;monster*&gt; targets;</a>
<a name="ln1775">    for (adjacent_iterator ai(you.pos(), true); ai; ++ai)</a>
<a name="ln1776">    {</a>
<a name="ln1777">        monster* target = monster_at(*ai);</a>
<a name="ln1778">        if (target &amp;&amp; _can_attack_martial(target) &amp;&amp; target-&gt;alive())</a>
<a name="ln1779">            targets.push_back(target);</a>
<a name="ln1780"> </a>
<a name="ln1781">        if (!cell_is_solid(*ai))</a>
<a name="ln1782">            check_place_cloud(CLOUD_DUST, *ai, 1 + random2(3) , &amp;you, 0, -1);</a>
<a name="ln1783">    }</a>
<a name="ln1784"> </a>
<a name="ln1785">    for (auto target : targets)</a>
<a name="ln1786">    {</a>
<a name="ln1787">        if (!target-&gt;alive())</a>
<a name="ln1788">            continue;</a>
<a name="ln1789"> </a>
<a name="ln1790">        if (you.props.exists(WU_JIAN_HEAVENLY_STORM_KEY))</a>
<a name="ln1791">            _wu_jian_increment_heavenly_storm();</a>
<a name="ln1792"> </a>
<a name="ln1793">        you.apply_berserk_penalty = false;</a>
<a name="ln1794"> </a>
<a name="ln1795">        // Twice the attacks as Wall Jump spends twice the time</a>
<a name="ln1796">        const int number_of_attacks = _wu_jian_number_of_attacks(true);</a>
<a name="ln1797">        if (number_of_attacks == 0)</a>
<a name="ln1798">        {</a>
<a name="ln1799">            mprf(&quot;You attack %s from above, but your attack speed is too slow&quot;</a>
<a name="ln1800">                 &quot; for a blow to land.&quot;, target-&gt;name(DESC_THE).c_str());</a>
<a name="ln1801">            continue;</a>
<a name="ln1802">        }</a>
<a name="ln1803">        else</a>
<a name="ln1804">        {</a>
<a name="ln1805">            mprf(&quot;You %sattack %s from above%s.&quot;,</a>
<a name="ln1806">                 number_of_attacks &gt; 1 ? &quot;repeatedly &quot; : &quot;&quot;,</a>
<a name="ln1807">                 target-&gt;name(DESC_THE).c_str(),</a>
<a name="ln1808">                 wu_jian_has_momentum(WU_JIAN_ATTACK_WALL_JUMP) ?</a>
<a name="ln1809">                     &quot;, with incredible momentum&quot; : &quot;&quot;);</a>
<a name="ln1810">        }</a>
<a name="ln1811"> </a>
<a name="ln1812">        for (int i = 0; i &lt; number_of_attacks; i++)</a>
<a name="ln1813">        {</a>
<a name="ln1814">            if (!target-&gt;alive())</a>
<a name="ln1815">                break;</a>
<a name="ln1816"> </a>
<a name="ln1817">            melee_attack aerial(&amp;you, target);</a>
<a name="ln1818">            aerial.wu_jian_attack = WU_JIAN_ATTACK_WALL_JUMP;</a>
<a name="ln1819">            aerial.wu_jian_number_of_targets = targets.size();</a>
<a name="ln1820">            aerial.attack();</a>
<a name="ln1821">        }</a>
<a name="ln1822">    }</a>
<a name="ln1823">}</a>
<a name="ln1824"> </a>
<a name="ln1825">bool wu_jian_post_move_effects(bool did_wall_jump,</a>
<a name="ln1826">                               const coord_def&amp; initial_position)</a>
<a name="ln1827">{</a>
<a name="ln1828">    bool did_wu_jian_attacks = false;</a>
<a name="ln1829"> </a>
<a name="ln1830">    if (!did_wall_jump)</a>
<a name="ln1831">        did_wu_jian_attacks = _wu_jian_trigger_martial_arts(initial_position);</a>
<a name="ln1832"> </a>
<a name="ln1833">    if (you.turn_is_over)</a>
<a name="ln1834">        _wu_jian_trigger_serpents_lash(initial_position, did_wall_jump);</a>
<a name="ln1835"> </a>
<a name="ln1836">    return did_wu_jian_attacks;</a>
<a name="ln1837">}</a>
<a name="ln1838"> </a>
<a name="ln1839">/**</a>
<a name="ln1840"> * check if the monster in this cell exists and is a valid target for Uskayaw</a>
<a name="ln1841"> */</a>
<a name="ln1842">static int _check_for_uskayaw_targets(coord_def where)</a>
<a name="ln1843">{</a>
<a name="ln1844">    if (!cell_has_valid_target(where))</a>
<a name="ln1845">        return 0;</a>
<a name="ln1846">    monster* mons = monster_at(where);</a>
<a name="ln1847">    ASSERT(mons);</a>
<a name="ln1848"> </a>
<a name="ln1849">    if (mons_is_firewood(*mons))</a>
<a name="ln1850">        return 0;</a>
<a name="ln1851"> </a>
<a name="ln1852">    return 1;</a>
<a name="ln1853">}</a>
<a name="ln1854"> </a>
<a name="ln1855">/**</a>
<a name="ln1856"> * Paralyse the monster in this cell, assuming one exists.</a>
<a name="ln1857"> *</a>
<a name="ln1858"> * Duration increases with invocations and experience level, and decreases</a>
<a name="ln1859"> * with target HD. The duration is pretty low, maxing out at 40 AUT.</a>
<a name="ln1860"> */</a>
<a name="ln1861">static int _prepare_audience(coord_def where)</a>
<a name="ln1862">{</a>
<a name="ln1863">    if (!_check_for_uskayaw_targets(where))</a>
<a name="ln1864">        return 0;</a>
<a name="ln1865"> </a>
<a name="ln1866">    monster* mons = monster_at(where);</a>
<a name="ln1867"> </a>
<a name="ln1868">    int power =  max(1, random2(1 + you.skill(SK_INVOCATIONS, 2))</a>
<a name="ln1869">                 + you.experience_level - mons-&gt;get_hit_dice());</a>
<a name="ln1870">    int duration = min(max(10, 5 + power), 40);</a>
<a name="ln1871">    mons-&gt;add_ench(mon_enchant(ENCH_PARALYSIS, 1, &amp;you, duration));</a>
<a name="ln1872"> </a>
<a name="ln1873">    return 1;</a>
<a name="ln1874">}</a>
<a name="ln1875"> </a>
<a name="ln1876">/**</a>
<a name="ln1877"> * On hitting *** piety, all the monsters are paralysed by their appreciation</a>
<a name="ln1878"> * for your dance.</a>
<a name="ln1879"> */</a>
<a name="ln1880">void uskayaw_prepares_audience()</a>
<a name="ln1881">{</a>
<a name="ln1882">    int count = apply_area_visible(_check_for_uskayaw_targets, you.pos());</a>
<a name="ln1883">    if (count &gt; 0)</a>
<a name="ln1884">    {</a>
<a name="ln1885">        simple_god_message(&quot; prepares the audience for your solo!&quot;);</a>
<a name="ln1886">        apply_area_visible(_prepare_audience, you.pos());</a>
<a name="ln1887"> </a>
<a name="ln1888">        // Increment a delay timer to prevent players from spamming this ability</a>
<a name="ln1889">        // via piety loss and gain. Timer is in AUT.</a>
<a name="ln1890">        you.props[USKAYAW_AUDIENCE_TIMER] = 300 + random2(201);</a>
<a name="ln1891">    }</a>
<a name="ln1892">    else // Reset the timer because we didn't actually execute.</a>
<a name="ln1893">        you.props[USKAYAW_AUDIENCE_TIMER] = 0;</a>
<a name="ln1894">}</a>
<a name="ln1895"> </a>
<a name="ln1896">/**</a>
<a name="ln1897"> * Apply pain bond to the monster in this cell.</a>
<a name="ln1898"> */</a>
<a name="ln1899">static int _bond_audience(coord_def where)</a>
<a name="ln1900">{</a>
<a name="ln1901">    if (!_check_for_uskayaw_targets(where))</a>
<a name="ln1902">        return 0;</a>
<a name="ln1903"> </a>
<a name="ln1904">    monster* mons = monster_at(where);</a>
<a name="ln1905"> </a>
<a name="ln1906">    // Don't pain bond monsters that aren't invested in fighting the player</a>
<a name="ln1907">    if (mons-&gt;wont_attack())</a>
<a name="ln1908">        return 0;</a>
<a name="ln1909"> </a>
<a name="ln1910">    int power = you.skill(SK_INVOCATIONS, 7) + you.experience_level</a>
<a name="ln1911">                 - mons-&gt;get_hit_dice();</a>
<a name="ln1912">    int duration = 20 + random2avg(power, 2);</a>
<a name="ln1913">    mons-&gt;add_ench(mon_enchant(ENCH_PAIN_BOND, 1, &amp;you, duration));</a>
<a name="ln1914"> </a>
<a name="ln1915">    return 1;</a>
<a name="ln1916">}</a>
<a name="ln1917"> </a>
<a name="ln1918">/**</a>
<a name="ln1919"> * On hitting **** piety, all the monsters are pain bonded.</a>
<a name="ln1920"> */</a>
<a name="ln1921">void uskayaw_bonds_audience()</a>
<a name="ln1922">{</a>
<a name="ln1923">    int count = apply_area_visible(_check_for_uskayaw_targets, you.pos());</a>
<a name="ln1924">    if (count &gt; 1)</a>
<a name="ln1925">    {</a>
<a name="ln1926">        simple_god_message(&quot; links your audience in an emotional bond!&quot;);</a>
<a name="ln1927">        apply_area_visible(_bond_audience, you.pos());</a>
<a name="ln1928"> </a>
<a name="ln1929">        // Increment a delay timer to prevent players from spamming this ability</a>
<a name="ln1930">        // via piety loss and gain. Timer is in AUT.</a>
<a name="ln1931">        you.props[USKAYAW_BOND_TIMER] = 300 + random2(201);</a>
<a name="ln1932">    }</a>
<a name="ln1933">    else // Reset the timer because we didn't actually execute.</a>
<a name="ln1934">        you.props[USKAYAW_BOND_TIMER] = 0;</a>
<a name="ln1935">}</a>

</code></pre>
<div class="balloon" rel="1510"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v1051/" target="_blank">V1051</a> Consider checking for misprints. It's possible that the 'mon->target' should be used inside 'actor_at' function.</p></div>

<link rel="stylesheet" href="highlight.css">
<script src="highlight.pack.js"></script>
<script src="highlightjs-line-numbers.js"></script>
<script>hljs.initHighlightingOnLoad();</script>
<script>hljs.initLineNumbersOnLoad();</script>
<script>
  $(document).ready(function() {
      $('.balloon').each(function () {
          var bl = $(this);
          var line = bl.attr('rel');
          var text = $('a[name="ln'+line+'"]').text();

          var space_count = 0;
          for(var i = 0; i<text.length; i++){
              var char = text[i];
              if((char !== ' ')&&(char !== '\t'))break;
              if(char === '\t')space_count++;
              space_count++;
          }

          bl.css('margin-left', space_count*8);
          $('a[name="ln'+line+'"]').after(bl);
      });

      window.location = window.location;
  });
</script>
</body>
</html>
