
<html>
<head>

  <meta http-equiv="Content-Type" content="text/html; charset=US-ASCII" />
  <title>tilereg-dgn.cc</title>

  <link rel="stylesheet" href="../style.css"/>
  <script src="../jquery-3.2.1.min.js"></script>
</head>
<body>

<pre><code class = "cpp">
<a name="ln1">#include &quot;AppHdr.h&quot;</a>
<a name="ln2"> </a>
<a name="ln3">#ifdef USE_TILE_LOCAL</a>
<a name="ln4"> </a>
<a name="ln5">#include &quot;tilereg-dgn.h&quot;</a>
<a name="ln6"> </a>
<a name="ln7">#include &lt;algorithm&gt; // any_of</a>
<a name="ln8"> </a>
<a name="ln9">#include &quot;cio.h&quot;</a>
<a name="ln10">#include &quot;cloud.h&quot;</a>
<a name="ln11">#include &quot;command.h&quot;</a>
<a name="ln12">#include &quot;coord.h&quot;</a>
<a name="ln13">#include &quot;describe.h&quot;</a>
<a name="ln14">#include &quot;directn.h&quot;</a>
<a name="ln15">#include &quot;dgn-height.h&quot;</a>
<a name="ln16">#include &quot;env.h&quot;</a>
<a name="ln17">#include &quot;invent.h&quot;</a>
<a name="ln18">#include &quot;item-prop.h&quot;</a>
<a name="ln19">#include &quot;items.h&quot;</a>
<a name="ln20">#include &quot;jobs.h&quot;</a>
<a name="ln21">#include &quot;libutil.h&quot;</a>
<a name="ln22">#include &quot;macro.h&quot;</a>
<a name="ln23">#include &quot;message.h&quot;</a>
<a name="ln24">#include &quot;mon-util.h&quot;</a>
<a name="ln25">#include &quot;nearby-danger.h&quot;</a>
<a name="ln26">#include &quot;options.h&quot;</a>
<a name="ln27">#include &quot;output.h&quot;</a>
<a name="ln28">#include &quot;prompt.h&quot;</a>
<a name="ln29">#include &quot;religion.h&quot;</a>
<a name="ln30">#include &quot;spl-book.h&quot;</a>
<a name="ln31">#include &quot;spl-cast.h&quot;</a>
<a name="ln32">#include &quot;stash.h&quot;</a>
<a name="ln33">#include &quot;stringutil.h&quot;</a>
<a name="ln34">#include &quot;terrain.h&quot;</a>
<a name="ln35">#include &quot;rltiles/tiledef-dngn.h&quot;</a>
<a name="ln36">#include &quot;rltiles/tiledef-icons.h&quot;</a>
<a name="ln37">#include &quot;rltiles/tiledef-main.h&quot;</a>
<a name="ln38">#include &quot;tilefont.h&quot;</a>
<a name="ln39">#include &quot;tilepick.h&quot;</a>
<a name="ln40">#include &quot;tiles-build-specific.h&quot;</a>
<a name="ln41">#include &quot;traps.h&quot;</a>
<a name="ln42">#include &quot;travel.h&quot;</a>
<a name="ln43">#include &quot;viewgeom.h&quot;</a>
<a name="ln44"> </a>
<a name="ln45">static VColour _flash_colours[NUM_TERM_COLOURS] =</a>
<a name="ln46">{</a>
<a name="ln47">    VColour(  0,   0,   0,   0), // BLACK (transparent)</a>
<a name="ln48">    VColour(  0,   0, 128, 100), // BLUE</a>
<a name="ln49">    VColour(  0, 128,   0, 100), // GREEN</a>
<a name="ln50">    VColour(  0, 128, 128, 100), // CYAN</a>
<a name="ln51">    VColour(128,   0,   0, 100), // RED</a>
<a name="ln52">    VColour(150,   0, 150, 100), // MAGENTA</a>
<a name="ln53">    VColour(165,  91,   0, 100), // BROWN</a>
<a name="ln54">    VColour( 50,  50,  50, 150), // LIGHTGRAY</a>
<a name="ln55">    VColour(  0,   0,   0, 150), // DARKGRAY</a>
<a name="ln56">    VColour( 64,  64, 255, 100), // LIGHTBLUE</a>
<a name="ln57">    VColour( 64, 255,  64, 100), // LIGHTGREEN</a>
<a name="ln58">    VColour(  0, 255, 255, 100), // LIGHTCYAN</a>
<a name="ln59">    VColour(255,  64,  64, 100), // LIGHTRED</a>
<a name="ln60">    VColour(255,  64, 255, 100), // LIGHTMAGENTA</a>
<a name="ln61">    VColour(150, 150,   0, 100), // YELLOW</a>
<a name="ln62">    VColour(255, 255, 255, 100), // WHITE</a>
<a name="ln63">};</a>
<a name="ln64"> </a>
<a name="ln65">DungeonRegion::DungeonRegion(const TileRegionInit &amp;init) :</a>
<a name="ln66">    TileRegion(init),</a>
<a name="ln67">    m_cx_to_gx(0),</a>
<a name="ln68">    m_cy_to_gy(0),</a>
<a name="ln69">    m_last_clicked_grid(coord_def()),</a>
<a name="ln70">    m_buf_dngn(init.im)</a>
<a name="ln71">{</a>
<a name="ln72">    for (int i = 0; i &lt; CURSOR_MAX; i++)</a>
<a name="ln73">        m_cursor[i] = NO_CURSOR;</a>
<a name="ln74">}</a>
<a name="ln75"> </a>
<a name="ln76">DungeonRegion::~DungeonRegion()</a>
<a name="ln77">{</a>
<a name="ln78">}</a>
<a name="ln79"> </a>
<a name="ln80">void DungeonRegion::load_dungeon(const crawl_view_buffer &amp;vbuf,</a>
<a name="ln81">                                 const coord_def &amp;gc)</a>
<a name="ln82">{</a>
<a name="ln83">    m_dirty = true;</a>
<a name="ln84"> </a>
<a name="ln85">    m_cx_to_gx = gc.x - mx / 2;</a>
<a name="ln86">    m_cy_to_gy = gc.y - my / 2;</a>
<a name="ln87"> </a>
<a name="ln88">    m_vbuf = vbuf;</a>
<a name="ln89"> </a>
<a name="ln90">    place_cursor(CURSOR_TUTORIAL, m_cursor[CURSOR_TUTORIAL]);</a>
<a name="ln91">}</a>
<a name="ln92"> </a>
<a name="ln93">void DungeonRegion::pack_cursor(cursor_type type, unsigned int tile)</a>
<a name="ln94">{</a>
<a name="ln95">    const coord_def &amp;gc = m_cursor[type];</a>
<a name="ln96">    if (gc == NO_CURSOR || !on_screen(gc))</a>
<a name="ln97">        return;</a>
<a name="ln98"> </a>
<a name="ln99">    const coord_def ep(gc.x - m_cx_to_gx, gc.y - m_cy_to_gy);</a>
<a name="ln100">    m_buf_dngn.add_icons_tile(tile, ep.x, ep.y);</a>
<a name="ln101">}</a>
<a name="ln102"> </a>
<a name="ln103">void DungeonRegion::pack_buffers()</a>
<a name="ln104">{</a>
<a name="ln105">    m_buf_dngn.clear();</a>
<a name="ln106">    m_buf_flash.clear();</a>
<a name="ln107"> </a>
<a name="ln108">    if (m_vbuf.empty())</a>
<a name="ln109">        return;</a>
<a name="ln110"> </a>
<a name="ln111">    coord_def m_vbuf_sz = m_vbuf.size();</a>
<a name="ln112">    ASSERT(m_vbuf_sz.x == crawl_view.viewsz.x);</a>
<a name="ln113">    ASSERT(m_vbuf_sz.y == crawl_view.viewsz.y);</a>
<a name="ln114"> </a>
<a name="ln115">    screen_cell_t *vbuf_cell = m_vbuf;</a>
<a name="ln116">    for (int y = 0; y &lt; crawl_view.viewsz.y; ++y)</a>
<a name="ln117">        for (int x = 0; x &lt; crawl_view.viewsz.x; ++x)</a>
<a name="ln118">        {</a>
<a name="ln119">            coord_def gc(x + m_cx_to_gx, y + m_cy_to_gy);</a>
<a name="ln120"> </a>
<a name="ln121">            if (map_bounds(gc))</a>
<a name="ln122">                pack_cell_overlays(coord_def(x, y), m_vbuf);</a>
<a name="ln123">            m_buf_dngn.add(vbuf_cell-&gt;tile, x, y);</a>
<a name="ln124"> </a>
<a name="ln125">            const int fcol = vbuf_cell-&gt;flash_colour;</a>
<a name="ln126">            if (fcol)</a>
<a name="ln127">                m_buf_flash.add(x, y, x + 1, y + 1, _flash_colours[fcol]);</a>
<a name="ln128"> </a>
<a name="ln129">            vbuf_cell++;</a>
<a name="ln130">        }</a>
<a name="ln131"> </a>
<a name="ln132">    pack_cursor(CURSOR_TUTORIAL, TILEI_TUTORIAL_CURSOR);</a>
<a name="ln133">    const bool mouse_curs_vis = you.see_cell(m_cursor[CURSOR_MOUSE]);</a>
<a name="ln134">    pack_cursor(CURSOR_MOUSE, mouse_curs_vis ? TILEI_CURSOR : TILEI_CURSOR2);</a>
<a name="ln135">    pack_cursor(CURSOR_MAP, TILEI_CURSOR);</a>
<a name="ln136"> </a>
<a name="ln137">    if (m_cursor[CURSOR_TUTORIAL] != NO_CURSOR</a>
<a name="ln138">        &amp;&amp; on_screen(m_cursor[CURSOR_TUTORIAL]))</a>
<a name="ln139">    {</a>
<a name="ln140">        m_buf_dngn.add_main_tile(TILEI_TUTORIAL_CURSOR,</a>
<a name="ln141">                                 m_cursor[CURSOR_TUTORIAL].x,</a>
<a name="ln142">                                 m_cursor[CURSOR_TUTORIAL].y);</a>
<a name="ln143">    }</a>
<a name="ln144"> </a>
<a name="ln145">    for (const tile_overlay &amp;overlay : m_overlays)</a>
<a name="ln146">    {</a>
<a name="ln147">        // overlays must be from the main image and must be in LOS.</a>
<a name="ln148">        if (!crawl_view.in_los_bounds_g(overlay.gc))</a>
<a name="ln149">            continue;</a>
<a name="ln150"> </a>
<a name="ln151">        tileidx_t idx = overlay.idx;</a>
<a name="ln152">        if (idx &gt;= TILE_MAIN_MAX)</a>
<a name="ln153">            continue;</a>
<a name="ln154"> </a>
<a name="ln155">        const coord_def ep(overlay.gc.x - m_cx_to_gx,</a>
<a name="ln156">                           overlay.gc.y - m_cy_to_gy);</a>
<a name="ln157">        m_buf_dngn.add_main_tile(idx, ep.x, ep.y);</a>
<a name="ln158">    }</a>
<a name="ln159">}</a>
<a name="ln160"> </a>
<a name="ln161">struct tag_def</a>
<a name="ln162">{</a>
<a name="ln163">    tag_def() { text = nullptr; left = right = 0; }</a>
<a name="ln164"> </a>
<a name="ln165">    const char* text;</a>
<a name="ln166">    char left, right;</a>
<a name="ln167">    char type;</a>
<a name="ln168">};</a>
<a name="ln169"> </a>
<a name="ln170">// #define DEBUG_TILES_REDRAW</a>
<a name="ln171">void DungeonRegion::render()</a>
<a name="ln172">{</a>
<a name="ln173">#ifdef DEBUG_TILES_REDRAW</a>
<a name="ln174">    cprintf(&quot;rendering DungeonRegion\n&quot;);</a>
<a name="ln175">#endif</a>
<a name="ln176">    if (m_dirty)</a>
<a name="ln177">    {</a>
<a name="ln178">        pack_buffers();</a>
<a name="ln179">        m_dirty = false;</a>
<a name="ln180">    }</a>
<a name="ln181"> </a>
<a name="ln182">    set_transform();</a>
<a name="ln183">    glmanager-&gt;set_scissor(0, 0, tile_iw, tile_ih);</a>
<a name="ln184">    m_buf_dngn.draw();</a>
<a name="ln185">    draw_minibars();</a>
<a name="ln186">    m_buf_flash.draw();</a>
<a name="ln187">    glmanager-&gt;reset_scissor();</a>
<a name="ln188"> </a>
<a name="ln189">    FixedArray&lt;tag_def, ENV_SHOW_DIAMETER, ENV_SHOW_DIAMETER&gt; tag_show;</a>
<a name="ln190"> </a>
<a name="ln191">    int total_tags = 0;</a>
<a name="ln192"> </a>
<a name="ln193">    for (int t = TAG_MAX - 1; t &gt;= 0; t--)</a>
<a name="ln194">    {</a>
<a name="ln195">        for (const TextTag &amp;tag : m_tags[t])</a>
<a name="ln196">        {</a>
<a name="ln197">            if (!crawl_view.in_los_bounds_g(tag.gc))</a>
<a name="ln198">                continue;</a>
<a name="ln199"> </a>
<a name="ln200">            const coord_def ep = grid2show(tag.gc);</a>
<a name="ln201"> </a>
<a name="ln202">            if (tag_show(ep).text)</a>
<a name="ln203">                continue;</a>
<a name="ln204"> </a>
<a name="ln205">            const char *str = tag.tag.c_str();</a>
<a name="ln206"> </a>
<a name="ln207">            int width    = m_tag_font-&gt;string_width(str);</a>
<a name="ln208">            tag_def &amp;def = tag_show(ep);</a>
<a name="ln209"> </a>
<a name="ln210">            const int buffer = 2;</a>
<a name="ln211"> </a>
<a name="ln212">            def.left  = -width / 2 - buffer;</a>
<a name="ln213">            def.right =  width / 2 + buffer;</a>
<a name="ln214">            def.text  = str;</a>
<a name="ln215">            def.type  = t;</a>
<a name="ln216"> </a>
<a name="ln217">            total_tags++;</a>
<a name="ln218">        }</a>
<a name="ln219"> </a>
<a name="ln220">        if (total_tags)</a>
<a name="ln221">            break;</a>
<a name="ln222">    }</a>
<a name="ln223"> </a>
<a name="ln224">    if (!total_tags)</a>
<a name="ln225">        return;</a>
<a name="ln226"> </a>
<a name="ln227">    // Draw text tags.</a>
<a name="ln228">    // TODO enne - be more intelligent about not covering stuff up</a>
<a name="ln229">    for (int y = 0; y &lt; ENV_SHOW_DIAMETER; y++)</a>
<a name="ln230">        for (int x = 0; x &lt; ENV_SHOW_DIAMETER; x++)</a>
<a name="ln231">        {</a>
<a name="ln232">            coord_def ep(x, y);</a>
<a name="ln233">            tag_def &amp;def = tag_show(ep);</a>
<a name="ln234"> </a>
<a name="ln235">            if (!def.text)</a>
<a name="ln236">                continue;</a>
<a name="ln237"> </a>
<a name="ln238">            const coord_def gc = show2grid(ep);</a>
<a name="ln239">            coord_def pc;</a>
<a name="ln240">            to_screen_coords(gc, &amp;pc);</a>
<a name="ln241">            // center this coord, which is at the top left of gc's cell</a>
<a name="ln242">            pc.x += dx / 2;</a>
<a name="ln243"> </a>
<a name="ln244">            const auto text = formatted_string(def.text, WHITE);</a>
<a name="ln245">            m_tag_font-&gt;render_hover_string(pc.x, pc.y, text);</a>
<a name="ln246">        }</a>
<a name="ln247">}</a>
<a name="ln248"> </a>
<a name="ln249">/**</a>
<a name="ln250"> * Draws miniature health and magic points bars on top of the player tile.</a>
<a name="ln251"> *</a>
<a name="ln252"> * Drawing of either is governed by options tile_show_minihealthbar and</a>
<a name="ln253"> * tile_show_minimagicbar. By default, both are on.</a>
<a name="ln254"> *</a>
<a name="ln255"> * Intended behaviour is to display both if either is not full. (Unless</a>
<a name="ln256"> * the bar is toggled off by options.) --Eino &amp; felirx</a>
<a name="ln257"> */</a>
<a name="ln258">void DungeonRegion::draw_minibars()</a>
<a name="ln259">{</a>
<a name="ln260">    if (Options.tile_show_minihealthbar &amp;&amp; you.hp &lt; you.hp_max</a>
<a name="ln261">        || Options.tile_show_minimagicbar</a>
<a name="ln262">           &amp;&amp; you.magic_points &lt; you.max_magic_points)</a>
<a name="ln263">    {</a>
<a name="ln264">        // Tiles are 32x32 pixels; 1/32 = 0.03125.</a>
<a name="ln265">        // The bars are two pixels high each.</a>
<a name="ln266">        const float bar_height = 0.0625;</a>
<a name="ln267">        float healthbar_offset = 0.875;</a>
<a name="ln268"> </a>
<a name="ln269">        ShapeBuffer buff;</a>
<a name="ln270"> </a>
<a name="ln271">        if (!you.on_current_level || !on_screen(you.pos()))</a>
<a name="ln272">            return;</a>
<a name="ln273"> </a>
<a name="ln274">        // FIXME: to_screen_coords could be made into two versions: one</a>
<a name="ln275">        // that gives coords by pixel (the current one), one that gives</a>
<a name="ln276">        // them by grid.</a>
<a name="ln277">        coord_def player_on_screen;</a>
<a name="ln278">        to_screen_coords(you.pos(), &amp;player_on_screen);</a>
<a name="ln279">        player_on_screen.x = (player_on_screen.x-sx)/dx;</a>
<a name="ln280">        player_on_screen.y = (player_on_screen.y-sy)/dy;</a>
<a name="ln281"> </a>
<a name="ln282">        if (Options.tile_show_minimagicbar &amp;&amp; you.max_magic_points &gt; 0)</a>
<a name="ln283">        {</a>
<a name="ln284">            static const VColour magic(0, 114, 159, 207);      // lightblue</a>
<a name="ln285">            static const VColour magic_spent(0, 0, 0, 255);  // black</a>
<a name="ln286"> </a>
<a name="ln287">            const float magic_divider = (float) you.magic_points</a>
<a name="ln288">                                        / (float) you.max_magic_points;</a>
<a name="ln289"> </a>
<a name="ln290">            buff.add(player_on_screen.x,</a>
<a name="ln291">                     player_on_screen.y + healthbar_offset + bar_height,</a>
<a name="ln292">                     player_on_screen.x + magic_divider,</a>
<a name="ln293">                     player_on_screen.y + 1,</a>
<a name="ln294">                     magic);</a>
<a name="ln295">            buff.add(player_on_screen.x + magic_divider,</a>
<a name="ln296">                     player_on_screen.y + healthbar_offset + bar_height,</a>
<a name="ln297">                     player_on_screen.x + 1,</a>
<a name="ln298">                     player_on_screen.y + 1,</a>
<a name="ln299">                     magic_spent);</a>
<a name="ln300">        }</a>
<a name="ln301">        else</a>
<a name="ln302">            healthbar_offset += bar_height;</a>
<a name="ln303"> </a>
<a name="ln304">        if (Options.tile_show_minihealthbar)</a>
<a name="ln305">        {</a>
<a name="ln306">            const float min_hp = max(0, you.hp);</a>
<a name="ln307">            const float health_divider = min_hp / (float) you.hp_max;</a>
<a name="ln308"> </a>
<a name="ln309">            const int hp_percent = (you.hp * 100) / you.hp_max;</a>
<a name="ln310"> </a>
<a name="ln311">            int hp_colour = GREEN;</a>
<a name="ln312">            for (const auto &amp;entry : Options.hp_colour)</a>
<a name="ln313">                if (hp_percent &lt;= entry.first)</a>
<a name="ln314">                    hp_colour = entry.second;</a>
<a name="ln315"> </a>
<a name="ln316">            static const VColour healthy(   0, 255, 0, 255); // green</a>
<a name="ln317">            static const VColour damaged( 255, 255, 0, 255); // yellow</a>
<a name="ln318">            static const VColour wounded( 150,   0, 0, 255); // darkred</a>
<a name="ln319">            static const VColour hp_spent(255,   0, 0, 255); // red</a>
<a name="ln320"> </a>
<a name="ln321">            buff.add(player_on_screen.x,</a>
<a name="ln322">                     player_on_screen.y + healthbar_offset,</a>
<a name="ln323">                     player_on_screen.x + health_divider,</a>
<a name="ln324">                     player_on_screen.y + healthbar_offset + bar_height,</a>
<a name="ln325">                     hp_colour == RED    ? wounded :</a>
<a name="ln326">                     hp_colour == YELLOW ? damaged</a>
<a name="ln327">                                         : healthy);</a>
<a name="ln328"> </a>
<a name="ln329">            buff.add(player_on_screen.x + health_divider,</a>
<a name="ln330">                     player_on_screen.y + healthbar_offset,</a>
<a name="ln331">                     player_on_screen.x + 1,</a>
<a name="ln332">                     player_on_screen.y + healthbar_offset + bar_height,</a>
<a name="ln333">                     hp_spent);</a>
<a name="ln334">        }</a>
<a name="ln335"> </a>
<a name="ln336">        buff.draw();</a>
<a name="ln337">    }</a>
<a name="ln338">}</a>
<a name="ln339"> </a>
<a name="ln340">void DungeonRegion::clear()</a>
<a name="ln341">{</a>
<a name="ln342">    m_vbuf.clear();</a>
<a name="ln343">}</a>
<a name="ln344"> </a>
<a name="ln345">void DungeonRegion::on_resize()</a>
<a name="ln346">{</a>
<a name="ln347">    // TODO enne</a>
<a name="ln348">}</a>
<a name="ln349"> </a>
<a name="ln350">bool DungeonRegion::inside(int x, int y)</a>
<a name="ln351">{</a>
<a name="ln352">    return x &gt;= 0 &amp;&amp; y &gt;= 0 &amp;&amp; x &lt;= tile_iw &amp;&amp; y &lt;= tile_ih;</a>
<a name="ln353">}</a>
<a name="ln354"> </a>
<a name="ln355">// FIXME: If the player is targeted, the game asks the player to target</a>
<a name="ln356">// something with the mouse, then targets the player anyway and treats</a>
<a name="ln357">// mouse click as if it hadn't come during targeting (moves the player</a>
<a name="ln358">// to the clicked cell, whatever).</a>
<a name="ln359">static void _add_targeting_commands(const coord_def&amp; pos)</a>
<a name="ln360">{</a>
<a name="ln361">    // Force targeting cursor back onto center to start off on a clean</a>
<a name="ln362">    // slate.</a>
<a name="ln363">    macro_sendkeys_end_add_cmd(CMD_TARGET_FIND_YOU);</a>
<a name="ln364"> </a>
<a name="ln365">    const coord_def delta = pos - you.pos();</a>
<a name="ln366"> </a>
<a name="ln367">    command_type cmd;</a>
<a name="ln368"> </a>
<a name="ln369">    if (delta.x &lt; 0)</a>
<a name="ln370">        cmd = CMD_TARGET_LEFT;</a>
<a name="ln371">    else</a>
<a name="ln372">        cmd = CMD_TARGET_RIGHT;</a>
<a name="ln373"> </a>
<a name="ln374">    for (int i = 0; i &lt; abs(delta.x); i++)</a>
<a name="ln375">        macro_sendkeys_end_add_cmd(cmd);</a>
<a name="ln376"> </a>
<a name="ln377">    if (delta.y &lt; 0)</a>
<a name="ln378">        cmd = CMD_TARGET_UP;</a>
<a name="ln379">    else</a>
<a name="ln380">        cmd = CMD_TARGET_DOWN;</a>
<a name="ln381"> </a>
<a name="ln382">    for (int i = 0; i &lt; abs(delta.y); i++)</a>
<a name="ln383">        macro_sendkeys_end_add_cmd(cmd);</a>
<a name="ln384"> </a>
<a name="ln385">    macro_sendkeys_end_add_cmd(CMD_TARGET_MOUSE_SELECT);</a>
<a name="ln386">}</a>
<a name="ln387"> </a>
<a name="ln388">static bool _is_appropriate_spell(spell_type spell, const actor* target)</a>
<a name="ln389">{</a>
<a name="ln390">    ASSERT(is_valid_spell(spell));</a>
<a name="ln391"> </a>
<a name="ln392">    const spell_flags  flags    = get_spell_flags(spell);</a>
<a name="ln393">    const bool         targeted = testbits(flags, spflag::targeting_mask);</a>
<a name="ln394"> </a>
<a name="ln395">    // All spells are blocked by transparent walls.</a>
<a name="ln396">    if (targeted &amp;&amp; !you.see_cell_no_trans(target-&gt;pos()))</a>
<a name="ln397">        return false;</a>
<a name="ln398"> </a>
<a name="ln399">    const bool helpful = testbits(flags, spflag::helpful);</a>
<a name="ln400"> </a>
<a name="ln401">    if (target-&gt;is_player())</a>
<a name="ln402">    {</a>
<a name="ln403">        if (flags &amp; spflag::not_self)</a>
<a name="ln404">            return false;</a>
<a name="ln405"> </a>
<a name="ln406">        return (flags &amp; (spflag::helpful | spflag::escape | spflag::recovery))</a>
<a name="ln407">               || !targeted;</a>
<a name="ln408">    }</a>
<a name="ln409"> </a>
<a name="ln410">    if (!targeted)</a>
<a name="ln411">        return false;</a>
<a name="ln412"> </a>
<a name="ln413">    if (flags &amp; spflag::neutral)</a>
<a name="ln414">        return false;</a>
<a name="ln415"> </a>
<a name="ln416">    bool friendly = target-&gt;as_monster()-&gt;wont_attack();</a>
<a name="ln417"> </a>
<a name="ln418">    return friendly == helpful;</a>
<a name="ln419">}</a>
<a name="ln420"> </a>
<a name="ln421">static bool _is_appropriate_evokable(const item_def&amp; item,</a>
<a name="ln422">                                     const actor* target)</a>
<a name="ln423">{</a>
<a name="ln424">    if (!item_is_evokable(item, false))</a>
<a name="ln425">        return false;</a>
<a name="ln426"> </a>
<a name="ln427">    // Only wands for now.</a>
<a name="ln428">    if (item.base_type != OBJ_WANDS)</a>
<a name="ln429">        return false;</a>
<a name="ln430"> </a>
<a name="ln431">    // Aren't yet any wands that can go through transparent walls.</a>
<a name="ln432">    if (!you.see_cell_no_trans(target-&gt;pos()))</a>
<a name="ln433">        return false;</a>
<a name="ln434"> </a>
<a name="ln435">    // We don't know what it is, so it *might* be appropriate.</a>
<a name="ln436">    if (!item_type_known(item))</a>
<a name="ln437">        return true;</a>
<a name="ln438"> </a>
<a name="ln439">    // Random effects are always (in)appropriate for all targets.</a>
<a name="ln440">    if (item.sub_type == WAND_RANDOM_EFFECTS)</a>
<a name="ln441">        return true;</a>
<a name="ln442"> </a>
<a name="ln443">    spell_type spell = spell_in_wand(static_cast&lt;wand_type&gt;(item.sub_type));</a>
<a name="ln444"> </a>
<a name="ln445">    return _is_appropriate_spell(spell, target);</a>
<a name="ln446">}</a>
<a name="ln447"> </a>
<a name="ln448">static bool _have_appropriate_evokable(const actor* target)</a>
<a name="ln449">{</a>
<a name="ln450">    return any_of(begin(you.inv), end(you.inv),</a>
<a name="ln451">                  [target] (const item_def &amp;item) -&gt; bool</a>
<a name="ln452">                  {</a>
<a name="ln453">                      return item.defined()</a>
<a name="ln454">                          &amp;&amp; _is_appropriate_evokable(item, target);</a>
<a name="ln455">                  });</a>
<a name="ln456">}</a>
<a name="ln457"> </a>
<a name="ln458">static item_def* _get_evokable_item(const actor* target)</a>
<a name="ln459">{</a>
<a name="ln460">    vector&lt;const item_def*&gt; list;</a>
<a name="ln461"> </a>
<a name="ln462">    for (const auto &amp;item : you.inv)</a>
<a name="ln463">        if (item.defined() &amp;&amp; _is_appropriate_evokable(item, target))</a>
<a name="ln464">            list.push_back(&amp;item);</a>
<a name="ln465"> </a>
<a name="ln466">    ASSERT(!list.empty());</a>
<a name="ln467"> </a>
<a name="ln468">    InvMenu menu(MF_SINGLESELECT | MF_ANYPRINTABLE</a>
<a name="ln469">                 | MF_ALLOW_FORMATTING | MF_SELECT_BY_PAGE);</a>
<a name="ln470">    menu.set_type(menu_type::any);</a>
<a name="ln471">    menu.set_title(&quot;Wand to zap?&quot;);</a>
<a name="ln472">    menu.load_items(list);</a>
<a name="ln473">    menu.show();</a>
<a name="ln474">    vector&lt;SelItem&gt; sel = menu.get_selitems();</a>
<a name="ln475"> </a>
<a name="ln476">    update_screen();</a>
<a name="ln477">    redraw_screen();</a>
<a name="ln478"> </a>
<a name="ln479">    if (sel.empty())</a>
<a name="ln480">        return nullptr;</a>
<a name="ln481"> </a>
<a name="ln482">    return const_cast&lt;item_def*&gt;(sel[0].item);</a>
<a name="ln483">}</a>
<a name="ln484"> </a>
<a name="ln485">static bool _evoke_item_on_target(actor* target)</a>
<a name="ln486">{</a>
<a name="ln487">    item_def* item;</a>
<a name="ln488">    {</a>
<a name="ln489">        // Prevent the inventory letter from being recorded twice.</a>
<a name="ln490">        pause_all_key_recorders pause;</a>
<a name="ln491"> </a>
<a name="ln492">        item = _get_evokable_item(target);</a>
<a name="ln493">    }</a>
<a name="ln494"> </a>
<a name="ln495">    if (item == nullptr)</a>
<a name="ln496">        return false;</a>
<a name="ln497">#if TAG_MAJOR_VERSION == 34</a>
<a name="ln498">    if (is_known_empty_wand(*item))</a>
<a name="ln499">    {</a>
<a name="ln500">        mpr(&quot;That wand is empty.&quot;);</a>
<a name="ln501">        return false;</a>
<a name="ln502">    }</a>
<a name="ln503">#endif</a>
<a name="ln504"> </a>
<a name="ln505">    macro_sendkeys_end_add_cmd(CMD_EVOKE);</a>
<a name="ln506">    macro_buf_add(index_to_letter(item-&gt;link)); // Inventory letter.</a>
<a name="ln507">    _add_targeting_commands(target-&gt;pos());</a>
<a name="ln508">    return true;</a>
<a name="ln509">}</a>
<a name="ln510"> </a>
<a name="ln511">static bool _spell_in_range(spell_type spell, actor* target)</a>
<a name="ln512">{</a>
<a name="ln513">    if (!(get_spell_flags(spell) &amp; spflag::targeting_mask))</a>
<a name="ln514">        return true;</a>
<a name="ln515"> </a>
<a name="ln516">    int range = calc_spell_range(spell);</a>
<a name="ln517"> </a>
<a name="ln518">    switch (spell)</a>
<a name="ln519">    {</a>
<a name="ln520">    case SPELL_MEPHITIC_CLOUD:</a>
<a name="ln521">    case SPELL_FIREBALL:</a>
<a name="ln522">    case SPELL_FREEZING_CLOUD:</a>
<a name="ln523">    case SPELL_POISONOUS_CLOUD:</a>
<a name="ln524">        // Increase range by one due to cloud radius.</a>
<a name="ln525">        range++;</a>
<a name="ln526">        break;</a>
<a name="ln527">    default:</a>
<a name="ln528">        break;</a>
<a name="ln529">    }</a>
<a name="ln530"> </a>
<a name="ln531">    return range &gt;= grid_distance(you.pos(), target-&gt;pos());</a>
<a name="ln532">}</a>
<a name="ln533"> </a>
<a name="ln534">static actor* _spell_target = nullptr;</a>
<a name="ln535"> </a>
<a name="ln536">static bool _spell_selector(spell_type spell)</a>
<a name="ln537">{</a>
<a name="ln538">    return _is_appropriate_spell(spell, _spell_target);</a>
<a name="ln539">}</a>
<a name="ln540"> </a>
<a name="ln541">// TODO: Cast spells which target a particular cell.</a>
<a name="ln542">static bool _cast_spell_on_target(actor* target)</a>
<a name="ln543">{</a>
<a name="ln544">    _spell_target = target;</a>
<a name="ln545">    spell_type spell;</a>
<a name="ln546">    int letter;</a>
<a name="ln547"> </a>
<a name="ln548">    if (is_valid_spell(you.last_cast_spell)</a>
<a name="ln549">        &amp;&amp; _is_appropriate_spell(you.last_cast_spell, target))</a>
<a name="ln550">    {</a>
<a name="ln551">        spell = you.last_cast_spell;</a>
<a name="ln552">        letter = get_spell_letter(spell);</a>
<a name="ln553">    }</a>
<a name="ln554">    else</a>
<a name="ln555">    {</a>
<a name="ln556">        {</a>
<a name="ln557">            // Prevent the spell letter from being recorded twice.</a>
<a name="ln558">            pause_all_key_recorders pause;</a>
<a name="ln559"> </a>
<a name="ln560">            letter = list_spells(true, false, true, &quot;Your Spells&quot;,</a>
<a name="ln561">                                 _spell_selector);</a>
<a name="ln562">        }</a>
<a name="ln563"> </a>
<a name="ln564">        _spell_target = nullptr;</a>
<a name="ln565"> </a>
<a name="ln566">        if (letter == 0)</a>
<a name="ln567">            return false;</a>
<a name="ln568"> </a>
<a name="ln569">        spell = get_spell_by_letter(letter);</a>
<a name="ln570">    }</a>
<a name="ln571"> </a>
<a name="ln572">    ASSERT(is_valid_spell(spell));</a>
<a name="ln573">    ASSERT(_is_appropriate_spell(spell, target));</a>
<a name="ln574"> </a>
<a name="ln575">    if (!_spell_in_range(spell, target))</a>
<a name="ln576">    {</a>
<a name="ln577">        mprf(&quot;%s is out of range for that spell.&quot;,</a>
<a name="ln578">             target-&gt;name(DESC_THE).c_str());</a>
<a name="ln579">        return true;</a>
<a name="ln580">    }</a>
<a name="ln581"> </a>
<a name="ln582">    if (spell_mana(spell) &gt; you.magic_points)</a>
<a name="ln583">    {</a>
<a name="ln584">        mpr(&quot;You don't have enough magic to cast that spell.&quot;);</a>
<a name="ln585">        return true;</a>
<a name="ln586">    }</a>
<a name="ln587"> </a>
<a name="ln588">    macro_sendkeys_end_add_cmd(CMD_FORCE_CAST_SPELL);</a>
<a name="ln589">    macro_buf_add(letter);</a>
<a name="ln590"> </a>
<a name="ln591">    if (get_spell_flags(spell) &amp; spflag::targeting_mask)</a>
<a name="ln592">        _add_targeting_commands(target-&gt;pos());</a>
<a name="ln593"> </a>
<a name="ln594">    return true;</a>
<a name="ln595">}</a>
<a name="ln596"> </a>
<a name="ln597">static bool _have_appropriate_spell(const actor* target)</a>
<a name="ln598">{</a>
<a name="ln599">    for (spell_type spell : you.spells)</a>
<a name="ln600">    {</a>
<a name="ln601">        if (!is_valid_spell(spell))</a>
<a name="ln602">            continue;</a>
<a name="ln603"> </a>
<a name="ln604">        if (_is_appropriate_spell(spell, target))</a>
<a name="ln605">            return true;</a>
<a name="ln606">    }</a>
<a name="ln607">    return false;</a>
<a name="ln608">}</a>
<a name="ln609"> </a>
<a name="ln610">static bool _can_fire_item()</a>
<a name="ln611">{</a>
<a name="ln612">    return you.species != SP_FELID</a>
<a name="ln613">           &amp;&amp; you.m_quiver.get_fire_item() != -1;</a>
<a name="ln614">}</a>
<a name="ln615"> </a>
<a name="ln616">static bool _handle_distant_monster(monster* mon, unsigned char mod)</a>
<a name="ln617">{</a>
<a name="ln618">    const bool shift = (mod &amp; TILES_MOD_SHIFT);</a>
<a name="ln619">    const bool ctrl  = (mod &amp; TILES_MOD_CTRL);</a>
<a name="ln620">    const bool alt   = (shift &amp;&amp; ctrl || (mod &amp; TILES_MOD_ALT));</a>
<a name="ln621">    const item_def* weapon = you.weapon();</a>
<a name="ln622"> </a>
<a name="ln623">    // Handle evoking items at monster.</a>
<a name="ln624">    if (alt &amp;&amp; _have_appropriate_evokable(mon))</a>
<a name="ln625">        return _evoke_item_on_target(mon);</a>
<a name="ln626"> </a>
<a name="ln627">    // Handle firing quivered items.</a>
<a name="ln628">    if (_can_fire_item() &amp;&amp; !ctrl</a>
<a name="ln629">        &amp;&amp; (shift || weapon &amp;&amp; is_range_weapon(*weapon)</a>
<a name="ln630">                     &amp;&amp; !mon-&gt;wont_attack()))</a>
<a name="ln631">    {</a>
<a name="ln632">        macro_sendkeys_end_add_cmd(CMD_FIRE);</a>
<a name="ln633">        _add_targeting_commands(mon-&gt;pos());</a>
<a name="ln634">        return true;</a>
<a name="ln635">    }</a>
<a name="ln636"> </a>
<a name="ln637">    // Handle casting spells at monster.</a>
<a name="ln638">    if (ctrl &amp;&amp; !shift &amp;&amp; _have_appropriate_spell(mon))</a>
<a name="ln639">        return _cast_spell_on_target(mon);</a>
<a name="ln640"> </a>
<a name="ln641">    // Handle weapons of reaching.</a>
<a name="ln642">    if (!mon-&gt;wont_attack() &amp;&amp; you.see_cell_no_trans(mon-&gt;pos()))</a>
<a name="ln643">    {</a>
<a name="ln644">        const int dist = (you.pos() - mon-&gt;pos()).rdist();</a>
<a name="ln645"> </a>
<a name="ln646">        if (dist &gt; 1 &amp;&amp; weapon &amp;&amp; weapon_reach(*weapon) &gt;= dist)</a>
<a name="ln647">        {</a>
<a name="ln648">            macro_sendkeys_end_add_cmd(CMD_EVOKE_WIELDED);</a>
<a name="ln649">            _add_targeting_commands(mon-&gt;pos());</a>
<a name="ln650">            return true;</a>
<a name="ln651">        }</a>
<a name="ln652">    }</a>
<a name="ln653"> </a>
<a name="ln654">    return false;</a>
<a name="ln655">}</a>
<a name="ln656"> </a>
<a name="ln657">static bool _handle_zap_player(wm_mouse_event &amp;event)</a>
<a name="ln658">{</a>
<a name="ln659">    const bool shift = (event.mod &amp; TILES_MOD_SHIFT);</a>
<a name="ln660">    const bool ctrl  = (event.mod &amp; TILES_MOD_CTRL);</a>
<a name="ln661">    const bool alt   = (shift &amp;&amp; ctrl || (event.mod &amp; TILES_MOD_ALT));</a>
<a name="ln662"> </a>
<a name="ln663">    if (alt &amp;&amp; _have_appropriate_evokable(&amp;you))</a>
<a name="ln664">        return _evoke_item_on_target(&amp;you);</a>
<a name="ln665"> </a>
<a name="ln666">    if (ctrl &amp;&amp; _have_appropriate_spell(&amp;you))</a>
<a name="ln667">        return _cast_spell_on_target(&amp;you);</a>
<a name="ln668"> </a>
<a name="ln669">    return false;</a>
<a name="ln670">}</a>
<a name="ln671"> </a>
<a name="ln672">void DungeonRegion::zoom(bool in)</a>
<a name="ln673">{</a>
<a name="ln674">    int sign = in ? 1 : -1;</a>
<a name="ln675">    int amt  = 4;</a>
<a name="ln676">    const int max_zoom = 64; // this needs to be a proportion, not a fixed amount!</a>
<a name="ln677">    const bool minimap_zoom = (sx&gt;dx); // i.e. there's a border bigger than a tile (was dx&lt;min_zoom+amt)</a>
<a name="ln678"> </a>
<a name="ln679">    // if we try to zoom out too far, go to minimap instead</a>
<a name="ln680">    if (!in &amp;&amp; minimap_zoom)</a>
<a name="ln681">        if (tiles.zoom_to_minimap())</a>
<a name="ln682">            return;</a>
<a name="ln683"> </a>
<a name="ln684">    // if we zoomed in from min zoom, and the map's still up, switch off minimap instead</a>
<a name="ln685">    if (in &amp;&amp; minimap_zoom)</a>
<a name="ln686">        if (tiles.zoom_from_minimap())</a>
<a name="ln687">            return;</a>
<a name="ln688"> </a>
<a name="ln689">    // if we zoom out too much, stop</a>
<a name="ln690">    if (!in &amp;&amp; minimap_zoom) //(dx + sign*amt &lt; min_zoom)</a>
<a name="ln691">        return;</a>
<a name="ln692">    // if we zoom in too close, stop</a>
<a name="ln693">    if (dx + sign*amt &gt; max_zoom)</a>
<a name="ln694">        return;</a>
<a name="ln695"> </a>
<a name="ln696">    dx = dx + sign*amt;</a>
<a name="ln697">    dy = dy + sign*amt;</a>
<a name="ln698"> </a>
<a name="ln699">    int old_wx = wx; int old_wy = wy;</a>
<a name="ln700">    recalculate();</a>
<a name="ln701"> </a>
<a name="ln702">    place((old_wx-wx)/2+sx, (old_wy-wy)/2+sy, 0);</a>
<a name="ln703"> </a>
<a name="ln704">    crawl_view.viewsz.x = mx;</a>
<a name="ln705">    crawl_view.viewsz.y = my;</a>
<a name="ln706">}</a>
<a name="ln707"> </a>
<a name="ln708">int DungeonRegion::handle_mouse(wm_mouse_event &amp;event)</a>
<a name="ln709">{</a>
<a name="ln710">    tiles.clear_text_tags(TAG_CELL_DESC);</a>
<a name="ln711"> </a>
<a name="ln712">    if (!inside(event.px, event.py))</a>
<a name="ln713">        return 0;</a>
<a name="ln714"> </a>
<a name="ln715">#ifdef TOUCH_UI</a>
<a name="ln716">    if (event.event == wm_mouse_event::WHEEL &amp;&amp; (event.mod &amp; TILES_MOD_CTRL))</a>
<a name="ln717">        zoom(event.button == wm_mouse_event::SCROLL_UP);</a>
<a name="ln718">#endif</a>
<a name="ln719"> </a>
<a name="ln720">    if (mouse_control::current_mode() == MOUSE_MODE_NORMAL</a>
<a name="ln721">        &amp;&amp; event.event == wm_mouse_event::PRESS</a>
<a name="ln722">        &amp;&amp; event.button == wm_mouse_event::LEFT)</a>
<a name="ln723">    {</a>
<a name="ln724">        m_last_clicked_grid = m_cursor[CURSOR_MOUSE];</a>
<a name="ln725"> </a>
<a name="ln726">        int cx, cy;</a>
<a name="ln727">        mouse_pos(event.px, event.py, cx, cy);</a>
<a name="ln728">        const coord_def gc(cx + m_cx_to_gx, cy + m_cy_to_gy);</a>
<a name="ln729">        tiles.place_cursor(CURSOR_MOUSE, gc);</a>
<a name="ln730"> </a>
<a name="ln731">        return CK_MOUSE_CLICK;</a>
<a name="ln732">    }</a>
<a name="ln733"> </a>
<a name="ln734">    if (mouse_control::current_mode() == MOUSE_MODE_MACRO</a>
<a name="ln735">        || mouse_control::current_mode() == MOUSE_MODE_MORE</a>
<a name="ln736">        || mouse_control::current_mode() == MOUSE_MODE_PROMPT</a>
<a name="ln737">        || mouse_control::current_mode() == MOUSE_MODE_YESNO)</a>
<a name="ln738">    {</a>
<a name="ln739">        return 0;</a>
<a name="ln740">    }</a>
<a name="ln741"> </a>
<a name="ln742">    int cx;</a>
<a name="ln743">    int cy;</a>
<a name="ln744"> </a>
<a name="ln745">    bool on_map = mouse_pos(event.px, event.py, cx, cy);</a>
<a name="ln746"> </a>
<a name="ln747">    const coord_def gc(cx + m_cx_to_gx, cy + m_cy_to_gy);</a>
<a name="ln748">    tiles.place_cursor(CURSOR_MOUSE, gc);</a>
<a name="ln749"> </a>
<a name="ln750">    if (event.event == wm_mouse_event::MOVE)</a>
<a name="ln751">    {</a>
<a name="ln752">        string desc = get_terse_square_desc(gc);</a>
<a name="ln753">        // Suppress floor description</a>
<a name="ln754">        if (desc == &quot;floor&quot;)</a>
<a name="ln755">            desc = &quot;&quot;;</a>
<a name="ln756"> </a>
<a name="ln757">        if (you.see_cell(gc))</a>
<a name="ln758">        {</a>
<a name="ln759">            if (cloud_struct* cloud = cloud_at(gc))</a>
<a name="ln760">            {</a>
<a name="ln761">                string terrain_desc = desc;</a>
<a name="ln762">                desc = cloud-&gt;cloud_name(true);</a>
<a name="ln763"> </a>
<a name="ln764">                if (!terrain_desc.empty())</a>
<a name="ln765">                    desc += &quot;\n&quot; + terrain_desc;</a>
<a name="ln766">            }</a>
<a name="ln767">        }</a>
<a name="ln768"> </a>
<a name="ln769">        if (!desc.empty())</a>
<a name="ln770">            tiles.add_text_tag(TAG_CELL_DESC, desc, gc);</a>
<a name="ln771">    }</a>
<a name="ln772"> </a>
<a name="ln773">    if (mouse_control::current_mode() == MOUSE_MODE_NORMAL)</a>
<a name="ln774">        return 0;</a>
<a name="ln775"> </a>
<a name="ln776">    if (!on_map)</a>
<a name="ln777">        return 0;</a>
<a name="ln778"> </a>
<a name="ln779">    if (mouse_control::current_mode() == MOUSE_MODE_TARGET</a>
<a name="ln780">        || mouse_control::current_mode() == MOUSE_MODE_TARGET_PATH</a>
<a name="ln781">        || mouse_control::current_mode() == MOUSE_MODE_TARGET_DIR)</a>
<a name="ln782">    {</a>
<a name="ln783">        if (event.event == wm_mouse_event::MOVE)</a>
<a name="ln784">            return CK_MOUSE_MOVE;</a>
<a name="ln785">        else if (event.event == wm_mouse_event::PRESS</a>
<a name="ln786">                 &amp;&amp; event.button == wm_mouse_event::LEFT &amp;&amp; on_screen(gc))</a>
<a name="ln787">        {</a>
<a name="ln788">            m_last_clicked_grid = m_cursor[CURSOR_MOUSE];</a>
<a name="ln789">            return CK_MOUSE_CLICK;</a>
<a name="ln790">        }</a>
<a name="ln791"> </a>
<a name="ln792">        return 0;</a>
<a name="ln793">    }</a>
<a name="ln794"> </a>
<a name="ln795">    if (event.event != wm_mouse_event::PRESS)</a>
<a name="ln796">        return 0;</a>
<a name="ln797"> </a>
<a name="ln798">    m_last_clicked_grid = m_cursor[CURSOR_MOUSE];</a>
<a name="ln799"> </a>
<a name="ln800">    if (you.pos() == gc)</a>
<a name="ln801">    {</a>
<a name="ln802">        switch (event.button)</a>
<a name="ln803">        {</a>
<a name="ln804">        case wm_mouse_event::LEFT:</a>
<a name="ln805">        {</a>
<a name="ln806">            if ((event.mod &amp; (TILES_MOD_CTRL | TILES_MOD_ALT)))</a>
<a name="ln807">            {</a>
<a name="ln808">                _handle_zap_player(event);</a>
<a name="ln809">                // return either way -- everything else in this case</a>
<a name="ln810">                // needs non-ctrl (and we definitely don't want to</a>
<a name="ln811">                // trigger a wait in the next if)</a>
<a name="ln812">                return 0;</a>
<a name="ln813">            }</a>
<a name="ln814"> </a>
<a name="ln815">            // if there's an item, pick it up, otherwise wait 1 turn</a>
<a name="ln816">            if (!(event.mod &amp; TILES_MOD_SHIFT))</a>
<a name="ln817">            {</a>
<a name="ln818">                const int o = you.visible_igrd(you.pos());</a>
<a name="ln819">                if (o == NON_ITEM)</a>
<a name="ln820">                {</a>
<a name="ln821">                    // if on stairs, travel them</a>
<a name="ln822">                    const dungeon_feature_type feat = grd(gc);</a>
<a name="ln823">                    switch (feat_stair_direction(feat))</a>
<a name="ln824">                    {</a>
<a name="ln825">                    case CMD_GO_DOWNSTAIRS:</a>
<a name="ln826">                    case CMD_GO_UPSTAIRS:</a>
<a name="ln827">                        return command_to_key(feat_stair_direction(feat));</a>
<a name="ln828">                    default:</a>
<a name="ln829">                        // otherwise wait</a>
<a name="ln830">                        return command_to_key(CMD_WAIT);</a>
<a name="ln831">                    }</a>
<a name="ln832">                }</a>
<a name="ln833">                else</a>
<a name="ln834">                {</a>
<a name="ln835"> </a>
<a name="ln836">                    // pick up menu</a>
<a name="ln837">                    // More than a single item -&gt; open menu right away.</a>
<a name="ln838">                    if (count_movable_items(o) &gt; 1)</a>
<a name="ln839">                    {</a>
<a name="ln840">                        pickup_menu(o);</a>
<a name="ln841">                        flush_prev_message();</a>
<a name="ln842">                        redraw_screen();</a>
<a name="ln843">                        return CK_MOUSE_CMD;</a>
<a name="ln844">                    }</a>
<a name="ln845">                    return command_to_key(CMD_PICKUP);</a>
<a name="ln846">                }</a>
<a name="ln847">            }</a>
<a name="ln848"> </a>
<a name="ln849">            const dungeon_feature_type feat = grd(gc);</a>
<a name="ln850">            switch (feat_stair_direction(feat))</a>
<a name="ln851">            {</a>
<a name="ln852">            case CMD_GO_DOWNSTAIRS:</a>
<a name="ln853">            case CMD_GO_UPSTAIRS:</a>
<a name="ln854">                return command_to_key(feat_stair_direction(feat));</a>
<a name="ln855">            default:</a>
<a name="ln856">                return 0;</a>
<a name="ln857">            }</a>
<a name="ln858">        }</a>
<a name="ln859">        case wm_mouse_event::RIGHT:</a>
<a name="ln860">            if (!(event.mod &amp; TILES_MOD_SHIFT))</a>
<a name="ln861">                return command_to_key(CMD_RESISTS_SCREEN); // Character overview.</a>
<a name="ln862">            if (!you_worship(GOD_NO_GOD))</a>
<a name="ln863">                return command_to_key(CMD_DISPLAY_RELIGION); // Religion screen.</a>
<a name="ln864"> </a>
<a name="ln865">            // fall through...</a>
<a name="ln866">        default:</a>
<a name="ln867">            return 0;</a>
<a name="ln868">        }</a>
<a name="ln869"> </a>
<a name="ln870">    }</a>
<a name="ln871">    // else not on player...</a>
<a name="ln872">    if (event.button == wm_mouse_event::RIGHT)</a>
<a name="ln873">    {</a>
<a name="ln874">        if (map_bounds(gc) &amp;&amp; env.map_knowledge(gc).known())</a>
<a name="ln875">        {</a>
<a name="ln876">            full_describe_square(gc);</a>
<a name="ln877">            return CK_MOUSE_CMD;</a>
<a name="ln878">        }</a>
<a name="ln879">        else</a>
<a name="ln880">            return 0;</a>
<a name="ln881">    }</a>
<a name="ln882"> </a>
<a name="ln883">    if (event.button != wm_mouse_event::LEFT)</a>
<a name="ln884">        return 0;</a>
<a name="ln885"> </a>
<a name="ln886">    return tile_click_cell(gc, event.mod);</a>
<a name="ln887">}</a>
<a name="ln888"> </a>
<a name="ln889">int tile_click_cell(const coord_def &amp;gc, unsigned char mod)</a>
<a name="ln890">{</a>
<a name="ln891">    monster* mon = monster_at(gc);</a>
<a name="ln892">    if (mon &amp;&amp; you.can_see(*mon))</a>
<a name="ln893">    {</a>
<a name="ln894">        if (_handle_distant_monster(mon, mod))</a>
<a name="ln895">            return CK_MOUSE_CMD;</a>
<a name="ln896">    }</a>
<a name="ln897"> </a>
<a name="ln898">    if ((mod &amp; TILES_MOD_CTRL) &amp;&amp; adjacent(you.pos(), gc))</a>
<a name="ln899">    {</a>
<a name="ln900">        const int cmd = click_travel(gc, mod &amp; TILES_MOD_CTRL);</a>
<a name="ln901">        if (cmd != CK_MOUSE_CMD)</a>
<a name="ln902">            process_command((command_type) cmd);</a>
<a name="ln903"> </a>
<a name="ln904">        return CK_MOUSE_CMD;</a>
<a name="ln905">    }</a>
<a name="ln906"> </a>
<a name="ln907">    // Don't move if we've tried to fire/cast/evoke when there's nothing</a>
<a name="ln908">    // available.</a>
<a name="ln909">    if (mod &amp; (TILES_MOD_SHIFT | TILES_MOD_CTRL | TILES_MOD_ALT))</a>
<a name="ln910">        return CK_MOUSE_CMD;</a>
<a name="ln911"> </a>
<a name="ln912">    const int cmd = click_travel(gc, mod &amp; TILES_MOD_CTRL);</a>
<a name="ln913">    if (cmd != CK_MOUSE_CMD)</a>
<a name="ln914">        process_command((command_type) cmd);</a>
<a name="ln915"> </a>
<a name="ln916">    return CK_MOUSE_CMD;</a>
<a name="ln917">}</a>
<a name="ln918"> </a>
<a name="ln919">void DungeonRegion::to_screen_coords(const coord_def &amp;gc, coord_def *pc) const</a>
<a name="ln920">{</a>
<a name="ln921">    int cx = gc.x - m_cx_to_gx;</a>
<a name="ln922">    int cy = gc.y - m_cy_to_gy;</a>
<a name="ln923"> </a>
<a name="ln924">    pc-&gt;x = sx + ox + cx * dx;</a>
<a name="ln925">    pc-&gt;y = sy + oy + cy * dy;</a>
<a name="ln926">}</a>
<a name="ln927"> </a>
<a name="ln928">bool DungeonRegion::on_screen(const coord_def &amp;gc) const</a>
<a name="ln929">{</a>
<a name="ln930">    int x = gc.x - m_cx_to_gx;</a>
<a name="ln931">    int y = gc.y - m_cy_to_gy;</a>
<a name="ln932"> </a>
<a name="ln933">    return x &gt;= 0 &amp;&amp; x &lt; mx &amp;&amp; y &gt;= 0 &amp;&amp; y &lt; my;</a>
<a name="ln934">}</a>
<a name="ln935"> </a>
<a name="ln936">void DungeonRegion::place_cursor(cursor_type type, const coord_def &amp;gc)</a>
<a name="ln937">{</a>
<a name="ln938">    coord_def result = gc;</a>
<a name="ln939"> </a>
<a name="ln940">    // If we're only looking for a direction, put the mouse</a>
<a name="ln941">    // cursor next to the player to let them know that their</a>
<a name="ln942">    // spell/wand will only go one square.</a>
<a name="ln943">    if (mouse_control::current_mode() == MOUSE_MODE_TARGET_DIR</a>
<a name="ln944">        &amp;&amp; type == CURSOR_MOUSE &amp;&amp; gc != NO_CURSOR)</a>
<a name="ln945">    {</a>
<a name="ln946">        coord_def delta = gc - you.pos();</a>
<a name="ln947"> </a>
<a name="ln948">        int ax = abs(delta.x);</a>
<a name="ln949">        int ay = abs(delta.y);</a>
<a name="ln950"> </a>
<a name="ln951">        result = you.pos();</a>
<a name="ln952">        if (1000 * ay &lt; 414 * ax)</a>
<a name="ln953">            result += (delta.x &gt; 0) ? coord_def(1, 0) : coord_def(-1, 0);</a>
<a name="ln954">        else if (1000 * ax &lt; 414 * ay)</a>
<a name="ln955">            result += (delta.y &gt; 0) ? coord_def(0, 1) : coord_def(0, -1);</a>
<a name="ln956">        else if (delta.x &gt; 0)</a>
<a name="ln957">            result += (delta.y &gt; 0) ? coord_def(1, 1) : coord_def(1, -1);</a>
<a name="ln958">        else if (delta.x &lt; 0)</a>
<a name="ln959">            result += (delta.y &gt; 0) ? coord_def(-1, 1) : coord_def(-1, -1);</a>
<a name="ln960">    }</a>
<a name="ln961"> </a>
<a name="ln962">    if (m_cursor[type] != result)</a>
<a name="ln963">    {</a>
<a name="ln964">        m_dirty = true;</a>
<a name="ln965">        m_cursor[type] = result;</a>
<a name="ln966">        if (type == CURSOR_MOUSE)</a>
<a name="ln967">            m_last_clicked_grid = coord_def();</a>
<a name="ln968">    }</a>
<a name="ln969">}</a>
<a name="ln970"> </a>
<a name="ln971">bool DungeonRegion::update_tip_text(string &amp;tip)</a>
<a name="ln972">{</a>
<a name="ln973">    // TODO enne - it would be really nice to use the tutorial</a>
<a name="ln974">    // descriptions here for features, monsters, etc...</a>
<a name="ln975">    // Unfortunately, that would require quite a bit of rewriting</a>
<a name="ln976">    // and some parsing of formatting to get that to work.</a>
<a name="ln977"> </a>
<a name="ln978">    if (mouse_control::current_mode() != MOUSE_MODE_COMMAND)</a>
<a name="ln979">        return false;</a>
<a name="ln980"> </a>
<a name="ln981">    if (m_cursor[CURSOR_MOUSE] == NO_CURSOR)</a>
<a name="ln982">        return false;</a>
<a name="ln983">    const coord_def gc = m_cursor[CURSOR_MOUSE];</a>
<a name="ln984">    if (!map_bounds(gc) || !crawl_view.in_viewport_g(gc))</a>
<a name="ln985">        return false;</a>
<a name="ln986"> </a>
<a name="ln987">    bool ret = (tile_dungeon_tip(gc, tip));</a>
<a name="ln988"> </a>
<a name="ln989">#ifdef WIZARD</a>
<a name="ln990">    if (you.wizard)</a>
<a name="ln991">    {</a>
<a name="ln992">        if (!tip.empty())</a>
<a name="ln993">            tip += &quot;\n\n&quot;;</a>
<a name="ln994"> </a>
<a name="ln995">        if (you.see_cell(gc))</a>
<a name="ln996">        {</a>
<a name="ln997">            const coord_def ep = grid2show(gc);</a>
<a name="ln998"> </a>
<a name="ln999">            tip += make_stringf(&quot;GC(%d, %d) EP(%d, %d)\n&quot;,</a>
<a name="ln1000">                                gc.x, gc.y, ep.x, ep.y);</a>
<a name="ln1001"> </a>
<a name="ln1002">            if (env.heightmap)</a>
<a name="ln1003">                tip += make_stringf(&quot;HEIGHT(%d)\n&quot;, dgn_height_at(gc));</a>
<a name="ln1004"> </a>
<a name="ln1005">            tip += &quot;\n&quot;;</a>
<a name="ln1006">            tip += tile_debug_string(env.tile_fg(ep), env.tile_bg(ep), ' ');</a>
<a name="ln1007">        }</a>
<a name="ln1008">        else</a>
<a name="ln1009">        {</a>
<a name="ln1010">            tip += make_stringf(&quot;GC(%d, %d) [out of sight]\n&quot;, gc.x, gc.y);</a>
<a name="ln1011">            if (env.heightmap)</a>
<a name="ln1012">                tip += make_stringf(&quot;HEIGHT(%d)\n&quot;, dgn_height_at(gc));</a>
<a name="ln1013">            tip += &quot;\n&quot;;</a>
<a name="ln1014">        }</a>
<a name="ln1015"> </a>
<a name="ln1016">        tip += tile_debug_string(env.tile_bk_fg(gc), env.tile_bk_bg(gc), 'B');</a>
<a name="ln1017"> </a>
<a name="ln1018">        if (!m_vbuf.empty())</a>
<a name="ln1019">        {</a>
<a name="ln1020">            const screen_cell_t *vbuf = m_vbuf;</a>
<a name="ln1021">            const coord_def vc(gc.x - m_cx_to_gx, gc.y - m_cy_to_gy);</a>
<a name="ln1022">            const screen_cell_t &amp;cell = vbuf[crawl_view.viewsz.x * vc.y + vc.x];</a>
<a name="ln1023">            tip += tile_debug_string(cell.tile.fg, cell.tile.bg, 'V');</a>
<a name="ln1024">        }</a>
<a name="ln1025"> </a>
<a name="ln1026">        tip += make_stringf(&quot;\nFLV: floor: %d (%s) (%d)&quot;</a>
<a name="ln1027">                            &quot;\n     wall:  %d (%s) (%d)&quot;</a>
<a name="ln1028">                            &quot;\n     feat:  %d (%s) (%d)&quot;</a>
<a name="ln1029">                            &quot;\n  special:  %d&quot;,</a>
<a name="ln1030">                            env.tile_flv(gc).floor,</a>
<a name="ln1031">                            tile_dngn_name(env.tile_flv(gc).floor),</a>
<a name="ln1032">                            env.tile_flv(gc).floor_idx,</a>
<a name="ln1033">                            env.tile_flv(gc).wall,</a>
<a name="ln1034">                            tile_dngn_name(env.tile_flv(gc).wall),</a>
<a name="ln1035">                            env.tile_flv(gc).wall_idx,</a>
<a name="ln1036">                            env.tile_flv(gc).feat,</a>
<a name="ln1037">                            tile_dngn_name(env.tile_flv(gc).feat),</a>
<a name="ln1038">                            env.tile_flv(gc).feat_idx,</a>
<a name="ln1039">                            env.tile_flv(gc).special);</a>
<a name="ln1040"> </a>
<a name="ln1041">        ret = true;</a>
<a name="ln1042">    }</a>
<a name="ln1043">#endif</a>
<a name="ln1044"> </a>
<a name="ln1045">    return ret;</a>
<a name="ln1046">}</a>
<a name="ln1047"> </a>
<a name="ln1048">static string _check_spell_evokable(const actor* target,</a>
<a name="ln1049">                                    vector&lt;command_type&gt; &amp;cmd)</a>
<a name="ln1050">{</a>
<a name="ln1051">    string str = &quot;&quot;;</a>
<a name="ln1052">    if (_have_appropriate_spell(target))</a>
<a name="ln1053">    {</a>
<a name="ln1054">        str += &quot;\n[Ctrl + L-Click] Cast spell (%)&quot;;</a>
<a name="ln1055">        cmd.push_back(CMD_CAST_SPELL);</a>
<a name="ln1056">    }</a>
<a name="ln1057"> </a>
<a name="ln1058">    if (_have_appropriate_evokable(target))</a>
<a name="ln1059">    {</a>
<a name="ln1060">        string key = &quot;Alt&quot;;</a>
<a name="ln1061">#ifdef UNIX</a>
<a name="ln1062">        // On Unix systems the Alt key is already hogged by</a>
<a name="ln1063">        // the application window, at least when we're not</a>
<a name="ln1064">        // in fullscreen mode, so we use Ctrl-Shift instead.</a>
<a name="ln1065">        if (!tiles.is_fullscreen())</a>
<a name="ln1066">            key = &quot;Ctrl-Shift&quot;;</a>
<a name="ln1067">#endif</a>
<a name="ln1068">        str += &quot;\n[&quot; + key + &quot; + L-Click] Zap wand (%)&quot;;</a>
<a name="ln1069">        cmd.push_back(CMD_EVOKE);</a>
<a name="ln1070">    }</a>
<a name="ln1071"> </a>
<a name="ln1072">    return str;</a>
<a name="ln1073">}</a>
<a name="ln1074"> </a>
<a name="ln1075">static void _add_tip(string &amp;tip, string text)</a>
<a name="ln1076">{</a>
<a name="ln1077">    if (!tip.empty())</a>
<a name="ln1078">        tip += &quot;\n&quot;;</a>
<a name="ln1079">    tip += text;</a>
<a name="ln1080">}</a>
<a name="ln1081"> </a>
<a name="ln1082">bool tile_dungeon_tip(const coord_def &amp;gc, string &amp;tip)</a>
<a name="ln1083">{</a>
<a name="ln1084">    const int attack_dist = you.weapon() ?</a>
<a name="ln1085">        weapon_reach(*you.weapon()) : 1;</a>
<a name="ln1086"> </a>
<a name="ln1087">    vector&lt;command_type&gt; cmd;</a>
<a name="ln1088">    tip = &quot;&quot;;</a>
<a name="ln1089">    bool has_monster = false;</a>
<a name="ln1090"> </a>
<a name="ln1091">    // Left-click first.</a>
<a name="ln1092">    if (gc == you.pos())</a>
<a name="ln1093">    {</a>
<a name="ln1094">        tip = you.your_name;</a>
<a name="ln1095">        tip += &quot; (&quot;;</a>
<a name="ln1096">        tip += get_species_abbrev(you.species);</a>
<a name="ln1097">        tip += get_job_abbrev(you.char_class);</a>
<a name="ln1098">        tip += &quot;)&quot;;</a>
<a name="ln1099"> </a>
<a name="ln1100">        tip += _check_spell_evokable(&amp;you, cmd);</a>
<a name="ln1101">    }</a>
<a name="ln1102">    else // non-player squares</a>
<a name="ln1103">    {</a>
<a name="ln1104">        const actor* target = actor_at(gc);</a>
<a name="ln1105">        if (target &amp;&amp; you.can_see(*target))</a>
<a name="ln1106">        {</a>
<a name="ln1107">            has_monster = true;</a>
<a name="ln1108">            if ((gc - you.pos()).rdist() &lt;= attack_dist)</a>
<a name="ln1109">            {</a>
<a name="ln1110">                if (!cell_is_solid(gc))</a>
<a name="ln1111">                {</a>
<a name="ln1112">                    const monster* mon = monster_at(gc);</a>
<a name="ln1113">                    if (!mon || mon-&gt;friendly() || !mon-&gt;visible_to(&amp;you))</a>
<a name="ln1114">                        _add_tip(tip, &quot;[L-Click] Move&quot;);</a>
<a name="ln1115">                    else if (mon)</a>
<a name="ln1116">                    {</a>
<a name="ln1117">                        tip = mon-&gt;name(DESC_A);</a>
<a name="ln1118">                        _add_tip(tip, &quot;[L-Click] Attack&quot;);</a>
<a name="ln1119">                    }</a>
<a name="ln1120">                }</a>
<a name="ln1121">            }</a>
<a name="ln1122"> </a>
<a name="ln1123">            if (you.species != SP_FELID</a>
<a name="ln1124">                &amp;&amp; you.see_cell_no_trans(target-&gt;pos())</a>
<a name="ln1125">                &amp;&amp; you.m_quiver.get_fire_item() != -1)</a>
<a name="ln1126">            {</a>
<a name="ln1127">                _add_tip(tip, &quot;[Shift + L-Click] Fire (%)&quot;);</a>
<a name="ln1128">                cmd.push_back(CMD_FIRE);</a>
<a name="ln1129">            }</a>
<a name="ln1130"> </a>
<a name="ln1131">            tip += _check_spell_evokable(target, cmd);</a>
<a name="ln1132">        }</a>
<a name="ln1133">        else if (!cell_is_solid(gc)) // no monster or player</a>
<a name="ln1134">        {</a>
<a name="ln1135">            if (adjacent(gc, you.pos()))</a>
<a name="ln1136">                _add_tip(tip, &quot;[L-Click] Move&quot;);</a>
<a name="ln1137">            else if (env.map_knowledge(gc).feat() != DNGN_UNSEEN</a>
<a name="ln1138">                     &amp;&amp; i_feel_safe())</a>
<a name="ln1139">            {</a>
<a name="ln1140">                _add_tip(tip, &quot;[L-Click] Travel&quot;);</a>
<a name="ln1141">            }</a>
<a name="ln1142">        }</a>
<a name="ln1143">        else if (feat_is_closed_door(grd(gc)))</a>
<a name="ln1144">        {</a>
<a name="ln1145">            if (!adjacent(gc, you.pos()) &amp;&amp; i_feel_safe())</a>
<a name="ln1146">                _add_tip(tip, &quot;[L-Click] Travel&quot;);</a>
<a name="ln1147"> </a>
<a name="ln1148">            _add_tip(tip, &quot;[L-Click] Open door (%)&quot;);</a>
<a name="ln1149">            cmd.push_back(CMD_OPEN_DOOR);</a>
<a name="ln1150">        }</a>
<a name="ln1151">    }</a>
<a name="ln1152"> </a>
<a name="ln1153">    // These apply both on the same square as the player's and elsewhere.</a>
<a name="ln1154">    if (!has_monster)</a>
<a name="ln1155">    {</a>
<a name="ln1156">        if (you.see_cell(gc) &amp;&amp; env.map_knowledge(gc).item())</a>
<a name="ln1157">        {</a>
<a name="ln1158">            const item_info * const item = env.map_knowledge(gc).item();</a>
<a name="ln1159">            if (item &amp;&amp; !item_is_stationary(*item))</a>
<a name="ln1160">            {</a>
<a name="ln1161">                _add_tip(tip, &quot;[L-Click] Pick up items (%)&quot;);</a>
<a name="ln1162">                cmd.push_back(CMD_PICKUP);</a>
<a name="ln1163">            }</a>
<a name="ln1164">        }</a>
<a name="ln1165"> </a>
<a name="ln1166">        const dungeon_feature_type feat = env.map_knowledge(gc).feat();</a>
<a name="ln1167">        const command_type dir = feat_stair_direction(feat);</a>
<a name="ln1168">        if (dir != CMD_NO_CMD)</a>
<a name="ln1169">        {</a>
<a name="ln1170">            _add_tip(tip, &quot;[Shift + L-Click] &quot;);</a>
<a name="ln1171">            if (feat == DNGN_ENTER_SHOP)</a>
<a name="ln1172">                tip += &quot;enter shop&quot;;</a>
<a name="ln1173">            else if (feat_is_altar(feat)</a>
<a name="ln1174">                     &amp;&amp; player_can_join_god(feat_altar_god(feat)))</a>
<a name="ln1175">            {</a>
<a name="ln1176">                tip += &quot;pray at altar&quot;;</a>
<a name="ln1177">            }</a>
<a name="ln1178">            else if (feat_is_gate(feat))</a>
<a name="ln1179">                tip += &quot;enter gate&quot;;</a>
<a name="ln1180">            else</a>
<a name="ln1181">                tip += &quot;use stairs&quot;;</a>
<a name="ln1182"> </a>
<a name="ln1183">            tip += &quot; (%)&quot;;</a>
<a name="ln1184">            cmd.push_back(dir);</a>
<a name="ln1185">        }</a>
<a name="ln1186">    }</a>
<a name="ln1187"> </a>
<a name="ln1188">    // Right-click.</a>
<a name="ln1189">    if (gc == you.pos())</a>
<a name="ln1190">    {</a>
<a name="ln1191">        const int o = you.visible_igrd(you.pos());</a>
<a name="ln1192">        if (o == NON_ITEM)</a>
<a name="ln1193">        {</a>
<a name="ln1194">            // if on stairs, travel them</a>
<a name="ln1195">            const dungeon_feature_type feat = grd(gc);</a>
<a name="ln1196">            if (feat_stair_direction(feat) == CMD_GO_DOWNSTAIRS</a>
<a name="ln1197">                || feat_stair_direction(feat) == CMD_GO_UPSTAIRS)</a>
<a name="ln1198">            {</a>
<a name="ln1199">                // XXX: wrong for golubria, shops?</a>
<a name="ln1200">                _add_tip(tip, &quot;[L-Click] Use stairs (%)&quot;);</a>
<a name="ln1201">                cmd.push_back(feat_stair_direction(feat));</a>
<a name="ln1202">            }</a>
<a name="ln1203">            else if (feat_is_altar(feat)</a>
<a name="ln1204">                     &amp;&amp; player_can_join_god(feat_altar_god(feat)))</a>
<a name="ln1205">            {</a>
<a name="ln1206">                _add_tip(tip, &quot;[L-Click] Pray at altar (%)&quot;);</a>
<a name="ln1207">                cmd.push_back(feat_stair_direction(feat));</a>
<a name="ln1208">            }</a>
<a name="ln1209">            else</a>
<a name="ln1210">            {</a>
<a name="ln1211">                // otherwise wait</a>
<a name="ln1212">                _add_tip(tip, &quot;[L-Click] Wait one turn (%)&quot;);</a>
<a name="ln1213">                cmd.push_back(CMD_WAIT);</a>
<a name="ln1214">            }</a>
<a name="ln1215">        }</a>
<a name="ln1216">        else</a>
<a name="ln1217">        {</a>
<a name="ln1218">            // pick up menu</a>
<a name="ln1219">            // this is already added by the code above</a>
<a name="ln1220">        }</a>
<a name="ln1221"> </a>
<a name="ln1222">        // Character overview.</a>
<a name="ln1223">        _add_tip(tip, &quot;[R-Click] Overview (%)&quot;);</a>
<a name="ln1224">        cmd.push_back(CMD_RESISTS_SCREEN);</a>
<a name="ln1225"> </a>
<a name="ln1226">        // Religion.</a>
<a name="ln1227">        if (!you_worship(GOD_NO_GOD))</a>
<a name="ln1228">        {</a>
<a name="ln1229">            _add_tip(tip, &quot;[Shift + R-Click] Religion (%)&quot;);</a>
<a name="ln1230">            cmd.push_back(CMD_DISPLAY_RELIGION);</a>
<a name="ln1231">        }</a>
<a name="ln1232">    }</a>
<a name="ln1233">    else if (you.see_cell(gc)</a>
<a name="ln1234">             &amp;&amp; env.map_knowledge(gc).feat() != DNGN_UNSEEN)</a>
<a name="ln1235">    {</a>
<a name="ln1236">        _add_tip(tip, &quot;[R-Click] Describe&quot;);</a>
<a name="ln1237">    }</a>
<a name="ln1238"> </a>
<a name="ln1239">    if (!tip.empty())</a>
<a name="ln1240">        insert_commands(tip, cmd, false);</a>
<a name="ln1241"> </a>
<a name="ln1242">    return true;</a>
<a name="ln1243">}</a>
<a name="ln1244"> </a>
<a name="ln1245">bool DungeonRegion::update_alt_text(string &amp;alt)</a>
<a name="ln1246">{</a>
<a name="ln1247">    if (mouse_control::current_mode() != MOUSE_MODE_COMMAND)</a>
<a name="ln1248">        return false;</a>
<a name="ln1249"> </a>
<a name="ln1250">    const coord_def &amp;gc = m_cursor[CURSOR_MOUSE];</a>
<a name="ln1251"> </a>
<a name="ln1252">    if (gc == NO_CURSOR)</a>
<a name="ln1253">        return false;</a>
<a name="ln1254">    if (!map_bounds(gc))</a>
<a name="ln1255">        return false;</a>
<a name="ln1256">    if (!env.map_knowledge(gc).seen())</a>
<a name="ln1257">        return false;</a>
<a name="ln1258">    if (m_last_clicked_grid == gc)</a>
<a name="ln1259">        return false;</a>
<a name="ln1260"> </a>
<a name="ln1261">    describe_info inf;</a>
<a name="ln1262">    dungeon_feature_type feat = env.map_knowledge(gc).feat();</a>
<a name="ln1263">    if (you.see_cell(gc))</a>
<a name="ln1264">        get_square_desc(gc, inf);</a>
<a name="ln1265">    else if (feat != DNGN_FLOOR &amp;&amp; !feat_is_wall(feat) &amp;&amp; !feat_is_tree(feat))</a>
<a name="ln1266">        get_feature_desc(gc, inf);</a>
<a name="ln1267">    else</a>
<a name="ln1268">    {</a>
<a name="ln1269">        // For plain floor, output the stash description.</a>
<a name="ln1270">        const string stash = get_stash_desc(gc);</a>
<a name="ln1271">        if (!stash.empty())</a>
<a name="ln1272">            inf.body &lt;&lt; &quot;\n&quot; &lt;&lt; stash;</a>
<a name="ln1273">    }</a>
<a name="ln1274"> </a>
<a name="ln1275">    alt = process_description(inf);</a>
<a name="ln1276"> </a>
<a name="ln1277">    // Suppress floor description</a>
<a name="ln1278">    if (alt == &quot;Floor.&quot;)</a>
<a name="ln1279">    {</a>
<a name="ln1280">        alt.clear();</a>
<a name="ln1281">        return false;</a>
<a name="ln1282">    }</a>
<a name="ln1283">    return true;</a>
<a name="ln1284">}</a>
<a name="ln1285"> </a>
<a name="ln1286">void DungeonRegion::clear_text_tags(text_tag_type type)</a>
<a name="ln1287">{</a>
<a name="ln1288">    m_tags[type].clear();</a>
<a name="ln1289">}</a>
<a name="ln1290"> </a>
<a name="ln1291">void DungeonRegion::add_text_tag(text_tag_type type, const string &amp;tag,</a>
<a name="ln1292">                                 const coord_def &amp;gc)</a>
<a name="ln1293">{</a>
<a name="ln1294">    TextTag t;</a>
<a name="ln1295">    t.tag = tag;</a>
<a name="ln1296">    t.gc  = gc;</a>
<a name="ln1297"> </a>
<a name="ln1298">    m_tags[type].push_back(t);</a>
<a name="ln1299">}</a>
<a name="ln1300"> </a>
<a name="ln1301">void DungeonRegion::add_overlay(const coord_def &amp;gc, int idx)</a>
<a name="ln1302">{</a>
<a name="ln1303">    tile_overlay over;</a>
<a name="ln1304">    over.gc  = gc;</a>
<a name="ln1305">    over.idx = idx;</a>
<a name="ln1306"> </a>
<a name="ln1307">    m_overlays.push_back(over);</a>
<a name="ln1308">    m_dirty = true;</a>
<a name="ln1309">}</a>
<a name="ln1310"> </a>
<a name="ln1311">void DungeonRegion::clear_overlays()</a>
<a name="ln1312">{</a>
<a name="ln1313">    m_overlays.clear();</a>
<a name="ln1314">    m_dirty = true;</a>
<a name="ln1315">}</a>
<a name="ln1316"> </a>
<a name="ln1317">#endif</a>

</code></pre>
<div class="balloon" rel="65"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v730/" target="_blank">V730</a> Not all members of a class are initialized inside the constructor. Consider inspecting: tile_iw, tile_ih.</p></div>
<div class="balloon" rel="163"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v730/" target="_blank">V730</a> Not all members of a class are initialized inside the constructor. Consider inspecting: type.</p></div>

<link rel="stylesheet" href="highlight.css">
<script src="highlight.pack.js"></script>
<script src="highlightjs-line-numbers.js"></script>
<script>hljs.initHighlightingOnLoad();</script>
<script>hljs.initLineNumbersOnLoad();</script>
<script>
  $(document).ready(function() {
      $('.balloon').each(function () {
          var bl = $(this);
          var line = bl.attr('rel');
          var text = $('a[name="ln'+line+'"]').text();

          var space_count = 0;
          for(var i = 0; i<text.length; i++){
              var char = text[i];
              if((char !== ' ')&&(char !== '\t'))break;
              if(char === '\t')space_count++;
              space_count++;
          }

          bl.css('margin-left', space_count*8);
          $('a[name="ln'+line+'"]').after(bl);
      });

      window.location = window.location;
  });
</script>
</body>
</html>
