
<html>
<head>

  <meta http-equiv="Content-Type" content="text/html; charset=US-ASCII" />
  <title>dungeon.cc</title>

  <link rel="stylesheet" href="../style.css"/>
  <script src="../jquery-3.2.1.min.js"></script>
</head>
<body>

<pre><code class = "cpp">
<a name="ln1">/**</a>
<a name="ln2"> * @file</a>
<a name="ln3"> * @brief Functions used when building new levels.</a>
<a name="ln4">**/</a>
<a name="ln5"> </a>
<a name="ln6">#include &quot;AppHdr.h&quot;</a>
<a name="ln7"> </a>
<a name="ln8">#include &quot;dungeon.h&quot;</a>
<a name="ln9"> </a>
<a name="ln10">#include &lt;algorithm&gt;</a>
<a name="ln11">#include &lt;cmath&gt;</a>
<a name="ln12">#include &lt;cstdio&gt;</a>
<a name="ln13">#include &lt;cstdlib&gt;</a>
<a name="ln14">#include &lt;ctime&gt;</a>
<a name="ln15">#include &lt;list&gt;</a>
<a name="ln16">#include &lt;map&gt;</a>
<a name="ln17">#include &lt;set&gt;</a>
<a name="ln18">#include &lt;sstream&gt;</a>
<a name="ln19"> </a>
<a name="ln20">#include &quot;abyss.h&quot;</a>
<a name="ln21">#include &quot;acquire.h&quot;</a>
<a name="ln22">#include &quot;artefact.h&quot;</a>
<a name="ln23">#include &quot;branch.h&quot;</a>
<a name="ln24">#include &quot;butcher.h&quot;</a>
<a name="ln25">#include &quot;chardump.h&quot;</a>
<a name="ln26">#include &quot;cloud.h&quot;</a>
<a name="ln27">#include &quot;coordit.h&quot;</a>
<a name="ln28">#include &quot;describe.h&quot;</a>
<a name="ln29">#include &quot;directn.h&quot;</a>
<a name="ln30">#include &quot;dbg-maps.h&quot;</a>
<a name="ln31">#include &quot;dbg-scan.h&quot;</a>
<a name="ln32">#include &quot;dgn-delve.h&quot;</a>
<a name="ln33">#include &quot;dgn-height.h&quot;</a>
<a name="ln34">#include &quot;dgn-overview.h&quot;</a>
<a name="ln35">#include &quot;dgn-shoals.h&quot;</a>
<a name="ln36">#include &quot;end.h&quot;</a>
<a name="ln37">#include &quot;files.h&quot;</a>
<a name="ln38">#include &quot;flood-find.h&quot;</a>
<a name="ln39">#include &quot;ghost.h&quot;</a>
<a name="ln40">#include &quot;god-passive.h&quot;</a>
<a name="ln41">#include &quot;item-name.h&quot;</a>
<a name="ln42">#include &quot;item-prop.h&quot;</a>
<a name="ln43">#include &quot;item-status-flag-type.h&quot;</a>
<a name="ln44">#include &quot;items.h&quot;</a>
<a name="ln45">#include &quot;lev-pand.h&quot;</a>
<a name="ln46">#include &quot;libutil.h&quot;</a>
<a name="ln47">#include &quot;mapmark.h&quot;</a>
<a name="ln48">#include &quot;maps.h&quot;</a>
<a name="ln49">#include &quot;message.h&quot;</a>
<a name="ln50">#include &quot;mon-death.h&quot;</a>
<a name="ln51">#include &quot;mon-pick.h&quot;</a>
<a name="ln52">#include &quot;mon-place.h&quot;</a>
<a name="ln53">#include &quot;mon-poly.h&quot;</a>
<a name="ln54">#include &quot;nearby-danger.h&quot;</a>
<a name="ln55">#include &quot;notes.h&quot;</a>
<a name="ln56">#include &quot;place.h&quot;</a>
<a name="ln57">#include &quot;randbook.h&quot;</a>
<a name="ln58">#include &quot;random.h&quot;</a>
<a name="ln59">#include &quot;religion.h&quot;</a>
<a name="ln60">#include &quot;rot.h&quot;</a>
<a name="ln61">#include &quot;show.h&quot;</a>
<a name="ln62">#include &quot;spl-transloc.h&quot;</a>
<a name="ln63">#include &quot;stairs.h&quot;</a>
<a name="ln64">#include &quot;state.h&quot;</a>
<a name="ln65">#include &quot;stringutil.h&quot;</a>
<a name="ln66">#include &quot;rltiles/tiledef-dngn.h&quot;</a>
<a name="ln67">#include &quot;tilepick.h&quot;</a>
<a name="ln68">#include &quot;tileview.h&quot;</a>
<a name="ln69">#include &quot;timed-effects.h&quot;</a>
<a name="ln70">#include &quot;traps.h&quot;</a>
<a name="ln71"> </a>
<a name="ln72">#ifdef DEBUG_DIAGNOSTICS</a>
<a name="ln73">#define DEBUG_TEMPLES</a>
<a name="ln74">#endif</a>
<a name="ln75"> </a>
<a name="ln76">#ifdef WIZARD</a>
<a name="ln77">#include &quot;cio.h&quot; // for cancellable_get_line()</a>
<a name="ln78">#endif</a>
<a name="ln79"> </a>
<a name="ln80">// DUNGEON BUILDERS</a>
<a name="ln81">static bool _build_level_vetoable(bool enable_random_maps);</a>
<a name="ln82">static void _build_dungeon_level();</a>
<a name="ln83">static bool _valid_dungeon_level();</a>
<a name="ln84"> </a>
<a name="ln85">static bool _builder_by_type();</a>
<a name="ln86">static bool _builder_normal();</a>
<a name="ln87">static void _builder_items();</a>
<a name="ln88">static void _builder_monsters();</a>
<a name="ln89">static coord_def _place_specific_feature(dungeon_feature_type feat);</a>
<a name="ln90">static void _place_specific_trap(const coord_def&amp; where, trap_spec* spec,</a>
<a name="ln91">                                 int charges = 0);</a>
<a name="ln92">static void _place_branch_entrances(bool use_vaults);</a>
<a name="ln93">static void _place_extra_vaults();</a>
<a name="ln94">static void _place_chance_vaults();</a>
<a name="ln95">static void _place_minivaults();</a>
<a name="ln96">static int _place_uniques();</a>
<a name="ln97">static void _place_traps();</a>
<a name="ln98">static void _prepare_water();</a>
<a name="ln99">static void _check_doors();</a>
<a name="ln100"> </a>
<a name="ln101">static void _add_plant_clumps(int rarity, int clump_sparseness,</a>
<a name="ln102">                              int clump_radius);</a>
<a name="ln103"> </a>
<a name="ln104">static void _pick_float_exits(vault_placement &amp;place,</a>
<a name="ln105">                              vector&lt;coord_def&gt; &amp;targets);</a>
<a name="ln106">static bool _feat_is_wall_floor_liquid(dungeon_feature_type);</a>
<a name="ln107">static bool _connect_spotty(const coord_def&amp; from,</a>
<a name="ln108">                            bool (*overwriteable)(dungeon_feature_type) = nullptr);</a>
<a name="ln109">static bool _connect_vault_exit(const coord_def&amp; exit);</a>
<a name="ln110"> </a>
<a name="ln111">// VAULT FUNCTIONS</a>
<a name="ln112">static const vault_placement *</a>
<a name="ln113">_build_secondary_vault(const map_def *vault,</a>
<a name="ln114">                       bool check_collisions = true,</a>
<a name="ln115">                       bool make_no_exits = false,</a>
<a name="ln116">                       const coord_def &amp;where = coord_def(-1, -1));</a>
<a name="ln117"> </a>
<a name="ln118">static const vault_placement *_build_primary_vault(const map_def *vault);</a>
<a name="ln119"> </a>
<a name="ln120">static void _build_postvault_level(vault_placement &amp;place);</a>
<a name="ln121">static const vault_placement *</a>
<a name="ln122">_build_vault_impl(const map_def *vault,</a>
<a name="ln123">                  bool build_only = false,</a>
<a name="ln124">                  bool check_collisions = false,</a>
<a name="ln125">                  bool make_no_exits = false,</a>
<a name="ln126">                  const coord_def &amp;where = coord_def(-1, -1));</a>
<a name="ln127"> </a>
<a name="ln128">static void _vault_grid(vault_placement &amp;,</a>
<a name="ln129">                        int vgrid,</a>
<a name="ln130">                        const coord_def&amp; where,</a>
<a name="ln131">                        keyed_mapspec *mapsp);</a>
<a name="ln132">static void _vault_grid_mons(vault_placement &amp;,</a>
<a name="ln133">                        int vgrid,</a>
<a name="ln134">                        const coord_def&amp; where,</a>
<a name="ln135">                        keyed_mapspec *mapsp);</a>
<a name="ln136">static void _vault_grid_glyph(vault_placement &amp;place, const coord_def&amp; where,</a>
<a name="ln137">                              int vgrid);</a>
<a name="ln138">static void _vault_grid_mapspec(vault_placement &amp;place, const coord_def&amp; where,</a>
<a name="ln139">                                keyed_mapspec&amp; mapsp);</a>
<a name="ln140">static dungeon_feature_type _vault_inspect(vault_placement &amp;place,</a>
<a name="ln141">                                           int vgrid, keyed_mapspec *mapsp);</a>
<a name="ln142">static dungeon_feature_type _vault_inspect_mapspec(vault_placement &amp;place,</a>
<a name="ln143">                                                   keyed_mapspec&amp; mapsp);</a>
<a name="ln144">static dungeon_feature_type _vault_inspect_glyph(int vgrid);</a>
<a name="ln145"> </a>
<a name="ln146">static const map_def *_dgn_random_map_for_place(bool minivault);</a>
<a name="ln147">static void _dgn_load_colour_grid();</a>
<a name="ln148">static void _dgn_map_colour_fixup();</a>
<a name="ln149"> </a>
<a name="ln150">static void _dgn_unregister_vault(const map_def &amp;map);</a>
<a name="ln151">static void _remember_vault_placement(const vault_placement &amp;place);</a>
<a name="ln152"> </a>
<a name="ln153">// Returns true if the given square is okay for use by any character,</a>
<a name="ln154">// but always false for squares in non-transparent vaults.</a>
<a name="ln155">static bool _dgn_square_is_passable(const coord_def &amp;c);</a>
<a name="ln156"> </a>
<a name="ln157">static coord_def _dgn_random_point_in_bounds(</a>
<a name="ln158">    dungeon_feature_type searchfeat,</a>
<a name="ln159">    uint32_t mapmask = MMT_VAULT,</a>
<a name="ln160">    dungeon_feature_type adjacent = DNGN_UNSEEN,</a>
<a name="ln161">    bool monster_free = false,</a>
<a name="ln162">    int tries = 1500);</a>
<a name="ln163"> </a>
<a name="ln164">// ALTAR FUNCTIONS</a>
<a name="ln165">static int                  _setup_temple_altars(CrawlHashTable &amp;temple);</a>
<a name="ln166">static dungeon_feature_type _pick_temple_altar();</a>
<a name="ln167">static dungeon_feature_type _pick_an_altar();</a>
<a name="ln168"> </a>
<a name="ln169">static vector&lt;god_type&gt; _temple_altar_list;</a>
<a name="ln170">static CrawlHashTable*       _current_temple_hash = nullptr; // XXX: hack!</a>
<a name="ln171"> </a>
<a name="ln172">// MISC FUNCTIONS</a>
<a name="ln173">static void _dgn_set_floor_colours();</a>
<a name="ln174">static bool _fixup_interlevel_connectivity();</a>
<a name="ln175">static void _slime_connectivity_fixup();</a>
<a name="ln176"> </a>
<a name="ln177">static void _dgn_postprocess_level();</a>
<a name="ln178">static void _calc_density();</a>
<a name="ln179">static void _mark_solid_squares();</a>
<a name="ln180"> </a>
<a name="ln181">//////////////////////////////////////////////////////////////////////////</a>
<a name="ln182">// Static data</a>
<a name="ln183"> </a>
<a name="ln184">// A mask of vaults and vault-specific flags.</a>
<a name="ln185">vector&lt;vault_placement&gt; Temp_Vaults;</a>
<a name="ln186">static FixedBitVector&lt;NUM_MONSTERS&gt; temp_unique_creatures;</a>
<a name="ln187">static FixedVector&lt;unique_item_status_type, MAX_UNRANDARTS&gt; temp_unique_items;</a>
<a name="ln188"> </a>
<a name="ln189">const map_bitmask *Vault_Placement_Mask = nullptr;</a>
<a name="ln190"> </a>
<a name="ln191">static bool use_random_maps = true;</a>
<a name="ln192">static bool dgn_check_connectivity = false;</a>
<a name="ln193">static int  dgn_zones = 0;</a>
<a name="ln194"> </a>
<a name="ln195">#ifdef DEBUG_STATISTICS</a>
<a name="ln196">static vector&lt;string&gt; _you_all_vault_list;</a>
<a name="ln197">#endif</a>
<a name="ln198"> </a>
<a name="ln199">struct coloured_feature</a>
<a name="ln200">{</a>
<a name="ln201">    dungeon_feature_type feature;</a>
<a name="ln202">    int                  colour;</a>
<a name="ln203"> </a>
<a name="ln204">    coloured_feature() : feature(DNGN_UNSEEN), colour(BLACK) { }</a>
<a name="ln205">    coloured_feature(dungeon_feature_type f, int c)</a>
<a name="ln206">        : feature(f), colour(c)</a>
<a name="ln207">    {</a>
<a name="ln208">    }</a>
<a name="ln209">};</a>
<a name="ln210"> </a>
<a name="ln211">struct dgn_colour_override_manager</a>
<a name="ln212">{</a>
<a name="ln213">    dgn_colour_override_manager()</a>
<a name="ln214">    {</a>
<a name="ln215">        _dgn_load_colour_grid();</a>
<a name="ln216">    }</a>
<a name="ln217"> </a>
<a name="ln218">    ~dgn_colour_override_manager()</a>
<a name="ln219">    {</a>
<a name="ln220">        _dgn_map_colour_fixup();</a>
<a name="ln221">    }</a>
<a name="ln222">};</a>
<a name="ln223"> </a>
<a name="ln224">typedef FixedArray&lt; coloured_feature, GXM, GYM &gt; dungeon_colour_grid;</a>
<a name="ln225">static unique_ptr&lt;dungeon_colour_grid&gt; dgn_colour_grid;</a>
<a name="ln226"> </a>
<a name="ln227">static string branch_epilogues[NUM_BRANCHES];</a>
<a name="ln228"> </a>
<a name="ln229">set&lt;string&gt; &amp;get_uniq_map_tags()</a>
<a name="ln230">{</a>
<a name="ln231">    if (you.where_are_you == BRANCH_ABYSS)</a>
<a name="ln232">        return you.uniq_map_tags_abyss;</a>
<a name="ln233">    else</a>
<a name="ln234">        return you.uniq_map_tags;</a>
<a name="ln235">}</a>
<a name="ln236"> </a>
<a name="ln237">set&lt;string&gt; &amp;get_uniq_map_names()</a>
<a name="ln238">{</a>
<a name="ln239">    if (you.where_are_you == BRANCH_ABYSS)</a>
<a name="ln240">        return you.uniq_map_names_abyss;</a>
<a name="ln241">    else</a>
<a name="ln242">        return you.uniq_map_names;</a>
<a name="ln243">}</a>
<a name="ln244"> </a>
<a name="ln245">/**********************************************************************</a>
<a name="ln246"> * builder() - kickoff for the dungeon generator.</a>
<a name="ln247"> *********************************************************************/</a>
<a name="ln248">bool builder(bool enable_random_maps)</a>
<a name="ln249">{</a>
<a name="ln250">#ifndef DEBUG_FULL_DUNGEON_SPAM</a>
<a name="ln251">    // hide builder debug spam by default -- this is still collected by a tee</a>
<a name="ln252">    // and accessible via &amp;ctrl-l without this #define.</a>
<a name="ln253">    no_messages quiet(MSGCH_DIAGNOSTICS);</a>
<a name="ln254">#endif</a>
<a name="ln255"> </a>
<a name="ln256">    // Re-check whether we're in a valid place, it leads to obscure errors</a>
<a name="ln257">    // otherwise.</a>
<a name="ln258">    ASSERT_RANGE(you.where_are_you, 0, NUM_BRANCHES);</a>
<a name="ln259">    ASSERT_RANGE(you.depth, 0 + 1, brdepth[you.where_are_you] + 1);</a>
<a name="ln260"> </a>
<a name="ln261">    const set&lt;string&gt; uniq_tags = get_uniq_map_tags();</a>
<a name="ln262">    const set&lt;string&gt; uniq_names = get_uniq_map_names();</a>
<a name="ln263"> </a>
<a name="ln264">    // For normal cases, this should already be taken care of by enter_level.</a>
<a name="ln265">    // However, we want to be really sure that the builder isn't ever run with</a>
<a name="ln266">    // the player at a real position on the level, e.g. during debug code or</a>
<a name="ln267">    // tests, because that can impact levelgen (somehow) and cause seed</a>
<a name="ln268">    // divergence. (I think it's because actor position can impact item gen,</a>
<a name="ln269">    // but it's a bit hard to track down.)</a>
<a name="ln270">    unwind_var&lt;coord_def&gt; saved_position(you.position);</a>
<a name="ln271">    you.position.reset();</a>
<a name="ln272"> </a>
<a name="ln273">    // Save a copy of unique creatures for vetoes.</a>
<a name="ln274">    temp_unique_creatures = you.unique_creatures;</a>
<a name="ln275">    // And unrands</a>
<a name="ln276">    temp_unique_items = you.unique_items;</a>
<a name="ln277"> </a>
<a name="ln278">    unwind_bool levelgen(crawl_state.generating_level, true);</a>
<a name="ln279">    rng::generator levelgen_rng(you.where_are_you);</a>
<a name="ln280"> </a>
<a name="ln281">#ifdef DEBUG_DIAGNOSTICS // no point in enabling unless dprf works</a>
<a name="ln282">    CrawlHashTable &amp;debug_logs = you.props[&quot;debug_builder_logs&quot;].get_table();</a>
<a name="ln283">    string &amp;cur_level_log = debug_logs[level_id::current().describe()].get_string();</a>
<a name="ln284">    message_tee debug_messages(cur_level_log);</a>
<a name="ln285">    debug_messages.append_line(make_stringf(&quot;Builder log for %s:&quot;,</a>
<a name="ln286">        level_id::current().describe().c_str()));</a>
<a name="ln287">#endif</a>
<a name="ln288"> </a>
<a name="ln289">    // N tries to build the level, after which we bail with a capital B.</a>
<a name="ln290">    int tries = 50;</a>
<a name="ln291">    while (tries-- &gt; 0)</a>
<a name="ln292">    {</a>
<a name="ln293">        // If we're getting low on available retries, disable random vaults</a>
<a name="ln294">        // and minivaults (special levels will still be placed).</a>
<a name="ln295">        if (tries &lt; 5)</a>
<a name="ln296">            enable_random_maps = false;</a>
<a name="ln297"> </a>
<a name="ln298">        try</a>
<a name="ln299">        {</a>
<a name="ln300">            if (_build_level_vetoable(enable_random_maps))</a>
<a name="ln301">                return true;</a>
<a name="ln302">        }</a>
<a name="ln303">        catch (map_load_exception &amp;mload)</a>
<a name="ln304">        {</a>
<a name="ln305">            mprf(MSGCH_ERROR, &quot;Failed to load map, reloading all maps (%s).&quot;,</a>
<a name="ln306">                 mload.what());</a>
<a name="ln307">            reread_maps();</a>
<a name="ln308">        }</a>
<a name="ln309"> </a>
<a name="ln310">        get_uniq_map_tags() = uniq_tags;</a>
<a name="ln311">        get_uniq_map_names() = uniq_names;</a>
<a name="ln312">    }</a>
<a name="ln313"> </a>
<a name="ln314">    if (!crawl_state.map_stat_gen &amp;&amp; !crawl_state.obj_stat_gen)</a>
<a name="ln315">    {</a>
<a name="ln316">        // Failed to build level, bail out.</a>
<a name="ln317">        if (crawl_state.need_save)</a>
<a name="ln318">        {</a>
<a name="ln319">            save_game(true,</a>
<a name="ln320">                  make_stringf(&quot;Unable to generate level for '%s'!&quot;,</a>
<a name="ln321">                               level_id::current().describe().c_str()).c_str());</a>
<a name="ln322">        }</a>
<a name="ln323">        else</a>
<a name="ln324">        {</a>
<a name="ln325">            die(&quot;Unable to generate level for '%s'!&quot;,</a>
<a name="ln326">                level_id::current().describe().c_str());</a>
<a name="ln327">        }</a>
<a name="ln328">    }</a>
<a name="ln329"> </a>
<a name="ln330">    env.level_layout_types.clear();</a>
<a name="ln331">    return false;</a>
<a name="ln332">}</a>
<a name="ln333"> </a>
<a name="ln334">static bool _build_level_vetoable(bool enable_random_maps)</a>
<a name="ln335">{</a>
<a name="ln336">#ifdef DEBUG_STATISTICS</a>
<a name="ln337">    mapstat_report_map_build_start();</a>
<a name="ln338">#endif</a>
<a name="ln339"> </a>
<a name="ln340">    dgn_reset_level(enable_random_maps);</a>
<a name="ln341"> </a>
<a name="ln342">    if (player_in_branch(BRANCH_TEMPLE))</a>
<a name="ln343">        _setup_temple_altars(you.props);</a>
<a name="ln344"> </a>
<a name="ln345">    try</a>
<a name="ln346">    {</a>
<a name="ln347">        _build_dungeon_level();</a>
<a name="ln348">    }</a>
<a name="ln349">    catch (dgn_veto_exception&amp; e)</a>
<a name="ln350">    {</a>
<a name="ln351">        dprf(DIAG_DNGN, &quot;&lt;white&gt;VETO&lt;/white&gt;: %s: %s&quot;,</a>
<a name="ln352">             level_id::current().describe().c_str(), e.what());</a>
<a name="ln353">#ifdef DEBUG_STATISTICS</a>
<a name="ln354">        mapstat_report_map_veto(e.what());</a>
<a name="ln355">#endif</a>
<a name="ln356">        // try not to lose any ghosts that have been placed</a>
<a name="ln357">        save_ghosts(ghost_demon::find_ghosts(false), false);</a>
<a name="ln358">        return false;</a>
<a name="ln359">    }</a>
<a name="ln360"> </a>
<a name="ln361">    _dgn_set_floor_colours();</a>
<a name="ln362"> </a>
<a name="ln363">    if (crawl_state.game_standard_levelgen()</a>
<a name="ln364">        &amp;&amp; !_valid_dungeon_level())</a>
<a name="ln365">    {</a>
<a name="ln366">        return false;</a>
<a name="ln367">    }</a>
<a name="ln368"> </a>
<a name="ln369">#ifdef DEBUG_MONS_SCAN</a>
<a name="ln370">    // If debug_mons_scan() finds a problem while crawl_state.generating_level is</a>
<a name="ln371">    // still true then it will announce that a problem was caused</a>
<a name="ln372">    // during level generation.</a>
<a name="ln373">    debug_mons_scan();</a>
<a name="ln374">#endif</a>
<a name="ln375"> </a>
<a name="ln376">    if (!env.level_build_method.empty()</a>
<a name="ln377">        &amp;&amp; env.level_build_method[0] == ' ')</a>
<a name="ln378">    {</a>
<a name="ln379">        env.level_build_method = env.level_build_method.substr(1);</a>
<a name="ln380">    }</a>
<a name="ln381"> </a>
<a name="ln382">    string level_layout_type = comma_separated_line(</a>
<a name="ln383">        env.level_layout_types.begin(),</a>
<a name="ln384">        env.level_layout_types.end(), &quot;, &quot;);</a>
<a name="ln385"> </a>
<a name="ln386">    // Save information in the level's properties hash table</a>
<a name="ln387">    // so we can include it in crash reports.</a>
<a name="ln388">    env.properties[BUILD_METHOD_KEY] = env.level_build_method;</a>
<a name="ln389">    env.properties[LAYOUT_TYPE_KEY]  = level_layout_type;</a>
<a name="ln390"> </a>
<a name="ln391">    _dgn_postprocess_level();</a>
<a name="ln392"> </a>
<a name="ln393">    env.level_layout_types.clear();</a>
<a name="ln394">    env.level_uniq_maps.clear();</a>
<a name="ln395">    env.level_uniq_map_tags.clear();</a>
<a name="ln396">    _dgn_map_colour_fixup();</a>
<a name="ln397"> </a>
<a name="ln398">    // Call the branch epilogue, if any.</a>
<a name="ln399">    if (!branch_epilogues[you.where_are_you].empty())</a>
<a name="ln400">        if (!dlua.callfn(branch_epilogues[you.where_are_you].c_str(), 0, 0))</a>
<a name="ln401">        {</a>
<a name="ln402">            mprf(MSGCH_ERROR, &quot;branch epilogue for %s failed: %s&quot;,</a>
<a name="ln403">                              level_id::current().describe().c_str(),</a>
<a name="ln404">                              dlua.error.c_str());</a>
<a name="ln405">            return false;</a>
<a name="ln406">        }</a>
<a name="ln407"> </a>
<a name="ln408">    // Discard any Lua chunks we loaded.</a>
<a name="ln409">    strip_all_maps();</a>
<a name="ln410"> </a>
<a name="ln411">    check_map_validity();</a>
<a name="ln412"> </a>
<a name="ln413">#ifdef DEBUG_STATISTICS</a>
<a name="ln414">    for (auto vault : _you_all_vault_list)</a>
<a name="ln415">        mapstat_report_map_success(vault);</a>
<a name="ln416">#endif</a>
<a name="ln417"> </a>
<a name="ln418">    return true;</a>
<a name="ln419">}</a>
<a name="ln420"> </a>
<a name="ln421">// Things that are bugs where we want to assert rather than to sweep it under</a>
<a name="ln422">// the rug with a veto.</a>
<a name="ln423">static void _builder_assertions()</a>
<a name="ln424">{</a>
<a name="ln425">#ifdef ASSERTS</a>
<a name="ln426">    for (rectangle_iterator ri(0); ri; ++ri)</a>
<a name="ln427">        if (!in_bounds(*ri))</a>
<a name="ln428">            if (!feat_is_valid_border(grd(*ri)))</a>
<a name="ln429">            {</a>
<a name="ln430">                die(&quot;invalid map border at (%d,%d): %s&quot;, ri-&gt;x, ri-&gt;y,</a>
<a name="ln431">                    dungeon_feature_name(grd(*ri)));</a>
<a name="ln432">            }</a>
<a name="ln433">#endif</a>
<a name="ln434">}</a>
<a name="ln435"> </a>
<a name="ln436">/**</a>
<a name="ln437"> * Place a transporter and set its destination.</a>
<a name="ln438"> *</a>
<a name="ln439"> * @param pos     The position of the transporter</a>
<a name="ln440"> * @param dest    The position the transporter destination.</a>
<a name="ln441"> **/</a>
<a name="ln442">void dgn_place_transporter(const coord_def &amp;pos, const coord_def &amp;dest)</a>
<a name="ln443">{</a>
<a name="ln444">    ASSERT(pos != dest);</a>
<a name="ln445"> </a>
<a name="ln446">    env.markers.add(new map_position_marker(pos, DNGN_TRANSPORTER, dest));</a>
<a name="ln447">    env.markers.clear_need_activate();</a>
<a name="ln448">    dungeon_terrain_changed(pos, DNGN_TRANSPORTER, false, true);</a>
<a name="ln449">    dungeon_terrain_changed(dest, DNGN_TRANSPORTER_LANDING, false, true);</a>
<a name="ln450">}</a>
<a name="ln451"> </a>
<a name="ln452">/**</a>
<a name="ln453"> * Create transporters on the current level based on transporter markers. This</a>
<a name="ln454"> * does checks for duplicate transporter destinations, transporters with no</a>
<a name="ln455"> * destinations, and unused transporter destinations.</a>
<a name="ln456"> *</a>
<a name="ln457"> * @returns True if no transporter placement errors were found, false</a>
<a name="ln458"> *          otherwise.</a>
<a name="ln459"> **/</a>
<a name="ln460">bool dgn_make_transporters_from_markers()</a>
<a name="ln461">{</a>
<a name="ln462">    bool no_errors = true;</a>
<a name="ln463"> </a>
<a name="ln464">    // Find transporter destination markers and ensure no duplicates.</a>
<a name="ln465">    const vector&lt;map_marker*&gt; dest_markers =</a>
<a name="ln466">        find_markers_by_prop(TRANSPORTER_DEST_NAME_PROP);</a>
<a name="ln467">    map&lt;string, map_marker *&gt; dest_map;</a>
<a name="ln468">    for (auto dm : dest_markers)</a>
<a name="ln469">    {</a>
<a name="ln470">        const string name = dm-&gt;property(TRANSPORTER_DEST_NAME_PROP);</a>
<a name="ln471">        if (dest_map.find(name) != dest_map.end())</a>
<a name="ln472">        {</a>
<a name="ln473">            mprf(MSGCH_ERROR, &quot;Multiple locations with transporter &quot;</a>
<a name="ln474">                 &quot;destination name %s.&quot;, name.c_str());</a>
<a name="ln475">            no_errors = false;</a>
<a name="ln476">            continue;</a>
<a name="ln477">        }</a>
<a name="ln478">        dest_map[name] = dm;</a>
<a name="ln479">    }</a>
<a name="ln480"> </a>
<a name="ln481">    // Place transporters.</a>
<a name="ln482">    const vector&lt;map_marker*&gt; trans_markers =</a>
<a name="ln483">        find_markers_by_prop(TRANSPORTER_NAME_PROP);</a>
<a name="ln484">    map&lt;string, bool&gt; used_dest_map;</a>
<a name="ln485">    for (auto tm : trans_markers)</a>
<a name="ln486">    {</a>
<a name="ln487">        const string name = tm-&gt;property(TRANSPORTER_NAME_PROP);</a>
<a name="ln488">        if (dest_map.find(name) == dest_map.end())</a>
<a name="ln489">        {</a>
<a name="ln490">            mprf(MSGCH_ERROR, &quot;Transporter with name %s has no corresponding &quot;</a>
<a name="ln491">                 &quot;destination marker.&quot;, name.c_str());</a>
<a name="ln492">            no_errors = false;</a>
<a name="ln493">            continue;</a>
<a name="ln494">        }</a>
<a name="ln495">        dgn_place_transporter(tm-&gt;pos, dest_map[name]-&gt;pos);</a>
<a name="ln496">        env.markers.remove(tm);</a>
<a name="ln497">        used_dest_map[name] = true;</a>
<a name="ln498">    }</a>
<a name="ln499"> </a>
<a name="ln500">    // Clean up any destination markers.</a>
<a name="ln501">    for (auto dm : dest_markers)</a>
<a name="ln502">    {</a>
<a name="ln503">        const string name = dm-&gt;property(TRANSPORTER_DEST_NAME_PROP);</a>
<a name="ln504">        if (used_dest_map[name])</a>
<a name="ln505">            env.markers.remove(dm);</a>
<a name="ln506">        else</a>
<a name="ln507">        {</a>
<a name="ln508">            mprf(MSGCH_ERROR, &quot;Unused transporter destination with name %s.&quot;,</a>
<a name="ln509">                 name.c_str());</a>
<a name="ln510">            no_errors = false;</a>
<a name="ln511">        }</a>
<a name="ln512">    }</a>
<a name="ln513"> </a>
<a name="ln514">    return no_errors;</a>
<a name="ln515">}</a>
<a name="ln516"> </a>
<a name="ln517">// Should be called after a level is constructed to perform any final</a>
<a name="ln518">// fixups.</a>
<a name="ln519">static void _dgn_postprocess_level()</a>
<a name="ln520">{</a>
<a name="ln521">    shoals_postprocess_level();</a>
<a name="ln522">    _builder_assertions();</a>
<a name="ln523">    _calc_density();</a>
<a name="ln524">    _mark_solid_squares();</a>
<a name="ln525">}</a>
<a name="ln526"> </a>
<a name="ln527">void dgn_clear_vault_placements()</a>
<a name="ln528">{</a>
<a name="ln529">    env.level_vaults.clear();</a>
<a name="ln530">}</a>
<a name="ln531"> </a>
<a name="ln532">// Removes vaults that are not referenced in the map index mask from</a>
<a name="ln533">// the level_vaults array.</a>
<a name="ln534">void dgn_erase_unused_vault_placements()</a>
<a name="ln535">{</a>
<a name="ln536">    set&lt;int&gt; referenced_vault_indexes;</a>
<a name="ln537">    for (rectangle_iterator ri(MAPGEN_BORDER); ri; ++ri)</a>
<a name="ln538">    {</a>
<a name="ln539">        const int map_index = env.level_map_ids(*ri);</a>
<a name="ln540">        if (map_index != INVALID_MAP_INDEX)</a>
<a name="ln541">            referenced_vault_indexes.insert(map_index);</a>
<a name="ln542">    }</a>
<a name="ln543"> </a>
<a name="ln544">    // Walk backwards and toss unused vaults.</a>
<a name="ln545">    map&lt;int, int&gt; new_vault_index_map;</a>
<a name="ln546">    const int nvaults = env.level_vaults.size();</a>
<a name="ln547">    for (int i = nvaults - 1; i &gt;= 0; --i)</a>
<a name="ln548">    {</a>
<a name="ln549">        if (!referenced_vault_indexes.count(i))</a>
<a name="ln550">        {</a>
<a name="ln551">            {</a>
<a name="ln552">                auto &amp;vp = env.level_vaults[i];</a>
<a name="ln553">                // Unreferenced vault, blow it away</a>
<a name="ln554">                dprf(DIAG_DNGN, &quot;Removing references to unused map #%d)&quot;</a>
<a name="ln555">                        &quot; '%s' (%d,%d) (%d,%d)&quot;,</a>
<a name="ln556">                        i, vp-&gt;map.name.c_str(), vp-&gt;pos.x, vp-&gt;pos.y,</a>
<a name="ln557">                        vp-&gt;size.x, vp-&gt;size.y);</a>
<a name="ln558"> </a>
<a name="ln559">                if (!vp-&gt;seen)</a>
<a name="ln560">                {</a>
<a name="ln561">                    dprf(DIAG_DNGN, &quot;Unregistering unseen vault: %s&quot;,</a>
<a name="ln562">                            vp-&gt;map.name.c_str());</a>
<a name="ln563">                    _dgn_unregister_vault(vp-&gt;map);</a>
<a name="ln564">                }</a>
<a name="ln565">            }</a>
<a name="ln566"> </a>
<a name="ln567">            env.level_vaults.erase(env.level_vaults.begin() + i);</a>
<a name="ln568"> </a>
<a name="ln569">            // Fix new indexes for all higher indexed vaults that are</a>
<a name="ln570">            // still referenced.</a>
<a name="ln571">            for (int j = i + 1; j &lt; nvaults; ++j)</a>
<a name="ln572">                if (int *newidx = map_find(new_vault_index_map, j))</a>
<a name="ln573">                    --*newidx;</a>
<a name="ln574">        }</a>
<a name="ln575">        else</a>
<a name="ln576">        {</a>
<a name="ln577">            // Vault is still referenced, make a note of this index.</a>
<a name="ln578">            new_vault_index_map[i] = i;</a>
<a name="ln579">        }</a>
<a name="ln580">    }</a>
<a name="ln581"> </a>
<a name="ln582">    // Finally, update the index map.</a>
<a name="ln583">    for (rectangle_iterator ri(MAPGEN_BORDER); ri; ++ri)</a>
<a name="ln584">    {</a>
<a name="ln585">        const int map_index = env.level_map_ids(*ri);</a>
<a name="ln586">        if (map_index != INVALID_MAP_INDEX)</a>
<a name="ln587">        {</a>
<a name="ln588">            if (int *newidx = map_find(new_vault_index_map, map_index))</a>
<a name="ln589">                env.level_map_ids(*ri) = *newidx;</a>
<a name="ln590">        }</a>
<a name="ln591">    }</a>
<a name="ln592"> </a>
<a name="ln593">#ifdef DEBUG_ABYSS</a>
<a name="ln594">    dprf(DIAG_DNGN, &quot;Extant vaults on level: %d&quot;,</a>
<a name="ln595">         (int) env.level_vaults.size());</a>
<a name="ln596">    int i = 0;</a>
<a name="ln597">    for (auto &amp;vp : env.level_vaults)</a>
<a name="ln598">    {</a>
<a name="ln599">        dprf(DIAG_DNGN, &quot;%d) %s (%d,%d) size (%d,%d)&quot;,</a>
<a name="ln600">             i++, vp-&gt;map.name.c_str(), vp-&gt;pos.x, vp-&gt;pos.y,</a>
<a name="ln601">             vp-&gt;size.x, vp-&gt;size.y);</a>
<a name="ln602">    }</a>
<a name="ln603">#endif</a>
<a name="ln604">}</a>
<a name="ln605"> </a>
<a name="ln606">void level_clear_vault_memory()</a>
<a name="ln607">{</a>
<a name="ln608">    dgn_clear_vault_placements();</a>
<a name="ln609">    Temp_Vaults.clear();</a>
<a name="ln610">    env.level_map_mask.init(0);</a>
<a name="ln611">    env.level_map_ids.init(INVALID_MAP_INDEX);</a>
<a name="ln612">}</a>
<a name="ln613"> </a>
<a name="ln614">void dgn_flush_map_memory()</a>
<a name="ln615">{</a>
<a name="ln616">    // it's probably better in general to just reset `you`. But that's not so</a>
<a name="ln617">    // convenient for lua tests, who are the only user of this function.</a>
<a name="ln618">    // This leaves some state uninitialized, and probably should be immediately</a>
<a name="ln619">    // followed by a call to `initial_dungeon_setup` and something that moves</a>
<a name="ln620">    // the player to a level or regenerates a level.</a>
<a name="ln621"> </a>
<a name="ln622">    // vaults and map stuff</a>
<a name="ln623">    you.uniq_map_tags.clear();</a>
<a name="ln624">    you.uniq_map_names.clear();</a>
<a name="ln625">    you.uniq_map_tags_abyss.clear();</a>
<a name="ln626">    you.uniq_map_names_abyss.clear();</a>
<a name="ln627">    you.vault_list.clear();</a>
<a name="ln628">    you.branches_left.reset();</a>
<a name="ln629">    you.branch_stairs.init(0);</a>
<a name="ln630">    you.zigs_completed = 0;</a>
<a name="ln631">    you.zig_max = 0;</a>
<a name="ln632">    you.exploration = 0;</a>
<a name="ln633">    you.seen_portals = 0; // should be just cosmetic</a>
<a name="ln634">    reset_portal_entrances();</a>
<a name="ln635">    // would it be safe to just clear you.props?</a>
<a name="ln636">    you.props.erase(TEMPLE_SIZE_KEY);</a>
<a name="ln637">    you.props.erase(TEMPLE_MAP_KEY);</a>
<a name="ln638">    you.props.erase(OVERFLOW_TEMPLES_KEY);</a>
<a name="ln639">    you.props.erase(TEMPLE_GODS_KEY);</a>
<a name="ln640">    you.clear_place_info();</a>
<a name="ln641">    // the following is supposed to clear any persistent lua state related to</a>
<a name="ln642">    // the builder. However, it's susceptible to custom dlua doing its own</a>
<a name="ln643">    // thing...</a>
<a name="ln644">    dlua.callfn(&quot;dgn_clear_data&quot;, &quot;&quot;);</a>
<a name="ln645"> </a>
<a name="ln646">    // monsters</a>
<a name="ln647">    you.unique_creatures.reset();</a>
<a name="ln648"> </a>
<a name="ln649">    // item stuff that can interact with the builder</a>
<a name="ln650">    you.runes.reset();</a>
<a name="ln651">    you.obtainable_runes = 15;</a>
<a name="ln652">    you.unique_items.init(UNIQ_NOT_EXISTS);</a>
<a name="ln653">    you.octopus_king_rings = 0x00;</a>
<a name="ln654">    you.item_description.init(255); // random names need reset after this, e.g.</a>
<a name="ln655">                                    // via debug.dungeon_setup()</a>
<a name="ln656">    you.attribute[ATTR_GOLD_GENERATED] = 0;</a>
<a name="ln657">    // potentially relevant for item placement in e.g. troves:</a>
<a name="ln658">    you.seen_weapon.init(0);</a>
<a name="ln659">    you.seen_armour.init(0);</a>
<a name="ln660">    you.seen_misc.reset();</a>
<a name="ln661">}</a>
<a name="ln662"> </a>
<a name="ln663">static void _dgn_load_colour_grid()</a>
<a name="ln664">{</a>
<a name="ln665">    dgn_colour_grid.reset(new dungeon_colour_grid);</a>
<a name="ln666">    dungeon_colour_grid &amp;dcgrid(*dgn_colour_grid);</a>
<a name="ln667">    for (int y = Y_BOUND_1; y &lt;= Y_BOUND_2; ++y)</a>
<a name="ln668">        for (int x = X_BOUND_1; x &lt;= X_BOUND_2; ++x)</a>
<a name="ln669">            if (env.grid_colours[x][y] != BLACK)</a>
<a name="ln670">            {</a>
<a name="ln671">                dcgrid[x][y]</a>
<a name="ln672">                    = coloured_feature(grd[x][y], env.grid_colours[x][y]);</a>
<a name="ln673">            }</a>
<a name="ln674">}</a>
<a name="ln675"> </a>
<a name="ln676">static void _dgn_map_colour_fixup()</a>
<a name="ln677">{</a>
<a name="ln678">    if (!dgn_colour_grid)</a>
<a name="ln679">        return;</a>
<a name="ln680"> </a>
<a name="ln681">    // If the original coloured feature has been changed, reset the colour.</a>
<a name="ln682">    const dungeon_colour_grid &amp;dcgrid(*dgn_colour_grid);</a>
<a name="ln683">    for (int y = Y_BOUND_1; y &lt;= Y_BOUND_2; ++y)</a>
<a name="ln684">        for (int x = X_BOUND_1; x &lt;= X_BOUND_2; ++x)</a>
<a name="ln685">            if (dcgrid[x][y].colour != BLACK</a>
<a name="ln686">                &amp;&amp; grd[x][y] != dcgrid[x][y].feature</a>
<a name="ln687">                &amp;&amp; dcgrid[x][y].feature != DNGN_FLOOR)</a>
<a name="ln688">            {</a>
<a name="ln689">                env.grid_colours[x][y] = BLACK;</a>
<a name="ln690">            }</a>
<a name="ln691"> </a>
<a name="ln692">    dgn_colour_grid.reset(nullptr);</a>
<a name="ln693">}</a>
<a name="ln694"> </a>
<a name="ln695">void dgn_set_grid_colour_at(const coord_def &amp;c, int colour)</a>
<a name="ln696">{</a>
<a name="ln697">    if (colour != BLACK)</a>
<a name="ln698">    {</a>
<a name="ln699">        env.grid_colours(c) = colour;</a>
<a name="ln700">        if (!dgn_colour_grid)</a>
<a name="ln701">            dgn_colour_grid.reset(new dungeon_colour_grid);</a>
<a name="ln702"> </a>
<a name="ln703">        (*dgn_colour_grid)(c) = coloured_feature(grd(c), colour);</a>
<a name="ln704">    }</a>
<a name="ln705">}</a>
<a name="ln706"> </a>
<a name="ln707">static void _set_grd(const coord_def &amp;c, dungeon_feature_type feat)</a>
<a name="ln708">{</a>
<a name="ln709">    // It might be good to clear some pgrid flags as well.</a>
<a name="ln710">    env.tile_flv(c).feat    = 0;</a>
<a name="ln711">    env.tile_flv(c).special = 0;</a>
<a name="ln712">    env.grid_colours(c) = 0;</a>
<a name="ln713">    grd(c) = feat;</a>
<a name="ln714">}</a>
<a name="ln715"> </a>
<a name="ln716">static void _dgn_register_vault(const string &amp;name, const unordered_set&lt;string&gt; &amp;tags)</a>
<a name="ln717">{</a>
<a name="ln718">    if (!tags.count(&quot;allow_dup&quot;))</a>
<a name="ln719">        get_uniq_map_names().insert(name);</a>
<a name="ln720"> </a>
<a name="ln721">    if (tags.count(&quot;luniq&quot;))</a>
<a name="ln722">        env.level_uniq_maps.insert(name);</a>
<a name="ln723"> </a>
<a name="ln724">    vector&lt;string&gt; sorted_tags(tags.begin(), tags.end());</a>
<a name="ln725">    sort(sorted_tags.begin(), sorted_tags.end());</a>
<a name="ln726"> </a>
<a name="ln727">    for (const string &amp;tag : sorted_tags)</a>
<a name="ln728">    {</a>
<a name="ln729">        if (starts_with(tag, &quot;uniq_&quot;))</a>
<a name="ln730">            get_uniq_map_tags().insert(tag);</a>
<a name="ln731">        else if (starts_with(tag, &quot;luniq_&quot;))</a>
<a name="ln732">            env.level_uniq_map_tags.insert(tag);</a>
<a name="ln733">    }</a>
<a name="ln734">}</a>
<a name="ln735"> </a>
<a name="ln736">static void _dgn_register_vault(const map_def &amp;map)</a>
<a name="ln737">{</a>
<a name="ln738">    _dgn_register_vault(map.name, map.get_tags_unsorted());</a>
<a name="ln739">}</a>
<a name="ln740"> </a>
<a name="ln741">static void _dgn_register_vault(const string &amp;name, string &amp;spaced_tags)</a>
<a name="ln742">{</a>
<a name="ln743">    _dgn_register_vault(name, parse_tags(spaced_tags));</a>
<a name="ln744">}</a>
<a name="ln745"> </a>
<a name="ln746">static void _dgn_unregister_vault(const map_def &amp;map)</a>
<a name="ln747">{</a>
<a name="ln748">    get_uniq_map_names().erase(map.name);</a>
<a name="ln749">    env.level_uniq_maps.erase(map.name);</a>
<a name="ln750"> </a>
<a name="ln751">    for (const string &amp;tag : map.get_tags_unsorted())</a>
<a name="ln752">    {</a>
<a name="ln753">        if (starts_with(tag, &quot;uniq_&quot;))</a>
<a name="ln754">            get_uniq_map_tags().erase(tag);</a>
<a name="ln755">        else if (starts_with(tag, &quot;luniq_&quot;))</a>
<a name="ln756">            env.level_uniq_map_tags.erase(tag);</a>
<a name="ln757">    }</a>
<a name="ln758"> </a>
<a name="ln759">    for (const subvault_place &amp;sub : map.subvault_places)</a>
<a name="ln760">        _dgn_unregister_vault(*sub.subvault);</a>
<a name="ln761">}</a>
<a name="ln762"> </a>
<a name="ln763">bool dgn_square_travel_ok(const coord_def &amp;c)</a>
<a name="ln764">{</a>
<a name="ln765">    const dungeon_feature_type feat = grd(c);</a>
<a name="ln766">    if (feat_is_trap(feat))</a>
<a name="ln767">    {</a>
<a name="ln768">        const trap_def * const trap = trap_at(c);</a>
<a name="ln769">        return !(trap &amp;&amp; (trap-&gt;type == TRAP_TELEPORT_PERMANENT</a>
<a name="ln770">                          || trap-&gt;type == TRAP_DISPERSAL));</a>
<a name="ln771">    }</a>
<a name="ln772">    else</a>
<a name="ln773">        return feat_is_traversable(feat);</a>
<a name="ln774">}</a>
<a name="ln775"> </a>
<a name="ln776">static bool _dgn_square_is_passable(const coord_def &amp;c)</a>
<a name="ln777">{</a>
<a name="ln778">    // [enne] Why does this function check MMT_OPAQUE?</a>
<a name="ln779">    //</a>
<a name="ln780">    // Don't peek inside MMT_OPAQUE vaults (all vaults are opaque by</a>
<a name="ln781">    // default) because vaults may choose to create isolated regions,</a>
<a name="ln782">    // or otherwise cause connectivity issues even if the map terrain</a>
<a name="ln783">    // is travel-passable.</a>
<a name="ln784">    return !(env.level_map_mask(c) &amp; MMT_OPAQUE) &amp;&amp; dgn_square_travel_ok(c);</a>
<a name="ln785">}</a>
<a name="ln786"> </a>
<a name="ln787">static bool _dgn_square_is_ever_passable(const coord_def &amp;c)</a>
<a name="ln788">{</a>
<a name="ln789">    if (!(env.level_map_mask(c) &amp; MMT_OPAQUE))</a>
<a name="ln790">    {</a>
<a name="ln791">        const dungeon_feature_type feat = grd(c);</a>
<a name="ln792">        if (feat == DNGN_DEEP_WATER || feat == DNGN_LAVA)</a>
<a name="ln793">            return true;</a>
<a name="ln794">    }</a>
<a name="ln795">    return _dgn_square_is_passable(c);</a>
<a name="ln796">}</a>
<a name="ln797"> </a>
<a name="ln798">static inline void _dgn_point_record_stub(const coord_def &amp;) { }</a>
<a name="ln799"> </a>
<a name="ln800">template &lt;class point_record&gt;</a>
<a name="ln801">static bool _dgn_fill_zone(</a>
<a name="ln802">    const coord_def &amp;start, int zone,</a>
<a name="ln803">    point_record &amp;record_point,</a>
<a name="ln804">    bool (*passable)(const coord_def &amp;) = _dgn_square_is_passable,</a>
<a name="ln805">    bool (*iswanted)(const coord_def &amp;) = nullptr)</a>
<a name="ln806">{</a>
<a name="ln807">    bool ret = false;</a>
<a name="ln808">    list&lt;coord_def&gt; points[2];</a>
<a name="ln809">    int cur = 0;</a>
<a name="ln810"> </a>
<a name="ln811">    // No bounds checks, assuming the level has at least one layer of</a>
<a name="ln812">    // rock border.</a>
<a name="ln813"> </a>
<a name="ln814">    for (points[cur].push_back(start); !points[cur].empty();)</a>
<a name="ln815">    {</a>
<a name="ln816">        for (const auto &amp;c : points[cur])</a>
<a name="ln817">        {</a>
<a name="ln818">            travel_point_distance[c.x][c.y] = zone;</a>
<a name="ln819"> </a>
<a name="ln820">            if (iswanted &amp;&amp; iswanted(c))</a>
<a name="ln821">                ret = true;</a>
<a name="ln822"> </a>
<a name="ln823">            for (adjacent_iterator ai(c); ai; ++ai)</a>
<a name="ln824">            {</a>
<a name="ln825">                const coord_def&amp; cp = *ai;</a>
<a name="ln826">                if (!map_bounds(cp)</a>
<a name="ln827">                    || travel_point_distance[cp.x][cp.y] || !passable(cp))</a>
<a name="ln828">                {</a>
<a name="ln829">                    continue;</a>
<a name="ln830">                }</a>
<a name="ln831"> </a>
<a name="ln832">                travel_point_distance[cp.x][cp.y] = zone;</a>
<a name="ln833">                record_point(cp);</a>
<a name="ln834">                points[!cur].push_back(cp);</a>
<a name="ln835">            }</a>
<a name="ln836">        }</a>
<a name="ln837"> </a>
<a name="ln838">        points[cur].clear();</a>
<a name="ln839">        cur = !cur;</a>
<a name="ln840">    }</a>
<a name="ln841">    return ret;</a>
<a name="ln842">}</a>
<a name="ln843"> </a>
<a name="ln844">static bool _is_perm_down_stair(const coord_def &amp;c)</a>
<a name="ln845">{</a>
<a name="ln846">    switch (grd(c))</a>
<a name="ln847">    {</a>
<a name="ln848">    case DNGN_STONE_STAIRS_DOWN_I:</a>
<a name="ln849">    case DNGN_STONE_STAIRS_DOWN_II:</a>
<a name="ln850">    case DNGN_STONE_STAIRS_DOWN_III:</a>
<a name="ln851">    case DNGN_EXIT_HELL:</a>
<a name="ln852">    case DNGN_EXIT_PANDEMONIUM:</a>
<a name="ln853">    case DNGN_TRANSIT_PANDEMONIUM:</a>
<a name="ln854">    case DNGN_EXIT_ABYSS:</a>
<a name="ln855">    case DNGN_ABYSSAL_STAIR:</a>
<a name="ln856">        return true;</a>
<a name="ln857">    default:</a>
<a name="ln858">        return false;</a>
<a name="ln859">    }</a>
<a name="ln860">}</a>
<a name="ln861"> </a>
<a name="ln862">static bool _is_upwards_exit_stair(const coord_def &amp;c)</a>
<a name="ln863">{</a>
<a name="ln864">    // Is this a valid upwards or exit stair out of a branch? In general,</a>
<a name="ln865">    // ensure that each region has a stone stair up.</a>
<a name="ln866"> </a>
<a name="ln867">    if (feature_mimic_at(c))</a>
<a name="ln868">        return false;</a>
<a name="ln869"> </a>
<a name="ln870">    if (feat_is_stone_stair_up(grd(c))</a>
<a name="ln871">        || feat_is_branch_exit(grd(c)))</a>
<a name="ln872">    {</a>
<a name="ln873">        return true;</a>
<a name="ln874">    }</a>
<a name="ln875"> </a>
<a name="ln876">    switch (grd(c))</a>
<a name="ln877">    {</a>
<a name="ln878">    case DNGN_EXIT_PANDEMONIUM:</a>
<a name="ln879">    case DNGN_TRANSIT_PANDEMONIUM:</a>
<a name="ln880">    case DNGN_EXIT_ABYSS:</a>
<a name="ln881">        return true;</a>
<a name="ln882">    case DNGN_ENTER_HELL:</a>
<a name="ln883">        return parent_branch(you.where_are_you) == BRANCH_VESTIBULE;</a>
<a name="ln884">    default:</a>
<a name="ln885">        return false;</a>
<a name="ln886">    }</a>
<a name="ln887">}</a>
<a name="ln888"> </a>
<a name="ln889">static bool _is_exit_stair(const coord_def &amp;c)</a>
<a name="ln890">{</a>
<a name="ln891">    if (feature_mimic_at(c))</a>
<a name="ln892">        return false;</a>
<a name="ln893"> </a>
<a name="ln894">    // Branch entries, portals, and abyss entries are not considered exit</a>
<a name="ln895">    // stairs here, as they do not provide an exit (in a transitive sense) from</a>
<a name="ln896">    // the current level.</a>
<a name="ln897">    if (feat_is_stone_stair(grd(c))</a>
<a name="ln898">        || feat_is_escape_hatch(grd(c))</a>
<a name="ln899">        || feat_is_branch_exit(grd(c)))</a>
<a name="ln900">    {</a>
<a name="ln901">        return true;</a>
<a name="ln902">    }</a>
<a name="ln903"> </a>
<a name="ln904">    switch (grd(c))</a>
<a name="ln905">    {</a>
<a name="ln906">    case DNGN_EXIT_PANDEMONIUM:</a>
<a name="ln907">    case DNGN_TRANSIT_PANDEMONIUM:</a>
<a name="ln908">    case DNGN_EXIT_ABYSS:</a>
<a name="ln909">        return true;</a>
<a name="ln910">    case DNGN_ENTER_HELL:</a>
<a name="ln911">        return parent_branch(you.where_are_you) == BRANCH_VESTIBULE;</a>
<a name="ln912">    default:</a>
<a name="ln913">        return false;</a>
<a name="ln914">    }</a>
<a name="ln915">}</a>
<a name="ln916"> </a>
<a name="ln917">// Counts the number of mutually unreachable areas in the map,</a>
<a name="ln918">// excluding isolated zones within vaults (we assume the vault author</a>
<a name="ln919">// knows what she's doing). This is an easy way to check whether a map</a>
<a name="ln920">// has isolated parts of the level that were not formerly isolated.</a>
<a name="ln921">//</a>
<a name="ln922">// All squares within vaults are treated as non-reachable, to simplify</a>
<a name="ln923">// life, because vaults may change the level layout and isolate</a>
<a name="ln924">// different areas without changing the number of isolated areas.</a>
<a name="ln925">// Here's a before and after example of such a vault that would cause</a>
<a name="ln926">// problems if we considered floor in the vault as non-isolating (the</a>
<a name="ln927">// vault is represented as V for walls and o for floor squares in the</a>
<a name="ln928">// vault).</a>
<a name="ln929">//</a>
<a name="ln930">// Before:</a>
<a name="ln931">//</a>
<a name="ln932">//   xxxxx    xxxxx</a>
<a name="ln933">//   x&lt;..x    x.2.x</a>
<a name="ln934">//   x.1.x    xxxxx  3 isolated zones</a>
<a name="ln935">//   x&gt;..x    x.3.x</a>
<a name="ln936">//   xxxxx    xxxxx</a>
<a name="ln937">//</a>
<a name="ln938">// After:</a>
<a name="ln939">//</a>
<a name="ln940">//   xxxxx    xxxxx</a>
<a name="ln941">//   x&lt;1.x    x.2.x</a>
<a name="ln942">//   VVVVVVVVVVoooV  3 isolated zones, but the isolated zones are different.</a>
<a name="ln943">//   x&gt;3.x    x...x</a>
<a name="ln944">//   xxxxx    xxxxx</a>
<a name="ln945">//</a>
<a name="ln946">// If count_stairless is true, returns the number of regions that have no</a>
<a name="ln947">// stairs in them.</a>
<a name="ln948">//</a>
<a name="ln949">// If fill is non-zero, it fills any disconnected regions with fill.</a>
<a name="ln950">//</a>
<a name="ln951">static int _process_disconnected_zones(int x1, int y1, int x2, int y2,</a>
<a name="ln952">                bool choose_stairless,</a>
<a name="ln953">                dungeon_feature_type fill,</a>
<a name="ln954">                bool (*passable)(const coord_def &amp;) = _dgn_square_is_passable)</a>
<a name="ln955">{</a>
<a name="ln956">    memset(travel_point_distance, 0, sizeof(travel_distance_grid_t));</a>
<a name="ln957">    int nzones = 0;</a>
<a name="ln958">    int ngood = 0;</a>
<a name="ln959">    for (int y = y1; y &lt;= y2 ; ++y)</a>
<a name="ln960">    {</a>
<a name="ln961">        for (int x = x1; x &lt;= x2; ++x)</a>
<a name="ln962">        {</a>
<a name="ln963">            if (!map_bounds(x, y)</a>
<a name="ln964">                || travel_point_distance[x][y]</a>
<a name="ln965">                || !passable(coord_def(x, y)))</a>
<a name="ln966">            {</a>
<a name="ln967">                continue;</a>
<a name="ln968">            }</a>
<a name="ln969"> </a>
<a name="ln970">            const bool found_exit_stair =</a>
<a name="ln971">                _dgn_fill_zone(coord_def(x, y), ++nzones,</a>
<a name="ln972">                               _dgn_point_record_stub,</a>
<a name="ln973">                               passable,</a>
<a name="ln974">                               choose_stairless ? (at_branch_bottom() ?</a>
<a name="ln975">                                                   _is_upwards_exit_stair :</a>
<a name="ln976">                                                   _is_exit_stair) : nullptr);</a>
<a name="ln977"> </a>
<a name="ln978">            // If we want only stairless zones, screen out zones that did</a>
<a name="ln979">            // have stairs.</a>
<a name="ln980">            if (choose_stairless &amp;&amp; found_exit_stair)</a>
<a name="ln981">                ++ngood;</a>
<a name="ln982">            else if (fill)</a>
<a name="ln983">            {</a>
<a name="ln984">                // Don't fill in areas connected to vaults.</a>
<a name="ln985">                // We want vaults to be accessible; if the area is disconneted</a>
<a name="ln986">                // from the rest of the level, this will cause the level to be</a>
<a name="ln987">                // vetoed later on.</a>
<a name="ln988">                bool veto = false;</a>
<a name="ln989">                vector&lt;coord_def&gt; coords;</a>
<a name="ln990">                for (int fy = y1; fy &lt;= y2 ; ++fy)</a>
<a name="ln991">                {</a>
<a name="ln992">                    for (int fx = x1; fx &lt;= x2; ++fx)</a>
<a name="ln993">                    {</a>
<a name="ln994">                        if (travel_point_distance[fx][fy] == nzones)</a>
<a name="ln995">                        {</a>
<a name="ln996">                            if (map_masked(coord_def(fx, fy), MMT_VAULT))</a>
<a name="ln997">                            {</a>
<a name="ln998">                                veto = true;</a>
<a name="ln999">                                break;</a>
<a name="ln1000">                            }</a>
<a name="ln1001">                            else</a>
<a name="ln1002">                                coords.emplace_back(fx, fy);</a>
<a name="ln1003">                        }</a>
<a name="ln1004">                    }</a>
<a name="ln1005">                    if (veto)</a>
<a name="ln1006">                        break;</a>
<a name="ln1007">                }</a>
<a name="ln1008">                if (!veto)</a>
<a name="ln1009">                {</a>
<a name="ln1010">                    for (auto c : coords)</a>
<a name="ln1011">                        _set_grd(c, fill);</a>
<a name="ln1012">                }</a>
<a name="ln1013">            }</a>
<a name="ln1014">        }</a>
<a name="ln1015">    }</a>
<a name="ln1016"> </a>
<a name="ln1017">    return nzones - ngood;</a>
<a name="ln1018">}</a>
<a name="ln1019"> </a>
<a name="ln1020">int dgn_count_disconnected_zones(bool choose_stairless,</a>
<a name="ln1021">                                 dungeon_feature_type fill)</a>
<a name="ln1022">{</a>
<a name="ln1023">    return _process_disconnected_zones(0, 0, GXM-1, GYM-1, choose_stairless,</a>
<a name="ln1024">                                       fill);</a>
<a name="ln1025">}</a>
<a name="ln1026"> </a>
<a name="ln1027">static void _fixup_hell_stairs()</a>
<a name="ln1028">{</a>
<a name="ln1029">    for (rectangle_iterator ri(1); ri; ++ri)</a>
<a name="ln1030">    {</a>
<a name="ln1031">        if (feat_is_stone_stair_up(grd(*ri))</a>
<a name="ln1032">            || grd(*ri) == DNGN_ESCAPE_HATCH_UP)</a>
<a name="ln1033">        {</a>
<a name="ln1034">            _set_grd(*ri, DNGN_ENTER_HELL);</a>
<a name="ln1035">        }</a>
<a name="ln1036">    }</a>
<a name="ln1037">}</a>
<a name="ln1038"> </a>
<a name="ln1039">static void _fixup_pandemonium_stairs()</a>
<a name="ln1040">{</a>
<a name="ln1041">    for (rectangle_iterator ri(1); ri; ++ri)</a>
<a name="ln1042">    {</a>
<a name="ln1043">        if (feat_is_stone_stair_up(grd(*ri))</a>
<a name="ln1044">            || grd(*ri) == DNGN_ESCAPE_HATCH_UP)</a>
<a name="ln1045">        {</a>
<a name="ln1046">            _set_grd(*ri, DNGN_TRANSIT_PANDEMONIUM);</a>
<a name="ln1047">        }</a>
<a name="ln1048">    }</a>
<a name="ln1049">}</a>
<a name="ln1050"> </a>
<a name="ln1051">static void _mask_vault(const vault_placement &amp;place, unsigned mask)</a>
<a name="ln1052">{</a>
<a name="ln1053">    for (vault_place_iterator vi(place); vi; ++vi)</a>
<a name="ln1054">        env.level_map_mask(*vi) |= mask;</a>
<a name="ln1055">}</a>
<a name="ln1056"> </a>
<a name="ln1057">static void _dgn_apply_map_index(const vault_placement &amp;place, int map_index)</a>
<a name="ln1058">{</a>
<a name="ln1059">    for (vault_place_iterator vi(place); vi; ++vi)</a>
<a name="ln1060">        env.level_map_ids(*vi) = map_index;</a>
<a name="ln1061">}</a>
<a name="ln1062"> </a>
<a name="ln1063">const vault_placement *</a>
<a name="ln1064">dgn_register_place(const vault_placement &amp;place, bool register_vault)</a>
<a name="ln1065">{</a>
<a name="ln1066">    const int  map_index    = env.level_vaults.size();</a>
<a name="ln1067">    const bool overwritable = place.map.is_overwritable_layout();</a>
<a name="ln1068">    const bool transparent  = place.map.has_tag(&quot;transparent&quot;);</a>
<a name="ln1069"> </a>
<a name="ln1070">    if (register_vault)</a>
<a name="ln1071">    {</a>
<a name="ln1072">        _dgn_register_vault(place.map);</a>
<a name="ln1073">        for (int i = env.new_subvault_names.size() - 1; i &gt;= 0; i--)</a>
<a name="ln1074">        {</a>
<a name="ln1075">            _dgn_register_vault(env.new_subvault_names[i],</a>
<a name="ln1076">                                env.new_subvault_tags[i]);</a>
<a name="ln1077">        }</a>
<a name="ln1078">        clear_subvault_stack();</a>
<a name="ln1079"> </a>
<a name="ln1080">        // Identify each square in the map with its map_index.</a>
<a name="ln1081">        if (!overwritable)</a>
<a name="ln1082">            _dgn_apply_map_index(place, map_index);</a>
<a name="ln1083">    }</a>
<a name="ln1084"> </a>
<a name="ln1085">    if (!overwritable)</a>
<a name="ln1086">    {</a>
<a name="ln1087">        if (place.map.orient == MAP_ENCOMPASS)</a>
<a name="ln1088">        {</a>
<a name="ln1089">            for (rectangle_iterator ri(0); ri; ++ri)</a>
<a name="ln1090">                env.level_map_mask(*ri) |= MMT_VAULT;</a>
<a name="ln1091">        }</a>
<a name="ln1092">        else</a>
<a name="ln1093">            _mask_vault(place, MMT_VAULT);</a>
<a name="ln1094"> </a>
<a name="ln1095">        if (!transparent)</a>
<a name="ln1096">            _mask_vault(place, MMT_OPAQUE);</a>
<a name="ln1097">    }</a>
<a name="ln1098"> </a>
<a name="ln1099">    // Find tags matching properties.</a>
<a name="ln1100">    for (const auto &amp;tag : place.map.get_tags_unsorted())</a>
<a name="ln1101">    {</a>
<a name="ln1102">        const feature_property_type prop = str_to_fprop(tag);</a>
<a name="ln1103">        if (prop == FPROP_NONE)</a>
<a name="ln1104">            continue;</a>
<a name="ln1105"> </a>
<a name="ln1106">        for (vault_place_iterator vi(place); vi; ++vi)</a>
<a name="ln1107">            env.pgrid(*vi) |= prop;</a>
<a name="ln1108"> </a>
<a name="ln1109">    }</a>
<a name="ln1110"> </a>
<a name="ln1111">    if (place.map.has_tag(&quot;no_monster_gen&quot;))</a>
<a name="ln1112">        _mask_vault(place, MMT_NO_MONS);</a>
<a name="ln1113"> </a>
<a name="ln1114">    if (place.map.has_tag(&quot;no_item_gen&quot;))</a>
<a name="ln1115">        _mask_vault(place, MMT_NO_ITEM);</a>
<a name="ln1116"> </a>
<a name="ln1117">    if (place.map.has_tag(&quot;no_pool_fixup&quot;))</a>
<a name="ln1118">        _mask_vault(place, MMT_NO_POOL);</a>
<a name="ln1119"> </a>
<a name="ln1120">    if (place.map.has_tag(&quot;no_wall_fixup&quot;))</a>
<a name="ln1121">        _mask_vault(place, MMT_NO_WALL);</a>
<a name="ln1122"> </a>
<a name="ln1123">    if (place.map.has_tag(&quot;no_trap_gen&quot;))</a>
<a name="ln1124">        _mask_vault(place, MMT_NO_TRAP);</a>
<a name="ln1125"> </a>
<a name="ln1126">    // Now do per-square by-symbol masking.</a>
<a name="ln1127">    for (vault_place_iterator vi(place); vi; ++vi)</a>
<a name="ln1128">    {</a>
<a name="ln1129">        const keyed_mapspec *spec = place.map.mapspec_at(*vi - place.pos);</a>
<a name="ln1130"> </a>
<a name="ln1131">        if (spec != nullptr)</a>
<a name="ln1132">        {</a>
<a name="ln1133">            env.level_map_mask(*vi) |= (short)spec-&gt;map_mask.flags_set;</a>
<a name="ln1134">            env.level_map_mask(*vi) &amp;= ~((short)spec-&gt;map_mask.flags_unset);</a>
<a name="ln1135">        }</a>
<a name="ln1136">    }</a>
<a name="ln1137"> </a>
<a name="ln1138">    if (place.map.floor_colour != BLACK)</a>
<a name="ln1139">        env.floor_colour = place.map.floor_colour;</a>
<a name="ln1140"> </a>
<a name="ln1141">    if (place.map.rock_colour != BLACK)</a>
<a name="ln1142">        env.rock_colour = place.map.rock_colour;</a>
<a name="ln1143"> </a>
<a name="ln1144">    if (!place.map.rock_tile.empty())</a>
<a name="ln1145">    {</a>
<a name="ln1146">        tileidx_t rock;</a>
<a name="ln1147">        if (tile_dngn_index(place.map.rock_tile.c_str(), &amp;rock))</a>
<a name="ln1148">        {</a>
<a name="ln1149">            env.tile_default.wall_idx =</a>
<a name="ln1150">                store_tilename_get_index(place.map.rock_tile);</a>
<a name="ln1151"> </a>
<a name="ln1152">            env.tile_default.wall = rock;</a>
<a name="ln1153">        }</a>
<a name="ln1154">    }</a>
<a name="ln1155"> </a>
<a name="ln1156">    if (!place.map.floor_tile.empty())</a>
<a name="ln1157">    {</a>
<a name="ln1158">        tileidx_t floor;</a>
<a name="ln1159">        if (tile_dngn_index(place.map.floor_tile.c_str(), &amp;floor))</a>
<a name="ln1160">        {</a>
<a name="ln1161">            env.tile_default.floor_idx =</a>
<a name="ln1162">                store_tilename_get_index(place.map.floor_tile);</a>
<a name="ln1163"> </a>
<a name="ln1164">            env.tile_default.floor = floor;</a>
<a name="ln1165">        }</a>
<a name="ln1166">    }</a>
<a name="ln1167"> </a>
<a name="ln1168">    vault_placement *new_vault_place = new vault_placement(place);</a>
<a name="ln1169">    env.level_vaults.emplace_back(new_vault_place);</a>
<a name="ln1170">    if (register_vault)</a>
<a name="ln1171">        _remember_vault_placement(place);</a>
<a name="ln1172">    return new_vault_place;</a>
<a name="ln1173">}</a>
<a name="ln1174"> </a>
<a name="ln1175">static bool _dgn_ensure_vault_placed(bool vault_success,</a>
<a name="ln1176">                                     bool disable_further_vaults)</a>
<a name="ln1177">{</a>
<a name="ln1178">    if (!vault_success)</a>
<a name="ln1179">        throw dgn_veto_exception(&quot;Vault placement failure.&quot;);</a>
<a name="ln1180">    else if (disable_further_vaults)</a>
<a name="ln1181">        use_random_maps = false;</a>
<a name="ln1182">    return vault_success;</a>
<a name="ln1183">}</a>
<a name="ln1184"> </a>
<a name="ln1185">static bool _ensure_vault_placed_ex(bool vault_success, const map_def *vault)</a>
<a name="ln1186">{</a>
<a name="ln1187">    return _dgn_ensure_vault_placed(vault_success,</a>
<a name="ln1188">                                    (!vault-&gt;is_extra_vault()</a>
<a name="ln1189">                                     &amp;&amp; vault-&gt;orient == MAP_ENCOMPASS));</a>
<a name="ln1190">}</a>
<a name="ln1191"> </a>
<a name="ln1192">static coord_def _find_level_feature(int feat)</a>
<a name="ln1193">{</a>
<a name="ln1194">    for (rectangle_iterator ri(1); ri; ++ri)</a>
<a name="ln1195">    {</a>
<a name="ln1196">        if (grd(*ri) == feat)</a>
<a name="ln1197">            return *ri;</a>
<a name="ln1198">    }</a>
<a name="ln1199"> </a>
<a name="ln1200">    return coord_def(0, 0);</a>
<a name="ln1201">}</a>
<a name="ln1202"> </a>
<a name="ln1203">static bool _has_connected_stone_stairs_from(const coord_def &amp;c)</a>
<a name="ln1204">{</a>
<a name="ln1205">    flood_find&lt;feature_grid, coord_predicate&gt; ff(env.grid, in_bounds);</a>
<a name="ln1206">    ff.add_feat(DNGN_STONE_STAIRS_DOWN_I);</a>
<a name="ln1207">    ff.add_feat(DNGN_STONE_STAIRS_DOWN_II);</a>
<a name="ln1208">    ff.add_feat(DNGN_STONE_STAIRS_DOWN_III);</a>
<a name="ln1209">    ff.add_feat(DNGN_STONE_STAIRS_UP_I);</a>
<a name="ln1210">    ff.add_feat(DNGN_STONE_STAIRS_UP_II);</a>
<a name="ln1211">    ff.add_feat(DNGN_STONE_STAIRS_UP_III);</a>
<a name="ln1212"> </a>
<a name="ln1213">    coord_def where = ff.find_first_from(c, env.level_map_mask);</a>
<a name="ln1214">    return where.x || !ff.did_leave_vault();</a>
<a name="ln1215">}</a>
<a name="ln1216"> </a>
<a name="ln1217">static bool _has_connected_downstairs_from(const coord_def &amp;c)</a>
<a name="ln1218">{</a>
<a name="ln1219">    flood_find&lt;feature_grid, coord_predicate&gt; ff(env.grid, in_bounds);</a>
<a name="ln1220">    ff.add_feat(DNGN_STONE_STAIRS_DOWN_I);</a>
<a name="ln1221">    ff.add_feat(DNGN_STONE_STAIRS_DOWN_II);</a>
<a name="ln1222">    ff.add_feat(DNGN_STONE_STAIRS_DOWN_III);</a>
<a name="ln1223">    ff.add_feat(DNGN_ESCAPE_HATCH_DOWN);</a>
<a name="ln1224"> </a>
<a name="ln1225">    coord_def where = ff.find_first_from(c, env.level_map_mask);</a>
<a name="ln1226">    return where.x || !ff.did_leave_vault();</a>
<a name="ln1227">}</a>
<a name="ln1228"> </a>
<a name="ln1229">static bool _is_level_stair_connected(dungeon_feature_type feat)</a>
<a name="ln1230">{</a>
<a name="ln1231">    coord_def up = _find_level_feature(feat);</a>
<a name="ln1232">    if (up.x &amp;&amp; up.y)</a>
<a name="ln1233">        return _has_connected_downstairs_from(up);</a>
<a name="ln1234"> </a>
<a name="ln1235">    return false;</a>
<a name="ln1236">}</a>
<a name="ln1237"> </a>
<a name="ln1238">static bool _valid_dungeon_level()</a>
<a name="ln1239">{</a>
<a name="ln1240">    // D:1 only.</a>
<a name="ln1241">    // Also, what's the point of this check?  Regular connectivity should</a>
<a name="ln1242">    // do that already.</a>
<a name="ln1243">    if (player_in_branch(BRANCH_DUNGEON) &amp;&amp; you.depth == 1)</a>
<a name="ln1244">        return _is_level_stair_connected(branches[BRANCH_DUNGEON].exit_stairs);</a>
<a name="ln1245"> </a>
<a name="ln1246">    return true;</a>
<a name="ln1247">}</a>
<a name="ln1248"> </a>
<a name="ln1249">void dgn_reset_level(bool enable_random_maps)</a>
<a name="ln1250">{</a>
<a name="ln1251">    env.level_uniq_maps.clear();</a>
<a name="ln1252">    env.level_uniq_map_tags.clear();</a>
<a name="ln1253">    clear_subvault_stack();</a>
<a name="ln1254"> </a>
<a name="ln1255">    you.unique_creatures = temp_unique_creatures;</a>
<a name="ln1256">    you.unique_items = temp_unique_items;</a>
<a name="ln1257"> </a>
<a name="ln1258">#ifdef DEBUG_STATISTICS</a>
<a name="ln1259">    _you_all_vault_list.clear();</a>
<a name="ln1260">#endif</a>
<a name="ln1261">    env.level_build_method.clear();</a>
<a name="ln1262">    env.level_layout_types.clear();</a>
<a name="ln1263">    level_clear_vault_memory();</a>
<a name="ln1264">    dgn_colour_grid.reset(nullptr);</a>
<a name="ln1265"> </a>
<a name="ln1266">    use_random_maps = enable_random_maps;</a>
<a name="ln1267">    dgn_check_connectivity = false;</a>
<a name="ln1268">    dgn_zones        = 0;</a>
<a name="ln1269"> </a>
<a name="ln1270">    _temple_altar_list.clear();</a>
<a name="ln1271">    _current_temple_hash = nullptr;</a>
<a name="ln1272"> </a>
<a name="ln1273">    // Forget level properties.</a>
<a name="ln1274">    env.properties.clear();</a>
<a name="ln1275">    env.heightmap.reset(nullptr);</a>
<a name="ln1276"> </a>
<a name="ln1277">    env.absdepth0 = absdungeon_depth(you.where_are_you, you.depth);</a>
<a name="ln1278"> </a>
<a name="ln1279">    if (!crawl_state.test)</a>
<a name="ln1280">        dprf(DIAG_DNGN, &quot;absdepth0 = %d&quot;, env.absdepth0);</a>
<a name="ln1281"> </a>
<a name="ln1282">    // Blank level with DNGN_ROCK_WALL.</a>
<a name="ln1283">    env.grid.init(DNGN_ROCK_WALL);</a>
<a name="ln1284">    env.pgrid.init(terrain_property_t{});</a>
<a name="ln1285">    env.grid_colours.init(BLACK);</a>
<a name="ln1286">    env.map_knowledge.init(map_cell());</a>
<a name="ln1287">    env.map_forgotten.reset();</a>
<a name="ln1288">    env.map_seen.reset();</a>
<a name="ln1289"> </a>
<a name="ln1290">    // Delete all traps.</a>
<a name="ln1291">    env.trap.clear();</a>
<a name="ln1292"> </a>
<a name="ln1293">    // Initialise all items.</a>
<a name="ln1294">    for (int i = 0; i &lt; MAX_ITEMS; i++)</a>
<a name="ln1295">        init_item(i);</a>
<a name="ln1296"> </a>
<a name="ln1297">    // Reset all monsters.</a>
<a name="ln1298">    reset_all_monsters();</a>
<a name="ln1299">    init_anon();</a>
<a name="ln1300"> </a>
<a name="ln1301">    // ... and Pan/regular spawn lists.</a>
<a name="ln1302">    env.mons_alloc.init(MONS_NO_MONSTER);</a>
<a name="ln1303">    setup_vault_mon_list();</a>
<a name="ln1304"> </a>
<a name="ln1305">    env.cloud.clear();</a>
<a name="ln1306"> </a>
<a name="ln1307">    mgrd.init(NON_MONSTER);</a>
<a name="ln1308">    igrd.init(NON_ITEM);</a>
<a name="ln1309"> </a>
<a name="ln1310">    // Reset all shops.</a>
<a name="ln1311">    env.shop.clear();</a>
<a name="ln1312"> </a>
<a name="ln1313">    // Clear all markers.</a>
<a name="ln1314">    env.markers.clear();</a>
<a name="ln1315"> </a>
<a name="ln1316">    // Lose all listeners.</a>
<a name="ln1317">    dungeon_events.clear();</a>
<a name="ln1318"> </a>
<a name="ln1319">    // Set default random monster generation rate (smaller is more often,</a>
<a name="ln1320">    // except that 0 == no random monsters).</a>
<a name="ln1321">    if (player_in_branch(BRANCH_TEMPLE)</a>
<a name="ln1322">        &amp;&amp; !player_on_orb_run() // except for the Orb run</a>
<a name="ln1323">        || crawl_state.game_is_tutorial())</a>
<a name="ln1324">    {</a>
<a name="ln1325">        // No random monsters in tutorial or ecu temple</a>
<a name="ln1326">        env.spawn_random_rate = 0;</a>
<a name="ln1327">    }</a>
<a name="ln1328">    else if (player_in_connected_branch()</a>
<a name="ln1329">             || (player_on_orb_run() &amp;&amp; !player_in_branch(BRANCH_ABYSS)))</a>
<a name="ln1330">        env.spawn_random_rate = 240;</a>
<a name="ln1331">    else if (player_in_branch(BRANCH_ABYSS)</a>
<a name="ln1332">             || player_in_branch(BRANCH_PANDEMONIUM))</a>
<a name="ln1333">    {</a>
<a name="ln1334">        // Abyss spawn rate is set for those characters that start out in the</a>
<a name="ln1335">        // Abyss; otherwise the number is ignored in the Abyss.</a>
<a name="ln1336">        env.spawn_random_rate = 50;</a>
<a name="ln1337">    }</a>
<a name="ln1338">    else</a>
<a name="ln1339">        // No random monsters in portal vaults if we don't have the orb.</a>
<a name="ln1340">        env.spawn_random_rate = 0;</a>
<a name="ln1341">    env.density = 0;</a>
<a name="ln1342">    env.forest_awoken_until = 0;</a>
<a name="ln1343"> </a>
<a name="ln1344">    env.floor_colour = BLACK;</a>
<a name="ln1345">    env.rock_colour  = BLACK;</a>
<a name="ln1346"> </a>
<a name="ln1347">    // Clear exclusions</a>
<a name="ln1348">    clear_excludes();</a>
<a name="ln1349"> </a>
<a name="ln1350">    // Clear custom tile settings from vaults</a>
<a name="ln1351">    tile_init_default_flavour();</a>
<a name="ln1352">    tile_clear_flavour();</a>
<a name="ln1353">    env.tile_names.clear();</a>
<a name="ln1354"> </a>
<a name="ln1355">    update_portal_entrances();</a>
<a name="ln1356">}</a>
<a name="ln1357"> </a>
<a name="ln1358">static int _num_items_wanted(int absdepth0)</a>
<a name="ln1359">{</a>
<a name="ln1360">    if (branches[you.where_are_you].branch_flags &amp; brflag::no_items)</a>
<a name="ln1361">        return 0;</a>
<a name="ln1362">    else if (absdepth0 &gt; 5 &amp;&amp; one_chance_in(500 - 5 * absdepth0))</a>
<a name="ln1363">        return 10 + random2avg(90, 2); // rich level!</a>
<a name="ln1364">    else</a>
<a name="ln1365">        return 3 + roll_dice(3, 11);</a>
<a name="ln1366">}</a>
<a name="ln1367"> </a>
<a name="ln1368">// Return how many level monster are wanted for level generation.</a>
<a name="ln1369">static int _num_mons_wanted()</a>
<a name="ln1370">{</a>
<a name="ln1371">    const bool in_pan = player_in_branch(BRANCH_PANDEMONIUM);</a>
<a name="ln1372"> </a>
<a name="ln1373">    // No disconnected branches aside from Pan have level monsters.</a>
<a name="ln1374">    if ((!player_in_connected_branch() &amp;&amp; !in_pan)</a>
<a name="ln1375">        // Temple is connected but has no monsters.</a>
<a name="ln1376">        || !branch_has_monsters(you.where_are_you))</a>
<a name="ln1377">    {</a>
<a name="ln1378">        return 0;</a>
<a name="ln1379">    }</a>
<a name="ln1380"> </a>
<a name="ln1381">    int size = 12;</a>
<a name="ln1382"> </a>
<a name="ln1383">    if (in_pan)</a>
<a name="ln1384">        size = 8;</a>
<a name="ln1385">    else if (player_in_branch(BRANCH_CRYPT))</a>
<a name="ln1386">        size = 10;</a>
<a name="ln1387">    else if (player_in_hell())</a>
<a name="ln1388">        size = 23;</a>
<a name="ln1389"> </a>
<a name="ln1390">    int mon_wanted = roll_dice(3, size);</a>
<a name="ln1391"> </a>
<a name="ln1392">    if (mon_wanted &gt; 60)</a>
<a name="ln1393">        mon_wanted = 60;</a>
<a name="ln1394"> </a>
<a name="ln1395">    return mon_wanted;</a>
<a name="ln1396">}</a>
<a name="ln1397"> </a>
<a name="ln1398">static void _fixup_walls()</a>
<a name="ln1399">{</a>
<a name="ln1400">    // If level part of Dis -&gt; all walls metal.</a>
<a name="ln1401">    // If Vaults:$ -&gt; all walls metal or crystal.</a>
<a name="ln1402">    // If part of crypt -&gt; all walls stone.</a>
<a name="ln1403"> </a>
<a name="ln1404">    dungeon_feature_type wall_type = DNGN_ROCK_WALL;</a>
<a name="ln1405"> </a>
<a name="ln1406">    if (!player_in_connected_branch())</a>
<a name="ln1407">        return;</a>
<a name="ln1408"> </a>
<a name="ln1409">    switch (you.where_are_you)</a>
<a name="ln1410">    {</a>
<a name="ln1411">    case BRANCH_DIS:</a>
<a name="ln1412">        wall_type = DNGN_METAL_WALL;</a>
<a name="ln1413">        break;</a>
<a name="ln1414"> </a>
<a name="ln1415">    case BRANCH_VAULTS:</a>
<a name="ln1416">    {</a>
<a name="ln1417">        // Everything but the branch end is handled in Lua.</a>
<a name="ln1418">        if (you.depth == branches[BRANCH_VAULTS].numlevels)</a>
<a name="ln1419">        {</a>
<a name="ln1420">            wall_type = random_choose_weighted(1, DNGN_CRYSTAL_WALL,</a>
<a name="ln1421">                                               9, DNGN_METAL_WALL);</a>
<a name="ln1422">        }</a>
<a name="ln1423">        break;</a>
<a name="ln1424">    }</a>
<a name="ln1425"> </a>
<a name="ln1426">    case BRANCH_CRYPT:</a>
<a name="ln1427">        wall_type = DNGN_STONE_WALL;</a>
<a name="ln1428">        break;</a>
<a name="ln1429"> </a>
<a name="ln1430">    case BRANCH_SLIME:</a>
<a name="ln1431">        wall_type = DNGN_SLIMY_WALL;</a>
<a name="ln1432">        break;</a>
<a name="ln1433"> </a>
<a name="ln1434">    default:</a>
<a name="ln1435">        return;</a>
<a name="ln1436">    }</a>
<a name="ln1437"> </a>
<a name="ln1438">    dgn_replace_area(0, 0, GXM-1, GYM-1, DNGN_ROCK_WALL, wall_type,</a>
<a name="ln1439">                     MMT_NO_WALL);</a>
<a name="ln1440">}</a>
<a name="ln1441"> </a>
<a name="ln1442">// Remove any items that are on squares that items should not be on.</a>
<a name="ln1443">// link_items() must be called after this function.</a>
<a name="ln1444">void fixup_misplaced_items()</a>
<a name="ln1445">{</a>
<a name="ln1446">    for (auto &amp;item : mitm)</a>
<a name="ln1447">    {</a>
<a name="ln1448">        if (!item.defined() || item.held_by_monster())</a>
<a name="ln1449">            continue;</a>
<a name="ln1450"> </a>
<a name="ln1451">        if (in_bounds(item.pos))</a>
<a name="ln1452">        {</a>
<a name="ln1453">            dungeon_feature_type feat = grd(item.pos);</a>
<a name="ln1454">            if (feat_has_solid_floor(feat))</a>
<a name="ln1455">                continue;</a>
<a name="ln1456"> </a>
<a name="ln1457">            // We accept items in deep water in the Abyss---they are likely to</a>
<a name="ln1458">            // be revealed eventually by morphing, and having deep water push</a>
<a name="ln1459">            // items away leads to strange results.</a>
<a name="ln1460">            if (feat == DNGN_DEEP_WATER &amp;&amp; player_in_branch(BRANCH_ABYSS))</a>
<a name="ln1461">                continue;</a>
<a name="ln1462"> </a>
<a name="ln1463">            mprf(MSGCH_ERROR, &quot;Item %s buggily placed in feature %s at (%d, %d).&quot;,</a>
<a name="ln1464">                 item.name(DESC_PLAIN).c_str(),</a>
<a name="ln1465">                 feature_description_at(item.pos, false, DESC_PLAIN).c_str(),</a>
<a name="ln1466">                 item.pos.x, item.pos.y);</a>
<a name="ln1467">        }</a>
<a name="ln1468">        else</a>
<a name="ln1469">        {</a>
<a name="ln1470">            mprf(MSGCH_ERROR, &quot;Item buggily placed out of bounds at (%d, %d).&quot;,</a>
<a name="ln1471">                 item.pos.x, item.pos.y);</a>
<a name="ln1472">        }</a>
<a name="ln1473"> </a>
<a name="ln1474">        // Can't just unlink item because it might not have been linked yet.</a>
<a name="ln1475">        item.base_type = OBJ_UNASSIGNED;</a>
<a name="ln1476">        item.quantity = 0;</a>
<a name="ln1477">        item.pos.reset();</a>
<a name="ln1478">    }</a>
<a name="ln1479">}</a>
<a name="ln1480"> </a>
<a name="ln1481">/*</a>
<a name="ln1482"> * At the top or bottom of a branch, adjust or remove illegal stairs:</a>
<a name="ln1483"> *</a>
<a name="ln1484"> * - non-vault escape hatches pointing outside the branch are removed</a>
<a name="ln1485"> * - non-vault stone stairs down from X:$ are removed</a>
<a name="ln1486"> * - stone stairs up from X:1 are replaced with branch exit feature</a>
<a name="ln1487"> *   - if there is more than one such stair, an error is logged</a>
<a name="ln1488"> * - vault-specified hatches or stairs are replaced with appropriate features</a>
<a name="ln1489"> *   - hatches down from X:$ are pointed up instead, and vice versa on X:1</a>
<a name="ln1490"> *   - for single-level branches, all hatches turn into the branch exit feature</a>
<a name="ln1491"> *   - if the branch has an &quot;escape feature&quot;, it is used instead of hatches up</a>
<a name="ln1492"> */</a>
<a name="ln1493">static void _fixup_branch_stairs()</a>
<a name="ln1494">{</a>
<a name="ln1495">    const auto&amp; branch = your_branch();</a>
<a name="ln1496">    const bool root = player_in_branch(root_branch);</a>
<a name="ln1497">    const bool top = you.depth == 1;</a>
<a name="ln1498">    const bool bottom = at_branch_bottom();</a>
<a name="ln1499"> </a>
<a name="ln1500">    const dungeon_feature_type exit =</a>
<a name="ln1501">        root ? DNGN_EXIT_DUNGEON</a>
<a name="ln1502">             : branch.exit_stairs;</a>
<a name="ln1503">    const dungeon_feature_type escape =</a>
<a name="ln1504">        branch.escape_feature == NUM_FEATURES ? DNGN_ESCAPE_HATCH_UP :</a>
<a name="ln1505">                                                branch.escape_feature;</a>
<a name="ln1506">    const dungeon_feature_type up_hatch =</a>
<a name="ln1507">        top &amp;&amp; bottom ? exit :</a>
<a name="ln1508">                  top ? DNGN_ESCAPE_HATCH_DOWN :</a>
<a name="ln1509">                        escape;</a>
<a name="ln1510"> </a>
<a name="ln1511">#ifdef DEBUG_DIAGNOSTICS</a>
<a name="ln1512">    int count = 0;</a>
<a name="ln1513">#endif</a>
<a name="ln1514">    // Just in case we somehow get here with more than one stair placed.</a>
<a name="ln1515">    // Prefer stairs that are placed in vaults for picking an exit at</a>
<a name="ln1516">    // random.</a>
<a name="ln1517">    vector&lt;coord_def&gt; vault_stairs, normal_stairs;</a>
<a name="ln1518">    for (rectangle_iterator ri(1); ri; ++ri)</a>
<a name="ln1519">    {</a>
<a name="ln1520">        const bool vault = map_masked(*ri, MMT_VAULT);</a>
<a name="ln1521">        const auto escape_replacement = vault ? up_hatch : DNGN_FLOOR;</a>
<a name="ln1522">        if (bottom &amp;&amp; (feat_is_stone_stair_down(grd(*ri))</a>
<a name="ln1523">                       || grd(*ri) == DNGN_ESCAPE_HATCH_DOWN))</a>
<a name="ln1524">        {</a>
<a name="ln1525">            _set_grd(*ri, escape_replacement);</a>
<a name="ln1526">        }</a>
<a name="ln1527"> </a>
<a name="ln1528">        if (top)</a>
<a name="ln1529">        {</a>
<a name="ln1530">            if (grd(*ri) == DNGN_ESCAPE_HATCH_UP)</a>
<a name="ln1531">                _set_grd(*ri, escape_replacement);</a>
<a name="ln1532">            else if (feat_is_stone_stair_up(grd(*ri)))</a>
<a name="ln1533">            {</a>
<a name="ln1534">#ifdef DEBUG_DIAGNOSTICS</a>
<a name="ln1535">                if (count++ &amp;&amp; !root)</a>
<a name="ln1536">                {</a>
<a name="ln1537">                    mprf(MSGCH_ERROR, &quot;Multiple branch exits on %s&quot;,</a>
<a name="ln1538">                         level_id::current().describe().c_str());</a>
<a name="ln1539">                }</a>
<a name="ln1540">#endif</a>
<a name="ln1541">                if (root)</a>
<a name="ln1542">                {</a>
<a name="ln1543">                    env.markers.add(new map_feature_marker(*ri, grd(*ri)));</a>
<a name="ln1544">                    _set_grd(*ri, exit);</a>
<a name="ln1545">                }</a>
<a name="ln1546">                else</a>
<a name="ln1547">                {</a>
<a name="ln1548">                    if (vault)</a>
<a name="ln1549">                        vault_stairs.push_back(*ri);</a>
<a name="ln1550">                    else</a>
<a name="ln1551">                        normal_stairs.push_back(*ri);</a>
<a name="ln1552">                }</a>
<a name="ln1553">            }</a>
<a name="ln1554">        }</a>
<a name="ln1555">    }</a>
<a name="ln1556">    if (!root)</a>
<a name="ln1557">    {</a>
<a name="ln1558">        vector&lt;coord_def&gt; stairs;</a>
<a name="ln1559">        if (!vault_stairs.empty())</a>
<a name="ln1560">            stairs = vault_stairs;</a>
<a name="ln1561">        else</a>
<a name="ln1562">            stairs = normal_stairs;</a>
<a name="ln1563"> </a>
<a name="ln1564">        if (!stairs.empty())</a>
<a name="ln1565">        {</a>
<a name="ln1566">            shuffle_array(stairs);</a>
<a name="ln1567">            coord_def coord = *(stairs.begin());</a>
<a name="ln1568">            env.markers.add(new map_feature_marker(coord, grd(coord)));</a>
<a name="ln1569">            _set_grd(coord, exit);</a>
<a name="ln1570">            for (auto it = stairs.begin() + 1; it != stairs.end(); it++)</a>
<a name="ln1571">                _set_grd(*it, DNGN_FLOOR);</a>
<a name="ln1572">        }</a>
<a name="ln1573">    }</a>
<a name="ln1574">}</a>
<a name="ln1575"> </a>
<a name="ln1576">/// List all stone stairs of the indicated type.</a>
<a name="ln1577">static list&lt;coord_def&gt; _find_stone_stairs(bool up_stairs)</a>
<a name="ln1578">{</a>
<a name="ln1579">    list&lt;coord_def&gt; stairs;</a>
<a name="ln1580"> </a>
<a name="ln1581">    for (rectangle_iterator ri(1); ri; ++ri)</a>
<a name="ln1582">    {</a>
<a name="ln1583">        const coord_def&amp; c = *ri;</a>
<a name="ln1584">        if (feature_mimic_at(c))</a>
<a name="ln1585">            continue;</a>
<a name="ln1586"> </a>
<a name="ln1587">        const dungeon_feature_type feat = grd(c);</a>
<a name="ln1588">        if (feat_is_stone_stair(feat)</a>
<a name="ln1589">            &amp;&amp; up_stairs == feat_is_stone_stair_up(feat))</a>
<a name="ln1590">        {</a>
<a name="ln1591">            stairs.push_back(c);</a>
<a name="ln1592">        }</a>
<a name="ln1593">    }</a>
<a name="ln1594"> </a>
<a name="ln1595">    return stairs;</a>
<a name="ln1596">}</a>
<a name="ln1597"> </a>
<a name="ln1598">/**</a>
<a name="ln1599"> * Try to turn excess stairs into hatches.</a>
<a name="ln1600"> *</a>
<a name="ln1601"> * @param stairs[in,out]    The list of stairs to be trimmed; any stairs that</a>
<a name="ln1602"> *                          are turned into hatches will be removed.</a>
<a name="ln1603"> * @param needed_stairs     The desired number of stairs.</a>
<a name="ln1604"> * @param preserve_vault_stairs    Don't trapdoorify stairs that are in vaults.</a>
<a name="ln1605"> * @param hatch_type        What sort of hatch to turn excess stairs into.</a>
<a name="ln1606"> */</a>
<a name="ln1607">static void _cull_redundant_stairs(list&lt;coord_def&gt; &amp;stairs,</a>
<a name="ln1608">                                   unsigned int needed_stairs,</a>
<a name="ln1609">                                   bool preserve_vault_stairs,</a>
<a name="ln1610">                                   dungeon_feature_type hatch_type)</a>
<a name="ln1611">{</a>
<a name="ln1612">    // we're going to iterate over the list, looking for redundant stairs.</a>
<a name="ln1613">    // (redundant = can walk from one to the other.) For each of</a>
<a name="ln1614">    // those iterations, we'll iterate over the remaining list checking for</a>
<a name="ln1615">    // stairs redundant with the outer iteration, and hatchify + remove from</a>
<a name="ln1616">    // the stair list any redundant stairs we find.</a>
<a name="ln1617"> </a>
<a name="ln1618">    for (auto iter1 = stairs.begin();</a>
<a name="ln1619">         iter1 != stairs.end() &amp;&amp; stairs.size() &lt;= needed_stairs;</a>
<a name="ln1620">         ++iter1)</a>
<a name="ln1621">    {</a>
<a name="ln1622">        const coord_def s1_loc = *iter1;</a>
<a name="ln1623">        // Ensure we don't search for the feature at s1. XXX: unwind_var?</a>
<a name="ln1624">        const dungeon_feature_type saved_feat = grd(s1_loc);</a>
<a name="ln1625">        grd(s1_loc) = DNGN_FLOOR;</a>
<a name="ln1626"> </a>
<a name="ln1627">        auto iter2 = iter1;</a>
<a name="ln1628">        ++iter2;</a>
<a name="ln1629">        while (iter2 != stairs.end() &amp;&amp; stairs.size() &gt; needed_stairs)</a>
<a name="ln1630">        {</a>
<a name="ln1631">            const coord_def s2_loc = *iter2;</a>
<a name="ln1632">            auto being_examined = iter2;</a>
<a name="ln1633">            ++iter2;</a>
<a name="ln1634"> </a>
<a name="ln1635">            if (preserve_vault_stairs &amp;&amp; map_masked(s2_loc, MMT_VAULT))</a>
<a name="ln1636">                continue;</a>
<a name="ln1637"> </a>
<a name="ln1638">            flood_find&lt;feature_grid, coord_predicate&gt; ff(env.grid,</a>
<a name="ln1639">                                                         in_bounds);</a>
<a name="ln1640">            ff.add_feat(grd(s2_loc));</a>
<a name="ln1641">            const coord_def where =</a>
<a name="ln1642">                ff.find_first_from(s1_loc, env.level_map_mask);</a>
<a name="ln1643">            if (!where.x) // these stairs aren't in the same zone</a>
<a name="ln1644">                continue;</a>
<a name="ln1645"> </a>
<a name="ln1646">            dprf(DIAG_DNGN,</a>
<a name="ln1647">                 &quot;Too many stairs -- removing one of a connected pair.&quot;);</a>
<a name="ln1648">            grd(s2_loc) = hatch_type;</a>
<a name="ln1649">            stairs.erase(being_examined);</a>
<a name="ln1650">        }</a>
<a name="ln1651"> </a>
<a name="ln1652">        grd(s1_loc) = saved_feat;</a>
<a name="ln1653">    }</a>
<a name="ln1654">}</a>
<a name="ln1655"> </a>
<a name="ln1656">/**</a>
<a name="ln1657"> * Trapdoorify stairs at random, until we reach the specified number.</a>
<a name="ln1658"> * @param stairs[in,out]    The list of stairs to be trimmed; any stairs that</a>
<a name="ln1659"> *                          are turned into hatches will be removed. Order not</a>
<a name="ln1660"> *                          preserved.</a>
<a name="ln1661"> * @param needed_stairs     The desired number of stairs.</a>
<a name="ln1662"> * @param preserve_vault_stairs    Don't remove stairs that are in vaults.</a>
<a name="ln1663"> * @param hatch_type        What sort of hatch to turn excess stairs into.</a>
<a name="ln1664"> */</a>
<a name="ln1665">static void _cull_random_stairs(list&lt;coord_def&gt; &amp;stairs,</a>
<a name="ln1666">                                unsigned int needed_stairs,</a>
<a name="ln1667">                                bool preserve_vault_stairs,</a>
<a name="ln1668">                                dungeon_feature_type hatch_type)</a>
<a name="ln1669">{</a>
<a name="ln1670">    while (stairs.size() &gt; needed_stairs)</a>
<a name="ln1671">    {</a>
<a name="ln1672">        const int remove_index = random2(stairs.size());</a>
<a name="ln1673">        // rotate the list until the desired element is in front</a>
<a name="ln1674">        for (int i = 0; i &lt; remove_index; ++i)</a>
<a name="ln1675">        {</a>
<a name="ln1676">            stairs.push_back(stairs.front());</a>
<a name="ln1677">            stairs.pop_front();</a>
<a name="ln1678">        }</a>
<a name="ln1679"> </a>
<a name="ln1680">        if (preserve_vault_stairs)</a>
<a name="ln1681">        {</a>
<a name="ln1682">            // try to rotate a non-vault stair to the front, if possible.</a>
<a name="ln1683">            for (size_t i = 0; i &lt; stairs.size(); ++i)</a>
<a name="ln1684">            {</a>
<a name="ln1685">                if (map_masked(stairs.front(), MMT_VAULT))</a>
<a name="ln1686">                {</a>
<a name="ln1687">                    stairs.push_back(stairs.front());</a>
<a name="ln1688">                    stairs.pop_front();</a>
<a name="ln1689">                }</a>
<a name="ln1690">            }</a>
<a name="ln1691"> </a>
<a name="ln1692">            // If we looped through all possibilities, then it</a>
<a name="ln1693">            // means that there are more than 3 stairs in vaults and</a>
<a name="ln1694">            // we can't preserve vault stairs.</a>
<a name="ln1695">            if (map_masked(stairs.front(), MMT_VAULT))</a>
<a name="ln1696">            {</a>
<a name="ln1697">                dprf(DIAG_DNGN, &quot;Too many stairs inside vaults!&quot;);</a>
<a name="ln1698">                return;</a>
<a name="ln1699">            }</a>
<a name="ln1700">        }</a>
<a name="ln1701"> </a>
<a name="ln1702">        dprf(DIAG_DNGN, &quot;Too many stairs -- removing one blindly.&quot;);</a>
<a name="ln1703">        _set_grd(stairs.front(), hatch_type);</a>
<a name="ln1704">        stairs.pop_front();</a>
<a name="ln1705">    }</a>
<a name="ln1706">}</a>
<a name="ln1707"> </a>
<a name="ln1708">/**</a>
<a name="ln1709"> * Ensure that there is only the correct number of each type of 'stone'</a>
<a name="ln1710"> * (permanent, intra-branch, non-trapdoor) stair on the current level.</a>
<a name="ln1711"> *</a>
<a name="ln1712"> * @param preserve_vault_stairs     Don't delete or trapdoorify stairs that are</a>
<a name="ln1713"> *                                  in vaults.</a>
<a name="ln1714"> * @param checking_up_stairs        Whether we're looking at stairs that lead</a>
<a name="ln1715"> *                                  up. If false, we're looking at down-stairs.</a>
<a name="ln1716"> * @return                          Whether we successfully set the right # of</a>
<a name="ln1717"> *                                  stairs for the level.</a>
<a name="ln1718"> */</a>
<a name="ln1719">static bool _fixup_stone_stairs(bool preserve_vault_stairs,</a>
<a name="ln1720">                                bool checking_up_stairs)</a>
<a name="ln1721">{</a>
<a name="ln1722">    list&lt;coord_def&gt; stairs = _find_stone_stairs(checking_up_stairs);</a>
<a name="ln1723"> </a>
<a name="ln1724">    unsigned int needed_stairs;</a>
<a name="ln1725">    dungeon_feature_type base;</a>
<a name="ln1726">    dungeon_feature_type replace;</a>
<a name="ln1727">    if (checking_up_stairs)</a>
<a name="ln1728">    {</a>
<a name="ln1729">        replace = DNGN_FLOOR;</a>
<a name="ln1730">        base = DNGN_STONE_STAIRS_UP_I;</a>
<a name="ln1731">        // Pan abuses stair placement for transits, as we want connectivity</a>
<a name="ln1732">        // checks.</a>
<a name="ln1733">        needed_stairs = you.depth == 1</a>
<a name="ln1734">                        &amp;&amp; !player_in_branch(BRANCH_PANDEMONIUM)</a>
<a name="ln1735">                        ? 1 : 3;</a>
<a name="ln1736">    }</a>
<a name="ln1737">    else</a>
<a name="ln1738">    {</a>
<a name="ln1739">        replace = DNGN_FLOOR;</a>
<a name="ln1740">        base = DNGN_STONE_STAIRS_DOWN_I;</a>
<a name="ln1741"> </a>
<a name="ln1742">        if (at_branch_bottom())</a>
<a name="ln1743">            needed_stairs = 0;</a>
<a name="ln1744">        else</a>
<a name="ln1745">            needed_stairs = 3;</a>
<a name="ln1746">    }</a>
<a name="ln1747"> </a>
<a name="ln1748">    // In Zot, don't create extra escape hatches, in order to force</a>
<a name="ln1749">    // the player through vaults that use all three down stone stairs.</a>
<a name="ln1750">    if (player_in_branch(BRANCH_ZOT))</a>
<a name="ln1751">    {</a>
<a name="ln1752">        replace = random_choose(DNGN_FOUNTAIN_BLUE,</a>
<a name="ln1753">                                DNGN_FOUNTAIN_SPARKLING,</a>
<a name="ln1754">                                DNGN_FOUNTAIN_BLOOD);</a>
<a name="ln1755">    }</a>
<a name="ln1756"> </a>
<a name="ln1757">    dprf(DIAG_DNGN, &quot;Before culling: %d/%d %s stairs&quot;,</a>
<a name="ln1758">         (int)stairs.size(), needed_stairs, checking_up_stairs ? &quot;up&quot; : &quot;down&quot;);</a>
<a name="ln1759"> </a>
<a name="ln1760">    // Find pairwise stairs that are connected and turn one of them</a>
<a name="ln1761">    // into an escape hatch of the appropriate type.</a>
<a name="ln1762">    if (stairs.size() &gt; needed_stairs)</a>
<a name="ln1763">    {</a>
<a name="ln1764">        _cull_redundant_stairs(stairs, needed_stairs,</a>
<a name="ln1765">                               preserve_vault_stairs, replace);</a>
<a name="ln1766">    }</a>
<a name="ln1767"> </a>
<a name="ln1768">    // If that doesn't work, remove random stairs.</a>
<a name="ln1769">    if (stairs.size() &gt; needed_stairs)</a>
<a name="ln1770">    {</a>
<a name="ln1771">        _cull_random_stairs(stairs, needed_stairs,</a>
<a name="ln1772">                            preserve_vault_stairs, replace);</a>
<a name="ln1773">    }</a>
<a name="ln1774"> </a>
<a name="ln1775">    // FIXME: stairs that generate inside random vaults are still</a>
<a name="ln1776">    // protected, resulting in superfluous ones.</a>
<a name="ln1777">    dprf(DIAG_DNGN, &quot;After culling: %d/%d %s stairs&quot;,</a>
<a name="ln1778">         (int)stairs.size(), needed_stairs, checking_up_stairs ? &quot;up&quot; : &quot;down&quot;);</a>
<a name="ln1779"> </a>
<a name="ln1780">    // XXX: this logic is exceptionally shady &amp; should be reviewed</a>
<a name="ln1781">    if (stairs.size() &gt; needed_stairs &amp;&amp; preserve_vault_stairs</a>
<a name="ln1782">        &amp;&amp; (!checking_up_stairs || you.depth != 1</a>
<a name="ln1783">            || !player_in_branch(root_branch)))</a>
<a name="ln1784">    {</a>
<a name="ln1785">        return false;</a>
<a name="ln1786">    }</a>
<a name="ln1787"> </a>
<a name="ln1788">    // If there are no stairs, it's either a branch entrance or exit.</a>
<a name="ln1789">    // If we somehow have ended up in a catastrophic &quot;no stairs&quot; state,</a>
<a name="ln1790">    // the level will not be validated, so we do not need to catch it here.</a>
<a name="ln1791">    if (stairs.size() == 0)</a>
<a name="ln1792">        return true;</a>
<a name="ln1793"> </a>
<a name="ln1794">    // Add extra stairs to get to exactly three.</a>
<a name="ln1795">    for (unsigned int s = stairs.size(); s &lt; needed_stairs; s++)</a>
<a name="ln1796">    {</a>
<a name="ln1797">        const uint32_t mask = preserve_vault_stairs ? MMT_VAULT : 0;</a>
<a name="ln1798">        const coord_def gc</a>
<a name="ln1799">            = _dgn_random_point_in_bounds(DNGN_FLOOR, mask, DNGN_UNSEEN);</a>
<a name="ln1800"> </a>
<a name="ln1801">        if (gc.origin())</a>
<a name="ln1802">            return false;</a>
<a name="ln1803"> </a>
<a name="ln1804">        dprf(DIAG_DNGN, &quot;Adding stair %d at (%d,%d)&quot;, s, gc.x, gc.y);</a>
<a name="ln1805">        // base gets fixed up to be the right stone stair below...</a>
<a name="ln1806">        _set_grd(gc, base);</a>
<a name="ln1807">        stairs.push_back(gc);</a>
<a name="ln1808">    }</a>
<a name="ln1809"> </a>
<a name="ln1810">    // If we only need one stone stair, make sure it's _I.</a>
<a name="ln1811">    if (needed_stairs != 3)</a>
<a name="ln1812">    {</a>
<a name="ln1813">        ASSERT(checking_up_stairs);</a>
<a name="ln1814">        ASSERT(needed_stairs == 1);</a>
<a name="ln1815">        ASSERT(stairs.size() == 1 || player_in_branch(root_branch));</a>
<a name="ln1816">        if (stairs.size() == 1)</a>
<a name="ln1817">            grd(stairs.front()) = DNGN_STONE_STAIRS_UP_I;</a>
<a name="ln1818"> </a>
<a name="ln1819">        return true;</a>
<a name="ln1820">    }</a>
<a name="ln1821"> </a>
<a name="ln1822">    // Ensure uniqueness of three stairs.</a>
<a name="ln1823">    ASSERT(needed_stairs == 3);</a>
<a name="ln1824">    for (size_t s = 0; s &lt; needed_stairs + 1; s++)</a>
<a name="ln1825">    {</a>
<a name="ln1826">        const coord_def s1_loc = stairs.front();</a>
<a name="ln1827">        const coord_def s2_loc = stairs.back();</a>
<a name="ln1828">        if (grd(s1_loc) == grd(s2_loc))</a>
<a name="ln1829">        {</a>
<a name="ln1830">            _set_grd(s2_loc, (dungeon_feature_type)</a>
<a name="ln1831">                     (base + (grd(s2_loc)-base+1) % needed_stairs));</a>
<a name="ln1832">        }</a>
<a name="ln1833"> </a>
<a name="ln1834">        stairs.push_back(stairs.front());</a>
<a name="ln1835">        stairs.pop_front();</a>
<a name="ln1836">    }</a>
<a name="ln1837"> </a>
<a name="ln1838">    return true;</a>
<a name="ln1839">}</a>
<a name="ln1840"> </a>
<a name="ln1841">static bool _fixup_stone_stairs(bool preserve_vault_stairs)</a>
<a name="ln1842">{</a>
<a name="ln1843">    // This function ensures that there is exactly one each up and down</a>
<a name="ln1844">    // stone stairs I, II, and III. More than three stairs will result in</a>
<a name="ln1845">    // turning additional stairs into escape hatches (with an attempt to keep</a>
<a name="ln1846">    // level connectivity). Fewer than three stone stairs will result in</a>
<a name="ln1847">    // random placement of new stairs.</a>
<a name="ln1848">    const bool upstairs_fixed = _fixup_stone_stairs(preserve_vault_stairs,</a>
<a name="ln1849">                                                    true);</a>
<a name="ln1850">    const bool downstairs_fixed = _fixup_stone_stairs(preserve_vault_stairs,</a>
<a name="ln1851">                                                      false);</a>
<a name="ln1852">    return upstairs_fixed &amp;&amp; downstairs_fixed;</a>
<a name="ln1853">}</a>
<a name="ln1854"> </a>
<a name="ln1855">static bool _add_feat_if_missing(bool (*iswanted)(const coord_def &amp;),</a>
<a name="ln1856">                                 dungeon_feature_type feat)</a>
<a name="ln1857">{</a>
<a name="ln1858">    memset(travel_point_distance, 0, sizeof(travel_distance_grid_t));</a>
<a name="ln1859">    int nzones = 0;</a>
<a name="ln1860">    for (int y = 0; y &lt; GYM; ++y)</a>
<a name="ln1861">        for (int x = 0; x &lt; GXM; ++x)</a>
<a name="ln1862">        {</a>
<a name="ln1863">            // [ds] Use dgn_square_is_passable instead of</a>
<a name="ln1864">            // dgn_square_travel_ok here, for we'll otherwise</a>
<a name="ln1865">            // fail on floorless isolated pocket in vaults (like the</a>
<a name="ln1866">            // altar surrounded by deep water), and trigger the assert</a>
<a name="ln1867">            // downstairs.</a>
<a name="ln1868">            const coord_def gc(x, y);</a>
<a name="ln1869">            if (!map_bounds(x, y)</a>
<a name="ln1870">                || travel_point_distance[x][y] // already covered previously</a>
<a name="ln1871">                || !_dgn_square_is_passable(gc))</a>
<a name="ln1872">            {</a>
<a name="ln1873">                continue;</a>
<a name="ln1874">            }</a>
<a name="ln1875"> </a>
<a name="ln1876">            if (_dgn_fill_zone(gc, ++nzones, _dgn_point_record_stub,</a>
<a name="ln1877">                               _dgn_square_is_passable, iswanted))</a>
<a name="ln1878">            {</a>
<a name="ln1879">                continue;</a>
<a name="ln1880">            }</a>
<a name="ln1881"> </a>
<a name="ln1882">            bool found_feature = false;</a>
<a name="ln1883">            for (rectangle_iterator ri(0); ri; ++ri)</a>
<a name="ln1884">            {</a>
<a name="ln1885">                if (grd(*ri) == feat</a>
<a name="ln1886">                    &amp;&amp; travel_point_distance[ri-&gt;x][ri-&gt;y] == nzones)</a>
<a name="ln1887">                {</a>
<a name="ln1888">                    found_feature = true;</a>
<a name="ln1889">                    break;</a>
<a name="ln1890">                }</a>
<a name="ln1891">            }</a>
<a name="ln1892"> </a>
<a name="ln1893">            if (found_feature)</a>
<a name="ln1894">                continue;</a>
<a name="ln1895"> </a>
<a name="ln1896">            int i = 0;</a>
<a name="ln1897">            while (i++ &lt; 2000)</a>
<a name="ln1898">            {</a>
<a name="ln1899">                coord_def rnd;</a>
<a name="ln1900">                rnd.x = random2(GXM);</a>
<a name="ln1901">                rnd.y = random2(GYM);</a>
<a name="ln1902">                if (grd(rnd) != DNGN_FLOOR)</a>
<a name="ln1903">                    continue;</a>
<a name="ln1904"> </a>
<a name="ln1905">                if (travel_point_distance[rnd.x][rnd.y] != nzones)</a>
<a name="ln1906">                    continue;</a>
<a name="ln1907"> </a>
<a name="ln1908">                _set_grd(rnd, feat);</a>
<a name="ln1909">                found_feature = true;</a>
<a name="ln1910">                break;</a>
<a name="ln1911">            }</a>
<a name="ln1912"> </a>
<a name="ln1913">            if (found_feature)</a>
<a name="ln1914">                continue;</a>
<a name="ln1915"> </a>
<a name="ln1916">            for (rectangle_iterator ri(0); ri; ++ri)</a>
<a name="ln1917">            {</a>
<a name="ln1918">                if (grd(*ri) != DNGN_FLOOR)</a>
<a name="ln1919">                    continue;</a>
<a name="ln1920"> </a>
<a name="ln1921">                if (travel_point_distance[ri-&gt;x][ri-&gt;y] != nzones)</a>
<a name="ln1922">                    continue;</a>
<a name="ln1923"> </a>
<a name="ln1924">                _set_grd(*ri, feat);</a>
<a name="ln1925">                found_feature = true;</a>
<a name="ln1926">                break;</a>
<a name="ln1927">            }</a>
<a name="ln1928"> </a>
<a name="ln1929">            if (found_feature)</a>
<a name="ln1930">                continue;</a>
<a name="ln1931"> </a>
<a name="ln1932">#ifdef DEBUG_DIAGNOSTICS</a>
<a name="ln1933">            dump_map(&quot;debug.map&quot;, true, true);</a>
<a name="ln1934">#endif</a>
<a name="ln1935">            // [ds] Too many normal cases trigger this ASSERT, including</a>
<a name="ln1936">            // rivers that surround a stair with deep water.</a>
<a name="ln1937">            // die(&quot;Couldn't find region.&quot;);</a>
<a name="ln1938">            return false;</a>
<a name="ln1939">        }</a>
<a name="ln1940"> </a>
<a name="ln1941">    return true;</a>
<a name="ln1942">}</a>
<a name="ln1943"> </a>
<a name="ln1944">static bool _add_connecting_escape_hatches()</a>
<a name="ln1945">{</a>
<a name="ln1946">    // For any regions without a down stone stair case, add an</a>
<a name="ln1947">    // escape hatch. This will always allow (downward) progress.</a>
<a name="ln1948"> </a>
<a name="ln1949">    if (branches[you.where_are_you].branch_flags &amp; brflag::islanded)</a>
<a name="ln1950">        return true;</a>
<a name="ln1951"> </a>
<a name="ln1952">    // Veto D:1 or Pan if there are disconnected areas.</a>
<a name="ln1953">    if (player_in_branch(BRANCH_PANDEMONIUM)</a>
<a name="ln1954">        || (player_in_branch(BRANCH_DUNGEON) &amp;&amp; you.depth == 1))</a>
<a name="ln1955">    {</a>
<a name="ln1956">        // Allow == 0 in case the entire level is one opaque vault.</a>
<a name="ln1957">        return dgn_count_disconnected_zones(false) &lt;= 1;</a>
<a name="ln1958">    }</a>
<a name="ln1959"> </a>
<a name="ln1960">    if (!player_in_connected_branch())</a>
<a name="ln1961">        return true;</a>
<a name="ln1962"> </a>
<a name="ln1963">    if (at_branch_bottom())</a>
<a name="ln1964">        return dgn_count_disconnected_zones(true) == 0;</a>
<a name="ln1965"> </a>
<a name="ln1966">    if (!_add_feat_if_missing(_is_perm_down_stair, DNGN_ESCAPE_HATCH_DOWN))</a>
<a name="ln1967">        return false;</a>
<a name="ln1968"> </a>
<a name="ln1969">    // FIXME: shouldn't depend on branch.</a>
<a name="ln1970">    if (!player_in_branch(BRANCH_ORC))</a>
<a name="ln1971">        return true;</a>
<a name="ln1972"> </a>
<a name="ln1973">    return _add_feat_if_missing(_is_upwards_exit_stair, DNGN_ESCAPE_HATCH_UP);</a>
<a name="ln1974">}</a>
<a name="ln1975"> </a>
<a name="ln1976">static bool _branch_entrances_are_connected()</a>
<a name="ln1977">{</a>
<a name="ln1978">    // Returns true if all branch entrances on the level are connected to</a>
<a name="ln1979">    // stone stairs.</a>
<a name="ln1980">    for (rectangle_iterator ri(0); ri; ++ri)</a>
<a name="ln1981">    {</a>
<a name="ln1982">        if (!feat_is_branch_entrance(grd(*ri)))</a>
<a name="ln1983">            continue;</a>
<a name="ln1984">        if (!_has_connected_stone_stairs_from(*ri))</a>
<a name="ln1985">            return false;</a>
<a name="ln1986">    }</a>
<a name="ln1987"> </a>
<a name="ln1988">    return true;</a>
<a name="ln1989">}</a>
<a name="ln1990"> </a>
<a name="ln1991">static bool _branch_needs_stairs()</a>
<a name="ln1992">{</a>
<a name="ln1993">    // Irrelevant for branches with a single level and all encompass maps.</a>
<a name="ln1994">    return !player_in_branch(BRANCH_ZIGGURAT)</a>
<a name="ln1995">        &amp;&amp; !player_in_branch(BRANCH_TOMB);</a>
<a name="ln1996">}</a>
<a name="ln1997"> </a>
<a name="ln1998">static void _dgn_verify_connectivity(unsigned nvaults)</a>
<a name="ln1999">{</a>
<a name="ln2000">    // After placing vaults, make sure parts of the level have not been</a>
<a name="ln2001">    // disconnected.</a>
<a name="ln2002">    if (dgn_zones &amp;&amp; nvaults != env.level_vaults.size())</a>
<a name="ln2003">    {</a>
<a name="ln2004">        const int newzones = dgn_count_disconnected_zones(false);</a>
<a name="ln2005"> </a>
<a name="ln2006">#ifdef DEBUG_STATISTICS</a>
<a name="ln2007">        ostringstream vlist;</a>
<a name="ln2008">        for (unsigned i = nvaults; i &lt; env.level_vaults.size(); ++i)</a>
<a name="ln2009">        {</a>
<a name="ln2010">            if (i &gt; nvaults)</a>
<a name="ln2011">                vlist &lt;&lt; &quot;, &quot;;</a>
<a name="ln2012">            vlist &lt;&lt; env.level_vaults[i]-&gt;map.name;</a>
<a name="ln2013">        }</a>
<a name="ln2014">        dprf(DIAG_DNGN, &quot;Dungeon has %d zones after placing %s.&quot;,</a>
<a name="ln2015">             newzones, vlist.str().c_str());</a>
<a name="ln2016">#endif</a>
<a name="ln2017">        if (newzones &gt; dgn_zones)</a>
<a name="ln2018">        {</a>
<a name="ln2019">            throw dgn_veto_exception(make_stringf(</a>
<a name="ln2020">                 &quot;Had %d zones, now has %d%s%s.&quot;, dgn_zones, newzones,</a>
<a name="ln2021">#ifdef DEBUG_STATISTICS</a>
<a name="ln2022">                 &quot;; broken by &quot;, vlist.str().c_str()</a>
<a name="ln2023">#else</a>
<a name="ln2024">                 &quot;&quot;, &quot;&quot;</a>
<a name="ln2025">#endif</a>
<a name="ln2026">            ));</a>
<a name="ln2027">        }</a>
<a name="ln2028">    }</a>
<a name="ln2029"> </a>
<a name="ln2030">    // Also check for isolated regions that have no stairs.</a>
<a name="ln2031">    if (player_in_connected_branch()</a>
<a name="ln2032">        &amp;&amp; !(branches[you.where_are_you].branch_flags &amp; brflag::islanded)</a>
<a name="ln2033">        &amp;&amp; dgn_count_disconnected_zones(true) &gt; 0)</a>
<a name="ln2034">    {</a>
<a name="ln2035">        throw dgn_veto_exception(&quot;Isolated areas with no stairs.&quot;);</a>
<a name="ln2036">    }</a>
<a name="ln2037"> </a>
<a name="ln2038">    if (_branch_needs_stairs() &amp;&amp; !_fixup_stone_stairs(true))</a>
<a name="ln2039">    {</a>
<a name="ln2040">        dprf(DIAG_DNGN, &quot;Warning: failed to preserve vault stairs.&quot;);</a>
<a name="ln2041">        if (!_fixup_stone_stairs(false))</a>
<a name="ln2042">            throw dgn_veto_exception(&quot;Failed to fix stone stairs.&quot;);</a>
<a name="ln2043">    }</a>
<a name="ln2044"> </a>
<a name="ln2045">    if (!_branch_entrances_are_connected())</a>
<a name="ln2046">        throw dgn_veto_exception(&quot;A disconnected branch entrance.&quot;);</a>
<a name="ln2047"> </a>
<a name="ln2048">    if (!_add_connecting_escape_hatches())</a>
<a name="ln2049">        throw dgn_veto_exception(&quot;Failed to add connecting escape hatches.&quot;);</a>
<a name="ln2050"> </a>
<a name="ln2051">    // XXX: Interlevel connectivity fixup relies on being the last</a>
<a name="ln2052">    //      point at which a level may be vetoed.</a>
<a name="ln2053">    if (!_fixup_interlevel_connectivity())</a>
<a name="ln2054">        throw dgn_veto_exception(&quot;Failed to ensure interlevel connectivity.&quot;);</a>
<a name="ln2055">}</a>
<a name="ln2056"> </a>
<a name="ln2057">// Structure of OVERFLOW_TEMPLES:</a>
<a name="ln2058">//</a>
<a name="ln2059">// * A vector, with one cell per dungeon level (unset if there's no</a>
<a name="ln2060">//   overflow temples on that level).</a>
<a name="ln2061">//</a>
<a name="ln2062">// * The cell of the previous vector is a vector, with one overflow</a>
<a name="ln2063">//   temple definition per cell.</a>
<a name="ln2064">//</a>
<a name="ln2065">// * The cell of the previous vector is a hash table, containing the</a>
<a name="ln2066">//   list of gods for the overflow temple and (optionally) the name of</a>
<a name="ln2067">//   the vault to use for the temple. If no map name is supplied,</a>
<a name="ln2068">//   it will randomly pick from vaults tagged &quot;temple_overflow_num&quot;,</a>
<a name="ln2069">//   where &quot;num&quot; is the number of gods in the temple. Gods are listed</a>
<a name="ln2070">//   in the order their altars are placed.</a>
<a name="ln2071">static void _build_overflow_temples()</a>
<a name="ln2072">{</a>
<a name="ln2073">    // Levels built while in testing mode.</a>
<a name="ln2074">    if (!you.props.exists(OVERFLOW_TEMPLES_KEY))</a>
<a name="ln2075">        return;</a>
<a name="ln2076"> </a>
<a name="ln2077">    CrawlVector &amp;levels = you.props[OVERFLOW_TEMPLES_KEY].get_vector();</a>
<a name="ln2078"> </a>
<a name="ln2079">    // Are we deeper than the last overflow temple?</a>
<a name="ln2080">    if (you.depth &gt;= levels.size() + 1)</a>
<a name="ln2081">        return;</a>
<a name="ln2082"> </a>
<a name="ln2083">    CrawlStoreValue &amp;val = levels[you.depth - 1];</a>
<a name="ln2084"> </a>
<a name="ln2085">    // Does this level have an overflow temple?</a>
<a name="ln2086">    if (val.get_flags() &amp; SFLAG_UNSET)</a>
<a name="ln2087">        return;</a>
<a name="ln2088"> </a>
<a name="ln2089">    CrawlVector &amp;temples = val.get_vector();</a>
<a name="ln2090"> </a>
<a name="ln2091">    if (temples.empty())</a>
<a name="ln2092">        return;</a>
<a name="ln2093"> </a>
<a name="ln2094">    for (unsigned int i = 0; i &lt; temples.size(); i++)</a>
<a name="ln2095">    {</a>
<a name="ln2096">        CrawlHashTable &amp;temple = temples[i].get_table();</a>
<a name="ln2097"> </a>
<a name="ln2098">        const int num_gods = _setup_temple_altars(temple);</a>
<a name="ln2099"> </a>
<a name="ln2100">        const map_def *vault = nullptr;</a>
<a name="ln2101">        string vault_tag = &quot;&quot;;</a>
<a name="ln2102">        string name = &quot;&quot;;</a>
<a name="ln2103"> </a>
<a name="ln2104">        if (temple.exists(TEMPLE_MAP_KEY))</a>
<a name="ln2105">        {</a>
<a name="ln2106">            name = temple[TEMPLE_MAP_KEY].get_string();</a>
<a name="ln2107"> </a>
<a name="ln2108">            vault = find_map_by_name(name);</a>
<a name="ln2109">            if (vault == nullptr)</a>
<a name="ln2110">            {</a>
<a name="ln2111">                mprf(MSGCH_ERROR,</a>
<a name="ln2112">                     &quot;Couldn't find overflow temple map '%s'!&quot;,</a>
<a name="ln2113">                     name.c_str());</a>
<a name="ln2114">            }</a>
<a name="ln2115">        }</a>
<a name="ln2116">        else</a>
<a name="ln2117">        {</a>
<a name="ln2118">            // First try to find a temple specialized for this combination of</a>
<a name="ln2119">            // gods.</a>
<a name="ln2120">            if (num_gods &gt; 1 || coinflip())</a>
<a name="ln2121">            {</a>
<a name="ln2122">                vault_tag = make_stringf(&quot;temple_overflow_%d&quot;, num_gods);</a>
<a name="ln2123"> </a>
<a name="ln2124">                CrawlVector &amp;god_vec = temple[TEMPLE_GODS_KEY];</a>
<a name="ln2125"> </a>
<a name="ln2126">                for (int j = 0; j &lt; num_gods; j++)</a>
<a name="ln2127">                {</a>
<a name="ln2128">                    god_type god = (god_type) god_vec[j].get_byte();</a>
<a name="ln2129"> </a>
<a name="ln2130">                    name = god_name(god);</a>
<a name="ln2131">                    name = replace_all(name, &quot; &quot;, &quot;_&quot;);</a>
<a name="ln2132">                    lowercase(name);</a>
<a name="ln2133"> </a>
<a name="ln2134">                    vault_tag = vault_tag + &quot; temple_overflow_&quot; + name;</a>
<a name="ln2135">                }</a>
<a name="ln2136"> </a>
<a name="ln2137">                if (num_gods == 1</a>
<a name="ln2138">                    &amp;&amp; get_uniq_map_tags().find(&quot;uniq_altar_&quot; + name)</a>
<a name="ln2139">                       != get_uniq_map_tags().end())</a>
<a name="ln2140">                {</a>
<a name="ln2141">                    // We've already placed a specialized temple for this</a>
<a name="ln2142">                    // god, so do nothing.</a>
<a name="ln2143">#ifdef DEBUG_TEMPLES</a>
<a name="ln2144">                    mprf(MSGCH_DIAGNOSTICS, &quot;Already placed specialized &quot;</a>
<a name="ln2145">                         &quot;single-altar temple for %s&quot;, name.c_str());</a>
<a name="ln2146">#endif</a>
<a name="ln2147">                    continue;</a>
<a name="ln2148">                }</a>
<a name="ln2149"> </a>
<a name="ln2150">                vault = random_map_for_tag(vault_tag, true);</a>
<a name="ln2151">#ifdef DEBUG_TEMPLES</a>
<a name="ln2152">                if (vault == nullptr)</a>
<a name="ln2153">                {</a>
<a name="ln2154">                    mprf(MSGCH_DIAGNOSTICS, &quot;Couldn't find overflow temple &quot;</a>
<a name="ln2155">                         &quot;for combination of tags %s&quot;, vault_tag.c_str());</a>
<a name="ln2156">                }</a>
<a name="ln2157">#endif</a>
<a name="ln2158">            }</a>
<a name="ln2159"> </a>
<a name="ln2160">            if (vault == nullptr)</a>
<a name="ln2161">            {</a>
<a name="ln2162">                vault_tag = make_stringf(&quot;temple_overflow_generic_%d&quot;,</a>
<a name="ln2163">                                         num_gods);</a>
<a name="ln2164"> </a>
<a name="ln2165">                vault = random_map_for_tag(vault_tag, true);</a>
<a name="ln2166">                if (vault == nullptr)</a>
<a name="ln2167">                {</a>
<a name="ln2168">                    mprf(MSGCH_ERROR,</a>
<a name="ln2169">                         &quot;Couldn't find overflow temple tag '%s'!&quot;,</a>
<a name="ln2170">                         vault_tag.c_str());</a>
<a name="ln2171">                }</a>
<a name="ln2172">            }</a>
<a name="ln2173">        }</a>
<a name="ln2174"> </a>
<a name="ln2175">        if (vault == nullptr)</a>
<a name="ln2176">            // Might as well build the rest of the level if we couldn't</a>
<a name="ln2177">            // find the overflow temple map, so don't veto the level.</a>
<a name="ln2178">            return;</a>
<a name="ln2179"> </a>
<a name="ln2180">        {</a>
<a name="ln2181">            dgn_map_parameters mp(vault_tag);</a>
<a name="ln2182">            if (!_dgn_ensure_vault_placed(</a>
<a name="ln2183">                    _build_secondary_vault(vault),</a>
<a name="ln2184">                    false))</a>
<a name="ln2185">            {</a>
<a name="ln2186">#ifdef DEBUG_TEMPLES</a>
<a name="ln2187">                mprf(MSGCH_DIAGNOSTICS, &quot;Couldn't place overflow temple '%s', &quot;</a>
<a name="ln2188">                     &quot;vetoing level.&quot;, vault-&gt;name.c_str());</a>
<a name="ln2189">#endif</a>
<a name="ln2190">                return;</a>
<a name="ln2191">            }</a>
<a name="ln2192">        }</a>
<a name="ln2193">#ifdef DEBUG_TEMPLES</a>
<a name="ln2194">        mprf(MSGCH_DIAGNOSTICS, &quot;Placed overflow temple %s&quot;,</a>
<a name="ln2195">             vault-&gt;name.c_str());</a>
<a name="ln2196">#endif</a>
<a name="ln2197">    }</a>
<a name="ln2198">    _current_temple_hash = nullptr; // XXX: hack!</a>
<a name="ln2199">}</a>
<a name="ln2200"> </a>
<a name="ln2201">struct coord_feat</a>
<a name="ln2202">{</a>
<a name="ln2203">    coord_def pos;</a>
<a name="ln2204">    dungeon_feature_type feat;</a>
<a name="ln2205">    terrain_property_t prop;</a>
<a name="ln2206">    unsigned int mask;</a>
<a name="ln2207"> </a>
<a name="ln2208">    coord_feat(const coord_def &amp;c, dungeon_feature_type f)</a>
<a name="ln2209">        : pos(c), feat(f), prop(), mask(0)</a>
<a name="ln2210">    {</a>
<a name="ln2211">    }</a>
<a name="ln2212"> </a>
<a name="ln2213">    void set_from(const coord_def &amp;c)</a>
<a name="ln2214">    {</a>
<a name="ln2215">        feat = grd(c);</a>
<a name="ln2216">        // Don't copy mimic-ness.</a>
<a name="ln2217">        mask = env.level_map_mask(c) &amp; ~(MMT_MIMIC);</a>
<a name="ln2218">        // Only copy &quot;static&quot; properties.</a>
<a name="ln2219">        prop = env.pgrid(c) &amp; (FPROP_NO_CLOUD_GEN | FPROP_NO_TELE_INTO</a>
<a name="ln2220">                               | FPROP_NO_TIDE | FPROP_NO_SUBMERGE);</a>
<a name="ln2221">    }</a>
<a name="ln2222">};</a>
<a name="ln2223"> </a>
<a name="ln2224">template &lt;typename Iterator&gt;</a>
<a name="ln2225">static void _ruin_level(Iterator iter,</a>
<a name="ln2226">                        unsigned vault_mask = MMT_VAULT,</a>
<a name="ln2227">                        int ruination = 10,</a>
<a name="ln2228">                        int plant_density = 5,</a>
<a name="ln2229">                        int iterations = 1)</a>
<a name="ln2230">{</a>
<a name="ln2231">    vector&lt;coord_def&gt; replaced;</a>
<a name="ln2232"> </a>
<a name="ln2233">    for (int i = 0; i &lt; iterations; ++i)</a>
<a name="ln2234">    {</a>
<a name="ln2235">        typedef vector&lt;coord_feat&gt; coord_feats;</a>
<a name="ln2236">        coord_feats to_replace;</a>
<a name="ln2237">        for (Iterator ri = iter; ri; ++ri)</a>
<a name="ln2238">        {</a>
<a name="ln2239">            // don't alter map boundary</a>
<a name="ln2240">            if (!in_bounds(*ri))</a>
<a name="ln2241">                continue;</a>
<a name="ln2242"> </a>
<a name="ln2243">            // only try to replace wall and door tiles</a>
<a name="ln2244">            if (!feat_is_wall(grd(*ri)) &amp;&amp; !feat_is_door(grd(*ri)))</a>
<a name="ln2245">                continue;</a>
<a name="ln2246"> </a>
<a name="ln2247">            // don't mess with permarock</a>
<a name="ln2248">            if (grd(*ri) == DNGN_PERMAROCK_WALL)</a>
<a name="ln2249">                continue;</a>
<a name="ln2250"> </a>
<a name="ln2251">            // or vaults</a>
<a name="ln2252">            if (map_masked(*ri, vault_mask))</a>
<a name="ln2253">                continue;</a>
<a name="ln2254"> </a>
<a name="ln2255">            // Pick a random adjacent non-wall, non-door, non-statue</a>
<a name="ln2256">            // feature, and count the number of such features.</a>
<a name="ln2257">            coord_feat replacement(*ri, DNGN_UNSEEN);</a>
<a name="ln2258">            int floor_count = 0;</a>
<a name="ln2259">            for (adjacent_iterator ai(*ri); ai; ++ai)</a>
<a name="ln2260">            {</a>
<a name="ln2261">                if (!feat_is_wall(grd(*ai)) &amp;&amp; !feat_is_door(grd(*ai))</a>
<a name="ln2262">                    &amp;&amp; !feat_is_statuelike(grd(*ai))</a>
<a name="ln2263">                    // Shouldn't happen, but just in case.</a>
<a name="ln2264">                    &amp;&amp; grd(*ai) != DNGN_MALIGN_GATEWAY)</a>
<a name="ln2265">                {</a>
<a name="ln2266">                    if (one_chance_in(++floor_count))</a>
<a name="ln2267">                        replacement.set_from(*ai);</a>
<a name="ln2268">                }</a>
<a name="ln2269">            }</a>
<a name="ln2270"> </a>
<a name="ln2271">            // chance of removing the tile is dependent on the number of adjacent</a>
<a name="ln2272">            // floor(ish) tiles</a>
<a name="ln2273">            if (x_chance_in_y(floor_count, ruination))</a>
<a name="ln2274">                to_replace.push_back(replacement);</a>
<a name="ln2275">        }</a>
<a name="ln2276"> </a>
<a name="ln2277">        for (const auto &amp;cfeat : to_replace)</a>
<a name="ln2278">        {</a>
<a name="ln2279">            const coord_def &amp;p(cfeat.pos);</a>
<a name="ln2280">            replaced.push_back(p);</a>
<a name="ln2281">            dungeon_feature_type replacement = cfeat.feat;</a>
<a name="ln2282">            ASSERT(replacement != DNGN_UNSEEN);</a>
<a name="ln2283"> </a>
<a name="ln2284">            // Don't replace doors with impassable features.</a>
<a name="ln2285">            if (feat_is_door(grd(p)))</a>
<a name="ln2286">            {</a>
<a name="ln2287">                if (feat_is_water(replacement))</a>
<a name="ln2288">                    replacement = DNGN_SHALLOW_WATER;</a>
<a name="ln2289">                else</a>
<a name="ln2290">                    replacement = DNGN_FLOOR;</a>
<a name="ln2291">            }</a>
<a name="ln2292">            else if (feat_has_solid_floor(replacement)</a>
<a name="ln2293">                    &amp;&amp; replacement != DNGN_SHALLOW_WATER)</a>
<a name="ln2294">            {</a>
<a name="ln2295">                // Exclude traps, shops, stairs, portals, altars, fountains.</a>
<a name="ln2296">                // The first four, especially, are a big deal.</a>
<a name="ln2297">                replacement = DNGN_FLOOR;</a>
<a name="ln2298">            }</a>
<a name="ln2299"> </a>
<a name="ln2300">            // only remove some doors, to preserve tactical options</a>
<a name="ln2301">            if (feat_is_wall(grd(p)) || coinflip() &amp;&amp; feat_is_door(grd(p)))</a>
<a name="ln2302">            {</a>
<a name="ln2303">                // Copy the mask and properties too, so that we don't make an</a>
<a name="ln2304">                // isolated transparent or rtele_into square.</a>
<a name="ln2305">                env.level_map_mask(p) |= cfeat.mask;</a>
<a name="ln2306">                env.pgrid(p) |= cfeat.prop;</a>
<a name="ln2307">                _set_grd(p, replacement);</a>
<a name="ln2308">            }</a>
<a name="ln2309"> </a>
<a name="ln2310">            // but remove doors if we've removed all adjacent walls</a>
<a name="ln2311">            for (adjacent_iterator wai(p); wai; ++wai)</a>
<a name="ln2312">            {</a>
<a name="ln2313">                if (feat_is_door(grd(*wai)))</a>
<a name="ln2314">                {</a>
<a name="ln2315">                    bool remove = true;</a>
<a name="ln2316">                    for (adjacent_iterator dai(*wai); dai; ++dai)</a>
<a name="ln2317">                    {</a>
<a name="ln2318">                        if (feat_is_wall(grd(*dai)))</a>
<a name="ln2319">                            remove = false;</a>
<a name="ln2320">                    }</a>
<a name="ln2321">                    // It's always safe to replace a door with floor.</a>
<a name="ln2322">                    if (remove)</a>
<a name="ln2323">                    {</a>
<a name="ln2324">                        env.level_map_mask(p) |= cfeat.mask;</a>
<a name="ln2325">                        env.pgrid(p) |= cfeat.prop;</a>
<a name="ln2326">                        _set_grd(*wai, DNGN_FLOOR);</a>
<a name="ln2327">                    }</a>
<a name="ln2328">                }</a>
<a name="ln2329">            }</a>
<a name="ln2330">        }</a>
<a name="ln2331">    }</a>
<a name="ln2332"> </a>
<a name="ln2333">    for (const auto &amp;p : replaced)</a>
<a name="ln2334">    {</a>
<a name="ln2335">        // replace some ruined walls with plants/fungi/bushes</a>
<a name="ln2336">        if (plant_density &amp;&amp; one_chance_in(plant_density)</a>
<a name="ln2337">            &amp;&amp; feat_has_solid_floor(grd(p))</a>
<a name="ln2338">            &amp;&amp; !plant_forbidden_at(p))</a>
<a name="ln2339">        {</a>
<a name="ln2340">            mgen_data mg;</a>
<a name="ln2341">            mg.cls = random_choose_weighted( 2, MONS_BUSH,</a>
<a name="ln2342">                                            19, MONS_PLANT,</a>
<a name="ln2343">                                            19, MONS_FUNGUS);</a>
<a name="ln2344">            mg.pos = p;</a>
<a name="ln2345">            mg.flags = MG_FORCE_PLACE;</a>
<a name="ln2346">            mons_place(mgen_data(mg));</a>
<a name="ln2347">        }</a>
<a name="ln2348">    }</a>
<a name="ln2349">}</a>
<a name="ln2350"> </a>
<a name="ln2351">static bool _mimic_at_level()</a>
<a name="ln2352">{</a>
<a name="ln2353">    return !player_in_branch(BRANCH_TEMPLE)</a>
<a name="ln2354">           &amp;&amp; !player_in_branch(BRANCH_VESTIBULE)</a>
<a name="ln2355">           &amp;&amp; !player_in_branch(BRANCH_SLIME)</a>
<a name="ln2356">           &amp;&amp; !player_in_branch(BRANCH_TOMB)</a>
<a name="ln2357">           &amp;&amp; !player_in_branch(BRANCH_PANDEMONIUM)</a>
<a name="ln2358">           &amp;&amp; !player_in_hell()</a>
<a name="ln2359">           &amp;&amp; !crawl_state.game_is_tutorial();</a>
<a name="ln2360">}</a>
<a name="ln2361"> </a>
<a name="ln2362">static void _place_feature_mimics()</a>
<a name="ln2363">{</a>
<a name="ln2364">    for (rectangle_iterator ri(1); ri; ++ri)</a>
<a name="ln2365">    {</a>
<a name="ln2366">        const coord_def pos = *ri;</a>
<a name="ln2367">        const dungeon_feature_type feat = grd(pos);</a>
<a name="ln2368"> </a>
<a name="ln2369">        // Vault tag prevents mimic.</a>
<a name="ln2370">        if (map_masked(pos, MMT_NO_MIMIC))</a>
<a name="ln2371">            continue;</a>
<a name="ln2372"> </a>
<a name="ln2373">        // Only features valid for mimicing.</a>
<a name="ln2374">        if (!feat_is_mimicable(feat))</a>
<a name="ln2375">            continue;</a>
<a name="ln2376"> </a>
<a name="ln2377">        if (one_chance_in(FEATURE_MIMIC_CHANCE))</a>
<a name="ln2378">        {</a>
<a name="ln2379">            dprf(DIAG_DNGN, &quot;Placed %s mimic at (%d,%d).&quot;,</a>
<a name="ln2380">                 feat_type_name(feat), ri-&gt;x, ri-&gt;y);</a>
<a name="ln2381">            env.level_map_mask(*ri) |= MMT_MIMIC;</a>
<a name="ln2382"> </a>
<a name="ln2383">            // If we're mimicing a unique portal vault, give a chance for</a>
<a name="ln2384">            // another one to spawn.</a>
<a name="ln2385">            const char* dst = branches[stair_destination(pos).branch].abbrevname;</a>
<a name="ln2386">            const string tag = &quot;uniq_&quot; + lowercase_string(dst);</a>
<a name="ln2387">            if (get_uniq_map_tags().count(tag))</a>
<a name="ln2388">                get_uniq_map_tags().erase(tag);</a>
<a name="ln2389">        }</a>
<a name="ln2390">    }</a>
<a name="ln2391">}</a>
<a name="ln2392"> </a>
<a name="ln2393">// Apply modifications (ruination, plant clumps) that should happen</a>
<a name="ln2394">// regardless of game mode.</a>
<a name="ln2395">static void _post_vault_build()</a>
<a name="ln2396">{</a>
<a name="ln2397">    if (player_in_branch(BRANCH_LAIR))</a>
<a name="ln2398">    {</a>
<a name="ln2399">        int depth = you.depth + 1;</a>
<a name="ln2400">        _ruin_level(rectangle_iterator(1), MMT_VAULT,</a>
<a name="ln2401">                    20 - depth, depth / 2 + 4, 1 + (depth / 3));</a>
<a name="ln2402">        do</a>
<a name="ln2403">        {</a>
<a name="ln2404">            _add_plant_clumps(12 - depth, 18 - depth / 4, depth / 4 + 2);</a>
<a name="ln2405">            depth -= 3;</a>
<a name="ln2406">        } while (depth &gt; 0);</a>
<a name="ln2407">    }</a>
<a name="ln2408">}</a>
<a name="ln2409"> </a>
<a name="ln2410">static void _build_dungeon_level()</a>
<a name="ln2411">{</a>
<a name="ln2412">    bool place_vaults = _builder_by_type();</a>
<a name="ln2413"> </a>
<a name="ln2414">    if (player_in_branch(BRANCH_SLIME))</a>
<a name="ln2415">        _slime_connectivity_fixup();</a>
<a name="ln2416"> </a>
<a name="ln2417">    // Now place items, mons, gates, etc.</a>
<a name="ln2418">    // Stairs must exist by this point (except in Shoals where they are</a>
<a name="ln2419">    // yet to be placed). Some items and monsters already exist.</a>
<a name="ln2420"> </a>
<a name="ln2421">    _check_doors();</a>
<a name="ln2422"> </a>
<a name="ln2423">    const unsigned nvaults = env.level_vaults.size();</a>
<a name="ln2424"> </a>
<a name="ln2425">    // Any further vaults must make sure not to disrupt level layout.</a>
<a name="ln2426">    dgn_check_connectivity = true;</a>
<a name="ln2427"> </a>
<a name="ln2428">    if (player_in_branch(BRANCH_DUNGEON)</a>
<a name="ln2429">        &amp;&amp; !crawl_state.game_is_tutorial())</a>
<a name="ln2430">    {</a>
<a name="ln2431">        _build_overflow_temples();</a>
<a name="ln2432">    }</a>
<a name="ln2433"> </a>
<a name="ln2434">    // Try to place minivaults that really badly want to be placed. Still</a>
<a name="ln2435">    // no guarantees, seeing this is a minivault.</a>
<a name="ln2436">    if (crawl_state.game_standard_levelgen())</a>
<a name="ln2437">    {</a>
<a name="ln2438">        if (place_vaults)</a>
<a name="ln2439">        {</a>
<a name="ln2440">            // Moved branch entries to place first so there's a good</a>
<a name="ln2441">            // chance of having room for a vault</a>
<a name="ln2442">            _place_branch_entrances(true);</a>
<a name="ln2443">            _place_chance_vaults();</a>
<a name="ln2444">            _place_minivaults();</a>
<a name="ln2445">            _place_extra_vaults();</a>
<a name="ln2446">        }</a>
<a name="ln2447">        else</a>
<a name="ln2448">        {</a>
<a name="ln2449">            // Place any branch entries vaultlessly</a>
<a name="ln2450">            _place_branch_entrances(false);</a>
<a name="ln2451">            // Still place chance vaults - important things like Abyss,</a>
<a name="ln2452">            // Hell, Pan entries are placed this way</a>
<a name="ln2453">            _place_chance_vaults();</a>
<a name="ln2454">        }</a>
<a name="ln2455"> </a>
<a name="ln2456">        // Ruination and plant clumps.</a>
<a name="ln2457">        _post_vault_build();</a>
<a name="ln2458"> </a>
<a name="ln2459">        // XXX: Moved this here from builder_monsters so that</a>
<a name="ln2460">        //      connectivity can be ensured</a>
<a name="ln2461">        _place_uniques();</a>
<a name="ln2462"> </a>
<a name="ln2463">        if (_mimic_at_level())</a>
<a name="ln2464">            _place_feature_mimics();</a>
<a name="ln2465"> </a>
<a name="ln2466">        _place_traps();</a>
<a name="ln2467"> </a>
<a name="ln2468">        // Any vault-placement activity must happen before this check.</a>
<a name="ln2469">        _dgn_verify_connectivity(nvaults);</a>
<a name="ln2470"> </a>
<a name="ln2471">        _builder_monsters();</a>
<a name="ln2472"> </a>
<a name="ln2473">        // Place items.</a>
<a name="ln2474">        _builder_items();</a>
<a name="ln2475"> </a>
<a name="ln2476">        _fixup_walls();</a>
<a name="ln2477">    }</a>
<a name="ln2478">    else</a>
<a name="ln2479">    {</a>
<a name="ln2480">        // Do ruination and plant clumps even in funny game modes, if</a>
<a name="ln2481">        // they happen to have the relevant branch.</a>
<a name="ln2482">        _post_vault_build();</a>
<a name="ln2483">    }</a>
<a name="ln2484"> </a>
<a name="ln2485">    // Translate stairs for pandemonium levels.</a>
<a name="ln2486">    if (player_in_branch(BRANCH_PANDEMONIUM))</a>
<a name="ln2487">        _fixup_pandemonium_stairs();</a>
<a name="ln2488"> </a>
<a name="ln2489">    _fixup_branch_stairs();</a>
<a name="ln2490"> </a>
<a name="ln2491">    if (!dgn_make_transporters_from_markers())</a>
<a name="ln2492">        throw dgn_veto_exception(&quot;Transporter placement failed.&quot;);</a>
<a name="ln2493"> </a>
<a name="ln2494">    fixup_misplaced_items();</a>
<a name="ln2495">    link_items();</a>
<a name="ln2496"> </a>
<a name="ln2497">    if (!player_in_branch(BRANCH_COCYTUS)</a>
<a name="ln2498">        &amp;&amp; !player_in_branch(BRANCH_SWAMP)</a>
<a name="ln2499">        &amp;&amp; !player_in_branch(BRANCH_SHOALS))</a>
<a name="ln2500">    {</a>
<a name="ln2501">        _prepare_water();</a>
<a name="ln2502">    }</a>
<a name="ln2503"> </a>
<a name="ln2504">    if (player_in_hell())</a>
<a name="ln2505">        _fixup_hell_stairs();</a>
<a name="ln2506">}</a>
<a name="ln2507"> </a>
<a name="ln2508">static void _dgn_set_floor_colours()</a>
<a name="ln2509">{</a>
<a name="ln2510">    colour_t old_floor_colour = env.floor_colour;</a>
<a name="ln2511">    colour_t old_rock_colour  = env.rock_colour;</a>
<a name="ln2512"> </a>
<a name="ln2513">    const int youbranch = you.where_are_you;</a>
<a name="ln2514">    env.floor_colour    = branches[youbranch].floor_colour;</a>
<a name="ln2515">    env.rock_colour     = branches[youbranch].rock_colour;</a>
<a name="ln2516"> </a>
<a name="ln2517">    if (old_floor_colour != BLACK)</a>
<a name="ln2518">        env.floor_colour = old_floor_colour;</a>
<a name="ln2519">    if (old_rock_colour != BLACK)</a>
<a name="ln2520">        env.rock_colour = old_rock_colour;</a>
<a name="ln2521"> </a>
<a name="ln2522">    if (env.floor_colour == BLACK)</a>
<a name="ln2523">        env.floor_colour = LIGHTGREY;</a>
<a name="ln2524">    if (env.rock_colour == BLACK)</a>
<a name="ln2525">        env.rock_colour  = BROWN;</a>
<a name="ln2526">}</a>
<a name="ln2527"> </a>
<a name="ln2528">static void _check_doors()</a>
<a name="ln2529">{</a>
<a name="ln2530">    for (rectangle_iterator ri(1); ri; ++ri)</a>
<a name="ln2531">    {</a>
<a name="ln2532">        if (!feat_is_closed_door(grd(*ri)))</a>
<a name="ln2533">            continue;</a>
<a name="ln2534"> </a>
<a name="ln2535">        int solid_count = 0;</a>
<a name="ln2536"> </a>
<a name="ln2537">        for (orth_adjacent_iterator rai(*ri); rai; ++rai)</a>
<a name="ln2538">            if (cell_is_solid(*rai))</a>
<a name="ln2539">                solid_count++;</a>
<a name="ln2540"> </a>
<a name="ln2541">        if (solid_count &lt; 2)</a>
<a name="ln2542">            _set_grd(*ri, DNGN_FLOOR);</a>
<a name="ln2543">    }</a>
<a name="ln2544">}</a>
<a name="ln2545"> </a>
<a name="ln2546">int count_feature_in_box(int x0, int y0, int x1, int y1,</a>
<a name="ln2547">                         dungeon_feature_type feat)</a>
<a name="ln2548">{</a>
<a name="ln2549">    int result = 0;</a>
<a name="ln2550">    for (int i = x0; i &lt; x1; ++i)</a>
<a name="ln2551">        for (int j = y0; j &lt; y1; ++j)</a>
<a name="ln2552">        {</a>
<a name="ln2553">            if (grd[i][j] == feat)</a>
<a name="ln2554">                ++result;</a>
<a name="ln2555">        }</a>
<a name="ln2556"> </a>
<a name="ln2557">    return result;</a>
<a name="ln2558">}</a>
<a name="ln2559"> </a>
<a name="ln2560">// Count how many neighbours of grd[x][y] are the feature feat.</a>
<a name="ln2561">int count_neighbours(int x, int y, dungeon_feature_type feat)</a>
<a name="ln2562">{</a>
<a name="ln2563">    return count_feature_in_box(x-1, y-1, x+2, y+2, feat);</a>
<a name="ln2564">}</a>
<a name="ln2565"> </a>
<a name="ln2566">// Gives water which is next to ground/shallow water a chance of being</a>
<a name="ln2567">// shallow. Checks each water space.</a>
<a name="ln2568">static void _prepare_water()</a>
<a name="ln2569">{</a>
<a name="ln2570">    for (rectangle_iterator ri(1); ri; ++ri)</a>
<a name="ln2571">    {</a>
<a name="ln2572">        if (map_masked(*ri, MMT_NO_POOL) || grd(*ri) != DNGN_DEEP_WATER)</a>
<a name="ln2573">            continue;</a>
<a name="ln2574"> </a>
<a name="ln2575">        for (adjacent_iterator ai(*ri); ai; ++ai)</a>
<a name="ln2576">        {</a>
<a name="ln2577">            const dungeon_feature_type which_grid = grd(*ai);</a>
<a name="ln2578"> </a>
<a name="ln2579">            if (which_grid == DNGN_SHALLOW_WATER &amp;&amp; one_chance_in(20)</a>
<a name="ln2580">                || feat_has_dry_floor(which_grid) &amp;&amp; x_chance_in_y(2, 5))</a>
<a name="ln2581">            {</a>
<a name="ln2582">                _set_grd(*ri, DNGN_SHALLOW_WATER);</a>
<a name="ln2583">                break;</a>
<a name="ln2584">            }</a>
<a name="ln2585">        }</a>
<a name="ln2586">    }</a>
<a name="ln2587">}</a>
<a name="ln2588"> </a>
<a name="ln2589">static bool _vault_can_use_layout(const map_def *vault, const map_def *layout)</a>
<a name="ln2590">{</a>
<a name="ln2591">    bool permissive = false;</a>
<a name="ln2592">    if (!vault-&gt;has_tag_prefix(&quot;layout_&quot;)</a>
<a name="ln2593">        &amp;&amp; !(permissive = vault-&gt;has_tag_prefix(&quot;nolayout_&quot;)))</a>
<a name="ln2594">    {</a>
<a name="ln2595">        return true;</a>
<a name="ln2596">    }</a>
<a name="ln2597"> </a>
<a name="ln2598">    ASSERT(layout-&gt;has_tag_prefix(&quot;layout_type_&quot;));</a>
<a name="ln2599"> </a>
<a name="ln2600">    // in principle, tag order can matter here, even though that is probably</a>
<a name="ln2601">    // a vault designer error</a>
<a name="ln2602">    for (const auto &amp;tag : layout-&gt;get_tags())</a>
<a name="ln2603">    {</a>
<a name="ln2604">        if (starts_with(tag, &quot;layout_type_&quot;))</a>
<a name="ln2605">        {</a>
<a name="ln2606">            string type = tag_without_prefix(tag, &quot;layout_type_&quot;);</a>
<a name="ln2607">            if (vault-&gt;has_tag(&quot;layout_&quot; + type))</a>
<a name="ln2608">                return true;</a>
<a name="ln2609">            else if (vault-&gt;has_tag(&quot;nolayout_&quot; + type))</a>
<a name="ln2610">                return false;</a>
<a name="ln2611">        }</a>
<a name="ln2612">    }</a>
<a name="ln2613"> </a>
<a name="ln2614">    return permissive;</a>
<a name="ln2615">}</a>
<a name="ln2616"> </a>
<a name="ln2617">static const map_def *_pick_layout(const map_def *vault)</a>
<a name="ln2618">{</a>
<a name="ln2619">    const map_def *layout = nullptr;</a>
<a name="ln2620"> </a>
<a name="ln2621">    // This is intended for use with primary vaults, so...</a>
<a name="ln2622">    ASSERT(vault);</a>
<a name="ln2623"> </a>
<a name="ln2624">    // For centred maps, try to pick a central-type layout first.</a>
<a name="ln2625">    if (vault-&gt;orient == MAP_CENTRE)</a>
<a name="ln2626">        layout = random_map_for_tag(&quot;central&quot;, true, true);</a>
<a name="ln2627"> </a>
<a name="ln2628">    int tries = 100;</a>
<a name="ln2629"> </a>
<a name="ln2630">    if (!layout)</a>
<a name="ln2631">    {</a>
<a name="ln2632">        do</a>
<a name="ln2633">        {</a>
<a name="ln2634">            if (!tries--)</a>
<a name="ln2635">            {</a>
<a name="ln2636">                die(&quot;Couldn't find a layout for %s&quot;,</a>
<a name="ln2637">                    level_id::current().describe().c_str());</a>
<a name="ln2638">            }</a>
<a name="ln2639">            layout = random_map_for_tag(&quot;layout&quot;, true, true);</a>
<a name="ln2640">        }</a>
<a name="ln2641">        while (layout-&gt;has_tag(&quot;no_primary_vault&quot;)</a>
<a name="ln2642">               || (tries &gt; 10 &amp;&amp; !_vault_can_use_layout(vault, layout)));</a>
<a name="ln2643">    }</a>
<a name="ln2644"> </a>
<a name="ln2645">    return layout;</a>
<a name="ln2646">}</a>
<a name="ln2647"> </a>
<a name="ln2648">static bool _pan_level()</a>
<a name="ln2649">{</a>
<a name="ln2650">    const char *pandemon_level_names[] =</a>
<a name="ln2651">        { &quot;mnoleg&quot;, &quot;lom_lobon&quot;, &quot;cerebov&quot;, &quot;gloorx_vloq&quot;, };</a>
<a name="ln2652">    int which_demon = -1;</a>
<a name="ln2653">    const PlaceInfo &amp;place_info = you.get_place_info();</a>
<a name="ln2654">    bool all_demons_generated = true;</a>
<a name="ln2655"> </a>
<a name="ln2656">    if (you.props.exists(&quot;force_map&quot;))</a>
<a name="ln2657">    {</a>
<a name="ln2658">        const map_def *vault =</a>
<a name="ln2659">            find_map_by_name(you.props[&quot;force_map&quot;].get_string());</a>
<a name="ln2660">        ASSERT(vault);</a>
<a name="ln2661"> </a>
<a name="ln2662">        _dgn_ensure_vault_placed(_build_primary_vault(vault), false);</a>
<a name="ln2663">        return vault-&gt;orient != MAP_ENCOMPASS;</a>
<a name="ln2664">    }</a>
<a name="ln2665"> </a>
<a name="ln2666">    for (int i = 0; i &lt; 4; i++)</a>
<a name="ln2667">    {</a>
<a name="ln2668">        if (!get_uniq_map_tags().count(string(&quot;uniq_&quot;) + pandemon_level_names[i]))</a>
<a name="ln2669">        {</a>
<a name="ln2670">            all_demons_generated = false;</a>
<a name="ln2671">            break;</a>
<a name="ln2672">        }</a>
<a name="ln2673">    }</a>
<a name="ln2674"> </a>
<a name="ln2675">    // Unique pan lords become more common as you travel through pandemonium.</a>
<a name="ln2676">    // On average it takes about 14 levels to see all four, and on average</a>
<a name="ln2677">    // about 5 levels to see your first.</a>
<a name="ln2678">    if (x_chance_in_y(1 + place_info.levels_seen, 20 + place_info.levels_seen)</a>
<a name="ln2679">        &amp;&amp; !all_demons_generated)</a>
<a name="ln2680">    {</a>
<a name="ln2681">        do</a>
<a name="ln2682">        {</a>
<a name="ln2683">            which_demon = random2(4);</a>
<a name="ln2684">        }</a>
<a name="ln2685">        while (get_uniq_map_tags().count(string(&quot;uniq_&quot;)</a>
<a name="ln2686">                                       + pandemon_level_names[which_demon]));</a>
<a name="ln2687">    }</a>
<a name="ln2688"> </a>
<a name="ln2689">    const map_def *vault = nullptr;</a>
<a name="ln2690"> </a>
<a name="ln2691">    if (which_demon &gt;= 0)</a>
<a name="ln2692">    {</a>
<a name="ln2693">        vault = random_map_for_tag(pandemon_level_names[which_demon], false,</a>
<a name="ln2694">                                   false, MB_FALSE);</a>
<a name="ln2695">    }</a>
<a name="ln2696">    else</a>
<a name="ln2697">        vault = random_map_in_depth(level_id::current(), false, MB_FALSE);</a>
<a name="ln2698"> </a>
<a name="ln2699">    // Every Pan level should have a primary vault.</a>
<a name="ln2700">    ASSERT(vault);</a>
<a name="ln2701">    _dgn_ensure_vault_placed(_build_primary_vault(vault), false);</a>
<a name="ln2702">    return vault-&gt;orient != MAP_ENCOMPASS;</a>
<a name="ln2703">}</a>
<a name="ln2704"> </a>
<a name="ln2705">// Returns true if we want the dungeon builder</a>
<a name="ln2706">// to place more vaults after this</a>
<a name="ln2707">static bool _builder_by_type()</a>
<a name="ln2708">{</a>
<a name="ln2709">    if (player_in_branch(BRANCH_ABYSS))</a>
<a name="ln2710">    {</a>
<a name="ln2711">        generate_abyss();</a>
<a name="ln2712">        // Should place some vaults in abyss because</a>
<a name="ln2713">        // there's never an encompass vault</a>
<a name="ln2714">        return true;</a>
<a name="ln2715">    }</a>
<a name="ln2716">    else if (player_in_branch(BRANCH_PANDEMONIUM))</a>
<a name="ln2717">    {</a>
<a name="ln2718">        // Generate a random monster table for Pan.</a>
<a name="ln2719">        init_pandemonium();</a>
<a name="ln2720">        setup_vault_mon_list();</a>
<a name="ln2721">        return _pan_level();</a>
<a name="ln2722">    }</a>
<a name="ln2723">    else</a>
<a name="ln2724">        return _builder_normal();</a>
<a name="ln2725">}</a>
<a name="ln2726"> </a>
<a name="ln2727">static const map_def *_dgn_random_map_for_place(bool minivault)</a>
<a name="ln2728">{</a>
<a name="ln2729">    if (!minivault &amp;&amp; player_in_branch(BRANCH_TEMPLE))</a>
<a name="ln2730">    {</a>
<a name="ln2731">        // Temple vault determined at new game time.</a>
<a name="ln2732">        const string name = you.props[TEMPLE_MAP_KEY];</a>
<a name="ln2733"> </a>
<a name="ln2734">        // Tolerate this for a little while, for old games.</a>
<a name="ln2735">        if (!name.empty())</a>
<a name="ln2736">        {</a>
<a name="ln2737">            const map_def *vault = find_map_by_name(name);</a>
<a name="ln2738"> </a>
<a name="ln2739">            if (vault)</a>
<a name="ln2740">                return vault;</a>
<a name="ln2741"> </a>
<a name="ln2742">            mprf(MSGCH_ERROR, &quot;Unable to find Temple vault '%s'&quot;,</a>
<a name="ln2743">                 name.c_str());</a>
<a name="ln2744"> </a>
<a name="ln2745">            // Fall through and use a different Temple map instead.</a>
<a name="ln2746">        }</a>
<a name="ln2747">    }</a>
<a name="ln2748"> </a>
<a name="ln2749">    const level_id lid = level_id::current();</a>
<a name="ln2750"> </a>
<a name="ln2751">#if TAG_MAJOR_VERSION == 34</a>
<a name="ln2752">    if (!minivault</a>
<a name="ln2753">        &amp;&amp; player_in_branch(BRANCH_TOMB)</a>
<a name="ln2754">        &amp;&amp; you.props[TOMB_STONE_STAIRS_KEY])</a>
<a name="ln2755">    {</a>
<a name="ln2756">        const map_def *vault = random_map_for_tag(&quot;tomb_stone_stairs&quot;, true);</a>
<a name="ln2757"> </a>
<a name="ln2758">        if (vault)</a>
<a name="ln2759">            return vault;</a>
<a name="ln2760"> </a>
<a name="ln2761">        end(1, false, &quot;Couldn't find map with tag tomb_stone_stairs for level &quot;</a>
<a name="ln2762">            &quot;%s.&quot;, lid.describe().c_str());</a>
<a name="ln2763">    }</a>
<a name="ln2764">#endif</a>
<a name="ln2765"> </a>
<a name="ln2766">    const map_def *vault = 0;</a>
<a name="ln2767"> </a>
<a name="ln2768">    if (you.props.exists(&quot;force_map&quot;))</a>
<a name="ln2769">        vault = find_map_by_name(you.props[&quot;force_map&quot;].get_string());</a>
<a name="ln2770">    else if (lid.branch == root_branch &amp;&amp; lid.depth == 1</a>
<a name="ln2771">        &amp;&amp; (crawl_state.game_is_sprint()</a>
<a name="ln2772">            || crawl_state.game_is_tutorial()))</a>
<a name="ln2773">    {</a>
<a name="ln2774">        vault = find_map_by_name(crawl_state.map);</a>
<a name="ln2775">        if (vault == nullptr)</a>
<a name="ln2776">        {</a>
<a name="ln2777">            end(1, false, &quot;Couldn't find selected map '%s'.&quot;,</a>
<a name="ln2778">                crawl_state.map.c_str());</a>
<a name="ln2779">        }</a>
<a name="ln2780">    }</a>
<a name="ln2781"> </a>
<a name="ln2782">    if (!vault)</a>
<a name="ln2783">        // Pick a normal map</a>
<a name="ln2784">        vault = random_map_for_place(lid, minivault, MB_FALSE);</a>
<a name="ln2785"> </a>
<a name="ln2786">    if (!vault &amp;&amp; lid.branch == root_branch &amp;&amp; lid.depth == 1)</a>
<a name="ln2787">        vault = random_map_for_tag(&quot;arrival&quot;, false, false, MB_FALSE);</a>
<a name="ln2788"> </a>
<a name="ln2789">    return vault;</a>
<a name="ln2790">}</a>
<a name="ln2791"> </a>
<a name="ln2792">static int _setup_temple_altars(CrawlHashTable &amp;temple)</a>
<a name="ln2793">{</a>
<a name="ln2794">    _current_temple_hash = &amp;temple; // XXX: hack!</a>
<a name="ln2795"> </a>
<a name="ln2796">    CrawlVector god_list = temple[TEMPLE_GODS_KEY].get_vector();</a>
<a name="ln2797"> </a>
<a name="ln2798">    _temple_altar_list.clear();</a>
<a name="ln2799"> </a>
<a name="ln2800">    for (unsigned int i = 0; i &lt; god_list.size(); i++)</a>
<a name="ln2801">        _temple_altar_list.push_back((god_type) god_list[i].get_byte());</a>
<a name="ln2802"> </a>
<a name="ln2803">    return (int)god_list.size();</a>
<a name="ln2804">}</a>
<a name="ln2805"> </a>
<a name="ln2806">struct map_component</a>
<a name="ln2807">{</a>
<a name="ln2808">    int label;</a>
<a name="ln2809"> </a>
<a name="ln2810">    map_component()</a>
<a name="ln2811">    {</a>
<a name="ln2812">        min_equivalent = nullptr;</a>
<a name="ln2813">    }</a>
<a name="ln2814">    map_component * min_equivalent;</a>
<a name="ln2815"> </a>
<a name="ln2816">    coord_def min_coord;</a>
<a name="ln2817">    coord_def max_coord;</a>
<a name="ln2818"> </a>
<a name="ln2819">    coord_def seed_position;</a>
<a name="ln2820"> </a>
<a name="ln2821">    void start_component(const coord_def &amp; pos, int in_label)</a>
<a name="ln2822">    {</a>
<a name="ln2823">        seed_position = pos;</a>
<a name="ln2824">        min_coord = pos;</a>
<a name="ln2825">        max_coord = pos;</a>
<a name="ln2826"> </a>
<a name="ln2827">        label = in_label;</a>
<a name="ln2828">        min_equivalent = nullptr;</a>
<a name="ln2829">    }</a>
<a name="ln2830"> </a>
<a name="ln2831">    void add_coord(const coord_def &amp; pos)</a>
<a name="ln2832">    {</a>
<a name="ln2833">        if (pos.x &lt; min_coord.x)</a>
<a name="ln2834">            min_coord.x = pos.x;</a>
<a name="ln2835">        if (pos.x &gt; max_coord.x)</a>
<a name="ln2836">            max_coord.x = pos.x;</a>
<a name="ln2837">        if (pos.y &lt; min_coord.y)</a>
<a name="ln2838">            min_coord.y = pos.y;</a>
<a name="ln2839">        if (pos.y &gt; max_coord.y)</a>
<a name="ln2840">            max_coord.y = pos.y;</a>
<a name="ln2841">    }</a>
<a name="ln2842"> </a>
<a name="ln2843">    void merge_region(const map_component &amp; existing)</a>
<a name="ln2844">    {</a>
<a name="ln2845">        add_coord(existing.min_coord);</a>
<a name="ln2846">        add_coord(existing.max_coord);</a>
<a name="ln2847">    }</a>
<a name="ln2848">};</a>
<a name="ln2849"> </a>
<a name="ln2850">static int _min_transitive_label(map_component &amp; component)</a>
<a name="ln2851">{</a>
<a name="ln2852">    map_component * current = &amp;component;</a>
<a name="ln2853"> </a>
<a name="ln2854">    int label;</a>
<a name="ln2855">    do</a>
<a name="ln2856">    {</a>
<a name="ln2857">        label = current-&gt;label;</a>
<a name="ln2858"> </a>
<a name="ln2859">        current = current-&gt;min_equivalent;</a>
<a name="ln2860">    } while (current);</a>
<a name="ln2861"> </a>
<a name="ln2862">    return label;</a>
<a name="ln2863">}</a>
<a name="ln2864"> </a>
<a name="ln2865">// 8-way connected component analysis on the current level map.</a>
<a name="ln2866">template&lt;typename comp&gt;</a>
<a name="ln2867">static void _ccomps_8(FixedArray&lt;int, GXM, GYM &gt; &amp; connectivity_map,</a>
<a name="ln2868">                      vector&lt;map_component&gt; &amp; components, comp &amp; connected)</a>
<a name="ln2869">{</a>
<a name="ln2870">    map&lt;int, map_component&gt; intermediate_components;</a>
<a name="ln2871"> </a>
<a name="ln2872">    connectivity_map.init(0);</a>
<a name="ln2873">    components.clear();</a>
<a name="ln2874"> </a>
<a name="ln2875">    unsigned adjacent_size = 4;</a>
<a name="ln2876">    coord_def offsets[4] = {coord_def(-1, 0), coord_def(-1, -1), coord_def(0, -1), coord_def(1, -1)};</a>
<a name="ln2877"> </a>
<a name="ln2878">    int next_label = 1;</a>
<a name="ln2879"> </a>
<a name="ln2880">    // Pass 1, for each point, check the upper/left adjacent squares for labels</a>
<a name="ln2881">    // if a labels are found, use the min connected label, else assign a new</a>
<a name="ln2882">    // label and start a new component</a>
<a name="ln2883">    for (rectangle_iterator pos(1); pos; ++pos)</a>
<a name="ln2884">    {</a>
<a name="ln2885">        if (connected(*pos))</a>
<a name="ln2886">        {</a>
<a name="ln2887">            int absolute_min_label = INT_MAX;</a>
<a name="ln2888">            set&lt;int&gt; neighbor_labels;</a>
<a name="ln2889">            for (unsigned i = 0; i &lt; adjacent_size; i++)</a>
<a name="ln2890">            {</a>
<a name="ln2891">                coord_def test = *pos + offsets[i];</a>
<a name="ln2892">                if (in_bounds(test) &amp;&amp; connectivity_map(test) != 0)</a>
<a name="ln2893">                {</a>
<a name="ln2894">                    int neighbor_label = connectivity_map(test);</a>
<a name="ln2895">                    if (neighbor_labels.insert(neighbor_label).second)</a>
<a name="ln2896">                    {</a>
<a name="ln2897">                        int trans = _min_transitive_label(intermediate_components[neighbor_label]);</a>
<a name="ln2898"> </a>
<a name="ln2899">                        if (trans &lt; absolute_min_label)</a>
<a name="ln2900">                            absolute_min_label = trans;</a>
<a name="ln2901">                    }</a>
<a name="ln2902">                }</a>
<a name="ln2903">            }</a>
<a name="ln2904"> </a>
<a name="ln2905">            int label;</a>
<a name="ln2906">            if (neighbor_labels.empty())</a>
<a name="ln2907">            {</a>
<a name="ln2908">                intermediate_components[next_label].start_component(*pos, next_label);</a>
<a name="ln2909">                label = next_label;</a>
<a name="ln2910">                next_label++;</a>
<a name="ln2911">            }</a>
<a name="ln2912">            else</a>
<a name="ln2913">            {</a>
<a name="ln2914">                label = absolute_min_label;</a>
<a name="ln2915">                map_component * absolute_min = &amp;intermediate_components[absolute_min_label];</a>
<a name="ln2916"> </a>
<a name="ln2917">                absolute_min-&gt;add_coord(*pos);</a>
<a name="ln2918">                for (auto i : neighbor_labels)</a>
<a name="ln2919">                {</a>
<a name="ln2920">                    map_component * current = &amp;intermediate_components[i];</a>
<a name="ln2921"> </a>
<a name="ln2922">                    while (current &amp;&amp; current != absolute_min)</a>
<a name="ln2923">                    {</a>
<a name="ln2924">                        absolute_min-&gt;merge_region(*current);</a>
<a name="ln2925">                        map_component * next = current-&gt;min_equivalent;</a>
<a name="ln2926">                        current-&gt;min_equivalent = absolute_min;</a>
<a name="ln2927">                        current = next;</a>
<a name="ln2928">                    }</a>
<a name="ln2929">                }</a>
<a name="ln2930">            }</a>
<a name="ln2931">            connectivity_map(*pos) = label;</a>
<a name="ln2932">        }</a>
<a name="ln2933">    }</a>
<a name="ln2934"> </a>
<a name="ln2935">    int reindexed_label = 1;</a>
<a name="ln2936">    // Reindex root labels, and move them to output</a>
<a name="ln2937">    for (auto &amp;entry : intermediate_components)</a>
<a name="ln2938">    {</a>
<a name="ln2939">        if (entry.second.min_equivalent == nullptr)</a>
<a name="ln2940">        {</a>
<a name="ln2941">            entry.second.label = reindexed_label++;</a>
<a name="ln2942">            components.push_back(entry.second);</a>
<a name="ln2943">        }</a>
<a name="ln2944">    }</a>
<a name="ln2945"> </a>
<a name="ln2946">    // Pass 2, mark new labels on the grid</a>
<a name="ln2947">    for (rectangle_iterator pos(1); pos; ++pos)</a>
<a name="ln2948">    {</a>
<a name="ln2949">        int label = connectivity_map(*pos);</a>
<a name="ln2950">        if (label  != 0)</a>
<a name="ln2951">            connectivity_map(*pos) = _min_transitive_label(intermediate_components[label]);</a>
<a name="ln2952">    }</a>
<a name="ln2953">}</a>
<a name="ln2954"> </a>
<a name="ln2955">// Is this square a wall, or does it belong to a vault? both are considered to</a>
<a name="ln2956">// block connectivity.</a>
<a name="ln2957">static bool _passable_square(const coord_def &amp; pos)</a>
<a name="ln2958">{</a>
<a name="ln2959">    return !feat_is_wall(env.grid(pos)) &amp;&amp; !(env.level_map_mask(pos) &amp; MMT_VAULT);</a>
<a name="ln2960">}</a>
<a name="ln2961"> </a>
<a name="ln2962">struct adjacency_test</a>
<a name="ln2963">{</a>
<a name="ln2964">    adjacency_test()</a>
<a name="ln2965">    {</a>
<a name="ln2966">        adjacency.init(0);</a>
<a name="ln2967">    }</a>
<a name="ln2968">    FixedArray&lt;int, GXM, GYM&gt; adjacency;</a>
<a name="ln2969">    bool operator()(const coord_def &amp; pos)</a>
<a name="ln2970">    {</a>
<a name="ln2971">        return _passable_square(pos) &amp;&amp; adjacency(pos) == 0;</a>
<a name="ln2972">    }</a>
<a name="ln2973">};</a>
<a name="ln2974"> </a>
<a name="ln2975">struct dummy_estimate</a>
<a name="ln2976">{</a>
<a name="ln2977">    bool operator() (const coord_def &amp;)</a>
<a name="ln2978">    {</a>
<a name="ln2979">        return 0;</a>
<a name="ln2980">    }</a>
<a name="ln2981">};</a>
<a name="ln2982"> </a>
<a name="ln2983">struct adjacent_costs</a>
<a name="ln2984">{</a>
<a name="ln2985">    FixedArray&lt;int, GXM, GYM&gt; * adjacency;</a>
<a name="ln2986">    int operator()(const coord_def &amp; pos)</a>
<a name="ln2987">    {</a>
<a name="ln2988">        return (*adjacency)(pos);</a>
<a name="ln2989">    }</a>
<a name="ln2990">};</a>
<a name="ln2991"> </a>
<a name="ln2992">struct label_match</a>
<a name="ln2993">{</a>
<a name="ln2994">    FixedArray&lt;int, GXM, GYM&gt; * labels;</a>
<a name="ln2995">    int target_label;</a>
<a name="ln2996">    bool operator()(const coord_def &amp; pos)</a>
<a name="ln2997">    {</a>
<a name="ln2998">        return (*labels)(pos) == target_label;</a>
<a name="ln2999">    }</a>
<a name="ln3000">};</a>
<a name="ln3001"> </a>
<a name="ln3002">// Connectivity checks to make sure that the parts of a bubble are not</a>
<a name="ln3003">// obstructed by slime wall adjacent squares</a>
<a name="ln3004">static void _slime_connectivity_fixup()</a>
<a name="ln3005">{</a>
<a name="ln3006">    // Generate a connectivity map considering any non wall, non vault square</a>
<a name="ln3007">    // passable</a>
<a name="ln3008">    FixedArray&lt;int, GXM, GYM&gt; connectivity_map;</a>
<a name="ln3009">    vector&lt;map_component&gt; components;</a>
<a name="ln3010">    _ccomps_8(connectivity_map, components, _passable_square);</a>
<a name="ln3011"> </a>
<a name="ln3012">    // Next we will generate a connectivity map with the above restrictions,</a>
<a name="ln3013">    // and also considering wall adjacent squares unpassable. But first we</a>
<a name="ln3014">    // build a map of how many walls are adjacent to each square in the level.</a>
<a name="ln3015">    // Walls/vault squares are flagged with DISCONNECT_DIST in this map.</a>
<a name="ln3016">    // This will be used to build the connectivity map, then later the adjacent</a>
<a name="ln3017">    // counts will define the costs of a search used to connect components in</a>
<a name="ln3018">    // the basic connectivity map that are broken apart in the restricted map</a>
<a name="ln3019">    FixedArray&lt;int, GXM, GYM&gt; non_adjacent_connectivity;</a>
<a name="ln3020">    vector&lt;map_component&gt; non_adj_components;</a>
<a name="ln3021">    adjacency_test adjacent_check;</a>
<a name="ln3022"> </a>
<a name="ln3023">    for (rectangle_iterator ri(1); ri; ++ri)</a>
<a name="ln3024">    {</a>
<a name="ln3025">        int count = 0;</a>
<a name="ln3026">        if (!_passable_square(*ri))</a>
<a name="ln3027">            count = DISCONNECT_DIST;</a>
<a name="ln3028">        else</a>
<a name="ln3029">        {</a>
<a name="ln3030">            for (adjacent_iterator adj(*ri); adj; ++adj)</a>
<a name="ln3031">            {</a>
<a name="ln3032">                if (feat_is_wall(env.grid(*adj)))</a>
<a name="ln3033">                {</a>
<a name="ln3034">                    // Not allowed to damage vault squares, so mark them</a>
<a name="ln3035">                    // inaccessible</a>
<a name="ln3036">                    if (env.level_map_mask(*adj) &amp; MMT_VAULT)</a>
<a name="ln3037">                    {</a>
<a name="ln3038">                        count = DISCONNECT_DIST;</a>
<a name="ln3039">                        break;</a>
<a name="ln3040">                    }</a>
<a name="ln3041">                    else</a>
<a name="ln3042">                        count++;</a>
<a name="ln3043">                }</a>
<a name="ln3044"> </a>
<a name="ln3045">            }</a>
<a name="ln3046">        }</a>
<a name="ln3047">        adjacent_check.adjacency(*ri) = count;</a>
<a name="ln3048">    }</a>
<a name="ln3049"> </a>
<a name="ln3050">    _ccomps_8(non_adjacent_connectivity, non_adj_components, adjacent_check);</a>
<a name="ln3051"> </a>
<a name="ln3052">    // Now that we have both connectivity maps, go over each component in the</a>
<a name="ln3053">    // unrestricted map and connect any separate components in the restricted</a>
<a name="ln3054">    // map that it was broken up into.</a>
<a name="ln3055">    for (map_component &amp;comp : components)</a>
<a name="ln3056">    {</a>
<a name="ln3057">        // Collect the components in the restricted connectivity map that</a>
<a name="ln3058">        // occupy part of the current component</a>
<a name="ln3059">        map&lt;int, map_component *&gt; present;</a>
<a name="ln3060">        for (rectangle_iterator ri(comp.min_coord, comp.max_coord); ri; ++ri)</a>
<a name="ln3061">        {</a>
<a name="ln3062">            int new_label = non_adjacent_connectivity(*ri);</a>
<a name="ln3063">            if (comp.label == connectivity_map(*ri) &amp;&amp; new_label != 0)</a>
<a name="ln3064">            {</a>
<a name="ln3065">                // the bit with new_label - 1 is foolish.</a>
<a name="ln3066">                present[new_label] = &amp;non_adj_components[new_label-1];</a>
<a name="ln3067">            }</a>
<a name="ln3068">        }</a>
<a name="ln3069"> </a>
<a name="ln3070">        // Set one restricted component as the base point, and search to all</a>
<a name="ln3071">        // other restricted components</a>
<a name="ln3072">        auto target_components = present.begin();</a>
<a name="ln3073"> </a>
<a name="ln3074">        // No non-wall adjacent squares in this component? This probably</a>
<a name="ln3075">        // shouldn't happen, but just move on.</a>
<a name="ln3076">        if (target_components == present.end())</a>
<a name="ln3077">            continue;</a>
<a name="ln3078"> </a>
<a name="ln3079">        map_component * base_component = target_components-&gt;second;</a>
<a name="ln3080">        ++target_components;</a>
<a name="ln3081"> </a>
<a name="ln3082">        adjacent_costs connection_costs;</a>
<a name="ln3083">        connection_costs.adjacency = &amp;adjacent_check.adjacency;</a>
<a name="ln3084"> </a>
<a name="ln3085">        label_match valid_label;</a>
<a name="ln3086">        valid_label.labels = &amp;non_adjacent_connectivity;</a>
<a name="ln3087"> </a>
<a name="ln3088">        dummy_estimate dummy;</a>
<a name="ln3089"> </a>
<a name="ln3090">        // Now search from our base component to the other components, and</a>
<a name="ln3091">        // clear out the path found</a>
<a name="ln3092">        for ( ; target_components != present.end(); ++target_components)</a>
<a name="ln3093">        {</a>
<a name="ln3094">            valid_label.target_label = target_components-&gt;second-&gt;label;</a>
<a name="ln3095"> </a>
<a name="ln3096">            vector&lt;set&lt;position_node&gt;::iterator &gt;path;</a>
<a name="ln3097">            set&lt;position_node&gt; visited;</a>
<a name="ln3098">            search_astar(base_component-&gt;seed_position, valid_label,</a>
<a name="ln3099">                         connection_costs, dummy, visited, path);</a>
<a name="ln3100"> </a>
<a name="ln3101">            // Did the search, now remove any walls adjacent to squares in</a>
<a name="ln3102">            // the path.</a>
<a name="ln3103">            if (!path.size())</a>
<a name="ln3104">                continue;</a>
<a name="ln3105">            const position_node * current = &amp;(*path[0]);</a>
<a name="ln3106"> </a>
<a name="ln3107">            while (current)</a>
<a name="ln3108">            {</a>
<a name="ln3109">                if (adjacent_check.adjacency(current-&gt;pos) &gt; 0)</a>
<a name="ln3110">                {</a>
<a name="ln3111">                    for (adjacent_iterator adj_it(current-&gt;pos); adj_it; ++adj_it)</a>
<a name="ln3112">                    {</a>
<a name="ln3113">                        if (feat_is_wall(env.grid(*adj_it)))</a>
<a name="ln3114">                        {</a>
<a name="ln3115">                            // This shouldn't happen since vault adjacent</a>
<a name="ln3116">                            // squares should have adjacency of DISCONNECT_DIST</a>
<a name="ln3117">                            // but oh well</a>
<a name="ln3118">                            if (env.level_map_mask(*adj_it) &amp; MMT_VAULT)</a>
<a name="ln3119">                                mpr(&quot;Whoops, nicked a vault in slime connectivity fixup&quot;);</a>
<a name="ln3120">                            env.grid(*adj_it) = DNGN_FLOOR;</a>
<a name="ln3121">                        }</a>
<a name="ln3122">                    }</a>
<a name="ln3123">                    adjacent_check.adjacency(current-&gt;pos) = 0;</a>
<a name="ln3124">                }</a>
<a name="ln3125">                current = current-&gt;last;</a>
<a name="ln3126">            }</a>
<a name="ln3127"> </a>
<a name="ln3128">        }</a>
<a name="ln3129"> </a>
<a name="ln3130">    }</a>
<a name="ln3131">}</a>
<a name="ln3132"> </a>
<a name="ln3133">// Place vaults with CHANCE: that want to be placed on this level.</a>
<a name="ln3134">static void _place_chance_vaults()</a>
<a name="ln3135">{</a>
<a name="ln3136">    const level_id &amp;lid(level_id::current());</a>
<a name="ln3137">    mapref_vector maps = random_chance_maps_in_depth(lid);</a>
<a name="ln3138">    // [ds] If there are multiple CHANCE maps that share an luniq_ or</a>
<a name="ln3139">    // uniq_ tag, only the first such map will be placed. Shuffle the</a>
<a name="ln3140">    // order of chosen maps so we don't have a first-map bias.</a>
<a name="ln3141">    shuffle_array(maps);</a>
<a name="ln3142">    for (const map_def *map : maps)</a>
<a name="ln3143">    {</a>
<a name="ln3144">        bool check_fallback = true;</a>
<a name="ln3145">        if (!map-&gt;map_already_used())</a>
<a name="ln3146">        {</a>
<a name="ln3147">            dprf(DIAG_DNGN, &quot;Placing CHANCE vault: %s (%s)&quot;,</a>
<a name="ln3148">                 map-&gt;name.c_str(), map-&gt;chance(lid).describe().c_str());</a>
<a name="ln3149">            check_fallback = !_build_secondary_vault(map);</a>
<a name="ln3150">        }</a>
<a name="ln3151">        if (check_fallback)</a>
<a name="ln3152">        {</a>
<a name="ln3153">            const string chance_tag = vault_chance_tag(*map);</a>
<a name="ln3154">            if (!chance_tag.empty())</a>
<a name="ln3155">            {</a>
<a name="ln3156">                const string fallback_tag =</a>
<a name="ln3157">                    &quot;fallback_&quot; + chance_tag.substr(7); // &quot;chance_&quot;</a>
<a name="ln3158">                const map_def *fallback =</a>
<a name="ln3159">                    random_map_for_tag(fallback_tag, true, false, MB_FALSE);</a>
<a name="ln3160">                if (fallback)</a>
<a name="ln3161">                {</a>
<a name="ln3162">                    dprf(DIAG_DNGN, &quot;Found fallback vault %s for chance tag %s&quot;,</a>
<a name="ln3163">                         fallback-&gt;name.c_str(), chance_tag.c_str());</a>
<a name="ln3164">                    _build_secondary_vault(fallback);</a>
<a name="ln3165">                }</a>
<a name="ln3166">            }</a>
<a name="ln3167">        }</a>
<a name="ln3168">    }</a>
<a name="ln3169">}</a>
<a name="ln3170"> </a>
<a name="ln3171">static void _place_minivaults()</a>
<a name="ln3172">{</a>
<a name="ln3173">    const map_def *vault = nullptr;</a>
<a name="ln3174">    // First place the vault requested with &amp;P</a>
<a name="ln3175">    if (you.props.exists(&quot;force_minivault&quot;)</a>
<a name="ln3176">        &amp;&amp; (vault = find_map_by_name(you.props[&quot;force_minivault&quot;])))</a>
<a name="ln3177">    {</a>
<a name="ln3178">        _dgn_ensure_vault_placed(_build_secondary_vault(vault), false);</a>
<a name="ln3179">    }</a>
<a name="ln3180">    // Always try to place PLACE:X minivaults.</a>
<a name="ln3181">    if ((vault = random_map_for_place(level_id::current(), true)))</a>
<a name="ln3182">        _build_secondary_vault(vault);</a>
<a name="ln3183"> </a>
<a name="ln3184">    if (use_random_maps)</a>
<a name="ln3185">    {</a>
<a name="ln3186">        int tries = 0;</a>
<a name="ln3187">        do</a>
<a name="ln3188">        {</a>
<a name="ln3189">            vault = random_map_in_depth(level_id::current(), true);</a>
<a name="ln3190">            if (vault)</a>
<a name="ln3191">                _build_secondary_vault(vault);</a>
<a name="ln3192">        } // if ALL maps eligible are &quot;extra&quot; but fail to place, we'd be screwed</a>
<a name="ln3193">        while (vault &amp;&amp; vault-&gt;is_extra_vault() &amp;&amp; tries++ &lt; 10000);</a>
<a name="ln3194">    }</a>
<a name="ln3195">}</a>
<a name="ln3196"> </a>
<a name="ln3197">static bool _builder_normal()</a>
<a name="ln3198">{</a>
<a name="ln3199">    const map_def *vault = _dgn_random_map_for_place(false);</a>
<a name="ln3200"> </a>
<a name="ln3201">    if (vault)</a>
<a name="ln3202">    {</a>
<a name="ln3203">        // TODO: figure out a good way to do this only in Temple</a>
<a name="ln3204">        dgn_map_parameters mp(</a>
<a name="ln3205">            you.props.exists(TEMPLE_SIZE_KEY)</a>
<a name="ln3206">            ? make_stringf(&quot;temple_altars_%d&quot;,</a>
<a name="ln3207">                           you.props[TEMPLE_SIZE_KEY].get_int())</a>
<a name="ln3208">            : &quot;&quot;);</a>
<a name="ln3209">        env.level_build_method += &quot; random_map_for_place&quot;;</a>
<a name="ln3210">        _ensure_vault_placed_ex(_build_primary_vault(vault), vault);</a>
<a name="ln3211">        // Only place subsequent random vaults on non-encompass maps</a>
<a name="ln3212">        // and not at the branch end</a>
<a name="ln3213">        return vault-&gt;orient != MAP_ENCOMPASS;</a>
<a name="ln3214">    }</a>
<a name="ln3215"> </a>
<a name="ln3216">    if (use_random_maps)</a>
<a name="ln3217">        vault = random_map_in_depth(level_id::current(), false, MB_FALSE);</a>
<a name="ln3218"> </a>
<a name="ln3219">    if (vault)</a>
<a name="ln3220">    {</a>
<a name="ln3221">        env.level_build_method += &quot; random_map_in_depth&quot;;</a>
<a name="ln3222">        _ensure_vault_placed_ex(_build_primary_vault(vault), vault);</a>
<a name="ln3223">        // Only place subsequent random vaults on non-encompass maps</a>
<a name="ln3224">        // and not at the branch end</a>
<a name="ln3225">        return vault-&gt;orient != MAP_ENCOMPASS;</a>
<a name="ln3226">    }</a>
<a name="ln3227"> </a>
<a name="ln3228">    vault = random_map_for_tag(&quot;layout&quot;, true, true);</a>
<a name="ln3229"> </a>
<a name="ln3230">    if (!vault)</a>
<a name="ln3231">        die(&quot;Couldn't pick a layout.&quot;);</a>
<a name="ln3232"> </a>
<a name="ln3233">    _dgn_ensure_vault_placed(_build_primary_vault(vault), false);</a>
<a name="ln3234">    return true;</a>
<a name="ln3235">}</a>
<a name="ln3236"> </a>
<a name="ln3237">static void _place_traps()</a>
<a name="ln3238">{</a>
<a name="ln3239">    const int num_traps = random2avg(2 * trap_rate_for_place(), 2);</a>
<a name="ln3240"> </a>
<a name="ln3241">    ASSERT(num_traps &gt;= 0);</a>
<a name="ln3242">    dprf(&quot;attempting to place %d traps&quot;, num_traps);</a>
<a name="ln3243"> </a>
<a name="ln3244">    for (int i = 0; i &lt; num_traps; i++)</a>
<a name="ln3245">    {</a>
<a name="ln3246">        trap_def ts;</a>
<a name="ln3247"> </a>
<a name="ln3248">        int tries;</a>
<a name="ln3249">        for (tries = 0; tries &lt; 200; ++tries)</a>
<a name="ln3250">        {</a>
<a name="ln3251">            ts.pos.x = random2(GXM);</a>
<a name="ln3252">            ts.pos.y = random2(GYM);</a>
<a name="ln3253">            // Don't place random traps under vault monsters; if a vault</a>
<a name="ln3254">            // wants this they have to request it specifically.</a>
<a name="ln3255">            if (in_bounds(ts.pos)</a>
<a name="ln3256">                &amp;&amp; grd(ts.pos) == DNGN_FLOOR</a>
<a name="ln3257">                &amp;&amp; !map_masked(ts.pos, MMT_NO_TRAP)</a>
<a name="ln3258">                &amp;&amp; mgrd(ts.pos) == NON_MONSTER)</a>
<a name="ln3259">            {</a>
<a name="ln3260">                break;</a>
<a name="ln3261">            }</a>
<a name="ln3262">        }</a>
<a name="ln3263"> </a>
<a name="ln3264">        if (tries == 200)</a>
<a name="ln3265">        {</a>
<a name="ln3266">            dprf(&quot;tried %d times to place a trap &amp; gave up&quot;, tries);</a>
<a name="ln3267">            break;</a>
<a name="ln3268">        }</a>
<a name="ln3269"> </a>
<a name="ln3270">        const trap_type type = random_trap_for_place();</a>
<a name="ln3271">        if (type == NUM_TRAPS)</a>
<a name="ln3272">        {</a>
<a name="ln3273">            dprf(&quot;failed to find a trap type to place&quot;);</a>
<a name="ln3274">            continue;</a>
<a name="ln3275">        }</a>
<a name="ln3276"> </a>
<a name="ln3277">        ts.type = type;</a>
<a name="ln3278">        grd(ts.pos) = ts.feature();</a>
<a name="ln3279">        ts.prepare_ammo();</a>
<a name="ln3280">        env.trap[ts.pos] = ts;</a>
<a name="ln3281">        dprf(&quot;placed a %s trap&quot;, trap_name(type).c_str());</a>
<a name="ln3282">    }</a>
<a name="ln3283"> </a>
<a name="ln3284">    if (player_in_branch(BRANCH_SPIDER))</a>
<a name="ln3285">    {</a>
<a name="ln3286">        // Max webs ranges from around 35 (Spider:1) to 220 (Spider:5), actual</a>
<a name="ln3287">        // amount will be much lower.</a>
<a name="ln3288">        int max_webs = 35 * pow(2, (you.depth - 1) / 1.5) - num_traps;</a>
<a name="ln3289">        max_webs /= 2;</a>
<a name="ln3290">        place_webs(max_webs + random2(max_webs));</a>
<a name="ln3291">    }</a>
<a name="ln3292">}</a>
<a name="ln3293"> </a>
<a name="ln3294">static void _dgn_place_feature_at_random_floor_square(dungeon_feature_type feat,</a>
<a name="ln3295">                                                      unsigned mask = MMT_VAULT)</a>
<a name="ln3296">{</a>
<a name="ln3297">    coord_def place = _dgn_random_point_in_bounds(DNGN_FLOOR, mask, DNGN_FLOOR);</a>
<a name="ln3298">    if (player_in_branch(BRANCH_SLIME))</a>
<a name="ln3299">    {</a>
<a name="ln3300">        int tries = 100;</a>
<a name="ln3301">        while (!place.origin()  // stop if we fail to find floor.</a>
<a name="ln3302">               &amp;&amp; (dgn_has_adjacent_feat(place, DNGN_ROCK_WALL)</a>
<a name="ln3303">                   || dgn_has_adjacent_feat(place, DNGN_SLIMY_WALL))</a>
<a name="ln3304">               &amp;&amp; tries-- &gt; 0)</a>
<a name="ln3305">        {</a>
<a name="ln3306">            place = _dgn_random_point_in_bounds(DNGN_FLOOR, mask, DNGN_FLOOR);</a>
<a name="ln3307">        }</a>
<a name="ln3308"> </a>
<a name="ln3309">        if (tries &lt; 0)  // tries == 0 means we succeeded on the last attempt</a>
<a name="ln3310">            place.reset();</a>
<a name="ln3311">    }</a>
<a name="ln3312">    if (place.origin())</a>
<a name="ln3313">        throw dgn_veto_exception(&quot;Cannot place feature at random floor square.&quot;);</a>
<a name="ln3314">    else</a>
<a name="ln3315">        _set_grd(place, feat);</a>
<a name="ln3316">}</a>
<a name="ln3317"> </a>
<a name="ln3318">// Create randomly-placed stone stairs.</a>
<a name="ln3319">void dgn_place_stone_stairs(bool maybe_place_hatches)</a>
<a name="ln3320">{</a>
<a name="ln3321">    const int stair_start = DNGN_STONE_STAIRS_DOWN_I;</a>
<a name="ln3322">    const int stair_count = DNGN_ESCAPE_HATCH_UP - stair_start + 1;</a>
<a name="ln3323"> </a>
<a name="ln3324">    FixedVector &lt; bool, stair_count &gt; existing;</a>
<a name="ln3325"> </a>
<a name="ln3326">    existing.init(false);</a>
<a name="ln3327"> </a>
<a name="ln3328">    for (rectangle_iterator ri(0); ri; ++ri)</a>
<a name="ln3329">        if (grd(*ri) &gt;= stair_start &amp;&amp; grd(*ri) &lt; stair_start + stair_count)</a>
<a name="ln3330">            existing[grd(*ri) - stair_start] = true;</a>
<a name="ln3331"> </a>
<a name="ln3332">    int pair_count = 3;</a>
<a name="ln3333"> </a>
<a name="ln3334">    if (maybe_place_hatches &amp;&amp; coinflip())</a>
<a name="ln3335">        pair_count++;</a>
<a name="ln3336"> </a>
<a name="ln3337">    for (int i = 0; i &lt; pair_count; ++i)</a>
<a name="ln3338">    {</a>
<a name="ln3339">        if (!existing[i])</a>
<a name="ln3340">        {</a>
<a name="ln3341">            _dgn_place_feature_at_random_floor_square(</a>
<a name="ln3342">                static_cast&lt;dungeon_feature_type&gt;(DNGN_STONE_STAIRS_DOWN_I + i));</a>
<a name="ln3343">        }</a>
<a name="ln3344"> </a>
<a name="ln3345">        if (!existing[DNGN_STONE_STAIRS_UP_I - stair_start + i])</a>
<a name="ln3346">        {</a>
<a name="ln3347">            _dgn_place_feature_at_random_floor_square(</a>
<a name="ln3348">                static_cast&lt;dungeon_feature_type&gt;(DNGN_STONE_STAIRS_UP_I + i));</a>
<a name="ln3349">        }</a>
<a name="ln3350">    }</a>
<a name="ln3351">}</a>
<a name="ln3352"> </a>
<a name="ln3353">bool dgn_has_adjacent_feat(coord_def c, dungeon_feature_type feat)</a>
<a name="ln3354">{</a>
<a name="ln3355">    for (adjacent_iterator ai(c); ai; ++ai)</a>
<a name="ln3356">        if (grd(*ai) == feat)</a>
<a name="ln3357">            return true;</a>
<a name="ln3358">    return false;</a>
<a name="ln3359">}</a>
<a name="ln3360"> </a>
<a name="ln3361">coord_def dgn_random_point_in_margin(int margin)</a>
<a name="ln3362">{</a>
<a name="ln3363">    coord_def res;</a>
<a name="ln3364">    res.x = random_range(margin, GXM - margin - 1);</a>
<a name="ln3365">    res.y = random_range(margin, GYM - margin - 1);</a>
<a name="ln3366">    return res;</a>
<a name="ln3367">}</a>
<a name="ln3368"> </a>
<a name="ln3369">static inline bool _point_matches_feat(coord_def c,</a>
<a name="ln3370">                                       dungeon_feature_type searchfeat,</a>
<a name="ln3371">                                       uint32_t mapmask,</a>
<a name="ln3372">                                       dungeon_feature_type adjacent_feat,</a>
<a name="ln3373">                                       bool monster_free)</a>
<a name="ln3374">{</a>
<a name="ln3375">    return grd(c) == searchfeat</a>
<a name="ln3376">           &amp;&amp; (!monster_free || !monster_at(c))</a>
<a name="ln3377">           &amp;&amp; !map_masked(c, mapmask)</a>
<a name="ln3378">           &amp;&amp; (adjacent_feat == DNGN_UNSEEN ||</a>
<a name="ln3379">               dgn_has_adjacent_feat(c, adjacent_feat));</a>
<a name="ln3380">}</a>
<a name="ln3381"> </a>
<a name="ln3382">// Returns a random point in map bounds matching the given search feature,</a>
<a name="ln3383">// and respecting the map mask (a map mask of MMT_VAULT ensures that</a>
<a name="ln3384">// positions inside vaults will not be returned).</a>
<a name="ln3385">//</a>
<a name="ln3386">// If adjacent_feat is not DNGN_UNSEEN, the chosen square will be</a>
<a name="ln3387">// adjacent to a square containing adjacent_feat.</a>
<a name="ln3388">//</a>
<a name="ln3389">// If monster_free is true, the chosen square will never be occupied by</a>
<a name="ln3390">// a monster.</a>
<a name="ln3391">//</a>
<a name="ln3392">// If tries is set to anything other than -1, this function will make tries</a>
<a name="ln3393">// attempts to find a suitable square, and may fail if the map is crowded.</a>
<a name="ln3394">// If tries is set to -1, this function will examine the entire map and</a>
<a name="ln3395">// guarantees to find a suitable point if available.</a>
<a name="ln3396">//</a>
<a name="ln3397">// If a suitable point is not available (or was not found in X tries),</a>
<a name="ln3398">// returns coord_def(0,0)</a>
<a name="ln3399">//</a>
<a name="ln3400">static coord_def _dgn_random_point_in_bounds(dungeon_feature_type searchfeat,</a>
<a name="ln3401">                                     uint32_t mapmask,</a>
<a name="ln3402">                                     dungeon_feature_type adjacent_feat,</a>
<a name="ln3403">                                     bool monster_free,</a>
<a name="ln3404">                                     int tries)</a>
<a name="ln3405">{</a>
<a name="ln3406">    if (tries == -1)</a>
<a name="ln3407">    {</a>
<a name="ln3408">        // Try a quick and dirty random search:</a>
<a name="ln3409">        int n = 10;</a>
<a name="ln3410">        if (searchfeat == DNGN_FLOOR)</a>
<a name="ln3411">            n = 500;</a>
<a name="ln3412">        coord_def chosen = _dgn_random_point_in_bounds(searchfeat,</a>
<a name="ln3413">                                                       mapmask,</a>
<a name="ln3414">                                                       adjacent_feat,</a>
<a name="ln3415">                                                       monster_free,</a>
<a name="ln3416">                                                       n);</a>
<a name="ln3417">        if (!chosen.origin())</a>
<a name="ln3418">            return chosen;</a>
<a name="ln3419"> </a>
<a name="ln3420">        // Exhaustive search; will never fail if a suitable place is</a>
<a name="ln3421">        // available, but is also far more expensive.</a>
<a name="ln3422">        int nfound = 0;</a>
<a name="ln3423">        for (rectangle_iterator ri(1); ri; ++ri)</a>
<a name="ln3424">        {</a>
<a name="ln3425">            const coord_def c(*ri);</a>
<a name="ln3426">            if (_point_matches_feat(c, searchfeat, mapmask, adjacent_feat,</a>
<a name="ln3427">                                    monster_free)</a>
<a name="ln3428">                &amp;&amp; one_chance_in(++nfound))</a>
<a name="ln3429">            {</a>
<a name="ln3430">                chosen = c;</a>
<a name="ln3431">            }</a>
<a name="ln3432">        }</a>
<a name="ln3433">        return chosen;</a>
<a name="ln3434">    }</a>
<a name="ln3435">    else</a>
<a name="ln3436">    {</a>
<a name="ln3437">        // Random search.</a>
<a name="ln3438">        while (--tries &gt;= 0)</a>
<a name="ln3439">        {</a>
<a name="ln3440">            const coord_def c = random_in_bounds();</a>
<a name="ln3441">            if (_point_matches_feat(c, searchfeat, mapmask, adjacent_feat,</a>
<a name="ln3442">                                    monster_free))</a>
<a name="ln3443">            {</a>
<a name="ln3444">                return c;</a>
<a name="ln3445">            }</a>
<a name="ln3446">        }</a>
<a name="ln3447">        return coord_def(0, 0);</a>
<a name="ln3448">    }</a>
<a name="ln3449">}</a>
<a name="ln3450"> </a>
<a name="ln3451">static coord_def _place_specific_feature(dungeon_feature_type feat)</a>
<a name="ln3452">{</a>
<a name="ln3453">    /* Only overwrite vaults when absolutely necessary. */</a>
<a name="ln3454">    coord_def c = _dgn_random_point_in_bounds(DNGN_FLOOR, MMT_VAULT, DNGN_UNSEEN, true);</a>
<a name="ln3455">    if (!in_bounds(c))</a>
<a name="ln3456">        c = _dgn_random_point_in_bounds(DNGN_FLOOR, 0, DNGN_UNSEEN, true);</a>
<a name="ln3457"> </a>
<a name="ln3458">    if (in_bounds(c))</a>
<a name="ln3459">        env.grid(c) = feat;</a>
<a name="ln3460">    else</a>
<a name="ln3461">        throw dgn_veto_exception(&quot;Cannot place specific feature.&quot;);</a>
<a name="ln3462"> </a>
<a name="ln3463">    return c;</a>
<a name="ln3464">}</a>
<a name="ln3465"> </a>
<a name="ln3466">static bool _place_vault_by_tag(const string &amp;tag)</a>
<a name="ln3467">{</a>
<a name="ln3468">    const map_def *vault = random_map_for_tag(tag, true);</a>
<a name="ln3469">    if (!vault)</a>
<a name="ln3470">        return false;</a>
<a name="ln3471">    return _build_secondary_vault(vault);</a>
<a name="ln3472">}</a>
<a name="ln3473"> </a>
<a name="ln3474">static void _place_branch_entrances(bool use_vaults)</a>
<a name="ln3475">{</a>
<a name="ln3476">    // Find what branch entrances are already placed, and what branch</a>
<a name="ln3477">    // entrances could be placed here.</a>
<a name="ln3478">    bool branch_entrance_placed[NUM_BRANCHES];</a>
<a name="ln3479">    bool could_be_placed = false;</a>
<a name="ln3480">    for (branch_iterator it; it; ++it)</a>
<a name="ln3481">    {</a>
<a name="ln3482">        branch_entrance_placed[it-&gt;id] = false;</a>
<a name="ln3483">        if (!could_be_placed</a>
<a name="ln3484">            &amp;&amp; !branch_is_unfinished(it-&gt;id)</a>
<a name="ln3485">            &amp;&amp; !is_hell_subbranch(it-&gt;id)</a>
<a name="ln3486">            &amp;&amp; ((you.depth &gt;= it-&gt;mindepth</a>
<a name="ln3487">                 &amp;&amp; you.depth &lt;= it-&gt;maxdepth)</a>
<a name="ln3488">                || level_id::current() == brentry[it-&gt;id]))</a>
<a name="ln3489">        {</a>
<a name="ln3490">            could_be_placed = true;</a>
<a name="ln3491">        }</a>
<a name="ln3492">    }</a>
<a name="ln3493"> </a>
<a name="ln3494">    // If there's nothing to be placed, don't bother.</a>
<a name="ln3495">    if (!could_be_placed)</a>
<a name="ln3496">        return;</a>
<a name="ln3497"> </a>
<a name="ln3498">    for (rectangle_iterator ri(0); ri; ++ri)</a>
<a name="ln3499">    {</a>
<a name="ln3500">        if (!feat_is_branch_entrance(grd(*ri)))</a>
<a name="ln3501">            continue;</a>
<a name="ln3502"> </a>
<a name="ln3503">        for (branch_iterator it; it; ++it)</a>
<a name="ln3504">            if (it-&gt;entry_stairs == grd(*ri)</a>
<a name="ln3505">                &amp;&amp; !feature_mimic_at(*ri))</a>
<a name="ln3506">            {</a>
<a name="ln3507">                branch_entrance_placed[it-&gt;id] = true;</a>
<a name="ln3508">                break;</a>
<a name="ln3509">            }</a>
<a name="ln3510">    }</a>
<a name="ln3511"> </a>
<a name="ln3512">    // Place actual branch entrances.</a>
<a name="ln3513">    for (branch_iterator it; it; ++it)</a>
<a name="ln3514">    {</a>
<a name="ln3515">        // Vestibule and hells are placed by other means.</a>
<a name="ln3516">        // Likewise, if we already have an entrance, keep going.</a>
<a name="ln3517">        if (is_hell_branch(it-&gt;id) || branch_entrance_placed[it-&gt;id])</a>
<a name="ln3518">            continue;</a>
<a name="ln3519"> </a>
<a name="ln3520">        if (it-&gt;entry_stairs != NUM_FEATURES</a>
<a name="ln3521">            &amp;&amp; player_in_branch(parent_branch(it-&gt;id))</a>
<a name="ln3522">            &amp;&amp; level_id::current() == brentry[it-&gt;id])</a>
<a name="ln3523">        {</a>
<a name="ln3524">            // Placing a stair.</a>
<a name="ln3525">            dprf(DIAG_DNGN, &quot;Placing stair to %s&quot;, it-&gt;shortname);</a>
<a name="ln3526"> </a>
<a name="ln3527">            // Attempt to place an entry vault if allowed</a>
<a name="ln3528">            if (use_vaults)</a>
<a name="ln3529">            {</a>
<a name="ln3530">                string entry_tag = string(it-&gt;abbrevname);</a>
<a name="ln3531">                entry_tag += &quot;_entry&quot;;</a>
<a name="ln3532">                lowercase(entry_tag);</a>
<a name="ln3533"> </a>
<a name="ln3534">                if (_place_vault_by_tag(entry_tag))</a>
<a name="ln3535">                    // Placed this entrance, carry on to subsequent branches</a>
<a name="ln3536">                    continue;</a>
<a name="ln3537">            }</a>
<a name="ln3538"> </a>
<a name="ln3539">            // Otherwise place a single stair feature.</a>
<a name="ln3540">            // Try to use designated locations for entrances if possible.</a>
<a name="ln3541">            const coord_def portal_pos = find_portal_place(nullptr, false);</a>
<a name="ln3542">            if (!portal_pos.origin())</a>
<a name="ln3543">            {</a>
<a name="ln3544">                env.grid(portal_pos) = it-&gt;entry_stairs;</a>
<a name="ln3545">                env.level_map_mask(portal_pos) |= MMT_VAULT;</a>
<a name="ln3546">                continue;</a>
<a name="ln3547">            }</a>
<a name="ln3548"> </a>
<a name="ln3549">            const coord_def stair_pos = _place_specific_feature(it-&gt;entry_stairs);</a>
<a name="ln3550">            // Don't allow subsequent vaults to overwrite the branch stair</a>
<a name="ln3551">            env.level_map_mask(stair_pos) |= MMT_VAULT;</a>
<a name="ln3552">        }</a>
<a name="ln3553">    }</a>
<a name="ln3554">}</a>
<a name="ln3555"> </a>
<a name="ln3556">static void _place_extra_vaults()</a>
<a name="ln3557">{</a>
<a name="ln3558">    int tries = 0;</a>
<a name="ln3559">    while (true)</a>
<a name="ln3560">    {</a>
<a name="ln3561">        if (!player_in_branch(BRANCH_DUNGEON) &amp;&amp; use_random_maps)</a>
<a name="ln3562">        {</a>
<a name="ln3563">            const map_def *vault = random_map_in_depth(level_id::current(),</a>
<a name="ln3564">                                                       false, MB_TRUE);</a>
<a name="ln3565"> </a>
<a name="ln3566">            // Encompass vaults can't be used as secondaries.</a>
<a name="ln3567">            if (!vault || vault-&gt;orient == MAP_ENCOMPASS)</a>
<a name="ln3568">                break;</a>
<a name="ln3569"> </a>
<a name="ln3570">            if (_build_secondary_vault(vault))</a>
<a name="ln3571">            {</a>
<a name="ln3572">                const map_def &amp;map(*vault);</a>
<a name="ln3573">                if (map.is_extra_vault())</a>
<a name="ln3574">                    continue;</a>
<a name="ln3575">                use_random_maps = false;</a>
<a name="ln3576">            }</a>
<a name="ln3577">            else if (++tries &gt;= 3)</a>
<a name="ln3578">                break;</a>
<a name="ln3579">        }</a>
<a name="ln3580">        break;</a>
<a name="ln3581">    }</a>
<a name="ln3582">}</a>
<a name="ln3583"> </a>
<a name="ln3584">// Place uniques on the level.</a>
<a name="ln3585">// Return the number of uniques placed.</a>
<a name="ln3586">static int _place_uniques()</a>
<a name="ln3587">{</a>
<a name="ln3588">#ifdef DEBUG_UNIQUE_PLACEMENT</a>
<a name="ln3589">    FILE *ostat = fopen(&quot;unique_placement.log&quot;, &quot;a&quot;);</a>
<a name="ln3590">    fprintf(ostat, &quot;--- Looking to place uniques on %s\n&quot;,</a>
<a name="ln3591">                   level_id::current().describe().c_str());</a>
<a name="ln3592">#endif</a>
<a name="ln3593"> </a>
<a name="ln3594">    int num_placed = 0;</a>
<a name="ln3595"> </a>
<a name="ln3596">    // Magic numbers for dpeg's unique system.</a>
<a name="ln3597">    int A = 2;</a>
<a name="ln3598">    const int B = 5;</a>
<a name="ln3599">    while (one_chance_in(A))</a>
<a name="ln3600">    {</a>
<a name="ln3601">        // In dpeg's unique placement system, chances is always 1 in A of even</a>
<a name="ln3602">        // starting to place a unique; reduced if there are less uniques to be</a>
<a name="ln3603">        // placed or available. Then there is a chance of uniques_available /</a>
<a name="ln3604">        // B; this only triggers on levels that have less than B uniques to be</a>
<a name="ln3605">        // placed.</a>
<a name="ln3606">        const mapref_vector uniques_available =</a>
<a name="ln3607">            find_maps_for_tag(&quot;place_unique&quot;, true, true);</a>
<a name="ln3608"> </a>
<a name="ln3609">        if (!x_chance_in_y((int)uniques_available.size(), B))</a>
<a name="ln3610">            break;</a>
<a name="ln3611"> </a>
<a name="ln3612">        const map_def *uniq_map = random_map_for_tag(&quot;place_unique&quot;, true);</a>
<a name="ln3613">        if (!uniq_map)</a>
<a name="ln3614">        {</a>
<a name="ln3615">#ifdef DEBUG_UNIQUE_PLACEMENT</a>
<a name="ln3616">            fprintf(ostat, &quot;Dummy balance or no uniques left.\n&quot;);</a>
<a name="ln3617">#endif</a>
<a name="ln3618">            break;</a>
<a name="ln3619">        }</a>
<a name="ln3620"> </a>
<a name="ln3621">        const bool map_placed = _build_secondary_vault(uniq_map);</a>
<a name="ln3622">        if (map_placed)</a>
<a name="ln3623">        {</a>
<a name="ln3624">            num_placed++;</a>
<a name="ln3625">            // Make the placement chance drop steeply after</a>
<a name="ln3626">            // some have been placed, to reduce chance of</a>
<a name="ln3627">            // many uniques per level.</a>
<a name="ln3628">            if (num_placed &gt;= 3)</a>
<a name="ln3629">                A++;</a>
<a name="ln3630">#ifdef DEBUG_UNIQUE_PLACEMENT</a>
<a name="ln3631">            fprintf(ostat, &quot;Placed valid unique map: %s.\n&quot;,</a>
<a name="ln3632">                    uniq_map-&gt;name.c_str());</a>
<a name="ln3633">#endif</a>
<a name="ln3634">            dprf(DIAG_DNGN, &quot;Placed %s.&quot;, uniq_map-&gt;name.c_str());</a>
<a name="ln3635">        }</a>
<a name="ln3636">#ifdef DEBUG_UNIQUE_PLACEMENT</a>
<a name="ln3637">        else</a>
<a name="ln3638">        {</a>
<a name="ln3639">            fprintf(ostat, &quot;Didn't place valid map: %s\n&quot;,</a>
<a name="ln3640">                    uniq_map-&gt;name.c_str());</a>
<a name="ln3641">        }</a>
<a name="ln3642">#endif</a>
<a name="ln3643">    }</a>
<a name="ln3644"> </a>
<a name="ln3645">#ifdef DEBUG_UNIQUE_PLACEMENT</a>
<a name="ln3646">    fprintf(ostat, &quot;--- Finished this set, placed %d uniques.\n&quot;, num_placed);</a>
<a name="ln3647">    fclose(ostat);</a>
<a name="ln3648">#endif</a>
<a name="ln3649">    return num_placed;</a>
<a name="ln3650">}</a>
<a name="ln3651"> </a>
<a name="ln3652">static void _place_aquatic_in(vector&lt;coord_def&gt; &amp;places, const pop_entry *pop,</a>
<a name="ln3653">                              int level, bool allow_zombies)</a>
<a name="ln3654">{</a>
<a name="ln3655">    if (places.size() &lt; 35)</a>
<a name="ln3656">        return;</a>
<a name="ln3657">    int num = min(random_range(places.size() / 35, places.size() / 18), 15);</a>
<a name="ln3658">    shuffle_array(places);</a>
<a name="ln3659"> </a>
<a name="ln3660">    for (int i = 0; i &lt; num; i++)</a>
<a name="ln3661">    {</a>
<a name="ln3662">        monster_type mon = pick_monster_from(pop, level);</a>
<a name="ln3663">        if (mon == MONS_0)</a>
<a name="ln3664">            break;</a>
<a name="ln3665"> </a>
<a name="ln3666">        mgen_data mg;</a>
<a name="ln3667">        mg.behaviour = BEH_SLEEP;</a>
<a name="ln3668">        mg.flags    |= MG_PERMIT_BANDS | MG_FORCE_PLACE;</a>
<a name="ln3669">        mg.map_mask |= MMT_NO_MONS;</a>
<a name="ln3670">        mg.cls = mon;</a>
<a name="ln3671">        mg.pos = places[i];</a>
<a name="ln3672"> </a>
<a name="ln3673">        // Amphibious creatures placed with water should hang around it</a>
<a name="ln3674">        if (mons_class_primary_habitat(mon) == HT_LAND)</a>
<a name="ln3675">            mg.flags |= MG_PATROLLING;</a>
<a name="ln3676"> </a>
<a name="ln3677">        if (allow_zombies</a>
<a name="ln3678">            &amp;&amp; player_in_hell()</a>
<a name="ln3679">            &amp;&amp; mons_class_can_be_zombified(mg.cls))</a>
<a name="ln3680">        {</a>
<a name="ln3681">            mg.base_type = mg.cls;</a>
<a name="ln3682">            const int skel_chance = mons_skeleton(mg.cls) ? 2 : 0;</a>
<a name="ln3683">            mg.cls = random_choose_weighted(skel_chance, MONS_SKELETON,</a>
<a name="ln3684">                                            8,           MONS_ZOMBIE,</a>
<a name="ln3685">                                            1,           MONS_SIMULACRUM);</a>
<a name="ln3686">        }</a>
<a name="ln3687"> </a>
<a name="ln3688">        place_monster(mg);</a>
<a name="ln3689">    }</a>
<a name="ln3690">}</a>
<a name="ln3691"> </a>
<a name="ln3692">static void _place_aquatic_monsters()</a>
<a name="ln3693">{</a>
<a name="ln3694">    // Shoals relies on normal monster generation to place its monsters.</a>
<a name="ln3695">    // Abyss's nature discourages random movement-inhibited monsters.</a>
<a name="ln3696">    // Default liquid creatures are harmless in Pan or Zot, and</a>
<a name="ln3697">    // threatening ones are distracting from their sets.</a>
<a name="ln3698">    // Random liquid monster placement is too vicious before D:6.</a>
<a name="ln3699">    //</a>
<a name="ln3700">    if (player_in_branch(BRANCH_SHOALS)</a>
<a name="ln3701">        || player_in_branch(BRANCH_ABYSS)</a>
<a name="ln3702">        || player_in_branch(BRANCH_PANDEMONIUM)</a>
<a name="ln3703">        || player_in_branch(BRANCH_ZOT)</a>
<a name="ln3704">        || player_in_branch(BRANCH_DUNGEON) &amp;&amp; you.depth &lt; 6)</a>
<a name="ln3705">    {</a>
<a name="ln3706">        return;</a>
<a name="ln3707">    }</a>
<a name="ln3708"> </a>
<a name="ln3709">    int level = level_id::current().depth;</a>
<a name="ln3710"> </a>
<a name="ln3711">    vector&lt;coord_def&gt; water;</a>
<a name="ln3712">    vector&lt;coord_def&gt; lava;</a>
<a name="ln3713"> </a>
<a name="ln3714">    for (rectangle_iterator ri(0); ri; ++ri)</a>
<a name="ln3715">    {</a>
<a name="ln3716">        if (actor_at(*ri) || env.level_map_mask(*ri) &amp; MMT_NO_MONS)</a>
<a name="ln3717">            continue;</a>
<a name="ln3718"> </a>
<a name="ln3719">        dungeon_feature_type feat = grd(*ri);</a>
<a name="ln3720">        if (feat == DNGN_SHALLOW_WATER || feat == DNGN_DEEP_WATER)</a>
<a name="ln3721">            water.push_back(*ri);</a>
<a name="ln3722">        else if (feat == DNGN_LAVA)</a>
<a name="ln3723">            lava.push_back(*ri);</a>
<a name="ln3724">    }</a>
<a name="ln3725"> </a>
<a name="ln3726">    _place_aquatic_in(water, fish_population(you.where_are_you, false), level,</a>
<a name="ln3727">                      true);</a>
<a name="ln3728">    _place_aquatic_in(lava, fish_population(you.where_are_you, true), level,</a>
<a name="ln3729">                      false);</a>
<a name="ln3730">}</a>
<a name="ln3731"> </a>
<a name="ln3732">static vector&lt;monster_type&gt; _zombifiables()</a>
<a name="ln3733">{</a>
<a name="ln3734">    vector&lt;monster_type&gt; z;</a>
<a name="ln3735">    for (monster_type mcls = MONS_0; mcls &lt; NUM_MONSTERS; ++mcls)</a>
<a name="ln3736">    {</a>
<a name="ln3737">        if (mons_species(mcls) != mcls</a>
<a name="ln3738">            || !mons_zombie_size(mcls)</a>
<a name="ln3739">            || mons_is_unique(mcls)</a>
<a name="ln3740">            || !(mons_class_holiness(mcls) &amp; MH_NATURAL)</a>
<a name="ln3741">            || mons_class_flag(mcls, M_NO_GEN_DERIVED))</a>
<a name="ln3742">        {</a>
<a name="ln3743">            continue;</a>
<a name="ln3744">        }</a>
<a name="ln3745"> </a>
<a name="ln3746">        z.push_back(mcls);</a>
<a name="ln3747">    }</a>
<a name="ln3748">    return z;</a>
<a name="ln3749">}</a>
<a name="ln3750"> </a>
<a name="ln3751">// For Crypt, adds a bunch of skeletons and zombies that do not respect</a>
<a name="ln3752">// absdepth (and thus tend to be varied and include several types that</a>
<a name="ln3753">// would not otherwise spawn there).</a>
<a name="ln3754">static void _place_assorted_zombies()</a>
<a name="ln3755">{</a>
<a name="ln3756">    static const vector&lt;monster_type&gt; zombifiable = _zombifiables();</a>
<a name="ln3757">    int num_zombies = random_range(6, 12, 3);</a>
<a name="ln3758">    for (int i = 0; i &lt; num_zombies; ++i)</a>
<a name="ln3759">    {</a>
<a name="ln3760">        bool skel = coinflip();</a>
<a name="ln3761">        monster_type z_base;</a>
<a name="ln3762">        do</a>
<a name="ln3763">        {</a>
<a name="ln3764">            z_base = zombifiable[random2(zombifiable.size())];</a>
<a name="ln3765">        }</a>
<a name="ln3766">        while (skel &amp;&amp; !mons_skeleton(z_base));</a>
<a name="ln3767"> </a>
<a name="ln3768">        mgen_data mg;</a>
<a name="ln3769">        mg.cls = (skel ? MONS_SKELETON : MONS_ZOMBIE);</a>
<a name="ln3770">        mg.base_type = z_base;</a>
<a name="ln3771">        mg.behaviour = BEH_SLEEP;</a>
<a name="ln3772">        mg.map_mask |= MMT_NO_MONS;</a>
<a name="ln3773">        mg.preferred_grid_feature = DNGN_FLOOR;</a>
<a name="ln3774"> </a>
<a name="ln3775">        place_monster(mg);</a>
<a name="ln3776">    }</a>
<a name="ln3777">}</a>
<a name="ln3778"> </a>
<a name="ln3779">bool door_vetoed(const coord_def pos)</a>
<a name="ln3780">{</a>
<a name="ln3781">    return env.markers.property_at(pos, MAT_ANY, &quot;veto_open&quot;) == &quot;veto&quot;;</a>
<a name="ln3782">}</a>
<a name="ln3783"> </a>
<a name="ln3784">static void _builder_monsters()</a>
<a name="ln3785">{</a>
<a name="ln3786">    if (player_in_branch(BRANCH_TEMPLE))</a>
<a name="ln3787">        return;</a>
<a name="ln3788"> </a>
<a name="ln3789">    int mon_wanted = _num_mons_wanted();</a>
<a name="ln3790"> </a>
<a name="ln3791">    const bool in_shoals = player_in_branch(BRANCH_SHOALS);</a>
<a name="ln3792">    if (in_shoals)</a>
<a name="ln3793">        dgn_shoals_generate_flora();</a>
<a name="ln3794"> </a>
<a name="ln3795">    // Try to place Shoals monsters on floor where possible instead of</a>
<a name="ln3796">    // letting all the merfolk be generated in the middle of the</a>
<a name="ln3797">    // water.</a>
<a name="ln3798">    const dungeon_feature_type preferred_grid_feature =</a>
<a name="ln3799">        in_shoals ? DNGN_FLOOR : DNGN_UNSEEN;</a>
<a name="ln3800"> </a>
<a name="ln3801">    dprf(DIAG_DNGN, &quot;_builder_monsters: Generating %d monsters&quot;, mon_wanted);</a>
<a name="ln3802">    for (int i = 0; i &lt; mon_wanted; i++)</a>
<a name="ln3803">    {</a>
<a name="ln3804">        mgen_data mg;</a>
<a name="ln3805"> </a>
<a name="ln3806">        // On D:1, we want monsters out of LOS distance from the player's</a>
<a name="ln3807">        // starting position, and we don't generate them awake.</a>
<a name="ln3808">        if (env.absdepth0 == 0)</a>
<a name="ln3809">        {</a>
<a name="ln3810">            mg.proximity = PROX_AWAY_FROM_DUNGEON_ENTRANCE;</a>
<a name="ln3811">            mg.behaviour = BEH_SLEEP;</a>
<a name="ln3812">        }</a>
<a name="ln3813">        // Chance to generate the monster awake, but away from level stairs.</a>
<a name="ln3814">        else if (player_in_connected_branch()</a>
<a name="ln3815">                 &amp;&amp; env.absdepth0 &gt; 0</a>
<a name="ln3816">                 &amp;&amp; one_chance_in(8))</a>
<a name="ln3817">        {</a>
<a name="ln3818">            mg.proximity = PROX_AWAY_FROM_STAIRS;</a>
<a name="ln3819">        }</a>
<a name="ln3820">        // Pan monsters always generate awake.</a>
<a name="ln3821">        else if (!player_in_branch(BRANCH_PANDEMONIUM))</a>
<a name="ln3822">            mg.behaviour = BEH_SLEEP;</a>
<a name="ln3823"> </a>
<a name="ln3824">        mg.flags    |= MG_PERMIT_BANDS;</a>
<a name="ln3825">        mg.map_mask |= MMT_NO_MONS;</a>
<a name="ln3826">        mg.preferred_grid_feature = preferred_grid_feature;</a>
<a name="ln3827">        place_monster(mg);</a>
<a name="ln3828">    }</a>
<a name="ln3829"> </a>
<a name="ln3830">    if (!player_in_branch(BRANCH_CRYPT)) // No water creatures in the Crypt.</a>
<a name="ln3831">        _place_aquatic_monsters();</a>
<a name="ln3832">    else</a>
<a name="ln3833">        _place_assorted_zombies();</a>
<a name="ln3834">}</a>
<a name="ln3835"> </a>
<a name="ln3836">/**</a>
<a name="ln3837"> * Randomly place a single item</a>
<a name="ln3838"> *</a>
<a name="ln3839"> * @param item   The item slot of the item being randomly placed</a>
<a name="ln3840"> */</a>
<a name="ln3841">static void _randomly_place_item(int item)</a>
<a name="ln3842">{</a>
<a name="ln3843">    coord_def itempos;</a>
<a name="ln3844">    bool found = false;</a>
<a name="ln3845">    for (int i = 0; i &lt; 500 &amp;&amp; !found; ++i)</a>
<a name="ln3846">    {</a>
<a name="ln3847">        itempos = random_in_bounds();</a>
<a name="ln3848">        const monster* mon = monster_at(itempos);</a>
<a name="ln3849">        found = grd(itempos) == DNGN_FLOOR</a>
<a name="ln3850">                &amp;&amp; !map_masked(itempos, MMT_NO_ITEM)</a>
<a name="ln3851">                // oklobs or statues are ok</a>
<a name="ln3852">                &amp;&amp; (!mon || !mons_is_firewood(*mon));</a>
<a name="ln3853">    }</a>
<a name="ln3854">    if (!found)</a>
<a name="ln3855">    {</a>
<a name="ln3856">        dprf(DIAG_DNGN, &quot;Builder failed to place %s&quot;,</a>
<a name="ln3857">            mitm[item].name(DESC_PLAIN, false, true).c_str());</a>
<a name="ln3858">        // Couldn't find a single good spot!</a>
<a name="ln3859">        destroy_item(item);</a>
<a name="ln3860">    }</a>
<a name="ln3861">    else</a>
<a name="ln3862">    {</a>
<a name="ln3863">        dprf(DIAG_DNGN, &quot;Builder placing %s at %d,%d&quot;,</a>
<a name="ln3864">            mitm[item].name(DESC_PLAIN, false, true).c_str(),</a>
<a name="ln3865">            itempos.x, itempos.y);</a>
<a name="ln3866">        move_item_to_grid(&amp;item, itempos);</a>
<a name="ln3867">    }</a>
<a name="ln3868">}</a>
<a name="ln3869"> </a>
<a name="ln3870">/**</a>
<a name="ln3871"> * Randomly place items on a level. Does not place items in vaults,</a>
<a name="ln3872"> * on monsters, etc. Only normal floor generated items.</a>
<a name="ln3873"> */</a>
<a name="ln3874">static void _builder_items()</a>
<a name="ln3875">{</a>
<a name="ln3876">    int i = 0;</a>
<a name="ln3877">    object_class_type specif_type = OBJ_RANDOM;</a>
<a name="ln3878">    int items_levels = env.absdepth0;</a>
<a name="ln3879">    int items_wanted = _num_items_wanted(items_levels);</a>
<a name="ln3880"> </a>
<a name="ln3881">    if (player_in_branch(BRANCH_VAULTS))</a>
<a name="ln3882">    {</a>
<a name="ln3883">        items_levels *= 15;</a>
<a name="ln3884">        items_levels /= 10;</a>
<a name="ln3885">    }</a>
<a name="ln3886">    else if (player_in_branch(BRANCH_ORC))</a>
<a name="ln3887">    {</a>
<a name="ln3888">        specif_type = OBJ_GOLD;  // Lots of gold in the orcish mines.</a>
<a name="ln3889">        items_levels *= 2;       // Four levels' worth, in fact.</a>
<a name="ln3890">    }</a>
<a name="ln3891"> </a>
<a name="ln3892">    for (i = 0; i &lt; items_wanted; i++)</a>
<a name="ln3893">    {</a>
<a name="ln3894">        int item = items(true, specif_type, OBJ_RANDOM, items_levels);</a>
<a name="ln3895"> </a>
<a name="ln3896">        _randomly_place_item(item);</a>
<a name="ln3897">    }</a>
<a name="ln3898"> </a>
<a name="ln3899">}</a>
<a name="ln3900"> </a>
<a name="ln3901">static bool _connect_vault_exit(const coord_def&amp; exit)</a>
<a name="ln3902">{</a>
<a name="ln3903">    flood_find&lt;feature_grid, coord_predicate&gt; ff(env.grid, in_bounds, true,</a>
<a name="ln3904">                                                 false);</a>
<a name="ln3905">    ff.add_feat(DNGN_FLOOR);</a>
<a name="ln3906"> </a>
<a name="ln3907">    coord_def target = ff.find_first_from(exit, env.level_map_mask);</a>
<a name="ln3908"> </a>
<a name="ln3909">    if (in_bounds(target))</a>
<a name="ln3910">        return join_the_dots(exit, target, MMT_VAULT);</a>
<a name="ln3911"> </a>
<a name="ln3912">    return false;</a>
<a name="ln3913">}</a>
<a name="ln3914"> </a>
<a name="ln3915">static bool _grid_needs_exit(const coord_def&amp; c)</a>
<a name="ln3916">{</a>
<a name="ln3917">    return !cell_is_solid(c)</a>
<a name="ln3918">           || feat_is_closed_door(grd(c));</a>
<a name="ln3919">}</a>
<a name="ln3920"> </a>
<a name="ln3921">static bool _map_feat_is_on_edge(const vault_placement &amp;place,</a>
<a name="ln3922">                                 const coord_def &amp;c)</a>
<a name="ln3923">{</a>
<a name="ln3924">    if (!place.map.in_map(c - place.pos))</a>
<a name="ln3925">        return false;</a>
<a name="ln3926"> </a>
<a name="ln3927">    for (orth_adjacent_iterator ai(c); ai; ++ai)</a>
<a name="ln3928">        if (!place.map.in_map(*ai - place.pos))</a>
<a name="ln3929">            return true;</a>
<a name="ln3930"> </a>
<a name="ln3931">    return false;</a>
<a name="ln3932">}</a>
<a name="ln3933"> </a>
<a name="ln3934">static void _pick_float_exits(vault_placement &amp;place, vector&lt;coord_def&gt; &amp;targets)</a>
<a name="ln3935">{</a>
<a name="ln3936">    vector&lt;coord_def&gt; possible_exits;</a>
<a name="ln3937"> </a>
<a name="ln3938">    for (rectangle_iterator ri(place.pos, place.pos + place.size - 1); ri; ++ri)</a>
<a name="ln3939">        if (_grid_needs_exit(*ri) &amp;&amp; _map_feat_is_on_edge(place, *ri))</a>
<a name="ln3940">            possible_exits.push_back(*ri);</a>
<a name="ln3941"> </a>
<a name="ln3942">    if (possible_exits.empty())</a>
<a name="ln3943">    {</a>
<a name="ln3944">        // Empty map (a serial vault master, etc).</a>
<a name="ln3945">        if (place.size.origin())</a>
<a name="ln3946">            return;</a>
<a name="ln3947"> </a>
<a name="ln3948">        // The vault is disconnected, does it have a stair inside?</a>
<a name="ln3949">        for (rectangle_iterator ri(place.pos, place.pos + place.size - 1); ri; ++ri)</a>
<a name="ln3950">            if (feat_is_stair(grd(*ri)))</a>
<a name="ln3951">                return;</a>
<a name="ln3952"> </a>
<a name="ln3953">        mprf(MSGCH_ERROR, &quot;Unable to find exit from %s&quot;,</a>
<a name="ln3954">             place.map.name.c_str());</a>
<a name="ln3955">        return;</a>
<a name="ln3956">    }</a>
<a name="ln3957"> </a>
<a name="ln3958">    const int npoints = possible_exits.size();</a>
<a name="ln3959">    int nexits = npoints &lt; 6? npoints : npoints / 8 + 1;</a>
<a name="ln3960"> </a>
<a name="ln3961">    if (nexits &gt; 10)</a>
<a name="ln3962">        nexits = 10;</a>
<a name="ln3963"> </a>
<a name="ln3964">    while (nexits-- &gt; 0)</a>
<a name="ln3965">    {</a>
<a name="ln3966">        int which_exit = random2(possible_exits.size());</a>
<a name="ln3967">        targets.push_back(possible_exits[which_exit]);</a>
<a name="ln3968">        possible_exits.erase(possible_exits.begin() + which_exit);</a>
<a name="ln3969">    }</a>
<a name="ln3970">}</a>
<a name="ln3971"> </a>
<a name="ln3972">static void _fixup_after_vault()</a>
<a name="ln3973">{</a>
<a name="ln3974">    _dgn_set_floor_colours();</a>
<a name="ln3975"> </a>
<a name="ln3976">    link_items();</a>
<a name="ln3977">    env.markers.activate_all();</a>
<a name="ln3978"> </a>
<a name="ln3979">    // Force teleport to place the player somewhere sane.</a>
<a name="ln3980">    you_teleport_now();</a>
<a name="ln3981"> </a>
<a name="ln3982">    setup_environment_effects();</a>
<a name="ln3983">}</a>
<a name="ln3984"> </a>
<a name="ln3985">// Places a map on the current level (minivault or regular vault).</a>
<a name="ln3986">//</a>
<a name="ln3987">// You can specify the centre of the map using &quot;where&quot; for floating vaults</a>
<a name="ln3988">// and minivaults. &quot;where&quot; is ignored for other vaults. XXX: it might be</a>
<a name="ln3989">// nice to specify a square that is not the centre, but is identified by</a>
<a name="ln3990">// a marker in the vault to be placed.</a>
<a name="ln3991">//</a>
<a name="ln3992">// NOTE: encompass maps will destroy the existing level!</a>
<a name="ln3993">//</a>
<a name="ln3994">// check_collision: If true, the newly placed vault cannot clobber existing</a>
<a name="ln3995">//          items and monsters (otherwise, items may be destroyed, monsters may</a>
<a name="ln3996">//          be teleported).</a>
<a name="ln3997">//</a>
<a name="ln3998">// Non-dungeon code should generally use dgn_safe_place_map instead of</a>
<a name="ln3999">// this function to recover from map_load_exceptions.</a>
<a name="ln4000">const vault_placement *dgn_place_map(const map_def *mdef,</a>
<a name="ln4001">                                     bool check_collision,</a>
<a name="ln4002">                                     bool make_no_exits,</a>
<a name="ln4003">                                     const coord_def &amp;where)</a>
<a name="ln4004">{</a>
<a name="ln4005">    if (!mdef)</a>
<a name="ln4006">        return nullptr;</a>
<a name="ln4007"> </a>
<a name="ln4008">    const dgn_colour_override_manager colour_man;</a>
<a name="ln4009"> </a>
<a name="ln4010">    if (mdef-&gt;orient == MAP_ENCOMPASS &amp;&amp; !crawl_state.generating_level)</a>
<a name="ln4011">    {</a>
<a name="ln4012">        if (check_collision)</a>
<a name="ln4013">        {</a>
<a name="ln4014">            mprf(MSGCH_DIAGNOSTICS,</a>
<a name="ln4015">                 &quot;Cannot generate encompass map '%s' with check_collision=true&quot;,</a>
<a name="ln4016">                 mdef-&gt;name.c_str());</a>
<a name="ln4017"> </a>
<a name="ln4018">            return nullptr;</a>
<a name="ln4019">        }</a>
<a name="ln4020"> </a>
<a name="ln4021">        // For encompass maps, clear the entire level.</a>
<a name="ln4022">        unwind_bool levgen(crawl_state.generating_level, true);</a>
<a name="ln4023">        dgn_reset_level();</a>
<a name="ln4024">        dungeon_events.clear();</a>
<a name="ln4025">        const vault_placement *vault_place =</a>
<a name="ln4026">            dgn_place_map(mdef, check_collision, make_no_exits, where);</a>
<a name="ln4027">        if (vault_place)</a>
<a name="ln4028">            _fixup_after_vault();</a>
<a name="ln4029">        return vault_place;</a>
<a name="ln4030">    }</a>
<a name="ln4031"> </a>
<a name="ln4032">    const vault_placement *vault_place =</a>
<a name="ln4033">        _build_secondary_vault(mdef, check_collision,</a>
<a name="ln4034">                               make_no_exits, where);</a>
<a name="ln4035"> </a>
<a name="ln4036">    // Activate any markers within the map.</a>
<a name="ln4037">    if (vault_place &amp;&amp; !crawl_state.generating_level)</a>
<a name="ln4038">    {</a>
<a name="ln4039">#ifdef ASSERTS</a>
<a name="ln4040">        if (mdef-&gt;name != vault_place-&gt;map.name)</a>
<a name="ln4041">        {</a>
<a name="ln4042">            die(&quot;Placed map '%s', yet vault_placement is '%s'&quot;,</a>
<a name="ln4043">                mdef-&gt;name.c_str(), vault_place-&gt;map.name.c_str());</a>
<a name="ln4044">        }</a>
<a name="ln4045">#endif</a>
<a name="ln4046"> </a>
<a name="ln4047">        for (vault_place_iterator vpi(*vault_place); vpi; ++vpi)</a>
<a name="ln4048">        {</a>
<a name="ln4049">            const coord_def p = *vpi;</a>
<a name="ln4050">            env.markers.activate_markers_at(p);</a>
<a name="ln4051">            if (!you.see_cell(p))</a>
<a name="ln4052">                set_terrain_changed(p);</a>
<a name="ln4053">        }</a>
<a name="ln4054">        env.markers.clear_need_activate();</a>
<a name="ln4055"> </a>
<a name="ln4056">        setup_environment_effects();</a>
<a name="ln4057">        _dgn_postprocess_level();</a>
<a name="ln4058">    }</a>
<a name="ln4059"> </a>
<a name="ln4060">    return vault_place;</a>
<a name="ln4061">}</a>
<a name="ln4062"> </a>
<a name="ln4063">// Identical to dgn_place_map, but recovers gracefully from</a>
<a name="ln4064">// map_load_exceptions. Prefer this function if placing maps *not*</a>
<a name="ln4065">// during level generation time.</a>
<a name="ln4066">//</a>
<a name="ln4067">// Returns the map actually placed if the map was placed successfully.</a>
<a name="ln4068">// This is usually the same as the map passed in, unless map load</a>
<a name="ln4069">// failed and maps had to be reloaded.</a>
<a name="ln4070">const vault_placement *dgn_safe_place_map(const map_def *mdef,</a>
<a name="ln4071">                                          bool check_collision,</a>
<a name="ln4072">                                          bool make_no_exits,</a>
<a name="ln4073">                                          const coord_def &amp;where)</a>
<a name="ln4074">{</a>
<a name="ln4075">    const string mapname(mdef-&gt;name);</a>
<a name="ln4076">    int retries = 10;</a>
<a name="ln4077">    while (true)</a>
<a name="ln4078">    {</a>
<a name="ln4079">        try</a>
<a name="ln4080">        {</a>
<a name="ln4081">            return dgn_place_map(mdef, check_collision, make_no_exits, where);</a>
<a name="ln4082">        }</a>
<a name="ln4083">        catch (map_load_exception &amp;mload)</a>
<a name="ln4084">        {</a>
<a name="ln4085">            if (retries-- &gt; 0)</a>
<a name="ln4086">            {</a>
<a name="ln4087">                mprf(MSGCH_ERROR,</a>
<a name="ln4088">                     &quot;Failed to load map %s in dgn_safe_place_map, &quot;</a>
<a name="ln4089">                     &quot;reloading all maps&quot;,</a>
<a name="ln4090">                     mload.what());</a>
<a name="ln4091">                reread_maps();</a>
<a name="ln4092"> </a>
<a name="ln4093">                mdef = find_map_by_name(mapname);</a>
<a name="ln4094">            }</a>
<a name="ln4095">            else</a>
<a name="ln4096">                return nullptr;</a>
<a name="ln4097">        }</a>
<a name="ln4098">    }</a>
<a name="ln4099">}</a>
<a name="ln4100"> </a>
<a name="ln4101">vault_placement *dgn_vault_at(coord_def p)</a>
<a name="ln4102">{</a>
<a name="ln4103">    const int map_index = env.level_map_ids(p);</a>
<a name="ln4104">    return map_index == INVALID_MAP_INDEX ? nullptr</a>
<a name="ln4105">                                          : env.level_vaults[map_index].get();</a>
<a name="ln4106">}</a>
<a name="ln4107"> </a>
<a name="ln4108">void dgn_seen_vault_at(coord_def p)</a>
<a name="ln4109">{</a>
<a name="ln4110">    if (vault_placement *vp = dgn_vault_at(p))</a>
<a name="ln4111">    {</a>
<a name="ln4112">        if (!vp-&gt;seen)</a>
<a name="ln4113">        {</a>
<a name="ln4114">            dprf(DIAG_DNGN, &quot;Vault %s (%d,%d)-(%d,%d) seen&quot;,</a>
<a name="ln4115">                 vp-&gt;map.name.c_str(), vp-&gt;pos.x, vp-&gt;pos.y,</a>
<a name="ln4116">                 vp-&gt;size.x, vp-&gt;size.y);</a>
<a name="ln4117">            vp-&gt;seen = true;</a>
<a name="ln4118">        }</a>
<a name="ln4119">    }</a>
<a name="ln4120">}</a>
<a name="ln4121"> </a>
<a name="ln4122">static bool _vault_wants_damage(const vault_placement &amp;vp)</a>
<a name="ln4123">{</a>
<a name="ln4124">    const map_def &amp;map = vp.map;</a>
<a name="ln4125">    if (map.has_tag(&quot;ruin&quot;))</a>
<a name="ln4126">        return true;</a>
<a name="ln4127"> </a>
<a name="ln4128">    // Some vaults may want to be ruined only in certain places with</a>
<a name="ln4129">    // tags like &quot;ruin_abyss&quot; or &quot;ruin_lair&quot;</a>
<a name="ln4130">    string place_desc = level_id::current().describe(false, false);</a>
<a name="ln4131">    lowercase(place_desc);</a>
<a name="ln4132">    return map.has_tag(&quot;ruin_&quot; + place_desc);</a>
<a name="ln4133">}</a>
<a name="ln4134"> </a>
<a name="ln4135">static void _ruin_vault(const vault_placement &amp;vp)</a>
<a name="ln4136">{</a>
<a name="ln4137">    _ruin_level(vault_place_iterator(vp), 0, 12, 0);</a>
<a name="ln4138">}</a>
<a name="ln4139"> </a>
<a name="ln4140">// Places a vault somewhere in an already built level if possible.</a>
<a name="ln4141">// Returns true if the vault was successfully placed.</a>
<a name="ln4142">static const vault_placement *_build_secondary_vault(const map_def *vault,</a>
<a name="ln4143">                       bool check_collision, bool no_exits,</a>
<a name="ln4144">                       const coord_def &amp;where)</a>
<a name="ln4145">{</a>
<a name="ln4146">    return _build_vault_impl(vault, true, check_collision, no_exits, where);</a>
<a name="ln4147">}</a>
<a name="ln4148"> </a>
<a name="ln4149">// Builds a primary vault - i.e. a vault that is built before anything</a>
<a name="ln4150">// else on the level. After placing the vault, rooms and corridors</a>
<a name="ln4151">// will be constructed on the level and the vault exits will be</a>
<a name="ln4152">// connected to corridors.</a>
<a name="ln4153">//</a>
<a name="ln4154">// If portions of the level are already generated at this point, use</a>
<a name="ln4155">// _build_secondary_vault or dgn_place_map instead.</a>
<a name="ln4156">//</a>
<a name="ln4157">// NOTE: minivaults can never be placed as primary vaults.</a>
<a name="ln4158">//</a>
<a name="ln4159">static const vault_placement *_build_primary_vault(const map_def *vault)</a>
<a name="ln4160">{</a>
<a name="ln4161">    return _build_vault_impl(vault);</a>
<a name="ln4162">}</a>
<a name="ln4163"> </a>
<a name="ln4164">// Builds a vault or minivault. Do not use this function directly: always</a>
<a name="ln4165">// prefer _build_secondary_vault or _build_primary_vault.</a>
<a name="ln4166">static const vault_placement *_build_vault_impl(const map_def *vault,</a>
<a name="ln4167">                  bool build_only, bool check_collisions,</a>
<a name="ln4168">                  bool make_no_exits, const coord_def &amp;where)</a>
<a name="ln4169">{</a>
<a name="ln4170">    if (dgn_check_connectivity &amp;&amp; !dgn_zones)</a>
<a name="ln4171">    {</a>
<a name="ln4172">        dgn_zones = dgn_count_disconnected_zones(false);</a>
<a name="ln4173">        if (player_in_branch(BRANCH_PANDEMONIUM) &amp;&amp; dgn_zones &gt; 1)</a>
<a name="ln4174">            throw dgn_veto_exception(&quot;Pan map with disconnected zones&quot;);</a>
<a name="ln4175">    }</a>
<a name="ln4176"> </a>
<a name="ln4177">    unwind_var&lt;string&gt; placing(env.placing_vault, vault-&gt;name);</a>
<a name="ln4178"> </a>
<a name="ln4179">    vault_placement place;</a>
<a name="ln4180"> </a>
<a name="ln4181">    if (map_bounds(where))</a>
<a name="ln4182">        place.pos = where;</a>
<a name="ln4183"> </a>
<a name="ln4184">    const map_section_type placed_vault_orientation =</a>
<a name="ln4185">        vault_main(place, vault, check_collisions);</a>
<a name="ln4186"> </a>
<a name="ln4187">    dprf(DIAG_DNGN, &quot;Map: %s; placed: %s; place: (%d,%d), size: (%d,%d)&quot;,</a>
<a name="ln4188">         vault-&gt;name.c_str(),</a>
<a name="ln4189">         placed_vault_orientation != MAP_NONE ? &quot;yes&quot; : &quot;no&quot;,</a>
<a name="ln4190">         place.pos.x, place.pos.y, place.size.x, place.size.y);</a>
<a name="ln4191"> </a>
<a name="ln4192">    if (placed_vault_orientation == MAP_NONE)</a>
<a name="ln4193">        return nullptr;</a>
<a name="ln4194"> </a>
<a name="ln4195">    const bool is_layout = place.map.is_overwritable_layout();</a>
<a name="ln4196"> </a>
<a name="ln4197">    if (placed_vault_orientation == MAP_ENCOMPASS &amp;&amp; !is_layout)</a>
<a name="ln4198">        env.level_layout_types.insert(&quot;encompass&quot;);</a>
<a name="ln4199"> </a>
<a name="ln4200">    if (!build_only</a>
<a name="ln4201">        &amp;&amp; (placed_vault_orientation == MAP_ENCOMPASS || is_layout)</a>
<a name="ln4202">        &amp;&amp; place.map.border_fill_type != DNGN_ROCK_WALL)</a>
<a name="ln4203">    {</a>
<a name="ln4204">        dgn_replace_area(0, 0, GXM-1, GYM-1, DNGN_ROCK_WALL,</a>
<a name="ln4205">                         place.map.border_fill_type);</a>
<a name="ln4206">    }</a>
<a name="ln4207"> </a>
<a name="ln4208">    // XXX: Moved this out of dgn_register_place so that vault-set monsters can</a>
<a name="ln4209">    // be accessed with the '9' and '8' glyphs. (due)</a>
<a name="ln4210">    if (!place.map.random_mons.empty())</a>
<a name="ln4211">    {</a>
<a name="ln4212">        dprf(DIAG_DNGN, &quot;Setting the custom random mons list.&quot;);</a>
<a name="ln4213">        set_vault_mon_list(place.map.random_mons);</a>
<a name="ln4214">    }</a>
<a name="ln4215"> </a>
<a name="ln4216">    place.apply_grid();</a>
<a name="ln4217"> </a>
<a name="ln4218">    if (_vault_wants_damage(place))</a>
<a name="ln4219">        _ruin_vault(place);</a>
<a name="ln4220"> </a>
<a name="ln4221">    if (place.exits.empty() &amp;&amp; placed_vault_orientation != MAP_ENCOMPASS</a>
<a name="ln4222">        &amp;&amp; (!place.map.is_minivault() || !place.map.has_tag(&quot;no_exits&quot;)))</a>
<a name="ln4223">    {</a>
<a name="ln4224">        _pick_float_exits(place, place.exits);</a>
<a name="ln4225">    }</a>
<a name="ln4226"> </a>
<a name="ln4227">    if (make_no_exits)</a>
<a name="ln4228">        place.exits.clear();</a>
<a name="ln4229"> </a>
<a name="ln4230">    // Must do this only after target_connections is finalised, or the vault</a>
<a name="ln4231">    // exits will not be correctly set.</a>
<a name="ln4232">    const vault_placement *saved_place = dgn_register_place(place, true);</a>
<a name="ln4233"> </a>
<a name="ln4234">#ifdef DEBUG_STATISTICS</a>
<a name="ln4235">    if (crawl_state.map_stat_gen)</a>
<a name="ln4236">        mapstat_report_map_use(place.map);</a>
<a name="ln4237">#endif</a>
<a name="ln4238"> </a>
<a name="ln4239">    if (is_layout &amp;&amp; place.map.has_tag_prefix(&quot;layout_type_&quot;))</a>
<a name="ln4240">    {</a>
<a name="ln4241">        for (auto &amp;tag : place.map.get_tags())</a>
<a name="ln4242">        {</a>
<a name="ln4243">            if (starts_with(tag, &quot;layout_type_&quot;))</a>
<a name="ln4244">            {</a>
<a name="ln4245">                env.level_layout_types.insert(</a>
<a name="ln4246">                    tag_without_prefix(tag, &quot;layout_type_&quot;));</a>
<a name="ln4247">            }</a>
<a name="ln4248">        }</a>
<a name="ln4249">    }</a>
<a name="ln4250"> </a>
<a name="ln4251">    // If the map takes the whole screen or we were only requested to</a>
<a name="ln4252">    // build the vault, our work is done.</a>
<a name="ln4253">    if (!build_only &amp;&amp; (placed_vault_orientation != MAP_ENCOMPASS || is_layout))</a>
<a name="ln4254">    {</a>
<a name="ln4255">        if (!is_layout)</a>
<a name="ln4256">            _build_postvault_level(place);</a>
<a name="ln4257"> </a>
<a name="ln4258">        dgn_place_stone_stairs(true);</a>
<a name="ln4259">    }</a>
<a name="ln4260"> </a>
<a name="ln4261">    if (!build_only &amp;&amp; (placed_vault_orientation != MAP_ENCOMPASS || is_layout)</a>
<a name="ln4262">        &amp;&amp; player_in_branch(BRANCH_SWAMP))</a>
<a name="ln4263">    {</a>
<a name="ln4264">        _process_disconnected_zones(0, 0, GXM-1, GYM-1, true, DNGN_TREE);</a>
<a name="ln4265">        // do a second pass to remove tele closets consisting of deep water</a>
<a name="ln4266">        // created by the first pass -- which will not fill in deep water</a>
<a name="ln4267">        // because it is treated as impassable.</a>
<a name="ln4268">        // TODO: get zonify to prevent these?</a>
<a name="ln4269">        // TODO: does this come up anywhere outside of swamp?</a>
<a name="ln4270">        _process_disconnected_zones(0, 0, GXM-1, GYM-1, true, DNGN_TREE,</a>
<a name="ln4271">                                    _dgn_square_is_ever_passable);</a>
<a name="ln4272">    }</a>
<a name="ln4273"> </a>
<a name="ln4274">    if (!make_no_exits)</a>
<a name="ln4275">    {</a>
<a name="ln4276">        const bool spotty =</a>
<a name="ln4277">            testbits(branches[you.where_are_you].branch_flags, brflag::spotty);</a>
<a name="ln4278">        if (place.connect(spotty) == 0 &amp;&amp; place.exits.size() &gt; 0</a>
<a name="ln4279">            &amp;&amp; !player_in_branch(BRANCH_ABYSS))</a>
<a name="ln4280">        {</a>
<a name="ln4281">            throw dgn_veto_exception(&quot;Failed to connect exits for: &quot;</a>
<a name="ln4282">                                     + place.map.name);</a>
<a name="ln4283">        }</a>
<a name="ln4284">    }</a>
<a name="ln4285"> </a>
<a name="ln4286">    // Fire any post-place hooks defined for this map; any failure</a>
<a name="ln4287">    // here is an automatic veto. Note that the post-place hook must</a>
<a name="ln4288">    // be run only after _build_postvault_level.</a>
<a name="ln4289">    if (!place.map.run_postplace_hook())</a>
<a name="ln4290">    {</a>
<a name="ln4291">        throw dgn_veto_exception(&quot;Post-place hook failed for: &quot;</a>
<a name="ln4292">                                 + place.map.name);</a>
<a name="ln4293">    }</a>
<a name="ln4294"> </a>
<a name="ln4295">    return saved_place;</a>
<a name="ln4296">}</a>
<a name="ln4297"> </a>
<a name="ln4298">static void _build_postvault_level(vault_placement &amp;place)</a>
<a name="ln4299">{</a>
<a name="ln4300">    if (player_in_branch(BRANCH_SPIDER))</a>
<a name="ln4301">    {</a>
<a name="ln4302">        int ngb_min = 2;</a>
<a name="ln4303">        int ngb_max = random_range(3, 8);</a>
<a name="ln4304">        if (one_chance_in(10))</a>
<a name="ln4305">            ngb_min = 1, ngb_max = random_range(5, 7);</a>
<a name="ln4306">        if (one_chance_in(20))</a>
<a name="ln4307">            ngb_min = 3, ngb_max = 4;</a>
<a name="ln4308">        const int connchance = random_choose(0, 5, 20, 50, 100);</a>
<a name="ln4309">        const int top = random_choose(1, 20, 125, 500, 999999);</a>
<a name="ln4310">        delve(0, ngb_min, ngb_max, connchance, -1, top);</a>
<a name="ln4311">    }</a>
<a name="ln4312">    else</a>
<a name="ln4313">    {</a>
<a name="ln4314">        const map_def* layout = _pick_layout(&amp;place.map);</a>
<a name="ln4315">        ASSERT(layout);</a>
<a name="ln4316">        {</a>
<a name="ln4317">            dgn_map_parameters mp(place.orient == MAP_CENTRE</a>
<a name="ln4318">                                  ? &quot;central&quot; : &quot;layout&quot;);</a>
<a name="ln4319">            _build_secondary_vault(layout, false);</a>
<a name="ln4320">        }</a>
<a name="ln4321">    }</a>
<a name="ln4322">}</a>
<a name="ln4323"> </a>
<a name="ln4324">static object_class_type _acquirement_object_class()</a>
<a name="ln4325">{</a>
<a name="ln4326">    static const object_class_type classes[] =</a>
<a name="ln4327">    {</a>
<a name="ln4328">        OBJ_JEWELLERY,</a>
<a name="ln4329">        OBJ_BOOKS,</a>
<a name="ln4330">        OBJ_WANDS,</a>
<a name="ln4331">        OBJ_MISCELLANY, // Felids stop here</a>
<a name="ln4332">        OBJ_WEAPONS,</a>
<a name="ln4333">        OBJ_ARMOUR,</a>
<a name="ln4334">        OBJ_STAVES,</a>
<a name="ln4335">    };</a>
<a name="ln4336"> </a>
<a name="ln4337">    const int nc = (you.species == SP_FELID) ? 4 : ARRAYSZ(classes);</a>
<a name="ln4338">    return classes[random2(nc)];</a>
<a name="ln4339">}</a>
<a name="ln4340"> </a>
<a name="ln4341">static int _dgn_item_corpse(const item_spec &amp;ispec, const coord_def where)</a>
<a name="ln4342">{</a>
<a name="ln4343">    mons_spec mspec(ispec.corpse_monster_spec());</a>
<a name="ln4344">    item_def* corpse = nullptr;</a>
<a name="ln4345"> </a>
<a name="ln4346">    for (int tries = 0; !corpse; tries++)</a>
<a name="ln4347">    {</a>
<a name="ln4348">        if (tries &gt; 200)</a>
<a name="ln4349">            return NON_ITEM;</a>
<a name="ln4350">        monster *mon = dgn_place_monster(mspec, coord_def(), true);</a>
<a name="ln4351">        if (!mon)</a>
<a name="ln4352">            continue;</a>
<a name="ln4353">        mon-&gt;position = where;</a>
<a name="ln4354">        corpse = place_monster_corpse(*mon, true, true);</a>
<a name="ln4355">        // Dismiss the monster we used to place the corpse.</a>
<a name="ln4356">        mon-&gt;flags |= MF_HARD_RESET;</a>
<a name="ln4357">        monster_die(*mon, KILL_DISMISSED, NON_MONSTER, false, true);</a>
<a name="ln4358">    }</a>
<a name="ln4359"> </a>
<a name="ln4360">    if (ispec.props.exists(CORPSE_NEVER_DECAYS))</a>
<a name="ln4361">    {</a>
<a name="ln4362">        corpse-&gt;props[CORPSE_NEVER_DECAYS].get_bool() =</a>
<a name="ln4363">            ispec.props[CORPSE_NEVER_DECAYS].get_bool();</a>
<a name="ln4364">    }</a>
<a name="ln4365"> </a>
<a name="ln4366">    if (ispec.base_type == OBJ_CORPSES &amp;&amp; ispec.sub_type == CORPSE_SKELETON)</a>
<a name="ln4367">        turn_corpse_into_skeleton(*corpse);</a>
<a name="ln4368">    else if (ispec.base_type == OBJ_FOOD &amp;&amp; ispec.sub_type == FOOD_CHUNK)</a>
<a name="ln4369">        turn_corpse_into_chunks(*corpse, false);</a>
<a name="ln4370"> </a>
<a name="ln4371">    if (ispec.props.exists(MONSTER_HIT_DICE))</a>
<a name="ln4372">    {</a>
<a name="ln4373">        corpse-&gt;props[MONSTER_HIT_DICE].get_short() =</a>
<a name="ln4374">            ispec.props[MONSTER_HIT_DICE].get_short();</a>
<a name="ln4375">    }</a>
<a name="ln4376"> </a>
<a name="ln4377">    if (ispec.qty &amp;&amp; ispec.base_type == OBJ_FOOD)</a>
<a name="ln4378">    {</a>
<a name="ln4379">        corpse-&gt;quantity = ispec.qty;</a>
<a name="ln4380">        init_perishable_stack(*corpse);</a>
<a name="ln4381">    }</a>
<a name="ln4382"> </a>
<a name="ln4383">    return corpse-&gt;index();</a>
<a name="ln4384">}</a>
<a name="ln4385"> </a>
<a name="ln4386">static bool _apply_item_props(item_def &amp;item, const item_spec &amp;spec,</a>
<a name="ln4387">                              bool allow_useless, bool monster)</a>
<a name="ln4388">{</a>
<a name="ln4389">    const CrawlHashTable props = spec.props;</a>
<a name="ln4390"> </a>
<a name="ln4391">    if (props.exists(&quot;build_themed_book&quot;))</a>
<a name="ln4392">    {</a>
<a name="ln4393">        string owner = props[RANDBK_OWNER_KEY].get_string();</a>
<a name="ln4394">        if (owner == &quot;player&quot;)</a>
<a name="ln4395">            owner = you.your_name;</a>
<a name="ln4396">        const string title = props[RANDBK_TITLE_KEY].get_string();</a>
<a name="ln4397"> </a>
<a name="ln4398">        vector&lt;spell_type&gt; spells;</a>
<a name="ln4399">        CrawlVector spell_list = props[RANDBK_SPELLS_KEY].get_vector();</a>
<a name="ln4400">        for (unsigned int i = 0; i &lt; spell_list.size(); ++i)</a>
<a name="ln4401">            spells.push_back((spell_type) spell_list[i].get_int());</a>
<a name="ln4402"> </a>
<a name="ln4403">        spschool disc1 = (spschool)props[RANDBK_DISC1_KEY].get_short();</a>
<a name="ln4404">        spschool disc2 = (spschool)props[RANDBK_DISC2_KEY].get_short();</a>
<a name="ln4405">        if (disc1 == spschool::none &amp;&amp; disc2 == spschool::none)</a>
<a name="ln4406">        {</a>
<a name="ln4407">            if (spells.size())</a>
<a name="ln4408">                disc1 = matching_book_theme(spells);</a>
<a name="ln4409">            else</a>
<a name="ln4410">                disc1 = random_book_theme();</a>
<a name="ln4411">            disc2 = random_book_theme();</a>
<a name="ln4412">        } else if (disc2 == spschool::none)</a>
<a name="ln4413">            disc2 = disc1;</a>
<a name="ln4414">        else</a>
<a name="ln4415">            ASSERT(disc1 != spschool::none); // mapdef should've handled this</a>
<a name="ln4416"> </a>
<a name="ln4417">        int num_spells = props[RANDBK_NSPELLS_KEY].get_short();</a>
<a name="ln4418">        if (num_spells &lt; 1)</a>
<a name="ln4419">            num_spells = theme_book_size();</a>
<a name="ln4420">        const int max_levels = props[RANDBK_SLVLS_KEY].get_short();</a>
<a name="ln4421"> </a>
<a name="ln4422">        vector&lt;spell_type&gt; chosen_spells;</a>
<a name="ln4423">        theme_book_spells(disc1, disc2,</a>
<a name="ln4424">                          forced_spell_filter(spells,</a>
<a name="ln4425">                                               capped_spell_filter(max_levels)),</a>
<a name="ln4426">                          origin_as_god_gift(item), num_spells, chosen_spells);</a>
<a name="ln4427">        fixup_randbook_disciplines(disc1, disc2, chosen_spells);</a>
<a name="ln4428">        init_book_theme_randart(item, chosen_spells);</a>
<a name="ln4429">        name_book_theme_randart(item, disc1, disc2, owner, title);</a>
<a name="ln4430">        // XXX: changing the signature of build_themed_book()'s get_discipline</a>
<a name="ln4431">        // would allow us to roll much of this ^ into that. possibly clever</a>
<a name="ln4432">        // lambdas could let us do it without even changing the signature?</a>
<a name="ln4433">    }</a>
<a name="ln4434"> </a>
<a name="ln4435">    // Wipe item origin to remove &quot;this is a god gift!&quot; from there,</a>
<a name="ln4436">    // unless we're dealing with a corpse.</a>
<a name="ln4437">    if (!spec.corpselike())</a>
<a name="ln4438">        origin_reset(item);</a>
<a name="ln4439">    if (is_stackable_item(item) &amp;&amp; spec.qty &gt; 0)</a>
<a name="ln4440">        item.quantity = spec.qty;</a>
<a name="ln4441"> </a>
<a name="ln4442">    if (spec.item_special)</a>
<a name="ln4443">        item.special = spec.item_special;</a>
<a name="ln4444"> </a>
<a name="ln4445">    if (spec.plus &gt;= 0 &amp;&amp; item.is_type(OBJ_BOOKS, BOOK_MANUAL))</a>
<a name="ln4446">    {</a>
<a name="ln4447">        item.plus = spec.plus;</a>
<a name="ln4448">        item_colour(item);</a>
<a name="ln4449">    }</a>
<a name="ln4450"> </a>
<a name="ln4451">    if (item.base_type == OBJ_RUNES)</a>
<a name="ln4452">    {</a>
<a name="ln4453">        if (you.runes[item.sub_type])</a>
<a name="ln4454">        {</a>
<a name="ln4455">            destroy_item(item, true);</a>
<a name="ln4456">            return false;</a>
<a name="ln4457">        }</a>
<a name="ln4458">        item_colour(item);</a>
<a name="ln4459">    }</a>
<a name="ln4460"> </a>
<a name="ln4461">    if (props.exists(&quot;cursed&quot;))</a>
<a name="ln4462">        do_curse_item(item);</a>
<a name="ln4463">    else if (props.exists(&quot;uncursed&quot;))</a>
<a name="ln4464">        do_uncurse_item(item);</a>
<a name="ln4465">    if (props.exists(&quot;useful&quot;) &amp;&amp; is_useless_item(item, false)</a>
<a name="ln4466">        &amp;&amp; !allow_useless)</a>
<a name="ln4467">    {</a>
<a name="ln4468">        destroy_item(item, true);</a>
<a name="ln4469">        return false;</a>
<a name="ln4470">    }</a>
<a name="ln4471">    if (item.base_type == OBJ_WANDS &amp;&amp; props.exists(&quot;charges&quot;))</a>
<a name="ln4472">        item.charges = props[&quot;charges&quot;].get_int();</a>
<a name="ln4473">    if ((item.base_type == OBJ_WEAPONS || item.base_type == OBJ_ARMOUR</a>
<a name="ln4474">         || item.base_type == OBJ_JEWELLERY || item.base_type == OBJ_MISSILES)</a>
<a name="ln4475">        &amp;&amp; props.exists(&quot;plus&quot;) &amp;&amp; !is_unrandom_artefact(item))</a>
<a name="ln4476">    {</a>
<a name="ln4477">        item.plus = props[&quot;plus&quot;].get_int();</a>
<a name="ln4478">        item_set_appearance(item);</a>
<a name="ln4479">    }</a>
<a name="ln4480">    if (props.exists(&quot;ident&quot;))</a>
<a name="ln4481">        item.flags |= props[&quot;ident&quot;].get_int();</a>
<a name="ln4482">    if (props.exists(&quot;unobtainable&quot;))</a>
<a name="ln4483">        item.flags |= ISFLAG_UNOBTAINABLE;</a>
<a name="ln4484"> </a>
<a name="ln4485">    if (props.exists(&quot;no_pickup&quot;))</a>
<a name="ln4486">        item.flags |= ISFLAG_NO_PICKUP;</a>
<a name="ln4487"> </a>
<a name="ln4488">    if (props.exists(&quot;item_tile_name&quot;))</a>
<a name="ln4489">        item.props[&quot;item_tile_name&quot;] = props[&quot;item_tile_name&quot;].get_string();</a>
<a name="ln4490">    if (props.exists(&quot;worn_tile_name&quot;))</a>
<a name="ln4491">        item.props[&quot;worn_tile_name&quot;] = props[&quot;worn_tile_name&quot;].get_string();</a>
<a name="ln4492">    bind_item_tile(item);</a>
<a name="ln4493"> </a>
<a name="ln4494">    if (!monster)</a>
<a name="ln4495">    {</a>
<a name="ln4496">        if (props.exists(&quot;mimic&quot;))</a>
<a name="ln4497">        {</a>
<a name="ln4498">            const int chance = props[&quot;mimic&quot;];</a>
<a name="ln4499">            if (chance &gt; 0 &amp;&amp; one_chance_in(chance))</a>
<a name="ln4500">                item.flags |= ISFLAG_MIMIC;</a>
<a name="ln4501">        }</a>
<a name="ln4502">    }</a>
<a name="ln4503"> </a>
<a name="ln4504">    return true;</a>
<a name="ln4505">}</a>
<a name="ln4506"> </a>
<a name="ln4507">static object_class_type _superb_object_class()</a>
<a name="ln4508">{</a>
<a name="ln4509">    return random_choose_weighted(</a>
<a name="ln4510">            20, OBJ_WEAPONS,</a>
<a name="ln4511">            10, OBJ_ARMOUR,</a>
<a name="ln4512">            10, OBJ_JEWELLERY,</a>
<a name="ln4513">            10, OBJ_BOOKS,</a>
<a name="ln4514">            10, OBJ_STAVES,</a>
<a name="ln4515">            10, OBJ_MISCELLANY);</a>
<a name="ln4516">}</a>
<a name="ln4517"> </a>
<a name="ln4518">int dgn_place_item(const item_spec &amp;spec,</a>
<a name="ln4519">                   const coord_def &amp;where,</a>
<a name="ln4520">                   int level)</a>
<a name="ln4521">{</a>
<a name="ln4522">    // Dummy object?</a>
<a name="ln4523">    if (spec.base_type == OBJ_UNASSIGNED)</a>
<a name="ln4524">        return NON_ITEM;</a>
<a name="ln4525"> </a>
<a name="ln4526">    if (level == INVALID_ABSDEPTH)</a>
<a name="ln4527">        level = env.absdepth0;</a>
<a name="ln4528"> </a>
<a name="ln4529">    object_class_type base_type = spec.base_type;</a>
<a name="ln4530">    bool acquire = false;</a>
<a name="ln4531"> </a>
<a name="ln4532">    if (spec.level &gt;= 0)</a>
<a name="ln4533">        level = spec.level;</a>
<a name="ln4534">    else</a>
<a name="ln4535">    {</a>
<a name="ln4536">        bool adjust_type = false;</a>
<a name="ln4537">        switch (spec.level)</a>
<a name="ln4538">        {</a>
<a name="ln4539">        case ISPEC_DAMAGED:</a>
<a name="ln4540">        case ISPEC_BAD:</a>
<a name="ln4541">        case ISPEC_RANDART:</a>
<a name="ln4542">            level = spec.level;</a>
<a name="ln4543">            break;</a>
<a name="ln4544">        case ISPEC_STAR:</a>
<a name="ln4545">            level = 5 + level * 2;</a>
<a name="ln4546">            break;</a>
<a name="ln4547">        case ISPEC_SUPERB:</a>
<a name="ln4548">            adjust_type = true;</a>
<a name="ln4549">            level = ISPEC_GOOD_ITEM;</a>
<a name="ln4550">            break;</a>
<a name="ln4551">        case ISPEC_ACQUIREMENT:</a>
<a name="ln4552">            adjust_type = true;</a>
<a name="ln4553">            acquire = true;</a>
<a name="ln4554">            break;</a>
<a name="ln4555">        default:</a>
<a name="ln4556">            break;</a>
<a name="ln4557">        }</a>
<a name="ln4558"> </a>
<a name="ln4559">        if (spec.props.exists(&quot;mimic&quot;) &amp;&amp; base_type == OBJ_RANDOM)</a>
<a name="ln4560">            base_type = get_random_item_mimic_type();</a>
<a name="ln4561">        else if (adjust_type &amp;&amp; base_type == OBJ_RANDOM)</a>
<a name="ln4562">        {</a>
<a name="ln4563">            base_type = acquire ? _acquirement_object_class()</a>
<a name="ln4564">                                : _superb_object_class();</a>
<a name="ln4565">        }</a>
<a name="ln4566">    }</a>
<a name="ln4567"> </a>
<a name="ln4568">    int useless_tries = 0;</a>
<a name="ln4569"> </a>
<a name="ln4570">    while (true)</a>
<a name="ln4571">    {</a>
<a name="ln4572">        int item_made = NON_ITEM;</a>
<a name="ln4573"> </a>
<a name="ln4574">        if (acquire)</a>
<a name="ln4575">        {</a>
<a name="ln4576">            item_made = acquirement_create_item(base_type,</a>
<a name="ln4577">                                                spec.acquirement_source,</a>
<a name="ln4578">                                                true, where);</a>
<a name="ln4579">        }</a>
<a name="ln4580"> </a>
<a name="ln4581">        // Both normal item generation and the failed &quot;acquire foo&quot; fallback.</a>
<a name="ln4582">        if (item_made == NON_ITEM)</a>
<a name="ln4583">        {</a>
<a name="ln4584">            if (spec.corpselike())</a>
<a name="ln4585">                item_made = _dgn_item_corpse(spec, where);</a>
<a name="ln4586">            else</a>
<a name="ln4587">            {</a>
<a name="ln4588">                item_made = items(spec.allow_uniques, base_type,</a>
<a name="ln4589">                                  spec.sub_type, level, spec.ego);</a>
<a name="ln4590"> </a>
<a name="ln4591">                if (spec.level == ISPEC_MUNDANE)</a>
<a name="ln4592">                    squash_plusses(item_made);</a>
<a name="ln4593">            }</a>
<a name="ln4594">        }</a>
<a name="ln4595"> </a>
<a name="ln4596">        if (item_made == NON_ITEM || item_made == -1)</a>
<a name="ln4597">            return NON_ITEM;</a>
<a name="ln4598">        else</a>
<a name="ln4599">        {</a>
<a name="ln4600">            item_def &amp;item(mitm[item_made]);</a>
<a name="ln4601">            item.pos = where;</a>
<a name="ln4602"> </a>
<a name="ln4603">            if (_apply_item_props(item, spec, (useless_tries &gt;= 10), false))</a>
<a name="ln4604">            {</a>
<a name="ln4605">                dprf(DIAG_DNGN, &quot;vault spec: placing %s at %d,%d&quot;,</a>
<a name="ln4606">                    mitm[item_made].name(DESC_PLAIN, false, true).c_str(),</a>
<a name="ln4607">                    where.x, where.y);</a>
<a name="ln4608">                env.level_map_mask(where) |= MMT_NO_TRAP;</a>
<a name="ln4609">                return item_made;</a>
<a name="ln4610">            }</a>
<a name="ln4611">            else</a>
<a name="ln4612">            {</a>
<a name="ln4613">                // _apply_item_props will not generate a rune you already have,</a>
<a name="ln4614">                // so don't bother looping.</a>
<a name="ln4615">                if (base_type == OBJ_RUNES)</a>
<a name="ln4616">                    return NON_ITEM;</a>
<a name="ln4617">                useless_tries++;</a>
<a name="ln4618">            }</a>
<a name="ln4619">        }</a>
<a name="ln4620"> </a>
<a name="ln4621">    }</a>
<a name="ln4622"> </a>
<a name="ln4623">}</a>
<a name="ln4624"> </a>
<a name="ln4625">void dgn_place_multiple_items(item_list &amp;list, const coord_def&amp; where)</a>
<a name="ln4626">{</a>
<a name="ln4627">    const int size = list.size();</a>
<a name="ln4628">    for (int i = 0; i &lt; size; ++i)</a>
<a name="ln4629">        dgn_place_item(list.get_item(i), where);</a>
<a name="ln4630">}</a>
<a name="ln4631"> </a>
<a name="ln4632">static void _dgn_place_item_explicit(int index, const coord_def&amp; where,</a>
<a name="ln4633">                                     vault_placement &amp;place)</a>
<a name="ln4634">{</a>
<a name="ln4635">    item_list &amp;sitems = place.map.items;</a>
<a name="ln4636"> </a>
<a name="ln4637">    if ((index &lt; 0 || index &gt;= static_cast&lt;int&gt;(sitems.size())) &amp;&amp;</a>
<a name="ln4638">        !crawl_state.game_is_sprint())</a>
<a name="ln4639">    {</a>
<a name="ln4640">        return;</a>
<a name="ln4641">    }</a>
<a name="ln4642"> </a>
<a name="ln4643">    const item_spec spec = sitems.get_item(index);</a>
<a name="ln4644">    dgn_place_item(spec, where);</a>
<a name="ln4645">}</a>
<a name="ln4646"> </a>
<a name="ln4647">static void _dgn_give_mon_spec_items(mons_spec &amp;mspec, monster *mon)</a>
<a name="ln4648">{</a>
<a name="ln4649">    ASSERT(mspec.place.is_valid());</a>
<a name="ln4650"> </a>
<a name="ln4651">    unwind_var&lt;int&gt; save_speedinc(mon-&gt;speed_increment);</a>
<a name="ln4652"> </a>
<a name="ln4653">    // Get rid of existing equipment.</a>
<a name="ln4654">    for (mon_inv_iterator ii(*mon); ii; ++ii)</a>
<a name="ln4655">    {</a>
<a name="ln4656">        mon-&gt;unequip(*ii, false, true);</a>
<a name="ln4657">        destroy_item(ii-&gt;index(), true);</a>
<a name="ln4658">    }</a>
<a name="ln4659"> </a>
<a name="ln4660">    item_list &amp;list = mspec.items;</a>
<a name="ln4661"> </a>
<a name="ln4662">    const int size = list.size();</a>
<a name="ln4663">    for (int i = 0; i &lt; size; ++i)</a>
<a name="ln4664">    {</a>
<a name="ln4665">        item_spec spec = list.get_item(i);</a>
<a name="ln4666"> </a>
<a name="ln4667">        if (spec.base_type == OBJ_UNASSIGNED)</a>
<a name="ln4668">            continue;</a>
<a name="ln4669"> </a>
<a name="ln4670">        // Don't give monster a randart, and don't randomly give</a>
<a name="ln4671">        // monster an ego item.</a>
<a name="ln4672">        if (spec.base_type == OBJ_ARMOUR || spec.base_type == OBJ_WEAPONS</a>
<a name="ln4673">            || spec.base_type == OBJ_MISSILES)</a>
<a name="ln4674">        {</a>
<a name="ln4675">            spec.allow_uniques = 0;</a>
<a name="ln4676">            if (spec.ego == 0)</a>
<a name="ln4677">                spec.ego = SP_FORBID_EGO;</a>
<a name="ln4678">        }</a>
<a name="ln4679"> </a>
<a name="ln4680">        int item_level = mspec.place.absdepth();</a>
<a name="ln4681"> </a>
<a name="ln4682">        if (spec.level &gt;= 0)</a>
<a name="ln4683">            item_level = spec.level;</a>
<a name="ln4684">        else</a>
<a name="ln4685">        {</a>
<a name="ln4686">            // TODO: merge this with the equivalent switch in dgn_place_item,</a>
<a name="ln4687">            // and maybe even handle ISPEC_ACQUIREMENT.</a>
<a name="ln4688">            switch (spec.level)</a>
<a name="ln4689">            {</a>
<a name="ln4690">            case ISPEC_STAR:</a>
<a name="ln4691">                item_level = 5 + item_level * 2;</a>
<a name="ln4692">                break;</a>
<a name="ln4693">            case ISPEC_SUPERB:</a>
<a name="ln4694">                item_level = ISPEC_GOOD_ITEM;</a>
<a name="ln4695">                break;</a>
<a name="ln4696">            case ISPEC_DAMAGED:</a>
<a name="ln4697">            case ISPEC_BAD:</a>
<a name="ln4698">            case ISPEC_RANDART:</a>
<a name="ln4699">                item_level = spec.level;</a>
<a name="ln4700">                break;</a>
<a name="ln4701">            }</a>
<a name="ln4702">        }</a>
<a name="ln4703"> </a>
<a name="ln4704">        for (int useless_tries = 0; true; useless_tries++)</a>
<a name="ln4705">        {</a>
<a name="ln4706">            int item_made;</a>
<a name="ln4707"> </a>
<a name="ln4708">            if (spec.corpselike())</a>
<a name="ln4709">                item_made = _dgn_item_corpse(spec, mon-&gt;pos());</a>
<a name="ln4710">            else</a>
<a name="ln4711">            {</a>
<a name="ln4712">                item_made = items(spec.allow_uniques, spec.base_type,</a>
<a name="ln4713">                                  spec.sub_type, item_level,</a>
<a name="ln4714">                                  spec.ego);</a>
<a name="ln4715"> </a>
<a name="ln4716">                if (spec.level == ISPEC_MUNDANE)</a>
<a name="ln4717">                    squash_plusses(item_made);</a>
<a name="ln4718">            }</a>
<a name="ln4719"> </a>
<a name="ln4720">            if (!(item_made == NON_ITEM || item_made == -1))</a>
<a name="ln4721">            {</a>
<a name="ln4722">                item_def &amp;item(mitm[item_made]);</a>
<a name="ln4723"> </a>
<a name="ln4724">                if (_apply_item_props(item, spec, (useless_tries &gt;= 10), true))</a>
<a name="ln4725">                {</a>
<a name="ln4726">                    // Mark items on summoned monsters as such.</a>
<a name="ln4727">                    if (mspec.abjuration_duration != 0)</a>
<a name="ln4728">                        item.flags |= ISFLAG_SUMMONED;</a>
<a name="ln4729"> </a>
<a name="ln4730">                    if (!mon-&gt;pickup_item(item, false, true))</a>
<a name="ln4731">                        destroy_item(item_made, true);</a>
<a name="ln4732">                    break;</a>
<a name="ln4733">                }</a>
<a name="ln4734">            }</a>
<a name="ln4735">        }</a>
<a name="ln4736">    }</a>
<a name="ln4737"> </a>
<a name="ln4738">    // Pre-wield ranged weapons.</a>
<a name="ln4739">    if (mon-&gt;inv[MSLOT_WEAPON] == NON_ITEM</a>
<a name="ln4740">        &amp;&amp; mon-&gt;inv[MSLOT_ALT_WEAPON] != NON_ITEM)</a>
<a name="ln4741">    {</a>
<a name="ln4742">        mon-&gt;swap_weapons(MB_FALSE);</a>
<a name="ln4743">    }</a>
<a name="ln4744">}</a>
<a name="ln4745"> </a>
<a name="ln4746">static bool _monster_type_is_already_spawned_unique(monster_type type)</a>
<a name="ln4747">{</a>
<a name="ln4748">    return mons_is_unique(type) &amp;&amp; you.unique_creatures[type];</a>
<a name="ln4749">}</a>
<a name="ln4750"> </a>
<a name="ln4751">static bool _unique_conflicts_with_younger_or_older_version(monster_type type)</a>
<a name="ln4752">{</a>
<a name="ln4753">    if (type == MONS_MAGGIE</a>
<a name="ln4754">       &amp;&amp; _monster_type_is_already_spawned_unique(MONS_MARGERY))</a>
<a name="ln4755">    {</a>
<a name="ln4756">        return true;</a>
<a name="ln4757">    }</a>
<a name="ln4758">    else if (type == MONS_MARGERY</a>
<a name="ln4759">       &amp;&amp; _monster_type_is_already_spawned_unique(MONS_MAGGIE))</a>
<a name="ln4760">        return true;</a>
<a name="ln4761"> </a>
<a name="ln4762">    return false;</a>
<a name="ln4763">}</a>
<a name="ln4764"> </a>
<a name="ln4765">static bool _should_veto_unique(monster_type type)</a>
<a name="ln4766">{</a>
<a name="ln4767">    return _monster_type_is_already_spawned_unique(type)</a>
<a name="ln4768">           || _unique_conflicts_with_younger_or_older_version(type);</a>
<a name="ln4769">}</a>
<a name="ln4770"> </a>
<a name="ln4771">monster* dgn_place_monster(mons_spec &amp;mspec, coord_def where,</a>
<a name="ln4772">                           bool force_pos, bool generate_awake, bool patrolling)</a>
<a name="ln4773">{</a>
<a name="ln4774">#if TAG_MAJOR_VERSION == 34</a>
<a name="ln4775">    if ((int)mspec.type == -1) // or rebuild the des cache</a>
<a name="ln4776">        return 0;</a>
<a name="ln4777">#endif</a>
<a name="ln4778">    if (mspec.type == MONS_NO_MONSTER)</a>
<a name="ln4779">        return 0;</a>
<a name="ln4780"> </a>
<a name="ln4781">    monster_type type = mspec.type;</a>
<a name="ln4782">    const bool m_generate_awake = (generate_awake || mspec.generate_awake);</a>
<a name="ln4783">    const bool m_patrolling     = (patrolling || mspec.patrolling);</a>
<a name="ln4784">    const bool m_band           = mspec.band;</a>
<a name="ln4785"> </a>
<a name="ln4786">    if (!mspec.place.is_valid())</a>
<a name="ln4787">        mspec.place = level_id::current();</a>
<a name="ln4788">    bool chose_ood = false;</a>
<a name="ln4789">    const int starting_depth = mspec.place.depth;</a>
<a name="ln4790"> </a>
<a name="ln4791">    if (type == RANDOM_SUPER_OOD || type == RANDOM_MODERATE_OOD)</a>
<a name="ln4792">    {</a>
<a name="ln4793">        if (brdepth[mspec.place.branch] &lt;= 1)</a>
<a name="ln4794">            ; // no OODs here</a>
<a name="ln4795">        else if (type == RANDOM_SUPER_OOD)</a>
<a name="ln4796">            mspec.place.depth += 4 + mspec.place.depth;</a>
<a name="ln4797">        else if (type == RANDOM_MODERATE_OOD)</a>
<a name="ln4798">            mspec.place.depth += 5;</a>
<a name="ln4799">        type = RANDOM_MONSTER;</a>
<a name="ln4800">    }</a>
<a name="ln4801"> </a>
<a name="ln4802">    if (type &lt; NUM_MONSTERS)</a>
<a name="ln4803">    {</a>
<a name="ln4804">        // Don't place a unique monster a second time.</a>
<a name="ln4805">        // (Boris is handled specially.)</a>
<a name="ln4806">        if (_should_veto_unique(type)</a>
<a name="ln4807">            &amp;&amp; !crawl_state.game_is_arena())</a>
<a name="ln4808">        {</a>
<a name="ln4809">            return 0;</a>
<a name="ln4810">        }</a>
<a name="ln4811"> </a>
<a name="ln4812">        const monster_type montype = mons_class_is_zombified(type)</a>
<a name="ln4813">                                                         ? mspec.monbase</a>
<a name="ln4814">                                                         : type;</a>
<a name="ln4815"> </a>
<a name="ln4816">        const habitat_type habitat = mons_class_primary_habitat(montype);</a>
<a name="ln4817"> </a>
<a name="ln4818">        if (in_bounds(where) &amp;&amp; !monster_habitable_grid(montype, grd(where)))</a>
<a name="ln4819">            dungeon_terrain_changed(where, habitat2grid(habitat));</a>
<a name="ln4820">    }</a>
<a name="ln4821"> </a>
<a name="ln4822">    if (type == RANDOM_MONSTER)</a>
<a name="ln4823">    {</a>
<a name="ln4824">        if (mons_class_is_zombified(mspec.monbase))</a>
<a name="ln4825">            type = pick_local_zombifiable_monster(mspec.place, mspec.monbase, coord_def());</a>
<a name="ln4826">        else</a>
<a name="ln4827">        {</a>
<a name="ln4828">            level_id place = mspec.place;</a>
<a name="ln4829">            type = pick_random_monster(mspec.place, mspec.monbase, &amp;place);</a>
<a name="ln4830">            if (place.depth &gt; starting_depth + 5)</a>
<a name="ln4831">                chose_ood = true;</a>
<a name="ln4832">        }</a>
<a name="ln4833">        if (!type)</a>
<a name="ln4834">            type = RANDOM_MONSTER;</a>
<a name="ln4835">    }</a>
<a name="ln4836"> </a>
<a name="ln4837">    mgen_data mg(type);</a>
<a name="ln4838"> </a>
<a name="ln4839">    mg.behaviour = (m_generate_awake) ? BEH_WANDER : BEH_SLEEP;</a>
<a name="ln4840">    switch (mspec.attitude)</a>
<a name="ln4841">    {</a>
<a name="ln4842">    case ATT_FRIENDLY:</a>
<a name="ln4843">        mg.behaviour = BEH_FRIENDLY;</a>
<a name="ln4844">        break;</a>
<a name="ln4845">    case ATT_NEUTRAL:</a>
<a name="ln4846">        mg.behaviour = BEH_NEUTRAL;</a>
<a name="ln4847">        break;</a>
<a name="ln4848">    case ATT_GOOD_NEUTRAL:</a>
<a name="ln4849">        mg.behaviour = BEH_GOOD_NEUTRAL;</a>
<a name="ln4850">        break;</a>
<a name="ln4851">    case ATT_STRICT_NEUTRAL:</a>
<a name="ln4852">        mg.behaviour = BEH_STRICT_NEUTRAL;</a>
<a name="ln4853">        break;</a>
<a name="ln4854">    default:</a>
<a name="ln4855">        break;</a>
<a name="ln4856">    }</a>
<a name="ln4857">    mg.base_type = mspec.monbase;</a>
<a name="ln4858">    mg.colour    = mspec.colour;</a>
<a name="ln4859"> </a>
<a name="ln4860">    if (mspec.god != GOD_NO_GOD)</a>
<a name="ln4861">        mg.god   = mspec.god;</a>
<a name="ln4862"> </a>
<a name="ln4863">    mg.mname     = mspec.monname;</a>
<a name="ln4864">    mg.hd        = mspec.hd;</a>
<a name="ln4865">    mg.hp        = mspec.hp;</a>
<a name="ln4866">    mg.props     = mspec.props;</a>
<a name="ln4867"> </a>
<a name="ln4868">    if (mg.props.exists(MAP_KEY))</a>
<a name="ln4869">        mg.xp_tracking = XP_VAULT;</a>
<a name="ln4870"> </a>
<a name="ln4871">    // Marking monsters as summoned</a>
<a name="ln4872">    mg.abjuration_duration = mspec.abjuration_duration;</a>
<a name="ln4873">    mg.summon_type         = mspec.summon_type;</a>
<a name="ln4874">    mg.non_actor_summoner  = mspec.non_actor_summoner;</a>
<a name="ln4875"> </a>
<a name="ln4876">    if (mg.colour == COLOUR_UNDEF)</a>
<a name="ln4877">        mg.colour = random_monster_colour();</a>
<a name="ln4878"> </a>
<a name="ln4879">    if (!force_pos &amp;&amp; actor_at(where)</a>
<a name="ln4880">        &amp;&amp; (mg.cls &lt; NUM_MONSTERS || needs_resolution(mg.cls)))</a>
<a name="ln4881">    {</a>
<a name="ln4882">        const monster_type habitat_target =</a>
<a name="ln4883">            mg.cls == RANDOM_MONSTER ? MONS_BAT : mg.cls;</a>
<a name="ln4884">        where = find_newmons_square_contiguous(habitat_target, where, 0);</a>
<a name="ln4885">    }</a>
<a name="ln4886"> </a>
<a name="ln4887">    mg.pos = where;</a>
<a name="ln4888"> </a>
<a name="ln4889">    if (mons_class_is_zombified(mg.base_type))</a>
<a name="ln4890">    {</a>
<a name="ln4891">        if (mons_class_is_zombified(mg.cls))</a>
<a name="ln4892">            mg.base_type = MONS_NO_MONSTER;</a>
<a name="ln4893">        else</a>
<a name="ln4894">            swap(mg.base_type, mg.cls);</a>
<a name="ln4895">    }</a>
<a name="ln4896"> </a>
<a name="ln4897">    if (m_patrolling)</a>
<a name="ln4898">        mg.flags |= MG_PATROLLING;</a>
<a name="ln4899"> </a>
<a name="ln4900">    if (m_band)</a>
<a name="ln4901">        mg.flags |= MG_PERMIT_BANDS;</a>
<a name="ln4902"> </a>
<a name="ln4903">    // Store any extra flags here.</a>
<a name="ln4904">    mg.extra_flags |= mspec.extra_monster_flags;</a>
<a name="ln4905"> </a>
<a name="ln4906">    monster *mons = place_monster(mg, true, force_pos &amp;&amp; where.origin());</a>
<a name="ln4907">    if (!mons)</a>
<a name="ln4908">        return 0;</a>
<a name="ln4909"> </a>
<a name="ln4910">    // Spells before items, so e.g. simulacrum casters can be given chunks.</a>
<a name="ln4911">    // add custom spell prop for spell display</a>
<a name="ln4912">    // XXX limited to the actual spellbook, won't display all</a>
<a name="ln4913">    // spellbooks available for vault monsters</a>
<a name="ln4914">    if (mspec.explicit_spells)</a>
<a name="ln4915">    {</a>
<a name="ln4916">        mons-&gt;spells = mspec.spells[random2(mspec.spells.size())];</a>
<a name="ln4917">        mons-&gt;props[CUSTOM_SPELLS_KEY] = true;</a>
<a name="ln4918">    }</a>
<a name="ln4919"> </a>
<a name="ln4920">    // this prop is mainly for the seed explorer.</a>
<a name="ln4921">    // not a great or complete measure of monster danger: the builder can roll</a>
<a name="ln4922">    // on the low side of the ood range, and vaults don't get this set.</a>
<a name="ln4923">    if (chose_ood)</a>
<a name="ln4924">        mons-&gt;props[MON_OOD_KEY].get_bool() = true;</a>
<a name="ln4925"> </a>
<a name="ln4926">    if (!mspec.items.empty())</a>
<a name="ln4927">        _dgn_give_mon_spec_items(mspec, mons);</a>
<a name="ln4928"> </a>
<a name="ln4929">    if (mspec.props.exists(&quot;monster_tile&quot;))</a>
<a name="ln4930">    {</a>
<a name="ln4931">        mons-&gt;props[&quot;monster_tile&quot;] =</a>
<a name="ln4932">            mspec.props[&quot;monster_tile&quot;].get_short();</a>
<a name="ln4933">    }</a>
<a name="ln4934">    if (mspec.props.exists(&quot;monster_tile_name&quot;))</a>
<a name="ln4935">    {</a>
<a name="ln4936">        mons-&gt;props[&quot;monster_tile_name&quot;].get_string() =</a>
<a name="ln4937">            mspec.props[&quot;monster_tile_name&quot;].get_string();</a>
<a name="ln4938">    }</a>
<a name="ln4939"> </a>
<a name="ln4940">    if (mspec.props.exists(&quot;always_corpse&quot;))</a>
<a name="ln4941">        mons-&gt;props[&quot;always_corpse&quot;] = true;</a>
<a name="ln4942"> </a>
<a name="ln4943">    if (mspec.props.exists(NEVER_CORPSE_KEY))</a>
<a name="ln4944">        mons-&gt;props[NEVER_CORPSE_KEY] = true;</a>
<a name="ln4945"> </a>
<a name="ln4946">    if (mspec.props.exists(&quot;dbname&quot;))</a>
<a name="ln4947">        mons-&gt;props[&quot;dbname&quot;].get_string() = mspec.props[&quot;dbname&quot;].get_string();</a>
<a name="ln4948"> </a>
<a name="ln4949">    // These are applied earlier to prevent issues with renamed monsters</a>
<a name="ln4950">    // and &quot;&lt;monster&gt; comes into view&quot; (see delay.cc:_monster_warning).</a>
<a name="ln4951">    //mons-&gt;flags |= mspec.extra_monster_flags;</a>
<a name="ln4952"> </a>
<a name="ln4953">    // Monsters with gods set by the spec aren't god gifts</a>
<a name="ln4954">    // unless they have the &quot;god_gift&quot; tag. place_monster(),</a>
<a name="ln4955">    // by default, marks any monsters with gods as god gifts,</a>
<a name="ln4956">    // so unmark them here.</a>
<a name="ln4957">    if (mspec.god != GOD_NO_GOD &amp;&amp; !mspec.god_gift)</a>
<a name="ln4958">        mons-&gt;flags &amp;= ~MF_GOD_GIFT;</a>
<a name="ln4959"> </a>
<a name="ln4960">    if (mons-&gt;is_priest() &amp;&amp; mons-&gt;god == GOD_NO_GOD)</a>
<a name="ln4961">        mons-&gt;god = GOD_NAMELESS;</a>
<a name="ln4962"> </a>
<a name="ln4963">    if (mons_class_is_animated_weapon(mons-&gt;type))</a>
<a name="ln4964">    {</a>
<a name="ln4965">        item_def *wpn = mons-&gt;mslot_item(MSLOT_WEAPON);</a>
<a name="ln4966">        ASSERT(wpn);</a>
<a name="ln4967">        if (mons-&gt;type == MONS_DANCING_WEAPON)</a>
<a name="ln4968">            mons-&gt;ghost-&gt;init_dancing_weapon(*wpn, 100);</a>
<a name="ln4969">        else if (mons-&gt;type == MONS_SPECTRAL_WEAPON)</a>
<a name="ln4970">            mons-&gt;ghost-&gt;init_spectral_weapon(*wpn, 100);</a>
<a name="ln4971">        mons-&gt;ghost_demon_init();</a>
<a name="ln4972">    }</a>
<a name="ln4973"> </a>
<a name="ln4974">    for (const mon_enchant &amp;ench : mspec.ench)</a>
<a name="ln4975">        mons-&gt;add_ench(ench);</a>
<a name="ln4976"> </a>
<a name="ln4977">    return mons;</a>
<a name="ln4978">}</a>
<a name="ln4979"> </a>
<a name="ln4980">static bool _dgn_place_monster(const vault_placement &amp;place, mons_spec &amp;mspec,</a>
<a name="ln4981">                               const coord_def&amp; where)</a>
<a name="ln4982">{</a>
<a name="ln4983">    const bool generate_awake</a>
<a name="ln4984">        = mspec.generate_awake || place.map.has_tag(&quot;generate_awake&quot;);</a>
<a name="ln4985"> </a>
<a name="ln4986">    const bool patrolling</a>
<a name="ln4987">        = mspec.patrolling || place.map.has_tag(&quot;patrolling&quot;);</a>
<a name="ln4988"> </a>
<a name="ln4989">    mspec.props[MAP_KEY].get_string() = place.map_name_at(where);</a>
<a name="ln4990">    return dgn_place_monster(mspec, where, false, generate_awake, patrolling);</a>
<a name="ln4991">}</a>
<a name="ln4992"> </a>
<a name="ln4993">static bool _dgn_place_one_monster(const vault_placement &amp;place,</a>
<a name="ln4994">                                   mons_list &amp;mons, const coord_def&amp; where)</a>
<a name="ln4995">{</a>
<a name="ln4996">    for (int i = 0, size = mons.size(); i &lt; size; ++i)</a>
<a name="ln4997">    {</a>
<a name="ln4998">        mons_spec spec = mons.get_monster(i);</a>
<a name="ln4999">        if (_dgn_place_monster(place, spec, where))</a>
<a name="ln5000">            return true;</a>
<a name="ln5001">    }</a>
<a name="ln5002">    return false;</a>
<a name="ln5003">}</a>
<a name="ln5004"> </a>
<a name="ln5005">/* &quot;Oddball grids&quot; are handled in _vault_grid. */</a>
<a name="ln5006">static dungeon_feature_type _glyph_to_feat(int glyph)</a>
<a name="ln5007">{</a>
<a name="ln5008">    return (glyph == 'x') ? DNGN_ROCK_WALL :</a>
<a name="ln5009">           (glyph == 'X') ? DNGN_PERMAROCK_WALL :</a>
<a name="ln5010">           (glyph == 'c') ? DNGN_STONE_WALL :</a>
<a name="ln5011">           (glyph == 'v') ? DNGN_METAL_WALL :</a>
<a name="ln5012">           (glyph == 'b') ? DNGN_CRYSTAL_WALL :</a>
<a name="ln5013">           (glyph == 'm') ? DNGN_CLEAR_ROCK_WALL :</a>
<a name="ln5014">           (glyph == 'n') ? DNGN_CLEAR_STONE_WALL :</a>
<a name="ln5015">           (glyph == 'o') ? DNGN_CLEAR_PERMAROCK_WALL :</a>
<a name="ln5016">           (glyph == 't') ? DNGN_TREE :</a>
<a name="ln5017">           (glyph == '+') ? DNGN_CLOSED_DOOR :</a>
<a name="ln5018">           (glyph == '=') ? DNGN_RUNED_CLEAR_DOOR :</a>
<a name="ln5019">           (glyph == 'w') ? DNGN_DEEP_WATER :</a>
<a name="ln5020">           (glyph == 'W') ? DNGN_SHALLOW_WATER :</a>
<a name="ln5021">           (glyph == 'l') ? DNGN_LAVA :</a>
<a name="ln5022">           (glyph == '&gt;') ? DNGN_ESCAPE_HATCH_DOWN :</a>
<a name="ln5023">           (glyph == '&lt;') ? DNGN_ESCAPE_HATCH_UP :</a>
<a name="ln5024">           (glyph == '}') ? DNGN_STONE_STAIRS_DOWN_I :</a>
<a name="ln5025">           (glyph == '{') ? DNGN_STONE_STAIRS_UP_I :</a>
<a name="ln5026">           (glyph == ')') ? DNGN_STONE_STAIRS_DOWN_II :</a>
<a name="ln5027">           (glyph == '(') ? DNGN_STONE_STAIRS_UP_II :</a>
<a name="ln5028">           (glyph == ']') ? DNGN_STONE_STAIRS_DOWN_III :</a>
<a name="ln5029">           (glyph == '[') ? DNGN_STONE_STAIRS_UP_III :</a>
<a name="ln5030">           (glyph == 'A') ? DNGN_STONE_ARCH :</a>
<a name="ln5031">           (glyph == 'C') ? _pick_an_altar() :   // f(x) elsewhere {dlb}</a>
<a name="ln5032">           (glyph == 'I') ? DNGN_ORCISH_IDOL :</a>
<a name="ln5033">           (glyph == 'G') ? DNGN_GRANITE_STATUE :</a>
<a name="ln5034">           (glyph == 'T') ? DNGN_FOUNTAIN_BLUE :</a>
<a name="ln5035">           (glyph == 'U') ? DNGN_FOUNTAIN_SPARKLING :</a>
<a name="ln5036">           (glyph == 'V') ? DNGN_DRY_FOUNTAIN :</a>
<a name="ln5037">           (glyph == 'Y') ? DNGN_FOUNTAIN_BLOOD :</a>
<a name="ln5038">           (glyph == '\0')? DNGN_ROCK_WALL</a>
<a name="ln5039">                          : DNGN_FLOOR; // includes everything else</a>
<a name="ln5040">}</a>
<a name="ln5041"> </a>
<a name="ln5042">dungeon_feature_type map_feature_at(map_def *map, const coord_def &amp;c,</a>
<a name="ln5043">                                    int rawfeat)</a>
<a name="ln5044">{</a>
<a name="ln5045">    if (rawfeat == -1)</a>
<a name="ln5046">        rawfeat = map-&gt;glyph_at(c);</a>
<a name="ln5047"> </a>
<a name="ln5048">    if (rawfeat == ' ')</a>
<a name="ln5049">        return NUM_FEATURES;</a>
<a name="ln5050"> </a>
<a name="ln5051">    keyed_mapspec *mapsp = map? map-&gt;mapspec_at(c) : nullptr;</a>
<a name="ln5052">    if (mapsp)</a>
<a name="ln5053">    {</a>
<a name="ln5054">        feature_spec f = mapsp-&gt;get_feat();</a>
<a name="ln5055">        if (f.trap)</a>
<a name="ln5056">        {</a>
<a name="ln5057">            if (f.trap-&gt;tr_type &gt;= NUM_TRAPS)</a>
<a name="ln5058">                return DNGN_FLOOR;</a>
<a name="ln5059">            else</a>
<a name="ln5060">                return trap_feature(f.trap-&gt;tr_type);</a>
<a name="ln5061">        }</a>
<a name="ln5062">        else if (f.feat &gt;= 0)</a>
<a name="ln5063">            return static_cast&lt;dungeon_feature_type&gt;(f.feat);</a>
<a name="ln5064">        else if (f.glyph &gt;= 0)</a>
<a name="ln5065">            return map_feature_at(nullptr, c, f.glyph);</a>
<a name="ln5066">        else if (f.shop)</a>
<a name="ln5067">            return DNGN_ENTER_SHOP;</a>
<a name="ln5068"> </a>
<a name="ln5069">        return DNGN_FLOOR;</a>
<a name="ln5070">    }</a>
<a name="ln5071"> </a>
<a name="ln5072">    return _glyph_to_feat(rawfeat);</a>
<a name="ln5073">}</a>
<a name="ln5074"> </a>
<a name="ln5075">static void _vault_grid_mapspec(vault_placement &amp;place, const coord_def &amp;where,</a>
<a name="ln5076">                                keyed_mapspec&amp; mapsp)</a>
<a name="ln5077">{</a>
<a name="ln5078">    const feature_spec f = mapsp.get_feat();</a>
<a name="ln5079">    if (f.trap)</a>
<a name="ln5080">        _place_specific_trap(where, f.trap.get(), 0);</a>
<a name="ln5081">    else if (f.feat &gt;= 0)</a>
<a name="ln5082">        grd(where) = static_cast&lt;dungeon_feature_type&gt;(f.feat);</a>
<a name="ln5083">    else if (f.glyph &gt;= 0)</a>
<a name="ln5084">        _vault_grid_glyph(place, where, f.glyph);</a>
<a name="ln5085">    else if (f.shop)</a>
<a name="ln5086">        place_spec_shop(where, *f.shop);</a>
<a name="ln5087">    else</a>
<a name="ln5088">        grd(where) = DNGN_FLOOR;</a>
<a name="ln5089"> </a>
<a name="ln5090">    if (f.mimic &gt; 0 &amp;&amp; one_chance_in(f.mimic))</a>
<a name="ln5091">    {</a>
<a name="ln5092">        ASSERT(feat_is_mimicable(grd(where), false));</a>
<a name="ln5093">        env.level_map_mask(where) |= MMT_MIMIC;</a>
<a name="ln5094">    }</a>
<a name="ln5095">    else if (f.no_mimic)</a>
<a name="ln5096">        env.level_map_mask(where) |= MMT_NO_MIMIC;</a>
<a name="ln5097"> </a>
<a name="ln5098">    item_list &amp;items = mapsp.get_items();</a>
<a name="ln5099">    dgn_place_multiple_items(items, where);</a>
<a name="ln5100">}</a>
<a name="ln5101"> </a>
<a name="ln5102">static void _vault_grid_glyph(vault_placement &amp;place, const coord_def&amp; where,</a>
<a name="ln5103">                              int vgrid)</a>
<a name="ln5104">{</a>
<a name="ln5105">    // First, set base tile for grids {dlb}:</a>
<a name="ln5106">    if (vgrid != -1)</a>
<a name="ln5107">        grd(where) = _glyph_to_feat(vgrid);</a>
<a name="ln5108"> </a>
<a name="ln5109">    if (feat_is_altar(grd(where))</a>
<a name="ln5110">        &amp;&amp; is_unavailable_god(feat_altar_god(grd(where))))</a>
<a name="ln5111">    {</a>
<a name="ln5112">        grd(where) = DNGN_FLOOR;</a>
<a name="ln5113">    }</a>
<a name="ln5114"> </a>
<a name="ln5115">    // then, handle oddball grids {dlb}:</a>
<a name="ln5116">    switch (vgrid)</a>
<a name="ln5117">    {</a>
<a name="ln5118">    case '@':</a>
<a name="ln5119">    case '=':</a>
<a name="ln5120">    case '+':</a>
<a name="ln5121">        if (_map_feat_is_on_edge(place, where))</a>
<a name="ln5122">            place.exits.push_back(where);</a>
<a name="ln5123">        break;</a>
<a name="ln5124">    case '^':</a>
<a name="ln5125">        place_specific_trap(where, TRAP_RANDOM);</a>
<a name="ln5126">        break;</a>
<a name="ln5127">    case '~':</a>
<a name="ln5128">        place_specific_trap(where, random_vault_trap());</a>
<a name="ln5129">        break;</a>
<a name="ln5130">    case 'B':</a>
<a name="ln5131">        grd(where) = _pick_temple_altar();</a>
<a name="ln5132">        break;</a>
<a name="ln5133">    }</a>
<a name="ln5134"> </a>
<a name="ln5135">    // Then, handle grids that place &quot;stuff&quot; {dlb}:</a>
<a name="ln5136">    if (vgrid == '$' || vgrid == '%' || vgrid == '*' || vgrid == '|')</a>
<a name="ln5137">    {</a>
<a name="ln5138">        int item_made = NON_ITEM;</a>
<a name="ln5139">        object_class_type which_class = OBJ_RANDOM;</a>
<a name="ln5140">        uint8_t which_type = OBJ_RANDOM;</a>
<a name="ln5141">        int which_depth = env.absdepth0;</a>
<a name="ln5142"> </a>
<a name="ln5143">        if (vgrid == '$')</a>
<a name="ln5144">            which_class = OBJ_GOLD;</a>
<a name="ln5145">        else if (vgrid == '|')</a>
<a name="ln5146">        {</a>
<a name="ln5147">            which_class = _superb_object_class();</a>
<a name="ln5148">            which_depth = ISPEC_GOOD_ITEM;</a>
<a name="ln5149">        }</a>
<a name="ln5150">        else if (vgrid == '*')</a>
<a name="ln5151">            which_depth = 5 + which_depth * 2;</a>
<a name="ln5152"> </a>
<a name="ln5153">        item_made = items(true, which_class, which_type, which_depth);</a>
<a name="ln5154">        if (item_made != NON_ITEM)</a>
<a name="ln5155">        {</a>
<a name="ln5156">            mitm[item_made].pos = where;</a>
<a name="ln5157">            env.level_map_mask(where) |= MMT_NO_TRAP;</a>
<a name="ln5158">            dprf(DIAG_DNGN, &quot;vault grid: placing %s at %d,%d&quot;,</a>
<a name="ln5159">                mitm[item_made].name(DESC_PLAIN, false, true).c_str(),</a>
<a name="ln5160">                mitm[item_made].pos.x, mitm[item_made].pos.y);</a>
<a name="ln5161">        }</a>
<a name="ln5162">    }</a>
<a name="ln5163"> </a>
<a name="ln5164">    // defghijk - items</a>
<a name="ln5165">    if (map_def::valid_item_array_glyph(vgrid))</a>
<a name="ln5166">    {</a>
<a name="ln5167">        int slot = map_def::item_array_glyph_to_slot(vgrid);</a>
<a name="ln5168">        _dgn_place_item_explicit(slot, where, place);</a>
<a name="ln5169">    }</a>
<a name="ln5170">}</a>
<a name="ln5171"> </a>
<a name="ln5172">static void _vault_grid(vault_placement &amp;place,</a>
<a name="ln5173">                        int vgrid,</a>
<a name="ln5174">                        const coord_def&amp; where,</a>
<a name="ln5175">                        keyed_mapspec *mapsp)</a>
<a name="ln5176">{</a>
<a name="ln5177">    if (mapsp &amp;&amp; mapsp-&gt;replaces_glyph())</a>
<a name="ln5178">        _vault_grid_mapspec(place, where, *mapsp);</a>
<a name="ln5179">    else</a>
<a name="ln5180">        _vault_grid_glyph(place, where, vgrid);</a>
<a name="ln5181"> </a>
<a name="ln5182">    if (cell_is_solid(where))</a>
<a name="ln5183">        delete_cloud(where);</a>
<a name="ln5184">}</a>
<a name="ln5185"> </a>
<a name="ln5186">static void _vault_grid_glyph_mons(vault_placement &amp;place,</a>
<a name="ln5187">                                   const coord_def &amp;where,</a>
<a name="ln5188">                                   int vgrid)</a>
<a name="ln5189">{</a>
<a name="ln5190">    // Handle grids that place monsters {dlb}:</a>
<a name="ln5191">    if (map_def::valid_monster_glyph(vgrid))</a>
<a name="ln5192">    {</a>
<a name="ln5193">        mons_spec ms(RANDOM_MONSTER);</a>
<a name="ln5194"> </a>
<a name="ln5195">        if (vgrid == '8')</a>
<a name="ln5196">            ms.type = RANDOM_SUPER_OOD;</a>
<a name="ln5197">        else if (vgrid == '9')</a>
<a name="ln5198">            ms.type = RANDOM_MODERATE_OOD;</a>
<a name="ln5199">        else if (vgrid != '0')</a>
<a name="ln5200">        {</a>
<a name="ln5201">            int slot = map_def::monster_array_glyph_to_slot(vgrid);</a>
<a name="ln5202">            ms = place.map.mons.get_monster(slot);</a>
<a name="ln5203">            monster_type mt = ms.type;</a>
<a name="ln5204">            // Is a map for a specific place trying to place a unique which</a>
<a name="ln5205">            // somehow already got created?</a>
<a name="ln5206">            if (!place.map.place.empty()</a>
<a name="ln5207">                &amp;&amp; !invalid_monster_type(mt)</a>
<a name="ln5208">                &amp;&amp; mons_is_unique(mt)</a>
<a name="ln5209">                &amp;&amp; you.unique_creatures[mt])</a>
<a name="ln5210">            {</a>
<a name="ln5211">                mprf(MSGCH_ERROR, &quot;ERROR: %s already generated somewhere &quot;</a>
<a name="ln5212">                     &quot;else; please file a bug report.&quot;,</a>
<a name="ln5213">                     mons_type_name(mt, DESC_THE).c_str());</a>
<a name="ln5214">                // Force it to be generated anyway.</a>
<a name="ln5215">                you.unique_creatures.set(mt, false);</a>
<a name="ln5216">            }</a>
<a name="ln5217">        }</a>
<a name="ln5218"> </a>
<a name="ln5219">        _dgn_place_monster(place, ms, where);</a>
<a name="ln5220">    }</a>
<a name="ln5221">}</a>
<a name="ln5222"> </a>
<a name="ln5223">static void _vault_grid_mapspec_mons(vault_placement &amp;place,</a>
<a name="ln5224">                                     const coord_def &amp;where,</a>
<a name="ln5225">                                     keyed_mapspec&amp; mapsp)</a>
<a name="ln5226">{</a>
<a name="ln5227">    const feature_spec f = mapsp.get_feat();</a>
<a name="ln5228">    if (f.glyph &gt;= 0)</a>
<a name="ln5229">        _vault_grid_glyph_mons(place, where, f.glyph);</a>
<a name="ln5230">    mons_list &amp;mons = mapsp.get_monsters();</a>
<a name="ln5231">    _dgn_place_one_monster(place, mons, where);</a>
<a name="ln5232">}</a>
<a name="ln5233"> </a>
<a name="ln5234">static void _vault_grid_mons(vault_placement &amp;place,</a>
<a name="ln5235">                        int vgrid,</a>
<a name="ln5236">                        const coord_def&amp; where,</a>
<a name="ln5237">                        keyed_mapspec *mapsp)</a>
<a name="ln5238">{</a>
<a name="ln5239">    if (mapsp &amp;&amp; mapsp-&gt;replaces_glyph())</a>
<a name="ln5240">        _vault_grid_mapspec_mons(place, where, *mapsp);</a>
<a name="ln5241">    else</a>
<a name="ln5242">        _vault_grid_glyph_mons(place, where, vgrid);</a>
<a name="ln5243">}</a>
<a name="ln5244"> </a>
<a name="ln5245">// Only used for Slime:$ where it will turn the stone walls into floor once the</a>
<a name="ln5246">// Royal Jelly has been killed, or at 6* Jiyva piety.</a>
<a name="ln5247">bool seen_destroy_feat(dungeon_feature_type old_feat)</a>
<a name="ln5248">{</a>
<a name="ln5249">    coord_def p1(0, 0);</a>
<a name="ln5250">    coord_def p2(GXM - 1, GYM - 1);</a>
<a name="ln5251"> </a>
<a name="ln5252">    bool seen = false;</a>
<a name="ln5253">    for (rectangle_iterator ri(p1, p2); ri; ++ri)</a>
<a name="ln5254">    {</a>
<a name="ln5255">        if (orig_terrain(*ri) == old_feat)</a>
<a name="ln5256">        {</a>
<a name="ln5257">            destroy_wall(*ri);</a>
<a name="ln5258">            if (you.see_cell(*ri))</a>
<a name="ln5259">                seen = true;</a>
<a name="ln5260">        }</a>
<a name="ln5261">    }</a>
<a name="ln5262"> </a>
<a name="ln5263">    return seen;</a>
<a name="ln5264">}</a>
<a name="ln5265"> </a>
<a name="ln5266">void dgn_replace_area(int sx, int sy, int ex, int ey,</a>
<a name="ln5267">                      dungeon_feature_type replace,</a>
<a name="ln5268">                      dungeon_feature_type feature,</a>
<a name="ln5269">                      unsigned mmask, bool needs_update)</a>
<a name="ln5270">{</a>
<a name="ln5271">    dgn_replace_area(coord_def(sx, sy), coord_def(ex, ey),</a>
<a name="ln5272">                      replace, feature, mmask, needs_update);</a>
<a name="ln5273">}</a>
<a name="ln5274"> </a>
<a name="ln5275">void dgn_replace_area(const coord_def&amp; p1, const coord_def&amp; p2,</a>
<a name="ln5276">                       dungeon_feature_type replace,</a>
<a name="ln5277">                       dungeon_feature_type feature, uint32_t mapmask,</a>
<a name="ln5278">                       bool needs_update)</a>
<a name="ln5279">{</a>
<a name="ln5280">    for (rectangle_iterator ri(p1, p2); ri; ++ri)</a>
<a name="ln5281">    {</a>
<a name="ln5282">        if (grd(*ri) == replace &amp;&amp; !map_masked(*ri, mapmask))</a>
<a name="ln5283">        {</a>
<a name="ln5284">            grd(*ri) = feature;</a>
<a name="ln5285">            if (needs_update &amp;&amp; env.map_knowledge(*ri).seen())</a>
<a name="ln5286">            {</a>
<a name="ln5287">                env.map_knowledge(*ri).set_feature(feature, 0,</a>
<a name="ln5288">                                                   get_trap_type(*ri));</a>
<a name="ln5289">#ifdef USE_TILE</a>
<a name="ln5290">                env.tile_bk_bg(*ri) = feature;</a>
<a name="ln5291">#endif</a>
<a name="ln5292">            }</a>
<a name="ln5293">        }</a>
<a name="ln5294">    }</a>
<a name="ln5295">}</a>
<a name="ln5296"> </a>
<a name="ln5297">bool map_masked(const coord_def &amp;c, unsigned mask)</a>
<a name="ln5298">{</a>
<a name="ln5299">    return mask &amp;&amp; (env.level_map_mask(c) &amp; mask);</a>
<a name="ln5300">}</a>
<a name="ln5301"> </a>
<a name="ln5302">struct coord_comparator</a>
<a name="ln5303">{</a>
<a name="ln5304">    coord_def target;</a>
<a name="ln5305">    coord_comparator(const coord_def &amp;t) : target(t) { }</a>
<a name="ln5306"> </a>
<a name="ln5307">    static int dist(const coord_def &amp;a, const coord_def &amp;b)</a>
<a name="ln5308">    {</a>
<a name="ln5309">        const coord_def del = a - b;</a>
<a name="ln5310">        return abs(del.x) + abs(del.y);</a>
<a name="ln5311">    }</a>
<a name="ln5312"> </a>
<a name="ln5313">    bool operator () (const coord_def &amp;a, const coord_def &amp;b) const</a>
<a name="ln5314">    {</a>
<a name="ln5315">        return dist(a, target) &lt; dist(b, target);</a>
<a name="ln5316">    }</a>
<a name="ln5317">};</a>
<a name="ln5318"> </a>
<a name="ln5319">typedef set&lt;coord_def, coord_comparator&gt; coord_set;</a>
<a name="ln5320"> </a>
<a name="ln5321">static void _jtd_init_surrounds(coord_set &amp;coords, uint32_t mapmask,</a>
<a name="ln5322">                                const coord_def &amp;c)</a>
<a name="ln5323">{</a>
<a name="ln5324">    vector&lt;coord_def&gt; cur;</a>
<a name="ln5325">    for (orth_adjacent_iterator ai(c); ai; ++ai)</a>
<a name="ln5326">    {</a>
<a name="ln5327">        if (!in_bounds(*ai) || travel_point_distance[ai-&gt;x][ai-&gt;y]</a>
<a name="ln5328">            || map_masked(*ai, mapmask))</a>
<a name="ln5329">        {</a>
<a name="ln5330">            continue;</a>
<a name="ln5331">        }</a>
<a name="ln5332">        cur.insert(cur.begin() + random2(cur.size()), *ai);</a>
<a name="ln5333">    }</a>
<a name="ln5334">    for (auto cc : cur)</a>
<a name="ln5335">    {</a>
<a name="ln5336">        coords.insert(cc);</a>
<a name="ln5337"> </a>
<a name="ln5338">        const coord_def dp = cc - c;</a>
<a name="ln5339">        travel_point_distance[cc.x][cc.y] = (-dp.x + 2) * 4 + (-dp.y + 2);</a>
<a name="ln5340">    }</a>
<a name="ln5341">}</a>
<a name="ln5342"> </a>
<a name="ln5343">// Resets travel_point_distance</a>
<a name="ln5344">vector&lt;coord_def&gt; dgn_join_the_dots_pathfind(const coord_def &amp;from,</a>
<a name="ln5345">                                             const coord_def &amp;to,</a>
<a name="ln5346">                                             uint32_t mapmask)</a>
<a name="ln5347">{</a>
<a name="ln5348">    memset(travel_point_distance, 0, sizeof(travel_distance_grid_t));</a>
<a name="ln5349">    const coord_comparator comp(to);</a>
<a name="ln5350">    coord_set coords(comp);</a>
<a name="ln5351"> </a>
<a name="ln5352">    vector&lt;coord_def&gt; path;</a>
<a name="ln5353">    coord_def curr = from;</a>
<a name="ln5354">    while (true)</a>
<a name="ln5355">    {</a>
<a name="ln5356">        int &amp;tpd = travel_point_distance[curr.x][curr.y];</a>
<a name="ln5357">        tpd = !tpd? -1000 : -tpd;</a>
<a name="ln5358"> </a>
<a name="ln5359">        if (curr == to)</a>
<a name="ln5360">            break;</a>
<a name="ln5361"> </a>
<a name="ln5362">        _jtd_init_surrounds(coords, mapmask, curr);</a>
<a name="ln5363"> </a>
<a name="ln5364">        if (coords.empty())</a>
<a name="ln5365">            break;</a>
<a name="ln5366"> </a>
<a name="ln5367">        curr = *coords.begin();</a>
<a name="ln5368">        coords.erase(coords.begin());</a>
<a name="ln5369">    }</a>
<a name="ln5370"> </a>
<a name="ln5371">    if (curr != to)</a>
<a name="ln5372">        return path;</a>
<a name="ln5373"> </a>
<a name="ln5374">    while (curr != from)</a>
<a name="ln5375">    {</a>
<a name="ln5376">        if (!map_masked(curr, mapmask))</a>
<a name="ln5377">            path.push_back(curr);</a>
<a name="ln5378"> </a>
<a name="ln5379">        const int dist = travel_point_distance[curr.x][curr.y];</a>
<a name="ln5380">        ASSERT(dist &lt; 0);</a>
<a name="ln5381">        ASSERT(dist != -1000);</a>
<a name="ln5382">        curr += coord_def(-dist / 4 - 2, (-dist % 4) - 2);</a>
<a name="ln5383">    }</a>
<a name="ln5384">    if (!map_masked(curr, mapmask))</a>
<a name="ln5385">        path.push_back(curr);</a>
<a name="ln5386"> </a>
<a name="ln5387">    return path;</a>
<a name="ln5388">}</a>
<a name="ln5389"> </a>
<a name="ln5390">bool join_the_dots(const coord_def &amp;from, const coord_def &amp;to,</a>
<a name="ln5391">                   uint32_t mapmask,</a>
<a name="ln5392">                   bool (*overwriteable)(dungeon_feature_type))</a>
<a name="ln5393">{</a>
<a name="ln5394">    if (!overwriteable)</a>
<a name="ln5395">        overwriteable = _feat_is_wall_floor_liquid;</a>
<a name="ln5396"> </a>
<a name="ln5397">    const vector&lt;coord_def&gt; path =</a>
<a name="ln5398">        dgn_join_the_dots_pathfind(from, to, mapmask);</a>
<a name="ln5399"> </a>
<a name="ln5400">    for (auto c : path)</a>
<a name="ln5401">    {</a>
<a name="ln5402">        auto feat = grd(c);</a>
<a name="ln5403">        if (!map_masked(c, mapmask) &amp;&amp; overwriteable(feat))</a>
<a name="ln5404">        {</a>
<a name="ln5405">            grd(c) = DNGN_FLOOR;</a>
<a name="ln5406">            dgn_height_set_at(c);</a>
<a name="ln5407">        }</a>
<a name="ln5408">        else</a>
<a name="ln5409">        {</a>
<a name="ln5410">            dprf(DIAG_DNGN, &quot;Failed to path through %s at (%d;%d) for connectivity&quot;,</a>
<a name="ln5411">                 get_feature_def(feat).name, c.x, c.y);</a>
<a name="ln5412">        }</a>
<a name="ln5413">    }</a>
<a name="ln5414"> </a>
<a name="ln5415">    return !path.empty() || from == to;</a>
<a name="ln5416">}</a>
<a name="ln5417"> </a>
<a name="ln5418">static dungeon_feature_type _pick_temple_altar()</a>
<a name="ln5419">{</a>
<a name="ln5420">    if (_temple_altar_list.empty())</a>
<a name="ln5421">    {</a>
<a name="ln5422">        if (_current_temple_hash != nullptr)</a>
<a name="ln5423">        {</a>
<a name="ln5424">            // Altar god doesn't matter, setting up the whole machinery would</a>
<a name="ln5425">            // be too much work.</a>
<a name="ln5426">            if (crawl_state.map_stat_gen || crawl_state.obj_stat_gen)</a>
<a name="ln5427">                return DNGN_ALTAR_XOM;</a>
<a name="ln5428"> </a>
<a name="ln5429">            mprf(MSGCH_ERROR, &quot;Ran out of altars for temple!&quot;);</a>
<a name="ln5430">            return DNGN_FLOOR;</a>
<a name="ln5431">        }</a>
<a name="ln5432">        // Randomized altar list for mini-temples.</a>
<a name="ln5433">        _temple_altar_list = temple_god_list();</a>
<a name="ln5434">        shuffle_array(_temple_altar_list);</a>
<a name="ln5435">    }</a>
<a name="ln5436"> </a>
<a name="ln5437">    const god_type god = _temple_altar_list.back();</a>
<a name="ln5438"> </a>
<a name="ln5439">    _temple_altar_list.pop_back();</a>
<a name="ln5440"> </a>
<a name="ln5441">    return altar_for_god(god);</a>
<a name="ln5442">}</a>
<a name="ln5443"> </a>
<a name="ln5444">//jmf: Generate altar based on where you are, or possibly randomly.</a>
<a name="ln5445">static dungeon_feature_type _pick_an_altar()</a>
<a name="ln5446">{</a>
<a name="ln5447">    god_type god;</a>
<a name="ln5448"> </a>
<a name="ln5449">    // No extra altars in Temple.</a>
<a name="ln5450">    if (player_in_branch(BRANCH_TEMPLE))</a>
<a name="ln5451">        god = GOD_NO_GOD;</a>
<a name="ln5452"> </a>
<a name="ln5453">    // Xom can turn up anywhere</a>
<a name="ln5454">    else if (one_chance_in(27))</a>
<a name="ln5455">        god = GOD_XOM;</a>
<a name="ln5456">    else</a>
<a name="ln5457">    {</a>
<a name="ln5458">        switch (you.where_are_you)</a>
<a name="ln5459">        {</a>
<a name="ln5460">        case BRANCH_CRYPT:</a>
<a name="ln5461">            god = random_choose(GOD_KIKUBAAQUDGHA, GOD_YREDELEMNUL);</a>
<a name="ln5462">            break;</a>
<a name="ln5463"> </a>
<a name="ln5464">        case BRANCH_ORC: // There are a few heretics</a>
<a name="ln5465">            if (one_chance_in(5))</a>
<a name="ln5466">                god = random_choose(GOD_TROG, GOD_MAKHLEB, GOD_VEHUMET);</a>
<a name="ln5467">            else</a>
<a name="ln5468">                god = GOD_BEOGH;</a>
<a name="ln5469">            break;</a>
<a name="ln5470"> </a>
<a name="ln5471">        case BRANCH_ELF: // magic gods</a>
<a name="ln5472">            god = random_choose(GOD_VEHUMET, GOD_SIF_MUNA, GOD_KIKUBAAQUDGHA);</a>
<a name="ln5473">            break;</a>
<a name="ln5474"> </a>
<a name="ln5475">        case BRANCH_SLIME:</a>
<a name="ln5476">            god = GOD_JIYVA;</a>
<a name="ln5477">            break;</a>
<a name="ln5478"> </a>
<a name="ln5479">        case BRANCH_TOMB:</a>
<a name="ln5480">            god = GOD_KIKUBAAQUDGHA;</a>
<a name="ln5481">            break;</a>
<a name="ln5482"> </a>
<a name="ln5483">        case BRANCH_VESTIBULE:</a>
<a name="ln5484">        case BRANCH_DIS:</a>
<a name="ln5485">        case BRANCH_GEHENNA:</a>
<a name="ln5486">        case BRANCH_COCYTUS:</a>
<a name="ln5487">        case BRANCH_TARTARUS:</a>
<a name="ln5488">        case BRANCH_PANDEMONIUM: // particularly destructive / elemental gods</a>
<a name="ln5489">            if (one_chance_in(3))</a>
<a name="ln5490">            {</a>
<a name="ln5491">                god = random_choose(GOD_KIKUBAAQUDGHA, GOD_NEMELEX_XOBEH,</a>
<a name="ln5492">                                    GOD_QAZLAL, GOD_VEHUMET);</a>
<a name="ln5493">            }</a>
<a name="ln5494">            else</a>
<a name="ln5495">                god = GOD_MAKHLEB;</a>
<a name="ln5496">            break;</a>
<a name="ln5497"> </a>
<a name="ln5498">        default: // Any god (with exceptions).</a>
<a name="ln5499">            do</a>
<a name="ln5500">            {</a>
<a name="ln5501">                god = random_god();</a>
<a name="ln5502">            }</a>
<a name="ln5503">            while (god == GOD_LUGONU || god == GOD_BEOGH || god == GOD_JIYVA);</a>
<a name="ln5504">            break;</a>
<a name="ln5505">        }</a>
<a name="ln5506">    }</a>
<a name="ln5507"> </a>
<a name="ln5508">    if (is_unavailable_god(god))</a>
<a name="ln5509">        god = GOD_NO_GOD;</a>
<a name="ln5510"> </a>
<a name="ln5511">    return altar_for_god(god);</a>
<a name="ln5512">}</a>
<a name="ln5513"> </a>
<a name="ln5514">static bool _shop_sells_antiques(shop_type type)</a>
<a name="ln5515">{</a>
<a name="ln5516">    return type == SHOP_WEAPON_ANTIQUE</a>
<a name="ln5517">            || type == SHOP_ARMOUR_ANTIQUE</a>
<a name="ln5518">            || type == SHOP_GENERAL_ANTIQUE;</a>
<a name="ln5519">}</a>
<a name="ln5520"> </a>
<a name="ln5521">void place_spec_shop(const coord_def&amp; where, shop_type force_type)</a>
<a name="ln5522">{</a>
<a name="ln5523">    shop_spec spec(force_type);</a>
<a name="ln5524">    place_spec_shop(where, spec);</a>
<a name="ln5525">}</a>
<a name="ln5526"> </a>
<a name="ln5527">int greed_for_shop_type(shop_type shop, int level_number)</a>
<a name="ln5528">{</a>
<a name="ln5529">    if (shop == SHOP_FOOD)</a>
<a name="ln5530">        return 10 + random2(5);</a>
<a name="ln5531">    if (_shop_sells_antiques(shop))</a>
<a name="ln5532">    {</a>
<a name="ln5533">        const int rand = random2avg(19, 2);</a>
<a name="ln5534">        return 15 + rand + random2(level_number);</a>
<a name="ln5535">    }</a>
<a name="ln5536">    const int rand = random2(5);</a>
<a name="ln5537">    return 10 + rand + random2(level_number / 2);</a>
<a name="ln5538">}</a>
<a name="ln5539"> </a>
<a name="ln5540">/**</a>
<a name="ln5541"> * How greedy should a given shop be? (Applies a multiplier to prices.)</a>
<a name="ln5542"> *</a>
<a name="ln5543"> * @param type              The type of the shop. (E.g. SHOP_FOOD.)</a>
<a name="ln5544"> * @param level_number      The depth in which the shop is placed.</a>
<a name="ln5545"> * @param spec_greed        An override for the greed, based on a vault</a>
<a name="ln5546"> *                          specification; if not -1, will override other</a>
<a name="ln5547"> *                          calculations &amp; give a debug message.</a>
<a name="ln5548"> * @return                  The greed for the shop.</a>
<a name="ln5549"> */</a>
<a name="ln5550">static int _shop_greed(shop_type type, int level_number, int spec_greed)</a>
<a name="ln5551">{</a>
<a name="ln5552">    const int base_greed = greed_for_shop_type(type, level_number);</a>
<a name="ln5553">    int adj_greed = base_greed;</a>
<a name="ln5554"> </a>
<a name="ln5555">    // Allow bargains in bazaars, prices randomly between 60% and 95%.</a>
<a name="ln5556">    if (player_in_branch(BRANCH_BAZAAR))</a>
<a name="ln5557">    {</a>
<a name="ln5558">        // divided by 20, so each is 5% of original price</a>
<a name="ln5559">        // 12-19 = 60-95%, per above</a>
<a name="ln5560">        const int factor = random2(8) + 12;</a>
<a name="ln5561"> </a>
<a name="ln5562">        dprf(DIAG_DNGN, &quot;Shop type %d: original greed = %d, factor = %d,&quot;</a>
<a name="ln5563">             &quot; discount = %d%%.&quot;,</a>
<a name="ln5564">             type, base_greed, factor, (20-factor)*5);</a>
<a name="ln5565"> </a>
<a name="ln5566">        adj_greed = factor * adj_greed / 20;</a>
<a name="ln5567">    }</a>
<a name="ln5568"> </a>
<a name="ln5569">    if (spec_greed != -1)</a>
<a name="ln5570">    {</a>
<a name="ln5571">        dprf(DIAG_DNGN, &quot;Shop spec overrides greed: %d becomes %d.&quot;,</a>
<a name="ln5572">             adj_greed, spec_greed);</a>
<a name="ln5573">        return spec_greed;</a>
<a name="ln5574">    }</a>
<a name="ln5575"> </a>
<a name="ln5576">    return adj_greed;</a>
<a name="ln5577">}</a>
<a name="ln5578"> </a>
<a name="ln5579">/**</a>
<a name="ln5580"> * How many items should be placed in a given shop?</a>
<a name="ln5581"> *</a>
<a name="ln5582"> * @param spec              A vault shop spec; may override default results.</a>
<a name="ln5583"> * @return                  The number of items the shop should be generated</a>
<a name="ln5584"> *                          to hold.</a>
<a name="ln5585"> */</a>
<a name="ln5586">static int _shop_num_items(const shop_spec &amp;spec)</a>
<a name="ln5587">{</a>
<a name="ln5588">    if (spec.num_items != -1)</a>
<a name="ln5589">    {</a>
<a name="ln5590">        dprf(DIAG_DNGN, &quot;Shop spec overrides number of items to %d.&quot;,</a>
<a name="ln5591">             spec.num_items);</a>
<a name="ln5592">        return spec.num_items;</a>
<a name="ln5593">    }</a>
<a name="ln5594"> </a>
<a name="ln5595">    if (spec.use_all &amp;&amp; !spec.items.empty())</a>
<a name="ln5596">    {</a>
<a name="ln5597">        dprf(DIAG_DNGN, &quot;Shop spec wants all items placed: %u of them.&quot;,</a>
<a name="ln5598">             (unsigned int)spec.items.size());</a>
<a name="ln5599">        return (int) spec.items.size();</a>
<a name="ln5600">    }</a>
<a name="ln5601"> </a>
<a name="ln5602">    return 5 + random2avg(12, 3);</a>
<a name="ln5603">}</a>
<a name="ln5604"> </a>
<a name="ln5605">/**</a>
<a name="ln5606"> * What 'level' should an item from the given shop type be generated at?</a>
<a name="ln5607"> *</a>
<a name="ln5608"> * @param shop_type_        The type of shop the item is to be sold from.</a>
<a name="ln5609"> * @param level_number      The depth of the level the shop is on.</a>
<a name="ln5610"> * @return                  An &quot;item level&quot; to generate an item at.</a>
<a name="ln5611"> */</a>
<a name="ln5612">static int _choose_shop_item_level(shop_type shop_type_, int level_number)</a>
<a name="ln5613">{</a>
<a name="ln5614">    const int shop_multiplier = _shop_sells_antiques(shop_type_) ? 3 : 2;</a>
<a name="ln5615">    const int base_level = level_number</a>
<a name="ln5616">                            + random2((level_number + 1) * shop_multiplier);</a>
<a name="ln5617"> </a>
<a name="ln5618">    // Make bazaar items more valuable (up to double value).</a>
<a name="ln5619">    if (!player_in_branch(BRANCH_BAZAAR))</a>
<a name="ln5620">        return base_level;</a>
<a name="ln5621"> </a>
<a name="ln5622">    const int bazaar_bonus = random2(base_level) + 1;</a>
<a name="ln5623">    return min(base_level + bazaar_bonus, level_number * 5);</a>
<a name="ln5624">}</a>
<a name="ln5625"> </a>
<a name="ln5626">/**</a>
<a name="ln5627"> * Is the given item valid for placement in the given shop?</a>
<a name="ln5628"> *</a>
<a name="ln5629"> * @param item_index    An index into mitm; may be NON_ITEM.</a>
<a name="ln5630"> * @param shop_type_    The type of shop being generated.</a>
<a name="ln5631"> * @param spec          The specification for the shop.</a>
<a name="ln5632"> * @return              Whether the item is valid.</a>
<a name="ln5633"> */</a>
<a name="ln5634">static bool _valid_item_for_shop(int item_index, shop_type shop_type_,</a>
<a name="ln5635">                                 shop_spec &amp;spec)</a>
<a name="ln5636">{</a>
<a name="ln5637">    if (item_index == NON_ITEM)</a>
<a name="ln5638">        return false;</a>
<a name="ln5639"> </a>
<a name="ln5640">    const item_def &amp;item = mitm[item_index];</a>
<a name="ln5641">    ASSERT(item.defined());</a>
<a name="ln5642"> </a>
<a name="ln5643">    // Don't generate gold in shops! This used to be possible with</a>
<a name="ln5644">    // general stores (GDL)</a>
<a name="ln5645">    if (item.base_type == OBJ_GOLD)</a>
<a name="ln5646">        return false;</a>
<a name="ln5647"> </a>
<a name="ln5648">    // Don't place missiles or food in general antique shops...</a>
<a name="ln5649">    if (shop_type_ == SHOP_GENERAL_ANTIQUE</a>
<a name="ln5650">            &amp;&amp; (item.base_type == OBJ_MISSILES</a>
<a name="ln5651">                || item.base_type == OBJ_FOOD))</a>
<a name="ln5652">    {</a>
<a name="ln5653">        // ...unless they're specified by the item spec.</a>
<a name="ln5654">        return !spec.items.empty();</a>
<a name="ln5655">    }</a>
<a name="ln5656"> </a>
<a name="ln5657">    return true;</a>
<a name="ln5658">}</a>
<a name="ln5659"> </a>
<a name="ln5660">/**</a>
<a name="ln5661"> * Attempt to make a corpse to be placed in a gozag ghoul corpse shop.</a>
<a name="ln5662"> *</a>
<a name="ln5663"> * @return  The mitm index of the corpse.</a>
<a name="ln5664"> *          If we couldn't make one, returns NON_ITEM instead.</a>
<a name="ln5665"> */</a>
<a name="ln5666">static int _make_delicious_corpse()</a>
<a name="ln5667">{</a>
<a name="ln5668">    // Choose corpses from D:&lt;XL&gt;</a>
<a name="ln5669">    const level_id lev(BRANCH_DUNGEON, you.get_experience_level());</a>
<a name="ln5670">    const monster_type mon_type = pick_local_corpsey_monster(lev);</a>
<a name="ln5671"> </a>
<a name="ln5672">    // Create corpse object.</a>
<a name="ln5673">    monster dummy;</a>
<a name="ln5674">    dummy.type = mon_type;</a>
<a name="ln5675">    define_monster(dummy);</a>
<a name="ln5676"> </a>
<a name="ln5677">    item_def* corpse = place_monster_corpse(dummy, true, true);</a>
<a name="ln5678">    if (!corpse)</a>
<a name="ln5679">        return NON_ITEM;</a>
<a name="ln5680"> </a>
<a name="ln5681">    return corpse-&gt;index();</a>
<a name="ln5682">}</a>
<a name="ln5683"> </a>
<a name="ln5684">/**</a>
<a name="ln5685"> * Create an item and place it in a shop.</a>
<a name="ln5686"> *</a>
<a name="ln5687"> * FIXME: I'm pretty sure this will go into an infinite loop if mitm is full.</a>
<a name="ln5688"> * items() uses get_mitm_slot with culling, so i think this is ok --wheals</a>
<a name="ln5689"> *</a>
<a name="ln5690"> * @param j                 The index of the item being created in the shop's</a>
<a name="ln5691"> *                          inventory.</a>
<a name="ln5692"> * @param shop_type_        The type of shop. (E.g. SHOP_FOOD.)</a>
<a name="ln5693"> * @param stocked[in,out]   An array mapping book types to the # in the shop.</a>
<a name="ln5694"> * @param spec              The specification of the shop.</a>
<a name="ln5695"> * @param shop              The shop.</a>
<a name="ln5696"> * @param shop_level        The effective depth to use for the shop.</a>
<a name="ln5697"> */</a>
<a name="ln5698">static void _stock_shop_item(int j, shop_type shop_type_,</a>
<a name="ln5699">                             int stocked[NUM_BOOKS],</a>
<a name="ln5700">                             shop_spec &amp;spec, shop_struct &amp;shop,</a>
<a name="ln5701">                             int shop_level)</a>
<a name="ln5702">{</a>
<a name="ln5703">    const int level_number = shop_level ? shop_level : env.absdepth0;</a>
<a name="ln5704">    const int item_level = _choose_shop_item_level(shop_type_, level_number);</a>
<a name="ln5705"> </a>
<a name="ln5706">    int item_index; // index into mitm (global item array)</a>
<a name="ln5707">                    // where the generated item will be stored</a>
<a name="ln5708"> </a>
<a name="ln5709">    // XXX: this scares the hell out of me. should it be a for (...1000)?</a>
<a name="ln5710">    // also, it'd be nice if it was just a function that returned an</a>
<a name="ln5711">    // item index, maybe</a>
<a name="ln5712">    while (true)</a>
<a name="ln5713">    {</a>
<a name="ln5714">        object_class_type basetype = item_in_shop(shop_type_);</a>
<a name="ln5715">        int subtype = OBJ_RANDOM;</a>
<a name="ln5716"> </a>
<a name="ln5717">        if (!spec.items.empty() &amp;&amp; !spec.use_all)</a>
<a name="ln5718">        {</a>
<a name="ln5719">            // shop spec lists a random set of items; choose one</a>
<a name="ln5720">            item_index = dgn_place_item(spec.items.random_item_weighted(),</a>
<a name="ln5721">                                        coord_def(), item_level);</a>
<a name="ln5722">        }</a>
<a name="ln5723">        else if (!spec.items.empty() &amp;&amp; spec.use_all</a>
<a name="ln5724">                 &amp;&amp; j &lt; (int)spec.items.size())</a>
<a name="ln5725">        {</a>
<a name="ln5726">            // shop lists ordered items; take the one at the right index</a>
<a name="ln5727">            item_index = dgn_place_item(spec.items.get_item(j), coord_def(),</a>
<a name="ln5728">                                        item_level);</a>
<a name="ln5729">        }</a>
<a name="ln5730">        else if (spec.gozag &amp;&amp; shop_type_ == SHOP_FOOD</a>
<a name="ln5731">                 &amp;&amp; you.species == SP_GHOUL)</a>
<a name="ln5732">        {</a>
<a name="ln5733">            item_index = _make_delicious_corpse();</a>
<a name="ln5734">        }</a>
<a name="ln5735">        else</a>
<a name="ln5736">        {</a>
<a name="ln5737">            // make an item randomly</a>
<a name="ln5738">            // gozag shop items are better</a>
<a name="ln5739">            const bool good_item = spec.gozag || one_chance_in(4);</a>
<a name="ln5740">            const int level = good_item ? ISPEC_GOOD_ITEM : item_level;</a>
<a name="ln5741">            item_index = items(true, basetype, subtype, level);</a>
<a name="ln5742">        }</a>
<a name="ln5743"> </a>
<a name="ln5744">        // Try for a better selection for bookshops.</a>
<a name="ln5745">        if (item_index != NON_ITEM &amp;&amp; shop_type_ == SHOP_BOOK)</a>
<a name="ln5746">        {</a>
<a name="ln5747">            // if this book type is already in the shop, maybe discard it</a>
<a name="ln5748">            if (!one_chance_in(stocked[mitm[item_index].sub_type] + 1))</a>
<a name="ln5749">            {</a>
<a name="ln5750">                mitm[item_index].clear();</a>
<a name="ln5751">                item_index = NON_ITEM; // try again</a>
<a name="ln5752">            }</a>
<a name="ln5753">        }</a>
<a name="ln5754"> </a>
<a name="ln5755">        if (_valid_item_for_shop(item_index, shop_type_, spec))</a>
<a name="ln5756">            break;</a>
<a name="ln5757"> </a>
<a name="ln5758">        // Reset object and try again.</a>
<a name="ln5759">        if (item_index != NON_ITEM)</a>
<a name="ln5760">            mitm[item_index].clear();</a>
<a name="ln5761">    }</a>
<a name="ln5762"> </a>
<a name="ln5763">    ASSERT(item_index != NON_ITEM);</a>
<a name="ln5764"> </a>
<a name="ln5765">    item_def item = mitm[item_index];</a>
<a name="ln5766"> </a>
<a name="ln5767">    // If this is a book, note it down in the stocked books array</a>
<a name="ln5768">    // (unless it's a randbook)</a>
<a name="ln5769">    if (shop_type_ == SHOP_BOOK &amp;&amp; !is_artefact(item))</a>
<a name="ln5770">        stocked[item.sub_type]++;</a>
<a name="ln5771"> </a>
<a name="ln5772">    // Identify the item, unless we don't do that.</a>
<a name="ln5773">    if (!_shop_sells_antiques(shop_type_))</a>
<a name="ln5774">        set_ident_flags(item, ISFLAG_IDENT_MASK);</a>
<a name="ln5775"> </a>
<a name="ln5776">    // Now move it into the shop!</a>
<a name="ln5777">    dec_mitm_item_quantity(item_index, item.quantity);</a>
<a name="ln5778">    item.pos = shop.pos;</a>
<a name="ln5779">    item.link = ITEM_IN_SHOP;</a>
<a name="ln5780">    shop.stock.push_back(item);</a>
<a name="ln5781">    dprf(DIAG_DNGN, &quot;shop spec: placing %s&quot;,</a>
<a name="ln5782">                    item.name(DESC_PLAIN, false, true).c_str());</a>
<a name="ln5783">}</a>
<a name="ln5784"> </a>
<a name="ln5785">/**</a>
<a name="ln5786"> * Attempt to place a shop in a given location.</a>
<a name="ln5787"> *</a>
<a name="ln5788"> * @param where             The location to place the shop.</a>
<a name="ln5789"> * @param spec              The details of the shop.</a>
<a name="ln5790"> *                          Would be const if not for list method nonsense.</a>
<a name="ln5791"> * @param shop_level        The effective depth to use for the shop.</a>
<a name="ln5792"> </a>
<a name="ln5793"> */</a>
<a name="ln5794">void place_spec_shop(const coord_def&amp; where, shop_spec &amp;spec, int shop_level)</a>
<a name="ln5795">{</a>
<a name="ln5796">    rng::subgenerator shop_rng; // isolate shop rolls from levelgen</a>
<a name="ln5797">    no_notes nx;</a>
<a name="ln5798"> </a>
<a name="ln5799">    shop_struct&amp; shop = env.shop[where];</a>
<a name="ln5800"> </a>
<a name="ln5801">    const int level_number = shop_level ? shop_level : env.absdepth0;</a>
<a name="ln5802"> </a>
<a name="ln5803">    for (int j = 0; j &lt; 3; j++)</a>
<a name="ln5804">        shop.keeper_name[j] = 1 + random2(200);</a>
<a name="ln5805">    shop.shop_name = spec.name;</a>
<a name="ln5806">    shop.shop_type_name = spec.type;</a>
<a name="ln5807">    shop.shop_suffix_name = spec.suffix;</a>
<a name="ln5808">    shop.level = level_number * 2;</a>
<a name="ln5809">    shop.type = spec.sh_type;</a>
<a name="ln5810">    if (shop.type == SHOP_RANDOM)</a>
<a name="ln5811">        shop.type = static_cast&lt;shop_type&gt;(random2(NUM_SHOPS));</a>
<a name="ln5812">    shop.greed = _shop_greed(shop.type, level_number, spec.greed);</a>
<a name="ln5813">    shop.pos = where;</a>
<a name="ln5814"> </a>
<a name="ln5815">    _set_grd(where, DNGN_ENTER_SHOP);</a>
<a name="ln5816"> </a>
<a name="ln5817">    const int num_items = _shop_num_items(spec);</a>
<a name="ln5818"> </a>
<a name="ln5819">    // For books shops, store how many copies of a given book are on display.</a>
<a name="ln5820">    // This increases the diversity of books in a shop.</a>
<a name="ln5821">    int stocked[NUM_BOOKS] = { 0 };</a>
<a name="ln5822"> </a>
<a name="ln5823">    shop.stock.clear();</a>
<a name="ln5824">    for (int j = 0; j &lt; num_items; j++)</a>
<a name="ln5825">        _stock_shop_item(j, shop.type, stocked, spec, shop, shop_level);</a>
<a name="ln5826">}</a>
<a name="ln5827"> </a>
<a name="ln5828">object_class_type item_in_shop(shop_type shop_type)</a>
<a name="ln5829">{</a>
<a name="ln5830">    switch (shop_type)</a>
<a name="ln5831">    {</a>
<a name="ln5832">    case SHOP_WEAPON:</a>
<a name="ln5833">        if (one_chance_in(5))</a>
<a name="ln5834">            return OBJ_MISSILES;</a>
<a name="ln5835">        // *** deliberate fall through here  {dlb} ***</a>
<a name="ln5836">    case SHOP_WEAPON_ANTIQUE:</a>
<a name="ln5837">        return OBJ_WEAPONS;</a>
<a name="ln5838"> </a>
<a name="ln5839">    case SHOP_ARMOUR:</a>
<a name="ln5840">    case SHOP_ARMOUR_ANTIQUE:</a>
<a name="ln5841">        return OBJ_ARMOUR;</a>
<a name="ln5842"> </a>
<a name="ln5843">    case SHOP_GENERAL:</a>
<a name="ln5844">    case SHOP_GENERAL_ANTIQUE:</a>
<a name="ln5845">        return OBJ_RANDOM;</a>
<a name="ln5846"> </a>
<a name="ln5847">    case SHOP_JEWELLERY:</a>
<a name="ln5848">        return OBJ_JEWELLERY;</a>
<a name="ln5849"> </a>
<a name="ln5850">    case SHOP_EVOKABLES:</a>
<a name="ln5851">        return random_choose(OBJ_WANDS, OBJ_MISCELLANY);</a>
<a name="ln5852"> </a>
<a name="ln5853">    case SHOP_BOOK:</a>
<a name="ln5854">        return OBJ_BOOKS;</a>
<a name="ln5855"> </a>
<a name="ln5856">    case SHOP_FOOD:</a>
<a name="ln5857">        return OBJ_FOOD;</a>
<a name="ln5858"> </a>
<a name="ln5859">    case SHOP_DISTILLERY:</a>
<a name="ln5860">        return OBJ_POTIONS;</a>
<a name="ln5861"> </a>
<a name="ln5862">    case SHOP_SCROLL:</a>
<a name="ln5863">        return OBJ_SCROLLS;</a>
<a name="ln5864"> </a>
<a name="ln5865">    default:</a>
<a name="ln5866">        die(&quot;unknown shop type %d&quot;, shop_type);</a>
<a name="ln5867">    }</a>
<a name="ln5868"> </a>
<a name="ln5869">    return OBJ_RANDOM;</a>
<a name="ln5870">}</a>
<a name="ln5871"> </a>
<a name="ln5872">// Keep seeds away from the borders so we don't end up with a</a>
<a name="ln5873">// straight wall.</a>
<a name="ln5874">static bool _spotty_seed_ok(const coord_def&amp; p)</a>
<a name="ln5875">{</a>
<a name="ln5876">    const int margin = 4;</a>
<a name="ln5877">    return p.x &gt;= margin &amp;&amp; p.y &gt;= margin</a>
<a name="ln5878">           &amp;&amp; p.x &lt; GXM - margin &amp;&amp; p.y &lt; GYM - margin;</a>
<a name="ln5879">}</a>
<a name="ln5880"> </a>
<a name="ln5881">static bool _feat_is_wall_floor_liquid(dungeon_feature_type feat)</a>
<a name="ln5882">{</a>
<a name="ln5883">    return feat_is_water(feat)</a>
<a name="ln5884">           || feat == DNGN_TREE</a>
<a name="ln5885">           || feat_is_lava(feat)</a>
<a name="ln5886">           || feat_is_wall(feat)</a>
<a name="ln5887">           || feat == DNGN_FLOOR;</a>
<a name="ln5888">}</a>
<a name="ln5889"> </a>
<a name="ln5890">// Connect vault exit &quot;from&quot; to dungeon floor by growing a spotty chamber.</a>
<a name="ln5891">// This tries to be like _spotty_level, but probably isn't quite.</a>
<a name="ln5892">// It might be better to aim for a more open connection -- currently</a>
<a name="ln5893">// it stops pretty much as soon as connectivity is attained.</a>
<a name="ln5894">static set&lt;coord_def&gt; _dgn_spotty_connect_path(const coord_def&amp; from,</a>
<a name="ln5895">            bool (*overwriteable)(dungeon_feature_type))</a>
<a name="ln5896">{</a>
<a name="ln5897">    set&lt;coord_def&gt; flatten;</a>
<a name="ln5898">    set&lt;coord_def&gt; border;</a>
<a name="ln5899">    bool success = false;</a>
<a name="ln5900"> </a>
<a name="ln5901">    if (!overwriteable)</a>
<a name="ln5902">        overwriteable = _feat_is_wall_floor_liquid;</a>
<a name="ln5903"> </a>
<a name="ln5904">    for (adjacent_iterator ai(from); ai; ++ai)</a>
<a name="ln5905">        if (!map_masked(*ai, MMT_VAULT) &amp;&amp; _spotty_seed_ok(*ai))</a>
<a name="ln5906">            border.insert(*ai);</a>
<a name="ln5907"> </a>
<a name="ln5908">    while (!success &amp;&amp; !border.empty())</a>
<a name="ln5909">    {</a>
<a name="ln5910">        auto it = random_iterator(border);</a>
<a name="ln5911">        coord_def cur = *it;</a>
<a name="ln5912">        border.erase(it);</a>
<a name="ln5913"> </a>
<a name="ln5914">        // Flatten orthogonal neighbours, and add new neighbours to border.</a>
<a name="ln5915">        flatten.insert(cur);</a>
<a name="ln5916">        for (orth_adjacent_iterator ai(cur); ai; ++ai)</a>
<a name="ln5917">        {</a>
<a name="ln5918">            if (map_masked(*ai, MMT_VAULT))</a>
<a name="ln5919">                continue;</a>
<a name="ln5920"> </a>
<a name="ln5921">            if (grd(*ai) == DNGN_FLOOR)</a>
<a name="ln5922">                success = true; // Through, but let's remove the others, too.</a>
<a name="ln5923"> </a>
<a name="ln5924">            if (!overwriteable(grd(*ai)) || flatten.count(*ai))</a>
<a name="ln5925">                continue;</a>
<a name="ln5926"> </a>
<a name="ln5927">            flatten.insert(*ai);</a>
<a name="ln5928">            for (adjacent_iterator bi(*ai); bi; ++bi)</a>
<a name="ln5929">            {</a>
<a name="ln5930">                if (!map_masked(*bi, MMT_VAULT)</a>
<a name="ln5931">                    &amp;&amp; _spotty_seed_ok(*bi)</a>
<a name="ln5932">                    &amp;&amp; !flatten.count(*bi))</a>
<a name="ln5933">                {</a>
<a name="ln5934">                    border.insert(*bi);</a>
<a name="ln5935">                }</a>
<a name="ln5936">            }</a>
<a name="ln5937">        }</a>
<a name="ln5938">    }</a>
<a name="ln5939"> </a>
<a name="ln5940">    if (!success)</a>
<a name="ln5941">        flatten.clear();</a>
<a name="ln5942"> </a>
<a name="ln5943">    return flatten;</a>
<a name="ln5944">}</a>
<a name="ln5945"> </a>
<a name="ln5946">static bool _connect_spotty(const coord_def&amp; from,</a>
<a name="ln5947">                            bool (*overwriteable)(dungeon_feature_type))</a>
<a name="ln5948">{</a>
<a name="ln5949">    const set&lt;coord_def&gt; spotty_path =</a>
<a name="ln5950">        _dgn_spotty_connect_path(from, overwriteable);</a>
<a name="ln5951"> </a>
<a name="ln5952">    if (!spotty_path.empty())</a>
<a name="ln5953">    {</a>
<a name="ln5954">        for (auto c : spotty_path)</a>
<a name="ln5955">        {</a>
<a name="ln5956">            grd(c) = (player_in_branch(BRANCH_SWAMP) &amp;&amp; one_chance_in(3))</a>
<a name="ln5957">                   ? DNGN_SHALLOW_WATER</a>
<a name="ln5958">                   : DNGN_FLOOR;</a>
<a name="ln5959">            dgn_height_set_at(c);</a>
<a name="ln5960">        }</a>
<a name="ln5961">    }</a>
<a name="ln5962"> </a>
<a name="ln5963">    return !spotty_path.empty();</a>
<a name="ln5964">}</a>
<a name="ln5965"> </a>
<a name="ln5966">void place_specific_trap(const coord_def&amp; where, trap_type spec_type, int charges)</a>
<a name="ln5967">{</a>
<a name="ln5968">    trap_spec spec(spec_type);</a>
<a name="ln5969"> </a>
<a name="ln5970">    _place_specific_trap(where, &amp;spec, charges);</a>
<a name="ln5971">}</a>
<a name="ln5972"> </a>
<a name="ln5973">static void _place_specific_trap(const coord_def&amp; where, trap_spec* spec,</a>
<a name="ln5974">                                 int charges)</a>
<a name="ln5975">{</a>
<a name="ln5976">    trap_type spec_type = spec-&gt;tr_type;</a>
<a name="ln5977"> </a>
<a name="ln5978">    if (spec_type == TRAP_SHAFT &amp;&amp; !is_valid_shaft_level())</a>
<a name="ln5979">    {</a>
<a name="ln5980">        mprf(MSGCH_ERROR, &quot;Vault %s tried to place a shaft at a branch end&quot;,</a>
<a name="ln5981">                env.placing_vault.c_str());</a>
<a name="ln5982">    }</a>
<a name="ln5983"> </a>
<a name="ln5984">    // find an appropriate trap for TRAP_RANDOM</a>
<a name="ln5985">    if (spec_type == TRAP_RANDOM)</a>
<a name="ln5986">    {</a>
<a name="ln5987">        do</a>
<a name="ln5988">        {</a>
<a name="ln5989">            spec_type = static_cast&lt;trap_type&gt;(random2(NUM_TRAPS));</a>
<a name="ln5990">        }</a>
<a name="ln5991">        while (!is_regular_trap(spec_type)</a>
<a name="ln5992">#if TAG_MAJOR_VERSION == 34</a>
<a name="ln5993">               || spec_type == TRAP_NEEDLE || spec_type == TRAP_GAS</a>
<a name="ln5994">               || spec_type == TRAP_SHADOW || spec_type == TRAP_SHADOW_DORMANT</a>
<a name="ln5995">#endif</a>
<a name="ln5996">               || !is_valid_shaft_level() &amp;&amp; spec_type == TRAP_SHAFT);</a>
<a name="ln5997">    }</a>
<a name="ln5998"> </a>
<a name="ln5999">    trap_def t;</a>
<a name="ln6000">    t.type = spec_type;</a>
<a name="ln6001">    t.pos = where;</a>
<a name="ln6002">    grd(where) = trap_feature(spec_type);</a>
<a name="ln6003">    t.prepare_ammo(charges);</a>
<a name="ln6004">    env.trap[where] = t;</a>
<a name="ln6005">    dprf(&quot;placed a %s trap&quot;, trap_name(spec_type).c_str());</a>
<a name="ln6006">}</a>
<a name="ln6007"> </a>
<a name="ln6008">/**</a>
<a name="ln6009"> * Sprinkle plants around the level.</a>
<a name="ln6010"> *</a>
<a name="ln6011"> * @param rarity            1/chance of placing clumps in any given place.</a>
<a name="ln6012"> * @param clump_density     1/chance of placing more plants within a clump.</a>
<a name="ln6013"> * @param clump_raidus      Radius of plant clumps.</a>
<a name="ln6014"> */</a>
<a name="ln6015">static void _add_plant_clumps(int rarity,</a>
<a name="ln6016">                              int clump_sparseness,</a>
<a name="ln6017">                              int clump_radius)</a>
<a name="ln6018">{</a>
<a name="ln6019">    for (rectangle_iterator ri(1); ri; ++ri)</a>
<a name="ln6020">    {</a>
<a name="ln6021">        mgen_data mg;</a>
<a name="ln6022">        mg.flags = MG_FORCE_PLACE;</a>
<a name="ln6023">        if (mgrd(*ri) != NON_MONSTER &amp;&amp; !map_masked(*ri, MMT_VAULT))</a>
<a name="ln6024">        {</a>
<a name="ln6025">            // clump plants around things that already exist</a>
<a name="ln6026">            monster_type type = menv[mgrd(*ri)].type;</a>
<a name="ln6027">            if ((type == MONS_PLANT</a>
<a name="ln6028">                     || type == MONS_FUNGUS</a>
<a name="ln6029">                     || type == MONS_BUSH)</a>
<a name="ln6030">                 &amp;&amp; one_chance_in(rarity))</a>
<a name="ln6031">            {</a>
<a name="ln6032">                mg.cls = type;</a>
<a name="ln6033">            }</a>
<a name="ln6034">            else</a>
<a name="ln6035">                continue;</a>
<a name="ln6036">        }</a>
<a name="ln6037">        else</a>
<a name="ln6038">            continue;</a>
<a name="ln6039"> </a>
<a name="ln6040">        vector&lt;coord_def&gt; to_place;</a>
<a name="ln6041">        to_place.push_back(*ri);</a>
<a name="ln6042">        for (int i = 1; i &lt; clump_radius; ++i)</a>
<a name="ln6043">        {</a>
<a name="ln6044">            for (radius_iterator rad(*ri, i, C_ROUND); rad; ++rad)</a>
<a name="ln6045">            {</a>
<a name="ln6046">                if (grd(*rad) != DNGN_FLOOR)</a>
<a name="ln6047">                    continue;</a>
<a name="ln6048"> </a>
<a name="ln6049">                // make sure the iterator stays valid</a>
<a name="ln6050">                vector&lt;coord_def&gt; more_to_place;</a>
<a name="ln6051">                for (auto c : to_place)</a>
<a name="ln6052">                {</a>
<a name="ln6053">                    if (*rad == c)</a>
<a name="ln6054">                        continue;</a>
<a name="ln6055">                    // only place plants next to previously placed plants</a>
<a name="ln6056">                    if (abs(rad-&gt;x - c.x) &lt;= 1 &amp;&amp; abs(rad-&gt;y - c.y) &lt;= 1)</a>
<a name="ln6057">                    {</a>
<a name="ln6058">                        if (one_chance_in(clump_sparseness))</a>
<a name="ln6059">                            more_to_place.push_back(*rad);</a>
<a name="ln6060">                    }</a>
<a name="ln6061">                }</a>
<a name="ln6062">                to_place.insert(to_place.end(), more_to_place.begin(),</a>
<a name="ln6063">                                more_to_place.end());</a>
<a name="ln6064">            }</a>
<a name="ln6065">        }</a>
<a name="ln6066"> </a>
<a name="ln6067">        for (auto c : to_place)</a>
<a name="ln6068">        {</a>
<a name="ln6069">            if (c == *ri)</a>
<a name="ln6070">                continue;</a>
<a name="ln6071">            if (plant_forbidden_at(c))</a>
<a name="ln6072">                continue;</a>
<a name="ln6073">            mg.pos = c;</a>
<a name="ln6074">            mons_place(mgen_data(mg));</a>
<a name="ln6075">        }</a>
<a name="ln6076">    }</a>
<a name="ln6077">}</a>
<a name="ln6078"> </a>
<a name="ln6079">static coord_def _find_named_hatch_dest(string hatch_name)</a>
<a name="ln6080">{</a>
<a name="ln6081">    vector &lt;map_marker *&gt; markers;</a>
<a name="ln6082">    markers = find_markers_by_prop(HATCH_DEST_NAME_PROP, hatch_name);</a>
<a name="ln6083">    ASSERT(markers.size() == 1);</a>
<a name="ln6084">    return markers[0]-&gt;pos;</a>
<a name="ln6085">}</a>
<a name="ln6086"> </a>
<a name="ln6087">static coord_def _get_feat_dest(coord_def base_pos, dungeon_feature_type feat,</a>
<a name="ln6088">                                const string &amp;hatch_name)</a>
<a name="ln6089">{</a>
<a name="ln6090">    const bool shaft = feat == DNGN_TRAP_SHAFT;</a>
<a name="ln6091">    map_position_marker *marker = nullptr;</a>
<a name="ln6092"> </a>
<a name="ln6093">    if (!shaft)</a>
<a name="ln6094">        marker = get_position_marker_at(base_pos, feat);</a>
<a name="ln6095"> </a>
<a name="ln6096">    if (!marker)</a>
<a name="ln6097">    {</a>
<a name="ln6098">        coord_def dest_pos;</a>
<a name="ln6099"> </a>
<a name="ln6100">        if (feat_is_escape_hatch(feat) &amp;&amp; !hatch_name.empty())</a>
<a name="ln6101">            dest_pos = _find_named_hatch_dest(hatch_name);</a>
<a name="ln6102">        else</a>
<a name="ln6103">        {</a>
<a name="ln6104">            do</a>
<a name="ln6105">            {</a>
<a name="ln6106">                dest_pos = random_in_bounds();</a>
<a name="ln6107">            }</a>
<a name="ln6108">            while (grd(dest_pos) != DNGN_FLOOR</a>
<a name="ln6109">                   || env.pgrid(dest_pos) &amp; FPROP_NO_TELE_INTO);</a>
<a name="ln6110">        }</a>
<a name="ln6111"> </a>
<a name="ln6112">        if (!shaft)</a>
<a name="ln6113">        {</a>
<a name="ln6114">            env.markers.add(new map_position_marker(base_pos, feat, dest_pos));</a>
<a name="ln6115">            env.markers.clear_need_activate();</a>
<a name="ln6116">        }</a>
<a name="ln6117">        return dest_pos;</a>
<a name="ln6118">    }</a>
<a name="ln6119">    else</a>
<a name="ln6120">        return marker-&gt;dest;</a>
<a name="ln6121">}</a>
<a name="ln6122"> </a>
<a name="ln6123">double dgn_degrees_to_radians(int degrees)</a>
<a name="ln6124">{</a>
<a name="ln6125">    return degrees * PI / 180;</a>
<a name="ln6126">}</a>
<a name="ln6127"> </a>
<a name="ln6128">coord_def dgn_random_point_from(const coord_def &amp;c, int radius, int margin)</a>
<a name="ln6129">{</a>
<a name="ln6130">    int attempts = 70;</a>
<a name="ln6131">    while (attempts-- &gt; 0)</a>
<a name="ln6132">    {</a>
<a name="ln6133">        const double angle = dgn_degrees_to_radians(random2(360));</a>
<a name="ln6134">        const coord_def res =</a>
<a name="ln6135">            c + coord_def(static_cast&lt;int&gt;(radius * cos(angle)),</a>
<a name="ln6136">                          static_cast&lt;int&gt;(radius * sin(angle)));</a>
<a name="ln6137">        if (map_bounds_with_margin(res, margin))</a>
<a name="ln6138">            return res;</a>
<a name="ln6139">    }</a>
<a name="ln6140">    return coord_def();</a>
<a name="ln6141">}</a>
<a name="ln6142"> </a>
<a name="ln6143">coord_def dgn_find_feature_marker(dungeon_feature_type feat)</a>
<a name="ln6144">{</a>
<a name="ln6145">    for (map_marker *mark : env.markers.get_all(MAT_FEATURE))</a>
<a name="ln6146">        if (dynamic_cast&lt;map_feature_marker*&gt;(mark)-&gt;feat == feat)</a>
<a name="ln6147">            return mark-&gt;pos;</a>
<a name="ln6148">    return coord_def();</a>
<a name="ln6149">}</a>
<a name="ln6150"> </a>
<a name="ln6151">// Make hatches and shafts land the player a bit away from the wall.</a>
<a name="ln6152">// Specifically, the adjacent cell with least slime walls next to it.</a>
<a name="ln6153">// XXX: This can still give bad situations if the layout is not bubbly,</a>
<a name="ln6154">//      e.g. when a vault is placed with connecting corridors.</a>
<a name="ln6155">static void _fixup_slime_hatch_dest(coord_def* pos)</a>
<a name="ln6156">{</a>
<a name="ln6157">    int max_walls = 9;</a>
<a name="ln6158">    for (adjacent_iterator ai(*pos, false); ai; ++ai)</a>
<a name="ln6159">    {</a>
<a name="ln6160">        if (!feat_is_traversable(env.grid(*ai)))</a>
<a name="ln6161">            continue;</a>
<a name="ln6162">        const int walls = count_adjacent_slime_walls(*ai);</a>
<a name="ln6163">        if (walls &lt; max_walls)</a>
<a name="ln6164">        {</a>
<a name="ln6165">            *pos = *ai;</a>
<a name="ln6166">            max_walls = walls;</a>
<a name="ln6167">        }</a>
<a name="ln6168">    }</a>
<a name="ln6169">    ASSERT(max_walls &lt; 9);</a>
<a name="ln6170">}</a>
<a name="ln6171"> </a>
<a name="ln6172">coord_def dgn_find_nearby_stair(dungeon_feature_type stair_to_find,</a>
<a name="ln6173">                                coord_def base_pos, bool find_closest,</a>
<a name="ln6174">                                string hatch_name)</a>
<a name="ln6175">{</a>
<a name="ln6176">    dprf(DIAG_DNGN, &quot;Level entry point on %sstair: %d (%s)&quot;,</a>
<a name="ln6177">         find_closest ? &quot;closest &quot; : &quot;&quot;,</a>
<a name="ln6178">         stair_to_find, dungeon_feature_name(stair_to_find));</a>
<a name="ln6179"> </a>
<a name="ln6180">    // Shafts and hatches.</a>
<a name="ln6181">    if (stair_to_find == DNGN_ESCAPE_HATCH_UP</a>
<a name="ln6182">        || stair_to_find == DNGN_ESCAPE_HATCH_DOWN</a>
<a name="ln6183">        || stair_to_find == DNGN_TRAP_SHAFT)</a>
<a name="ln6184">    {</a>
<a name="ln6185">        coord_def pos(_get_feat_dest(base_pos, stair_to_find, hatch_name));</a>
<a name="ln6186">        if (player_in_branch(BRANCH_SLIME))</a>
<a name="ln6187">            _fixup_slime_hatch_dest(&amp;pos);</a>
<a name="ln6188">        if (in_bounds(pos))</a>
<a name="ln6189">            return pos;</a>
<a name="ln6190">    }</a>
<a name="ln6191"> </a>
<a name="ln6192">    if (stair_to_find == DNGN_STONE_ARCH)</a>
<a name="ln6193">    {</a>
<a name="ln6194">        const coord_def pos(dgn_find_feature_marker(stair_to_find));</a>
<a name="ln6195">        if (in_bounds(pos) &amp;&amp; grd(pos) == stair_to_find)</a>
<a name="ln6196">            return pos;</a>
<a name="ln6197">    }</a>
<a name="ln6198"> </a>
<a name="ln6199">    if (stair_to_find == your_branch().exit_stairs)</a>
<a name="ln6200">    {</a>
<a name="ln6201">        const coord_def pos(dgn_find_feature_marker(DNGN_STONE_STAIRS_UP_I));</a>
<a name="ln6202">        if (in_bounds(pos) &amp;&amp; grd(pos) == stair_to_find)</a>
<a name="ln6203">            return pos;</a>
<a name="ln6204">    }</a>
<a name="ln6205"> </a>
<a name="ln6206">    // Scan around the player's position first.</a>
<a name="ln6207">    int basex = base_pos.x;</a>
<a name="ln6208">    int basey = base_pos.y;</a>
<a name="ln6209"> </a>
<a name="ln6210">    // Check for illegal starting point.</a>
<a name="ln6211">    if (!in_bounds(basex, basey))</a>
<a name="ln6212">    {</a>
<a name="ln6213">        basex = 0;</a>
<a name="ln6214">        basey = 0;</a>
<a name="ln6215">    }</a>
<a name="ln6216"> </a>
<a name="ln6217">    coord_def result;</a>
<a name="ln6218"> </a>
<a name="ln6219">    int found = 0;</a>
<a name="ln6220">    int best_dist = 1 + GXM*GXM + GYM*GYM;</a>
<a name="ln6221"> </a>
<a name="ln6222">    // XXX These passes should be rewritten to use an iterator of STL</a>
<a name="ln6223">    // algorithm of some kind.</a>
<a name="ln6224"> </a>
<a name="ln6225">    // First pass: look for an exact match.</a>
<a name="ln6226">    for (int xcode = 0; xcode &lt; GXM; ++xcode)</a>
<a name="ln6227">    {</a>
<a name="ln6228">        if (stair_to_find == DNGN_FLOOR)</a>
<a name="ln6229">            break;</a>
<a name="ln6230"> </a>
<a name="ln6231">        const int xsign = ((xcode % 2) ? 1 : -1);</a>
<a name="ln6232">        const int xdiff = xsign * (xcode + 1)/2;</a>
<a name="ln6233">        const int xpos  = (basex + xdiff + GXM) % GXM;</a>
<a name="ln6234"> </a>
<a name="ln6235">        for (int ycode = 0; ycode &lt; GYM; ++ycode)</a>
<a name="ln6236">        {</a>
<a name="ln6237">            const int ysign = ((ycode % 2) ? 1 : -1);</a>
<a name="ln6238">            const int ydiff = ysign * (ycode + 1)/2;</a>
<a name="ln6239">            const int ypos  = (basey + ydiff + GYM) % GYM;</a>
<a name="ln6240"> </a>
<a name="ln6241">            // Note that due to the wrapping above, we can't just use</a>
<a name="ln6242">            // xdiff*xdiff + ydiff*ydiff.</a>
<a name="ln6243">            const int dist = (xpos-basex)*(xpos-basex)</a>
<a name="ln6244">                             + (ypos-basey)*(ypos-basey);</a>
<a name="ln6245"> </a>
<a name="ln6246">            if (orig_terrain(coord_def(xpos, ypos)) == stair_to_find</a>
<a name="ln6247">                &amp;&amp; !feature_mimic_at(coord_def(xpos, ypos)))</a>
<a name="ln6248">            {</a>
<a name="ln6249">                found++;</a>
<a name="ln6250">                if (find_closest)</a>
<a name="ln6251">                {</a>
<a name="ln6252">                    if (dist &lt; best_dist)</a>
<a name="ln6253">                    {</a>
<a name="ln6254">                        best_dist = dist;</a>
<a name="ln6255">                        result.x = xpos;</a>
<a name="ln6256">                        result.y = ypos;</a>
<a name="ln6257">                    }</a>
<a name="ln6258">                }</a>
<a name="ln6259">                else if (one_chance_in(found))</a>
<a name="ln6260">                {</a>
<a name="ln6261">                    result.x = xpos;</a>
<a name="ln6262">                    result.y = ypos;</a>
<a name="ln6263">                }</a>
<a name="ln6264">            }</a>
<a name="ln6265">        }</a>
<a name="ln6266">    }</a>
<a name="ln6267"> </a>
<a name="ln6268">    if (found)</a>
<a name="ln6269">        return result;</a>
<a name="ln6270"> </a>
<a name="ln6271">    best_dist = 1 + GXM*GXM + GYM*GYM;</a>
<a name="ln6272"> </a>
<a name="ln6273">    // Second pass: find a staircase in the proper direction.</a>
<a name="ln6274">    for (int xcode = 0; xcode &lt; GXM; ++xcode)</a>
<a name="ln6275">    {</a>
<a name="ln6276">        if (stair_to_find == DNGN_FLOOR)</a>
<a name="ln6277">            break;</a>
<a name="ln6278"> </a>
<a name="ln6279">        const int xsign = ((xcode % 2) ? 1 : -1);</a>
<a name="ln6280">        const int xdiff = xsign * (xcode + 1)/2;</a>
<a name="ln6281">        const int xpos  = (basex + xdiff + GXM) % GXM;</a>
<a name="ln6282"> </a>
<a name="ln6283">        for (int ycode = 0; ycode &lt; GYM; ++ycode)</a>
<a name="ln6284">        {</a>
<a name="ln6285">            const int ysign = ((ycode % 2) ? 1 : -1);</a>
<a name="ln6286">            const int ydiff = ysign * (ycode + 1)/2;</a>
<a name="ln6287">            const int ypos  = (basey + ydiff + GYM) % GYM;</a>
<a name="ln6288"> </a>
<a name="ln6289">            bool good_stair;</a>
<a name="ln6290">            const int looking_at = orig_terrain(coord_def(xpos, ypos));</a>
<a name="ln6291"> </a>
<a name="ln6292">            if (feat_is_stone_stair_down(stair_to_find)</a>
<a name="ln6293">                || stair_to_find == DNGN_ESCAPE_HATCH_DOWN</a>
<a name="ln6294">                || stair_to_find == DNGN_FLOOR)</a>
<a name="ln6295">            {</a>
<a name="ln6296">                good_stair = feat_is_stone_stair_down((dungeon_feature_type)looking_at)</a>
<a name="ln6297">                             || looking_at == DNGN_ESCAPE_HATCH_DOWN;</a>
<a name="ln6298">            }</a>
<a name="ln6299">            else</a>
<a name="ln6300">            {</a>
<a name="ln6301">                good_stair = feat_is_stone_stair_up((dungeon_feature_type)looking_at)</a>
<a name="ln6302">                              || looking_at == DNGN_ESCAPE_HATCH_UP;</a>
<a name="ln6303">            }</a>
<a name="ln6304"> </a>
<a name="ln6305">            const int dist = (xpos-basex)*(xpos-basex)</a>
<a name="ln6306">                             + (ypos-basey)*(ypos-basey);</a>
<a name="ln6307"> </a>
<a name="ln6308">            if (good_stair &amp;&amp; !feature_mimic_at(coord_def(xpos, ypos)))</a>
<a name="ln6309">            {</a>
<a name="ln6310">                found++;</a>
<a name="ln6311">                if (find_closest &amp;&amp; dist &lt; best_dist)</a>
<a name="ln6312">                {</a>
<a name="ln6313">                    best_dist = dist;</a>
<a name="ln6314">                    result.x = xpos;</a>
<a name="ln6315">                    result.y = ypos;</a>
<a name="ln6316">                }</a>
<a name="ln6317">                else if (one_chance_in(found))</a>
<a name="ln6318">                {</a>
<a name="ln6319">                    result.x = xpos;</a>
<a name="ln6320">                    result.y = ypos;</a>
<a name="ln6321">                }</a>
<a name="ln6322">            }</a>
<a name="ln6323">        }</a>
<a name="ln6324">    }</a>
<a name="ln6325"> </a>
<a name="ln6326">    if (found)</a>
<a name="ln6327">        return result;</a>
<a name="ln6328"> </a>
<a name="ln6329">    const coord_def pos(dgn_find_feature_marker(stair_to_find));</a>
<a name="ln6330">    if (in_bounds(pos))</a>
<a name="ln6331">        return pos;</a>
<a name="ln6332"> </a>
<a name="ln6333">    // Look for any clear terrain and abandon the idea of looking nearby now.</a>
<a name="ln6334">    // This is used when taking transit Pandemonium gates. Currently the player</a>
<a name="ln6335">    // can land in vaults, which is considered acceptable.</a>
<a name="ln6336">    for (rectangle_iterator ri(0); ri; ++ri)</a>
<a name="ln6337">    {</a>
<a name="ln6338">        if (feat_has_dry_floor(grd(*ri)))</a>
<a name="ln6339">        {</a>
<a name="ln6340">            found++;</a>
<a name="ln6341">            if (one_chance_in(found))</a>
<a name="ln6342">                result = *ri;</a>
<a name="ln6343">        }</a>
<a name="ln6344">    }</a>
<a name="ln6345">    if (found)</a>
<a name="ln6346">        return result;</a>
<a name="ln6347"> </a>
<a name="ln6348">    // FAIL</a>
<a name="ln6349">    die(&quot;Can't find any floor to put the player on.&quot;);</a>
<a name="ln6350">}</a>
<a name="ln6351"> </a>
<a name="ln6352">void dgn_set_branch_epilogue(branch_type branch, string func_name)</a>
<a name="ln6353">{</a>
<a name="ln6354">    branch_epilogues[branch] = func_name;</a>
<a name="ln6355">}</a>
<a name="ln6356"> </a>
<a name="ln6357">////////////////////////////////////////////////////////////////////</a>
<a name="ln6358">// dgn_region</a>
<a name="ln6359"> </a>
<a name="ln6360">bool dgn_region::overlaps(const dgn_region &amp;other) const</a>
<a name="ln6361">{</a>
<a name="ln6362">    // The old overlap check checked only two corners - top-left and</a>
<a name="ln6363">    // bottom-right. I'm hoping nothing actually *relied* on that stupid bug.</a>
<a name="ln6364"> </a>
<a name="ln6365">    return (between(pos.x, other.pos.x, other.pos.x + other.size.x - 1)</a>
<a name="ln6366">               || between(pos.x + size.x - 1, other.pos.x,</a>
<a name="ln6367">                          other.pos.x + other.size.x - 1))</a>
<a name="ln6368">           &amp;&amp; (between(pos.y, other.pos.y, other.pos.y + other.size.y - 1)</a>
<a name="ln6369">               || between(pos.y + size.y - 1, other.pos.y,</a>
<a name="ln6370">                          other.pos.y + other.size.y - 1));</a>
<a name="ln6371">}</a>
<a name="ln6372"> </a>
<a name="ln6373">bool dgn_region::overlaps_any(const dgn_region_list &amp;regions) const</a>
<a name="ln6374">{</a>
<a name="ln6375">    for (auto reg : regions)</a>
<a name="ln6376">        if (overlaps(reg))</a>
<a name="ln6377">            return true;</a>
<a name="ln6378"> </a>
<a name="ln6379">    return false;</a>
<a name="ln6380">}</a>
<a name="ln6381"> </a>
<a name="ln6382">bool dgn_region::overlaps(const dgn_region_list &amp;regions,</a>
<a name="ln6383">                          const map_mask &amp;mask) const</a>
<a name="ln6384">{</a>
<a name="ln6385">    return overlaps_any(regions) &amp;&amp; overlaps(mask);</a>
<a name="ln6386">}</a>
<a name="ln6387"> </a>
<a name="ln6388">bool dgn_region::overlaps(const map_mask &amp;mask) const</a>
<a name="ln6389">{</a>
<a name="ln6390">    const coord_def endp = pos + size;</a>
<a name="ln6391">    for (int y = pos.y; y &lt; endp.y; ++y)</a>
<a name="ln6392">        for (int x = pos.x; x &lt; endp.x; ++x)</a>
<a name="ln6393">        {</a>
<a name="ln6394">            if (mask[x][y])</a>
<a name="ln6395">                return true;</a>
<a name="ln6396">        }</a>
<a name="ln6397"> </a>
<a name="ln6398">    return false;</a>
<a name="ln6399">}</a>
<a name="ln6400"> </a>
<a name="ln6401">coord_def dgn_region::random_edge_point() const</a>
<a name="ln6402">{</a>
<a name="ln6403">    coord_def res;</a>
<a name="ln6404">    if (x_chance_in_y(size.x, size.x + size.y))</a>
<a name="ln6405">    {</a>
<a name="ln6406">        res.x = pos.x + random2(size.x);</a>
<a name="ln6407">        res.y = random_choose(pos.y, pos.y + size.y - 1);</a>
<a name="ln6408">    }</a>
<a name="ln6409">    else</a>
<a name="ln6410">    {</a>
<a name="ln6411">        res.x = random_choose(pos.x, pos.x + size.x - 1);</a>
<a name="ln6412">        res.y = pos.y + random2(size.y);</a>
<a name="ln6413">    }</a>
<a name="ln6414">    return res;</a>
<a name="ln6415">}</a>
<a name="ln6416"> </a>
<a name="ln6417">coord_def dgn_region::random_point() const</a>
<a name="ln6418">{</a>
<a name="ln6419">    coord_def res;</a>
<a name="ln6420">    res.x = pos.x + random2(size.x);</a>
<a name="ln6421">    res.y = pos.y + random2(size.y);</a>
<a name="ln6422">    return res;</a>
<a name="ln6423">}</a>
<a name="ln6424"> </a>
<a name="ln6425">struct StairConnectivity</a>
<a name="ln6426">{</a>
<a name="ln6427">    StairConnectivity()</a>
<a name="ln6428">    {</a>
<a name="ln6429">        region[0] = region[1] = region[2] = 0;</a>
<a name="ln6430">        connected[0] = connected[1] = connected[2] = true;</a>
<a name="ln6431">    }</a>
<a name="ln6432"> </a>
<a name="ln6433">    void connect_region(int idx)</a>
<a name="ln6434">    {</a>
<a name="ln6435">        for (int i = 0; i &lt; 3; i++)</a>
<a name="ln6436">            connected[i] |= (region[i] == idx);</a>
<a name="ln6437">    }</a>
<a name="ln6438"> </a>
<a name="ln6439">    void read(reader &amp;th)</a>
<a name="ln6440">    {</a>
<a name="ln6441">        region[0] = unmarshallByte(th);</a>
<a name="ln6442">        region[1] = unmarshallByte(th);</a>
<a name="ln6443">        region[2] = unmarshallByte(th);</a>
<a name="ln6444">        connected[0] = unmarshallBoolean(th);</a>
<a name="ln6445">        connected[1] = unmarshallBoolean(th);</a>
<a name="ln6446">        connected[2] = unmarshallBoolean(th);</a>
<a name="ln6447">    }</a>
<a name="ln6448"> </a>
<a name="ln6449">    void write(writer &amp;th)</a>
<a name="ln6450">    {</a>
<a name="ln6451">        marshallByte(th, region[0]);</a>
<a name="ln6452">        marshallByte(th, region[1]);</a>
<a name="ln6453">        marshallByte(th, region[2]);</a>
<a name="ln6454">        marshallBoolean(th, connected[0]);</a>
<a name="ln6455">        marshallBoolean(th, connected[1]);</a>
<a name="ln6456">        marshallBoolean(th, connected[2]);</a>
<a name="ln6457">    }</a>
<a name="ln6458"> </a>
<a name="ln6459">    int8_t region[3];</a>
<a name="ln6460">    bool connected[3];</a>
<a name="ln6461">};</a>
<a name="ln6462"> </a>
<a name="ln6463">FixedVector&lt;vector&lt;StairConnectivity&gt;, NUM_BRANCHES&gt; connectivity;</a>
<a name="ln6464"> </a>
<a name="ln6465">void init_level_connectivity()</a>
<a name="ln6466">{</a>
<a name="ln6467">    for (branch_iterator it; it; ++it)</a>
<a name="ln6468">    {</a>
<a name="ln6469">        int depth = brdepth[it-&gt;id] &gt; 0 ? brdepth[it-&gt;id] : 0;</a>
<a name="ln6470">        connectivity[it-&gt;id].resize(depth);</a>
<a name="ln6471">    }</a>
<a name="ln6472">}</a>
<a name="ln6473"> </a>
<a name="ln6474">void read_level_connectivity(reader &amp;th)</a>
<a name="ln6475">{</a>
<a name="ln6476">    int nb = unmarshallInt(th);</a>
<a name="ln6477">    ASSERT(nb &lt;= NUM_BRANCHES);</a>
<a name="ln6478">    for (int i = 0; i &lt; nb; i++)</a>
<a name="ln6479">    {</a>
<a name="ln6480">        unsigned int depth = brdepth[i] &gt; 0 ? brdepth[i] : 0;</a>
<a name="ln6481">        unsigned int num_entries = unmarshallInt(th);</a>
<a name="ln6482">        connectivity[i].resize(max(depth, num_entries));</a>
<a name="ln6483"> </a>
<a name="ln6484">        for (unsigned int e = 0; e &lt; num_entries; e++)</a>
<a name="ln6485">            connectivity[i][e].read(th);</a>
<a name="ln6486">    }</a>
<a name="ln6487">}</a>
<a name="ln6488"> </a>
<a name="ln6489">void write_level_connectivity(writer &amp;th)</a>
<a name="ln6490">{</a>
<a name="ln6491">    marshallInt(th, NUM_BRANCHES);</a>
<a name="ln6492">    for (int i = 0; i &lt; NUM_BRANCHES; i++)</a>
<a name="ln6493">    {</a>
<a name="ln6494">        marshallInt(th, connectivity[i].size());</a>
<a name="ln6495">        for (unsigned int e = 0; e &lt; connectivity[i].size(); e++)</a>
<a name="ln6496">            connectivity[i][e].write(th);</a>
<a name="ln6497">    }</a>
<a name="ln6498">}</a>
<a name="ln6499"> </a>
<a name="ln6500">static bool _fixup_interlevel_connectivity()</a>
<a name="ln6501">{</a>
<a name="ln6502">    // Rotate the stairs on this level to attempt to preserve connectivity</a>
<a name="ln6503">    // as much as possible. At a minimum, it ensures a path from the bottom</a>
<a name="ln6504">    // of a branch to the top of a branch. If this is not possible, it</a>
<a name="ln6505">    // returns false.</a>
<a name="ln6506">    //</a>
<a name="ln6507">    // Note: this check is undirectional and assumes that levels below this</a>
<a name="ln6508">    // one have not been created yet. If this is not the case, it will not</a>
<a name="ln6509">    // guarantee or preserve connectivity.</a>
<a name="ln6510">    //</a>
<a name="ln6511">    // XXX: If successful, the previous level's connectedness information</a>
<a name="ln6512">    //      is updated, so we rely on the level not being vetoed after</a>
<a name="ln6513">    //      this check.</a>
<a name="ln6514"> </a>
<a name="ln6515">    if (!player_in_connected_branch() || brdepth[you.where_are_you] == -1)</a>
<a name="ln6516">        return true;</a>
<a name="ln6517">    if (branches[you.where_are_you].branch_flags &amp; brflag::islanded)</a>
<a name="ln6518">        return true;</a>
<a name="ln6519"> </a>
<a name="ln6520">    StairConnectivity prev_con;</a>
<a name="ln6521">    if (you.depth &gt; 1)</a>
<a name="ln6522">        prev_con = connectivity[your_branch().id][you.depth - 2];</a>
<a name="ln6523">    StairConnectivity this_con;</a>
<a name="ln6524"> </a>
<a name="ln6525">    FixedVector&lt;coord_def, 3&gt; up_gc;</a>
<a name="ln6526">    FixedVector&lt;coord_def, 3&gt; down_gc;</a>
<a name="ln6527">    FixedVector&lt;int, 3&gt; up_region;</a>
<a name="ln6528">    FixedVector&lt;int, 3&gt; down_region;</a>
<a name="ln6529">    FixedVector&lt;bool, 3&gt; has_down;</a>
<a name="ln6530">    vector&lt;bool&gt; region_connected;</a>
<a name="ln6531"> </a>
<a name="ln6532">    up_region[0] = up_region[1] = up_region[2] = -1;</a>
<a name="ln6533">    down_region[0] = down_region[1] = down_region[2] = -1;</a>
<a name="ln6534">    has_down[0] = has_down[1] = has_down[2] = false;</a>
<a name="ln6535"> </a>
<a name="ln6536">    // Find up stairs and down stairs on the current level.</a>
<a name="ln6537">    memset(travel_point_distance, 0, sizeof(travel_distance_grid_t));</a>
<a name="ln6538">    int nzones = 0;</a>
<a name="ln6539">    for (rectangle_iterator ri(0); ri; ++ri)</a>
<a name="ln6540">    {</a>
<a name="ln6541">        if (!map_bounds(ri-&gt;x, ri-&gt;y)</a>
<a name="ln6542">            || travel_point_distance[ri-&gt;x][ri-&gt;y]</a>
<a name="ln6543">            || !dgn_square_travel_ok(*ri))</a>
<a name="ln6544">        {</a>
<a name="ln6545">            continue;</a>
<a name="ln6546">        }</a>
<a name="ln6547"> </a>
<a name="ln6548">        _dgn_fill_zone(*ri, ++nzones, _dgn_point_record_stub,</a>
<a name="ln6549">                       dgn_square_travel_ok, nullptr);</a>
<a name="ln6550">    }</a>
<a name="ln6551"> </a>
<a name="ln6552">    int max_region = 0;</a>
<a name="ln6553">    for (rectangle_iterator ri(0); ri; ++ri)</a>
<a name="ln6554">    {</a>
<a name="ln6555">        if (feature_mimic_at(*ri))</a>
<a name="ln6556">            continue;</a>
<a name="ln6557"> </a>
<a name="ln6558">        dungeon_feature_type feat = grd(*ri);</a>
<a name="ln6559">        switch (feat)</a>
<a name="ln6560">        {</a>
<a name="ln6561">        case DNGN_STONE_STAIRS_DOWN_I:</a>
<a name="ln6562">        case DNGN_STONE_STAIRS_DOWN_II:</a>
<a name="ln6563">        case DNGN_STONE_STAIRS_DOWN_III:</a>
<a name="ln6564">        {</a>
<a name="ln6565">            int idx = feat - DNGN_STONE_STAIRS_DOWN_I;</a>
<a name="ln6566">            if (down_region[idx] == -1)</a>
<a name="ln6567">            {</a>
<a name="ln6568">                down_region[idx] = travel_point_distance[ri-&gt;x][ri-&gt;y];</a>
<a name="ln6569">                down_gc[idx] = *ri;</a>
<a name="ln6570">                max_region = max(down_region[idx], max_region);</a>
<a name="ln6571">            }</a>
<a name="ln6572">            else</a>
<a name="ln6573">            {</a>
<a name="ln6574">                // Too many stairs!</a>
<a name="ln6575">                return false;</a>
<a name="ln6576">            }</a>
<a name="ln6577">            break;</a>
<a name="ln6578">        }</a>
<a name="ln6579">        case DNGN_STONE_STAIRS_UP_I:</a>
<a name="ln6580">        case DNGN_STONE_STAIRS_UP_II:</a>
<a name="ln6581">        case DNGN_STONE_STAIRS_UP_III:</a>
<a name="ln6582">        {</a>
<a name="ln6583">            int idx = feat - DNGN_STONE_STAIRS_UP_I;</a>
<a name="ln6584">            if (up_region[idx] == -1)</a>
<a name="ln6585">            {</a>
<a name="ln6586">                up_region[idx] = travel_point_distance[ri-&gt;x][ri-&gt;y];</a>
<a name="ln6587">                up_gc[idx] = *ri;</a>
<a name="ln6588">                max_region = max(up_region[idx], max_region);</a>
<a name="ln6589">            }</a>
<a name="ln6590">            else</a>
<a name="ln6591">            {</a>
<a name="ln6592">                // Too many stairs!</a>
<a name="ln6593">                return false;</a>
<a name="ln6594">            }</a>
<a name="ln6595">            break;</a>
<a name="ln6596">        }</a>
<a name="ln6597">        default:</a>
<a name="ln6598">            break;</a>
<a name="ln6599">        }</a>
<a name="ln6600">    }</a>
<a name="ln6601"> </a>
<a name="ln6602">    const int up_region_max = you.depth == 1 ? 1 : 3;</a>
<a name="ln6603"> </a>
<a name="ln6604">    // Ensure all up stairs were found.</a>
<a name="ln6605">    for (int i = 0; i &lt; up_region_max; i++)</a>
<a name="ln6606">        if (up_region[i] == -1)</a>
<a name="ln6607">            return false;</a>
<a name="ln6608"> </a>
<a name="ln6609">    region_connected.resize(max_region + 1);</a>
<a name="ln6610">    fill(begin(region_connected), end(region_connected), false);</a>
<a name="ln6611"> </a>
<a name="ln6612">    // Which up stairs have a down stair? (These are potentially connected.)</a>
<a name="ln6613">    if (!at_branch_bottom())</a>
<a name="ln6614">    {</a>
<a name="ln6615">        for (int i = 0; i &lt; up_region_max; i++)</a>
<a name="ln6616">            for (int j = 0; j &lt; 3; j++)</a>
<a name="ln6617">            {</a>
<a name="ln6618">                if (down_region[j] == up_region[i])</a>
<a name="ln6619">                    has_down[i] = true;</a>
<a name="ln6620">            }</a>
<a name="ln6621">    }</a>
<a name="ln6622"> </a>
<a name="ln6623">    bool any_connected = has_down[0] || has_down[1] || has_down[2];</a>
<a name="ln6624">    if (!any_connected &amp;&amp; !at_branch_bottom())</a>
<a name="ln6625">        return false;</a>
<a name="ln6626"> </a>
<a name="ln6627">    // Keep track of what stairs we've assigned.</a>
<a name="ln6628">    int assign_prev[3] = {-1, -1, -1};</a>
<a name="ln6629">    int assign_cur[3] = {-1, -1, -1};</a>
<a name="ln6630"> </a>
<a name="ln6631">    // Assign one connected down stair from the previous level to an</a>
<a name="ln6632">    // upstair on the current level with a downstair in the same region.</a>
<a name="ln6633">    // This ensures at least a single valid path to the top.</a>
<a name="ln6634">    bool minimal_connectivity = false;</a>
<a name="ln6635">    for (int i = 0; i &lt; 3 &amp;&amp; !minimal_connectivity; i++)</a>
<a name="ln6636">    {</a>
<a name="ln6637">        if (!prev_con.connected[i])</a>
<a name="ln6638">            continue;</a>
<a name="ln6639">        for (int j = 0; j &lt; up_region_max; j++)</a>
<a name="ln6640">        {</a>
<a name="ln6641">            if (!has_down[j] &amp;&amp; !at_branch_bottom())</a>
<a name="ln6642">                continue;</a>
<a name="ln6643"> </a>
<a name="ln6644">            minimal_connectivity = true;</a>
<a name="ln6645">            assign_prev[i] = j;</a>
<a name="ln6646">            assign_cur[j] = i;</a>
<a name="ln6647">            region_connected[up_region[j]] = true;</a>
<a name="ln6648">            break;</a>
<a name="ln6649">        }</a>
<a name="ln6650">    }</a>
<a name="ln6651">    if (!minimal_connectivity)</a>
<a name="ln6652">        return false;</a>
<a name="ln6653"> </a>
<a name="ln6654">    // For each disconnected stair (in a unique region) on the previous level,</a>
<a name="ln6655">    // try to reconnect to a connected up stair on the current level.</a>
<a name="ln6656">    for (int i = 0; i &lt; 3; i++)</a>
<a name="ln6657">    {</a>
<a name="ln6658">        if (assign_prev[i] != -1 || prev_con.connected[i])</a>
<a name="ln6659">            continue;</a>
<a name="ln6660"> </a>
<a name="ln6661">        bool unique_region = true;</a>
<a name="ln6662">        for (int j = 0; j &lt; i; j++)</a>
<a name="ln6663">        {</a>
<a name="ln6664">            if (prev_con.region[j] == prev_con.region[i])</a>
<a name="ln6665">                unique_region = false;</a>
<a name="ln6666">        }</a>
<a name="ln6667">        if (!unique_region)</a>
<a name="ln6668">            continue;</a>
<a name="ln6669"> </a>
<a name="ln6670">        // Try first to assign to any connected regions.</a>
<a name="ln6671">        for (int j = 0; j &lt; up_region_max; j++)</a>
<a name="ln6672">        {</a>
<a name="ln6673">            if (assign_cur[j] != -1 || !region_connected[up_region[j]])</a>
<a name="ln6674">                continue;</a>
<a name="ln6675"> </a>
<a name="ln6676">            assign_prev[i] = j;</a>
<a name="ln6677">            assign_cur[j] = i;</a>
<a name="ln6678">            prev_con.connect_region(prev_con.region[i]);</a>
<a name="ln6679">            break;</a>
<a name="ln6680">        }</a>
<a name="ln6681">        if (assign_prev[i] != -1)</a>
<a name="ln6682">            continue;</a>
<a name="ln6683"> </a>
<a name="ln6684">        // If we fail, then assign to any up stair with a down, and we'll</a>
<a name="ln6685">        // try to reconnect this section on the next level.</a>
<a name="ln6686">        for (int j = 0; j &lt; 3; j++)</a>
<a name="ln6687">        {</a>
<a name="ln6688">            if (assign_cur[j] != -1 || !has_down[j])</a>
<a name="ln6689">                continue;</a>
<a name="ln6690"> </a>
<a name="ln6691">            assign_prev[i] = j;</a>
<a name="ln6692">            assign_cur[j] = i;</a>
<a name="ln6693">            break;</a>
<a name="ln6694">        }</a>
<a name="ln6695">    }</a>
<a name="ln6696"> </a>
<a name="ln6697">    // Assign any connected down stairs from the previous level to any</a>
<a name="ln6698">    // disconnected stairs on the current level.</a>
<a name="ln6699">    for (int i = 0; i &lt; 3; i++)</a>
<a name="ln6700">    {</a>
<a name="ln6701">        if (!prev_con.connected[i] || assign_prev[i] != -1)</a>
<a name="ln6702">            continue;</a>
<a name="ln6703"> </a>
<a name="ln6704">        for (int j = 0; j &lt; up_region_max; j++)</a>
<a name="ln6705">        {</a>
<a name="ln6706">            if (has_down[j] || assign_cur[j] != -1)</a>
<a name="ln6707">                continue;</a>
<a name="ln6708">            if (region_connected[up_region[j]])</a>
<a name="ln6709">                continue;</a>
<a name="ln6710"> </a>
<a name="ln6711">            assign_prev[i] = j;</a>
<a name="ln6712">            assign_cur[j] = i;</a>
<a name="ln6713">            region_connected[up_region[j]] = true;</a>
<a name="ln6714">            break;</a>
<a name="ln6715">        }</a>
<a name="ln6716">    }</a>
<a name="ln6717"> </a>
<a name="ln6718">    // If there are any remaining stairs, assign those.</a>
<a name="ln6719">    for (int i = 0; i &lt; 3; i++)</a>
<a name="ln6720">    {</a>
<a name="ln6721">        if (assign_prev[i] != -1)</a>
<a name="ln6722">            continue;</a>
<a name="ln6723">        for (int j = 0; j &lt; up_region_max; j++)</a>
<a name="ln6724">        {</a>
<a name="ln6725">            if (assign_cur[j] != -1)</a>
<a name="ln6726">                continue;</a>
<a name="ln6727">            assign_prev[i] = j;</a>
<a name="ln6728">            assign_cur[j] = i;</a>
<a name="ln6729"> </a>
<a name="ln6730">            if (region_connected[up_region[j]])</a>
<a name="ln6731">                prev_con.connect_region(prev_con.region[i]);</a>
<a name="ln6732">            else if (prev_con.connected[i])</a>
<a name="ln6733">                region_connected[up_region[j]] = true;</a>
<a name="ln6734">            break;</a>
<a name="ln6735">        }</a>
<a name="ln6736">    }</a>
<a name="ln6737"> </a>
<a name="ln6738">    // At the branch bottom, all up stairs must be connected.</a>
<a name="ln6739">    if (at_branch_bottom())</a>
<a name="ln6740">    {</a>
<a name="ln6741">        for (int i = 0; i &lt; up_region_max; i++)</a>
<a name="ln6742">            if (!region_connected[up_region[i]])</a>
<a name="ln6743">                return false;</a>
<a name="ln6744">    }</a>
<a name="ln6745"> </a>
<a name="ln6746">    // Sanity check that we're not duplicating stairs.</a>
<a name="ln6747">    if (up_region_max &gt; 1)</a>
<a name="ln6748">    {</a>
<a name="ln6749">        bool stairs_unique = (assign_cur[0] != assign_cur[1]</a>
<a name="ln6750">                              &amp;&amp; assign_cur[1] != assign_cur[2]);</a>
<a name="ln6751">        ASSERT(stairs_unique);</a>
<a name="ln6752">        if (!stairs_unique)</a>
<a name="ln6753">            return false;</a>
<a name="ln6754">    }</a>
<a name="ln6755"> </a>
<a name="ln6756">    // Reassign up stair numbers as needed.</a>
<a name="ln6757">    for (int i = 0; i &lt; up_region_max; i++)</a>
<a name="ln6758">    {</a>
<a name="ln6759">        _set_grd(up_gc[i],</a>
<a name="ln6760">            (dungeon_feature_type)(DNGN_STONE_STAIRS_UP_I + assign_cur[i]));</a>
<a name="ln6761">    }</a>
<a name="ln6762"> </a>
<a name="ln6763">    // Fill in connectivity and regions.</a>
<a name="ln6764">    for (int i = 0; i &lt; 3; i++)</a>
<a name="ln6765">    {</a>
<a name="ln6766">        this_con.region[i] = down_region[i];</a>
<a name="ln6767">        if (down_region[i] != -1)</a>
<a name="ln6768">            this_con.connected[i] = region_connected[down_region[i]];</a>
<a name="ln6769">        else</a>
<a name="ln6770">            this_con.connected[i] = false;</a>
<a name="ln6771"> </a>
<a name="ln6772">    }</a>
<a name="ln6773"> </a>
<a name="ln6774">    // Save the connectivity.</a>
<a name="ln6775">    if (you.depth &gt; 1)</a>
<a name="ln6776">        connectivity[your_branch().id][you.depth - 2] = prev_con;</a>
<a name="ln6777">    connectivity[your_branch().id][you.depth - 1] = this_con;</a>
<a name="ln6778"> </a>
<a name="ln6779">    return true;</a>
<a name="ln6780">}</a>
<a name="ln6781"> </a>
<a name="ln6782">void run_map_epilogues()</a>
<a name="ln6783">{</a>
<a name="ln6784">    // Iterate over level vaults and run each map's epilogue.</a>
<a name="ln6785">    for (auto &amp;vault : env.level_vaults)</a>
<a name="ln6786">        vault-&gt;map.run_lua_epilogue();</a>
<a name="ln6787">}</a>
<a name="ln6788"> </a>
<a name="ln6789">//////////////////////////////////////////////////////////////////////////</a>
<a name="ln6790">// vault_placement</a>
<a name="ln6791"> </a>
<a name="ln6792">vault_placement::vault_placement()</a>
<a name="ln6793">    : pos(-1, -1), size(0, 0), orient(MAP_NONE), map(), exits(), seen(false)</a>
<a name="ln6794">{</a>
<a name="ln6795">}</a>
<a name="ln6796"> </a>
<a name="ln6797">string vault_placement::map_name_at(const coord_def &amp;where) const</a>
<a name="ln6798">{</a>
<a name="ln6799">    const coord_def offset = where - pos;</a>
<a name="ln6800">    return map.name_at(offset);</a>
<a name="ln6801">}</a>
<a name="ln6802"> </a>
<a name="ln6803">void vault_placement::reset()</a>
<a name="ln6804">{</a>
<a name="ln6805">    if (_current_temple_hash != nullptr)</a>
<a name="ln6806">        _setup_temple_altars(*_current_temple_hash);</a>
<a name="ln6807">    else</a>
<a name="ln6808">        _temple_altar_list.clear();</a>
<a name="ln6809">}</a>
<a name="ln6810"> </a>
<a name="ln6811">void vault_placement::apply_grid()</a>
<a name="ln6812">{</a>
<a name="ln6813">    if (!size.zero())</a>
<a name="ln6814">    {</a>
<a name="ln6815">        bool clear = !map.has_tag(&quot;overwrite_floor_cell&quot;);</a>
<a name="ln6816"> </a>
<a name="ln6817">        // NOTE: assumes *no* previous item (I think) or monster (definitely)</a>
<a name="ln6818">        // placement.</a>
<a name="ln6819">        for (rectangle_iterator ri(pos, pos + size - 1); ri; ++ri)</a>
<a name="ln6820">        {</a>
<a name="ln6821">            if (map.is_overwritable_layout() &amp;&amp; map_masked(*ri, MMT_VAULT))</a>
<a name="ln6822">                continue;</a>
<a name="ln6823"> </a>
<a name="ln6824">            const coord_def &amp;rp(*ri);</a>
<a name="ln6825">            const coord_def dp = rp - pos;</a>
<a name="ln6826"> </a>
<a name="ln6827">            const int feat = map.map.glyph(dp);</a>
<a name="ln6828"> </a>
<a name="ln6829">            if (feat == ' ')</a>
<a name="ln6830">                continue;</a>
<a name="ln6831"> </a>
<a name="ln6832">            const dungeon_feature_type oldgrid = grd(*ri);</a>
<a name="ln6833"> </a>
<a name="ln6834">            if (clear)</a>
<a name="ln6835">            {</a>
<a name="ln6836">                env.grid_colours(*ri) = 0;</a>
<a name="ln6837">                env.pgrid(*ri) = terrain_property_t{};</a>
<a name="ln6838">                // what about heightmap?</a>
<a name="ln6839">                tile_clear_flavour(*ri);</a>
<a name="ln6840">            }</a>
<a name="ln6841"> </a>
<a name="ln6842">            keyed_mapspec *mapsp = map.mapspec_at(dp);</a>
<a name="ln6843">            _vault_grid(*this, feat, *ri, mapsp);</a>
<a name="ln6844"> </a>
<a name="ln6845">            if (!crawl_state.generating_level)</a>
<a name="ln6846">            {</a>
<a name="ln6847">                // Have to link items each square at a time, or</a>
<a name="ln6848">                // dungeon_terrain_changed could blow up.</a>
<a name="ln6849">                link_items();</a>
<a name="ln6850">                // Init tile flavour -- dungeon_terrain_changed does</a>
<a name="ln6851">                // this too, but only if oldgrid != newgrid, so we</a>
<a name="ln6852">                // make sure here.</a>
<a name="ln6853">                tile_init_flavour(*ri);</a>
<a name="ln6854">                const dungeon_feature_type newgrid = grd(*ri);</a>
<a name="ln6855">                grd(*ri) = oldgrid;</a>
<a name="ln6856">                dungeon_terrain_changed(*ri, newgrid, true);</a>
<a name="ln6857">                remove_markers_and_listeners_at(*ri);</a>
<a name="ln6858">            }</a>
<a name="ln6859">        }</a>
<a name="ln6860"> </a>
<a name="ln6861">        // Place monsters in a second pass. Otherwise band followers</a>
<a name="ln6862">        // could be overwritten with subsequent walls.</a>
<a name="ln6863">        for (rectangle_iterator ri(pos, pos + size - 1); ri; ++ri)</a>
<a name="ln6864">        {</a>
<a name="ln6865">            if (map.is_overwritable_layout() &amp;&amp; map_masked(*ri, MMT_VAULT))</a>
<a name="ln6866">                continue;</a>
<a name="ln6867"> </a>
<a name="ln6868">            const coord_def dp = *ri - pos;</a>
<a name="ln6869"> </a>
<a name="ln6870">            const int feat = map.map.glyph(dp);</a>
<a name="ln6871">            keyed_mapspec *mapsp = map.mapspec_at(dp);</a>
<a name="ln6872"> </a>
<a name="ln6873">            _vault_grid_mons(*this, feat, *ri, mapsp);</a>
<a name="ln6874">        }</a>
<a name="ln6875"> </a>
<a name="ln6876">        map.map.apply_overlays(pos, map.is_overwritable_layout());</a>
<a name="ln6877">    }</a>
<a name="ln6878">}</a>
<a name="ln6879"> </a>
<a name="ln6880">void vault_placement::draw_at(const coord_def &amp;c)</a>
<a name="ln6881">{</a>
<a name="ln6882">    pos = c;</a>
<a name="ln6883">    apply_grid();</a>
<a name="ln6884">}</a>
<a name="ln6885"> </a>
<a name="ln6886">int vault_placement::connect(bool spotty) const</a>
<a name="ln6887">{</a>
<a name="ln6888">    int exits_placed = 0;</a>
<a name="ln6889"> </a>
<a name="ln6890">    for (auto c : exits)</a>
<a name="ln6891">    {</a>
<a name="ln6892">        if (spotty &amp;&amp; _connect_spotty(c, _feat_is_wall_floor_liquid)</a>
<a name="ln6893">            || player_in_branch(BRANCH_SHOALS) &amp;&amp; dgn_shoals_connect_point(c)</a>
<a name="ln6894">            || _connect_vault_exit(c))</a>
<a name="ln6895">        {</a>
<a name="ln6896">            exits_placed++;</a>
<a name="ln6897">        }</a>
<a name="ln6898">        else</a>
<a name="ln6899">        {</a>
<a name="ln6900">            dprf(DIAG_DNGN, &quot;Warning: failed to connect vault exit (%d;%d).&quot;,</a>
<a name="ln6901">                 c.x, c.y);</a>
<a name="ln6902">        }</a>
<a name="ln6903">    }</a>
<a name="ln6904"> </a>
<a name="ln6905">    return exits_placed;</a>
<a name="ln6906">}</a>
<a name="ln6907"> </a>
<a name="ln6908">// Checks the resultant feature type of the map glyph, after applying KFEAT</a>
<a name="ln6909">// and so forth. Unfortunately there is a certain amount of duplication of</a>
<a name="ln6910">// the code path in apply_grid; but actual modifications to the level</a>
<a name="ln6911">// are so intertwined with that code path it would be actually quite messy</a>
<a name="ln6912">// to try and avoid the duplication.</a>
<a name="ln6913">dungeon_feature_type vault_placement::feature_at(const coord_def &amp;c)</a>
<a name="ln6914">{</a>
<a name="ln6915">    // Can't check outside bounds of vault</a>
<a name="ln6916">    if (size.zero() || c.x &gt; size.x || c.y &gt; size.y)</a>
<a name="ln6917">        return NUM_FEATURES;</a>
<a name="ln6918"> </a>
<a name="ln6919">    const int feat = map.map.glyph(c);</a>
<a name="ln6920"> </a>
<a name="ln6921">    //XXX: perhaps this should really be NUM_FEATURES, but there are crashes.</a>
<a name="ln6922">    if (feat == ' ')</a>
<a name="ln6923">        return DNGN_FLOOR;</a>
<a name="ln6924"> </a>
<a name="ln6925">    keyed_mapspec *mapsp = map.mapspec_at(c);</a>
<a name="ln6926">    return _vault_inspect(*this, feat, mapsp);</a>
<a name="ln6927">}</a>
<a name="ln6928"> </a>
<a name="ln6929">bool vault_placement::is_space(const coord_def &amp;c)</a>
<a name="ln6930">{</a>
<a name="ln6931">    // Can't check outside bounds of vault</a>
<a name="ln6932">    if (size.zero() || c.x &gt; size.x || c.y &gt; size.y)</a>
<a name="ln6933">        return false;</a>
<a name="ln6934"> </a>
<a name="ln6935">    const int feat = map.map.glyph(c);</a>
<a name="ln6936">    return feat == ' ';</a>
<a name="ln6937">}</a>
<a name="ln6938">bool vault_placement::is_exit(const coord_def &amp;c)</a>
<a name="ln6939">{</a>
<a name="ln6940">    // Can't check outside bounds of vault</a>
<a name="ln6941">    if (size.zero() || c.x &gt; size.x || c.y &gt; size.y)</a>
<a name="ln6942">        return false;</a>
<a name="ln6943"> </a>
<a name="ln6944">    const int feat = map.map.glyph(c);</a>
<a name="ln6945">    return feat == '@';</a>
<a name="ln6946">}</a>
<a name="ln6947">static dungeon_feature_type _vault_inspect(vault_placement &amp;place,</a>
<a name="ln6948">                        int vgrid, keyed_mapspec *mapsp)</a>
<a name="ln6949">{</a>
<a name="ln6950">    // The two functions called are</a>
<a name="ln6951">    if (mapsp &amp;&amp; mapsp-&gt;replaces_glyph())</a>
<a name="ln6952">        return _vault_inspect_mapspec(place, *mapsp);</a>
<a name="ln6953">    else</a>
<a name="ln6954">        return _vault_inspect_glyph(vgrid);</a>
<a name="ln6955">}</a>
<a name="ln6956"> </a>
<a name="ln6957">static dungeon_feature_type _vault_inspect_mapspec(vault_placement &amp;place,</a>
<a name="ln6958">                                                   keyed_mapspec&amp; mapsp)</a>
<a name="ln6959">{</a>
<a name="ln6960">    UNUSED(place);</a>
<a name="ln6961">    dungeon_feature_type found = NUM_FEATURES;</a>
<a name="ln6962">    const feature_spec f = mapsp.get_feat();</a>
<a name="ln6963">    if (f.trap)</a>
<a name="ln6964">        found = trap_feature(f.trap-&gt;tr_type);</a>
<a name="ln6965">    else if (f.feat &gt;= 0)</a>
<a name="ln6966">        found = static_cast&lt;dungeon_feature_type&gt;(f.feat);</a>
<a name="ln6967">    else if (f.glyph &gt;= 0)</a>
<a name="ln6968">        found = _vault_inspect_glyph(f.glyph);</a>
<a name="ln6969">    else if (f.shop)</a>
<a name="ln6970">        found = DNGN_ENTER_SHOP;</a>
<a name="ln6971">    else</a>
<a name="ln6972">        found = DNGN_FLOOR;</a>
<a name="ln6973"> </a>
<a name="ln6974">    return found;</a>
<a name="ln6975">}</a>
<a name="ln6976"> </a>
<a name="ln6977">static dungeon_feature_type _vault_inspect_glyph(int vgrid)</a>
<a name="ln6978">{</a>
<a name="ln6979">    // Get the base feature according to the glyph</a>
<a name="ln6980">    dungeon_feature_type found = NUM_FEATURES;</a>
<a name="ln6981">    if (vgrid != -1)</a>
<a name="ln6982">        found = _glyph_to_feat(vgrid);</a>
<a name="ln6983"> </a>
<a name="ln6984">    // If it's an altar for an unavailable god then it will get turned into floor by _vault_grid_glyph</a>
<a name="ln6985">    if (feat_is_altar(found)</a>
<a name="ln6986">        &amp;&amp; is_unavailable_god(feat_altar_god(found)))</a>
<a name="ln6987">    {</a>
<a name="ln6988">        found = DNGN_FLOOR;</a>
<a name="ln6989">    }</a>
<a name="ln6990"> </a>
<a name="ln6991">    return found;</a>
<a name="ln6992">}</a>
<a name="ln6993"> </a>
<a name="ln6994">static void _remember_vault_placement(const vault_placement &amp;place)</a>
<a name="ln6995">{</a>
<a name="ln6996">    UNUSED(place);</a>
<a name="ln6997">#ifdef DEBUG_STATISTICS</a>
<a name="ln6998">    _you_all_vault_list.push_back(place.map.name);</a>
<a name="ln6999">#endif</a>
<a name="ln7000">}</a>
<a name="ln7001"> </a>
<a name="ln7002">string dump_vault_maps()</a>
<a name="ln7003">{</a>
<a name="ln7004">    string out = &quot;&quot;;</a>
<a name="ln7005"> </a>
<a name="ln7006">    vector&lt;level_id&gt; levels = all_dungeon_ids();</a>
<a name="ln7007"> </a>
<a name="ln7008">    for (const level_id &amp;lid : levels)</a>
<a name="ln7009">    {</a>
<a name="ln7010">        // n.b. portal vaults get cleared from here, so won't show up.</a>
<a name="ln7011">        // kind of spammy in wizmode. To test non-wizmode, use &amp;ctrl-y</a>
<a name="ln7012">        if (!you.wizard &amp;&amp; (!you.level_visited(lid)</a>
<a name="ln7013">                            || !you.vault_list.count(lid))</a>
<a name="ln7014">            || branch_is_unfinished(lid.branch))</a>
<a name="ln7015">        {</a>
<a name="ln7016">            continue;</a>
<a name="ln7017">        }</a>
<a name="ln7018"> </a>
<a name="ln7019">        if (you.wizard)</a>
<a name="ln7020">        {</a>
<a name="ln7021">            // because the save is already gone at the point where we are</a>
<a name="ln7022">            // printing a morgue, this check isn't reliable. Ignore it.</a>
<a name="ln7023">            if (!is_existing_level(lid) &amp;&amp; you.save)</a>
<a name="ln7024">            {</a>
<a name="ln7025">                out += &quot;[-gen]      &quot;;</a>
<a name="ln7026">                if (!you.vault_list.count(lid))</a>
<a name="ln7027">                {</a>
<a name="ln7028">                    out +=  lid.describe() + &quot;\n&quot;;</a>
<a name="ln7029">                    continue;</a>
<a name="ln7030">                }</a>
<a name="ln7031">            }</a>
<a name="ln7032">            else</a>
<a name="ln7033">                out += you.level_visited(lid) ? &quot;[+gen,+vis] &quot; : &quot;[+gen,-vis] &quot;;</a>
<a name="ln7034">        }</a>
<a name="ln7035">        out += lid.describe();</a>
<a name="ln7036">        vector&lt;string&gt; &amp;maps(you.vault_list[lid]);</a>
<a name="ln7037">        if (maps.size() == 0)</a>
<a name="ln7038">        {</a>
<a name="ln7039">            out += &quot;\n&quot;;</a>
<a name="ln7040">            continue;</a>
<a name="ln7041">        }</a>
<a name="ln7042"> </a>
<a name="ln7043">        out += &quot;: &quot; + string(max(8 - int(lid.describe().length()), 0), ' ');</a>
<a name="ln7044"> </a>
<a name="ln7045">        // TODO: some way of showing no_dump maps in wizmode?</a>
<a name="ln7046"> </a>
<a name="ln7047">        string vaults = comma_separated_line(maps.begin(), maps.end(), &quot;, &quot;);</a>
<a name="ln7048">        out += wordwrap_line(vaults, you.wizard ? 58 : 70) + &quot;\n&quot;;</a>
<a name="ln7049">        while (!vaults.empty())</a>
<a name="ln7050">        {</a>
<a name="ln7051">            out += string(you.wizard ? 22 : 10, ' ')</a>
<a name="ln7052">                    + wordwrap_line(vaults, you.wizard ? 58 : 70, false) + &quot;\n&quot;;</a>
<a name="ln7053">        }</a>
<a name="ln7054"> </a>
<a name="ln7055">    }</a>
<a name="ln7056">    return out;</a>
<a name="ln7057">}</a>
<a name="ln7058"> </a>
<a name="ln7059">///////////////////////////////////////////////////////////////////////////</a>
<a name="ln7060">// vault_place_iterator</a>
<a name="ln7061"> </a>
<a name="ln7062">vault_place_iterator::vault_place_iterator(const vault_placement &amp;vp)</a>
<a name="ln7063">    : vault_place(vp), pos(vp.pos), tl(vp.pos), br(vp.pos + vp.size - 1)</a>
<a name="ln7064">{</a>
<a name="ln7065">    --pos.x;</a>
<a name="ln7066">    ++*this;</a>
<a name="ln7067">}</a>
<a name="ln7068"> </a>
<a name="ln7069">vault_place_iterator::operator bool () const</a>
<a name="ln7070">{</a>
<a name="ln7071">    return pos.y &lt;= br.y &amp;&amp; pos.x &lt;= br.x;</a>
<a name="ln7072">}</a>
<a name="ln7073"> </a>
<a name="ln7074">coord_def vault_place_iterator::operator * () const</a>
<a name="ln7075">{</a>
<a name="ln7076">    return pos;</a>
<a name="ln7077">}</a>
<a name="ln7078"> </a>
<a name="ln7079">const coord_def *vault_place_iterator::operator -&gt; () const</a>
<a name="ln7080">{</a>
<a name="ln7081">    return &amp;pos;</a>
<a name="ln7082">}</a>
<a name="ln7083"> </a>
<a name="ln7084">vault_place_iterator &amp;vault_place_iterator::operator ++ ()</a>
<a name="ln7085">{</a>
<a name="ln7086">    while (pos.y &lt;= br.y)</a>
<a name="ln7087">    {</a>
<a name="ln7088">        if (++pos.x &gt; br.x)</a>
<a name="ln7089">        {</a>
<a name="ln7090">            pos.x = tl.x;</a>
<a name="ln7091">            ++pos.y;</a>
<a name="ln7092">        }</a>
<a name="ln7093">        if (pos.y &lt;= br.y &amp;&amp; vault_place.map.in_map(pos - tl))</a>
<a name="ln7094">            break;</a>
<a name="ln7095">    }</a>
<a name="ln7096">    return *this;</a>
<a name="ln7097">}</a>
<a name="ln7098"> </a>
<a name="ln7099">vault_place_iterator vault_place_iterator::operator ++ (int)</a>
<a name="ln7100">{</a>
<a name="ln7101">    const vault_place_iterator copy = *this;</a>
<a name="ln7102">    ++*this;</a>
<a name="ln7103">    return copy;</a>
<a name="ln7104">}</a>
<a name="ln7105"> </a>
<a name="ln7106">//////////////////////////////////////////////////////////////////////////</a>
<a name="ln7107">// unwind_vault_placement_mask</a>
<a name="ln7108"> </a>
<a name="ln7109">unwind_vault_placement_mask::unwind_vault_placement_mask(const map_bitmask *mask)</a>
<a name="ln7110">    : oldmask(Vault_Placement_Mask)</a>
<a name="ln7111">{</a>
<a name="ln7112">    Vault_Placement_Mask = mask;</a>
<a name="ln7113">}</a>
<a name="ln7114"> </a>
<a name="ln7115">unwind_vault_placement_mask::~unwind_vault_placement_mask()</a>
<a name="ln7116">{</a>
<a name="ln7117">    Vault_Placement_Mask = oldmask;</a>
<a name="ln7118">}</a>
<a name="ln7119"> </a>
<a name="ln7120">// mark all unexplorable squares, count the rest</a>
<a name="ln7121">static void _calc_density()</a>
<a name="ln7122">{</a>
<a name="ln7123">    int open = 0;</a>
<a name="ln7124">    for (rectangle_iterator ri(0); ri; ++ri)</a>
<a name="ln7125">    {</a>
<a name="ln7126">        // If for some reason a level gets modified afterwards, dug-out</a>
<a name="ln7127">        // places in unmodified parts should not suddenly become explorable.</a>
<a name="ln7128">        if (!testbits(env.pgrid(*ri), FPROP_SEEN_OR_NOEXP))</a>
<a name="ln7129">            for (adjacent_iterator ai(*ri, false); ai; ++ai)</a>
<a name="ln7130">                if (feat_has_solid_floor(grd(*ai)))</a>
<a name="ln7131">                {</a>
<a name="ln7132">                    open++;</a>
<a name="ln7133">                    goto out;</a>
<a name="ln7134">                }</a>
<a name="ln7135">        env.pgrid(*ri) |= FPROP_SEEN_OR_NOEXP;</a>
<a name="ln7136">    out:;</a>
<a name="ln7137">    }</a>
<a name="ln7138"> </a>
<a name="ln7139">    dprf(DIAG_DNGN, &quot;Level density: %d&quot;, open);</a>
<a name="ln7140">    env.density = open;</a>
<a name="ln7141">}</a>
<a name="ln7142"> </a>
<a name="ln7143">// Mark all solid squares as no_tele so that digging doesn't influence</a>
<a name="ln7144">// random teleportation.</a>
<a name="ln7145">static void _mark_solid_squares()</a>
<a name="ln7146">{</a>
<a name="ln7147">    for (rectangle_iterator ri(0); ri; ++ri)</a>
<a name="ln7148">        if (feat_is_solid(grd(*ri)))</a>
<a name="ln7149">            env.pgrid(*ri) |= FPROP_NO_TELE_INTO;</a>
<a name="ln7150">}</a>

</code></pre>
<div class="balloon" rel="982"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v768/" target="_blank">V768</a> The variable 'fill' is of enum type. It is odd that it is used as a variable of a Boolean-type.</p></div>
<div class="balloon" rel="2301"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v648/" target="_blank">V648</a> Priority of the '&&' operation is higher than that of the '||' operation.</p></div>
<div class="balloon" rel="3704"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v648/" target="_blank">V648</a> Priority of the '&&' operation is higher than that of the '||' operation.</p></div>
<div class="balloon" rel="5996"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v648/" target="_blank">V648</a> Priority of the '&&' operation is higher than that of the '||' operation.</p></div>
<div class="balloon" rel="6146"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v522/" target="_blank">V522</a> There might be dereferencing of a potential null pointer.</p></div>
<div class="balloon" rel="6294"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v560/" target="_blank">V560</a> A part of conditional expression is always false: stair_to_find == DNGN_FLOOR.</p></div>
<div class="balloon" rel="6752"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v547/" target="_blank">V547</a> Expression '!stairs_unique' is always false.</p></div>
<div class="balloon" rel="2810"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v730/" target="_blank">V730</a> Not all members of a class are initialized inside the constructor. Consider inspecting: label.</p></div>

<link rel="stylesheet" href="highlight.css">
<script src="highlight.pack.js"></script>
<script src="highlightjs-line-numbers.js"></script>
<script>hljs.initHighlightingOnLoad();</script>
<script>hljs.initLineNumbersOnLoad();</script>
<script>
  $(document).ready(function() {
      $('.balloon').each(function () {
          var bl = $(this);
          var line = bl.attr('rel');
          var text = $('a[name="ln'+line+'"]').text();

          var space_count = 0;
          for(var i = 0; i<text.length; i++){
              var char = text[i];
              if((char !== ' ')&&(char !== '\t'))break;
              if(char === '\t')space_count++;
              space_count++;
          }

          bl.css('margin-left', space_count*8);
          $('a[name="ln'+line+'"]').after(bl);
      });

      window.location = window.location;
  });
</script>
</body>
</html>
