
<html>
<head>

  <meta http-equiv="Content-Type" content="text/html; charset=US-ASCII" />
  <title>decks.cc</title>

  <link rel="stylesheet" href="../style.css"/>
  <script src="../jquery-3.2.1.min.js"></script>
</head>
<body>

<pre><code class = "cpp">
<a name="ln1">/**</a>
<a name="ln2"> * @file</a>
<a name="ln3"> * @brief Functions with decks of cards.</a>
<a name="ln4">**/</a>
<a name="ln5"> </a>
<a name="ln6">#include &quot;AppHdr.h&quot;</a>
<a name="ln7"> </a>
<a name="ln8">#include &quot;decks.h&quot;</a>
<a name="ln9"> </a>
<a name="ln10">#include &lt;algorithm&gt;</a>
<a name="ln11">#include &lt;iostream&gt;</a>
<a name="ln12">#include &lt;iterator&gt;</a>
<a name="ln13">#include &lt;sstream&gt;</a>
<a name="ln14">#include &lt;unordered_set&gt;</a>
<a name="ln15"> </a>
<a name="ln16">#include &quot;ability.h&quot;</a>
<a name="ln17">#include &quot;abyss.h&quot;</a>
<a name="ln18">#include &quot;artefact.h&quot;</a>
<a name="ln19">#include &quot;beam.h&quot;</a>
<a name="ln20">#include &quot;cloud.h&quot;</a>
<a name="ln21">#include &quot;coordit.h&quot;</a>
<a name="ln22">#include &quot;dactions.h&quot;</a>
<a name="ln23">#include &quot;database.h&quot;</a>
<a name="ln24">#include &quot;describe.h&quot;</a>
<a name="ln25">#include &quot;directn.h&quot;</a>
<a name="ln26">#include &quot;dungeon.h&quot;</a>
<a name="ln27">#include &quot;evoke.h&quot;</a>
<a name="ln28">#include &quot;food.h&quot;</a>
<a name="ln29">#include &quot;ghost.h&quot;</a>
<a name="ln30">#include &quot;god-passive.h&quot; // passive_t::no_haste</a>
<a name="ln31">#include &quot;god-wrath.h&quot;</a>
<a name="ln32">#include &quot;invent.h&quot;</a>
<a name="ln33">#include &quot;item-prop.h&quot;</a>
<a name="ln34">#include &quot;item-status-flag-type.h&quot;</a>
<a name="ln35">#include &quot;items.h&quot;</a>
<a name="ln36">#include &quot;libutil.h&quot;</a>
<a name="ln37">#include &quot;macro.h&quot;</a>
<a name="ln38">#include &quot;message.h&quot;</a>
<a name="ln39">#include &quot;mon-cast.h&quot;</a>
<a name="ln40">#include &quot;mon-clone.h&quot;</a>
<a name="ln41">#include &quot;mon-place.h&quot;</a>
<a name="ln42">#include &quot;mon-poly.h&quot;</a>
<a name="ln43">#include &quot;mon-project.h&quot;</a>
<a name="ln44">#include &quot;mon-util.h&quot;</a>
<a name="ln45">#include &quot;mutation.h&quot;</a>
<a name="ln46">#include &quot;notes.h&quot;</a>
<a name="ln47">#include &quot;output.h&quot;</a>
<a name="ln48">#include &quot;prompt.h&quot;</a>
<a name="ln49">#include &quot;random.h&quot;</a>
<a name="ln50">#include &quot;religion.h&quot;</a>
<a name="ln51">#include &quot;spl-clouds.h&quot;</a>
<a name="ln52">#include &quot;spl-goditem.h&quot;</a>
<a name="ln53">#include &quot;spl-miscast.h&quot;</a>
<a name="ln54">#include &quot;spl-monench.h&quot;</a>
<a name="ln55">#include &quot;spl-wpnench.h&quot;</a>
<a name="ln56">#include &quot;state.h&quot;</a>
<a name="ln57">#include &quot;stringutil.h&quot;</a>
<a name="ln58">#include &quot;teleport.h&quot;</a>
<a name="ln59">#include &quot;terrain.h&quot;</a>
<a name="ln60">#include &quot;transform.h&quot;</a>
<a name="ln61">#include &quot;traps.h&quot;</a>
<a name="ln62">#include &quot;uncancel.h&quot;</a>
<a name="ln63">#include &quot;unicode.h&quot;</a>
<a name="ln64">#include &quot;view.h&quot;</a>
<a name="ln65">#include &quot;viewchar.h&quot;</a>
<a name="ln66">#include &quot;xom.h&quot;</a>
<a name="ln67"> </a>
<a name="ln68">using namespace ui;</a>
<a name="ln69"> </a>
<a name="ln70">typedef map&lt;card_type, int&gt; deck_archetype;</a>
<a name="ln71"> </a>
<a name="ln72">deck_archetype deck_of_escape =</a>
<a name="ln73">{</a>
<a name="ln74">    { CARD_TOMB,       5 },</a>
<a name="ln75">    { CARD_EXILE,      1 },</a>
<a name="ln76">    { CARD_ELIXIR,     5 },</a>
<a name="ln77">    { CARD_CLOUD,      5 },</a>
<a name="ln78">    { CARD_VELOCITY,   5 },</a>
<a name="ln79">    { CARD_SHAFT,      5 },</a>
<a name="ln80">};</a>
<a name="ln81"> </a>
<a name="ln82">deck_archetype deck_of_destruction =</a>
<a name="ln83">{</a>
<a name="ln84">    { CARD_VITRIOL,    5 },</a>
<a name="ln85">    { CARD_PAIN,       5 },</a>
<a name="ln86">    { CARD_ORB,        5 },</a>
<a name="ln87">    { CARD_DEGEN,      3 },</a>
<a name="ln88">    { CARD_WILD_MAGIC, 5 },</a>
<a name="ln89">    { CARD_STORM,      5 },</a>
<a name="ln90">};</a>
<a name="ln91"> </a>
<a name="ln92">deck_archetype deck_of_summoning =</a>
<a name="ln93">{</a>
<a name="ln94">    { CARD_ELEMENTS,        5 },</a>
<a name="ln95">    { CARD_SUMMON_DEMON,    5 },</a>
<a name="ln96">    { CARD_SUMMON_WEAPON,   5 },</a>
<a name="ln97">    { CARD_SUMMON_FLYING,   5 },</a>
<a name="ln98">    { CARD_RANGERS,         5 },</a>
<a name="ln99">    { CARD_ILLUSION,        5 },</a>
<a name="ln100">};</a>
<a name="ln101"> </a>
<a name="ln102">deck_archetype deck_of_punishment =</a>
<a name="ln103">{</a>
<a name="ln104">    { CARD_WRAITH,     5 },</a>
<a name="ln105">    { CARD_WRATH,      5 },</a>
<a name="ln106">    { CARD_FAMINE,     5 },</a>
<a name="ln107">    { CARD_SWINE,      5 },</a>
<a name="ln108">    { CARD_TORMENT,    5 },</a>
<a name="ln109">};</a>
<a name="ln110"> </a>
<a name="ln111">struct deck_type_data</a>
<a name="ln112">{</a>
<a name="ln113">    string name;</a>
<a name="ln114">    string flavour;</a>
<a name="ln115">    /// The list of cards this deck contains.</a>
<a name="ln116">    deck_archetype cards;</a>
<a name="ln117">    int deck_max;</a>
<a name="ln118">};</a>
<a name="ln119"> </a>
<a name="ln120">static map&lt;deck_type, deck_type_data&gt; all_decks =</a>
<a name="ln121">{</a>
<a name="ln122">    { DECK_OF_ESCAPE, {</a>
<a name="ln123">        &quot;escape&quot;, &quot;mainly dealing with various forms of escape.&quot;,</a>
<a name="ln124">        deck_of_escape,</a>
<a name="ln125">        13,</a>
<a name="ln126">    } },</a>
<a name="ln127">    { DECK_OF_DESTRUCTION, {</a>
<a name="ln128">        &quot;destruction&quot;, &quot;most of which hurl death and destruction &quot;</a>
<a name="ln129">            &quot;at one's foes (or, if unlucky, at oneself).&quot;,</a>
<a name="ln130">        deck_of_destruction,</a>
<a name="ln131">        26,</a>
<a name="ln132">    } },</a>
<a name="ln133">    { DECK_OF_SUMMONING, {</a>
<a name="ln134">        &quot;summoning&quot;, &quot;depicting a range of weird and wonderful creatures.&quot;,</a>
<a name="ln135">        deck_of_summoning,</a>
<a name="ln136">        13,</a>
<a name="ln137">    } },</a>
<a name="ln138">    { DECK_OF_PUNISHMENT, {</a>
<a name="ln139">        &quot;punishment&quot;, &quot;which wreak havoc on the user.&quot;, deck_of_punishment,</a>
<a name="ln140">        0, // Not a user deck</a>
<a name="ln141">    } },</a>
<a name="ln142">};</a>
<a name="ln143"> </a>
<a name="ln144">vector&lt;ability_type&gt; deck_ability = {</a>
<a name="ln145">    ABIL_NEMELEX_DRAW_ESCAPE,</a>
<a name="ln146">    ABIL_NEMELEX_DRAW_DESTRUCTION,</a>
<a name="ln147">    ABIL_NEMELEX_DRAW_SUMMONING,</a>
<a name="ln148">    ABIL_NON_ABILITY,</a>
<a name="ln149">    ABIL_NEMELEX_DRAW_STACK</a>
<a name="ln150">};</a>
<a name="ln151"> </a>
<a name="ln152">const char* card_name(card_type card)</a>
<a name="ln153">{</a>
<a name="ln154">    switch (card)</a>
<a name="ln155">    {</a>
<a name="ln156">    case CARD_VELOCITY:        return &quot;Velocity&quot;;</a>
<a name="ln157">    case CARD_EXILE:           return &quot;Exile&quot;;</a>
<a name="ln158">    case CARD_ELIXIR:          return &quot;the Elixir&quot;;</a>
<a name="ln159">    case CARD_STAIRS:          return &quot;the Stairs&quot;;</a>
<a name="ln160">    case CARD_TOMB:            return &quot;the Tomb&quot;;</a>
<a name="ln161">    case CARD_WILD_MAGIC:      return &quot;Wild Magic&quot;;</a>
<a name="ln162">    case CARD_ELEMENTS:        return &quot;the Elements&quot;;</a>
<a name="ln163">    case CARD_SUMMON_DEMON:    return &quot;the Pentagram&quot;;</a>
<a name="ln164">    case CARD_SUMMON_WEAPON:   return &quot;the Dance&quot;;</a>
<a name="ln165">    case CARD_SUMMON_FLYING:   return &quot;Foxfire&quot;;</a>
<a name="ln166">    case CARD_RANGERS:         return &quot;the Rangers&quot;;</a>
<a name="ln167">    case CARD_SHAFT:           return &quot;the Shaft&quot;;</a>
<a name="ln168">    case CARD_VITRIOL:         return &quot;Vitriol&quot;;</a>
<a name="ln169">    case CARD_CLOUD:           return &quot;the Cloud&quot;;</a>
<a name="ln170">    case CARD_STORM:           return &quot;the Storm&quot;;</a>
<a name="ln171">    case CARD_PAIN:            return &quot;Pain&quot;;</a>
<a name="ln172">    case CARD_TORMENT:         return &quot;Torment&quot;;</a>
<a name="ln173">    case CARD_WRATH:           return &quot;Wrath&quot;;</a>
<a name="ln174">    case CARD_WRAITH:          return &quot;the Wraith&quot;;</a>
<a name="ln175">    case CARD_SWINE:           return &quot;the Swine&quot;;</a>
<a name="ln176">    case CARD_ORB:             return &quot;the Orb&quot;;</a>
<a name="ln177">    case CARD_ILLUSION:        return &quot;the Illusion&quot;;</a>
<a name="ln178">    case CARD_DEGEN:           return &quot;Degeneration&quot;;</a>
<a name="ln179">    case CARD_FAMINE:          return &quot;Famine&quot;;</a>
<a name="ln180"> </a>
<a name="ln181">    case NUM_CARDS:            return &quot;a buggy card&quot;;</a>
<a name="ln182">    }</a>
<a name="ln183">    return &quot;a very buggy card&quot;;</a>
<a name="ln184">}</a>
<a name="ln185"> </a>
<a name="ln186">card_type name_to_card(string name)</a>
<a name="ln187">{</a>
<a name="ln188">    for (int i = 0; i &lt; NUM_CARDS; i++)</a>
<a name="ln189">    {</a>
<a name="ln190">        if (card_name(static_cast&lt;card_type&gt;(i)) == name)</a>
<a name="ln191">            return static_cast&lt;card_type&gt;(i);</a>
<a name="ln192">    }</a>
<a name="ln193">    return NUM_CARDS;</a>
<a name="ln194">}</a>
<a name="ln195"> </a>
<a name="ln196">static const deck_archetype _cards_in_deck(deck_type deck)</a>
<a name="ln197">{</a>
<a name="ln198">    deck_type_data *deck_data = map_find(all_decks, deck);</a>
<a name="ln199"> </a>
<a name="ln200">    if (deck_data)</a>
<a name="ln201">        return deck_data-&gt;cards;</a>
<a name="ln202"> </a>
<a name="ln203">#ifdef ASSERTS</a>
<a name="ln204">    die(&quot;No cards found for %u&quot;, unsigned(deck));</a>
<a name="ln205">#endif</a>
<a name="ln206">    return {};</a>
<a name="ln207">}</a>
<a name="ln208"> </a>
<a name="ln209">const string stack_contents()</a>
<a name="ln210">{</a>
<a name="ln211">    const auto&amp; stack = you.props[NEMELEX_STACK_KEY].get_vector();</a>
<a name="ln212"> </a>
<a name="ln213">    string output = &quot;&quot;;</a>
<a name="ln214">    output += comma_separated_fn(</a>
<a name="ln215">                reverse_iterator&lt;CrawlVector::const_iterator&gt;(stack.end()),</a>
<a name="ln216">                reverse_iterator&lt;CrawlVector::const_iterator&gt;(stack.begin()),</a>
<a name="ln217">              [](const CrawlStoreValue&amp; card) { return card_name((card_type)card.get_int()); });</a>
<a name="ln218">    if (!stack.empty())</a>
<a name="ln219">        output += &quot;.&quot;;</a>
<a name="ln220"> </a>
<a name="ln221">    return output;</a>
<a name="ln222">}</a>
<a name="ln223"> </a>
<a name="ln224">const string stack_top()</a>
<a name="ln225">{</a>
<a name="ln226">    const auto&amp; stack = you.props[NEMELEX_STACK_KEY].get_vector();</a>
<a name="ln227">    if (stack.empty())</a>
<a name="ln228">        return &quot;none&quot;;</a>
<a name="ln229">    else</a>
<a name="ln230">        return card_name((card_type) stack[stack.size() - 1].get_int());</a>
<a name="ln231">}</a>
<a name="ln232"> </a>
<a name="ln233">const string deck_contents(deck_type deck)</a>
<a name="ln234">{</a>
<a name="ln235">    if (deck == DECK_STACK)</a>
<a name="ln236">        return &quot;Remaining cards: &quot; + stack_contents();</a>
<a name="ln237"> </a>
<a name="ln238">    string output = &quot;It may contain the following cards: &quot;;</a>
<a name="ln239"> </a>
<a name="ln240">    // This way of doing things is intended to prevent a card</a>
<a name="ln241">    // that appears in multiple subdecks from showing up twice in the</a>
<a name="ln242">    // output.</a>
<a name="ln243">    set&lt;card_type&gt; cards;</a>
<a name="ln244">    const deck_archetype &amp;pdeck =_cards_in_deck(deck);</a>
<a name="ln245">    for (const auto&amp; cww : pdeck)</a>
<a name="ln246">        cards.insert(cww.first);</a>
<a name="ln247"> </a>
<a name="ln248">    output += comma_separated_fn(cards.begin(), cards.end(), card_name);</a>
<a name="ln249">    output += &quot;.&quot;;</a>
<a name="ln250"> </a>
<a name="ln251">    return output;</a>
<a name="ln252">}</a>
<a name="ln253"> </a>
<a name="ln254">const string deck_flavour(deck_type deck)</a>
<a name="ln255">{</a>
<a name="ln256">    if (deck == DECK_STACK)</a>
<a name="ln257">        return &quot;set aside for later.&quot;;</a>
<a name="ln258"> </a>
<a name="ln259">    deck_type_data* deck_data = map_find(all_decks, deck);</a>
<a name="ln260"> </a>
<a name="ln261">    if (deck_data)</a>
<a name="ln262">        return deck_data-&gt;flavour;</a>
<a name="ln263"> </a>
<a name="ln264">    return &quot;&quot;;</a>
<a name="ln265">}</a>
<a name="ln266"> </a>
<a name="ln267">static card_type _random_card(deck_type deck)</a>
<a name="ln268">{</a>
<a name="ln269">    const deck_archetype &amp;pdeck = _cards_in_deck(deck);</a>
<a name="ln270">    return *random_choose_weighted(pdeck);</a>
<a name="ln271">}</a>
<a name="ln272"> </a>
<a name="ln273">int deck_cards(deck_type deck)</a>
<a name="ln274">{</a>
<a name="ln275">    return deck == DECK_STACK ? you.props[NEMELEX_STACK_KEY].get_vector().size()</a>
<a name="ln276">                              : you.props[deck_name(deck)].get_int();</a>
<a name="ln277">}</a>
<a name="ln278"> </a>
<a name="ln279">bool gift_cards()</a>
<a name="ln280">{</a>
<a name="ln281">    const int deal = random_range(MIN_GIFT_CARDS, MAX_GIFT_CARDS);</a>
<a name="ln282">    bool dealt_cards = false;</a>
<a name="ln283"> </a>
<a name="ln284">    for (int i = 0; i &lt; deal; i++)</a>
<a name="ln285">    {</a>
<a name="ln286">        deck_type choice = random_choose_weighted(</a>
<a name="ln287">                                        3, DECK_OF_DESTRUCTION,</a>
<a name="ln288">                                        1, DECK_OF_SUMMONING,</a>
<a name="ln289">                                        1, DECK_OF_ESCAPE);</a>
<a name="ln290">        if (deck_cards(choice) &lt; all_decks[choice].deck_max)</a>
<a name="ln291">        {</a>
<a name="ln292">            you.props[deck_name(choice)]++;</a>
<a name="ln293">            dealt_cards = true;</a>
<a name="ln294">        }</a>
<a name="ln295">    }</a>
<a name="ln296"> </a>
<a name="ln297">    return dealt_cards;</a>
<a name="ln298">}</a>
<a name="ln299"> </a>
<a name="ln300">void reset_cards()</a>
<a name="ln301">{</a>
<a name="ln302">    for (int i = FIRST_PLAYER_DECK; i &lt;= LAST_PLAYER_DECK; i++)</a>
<a name="ln303">        you.props[deck_name((deck_type) i)] = 0;</a>
<a name="ln304">    you.props[NEMELEX_STACK_KEY].get_vector().clear();</a>
<a name="ln305">}</a>
<a name="ln306"> </a>
<a name="ln307">string deck_summary()</a>
<a name="ln308">{</a>
<a name="ln309">    vector&lt;string&gt; stats;</a>
<a name="ln310">    for (int i = FIRST_PLAYER_DECK; i &lt;= LAST_PLAYER_DECK; i++)</a>
<a name="ln311">    {</a>
<a name="ln312">        int cards = deck_cards((deck_type) i);</a>
<a name="ln313">        const deck_type_data *deck_data = map_find(all_decks, (deck_type) i);</a>
<a name="ln314">        const string name = deck_data ? deck_data-&gt;name : &quot;bugginess&quot;;</a>
<a name="ln315">        if (cards)</a>
<a name="ln316">        {</a>
<a name="ln317">            stats.push_back(make_stringf(&quot;%d %s card%s&quot;, cards,</a>
<a name="ln318">               name.c_str(), cards == 1 ? &quot;&quot; : &quot;s&quot;));</a>
<a name="ln319">        }</a>
<a name="ln320">    }</a>
<a name="ln321">    return comma_separated_line(stats.begin(), stats.end());</a>
<a name="ln322">}</a>
<a name="ln323"> </a>
<a name="ln324">string which_decks(card_type card)</a>
<a name="ln325">{</a>
<a name="ln326">    vector&lt;string&gt; decks;</a>
<a name="ln327">    string output = &quot;\n&quot;;</a>
<a name="ln328">    bool punishment = false;</a>
<a name="ln329">    for (auto &amp;deck_data : all_decks)</a>
<a name="ln330">    {</a>
<a name="ln331">        if (!deck_data.second.cards.count(card))</a>
<a name="ln332">            continue;</a>
<a name="ln333"> </a>
<a name="ln334">        if (deck_data.first == DECK_OF_PUNISHMENT)</a>
<a name="ln335">            punishment = true;</a>
<a name="ln336">        else</a>
<a name="ln337">            decks.push_back(deck_data.second.name);</a>
<a name="ln338">    }</a>
<a name="ln339"> </a>
<a name="ln340">    if (!decks.empty())</a>
<a name="ln341">    {</a>
<a name="ln342">        output += &quot;It is found in decks of &quot;</a>
<a name="ln343">               +  comma_separated_line(decks.begin(), decks.end());</a>
<a name="ln344">        if (punishment)</a>
<a name="ln345">            output += &quot;, or in Nemelex Xobeh's deck of punishment&quot;;</a>
<a name="ln346">        output += &quot;.&quot;;</a>
<a name="ln347">    }</a>
<a name="ln348">    else if (punishment)</a>
<a name="ln349">    {</a>
<a name="ln350">        output += &quot;It is only found in Nemelex Xobeh's deck of &quot;</a>
<a name="ln351">                  &quot;punishment.&quot;;</a>
<a name="ln352">    }</a>
<a name="ln353">    else</a>
<a name="ln354">        output += &quot;It is normally not part of any deck.&quot;;</a>
<a name="ln355"> </a>
<a name="ln356">    return output;</a>
<a name="ln357">}</a>
<a name="ln358"> </a>
<a name="ln359">static void _describe_cards(CrawlVector&amp; cards)</a>
<a name="ln360">{</a>
<a name="ln361">    ASSERT(!cards.empty());</a>
<a name="ln362"> </a>
<a name="ln363">    auto scroller = make_shared&lt;Scroller&gt;();</a>
<a name="ln364">    auto vbox = make_shared&lt;Box&gt;(Widget::VERT);</a>
<a name="ln365"> </a>
<a name="ln366">#ifdef USE_TILE_WEB</a>
<a name="ln367">    tiles.json_open_object();</a>
<a name="ln368">    tiles.json_open_array(&quot;cards&quot;);</a>
<a name="ln369">#endif</a>
<a name="ln370">    bool seen[NUM_CARDS] = {0};</a>
<a name="ln371">    ostringstream data;</a>
<a name="ln372">    bool first = true;</a>
<a name="ln373">    for (auto&amp; val : cards)</a>
<a name="ln374">    {</a>
<a name="ln375">        card_type card = (card_type) val.get_int();</a>
<a name="ln376"> </a>
<a name="ln377">        if (seen[card])</a>
<a name="ln378">            continue;</a>
<a name="ln379">        seen[card] = true;</a>
<a name="ln380"> </a>
<a name="ln381">        string name = card_name(card);</a>
<a name="ln382">        string desc = getLongDescription(name + &quot; card&quot;);</a>
<a name="ln383">        if (desc.empty())</a>
<a name="ln384">            desc = &quot;No description found.\n&quot;;</a>
<a name="ln385">        string decks = which_decks(card);</a>
<a name="ln386"> </a>
<a name="ln387">        name = uppercase_first(name);</a>
<a name="ln388">        desc = desc + decks;</a>
<a name="ln389"> </a>
<a name="ln390">    auto title_hbox = make_shared&lt;Box&gt;(Widget::HORZ);</a>
<a name="ln391">#ifdef USE_TILE</a>
<a name="ln392">        auto icon = make_shared&lt;Image&gt;();</a>
<a name="ln393">        icon-&gt;set_tile(tile_def(TILEG_NEMELEX_CARD, TEX_GUI));</a>
<a name="ln394">        title_hbox-&gt;add_child(move(icon));</a>
<a name="ln395">#endif</a>
<a name="ln396">        auto title = make_shared&lt;Text&gt;(formatted_string(name, WHITE));</a>
<a name="ln397">        title-&gt;set_margin_for_sdl(0, 0, 0, 10);</a>
<a name="ln398">        title_hbox-&gt;add_child(move(title));</a>
<a name="ln399">        title_hbox-&gt;set_cross_alignment(Widget::CENTER);</a>
<a name="ln400">        title_hbox-&gt;set_margin_for_crt(first ? 0 : 1, 0);</a>
<a name="ln401">        title_hbox-&gt;set_margin_for_sdl(first ? 0 : 20, 0);</a>
<a name="ln402">        vbox-&gt;add_child(move(title_hbox));</a>
<a name="ln403"> </a>
<a name="ln404">        auto text = make_shared&lt;Text&gt;(desc);</a>
<a name="ln405">        text-&gt;set_wrap_text(true);</a>
<a name="ln406">        vbox-&gt;add_child(move(text));</a>
<a name="ln407"> </a>
<a name="ln408">#ifdef USE_TILE_WEB</a>
<a name="ln409">        tiles.json_open_object();</a>
<a name="ln410">        tiles.json_write_string(&quot;name&quot;, name);</a>
<a name="ln411">        tiles.json_write_string(&quot;desc&quot;, desc);</a>
<a name="ln412">        tiles.json_close_object();</a>
<a name="ln413">#endif</a>
<a name="ln414">        first = false;</a>
<a name="ln415">    }</a>
<a name="ln416"> </a>
<a name="ln417">#ifdef USE_TILE_LOCAL</a>
<a name="ln418">    vbox-&gt;max_size().width = tiles.get_crt_font()-&gt;char_width()*80;</a>
<a name="ln419">#endif</a>
<a name="ln420"> </a>
<a name="ln421">    scroller-&gt;set_child(move(vbox));</a>
<a name="ln422">    auto popup = make_shared&lt;ui::Popup&gt;(scroller);</a>
<a name="ln423"> </a>
<a name="ln424">    bool done = false;</a>
<a name="ln425">    popup-&gt;on_keydown_event([&amp;done, &amp;scroller](const KeyEvent&amp; ev) {</a>
<a name="ln426">        done = !scroller-&gt;on_event(ev);</a>
<a name="ln427">        return true;</a>
<a name="ln428">    });</a>
<a name="ln429"> </a>
<a name="ln430">#ifdef USE_TILE_WEB</a>
<a name="ln431">    tiles.json_close_array();</a>
<a name="ln432">    tiles.push_ui_layout(&quot;describe-cards&quot;, 0);</a>
<a name="ln433">    popup-&gt;on_layout_pop([](){ tiles.pop_ui_layout(); });</a>
<a name="ln434">#endif</a>
<a name="ln435"> </a>
<a name="ln436">    ui::run_layout(move(popup), done);</a>
<a name="ln437">}</a>
<a name="ln438"> </a>
<a name="ln439">string deck_status(deck_type deck)</a>
<a name="ln440">{</a>
<a name="ln441">    const string name = deck_name(deck);</a>
<a name="ln442">    const int cards   = deck_cards(deck);</a>
<a name="ln443"> </a>
<a name="ln444">    ostringstream desc;</a>
<a name="ln445"> </a>
<a name="ln446">    desc &lt;&lt; chop_string(deck_name(deck), 24)</a>
<a name="ln447">         &lt;&lt; to_string(cards);</a>
<a name="ln448"> </a>
<a name="ln449">    return trimmed_string(desc.str());</a>
<a name="ln450">}</a>
<a name="ln451"> </a>
<a name="ln452">string deck_description(deck_type deck)</a>
<a name="ln453">{</a>
<a name="ln454">    ostringstream desc;</a>
<a name="ln455"> </a>
<a name="ln456">    desc &lt;&lt; &quot;A deck of magical cards, &quot;;</a>
<a name="ln457">    desc &lt;&lt; deck_flavour(deck) &lt;&lt; &quot;\n\n&quot;;</a>
<a name="ln458">    desc &lt;&lt; deck_contents(deck) &lt;&lt; &quot;\n&quot;;</a>
<a name="ln459"> </a>
<a name="ln460">    if (deck != DECK_STACK)</a>
<a name="ln461">    {</a>
<a name="ln462">        const int cards = deck_cards(deck);</a>
<a name="ln463">        desc &lt;&lt; &quot;\n&quot;;</a>
<a name="ln464"> </a>
<a name="ln465">        if (cards &gt; 1)</a>
<a name="ln466">            desc &lt;&lt; make_stringf(&quot;It currently has %d cards &quot;, cards);</a>
<a name="ln467">        else if (cards == 1)</a>
<a name="ln468">            desc &lt;&lt; &quot;It currently has 1 card &quot;;</a>
<a name="ln469">        else</a>
<a name="ln470">            desc &lt;&lt; &quot;It is currently empty &quot;;</a>
<a name="ln471"> </a>
<a name="ln472">        desc &lt;&lt; make_stringf(&quot;and can contain up to %d cards.&quot;,</a>
<a name="ln473">                             all_decks[deck].deck_max);</a>
<a name="ln474">        desc &lt;&lt; &quot;\n&quot;;</a>
<a name="ln475">    }</a>
<a name="ln476"> </a>
<a name="ln477">    return desc.str();</a>
<a name="ln478">}</a>
<a name="ln479"> </a>
<a name="ln480">/**</a>
<a name="ln481"> * The deck a given ability uses. Asserts if called on an ability that does not</a>
<a name="ln482"> * use decks.</a>
<a name="ln483"> *</a>
<a name="ln484"> * @param abil the ability</a>
<a name="ln485"> *</a>
<a name="ln486"> * @return the deck</a>
<a name="ln487"> */</a>
<a name="ln488">deck_type ability_deck(ability_type abil)</a>
<a name="ln489">{</a>
<a name="ln490">    auto deck = find(deck_ability.begin(), deck_ability.end(), abil);</a>
<a name="ln491"> </a>
<a name="ln492">    ASSERT(deck != deck_ability.end());</a>
<a name="ln493">    return (deck_type) distance(deck_ability.begin(), deck);</a>
<a name="ln494">}</a>
<a name="ln495"> </a>
<a name="ln496">// This will assert if the player doesn't have the ability to draw from the</a>
<a name="ln497">// deck passed.</a>
<a name="ln498">static char _deck_hotkey(deck_type deck)</a>
<a name="ln499">{</a>
<a name="ln500">    return get_talent(deck_ability[deck], false).hotkey;</a>
<a name="ln501">}</a>
<a name="ln502"> </a>
<a name="ln503">static deck_type _choose_deck(const string title = &quot;Draw&quot;)</a>
<a name="ln504">{</a>
<a name="ln505">    ToggleableMenu deck_menu(MF_SINGLESELECT</a>
<a name="ln506">            | MF_NO_WRAP_ROWS | MF_TOGGLE_ACTION | MF_ALWAYS_SHOW_MORE);</a>
<a name="ln507">    {</a>
<a name="ln508">        ToggleableMenuEntry* me =</a>
<a name="ln509">            new ToggleableMenuEntry(make_stringf(&quot;%s which deck?        &quot;</a>
<a name="ln510">                                    &quot;Cards available&quot;, title.c_str()),</a>
<a name="ln511">                                    &quot;Describe which deck?    &quot;</a>
<a name="ln512">                                    &quot;Cards available&quot;,</a>
<a name="ln513">                                    MEL_TITLE);</a>
<a name="ln514">        deck_menu.set_title(me, true, true);</a>
<a name="ln515">    }</a>
<a name="ln516">    deck_menu.set_tag(&quot;deck&quot;);</a>
<a name="ln517">    deck_menu.add_toggle_key('!');</a>
<a name="ln518">    deck_menu.add_toggle_key('?');</a>
<a name="ln519">    deck_menu.menu_action = Menu::ACT_EXECUTE;</a>
<a name="ln520"> </a>
<a name="ln521">    deck_menu.set_more(formatted_string::parse_string(</a>
<a name="ln522">                       &quot;Press '&lt;w&gt;!&lt;/w&gt;' or '&lt;w&gt;?&lt;/w&gt;' to toggle &quot;</a>
<a name="ln523">                       &quot;between deck selection and description.&quot;));</a>
<a name="ln524"> </a>
<a name="ln525">    int numbers[NUM_DECKS];</a>
<a name="ln526"> </a>
<a name="ln527">    for (int i = FIRST_PLAYER_DECK; i &lt;= LAST_PLAYER_DECK; i++)</a>
<a name="ln528">    {</a>
<a name="ln529">        ToggleableMenuEntry* me =</a>
<a name="ln530">            new ToggleableMenuEntry(deck_status(static_cast&lt;deck_type&gt;(i)),</a>
<a name="ln531">                    deck_status(static_cast&lt;deck_type&gt;(i)),</a>
<a name="ln532">                    MEL_ITEM, 1, _deck_hotkey(static_cast&lt;deck_type&gt;(i)));</a>
<a name="ln533">        numbers[i] = i;</a>
<a name="ln534">        me-&gt;data = &amp;numbers[i];</a>
<a name="ln535">        if (!deck_cards((deck_type)i))</a>
<a name="ln536">            me-&gt;colour = COL_USELESS;</a>
<a name="ln537"> </a>
<a name="ln538">#ifdef USE_TILE</a>
<a name="ln539">        me-&gt;add_tile(tile_def(TILEG_NEMELEX_DECK + i - FIRST_PLAYER_DECK + 1, TEX_GUI));</a>
<a name="ln540">#endif</a>
<a name="ln541">        deck_menu.add_entry(me);</a>
<a name="ln542">    }</a>
<a name="ln543"> </a>
<a name="ln544">    int ret = NUM_DECKS;</a>
<a name="ln545">    deck_menu.on_single_selection = [&amp;deck_menu, &amp;ret](const MenuEntry&amp; sel)</a>
<a name="ln546">    {</a>
<a name="ln547">        ASSERT(sel.hotkeys.size() == 1);</a>
<a name="ln548">        int selected = *(static_cast&lt;int*&gt;(sel.data));</a>
<a name="ln549"> </a>
<a name="ln550">        if (deck_menu.menu_action == Menu::ACT_EXAMINE)</a>
<a name="ln551">            describe_deck((deck_type) selected);</a>
<a name="ln552">        else</a>
<a name="ln553">            ret = *(static_cast&lt;int*&gt;(sel.data));</a>
<a name="ln554">        return deck_menu.menu_action == Menu::ACT_EXAMINE;</a>
<a name="ln555">    };</a>
<a name="ln556">    deck_menu.show(false);</a>
<a name="ln557">    if (!crawl_state.doing_prev_cmd_again)</a>
<a name="ln558">        redraw_screen();</a>
<a name="ln559">    return (deck_type) ret;</a>
<a name="ln560">}</a>
<a name="ln561"> </a>
<a name="ln562">/**</a>
<a name="ln563"> * Printed when a deck is exhausted</a>
<a name="ln564"> *</a>
<a name="ln565"> * @return          A message to print;</a>
<a name="ln566"> *                  e.g. &quot;the deck of cards disappears without a trace.&quot;</a>
<a name="ln567"> */</a>
<a name="ln568">static string _empty_deck_msg()</a>
<a name="ln569">{</a>
<a name="ln570">    string message = random_choose(&quot;disappears without a trace.&quot;,</a>
<a name="ln571">        &quot;glows slightly and disappears.&quot;,</a>
<a name="ln572">        &quot;glows with a rainbow of weird colours and disappears.&quot;);</a>
<a name="ln573">    return &quot;The deck of cards &quot; + message;</a>
<a name="ln574">}</a>
<a name="ln575"> </a>
<a name="ln576">static void _evoke_deck(deck_type deck, bool dealt = false)</a>
<a name="ln577">{</a>
<a name="ln578">    ASSERT(deck_cards(deck) &gt; 0);</a>
<a name="ln579"> </a>
<a name="ln580">    mprf(&quot;You %s a card...&quot;, dealt ? &quot;deal&quot; : &quot;draw&quot;);</a>
<a name="ln581"> </a>
<a name="ln582">    if (deck == DECK_STACK)</a>
<a name="ln583">    {</a>
<a name="ln584">        auto&amp; stack = you.props[NEMELEX_STACK_KEY].get_vector();</a>
<a name="ln585">        card_type card = (card_type) stack[stack.size() - 1].get_int();</a>
<a name="ln586">        stack.pop_back();</a>
<a name="ln587">        card_effect(card, dealt);</a>
<a name="ln588">    }</a>
<a name="ln589">    else</a>
<a name="ln590">    {</a>
<a name="ln591">        --you.props[deck_name(deck)];</a>
<a name="ln592">        card_effect(_random_card(deck), dealt);</a>
<a name="ln593">    }</a>
<a name="ln594"> </a>
<a name="ln595">    if (!deck_cards(deck))</a>
<a name="ln596">        mpr(_empty_deck_msg());</a>
<a name="ln597">}</a>
<a name="ln598"> </a>
<a name="ln599">// Draw one card from a deck, prompting the user for a choice</a>
<a name="ln600">bool deck_draw(deck_type deck)</a>
<a name="ln601">{</a>
<a name="ln602">    if (!deck_cards(deck))</a>
<a name="ln603">    {</a>
<a name="ln604">        mpr(&quot;That deck is empty!&quot;);</a>
<a name="ln605">        return false;</a>
<a name="ln606">    }</a>
<a name="ln607"> </a>
<a name="ln608">    _evoke_deck(deck);</a>
<a name="ln609">    return true;</a>
<a name="ln610">}</a>
<a name="ln611"> </a>
<a name="ln612">bool deck_stack()</a>
<a name="ln613">{</a>
<a name="ln614">    int total_cards = 0;</a>
<a name="ln615"> </a>
<a name="ln616">    for (int i = FIRST_PLAYER_DECK; i &lt;= LAST_PLAYER_DECK; ++i)</a>
<a name="ln617">        total_cards += deck_cards((deck_type) i);</a>
<a name="ln618"> </a>
<a name="ln619">    if (deck_cards(DECK_STACK) &amp;&amp; !yesno(&quot;Replace your current stack?&quot;,</a>
<a name="ln620">                                          false, 0))</a>
<a name="ln621">    {</a>
<a name="ln622">        return false;</a>
<a name="ln623">    }</a>
<a name="ln624"> </a>
<a name="ln625">    if (!total_cards)</a>
<a name="ln626">    {</a>
<a name="ln627">        mpr(&quot;You are out of cards!&quot;);</a>
<a name="ln628">        return false;</a>
<a name="ln629">    }</a>
<a name="ln630"> </a>
<a name="ln631">    if (total_cards &lt; 5 &amp;&amp; !yesno(&quot;You have fewer than five cards, &quot;</a>
<a name="ln632">                                  &quot;stack them anyway?&quot;, false, 0))</a>
<a name="ln633">    {</a>
<a name="ln634">        canned_msg(MSG_OK);</a>
<a name="ln635">        return false;</a>
<a name="ln636">    }</a>
<a name="ln637"> </a>
<a name="ln638">    you.props[NEMELEX_STACK_KEY].get_vector().clear();</a>
<a name="ln639">    run_uncancel(UNC_STACK_FIVE, min(total_cards, 5));</a>
<a name="ln640">    return true;</a>
<a name="ln641">}</a>
<a name="ln642"> </a>
<a name="ln643">class StackFiveMenu : public Menu</a>
<a name="ln644">{</a>
<a name="ln645">    virtual bool process_key(int keyin) override;</a>
<a name="ln646">    CrawlVector&amp; draws;</a>
<a name="ln647">public:</a>
<a name="ln648">    StackFiveMenu(CrawlVector&amp; d)</a>
<a name="ln649">        : Menu(MF_NOSELECT | MF_UNCANCEL | MF_ALWAYS_SHOW_MORE), draws(d) {};</a>
<a name="ln650">};</a>
<a name="ln651"> </a>
<a name="ln652">bool StackFiveMenu::process_key(int keyin)</a>
<a name="ln653">{</a>
<a name="ln654">    if (keyin == CK_ENTER)</a>
<a name="ln655">    {</a>
<a name="ln656">        formatted_string old_more = more;</a>
<a name="ln657">        set_more(formatted_string::parse_string(</a>
<a name="ln658">                &quot;Are you done? (press y or Y to confirm)&quot;));</a>
<a name="ln659">        if (yesno(nullptr, true, 'n', false, false, true))</a>
<a name="ln660">            return false;</a>
<a name="ln661">        set_more(old_more);</a>
<a name="ln662">    }</a>
<a name="ln663">    else if (keyin == '?')</a>
<a name="ln664">        _describe_cards(draws);</a>
<a name="ln665">    else if (keyin &gt;= '1' &amp;&amp; keyin &lt;= '0' + static_cast&lt;int&gt;(draws.size()))</a>
<a name="ln666">    {</a>
<a name="ln667">        const unsigned int i = keyin - '1';</a>
<a name="ln668">        for (unsigned int j = 0; j &lt; items.size(); j++)</a>
<a name="ln669">            if (items[j]-&gt;selected())</a>
<a name="ln670">            {</a>
<a name="ln671">                swap(draws[i], draws[j]);</a>
<a name="ln672">                swap(items[i]-&gt;text, items[j]-&gt;text);</a>
<a name="ln673">                items[j]-&gt;colour = LIGHTGREY;</a>
<a name="ln674">                select_item_index(i, 0, false); // this also updates the item</a>
<a name="ln675">                select_item_index(j, 0, false);</a>
<a name="ln676">                return true;</a>
<a name="ln677">            }</a>
<a name="ln678">        items[i]-&gt;colour = WHITE;</a>
<a name="ln679">        select_item_index(i, 1, false);</a>
<a name="ln680">    }</a>
<a name="ln681">    else</a>
<a name="ln682">        Menu::process_key(keyin);</a>
<a name="ln683">    return true;</a>
<a name="ln684">}</a>
<a name="ln685"> </a>
<a name="ln686">static void _draw_stack(int to_stack)</a>
<a name="ln687">{</a>
<a name="ln688">    ToggleableMenu deck_menu(MF_SINGLESELECT | MF_UNCANCEL</a>
<a name="ln689">            | MF_NO_WRAP_ROWS | MF_TOGGLE_ACTION | MF_ALWAYS_SHOW_MORE);</a>
<a name="ln690">    {</a>
<a name="ln691">        ToggleableMenuEntry* me =</a>
<a name="ln692">            new ToggleableMenuEntry(&quot;Draw which deck?        &quot;</a>
<a name="ln693">                                    &quot;Cards available&quot;,</a>
<a name="ln694">                                    &quot;Describe which deck?    &quot;</a>
<a name="ln695">                                    &quot;Cards available&quot;,</a>
<a name="ln696">                                    MEL_TITLE);</a>
<a name="ln697">        deck_menu.set_title(me, true, true);</a>
<a name="ln698">    }</a>
<a name="ln699">    deck_menu.set_tag(&quot;deck&quot;);</a>
<a name="ln700">    deck_menu.add_toggle_key('!');</a>
<a name="ln701">    deck_menu.add_toggle_key('?');</a>
<a name="ln702">    deck_menu.menu_action = Menu::ACT_EXECUTE;</a>
<a name="ln703"> </a>
<a name="ln704">    auto&amp; stack = you.props[NEMELEX_STACK_KEY].get_vector();</a>
<a name="ln705"> </a>
<a name="ln706">    if (!stack.empty())</a>
<a name="ln707">    {</a>
<a name="ln708">            string status = &quot;Drawn so far: &quot; + stack_contents();</a>
<a name="ln709">            deck_menu.set_more(formatted_string::parse_string(</a>
<a name="ln710">                       status + &quot;\n&quot; +</a>
<a name="ln711">                       &quot;Press '&lt;w&gt;!&lt;/w&gt;' or '&lt;w&gt;?&lt;/w&gt;' to toggle &quot;</a>
<a name="ln712">                       &quot;between deck selection and description.&quot;));</a>
<a name="ln713">    }</a>
<a name="ln714">    else</a>
<a name="ln715">    {</a>
<a name="ln716">        deck_menu.set_more(formatted_string::parse_string(</a>
<a name="ln717">                           &quot;Press '&lt;w&gt;!&lt;/w&gt;' or '&lt;w&gt;?&lt;/w&gt;' to toggle &quot;</a>
<a name="ln718">                           &quot;between deck selection and description.&quot;));</a>
<a name="ln719">    }</a>
<a name="ln720"> </a>
<a name="ln721">    int numbers[NUM_DECKS];</a>
<a name="ln722"> </a>
<a name="ln723">    for (int i = FIRST_PLAYER_DECK; i &lt;= LAST_PLAYER_DECK; i++)</a>
<a name="ln724">    {</a>
<a name="ln725">        ToggleableMenuEntry* me =</a>
<a name="ln726">            new ToggleableMenuEntry(deck_status((deck_type)i),</a>
<a name="ln727">                    deck_status((deck_type)i),</a>
<a name="ln728">                    MEL_ITEM, 1, _deck_hotkey((deck_type)i));</a>
<a name="ln729">        numbers[i] = i;</a>
<a name="ln730">        me-&gt;data = &amp;numbers[i];</a>
<a name="ln731">        if (!deck_cards((deck_type)i))</a>
<a name="ln732">            me-&gt;colour = COL_USELESS;</a>
<a name="ln733"> </a>
<a name="ln734">#ifdef USE_TILE</a>
<a name="ln735">        me-&gt;add_tile(tile_def(TILEG_NEMELEX_DECK + i - FIRST_PLAYER_DECK + 1, TEX_GUI));</a>
<a name="ln736">#endif</a>
<a name="ln737">        deck_menu.add_entry(me);</a>
<a name="ln738">    }</a>
<a name="ln739">    deck_menu.on_single_selection = [&amp;deck_menu, &amp;stack, to_stack](const MenuEntry&amp; sel)</a>
<a name="ln740">    {</a>
<a name="ln741">        ASSERT(sel.hotkeys.size() == 1);</a>
<a name="ln742">        deck_type selected = (deck_type) *(static_cast&lt;int*&gt;(sel.data));</a>
<a name="ln743">        // Need non-const access to the selection.</a>
<a name="ln744">        ToggleableMenuEntry* me =</a>
<a name="ln745">            static_cast&lt;ToggleableMenuEntry*&gt;(deck_menu.selected_entries()[0]);</a>
<a name="ln746"> </a>
<a name="ln747">        if (deck_menu.menu_action == Menu::ACT_EXAMINE)</a>
<a name="ln748">            describe_deck(selected);</a>
<a name="ln749">        else</a>
<a name="ln750">        {</a>
<a name="ln751">            you.props[deck_name(selected)]--;</a>
<a name="ln752">            me-&gt;text = deck_status(selected);</a>
<a name="ln753">            me-&gt;alt_text = deck_status(selected);</a>
<a name="ln754"> </a>
<a name="ln755">            card_type draw = _random_card(selected);</a>
<a name="ln756">            stack.push_back(draw);</a>
<a name="ln757">            string status = &quot;Drawn so far: &quot; + stack_contents();</a>
<a name="ln758">            deck_menu.set_more(formatted_string::parse_string(</a>
<a name="ln759">                       status + &quot;\n&quot; +</a>
<a name="ln760">                       &quot;Press '&lt;w&gt;!&lt;/w&gt;' or '&lt;w&gt;?&lt;/w&gt;' to toggle &quot;</a>
<a name="ln761">                       &quot;between deck selection and description.&quot;));</a>
<a name="ln762">        }</a>
<a name="ln763">        return stack.size() &lt; to_stack</a>
<a name="ln764">               || deck_menu.menu_action == Menu::ACT_EXAMINE;</a>
<a name="ln765">    };</a>
<a name="ln766">    deck_menu.show(false);</a>
<a name="ln767">}</a>
<a name="ln768"> </a>
<a name="ln769">bool stack_five(int to_stack)</a>
<a name="ln770">{</a>
<a name="ln771">    auto&amp; stack = you.props[NEMELEX_STACK_KEY].get_vector();</a>
<a name="ln772"> </a>
<a name="ln773">    while (stack.size() &lt; to_stack)</a>
<a name="ln774">    {</a>
<a name="ln775">        if (crawl_state.seen_hups)</a>
<a name="ln776">            return false;</a>
<a name="ln777"> </a>
<a name="ln778">        _draw_stack(to_stack);</a>
<a name="ln779">    }</a>
<a name="ln780"> </a>
<a name="ln781">    StackFiveMenu menu(stack);</a>
<a name="ln782">    MenuEntry *const title = new MenuEntry(&quot;Select two cards to swap them:&quot;, MEL_TITLE);</a>
<a name="ln783">    menu.set_title(title);</a>
<a name="ln784">    for (unsigned int i = 0; i &lt; stack.size(); i++)</a>
<a name="ln785">    {</a>
<a name="ln786">        MenuEntry * const entry =</a>
<a name="ln787">            new MenuEntry(card_name((card_type)stack[i].get_int()),</a>
<a name="ln788">                          MEL_ITEM, 1, '1'+i);</a>
<a name="ln789">#ifdef USE_TILE</a>
<a name="ln790">        entry-&gt;add_tile(tile_def(TILEG_NEMELEX_CARD, TEX_GUI));</a>
<a name="ln791">#endif</a>
<a name="ln792">        menu.add_entry(entry);</a>
<a name="ln793">    }</a>
<a name="ln794">    menu.set_more(formatted_string::parse_string(</a>
<a name="ln795">                &quot;&lt;lightgrey&gt;Press &lt;w&gt;?&lt;/w&gt; for the card descriptions&quot;</a>
<a name="ln796">                &quot; or &lt;w&gt;Enter&lt;/w&gt; to accept.&quot;));</a>
<a name="ln797">    menu.show();</a>
<a name="ln798"> </a>
<a name="ln799">    if (crawl_state.seen_hups)</a>
<a name="ln800">        return false;</a>
<a name="ln801">    else</a>
<a name="ln802">    {</a>
<a name="ln803">        std::reverse(stack.begin(), stack.end());</a>
<a name="ln804">        return true;</a>
<a name="ln805">    }</a>
<a name="ln806">}</a>
<a name="ln807"> </a>
<a name="ln808">// Draw the top four cards of an deck and play them all.</a>
<a name="ln809">// Return false if the operation was failed/aborted along the way.</a>
<a name="ln810">bool deck_deal()</a>
<a name="ln811">{</a>
<a name="ln812">    deck_type choice = _choose_deck(&quot;Deal&quot;);</a>
<a name="ln813"> </a>
<a name="ln814">    if (choice == NUM_DECKS)</a>
<a name="ln815">        return false;</a>
<a name="ln816"> </a>
<a name="ln817">    int num_cards = deck_cards(choice);</a>
<a name="ln818"> </a>
<a name="ln819">    if (!num_cards)</a>
<a name="ln820">    {</a>
<a name="ln821">        mpr(&quot;That deck is empty!&quot;);</a>
<a name="ln822">        return false;</a>
<a name="ln823">    }</a>
<a name="ln824"> </a>
<a name="ln825">    const int num_to_deal = min(num_cards, 4);</a>
<a name="ln826"> </a>
<a name="ln827">    for (int i = 0; i &lt; num_to_deal; ++i)</a>
<a name="ln828">        _evoke_deck(choice, true);</a>
<a name="ln829"> </a>
<a name="ln830">    return true;</a>
<a name="ln831">}</a>
<a name="ln832"> </a>
<a name="ln833">// Draw the next three cards, discard two and pick one.</a>
<a name="ln834">bool deck_triple_draw()</a>
<a name="ln835">{</a>
<a name="ln836">    deck_type choice = _choose_deck();</a>
<a name="ln837"> </a>
<a name="ln838">    if (choice == NUM_DECKS)</a>
<a name="ln839">        return false;</a>
<a name="ln840"> </a>
<a name="ln841">    int num_cards = deck_cards(choice);</a>
<a name="ln842"> </a>
<a name="ln843">    if (!num_cards)</a>
<a name="ln844">    {</a>
<a name="ln845">        mpr(&quot;That deck is empty!&quot;);</a>
<a name="ln846">        return false;</a>
<a name="ln847">    }</a>
<a name="ln848"> </a>
<a name="ln849">    if (num_cards &lt; 3 &amp;&amp; !yesno(&quot;There's fewer than three cards, &quot;</a>
<a name="ln850">                                &quot;still triple draw?&quot;, false, 0))</a>
<a name="ln851">    {</a>
<a name="ln852">        canned_msg(MSG_OK);</a>
<a name="ln853">        return false;</a>
<a name="ln854">    }</a>
<a name="ln855"> </a>
<a name="ln856">    if (num_cards == 1)</a>
<a name="ln857">    {</a>
<a name="ln858">        // Only one card to draw, so just draw it.</a>
<a name="ln859">        mpr(&quot;There's only one card left!&quot;);</a>
<a name="ln860">        _evoke_deck(choice);</a>
<a name="ln861">        return true;</a>
<a name="ln862">    }</a>
<a name="ln863"> </a>
<a name="ln864">    const int num_to_draw = min(num_cards, 3);</a>
<a name="ln865"> </a>
<a name="ln866">    you.props[deck_name(choice)] = deck_cards(choice) - num_to_draw;</a>
<a name="ln867"> </a>
<a name="ln868">    auto&amp; draw = you.props[NEMELEX_TRIPLE_DRAW_KEY].get_vector();</a>
<a name="ln869">    draw.clear();</a>
<a name="ln870"> </a>
<a name="ln871">    for (int i = 0; i &lt; num_to_draw; ++i)</a>
<a name="ln872">        draw.push_back(_random_card(choice));</a>
<a name="ln873"> </a>
<a name="ln874">    run_uncancel(UNC_DRAW_THREE, 0);</a>
<a name="ln875">    return true;</a>
<a name="ln876">}</a>
<a name="ln877"> </a>
<a name="ln878">bool draw_three()</a>
<a name="ln879">{</a>
<a name="ln880">    auto&amp; draws = you.props[NEMELEX_TRIPLE_DRAW_KEY].get_vector();</a>
<a name="ln881"> </a>
<a name="ln882">    int selected = -1;</a>
<a name="ln883">    bool need_prompt_redraw = true;</a>
<a name="ln884">    while (true)</a>
<a name="ln885">    {</a>
<a name="ln886">        if (need_prompt_redraw)</a>
<a name="ln887">        {</a>
<a name="ln888">            mpr(&quot;You draw... (choose one card, ? for their descriptions)&quot;);</a>
<a name="ln889">            for (int i = 0; i &lt; draws.size(); ++i)</a>
<a name="ln890">            {</a>
<a name="ln891">                msg::streams(MSGCH_PROMPT)</a>
<a name="ln892">                    &lt;&lt; msg::nocap &lt;&lt; (static_cast&lt;char&gt;(i + 'a')) &lt;&lt; &quot; - &quot;</a>
<a name="ln893">                    &lt;&lt; card_name((card_type)draws[i].get_int()) &lt;&lt; endl;</a>
<a name="ln894">            }</a>
<a name="ln895">            need_prompt_redraw = false;</a>
<a name="ln896">        }</a>
<a name="ln897">        const int keyin = toalower(get_ch());</a>
<a name="ln898"> </a>
<a name="ln899">        if (crawl_state.seen_hups)</a>
<a name="ln900">            return false;</a>
<a name="ln901"> </a>
<a name="ln902">        if (keyin == '?')</a>
<a name="ln903">        {</a>
<a name="ln904">            _describe_cards(draws);</a>
<a name="ln905">            redraw_screen();</a>
<a name="ln906">            need_prompt_redraw = true;</a>
<a name="ln907">        }</a>
<a name="ln908">        else if (keyin &gt;= 'a' &amp;&amp; keyin &lt; 'a' + draws.size())</a>
<a name="ln909">        {</a>
<a name="ln910">            selected = keyin - 'a';</a>
<a name="ln911">            break;</a>
<a name="ln912">        }</a>
<a name="ln913">        else</a>
<a name="ln914">            canned_msg(MSG_HUH);</a>
<a name="ln915">    }</a>
<a name="ln916"> </a>
<a name="ln917">    card_effect((card_type) draws[selected].get_int());</a>
<a name="ln918"> </a>
<a name="ln919">    return true;</a>
<a name="ln920">}</a>
<a name="ln921"> </a>
<a name="ln922">// This is Nemelex retribution. If deal is true, use the word &quot;deal&quot;</a>
<a name="ln923">// rather than &quot;draw&quot; (for the Deal Four out-of-cards situation).</a>
<a name="ln924">void draw_from_deck_of_punishment(bool deal)</a>
<a name="ln925">{</a>
<a name="ln926">    card_type card = _random_card(DECK_OF_PUNISHMENT);</a>
<a name="ln927"> </a>
<a name="ln928">    mprf(&quot;You %s a card...&quot;, deal ? &quot;deal&quot; : &quot;draw&quot;);</a>
<a name="ln929">    card_effect(card, deal, true);</a>
<a name="ln930">}</a>
<a name="ln931"> </a>
<a name="ln932">static int _get_power_level(int power)</a>
<a name="ln933">{</a>
<a name="ln934">    int power_level = x_chance_in_y(power, 900) + x_chance_in_y(power, 2700);</a>
<a name="ln935"> </a>
<a name="ln936">    // other functions in this file will break if this assertion is violated</a>
<a name="ln937">    ASSERT(power_level &gt;= 0 &amp;&amp; power_level &lt;= 2);</a>
<a name="ln938">    return power_level;</a>
<a name="ln939">}</a>
<a name="ln940"> </a>
<a name="ln941">// Actual card implementations follow.</a>
<a name="ln942"> </a>
<a name="ln943">static void _velocity_card(int power)</a>
<a name="ln944">{</a>
<a name="ln945"> </a>
<a name="ln946">    const int power_level = _get_power_level(power);</a>
<a name="ln947">    bool did_something = false;</a>
<a name="ln948"> </a>
<a name="ln949">    if (you.duration[DUR_SLOW] &amp;&amp; x_chance_in_y(power_level, 2))</a>
<a name="ln950">    {</a>
<a name="ln951">        you.duration[DUR_SLOW] = 1;</a>
<a name="ln952">        did_something = true;</a>
<a name="ln953">    }</a>
<a name="ln954"> </a>
<a name="ln955">    if (!apply_visible_monsters([=](monster&amp; mon)</a>
<a name="ln956">          {</a>
<a name="ln957">              bool affected = false;</a>
<a name="ln958">              if (!mons_immune_magic(mon))</a>
<a name="ln959">              {</a>
<a name="ln960">                  const bool hostile = !mon.wont_attack();</a>
<a name="ln961">                  const bool haste_immune = (mon.stasis()</a>
<a name="ln962">                                             || mons_is_immotile(mon));</a>
<a name="ln963"> </a>
<a name="ln964">                  bool did_haste = false;</a>
<a name="ln965"> </a>
<a name="ln966">                  if (hostile)</a>
<a name="ln967">                  {</a>
<a name="ln968">                      if (x_chance_in_y(1 + power_level, 3))</a>
<a name="ln969">                      {</a>
<a name="ln970">                          do_slow_monster(mon, &amp;you);</a>
<a name="ln971">                          affected = true;</a>
<a name="ln972">                      }</a>
<a name="ln973">                  }</a>
<a name="ln974">                  else //allies</a>
<a name="ln975">                  {</a>
<a name="ln976">                      if (!haste_immune &amp;&amp; x_chance_in_y(power_level, 2))</a>
<a name="ln977">                      {</a>
<a name="ln978">                          mon.add_ench(ENCH_HASTE);</a>
<a name="ln979">                          affected = true;</a>
<a name="ln980">                          did_haste = true;</a>
<a name="ln981">                      }</a>
<a name="ln982">                  }</a>
<a name="ln983"> </a>
<a name="ln984">                  if (did_haste)</a>
<a name="ln985">                      simple_monster_message(mon, &quot; seems to speed up.&quot;);</a>
<a name="ln986">              }</a>
<a name="ln987">              return affected;</a>
<a name="ln988">          })</a>
<a name="ln989">        &amp;&amp; !did_something)</a>
<a name="ln990">    {</a>
<a name="ln991">        canned_msg(MSG_NOTHING_HAPPENS);</a>
<a name="ln992">    }</a>
<a name="ln993">}</a>
<a name="ln994"> </a>
<a name="ln995">static void _exile_card(int power)</a>
<a name="ln996">{</a>
<a name="ln997">    if (player_in_branch(BRANCH_ABYSS))</a>
<a name="ln998">    {</a>
<a name="ln999">        canned_msg(MSG_NOTHING_HAPPENS);</a>
<a name="ln1000">        return;</a>
<a name="ln1001">    }</a>
<a name="ln1002"> </a>
<a name="ln1003">    // Calculate how many extra banishments you get.</a>
<a name="ln1004">    const int power_level = _get_power_level(power);</a>
<a name="ln1005">    int extra_targets = power_level + random2(1 + power_level);</a>
<a name="ln1006"> </a>
<a name="ln1007">    for (int i = 0; i &lt; 1 + extra_targets; ++i)</a>
<a name="ln1008">    {</a>
<a name="ln1009">        // Pick a random monster nearby to banish (or yourself).</a>
<a name="ln1010">        monster* mon_to_banish = choose_random_nearby_monster(1);</a>
<a name="ln1011"> </a>
<a name="ln1012">        // Bonus banishments only banish monsters.</a>
<a name="ln1013">        if (i != 0 &amp;&amp; !mon_to_banish)</a>
<a name="ln1014">            continue;</a>
<a name="ln1015"> </a>
<a name="ln1016">        if (!mon_to_banish) // Banish yourself!</a>
<a name="ln1017">        {</a>
<a name="ln1018">            banished(&quot;drawing a card&quot;);</a>
<a name="ln1019">            break;              // Don't banish anything else.</a>
<a name="ln1020">        }</a>
<a name="ln1021">        else</a>
<a name="ln1022">            mon_to_banish-&gt;banish(&amp;you);</a>
<a name="ln1023">    }</a>
<a name="ln1024">}</a>
<a name="ln1025"> </a>
<a name="ln1026">static void _shaft_card(int power)</a>
<a name="ln1027">{</a>
<a name="ln1028">    const int power_level = _get_power_level(power);</a>
<a name="ln1029">    bool did_something = false;</a>
<a name="ln1030"> </a>
<a name="ln1031">    if (is_valid_shaft_level())</a>
<a name="ln1032">    {</a>
<a name="ln1033">        if (grd(you.pos()) == DNGN_FLOOR)</a>
<a name="ln1034">        {</a>
<a name="ln1035">            place_specific_trap(you.pos(), TRAP_SHAFT);</a>
<a name="ln1036">            trap_at(you.pos())-&gt;reveal();</a>
<a name="ln1037">            mpr(&quot;A shaft materialises beneath you!&quot;);</a>
<a name="ln1038">            did_something = true;</a>
<a name="ln1039">        }</a>
<a name="ln1040"> </a>
<a name="ln1041">        did_something = apply_visible_monsters([=](monster&amp; mons)</a>
<a name="ln1042">        {</a>
<a name="ln1043">            return !mons.wont_attack()</a>
<a name="ln1044">                   &amp;&amp; mons_is_threatening(mons)</a>
<a name="ln1045">                   &amp;&amp; x_chance_in_y(power_level, 3)</a>
<a name="ln1046">                   &amp;&amp; mons.do_shaft();</a>
<a name="ln1047">        }) || did_something;</a>
<a name="ln1048">    }</a>
<a name="ln1049"> </a>
<a name="ln1050">    if (!did_something)</a>
<a name="ln1051">        canned_msg(MSG_NOTHING_HAPPENS);</a>
<a name="ln1052">}</a>
<a name="ln1053"> </a>
<a name="ln1054">static int stair_draw_count = 0;</a>
<a name="ln1055"> </a>
<a name="ln1056">// This does not describe an actual card. Instead, it only exists to test</a>
<a name="ln1057">// the stair movement effect in wizard mode (&quot;&amp;c stairs&quot;).</a>
<a name="ln1058">static void _stairs_card(int /*power*/)</a>
<a name="ln1059">{</a>
<a name="ln1060">    you.duration[DUR_REPEL_STAIRS_MOVE]  = 0;</a>
<a name="ln1061">    you.duration[DUR_REPEL_STAIRS_CLIMB] = 0;</a>
<a name="ln1062"> </a>
<a name="ln1063">    if (feat_stair_direction(grd(you.pos())) == CMD_NO_CMD)</a>
<a name="ln1064">        you.duration[DUR_REPEL_STAIRS_MOVE]  = 1000;</a>
<a name="ln1065">    else</a>
<a name="ln1066">        you.duration[DUR_REPEL_STAIRS_CLIMB] =  500; // more annoying</a>
<a name="ln1067"> </a>
<a name="ln1068">    vector&lt;coord_def&gt; stairs_avail;</a>
<a name="ln1069"> </a>
<a name="ln1070">    for (radius_iterator ri(you.pos(), LOS_DEFAULT, true); ri; ++ri)</a>
<a name="ln1071">    {</a>
<a name="ln1072">        dungeon_feature_type feat = grd(*ri);</a>
<a name="ln1073">        if (feat_stair_direction(feat) != CMD_NO_CMD</a>
<a name="ln1074">            &amp;&amp; feat != DNGN_ENTER_SHOP)</a>
<a name="ln1075">        {</a>
<a name="ln1076">            stairs_avail.push_back(*ri);</a>
<a name="ln1077">        }</a>
<a name="ln1078">    }</a>
<a name="ln1079"> </a>
<a name="ln1080">    if (stairs_avail.empty())</a>
<a name="ln1081">    {</a>
<a name="ln1082">        mpr(&quot;No stairs available to move.&quot;);</a>
<a name="ln1083">        return;</a>
<a name="ln1084">    }</a>
<a name="ln1085"> </a>
<a name="ln1086">    shuffle_array(stairs_avail);</a>
<a name="ln1087"> </a>
<a name="ln1088">    for (coord_def stair : stairs_avail)</a>
<a name="ln1089">        move_stair(stair, stair_draw_count % 2, false);</a>
<a name="ln1090"> </a>
<a name="ln1091">    stair_draw_count++;</a>
<a name="ln1092">}</a>
<a name="ln1093"> </a>
<a name="ln1094">static monster* _friendly(monster_type mt, int dur)</a>
<a name="ln1095">{</a>
<a name="ln1096">    return create_monster(mgen_data(mt, BEH_FRIENDLY, you.pos(), MHITYOU,</a>
<a name="ln1097">                                    MG_AUTOFOE)</a>
<a name="ln1098">                          .set_summoned(&amp;you, dur, 0));</a>
<a name="ln1099">}</a>
<a name="ln1100"> </a>
<a name="ln1101">static void _damaging_card(card_type card, int power,</a>
<a name="ln1102">                           bool dealt = false)</a>
<a name="ln1103">{</a>
<a name="ln1104">    const int power_level = _get_power_level(power);</a>
<a name="ln1105">    const char *participle = dealt ? &quot;dealt&quot; : &quot;drawn&quot;;</a>
<a name="ln1106"> </a>
<a name="ln1107">    bool done_prompt = false;</a>
<a name="ln1108">    string prompt = make_stringf(&quot;You have %s %s.&quot;, participle,</a>
<a name="ln1109">                                 card_name(card));</a>
<a name="ln1110"> </a>
<a name="ln1111">    dist target;</a>
<a name="ln1112">    zap_type ztype = ZAP_DEBUGGING_RAY;</a>
<a name="ln1113">    const zap_type painzaps[2] = { ZAP_AGONY, ZAP_BOLT_OF_DRAINING };</a>
<a name="ln1114">    const zap_type acidzaps[3] = { ZAP_BREATHE_ACID, ZAP_CORROSIVE_BOLT,</a>
<a name="ln1115">                                   ZAP_CORROSIVE_BOLT };</a>
<a name="ln1116"> </a>
<a name="ln1117">    switch (card)</a>
<a name="ln1118">    {</a>
<a name="ln1119">    case CARD_VITRIOL:</a>
<a name="ln1120">        if (power_level == 2)</a>
<a name="ln1121">        {</a>
<a name="ln1122">            done_prompt = true;</a>
<a name="ln1123">            mpr(prompt);</a>
<a name="ln1124">            mpr(&quot;You radiate a wave of entropy!&quot;);</a>
<a name="ln1125">            apply_visible_monsters([](monster&amp; mons)</a>
<a name="ln1126">            {</a>
<a name="ln1127">                return !mons.wont_attack()</a>
<a name="ln1128">                       &amp;&amp; mons_is_threatening(mons)</a>
<a name="ln1129">                       &amp;&amp; coinflip()</a>
<a name="ln1130">                       &amp;&amp; mons.corrode_equipment();</a>
<a name="ln1131">            });</a>
<a name="ln1132">        }</a>
<a name="ln1133">        ztype = acidzaps[power_level];</a>
<a name="ln1134">        break;</a>
<a name="ln1135"> </a>
<a name="ln1136">    case CARD_ORB:</a>
<a name="ln1137">        ztype = ZAP_IOOD;</a>
<a name="ln1138">        break;</a>
<a name="ln1139"> </a>
<a name="ln1140">    case CARD_PAIN:</a>
<a name="ln1141">        if (power_level == 2)</a>
<a name="ln1142">        {</a>
<a name="ln1143">            mpr(&quot;You reveal a symbol of torment!&quot;);</a>
<a name="ln1144">            torment(&amp;you, TORMENT_CARD_PAIN, you.pos());</a>
<a name="ln1145">        }</a>
<a name="ln1146"> </a>
<a name="ln1147">        ztype = painzaps[min(power_level, (int)ARRAYSZ(painzaps)-1)];</a>
<a name="ln1148">        break;</a>
<a name="ln1149"> </a>
<a name="ln1150">    default:</a>
<a name="ln1151">        break;</a>
<a name="ln1152">    }</a>
<a name="ln1153"> </a>
<a name="ln1154">    bolt beam;</a>
<a name="ln1155">    beam.range = LOS_RADIUS;</a>
<a name="ln1156"> </a>
<a name="ln1157">    direction_chooser_args args;</a>
<a name="ln1158">    args.mode = TARG_HOSTILE;</a>
<a name="ln1159">    if (!done_prompt)</a>
<a name="ln1160">        args.top_prompt = prompt;</a>
<a name="ln1161"> </a>
<a name="ln1162">    // Confirm aborts as they waste the card.</a>
<a name="ln1163">    prompt = make_stringf(&quot;Aiming: %s&quot;, card_name(card));</a>
<a name="ln1164">    while (!(spell_direction(target, beam, &amp;args)</a>
<a name="ln1165">            &amp;&amp; player_tracer(ZAP_DEBUGGING_RAY, power/6, beam)))</a>
<a name="ln1166">    {</a>
<a name="ln1167">        if (crawl_state.seen_hups</a>
<a name="ln1168">            || yesno(&quot;Really abort (and waste the card)?&quot;, false, 0))</a>
<a name="ln1169">        {</a>
<a name="ln1170">            canned_msg(MSG_OK);</a>
<a name="ln1171">            return;</a>
<a name="ln1172">        }</a>
<a name="ln1173">        args.top_prompt = prompt;</a>
<a name="ln1174">    }</a>
<a name="ln1175"> </a>
<a name="ln1176">    if (ztype == ZAP_IOOD)</a>
<a name="ln1177">    {</a>
<a name="ln1178">        if (power_level == 1)</a>
<a name="ln1179">        {</a>
<a name="ln1180">            cast_iood(&amp;you, power/6, &amp;beam, 0, 0,</a>
<a name="ln1181">                      mgrd(beam.target), false, false);</a>
<a name="ln1182">        }</a>
<a name="ln1183">        else</a>
<a name="ln1184">            cast_iood_burst(power/6, beam.target);</a>
<a name="ln1185">    }</a>
<a name="ln1186">    else</a>
<a name="ln1187">        zapping(ztype, power/6, beam);</a>
<a name="ln1188">}</a>
<a name="ln1189"> </a>
<a name="ln1190">static void _elixir_card(int power)</a>
<a name="ln1191">{</a>
<a name="ln1192">    int power_level = _get_power_level(power);</a>
<a name="ln1193"> </a>
<a name="ln1194">    you.duration[DUR_ELIXIR_HEALTH] = 0;</a>
<a name="ln1195">    you.duration[DUR_ELIXIR_MAGIC] = 0;</a>
<a name="ln1196"> </a>
<a name="ln1197">    switch (power_level)</a>
<a name="ln1198">    {</a>
<a name="ln1199">    case 0:</a>
<a name="ln1200">        if (coinflip())</a>
<a name="ln1201">            you.set_duration(DUR_ELIXIR_HEALTH, 1 + random2(3));</a>
<a name="ln1202">        else</a>
<a name="ln1203">            you.set_duration(DUR_ELIXIR_MAGIC, 3 + random2(5));</a>
<a name="ln1204">        break;</a>
<a name="ln1205">    case 1:</a>
<a name="ln1206">        if (you.hp * 2 &lt; you.hp_max)</a>
<a name="ln1207">            you.set_duration(DUR_ELIXIR_HEALTH, 3 + random2(3));</a>
<a name="ln1208">        else</a>
<a name="ln1209">            you.set_duration(DUR_ELIXIR_MAGIC, 10);</a>
<a name="ln1210">        break;</a>
<a name="ln1211">    default:</a>
<a name="ln1212">        you.set_duration(DUR_ELIXIR_HEALTH, 10);</a>
<a name="ln1213">        you.set_duration(DUR_ELIXIR_MAGIC, 10);</a>
<a name="ln1214">    }</a>
<a name="ln1215"> </a>
<a name="ln1216">    if (you.duration[DUR_ELIXIR_HEALTH] &amp;&amp; you.duration[DUR_ELIXIR_MAGIC])</a>
<a name="ln1217">        mpr(&quot;You begin rapidly regenerating health and magic.&quot;);</a>
<a name="ln1218">    else if (you.duration[DUR_ELIXIR_HEALTH])</a>
<a name="ln1219">        mpr(&quot;You begin rapidly regenerating.&quot;);</a>
<a name="ln1220">    else</a>
<a name="ln1221">        mpr(&quot;You begin rapidly regenerating magic.&quot;);</a>
<a name="ln1222"> </a>
<a name="ln1223">    apply_visible_monsters([=](monster&amp; mon)</a>
<a name="ln1224">    {</a>
<a name="ln1225">        if (mon.wont_attack())</a>
<a name="ln1226">        {</a>
<a name="ln1227">            const int hp = mon.max_hit_points / (4 - power_level);</a>
<a name="ln1228">            if (mon.heal(hp + random2avg(hp, 2)))</a>
<a name="ln1229">               simple_monster_message(mon, &quot; is healed.&quot;);</a>
<a name="ln1230">        }</a>
<a name="ln1231">        return true;</a>
<a name="ln1232">    });</a>
<a name="ln1233">}</a>
<a name="ln1234"> </a>
<a name="ln1235">// Special case for *your* god, maybe?</a>
<a name="ln1236">static void _godly_wrath()</a>
<a name="ln1237">{</a>
<a name="ln1238">    for (int tries = 0; tries &lt; 100; tries++)</a>
<a name="ln1239">    {</a>
<a name="ln1240">        god_type god = random_god();</a>
<a name="ln1241"> </a>
<a name="ln1242">        // Don't recursively make player draw from the Deck of Punishment.</a>
<a name="ln1243">        if (god != GOD_NEMELEX_XOBEH &amp;&amp; divine_retribution(god))</a>
<a name="ln1244">            return; // Stop once we find a god willing to punish the player.</a>
<a name="ln1245">    }</a>
<a name="ln1246"> </a>
<a name="ln1247">    mpr(&quot;You somehow manage to escape divine attention...&quot;);</a>
<a name="ln1248">}</a>
<a name="ln1249"> </a>
<a name="ln1250">static void _summon_demon_card(int power)</a>
<a name="ln1251">{</a>
<a name="ln1252">    const int power_level = _get_power_level(power);</a>
<a name="ln1253">    // one demon (potentially hostile), and one other demonic creature (always</a>
<a name="ln1254">    // friendly)</a>
<a name="ln1255">    monster_type dct, dct2;</a>
<a name="ln1256">    switch (power_level)</a>
<a name="ln1257">    {</a>
<a name="ln1258">    case 0:</a>
<a name="ln1259">        dct = random_demon_by_tier(4);</a>
<a name="ln1260">        dct2 = MONS_HELL_HOUND;</a>
<a name="ln1261">        break;</a>
<a name="ln1262">    case 1:</a>
<a name="ln1263">        dct = random_demon_by_tier(3);</a>
<a name="ln1264">        dct2 = MONS_RAKSHASA;</a>
<a name="ln1265">        break;</a>
<a name="ln1266">    default:</a>
<a name="ln1267">        dct = random_demon_by_tier(2);</a>
<a name="ln1268">        dct2 = MONS_PANDEMONIUM_LORD;</a>
<a name="ln1269">    }</a>
<a name="ln1270"> </a>
<a name="ln1271">    // FIXME: The manual testing for message printing is there because</a>
<a name="ln1272">    // we can't rely on create_monster() to do it for us. This is</a>
<a name="ln1273">    // because if you are completely surrounded by walls, create_monster()</a>
<a name="ln1274">    // will never manage to give a position which isn't (-1,-1)</a>
<a name="ln1275">    // and thus not print the message.</a>
<a name="ln1276">    // This hack appears later in this file as well.</a>
<a name="ln1277"> </a>
<a name="ln1278">    const bool hostile = one_chance_in(power_level + 4);</a>
<a name="ln1279"> </a>
<a name="ln1280">    if (!create_monster(mgen_data(dct, hostile ? BEH_HOSTILE : BEH_FRIENDLY,</a>
<a name="ln1281">                                  you.pos(), MHITYOU, MG_AUTOFOE)</a>
<a name="ln1282">                        .set_summoned(&amp;you, 5 - power_level, 0)))</a>
<a name="ln1283">    {</a>
<a name="ln1284">        mpr(&quot;You see a puff of smoke.&quot;);</a>
<a name="ln1285">    }</a>
<a name="ln1286">    else if (hostile</a>
<a name="ln1287">             &amp;&amp; mons_class_flag(dct, M_INVIS)</a>
<a name="ln1288">             &amp;&amp; !you.can_see_invisible())</a>
<a name="ln1289">    {</a>
<a name="ln1290">        mpr(&quot;You sense the presence of something unfriendly.&quot;);</a>
<a name="ln1291">    }</a>
<a name="ln1292"> </a>
<a name="ln1293">    _friendly(dct2, 5 - power_level);</a>
<a name="ln1294">}</a>
<a name="ln1295"> </a>
<a name="ln1296">static void _elements_card(int power)</a>
<a name="ln1297">{</a>
<a name="ln1298"> </a>
<a name="ln1299">    const int power_level = _get_power_level(power);</a>
<a name="ln1300">    const monster_type element_list[][3] =</a>
<a name="ln1301">    {</a>
<a name="ln1302">        {MONS_RAIJU, MONS_WIND_DRAKE, MONS_SHOCK_SERPENT},</a>
<a name="ln1303">        {MONS_BASILISK, MONS_CATOBLEPAS, MONS_IRON_GOLEM},</a>
<a name="ln1304">        {MONS_FIRE_VORTEX, MONS_MOLTEN_GARGOYLE, MONS_FIRE_DRAGON},</a>
<a name="ln1305">        {MONS_ICE_BEAST, MONS_POLAR_BEAR, MONS_ICE_DRAGON}</a>
<a name="ln1306">    };</a>
<a name="ln1307"> </a>
<a name="ln1308">    int start = random2(ARRAYSZ(element_list));</a>
<a name="ln1309">    for (int i = 0; i &lt; 3; ++i)</a>
<a name="ln1310">    {</a>
<a name="ln1311">        _friendly(element_list[start % ARRAYSZ(element_list)][power_level],</a>
<a name="ln1312">                  power_level + 2);</a>
<a name="ln1313">        start++;</a>
<a name="ln1314">    }</a>
<a name="ln1315"> </a>
<a name="ln1316">}</a>
<a name="ln1317"> </a>
<a name="ln1318">static void _summon_dancing_weapon(int power)</a>
<a name="ln1319">{</a>
<a name="ln1320">    const int power_level = _get_power_level(power);</a>
<a name="ln1321"> </a>
<a name="ln1322">    monster *mon =</a>
<a name="ln1323">        create_monster(</a>
<a name="ln1324">            mgen_data(MONS_DANCING_WEAPON, BEH_FRIENDLY, you.pos(), MHITYOU,</a>
<a name="ln1325">                      MG_AUTOFOE).set_summoned(&amp;you, power_level + 2, 0),</a>
<a name="ln1326">            false);</a>
<a name="ln1327"> </a>
<a name="ln1328">    if (!mon)</a>
<a name="ln1329">    {</a>
<a name="ln1330">        mpr(&quot;You see a puff of smoke.&quot;);</a>
<a name="ln1331">        return;</a>
<a name="ln1332">    }</a>
<a name="ln1333"> </a>
<a name="ln1334">    // Override the weapon.</a>
<a name="ln1335">    ASSERT(mon-&gt;weapon() != nullptr);</a>
<a name="ln1336">    item_def&amp; wpn(*mon-&gt;weapon());</a>
<a name="ln1337"> </a>
<a name="ln1338">    switch (power_level)</a>
<a name="ln1339">    {</a>
<a name="ln1340">    case 0:</a>
<a name="ln1341">        // Wimpy, negative-enchantment weapon.</a>
<a name="ln1342">        wpn.plus = random2(3) - 2;</a>
<a name="ln1343">        wpn.sub_type = random_choose(WPN_QUARTERSTAFF, WPN_HAND_AXE);</a>
<a name="ln1344"> </a>
<a name="ln1345">        set_item_ego_type(wpn, OBJ_WEAPONS,</a>
<a name="ln1346">                          random_choose(SPWPN_VENOM, SPWPN_NORMAL));</a>
<a name="ln1347">        break;</a>
<a name="ln1348">    case 1:</a>
<a name="ln1349">        // This is getting good.</a>
<a name="ln1350">        wpn.plus = random2(4) - 1;</a>
<a name="ln1351">        wpn.sub_type = random_choose(WPN_LONG_SWORD, WPN_TRIDENT);</a>
<a name="ln1352"> </a>
<a name="ln1353">        if (coinflip())</a>
<a name="ln1354">        {</a>
<a name="ln1355">            set_item_ego_type(wpn, OBJ_WEAPONS,</a>
<a name="ln1356">                              random_choose(SPWPN_FLAMING, SPWPN_FREEZING));</a>
<a name="ln1357">        }</a>
<a name="ln1358">        else</a>
<a name="ln1359">            set_item_ego_type(wpn, OBJ_WEAPONS, SPWPN_NORMAL);</a>
<a name="ln1360">        break;</a>
<a name="ln1361">    default:</a>
<a name="ln1362">        // Rare and powerful.</a>
<a name="ln1363">        wpn.plus = random2(4) + 2;</a>
<a name="ln1364">        wpn.sub_type = random_choose(WPN_DEMON_TRIDENT, WPN_EXECUTIONERS_AXE);</a>
<a name="ln1365"> </a>
<a name="ln1366">        set_item_ego_type(wpn, OBJ_WEAPONS,</a>
<a name="ln1367">                          random_choose(SPWPN_SPEED, SPWPN_ELECTROCUTION));</a>
<a name="ln1368">    }</a>
<a name="ln1369"> </a>
<a name="ln1370">    item_colour(wpn); // this is probably not needed</a>
<a name="ln1371"> </a>
<a name="ln1372">    // sometimes give a randart instead</a>
<a name="ln1373">    if (one_chance_in(3))</a>
<a name="ln1374">    {</a>
<a name="ln1375">        make_item_randart(wpn, true);</a>
<a name="ln1376">        set_ident_flags(wpn, ISFLAG_KNOW_PROPERTIES| ISFLAG_KNOW_TYPE);</a>
<a name="ln1377">    }</a>
<a name="ln1378"> </a>
<a name="ln1379">    // Don't leave a trail of weapons behind. (Especially not randarts!)</a>
<a name="ln1380">    mon-&gt;flags |= MF_HARD_RESET;</a>
<a name="ln1381"> </a>
<a name="ln1382">    ghost_demon newstats;</a>
<a name="ln1383">    newstats.init_dancing_weapon(wpn, power / 4);</a>
<a name="ln1384"> </a>
<a name="ln1385">    mon-&gt;set_ghost(newstats);</a>
<a name="ln1386">    mon-&gt;ghost_demon_init();</a>
<a name="ln1387">}</a>
<a name="ln1388"> </a>
<a name="ln1389">static void _summon_flying(int power)</a>
<a name="ln1390">{</a>
<a name="ln1391">    const int power_level = _get_power_level(power);</a>
<a name="ln1392"> </a>
<a name="ln1393">    const monster_type flytypes[] =</a>
<a name="ln1394">    {</a>
<a name="ln1395">        MONS_INSUBSTANTIAL_WISP, MONS_WYVERN, MONS_KILLER_BEE,</a>
<a name="ln1396">        MONS_VAMPIRE_MOSQUITO, MONS_HORNET</a>
<a name="ln1397">    };</a>
<a name="ln1398">    const int num_flytypes = ARRAYSZ(flytypes);</a>
<a name="ln1399"> </a>
<a name="ln1400">    // Choose what kind of monster.</a>
<a name="ln1401">    monster_type result;</a>
<a name="ln1402">    const int how_many = 2 + random2(3) + power_level * 3;</a>
<a name="ln1403">    bool hostile_invis = false;</a>
<a name="ln1404"> </a>
<a name="ln1405">    do</a>
<a name="ln1406">    {</a>
<a name="ln1407">        result = flytypes[random2(num_flytypes - 2) + power_level];</a>
<a name="ln1408">    }</a>
<a name="ln1409">    while (is_good_god(you.religion) &amp;&amp; result == MONS_VAMPIRE_MOSQUITO);</a>
<a name="ln1410"> </a>
<a name="ln1411">    for (int i = 0; i &lt; how_many; ++i)</a>
<a name="ln1412">    {</a>
<a name="ln1413">        const bool hostile = one_chance_in(power_level + 4);</a>
<a name="ln1414"> </a>
<a name="ln1415">        create_monster(</a>
<a name="ln1416">            mgen_data(result,</a>
<a name="ln1417">                      hostile ? BEH_HOSTILE : BEH_FRIENDLY, you.pos(), MHITYOU,</a>
<a name="ln1418">                      MG_AUTOFOE).set_summoned(&amp;you, 3, 0));</a>
<a name="ln1419"> </a>
<a name="ln1420">        if (hostile &amp;&amp; mons_class_flag(result, M_INVIS) &amp;&amp; !you.can_see_invisible())</a>
<a name="ln1421">            hostile_invis = true;</a>
<a name="ln1422">    }</a>
<a name="ln1423"> </a>
<a name="ln1424">    if (hostile_invis)</a>
<a name="ln1425">        mpr(&quot;You sense the presence of something unfriendly.&quot;);</a>
<a name="ln1426">}</a>
<a name="ln1427"> </a>
<a name="ln1428">static void _summon_rangers(int power)</a>
<a name="ln1429">{</a>
<a name="ln1430">    const int power_level = _get_power_level(power);</a>
<a name="ln1431">    const monster_type dctr  = random_choose(MONS_CENTAUR, MONS_YAKTAUR),</a>
<a name="ln1432">                       dctr2 = random_choose(MONS_CENTAUR_WARRIOR, MONS_FAUN),</a>
<a name="ln1433">                       dctr3 = random_choose(MONS_YAKTAUR_CAPTAIN,</a>
<a name="ln1434">                                             MONS_NAGA_SHARPSHOOTER),</a>
<a name="ln1435">                       dctr4 = random_choose(MONS_SATYR,</a>
<a name="ln1436">                                             MONS_MERFOLK_JAVELINEER,</a>
<a name="ln1437">                                             MONS_DEEP_ELF_MASTER_ARCHER);</a>
<a name="ln1438"> </a>
<a name="ln1439">    const monster_type base_choice = power_level == 2 ? dctr2 :</a>
<a name="ln1440">                                                        dctr;</a>
<a name="ln1441">    monster_type placed_choice  = power_level == 2 ? dctr3 :</a>
<a name="ln1442">                                  power_level == 1 ? dctr2 :</a>
<a name="ln1443">                                                     dctr;</a>
<a name="ln1444">    const bool extra_monster = coinflip();</a>
<a name="ln1445"> </a>
<a name="ln1446">    if (!extra_monster &amp;&amp; power_level &gt; 0)</a>
<a name="ln1447">        placed_choice = power_level == 2 ? dctr4 : dctr3;</a>
<a name="ln1448"> </a>
<a name="ln1449">    for (int i = 0; i &lt; 1 + extra_monster; ++i)</a>
<a name="ln1450">        _friendly(base_choice, 5 - power_level);</a>
<a name="ln1451"> </a>
<a name="ln1452">    _friendly(placed_choice, 5 - power_level);</a>
<a name="ln1453">}</a>
<a name="ln1454"> </a>
<a name="ln1455">static void _cloud_card(int power)</a>
<a name="ln1456">{</a>
<a name="ln1457">    const int power_level = _get_power_level(power);</a>
<a name="ln1458">    bool something_happened = false;</a>
<a name="ln1459"> </a>
<a name="ln1460">    for (radius_iterator di(you.pos(), LOS_NO_TRANS); di; ++di)</a>
<a name="ln1461">    {</a>
<a name="ln1462">        monster *mons = monster_at(*di);</a>
<a name="ln1463">        cloud_type cloudy;</a>
<a name="ln1464">        cloudy = CLOUD_BLACK_SMOKE;</a>
<a name="ln1465"> </a>
<a name="ln1466">        if (!mons || mons-&gt;wont_attack() || !mons_is_threatening(*mons))</a>
<a name="ln1467">            continue;</a>
<a name="ln1468"> </a>
<a name="ln1469">        for (adjacent_iterator ai(mons-&gt;pos(), false); ai; ++ai)</a>
<a name="ln1470">        {</a>
<a name="ln1471">            if (grd(*ai) == DNGN_FLOOR &amp;&amp; !cloud_at(*ai))</a>
<a name="ln1472">            {</a>
<a name="ln1473">                const int cloud_power = 5 + random2avg(power_level * 6, 2);</a>
<a name="ln1474">                place_cloud(cloudy, *ai, cloud_power, &amp;you);</a>
<a name="ln1475"> </a>
<a name="ln1476">                if (you.see_cell(*ai))</a>
<a name="ln1477">                    something_happened = true;</a>
<a name="ln1478">            }</a>
<a name="ln1479">        }</a>
<a name="ln1480">    }</a>
<a name="ln1481"> </a>
<a name="ln1482">    if (something_happened)</a>
<a name="ln1483">        mpr(&quot;Clouds appear around you!&quot;);</a>
<a name="ln1484">    else</a>
<a name="ln1485">        canned_msg(MSG_NOTHING_HAPPENS);</a>
<a name="ln1486">}</a>
<a name="ln1487"> </a>
<a name="ln1488">static void _storm_card(int power)</a>
<a name="ln1489">{</a>
<a name="ln1490">    const int power_level = _get_power_level(power);</a>
<a name="ln1491"> </a>
<a name="ln1492">    wind_blast(&amp;you, (power_level + 1) * 66, coord_def(), true);</a>
<a name="ln1493">    redraw_screen(); // Update monster positions</a>
<a name="ln1494"> </a>
<a name="ln1495">    // 1-3, 4-6, 7-9</a>
<a name="ln1496">    const int max_explosions = random_range((power_level * 3) + 1, (power_level + 1) * 3);</a>
<a name="ln1497">    // Select targets based on simultaneously running max_explosions resivoir</a>
<a name="ln1498">    // samples from the radius iterator over valid targets.</a>
<a name="ln1499">    //</a>
<a name="ln1500">    // Once the possible targets are drawn, the result is deduplicated into a</a>
<a name="ln1501">    // set of targets.</a>
<a name="ln1502">    vector&lt;coord_def&gt; target_draws (max_explosions, you.pos());</a>
<a name="ln1503">    int valid_targets = 0;</a>
<a name="ln1504">    for (radius_iterator ri(you.pos(), LOS_NO_TRANS, true); ri; ++ri)</a>
<a name="ln1505">    {</a>
<a name="ln1506">        if (grid_distance(*ri, you.pos()) &gt; 3 &amp;&amp; !cell_is_solid(*ri))</a>
<a name="ln1507">        {</a>
<a name="ln1508">            ++valid_targets;</a>
<a name="ln1509">            for (int i = 0; i &lt; max_explosions; ++i)</a>
<a name="ln1510">            {</a>
<a name="ln1511">                if (one_chance_in(valid_targets))</a>
<a name="ln1512">                    target_draws[i] = *ri;</a>
<a name="ln1513">            }</a>
<a name="ln1514">        }</a>
<a name="ln1515">    }</a>
<a name="ln1516"> </a>
<a name="ln1517">    unordered_set&lt;coord_def&gt; targets (target_draws.begin(), target_draws.end());</a>
<a name="ln1518">    targets.erase(you.pos());</a>
<a name="ln1519"> </a>
<a name="ln1520">    bool heard = false;</a>
<a name="ln1521">    for (auto p : targets)</a>
<a name="ln1522">    {</a>
<a name="ln1523">        bolt beam;</a>
<a name="ln1524">        beam.is_tracer         = false;</a>
<a name="ln1525">        beam.is_explosion      = true;</a>
<a name="ln1526">        beam.glyph             = dchar_glyph(DCHAR_FIRED_BURST);</a>
<a name="ln1527">        beam.name              = &quot;electrical discharge&quot;;</a>
<a name="ln1528">        beam.aux_source        = &quot;the storm&quot;;</a>
<a name="ln1529">        beam.explode_noise_msg = &quot;You hear a clap of thunder!&quot;;</a>
<a name="ln1530">        beam.real_flavour      = beam.flavour;</a>
<a name="ln1531">        beam.colour            = LIGHTCYAN;</a>
<a name="ln1532">        beam.source_id         = MID_PLAYER;</a>
<a name="ln1533">        beam.thrower           = KILL_YOU;</a>
<a name="ln1534">        beam.is_explosion      = true;</a>
<a name="ln1535">        beam.ex_size           = 3;</a>
<a name="ln1536">        beam.damage            = dice_def(3, 9 + 9 * power_level);</a>
<a name="ln1537">        beam.source = p;</a>
<a name="ln1538">        beam.target = p;</a>
<a name="ln1539">        beam.explode();</a>
<a name="ln1540">        heard = heard || player_can_hear(p);</a>
<a name="ln1541">    }</a>
<a name="ln1542">    // Lots of loud bangs, even if everything is silenced get a message.</a>
<a name="ln1543">    // Thunder comes after the animation runs.</a>
<a name="ln1544">    if (targets.size() &gt; 0)</a>
<a name="ln1545">    {</a>
<a name="ln1546">        vector&lt;string&gt; thunder_adjectives = { &quot;mighty&quot;,</a>
<a name="ln1547">                                              &quot;violent&quot;,</a>
<a name="ln1548">                                              &quot;cataclysmic&quot; };</a>
<a name="ln1549">        mprf(&quot;You %s %s%s peal%s of thunder!&quot;,</a>
<a name="ln1550">              heard ? &quot;hear&quot; : &quot;feel&quot;,</a>
<a name="ln1551">              targets.size() &gt; 1 ? &quot;&quot; : &quot;a &quot;,</a>
<a name="ln1552">              thunder_adjectives[power_level].c_str(),</a>
<a name="ln1553">              targets.size() &gt; 1 ? &quot;s&quot; : &quot;&quot;);</a>
<a name="ln1554">    }</a>
<a name="ln1555">}</a>
<a name="ln1556"> </a>
<a name="ln1557">static void _illusion_card(int power)</a>
<a name="ln1558">{</a>
<a name="ln1559">    const int power_level = _get_power_level(power);</a>
<a name="ln1560">    monster* mon = get_free_monster();</a>
<a name="ln1561"> </a>
<a name="ln1562">    if (!mon || monster_at(you.pos()))</a>
<a name="ln1563">        return;</a>
<a name="ln1564"> </a>
<a name="ln1565">    mon-&gt;type = MONS_PLAYER;</a>
<a name="ln1566">    mon-&gt;behaviour = BEH_SEEK;</a>
<a name="ln1567">    mon-&gt;attitude = ATT_FRIENDLY;</a>
<a name="ln1568">    mon-&gt;set_position(you.pos());</a>
<a name="ln1569">    mon-&gt;mid = MID_PLAYER;</a>
<a name="ln1570">    mgrd(you.pos()) = mon-&gt;mindex();</a>
<a name="ln1571"> </a>
<a name="ln1572">    mons_summon_illusion_from(mon, (actor *)&amp;you, SPELL_NO_SPELL, power_level);</a>
<a name="ln1573">    mon-&gt;reset();</a>
<a name="ln1574">}</a>
<a name="ln1575"> </a>
<a name="ln1576">static void _degeneration_card(int power)</a>
<a name="ln1577">{</a>
<a name="ln1578">    const int power_level = _get_power_level(power);</a>
<a name="ln1579"> </a>
<a name="ln1580">    if (!apply_visible_monsters([power_level](monster&amp; mons)</a>
<a name="ln1581">           {</a>
<a name="ln1582">               if (mons.wont_attack() || !mons_is_threatening(mons))</a>
<a name="ln1583">                   return false;</a>
<a name="ln1584"> </a>
<a name="ln1585">               if (!x_chance_in_y((power_level + 1) * 5 + random2(5),</a>
<a name="ln1586">                                  mons.get_hit_dice()))</a>
<a name="ln1587">               {</a>
<a name="ln1588">                   return false;</a>
<a name="ln1589">               }</a>
<a name="ln1590"> </a>
<a name="ln1591">               if (mons.can_polymorph())</a>
<a name="ln1592">               {</a>
<a name="ln1593">                   mons.polymorph(PPT_LESS);</a>
<a name="ln1594">                   mons.malmutate(&quot;&quot;);</a>
<a name="ln1595">               }</a>
<a name="ln1596">               else</a>
<a name="ln1597">               {</a>
<a name="ln1598">                   const int daze_time = (5 + 5 * power_level) * BASELINE_DELAY;</a>
<a name="ln1599">                   mons.add_ench(mon_enchant(ENCH_DAZED, 0, &amp;you, daze_time));</a>
<a name="ln1600">                   simple_monster_message(mons,</a>
<a name="ln1601">                                          &quot; is dazed by the mutagenic energy.&quot;);</a>
<a name="ln1602">               }</a>
<a name="ln1603">               return true;</a>
<a name="ln1604">           }))</a>
<a name="ln1605">    {</a>
<a name="ln1606">        canned_msg(MSG_NOTHING_HAPPENS);</a>
<a name="ln1607">    }</a>
<a name="ln1608">}</a>
<a name="ln1609"> </a>
<a name="ln1610">static void _wild_magic_card(int power)</a>
<a name="ln1611">{</a>
<a name="ln1612">    const int power_level = _get_power_level(power);</a>
<a name="ln1613">    int num_affected = 0;</a>
<a name="ln1614"> </a>
<a name="ln1615">    for (radius_iterator di(you.pos(), LOS_NO_TRANS); di; ++di)</a>
<a name="ln1616">    {</a>
<a name="ln1617">        monster *mons = monster_at(*di);</a>
<a name="ln1618"> </a>
<a name="ln1619">        if (!mons || mons-&gt;wont_attack() || !mons_is_threatening(*mons))</a>
<a name="ln1620">            continue;</a>
<a name="ln1621"> </a>
<a name="ln1622">        if (x_chance_in_y((power_level + 1) * 5 + random2(5),</a>
<a name="ln1623">                           mons-&gt;get_hit_dice()))</a>
<a name="ln1624">        {</a>
<a name="ln1625">            // skip summoning and tlocs, only destructive forces</a>
<a name="ln1626">            spschool type = random_choose(spschool::conjuration,</a>
<a name="ln1627">                                          spschool::fire,</a>
<a name="ln1628">                                          spschool::ice,</a>
<a name="ln1629">                                          spschool::earth,</a>
<a name="ln1630">                                          spschool::air,</a>
<a name="ln1631">                                          spschool::poison,</a>
<a name="ln1632">                                          spschool::transmutation,</a>
<a name="ln1633">                                          spschool::charms,</a>
<a name="ln1634">                                          spschool::hexes,</a>
<a name="ln1635">                                          spschool::necromancy);</a>
<a name="ln1636"> </a>
<a name="ln1637">            miscast_effect(*mons, &amp;you,</a>
<a name="ln1638">                           {miscast_source::deck}, type,</a>
<a name="ln1639">                           3 * (power_level + 1), random2(70),</a>
<a name="ln1640">                           &quot;a card of wild magic&quot;);</a>
<a name="ln1641"> </a>
<a name="ln1642">            num_affected++;</a>
<a name="ln1643">        }</a>
<a name="ln1644">    }</a>
<a name="ln1645"> </a>
<a name="ln1646">    if (num_affected &gt; 0)</a>
<a name="ln1647">    {</a>
<a name="ln1648">        int mp = 0;</a>
<a name="ln1649"> </a>
<a name="ln1650">        for (int i = 0; i &lt; num_affected; ++i)</a>
<a name="ln1651">            mp += random2(5);</a>
<a name="ln1652"> </a>
<a name="ln1653">        mpr(&quot;You feel a surge of magic.&quot;);</a>
<a name="ln1654">        if (mp &amp;&amp; you.magic_points &lt; you.max_magic_points)</a>
<a name="ln1655">        {</a>
<a name="ln1656">            inc_mp(mp);</a>
<a name="ln1657">            canned_msg(MSG_GAIN_MAGIC);</a>
<a name="ln1658">        }</a>
<a name="ln1659">    }</a>
<a name="ln1660">    else</a>
<a name="ln1661">        canned_msg(MSG_NOTHING_HAPPENS);</a>
<a name="ln1662">}</a>
<a name="ln1663"> </a>
<a name="ln1664">static void _torment_card()</a>
<a name="ln1665">{</a>
<a name="ln1666">    if (you.undead_or_demonic())</a>
<a name="ln1667">        holy_word_player(HOLY_WORD_CARD);</a>
<a name="ln1668">    else</a>
<a name="ln1669">        torment_player(&amp;you, TORMENT_CARDS);</a>
<a name="ln1670">}</a>
<a name="ln1671"> </a>
<a name="ln1672">// Punishment cards don't have their power adjusted depending on Nemelex piety,</a>
<a name="ln1673">// and are based on experience level instead of invocations skill.</a>
<a name="ln1674">// Max power = 200 * (2700+2500) / 2700 + 243 + 300 = 928</a>
<a name="ln1675">// Min power = 1 * 2501 / 2700 + 1 + 0 = 2</a>
<a name="ln1676">static int _card_power(bool punishment)</a>
<a name="ln1677">{</a>
<a name="ln1678">    if (punishment)</a>
<a name="ln1679">        return you.experience_level * 18;</a>
<a name="ln1680"> </a>
<a name="ln1681">    int result = you.piety;</a>
<a name="ln1682">    result *= you.skill(SK_INVOCATIONS, 100) + 2500;</a>
<a name="ln1683">    result /= 2700;</a>
<a name="ln1684">    result += you.skill(SK_INVOCATIONS, 9);</a>
<a name="ln1685">    result += (you.piety * 3) / 2;</a>
<a name="ln1686"> </a>
<a name="ln1687">    return result;</a>
<a name="ln1688">}</a>
<a name="ln1689"> </a>
<a name="ln1690">void card_effect(card_type which_card,</a>
<a name="ln1691">                 bool dealt,</a>
<a name="ln1692">                 bool punishment, bool tell_card)</a>
<a name="ln1693">{</a>
<a name="ln1694">    const char *participle = dealt ? &quot;dealt&quot; : &quot;drawn&quot;;</a>
<a name="ln1695">    const int power = _card_power(punishment);</a>
<a name="ln1696"> </a>
<a name="ln1697">    dprf(&quot;Card power: %d&quot;, power);</a>
<a name="ln1698"> </a>
<a name="ln1699">    if (tell_card)</a>
<a name="ln1700">    {</a>
<a name="ln1701">        // These card types will usually give this message in the targeting</a>
<a name="ln1702">        // prompt, and the cases where they don't are handled specially.</a>
<a name="ln1703">        if (which_card != CARD_VITRIOL</a>
<a name="ln1704">            &amp;&amp; which_card != CARD_PAIN</a>
<a name="ln1705">            &amp;&amp; which_card != CARD_ORB)</a>
<a name="ln1706">        {</a>
<a name="ln1707">            mprf(&quot;You have %s %s.&quot;, participle, card_name(which_card));</a>
<a name="ln1708">        }</a>
<a name="ln1709">    }</a>
<a name="ln1710"> </a>
<a name="ln1711">    switch (which_card)</a>
<a name="ln1712">    {</a>
<a name="ln1713">    case CARD_VELOCITY:         _velocity_card(power); break;</a>
<a name="ln1714">    case CARD_EXILE:            _exile_card(power); break;</a>
<a name="ln1715">    case CARD_ELIXIR:           _elixir_card(power); break;</a>
<a name="ln1716">    case CARD_STAIRS:           _stairs_card(power); break;</a>
<a name="ln1717">    case CARD_SHAFT:            _shaft_card(power); break;</a>
<a name="ln1718">    case CARD_TOMB:             entomb(10 + power/20 + random2(power/4)); break;</a>
<a name="ln1719">    case CARD_WRAITH:           drain_player(power / 4, false, true); break;</a>
<a name="ln1720">    case CARD_WRATH:            _godly_wrath(); break;</a>
<a name="ln1721">    case CARD_SUMMON_DEMON:     _summon_demon_card(power); break;</a>
<a name="ln1722">    case CARD_ELEMENTS:         _elements_card(power); break;</a>
<a name="ln1723">    case CARD_RANGERS:          _summon_rangers(power); break;</a>
<a name="ln1724">    case CARD_SUMMON_WEAPON:    _summon_dancing_weapon(power); break;</a>
<a name="ln1725">    case CARD_SUMMON_FLYING:    _summon_flying(power); break;</a>
<a name="ln1726">    case CARD_TORMENT:          _torment_card(); break;</a>
<a name="ln1727">    case CARD_CLOUD:            _cloud_card(power); break;</a>
<a name="ln1728">    case CARD_STORM:            _storm_card(power); break;</a>
<a name="ln1729">    case CARD_ILLUSION:         _illusion_card(power); break;</a>
<a name="ln1730">    case CARD_DEGEN:            _degeneration_card(power); break;</a>
<a name="ln1731">    case CARD_WILD_MAGIC:       _wild_magic_card(power); break;</a>
<a name="ln1732"> </a>
<a name="ln1733">    case CARD_VITRIOL:</a>
<a name="ln1734">    case CARD_PAIN:</a>
<a name="ln1735">    case CARD_ORB:</a>
<a name="ln1736">        _damaging_card(which_card, power, dealt);</a>
<a name="ln1737">        break;</a>
<a name="ln1738"> </a>
<a name="ln1739">    case CARD_FAMINE:</a>
<a name="ln1740">        if (you_foodless())</a>
<a name="ln1741">            mpr(&quot;You feel rather smug.&quot;);</a>
<a name="ln1742">        else</a>
<a name="ln1743">            set_hunger(min(you.hunger, HUNGER_STARVING / 2), true);</a>
<a name="ln1744">        break;</a>
<a name="ln1745"> </a>
<a name="ln1746">    case CARD_SWINE:</a>
<a name="ln1747">        if (transform(5 + power/10 + random2(power/10), transformation::pig, true))</a>
<a name="ln1748">            you.transform_uncancellable = true;</a>
<a name="ln1749">        else</a>
<a name="ln1750">            mpr(&quot;You feel a momentary urge to oink.&quot;);</a>
<a name="ln1751">        break;</a>
<a name="ln1752"> </a>
<a name="ln1753">    case NUM_CARDS:</a>
<a name="ln1754">        // The compiler will complain if any card remains unhandled.</a>
<a name="ln1755">        mprf(&quot;You have %s a buggy card!&quot;, participle);</a>
<a name="ln1756">        break;</a>
<a name="ln1757">    }</a>
<a name="ln1758">}</a>
<a name="ln1759"> </a>
<a name="ln1760">/**</a>
<a name="ln1761"> * Return the appropriate name for a known deck of the given type.</a>
<a name="ln1762"> *</a>
<a name="ln1763"> * @param sub_type  The type of deck in question.</a>
<a name="ln1764"> * @return          A name, e.g. &quot;deck of destruction&quot;.</a>
<a name="ln1765"> *                  If the given type isn't a deck, return &quot;deck of bugginess&quot;.</a>
<a name="ln1766"> */</a>
<a name="ln1767">string deck_name(deck_type deck)</a>
<a name="ln1768">{</a>
<a name="ln1769">    if (deck == DECK_STACK)</a>
<a name="ln1770">        return &quot;stacked deck&quot;;</a>
<a name="ln1771">    const deck_type_data *deck_data = map_find(all_decks, deck);</a>
<a name="ln1772">    const string name = deck_data ? deck_data-&gt;name : &quot;bugginess&quot;;</a>
<a name="ln1773">    return &quot;deck of &quot; + name;</a>
<a name="ln1774">}</a>
<a name="ln1775"> </a>
<a name="ln1776">#if TAG_MAJOR_VERSION == 34</a>
<a name="ln1777">bool is_deck_type(uint8_t sub_type)</a>
<a name="ln1778">{</a>
<a name="ln1779">    return (MISC_FIRST_DECK &lt;= sub_type &amp;&amp; sub_type &lt;= MISC_LAST_DECK)</a>
<a name="ln1780">        || sub_type == MISC_DECK_OF_ODDITIES</a>
<a name="ln1781">        || sub_type == MISC_DECK_UNKNOWN;</a>
<a name="ln1782">}</a>
<a name="ln1783"> </a>
<a name="ln1784">bool is_deck(const item_def &amp;item)</a>
<a name="ln1785">{</a>
<a name="ln1786">    return item.base_type == OBJ_MISCELLANY</a>
<a name="ln1787">           &amp;&amp; is_deck_type(item.sub_type);</a>
<a name="ln1788">}</a>
<a name="ln1789"> </a>
<a name="ln1790">void reclaim_decks_on_level()</a>
<a name="ln1791">{</a>
<a name="ln1792">    for (auto &amp;item : mitm)</a>
<a name="ln1793">        if (item.defined() &amp;&amp; is_deck(item))</a>
<a name="ln1794">            destroy_item(item.index());</a>
<a name="ln1795">}</a>
<a name="ln1796"> </a>
<a name="ln1797">static void _reclaim_inventory_decks()</a>
<a name="ln1798">{</a>
<a name="ln1799">    for (auto &amp;item : you.inv)</a>
<a name="ln1800">        if (item.defined() &amp;&amp; is_deck(item))</a>
<a name="ln1801">            dec_inv_item_quantity(item.link, 1);</a>
<a name="ln1802">}</a>
<a name="ln1803"> </a>
<a name="ln1804">void reclaim_decks()</a>
<a name="ln1805">{</a>
<a name="ln1806">    add_daction(DACT_RECLAIM_DECKS);</a>
<a name="ln1807">    _reclaim_inventory_decks();</a>
<a name="ln1808">}</a>
<a name="ln1809">#endif</a>

</code></pre>
<div class="balloon" rel="534"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v506/" target="_blank">V506</a> Pointer to local variable 'numbers' is stored outside the scope of this variable. Such a pointer will become invalid.</p></div>
<div class="balloon" rel="730"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v506/" target="_blank">V506</a> Pointer to local variable 'numbers' is stored outside the scope of this variable. Such a pointer will become invalid.</p></div>
<div class="balloon" rel="1524"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v1048/" target="_blank">V1048</a> The 'beam.is_tracer' variable was assigned the same value.</p></div>
<div class="balloon" rel="1530"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v1048/" target="_blank">V1048</a> The 'beam.real_flavour' variable was assigned the same value.</p></div>
<div class="balloon" rel="1534"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v1048/" target="_blank">V1048</a> The 'beam.is_explosion' variable was assigned the same value.</p></div>
<div class="balloon" rel="1534"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v519/" target="_blank">V519</a> The 'beam.is_explosion' variable is assigned values twice successively. Perhaps this is a mistake. Check lines: 1525, 1534.</p></div>

<link rel="stylesheet" href="highlight.css">
<script src="highlight.pack.js"></script>
<script src="highlightjs-line-numbers.js"></script>
<script>hljs.initHighlightingOnLoad();</script>
<script>hljs.initLineNumbersOnLoad();</script>
<script>
  $(document).ready(function() {
      $('.balloon').each(function () {
          var bl = $(this);
          var line = bl.attr('rel');
          var text = $('a[name="ln'+line+'"]').text();

          var space_count = 0;
          for(var i = 0; i<text.length; i++){
              var char = text[i];
              if((char !== ' ')&&(char !== '\t'))break;
              if(char === '\t')space_count++;
              space_count++;
          }

          bl.css('margin-left', space_count*8);
          $('a[name="ln'+line+'"]').after(bl);
      });

      window.location = window.location;
  });
</script>
</body>
</html>
