
<html>
<head>

  <meta http-equiv="Content-Type" content="text/html; charset=US-ASCII" />
  <title>mutation.cc</title>

  <link rel="stylesheet" href="../style.css"/>
  <script src="../jquery-3.2.1.min.js"></script>
</head>
<body>

<pre><code class = "cpp">
<a name="ln1">/**</a>
<a name="ln2"> * @file</a>
<a name="ln3"> * @brief Functions for handling player mutations.</a>
<a name="ln4">**/</a>
<a name="ln5"> </a>
<a name="ln6">#include &quot;AppHdr.h&quot;</a>
<a name="ln7"> </a>
<a name="ln8">#include &quot;mutation.h&quot;</a>
<a name="ln9"> </a>
<a name="ln10">#include &lt;algorithm&gt;</a>
<a name="ln11">#include &lt;cmath&gt;</a>
<a name="ln12">#include &lt;cstdio&gt;</a>
<a name="ln13">#include &lt;cstdlib&gt;</a>
<a name="ln14">#include &lt;cstring&gt;</a>
<a name="ln15">#include &lt;sstream&gt;</a>
<a name="ln16"> </a>
<a name="ln17">#include &quot;ability.h&quot;</a>
<a name="ln18">#include &quot;cio.h&quot;</a>
<a name="ln19">#include &quot;coordit.h&quot;</a>
<a name="ln20">#include &quot;dactions.h&quot;</a>
<a name="ln21">#include &quot;delay.h&quot;</a>
<a name="ln22">#include &quot;english.h&quot;</a>
<a name="ln23">#include &quot;env.h&quot;</a>
<a name="ln24">#include &quot;god-abil.h&quot;</a>
<a name="ln25">#include &quot;god-passive.h&quot;</a>
<a name="ln26">#include &quot;hints.h&quot;</a>
<a name="ln27">#include &quot;item-prop.h&quot;</a>
<a name="ln28">#include &quot;items.h&quot;</a>
<a name="ln29">#include &quot;libutil.h&quot;</a>
<a name="ln30">#include &quot;menu.h&quot;</a>
<a name="ln31">#include &quot;message.h&quot;</a>
<a name="ln32">#include &quot;mon-place.h&quot;</a>
<a name="ln33">#include &quot;notes.h&quot;</a>
<a name="ln34">#include &quot;output.h&quot;</a>
<a name="ln35">#include &quot;player-equip.h&quot; // lose_permafly_source</a>
<a name="ln36">#include &quot;player-stats.h&quot;</a>
<a name="ln37">#include &quot;religion.h&quot;</a>
<a name="ln38">#include &quot;skills.h&quot;</a>
<a name="ln39">#include &quot;state.h&quot;</a>
<a name="ln40">#include &quot;stringutil.h&quot;</a>
<a name="ln41">#include &quot;transform.h&quot;</a>
<a name="ln42">#include &quot;unicode.h&quot;</a>
<a name="ln43">#include &quot;xom.h&quot;</a>
<a name="ln44"> </a>
<a name="ln45">using namespace ui;</a>
<a name="ln46"> </a>
<a name="ln47">static bool _delete_single_mutation_level(mutation_type mutat, const string &amp;reason, bool transient);</a>
<a name="ln48"> </a>
<a name="ln49">struct body_facet_def</a>
<a name="ln50">{</a>
<a name="ln51">    equipment_type eq;</a>
<a name="ln52">    mutation_type mut;</a>
<a name="ln53">};</a>
<a name="ln54"> </a>
<a name="ln55">struct facet_def</a>
<a name="ln56">{</a>
<a name="ln57">    int tier;</a>
<a name="ln58">    mutation_type muts[3];</a>
<a name="ln59">    int when[3];</a>
<a name="ln60">};</a>
<a name="ln61"> </a>
<a name="ln62">struct demon_mutation_info</a>
<a name="ln63">{</a>
<a name="ln64">    mutation_type mut;</a>
<a name="ln65">    int when;</a>
<a name="ln66">    int facet;</a>
<a name="ln67"> </a>
<a name="ln68">    demon_mutation_info(mutation_type m, int w, int f)</a>
<a name="ln69">        : mut(m), when(w), facet(f) { }</a>
<a name="ln70">};</a>
<a name="ln71"> </a>
<a name="ln72">enum class mutflag</a>
<a name="ln73">{</a>
<a name="ln74">    good    = 1 &lt;&lt; 0, // used by benemut etc</a>
<a name="ln75">    bad     = 1 &lt;&lt; 1, // used by malmut etc</a>
<a name="ln76">    jiyva   = 1 &lt;&lt; 2, // jiyva-only muts</a>
<a name="ln77">    qazlal  = 1 &lt;&lt; 3, // qazlal wrath</a>
<a name="ln78">    xom     = 1 &lt;&lt; 4, // xom being xom</a>
<a name="ln79"> </a>
<a name="ln80">    last    = xom</a>
<a name="ln81">};</a>
<a name="ln82">DEF_BITFIELD(mutflags, mutflag, 4);</a>
<a name="ln83">COMPILE_CHECK(mutflags::exponent(mutflags::last_exponent) == mutflag::last);</a>
<a name="ln84"> </a>
<a name="ln85">#include &quot;mutation-data.h&quot;</a>
<a name="ln86"> </a>
<a name="ln87">static const body_facet_def _body_facets[] =</a>
<a name="ln88">{</a>
<a name="ln89">    //{ EQ_NONE, MUT_FANGS },</a>
<a name="ln90">    { EQ_HELMET, MUT_HORNS },</a>
<a name="ln91">    { EQ_HELMET, MUT_ANTENNAE },</a>
<a name="ln92">    //{ EQ_HELMET, MUT_BEAK },</a>
<a name="ln93">    { EQ_GLOVES, MUT_CLAWS },</a>
<a name="ln94">    { EQ_BOOTS, MUT_HOOVES },</a>
<a name="ln95">    { EQ_BOOTS, MUT_TALONS }</a>
<a name="ln96">};</a>
<a name="ln97"> </a>
<a name="ln98">/**</a>
<a name="ln99"> * Conflicting mutation pairs. Entries are symmetric (so if A conflicts</a>
<a name="ln100"> * with B, B conflicts with A in the same way).</a>
<a name="ln101"> *</a>
<a name="ln102"> * The third value in each entry means:</a>
<a name="ln103"> *   0: If the new mutation is forced, remove all levels of the old</a>
<a name="ln104"> *      mutation. Either way, keep scanning for more conflicts and</a>
<a name="ln105"> *      do what they say (accepting the mutation if there are no</a>
<a name="ln106"> *      further conflicts).</a>
<a name="ln107"> *</a>
<a name="ln108"> *  -1: If the new mutation is forced, remove all levels of the old</a>
<a name="ln109"> *      mutation and scan for more conflicts. If it is not forced,</a>
<a name="ln110"> *      fail at giving the new mutation.</a>
<a name="ln111"> *</a>
<a name="ln112"> *   1: If the new mutation is temporary, just allow the conflict.</a>
<a name="ln113"> *      Otherwise, trade off: delete one level of the old mutation,</a>
<a name="ln114"> *      don't give the new mutation, and consider it a success.</a>
<a name="ln115"> *</a>
<a name="ln116"> * It makes sense to have two entries for the same pair, one with value 0</a>
<a name="ln117"> * and one with 1: that would replace all levels of the old mutation if</a>
<a name="ln118"> * forced, or a single level if not forced. However, the 0 entry must</a>
<a name="ln119"> * precede the 1 entry; so if you re-order this list, keep all the 0s</a>
<a name="ln120"> * before all the 1s.</a>
<a name="ln121"> */</a>
<a name="ln122">static const int conflict[][3] =</a>
<a name="ln123">{</a>
<a name="ln124">    { MUT_REGENERATION,        MUT_SLOW_METABOLISM,         0},</a>
<a name="ln125">    { MUT_REGENERATION,        MUT_INHIBITED_REGENERATION,  0},</a>
<a name="ln126">    { MUT_ACUTE_VISION,        MUT_BLURRY_VISION,           0},</a>
<a name="ln127">    { MUT_FAST,                MUT_SLOW,                    0},</a>
<a name="ln128">#if TAG_MAJOR_VERSION == 34</a>
<a name="ln129">    { MUT_STRONG_STIFF,        MUT_FLEXIBLE_WEAK,           1},</a>
<a name="ln130">#endif</a>
<a name="ln131">    { MUT_STRONG,              MUT_WEAK,                    1},</a>
<a name="ln132">    { MUT_CLEVER,              MUT_DOPEY,                   1},</a>
<a name="ln133">    { MUT_AGILE,               MUT_CLUMSY,                  1},</a>
<a name="ln134">    { MUT_ROBUST,              MUT_FRAIL,                   1},</a>
<a name="ln135">    { MUT_HIGH_MAGIC,          MUT_LOW_MAGIC,               1},</a>
<a name="ln136">    { MUT_WILD_MAGIC,          MUT_SUBDUED_MAGIC,           1},</a>
<a name="ln137">    { MUT_CARNIVOROUS,         MUT_HERBIVOROUS,             1},</a>
<a name="ln138">    { MUT_SLOW_METABOLISM,     MUT_FAST_METABOLISM,         1},</a>
<a name="ln139">    { MUT_REGENERATION,        MUT_INHIBITED_REGENERATION,  1},</a>
<a name="ln140">    { MUT_ACUTE_VISION,        MUT_BLURRY_VISION,           1},</a>
<a name="ln141">    { MUT_BERSERK,             MUT_CLARITY,                 1},</a>
<a name="ln142">    { MUT_FAST,                MUT_SLOW,                    1},</a>
<a name="ln143">    { MUT_FANGS,               MUT_BEAK,                   -1},</a>
<a name="ln144">    { MUT_ANTENNAE,            MUT_HORNS,                  -1}, // currently overridden by physiology_mutation_conflict</a>
<a name="ln145">    { MUT_HOOVES,              MUT_TALONS,                 -1}, // currently overridden by physiology_mutation_conflict</a>
<a name="ln146">    { MUT_TRANSLUCENT_SKIN,    MUT_CAMOUFLAGE,             -1},</a>
<a name="ln147">    { MUT_MUTATION_RESISTANCE, MUT_EVOLUTION,              -1},</a>
<a name="ln148">    { MUT_ANTIMAGIC_BITE,      MUT_ACIDIC_BITE,            -1},</a>
<a name="ln149">    { MUT_HEAT_RESISTANCE,     MUT_HEAT_VULNERABILITY,     -1},</a>
<a name="ln150">    { MUT_COLD_RESISTANCE,     MUT_COLD_VULNERABILITY,     -1},</a>
<a name="ln151">    { MUT_SHOCK_RESISTANCE,    MUT_SHOCK_VULNERABILITY,    -1},</a>
<a name="ln152">    { MUT_MAGIC_RESISTANCE,    MUT_MAGICAL_VULNERABILITY,  -1},</a>
<a name="ln153">    { MUT_NO_REGENERATION,     MUT_INHIBITED_REGENERATION, -1},</a>
<a name="ln154">    { MUT_NO_REGENERATION,     MUT_REGENERATION,           -1},</a>
<a name="ln155">};</a>
<a name="ln156"> </a>
<a name="ln157">equipment_type beastly_slot(int mut)</a>
<a name="ln158">{</a>
<a name="ln159">    switch (mut)</a>
<a name="ln160">    {</a>
<a name="ln161">    case MUT_HORNS:</a>
<a name="ln162">    case MUT_ANTENNAE:</a>
<a name="ln163">    // Not putting MUT_BEAK here because it doesn't conflict with the other two.</a>
<a name="ln164">        return EQ_HELMET;</a>
<a name="ln165">    case MUT_CLAWS:</a>
<a name="ln166">        return EQ_GLOVES;</a>
<a name="ln167">    case MUT_HOOVES:</a>
<a name="ln168">    case MUT_TALONS:</a>
<a name="ln169">    case MUT_TENTACLE_SPIKE:</a>
<a name="ln170">        return EQ_BOOTS;</a>
<a name="ln171">    default:</a>
<a name="ln172">        return EQ_NONE;</a>
<a name="ln173">    }</a>
<a name="ln174">}</a>
<a name="ln175"> </a>
<a name="ln176">static bool _mut_has_use(const mutation_def &amp;mut, mutflag use)</a>
<a name="ln177">{</a>
<a name="ln178">    return bool(mut.uses &amp; use);</a>
<a name="ln179">}</a>
<a name="ln180"> </a>
<a name="ln181">#define MUT_BAD(mut) _mut_has_use((mut), mutflag::bad)</a>
<a name="ln182">#define MUT_GOOD(mut) _mut_has_use((mut), mutflag::good)</a>
<a name="ln183"> </a>
<a name="ln184">static int _mut_weight(const mutation_def &amp;mut, mutflag use)</a>
<a name="ln185">{</a>
<a name="ln186">    switch (use)</a>
<a name="ln187">    {</a>
<a name="ln188">        case mutflag::jiyva:</a>
<a name="ln189">        case mutflag::qazlal:</a>
<a name="ln190">        case mutflag::xom:</a>
<a name="ln191">            return 1;</a>
<a name="ln192">        case mutflag::good:</a>
<a name="ln193">        case mutflag::bad:</a>
<a name="ln194">        default:</a>
<a name="ln195">            return mut.weight;</a>
<a name="ln196">    }</a>
<a name="ln197">}</a>
<a name="ln198"> </a>
<a name="ln199">static int mut_index[NUM_MUTATIONS];</a>
<a name="ln200">static int category_mut_index[MUT_NON_MUTATION - CATEGORY_MUTATIONS];</a>
<a name="ln201">static map&lt;mutflag, int&gt; total_weight;</a>
<a name="ln202"> </a>
<a name="ln203">void init_mut_index()</a>
<a name="ln204">{</a>
<a name="ln205">    total_weight.clear();</a>
<a name="ln206">    for (int i = 0; i &lt; NUM_MUTATIONS; ++i)</a>
<a name="ln207">        mut_index[i] = -1;</a>
<a name="ln208"> </a>
<a name="ln209">    for (unsigned int i = 0; i &lt; ARRAYSZ(mut_data); ++i)</a>
<a name="ln210">    {</a>
<a name="ln211">        const mutation_type mut = mut_data[i].mutation;</a>
<a name="ln212">        ASSERT_RANGE(mut, 0, NUM_MUTATIONS);</a>
<a name="ln213">        ASSERT(mut_index[mut] == -1);</a>
<a name="ln214">        mut_index[mut] = i;</a>
<a name="ln215">        for (const auto flag : mutflags::range())</a>
<a name="ln216">        {</a>
<a name="ln217">            if (_mut_has_use(mut_data[i], flag))</a>
<a name="ln218">                total_weight[flag] += _mut_weight(mut_data[i], flag);</a>
<a name="ln219">        }</a>
<a name="ln220">    }</a>
<a name="ln221"> </a>
<a name="ln222">    // this is all a bit silly but ok</a>
<a name="ln223">    for (int i = 0; i &lt; MUT_NON_MUTATION - CATEGORY_MUTATIONS; ++i)</a>
<a name="ln224">        category_mut_index[i] = -1;</a>
<a name="ln225"> </a>
<a name="ln226">    for (unsigned int i = 0; i &lt; ARRAYSZ(category_mut_data); ++i)</a>
<a name="ln227">    {</a>
<a name="ln228">        const mutation_type mut = category_mut_data[i].mutation;</a>
<a name="ln229">        ASSERT_RANGE(mut, CATEGORY_MUTATIONS, MUT_NON_MUTATION);</a>
<a name="ln230">        ASSERT(category_mut_index[mut-CATEGORY_MUTATIONS] == -1);</a>
<a name="ln231">        category_mut_index[mut-CATEGORY_MUTATIONS] = i;</a>
<a name="ln232">    }</a>
<a name="ln233">}</a>
<a name="ln234"> </a>
<a name="ln235">static const mutation_def&amp; _get_mutation_def(mutation_type mut)</a>
<a name="ln236">{</a>
<a name="ln237">    ASSERT_RANGE(mut, 0, NUM_MUTATIONS);</a>
<a name="ln238">    ASSERT(mut_index[mut] != -1);</a>
<a name="ln239">    return mut_data[mut_index[mut]];</a>
<a name="ln240">}</a>
<a name="ln241"> </a>
<a name="ln242">/*</a>
<a name="ln243"> * Get the max number of possible levels for mutation `mut`. This is typically 1 or 3.</a>
<a name="ln244"> *</a>
<a name="ln245"> * @return the mutation cap.</a>
<a name="ln246"> */</a>
<a name="ln247">int get_mutation_cap(mutation_type mut)</a>
<a name="ln248">{</a>
<a name="ln249">    return _get_mutation_def(mut).levels;</a>
<a name="ln250">}</a>
<a name="ln251"> </a>
<a name="ln252">static const mutation_category_def&amp; _get_category_mutation_def(mutation_type mut)</a>
<a name="ln253">{</a>
<a name="ln254">    ASSERT_RANGE(mut, CATEGORY_MUTATIONS, MUT_NON_MUTATION);</a>
<a name="ln255">    ASSERT(category_mut_index[mut-CATEGORY_MUTATIONS] != -1);</a>
<a name="ln256">    return category_mut_data[category_mut_index[mut-CATEGORY_MUTATIONS]];</a>
<a name="ln257">}</a>
<a name="ln258"> </a>
<a name="ln259">static bool _is_valid_mutation(mutation_type mut)</a>
<a name="ln260">{</a>
<a name="ln261">    return mut &gt;= 0 &amp;&amp; mut &lt; NUM_MUTATIONS &amp;&amp; mut_index[mut] != -1;</a>
<a name="ln262">}</a>
<a name="ln263"> </a>
<a name="ln264">static const mutation_type _all_scales[] =</a>
<a name="ln265">{</a>
<a name="ln266">    MUT_DISTORTION_FIELD,           MUT_ICY_BLUE_SCALES,</a>
<a name="ln267">    MUT_IRIDESCENT_SCALES,          MUT_LARGE_BONE_PLATES,</a>
<a name="ln268">    MUT_MOLTEN_SCALES,</a>
<a name="ln269">#if TAG_MAJOR_VERSION == 34</a>
<a name="ln270">    MUT_ROUGH_BLACK_SCALES,</a>
<a name="ln271">#endif</a>
<a name="ln272">    MUT_RUGGED_BROWN_SCALES,        MUT_SLIMY_GREEN_SCALES,</a>
<a name="ln273">    MUT_THIN_METALLIC_SCALES,       MUT_THIN_SKELETAL_STRUCTURE,</a>
<a name="ln274">    MUT_YELLOW_SCALES,              MUT_STURDY_FRAME,</a>
<a name="ln275">    MUT_SANGUINE_ARMOUR,</a>
<a name="ln276">};</a>
<a name="ln277"> </a>
<a name="ln278">static bool _is_covering(mutation_type mut)</a>
<a name="ln279">{</a>
<a name="ln280">    return find(begin(_all_scales), end(_all_scales), mut) != end(_all_scales);</a>
<a name="ln281">}</a>
<a name="ln282"> </a>
<a name="ln283">bool is_body_facet(mutation_type mut)</a>
<a name="ln284">{</a>
<a name="ln285">    return any_of(begin(_body_facets), end(_body_facets),</a>
<a name="ln286">                  [=](const body_facet_def &amp;facet)</a>
<a name="ln287">                  { return facet.mut == mut; });</a>
<a name="ln288">}</a>
<a name="ln289"> </a>
<a name="ln290">/*</a>
<a name="ln291"> * The degree to which `mut` is suppressed by the current form.</a>
<a name="ln292"> *</a>
<a name="ln293"> * @param mut  the mutation to check.</a>
<a name="ln294"> *</a>
<a name="ln295"> * @return  mutation_activity_type::FULL: completely available.</a>
<a name="ln296"> *          mutation_activity_type::PARTIAL: partially suppressed.</a>
<a name="ln297"> *          mutation_activity_type::INACTIVE: completely suppressed.</a>
<a name="ln298"> */</a>
<a name="ln299">mutation_activity_type mutation_activity_level(mutation_type mut)</a>
<a name="ln300">{</a>
<a name="ln301">    // First make sure the player's form permits the mutation.</a>
<a name="ln302">    if (!form_keeps_mutations())</a>
<a name="ln303">    {</a>
<a name="ln304">        if (you.form == transformation::dragon)</a>
<a name="ln305">        {</a>
<a name="ln306">            monster_type drag = dragon_form_dragon_type();</a>
<a name="ln307">            if (mut == MUT_SHOCK_RESISTANCE &amp;&amp; drag == MONS_STORM_DRAGON)</a>
<a name="ln308">                return mutation_activity_type::FULL;</a>
<a name="ln309">            if (mut == MUT_UNBREATHING &amp;&amp; drag == MONS_IRON_DRAGON)</a>
<a name="ln310">                return mutation_activity_type::FULL;</a>
<a name="ln311">            if ((mut == MUT_ACIDIC_BITE || mut == MUT_ACID_RESISTANCE)</a>
<a name="ln312">                &amp;&amp; drag == MONS_GOLDEN_DRAGON)</a>
<a name="ln313">            {</a>
<a name="ln314">                return mutation_activity_type::FULL;</a>
<a name="ln315">            }</a>
<a name="ln316">            if (mut == MUT_STINGER &amp;&amp; drag == MONS_SWAMP_DRAGON)</a>
<a name="ln317">                return mutation_activity_type::FULL;</a>
<a name="ln318">        }</a>
<a name="ln319">        // Vampire bats keep their fangs.</a>
<a name="ln320">        if (you.form == transformation::bat</a>
<a name="ln321">            &amp;&amp; you.species == SP_VAMPIRE</a>
<a name="ln322">            &amp;&amp; mut == MUT_FANGS)</a>
<a name="ln323">        {</a>
<a name="ln324">            return mutation_activity_type::FULL;</a>
<a name="ln325">        }</a>
<a name="ln326">        // Dex and HP changes are kept in all forms.</a>
<a name="ln327">#if TAG_MAJOR_VERSION == 34</a>
<a name="ln328">        if (mut == MUT_ROUGH_BLACK_SCALES)</a>
<a name="ln329">            return mutation_activity_type::PARTIAL;</a>
<a name="ln330">#endif</a>
<a name="ln331">        if (mut == MUT_RUGGED_BROWN_SCALES)</a>
<a name="ln332">            return mutation_activity_type::PARTIAL;</a>
<a name="ln333">        else if (_get_mutation_def(mut).form_based)</a>
<a name="ln334">            return mutation_activity_type::INACTIVE;</a>
<a name="ln335">    }</a>
<a name="ln336"> </a>
<a name="ln337">    if (you.form == transformation::statue)</a>
<a name="ln338">    {</a>
<a name="ln339">        // Statues get all but the AC benefit from scales, but are not affected</a>
<a name="ln340">        // by other changes in body material or speed.</a>
<a name="ln341">        switch (mut)</a>
<a name="ln342">        {</a>
<a name="ln343">        case MUT_GELATINOUS_BODY:</a>
<a name="ln344">        case MUT_TOUGH_SKIN:</a>
<a name="ln345">        case MUT_SHAGGY_FUR:</a>
<a name="ln346">        case MUT_FAST:</a>
<a name="ln347">        case MUT_SLOW:</a>
<a name="ln348">        case MUT_IRIDESCENT_SCALES:</a>
<a name="ln349">            return mutation_activity_type::INACTIVE;</a>
<a name="ln350">#if TAG_MAJOR_VERSION == 34</a>
<a name="ln351">        case MUT_ROUGH_BLACK_SCALES:</a>
<a name="ln352">#endif</a>
<a name="ln353">        case MUT_RUGGED_BROWN_SCALES:</a>
<a name="ln354">            return mutation_activity_type::PARTIAL;</a>
<a name="ln355">        case MUT_YELLOW_SCALES:</a>
<a name="ln356">        case MUT_ICY_BLUE_SCALES:</a>
<a name="ln357">        case MUT_MOLTEN_SCALES:</a>
<a name="ln358">        case MUT_SLIMY_GREEN_SCALES:</a>
<a name="ln359">        case MUT_THIN_METALLIC_SCALES:</a>
<a name="ln360">            return you.get_base_mutation_level(mut) &gt; 2 ? mutation_activity_type::PARTIAL :</a>
<a name="ln361">                                                          mutation_activity_type::INACTIVE;</a>
<a name="ln362">        default:</a>
<a name="ln363">            break;</a>
<a name="ln364">        }</a>
<a name="ln365">    }</a>
<a name="ln366"> </a>
<a name="ln367">    //XXX: Should this make claws inactive too?</a>
<a name="ln368">    if (you.form == transformation::blade_hands &amp;&amp; mut == MUT_PAWS)</a>
<a name="ln369">        return mutation_activity_type::INACTIVE;</a>
<a name="ln370"> </a>
<a name="ln371">    if (you.form == transformation::tree</a>
<a name="ln372">        &amp;&amp; (mut == MUT_BLINK || mut == MUT_TELEPORT))</a>
<a name="ln373">    {</a>
<a name="ln374">        return mutation_activity_type::INACTIVE;</a>
<a name="ln375">    }</a>
<a name="ln376">#if TAG_MAJOR_VERSION == 34</a>
<a name="ln377">    if ((you_worship(GOD_PAKELLAS) || player_under_penance(GOD_PAKELLAS))</a>
<a name="ln378">         &amp;&amp; (mut == MUT_MANA_LINK || mut == MUT_MANA_REGENERATION))</a>
<a name="ln379">    {</a>
<a name="ln380">        return mutation_activity_type::INACTIVE;</a>
<a name="ln381">    }</a>
<a name="ln382">#endif</a>
<a name="ln383"> </a>
<a name="ln384">    if (mut == MUT_BERSERK &amp;&amp; you.species == SP_VAMPIRE &amp;&amp; !you.vampire_alive)</a>
<a name="ln385">        return mutation_activity_type::INACTIVE;</a>
<a name="ln386"> </a>
<a name="ln387">    if (!form_can_bleed(you.form) &amp;&amp; mut == MUT_SANGUINE_ARMOUR)</a>
<a name="ln388">        return mutation_activity_type::INACTIVE;</a>
<a name="ln389"> </a>
<a name="ln390">    if (mut == MUT_DEMONIC_GUARDIAN &amp;&amp; you.get_mutation_level(MUT_NO_LOVE))</a>
<a name="ln391">        return mutation_activity_type::INACTIVE;</a>
<a name="ln392"> </a>
<a name="ln393">    return mutation_activity_type::FULL;</a>
<a name="ln394">}</a>
<a name="ln395"> </a>
<a name="ln396">// Counts of various statuses/types of mutations from the current/most</a>
<a name="ln397">// recent call to describe_mutations. TODO: eliminate</a>
<a name="ln398">static int _num_full_suppressed = 0;</a>
<a name="ln399">static int _num_part_suppressed = 0;</a>
<a name="ln400">static int _num_transient = 0;</a>
<a name="ln401"> </a>
<a name="ln402">static string _annotate_form_based(string desc, bool suppressed)</a>
<a name="ln403">{</a>
<a name="ln404">    if (suppressed)</a>
<a name="ln405">    {</a>
<a name="ln406">        desc = &quot;&lt;darkgrey&gt;((&quot; + desc + &quot;))&lt;/darkgrey&gt;&quot;;</a>
<a name="ln407">        ++_num_full_suppressed;</a>
<a name="ln408">    }</a>
<a name="ln409"> </a>
<a name="ln410">    return desc + &quot;\n&quot;;</a>
<a name="ln411">}</a>
<a name="ln412"> </a>
<a name="ln413">static string _dragon_abil(string desc)</a>
<a name="ln414">{</a>
<a name="ln415">    const bool supp = form_changed_physiology() &amp;&amp; you.form != transformation::dragon;</a>
<a name="ln416">    return _annotate_form_based(desc, supp);</a>
<a name="ln417">}</a>
<a name="ln418"> </a>
<a name="ln419">/*</a>
<a name="ln420"> * Does the player have mutation `mut` with at least one temporary level?</a>
<a name="ln421"> *</a>
<a name="ln422"> * Reminder: temporary mutations can coexist with innate or normal mutations.</a>
<a name="ln423"> */</a>
<a name="ln424">bool player::has_temporary_mutation(mutation_type mut) const</a>
<a name="ln425">{</a>
<a name="ln426">    return you.temp_mutation[mut] &gt; 0;</a>
<a name="ln427">}</a>
<a name="ln428"> </a>
<a name="ln429">/*</a>
<a name="ln430"> * Does the player have mutation `mut` with at least one innate level?</a>
<a name="ln431"> *</a>
<a name="ln432"> * Reminder: innate mutations can coexist with temporary or normal mutations.</a>
<a name="ln433"> */</a>
<a name="ln434">bool player::has_innate_mutation(mutation_type mut) const</a>
<a name="ln435">{</a>
<a name="ln436">    return you.innate_mutation[mut] &gt; 0;</a>
<a name="ln437">}</a>
<a name="ln438"> </a>
<a name="ln439">/*</a>
<a name="ln440"> * How much of mutation `mut` does the player have? This ignores form changes.</a>
<a name="ln441"> * If all three bool arguments are false, this should always return 0.</a>
<a name="ln442"> *</a>
<a name="ln443"> * @param temp   include temporary mutation levels. defaults to true.</a>
<a name="ln444"> * @param innate include innate mutation levels. defaults to true.</a>
<a name="ln445"> * @param normal include normal (non-temp, non-innate) mutation levels. defaults to true.</a>
<a name="ln446"> *</a>
<a name="ln447"> * @return the total levels of the mutation.</a>
<a name="ln448"> */</a>
<a name="ln449">int player::get_base_mutation_level(mutation_type mut, bool innate, bool temp, bool normal) const</a>
<a name="ln450">{</a>
<a name="ln451">    ASSERT_RANGE(mut, 0, NUM_MUTATIONS);</a>
<a name="ln452">    // you.mutation stores the total levels of all mutations</a>
<a name="ln453">    int level = you.mutation[mut];</a>
<a name="ln454">    if (!temp)</a>
<a name="ln455">        level -= you.temp_mutation[mut];</a>
<a name="ln456">    if (!innate)</a>
<a name="ln457">        level -= you.innate_mutation[mut];</a>
<a name="ln458">    if (!normal)</a>
<a name="ln459">        level -= (you.mutation[mut] - (you.temp_mutation[mut] + you.innate_mutation[mut]));</a>
<a name="ln460">    ASSERT(level &gt;= 0);</a>
<a name="ln461">    return level;</a>
<a name="ln462">}</a>
<a name="ln463"> </a>
<a name="ln464">/*</a>
<a name="ln465"> * How much of mutation `mut` does the player have innately?</a>
<a name="ln466"> *</a>
<a name="ln467"> */</a>
<a name="ln468">int player::get_innate_mutation_level(mutation_type mut) const</a>
<a name="ln469">{</a>
<a name="ln470">    ASSERT_RANGE(mut, 0, NUM_MUTATIONS);</a>
<a name="ln471">    return you.innate_mutation[mut];</a>
<a name="ln472">}</a>
<a name="ln473"> </a>
<a name="ln474">/*</a>
<a name="ln475"> * How much of mutation `mut` does the player have temporarily?</a>
<a name="ln476"> *</a>
<a name="ln477"> */</a>
<a name="ln478">int player::get_temp_mutation_level(mutation_type mut) const</a>
<a name="ln479">{</a>
<a name="ln480">    ASSERT_RANGE(mut, 0, NUM_MUTATIONS);</a>
<a name="ln481">    return you.temp_mutation[mut];</a>
<a name="ln482">}</a>
<a name="ln483"> </a>
<a name="ln484">/*</a>
<a name="ln485"> * Get the current player mutation level for `mut`, possibly incorporating information about forms.</a>
<a name="ln486"> * See the other version of this function for the canonical usage of `minact`; some forms such as scale mutations</a>
<a name="ln487"> * have different thresholds depending on the purpose and form and so will call this directly (e.g. ac</a>
<a name="ln488"> * but not resistances are suppressed in statueform.)</a>
<a name="ln489"> *</a>
<a name="ln490"> * @param mut           the mutation to check</a>
<a name="ln491"> * @param minact        the minimum activity level needed for the mutation to count as non-suppressed.</a>
<a name="ln492"> *</a>
<a name="ln493"> * @return a mutation level, 0 if the mutation doesn't exist or is suppressed.</a>
<a name="ln494"> */</a>
<a name="ln495">int player::get_mutation_level(mutation_type mut, mutation_activity_type minact) const</a>
<a name="ln496">{</a>
<a name="ln497">    ASSERT_RANGE(mut, 0, NUM_MUTATIONS);</a>
<a name="ln498">    if (mutation_activity_level(mut) &lt; minact)</a>
<a name="ln499">        return 0;</a>
<a name="ln500">    return get_base_mutation_level(mut, true, true);</a>
<a name="ln501">}</a>
<a name="ln502"> </a>
<a name="ln503">/*</a>
<a name="ln504"> * Get the current player mutation level for `mut`, possibly incorporating information about forms.</a>
<a name="ln505"> *</a>
<a name="ln506"> * @param mut           the mutation to check</a>
<a name="ln507"> * @param check_form    whether to incorporate suppression from forms. Defaults to true.</a>
<a name="ln508"> *</a>
<a name="ln509"> * @return a mutation level, 0 if the mutation doesn't exist or is suppressed.</a>
<a name="ln510"> */</a>
<a name="ln511">int player::get_mutation_level(mutation_type mut, bool check_form) const</a>
<a name="ln512">{</a>
<a name="ln513">    return get_mutation_level(mut, check_form ? mutation_activity_type::PARTIAL :</a>
<a name="ln514">                                                            mutation_activity_type::INACTIVE);</a>
<a name="ln515">}</a>
<a name="ln516"> </a>
<a name="ln517">/*</a>
<a name="ln518"> * Does the player have mutation `mut` in some form?</a>
<a name="ln519"> */</a>
<a name="ln520">bool player::has_mutation(mutation_type mut, bool check_form) const</a>
<a name="ln521">{</a>
<a name="ln522">    return get_mutation_level(mut, check_form) &gt; 0;</a>
<a name="ln523">}</a>
<a name="ln524"> </a>
<a name="ln525">/*</a>
<a name="ln526"> * Test the validity of the player mutation structures, using ASSERTs.</a>
<a name="ln527"> * Will crash on a failure.</a>
<a name="ln528"> *</a>
<a name="ln529"> * @debug_msg whether to output diagnostic `dprf`s in the process.</a>
<a name="ln530"> */</a>
<a name="ln531">void validate_mutations(bool debug_msg)</a>
<a name="ln532">{</a>
<a name="ln533">    if (debug_msg)</a>
<a name="ln534">        dprf(&quot;Validating player mutations&quot;);</a>
<a name="ln535">    int total_temp = 0;</a>
<a name="ln536"> </a>
<a name="ln537">    for (int i = 0; i &lt; NUM_MUTATIONS; i++)</a>
<a name="ln538">    {</a>
<a name="ln539">        mutation_type mut = static_cast&lt;mutation_type&gt;(i);</a>
<a name="ln540">        if (debug_msg &amp;&amp; you.mutation[mut] &gt; 0)</a>
<a name="ln541">        {</a>
<a name="ln542">            dprf(&quot;mutation %s: total %d innate %d temp %d&quot;,</a>
<a name="ln543">                mutation_name(mut), you.mutation[mut],</a>
<a name="ln544">                you.innate_mutation[mut], you.temp_mutation[mut]);</a>
<a name="ln545">        }</a>
<a name="ln546">        ASSERT(you.get_base_mutation_level(mut) == you.mutation[mut]);</a>
<a name="ln547">        ASSERT(you.mutation[i] &gt;= you.innate_mutation[mut] + you.temp_mutation[mut]);</a>
<a name="ln548">        total_temp += you.temp_mutation[mut];</a>
<a name="ln549"> </a>
<a name="ln550">        const mutation_def&amp; mdef = _get_mutation_def(mut);</a>
<a name="ln551">        ASSERT(you.mutation[mut] &lt;= mdef.levels);</a>
<a name="ln552"> </a>
<a name="ln553">        // reconstruct what the innate mutations should be based on Ds mutation schedule</a>
<a name="ln554">        // TODO generalize to all innate muts</a>
<a name="ln555">        if (you.species == SP_DEMONSPAWN)</a>
<a name="ln556">        {</a>
<a name="ln557">            bool is_trait = false;</a>
<a name="ln558">            int trait_level = 0;</a>
<a name="ln559">            // If the player has sacrificed xp, use the pre-sac xl; sac xp</a>
<a name="ln560">            // doesn't remove Ds mutations.</a>
<a name="ln561">            // You can still trick wizmode into crashing here.</a>
<a name="ln562">            const int check_xl = (you.get_mutation_level(MUT_INEXPERIENCED)</a>
<a name="ln563">                            &amp;&amp; you.max_level &lt;= you.get_experience_level() + 2)</a>
<a name="ln564">                                ? you.max_level</a>
<a name="ln565">                                : you.get_experience_level();</a>
<a name="ln566">            for (player::demon_trait trait : you.demonic_traits)</a>
<a name="ln567">            {</a>
<a name="ln568">                if (trait.mutation == mut)</a>
<a name="ln569">                {</a>
<a name="ln570">                    is_trait = true;</a>
<a name="ln571">                    if (check_xl &gt;= trait.level_gained)</a>
<a name="ln572">                        trait_level += 1;</a>
<a name="ln573">                }</a>
<a name="ln574">            }</a>
<a name="ln575"> </a>
<a name="ln576">            if (debug_msg &amp;&amp; is_trait)</a>
<a name="ln577">            {</a>
<a name="ln578">                dprf(&quot;scheduled innate for %s: %d, actual %d&quot;, mutation_name(mut),</a>
<a name="ln579">                     trait_level, you.innate_mutation[mut]);</a>
<a name="ln580">            }</a>
<a name="ln581">            if (is_trait)</a>
<a name="ln582">                ASSERT(you.innate_mutation[mut] == trait_level);</a>
<a name="ln583">        }</a>
<a name="ln584">    }</a>
<a name="ln585">    ASSERT(total_temp == you.attribute[ATTR_TEMP_MUTATIONS]);</a>
<a name="ln586">}</a>
<a name="ln587"> </a>
<a name="ln588">string describe_mutations(bool drop_title)</a>
<a name="ln589">{</a>
<a name="ln590">#ifdef DEBUG</a>
<a name="ln591">    validate_mutations(true);</a>
<a name="ln592">#endif</a>
<a name="ln593">    string result;</a>
<a name="ln594"> </a>
<a name="ln595">    _num_full_suppressed = _num_part_suppressed = 0;</a>
<a name="ln596">    _num_transient = 0;</a>
<a name="ln597"> </a>
<a name="ln598">    if (!drop_title)</a>
<a name="ln599">    {</a>
<a name="ln600">        result += &quot;&lt;white&gt;&quot;;</a>
<a name="ln601">        result += &quot;Innate Abilities, Weirdness &amp; Mutations&quot;;</a>
<a name="ln602">        result += &quot;&lt;/white&gt;\n\n&quot;;</a>
<a name="ln603">    }</a>
<a name="ln604"> </a>
<a name="ln605">    result += &quot;&lt;lightblue&gt;&quot;;</a>
<a name="ln606">    const string old_result = result;</a>
<a name="ln607"> </a>
<a name="ln608">    // Innate abilities which haven't been implemented as mutations yet.</a>
<a name="ln609">    // TODO: clean these up with respect to transformations. Currently</a>
<a name="ln610">    // we handle only Naga/Draconian AC and Yellow Draconian rAcid.</a>
<a name="ln611">    for (const string&amp; str : fake_mutations(you.species, false))</a>
<a name="ln612">    {</a>
<a name="ln613">        if (species_is_draconian(you.species))</a>
<a name="ln614">            result += _dragon_abil(str);</a>
<a name="ln615">        else if (you.species == SP_MERFOLK)</a>
<a name="ln616">            result += _annotate_form_based(str, form_changed_physiology());</a>
<a name="ln617">        else if (you.species == SP_MINOTAUR)</a>
<a name="ln618">            result += _annotate_form_based(str, !form_keeps_mutations());</a>
<a name="ln619">        else</a>
<a name="ln620">            result += str + &quot;\n&quot;;</a>
<a name="ln621">    }</a>
<a name="ln622"> </a>
<a name="ln623">    if (you.racial_ac(false) &gt; 0)</a>
<a name="ln624">    {</a>
<a name="ln625">        const string scale_clause = string(scale_type(you.species))</a>
<a name="ln626">              + &quot; scales are &quot;</a>
<a name="ln627">              + (you.species == SP_GREY_DRACONIAN ? &quot;very &quot; : &quot;&quot;) + &quot;hard&quot;;</a>
<a name="ln628"> </a>
<a name="ln629">        result += _annotate_form_based(</a>
<a name="ln630">                    make_stringf(&quot;Your %s. (AC +%d)&quot;,</a>
<a name="ln631">                       you.species == SP_NAGA ? &quot;serpentine skin is tough&quot; :</a>
<a name="ln632">                       you.species == SP_GARGOYLE ? &quot;stone body is resilient&quot; :</a>
<a name="ln633">                                                    scale_clause.c_str(),</a>
<a name="ln634">                       you.racial_ac(false) / 100),</a>
<a name="ln635">                    player_is_shapechanged()</a>
<a name="ln636">                    &amp;&amp; !(species_is_draconian(you.species)</a>
<a name="ln637">                         &amp;&amp; you.form == transformation::dragon));</a>
<a name="ln638">    }</a>
<a name="ln639"> </a>
<a name="ln640">    if (you.species == SP_VAMPIRE)</a>
<a name="ln641">    {</a>
<a name="ln642">        if (!you.vampire_alive)</a>
<a name="ln643">        {</a>
<a name="ln644">            result += &quot;&lt;green&gt;You do not regenerate when monsters are visible.&lt;/green&gt;\n&quot;;</a>
<a name="ln645">            result += &quot;&lt;green&gt;You are frail without blood (-20% HP).&lt;/green&gt;\n&quot;;</a>
<a name="ln646">            result += &quot;&lt;green&gt;You can heal yourself when you bite living creatures.&lt;/green&gt;\n&quot;;</a>
<a name="ln647">        }</a>
<a name="ln648">        else</a>
<a name="ln649">            result += &quot;&lt;green&gt;Your natural rate of healing is unusually fast.&lt;/green&gt;\n&quot;;</a>
<a name="ln650">    }</a>
<a name="ln651"> </a>
<a name="ln652">    if (you.species == SP_OCTOPODE)</a>
<a name="ln653">    {</a>
<a name="ln654">        result += _annotate_form_based(&quot;You are amphibious.&quot;,</a>
<a name="ln655">                                       !form_likes_water());</a>
<a name="ln656"> </a>
<a name="ln657">        const string num_tentacles =</a>
<a name="ln658">               number_in_words(you.has_usable_tentacles(false));</a>
<a name="ln659">        result += _annotate_form_based(</a>
<a name="ln660">            make_stringf(&quot;You can wear up to %s rings at the same time.&quot;,</a>
<a name="ln661">                         num_tentacles.c_str()),</a>
<a name="ln662">            !get_form()-&gt;slot_available(EQ_RING_EIGHT));</a>
<a name="ln663">        result += _annotate_form_based(</a>
<a name="ln664">            make_stringf(&quot;You can use your tentacles to constrict %s enemies at once.&quot;,</a>
<a name="ln665">                         num_tentacles.c_str()),</a>
<a name="ln666">            !form_keeps_mutations());</a>
<a name="ln667">    }</a>
<a name="ln668"> </a>
<a name="ln669">    if (you.species != SP_FELID)</a>
<a name="ln670">    {</a>
<a name="ln671">        switch (you.body_size(PSIZE_TORSO, true))</a>
<a name="ln672">        {</a>
<a name="ln673">        case SIZE_LITTLE:</a>
<a name="ln674">            result += &quot;You are very small and have problems with some larger weapons.\n&quot;</a>
<a name="ln675">                      &quot;You are too small for most types of armour.\n&quot;;</a>
<a name="ln676">            break;</a>
<a name="ln677">        case SIZE_SMALL:</a>
<a name="ln678">            result += &quot;You are small and have problems with some larger weapons.\n&quot;;</a>
<a name="ln679">            break;</a>
<a name="ln680">        case SIZE_LARGE:</a>
<a name="ln681">            result += &quot;You are too large for most types of armour.\n&quot;;</a>
<a name="ln682">            break;</a>
<a name="ln683">        default:</a>
<a name="ln684">            break;</a>
<a name="ln685">        }</a>
<a name="ln686">    }</a>
<a name="ln687"> </a>
<a name="ln688">    // Could move this into species-data, but then the hack that assumes</a>
<a name="ln689">    // _dragon_abil should get called on all draconian fake muts would break.</a>
<a name="ln690">    if (species_is_draconian(you.species))</a>
<a name="ln691">        result += &quot;You cannot fit into any form of body armour.\n&quot;;</a>
<a name="ln692"> </a>
<a name="ln693">    if (player_res_poison(false, false, false) == 3)</a>
<a name="ln694">        result += &quot;You are immune to poison.\n&quot;;</a>
<a name="ln695"> </a>
<a name="ln696">    result += &quot;&lt;/lightblue&gt;&quot;;</a>
<a name="ln697"> </a>
<a name="ln698">    // First add (non-removable) inborn abilities and demon powers.</a>
<a name="ln699">    for (int i = 0; i &lt; NUM_MUTATIONS; i++)</a>
<a name="ln700">    {</a>
<a name="ln701">        mutation_type mut_type = static_cast&lt;mutation_type&gt;(i);</a>
<a name="ln702">        if (you.has_innate_mutation(mut_type))</a>
<a name="ln703">        {</a>
<a name="ln704">            result += mutation_desc(mut_type, -1, true,</a>
<a name="ln705">                ((you.sacrifices[i] != 0) ? true : false));</a>
<a name="ln706">            result += &quot;\n&quot;;</a>
<a name="ln707">        }</a>
<a name="ln708">    }</a>
<a name="ln709"> </a>
<a name="ln710">    if (have_passive(passive_t::water_walk))</a>
<a name="ln711">        result += &quot;&lt;green&gt;You can walk on water.&lt;/green&gt;\n&quot;;</a>
<a name="ln712">    else if (you.can_water_walk())</a>
<a name="ln713">    {</a>
<a name="ln714">        result += &quot;&lt;lightgreen&gt;You can walk on water until reaching land.&quot;</a>
<a name="ln715">                  &quot;&lt;/lightgreen&gt;&quot;;</a>
<a name="ln716">    }</a>
<a name="ln717"> </a>
<a name="ln718">    if (have_passive(passive_t::frail)</a>
<a name="ln719">        || player_under_penance(GOD_HEPLIAKLQANA))</a>
<a name="ln720">    {</a>
<a name="ln721">        result += &quot;&lt;lightred&gt;Your life essence is reduced to manifest your ancestor. (-10% HP)&quot;</a>
<a name="ln722">                  &quot;&lt;/lightred&gt;\n&quot;;</a>
<a name="ln723">    }</a>
<a name="ln724"> </a>
<a name="ln725">    // Now add removable mutations.</a>
<a name="ln726">    for (int i = 0; i &lt; NUM_MUTATIONS; i++)</a>
<a name="ln727">    {</a>
<a name="ln728">        mutation_type mut_type = static_cast&lt;mutation_type&gt;(i);</a>
<a name="ln729">        if (you.get_base_mutation_level(mut_type, false, false, true) &gt; 0</a>
<a name="ln730">            &amp;&amp; !you.has_innate_mutation(mut_type) &amp;&amp; !you.has_temporary_mutation(mut_type))</a>
<a name="ln731">        {</a>
<a name="ln732">            result += mutation_desc(mut_type, -1, true);</a>
<a name="ln733">            result += &quot;\n&quot;;</a>
<a name="ln734">        }</a>
<a name="ln735">    }</a>
<a name="ln736"> </a>
<a name="ln737">    //Finally, temporary mutations.</a>
<a name="ln738">    for (int i = 0; i &lt; NUM_MUTATIONS; i++)</a>
<a name="ln739">    {</a>
<a name="ln740">        mutation_type mut_type = static_cast&lt;mutation_type&gt;(i);</a>
<a name="ln741">        if (you.has_temporary_mutation(mut_type))</a>
<a name="ln742">        {</a>
<a name="ln743">            result += mutation_desc(mut_type, -1, true);</a>
<a name="ln744">            result += &quot;\n&quot;;</a>
<a name="ln745">        }</a>
<a name="ln746">    }</a>
<a name="ln747"> </a>
<a name="ln748">    if (result == old_result + &quot;&lt;/lightblue&gt;&quot;) // Nothing was added</a>
<a name="ln749">        result += &quot;You are rather mundane.\n&quot;;</a>
<a name="ln750"> </a>
<a name="ln751">    return result;</a>
<a name="ln752">}</a>
<a name="ln753"> </a>
<a name="ln754">static formatted_string _vampire_Ascreen_footer(bool first_page)</a>
<a name="ln755">{</a>
<a name="ln756">    const char *text = first_page ? &quot;&lt;w&gt;Mutations&lt;/w&gt;|Blood properties&quot;</a>
<a name="ln757">                                  : &quot;Mutations|&lt;w&gt;Blood properties&lt;/w&gt;&quot;;</a>
<a name="ln758">    const string fmt = make_stringf(&quot;[&lt;w&gt;!&lt;/w&gt;/&lt;w&gt;^&lt;/w&gt;&quot;</a>
<a name="ln759">#ifdef USE_TILE_LOCAL</a>
<a name="ln760">            &quot;|&lt;w&gt;Right-click&lt;/w&gt;&quot;</a>
<a name="ln761">#endif</a>
<a name="ln762">            &quot;]: %s&quot;, text);</a>
<a name="ln763">    return formatted_string::parse_string(fmt);</a>
<a name="ln764">}</a>
<a name="ln765"> </a>
<a name="ln766">static int _vampire_bloodlessness()</a>
<a name="ln767">{</a>
<a name="ln768">    return you.vampire_alive ? 1 : 2;</a>
<a name="ln769">}</a>
<a name="ln770"> </a>
<a name="ln771">static string _display_vampire_attributes()</a>
<a name="ln772">{</a>
<a name="ln773">    ASSERT(you.species == SP_VAMPIRE);</a>
<a name="ln774"> </a>
<a name="ln775">    string result;</a>
<a name="ln776"> </a>
<a name="ln777">    const int lines = 12;</a>
<a name="ln778">    string column[lines][3] =</a>
<a name="ln779">    {</a>
<a name="ln780">        {&quot;                     &quot;, &quot;&lt;green&gt;Alive&lt;/green&gt;      &quot;, &quot;&lt;lightred&gt;Bloodless&lt;/lightred&gt;&quot;},</a>
<a name="ln781">                                 //Full       Bloodless</a>
<a name="ln782">        {&quot;Regeneration         &quot;, &quot;fast       &quot;, &quot;none with monsters in sight&quot;},</a>
<a name="ln783"> </a>
<a name="ln784">        {&quot;HP modifier          &quot;, &quot;none       &quot;, &quot;-20%&quot;},</a>
<a name="ln785"> </a>
<a name="ln786">        {&quot;Stealth boost        &quot;, &quot;none       &quot;, &quot;major &quot;},</a>
<a name="ln787"> </a>
<a name="ln788">        {&quot;Heal on bite         &quot;, &quot;no         &quot;, &quot;yes &quot;},</a>
<a name="ln789"> </a>
<a name="ln790">        {&quot;\n&lt;w&gt;Resistances&lt;/w&gt;\n&quot;</a>
<a name="ln791">         &quot;Poison resistance    &quot;, &quot;           &quot;, &quot;immune&quot;},</a>
<a name="ln792"> </a>
<a name="ln793">        {&quot;Cold resistance      &quot;, &quot;           &quot;, &quot;++    &quot;},</a>
<a name="ln794"> </a>
<a name="ln795">        {&quot;Negative resistance  &quot;, &quot;           &quot;, &quot;+++   &quot;},</a>
<a name="ln796"> </a>
<a name="ln797">        {&quot;Rotting resistance   &quot;, &quot;           &quot;, &quot;+     &quot;},</a>
<a name="ln798"> </a>
<a name="ln799">        {&quot;Torment resistance   &quot;, &quot;           &quot;, &quot;+     &quot;},</a>
<a name="ln800"> </a>
<a name="ln801">        {&quot;\n&lt;w&gt;Transformations&lt;/w&gt;\n&quot;</a>
<a name="ln802">         &quot;Bat form             &quot;, &quot;no         &quot;, &quot;yes   &quot;},</a>
<a name="ln803"> </a>
<a name="ln804">        {&quot;Other forms and \n&quot;</a>
<a name="ln805">         &quot;berserk              &quot;, &quot;yes        &quot;, &quot;no    &quot;}</a>
<a name="ln806">    };</a>
<a name="ln807"> </a>
<a name="ln808">    int current = _vampire_bloodlessness();</a>
<a name="ln809"> </a>
<a name="ln810">    for (int y = 0; y &lt; lines; y++)  // lines   (properties)</a>
<a name="ln811">    {</a>
<a name="ln812">        for (int x = 0; x &lt; 3; x++)  // columns (hunger states)</a>
<a name="ln813">        {</a>
<a name="ln814">            if (y &gt; 0 &amp;&amp; x == current)</a>
<a name="ln815">                result += &quot;&lt;w&gt;&quot;;</a>
<a name="ln816">            result += column[y][x];</a>
<a name="ln817">            if (y &gt; 0 &amp;&amp; x == current)</a>
<a name="ln818">                result += &quot;&lt;/w&gt;&quot;;</a>
<a name="ln819">        }</a>
<a name="ln820">        result += &quot;\n&quot;;</a>
<a name="ln821">    }</a>
<a name="ln822"> </a>
<a name="ln823">    trim_string_right(result);</a>
<a name="ln824">    return result;</a>
<a name="ln825">}</a>
<a name="ln826"> </a>
<a name="ln827">void display_mutations()</a>
<a name="ln828">{</a>
<a name="ln829">    string mutation_s = describe_mutations(true);</a>
<a name="ln830"> </a>
<a name="ln831">    string extra = &quot;&quot;;</a>
<a name="ln832">    if (_num_part_suppressed)</a>
<a name="ln833">        extra += &quot;&lt;brown&gt;()&lt;/brown&gt;  : Partially suppressed.\n&quot;;</a>
<a name="ln834">    if (_num_full_suppressed)</a>
<a name="ln835">        extra += &quot;&lt;darkgrey&gt;(())&lt;/darkgrey&gt;: Completely suppressed.\n&quot;;</a>
<a name="ln836">    if (_num_transient)</a>
<a name="ln837">        extra += &quot;&lt;magenta&gt;[]&lt;/magenta&gt;   : Transient mutations.&quot;;</a>
<a name="ln838"> </a>
<a name="ln839">    if (!extra.empty())</a>
<a name="ln840">    {</a>
<a name="ln841">        mutation_s += &quot;\n\n\n\n&quot;;</a>
<a name="ln842">        mutation_s += extra;</a>
<a name="ln843">    }</a>
<a name="ln844">    trim_string_right(mutation_s);</a>
<a name="ln845"> </a>
<a name="ln846">    auto vbox = make_shared&lt;Box&gt;(Widget::VERT);</a>
<a name="ln847">    vbox-&gt;set_cross_alignment(Widget::STRETCH);</a>
<a name="ln848"> </a>
<a name="ln849">    const char *title_text = &quot;Innate Abilities, Weirdness &amp; Mutations&quot;;</a>
<a name="ln850">    auto title = make_shared&lt;Text&gt;(formatted_string(title_text, WHITE));</a>
<a name="ln851">    auto title_hbox = make_shared&lt;Box&gt;(Widget::HORZ);</a>
<a name="ln852">    title_hbox-&gt;add_child(move(title));</a>
<a name="ln853">    title_hbox-&gt;set_main_alignment(Widget::CENTER);</a>
<a name="ln854">    vbox-&gt;add_child(move(title_hbox));</a>
<a name="ln855"> </a>
<a name="ln856">    auto switcher = make_shared&lt;Switcher&gt;();</a>
<a name="ln857"> </a>
<a name="ln858">    const string vamp_s = you.species == SP_VAMPIRE ?_display_vampire_attributes() : &quot;N/A&quot;;</a>
<a name="ln859">    const string descs[3] =  { mutation_s, vamp_s };</a>
<a name="ln860">    for (int i = 0; i &lt; 2; i++)</a>
<a name="ln861">    {</a>
<a name="ln862">        auto scroller = make_shared&lt;Scroller&gt;();</a>
<a name="ln863">        auto text = make_shared&lt;Text&gt;(formatted_string::parse_string(</a>
<a name="ln864">                descs[static_cast&lt;int&gt;(i)]));</a>
<a name="ln865">        text-&gt;set_wrap_text(true);</a>
<a name="ln866">        scroller-&gt;set_child(text);</a>
<a name="ln867">        switcher-&gt;add_child(move(scroller));</a>
<a name="ln868">    }</a>
<a name="ln869"> </a>
<a name="ln870">    switcher-&gt;current() = 0;</a>
<a name="ln871">    switcher-&gt;set_margin_for_sdl(20, 0, 0, 0);</a>
<a name="ln872">    switcher-&gt;set_margin_for_crt(1, 0, 0, 0);</a>
<a name="ln873">    switcher-&gt;expand_h = false;</a>
<a name="ln874">    switcher-&gt;align_x = Widget::STRETCH;</a>
<a name="ln875">#ifdef USE_TILE_LOCAL</a>
<a name="ln876">    switcher-&gt;max_size().width = tiles.get_crt_font()-&gt;char_width()*80;</a>
<a name="ln877">#endif</a>
<a name="ln878">    vbox-&gt;add_child(switcher);</a>
<a name="ln879"> </a>
<a name="ln880">    auto bottom = make_shared&lt;Text&gt;(_vampire_Ascreen_footer(true));</a>
<a name="ln881">    bottom-&gt;set_margin_for_sdl(20, 0, 0, 0);</a>
<a name="ln882">    bottom-&gt;set_margin_for_crt(1, 0, 0, 0);</a>
<a name="ln883">    if (you.species == SP_VAMPIRE)</a>
<a name="ln884">        vbox-&gt;add_child(bottom);</a>
<a name="ln885"> </a>
<a name="ln886">    auto popup = make_shared&lt;ui::Popup&gt;(vbox);</a>
<a name="ln887"> </a>
<a name="ln888">    bool done = false;</a>
<a name="ln889">    int lastch;</a>
<a name="ln890">    popup-&gt;on_keydown_event([&amp;](const KeyEvent&amp; ev) {</a>
<a name="ln891">        lastch = ev.key();</a>
<a name="ln892">        if (you.species == SP_VAMPIRE &amp;&amp; (lastch == '!' || lastch == CK_MOUSE_CMD || lastch == '^'))</a>
<a name="ln893">        {</a>
<a name="ln894">            int&amp; c = switcher-&gt;current();</a>
<a name="ln895"> </a>
<a name="ln896">            bottom-&gt;set_text(_vampire_Ascreen_footer(c));</a>
<a name="ln897"> </a>
<a name="ln898">            c = 1 - c;</a>
<a name="ln899">#ifdef USE_TILE_WEB</a>
<a name="ln900">            tiles.json_open_object();</a>
<a name="ln901">            tiles.json_write_int(&quot;pane&quot;, c);</a>
<a name="ln902">            tiles.ui_state_change(&quot;mutations&quot;, 0);</a>
<a name="ln903">#endif</a>
<a name="ln904">        } else</a>
<a name="ln905">            done = !switcher-&gt;current_widget()-&gt;on_event(ev);</a>
<a name="ln906">        return true;</a>
<a name="ln907">    });</a>
<a name="ln908"> </a>
<a name="ln909">#ifdef USE_TILE_WEB</a>
<a name="ln910">    tiles.json_open_object();</a>
<a name="ln911">    tiles.json_write_string(&quot;mutations&quot;, mutation_s);</a>
<a name="ln912">    if (you.species == SP_VAMPIRE)</a>
<a name="ln913">        tiles.json_write_int(&quot;vampire&quot;, _vampire_bloodlessness());</a>
<a name="ln914">    tiles.push_ui_layout(&quot;mutations&quot;, 1);</a>
<a name="ln915">    popup-&gt;on_layout_pop([](){ tiles.pop_ui_layout(); });</a>
<a name="ln916">#endif</a>
<a name="ln917"> </a>
<a name="ln918">    ui::run_layout(move(popup), done);</a>
<a name="ln919">}</a>
<a name="ln920"> </a>
<a name="ln921">static int _calc_mutation_amusement_value(mutation_type which_mutation)</a>
<a name="ln922">{</a>
<a name="ln923">    int amusement = 12 * (11 - _get_mutation_def(which_mutation).weight);</a>
<a name="ln924"> </a>
<a name="ln925">    if (MUT_GOOD(mut_data[which_mutation]))</a>
<a name="ln926">        amusement /= 2;</a>
<a name="ln927">    else if (MUT_BAD(mut_data[which_mutation]))</a>
<a name="ln928">        amusement *= 2;</a>
<a name="ln929">    // currently is only ever one of these, but maybe that'll change?</a>
<a name="ln930"> </a>
<a name="ln931">    return amusement;</a>
<a name="ln932">}</a>
<a name="ln933"> </a>
<a name="ln934">static bool _accept_mutation(mutation_type mutat, bool ignore_weight = false)</a>
<a name="ln935">{</a>
<a name="ln936">    if (!_is_valid_mutation(mutat))</a>
<a name="ln937">        return false;</a>
<a name="ln938"> </a>
<a name="ln939">    if (physiology_mutation_conflict(mutat))</a>
<a name="ln940">        return false;</a>
<a name="ln941"> </a>
<a name="ln942">    const mutation_def&amp; mdef = _get_mutation_def(mutat);</a>
<a name="ln943"> </a>
<a name="ln944">    if (you.get_base_mutation_level(mutat) &gt;= mdef.levels)</a>
<a name="ln945">        return false;</a>
<a name="ln946"> </a>
<a name="ln947">    if (ignore_weight)</a>
<a name="ln948">        return true;</a>
<a name="ln949"> </a>
<a name="ln950">    // bias towards adding (non-innate) levels to existing innate mutations.</a>
<a name="ln951">    const int weight = mdef.weight + you.get_innate_mutation_level(mutat);</a>
<a name="ln952"> </a>
<a name="ln953">    // Low weight means unlikely to choose it.</a>
<a name="ln954">    return x_chance_in_y(weight, 10);</a>
<a name="ln955">}</a>
<a name="ln956"> </a>
<a name="ln957">static mutation_type _get_mut_with_use(mutflag mt)</a>
<a name="ln958">{</a>
<a name="ln959">    const int tweight = lookup(total_weight, mt, 0);</a>
<a name="ln960">    ASSERT(tweight);</a>
<a name="ln961"> </a>
<a name="ln962">    int cweight = random2(tweight);</a>
<a name="ln963">    for (const mutation_def &amp;mutdef : mut_data)</a>
<a name="ln964">    {</a>
<a name="ln965">        if (!_mut_has_use(mutdef, mt))</a>
<a name="ln966">            continue;</a>
<a name="ln967"> </a>
<a name="ln968">        cweight -= _mut_weight(mutdef, mt);</a>
<a name="ln969">        if (cweight &gt;= 0)</a>
<a name="ln970">            continue;</a>
<a name="ln971"> </a>
<a name="ln972">        return mutdef.mutation;</a>
<a name="ln973">    }</a>
<a name="ln974"> </a>
<a name="ln975">    die(&quot;Error while selecting mutations&quot;);</a>
<a name="ln976">}</a>
<a name="ln977"> </a>
<a name="ln978">static mutation_type _get_random_slime_mutation()</a>
<a name="ln979">{</a>
<a name="ln980">    return _get_mut_with_use(mutflag::jiyva);</a>
<a name="ln981">}</a>
<a name="ln982"> </a>
<a name="ln983">static mutation_type _delete_random_slime_mutation()</a>
<a name="ln984">{</a>
<a name="ln985">    mutation_type mutat;</a>
<a name="ln986"> </a>
<a name="ln987">    while (true)</a>
<a name="ln988">    {</a>
<a name="ln989">        mutat = _get_random_slime_mutation();</a>
<a name="ln990"> </a>
<a name="ln991">        if (you.get_base_mutation_level(mutat) &gt; 0)</a>
<a name="ln992">            break;</a>
<a name="ln993"> </a>
<a name="ln994">        if (one_chance_in(500))</a>
<a name="ln995">        {</a>
<a name="ln996">            mutat = NUM_MUTATIONS;</a>
<a name="ln997">            break;</a>
<a name="ln998">        }</a>
<a name="ln999">    }</a>
<a name="ln1000"> </a>
<a name="ln1001">    return mutat;</a>
<a name="ln1002">}</a>
<a name="ln1003"> </a>
<a name="ln1004">bool is_slime_mutation(mutation_type mut)</a>
<a name="ln1005">{</a>
<a name="ln1006">    return _mut_has_use(mut_data[mut_index[mut]], mutflag::jiyva);</a>
<a name="ln1007">}</a>
<a name="ln1008"> </a>
<a name="ln1009">static mutation_type _get_random_xom_mutation()</a>
<a name="ln1010">{</a>
<a name="ln1011">    mutation_type mutat = NUM_MUTATIONS;</a>
<a name="ln1012"> </a>
<a name="ln1013">    do</a>
<a name="ln1014">    {</a>
<a name="ln1015">        mutat = static_cast&lt;mutation_type&gt;(random2(NUM_MUTATIONS));</a>
<a name="ln1016"> </a>
<a name="ln1017">        if (one_chance_in(1000))</a>
<a name="ln1018">            return NUM_MUTATIONS;</a>
<a name="ln1019">        else if (one_chance_in(5))</a>
<a name="ln1020">            mutat = _get_mut_with_use(mutflag::xom);</a>
<a name="ln1021">    }</a>
<a name="ln1022">    while (!_accept_mutation(mutat, false));</a>
<a name="ln1023"> </a>
<a name="ln1024">    return mutat;</a>
<a name="ln1025">}</a>
<a name="ln1026"> </a>
<a name="ln1027">static mutation_type _get_random_qazlal_mutation()</a>
<a name="ln1028">{</a>
<a name="ln1029">    return _get_mut_with_use(mutflag::qazlal);</a>
<a name="ln1030">}</a>
<a name="ln1031"> </a>
<a name="ln1032">static mutation_type _get_random_mutation(mutation_type mutclass)</a>
<a name="ln1033">{</a>
<a name="ln1034">    mutflag mt;</a>
<a name="ln1035">    switch (mutclass)</a>
<a name="ln1036">    {</a>
<a name="ln1037">        case RANDOM_MUTATION:</a>
<a name="ln1038">            // maintain an arbitrary ratio of good to bad muts to allow easier</a>
<a name="ln1039">            // weight changes within categories - 60% good seems to be about</a>
<a name="ln1040">            // where things are right now</a>
<a name="ln1041">            mt = x_chance_in_y(3, 5) ? mutflag::good : mutflag::bad;</a>
<a name="ln1042">            break;</a>
<a name="ln1043">        case RANDOM_BAD_MUTATION:</a>
<a name="ln1044">        case RANDOM_CORRUPT_MUTATION:</a>
<a name="ln1045">            mt = mutflag::bad;</a>
<a name="ln1046">            break;</a>
<a name="ln1047">        case RANDOM_GOOD_MUTATION:</a>
<a name="ln1048">            mt = mutflag::good;</a>
<a name="ln1049">            break;</a>
<a name="ln1050">        default:</a>
<a name="ln1051">            die(&quot;invalid mutation class: %d&quot;, mutclass);</a>
<a name="ln1052">    }</a>
<a name="ln1053"> </a>
<a name="ln1054">    for (int attempt = 0; attempt &lt; 100; ++attempt)</a>
<a name="ln1055">    {</a>
<a name="ln1056">        mutation_type mut = _get_mut_with_use(mt);</a>
<a name="ln1057">        if (_accept_mutation(mut, true))</a>
<a name="ln1058">            return mut;</a>
<a name="ln1059">    }</a>
<a name="ln1060"> </a>
<a name="ln1061">    return NUM_MUTATIONS;</a>
<a name="ln1062">}</a>
<a name="ln1063"> </a>
<a name="ln1064">/**</a>
<a name="ln1065"> * Does the player have a mutation that conflicts with the given mutation?</a>
<a name="ln1066"> *</a>
<a name="ln1067"> * @param mut           A mutation. (E.g. MUT_INHIBITED_REGENERATION, ...)</a>
<a name="ln1068"> * @param innate_only   Whether to only check innate mutations (from e.g. race)</a>
<a name="ln1069"> * @return              The level of the conflicting mutation.</a>
<a name="ln1070"> *                      E.g., if MUT_INHIBITED_REGENERATION is passed in and the</a>
<a name="ln1071"> *                      player has 2 levels of MUT_REGENERATION, 2 will be</a>
<a name="ln1072"> *                      returned.</a>
<a name="ln1073"> *</a>
<a name="ln1074"> *                      No guarantee is offered on ordering if there are</a>
<a name="ln1075"> *                      multiple conflicting mutations with different levels.</a>
<a name="ln1076"> */</a>
<a name="ln1077">int mut_check_conflict(mutation_type mut, bool innate_only)</a>
<a name="ln1078">{</a>
<a name="ln1079">    for (const int (&amp;confl)[3] : conflict)</a>
<a name="ln1080">    {</a>
<a name="ln1081">        if (confl[0] != mut &amp;&amp; confl[1] != mut)</a>
<a name="ln1082">            continue;</a>
<a name="ln1083"> </a>
<a name="ln1084">        const mutation_type confl_mut</a>
<a name="ln1085">           = static_cast&lt;mutation_type&gt;(confl[0] == mut ? confl[1] : confl[0]);</a>
<a name="ln1086"> </a>
<a name="ln1087">        const int level = you.get_base_mutation_level(confl_mut, true, !innate_only, !innate_only);</a>
<a name="ln1088">        if (level)</a>
<a name="ln1089">            return level;</a>
<a name="ln1090">    }</a>
<a name="ln1091"> </a>
<a name="ln1092">    return 0;</a>
<a name="ln1093">}</a>
<a name="ln1094"> </a>
<a name="ln1095">// Tries to give you the mutation by deleting a conflicting</a>
<a name="ln1096">// one, or clears out conflicting mutations if we should give</a>
<a name="ln1097">// you the mutation anyway.</a>
<a name="ln1098">// Return:</a>
<a name="ln1099">//  1 if we should stop processing (success);</a>
<a name="ln1100">//  0 if we should continue processing;</a>
<a name="ln1101">// -1 if we should stop processing (failure).</a>
<a name="ln1102">static int _handle_conflicting_mutations(mutation_type mutation,</a>
<a name="ln1103">                                         bool override,</a>
<a name="ln1104">                                         const string &amp;reason,</a>
<a name="ln1105">                                         bool temp = false)</a>
<a name="ln1106">{</a>
<a name="ln1107">    // If we have one of the pair, delete all levels of the other,</a>
<a name="ln1108">    // and continue processing.</a>
<a name="ln1109">    for (const int (&amp;confl)[3] : conflict)</a>
<a name="ln1110">    {</a>
<a name="ln1111">        for (int j = 0; j &lt;= 1; ++j)</a>
<a name="ln1112">        {</a>
<a name="ln1113">            const mutation_type a = (mutation_type)confl[j];</a>
<a name="ln1114">            const mutation_type b = (mutation_type)confl[1-j];</a>
<a name="ln1115"> </a>
<a name="ln1116">            if (mutation == a &amp;&amp; you.get_base_mutation_level(b) &gt; 0)</a>
<a name="ln1117">            {</a>
<a name="ln1118">                // can never delete innate mutations. For case -1 and 0, fail if there are any, otherwise,</a>
<a name="ln1119">                // make sure there is a non-innate instance to delete.</a>
<a name="ln1120">                if (you.has_innate_mutation(b) &amp;&amp;</a>
<a name="ln1121">                    (confl[2] != 1</a>
<a name="ln1122">                     || you.get_base_mutation_level(b, true, false, false) == you.get_base_mutation_level(b)))</a>
<a name="ln1123">                {</a>
<a name="ln1124">                    dprf(&quot;Delete mutation failed: have innate mutation %d at level %d, you.mutation at level %d&quot;, b,</a>
<a name="ln1125">                        you.get_innate_mutation_level(b), you.get_base_mutation_level(b));</a>
<a name="ln1126">                    return -1;</a>
<a name="ln1127">                }</a>
<a name="ln1128"> </a>
<a name="ln1129">                // at least one level of this mutation is temporary</a>
<a name="ln1130">                const bool temp_b = you.has_temporary_mutation(b);</a>
<a name="ln1131"> </a>
<a name="ln1132">                // confl[2] indicates how the mutation resolution should proceed (see `conflict` a the beginning of this file):</a>
<a name="ln1133">                switch (confl[2])</a>
<a name="ln1134">                {</a>
<a name="ln1135">                case -1:</a>
<a name="ln1136">                    // Fail if not forced, otherwise override.</a>
<a name="ln1137">                    if (!override)</a>
<a name="ln1138">                        return -1;</a>
<a name="ln1139">                case 0:</a>
<a name="ln1140">                    // Ignore if not forced, otherwise override.</a>
<a name="ln1141">                    // All cases but regen:slowmeta will currently trade off.</a>
<a name="ln1142">                    if (override)</a>
<a name="ln1143">                    {</a>
<a name="ln1144">                        while (_delete_single_mutation_level(b, reason, true))</a>
<a name="ln1145">                            ;</a>
<a name="ln1146">                    }</a>
<a name="ln1147">                    break;</a>
<a name="ln1148">                case 1:</a>
<a name="ln1149">                    // If we have one of the pair, delete a level of the</a>
<a name="ln1150">                    // other, and that's it.</a>
<a name="ln1151">                    //</a>
<a name="ln1152">                    // Temporary mutations can co-exist with things they would</a>
<a name="ln1153">                    // ordinarily conflict with. But if both a and b are temporary,</a>
<a name="ln1154">                    // mark b for deletion.</a>
<a name="ln1155">                    if ((temp || temp_b) &amp;&amp; !(temp &amp;&amp; temp_b))</a>
<a name="ln1156">                        return 0;       // Allow conflicting transient mutations</a>
<a name="ln1157">                    else</a>
<a name="ln1158">                    {</a>
<a name="ln1159">                        _delete_single_mutation_level(b, reason, true);</a>
<a name="ln1160">                        return 1;     // Nothing more to do.</a>
<a name="ln1161">                    }</a>
<a name="ln1162"> </a>
<a name="ln1163">                default:</a>
<a name="ln1164">                    die(&quot;bad mutation conflict resulution&quot;);</a>
<a name="ln1165">                }</a>
<a name="ln1166">            }</a>
<a name="ln1167">        }</a>
<a name="ln1168">    }</a>
<a name="ln1169"> </a>
<a name="ln1170">    return 0;</a>
<a name="ln1171">}</a>
<a name="ln1172"> </a>
<a name="ln1173">static int _body_covered()</a>
<a name="ln1174">{</a>
<a name="ln1175">    // Check how much of your body is covered by scales, etc.</a>
<a name="ln1176">    // Note: this won't take into account forms, so is only usable for checking in general.</a>
<a name="ln1177">    int covered = 0;</a>
<a name="ln1178"> </a>
<a name="ln1179">    if (you.species == SP_NAGA)</a>
<a name="ln1180">        covered++;</a>
<a name="ln1181"> </a>
<a name="ln1182">    if (species_is_draconian(you.species))</a>
<a name="ln1183">        covered += 3;</a>
<a name="ln1184"> </a>
<a name="ln1185">    for (mutation_type scale : _all_scales)</a>
<a name="ln1186">        covered += you.get_base_mutation_level(scale);</a>
<a name="ln1187"> </a>
<a name="ln1188">    return covered;</a>
<a name="ln1189">}</a>
<a name="ln1190"> </a>
<a name="ln1191">bool physiology_mutation_conflict(mutation_type mutat)</a>
<a name="ln1192">{</a>
<a name="ln1193">    // If demonspawn, and mutat is a scale, see if they were going</a>
<a name="ln1194">    // to get it sometime in the future anyway; otherwise, conflict.</a>
<a name="ln1195">    if (you.species == SP_DEMONSPAWN &amp;&amp; _is_covering(mutat)</a>
<a name="ln1196">        &amp;&amp; find(_all_scales, _all_scales+ARRAYSZ(_all_scales), mutat) !=</a>
<a name="ln1197">                _all_scales+ARRAYSZ(_all_scales))</a>
<a name="ln1198">    {</a>
<a name="ln1199">        return none_of(begin(you.demonic_traits), end(you.demonic_traits),</a>
<a name="ln1200">                       [=](const player::demon_trait &amp;t) {</a>
<a name="ln1201">                           return t.mutation == mutat;});</a>
<a name="ln1202">    }</a>
<a name="ln1203"> </a>
<a name="ln1204">    // Strict 3-scale limit.</a>
<a name="ln1205">    if (_is_covering(mutat) &amp;&amp; _body_covered() &gt;= 3)</a>
<a name="ln1206">        return true;</a>
<a name="ln1207"> </a>
<a name="ln1208">    // Only Nagas and Draconians can get this one.</a>
<a name="ln1209">    if (you.species != SP_NAGA &amp;&amp; !species_is_draconian(you.species)</a>
<a name="ln1210">        &amp;&amp; mutat == MUT_STINGER)</a>
<a name="ln1211">    {</a>
<a name="ln1212">        return true;</a>
<a name="ln1213">    }</a>
<a name="ln1214"> </a>
<a name="ln1215">    // Need tentacles to grow something on them.</a>
<a name="ln1216">    if (you.species != SP_OCTOPODE &amp;&amp; mutat == MUT_TENTACLE_SPIKE)</a>
<a name="ln1217">        return true;</a>
<a name="ln1218"> </a>
<a name="ln1219">    // No bones for thin skeletal structure, and too squishy for horns.</a>
<a name="ln1220">    if (you.species == SP_OCTOPODE</a>
<a name="ln1221">        &amp;&amp; (mutat == MUT_THIN_SKELETAL_STRUCTURE || mutat == MUT_HORNS))</a>
<a name="ln1222">    {</a>
<a name="ln1223">        return true;</a>
<a name="ln1224">    }</a>
<a name="ln1225"> </a>
<a name="ln1226">    // No feet.</a>
<a name="ln1227">    if (!player_has_feet(false, false)</a>
<a name="ln1228">        &amp;&amp; (mutat == MUT_HOOVES || mutat == MUT_TALONS))</a>
<a name="ln1229">    {</a>
<a name="ln1230">        return true;</a>
<a name="ln1231">    }</a>
<a name="ln1232"> </a>
<a name="ln1233">    // Only nagas can get upgraded poison spit.</a>
<a name="ln1234">    if (you.species != SP_NAGA &amp;&amp; mutat == MUT_SPIT_POISON)</a>
<a name="ln1235">        return true;</a>
<a name="ln1236"> </a>
<a name="ln1237">    // Only Draconians (and gargoyles) can get wings.</a>
<a name="ln1238">    if (!species_is_draconian(you.species) &amp;&amp; you.species != SP_GARGOYLE</a>
<a name="ln1239">        &amp;&amp; mutat == MUT_BIG_WINGS)</a>
<a name="ln1240">    {</a>
<a name="ln1241">        return true;</a>
<a name="ln1242">    }</a>
<a name="ln1243"> </a>
<a name="ln1244">    // Vampires' healing and thirst rates depend on their blood level.</a>
<a name="ln1245">    if (you.species == SP_VAMPIRE</a>
<a name="ln1246">        &amp;&amp; (mutat == MUT_CARNIVOROUS || mutat == MUT_HERBIVOROUS</a>
<a name="ln1247">            || mutat == MUT_REGENERATION || mutat == MUT_INHIBITED_REGENERATION</a>
<a name="ln1248">            || mutat == MUT_FAST_METABOLISM || mutat == MUT_SLOW_METABOLISM))</a>
<a name="ln1249">    {</a>
<a name="ln1250">        return true;</a>
<a name="ln1251">    }</a>
<a name="ln1252"> </a>
<a name="ln1253">    // Felids have innate claws, and unlike trolls/ghouls, there are no</a>
<a name="ln1254">    // increases for them. And octopodes have no hands.</a>
<a name="ln1255">    if ((you.species == SP_FELID || you.species == SP_OCTOPODE)</a>
<a name="ln1256">         &amp;&amp; mutat == MUT_CLAWS)</a>
<a name="ln1257">    {</a>
<a name="ln1258">        return true;</a>
<a name="ln1259">    }</a>
<a name="ln1260"> </a>
<a name="ln1261">    // Merfolk have no feet in the natural form, and we never allow mutations</a>
<a name="ln1262">    // that show up only in a certain transformation.</a>
<a name="ln1263">    if (you.species == SP_MERFOLK</a>
<a name="ln1264">        &amp;&amp; (mutat == MUT_TALONS || mutat == MUT_HOOVES))</a>
<a name="ln1265">    {</a>
<a name="ln1266">        return true;</a>
<a name="ln1267">    }</a>
<a name="ln1268"> </a>
<a name="ln1269">    if (you.species == SP_FORMICID)</a>
<a name="ln1270">    {</a>
<a name="ln1271">        // Formicids have stasis and so prevent mutations that would do nothing.</a>
<a name="ln1272">        // Antennae provides SInv, so acute vision is pointless.</a>
<a name="ln1273">        if (mutat == MUT_BERSERK</a>
<a name="ln1274">            || mutat == MUT_BLINK</a>
<a name="ln1275">            || mutat == MUT_TELEPORT</a>
<a name="ln1276">            || mutat == MUT_ACUTE_VISION)</a>
<a name="ln1277">        {</a>
<a name="ln1278">            return true;</a>
<a name="ln1279">        }</a>
<a name="ln1280">    }</a>
<a name="ln1281"> </a>
<a name="ln1282">    // Already immune.</a>
<a name="ln1283">    if (you.species == SP_GARGOYLE &amp;&amp; mutat == MUT_POISON_RESISTANCE)</a>
<a name="ln1284">        return true;</a>
<a name="ln1285"> </a>
<a name="ln1286">    // We can't use is_useless_skill() here, since species that can still wear</a>
<a name="ln1287">    // body armour can sacrifice armour skill with Ru.</a>
<a name="ln1288">    if (species_apt(SK_ARMOUR) == UNUSABLE_SKILL</a>
<a name="ln1289">        &amp;&amp; (mutat == MUT_DEFORMED || mutat == MUT_STURDY_FRAME))</a>
<a name="ln1290">    {</a>
<a name="ln1291">        return true;</a>
<a name="ln1292">    }</a>
<a name="ln1293"> </a>
<a name="ln1294">    equipment_type eq_type = EQ_NONE;</a>
<a name="ln1295"> </a>
<a name="ln1296">    // Mutations of the same slot conflict</a>
<a name="ln1297">    if (is_body_facet(mutat))</a>
<a name="ln1298">    {</a>
<a name="ln1299">        // Find equipment slot of attempted mutation</a>
<a name="ln1300">        for (const body_facet_def &amp;facet : _body_facets)</a>
<a name="ln1301">            if (mutat == facet.mut)</a>
<a name="ln1302">                eq_type = facet.eq;</a>
<a name="ln1303"> </a>
<a name="ln1304">        if (eq_type != EQ_NONE)</a>
<a name="ln1305">        {</a>
<a name="ln1306">            for (const body_facet_def &amp;facet : _body_facets)</a>
<a name="ln1307">            {</a>
<a name="ln1308">                if (eq_type == facet.eq</a>
<a name="ln1309">                    &amp;&amp; mutat != facet.mut</a>
<a name="ln1310">                    &amp;&amp; you.get_base_mutation_level(facet.mut))</a>
<a name="ln1311">                {</a>
<a name="ln1312">                    return true;</a>
<a name="ln1313">                }</a>
<a name="ln1314">            }</a>
<a name="ln1315">        }</a>
<a name="ln1316">    }</a>
<a name="ln1317"> </a>
<a name="ln1318">    return false;</a>
<a name="ln1319">}</a>
<a name="ln1320"> </a>
<a name="ln1321">static const char* _stat_mut_desc(mutation_type mut, bool gain)</a>
<a name="ln1322">{</a>
<a name="ln1323">    stat_type stat = STAT_STR;</a>
<a name="ln1324">    bool positive = gain;</a>
<a name="ln1325">    switch (mut)</a>
<a name="ln1326">    {</a>
<a name="ln1327">    case MUT_WEAK:</a>
<a name="ln1328">        positive = !positive;</a>
<a name="ln1329">    case MUT_STRONG:</a>
<a name="ln1330">        stat = STAT_STR;</a>
<a name="ln1331">        break;</a>
<a name="ln1332"> </a>
<a name="ln1333">    case MUT_DOPEY:</a>
<a name="ln1334">        positive = !positive;</a>
<a name="ln1335">    case MUT_CLEVER:</a>
<a name="ln1336">        stat = STAT_INT;</a>
<a name="ln1337">        break;</a>
<a name="ln1338"> </a>
<a name="ln1339">    case MUT_CLUMSY:</a>
<a name="ln1340">        positive = !positive;</a>
<a name="ln1341">    case MUT_AGILE:</a>
<a name="ln1342">        stat = STAT_DEX;</a>
<a name="ln1343">        break;</a>
<a name="ln1344"> </a>
<a name="ln1345">    default:</a>
<a name="ln1346">        die(&quot;invalid stat mutation: %d&quot;, mut);</a>
<a name="ln1347">    }</a>
<a name="ln1348">    return stat_desc(stat, positive ? SD_INCREASE : SD_DECREASE);</a>
<a name="ln1349">}</a>
<a name="ln1350"> </a>
<a name="ln1351">/**</a>
<a name="ln1352"> * Do a resistance check for the given mutation permanence class.</a>
<a name="ln1353"> * Does not include divine intervention!</a>
<a name="ln1354"> *</a>
<a name="ln1355"> * @param mutclass The type of mutation that is checking resistance</a>
<a name="ln1356"> * @param beneficial Is the mutation beneficial?</a>
<a name="ln1357"> *</a>
<a name="ln1358"> * @return True if a mutation is successfully resisted, false otherwise.</a>
<a name="ln1359">**/</a>
<a name="ln1360">static bool _resist_mutation(mutation_permanence_class mutclass,</a>
<a name="ln1361">                             bool beneficial)</a>
<a name="ln1362">{</a>
<a name="ln1363">    if (you.get_mutation_level(MUT_MUTATION_RESISTANCE) == 3)</a>
<a name="ln1364">        return true;</a>
<a name="ln1365"> </a>
<a name="ln1366">    const int mut_resist_chance = mutclass == MUTCLASS_TEMPORARY ? 2 : 3;</a>
<a name="ln1367">    if (you.get_mutation_level(MUT_MUTATION_RESISTANCE)</a>
<a name="ln1368">        &amp;&amp; !one_chance_in(mut_resist_chance))</a>
<a name="ln1369">    {</a>
<a name="ln1370">        return true;</a>
<a name="ln1371">    }</a>
<a name="ln1372"> </a>
<a name="ln1373">    // To be nice, beneficial mutations go through removable sources of rMut.</a>
<a name="ln1374">    if (you.rmut_from_item() &amp;&amp; !beneficial</a>
<a name="ln1375">        &amp;&amp; !one_chance_in(mut_resist_chance))</a>
<a name="ln1376">    {</a>
<a name="ln1377">        return true;</a>
<a name="ln1378">    }</a>
<a name="ln1379"> </a>
<a name="ln1380">    return false;</a>
<a name="ln1381">}</a>
<a name="ln1382"> </a>
<a name="ln1383">/*</a>
<a name="ln1384"> * Does the player rot instead of mutating?</a>
<a name="ln1385"> * Right now this is coextensive with whether the player is unable to mutate.</a>
<a name="ln1386"> * For most undead, they will never mutate and always rot instead; vampires always mutate and never rot.</a>
<a name="ln1387"> *</a>
<a name="ln1388"> * @return true if so.</a>
<a name="ln1389"> */</a>
<a name="ln1390">bool undead_mutation_rot()</a>
<a name="ln1391">{</a>
<a name="ln1392">    return !you.can_safely_mutate();</a>
<a name="ln1393">}</a>
<a name="ln1394"> </a>
<a name="ln1395">/*</a>
<a name="ln1396"> * Try to mutate the player, along with associated bookkeeping. This accepts mutation categories as well as particular mutations.</a>
<a name="ln1397"> *</a>
<a name="ln1398"> * In many cases this will produce only 1 level of mutation at a time, but it may mutate more than one level if the mutation category is corrupt or qazlal.</a>
<a name="ln1399"> *</a>
<a name="ln1400"> * If the player is at the mutation cap, this may fail.</a>
<a name="ln1401"> *   1. If mutclass is innate, this will attempt to replace temporary and normal mutations (in that order) and will fail if this isn't possible (e.g. there are only innate levels).</a>
<a name="ln1402"> *   2. Otherwise, this will fail. This means that a temporary mutation can block a permanent mutation of the same type in some circumstances.</a>
<a name="ln1403"> *</a>
<a name="ln1404"> * If the mutation conflicts with an existing one it may fail. See `_handle_conflicting_mutations`.</a>
<a name="ln1405"> *</a>
<a name="ln1406"> * If the player is undead, this may rot instead. Rotting counts as success.</a>
<a name="ln1407"> *</a>
<a name="ln1408"> * @param which_mutation    the mutation to use.</a>
<a name="ln1409"> * @param reason            the explanation for how the player got mutated.</a>
<a name="ln1410"> * @param failMsg           whether to do any messaging if this fails.</a>
<a name="ln1411"> * @param force_mutation    whether to override mutation protection and the like.</a>
<a name="ln1412"> * @param god_gift          is this a god gift? Entails overriding mutation resistance if not forced.</a>
<a name="ln1413"> * @param mutclass          is the mutation temporary, regular, or permanent (innate)? permanent entails force_mutation.</a>
<a name="ln1414"> *</a>
<a name="ln1415"> * @return whether the mutation succeeded.</a>
<a name="ln1416"> */</a>
<a name="ln1417">bool mutate(mutation_type which_mutation, const string &amp;reason, bool failMsg,</a>
<a name="ln1418">            bool force_mutation, bool god_gift, bool beneficial,</a>
<a name="ln1419">            mutation_permanence_class mutclass)</a>
<a name="ln1420">{</a>
<a name="ln1421">    if (which_mutation == RANDOM_BAD_MUTATION</a>
<a name="ln1422">        &amp;&amp; mutclass == MUTCLASS_NORMAL</a>
<a name="ln1423">        &amp;&amp; crawl_state.disables[DIS_AFFLICTIONS])</a>
<a name="ln1424">    {</a>
<a name="ln1425">        return true; // no fallbacks</a>
<a name="ln1426">    }</a>
<a name="ln1427"> </a>
<a name="ln1428">    god_gift |= crawl_state.is_god_acting();</a>
<a name="ln1429"> </a>
<a name="ln1430">    if (mutclass == MUTCLASS_INNATE)</a>
<a name="ln1431">        force_mutation = true;</a>
<a name="ln1432"> </a>
<a name="ln1433">    mutation_type mutat = which_mutation;</a>
<a name="ln1434"> </a>
<a name="ln1435">    if (!force_mutation)</a>
<a name="ln1436">    {</a>
<a name="ln1437">        // God gifts override all sources of mutation resistance other</a>
<a name="ln1438">        // than divine protection.</a>
<a name="ln1439">        if (!god_gift &amp;&amp; _resist_mutation(mutclass, beneficial))</a>
<a name="ln1440">        {</a>
<a name="ln1441">            if (failMsg)</a>
<a name="ln1442">                mprf(MSGCH_MUTATION, &quot;You feel odd for a moment.&quot;);</a>
<a name="ln1443">            return false;</a>
<a name="ln1444">        }</a>
<a name="ln1445"> </a>
<a name="ln1446">        // Zin's protection.</a>
<a name="ln1447">        if (have_passive(passive_t::resist_mutation)</a>
<a name="ln1448">            &amp;&amp; x_chance_in_y(you.piety, piety_breakpoint(5)))</a>
<a name="ln1449">        {</a>
<a name="ln1450">            simple_god_message(&quot; protects your body from mutation!&quot;);</a>
<a name="ln1451">            return false;</a>
<a name="ln1452">        }</a>
<a name="ln1453">    }</a>
<a name="ln1454"> </a>
<a name="ln1455">    // Undead bodies don't mutate, they fall apart. -- bwr</a>
<a name="ln1456">    if (undead_mutation_rot())</a>
<a name="ln1457">    {</a>
<a name="ln1458">        switch (mutclass)</a>
<a name="ln1459">        {</a>
<a name="ln1460">        case MUTCLASS_TEMPORARY:</a>
<a name="ln1461">            if (coinflip())</a>
<a name="ln1462">                return false;</a>
<a name="ln1463">            // fallthrough to normal mut</a>
<a name="ln1464">        case MUTCLASS_NORMAL:</a>
<a name="ln1465">            mprf(MSGCH_MUTATION, &quot;Your body decomposes!&quot;);</a>
<a name="ln1466">            lose_stat(STAT_RANDOM, 1);</a>
<a name="ln1467">            return true;</a>
<a name="ln1468">        case MUTCLASS_INNATE:</a>
<a name="ln1469">            // You can't miss out on innate mutations just because you're</a>
<a name="ln1470">            // temporarily undead.</a>
<a name="ln1471">            break;</a>
<a name="ln1472">        default:</a>
<a name="ln1473">            die(&quot;bad fall through&quot;);</a>
<a name="ln1474">            return false;</a>
<a name="ln1475">        }</a>
<a name="ln1476">    }</a>
<a name="ln1477"> </a>
<a name="ln1478">    if (mutclass == MUTCLASS_NORMAL</a>
<a name="ln1479">        &amp;&amp; (which_mutation == RANDOM_MUTATION</a>
<a name="ln1480">            || which_mutation == RANDOM_XOM_MUTATION)</a>
<a name="ln1481">        &amp;&amp; x_chance_in_y(you.how_mutated(false, true), 15))</a>
<a name="ln1482">    {</a>
<a name="ln1483">        // God gifts override mutation loss due to being heavily</a>
<a name="ln1484">        // mutated.</a>
<a name="ln1485">        if (!one_chance_in(3) &amp;&amp; !god_gift &amp;&amp; !force_mutation)</a>
<a name="ln1486">            return false;</a>
<a name="ln1487">        else</a>
<a name="ln1488">            return delete_mutation(RANDOM_MUTATION, reason, failMsg,</a>
<a name="ln1489">                                   force_mutation, false);</a>
<a name="ln1490">    }</a>
<a name="ln1491"> </a>
<a name="ln1492">    switch (which_mutation)</a>
<a name="ln1493">    {</a>
<a name="ln1494">    case RANDOM_MUTATION:</a>
<a name="ln1495">    case RANDOM_GOOD_MUTATION:</a>
<a name="ln1496">    case RANDOM_BAD_MUTATION:</a>
<a name="ln1497">    case RANDOM_CORRUPT_MUTATION:</a>
<a name="ln1498">        mutat = _get_random_mutation(which_mutation);</a>
<a name="ln1499">        break;</a>
<a name="ln1500">    case RANDOM_XOM_MUTATION:</a>
<a name="ln1501">        mutat = _get_random_xom_mutation();</a>
<a name="ln1502">        break;</a>
<a name="ln1503">    case RANDOM_SLIME_MUTATION:</a>
<a name="ln1504">        mutat = _get_random_slime_mutation();</a>
<a name="ln1505">        break;</a>
<a name="ln1506">    case RANDOM_QAZLAL_MUTATION:</a>
<a name="ln1507">        mutat = _get_random_qazlal_mutation();</a>
<a name="ln1508">        break;</a>
<a name="ln1509">    default:</a>
<a name="ln1510">        break;</a>
<a name="ln1511">    }</a>
<a name="ln1512"> </a>
<a name="ln1513"> </a>
<a name="ln1514">    if (!_is_valid_mutation(mutat))</a>
<a name="ln1515">        return false;</a>
<a name="ln1516"> </a>
<a name="ln1517">    // [Cha] don't allow teleportitis in sprint</a>
<a name="ln1518">    if (mutat == MUT_TELEPORT &amp;&amp; crawl_state.game_is_sprint())</a>
<a name="ln1519">        return false;</a>
<a name="ln1520"> </a>
<a name="ln1521">    if (physiology_mutation_conflict(mutat))</a>
<a name="ln1522">        return false;</a>
<a name="ln1523"> </a>
<a name="ln1524">    const mutation_def&amp; mdef = _get_mutation_def(mutat);</a>
<a name="ln1525"> </a>
<a name="ln1526">    bool gain_msg = true;</a>
<a name="ln1527"> </a>
<a name="ln1528">    if (mutclass == MUTCLASS_INNATE)</a>
<a name="ln1529">    {</a>
<a name="ln1530">        // are there any non-innate instances to replace?  Prioritize temporary mutations over normal.</a>
<a name="ln1531">        // Temporarily decrement the mutation value so it can be silently regained in the while loop below.</a>
<a name="ln1532">        if (you.mutation[mutat] &gt; you.innate_mutation[mutat])</a>
<a name="ln1533">        {</a>
<a name="ln1534">            if (you.temp_mutation[mutat] &gt; 0)</a>
<a name="ln1535">            {</a>
<a name="ln1536">                you.temp_mutation[mutat]--;</a>
<a name="ln1537">                you.attribute[ATTR_TEMP_MUTATIONS]--;</a>
<a name="ln1538">                if (you.attribute[ATTR_TEMP_MUTATIONS] == 0)</a>
<a name="ln1539">                    you.attribute[ATTR_TEMP_MUT_XP] = 0;</a>
<a name="ln1540">            }</a>
<a name="ln1541">            you.mutation[mutat]--;</a>
<a name="ln1542">            mprf(MSGCH_MUTATION, &quot;Your mutations feel more permanent.&quot;);</a>
<a name="ln1543">            take_note(Note(NOTE_PERM_MUTATION, mutat,</a>
<a name="ln1544">                    you.get_base_mutation_level(mutat), reason.c_str()));</a>
<a name="ln1545">            gain_msg = false;</a>
<a name="ln1546">        }</a>
<a name="ln1547">    }</a>
<a name="ln1548">    if (you.mutation[mutat] &gt;= mdef.levels)</a>
<a name="ln1549">        return false;</a>
<a name="ln1550"> </a>
<a name="ln1551">    // God gifts and forced mutations clear away conflicting mutations.</a>
<a name="ln1552">    int rc = _handle_conflicting_mutations(mutat, god_gift || force_mutation,</a>
<a name="ln1553">                                           reason,</a>
<a name="ln1554">                                           mutclass == MUTCLASS_TEMPORARY);</a>
<a name="ln1555">    if (rc == 1)</a>
<a name="ln1556">        return true;</a>
<a name="ln1557">    if (rc == -1)</a>
<a name="ln1558">        return false;</a>
<a name="ln1559"> </a>
<a name="ln1560">    ASSERT(rc == 0);</a>
<a name="ln1561"> </a>
<a name="ln1562">    const unsigned int old_talents = your_talents(false).size();</a>
<a name="ln1563"> </a>
<a name="ln1564">    const int levels = (which_mutation == RANDOM_CORRUPT_MUTATION</a>
<a name="ln1565">                         || which_mutation == RANDOM_QAZLAL_MUTATION)</a>
<a name="ln1566">                       ? min(2, mdef.levels - you.get_base_mutation_level(mutat))</a>
<a name="ln1567">                       : 1;</a>
<a name="ln1568">    ASSERT(levels &gt; 0); //TODO: is &gt; too strong?</a>
<a name="ln1569"> </a>
<a name="ln1570">    int count = levels;</a>
<a name="ln1571"> </a>
<a name="ln1572">    while (count-- &gt; 0)</a>
<a name="ln1573">    {</a>
<a name="ln1574">        // no fail condition past this point, so it is safe to do bookkeeping</a>
<a name="ln1575">        you.mutation[mutat]++;</a>
<a name="ln1576">        if (mutclass == MUTCLASS_TEMPORARY)</a>
<a name="ln1577">        {</a>
<a name="ln1578">            // do book-keeping for temporary mutations</a>
<a name="ln1579">            you.temp_mutation[mutat]++;</a>
<a name="ln1580">            you.attribute[ATTR_TEMP_MUTATIONS]++;</a>
<a name="ln1581">        }</a>
<a name="ln1582">        else if (mutclass == MUTCLASS_INNATE)</a>
<a name="ln1583">            you.innate_mutation[mutat]++;</a>
<a name="ln1584"> </a>
<a name="ln1585">        const int cur_base_level = you.get_base_mutation_level(mutat);</a>
<a name="ln1586"> </a>
<a name="ln1587">        // More than three messages, need to give them by hand.</a>
<a name="ln1588">        switch (mutat)</a>
<a name="ln1589">        {</a>
<a name="ln1590">        case MUT_STRONG: case MUT_AGILE:  case MUT_CLEVER:</a>
<a name="ln1591">        case MUT_WEAK:   case MUT_CLUMSY: case MUT_DOPEY:</a>
<a name="ln1592">            mprf(MSGCH_MUTATION, &quot;You feel %s.&quot;, _stat_mut_desc(mutat, true));</a>
<a name="ln1593">            gain_msg = false;</a>
<a name="ln1594">            break;</a>
<a name="ln1595"> </a>
<a name="ln1596">        case MUT_LARGE_BONE_PLATES:</a>
<a name="ln1597">            {</a>
<a name="ln1598">                const char *arms;</a>
<a name="ln1599">                if (you.species == SP_FELID)</a>
<a name="ln1600">                    arms = &quot;legs&quot;;</a>
<a name="ln1601">                else if (you.species == SP_OCTOPODE)</a>
<a name="ln1602">                    arms = &quot;tentacles&quot;;</a>
<a name="ln1603">                else</a>
<a name="ln1604">                    break;</a>
<a name="ln1605">                mprf(MSGCH_MUTATION, &quot;%s&quot;,</a>
<a name="ln1606">                     replace_all(mdef.gain[cur_base_level - 1], &quot;arms&quot;,</a>
<a name="ln1607">                                 arms).c_str());</a>
<a name="ln1608">                gain_msg = false;</a>
<a name="ln1609">            }</a>
<a name="ln1610">            break;</a>
<a name="ln1611"> </a>
<a name="ln1612">        case MUT_MISSING_HAND:</a>
<a name="ln1613">            {</a>
<a name="ln1614">                const char *hands;</a>
<a name="ln1615">                if (you.species == SP_FELID)</a>
<a name="ln1616">                    hands = &quot;front paws&quot;;</a>
<a name="ln1617">                else if (you.species == SP_OCTOPODE)</a>
<a name="ln1618">                    hands = &quot;tentacles&quot;;</a>
<a name="ln1619">                else</a>
<a name="ln1620">                    break;</a>
<a name="ln1621">                mprf(MSGCH_MUTATION, &quot;%s&quot;,</a>
<a name="ln1622">                     replace_all(mdef.gain[cur_base_level - 1], &quot;hands&quot;,</a>
<a name="ln1623">                                 hands).c_str());</a>
<a name="ln1624">                gain_msg = false;</a>
<a name="ln1625">            }</a>
<a name="ln1626">            break;</a>
<a name="ln1627"> </a>
<a name="ln1628">        case MUT_SPIT_POISON:</a>
<a name="ln1629">            // Breathe poison replaces spit poison (so it takes the slot).</a>
<a name="ln1630">            if (cur_base_level &gt;= 2)</a>
<a name="ln1631">                for (int i = 0; i &lt; 52; ++i)</a>
<a name="ln1632">                    if (you.ability_letter_table[i] == ABIL_SPIT_POISON)</a>
<a name="ln1633">                        you.ability_letter_table[i] = ABIL_BREATHE_POISON;</a>
<a name="ln1634">            break;</a>
<a name="ln1635"> </a>
<a name="ln1636">        default:</a>
<a name="ln1637">            break;</a>
<a name="ln1638">        }</a>
<a name="ln1639"> </a>
<a name="ln1640">        // For all those scale mutations.</a>
<a name="ln1641">        you.redraw_armour_class = true;</a>
<a name="ln1642"> </a>
<a name="ln1643">        notify_stat_change();</a>
<a name="ln1644"> </a>
<a name="ln1645">        if (gain_msg)</a>
<a name="ln1646">            mprf(MSGCH_MUTATION, &quot;%s&quot;, mdef.gain[cur_base_level - 1]);</a>
<a name="ln1647"> </a>
<a name="ln1648">        // Do post-mutation effects.</a>
<a name="ln1649">        switch (mutat)</a>
<a name="ln1650">        {</a>
<a name="ln1651">        case MUT_FRAIL:</a>
<a name="ln1652">        case MUT_ROBUST:</a>
<a name="ln1653">        case MUT_RUGGED_BROWN_SCALES:</a>
<a name="ln1654">            calc_hp();</a>
<a name="ln1655">            break;</a>
<a name="ln1656"> </a>
<a name="ln1657">        case MUT_LOW_MAGIC:</a>
<a name="ln1658">        case MUT_HIGH_MAGIC:</a>
<a name="ln1659">            calc_mp();</a>
<a name="ln1660">            break;</a>
<a name="ln1661"> </a>
<a name="ln1662">        case MUT_PASSIVE_MAPPING:</a>
<a name="ln1663">            add_daction(DACT_REAUTOMAP);</a>
<a name="ln1664">            break;</a>
<a name="ln1665"> </a>
<a name="ln1666">        case MUT_HOOVES:</a>
<a name="ln1667">        case MUT_TALONS:</a>
<a name="ln1668">            // Hooves and talons force boots off at 3.</a>
<a name="ln1669">            if (cur_base_level &gt;= 3 &amp;&amp; !you.melded[EQ_BOOTS])</a>
<a name="ln1670">                remove_one_equip(EQ_BOOTS, false, true);</a>
<a name="ln1671">            // Recheck Ashenzari bondage in case our available slots changed.</a>
<a name="ln1672">            ash_check_bondage();</a>
<a name="ln1673">            break;</a>
<a name="ln1674"> </a>
<a name="ln1675">        case MUT_CLAWS:</a>
<a name="ln1676">            // Claws force gloves off at 3.</a>
<a name="ln1677">            if (cur_base_level &gt;= 3 &amp;&amp; !you.melded[EQ_GLOVES])</a>
<a name="ln1678">                remove_one_equip(EQ_GLOVES, false, true);</a>
<a name="ln1679">            // Recheck Ashenzari bondage in case our available slots changed.</a>
<a name="ln1680">            ash_check_bondage();</a>
<a name="ln1681">            break;</a>
<a name="ln1682"> </a>
<a name="ln1683">        case MUT_HORNS:</a>
<a name="ln1684">        case MUT_ANTENNAE:</a>
<a name="ln1685">            // Horns &amp; Antennae 3 removes all headgear. Same algorithm as with</a>
<a name="ln1686">            // glove removal.</a>
<a name="ln1687"> </a>
<a name="ln1688">            if (cur_base_level &gt;= 3 &amp;&amp; !you.melded[EQ_HELMET])</a>
<a name="ln1689">                remove_one_equip(EQ_HELMET, false, true);</a>
<a name="ln1690">            // Intentional fall-through</a>
<a name="ln1691">        case MUT_BEAK:</a>
<a name="ln1692">            // Horns, beaks, and antennae force hard helmets off.</a>
<a name="ln1693">            if (you.equip[EQ_HELMET] != -1</a>
<a name="ln1694">                &amp;&amp; is_hard_helmet(you.inv[you.equip[EQ_HELMET]])</a>
<a name="ln1695">                &amp;&amp; !you.melded[EQ_HELMET])</a>
<a name="ln1696">            {</a>
<a name="ln1697">                remove_one_equip(EQ_HELMET, false, true);</a>
<a name="ln1698">            }</a>
<a name="ln1699">            // Recheck Ashenzari bondage in case our available slots changed.</a>
<a name="ln1700">            ash_check_bondage();</a>
<a name="ln1701">            break;</a>
<a name="ln1702"> </a>
<a name="ln1703">        case MUT_ACUTE_VISION:</a>
<a name="ln1704">            // We might have to turn autopickup back on again.</a>
<a name="ln1705">            autotoggle_autopickup(false);</a>
<a name="ln1706">            break;</a>
<a name="ln1707"> </a>
<a name="ln1708">        case MUT_NIGHTSTALKER:</a>
<a name="ln1709">            update_vision_range();</a>
<a name="ln1710">            break;</a>
<a name="ln1711"> </a>
<a name="ln1712">        case MUT_BIG_WINGS:</a>
<a name="ln1713">#ifdef USE_TILE</a>
<a name="ln1714">            init_player_doll();</a>
<a name="ln1715">#endif</a>
<a name="ln1716">            break;</a>
<a name="ln1717"> </a>
<a name="ln1718">        default:</a>
<a name="ln1719">            break;</a>
<a name="ln1720">        }</a>
<a name="ln1721"> </a>
<a name="ln1722">        xom_is_stimulated(_calc_mutation_amusement_value(mutat));</a>
<a name="ln1723"> </a>
<a name="ln1724">        if (mutclass != MUTCLASS_TEMPORARY)</a>
<a name="ln1725">        {</a>
<a name="ln1726">            take_note(Note(NOTE_GET_MUTATION, mutat, cur_base_level,</a>
<a name="ln1727">                           reason.c_str()));</a>
<a name="ln1728">        }</a>
<a name="ln1729">        else</a>
<a name="ln1730">        {</a>
<a name="ln1731">            // only do this once regardless of how many levels got added</a>
<a name="ln1732">            you.attribute[ATTR_TEMP_MUT_XP] = temp_mutation_roll();</a>
<a name="ln1733">        }</a>
<a name="ln1734"> </a>
<a name="ln1735">        if (you.hp &lt;= 0)</a>
<a name="ln1736">        {</a>
<a name="ln1737">            ouch(0, KILLED_BY_FRAILTY, MID_NOBODY,</a>
<a name="ln1738">                 make_stringf(&quot;gaining the %s mutation&quot;,</a>
<a name="ln1739">                              mutation_name(mutat)).c_str());</a>
<a name="ln1740">        }</a>
<a name="ln1741">    }</a>
<a name="ln1742"> </a>
<a name="ln1743">#ifdef USE_TILE_LOCAL</a>
<a name="ln1744">    if (your_talents(false).size() != old_talents)</a>
<a name="ln1745">    {</a>
<a name="ln1746">        tiles.layout_statcol();</a>
<a name="ln1747">        redraw_screen();</a>
<a name="ln1748">    }</a>
<a name="ln1749">#endif</a>
<a name="ln1750">    if (crawl_state.game_is_hints()</a>
<a name="ln1751">        &amp;&amp; your_talents(false).size() &gt; old_talents)</a>
<a name="ln1752">    {</a>
<a name="ln1753">        learned_something_new(HINT_NEW_ABILITY_MUT);</a>
<a name="ln1754">    }</a>
<a name="ln1755">#ifdef DEBUG</a>
<a name="ln1756">    if (mutclass != MUTCLASS_INNATE) // taken care of in perma_mutate. Skipping this here avoids validation issues in doing repairs.</a>
<a name="ln1757">        validate_mutations(false);</a>
<a name="ln1758">#endif</a>
<a name="ln1759">    return true;</a>
<a name="ln1760">}</a>
<a name="ln1761"> </a>
<a name="ln1762">/*</a>
<a name="ln1763"> * Delete a single mutation level of fixed type `mutat`.</a>
<a name="ln1764"> * If `transient` is set, allow deleting temporary mutations, and prioritize them.</a>
<a name="ln1765"> * Note that if `transient` is true and there are no temporary mutations, this can delete non-temp mutations.</a>
<a name="ln1766"> * If `transient` is false, and there are only temp mutations, this will fail; otherwise it will delete a non-temp mutation.</a>
<a name="ln1767"> *</a>
<a name="ln1768"> * @mutat     the mutation to delete</a>
<a name="ln1769"> * @reason    why is it being deleted</a>
<a name="ln1770"> * @transient whether to allow (and prioritize) deletion of temporary mutations</a>
<a name="ln1771"> *</a>
<a name="ln1772"> * @return whether a mutation was deleted.</a>
<a name="ln1773"> */</a>
<a name="ln1774">static bool _delete_single_mutation_level(mutation_type mutat,</a>
<a name="ln1775">                                          const string &amp;reason,</a>
<a name="ln1776">                                          bool transient)</a>
<a name="ln1777">{</a>
<a name="ln1778">    // are there some non-innate mutations to delete?</a>
<a name="ln1779">    if (you.get_base_mutation_level(mutat, false, true, true) == 0)</a>
<a name="ln1780">        return false;</a>
<a name="ln1781"> </a>
<a name="ln1782">    bool was_transient = false;</a>
<a name="ln1783">    if (you.has_temporary_mutation(mutat))</a>
<a name="ln1784">    {</a>
<a name="ln1785">        if (transient)</a>
<a name="ln1786">            was_transient = true;</a>
<a name="ln1787">        else if (you.get_base_mutation_level(mutat, false, false, true) == 0) // there are only temporary mutations to delete</a>
<a name="ln1788">            return false;</a>
<a name="ln1789"> </a>
<a name="ln1790">        // fall through: there is a non-temporary mutation level that can be deleted.</a>
<a name="ln1791">    }</a>
<a name="ln1792"> </a>
<a name="ln1793">    const mutation_def&amp; mdef = _get_mutation_def(mutat);</a>
<a name="ln1794"> </a>
<a name="ln1795">    bool lose_msg = true;</a>
<a name="ln1796"> </a>
<a name="ln1797">    you.mutation[mutat]--;</a>
<a name="ln1798"> </a>
<a name="ln1799">    switch (mutat)</a>
<a name="ln1800">    {</a>
<a name="ln1801">    case MUT_STRONG: case MUT_AGILE:  case MUT_CLEVER:</a>
<a name="ln1802">    case MUT_WEAK:   case MUT_CLUMSY: case MUT_DOPEY:</a>
<a name="ln1803">        mprf(MSGCH_MUTATION, &quot;You feel %s.&quot;, _stat_mut_desc(mutat, false));</a>
<a name="ln1804">        lose_msg = false;</a>
<a name="ln1805">        break;</a>
<a name="ln1806"> </a>
<a name="ln1807">    case MUT_SPIT_POISON:</a>
<a name="ln1808">        // Breathe poison replaces spit poison (so it takes the slot).</a>
<a name="ln1809">        if (you.mutation[mutat] &lt; 2)</a>
<a name="ln1810">            for (int i = 0; i &lt; 52; ++i)</a>
<a name="ln1811">                if (you.ability_letter_table[i] == ABIL_SPIT_POISON)</a>
<a name="ln1812">                    you.ability_letter_table[i] = ABIL_BREATHE_POISON;</a>
<a name="ln1813">        break;</a>
<a name="ln1814"> </a>
<a name="ln1815">    case MUT_NIGHTSTALKER:</a>
<a name="ln1816">        update_vision_range();</a>
<a name="ln1817">        break;</a>
<a name="ln1818"> </a>
<a name="ln1819">    case MUT_BIG_WINGS:</a>
<a name="ln1820">        lose_permafly_source();</a>
<a name="ln1821">        break;</a>
<a name="ln1822"> </a>
<a name="ln1823">    case MUT_HORNS:</a>
<a name="ln1824">    case MUT_ANTENNAE:</a>
<a name="ln1825">    case MUT_BEAK:</a>
<a name="ln1826">    case MUT_CLAWS:</a>
<a name="ln1827">    case MUT_HOOVES:</a>
<a name="ln1828">    case MUT_TALONS:</a>
<a name="ln1829">        // Recheck Ashenzari bondage in case our available slots changed.</a>
<a name="ln1830">        ash_check_bondage();</a>
<a name="ln1831">        break;</a>
<a name="ln1832"> </a>
<a name="ln1833">    default:</a>
<a name="ln1834">        break;</a>
<a name="ln1835">    }</a>
<a name="ln1836"> </a>
<a name="ln1837">    // For all those scale mutations.</a>
<a name="ln1838">    you.redraw_armour_class = true;</a>
<a name="ln1839"> </a>
<a name="ln1840">    notify_stat_change();</a>
<a name="ln1841"> </a>
<a name="ln1842">    if (lose_msg)</a>
<a name="ln1843">        mprf(MSGCH_MUTATION, &quot;%s&quot;, mdef.lose[you.mutation[mutat]]);</a>
<a name="ln1844"> </a>
<a name="ln1845">    // Do post-mutation effects.</a>
<a name="ln1846">    if (mutat == MUT_FRAIL || mutat == MUT_ROBUST</a>
<a name="ln1847">        || mutat == MUT_RUGGED_BROWN_SCALES)</a>
<a name="ln1848">    {</a>
<a name="ln1849">        calc_hp();</a>
<a name="ln1850">    }</a>
<a name="ln1851">    if (mutat == MUT_LOW_MAGIC || mutat == MUT_HIGH_MAGIC)</a>
<a name="ln1852">        calc_mp();</a>
<a name="ln1853"> </a>
<a name="ln1854">    if (was_transient)</a>
<a name="ln1855">    {</a>
<a name="ln1856">        --you.temp_mutation[mutat];</a>
<a name="ln1857">        --you.attribute[ATTR_TEMP_MUTATIONS];</a>
<a name="ln1858">    }</a>
<a name="ln1859">    else</a>
<a name="ln1860">        take_note(Note(NOTE_LOSE_MUTATION, mutat, you.mutation[mutat], reason));</a>
<a name="ln1861"> </a>
<a name="ln1862">    if (you.hp &lt;= 0)</a>
<a name="ln1863">    {</a>
<a name="ln1864">        ouch(0, KILLED_BY_FRAILTY, MID_NOBODY,</a>
<a name="ln1865">             make_stringf(&quot;losing the %s mutation&quot;, mutation_name(mutat)).c_str());</a>
<a name="ln1866">    }</a>
<a name="ln1867"> </a>
<a name="ln1868">    return true;</a>
<a name="ln1869">}</a>
<a name="ln1870"> </a>
<a name="ln1871">/*</a>
<a name="ln1872"> * Delete a mutation level, accepting random mutation types and checking mutation resistance.</a>
<a name="ln1873"> * This will not delete temporary or innate mutations.</a>
<a name="ln1874"> *</a>
<a name="ln1875"> * @param which_mutation    a mutation, including random</a>
<a name="ln1876"> * @param reason            the reason for deletion</a>
<a name="ln1877"> * @param failMsg           whether to message the player on failure</a>
<a name="ln1878"> * @param force_mutation    whether to try to override certain cases where the mutation would otherwise fail</a>
<a name="ln1879"> * @param god_gift          is the mutation a god gift?  Will also override certain cases.</a>
<a name="ln1880"> * @param disallow_mismatch for random mutations, do we override good/bad designations in `which_mutation`? (??)</a>
<a name="ln1881"> *</a>
<a name="ln1882"> * @return true iff a mutation was applied.</a>
<a name="ln1883"> */</a>
<a name="ln1884">bool delete_mutation(mutation_type which_mutation, const string &amp;reason,</a>
<a name="ln1885">                     bool failMsg,</a>
<a name="ln1886">                     bool force_mutation, bool god_gift,</a>
<a name="ln1887">                     bool disallow_mismatch)</a>
<a name="ln1888">{</a>
<a name="ln1889">    god_gift |= crawl_state.is_god_acting();</a>
<a name="ln1890"> </a>
<a name="ln1891">    mutation_type mutat = which_mutation;</a>
<a name="ln1892"> </a>
<a name="ln1893">    if (!force_mutation)</a>
<a name="ln1894">    {</a>
<a name="ln1895">        if (!god_gift)</a>
<a name="ln1896">        {</a>
<a name="ln1897">            if (you.get_mutation_level(MUT_MUTATION_RESISTANCE) &gt; 1</a>
<a name="ln1898">                &amp;&amp; (you.get_mutation_level(MUT_MUTATION_RESISTANCE) == 3</a>
<a name="ln1899">                    || coinflip()))</a>
<a name="ln1900">            {</a>
<a name="ln1901">                if (failMsg)</a>
<a name="ln1902">                    mprf(MSGCH_MUTATION, &quot;You feel rather odd for a moment.&quot;);</a>
<a name="ln1903">                return false;</a>
<a name="ln1904">            }</a>
<a name="ln1905">        }</a>
<a name="ln1906"> </a>
<a name="ln1907">        if (undead_mutation_rot())</a>
<a name="ln1908">            return false;</a>
<a name="ln1909">    }</a>
<a name="ln1910"> </a>
<a name="ln1911">    if (which_mutation == RANDOM_MUTATION</a>
<a name="ln1912">        || which_mutation == RANDOM_XOM_MUTATION</a>
<a name="ln1913">        || which_mutation == RANDOM_GOOD_MUTATION</a>
<a name="ln1914">        || which_mutation == RANDOM_BAD_MUTATION</a>
<a name="ln1915">        || which_mutation == RANDOM_NON_SLIME_MUTATION</a>
<a name="ln1916">        || which_mutation == RANDOM_CORRUPT_MUTATION</a>
<a name="ln1917">        || which_mutation == RANDOM_QAZLAL_MUTATION)</a>
<a name="ln1918">    {</a>
<a name="ln1919">        while (true)</a>
<a name="ln1920">        {</a>
<a name="ln1921">            if (one_chance_in(1000))</a>
<a name="ln1922">                return false;</a>
<a name="ln1923"> </a>
<a name="ln1924">            mutat = static_cast&lt;mutation_type&gt;(random2(NUM_MUTATIONS));</a>
<a name="ln1925"> </a>
<a name="ln1926">            if (you.mutation[mutat] == 0</a>
<a name="ln1927">                &amp;&amp; mutat != MUT_STRONG</a>
<a name="ln1928">                &amp;&amp; mutat != MUT_CLEVER</a>
<a name="ln1929">                &amp;&amp; mutat != MUT_AGILE</a>
<a name="ln1930">                &amp;&amp; mutat != MUT_WEAK</a>
<a name="ln1931">                &amp;&amp; mutat != MUT_DOPEY</a>
<a name="ln1932">                &amp;&amp; mutat != MUT_CLUMSY)</a>
<a name="ln1933">            {</a>
<a name="ln1934">                continue;</a>
<a name="ln1935">            }</a>
<a name="ln1936"> </a>
<a name="ln1937">            if (which_mutation == RANDOM_NON_SLIME_MUTATION</a>
<a name="ln1938">                &amp;&amp; is_slime_mutation(mutat))</a>
<a name="ln1939">            {</a>
<a name="ln1940">                continue;</a>
<a name="ln1941">            }</a>
<a name="ln1942"> </a>
<a name="ln1943">            // Check whether there is a non-innate level of `mutat` to delete</a>
<a name="ln1944">            if (you.get_base_mutation_level(mutat, false, true, true) == 0)</a>
<a name="ln1945">                continue;</a>
<a name="ln1946"> </a>
<a name="ln1947">            // MUT_ANTENNAE is 0, and you.attribute[] is initialized to 0.</a>
<a name="ln1948">            if (mutat &amp;&amp; mutat == you.attribute[ATTR_APPENDAGE])</a>
<a name="ln1949">                continue;</a>
<a name="ln1950"> </a>
<a name="ln1951">            const mutation_def&amp; mdef = _get_mutation_def(mutat);</a>
<a name="ln1952"> </a>
<a name="ln1953">            if (random2(10) &gt;= mdef.weight &amp;&amp; !is_slime_mutation(mutat))</a>
<a name="ln1954">                continue;</a>
<a name="ln1955"> </a>
<a name="ln1956">            const bool mismatch =</a>
<a name="ln1957">                (which_mutation == RANDOM_GOOD_MUTATION</a>
<a name="ln1958">                 &amp;&amp; MUT_BAD(mdef))</a>
<a name="ln1959">                    || (which_mutation == RANDOM_BAD_MUTATION</a>
<a name="ln1960">                        &amp;&amp; MUT_GOOD(mdef));</a>
<a name="ln1961"> </a>
<a name="ln1962">            if (mismatch &amp;&amp; (disallow_mismatch || !one_chance_in(10)))</a>
<a name="ln1963">                continue;</a>
<a name="ln1964"> </a>
<a name="ln1965">            if (you.get_base_mutation_level(mutat, true, false, true) == 0)</a>
<a name="ln1966">                continue; // No non-transient mutations in this category to cure</a>
<a name="ln1967"> </a>
<a name="ln1968">            break;</a>
<a name="ln1969">        }</a>
<a name="ln1970">    }</a>
<a name="ln1971">    else if (which_mutation == RANDOM_SLIME_MUTATION)</a>
<a name="ln1972">    {</a>
<a name="ln1973">        mutat = _delete_random_slime_mutation();</a>
<a name="ln1974"> </a>
<a name="ln1975">        if (mutat == NUM_MUTATIONS)</a>
<a name="ln1976">            return false;</a>
<a name="ln1977">    }</a>
<a name="ln1978"> </a>
<a name="ln1979">    return _delete_single_mutation_level(mutat, reason, false); // won't delete temp mutations</a>
<a name="ln1980">}</a>
<a name="ln1981"> </a>
<a name="ln1982">/*</a>
<a name="ln1983"> * Delete all (non-innate) mutations.</a>
<a name="ln1984"> *</a>
<a name="ln1985"> * If you really need to delete innate mutations as well, have a look at `change_species_to` in species.cc.</a>
<a name="ln1986"> * Changing species to human, for example, is a safe way to clear innate mutations entirely. For a</a>
<a name="ln1987"> * demonspawn, you could also use wizmode code to set the level to 1.</a>
<a name="ln1988"> *</a>
<a name="ln1989"> * @return  Whether the function found mutations to delete.</a>
<a name="ln1990"> */</a>
<a name="ln1991">bool delete_all_mutations(const string &amp;reason)</a>
<a name="ln1992">{</a>
<a name="ln1993">    for (int i = 0; i &lt; NUM_MUTATIONS; ++i)</a>
<a name="ln1994">    {</a>
<a name="ln1995">        while (_delete_single_mutation_level(static_cast&lt;mutation_type&gt;(i), reason, true))</a>
<a name="ln1996">            ;</a>
<a name="ln1997">    }</a>
<a name="ln1998">    ASSERT(you.attribute[ATTR_TEMP_MUTATIONS] == 0);</a>
<a name="ln1999">    ASSERT(you.how_mutated(false, true, false) == 0);</a>
<a name="ln2000">    you.attribute[ATTR_TEMP_MUT_XP] = 0;</a>
<a name="ln2001"> </a>
<a name="ln2002">    return !you.how_mutated();</a>
<a name="ln2003">}</a>
<a name="ln2004"> </a>
<a name="ln2005">/*</a>
<a name="ln2006"> * Delete all temporary mutations.</a>
<a name="ln2007"> *</a>
<a name="ln2008"> * @return  Whether the function found mutations to delete.</a>
<a name="ln2009"> */</a>
<a name="ln2010">bool delete_all_temp_mutations(const string &amp;reason)</a>
<a name="ln2011">{</a>
<a name="ln2012">    bool found = false;</a>
<a name="ln2013">    for (int i = 0; i &lt; NUM_MUTATIONS; ++i)</a>
<a name="ln2014">    {</a>
<a name="ln2015">        while (you.has_temporary_mutation(static_cast&lt;mutation_type&gt;(i)))</a>
<a name="ln2016">            if (_delete_single_mutation_level(static_cast&lt;mutation_type&gt;(i), reason, true))</a>
<a name="ln2017">                found = true;</a>
<a name="ln2018">    }</a>
<a name="ln2019">    // the rest of the bookkeeping is handled in _delete_single_mutation_level</a>
<a name="ln2020">    you.attribute[ATTR_TEMP_MUT_XP] = 0;</a>
<a name="ln2021">    return found;</a>
<a name="ln2022">}</a>
<a name="ln2023"> </a>
<a name="ln2024">/*</a>
<a name="ln2025"> * Delete a single level of a random temporary mutation.</a>
<a name="ln2026"> * This function does not itself do XP-related bookkeeping; see `temp_mutation_wanes()`.</a>
<a name="ln2027"> *</a>
<a name="ln2028"> * @return          Whether the function found a mutation to delete.</a>
<a name="ln2029"> */</a>
<a name="ln2030">bool delete_temp_mutation()</a>
<a name="ln2031">{</a>
<a name="ln2032">    if (you.attribute[ATTR_TEMP_MUTATIONS] &gt; 0)</a>
<a name="ln2033">    {</a>
<a name="ln2034">        mutation_type mutat = NUM_MUTATIONS;</a>
<a name="ln2035"> </a>
<a name="ln2036">        int count = 0;</a>
<a name="ln2037">        for (int i = 0; i &lt; NUM_MUTATIONS; i++)</a>
<a name="ln2038">            if (you.has_temporary_mutation(static_cast&lt;mutation_type&gt;(i)) &amp;&amp; one_chance_in(++count))</a>
<a name="ln2039">                mutat = static_cast&lt;mutation_type&gt;(i);</a>
<a name="ln2040"> </a>
<a name="ln2041">#if TAG_MAJOR_VERSION == 34</a>
<a name="ln2042">        // We had a brief period (between 0.14-a0-1589-g48c4fed and</a>
<a name="ln2043">        // 0.14-a0-1604-g40af2d8) where we corrupted attributes in transferred</a>
<a name="ln2044">        // games.</a>
<a name="ln2045">        if (mutat == NUM_MUTATIONS)</a>
<a name="ln2046">        {</a>
<a name="ln2047">            mprf(MSGCH_ERROR, &quot;Found no temp mutations, clearing.&quot;);</a>
<a name="ln2048">            you.attribute[ATTR_TEMP_MUTATIONS] = 0;</a>
<a name="ln2049">            return false;</a>
<a name="ln2050">        }</a>
<a name="ln2051">#else</a>
<a name="ln2052">        ASSERTM(mutat != NUM_MUTATIONS, &quot;Found no temp mutations, expected %d&quot;,</a>
<a name="ln2053">                                        you.attribute[ATTR_TEMP_MUTATIONS]);</a>
<a name="ln2054">#endif</a>
<a name="ln2055"> </a>
<a name="ln2056">        if (_delete_single_mutation_level(mutat, &quot;temp mutation expiry&quot;, true))</a>
<a name="ln2057">            return true;</a>
<a name="ln2058">    }</a>
<a name="ln2059"> </a>
<a name="ln2060">    return false;</a>
<a name="ln2061">}</a>
<a name="ln2062"> </a>
<a name="ln2063">const char* mutation_name(mutation_type mut, bool allow_category)</a>
<a name="ln2064">{</a>
<a name="ln2065">    if (allow_category &amp;&amp; mut &gt;= CATEGORY_MUTATIONS &amp;&amp; mut &lt; MUT_NON_MUTATION)</a>
<a name="ln2066">        return _get_category_mutation_def(mut).short_desc;</a>
<a name="ln2067"> </a>
<a name="ln2068">    // note -- this can produce crashes if fed invalid mutations, e.g. if allow_category is false and mut is a category mutation</a>
<a name="ln2069">    if (!_is_valid_mutation(mut))</a>
<a name="ln2070">        return nullptr;</a>
<a name="ln2071"> </a>
<a name="ln2072">    return _get_mutation_def(mut).short_desc;</a>
<a name="ln2073">}</a>
<a name="ln2074"> </a>
<a name="ln2075">const char* category_mutation_name(mutation_type mut)</a>
<a name="ln2076">{</a>
<a name="ln2077">    if (mut &lt; CATEGORY_MUTATIONS || mut &gt;= MUT_NON_MUTATION)</a>
<a name="ln2078">        return nullptr;</a>
<a name="ln2079">    return _get_category_mutation_def(mut).short_desc;</a>
<a name="ln2080">}</a>
<a name="ln2081"> </a>
<a name="ln2082">/*</a>
<a name="ln2083"> * Given some name, return a mutation type. Tries to match the short description as found in `mutation-data.h`.</a>
<a name="ln2084"> * If `partial_matches` is set, it will fill the vector with any partial matches it finds. If there is exactly one,</a>
<a name="ln2085"> * will return this mutation, otherwise, will fail.</a>
<a name="ln2086"> *</a>
<a name="ln2087"> * @param allow_category    whether to include category mutation types (e.g. RANDOM_GOOD)</a>
<a name="ln2088"> * @param partial_matches   an optional pointer to a vector, in case the consumer wants to do something</a>
<a name="ln2089"> *                          with the partial match results (e.g. show them to the user). If this is `nullptr`,</a>
<a name="ln2090"> *                          will accept only exact matches.</a>
<a name="ln2091"> *</a>
<a name="ln2092"> * @return the mutation type if succesful, otherwise NUM_MUTATIONS if it can't find a single match.</a>
<a name="ln2093"> */</a>
<a name="ln2094">mutation_type mutation_from_name(string name, bool allow_category, vector&lt;mutation_type&gt; *partial_matches)</a>
<a name="ln2095">{</a>
<a name="ln2096">    mutation_type mutat = NUM_MUTATIONS;</a>
<a name="ln2097"> </a>
<a name="ln2098">    string spec = lowercase_string(name);</a>
<a name="ln2099"> </a>
<a name="ln2100">    if (allow_category)</a>
<a name="ln2101">    {</a>
<a name="ln2102">        for (int i = CATEGORY_MUTATIONS; i &lt; MUT_NON_MUTATION; ++i)</a>
<a name="ln2103">        {</a>
<a name="ln2104">            mutation_type mut = static_cast&lt;mutation_type&gt;(i);</a>
<a name="ln2105">            const char* mut_name_c = category_mutation_name(mut);</a>
<a name="ln2106">            if (!mut_name_c)</a>
<a name="ln2107">                continue;</a>
<a name="ln2108">            const string mut_name = lowercase_string(mut_name_c);</a>
<a name="ln2109"> </a>
<a name="ln2110">            if (spec == mut_name)</a>
<a name="ln2111">                return mut; // note, won't fully populate partial_matches</a>
<a name="ln2112"> </a>
<a name="ln2113">            if (partial_matches &amp;&amp; strstr(mut_name.c_str(), spec.c_str()))</a>
<a name="ln2114">                partial_matches-&gt;push_back(mut);</a>
<a name="ln2115">        }</a>
<a name="ln2116">    }</a>
<a name="ln2117"> </a>
<a name="ln2118">    for (int i = 0; i &lt; NUM_MUTATIONS; ++i)</a>
<a name="ln2119">    {</a>
<a name="ln2120">        mutation_type mut = static_cast&lt;mutation_type&gt;(i);</a>
<a name="ln2121">        const char *mut_name_c = mutation_name(mut);</a>
<a name="ln2122">        if (!mut_name_c)</a>
<a name="ln2123">            continue;</a>
<a name="ln2124">        const string mut_name = lowercase_string(mut_name_c);</a>
<a name="ln2125"> </a>
<a name="ln2126">        if (spec == mut_name)</a>
<a name="ln2127">        {</a>
<a name="ln2128">            mutat = mut;</a>
<a name="ln2129">            break;</a>
<a name="ln2130">        }</a>
<a name="ln2131"> </a>
<a name="ln2132">        if (partial_matches &amp;&amp; strstr(mut_name.c_str(), spec.c_str()))</a>
<a name="ln2133">            partial_matches-&gt;push_back(mut);</a>
<a name="ln2134">    }</a>
<a name="ln2135"> </a>
<a name="ln2136">    // If only one matching mutation, use that.</a>
<a name="ln2137">    if (partial_matches &amp;&amp; mutat == NUM_MUTATIONS &amp;&amp; partial_matches-&gt;size() == 1)</a>
<a name="ln2138">        mutat = (*partial_matches)[0];</a>
<a name="ln2139">    return mutat;</a>
<a name="ln2140">}</a>
<a name="ln2141"> </a>
<a name="ln2142">/**</a>
<a name="ln2143"> * A summary of what the next level of a mutation does.</a>
<a name="ln2144"> *</a>
<a name="ln2145"> * @param mut   The mutation_type in question; e.g. MUT_FRAIL.</a>
<a name="ln2146"> * @return      The mutation's description, helpfully trimmed.</a>
<a name="ln2147"> *              e.g. &quot;you are frail (-10% HP)&quot;.</a>
<a name="ln2148"> */</a>
<a name="ln2149">string mut_upgrade_summary(mutation_type mut)</a>
<a name="ln2150">{</a>
<a name="ln2151">    if (!_is_valid_mutation(mut))</a>
<a name="ln2152">        return nullptr;</a>
<a name="ln2153"> </a>
<a name="ln2154">    string mut_desc =</a>
<a name="ln2155">        lowercase_first(mutation_desc(mut, you.mutation[mut] + 1));</a>
<a name="ln2156">    strip_suffix(mut_desc, &quot;.&quot;);</a>
<a name="ln2157">    return mut_desc;</a>
<a name="ln2158">}</a>
<a name="ln2159"> </a>
<a name="ln2160">int mutation_max_levels(mutation_type mut)</a>
<a name="ln2161">{</a>
<a name="ln2162">    if (!_is_valid_mutation(mut))</a>
<a name="ln2163">        return 0;</a>
<a name="ln2164"> </a>
<a name="ln2165">    return _get_mutation_def(mut).levels;</a>
<a name="ln2166">}</a>
<a name="ln2167"> </a>
<a name="ln2168">// Return a string describing the mutation.</a>
<a name="ln2169">// If colour is true, also add the colour annotation.</a>
<a name="ln2170">string mutation_desc(mutation_type mut, int level, bool colour,</a>
<a name="ln2171">        bool is_sacrifice)</a>
<a name="ln2172">{</a>
<a name="ln2173">    // Ignore the player's forms, etc.</a>
<a name="ln2174">    const bool ignore_player = (level != -1);</a>
<a name="ln2175"> </a>
<a name="ln2176">    const mutation_activity_type active = mutation_activity_level(mut);</a>
<a name="ln2177">    const bool partially_active = (active == mutation_activity_type::PARTIAL);</a>
<a name="ln2178">    const bool fully_inactive = (active == mutation_activity_type::INACTIVE);</a>
<a name="ln2179"> </a>
<a name="ln2180">    const bool temporary = you.has_temporary_mutation(mut);</a>
<a name="ln2181"> </a>
<a name="ln2182">    // level == -1 means default action of current level</a>
<a name="ln2183">    if (level == -1)</a>
<a name="ln2184">    {</a>
<a name="ln2185">        if (!fully_inactive)</a>
<a name="ln2186">            level = you.get_mutation_level(mut);</a>
<a name="ln2187">        else // give description of fully active mutation</a>
<a name="ln2188">            level = you.get_base_mutation_level(mut);</a>
<a name="ln2189">    }</a>
<a name="ln2190"> </a>
<a name="ln2191">    string result;</a>
<a name="ln2192"> </a>
<a name="ln2193">    const mutation_def&amp; mdef = _get_mutation_def(mut);</a>
<a name="ln2194"> </a>
<a name="ln2195">    if (mut == MUT_STRONG || mut == MUT_CLEVER</a>
<a name="ln2196">        || mut == MUT_AGILE || mut == MUT_WEAK</a>
<a name="ln2197">        || mut == MUT_DOPEY || mut == MUT_CLUMSY)</a>
<a name="ln2198">    {</a>
<a name="ln2199">        level = min(level, 2);</a>
<a name="ln2200">    }</a>
<a name="ln2201">    if (mut == MUT_ICEMAIL)</a>
<a name="ln2202">    {</a>
<a name="ln2203">        ostringstream ostr;</a>
<a name="ln2204">        ostr &lt;&lt; mdef.have[0] &lt;&lt; player_icemail_armour_class() &lt;&lt; &quot;)&quot;;</a>
<a name="ln2205">        result = ostr.str();</a>
<a name="ln2206">    }</a>
<a name="ln2207">    else if (mut == MUT_SANGUINE_ARMOUR)</a>
<a name="ln2208">    {</a>
<a name="ln2209">        ostringstream ostr;</a>
<a name="ln2210">        ostr &lt;&lt; mdef.have[level - 1] &lt;&lt; sanguine_armour_bonus() / 100 &lt;&lt; &quot;)&quot;;</a>
<a name="ln2211">        result = ostr.str();</a>
<a name="ln2212">    }</a>
<a name="ln2213">    else if (!ignore_player &amp;&amp; you.species == SP_FELID &amp;&amp; mut == MUT_CLAWS)</a>
<a name="ln2214">        result = &quot;You have sharp claws.&quot;;</a>
<a name="ln2215">    else if (have_passive(passive_t::no_mp_regen) &amp;&amp; mut == MUT_ANTIMAGIC_BITE)</a>
<a name="ln2216">        result = &quot;Your bite disrupts the magic of your enemies.&quot;;</a>
<a name="ln2217">    else if (result.empty() &amp;&amp; level &gt; 0)</a>
<a name="ln2218">        result = mdef.have[level - 1];</a>
<a name="ln2219"> </a>
<a name="ln2220">    if (!ignore_player)</a>
<a name="ln2221">    {</a>
<a name="ln2222">        if (fully_inactive)</a>
<a name="ln2223">        {</a>
<a name="ln2224">            result = &quot;((&quot; + result + &quot;))&quot;;</a>
<a name="ln2225">            ++_num_full_suppressed;</a>
<a name="ln2226">        }</a>
<a name="ln2227">        else if (partially_active)</a>
<a name="ln2228">        {</a>
<a name="ln2229">            result = &quot;(&quot; + result + &quot;)&quot;;</a>
<a name="ln2230">            ++_num_part_suppressed;</a>
<a name="ln2231">        }</a>
<a name="ln2232">    }</a>
<a name="ln2233"> </a>
<a name="ln2234">    if (temporary)</a>
<a name="ln2235">    {</a>
<a name="ln2236">        result = &quot;[&quot; + result + &quot;]&quot;;</a>
<a name="ln2237">        ++_num_transient;</a>
<a name="ln2238">    }</a>
<a name="ln2239"> </a>
<a name="ln2240">    if (colour)</a>
<a name="ln2241">    {</a>
<a name="ln2242">        const char* colourname = (MUT_BAD(mdef) ? &quot;red&quot; : &quot;lightgrey&quot;);</a>
<a name="ln2243">        const bool permanent   = you.has_innate_mutation(mut);</a>
<a name="ln2244"> </a>
<a name="ln2245">        if (permanent)</a>
<a name="ln2246">        {</a>
<a name="ln2247">            const bool demonspawn = (you.species == SP_DEMONSPAWN);</a>
<a name="ln2248">            const bool extra = you.get_base_mutation_level(mut, false, true, true) &gt; 0;</a>
<a name="ln2249"> </a>
<a name="ln2250">            if (fully_inactive || (mut == MUT_COLD_BLOODED &amp;&amp; player_res_cold(false) &gt; 0))</a>
<a name="ln2251">                colourname = &quot;darkgrey&quot;;</a>
<a name="ln2252">            else if (is_sacrifice)</a>
<a name="ln2253">                colourname = &quot;lightred&quot;;</a>
<a name="ln2254">            else if (partially_active)</a>
<a name="ln2255">                colourname = demonspawn ? &quot;yellow&quot;    : &quot;blue&quot;;</a>
<a name="ln2256">            else if (extra)</a>
<a name="ln2257">                colourname = demonspawn ? &quot;lightcyan&quot; : &quot;cyan&quot;;</a>
<a name="ln2258">            else</a>
<a name="ln2259">                colourname = demonspawn ? &quot;cyan&quot;      : &quot;lightblue&quot;;</a>
<a name="ln2260">        }</a>
<a name="ln2261">        else if (fully_inactive)</a>
<a name="ln2262">            colourname = &quot;darkgrey&quot;;</a>
<a name="ln2263">        else if (partially_active)</a>
<a name="ln2264">            colourname = &quot;brown&quot;;</a>
<a name="ln2265">        else if (you.form == transformation::appendage &amp;&amp; you.attribute[ATTR_APPENDAGE] == mut)</a>
<a name="ln2266">            colourname = &quot;lightgreen&quot;;</a>
<a name="ln2267">        else if (is_slime_mutation(mut))</a>
<a name="ln2268">            colourname = &quot;green&quot;;</a>
<a name="ln2269">        else if (temporary)</a>
<a name="ln2270">            colourname = (you.get_base_mutation_level(mut, true, false, true) &gt; 0) ?</a>
<a name="ln2271">                         &quot;lightmagenta&quot; : &quot;magenta&quot;;</a>
<a name="ln2272"> </a>
<a name="ln2273">        // Build the result</a>
<a name="ln2274">        ostringstream ostr;</a>
<a name="ln2275">        ostr &lt;&lt; '&lt;' &lt;&lt; colourname &lt;&lt; '&gt;' &lt;&lt; result</a>
<a name="ln2276">             &lt;&lt; &quot;&lt;/&quot; &lt;&lt; colourname &lt;&lt; '&gt;';</a>
<a name="ln2277">        result = ostr.str();</a>
<a name="ln2278">    }</a>
<a name="ln2279"> </a>
<a name="ln2280">    return result;</a>
<a name="ln2281">}</a>
<a name="ln2282"> </a>
<a name="ln2283">// The &quot;when&quot; numbers indicate the range of times in which the mutation tries</a>
<a name="ln2284">// to place itself; it will be approximately placed between when% and</a>
<a name="ln2285">// (when + 100)% of the way through the mutations. For example, you should</a>
<a name="ln2286">// usually get all your body slot mutations in the first 2/3 of your</a>
<a name="ln2287">// mutations and you should usually only start your tier 3 facet in the second</a>
<a name="ln2288">// half of your mutations. See _order_ds_mutations() for details.</a>
<a name="ln2289">static const facet_def _demon_facets[] =</a>
<a name="ln2290">{</a>
<a name="ln2291">    // Body Slot facets</a>
<a name="ln2292">    { 0, { MUT_CLAWS, MUT_CLAWS, MUT_CLAWS },</a>
<a name="ln2293">      { -33, -33, -33 } },</a>
<a name="ln2294">    { 0, { MUT_HORNS, MUT_HORNS, MUT_HORNS },</a>
<a name="ln2295">      { -33, -33, -33 } },</a>
<a name="ln2296">    { 0, { MUT_ANTENNAE, MUT_ANTENNAE, MUT_ANTENNAE },</a>
<a name="ln2297">      { -33, -33, -33 } },</a>
<a name="ln2298">    { 0, { MUT_HOOVES, MUT_HOOVES, MUT_HOOVES },</a>
<a name="ln2299">      { -33, -33, -33 } },</a>
<a name="ln2300">    { 0, { MUT_TALONS, MUT_TALONS, MUT_TALONS },</a>
<a name="ln2301">      { -33, -33, -33 } },</a>
<a name="ln2302">    // Scale mutations</a>
<a name="ln2303">    { 1, { MUT_DISTORTION_FIELD, MUT_DISTORTION_FIELD, MUT_DISTORTION_FIELD },</a>
<a name="ln2304">      { -33, -33, 0 } },</a>
<a name="ln2305">    { 1, { MUT_ICY_BLUE_SCALES, MUT_ICY_BLUE_SCALES, MUT_ICY_BLUE_SCALES },</a>
<a name="ln2306">      { -33, -33, 0 } },</a>
<a name="ln2307">    { 1, { MUT_IRIDESCENT_SCALES, MUT_IRIDESCENT_SCALES, MUT_IRIDESCENT_SCALES },</a>
<a name="ln2308">      { -33, -33, 0 } },</a>
<a name="ln2309">    { 1, { MUT_LARGE_BONE_PLATES, MUT_LARGE_BONE_PLATES, MUT_LARGE_BONE_PLATES },</a>
<a name="ln2310">      { -33, -33, 0 } },</a>
<a name="ln2311">    { 1, { MUT_MOLTEN_SCALES, MUT_MOLTEN_SCALES, MUT_MOLTEN_SCALES },</a>
<a name="ln2312">      { -33, -33, 0 } },</a>
<a name="ln2313">    { 1, { MUT_RUGGED_BROWN_SCALES, MUT_RUGGED_BROWN_SCALES,</a>
<a name="ln2314">           MUT_RUGGED_BROWN_SCALES },</a>
<a name="ln2315">      { -33, -33, 0 } },</a>
<a name="ln2316">    { 1, { MUT_SLIMY_GREEN_SCALES, MUT_SLIMY_GREEN_SCALES, MUT_SLIMY_GREEN_SCALES },</a>
<a name="ln2317">      { -33, -33, 0 } },</a>
<a name="ln2318">    { 1, { MUT_THIN_METALLIC_SCALES, MUT_THIN_METALLIC_SCALES,</a>
<a name="ln2319">        MUT_THIN_METALLIC_SCALES },</a>
<a name="ln2320">      { -33, -33, 0 } },</a>
<a name="ln2321">    { 1, { MUT_THIN_SKELETAL_STRUCTURE, MUT_THIN_SKELETAL_STRUCTURE,</a>
<a name="ln2322">           MUT_THIN_SKELETAL_STRUCTURE },</a>
<a name="ln2323">      { -33, -33, 0 } },</a>
<a name="ln2324">    { 1, { MUT_YELLOW_SCALES, MUT_YELLOW_SCALES, MUT_YELLOW_SCALES },</a>
<a name="ln2325">      { -33, -33, 0 } },</a>
<a name="ln2326">    { 1, { MUT_STURDY_FRAME, MUT_STURDY_FRAME, MUT_STURDY_FRAME },</a>
<a name="ln2327">      { -33, -33, 0 } },</a>
<a name="ln2328">    { 1, { MUT_SANGUINE_ARMOUR, MUT_SANGUINE_ARMOUR, MUT_SANGUINE_ARMOUR },</a>
<a name="ln2329">      { -33, -33, 0 } },</a>
<a name="ln2330">    // Tier 2 facets</a>
<a name="ln2331">    { 2, { MUT_HEAT_RESISTANCE, MUT_FLAME_CLOUD_IMMUNITY, MUT_IGNITE_BLOOD },</a>
<a name="ln2332">      { -33, 0, 0 } },</a>
<a name="ln2333">    { 2, { MUT_COLD_RESISTANCE, MUT_FREEZING_CLOUD_IMMUNITY, MUT_ICEMAIL },</a>
<a name="ln2334">      { -33, 0, 0 } },</a>
<a name="ln2335">    { 2, { MUT_POWERED_BY_DEATH, MUT_POWERED_BY_DEATH, MUT_POWERED_BY_DEATH },</a>
<a name="ln2336">      { -33, 0, 0 } },</a>
<a name="ln2337">    { 2, { MUT_DEMONIC_GUARDIAN, MUT_DEMONIC_GUARDIAN, MUT_DEMONIC_GUARDIAN },</a>
<a name="ln2338">      { -66, 17, 50 } },</a>
<a name="ln2339">    { 2, { MUT_NIGHTSTALKER, MUT_NIGHTSTALKER, MUT_NIGHTSTALKER },</a>
<a name="ln2340">      { -33, 0, 0 } },</a>
<a name="ln2341">    { 2, { MUT_SPINY, MUT_SPINY, MUT_SPINY },</a>
<a name="ln2342">      { -33, 0, 0 } },</a>
<a name="ln2343">    { 2, { MUT_POWERED_BY_PAIN, MUT_POWERED_BY_PAIN, MUT_POWERED_BY_PAIN },</a>
<a name="ln2344">      { -33, 0, 0 } },</a>
<a name="ln2345">    { 2, { MUT_ROT_IMMUNITY, MUT_FOUL_STENCH, MUT_FOUL_STENCH },</a>
<a name="ln2346">      { -33, 0, 0 } },</a>
<a name="ln2347">    { 2, { MUT_MANA_SHIELD, MUT_MANA_REGENERATION, MUT_MANA_LINK },</a>
<a name="ln2348">      { -33, 0, 0 } },</a>
<a name="ln2349">    // Tier 3 facets</a>
<a name="ln2350">    { 3, { MUT_HEAT_RESISTANCE, MUT_FLAME_CLOUD_IMMUNITY, MUT_HURL_DAMNATION },</a>
<a name="ln2351">      { 50, 50, 50 } },</a>
<a name="ln2352">    { 3, { MUT_COLD_RESISTANCE, MUT_FREEZING_CLOUD_IMMUNITY, MUT_PASSIVE_FREEZE },</a>
<a name="ln2353">      { 50, 50, 50 } },</a>
<a name="ln2354">    { 3, { MUT_ROBUST, MUT_ROBUST, MUT_ROBUST },</a>
<a name="ln2355">      { 50, 50, 50 } },</a>
<a name="ln2356">    { 3, { MUT_NEGATIVE_ENERGY_RESISTANCE, MUT_STOCHASTIC_TORMENT_RESISTANCE,</a>
<a name="ln2357">           MUT_BLACK_MARK },</a>
<a name="ln2358">      { 50, 50, 50 } },</a>
<a name="ln2359">    { 3, { MUT_AUGMENTATION, MUT_AUGMENTATION, MUT_AUGMENTATION },</a>
<a name="ln2360">      { 50, 50, 50 } },</a>
<a name="ln2361">};</a>
<a name="ln2362"> </a>
<a name="ln2363">static bool _works_at_tier(const facet_def&amp; facet, int tier)</a>
<a name="ln2364">{</a>
<a name="ln2365">    return facet.tier == tier;</a>
<a name="ln2366">}</a>
<a name="ln2367"> </a>
<a name="ln2368">typedef decltype(facet_def().muts) mut_array_t;</a>
<a name="ln2369">static bool _slot_is_unique(const mut_array_t &amp;mut,</a>
<a name="ln2370">                            set&lt;const facet_def *&gt; facets_used)</a>
<a name="ln2371">{</a>
<a name="ln2372">    set&lt;equipment_type&gt; eq;</a>
<a name="ln2373"> </a>
<a name="ln2374">    // find the equipment slot(s) used by mut</a>
<a name="ln2375">    for (const body_facet_def &amp;facet : _body_facets)</a>
<a name="ln2376">    {</a>
<a name="ln2377">        for (mutation_type slotmut : mut)</a>
<a name="ln2378">            if (facet.mut == slotmut)</a>
<a name="ln2379">                eq.insert(facet.eq);</a>
<a name="ln2380">    }</a>
<a name="ln2381"> </a>
<a name="ln2382">    if (eq.empty())</a>
<a name="ln2383">        return true;</a>
<a name="ln2384"> </a>
<a name="ln2385">    for (const facet_def *used : facets_used)</a>
<a name="ln2386">    {</a>
<a name="ln2387">        for (const body_facet_def &amp;facet : _body_facets)</a>
<a name="ln2388">            if (facet.mut == used-&gt;muts[0] &amp;&amp; eq.count(facet.eq))</a>
<a name="ln2389">                return false;</a>
<a name="ln2390">    }</a>
<a name="ln2391"> </a>
<a name="ln2392">    return true;</a>
<a name="ln2393">}</a>
<a name="ln2394"> </a>
<a name="ln2395">static vector&lt;demon_mutation_info&gt; _select_ds_mutations()</a>
<a name="ln2396">{</a>
<a name="ln2397">    int ct_of_tier[] = { 1, 1, 2, 1 };</a>
<a name="ln2398">    // 1 in 10 chance to create a monstrous set</a>
<a name="ln2399">    if (one_chance_in(10))</a>
<a name="ln2400">    {</a>
<a name="ln2401">        ct_of_tier[0] = 3;</a>
<a name="ln2402">        ct_of_tier[1] = 0;</a>
<a name="ln2403">    }</a>
<a name="ln2404"> </a>
<a name="ln2405">try_again:</a>
<a name="ln2406">    vector&lt;demon_mutation_info&gt; ret;</a>
<a name="ln2407"> </a>
<a name="ln2408">    ret.clear();</a>
<a name="ln2409">    int absfacet = 0;</a>
<a name="ln2410">    int ice_elemental = 0;</a>
<a name="ln2411">    int fire_elemental = 0;</a>
<a name="ln2412">    int cloud_producing = 0;</a>
<a name="ln2413"> </a>
<a name="ln2414">    set&lt;const facet_def *&gt; facets_used;</a>
<a name="ln2415"> </a>
<a name="ln2416">    for (int tier = ARRAYSZ(ct_of_tier) - 1; tier &gt;= 0; --tier)</a>
<a name="ln2417">    {</a>
<a name="ln2418">        for (int nfacet = 0; nfacet &lt; ct_of_tier[tier]; ++nfacet)</a>
<a name="ln2419">        {</a>
<a name="ln2420">            const facet_def* next_facet;</a>
<a name="ln2421"> </a>
<a name="ln2422">            do</a>
<a name="ln2423">            {</a>
<a name="ln2424">                next_facet = &amp;RANDOM_ELEMENT(_demon_facets);</a>
<a name="ln2425">            }</a>
<a name="ln2426">            while (!_works_at_tier(*next_facet, tier)</a>
<a name="ln2427">                   || facets_used.count(next_facet)</a>
<a name="ln2428">                   || !_slot_is_unique(next_facet-&gt;muts, facets_used));</a>
<a name="ln2429"> </a>
<a name="ln2430">            facets_used.insert(next_facet);</a>
<a name="ln2431"> </a>
<a name="ln2432">            for (int i = 0; i &lt; 3; ++i)</a>
<a name="ln2433">            {</a>
<a name="ln2434">                mutation_type m = next_facet-&gt;muts[i];</a>
<a name="ln2435"> </a>
<a name="ln2436">                ret.emplace_back(m, next_facet-&gt;when[i], absfacet);</a>
<a name="ln2437"> </a>
<a name="ln2438">                if (m == MUT_COLD_RESISTANCE)</a>
<a name="ln2439">                    ice_elemental++;</a>
<a name="ln2440"> </a>
<a name="ln2441">                if (m == MUT_HEAT_RESISTANCE)</a>
<a name="ln2442">                    fire_elemental++;</a>
<a name="ln2443"> </a>
<a name="ln2444">                if (m == MUT_ROT_IMMUNITY || m == MUT_IGNITE_BLOOD)</a>
<a name="ln2445">                    cloud_producing++;</a>
<a name="ln2446">            }</a>
<a name="ln2447"> </a>
<a name="ln2448">            ++absfacet;</a>
<a name="ln2449">        }</a>
<a name="ln2450">    }</a>
<a name="ln2451"> </a>
<a name="ln2452">    if (ice_elemental + fire_elemental &gt; 1)</a>
<a name="ln2453">        goto try_again;</a>
<a name="ln2454"> </a>
<a name="ln2455">    if (cloud_producing &gt; 1)</a>
<a name="ln2456">        goto try_again;</a>
<a name="ln2457"> </a>
<a name="ln2458">    return ret;</a>
<a name="ln2459">}</a>
<a name="ln2460"> </a>
<a name="ln2461">static vector&lt;mutation_type&gt;</a>
<a name="ln2462">_order_ds_mutations(vector&lt;demon_mutation_info&gt; muts)</a>
<a name="ln2463">{</a>
<a name="ln2464">    vector&lt;mutation_type&gt; out;</a>
<a name="ln2465">    vector&lt;int&gt; times;</a>
<a name="ln2466">    FixedVector&lt;int, 1000&gt; time_slots;</a>
<a name="ln2467">    time_slots.init(-1);</a>
<a name="ln2468">    for (unsigned int i = 0; i &lt; muts.size(); i++)</a>
<a name="ln2469">    {</a>
<a name="ln2470">        int first = max(0, muts[i].when);</a>
<a name="ln2471">        int last = min(100, muts[i].when + 100);</a>
<a name="ln2472">        int k;</a>
<a name="ln2473">        do</a>
<a name="ln2474">        {</a>
<a name="ln2475">            k = 10 * first + random2(10 * (last - first));</a>
<a name="ln2476">        }</a>
<a name="ln2477">        while (time_slots[k] &gt;= 0);</a>
<a name="ln2478">        time_slots[k] = i;</a>
<a name="ln2479">        times.push_back(k);</a>
<a name="ln2480"> </a>
<a name="ln2481">        // Don't reorder mutations within a facet.</a>
<a name="ln2482">        for (unsigned int j = i; j &gt; 0; j--)</a>
<a name="ln2483">        {</a>
<a name="ln2484">            if (muts[j].facet == muts[j-1].facet &amp;&amp; times[j] &lt; times[j-1])</a>
<a name="ln2485">            {</a>
<a name="ln2486">                int earlier = times[j];</a>
<a name="ln2487">                int later = times[j-1];</a>
<a name="ln2488">                time_slots[earlier] = j-1;</a>
<a name="ln2489">                time_slots[later] = j;</a>
<a name="ln2490">                times[j-1] = earlier;</a>
<a name="ln2491">                times[j] = later;</a>
<a name="ln2492">            }</a>
<a name="ln2493">            else</a>
<a name="ln2494">                break;</a>
<a name="ln2495">        }</a>
<a name="ln2496">    }</a>
<a name="ln2497"> </a>
<a name="ln2498">    for (int time = 0; time &lt; 1000; time++)</a>
<a name="ln2499">        if (time_slots[time] &gt;= 0)</a>
<a name="ln2500">            out.push_back(muts[time_slots[time]].mut);</a>
<a name="ln2501"> </a>
<a name="ln2502">    return out;</a>
<a name="ln2503">}</a>
<a name="ln2504"> </a>
<a name="ln2505">static vector&lt;player::demon_trait&gt;</a>
<a name="ln2506">_schedule_ds_mutations(vector&lt;mutation_type&gt; muts)</a>
<a name="ln2507">{</a>
<a name="ln2508">    list&lt;mutation_type&gt; muts_left(muts.begin(), muts.end());</a>
<a name="ln2509"> </a>
<a name="ln2510">    list&lt;int&gt; slots_left;</a>
<a name="ln2511"> </a>
<a name="ln2512">    vector&lt;player::demon_trait&gt; out;</a>
<a name="ln2513"> </a>
<a name="ln2514">    for (int level = 2; level &lt;= 27; ++level)</a>
<a name="ln2515">        slots_left.push_back(level);</a>
<a name="ln2516"> </a>
<a name="ln2517">    while (!muts_left.empty())</a>
<a name="ln2518">    {</a>
<a name="ln2519">        if (out.empty() // always give a mutation at XL 2</a>
<a name="ln2520">            || x_chance_in_y(muts_left.size(), slots_left.size()))</a>
<a name="ln2521">        {</a>
<a name="ln2522">            player::demon_trait dt;</a>
<a name="ln2523"> </a>
<a name="ln2524">            dt.level_gained = slots_left.front();</a>
<a name="ln2525">            dt.mutation     = muts_left.front();</a>
<a name="ln2526"> </a>
<a name="ln2527">            dprf(&quot;Demonspawn will gain %s at level %d&quot;,</a>
<a name="ln2528">                    _get_mutation_def(dt.mutation).short_desc, dt.level_gained);</a>
<a name="ln2529"> </a>
<a name="ln2530">            out.push_back(dt);</a>
<a name="ln2531"> </a>
<a name="ln2532">            muts_left.pop_front();</a>
<a name="ln2533">        }</a>
<a name="ln2534">        slots_left.pop_front();</a>
<a name="ln2535">    }</a>
<a name="ln2536"> </a>
<a name="ln2537">    return out;</a>
<a name="ln2538">}</a>
<a name="ln2539"> </a>
<a name="ln2540">void roll_demonspawn_mutations()</a>
<a name="ln2541">{</a>
<a name="ln2542">    // intentionally create the subgenerator either way, so that this has the</a>
<a name="ln2543">    // same impact on the current main rng for all chars.</a>
<a name="ln2544">    rng::subgenerator ds_rng;</a>
<a name="ln2545"> </a>
<a name="ln2546">    if (you.species != SP_DEMONSPAWN)</a>
<a name="ln2547">        return;</a>
<a name="ln2548">    you.demonic_traits = _schedule_ds_mutations(</a>
<a name="ln2549">                         _order_ds_mutations(</a>
<a name="ln2550">                         _select_ds_mutations()));</a>
<a name="ln2551">}</a>
<a name="ln2552"> </a>
<a name="ln2553">bool perma_mutate(mutation_type which_mut, int how_much, const string &amp;reason)</a>
<a name="ln2554">{</a>
<a name="ln2555">    ASSERT(_is_valid_mutation(which_mut));</a>
<a name="ln2556"> </a>
<a name="ln2557">    int cap = get_mutation_cap(which_mut);</a>
<a name="ln2558">    how_much = min(how_much, cap);</a>
<a name="ln2559"> </a>
<a name="ln2560">    int rc = 1;</a>
<a name="ln2561">    // clear out conflicting mutations</a>
<a name="ln2562">    int count = 0;</a>
<a name="ln2563">    while (rc == 1 &amp;&amp; ++count &lt; 100)</a>
<a name="ln2564">        rc = _handle_conflicting_mutations(which_mut, true, reason);</a>
<a name="ln2565">    ASSERT(rc == 0);</a>
<a name="ln2566"> </a>
<a name="ln2567">    int levels = 0;</a>
<a name="ln2568">    while (how_much-- &gt; 0)</a>
<a name="ln2569">    {</a>
<a name="ln2570">        dprf(&quot;Perma Mutate %s: cap %d, total %d, innate %d&quot;, mutation_name(which_mut), cap,</a>
<a name="ln2571">            you.get_base_mutation_level(which_mut), you.get_innate_mutation_level(which_mut));</a>
<a name="ln2572">        if (you.get_base_mutation_level(which_mut, true, false, false) &lt; cap</a>
<a name="ln2573">            &amp;&amp; !mutate(which_mut, reason, false, true, false, false, MUTCLASS_INNATE))</a>
<a name="ln2574">        {</a>
<a name="ln2575">            dprf(&quot;Innate mutation failed.&quot;);</a>
<a name="ln2576">            break;</a>
<a name="ln2577">        }</a>
<a name="ln2578">        levels++;</a>
<a name="ln2579">    }</a>
<a name="ln2580"> </a>
<a name="ln2581">#ifdef DEBUG</a>
<a name="ln2582">    // don't validate permamutate directly on level regain; this is so that wizmode level change</a>
<a name="ln2583">    // functions can work correctly.</a>
<a name="ln2584">    if (you.experience_level &gt;= you.max_level)</a>
<a name="ln2585">        validate_mutations(false);</a>
<a name="ln2586">#endif</a>
<a name="ln2587">    return levels &gt; 0;</a>
<a name="ln2588">}</a>
<a name="ln2589"> </a>
<a name="ln2590">bool temp_mutate(mutation_type which_mut, const string &amp;reason)</a>
<a name="ln2591">{</a>
<a name="ln2592">    return mutate(which_mut, reason, false, false, false, false, MUTCLASS_TEMPORARY);</a>
<a name="ln2593">}</a>
<a name="ln2594"> </a>
<a name="ln2595">int temp_mutation_roll()</a>
<a name="ln2596">{</a>
<a name="ln2597">    return min(you.experience_level, 17) * (500 + roll_dice(5, 500)) / 17;</a>
<a name="ln2598">}</a>
<a name="ln2599"> </a>
<a name="ln2600">bool temp_mutation_wanes()</a>
<a name="ln2601">{</a>
<a name="ln2602">    const int starting_tmuts = you.attribute[ATTR_TEMP_MUTATIONS];</a>
<a name="ln2603">    if (starting_tmuts == 0)</a>
<a name="ln2604">        return false;</a>
<a name="ln2605"> </a>
<a name="ln2606">    int num_remove = min(starting_tmuts,</a>
<a name="ln2607">        max(starting_tmuts * 5 / 12 - random2(3),</a>
<a name="ln2608">        1 + random2(3)));</a>
<a name="ln2609"> </a>
<a name="ln2610">    mprf(MSGCH_DURATION, &quot;You feel the corruption within you wane %s.&quot;,</a>
<a name="ln2611">        (num_remove &gt;= starting_tmuts ? &quot;completely&quot; : &quot;somewhat&quot;));</a>
<a name="ln2612"> </a>
<a name="ln2613">    for (int i = 0; i &lt; num_remove; ++i)</a>
<a name="ln2614">        delete_temp_mutation(); // chooses randomly</a>
<a name="ln2615"> </a>
<a name="ln2616">    if (you.attribute[ATTR_TEMP_MUTATIONS] &gt; 0)</a>
<a name="ln2617">        you.attribute[ATTR_TEMP_MUT_XP] += temp_mutation_roll();</a>
<a name="ln2618">    else</a>
<a name="ln2619">        you.attribute[ATTR_TEMP_MUT_XP] = 0;</a>
<a name="ln2620">    ASSERT(you.attribute[ATTR_TEMP_MUTATIONS] &lt; starting_tmuts);</a>
<a name="ln2621">    return true;</a>
<a name="ln2622">}</a>
<a name="ln2623"> </a>
<a name="ln2624">/**</a>
<a name="ln2625"> * How mutated is the player?</a>
<a name="ln2626"> *</a>
<a name="ln2627"> * @param innate Whether to count innate mutations (default false).</a>
<a name="ln2628"> * @param levels Whether to add up mutation levels, as opposed to just counting number of mutations (default false).</a>
<a name="ln2629"> * @param temp Whether to count temporary mutations (default true).</a>
<a name="ln2630"> * @return Either the number of matching mutations, or the sum of their</a>
<a name="ln2631"> *         levels, depending on \c levels</a>
<a name="ln2632"> */</a>
<a name="ln2633">int player::how_mutated(bool innate, bool levels, bool temp) const</a>
<a name="ln2634">{</a>
<a name="ln2635">    int result = 0;</a>
<a name="ln2636"> </a>
<a name="ln2637">    for (int i = 0; i &lt; NUM_MUTATIONS; ++i)</a>
<a name="ln2638">    {</a>
<a name="ln2639">        if (you.mutation[i])</a>
<a name="ln2640">        {</a>
<a name="ln2641">            const int mut_level = get_base_mutation_level(static_cast&lt;mutation_type&gt;(i), innate, temp);</a>
<a name="ln2642"> </a>
<a name="ln2643">            if (levels)</a>
<a name="ln2644">                result += mut_level;</a>
<a name="ln2645">            else if (mut_level &gt; 0)</a>
<a name="ln2646">                result++;</a>
<a name="ln2647">        }</a>
<a name="ln2648">        if (you.species == SP_DEMONSPAWN</a>
<a name="ln2649">            &amp;&amp; you.props.exists(&quot;num_sacrifice_muts&quot;))</a>
<a name="ln2650">        {</a>
<a name="ln2651">            result -= you.props[&quot;num_sacrifice_muts&quot;].get_int();</a>
<a name="ln2652">        }</a>
<a name="ln2653">    }</a>
<a name="ln2654"> </a>
<a name="ln2655">    return result;</a>
<a name="ln2656">}</a>
<a name="ln2657"> </a>
<a name="ln2658">// Return whether current tension is balanced</a>
<a name="ln2659">static bool _balance_demonic_guardian()</a>
<a name="ln2660">{</a>
<a name="ln2661">    // if tension is unfavourably high, perhaps another guardian should spawn</a>
<a name="ln2662">    const int mutlevel = you.get_mutation_level(MUT_DEMONIC_GUARDIAN);</a>
<a name="ln2663">    const int tension = get_tension(GOD_NO_GOD);</a>
<a name="ln2664">    return tension*3/4 &lt;= mutlevel*6 + random2(mutlevel*mutlevel*2);</a>
<a name="ln2665">}</a>
<a name="ln2666"> </a>
<a name="ln2667">// Primary function to handle and balance demonic guardians, if the tension</a>
<a name="ln2668">// is unfavourably high and a guardian was not recently spawned, a new guardian</a>
<a name="ln2669">// will be made, if tension is below a threshold (determined by the mutations</a>
<a name="ln2670">// level and a bit of randomness), guardians may be dismissed in</a>
<a name="ln2671">// _balance_demonic_guardian()</a>
<a name="ln2672">void check_demonic_guardian()</a>
<a name="ln2673">{</a>
<a name="ln2674">    // Players hated by all monsters don't get guardians, so that they aren't</a>
<a name="ln2675">    // swarmed by hostile executioners whenever things get rough.</a>
<a name="ln2676">    if (you.get_mutation_level(MUT_NO_LOVE))</a>
<a name="ln2677">        return;</a>
<a name="ln2678"> </a>
<a name="ln2679">    const int mutlevel = you.get_mutation_level(MUT_DEMONIC_GUARDIAN);</a>
<a name="ln2680"> </a>
<a name="ln2681">    if (!_balance_demonic_guardian() &amp;&amp;</a>
<a name="ln2682">        you.duration[DUR_DEMONIC_GUARDIAN] == 0)</a>
<a name="ln2683">    {</a>
<a name="ln2684">        monster_type mt;</a>
<a name="ln2685"> </a>
<a name="ln2686">        switch (mutlevel)</a>
<a name="ln2687">        {</a>
<a name="ln2688">        case 1:</a>
<a name="ln2689">            mt = random_choose(MONS_QUASIT, MONS_WHITE_IMP, MONS_UFETUBUS,</a>
<a name="ln2690">                               MONS_IRON_IMP, MONS_SHADOW_IMP);</a>
<a name="ln2691">            break;</a>
<a name="ln2692">        case 2:</a>
<a name="ln2693">            mt = random_choose(MONS_ORANGE_DEMON, MONS_ICE_DEVIL,</a>
<a name="ln2694">                               MONS_SOUL_EATER, MONS_SMOKE_DEMON,</a>
<a name="ln2695">                               MONS_SIXFIRHY);</a>
<a name="ln2696">            break;</a>
<a name="ln2697">        case 3:</a>
<a name="ln2698">            mt = random_choose(MONS_EXECUTIONER, MONS_BALRUG, MONS_REAPER,</a>
<a name="ln2699">                               MONS_CACODEMON, MONS_LOROCYPROCA);</a>
<a name="ln2700">            break;</a>
<a name="ln2701">        default:</a>
<a name="ln2702">            die(&quot;Invalid demonic guardian level: %d&quot;, mutlevel);</a>
<a name="ln2703">        }</a>
<a name="ln2704"> </a>
<a name="ln2705">        monster *guardian = create_monster(</a>
<a name="ln2706">            mgen_data(mt, BEH_FRIENDLY, you.pos(), MHITYOU,</a>
<a name="ln2707">                      MG_FORCE_BEH | MG_AUTOFOE).set_summoned(&amp;you, 2, 0));</a>
<a name="ln2708"> </a>
<a name="ln2709">        if (!guardian)</a>
<a name="ln2710">            return;</a>
<a name="ln2711"> </a>
<a name="ln2712">        guardian-&gt;flags |= MF_NO_REWARD;</a>
<a name="ln2713">        guardian-&gt;flags |= MF_DEMONIC_GUARDIAN;</a>
<a name="ln2714"> </a>
<a name="ln2715">        guardian-&gt;add_ench(ENCH_LIFE_TIMER);</a>
<a name="ln2716"> </a>
<a name="ln2717">        // no more guardians for mutlevel+1 to mutlevel+20 turns</a>
<a name="ln2718">        you.duration[DUR_DEMONIC_GUARDIAN] = 10*(mutlevel + random2(20));</a>
<a name="ln2719">    }</a>
<a name="ln2720">}</a>
<a name="ln2721"> </a>
<a name="ln2722">/**</a>
<a name="ln2723"> * Update the map knowledge based on any monster detection sources the player</a>
<a name="ln2724"> * has.</a>
<a name="ln2725"> */</a>
<a name="ln2726">void check_monster_detect()</a>
<a name="ln2727">{</a>
<a name="ln2728">    int radius = player_monster_detect_radius();</a>
<a name="ln2729">    if (radius &lt;= 0)</a>
<a name="ln2730">        return;</a>
<a name="ln2731"> </a>
<a name="ln2732">    for (radius_iterator ri(you.pos(), radius, C_SQUARE); ri; ++ri)</a>
<a name="ln2733">    {</a>
<a name="ln2734">        monster* mon = monster_at(*ri);</a>
<a name="ln2735">        map_cell&amp; cell = env.map_knowledge(*ri);</a>
<a name="ln2736">        if (!mon)</a>
<a name="ln2737">        {</a>
<a name="ln2738">            if (cell.detected_monster())</a>
<a name="ln2739">                cell.clear_monster();</a>
<a name="ln2740">            continue;</a>
<a name="ln2741">        }</a>
<a name="ln2742">        if (mons_is_firewood(*mon))</a>
<a name="ln2743">            continue;</a>
<a name="ln2744"> </a>
<a name="ln2745">        // [ds] If the PC remembers the correct monster at this</a>
<a name="ln2746">        // square, don't trample it with MONS_SENSED. Forgetting</a>
<a name="ln2747">        // legitimate monster memory affects travel, which can</a>
<a name="ln2748">        // path around mimics correctly only if it can actually</a>
<a name="ln2749">        // *see* them in monster memory -- overwriting the mimic</a>
<a name="ln2750">        // with MONS_SENSED causes travel to bounce back and</a>
<a name="ln2751">        // forth, since every time it leaves LOS of the mimic, the</a>
<a name="ln2752">        // mimic is forgotten (replaced by MONS_SENSED).</a>
<a name="ln2753">        // XXX: since mimics were changed, is this safe to remove now?</a>
<a name="ln2754">        const monster_type remembered_monster = cell.monster();</a>
<a name="ln2755">        if (remembered_monster == mon-&gt;type)</a>
<a name="ln2756">            continue;</a>
<a name="ln2757"> </a>
<a name="ln2758">        const monster_type mc = mon-&gt;friendly() ? MONS_SENSED_FRIENDLY</a>
<a name="ln2759">            : have_passive(passive_t::detect_montier)</a>
<a name="ln2760">            ? ash_monster_tier(mon)</a>
<a name="ln2761">            : MONS_SENSED;</a>
<a name="ln2762"> </a>
<a name="ln2763">        env.map_knowledge(*ri).set_detected_monster(mc);</a>
<a name="ln2764"> </a>
<a name="ln2765">        // Don't bother warning the player (or interrupting autoexplore) about</a>
<a name="ln2766">        // friendly monsters or those known to be easy, or those recently</a>
<a name="ln2767">        // warned about</a>
<a name="ln2768">        if (mc == MONS_SENSED_TRIVIAL || mc == MONS_SENSED_EASY</a>
<a name="ln2769">            || mc == MONS_SENSED_FRIENDLY || mon-&gt;wont_attack()</a>
<a name="ln2770">            || testbits(mon-&gt;flags, MF_SENSED))</a>
<a name="ln2771">        {</a>
<a name="ln2772">            continue;</a>
<a name="ln2773">        }</a>
<a name="ln2774"> </a>
<a name="ln2775">        for (radius_iterator ri2(mon-&gt;pos(), 2, C_SQUARE); ri2; ++ri2)</a>
<a name="ln2776">        {</a>
<a name="ln2777">            if (you.see_cell(*ri2))</a>
<a name="ln2778">            {</a>
<a name="ln2779">                mon-&gt;flags |= MF_SENSED;</a>
<a name="ln2780">                interrupt_activity(activity_interrupt::sense_monster);</a>
<a name="ln2781">                break;</a>
<a name="ln2782">            }</a>
<a name="ln2783">        }</a>
<a name="ln2784">    }</a>
<a name="ln2785">}</a>
<a name="ln2786"> </a>
<a name="ln2787">int augmentation_amount()</a>
<a name="ln2788">{</a>
<a name="ln2789">    int amount = 0;</a>
<a name="ln2790">    const int level = you.get_mutation_level(MUT_AUGMENTATION);</a>
<a name="ln2791"> </a>
<a name="ln2792">    for (int i = 0; i &lt; level; ++i)</a>
<a name="ln2793">    {</a>
<a name="ln2794">        if (you.hp &gt;= ((i + level) * you.hp_max) / (2 * level))</a>
<a name="ln2795">            amount++;</a>
<a name="ln2796">    }</a>
<a name="ln2797"> </a>
<a name="ln2798">    return amount;</a>
<a name="ln2799">}</a>
<a name="ln2800"> </a>
<a name="ln2801">void reset_powered_by_death_duration()</a>
<a name="ln2802">{</a>
<a name="ln2803">    const int pbd_dur = random_range(2, 5);</a>
<a name="ln2804">    you.set_duration(DUR_POWERED_BY_DEATH, pbd_dur);</a>
<a name="ln2805">}</a>

</code></pre>
<div class="balloon" rel="261"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v1016/" target="_blank">V1016</a> Expression 'mut >= 0' is always true.</p></div>
<div class="balloon" rel="1948"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v768/" target="_blank">V768</a> The variable 'mutat' is of enum type. It is odd that it is used as a variable of a Boolean-type.</p></div>
<div class="balloon" rel="2217"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v560/" target="_blank">V560</a> A part of conditional expression is always true: result.empty().</p></div>

<link rel="stylesheet" href="highlight.css">
<script src="highlight.pack.js"></script>
<script src="highlightjs-line-numbers.js"></script>
<script>hljs.initHighlightingOnLoad();</script>
<script>hljs.initLineNumbersOnLoad();</script>
<script>
  $(document).ready(function() {
      $('.balloon').each(function () {
          var bl = $(this);
          var line = bl.attr('rel');
          var text = $('a[name="ln'+line+'"]').text();

          var space_count = 0;
          for(var i = 0; i<text.length; i++){
              var char = text[i];
              if((char !== ' ')&&(char !== '\t'))break;
              if(char === '\t')space_count++;
              space_count++;
          }

          bl.css('margin-left', space_count*8);
          $('a[name="ln'+line+'"]').after(bl);
      });

      window.location = window.location;
  });
</script>
</body>
</html>
