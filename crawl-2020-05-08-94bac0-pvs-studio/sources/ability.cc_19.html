
<html>
<head>

  <meta http-equiv="Content-Type" content="text/html; charset=US-ASCII" />
  <title>ability.cc</title>

  <link rel="stylesheet" href="../style.css"/>
  <script src="../jquery-3.2.1.min.js"></script>
</head>
<body>

<pre><code class = "cpp">
<a name="ln1">/**</a>
<a name="ln2"> * @file</a>
<a name="ln3"> * @brief Functions related to special abilities.</a>
<a name="ln4">**/</a>
<a name="ln5"> </a>
<a name="ln6">#include &quot;AppHdr.h&quot;</a>
<a name="ln7"> </a>
<a name="ln8">#include &quot;ability.h&quot;</a>
<a name="ln9"> </a>
<a name="ln10">#include &lt;cctype&gt;</a>
<a name="ln11">#include &lt;cmath&gt;</a>
<a name="ln12">#include &lt;cstdio&gt;</a>
<a name="ln13">#include &lt;cstring&gt;</a>
<a name="ln14">#include &lt;iomanip&gt;</a>
<a name="ln15">#include &lt;sstream&gt;</a>
<a name="ln16"> </a>
<a name="ln17">#include &quot;abyss.h&quot;</a>
<a name="ln18">#include &quot;areas.h&quot;</a>
<a name="ln19">#include &quot;art-enum.h&quot;</a>
<a name="ln20">#include &quot;branch.h&quot;</a>
<a name="ln21">#include &quot;chardump.h&quot;</a>
<a name="ln22">#include &quot;cleansing-flame-source-type.h&quot;</a>
<a name="ln23">#include &quot;cloud.h&quot;</a>
<a name="ln24">#include &quot;coordit.h&quot;</a>
<a name="ln25">#include &quot;database.h&quot;</a>
<a name="ln26">#include &quot;decks.h&quot;</a>
<a name="ln27">#include &quot;delay.h&quot;</a>
<a name="ln28">#include &quot;describe.h&quot;</a>
<a name="ln29">#include &quot;directn.h&quot;</a>
<a name="ln30">#include &quot;dungeon.h&quot;</a>
<a name="ln31">#include &quot;evoke.h&quot;</a>
<a name="ln32">#include &quot;exercise.h&quot;</a>
<a name="ln33">#include &quot;fight.h&quot;</a>
<a name="ln34">#include &quot;food.h&quot;</a>
<a name="ln35">#include &quot;god-abil.h&quot;</a>
<a name="ln36">#include &quot;god-companions.h&quot;</a>
<a name="ln37">#include &quot;god-conduct.h&quot;</a>
<a name="ln38">#include &quot;hints.h&quot;</a>
<a name="ln39">#include &quot;invent.h&quot;</a>
<a name="ln40">#include &quot;item-prop.h&quot;</a>
<a name="ln41">#include &quot;items.h&quot;</a>
<a name="ln42">#include &quot;item-use.h&quot;</a>
<a name="ln43">#include &quot;level-state-type.h&quot;</a>
<a name="ln44">#include &quot;libutil.h&quot;</a>
<a name="ln45">#include &quot;macro.h&quot;</a>
<a name="ln46">#include &quot;maps.h&quot;</a>
<a name="ln47">#include &quot;menu.h&quot;</a>
<a name="ln48">#include &quot;message.h&quot;</a>
<a name="ln49">#include &quot;mon-place.h&quot;</a>
<a name="ln50">#include &quot;mutation.h&quot;</a>
<a name="ln51">#include &quot;notes.h&quot;</a>
<a name="ln52">#include &quot;options.h&quot;</a>
<a name="ln53">#include &quot;output.h&quot;</a>
<a name="ln54">#include &quot;player-stats.h&quot;</a>
<a name="ln55">#include &quot;potion.h&quot;</a>
<a name="ln56">#include &quot;prompt.h&quot;</a>
<a name="ln57">#include &quot;religion.h&quot;</a>
<a name="ln58">#include &quot;skills.h&quot;</a>
<a name="ln59">#include &quot;spl-book.h&quot;</a>
<a name="ln60">#include &quot;spl-cast.h&quot;</a>
<a name="ln61">#include &quot;spl-clouds.h&quot;</a>
<a name="ln62">#include &quot;spl-damage.h&quot;</a>
<a name="ln63">#include &quot;spl-goditem.h&quot;</a>
<a name="ln64">#include &quot;spl-miscast.h&quot;</a>
<a name="ln65">#include &quot;spl-other.h&quot;</a>
<a name="ln66">#include &quot;spl-selfench.h&quot;</a>
<a name="ln67">#include &quot;spl-summoning.h&quot;</a>
<a name="ln68">#include &quot;spl-transloc.h&quot;</a>
<a name="ln69">#include &quot;stairs.h&quot;</a>
<a name="ln70">#include &quot;state.h&quot;</a>
<a name="ln71">#include &quot;stepdown.h&quot;</a>
<a name="ln72">#include &quot;stringutil.h&quot;</a>
<a name="ln73">#include &quot;target.h&quot;</a>
<a name="ln74">#include &quot;terrain.h&quot;</a>
<a name="ln75">#include &quot;tilepick.h&quot;</a>
<a name="ln76">#include &quot;transform.h&quot;</a>
<a name="ln77">#include &quot;traps.h&quot;</a>
<a name="ln78">#include &quot;uncancel.h&quot;</a>
<a name="ln79">#include &quot;unicode.h&quot;</a>
<a name="ln80">#include &quot;view.h&quot;</a>
<a name="ln81"> </a>
<a name="ln82">#ifdef USE_TILE</a>
<a name="ln83"># include &quot;rltiles/tiledef-icons.h&quot;</a>
<a name="ln84">#endif</a>
<a name="ln85"> </a>
<a name="ln86">enum class abflag</a>
<a name="ln87">{</a>
<a name="ln88">    none                = 0x00000000,</a>
<a name="ln89">    breath              = 0x00000001, // ability uses DUR_BREATH_WEAPON</a>
<a name="ln90">    delay               = 0x00000002, // ability has its own delay</a>
<a name="ln91">    pain                = 0x00000004, // ability must hurt player (ie torment)</a>
<a name="ln92">    piety               = 0x00000008, // ability has its own piety cost</a>
<a name="ln93">    exhaustion          = 0x00000010, // fails if you.exhausted</a>
<a name="ln94">    instant             = 0x00000020, // doesn't take time to use</a>
<a name="ln95">                        //0x00000040,</a>
<a name="ln96">                        //0x00000080,</a>
<a name="ln97">    conf_ok             = 0x00000100, // can use even if confused</a>
<a name="ln98">    rations             = 0x00000200, // ability requires 2 rations per target</a>
<a name="ln99">    rations_or_piety    = 0x00000400, // ability requires 2 rations or piety</a>
<a name="ln100">    variable_mp         = 0x00000800, // costs a variable amount of MP</a>
<a name="ln101">                        //0x00001000,</a>
<a name="ln102">                        //0x00002000,</a>
<a name="ln103">                        //0x00004000,</a>
<a name="ln104">                        //0x00008000,</a>
<a name="ln105">                        //0x00010000,</a>
<a name="ln106">                        //0x00020000,</a>
<a name="ln107">    remove_curse_scroll = 0x00040000, // Uses ?rc</a>
<a name="ln108">    skill_drain         = 0x00080000, // drains skill levels</a>
<a name="ln109">    gold                = 0x00100000, // costs gold</a>
<a name="ln110">    sacrifice           = 0x00200000, // sacrifice (Ru)</a>
<a name="ln111">    hostile             = 0x00400000, // failure summons a hostile (Makhleb)</a>
<a name="ln112">    starve_ok           = 0x00800000, // can use even if starving</a>
<a name="ln113">    berserk_ok          = 0x01000000, // can use even if berserk</a>
<a name="ln114">    card                = 0x02000000, // deck drawing (Nemelex)</a>
<a name="ln115">};</a>
<a name="ln116">DEF_BITFIELD(ability_flags, abflag);</a>
<a name="ln117"> </a>
<a name="ln118">struct generic_cost</a>
<a name="ln119">{</a>
<a name="ln120">    int base, add, rolls;</a>
<a name="ln121"> </a>
<a name="ln122">    generic_cost(int num)</a>
<a name="ln123">        : base(num), add(num == 0 ? 0 : (num + 1) / 2 + 1), rolls(1)</a>
<a name="ln124">    {</a>
<a name="ln125">    }</a>
<a name="ln126">    generic_cost(int num, int _add, int _rolls = 1)</a>
<a name="ln127">        : base(num), add(_add), rolls(_rolls)</a>
<a name="ln128">    {</a>
<a name="ln129">    }</a>
<a name="ln130">    static generic_cost fixed(int fixed)</a>
<a name="ln131">    {</a>
<a name="ln132">        return generic_cost(fixed, 0, 1);</a>
<a name="ln133">    }</a>
<a name="ln134">    static generic_cost range(int low, int high, int _rolls = 1)</a>
<a name="ln135">    {</a>
<a name="ln136">        return generic_cost(low, high - low + 1, _rolls);</a>
<a name="ln137">    }</a>
<a name="ln138"> </a>
<a name="ln139">    int cost() const PURE;</a>
<a name="ln140"> </a>
<a name="ln141">    operator bool () const { return base &gt; 0 || add &gt; 0; }</a>
<a name="ln142">};</a>
<a name="ln143"> </a>
<a name="ln144">struct scaling_cost</a>
<a name="ln145">{</a>
<a name="ln146">    int value;</a>
<a name="ln147"> </a>
<a name="ln148">    scaling_cost(int permille) : value(permille) {}</a>
<a name="ln149"> </a>
<a name="ln150">    static scaling_cost fixed(int fixed)</a>
<a name="ln151">    {</a>
<a name="ln152">        return scaling_cost(-fixed);</a>
<a name="ln153">    }</a>
<a name="ln154"> </a>
<a name="ln155">    int cost(int max) const;</a>
<a name="ln156"> </a>
<a name="ln157">    operator bool () const { return value != 0; }</a>
<a name="ln158">};</a>
<a name="ln159"> </a>
<a name="ln160">/// What affects the failure chance of the ability?</a>
<a name="ln161">enum class fail_basis</a>
<a name="ln162">{</a>
<a name="ln163">    xl,</a>
<a name="ln164">    evo,</a>
<a name="ln165">    invo,</a>
<a name="ln166">};</a>
<a name="ln167"> </a>
<a name="ln168">/**</a>
<a name="ln169"> * What skill is used to determine the player's god's invocations' failure</a>
<a name="ln170"> * chance?</a>
<a name="ln171"> *</a>
<a name="ln172"> * XXX: deduplicate this with the similar code for divine titles, etc</a>
<a name="ln173"> * (skills.cc:skill_title_by_rank)</a>
<a name="ln174"> *</a>
<a name="ln175"> * IMPORTANT NOTE: functions that depend on this will be wrong if you aren't</a>
<a name="ln176"> * currently worshipping a god that grants the given ability (e.g. in ?/A)!</a>
<a name="ln177"> *</a>
<a name="ln178"> * @return      The appropriate skill type; e.g. SK_INVOCATIONS.</a>
<a name="ln179"> */</a>
<a name="ln180">skill_type invo_skill(god_type god)</a>
<a name="ln181">{</a>
<a name="ln182">    switch (god)</a>
<a name="ln183">    {</a>
<a name="ln184">        case GOD_KIKUBAAQUDGHA:</a>
<a name="ln185">            return SK_NECROMANCY;</a>
<a name="ln186"> </a>
<a name="ln187">#if TAG_MAJOR_VERSION == 34</a>
<a name="ln188">        case GOD_PAKELLAS:</a>
<a name="ln189">            return SK_EVOCATIONS;</a>
<a name="ln190">#endif</a>
<a name="ln191">        case GOD_ASHENZARI:</a>
<a name="ln192">        case GOD_JIYVA:</a>
<a name="ln193">        case GOD_GOZAG:</a>
<a name="ln194">        case GOD_RU:</a>
<a name="ln195">        case GOD_TROG:</a>
<a name="ln196">        case GOD_WU_JIAN:</a>
<a name="ln197">            return SK_NONE; // ugh</a>
<a name="ln198">        default:</a>
<a name="ln199">            return SK_INVOCATIONS;</a>
<a name="ln200">    }</a>
<a name="ln201">}</a>
<a name="ln202"> </a>
<a name="ln203">/// How to determine the odds of the ability failing?</a>
<a name="ln204">struct failure_info</a>
<a name="ln205">{</a>
<a name="ln206">    /// what determines the variable portion of failure: e.g. xl, evo, invo</a>
<a name="ln207">    fail_basis basis;</a>
<a name="ln208">    /// base failure chance</a>
<a name="ln209">    int base_chance;</a>
<a name="ln210">    /// multiplier to skill/xl; subtracted from base fail chance</a>
<a name="ln211">    int variable_fail_mult;</a>
<a name="ln212">    /// denominator to piety; subtracted from base fail chance if invo</a>
<a name="ln213">    int piety_fail_denom;</a>
<a name="ln214"> </a>
<a name="ln215">    /**</a>
<a name="ln216">     * What's the chance of the ability failing if the player tries to use it</a>
<a name="ln217">     * right now?</a>
<a name="ln218">     *</a>
<a name="ln219">     * See spl-cast.cc:_get_true_fail_rate() for details on what this 'chance'</a>
<a name="ln220">     * actually means.</a>
<a name="ln221">     *</a>
<a name="ln222">     * @return  A failure chance; may be outside the 0-100 range.</a>
<a name="ln223">     */</a>
<a name="ln224">    int chance() const</a>
<a name="ln225">    {</a>
<a name="ln226">        switch (basis)</a>
<a name="ln227">        {</a>
<a name="ln228">        case fail_basis::xl:</a>
<a name="ln229">            return base_chance - you.experience_level * variable_fail_mult;</a>
<a name="ln230">        case fail_basis::evo:</a>
<a name="ln231">            return base_chance - you.skill(SK_EVOCATIONS, variable_fail_mult);</a>
<a name="ln232">        case fail_basis::invo:</a>
<a name="ln233">        {</a>
<a name="ln234">            const int sk_mod = invo_skill() == SK_NONE ? 0 :</a>
<a name="ln235">                                 you.skill(invo_skill(), variable_fail_mult);</a>
<a name="ln236">            const int piety_mod</a>
<a name="ln237">                = piety_fail_denom ? you.piety / piety_fail_denom : 0;</a>
<a name="ln238">            return base_chance - sk_mod - piety_mod;</a>
<a name="ln239">        }</a>
<a name="ln240">        default:</a>
<a name="ln241">            die(&quot;unknown failure basis %d!&quot;, (int)basis);</a>
<a name="ln242">        }</a>
<a name="ln243">    }</a>
<a name="ln244"> </a>
<a name="ln245">    /// What skill governs the use of this ability, if any?</a>
<a name="ln246">    skill_type skill() const</a>
<a name="ln247">    {</a>
<a name="ln248">        switch (basis)</a>
<a name="ln249">        {</a>
<a name="ln250">        case fail_basis::evo:</a>
<a name="ln251">            return SK_EVOCATIONS;</a>
<a name="ln252">        case fail_basis::invo:</a>
<a name="ln253">            return invo_skill();</a>
<a name="ln254">        case fail_basis::xl:</a>
<a name="ln255">        default:</a>
<a name="ln256">            return SK_NONE;</a>
<a name="ln257">        }</a>
<a name="ln258">    }</a>
<a name="ln259">};</a>
<a name="ln260"> </a>
<a name="ln261">// Structure for representing an ability:</a>
<a name="ln262">struct ability_def</a>
<a name="ln263">{</a>
<a name="ln264">    ability_type        ability;</a>
<a name="ln265">    const char *        name;</a>
<a name="ln266">    unsigned int        mp_cost;        // magic cost of ability</a>
<a name="ln267">    scaling_cost        hp_cost;        // hit point cost of ability</a>
<a name="ln268">    unsigned int        food_cost;      // + rand2avg(food_cost, 2)</a>
<a name="ln269">    generic_cost        piety_cost;     // + random2((piety_cost + 1) / 2 + 1)</a>
<a name="ln270">    failure_info        failure;        // calculator for failure odds</a>
<a name="ln271">    ability_flags       flags;          // used for additional cost notices</a>
<a name="ln272">};</a>
<a name="ln273"> </a>
<a name="ln274">static int _lookup_ability_slot(ability_type abil);</a>
<a name="ln275">static spret _do_ability(const ability_def&amp; abil, bool fail);</a>
<a name="ln276">static void _pay_ability_costs(const ability_def&amp; abil);</a>
<a name="ln277">static int _scale_piety_cost(ability_type abil, int original_cost);</a>
<a name="ln278"> </a>
<a name="ln279">// The description screen was way out of date with the actual costs.</a>
<a name="ln280">// This table puts all the information in one place... -- bwr</a>
<a name="ln281">//</a>
<a name="ln282">// The four numerical fields are: MP, HP, food, and piety.</a>
<a name="ln283">// Note:  food_cost  = val + random2avg(val, 2)</a>
<a name="ln284">//        piety_cost = val + random2((val + 1) / 2 + 1);</a>
<a name="ln285">//        hp cost is in per-mil of maxhp (i.e. 20 = 2% of hp, rounded up)</a>
<a name="ln286">static const ability_def Ability_List[] =</a>
<a name="ln287">{</a>
<a name="ln288">    // NON_ABILITY should always come first</a>
<a name="ln289">    { ABIL_NON_ABILITY, &quot;No ability&quot;, 0, 0, 0, 0, {}, abflag::none },</a>
<a name="ln290">    { ABIL_SPIT_POISON, &quot;Spit Poison&quot;,</a>
<a name="ln291">        0, 0, 40, 0, {fail_basis::xl, 20, 1}, abflag::breath },</a>
<a name="ln292"> </a>
<a name="ln293">    { ABIL_BLINK, &quot;Blink&quot;, 0, 50, 50, 0, {fail_basis::xl, -1}, abflag::none },</a>
<a name="ln294">    // ^ failure special-cased</a>
<a name="ln295"> </a>
<a name="ln296">    { ABIL_BREATHE_FIRE, &quot;Breathe Fire&quot;,</a>
<a name="ln297">        0, 0, 125, 0, {fail_basis::xl, 30, 1}, abflag::breath },</a>
<a name="ln298">    { ABIL_BREATHE_FROST, &quot;Breathe Frost&quot;,</a>
<a name="ln299">        0, 0, 125, 0, {fail_basis::xl, 30, 1}, abflag::breath },</a>
<a name="ln300">    { ABIL_BREATHE_POISON, &quot;Breathe Poison Gas&quot;,</a>
<a name="ln301">      0, 0, 125, 0, {fail_basis::xl, 30, 1}, abflag::breath },</a>
<a name="ln302">    { ABIL_BREATHE_MEPHITIC, &quot;Breathe Noxious Fumes&quot;,</a>
<a name="ln303">      0, 0, 125, 0, {fail_basis::xl, 30, 1}, abflag::breath },</a>
<a name="ln304">    { ABIL_BREATHE_LIGHTNING, &quot;Breathe Lightning&quot;,</a>
<a name="ln305">      0, 0, 125, 0, {fail_basis::xl, 30, 1}, abflag::breath },</a>
<a name="ln306">    { ABIL_BREATHE_POWER, &quot;Breathe Dispelling Energy&quot;,</a>
<a name="ln307">      0, 0, 125, 0, {fail_basis::xl, 30, 1}, abflag::breath },</a>
<a name="ln308">    { ABIL_BREATHE_STEAM, &quot;Breathe Steam&quot;,</a>
<a name="ln309">      0, 0, 75, 0, {fail_basis::xl, 20, 1}, abflag::breath },</a>
<a name="ln310">    { ABIL_BREATHE_ACID, &quot;Breathe Acid&quot;,</a>
<a name="ln311">      0, 0, 125, 0, {fail_basis::xl, 30, 1}, abflag::breath },</a>
<a name="ln312"> </a>
<a name="ln313">    { ABIL_TRAN_BAT, &quot;Bat Form&quot;,</a>
<a name="ln314">      2, 0, 0, 0, {fail_basis::xl, 45, 2}, abflag::starve_ok },</a>
<a name="ln315">    { ABIL_EXSANGUINATE, &quot;Exsanguinate&quot;,</a>
<a name="ln316">      0, 0, 0, 0, {}, abflag::delay},</a>
<a name="ln317">    { ABIL_REVIVIFY, &quot;Revivify&quot;,</a>
<a name="ln318">      0, 0, 0, 0, {}, abflag::delay},</a>
<a name="ln319"> </a>
<a name="ln320">    { ABIL_FLY, &quot;Fly&quot;, 3, 0, 100, 0, {fail_basis::xl, 42, 3}, abflag::none },</a>
<a name="ln321">    { ABIL_STOP_FLYING, &quot;Stop Flying&quot;, 0, 0, 0, 0, {}, abflag::starve_ok },</a>
<a name="ln322">    { ABIL_DAMNATION, &quot;Hurl Damnation&quot;,</a>
<a name="ln323">        0, 150, 200, 0, {fail_basis::xl, 50, 1}, abflag::none },</a>
<a name="ln324"> </a>
<a name="ln325">    { ABIL_CANCEL_PPROJ, &quot;Cancel Portal Projectile&quot;,</a>
<a name="ln326">      0, 0, 0, 0, {}, abflag::instant | abflag::starve_ok },</a>
<a name="ln327"> </a>
<a name="ln328">    { ABIL_DIG, &quot;Dig&quot;, 0, 0, 0, 0, {}, abflag::instant | abflag::starve_ok },</a>
<a name="ln329">    { ABIL_SHAFT_SELF, &quot;Shaft Self&quot;, 0, 0, 250, 0, {}, abflag::delay },</a>
<a name="ln330"> </a>
<a name="ln331">    { ABIL_HOP, &quot;Hop&quot;, 0, 0, 0, 0, {}, abflag::none },</a>
<a name="ln332"> </a>
<a name="ln333">    // EVOKE abilities use Evocations and come from items.</a>
<a name="ln334">    // Teleportation and Blink can also come from mutations</a>
<a name="ln335">    // so we have to distinguish them (see above). The off items</a>
<a name="ln336">    // below are labeled EVOKE because they only work now if the</a>
<a name="ln337">    // player has an item with the evocable power (not just because</a>
<a name="ln338">    // you used a wand, potion, or miscast effect). I didn't see</a>
<a name="ln339">    // any reason to label them as &quot;Evoke&quot; in the text, they don't</a>
<a name="ln340">    // use or train Evocations (the others do).  -- bwr</a>
<a name="ln341">    { ABIL_EVOKE_BLINK, &quot;Evoke Blink&quot;,</a>
<a name="ln342">      1, 0, 50, 0, {fail_basis::evo, 40, 2}, abflag::none },</a>
<a name="ln343">    { ABIL_HEAL_WOUNDS, &quot;Heal Wounds&quot;,</a>
<a name="ln344">      0, 0, 0, 0, {fail_basis::xl, 45, 2}, abflag::none },</a>
<a name="ln345">    { ABIL_EVOKE_BERSERK, &quot;Evoke Berserk Rage&quot;,</a>
<a name="ln346">      0, 0, 600, 0, {fail_basis::evo, 50, 2}, abflag::none },</a>
<a name="ln347"> </a>
<a name="ln348">    { ABIL_EVOKE_TURN_INVISIBLE, &quot;Evoke Invisibility&quot;,</a>
<a name="ln349">      2, 0, 250, 0, {fail_basis::evo, 60, 2}, abflag::none },</a>
<a name="ln350">#if TAG_MAJOR_VERSION == 34</a>
<a name="ln351">    { ABIL_EVOKE_TURN_VISIBLE, &quot;Turn Visible&quot;,</a>
<a name="ln352">      0, 0, 0, 0, {}, abflag::starve_ok },</a>
<a name="ln353">#endif</a>
<a name="ln354">    { ABIL_EVOKE_FLIGHT, &quot;Evoke Flight&quot;,</a>
<a name="ln355">      1, 0, 100, 0, {fail_basis::evo, 40, 2}, abflag::none },</a>
<a name="ln356">    { ABIL_EVOKE_FOG, &quot;Evoke Fog&quot;,</a>
<a name="ln357">      2, 0, 250, 0, {fail_basis::evo, 50, 2}, abflag::none },</a>
<a name="ln358">    { ABIL_EVOKE_RATSKIN, &quot;Evoke Ratskin&quot;,</a>
<a name="ln359">      3, 0, 200, 0, {fail_basis::evo, 50, 2}, abflag::none },</a>
<a name="ln360">    { ABIL_EVOKE_THUNDER, &quot;Evoke Thunderclouds&quot;,</a>
<a name="ln361">      5, 0, 200, 0, {fail_basis::evo, 60, 2}, abflag::none },</a>
<a name="ln362"> </a>
<a name="ln363"> </a>
<a name="ln364">    { ABIL_END_TRANSFORMATION, &quot;End Transformation&quot;,</a>
<a name="ln365">      0, 0, 0, 0, {}, abflag::starve_ok },</a>
<a name="ln366"> </a>
<a name="ln367">    // INVOCATIONS:</a>
<a name="ln368">    // Zin</a>
<a name="ln369">    { ABIL_ZIN_RECITE, &quot;Recite&quot;,</a>
<a name="ln370">      0, 0, 0, 0, {fail_basis::invo, 30, 6, 20}, abflag::none },</a>
<a name="ln371">    { ABIL_ZIN_VITALISATION, &quot;Vitalisation&quot;,</a>
<a name="ln372">      2, 0, 0, 1, {fail_basis::invo, 40, 5, 20}, abflag::none },</a>
<a name="ln373">    { ABIL_ZIN_IMPRISON, &quot;Imprison&quot;,</a>
<a name="ln374">      5, 0, 0, 4, {fail_basis::invo, 60, 5, 20}, abflag::none },</a>
<a name="ln375">    { ABIL_ZIN_SANCTUARY, &quot;Sanctuary&quot;,</a>
<a name="ln376">      7, 0, 0, 15, {fail_basis::invo, 80, 4, 25}, abflag::none },</a>
<a name="ln377">    { ABIL_ZIN_DONATE_GOLD, &quot;Donate Gold&quot;,</a>
<a name="ln378">      0, 0, 0, 0, {fail_basis::invo}, abflag::none },</a>
<a name="ln379"> </a>
<a name="ln380">    // The Shining One</a>
<a name="ln381">    { ABIL_TSO_DIVINE_SHIELD, &quot;Divine Shield&quot;,</a>
<a name="ln382">      3, 0, 50, 2, {fail_basis::invo, 40, 5, 20}, abflag::none },</a>
<a name="ln383">    { ABIL_TSO_CLEANSING_FLAME, &quot;Cleansing Flame&quot;,</a>
<a name="ln384">      5, 0, 100, 2, {fail_basis::invo, 70, 4, 25}, abflag::none },</a>
<a name="ln385">    { ABIL_TSO_SUMMON_DIVINE_WARRIOR, &quot;Summon Divine Warrior&quot;,</a>
<a name="ln386">      8, 0, 150, 5, {fail_basis::invo, 80, 4, 25}, abflag::none },</a>
<a name="ln387">    { ABIL_TSO_BLESS_WEAPON, &quot;Brand Weapon With Holy Wrath&quot;, 0, 0, 0, 0,</a>
<a name="ln388">      {fail_basis::invo}, abflag::none },</a>
<a name="ln389"> </a>
<a name="ln390">    // Kikubaaqudgha</a>
<a name="ln391">    { ABIL_KIKU_RECEIVE_CORPSES, &quot;Receive Corpses&quot;,</a>
<a name="ln392">      3, 0, 200, 2, {fail_basis::invo, 40, 5, 20}, abflag::none },</a>
<a name="ln393">    { ABIL_KIKU_TORMENT, &quot;Torment&quot;,</a>
<a name="ln394">      4, 0, 0, 8, {fail_basis::invo, 60, 5, 20}, abflag::none },</a>
<a name="ln395">    { ABIL_KIKU_GIFT_NECRONOMICON, &quot;Receive Necronomicon&quot;, 0, 0, 0, 0,</a>
<a name="ln396">      {fail_basis::invo}, abflag::none },</a>
<a name="ln397">    { ABIL_KIKU_BLESS_WEAPON, &quot;Brand Weapon With Pain&quot;, 0, 0, 0, 0,</a>
<a name="ln398">      {fail_basis::invo}, abflag::pain },</a>
<a name="ln399"> </a>
<a name="ln400">    // Yredelemnul</a>
<a name="ln401">    { ABIL_YRED_INJURY_MIRROR, &quot;Injury Mirror&quot;,</a>
<a name="ln402">      0, 0, 0, 0, {fail_basis::invo, 40, 4, 20}, abflag::piety },</a>
<a name="ln403">    { ABIL_YRED_ANIMATE_REMAINS, &quot;Animate Remains&quot;,</a>
<a name="ln404">      2, 0, 200, 0, {fail_basis::invo, 40, 4, 20}, abflag::none },</a>
<a name="ln405">    { ABIL_YRED_RECALL_UNDEAD_SLAVES, &quot;Recall Undead Slaves&quot;,</a>
<a name="ln406">      2, 0, 0, 0, {fail_basis::invo, 50, 4, 20}, abflag::none },</a>
<a name="ln407">    { ABIL_YRED_ANIMATE_DEAD, &quot;Animate Dead&quot;,</a>
<a name="ln408">      2, 0, 200, 0, {fail_basis::invo, 40, 4, 20}, abflag::none },</a>
<a name="ln409">    { ABIL_YRED_DRAIN_LIFE, &quot;Drain Life&quot;,</a>
<a name="ln410">      6, 0, 200, 2, {fail_basis::invo, 60, 4, 25}, abflag::none },</a>
<a name="ln411">    { ABIL_YRED_ENSLAVE_SOUL, &quot;Enslave Soul&quot;,</a>
<a name="ln412">      8, 0, 500, 4, {fail_basis::invo, 80, 4, 25}, abflag::none },</a>
<a name="ln413"> </a>
<a name="ln414">    // Okawaru</a>
<a name="ln415">    { ABIL_OKAWARU_HEROISM, &quot;Heroism&quot;,</a>
<a name="ln416">      2, 0, 0, 1, {fail_basis::invo, 30, 6, 20}, abflag::none },</a>
<a name="ln417">    { ABIL_OKAWARU_FINESSE, &quot;Finesse&quot;,</a>
<a name="ln418">      5, 0, 0, 3, {fail_basis::invo, 60, 4, 25}, abflag::none },</a>
<a name="ln419"> </a>
<a name="ln420">    // Makhleb</a>
<a name="ln421">    { ABIL_MAKHLEB_MINOR_DESTRUCTION, &quot;Minor Destruction&quot;,</a>
<a name="ln422">      0, scaling_cost::fixed(1), 0, 0, {fail_basis::invo, 40, 5, 20}, abflag::none },</a>
<a name="ln423">    { ABIL_MAKHLEB_LESSER_SERVANT_OF_MAKHLEB, &quot;Lesser Servant of Makhleb&quot;,</a>
<a name="ln424">      0, scaling_cost::fixed(4), 0, 2, {fail_basis::invo, 40, 5, 20}, abflag::hostile },</a>
<a name="ln425">    { ABIL_MAKHLEB_MAJOR_DESTRUCTION, &quot;Major Destruction&quot;,</a>
<a name="ln426">      0, scaling_cost::fixed(6), 0, generic_cost::range(0, 1),</a>
<a name="ln427">      {fail_basis::invo, 60, 4, 25}, abflag::none },</a>
<a name="ln428">    { ABIL_MAKHLEB_GREATER_SERVANT_OF_MAKHLEB, &quot;Greater Servant of Makhleb&quot;,</a>
<a name="ln429">      0, scaling_cost::fixed(10), 0, 5,</a>
<a name="ln430">      {fail_basis::invo, 90, 2, 5}, abflag::hostile },</a>
<a name="ln431"> </a>
<a name="ln432">    // Sif Muna</a>
<a name="ln433">    { ABIL_SIF_MUNA_CHANNEL_ENERGY, &quot;Channel Magic&quot;,</a>
<a name="ln434">      0, 0, 200, 2, {fail_basis::invo, 60, 4, 25}, abflag::none },</a>
<a name="ln435">    { ABIL_SIF_MUNA_FORGET_SPELL, &quot;Forget Spell&quot;,</a>
<a name="ln436">      0, 0, 0, 8, {fail_basis::invo}, abflag::none },</a>
<a name="ln437">    { ABIL_SIF_MUNA_DIVINE_EXEGESIS, &quot;Divine Exegesis&quot;,</a>
<a name="ln438">      0, 0, 0, 12, {fail_basis::invo, 80, 4, 25}, abflag::none },</a>
<a name="ln439"> </a>
<a name="ln440">    // Trog</a>
<a name="ln441">    { ABIL_TROG_BERSERK, &quot;Berserk&quot;,</a>
<a name="ln442">      0, 0, 600, 0, {fail_basis::invo}, abflag::none },</a>
<a name="ln443">    { ABIL_TROG_REGEN_MR, &quot;Trog's Hand&quot;,</a>
<a name="ln444">      0, 0, 250, 2, {fail_basis::invo, piety_breakpoint(2), 0, 1}, abflag::none },</a>
<a name="ln445">    { ABIL_TROG_BROTHERS_IN_ARMS, &quot;Brothers in Arms&quot;,</a>
<a name="ln446">      0, 0, 250, generic_cost::range(5, 6),</a>
<a name="ln447">      {fail_basis::invo, piety_breakpoint(5), 0, 1}, abflag::none },</a>
<a name="ln448"> </a>
<a name="ln449">    // Elyvilon</a>
<a name="ln450">    { ABIL_ELYVILON_LIFESAVING, &quot;Divine Protection&quot;,</a>
<a name="ln451">      0, 0, 0, 0, {fail_basis::invo}, abflag::piety },</a>
<a name="ln452">    { ABIL_ELYVILON_LESSER_HEALING, &quot;Lesser Healing&quot;, 1, 0, 100,</a>
<a name="ln453">      generic_cost::range(0, 1), {fail_basis::invo, 30, 6, 20}, abflag::none },</a>
<a name="ln454">    { ABIL_ELYVILON_HEAL_OTHER, &quot;Heal Other&quot;,</a>
<a name="ln455">      2, 0, 250, 2, {fail_basis::invo, 40, 5, 20}, abflag::none },</a>
<a name="ln456">    { ABIL_ELYVILON_PURIFICATION, &quot;Purification&quot;,</a>
<a name="ln457">      3, 0, 300, 3, {fail_basis::invo, 20, 5, 20}, abflag::conf_ok },</a>
<a name="ln458">    { ABIL_ELYVILON_GREATER_HEALING, &quot;Greater Healing&quot;,</a>
<a name="ln459">      2, 0, 250, 3, {fail_basis::invo, 40, 5, 20}, abflag::none },</a>
<a name="ln460">    { ABIL_ELYVILON_DIVINE_VIGOUR, &quot;Divine Vigour&quot;,</a>
<a name="ln461">      0, 0, 600, 6, {fail_basis::invo, 80, 4, 25}, abflag::none },</a>
<a name="ln462"> </a>
<a name="ln463">    // Lugonu</a>
<a name="ln464">    { ABIL_LUGONU_ABYSS_EXIT, &quot;Depart the Abyss&quot;,</a>
<a name="ln465">      1, 0, 0, 10, {fail_basis::invo, 30, 6, 20}, abflag::none },</a>
<a name="ln466">    { ABIL_LUGONU_BEND_SPACE, &quot;Bend Space&quot;,</a>
<a name="ln467">      1, scaling_cost::fixed(2), 0, 0, {fail_basis::invo, 40, 5, 20}, abflag::none },</a>
<a name="ln468">    { ABIL_LUGONU_BANISH, &quot;Banish&quot;, 4, 0, 200, generic_cost::range(3, 4),</a>
<a name="ln469">      {fail_basis::invo, 85, 7, 20}, abflag::none },</a>
<a name="ln470">    { ABIL_LUGONU_CORRUPT, &quot;Corrupt&quot;, 7, scaling_cost::fixed(5), 500, 10,</a>
<a name="ln471">      {fail_basis::invo, 70, 4, 25}, abflag::none },</a>
<a name="ln472">    { ABIL_LUGONU_ABYSS_ENTER, &quot;Enter the Abyss&quot;, 10, 0, 500, 28,</a>
<a name="ln473">      {fail_basis::invo, 80, 4, 25}, abflag::pain },</a>
<a name="ln474">    { ABIL_LUGONU_BLESS_WEAPON, &quot;Brand Weapon With Distortion&quot;, 0, 0, 0, 0,</a>
<a name="ln475">      {fail_basis::invo}, abflag::none },</a>
<a name="ln476"> </a>
<a name="ln477">    // Nemelex</a>
<a name="ln478">    { ABIL_NEMELEX_DRAW_DESTRUCTION, &quot;Draw Destruction&quot;,</a>
<a name="ln479">      0, 0, 0, 0, {fail_basis::invo}, abflag::card },</a>
<a name="ln480">    { ABIL_NEMELEX_DRAW_ESCAPE, &quot;Draw Escape&quot;,</a>
<a name="ln481">      0, 0, 0, 0, {fail_basis::invo}, abflag::card },</a>
<a name="ln482">    { ABIL_NEMELEX_DRAW_SUMMONING, &quot;Draw Summoning&quot;,</a>
<a name="ln483">      0, 0, 0, 0, {fail_basis::invo}, abflag::card },</a>
<a name="ln484">    { ABIL_NEMELEX_DRAW_STACK, &quot;Draw Stack&quot;,</a>
<a name="ln485">      0, 0, 0, 0, {fail_basis::invo}, abflag::card },</a>
<a name="ln486">    { ABIL_NEMELEX_TRIPLE_DRAW, &quot;Triple Draw&quot;,</a>
<a name="ln487">      2, 0, 0, 6, {fail_basis::invo, 60, 5, 20}, abflag::none },</a>
<a name="ln488">    { ABIL_NEMELEX_DEAL_FOUR, &quot;Deal Four&quot;,</a>
<a name="ln489">      8, 0, 0, 4, {fail_basis::invo, -1}, abflag::none }, // failure special-cased</a>
<a name="ln490">    { ABIL_NEMELEX_STACK_FIVE, &quot;Stack Five&quot;,</a>
<a name="ln491">      5, 0, 0, 10, {fail_basis::invo, 80, 4, 25}, abflag::none },</a>
<a name="ln492"> </a>
<a name="ln493">    // Beogh</a>
<a name="ln494">    { ABIL_BEOGH_SMITING, &quot;Smiting&quot;,</a>
<a name="ln495">      3, 0, 0, generic_cost::fixed(3), {fail_basis::invo, 40, 5, 20}, abflag::none },</a>
<a name="ln496">    { ABIL_BEOGH_RECALL_ORCISH_FOLLOWERS, &quot;Recall Orcish Followers&quot;,</a>
<a name="ln497">      2, 0, 0, 0, {fail_basis::invo, 30, 6, 20}, abflag::none },</a>
<a name="ln498">    { ABIL_BEOGH_GIFT_ITEM, &quot;Give Item to Named Follower&quot;,</a>
<a name="ln499">      0, 0, 0, 0, {fail_basis::invo}, abflag::none },</a>
<a name="ln500">    { ABIL_BEOGH_RESURRECTION, &quot;Resurrection&quot;,</a>
<a name="ln501">      0, 0, 0, 28, {fail_basis::invo}, abflag::none },</a>
<a name="ln502"> </a>
<a name="ln503">    // Jiyva</a>
<a name="ln504">    { ABIL_JIYVA_CALL_JELLY, &quot;Request Jelly&quot;,</a>
<a name="ln505">      2, 0, 0, 1, {fail_basis::invo}, abflag::none },</a>
<a name="ln506">    { ABIL_JIYVA_SLIMIFY, &quot;Slimify&quot;,</a>
<a name="ln507">      4, 0, 0, 8, {fail_basis::invo, 90, 0, 2}, abflag::none },</a>
<a name="ln508">    { ABIL_JIYVA_CURE_BAD_MUTATION, &quot;Cure Bad Mutation&quot;,</a>
<a name="ln509">      0, 0, 0, 15, {fail_basis::invo}, abflag::none },</a>
<a name="ln510"> </a>
<a name="ln511">    // Fedhas</a>
<a name="ln512">    { ABIL_FEDHAS_WALL_OF_BRIARS, &quot;Wall of Briars&quot;,</a>
<a name="ln513">      3, 0, 50, 2, {fail_basis::invo, 30, 6, 20}, abflag::none},</a>
<a name="ln514">    { ABIL_FEDHAS_GROW_BALLISTOMYCETE, &quot;Grow Ballistomycete&quot;,</a>
<a name="ln515">      4, 0, 100, 4, {fail_basis::invo, 60, 4, 25}, abflag::none },</a>
<a name="ln516">    { ABIL_FEDHAS_OVERGROW, &quot;Overgrow&quot;,</a>
<a name="ln517">      8, 0, 200, 12, {fail_basis::invo, 70, 5, 20}, abflag::none},</a>
<a name="ln518">    { ABIL_FEDHAS_GROW_OKLOB, &quot;Grow Oklob&quot;,</a>
<a name="ln519">      6, 0, 150, 6, {fail_basis::invo, 80, 4, 25}, abflag::none },</a>
<a name="ln520"> </a>
<a name="ln521">    // Cheibriados</a>
<a name="ln522">    { ABIL_CHEIBRIADOS_TIME_BEND, &quot;Bend Time&quot;,</a>
<a name="ln523">      3, 0, 50, 1, {fail_basis::invo, 40, 4, 20}, abflag::none },</a>
<a name="ln524">    { ABIL_CHEIBRIADOS_DISTORTION, &quot;Temporal Distortion&quot;,</a>
<a name="ln525">      4, 0, 200, 3, {fail_basis::invo, 60, 5, 20}, abflag::instant },</a>
<a name="ln526">    { ABIL_CHEIBRIADOS_SLOUCH, &quot;Slouch&quot;,</a>
<a name="ln527">      5, 0, 100, 8, {fail_basis::invo, 60, 4, 25}, abflag::none },</a>
<a name="ln528">    { ABIL_CHEIBRIADOS_TIME_STEP, &quot;Step From Time&quot;,</a>
<a name="ln529">      10, 0, 200, 10, {fail_basis::invo, 80, 4, 25}, abflag::none },</a>
<a name="ln530"> </a>
<a name="ln531">    // Ashenzari</a>
<a name="ln532">    { ABIL_ASHENZARI_CURSE, &quot;Curse Item&quot;,</a>
<a name="ln533">      0, 0, 0, 0, {fail_basis::invo}, abflag::remove_curse_scroll },</a>
<a name="ln534">    { ABIL_ASHENZARI_SCRYING, &quot;Scrying&quot;,</a>
<a name="ln535">      4, 0, 0, 2, {fail_basis::invo}, abflag::instant },</a>
<a name="ln536">    { ABIL_ASHENZARI_TRANSFER_KNOWLEDGE, &quot;Transfer Knowledge&quot;,</a>
<a name="ln537">      0, 0, 0, 10, {fail_basis::invo}, abflag::none },</a>
<a name="ln538">    { ABIL_ASHENZARI_END_TRANSFER, &quot;End Transfer Knowledge&quot;,</a>
<a name="ln539">      0, 0, 0, 0, {fail_basis::invo}, abflag::starve_ok },</a>
<a name="ln540"> </a>
<a name="ln541">    // Dithmenos</a>
<a name="ln542">    { ABIL_DITHMENOS_SHADOW_STEP, &quot;Shadow Step&quot;,</a>
<a name="ln543">      4, 80, 0, 5, {fail_basis::invo, 30, 6, 20}, abflag::none },</a>
<a name="ln544">    { ABIL_DITHMENOS_SHADOW_FORM, &quot;Shadow Form&quot;,</a>
<a name="ln545">      9, 0, 0, 12, {fail_basis::invo, 80, 4, 25}, abflag::skill_drain },</a>
<a name="ln546"> </a>
<a name="ln547">    // Ru</a>
<a name="ln548">    { ABIL_RU_DRAW_OUT_POWER, &quot;Draw Out Power&quot;, 0, 0, 0, 0,</a>
<a name="ln549">      {fail_basis::invo}, abflag::exhaustion|abflag::skill_drain|abflag::conf_ok },</a>
<a name="ln550">    { ABIL_RU_POWER_LEAP, &quot;Power Leap&quot;,</a>
<a name="ln551">      5, 0, 0, 0, {fail_basis::invo}, abflag::exhaustion },</a>
<a name="ln552">    { ABIL_RU_APOCALYPSE, &quot;Apocalypse&quot;,</a>
<a name="ln553">      8, 0, 0, 0, {fail_basis::invo}, abflag::exhaustion|abflag::skill_drain },</a>
<a name="ln554"> </a>
<a name="ln555">    { ABIL_RU_SACRIFICE_PURITY, &quot;Sacrifice Purity&quot;,</a>
<a name="ln556">      0, 0, 0, 0, {fail_basis::invo}, abflag::sacrifice },</a>
<a name="ln557">    { ABIL_RU_SACRIFICE_WORDS, &quot;Sacrifice Words&quot;,</a>
<a name="ln558">      0, 0, 0, 0, {fail_basis::invo}, abflag::sacrifice },</a>
<a name="ln559">    { ABIL_RU_SACRIFICE_DRINK, &quot;Sacrifice Drink&quot;,</a>
<a name="ln560">      0, 0, 0, 0, {fail_basis::invo}, abflag::sacrifice },</a>
<a name="ln561">    { ABIL_RU_SACRIFICE_ESSENCE, &quot;Sacrifice Essence&quot;,</a>
<a name="ln562">      0, 0, 0, 0, {fail_basis::invo}, abflag::sacrifice },</a>
<a name="ln563">    { ABIL_RU_SACRIFICE_HEALTH, &quot;Sacrifice Health&quot;,</a>
<a name="ln564">      0, 0, 0, 0, {fail_basis::invo}, abflag::sacrifice },</a>
<a name="ln565">    { ABIL_RU_SACRIFICE_STEALTH, &quot;Sacrifice Stealth&quot;,</a>
<a name="ln566">      0, 0, 0, 0, {fail_basis::invo}, abflag::sacrifice },</a>
<a name="ln567">    { ABIL_RU_SACRIFICE_ARTIFICE, &quot;Sacrifice Artifice&quot;,</a>
<a name="ln568">      0, 0, 0, 0, {fail_basis::invo}, abflag::sacrifice },</a>
<a name="ln569">    { ABIL_RU_SACRIFICE_LOVE, &quot;Sacrifice Love&quot;,</a>
<a name="ln570">      0, 0, 0, 0, {fail_basis::invo}, abflag::sacrifice },</a>
<a name="ln571">    { ABIL_RU_SACRIFICE_COURAGE, &quot;Sacrifice Courage&quot;,</a>
<a name="ln572">      0, 0, 0, 0, {fail_basis::invo}, abflag::sacrifice },</a>
<a name="ln573">    { ABIL_RU_SACRIFICE_ARCANA, &quot;Sacrifice Arcana&quot;,</a>
<a name="ln574">      0, 0, 0, 0, {fail_basis::invo}, abflag::sacrifice },</a>
<a name="ln575">    { ABIL_RU_SACRIFICE_NIMBLENESS, &quot;Sacrifice Nimbleness&quot;,</a>
<a name="ln576">      0, 0, 0, 0, {fail_basis::invo}, abflag::sacrifice },</a>
<a name="ln577">    { ABIL_RU_SACRIFICE_DURABILITY, &quot;Sacrifice Durability&quot;,</a>
<a name="ln578">      0, 0, 0, 0, {fail_basis::invo}, abflag::sacrifice },</a>
<a name="ln579">    { ABIL_RU_SACRIFICE_HAND, &quot;Sacrifice a Hand&quot;,</a>
<a name="ln580">      0, 0, 0, 0, {fail_basis::invo}, abflag::sacrifice },</a>
<a name="ln581">    { ABIL_RU_SACRIFICE_EXPERIENCE, &quot;Sacrifice Experience&quot;,</a>
<a name="ln582">      0, 0, 0, 0, {fail_basis::invo}, abflag::sacrifice },</a>
<a name="ln583">    { ABIL_RU_SACRIFICE_SKILL, &quot;Sacrifice Skill&quot;,</a>
<a name="ln584">      0, 0, 0, 0, {fail_basis::invo}, abflag::sacrifice },</a>
<a name="ln585">    { ABIL_RU_SACRIFICE_EYE, &quot;Sacrifice an Eye&quot;,</a>
<a name="ln586">      0, 0, 0, 0, {fail_basis::invo}, abflag::sacrifice },</a>
<a name="ln587">    { ABIL_RU_SACRIFICE_RESISTANCE, &quot;Sacrifice Resistance&quot;,</a>
<a name="ln588">      0, 0, 0, 0, {fail_basis::invo}, abflag::sacrifice },</a>
<a name="ln589">    { ABIL_RU_REJECT_SACRIFICES, &quot;Reject Sacrifices&quot;,</a>
<a name="ln590">      0, 0, 0, 0, {fail_basis::invo}, abflag::none },</a>
<a name="ln591"> </a>
<a name="ln592">    // Gozag</a>
<a name="ln593">    { ABIL_GOZAG_POTION_PETITION, &quot;Potion Petition&quot;,</a>
<a name="ln594">      0, 0, 0, 0, {fail_basis::invo}, abflag::gold },</a>
<a name="ln595">    { ABIL_GOZAG_CALL_MERCHANT, &quot;Call Merchant&quot;,</a>
<a name="ln596">      0, 0, 0, 0, {fail_basis::invo}, abflag::gold|abflag::starve_ok },</a>
<a name="ln597">    { ABIL_GOZAG_BRIBE_BRANCH, &quot;Bribe Branch&quot;,</a>
<a name="ln598">      0, 0, 0, 0, {fail_basis::invo}, abflag::gold },</a>
<a name="ln599"> </a>
<a name="ln600">    // Qazlal</a>
<a name="ln601">    { ABIL_QAZLAL_UPHEAVAL, &quot;Upheaval&quot;,</a>
<a name="ln602">      4, 0, 0, 3, {fail_basis::invo, 40, 5, 20}, abflag::none },</a>
<a name="ln603">    { ABIL_QAZLAL_ELEMENTAL_FORCE, &quot;Elemental Force&quot;,</a>
<a name="ln604">      6, 0, 0, 6, {fail_basis::invo, 60, 5, 20}, abflag::none },</a>
<a name="ln605">    { ABIL_QAZLAL_DISASTER_AREA, &quot;Disaster Area&quot;,</a>
<a name="ln606">      7, 0, 0, 10, {fail_basis::invo, 70, 4, 25}, abflag::none },</a>
<a name="ln607"> </a>
<a name="ln608">#if TAG_MAJOR_VERSION == 34</a>
<a name="ln609">    // Pakellas</a>
<a name="ln610">    { ABIL_PAKELLAS_DEVICE_SURGE, &quot;Device Surge&quot;,</a>
<a name="ln611">      0, 0, 0, generic_cost::fixed(1),</a>
<a name="ln612">      {fail_basis::invo, 40, 5, 20}, abflag::variable_mp | abflag::instant },</a>
<a name="ln613">#endif</a>
<a name="ln614"> </a>
<a name="ln615">    // Uskayaw</a>
<a name="ln616">    { ABIL_USKAYAW_STOMP, &quot;Stomp&quot;,</a>
<a name="ln617">        3, 0, 100, generic_cost::fixed(20), {fail_basis::invo}, abflag::none },</a>
<a name="ln618">    { ABIL_USKAYAW_LINE_PASS, &quot;Line Pass&quot;,</a>
<a name="ln619">        4, 0, 200, generic_cost::fixed(20), {fail_basis::invo}, abflag::none},</a>
<a name="ln620">    { ABIL_USKAYAW_GRAND_FINALE, &quot;Grand Finale&quot;,</a>
<a name="ln621">        8, 0, 500, generic_cost::fixed(0),</a>
<a name="ln622">        {fail_basis::invo, 120 + piety_breakpoint(4), 5, 1}, abflag::none},</a>
<a name="ln623"> </a>
<a name="ln624">    // Hepliaklqana</a>
<a name="ln625">    { ABIL_HEPLIAKLQANA_RECALL, &quot;Recall Ancestor&quot;,</a>
<a name="ln626">        2, 0, 0, 0, {fail_basis::invo}, abflag::none },</a>
<a name="ln627">    { ABIL_HEPLIAKLQANA_TRANSFERENCE, &quot;Transference&quot;,</a>
<a name="ln628">        2, 0, 0, 3, {fail_basis::invo, 40, 5, 20},</a>
<a name="ln629">        abflag::none },</a>
<a name="ln630">    { ABIL_HEPLIAKLQANA_IDEALISE, &quot;Idealise&quot;,</a>
<a name="ln631">        4, 0, 0, 4, {fail_basis::invo, 60, 4, 25},</a>
<a name="ln632">        abflag::none },</a>
<a name="ln633"> </a>
<a name="ln634">    { ABIL_HEPLIAKLQANA_TYPE_KNIGHT,       &quot;Ancestor Life: Knight&quot;,</a>
<a name="ln635">        0, 0, 0, 0, {fail_basis::invo}, abflag::starve_ok },</a>
<a name="ln636">    { ABIL_HEPLIAKLQANA_TYPE_BATTLEMAGE,   &quot;Ancestor Life: Battlemage&quot;,</a>
<a name="ln637">        0, 0, 0, 0, {fail_basis::invo}, abflag::starve_ok },</a>
<a name="ln638">    { ABIL_HEPLIAKLQANA_TYPE_HEXER,        &quot;Ancestor Life: Hexer&quot;,</a>
<a name="ln639">        0, 0, 0, 0, {fail_basis::invo}, abflag::starve_ok },</a>
<a name="ln640"> </a>
<a name="ln641">    { ABIL_HEPLIAKLQANA_IDENTITY,  &quot;Ancestor Identity&quot;,</a>
<a name="ln642">        0, 0, 0, 0, {fail_basis::invo}, abflag::instant | abflag::starve_ok },</a>
<a name="ln643"> </a>
<a name="ln644">    // Wu Jian</a>
<a name="ln645">    { ABIL_WU_JIAN_SERPENTS_LASH, &quot;Serpent's Lash&quot;,</a>
<a name="ln646">        0, 0, 0, 2, {fail_basis::invo}, abflag::exhaustion | abflag::instant },</a>
<a name="ln647">    { ABIL_WU_JIAN_HEAVENLY_STORM, &quot;Heavenly Storm&quot;,</a>
<a name="ln648">        0, 0, 0, 20, {fail_basis::invo, piety_breakpoint(5), 0, 1}, abflag::none },</a>
<a name="ln649">    // Lunge and Whirlwind abilities aren't menu abilities but currently need</a>
<a name="ln650">    // to exist for action counting, hence need enums/entries.</a>
<a name="ln651">    { ABIL_WU_JIAN_LUNGE, &quot;Lunge&quot;, 0, 0, 0, 0, {}, abflag::berserk_ok },</a>
<a name="ln652">    { ABIL_WU_JIAN_WHIRLWIND, &quot;Whirlwind&quot;, 0, 0, 0, 0, {}, abflag::berserk_ok },</a>
<a name="ln653">    { ABIL_WU_JIAN_WALLJUMP, &quot;Wall Jump&quot;,</a>
<a name="ln654">        0, 0, 0, 0, {}, abflag::starve_ok | abflag::berserk_ok },</a>
<a name="ln655"> </a>
<a name="ln656">    { ABIL_STOP_RECALL, &quot;Stop Recall&quot;, 0, 0, 0, 0, {fail_basis::invo}, abflag::starve_ok },</a>
<a name="ln657">    { ABIL_RENOUNCE_RELIGION, &quot;Renounce Religion&quot;,</a>
<a name="ln658">      0, 0, 0, 0, {fail_basis::invo}, abflag::starve_ok },</a>
<a name="ln659">    { ABIL_CONVERT_TO_BEOGH, &quot;Convert to Beogh&quot;,</a>
<a name="ln660">      0, 0, 0, 0, {fail_basis::invo}, abflag::starve_ok },</a>
<a name="ln661">};</a>
<a name="ln662"> </a>
<a name="ln663">static const ability_def&amp; get_ability_def(ability_type abil)</a>
<a name="ln664">{</a>
<a name="ln665">    for (const ability_def &amp;ab_def : Ability_List)</a>
<a name="ln666">        if (ab_def.ability == abil)</a>
<a name="ln667">            return ab_def;</a>
<a name="ln668"> </a>
<a name="ln669">    return Ability_List[0];</a>
<a name="ln670">}</a>
<a name="ln671"> </a>
<a name="ln672">unsigned int ability_mp_cost(ability_type abil)</a>
<a name="ln673">{</a>
<a name="ln674">    return get_ability_def(abil).mp_cost;</a>
<a name="ln675">}</a>
<a name="ln676"> </a>
<a name="ln677">/**</a>
<a name="ln678"> * Is there a valid ability with a name matching that given?</a>
<a name="ln679"> *</a>
<a name="ln680"> * @param key   The name in question. (Not case sensitive.)</a>
<a name="ln681"> * @return      true if such an ability exists; false if not.</a>
<a name="ln682"> */</a>
<a name="ln683">bool string_matches_ability_name(const string&amp; key)</a>
<a name="ln684">{</a>
<a name="ln685">    return ability_by_name(key) != ABIL_NON_ABILITY;</a>
<a name="ln686">}</a>
<a name="ln687"> </a>
<a name="ln688">/**</a>
<a name="ln689"> * Find an ability whose name matches the given key.</a>
<a name="ln690"> *</a>
<a name="ln691"> * @param name      The name in question. (Not case sensitive.)</a>
<a name="ln692"> * @return          The enum of the relevant ability, if there was one; else</a>
<a name="ln693"> *                  ABIL_NON_ABILITY.</a>
<a name="ln694"> */</a>
<a name="ln695">ability_type ability_by_name(const string &amp;key)</a>
<a name="ln696">{</a>
<a name="ln697">    for (const auto &amp;abil : Ability_List)</a>
<a name="ln698">    {</a>
<a name="ln699">        if (abil.ability == ABIL_NON_ABILITY)</a>
<a name="ln700">            continue;</a>
<a name="ln701"> </a>
<a name="ln702">        const string name = lowercase_string(ability_name(abil.ability));</a>
<a name="ln703">        if (name == lowercase_string(key))</a>
<a name="ln704">            return abil.ability;</a>
<a name="ln705">    }</a>
<a name="ln706"> </a>
<a name="ln707">    return ABIL_NON_ABILITY;</a>
<a name="ln708">}</a>
<a name="ln709"> </a>
<a name="ln710">string print_abilities()</a>
<a name="ln711">{</a>
<a name="ln712">    string text = &quot;\n&lt;w&gt;a:&lt;/w&gt; &quot;;</a>
<a name="ln713"> </a>
<a name="ln714">    const vector&lt;talent&gt; talents = your_talents(false);</a>
<a name="ln715"> </a>
<a name="ln716">    if (talents.empty())</a>
<a name="ln717">        text += &quot;no special abilities&quot;;</a>
<a name="ln718">    else</a>
<a name="ln719">    {</a>
<a name="ln720">        for (unsigned int i = 0; i &lt; talents.size(); ++i)</a>
<a name="ln721">        {</a>
<a name="ln722">            if (i)</a>
<a name="ln723">                text += &quot;, &quot;;</a>
<a name="ln724">            text += ability_name(talents[i].which);</a>
<a name="ln725">        }</a>
<a name="ln726">    }</a>
<a name="ln727"> </a>
<a name="ln728">    return text;</a>
<a name="ln729">}</a>
<a name="ln730"> </a>
<a name="ln731">int get_gold_cost(ability_type ability)</a>
<a name="ln732">{</a>
<a name="ln733">    switch (ability)</a>
<a name="ln734">    {</a>
<a name="ln735">    case ABIL_GOZAG_CALL_MERCHANT:</a>
<a name="ln736">        return gozag_price_for_shop(true);</a>
<a name="ln737">    case ABIL_GOZAG_POTION_PETITION:</a>
<a name="ln738">        return gozag_potion_price();</a>
<a name="ln739">    case ABIL_GOZAG_BRIBE_BRANCH:</a>
<a name="ln740">        return GOZAG_BRIBE_AMOUNT;</a>
<a name="ln741">    default:</a>
<a name="ln742">        return 0;</a>
<a name="ln743">    }</a>
<a name="ln744">}</a>
<a name="ln745"> </a>
<a name="ln746">static string _nemelex_card_text(ability_type ability)</a>
<a name="ln747">{</a>
<a name="ln748">    int cards = deck_cards(ability_deck(ability));</a>
<a name="ln749"> </a>
<a name="ln750">    if (ability == ABIL_NEMELEX_DRAW_STACK)</a>
<a name="ln751">        return make_stringf(&quot;(next: %s)&quot;, stack_top().c_str());</a>
<a name="ln752">    else</a>
<a name="ln753">        return make_stringf(&quot;(%d in deck)&quot;, cards);</a>
<a name="ln754">}</a>
<a name="ln755"> </a>
<a name="ln756">static const int VAMPIRE_BAT_FORM_STAT_DRAIN = 2;</a>
<a name="ln757"> </a>
<a name="ln758">const string make_cost_description(ability_type ability)</a>
<a name="ln759">{</a>
<a name="ln760">    const ability_def&amp; abil = get_ability_def(ability);</a>
<a name="ln761">    string ret;</a>
<a name="ln762">    if (abil.mp_cost)</a>
<a name="ln763">        ret += make_stringf(&quot;, %d MP&quot;, abil.mp_cost);</a>
<a name="ln764"> </a>
<a name="ln765">    if (abil.flags &amp; abflag::variable_mp)</a>
<a name="ln766">        ret += &quot;, MP&quot;;</a>
<a name="ln767"> </a>
<a name="ln768">    if (ability == ABIL_HEAL_WOUNDS)</a>
<a name="ln769">        ret += make_stringf(&quot;, Permanent MP (%d left)&quot;, get_real_mp(false));</a>
<a name="ln770"> </a>
<a name="ln771">    if (ability == ABIL_TRAN_BAT)</a>
<a name="ln772">    {</a>
<a name="ln773">        ret += make_stringf(&quot;, Stat Drain (%d each)&quot;,</a>
<a name="ln774">                            VAMPIRE_BAT_FORM_STAT_DRAIN);</a>
<a name="ln775">    }</a>
<a name="ln776"> </a>
<a name="ln777">    if (ability == ABIL_REVIVIFY)</a>
<a name="ln778">        ret += &quot;, Frailty&quot;;</a>
<a name="ln779"> </a>
<a name="ln780">    if (abil.hp_cost)</a>
<a name="ln781">        ret += make_stringf(&quot;, %d HP&quot;, abil.hp_cost.cost(you.hp_max));</a>
<a name="ln782"> </a>
<a name="ln783">    if (abil.food_cost &amp;&amp; !you_foodless()</a>
<a name="ln784">        &amp;&amp; (you.undead_state() != US_SEMI_UNDEAD</a>
<a name="ln785">            || you.hunger_state &gt; HS_STARVING))</a>
<a name="ln786">    {</a>
<a name="ln787">        ret += &quot;, Hunger&quot;; // randomised and exact amount hidden from player</a>
<a name="ln788">    }</a>
<a name="ln789"> </a>
<a name="ln790">    if (abil.piety_cost || abil.flags &amp; abflag::piety)</a>
<a name="ln791">        ret += &quot;, Piety&quot;; // randomised and exact amount hidden from player</a>
<a name="ln792"> </a>
<a name="ln793">    if (abil.flags &amp; abflag::breath)</a>
<a name="ln794">        ret += &quot;, Breath&quot;;</a>
<a name="ln795"> </a>
<a name="ln796">    if (abil.flags &amp; abflag::delay)</a>
<a name="ln797">        ret += &quot;, Delay&quot;;</a>
<a name="ln798"> </a>
<a name="ln799">    if (abil.flags &amp; abflag::pain)</a>
<a name="ln800">        ret += &quot;, Pain&quot;;</a>
<a name="ln801"> </a>
<a name="ln802">    if (abil.flags &amp; abflag::exhaustion)</a>
<a name="ln803">        ret += &quot;, Exhaustion&quot;;</a>
<a name="ln804"> </a>
<a name="ln805">    if (abil.flags &amp; abflag::instant)</a>
<a name="ln806">        ret += &quot;, Instant&quot;; // not really a cost, more of a bonus - bwr</a>
<a name="ln807"> </a>
<a name="ln808">    if (abil.flags &amp; abflag::rations)</a>
<a name="ln809">        ret += &quot;, 2 Rations per target&quot;;</a>
<a name="ln810"> </a>
<a name="ln811">    if (abil.flags &amp; abflag::rations_or_piety)</a>
<a name="ln812">        ret += &quot;, Piety or 2 Rations&quot;;</a>
<a name="ln813"> </a>
<a name="ln814">    if (abil.flags &amp; abflag::skill_drain)</a>
<a name="ln815">        ret += &quot;, Skill drain&quot;;</a>
<a name="ln816"> </a>
<a name="ln817">    if (abil.flags &amp; abflag::remove_curse_scroll)</a>
<a name="ln818">        ret += &quot;, Scroll of remove curse&quot;;</a>
<a name="ln819"> </a>
<a name="ln820">    if (abil.flags &amp; abflag::gold)</a>
<a name="ln821">    {</a>
<a name="ln822">        const int amount = get_gold_cost(ability);</a>
<a name="ln823">        if (amount)</a>
<a name="ln824">            ret += make_stringf(&quot;, %d Gold&quot;, amount);</a>
<a name="ln825">        else if (ability == ABIL_GOZAG_POTION_PETITION)</a>
<a name="ln826">            ret += &quot;, Free&quot;;</a>
<a name="ln827">        else</a>
<a name="ln828">            ret += &quot;, Gold&quot;;</a>
<a name="ln829">    }</a>
<a name="ln830"> </a>
<a name="ln831">    if (abil.flags &amp; abflag::sacrifice)</a>
<a name="ln832">    {</a>
<a name="ln833">        ret += &quot;, &quot;;</a>
<a name="ln834">        const string prefix = &quot;Sacrifice &quot;;</a>
<a name="ln835">        ret += string(ability_name(ability)).substr(prefix.size());</a>
<a name="ln836">        ret += ru_sac_text(ability);</a>
<a name="ln837">    }</a>
<a name="ln838"> </a>
<a name="ln839">    if (abil.flags &amp; abflag::card)</a>
<a name="ln840">    {</a>
<a name="ln841">        ret += &quot;, &quot;;</a>
<a name="ln842">        ret += &quot;A Card &quot;;</a>
<a name="ln843">        ret += _nemelex_card_text(ability);</a>
<a name="ln844">    }</a>
<a name="ln845"> </a>
<a name="ln846">    // If we haven't output anything so far, then the effect has no cost</a>
<a name="ln847">    if (ret.empty())</a>
<a name="ln848">        return &quot;None&quot;;</a>
<a name="ln849"> </a>
<a name="ln850">    ret.erase(0, 2);</a>
<a name="ln851">    return ret;</a>
<a name="ln852">}</a>
<a name="ln853"> </a>
<a name="ln854">static string _get_piety_amount_str(int value)</a>
<a name="ln855">{</a>
<a name="ln856">    return value &gt; 15 ? &quot;extremely large&quot; :</a>
<a name="ln857">           value &gt; 10 ? &quot;large&quot; :</a>
<a name="ln858">           value &gt; 5  ? &quot;moderate&quot; :</a>
<a name="ln859">                        &quot;small&quot;;</a>
<a name="ln860">}</a>
<a name="ln861"> </a>
<a name="ln862">static const string _detailed_cost_description(ability_type ability)</a>
<a name="ln863">{</a>
<a name="ln864">    const ability_def&amp; abil = get_ability_def(ability);</a>
<a name="ln865">    ostringstream ret;</a>
<a name="ln866"> </a>
<a name="ln867">    bool have_cost = false;</a>
<a name="ln868">    ret &lt;&lt; &quot;This ability costs: &quot;;</a>
<a name="ln869"> </a>
<a name="ln870">    if (abil.mp_cost &gt; 0)</a>
<a name="ln871">    {</a>
<a name="ln872">        have_cost = true;</a>
<a name="ln873">        ret &lt;&lt; &quot;\nMP     : &quot;;</a>
<a name="ln874">        ret &lt;&lt; abil.mp_cost;</a>
<a name="ln875">    }</a>
<a name="ln876">    if (abil.hp_cost)</a>
<a name="ln877">    {</a>
<a name="ln878">        have_cost = true;</a>
<a name="ln879">        ret &lt;&lt; &quot;\nHP     : &quot;;</a>
<a name="ln880">        ret &lt;&lt; abil.hp_cost.cost(you.hp_max);</a>
<a name="ln881">    }</a>
<a name="ln882"> </a>
<a name="ln883">    if (abil.food_cost &amp;&amp; !you_foodless()</a>
<a name="ln884">        &amp;&amp; (you.undead_state() != US_SEMI_UNDEAD</a>
<a name="ln885">            || you.hunger_state &gt; HS_STARVING))</a>
<a name="ln886">    {</a>
<a name="ln887">        have_cost = true;</a>
<a name="ln888">        ret &lt;&lt; &quot;\nHunger : &quot;;</a>
<a name="ln889">        ret &lt;&lt; hunger_cost_string(abil.food_cost + abil.food_cost / 2);</a>
<a name="ln890">    }</a>
<a name="ln891"> </a>
<a name="ln892">    if (abil.piety_cost || abil.flags &amp; abflag::piety)</a>
<a name="ln893">    {</a>
<a name="ln894">        have_cost = true;</a>
<a name="ln895">        ret &lt;&lt; &quot;\nPiety  : &quot;;</a>
<a name="ln896">        if (abil.flags &amp; abflag::piety)</a>
<a name="ln897">            ret &lt;&lt; &quot;variable&quot;;</a>
<a name="ln898">        else</a>
<a name="ln899">        {</a>
<a name="ln900">            int avgcost = abil.piety_cost.base + abil.piety_cost.add / 2;</a>
<a name="ln901">            ret &lt;&lt; _get_piety_amount_str(avgcost);</a>
<a name="ln902">        }</a>
<a name="ln903">    }</a>
<a name="ln904"> </a>
<a name="ln905">    if (abil.flags &amp; abflag::gold)</a>
<a name="ln906">    {</a>
<a name="ln907">        have_cost = true;</a>
<a name="ln908">        ret &lt;&lt; &quot;\nGold   : &quot;;</a>
<a name="ln909">        int gold_amount = get_gold_cost(ability);</a>
<a name="ln910">        if (gold_amount)</a>
<a name="ln911">            ret &lt;&lt; gold_amount;</a>
<a name="ln912">        else if (ability == ABIL_GOZAG_POTION_PETITION)</a>
<a name="ln913">            ret &lt;&lt; &quot;free&quot;;</a>
<a name="ln914">        else</a>
<a name="ln915">            ret &lt;&lt; &quot;variable&quot;;</a>
<a name="ln916">    }</a>
<a name="ln917"> </a>
<a name="ln918">    if (abil.flags &amp; abflag::rations_or_piety)</a>
<a name="ln919">        ret &lt;&lt; &quot;\nPiety, or 2 rations&quot;;</a>
<a name="ln920"> </a>
<a name="ln921">    if (abil.flags &amp; abflag::rations)</a>
<a name="ln922">        ret &lt;&lt; &quot;\nRations: 2 per target&quot;;</a>
<a name="ln923"> </a>
<a name="ln924">    if (abil.flags &amp; abflag::remove_curse_scroll)</a>
<a name="ln925">    {</a>
<a name="ln926">        have_cost = true;</a>
<a name="ln927">        ret &lt;&lt; &quot;\nOne scroll of remove curse&quot;;</a>
<a name="ln928">    }</a>
<a name="ln929"> </a>
<a name="ln930">    if (!have_cost)</a>
<a name="ln931">        ret &lt;&lt; &quot;nothing.&quot;;</a>
<a name="ln932"> </a>
<a name="ln933">    if (abil.flags &amp; abflag::breath)</a>
<a name="ln934">        ret &lt;&lt; &quot;\nYou must catch your breath between uses of this ability.&quot;;</a>
<a name="ln935"> </a>
<a name="ln936">    if (abil.flags &amp; abflag::delay)</a>
<a name="ln937">        ret &lt;&lt; &quot;\nIt takes some time before being effective.&quot;;</a>
<a name="ln938"> </a>
<a name="ln939">    if (abil.flags &amp; abflag::pain)</a>
<a name="ln940">        ret &lt;&lt; &quot;\nUsing this ability will hurt you.&quot;;</a>
<a name="ln941"> </a>
<a name="ln942">    if (abil.flags &amp; abflag::exhaustion)</a>
<a name="ln943">        ret &lt;&lt; &quot;\nIt causes exhaustion, and cannot be used when exhausted.&quot;;</a>
<a name="ln944"> </a>
<a name="ln945">    if (abil.flags &amp; abflag::instant)</a>
<a name="ln946">        ret &lt;&lt; &quot;\nIt is instantaneous.&quot;;</a>
<a name="ln947"> </a>
<a name="ln948">    if (abil.flags &amp; abflag::conf_ok)</a>
<a name="ln949">        ret &lt;&lt; &quot;\nYou can use it even if confused.&quot;;</a>
<a name="ln950"> </a>
<a name="ln951">    if (abil.flags &amp; abflag::skill_drain)</a>
<a name="ln952">        ret &lt;&lt; &quot;\nIt will temporarily drain your skills when used.&quot;;</a>
<a name="ln953"> </a>
<a name="ln954">    if (abil.ability == ABIL_HEAL_WOUNDS)</a>
<a name="ln955">    {</a>
<a name="ln956">        ret &lt;&lt; &quot;\nIt has a chance of reducing your maximum magic capacity &quot;</a>
<a name="ln957">               &quot;when used.&quot;;</a>
<a name="ln958">    }</a>
<a name="ln959"> </a>
<a name="ln960">    return ret.str();</a>
<a name="ln961">}</a>
<a name="ln962"> </a>
<a name="ln963">ability_type fixup_ability(ability_type ability)</a>
<a name="ln964">{</a>
<a name="ln965">    switch (ability)</a>
<a name="ln966">    {</a>
<a name="ln967">    case ABIL_YRED_ANIMATE_REMAINS:</a>
<a name="ln968">        // suppress animate remains once animate dead is unlocked (ugh)</a>
<a name="ln969">        if (in_good_standing(GOD_YREDELEMNUL, 2))</a>
<a name="ln970">            return ABIL_NON_ABILITY;</a>
<a name="ln971">        return ability;</a>
<a name="ln972"> </a>
<a name="ln973">    case ABIL_YRED_RECALL_UNDEAD_SLAVES:</a>
<a name="ln974">    case ABIL_BEOGH_RECALL_ORCISH_FOLLOWERS:</a>
<a name="ln975">        if (!you.recall_list.empty())</a>
<a name="ln976">            return ABIL_STOP_RECALL;</a>
<a name="ln977">        return ability;</a>
<a name="ln978"> </a>
<a name="ln979">    case ABIL_EVOKE_BERSERK:</a>
<a name="ln980">    case ABIL_TROG_BERSERK:</a>
<a name="ln981">        if (you.is_lifeless_undead(false)</a>
<a name="ln982">            || you.species == SP_FORMICID)</a>
<a name="ln983">        {</a>
<a name="ln984">            return ABIL_NON_ABILITY;</a>
<a name="ln985">        }</a>
<a name="ln986">        return ability;</a>
<a name="ln987"> </a>
<a name="ln988">    case ABIL_BLINK:</a>
<a name="ln989">    case ABIL_EVOKE_BLINK:</a>
<a name="ln990">        if (you.species == SP_FORMICID)</a>
<a name="ln991">            return ABIL_NON_ABILITY;</a>
<a name="ln992">        else</a>
<a name="ln993">            return ability;</a>
<a name="ln994"> </a>
<a name="ln995">    case ABIL_LUGONU_ABYSS_EXIT:</a>
<a name="ln996">    case ABIL_LUGONU_ABYSS_ENTER:</a>
<a name="ln997">        if (brdepth[BRANCH_ABYSS] == -1)</a>
<a name="ln998">            return ABIL_NON_ABILITY;</a>
<a name="ln999">        else</a>
<a name="ln1000">            return ability;</a>
<a name="ln1001"> </a>
<a name="ln1002">    case ABIL_TSO_BLESS_WEAPON:</a>
<a name="ln1003">    case ABIL_KIKU_BLESS_WEAPON:</a>
<a name="ln1004">    case ABIL_LUGONU_BLESS_WEAPON:</a>
<a name="ln1005">        if (you.species == SP_FELID)</a>
<a name="ln1006">            return ABIL_NON_ABILITY;</a>
<a name="ln1007">        else</a>
<a name="ln1008">            return ability;</a>
<a name="ln1009"> </a>
<a name="ln1010">    case ABIL_ELYVILON_HEAL_OTHER:</a>
<a name="ln1011">    case ABIL_TSO_SUMMON_DIVINE_WARRIOR:</a>
<a name="ln1012">    case ABIL_MAKHLEB_LESSER_SERVANT_OF_MAKHLEB:</a>
<a name="ln1013">    case ABIL_MAKHLEB_GREATER_SERVANT_OF_MAKHLEB:</a>
<a name="ln1014">    case ABIL_TROG_BROTHERS_IN_ARMS:</a>
<a name="ln1015">    case ABIL_GOZAG_BRIBE_BRANCH:</a>
<a name="ln1016">    case ABIL_QAZLAL_ELEMENTAL_FORCE:</a>
<a name="ln1017">        if (you.get_mutation_level(MUT_NO_LOVE))</a>
<a name="ln1018">            return ABIL_NON_ABILITY;</a>
<a name="ln1019">        else</a>
<a name="ln1020">            return ability;</a>
<a name="ln1021"> </a>
<a name="ln1022">    case ABIL_ASHENZARI_TRANSFER_KNOWLEDGE:</a>
<a name="ln1023">        if (you.species == SP_GNOLL)</a>
<a name="ln1024">            return ABIL_NON_ABILITY;</a>
<a name="ln1025">        else</a>
<a name="ln1026">            return ability;</a>
<a name="ln1027"> </a>
<a name="ln1028">    default:</a>
<a name="ln1029">        return ability;</a>
<a name="ln1030">    }</a>
<a name="ln1031">}</a>
<a name="ln1032"> </a>
<a name="ln1033">/// Handle special cases for ability failure chances.</a>
<a name="ln1034">static int _adjusted_failure_chance(ability_type ability, int base_chance)</a>
<a name="ln1035">{</a>
<a name="ln1036">    switch (ability)</a>
<a name="ln1037">    {</a>
<a name="ln1038">    case ABIL_BREATHE_FIRE:</a>
<a name="ln1039">    case ABIL_BREATHE_FROST:</a>
<a name="ln1040">    case ABIL_BREATHE_ACID:</a>
<a name="ln1041">    case ABIL_BREATHE_LIGHTNING:</a>
<a name="ln1042">    case ABIL_BREATHE_POWER:</a>
<a name="ln1043">    case ABIL_BREATHE_MEPHITIC:</a>
<a name="ln1044">    case ABIL_BREATHE_STEAM:</a>
<a name="ln1045">        if (you.form == transformation::dragon)</a>
<a name="ln1046">            return base_chance - 20;</a>
<a name="ln1047">        return base_chance;</a>
<a name="ln1048"> </a>
<a name="ln1049">    case ABIL_BLINK:</a>
<a name="ln1050">        return 48 - (17 * you.get_mutation_level(MUT_BLINK))</a>
<a name="ln1051">                  - you.experience_level / 2;</a>
<a name="ln1052">        break;</a>
<a name="ln1053"> </a>
<a name="ln1054">    case ABIL_NEMELEX_DEAL_FOUR:</a>
<a name="ln1055">        return 70 - (you.piety * 2 / 45) - you.skill(SK_INVOCATIONS, 9) / 2;</a>
<a name="ln1056"> </a>
<a name="ln1057">    default:</a>
<a name="ln1058">        return base_chance;</a>
<a name="ln1059">    }</a>
<a name="ln1060">}</a>
<a name="ln1061"> </a>
<a name="ln1062">talent get_talent(ability_type ability, bool check_confused)</a>
<a name="ln1063">{</a>
<a name="ln1064">    ASSERT(ability != ABIL_NON_ABILITY);</a>
<a name="ln1065"> </a>
<a name="ln1066">    // Placeholder handling, part 1: The ability we have might be a</a>
<a name="ln1067">    // placeholder, so convert it into its corresponding ability before</a>
<a name="ln1068">    // doing anything else, so that we'll handle its flags properly.</a>
<a name="ln1069">    talent result { fixup_ability(ability), 0, 0, false };</a>
<a name="ln1070">    const ability_def &amp;abil = get_ability_def(result.which);</a>
<a name="ln1071"> </a>
<a name="ln1072">    if (check_confused &amp;&amp; you.confused()</a>
<a name="ln1073">        &amp;&amp; !testbits(abil.flags, abflag::conf_ok))</a>
<a name="ln1074">    {</a>
<a name="ln1075">        result.which = ABIL_NON_ABILITY;</a>
<a name="ln1076">        return result;</a>
<a name="ln1077">    }</a>
<a name="ln1078"> </a>
<a name="ln1079">    // Look through the table to see if there's a preference, else find</a>
<a name="ln1080">    // a new empty slot for this ability. - bwr</a>
<a name="ln1081">    const int index = find_ability_slot(abil.ability);</a>
<a name="ln1082">    result.hotkey = index &gt;= 0 ? index_to_letter(index) : 0;</a>
<a name="ln1083"> </a>
<a name="ln1084">    const int base_chance = abil.failure.chance();</a>
<a name="ln1085">    const int failure = _adjusted_failure_chance(ability, base_chance);</a>
<a name="ln1086">    result.fail = max(0, min(100, failure));</a>
<a name="ln1087"> </a>
<a name="ln1088">    result.is_invocation = abil.failure.basis == fail_basis::invo;</a>
<a name="ln1089"> </a>
<a name="ln1090">    return result;</a>
<a name="ln1091">}</a>
<a name="ln1092"> </a>
<a name="ln1093">const char* ability_name(ability_type ability)</a>
<a name="ln1094">{</a>
<a name="ln1095">    return get_ability_def(ability).name;</a>
<a name="ln1096">}</a>
<a name="ln1097"> </a>
<a name="ln1098">vector&lt;const char*&gt; get_ability_names()</a>
<a name="ln1099">{</a>
<a name="ln1100">    vector&lt;const char*&gt; result;</a>
<a name="ln1101">    for (const talent &amp;tal : your_talents(false))</a>
<a name="ln1102">        result.push_back(ability_name(tal.which));</a>
<a name="ln1103">    return result;</a>
<a name="ln1104">}</a>
<a name="ln1105"> </a>
<a name="ln1106">static string _desc_sac_mut(const CrawlStoreValue &amp;mut_store)</a>
<a name="ln1107">{</a>
<a name="ln1108">    return mut_upgrade_summary(static_cast&lt;mutation_type&gt;(mut_store.get_int()));</a>
<a name="ln1109">}</a>
<a name="ln1110"> </a>
<a name="ln1111">static string _sacrifice_desc(const ability_type ability)</a>
<a name="ln1112">{</a>
<a name="ln1113">    const string boilerplate =</a>
<a name="ln1114">        &quot;\nIf you make this sacrifice, your powers granted by Ru &quot;</a>
<a name="ln1115">        &quot;will become stronger in proportion to the value of the &quot;</a>
<a name="ln1116">        &quot;sacrifice, and you may gain new powers as well.\n\n&quot;</a>
<a name="ln1117">        &quot;Sacrifices cannot be taken back.\n&quot;;</a>
<a name="ln1118">    const string piety_info = ru_sacrifice_description(ability);</a>
<a name="ln1119">    const string desc = boilerplate + piety_info;</a>
<a name="ln1120"> </a>
<a name="ln1121">    if (!you_worship(GOD_RU))</a>
<a name="ln1122">        return desc;</a>
<a name="ln1123"> </a>
<a name="ln1124">    const string sac_vec_key = ru_sacrifice_vector(ability);</a>
<a name="ln1125">    if (sac_vec_key.empty())</a>
<a name="ln1126">        return desc;</a>
<a name="ln1127"> </a>
<a name="ln1128">    ASSERT(you.props.exists(sac_vec_key));</a>
<a name="ln1129">    const CrawlVector &amp;sacrifice_muts = you.props[sac_vec_key].get_vector();</a>
<a name="ln1130">    return &quot;\nAfter this sacrifice, you will find that &quot;</a>
<a name="ln1131">            + comma_separated_fn(sacrifice_muts.begin(), sacrifice_muts.end(),</a>
<a name="ln1132">                                 _desc_sac_mut)</a>
<a name="ln1133">            + &quot;.\n&quot; + desc;</a>
<a name="ln1134">}</a>
<a name="ln1135"> </a>
<a name="ln1136">static string _nemelex_desc(ability_type ability)</a>
<a name="ln1137">{</a>
<a name="ln1138">    ostringstream desc;</a>
<a name="ln1139">    deck_type deck = ability_deck(ability);</a>
<a name="ln1140"> </a>
<a name="ln1141">    desc &lt;&lt; &quot;Draw a card from &quot; &lt;&lt; (deck == DECK_STACK ? &quot;your &quot; : &quot;the &quot;);</a>
<a name="ln1142">    desc &lt;&lt; deck_name(deck) &lt;&lt; &quot;; &quot; &lt;&lt; lowercase_first(deck_description(deck));</a>
<a name="ln1143"> </a>
<a name="ln1144">    return desc.str();</a>
<a name="ln1145">}</a>
<a name="ln1146"> </a>
<a name="ln1147">// XXX: should this be in describe.cc?</a>
<a name="ln1148">string get_ability_desc(const ability_type ability, bool need_title)</a>
<a name="ln1149">{</a>
<a name="ln1150">    const string&amp; name = ability_name(ability);</a>
<a name="ln1151"> </a>
<a name="ln1152">    string lookup;</a>
<a name="ln1153"> </a>
<a name="ln1154">    if (testbits(get_ability_def(ability).flags, abflag::card))</a>
<a name="ln1155">        lookup = _nemelex_desc(ability);</a>
<a name="ln1156">    else</a>
<a name="ln1157">        lookup = getLongDescription(name + &quot; ability&quot;);</a>
<a name="ln1158"> </a>
<a name="ln1159">    if (lookup.empty()) // Nothing found?</a>
<a name="ln1160">        lookup = &quot;No description found.\n&quot;;</a>
<a name="ln1161"> </a>
<a name="ln1162">    if (testbits(get_ability_def(ability).flags, abflag::sacrifice))</a>
<a name="ln1163">        lookup += _sacrifice_desc(ability);</a>
<a name="ln1164"> </a>
<a name="ln1165">    if (god_hates_ability(ability, you.religion))</a>
<a name="ln1166">    {</a>
<a name="ln1167">        lookup += uppercase_first(god_name(you.religion))</a>
<a name="ln1168">                  + &quot; frowns upon the use of this ability.\n&quot;;</a>
<a name="ln1169">    }</a>
<a name="ln1170"> </a>
<a name="ln1171">    ostringstream res;</a>
<a name="ln1172">    if (need_title)</a>
<a name="ln1173">        res &lt;&lt; name &lt;&lt; &quot;\n\n&quot;;</a>
<a name="ln1174">    res &lt;&lt; lookup &lt;&lt; &quot;\n&quot; &lt;&lt; _detailed_cost_description(ability);</a>
<a name="ln1175"> </a>
<a name="ln1176">    const string quote = getQuoteString(name + &quot; ability&quot;);</a>
<a name="ln1177">    if (!quote.empty())</a>
<a name="ln1178">        res &lt;&lt; &quot;\n\n&quot; &lt;&lt; quote;</a>
<a name="ln1179"> </a>
<a name="ln1180">    return res.str();</a>
<a name="ln1181">}</a>
<a name="ln1182"> </a>
<a name="ln1183">static void _print_talent_description(const talent&amp; tal)</a>
<a name="ln1184">{</a>
<a name="ln1185">    describe_ability(tal.which);</a>
<a name="ln1186">}</a>
<a name="ln1187"> </a>
<a name="ln1188">void no_ability_msg()</a>
<a name="ln1189">{</a>
<a name="ln1190">    // Give messages if the character cannot use innate talents right now.</a>
<a name="ln1191">    // * Vampires can't turn into bats when full of blood.</a>
<a name="ln1192">    // * Tengu can't start to fly if already flying.</a>
<a name="ln1193">    if (you.species == SP_VAMPIRE &amp;&amp; you.experience_level &gt;= 3)</a>
<a name="ln1194">    {</a>
<a name="ln1195">        if (you.transform_uncancellable)</a>
<a name="ln1196">            mpr(&quot;You can't untransform!&quot;);</a>
<a name="ln1197">        else</a>
<a name="ln1198">        {</a>
<a name="ln1199">            ASSERT(you.vampire_alive);</a>
<a name="ln1200">            mpr(&quot;Sorry, you cannot become a bat while alive.&quot;);</a>
<a name="ln1201">        }</a>
<a name="ln1202">    }</a>
<a name="ln1203">    else if (you.get_mutation_level(MUT_TENGU_FLIGHT)</a>
<a name="ln1204">             || you.get_mutation_level(MUT_BIG_WINGS))</a>
<a name="ln1205">    {</a>
<a name="ln1206">        if (you.airborne())</a>
<a name="ln1207">            mpr(&quot;You're already flying!&quot;);</a>
<a name="ln1208">    }</a>
<a name="ln1209">    else</a>
<a name="ln1210">        mpr(&quot;Sorry, you're not good enough to have a special ability.&quot;);</a>
<a name="ln1211">}</a>
<a name="ln1212"> </a>
<a name="ln1213">bool activate_ability()</a>
<a name="ln1214">{</a>
<a name="ln1215">    vector&lt;talent&gt; talents = your_talents(false);</a>
<a name="ln1216"> </a>
<a name="ln1217">    if (talents.empty())</a>
<a name="ln1218">    {</a>
<a name="ln1219">        no_ability_msg();</a>
<a name="ln1220">        crawl_state.zero_turns_taken();</a>
<a name="ln1221">        return false;</a>
<a name="ln1222">    }</a>
<a name="ln1223"> </a>
<a name="ln1224">    int selected = -1;</a>
<a name="ln1225">#ifndef TOUCH_UI</a>
<a name="ln1226">    if (Options.ability_menu)</a>
<a name="ln1227">#endif</a>
<a name="ln1228">    {</a>
<a name="ln1229">        selected = choose_ability_menu(talents);</a>
<a name="ln1230">        if (selected == -1)</a>
<a name="ln1231">        {</a>
<a name="ln1232">            canned_msg(MSG_OK);</a>
<a name="ln1233">            crawl_state.zero_turns_taken();</a>
<a name="ln1234">            return false;</a>
<a name="ln1235">        }</a>
<a name="ln1236">    }</a>
<a name="ln1237">#ifndef TOUCH_UI</a>
<a name="ln1238">    else</a>
<a name="ln1239">    {</a>
<a name="ln1240">        while (selected &lt; 0)</a>
<a name="ln1241">        {</a>
<a name="ln1242">            msg::streams(MSGCH_PROMPT) &lt;&lt; &quot;Use which ability? (? or * to list) &quot;</a>
<a name="ln1243">                                       &lt;&lt; endl;</a>
<a name="ln1244"> </a>
<a name="ln1245">            const int keyin = get_ch();</a>
<a name="ln1246"> </a>
<a name="ln1247">            if (keyin == '?' || keyin == '*')</a>
<a name="ln1248">            {</a>
<a name="ln1249">                selected = choose_ability_menu(talents);</a>
<a name="ln1250">                if (selected == -1)</a>
<a name="ln1251">                {</a>
<a name="ln1252">                    canned_msg(MSG_OK);</a>
<a name="ln1253">                    crawl_state.zero_turns_taken();</a>
<a name="ln1254">                    return false;</a>
<a name="ln1255">                }</a>
<a name="ln1256">            }</a>
<a name="ln1257">            else if (key_is_escape(keyin) || keyin == ' ' || keyin == '\r'</a>
<a name="ln1258">                     || keyin == '\n')</a>
<a name="ln1259">            {</a>
<a name="ln1260">                canned_msg(MSG_OK);</a>
<a name="ln1261">                crawl_state.zero_turns_taken();</a>
<a name="ln1262">                return false;</a>
<a name="ln1263">            }</a>
<a name="ln1264">            else if (isaalpha(keyin))</a>
<a name="ln1265">            {</a>
<a name="ln1266">                // Try to find the hotkey.</a>
<a name="ln1267">                for (unsigned int i = 0; i &lt; talents.size(); ++i)</a>
<a name="ln1268">                {</a>
<a name="ln1269">                    if (talents[i].hotkey == keyin)</a>
<a name="ln1270">                    {</a>
<a name="ln1271">                        selected = static_cast&lt;int&gt;(i);</a>
<a name="ln1272">                        break;</a>
<a name="ln1273">                    }</a>
<a name="ln1274">                }</a>
<a name="ln1275"> </a>
<a name="ln1276">                // If we can't, cancel out.</a>
<a name="ln1277">                if (selected &lt; 0)</a>
<a name="ln1278">                {</a>
<a name="ln1279">                    mpr(&quot;You can't do that.&quot;);</a>
<a name="ln1280">                    crawl_state.zero_turns_taken();</a>
<a name="ln1281">                    return false;</a>
<a name="ln1282">                }</a>
<a name="ln1283">            }</a>
<a name="ln1284">        }</a>
<a name="ln1285">    }</a>
<a name="ln1286">#endif</a>
<a name="ln1287">    return activate_talent(talents[selected]);</a>
<a name="ln1288">}</a>
<a name="ln1289"> </a>
<a name="ln1290">static bool _can_hop(bool quiet)</a>
<a name="ln1291">{</a>
<a name="ln1292">    if (!you.duration[DUR_NO_HOP])</a>
<a name="ln1293">        return true;</a>
<a name="ln1294">    if (!quiet)</a>
<a name="ln1295">        mpr(&quot;Your legs are too worn out to hop.&quot;);</a>
<a name="ln1296">    return false;</a>
<a name="ln1297">}</a>
<a name="ln1298"> </a>
<a name="ln1299">// Check prerequisites for a number of abilities.</a>
<a name="ln1300">// Abort any attempt if these cannot be met, without losing the turn.</a>
<a name="ln1301">// TODO: Many more cases need to be added!</a>
<a name="ln1302">static bool _check_ability_possible(const ability_def&amp; abil, bool quiet = false)</a>
<a name="ln1303">{</a>
<a name="ln1304">    if (you.berserk() &amp;&amp; !testbits(abil.flags, abflag::berserk_ok))</a>
<a name="ln1305">    {</a>
<a name="ln1306">        if (!quiet)</a>
<a name="ln1307">            canned_msg(MSG_TOO_BERSERK);</a>
<a name="ln1308">        return false;</a>
<a name="ln1309">    }</a>
<a name="ln1310"> </a>
<a name="ln1311">    // Doing these would outright kill the player.</a>
<a name="ln1312">    // (or, in the case of the stat-zeros, they'd at least be extremely</a>
<a name="ln1313">    // dangerous.)</a>
<a name="ln1314">    if (abil.ability == ABIL_STOP_FLYING)</a>
<a name="ln1315">    {</a>
<a name="ln1316">        if (is_feat_dangerous(grd(you.pos()), false, true))</a>
<a name="ln1317">        {</a>
<a name="ln1318">            if (!quiet)</a>
<a name="ln1319">                mpr(&quot;Stopping flight right now would be fatal!&quot;);</a>
<a name="ln1320">            return false;</a>
<a name="ln1321">        }</a>
<a name="ln1322">    }</a>
<a name="ln1323">    else if (abil.ability == ABIL_END_TRANSFORMATION)</a>
<a name="ln1324">    {</a>
<a name="ln1325">        if (feat_dangerous_for_form(transformation::none, env.grid(you.pos())))</a>
<a name="ln1326">        {</a>
<a name="ln1327">            if (!quiet)</a>
<a name="ln1328">            {</a>
<a name="ln1329">                mprf(&quot;Turning back right now would cause you to %s!&quot;,</a>
<a name="ln1330">                    env.grid(you.pos()) == DNGN_LAVA ? &quot;burn&quot; : &quot;drown&quot;);</a>
<a name="ln1331">            }</a>
<a name="ln1332"> </a>
<a name="ln1333">            return false;</a>
<a name="ln1334">        }</a>
<a name="ln1335">    }</a>
<a name="ln1336">    else if ((abil.ability == ABIL_EXSANGUINATE</a>
<a name="ln1337">              || abil.ability == ABIL_REVIVIFY)</a>
<a name="ln1338">            &amp;&amp; you.form != transformation::none)</a>
<a name="ln1339">    {</a>
<a name="ln1340">        if (feat_dangerous_for_form(transformation::none, env.grid(you.pos())))</a>
<a name="ln1341">        {</a>
<a name="ln1342">            if (!quiet)</a>
<a name="ln1343">            {</a>
<a name="ln1344">                mprf(&quot;Becoming %s right now would cause you to %s!&quot;,</a>
<a name="ln1345">                    abil.ability == ABIL_EXSANGUINATE ? &quot;bloodless&quot; : &quot;alive&quot;,</a>
<a name="ln1346">                    env.grid(you.pos()) == DNGN_LAVA ? &quot;burn&quot; : &quot;drown&quot;);</a>
<a name="ln1347">            }</a>
<a name="ln1348"> </a>
<a name="ln1349">            return false;</a>
<a name="ln1350">        }</a>
<a name="ln1351">    }</a>
<a name="ln1352"> </a>
<a name="ln1353">    if ((abil.ability == ABIL_EVOKE_BERSERK</a>
<a name="ln1354">         || abil.ability == ABIL_TROG_BERSERK)</a>
<a name="ln1355">        &amp;&amp; !you.can_go_berserk(true, false, quiet))</a>
<a name="ln1356">    {</a>
<a name="ln1357">        return false;</a>
<a name="ln1358">    }</a>
<a name="ln1359"> </a>
<a name="ln1360">    if ((abil.ability == ABIL_EVOKE_FLIGHT</a>
<a name="ln1361">         || abil.ability == ABIL_TRAN_BAT</a>
<a name="ln1362">         || abil.ability == ABIL_FLY)</a>
<a name="ln1363">        &amp;&amp; !flight_allowed(quiet))</a>
<a name="ln1364">    {</a>
<a name="ln1365">        return false;</a>
<a name="ln1366">    }</a>
<a name="ln1367"> </a>
<a name="ln1368"> </a>
<a name="ln1369">    if (you.confused() &amp;&amp; !testbits(abil.flags, abflag::conf_ok))</a>
<a name="ln1370">    {</a>
<a name="ln1371">        if (!quiet)</a>
<a name="ln1372">            canned_msg(MSG_TOO_CONFUSED);</a>
<a name="ln1373">        return false;</a>
<a name="ln1374">    }</a>
<a name="ln1375"> </a>
<a name="ln1376">    // Silence and water elementals</a>
<a name="ln1377">    if (silenced(you.pos())</a>
<a name="ln1378">        || you.duration[DUR_WATER_HOLD] &amp;&amp; !you.res_water_drowning())</a>
<a name="ln1379">    {</a>
<a name="ln1380">        talent tal = get_talent(abil.ability, false);</a>
<a name="ln1381">        if (tal.is_invocation &amp;&amp; abil.ability != ABIL_RENOUNCE_RELIGION)</a>
<a name="ln1382">        {</a>
<a name="ln1383">            if (!quiet)</a>
<a name="ln1384">            {</a>
<a name="ln1385">                mprf(&quot;You cannot call out to %s while %s.&quot;,</a>
<a name="ln1386">                     god_name(you.religion).c_str(),</a>
<a name="ln1387">                     you.duration[DUR_WATER_HOLD] ? &quot;unable to breathe&quot;</a>
<a name="ln1388">                                                  : &quot;silenced&quot;);</a>
<a name="ln1389">            }</a>
<a name="ln1390">            return false;</a>
<a name="ln1391">        }</a>
<a name="ln1392">    }</a>
<a name="ln1393"> </a>
<a name="ln1394">    if (!testbits(abil.flags, abflag::starve_ok)</a>
<a name="ln1395">        &amp;&amp; apply_starvation_penalties())</a>
<a name="ln1396">    {</a>
<a name="ln1397">        if (!quiet)</a>
<a name="ln1398">            canned_msg(MSG_TOO_HUNGRY);</a>
<a name="ln1399">        return false;</a>
<a name="ln1400">    }</a>
<a name="ln1401"> </a>
<a name="ln1402">    // Don't insta-starve the player.</a>
<a name="ln1403">    // (Losing consciousness possible from 400 downward.)</a>
<a name="ln1404">    if (!testbits(abil.flags, abflag::starve_ok) &amp;&amp; !you.undead_state())</a>
<a name="ln1405">    {</a>
<a name="ln1406">        const hunger_state_t state =</a>
<a name="ln1407">            static_cast&lt;hunger_state_t&gt;(max(0, you.hunger_state - 1));</a>
<a name="ln1408">        const int expected_hunger = hunger_threshold[state]</a>
<a name="ln1409">                                    - abil.food_cost * 2;</a>
<a name="ln1410">        if (!quiet)</a>
<a name="ln1411">        {</a>
<a name="ln1412">            dprf(&quot;hunger: %d, max. food_cost: %d, expected hunger: %d&quot;,</a>
<a name="ln1413">                 you.hunger, abil.food_cost * 2, expected_hunger);</a>
<a name="ln1414">        }</a>
<a name="ln1415">        // Safety margin for natural hunger, mutations etc.</a>
<a name="ln1416">        if (expected_hunger &lt;= 50)</a>
<a name="ln1417">        {</a>
<a name="ln1418">            if (!quiet)</a>
<a name="ln1419">                canned_msg(MSG_TOO_HUNGRY);</a>
<a name="ln1420">            return false;</a>
<a name="ln1421">        }</a>
<a name="ln1422">    }</a>
<a name="ln1423"> </a>
<a name="ln1424">    const god_power* god_power = god_power_from_ability(abil.ability);</a>
<a name="ln1425">    if (god_power &amp;&amp; !god_power_usable(*god_power))</a>
<a name="ln1426">    {</a>
<a name="ln1427">        if (!quiet)</a>
<a name="ln1428">            canned_msg(MSG_GOD_DECLINES);</a>
<a name="ln1429">        return false;</a>
<a name="ln1430">    }</a>
<a name="ln1431"> </a>
<a name="ln1432">    if (testbits(abil.flags, abflag::card) &amp;&amp; !deck_cards(ability_deck(abil.ability)))</a>
<a name="ln1433">    {</a>
<a name="ln1434">        if (!quiet)</a>
<a name="ln1435">            mpr(&quot;That deck is empty!&quot;);</a>
<a name="ln1436">        return false;</a>
<a name="ln1437">    }</a>
<a name="ln1438"> </a>
<a name="ln1439">    if (!quiet)</a>
<a name="ln1440">    {</a>
<a name="ln1441">        vector&lt;text_pattern&gt; &amp;actions = Options.confirm_action;</a>
<a name="ln1442">        if (!actions.empty())</a>
<a name="ln1443">        {</a>
<a name="ln1444">            const char* name = ability_name(abil.ability);</a>
<a name="ln1445">            for (const text_pattern &amp;action : actions)</a>
<a name="ln1446">            {</a>
<a name="ln1447">                if (action.matches(name))</a>
<a name="ln1448">                {</a>
<a name="ln1449">                    string prompt = &quot;Really use &quot; + string(name) + &quot;?&quot;;</a>
<a name="ln1450">                    if (!yesno(prompt.c_str(), false, 'n'))</a>
<a name="ln1451">                    {</a>
<a name="ln1452">                        canned_msg(MSG_OK);</a>
<a name="ln1453">                        return false;</a>
<a name="ln1454">                    }</a>
<a name="ln1455">                    break;</a>
<a name="ln1456">                }</a>
<a name="ln1457">            }</a>
<a name="ln1458">        }</a>
<a name="ln1459">    }</a>
<a name="ln1460"> </a>
<a name="ln1461">    // Check that we can afford to pay the costs.</a>
<a name="ln1462">    // Note that mutation shenanigans might leave us with negative MP,</a>
<a name="ln1463">    // so don't fail in that case if there's no MP cost.</a>
<a name="ln1464">    if (abil.mp_cost &gt; 0 &amp;&amp; !enough_mp(abil.mp_cost, quiet, true))</a>
<a name="ln1465">        return false;</a>
<a name="ln1466"> </a>
<a name="ln1467">    const int hpcost = abil.hp_cost.cost(you.hp_max);</a>
<a name="ln1468">    if (hpcost &gt; 0 &amp;&amp; !enough_hp(hpcost, quiet))</a>
<a name="ln1469">        return false;</a>
<a name="ln1470"> </a>
<a name="ln1471">    switch (abil.ability)</a>
<a name="ln1472">    {</a>
<a name="ln1473">    case ABIL_ZIN_RECITE:</a>
<a name="ln1474">    {</a>
<a name="ln1475">        if (!zin_check_able_to_recite(quiet))</a>
<a name="ln1476">            return false;</a>
<a name="ln1477"> </a>
<a name="ln1478">        int result = zin_check_recite_to_monsters(quiet);</a>
<a name="ln1479">        if (result != 1)</a>
<a name="ln1480">        {</a>
<a name="ln1481">            if (!quiet)</a>
<a name="ln1482">            {</a>
<a name="ln1483">                if (result == 0)</a>
<a name="ln1484">                    mpr(&quot;There's no appreciative audience!&quot;);</a>
<a name="ln1485">                else if (result == -1)</a>
<a name="ln1486">                    mpr(&quot;You are not zealous enough to affect this audience!&quot;);</a>
<a name="ln1487">            }</a>
<a name="ln1488">            return false;</a>
<a name="ln1489">        }</a>
<a name="ln1490">        return true;</a>
<a name="ln1491">    }</a>
<a name="ln1492"> </a>
<a name="ln1493">    case ABIL_ZIN_SANCTUARY:</a>
<a name="ln1494">        if (env.sanctuary_time)</a>
<a name="ln1495">        {</a>
<a name="ln1496">            if (!quiet)</a>
<a name="ln1497">                mpr(&quot;There's already a sanctuary in place on this level.&quot;);</a>
<a name="ln1498">            return false;</a>
<a name="ln1499">        }</a>
<a name="ln1500">        return true;</a>
<a name="ln1501"> </a>
<a name="ln1502">    case ABIL_ZIN_DONATE_GOLD:</a>
<a name="ln1503">        if (!you.gold)</a>
<a name="ln1504">        {</a>
<a name="ln1505">            if (!quiet)</a>
<a name="ln1506">                mpr(&quot;You have nothing to donate!&quot;);</a>
<a name="ln1507">            return false;</a>
<a name="ln1508">        }</a>
<a name="ln1509">        return true;</a>
<a name="ln1510"> </a>
<a name="ln1511">    case ABIL_ELYVILON_PURIFICATION:</a>
<a name="ln1512">        if (!you.disease &amp;&amp; !you.duration[DUR_POISONING]</a>
<a name="ln1513">            &amp;&amp; !you.duration[DUR_CONF] &amp;&amp; !you.duration[DUR_SLOW]</a>
<a name="ln1514">            &amp;&amp; !you.petrifying()</a>
<a name="ln1515">            &amp;&amp; you.strength(false) == you.max_strength()</a>
<a name="ln1516">            &amp;&amp; you.intel(false) == you.max_intel()</a>
<a name="ln1517">            &amp;&amp; you.dex(false) == you.max_dex()</a>
<a name="ln1518">            &amp;&amp; !player_rotted()</a>
<a name="ln1519">            &amp;&amp; !you.duration[DUR_WEAK])</a>
<a name="ln1520">        {</a>
<a name="ln1521">            if (!quiet)</a>
<a name="ln1522">                mpr(&quot;Nothing ails you!&quot;);</a>
<a name="ln1523">            return false;</a>
<a name="ln1524">        }</a>
<a name="ln1525">        return true;</a>
<a name="ln1526"> </a>
<a name="ln1527">    case ABIL_LUGONU_ABYSS_EXIT:</a>
<a name="ln1528">        if (!player_in_branch(BRANCH_ABYSS))</a>
<a name="ln1529">        {</a>
<a name="ln1530">            if (!quiet)</a>
<a name="ln1531">                mpr(&quot;You aren't in the Abyss!&quot;);</a>
<a name="ln1532">            return false;</a>
<a name="ln1533">        }</a>
<a name="ln1534">        return true;</a>
<a name="ln1535"> </a>
<a name="ln1536">    case ABIL_LUGONU_CORRUPT:</a>
<a name="ln1537">        return !is_level_incorruptible(quiet);</a>
<a name="ln1538"> </a>
<a name="ln1539">    case ABIL_LUGONU_ABYSS_ENTER:</a>
<a name="ln1540">        if (player_in_branch(BRANCH_ABYSS))</a>
<a name="ln1541">        {</a>
<a name="ln1542">            if (!quiet)</a>
<a name="ln1543">                mpr(&quot;You're already here!&quot;);</a>
<a name="ln1544">            return false;</a>
<a name="ln1545">        }</a>
<a name="ln1546">        return true;</a>
<a name="ln1547"> </a>
<a name="ln1548">    case ABIL_SIF_MUNA_FORGET_SPELL:</a>
<a name="ln1549">        if (you.spell_no == 0)</a>
<a name="ln1550">        {</a>
<a name="ln1551">            if (!quiet)</a>
<a name="ln1552">                canned_msg(MSG_NO_SPELLS);</a>
<a name="ln1553">            return false;</a>
<a name="ln1554">        }</a>
<a name="ln1555">        return true;</a>
<a name="ln1556"> </a>
<a name="ln1557">    case ABIL_SIF_MUNA_DIVINE_EXEGESIS:</a>
<a name="ln1558">        return can_cast_spells(quiet, true);</a>
<a name="ln1559"> </a>
<a name="ln1560">    case ABIL_ASHENZARI_TRANSFER_KNOWLEDGE:</a>
<a name="ln1561">        if (!trainable_skills(true))</a>
<a name="ln1562">        {</a>
<a name="ln1563">            if (!quiet)</a>
<a name="ln1564">                mpr(&quot;You have nothing more to learn.&quot;);</a>
<a name="ln1565">            return false;</a>
<a name="ln1566">        }</a>
<a name="ln1567">        return true;</a>
<a name="ln1568"> </a>
<a name="ln1569">    case ABIL_SPIT_POISON:</a>
<a name="ln1570">    case ABIL_BREATHE_FIRE:</a>
<a name="ln1571">    case ABIL_BREATHE_FROST:</a>
<a name="ln1572">    case ABIL_BREATHE_POISON:</a>
<a name="ln1573">    case ABIL_BREATHE_LIGHTNING:</a>
<a name="ln1574">    case ABIL_BREATHE_ACID:</a>
<a name="ln1575">    case ABIL_BREATHE_POWER:</a>
<a name="ln1576">    case ABIL_BREATHE_STEAM:</a>
<a name="ln1577">    case ABIL_BREATHE_MEPHITIC:</a>
<a name="ln1578">        if (you.duration[DUR_BREATH_WEAPON])</a>
<a name="ln1579">        {</a>
<a name="ln1580">            if (!quiet)</a>
<a name="ln1581">                canned_msg(MSG_CANNOT_DO_YET);</a>
<a name="ln1582">            return false;</a>
<a name="ln1583">        }</a>
<a name="ln1584">        return true;</a>
<a name="ln1585"> </a>
<a name="ln1586">    case ABIL_HEAL_WOUNDS:</a>
<a name="ln1587">        if (you.hp == you.hp_max)</a>
<a name="ln1588">        {</a>
<a name="ln1589">            if (!quiet)</a>
<a name="ln1590">                canned_msg(MSG_FULL_HEALTH);</a>
<a name="ln1591">            return false;</a>
<a name="ln1592">        }</a>
<a name="ln1593">        if (get_real_mp(false) &lt; 1)</a>
<a name="ln1594">        {</a>
<a name="ln1595">            if (!quiet)</a>
<a name="ln1596">                mpr(&quot;You don't have enough innate magic capacity.&quot;);</a>
<a name="ln1597">            return false;</a>
<a name="ln1598">        }</a>
<a name="ln1599">        return true;</a>
<a name="ln1600"> </a>
<a name="ln1601">    case ABIL_SHAFT_SELF:</a>
<a name="ln1602">        return you.can_do_shaft_ability(quiet);</a>
<a name="ln1603"> </a>
<a name="ln1604">    case ABIL_HOP:</a>
<a name="ln1605">        return _can_hop(quiet);</a>
<a name="ln1606"> </a>
<a name="ln1607">    case ABIL_BLINK:</a>
<a name="ln1608">    case ABIL_EVOKE_BLINK:</a>
<a name="ln1609">    {</a>
<a name="ln1610">        const string no_tele_reason = you.no_tele_reason(false, true);</a>
<a name="ln1611">        if (no_tele_reason.empty())</a>
<a name="ln1612">            return true;</a>
<a name="ln1613"> </a>
<a name="ln1614">        if (!quiet)</a>
<a name="ln1615">             mpr(no_tele_reason);</a>
<a name="ln1616">        return false;</a>
<a name="ln1617">    }</a>
<a name="ln1618"> </a>
<a name="ln1619">    case ABIL_EVOKE_BERSERK:</a>
<a name="ln1620">    case ABIL_TROG_BERSERK:</a>
<a name="ln1621">        return you.can_go_berserk(true, false, true)</a>
<a name="ln1622">               &amp;&amp; (quiet || berserk_check_wielded_weapon());</a>
<a name="ln1623"> </a>
<a name="ln1624">    case ABIL_EVOKE_FOG:</a>
<a name="ln1625">        if (cloud_at(you.pos()))</a>
<a name="ln1626">        {</a>
<a name="ln1627">            if (!quiet)</a>
<a name="ln1628">                mpr(&quot;It's too cloudy to do that here.&quot;);</a>
<a name="ln1629">            return false;</a>
<a name="ln1630">        }</a>
<a name="ln1631">        if (env.level_state &amp; LSTATE_STILL_WINDS)</a>
<a name="ln1632">        {</a>
<a name="ln1633">            if (!quiet)</a>
<a name="ln1634">                mpr(&quot;The air is too still for clouds to form.&quot;);</a>
<a name="ln1635">            return false;</a>
<a name="ln1636">        }</a>
<a name="ln1637">        return true;</a>
<a name="ln1638"> </a>
<a name="ln1639">    case ABIL_GOZAG_POTION_PETITION:</a>
<a name="ln1640">        return gozag_setup_potion_petition(quiet);</a>
<a name="ln1641"> </a>
<a name="ln1642">    case ABIL_GOZAG_CALL_MERCHANT:</a>
<a name="ln1643">        return gozag_setup_call_merchant(quiet);</a>
<a name="ln1644"> </a>
<a name="ln1645">    case ABIL_GOZAG_BRIBE_BRANCH:</a>
<a name="ln1646">        return gozag_check_bribe_branch(quiet);</a>
<a name="ln1647"> </a>
<a name="ln1648">    case ABIL_RU_SACRIFICE_EXPERIENCE:</a>
<a name="ln1649">        if (you.experience_level &lt;= RU_SAC_XP_LEVELS)</a>
<a name="ln1650">        {</a>
<a name="ln1651">            if (!quiet)</a>
<a name="ln1652">                mpr(&quot;You don't have enough experience to sacrifice.&quot;);</a>
<a name="ln1653">            return false;</a>
<a name="ln1654">        }</a>
<a name="ln1655">        return true;</a>
<a name="ln1656"> </a>
<a name="ln1657">#if TAG_MAJOR_VERSION == 34</a>
<a name="ln1658">    case ABIL_PAKELLAS_DEVICE_SURGE:</a>
<a name="ln1659">        if (you.magic_points == 0)</a>
<a name="ln1660">        {</a>
<a name="ln1661">            if (!quiet)</a>
<a name="ln1662">                mpr(&quot;You have no magic power.&quot;);</a>
<a name="ln1663">            return false;</a>
<a name="ln1664">        }</a>
<a name="ln1665">        return true;</a>
<a name="ln1666">#endif</a>
<a name="ln1667"> </a>
<a name="ln1668">        // only available while your ancestor is alive.</a>
<a name="ln1669">    case ABIL_HEPLIAKLQANA_IDEALISE:</a>
<a name="ln1670">    case ABIL_HEPLIAKLQANA_RECALL:</a>
<a name="ln1671">    case ABIL_HEPLIAKLQANA_TRANSFERENCE:</a>
<a name="ln1672">        if (hepliaklqana_ancestor() == MID_NOBODY)</a>
<a name="ln1673">        {</a>
<a name="ln1674">            if (!quiet)</a>
<a name="ln1675">            {</a>
<a name="ln1676">                mprf(&quot;%s is still trapped in memory!&quot;,</a>
<a name="ln1677">                     hepliaklqana_ally_name().c_str());</a>
<a name="ln1678">            }</a>
<a name="ln1679">            return false;</a>
<a name="ln1680">        }</a>
<a name="ln1681">        return true;</a>
<a name="ln1682"> </a>
<a name="ln1683">    case ABIL_WU_JIAN_WALLJUMP:</a>
<a name="ln1684">    {</a>
<a name="ln1685">        // TODO: Add check for whether there is any valid landing spot</a>
<a name="ln1686">        if (you.is_nervous())</a>
<a name="ln1687">        {</a>
<a name="ln1688">            if (!quiet)</a>
<a name="ln1689">                mpr(&quot;You are too terrified to wall jump!&quot;);</a>
<a name="ln1690">            return false;</a>
<a name="ln1691">        }</a>
<a name="ln1692">        if (you.attribute[ATTR_HELD])</a>
<a name="ln1693">        {</a>
<a name="ln1694">            if (!quiet)</a>
<a name="ln1695">            {</a>
<a name="ln1696">                mprf(&quot;You cannot wall jump while caught in a %s.&quot;,</a>
<a name="ln1697">                     get_trapping_net(you.pos()) == NON_ITEM ? &quot;web&quot; : &quot;net&quot;);</a>
<a name="ln1698">            }</a>
<a name="ln1699">            return false;</a>
<a name="ln1700">        }</a>
<a name="ln1701">        // Is there a valid place to wall jump?</a>
<a name="ln1702">        bool has_targets = false;</a>
<a name="ln1703">        for (adjacent_iterator ai(you.pos()); ai; ++ai)</a>
<a name="ln1704">            if (feat_can_wall_jump_against(grd(*ai)))</a>
<a name="ln1705">            {</a>
<a name="ln1706">                has_targets = true;</a>
<a name="ln1707">                break;</a>
<a name="ln1708">            }</a>
<a name="ln1709"> </a>
<a name="ln1710">        if (!has_targets)</a>
<a name="ln1711">        {</a>
<a name="ln1712">            if (!quiet)</a>
<a name="ln1713">                mpr(&quot;There is nothing to wall jump against here.&quot;);</a>
<a name="ln1714">            return false;</a>
<a name="ln1715">        }</a>
<a name="ln1716">        return true;</a>
<a name="ln1717">    }</a>
<a name="ln1718"> </a>
<a name="ln1719">    default:</a>
<a name="ln1720">        return true;</a>
<a name="ln1721">    }</a>
<a name="ln1722">}</a>
<a name="ln1723"> </a>
<a name="ln1724">static bool _check_ability_dangerous(const ability_type ability,</a>
<a name="ln1725">                                     bool quiet = false)</a>
<a name="ln1726">{</a>
<a name="ln1727">    if (ability == ABIL_TRAN_BAT)</a>
<a name="ln1728">        return !check_form_stat_safety(transformation::bat, quiet);</a>
<a name="ln1729">    else if (ability == ABIL_END_TRANSFORMATION</a>
<a name="ln1730">             &amp;&amp; !feat_dangerous_for_form(transformation::none,</a>
<a name="ln1731">                                         env.grid(you.pos())))</a>
<a name="ln1732">    {</a>
<a name="ln1733">        return !check_form_stat_safety(transformation::bat, quiet);</a>
<a name="ln1734">    }</a>
<a name="ln1735">    else</a>
<a name="ln1736">        return false;</a>
<a name="ln1737">}</a>
<a name="ln1738"> </a>
<a name="ln1739">bool check_ability_possible(const ability_type ability, bool quiet)</a>
<a name="ln1740">{</a>
<a name="ln1741">    return _check_ability_possible(get_ability_def(ability), quiet);</a>
<a name="ln1742">}</a>
<a name="ln1743"> </a>
<a name="ln1744">bool activate_talent(const talent&amp; tal)</a>
<a name="ln1745">{</a>
<a name="ln1746">    const ability_def&amp; abil = get_ability_def(tal.which);</a>
<a name="ln1747"> </a>
<a name="ln1748">    if (_check_ability_dangerous(abil.ability) || !_check_ability_possible(abil))</a>
<a name="ln1749">    {</a>
<a name="ln1750">        crawl_state.zero_turns_taken();</a>
<a name="ln1751">        return false;</a>
<a name="ln1752">    }</a>
<a name="ln1753"> </a>
<a name="ln1754">    bool fail = random2avg(100, 3) &lt; tal.fail;</a>
<a name="ln1755"> </a>
<a name="ln1756">    const spret ability_result = _do_ability(abil, fail);</a>
<a name="ln1757">    switch (ability_result)</a>
<a name="ln1758">    {</a>
<a name="ln1759">        case spret::success:</a>
<a name="ln1760">            ASSERT(!fail || testbits(abil.flags, abflag::hostile));</a>
<a name="ln1761">            practise_using_ability(abil.ability);</a>
<a name="ln1762">            _pay_ability_costs(abil);</a>
<a name="ln1763">            count_action(tal.is_invocation ? CACT_INVOKE : CACT_ABIL, abil.ability);</a>
<a name="ln1764">            return true;</a>
<a name="ln1765">        case spret::fail:</a>
<a name="ln1766">            mpr(&quot;You fail to use your ability.&quot;);</a>
<a name="ln1767">            you.turn_is_over = true;</a>
<a name="ln1768">            return false;</a>
<a name="ln1769">        case spret::abort:</a>
<a name="ln1770">            crawl_state.zero_turns_taken();</a>
<a name="ln1771">            return false;</a>
<a name="ln1772">        case spret::none:</a>
<a name="ln1773">        default:</a>
<a name="ln1774">            die(&quot;Weird ability return type&quot;);</a>
<a name="ln1775">            return false;</a>
<a name="ln1776">    }</a>
<a name="ln1777">}</a>
<a name="ln1778"> </a>
<a name="ln1779">static int _calc_breath_ability_range(ability_type ability)</a>
<a name="ln1780">{</a>
<a name="ln1781">    int range = 0;</a>
<a name="ln1782"> </a>
<a name="ln1783">    switch (ability)</a>
<a name="ln1784">    {</a>
<a name="ln1785">    case ABIL_BREATHE_ACID:</a>
<a name="ln1786">        range = 3;</a>
<a name="ln1787">        break;</a>
<a name="ln1788">    case ABIL_BREATHE_FIRE:</a>
<a name="ln1789">    case ABIL_BREATHE_FROST:</a>
<a name="ln1790">    case ABIL_SPIT_POISON:</a>
<a name="ln1791">        range = 5;</a>
<a name="ln1792">        break;</a>
<a name="ln1793">    case ABIL_BREATHE_MEPHITIC:</a>
<a name="ln1794">    case ABIL_BREATHE_STEAM:</a>
<a name="ln1795">    case ABIL_BREATHE_POISON:</a>
<a name="ln1796">        range = 6;</a>
<a name="ln1797">        break;</a>
<a name="ln1798">    case ABIL_BREATHE_LIGHTNING:</a>
<a name="ln1799">    case ABIL_BREATHE_POWER:</a>
<a name="ln1800">        range = LOS_MAX_RANGE;</a>
<a name="ln1801">        break;</a>
<a name="ln1802">    default:</a>
<a name="ln1803">        die(&quot;Bad breath type!&quot;);</a>
<a name="ln1804">        break;</a>
<a name="ln1805">    }</a>
<a name="ln1806"> </a>
<a name="ln1807">    return min((int)you.current_vision, range);</a>
<a name="ln1808">}</a>
<a name="ln1809"> </a>
<a name="ln1810">static bool _acid_breath_can_hit(const actor *act)</a>
<a name="ln1811">{</a>
<a name="ln1812">    if (act-&gt;is_monster())</a>
<a name="ln1813">    {</a>
<a name="ln1814">        const monster* mons = act-&gt;as_monster();</a>
<a name="ln1815">        bolt testbeam;</a>
<a name="ln1816">        testbeam.thrower = KILL_YOU;</a>
<a name="ln1817">        zappy(ZAP_BREATHE_ACID, 100, false, testbeam);</a>
<a name="ln1818"> </a>
<a name="ln1819">        return !testbeam.ignores_monster(mons);</a>
<a name="ln1820">    }</a>
<a name="ln1821">    else</a>
<a name="ln1822">        return false;</a>
<a name="ln1823">}</a>
<a name="ln1824"> </a>
<a name="ln1825">/// If the player is stationary, print 'You cannot move.' and return true.</a>
<a name="ln1826">static bool _abort_if_stationary()</a>
<a name="ln1827">{</a>
<a name="ln1828">    if (!you.is_stationary())</a>
<a name="ln1829">        return false;</a>
<a name="ln1830"> </a>
<a name="ln1831">    canned_msg(MSG_CANNOT_MOVE);</a>
<a name="ln1832">    return true;</a>
<a name="ln1833">}</a>
<a name="ln1834"> </a>
<a name="ln1835">static bool _cleansing_flame_affects(const actor *act)</a>
<a name="ln1836">{</a>
<a name="ln1837">    return act-&gt;res_holy_energy() &lt; 3;</a>
<a name="ln1838">}</a>
<a name="ln1839"> </a>
<a name="ln1840">static string _vampire_str_int_info_blurb(string stats_affected)</a>
<a name="ln1841">{</a>
<a name="ln1842">    return make_stringf(&quot;This will reduce your %s to zero. &quot;,</a>
<a name="ln1843">                        stats_affected.c_str());</a>
<a name="ln1844">}</a>
<a name="ln1845"> </a>
<a name="ln1846">/*</a>
<a name="ln1847"> * Create a string which informs the player of the consequences of bat form.</a>
<a name="ln1848"> *</a>
<a name="ln1849"> * @param str_affected Whether the player will cause strength stat zero by</a>
<a name="ln1850"> * Bat Form's stat drain ability cost.</a>
<a name="ln1851"> * @param dex_affected Whether the player will cause dexterity stat zero by</a>
<a name="ln1852"> * Bat Form's stat drain ability cost, disregarding Bat Form's dexterity boost.</a>
<a name="ln1853"> * @param int_affected Whether the player will cause intelligence stat zero by</a>
<a name="ln1854"> * Bat Form's stat drain ability cost.</a>
<a name="ln1855"> * @returns The string prompt to give the player.</a>
<a name="ln1856"> */</a>
<a name="ln1857">static string _vampire_bat_transform_prompt(bool str_affected, bool dex_affected,</a>
<a name="ln1858">                                            bool intel_affected)</a>
<a name="ln1859">{</a>
<a name="ln1860">    string prompt = &quot;&quot;;</a>
<a name="ln1861"> </a>
<a name="ln1862">    if (str_affected &amp;&amp; intel_affected)</a>
<a name="ln1863">        prompt += _vampire_str_int_info_blurb(&quot;strength and intelligence&quot;);</a>
<a name="ln1864">    else if (str_affected)</a>
<a name="ln1865">        prompt += _vampire_str_int_info_blurb(&quot;strength&quot;);</a>
<a name="ln1866">    else if (intel_affected)</a>
<a name="ln1867">        prompt += _vampire_str_int_info_blurb(&quot;intelligence&quot;);</a>
<a name="ln1868"> </a>
<a name="ln1869">    // Bat form's dexterity boost will keep a vampire's dexterity above zero until</a>
<a name="ln1870">    // they untransform.</a>
<a name="ln1871">    if (dex_affected)</a>
<a name="ln1872">        prompt += &quot;This will reduce your dexterity to zero once you untransform. &quot;;</a>
<a name="ln1873"> </a>
<a name="ln1874">    prompt += &quot;Continue?&quot;;</a>
<a name="ln1875"> </a>
<a name="ln1876">    return prompt;</a>
<a name="ln1877">}</a>
<a name="ln1878"> </a>
<a name="ln1879">static bool _stat_affected_by_bat_form_stat_drain(int stat_value)</a>
<a name="ln1880">{</a>
<a name="ln1881">    // We check whether the stat is greater than zero to avoid prompting if a</a>
<a name="ln1882">    // stat is already zero.</a>
<a name="ln1883">    return 0 &lt; stat_value &amp;&amp; stat_value &lt;= VAMPIRE_BAT_FORM_STAT_DRAIN;</a>
<a name="ln1884">}</a>
<a name="ln1885"> </a>
<a name="ln1886">/*</a>
<a name="ln1887"> * Give the player a chance to cancel a bat form transformation which could</a>
<a name="ln1888"> * cause their stats to be drained to zero.</a>
<a name="ln1889"> *</a>
<a name="ln1890"> * @returns Whether the player canceled the transformation.</a>
<a name="ln1891"> */</a>
<a name="ln1892">static bool _player_cancels_vampire_bat_transformation()</a>
<a name="ln1893">{</a>
<a name="ln1894"> </a>
<a name="ln1895">    bool str_affected = _stat_affected_by_bat_form_stat_drain(you.strength());</a>
<a name="ln1896">    bool dex_affected = _stat_affected_by_bat_form_stat_drain(you.dex());</a>
<a name="ln1897">    bool intel_affected = _stat_affected_by_bat_form_stat_drain(you.intel());</a>
<a name="ln1898"> </a>
<a name="ln1899">    // Don't prompt if there's no risk of stat-zero</a>
<a name="ln1900">    if (!str_affected &amp;&amp; !dex_affected &amp;&amp; !intel_affected)</a>
<a name="ln1901">        return false;</a>
<a name="ln1902"> </a>
<a name="ln1903">    string prompt = _vampire_bat_transform_prompt(str_affected, dex_affected,</a>
<a name="ln1904">                                                  intel_affected);</a>
<a name="ln1905"> </a>
<a name="ln1906">    bool proceed_with_transformation = yesno(prompt.c_str(), false, 'n');</a>
<a name="ln1907"> </a>
<a name="ln1908">    if (!proceed_with_transformation)</a>
<a name="ln1909">        canned_msg(MSG_OK);</a>
<a name="ln1910"> </a>
<a name="ln1911">    return !proceed_with_transformation;</a>
<a name="ln1912">}</a>
<a name="ln1913"> </a>
<a name="ln1914">static void _cause_vampire_bat_form_stat_drain()</a>
<a name="ln1915">{</a>
<a name="ln1916">    lose_stat(STAT_STR, VAMPIRE_BAT_FORM_STAT_DRAIN);</a>
<a name="ln1917">    lose_stat(STAT_INT, VAMPIRE_BAT_FORM_STAT_DRAIN);</a>
<a name="ln1918">    lose_stat(STAT_DEX, VAMPIRE_BAT_FORM_STAT_DRAIN);</a>
<a name="ln1919">}</a>
<a name="ln1920"> </a>
<a name="ln1921">/*</a>
<a name="ln1922"> * Use an ability.</a>
<a name="ln1923"> *</a>
<a name="ln1924"> * @param abil The actual ability used.</a>
<a name="ln1925"> * @param fail If true, the ability is doomed to fail, and spret::fail will</a>
<a name="ln1926"> * be returned if the ability is not spret::aborted.</a>
<a name="ln1927"> * @returns Whether the spell succeeded (spret::success), failed (spret::fail),</a>
<a name="ln1928"> *  or was canceled (spret::abort). Never returns spret::none.</a>
<a name="ln1929"> */</a>
<a name="ln1930">static spret _do_ability(const ability_def&amp; abil, bool fail)</a>
<a name="ln1931">{</a>
<a name="ln1932">    dist abild;</a>
<a name="ln1933">    bolt beam;</a>
<a name="ln1934">    dist spd;</a>
<a name="ln1935"> </a>
<a name="ln1936">    // Note: the costs will not be applied until after this switch</a>
<a name="ln1937">    // statement... it's assumed that only failures have returned! - bwr</a>
<a name="ln1938">    switch (abil.ability)</a>
<a name="ln1939">    {</a>
<a name="ln1940">    case ABIL_HEAL_WOUNDS:</a>
<a name="ln1941">        fail_check();</a>
<a name="ln1942">        if (one_chance_in(4))</a>
<a name="ln1943">        {</a>
<a name="ln1944">            mpr(&quot;Your magical essence is drained by the effort!&quot;);</a>
<a name="ln1945">            rot_mp(1);</a>
<a name="ln1946">        }</a>
<a name="ln1947">        potionlike_effect(POT_HEAL_WOUNDS, 40);</a>
<a name="ln1948">        break;</a>
<a name="ln1949"> </a>
<a name="ln1950">    case ABIL_DIG:</a>
<a name="ln1951">        fail_check();</a>
<a name="ln1952">        if (!you.digging)</a>
<a name="ln1953">        {</a>
<a name="ln1954">            you.digging = true;</a>
<a name="ln1955">            mpr(&quot;You extend your mandibles.&quot;);</a>
<a name="ln1956">        }</a>
<a name="ln1957">        else</a>
<a name="ln1958">        {</a>
<a name="ln1959">            you.digging = false;</a>
<a name="ln1960">            mpr(&quot;You retract your mandibles.&quot;);</a>
<a name="ln1961">        }</a>
<a name="ln1962">        break;</a>
<a name="ln1963"> </a>
<a name="ln1964">    case ABIL_SHAFT_SELF:</a>
<a name="ln1965">        fail_check();</a>
<a name="ln1966">        if (you.can_do_shaft_ability(false))</a>
<a name="ln1967">        {</a>
<a name="ln1968">            if (yesno(&quot;Are you sure you want to shaft yourself?&quot;, true, 'n'))</a>
<a name="ln1969">                start_delay&lt;ShaftSelfDelay&gt;(1);</a>
<a name="ln1970">            else</a>
<a name="ln1971">                return spret::abort;</a>
<a name="ln1972">        }</a>
<a name="ln1973">        else</a>
<a name="ln1974">            return spret::abort;</a>
<a name="ln1975">        break;</a>
<a name="ln1976"> </a>
<a name="ln1977">    case ABIL_HOP:</a>
<a name="ln1978">        if (_can_hop(false))</a>
<a name="ln1979">            return frog_hop(fail);</a>
<a name="ln1980">        else</a>
<a name="ln1981">            return spret::abort;</a>
<a name="ln1982"> </a>
<a name="ln1983">    case ABIL_SPIT_POISON:      // Naga poison spit</a>
<a name="ln1984">    {</a>
<a name="ln1985">        int power = 10 + you.experience_level;</a>
<a name="ln1986">        beam.range = _calc_breath_ability_range(abil.ability);</a>
<a name="ln1987"> </a>
<a name="ln1988">        if (!spell_direction(abild, beam)</a>
<a name="ln1989">            || !player_tracer(ZAP_SPIT_POISON, power, beam))</a>
<a name="ln1990">        {</a>
<a name="ln1991">            return spret::abort;</a>
<a name="ln1992">        }</a>
<a name="ln1993">        else</a>
<a name="ln1994">        {</a>
<a name="ln1995">            fail_check();</a>
<a name="ln1996">            zapping(ZAP_SPIT_POISON, power, beam);</a>
<a name="ln1997">            you.set_duration(DUR_BREATH_WEAPON, 3 + random2(5));</a>
<a name="ln1998">        }</a>
<a name="ln1999">        break;</a>
<a name="ln2000">    }</a>
<a name="ln2001"> </a>
<a name="ln2002">    case ABIL_BREATHE_ACID:       // Draconian acid splash</a>
<a name="ln2003">    {</a>
<a name="ln2004">        beam.range = _calc_breath_ability_range(abil.ability);</a>
<a name="ln2005">        targeter_splash hitfunc(&amp;you, beam.range);</a>
<a name="ln2006">        direction_chooser_args args;</a>
<a name="ln2007">        args.mode = TARG_HOSTILE;</a>
<a name="ln2008">        args.hitfunc = &amp;hitfunc;</a>
<a name="ln2009">        if (!spell_direction(abild, beam, &amp;args))</a>
<a name="ln2010">          return spret::abort;</a>
<a name="ln2011"> </a>
<a name="ln2012">        if (stop_attack_prompt(hitfunc, &quot;spit at&quot;, _acid_breath_can_hit))</a>
<a name="ln2013">          return spret::abort;</a>
<a name="ln2014"> </a>
<a name="ln2015">        fail_check();</a>
<a name="ln2016">        zapping(ZAP_BREATHE_ACID, (you.form == transformation::dragon) ?</a>
<a name="ln2017">                2 * you.experience_level : you.experience_level,</a>
<a name="ln2018">                beam, false, &quot;You spit a glob of acid.&quot;);</a>
<a name="ln2019"> </a>
<a name="ln2020">        you.increase_duration(DUR_BREATH_WEAPON,</a>
<a name="ln2021">                          3 + random2(10) + random2(30 - you.experience_level));</a>
<a name="ln2022">        break;</a>
<a name="ln2023">    }</a>
<a name="ln2024"> </a>
<a name="ln2025">    case ABIL_BREATHE_FIRE:</a>
<a name="ln2026">    case ABIL_BREATHE_FROST:</a>
<a name="ln2027">    case ABIL_BREATHE_POISON:</a>
<a name="ln2028">    case ABIL_BREATHE_POWER:</a>
<a name="ln2029">    case ABIL_BREATHE_STEAM:</a>
<a name="ln2030">    case ABIL_BREATHE_MEPHITIC:</a>
<a name="ln2031">        beam.range = _calc_breath_ability_range(abil.ability);</a>
<a name="ln2032">        if (!spell_direction(abild, beam))</a>
<a name="ln2033">            return spret::abort;</a>
<a name="ln2034"> </a>
<a name="ln2035">        // fallthrough to ABIL_BREATHE_LIGHTNING</a>
<a name="ln2036"> </a>
<a name="ln2037">    case ABIL_BREATHE_LIGHTNING: // not targeted</a>
<a name="ln2038">        fail_check();</a>
<a name="ln2039"> </a>
<a name="ln2040">        // TODO: refactor this to use only one call to zapping(), don't</a>
<a name="ln2041">        // duplicate its fail_check(), split out breathe_lightning, etc</a>
<a name="ln2042"> </a>
<a name="ln2043">        switch (abil.ability)</a>
<a name="ln2044">        {</a>
<a name="ln2045">        case ABIL_BREATHE_FIRE:</a>
<a name="ln2046">        {</a>
<a name="ln2047">            int power = you.experience_level;</a>
<a name="ln2048"> </a>
<a name="ln2049">            if (you.form == transformation::dragon)</a>
<a name="ln2050">                power += 12;</a>
<a name="ln2051"> </a>
<a name="ln2052">            string msg = &quot;You breathe a blast of fire&quot;;</a>
<a name="ln2053">            msg += (power &lt; 15) ? '.' : '!';</a>
<a name="ln2054"> </a>
<a name="ln2055">            if (zapping(ZAP_BREATHE_FIRE, power, beam, true, msg.c_str())</a>
<a name="ln2056">                == spret::abort)</a>
<a name="ln2057">            {</a>
<a name="ln2058">                return spret::abort;</a>
<a name="ln2059">            }</a>
<a name="ln2060">            break;</a>
<a name="ln2061">        }</a>
<a name="ln2062"> </a>
<a name="ln2063">        case ABIL_BREATHE_FROST:</a>
<a name="ln2064">            if (zapping(ZAP_BREATHE_FROST,</a>
<a name="ln2065">                        you.form == transformation::dragon</a>
<a name="ln2066">                            ? 2 * you.experience_level : you.experience_level,</a>
<a name="ln2067">                        beam, true, &quot;You exhale a wave of freezing cold.&quot;)</a>
<a name="ln2068">                == spret::abort)</a>
<a name="ln2069">            {</a>
<a name="ln2070">                return spret::abort;</a>
<a name="ln2071">            }</a>
<a name="ln2072">            break;</a>
<a name="ln2073"> </a>
<a name="ln2074">        case ABIL_BREATHE_POISON:</a>
<a name="ln2075">            if (zapping(ZAP_BREATHE_POISON, you.experience_level, beam, true,</a>
<a name="ln2076">                        &quot;You exhale a blast of poison gas.&quot;)</a>
<a name="ln2077">                == spret::abort)</a>
<a name="ln2078">            {</a>
<a name="ln2079">                return spret::abort;</a>
<a name="ln2080">            }</a>
<a name="ln2081">            break;</a>
<a name="ln2082"> </a>
<a name="ln2083">        case ABIL_BREATHE_LIGHTNING:</a>
<a name="ln2084">            mpr(&quot;You breathe a wild blast of lightning!&quot;);</a>
<a name="ln2085">            black_drac_breath();</a>
<a name="ln2086">            break;</a>
<a name="ln2087"> </a>
<a name="ln2088">        case ABIL_BREATHE_ACID:</a>
<a name="ln2089">            if (zapping(ZAP_BREATHE_ACID,</a>
<a name="ln2090">                        you.form == transformation::dragon</a>
<a name="ln2091">                            ? 2 * you.experience_level : you.experience_level,</a>
<a name="ln2092">                        beam, true, &quot;You spit a glob of acid.&quot;)</a>
<a name="ln2093">                == spret::abort)</a>
<a name="ln2094">            {</a>
<a name="ln2095">                return spret::abort;</a>
<a name="ln2096">            }</a>
<a name="ln2097">            break;</a>
<a name="ln2098"> </a>
<a name="ln2099">        case ABIL_BREATHE_POWER:</a>
<a name="ln2100">            if (zapping(ZAP_BREATHE_POWER,</a>
<a name="ln2101">                        you.form == transformation::dragon</a>
<a name="ln2102">                            ? 2 * you.experience_level : you.experience_level,</a>
<a name="ln2103">                        beam, true, &quot;You breathe a bolt of dispelling energy.&quot;)</a>
<a name="ln2104">                == spret::abort)</a>
<a name="ln2105">            {</a>
<a name="ln2106">                return spret::abort;</a>
<a name="ln2107">            }</a>
<a name="ln2108">            break;</a>
<a name="ln2109"> </a>
<a name="ln2110">        case ABIL_BREATHE_STEAM:</a>
<a name="ln2111">            if (zapping(ZAP_BREATHE_STEAM,</a>
<a name="ln2112">                        you.form == transformation::dragon</a>
<a name="ln2113">                            ? 2 * you.experience_level : you.experience_level,</a>
<a name="ln2114">                        beam, true, &quot;You exhale a blast of scalding steam.&quot;)</a>
<a name="ln2115">                == spret::abort)</a>
<a name="ln2116">            {</a>
<a name="ln2117">                return spret::abort;</a>
<a name="ln2118">            }</a>
<a name="ln2119">            break;</a>
<a name="ln2120"> </a>
<a name="ln2121">        case ABIL_BREATHE_MEPHITIC:</a>
<a name="ln2122">            if (zapping(ZAP_BREATHE_MEPHITIC,</a>
<a name="ln2123">                        you.form == transformation::dragon</a>
<a name="ln2124">                            ? 2 * you.experience_level : you.experience_level,</a>
<a name="ln2125">                        beam, true, &quot;You exhale a blast of noxious fumes.&quot;)</a>
<a name="ln2126">                == spret::abort)</a>
<a name="ln2127">            {</a>
<a name="ln2128">                return spret::abort;</a>
<a name="ln2129">            }</a>
<a name="ln2130">            break;</a>
<a name="ln2131"> </a>
<a name="ln2132">        default:</a>
<a name="ln2133">            break;</a>
<a name="ln2134">        }</a>
<a name="ln2135"> </a>
<a name="ln2136">        you.increase_duration(DUR_BREATH_WEAPON,</a>
<a name="ln2137">                      3 + random2(10) + random2(30 - you.experience_level));</a>
<a name="ln2138"> </a>
<a name="ln2139">        if (abil.ability == ABIL_BREATHE_STEAM)</a>
<a name="ln2140">            you.duration[DUR_BREATH_WEAPON] /= 2;</a>
<a name="ln2141"> </a>
<a name="ln2142">        break;</a>
<a name="ln2143"> </a>
<a name="ln2144">    case ABIL_EVOKE_BLINK:      // randarts</a>
<a name="ln2145">        fail_check();</a>
<a name="ln2146">        // deliberate fall-through</a>
<a name="ln2147">    case ABIL_BLINK:            // mutation</a>
<a name="ln2148">        return cast_blink(fail);</a>
<a name="ln2149">        break;</a>
<a name="ln2150"> </a>
<a name="ln2151">    case ABIL_EVOKE_BERSERK:    // amulet of rage, randarts</a>
<a name="ln2152">        fail_check();</a>
<a name="ln2153">        you.go_berserk(true);</a>
<a name="ln2154">        break;</a>
<a name="ln2155"> </a>
<a name="ln2156">    case ABIL_FLY:</a>
<a name="ln2157">        fail_check();</a>
<a name="ln2158">        // Te or Dr/Gr wings</a>
<a name="ln2159">        if (you.racial_permanent_flight())</a>
<a name="ln2160">        {</a>
<a name="ln2161">            you.attribute[ATTR_PERM_FLIGHT] = 1;</a>
<a name="ln2162">            float_player();</a>
<a name="ln2163">        }</a>
<a name="ln2164">        if (you.species == SP_TENGU)</a>
<a name="ln2165">            mpr(&quot;You feel very comfortable in the air.&quot;);</a>
<a name="ln2166">        break;</a>
<a name="ln2167"> </a>
<a name="ln2168">    // DEMONIC POWERS:</a>
<a name="ln2169">    case ABIL_DAMNATION:</a>
<a name="ln2170">        fail_check();</a>
<a name="ln2171">        if (your_spells(SPELL_HURL_DAMNATION,</a>
<a name="ln2172">                        you.experience_level * 10,</a>
<a name="ln2173">                        false) == spret::abort)</a>
<a name="ln2174">        {</a>
<a name="ln2175">            return spret::abort;</a>
<a name="ln2176">        }</a>
<a name="ln2177">        break;</a>
<a name="ln2178"> </a>
<a name="ln2179">    case ABIL_EVOKE_TURN_INVISIBLE:     // cloaks, randarts</a>
<a name="ln2180">        if (!invis_allowed())</a>
<a name="ln2181">            return spret::abort;</a>
<a name="ln2182">        fail_check();</a>
<a name="ln2183">#if TAG_MAJOR_VERSION == 34</a>
<a name="ln2184">        surge_power(you.spec_evoke());</a>
<a name="ln2185">#endif</a>
<a name="ln2186">        potionlike_effect(POT_INVISIBILITY,</a>
<a name="ln2187">                          player_adjust_evoc_power(</a>
<a name="ln2188">                              you.skill(SK_EVOCATIONS, 2) + 5));</a>
<a name="ln2189">        contaminate_player(1000 + random2(2000), true);</a>
<a name="ln2190">        break;</a>
<a name="ln2191"> </a>
<a name="ln2192">#if TAG_MAJOR_VERSION == 34</a>
<a name="ln2193">    case ABIL_EVOKE_TURN_VISIBLE:</a>
<a name="ln2194">        fail_check();</a>
<a name="ln2195">        ASSERT(!you.attribute[ATTR_INVIS_UNCANCELLABLE]);</a>
<a name="ln2196">        mpr(&quot;You feel less transparent.&quot;);</a>
<a name="ln2197">        you.duration[DUR_INVIS] = 1;</a>
<a name="ln2198">        break;</a>
<a name="ln2199">#endif</a>
<a name="ln2200"> </a>
<a name="ln2201">    case ABIL_EVOKE_FLIGHT:             // ring, boots, randarts</a>
<a name="ln2202">        fail_check();</a>
<a name="ln2203">        ASSERT(!get_form()-&gt;forbids_flight());</a>
<a name="ln2204">        if (you.wearing_ego(EQ_ALL_ARMOUR, SPARM_FLYING))</a>
<a name="ln2205">        {</a>
<a name="ln2206">            bool standing = !you.airborne();</a>
<a name="ln2207">            you.attribute[ATTR_PERM_FLIGHT] = 1;</a>
<a name="ln2208">            if (standing)</a>
<a name="ln2209">                float_player();</a>
<a name="ln2210">            else</a>
<a name="ln2211">                mpr(&quot;You feel more buoyant.&quot;);</a>
<a name="ln2212">        }</a>
<a name="ln2213">        else</a>
<a name="ln2214">        {</a>
<a name="ln2215">#if TAG_MAJOR_VERSION == 34</a>
<a name="ln2216">            surge_power(you.spec_evoke());</a>
<a name="ln2217">#endif</a>
<a name="ln2218">            fly_player(</a>
<a name="ln2219">                player_adjust_evoc_power(you.skill(SK_EVOCATIONS, 2) + 30));</a>
<a name="ln2220">        }</a>
<a name="ln2221">        break;</a>
<a name="ln2222"> </a>
<a name="ln2223">    case ABIL_EVOKE_FOG:     // cloak of the Thief</a>
<a name="ln2224">        fail_check();</a>
<a name="ln2225">        mpr(&quot;With a swish of your cloak, you release a cloud of fog.&quot;);</a>
<a name="ln2226">        big_cloud(random_smoke_type(), &amp;you, you.pos(), 50, 8 + random2(8));</a>
<a name="ln2227">        break;</a>
<a name="ln2228"> </a>
<a name="ln2229">    case ABIL_EVOKE_RATSKIN: // ratskin cloak</a>
<a name="ln2230">        fail_check();</a>
<a name="ln2231">        mpr(&quot;The rats of the Dungeon answer your call.&quot;);</a>
<a name="ln2232"> </a>
<a name="ln2233">        for (int i = 0; i &lt; (coinflip() + 1); ++i)</a>
<a name="ln2234">        {</a>
<a name="ln2235">            monster_type mon = coinflip() ? MONS_HELL_RAT : MONS_RIVER_RAT;</a>
<a name="ln2236"> </a>
<a name="ln2237">            mgen_data mg(mon, BEH_FRIENDLY, you.pos(), MHITYOU);</a>
<a name="ln2238">            if (monster *m = create_monster(mg))</a>
<a name="ln2239">                m-&gt;add_ench(mon_enchant(ENCH_FAKE_ABJURATION, 3));</a>
<a name="ln2240">        }</a>
<a name="ln2241"> </a>
<a name="ln2242">        break;</a>
<a name="ln2243"> </a>
<a name="ln2244">    case ABIL_EVOKE_THUNDER: // robe of Clouds</a>
<a name="ln2245">        fail_check();</a>
<a name="ln2246">        mpr(&quot;The folds of your robe billow into a mighty storm.&quot;);</a>
<a name="ln2247"> </a>
<a name="ln2248">        for (radius_iterator ri(you.pos(), 2, C_SQUARE); ri; ++ri)</a>
<a name="ln2249">            if (!cell_is_solid(*ri))</a>
<a name="ln2250">                place_cloud(CLOUD_STORM, *ri, 8 + random2avg(8,2), &amp;you);</a>
<a name="ln2251"> </a>
<a name="ln2252">        break;</a>
<a name="ln2253"> </a>
<a name="ln2254">    case ABIL_CANCEL_PPROJ:</a>
<a name="ln2255">        fail_check();</a>
<a name="ln2256">        you.duration[DUR_PORTAL_PROJECTILE] = 0;</a>
<a name="ln2257">        you.attribute[ATTR_PORTAL_PROJECTILE] = 0;</a>
<a name="ln2258">        mpr(&quot;You are no longer teleporting projectiles to their destination.&quot;);</a>
<a name="ln2259">        break;</a>
<a name="ln2260"> </a>
<a name="ln2261">    case ABIL_STOP_FLYING:</a>
<a name="ln2262">        fail_check();</a>
<a name="ln2263">        you.duration[DUR_FLIGHT] = 0;</a>
<a name="ln2264">        you.attribute[ATTR_PERM_FLIGHT] = 0;</a>
<a name="ln2265">        land_player();</a>
<a name="ln2266">        break;</a>
<a name="ln2267"> </a>
<a name="ln2268">    case ABIL_END_TRANSFORMATION:</a>
<a name="ln2269">        fail_check();</a>
<a name="ln2270">        untransform();</a>
<a name="ln2271">        break;</a>
<a name="ln2272"> </a>
<a name="ln2273">    // INVOCATIONS:</a>
<a name="ln2274">    case ABIL_ZIN_RECITE:</a>
<a name="ln2275">    {</a>
<a name="ln2276">        fail_check();</a>
<a name="ln2277">        if (zin_check_recite_to_monsters() == 1)</a>
<a name="ln2278">        {</a>
<a name="ln2279">            you.attribute[ATTR_RECITE_TYPE] = (recite_type) random2(NUM_RECITE_TYPES); // This is just flavor</a>
<a name="ln2280">            you.attribute[ATTR_RECITE_SEED] = random2(2187); // 3^7</a>
<a name="ln2281">            you.duration[DUR_RECITE] = 3 * BASELINE_DELAY;</a>
<a name="ln2282">            mprf(&quot;You clear your throat and prepare to recite.&quot;);</a>
<a name="ln2283">            you.increase_duration(DUR_RECITE_COOLDOWN,</a>
<a name="ln2284">                                  3 + random2(10) + random2(30));</a>
<a name="ln2285">        }</a>
<a name="ln2286">        else</a>
<a name="ln2287">        {</a>
<a name="ln2288">            canned_msg(MSG_OK);</a>
<a name="ln2289">            return spret::abort;</a>
<a name="ln2290">        }</a>
<a name="ln2291">        break;</a>
<a name="ln2292">    }</a>
<a name="ln2293">    case ABIL_ZIN_VITALISATION:</a>
<a name="ln2294">        fail_check();</a>
<a name="ln2295">        zin_vitalisation();</a>
<a name="ln2296">        break;</a>
<a name="ln2297"> </a>
<a name="ln2298">    case ABIL_ZIN_IMPRISON:</a>
<a name="ln2299">    {</a>
<a name="ln2300">        beam.range = LOS_MAX_RANGE;</a>
<a name="ln2301">        direction_chooser_args args;</a>
<a name="ln2302">        args.restricts = DIR_TARGET;</a>
<a name="ln2303">        args.mode = TARG_HOSTILE;</a>
<a name="ln2304">        args.needs_path = false;</a>
<a name="ln2305">        if (!spell_direction(spd, beam, &amp;args))</a>
<a name="ln2306">            return spret::abort;</a>
<a name="ln2307"> </a>
<a name="ln2308">        if (beam.target == you.pos())</a>
<a name="ln2309">        {</a>
<a name="ln2310">            mpr(&quot;You cannot imprison yourself!&quot;);</a>
<a name="ln2311">            return spret::abort;</a>
<a name="ln2312">        }</a>
<a name="ln2313"> </a>
<a name="ln2314">        monster* mons = monster_at(beam.target);</a>
<a name="ln2315"> </a>
<a name="ln2316">        if (mons == nullptr || !you.can_see(*mons))</a>
<a name="ln2317">        {</a>
<a name="ln2318">            mpr(&quot;There is no monster there to imprison!&quot;);</a>
<a name="ln2319">            return spret::abort;</a>
<a name="ln2320">        }</a>
<a name="ln2321"> </a>
<a name="ln2322">        if (mons_is_firewood(*mons) || mons_is_conjured(mons-&gt;type))</a>
<a name="ln2323">        {</a>
<a name="ln2324">            mpr(&quot;You cannot imprison that!&quot;);</a>
<a name="ln2325">            return spret::abort;</a>
<a name="ln2326">        }</a>
<a name="ln2327"> </a>
<a name="ln2328">        if (mons-&gt;friendly() || mons-&gt;good_neutral())</a>
<a name="ln2329">        {</a>
<a name="ln2330">            mpr(&quot;You cannot imprison a law-abiding creature!&quot;);</a>
<a name="ln2331">            return spret::abort;</a>
<a name="ln2332">        }</a>
<a name="ln2333"> </a>
<a name="ln2334">        fail_check();</a>
<a name="ln2335"> </a>
<a name="ln2336">        int power = 3 + (roll_dice(5, you.skill(SK_INVOCATIONS, 5) + 12) / 26);</a>
<a name="ln2337"> </a>
<a name="ln2338">        if (!cast_imprison(power, mons, -GOD_ZIN))</a>
<a name="ln2339">            return spret::abort;</a>
<a name="ln2340">        break;</a>
<a name="ln2341">    }</a>
<a name="ln2342"> </a>
<a name="ln2343">    case ABIL_ZIN_SANCTUARY:</a>
<a name="ln2344">        fail_check();</a>
<a name="ln2345">        zin_sanctuary();</a>
<a name="ln2346">        break;</a>
<a name="ln2347"> </a>
<a name="ln2348">    case ABIL_ZIN_DONATE_GOLD:</a>
<a name="ln2349">        fail_check();</a>
<a name="ln2350">        zin_donate_gold();</a>
<a name="ln2351">        break;</a>
<a name="ln2352"> </a>
<a name="ln2353">    case ABIL_TSO_DIVINE_SHIELD:</a>
<a name="ln2354">        fail_check();</a>
<a name="ln2355">        tso_divine_shield();</a>
<a name="ln2356">        break;</a>
<a name="ln2357"> </a>
<a name="ln2358">    case ABIL_TSO_CLEANSING_FLAME:</a>
<a name="ln2359">    {</a>
<a name="ln2360">        targeter_radius hitfunc(&amp;you, LOS_SOLID, 2);</a>
<a name="ln2361">        {</a>
<a name="ln2362">            if (stop_attack_prompt(hitfunc, &quot;harm&quot;, _cleansing_flame_affects))</a>
<a name="ln2363">                return spret::abort;</a>
<a name="ln2364">        }</a>
<a name="ln2365">        fail_check();</a>
<a name="ln2366">        cleansing_flame(10 + you.skill_rdiv(SK_INVOCATIONS, 7, 6),</a>
<a name="ln2367">                        cleansing_flame_source::invocation, you.pos(), &amp;you);</a>
<a name="ln2368">        break;</a>
<a name="ln2369">    }</a>
<a name="ln2370"> </a>
<a name="ln2371">    case ABIL_TSO_SUMMON_DIVINE_WARRIOR:</a>
<a name="ln2372">        fail_check();</a>
<a name="ln2373">        summon_holy_warrior(you.skill(SK_INVOCATIONS, 4), false);</a>
<a name="ln2374">        break;</a>
<a name="ln2375"> </a>
<a name="ln2376">    case ABIL_TSO_BLESS_WEAPON:</a>
<a name="ln2377">        fail_check();</a>
<a name="ln2378">        simple_god_message(&quot; will bless one of your weapons.&quot;);</a>
<a name="ln2379">        // included in default force_more_message</a>
<a name="ln2380">        if (!bless_weapon(GOD_SHINING_ONE, SPWPN_HOLY_WRATH, YELLOW))</a>
<a name="ln2381">            return spret::abort;</a>
<a name="ln2382">        break;</a>
<a name="ln2383"> </a>
<a name="ln2384">    case ABIL_KIKU_RECEIVE_CORPSES:</a>
<a name="ln2385">        fail_check();</a>
<a name="ln2386">        kiku_receive_corpses(you.skill(SK_NECROMANCY, 4));</a>
<a name="ln2387">        break;</a>
<a name="ln2388"> </a>
<a name="ln2389">    case ABIL_KIKU_TORMENT:</a>
<a name="ln2390">        fail_check();</a>
<a name="ln2391">        if (!kiku_take_corpse())</a>
<a name="ln2392">        {</a>
<a name="ln2393">            mpr(&quot;There are no corpses to sacrifice!&quot;);</a>
<a name="ln2394">            return spret::abort;</a>
<a name="ln2395">        }</a>
<a name="ln2396">        simple_god_message(&quot; torments the living!&quot;);</a>
<a name="ln2397">        torment(&amp;you, TORMENT_KIKUBAAQUDGHA, you.pos());</a>
<a name="ln2398">        break;</a>
<a name="ln2399"> </a>
<a name="ln2400">    case ABIL_KIKU_BLESS_WEAPON:</a>
<a name="ln2401">        fail_check();</a>
<a name="ln2402">        simple_god_message(&quot; will bloody one of your weapons with pain.&quot;);</a>
<a name="ln2403">        // included in default force_more_message</a>
<a name="ln2404">        if (!bless_weapon(GOD_KIKUBAAQUDGHA, SPWPN_PAIN, RED))</a>
<a name="ln2405">            return spret::abort;</a>
<a name="ln2406">        break;</a>
<a name="ln2407"> </a>
<a name="ln2408">    case ABIL_KIKU_GIFT_NECRONOMICON:</a>
<a name="ln2409">    {</a>
<a name="ln2410">        fail_check();</a>
<a name="ln2411">        if (!kiku_gift_necronomicon())</a>
<a name="ln2412">            return spret::abort;</a>
<a name="ln2413">        break;</a>
<a name="ln2414">    }</a>
<a name="ln2415"> </a>
<a name="ln2416">    case ABIL_YRED_INJURY_MIRROR:</a>
<a name="ln2417">        fail_check();</a>
<a name="ln2418">        if (yred_injury_mirror())</a>
<a name="ln2419">            mpr(&quot;Another wave of unholy energy enters you.&quot;);</a>
<a name="ln2420">        else</a>
<a name="ln2421">        {</a>
<a name="ln2422">            mprf(&quot;You offer yourself to %s, and are filled with unholy energy.&quot;,</a>
<a name="ln2423">                 god_name(you.religion).c_str());</a>
<a name="ln2424">        }</a>
<a name="ln2425">        you.duration[DUR_MIRROR_DAMAGE] = 9 * BASELINE_DELAY</a>
<a name="ln2426">                     + random2avg(you.piety * BASELINE_DELAY, 2) / 10;</a>
<a name="ln2427">        break;</a>
<a name="ln2428"> </a>
<a name="ln2429">    case ABIL_YRED_ANIMATE_REMAINS:</a>
<a name="ln2430">        fail_check();</a>
<a name="ln2431">        canned_msg(MSG_ANIMATE_REMAINS);</a>
<a name="ln2432">        if (animate_remains(you.pos(), CORPSE_BODY, BEH_FRIENDLY,</a>
<a name="ln2433">                            MHITYOU, &amp;you, &quot;&quot;, GOD_YREDELEMNUL) &lt; 0)</a>
<a name="ln2434">        {</a>
<a name="ln2435">            mpr(&quot;There are no remains here to animate!&quot;);</a>
<a name="ln2436">            return spret::abort;</a>
<a name="ln2437">        }</a>
<a name="ln2438">        break;</a>
<a name="ln2439"> </a>
<a name="ln2440">    case ABIL_YRED_ANIMATE_DEAD:</a>
<a name="ln2441">        fail_check();</a>
<a name="ln2442">        canned_msg(MSG_CALL_DEAD);</a>
<a name="ln2443">        animate_dead(&amp;you, you.skill_rdiv(SK_INVOCATIONS) + 1,</a>
<a name="ln2444">                     BEH_FRIENDLY, MHITYOU, &amp;you, &quot;&quot;, GOD_YREDELEMNUL);</a>
<a name="ln2445">        break;</a>
<a name="ln2446"> </a>
<a name="ln2447">    case ABIL_YRED_RECALL_UNDEAD_SLAVES:</a>
<a name="ln2448">        fail_check();</a>
<a name="ln2449">        start_recall(recall_t::yred);</a>
<a name="ln2450">        break;</a>
<a name="ln2451"> </a>
<a name="ln2452">    case ABIL_YRED_DRAIN_LIFE:</a>
<a name="ln2453">    {</a>
<a name="ln2454">        int damage = 0;</a>
<a name="ln2455">        const spret result =</a>
<a name="ln2456">            fire_los_attack_spell(SPELL_DRAIN_LIFE,</a>
<a name="ln2457">                                  you.skill_rdiv(SK_INVOCATIONS),</a>
<a name="ln2458">                                  &amp;you, fail, &amp;damage);</a>
<a name="ln2459">        if (result != spret::success)</a>
<a name="ln2460">            return result;</a>
<a name="ln2461"> </a>
<a name="ln2462">        if (damage &gt; 0)</a>
<a name="ln2463">        {</a>
<a name="ln2464">            mpr(&quot;You feel life flooding into your body.&quot;);</a>
<a name="ln2465">            inc_hp(damage);</a>
<a name="ln2466">        }</a>
<a name="ln2467">        break;</a>
<a name="ln2468">    }</a>
<a name="ln2469"> </a>
<a name="ln2470">    case ABIL_YRED_ENSLAVE_SOUL:</a>
<a name="ln2471">    {</a>
<a name="ln2472">        god_acting gdact;</a>
<a name="ln2473">        beam.range = LOS_MAX_RANGE;</a>
<a name="ln2474">        direction_chooser_args args;</a>
<a name="ln2475">        args.restricts = DIR_TARGET;</a>
<a name="ln2476">        args.mode = TARG_HOSTILE;</a>
<a name="ln2477">        args.needs_path = false;</a>
<a name="ln2478"> </a>
<a name="ln2479">        if (!spell_direction(spd, beam, &amp;args))</a>
<a name="ln2480">            return spret::abort;</a>
<a name="ln2481"> </a>
<a name="ln2482">        if (beam.target == you.pos())</a>
<a name="ln2483">        {</a>
<a name="ln2484">            mpr(&quot;Your soul already belongs to Yredelemnul.&quot;);</a>
<a name="ln2485">            return spret::abort;</a>
<a name="ln2486">        }</a>
<a name="ln2487"> </a>
<a name="ln2488">        monster* mons = monster_at(beam.target);</a>
<a name="ln2489">        if (mons == nullptr || !you.can_see(*mons)</a>
<a name="ln2490">            || !yred_can_enslave_soul(mons))</a>
<a name="ln2491">        {</a>
<a name="ln2492">            mpr(&quot;You see nothing there you can enslave the soul of!&quot;);</a>
<a name="ln2493">            return spret::abort;</a>
<a name="ln2494">        }</a>
<a name="ln2495"> </a>
<a name="ln2496">        // The monster can be no more than lightly wounded/damaged.</a>
<a name="ln2497">        if (mons_get_damage_level(*mons) &gt; MDAM_LIGHTLY_DAMAGED)</a>
<a name="ln2498">        {</a>
<a name="ln2499">            simple_monster_message(*mons, &quot;'s soul is too badly injured.&quot;);</a>
<a name="ln2500">            return spret::abort;</a>
<a name="ln2501">        }</a>
<a name="ln2502">        fail_check();</a>
<a name="ln2503"> </a>
<a name="ln2504">        const int duration = you.skill_rdiv(SK_INVOCATIONS, 3, 4) + 2;</a>
<a name="ln2505">        mons-&gt;add_ench(mon_enchant(ENCH_SOUL_RIPE, 0, &amp;you,</a>
<a name="ln2506">                                   duration * BASELINE_DELAY));</a>
<a name="ln2507">        simple_monster_message(*mons, &quot;'s soul is now ripe for the taking.&quot;);</a>
<a name="ln2508">        break;</a>
<a name="ln2509">    }</a>
<a name="ln2510"> </a>
<a name="ln2511">    case ABIL_OKAWARU_HEROISM:</a>
<a name="ln2512">        fail_check();</a>
<a name="ln2513">        mprf(MSGCH_DURATION, you.duration[DUR_HEROISM]</a>
<a name="ln2514">             ? &quot;You feel more confident with your borrowed prowess.&quot;</a>
<a name="ln2515">             : &quot;You gain the combat prowess of a mighty hero.&quot;);</a>
<a name="ln2516"> </a>
<a name="ln2517">        you.increase_duration(DUR_HEROISM,</a>
<a name="ln2518">                              10 + random2avg(you.skill(SK_INVOCATIONS, 6), 2),</a>
<a name="ln2519">                              100);</a>
<a name="ln2520">        you.redraw_evasion      = true;</a>
<a name="ln2521">        you.redraw_armour_class = true;</a>
<a name="ln2522">        break;</a>
<a name="ln2523"> </a>
<a name="ln2524">    case ABIL_OKAWARU_FINESSE:</a>
<a name="ln2525">        fail_check();</a>
<a name="ln2526">        if (you.duration[DUR_FINESSE])</a>
<a name="ln2527">        {</a>
<a name="ln2528">            // &quot;Your [hand(s)] get{s} new energy.&quot;</a>
<a name="ln2529">            mprf(MSGCH_DURATION, &quot;%s&quot;,</a>
<a name="ln2530">                 you.hands_act(&quot;get&quot;, &quot;new energy.&quot;).c_str());</a>
<a name="ln2531">        }</a>
<a name="ln2532">        else</a>
<a name="ln2533">            mprf(MSGCH_DURATION, &quot;You can now deal lightning-fast blows.&quot;);</a>
<a name="ln2534"> </a>
<a name="ln2535">        you.increase_duration(DUR_FINESSE,</a>
<a name="ln2536">                              10 + random2avg(you.skill(SK_INVOCATIONS, 6), 2),</a>
<a name="ln2537">                              100);</a>
<a name="ln2538"> </a>
<a name="ln2539">        did_god_conduct(DID_HASTY, 8); // Currently irrelevant.</a>
<a name="ln2540">        break;</a>
<a name="ln2541"> </a>
<a name="ln2542">    case ABIL_MAKHLEB_MINOR_DESTRUCTION:</a>
<a name="ln2543">    {</a>
<a name="ln2544">        beam.range = min((int)you.current_vision, 5);</a>
<a name="ln2545"> </a>
<a name="ln2546">        if (!spell_direction(spd, beam))</a>
<a name="ln2547">            return spret::abort;</a>
<a name="ln2548"> </a>
<a name="ln2549">        int power = you.skill(SK_INVOCATIONS, 1)</a>
<a name="ln2550">                    + random2(1 + you.skill(SK_INVOCATIONS, 1))</a>
<a name="ln2551">                    + random2(1 + you.skill(SK_INVOCATIONS, 1));</a>
<a name="ln2552"> </a>
<a name="ln2553">        // Since the actual beam is random, check with BEAM_MMISSILE.</a>
<a name="ln2554">        if (!player_tracer(ZAP_DEBUGGING_RAY, power, beam, beam.range))</a>
<a name="ln2555">            return spret::abort;</a>
<a name="ln2556"> </a>
<a name="ln2557">        fail_check();</a>
<a name="ln2558">        beam.origin_spell = SPELL_NO_SPELL; // let zapping reset this</a>
<a name="ln2559"> </a>
<a name="ln2560">        switch (random2(5))</a>
<a name="ln2561">        {</a>
<a name="ln2562">        case 0: zapping(ZAP_THROW_FLAME, power, beam); break;</a>
<a name="ln2563">        case 1: zapping(ZAP_PAIN, power, beam); break;</a>
<a name="ln2564">        case 2: zapping(ZAP_STONE_ARROW, power, beam); break;</a>
<a name="ln2565">        case 3: zapping(ZAP_SHOCK, power, beam); break;</a>
<a name="ln2566">        case 4: zapping(ZAP_BREATHE_ACID, power / 7, beam); break;</a>
<a name="ln2567">        }</a>
<a name="ln2568">        break;</a>
<a name="ln2569">    }</a>
<a name="ln2570"> </a>
<a name="ln2571">    case ABIL_MAKHLEB_LESSER_SERVANT_OF_MAKHLEB:</a>
<a name="ln2572">        summon_demon_type(random_choose(MONS_HELLWING, MONS_NEQOXEC,</a>
<a name="ln2573">                                        MONS_ORANGE_DEMON, MONS_SMOKE_DEMON,</a>
<a name="ln2574">                                        MONS_YNOXINUL),</a>
<a name="ln2575">                          20 + you.skill(SK_INVOCATIONS, 3),</a>
<a name="ln2576">                          GOD_MAKHLEB, 0, !fail);</a>
<a name="ln2577">        break;</a>
<a name="ln2578"> </a>
<a name="ln2579">    case ABIL_MAKHLEB_MAJOR_DESTRUCTION:</a>
<a name="ln2580">    {</a>
<a name="ln2581">        beam.range = you.current_vision;</a>
<a name="ln2582"> </a>
<a name="ln2583">        if (!spell_direction(spd, beam))</a>
<a name="ln2584">            return spret::abort;</a>
<a name="ln2585"> </a>
<a name="ln2586">        int power = you.skill(SK_INVOCATIONS, 1)</a>
<a name="ln2587">                    + random2(1 + you.skill(SK_INVOCATIONS, 1))</a>
<a name="ln2588">                    + random2(1 + you.skill(SK_INVOCATIONS, 1));</a>
<a name="ln2589"> </a>
<a name="ln2590">        // Since the actual beam is random, check with BEAM_MMISSILE.</a>
<a name="ln2591">        if (!player_tracer(ZAP_DEBUGGING_RAY, power, beam, beam.range))</a>
<a name="ln2592">            return spret::abort;</a>
<a name="ln2593"> </a>
<a name="ln2594">        fail_check();</a>
<a name="ln2595">        {</a>
<a name="ln2596">            beam.origin_spell = SPELL_NO_SPELL; // let zapping reset this</a>
<a name="ln2597">            zap_type ztype =</a>
<a name="ln2598">                random_choose(ZAP_BOLT_OF_FIRE,</a>
<a name="ln2599">                              ZAP_FIREBALL,</a>
<a name="ln2600">                              ZAP_LIGHTNING_BOLT,</a>
<a name="ln2601">                              ZAP_STICKY_FLAME,</a>
<a name="ln2602">                              ZAP_IRON_SHOT,</a>
<a name="ln2603">                              ZAP_BOLT_OF_DRAINING,</a>
<a name="ln2604">                              ZAP_ORB_OF_ELECTRICITY);</a>
<a name="ln2605">            zapping(ztype, power, beam);</a>
<a name="ln2606">        }</a>
<a name="ln2607">        break;</a>
<a name="ln2608">    }</a>
<a name="ln2609"> </a>
<a name="ln2610">    case ABIL_MAKHLEB_GREATER_SERVANT_OF_MAKHLEB:</a>
<a name="ln2611">        summon_demon_type(random_choose(MONS_EXECUTIONER, MONS_GREEN_DEATH,</a>
<a name="ln2612">                                        MONS_BLIZZARD_DEMON, MONS_BALRUG,</a>
<a name="ln2613">                                        MONS_CACODEMON),</a>
<a name="ln2614">                          20 + you.skill(SK_INVOCATIONS, 3),</a>
<a name="ln2615">                          GOD_MAKHLEB, 0, !fail);</a>
<a name="ln2616">        break;</a>
<a name="ln2617"> </a>
<a name="ln2618">    case ABIL_TROG_BERSERK:</a>
<a name="ln2619">        fail_check();</a>
<a name="ln2620">        // Trog abilities don't use or train invocations.</a>
<a name="ln2621">        you.go_berserk(true);</a>
<a name="ln2622">        break;</a>
<a name="ln2623"> </a>
<a name="ln2624">    case ABIL_TROG_REGEN_MR:</a>
<a name="ln2625">        fail_check();</a>
<a name="ln2626">        // Trog abilities don't use or train invocations.</a>
<a name="ln2627">        trog_do_trogs_hand(you.piety / 2);</a>
<a name="ln2628">        break;</a>
<a name="ln2629"> </a>
<a name="ln2630">    case ABIL_TROG_BROTHERS_IN_ARMS:</a>
<a name="ln2631">        fail_check();</a>
<a name="ln2632">        // Trog abilities don't use or train invocations.</a>
<a name="ln2633">        summon_berserker(you.piety +</a>
<a name="ln2634">                         random2(you.piety/4) - random2(you.piety/4),</a>
<a name="ln2635">                         &amp;you);</a>
<a name="ln2636">        break;</a>
<a name="ln2637"> </a>
<a name="ln2638">    case ABIL_SIF_MUNA_FORGET_SPELL:</a>
<a name="ln2639">        fail_check();</a>
<a name="ln2640">        if (cast_selective_amnesia() &lt;= 0)</a>
<a name="ln2641">        {</a>
<a name="ln2642">            canned_msg(MSG_OK);</a>
<a name="ln2643">            return spret::abort;</a>
<a name="ln2644">        }</a>
<a name="ln2645">        break;</a>
<a name="ln2646"> </a>
<a name="ln2647">    case ABIL_SIF_MUNA_CHANNEL_ENERGY:</a>
<a name="ln2648">    {</a>
<a name="ln2649">        fail_check();</a>
<a name="ln2650">        you.increase_duration(DUR_CHANNEL_ENERGY,</a>
<a name="ln2651">            4 + random2avg(you.skill_rdiv(SK_INVOCATIONS, 2, 3), 2), 100);</a>
<a name="ln2652">        break;</a>
<a name="ln2653">    }</a>
<a name="ln2654"> </a>
<a name="ln2655">    case ABIL_SIF_MUNA_DIVINE_EXEGESIS:</a>
<a name="ln2656">    {</a>
<a name="ln2657">        return divine_exegesis(fail);</a>
<a name="ln2658">        break;</a>
<a name="ln2659">    }</a>
<a name="ln2660"> </a>
<a name="ln2661">    case ABIL_ELYVILON_LIFESAVING:</a>
<a name="ln2662">        fail_check();</a>
<a name="ln2663">        if (you.duration[DUR_LIFESAVING])</a>
<a name="ln2664">            mpr(&quot;You renew your call for help.&quot;);</a>
<a name="ln2665">        else</a>
<a name="ln2666">        {</a>
<a name="ln2667">            mprf(&quot;You beseech %s to protect your life.&quot;,</a>
<a name="ln2668">                 god_name(you.religion).c_str());</a>
<a name="ln2669">        }</a>
<a name="ln2670">        // Might be a decrease, this is intentional (like Yred).</a>
<a name="ln2671">        you.duration[DUR_LIFESAVING] = 9 * BASELINE_DELAY</a>
<a name="ln2672">                     + random2avg(you.piety * BASELINE_DELAY, 2) / 10;</a>
<a name="ln2673">        break;</a>
<a name="ln2674"> </a>
<a name="ln2675">    case ABIL_ELYVILON_LESSER_HEALING:</a>
<a name="ln2676">    case ABIL_ELYVILON_GREATER_HEALING:</a>
<a name="ln2677">    {</a>
<a name="ln2678">        fail_check();</a>
<a name="ln2679">        int pow = 0;</a>
<a name="ln2680">        if (abil.ability == ABIL_ELYVILON_LESSER_HEALING)</a>
<a name="ln2681">            pow = 3 + you.skill_rdiv(SK_INVOCATIONS, 1, 6);</a>
<a name="ln2682">        else</a>
<a name="ln2683">            pow = 10 + you.skill_rdiv(SK_INVOCATIONS, 1, 3);</a>
<a name="ln2684">        pow = min(50, pow);</a>
<a name="ln2685">        const int healed = pow + roll_dice(2, pow) - 2;</a>
<a name="ln2686">        mpr(&quot;You are healed.&quot;);</a>
<a name="ln2687">        inc_hp(healed);</a>
<a name="ln2688">        break;</a>
<a name="ln2689">    }</a>
<a name="ln2690"> </a>
<a name="ln2691">    case ABIL_ELYVILON_PURIFICATION:</a>
<a name="ln2692">        fail_check();</a>
<a name="ln2693">        elyvilon_purification();</a>
<a name="ln2694">        break;</a>
<a name="ln2695"> </a>
<a name="ln2696">    case ABIL_ELYVILON_HEAL_OTHER:</a>
<a name="ln2697">    {</a>
<a name="ln2698">        int pow = 30 + you.skill(SK_INVOCATIONS, 1);</a>
<a name="ln2699">        return cast_healing(pow, fail);</a>
<a name="ln2700">    }</a>
<a name="ln2701"> </a>
<a name="ln2702">    case ABIL_ELYVILON_DIVINE_VIGOUR:</a>
<a name="ln2703">        fail_check();</a>
<a name="ln2704">        if (!elyvilon_divine_vigour())</a>
<a name="ln2705">            return spret::abort;</a>
<a name="ln2706">        break;</a>
<a name="ln2707"> </a>
<a name="ln2708">    case ABIL_LUGONU_ABYSS_EXIT:</a>
<a name="ln2709">        fail_check();</a>
<a name="ln2710">        down_stairs(DNGN_EXIT_ABYSS);</a>
<a name="ln2711">        break;</a>
<a name="ln2712"> </a>
<a name="ln2713">    case ABIL_LUGONU_BEND_SPACE:</a>
<a name="ln2714">        fail_check();</a>
<a name="ln2715">        lugonu_bend_space();</a>
<a name="ln2716">        break;</a>
<a name="ln2717"> </a>
<a name="ln2718">    case ABIL_LUGONU_BANISH:</a>
<a name="ln2719">    {</a>
<a name="ln2720">        beam.range = you.current_vision;</a>
<a name="ln2721">        const int pow = 68 + you.skill(SK_INVOCATIONS, 3);</a>
<a name="ln2722"> </a>
<a name="ln2723">        direction_chooser_args args;</a>
<a name="ln2724">        args.mode = TARG_HOSTILE;</a>
<a name="ln2725">        args.get_desc_func = bind(desc_success_chance, placeholders::_1,</a>
<a name="ln2726">                                  zap_ench_power(ZAP_BANISHMENT, pow, false),</a>
<a name="ln2727">                                  false, nullptr);</a>
<a name="ln2728">        if (!spell_direction(spd, beam, &amp;args))</a>
<a name="ln2729">            return spret::abort;</a>
<a name="ln2730"> </a>
<a name="ln2731">        if (beam.target == you.pos())</a>
<a name="ln2732">        {</a>
<a name="ln2733">            mpr(&quot;You cannot banish yourself!&quot;);</a>
<a name="ln2734">            return spret::abort;</a>
<a name="ln2735">        }</a>
<a name="ln2736"> </a>
<a name="ln2737">        fail_check();</a>
<a name="ln2738"> </a>
<a name="ln2739">        return zapping(ZAP_BANISHMENT, pow, beam, true, nullptr, fail);</a>
<a name="ln2740">    }</a>
<a name="ln2741"> </a>
<a name="ln2742">    case ABIL_LUGONU_CORRUPT:</a>
<a name="ln2743">        fail_check();</a>
<a name="ln2744">        if (!lugonu_corrupt_level(300 + you.skill(SK_INVOCATIONS, 15)))</a>
<a name="ln2745">            return spret::abort;</a>
<a name="ln2746">        break;</a>
<a name="ln2747"> </a>
<a name="ln2748">    case ABIL_LUGONU_ABYSS_ENTER:</a>
<a name="ln2749">    {</a>
<a name="ln2750">        fail_check();</a>
<a name="ln2751">        // Deflate HP.</a>
<a name="ln2752">        dec_hp(random2avg(you.hp, 2), false);</a>
<a name="ln2753"> </a>
<a name="ln2754">        no_notes nx; // This banishment shouldn't be noted.</a>
<a name="ln2755">        banished();</a>
<a name="ln2756">        break;</a>
<a name="ln2757">    }</a>
<a name="ln2758"> </a>
<a name="ln2759">    case ABIL_LUGONU_BLESS_WEAPON:</a>
<a name="ln2760">        fail_check();</a>
<a name="ln2761">        simple_god_message(&quot; will brand one of your weapons with the &quot;</a>
<a name="ln2762">                           &quot;corruption of the Abyss.&quot;);</a>
<a name="ln2763">        // included in default force_more_message</a>
<a name="ln2764">        if (!bless_weapon(GOD_LUGONU, SPWPN_DISTORTION, MAGENTA))</a>
<a name="ln2765">            return spret::abort;</a>
<a name="ln2766">        break;</a>
<a name="ln2767"> </a>
<a name="ln2768">    case ABIL_NEMELEX_DRAW_DESTRUCTION:</a>
<a name="ln2769">        fail_check();</a>
<a name="ln2770">        if (!deck_draw(DECK_OF_DESTRUCTION))</a>
<a name="ln2771">            return spret::abort;</a>
<a name="ln2772">        break;</a>
<a name="ln2773">    case ABIL_NEMELEX_DRAW_ESCAPE:</a>
<a name="ln2774">        fail_check();</a>
<a name="ln2775">        if (!deck_draw(DECK_OF_ESCAPE))</a>
<a name="ln2776">            return spret::abort;</a>
<a name="ln2777">        break;</a>
<a name="ln2778">    case ABIL_NEMELEX_DRAW_SUMMONING:</a>
<a name="ln2779">        fail_check();</a>
<a name="ln2780">        if (!deck_draw(DECK_OF_SUMMONING))</a>
<a name="ln2781">            return spret::abort;</a>
<a name="ln2782">        break;</a>
<a name="ln2783">    case ABIL_NEMELEX_DRAW_STACK:</a>
<a name="ln2784">        fail_check();</a>
<a name="ln2785">        if (!deck_draw(DECK_STACK))</a>
<a name="ln2786">            return spret::abort;</a>
<a name="ln2787">        break;</a>
<a name="ln2788"> </a>
<a name="ln2789">    case ABIL_NEMELEX_TRIPLE_DRAW:</a>
<a name="ln2790">        fail_check();</a>
<a name="ln2791">        if (!deck_triple_draw())</a>
<a name="ln2792">            return spret::abort;</a>
<a name="ln2793">        break;</a>
<a name="ln2794"> </a>
<a name="ln2795">    case ABIL_NEMELEX_DEAL_FOUR:</a>
<a name="ln2796">        fail_check();</a>
<a name="ln2797">        if (!deck_deal())</a>
<a name="ln2798">            return spret::abort;</a>
<a name="ln2799">        break;</a>
<a name="ln2800"> </a>
<a name="ln2801">    case ABIL_NEMELEX_STACK_FIVE:</a>
<a name="ln2802">        fail_check();</a>
<a name="ln2803">        if (!deck_stack())</a>
<a name="ln2804">            return spret::abort;</a>
<a name="ln2805">        break;</a>
<a name="ln2806"> </a>
<a name="ln2807">    case ABIL_BEOGH_SMITING:</a>
<a name="ln2808">        fail_check();</a>
<a name="ln2809">        if (your_spells(SPELL_SMITING,</a>
<a name="ln2810">                        12 + skill_bump(SK_INVOCATIONS, 6),</a>
<a name="ln2811">                        false, nullptr) == spret::abort)</a>
<a name="ln2812">        {</a>
<a name="ln2813">            return spret::abort;</a>
<a name="ln2814">        }</a>
<a name="ln2815">        break;</a>
<a name="ln2816"> </a>
<a name="ln2817">    case ABIL_BEOGH_GIFT_ITEM:</a>
<a name="ln2818">        if (!beogh_gift_item())</a>
<a name="ln2819">            return spret::abort;</a>
<a name="ln2820">        break;</a>
<a name="ln2821"> </a>
<a name="ln2822">    case ABIL_BEOGH_RESURRECTION:</a>
<a name="ln2823">        if (!beogh_resurrect())</a>
<a name="ln2824">            return spret::abort;</a>
<a name="ln2825">        break;</a>
<a name="ln2826"> </a>
<a name="ln2827">    case ABIL_BEOGH_RECALL_ORCISH_FOLLOWERS:</a>
<a name="ln2828">        fail_check();</a>
<a name="ln2829">        start_recall(recall_t::beogh);</a>
<a name="ln2830">        break;</a>
<a name="ln2831"> </a>
<a name="ln2832">    case ABIL_STOP_RECALL:</a>
<a name="ln2833">        fail_check();</a>
<a name="ln2834">        mpr(&quot;You stop recalling your allies.&quot;);</a>
<a name="ln2835">        end_recall();</a>
<a name="ln2836">        break;</a>
<a name="ln2837"> </a>
<a name="ln2838">    case ABIL_FEDHAS_WALL_OF_BRIARS:</a>
<a name="ln2839">        fail_check();</a>
<a name="ln2840">        if (!fedhas_wall_of_briars())</a>
<a name="ln2841">            return spret::abort;</a>
<a name="ln2842">        break;</a>
<a name="ln2843"> </a>
<a name="ln2844">    case ABIL_FEDHAS_GROW_BALLISTOMYCETE:</a>
<a name="ln2845">    {</a>
<a name="ln2846">        return fedhas_grow_ballistomycete(fail);</a>
<a name="ln2847"> </a>
<a name="ln2848">        break;</a>
<a name="ln2849">    }</a>
<a name="ln2850"> </a>
<a name="ln2851">    case ABIL_FEDHAS_OVERGROW:</a>
<a name="ln2852">    {</a>
<a name="ln2853">        fail_check();</a>
<a name="ln2854"> </a>
<a name="ln2855">        if (!fedhas_overgrow())</a>
<a name="ln2856">            return spret::abort;</a>
<a name="ln2857"> </a>
<a name="ln2858">        break;</a>
<a name="ln2859">    }</a>
<a name="ln2860"> </a>
<a name="ln2861">    case ABIL_FEDHAS_GROW_OKLOB:</a>
<a name="ln2862">    {</a>
<a name="ln2863">        return fedhas_grow_oklob(fail);</a>
<a name="ln2864"> </a>
<a name="ln2865">        break;</a>
<a name="ln2866">    }</a>
<a name="ln2867"> </a>
<a name="ln2868">    case ABIL_TRAN_BAT:</a>
<a name="ln2869">    {</a>
<a name="ln2870">        if (_player_cancels_vampire_bat_transformation())</a>
<a name="ln2871">            return spret::abort;</a>
<a name="ln2872">        fail_check();</a>
<a name="ln2873">        if (!transform(100, transformation::bat))</a>
<a name="ln2874">        {</a>
<a name="ln2875">            crawl_state.zero_turns_taken();</a>
<a name="ln2876">            return spret::abort;</a>
<a name="ln2877">        }</a>
<a name="ln2878"> </a>
<a name="ln2879">        _cause_vampire_bat_form_stat_drain();</a>
<a name="ln2880"> </a>
<a name="ln2881">        break;</a>
<a name="ln2882">    }</a>
<a name="ln2883"> </a>
<a name="ln2884">    case ABIL_EXSANGUINATE:</a>
<a name="ln2885">        fail_check();</a>
<a name="ln2886">        start_delay&lt;ExsanguinateDelay&gt;(5);</a>
<a name="ln2887">        break;</a>
<a name="ln2888"> </a>
<a name="ln2889">    case ABIL_REVIVIFY:</a>
<a name="ln2890">        fail_check();</a>
<a name="ln2891">        start_delay&lt;RevivifyDelay&gt;(5);</a>
<a name="ln2892">        break;</a>
<a name="ln2893"> </a>
<a name="ln2894">    case ABIL_JIYVA_CALL_JELLY:</a>
<a name="ln2895">    {</a>
<a name="ln2896">        fail_check();</a>
<a name="ln2897">        mgen_data mg(MONS_JELLY, BEH_STRICT_NEUTRAL, you.pos(),</a>
<a name="ln2898">                     MHITNOT, MG_NONE, GOD_JIYVA);</a>
<a name="ln2899"> </a>
<a name="ln2900">        mg.non_actor_summoner = &quot;Jiyva&quot;;</a>
<a name="ln2901"> </a>
<a name="ln2902">        if (!create_monster(mg))</a>
<a name="ln2903">            return spret::abort;</a>
<a name="ln2904">        break;</a>
<a name="ln2905">    }</a>
<a name="ln2906"> </a>
<a name="ln2907">    case ABIL_JIYVA_SLIMIFY:</a>
<a name="ln2908">    {</a>
<a name="ln2909">        fail_check();</a>
<a name="ln2910">        const item_def* const weapon = you.weapon();</a>
<a name="ln2911">        const string msg = weapon ? weapon-&gt;name(DESC_YOUR)</a>
<a name="ln2912">                                  : (&quot;your &quot; + you.hand_name(true));</a>
<a name="ln2913">        mprf(MSGCH_DURATION, &quot;A thick mucus forms on %s.&quot;, msg.c_str());</a>
<a name="ln2914">        you.increase_duration(DUR_SLIMIFY,</a>
<a name="ln2915">                              random2avg(you.piety / 4, 2) + 3, 100);</a>
<a name="ln2916">        break;</a>
<a name="ln2917">    }</a>
<a name="ln2918"> </a>
<a name="ln2919">    case ABIL_JIYVA_CURE_BAD_MUTATION:</a>
<a name="ln2920">        fail_check();</a>
<a name="ln2921">        jiyva_remove_bad_mutation();</a>
<a name="ln2922">        break;</a>
<a name="ln2923"> </a>
<a name="ln2924">    case ABIL_CHEIBRIADOS_TIME_STEP:</a>
<a name="ln2925">        fail_check();</a>
<a name="ln2926">        cheibriados_time_step(max(1, you.skill(SK_INVOCATIONS, 10)</a>
<a name="ln2927">                                     * you.piety / 100));</a>
<a name="ln2928">        break;</a>
<a name="ln2929"> </a>
<a name="ln2930">    case ABIL_CHEIBRIADOS_TIME_BEND:</a>
<a name="ln2931">        fail_check();</a>
<a name="ln2932">        cheibriados_time_bend(16 + you.skill(SK_INVOCATIONS, 8));</a>
<a name="ln2933">        break;</a>
<a name="ln2934"> </a>
<a name="ln2935">    case ABIL_CHEIBRIADOS_DISTORTION:</a>
<a name="ln2936">        fail_check();</a>
<a name="ln2937">        cheibriados_temporal_distortion();</a>
<a name="ln2938">        break;</a>
<a name="ln2939"> </a>
<a name="ln2940">    case ABIL_CHEIBRIADOS_SLOUCH:</a>
<a name="ln2941">        fail_check();</a>
<a name="ln2942">        if (!cheibriados_slouch())</a>
<a name="ln2943">            return spret::abort;</a>
<a name="ln2944">        break;</a>
<a name="ln2945"> </a>
<a name="ln2946">    case ABIL_ASHENZARI_CURSE:</a>
<a name="ln2947">    {</a>
<a name="ln2948">        fail_check();</a>
<a name="ln2949">        auto iter = find_if(begin(you.inv), end(you.inv),</a>
<a name="ln2950">                [] (const item_def &amp;it) -&gt; bool</a>
<a name="ln2951">                {</a>
<a name="ln2952">                    return it.defined()</a>
<a name="ln2953">                           &amp;&amp; it.is_type(OBJ_SCROLLS, SCR_REMOVE_CURSE)</a>
<a name="ln2954">                           &amp;&amp; check_warning_inscriptions(it, OPER_DESTROY);</a>
<a name="ln2955">                });</a>
<a name="ln2956">        if (iter != end(you.inv))</a>
<a name="ln2957">        {</a>
<a name="ln2958">            if (ashenzari_curse_item(iter-&gt;quantity))</a>
<a name="ln2959">                dec_inv_item_quantity(iter - begin(you.inv), 1);</a>
<a name="ln2960">            else</a>
<a name="ln2961">                return spret::abort;</a>
<a name="ln2962">        }</a>
<a name="ln2963">        else</a>
<a name="ln2964">        {</a>
<a name="ln2965">            mpr(&quot;You need a scroll of remove curse to do this.&quot;);</a>
<a name="ln2966">            return spret::abort;</a>
<a name="ln2967">        }</a>
<a name="ln2968">        break;</a>
<a name="ln2969">    }</a>
<a name="ln2970"> </a>
<a name="ln2971">    case ABIL_ASHENZARI_SCRYING:</a>
<a name="ln2972">        fail_check();</a>
<a name="ln2973">        if (you.duration[DUR_SCRYING])</a>
<a name="ln2974">            mpr(&quot;You extend your astral sight.&quot;);</a>
<a name="ln2975">        else</a>
<a name="ln2976">            mpr(&quot;You gain astral sight.&quot;);</a>
<a name="ln2977">        you.duration[DUR_SCRYING] = 100 + random2avg(you.piety * 2, 2);</a>
<a name="ln2978">        you.xray_vision = true;</a>
<a name="ln2979">        viewwindow(true);</a>
<a name="ln2980">        break;</a>
<a name="ln2981"> </a>
<a name="ln2982">    case ABIL_ASHENZARI_TRANSFER_KNOWLEDGE:</a>
<a name="ln2983">        fail_check();</a>
<a name="ln2984">        if (!ashenzari_transfer_knowledge())</a>
<a name="ln2985">        {</a>
<a name="ln2986">            canned_msg(MSG_OK);</a>
<a name="ln2987">            return spret::abort;</a>
<a name="ln2988">        }</a>
<a name="ln2989">        break;</a>
<a name="ln2990"> </a>
<a name="ln2991">    case ABIL_ASHENZARI_END_TRANSFER:</a>
<a name="ln2992">        fail_check();</a>
<a name="ln2993">        if (!ashenzari_end_transfer())</a>
<a name="ln2994">        {</a>
<a name="ln2995">            canned_msg(MSG_OK);</a>
<a name="ln2996">            return spret::abort;</a>
<a name="ln2997">        }</a>
<a name="ln2998">        break;</a>
<a name="ln2999"> </a>
<a name="ln3000">    case ABIL_DITHMENOS_SHADOW_STEP:</a>
<a name="ln3001">        if (_abort_if_stationary())</a>
<a name="ln3002">            return spret::abort;</a>
<a name="ln3003">        fail_check();</a>
<a name="ln3004">        if (!dithmenos_shadow_step())</a>
<a name="ln3005">        {</a>
<a name="ln3006">            canned_msg(MSG_OK);</a>
<a name="ln3007">            return spret::abort;</a>
<a name="ln3008">        }</a>
<a name="ln3009">        break;</a>
<a name="ln3010"> </a>
<a name="ln3011">    case ABIL_DITHMENOS_SHADOW_FORM:</a>
<a name="ln3012">        fail_check();</a>
<a name="ln3013">        if (!transform(you.skill(SK_INVOCATIONS, 2), transformation::shadow))</a>
<a name="ln3014">        {</a>
<a name="ln3015">            crawl_state.zero_turns_taken();</a>
<a name="ln3016">            return spret::abort;</a>
<a name="ln3017">        }</a>
<a name="ln3018">        break;</a>
<a name="ln3019"> </a>
<a name="ln3020">    case ABIL_GOZAG_POTION_PETITION:</a>
<a name="ln3021">        fail_check();</a>
<a name="ln3022">        run_uncancel(UNC_POTION_PETITION, 0);</a>
<a name="ln3023">        break;</a>
<a name="ln3024"> </a>
<a name="ln3025">    case ABIL_GOZAG_CALL_MERCHANT:</a>
<a name="ln3026">        fail_check();</a>
<a name="ln3027">        run_uncancel(UNC_CALL_MERCHANT, 0);</a>
<a name="ln3028">        break;</a>
<a name="ln3029"> </a>
<a name="ln3030">    case ABIL_GOZAG_BRIBE_BRANCH:</a>
<a name="ln3031">        fail_check();</a>
<a name="ln3032">        if (!gozag_bribe_branch())</a>
<a name="ln3033">            return spret::abort;</a>
<a name="ln3034">        break;</a>
<a name="ln3035"> </a>
<a name="ln3036">    case ABIL_QAZLAL_UPHEAVAL:</a>
<a name="ln3037">        return qazlal_upheaval(coord_def(), false, fail);</a>
<a name="ln3038"> </a>
<a name="ln3039">    case ABIL_QAZLAL_ELEMENTAL_FORCE:</a>
<a name="ln3040">        return qazlal_elemental_force(fail);</a>
<a name="ln3041"> </a>
<a name="ln3042">    case ABIL_QAZLAL_DISASTER_AREA:</a>
<a name="ln3043">        fail_check();</a>
<a name="ln3044">        if (!qazlal_disaster_area())</a>
<a name="ln3045">            return spret::abort;</a>
<a name="ln3046">        break;</a>
<a name="ln3047"> </a>
<a name="ln3048">    case ABIL_RU_SACRIFICE_PURITY:</a>
<a name="ln3049">    case ABIL_RU_SACRIFICE_WORDS:</a>
<a name="ln3050">    case ABIL_RU_SACRIFICE_DRINK:</a>
<a name="ln3051">    case ABIL_RU_SACRIFICE_ESSENCE:</a>
<a name="ln3052">    case ABIL_RU_SACRIFICE_HEALTH:</a>
<a name="ln3053">    case ABIL_RU_SACRIFICE_STEALTH:</a>
<a name="ln3054">    case ABIL_RU_SACRIFICE_ARTIFICE:</a>
<a name="ln3055">    case ABIL_RU_SACRIFICE_LOVE:</a>
<a name="ln3056">    case ABIL_RU_SACRIFICE_COURAGE:</a>
<a name="ln3057">    case ABIL_RU_SACRIFICE_ARCANA:</a>
<a name="ln3058">    case ABIL_RU_SACRIFICE_NIMBLENESS:</a>
<a name="ln3059">    case ABIL_RU_SACRIFICE_DURABILITY:</a>
<a name="ln3060">    case ABIL_RU_SACRIFICE_HAND:</a>
<a name="ln3061">    case ABIL_RU_SACRIFICE_EXPERIENCE:</a>
<a name="ln3062">    case ABIL_RU_SACRIFICE_SKILL:</a>
<a name="ln3063">    case ABIL_RU_SACRIFICE_EYE:</a>
<a name="ln3064">    case ABIL_RU_SACRIFICE_RESISTANCE:</a>
<a name="ln3065">        fail_check();</a>
<a name="ln3066">        if (!ru_do_sacrifice(abil.ability))</a>
<a name="ln3067">            return spret::abort;</a>
<a name="ln3068">        break;</a>
<a name="ln3069"> </a>
<a name="ln3070">    case ABIL_RU_REJECT_SACRIFICES:</a>
<a name="ln3071">        fail_check();</a>
<a name="ln3072">        if (!ru_reject_sacrifices())</a>
<a name="ln3073">            return spret::abort;</a>
<a name="ln3074">        break;</a>
<a name="ln3075"> </a>
<a name="ln3076">    case ABIL_RU_DRAW_OUT_POWER:</a>
<a name="ln3077">        fail_check();</a>
<a name="ln3078">        if (you.duration[DUR_EXHAUSTED])</a>
<a name="ln3079">        {</a>
<a name="ln3080">            mpr(&quot;You're too exhausted to draw out your power.&quot;);</a>
<a name="ln3081">            return spret::abort;</a>
<a name="ln3082">        }</a>
<a name="ln3083">        if (you.hp == you.hp_max &amp;&amp; you.magic_points == you.max_magic_points</a>
<a name="ln3084">            &amp;&amp; !you.duration[DUR_CONF]</a>
<a name="ln3085">            &amp;&amp; !you.duration[DUR_SLOW]</a>
<a name="ln3086">            &amp;&amp; !you.attribute[ATTR_HELD]</a>
<a name="ln3087">            &amp;&amp; !you.petrifying()</a>
<a name="ln3088">            &amp;&amp; !you.is_constricted())</a>
<a name="ln3089">        {</a>
<a name="ln3090">            mpr(&quot;You have no need to draw out power.&quot;);</a>
<a name="ln3091">            return spret::abort;</a>
<a name="ln3092">        }</a>
<a name="ln3093">        ru_draw_out_power();</a>
<a name="ln3094">        you.increase_duration(DUR_EXHAUSTED, 12 + random2(5));</a>
<a name="ln3095">        break;</a>
<a name="ln3096"> </a>
<a name="ln3097">    case ABIL_RU_POWER_LEAP:</a>
<a name="ln3098">        if (you.duration[DUR_EXHAUSTED])</a>
<a name="ln3099">        {</a>
<a name="ln3100">            mpr(&quot;You're too exhausted to power leap.&quot;);</a>
<a name="ln3101">            return spret::abort;</a>
<a name="ln3102">        }</a>
<a name="ln3103"> </a>
<a name="ln3104">        if (_abort_if_stationary())</a>
<a name="ln3105">            return spret::abort;</a>
<a name="ln3106"> </a>
<a name="ln3107">        fail_check();</a>
<a name="ln3108"> </a>
<a name="ln3109">        if (!ru_power_leap())</a>
<a name="ln3110">        {</a>
<a name="ln3111">            canned_msg(MSG_OK);</a>
<a name="ln3112">            return spret::abort;</a>
<a name="ln3113">        }</a>
<a name="ln3114">        you.increase_duration(DUR_EXHAUSTED, 18 + random2(8));</a>
<a name="ln3115">        break;</a>
<a name="ln3116"> </a>
<a name="ln3117">    case ABIL_RU_APOCALYPSE:</a>
<a name="ln3118">        if (you.duration[DUR_EXHAUSTED])</a>
<a name="ln3119">        {</a>
<a name="ln3120">            mpr(&quot;You're too exhausted to unleash your apocalyptic power.&quot;);</a>
<a name="ln3121">            return spret::abort;</a>
<a name="ln3122">        }</a>
<a name="ln3123"> </a>
<a name="ln3124">        fail_check();</a>
<a name="ln3125"> </a>
<a name="ln3126">        if (!ru_apocalypse())</a>
<a name="ln3127">            return spret::abort;</a>
<a name="ln3128">        you.increase_duration(DUR_EXHAUSTED, 30 + random2(20));</a>
<a name="ln3129">        break;</a>
<a name="ln3130"> </a>
<a name="ln3131">#if TAG_MAJOR_VERSION == 34</a>
<a name="ln3132">    case ABIL_PAKELLAS_DEVICE_SURGE:</a>
<a name="ln3133">    {</a>
<a name="ln3134">        fail_check();</a>
<a name="ln3135"> </a>
<a name="ln3136">        mprf(MSGCH_DURATION, &quot;You feel a buildup of energy.&quot;);</a>
<a name="ln3137">        you.increase_duration(DUR_DEVICE_SURGE,</a>
<a name="ln3138">                              random2avg(you.piety / 4, 2) + 3, 100);</a>
<a name="ln3139">        break;</a>
<a name="ln3140">    }</a>
<a name="ln3141">#endif</a>
<a name="ln3142"> </a>
<a name="ln3143">    case ABIL_USKAYAW_STOMP:</a>
<a name="ln3144">        fail_check();</a>
<a name="ln3145">        if (!uskayaw_stomp())</a>
<a name="ln3146">            return spret::abort;</a>
<a name="ln3147">        break;</a>
<a name="ln3148"> </a>
<a name="ln3149">    case ABIL_USKAYAW_LINE_PASS:</a>
<a name="ln3150">        if (_abort_if_stationary())</a>
<a name="ln3151">            return spret::abort;</a>
<a name="ln3152">        fail_check();</a>
<a name="ln3153">        if (!uskayaw_line_pass())</a>
<a name="ln3154">            return spret::abort;</a>
<a name="ln3155">        break;</a>
<a name="ln3156"> </a>
<a name="ln3157">    case ABIL_USKAYAW_GRAND_FINALE:</a>
<a name="ln3158">        return uskayaw_grand_finale(fail);</a>
<a name="ln3159"> </a>
<a name="ln3160">    case ABIL_HEPLIAKLQANA_IDEALISE:</a>
<a name="ln3161">        return hepliaklqana_idealise(fail);</a>
<a name="ln3162"> </a>
<a name="ln3163">    case ABIL_HEPLIAKLQANA_RECALL:</a>
<a name="ln3164">        fail_check();</a>
<a name="ln3165">        if (try_recall(hepliaklqana_ancestor()))</a>
<a name="ln3166">            upgrade_hepliaklqana_ancestor(true);</a>
<a name="ln3167">        break;</a>
<a name="ln3168"> </a>
<a name="ln3169">    case ABIL_HEPLIAKLQANA_TRANSFERENCE:</a>
<a name="ln3170">        return hepliaklqana_transference(fail);</a>
<a name="ln3171"> </a>
<a name="ln3172">    case ABIL_HEPLIAKLQANA_TYPE_KNIGHT:</a>
<a name="ln3173">    case ABIL_HEPLIAKLQANA_TYPE_BATTLEMAGE:</a>
<a name="ln3174">    case ABIL_HEPLIAKLQANA_TYPE_HEXER:</a>
<a name="ln3175">        if (!hepliaklqana_choose_ancestor_type(abil.ability))</a>
<a name="ln3176">            return spret::abort;</a>
<a name="ln3177">        break;</a>
<a name="ln3178"> </a>
<a name="ln3179">    case ABIL_HEPLIAKLQANA_IDENTITY:</a>
<a name="ln3180">        hepliaklqana_choose_identity();</a>
<a name="ln3181">        break;</a>
<a name="ln3182"> </a>
<a name="ln3183">    case ABIL_WU_JIAN_SERPENTS_LASH:</a>
<a name="ln3184">        if (you.attribute[ATTR_SERPENTS_LASH])</a>
<a name="ln3185">        {</a>
<a name="ln3186">            mpr(&quot;You are already lashing out.&quot;);</a>
<a name="ln3187">            return spret::abort;</a>
<a name="ln3188">        }</a>
<a name="ln3189">        if (you.duration[DUR_EXHAUSTED])</a>
<a name="ln3190">        {</a>
<a name="ln3191">            mpr(&quot;You are too exhausted to lash out.&quot;);</a>
<a name="ln3192">            return spret::abort;</a>
<a name="ln3193">        }</a>
<a name="ln3194">        fail_check();</a>
<a name="ln3195">        mprf(MSGCH_GOD, &quot;Your muscles tense, ready for explosive movement...&quot;);</a>
<a name="ln3196">        you.attribute[ATTR_SERPENTS_LASH] = 2;</a>
<a name="ln3197">        you.redraw_status_lights = true;</a>
<a name="ln3198">        return spret::success;</a>
<a name="ln3199"> </a>
<a name="ln3200">    case ABIL_WU_JIAN_HEAVENLY_STORM:</a>
<a name="ln3201">        if (you.props.exists(WU_JIAN_HEAVENLY_STORM_KEY))</a>
<a name="ln3202">        {</a>
<a name="ln3203">            mpr(&quot;You are already engulfed in a heavenly storm!&quot;);</a>
<a name="ln3204">            return spret::abort;</a>
<a name="ln3205">        }</a>
<a name="ln3206">        fail_check();</a>
<a name="ln3207">        wu_jian_heavenly_storm();</a>
<a name="ln3208">        break;</a>
<a name="ln3209"> </a>
<a name="ln3210">    case ABIL_WU_JIAN_WALLJUMP:</a>
<a name="ln3211">        fail_check();</a>
<a name="ln3212">        return wu_jian_wall_jump_ability();</a>
<a name="ln3213"> </a>
<a name="ln3214">    case ABIL_RENOUNCE_RELIGION:</a>
<a name="ln3215">        fail_check();</a>
<a name="ln3216">        if (yesno(&quot;Really renounce your faith, foregoing its fabulous benefits?&quot;,</a>
<a name="ln3217">                  false, 'n')</a>
<a name="ln3218">            &amp;&amp; yesno(&quot;Are you sure?&quot;, false, 'n'))</a>
<a name="ln3219">        {</a>
<a name="ln3220">            excommunication(true);</a>
<a name="ln3221">        }</a>
<a name="ln3222">        else</a>
<a name="ln3223">        {</a>
<a name="ln3224">            canned_msg(MSG_OK);</a>
<a name="ln3225">            return spret::abort;</a>
<a name="ln3226">        }</a>
<a name="ln3227">        break;</a>
<a name="ln3228"> </a>
<a name="ln3229">    case ABIL_CONVERT_TO_BEOGH:</a>
<a name="ln3230">        fail_check();</a>
<a name="ln3231">        god_pitch(GOD_BEOGH);</a>
<a name="ln3232">        if (you_worship(GOD_BEOGH))</a>
<a name="ln3233">        {</a>
<a name="ln3234">            spare_beogh_convert();</a>
<a name="ln3235">            break;</a>
<a name="ln3236">        }</a>
<a name="ln3237">        return spret::abort;</a>
<a name="ln3238"> </a>
<a name="ln3239">    case ABIL_NON_ABILITY:</a>
<a name="ln3240">        fail_check();</a>
<a name="ln3241">        mpr(&quot;Sorry, you can't do that.&quot;);</a>
<a name="ln3242">        break;</a>
<a name="ln3243"> </a>
<a name="ln3244">    default:</a>
<a name="ln3245">        die(&quot;invalid ability&quot;);</a>
<a name="ln3246">    }</a>
<a name="ln3247"> </a>
<a name="ln3248">    return spret::success;</a>
<a name="ln3249">}</a>
<a name="ln3250"> </a>
<a name="ln3251">// [ds] Increase piety cost for god abilities that are particularly</a>
<a name="ln3252">// overpowered in Sprint. Yes, this is a hack. No, I don't care.</a>
<a name="ln3253">static int _scale_piety_cost(ability_type abil, int original_cost)</a>
<a name="ln3254">{</a>
<a name="ln3255">    // Abilities that have aroused our ire earn 2.5x their classic</a>
<a name="ln3256">    // Crawl piety cost.</a>
<a name="ln3257">    return (crawl_state.game_is_sprint()</a>
<a name="ln3258">            &amp;&amp; (abil == ABIL_TROG_BROTHERS_IN_ARMS</a>
<a name="ln3259">                || abil == ABIL_MAKHLEB_GREATER_SERVANT_OF_MAKHLEB))</a>
<a name="ln3260">           ? div_rand_round(original_cost * 5, 2)</a>
<a name="ln3261">           : original_cost;</a>
<a name="ln3262">}</a>
<a name="ln3263"> </a>
<a name="ln3264">static void _pay_ability_costs(const ability_def&amp; abil)</a>
<a name="ln3265">{</a>
<a name="ln3266">    // wall jump handles its own timing, because it can be instant if</a>
<a name="ln3267">    // serpent's lash is activated.</a>
<a name="ln3268">    if (abil.flags &amp; abflag::instant)</a>
<a name="ln3269">    {</a>
<a name="ln3270">        you.turn_is_over = false;</a>
<a name="ln3271">        you.elapsed_time_at_last_input = you.elapsed_time;</a>
<a name="ln3272">        update_turn_count();</a>
<a name="ln3273">    }</a>
<a name="ln3274">    else if (abil.ability != ABIL_WU_JIAN_WALLJUMP)</a>
<a name="ln3275">        you.turn_is_over = true;</a>
<a name="ln3276"> </a>
<a name="ln3277">    const int food_cost  = abil.food_cost + random2avg(abil.food_cost, 2);</a>
<a name="ln3278">    const int piety_cost =</a>
<a name="ln3279">        _scale_piety_cost(abil.ability, abil.piety_cost.cost());</a>
<a name="ln3280">    const int hp_cost    = abil.hp_cost.cost(you.hp_max);</a>
<a name="ln3281"> </a>
<a name="ln3282">    dprf(&quot;Cost: mp=%d; hp=%d; food=%d; piety=%d&quot;,</a>
<a name="ln3283">         abil.mp_cost, hp_cost, food_cost, piety_cost);</a>
<a name="ln3284"> </a>
<a name="ln3285">    if (abil.mp_cost)</a>
<a name="ln3286">        dec_mp(abil.mp_cost);</a>
<a name="ln3287"> </a>
<a name="ln3288">    if (abil.hp_cost)</a>
<a name="ln3289">        dec_hp(hp_cost, false);</a>
<a name="ln3290"> </a>
<a name="ln3291">    if (food_cost)</a>
<a name="ln3292">        make_hungry(food_cost, false, true);</a>
<a name="ln3293"> </a>
<a name="ln3294">    if (piety_cost)</a>
<a name="ln3295">        lose_piety(piety_cost);</a>
<a name="ln3296">}</a>
<a name="ln3297"> </a>
<a name="ln3298">int choose_ability_menu(const vector&lt;talent&gt;&amp; talents)</a>
<a name="ln3299">{</a>
<a name="ln3300">    ToggleableMenu abil_menu(MF_SINGLESELECT | MF_ANYPRINTABLE</a>
<a name="ln3301">            | MF_NO_WRAP_ROWS | MF_TOGGLE_ACTION | MF_ALWAYS_SHOW_MORE);</a>
<a name="ln3302"> </a>
<a name="ln3303">    abil_menu.set_highlighter(nullptr);</a>
<a name="ln3304">#ifdef USE_TILE_LOCAL</a>
<a name="ln3305">    {</a>
<a name="ln3306">        // Hack like the one in spl-cast.cc:list_spells() to align the title.</a>
<a name="ln3307">        ToggleableMenuEntry* me =</a>
<a name="ln3308">            new ToggleableMenuEntry(&quot;Ability - do what?                  &quot;</a>
<a name="ln3309">                                    &quot;Cost                            Failure&quot;,</a>
<a name="ln3310">                                    &quot;Ability - describe what?            &quot;</a>
<a name="ln3311">                                    &quot;Cost                            Failure&quot;,</a>
<a name="ln3312">                                    MEL_ITEM);</a>
<a name="ln3313">        me-&gt;colour = BLUE;</a>
<a name="ln3314">        abil_menu.set_title(me, true, true);</a>
<a name="ln3315">    }</a>
<a name="ln3316">#else</a>
<a name="ln3317">    abil_menu.set_title(</a>
<a name="ln3318">        new ToggleableMenuEntry(&quot;Ability - do what?                  &quot;</a>
<a name="ln3319">                                &quot;Cost                            Failure&quot;,</a>
<a name="ln3320">                                &quot;Ability - describe what?            &quot;</a>
<a name="ln3321">                                &quot;Cost                            Failure&quot;,</a>
<a name="ln3322">                                MEL_TITLE), true, true);</a>
<a name="ln3323">#endif</a>
<a name="ln3324">    abil_menu.set_tag(&quot;ability&quot;);</a>
<a name="ln3325">    abil_menu.add_toggle_key('!');</a>
<a name="ln3326">    abil_menu.add_toggle_key('?');</a>
<a name="ln3327">    abil_menu.menu_action = Menu::ACT_EXECUTE;</a>
<a name="ln3328"> </a>
<a name="ln3329">    if (crawl_state.game_is_hints())</a>
<a name="ln3330">    {</a>
<a name="ln3331">        // XXX: This could be buggy if you manage to pick up lots and</a>
<a name="ln3332">        // lots of abilities during hints mode.</a>
<a name="ln3333">        abil_menu.set_more(hints_abilities_info());</a>
<a name="ln3334">    }</a>
<a name="ln3335">    else</a>
<a name="ln3336">    {</a>
<a name="ln3337">        abil_menu.set_more(formatted_string::parse_string(</a>
<a name="ln3338">                           &quot;Press '&lt;w&gt;!&lt;/w&gt;' or '&lt;w&gt;?&lt;/w&gt;' to toggle &quot;</a>
<a name="ln3339">                           &quot;between ability selection and description.&quot;));</a>
<a name="ln3340">    }</a>
<a name="ln3341"> </a>
<a name="ln3342">    int numbers[52];</a>
<a name="ln3343">    for (int i = 0; i &lt; 52; ++i)</a>
<a name="ln3344">        numbers[i] = i;</a>
<a name="ln3345"> </a>
<a name="ln3346">    bool found_invocations = false;</a>
<a name="ln3347"> </a>
<a name="ln3348">    // First add all non-invocation abilities.</a>
<a name="ln3349">    for (unsigned int i = 0; i &lt; talents.size(); ++i)</a>
<a name="ln3350">    {</a>
<a name="ln3351">        if (talents[i].is_invocation)</a>
<a name="ln3352">            found_invocations = true;</a>
<a name="ln3353">        else</a>
<a name="ln3354">        {</a>
<a name="ln3355">            ToggleableMenuEntry* me =</a>
<a name="ln3356">                new ToggleableMenuEntry(describe_talent(talents[i]),</a>
<a name="ln3357">                                        describe_talent(talents[i]),</a>
<a name="ln3358">                                        MEL_ITEM, 1, talents[i].hotkey);</a>
<a name="ln3359">            me-&gt;data = &amp;numbers[i];</a>
<a name="ln3360">#ifdef USE_TILE</a>
<a name="ln3361">            me-&gt;add_tile(tile_def(tileidx_ability(talents[i].which), TEX_GUI));</a>
<a name="ln3362">#endif</a>
<a name="ln3363">            if (!check_ability_possible(talents[i].which, true))</a>
<a name="ln3364">            {</a>
<a name="ln3365">                me-&gt;colour = COL_INAPPLICABLE;</a>
<a name="ln3366">#ifdef USE_TILE</a>
<a name="ln3367">                me-&gt;add_tile(tile_def(TILEI_MESH, TEX_ICONS));</a>
<a name="ln3368">#endif</a>
<a name="ln3369">            }</a>
<a name="ln3370">            else if (_check_ability_dangerous(talents[i].which, true))</a>
<a name="ln3371">                me-&gt;colour = COL_DANGEROUS;</a>
<a name="ln3372">            // Only check this here, since your god can't hate its own abilities</a>
<a name="ln3373">            else if (god_hates_ability(talents[i].which, you.religion))</a>
<a name="ln3374">                me-&gt;colour = COL_FORBIDDEN;</a>
<a name="ln3375">            abil_menu.add_entry(me);</a>
<a name="ln3376">        }</a>
<a name="ln3377">    }</a>
<a name="ln3378"> </a>
<a name="ln3379">    if (found_invocations)</a>
<a name="ln3380">    {</a>
<a name="ln3381">#ifdef USE_TILE_LOCAL</a>
<a name="ln3382">        MenuEntry* subtitle = new MenuEntry(&quot; Invocations -    &quot;, MEL_ITEM);</a>
<a name="ln3383">        subtitle-&gt;colour = BLUE;</a>
<a name="ln3384">        abil_menu.add_entry(subtitle);</a>
<a name="ln3385">#else</a>
<a name="ln3386">        abil_menu.add_entry(new MenuEntry(&quot; Invocations -    &quot;, MEL_SUBTITLE));</a>
<a name="ln3387">#endif</a>
<a name="ln3388">        for (unsigned int i = 0; i &lt; talents.size(); ++i)</a>
<a name="ln3389">        {</a>
<a name="ln3390">            if (talents[i].is_invocation)</a>
<a name="ln3391">            {</a>
<a name="ln3392">                ToggleableMenuEntry* me =</a>
<a name="ln3393">                    new ToggleableMenuEntry(describe_talent(talents[i]),</a>
<a name="ln3394">                                            describe_talent(talents[i]),</a>
<a name="ln3395">                                            MEL_ITEM, 1, talents[i].hotkey);</a>
<a name="ln3396">                me-&gt;data = &amp;numbers[i];</a>
<a name="ln3397">#ifdef USE_TILE</a>
<a name="ln3398">                me-&gt;add_tile(tile_def(tileidx_ability(talents[i].which),</a>
<a name="ln3399">                                      TEX_GUI));</a>
<a name="ln3400">#endif</a>
<a name="ln3401">                if (!check_ability_possible(talents[i].which, true))</a>
<a name="ln3402">                {</a>
<a name="ln3403">                    me-&gt;colour = COL_INAPPLICABLE;</a>
<a name="ln3404">#ifdef USE_TILE</a>
<a name="ln3405">                    me-&gt;add_tile(tile_def(TILEI_MESH, TEX_ICONS));</a>
<a name="ln3406">#endif</a>
<a name="ln3407">                }</a>
<a name="ln3408">                else if (_check_ability_dangerous(talents[i].which, true))</a>
<a name="ln3409">                    me-&gt;colour = COL_DANGEROUS;</a>
<a name="ln3410">                abil_menu.add_entry(me);</a>
<a name="ln3411">            }</a>
<a name="ln3412">        }</a>
<a name="ln3413">    }</a>
<a name="ln3414"> </a>
<a name="ln3415">    int ret = -1;</a>
<a name="ln3416">    abil_menu.on_single_selection = [&amp;abil_menu, &amp;talents, &amp;ret](const MenuEntry&amp; sel)</a>
<a name="ln3417">    {</a>
<a name="ln3418">        ASSERT(sel.hotkeys.size() == 1);</a>
<a name="ln3419">        int selected = *(static_cast&lt;int*&gt;(sel.data));</a>
<a name="ln3420"> </a>
<a name="ln3421">        if (abil_menu.menu_action == Menu::ACT_EXAMINE)</a>
<a name="ln3422">            _print_talent_description(talents[selected]);</a>
<a name="ln3423">        else</a>
<a name="ln3424">            ret = *(static_cast&lt;int*&gt;(sel.data));</a>
<a name="ln3425">        return abil_menu.menu_action == Menu::ACT_EXAMINE;</a>
<a name="ln3426">    };</a>
<a name="ln3427">    abil_menu.show(false);</a>
<a name="ln3428">    if (!crawl_state.doing_prev_cmd_again)</a>
<a name="ln3429">        redraw_screen();</a>
<a name="ln3430">    return ret;</a>
<a name="ln3431">}</a>
<a name="ln3432"> </a>
<a name="ln3433">string describe_talent(const talent&amp; tal)</a>
<a name="ln3434">{</a>
<a name="ln3435">    ASSERT(tal.which != ABIL_NON_ABILITY);</a>
<a name="ln3436"> </a>
<a name="ln3437">    const string failure = failure_rate_to_string(tal.fail)</a>
<a name="ln3438">        + (testbits(get_ability_def(tal.which).flags, abflag::hostile)</a>
<a name="ln3439">           ? &quot; hostile&quot; : &quot;&quot;);</a>
<a name="ln3440"> </a>
<a name="ln3441">    ostringstream desc;</a>
<a name="ln3442">    desc &lt;&lt; left</a>
<a name="ln3443">         &lt;&lt; chop_string(ability_name(tal.which), 32)</a>
<a name="ln3444">         &lt;&lt; chop_string(make_cost_description(tal.which), 32)</a>
<a name="ln3445">         &lt;&lt; chop_string(failure, 12);</a>
<a name="ln3446">    return trimmed_string(desc.str());</a>
<a name="ln3447">}</a>
<a name="ln3448"> </a>
<a name="ln3449">static void _add_talent(vector&lt;talent&gt;&amp; vec, const ability_type ability,</a>
<a name="ln3450">                        bool check_confused)</a>
<a name="ln3451">{</a>
<a name="ln3452">    const talent t = get_talent(ability, check_confused);</a>
<a name="ln3453">    if (t.which != ABIL_NON_ABILITY)</a>
<a name="ln3454">        vec.push_back(t);</a>
<a name="ln3455">}</a>
<a name="ln3456"> </a>
<a name="ln3457">/**</a>
<a name="ln3458"> * Return all relevant talents that the player has.</a>
<a name="ln3459"> *</a>
<a name="ln3460"> * Currently the only abilities that are affected by include_unusable are god</a>
<a name="ln3461"> * abilities (affect by e.g. penance or silence).</a>
<a name="ln3462"> * @param check_confused If true, abilities that don't work when confused will</a>
<a name="ln3463"> *                       be excluded.</a>
<a name="ln3464"> * @param include_unusable If true, abilities that are currently unusable will</a>
<a name="ln3465"> *                         be excluded.</a>
<a name="ln3466"> * @return  A vector of talent structs.</a>
<a name="ln3467"> */</a>
<a name="ln3468">vector&lt;talent&gt; your_talents(bool check_confused, bool include_unusable)</a>
<a name="ln3469">{</a>
<a name="ln3470">    vector&lt;talent&gt; talents;</a>
<a name="ln3471"> </a>
<a name="ln3472">    // Species-based abilities.</a>
<a name="ln3473">    if (you.species == SP_DEEP_DWARF)</a>
<a name="ln3474">        _add_talent(talents, ABIL_HEAL_WOUNDS, check_confused);</a>
<a name="ln3475"> </a>
<a name="ln3476">    if (you.species == SP_FORMICID</a>
<a name="ln3477">        &amp;&amp; (form_keeps_mutations() || include_unusable))</a>
<a name="ln3478">    {</a>
<a name="ln3479">        _add_talent(talents, ABIL_DIG, check_confused);</a>
<a name="ln3480">        if (!crawl_state.game_is_sprint() || brdepth[you.where_are_you] &gt; 1)</a>
<a name="ln3481">            _add_talent(talents, ABIL_SHAFT_SELF, check_confused);</a>
<a name="ln3482">    }</a>
<a name="ln3483"> </a>
<a name="ln3484">    if (you.get_mutation_level(MUT_HOP))</a>
<a name="ln3485">        _add_talent(talents, ABIL_HOP, check_confused);</a>
<a name="ln3486"> </a>
<a name="ln3487">    // Spit Poison, possibly upgraded to Breathe Poison.</a>
<a name="ln3488">    if (you.get_mutation_level(MUT_SPIT_POISON) == 2)</a>
<a name="ln3489">        _add_talent(talents, ABIL_BREATHE_POISON, check_confused);</a>
<a name="ln3490">    else if (you.get_mutation_level(MUT_SPIT_POISON))</a>
<a name="ln3491">        _add_talent(talents, ABIL_SPIT_POISON, check_confused);</a>
<a name="ln3492"> </a>
<a name="ln3493">    if (species_is_draconian(you.species)</a>
<a name="ln3494">        // Draconians don't maintain their original breath weapons</a>
<a name="ln3495">        // if shapechanged into a non-dragon form.</a>
<a name="ln3496">        &amp;&amp; (!form_changed_physiology() || you.form == transformation::dragon)</a>
<a name="ln3497">        &amp;&amp; draconian_breath(you.species) != ABIL_NON_ABILITY)</a>
<a name="ln3498">    {</a>
<a name="ln3499">        _add_talent(talents, draconian_breath(you.species), check_confused);</a>
<a name="ln3500">    }</a>
<a name="ln3501"> </a>
<a name="ln3502">    if (you.species == SP_VAMPIRE)</a>
<a name="ln3503">    {</a>
<a name="ln3504">        if (!you.vampire_alive)</a>
<a name="ln3505">        {</a>
<a name="ln3506">            if (you.experience_level &gt;= 3 &amp;&amp; you.form != transformation::bat)</a>
<a name="ln3507">                _add_talent(talents, ABIL_TRAN_BAT, check_confused);</a>
<a name="ln3508">            _add_talent(talents, ABIL_REVIVIFY, check_confused);</a>
<a name="ln3509">        }</a>
<a name="ln3510">        else</a>
<a name="ln3511">            _add_talent(talents, ABIL_EXSANGUINATE, check_confused);</a>
<a name="ln3512">    }</a>
<a name="ln3513"> </a>
<a name="ln3514">    if (you.racial_permanent_flight() &amp;&amp; !you.attribute[ATTR_PERM_FLIGHT])</a>
<a name="ln3515">    {</a>
<a name="ln3516">        // Tengu can fly starting at XL 5</a>
<a name="ln3517">        // Black draconians and gargoyles get permaflight at XL 14, but they</a>
<a name="ln3518">        // don't get the tengu movement/evasion bonuses</a>
<a name="ln3519">        // Other dracs can mutate big wings whenever as well.</a>
<a name="ln3520">        _add_talent(talents, ABIL_FLY, check_confused);</a>
<a name="ln3521">    }</a>
<a name="ln3522"> </a>
<a name="ln3523">    if (you.attribute[ATTR_PERM_FLIGHT] &amp;&amp; you.racial_permanent_flight())</a>
<a name="ln3524">        _add_talent(talents, ABIL_STOP_FLYING, check_confused);</a>
<a name="ln3525"> </a>
<a name="ln3526">    // Mutations</a>
<a name="ln3527">    if (you.get_mutation_level(MUT_HURL_DAMNATION))</a>
<a name="ln3528">        _add_talent(talents, ABIL_DAMNATION, check_confused);</a>
<a name="ln3529"> </a>
<a name="ln3530">    if (you.duration[DUR_TRANSFORMATION] &amp;&amp; !you.transform_uncancellable)</a>
<a name="ln3531">        _add_talent(talents, ABIL_END_TRANSFORMATION, check_confused);</a>
<a name="ln3532"> </a>
<a name="ln3533">    if (you.get_mutation_level(MUT_BLINK))</a>
<a name="ln3534">        _add_talent(talents, ABIL_BLINK, check_confused);</a>
<a name="ln3535"> </a>
<a name="ln3536">    // Religious abilities.</a>
<a name="ln3537">    for (ability_type abil : get_god_abilities(include_unusable, false,</a>
<a name="ln3538">                                               include_unusable))</a>
<a name="ln3539">    {</a>
<a name="ln3540">        _add_talent(talents, abil, check_confused);</a>
<a name="ln3541">    }</a>
<a name="ln3542"> </a>
<a name="ln3543">    // And finally, the ability to opt-out of your faith {dlb}:</a>
<a name="ln3544">    if (!you_worship(GOD_NO_GOD))</a>
<a name="ln3545">        _add_talent(talents, ABIL_RENOUNCE_RELIGION, check_confused);</a>
<a name="ln3546"> </a>
<a name="ln3547">    if (env.level_state &amp; LSTATE_BEOGH &amp;&amp; can_convert_to_beogh())</a>
<a name="ln3548">        _add_talent(talents, ABIL_CONVERT_TO_BEOGH, check_confused);</a>
<a name="ln3549"> </a>
<a name="ln3550">    //jmf: Check for breath weapons - they're exclusive of each other, I hope!</a>
<a name="ln3551">    //     Make better ones come first.</a>
<a name="ln3552">    if (you.species != SP_RED_DRACONIAN &amp;&amp; you.form == transformation::dragon</a>
<a name="ln3553">         &amp;&amp; dragon_form_dragon_type() == MONS_FIRE_DRAGON)</a>
<a name="ln3554">    {</a>
<a name="ln3555">        _add_talent(talents, ABIL_BREATHE_FIRE, check_confused);</a>
<a name="ln3556">    }</a>
<a name="ln3557"> </a>
<a name="ln3558">    if (you.duration[DUR_PORTAL_PROJECTILE])</a>
<a name="ln3559">        _add_talent(talents, ABIL_CANCEL_PPROJ, check_confused);</a>
<a name="ln3560"> </a>
<a name="ln3561">    // Evocations from items.</a>
<a name="ln3562">    if (you.scan_artefacts(ARTP_BLINK)</a>
<a name="ln3563">        &amp;&amp; !you.get_mutation_level(MUT_NO_ARTIFICE))</a>
<a name="ln3564">    {</a>
<a name="ln3565">        _add_talent(talents, ABIL_EVOKE_BLINK, check_confused);</a>
<a name="ln3566">    }</a>
<a name="ln3567"> </a>
<a name="ln3568">    if (player_equip_unrand(UNRAND_THIEF)</a>
<a name="ln3569">        &amp;&amp; !you.get_mutation_level(MUT_NO_ARTIFICE))</a>
<a name="ln3570">    {</a>
<a name="ln3571">        _add_talent(talents, ABIL_EVOKE_FOG, check_confused);</a>
<a name="ln3572">    }</a>
<a name="ln3573"> </a>
<a name="ln3574">    if (player_equip_unrand(UNRAND_RATSKIN_CLOAK)</a>
<a name="ln3575">        &amp;&amp; !you.get_mutation_level(MUT_NO_ARTIFICE)</a>
<a name="ln3576">        &amp;&amp; !you.get_mutation_level(MUT_NO_LOVE))</a>
<a name="ln3577">    {</a>
<a name="ln3578">        _add_talent(talents, ABIL_EVOKE_RATSKIN, check_confused);</a>
<a name="ln3579">    }</a>
<a name="ln3580"> </a>
<a name="ln3581">    if (player_equip_unrand(UNRAND_RCLOUDS)</a>
<a name="ln3582">        &amp;&amp; !you.get_mutation_level(MUT_NO_ARTIFICE))</a>
<a name="ln3583">    {</a>
<a name="ln3584">        _add_talent(talents, ABIL_EVOKE_THUNDER, check_confused);</a>
<a name="ln3585">    }</a>
<a name="ln3586"> </a>
<a name="ln3587">    if (you.evokable_berserk() &amp;&amp; !you.get_mutation_level(MUT_NO_ARTIFICE))</a>
<a name="ln3588">        _add_talent(talents, ABIL_EVOKE_BERSERK, check_confused);</a>
<a name="ln3589"> </a>
<a name="ln3590">    if (you.evokable_invis() &gt; 0</a>
<a name="ln3591">        &amp;&amp; !you.get_mutation_level(MUT_NO_ARTIFICE)</a>
<a name="ln3592">        &amp;&amp; !you.duration[DUR_INVIS])</a>
<a name="ln3593">    {</a>
<a name="ln3594">        _add_talent(talents, ABIL_EVOKE_TURN_INVISIBLE, check_confused);</a>
<a name="ln3595">    }</a>
<a name="ln3596"> </a>
<a name="ln3597">    if (you.evokable_flight() &amp;&amp; !you.get_mutation_level(MUT_NO_ARTIFICE))</a>
<a name="ln3598">    {</a>
<a name="ln3599">        // Has no effect on permanently flying Tengu.</a>
<a name="ln3600">        if (!you.permanent_flight() || !you.racial_permanent_flight())</a>
<a name="ln3601">        {</a>
<a name="ln3602">            // You can still evoke perm flight if you have temporary one.</a>
<a name="ln3603">            if (!you.airborne()</a>
<a name="ln3604">                || !you.attribute[ATTR_PERM_FLIGHT]</a>
<a name="ln3605">                   &amp;&amp; you.wearing_ego(EQ_ALL_ARMOUR, SPARM_FLYING))</a>
<a name="ln3606">            {</a>
<a name="ln3607">                _add_talent(talents, ABIL_EVOKE_FLIGHT, check_confused);</a>
<a name="ln3608">            }</a>
<a name="ln3609">            // Now you can only turn flight off if you have an</a>
<a name="ln3610">            // activatable item. Potions and spells will have to time</a>
<a name="ln3611">            // out.</a>
<a name="ln3612">            if (you.airborne() &amp;&amp; !you.attribute[ATTR_FLIGHT_UNCANCELLABLE])</a>
<a name="ln3613">                _add_talent(talents, ABIL_STOP_FLYING, check_confused);</a>
<a name="ln3614">        }</a>
<a name="ln3615">    }</a>
<a name="ln3616"> </a>
<a name="ln3617">    // Find hotkeys for the non-hotkeyed talents.</a>
<a name="ln3618">    for (talent &amp;tal : talents)</a>
<a name="ln3619">    {</a>
<a name="ln3620">        const int index = _lookup_ability_slot(tal.which);</a>
<a name="ln3621">        if (index &gt; -1)</a>
<a name="ln3622">        {</a>
<a name="ln3623">            tal.hotkey = index_to_letter(index);</a>
<a name="ln3624">            continue;</a>
<a name="ln3625">        }</a>
<a name="ln3626"> </a>
<a name="ln3627">        // Try to find a free hotkey for i, starting from Z.</a>
<a name="ln3628">        for (int k = 51; k &gt;= 0; --k)</a>
<a name="ln3629">        {</a>
<a name="ln3630">            const int kkey = index_to_letter(k);</a>
<a name="ln3631">            bool good_key = true;</a>
<a name="ln3632"> </a>
<a name="ln3633">            // Check that it doesn't conflict with other hotkeys.</a>
<a name="ln3634">            for (const talent &amp;other : talents)</a>
<a name="ln3635">                if (other.hotkey == kkey)</a>
<a name="ln3636">                {</a>
<a name="ln3637">                    good_key = false;</a>
<a name="ln3638">                    break;</a>
<a name="ln3639">                }</a>
<a name="ln3640"> </a>
<a name="ln3641">            if (good_key)</a>
<a name="ln3642">            {</a>
<a name="ln3643">                tal.hotkey = kkey;</a>
<a name="ln3644">                you.ability_letter_table[k] = tal.which;</a>
<a name="ln3645">                break;</a>
<a name="ln3646">            }</a>
<a name="ln3647">        }</a>
<a name="ln3648">        // In theory, we could be left with an unreachable ability</a>
<a name="ln3649">        // here (if you have 53 or more abilities simultaneously).</a>
<a name="ln3650">    }</a>
<a name="ln3651"> </a>
<a name="ln3652">    return talents;</a>
<a name="ln3653">}</a>
<a name="ln3654"> </a>
<a name="ln3655">/**</a>
<a name="ln3656"> * Maybe move an ability to the slot given by the ability_slot option.</a>
<a name="ln3657"> *</a>
<a name="ln3658"> * @param[in] slot current slot of the ability</a>
<a name="ln3659"> * @returns the new slot of the ability; may still be slot, if the ability</a>
<a name="ln3660"> *          was not reassigned.</a>
<a name="ln3661"> */</a>
<a name="ln3662">int auto_assign_ability_slot(int slot)</a>
<a name="ln3663">{</a>
<a name="ln3664">    const ability_type abil_type = you.ability_letter_table[slot];</a>
<a name="ln3665">    const string abilname = lowercase_string(ability_name(abil_type));</a>
<a name="ln3666">    bool overwrite = false;</a>
<a name="ln3667">    // check to see whether we've chosen an automatic label:</a>
<a name="ln3668">    for (auto&amp; mapping : Options.auto_ability_letters)</a>
<a name="ln3669">    {</a>
<a name="ln3670">        if (!mapping.first.matches(abilname))</a>
<a name="ln3671">            continue;</a>
<a name="ln3672">        for (char i : mapping.second)</a>
<a name="ln3673">        {</a>
<a name="ln3674">            if (i == '+')</a>
<a name="ln3675">                overwrite = true;</a>
<a name="ln3676">            else if (i == '-')</a>
<a name="ln3677">                overwrite = false;</a>
<a name="ln3678">            else if (isaalpha(i))</a>
<a name="ln3679">            {</a>
<a name="ln3680">                const int index = letter_to_index(i);</a>
<a name="ln3681">                ability_type existing_ability = you.ability_letter_table[index];</a>
<a name="ln3682"> </a>
<a name="ln3683">                if (existing_ability == ABIL_NON_ABILITY</a>
<a name="ln3684">                    || existing_ability == abil_type)</a>
<a name="ln3685">                {</a>
<a name="ln3686">                    // Unassigned or already assigned to this ability.</a>
<a name="ln3687">                    you.ability_letter_table[index] = abil_type;</a>
<a name="ln3688">                    if (slot != index)</a>
<a name="ln3689">                        you.ability_letter_table[slot] = ABIL_NON_ABILITY;</a>
<a name="ln3690">                    return index;</a>
<a name="ln3691">                }</a>
<a name="ln3692">                else if (overwrite)</a>
<a name="ln3693">                {</a>
<a name="ln3694">                    const string str = lowercase_string(ability_name(existing_ability));</a>
<a name="ln3695">                    // Don't overwrite an ability matched by the same rule.</a>
<a name="ln3696">                    if (mapping.first.matches(str))</a>
<a name="ln3697">                        continue;</a>
<a name="ln3698">                    you.ability_letter_table[slot] = abil_type;</a>
<a name="ln3699">                    swap_ability_slots(slot, index, true);</a>
<a name="ln3700">                    return index;</a>
<a name="ln3701">                }</a>
<a name="ln3702">                // else occupied, continue to the next mapping.</a>
<a name="ln3703">            }</a>
<a name="ln3704">        }</a>
<a name="ln3705">    }</a>
<a name="ln3706">    return slot;</a>
<a name="ln3707">}</a>
<a name="ln3708"> </a>
<a name="ln3709">// Returns an index (0-51) if already assigned, -1 if not.</a>
<a name="ln3710">static int _lookup_ability_slot(const ability_type abil)</a>
<a name="ln3711">{</a>
<a name="ln3712">    // Placeholder handling, part 2: The ability we have might</a>
<a name="ln3713">    // correspond to a placeholder, in which case the ability letter</a>
<a name="ln3714">    // table will contain that placeholder. Convert the latter to</a>
<a name="ln3715">    // its corresponding ability before comparing the two, so that</a>
<a name="ln3716">    // we'll find the placeholder's index properly.</a>
<a name="ln3717">    for (int slot = 0; slot &lt; 52; slot++)</a>
<a name="ln3718">        if (fixup_ability(you.ability_letter_table[slot]) == abil)</a>
<a name="ln3719">            return slot;</a>
<a name="ln3720">    return -1;</a>
<a name="ln3721">}</a>
<a name="ln3722"> </a>
<a name="ln3723">// Assign a new ability slot if necessary. Returns an index (0-51) if</a>
<a name="ln3724">// successful, -1 if you should just use the next one.</a>
<a name="ln3725">int find_ability_slot(const ability_type abil, char firstletter)</a>
<a name="ln3726">{</a>
<a name="ln3727">    // If we were already assigned a slot, use it.</a>
<a name="ln3728">    int had_slot = _lookup_ability_slot(abil);</a>
<a name="ln3729">    if (had_slot &gt; -1)</a>
<a name="ln3730">        return had_slot;</a>
<a name="ln3731"> </a>
<a name="ln3732">    // No requested slot, find new one and make it preferred.</a>
<a name="ln3733"> </a>
<a name="ln3734">    // firstletter defaults to 'f', because a-e is for invocations</a>
<a name="ln3735">    int first_slot = letter_to_index(firstletter);</a>
<a name="ln3736"> </a>
<a name="ln3737">    // Reserve the first non-god ability slot (f) for Draconian breath</a>
<a name="ln3738">    if (you.species == SP_BASE_DRACONIAN &amp;&amp; first_slot &gt;= letter_to_index('f'))</a>
<a name="ln3739">        first_slot += 1;</a>
<a name="ln3740"> </a>
<a name="ln3741">    ASSERT(first_slot &lt; 52);</a>
<a name="ln3742"> </a>
<a name="ln3743">    switch (abil)</a>
<a name="ln3744">    {</a>
<a name="ln3745">    case ABIL_ELYVILON_LIFESAVING:</a>
<a name="ln3746">        first_slot = letter_to_index('p');</a>
<a name="ln3747">        break;</a>
<a name="ln3748">    case ABIL_KIKU_GIFT_NECRONOMICON:</a>
<a name="ln3749">        first_slot = letter_to_index('N');</a>
<a name="ln3750">        break;</a>
<a name="ln3751">    case ABIL_TSO_BLESS_WEAPON:</a>
<a name="ln3752">    case ABIL_KIKU_BLESS_WEAPON:</a>
<a name="ln3753">    case ABIL_LUGONU_BLESS_WEAPON:</a>
<a name="ln3754">        first_slot = letter_to_index('W');</a>
<a name="ln3755">        break;</a>
<a name="ln3756">    case ABIL_CONVERT_TO_BEOGH:</a>
<a name="ln3757">        first_slot = letter_to_index('Y');</a>
<a name="ln3758">        break;</a>
<a name="ln3759">    case ABIL_RU_SACRIFICE_PURITY:</a>
<a name="ln3760">    case ABIL_RU_SACRIFICE_WORDS:</a>
<a name="ln3761">    case ABIL_RU_SACRIFICE_DRINK:</a>
<a name="ln3762">    case ABIL_RU_SACRIFICE_ESSENCE:</a>
<a name="ln3763">    case ABIL_RU_SACRIFICE_HEALTH:</a>
<a name="ln3764">    case ABIL_RU_SACRIFICE_STEALTH:</a>
<a name="ln3765">    case ABIL_RU_SACRIFICE_ARTIFICE:</a>
<a name="ln3766">    case ABIL_RU_SACRIFICE_LOVE:</a>
<a name="ln3767">    case ABIL_RU_SACRIFICE_COURAGE:</a>
<a name="ln3768">    case ABIL_RU_SACRIFICE_ARCANA:</a>
<a name="ln3769">    case ABIL_RU_SACRIFICE_NIMBLENESS:</a>
<a name="ln3770">    case ABIL_RU_SACRIFICE_DURABILITY:</a>
<a name="ln3771">    case ABIL_RU_SACRIFICE_HAND:</a>
<a name="ln3772">    case ABIL_RU_SACRIFICE_EXPERIENCE:</a>
<a name="ln3773">    case ABIL_RU_SACRIFICE_SKILL:</a>
<a name="ln3774">    case ABIL_RU_SACRIFICE_EYE:</a>
<a name="ln3775">    case ABIL_RU_SACRIFICE_RESISTANCE:</a>
<a name="ln3776">    case ABIL_RU_REJECT_SACRIFICES:</a>
<a name="ln3777">    case ABIL_HEPLIAKLQANA_TYPE_KNIGHT:</a>
<a name="ln3778">    case ABIL_HEPLIAKLQANA_TYPE_BATTLEMAGE:</a>
<a name="ln3779">    case ABIL_HEPLIAKLQANA_TYPE_HEXER:</a>
<a name="ln3780">    case ABIL_HEPLIAKLQANA_IDENTITY: // move this?</a>
<a name="ln3781">        first_slot = letter_to_index('G');</a>
<a name="ln3782">        break;</a>
<a name="ln3783">    default:</a>
<a name="ln3784">        break;</a>
<a name="ln3785">    }</a>
<a name="ln3786"> </a>
<a name="ln3787">    for (int slot = first_slot; slot &lt; 52; ++slot)</a>
<a name="ln3788">    {</a>
<a name="ln3789">        if (you.ability_letter_table[slot] == ABIL_NON_ABILITY)</a>
<a name="ln3790">        {</a>
<a name="ln3791">            you.ability_letter_table[slot] = abil;</a>
<a name="ln3792">            return auto_assign_ability_slot(slot);</a>
<a name="ln3793">        }</a>
<a name="ln3794">    }</a>
<a name="ln3795"> </a>
<a name="ln3796">    // If we can't find anything else, try a-e.</a>
<a name="ln3797">    for (int slot = first_slot - 1; slot &gt;= 0; --slot)</a>
<a name="ln3798">    {</a>
<a name="ln3799">        if (you.ability_letter_table[slot] == ABIL_NON_ABILITY)</a>
<a name="ln3800">        {</a>
<a name="ln3801">            you.ability_letter_table[slot] = abil;</a>
<a name="ln3802">            return auto_assign_ability_slot(slot);</a>
<a name="ln3803">        }</a>
<a name="ln3804">    }</a>
<a name="ln3805"> </a>
<a name="ln3806">    // All letters are assigned.</a>
<a name="ln3807">    return -1;</a>
<a name="ln3808">}</a>
<a name="ln3809"> </a>
<a name="ln3810"> </a>
<a name="ln3811">vector&lt;ability_type&gt; get_god_abilities(bool ignore_silence, bool ignore_piety,</a>
<a name="ln3812">                                       bool ignore_penance)</a>
<a name="ln3813">{</a>
<a name="ln3814">    vector&lt;ability_type&gt; abilities;</a>
<a name="ln3815">    if (you_worship(GOD_RU))</a>
<a name="ln3816">    {</a>
<a name="ln3817">        ASSERT(you.props.exists(AVAILABLE_SAC_KEY));</a>
<a name="ln3818">        bool any_sacrifices = false;</a>
<a name="ln3819">        for (const auto&amp; store : you.props[AVAILABLE_SAC_KEY].get_vector())</a>
<a name="ln3820">        {</a>
<a name="ln3821">            any_sacrifices = true;</a>
<a name="ln3822">            abilities.push_back(static_cast&lt;ability_type&gt;(store.get_int()));</a>
<a name="ln3823">        }</a>
<a name="ln3824">        if (any_sacrifices)</a>
<a name="ln3825">            abilities.push_back(ABIL_RU_REJECT_SACRIFICES);</a>
<a name="ln3826">    }</a>
<a name="ln3827">    // XXX: should we check ignore_piety?</a>
<a name="ln3828">    if (you_worship(GOD_HEPLIAKLQANA)</a>
<a name="ln3829">        &amp;&amp; piety_rank() &gt;= 2 &amp;&amp; !you.props.exists(HEPLIAKLQANA_ALLY_TYPE_KEY))</a>
<a name="ln3830">    {</a>
<a name="ln3831">        for (int anc_type = ABIL_HEPLIAKLQANA_FIRST_TYPE;</a>
<a name="ln3832">             anc_type &lt;= ABIL_HEPLIAKLQANA_LAST_TYPE;</a>
<a name="ln3833">             ++anc_type)</a>
<a name="ln3834">        {</a>
<a name="ln3835">            abilities.push_back(static_cast&lt;ability_type&gt;(anc_type));</a>
<a name="ln3836">        }</a>
<a name="ln3837">    }</a>
<a name="ln3838">    if (you.transfer_skill_points &gt; 0)</a>
<a name="ln3839">        abilities.push_back(ABIL_ASHENZARI_END_TRANSFER);</a>
<a name="ln3840">    if (silenced(you.pos()) &amp;&amp; you_worship(GOD_WU_JIAN) &amp;&amp; piety_rank() &gt;= 2)</a>
<a name="ln3841">        abilities.push_back(ABIL_WU_JIAN_WALLJUMP);</a>
<a name="ln3842"> </a>
<a name="ln3843">    if (!ignore_silence &amp;&amp; silenced(you.pos()))</a>
<a name="ln3844">        return abilities;</a>
<a name="ln3845">    // Remaining abilities are unusable if silenced.</a>
<a name="ln3846">    if (you_worship(GOD_NEMELEX_XOBEH))</a>
<a name="ln3847">    {</a>
<a name="ln3848">        for (int deck = ABIL_NEMELEX_FIRST_DECK;</a>
<a name="ln3849">             deck &lt;= ABIL_NEMELEX_LAST_DECK;</a>
<a name="ln3850">             ++deck)</a>
<a name="ln3851">        {</a>
<a name="ln3852">            abilities.push_back(static_cast&lt;ability_type&gt;(deck));</a>
<a name="ln3853">        }</a>
<a name="ln3854">        if (!you.props[NEMELEX_STACK_KEY].get_vector().empty())</a>
<a name="ln3855">            abilities.push_back(ABIL_NEMELEX_DRAW_STACK);</a>
<a name="ln3856">    }</a>
<a name="ln3857"> </a>
<a name="ln3858">    for (const auto&amp; power : get_god_powers(you.religion))</a>
<a name="ln3859">    {</a>
<a name="ln3860">        if (god_power_usable(power, ignore_piety, ignore_penance))</a>
<a name="ln3861">        {</a>
<a name="ln3862">            const ability_type abil = fixup_ability(power.abil);</a>
<a name="ln3863">            ASSERT(abil != ABIL_NON_ABILITY);</a>
<a name="ln3864">            abilities.push_back(abil);</a>
<a name="ln3865">        }</a>
<a name="ln3866">    }</a>
<a name="ln3867"> </a>
<a name="ln3868">    return abilities;</a>
<a name="ln3869">}</a>
<a name="ln3870"> </a>
<a name="ln3871">void swap_ability_slots(int index1, int index2, bool silent)</a>
<a name="ln3872">{</a>
<a name="ln3873">    // Swap references in the letter table.</a>
<a name="ln3874">    ability_type tmp = you.ability_letter_table[index2];</a>
<a name="ln3875">    you.ability_letter_table[index2] = you.ability_letter_table[index1];</a>
<a name="ln3876">    you.ability_letter_table[index1] = tmp;</a>
<a name="ln3877"> </a>
<a name="ln3878">    if (!silent)</a>
<a name="ln3879">    {</a>
<a name="ln3880">        mprf_nocap(&quot;%c - %s&quot;, index_to_letter(index2),</a>
<a name="ln3881">                   ability_name(you.ability_letter_table[index2]));</a>
<a name="ln3882">    }</a>
<a name="ln3883"> </a>
<a name="ln3884">}</a>
<a name="ln3885"> </a>
<a name="ln3886">/**</a>
<a name="ln3887"> * What skill affects the success chance/power of a given skill, if any?</a>
<a name="ln3888"> *</a>
<a name="ln3889"> * @param ability       The ability in question.</a>
<a name="ln3890"> * @return              The skill that governs the ability, or SK_NONE.</a>
<a name="ln3891"> */</a>
<a name="ln3892">skill_type abil_skill(ability_type ability)</a>
<a name="ln3893">{</a>
<a name="ln3894">    ASSERT(ability != ABIL_NON_ABILITY);</a>
<a name="ln3895">    return get_ability_def(ability).failure.skill();</a>
<a name="ln3896">}</a>
<a name="ln3897"> </a>
<a name="ln3898">/**</a>
<a name="ln3899"> * How valuable is it to train the skill that governs this ability? (What</a>
<a name="ln3900"> * 'magnitude' does the ability have?)</a>
<a name="ln3901"> *</a>
<a name="ln3902"> * @param ability       The ability in question.</a>
<a name="ln3903"> * @return              A 'magnitude' for the ability, probably &lt; 10.</a>
<a name="ln3904"> */</a>
<a name="ln3905">int abil_skill_weight(ability_type ability)</a>
<a name="ln3906">{</a>
<a name="ln3907">    ASSERT(ability != ABIL_NON_ABILITY);</a>
<a name="ln3908">    // This is very loosely modelled on a legacy model; fairly arbitrary.</a>
<a name="ln3909">    const int base_fail = get_ability_def(ability).failure.base_chance;</a>
<a name="ln3910">    const int floor = base_fail ? 1 : 0;</a>
<a name="ln3911">    return max(floor, div_rand_round(base_fail, 8) - 3);</a>
<a name="ln3912">}</a>
<a name="ln3913"> </a>
<a name="ln3914"> </a>
<a name="ln3915">////////////////////////////////////////////////////////////////////////</a>
<a name="ln3916">// generic_cost</a>
<a name="ln3917"> </a>
<a name="ln3918">int generic_cost::cost() const</a>
<a name="ln3919">{</a>
<a name="ln3920">    return base + (add &gt; 0 ? random2avg(add, rolls) : 0);</a>
<a name="ln3921">}</a>
<a name="ln3922"> </a>
<a name="ln3923">int scaling_cost::cost(int max) const</a>
<a name="ln3924">{</a>
<a name="ln3925">    return (value &lt; 0) ? (-value) : ((value * max + 500) / 1000);</a>
<a name="ln3926">}</a>

</code></pre>
<div class="balloon" rel="1378"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v648/" target="_blank">V648</a> Priority of the '&&' operation is higher than that of the '||' operation.</p></div>
<div class="balloon" rel="1404"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v768/" target="_blank">V768</a> The expression 'you.undead_state()' is of enum type. It is odd that it is used as an expression of a Boolean-type.</p></div>
<div class="balloon" rel="2152"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v1037/" target="_blank">V1037</a> Two or more case-branches perform the same actions. Check lines: 2152, 2619</p></div>
<div class="balloon" rel="3359"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v506/" target="_blank">V506</a> Pointer to local variable 'numbers' is stored outside the scope of this variable. Such a pointer will become invalid.</p></div>
<div class="balloon" rel="3396"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v506/" target="_blank">V506</a> Pointer to local variable 'numbers' is stored outside the scope of this variable. Such a pointer will become invalid.</p></div>
<div class="balloon" rel="3604"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v648/" target="_blank">V648</a> Priority of the '&&' operation is higher than that of the '||' operation.</p></div>

<link rel="stylesheet" href="highlight.css">
<script src="highlight.pack.js"></script>
<script src="highlightjs-line-numbers.js"></script>
<script>hljs.initHighlightingOnLoad();</script>
<script>hljs.initLineNumbersOnLoad();</script>
<script>
  $(document).ready(function() {
      $('.balloon').each(function () {
          var bl = $(this);
          var line = bl.attr('rel');
          var text = $('a[name="ln'+line+'"]').text();

          var space_count = 0;
          for(var i = 0; i<text.length; i++){
              var char = text[i];
              if((char !== ' ')&&(char !== '\t'))break;
              if(char === '\t')space_count++;
              space_count++;
          }

          bl.css('margin-left', space_count*8);
          $('a[name="ln'+line+'"]').after(bl);
      });

      window.location = window.location;
  });
</script>
</body>
</html>
