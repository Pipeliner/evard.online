
<html>
<head>

  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
  <title>files.cc</title>

  <link rel="stylesheet" href="../style.css"/>
  <script src="../jquery-3.2.1.min.js"></script>
</head>
<body>

<pre><code class = "cpp">
<a name="ln1">/**</a>
<a name="ln2"> * @file</a>
<a name="ln3"> * @brief Functions used to save and load levels/games.</a>
<a name="ln4">**/</a>
<a name="ln5"> </a>
<a name="ln6">#include &quot;AppHdr.h&quot;</a>
<a name="ln7"> </a>
<a name="ln8">#include &quot;files.h&quot;</a>
<a name="ln9"> </a>
<a name="ln10">#include &lt;algorithm&gt;</a>
<a name="ln11">#include &lt;cctype&gt;</a>
<a name="ln12">#include &lt;cerrno&gt;</a>
<a name="ln13">#include &lt;cstdio&gt;</a>
<a name="ln14">#include &lt;cstdlib&gt;</a>
<a name="ln15">#include &lt;cstring&gt;</a>
<a name="ln16">#include &lt;functional&gt;</a>
<a name="ln17">#include &lt;string&gt;</a>
<a name="ln18">#include &lt;fcntl.h&gt;</a>
<a name="ln19">#include &lt;sys/stat.h&gt;</a>
<a name="ln20">#ifdef HAVE_UTIMES</a>
<a name="ln21">#include &lt;sys/time.h&gt;</a>
<a name="ln22">#endif</a>
<a name="ln23">#include &lt;sys/types.h&gt;</a>
<a name="ln24">#ifdef UNIX</a>
<a name="ln25">#include &lt;unistd.h&gt;</a>
<a name="ln26">#endif</a>
<a name="ln27"> </a>
<a name="ln28">#include &quot;abyss.h&quot;</a>
<a name="ln29">#include &quot;act-iter.h&quot;</a>
<a name="ln30">#include &quot;areas.h&quot;</a>
<a name="ln31">#include &quot;branch.h&quot;</a>
<a name="ln32">#include &quot;chardump.h&quot;</a>
<a name="ln33">#include &quot;cloud.h&quot;</a>
<a name="ln34">#include &quot;coordit.h&quot;</a>
<a name="ln35">#include &quot;dactions.h&quot;</a>
<a name="ln36">#include &quot;dbg-util.h&quot;</a>
<a name="ln37">#include &quot;dgn-overview.h&quot;</a>
<a name="ln38">#include &quot;directn.h&quot;</a>
<a name="ln39">#include &quot;dungeon.h&quot;</a>
<a name="ln40">#include &quot;end.h&quot;</a>
<a name="ln41">#include &quot;errors.h&quot;</a>
<a name="ln42">#include &quot;player-save-info.h&quot;</a>
<a name="ln43">#include &quot;fineff.h&quot;</a>
<a name="ln44">#include &quot;food.h&quot; //for HUNGER_MAXIMUM</a>
<a name="ln45">#include &quot;ghost.h&quot;</a>
<a name="ln46">#include &quot;god-abil.h&quot;</a>
<a name="ln47">#include &quot;god-companions.h&quot;</a>
<a name="ln48">#include &quot;god-passive.h&quot;</a>
<a name="ln49">#include &quot;hints.h&quot;</a>
<a name="ln50">#include &quot;initfile.h&quot;</a>
<a name="ln51">#include &quot;item-name.h&quot;</a>
<a name="ln52">#include &quot;items.h&quot;</a>
<a name="ln53">#include &quot;jobs.h&quot;</a>
<a name="ln54">#include &quot;kills.h&quot;</a>
<a name="ln55">#include &quot;level-state-type.h&quot;</a>
<a name="ln56">#include &quot;libutil.h&quot;</a>
<a name="ln57">#include &quot;macro.h&quot;</a>
<a name="ln58">#include &quot;mapmark.h&quot;</a>
<a name="ln59">#include &quot;message.h&quot;</a>
<a name="ln60">#include &quot;mon-behv.h&quot;</a>
<a name="ln61">#include &quot;mon-death.h&quot;</a>
<a name="ln62">#include &quot;mon-place.h&quot;</a>
<a name="ln63">#include &quot;notes.h&quot;</a>
<a name="ln64">#include &quot;place.h&quot;</a>
<a name="ln65">#include &quot;prompt.h&quot;</a>
<a name="ln66">#include &quot;species.h&quot;</a>
<a name="ln67">#include &quot;spl-summoning.h&quot;</a>
<a name="ln68">#include &quot;stairs.h&quot;</a>
<a name="ln69">#include &quot;state.h&quot;</a>
<a name="ln70">#include &quot;stringutil.h&quot;</a>
<a name="ln71">#include &quot;syscalls.h&quot;</a>
<a name="ln72">#include &quot;teleport.h&quot;</a>
<a name="ln73">#include &quot;terrain.h&quot;</a>
<a name="ln74">#ifdef USE_TILE</a>
<a name="ln75"> // TODO -- dolls</a>
<a name="ln76"> #include &quot;rltiles/tiledef-player.h&quot;</a>
<a name="ln77"> #include &quot;tilepick-p.h&quot;</a>
<a name="ln78">#endif</a>
<a name="ln79">#include &quot;tileview.h&quot;</a>
<a name="ln80">#include &quot;tiles-build-specific.h&quot;</a>
<a name="ln81">#include &quot;timed-effects.h&quot;</a>
<a name="ln82">#include &quot;ui.h&quot;</a>
<a name="ln83">#include &quot;unwind.h&quot;</a>
<a name="ln84">#include &quot;version.h&quot;</a>
<a name="ln85">#include &quot;view.h&quot;</a>
<a name="ln86">#include &quot;xom.h&quot;</a>
<a name="ln87"> </a>
<a name="ln88">#ifdef __ANDROID__</a>
<a name="ln89">#include &lt;android/log.h&gt;</a>
<a name="ln90">#endif</a>
<a name="ln91"> </a>
<a name="ln92">#ifndef F_OK // MSVC for example</a>
<a name="ln93">#define F_OK 0</a>
<a name="ln94">#endif</a>
<a name="ln95"> </a>
<a name="ln96">#define BONES_DIAGNOSTICS (defined(WIZARD) || defined(DEBUG_BONES) || defined(DEBUG_DIAGNOSTICS))</a>
<a name="ln97"> </a>
<a name="ln98">#ifdef BONES_DIAGNOSTICS</a>
<a name="ln99">/// show diagnostics following a wizard command, even if not a debug build</a>
<a name="ln100">static void _ghost_dprf(const char *format, ...)</a>
<a name="ln101">{</a>
<a name="ln102">    va_list argp;</a>
<a name="ln103">    va_start(argp, format);</a>
<a name="ln104"> </a>
<a name="ln105">#ifndef DEBUG_DIAGNOSTICS</a>
<a name="ln106">    const bool wiz_cmd = (crawl_state.prev_cmd == CMD_WIZARD);</a>
<a name="ln107">    if (wiz_cmd)</a>
<a name="ln108">#endif</a>
<a name="ln109">        do_message_print(MSGCH_DIAGNOSTICS, 0, false, false, format, argp);</a>
<a name="ln110"> </a>
<a name="ln111">    va_end(argp);</a>
<a name="ln112">}</a>
<a name="ln113">#else</a>
<a name="ln114"># define _ghost_dprf(...) ((void)0)</a>
<a name="ln115">#endif</a>
<a name="ln116"> </a>
<a name="ln117">static void _save_level(const level_id&amp; lid);</a>
<a name="ln118"> </a>
<a name="ln119">static bool _ghost_version_compatible(const save_version &amp;version);</a>
<a name="ln120"> </a>
<a name="ln121">static bool _restore_tagged_chunk(package *save, const string &amp;name,</a>
<a name="ln122">                                  tag_type tag, const char* complaint);</a>
<a name="ln123">static bool _read_char_chunk(package *save);</a>
<a name="ln124"> </a>
<a name="ln125">static bool _convert_obsolete_species();</a>
<a name="ln126"> </a>
<a name="ln127">const short GHOST_SIGNATURE = short(0xDC55);</a>
<a name="ln128"> </a>
<a name="ln129">const int GHOST_LIMIT = 27; // max number of ghost files per level</a>
<a name="ln130"> </a>
<a name="ln131">static void _redraw_all()</a>
<a name="ln132">{</a>
<a name="ln133">    you.redraw_hit_points    = true;</a>
<a name="ln134">    you.redraw_magic_points  = true;</a>
<a name="ln135">    you.redraw_stats.init(true);</a>
<a name="ln136">    you.redraw_armour_class  = true;</a>
<a name="ln137">    you.redraw_evasion       = true;</a>
<a name="ln138">    you.redraw_experience    = true;</a>
<a name="ln139">    you.redraw_status_lights = true;</a>
<a name="ln140">}</a>
<a name="ln141"> </a>
<a name="ln142">static bool is_save_file_name(const string &amp;name)</a>
<a name="ln143">{</a>
<a name="ln144">    int off = name.length() - strlen(SAVE_SUFFIX);</a>
<a name="ln145">    if (off &lt;= 0)</a>
<a name="ln146">        return false;</a>
<a name="ln147">    return !strcasecmp(name.c_str() + off, SAVE_SUFFIX);</a>
<a name="ln148">}</a>
<a name="ln149"> </a>
<a name="ln150">// Returns the save_info from the save.</a>
<a name="ln151">static player_save_info _read_character_info(package *save)</a>
<a name="ln152">{</a>
<a name="ln153">    player_save_info fromfile;</a>
<a name="ln154"> </a>
<a name="ln155">    // Backup before we clobber &quot;you&quot;.</a>
<a name="ln156">    const player backup(you);</a>
<a name="ln157">    unwind_var&lt;game_type&gt; gtype(crawl_state.type);</a>
<a name="ln158"> </a>
<a name="ln159">    try // need a redundant try block just so we can restore the backup</a>
<a name="ln160">    {   // (or risk an = operator on you getting misused)</a>
<a name="ln161">        fromfile.save_loadable = _read_char_chunk(save);</a>
<a name="ln162">        fromfile = you;</a>
<a name="ln163">    }</a>
<a name="ln164">    catch (ext_fail_exception &amp;E) {}</a>
<a name="ln165"> </a>
<a name="ln166">    you = backup;</a>
<a name="ln167"> </a>
<a name="ln168">    return fromfile;</a>
<a name="ln169">}</a>
<a name="ln170"> </a>
<a name="ln171">vector&lt;string&gt; get_dir_files_sorted(const string &amp;dirname)</a>
<a name="ln172">{</a>
<a name="ln173">    auto result = get_dir_files(dirname);</a>
<a name="ln174">    sort(result.begin(), result.end());</a>
<a name="ln175">    return result;</a>
<a name="ln176">}</a>
<a name="ln177"> </a>
<a name="ln178">// Returns a vector of files (including directories if requested) in</a>
<a name="ln179">// the given directory, recursively. All filenames returned are</a>
<a name="ln180">// relative to the start directory. If an extension is supplied, all</a>
<a name="ln181">// filenames (and directory names if include_directories is set)</a>
<a name="ln182">// returned must be suffixed with the extension (the extension is not</a>
<a name="ln183">// modified in any way, so if you want, say, &quot;.des&quot;, you must include</a>
<a name="ln184">// the &quot;.&quot; as well).</a>
<a name="ln185">//</a>
<a name="ln186">// If recursion_depth is -1, the recursion is infinite, as far as the</a>
<a name="ln187">// directory structure and filesystem allows. If recursion_depth is 0,</a>
<a name="ln188">// only files in the start directory are returned.</a>
<a name="ln189">vector&lt;string&gt; get_dir_files_recursive(const string &amp;dirname, const string &amp;ext,</a>
<a name="ln190">                                       int recursion_depth,</a>
<a name="ln191">                                       bool include_directories)</a>
<a name="ln192">{</a>
<a name="ln193">    vector&lt;string&gt; files;</a>
<a name="ln194"> </a>
<a name="ln195">    const int next_recur_depth =</a>
<a name="ln196">        recursion_depth == -1? -1 : recursion_depth - 1;</a>
<a name="ln197">    const bool recur = recursion_depth == -1 || recursion_depth &gt; 0;</a>
<a name="ln198"> </a>
<a name="ln199">    for (const string &amp;filename : get_dir_files_sorted(dirname))</a>
<a name="ln200">    {</a>
<a name="ln201">        if (dir_exists(catpath(dirname, filename)))</a>
<a name="ln202">        {</a>
<a name="ln203">            if (include_directories</a>
<a name="ln204">                &amp;&amp; (ext.empty() || ends_with(filename, ext)))</a>
<a name="ln205">            {</a>
<a name="ln206">                files.push_back(filename);</a>
<a name="ln207">            }</a>
<a name="ln208"> </a>
<a name="ln209">            if (recur)</a>
<a name="ln210">            {</a>
<a name="ln211">                // Each filename in a subdirectory has to be prefixed</a>
<a name="ln212">                // with the subdirectory name.</a>
<a name="ln213">                for (const string &amp;subdirfile</a>
<a name="ln214">                        : get_dir_files_recursive(catpath(dirname, filename),</a>
<a name="ln215">                                                  ext, next_recur_depth))</a>
<a name="ln216">                {</a>
<a name="ln217">                    files.push_back(catpath(filename, subdirfile));</a>
<a name="ln218">                }</a>
<a name="ln219">            }</a>
<a name="ln220">        }</a>
<a name="ln221">        else</a>
<a name="ln222">        {</a>
<a name="ln223">            if (ext.empty() || ends_with(filename, ext))</a>
<a name="ln224">                files.push_back(filename);</a>
<a name="ln225">        }</a>
<a name="ln226">    }</a>
<a name="ln227">    return files;</a>
<a name="ln228">}</a>
<a name="ln229"> </a>
<a name="ln230">vector&lt;string&gt; get_dir_files_ext(const string &amp;dir, const string &amp;ext)</a>
<a name="ln231">{</a>
<a name="ln232">    return get_dir_files_recursive(dir, ext, 0);</a>
<a name="ln233">}</a>
<a name="ln234"> </a>
<a name="ln235">string get_parent_directory(const string &amp;filename)</a>
<a name="ln236">{</a>
<a name="ln237">    string::size_type pos = filename.rfind(FILE_SEPARATOR);</a>
<a name="ln238">    if (pos != string::npos)</a>
<a name="ln239">        return filename.substr(0, pos + 1);</a>
<a name="ln240">#ifdef ALT_FILE_SEPARATOR</a>
<a name="ln241">    pos = filename.rfind(ALT_FILE_SEPARATOR);</a>
<a name="ln242">    if (pos != string::npos)</a>
<a name="ln243">        return filename.substr(0, pos + 1);</a>
<a name="ln244">#endif</a>
<a name="ln245">    return &quot;&quot;;</a>
<a name="ln246">}</a>
<a name="ln247"> </a>
<a name="ln248">string get_base_filename(const string &amp;filename)</a>
<a name="ln249">{</a>
<a name="ln250">    string::size_type pos = filename.rfind(FILE_SEPARATOR);</a>
<a name="ln251">    if (pos != string::npos)</a>
<a name="ln252">        return filename.substr(pos + 1);</a>
<a name="ln253">#ifdef ALT_FILE_SEPARATOR</a>
<a name="ln254">    pos = filename.rfind(ALT_FILE_SEPARATOR);</a>
<a name="ln255">    if (pos != string::npos)</a>
<a name="ln256">        return filename.substr(pos + 1);</a>
<a name="ln257">#endif</a>
<a name="ln258">    return filename;</a>
<a name="ln259">}</a>
<a name="ln260"> </a>
<a name="ln261">string get_cache_name(const string &amp;filename)</a>
<a name="ln262">{</a>
<a name="ln263">    string::size_type pos = filename.rfind(FILE_SEPARATOR);</a>
<a name="ln264">    while (pos != string::npos &amp;&amp; filename.find(&quot;/des&quot;, pos) != pos)</a>
<a name="ln265">        pos = filename.rfind(FILE_SEPARATOR, pos - 1);</a>
<a name="ln266">    if (pos != string::npos)</a>
<a name="ln267">        return replace_all_of(filename.substr(pos + 5), &quot; /\\:&quot;, &quot;_&quot;);</a>
<a name="ln268">#ifdef ALT_FILE_SEPARATOR</a>
<a name="ln269">    pos = filename.rfind(ALT_FILE_SEPARATOR);</a>
<a name="ln270">    while (pos != string::npos &amp;&amp; filename.find(&quot;/des&quot;, pos) != pos)</a>
<a name="ln271">        pos = filename.rfind(ALT_FILE_SEPARATOR, pos - 1);</a>
<a name="ln272">    if (pos != string::npos)</a>
<a name="ln273">        return replace_all_of(filename.substr(pos + 5), &quot; /\\:&quot;, &quot;_&quot;);</a>
<a name="ln274">#endif</a>
<a name="ln275">    return filename;</a>
<a name="ln276">}</a>
<a name="ln277"> </a>
<a name="ln278">bool is_absolute_path(const string &amp;path)</a>
<a name="ln279">{</a>
<a name="ln280">    return !path.empty()</a>
<a name="ln281">           &amp;&amp; (path[0] == FILE_SEPARATOR</a>
<a name="ln282">#ifdef TARGET_OS_WINDOWS</a>
<a name="ln283">               || path.find(':') != string::npos</a>
<a name="ln284">#endif</a>
<a name="ln285">             );</a>
<a name="ln286">}</a>
<a name="ln287"> </a>
<a name="ln288">// Concatenates two paths, separating them with FILE_SEPARATOR if necessary.</a>
<a name="ln289">// Assumes that the second path is not absolute.</a>
<a name="ln290">//</a>
<a name="ln291">// If the first path is empty, returns the second unchanged. The second path</a>
<a name="ln292">// may be absolute in this case.</a>
<a name="ln293">string catpath(const string &amp;first, const string &amp;second)</a>
<a name="ln294">{</a>
<a name="ln295">    if (first.empty())</a>
<a name="ln296">        return second;</a>
<a name="ln297"> </a>
<a name="ln298">    string directory = first;</a>
<a name="ln299">    if (directory[directory.length() - 1] != FILE_SEPARATOR</a>
<a name="ln300">        &amp;&amp; (second.empty() || second[0] != FILE_SEPARATOR))</a>
<a name="ln301">    {</a>
<a name="ln302">        directory += FILE_SEPARATOR;</a>
<a name="ln303">    }</a>
<a name="ln304">    directory += second;</a>
<a name="ln305"> </a>
<a name="ln306">    return directory;</a>
<a name="ln307">}</a>
<a name="ln308"> </a>
<a name="ln309">// Given a relative path and a reference file name, returns the relative path</a>
<a name="ln310">// suffixed to the directory containing the reference file name. Assumes that</a>
<a name="ln311">// the second path is not absolute.</a>
<a name="ln312">string get_path_relative_to(const string &amp;referencefile,</a>
<a name="ln313">                            const string &amp;relativepath)</a>
<a name="ln314">{</a>
<a name="ln315">    return catpath(get_parent_directory(referencefile),</a>
<a name="ln316">                   relativepath);</a>
<a name="ln317">}</a>
<a name="ln318"> </a>
<a name="ln319">string change_file_extension(const string &amp;filename, const string &amp;ext)</a>
<a name="ln320">{</a>
<a name="ln321">    const string::size_type pos = filename.rfind('.');</a>
<a name="ln322">    return (pos == string::npos? filename : filename.substr(0, pos)) + ext;</a>
<a name="ln323">}</a>
<a name="ln324"> </a>
<a name="ln325">time_t file_modtime(const string &amp;file)</a>
<a name="ln326">{</a>
<a name="ln327">    struct stat filestat;</a>
<a name="ln328">    if (stat(file.c_str(), &amp;filestat))</a>
<a name="ln329">        return 0;</a>
<a name="ln330"> </a>
<a name="ln331">    return filestat.st_mtime;</a>
<a name="ln332">}</a>
<a name="ln333"> </a>
<a name="ln334">time_t file_modtime(FILE *f)</a>
<a name="ln335">{</a>
<a name="ln336">    struct stat filestat;</a>
<a name="ln337">    if (fstat(fileno(f), &amp;filestat))</a>
<a name="ln338">        return 0;</a>
<a name="ln339"> </a>
<a name="ln340">    return filestat.st_mtime;</a>
<a name="ln341">}</a>
<a name="ln342"> </a>
<a name="ln343">static bool _create_directory(const char *dir)</a>
<a name="ln344">{</a>
<a name="ln345">    if (!mkdir_u(dir, 0755))</a>
<a name="ln346">        return true;</a>
<a name="ln347">    if (errno == EEXIST) // might be not a directory</a>
<a name="ln348">        return dir_exists(dir);</a>
<a name="ln349">    return false;</a>
<a name="ln350">}</a>
<a name="ln351"> </a>
<a name="ln352">static bool _create_dirs(const string &amp;dir)</a>
<a name="ln353">{</a>
<a name="ln354">    string sep = &quot; &quot;;</a>
<a name="ln355">    sep[0] = FILE_SEPARATOR;</a>
<a name="ln356">    vector&lt;string&gt; segments = split_string(sep, dir, false, false);</a>
<a name="ln357"> </a>
<a name="ln358">    string path;</a>
<a name="ln359">    for (int i = 0, size = segments.size(); i &lt; size; ++i)</a>
<a name="ln360">    {</a>
<a name="ln361">        path += segments[i];</a>
<a name="ln362"> </a>
<a name="ln363">        // Handle absolute paths correctly.</a>
<a name="ln364">        if (i == 0 &amp;&amp; dir.size() &amp;&amp; dir[0] == FILE_SEPARATOR)</a>
<a name="ln365">            path = FILE_SEPARATOR + path;</a>
<a name="ln366"> </a>
<a name="ln367">        if (!_create_directory(path.c_str()))</a>
<a name="ln368">            return false;</a>
<a name="ln369"> </a>
<a name="ln370">        path += FILE_SEPARATOR;</a>
<a name="ln371">    }</a>
<a name="ln372">    return true;</a>
<a name="ln373">}</a>
<a name="ln374"> </a>
<a name="ln375">// Checks whether the given path is safe to read from. A path is safe if:</a>
<a name="ln376">// 1. If Unix: It contains no shell metacharacters.</a>
<a name="ln377">// 2. If DATA_DIR_PATH is set: the path is not an absolute path.</a>
<a name="ln378">// 3. If DATA_DIR_PATH is set: the path contains no &quot;..&quot; sequence.</a>
<a name="ln379">void assert_read_safe_path(const string &amp;path)</a>
<a name="ln380">{</a>
<a name="ln381">    // Check for rank tomfoolery first:</a>
<a name="ln382">    if (path.empty())</a>
<a name="ln383">        throw unsafe_path(&quot;Empty file name.&quot;);</a>
<a name="ln384"> </a>
<a name="ln385">#ifdef UNIX</a>
<a name="ln386">    if (!shell_safe(path.c_str()))</a>
<a name="ln387">        throw unsafe_path_f(&quot;\&quot;%s\&quot; contains bad characters.&quot;, path.c_str());</a>
<a name="ln388">#endif</a>
<a name="ln389"> </a>
<a name="ln390">#ifdef DATA_DIR_PATH</a>
<a name="ln391">    if (is_absolute_path(path))</a>
<a name="ln392">        throw unsafe_path_f(&quot;\&quot;%s\&quot; is an absolute path.&quot;, path.c_str());</a>
<a name="ln393"> </a>
<a name="ln394">    if (path.find(&quot;..&quot;) != string::npos)</a>
<a name="ln395">        throw unsafe_path_f(&quot;\&quot;%s\&quot; contains \&quot;..\&quot; sequences.&quot;, path.c_str());</a>
<a name="ln396">#endif</a>
<a name="ln397"> </a>
<a name="ln398">    // Path is okay.</a>
<a name="ln399">}</a>
<a name="ln400"> </a>
<a name="ln401">string canonicalise_file_separator(const string &amp;path)</a>
<a name="ln402">{</a>
<a name="ln403">    const string sep(1, FILE_SEPARATOR);</a>
<a name="ln404">    return replace_all_of(replace_all_of(path, &quot;/&quot;, sep),</a>
<a name="ln405">                          &quot;\\&quot;, sep);</a>
<a name="ln406">}</a>
<a name="ln407"> </a>
<a name="ln408">static vector&lt;string&gt; _get_base_dirs()</a>
<a name="ln409">{</a>
<a name="ln410">    const string rawbases[] =</a>
<a name="ln411">    {</a>
<a name="ln412">#ifdef DATA_DIR_PATH</a>
<a name="ln413">        DATA_DIR_PATH,</a>
<a name="ln414">#else</a>
<a name="ln415">        !SysEnv.crawl_dir.empty()? SysEnv.crawl_dir : &quot;&quot;,</a>
<a name="ln416">        !SysEnv.crawl_base.empty()? SysEnv.crawl_base : &quot;&quot;,</a>
<a name="ln417">#endif</a>
<a name="ln418">#ifdef TARGET_OS_MACOSX</a>
<a name="ln419">        SysEnv.crawl_base + &quot;../Resources/&quot;,</a>
<a name="ln420">#endif</a>
<a name="ln421">#ifdef __ANDROID__</a>
<a name="ln422">        ANDROID_ASSETS,</a>
<a name="ln423">        &quot;/sdcard/Android/data/org.develz.crawl/files/&quot;,</a>
<a name="ln424">#endif</a>
<a name="ln425">    };</a>
<a name="ln426"> </a>
<a name="ln427">    const string prefixes[] =</a>
<a name="ln428">    {</a>
<a name="ln429">        string(&quot;dat&quot;) + FILE_SEPARATOR,</a>
<a name="ln430">#ifdef USE_TILE_LOCAL</a>
<a name="ln431">        string(&quot;dat/tiles&quot;) + FILE_SEPARATOR,</a>
<a name="ln432">#endif</a>
<a name="ln433">        string(&quot;docs&quot;) + FILE_SEPARATOR,</a>
<a name="ln434">        string(&quot;settings&quot;) + FILE_SEPARATOR,</a>
<a name="ln435">#ifndef DATA_DIR_PATH</a>
<a name="ln436">        string(&quot;..&quot;) + FILE_SEPARATOR + &quot;docs&quot; + FILE_SEPARATOR,</a>
<a name="ln437">        string(&quot;..&quot;) + FILE_SEPARATOR + &quot;dat&quot; + FILE_SEPARATOR,</a>
<a name="ln438">#ifdef USE_TILE_LOCAL</a>
<a name="ln439">        string(&quot;..&quot;) + FILE_SEPARATOR + &quot;dat/tiles&quot; + FILE_SEPARATOR,</a>
<a name="ln440">#endif</a>
<a name="ln441">        string(&quot;..&quot;) + FILE_SEPARATOR + &quot;settings&quot; + FILE_SEPARATOR,</a>
<a name="ln442">        string(&quot;..&quot;) + FILE_SEPARATOR,</a>
<a name="ln443">#endif</a>
<a name="ln444">        &quot;&quot;,</a>
<a name="ln445">    };</a>
<a name="ln446"> </a>
<a name="ln447">    vector&lt;string&gt; bases;</a>
<a name="ln448">    for (string base : rawbases)</a>
<a name="ln449">    {</a>
<a name="ln450">        if (base.empty())</a>
<a name="ln451">            continue;</a>
<a name="ln452"> </a>
<a name="ln453">        base = canonicalise_file_separator(base);</a>
<a name="ln454"> </a>
<a name="ln455">        if (base[base.length() - 1] != FILE_SEPARATOR)</a>
<a name="ln456">            base += FILE_SEPARATOR;</a>
<a name="ln457"> </a>
<a name="ln458">        for (unsigned p = 0; p &lt; ARRAYSZ(prefixes); ++p)</a>
<a name="ln459">            bases.push_back(base + prefixes[p]);</a>
<a name="ln460">    }</a>
<a name="ln461"> </a>
<a name="ln462">    return bases;</a>
<a name="ln463">}</a>
<a name="ln464"> </a>
<a name="ln465">void validate_basedirs()</a>
<a name="ln466">{</a>
<a name="ln467">    // TODO: could use this to pick a single data directory?</a>
<a name="ln468">    vector&lt;string&gt; bases(_get_base_dirs());</a>
<a name="ln469">    bool found = false;</a>
<a name="ln470"> </a>
<a name="ln471">    // there are a few others, but this should be enough to minimally run something</a>
<a name="ln472">    const vector&lt;string&gt; data_subfolders =</a>
<a name="ln473">    {</a>
<a name="ln474">#ifdef CLUA_BINDINGS</a>
<a name="ln475">        &quot;clua&quot;,</a>
<a name="ln476">#endif</a>
<a name="ln477">        &quot;database&quot;,</a>
<a name="ln478">        &quot;defaults&quot;,</a>
<a name="ln479">        &quot;des&quot;,</a>
<a name="ln480">        &quot;descript&quot;,</a>
<a name="ln481">        &quot;dlua&quot;</a>
<a name="ln482">#ifdef USE_TILE_LOCAL</a>
<a name="ln483">        , &quot;tiles&quot;</a>
<a name="ln484">#endif</a>
<a name="ln485">    };</a>
<a name="ln486"> </a>
<a name="ln487">    for (const string &amp;d : bases)</a>
<a name="ln488">    {</a>
<a name="ln489">        if (dir_exists(d))</a>
<a name="ln490">        {</a>
<a name="ln491">            bool everything = true;</a>
<a name="ln492">            bool something = false;</a>
<a name="ln493">            for (auto subdir : data_subfolders)</a>
<a name="ln494">            {</a>
<a name="ln495">                if (dir_exists(d + subdir))</a>
<a name="ln496">                    something = true;</a>
<a name="ln497">                else</a>
<a name="ln498">                    everything = false;</a>
<a name="ln499">            }</a>
<a name="ln500">            if (everything)</a>
<a name="ln501">            {</a>
<a name="ln502">                mprf(MSGCH_PLAIN, &quot;Data directory '%s' found.&quot;, d.c_str());</a>
<a name="ln503">                found = true;</a>
<a name="ln504">            }</a>
<a name="ln505">            else if (something)</a>
<a name="ln506">            {</a>
<a name="ln507">                // give an error for this case because this incomplete data</a>
<a name="ln508">                // directory will be checked before others, possibly leading</a>
<a name="ln509">                // to a weird mix of data files.</a>
<a name="ln510">                if (!found)</a>
<a name="ln511">                {</a>
<a name="ln512">                    mprf(MSGCH_ERROR,</a>
<a name="ln513">                        &quot;Incomplete or corrupted data directory '%s'&quot;,</a>
<a name="ln514">                                d.c_str());</a>
<a name="ln515">                }</a>
<a name="ln516">            }</a>
<a name="ln517">        }</a>
<a name="ln518">    }</a>
<a name="ln519"> </a>
<a name="ln520">    // can't proceed if nothing complete was found.</a>
<a name="ln521">    if (!found)</a>
<a name="ln522">    {</a>
<a name="ln523">        string err = &quot;Missing DCSS data directory; tried: \n&quot;;</a>
<a name="ln524">        err += comma_separated_line(bases.begin(), bases.end());</a>
<a name="ln525"> </a>
<a name="ln526">        end(1, false, &quot;%s&quot;, err.c_str());</a>
<a name="ln527">    }</a>
<a name="ln528">}</a>
<a name="ln529"> </a>
<a name="ln530">string datafile_path(string basename, bool croak_on_fail, bool test_base_path,</a>
<a name="ln531">                     bool (*thing_exists)(const string&amp;))</a>
<a name="ln532">{</a>
<a name="ln533">    basename = canonicalise_file_separator(basename);</a>
<a name="ln534"> </a>
<a name="ln535">    if (test_base_path &amp;&amp; thing_exists(basename))</a>
<a name="ln536">        return basename;</a>
<a name="ln537"> </a>
<a name="ln538">    for (const string &amp;basedir : _get_base_dirs())</a>
<a name="ln539">    {</a>
<a name="ln540">        string name = basedir + basename;</a>
<a name="ln541">#ifdef __ANDROID__</a>
<a name="ln542">        __android_log_print(ANDROID_LOG_INFO,&quot;Crawl&quot;,&quot;Looking for %s as '%s'&quot;,basename.c_str(),name.c_str());</a>
<a name="ln543">#endif</a>
<a name="ln544">        if (thing_exists(name))</a>
<a name="ln545">            return name;</a>
<a name="ln546">    }</a>
<a name="ln547"> </a>
<a name="ln548">    // Die horribly.</a>
<a name="ln549">    if (croak_on_fail)</a>
<a name="ln550">    {</a>
<a name="ln551">        end(1, false, &quot;Cannot find data file '%s' anywhere, aborting\n&quot;,</a>
<a name="ln552">            basename.c_str());</a>
<a name="ln553">    }</a>
<a name="ln554"> </a>
<a name="ln555">    return &quot;&quot;;</a>
<a name="ln556">}</a>
<a name="ln557"> </a>
<a name="ln558">// Checks if directory 'dir' exists and tries to create it if it</a>
<a name="ln559">// doesn't exist, modifying 'dir' to its canonical form.</a>
<a name="ln560">//</a>
<a name="ln561">// If given an empty 'dir', returns true without modifying 'dir' or</a>
<a name="ln562">// performing any other checks.</a>
<a name="ln563">//</a>
<a name="ln564">// Otherwise, returns true if the directory already exists or was just</a>
<a name="ln565">// created. 'dir' will be modified to a canonical representation,</a>
<a name="ln566">// guaranteed to have the file separator appended to it, and with any</a>
<a name="ln567">// / and \ separators replaced with the one true FILE_SEPARATOR.</a>
<a name="ln568">//</a>
<a name="ln569">bool check_mkdir(const string &amp;whatdir, string *dir, bool silent)</a>
<a name="ln570">{</a>
<a name="ln571">    if (dir-&gt;empty())</a>
<a name="ln572">        return true;</a>
<a name="ln573"> </a>
<a name="ln574">    *dir = canonicalise_file_separator(*dir);</a>
<a name="ln575"> </a>
<a name="ln576">    // Suffix the separator if necessary</a>
<a name="ln577">    if ((*dir)[dir-&gt;length() - 1] != FILE_SEPARATOR)</a>
<a name="ln578">        *dir += FILE_SEPARATOR;</a>
<a name="ln579"> </a>
<a name="ln580">    if (!dir_exists(*dir) &amp;&amp; !_create_dirs(*dir))</a>
<a name="ln581">    {</a>
<a name="ln582">        if (!silent)</a>
<a name="ln583">        {</a>
<a name="ln584">#ifdef __ANDROID__</a>
<a name="ln585">            __android_log_print(ANDROID_LOG_INFO, &quot;Crawl&quot;,</a>
<a name="ln586">                                &quot;%s \&quot;%s\&quot; does not exist and I can't create it.&quot;,</a>
<a name="ln587">                                whatdir.c_str(), dir-&gt;c_str());</a>
<a name="ln588">#endif</a>
<a name="ln589">            fprintf(stderr, &quot;%s \&quot;%s\&quot; does not exist &quot;</a>
<a name="ln590">                    &quot;and I can't create it.\n&quot;,</a>
<a name="ln591">                    whatdir.c_str(), dir-&gt;c_str());</a>
<a name="ln592">        }</a>
<a name="ln593">        return false;</a>
<a name="ln594">    }</a>
<a name="ln595"> </a>
<a name="ln596">    return true;</a>
<a name="ln597">}</a>
<a name="ln598"> </a>
<a name="ln599">// Get the directory that contains save files for the current game</a>
<a name="ln600">// type. This will not be the same as get_base_savedir() for game</a>
<a name="ln601">// types such as Sprint.</a>
<a name="ln602">static string _get_savefile_directory()</a>
<a name="ln603">{</a>
<a name="ln604">    string dir = catpath(Options.save_dir, crawl_state.game_savedir_path());</a>
<a name="ln605">    check_mkdir(&quot;Save directory&quot;, &amp;dir, false);</a>
<a name="ln606">    if (dir.empty())</a>
<a name="ln607">        dir = &quot;.&quot;;</a>
<a name="ln608">    return dir;</a>
<a name="ln609">}</a>
<a name="ln610"> </a>
<a name="ln611"> </a>
<a name="ln612">/**</a>
<a name="ln613"> * Location of legacy ghost files. (The save directory.)</a>
<a name="ln614"> *</a>
<a name="ln615"> * @return The path to the directory for old ghost files.</a>
<a name="ln616"> */</a>
<a name="ln617">static string _get_old_bonefile_directory()</a>
<a name="ln618">{</a>
<a name="ln619">    string dir = catpath(Options.shared_dir, crawl_state.game_savedir_path());</a>
<a name="ln620">    check_mkdir(&quot;Bones directory&quot;, &amp;dir, false);</a>
<a name="ln621">    if (dir.empty())</a>
<a name="ln622">        dir = &quot;.&quot;;</a>
<a name="ln623">    return dir;</a>
<a name="ln624">}</a>
<a name="ln625"> </a>
<a name="ln626">/**</a>
<a name="ln627"> * Location of ghost files.</a>
<a name="ln628"> *</a>
<a name="ln629"> * @return The path to the directory for ghost files.</a>
<a name="ln630"> */</a>
<a name="ln631">static string _get_bonefile_directory()</a>
<a name="ln632">{</a>
<a name="ln633">    string dir = catpath(Options.shared_dir, crawl_state.game_savedir_path());</a>
<a name="ln634">    dir = catpath(dir, &quot;bones&quot;);</a>
<a name="ln635">    check_mkdir(&quot;Bones directory&quot;, &amp;dir, false);</a>
<a name="ln636">    if (dir.empty())</a>
<a name="ln637">        dir = &quot;.&quot;;</a>
<a name="ln638">    return dir;</a>
<a name="ln639">}</a>
<a name="ln640"> </a>
<a name="ln641">// Returns a subdirectory of the current savefile directory as returned by</a>
<a name="ln642">// _get_savefile_directory.</a>
<a name="ln643">static string _get_savedir_path(const string &amp;shortpath)</a>
<a name="ln644">{</a>
<a name="ln645">    return canonicalise_file_separator(</a>
<a name="ln646">        catpath(_get_savefile_directory(), shortpath));</a>
<a name="ln647">}</a>
<a name="ln648"> </a>
<a name="ln649">// Returns a subdirectory of the base save directory that contains all saves</a>
<a name="ln650">// and cache directories. Save files for game type != GAME_TYPE_NORMAL may</a>
<a name="ln651">// be found in a subdirectory of this dir. Use _get_savefile_directory() if</a>
<a name="ln652">// you want the directory that contains save games for the current game</a>
<a name="ln653">// type.</a>
<a name="ln654">static string _get_base_savedir_path(const string &amp;subpath = &quot;&quot;)</a>
<a name="ln655">{</a>
<a name="ln656">    return canonicalise_file_separator(catpath(Options.save_dir, subpath));</a>
<a name="ln657">}</a>
<a name="ln658"> </a>
<a name="ln659">// Given a simple (relative) path, returns the path relative to the</a>
<a name="ln660">// base save directory and a subdirectory named with the game version.</a>
<a name="ln661">// This is useful when writing cache files and similar output that</a>
<a name="ln662">// should not be shared between different game versions.</a>
<a name="ln663">string savedir_versioned_path(const string &amp;shortpath)</a>
<a name="ln664">{</a>
<a name="ln665">#ifdef DGL_VERSIONED_CACHE_DIR</a>
<a name="ln666">    const string versioned_dir =</a>
<a name="ln667">        _get_base_savedir_path(string(&quot;cache.&quot;) + Version::Long);</a>
<a name="ln668">#else</a>
<a name="ln669">    const string versioned_dir = _get_base_savedir_path();</a>
<a name="ln670">#endif</a>
<a name="ln671">    return catpath(versioned_dir, shortpath);</a>
<a name="ln672">}</a>
<a name="ln673"> </a>
<a name="ln674">#ifdef USE_TILE</a>
<a name="ln675">#define LINEMAX 1024</a>
<a name="ln676">static bool _readln(chunk_reader &amp;rd, char *buf)</a>
<a name="ln677">{</a>
<a name="ln678">    for (int space = LINEMAX - 1; space; space--)</a>
<a name="ln679">    {</a>
<a name="ln680">        if (!rd.read(buf, 1))</a>
<a name="ln681">            return false;</a>
<a name="ln682">        if (*buf == '\n')</a>
<a name="ln683">            break;</a>
<a name="ln684">        buf++;</a>
<a name="ln685">    }</a>
<a name="ln686">    *buf = 0;</a>
<a name="ln687">    return true;</a>
<a name="ln688">}</a>
<a name="ln689"> </a>
<a name="ln690">static void _fill_player_doll(player_save_info &amp;p, package *save)</a>
<a name="ln691">{</a>
<a name="ln692">    dolls_data equip_doll;</a>
<a name="ln693">    for (unsigned int j = 0; j &lt; TILEP_PART_MAX; ++j)</a>
<a name="ln694">        equip_doll.parts[j] = TILEP_SHOW_EQUIP;</a>
<a name="ln695"> </a>
<a name="ln696">    equip_doll.parts[TILEP_PART_BASE]</a>
<a name="ln697">        = tilep_species_to_base_tile(p.species, p.experience_level);</a>
<a name="ln698"> </a>
<a name="ln699">    bool success = false;</a>
<a name="ln700"> </a>
<a name="ln701">    chunk_reader fdoll(save, &quot;tdl&quot;);</a>
<a name="ln702">    {</a>
<a name="ln703">        char fbuf[LINEMAX];</a>
<a name="ln704">        if (_readln(fdoll,fbuf))</a>
<a name="ln705">        {</a>
<a name="ln706">            tilep_scan_parts(fbuf, equip_doll, p.species, p.experience_level);</a>
<a name="ln707">            tilep_race_default(p.species, p.experience_level, &amp;equip_doll);</a>
<a name="ln708">            success = true;</a>
<a name="ln709">        }</a>
<a name="ln710">    }</a>
<a name="ln711"> </a>
<a name="ln712">    if (!success) // Use default doll instead.</a>
<a name="ln713">    {</a>
<a name="ln714">        job_type job = get_job_by_name(p.class_name.c_str());</a>
<a name="ln715">        if (job == JOB_UNKNOWN)</a>
<a name="ln716">            job = JOB_FIGHTER;</a>
<a name="ln717"> </a>
<a name="ln718">        tilep_job_default(job, &amp;equip_doll);</a>
<a name="ln719">    }</a>
<a name="ln720">    p.doll = equip_doll;</a>
<a name="ln721">}</a>
<a name="ln722">#endif</a>
<a name="ln723"> </a>
<a name="ln724">/*</a>
<a name="ln725"> * Returns a list of the names of characters that are already saved for the</a>
<a name="ln726"> * current user.</a>
<a name="ln727"> */</a>
<a name="ln728"> </a>
<a name="ln729">static vector&lt;player_save_info&gt; _find_saved_characters()</a>
<a name="ln730">{</a>
<a name="ln731">    vector&lt;player_save_info&gt; chars;</a>
<a name="ln732"> </a>
<a name="ln733">    if (Options.no_save)</a>
<a name="ln734">        return chars;</a>
<a name="ln735"> </a>
<a name="ln736">#ifndef DISABLE_SAVEGAME_LISTS</a>
<a name="ln737">    string searchpath = _get_savefile_directory();</a>
<a name="ln738"> </a>
<a name="ln739">    if (searchpath.empty())</a>
<a name="ln740">        searchpath = &quot;.&quot;;</a>
<a name="ln741"> </a>
<a name="ln742">    for (const string &amp;filename : get_dir_files_sorted(searchpath))</a>
<a name="ln743">    {</a>
<a name="ln744">        if (is_save_file_name(filename))</a>
<a name="ln745">        {</a>
<a name="ln746">            try</a>
<a name="ln747">            {</a>
<a name="ln748">                package save(_get_savedir_path(filename).c_str(), false);</a>
<a name="ln749">                player_save_info p = _read_character_info(&amp;save);</a>
<a name="ln750">                if (!p.name.empty())</a>
<a name="ln751">                {</a>
<a name="ln752">                    p.filename = filename;</a>
<a name="ln753">#ifdef USE_TILE</a>
<a name="ln754">                    if (Options.tile_menu_icons &amp;&amp; save.has_chunk(&quot;tdl&quot;))</a>
<a name="ln755">                        _fill_player_doll(p, &amp;save);</a>
<a name="ln756">#endif</a>
<a name="ln757">                    chars.push_back(p);</a>
<a name="ln758">                }</a>
<a name="ln759">            }</a>
<a name="ln760">            catch (ext_fail_exception &amp;E)</a>
<a name="ln761">            {</a>
<a name="ln762">                dprf(&quot;%s: %s&quot;, filename.c_str(), E.what());</a>
<a name="ln763">            }</a>
<a name="ln764">            catch (game_ended_condition &amp;E) // another process is using the save</a>
<a name="ln765">            {</a>
<a name="ln766">                if (E.exit_reason != game_exit::abort)</a>
<a name="ln767">                    throw;</a>
<a name="ln768">            }</a>
<a name="ln769">        }</a>
<a name="ln770">    }</a>
<a name="ln771"> </a>
<a name="ln772">    sort(chars.begin(), chars.end());</a>
<a name="ln773">#endif // !DISABLE_SAVEGAME_LISTS</a>
<a name="ln774">    return chars;</a>
<a name="ln775">}</a>
<a name="ln776"> </a>
<a name="ln777">vector&lt;player_save_info&gt; find_all_saved_characters()</a>
<a name="ln778">{</a>
<a name="ln779">    set&lt;string&gt; dirs;</a>
<a name="ln780">    vector&lt;player_save_info&gt; saved_characters;</a>
<a name="ln781">    for (int i = 0; i &lt; NUM_GAME_TYPE; ++i)</a>
<a name="ln782">    {</a>
<a name="ln783">        unwind_var&lt;game_type&gt; gt(</a>
<a name="ln784">            crawl_state.type,</a>
<a name="ln785">            static_cast&lt;game_type&gt;(i));</a>
<a name="ln786"> </a>
<a name="ln787">        const string savedir = _get_savefile_directory();</a>
<a name="ln788">        if (dirs.count(savedir))</a>
<a name="ln789">            continue;</a>
<a name="ln790"> </a>
<a name="ln791">        dirs.insert(savedir);</a>
<a name="ln792"> </a>
<a name="ln793">        vector&lt;player_save_info&gt; chars_in_dir = _find_saved_characters();</a>
<a name="ln794">        saved_characters.insert(saved_characters.end(),</a>
<a name="ln795">                                chars_in_dir.begin(),</a>
<a name="ln796">                                chars_in_dir.end());</a>
<a name="ln797">    }</a>
<a name="ln798">    return saved_characters;</a>
<a name="ln799">}</a>
<a name="ln800"> </a>
<a name="ln801">bool save_exists(const string&amp; filename)</a>
<a name="ln802">{</a>
<a name="ln803">    return file_exists(_get_savefile_directory() + filename);</a>
<a name="ln804">}</a>
<a name="ln805"> </a>
<a name="ln806">string get_savedir_filename(const string &amp;name)</a>
<a name="ln807">{</a>
<a name="ln808">    return _get_savefile_directory() + get_save_filename(name);</a>
<a name="ln809">}</a>
<a name="ln810"> </a>
<a name="ln811">#define MAX_FILENAME_LENGTH 250</a>
<a name="ln812">string get_save_filename(const string &amp;name)</a>
<a name="ln813">{</a>
<a name="ln814">    return chop_string(strip_filename_unsafe_chars(name), MAX_FILENAME_LENGTH,</a>
<a name="ln815">                       false) + SAVE_SUFFIX;</a>
<a name="ln816">}</a>
<a name="ln817"> </a>
<a name="ln818">string get_prefs_filename()</a>
<a name="ln819">{</a>
<a name="ln820">#ifdef DGL_STARTUP_PREFS_BY_NAME</a>
<a name="ln821">    return _get_savefile_directory() + &quot;start-&quot;</a>
<a name="ln822">           + strip_filename_unsafe_chars(Options.game.name) + &quot;-ns.prf&quot;;</a>
<a name="ln823">#else</a>
<a name="ln824">    return _get_savefile_directory() + &quot;start-ns.prf&quot;;</a>
<a name="ln825">#endif</a>
<a name="ln826">}</a>
<a name="ln827"> </a>
<a name="ln828">void write_ghost_version(writer &amp;outf)</a>
<a name="ln829">{</a>
<a name="ln830">    // this may be distinct from the current save version</a>
<a name="ln831">    write_save_version(outf, save_version::current_bones());</a>
<a name="ln832"> </a>
<a name="ln833">    // extended_version just pads the version out to four 32-bit words.</a>
<a name="ln834">    // This makes the bones file compatible with Hearse with no extra</a>
<a name="ln835">    // munging needed.</a>
<a name="ln836"> </a>
<a name="ln837">    // Use a single signature 16-bit word to indicate that this is</a>
<a name="ln838">    // Stone Soup and to disambiguate this (unmunged) bones file</a>
<a name="ln839">    // from the munged bones files offered by the old Crawl-aware</a>
<a name="ln840">    // hearse.pl. Crawl-aware hearse.pl will prefix the bones file</a>
<a name="ln841">    // with the first 16-bits of the Crawl version, and the following</a>
<a name="ln842">    // 7 16-bit words set to 0.</a>
<a name="ln843">    marshallShort(outf, GHOST_SIGNATURE);</a>
<a name="ln844"> </a>
<a name="ln845">    // Write the three remaining 32-bit words of padding.</a>
<a name="ln846">    for (int i = 0; i &lt; 3; ++i)</a>
<a name="ln847">        marshallInt(outf, 0);</a>
<a name="ln848">}</a>
<a name="ln849"> </a>
<a name="ln850">static void _write_tagged_chunk(const string &amp;chunkname, tag_type tag)</a>
<a name="ln851">{</a>
<a name="ln852">    writer outf(you.save, chunkname);</a>
<a name="ln853"> </a>
<a name="ln854">    write_save_version(outf, save_version::current());</a>
<a name="ln855">    tag_write(tag, outf);</a>
<a name="ln856">}</a>
<a name="ln857"> </a>
<a name="ln858">static int _get_dest_stair_type(dungeon_feature_type stair_taken,</a>
<a name="ln859">                                bool &amp;find_first)</a>
<a name="ln860">{</a>
<a name="ln861">    // Order is important here.</a>
<a name="ln862">    if (stair_taken == DNGN_EXIT_ABYSS)</a>
<a name="ln863">    {</a>
<a name="ln864">        find_first = false;</a>
<a name="ln865">        return DNGN_EXIT_DUNGEON;</a>
<a name="ln866">    }</a>
<a name="ln867"> </a>
<a name="ln868">    if (stair_taken == DNGN_EXIT_HELL)</a>
<a name="ln869">        return DNGN_ENTER_HELL;</a>
<a name="ln870"> </a>
<a name="ln871">    if (stair_taken == DNGN_ENTER_HELL)</a>
<a name="ln872">        return DNGN_EXIT_HELL;</a>
<a name="ln873"> </a>
<a name="ln874">    if (player_in_hell() &amp;&amp; feat_is_stone_stair_down(stair_taken))</a>
<a name="ln875">    {</a>
<a name="ln876">        find_first = false;</a>
<a name="ln877">        return DNGN_ENTER_HELL;</a>
<a name="ln878">    }</a>
<a name="ln879"> </a>
<a name="ln880">    if (feat_is_stone_stair(stair_taken))</a>
<a name="ln881">    {</a>
<a name="ln882">        switch (stair_taken)</a>
<a name="ln883">        {</a>
<a name="ln884">        case DNGN_STONE_STAIRS_UP_I: return DNGN_STONE_STAIRS_DOWN_I;</a>
<a name="ln885">        case DNGN_STONE_STAIRS_UP_II: return DNGN_STONE_STAIRS_DOWN_II;</a>
<a name="ln886">        case DNGN_STONE_STAIRS_UP_III: return DNGN_STONE_STAIRS_DOWN_III;</a>
<a name="ln887"> </a>
<a name="ln888">        case DNGN_STONE_STAIRS_DOWN_I: return DNGN_STONE_STAIRS_UP_I;</a>
<a name="ln889">        case DNGN_STONE_STAIRS_DOWN_II: return DNGN_STONE_STAIRS_UP_II;</a>
<a name="ln890">        case DNGN_STONE_STAIRS_DOWN_III: return DNGN_STONE_STAIRS_UP_III;</a>
<a name="ln891"> </a>
<a name="ln892">        default: die(&quot;unknown stone stair %d&quot;, stair_taken);</a>
<a name="ln893">        }</a>
<a name="ln894">    }</a>
<a name="ln895"> </a>
<a name="ln896">    if (feat_is_escape_hatch(stair_taken) || stair_taken == DNGN_TRAP_SHAFT)</a>
<a name="ln897">        return stair_taken;</a>
<a name="ln898"> </a>
<a name="ln899">    if (stair_taken == DNGN_ENTER_DIS</a>
<a name="ln900">        || stair_taken == DNGN_ENTER_GEHENNA</a>
<a name="ln901">        || stair_taken == DNGN_ENTER_COCYTUS</a>
<a name="ln902">        || stair_taken == DNGN_ENTER_TARTARUS)</a>
<a name="ln903">    {</a>
<a name="ln904">        return player_in_hell() ? DNGN_ENTER_HELL : stair_taken;</a>
<a name="ln905">    }</a>
<a name="ln906"> </a>
<a name="ln907">    if (feat_is_branch_exit(stair_taken))</a>
<a name="ln908">    {</a>
<a name="ln909">        for (branch_iterator it; it; ++it)</a>
<a name="ln910">            if (it-&gt;exit_stairs == stair_taken)</a>
<a name="ln911">                return it-&gt;entry_stairs;</a>
<a name="ln912">        die(&quot;entrance corresponding to exit %d not found&quot;, stair_taken);</a>
<a name="ln913">    }</a>
<a name="ln914"> </a>
<a name="ln915">    if (feat_is_branch_entrance(stair_taken))</a>
<a name="ln916">    {</a>
<a name="ln917">        for (branch_iterator it; it; ++it)</a>
<a name="ln918">            if (it-&gt;entry_stairs == stair_taken)</a>
<a name="ln919">                return it-&gt;exit_stairs;</a>
<a name="ln920">        die(&quot;return corresponding to entry %d not found&quot;, stair_taken);</a>
<a name="ln921">    }</a>
<a name="ln922">#if TAG_MAJOR_VERSION == 34</a>
<a name="ln923">    if (stair_taken == DNGN_ENTER_LABYRINTH)</a>
<a name="ln924">    {</a>
<a name="ln925">        // dgn_find_nearby_stair uses special logic for labyrinths.</a>
<a name="ln926">        return DNGN_ENTER_LABYRINTH;</a>
<a name="ln927">    }</a>
<a name="ln928">#endif</a>
<a name="ln929"> </a>
<a name="ln930">    if (feat_is_portal_entrance(stair_taken))</a>
<a name="ln931">        return DNGN_STONE_ARCH;</a>
<a name="ln932"> </a>
<a name="ln933">    // Note: stair_taken can equal things like DNGN_FLOOR</a>
<a name="ln934">    // Just find a nice empty square.</a>
<a name="ln935">    find_first = false;</a>
<a name="ln936">    return DNGN_FLOOR;</a>
<a name="ln937">}</a>
<a name="ln938"> </a>
<a name="ln939">static void _place_player_on_stair(int stair_taken, const coord_def&amp; dest_pos,</a>
<a name="ln940">                                   const string &amp;hatch_name)</a>
<a name="ln941"> </a>
<a name="ln942">{</a>
<a name="ln943">    bool find_first = true;</a>
<a name="ln944">    dungeon_feature_type stair_type = static_cast&lt;dungeon_feature_type&gt;(</a>
<a name="ln945">            _get_dest_stair_type(static_cast&lt;dungeon_feature_type&gt;(stair_taken),</a>
<a name="ln946">                                 find_first));</a>
<a name="ln947"> </a>
<a name="ln948">    you.moveto(dgn_find_nearby_stair(stair_type, dest_pos, find_first,</a>
<a name="ln949">                                     hatch_name));</a>
<a name="ln950">}</a>
<a name="ln951"> </a>
<a name="ln952">static void _clear_env_map()</a>
<a name="ln953">{</a>
<a name="ln954">    env.map_knowledge.init(map_cell());</a>
<a name="ln955">    env.map_forgotten.reset();</a>
<a name="ln956">}</a>
<a name="ln957"> </a>
<a name="ln958">static bool _grab_follower_at(const coord_def &amp;pos, bool can_follow)</a>
<a name="ln959">{</a>
<a name="ln960">    if (pos == you.pos())</a>
<a name="ln961">        return false;</a>
<a name="ln962"> </a>
<a name="ln963">    monster* fol = monster_at(pos);</a>
<a name="ln964">    if (!fol || !fol-&gt;alive() || fol-&gt;incapacitated())</a>
<a name="ln965">        return false;</a>
<a name="ln966"> </a>
<a name="ln967">    // only H's ancestors can follow into portals &amp; similar.</a>
<a name="ln968">    if (!can_follow &amp;&amp; !mons_is_hepliaklqana_ancestor(fol-&gt;type))</a>
<a name="ln969">        return false;</a>
<a name="ln970"> </a>
<a name="ln971">    // The monster has to already be tagged in order to follow.</a>
<a name="ln972">    if (!testbits(fol-&gt;flags, MF_TAKING_STAIRS))</a>
<a name="ln973">        return false;</a>
<a name="ln974"> </a>
<a name="ln975">    // If a monster that can't use stairs was marked as a follower,</a>
<a name="ln976">    // it's because it's an ally and there might be another ally</a>
<a name="ln977">    // behind it that might want to push through.</a>
<a name="ln978">    // This means we don't actually send it on transit, but we do</a>
<a name="ln979">    // return true, so adjacent real followers are handled correctly. (jpeg)</a>
<a name="ln980">    if (!mons_can_use_stairs(*fol))</a>
<a name="ln981">        return true;</a>
<a name="ln982"> </a>
<a name="ln983">    level_id dest = level_id::current();</a>
<a name="ln984"> </a>
<a name="ln985">    dprf(&quot;%s is following to %s.&quot;, fol-&gt;name(DESC_THE, true).c_str(),</a>
<a name="ln986">         dest.describe().c_str());</a>
<a name="ln987">    bool could_see = you.can_see(*fol);</a>
<a name="ln988">    fol-&gt;set_transit(dest);</a>
<a name="ln989">    fol-&gt;destroy_inventory();</a>
<a name="ln990">    monster_cleanup(fol);</a>
<a name="ln991">    if (could_see)</a>
<a name="ln992">        view_update_at(pos);</a>
<a name="ln993">    return true;</a>
<a name="ln994">}</a>
<a name="ln995"> </a>
<a name="ln996">static void _grab_followers()</a>
<a name="ln997">{</a>
<a name="ln998">    const bool can_follow = branch_allows_followers(you.where_are_you);</a>
<a name="ln999"> </a>
<a name="ln1000">    int non_stair_using_allies = 0;</a>
<a name="ln1001">    int non_stair_using_summons = 0;</a>
<a name="ln1002"> </a>
<a name="ln1003">    monster* dowan = nullptr;</a>
<a name="ln1004">    monster* duvessa = nullptr;</a>
<a name="ln1005"> </a>
<a name="ln1006">    // Handle some hacky cases</a>
<a name="ln1007">    for (adjacent_iterator ai(you.pos()); ai; ++ai)</a>
<a name="ln1008">    {</a>
<a name="ln1009">        monster* fol = monster_at(*ai);</a>
<a name="ln1010">        if (fol == nullptr)</a>
<a name="ln1011">            continue;</a>
<a name="ln1012"> </a>
<a name="ln1013">        if (mons_is_mons_class(fol, MONS_DUVESSA) &amp;&amp; fol-&gt;alive())</a>
<a name="ln1014">            duvessa = fol;</a>
<a name="ln1015"> </a>
<a name="ln1016">        if (mons_is_mons_class(fol, MONS_DOWAN) &amp;&amp; fol-&gt;alive())</a>
<a name="ln1017">            dowan = fol;</a>
<a name="ln1018"> </a>
<a name="ln1019">        if (fol-&gt;wont_attack() &amp;&amp; !mons_can_use_stairs(*fol))</a>
<a name="ln1020">        {</a>
<a name="ln1021">            non_stair_using_allies++;</a>
<a name="ln1022">            // If the class can normally use stairs it</a>
<a name="ln1023">            // must have been a summon</a>
<a name="ln1024">            if (mons_class_can_use_stairs(fol-&gt;type))</a>
<a name="ln1025">                non_stair_using_summons++;</a>
<a name="ln1026">        }</a>
<a name="ln1027">    }</a>
<a name="ln1028"> </a>
<a name="ln1029">    // Deal with Dowan and Duvessa here.</a>
<a name="ln1030">    if (dowan &amp;&amp; duvessa)</a>
<a name="ln1031">    {</a>
<a name="ln1032">        if (!testbits(dowan-&gt;flags, MF_TAKING_STAIRS)</a>
<a name="ln1033">            || !testbits(duvessa-&gt;flags, MF_TAKING_STAIRS))</a>
<a name="ln1034">        {</a>
<a name="ln1035">            dowan-&gt;flags &amp;= ~MF_TAKING_STAIRS;</a>
<a name="ln1036">            duvessa-&gt;flags &amp;= ~MF_TAKING_STAIRS;</a>
<a name="ln1037">        }</a>
<a name="ln1038">    }</a>
<a name="ln1039">    else if (dowan &amp;&amp; !duvessa)</a>
<a name="ln1040">    {</a>
<a name="ln1041">        if (!dowan-&gt;props.exists(&quot;can_climb&quot;))</a>
<a name="ln1042">            dowan-&gt;flags &amp;= ~MF_TAKING_STAIRS;</a>
<a name="ln1043">    }</a>
<a name="ln1044">    else if (!dowan &amp;&amp; duvessa)</a>
<a name="ln1045">    {</a>
<a name="ln1046">        if (!duvessa-&gt;props.exists(&quot;can_climb&quot;))</a>
<a name="ln1047">            duvessa-&gt;flags &amp;= ~MF_TAKING_STAIRS;</a>
<a name="ln1048">    }</a>
<a name="ln1049"> </a>
<a name="ln1050">    if (can_follow &amp;&amp; non_stair_using_allies &gt; 0)</a>
<a name="ln1051">    {</a>
<a name="ln1052">        // Summons won't follow and will time out.</a>
<a name="ln1053">        if (non_stair_using_summons &gt; 0)</a>
<a name="ln1054">        {</a>
<a name="ln1055">            mprf(&quot;Your summoned %s left behind.&quot;,</a>
<a name="ln1056">                 non_stair_using_allies &gt; 1 ? &quot;allies are&quot; : &quot;ally is&quot;);</a>
<a name="ln1057">        }</a>
<a name="ln1058">        else</a>
<a name="ln1059">        {</a>
<a name="ln1060">            // Permanent undead are left behind but stay.</a>
<a name="ln1061">            mprf(&quot;Your mindless thrall%s behind.&quot;,</a>
<a name="ln1062">                 non_stair_using_allies &gt; 1 ? &quot;s stay&quot; : &quot; stays&quot;);</a>
<a name="ln1063">        }</a>
<a name="ln1064">    }</a>
<a name="ln1065"> </a>
<a name="ln1066">    memset(travel_point_distance, 0, sizeof(travel_distance_grid_t));</a>
<a name="ln1067">    vector&lt;coord_def&gt; places[2] = { { you.pos() }, {} };</a>
<a name="ln1068">    int place_set = 0;</a>
<a name="ln1069">    while (!places[place_set].empty())</a>
<a name="ln1070">    {</a>
<a name="ln1071">        for (const coord_def p : places[place_set])</a>
<a name="ln1072">        {</a>
<a name="ln1073">            for (adjacent_iterator ai(p); ai; ++ai)</a>
<a name="ln1074">            {</a>
<a name="ln1075">                if (travel_point_distance[ai-&gt;x][ai-&gt;y])</a>
<a name="ln1076">                    continue;</a>
<a name="ln1077"> </a>
<a name="ln1078">                travel_point_distance[ai-&gt;x][ai-&gt;y] = 1;</a>
<a name="ln1079">                if (_grab_follower_at(*ai, can_follow))</a>
<a name="ln1080">                    places[!place_set].push_back(*ai);</a>
<a name="ln1081">            }</a>
<a name="ln1082">        }</a>
<a name="ln1083">        places[place_set].clear();</a>
<a name="ln1084">        place_set = !place_set;</a>
<a name="ln1085">    }</a>
<a name="ln1086"> </a>
<a name="ln1087">    // Clear flags of monsters that didn't follow.</a>
<a name="ln1088">    for (auto &amp;mons : menv_real)</a>
<a name="ln1089">    {</a>
<a name="ln1090">        if (!mons.alive())</a>
<a name="ln1091">            continue;</a>
<a name="ln1092">        if (mons.type == MONS_BATTLESPHERE)</a>
<a name="ln1093">            end_battlesphere(&amp;mons, false);</a>
<a name="ln1094">        if (mons.type == MONS_SPECTRAL_WEAPON)</a>
<a name="ln1095">            end_spectral_weapon(&amp;mons, false);</a>
<a name="ln1096">        mons.flags &amp;= ~MF_TAKING_STAIRS;</a>
<a name="ln1097">    }</a>
<a name="ln1098">}</a>
<a name="ln1099"> </a>
<a name="ln1100">static void _do_lost_monsters()</a>
<a name="ln1101">{</a>
<a name="ln1102">    // Uniques can be considered wandering Pan just like you, so they're not</a>
<a name="ln1103">    // gone forever. The likes of Cerebov won't be generated elsewhere, but</a>
<a name="ln1104">    // there's no need to special-case that.</a>
<a name="ln1105">    if (player_in_branch(BRANCH_PANDEMONIUM))</a>
<a name="ln1106">        for (monster_iterator mi; mi; ++mi)</a>
<a name="ln1107">            if (mons_is_unique(mi-&gt;type) &amp;&amp; !(mi-&gt;flags &amp; MF_TAKING_STAIRS))</a>
<a name="ln1108">                you.unique_creatures.set(mi-&gt;type, false);</a>
<a name="ln1109">}</a>
<a name="ln1110"> </a>
<a name="ln1111">// Should be called after _grab_followers(), so that items carried by</a>
<a name="ln1112">// followers won't be considered lost.</a>
<a name="ln1113">static void _do_lost_items()</a>
<a name="ln1114">{</a>
<a name="ln1115">    for (const auto &amp;item : mitm)</a>
<a name="ln1116">        if (item.defined() &amp;&amp; item.pos != ITEM_IN_INVENTORY)</a>
<a name="ln1117">            item_was_lost(item);</a>
<a name="ln1118">}</a>
<a name="ln1119"> </a>
<a name="ln1120">/**</a>
<a name="ln1121"> * Perform cleanup when leaving a level.</a>
<a name="ln1122"> *</a>
<a name="ln1123"> * If returning to the previous level on the level stack (e.g. when leaving the</a>
<a name="ln1124"> * abyss), pop it off the stack. Delete non-permanent levels. Also check to be</a>
<a name="ln1125"> * sure no loops have formed in the level stack, and, for Fedhasites, rots any</a>
<a name="ln1126"> * corpses left behind.</a>
<a name="ln1127"> *</a>
<a name="ln1128"> * @param stair_taken   The means used to leave the last level.</a>
<a name="ln1129"> * @param old_level     The ID of the previous level.</a>
<a name="ln1130"> * @param return_pos    Set to the level entrance, if popping a stack level.</a>
<a name="ln1131"> * @return Whether the level was popped onto the stack.</a>
<a name="ln1132"> */</a>
<a name="ln1133">static bool _leave_level(dungeon_feature_type stair_taken,</a>
<a name="ln1134">                         const level_id&amp; old_level, coord_def *return_pos)</a>
<a name="ln1135">{</a>
<a name="ln1136">    bool popped = false;</a>
<a name="ln1137"> </a>
<a name="ln1138">    if (!you.level_stack.empty()</a>
<a name="ln1139">        &amp;&amp; you.level_stack.back().id == level_id::current())</a>
<a name="ln1140">    {</a>
<a name="ln1141">        *return_pos = you.level_stack.back().pos;</a>
<a name="ln1142">        you.level_stack.pop_back();</a>
<a name="ln1143">        env.level_state |= LSTATE_DELETED;</a>
<a name="ln1144">        popped = true;</a>
<a name="ln1145">    }</a>
<a name="ln1146">    else if (stair_taken == DNGN_TRANSIT_PANDEMONIUM</a>
<a name="ln1147">             || stair_taken == DNGN_EXIT_THROUGH_ABYSS</a>
<a name="ln1148">             || stair_taken == DNGN_STONE_STAIRS_DOWN_I</a>
<a name="ln1149">             &amp;&amp; old_level.branch == BRANCH_ZIGGURAT</a>
<a name="ln1150">             || old_level.branch == BRANCH_ABYSS)</a>
<a name="ln1151">    {</a>
<a name="ln1152">        env.level_state |= LSTATE_DELETED;</a>
<a name="ln1153">    }</a>
<a name="ln1154"> </a>
<a name="ln1155">    if (is_level_on_stack(level_id::current())</a>
<a name="ln1156">        &amp;&amp; !player_in_branch(BRANCH_ABYSS))</a>
<a name="ln1157">    {</a>
<a name="ln1158">        vector&lt;string&gt; stack;</a>
<a name="ln1159">        for (level_pos lvl : you.level_stack)</a>
<a name="ln1160">            stack.push_back(lvl.id.describe());</a>
<a name="ln1161">        if (you.wizard)</a>
<a name="ln1162">        {</a>
<a name="ln1163">            // warn about breakage so testers know it's an abnormal situation.</a>
<a name="ln1164">            mprf(MSGCH_ERROR, &quot;Error: you smelly wizard, how dare you enter &quot;</a>
<a name="ln1165">                 &quot;the same level (%s) twice! It will be trampled upon return.\n&quot;</a>
<a name="ln1166">                 &quot;The stack has: %s.&quot;,</a>
<a name="ln1167">                 level_id::current().describe().c_str(),</a>
<a name="ln1168">                 comma_separated_line(stack.begin(), stack.end(),</a>
<a name="ln1169">                                      &quot;, &quot;, &quot;, &quot;).c_str());</a>
<a name="ln1170">        }</a>
<a name="ln1171">        else</a>
<a name="ln1172">        {</a>
<a name="ln1173">            die(&quot;Attempt to enter a portal (%s) twice; stack: %s&quot;,</a>
<a name="ln1174">                level_id::current().describe().c_str(),</a>
<a name="ln1175">                comma_separated_line(stack.begin(), stack.end(),</a>
<a name="ln1176">                                     &quot;, &quot;, &quot;, &quot;).c_str());</a>
<a name="ln1177">        }</a>
<a name="ln1178">    }</a>
<a name="ln1179"> </a>
<a name="ln1180">    return popped;</a>
<a name="ln1181">}</a>
<a name="ln1182"> </a>
<a name="ln1183">/**</a>
<a name="ln1184"> * Move the player to the appropriate entrance location in a level.</a>
<a name="ln1185"> *</a>
<a name="ln1186"> * @param stair_taken   The means used to leave the last level.</a>
<a name="ln1187"> * @param return_pos    The location of the entrance portal, if applicable.</a>
<a name="ln1188"> * @param dest_pos      The player's location on the last level.</a>
<a name="ln1189"> */</a>
<a name="ln1190">static void _place_player(dungeon_feature_type stair_taken,</a>
<a name="ln1191">                          const coord_def &amp;return_pos,</a>
<a name="ln1192">                          const coord_def &amp;dest_pos, const string &amp;hatch_name)</a>
<a name="ln1193">{</a>
<a name="ln1194">    if (player_in_branch(BRANCH_ABYSS))</a>
<a name="ln1195">        you.moveto(ABYSS_CENTRE);</a>
<a name="ln1196">    else if (!return_pos.origin())</a>
<a name="ln1197">        you.moveto(return_pos);</a>
<a name="ln1198">    else</a>
<a name="ln1199">        _place_player_on_stair(stair_taken, dest_pos, hatch_name);</a>
<a name="ln1200"> </a>
<a name="ln1201">    // Don't return the player into walls, deep water, or a trap.</a>
<a name="ln1202">    for (distance_iterator di(you.pos(), true, false); di; ++di)</a>
<a name="ln1203">        if (you.is_habitable_feat(grd(*di))</a>
<a name="ln1204">            &amp;&amp; !is_feat_dangerous(grd(*di), true)</a>
<a name="ln1205">            &amp;&amp; !feat_is_trap(grd(*di)))</a>
<a name="ln1206">        {</a>
<a name="ln1207">            if (you.pos() != *di)</a>
<a name="ln1208">                you.moveto(*di);</a>
<a name="ln1209">            break;</a>
<a name="ln1210">        }</a>
<a name="ln1211"> </a>
<a name="ln1212">    // This should fix the &quot;monster occurring under the player&quot; bug.</a>
<a name="ln1213">    monster *mon = monster_at(you.pos());</a>
<a name="ln1214">    if (mon &amp;&amp; !fedhas_passthrough(mon))</a>
<a name="ln1215">    {</a>
<a name="ln1216">        for (distance_iterator di(you.pos()); di; ++di)</a>
<a name="ln1217">        {</a>
<a name="ln1218">            if (!monster_at(*di) &amp;&amp; mon-&gt;is_habitable(*di))</a>
<a name="ln1219">            {</a>
<a name="ln1220">                mon-&gt;move_to_pos(*di);</a>
<a name="ln1221">                return;</a>
<a name="ln1222">            }</a>
<a name="ln1223">        }</a>
<a name="ln1224"> </a>
<a name="ln1225">        dprf(&quot;%s under player and can't be moved anywhere; killing&quot;,</a>
<a name="ln1226">             mon-&gt;name(DESC_PLAIN).c_str());</a>
<a name="ln1227">        monster_die(*mon, KILL_DISMISSED, NON_MONSTER);</a>
<a name="ln1228">        // XXX: do we need special handling for uniques...?</a>
<a name="ln1229">    }</a>
<a name="ln1230">}</a>
<a name="ln1231"> </a>
<a name="ln1232">// Update the trackers after the player changed level.</a>
<a name="ln1233">void trackers_init_new_level()</a>
<a name="ln1234">{</a>
<a name="ln1235">    travel_init_new_level();</a>
<a name="ln1236">}</a>
<a name="ln1237"> </a>
<a name="ln1238">static string _get_hatch_name()</a>
<a name="ln1239">{</a>
<a name="ln1240">    vector &lt;map_marker *&gt; markers;</a>
<a name="ln1241">    markers = find_markers_by_prop(HATCH_NAME_PROP);</a>
<a name="ln1242">    for (auto m : markers)</a>
<a name="ln1243">    {</a>
<a name="ln1244">        if (m-&gt;pos == you.pos())</a>
<a name="ln1245">        {</a>
<a name="ln1246">            string name = m-&gt;property(HATCH_NAME_PROP);</a>
<a name="ln1247">            ASSERT(!name.empty());</a>
<a name="ln1248">            return name;</a>
<a name="ln1249">        }</a>
<a name="ln1250">    }</a>
<a name="ln1251">    return &quot;&quot;;</a>
<a name="ln1252">}</a>
<a name="ln1253"> </a>
<a name="ln1254">static const string VISITED_LEVELS_KEY = &quot;visited_levels&quot;;</a>
<a name="ln1255"> </a>
<a name="ln1256">#if TAG_MAJOR_VERSION == 34</a>
<a name="ln1257">// n.b. these functions are in files.cc largely because this is where the fixup</a>
<a name="ln1258">// needs to happen.</a>
<a name="ln1259">// before pregeneration, whether the level had been visited was synonymous with</a>
<a name="ln1260">// whether it had been visited, but after, we need to track this information</a>
<a name="ln1261">// more directly. It is also inferrable from turns_on_level, but you can't get</a>
<a name="ln1262">// at that very easily without fully loading the level.</a>
<a name="ln1263">// no need for a minor version here, though there will be a brief window of</a>
<a name="ln1264">// offline pregen games that this doesn't handle right -- they will get things</a>
<a name="ln1265">// like broken runelock. (In principle this fixup could be done by loading</a>
<a name="ln1266">// each level and checking turns, but it's not worth the trouble for these few</a>
<a name="ln1267">// games.)</a>
<a name="ln1268">static void _fixup_visited_from_package()</a>
<a name="ln1269">{</a>
<a name="ln1270">    // for games started later than this fixup, this prop is initialized in</a>
<a name="ln1271">    // player::player</a>
<a name="ln1272">    CrawlHashTable &amp;visited = you.props[VISITED_LEVELS_KEY].get_table();</a>
<a name="ln1273">    if (visited.size()) // only 0 for upgrades, or before entering D:1</a>
<a name="ln1274">        return;</a>
<a name="ln1275">    vector&lt;level_id&gt; levels = all_dungeon_ids();</a>
<a name="ln1276">    for (const level_id &amp;lid : levels)</a>
<a name="ln1277">        if (is_existing_level(lid))</a>
<a name="ln1278">            visited[lid.describe()] = true;</a>
<a name="ln1279">}</a>
<a name="ln1280">#endif</a>
<a name="ln1281"> </a>
<a name="ln1282">void player::set_level_visited(const level_id &amp;level)</a>
<a name="ln1283">{</a>
<a name="ln1284">    auto &amp;visited = props[VISITED_LEVELS_KEY].get_table();</a>
<a name="ln1285">    visited[level.describe()] = true;</a>
<a name="ln1286">}</a>
<a name="ln1287"> </a>
<a name="ln1288">/**</a>
<a name="ln1289"> * Has the player visited the level currently stored in the save under the id</a>
<a name="ln1290"> * `level`, if there is one? Returns false if there isn't one. This stores</a>
<a name="ln1291"> * *token level* visited state, not type-level -- it does not answer questions</a>
<a name="ln1292"> * like, e.g. has the player ever visited a trove? For that, see place_info.</a>
<a name="ln1293"> * This distinction matters mainly for portal branches, especially ones that can</a>
<a name="ln1294"> * be revisited, e.g. Pan levels and zigs.</a>
<a name="ln1295"> */</a>
<a name="ln1296">bool player::level_visited(const level_id &amp;level)</a>
<a name="ln1297">{</a>
<a name="ln1298">    // `is_existing_level` is not reliable after the game end, because the</a>
<a name="ln1299">    // save no longer exists, so we ignore it for printing morgues</a>
<a name="ln1300">    if (!is_existing_level(level) &amp;&amp; you.save)</a>
<a name="ln1301">        return false;</a>
<a name="ln1302">    const auto &amp;visited = props[VISITED_LEVELS_KEY].get_table();</a>
<a name="ln1303">    return visited.exists(level.describe());</a>
<a name="ln1304">}</a>
<a name="ln1305"> </a>
<a name="ln1306">static void _generic_level_reset()</a>
<a name="ln1307">{</a>
<a name="ln1308">    // TODO: can more be pulled into here?</a>
<a name="ln1309"> </a>
<a name="ln1310">    you.prev_targ = MHITNOT;</a>
<a name="ln1311">    you.prev_grd_targ.reset();</a>
<a name="ln1312"> </a>
<a name="ln1313">    // Lose all listeners.</a>
<a name="ln1314">    dungeon_events.clear();</a>
<a name="ln1315">    clear_travel_trail();</a>
<a name="ln1316">}</a>
<a name="ln1317"> </a>
<a name="ln1318"> </a>
<a name="ln1319">// used to resolve generation order for cases where a single level has multiple</a>
<a name="ln1320">// portals.</a>
<a name="ln1321">static const vector&lt;branch_type&gt; portal_generation_order =</a>
<a name="ln1322">{</a>
<a name="ln1323">    BRANCH_SEWER,</a>
<a name="ln1324">    BRANCH_OSSUARY,</a>
<a name="ln1325">    BRANCH_ICE_CAVE,</a>
<a name="ln1326">    BRANCH_VOLCANO,</a>
<a name="ln1327">    BRANCH_BAILEY,</a>
<a name="ln1328">    BRANCH_GAUNTLET,</a>
<a name="ln1329">#if TAG_MAJOR_VERSION == 34</a>
<a name="ln1330">    BRANCH_LABYRINTH,</a>
<a name="ln1331">#endif</a>
<a name="ln1332">    // do not pregenerate bazaar (TODO: this is non-ideal)</a>
<a name="ln1333">    // do not pregenerate trove</a>
<a name="ln1334">    BRANCH_WIZLAB,</a>
<a name="ln1335">    BRANCH_DESOLATION,</a>
<a name="ln1336">};</a>
<a name="ln1337"> </a>
<a name="ln1338">void update_portal_entrances()</a>
<a name="ln1339">{</a>
<a name="ln1340">    unordered_set&lt;branch_type, std::hash&lt;int&gt;&gt; seen_portals;</a>
<a name="ln1341">    auto const cur_level = level_id::current();</a>
<a name="ln1342">    // add any portals not currently registered</a>
<a name="ln1343">    for (rectangle_iterator ri(0); ri; ++ri)</a>
<a name="ln1344">    {</a>
<a name="ln1345">        dungeon_feature_type feat = env.grid(*ri);</a>
<a name="ln1346">        // excludes pan, hell, abyss.</a>
<a name="ln1347">        if (feat_is_portal_entrance(feat) &amp;&amp; !feature_mimic_at(*ri))</a>
<a name="ln1348">        {</a>
<a name="ln1349">            level_id whither = stair_destination(feat, &quot;&quot;, false);</a>
<a name="ln1350">            if (whither.branch == BRANCH_ZIGGURAT // not (quite) pregenerated</a>
<a name="ln1351">                || whither.branch == BRANCH_TROVE // not pregenerated</a>
<a name="ln1352">                || whither.branch == BRANCH_BAZAAR) // multiple bazaars possible</a>
<a name="ln1353">            {</a>
<a name="ln1354">                continue; // handle these differently</a>
<a name="ln1355">            }</a>
<a name="ln1356">            dprf(&quot;Setting up entry for %s.&quot;, whither.describe().c_str());</a>
<a name="ln1357">            ASSERT(count(portal_generation_order.begin(),</a>
<a name="ln1358">                         portal_generation_order.end(),</a>
<a name="ln1359">                         whither.branch) == 1);</a>
<a name="ln1360">            if (brentry[whither.branch] != level_id())</a>
<a name="ln1361">            {</a>
<a name="ln1362">                mprf(MSGCH_ERROR, &quot;Second portal entrance for %s!&quot;,</a>
<a name="ln1363">                    whither.describe().c_str());</a>
<a name="ln1364">            }</a>
<a name="ln1365">            brentry[whither.branch] = cur_level;</a>
<a name="ln1366">            seen_portals.insert(whither.branch);</a>
<a name="ln1367">        }</a>
<a name="ln1368">    }</a>
<a name="ln1369">    // clean up any portals that aren't actually here -- comes up for wizmode</a>
<a name="ln1370">    // and test mode cases.</a>
<a name="ln1371">    for (auto b : portal_generation_order)</a>
<a name="ln1372">        if (!seen_portals.count(b) &amp;&amp; brentry[b] == cur_level)</a>
<a name="ln1373">            brentry[b] = level_id();</a>
<a name="ln1374">}</a>
<a name="ln1375"> </a>
<a name="ln1376">void reset_portal_entrances()</a>
<a name="ln1377">{</a>
<a name="ln1378">    for (auto b : portal_generation_order)</a>
<a name="ln1379">        if (brentry[b].is_valid())</a>
<a name="ln1380">            brentry[b] = level_id();</a>
<a name="ln1381">}</a>
<a name="ln1382"> </a>
<a name="ln1383">static bool _generate_portal_levels()</a>
<a name="ln1384">{</a>
<a name="ln1385">    // find any portals that branch off of the current level.</a>
<a name="ln1386">    level_id here = level_id::current();</a>
<a name="ln1387">    vector&lt;level_id&gt; to_build;</a>
<a name="ln1388">    for (auto b : portal_generation_order)</a>
<a name="ln1389">        if (brentry[b] == here)</a>
<a name="ln1390">            for (int i = 1; i &lt;= branches[b].numlevels; i++)</a>
<a name="ln1391">                to_build.push_back(level_id(b, i));</a>
<a name="ln1392"> </a>
<a name="ln1393">    bool generated = false;</a>
<a name="ln1394">    for (auto lid : to_build)</a>
<a name="ln1395">        generated = generate_level(lid) || generated;</a>
<a name="ln1396">    return generated;</a>
<a name="ln1397">}</a>
<a name="ln1398"> </a>
<a name="ln1399">/**</a>
<a name="ln1400"> * Ensure that the level given by `l` is generated. This does not do much in</a>
<a name="ln1401"> * the way of cleanup, and the caller must ensure the player ends up somewhere</a>
<a name="ln1402"> * sensible afterwards (this will not place the player, and will wipe out their</a>
<a name="ln1403"> * current location state if a level is built). Does not do anything if the</a>
<a name="ln1404"> * save already contains the relevant level.</a>
<a name="ln1405"> *</a>
<a name="ln1406"> * @param l the level to try to build.</a>
<a name="ln1407"> * @return whether a level was built.</a>
<a name="ln1408"> */</a>
<a name="ln1409">bool generate_level(const level_id &amp;l)</a>
<a name="ln1410">{</a>
<a name="ln1411">    const string level_name = l.describe();</a>
<a name="ln1412">    if (you.save-&gt;has_chunk(level_name))</a>
<a name="ln1413">        return false;</a>
<a name="ln1414"> </a>
<a name="ln1415">    unwind_var&lt;int&gt; depth(you.depth, l.depth);</a>
<a name="ln1416">    unwind_var&lt;branch_type&gt; branch(you.where_are_you, l.branch);</a>
<a name="ln1417">    unwind_var&lt;coord_def&gt; saved_position(you.position);</a>
<a name="ln1418">    you.position.reset();</a>
<a name="ln1419"> </a>
<a name="ln1420">    // simulate a reasonable stair to enter the level with</a>
<a name="ln1421">    const dungeon_feature_type stair_taken =</a>
<a name="ln1422">          you.depth == 1</a>
<a name="ln1423">        ? (you.where_are_you == BRANCH_DUNGEON</a>
<a name="ln1424">           ? DNGN_UNSEEN</a>
<a name="ln1425">           : branches[you.where_are_you].entry_stairs)</a>
<a name="ln1426">        : DNGN_STONE_STAIRS_DOWN_I;</a>
<a name="ln1427"> </a>
<a name="ln1428">    unwind_var&lt;dungeon_feature_type&gt; stair(you.transit_stair, stair_taken);</a>
<a name="ln1429">    // TODO how necessary is this?</a>
<a name="ln1430">    unwind_bool ylev(you.entering_level, true);</a>
<a name="ln1431">    // n.b. crawl_state.generating_level is handled in builder</a>
<a name="ln1432"> </a>
<a name="ln1433">    _generic_level_reset();</a>
<a name="ln1434">    delete_all_clouds();</a>
<a name="ln1435">    los_changed(); // invalidate the los cache, which impacts monster placement</a>
<a name="ln1436"> </a>
<a name="ln1437">    // initialize env for builder</a>
<a name="ln1438">    env.turns_on_level = -1;</a>
<a name="ln1439">    tile_init_default_flavour();</a>
<a name="ln1440">    tile_clear_flavour();</a>
<a name="ln1441">    env.tile_names.clear();</a>
<a name="ln1442">    _clear_env_map();</a>
<a name="ln1443"> </a>
<a name="ln1444">    // finally -- everything is set up, call the builder.</a>
<a name="ln1445">    dprf(&quot;Generating new level for '%s'.&quot;, level_name.c_str());</a>
<a name="ln1446">    builder(true);</a>
<a name="ln1447"> </a>
<a name="ln1448">    auto &amp;vault_list =  you.vault_list[level_id::current()];</a>
<a name="ln1449">#ifdef DEBUG</a>
<a name="ln1450">    // places where a level can generate multiple times.</a>
<a name="ln1451">    // could add portals to this list for debugging purposes?</a>
<a name="ln1452">    if (   you.where_are_you == BRANCH_ABYSS</a>
<a name="ln1453">        || you.where_are_you == BRANCH_PANDEMONIUM</a>
<a name="ln1454">        || you.where_are_you == BRANCH_BAZAAR</a>
<a name="ln1455">        || you.where_are_you == BRANCH_ZIGGURAT)</a>
<a name="ln1456">    {</a>
<a name="ln1457">        vault_list.push_back(&quot;[gen]&quot;);</a>
<a name="ln1458">    }</a>
<a name="ln1459">#endif</a>
<a name="ln1460">    const auto &amp;level_vaults = level_vault_names();</a>
<a name="ln1461">    vault_list.insert(vault_list.end(),</a>
<a name="ln1462">                        level_vaults.begin(), level_vaults.end());</a>
<a name="ln1463"> </a>
<a name="ln1464">    // initialize env for a new level</a>
<a name="ln1465">    env.turns_on_level = 0;</a>
<a name="ln1466">    env.sanctuary_pos  = coord_def(-1, -1);</a>
<a name="ln1467">    env.sanctuary_time = 0;</a>
<a name="ln1468">    env.markers.init_all(); // init first, activation happens when entering</a>
<a name="ln1469">    show_update_emphasis(); // Clear map knowledge stair emphasis in env.</a>
<a name="ln1470">    update_portal_entrances();</a>
<a name="ln1471"> </a>
<a name="ln1472">    // save the level and associated env state</a>
<a name="ln1473">    _save_level(level_id::current());</a>
<a name="ln1474"> </a>
<a name="ln1475">    const string save_name = level_id::current().describe(); // should be same as level_name...</a>
<a name="ln1476"> </a>
<a name="ln1477">    // generate levels for all portals that branch off from here</a>
<a name="ln1478">    if (_generate_portal_levels())</a>
<a name="ln1479">    {</a>
<a name="ln1480">        // if portals were generated, we're currently elsewhere.</a>
<a name="ln1481">        ASSERT(you.save-&gt;has_chunk(save_name));</a>
<a name="ln1482">        dprf(&quot;Reloading new level '%s'.&quot;, save_name.c_str());</a>
<a name="ln1483">        _restore_tagged_chunk(you.save, save_name, TAG_LEVEL,</a>
<a name="ln1484">            &quot;Level file is invalid.&quot;);</a>
<a name="ln1485">    }</a>
<a name="ln1486">    return true;</a>
<a name="ln1487">}</a>
<a name="ln1488"> </a>
<a name="ln1489">// bel's original proposal generated D to lair depth, then lair, then D</a>
<a name="ln1490">// to orc depth, then orc, then the rest of D. I have simplified this to</a>
<a name="ln1491">// just generate whole branches at a time -- I am not sure how much real</a>
<a name="ln1492">// impact this has. One idea might be to shuffle this slightly based on</a>
<a name="ln1493">// the seed.</a>
<a name="ln1494">// TODO: probably need to do portal vaults too?</a>
<a name="ln1495">// Should this use something like logical_branch_order?</a>
<a name="ln1496">static const vector&lt;branch_type&gt; branch_generation_order =</a>
<a name="ln1497">{</a>
<a name="ln1498">    BRANCH_DUNGEON,</a>
<a name="ln1499">    BRANCH_TEMPLE,</a>
<a name="ln1500">    BRANCH_LAIR,</a>
<a name="ln1501">    BRANCH_ORC,</a>
<a name="ln1502">    BRANCH_SPIDER,</a>
<a name="ln1503">    BRANCH_SNAKE,</a>
<a name="ln1504">    BRANCH_SHOALS,</a>
<a name="ln1505">    BRANCH_SWAMP,</a>
<a name="ln1506">    BRANCH_VAULTS,</a>
<a name="ln1507">    BRANCH_CRYPT,</a>
<a name="ln1508">    BRANCH_DEPTHS,</a>
<a name="ln1509">    BRANCH_VESTIBULE,</a>
<a name="ln1510">    BRANCH_ELF,</a>
<a name="ln1511">    BRANCH_ZOT,</a>
<a name="ln1512">    BRANCH_SLIME,</a>
<a name="ln1513">    BRANCH_TOMB,</a>
<a name="ln1514">    BRANCH_TARTARUS,</a>
<a name="ln1515">    BRANCH_COCYTUS,</a>
<a name="ln1516">    BRANCH_DIS,</a>
<a name="ln1517">    BRANCH_GEHENNA,</a>
<a name="ln1518">    BRANCH_PANDEMONIUM,</a>
<a name="ln1519">    BRANCH_ZIGGURAT,</a>
<a name="ln1520">    NUM_BRANCHES,</a>
<a name="ln1521">};</a>
<a name="ln1522"> </a>
<a name="ln1523">static bool _branch_pregenerates(branch_type b)</a>
<a name="ln1524">{</a>
<a name="ln1525">    if (!you.deterministic_levelgen)</a>
<a name="ln1526">        return false;</a>
<a name="ln1527">    if (b == NUM_BRANCHES || !brentry[b].is_valid() &amp;&amp; is_random_subbranch(b))</a>
<a name="ln1528">        return false;</a>
<a name="ln1529">    return count(branch_generation_order.begin(),</a>
<a name="ln1530">        branch_generation_order.end(), b) &gt; 0;</a>
<a name="ln1531">}</a>
<a name="ln1532"> </a>
<a name="ln1533">/**</a>
<a name="ln1534">* Generate dungeon branches in a stable order until the level `stopping_point`</a>
<a name="ln1535">* is found; `stopping_point` will be generated if it doesn't already exist. If</a>
<a name="ln1536">* it does exist, the function is a noop.</a>
<a name="ln1537">*</a>
<a name="ln1538">* If `stopping_point` is not in the generation order, it will be generated on</a>
<a name="ln1539">* its own.</a>
<a name="ln1540">*</a>
<a name="ln1541">* To generate all generatable levels, pass a level_id with NUM_BRANCHES as the</a>
<a name="ln1542">* branch.</a>
<a name="ln1543">*/</a>
<a name="ln1544">bool pregen_dungeon(const level_id &amp;stopping_point)</a>
<a name="ln1545">{</a>
<a name="ln1546">    // TODO: the is_valid() check here doesn't look quite right to me, but so</a>
<a name="ln1547">    // far I can't get it to break anything...</a>
<a name="ln1548">    if (stopping_point.is_valid()</a>
<a name="ln1549">        || stopping_point.branch != NUM_BRANCHES &amp;&amp;</a>
<a name="ln1550">           is_random_subbranch(stopping_point.branch) &amp;&amp; you.wizard)</a>
<a name="ln1551">    {</a>
<a name="ln1552">        if (you.save-&gt;has_chunk(stopping_point.describe()))</a>
<a name="ln1553">            return false;</a>
<a name="ln1554"> </a>
<a name="ln1555">        if (!_branch_pregenerates(stopping_point.branch))</a>
<a name="ln1556">            return generate_level(stopping_point);</a>
<a name="ln1557">    }</a>
<a name="ln1558"> </a>
<a name="ln1559">    vector&lt;level_id&gt; to_generate;</a>
<a name="ln1560">    bool at_end = false;</a>
<a name="ln1561">    for (auto br : branch_generation_order)</a>
<a name="ln1562">    {</a>
<a name="ln1563">        if (br == BRANCH_ZIGGURAT &amp;&amp;</a>
<a name="ln1564">            stopping_point.branch == BRANCH_ZIGGURAT)</a>
<a name="ln1565">        {</a>
<a name="ln1566">            // zigs delete levels as they go, so don't catchup when we're</a>
<a name="ln1567">            // already in one. Zigs are only handled this way so that everything</a>
<a name="ln1568">            // else generates first.</a>
<a name="ln1569">            to_generate.push_back(stopping_point);</a>
<a name="ln1570">            continue;</a>
<a name="ln1571">        }</a>
<a name="ln1572">        // TODO: why is dungeon invalid? it's not set up properly in</a>
<a name="ln1573">        // `initialise_branch_depths` for some reason. The vestibule is invalid</a>
<a name="ln1574">        // because its depth isn't set until the player actually enters a</a>
<a name="ln1575">        // portal, similarly for other portal branches.</a>
<a name="ln1576">        if (br &lt; NUM_BRANCHES &amp;&amp;</a>
<a name="ln1577">            (brentry[br].is_valid()</a>
<a name="ln1578">             || br == BRANCH_DUNGEON || br == BRANCH_VESTIBULE</a>
<a name="ln1579">             || !is_connected_branch(br)))</a>
<a name="ln1580">        {</a>
<a name="ln1581">            for (int i = 1; i &lt;= branches[br].numlevels; i++)</a>
<a name="ln1582">            {</a>
<a name="ln1583">                level_id new_level = level_id(br, i);</a>
<a name="ln1584">                if (you.save-&gt;has_chunk(new_level.describe()))</a>
<a name="ln1585">                    continue;</a>
<a name="ln1586">                to_generate.push_back(new_level);</a>
<a name="ln1587"> </a>
<a name="ln1588">                if (br == stopping_point.branch</a>
<a name="ln1589">                    &amp;&amp; (i == stopping_point.depth</a>
<a name="ln1590">                        || i == branches[br].numlevels))</a>
<a name="ln1591">                {</a>
<a name="ln1592">                    at_end = true;</a>
<a name="ln1593">                    break;</a>
<a name="ln1594">                }</a>
<a name="ln1595">            }</a>
<a name="ln1596">        }</a>
<a name="ln1597">        if (at_end)</a>
<a name="ln1598">            break;</a>
<a name="ln1599">    }</a>
<a name="ln1600"> </a>
<a name="ln1601">    if (to_generate.size() == 0)</a>
<a name="ln1602">    {</a>
<a name="ln1603">        dprf(&quot;levelgen: No valid levels to generate.&quot;);</a>
<a name="ln1604">        return false;</a>
<a name="ln1605">    }</a>
<a name="ln1606">    else if (to_generate.size() == 1)</a>
<a name="ln1607">        return generate_level(to_generate[0]); // no popup for this case</a>
<a name="ln1608">    else</a>
<a name="ln1609">    {</a>
<a name="ln1610">        // be sure that AK start doesn't interfere with the builder</a>
<a name="ln1611">        unwind_var&lt;game_chapter&gt; chapter(you.chapter, CHAPTER_ORB_HUNTING);</a>
<a name="ln1612"> </a>
<a name="ln1613">        ui::progress_popup progress(&quot;Generating dungeon...\n\n&quot;, 35);</a>
<a name="ln1614">        progress.advance_progress();</a>
<a name="ln1615"> </a>
<a name="ln1616">        // in normal usage if we get to here, something will generate. But it</a>
<a name="ln1617">        // is possible to call this in a way that doesn't lead to generation.</a>
<a name="ln1618">        bool generated = false;</a>
<a name="ln1619"> </a>
<a name="ln1620">        for (const level_id &amp;new_level : to_generate)</a>
<a name="ln1621">        {</a>
<a name="ln1622">            string status = &quot;\nbuilding &quot;;</a>
<a name="ln1623"> </a>
<a name="ln1624">            switch (new_level.branch)</a>
<a name="ln1625">            {</a>
<a name="ln1626">            case BRANCH_SPIDER:</a>
<a name="ln1627">            case BRANCH_SNAKE:</a>
<a name="ln1628">                status += &quot;a lair branch&quot;;</a>
<a name="ln1629">                break;</a>
<a name="ln1630">            case BRANCH_SHOALS:</a>
<a name="ln1631">            case BRANCH_SWAMP:</a>
<a name="ln1632">                status += &quot;another lair branch&quot;;</a>
<a name="ln1633">                break;</a>
<a name="ln1634">            default:</a>
<a name="ln1635">                status += branches[new_level.branch].longname;</a>
<a name="ln1636">                break;</a>
<a name="ln1637">            }</a>
<a name="ln1638">            progress.set_status_text(status);</a>
<a name="ln1639">            dprf(&quot;Pregenerating %s:%d&quot;,</a>
<a name="ln1640">                branches[new_level.branch].abbrevname, new_level.depth);</a>
<a name="ln1641">            progress.advance_progress();</a>
<a name="ln1642">            generated = generate_level(new_level) || generated;</a>
<a name="ln1643">        }</a>
<a name="ln1644"> </a>
<a name="ln1645">        return generated;</a>
<a name="ln1646">    }</a>
<a name="ln1647">}</a>
<a name="ln1648"> </a>
<a name="ln1649">/**</a>
<a name="ln1650"> * Load the current level.</a>
<a name="ln1651"> *</a>
<a name="ln1652"> * @param stair_taken   The means used to enter the level.</a>
<a name="ln1653"> * @param load_mode     Whether the level is being entered, examined, etc.</a>
<a name="ln1654"> * @return Whether a new level was created.</a>
<a name="ln1655"> */</a>
<a name="ln1656">bool load_level(dungeon_feature_type stair_taken, load_mode_type load_mode,</a>
<a name="ln1657">                const level_id&amp; old_level)</a>
<a name="ln1658">{</a>
<a name="ln1659">    const string level_name = level_id::current().describe();</a>
<a name="ln1660">    if (!you.save-&gt;has_chunk(level_name) &amp;&amp; load_mode == LOAD_VISITOR)</a>
<a name="ln1661">        return false;</a>
<a name="ln1662"> </a>
<a name="ln1663">    const bool make_changes =</a>
<a name="ln1664">        (load_mode == LOAD_START_GAME || load_mode == LOAD_ENTER_LEVEL);</a>
<a name="ln1665"> </a>
<a name="ln1666">#if TAG_MAJOR_VERSION == 34</a>
<a name="ln1667">    // fixup saves that don't have this prop initialized.</a>
<a name="ln1668">    if (load_mode == LOAD_RESTART_GAME)</a>
<a name="ln1669">        _fixup_visited_from_package();</a>
<a name="ln1670">#endif</a>
<a name="ln1671"> </a>
<a name="ln1672">    // Did we get here by popping the level stack?</a>
<a name="ln1673">    bool popped = false;</a>
<a name="ln1674"> </a>
<a name="ln1675">    coord_def return_pos; //TODO: initialize to null</a>
<a name="ln1676"> </a>
<a name="ln1677">    string hatch_name = &quot;&quot;;</a>
<a name="ln1678">    if (feat_is_escape_hatch(stair_taken))</a>
<a name="ln1679">        hatch_name = _get_hatch_name();</a>
<a name="ln1680"> </a>
<a name="ln1681">    if (load_mode != LOAD_VISITOR)</a>
<a name="ln1682">        popped = _leave_level(stair_taken, old_level, &amp;return_pos);</a>
<a name="ln1683"> </a>
<a name="ln1684">    unwind_var&lt;dungeon_feature_type&gt; stair(</a>
<a name="ln1685">        you.transit_stair, stair_taken, DNGN_UNSEEN);</a>
<a name="ln1686">    unwind_bool ylev(you.entering_level, load_mode != LOAD_VISITOR, false);</a>
<a name="ln1687"> </a>
<a name="ln1688">#ifdef DEBUG_LEVEL_LOAD</a>
<a name="ln1689">    mprf(MSGCH_DIAGNOSTICS, &quot;Loading... branch: %d, level: %d&quot;,</a>
<a name="ln1690">                            you.where_are_you, you.depth);</a>
<a name="ln1691">#endif</a>
<a name="ln1692"> </a>
<a name="ln1693">    // Save position for hatches to place a marker on the destination level.</a>
<a name="ln1694">    coord_def dest_pos = you.pos();</a>
<a name="ln1695"> </a>
<a name="ln1696">    _generic_level_reset();</a>
<a name="ln1697"> </a>
<a name="ln1698">    // We clear twice - on save and on load.</a>
<a name="ln1699">    // Once would be enough...</a>
<a name="ln1700">    if (make_changes)</a>
<a name="ln1701">        delete_all_clouds();</a>
<a name="ln1702"> </a>
<a name="ln1703">    // This block is to grab followers and save the old level to disk.</a>
<a name="ln1704">    if (load_mode == LOAD_ENTER_LEVEL)</a>
<a name="ln1705">    {</a>
<a name="ln1706">        dprf(&quot;stair_taken = %s&quot;, dungeon_feature_name(stair_taken));</a>
<a name="ln1707">        // Not the case normally, but can happen during recovery of damaged</a>
<a name="ln1708">        // games.</a>
<a name="ln1709">        if (old_level.depth != -1)</a>
<a name="ln1710">        {</a>
<a name="ln1711">            _grab_followers();</a>
<a name="ln1712"> </a>
<a name="ln1713">            if (env.level_state &amp; LSTATE_DELETED)</a>
<a name="ln1714">                delete_level(old_level), dprf(&quot;&lt;lightmagenta&gt;Deleting level.&lt;/lightmagenta&gt;&quot;);</a>
<a name="ln1715">            else</a>
<a name="ln1716">                _save_level(old_level);</a>
<a name="ln1717">        }</a>
<a name="ln1718"> </a>
<a name="ln1719">        // The player is now between levels.</a>
<a name="ln1720">        you.position.reset();</a>
<a name="ln1721"> </a>
<a name="ln1722">        update_companions();</a>
<a name="ln1723">    }</a>
<a name="ln1724"> </a>
<a name="ln1725">#ifdef USE_TILE</a>
<a name="ln1726">    if (load_mode != LOAD_VISITOR)</a>
<a name="ln1727">    {</a>
<a name="ln1728">        tiles.clear_minimap();</a>
<a name="ln1729">        crawl_view_buffer empty_vbuf;</a>
<a name="ln1730">        tiles.load_dungeon(empty_vbuf, crawl_view.vgrdc);</a>
<a name="ln1731">    }</a>
<a name="ln1732">#endif</a>
<a name="ln1733"> </a>
<a name="ln1734">    if (load_mode != LOAD_VISITOR</a>
<a name="ln1735">        &amp;&amp; you.chapter == CHAPTER_POCKET_ABYSS</a>
<a name="ln1736">        &amp;&amp; player_in_branch(BRANCH_DUNGEON))</a>
<a name="ln1737">    {</a>
<a name="ln1738">        // If we're leaving the Abyss for the first time as a Chaos</a>
<a name="ln1739">        // Knight of Lugonu (who start out there), enable normal monster</a>
<a name="ln1740">        // generation.</a>
<a name="ln1741">        you.chapter = CHAPTER_ORB_HUNTING;</a>
<a name="ln1742">    }</a>
<a name="ln1743"> </a>
<a name="ln1744">    // GENERATE new level(s) when the file can't be opened:</a>
<a name="ln1745">    if (!pregen_dungeon(level_id::current()))</a>
<a name="ln1746">    {</a>
<a name="ln1747">        ASSERT(you.save-&gt;has_chunk(level_name));</a>
<a name="ln1748">        dprf(&quot;Loading old level '%s'.&quot;, level_name.c_str());</a>
<a name="ln1749">        _restore_tagged_chunk(you.save, level_name, TAG_LEVEL, &quot;Level file is invalid.&quot;);</a>
<a name="ln1750">        _redraw_all(); // TODO why is there a redraw call here?</a>
<a name="ln1751">    }</a>
<a name="ln1752"> </a>
<a name="ln1753">    const bool just_created_level = !you.level_visited(level_id::current());</a>
<a name="ln1754"> </a>
<a name="ln1755">    // Clear map knowledge stair emphasis.</a>
<a name="ln1756">    show_update_emphasis();</a>
<a name="ln1757"> </a>
<a name="ln1758">    // Shouldn't happen, but this is too unimportant to assert.</a>
<a name="ln1759">    deleteAll(env.final_effects);</a>
<a name="ln1760"> </a>
<a name="ln1761">    los_changed();</a>
<a name="ln1762"> </a>
<a name="ln1763">    if (load_mode != LOAD_VISITOR)</a>
<a name="ln1764">        you.set_level_visited(level_id::current());</a>
<a name="ln1765"> </a>
<a name="ln1766">    // Markers must be activated early, since they may rely on</a>
<a name="ln1767">    // events issued later, e.g. DET_ENTERING_LEVEL or</a>
<a name="ln1768">    // the DET_TURN_ELAPSED from update_level.</a>
<a name="ln1769">    if (make_changes || load_mode == LOAD_RESTART_GAME)</a>
<a name="ln1770">        env.markers.activate_all();</a>
<a name="ln1771"> </a>
<a name="ln1772">    if (make_changes &amp;&amp; env.elapsed_time &amp;&amp; !just_created_level)</a>
<a name="ln1773">        update_level(you.elapsed_time - env.elapsed_time);</a>
<a name="ln1774"> </a>
<a name="ln1775">    // Apply all delayed actions, if any. TODO: logic for marshalling this is</a>
<a name="ln1776">    // kind of odd.</a>
<a name="ln1777">    if (just_created_level)</a>
<a name="ln1778">        env.dactions_done = 0;</a>
<a name="ln1779"> </a>
<a name="ln1780">    // Here's the second cloud clearing, on load (see above).</a>
<a name="ln1781">    if (make_changes)</a>
<a name="ln1782">    {</a>
<a name="ln1783">        // this includes various things that are irrelevant for new levels, but</a>
<a name="ln1784">        // also some things that aren't, such as bribe branch.</a>
<a name="ln1785">        catchup_dactions();</a>
<a name="ln1786"> </a>
<a name="ln1787">        delete_all_clouds();</a>
<a name="ln1788"> </a>
<a name="ln1789">        _place_player(stair_taken, return_pos, dest_pos, hatch_name);</a>
<a name="ln1790">    }</a>
<a name="ln1791"> </a>
<a name="ln1792">    crawl_view.set_player_at(you.pos(), load_mode != LOAD_VISITOR);</a>
<a name="ln1793"> </a>
<a name="ln1794">    // Actually &quot;move&quot; the followers if applicable.</a>
<a name="ln1795">    if (load_mode == LOAD_ENTER_LEVEL)</a>
<a name="ln1796">        place_followers();</a>
<a name="ln1797"> </a>
<a name="ln1798">    // Load monsters in transit.</a>
<a name="ln1799">    if (load_mode == LOAD_ENTER_LEVEL)</a>
<a name="ln1800">        place_transiting_monsters();</a>
<a name="ln1801"> </a>
<a name="ln1802">    if (just_created_level &amp;&amp; make_changes)</a>
<a name="ln1803">        replace_boris();</a>
<a name="ln1804"> </a>
<a name="ln1805">    if (make_changes)</a>
<a name="ln1806">    {</a>
<a name="ln1807">        // Tell stash-tracker and travel that we've changed levels.</a>
<a name="ln1808">        trackers_init_new_level();</a>
<a name="ln1809">        tile_new_level(just_created_level);</a>
<a name="ln1810">    }</a>
<a name="ln1811">    else if (load_mode == LOAD_RESTART_GAME)</a>
<a name="ln1812">    {</a>
<a name="ln1813">        // Travel needs initialize some things on reload, too.</a>
<a name="ln1814">        travel_init_load_level();</a>
<a name="ln1815">    }</a>
<a name="ln1816"> </a>
<a name="ln1817">    _redraw_all();</a>
<a name="ln1818"> </a>
<a name="ln1819">    if (load_mode != LOAD_VISITOR)</a>
<a name="ln1820">        dungeon_events.fire_event(DET_ENTERING_LEVEL);</a>
<a name="ln1821"> </a>
<a name="ln1822">    // Things to update for player entering level</a>
<a name="ln1823">    if (load_mode == LOAD_ENTER_LEVEL)</a>
<a name="ln1824">    {</a>
<a name="ln1825">        // new levels have less wary monsters, and we don't</a>
<a name="ln1826">        // want them to attack players quite as soon:</a>
<a name="ln1827">        you.time_taken *= (just_created_level ? 1 : 2);</a>
<a name="ln1828"> </a>
<a name="ln1829">        you.time_taken = div_rand_round(you.time_taken * 3, 4);</a>
<a name="ln1830"> </a>
<a name="ln1831">        dprf(&quot;arrival time: %d&quot;, you.time_taken);</a>
<a name="ln1832"> </a>
<a name="ln1833">        if (just_created_level)</a>
<a name="ln1834">            run_map_epilogues();</a>
<a name="ln1835">    }</a>
<a name="ln1836"> </a>
<a name="ln1837">    // Save the created/updated level out to disk:</a>
<a name="ln1838">    if (make_changes)</a>
<a name="ln1839">        _save_level(level_id::current());</a>
<a name="ln1840"> </a>
<a name="ln1841">    setup_environment_effects();</a>
<a name="ln1842"> </a>
<a name="ln1843">    setup_vault_mon_list();</a>
<a name="ln1844"> </a>
<a name="ln1845">    // Inform user of level's annotation.</a>
<a name="ln1846">    if (load_mode != LOAD_VISITOR</a>
<a name="ln1847">        &amp;&amp; !get_level_annotation().empty()</a>
<a name="ln1848">        &amp;&amp; !crawl_state.level_annotation_shown)</a>
<a name="ln1849">    {</a>
<a name="ln1850">        mprf(MSGCH_PLAIN, YELLOW, &quot;Level annotation: %s&quot;,</a>
<a name="ln1851">             get_level_annotation().c_str());</a>
<a name="ln1852">    }</a>
<a name="ln1853"> </a>
<a name="ln1854">    if (load_mode != LOAD_VISITOR)</a>
<a name="ln1855">        crawl_state.level_annotation_shown = false;</a>
<a name="ln1856"> </a>
<a name="ln1857">    if (make_changes)</a>
<a name="ln1858">    {</a>
<a name="ln1859">        // Update PlaceInfo entries</a>
<a name="ln1860">        PlaceInfo&amp; curr_PlaceInfo = you.get_place_info();</a>
<a name="ln1861">        PlaceInfo  delta;</a>
<a name="ln1862"> </a>
<a name="ln1863">        if (load_mode == LOAD_START_GAME</a>
<a name="ln1864">            || (load_mode == LOAD_ENTER_LEVEL</a>
<a name="ln1865">                &amp;&amp; old_level.branch != you.where_are_you</a>
<a name="ln1866">                &amp;&amp; !popped))</a>
<a name="ln1867">        {</a>
<a name="ln1868">            delta.num_visits++;</a>
<a name="ln1869">        }</a>
<a name="ln1870"> </a>
<a name="ln1871">        if (just_created_level)</a>
<a name="ln1872">            delta.levels_seen++;</a>
<a name="ln1873"> </a>
<a name="ln1874">        you.global_info += delta;</a>
<a name="ln1875">#ifdef DEBUG_LEVEL_LOAD</a>
<a name="ln1876">        mprf(MSGCH_DIAGNOSTICS,</a>
<a name="ln1877">             &quot;global_info:: num_visits: %d, levels_seen: %d&quot;,</a>
<a name="ln1878">             you.global_info.num_visits, you.global_info.levels_seen);</a>
<a name="ln1879">#endif</a>
<a name="ln1880">        you.global_info.assert_validity();</a>
<a name="ln1881"> </a>
<a name="ln1882">        curr_PlaceInfo += delta;</a>
<a name="ln1883">#ifdef DEBUG_LEVEL_LOAD</a>
<a name="ln1884">        mprf(MSGCH_DIAGNOSTICS,</a>
<a name="ln1885">             &quot;curr_PlaceInfo:: num_visits: %d, levels_seen: %d&quot;,</a>
<a name="ln1886">             curr_PlaceInfo.num_visits, curr_PlaceInfo.levels_seen);</a>
<a name="ln1887">#endif</a>
<a name="ln1888">#if TAG_MAJOR_VERSION == 34</a>
<a name="ln1889">        // this fixup is for a bug where turns_on_level==0 was used to set</a>
<a name="ln1890">        // just_created_level, and there were some obscure ways to have 0</a>
<a name="ln1891">        // turns on a level that you had entered previously. It only applies</a>
<a name="ln1892">        // to a narrow version range (basically 0.23.0) but there's no way to</a>
<a name="ln1893">        // do a sensible minor version check here and the fixup can't happen</a>
<a name="ln1894">        // on load.</a>
<a name="ln1895">        if (is_connected_branch(curr_PlaceInfo.branch)</a>
<a name="ln1896">            &amp;&amp; brdepth[curr_PlaceInfo.branch] &gt; 0</a>
<a name="ln1897">            &amp;&amp; static_cast&lt;int&gt;(curr_PlaceInfo.levels_seen)</a>
<a name="ln1898">                                        &gt; brdepth[curr_PlaceInfo.branch])</a>
<a name="ln1899">        {</a>
<a name="ln1900">            mprf(MSGCH_ERROR,</a>
<a name="ln1901">                &quot;Fixing up corrupted PlaceInfo for %s (levels_seen is %d)&quot;,</a>
<a name="ln1902">                branches[curr_PlaceInfo.branch].shortname,</a>
<a name="ln1903">                curr_PlaceInfo.levels_seen);</a>
<a name="ln1904">            curr_PlaceInfo.levels_seen = brdepth[curr_PlaceInfo.branch];</a>
<a name="ln1905">        }</a>
<a name="ln1906">#endif</a>
<a name="ln1907">        curr_PlaceInfo.assert_validity();</a>
<a name="ln1908">    }</a>
<a name="ln1909"> </a>
<a name="ln1910">    if (just_created_level)</a>
<a name="ln1911">    {</a>
<a name="ln1912">        you.attribute[ATTR_ABYSS_ENTOURAGE] = 0;</a>
<a name="ln1913">        gozag_detect_level_gold(true);</a>
<a name="ln1914">    }</a>
<a name="ln1915"> </a>
<a name="ln1916"> </a>
<a name="ln1917">    if (load_mode != LOAD_VISITOR)</a>
<a name="ln1918">        dungeon_events.fire_event(DET_ENTERED_LEVEL);</a>
<a name="ln1919"> </a>
<a name="ln1920">    if (load_mode == LOAD_ENTER_LEVEL)</a>
<a name="ln1921">    {</a>
<a name="ln1922">        // 50% chance of repelling the stair you just came through.</a>
<a name="ln1923">        if (you.duration[DUR_REPEL_STAIRS_MOVE]</a>
<a name="ln1924">            || you.duration[DUR_REPEL_STAIRS_CLIMB])</a>
<a name="ln1925">        {</a>
<a name="ln1926">            dungeon_feature_type feat = grd(you.pos());</a>
<a name="ln1927">            if (feat != DNGN_ENTER_SHOP</a>
<a name="ln1928">                &amp;&amp; feat_stair_direction(feat) != CMD_NO_CMD</a>
<a name="ln1929">                &amp;&amp; feat_stair_direction(stair_taken) != CMD_NO_CMD)</a>
<a name="ln1930">            {</a>
<a name="ln1931">                string stair_str = feature_description_at(you.pos(), false,</a>
<a name="ln1932">                                                          DESC_THE);</a>
<a name="ln1933">                string verb = stair_climb_verb(feat);</a>
<a name="ln1934"> </a>
<a name="ln1935">                if (coinflip()</a>
<a name="ln1936">                    &amp;&amp; slide_feature_over(you.pos()))</a>
<a name="ln1937">                {</a>
<a name="ln1938">                    mprf(&quot;%s slides away from you right after you %s it!&quot;,</a>
<a name="ln1939">                         stair_str.c_str(), verb.c_str());</a>
<a name="ln1940">                }</a>
<a name="ln1941"> </a>
<a name="ln1942">                if (coinflip())</a>
<a name="ln1943">                {</a>
<a name="ln1944">                    // Stairs stop fleeing from you now you actually caught one.</a>
<a name="ln1945">                    mprf(&quot;%s settles down.&quot;, stair_str.c_str());</a>
<a name="ln1946">                    you.duration[DUR_REPEL_STAIRS_MOVE]  = 0;</a>
<a name="ln1947">                    you.duration[DUR_REPEL_STAIRS_CLIMB] = 0;</a>
<a name="ln1948">                }</a>
<a name="ln1949">            }</a>
<a name="ln1950">        }</a>
<a name="ln1951"> </a>
<a name="ln1952">        ash_detect_portals(is_map_persistent());</a>
<a name="ln1953"> </a>
<a name="ln1954">        if (just_created_level)</a>
<a name="ln1955">            xom_new_level_noise_or_stealth();</a>
<a name="ln1956">    }</a>
<a name="ln1957">    // Initialize halos, etc.</a>
<a name="ln1958">    invalidate_agrid(true);</a>
<a name="ln1959"> </a>
<a name="ln1960">    // Maybe make a note if we reached a new level.</a>
<a name="ln1961">    // Don't do so if we are just moving around inside Pan, though.</a>
<a name="ln1962">    if (just_created_level &amp;&amp; make_changes</a>
<a name="ln1963">        &amp;&amp; stair_taken != DNGN_TRANSIT_PANDEMONIUM)</a>
<a name="ln1964">    {</a>
<a name="ln1965">        take_note(Note(NOTE_DUNGEON_LEVEL_CHANGE));</a>
<a name="ln1966">    }</a>
<a name="ln1967"> </a>
<a name="ln1968">    // If the player entered the level from a different location than they last</a>
<a name="ln1969">    // exited it, have monsters lose track of where they are</a>
<a name="ln1970">    if (you.position != env.old_player_pos)</a>
<a name="ln1971">       shake_off_monsters(you.as_player());</a>
<a name="ln1972"> </a>
<a name="ln1973">#if TAG_MAJOR_VERSION == 34</a>
<a name="ln1974">    if (make_changes &amp;&amp; you.props.exists(&quot;zig-fixup&quot;)</a>
<a name="ln1975">        &amp;&amp; you.where_are_you == BRANCH_TOMB</a>
<a name="ln1976">        &amp;&amp; you.depth == brdepth[BRANCH_TOMB])</a>
<a name="ln1977">    {</a>
<a name="ln1978">        if (!just_created_level)</a>
<a name="ln1979">        {</a>
<a name="ln1980">            int obj = items(false, OBJ_MISCELLANY, MISC_ZIGGURAT, 0);</a>
<a name="ln1981">            ASSERT(obj != NON_ITEM);</a>
<a name="ln1982">            bool success = move_item_to_grid(&amp;obj, you.pos(), true);</a>
<a name="ln1983">            ASSERT(success);</a>
<a name="ln1984">        }</a>
<a name="ln1985">        you.props.erase(&quot;zig-fixup&quot;);</a>
<a name="ln1986">    }</a>
<a name="ln1987">#endif</a>
<a name="ln1988"> </a>
<a name="ln1989">    return just_created_level;</a>
<a name="ln1990">}</a>
<a name="ln1991"> </a>
<a name="ln1992">static void _save_level(const level_id&amp; lid)</a>
<a name="ln1993">{</a>
<a name="ln1994">    if (you.level_visited(lid))</a>
<a name="ln1995">        travel_cache.get_level_info(lid).update();</a>
<a name="ln1996"> </a>
<a name="ln1997">    // Nail all items to the ground.</a>
<a name="ln1998">    fix_item_coordinates();</a>
<a name="ln1999"> </a>
<a name="ln2000">    _write_tagged_chunk(lid.describe(), TAG_LEVEL);</a>
<a name="ln2001">}</a>
<a name="ln2002"> </a>
<a name="ln2003">#if TAG_MAJOR_VERSION == 34</a>
<a name="ln2004"># define CHUNK(short, long) short</a>
<a name="ln2005">#else</a>
<a name="ln2006"># define CHUNK(short, long) long</a>
<a name="ln2007">#endif</a>
<a name="ln2008"> </a>
<a name="ln2009">#define SAVEFILE(short, long, savefn)           \</a>
<a name="ln2010">    do                                          \</a>
<a name="ln2011">    {                                           \</a>
<a name="ln2012">        writer w(you.save, CHUNK(short, long)); \</a>
<a name="ln2013">        savefn(w);                              \</a>
<a name="ln2014">    } while (false)</a>
<a name="ln2015"> </a>
<a name="ln2016">// Stack allocated string's go in separate function, so Valgrind doesn't</a>
<a name="ln2017">// complain.</a>
<a name="ln2018">static void _save_game_base()</a>
<a name="ln2019">{</a>
<a name="ln2020">    /* Stashes */</a>
<a name="ln2021">    SAVEFILE(&quot;st&quot;, &quot;stashes&quot;, StashTrack.save);</a>
<a name="ln2022"> </a>
<a name="ln2023">#ifdef CLUA_BINDINGS</a>
<a name="ln2024">    /* lua */</a>
<a name="ln2025">    SAVEFILE(&quot;lua&quot;, &quot;lua&quot;, clua.save);</a>
<a name="ln2026">#endif</a>
<a name="ln2027"> </a>
<a name="ln2028">    /* kills */</a>
<a name="ln2029">    SAVEFILE(&quot;kil&quot;, &quot;kills&quot;, you.kills.save);</a>
<a name="ln2030"> </a>
<a name="ln2031">    /* travel cache */</a>
<a name="ln2032">    SAVEFILE(&quot;tc&quot;, &quot;travel_cache&quot;, travel_cache.save);</a>
<a name="ln2033"> </a>
<a name="ln2034">    /* notes */</a>
<a name="ln2035">    SAVEFILE(&quot;nts&quot;, &quot;notes&quot;, save_notes);</a>
<a name="ln2036"> </a>
<a name="ln2037">    /* tutorial/hints mode */</a>
<a name="ln2038">    if (crawl_state.game_is_hints_tutorial())</a>
<a name="ln2039">        SAVEFILE(&quot;tut&quot;, &quot;tutorial&quot;, save_hints);</a>
<a name="ln2040"> </a>
<a name="ln2041">    /* messages */</a>
<a name="ln2042">    SAVEFILE(&quot;msg&quot;, &quot;messages&quot;, save_messages);</a>
<a name="ln2043"> </a>
<a name="ln2044">    /* tile dolls (empty for ASCII)*/</a>
<a name="ln2045">#ifdef USE_TILE</a>
<a name="ln2046">    // Save the current equipment into a file.</a>
<a name="ln2047">    SAVEFILE(&quot;tdl&quot;, &quot;tiles_doll&quot;, save_doll_file);</a>
<a name="ln2048">#endif</a>
<a name="ln2049"> </a>
<a name="ln2050">    _write_tagged_chunk(&quot;you&quot;, TAG_YOU);</a>
<a name="ln2051">    _write_tagged_chunk(&quot;chr&quot;, TAG_CHR);</a>
<a name="ln2052">}</a>
<a name="ln2053"> </a>
<a name="ln2054">// Stack allocated string's go in separate function, so Valgrind doesn't</a>
<a name="ln2055">// complain.</a>
<a name="ln2056">static void _save_game_exit()</a>
<a name="ln2057">{</a>
<a name="ln2058">    clua.save_persist();</a>
<a name="ln2059"> </a>
<a name="ln2060">    // Prompt for saving macros.</a>
<a name="ln2061">    if (crawl_state.unsaved_macros)</a>
<a name="ln2062">        macro_save();</a>
<a name="ln2063"> </a>
<a name="ln2064">    // Must be exiting -- save level &amp; goodbye!</a>
<a name="ln2065">    if (!you.entering_level)</a>
<a name="ln2066">        _save_level(level_id::current());</a>
<a name="ln2067"> </a>
<a name="ln2068">    clrscr();</a>
<a name="ln2069"> </a>
<a name="ln2070">#ifdef DGL_WHEREIS</a>
<a name="ln2071">    whereis_record(&quot;saved&quot;);</a>
<a name="ln2072">#endif</a>
<a name="ln2073">#ifdef USE_TILE_WEB</a>
<a name="ln2074">    tiles.send_exit_reason(&quot;saved&quot;);</a>
<a name="ln2075">#endif</a>
<a name="ln2076"> </a>
<a name="ln2077">    delete you.save;</a>
<a name="ln2078">    you.save = 0;</a>
<a name="ln2079">}</a>
<a name="ln2080"> </a>
<a name="ln2081">void save_game(bool leave_game, const char *farewellmsg)</a>
<a name="ln2082">{</a>
<a name="ln2083">    unwind_bool saving_game(crawl_state.saving_game, true);</a>
<a name="ln2084"> </a>
<a name="ln2085"> </a>
<a name="ln2086">    if (leave_game &amp;&amp; Options.dump_on_save)</a>
<a name="ln2087">    {</a>
<a name="ln2088">        if (!dump_char(you.your_name, true))</a>
<a name="ln2089">        {</a>
<a name="ln2090">            mpr(&quot;Char dump unsuccessful! Sorry about that.&quot;);</a>
<a name="ln2091">            if (!crawl_state.seen_hups)</a>
<a name="ln2092">                more();</a>
<a name="ln2093">        }</a>
<a name="ln2094">#ifdef USE_TILE_WEB</a>
<a name="ln2095">        else</a>
<a name="ln2096">            tiles.send_dump_info(&quot;save&quot;, you.your_name);</a>
<a name="ln2097">#endif</a>
<a name="ln2098">    }</a>
<a name="ln2099"> </a>
<a name="ln2100">    // Stack allocated string's go in separate function,</a>
<a name="ln2101">    // so Valgrind doesn't complain.</a>
<a name="ln2102">    _save_game_base();</a>
<a name="ln2103"> </a>
<a name="ln2104">    // If just save, early out.</a>
<a name="ln2105">    if (!leave_game)</a>
<a name="ln2106">    {</a>
<a name="ln2107">        if (!crawl_state.disables[DIS_SAVE_CHECKPOINTS])</a>
<a name="ln2108">            you.save-&gt;commit();</a>
<a name="ln2109">        return;</a>
<a name="ln2110">    }</a>
<a name="ln2111"> </a>
<a name="ln2112">    // Stack allocated string's go in separate function,</a>
<a name="ln2113">    // so Valgrind doesn't complain.</a>
<a name="ln2114">    _save_game_exit();</a>
<a name="ln2115"> </a>
<a name="ln2116">    game_ended(game_exit::save, farewellmsg ? farewellmsg</a>
<a name="ln2117">                                : &quot;See you soon, &quot; + you.your_name + &quot;!&quot;);</a>
<a name="ln2118">}</a>
<a name="ln2119"> </a>
<a name="ln2120">// Saves the game without exiting.</a>
<a name="ln2121">void save_game_state()</a>
<a name="ln2122">{</a>
<a name="ln2123">    save_game(false);</a>
<a name="ln2124">    if (crawl_state.seen_hups)</a>
<a name="ln2125">        save_game(true);</a>
<a name="ln2126">}</a>
<a name="ln2127"> </a>
<a name="ln2128">static bool _bones_save_individual_levels(bool store)</a>
<a name="ln2129">{</a>
<a name="ln2130">    // Only use level-numbered bones files for places where players die a lot.</a>
<a name="ln2131">    // For the permastore, go even coarser (just D and Lair use level numbers).</a>
<a name="ln2132">    // n.b. some branches here may not currently generate ghosts.</a>
<a name="ln2133">    // TODO: further adjustments? Make Zot coarser?</a>
<a name="ln2134">    return store ? player_in_branch(BRANCH_DUNGEON) ||</a>
<a name="ln2135">                   player_in_branch(BRANCH_LAIR)</a>
<a name="ln2136">                 : !(player_in_branch(BRANCH_ZIGGURAT) ||</a>
<a name="ln2137">                     player_in_branch(BRANCH_CRYPT) ||</a>
<a name="ln2138">                     player_in_branch(BRANCH_TOMB) ||</a>
<a name="ln2139">                     player_in_branch(BRANCH_ABYSS) ||</a>
<a name="ln2140">                     player_in_branch(BRANCH_SLIME));</a>
<a name="ln2141">}</a>
<a name="ln2142"> </a>
<a name="ln2143">static string _make_ghost_filename(bool store=false)</a>
<a name="ln2144">{</a>
<a name="ln2145">    const bool with_number = _bones_save_individual_levels(store);</a>
<a name="ln2146">    // Players die so rarely in hell in practice that it doesn't even make</a>
<a name="ln2147">    // sense to have per-hell bones. (Maybe vestibule should be separate?)</a>
<a name="ln2148">    const string level_desc = player_in_hell(true) ? &quot;Hells&quot; :</a>
<a name="ln2149">        replace_all(level_id::current().describe(false, with_number), &quot;:&quot;, &quot;-&quot;);</a>
<a name="ln2150">    return string(&quot;bones.&quot;) + (store ? &quot;store.&quot; : &quot;&quot;) + level_desc;</a>
<a name="ln2151">}</a>
<a name="ln2152"> </a>
<a name="ln2153">static string _bones_permastore_file()</a>
<a name="ln2154">{</a>
<a name="ln2155">    string filename = _make_ghost_filename(true);</a>
<a name="ln2156">    string full_path = _get_bonefile_directory() + filename;</a>
<a name="ln2157">    if (file_exists(full_path))</a>
<a name="ln2158">        return full_path;</a>
<a name="ln2159"> </a>
<a name="ln2160">    string dist_full_path = datafile_path(</a>
<a name="ln2161">            string(&quot;dist_bones&quot;) + FILE_SEPARATOR + filename, false, false);</a>
<a name="ln2162">    if (dist_full_path.empty())</a>
<a name="ln2163">        return dist_full_path;</a>
<a name="ln2164"> </a>
<a name="ln2165">    // no matching permastore is in the player's bones file, but one exists in</a>
<a name="ln2166">    // the crawl distribution. Install it.</a>
<a name="ln2167"> </a>
<a name="ln2168">    FILE *src = fopen(dist_full_path.c_str(), &quot;rb&quot;);</a>
<a name="ln2169">    if (!src)</a>
<a name="ln2170">    {</a>
<a name="ln2171">        mprf(MSGCH_ERROR, &quot;Bones file exists but can't be opened: %s&quot;,</a>
<a name="ln2172">            dist_full_path.c_str());</a>
<a name="ln2173">        return &quot;&quot;;</a>
<a name="ln2174">    }</a>
<a name="ln2175">    FILE *target = lk_open(&quot;wb&quot;, full_path);</a>
<a name="ln2176">    if (!target)</a>
<a name="ln2177">    {</a>
<a name="ln2178">        mprf(MSGCH_ERROR, &quot;Unable to open bones file %s for writing&quot;,</a>
<a name="ln2179">            full_path.c_str());</a>
<a name="ln2180">        fclose(src);</a>
<a name="ln2181">        return &quot;&quot;;</a>
<a name="ln2182">    }</a>
<a name="ln2183"> </a>
<a name="ln2184">    _ghost_dprf(&quot;Copying %s to %s&quot;, dist_full_path.c_str(), full_path.c_str());</a>
<a name="ln2185"> </a>
<a name="ln2186">    char buf[BUFSIZ];</a>
<a name="ln2187"> </a>
<a name="ln2188">    size_t size;</a>
<a name="ln2189">    while ((size = fread(buf, sizeof(char), BUFSIZ, src)) &gt; 0)</a>
<a name="ln2190">        fwrite(buf, sizeof(char), size, target);</a>
<a name="ln2191"> </a>
<a name="ln2192">    lk_close(target);</a>
<a name="ln2193"> </a>
<a name="ln2194">    if (!feof(src))</a>
<a name="ln2195">    {</a>
<a name="ln2196">        mprf(MSGCH_ERROR, &quot;Error installing bones file to %s&quot;,</a>
<a name="ln2197">                                                    full_path.c_str());</a>
<a name="ln2198">        if (unlink(full_path.c_str()) != 0)</a>
<a name="ln2199">        {</a>
<a name="ln2200">            mprf(MSGCH_ERROR,</a>
<a name="ln2201">                &quot;Failed to unlink probably corrupt bones file: %s&quot;,</a>
<a name="ln2202">                full_path.c_str());</a>
<a name="ln2203">        }</a>
<a name="ln2204">        fclose(src);</a>
<a name="ln2205">        return &quot;&quot;;</a>
<a name="ln2206">    }</a>
<a name="ln2207">    fclose(src);</a>
<a name="ln2208">    return full_path;</a>
<a name="ln2209">}</a>
<a name="ln2210"> </a>
<a name="ln2211">// Bones files</a>
<a name="ln2212">//</a>
<a name="ln2213">// There are two kinds of bones files: temporary bones files and the</a>
<a name="ln2214">// permastore. Temporary bones files are ephemeral: ghosts will be reused only</a>
<a name="ln2215">// if they are on the floor where the player dies. The permastore is a more</a>
<a name="ln2216">// permanent stock of ghosts (per level) to use as a backup in case the</a>
<a name="ln2217">// temporary bones files are depleted.</a>
<a name="ln2218"> </a>
<a name="ln2219">/**</a>
<a name="ln2220"> * Lists all bonefiles for the current level.</a>
<a name="ln2221"> *</a>
<a name="ln2222"> * @return A vector containing absolute paths to 0+ bonefiles.</a>
<a name="ln2223"> */</a>
<a name="ln2224">static vector&lt;string&gt; _list_bones()</a>
<a name="ln2225">{</a>
<a name="ln2226">    string bonefile_dir = _get_bonefile_directory();</a>
<a name="ln2227">    string base_filename = _make_ghost_filename();</a>
<a name="ln2228">    string underscored_filename = base_filename + &quot;_&quot;;</a>
<a name="ln2229"> </a>
<a name="ln2230">    vector&lt;string&gt; filenames = get_dir_files_sorted(bonefile_dir);</a>
<a name="ln2231">    vector&lt;string&gt; bonefiles;</a>
<a name="ln2232">    for (const auto &amp;filename : filenames)</a>
<a name="ln2233">        if (starts_with(filename, underscored_filename)</a>
<a name="ln2234">                                            &amp;&amp; !ends_with(filename, &quot;.backup&quot;))</a>
<a name="ln2235">        {</a>
<a name="ln2236">            bonefiles.push_back(bonefile_dir + filename);</a>
<a name="ln2237">            _ghost_dprf(&quot;bonesfile %s&quot;, (bonefile_dir + filename).c_str());</a>
<a name="ln2238">        }</a>
<a name="ln2239"> </a>
<a name="ln2240">    string old_bonefile = _get_old_bonefile_directory() + base_filename;</a>
<a name="ln2241">    if (access(old_bonefile.c_str(), F_OK) == 0)</a>
<a name="ln2242">    {</a>
<a name="ln2243">        _ghost_dprf(&quot;Found old bonefile %s&quot;, old_bonefile.c_str());</a>
<a name="ln2244">        bonefiles.push_back(old_bonefile);</a>
<a name="ln2245">    }</a>
<a name="ln2246"> </a>
<a name="ln2247">    return bonefiles;</a>
<a name="ln2248">}</a>
<a name="ln2249"> </a>
<a name="ln2250">/**</a>
<a name="ln2251"> * Attempts to find a file containing ghost(s) appropriate for the player.</a>
<a name="ln2252"> *</a>
<a name="ln2253"> * @return The filename of an appropriate bones file; may be &quot;&quot;.</a>
<a name="ln2254"> */</a>
<a name="ln2255">static string _find_ghost_file()</a>
<a name="ln2256">{</a>
<a name="ln2257">    vector&lt;string&gt; bonefiles = _list_bones();</a>
<a name="ln2258">    if (bonefiles.empty())</a>
<a name="ln2259">        return &quot;&quot;;</a>
<a name="ln2260">    return bonefiles[random2(bonefiles.size())];</a>
<a name="ln2261">}</a>
<a name="ln2262"> </a>
<a name="ln2263">static string _old_bones_filename(string ghost_filename, const save_version &amp;v)</a>
<a name="ln2264">{</a>
<a name="ln2265">    // TODO: a way of looking for any backup with a version earlier than v</a>
<a name="ln2266">    if (ends_with(ghost_filename, &quot;.backup&quot;))</a>
<a name="ln2267">        return ghost_filename; // already an old bones file</a>
<a name="ln2268"> </a>
<a name="ln2269">    string new_filename = make_stringf(&quot;%s-v%d.%d.backup&quot;, ghost_filename.c_str(),</a>
<a name="ln2270">                                        v.major, v.minor);</a>
<a name="ln2271">    return new_filename;</a>
<a name="ln2272">}</a>
<a name="ln2273"> </a>
<a name="ln2274">static bool _backup_bones_for_upgrade(string ghost_filename, save_version &amp;v)</a>
<a name="ln2275">{</a>
<a name="ln2276">    // Copy the bones file to a versioned name, so that non-upgraded saves can</a>
<a name="ln2277">    // load it. Copying would be cleaner with c++ ios stuff, but we need to</a>
<a name="ln2278">    // interact with the lock system.</a>
<a name="ln2279"> </a>
<a name="ln2280">    if (ghost_filename.empty())</a>
<a name="ln2281">        return false;</a>
<a name="ln2282">    if (ends_with(ghost_filename, &quot;.backup&quot;))</a>
<a name="ln2283">        return false; // already an old bones file</a>
<a name="ln2284"> </a>
<a name="ln2285">    string upgrade_filename = _old_bones_filename(ghost_filename, v);</a>
<a name="ln2286">    if (file_exists(upgrade_filename))</a>
<a name="ln2287">        return false;</a>
<a name="ln2288">    _ghost_dprf(&quot;Backing up bones file %s to %s before upgrade to %d.%d&quot;,</a>
<a name="ln2289">                            ghost_filename.c_str(), upgrade_filename.c_str(),</a>
<a name="ln2290">                            save_version::current_bones().major,</a>
<a name="ln2291">                            save_version::current_bones().minor);</a>
<a name="ln2292"> </a>
<a name="ln2293">    FILE *backup_src = lk_open(&quot;rb&quot;, ghost_filename);</a>
<a name="ln2294">    if (!backup_src)</a>
<a name="ln2295">    {</a>
<a name="ln2296">        mprf(MSGCH_ERROR, &quot;Bones file to back up doesn't exist: %s&quot;,</a>
<a name="ln2297">            ghost_filename.c_str());</a>
<a name="ln2298">        return false;</a>
<a name="ln2299">    }</a>
<a name="ln2300">    FILE *backup_target = lk_open(&quot;wb&quot;, upgrade_filename);</a>
<a name="ln2301">    if (!backup_target)</a>
<a name="ln2302">    {</a>
<a name="ln2303">        mprf(MSGCH_ERROR, &quot;Unable to open bones backup file %s for writing&quot;,</a>
<a name="ln2304">            upgrade_filename.c_str());</a>
<a name="ln2305">        lk_close(backup_src);</a>
<a name="ln2306">        return false;</a>
<a name="ln2307">    }</a>
<a name="ln2308"> </a>
<a name="ln2309">    char buf[BUFSIZ];</a>
<a name="ln2310"> </a>
<a name="ln2311">    size_t size;</a>
<a name="ln2312">    while ((size = fread(buf, sizeof(char), BUFSIZ, backup_src)) &gt; 0)</a>
<a name="ln2313">        fwrite(buf, sizeof(char), size, backup_target);</a>
<a name="ln2314"> </a>
<a name="ln2315">    lk_close(backup_target);</a>
<a name="ln2316"> </a>
<a name="ln2317">    if (!feof(backup_src))</a>
<a name="ln2318">    {</a>
<a name="ln2319">        mprf(MSGCH_ERROR, &quot;Error backing up bones file to %s&quot;,</a>
<a name="ln2320">                                                    upgrade_filename.c_str());</a>
<a name="ln2321">        if (unlink(upgrade_filename.c_str()) != 0)</a>
<a name="ln2322">        {</a>
<a name="ln2323">            mprf(MSGCH_ERROR,</a>
<a name="ln2324">                &quot;Failed to unlink probably corrupt bones file: %s&quot;,</a>
<a name="ln2325">                upgrade_filename.c_str());</a>
<a name="ln2326">        }</a>
<a name="ln2327">        lk_close(backup_src);</a>
<a name="ln2328">        return false;</a>
<a name="ln2329">    }</a>
<a name="ln2330">    lk_close(backup_src);</a>
<a name="ln2331">    return true;</a>
<a name="ln2332">}</a>
<a name="ln2333"> </a>
<a name="ln2334">save_version read_ghost_header(reader &amp;inf)</a>
<a name="ln2335">{</a>
<a name="ln2336">    auto version = get_save_version(inf);</a>
<a name="ln2337">    if (!version.valid())</a>
<a name="ln2338">        return version;</a>
<a name="ln2339"> </a>
<a name="ln2340">#if TAG_MAJOR_VERSION == 34</a>
<a name="ln2341">    // downgrade bones files saved before the bones sub-versioning system</a>
<a name="ln2342">    if (version &gt; save_version::current_bones() &amp;&amp; version.is_compatible())</a>
<a name="ln2343">    {</a>
<a name="ln2344">        _ghost_dprf(&quot;Setting bones file version from %d.%d to %d.%d on load&quot;,</a>
<a name="ln2345">            version.major, version.minor,</a>
<a name="ln2346">            save_version::current_bones().major,</a>
<a name="ln2347">            save_version::current_bones().minor);</a>
<a name="ln2348">        version = save_version::current_bones();</a>
<a name="ln2349">    }</a>
<a name="ln2350">#endif</a>
<a name="ln2351"> </a>
<a name="ln2352">    try</a>
<a name="ln2353">    {</a>
<a name="ln2354">        // Check for the DCSS ghost signature.</a>
<a name="ln2355">        if (unmarshallShort(inf) != GHOST_SIGNATURE)</a>
<a name="ln2356">            return save_version(); // version was valid, but this isn't a bones file</a>
<a name="ln2357"> </a>
<a name="ln2358">        // Discard three more 32-bit words of padding.</a>
<a name="ln2359">        inf.read(nullptr, 3*4);</a>
<a name="ln2360">    }</a>
<a name="ln2361">    catch (short_read_exception &amp;E)</a>
<a name="ln2362">    {</a>
<a name="ln2363">        mprf(MSGCH_ERROR,</a>
<a name="ln2364">             &quot;Ghost file \&quot;%s\&quot; seems to be invalid (short read); deleting it.&quot;,</a>
<a name="ln2365">             inf.filename().c_str());</a>
<a name="ln2366">        return save_version();</a>
<a name="ln2367">    }</a>
<a name="ln2368"> </a>
<a name="ln2369">    return version;</a>
<a name="ln2370">}</a>
<a name="ln2371"> </a>
<a name="ln2372">vector&lt;ghost_demon&gt; load_bones_file(string ghost_filename, bool backup)</a>
<a name="ln2373">{</a>
<a name="ln2374">    vector&lt;ghost_demon&gt; result;</a>
<a name="ln2375"> </a>
<a name="ln2376">    if (ghost_filename.empty())</a>
<a name="ln2377">        return result; // no such ghost.</a>
<a name="ln2378"> </a>
<a name="ln2379">    reader inf(ghost_filename);</a>
<a name="ln2380">    if (!inf.valid())</a>
<a name="ln2381">    {</a>
<a name="ln2382">        // file doesn't exist</a>
<a name="ln2383">        _ghost_dprf(&quot;Ghost file '%s' invalid before read.&quot;, ghost_filename.c_str());</a>
<a name="ln2384">        return result;</a>
<a name="ln2385">    }</a>
<a name="ln2386"> </a>
<a name="ln2387">    inf.set_safe_read(true); // don't die on 0-byte bones</a>
<a name="ln2388">    save_version version = read_ghost_header(inf);</a>
<a name="ln2389">    if (!_ghost_version_compatible(version))</a>
<a name="ln2390">    {</a>
<a name="ln2391">        string error = &quot;Incompatible bones file: &quot; + ghost_filename;</a>
<a name="ln2392">        throw corrupted_save(error, version);</a>
<a name="ln2393">    }</a>
<a name="ln2394">    inf.setMinorVersion(version.minor);</a>
<a name="ln2395">    if (backup &amp;&amp; version &lt; save_version::current_bones())</a>
<a name="ln2396">        _backup_bones_for_upgrade(ghost_filename, version);</a>
<a name="ln2397"> </a>
<a name="ln2398">    try</a>
<a name="ln2399">    {</a>
<a name="ln2400">        result = tag_read_ghosts(inf);</a>
<a name="ln2401">        inf.fail_if_not_eof(ghost_filename);</a>
<a name="ln2402">    }</a>
<a name="ln2403">    catch (short_read_exception &amp;short_read)</a>
<a name="ln2404">    {</a>
<a name="ln2405">        string error = &quot;Broken bones file: &quot; + ghost_filename;</a>
<a name="ln2406">        throw corrupted_save(error, version);</a>
<a name="ln2407">    }</a>
<a name="ln2408">    inf.close();</a>
<a name="ln2409"> </a>
<a name="ln2410">    if (!debug_check_ghosts(result))</a>
<a name="ln2411">    {</a>
<a name="ln2412">        string error = &quot;Bones file is buggy: &quot; + ghost_filename;</a>
<a name="ln2413">        throw corrupted_save(error, version);</a>
<a name="ln2414">    }</a>
<a name="ln2415"> </a>
<a name="ln2416">    return result;</a>
<a name="ln2417">}</a>
<a name="ln2418"> </a>
<a name="ln2419"> </a>
<a name="ln2420">static vector&lt;ghost_demon&gt; _load_ghosts_core(string filename,</a>
<a name="ln2421">                                                        bool backup_on_upgrade)</a>
<a name="ln2422">{</a>
<a name="ln2423">    vector&lt;ghost_demon&gt; results;</a>
<a name="ln2424">    try</a>
<a name="ln2425">    {</a>
<a name="ln2426">        results = load_bones_file(filename, backup_on_upgrade);</a>
<a name="ln2427">    }</a>
<a name="ln2428">    catch (corrupted_save &amp;err)</a>
<a name="ln2429">    {</a>
<a name="ln2430">        // not a corrupted save per se, just from the future. Try to load the</a>
<a name="ln2431">        // versioned bones file if it exists.</a>
<a name="ln2432">        if (err.version.valid() &amp;&amp; err.version.is_future())</a>
<a name="ln2433">        {</a>
<a name="ln2434">            string old_bones =</a>
<a name="ln2435">                        _old_bones_filename(filename, save_version::current());</a>
<a name="ln2436">            if (old_bones != filename)</a>
<a name="ln2437">            {</a>
<a name="ln2438">                _ghost_dprf(&quot;Loading ghost from backup bones file %s&quot;,</a>
<a name="ln2439">                                                        old_bones.c_str());</a>
<a name="ln2440">                return load_bones_file(old_bones, false);</a>
<a name="ln2441">            }</a>
<a name="ln2442">            else</a>
<a name="ln2443">                mprf(MSGCH_ERROR, &quot;Mismatch between bones backup &quot;</a>
<a name="ln2444">                    &quot;filename '%s' and version %d.%d!&quot;, filename.c_str(),</a>
<a name="ln2445">                    err.version.major, err.version.minor);</a>
<a name="ln2446">            // intentional fallthrough -- unlink the misnamed file</a>
<a name="ln2447">        }</a>
<a name="ln2448">        else</a>
<a name="ln2449">            mprf(MSGCH_ERROR, &quot;%s&quot;, err.what());</a>
<a name="ln2450">        string report;</a>
<a name="ln2451">        // if we get to this point the bones file is unreadable and needs to</a>
<a name="ln2452">        // be scrapped</a>
<a name="ln2453">        if (unlink(filename.c_str()) != 0)</a>
<a name="ln2454">            report = &quot;Failed to unlink bad bones file&quot;;</a>
<a name="ln2455">        else</a>
<a name="ln2456">            report = &quot;Clearing bad bones file&quot;;</a>
<a name="ln2457">        mprf(MSGCH_ERROR, &quot;%s: %s&quot;, report.c_str(), filename.c_str());</a>
<a name="ln2458">    }</a>
<a name="ln2459">    return results;</a>
<a name="ln2460"> </a>
<a name="ln2461">}</a>
<a name="ln2462"> </a>
<a name="ln2463">static vector&lt;ghost_demon&gt; _load_ephemeral_ghosts()</a>
<a name="ln2464">{</a>
<a name="ln2465">    vector&lt;ghost_demon&gt; results;</a>
<a name="ln2466"> </a>
<a name="ln2467">    string ghost_filename = _find_ghost_file();</a>
<a name="ln2468">    if (ghost_filename.empty())</a>
<a name="ln2469">    {</a>
<a name="ln2470">        _ghost_dprf(&quot;%s&quot;, &quot;No ephemeral ghost files for this level.&quot;);</a>
<a name="ln2471">        return results; // no such ghost.</a>
<a name="ln2472">    }</a>
<a name="ln2473"> </a>
<a name="ln2474">    results = _load_ghosts_core(ghost_filename, true);</a>
<a name="ln2475"> </a>
<a name="ln2476">    if (unlink(ghost_filename.c_str()) != 0)</a>
<a name="ln2477">    {</a>
<a name="ln2478">        mprf(MSGCH_ERROR, &quot;Failed to unlink bones file: %s&quot;,</a>
<a name="ln2479">                ghost_filename.c_str());</a>
<a name="ln2480">    }</a>
<a name="ln2481">    return results;</a>
<a name="ln2482">}</a>
<a name="ln2483"> </a>
<a name="ln2484">static vector&lt;ghost_demon&gt; _load_permastore_ghosts(bool backup_on_upgrade=false)</a>
<a name="ln2485">{</a>
<a name="ln2486">    return _load_ghosts_core(_bones_permastore_file(), backup_on_upgrade);</a>
<a name="ln2487">}</a>
<a name="ln2488"> </a>
<a name="ln2489">/**</a>
<a name="ln2490"> * Attempt to fill in a monster based on bones files.</a>
<a name="ln2491"> *</a>
<a name="ln2492"> * @param mons the monster to fill in</a>
<a name="ln2493"> *</a>
<a name="ln2494"> * @return whether there was a saved ghost that could be used.</a>
<a name="ln2495"> */</a>
<a name="ln2496">bool define_ghost_from_bones(monster&amp; mons)</a>
<a name="ln2497">{</a>
<a name="ln2498">    rng::generator rng(rng::SYSTEM_SPECIFIC);</a>
<a name="ln2499"> </a>
<a name="ln2500">    bool used_permastore = false;</a>
<a name="ln2501"> </a>
<a name="ln2502">    vector&lt;ghost_demon&gt; loaded_ghosts = _load_ephemeral_ghosts();</a>
<a name="ln2503">    if (loaded_ghosts.empty())</a>
<a name="ln2504">    {</a>
<a name="ln2505">        loaded_ghosts = _load_permastore_ghosts();</a>
<a name="ln2506">        if (loaded_ghosts.empty())</a>
<a name="ln2507">            return false;</a>
<a name="ln2508">        used_permastore = true;</a>
<a name="ln2509">    }</a>
<a name="ln2510"> </a>
<a name="ln2511">    int place_i = random2(loaded_ghosts.size());</a>
<a name="ln2512">    _ghost_dprf(&quot;Loaded ghost file with %u ghost(s), placing %s&quot;,</a>
<a name="ln2513">         (unsigned int)loaded_ghosts.size(), loaded_ghosts[place_i].name.c_str());</a>
<a name="ln2514"> </a>
<a name="ln2515">    mons.set_ghost(loaded_ghosts[place_i]);</a>
<a name="ln2516">    mons.type = MONS_PLAYER_GHOST;</a>
<a name="ln2517">    mons.ghost_init(false);</a>
<a name="ln2518"> </a>
<a name="ln2519">    if (!mons.alive())</a>
<a name="ln2520">        mprf(MSGCH_ERROR, &quot;Placed ghost is not alive.&quot;);</a>
<a name="ln2521">    else if (mons.type != MONS_PLAYER_GHOST)</a>
<a name="ln2522">    {</a>
<a name="ln2523">        mprf(MSGCH_ERROR, &quot;Placed ghost is not MONS_PLAYER_GHOST, but %s&quot;,</a>
<a name="ln2524">             mons.name(DESC_PLAIN, true).c_str());</a>
<a name="ln2525">    }</a>
<a name="ln2526"> </a>
<a name="ln2527">    if (!used_permastore)</a>
<a name="ln2528">    {</a>
<a name="ln2529">        loaded_ghosts.erase(loaded_ghosts.begin() + place_i);</a>
<a name="ln2530"> </a>
<a name="ln2531">        if (!loaded_ghosts.empty())</a>
<a name="ln2532">            save_ghosts(loaded_ghosts);</a>
<a name="ln2533">    }</a>
<a name="ln2534">    return true;</a>
<a name="ln2535">}</a>
<a name="ln2536"> </a>
<a name="ln2537">/**</a>
<a name="ln2538"> * Attempt to load one or more ghosts into the level.</a>
<a name="ln2539"> *</a>
<a name="ln2540"> * @param max_ghosts        A maximum number of ghosts to creat.</a>
<a name="ln2541"> *                          Set to &lt;= 0 to load as many as possible.</a>
<a name="ln2542"> * @param creating_level    Whether a level is currently being generated.</a>
<a name="ln2543"> * @return                  Whether ghosts were actually generated.</a>
<a name="ln2544"> */</a>
<a name="ln2545">bool load_ghosts(int max_ghosts, bool creating_level)</a>
<a name="ln2546">{</a>
<a name="ln2547">    ASSERT(you.transit_stair == DNGN_UNSEEN || creating_level);</a>
<a name="ln2548">    ASSERT(!you.entering_level || creating_level);</a>
<a name="ln2549">    ASSERT(!creating_level</a>
<a name="ln2550">           || (you.entering_level &amp;&amp; you.transit_stair != DNGN_UNSEEN));</a>
<a name="ln2551">    // Only way to load a ghost without creating a level is via a wizard</a>
<a name="ln2552">    // command.</a>
<a name="ln2553">    ASSERT(creating_level || (crawl_state.prev_cmd == CMD_WIZARD));</a>
<a name="ln2554"> </a>
<a name="ln2555">#ifdef BONES_DIAGNOSTICS</a>
<a name="ln2556">    // this is pretty hacky, but arguably cleaner than what it is replacing.</a>
<a name="ln2557">    // The effect is to show bones diagnostic messages on wizmode builds during</a>
<a name="ln2558">    // level building</a>
<a name="ln2559">    unwind_var&lt;command_type&gt; last_cmd(crawl_state.prev_cmd, creating_level ?</a>
<a name="ln2560">        CMD_WIZARD : crawl_state.prev_cmd);</a>
<a name="ln2561">#endif</a>
<a name="ln2562"> </a>
<a name="ln2563">    vector&lt;ghost_demon&gt; loaded_ghosts = _load_ephemeral_ghosts();</a>
<a name="ln2564"> </a>
<a name="ln2565">    _ghost_dprf(&quot;Loaded ghost file with %u ghost(s), will attempt to place %d of them&quot;,</a>
<a name="ln2566">             (unsigned int)loaded_ghosts.size(), max_ghosts);</a>
<a name="ln2567"> </a>
<a name="ln2568">    bool ghost_errors = false;</a>
<a name="ln2569"> </a>
<a name="ln2570">    max_ghosts = max_ghosts &lt;= 0 ? loaded_ghosts.size()</a>
<a name="ln2571">                                 : min(max_ghosts, (int) loaded_ghosts.size());</a>
<a name="ln2572">    int placed_ghosts = 0;</a>
<a name="ln2573"> </a>
<a name="ln2574">    // Translate ghost to monster and place.</a>
<a name="ln2575">    while (!loaded_ghosts.empty() &amp;&amp; placed_ghosts &lt; max_ghosts)</a>
<a name="ln2576">    {</a>
<a name="ln2577">        monster * const mons = get_free_monster();</a>
<a name="ln2578">        if (!mons)</a>
<a name="ln2579">            break;</a>
<a name="ln2580"> </a>
<a name="ln2581">        mons-&gt;set_new_monster_id();</a>
<a name="ln2582">        mons-&gt;set_ghost(loaded_ghosts[0]);</a>
<a name="ln2583">        mons-&gt;type = MONS_PLAYER_GHOST;</a>
<a name="ln2584">        mons-&gt;ghost_init();</a>
<a name="ln2585"> </a>
<a name="ln2586">        loaded_ghosts.erase(loaded_ghosts.begin());</a>
<a name="ln2587">        placed_ghosts++;</a>
<a name="ln2588"> </a>
<a name="ln2589">        if (!mons-&gt;alive())</a>
<a name="ln2590">        {</a>
<a name="ln2591">            _ghost_dprf(&quot;Placed ghost is not alive.&quot;);</a>
<a name="ln2592">            ghost_errors = true;</a>
<a name="ln2593">        }</a>
<a name="ln2594">        else if (mons-&gt;type != MONS_PLAYER_GHOST)</a>
<a name="ln2595">        {</a>
<a name="ln2596">            _ghost_dprf(&quot;Placed ghost is not MONS_PLAYER_GHOST, but %s&quot;,</a>
<a name="ln2597">                 mons-&gt;name(DESC_PLAIN, true).c_str());</a>
<a name="ln2598">            ghost_errors = true;</a>
<a name="ln2599">        }</a>
<a name="ln2600">    }</a>
<a name="ln2601"> </a>
<a name="ln2602">    if (placed_ghosts &lt; max_ghosts)</a>
<a name="ln2603">    {</a>
<a name="ln2604">        _ghost_dprf(&quot;Unable to place %u ghost(s)&quot;, max_ghosts - placed_ghosts);</a>
<a name="ln2605">        ghost_errors = true;</a>
<a name="ln2606">    }</a>
<a name="ln2607">#ifdef BONES_DIAGNOSTICS</a>
<a name="ln2608">    if (ghost_errors)</a>
<a name="ln2609">        more();</a>
<a name="ln2610">#endif</a>
<a name="ln2611"> </a>
<a name="ln2612">    // resave any unused ghosts</a>
<a name="ln2613">    if (!loaded_ghosts.empty())</a>
<a name="ln2614">        save_ghosts(loaded_ghosts);</a>
<a name="ln2615"> </a>
<a name="ln2616">    return true;</a>
<a name="ln2617">}</a>
<a name="ln2618"> </a>
<a name="ln2619">static string _type_name_processed(game_type t)</a>
<a name="ln2620">{</a>
<a name="ln2621">    string name = game_state::game_type_name_for(t);</a>
<a name="ln2622">    return name.size() ? name : &quot;regular&quot;;</a>
<a name="ln2623">}</a>
<a name="ln2624"> </a>
<a name="ln2625">// returns false if a new game should start instead</a>
<a name="ln2626">static bool _restore_game(const string&amp; filename)</a>
<a name="ln2627">{</a>
<a name="ln2628">    if (Options.no_save)</a>
<a name="ln2629">        return false;</a>
<a name="ln2630"> </a>
<a name="ln2631">    // In webtiles, a more before the player is loaded will crash when it tries</a>
<a name="ln2632">    // to send enough information to the webtiles client to render the display.</a>
<a name="ln2633">    // This is just cosmetic for other build targets.</a>
<a name="ln2634">    unwind_bool save_more(crawl_state.show_more_prompt, false);</a>
<a name="ln2635">    game_type menu_game_type = crawl_state.type;</a>
<a name="ln2636"> </a>
<a name="ln2637">    clear_message_store();</a>
<a name="ln2638"> </a>
<a name="ln2639">    you.save = new package((_get_savefile_directory() + filename).c_str(), true);</a>
<a name="ln2640"> </a>
<a name="ln2641">    if (!_read_char_chunk(you.save))</a>
<a name="ln2642">    {</a>
<a name="ln2643">        // Note: if we are here, the save info was properly read, it would</a>
<a name="ln2644">        // raise an exception otherwise.</a>
<a name="ln2645">        if (yesno((&quot;There is an existing game for name '&quot; + you.your_name +</a>
<a name="ln2646">                   &quot;' from an incompatible version of Crawl (&quot;</a>
<a name="ln2647">                   + you.prev_save_version + &quot;).\n&quot;</a>
<a name="ln2648">                   &quot;Unless you reinstall that version, you can't load it.\n&quot;</a>
<a name="ln2649">                   &quot;Do you want to DELETE that game and start a new one?&quot;</a>
<a name="ln2650">                  ).c_str(),</a>
<a name="ln2651">                  true, 'n'))</a>
<a name="ln2652">        {</a>
<a name="ln2653">            you.save-&gt;unlink();</a>
<a name="ln2654">            you.save = 0;</a>
<a name="ln2655">            return false;</a>
<a name="ln2656">        }</a>
<a name="ln2657">        if (Options.remember_name)</a>
<a name="ln2658">            crawl_state.default_startup_name = you.your_name; // for main menu</a>
<a name="ln2659">        you.save-&gt;abort();</a>
<a name="ln2660">        delete you.save;</a>
<a name="ln2661">        you.save = 0;</a>
<a name="ln2662">        game_ended(game_exit::abort,</a>
<a name="ln2663">            you.your_name + &quot; is from an incompatible version and can't be loaded.&quot;);</a>
<a name="ln2664">    }</a>
<a name="ln2665"> </a>
<a name="ln2666">    if (!crawl_state.bypassed_startup_menu</a>
<a name="ln2667">        &amp;&amp; menu_game_type != crawl_state.type)</a>
<a name="ln2668">    {</a>
<a name="ln2669">        if (!yesno((&quot;You already have a &quot;</a>
<a name="ln2670">                        + _type_name_processed(crawl_state.type) +</a>
<a name="ln2671">                    &quot; game saved under the name '&quot; + you.your_name + &quot;';\n&quot;</a>
<a name="ln2672">                    &quot;do you want to load that instead?&quot;).c_str(),</a>
<a name="ln2673">                   true, 'n'))</a>
<a name="ln2674">        {</a>
<a name="ln2675">            you.save-&gt;abort(); // don't even rewrite the header</a>
<a name="ln2676">            delete you.save;</a>
<a name="ln2677">            you.save = 0;</a>
<a name="ln2678">            game_ended(game_exit::abort,</a>
<a name="ln2679">                &quot;Please use a different name to start a new &quot; +</a>
<a name="ln2680">                _type_name_processed(menu_game_type) + &quot; game, then.&quot;);</a>
<a name="ln2681">        }</a>
<a name="ln2682">    }</a>
<a name="ln2683"> </a>
<a name="ln2684">    if (Options.remember_name)</a>
<a name="ln2685">        crawl_state.default_startup_name = you.your_name; // for main menu</a>
<a name="ln2686"> </a>
<a name="ln2687">    if (numcmp(you.prev_save_version.c_str(), Version::Long, 2) == -1</a>
<a name="ln2688">        &amp;&amp; version_is_stable(you.prev_save_version.c_str()))</a>
<a name="ln2689">    {</a>
<a name="ln2690">        if (!yesno((&quot;This game comes from a previous release of Crawl (&quot; +</a>
<a name="ln2691">                    you.prev_save_version + &quot;).\n\nIf you load it now,&quot;</a>
<a name="ln2692">                    &quot; you won't be able to go back. Continue?&quot;).c_str(),</a>
<a name="ln2693">                    true, 'n'))</a>
<a name="ln2694">        {</a>
<a name="ln2695">            you.save-&gt;abort(); // don't even rewrite the header</a>
<a name="ln2696">            delete you.save;</a>
<a name="ln2697">            you.save = 0;</a>
<a name="ln2698">            game_ended(game_exit::abort, &quot;Please use version &quot; +</a>
<a name="ln2699">                you.prev_save_version + &quot; to load &quot; + you.your_name + &quot; then.&quot;);</a>
<a name="ln2700">        }</a>
<a name="ln2701">    }</a>
<a name="ln2702"> </a>
<a name="ln2703">    _restore_tagged_chunk(you.save, &quot;you&quot;, TAG_YOU, &quot;Save data is invalid.&quot;);</a>
<a name="ln2704"> </a>
<a name="ln2705">    _convert_obsolete_species();</a>
<a name="ln2706"> </a>
<a name="ln2707">    const int minorVersion = crawl_state.minor_version;</a>
<a name="ln2708"> </a>
<a name="ln2709">    if (you.save-&gt;has_chunk(CHUNK(&quot;st&quot;, &quot;stashes&quot;)))</a>
<a name="ln2710">    {</a>
<a name="ln2711">        reader inf(you.save, CHUNK(&quot;st&quot;, &quot;stashes&quot;), minorVersion);</a>
<a name="ln2712">        StashTrack.load(inf);</a>
<a name="ln2713">    }</a>
<a name="ln2714"> </a>
<a name="ln2715">#ifdef CLUA_BINDINGS</a>
<a name="ln2716">    if (you.save-&gt;has_chunk(&quot;lua&quot;))</a>
<a name="ln2717">    {</a>
<a name="ln2718">        vector&lt;char&gt; buf;</a>
<a name="ln2719">        chunk_reader inf(you.save, &quot;lua&quot;);</a>
<a name="ln2720">        inf.read_all(buf);</a>
<a name="ln2721">        buf.push_back(0);</a>
<a name="ln2722">        clua.execstring(&amp;buf[0]);</a>
<a name="ln2723">    }</a>
<a name="ln2724">#endif</a>
<a name="ln2725"> </a>
<a name="ln2726">    if (you.save-&gt;has_chunk(CHUNK(&quot;kil&quot;, &quot;kills&quot;)))</a>
<a name="ln2727">    {</a>
<a name="ln2728">        reader inf(you.save, CHUNK(&quot;kil&quot;, &quot;kills&quot;),minorVersion);</a>
<a name="ln2729">        you.kills.load(inf);</a>
<a name="ln2730">    }</a>
<a name="ln2731"> </a>
<a name="ln2732">    if (you.save-&gt;has_chunk(CHUNK(&quot;tc&quot;, &quot;travel_cache&quot;)))</a>
<a name="ln2733">    {</a>
<a name="ln2734">        reader inf(you.save, CHUNK(&quot;tc&quot;, &quot;travel_cache&quot;), minorVersion);</a>
<a name="ln2735">        travel_cache.load(inf, minorVersion);</a>
<a name="ln2736">    }</a>
<a name="ln2737"> </a>
<a name="ln2738">    if (you.save-&gt;has_chunk(CHUNK(&quot;nts&quot;, &quot;notes&quot;)))</a>
<a name="ln2739">    {</a>
<a name="ln2740">        reader inf(you.save, CHUNK(&quot;nts&quot;, &quot;notes&quot;), minorVersion);</a>
<a name="ln2741">        load_notes(inf);</a>
<a name="ln2742">    }</a>
<a name="ln2743"> </a>
<a name="ln2744">    /* hints mode */</a>
<a name="ln2745">    if (you.save-&gt;has_chunk(CHUNK(&quot;tut&quot;, &quot;tutorial&quot;)))</a>
<a name="ln2746">    {</a>
<a name="ln2747">        reader inf(you.save, CHUNK(&quot;tut&quot;, &quot;tutorial&quot;), minorVersion);</a>
<a name="ln2748">        load_hints(inf);</a>
<a name="ln2749">    }</a>
<a name="ln2750"> </a>
<a name="ln2751">    /* messages */</a>
<a name="ln2752">    if (you.save-&gt;has_chunk(CHUNK(&quot;msg&quot;, &quot;messages&quot;)))</a>
<a name="ln2753">    {</a>
<a name="ln2754">        reader inf(you.save, CHUNK(&quot;msg&quot;, &quot;messages&quot;), minorVersion);</a>
<a name="ln2755">        load_messages(inf);</a>
<a name="ln2756">    }</a>
<a name="ln2757"> </a>
<a name="ln2758">    return true;</a>
<a name="ln2759">}</a>
<a name="ln2760"> </a>
<a name="ln2761">// returns false if a new game should start instead</a>
<a name="ln2762">bool restore_game(const string&amp; filename)</a>
<a name="ln2763">{</a>
<a name="ln2764">    try</a>
<a name="ln2765">    {</a>
<a name="ln2766">        return _restore_game(filename);</a>
<a name="ln2767">    }</a>
<a name="ln2768">    catch (corrupted_save &amp;err)</a>
<a name="ln2769">    {</a>
<a name="ln2770">        if (yesno(make_stringf(</a>
<a name="ln2771">                   &quot;There exists a save by that name but it appears to be invalid.\n&quot;</a>
<a name="ln2772">                   &quot;Do you want to delete it?\n&quot;</a>
<a name="ln2773">                   &quot;Error: %s&quot;, err.what()).c_str(), // TODO linebreak error</a>
<a name="ln2774">                  true, 'n'))</a>
<a name="ln2775">        {</a>
<a name="ln2776">            if (you.save)</a>
<a name="ln2777">                you.save-&gt;unlink();</a>
<a name="ln2778">            you.save = 0;</a>
<a name="ln2779">            return false;</a>
<a name="ln2780">        }</a>
<a name="ln2781">        // Shouldn't crash probably...</a>
<a name="ln2782">        fail(&quot;Aborting; you may try to recover it somehow.&quot;);</a>
<a name="ln2783">    }</a>
<a name="ln2784">}</a>
<a name="ln2785"> </a>
<a name="ln2786">static void _load_level(const level_id &amp;level)</a>
<a name="ln2787">{</a>
<a name="ln2788">    // Load the given level.</a>
<a name="ln2789">    you.where_are_you = level.branch;</a>
<a name="ln2790">    you.depth =         level.depth;</a>
<a name="ln2791"> </a>
<a name="ln2792">    load_level(DNGN_STONE_STAIRS_DOWN_I, LOAD_VISITOR, level_id());</a>
<a name="ln2793">}</a>
<a name="ln2794"> </a>
<a name="ln2795">// Given a level returns true if the level has been created already</a>
<a name="ln2796">// in this game. Warning: after a game has ended, there is a phase where the</a>
<a name="ln2797">// save has been deleted and this check isn't usable, and this is when a moruge</a>
<a name="ln2798">// is generated.</a>
<a name="ln2799">bool is_existing_level(const level_id &amp;level)</a>
<a name="ln2800">{</a>
<a name="ln2801">    return you.save &amp;&amp; you.save-&gt;has_chunk(level.describe());</a>
<a name="ln2802">}</a>
<a name="ln2803"> </a>
<a name="ln2804">void delete_level(const level_id &amp;level)</a>
<a name="ln2805">{</a>
<a name="ln2806">    travel_cache.erase_level_info(level);</a>
<a name="ln2807">    StashTrack.remove_level(level);</a>
<a name="ln2808">    shopping_list.del_things_from(level);</a>
<a name="ln2809"> </a>
<a name="ln2810">    clear_level_exclusion_annotation(level);</a>
<a name="ln2811">    clear_level_annotations(level);</a>
<a name="ln2812"> </a>
<a name="ln2813">    if (you.save)</a>
<a name="ln2814">        you.save-&gt;delete_chunk(level.describe());</a>
<a name="ln2815"> </a>
<a name="ln2816">    auto &amp;visited = you.props[VISITED_LEVELS_KEY].get_table();</a>
<a name="ln2817">    visited.erase(level.describe());</a>
<a name="ln2818"> </a>
<a name="ln2819">    if (level.branch == BRANCH_ABYSS)</a>
<a name="ln2820">    {</a>
<a name="ln2821">        save_abyss_uniques();</a>
<a name="ln2822">        destroy_abyss();</a>
<a name="ln2823">    }</a>
<a name="ln2824">    _do_lost_monsters();</a>
<a name="ln2825">    _do_lost_items();</a>
<a name="ln2826">}</a>
<a name="ln2827"> </a>
<a name="ln2828">// This class provides a way to walk the dungeon with a bit more flexibility</a>
<a name="ln2829">// than you used to get with apply_to_all_dungeons.</a>
<a name="ln2830">level_excursion::level_excursion()</a>
<a name="ln2831">    : original(level_id::current()), ever_changed_levels(false)</a>
<a name="ln2832">{</a>
<a name="ln2833">}</a>
<a name="ln2834"> </a>
<a name="ln2835">void level_excursion::go_to(const level_id&amp; next)</a>
<a name="ln2836">{</a>
<a name="ln2837">    if (level_id::current() != next)</a>
<a name="ln2838">    {</a>
<a name="ln2839">        if (!you.level_visited(level_id::current()))</a>
<a name="ln2840">            travel_cache.erase_level_info(level_id::current());</a>
<a name="ln2841"> </a>
<a name="ln2842">        ever_changed_levels = true;</a>
<a name="ln2843"> </a>
<a name="ln2844">        _save_level(level_id::current());</a>
<a name="ln2845">        _load_level(next);</a>
<a name="ln2846"> </a>
<a name="ln2847">        if (you.level_visited(next))</a>
<a name="ln2848">        {</a>
<a name="ln2849">            LevelInfo &amp;li = travel_cache.get_level_info(next);</a>
<a name="ln2850">            li.set_level_excludes();</a>
<a name="ln2851">        }</a>
<a name="ln2852">        // TODO: this won't clear excludes on an excursion to an unvisited</a>
<a name="ln2853">        // level. Does this matter? Not right now, this case is only used for</a>
<a name="ln2854">        // abyss procgen.</a>
<a name="ln2855">    }</a>
<a name="ln2856"> </a>
<a name="ln2857">    you.on_current_level = (level_id::current() == original);</a>
<a name="ln2858">}</a>
<a name="ln2859"> </a>
<a name="ln2860">level_excursion::~level_excursion()</a>
<a name="ln2861">{</a>
<a name="ln2862">    // Go back to original level and reactivate markers if we ever</a>
<a name="ln2863">    // left the level.</a>
<a name="ln2864">    if (ever_changed_levels)</a>
<a name="ln2865">    {</a>
<a name="ln2866">        // This may be a no-op if the level-excursion subsequently</a>
<a name="ln2867">        // returned to the original level. However, at this point</a>
<a name="ln2868">        // markers will still not be activated.</a>
<a name="ln2869">        go_to(original);</a>
<a name="ln2870"> </a>
<a name="ln2871">        // Quietly reactivate markers.</a>
<a name="ln2872">        env.markers.activate_all(false);</a>
<a name="ln2873">    }</a>
<a name="ln2874">}</a>
<a name="ln2875"> </a>
<a name="ln2876">save_version get_save_version(reader &amp;file)</a>
<a name="ln2877">{</a>
<a name="ln2878">    int major, minor;</a>
<a name="ln2879">    try</a>
<a name="ln2880">    {</a>
<a name="ln2881">        major = unmarshallUByte(file);</a>
<a name="ln2882">        minor = unmarshallUByte(file);</a>
<a name="ln2883">        if (minor == UINT8_MAX)</a>
<a name="ln2884">            minor = unmarshallInt(file);</a>
<a name="ln2885">    }</a>
<a name="ln2886">    catch (short_read_exception&amp; E)</a>
<a name="ln2887">    {</a>
<a name="ln2888">        // Empty file?</a>
<a name="ln2889">        return save_version(-1, -1);</a>
<a name="ln2890">    }</a>
<a name="ln2891">    return save_version(major, minor);</a>
<a name="ln2892">}</a>
<a name="ln2893"> </a>
<a name="ln2894">void write_save_version(writer &amp;outf, save_version version)</a>
<a name="ln2895">{</a>
<a name="ln2896">    marshallUByte(outf, version.major);</a>
<a name="ln2897">    if (version.minor &lt; UINT8_MAX)</a>
<a name="ln2898">        marshallUByte(outf, version.minor);</a>
<a name="ln2899">    else</a>
<a name="ln2900">    {</a>
<a name="ln2901">        marshallUByte(outf, UINT8_MAX);</a>
<a name="ln2902">        marshallInt(outf, version.minor);</a>
<a name="ln2903">    }</a>
<a name="ln2904">}</a>
<a name="ln2905"> </a>
<a name="ln2906">static bool _convert_obsolete_species()</a>
<a name="ln2907">{</a>
<a name="ln2908">    // At this point the character has been loaded but not resaved, but the grid, lua, stashes, etc have not been.</a>
<a name="ln2909">#if TAG_MAJOR_VERSION == 34</a>
<a name="ln2910">    if (you.species == SP_LAVA_ORC)</a>
<a name="ln2911">    {</a>
<a name="ln2912">        if (!yes_or_no(&quot;This &lt;red&gt;Lava Orc&lt;/red&gt; save game cannot be loaded as-is. If you &quot;</a>
<a name="ln2913">                       &quot;load it now, your character will be converted to a Hill Orc. Continue?&quot;))</a>
<a name="ln2914">        {</a>
<a name="ln2915">            you.save-&gt;abort(); // don't even rewrite the header</a>
<a name="ln2916">            delete you.save;</a>
<a name="ln2917">            you.save = 0;</a>
<a name="ln2918">            game_ended(game_exit::abort,</a>
<a name="ln2919">                &quot;Please load the save in an earlier version &quot;</a>
<a name="ln2920">                &quot;if you want to keep it as a Lava Orc.&quot;);</a>
<a name="ln2921">        }</a>
<a name="ln2922">        change_species_to(SP_HILL_ORC);</a>
<a name="ln2923">        // No need for conservation</a>
<a name="ln2924">        you.innate_mutation[MUT_CONSERVE_SCROLLS] = you.mutation[MUT_CONSERVE_SCROLLS] = 0;</a>
<a name="ln2925">        // This is not an elegant way to deal with lava, but at this point the</a>
<a name="ln2926">        // level isn't loaded so we can't check the grid features. In</a>
<a name="ln2927">        // addition, even if the player isn't over lava, they might still get</a>
<a name="ln2928">        // trapped.</a>
<a name="ln2929">        fly_player(100);</a>
<a name="ln2930">        return true;</a>
<a name="ln2931">    }</a>
<a name="ln2932">    if (you.species == SP_DJINNI)</a>
<a name="ln2933">    {</a>
<a name="ln2934">        if (!yes_or_no(&quot;This &lt;red&gt;Djinni&lt;/red&gt; save game cannot be loaded as-is. If you &quot;</a>
<a name="ln2935">                       &quot;load it now, your character will be converted to a Vine Stalker. Continue?&quot;))</a>
<a name="ln2936">        {</a>
<a name="ln2937">            you.save-&gt;abort(); // don't even rewrite the header</a>
<a name="ln2938">            delete you.save;</a>
<a name="ln2939">            you.save = 0;</a>
<a name="ln2940">            game_ended(game_exit::abort,</a>
<a name="ln2941">                &quot;Please load the save in an earlier version &quot;</a>
<a name="ln2942">                &quot;if you want to keep it as a Djinni.&quot;);</a>
<a name="ln2943">        }</a>
<a name="ln2944">        change_species_to(SP_VINE_STALKER);</a>
<a name="ln2945">        you.magic_contamination = 0;</a>
<a name="ln2946">        // Djinni were flying, so give the player some time to land</a>
<a name="ln2947">        fly_player(100);</a>
<a name="ln2948">        // Give them some time to find food. Creating food isn't safe as the grid doesn't exist yet, and may have water anyways.</a>
<a name="ln2949">        you.hunger = HUNGER_MAXIMUM;</a>
<a name="ln2950">        return true;</a>
<a name="ln2951">    }</a>
<a name="ln2952">#endif</a>
<a name="ln2953">    return false;</a>
<a name="ln2954">}</a>
<a name="ln2955"> </a>
<a name="ln2956">static bool _read_char_chunk(package *save)</a>
<a name="ln2957">{</a>
<a name="ln2958">    reader inf(save, &quot;chr&quot;);</a>
<a name="ln2959"> </a>
<a name="ln2960">    try</a>
<a name="ln2961">    {</a>
<a name="ln2962">        const auto version = get_save_version(inf);</a>
<a name="ln2963">        const auto major = version.major, minor = version.minor;</a>
<a name="ln2964">        uint8_t format;</a>
<a name="ln2965"> </a>
<a name="ln2966">        unsigned int len = unmarshallInt(inf);</a>
<a name="ln2967">        if (len &gt; 1024) // something is fishy</a>
<a name="ln2968">            fail(&quot;Save file corrupted (info &gt; 1KB)&quot;);</a>
<a name="ln2969">        vector&lt;unsigned char&gt; buf;</a>
<a name="ln2970">        buf.resize(len);</a>
<a name="ln2971">        inf.read(&amp;buf[0], len);</a>
<a name="ln2972">        inf.fail_if_not_eof(&quot;chr&quot;);</a>
<a name="ln2973">        reader th(buf);</a>
<a name="ln2974"> </a>
<a name="ln2975">        // 0.8 trunks (30.0 .. 32.12) were format 0 but without the marker.</a>
<a name="ln2976">        if (major &gt; 32 || major == 32 &amp;&amp; minor &gt;= 13)</a>
<a name="ln2977">            th.read(&amp;format, 1);</a>
<a name="ln2978">        else</a>
<a name="ln2979">            format = 0;</a>
<a name="ln2980"> </a>
<a name="ln2981">        if (format &gt; TAG_CHR_FORMAT)</a>
<a name="ln2982">            fail(&quot;Incompatible character data&quot;);</a>
<a name="ln2983"> </a>
<a name="ln2984">        tag_read_char(th, format, major, minor);</a>
<a name="ln2985"> </a>
<a name="ln2986">        // Check if we read everything only on the exact same version,</a>
<a name="ln2987">        // but that's the common case.</a>
<a name="ln2988">        if (major == TAG_MAJOR_VERSION &amp;&amp; minor == TAG_MINOR_VERSION)</a>
<a name="ln2989">            inf.fail_if_not_eof(&quot;chr&quot;);</a>
<a name="ln2990"> </a>
<a name="ln2991">#if TAG_MAJOR_VERSION == 34</a>
<a name="ln2992">        if (major == 33 &amp;&amp; minor == TAG_MINOR_0_11)</a>
<a name="ln2993">            return true;</a>
<a name="ln2994">#endif</a>
<a name="ln2995">        return major == TAG_MAJOR_VERSION &amp;&amp; minor &lt;= TAG_MINOR_VERSION;</a>
<a name="ln2996">    }</a>
<a name="ln2997">    catch (short_read_exception &amp;E)</a>
<a name="ln2998">    {</a>
<a name="ln2999">        fail(&quot;Save file corrupted&quot;);</a>
<a name="ln3000">    };</a>
<a name="ln3001">}</a>
<a name="ln3002"> </a>
<a name="ln3003">static bool _tagged_chunk_version_compatible(reader &amp;inf, string* reason)</a>
<a name="ln3004">{</a>
<a name="ln3005">    ASSERT(reason);</a>
<a name="ln3006"> </a>
<a name="ln3007">    const save_version version = get_save_version(inf);</a>
<a name="ln3008"> </a>
<a name="ln3009">    if (!version.valid())</a>
<a name="ln3010">    {</a>
<a name="ln3011">        *reason = make_stringf(&quot;File is corrupt (found version %d,%d).&quot;,</a>
<a name="ln3012">                                version.major, version.minor);</a>
<a name="ln3013">        return false;</a>
<a name="ln3014">    }</a>
<a name="ln3015"> </a>
<a name="ln3016">    if (!version.is_compatible())</a>
<a name="ln3017">    {</a>
<a name="ln3018">        if (version.is_ancient())</a>
<a name="ln3019">        {</a>
<a name="ln3020">            const auto min_supported = save_version::minimum_supported();</a>
<a name="ln3021">            *reason = make_stringf(&quot;This save is from an older version.\n&quot;</a>
<a name="ln3022">                    &quot;\n&quot;</a>
<a name="ln3023">                    CRAWL &quot; %s is not compatible with save files this old. You can:\n&quot;</a>
<a name="ln3024">                    &quot; • continue your game with an older version of &quot; CRAWL &quot;\n&quot;</a>
<a name="ln3025">                    &quot; • delete it and start a new game\n&quot;</a>
<a name="ln3026">                    &quot;\n&quot;</a>
<a name="ln3027">                    &quot;This save's version: (%d.%d) (must be &gt;= %d.%d)&quot;,</a>
<a name="ln3028">                    Version::Short,</a>
<a name="ln3029">                    version.major, version.minor,</a>
<a name="ln3030">                    min_supported.major, min_supported.minor);</a>
<a name="ln3031">        }</a>
<a name="ln3032">        else if (version.is_future())</a>
<a name="ln3033">        {</a>
<a name="ln3034">            const auto current = save_version::current();</a>
<a name="ln3035">            *reason = make_stringf(&quot;This save is from a newer version.\n&quot;</a>
<a name="ln3036">                    &quot;\n&quot;</a>
<a name="ln3037">                    CRAWL &quot; cannot load saves from newer versions. You can:\n&quot;</a>
<a name="ln3038">                    &quot; • continue your game with a newer version of &quot; CRAWL &quot;\n&quot;</a>
<a name="ln3039">                    &quot; • delete it and start a new game\n&quot;</a>
<a name="ln3040">                    &quot;\n&quot;</a>
<a name="ln3041">                    &quot;This save's version: (%d.%d) (must be &lt;= %d.%d)&quot;,</a>
<a name="ln3042">                    version.major, version.minor,</a>
<a name="ln3043">                    current.major, current.minor);</a>
<a name="ln3044">        }</a>
<a name="ln3045">        return false;</a>
<a name="ln3046">    }</a>
<a name="ln3047"> </a>
<a name="ln3048">    inf.setMinorVersion(version.minor);</a>
<a name="ln3049">    return true;</a>
<a name="ln3050">}</a>
<a name="ln3051"> </a>
<a name="ln3052">static bool _restore_tagged_chunk(package *save, const string &amp;name,</a>
<a name="ln3053">                                  tag_type tag, const char* complaint)</a>
<a name="ln3054">{</a>
<a name="ln3055">    reader inf(save, name);</a>
<a name="ln3056">    string reason;</a>
<a name="ln3057">    if (!_tagged_chunk_version_compatible(inf, &amp;reason))</a>
<a name="ln3058">    {</a>
<a name="ln3059">        if (!complaint)</a>
<a name="ln3060">        {</a>
<a name="ln3061">            dprf(&quot;chunk %s: %s&quot;, name.c_str(), reason.c_str());</a>
<a name="ln3062">            return false;</a>
<a name="ln3063">        }</a>
<a name="ln3064">        else</a>
<a name="ln3065">            end(-1, false, &quot;\n%s %s\n&quot;, complaint, reason.c_str());</a>
<a name="ln3066">    }</a>
<a name="ln3067"> </a>
<a name="ln3068">    crawl_state.minor_version = inf.getMinorVersion();</a>
<a name="ln3069">    try</a>
<a name="ln3070">    {</a>
<a name="ln3071">        tag_read(inf, tag);</a>
<a name="ln3072">    }</a>
<a name="ln3073">    catch (short_read_exception &amp;E)</a>
<a name="ln3074">    {</a>
<a name="ln3075">        fail(&quot;truncated save chunk (%s)&quot;, name.c_str());</a>
<a name="ln3076">    };</a>
<a name="ln3077"> </a>
<a name="ln3078">    inf.fail_if_not_eof(name);</a>
<a name="ln3079">    return true;</a>
<a name="ln3080">}</a>
<a name="ln3081"> </a>
<a name="ln3082">static bool _ghost_version_compatible(const save_version &amp;version)</a>
<a name="ln3083">{</a>
<a name="ln3084">    if (!version.valid())</a>
<a name="ln3085">        return false;</a>
<a name="ln3086">    if (!version.is_compatible())</a>
<a name="ln3087">    {</a>
<a name="ln3088">        _ghost_dprf(&quot;Ghost version mismatch: ghost was %d.%d; current is %d.%d&quot;,</a>
<a name="ln3089">             version.major, version.minor,</a>
<a name="ln3090">             save_version::current().major, save_version::current().minor);</a>
<a name="ln3091">        return false;</a>
<a name="ln3092">    }</a>
<a name="ln3093">    return true;</a>
<a name="ln3094">}</a>
<a name="ln3095"> </a>
<a name="ln3096">/**</a>
<a name="ln3097"> * Attempt to open a new bones file for saving ghosts.</a>
<a name="ln3098"> *</a>
<a name="ln3099"> * @param[out] return_gfilename     The name of the file created, if any.</a>
<a name="ln3100"> * @return                          A FILE object, or nullptr.</a>
<a name="ln3101"> **/</a>
<a name="ln3102">static FILE* _make_bones_file(string * return_gfilename)</a>
<a name="ln3103">{</a>
<a name="ln3104">    const string bone_dir = _get_bonefile_directory();</a>
<a name="ln3105">    const string base_filename = _make_ghost_filename(false);</a>
<a name="ln3106"> </a>
<a name="ln3107">    for (int i = 0; i &lt; GHOST_LIMIT; i++)</a>
<a name="ln3108">    {</a>
<a name="ln3109">        const string g_file_name = make_stringf(&quot;%s%s_%d&quot;, bone_dir.c_str(),</a>
<a name="ln3110">                                                base_filename.c_str(), i);</a>
<a name="ln3111">        FILE *ghost_file = lk_open_exclusive(g_file_name);</a>
<a name="ln3112">        // need to check file size, so can't open 'wb' - would truncate!</a>
<a name="ln3113"> </a>
<a name="ln3114">        if (!ghost_file)</a>
<a name="ln3115">        {</a>
<a name="ln3116">            dprf(&quot;Could not open %s&quot;, g_file_name.c_str());</a>
<a name="ln3117">            continue;</a>
<a name="ln3118">        }</a>
<a name="ln3119"> </a>
<a name="ln3120">        dprf(&quot;found %s&quot;, g_file_name.c_str());</a>
<a name="ln3121"> </a>
<a name="ln3122">        *return_gfilename = g_file_name;</a>
<a name="ln3123">        return ghost_file;</a>
<a name="ln3124">    }</a>
<a name="ln3125"> </a>
<a name="ln3126">    return nullptr;</a>
<a name="ln3127">}</a>
<a name="ln3128"> </a>
<a name="ln3129">#define GHOST_PERMASTORE_SIZE 10</a>
<a name="ln3130">#define GHOST_PERMASTORE_REPLACE_CHANCE 5</a>
<a name="ln3131"> </a>
<a name="ln3132">static size_t _ghost_permastore_size()</a>
<a name="ln3133">{</a>
<a name="ln3134">    if (_bones_save_individual_levels(true))</a>
<a name="ln3135">        return GHOST_PERMASTORE_SIZE;</a>
<a name="ln3136">    else</a>
<a name="ln3137">        return GHOST_PERMASTORE_SIZE * 2;</a>
<a name="ln3138">}</a>
<a name="ln3139"> </a>
<a name="ln3140">static vector&lt;ghost_demon&gt; _update_permastore(const vector&lt;ghost_demon&gt; &amp;ghosts)</a>
<a name="ln3141">{</a>
<a name="ln3142">    rng::generator rng(rng::SYSTEM_SPECIFIC);</a>
<a name="ln3143">    if (ghosts.empty())</a>
<a name="ln3144">        return ghosts;</a>
<a name="ln3145"> </a>
<a name="ln3146">    // this read is not locked...</a>
<a name="ln3147">    vector&lt;ghost_demon&gt; permastore = _load_permastore_ghosts();</a>
<a name="ln3148">    vector&lt;ghost_demon&gt; leftovers;</a>
<a name="ln3149"> </a>
<a name="ln3150">    bool rewrite = false;</a>
<a name="ln3151">    unsigned int i = 0;</a>
<a name="ln3152">    const size_t max_ghosts = _ghost_permastore_size();</a>
<a name="ln3153">    while (permastore.size() &lt; max_ghosts &amp;&amp; i &lt; ghosts.size())</a>
<a name="ln3154">    {</a>
<a name="ln3155">        // TODO: heuristics to make this as distinct as possible; maybe</a>
<a name="ln3156">        // create a new name?</a>
<a name="ln3157">        permastore.push_back(ghosts[i]);</a>
<a name="ln3158">#ifdef DGAMELAUNCH</a>
<a name="ln3159">        // randomize name for online play</a>
<a name="ln3160">        permastore.back().name = make_name();</a>
<a name="ln3161">#endif</a>
<a name="ln3162">        i++;</a>
<a name="ln3163">        rewrite = true;</a>
<a name="ln3164">    }</a>
<a name="ln3165">    if (i &gt; 0)</a>
<a name="ln3166">        _ghost_dprf(&quot;Permastoring %d ghosts&quot;, i);</a>
<a name="ln3167">    if (!rewrite &amp;&amp; x_chance_in_y(GHOST_PERMASTORE_REPLACE_CHANCE, 100)</a>
<a name="ln3168">                                                        &amp;&amp; i &lt; ghosts.size())</a>
<a name="ln3169">    {</a>
<a name="ln3170">        int rewrite_i = random2(permastore.size());</a>
<a name="ln3171">        permastore[rewrite_i] = ghosts[i];</a>
<a name="ln3172">#ifdef DGAMELAUNCH</a>
<a name="ln3173">        permastore[rewrite_i].name = make_name();</a>
<a name="ln3174">#endif</a>
<a name="ln3175">        rewrite = true;</a>
<a name="ln3176">    }</a>
<a name="ln3177">    while (i &lt; ghosts.size())</a>
<a name="ln3178">    {</a>
<a name="ln3179">        leftovers.push_back(ghosts[i]);</a>
<a name="ln3180">        i++;</a>
<a name="ln3181">    }</a>
<a name="ln3182"> </a>
<a name="ln3183">    if (rewrite)</a>
<a name="ln3184">    {</a>
<a name="ln3185">        string permastore_file = _bones_permastore_file();</a>
<a name="ln3186"> </a>
<a name="ln3187">        // the following is to ensure that an old game doesn't overwrite a</a>
<a name="ln3188">        // permastore that has a version in the future relative to that game.</a>
<a name="ln3189">        {</a>
<a name="ln3190">            reader inf(permastore_file);</a>
<a name="ln3191">            if (inf.valid())</a>
<a name="ln3192">            {</a>
<a name="ln3193">                inf.set_safe_read(true); // don't die on 0-byte bones</a>
<a name="ln3194">                save_version version = read_ghost_header(inf);</a>
<a name="ln3195">                if (version.valid() &amp;&amp; version.is_future())</a>
<a name="ln3196">                {</a>
<a name="ln3197">                    permastore_file = _old_bones_filename(permastore_file,</a>
<a name="ln3198">                                                    save_version::current());</a>
<a name="ln3199">                }</a>
<a name="ln3200">                inf.close();</a>
<a name="ln3201">            }</a>
<a name="ln3202">        }</a>
<a name="ln3203"> </a>
<a name="ln3204">        FILE *ghost_file = lk_open(&quot;wb&quot;, permastore_file);</a>
<a name="ln3205"> </a>
<a name="ln3206">        if (!ghost_file)</a>
<a name="ln3207">        {</a>
<a name="ln3208">            // this will fail silently if the lock fails, seems safest</a>
<a name="ln3209">            // TODO: better lock system for servers?</a>
<a name="ln3210">            _ghost_dprf(&quot;Could not open ghost permastore: %s&quot;,</a>
<a name="ln3211">                                                    permastore_file.c_str());</a>
<a name="ln3212">            return ghosts;</a>
<a name="ln3213">        }</a>
<a name="ln3214"> </a>
<a name="ln3215">        _ghost_dprf(&quot;Rewriting ghost permastore %s with %u ghosts&quot;,</a>
<a name="ln3216">                    permastore_file.c_str(), (unsigned int) permastore.size());</a>
<a name="ln3217">        writer outw(permastore_file, ghost_file);</a>
<a name="ln3218">        write_ghost_version(outw);</a>
<a name="ln3219">        tag_write_ghosts(outw, permastore);</a>
<a name="ln3220"> </a>
<a name="ln3221">        lk_close(ghost_file);</a>
<a name="ln3222">    }</a>
<a name="ln3223">    return leftovers;</a>
<a name="ln3224">}</a>
<a name="ln3225"> </a>
<a name="ln3226">/**</a>
<a name="ln3227"> * Attempt to save all ghosts from the current level.</a>
<a name="ln3228"> *</a>
<a name="ln3229"> * Including the player, if they're not undead. Doesn't save ghosts from D:1-2</a>
<a name="ln3230"> * or Temple.</a>
<a name="ln3231"> *</a>
<a name="ln3232"> * @param force   Forces ghost generation even in otherwise-disallowed levels.</a>
<a name="ln3233"> **/</a>
<a name="ln3234">void save_ghosts(const vector&lt;ghost_demon&gt; &amp;ghosts, bool force, bool use_store)</a>
<a name="ln3235">{</a>
<a name="ln3236">    // n.b. this is not called in the normal course of events for wizmode</a>
<a name="ln3237">    // chars, so for debugging anything to do with deaths in wizmode, you will</a>
<a name="ln3238">    // need to edit a conditional at the end of ouch.cc:ouch.</a>
<a name="ln3239">    _ghost_dprf(&quot;Trying to save ghosts.&quot;);</a>
<a name="ln3240">    if (ghosts.empty())</a>
<a name="ln3241">    {</a>
<a name="ln3242">        _ghost_dprf(&quot;Could not find any ghosts for this level to save.&quot;);</a>
<a name="ln3243">        return;</a>
<a name="ln3244">    }</a>
<a name="ln3245"> </a>
<a name="ln3246">    if (!force &amp;&amp; !ghost_demon::ghost_eligible())</a>
<a name="ln3247">    {</a>
<a name="ln3248">        _ghost_dprf(&quot;No eligible ghosts.&quot;);</a>
<a name="ln3249">        return;</a>
<a name="ln3250">    }</a>
<a name="ln3251"> </a>
<a name="ln3252">    vector&lt;ghost_demon&gt; leftovers;</a>
<a name="ln3253">    if (use_store)</a>
<a name="ln3254">        leftovers = _update_permastore(ghosts);</a>
<a name="ln3255">    else</a>
<a name="ln3256">        leftovers = ghosts;</a>
<a name="ln3257">    if (leftovers.size() == 0)</a>
<a name="ln3258">        return;</a>
<a name="ln3259"> </a>
<a name="ln3260">    if (_list_bones().size() &gt;= static_cast&lt;size_t&gt;(GHOST_LIMIT))</a>
<a name="ln3261">    {</a>
<a name="ln3262">        _ghost_dprf(&quot;Too many ghosts for this level already!&quot;);</a>
<a name="ln3263">        return;</a>
<a name="ln3264">    }</a>
<a name="ln3265"> </a>
<a name="ln3266">    string g_file_name = &quot;&quot;;</a>
<a name="ln3267">    FILE* ghost_file = _make_bones_file(&amp;g_file_name);</a>
<a name="ln3268"> </a>
<a name="ln3269">    if (!ghost_file)</a>
<a name="ln3270">    {</a>
<a name="ln3271">        _ghost_dprf(&quot;Could not open file to save ghosts.&quot;);</a>
<a name="ln3272">        return;</a>
<a name="ln3273">    }</a>
<a name="ln3274"> </a>
<a name="ln3275">    writer outw(g_file_name, ghost_file);</a>
<a name="ln3276"> </a>
<a name="ln3277">    write_ghost_version(outw);</a>
<a name="ln3278">    tag_write_ghosts(outw, leftovers);</a>
<a name="ln3279"> </a>
<a name="ln3280">    lk_close(ghost_file);</a>
<a name="ln3281"> </a>
<a name="ln3282">    _ghost_dprf(&quot;Saved ghosts (%s).&quot;, g_file_name.c_str());</a>
<a name="ln3283">}</a>
<a name="ln3284"> </a>
<a name="ln3285">////////////////////////////////////////////////////////////////////////////</a>
<a name="ln3286">// Locking</a>
<a name="ln3287"> </a>
<a name="ln3288">bool lock_file_handle(FILE *handle, bool write)</a>
<a name="ln3289">{</a>
<a name="ln3290">    return lock_file(fileno(handle), write, true);</a>
<a name="ln3291">}</a>
<a name="ln3292"> </a>
<a name="ln3293">bool unlock_file_handle(FILE *handle)</a>
<a name="ln3294">{</a>
<a name="ln3295">    return unlock_file(fileno(handle));</a>
<a name="ln3296">}</a>
<a name="ln3297"> </a>
<a name="ln3298">/**</a>
<a name="ln3299"> * Attempts to open &amp; lock a file.</a>
<a name="ln3300"> *</a>
<a name="ln3301"> * @param mode      The file access mode. ('r', 'ab+', etc)</a>
<a name="ln3302"> * @param file      The path to the file to be opened.</a>
<a name="ln3303"> * @return          A handle for the specified file, if successful; else nullptr.</a>
<a name="ln3304"> */</a>
<a name="ln3305">FILE *lk_open(const char *mode, const string &amp;file)</a>
<a name="ln3306">{</a>
<a name="ln3307">    ASSERT(mode);</a>
<a name="ln3308"> </a>
<a name="ln3309">    FILE *handle = fopen_u(file.c_str(), mode);</a>
<a name="ln3310">    if (!handle)</a>
<a name="ln3311">        return nullptr;</a>
<a name="ln3312"> </a>
<a name="ln3313">    const bool write_lock = mode[0] != 'r' || strchr(mode, '+');</a>
<a name="ln3314">    if (!lock_file_handle(handle, write_lock))</a>
<a name="ln3315">    {</a>
<a name="ln3316">        mprf(MSGCH_ERROR, &quot;ERROR: Could not lock file %s&quot;, file.c_str());</a>
<a name="ln3317">        fclose(handle);</a>
<a name="ln3318">        handle = nullptr;</a>
<a name="ln3319">    }</a>
<a name="ln3320"> </a>
<a name="ln3321">    return handle;</a>
<a name="ln3322">}</a>
<a name="ln3323"> </a>
<a name="ln3324">/**</a>
<a name="ln3325"> * Attempts to open and lock a file for exclusive write access; fails if</a>
<a name="ln3326"> * the file already exists.</a>
<a name="ln3327"> *</a>
<a name="ln3328"> * @param file The path to the file to be opened.</a>
<a name="ln3329"> * @return     A locked file handle for the specified file, if</a>
<a name="ln3330"> *             successful; else nullptr.</a>
<a name="ln3331"> */</a>
<a name="ln3332">FILE *lk_open_exclusive(const string &amp;file)</a>
<a name="ln3333">{</a>
<a name="ln3334">    int fd = open_u(file.c_str(), O_WRONLY|O_BINARY|O_EXCL|O_CREAT, 0666);</a>
<a name="ln3335">    if (fd &lt; 0)</a>
<a name="ln3336">        return nullptr;</a>
<a name="ln3337"> </a>
<a name="ln3338">    if (!lock_file(fd, true))</a>
<a name="ln3339">    {</a>
<a name="ln3340">        mprf(MSGCH_ERROR, &quot;ERROR: Could not lock file %s&quot;, file.c_str());</a>
<a name="ln3341">        close(fd);</a>
<a name="ln3342">        return nullptr;</a>
<a name="ln3343">    }</a>
<a name="ln3344"> </a>
<a name="ln3345">    return fdopen(fd, &quot;wb&quot;);</a>
<a name="ln3346">}</a>
<a name="ln3347"> </a>
<a name="ln3348">void lk_close(FILE *handle)</a>
<a name="ln3349">{</a>
<a name="ln3350">    if (handle == nullptr || handle == stdin)</a>
<a name="ln3351">        return;</a>
<a name="ln3352"> </a>
<a name="ln3353">    unlock_file_handle(handle);</a>
<a name="ln3354"> </a>
<a name="ln3355">    // actually close</a>
<a name="ln3356">    fclose(handle);</a>
<a name="ln3357">}</a>
<a name="ln3358"> </a>
<a name="ln3359">/////////////////////////////////////////////////////////////////////////////</a>
<a name="ln3360">// file_lock</a>
<a name="ln3361">//</a>
<a name="ln3362">// Locks a named file (usually an empty lock file), creating it if necessary.</a>
<a name="ln3363"> </a>
<a name="ln3364">file_lock::file_lock(const string &amp;s, const char *_mode, bool die_on_fail)</a>
<a name="ln3365">    : handle(nullptr), mode(_mode), filename(s)</a>
<a name="ln3366">{</a>
<a name="ln3367">    if (!(handle = lk_open(mode, filename)) &amp;&amp; die_on_fail)</a>
<a name="ln3368">        end(1, true, &quot;Unable to open lock file \&quot;%s\&quot;&quot;, filename.c_str());</a>
<a name="ln3369">}</a>
<a name="ln3370"> </a>
<a name="ln3371">file_lock::~file_lock()</a>
<a name="ln3372">{</a>
<a name="ln3373">    if (handle)</a>
<a name="ln3374">        lk_close(handle);</a>
<a name="ln3375">}</a>
<a name="ln3376"> </a>
<a name="ln3377">/////////////////////////////////////////////////////////////////////////////</a>
<a name="ln3378"> </a>
<a name="ln3379">FILE *fopen_replace(const char *name)</a>
<a name="ln3380">{</a>
<a name="ln3381">    int fd;</a>
<a name="ln3382"> </a>
<a name="ln3383">    // Stave off symlink attacks. Races will be handled with O_EXCL.</a>
<a name="ln3384">    unlink_u(name);</a>
<a name="ln3385">    fd = open_u(name, O_CREAT|O_EXCL|O_WRONLY, 0666);</a>
<a name="ln3386">    if (fd == -1)</a>
<a name="ln3387">        return 0;</a>
<a name="ln3388">    return fdopen(fd, &quot;w&quot;);</a>
<a name="ln3389">}</a>
<a name="ln3390"> </a>
<a name="ln3391">// Returns the size of the opened file with the give FILE* handle.</a>
<a name="ln3392">off_t file_size(FILE *handle)</a>
<a name="ln3393">{</a>
<a name="ln3394">#ifdef __ANDROID__</a>
<a name="ln3395">    off_t pos = ftello(handle);</a>
<a name="ln3396">    if (fseeko(handle, 0, SEEK_END) &lt; 0)</a>
<a name="ln3397">        return 0;</a>
<a name="ln3398">    off_t ret = ftello(handle);</a>
<a name="ln3399">    fseeko(handle, pos, SEEK_SET);</a>
<a name="ln3400">    return ret;</a>
<a name="ln3401">#else</a>
<a name="ln3402">    struct stat fs;</a>
<a name="ln3403">    const int err = fstat(fileno(handle), &amp;fs);</a>
<a name="ln3404">    return err? 0 : fs.st_size;</a>
<a name="ln3405">#endif</a>
<a name="ln3406">}</a>
<a name="ln3407"> </a>
<a name="ln3408">vector&lt;string&gt; get_title_files()</a>
<a name="ln3409">{</a>
<a name="ln3410">    vector&lt;string&gt; titles;</a>
<a name="ln3411">    for (const string &amp;dir : _get_base_dirs())</a>
<a name="ln3412">        for (const string &amp;file : get_dir_files_sorted(dir))</a>
<a name="ln3413">            if (file.substr(0, 6) == &quot;title_&quot;)</a>
<a name="ln3414">                titles.push_back(file);</a>
<a name="ln3415">    return titles;</a>
<a name="ln3416">}</a>

</code></pre>
<div class="balloon" rel="739"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v547/" target="_blank">V547</a> Expression 'searchpath.empty()' is always false.</p></div>
<div class="balloon" rel="1148"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v648/" target="_blank">V648</a> Priority of the '&&' operation is higher than that of the '||' operation.</p></div>
<div class="balloon" rel="1527"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v648/" target="_blank">V648</a> Priority of the '&&' operation is higher than that of the '||' operation.</p></div>
<div class="balloon" rel="1864"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v560/" target="_blank">V560</a> A part of conditional expression is always true: load_mode == LOAD_ENTER_LEVEL.</p></div>
<div class="balloon" rel="1799"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v581/" target="_blank">V581</a> The conditional expressions of the 'if' statements situated alongside each other are identical. Check lines: 1795, 1799.</p></div>
<div class="balloon" rel="2830"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v730/" target="_blank">V730</a> Not all members of a class are initialized inside the constructor. Consider inspecting: allow_unvisited.</p></div>

<link rel="stylesheet" href="highlight.css">
<script src="highlight.pack.js"></script>
<script src="highlightjs-line-numbers.js"></script>
<script>hljs.initHighlightingOnLoad();</script>
<script>hljs.initLineNumbersOnLoad();</script>
<script>
  $(document).ready(function() {
      $('.balloon').each(function () {
          var bl = $(this);
          var line = bl.attr('rel');
          var text = $('a[name="ln'+line+'"]').text();

          var space_count = 0;
          for(var i = 0; i<text.length; i++){
              var char = text[i];
              if((char !== ' ')&&(char !== '\t'))break;
              if(char === '\t')space_count++;
              space_count++;
          }

          bl.css('margin-left', space_count*8);
          $('a[name="ln'+line+'"]').after(bl);
      });

      window.location = window.location;
  });
</script>
</body>
</html>
