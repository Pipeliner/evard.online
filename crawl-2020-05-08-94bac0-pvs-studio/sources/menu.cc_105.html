
<html>
<head>

  <meta http-equiv="Content-Type" content="text/html; charset=US-ASCII" />
  <title>menu.cc</title>

  <link rel="stylesheet" href="../style.css"/>
  <script src="../jquery-3.2.1.min.js"></script>
</head>
<body>

<pre><code class = "cpp">
<a name="ln1">/**</a>
<a name="ln2"> * @file</a>
<a name="ln3"> * @brief Menus and associated malarkey.</a>
<a name="ln4">**/</a>
<a name="ln5"> </a>
<a name="ln6">#include &quot;AppHdr.h&quot;</a>
<a name="ln7"> </a>
<a name="ln8">#include &quot;menu.h&quot;</a>
<a name="ln9"> </a>
<a name="ln10">#include &lt;cctype&gt;</a>
<a name="ln11">#include &lt;functional&gt;</a>
<a name="ln12"> </a>
<a name="ln13">#include &quot;cio.h&quot;</a>
<a name="ln14">#include &quot;colour.h&quot;</a>
<a name="ln15">#include &quot;command.h&quot;</a>
<a name="ln16">#include &quot;coord.h&quot;</a>
<a name="ln17">#include &quot;env.h&quot;</a>
<a name="ln18">#include &quot;hints.h&quot;</a>
<a name="ln19">#include &quot;invent.h&quot;</a>
<a name="ln20">#include &quot;libutil.h&quot;</a>
<a name="ln21">#include &quot;message.h&quot;</a>
<a name="ln22">#ifdef USE_TILE</a>
<a name="ln23"> #include &quot;mon-util.h&quot;</a>
<a name="ln24">#endif</a>
<a name="ln25">#include &quot;options.h&quot;</a>
<a name="ln26">#include &quot;player.h&quot;</a>
<a name="ln27">#include &quot;player-save-info.h&quot;</a>
<a name="ln28">#include &quot;state.h&quot;</a>
<a name="ln29">#include &quot;stringutil.h&quot;</a>
<a name="ln30">#ifdef USE_TILE</a>
<a name="ln31"> #include &quot;terrain.h&quot;</a>
<a name="ln32">#endif</a>
<a name="ln33">#ifdef USE_TILE_LOCAL</a>
<a name="ln34"> #include &quot;tilebuf.h&quot;</a>
<a name="ln35">#endif</a>
<a name="ln36">#ifdef USE_TILE</a>
<a name="ln37"> #include &quot;tile-flags.h&quot;</a>
<a name="ln38"> #include &quot;tile-player-flag-cut.h&quot;</a>
<a name="ln39"> #include &quot;rltiles/tiledef-dngn.h&quot;</a>
<a name="ln40"> #include &quot;rltiles/tiledef-icons.h&quot;</a>
<a name="ln41"> #include &quot;rltiles/tiledef-main.h&quot;</a>
<a name="ln42"> #include &quot;rltiles/tiledef-player.h&quot;</a>
<a name="ln43">#endif</a>
<a name="ln44">#ifdef USE_TILE_LOCAL</a>
<a name="ln45"> #include &quot;tilefont.h&quot;</a>
<a name="ln46">#endif</a>
<a name="ln47">#ifdef USE_TILE</a>
<a name="ln48"> #include &quot;tilepick.h&quot;</a>
<a name="ln49"> #include &quot;tilepick-p.h&quot;</a>
<a name="ln50">#endif</a>
<a name="ln51">#ifdef USE_TILE_LOCAL</a>
<a name="ln52"> #include &quot;tilereg-crt.h&quot;</a>
<a name="ln53">#endif</a>
<a name="ln54">#ifdef USE_TILE</a>
<a name="ln55"> #include &quot;travel.h&quot;</a>
<a name="ln56">#endif</a>
<a name="ln57">#include &quot;ui.h&quot;</a>
<a name="ln58">#include &quot;unicode.h&quot;</a>
<a name="ln59">#include &quot;unwind.h&quot;</a>
<a name="ln60">#ifdef USE_TILE_LOCAL</a>
<a name="ln61">#include &quot;windowmanager.h&quot;</a>
<a name="ln62">#endif</a>
<a name="ln63"> </a>
<a name="ln64">using namespace ui;</a>
<a name="ln65"> </a>
<a name="ln66">class UIMenu : public Widget</a>
<a name="ln67">{</a>
<a name="ln68">    friend class UIMenuPopup;</a>
<a name="ln69">public:</a>
<a name="ln70">    UIMenu(Menu *menu) : m_menu(menu)</a>
<a name="ln71"> </a>
<a name="ln72">#ifdef USE_TILE_LOCAL</a>
<a name="ln73">    , m_num_columns(1), m_font_entry(tiles.get_crt_font()), m_text_buf(m_font_entry)</a>
<a name="ln74">#endif</a>
<a name="ln75">    {</a>
<a name="ln76">#ifdef USE_TILE_LOCAL</a>
<a name="ln77">        const ImageManager *m_image = tiles.get_image_manager();</a>
<a name="ln78">        for (int i = 0; i &lt; TEX_MAX; i++)</a>
<a name="ln79">            m_tile_buf[i].set_tex(&amp;m_image-&gt;m_textures[i]);</a>
<a name="ln80">#else</a>
<a name="ln81">        expand_h = true;</a>
<a name="ln82">#endif</a>
<a name="ln83">    };</a>
<a name="ln84">    ~UIMenu() {};</a>
<a name="ln85"> </a>
<a name="ln86">    virtual void _render() override;</a>
<a name="ln87">    virtual SizeReq _get_preferred_size(Direction dim, int prosp_width) override;</a>
<a name="ln88">    virtual void _allocate_region() override;</a>
<a name="ln89">#ifdef USE_TILE_LOCAL</a>
<a name="ln90">    virtual bool on_event(const Event&amp; event) override;</a>
<a name="ln91">    int get_num_columns() const { return m_num_columns; };</a>
<a name="ln92">    void set_num_columns(int n) {</a>
<a name="ln93">        m_num_columns = n;</a>
<a name="ln94">        _invalidate_sizereq();</a>
<a name="ln95">        _queue_allocation();</a>
<a name="ln96">    };</a>
<a name="ln97">#endif</a>
<a name="ln98"> </a>
<a name="ln99">    void update_item(int index);</a>
<a name="ln100">    void update_items();</a>
<a name="ln101"> </a>
<a name="ln102">    void is_visible_item_range(int *vis_min, int *vis_max);</a>
<a name="ln103">    void get_item_region(int index, int *y1, int *y2);</a>
<a name="ln104"> </a>
<a name="ln105">#ifndef USE_TILE_LOCAL</a>
<a name="ln106">    void set_showable_height(int h)</a>
<a name="ln107">    {</a>
<a name="ln108">        m_shown_height = h;</a>
<a name="ln109">        _invalidate_sizereq();</a>
<a name="ln110">    }</a>
<a name="ln111">#endif</a>
<a name="ln112"> </a>
<a name="ln113">protected:</a>
<a name="ln114">    Menu *m_menu;</a>
<a name="ln115">    int m_height; // set by do_layout()</a>
<a name="ln116"> </a>
<a name="ln117">#ifdef USE_TILE_LOCAL</a>
<a name="ln118">    void do_layout(int mw, int num_columns);</a>
<a name="ln119"> </a>
<a name="ln120">    int get_max_viewport_height();</a>
<a name="ln121">    int m_nat_column_width; // set by do_layout()</a>
<a name="ln122">    int m_num_columns = 1;</a>
<a name="ln123"> </a>
<a name="ln124">    struct MenuItemInfo {</a>
<a name="ln125">        int x, y, row, column;</a>
<a name="ln126">        formatted_string text;</a>
<a name="ln127">        vector&lt;tile_def&gt; tiles;</a>
<a name="ln128">        bool heading;</a>
<a name="ln129">    };</a>
<a name="ln130">    vector&lt;MenuItemInfo&gt; item_info;</a>
<a name="ln131">    vector&lt;int&gt; row_heights;</a>
<a name="ln132"> </a>
<a name="ln133">    bool m_mouse_pressed = false;</a>
<a name="ln134">    int m_mouse_idx = -1, m_mouse_x = -1, m_mouse_y = -1;</a>
<a name="ln135">    void update_hovered_entry();</a>
<a name="ln136"> </a>
<a name="ln137">    void pack_buffers();</a>
<a name="ln138"> </a>
<a name="ln139">    bool m_draw_tiles;</a>
<a name="ln140">    FontWrapper *m_font_entry;</a>
<a name="ln141">    ShapeBuffer m_shape_buf;</a>
<a name="ln142">    LineBuffer m_line_buf, m_div_line_buf;</a>
<a name="ln143">    FontBuffer m_text_buf;</a>
<a name="ln144">    FixedVector&lt;TileBuffer, TEX_MAX&gt; m_tile_buf;</a>
<a name="ln145"> </a>
<a name="ln146">public:</a>
<a name="ln147">    static constexpr int item_pad = 2;</a>
<a name="ln148">    static constexpr int pad_right = 10;</a>
<a name="ln149">#else</a>
<a name="ln150">    int m_shown_height {0};</a>
<a name="ln151">#endif</a>
<a name="ln152">};</a>
<a name="ln153"> </a>
<a name="ln154">void UIMenu::update_items()</a>
<a name="ln155">{</a>
<a name="ln156">    _invalidate_sizereq();</a>
<a name="ln157"> </a>
<a name="ln158">#ifdef USE_TILE_LOCAL</a>
<a name="ln159">    item_info.resize(m_menu-&gt;items.size());</a>
<a name="ln160">#endif</a>
<a name="ln161">    for (unsigned int i = 0; i &lt; m_menu-&gt;items.size(); ++i)</a>
<a name="ln162">        update_item(i);</a>
<a name="ln163"> </a>
<a name="ln164">#ifdef USE_TILE_LOCAL</a>
<a name="ln165">    // update m_draw_tiles</a>
<a name="ln166">    m_draw_tiles = false;</a>
<a name="ln167">    for (const auto&amp; entry : item_info)</a>
<a name="ln168">        if (!entry.heading &amp;&amp; !entry.tiles.empty())</a>
<a name="ln169">        {</a>
<a name="ln170">            m_draw_tiles = Options.tile_menu_icons;</a>
<a name="ln171">            break;</a>
<a name="ln172">        }</a>
<a name="ln173">#endif</a>
<a name="ln174">}</a>
<a name="ln175"> </a>
<a name="ln176">void UIMenu::is_visible_item_range(int *vis_min, int *vis_max)</a>
<a name="ln177">{</a>
<a name="ln178">    const int viewport_height = m_menu-&gt;m_ui.scroller-&gt;get_region().height;</a>
<a name="ln179">    const int scroll = m_menu-&gt;m_ui.scroller-&gt;get_scroll();</a>
<a name="ln180"> </a>
<a name="ln181">#ifdef USE_TILE_LOCAL</a>
<a name="ln182">    int v_min = 0, v_max = item_info.size(), i;</a>
<a name="ln183">    for (i = 0; i &lt; (int)item_info.size(); ++i)</a>
<a name="ln184">    {</a>
<a name="ln185">        if (row_heights[item_info[i].row + 1] &gt; scroll)</a>
<a name="ln186">        {</a>
<a name="ln187">            v_min = i;</a>
<a name="ln188">            break;</a>
<a name="ln189">        }</a>
<a name="ln190">    }</a>
<a name="ln191">    for (; i &lt; (int)item_info.size(); ++i)</a>
<a name="ln192">    {</a>
<a name="ln193">        if (row_heights[item_info[i].row] &gt;= scroll + viewport_height)</a>
<a name="ln194">        {</a>
<a name="ln195">            v_max = i;</a>
<a name="ln196">            break;</a>
<a name="ln197">        }</a>
<a name="ln198">    }</a>
<a name="ln199">#else</a>
<a name="ln200">    int v_min = scroll;</a>
<a name="ln201">    int v_max = scroll + viewport_height;</a>
<a name="ln202">#endif</a>
<a name="ln203">    v_max = min(v_max, (int)m_menu-&gt;items.size());</a>
<a name="ln204">    if (vis_min)</a>
<a name="ln205">        *vis_min = v_min;</a>
<a name="ln206">    if (vis_max)</a>
<a name="ln207">        *vis_max = v_max;</a>
<a name="ln208">}</a>
<a name="ln209"> </a>
<a name="ln210">void UIMenu::get_item_region(int index, int *y1, int *y2)</a>
<a name="ln211">{</a>
<a name="ln212">    ASSERT_RANGE(index, 0, (int)m_menu-&gt;items.size());</a>
<a name="ln213">#ifdef USE_TILE_LOCAL</a>
<a name="ln214">    int row = item_info[index].row;</a>
<a name="ln215">    if (y1)</a>
<a name="ln216">        *y1 = row_heights[row];</a>
<a name="ln217">    if (y2)</a>
<a name="ln218">        *y2 = row_heights[row+1];</a>
<a name="ln219">#else</a>
<a name="ln220">    if (y1)</a>
<a name="ln221">        *y1 = index;</a>
<a name="ln222">    if (y2)</a>
<a name="ln223">        *y2 = index+1;</a>
<a name="ln224">#endif</a>
<a name="ln225">}</a>
<a name="ln226"> </a>
<a name="ln227">void UIMenu::update_item(int index)</a>
<a name="ln228">{</a>
<a name="ln229">    _invalidate_sizereq();</a>
<a name="ln230">    _queue_allocation();</a>
<a name="ln231">#ifdef USE_TILE_LOCAL</a>
<a name="ln232">    const MenuEntry *me = m_menu-&gt;items[index];</a>
<a name="ln233">    int colour = m_menu-&gt;item_colour(me);</a>
<a name="ln234">    const bool needs_cursor = (m_menu-&gt;get_cursor() == index</a>
<a name="ln235">                               &amp;&amp; m_menu-&gt;is_set(MF_MULTISELECT));</a>
<a name="ln236">    string text = me-&gt;get_text(needs_cursor);</a>
<a name="ln237"> </a>
<a name="ln238">    item_info.resize(m_menu-&gt;items.size());</a>
<a name="ln239"> </a>
<a name="ln240">    auto&amp; entry = item_info[index];</a>
<a name="ln241">    entry.text.clear();</a>
<a name="ln242">    entry.text.textcolour(colour);</a>
<a name="ln243">    entry.text += formatted_string::parse_string(text);</a>
<a name="ln244">    entry.heading = me-&gt;level == MEL_TITLE || me-&gt;level == MEL_SUBTITLE;</a>
<a name="ln245">    entry.tiles.clear();</a>
<a name="ln246">    me-&gt;get_tiles(entry.tiles);</a>
<a name="ln247">#else</a>
<a name="ln248">    UNUSED(index);</a>
<a name="ln249">#endif</a>
<a name="ln250">}</a>
<a name="ln251"> </a>
<a name="ln252">#ifdef USE_TILE_LOCAL</a>
<a name="ln253">static bool _has_hotkey_prefix(const string &amp;s)</a>
<a name="ln254">{</a>
<a name="ln255">    // [enne] - Ugh, hack. Maybe MenuEntry could specify the</a>
<a name="ln256">    // presence and length of this substring?</a>
<a name="ln257">    bool let = (s[1] &gt;= 'a' &amp;&amp; s[1] &lt;= 'z' || s[1] &gt;= 'A' &amp;&amp; s[1] &lt;= 'Z');</a>
<a name="ln258">    bool plus = (s[3] == '-' || s[3] == '+' || s[3] == '#');</a>
<a name="ln259">    return let &amp;&amp; plus &amp;&amp; s[0] == ' ' &amp;&amp; s[2] == ' ' &amp;&amp; s[4] == ' ';</a>
<a name="ln260">}</a>
<a name="ln261"> </a>
<a name="ln262">void UIMenu::do_layout(int mw, int num_columns)</a>
<a name="ln263">{</a>
<a name="ln264">    const int min_column_width = 400;</a>
<a name="ln265">    const int max_column_width = mw / num_columns;</a>
<a name="ln266">    const int text_height = m_font_entry-&gt;char_height();</a>
<a name="ln267"> </a>
<a name="ln268">    int column = -1; // an initial increment makes this 0</a>
<a name="ln269">    int column_width = 0;</a>
<a name="ln270">    int row_height = 0;</a>
<a name="ln271">    int height = 0;</a>
<a name="ln272"> </a>
<a name="ln273">    row_heights.clear();</a>
<a name="ln274">    row_heights.reserve(m_menu-&gt;items.size()+1);</a>
<a name="ln275"> </a>
<a name="ln276">    for (size_t i = 0; i &lt; m_menu-&gt;items.size(); ++i)</a>
<a name="ln277">    {</a>
<a name="ln278">        auto&amp; entry = item_info[i];</a>
<a name="ln279"> </a>
<a name="ln280">        column = entry.heading ? 0 : (column+1) % num_columns;</a>
<a name="ln281"> </a>
<a name="ln282">        if (column == 0)</a>
<a name="ln283">        {</a>
<a name="ln284">            row_height += row_height == 0 ? 0 : 2*item_pad;</a>
<a name="ln285">            height += row_height;</a>
<a name="ln286">            row_heights.push_back(height);</a>
<a name="ln287">            row_height = 0;</a>
<a name="ln288">        }</a>
<a name="ln289"> </a>
<a name="ln290">        const int text_width = m_font_entry-&gt;string_width(entry.text);</a>
<a name="ln291"> </a>
<a name="ln292">        entry.y = height;</a>
<a name="ln293">        entry.row = row_heights.size() - 1;</a>
<a name="ln294">        entry.column = column;</a>
<a name="ln295"> </a>
<a name="ln296">        if (entry.heading)</a>
<a name="ln297">        {</a>
<a name="ln298">            entry.x = 0;</a>
<a name="ln299">            // extra space here is used for divider line and padding; note that</a>
<a name="ln300">            // we only want top padding if we're not the first item, since the</a>
<a name="ln301">            // popup and the more already have padding.</a>
<a name="ln302">            row_height = text_height + (i == 0 ? 5 : 10);</a>
<a name="ln303"> </a>
<a name="ln304">            // wrap titles to two lines if they don't fit</a>
<a name="ln305">            if (m_draw_tiles &amp;&amp; text_width &gt; mw)</a>
<a name="ln306">            {</a>
<a name="ln307">                formatted_string split = m_font_entry-&gt;split(entry.text, mw, UINT_MAX);</a>
<a name="ln308">                row_height = max(row_height, (int)m_font_entry-&gt;string_height(split));</a>
<a name="ln309">            }</a>
<a name="ln310">            column = num_columns-1;</a>
<a name="ln311">        }</a>
<a name="ln312">        else</a>
<a name="ln313">        {</a>
<a name="ln314">            const int text_indent = m_draw_tiles ? 38 : 0;</a>
<a name="ln315"> </a>
<a name="ln316">            entry.x = text_indent;</a>
<a name="ln317">            int text_sx = text_indent;</a>
<a name="ln318">            int item_height = max(text_height, !entry.tiles.empty() ? 32 : 0);</a>
<a name="ln319"> </a>
<a name="ln320">            // Split menu entries that don't fit into a single line into two lines.</a>
<a name="ln321">            if (!m_menu-&gt;is_set(MF_NO_WRAP_ROWS))</a>
<a name="ln322">            if ((text_width &gt; max_column_width-entry.x-pad_right))</a>
<a name="ln323">            {</a>
<a name="ln324">                formatted_string text;</a>
<a name="ln325">                if (_has_hotkey_prefix(entry.text.tostring()))</a>
<a name="ln326">                {</a>
<a name="ln327">                    formatted_string header = entry.text.chop(5);</a>
<a name="ln328">                    text_sx += m_font_entry-&gt;string_width(header);</a>
<a name="ln329">                    text = entry.text;</a>
<a name="ln330">                    // remove hotkeys. As Enne said above, this is a monstrosity.</a>
<a name="ln331">                    for (int k = 0; k &lt; 5; k++)</a>
<a name="ln332">                        text.del_char();</a>
<a name="ln333">                }</a>
<a name="ln334">                else</a>
<a name="ln335">                    text += entry.text;</a>
<a name="ln336"> </a>
<a name="ln337">                int w = max_column_width - text_sx - pad_right;</a>
<a name="ln338">                formatted_string split = m_font_entry-&gt;split(text, w, UINT_MAX);</a>
<a name="ln339">                int string_height = m_font_entry-&gt;string_height(split);</a>
<a name="ln340">                string_height = min(string_height, text_height*2);</a>
<a name="ln341">                item_height = max(item_height, string_height);</a>
<a name="ln342">            }</a>
<a name="ln343"> </a>
<a name="ln344">            column_width = max(column_width, text_sx + text_width + pad_right);</a>
<a name="ln345">            row_height = max(row_height, item_height);</a>
<a name="ln346">        }</a>
<a name="ln347">    }</a>
<a name="ln348">    row_height += row_height == 0 ? 0 : 2*item_pad;</a>
<a name="ln349">    height += row_height;</a>
<a name="ln350">    row_heights.push_back(height);</a>
<a name="ln351">    column_width += 2*item_pad;</a>
<a name="ln352"> </a>
<a name="ln353">    m_height = height;</a>
<a name="ln354">    m_nat_column_width = max(min_column_width, min(column_width, max_column_width));</a>
<a name="ln355">}</a>
<a name="ln356"> </a>
<a name="ln357">int UIMenu::get_max_viewport_height()</a>
<a name="ln358">{</a>
<a name="ln359">    // Limit page size to ensure &lt;= 52 items visible</a>
<a name="ln360">    int max_viewport_height = INT_MAX;</a>
<a name="ln361">    size_t a = 0, b = 0, num_items = 0;</a>
<a name="ln362">    while (b &lt; item_info.size())</a>
<a name="ln363">    {</a>
<a name="ln364">        if (num_items &lt; 52)</a>
<a name="ln365">            num_items += !item_info[b++].heading;</a>
<a name="ln366">        else if (num_items == 52)</a>
<a name="ln367">        {</a>
<a name="ln368">            int item_h = row_heights[item_info[b].row] - row_heights[item_info[b-1].row];</a>
<a name="ln369">            int delta = item_h + item_info[b-1].y - item_info[a].y;</a>
<a name="ln370">            max_viewport_height = min(max_viewport_height, delta);</a>
<a name="ln371">            do</a>
<a name="ln372">            {</a>
<a name="ln373">                num_items -= !item_info[a++].heading;</a>
<a name="ln374">            }</a>
<a name="ln375">            while (item_info[a].column != 0);</a>
<a name="ln376">        }</a>
<a name="ln377">    }</a>
<a name="ln378">    return max_viewport_height;</a>
<a name="ln379">}</a>
<a name="ln380">#endif</a>
<a name="ln381"> </a>
<a name="ln382">void UIMenu::_render()</a>
<a name="ln383">{</a>
<a name="ln384">#ifdef USE_TILE_LOCAL</a>
<a name="ln385">    GLW_3VF t = {(float)m_region.x, (float)m_region.y, 0}, s = {1, 1, 1};</a>
<a name="ln386">    glmanager-&gt;set_transform(t, s);</a>
<a name="ln387"> </a>
<a name="ln388">    m_shape_buf.draw();</a>
<a name="ln389">    m_div_line_buf.draw();</a>
<a name="ln390">    for (int i = 0; i &lt; TEX_MAX; i++)</a>
<a name="ln391">        m_tile_buf[i].draw();</a>
<a name="ln392">    m_text_buf.draw();</a>
<a name="ln393">    m_line_buf.draw();</a>
<a name="ln394"> </a>
<a name="ln395">    glmanager-&gt;reset_transform();</a>
<a name="ln396">#else</a>
<a name="ln397"> </a>
<a name="ln398">    int vis_min, vis_max;</a>
<a name="ln399">    is_visible_item_range(&amp;vis_min, &amp;vis_max);</a>
<a name="ln400">    const int scroll = m_menu-&gt;m_ui.scroller-&gt;get_scroll();</a>
<a name="ln401"> </a>
<a name="ln402">    for (int i = vis_min; i &lt; vis_max; i++)</a>
<a name="ln403">    {</a>
<a name="ln404">        const MenuEntry *me = m_menu-&gt;items[i];</a>
<a name="ln405">        int y = i - vis_min + 1;</a>
<a name="ln406">        cgotoxy(m_region.x+1, m_region.y+scroll+y);</a>
<a name="ln407">        const int col = m_menu-&gt;item_colour(me);</a>
<a name="ln408">        textcolour(col);</a>
<a name="ln409">        const bool needs_cursor = (m_menu-&gt;get_cursor() == i &amp;&amp; m_menu-&gt;is_set(MF_MULTISELECT));</a>
<a name="ln410"> </a>
<a name="ln411">        if (m_menu-&gt;get_flags() &amp; MF_ALLOW_FORMATTING)</a>
<a name="ln412">        {</a>
<a name="ln413">            formatted_string s = formatted_string::parse_string(</a>
<a name="ln414">                me-&gt;get_text(needs_cursor), col);</a>
<a name="ln415">            s.chop(m_region.width).display();</a>
<a name="ln416">        }</a>
<a name="ln417">        else</a>
<a name="ln418">        {</a>
<a name="ln419">            string text = me-&gt;get_text(needs_cursor);</a>
<a name="ln420">            text = chop_string(text, m_region.width);</a>
<a name="ln421">            cprintf(&quot;%s&quot;, text.c_str());</a>
<a name="ln422">        }</a>
<a name="ln423">    }</a>
<a name="ln424">#endif</a>
<a name="ln425">}</a>
<a name="ln426"> </a>
<a name="ln427">SizeReq UIMenu::_get_preferred_size(Direction dim, int prosp_width)</a>
<a name="ln428">{</a>
<a name="ln429">#ifdef USE_TILE_LOCAL</a>
<a name="ln430">    if (!dim)</a>
<a name="ln431">    {</a>
<a name="ln432">        do_layout(INT_MAX, m_num_columns);</a>
<a name="ln433">        const int em = Options.tile_font_crt_size;</a>
<a name="ln434">        int max_menu_width = min(93*em, m_nat_column_width * m_num_columns);</a>
<a name="ln435">        return {0, max_menu_width};</a>
<a name="ln436">    }</a>
<a name="ln437">    else</a>
<a name="ln438">    {</a>
<a name="ln439">        do_layout(prosp_width, m_num_columns);</a>
<a name="ln440">        return {0, m_height};</a>
<a name="ln441">    }</a>
<a name="ln442">#else</a>
<a name="ln443">    UNUSED(prosp_width);</a>
<a name="ln444">    if (!dim)</a>
<a name="ln445">        return {0, 80};</a>
<a name="ln446">    else</a>
<a name="ln447">        return {1, max({1, (int)m_menu-&gt;items.size(), m_shown_height})};</a>
<a name="ln448">#endif</a>
<a name="ln449">}</a>
<a name="ln450"> </a>
<a name="ln451">class UIMenuScroller : public Scroller</a>
<a name="ln452">{</a>
<a name="ln453">public:</a>
<a name="ln454">    UIMenuScroller() : Scroller() {};</a>
<a name="ln455">    virtual ~UIMenuScroller() {};</a>
<a name="ln456">    virtual void _allocate_region() override {</a>
<a name="ln457">        m_child-&gt;set_allocation_needed();</a>
<a name="ln458">        Scroller::_allocate_region();</a>
<a name="ln459">    };</a>
<a name="ln460">};</a>
<a name="ln461"> </a>
<a name="ln462">class UIMenuMore : public Text</a>
<a name="ln463">{</a>
<a name="ln464">public:</a>
<a name="ln465">    virtual ~UIMenuMore() {};</a>
<a name="ln466">    void set_text_immediately(const formatted_string &amp;fs)</a>
<a name="ln467">    {</a>
<a name="ln468">        m_text.clear();</a>
<a name="ln469">        m_text += fs;</a>
<a name="ln470">        _expose();</a>
<a name="ln471">        m_wrapped_size = Size(-1);</a>
<a name="ln472">        wrap_text_to_size(m_region.width, m_region.height);</a>
<a name="ln473">    };</a>
<a name="ln474">};</a>
<a name="ln475"> </a>
<a name="ln476">class UIMenuPopup : public ui::Popup</a>
<a name="ln477">{</a>
<a name="ln478">public:</a>
<a name="ln479">    UIMenuPopup(shared_ptr&lt;Widget&gt; child, Menu *menu) : ui::Popup(child), m_menu(menu) {};</a>
<a name="ln480">    virtual ~UIMenuPopup() {};</a>
<a name="ln481"> </a>
<a name="ln482">    virtual void _allocate_region() override;</a>
<a name="ln483"> </a>
<a name="ln484">private:</a>
<a name="ln485">    Menu *m_menu;</a>
<a name="ln486">};</a>
<a name="ln487"> </a>
<a name="ln488">void UIMenuPopup::_allocate_region()</a>
<a name="ln489">{</a>
<a name="ln490">    Popup::_allocate_region();</a>
<a name="ln491"> </a>
<a name="ln492">    int max_height = m_menu-&gt;m_ui.popup-&gt;get_max_child_size().height;</a>
<a name="ln493">    max_height -= m_menu-&gt;m_ui.title-&gt;get_region().height;</a>
<a name="ln494">    max_height -= m_menu-&gt;m_ui.title-&gt;get_margin().bottom;</a>
<a name="ln495">    int viewport_height = m_menu-&gt;m_ui.scroller-&gt;get_region().height;</a>
<a name="ln496"> </a>
<a name="ln497">#ifdef USE_TILE_LOCAL</a>
<a name="ln498">    int menu_w = m_menu-&gt;m_ui.menu-&gt;get_region().width;</a>
<a name="ln499">    m_menu-&gt;m_ui.menu-&gt;do_layout(menu_w, 1);</a>
<a name="ln500">    int m_height = m_menu-&gt;m_ui.menu-&gt;m_height;</a>
<a name="ln501"> </a>
<a name="ln502">    int more_height = m_menu-&gt;m_ui.more-&gt;get_region().height;</a>
<a name="ln503">    // switch number of columns</a>
<a name="ln504">    int num_cols = m_menu-&gt;m_ui.menu-&gt;get_num_columns();</a>
<a name="ln505">    if (m_menu-&gt;m_ui.menu-&gt;m_draw_tiles &amp;&amp; m_menu-&gt;is_set(MF_USE_TWO_COLUMNS)</a>
<a name="ln506">        &amp;&amp; !Options.tile_single_column_menus)</a>
<a name="ln507">    {</a>
<a name="ln508">        if ((num_cols == 1 &amp;&amp; m_height+more_height &gt; max_height)</a>
<a name="ln509">         || (num_cols == 2 &amp;&amp; m_height+more_height &lt;= max_height))</a>
<a name="ln510">        {</a>
<a name="ln511">            m_menu-&gt;m_ui.menu-&gt;set_num_columns(3 - num_cols);</a>
<a name="ln512">            ui::restart_layout();</a>
<a name="ln513">        }</a>
<a name="ln514">    }</a>
<a name="ln515">    m_menu-&gt;m_ui.menu-&gt;do_layout(menu_w, num_cols);</a>
<a name="ln516">#endif</a>
<a name="ln517"> </a>
<a name="ln518">#ifndef USE_TILE_LOCAL</a>
<a name="ln519">    int menu_height = m_menu-&gt;m_ui.menu-&gt;get_region().height;</a>
<a name="ln520"> </a>
<a name="ln521">    // change more visibility</a>
<a name="ln522">    bool can_toggle_more = !m_menu-&gt;is_set(MF_ALWAYS_SHOW_MORE)</a>
<a name="ln523">        &amp;&amp; !m_menu-&gt;m_ui.more-&gt;get_text().ops.empty();</a>
<a name="ln524">    if (can_toggle_more)</a>
<a name="ln525">    {</a>
<a name="ln526">        bool more_visible = m_menu-&gt;m_ui.more-&gt;is_visible();</a>
<a name="ln527">        if (more_visible ? menu_height &lt;= max_height : menu_height &gt; max_height)</a>
<a name="ln528">        {</a>
<a name="ln529">            m_menu-&gt;m_ui.more-&gt;set_visible(!more_visible);</a>
<a name="ln530">            _invalidate_sizereq();</a>
<a name="ln531">            m_menu-&gt;m_ui.more-&gt;_queue_allocation();</a>
<a name="ln532">            ui::restart_layout();</a>
<a name="ln533">        }</a>
<a name="ln534">    }</a>
<a name="ln535"> </a>
<a name="ln536">    if (m_menu-&gt;m_keyhelp_more &amp;&amp; m_menu-&gt;m_ui.more-&gt;is_visible())</a>
<a name="ln537">    {</a>
<a name="ln538">        int scroll = m_menu-&gt;m_ui.scroller-&gt;get_scroll();</a>
<a name="ln539">        int scroll_percent = scroll*100/(menu_height-viewport_height);</a>
<a name="ln540">        string perc = scroll &lt;= 0 ? &quot;top&quot;</a>
<a name="ln541">            : scroll_percent &gt;= 100 ? &quot;bot&quot;</a>
<a name="ln542">            : make_stringf(&quot;%2d%%&quot;, scroll_percent);</a>
<a name="ln543"> </a>
<a name="ln544">        string scroll_more = m_menu-&gt;more.to_colour_string();</a>
<a name="ln545">        scroll_more = replace_all(scroll_more, &quot;XXX&quot;, perc);</a>
<a name="ln546">        m_menu-&gt;m_ui.more-&gt;set_text_immediately(formatted_string::parse_string(scroll_more));</a>
<a name="ln547">    }</a>
<a name="ln548">#endif</a>
<a name="ln549"> </a>
<a name="ln550">    // adjust maximum height</a>
<a name="ln551">#ifdef USE_TILE_LOCAL</a>
<a name="ln552">    const int max_viewport_height = m_menu-&gt;m_ui.menu-&gt;get_max_viewport_height();</a>
<a name="ln553">#else</a>
<a name="ln554">    const int max_viewport_height = 52;</a>
<a name="ln555">#endif</a>
<a name="ln556">    m_menu-&gt;m_ui.scroller-&gt;max_size().height = max_viewport_height;</a>
<a name="ln557">    if (max_viewport_height &lt; viewport_height)</a>
<a name="ln558">    {</a>
<a name="ln559">        m_menu-&gt;m_ui.scroller-&gt;_invalidate_sizereq();</a>
<a name="ln560">        m_menu-&gt;m_ui.scroller-&gt;_queue_allocation();</a>
<a name="ln561">        ui::restart_layout();</a>
<a name="ln562">    }</a>
<a name="ln563">}</a>
<a name="ln564"> </a>
<a name="ln565">void UIMenu::_allocate_region()</a>
<a name="ln566">{</a>
<a name="ln567">#ifndef USE_TILE_LOCAL</a>
<a name="ln568">    // XXX: is this needed?</a>
<a name="ln569">    m_height = m_menu-&gt;items.size();</a>
<a name="ln570">#else</a>
<a name="ln571">    do_layout(m_region.width, m_num_columns);</a>
<a name="ln572">    update_hovered_entry();</a>
<a name="ln573">    pack_buffers();</a>
<a name="ln574">#endif</a>
<a name="ln575">}</a>
<a name="ln576"> </a>
<a name="ln577">#ifdef USE_TILE_LOCAL</a>
<a name="ln578">void UIMenu::update_hovered_entry()</a>
<a name="ln579">{</a>
<a name="ln580">    const int x = m_mouse_x - m_region.x,</a>
<a name="ln581">              y = m_mouse_y - m_region.y;</a>
<a name="ln582">    int vis_min, vis_max;</a>
<a name="ln583">    is_visible_item_range(&amp;vis_min, &amp;vis_max);</a>
<a name="ln584"> </a>
<a name="ln585">    for (int i = vis_min; i &lt; vis_max; ++i)</a>
<a name="ln586">    {</a>
<a name="ln587">        const auto&amp; entry = item_info[i];</a>
<a name="ln588">        if (entry.heading)</a>
<a name="ln589">            continue;</a>
<a name="ln590">        const auto me = m_menu-&gt;items[i];</a>
<a name="ln591">        if (me-&gt;hotkeys.size() == 0)</a>
<a name="ln592">            continue;</a>
<a name="ln593">        const int w = m_region.width / m_num_columns;</a>
<a name="ln594">        const int entry_x = entry.column * w;</a>
<a name="ln595">        const int entry_h = row_heights[entry.row+1] - row_heights[entry.row];</a>
<a name="ln596">        if (x &gt;= entry_x &amp;&amp; x &lt; entry_x+w &amp;&amp; y &gt;= entry.y &amp;&amp; y &lt; entry.y+entry_h)</a>
<a name="ln597">        {</a>
<a name="ln598">            wm-&gt;set_mouse_cursor(MOUSE_CURSOR_POINTER);</a>
<a name="ln599">            m_mouse_idx = i;</a>
<a name="ln600">            return;</a>
<a name="ln601">        }</a>
<a name="ln602">    }</a>
<a name="ln603">    wm-&gt;set_mouse_cursor(MOUSE_CURSOR_ARROW);</a>
<a name="ln604">    m_mouse_idx = -1;</a>
<a name="ln605">}</a>
<a name="ln606"> </a>
<a name="ln607">bool UIMenu::on_event(const Event&amp; ev)</a>
<a name="ln608">{</a>
<a name="ln609">    if (Widget::on_event(ev))</a>
<a name="ln610">        return true;</a>
<a name="ln611"> </a>
<a name="ln612">    if (ev.type() != Event::Type::MouseMove</a>
<a name="ln613">     &amp;&amp; ev.type() != Event::Type::MouseDown</a>
<a name="ln614">     &amp;&amp; ev.type() != Event::Type::MouseUp</a>
<a name="ln615">     &amp;&amp; ev.type() != Event::Type::MouseEnter</a>
<a name="ln616">     &amp;&amp; ev.type() != Event::Type::MouseLeave)</a>
<a name="ln617">    {</a>
<a name="ln618">        return false;</a>
<a name="ln619">    }</a>
<a name="ln620"> </a>
<a name="ln621">    auto event = static_cast&lt;const MouseEvent&amp;&gt;(ev);</a>
<a name="ln622"> </a>
<a name="ln623">    m_mouse_x = event.x();</a>
<a name="ln624">    m_mouse_y = event.y();</a>
<a name="ln625"> </a>
<a name="ln626">    if (event.type() == Event::Type::MouseEnter)</a>
<a name="ln627">    {</a>
<a name="ln628">        do_layout(m_region.width, m_num_columns);</a>
<a name="ln629">        update_hovered_entry();</a>
<a name="ln630">        pack_buffers();</a>
<a name="ln631">        _expose();</a>
<a name="ln632">        return false;</a>
<a name="ln633">    }</a>
<a name="ln634"> </a>
<a name="ln635">    if (event.type() == Event::Type::MouseLeave)</a>
<a name="ln636">    {</a>
<a name="ln637">        wm-&gt;set_mouse_cursor(MOUSE_CURSOR_ARROW);</a>
<a name="ln638">        m_mouse_x = -1;</a>
<a name="ln639">        m_mouse_y = -1;</a>
<a name="ln640">        m_mouse_pressed = false;</a>
<a name="ln641">        m_mouse_idx = -1;</a>
<a name="ln642">        do_layout(m_region.width, m_num_columns);</a>
<a name="ln643">        pack_buffers();</a>
<a name="ln644">        _expose();</a>
<a name="ln645">        return false;</a>
<a name="ln646">    }</a>
<a name="ln647"> </a>
<a name="ln648">    if (event.type() == Event::Type::MouseMove)</a>
<a name="ln649">    {</a>
<a name="ln650">        do_layout(m_region.width, m_num_columns);</a>
<a name="ln651">        update_hovered_entry();</a>
<a name="ln652">        pack_buffers();</a>
<a name="ln653">        _expose();</a>
<a name="ln654">        return true;</a>
<a name="ln655">    }</a>
<a name="ln656"> </a>
<a name="ln657">    int key = -1;</a>
<a name="ln658">    if (event.type() ==  Event::Type::MouseDown</a>
<a name="ln659">        &amp;&amp; event.button() == MouseEvent::Button::Left)</a>
<a name="ln660">    {</a>
<a name="ln661">        m_mouse_pressed = true;</a>
<a name="ln662">        _queue_allocation();</a>
<a name="ln663">    }</a>
<a name="ln664">    else if (event.type() == Event::Type::MouseUp</a>
<a name="ln665">            &amp;&amp; event.button() == MouseEvent::Button::Left</a>
<a name="ln666">            &amp;&amp; m_mouse_pressed)</a>
<a name="ln667">    {</a>
<a name="ln668">        int entry = m_mouse_idx;</a>
<a name="ln669">        if (entry != -1 &amp;&amp; m_menu-&gt;items[entry]-&gt;hotkeys.size() &gt; 0)</a>
<a name="ln670">            key = m_menu-&gt;items[entry]-&gt;hotkeys[0];</a>
<a name="ln671">        m_mouse_pressed = false;</a>
<a name="ln672">        _queue_allocation();</a>
<a name="ln673">    }</a>
<a name="ln674"> </a>
<a name="ln675">    if (key != -1)</a>
<a name="ln676">    {</a>
<a name="ln677">        wm_keyboard_event wm_ev = {0};</a>
<a name="ln678">        wm_ev.keysym.sym = key;</a>
<a name="ln679">        KeyEvent key_ev(Event::Type::KeyDown, wm_ev);</a>
<a name="ln680">        m_menu-&gt;m_ui.popup-&gt;on_event(key_ev);</a>
<a name="ln681">    }</a>
<a name="ln682"> </a>
<a name="ln683">    return true;</a>
<a name="ln684">}</a>
<a name="ln685"> </a>
<a name="ln686">void UIMenu::pack_buffers()</a>
<a name="ln687">{</a>
<a name="ln688">    m_shape_buf.clear();</a>
<a name="ln689">    m_div_line_buf.clear();</a>
<a name="ln690">    for (int i = 0; i &lt; TEX_MAX; i++)</a>
<a name="ln691">        m_tile_buf[i].clear();</a>
<a name="ln692">    m_text_buf.clear();</a>
<a name="ln693">    m_line_buf.clear();</a>
<a name="ln694"> </a>
<a name="ln695">    const VColour selected_colour(50, 50, 10, 255);</a>
<a name="ln696">    const VColour header_div_colour(64, 64, 64, 200);</a>
<a name="ln697"> </a>
<a name="ln698">    if (!item_info.size())</a>
<a name="ln699">        return;</a>
<a name="ln700"> </a>
<a name="ln701">    const int col_width = m_region.width / m_num_columns;</a>
<a name="ln702"> </a>
<a name="ln703">    int vis_min, vis_max;</a>
<a name="ln704">    is_visible_item_range(&amp;vis_min, &amp;vis_max);</a>
<a name="ln705"> </a>
<a name="ln706">    for (int i = vis_min; i &lt; vis_max; ++i)</a>
<a name="ln707">    {</a>
<a name="ln708">        const auto&amp; entry = item_info[i];</a>
<a name="ln709">        const auto me = m_menu-&gt;items[i];</a>
<a name="ln710">        const int entry_x = entry.column * col_width;</a>
<a name="ln711">        const int entry_ex = entry_x + col_width;</a>
<a name="ln712">        const int entry_h = row_heights[entry.row+1] - row_heights[entry.row];</a>
<a name="ln713"> </a>
<a name="ln714">        if (entry.heading)</a>
<a name="ln715">        {</a>
<a name="ln716">            formatted_string split = m_font_entry-&gt;split(entry.text, m_region.width, entry_h);</a>
<a name="ln717">            // see corresponding section in do_layout()</a>
<a name="ln718">            int line_y = entry.y  + (i == 0 ? 0 : 5) + item_pad;</a>
<a name="ln719">            if (i &lt; (int)item_info.size()-1 &amp;&amp; !item_info[i+1].heading)</a>
<a name="ln720">            {</a>
<a name="ln721">                m_div_line_buf.add_square(entry.x, line_y,</a>
<a name="ln722">                        entry.x+m_num_columns*col_width, line_y, header_div_colour);</a>
<a name="ln723">            }</a>
<a name="ln724">            m_text_buf.add(split, entry.x, line_y+3);</a>
<a name="ln725">        }</a>
<a name="ln726">        else</a>
<a name="ln727">        {</a>
<a name="ln728">            const int ty = entry.y + max(entry_h-32, 0)/2;</a>
<a name="ln729">            for (const tile_def &amp;tile : entry.tiles)</a>
<a name="ln730">            {</a>
<a name="ln731">                // NOTE: This is not perfect. Tiles will be drawn</a>
<a name="ln732">                // sorted by texture first, e.g. you can never draw</a>
<a name="ln733">                // a dungeon tile over a monster tile.</a>
<a name="ln734">                TextureID tex  = tile.tex;</a>
<a name="ln735">                m_tile_buf[tex].add(tile.tile, entry_x + item_pad, ty, 0, 0, false, tile.ymax, 1, 1);</a>
<a name="ln736">            }</a>
<a name="ln737"> </a>
<a name="ln738">            const int text_indent = m_draw_tiles ? 38 : 0;</a>
<a name="ln739">            int text_sx = entry_x + text_indent + item_pad;</a>
<a name="ln740">            int text_sy = entry.y + (entry_h - m_font_entry-&gt;char_height())/2;</a>
<a name="ln741"> </a>
<a name="ln742">            // Split off and render any hotkey prefix first</a>
<a name="ln743">            formatted_string text;</a>
<a name="ln744">            if (_has_hotkey_prefix(entry.text.tostring()))</a>
<a name="ln745">            {</a>
<a name="ln746">                formatted_string header = entry.text.chop(5);</a>
<a name="ln747">                m_text_buf.add(header, text_sx, text_sy);</a>
<a name="ln748">                text_sx += m_font_entry-&gt;string_width(header);</a>
<a name="ln749">                text = entry.text;</a>
<a name="ln750">                // remove hotkeys. As Enne said above, this is a monstrosity.</a>
<a name="ln751">                for (int k = 0; k &lt; 5; k++)</a>
<a name="ln752">                    text.del_char();</a>
<a name="ln753">            }</a>
<a name="ln754">            else</a>
<a name="ln755">                text += entry.text;</a>
<a name="ln756"> </a>
<a name="ln757">            // Line wrap and render the remaining text</a>
<a name="ln758">            int w = entry_ex-text_sx - pad_right;</a>
<a name="ln759">            int h = m_font_entry-&gt;char_height();</a>
<a name="ln760">            h *= m_menu-&gt;is_set(MF_NO_WRAP_ROWS) ? 1 : 2;</a>
<a name="ln761">            formatted_string split = m_font_entry-&gt;split(text, w, h);</a>
<a name="ln762">            int string_height = m_font_entry-&gt;string_height(split);</a>
<a name="ln763">            text_sy = entry.y + (entry_h - string_height)/2;</a>
<a name="ln764"> </a>
<a name="ln765">            m_text_buf.add(split, text_sx, text_sy);</a>
<a name="ln766">        }</a>
<a name="ln767"> </a>
<a name="ln768">        bool hovered = i == m_mouse_idx &amp;&amp; !entry.heading &amp;&amp; me-&gt;hotkeys.size() &gt; 0;</a>
<a name="ln769"> </a>
<a name="ln770">        if (me-&gt;selected() &amp;&amp; !m_menu-&gt;is_set(MF_QUIET_SELECT))</a>
<a name="ln771">        {</a>
<a name="ln772">            m_shape_buf.add(entry_x, entry.y,</a>
<a name="ln773">                    entry_ex, entry.y+entry_h, selected_colour);</a>
<a name="ln774">        }</a>
<a name="ln775">        else if (hovered)</a>
<a name="ln776">        {</a>
<a name="ln777">            const VColour hover_bg = m_mouse_pressed ?</a>
<a name="ln778">                VColour(0, 0, 0, 255) : VColour(255, 255, 255, 25);</a>
<a name="ln779">            m_shape_buf.add(entry_x, entry.y,</a>
<a name="ln780">                    entry_ex, entry.y+entry_h, hover_bg);</a>
<a name="ln781">        }</a>
<a name="ln782">        if (hovered)</a>
<a name="ln783">        {</a>
<a name="ln784">            const VColour mouse_colour = m_mouse_pressed ?</a>
<a name="ln785">                VColour(34, 34, 34, 255) : VColour(255, 255, 255, 51);</a>
<a name="ln786">            m_line_buf.add_square(entry_x + 1, entry.y + 1,</a>
<a name="ln787">                    entry_x+col_width, entry.y+entry_h, mouse_colour);</a>
<a name="ln788">        }</a>
<a name="ln789">    }</a>
<a name="ln790">}</a>
<a name="ln791">#endif</a>
<a name="ln792"> </a>
<a name="ln793">Menu::Menu(int _flags, const string&amp; tagname, KeymapContext kmc)</a>
<a name="ln794">  : f_selitem(nullptr), f_keyfilter(nullptr),</a>
<a name="ln795">    action_cycle(CYCLE_NONE), menu_action(ACT_EXAMINE), title(nullptr),</a>
<a name="ln796">    title2(nullptr), flags(_flags), tag(tagname),</a>
<a name="ln797">    cur_page(1), items(), sel(),</a>
<a name="ln798">    select_filter(), highlighter(new MenuHighlighter), num(-1), lastch(0),</a>
<a name="ln799">    alive(false), last_selected(-1), m_kmc(kmc), m_filter(nullptr)</a>
<a name="ln800">{</a>
<a name="ln801">    m_ui.menu = make_shared&lt;UIMenu&gt;(this);</a>
<a name="ln802">    m_ui.scroller = make_shared&lt;UIMenuScroller&gt;();</a>
<a name="ln803">    m_ui.title = make_shared&lt;Text&gt;();</a>
<a name="ln804">    m_ui.more = make_shared&lt;UIMenuMore&gt;();</a>
<a name="ln805">    m_ui.more-&gt;set_visible(false);</a>
<a name="ln806">    m_ui.vbox = make_shared&lt;Box&gt;(Widget::VERT);</a>
<a name="ln807">    m_ui.vbox-&gt;set_cross_alignment(Widget::STRETCH);</a>
<a name="ln808"> </a>
<a name="ln809">    m_ui.vbox-&gt;add_child(m_ui.title);</a>
<a name="ln810">#ifdef USE_TILE_LOCAL</a>
<a name="ln811">    m_ui.vbox-&gt;add_child(m_ui.scroller);</a>
<a name="ln812">#else</a>
<a name="ln813">    auto scroller_wrap = make_shared&lt;Box&gt;(Widget::VERT, Box::Expand::EXPAND_V);</a>
<a name="ln814">    scroller_wrap-&gt;set_cross_alignment(Widget::STRETCH);</a>
<a name="ln815">    scroller_wrap-&gt;add_child(m_ui.scroller);</a>
<a name="ln816">    m_ui.vbox-&gt;add_child(scroller_wrap);</a>
<a name="ln817">#endif</a>
<a name="ln818">    m_ui.vbox-&gt;add_child(m_ui.more);</a>
<a name="ln819">    m_ui.scroller-&gt;set_child(m_ui.menu);</a>
<a name="ln820"> </a>
<a name="ln821">    set_flags(flags);</a>
<a name="ln822">    set_more();</a>
<a name="ln823">}</a>
<a name="ln824"> </a>
<a name="ln825">void Menu::check_add_formatted_line(int firstcol, int nextcol,</a>
<a name="ln826">                                    string &amp;line, bool check_eol)</a>
<a name="ln827">{</a>
<a name="ln828">    if (line.empty())</a>
<a name="ln829">        return;</a>
<a name="ln830"> </a>
<a name="ln831">    if (check_eol &amp;&amp; line.find(&quot;\n&quot;) == string::npos)</a>
<a name="ln832">        return;</a>
<a name="ln833"> </a>
<a name="ln834">    vector&lt;string&gt; lines = split_string(&quot;\n&quot;, line, false, true);</a>
<a name="ln835">    int size = lines.size();</a>
<a name="ln836"> </a>
<a name="ln837">    // If we have stuff after EOL, leave that in the line variable and</a>
<a name="ln838">    // don't add an entry for it, unless the caller told us not to</a>
<a name="ln839">    // check EOL sanity.</a>
<a name="ln840">    if (check_eol &amp;&amp; !ends_with(line, &quot;\n&quot;))</a>
<a name="ln841">        line = lines[--size];</a>
<a name="ln842">    else</a>
<a name="ln843">        line.clear();</a>
<a name="ln844"> </a>
<a name="ln845">    for (int i = 0, col = firstcol; i &lt; size; ++i, col = nextcol)</a>
<a name="ln846">    {</a>
<a name="ln847">        string &amp;s(lines[i]);</a>
<a name="ln848"> </a>
<a name="ln849">        trim_string_right(s);</a>
<a name="ln850"> </a>
<a name="ln851">        MenuEntry *me = new MenuEntry(s);</a>
<a name="ln852">        me-&gt;colour = col;</a>
<a name="ln853">        if (!title)</a>
<a name="ln854">            set_title(me);</a>
<a name="ln855">        else</a>
<a name="ln856">            add_entry(me);</a>
<a name="ln857">    }</a>
<a name="ln858"> </a>
<a name="ln859">    line.clear();</a>
<a name="ln860">}</a>
<a name="ln861"> </a>
<a name="ln862">Menu::~Menu()</a>
<a name="ln863">{</a>
<a name="ln864">    deleteAll(items);</a>
<a name="ln865">    delete title;</a>
<a name="ln866">    if (title2)</a>
<a name="ln867">        delete title2;</a>
<a name="ln868">    delete highlighter;</a>
<a name="ln869">}</a>
<a name="ln870"> </a>
<a name="ln871">void Menu::clear()</a>
<a name="ln872">{</a>
<a name="ln873">    deleteAll(items);</a>
<a name="ln874">    m_ui.menu-&gt;_queue_allocation();</a>
<a name="ln875">    last_selected = -1;</a>
<a name="ln876">}</a>
<a name="ln877"> </a>
<a name="ln878">void Menu::set_flags(int new_flags)</a>
<a name="ln879">{</a>
<a name="ln880">    flags = new_flags;</a>
<a name="ln881"> </a>
<a name="ln882">#ifdef DEBUG</a>
<a name="ln883">    int sel_flag = flags &amp; (MF_NOSELECT | MF_SINGLESELECT | MF_MULTISELECT);</a>
<a name="ln884">    ASSERT(sel_flag == MF_NOSELECT || sel_flag == MF_SINGLESELECT || sel_flag == MF_MULTISELECT);</a>
<a name="ln885">#endif</a>
<a name="ln886">}</a>
<a name="ln887"> </a>
<a name="ln888">bool Menu::minus_is_pageup() const</a>
<a name="ln889">{</a>
<a name="ln890">    return !is_set(MF_MULTISELECT) &amp;&amp; !is_set(MF_SPECIAL_MINUS);</a>
<a name="ln891">}</a>
<a name="ln892"> </a>
<a name="ln893">void Menu::set_more(const formatted_string &amp;fs)</a>
<a name="ln894">{</a>
<a name="ln895">    m_keyhelp_more = false;</a>
<a name="ln896">    more = fs;</a>
<a name="ln897">    update_more();</a>
<a name="ln898">}</a>
<a name="ln899"> </a>
<a name="ln900">void Menu::set_more()</a>
<a name="ln901">{</a>
<a name="ln902">    m_keyhelp_more = true;</a>
<a name="ln903">    string pageup_keys = minus_is_pageup() ? &quot;&lt;w&gt;-&lt;/w&gt;|&lt;w&gt;&lt;&lt;&lt;/w&gt;&quot; : &quot;&lt;w&gt;&lt;&lt;&lt;/w&gt;&quot;;</a>
<a name="ln904">    more = formatted_string::parse_string(</a>
<a name="ln905">        &quot;&lt;lightgrey&gt;[&lt;w&gt;+&lt;/w&gt;|&lt;w&gt;&gt;&lt;/w&gt;|&lt;w&gt;Space&lt;/w&gt;]: page down        &quot;</a>
<a name="ln906">        &quot;[&quot; + pageup_keys + &quot;]: page up        &quot;</a>
<a name="ln907">        &quot;[&lt;w&gt;Esc&lt;/w&gt;]: close        [&lt;w&gt;XXX&lt;/w&gt;]&lt;/lightgrey&gt;&quot;</a>
<a name="ln908">    );</a>
<a name="ln909">    update_more();</a>
<a name="ln910">}</a>
<a name="ln911"> </a>
<a name="ln912">void Menu::set_highlighter(MenuHighlighter *mh)</a>
<a name="ln913">{</a>
<a name="ln914">    if (highlighter != mh)</a>
<a name="ln915">        delete highlighter;</a>
<a name="ln916">    highlighter = mh;</a>
<a name="ln917">}</a>
<a name="ln918"> </a>
<a name="ln919">void Menu::set_title(MenuEntry *e, bool first, bool indent)</a>
<a name="ln920">{</a>
<a name="ln921">    if (first)</a>
<a name="ln922">    {</a>
<a name="ln923">        if (title != e)</a>
<a name="ln924">            delete title;</a>
<a name="ln925"> </a>
<a name="ln926">        title = e;</a>
<a name="ln927">        title-&gt;level = MEL_TITLE;</a>
<a name="ln928">    }</a>
<a name="ln929">    else</a>
<a name="ln930">    {</a>
<a name="ln931">        title2 = e;</a>
<a name="ln932">        title2-&gt;level = MEL_TITLE;</a>
<a name="ln933">    }</a>
<a name="ln934">    m_indent_title = indent;</a>
<a name="ln935">    update_title();</a>
<a name="ln936">}</a>
<a name="ln937"> </a>
<a name="ln938">void Menu::add_entry(MenuEntry *entry)</a>
<a name="ln939">{</a>
<a name="ln940">    entry-&gt;tag = tag;</a>
<a name="ln941">    items.push_back(entry);</a>
<a name="ln942">}</a>
<a name="ln943"> </a>
<a name="ln944">void Menu::reset()</a>
<a name="ln945">{</a>
<a name="ln946">    m_ui.scroller-&gt;set_scroll(0);</a>
<a name="ln947">}</a>
<a name="ln948"> </a>
<a name="ln949">vector&lt;MenuEntry *&gt; Menu::show(bool reuse_selections)</a>
<a name="ln950">{</a>
<a name="ln951">    cursor_control cs(false);</a>
<a name="ln952"> </a>
<a name="ln953">    if (reuse_selections)</a>
<a name="ln954">        get_selected(&amp;sel);</a>
<a name="ln955">    else</a>
<a name="ln956">        deselect_all(false);</a>
<a name="ln957"> </a>
<a name="ln958">    if (is_set(MF_START_AT_END))</a>
<a name="ln959">        m_ui.scroller-&gt;set_scroll(INT_MAX);</a>
<a name="ln960"> </a>
<a name="ln961">    do_menu();</a>
<a name="ln962"> </a>
<a name="ln963">    return sel;</a>
<a name="ln964">}</a>
<a name="ln965"> </a>
<a name="ln966">void Menu::do_menu()</a>
<a name="ln967">{</a>
<a name="ln968">    bool done = false;</a>
<a name="ln969">    m_ui.popup = make_shared&lt;UIMenuPopup&gt;(m_ui.vbox, this);</a>
<a name="ln970"> </a>
<a name="ln971">    m_ui.popup-&gt;on_keydown_event([this, &amp;done](const KeyEvent&amp; ev) {</a>
<a name="ln972">        if (m_filter)</a>
<a name="ln973">        {</a>
<a name="ln974">            int key = m_filter-&gt;putkey(ev.key());</a>
<a name="ln975">            if (key != -1)</a>
<a name="ln976">            {</a>
<a name="ln977">                delete m_filter;</a>
<a name="ln978">                m_filter = nullptr;</a>
<a name="ln979">            }</a>
<a name="ln980">            update_title();</a>
<a name="ln981">            return true;</a>
<a name="ln982">        }</a>
<a name="ln983">        done = !process_key(ev.key());</a>
<a name="ln984">        return true;</a>
<a name="ln985">    });</a>
<a name="ln986">#ifdef TOUCH_UI</a>
<a name="ln987">    auto menu_wrap_click = [this, &amp;done](const MouseEvent&amp; ev) {</a>
<a name="ln988">        if (!m_filter &amp;&amp; ev.button() == MouseEvent::Button::Left)</a>
<a name="ln989">        {</a>
<a name="ln990">            done = !process_key(CK_TOUCH_DUMMY);</a>
<a name="ln991">            return true;</a>
<a name="ln992">        }</a>
<a name="ln993">        return false;</a>
<a name="ln994">    };</a>
<a name="ln995">    m_ui.title-&gt;on_mousedown_event(menu_wrap_click);</a>
<a name="ln996">    m_ui.more-&gt;on_mousedown_event(menu_wrap_click);</a>
<a name="ln997">#endif</a>
<a name="ln998"> </a>
<a name="ln999">    update_menu();</a>
<a name="ln1000">    ui::push_layout(m_ui.popup, m_kmc);</a>
<a name="ln1001"> </a>
<a name="ln1002">#ifdef USE_TILE_WEB</a>
<a name="ln1003">    tiles.push_menu(this);</a>
<a name="ln1004">    _webtiles_title_changed = false;</a>
<a name="ln1005">    m_ui.popup-&gt;on_layout_pop([](){ tiles.pop_menu(); });</a>
<a name="ln1006">#endif</a>
<a name="ln1007"> </a>
<a name="ln1008">    alive = true;</a>
<a name="ln1009">    while (alive &amp;&amp; !done &amp;&amp; !crawl_state.seen_hups)</a>
<a name="ln1010">    {</a>
<a name="ln1011">#ifdef USE_TILE_WEB</a>
<a name="ln1012">        if (_webtiles_title_changed)</a>
<a name="ln1013">        {</a>
<a name="ln1014">            webtiles_update_title();</a>
<a name="ln1015">            _webtiles_title_changed = false;</a>
<a name="ln1016">        }</a>
<a name="ln1017">#endif</a>
<a name="ln1018">        ui::pump_events();</a>
<a name="ln1019">    }</a>
<a name="ln1020">    alive = false;</a>
<a name="ln1021">    ui::pop_layout();</a>
<a name="ln1022">}</a>
<a name="ln1023"> </a>
<a name="ln1024">int Menu::get_cursor() const</a>
<a name="ln1025">{</a>
<a name="ln1026">    if (last_selected == -1)</a>
<a name="ln1027">        return -1;</a>
<a name="ln1028"> </a>
<a name="ln1029">    unsigned int last = last_selected % item_count();</a>
<a name="ln1030">    unsigned int next = (last_selected + 1) % item_count();</a>
<a name="ln1031"> </a>
<a name="ln1032">    // Items with no hotkeys are unselectable</a>
<a name="ln1033">    while (next != last &amp;&amp; (items[next]-&gt;hotkeys.empty()</a>
<a name="ln1034">                            || items[next]-&gt;level != MEL_ITEM))</a>
<a name="ln1035">    {</a>
<a name="ln1036">        next = (next + 1) % item_count();</a>
<a name="ln1037">    }</a>
<a name="ln1038"> </a>
<a name="ln1039">    return next;</a>
<a name="ln1040">}</a>
<a name="ln1041"> </a>
<a name="ln1042">bool Menu::is_set(int flag) const</a>
<a name="ln1043">{</a>
<a name="ln1044">    return (flags &amp; flag) == flag;</a>
<a name="ln1045">}</a>
<a name="ln1046"> </a>
<a name="ln1047">int Menu::pre_process(int k)</a>
<a name="ln1048">{</a>
<a name="ln1049">    return k;</a>
<a name="ln1050">}</a>
<a name="ln1051"> </a>
<a name="ln1052">int Menu::post_process(int k)</a>
<a name="ln1053">{</a>
<a name="ln1054">    return k;</a>
<a name="ln1055">}</a>
<a name="ln1056"> </a>
<a name="ln1057">bool Menu::filter_with_regex(const char *re)</a>
<a name="ln1058">{</a>
<a name="ln1059">    text_pattern tpat(re, true);</a>
<a name="ln1060">    for (unsigned int i = 0; i &lt; items.size(); ++i)</a>
<a name="ln1061">    {</a>
<a name="ln1062">        if (items[i]-&gt;level == MEL_ITEM</a>
<a name="ln1063">            &amp;&amp; tpat.matches(items[i]-&gt;get_text()))</a>
<a name="ln1064">        {</a>
<a name="ln1065">            select_index(i);</a>
<a name="ln1066">            if (flags &amp; MF_SINGLESELECT)</a>
<a name="ln1067">            {</a>
<a name="ln1068">                // Return the first item found.</a>
<a name="ln1069">                get_selected(&amp;sel);</a>
<a name="ln1070">                return false;</a>
<a name="ln1071">            }</a>
<a name="ln1072">        }</a>
<a name="ln1073">    }</a>
<a name="ln1074">    get_selected(&amp;sel);</a>
<a name="ln1075">    return true;</a>
<a name="ln1076">}</a>
<a name="ln1077"> </a>
<a name="ln1078">bool Menu::title_prompt(char linebuf[], int bufsz, const char* prompt)</a>
<a name="ln1079">{</a>
<a name="ln1080">    bool validline;</a>
<a name="ln1081">#ifdef USE_TILE_WEB</a>
<a name="ln1082">    mouse_control mc(MOUSE_MODE_PROMPT);</a>
<a name="ln1083">    cgotoxy(1,1);</a>
<a name="ln1084">    clear_to_end_of_line();</a>
<a name="ln1085">    textcolour(WHITE);</a>
<a name="ln1086">    cprintf(&quot;%s&quot;, prompt);</a>
<a name="ln1087">    textcolour(LIGHTGREY);</a>
<a name="ln1088">    line_reader reader(linebuf, bufsz, get_number_of_cols());</a>
<a name="ln1089">    validline = !reader.read_line(&quot;&quot;);</a>
<a name="ln1090">#else</a>
<a name="ln1091">    UNUSED(prompt);</a>
<a name="ln1092">    ASSERT(!m_filter);</a>
<a name="ln1093">    m_filter = new resumable_line_reader(linebuf, bufsz);</a>
<a name="ln1094">    update_title();</a>
<a name="ln1095">    do</a>
<a name="ln1096">    {</a>
<a name="ln1097">        ui::pump_events();</a>
<a name="ln1098">    }</a>
<a name="ln1099">    while (m_filter &amp;&amp; !crawl_state.seen_hups);</a>
<a name="ln1100">    validline = linebuf[0];</a>
<a name="ln1101">#endif</a>
<a name="ln1102"> </a>
<a name="ln1103">    return validline;</a>
<a name="ln1104">}</a>
<a name="ln1105"> </a>
<a name="ln1106">bool Menu::process_key(int keyin)</a>
<a name="ln1107">{</a>
<a name="ln1108">    if (items.empty())</a>
<a name="ln1109">    {</a>
<a name="ln1110">        lastch = keyin;</a>
<a name="ln1111">        return false;</a>
<a name="ln1112">    }</a>
<a name="ln1113">#ifdef TOUCH_UI</a>
<a name="ln1114">    else if (action_cycle == CYCLE_TOGGLE &amp;&amp; (keyin == '!' || keyin == '?'</a>
<a name="ln1115">             || keyin == CK_TOUCH_DUMMY))</a>
<a name="ln1116">#else</a>
<a name="ln1117">    else if (action_cycle == CYCLE_TOGGLE &amp;&amp; (keyin == '!' || keyin == '?'))</a>
<a name="ln1118">#endif</a>
<a name="ln1119">    {</a>
<a name="ln1120">        ASSERT(menu_action != ACT_MISC);</a>
<a name="ln1121">        if (menu_action == ACT_EXECUTE)</a>
<a name="ln1122">            menu_action = ACT_EXAMINE;</a>
<a name="ln1123">        else</a>
<a name="ln1124">            menu_action = ACT_EXECUTE;</a>
<a name="ln1125"> </a>
<a name="ln1126">        sel.clear();</a>
<a name="ln1127">        update_title();</a>
<a name="ln1128">        return true;</a>
<a name="ln1129">    }</a>
<a name="ln1130">#ifdef TOUCH_UI</a>
<a name="ln1131">    else if (action_cycle == CYCLE_CYCLE &amp;&amp; (keyin == '!' || keyin == '?'</a>
<a name="ln1132">             || keyin == CK_TOUCH_DUMMY))</a>
<a name="ln1133">#else</a>
<a name="ln1134">    else if (action_cycle == CYCLE_CYCLE &amp;&amp; (keyin == '!' || keyin == '?'))</a>
<a name="ln1135">#endif</a>
<a name="ln1136">    {</a>
<a name="ln1137">        menu_action = (action)((menu_action+1) % ACT_NUM);</a>
<a name="ln1138">        sel.clear();</a>
<a name="ln1139">        update_title();</a>
<a name="ln1140">        return true;</a>
<a name="ln1141">    }</a>
<a name="ln1142"> </a>
<a name="ln1143">    if (f_keyfilter)</a>
<a name="ln1144">        keyin = (*f_keyfilter)(keyin);</a>
<a name="ln1145">    keyin = pre_process(keyin);</a>
<a name="ln1146"> </a>
<a name="ln1147">#ifdef USE_TILE_WEB</a>
<a name="ln1148">    const int old_vis_first = get_first_visible();</a>
<a name="ln1149">#endif</a>
<a name="ln1150"> </a>
<a name="ln1151">    switch (keyin)</a>
<a name="ln1152">    {</a>
<a name="ln1153">    case CK_REDRAW:</a>
<a name="ln1154">        return true;</a>
<a name="ln1155">#ifndef TOUCH_UI</a>
<a name="ln1156">    case 0:</a>
<a name="ln1157">        return true;</a>
<a name="ln1158">#endif</a>
<a name="ln1159">    case CK_MOUSE_B2:</a>
<a name="ln1160">    case CK_MOUSE_CMD:</a>
<a name="ln1161">    CASE_ESCAPE</a>
<a name="ln1162">        sel.clear();</a>
<a name="ln1163">        lastch = keyin;</a>
<a name="ln1164">        return is_set(MF_UNCANCEL) &amp;&amp; !crawl_state.seen_hups;</a>
<a name="ln1165">    case ' ': case CK_PGDN: case '&gt;': case '+':</a>
<a name="ln1166">    case CK_MOUSE_B1:</a>
<a name="ln1167">    case CK_MOUSE_CLICK:</a>
<a name="ln1168">        if (!page_down() &amp;&amp; is_set(MF_WRAP))</a>
<a name="ln1169">            m_ui.scroller-&gt;set_scroll(0);</a>
<a name="ln1170">        break;</a>
<a name="ln1171">    case CK_PGUP: case '&lt;':</a>
<a name="ln1172">        page_up();</a>
<a name="ln1173">        break;</a>
<a name="ln1174">    case CK_UP:</a>
<a name="ln1175">        line_up();</a>
<a name="ln1176">        break;</a>
<a name="ln1177">    case CK_DOWN:</a>
<a name="ln1178">        line_down();</a>
<a name="ln1179">        break;</a>
<a name="ln1180">    case CK_HOME:</a>
<a name="ln1181">        m_ui.scroller-&gt;set_scroll(0);</a>
<a name="ln1182">        break;</a>
<a name="ln1183">    case CK_END:</a>
<a name="ln1184">        m_ui.scroller-&gt;set_scroll(INT_MAX);</a>
<a name="ln1185">        break;</a>
<a name="ln1186">    case CONTROL('F'):</a>
<a name="ln1187">        if ((flags &amp; MF_ALLOW_FILTER))</a>
<a name="ln1188">        {</a>
<a name="ln1189">            char linebuf[80] = &quot;&quot;;</a>
<a name="ln1190"> </a>
<a name="ln1191">            const bool validline = title_prompt(linebuf, sizeof linebuf,</a>
<a name="ln1192">                                                &quot;Select what? (regex) &quot;);</a>
<a name="ln1193"> </a>
<a name="ln1194">            return (validline &amp;&amp; linebuf[0]) ? filter_with_regex(linebuf) : true;</a>
<a name="ln1195">        }</a>
<a name="ln1196">        break;</a>
<a name="ln1197">    case '.':</a>
<a name="ln1198">        if (last_selected == -1 &amp;&amp; is_set(MF_MULTISELECT))</a>
<a name="ln1199">            last_selected = 0;</a>
<a name="ln1200"> </a>
<a name="ln1201">        if (last_selected != -1)</a>
<a name="ln1202">        {</a>
<a name="ln1203">            const int next = get_cursor();</a>
<a name="ln1204">            if (next != -1)</a>
<a name="ln1205">            {</a>
<a name="ln1206">                InvEntry::set_show_cursor(true);</a>
<a name="ln1207">                select_index(next, num);</a>
<a name="ln1208">                get_selected(&amp;sel);</a>
<a name="ln1209">                update_title();</a>
<a name="ln1210">                if (get_cursor() &lt; next)</a>
<a name="ln1211">                {</a>
<a name="ln1212">                    m_ui.scroller-&gt;set_scroll(0);</a>
<a name="ln1213">                    break;</a>
<a name="ln1214">                }</a>
<a name="ln1215">            }</a>
<a name="ln1216"> </a>
<a name="ln1217">            if (!in_page(last_selected))</a>
<a name="ln1218">                page_down();</a>
<a name="ln1219">        }</a>
<a name="ln1220">        break;</a>
<a name="ln1221"> </a>
<a name="ln1222">    case '\'':</a>
<a name="ln1223">        if (last_selected == -1 &amp;&amp; is_set(MF_MULTISELECT))</a>
<a name="ln1224">            last_selected = 0;</a>
<a name="ln1225">        else</a>
<a name="ln1226">            last_selected = get_cursor();</a>
<a name="ln1227"> </a>
<a name="ln1228">        if (last_selected != -1)</a>
<a name="ln1229">        {</a>
<a name="ln1230">            InvEntry::set_show_cursor(true);</a>
<a name="ln1231">            const int it_count = item_count();</a>
<a name="ln1232">            if (last_selected &lt; it_count</a>
<a name="ln1233">                &amp;&amp; items[last_selected]-&gt;level == MEL_ITEM)</a>
<a name="ln1234">            {</a>
<a name="ln1235">                m_ui.menu-&gt;update_item(last_selected);</a>
<a name="ln1236">            }</a>
<a name="ln1237"> </a>
<a name="ln1238">            const int next_cursor = get_cursor();</a>
<a name="ln1239">            if (next_cursor != -1)</a>
<a name="ln1240">            {</a>
<a name="ln1241">                if (next_cursor &lt; last_selected)</a>
<a name="ln1242">                    m_ui.scroller-&gt;set_scroll(0);</a>
<a name="ln1243">                else if (!in_page(last_selected))</a>
<a name="ln1244">                    page_down();</a>
<a name="ln1245">                else if (next_cursor &lt; it_count</a>
<a name="ln1246">                         &amp;&amp; items[next_cursor]-&gt;level == MEL_ITEM)</a>
<a name="ln1247">                {</a>
<a name="ln1248">                    m_ui.menu-&gt;update_item(next_cursor);</a>
<a name="ln1249">                }</a>
<a name="ln1250">            }</a>
<a name="ln1251">        }</a>
<a name="ln1252">        break;</a>
<a name="ln1253"> </a>
<a name="ln1254">    case '_':</a>
<a name="ln1255">        if (!help_key().empty())</a>
<a name="ln1256">            show_specific_help(help_key());</a>
<a name="ln1257">        break;</a>
<a name="ln1258"> </a>
<a name="ln1259">#ifdef TOUCH_UI</a>
<a name="ln1260">    case CK_TOUCH_DUMMY:  // mouse click in top/bottom region of menu</a>
<a name="ln1261">    case 0:               // do the same as &lt;enter&gt; key</a>
<a name="ln1262">        if (!(flags &amp; MF_MULTISELECT)) // bail out if not a multi-select</a>
<a name="ln1263">            return true;</a>
<a name="ln1264">#endif</a>
<a name="ln1265">    case CK_ENTER:</a>
<a name="ln1266">        if (!(flags &amp; MF_PRESELECTED) || !sel.empty())</a>
<a name="ln1267">            return false;</a>
<a name="ln1268">        // else fall through</a>
<a name="ln1269">    default:</a>
<a name="ln1270">        // Even if we do return early, lastch needs to be set first,</a>
<a name="ln1271">        // as it's sometimes checked when leaving a menu.</a>
<a name="ln1272">        keyin  = post_process(keyin);</a>
<a name="ln1273">        lastch = keyin;</a>
<a name="ln1274"> </a>
<a name="ln1275">        // If no selection at all is allowed, exit now.</a>
<a name="ln1276">        if (!(flags &amp; (MF_SINGLESELECT | MF_MULTISELECT)))</a>
<a name="ln1277">            return false;</a>
<a name="ln1278"> </a>
<a name="ln1279">        if (!is_set(MF_NO_SELECT_QTY) &amp;&amp; isadigit(keyin))</a>
<a name="ln1280">        {</a>
<a name="ln1281">            if (num &gt; 999)</a>
<a name="ln1282">                num = -1;</a>
<a name="ln1283">            num = (num == -1) ? keyin - '0' :</a>
<a name="ln1284">                                num * 10 + keyin - '0';</a>
<a name="ln1285">        }</a>
<a name="ln1286"> </a>
<a name="ln1287">        select_items(keyin, num);</a>
<a name="ln1288">        get_selected(&amp;sel);</a>
<a name="ln1289">        if (sel.size() == 1 &amp;&amp; (flags &amp; MF_SINGLESELECT))</a>
<a name="ln1290">        {</a>
<a name="ln1291">            if (!on_single_selection)</a>
<a name="ln1292">                return false;</a>
<a name="ln1293">            MenuEntry *item = sel[0];</a>
<a name="ln1294">            if (!on_single_selection(*item))</a>
<a name="ln1295">                return false;</a>
<a name="ln1296">            deselect_all();</a>
<a name="ln1297">            return true;</a>
<a name="ln1298">        }</a>
<a name="ln1299"> </a>
<a name="ln1300">        update_title();</a>
<a name="ln1301"> </a>
<a name="ln1302">        if (flags &amp; MF_ANYPRINTABLE</a>
<a name="ln1303">            &amp;&amp; (!isadigit(keyin) || is_set(MF_NO_SELECT_QTY)))</a>
<a name="ln1304">        {</a>
<a name="ln1305">            return false;</a>
<a name="ln1306">        }</a>
<a name="ln1307"> </a>
<a name="ln1308">        break;</a>
<a name="ln1309">    }</a>
<a name="ln1310"> </a>
<a name="ln1311">    if (last_selected != -1 &amp;&amp; get_cursor() == -1)</a>
<a name="ln1312">        last_selected = -1;</a>
<a name="ln1313"> </a>
<a name="ln1314">    if (!isadigit(keyin))</a>
<a name="ln1315">        num = -1;</a>
<a name="ln1316"> </a>
<a name="ln1317">#ifdef USE_TILE_WEB</a>
<a name="ln1318">    if (old_vis_first != get_first_visible())</a>
<a name="ln1319">        webtiles_update_scroll_pos();</a>
<a name="ln1320">#endif</a>
<a name="ln1321"> </a>
<a name="ln1322">    return true;</a>
<a name="ln1323">}</a>
<a name="ln1324"> </a>
<a name="ln1325">string Menu::get_select_count_string(int count) const</a>
<a name="ln1326">{</a>
<a name="ln1327">    string ret;</a>
<a name="ln1328">    if (f_selitem)</a>
<a name="ln1329">        ret = f_selitem(&amp;sel);</a>
<a name="ln1330">    else</a>
<a name="ln1331">    {</a>
<a name="ln1332">        char buf[100] = &quot;&quot;;</a>
<a name="ln1333">        if (count)</a>
<a name="ln1334">        {</a>
<a name="ln1335">            snprintf(buf, sizeof buf, &quot; (%d item%s)&quot;, count,</a>
<a name="ln1336">                    (count &gt; 1 ? &quot;s&quot; : &quot;&quot;));</a>
<a name="ln1337">        }</a>
<a name="ln1338">        ret = string(buf);</a>
<a name="ln1339">    }</a>
<a name="ln1340">    return ret + string(max(12-(int)ret.size(), 0), ' ');</a>
<a name="ln1341">}</a>
<a name="ln1342"> </a>
<a name="ln1343">vector&lt;MenuEntry*&gt; Menu::selected_entries() const</a>
<a name="ln1344">{</a>
<a name="ln1345">    vector&lt;MenuEntry*&gt; selection;</a>
<a name="ln1346">    get_selected(&amp;selection);</a>
<a name="ln1347">    return selection;</a>
<a name="ln1348">}</a>
<a name="ln1349"> </a>
<a name="ln1350">void Menu::get_selected(vector&lt;MenuEntry*&gt; *selected) const</a>
<a name="ln1351">{</a>
<a name="ln1352">    selected-&gt;clear();</a>
<a name="ln1353"> </a>
<a name="ln1354">    for (MenuEntry *item : items)</a>
<a name="ln1355">        if (item-&gt;selected())</a>
<a name="ln1356">            selected-&gt;push_back(item);</a>
<a name="ln1357">}</a>
<a name="ln1358"> </a>
<a name="ln1359">void Menu::deselect_all(bool update_view)</a>
<a name="ln1360">{</a>
<a name="ln1361">    for (int i = 0, count = items.size(); i &lt; count; ++i)</a>
<a name="ln1362">    {</a>
<a name="ln1363">        if (items[i]-&gt;level == MEL_ITEM &amp;&amp; items[i]-&gt;selected())</a>
<a name="ln1364">        {</a>
<a name="ln1365">            items[i]-&gt;select(0);</a>
<a name="ln1366">            if (update_view)</a>
<a name="ln1367">            {</a>
<a name="ln1368">                m_ui.menu-&gt;update_item(i);</a>
<a name="ln1369">#ifdef USE_TILE_WEB</a>
<a name="ln1370">                webtiles_update_item(i);</a>
<a name="ln1371">#endif</a>
<a name="ln1372">            }</a>
<a name="ln1373">        }</a>
<a name="ln1374">    }</a>
<a name="ln1375">    sel.clear();</a>
<a name="ln1376">}</a>
<a name="ln1377"> </a>
<a name="ln1378">int Menu::get_first_visible() const</a>
<a name="ln1379">{</a>
<a name="ln1380">    int y = m_ui.scroller-&gt;get_scroll();</a>
<a name="ln1381">    for (int i = 0; i &lt; (int)items.size(); i++)</a>
<a name="ln1382">    {</a>
<a name="ln1383">        int item_y2;</a>
<a name="ln1384">        m_ui.menu-&gt;get_item_region(i, nullptr, &amp;item_y2);</a>
<a name="ln1385">        if (item_y2 &gt; y)</a>
<a name="ln1386">            return i;</a>
<a name="ln1387">    }</a>
<a name="ln1388">    return items.size();</a>
<a name="ln1389">}</a>
<a name="ln1390"> </a>
<a name="ln1391">bool Menu::is_hotkey(int i, int key)</a>
<a name="ln1392">{</a>
<a name="ln1393">    bool ishotkey = items[i]-&gt;is_hotkey(key);</a>
<a name="ln1394">    return ishotkey &amp;&amp; (!is_set(MF_SELECT_BY_PAGE) || in_page(i));</a>
<a name="ln1395">}</a>
<a name="ln1396"> </a>
<a name="ln1397">void Menu::select_items(int key, int qty)</a>
<a name="ln1398">{</a>
<a name="ln1399">    if (key == ',') // Select all or apply filter if there is one.</a>
<a name="ln1400">        select_index(-1, -2);</a>
<a name="ln1401">    else if (key == '*') // Invert selection.</a>
<a name="ln1402">        select_index(-1, -1);</a>
<a name="ln1403">    else if (key == '-') // Clear selection.</a>
<a name="ln1404">        select_index(-1, 0);</a>
<a name="ln1405">    else</a>
<a name="ln1406">    {</a>
<a name="ln1407">        int first_entry = get_first_visible(), final = items.size();</a>
<a name="ln1408">        bool selected = false;</a>
<a name="ln1409"> </a>
<a name="ln1410">        // Process all items, in case user hits hotkey for an</a>
<a name="ln1411">        // item not on the current page.</a>
<a name="ln1412"> </a>
<a name="ln1413">        // We have to use some hackery to handle items that share</a>
<a name="ln1414">        // the same hotkey (as for pickup when there's a stack of</a>
<a name="ln1415">        // &gt;52 items). If there are duplicate hotkeys, the items</a>
<a name="ln1416">        // are usually separated by at least a page, so we should</a>
<a name="ln1417">        // only select the item on the current page. This is why we</a>
<a name="ln1418">        // use two loops, and check to see if we've matched an item</a>
<a name="ln1419">        // by its primary hotkey (hotkeys[0] for multiple-selection</a>
<a name="ln1420">        // menus, any hotkey for single-selection menus), in which</a>
<a name="ln1421">        // case, we stop selecting further items.</a>
<a name="ln1422">        const bool check_preselected = (key == CK_ENTER);</a>
<a name="ln1423">        for (int i = first_entry; i &lt; final; ++i)</a>
<a name="ln1424">        {</a>
<a name="ln1425">            if (check_preselected &amp;&amp; items[i]-&gt;preselected)</a>
<a name="ln1426">            {</a>
<a name="ln1427">                select_index(i, qty);</a>
<a name="ln1428">                selected = true;</a>
<a name="ln1429">                break;</a>
<a name="ln1430">            }</a>
<a name="ln1431">            else if (is_hotkey(i, key))</a>
<a name="ln1432">            {</a>
<a name="ln1433">                select_index(i, qty);</a>
<a name="ln1434">                if (items[i]-&gt;hotkeys[0] == key || is_set(MF_SINGLESELECT))</a>
<a name="ln1435">                {</a>
<a name="ln1436">                    selected = true;</a>
<a name="ln1437">                    break;</a>
<a name="ln1438">                }</a>
<a name="ln1439">            }</a>
<a name="ln1440">        }</a>
<a name="ln1441"> </a>
<a name="ln1442">        if (!selected)</a>
<a name="ln1443">        {</a>
<a name="ln1444">            for (int i = 0; i &lt; first_entry; ++i)</a>
<a name="ln1445">            {</a>
<a name="ln1446">                if (check_preselected &amp;&amp; items[i]-&gt;preselected)</a>
<a name="ln1447">                {</a>
<a name="ln1448">                    select_index(i, qty);</a>
<a name="ln1449">                    break;</a>
<a name="ln1450">                }</a>
<a name="ln1451">                else if (is_hotkey(i, key))</a>
<a name="ln1452">                {</a>
<a name="ln1453">                    select_index(i, qty);</a>
<a name="ln1454">                    break;</a>
<a name="ln1455">                }</a>
<a name="ln1456">            }</a>
<a name="ln1457">        }</a>
<a name="ln1458">    }</a>
<a name="ln1459">}</a>
<a name="ln1460"> </a>
<a name="ln1461">MonsterMenuEntry::MonsterMenuEntry(const string &amp;str, const monster_info* mon,</a>
<a name="ln1462">                                   int hotkey) :</a>
<a name="ln1463">    MenuEntry(str, MEL_ITEM, 1, hotkey)</a>
<a name="ln1464">{</a>
<a name="ln1465">    data = (void*)mon;</a>
<a name="ln1466">    quantity = 1;</a>
<a name="ln1467">}</a>
<a name="ln1468"> </a>
<a name="ln1469">FeatureMenuEntry::FeatureMenuEntry(const string &amp;str, const coord_def p,</a>
<a name="ln1470">                                   int hotkey) :</a>
<a name="ln1471">    MenuEntry(str, MEL_ITEM, 1, hotkey)</a>
<a name="ln1472">{</a>
<a name="ln1473">    if (in_bounds(p))</a>
<a name="ln1474">        feat = grd(p);</a>
<a name="ln1475">    else</a>
<a name="ln1476">        feat = DNGN_UNSEEN;</a>
<a name="ln1477">    pos      = p;</a>
<a name="ln1478">    quantity = 1;</a>
<a name="ln1479">}</a>
<a name="ln1480"> </a>
<a name="ln1481">FeatureMenuEntry::FeatureMenuEntry(const string &amp;str,</a>
<a name="ln1482">                                   const dungeon_feature_type f,</a>
<a name="ln1483">                                   int hotkey) :</a>
<a name="ln1484">    MenuEntry(str, MEL_ITEM, 1, hotkey)</a>
<a name="ln1485">{</a>
<a name="ln1486">    pos.reset();</a>
<a name="ln1487">    feat     = f;</a>
<a name="ln1488">    quantity = 1;</a>
<a name="ln1489">}</a>
<a name="ln1490"> </a>
<a name="ln1491">#ifdef USE_TILE</a>
<a name="ln1492">bool MenuEntry::get_tiles(vector&lt;tile_def&gt;&amp; tileset) const</a>
<a name="ln1493">{</a>
<a name="ln1494">    if (!Options.tile_menu_icons || tiles.empty())</a>
<a name="ln1495">        return false;</a>
<a name="ln1496"> </a>
<a name="ln1497">    tileset.insert(end(tileset), begin(tiles), end(tiles));</a>
<a name="ln1498">    return true;</a>
<a name="ln1499">}</a>
<a name="ln1500">#else</a>
<a name="ln1501">bool MenuEntry::get_tiles(vector&lt;tile_def&gt;&amp; /*tileset*/) const { return false; }</a>
<a name="ln1502">#endif</a>
<a name="ln1503"> </a>
<a name="ln1504">#ifdef USE_TILE</a>
<a name="ln1505">PlayerMenuEntry::PlayerMenuEntry(const string &amp;str) :</a>
<a name="ln1506">    MenuEntry(str, MEL_ITEM, 1)</a>
<a name="ln1507">{</a>
<a name="ln1508">    quantity = 1;</a>
<a name="ln1509">}</a>
<a name="ln1510"> </a>
<a name="ln1511">void MenuEntry::add_tile(tile_def tile)</a>
<a name="ln1512">{</a>
<a name="ln1513">    tiles.push_back(tile);</a>
<a name="ln1514">}</a>
<a name="ln1515"> </a>
<a name="ln1516">bool MonsterMenuEntry::get_tiles(vector&lt;tile_def&gt;&amp; tileset) const</a>
<a name="ln1517">{</a>
<a name="ln1518">    if (!Options.tile_menu_icons)</a>
<a name="ln1519">        return false;</a>
<a name="ln1520"> </a>
<a name="ln1521">    monster_info* m = (monster_info*)(data);</a>
<a name="ln1522">    if (!m)</a>
<a name="ln1523">        return false;</a>
<a name="ln1524"> </a>
<a name="ln1525">    MenuEntry::get_tiles(tileset);</a>
<a name="ln1526"> </a>
<a name="ln1527">    const bool    fake = m-&gt;props.exists(&quot;fake&quot;);</a>
<a name="ln1528">    const coord_def c  = m-&gt;pos;</a>
<a name="ln1529">    tileidx_t       ch = TILE_FLOOR_NORMAL;</a>
<a name="ln1530"> </a>
<a name="ln1531">    if (!fake)</a>
<a name="ln1532">    {</a>
<a name="ln1533">        ch = tileidx_feature(c);</a>
<a name="ln1534">        if (ch == TILE_FLOOR_NORMAL)</a>
<a name="ln1535">            ch = env.tile_flv(c).floor;</a>
<a name="ln1536">        else if (ch == TILE_WALL_NORMAL)</a>
<a name="ln1537">            ch = env.tile_flv(c).wall;</a>
<a name="ln1538">    }</a>
<a name="ln1539"> </a>
<a name="ln1540">    tileset.emplace_back(ch, get_dngn_tex(ch));</a>
<a name="ln1541"> </a>
<a name="ln1542">    if (m-&gt;attitude == ATT_FRIENDLY)</a>
<a name="ln1543">        tileset.emplace_back(TILE_HALO_FRIENDLY, TEX_FEAT);</a>
<a name="ln1544">    else if (m-&gt;attitude == ATT_GOOD_NEUTRAL || m-&gt;attitude == ATT_STRICT_NEUTRAL)</a>
<a name="ln1545">        tileset.emplace_back(TILE_HALO_GD_NEUTRAL, TEX_FEAT);</a>
<a name="ln1546">    else if (m-&gt;neutral())</a>
<a name="ln1547">        tileset.emplace_back(TILE_HALO_NEUTRAL, TEX_FEAT);</a>
<a name="ln1548">    else</a>
<a name="ln1549">        switch (m-&gt;threat)</a>
<a name="ln1550">        {</a>
<a name="ln1551">        case MTHRT_TRIVIAL:</a>
<a name="ln1552">            if (Options.tile_show_threat_levels.find(&quot;trivial&quot;) != string::npos)</a>
<a name="ln1553">                tileset.emplace_back(TILE_THREAT_TRIVIAL, TEX_FEAT);</a>
<a name="ln1554">            break;</a>
<a name="ln1555">        case MTHRT_EASY:</a>
<a name="ln1556">            if (Options.tile_show_threat_levels.find(&quot;easy&quot;) != string::npos)</a>
<a name="ln1557">                tileset.emplace_back(TILE_THREAT_EASY, TEX_FEAT);</a>
<a name="ln1558">            break;</a>
<a name="ln1559">        case MTHRT_TOUGH:</a>
<a name="ln1560">            if (Options.tile_show_threat_levels.find(&quot;tough&quot;) != string::npos)</a>
<a name="ln1561">                tileset.emplace_back(TILE_THREAT_TOUGH, TEX_FEAT);</a>
<a name="ln1562">            break;</a>
<a name="ln1563">        case MTHRT_NASTY:</a>
<a name="ln1564">            if (Options.tile_show_threat_levels.find(&quot;nasty&quot;) != string::npos)</a>
<a name="ln1565">                tileset.emplace_back(TILE_THREAT_NASTY, TEX_FEAT);</a>
<a name="ln1566">            break;</a>
<a name="ln1567">        default:</a>
<a name="ln1568">            break;</a>
<a name="ln1569">        }</a>
<a name="ln1570"> </a>
<a name="ln1571">    if (m-&gt;type == MONS_DANCING_WEAPON)</a>
<a name="ln1572">    {</a>
<a name="ln1573">        // For fake dancing weapons, just use a generic long sword, since</a>
<a name="ln1574">        // fake monsters won't have a real item equipped.</a>
<a name="ln1575">        item_def item;</a>
<a name="ln1576">        if (fake)</a>
<a name="ln1577">        {</a>
<a name="ln1578">            item.base_type = OBJ_WEAPONS;</a>
<a name="ln1579">            item.sub_type  = WPN_LONG_SWORD;</a>
<a name="ln1580">            item.quantity  = 1;</a>
<a name="ln1581">        }</a>
<a name="ln1582">        else</a>
<a name="ln1583">            item = *m-&gt;inv[MSLOT_WEAPON];</a>
<a name="ln1584"> </a>
<a name="ln1585">        tileset.emplace_back(tileidx_item(item), TEX_DEFAULT);</a>
<a name="ln1586">        tileset.emplace_back(TILEI_ANIMATED_WEAPON, TEX_ICONS);</a>
<a name="ln1587">    }</a>
<a name="ln1588">    else if (mons_is_draconian(m-&gt;type))</a>
<a name="ln1589">    {</a>
<a name="ln1590">        tileset.emplace_back(tileidx_draco_base(*m), TEX_PLAYER);</a>
<a name="ln1591">        const tileidx_t job = tileidx_draco_job(*m);</a>
<a name="ln1592">        if (job)</a>
<a name="ln1593">            tileset.emplace_back(job, TEX_PLAYER);</a>
<a name="ln1594">    }</a>
<a name="ln1595">    else if (mons_is_demonspawn(m-&gt;type))</a>
<a name="ln1596">    {</a>
<a name="ln1597">        tileset.emplace_back(tileidx_demonspawn_base(*m), TEX_PLAYER);</a>
<a name="ln1598">        const tileidx_t job = tileidx_demonspawn_job(*m);</a>
<a name="ln1599">        if (job)</a>
<a name="ln1600">            tileset.emplace_back(job, TEX_PLAYER);</a>
<a name="ln1601">    }</a>
<a name="ln1602">    else</a>
<a name="ln1603">    {</a>
<a name="ln1604">        tileidx_t idx = tileidx_monster(*m) &amp; TILE_FLAG_MASK;</a>
<a name="ln1605">        tileset.emplace_back(idx, TEX_PLAYER);</a>
<a name="ln1606">    }</a>
<a name="ln1607"> </a>
<a name="ln1608">    // A fake monster might not have its ghost member set up properly.</a>
<a name="ln1609">    if (!fake &amp;&amp; m-&gt;ground_level())</a>
<a name="ln1610">    {</a>
<a name="ln1611">        if (ch == TILE_DNGN_LAVA)</a>
<a name="ln1612">            tileset.emplace_back(TILEI_MASK_LAVA, TEX_ICONS);</a>
<a name="ln1613">        else if (ch == TILE_DNGN_SHALLOW_WATER)</a>
<a name="ln1614">            tileset.emplace_back(TILEI_MASK_SHALLOW_WATER, TEX_ICONS);</a>
<a name="ln1615">        else if (ch == TILE_DNGN_DEEP_WATER)</a>
<a name="ln1616">            tileset.emplace_back(TILEI_MASK_DEEP_WATER, TEX_ICONS);</a>
<a name="ln1617">        else if (ch == TILE_DNGN_SHALLOW_WATER_MURKY)</a>
<a name="ln1618">            tileset.emplace_back(TILEI_MASK_SHALLOW_WATER_MURKY, TEX_ICONS);</a>
<a name="ln1619">        else if (ch == TILE_DNGN_DEEP_WATER_MURKY)</a>
<a name="ln1620">            tileset.emplace_back(TILEI_MASK_DEEP_WATER_MURKY, TEX_ICONS);</a>
<a name="ln1621">    }</a>
<a name="ln1622"> </a>
<a name="ln1623">    string damage_desc;</a>
<a name="ln1624">    mon_dam_level_type damage_level = m-&gt;dam;</a>
<a name="ln1625"> </a>
<a name="ln1626">    switch (damage_level)</a>
<a name="ln1627">    {</a>
<a name="ln1628">    case MDAM_DEAD:</a>
<a name="ln1629">    case MDAM_ALMOST_DEAD:</a>
<a name="ln1630">        tileset.emplace_back(TILEI_MDAM_ALMOST_DEAD, TEX_ICONS);</a>
<a name="ln1631">        break;</a>
<a name="ln1632">    case MDAM_SEVERELY_DAMAGED:</a>
<a name="ln1633">        tileset.emplace_back(TILEI_MDAM_SEVERELY_DAMAGED, TEX_ICONS);</a>
<a name="ln1634">        break;</a>
<a name="ln1635">    case MDAM_HEAVILY_DAMAGED:</a>
<a name="ln1636">        tileset.emplace_back(TILEI_MDAM_HEAVILY_DAMAGED, TEX_ICONS);</a>
<a name="ln1637">        break;</a>
<a name="ln1638">    case MDAM_MODERATELY_DAMAGED:</a>
<a name="ln1639">        tileset.emplace_back(TILEI_MDAM_MODERATELY_DAMAGED, TEX_ICONS);</a>
<a name="ln1640">        break;</a>
<a name="ln1641">    case MDAM_LIGHTLY_DAMAGED:</a>
<a name="ln1642">        tileset.emplace_back(TILEI_MDAM_LIGHTLY_DAMAGED, TEX_ICONS);</a>
<a name="ln1643">        break;</a>
<a name="ln1644">    case MDAM_OKAY:</a>
<a name="ln1645">    default:</a>
<a name="ln1646">        // no flag for okay.</a>
<a name="ln1647">        break;</a>
<a name="ln1648">    }</a>
<a name="ln1649"> </a>
<a name="ln1650">    if (m-&gt;attitude == ATT_FRIENDLY)</a>
<a name="ln1651">        tileset.emplace_back(TILEI_FRIENDLY, TEX_ICONS);</a>
<a name="ln1652">    else if (m-&gt;attitude == ATT_GOOD_NEUTRAL || m-&gt;attitude == ATT_STRICT_NEUTRAL)</a>
<a name="ln1653">        tileset.emplace_back(TILEI_GOOD_NEUTRAL, TEX_ICONS);</a>
<a name="ln1654">    else if (m-&gt;neutral())</a>
<a name="ln1655">        tileset.emplace_back(TILEI_NEUTRAL, TEX_ICONS);</a>
<a name="ln1656">    else if (m-&gt;is(MB_FLEEING))</a>
<a name="ln1657">        tileset.emplace_back(TILEI_FLEEING, TEX_ICONS);</a>
<a name="ln1658">    else if (m-&gt;is(MB_STABBABLE))</a>
<a name="ln1659">        tileset.emplace_back(TILEI_STAB_BRAND, TEX_ICONS);</a>
<a name="ln1660">    else if (m-&gt;is(MB_DISTRACTED))</a>
<a name="ln1661">        tileset.emplace_back(TILEI_MAY_STAB_BRAND, TEX_ICONS);</a>
<a name="ln1662"> </a>
<a name="ln1663">    return true;</a>
<a name="ln1664">}</a>
<a name="ln1665"> </a>
<a name="ln1666">bool FeatureMenuEntry::get_tiles(vector&lt;tile_def&gt;&amp; tileset) const</a>
<a name="ln1667">{</a>
<a name="ln1668">    if (!Options.tile_menu_icons)</a>
<a name="ln1669">        return false;</a>
<a name="ln1670"> </a>
<a name="ln1671">    if (feat == DNGN_UNSEEN)</a>
<a name="ln1672">        return false;</a>
<a name="ln1673"> </a>
<a name="ln1674">    MenuEntry::get_tiles(tileset);</a>
<a name="ln1675"> </a>
<a name="ln1676">    tileidx_t tile = tileidx_feature(pos);</a>
<a name="ln1677">    tileset.emplace_back(tile, get_dngn_tex(tile));</a>
<a name="ln1678"> </a>
<a name="ln1679">    if (in_bounds(pos) &amp;&amp; is_unknown_stair(pos))</a>
<a name="ln1680">        tileset.emplace_back(TILEI_NEW_STAIR, TEX_ICONS);</a>
<a name="ln1681"> </a>
<a name="ln1682">    if (in_bounds(pos) &amp;&amp; is_unknown_transporter(pos))</a>
<a name="ln1683">        tileset.emplace_back(TILEI_NEW_TRANSPORTER, TEX_ICONS);</a>
<a name="ln1684"> </a>
<a name="ln1685">    return true;</a>
<a name="ln1686">}</a>
<a name="ln1687"> </a>
<a name="ln1688">bool PlayerMenuEntry::get_tiles(vector&lt;tile_def&gt;&amp; tileset) const</a>
<a name="ln1689">{</a>
<a name="ln1690">    if (!Options.tile_menu_icons)</a>
<a name="ln1691">        return false;</a>
<a name="ln1692"> </a>
<a name="ln1693">    MenuEntry::get_tiles(tileset);</a>
<a name="ln1694"> </a>
<a name="ln1695">    const player_save_info &amp;player = *static_cast&lt;player_save_info*&gt;(data);</a>
<a name="ln1696">    dolls_data equip_doll = player.doll;</a>
<a name="ln1697"> </a>
<a name="ln1698">    // FIXME: Implement this logic in one place in e.g. pack_doll_buf().</a>
<a name="ln1699">    int p_order[TILEP_PART_MAX] =</a>
<a name="ln1700">    {</a>
<a name="ln1701">        TILEP_PART_SHADOW,  //  0</a>
<a name="ln1702">        TILEP_PART_HALO,</a>
<a name="ln1703">        TILEP_PART_ENCH,</a>
<a name="ln1704">        TILEP_PART_DRCWING,</a>
<a name="ln1705">        TILEP_PART_CLOAK,</a>
<a name="ln1706">        TILEP_PART_BASE,    //  5</a>
<a name="ln1707">        TILEP_PART_BOOTS,</a>
<a name="ln1708">        TILEP_PART_LEG,</a>
<a name="ln1709">        TILEP_PART_BODY,</a>
<a name="ln1710">        TILEP_PART_ARM,</a>
<a name="ln1711">        TILEP_PART_HAIR,</a>
<a name="ln1712">        TILEP_PART_BEARD,</a>
<a name="ln1713">        TILEP_PART_DRCHEAD,  // 15</a>
<a name="ln1714">        TILEP_PART_HELM,</a>
<a name="ln1715">        TILEP_PART_HAND1,   // 10</a>
<a name="ln1716">        TILEP_PART_HAND2,</a>
<a name="ln1717">    };</a>
<a name="ln1718"> </a>
<a name="ln1719">    int flags[TILEP_PART_MAX];</a>
<a name="ln1720">    tilep_calc_flags(equip_doll, flags);</a>
<a name="ln1721"> </a>
<a name="ln1722">    // For skirts, boots go under the leg armour. For pants, they go over.</a>
<a name="ln1723">    if (equip_doll.parts[TILEP_PART_LEG] &lt; TILEP_LEG_SKIRT_OFS)</a>
<a name="ln1724">    {</a>
<a name="ln1725">        p_order[6] = TILEP_PART_BOOTS;</a>
<a name="ln1726">        p_order[7] = TILEP_PART_LEG;</a>
<a name="ln1727">    }</a>
<a name="ln1728"> </a>
<a name="ln1729">    // Special case bardings from being cut off.</a>
<a name="ln1730">    bool is_naga = (equip_doll.parts[TILEP_PART_BASE] == TILEP_BASE_NAGA</a>
<a name="ln1731">                    || equip_doll.parts[TILEP_PART_BASE] == TILEP_BASE_NAGA + 1);</a>
<a name="ln1732">    if (equip_doll.parts[TILEP_PART_BOOTS] &gt;= TILEP_BOOTS_NAGA_BARDING</a>
<a name="ln1733">        &amp;&amp; equip_doll.parts[TILEP_PART_BOOTS] &lt;= TILEP_BOOTS_NAGA_BARDING_RED)</a>
<a name="ln1734">    {</a>
<a name="ln1735">        flags[TILEP_PART_BOOTS] = is_naga ? TILEP_FLAG_NORMAL : TILEP_FLAG_HIDE;</a>
<a name="ln1736">    }</a>
<a name="ln1737"> </a>
<a name="ln1738">    bool is_cent = (equip_doll.parts[TILEP_PART_BASE] == TILEP_BASE_CENTAUR</a>
<a name="ln1739">                    || equip_doll.parts[TILEP_PART_BASE] == TILEP_BASE_CENTAUR + 1);</a>
<a name="ln1740">    if (equip_doll.parts[TILEP_PART_BOOTS] &gt;= TILEP_BOOTS_CENTAUR_BARDING</a>
<a name="ln1741">        &amp;&amp; equip_doll.parts[TILEP_PART_BOOTS] &lt;= TILEP_BOOTS_CENTAUR_BARDING_RED)</a>
<a name="ln1742">    {</a>
<a name="ln1743">        flags[TILEP_PART_BOOTS] = is_cent ? TILEP_FLAG_NORMAL : TILEP_FLAG_HIDE;</a>
<a name="ln1744">    }</a>
<a name="ln1745"> </a>
<a name="ln1746">    for (int i = 0; i &lt; TILEP_PART_MAX; ++i)</a>
<a name="ln1747">    {</a>
<a name="ln1748">        const int p   = p_order[i];</a>
<a name="ln1749">        const int idx = equip_doll.parts[p];</a>
<a name="ln1750">        if (idx == 0 || idx == TILEP_SHOW_EQUIP || flags[p] == TILEP_FLAG_HIDE)</a>
<a name="ln1751">            continue;</a>
<a name="ln1752"> </a>
<a name="ln1753">        ASSERT_RANGE(idx, TILE_MAIN_MAX, TILEP_PLAYER_MAX);</a>
<a name="ln1754"> </a>
<a name="ln1755">        int ymax = TILE_Y;</a>
<a name="ln1756"> </a>
<a name="ln1757">        if (flags[p] == TILEP_FLAG_CUT_CENTAUR</a>
<a name="ln1758">            || flags[p] == TILEP_FLAG_CUT_NAGA)</a>
<a name="ln1759">        {</a>
<a name="ln1760">            ymax = 18;</a>
<a name="ln1761">        }</a>
<a name="ln1762"> </a>
<a name="ln1763">        tileset.emplace_back(idx, TEX_PLAYER, ymax);</a>
<a name="ln1764">    }</a>
<a name="ln1765"> </a>
<a name="ln1766">    return true;</a>
<a name="ln1767">}</a>
<a name="ln1768">#endif</a>
<a name="ln1769"> </a>
<a name="ln1770">bool Menu::is_selectable(int item) const</a>
<a name="ln1771">{</a>
<a name="ln1772">    if (select_filter.empty())</a>
<a name="ln1773">        return true;</a>
<a name="ln1774"> </a>
<a name="ln1775">    string text = items[item]-&gt;get_filter_text();</a>
<a name="ln1776">    for (const text_pattern &amp;pat : select_filter)</a>
<a name="ln1777">        if (pat.matches(text))</a>
<a name="ln1778">            return true;</a>
<a name="ln1779"> </a>
<a name="ln1780">    return false;</a>
<a name="ln1781">}</a>
<a name="ln1782"> </a>
<a name="ln1783">void Menu::select_item_index(int idx, int qty, bool draw_cursor)</a>
<a name="ln1784">{</a>
<a name="ln1785">    const int old_cursor = get_cursor();</a>
<a name="ln1786"> </a>
<a name="ln1787">    last_selected = idx;</a>
<a name="ln1788">    items[idx]-&gt;select(qty);</a>
<a name="ln1789">    m_ui.menu-&gt;update_item(idx);</a>
<a name="ln1790">#ifdef USE_TILE_WEB</a>
<a name="ln1791">    webtiles_update_item(idx);</a>
<a name="ln1792">#endif</a>
<a name="ln1793"> </a>
<a name="ln1794">    if (draw_cursor)</a>
<a name="ln1795">    {</a>
<a name="ln1796">        int it_count = items.size();</a>
<a name="ln1797"> </a>
<a name="ln1798">        const int new_cursor = get_cursor();</a>
<a name="ln1799">        if (old_cursor != -1 &amp;&amp; old_cursor &lt; it_count</a>
<a name="ln1800">            &amp;&amp; items[old_cursor]-&gt;level == MEL_ITEM)</a>
<a name="ln1801">        {</a>
<a name="ln1802">            m_ui.menu-&gt;update_item(old_cursor);</a>
<a name="ln1803">        }</a>
<a name="ln1804">        if (new_cursor != -1 &amp;&amp; new_cursor &lt; it_count</a>
<a name="ln1805">            &amp;&amp; items[new_cursor]-&gt;level == MEL_ITEM)</a>
<a name="ln1806">        {</a>
<a name="ln1807">            m_ui.menu-&gt;update_item(new_cursor);</a>
<a name="ln1808">        }</a>
<a name="ln1809">    }</a>
<a name="ln1810">}</a>
<a name="ln1811"> </a>
<a name="ln1812">void Menu::select_index(int index, int qty)</a>
<a name="ln1813">{</a>
<a name="ln1814">    int first_vis = get_first_visible();</a>
<a name="ln1815"> </a>
<a name="ln1816">    int si = index == -1 ? first_vis : index;</a>
<a name="ln1817"> </a>
<a name="ln1818">    if (index == -1)</a>
<a name="ln1819">    {</a>
<a name="ln1820">        if (flags &amp; MF_MULTISELECT)</a>
<a name="ln1821">        {</a>
<a name="ln1822">            for (int i = 0, count = items.size(); i &lt; count; ++i)</a>
<a name="ln1823">            {</a>
<a name="ln1824">                if (items[i]-&gt;level != MEL_ITEM</a>
<a name="ln1825">                    || items[i]-&gt;hotkeys.empty())</a>
<a name="ln1826">                {</a>
<a name="ln1827">                    continue;</a>
<a name="ln1828">                }</a>
<a name="ln1829">                if (is_hotkey(i, items[i]-&gt;hotkeys[0])</a>
<a name="ln1830">                    &amp;&amp; (qty != -2 || is_selectable(i)))</a>
<a name="ln1831">                {</a>
<a name="ln1832">                    select_item_index(i, qty);</a>
<a name="ln1833">                }</a>
<a name="ln1834">            }</a>
<a name="ln1835">        }</a>
<a name="ln1836">    }</a>
<a name="ln1837">    else if (items[si]-&gt;level == MEL_SUBTITLE &amp;&amp; (flags &amp; MF_MULTISELECT))</a>
<a name="ln1838">    {</a>
<a name="ln1839">        for (int i = si + 1, count = items.size(); i &lt; count; ++i)</a>
<a name="ln1840">        {</a>
<a name="ln1841">            if (items[i]-&gt;level != MEL_ITEM</a>
<a name="ln1842">                || items[i]-&gt;hotkeys.empty())</a>
<a name="ln1843">            {</a>
<a name="ln1844">                continue;</a>
<a name="ln1845">            }</a>
<a name="ln1846">            if (is_hotkey(i, items[i]-&gt;hotkeys[0]))</a>
<a name="ln1847">                select_item_index(i, qty);</a>
<a name="ln1848">        }</a>
<a name="ln1849">    }</a>
<a name="ln1850">    else if (items[si]-&gt;level == MEL_ITEM</a>
<a name="ln1851">             &amp;&amp; (flags &amp; (MF_SINGLESELECT | MF_MULTISELECT)))</a>
<a name="ln1852">    {</a>
<a name="ln1853">        select_item_index(si, qty, (flags &amp; MF_MULTISELECT));</a>
<a name="ln1854">    }</a>
<a name="ln1855">}</a>
<a name="ln1856"> </a>
<a name="ln1857">int Menu::get_entry_index(const MenuEntry *e) const</a>
<a name="ln1858">{</a>
<a name="ln1859">    int index = 0;</a>
<a name="ln1860">    for (const auto &amp;item : items)</a>
<a name="ln1861">    {</a>
<a name="ln1862">        if (item == e)</a>
<a name="ln1863">            return index;</a>
<a name="ln1864"> </a>
<a name="ln1865">        if (item-&gt;quantity != 0)</a>
<a name="ln1866">            index++;</a>
<a name="ln1867">    }</a>
<a name="ln1868"> </a>
<a name="ln1869">    return -1;</a>
<a name="ln1870">}</a>
<a name="ln1871"> </a>
<a name="ln1872">void Menu::update_menu(bool update_entries)</a>
<a name="ln1873">{</a>
<a name="ln1874">    m_ui.menu-&gt;update_items();</a>
<a name="ln1875">    update_title();</a>
<a name="ln1876"> </a>
<a name="ln1877">    if (!alive)</a>
<a name="ln1878">        return;</a>
<a name="ln1879">#ifdef USE_TILE_WEB</a>
<a name="ln1880">    if (update_entries)</a>
<a name="ln1881">    {</a>
<a name="ln1882">        tiles.json_open_object();</a>
<a name="ln1883">        tiles.json_write_string(&quot;msg&quot;, &quot;update_menu&quot;);</a>
<a name="ln1884">        tiles.json_write_int(&quot;total_items&quot;, items.size());</a>
<a name="ln1885">        tiles.json_close_object();</a>
<a name="ln1886">        tiles.finish_message();</a>
<a name="ln1887">        if (items.size() &gt; 0)</a>
<a name="ln1888">            webtiles_update_items(0, items.size() - 1);</a>
<a name="ln1889">    }</a>
<a name="ln1890">#else</a>
<a name="ln1891">    UNUSED(update_entries);</a>
<a name="ln1892">#endif</a>
<a name="ln1893">}</a>
<a name="ln1894"> </a>
<a name="ln1895">void Menu::update_more()</a>
<a name="ln1896">{</a>
<a name="ln1897">    if (crawl_state.doing_prev_cmd_again)</a>
<a name="ln1898">        return;</a>
<a name="ln1899">    m_ui.more-&gt;set_text(more);</a>
<a name="ln1900"> </a>
<a name="ln1901">    bool show_more = !more.ops.empty();</a>
<a name="ln1902">#ifdef USE_TILE_LOCAL</a>
<a name="ln1903">    show_more = show_more &amp;&amp; !m_keyhelp_more;</a>
<a name="ln1904">#endif</a>
<a name="ln1905">    m_ui.more-&gt;set_visible(show_more);</a>
<a name="ln1906"> </a>
<a name="ln1907">#ifdef USE_TILE_WEB</a>
<a name="ln1908">    if (!alive)</a>
<a name="ln1909">        return;</a>
<a name="ln1910">    tiles.json_open_object();</a>
<a name="ln1911">    tiles.json_write_string(&quot;msg&quot;, &quot;update_menu&quot;);</a>
<a name="ln1912">    tiles.json_write_string(&quot;more&quot;,</a>
<a name="ln1913">            m_keyhelp_more ? &quot;&quot; : more.to_colour_string());</a>
<a name="ln1914">    tiles.json_close_object();</a>
<a name="ln1915">    tiles.finish_message();</a>
<a name="ln1916">#endif</a>
<a name="ln1917">}</a>
<a name="ln1918"> </a>
<a name="ln1919">int Menu::item_colour(const MenuEntry *entry) const</a>
<a name="ln1920">{</a>
<a name="ln1921">    int icol = -1;</a>
<a name="ln1922">    if (highlighter)</a>
<a name="ln1923">        icol = highlighter-&gt;entry_colour(entry);</a>
<a name="ln1924"> </a>
<a name="ln1925">    return icol == -1 ? entry-&gt;colour : icol;</a>
<a name="ln1926">}</a>
<a name="ln1927"> </a>
<a name="ln1928">formatted_string Menu::calc_title() { return formatted_string(); }</a>
<a name="ln1929"> </a>
<a name="ln1930">void Menu::update_title()</a>
<a name="ln1931">{</a>
<a name="ln1932">    if (!title || crawl_state.doing_prev_cmd_again)</a>
<a name="ln1933">        return;</a>
<a name="ln1934"> </a>
<a name="ln1935">    formatted_string fs;</a>
<a name="ln1936"> </a>
<a name="ln1937">    if (m_filter)</a>
<a name="ln1938">    {</a>
<a name="ln1939">        fs.textcolour(WHITE);</a>
<a name="ln1940">        fs.cprintf(&quot;Select what? (regex) %s&quot;, m_filter-&gt;get_text().c_str());</a>
<a name="ln1941">    } else</a>
<a name="ln1942">        fs = calc_title();</a>
<a name="ln1943"> </a>
<a name="ln1944">    if (fs.empty())</a>
<a name="ln1945">    {</a>
<a name="ln1946">        const bool first = (action_cycle == CYCLE_NONE</a>
<a name="ln1947">                            || menu_action == ACT_EXECUTE);</a>
<a name="ln1948">        if (!first)</a>
<a name="ln1949">            ASSERT(title2);</a>
<a name="ln1950"> </a>
<a name="ln1951">        auto col = item_colour(first ? title : title2);</a>
<a name="ln1952">        string text = (first ? title-&gt;get_text() : title2-&gt;get_text());</a>
<a name="ln1953"> </a>
<a name="ln1954">        fs.textcolour(col);</a>
<a name="ln1955"> </a>
<a name="ln1956">        if (flags &amp; MF_ALLOW_FORMATTING)</a>
<a name="ln1957">            fs += formatted_string::parse_string(text);</a>
<a name="ln1958">        else</a>
<a name="ln1959">            fs.cprintf(&quot;%s&quot;, text.c_str());</a>
<a name="ln1960">    }</a>
<a name="ln1961"> </a>
<a name="ln1962">    if (!is_set(MF_QUIET_SELECT) &amp;&amp; is_set(MF_MULTISELECT))</a>
<a name="ln1963">        fs.cprintf(&quot;%s&quot;, get_select_count_string(sel.size()).c_str());</a>
<a name="ln1964"> </a>
<a name="ln1965">    if (m_indent_title)</a>
<a name="ln1966">    {</a>
<a name="ln1967">        formatted_string indented(&quot; &quot;);</a>
<a name="ln1968">        indented += fs;</a>
<a name="ln1969">        fs = indented;</a>
<a name="ln1970">    }</a>
<a name="ln1971"> </a>
<a name="ln1972">#ifdef USE_TILE_LOCAL</a>
<a name="ln1973">    const bool tile_indent = m_indent_title &amp;&amp; Options.tile_menu_icons;</a>
<a name="ln1974">    m_ui.title-&gt;set_margin_for_sdl(0, UIMenu::item_pad+UIMenu::pad_right, 10,</a>
<a name="ln1975">            UIMenu::item_pad + (tile_indent ? 38 : 0));</a>
<a name="ln1976">    m_ui.more-&gt;set_margin_for_sdl(10, UIMenu::item_pad+UIMenu::pad_right, 0, 0);</a>
<a name="ln1977">#endif</a>
<a name="ln1978">    m_ui.title-&gt;set_text(fs);</a>
<a name="ln1979">#ifdef USE_TILE_WEB</a>
<a name="ln1980">    webtiles_set_title(fs);</a>
<a name="ln1981">#endif</a>
<a name="ln1982">}</a>
<a name="ln1983"> </a>
<a name="ln1984">bool Menu::in_page(int index) const</a>
<a name="ln1985">{</a>
<a name="ln1986">    int y1, y2;</a>
<a name="ln1987">    m_ui.menu-&gt;get_item_region(index, &amp;y1, &amp;y2);</a>
<a name="ln1988">    int vph = m_ui.menu-&gt;get_region().height;</a>
<a name="ln1989">    int vpy = m_ui.scroller-&gt;get_scroll();</a>
<a name="ln1990">    return (vpy &lt; y1 &amp;&amp; y1 &lt; vpy+vph) || (vpy &lt; y2 &amp;&amp; y2 &lt; vpy+vph);</a>
<a name="ln1991">}</a>
<a name="ln1992"> </a>
<a name="ln1993">bool Menu::page_down()</a>
<a name="ln1994">{</a>
<a name="ln1995">    int dy = m_ui.scroller-&gt;get_region().height;</a>
<a name="ln1996">    int y = m_ui.scroller-&gt;get_scroll();</a>
<a name="ln1997">    bool at_bottom = y+dy &gt;= m_ui.menu-&gt;get_region().height;</a>
<a name="ln1998">    m_ui.scroller-&gt;set_scroll(y+dy);</a>
<a name="ln1999">#ifndef USE_TILE_LOCAL</a>
<a name="ln2000">    if (!at_bottom)</a>
<a name="ln2001">        m_ui.menu-&gt;set_showable_height(y+dy+dy);</a>
<a name="ln2002">#endif</a>
<a name="ln2003">    return !at_bottom;</a>
<a name="ln2004">}</a>
<a name="ln2005"> </a>
<a name="ln2006">bool Menu::page_up()</a>
<a name="ln2007">{</a>
<a name="ln2008">    int dy = m_ui.scroller-&gt;get_region().height;</a>
<a name="ln2009">    int y = m_ui.scroller-&gt;get_scroll();</a>
<a name="ln2010">    m_ui.scroller-&gt;set_scroll(y-dy);</a>
<a name="ln2011">#ifndef USE_TILE_LOCAL</a>
<a name="ln2012">    m_ui.menu-&gt;set_showable_height(y);</a>
<a name="ln2013">#endif</a>
<a name="ln2014">    return y &gt; 0;</a>
<a name="ln2015">}</a>
<a name="ln2016"> </a>
<a name="ln2017">bool Menu::line_down()</a>
<a name="ln2018">{</a>
<a name="ln2019">    int index = get_first_visible();</a>
<a name="ln2020">    int first_vis_y;</a>
<a name="ln2021">    m_ui.menu-&gt;get_item_region(index, &amp;first_vis_y, nullptr);</a>
<a name="ln2022"> </a>
<a name="ln2023">    index++;</a>
<a name="ln2024">    while (index &lt; (int)items.size())</a>
<a name="ln2025">    {</a>
<a name="ln2026">        int y;</a>
<a name="ln2027">        m_ui.menu-&gt;get_item_region(index, &amp;y, nullptr);</a>
<a name="ln2028">        index++;</a>
<a name="ln2029">        if (y == first_vis_y)</a>
<a name="ln2030">            continue;</a>
<a name="ln2031">        m_ui.scroller-&gt;set_scroll(y);</a>
<a name="ln2032">        return true;</a>
<a name="ln2033">    }</a>
<a name="ln2034">    return false;</a>
<a name="ln2035">}</a>
<a name="ln2036"> </a>
<a name="ln2037">// XXX: doesn't do exactly what we want</a>
<a name="ln2038">bool Menu::line_up()</a>
<a name="ln2039">{</a>
<a name="ln2040">    int index = get_first_visible();</a>
<a name="ln2041">    if (index &gt; 0)</a>
<a name="ln2042">    {</a>
<a name="ln2043">        int y;</a>
<a name="ln2044">        m_ui.menu-&gt;get_item_region(index-1, &amp;y, nullptr);</a>
<a name="ln2045">        m_ui.scroller-&gt;set_scroll(y);</a>
<a name="ln2046">#ifndef USE_TILE_LOCAL</a>
<a name="ln2047">        int dy = m_ui.scroller-&gt;get_region().height;</a>
<a name="ln2048">        m_ui.menu-&gt;set_showable_height(y+dy);</a>
<a name="ln2049">#endif</a>
<a name="ln2050">        return true;</a>
<a name="ln2051">    }</a>
<a name="ln2052">    return false;</a>
<a name="ln2053">}</a>
<a name="ln2054"> </a>
<a name="ln2055">#ifdef USE_TILE_WEB</a>
<a name="ln2056">void Menu::webtiles_write_menu(bool replace) const</a>
<a name="ln2057">{</a>
<a name="ln2058">    if (crawl_state.doing_prev_cmd_again)</a>
<a name="ln2059">        return;</a>
<a name="ln2060"> </a>
<a name="ln2061">    tiles.json_open_object();</a>
<a name="ln2062">    tiles.json_write_string(&quot;msg&quot;, &quot;menu&quot;);</a>
<a name="ln2063">    tiles.json_write_bool(&quot;ui-centred&quot;, !crawl_state.need_save);</a>
<a name="ln2064">    tiles.json_write_string(&quot;tag&quot;, tag);</a>
<a name="ln2065">    tiles.json_write_int(&quot;flags&quot;, flags);</a>
<a name="ln2066">    if (replace)</a>
<a name="ln2067">        tiles.json_write_int(&quot;replace&quot;, 1);</a>
<a name="ln2068"> </a>
<a name="ln2069">    webtiles_write_title();</a>
<a name="ln2070"> </a>
<a name="ln2071">    tiles.json_write_string(&quot;more&quot;,</a>
<a name="ln2072">            m_keyhelp_more ? &quot;&quot; : more.to_colour_string());</a>
<a name="ln2073"> </a>
<a name="ln2074">    int count = items.size();</a>
<a name="ln2075">    int start = 0;</a>
<a name="ln2076">    int end = start + count;</a>
<a name="ln2077"> </a>
<a name="ln2078">    tiles.json_write_int(&quot;total_items&quot;, count);</a>
<a name="ln2079">    tiles.json_write_int(&quot;chunk_start&quot;, start);</a>
<a name="ln2080"> </a>
<a name="ln2081">    int first_entry = get_first_visible();</a>
<a name="ln2082">    if (first_entry != 0 &amp;&amp; !is_set(MF_START_AT_END))</a>
<a name="ln2083">        tiles.json_write_int(&quot;jump_to&quot;, first_entry);</a>
<a name="ln2084"> </a>
<a name="ln2085">    tiles.json_open_array(&quot;items&quot;);</a>
<a name="ln2086"> </a>
<a name="ln2087">    for (int i = start; i &lt; end; ++i)</a>
<a name="ln2088">        webtiles_write_item(items[i]);</a>
<a name="ln2089"> </a>
<a name="ln2090">    tiles.json_close_array();</a>
<a name="ln2091"> </a>
<a name="ln2092">    tiles.json_close_object();</a>
<a name="ln2093">}</a>
<a name="ln2094"> </a>
<a name="ln2095">void Menu::webtiles_scroll(int first)</a>
<a name="ln2096">{</a>
<a name="ln2097">    // catch and ignore stale scroll events</a>
<a name="ln2098">    if (first &gt;= static_cast&lt;int&gt;(items.size()))</a>
<a name="ln2099">        return;</a>
<a name="ln2100"> </a>
<a name="ln2101">    int item_y;</a>
<a name="ln2102">    m_ui.menu-&gt;get_item_region(first, &amp;item_y, nullptr);</a>
<a name="ln2103">    if (m_ui.scroller-&gt;get_scroll() != item_y)</a>
<a name="ln2104">    {</a>
<a name="ln2105">        m_ui.scroller-&gt;set_scroll(item_y);</a>
<a name="ln2106">        webtiles_update_scroll_pos();</a>
<a name="ln2107">        ui::force_render();</a>
<a name="ln2108">    }</a>
<a name="ln2109">}</a>
<a name="ln2110"> </a>
<a name="ln2111">void Menu::webtiles_handle_item_request(int start, int end)</a>
<a name="ln2112">{</a>
<a name="ln2113">    start = min(max(0, start), (int)items.size()-1);</a>
<a name="ln2114">    if (end &lt; start) end = start;</a>
<a name="ln2115">    if (end &gt;= (int)items.size())</a>
<a name="ln2116">        end = (int)items.size() - 1;</a>
<a name="ln2117"> </a>
<a name="ln2118">    tiles.json_open_object();</a>
<a name="ln2119">    tiles.json_write_string(&quot;msg&quot;, &quot;update_menu_items&quot;);</a>
<a name="ln2120"> </a>
<a name="ln2121">    tiles.json_write_int(&quot;chunk_start&quot;, start);</a>
<a name="ln2122"> </a>
<a name="ln2123">    tiles.json_open_array(&quot;items&quot;);</a>
<a name="ln2124"> </a>
<a name="ln2125">    for (int i = start; i &lt;= end; ++i)</a>
<a name="ln2126">        webtiles_write_item(items[i]);</a>
<a name="ln2127"> </a>
<a name="ln2128">    tiles.json_close_array();</a>
<a name="ln2129"> </a>
<a name="ln2130">    tiles.json_close_object();</a>
<a name="ln2131">    tiles.finish_message();</a>
<a name="ln2132">}</a>
<a name="ln2133"> </a>
<a name="ln2134">void Menu::webtiles_set_title(const formatted_string title_)</a>
<a name="ln2135">{</a>
<a name="ln2136">    if (title_.to_colour_string() != _webtiles_title.to_colour_string())</a>
<a name="ln2137">    {</a>
<a name="ln2138">        _webtiles_title_changed = true;</a>
<a name="ln2139">        _webtiles_title = title_;</a>
<a name="ln2140">    }</a>
<a name="ln2141">}</a>
<a name="ln2142"> </a>
<a name="ln2143">void Menu::webtiles_update_items(int start, int end) const</a>
<a name="ln2144">{</a>
<a name="ln2145">    ASSERT_RANGE(start, 0, (int) items.size());</a>
<a name="ln2146">    ASSERT_RANGE(end, start, (int) items.size());</a>
<a name="ln2147"> </a>
<a name="ln2148">    tiles.json_open_object();</a>
<a name="ln2149"> </a>
<a name="ln2150">    tiles.json_write_string(&quot;msg&quot;, &quot;update_menu_items&quot;);</a>
<a name="ln2151">    tiles.json_write_int(&quot;chunk_start&quot;, start);</a>
<a name="ln2152"> </a>
<a name="ln2153">    tiles.json_open_array(&quot;items&quot;);</a>
<a name="ln2154"> </a>
<a name="ln2155">    for (int i = start; i &lt;= end; ++i)</a>
<a name="ln2156">    {</a>
<a name="ln2157">        tiles.json_open_object();</a>
<a name="ln2158">        const MenuEntry* me = items[i];</a>
<a name="ln2159">        tiles.json_write_string(&quot;text&quot;, me-&gt;get_text());</a>
<a name="ln2160">        int col = item_colour(me);</a>
<a name="ln2161">        // previous colour field is deleted by client if new one not sent</a>
<a name="ln2162">        if (col != MENU_ITEM_STOCK_COLOUR)</a>
<a name="ln2163">            tiles.json_write_int(&quot;colour&quot;, col);</a>
<a name="ln2164">        webtiles_write_tiles(*me);</a>
<a name="ln2165">        tiles.json_close_object();</a>
<a name="ln2166">    }</a>
<a name="ln2167"> </a>
<a name="ln2168">    tiles.json_close_array();</a>
<a name="ln2169"> </a>
<a name="ln2170">    tiles.json_close_object();</a>
<a name="ln2171">    tiles.finish_message();</a>
<a name="ln2172">}</a>
<a name="ln2173"> </a>
<a name="ln2174"> </a>
<a name="ln2175">void Menu::webtiles_update_item(int index) const</a>
<a name="ln2176">{</a>
<a name="ln2177">    webtiles_update_items(index, index);</a>
<a name="ln2178">}</a>
<a name="ln2179"> </a>
<a name="ln2180">void Menu::webtiles_update_title() const</a>
<a name="ln2181">{</a>
<a name="ln2182">    tiles.json_open_object();</a>
<a name="ln2183">    tiles.json_write_string(&quot;msg&quot;, &quot;update_menu&quot;);</a>
<a name="ln2184">    webtiles_write_title();</a>
<a name="ln2185">    tiles.json_close_object();</a>
<a name="ln2186">    tiles.finish_message();</a>
<a name="ln2187">}</a>
<a name="ln2188"> </a>
<a name="ln2189">void Menu::webtiles_update_scroll_pos() const</a>
<a name="ln2190">{</a>
<a name="ln2191">    tiles.json_open_object();</a>
<a name="ln2192">    tiles.json_write_string(&quot;msg&quot;, &quot;menu_scroll&quot;);</a>
<a name="ln2193">    tiles.json_write_int(&quot;first&quot;, get_first_visible());</a>
<a name="ln2194">    tiles.json_close_object();</a>
<a name="ln2195">    tiles.finish_message();</a>
<a name="ln2196">}</a>
<a name="ln2197"> </a>
<a name="ln2198">void Menu::webtiles_write_title() const</a>
<a name="ln2199">{</a>
<a name="ln2200">    // the title object only exists for backwards compatibility</a>
<a name="ln2201">    tiles.json_open_object(&quot;title&quot;);</a>
<a name="ln2202">    tiles.json_write_string(&quot;text&quot;, _webtiles_title.to_colour_string());</a>
<a name="ln2203">    tiles.json_close_object(&quot;title&quot;);</a>
<a name="ln2204">}</a>
<a name="ln2205"> </a>
<a name="ln2206">void Menu::webtiles_write_tiles(const MenuEntry&amp; me) const</a>
<a name="ln2207">{</a>
<a name="ln2208">    vector&lt;tile_def&gt; t;</a>
<a name="ln2209">    if (me.get_tiles(t) &amp;&amp; !t.empty())</a>
<a name="ln2210">    {</a>
<a name="ln2211">        tiles.json_open_array(&quot;tiles&quot;);</a>
<a name="ln2212"> </a>
<a name="ln2213">        for (const tile_def &amp;tile : t)</a>
<a name="ln2214">        {</a>
<a name="ln2215">            tiles.json_open_object();</a>
<a name="ln2216"> </a>
<a name="ln2217">            tiles.json_write_int(&quot;t&quot;, tile.tile);</a>
<a name="ln2218">            tiles.json_write_int(&quot;tex&quot;, tile.tex);</a>
<a name="ln2219"> </a>
<a name="ln2220">            if (tile.ymax != TILE_Y)</a>
<a name="ln2221">                tiles.json_write_int(&quot;ymax&quot;, tile.ymax);</a>
<a name="ln2222"> </a>
<a name="ln2223">            tiles.json_close_object();</a>
<a name="ln2224">        }</a>
<a name="ln2225"> </a>
<a name="ln2226">        tiles.json_close_array();</a>
<a name="ln2227">    }</a>
<a name="ln2228">}</a>
<a name="ln2229"> </a>
<a name="ln2230">void Menu::webtiles_write_item(const MenuEntry* me) const</a>
<a name="ln2231">{</a>
<a name="ln2232">    tiles.json_open_object();</a>
<a name="ln2233"> </a>
<a name="ln2234">    if (me)</a>
<a name="ln2235">        tiles.json_write_string(&quot;text&quot;, me-&gt;get_text());</a>
<a name="ln2236">    else</a>
<a name="ln2237">    {</a>
<a name="ln2238">        tiles.json_write_string(&quot;text&quot;, &quot;&quot;);</a>
<a name="ln2239">        tiles.json_close_object();</a>
<a name="ln2240">        return;</a>
<a name="ln2241">    }</a>
<a name="ln2242"> </a>
<a name="ln2243">    if (me-&gt;quantity)</a>
<a name="ln2244">        tiles.json_write_int(&quot;q&quot;, me-&gt;quantity);</a>
<a name="ln2245"> </a>
<a name="ln2246">    int col = item_colour(me);</a>
<a name="ln2247">    if (col != MENU_ITEM_STOCK_COLOUR)</a>
<a name="ln2248">        tiles.json_write_int(&quot;colour&quot;, col);</a>
<a name="ln2249"> </a>
<a name="ln2250">    if (!me-&gt;hotkeys.empty())</a>
<a name="ln2251">    {</a>
<a name="ln2252">        tiles.json_open_array(&quot;hotkeys&quot;);</a>
<a name="ln2253">        for (int hotkey : me-&gt;hotkeys)</a>
<a name="ln2254">            tiles.json_write_int(hotkey);</a>
<a name="ln2255">        tiles.json_close_array();</a>
<a name="ln2256">    }</a>
<a name="ln2257"> </a>
<a name="ln2258">    if (me-&gt;level != MEL_NONE)</a>
<a name="ln2259">        tiles.json_write_int(&quot;level&quot;, me-&gt;level);</a>
<a name="ln2260"> </a>
<a name="ln2261">    if (me-&gt;preselected)</a>
<a name="ln2262">        tiles.json_write_int(&quot;preselected&quot;, me-&gt;preselected);</a>
<a name="ln2263"> </a>
<a name="ln2264">    webtiles_write_tiles(*me);</a>
<a name="ln2265"> </a>
<a name="ln2266">    tiles.json_close_object();</a>
<a name="ln2267">}</a>
<a name="ln2268">#endif // USE_TILE_WEB</a>
<a name="ln2269"> </a>
<a name="ln2270">/////////////////////////////////////////////////////////////////</a>
<a name="ln2271">// Menu colouring</a>
<a name="ln2272">//</a>
<a name="ln2273"> </a>
<a name="ln2274">int menu_colour(const string &amp;text, const string &amp;prefix, const string &amp;tag)</a>
<a name="ln2275">{</a>
<a name="ln2276">    const string tmp_text = prefix + text;</a>
<a name="ln2277"> </a>
<a name="ln2278">    for (const colour_mapping &amp;cm : Options.menu_colour_mappings)</a>
<a name="ln2279">    {</a>
<a name="ln2280">        if ((cm.tag.empty() || cm.tag == &quot;any&quot; || cm.tag == tag</a>
<a name="ln2281">               || cm.tag == &quot;inventory&quot; &amp;&amp; tag == &quot;pickup&quot;)</a>
<a name="ln2282">            &amp;&amp; cm.pattern.matches(tmp_text))</a>
<a name="ln2283">        {</a>
<a name="ln2284">            return cm.colour;</a>
<a name="ln2285">        }</a>
<a name="ln2286">    }</a>
<a name="ln2287">    return -1;</a>
<a name="ln2288">}</a>
<a name="ln2289"> </a>
<a name="ln2290">int MenuHighlighter::entry_colour(const MenuEntry *entry) const</a>
<a name="ln2291">{</a>
<a name="ln2292">    return entry-&gt;colour != MENU_ITEM_STOCK_COLOUR ? entry-&gt;colour</a>
<a name="ln2293">           : entry-&gt;highlight_colour();</a>
<a name="ln2294">}</a>
<a name="ln2295"> </a>
<a name="ln2296">///////////////////////////////////////////////////////////////////////</a>
<a name="ln2297">// column_composer</a>
<a name="ln2298"> </a>
<a name="ln2299">column_composer::column_composer(int cols, ...)</a>
<a name="ln2300">    : columns()</a>
<a name="ln2301">{</a>
<a name="ln2302">    ASSERT(cols &gt; 0);</a>
<a name="ln2303"> </a>
<a name="ln2304">    va_list args;</a>
<a name="ln2305">    va_start(args, cols);</a>
<a name="ln2306"> </a>
<a name="ln2307">    columns.emplace_back(1);</a>
<a name="ln2308">    int lastcol = 1;</a>
<a name="ln2309">    for (int i = 1; i &lt; cols; ++i)</a>
<a name="ln2310">    {</a>
<a name="ln2311">        int nextcol = va_arg(args, int);</a>
<a name="ln2312">        ASSERT(nextcol &gt; lastcol);</a>
<a name="ln2313"> </a>
<a name="ln2314">        lastcol = nextcol;</a>
<a name="ln2315">        columns.emplace_back(nextcol);</a>
<a name="ln2316">    }</a>
<a name="ln2317"> </a>
<a name="ln2318">    va_end(args);</a>
<a name="ln2319">}</a>
<a name="ln2320"> </a>
<a name="ln2321">void column_composer::clear()</a>
<a name="ln2322">{</a>
<a name="ln2323">    flines.clear();</a>
<a name="ln2324">}</a>
<a name="ln2325"> </a>
<a name="ln2326">void column_composer::add_formatted(int ncol,</a>
<a name="ln2327">                                    const string &amp;s,</a>
<a name="ln2328">                                    bool add_separator,</a>
<a name="ln2329">                                    int  margin)</a>
<a name="ln2330">{</a>
<a name="ln2331">    ASSERT_RANGE(ncol, 0, (int) columns.size());</a>
<a name="ln2332"> </a>
<a name="ln2333">    column &amp;col = columns[ncol];</a>
<a name="ln2334">    vector&lt;string&gt; segs = split_string(&quot;\n&quot;, s, false, true);</a>
<a name="ln2335"> </a>
<a name="ln2336">    vector&lt;formatted_string&gt; newlines;</a>
<a name="ln2337">    // Add a blank line if necessary. Blank lines will not</a>
<a name="ln2338">    // be added at page boundaries.</a>
<a name="ln2339">    if (add_separator &amp;&amp; col.lines &amp;&amp; !segs.empty())</a>
<a name="ln2340">        newlines.emplace_back();</a>
<a name="ln2341"> </a>
<a name="ln2342">    for (const string &amp;seg : segs)</a>
<a name="ln2343">        newlines.push_back(formatted_string::parse_string(seg));</a>
<a name="ln2344"> </a>
<a name="ln2345">    strip_blank_lines(newlines);</a>
<a name="ln2346"> </a>
<a name="ln2347">    compose_formatted_column(newlines,</a>
<a name="ln2348">                              col.lines,</a>
<a name="ln2349">                              margin == -1 ? col.margin : margin);</a>
<a name="ln2350"> </a>
<a name="ln2351">    col.lines += newlines.size();</a>
<a name="ln2352"> </a>
<a name="ln2353">    strip_blank_lines(flines);</a>
<a name="ln2354">}</a>
<a name="ln2355"> </a>
<a name="ln2356">vector&lt;formatted_string&gt; column_composer::formatted_lines() const</a>
<a name="ln2357">{</a>
<a name="ln2358">    return flines;</a>
<a name="ln2359">}</a>
<a name="ln2360"> </a>
<a name="ln2361">void column_composer::strip_blank_lines(vector&lt;formatted_string&gt; &amp;fs) const</a>
<a name="ln2362">{</a>
<a name="ln2363">    for (int i = fs.size() - 1; i &gt;= 0; --i)</a>
<a name="ln2364">    {</a>
<a name="ln2365">        if (fs[i].width() == 0)</a>
<a name="ln2366">            fs.erase(fs.begin() + i);</a>
<a name="ln2367">        else</a>
<a name="ln2368">            break;</a>
<a name="ln2369">    }</a>
<a name="ln2370">}</a>
<a name="ln2371"> </a>
<a name="ln2372">void column_composer::compose_formatted_column(</a>
<a name="ln2373">        const vector&lt;formatted_string&gt; &amp;lines,</a>
<a name="ln2374">        int startline,</a>
<a name="ln2375">        int margin)</a>
<a name="ln2376">{</a>
<a name="ln2377">    if (flines.size() &lt; startline + lines.size())</a>
<a name="ln2378">        flines.resize(startline + lines.size());</a>
<a name="ln2379"> </a>
<a name="ln2380">    for (unsigned i = 0, size = lines.size(); i &lt; size; ++i)</a>
<a name="ln2381">    {</a>
<a name="ln2382">        int f = i + startline;</a>
<a name="ln2383">        if (margin &gt; 1)</a>
<a name="ln2384">        {</a>
<a name="ln2385">            int xdelta = margin - flines[f].width() - 1;</a>
<a name="ln2386">            if (xdelta &gt; 0)</a>
<a name="ln2387">                flines[f].cprintf(&quot;%-*s&quot;, xdelta, &quot;&quot;);</a>
<a name="ln2388">        }</a>
<a name="ln2389">        flines[f] += lines[i];</a>
<a name="ln2390">    }</a>
<a name="ln2391">}</a>
<a name="ln2392"> </a>
<a name="ln2393">int linebreak_string(string&amp; s, int maxcol, bool indent)</a>
<a name="ln2394">{</a>
<a name="ln2395">    // [ds] Don't loop forever if the user is playing silly games with</a>
<a name="ln2396">    // their term size.</a>
<a name="ln2397">    if (maxcol &lt; 1)</a>
<a name="ln2398">        return 0;</a>
<a name="ln2399"> </a>
<a name="ln2400">    int breakcount = 0;</a>
<a name="ln2401">    string res;</a>
<a name="ln2402"> </a>
<a name="ln2403">    while (!s.empty())</a>
<a name="ln2404">    {</a>
<a name="ln2405">        res += wordwrap_line(s, maxcol, true, indent);</a>
<a name="ln2406">        if (!s.empty())</a>
<a name="ln2407">        {</a>
<a name="ln2408">            res += &quot;\n&quot;;</a>
<a name="ln2409">            breakcount++;</a>
<a name="ln2410">        }</a>
<a name="ln2411">    }</a>
<a name="ln2412">    s = res;</a>
<a name="ln2413">    return breakcount;</a>
<a name="ln2414">}</a>
<a name="ln2415"> </a>
<a name="ln2416">string get_linebreak_string(const string&amp; s, int maxcol)</a>
<a name="ln2417">{</a>
<a name="ln2418">    string r = s;</a>
<a name="ln2419">    linebreak_string(r, maxcol);</a>
<a name="ln2420">    return r;</a>
<a name="ln2421">}</a>
<a name="ln2422"> </a>
<a name="ln2423">int ToggleableMenu::pre_process(int key)</a>
<a name="ln2424">{</a>
<a name="ln2425">#ifdef TOUCH_UI</a>
<a name="ln2426">    if (find(toggle_keys.begin(), toggle_keys.end(), key) != toggle_keys.end()</a>
<a name="ln2427">        || key == CK_TOUCH_DUMMY)</a>
<a name="ln2428">#else</a>
<a name="ln2429">    if (find(toggle_keys.begin(), toggle_keys.end(), key) != toggle_keys.end())</a>
<a name="ln2430">#endif</a>
<a name="ln2431">    {</a>
<a name="ln2432">        // Toggle all menu entries</a>
<a name="ln2433">        for (MenuEntry *item : items)</a>
<a name="ln2434">            if (auto p = dynamic_cast&lt;ToggleableMenuEntry*&gt;(item))</a>
<a name="ln2435">                p-&gt;toggle();</a>
<a name="ln2436"> </a>
<a name="ln2437">        // Toggle title</a>
<a name="ln2438">        if (auto pt = dynamic_cast&lt;ToggleableMenuEntry*&gt;(title))</a>
<a name="ln2439">            pt-&gt;toggle();</a>
<a name="ln2440"> </a>
<a name="ln2441">        update_menu();</a>
<a name="ln2442"> </a>
<a name="ln2443">#ifdef USE_TILE_WEB</a>
<a name="ln2444">        webtiles_update_items(0, items.size() - 1);</a>
<a name="ln2445">#endif</a>
<a name="ln2446"> </a>
<a name="ln2447">        if (flags &amp; MF_TOGGLE_ACTION)</a>
<a name="ln2448">        {</a>
<a name="ln2449">            if (menu_action == ACT_EXECUTE)</a>
<a name="ln2450">                menu_action = ACT_EXAMINE;</a>
<a name="ln2451">            else</a>
<a name="ln2452">                menu_action = ACT_EXECUTE;</a>
<a name="ln2453">        }</a>
<a name="ln2454"> </a>
<a name="ln2455">        // Don't further process the key</a>
<a name="ln2456">#ifdef TOUCH_UI</a>
<a name="ln2457">        return CK_TOUCH_DUMMY;</a>
<a name="ln2458">#else</a>
<a name="ln2459">        return 0;</a>
<a name="ln2460">#endif</a>
<a name="ln2461">    }</a>
<a name="ln2462">    return key;</a>
<a name="ln2463">}</a>
<a name="ln2464"> </a>
<a name="ln2465">/**</a>
<a name="ln2466"> * Performs regular rectangular AABB intersection between the given AABB</a>
<a name="ln2467"> * rectangle and a item in the menu_entries</a>
<a name="ln2468"> * &lt;pre&gt;</a>
<a name="ln2469"> * start(x,y)------------</a>
<a name="ln2470"> *           |          |</a>
<a name="ln2471"> *           ------------end(x,y)</a>
<a name="ln2472"> * &lt;/pre&gt;</a>
<a name="ln2473"> */</a>
<a name="ln2474">static bool _AABB_intersection(const coord_def&amp; item_start,</a>
<a name="ln2475">                              const coord_def&amp; item_end,</a>
<a name="ln2476">                              const coord_def&amp; aabb_start,</a>
<a name="ln2477">                              const coord_def&amp; aabb_end)</a>
<a name="ln2478">{</a>
<a name="ln2479">    // Check for no overlap using equals on purpose to rule out entities</a>
<a name="ln2480">    // that only brush the bounding box</a>
<a name="ln2481">    if (aabb_start.x &gt;= item_end.x)</a>
<a name="ln2482">        return false;</a>
<a name="ln2483">    if (aabb_end.x &lt;= item_start.x)</a>
<a name="ln2484">        return false;</a>
<a name="ln2485">    if (aabb_start.y &gt;= item_end.y)</a>
<a name="ln2486">        return false;</a>
<a name="ln2487">    if (aabb_end.y &lt;= item_start.y)</a>
<a name="ln2488">        return false;</a>
<a name="ln2489">    // We have overlap</a>
<a name="ln2490">    return true;</a>
<a name="ln2491">}</a>
<a name="ln2492"> </a>
<a name="ln2493">PrecisionMenu::PrecisionMenu() : m_active_object(nullptr),</a>
<a name="ln2494">    m_select_type(PRECISION_SINGLESELECT)</a>
<a name="ln2495">{</a>
<a name="ln2496">}</a>
<a name="ln2497"> </a>
<a name="ln2498">PrecisionMenu::~PrecisionMenu()</a>
<a name="ln2499">{</a>
<a name="ln2500">    clear();</a>
<a name="ln2501">}</a>
<a name="ln2502"> </a>
<a name="ln2503">void PrecisionMenu::set_select_type(SelectType flag)</a>
<a name="ln2504">{</a>
<a name="ln2505">    m_select_type = flag;</a>
<a name="ln2506">}</a>
<a name="ln2507"> </a>
<a name="ln2508">/**</a>
<a name="ln2509"> * Frees all used memory</a>
<a name="ln2510"> */</a>
<a name="ln2511">void PrecisionMenu::clear()</a>
<a name="ln2512">{</a>
<a name="ln2513">    // release all the data reserved</a>
<a name="ln2514">    deleteAll(m_attached_objects);</a>
<a name="ln2515">}</a>
<a name="ln2516"> </a>
<a name="ln2517">/**</a>
<a name="ln2518"> * Processes user input.</a>
<a name="ln2519"> *</a>
<a name="ln2520"> * Returns:</a>
<a name="ln2521"> * true when a significant event happened, signaling that the player has made a</a>
<a name="ln2522"> * menu ending action like selecting an item in singleselect mode</a>
<a name="ln2523"> * false otherwise</a>
<a name="ln2524"> */</a>
<a name="ln2525">bool PrecisionMenu::process_key(int key)</a>
<a name="ln2526">{</a>
<a name="ln2527">    if (m_active_object == nullptr)</a>
<a name="ln2528">    {</a>
<a name="ln2529">        if (m_attached_objects.empty())</a>
<a name="ln2530">        {</a>
<a name="ln2531">            // nothing to process</a>
<a name="ln2532">            return true;</a>
<a name="ln2533">        }</a>
<a name="ln2534">        else</a>
<a name="ln2535">        {</a>
<a name="ln2536">            // pick the first object possible</a>
<a name="ln2537">            for (auto mobj : m_attached_objects)</a>
<a name="ln2538">            {</a>
<a name="ln2539">                if (mobj-&gt;can_be_focused())</a>
<a name="ln2540">                {</a>
<a name="ln2541">                    m_active_object = mobj;</a>
<a name="ln2542">                    break;</a>
<a name="ln2543">                }</a>
<a name="ln2544">            }</a>
<a name="ln2545">        }</a>
<a name="ln2546">    }</a>
<a name="ln2547"> </a>
<a name="ln2548">#ifdef TOUCH_UI</a>
<a name="ln2549">    if (key == CK_TOUCH_DUMMY)</a>
<a name="ln2550">        return true; // mouse click in title area, which wouldn't usually be handled</a>
<a name="ln2551">#endif</a>
<a name="ln2552">    // Handle CK_MOUSE_CLICK separately</a>
<a name="ln2553">    // This signifies a menu ending action</a>
<a name="ln2554">    if (key == CK_MOUSE_CLICK)</a>
<a name="ln2555">        return true;</a>
<a name="ln2556"> </a>
<a name="ln2557">    bool focus_find = false;</a>
<a name="ln2558">    PrecisionMenu::Direction focus_direction;</a>
<a name="ln2559">    MenuObject::InputReturnValue input_ret = m_active_object-&gt;process_input(key);</a>
<a name="ln2560">    switch (input_ret)</a>
<a name="ln2561">    {</a>
<a name="ln2562">    case MenuObject::INPUT_NO_ACTION:</a>
<a name="ln2563">        break;</a>
<a name="ln2564">    case MenuObject::INPUT_SELECTED:</a>
<a name="ln2565">        if (m_select_type == PRECISION_SINGLESELECT)</a>
<a name="ln2566">            return true;</a>
<a name="ln2567">        else</a>
<a name="ln2568">        {</a>
<a name="ln2569">            // TODO: Handle multiselect somehow</a>
<a name="ln2570">        }</a>
<a name="ln2571">        break;</a>
<a name="ln2572">    case MenuObject::INPUT_DESELECTED:</a>
<a name="ln2573">        break;</a>
<a name="ln2574">    case MenuObject::INPUT_END_MENU_SUCCESS:</a>
<a name="ln2575">        return true;</a>
<a name="ln2576">    case MenuObject::INPUT_END_MENU_ABORT:</a>
<a name="ln2577">        clear_selections();</a>
<a name="ln2578">        return true;</a>
<a name="ln2579">    case MenuObject::INPUT_ACTIVE_CHANGED:</a>
<a name="ln2580">        break;</a>
<a name="ln2581">    case MenuObject::INPUT_FOCUS_RELEASE_UP:</a>
<a name="ln2582">        focus_find = true;</a>
<a name="ln2583">        focus_direction = PrecisionMenu::UP;</a>
<a name="ln2584">        break;</a>
<a name="ln2585">    case MenuObject::INPUT_FOCUS_RELEASE_DOWN:</a>
<a name="ln2586">        focus_find = true;</a>
<a name="ln2587">        focus_direction = PrecisionMenu::DOWN;</a>
<a name="ln2588">        break;</a>
<a name="ln2589">    case MenuObject::INPUT_FOCUS_RELEASE_LEFT:</a>
<a name="ln2590">        focus_find = true;</a>
<a name="ln2591">        focus_direction = PrecisionMenu::LEFT;</a>
<a name="ln2592">        break;</a>
<a name="ln2593">    case MenuObject::INPUT_FOCUS_RELEASE_RIGHT:</a>
<a name="ln2594">        focus_find = true;</a>
<a name="ln2595">        focus_direction = PrecisionMenu::RIGHT;</a>
<a name="ln2596">        break;</a>
<a name="ln2597">    default:</a>
<a name="ln2598">        die(&quot;Malformed return value&quot;);</a>
<a name="ln2599">        break;</a>
<a name="ln2600">    }</a>
<a name="ln2601">    if (focus_find)</a>
<a name="ln2602">    {</a>
<a name="ln2603">        MenuObject* find_object = _find_object_by_direction(m_active_object,</a>
<a name="ln2604">                                                            focus_direction);</a>
<a name="ln2605">        if (find_object != nullptr)</a>
<a name="ln2606">        {</a>
<a name="ln2607">            m_active_object-&gt;set_active_item((MenuItem*)nullptr);</a>
<a name="ln2608">            m_active_object = find_object;</a>
<a name="ln2609">            if (focus_direction == PrecisionMenu::UP)</a>
<a name="ln2610">                m_active_object-&gt;activate_last_item();</a>
<a name="ln2611">            else</a>
<a name="ln2612">                m_active_object-&gt;activate_first_item();</a>
<a name="ln2613">        }</a>
<a name="ln2614">    }</a>
<a name="ln2615">    // Handle selection of other objects items hotkeys</a>
<a name="ln2616">    for (MenuObject *obj : m_attached_objects)</a>
<a name="ln2617">    {</a>
<a name="ln2618">        MenuItem* tmp = obj-&gt;select_item_by_hotkey(key);</a>
<a name="ln2619">        if (tmp != nullptr)</a>
<a name="ln2620">        {</a>
<a name="ln2621">            // was it a toggle?</a>
<a name="ln2622">            if (!tmp-&gt;selected())</a>
<a name="ln2623">                continue;</a>
<a name="ln2624">            // it was a selection</a>
<a name="ln2625">            if (m_select_type == PrecisionMenu::PRECISION_SINGLESELECT)</a>
<a name="ln2626">                return true;</a>
<a name="ln2627">        }</a>
<a name="ln2628">    }</a>
<a name="ln2629">    return false;</a>
<a name="ln2630">}</a>
<a name="ln2631"> </a>
<a name="ln2632">#ifdef USE_TILE_LOCAL</a>
<a name="ln2633">int PrecisionMenu::handle_mouse(const wm_mouse_event &amp;me)</a>
<a name="ln2634">{</a>
<a name="ln2635">    // Feed input to each attached object that the mouse is over</a>
<a name="ln2636">    // The objects are responsible for processing the input</a>
<a name="ln2637">    // This includes, if applicable for instance checking if the mouse</a>
<a name="ln2638">    // is over the item or not</a>
<a name="ln2639">    for (MenuObject *obj : m_attached_objects)</a>
<a name="ln2640">    {</a>
<a name="ln2641">        const MenuObject::InputReturnValue input_return = obj-&gt;handle_mouse(me);</a>
<a name="ln2642"> </a>
<a name="ln2643">        switch (input_return)</a>
<a name="ln2644">        {</a>
<a name="ln2645">        case MenuObject::INPUT_SELECTED:</a>
<a name="ln2646">            m_active_object = obj;</a>
<a name="ln2647">            if (m_select_type == PRECISION_SINGLESELECT)</a>
<a name="ln2648">                return CK_MOUSE_CLICK;</a>
<a name="ln2649">            break;</a>
<a name="ln2650">        case MenuObject::INPUT_ACTIVE_CHANGED:</a>
<a name="ln2651">            // Set the active object to be this one</a>
<a name="ln2652">            m_active_object = obj;</a>
<a name="ln2653">            break;</a>
<a name="ln2654">        case MenuObject::INPUT_END_MENU_SUCCESS:</a>
<a name="ln2655">            // something got clicked that needs to signal the menu to end</a>
<a name="ln2656">            return CK_MOUSE_CLICK;</a>
<a name="ln2657">        case MenuObject::INPUT_END_MENU_ABORT:</a>
<a name="ln2658">            // XXX: For right-click we use CK_MOUSE_CMD to cancel out of the</a>
<a name="ln2659">            // menu, but these mouse-button-&gt;key mappings are not very sane.</a>
<a name="ln2660">            clear_selections();</a>
<a name="ln2661">            return CK_MOUSE_CMD;</a>
<a name="ln2662">        case MenuObject::INPUT_FOCUS_LOST:</a>
<a name="ln2663">            // The object lost its focus and is no longer the active one</a>
<a name="ln2664">            if (obj == m_active_object)</a>
<a name="ln2665">                m_active_object = nullptr;</a>
<a name="ln2666">        default:</a>
<a name="ln2667">            break;</a>
<a name="ln2668">        }</a>
<a name="ln2669">    }</a>
<a name="ln2670">    return 0;</a>
<a name="ln2671">}</a>
<a name="ln2672">#endif</a>
<a name="ln2673"> </a>
<a name="ln2674">void PrecisionMenu::clear_selections()</a>
<a name="ln2675">{</a>
<a name="ln2676">    for (MenuObject *obj : m_attached_objects)</a>
<a name="ln2677">        obj-&gt;clear_selections();</a>
<a name="ln2678">}</a>
<a name="ln2679"> </a>
<a name="ln2680">/**</a>
<a name="ln2681"> * Finds the closest rectangle to given entry start on a cardinal</a>
<a name="ln2682"> * direction from it.</a>
<a name="ln2683"> * If no entries are found, nullptr is returned.</a>
<a name="ln2684"> *</a>
<a name="ln2685"> * TODO: This is exact duplicate of MenuObject::_find_item_by_direction();</a>
<a name="ln2686"> * maybe somehow generalize it and detach it from class?</a>
<a name="ln2687"> */</a>
<a name="ln2688">MenuObject* PrecisionMenu::_find_object_by_direction(const MenuObject* start,</a>
<a name="ln2689">                                                   Direction dir)</a>
<a name="ln2690">{</a>
<a name="ln2691">    if (start == nullptr)</a>
<a name="ln2692">        return nullptr;</a>
<a name="ln2693"> </a>
<a name="ln2694">    coord_def aabb_start(0,0);</a>
<a name="ln2695">    coord_def aabb_end(0,0);</a>
<a name="ln2696"> </a>
<a name="ln2697">    // construct the aabb</a>
<a name="ln2698">    switch (dir)</a>
<a name="ln2699">    {</a>
<a name="ln2700">    case UP:</a>
<a name="ln2701">        aabb_start.x = start-&gt;get_min_coord().x;</a>
<a name="ln2702">        aabb_end.x = start-&gt;get_max_coord().x;</a>
<a name="ln2703">        aabb_start.y = 0; // top of screen</a>
<a name="ln2704">        aabb_end.y = start-&gt;get_min_coord().y;</a>
<a name="ln2705">        break;</a>
<a name="ln2706">    case DOWN:</a>
<a name="ln2707">        aabb_start.x = start-&gt;get_min_coord().x;</a>
<a name="ln2708">        aabb_end.x = start-&gt;get_max_coord().x;</a>
<a name="ln2709">        aabb_start.y = start-&gt;get_max_coord().y;</a>
<a name="ln2710">        // we choose an arbitrarily large number here, because</a>
<a name="ln2711">        // tiles saves entry coordinates in pixels, yet console saves them</a>
<a name="ln2712">        // in characters</a>
<a name="ln2713">        // basically, we want the AABB to be large enough to extend to the</a>
<a name="ln2714">        // bottom of the screen in every possible resolution</a>
<a name="ln2715">        aabb_end.y = 32767;</a>
<a name="ln2716">        break;</a>
<a name="ln2717">    case LEFT:</a>
<a name="ln2718">        aabb_start.x = 0; // left of screen</a>
<a name="ln2719">        aabb_end.x = start-&gt;get_min_coord().x;</a>
<a name="ln2720">        aabb_start.y = start-&gt;get_min_coord().y;</a>
<a name="ln2721">        aabb_end.y = start-&gt;get_max_coord().y;</a>
<a name="ln2722">        break;</a>
<a name="ln2723">    case RIGHT:</a>
<a name="ln2724">        aabb_start.x = start-&gt;get_max_coord().x;</a>
<a name="ln2725">        // we again want a value that is always larger then the width of screen</a>
<a name="ln2726">        aabb_end.x = 32767;</a>
<a name="ln2727">        aabb_start.y = start-&gt;get_min_coord().y;</a>
<a name="ln2728">        aabb_end.y = start-&gt;get_max_coord().y;</a>
<a name="ln2729">        break;</a>
<a name="ln2730">    default:</a>
<a name="ln2731">        die(&quot;Bad direction given&quot;);</a>
<a name="ln2732">    }</a>
<a name="ln2733"> </a>
<a name="ln2734">    // loop through the entries</a>
<a name="ln2735">    // save the currently closest to the index in a variable</a>
<a name="ln2736">    MenuObject* closest = nullptr;</a>
<a name="ln2737">    for (MenuObject *obj : m_attached_objects)</a>
<a name="ln2738">    {</a>
<a name="ln2739">        if (!obj-&gt;can_be_focused())</a>
<a name="ln2740">        {</a>
<a name="ln2741">            // this is a noselect entry, skip it</a>
<a name="ln2742">            continue;</a>
<a name="ln2743">        }</a>
<a name="ln2744"> </a>
<a name="ln2745">        if (!_AABB_intersection(obj-&gt;get_min_coord(), obj-&gt;get_max_coord(),</a>
<a name="ln2746">                                aabb_start, aabb_end))</a>
<a name="ln2747">        {</a>
<a name="ln2748">            continue; // does not intersect, continue loop</a>
<a name="ln2749">        }</a>
<a name="ln2750"> </a>
<a name="ln2751">        // intersects</a>
<a name="ln2752">        // check if it's closer than current</a>
<a name="ln2753">        if (closest == nullptr)</a>
<a name="ln2754">            closest = obj;</a>
<a name="ln2755"> </a>
<a name="ln2756">        switch (dir)</a>
<a name="ln2757">        {</a>
<a name="ln2758">        case UP:</a>
<a name="ln2759">            if (obj-&gt;get_min_coord().y &gt; closest-&gt;get_min_coord().y)</a>
<a name="ln2760">                closest = obj;</a>
<a name="ln2761">            break;</a>
<a name="ln2762">        case DOWN:</a>
<a name="ln2763">            if (obj-&gt;get_min_coord().y &lt; closest-&gt;get_min_coord().y)</a>
<a name="ln2764">                closest = obj;</a>
<a name="ln2765">            break;</a>
<a name="ln2766">        case LEFT:</a>
<a name="ln2767">            if (obj-&gt;get_min_coord().x &gt; closest-&gt;get_min_coord().x)</a>
<a name="ln2768">                closest = obj;</a>
<a name="ln2769">            break;</a>
<a name="ln2770">        case RIGHT:</a>
<a name="ln2771">            if (obj-&gt;get_min_coord().x &lt; closest-&gt;get_min_coord().x)</a>
<a name="ln2772">                closest = obj;</a>
<a name="ln2773">        }</a>
<a name="ln2774">    }</a>
<a name="ln2775">    // TODO handle special cases here, like pressing down on the last entry</a>
<a name="ln2776">    // to go the the first item in that line</a>
<a name="ln2777">    return closest;</a>
<a name="ln2778">}</a>
<a name="ln2779"> </a>
<a name="ln2780">vector&lt;MenuItem*&gt; PrecisionMenu::get_selected_items()</a>
<a name="ln2781">{</a>
<a name="ln2782">    vector&lt;MenuItem*&gt; ret_val;</a>
<a name="ln2783"> </a>
<a name="ln2784">    for (MenuObject *obj : m_attached_objects)</a>
<a name="ln2785">        for (MenuItem *item : obj-&gt;get_selected_items())</a>
<a name="ln2786">            ret_val.push_back(item);</a>
<a name="ln2787"> </a>
<a name="ln2788">    return ret_val;</a>
<a name="ln2789">}</a>
<a name="ln2790"> </a>
<a name="ln2791">void PrecisionMenu::attach_object(MenuObject* item)</a>
<a name="ln2792">{</a>
<a name="ln2793">    ASSERT(item != nullptr);</a>
<a name="ln2794">    m_attached_objects.push_back(item);</a>
<a name="ln2795">}</a>
<a name="ln2796"> </a>
<a name="ln2797">// Predicate for std::find_if</a>
<a name="ln2798">static bool _string_lookup(MenuObject* item, string lookup)</a>
<a name="ln2799">{</a>
<a name="ln2800">    return item-&gt;get_name().compare(lookup) == 0;</a>
<a name="ln2801">}</a>
<a name="ln2802"> </a>
<a name="ln2803">MenuObject* PrecisionMenu::get_object_by_name(const string &amp;search)</a>
<a name="ln2804">{</a>
<a name="ln2805">    auto it = find_if(begin(m_attached_objects), end(m_attached_objects),</a>
<a name="ln2806">                      bind(_string_lookup, placeholders::_1, search));</a>
<a name="ln2807">    return it != m_attached_objects.end() ? *it : nullptr;</a>
<a name="ln2808">}</a>
<a name="ln2809"> </a>
<a name="ln2810">MenuItem* PrecisionMenu::get_active_item()</a>
<a name="ln2811">{</a>
<a name="ln2812">    if (m_active_object != nullptr)</a>
<a name="ln2813">        return m_active_object-&gt;get_active_item();</a>
<a name="ln2814">    return nullptr;</a>
<a name="ln2815">}</a>
<a name="ln2816"> </a>
<a name="ln2817">void PrecisionMenu::set_active_object(MenuObject* object)</a>
<a name="ln2818">{</a>
<a name="ln2819">    if (object == m_active_object)</a>
<a name="ln2820">        return;</a>
<a name="ln2821"> </a>
<a name="ln2822">    // is the object attached?</a>
<a name="ln2823">    auto find_val = find(m_attached_objects.begin(), m_attached_objects.end(),</a>
<a name="ln2824">                         object);</a>
<a name="ln2825">    if (find_val != m_attached_objects.end())</a>
<a name="ln2826">    {</a>
<a name="ln2827">        m_active_object = object;</a>
<a name="ln2828">        m_active_object-&gt;activate_first_item();</a>
<a name="ln2829">    }</a>
<a name="ln2830">}</a>
<a name="ln2831"> </a>
<a name="ln2832">void PrecisionMenu::draw_menu()</a>
<a name="ln2833">{</a>
<a name="ln2834">    for (MenuObject *obj : m_attached_objects)</a>
<a name="ln2835">        obj-&gt;render();</a>
<a name="ln2836">}</a>
<a name="ln2837"> </a>
<a name="ln2838">MenuItem::MenuItem(): m_min_coord(0,0), m_max_coord(0,0), m_selected(false),</a>
<a name="ln2839">                      m_allow_highlight(true), m_dirty(false), m_visible(false),</a>
<a name="ln2840">                      m_link_left(nullptr), m_link_right(nullptr),</a>
<a name="ln2841">                      m_link_up(nullptr), m_link_down(nullptr), m_item_id(-1)</a>
<a name="ln2842">{</a>
<a name="ln2843">#ifdef USE_TILE_LOCAL</a>
<a name="ln2844">    m_unit_width_pixels = tiles.get_crt_font()-&gt;char_width();</a>
<a name="ln2845">    m_unit_height_pixels = tiles.get_crt_font()-&gt;char_height();</a>
<a name="ln2846">#endif</a>
<a name="ln2847"> </a>
<a name="ln2848">    set_fg_colour(LIGHTGRAY);</a>
<a name="ln2849">    set_bg_colour(BLACK);</a>
<a name="ln2850">    set_highlight_colour(BLACK);</a>
<a name="ln2851">}</a>
<a name="ln2852"> </a>
<a name="ln2853">MenuItem::~MenuItem()</a>
<a name="ln2854">{</a>
<a name="ln2855">}</a>
<a name="ln2856"> </a>
<a name="ln2857">#ifdef USE_TILE_LOCAL</a>
<a name="ln2858">void MenuItem::set_height(const int height)</a>
<a name="ln2859">{</a>
<a name="ln2860">    m_unit_height_pixels = height;</a>
<a name="ln2861">}</a>
<a name="ln2862">#endif</a>
<a name="ln2863"> </a>
<a name="ln2864">/**</a>
<a name="ln2865"> * Override this if you use eg funky different sized fonts, tiles etc</a>
<a name="ln2866"> */</a>
<a name="ln2867">void MenuItem::set_bounds(const coord_def&amp; min_coord, const coord_def&amp; max_coord)</a>
<a name="ln2868">{</a>
<a name="ln2869">#ifdef USE_TILE_LOCAL</a>
<a name="ln2870">    // these are saved in font dx / dy for mouse to work properly</a>
<a name="ln2871">    // remove 1 unit from all the entries because console starts at (1,1)</a>
<a name="ln2872">    // but tiles starts at (0,0)</a>
<a name="ln2873">    m_min_coord.x = (min_coord.x - 1) * m_unit_width_pixels;</a>
<a name="ln2874">    m_min_coord.y = (min_coord.y - 1) * m_unit_height_pixels;</a>
<a name="ln2875">    m_max_coord.x = (max_coord.x - 1) * m_unit_width_pixels;</a>
<a name="ln2876">    m_max_coord.y = (max_coord.y - 1) * m_unit_height_pixels;</a>
<a name="ln2877">#else</a>
<a name="ln2878">    m_min_coord = min_coord;</a>
<a name="ln2879">    m_max_coord = max_coord;</a>
<a name="ln2880">#endif</a>
<a name="ln2881">}</a>
<a name="ln2882"> </a>
<a name="ln2883">/**</a>
<a name="ln2884"> * This is handly if you are already working with existing multiplied</a>
<a name="ln2885"> * coordinates and modifying them</a>
<a name="ln2886"> */</a>
<a name="ln2887">void MenuItem::set_bounds_no_multiply(const coord_def&amp; min_coord,</a>
<a name="ln2888">                                      const coord_def&amp; max_coord)</a>
<a name="ln2889">{</a>
<a name="ln2890">    m_min_coord = min_coord;</a>
<a name="ln2891">    m_max_coord = max_coord;</a>
<a name="ln2892">}</a>
<a name="ln2893"> </a>
<a name="ln2894">void MenuItem::move(const coord_def&amp; delta)</a>
<a name="ln2895">{</a>
<a name="ln2896">    m_min_coord += delta;</a>
<a name="ln2897">    m_max_coord += delta;</a>
<a name="ln2898">}</a>
<a name="ln2899"> </a>
<a name="ln2900">// By default, value does nothing. Override for Items needing it.</a>
<a name="ln2901">void MenuItem::select(bool toggle, int /*value*/)</a>
<a name="ln2902">{</a>
<a name="ln2903">    select(toggle);</a>
<a name="ln2904">}</a>
<a name="ln2905"> </a>
<a name="ln2906">void MenuItem::select(bool toggle)</a>
<a name="ln2907">{</a>
<a name="ln2908">    m_selected = toggle;</a>
<a name="ln2909">    m_dirty = true;</a>
<a name="ln2910">}</a>
<a name="ln2911"> </a>
<a name="ln2912">bool MenuItem::selected() const</a>
<a name="ln2913">{</a>
<a name="ln2914">    return m_selected;</a>
<a name="ln2915">}</a>
<a name="ln2916"> </a>
<a name="ln2917">void MenuItem::allow_highlight(bool toggle)</a>
<a name="ln2918">{</a>
<a name="ln2919">    m_allow_highlight = toggle;</a>
<a name="ln2920">    m_dirty = true;</a>
<a name="ln2921">}</a>
<a name="ln2922"> </a>
<a name="ln2923">bool MenuItem::can_be_highlighted() const</a>
<a name="ln2924">{</a>
<a name="ln2925">    return m_allow_highlight;</a>
<a name="ln2926">}</a>
<a name="ln2927"> </a>
<a name="ln2928">void MenuItem::set_highlight_colour(COLOURS colour)</a>
<a name="ln2929">{</a>
<a name="ln2930">    m_highlight_colour = colour;</a>
<a name="ln2931">    m_dirty = true;</a>
<a name="ln2932">}</a>
<a name="ln2933"> </a>
<a name="ln2934">COLOURS MenuItem::get_highlight_colour() const</a>
<a name="ln2935">{</a>
<a name="ln2936">    return m_highlight_colour;</a>
<a name="ln2937">}</a>
<a name="ln2938"> </a>
<a name="ln2939">void MenuItem::set_bg_colour(COLOURS colour)</a>
<a name="ln2940">{</a>
<a name="ln2941">    m_bg_colour = colour;</a>
<a name="ln2942">    m_dirty = true;</a>
<a name="ln2943">}</a>
<a name="ln2944"> </a>
<a name="ln2945">void MenuItem::set_fg_colour(COLOURS colour)</a>
<a name="ln2946">{</a>
<a name="ln2947">    m_fg_colour = colour;</a>
<a name="ln2948">    m_dirty = true;</a>
<a name="ln2949">}</a>
<a name="ln2950"> </a>
<a name="ln2951">COLOURS MenuItem::get_fg_colour() const</a>
<a name="ln2952">{</a>
<a name="ln2953">    return m_fg_colour;</a>
<a name="ln2954">}</a>
<a name="ln2955"> </a>
<a name="ln2956">COLOURS MenuItem::get_bg_colour() const</a>
<a name="ln2957">{</a>
<a name="ln2958">    return static_cast&lt;COLOURS&gt; (m_bg_colour);</a>
<a name="ln2959">}</a>
<a name="ln2960"> </a>
<a name="ln2961">void MenuItem::set_visible(bool flag)</a>
<a name="ln2962">{</a>
<a name="ln2963">    m_visible = flag;</a>
<a name="ln2964">}</a>
<a name="ln2965"> </a>
<a name="ln2966">bool MenuItem::is_visible() const</a>
<a name="ln2967">{</a>
<a name="ln2968">    return m_visible;</a>
<a name="ln2969">}</a>
<a name="ln2970"> </a>
<a name="ln2971">void MenuItem::add_hotkey(int key)</a>
<a name="ln2972">{</a>
<a name="ln2973">    m_hotkeys.push_back(key);</a>
<a name="ln2974">}</a>
<a name="ln2975"> </a>
<a name="ln2976">void MenuItem::clear_hotkeys()</a>
<a name="ln2977">{</a>
<a name="ln2978">    m_hotkeys.clear();</a>
<a name="ln2979">}</a>
<a name="ln2980"> </a>
<a name="ln2981">const vector&lt;int&gt;&amp; MenuItem::get_hotkeys() const</a>
<a name="ln2982">{</a>
<a name="ln2983">    return m_hotkeys;</a>
<a name="ln2984">}</a>
<a name="ln2985"> </a>
<a name="ln2986">void MenuItem::set_link_left(MenuItem* item)</a>
<a name="ln2987">{</a>
<a name="ln2988">    m_link_left = item;</a>
<a name="ln2989">}</a>
<a name="ln2990"> </a>
<a name="ln2991">void MenuItem::set_link_right(MenuItem* item)</a>
<a name="ln2992">{</a>
<a name="ln2993">    m_link_right = item;</a>
<a name="ln2994">}</a>
<a name="ln2995"> </a>
<a name="ln2996">void MenuItem::set_link_up(MenuItem* item)</a>
<a name="ln2997">{</a>
<a name="ln2998">    m_link_up = item;</a>
<a name="ln2999">}</a>
<a name="ln3000"> </a>
<a name="ln3001">void MenuItem::set_link_down(MenuItem* item)</a>
<a name="ln3002">{</a>
<a name="ln3003">    m_link_down = item;</a>
<a name="ln3004">}</a>
<a name="ln3005"> </a>
<a name="ln3006">MenuItem* MenuItem::get_link_left() const</a>
<a name="ln3007">{</a>
<a name="ln3008">    return m_link_left;</a>
<a name="ln3009">}</a>
<a name="ln3010"> </a>
<a name="ln3011">MenuItem* MenuItem::get_link_right() const</a>
<a name="ln3012">{</a>
<a name="ln3013">    return m_link_right;</a>
<a name="ln3014">}</a>
<a name="ln3015"> </a>
<a name="ln3016">MenuItem* MenuItem::get_link_up() const</a>
<a name="ln3017">{</a>
<a name="ln3018">    return m_link_up;</a>
<a name="ln3019">}</a>
<a name="ln3020"> </a>
<a name="ln3021">MenuItem* MenuItem::get_link_down() const</a>
<a name="ln3022">{</a>
<a name="ln3023">    return m_link_down;</a>
<a name="ln3024">}</a>
<a name="ln3025"> </a>
<a name="ln3026">#ifdef USE_TILE_LOCAL</a>
<a name="ln3027">int MenuItem::get_vertical_offset() const</a>
<a name="ln3028">{</a>
<a name="ln3029">    return m_unit_height_pixels / 2 - tiles.get_crt_font()-&gt;char_height() / 2;</a>
<a name="ln3030">}</a>
<a name="ln3031">#endif</a>
<a name="ln3032"> </a>
<a name="ln3033">TextItem::TextItem()</a>
<a name="ln3034">#ifdef USE_TILE_LOCAL</a>
<a name="ln3035">                        : m_font_buf(tiles.get_crt_font())</a>
<a name="ln3036">#endif</a>
<a name="ln3037">{</a>
<a name="ln3038">}</a>
<a name="ln3039"> </a>
<a name="ln3040">TextItem::~TextItem()</a>
<a name="ln3041">{</a>
<a name="ln3042">}</a>
<a name="ln3043"> </a>
<a name="ln3044">/**</a>
<a name="ln3045"> * Rewrap the text if bounds changes</a>
<a name="ln3046"> */</a>
<a name="ln3047">void TextItem::set_bounds(const coord_def&amp; min_coord, const coord_def&amp; max_coord)</a>
<a name="ln3048">{</a>
<a name="ln3049">    MenuItem::set_bounds(min_coord, max_coord);</a>
<a name="ln3050">    _wrap_text();</a>
<a name="ln3051">    m_dirty = true;</a>
<a name="ln3052">}</a>
<a name="ln3053"> </a>
<a name="ln3054">/**</a>
<a name="ln3055"> * Rewrap the text if bounds changes</a>
<a name="ln3056"> */</a>
<a name="ln3057">void TextItem::set_bounds_no_multiply(const coord_def&amp; min_coord,</a>
<a name="ln3058">                                      const coord_def&amp; max_coord)</a>
<a name="ln3059">{</a>
<a name="ln3060">    MenuItem::set_bounds_no_multiply(min_coord, max_coord);</a>
<a name="ln3061">    _wrap_text();</a>
<a name="ln3062">    m_dirty = true;</a>
<a name="ln3063">}</a>
<a name="ln3064"> </a>
<a name="ln3065">void TextItem::render()</a>
<a name="ln3066">{</a>
<a name="ln3067">    if (!m_visible)</a>
<a name="ln3068">        return;</a>
<a name="ln3069"> </a>
<a name="ln3070">#ifdef USE_TILE_LOCAL</a>
<a name="ln3071">    if (m_dirty)</a>
<a name="ln3072">    {</a>
<a name="ln3073">        m_font_buf.clear();</a>
<a name="ln3074">        // TODO: handle m_bg_colour</a>
<a name="ln3075">        m_font_buf.add(m_render_text, term_colours[m_fg_colour],</a>
<a name="ln3076">                       m_min_coord.x, m_min_coord.y + get_vertical_offset());</a>
<a name="ln3077">        m_dirty = false;</a>
<a name="ln3078">    }</a>
<a name="ln3079">    m_font_buf.draw();</a>
<a name="ln3080">#else</a>
<a name="ln3081">    // Clean the drawing area first</a>
<a name="ln3082">    // clear_to_end_of_line does not work for us</a>
<a name="ln3083">    string white_space(m_max_coord.x - m_min_coord.x, ' ');</a>
<a name="ln3084">    textcolour(BLACK);</a>
<a name="ln3085">    for (int i = 0; i &lt; (m_max_coord.y - m_min_coord.y); ++i)</a>
<a name="ln3086">    {</a>
<a name="ln3087">        cgotoxy(m_min_coord.x, m_min_coord.y + i);</a>
<a name="ln3088">        cprintf(&quot;%s&quot;, white_space.c_str());</a>
<a name="ln3089">    }</a>
<a name="ln3090"> </a>
<a name="ln3091">    // print each line separately, is there a cleaner solution?</a>
<a name="ln3092">    size_t newline_pos = 0;</a>
<a name="ln3093">    size_t endline_pos = 0;</a>
<a name="ln3094">    for (int i = 0; i &lt; (m_max_coord.y - m_min_coord.y); ++i)</a>
<a name="ln3095">    {</a>
<a name="ln3096">        endline_pos = m_render_text.find('\n', newline_pos);</a>
<a name="ln3097">        cgotoxy(m_min_coord.x, m_min_coord.y + i);</a>
<a name="ln3098">        textcolour(m_fg_colour);</a>
<a name="ln3099">        textbackground(m_bg_colour);</a>
<a name="ln3100">        cprintf(&quot;%s&quot;, m_render_text.substr(newline_pos,</a>
<a name="ln3101">                endline_pos - newline_pos).c_str());</a>
<a name="ln3102">        if (endline_pos != string::npos)</a>
<a name="ln3103">            newline_pos = endline_pos + 1;</a>
<a name="ln3104">        else</a>
<a name="ln3105">            break;</a>
<a name="ln3106">    }</a>
<a name="ln3107">    // clear text background</a>
<a name="ln3108">    textbackground(BLACK);</a>
<a name="ln3109">#endif</a>
<a name="ln3110">}</a>
<a name="ln3111"> </a>
<a name="ln3112">void TextItem::set_text(const string&amp; text)</a>
<a name="ln3113">{</a>
<a name="ln3114">    m_text = text;</a>
<a name="ln3115">    _wrap_text();</a>
<a name="ln3116">    m_dirty = true;</a>
<a name="ln3117">}</a>
<a name="ln3118"> </a>
<a name="ln3119">const string&amp; TextItem::get_text() const</a>
<a name="ln3120">{</a>
<a name="ln3121">    return m_text;</a>
<a name="ln3122">}</a>
<a name="ln3123"> </a>
<a name="ln3124">/**</a>
<a name="ln3125"> * Wraps and chops the #m_text variable and saves the chopped</a>
<a name="ln3126"> * text to #m_render_text.</a>
<a name="ln3127"> * This is done to preserve the old text in case the text item</a>
<a name="ln3128"> * changes size and could fit more text.</a>
<a name="ln3129"> * Override if you use font with different sizes than CRTRegion font.</a>
<a name="ln3130"> */</a>
<a name="ln3131">void TextItem::_wrap_text()</a>
<a name="ln3132">{</a>
<a name="ln3133">    m_render_text = m_text; // preserve original copy intact</a>
<a name="ln3134">    int max_cols;</a>
<a name="ln3135">    int max_lines;</a>
<a name="ln3136">    max_cols = (m_max_coord.x - m_min_coord.x);</a>
<a name="ln3137">    max_lines = (m_max_coord.y - m_min_coord.y);</a>
<a name="ln3138">#ifdef USE_TILE_LOCAL</a>
<a name="ln3139">    // Tiles saves coordinates in pixels</a>
<a name="ln3140">    max_cols = max_cols / m_unit_width_pixels;</a>
<a name="ln3141">    max_lines = max_lines / m_unit_height_pixels;</a>
<a name="ln3142">#endif</a>
<a name="ln3143">    if (max_cols == 0 || max_lines == 0)</a>
<a name="ln3144">    {</a>
<a name="ln3145">        // escape and set render text to nothing</a>
<a name="ln3146">        m_render_text = &quot;&quot;;</a>
<a name="ln3147">        return;</a>
<a name="ln3148">    }</a>
<a name="ln3149"> </a>
<a name="ln3150">    int num_linebreaks = linebreak_string(m_render_text, max_cols);</a>
<a name="ln3151">    if (num_linebreaks &gt; max_lines)</a>
<a name="ln3152">    {</a>
<a name="ln3153">        size_t pos = 0;</a>
<a name="ln3154">        // find the max_line'th occurrence of '\n'</a>
<a name="ln3155">        for (int i = 0; i &lt; max_lines; ++i)</a>
<a name="ln3156">            pos = m_render_text.find('\n', pos);</a>
<a name="ln3157"> </a>
<a name="ln3158">        // Chop of all the nonfitting text</a>
<a name="ln3159">        m_render_text = m_render_text.substr(pos);</a>
<a name="ln3160">    }</a>
<a name="ln3161">    // m_render_text now holds the fitting part of the text, ready for render!</a>
<a name="ln3162">}</a>
<a name="ln3163"> </a>
<a name="ln3164"> </a>
<a name="ln3165">EditableTextItem::EditableTextItem() : TextItem(),</a>
<a name="ln3166">                        editable(true), in_edit_mode(false), edit_width(-1),</a>
<a name="ln3167">                        tag(&quot;generic_text_box&quot;)</a>
<a name="ln3168">{</a>
<a name="ln3169">}</a>
<a name="ln3170"> </a>
<a name="ln3171">void EditableTextItem::set_editable(bool e, int width)</a>
<a name="ln3172">{</a>
<a name="ln3173">    editable = e;</a>
<a name="ln3174">    edit_width = width;</a>
<a name="ln3175">}</a>
<a name="ln3176"> </a>
<a name="ln3177">/**</a>
<a name="ln3178"> * A rudimentary textbox editing mode.</a>
<a name="ln3179"> *</a>
<a name="ln3180"> * This uses a line_reader to read some text at the location of the TextItem.</a>
<a name="ln3181"> * It does not do anything with the edit results! You will need to call this</a>
<a name="ln3182"> * function at the right point in the gui, and do something appropriate with</a>
<a name="ln3183"> * the results elsewhere.</a>
<a name="ln3184"> *</a>
<a name="ln3185"> * @param custom_prefill a string to populate the box; if null, this will use</a>
<a name="ln3186"> *                          the current text.</a>
<a name="ln3187"> * @param keyproc_fun an optional keyproc for the line_reader</a>
<a name="ln3188">  *                     (see lin_reader::set_keyproc).</a>
<a name="ln3189"> *</a>
<a name="ln3190"> * @return the result of the editing, including the string and the int</a>
<a name="ln3191"> *          returned by the line_reader.</a>
<a name="ln3192"> */</a>
<a name="ln3193">edit_result EditableTextItem::edit(const string *custom_prefill,</a>
<a name="ln3194">                                   const line_reader::keyproc keyproc_fun)</a>
<a name="ln3195">{</a>
<a name="ln3196">    char buf[80];</a>
<a name="ln3197"> </a>
<a name="ln3198">    if (!editable)</a>
<a name="ln3199">        return edit_result(string(m_text), 0);</a>
<a name="ln3200"> </a>
<a name="ln3201">    // this is needed because render will get called during the input loop.</a>
<a name="ln3202">    unwind_bool e_mode(in_edit_mode, true);</a>
<a name="ln3203"> </a>
<a name="ln3204">    int e_width;</a>
<a name="ln3205">    int box_width = m_max_coord.x - m_min_coord.x;</a>
<a name="ln3206">    if (edit_width &lt;= 0)</a>
<a name="ln3207">        e_width = box_width;</a>
<a name="ln3208">    else</a>
<a name="ln3209">        e_width = edit_width;</a>
<a name="ln3210"> </a>
<a name="ln3211">    e_width = min(e_width, (int) sizeof buf - 1);</a>
<a name="ln3212"> </a>
<a name="ln3213">    // TODO: make width not dependent on prefill string</a>
<a name="ln3214">    string prefill = make_stringf(&quot;%-*s&quot;, e_width,</a>
<a name="ln3215">        custom_prefill ? custom_prefill-&gt;c_str() : m_text.c_str());</a>
<a name="ln3216"> </a>
<a name="ln3217">    strncpy(buf, prefill.c_str(), e_width);</a>
<a name="ln3218">    buf[e_width] = 0;</a>
<a name="ln3219"> </a>
<a name="ln3220">    mouse_control mc(MOUSE_MODE_PROMPT);</a>
<a name="ln3221"> </a>
<a name="ln3222">#ifdef USE_TILE_LOCAL</a>
<a name="ln3223">    m_line_buf.clear();</a>
<a name="ln3224">    m_line_buf.add_square(m_min_coord.x, m_min_coord.y,</a>
<a name="ln3225">                          m_max_coord.x, m_max_coord.y, term_colours[RED]);</a>
<a name="ln3226">    m_line_buf.draw();</a>
<a name="ln3227"> </a>
<a name="ln3228">    unwind_bool dirty(m_dirty, false);</a>
<a name="ln3229"> </a>
<a name="ln3230">    fontbuf_line_reader reader(buf, e_width+1, m_font_buf, 80);</a>
<a name="ln3231">    reader.set_location(coord_def(m_min_coord.x,</a>
<a name="ln3232">                                  m_min_coord.y + get_vertical_offset()));</a>
<a name="ln3233">#else</a>
<a name="ln3234">    line_reader reader(buf, e_width+1, 80);</a>
<a name="ln3235">    reader.set_location(m_min_coord);</a>
<a name="ln3236">#endif</a>
<a name="ln3237"> </a>
<a name="ln3238">    reader.set_edit_mode(EDIT_MODE_OVERWRITE);</a>
<a name="ln3239">    if (keyproc_fun)</a>
<a name="ln3240">        reader.set_keyproc(keyproc_fun);</a>
<a name="ln3241"> </a>
<a name="ln3242">#ifdef USE_TILE_WEB</a>
<a name="ln3243">    reader.set_prompt(prompt);</a>
<a name="ln3244">    reader.set_tag(tag);</a>
<a name="ln3245">#endif</a>
<a name="ln3246"> </a>
<a name="ln3247">    reader.set_colour(COLOUR_INHERIT, m_highlight_colour);</a>
<a name="ln3248">    int result = reader.read_line(false, true);</a>
<a name="ln3249"> </a>
<a name="ln3250">#ifdef USE_TILE_LOCAL</a>
<a name="ln3251">    m_line_buf.clear();</a>
<a name="ln3252">    m_line_buf.draw();</a>
<a name="ln3253">#endif</a>
<a name="ln3254"> </a>
<a name="ln3255">    return edit_result(string(buf), result);</a>
<a name="ln3256">}</a>
<a name="ln3257"> </a>
<a name="ln3258">void EditableTextItem::set_tag(string t)</a>
<a name="ln3259">{</a>
<a name="ln3260">    tag = t;</a>
<a name="ln3261">}</a>
<a name="ln3262"> </a>
<a name="ln3263">void EditableTextItem::set_prompt(string p)</a>
<a name="ln3264">{</a>
<a name="ln3265">    prompt = p;</a>
<a name="ln3266">}</a>
<a name="ln3267"> </a>
<a name="ln3268">bool EditableTextItem::selected() const</a>
<a name="ln3269">{</a>
<a name="ln3270">    return false;</a>
<a name="ln3271">}</a>
<a name="ln3272"> </a>
<a name="ln3273">bool EditableTextItem::can_be_highlighted() const</a>
<a name="ln3274">{</a>
<a name="ln3275">    // TODO: make this work better</a>
<a name="ln3276">    return false;</a>
<a name="ln3277">}</a>
<a name="ln3278"> </a>
<a name="ln3279">void EditableTextItem::render()</a>
<a name="ln3280">{</a>
<a name="ln3281">#ifdef USE_TILE_LOCAL</a>
<a name="ln3282">    if (in_edit_mode)</a>
<a name="ln3283">    {</a>
<a name="ln3284">        m_line_buf.add_square(m_min_coord.x, m_min_coord.y,</a>
<a name="ln3285">                              m_max_coord.x, m_max_coord.y,</a>
<a name="ln3286">                              term_colours[m_highlight_colour]);</a>
<a name="ln3287">        m_line_buf.draw();</a>
<a name="ln3288">        // this relies on m_font_buf being modified by the reader</a>
<a name="ln3289">        m_font_buf.draw();</a>
<a name="ln3290">    }</a>
<a name="ln3291">    else</a>
<a name="ln3292">    {</a>
<a name="ln3293">        m_line_buf.clear();</a>
<a name="ln3294">        m_line_buf.draw();</a>
<a name="ln3295">        TextItem::render();</a>
<a name="ln3296">    }</a>
<a name="ln3297">#else</a>
<a name="ln3298">    TextItem::render();</a>
<a name="ln3299">#endif //USE_TILE_LOCAL</a>
<a name="ln3300">}</a>
<a name="ln3301"> </a>
<a name="ln3302">NoSelectTextItem::NoSelectTextItem()</a>
<a name="ln3303">{</a>
<a name="ln3304">}</a>
<a name="ln3305"> </a>
<a name="ln3306">NoSelectTextItem::~NoSelectTextItem()</a>
<a name="ln3307">{</a>
<a name="ln3308">}</a>
<a name="ln3309"> </a>
<a name="ln3310">// Do not allow selection</a>
<a name="ln3311">bool NoSelectTextItem::selected() const</a>
<a name="ln3312">{</a>
<a name="ln3313">    return false;</a>
<a name="ln3314">}</a>
<a name="ln3315"> </a>
<a name="ln3316">// Do not allow highlight</a>
<a name="ln3317">bool NoSelectTextItem::can_be_highlighted() const</a>
<a name="ln3318">{</a>
<a name="ln3319">    return false;</a>
<a name="ln3320">}</a>
<a name="ln3321"> </a>
<a name="ln3322">void FormattedTextItem::render()</a>
<a name="ln3323">{</a>
<a name="ln3324">    if (!m_visible)</a>
<a name="ln3325">        return;</a>
<a name="ln3326"> </a>
<a name="ln3327">    if (m_max_coord.x == m_min_coord.x || m_max_coord.y == m_min_coord.y)</a>
<a name="ln3328">        return;</a>
<a name="ln3329"> </a>
<a name="ln3330">#ifdef USE_TILE_LOCAL</a>
<a name="ln3331">    if (m_dirty)</a>
<a name="ln3332">    {</a>
<a name="ln3333">        m_font_buf.clear();</a>
<a name="ln3334">        // FIXME: m_fg_colour doesn't work here while it works in console.</a>
<a name="ln3335">        m_font_buf.add(formatted_string::parse_string(m_render_text,</a>
<a name="ln3336">                                                      m_fg_colour),</a>
<a name="ln3337">                       m_min_coord.x, m_min_coord.y + get_vertical_offset());</a>
<a name="ln3338">        m_dirty = false;</a>
<a name="ln3339">    }</a>
<a name="ln3340">    m_font_buf.draw();</a>
<a name="ln3341">#else</a>
<a name="ln3342">    // Clean the drawing area first</a>
<a name="ln3343">    // clear_to_end_of_line does not work for us</a>
<a name="ln3344">    ASSERT(m_max_coord.x &gt; m_min_coord.x);</a>
<a name="ln3345">    ASSERT(m_max_coord.y &gt; m_min_coord.y);</a>
<a name="ln3346">    string white_space(m_max_coord.x - m_min_coord.x, ' ');</a>
<a name="ln3347">    for (int i = 0; i &lt; (m_max_coord.y - m_min_coord.y); ++i)</a>
<a name="ln3348">    {</a>
<a name="ln3349">        cgotoxy(m_min_coord.x, m_min_coord.y + i);</a>
<a name="ln3350">        cprintf(&quot;%s&quot;, white_space.c_str());</a>
<a name="ln3351">    }</a>
<a name="ln3352"> </a>
<a name="ln3353">    cgotoxy(m_min_coord.x, m_min_coord.y);</a>
<a name="ln3354">    textcolour(m_fg_colour);</a>
<a name="ln3355">    display_tagged_block(m_render_text);</a>
<a name="ln3356">#endif</a>
<a name="ln3357">}</a>
<a name="ln3358"> </a>
<a name="ln3359">#ifdef USE_TILE_LOCAL</a>
<a name="ln3360">TextTileItem::TextTileItem()</a>
<a name="ln3361">{</a>
<a name="ln3362">    for (int i = 0; i &lt; TEX_MAX; i++)</a>
<a name="ln3363">        m_tile_buf[i].set_tex(&amp;tiles.get_image_manager()-&gt;m_textures[i]);</a>
<a name="ln3364">    m_unit_height_pixels = max&lt;int&gt;(m_unit_height_pixels, TILE_Y);</a>
<a name="ln3365">}</a>
<a name="ln3366"> </a>
<a name="ln3367">TextTileItem::~TextTileItem()</a>
<a name="ln3368">{</a>
<a name="ln3369">}</a>
<a name="ln3370"> </a>
<a name="ln3371">void TextTileItem::add_tile(tile_def tile)</a>
<a name="ln3372">{</a>
<a name="ln3373">    m_tiles.push_back(tile);</a>
<a name="ln3374">    m_dirty = true;</a>
<a name="ln3375">}</a>
<a name="ln3376"> </a>
<a name="ln3377">void TextTileItem::set_bounds(const coord_def &amp;min_coord, const coord_def &amp;max_coord)</a>
<a name="ln3378">{</a>
<a name="ln3379">    // these are saved in font dx / dy for mouse to work properly</a>
<a name="ln3380">    // remove 1 unit from all the entries because console starts at (1,1)</a>
<a name="ln3381">    // but tiles starts at (0,0)</a>
<a name="ln3382">    m_min_coord.x = (min_coord.x - 1) * m_unit_width_pixels;</a>
<a name="ln3383">    m_max_coord.x = (max_coord.x - 1) * m_unit_width_pixels + 4;</a>
<a name="ln3384">    m_min_coord.y = (min_coord.y - 1) * m_unit_height_pixels;</a>
<a name="ln3385">    m_max_coord.y = (max_coord.y - 1) * m_unit_height_pixels + 4;</a>
<a name="ln3386">}</a>
<a name="ln3387"> </a>
<a name="ln3388">void TextTileItem::render()</a>
<a name="ln3389">{</a>
<a name="ln3390">    if (!m_visible)</a>
<a name="ln3391">        return;</a>
<a name="ln3392"> </a>
<a name="ln3393">    if (m_dirty)</a>
<a name="ln3394">    {</a>
<a name="ln3395">        m_font_buf.clear();</a>
<a name="ln3396">        for (int t = 0; t &lt; TEX_MAX; t++)</a>
<a name="ln3397">            m_tile_buf[t].clear();</a>
<a name="ln3398">        for (const tile_def &amp;tdef : m_tiles)</a>
<a name="ln3399">        {</a>
<a name="ln3400">            int tile      = tdef.tile;</a>
<a name="ln3401">            TextureID tex = tdef.tex;</a>
<a name="ln3402">            m_tile_buf[tex].add_unscaled(tile, m_min_coord.x + 2, m_min_coord.y + 2,</a>
<a name="ln3403">                                         tdef.ymax,</a>
<a name="ln3404">                                         (float)m_unit_height_pixels / TILE_Y);</a>
<a name="ln3405">        }</a>
<a name="ln3406">        // center the text</a>
<a name="ln3407">        // TODO wrap / chop the text</a>
<a name="ln3408">        const int tile_offset = m_tiles.empty() ? 0 : (m_unit_height_pixels + 6);</a>
<a name="ln3409">        m_font_buf.add(m_text, term_colours[m_fg_colour],</a>
<a name="ln3410">                       m_min_coord.x + 2 + tile_offset,</a>
<a name="ln3411">                       m_min_coord.y + 2 + get_vertical_offset());</a>
<a name="ln3412"> </a>
<a name="ln3413">        m_dirty = false;</a>
<a name="ln3414">    }</a>
<a name="ln3415"> </a>
<a name="ln3416">    m_font_buf.draw();</a>
<a name="ln3417">    for (int i = 0; i &lt; TEX_MAX; i++)</a>
<a name="ln3418">        m_tile_buf[i].draw();</a>
<a name="ln3419">}</a>
<a name="ln3420">#endif</a>
<a name="ln3421"> </a>
<a name="ln3422">MenuObject::MenuObject() : m_dirty(false), m_allow_focus(true), m_min_coord(0,0),</a>
<a name="ln3423">                           m_max_coord(0,0), m_object_name(&quot;unnamed object&quot;)</a>
<a name="ln3424">{</a>
<a name="ln3425">#ifdef USE_TILE_LOCAL</a>
<a name="ln3426">    m_unit_width_pixels = tiles.get_crt_font()-&gt;char_width();</a>
<a name="ln3427">    m_unit_height_pixels = tiles.get_crt_font()-&gt;char_height();</a>
<a name="ln3428">#endif</a>
<a name="ln3429">}</a>
<a name="ln3430"> </a>
<a name="ln3431">MenuObject::~MenuObject()</a>
<a name="ln3432">{</a>
<a name="ln3433">}</a>
<a name="ln3434"> </a>
<a name="ln3435">#ifdef USE_TILE_LOCAL</a>
<a name="ln3436">void MenuObject::set_height(const int height)</a>
<a name="ln3437">{</a>
<a name="ln3438">    m_unit_height_pixels = height;</a>
<a name="ln3439">}</a>
<a name="ln3440">#endif</a>
<a name="ln3441"> </a>
<a name="ln3442">void MenuObject::init(const coord_def&amp; min_coord, const coord_def&amp; max_coord,</a>
<a name="ln3443">                      const string&amp; name)</a>
<a name="ln3444">{</a>
<a name="ln3445">#ifdef USE_TILE_LOCAL</a>
<a name="ln3446">    // these are saved in font dx / dy for mouse to work properly</a>
<a name="ln3447">    // remove 1 unit from all the entries because console starts at (1,1)</a>
<a name="ln3448">    // but tiles starts at (0,0)</a>
<a name="ln3449">    m_min_coord.x = (min_coord.x - 1) * m_unit_width_pixels;</a>
<a name="ln3450">    m_min_coord.y = (min_coord.y - 1) * m_unit_height_pixels;</a>
<a name="ln3451">    m_max_coord.x = (max_coord.x - 1) * m_unit_width_pixels;</a>
<a name="ln3452">    m_max_coord.y = (max_coord.y - 1) * m_unit_height_pixels;</a>
<a name="ln3453">#else</a>
<a name="ln3454">    m_min_coord = min_coord;</a>
<a name="ln3455">    m_max_coord = max_coord;</a>
<a name="ln3456">#endif</a>
<a name="ln3457">    m_object_name = name;</a>
<a name="ln3458">}</a>
<a name="ln3459"> </a>
<a name="ln3460">bool MenuObject::_is_mouse_in_bounds(const coord_def&amp; pos)</a>
<a name="ln3461">{</a>
<a name="ln3462">    // Is the mouse in our bounds?</a>
<a name="ln3463">    if (m_min_coord.x &gt; static_cast&lt;int&gt; (pos.x)</a>
<a name="ln3464">        || m_max_coord.x &lt; static_cast&lt;int&gt; (pos.x)</a>
<a name="ln3465">        || m_min_coord.y &gt; static_cast&lt;int&gt; (pos.y)</a>
<a name="ln3466">        || m_max_coord.y &lt; static_cast&lt;int&gt; (pos.y))</a>
<a name="ln3467">    {</a>
<a name="ln3468">        return false;</a>
<a name="ln3469">    }</a>
<a name="ln3470">    return true;</a>
<a name="ln3471">}</a>
<a name="ln3472"> </a>
<a name="ln3473">MenuItem* MenuObject::_find_item_by_mouse_coords(const coord_def&amp; pos)</a>
<a name="ln3474">{</a>
<a name="ln3475">    // Is the mouse even in bounds?</a>
<a name="ln3476">    if (!_is_mouse_in_bounds(pos))</a>
<a name="ln3477">        return nullptr;</a>
<a name="ln3478"> </a>
<a name="ln3479">    // Traverse</a>
<a name="ln3480">    for (MenuItem *item : m_entries)</a>
<a name="ln3481">    {</a>
<a name="ln3482">        if (!item-&gt;can_be_highlighted())</a>
<a name="ln3483">        {</a>
<a name="ln3484">            // this is a noselect entry, skip it</a>
<a name="ln3485">            continue;</a>
<a name="ln3486">        }</a>
<a name="ln3487">        if (!item-&gt;is_visible())</a>
<a name="ln3488">        {</a>
<a name="ln3489">            // this item is not visible, skip it</a>
<a name="ln3490">            continue;</a>
<a name="ln3491">        }</a>
<a name="ln3492">        if (pos.x &gt;= item-&gt;get_min_coord().x</a>
<a name="ln3493">            &amp;&amp; pos.x &lt;= item-&gt;get_max_coord().x</a>
<a name="ln3494">            &amp;&amp; pos.y &gt;= item-&gt;get_min_coord().y</a>
<a name="ln3495">            &amp;&amp; pos.y &lt;= item-&gt;get_max_coord().y)</a>
<a name="ln3496">        {</a>
<a name="ln3497">            // We're inside</a>
<a name="ln3498">            return item;</a>
<a name="ln3499">        }</a>
<a name="ln3500">    }</a>
<a name="ln3501"> </a>
<a name="ln3502">    // nothing found</a>
<a name="ln3503">    return nullptr;</a>
<a name="ln3504">}</a>
<a name="ln3505"> </a>
<a name="ln3506">MenuItem* MenuObject::find_item_by_hotkey(int key)</a>
<a name="ln3507">{</a>
<a name="ln3508">    // browse through all the Entries</a>
<a name="ln3509">    for (MenuItem *item : m_entries)</a>
<a name="ln3510">        for (int hotkey : item-&gt;get_hotkeys())</a>
<a name="ln3511">            if (key == hotkey)</a>
<a name="ln3512">                return item;</a>
<a name="ln3513"> </a>
<a name="ln3514">    return nullptr;</a>
<a name="ln3515">}</a>
<a name="ln3516"> </a>
<a name="ln3517">MenuItem* MenuObject::select_item_by_hotkey(int key)</a>
<a name="ln3518">{</a>
<a name="ln3519">    MenuItem* item = find_item_by_hotkey(key);</a>
<a name="ln3520">    if (item)</a>
<a name="ln3521">        select_item(item);</a>
<a name="ln3522">    return item;</a>
<a name="ln3523">}</a>
<a name="ln3524"> </a>
<a name="ln3525">vector&lt;MenuItem*&gt; MenuObject::get_selected_items()</a>
<a name="ln3526">{</a>
<a name="ln3527">    vector&lt;MenuItem *&gt; result;</a>
<a name="ln3528">    for (MenuItem *item : m_entries)</a>
<a name="ln3529">        if (item-&gt;selected())</a>
<a name="ln3530">            result.push_back(item);</a>
<a name="ln3531"> </a>
<a name="ln3532">    return result;</a>
<a name="ln3533">}</a>
<a name="ln3534"> </a>
<a name="ln3535">void MenuObject::clear_selections()</a>
<a name="ln3536">{</a>
<a name="ln3537">    for (MenuItem *item : m_entries)</a>
<a name="ln3538">        item-&gt;select(false);</a>
<a name="ln3539">}</a>
<a name="ln3540"> </a>
<a name="ln3541">void MenuObject::allow_focus(bool toggle)</a>
<a name="ln3542">{</a>
<a name="ln3543">    m_allow_focus = toggle;</a>
<a name="ln3544">}</a>
<a name="ln3545"> </a>
<a name="ln3546">bool MenuObject::can_be_focused()</a>
<a name="ln3547">{</a>
<a name="ln3548">    if (m_entries.empty())</a>
<a name="ln3549">    {</a>
<a name="ln3550">        // Do not allow focusing empty containers by default</a>
<a name="ln3551">        return false;</a>
<a name="ln3552">    }</a>
<a name="ln3553">    return m_allow_focus;</a>
<a name="ln3554">}</a>
<a name="ln3555"> </a>
<a name="ln3556">void MenuObject::set_visible(bool flag)</a>
<a name="ln3557">{</a>
<a name="ln3558">    m_visible = flag;</a>
<a name="ln3559">}</a>
<a name="ln3560"> </a>
<a name="ln3561">bool MenuObject::is_visible() const</a>
<a name="ln3562">{</a>
<a name="ln3563">    return m_visible;</a>
<a name="ln3564">}</a>
<a name="ln3565"> </a>
<a name="ln3566">MenuFreeform::MenuFreeform(): m_active_item(nullptr), m_default_item(nullptr)</a>
<a name="ln3567">{</a>
<a name="ln3568">}</a>
<a name="ln3569"> </a>
<a name="ln3570">MenuFreeform::~MenuFreeform()</a>
<a name="ln3571">{</a>
<a name="ln3572">    deleteAll(m_entries);</a>
<a name="ln3573">}</a>
<a name="ln3574"> </a>
<a name="ln3575">void MenuFreeform::set_default_item(MenuItem* item)</a>
<a name="ln3576">{</a>
<a name="ln3577">    m_default_item = item;</a>
<a name="ln3578">}</a>
<a name="ln3579"> </a>
<a name="ln3580">void MenuFreeform::activate_default_item()</a>
<a name="ln3581">{</a>
<a name="ln3582">    m_active_item = m_default_item;</a>
<a name="ln3583">}</a>
<a name="ln3584"> </a>
<a name="ln3585">MenuObject::InputReturnValue MenuFreeform::process_input(int key)</a>
<a name="ln3586">{</a>
<a name="ln3587">    if (!m_allow_focus || !m_visible)</a>
<a name="ln3588">        return INPUT_NO_ACTION;</a>
<a name="ln3589"> </a>
<a name="ln3590">    if (m_active_item == nullptr)</a>
<a name="ln3591">    {</a>
<a name="ln3592">        if (m_entries.empty())</a>
<a name="ln3593">        {</a>
<a name="ln3594">            // nothing to process</a>
<a name="ln3595">            return MenuObject::INPUT_NO_ACTION;</a>
<a name="ln3596">        }</a>
<a name="ln3597">        else if (m_default_item == nullptr)</a>
<a name="ln3598">        {</a>
<a name="ln3599">            // pick the first item possible</a>
<a name="ln3600">            for (auto mentry : m_entries)</a>
<a name="ln3601">            {</a>
<a name="ln3602">                if (mentry-&gt;can_be_highlighted())</a>
<a name="ln3603">                {</a>
<a name="ln3604">                    m_active_item = mentry;</a>
<a name="ln3605">                    break;</a>
<a name="ln3606">                }</a>
<a name="ln3607">            }</a>
<a name="ln3608">        }</a>
<a name="ln3609">    }</a>
<a name="ln3610"> </a>
<a name="ln3611">    if (m_active_item == nullptr &amp;&amp; m_default_item != nullptr)</a>
<a name="ln3612">    {</a>
<a name="ln3613">        switch (key)</a>
<a name="ln3614">        {</a>
<a name="ln3615">        case CK_UP:</a>
<a name="ln3616">        case CK_DOWN:</a>
<a name="ln3617">        case CK_LEFT:</a>
<a name="ln3618">        case CK_RIGHT:</a>
<a name="ln3619">        case CK_ENTER:</a>
<a name="ln3620">            set_active_item(m_default_item);</a>
<a name="ln3621">            return MenuObject::INPUT_ACTIVE_CHANGED;</a>
<a name="ln3622">        }</a>
<a name="ln3623">    }</a>
<a name="ln3624"> </a>
<a name="ln3625">    MenuItem* find_entry = nullptr;</a>
<a name="ln3626">    switch (key)</a>
<a name="ln3627">    {</a>
<a name="ln3628">    case CK_ENTER:</a>
<a name="ln3629">        if (m_active_item == nullptr)</a>
<a name="ln3630">            return MenuObject::INPUT_NO_ACTION;</a>
<a name="ln3631"> </a>
<a name="ln3632">        select_item(m_active_item);</a>
<a name="ln3633">        if (m_active_item-&gt;selected())</a>
<a name="ln3634">            return MenuObject::INPUT_SELECTED;</a>
<a name="ln3635">        else</a>
<a name="ln3636">            return MenuObject::INPUT_DESELECTED;</a>
<a name="ln3637">        break;</a>
<a name="ln3638">    case CK_UP:</a>
<a name="ln3639">        find_entry = _find_item_by_direction(m_active_item, UP);</a>
<a name="ln3640">        if (find_entry != nullptr)</a>
<a name="ln3641">        {</a>
<a name="ln3642">            set_active_item(find_entry);</a>
<a name="ln3643">            return MenuObject::INPUT_ACTIVE_CHANGED;</a>
<a name="ln3644">        }</a>
<a name="ln3645">        else</a>
<a name="ln3646">            return MenuObject::INPUT_FOCUS_RELEASE_UP;</a>
<a name="ln3647">        break;</a>
<a name="ln3648">    case CK_DOWN:</a>
<a name="ln3649">        find_entry = _find_item_by_direction(m_active_item, DOWN);</a>
<a name="ln3650">        if (find_entry != nullptr)</a>
<a name="ln3651">        {</a>
<a name="ln3652">            set_active_item(find_entry);</a>
<a name="ln3653">            return MenuObject::INPUT_ACTIVE_CHANGED;</a>
<a name="ln3654">        }</a>
<a name="ln3655">        else</a>
<a name="ln3656">            return MenuObject::INPUT_FOCUS_RELEASE_DOWN;</a>
<a name="ln3657">        break;</a>
<a name="ln3658">    case CK_LEFT:</a>
<a name="ln3659">        find_entry = _find_item_by_direction(m_active_item, LEFT);</a>
<a name="ln3660">        if (find_entry != nullptr)</a>
<a name="ln3661">        {</a>
<a name="ln3662">            set_active_item(find_entry);</a>
<a name="ln3663">            return MenuObject::INPUT_ACTIVE_CHANGED;</a>
<a name="ln3664">        }</a>
<a name="ln3665">        else</a>
<a name="ln3666">            return MenuObject::INPUT_FOCUS_RELEASE_LEFT;</a>
<a name="ln3667">        break;</a>
<a name="ln3668">    case CK_RIGHT:</a>
<a name="ln3669">        find_entry = _find_item_by_direction(m_active_item, RIGHT);</a>
<a name="ln3670">        if (find_entry != nullptr)</a>
<a name="ln3671">        {</a>
<a name="ln3672">            set_active_item(find_entry);</a>
<a name="ln3673">            return MenuObject::INPUT_ACTIVE_CHANGED;</a>
<a name="ln3674">        }</a>
<a name="ln3675">        else</a>
<a name="ln3676">            return MenuObject::INPUT_FOCUS_RELEASE_RIGHT;</a>
<a name="ln3677">        break;</a>
<a name="ln3678">    default:</a>
<a name="ln3679">        find_entry = select_item_by_hotkey(key);</a>
<a name="ln3680">        if (find_entry != nullptr)</a>
<a name="ln3681">        {</a>
<a name="ln3682">            if (find_entry-&gt;selected())</a>
<a name="ln3683">                return MenuObject::INPUT_SELECTED;</a>
<a name="ln3684">            else</a>
<a name="ln3685">                return MenuObject::INPUT_DESELECTED;</a>
<a name="ln3686">        }</a>
<a name="ln3687">        break;</a>
<a name="ln3688">    }</a>
<a name="ln3689">    return MenuObject::INPUT_NO_ACTION;</a>
<a name="ln3690">}</a>
<a name="ln3691"> </a>
<a name="ln3692">#ifdef USE_TILE_LOCAL</a>
<a name="ln3693">MenuObject::InputReturnValue MenuFreeform::handle_mouse(const wm_mouse_event&amp; me)</a>
<a name="ln3694">{</a>
<a name="ln3695">    if (!m_allow_focus || !m_visible)</a>
<a name="ln3696">        return INPUT_NO_ACTION;</a>
<a name="ln3697"> </a>
<a name="ln3698">    if (!_is_mouse_in_bounds(coord_def(me.px, me.py)))</a>
<a name="ln3699">    {</a>
<a name="ln3700">        if (m_active_item != nullptr)</a>
<a name="ln3701">        {</a>
<a name="ln3702">            _set_active_item(nullptr);</a>
<a name="ln3703">            return INPUT_FOCUS_LOST;</a>
<a name="ln3704">        }</a>
<a name="ln3705">        else</a>
<a name="ln3706">            return INPUT_NO_ACTION;</a>
<a name="ln3707">    }</a>
<a name="ln3708"> </a>
<a name="ln3709">    MenuItem* find_item = _find_item_by_mouse_coords(coord_def(me.px, me.py));</a>
<a name="ln3710"> </a>
<a name="ln3711">    if (find_item &amp;&amp; find_item-&gt;handle_mouse(me))</a>
<a name="ln3712">        return MenuObject::INPUT_SELECTED; // The object handled the event</a>
<a name="ln3713">    else if (me.event == wm_mouse_event::MOVE)</a>
<a name="ln3714">    {</a>
<a name="ln3715">        if (find_item == nullptr)</a>
<a name="ln3716">        {</a>
<a name="ln3717">            if (m_active_item != nullptr)</a>
<a name="ln3718">            {</a>
<a name="ln3719">                _set_active_item(nullptr);</a>
<a name="ln3720">                return INPUT_NO_ACTION;</a>
<a name="ln3721">            }</a>
<a name="ln3722">        }</a>
<a name="ln3723">        else</a>
<a name="ln3724">        {</a>
<a name="ln3725">            if (m_active_item != find_item)</a>
<a name="ln3726">            {</a>
<a name="ln3727">                set_active_item(find_item);</a>
<a name="ln3728">                return INPUT_ACTIVE_CHANGED;</a>
<a name="ln3729">            }</a>
<a name="ln3730">        }</a>
<a name="ln3731">        return INPUT_NO_ACTION;</a>
<a name="ln3732">    }</a>
<a name="ln3733">    InputReturnValue ret = INPUT_NO_ACTION;</a>
<a name="ln3734">    if (me.event == wm_mouse_event::PRESS)</a>
<a name="ln3735">    {</a>
<a name="ln3736">        if (me.button == wm_mouse_event::LEFT)</a>
<a name="ln3737">        {</a>
<a name="ln3738">            if (find_item != nullptr)</a>
<a name="ln3739">            {</a>
<a name="ln3740">                select_item(find_item);</a>
<a name="ln3741">                if (find_item-&gt;selected())</a>
<a name="ln3742">                    ret = INPUT_SELECTED;</a>
<a name="ln3743">                else</a>
<a name="ln3744">                    ret = INPUT_DESELECTED;</a>
<a name="ln3745">            }</a>
<a name="ln3746">        }</a>
<a name="ln3747">        else if (me.button == wm_mouse_event::RIGHT)</a>
<a name="ln3748">            ret = INPUT_END_MENU_ABORT;</a>
<a name="ln3749">    }</a>
<a name="ln3750">    // all the other Mouse Events are uninteresting and are ignored</a>
<a name="ln3751">    return ret;</a>
<a name="ln3752">}</a>
<a name="ln3753">#endif</a>
<a name="ln3754"> </a>
<a name="ln3755">void MenuFreeform::render()</a>
<a name="ln3756">{</a>
<a name="ln3757">    if (!m_visible)</a>
<a name="ln3758">        return;</a>
<a name="ln3759"> </a>
<a name="ln3760">    if (m_dirty)</a>
<a name="ln3761">        _place_items();</a>
<a name="ln3762"> </a>
<a name="ln3763">    for (MenuItem *item : m_entries)</a>
<a name="ln3764">        item-&gt;render();</a>
<a name="ln3765">}</a>
<a name="ln3766"> </a>
<a name="ln3767">/**</a>
<a name="ln3768"> * Handle all the dirtyness here that the MenuItems themselves do not handle</a>
<a name="ln3769"> */</a>
<a name="ln3770">void MenuFreeform::_place_items()</a>
<a name="ln3771">{</a>
<a name="ln3772">    m_dirty = false;</a>
<a name="ln3773">}</a>
<a name="ln3774"> </a>
<a name="ln3775">MenuItem* MenuFreeform::get_active_item()</a>
<a name="ln3776">{</a>
<a name="ln3777">    return m_active_item;</a>
<a name="ln3778">}</a>
<a name="ln3779"> </a>
<a name="ln3780">/**</a>
<a name="ln3781"> * Sets item by ID</a>
<a name="ln3782"> * Clears active item if ID not found</a>
<a name="ln3783"> */</a>
<a name="ln3784">void MenuFreeform::set_active_item(int ID)</a>
<a name="ln3785">{</a>
<a name="ln3786">    auto it = find_if(m_entries.begin(), m_entries.end(),</a>
<a name="ln3787">            [=](const MenuItem* item) { return item-&gt;get_id() == ID; });</a>
<a name="ln3788">    m_active_item = (it != m_entries.end()) ? *it : nullptr;</a>
<a name="ln3789">    m_dirty = true;</a>
<a name="ln3790">}</a>
<a name="ln3791"> </a>
<a name="ln3792">/**</a>
<a name="ln3793"> * Sets active item based on index</a>
<a name="ln3794"> * This function is for internal use if object does not have ID set</a>
<a name="ln3795"> */</a>
<a name="ln3796">void MenuFreeform::_set_active_item(MenuItem* item)</a>
<a name="ln3797">{</a>
<a name="ln3798">    ASSERT(!item || item-&gt;can_be_highlighted());</a>
<a name="ln3799">    m_active_item = item;</a>
<a name="ln3800">    m_dirty = true;</a>
<a name="ln3801">}</a>
<a name="ln3802"> </a>
<a name="ln3803">void MenuFreeform::set_active_item(MenuItem* item)</a>
<a name="ln3804">{</a>
<a name="ln3805">    bool present = find(m_entries.begin(), m_entries.end(), item) != m_entries.end();</a>
<a name="ln3806">    m_active_item = (present &amp;&amp; item-&gt;can_be_highlighted()) ? item : nullptr;</a>
<a name="ln3807">    m_dirty = true;</a>
<a name="ln3808">}</a>
<a name="ln3809"> </a>
<a name="ln3810">void MenuFreeform::activate_first_item()</a>
<a name="ln3811">{</a>
<a name="ln3812">    auto el = find_if(m_entries.begin(), m_entries.end(),</a>
<a name="ln3813">            [=](const MenuItem* item) { return item-&gt;can_be_highlighted(); });</a>
<a name="ln3814">    if (el != m_entries.end())</a>
<a name="ln3815">        _set_active_item(*el);</a>
<a name="ln3816">}</a>
<a name="ln3817"> </a>
<a name="ln3818">void MenuFreeform::activate_last_item()</a>
<a name="ln3819">{</a>
<a name="ln3820">    auto el = find_if(m_entries.rbegin(), m_entries.rend(),</a>
<a name="ln3821">            [=](const MenuItem* item) { return item-&gt;can_be_highlighted(); });</a>
<a name="ln3822">    if (el != m_entries.rend())</a>
<a name="ln3823">        _set_active_item(*el);</a>
<a name="ln3824">}</a>
<a name="ln3825"> </a>
<a name="ln3826">bool MenuFreeform::select_item(int index)</a>
<a name="ln3827">{</a>
<a name="ln3828">    if (index &gt;= 0 &amp;&amp; index &lt; static_cast&lt;int&gt; (m_entries.size()))</a>
<a name="ln3829">    {</a>
<a name="ln3830">        // Flip the selection flag</a>
<a name="ln3831">        m_entries.at(index)-&gt;select(!m_entries.at(index)-&gt;selected());</a>
<a name="ln3832">    }</a>
<a name="ln3833">    return m_entries.at(index)-&gt;selected();</a>
<a name="ln3834">}</a>
<a name="ln3835"> </a>
<a name="ln3836">bool MenuFreeform::select_item(MenuItem* item)</a>
<a name="ln3837">{</a>
<a name="ln3838">    ASSERT(item != nullptr);</a>
<a name="ln3839"> </a>
<a name="ln3840">    // Is the given item in menu?</a>
<a name="ln3841">    auto find_val = find(m_entries.begin(), m_entries.end(), item);</a>
<a name="ln3842">    if (find_val != m_entries.end())</a>
<a name="ln3843">    {</a>
<a name="ln3844">        // Flip the selection flag</a>
<a name="ln3845">        item-&gt;select(!item-&gt;selected());</a>
<a name="ln3846">    }</a>
<a name="ln3847">    return item-&gt;selected();</a>
<a name="ln3848">}</a>
<a name="ln3849"> </a>
<a name="ln3850">bool MenuFreeform::attach_item(MenuItem* item)</a>
<a name="ln3851">{</a>
<a name="ln3852">    // is the item inside boundaries?</a>
<a name="ln3853">    if (   item-&gt;get_min_coord().x &lt; m_min_coord.x</a>
<a name="ln3854">        || item-&gt;get_min_coord().x &gt; m_max_coord.x</a>
<a name="ln3855">        || item-&gt;get_min_coord().y &lt; m_min_coord.y</a>
<a name="ln3856">        || item-&gt;get_min_coord().y &gt; m_max_coord.y</a>
<a name="ln3857">        || item-&gt;get_max_coord().x &lt; m_min_coord.x</a>
<a name="ln3858">        || item-&gt;get_max_coord().x &gt; m_max_coord.x</a>
<a name="ln3859">        || item-&gt;get_max_coord().y &lt; m_min_coord.y</a>
<a name="ln3860">        || item-&gt;get_max_coord().y &gt; m_max_coord.y)</a>
<a name="ln3861">    {</a>
<a name="ln3862">        return false;</a>
<a name="ln3863">    }</a>
<a name="ln3864">    // It's inside boundaries</a>
<a name="ln3865"> </a>
<a name="ln3866">    m_entries.push_back(item);</a>
<a name="ln3867">    return true;</a>
<a name="ln3868">}</a>
<a name="ln3869"> </a>
<a name="ln3870">/**</a>
<a name="ln3871"> * Finds the closest rectangle to given entry begin_index on a caardinal</a>
<a name="ln3872"> * direction from it.</a>
<a name="ln3873"> * if no entries are found, -1 is returned</a>
<a name="ln3874"> */</a>
<a name="ln3875">MenuItem* MenuFreeform::_find_item_by_direction(const MenuItem* start,</a>
<a name="ln3876">                                                MenuObject::Direction dir)</a>
<a name="ln3877">{</a>
<a name="ln3878">    if (start == nullptr)</a>
<a name="ln3879">        return nullptr;</a>
<a name="ln3880"> </a>
<a name="ln3881">    coord_def aabb_start(0,0);</a>
<a name="ln3882">    coord_def aabb_end(0,0);</a>
<a name="ln3883"> </a>
<a name="ln3884">    // construct the aabb</a>
<a name="ln3885">    switch (dir)</a>
<a name="ln3886">    {</a>
<a name="ln3887">    case UP:</a>
<a name="ln3888">        if (start-&gt;get_link_up())</a>
<a name="ln3889">            return start-&gt;get_link_up();</a>
<a name="ln3890"> </a>
<a name="ln3891">        aabb_start.x = start-&gt;get_min_coord().x;</a>
<a name="ln3892">        aabb_end.x = start-&gt;get_max_coord().x;</a>
<a name="ln3893">        aabb_start.y = 0; // top of screen</a>
<a name="ln3894">        aabb_end.y = start-&gt;get_min_coord().y;</a>
<a name="ln3895">        break;</a>
<a name="ln3896">    case DOWN:</a>
<a name="ln3897">        if (start-&gt;get_link_down())</a>
<a name="ln3898">            return start-&gt;get_link_down();</a>
<a name="ln3899"> </a>
<a name="ln3900">        aabb_start.x = start-&gt;get_min_coord().x;</a>
<a name="ln3901">        aabb_end.x = start-&gt;get_max_coord().x;</a>
<a name="ln3902">        aabb_start.y = start-&gt;get_max_coord().y;</a>
<a name="ln3903">        // we choose an arbitrarily large number here, because</a>
<a name="ln3904">        // tiles saves entry coordinates in pixels, yet console saves them</a>
<a name="ln3905">        // in characters</a>
<a name="ln3906">        // basically, we want the AABB to be large enough to extend to the</a>
<a name="ln3907">        // bottom of the screen in every possible resolution</a>
<a name="ln3908">        aabb_end.y = 32767;</a>
<a name="ln3909">        break;</a>
<a name="ln3910">    case LEFT:</a>
<a name="ln3911">        if (start-&gt;get_link_left())</a>
<a name="ln3912">            return start-&gt;get_link_left();</a>
<a name="ln3913"> </a>
<a name="ln3914">        aabb_start.x = 0; // left of screen</a>
<a name="ln3915">        aabb_end.x = start-&gt;get_min_coord().x;</a>
<a name="ln3916">        aabb_start.y = start-&gt;get_min_coord().y;</a>
<a name="ln3917">        aabb_end.y = start-&gt;get_max_coord().y;</a>
<a name="ln3918">        break;</a>
<a name="ln3919">    case RIGHT:</a>
<a name="ln3920">        if (start-&gt;get_link_right())</a>
<a name="ln3921">            return start-&gt;get_link_right();</a>
<a name="ln3922"> </a>
<a name="ln3923">        aabb_start.x = start-&gt;get_max_coord().x;</a>
<a name="ln3924">        // we again want a value that is always larger then the width of screen</a>
<a name="ln3925">        aabb_end.x = 32767;</a>
<a name="ln3926">        aabb_start.y = start-&gt;get_min_coord().y;</a>
<a name="ln3927">        aabb_end.y = start-&gt;get_max_coord().y;</a>
<a name="ln3928">        break;</a>
<a name="ln3929">    default:</a>
<a name="ln3930">        die(&quot;Bad direction given&quot;);</a>
<a name="ln3931">    }</a>
<a name="ln3932"> </a>
<a name="ln3933">    // loop through the entries</a>
<a name="ln3934">    // save the currently closest to the index in a variable</a>
<a name="ln3935">    MenuItem* closest = nullptr;</a>
<a name="ln3936">    for (MenuItem *item : m_entries)</a>
<a name="ln3937">    {</a>
<a name="ln3938">        if (!item-&gt;can_be_highlighted())</a>
<a name="ln3939">        {</a>
<a name="ln3940">            // this is a noselect entry, skip it</a>
<a name="ln3941">            continue;</a>
<a name="ln3942">        }</a>
<a name="ln3943">        if (!item-&gt;is_visible())</a>
<a name="ln3944">        {</a>
<a name="ln3945">            // this item is not visible, skip it</a>
<a name="ln3946">            continue;</a>
<a name="ln3947">        }</a>
<a name="ln3948">        if (!_AABB_intersection(item-&gt;get_min_coord(), item-&gt;get_max_coord(),</a>
<a name="ln3949">                                aabb_start, aabb_end))</a>
<a name="ln3950">        {</a>
<a name="ln3951">            continue; // does not intersect, continue loop</a>
<a name="ln3952">        }</a>
<a name="ln3953"> </a>
<a name="ln3954">        // intersects</a>
<a name="ln3955">        // check if it's closer than current</a>
<a name="ln3956">        if (closest == nullptr)</a>
<a name="ln3957">            closest = item;</a>
<a name="ln3958"> </a>
<a name="ln3959">        switch (dir)</a>
<a name="ln3960">        {</a>
<a name="ln3961">        case UP:</a>
<a name="ln3962">            if (item-&gt;get_min_coord().y &gt; closest-&gt;get_min_coord().y)</a>
<a name="ln3963">                closest = item;</a>
<a name="ln3964">            break;</a>
<a name="ln3965">        case DOWN:</a>
<a name="ln3966">            if (item-&gt;get_min_coord().y &lt; closest-&gt;get_min_coord().y)</a>
<a name="ln3967">                closest = item;</a>
<a name="ln3968">            break;</a>
<a name="ln3969">        case LEFT:</a>
<a name="ln3970">            if (item-&gt;get_min_coord().x &gt; closest-&gt;get_min_coord().x)</a>
<a name="ln3971">                closest = item;</a>
<a name="ln3972">            break;</a>
<a name="ln3973">        case RIGHT:</a>
<a name="ln3974">            if (item-&gt;get_min_coord().x &lt; closest-&gt;get_min_coord().x)</a>
<a name="ln3975">                closest = item;</a>
<a name="ln3976">        }</a>
<a name="ln3977">    }</a>
<a name="ln3978">    // TODO handle special cases here, like pressing down on the last entry</a>
<a name="ln3979">    // to go the the first item in that line</a>
<a name="ln3980">    return closest;</a>
<a name="ln3981">}</a>
<a name="ln3982"> </a>
<a name="ln3983">BoxMenuHighlighter::BoxMenuHighlighter(PrecisionMenu *parent): m_parent(parent),</a>
<a name="ln3984">    m_active_item(nullptr)</a>
<a name="ln3985">{</a>
<a name="ln3986">    ASSERT(parent != nullptr);</a>
<a name="ln3987">}</a>
<a name="ln3988"> </a>
<a name="ln3989">BoxMenuHighlighter::~BoxMenuHighlighter()</a>
<a name="ln3990">{</a>
<a name="ln3991">}</a>
<a name="ln3992"> </a>
<a name="ln3993">vector&lt;MenuItem*&gt; BoxMenuHighlighter::get_selected_items()</a>
<a name="ln3994">{</a>
<a name="ln3995">    vector&lt;MenuItem*&gt; ret_val;</a>
<a name="ln3996">    return ret_val;</a>
<a name="ln3997">}</a>
<a name="ln3998"> </a>
<a name="ln3999">MenuObject::InputReturnValue BoxMenuHighlighter::process_input(int /*key*/)</a>
<a name="ln4000">{</a>
<a name="ln4001">    // just in case we somehow end up processing input of this item</a>
<a name="ln4002">    return MenuObject::INPUT_NO_ACTION;</a>
<a name="ln4003">}</a>
<a name="ln4004"> </a>
<a name="ln4005">#ifdef USE_TILE_LOCAL</a>
<a name="ln4006">MenuObject::InputReturnValue BoxMenuHighlighter::handle_mouse(const wm_mouse_event &amp;/*me*/)</a>
<a name="ln4007">{</a>
<a name="ln4008">    // we have nothing interesting to do on mouse events because render()</a>
<a name="ln4009">    // always checks if the active has changed</a>
<a name="ln4010">    return MenuObject::INPUT_NO_ACTION;</a>
<a name="ln4011">}</a>
<a name="ln4012">#endif</a>
<a name="ln4013"> </a>
<a name="ln4014">void BoxMenuHighlighter::render()</a>
<a name="ln4015">{</a>
<a name="ln4016">    if (!m_visible)</a>
<a name="ln4017">        return;</a>
<a name="ln4018"> </a>
<a name="ln4019">    if (!m_visible)</a>
<a name="ln4020">        return;</a>
<a name="ln4021">    _place_items();</a>
<a name="ln4022">#ifdef USE_TILE_LOCAL</a>
<a name="ln4023">    m_line_buf.draw();</a>
<a name="ln4024">    m_shape_buf.draw();</a>
<a name="ln4025">#else</a>
<a name="ln4026">    if (m_active_item != nullptr)</a>
<a name="ln4027">        m_active_item-&gt;render();</a>
<a name="ln4028">#endif</a>
<a name="ln4029">}</a>
<a name="ln4030"> </a>
<a name="ln4031">void BoxMenuHighlighter::_place_items()</a>
<a name="ln4032">{</a>
<a name="ln4033">    MenuItem* tmp = m_parent-&gt;get_active_item();</a>
<a name="ln4034">    if (tmp == m_active_item)</a>
<a name="ln4035">        return;</a>
<a name="ln4036"> </a>
<a name="ln4037">#ifdef USE_TILE_LOCAL</a>
<a name="ln4038">    m_line_buf.clear();</a>
<a name="ln4039">    m_shape_buf.clear();</a>
<a name="ln4040">    if (tmp != nullptr)</a>
<a name="ln4041">    {</a>
<a name="ln4042">        const VColour&amp; c = term_colours[tmp-&gt;get_highlight_colour()];</a>
<a name="ln4043">        const VColour bg_colour(c.r, c.g, c.b, 80);</a>
<a name="ln4044">        const VColour line_colour(c.r, c.g, c.b, 127);</a>
<a name="ln4045">        const coord_def tl = tmp-&gt;get_min_coord() + coord_def(1, 1);</a>
<a name="ln4046">        const coord_def br = tmp-&gt;get_max_coord();</a>
<a name="ln4047">        m_line_buf.add_square(tl.x, tl.y, br.x, br.y, line_colour);</a>
<a name="ln4048">        m_shape_buf.add(tl.x, tl.y, br.x, br.y, bg_colour);</a>
<a name="ln4049">    }</a>
<a name="ln4050">#else</a>
<a name="ln4051">    // we had an active item before</a>
<a name="ln4052">    if (m_active_item != nullptr)</a>
<a name="ln4053">    {</a>
<a name="ln4054">        // clear the background highlight trickery</a>
<a name="ln4055">        m_active_item-&gt;set_bg_colour(m_old_bg_colour);</a>
<a name="ln4056">        // redraw the old item</a>
<a name="ln4057">        m_active_item-&gt;render();</a>
<a name="ln4058">    }</a>
<a name="ln4059">    if (tmp != nullptr)</a>
<a name="ln4060">    {</a>
<a name="ln4061">        m_old_bg_colour = tmp-&gt;get_bg_colour();</a>
<a name="ln4062">        tmp-&gt;set_bg_colour(tmp-&gt;get_highlight_colour());</a>
<a name="ln4063">    }</a>
<a name="ln4064">#endif</a>
<a name="ln4065">    m_active_item = tmp;</a>
<a name="ln4066">}</a>

</code></pre>
<div class="balloon" rel="2281"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v648/" target="_blank">V648</a> Priority of the '&&' operation is higher than that of the '||' operation.</p></div>
<div class="balloon" rel="4019"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v547/" target="_blank">V547</a> Expression '!m_visible' is always false.</p></div>
<div class="balloon" rel="4019"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v649/" target="_blank">V649</a> There are two 'if' statements with identical conditional expressions. The first 'if' statement contains function return. This means that the second 'if' statement is senseless. Check lines: 4016, 4019.</p></div>
<div class="balloon" rel="3422"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v730/" target="_blank">V730</a> Not all members of a class are initialized inside the constructor. Consider inspecting: m_visible.</p></div>
<div class="balloon" rel="70"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v730/" target="_blank">V730</a> Not all members of a class are initialized inside the constructor. Consider inspecting: m_height, m_nat_column_width, m_draw_tiles.</p></div>

<link rel="stylesheet" href="highlight.css">
<script src="highlight.pack.js"></script>
<script src="highlightjs-line-numbers.js"></script>
<script>hljs.initHighlightingOnLoad();</script>
<script>hljs.initLineNumbersOnLoad();</script>
<script>
  $(document).ready(function() {
      $('.balloon').each(function () {
          var bl = $(this);
          var line = bl.attr('rel');
          var text = $('a[name="ln'+line+'"]').text();

          var space_count = 0;
          for(var i = 0; i<text.length; i++){
              var char = text[i];
              if((char !== ' ')&&(char !== '\t'))break;
              if(char === '\t')space_count++;
              space_count++;
          }

          bl.css('margin-left', space_count*8);
          $('a[name="ln'+line+'"]').after(bl);
      });

      window.location = window.location;
  });
</script>
</body>
</html>
