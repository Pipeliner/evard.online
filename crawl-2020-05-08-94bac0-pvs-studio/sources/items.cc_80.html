
<html>
<head>

  <meta http-equiv="Content-Type" content="text/html; charset=US-ASCII" />
  <title>items.cc</title>

  <link rel="stylesheet" href="../style.css"/>
  <script src="../jquery-3.2.1.min.js"></script>
</head>
<body>

<pre><code class = "cpp">
<a name="ln1">/**</a>
<a name="ln2"> * @file</a>
<a name="ln3"> * @brief Misc (mostly) inventory related functions.</a>
<a name="ln4">**/</a>
<a name="ln5"> </a>
<a name="ln6">#include &quot;AppHdr.h&quot;</a>
<a name="ln7"> </a>
<a name="ln8">#include &quot;items.h&quot;</a>
<a name="ln9"> </a>
<a name="ln10">#include &lt;algorithm&gt;</a>
<a name="ln11">#include &lt;cctype&gt;</a>
<a name="ln12">#include &lt;cstdio&gt;</a>
<a name="ln13">#include &lt;cstdlib&gt;</a>
<a name="ln14">#include &lt;cstring&gt;</a>
<a name="ln15">#include &lt;functional&gt; // mem_fn</a>
<a name="ln16">#include &lt;limits&gt;</a>
<a name="ln17"> </a>
<a name="ln18">#include &quot;adjust.h&quot;</a>
<a name="ln19">#include &quot;areas.h&quot;</a>
<a name="ln20">#include &quot;arena.h&quot;</a>
<a name="ln21">#include &quot;artefact.h&quot;</a>
<a name="ln22">#include &quot;art-enum.h&quot;</a>
<a name="ln23">#include &quot;beam.h&quot;</a>
<a name="ln24">#include &quot;bitary.h&quot;</a>
<a name="ln25">#include &quot;butcher.h&quot;</a>
<a name="ln26">#include &quot;cio.h&quot;</a>
<a name="ln27">#include &quot;clua.h&quot;</a>
<a name="ln28">#include &quot;colour.h&quot;</a>
<a name="ln29">#include &quot;coord.h&quot;</a>
<a name="ln30">#include &quot;coordit.h&quot;</a>
<a name="ln31">#include &quot;dbg-util.h&quot;</a>
<a name="ln32">#include &quot;defines.h&quot;</a>
<a name="ln33">#include &quot;delay.h&quot;</a>
<a name="ln34">#include &quot;describe.h&quot;</a>
<a name="ln35">#include &quot;dgn-event.h&quot;</a>
<a name="ln36">#include &quot;directn.h&quot;</a>
<a name="ln37">#include &quot;dungeon.h&quot;</a>
<a name="ln38">#include &quot;english.h&quot;</a>
<a name="ln39">#include &quot;env.h&quot;</a>
<a name="ln40">#include &quot;food.h&quot;</a>
<a name="ln41">#include &quot;god-passive.h&quot;</a>
<a name="ln42">#include &quot;god-prayer.h&quot;</a>
<a name="ln43">#include &quot;hints.h&quot;</a>
<a name="ln44">#include &quot;hints.h&quot;</a>
<a name="ln45">#include &quot;hiscores.h&quot;</a>
<a name="ln46">#include &quot;invent.h&quot;</a>
<a name="ln47">#include &quot;item-name.h&quot;</a>
<a name="ln48">#include &quot;item-prop.h&quot;</a>
<a name="ln49">#include &quot;item-status-flag-type.h&quot;</a>
<a name="ln50">#include &quot;item-use.h&quot;</a>
<a name="ln51">#include &quot;libutil.h&quot;</a>
<a name="ln52">#include &quot;macro.h&quot;</a>
<a name="ln53">#include &quot;makeitem.h&quot;</a>
<a name="ln54">#include &quot;message.h&quot;</a>
<a name="ln55">#include &quot;nearby-danger.h&quot;</a>
<a name="ln56">#include &quot;notes.h&quot;</a>
<a name="ln57">#include &quot;options.h&quot;</a>
<a name="ln58">#include &quot;orb.h&quot;</a>
<a name="ln59">#include &quot;output.h&quot;</a>
<a name="ln60">#include &quot;place.h&quot;</a>
<a name="ln61">#include &quot;player-equip.h&quot;</a>
<a name="ln62">#include &quot;player.h&quot;</a>
<a name="ln63">#include &quot;prompt.h&quot;</a>
<a name="ln64">#include &quot;quiver.h&quot;</a>
<a name="ln65">#include &quot;randbook.h&quot;</a>
<a name="ln66">#include &quot;religion.h&quot;</a>
<a name="ln67">#include &quot;rot.h&quot;</a>
<a name="ln68">#include &quot;shopping.h&quot;</a>
<a name="ln69">#include &quot;showsymb.h&quot;</a>
<a name="ln70">#include &quot;slot-select-mode.h&quot;</a>
<a name="ln71">#include &quot;sound.h&quot;</a>
<a name="ln72">#include &quot;spl-book.h&quot;</a>
<a name="ln73">#include &quot;spl-util.h&quot;</a>
<a name="ln74">#include &quot;stash.h&quot;</a>
<a name="ln75">#include &quot;state.h&quot;</a>
<a name="ln76">#include &quot;state.h&quot;</a>
<a name="ln77">#include &quot;stringutil.h&quot;</a>
<a name="ln78">#include &quot;terrain.h&quot;</a>
<a name="ln79">#include &quot;throw.h&quot;</a>
<a name="ln80">#include &quot;tilepick.h&quot;</a>
<a name="ln81">#include &quot;travel.h&quot;</a>
<a name="ln82">#include &quot;viewchar.h&quot;</a>
<a name="ln83">#include &quot;view.h&quot;</a>
<a name="ln84">#include &quot;xom.h&quot;</a>
<a name="ln85"> </a>
<a name="ln86">/**</a>
<a name="ln87"> * Return an item's location (floor or inventory) and the corresponding mitm</a>
<a name="ln88"> * int or inv slot referring to it.</a>
<a name="ln89"> *</a>
<a name="ln90"> * @param item_def An item in either mitm (the floor or monster inventory)</a>
<a name="ln91"> *                 or you.inv.</a>
<a name="ln92"> *</a>
<a name="ln93"> * @return A pair containing bool and int. The bool is true for items in</a>
<a name="ln94"> *         inventory, false for others. The int is the item's index in either</a>
<a name="ln95"> *         you.inv or mitm.</a>
<a name="ln96"> */</a>
<a name="ln97"> </a>
<a name="ln98">pair&lt;bool, int&gt; item_int(item_def &amp;item)</a>
<a name="ln99">{</a>
<a name="ln100">    if (in_inventory(item))</a>
<a name="ln101">        return make_pair(true, item.link);</a>
<a name="ln102">    return make_pair(false, item.index());</a>
<a name="ln103">}</a>
<a name="ln104"> </a>
<a name="ln105"> </a>
<a name="ln106">/**</a>
<a name="ln107"> * Return an item_def&amp; requested by an item's inv slot or mitm index.</a>
<a name="ln108"> *</a>
<a name="ln109"> * @param inv Is the item in inventory?</a>
<a name="ln110"> * @param number The index of the item, either in you.inv (if inv == true)</a>
<a name="ln111"> *               or in mitm (if inv == false).</a>
<a name="ln112"> *</a>
<a name="ln113"> * @return The item.</a>
<a name="ln114"> */</a>
<a name="ln115"> </a>
<a name="ln116">item_def&amp; item_from_int(bool inv, int number)</a>
<a name="ln117">{</a>
<a name="ln118">    return inv ? you.inv[number] : mitm[number];</a>
<a name="ln119">}</a>
<a name="ln120"> </a>
<a name="ln121">static int _autopickup_subtype(const item_def &amp;item);</a>
<a name="ln122">static void _autoinscribe_item(item_def&amp; item);</a>
<a name="ln123">static void _autoinscribe_floor_items();</a>
<a name="ln124">static void _autoinscribe_inventory();</a>
<a name="ln125">static void _multidrop(vector&lt;SelItem&gt; tmp_items);</a>
<a name="ln126">static bool _merge_items_into_inv(item_def &amp;it, int quant_got,</a>
<a name="ln127">                                  int &amp;inv_slot, bool quiet);</a>
<a name="ln128"> </a>
<a name="ln129">static bool will_autopickup   = false;</a>
<a name="ln130">static bool will_autoinscribe = false;</a>
<a name="ln131"> </a>
<a name="ln132">static inline string _autopickup_item_name(const item_def &amp;item)</a>
<a name="ln133">{</a>
<a name="ln134">    return userdef_annotate_item(STASH_LUA_SEARCH_ANNOTATE, &amp;item)</a>
<a name="ln135">           + item_prefix(item, false) + &quot; &quot; + item.name(DESC_PLAIN);</a>
<a name="ln136">}</a>
<a name="ln137"> </a>
<a name="ln138">// Used to be called &quot;unlink_items&quot;, but all it really does is make</a>
<a name="ln139">// sure item coordinates are correct to the stack they're in. -- bwr</a>
<a name="ln140">void fix_item_coordinates()</a>
<a name="ln141">{</a>
<a name="ln142">    // Nails all items to the ground (i.e. sets x,y).</a>
<a name="ln143">    for (int x = 0; x &lt; GXM; x++)</a>
<a name="ln144">        for (int y = 0; y &lt; GYM; y++)</a>
<a name="ln145">        {</a>
<a name="ln146">            int i = igrd[x][y];</a>
<a name="ln147"> </a>
<a name="ln148">            while (i != NON_ITEM)</a>
<a name="ln149">            {</a>
<a name="ln150">                mitm[i].pos.x = x;</a>
<a name="ln151">                mitm[i].pos.y = y;</a>
<a name="ln152">                i = mitm[i].link;</a>
<a name="ln153">            }</a>
<a name="ln154">        }</a>
<a name="ln155">}</a>
<a name="ln156"> </a>
<a name="ln157">// This function uses the items coordinates to relink all the igrd lists.</a>
<a name="ln158">void link_items()</a>
<a name="ln159">{</a>
<a name="ln160">    // First, initialise igrd array.</a>
<a name="ln161">    igrd.init(NON_ITEM);</a>
<a name="ln162"> </a>
<a name="ln163">    // Link all items on the grid, plus shop inventory,</a>
<a name="ln164">    // but DON'T link the huge pile of monster items at (-2,-2).</a>
<a name="ln165"> </a>
<a name="ln166">    for (int i = 0; i &lt; MAX_ITEMS; i++)</a>
<a name="ln167">    {</a>
<a name="ln168">        // Don't mess with monster held items, since the index of the holding</a>
<a name="ln169">        // monster is stored in the link field.</a>
<a name="ln170">        if (mitm[i].held_by_monster())</a>
<a name="ln171">            continue;</a>
<a name="ln172"> </a>
<a name="ln173">        if (!mitm[i].defined())</a>
<a name="ln174">        {</a>
<a name="ln175">            // Item is not assigned. Ignore.</a>
<a name="ln176">            mitm[i].link = NON_ITEM;</a>
<a name="ln177">            continue;</a>
<a name="ln178">        }</a>
<a name="ln179"> </a>
<a name="ln180">        bool move_below = item_is_stationary(mitm[i])</a>
<a name="ln181">            &amp;&amp; !item_is_stationary_net(mitm[i]);</a>
<a name="ln182">        int movable_ind = -1;</a>
<a name="ln183">        // Stationary item, find index at location</a>
<a name="ln184">        if (move_below)</a>
<a name="ln185">        {</a>
<a name="ln186"> </a>
<a name="ln187">            for (stack_iterator si(mitm[i].pos); si; ++si)</a>
<a name="ln188">            {</a>
<a name="ln189">                if (!item_is_stationary(*si) || item_is_stationary_net(*si))</a>
<a name="ln190">                    movable_ind = si-&gt;index();</a>
<a name="ln191">            }</a>
<a name="ln192">        }</a>
<a name="ln193">        // Link to top</a>
<a name="ln194">        if (!move_below || movable_ind == -1)</a>
<a name="ln195">        {</a>
<a name="ln196">            mitm[i].link = igrd(mitm[i].pos);</a>
<a name="ln197">            igrd(mitm[i].pos) = i;</a>
<a name="ln198">        }</a>
<a name="ln199">        // Link below movable items.</a>
<a name="ln200">        else</a>
<a name="ln201">        {</a>
<a name="ln202">            mitm[i].link = mitm[movable_ind].link;</a>
<a name="ln203">            mitm[movable_ind].link = i;</a>
<a name="ln204">        }</a>
<a name="ln205">    }</a>
<a name="ln206">}</a>
<a name="ln207"> </a>
<a name="ln208">static bool _item_ok_to_clean(int item)</a>
<a name="ln209">{</a>
<a name="ln210">    // Never clean food, zigfigs, Orbs, or runes.</a>
<a name="ln211">    if (mitm[item].base_type == OBJ_FOOD</a>
<a name="ln212">        || mitm[item].base_type == OBJ_MISCELLANY</a>
<a name="ln213">            &amp;&amp; mitm[item].sub_type == MISC_ZIGGURAT</a>
<a name="ln214">        || item_is_orb(mitm[item])</a>
<a name="ln215">        || mitm[item].base_type == OBJ_RUNES)</a>
<a name="ln216">    {</a>
<a name="ln217">        return false;</a>
<a name="ln218">    }</a>
<a name="ln219"> </a>
<a name="ln220">    return true;</a>
<a name="ln221">}</a>
<a name="ln222"> </a>
<a name="ln223">static bool _item_preferred_to_clean(int item)</a>
<a name="ln224">{</a>
<a name="ln225">    // Preferably clean &quot;normal&quot; weapons and ammo</a>
<a name="ln226">    if (mitm[item].base_type == OBJ_WEAPONS</a>
<a name="ln227">        &amp;&amp; mitm[item].plus &lt;= 0</a>
<a name="ln228">        &amp;&amp; !is_artefact(mitm[item]))</a>
<a name="ln229">    {</a>
<a name="ln230">        return true;</a>
<a name="ln231">    }</a>
<a name="ln232"> </a>
<a name="ln233">    if (mitm[item].base_type == OBJ_MISSILES</a>
<a name="ln234">        &amp;&amp; mitm[item].plus &lt;= 0 &amp;&amp; !mitm[item].net_placed // XXX: plus...?</a>
<a name="ln235">        &amp;&amp; !is_artefact(mitm[item]))</a>
<a name="ln236">    {</a>
<a name="ln237">        return true;</a>
<a name="ln238">    }</a>
<a name="ln239"> </a>
<a name="ln240">    return false;</a>
<a name="ln241">}</a>
<a name="ln242"> </a>
<a name="ln243">// Returns index number of first available space, or NON_ITEM for</a>
<a name="ln244">// unsuccessful cleanup (should be exceedingly rare!)</a>
<a name="ln245">static int _cull_items()</a>
<a name="ln246">{</a>
<a name="ln247">    crawl_state.cancel_cmd_repeat();</a>
<a name="ln248"> </a>
<a name="ln249">    // XXX: Not the prettiest of messages, but the player</a>
<a name="ln250">    // deserves to know whenever this kicks in. -- bwr</a>
<a name="ln251">    mprf(MSGCH_WARN, &quot;Too many items on level, removing some.&quot;);</a>
<a name="ln252"> </a>
<a name="ln253">    // Rules:</a>
<a name="ln254">    //  1. Don't cleanup anything nearby the player</a>
<a name="ln255">    //  2. Don't cleanup shops</a>
<a name="ln256">    //  3. Don't cleanup monster inventory</a>
<a name="ln257">    //  4. Clean 15% of items</a>
<a name="ln258">    //  5. never remove food, orbs, runes</a>
<a name="ln259">    //  7. uniques weapons are moved to the abyss</a>
<a name="ln260">    //  8. randarts are simply lost</a>
<a name="ln261">    //  9. unrandarts are 'destroyed', but may be generated again</a>
<a name="ln262">    // 10. Remove +0 weapons and ammo first, only removing others if this fails.</a>
<a name="ln263"> </a>
<a name="ln264">    int first_cleaned = NON_ITEM;</a>
<a name="ln265"> </a>
<a name="ln266">    // 2. Avoid shops by avoiding (0,5..9).</a>
<a name="ln267">    // 3. Avoid monster inventory by iterating over the dungeon grid.</a>
<a name="ln268"> </a>
<a name="ln269">    // 10. Remove +0 weapons and ammo first, only removing others if this fails.</a>
<a name="ln270">    // Loop twice. First iteration, get rid of uninteresting stuff. Second</a>
<a name="ln271">    // iteration, get rid of anything non-essential</a>
<a name="ln272">    for (int remove_all=0; remove_all&lt;2 &amp;&amp; first_cleaned==NON_ITEM; remove_all++)</a>
<a name="ln273">    {</a>
<a name="ln274">        for (rectangle_iterator ri(1); ri; ++ri)</a>
<a name="ln275">        {</a>
<a name="ln276">            if (grid_distance(you.pos(), *ri) &lt;= 8)</a>
<a name="ln277">                continue;</a>
<a name="ln278"> </a>
<a name="ln279">            for (stack_iterator si(*ri); si; ++si)</a>
<a name="ln280">            {</a>
<a name="ln281">                if (_item_ok_to_clean(si-&gt;index())</a>
<a name="ln282">                    &amp;&amp; (remove_all || _item_preferred_to_clean(si-&gt;index()))</a>
<a name="ln283">                    &amp;&amp; x_chance_in_y(15, 100))</a>
<a name="ln284">                {</a>
<a name="ln285">                    if (is_unrandom_artefact(*si))</a>
<a name="ln286">                    {</a>
<a name="ln287">                        // 7. Move uniques to abyss.</a>
<a name="ln288">                        set_unique_item_status(*si, UNIQ_LOST_IN_ABYSS);</a>
<a name="ln289">                    }</a>
<a name="ln290"> </a>
<a name="ln291">                    if (first_cleaned == NON_ITEM)</a>
<a name="ln292">                        first_cleaned = si-&gt;index();</a>
<a name="ln293"> </a>
<a name="ln294">                    // POOF!</a>
<a name="ln295">                    destroy_item(si-&gt;index());</a>
<a name="ln296">                }</a>
<a name="ln297">            }</a>
<a name="ln298">        }</a>
<a name="ln299">    }</a>
<a name="ln300"> </a>
<a name="ln301">    return first_cleaned;</a>
<a name="ln302">}</a>
<a name="ln303"> </a>
<a name="ln304">/*---------------------------------------------------------------------*/</a>
<a name="ln305">stack_iterator::stack_iterator(const coord_def&amp; pos, bool accessible)</a>
<a name="ln306">{</a>
<a name="ln307">    cur_link = accessible ? you.visible_igrd(pos) : igrd(pos);</a>
<a name="ln308">    if (cur_link != NON_ITEM)</a>
<a name="ln309">        next_link = mitm[cur_link].link;</a>
<a name="ln310">    else</a>
<a name="ln311">        next_link = NON_ITEM;</a>
<a name="ln312">}</a>
<a name="ln313"> </a>
<a name="ln314">stack_iterator::stack_iterator(int start_link)</a>
<a name="ln315">{</a>
<a name="ln316">    cur_link = start_link;</a>
<a name="ln317">    if (cur_link != NON_ITEM)</a>
<a name="ln318">        next_link = mitm[cur_link].link;</a>
<a name="ln319">    else</a>
<a name="ln320">        next_link = NON_ITEM;</a>
<a name="ln321">}</a>
<a name="ln322"> </a>
<a name="ln323">stack_iterator::operator bool() const</a>
<a name="ln324">{</a>
<a name="ln325">    return cur_link != NON_ITEM;</a>
<a name="ln326">}</a>
<a name="ln327"> </a>
<a name="ln328">item_def&amp; stack_iterator::operator*() const</a>
<a name="ln329">{</a>
<a name="ln330">    ASSERT(cur_link != NON_ITEM);</a>
<a name="ln331">    return mitm[cur_link];</a>
<a name="ln332">}</a>
<a name="ln333"> </a>
<a name="ln334">item_def* stack_iterator::operator-&gt;() const</a>
<a name="ln335">{</a>
<a name="ln336">    ASSERT(cur_link != NON_ITEM);</a>
<a name="ln337">    return &amp;mitm[cur_link];</a>
<a name="ln338">}</a>
<a name="ln339"> </a>
<a name="ln340">int stack_iterator::index() const</a>
<a name="ln341">{</a>
<a name="ln342">    return cur_link;</a>
<a name="ln343">}</a>
<a name="ln344"> </a>
<a name="ln345">const stack_iterator&amp; stack_iterator::operator ++ ()</a>
<a name="ln346">{</a>
<a name="ln347">    cur_link = next_link;</a>
<a name="ln348">    if (cur_link != NON_ITEM)</a>
<a name="ln349">        next_link = mitm[cur_link].link;</a>
<a name="ln350">    return *this;</a>
<a name="ln351">}</a>
<a name="ln352"> </a>
<a name="ln353">stack_iterator stack_iterator::operator++(int)</a>
<a name="ln354">{</a>
<a name="ln355">    const stack_iterator copy = *this;</a>
<a name="ln356">    ++(*this);</a>
<a name="ln357">    return copy;</a>
<a name="ln358">}</a>
<a name="ln359"> </a>
<a name="ln360">mon_inv_iterator::mon_inv_iterator(monster&amp; _mon)</a>
<a name="ln361">    : mon(_mon)</a>
<a name="ln362">{</a>
<a name="ln363">    type = static_cast&lt;mon_inv_type&gt;(0);</a>
<a name="ln364">    if (mon.inv[type] == NON_ITEM)</a>
<a name="ln365">        ++*this;</a>
<a name="ln366">}</a>
<a name="ln367"> </a>
<a name="ln368">mon_inv_iterator::operator bool() const</a>
<a name="ln369">{</a>
<a name="ln370">    return type &lt; NUM_MONSTER_SLOTS;</a>
<a name="ln371">}</a>
<a name="ln372"> </a>
<a name="ln373">item_def&amp; mon_inv_iterator::operator*() const</a>
<a name="ln374">{</a>
<a name="ln375">    ASSERT(mon.inv[type] != NON_ITEM);</a>
<a name="ln376">    return mitm[mon.inv[type]];</a>
<a name="ln377">}</a>
<a name="ln378"> </a>
<a name="ln379">item_def* mon_inv_iterator::operator-&gt;() const</a>
<a name="ln380">{</a>
<a name="ln381">    ASSERT(mon.inv[type] != NON_ITEM);</a>
<a name="ln382">    return &amp;mitm[mon.inv[type]];</a>
<a name="ln383">}</a>
<a name="ln384"> </a>
<a name="ln385">mon_inv_iterator&amp; mon_inv_iterator::operator ++ ()</a>
<a name="ln386">{</a>
<a name="ln387">    do</a>
<a name="ln388">    {</a>
<a name="ln389">        type = static_cast&lt;mon_inv_type&gt;(type + 1);</a>
<a name="ln390">    }</a>
<a name="ln391">    while (*this &amp;&amp; mon.inv[type] == NON_ITEM);</a>
<a name="ln392"> </a>
<a name="ln393">    return *this;</a>
<a name="ln394">}</a>
<a name="ln395"> </a>
<a name="ln396">mon_inv_iterator mon_inv_iterator::operator++(int)</a>
<a name="ln397">{</a>
<a name="ln398">    const mon_inv_iterator copy = *this;</a>
<a name="ln399">    ++(*this);</a>
<a name="ln400">    return copy;</a>
<a name="ln401">}</a>
<a name="ln402"> </a>
<a name="ln403">/**</a>
<a name="ln404"> * Reduce quantity of an inventory item, do cleanup if item goes away.</a>
<a name="ln405"> * @return  True if stack of items no longer exists, false otherwise.</a>
<a name="ln406">*/</a>
<a name="ln407">bool dec_inv_item_quantity(int obj, int amount)</a>
<a name="ln408">{</a>
<a name="ln409">    bool ret = false;</a>
<a name="ln410"> </a>
<a name="ln411">    if (you.equip[EQ_WEAPON] == obj)</a>
<a name="ln412">        you.wield_change = true;</a>
<a name="ln413"> </a>
<a name="ln414">    you.m_quiver.on_inv_quantity_changed(obj, amount);</a>
<a name="ln415"> </a>
<a name="ln416">    if (you.inv[obj].quantity &lt;= amount)</a>
<a name="ln417">    {</a>
<a name="ln418">        for (int i = EQ_FIRST_EQUIP; i &lt; NUM_EQUIP; i++)</a>
<a name="ln419">        {</a>
<a name="ln420">            if (you.equip[i] == obj)</a>
<a name="ln421">            {</a>
<a name="ln422">                if (i == EQ_WEAPON)</a>
<a name="ln423">                {</a>
<a name="ln424">                    unwield_item();</a>
<a name="ln425">                    canned_msg(MSG_EMPTY_HANDED_NOW);</a>
<a name="ln426">                }</a>
<a name="ln427">                you.equip[i] = -1;</a>
<a name="ln428">            }</a>
<a name="ln429">        }</a>
<a name="ln430"> </a>
<a name="ln431">        item_skills(you.inv[obj], you.stop_train);</a>
<a name="ln432"> </a>
<a name="ln433">        you.inv[obj].base_type = OBJ_UNASSIGNED;</a>
<a name="ln434">        you.inv[obj].quantity  = 0;</a>
<a name="ln435">        you.inv[obj].props.clear();</a>
<a name="ln436"> </a>
<a name="ln437">        ret = true;</a>
<a name="ln438"> </a>
<a name="ln439">        // If we're repeating a command, the repetitions used up the</a>
<a name="ln440">        // item stack being repeated on, so stop rather than move onto</a>
<a name="ln441">        // the next stack.</a>
<a name="ln442">        crawl_state.cancel_cmd_repeat();</a>
<a name="ln443">        crawl_state.cancel_cmd_again();</a>
<a name="ln444">    }</a>
<a name="ln445">    else</a>
<a name="ln446">        you.inv[obj].quantity -= amount;</a>
<a name="ln447"> </a>
<a name="ln448">    return ret;</a>
<a name="ln449">}</a>
<a name="ln450"> </a>
<a name="ln451">// Reduce quantity of a monster/grid item, do cleanup if item goes away.</a>
<a name="ln452">//</a>
<a name="ln453">// Returns true if stack of items no longer exists.</a>
<a name="ln454">bool dec_mitm_item_quantity(int obj, int amount)</a>
<a name="ln455">{</a>
<a name="ln456">    item_def &amp;item = mitm[obj];</a>
<a name="ln457">    if (amount &gt; item.quantity)</a>
<a name="ln458">        amount = item.quantity; // can't use min due to type mismatch</a>
<a name="ln459"> </a>
<a name="ln460">    if (item.quantity == amount)</a>
<a name="ln461">    {</a>
<a name="ln462">        destroy_item(obj);</a>
<a name="ln463">        // If we're repeating a command, the repetitions used up the</a>
<a name="ln464">        // item stack being repeated on, so stop rather than move onto</a>
<a name="ln465">        // the next stack.</a>
<a name="ln466">        crawl_state.cancel_cmd_repeat();</a>
<a name="ln467">        crawl_state.cancel_cmd_again();</a>
<a name="ln468">        return true;</a>
<a name="ln469">    }</a>
<a name="ln470"> </a>
<a name="ln471">    item.quantity -= amount;</a>
<a name="ln472">    return false;</a>
<a name="ln473">}</a>
<a name="ln474"> </a>
<a name="ln475">void inc_inv_item_quantity(int obj, int amount)</a>
<a name="ln476">{</a>
<a name="ln477">    if (you.equip[EQ_WEAPON] == obj)</a>
<a name="ln478">        you.wield_change = true;</a>
<a name="ln479"> </a>
<a name="ln480">    you.m_quiver.on_inv_quantity_changed(obj, amount);</a>
<a name="ln481">    you.inv[obj].quantity += amount;</a>
<a name="ln482">}</a>
<a name="ln483"> </a>
<a name="ln484">void inc_mitm_item_quantity(int obj, int amount)</a>
<a name="ln485">{</a>
<a name="ln486">    mitm[obj].quantity += amount;</a>
<a name="ln487">}</a>
<a name="ln488"> </a>
<a name="ln489">void init_item(int item)</a>
<a name="ln490">{</a>
<a name="ln491">    if (item == NON_ITEM)</a>
<a name="ln492">        return;</a>
<a name="ln493"> </a>
<a name="ln494">    mitm[item].clear();</a>
<a name="ln495">}</a>
<a name="ln496"> </a>
<a name="ln497">// Returns an unused mitm slot, or NON_ITEM if none available.</a>
<a name="ln498">// The reserve is the number of item slots to not check.</a>
<a name="ln499">// Items may be culled if a reserve &lt;= 10 is specified.</a>
<a name="ln500">int get_mitm_slot(int reserve)</a>
<a name="ln501">{</a>
<a name="ln502">    ASSERT(reserve &gt;= 0);</a>
<a name="ln503"> </a>
<a name="ln504">    if (crawl_state.game_is_arena())</a>
<a name="ln505">        reserve = 0;</a>
<a name="ln506"> </a>
<a name="ln507">    int item = NON_ITEM;</a>
<a name="ln508"> </a>
<a name="ln509">    for (item = 0; item &lt; (MAX_ITEMS - reserve); item++)</a>
<a name="ln510">        if (!mitm[item].defined())</a>
<a name="ln511">            break;</a>
<a name="ln512"> </a>
<a name="ln513">    if (item &gt;= MAX_ITEMS - reserve)</a>
<a name="ln514">    {</a>
<a name="ln515">        if (crawl_state.game_is_arena())</a>
<a name="ln516">        {</a>
<a name="ln517">            item = arena_cull_items();</a>
<a name="ln518">            // If arena_cull_items() can't free up any space then</a>
<a name="ln519">            // _cull_items() won't be able to either, so give up.</a>
<a name="ln520">            if (item == NON_ITEM)</a>
<a name="ln521">                return NON_ITEM;</a>
<a name="ln522">        }</a>
<a name="ln523">        else</a>
<a name="ln524">            item = (reserve &lt;= 10) ? _cull_items() : NON_ITEM;</a>
<a name="ln525"> </a>
<a name="ln526">        if (item == NON_ITEM)</a>
<a name="ln527">            return NON_ITEM;</a>
<a name="ln528">    }</a>
<a name="ln529"> </a>
<a name="ln530">    ASSERT(item != NON_ITEM);</a>
<a name="ln531"> </a>
<a name="ln532">    init_item(item);</a>
<a name="ln533"> </a>
<a name="ln534">    return item;</a>
<a name="ln535">}</a>
<a name="ln536"> </a>
<a name="ln537">void unlink_item(int dest)</a>
<a name="ln538">{</a>
<a name="ln539">    // Don't destroy non-items, may be called after an item has been</a>
<a name="ln540">    // reduced to zero quantity however.</a>
<a name="ln541">    if (dest == NON_ITEM || !mitm[dest].defined())</a>
<a name="ln542">        return;</a>
<a name="ln543"> </a>
<a name="ln544">    monster* mons = mitm[dest].holding_monster();</a>
<a name="ln545"> </a>
<a name="ln546">    if (mons != nullptr)</a>
<a name="ln547">    {</a>
<a name="ln548">        for (mon_inv_iterator ii(*mons); ii; ++ii)</a>
<a name="ln549">        {</a>
<a name="ln550">            if (ii-&gt;index() == dest)</a>
<a name="ln551">            {</a>
<a name="ln552">                item_def&amp; item = *ii;</a>
<a name="ln553">                mons-&gt;inv[ii.slot()] = NON_ITEM;</a>
<a name="ln554"> </a>
<a name="ln555">                item.pos.reset();</a>
<a name="ln556">                item.link = NON_ITEM;</a>
<a name="ln557">                return;</a>
<a name="ln558">            }</a>
<a name="ln559">        }</a>
<a name="ln560">        mprf(MSGCH_ERROR, &quot;Item %s claims to be held by monster %s, but &quot;</a>
<a name="ln561">                          &quot;it isn't in the monster's inventory.&quot;,</a>
<a name="ln562">             mitm[dest].name(DESC_PLAIN, false, true).c_str(),</a>
<a name="ln563">             mons-&gt;name(DESC_PLAIN, true).c_str());</a>
<a name="ln564">        // Don't return so the debugging code can take a look at it.</a>
<a name="ln565">    }</a>
<a name="ln566">    // Unlinking a newly created item, or a a temporary one, or an item in</a>
<a name="ln567">    // the player's inventory.</a>
<a name="ln568">    else if (mitm[dest].pos.origin() || mitm[dest].pos == ITEM_IN_INVENTORY)</a>
<a name="ln569">    {</a>
<a name="ln570">        mitm[dest].pos.reset();</a>
<a name="ln571">        mitm[dest].link = NON_ITEM;</a>
<a name="ln572">        return;</a>
<a name="ln573">    }</a>
<a name="ln574">    else</a>
<a name="ln575">    {</a>
<a name="ln576">        // Linked item on map:</a>
<a name="ln577">        //</a>
<a name="ln578">        // Use the items (x,y) to access the list (igrd[x][y]) where</a>
<a name="ln579">        // the item should be linked.</a>
<a name="ln580"> </a>
<a name="ln581">#if TAG_MAJOR_VERSION == 34</a>
<a name="ln582">        if (mitm[dest].pos.x != 0 || mitm[dest].pos.y &lt; 5)</a>
<a name="ln583">#endif</a>
<a name="ln584">        ASSERT_IN_BOUNDS(mitm[dest].pos);</a>
<a name="ln585"> </a>
<a name="ln586">        // First check the top:</a>
<a name="ln587">        if (igrd(mitm[dest].pos) == dest)</a>
<a name="ln588">        {</a>
<a name="ln589">            // link igrd to the second item</a>
<a name="ln590">            igrd(mitm[dest].pos) = mitm[dest].link;</a>
<a name="ln591"> </a>
<a name="ln592">            mitm[dest].pos.reset();</a>
<a name="ln593">            mitm[dest].link = NON_ITEM;</a>
<a name="ln594">            return;</a>
<a name="ln595">        }</a>
<a name="ln596"> </a>
<a name="ln597">        // Okay, item is buried, find item that's on top of it.</a>
<a name="ln598">        for (stack_iterator si(mitm[dest].pos); si; ++si)</a>
<a name="ln599">        {</a>
<a name="ln600">            // Find item linking to dest item.</a>
<a name="ln601">            if (si-&gt;defined() &amp;&amp; si-&gt;link == dest)</a>
<a name="ln602">            {</a>
<a name="ln603">                // unlink dest</a>
<a name="ln604">                si-&gt;link = mitm[dest].link;</a>
<a name="ln605">                mitm[dest].pos.reset();</a>
<a name="ln606">                mitm[dest].link = NON_ITEM;</a>
<a name="ln607">                return;</a>
<a name="ln608">            }</a>
<a name="ln609">        }</a>
<a name="ln610">    }</a>
<a name="ln611"> </a>
<a name="ln612">#ifdef DEBUG</a>
<a name="ln613">    // Okay, the sane ways are gone... let's warn the player:</a>
<a name="ln614">    mprf(MSGCH_ERROR, &quot;BUG WARNING: Problems unlinking item '%s', (%d, %d)!!!&quot;,</a>
<a name="ln615">         mitm[dest].name(DESC_PLAIN).c_str(),</a>
<a name="ln616">         mitm[dest].pos.x, mitm[dest].pos.y);</a>
<a name="ln617"> </a>
<a name="ln618">    // Okay, first we scan all items to see if we have something</a>
<a name="ln619">    // linked to this item. We're not going to return if we find</a>
<a name="ln620">    // such a case... instead, since things are already out of</a>
<a name="ln621">    // alignment, let's assume there might be multiple links as well.</a>
<a name="ln622">    bool linked = false;</a>
<a name="ln623">    int  old_link = mitm[dest].link; // used to try linking the first</a>
<a name="ln624"> </a>
<a name="ln625">    // Clean the relevant parts of the object.</a>
<a name="ln626">    mitm[dest].base_type = OBJ_UNASSIGNED;</a>
<a name="ln627">    mitm[dest].quantity  = 0;</a>
<a name="ln628">    mitm[dest].link      = NON_ITEM;</a>
<a name="ln629">    mitm[dest].pos.reset();</a>
<a name="ln630">    mitm[dest].props.clear();</a>
<a name="ln631"> </a>
<a name="ln632">    // Look through all items for links to this item.</a>
<a name="ln633">    for (auto &amp;item : mitm)</a>
<a name="ln634">    {</a>
<a name="ln635">        if (item.defined() &amp;&amp; item.link == dest)</a>
<a name="ln636">        {</a>
<a name="ln637">            // unlink item</a>
<a name="ln638">            item.link = old_link;</a>
<a name="ln639"> </a>
<a name="ln640">            if (!linked)</a>
<a name="ln641">            {</a>
<a name="ln642">                old_link = NON_ITEM;</a>
<a name="ln643">                linked = true;</a>
<a name="ln644">            }</a>
<a name="ln645">        }</a>
<a name="ln646">    }</a>
<a name="ln647"> </a>
<a name="ln648">    // Now check the grids to see if it's linked as a list top.</a>
<a name="ln649">    for (int c = 2; c &lt; (GXM - 1); c++)</a>
<a name="ln650">        for (int cy = 2; cy &lt; (GYM - 1); cy++)</a>
<a name="ln651">        {</a>
<a name="ln652">            if (igrd[c][cy] == dest)</a>
<a name="ln653">            {</a>
<a name="ln654">                igrd[c][cy] = old_link;</a>
<a name="ln655"> </a>
<a name="ln656">                if (!linked)</a>
<a name="ln657">                {</a>
<a name="ln658">                    old_link = NON_ITEM;  // cleaned after the first</a>
<a name="ln659">                    linked = true;</a>
<a name="ln660">                }</a>
<a name="ln661">            }</a>
<a name="ln662">        }</a>
<a name="ln663"> </a>
<a name="ln664">    // Okay, finally warn player if we didn't do anything.</a>
<a name="ln665">    if (!linked)</a>
<a name="ln666">        mprf(MSGCH_ERROR, &quot;BUG WARNING: Item didn't seem to be linked at all.&quot;);</a>
<a name="ln667">#endif</a>
<a name="ln668">}</a>
<a name="ln669"> </a>
<a name="ln670">void destroy_item(item_def &amp;item, bool never_created)</a>
<a name="ln671">{</a>
<a name="ln672">    if (!item.defined())</a>
<a name="ln673">        return;</a>
<a name="ln674"> </a>
<a name="ln675">    if (never_created)</a>
<a name="ln676">    {</a>
<a name="ln677">        if (is_unrandom_artefact(item))</a>
<a name="ln678">            set_unique_item_status(item, UNIQ_NOT_EXISTS);</a>
<a name="ln679">    }</a>
<a name="ln680"> </a>
<a name="ln681">    item.clear();</a>
<a name="ln682">}</a>
<a name="ln683"> </a>
<a name="ln684">void destroy_item(int dest, bool never_created)</a>
<a name="ln685">{</a>
<a name="ln686">    // Don't destroy non-items, but this function may be called upon</a>
<a name="ln687">    // to remove items reduced to zero quantity, so we allow &quot;invalid&quot;</a>
<a name="ln688">    // objects in.</a>
<a name="ln689">    if (dest == NON_ITEM || !mitm[dest].defined())</a>
<a name="ln690">        return;</a>
<a name="ln691"> </a>
<a name="ln692">    unlink_item(dest);</a>
<a name="ln693">    destroy_item(mitm[dest], never_created);</a>
<a name="ln694">}</a>
<a name="ln695"> </a>
<a name="ln696">static void _handle_gone_item(const item_def &amp;item)</a>
<a name="ln697">{</a>
<a name="ln698">    if (player_in_branch(BRANCH_ABYSS)</a>
<a name="ln699">        &amp;&amp; item.orig_place.branch == BRANCH_ABYSS)</a>
<a name="ln700">    {</a>
<a name="ln701">        if (is_unrandom_artefact(item))</a>
<a name="ln702">            set_unique_item_status(item, UNIQ_LOST_IN_ABYSS);</a>
<a name="ln703">    }</a>
<a name="ln704">}</a>
<a name="ln705"> </a>
<a name="ln706">void item_was_lost(const item_def &amp;item)</a>
<a name="ln707">{</a>
<a name="ln708">    _handle_gone_item(item);</a>
<a name="ln709">    xom_check_lost_item(item);</a>
<a name="ln710">}</a>
<a name="ln711"> </a>
<a name="ln712">void item_was_destroyed(const item_def &amp;item)</a>
<a name="ln713">{</a>
<a name="ln714">    _handle_gone_item(item);</a>
<a name="ln715">    xom_check_destroyed_item(item);</a>
<a name="ln716">}</a>
<a name="ln717"> </a>
<a name="ln718">void lose_item_stack(const coord_def&amp; where)</a>
<a name="ln719">{</a>
<a name="ln720">    for (stack_iterator si(where); si; ++si)</a>
<a name="ln721">    {</a>
<a name="ln722">        if (si -&gt;defined()) // FIXME is this check necessary?</a>
<a name="ln723">        {</a>
<a name="ln724">            item_was_lost(*si);</a>
<a name="ln725">            si-&gt;clear();</a>
<a name="ln726">        }</a>
<a name="ln727">    }</a>
<a name="ln728">    igrd(where) = NON_ITEM;</a>
<a name="ln729">}</a>
<a name="ln730"> </a>
<a name="ln731">/**</a>
<a name="ln732"> * How many movable items are there at a location?</a>
<a name="ln733"> *</a>
<a name="ln734"> * @param obj The item link for the location.</a>
<a name="ln735"> * @return  The number of movable items at the location.</a>
<a name="ln736">*/</a>
<a name="ln737">int count_movable_items(int obj)</a>
<a name="ln738">{</a>
<a name="ln739">    int result = 0;</a>
<a name="ln740"> </a>
<a name="ln741">    for (stack_iterator si(obj); si; ++si)</a>
<a name="ln742">    {</a>
<a name="ln743">        if (!item_is_stationary(*si))</a>
<a name="ln744">            ++result;</a>
<a name="ln745">    }</a>
<a name="ln746">    return result;</a>
<a name="ln747">}</a>
<a name="ln748"> </a>
<a name="ln749">/**</a>
<a name="ln750"> * Fill the given vector with the items on the given location link.</a>
<a name="ln751"> *</a>
<a name="ln752"> * @param[out] items A vector to hold the item_defs of the item.</a>
<a name="ln753"> * @param[in] obj The location link; an index in mitm.</a>
<a name="ln754"> * @param exclude_stationary If true, don't include stationary items.</a>
<a name="ln755">*/</a>
<a name="ln756">vector&lt;const item_def*&gt; item_list_on_square(int obj)</a>
<a name="ln757">{</a>
<a name="ln758">    vector&lt;const item_def*&gt; items;</a>
<a name="ln759">    for (stack_iterator si(obj); si; ++si)</a>
<a name="ln760">        items.push_back(&amp; (*si));</a>
<a name="ln761">    return items;</a>
<a name="ln762">}</a>
<a name="ln763"> </a>
<a name="ln764">bool need_to_autopickup()</a>
<a name="ln765">{</a>
<a name="ln766">    return will_autopickup;</a>
<a name="ln767">}</a>
<a name="ln768"> </a>
<a name="ln769">void request_autopickup(bool do_pickup)</a>
<a name="ln770">{</a>
<a name="ln771">    will_autopickup = do_pickup;</a>
<a name="ln772">}</a>
<a name="ln773"> </a>
<a name="ln774">bool item_is_branded(const item_def&amp; item)</a>
<a name="ln775">{</a>
<a name="ln776">    switch (item.base_type)</a>
<a name="ln777">    {</a>
<a name="ln778">    case OBJ_WEAPONS:</a>
<a name="ln779">        return get_weapon_brand(item) != SPWPN_NORMAL;</a>
<a name="ln780">    case OBJ_ARMOUR:</a>
<a name="ln781">        return get_armour_ego_type(item) != SPARM_NORMAL;</a>
<a name="ln782">    case OBJ_MISSILES:</a>
<a name="ln783">        return get_ammo_brand(item) != SPMSL_NORMAL;</a>
<a name="ln784">    default:</a>
<a name="ln785">        return false;</a>
<a name="ln786">    }</a>
<a name="ln787">}</a>
<a name="ln788"> </a>
<a name="ln789">// 2 - artefact, 1 - glowing/runed, 0 - mundane</a>
<a name="ln790">static int _item_name_specialness(const item_def&amp; item)</a>
<a name="ln791">{</a>
<a name="ln792">    if (item.base_type != OBJ_WEAPONS &amp;&amp; item.base_type != OBJ_ARMOUR</a>
<a name="ln793">        &amp;&amp; item.base_type != OBJ_MISSILES &amp;&amp; item.base_type != OBJ_JEWELLERY)</a>
<a name="ln794">    {</a>
<a name="ln795">        return 0;</a>
<a name="ln796">    }</a>
<a name="ln797"> </a>
<a name="ln798">    // You can tell something is an artefact, because it'll have a</a>
<a name="ln799">    // description which rules out anything else.</a>
<a name="ln800">    if (is_artefact(item))</a>
<a name="ln801">        return 2;</a>
<a name="ln802"> </a>
<a name="ln803">    // All unknown jewellery is worth looking at.</a>
<a name="ln804">    if (item.base_type == OBJ_JEWELLERY)</a>
<a name="ln805">    {</a>
<a name="ln806">        if (is_useless_item(item))</a>
<a name="ln807">            return 0;</a>
<a name="ln808"> </a>
<a name="ln809">        return 1;</a>
<a name="ln810">    }</a>
<a name="ln811"> </a>
<a name="ln812">    if (item_type_known(item))</a>
<a name="ln813">    {</a>
<a name="ln814">        if (item_is_branded(item))</a>
<a name="ln815">            return 1;</a>
<a name="ln816">        return 0;</a>
<a name="ln817">    }</a>
<a name="ln818"> </a>
<a name="ln819">    if (item.flags &amp; ISFLAG_COSMETIC_MASK)</a>
<a name="ln820">        return 1;</a>
<a name="ln821"> </a>
<a name="ln822">    return 0;</a>
<a name="ln823">}</a>
<a name="ln824"> </a>
<a name="ln825">static void _maybe_give_corpse_hint(const item_def&amp; item)</a>
<a name="ln826">{</a>
<a name="ln827">    if (!crawl_state.game_is_hints_tutorial())</a>
<a name="ln828">        return;</a>
<a name="ln829"> </a>
<a name="ln830">    if (item.is_type(OBJ_CORPSES, CORPSE_BODY)</a>
<a name="ln831">        &amp;&amp; you.has_spell(SPELL_ANIMATE_SKELETON))</a>
<a name="ln832">    {</a>
<a name="ln833">        learned_something_new(HINT_ANIMATE_CORPSE_SKELETON);</a>
<a name="ln834">    }</a>
<a name="ln835">}</a>
<a name="ln836"> </a>
<a name="ln837">void item_check()</a>
<a name="ln838">{</a>
<a name="ln839">    describe_floor();</a>
<a name="ln840">    origin_set(you.pos());</a>
<a name="ln841"> </a>
<a name="ln842">    ostream&amp; strm = msg::streams(MSGCH_FLOOR_ITEMS);</a>
<a name="ln843"> </a>
<a name="ln844">    auto items = item_list_on_square(you.visible_igrd(you.pos()));</a>
<a name="ln845"> </a>
<a name="ln846">    if (items.empty())</a>
<a name="ln847">        return;</a>
<a name="ln848"> </a>
<a name="ln849">    if (items.size() == 1)</a>
<a name="ln850">    {</a>
<a name="ln851">        const item_def&amp; it(*items[0]);</a>
<a name="ln852">        string name = menu_colour_item_name(it, DESC_A);</a>
<a name="ln853">        strm &lt;&lt; &quot;You see here &quot; &lt;&lt; name &lt;&lt; '.' &lt;&lt; endl;</a>
<a name="ln854">        _maybe_give_corpse_hint(it);</a>
<a name="ln855">        return;</a>
<a name="ln856">    }</a>
<a name="ln857"> </a>
<a name="ln858">    bool done_init_line = false;</a>
<a name="ln859"> </a>
<a name="ln860">    if (static_cast&lt;int&gt;(items.size()) &gt;= Options.item_stack_summary_minimum)</a>
<a name="ln861">    {</a>
<a name="ln862">        vector&lt;unsigned int&gt; item_chars;</a>
<a name="ln863">        for (unsigned int i = 0; i &lt; items.size() &amp;&amp; i &lt; 50; ++i)</a>
<a name="ln864">        {</a>
<a name="ln865">            cglyph_t g = get_item_glyph(*items[i]);</a>
<a name="ln866">            item_chars.push_back(g.ch * 0x100 +</a>
<a name="ln867">                                 (10 - _item_name_specialness(*(items[i]))));</a>
<a name="ln868">        }</a>
<a name="ln869">        sort(item_chars.begin(), item_chars.end());</a>
<a name="ln870"> </a>
<a name="ln871">        string out_string = &quot;Items here: &quot;;</a>
<a name="ln872">        int cur_state = -1;</a>
<a name="ln873">        string colour = &quot;&quot;;</a>
<a name="ln874">        for (unsigned int i = 0; i &lt; item_chars.size(); ++i)</a>
<a name="ln875">        {</a>
<a name="ln876">            const int specialness = 10 - (item_chars[i] % 0x100);</a>
<a name="ln877">            if (specialness != cur_state)</a>
<a name="ln878">            {</a>
<a name="ln879">                if (!colour.empty())</a>
<a name="ln880">                    out_string += &quot;&lt;/&quot; + colour + &quot;&gt;&quot;;</a>
<a name="ln881">                switch (specialness)</a>
<a name="ln882">                {</a>
<a name="ln883">                case 2: colour = &quot;yellow&quot;;   break; // artefact</a>
<a name="ln884">                case 1: colour = &quot;white&quot;;    break; // glowing/runed</a>
<a name="ln885">                case 0: colour = &quot;darkgrey&quot;; break; // mundane</a>
<a name="ln886">                }</a>
<a name="ln887">                if (!colour.empty())</a>
<a name="ln888">                    out_string += &quot;&lt;&quot; + colour + &quot;&gt;&quot;;</a>
<a name="ln889">                cur_state = specialness;</a>
<a name="ln890">            }</a>
<a name="ln891"> </a>
<a name="ln892">            out_string += stringize_glyph(item_chars[i] / 0x100);</a>
<a name="ln893">            if (i + 1 &lt; item_chars.size()</a>
<a name="ln894">                &amp;&amp; (item_chars[i] / 0x100) != (item_chars[i+1] / 0x100))</a>
<a name="ln895">            {</a>
<a name="ln896">                out_string += ' ';</a>
<a name="ln897">            }</a>
<a name="ln898">        }</a>
<a name="ln899">        if (!colour.empty())</a>
<a name="ln900">            out_string += &quot;&lt;/&quot; + colour + &quot;&gt;&quot;;</a>
<a name="ln901">        mpr_nojoin(MSGCH_FLOOR_ITEMS, out_string);</a>
<a name="ln902">        done_init_line = true;</a>
<a name="ln903">    }</a>
<a name="ln904"> </a>
<a name="ln905">    if (items.size() &lt;= msgwin_lines() - 1)</a>
<a name="ln906">    {</a>
<a name="ln907">        if (!done_init_line)</a>
<a name="ln908">            mpr_nojoin(MSGCH_FLOOR_ITEMS, &quot;Things that are here:&quot;);</a>
<a name="ln909">        for (const item_def *it : items)</a>
<a name="ln910">        {</a>
<a name="ln911">            mprf_nocap(&quot;%s&quot;, menu_colour_item_name(*it, DESC_A).c_str());</a>
<a name="ln912">            _maybe_give_corpse_hint(*it);</a>
<a name="ln913">        }</a>
<a name="ln914">    }</a>
<a name="ln915">    else if (!done_init_line)</a>
<a name="ln916">        strm &lt;&lt; &quot;There are many items here.&quot; &lt;&lt; endl;</a>
<a name="ln917"> </a>
<a name="ln918">    if (items.size() &gt; 2 &amp;&amp; crawl_state.game_is_hints_tutorial())</a>
<a name="ln919">    {</a>
<a name="ln920">        // If there are 2 or more non-corpse items here, we might need</a>
<a name="ln921">        // a hint.</a>
<a name="ln922">        int count = 0;</a>
<a name="ln923">        for (const item_def *it : items)</a>
<a name="ln924">        {</a>
<a name="ln925">            if (it-&gt;base_type == OBJ_CORPSES)</a>
<a name="ln926">                continue;</a>
<a name="ln927"> </a>
<a name="ln928">            if (++count &gt; 1)</a>
<a name="ln929">            {</a>
<a name="ln930">                learned_something_new(HINT_MULTI_PICKUP);</a>
<a name="ln931">                break;</a>
<a name="ln932">            }</a>
<a name="ln933">        }</a>
<a name="ln934">    }</a>
<a name="ln935">}</a>
<a name="ln936"> </a>
<a name="ln937">// Identify the object the player stepped on.</a>
<a name="ln938">// Books are fully identified.</a>
<a name="ln939">// Wands are only type-identified.</a>
<a name="ln940">static bool _id_floor_item(item_def &amp;item)</a>
<a name="ln941">{</a>
<a name="ln942">    if (item.base_type == OBJ_BOOKS)</a>
<a name="ln943">    {</a>
<a name="ln944">        if (fully_identified(item))</a>
<a name="ln945">            return false;</a>
<a name="ln946"> </a>
<a name="ln947">        // fix autopickup for previously-unknown books (hack)</a>
<a name="ln948">        if (item_needs_autopickup(item))</a>
<a name="ln949">            item.props[&quot;needs_autopickup&quot;] = true;</a>
<a name="ln950">        set_ident_flags(item, ISFLAG_IDENT_MASK);</a>
<a name="ln951">        return true;</a>
<a name="ln952">    }</a>
<a name="ln953">    else if (item.base_type == OBJ_WANDS)</a>
<a name="ln954">    {</a>
<a name="ln955">        if (!get_ident_type(item))</a>
<a name="ln956">        {</a>
<a name="ln957">            // If the player doesn't want unknown wands picked up, assume</a>
<a name="ln958">            // they won't want this wand after it is identified.</a>
<a name="ln959">            bool should_pickup = item_needs_autopickup(item);</a>
<a name="ln960">            set_ident_type(item, true);</a>
<a name="ln961">            if (!should_pickup)</a>
<a name="ln962">                set_item_autopickup(item, AP_FORCE_OFF);</a>
<a name="ln963">            return true;</a>
<a name="ln964">        }</a>
<a name="ln965">    }</a>
<a name="ln966"> </a>
<a name="ln967">    return false;</a>
<a name="ln968">}</a>
<a name="ln969"> </a>
<a name="ln970">/// Auto-ID whatever stuff the player stands on.</a>
<a name="ln971">void id_floor_items()</a>
<a name="ln972">{</a>
<a name="ln973">    for (stack_iterator si(you.pos()); si; ++si)</a>
<a name="ln974">        _id_floor_item(*si);</a>
<a name="ln975">}</a>
<a name="ln976"> </a>
<a name="ln977">void pickup_menu(int item_link)</a>
<a name="ln978">{</a>
<a name="ln979">    int n_did_pickup   = 0;</a>
<a name="ln980">    int n_tried_pickup = 0;</a>
<a name="ln981"> </a>
<a name="ln982">    auto items = item_list_on_square(item_link);</a>
<a name="ln983">    ASSERT(items.size());</a>
<a name="ln984"> </a>
<a name="ln985">    string prompt = &quot;Pick up what? &quot; + slot_description()</a>
<a name="ln986">#ifdef TOUCH_UI</a>
<a name="ln987">                  + &quot; (&lt;Enter&gt; or tap header to pick up)&quot;</a>
<a name="ln988">#else</a>
<a name="ln989">                  + &quot; (_ for help)&quot;</a>
<a name="ln990">#endif</a>
<a name="ln991">                  ;</a>
<a name="ln992"> </a>
<a name="ln993">    if (items.size() == 1 &amp;&amp; items[0]-&gt;quantity &gt; 1)</a>
<a name="ln994">        prompt = &quot;Select pick up quantity by entering a number, then select the item&quot;;</a>
<a name="ln995">    vector&lt;SelItem&gt; selected = select_items(items, prompt.c_str(), false,</a>
<a name="ln996">                                            menu_type::pickup);</a>
<a name="ln997">    if (selected.empty())</a>
<a name="ln998">        canned_msg(MSG_OK);</a>
<a name="ln999">    redraw_screen();</a>
<a name="ln1000"> </a>
<a name="ln1001">    string pickup_warning;</a>
<a name="ln1002">    for (const SelItem &amp;sel : selected)</a>
<a name="ln1003">    {</a>
<a name="ln1004">        // Moving the item might destroy it, in which case we can't</a>
<a name="ln1005">        // rely on the link.</a>
<a name="ln1006">        short next;</a>
<a name="ln1007">        for (int j = item_link; j != NON_ITEM; j = next)</a>
<a name="ln1008">        {</a>
<a name="ln1009">            next = mitm[j].link;</a>
<a name="ln1010">            if (&amp;mitm[j] == sel.item)</a>
<a name="ln1011">            {</a>
<a name="ln1012">                if (j == item_link)</a>
<a name="ln1013">                    item_link = next;</a>
<a name="ln1014"> </a>
<a name="ln1015">                int num_to_take = sel.quantity;</a>
<a name="ln1016">                const bool take_all = (num_to_take == mitm[j].quantity);</a>
<a name="ln1017">                iflags_t oldflags = mitm[j].flags;</a>
<a name="ln1018">                clear_item_pickup_flags(mitm[j]);</a>
<a name="ln1019"> </a>
<a name="ln1020">                // If we cleared any flags on the items, but the pickup was</a>
<a name="ln1021">                // partial, reset the flags for the items that remain on the</a>
<a name="ln1022">                // floor.</a>
<a name="ln1023">                if (!move_item_to_inv(j, num_to_take))</a>
<a name="ln1024">                {</a>
<a name="ln1025">                    n_tried_pickup++;</a>
<a name="ln1026">                    pickup_warning = &quot;You can't carry that many items.&quot;;</a>
<a name="ln1027">                    if (mitm[j].defined())</a>
<a name="ln1028">                        mitm[j].flags = oldflags;</a>
<a name="ln1029">                }</a>
<a name="ln1030">                else</a>
<a name="ln1031">                {</a>
<a name="ln1032">                    n_did_pickup++;</a>
<a name="ln1033">                    // If we deliberately chose to take only part of a</a>
<a name="ln1034">                    // pile, we consider the rest to have been</a>
<a name="ln1035">                    // &quot;dropped.&quot;</a>
<a name="ln1036">                    if (!take_all &amp;&amp; mitm[j].defined())</a>
<a name="ln1037">                        mitm[j].flags |= ISFLAG_DROPPED;</a>
<a name="ln1038">                }</a>
<a name="ln1039">            }</a>
<a name="ln1040">        }</a>
<a name="ln1041">    }</a>
<a name="ln1042"> </a>
<a name="ln1043">    if (!pickup_warning.empty())</a>
<a name="ln1044">    {</a>
<a name="ln1045">        mpr(pickup_warning);</a>
<a name="ln1046">        learned_something_new(HINT_FULL_INVENTORY);</a>
<a name="ln1047">    }</a>
<a name="ln1048"> </a>
<a name="ln1049">    if (n_did_pickup)</a>
<a name="ln1050">        you.turn_is_over = true;</a>
<a name="ln1051">}</a>
<a name="ln1052"> </a>
<a name="ln1053">bool origin_known(const item_def &amp;item)</a>
<a name="ln1054">{</a>
<a name="ln1055">    return item.orig_place != level_id();</a>
<a name="ln1056">}</a>
<a name="ln1057"> </a>
<a name="ln1058">void origin_reset(item_def &amp;item)</a>
<a name="ln1059">{</a>
<a name="ln1060">    item.orig_place.clear();</a>
<a name="ln1061">    item.orig_monnum = 0;</a>
<a name="ln1062">}</a>
<a name="ln1063"> </a>
<a name="ln1064">// We have no idea where the player found this item.</a>
<a name="ln1065">void origin_set_unknown(item_def &amp;item)</a>
<a name="ln1066">{</a>
<a name="ln1067">    if (!origin_known(item))</a>
<a name="ln1068">    {</a>
<a name="ln1069">        item.orig_place  = level_id(BRANCH_DUNGEON, 0);</a>
<a name="ln1070">        item.orig_monnum = 0;</a>
<a name="ln1071">    }</a>
<a name="ln1072">}</a>
<a name="ln1073"> </a>
<a name="ln1074">// This item is starting equipment.</a>
<a name="ln1075">void origin_set_startequip(item_def &amp;item)</a>
<a name="ln1076">{</a>
<a name="ln1077">    if (!origin_known(item))</a>
<a name="ln1078">    {</a>
<a name="ln1079">        item.orig_place  = level_id(BRANCH_DUNGEON, 0);</a>
<a name="ln1080">        item.orig_monnum = -IT_SRC_START;</a>
<a name="ln1081">    }</a>
<a name="ln1082">}</a>
<a name="ln1083"> </a>
<a name="ln1084">void origin_set_monster(item_def &amp;item, const monster* mons)</a>
<a name="ln1085">{</a>
<a name="ln1086">    if (!origin_known(item))</a>
<a name="ln1087">    {</a>
<a name="ln1088">        if (!item.orig_monnum)</a>
<a name="ln1089">            item.orig_monnum = mons-&gt;type;</a>
<a name="ln1090">        item.orig_place = level_id::current();</a>
<a name="ln1091">    }</a>
<a name="ln1092">}</a>
<a name="ln1093"> </a>
<a name="ln1094">void origin_purchased(item_def &amp;item)</a>
<a name="ln1095">{</a>
<a name="ln1096">    // We don't need to check origin_known if it's a shop purchase</a>
<a name="ln1097">    item.orig_place  = level_id::current();</a>
<a name="ln1098">    item.orig_monnum = -IT_SRC_SHOP;</a>
<a name="ln1099">}</a>
<a name="ln1100"> </a>
<a name="ln1101">void origin_acquired(item_def &amp;item, int agent)</a>
<a name="ln1102">{</a>
<a name="ln1103">    // We don't need to check origin_known if it's a divine gift</a>
<a name="ln1104">    item.orig_place  = level_id::current();</a>
<a name="ln1105">    item.orig_monnum = -agent;</a>
<a name="ln1106">}</a>
<a name="ln1107"> </a>
<a name="ln1108">static string _milestone_rune(const item_def &amp;item)</a>
<a name="ln1109">{</a>
<a name="ln1110">    return string(&quot;found &quot;) + item.name(DESC_A) + &quot;.&quot;;</a>
<a name="ln1111">}</a>
<a name="ln1112"> </a>
<a name="ln1113">static void _milestone_check(const item_def &amp;item)</a>
<a name="ln1114">{</a>
<a name="ln1115">    if (item.base_type == OBJ_RUNES)</a>
<a name="ln1116">        mark_milestone(&quot;rune&quot;, _milestone_rune(item));</a>
<a name="ln1117">    else if (item_is_orb(item))</a>
<a name="ln1118">        mark_milestone(&quot;orb&quot;, &quot;found the Orb of Zot!&quot;);</a>
<a name="ln1119">}</a>
<a name="ln1120"> </a>
<a name="ln1121">static void _check_note_item(item_def &amp;item)</a>
<a name="ln1122">{</a>
<a name="ln1123">    if (item.flags &amp; (ISFLAG_NOTED_GET | ISFLAG_NOTED_ID))</a>
<a name="ln1124">        return;</a>
<a name="ln1125"> </a>
<a name="ln1126">    if (item.base_type == OBJ_RUNES || item_is_orb(item) || is_artefact(item))</a>
<a name="ln1127">    {</a>
<a name="ln1128">        take_note(Note(NOTE_GET_ITEM, 0, 0, item.name(DESC_A),</a>
<a name="ln1129">                       origin_desc(item)));</a>
<a name="ln1130">        item.flags |= ISFLAG_NOTED_GET;</a>
<a name="ln1131"> </a>
<a name="ln1132">        // If it's already fully identified when picked up, don't take</a>
<a name="ln1133">        // further notes.</a>
<a name="ln1134">        if (fully_identified(item))</a>
<a name="ln1135">            item.flags |= ISFLAG_NOTED_ID;</a>
<a name="ln1136">        _milestone_check(item);</a>
<a name="ln1137">    }</a>
<a name="ln1138">}</a>
<a name="ln1139"> </a>
<a name="ln1140">void origin_set(const coord_def&amp; where)</a>
<a name="ln1141">{</a>
<a name="ln1142">    for (stack_iterator si(where); si; ++si)</a>
<a name="ln1143">    {</a>
<a name="ln1144">        if (origin_known(*si))</a>
<a name="ln1145">            continue;</a>
<a name="ln1146"> </a>
<a name="ln1147">        si-&gt;orig_place = level_id::current();</a>
<a name="ln1148">    }</a>
<a name="ln1149">}</a>
<a name="ln1150"> </a>
<a name="ln1151">static void _origin_freeze(item_def &amp;item)</a>
<a name="ln1152">{</a>
<a name="ln1153">    if (!origin_known(item))</a>
<a name="ln1154">    {</a>
<a name="ln1155">        item.orig_place = level_id::current();</a>
<a name="ln1156">        _check_note_item(item);</a>
<a name="ln1157">    }</a>
<a name="ln1158">}</a>
<a name="ln1159"> </a>
<a name="ln1160">static string _origin_monster_name(const item_def &amp;item)</a>
<a name="ln1161">{</a>
<a name="ln1162">    const monster_type monnum = static_cast&lt;monster_type&gt;(item.orig_monnum);</a>
<a name="ln1163">    if (monnum == MONS_PLAYER_GHOST)</a>
<a name="ln1164">        return &quot;a player ghost&quot;;</a>
<a name="ln1165">    else if (monnum == MONS_PANDEMONIUM_LORD)</a>
<a name="ln1166">        return &quot;a pandemonium lord&quot;;</a>
<a name="ln1167">    return mons_type_name(monnum, DESC_A);</a>
<a name="ln1168">}</a>
<a name="ln1169"> </a>
<a name="ln1170">static string _origin_place_desc(const item_def &amp;item)</a>
<a name="ln1171">{</a>
<a name="ln1172">    return prep_branch_level_name(item.orig_place);</a>
<a name="ln1173">}</a>
<a name="ln1174"> </a>
<a name="ln1175">static bool _origin_is_special(const item_def &amp;item)</a>
<a name="ln1176">{</a>
<a name="ln1177">    return item.orig_place == level_id(BRANCH_DUNGEON, 0);</a>
<a name="ln1178">}</a>
<a name="ln1179"> </a>
<a name="ln1180">bool origin_describable(const item_def &amp;item)</a>
<a name="ln1181">{</a>
<a name="ln1182">    return origin_known(item)</a>
<a name="ln1183">           &amp;&amp; !_origin_is_special(item)</a>
<a name="ln1184">           &amp;&amp; !is_stackable_item(item)</a>
<a name="ln1185">           &amp;&amp; item.quantity == 1</a>
<a name="ln1186">           &amp;&amp; item.base_type != OBJ_CORPSES</a>
<a name="ln1187">           &amp;&amp; (item.base_type != OBJ_FOOD || item.sub_type != FOOD_CHUNK);</a>
<a name="ln1188">}</a>
<a name="ln1189"> </a>
<a name="ln1190">static string _article_it(const item_def &amp;/*item*/)</a>
<a name="ln1191">{</a>
<a name="ln1192">    // &quot;it&quot; is always correct, since gloves and boots also come in pairs.</a>
<a name="ln1193">    return &quot;it&quot;;</a>
<a name="ln1194">}</a>
<a name="ln1195"> </a>
<a name="ln1196">static bool _origin_is_original_equip(const item_def &amp;item)</a>
<a name="ln1197">{</a>
<a name="ln1198">    return _origin_is_special(item) &amp;&amp; item.orig_monnum == -IT_SRC_START;</a>
<a name="ln1199">}</a>
<a name="ln1200"> </a>
<a name="ln1201">/**</a>
<a name="ln1202"> * What god gifted this item to the player?</a>
<a name="ln1203"> *</a>
<a name="ln1204"> * @param item      The item in question.</a>
<a name="ln1205"> * @returns         The god that gifted this item to the player, if any;</a>
<a name="ln1206"> *                  else GOD_NO_GOD.</a>
<a name="ln1207"> */</a>
<a name="ln1208">god_type origin_as_god_gift(const item_def&amp; item)</a>
<a name="ln1209">{</a>
<a name="ln1210">    const god_type ogod = static_cast&lt;god_type&gt;(-item.orig_monnum);</a>
<a name="ln1211">    if (ogod &lt;= GOD_NO_GOD || ogod &gt;= NUM_GODS)</a>
<a name="ln1212">        return GOD_NO_GOD;</a>
<a name="ln1213">    return ogod;</a>
<a name="ln1214">}</a>
<a name="ln1215"> </a>
<a name="ln1216">bool origin_is_acquirement(const item_def&amp; item, item_source_type *type)</a>
<a name="ln1217">{</a>
<a name="ln1218">    item_source_type junk;</a>
<a name="ln1219">    if (type == nullptr)</a>
<a name="ln1220">        type = &amp;junk;</a>
<a name="ln1221">    *type = IT_SRC_NONE;</a>
<a name="ln1222"> </a>
<a name="ln1223">    const int iorig = -item.orig_monnum;</a>
<a name="ln1224">#if TAG_MAJOR_VERSION == 34</a>
<a name="ln1225">// Copy pasting is bad but this will autoupdate on version bump</a>
<a name="ln1226">    if (iorig == AQ_CARD_GENIE)</a>
<a name="ln1227">    {</a>
<a name="ln1228">        *type = static_cast&lt;item_source_type&gt;(iorig);</a>
<a name="ln1229">        return true;</a>
<a name="ln1230">    }</a>
<a name="ln1231"> </a>
<a name="ln1232">#endif</a>
<a name="ln1233">    if (iorig == AQ_SCROLL || iorig == AQ_WIZMODE)</a>
<a name="ln1234">    {</a>
<a name="ln1235">        *type = static_cast&lt;item_source_type&gt;(iorig);</a>
<a name="ln1236">        return true;</a>
<a name="ln1237">    }</a>
<a name="ln1238"> </a>
<a name="ln1239">    return false;</a>
<a name="ln1240">}</a>
<a name="ln1241"> </a>
<a name="ln1242">string origin_desc(const item_def &amp;item)</a>
<a name="ln1243">{</a>
<a name="ln1244">    if (!origin_describable(item))</a>
<a name="ln1245">        return &quot;&quot;;</a>
<a name="ln1246"> </a>
<a name="ln1247">    if (_origin_is_original_equip(item))</a>
<a name="ln1248">        return &quot;Original Equipment&quot;;</a>
<a name="ln1249"> </a>
<a name="ln1250">    string desc;</a>
<a name="ln1251">    if (item.orig_monnum)</a>
<a name="ln1252">    {</a>
<a name="ln1253">        if (item.orig_monnum &lt; 0)</a>
<a name="ln1254">        {</a>
<a name="ln1255">            int iorig = -item.orig_monnum;</a>
<a name="ln1256">            switch (iorig)</a>
<a name="ln1257">            {</a>
<a name="ln1258">            case IT_SRC_SHOP:</a>
<a name="ln1259">                desc += &quot;You bought &quot; + _article_it(item) + &quot; in a shop &quot;;</a>
<a name="ln1260">                break;</a>
<a name="ln1261">            case IT_SRC_START:</a>
<a name="ln1262">                desc += &quot;Buggy Original Equipment: &quot;;</a>
<a name="ln1263">                break;</a>
<a name="ln1264">            case AQ_SCROLL:</a>
<a name="ln1265">                desc += &quot;You acquired &quot; + _article_it(item) + &quot; &quot;;</a>
<a name="ln1266">                break;</a>
<a name="ln1267">#if TAG_MAJOR_VERSION == 34</a>
<a name="ln1268">            case AQ_CARD_GENIE:</a>
<a name="ln1269">                desc += &quot;You drew the Genie &quot;;</a>
<a name="ln1270">                break;</a>
<a name="ln1271">#endif</a>
<a name="ln1272">            case AQ_WIZMODE:</a>
<a name="ln1273">                desc += &quot;Your wizardly powers created &quot;+ _article_it(item)+ &quot; &quot;;</a>
<a name="ln1274">                break;</a>
<a name="ln1275">            default:</a>
<a name="ln1276">                if (iorig &gt; GOD_NO_GOD &amp;&amp; iorig &lt; NUM_GODS)</a>
<a name="ln1277">                {</a>
<a name="ln1278">                    desc += god_name(static_cast&lt;god_type&gt;(iorig))</a>
<a name="ln1279">                        + &quot; gifted &quot; + _article_it(item) + &quot; to you &quot;;</a>
<a name="ln1280">                }</a>
<a name="ln1281">                else</a>
<a name="ln1282">                {</a>
<a name="ln1283">                    // Bug really.</a>
<a name="ln1284">                    desc += &quot;You stumbled upon &quot; + _article_it(item) + &quot; &quot;;</a>
<a name="ln1285">                }</a>
<a name="ln1286">                break;</a>
<a name="ln1287">            }</a>
<a name="ln1288">        }</a>
<a name="ln1289">        else if (item.orig_monnum == MONS_DANCING_WEAPON)</a>
<a name="ln1290">            desc += &quot;You subdued it &quot;;</a>
<a name="ln1291">        else</a>
<a name="ln1292">        {</a>
<a name="ln1293">            desc += &quot;You took &quot; + _article_it(item) + &quot; off &quot;</a>
<a name="ln1294">                    + _origin_monster_name(item) + &quot; &quot;;</a>
<a name="ln1295">        }</a>
<a name="ln1296">    }</a>
<a name="ln1297">    else</a>
<a name="ln1298">        desc += &quot;You found &quot; + _article_it(item) + &quot; &quot;;</a>
<a name="ln1299"> </a>
<a name="ln1300">    desc += _origin_place_desc(item);</a>
<a name="ln1301">    return desc;</a>
<a name="ln1302">}</a>
<a name="ln1303"> </a>
<a name="ln1304">/**</a>
<a name="ln1305"> * Pickup a single item stack at the given location link</a>
<a name="ln1306"> *</a>
<a name="ln1307"> * @param link The location link</a>
<a name="ln1308"> * @param qty If 0, prompt for quantity of that item to pick up, if &lt; 0,</a>
<a name="ln1309"> *            pick up the entire stack, otherwise pick up qty of the item.</a>
<a name="ln1310"> * @return  True if any item was picked up, false otherwise.</a>
<a name="ln1311">*/</a>
<a name="ln1312">bool pickup_single_item(int link, int qty)</a>
<a name="ln1313">{</a>
<a name="ln1314">    ASSERT(link != NON_ITEM);</a>
<a name="ln1315"> </a>
<a name="ln1316">    item_def* item = &amp;mitm[link];</a>
<a name="ln1317">    if (item_is_stationary(mitm[link]))</a>
<a name="ln1318">    {</a>
<a name="ln1319">        mpr(&quot;You can't pick that up.&quot;);</a>
<a name="ln1320">        return false;</a>
<a name="ln1321">    }</a>
<a name="ln1322">    if (item-&gt;base_type == OBJ_GOLD &amp;&amp; !qty &amp;&amp; !i_feel_safe()</a>
<a name="ln1323">        &amp;&amp; !yesno(&quot;Are you sure you want to pick up this pile of gold now?&quot;,</a>
<a name="ln1324">                  true, 'n'))</a>
<a name="ln1325">    {</a>
<a name="ln1326">        canned_msg(MSG_OK);</a>
<a name="ln1327">        return false;</a>
<a name="ln1328">    }</a>
<a name="ln1329">    if (qty == 0 &amp;&amp; item-&gt;quantity &gt; 1 &amp;&amp; item-&gt;base_type != OBJ_GOLD)</a>
<a name="ln1330">    {</a>
<a name="ln1331">        const string prompt</a>
<a name="ln1332">                = make_stringf(&quot;Pick up how many of %s (; or enter for all)? &quot;,</a>
<a name="ln1333">                               item-&gt;name(DESC_THE, false,</a>
<a name="ln1334">                                          false, false).c_str());</a>
<a name="ln1335"> </a>
<a name="ln1336">        qty = prompt_for_quantity(prompt.c_str());</a>
<a name="ln1337">        if (qty == -1)</a>
<a name="ln1338">            qty = item-&gt;quantity;</a>
<a name="ln1339">        else if (qty == 0)</a>
<a name="ln1340">        {</a>
<a name="ln1341">            canned_msg(MSG_OK);</a>
<a name="ln1342">            return false;</a>
<a name="ln1343">        }</a>
<a name="ln1344">        else if (qty &lt; item-&gt;quantity)</a>
<a name="ln1345">        {</a>
<a name="ln1346">            // Mark rest item as not eligible for autopickup.</a>
<a name="ln1347">            item-&gt;flags |= ISFLAG_DROPPED;</a>
<a name="ln1348">            item-&gt;flags &amp;= ~ISFLAG_THROWN;</a>
<a name="ln1349">        }</a>
<a name="ln1350">    }</a>
<a name="ln1351"> </a>
<a name="ln1352">    if (qty &lt; 1 || qty &gt; item-&gt;quantity)</a>
<a name="ln1353">        qty = item-&gt;quantity;</a>
<a name="ln1354"> </a>
<a name="ln1355">    iflags_t oldflags = item-&gt;flags;</a>
<a name="ln1356">    clear_item_pickup_flags(*item);</a>
<a name="ln1357">    const bool pickup_succ = move_item_to_inv(link, qty);</a>
<a name="ln1358">    if (item-&gt;defined())</a>
<a name="ln1359">        item-&gt;flags = oldflags;</a>
<a name="ln1360"> </a>
<a name="ln1361">    if (!pickup_succ)</a>
<a name="ln1362">    {</a>
<a name="ln1363">        mpr(&quot;You can't carry that many items.&quot;);</a>
<a name="ln1364">        learned_something_new(HINT_FULL_INVENTORY);</a>
<a name="ln1365">        return false;</a>
<a name="ln1366">    }</a>
<a name="ln1367">    return true;</a>
<a name="ln1368">}</a>
<a name="ln1369"> </a>
<a name="ln1370">bool player_on_single_stack()</a>
<a name="ln1371">{</a>
<a name="ln1372">    int o = you.visible_igrd(you.pos());</a>
<a name="ln1373">    if (o == NON_ITEM)</a>
<a name="ln1374">        return false;</a>
<a name="ln1375">    else</a>
<a name="ln1376">        return mitm[o].link == NON_ITEM &amp;&amp; mitm[o].quantity &gt; 1;</a>
<a name="ln1377">}</a>
<a name="ln1378"> </a>
<a name="ln1379">/**</a>
<a name="ln1380"> * Do the pickup command.</a>
<a name="ln1381"> *</a>
<a name="ln1382"> * @param partial_quantity If true, prompt for a quantity to pick up when</a>
<a name="ln1383"> *                         picking up a single stack.</a>
<a name="ln1384">*/</a>
<a name="ln1385">void pickup(bool partial_quantity)</a>
<a name="ln1386">{</a>
<a name="ln1387">    int keyin = 'x';</a>
<a name="ln1388"> </a>
<a name="ln1389">    int o = you.visible_igrd(you.pos());</a>
<a name="ln1390">    const int num_items = count_movable_items(o);</a>
<a name="ln1391"> </a>
<a name="ln1392">    // Store last_pickup in case we need to restore it.</a>
<a name="ln1393">    // Then clear it to fill with items picked up.</a>
<a name="ln1394">    map&lt;int,int&gt; tmp_l_p = you.last_pickup;</a>
<a name="ln1395">    you.last_pickup.clear();</a>
<a name="ln1396"> </a>
<a name="ln1397">    if (o == NON_ITEM)</a>
<a name="ln1398">        mpr(&quot;There are no items here.&quot;);</a>
<a name="ln1399">    else if (you.form == transformation::ice_beast</a>
<a name="ln1400">             &amp;&amp; grd(you.pos()) == DNGN_DEEP_WATER)</a>
<a name="ln1401">    {</a>
<a name="ln1402">        mpr(&quot;You can't reach the bottom while floating on water.&quot;);</a>
<a name="ln1403">    }</a>
<a name="ln1404">    else if (num_items == 1) // just one movable item?</a>
<a name="ln1405">    {</a>
<a name="ln1406">        // Get the link to the movable item in the pile.</a>
<a name="ln1407">        while (item_is_stationary(mitm[o]))</a>
<a name="ln1408">            o = mitm[o].link;</a>
<a name="ln1409">        pickup_single_item(o, partial_quantity ? 0 : mitm[o].quantity);</a>
<a name="ln1410">    }</a>
<a name="ln1411">    else if (Options.pickup_menu_limit</a>
<a name="ln1412">             &amp;&amp; num_items &gt; (Options.pickup_menu_limit &gt; 0</a>
<a name="ln1413">                             ? Options.pickup_menu_limit</a>
<a name="ln1414">                             : Options.item_stack_summary_minimum - 1))</a>
<a name="ln1415">    {</a>
<a name="ln1416">        pickup_menu(o);</a>
<a name="ln1417">    }</a>
<a name="ln1418">    else</a>
<a name="ln1419">    {</a>
<a name="ln1420">        int next;</a>
<a name="ln1421">        if (num_items == 0)</a>
<a name="ln1422">            mpr(&quot;There are no objects that can be picked up here.&quot;);</a>
<a name="ln1423">        else</a>
<a name="ln1424">            mpr(&quot;There are several objects here.&quot;);</a>
<a name="ln1425">        string pickup_warning;</a>
<a name="ln1426">        bool any_selectable = false;</a>
<a name="ln1427">        while (o != NON_ITEM)</a>
<a name="ln1428">        {</a>
<a name="ln1429">            // Must save this because pickup can destroy the item.</a>
<a name="ln1430">            next = mitm[o].link;</a>
<a name="ln1431"> </a>
<a name="ln1432">            if (item_is_stationary(mitm[o]))</a>
<a name="ln1433">            {</a>
<a name="ln1434">                o = next;</a>
<a name="ln1435">                continue;</a>
<a name="ln1436">            }</a>
<a name="ln1437">            any_selectable = true;</a>
<a name="ln1438"> </a>
<a name="ln1439">            if (keyin != 'a')</a>
<a name="ln1440">            {</a>
<a name="ln1441">                string prompt = &quot;Pick up %s? ((y)es/(n)o/(a)ll/(m)enu/*?g,/q)&quot;;</a>
<a name="ln1442"> </a>
<a name="ln1443">                mprf(MSGCH_PROMPT, prompt.c_str(),</a>
<a name="ln1444">                     menu_colour_item_name(mitm[o], DESC_A).c_str());</a>
<a name="ln1445"> </a>
<a name="ln1446">                mouse_control mc(MOUSE_MODE_YESNO);</a>
<a name="ln1447">                keyin = getch_ck();</a>
<a name="ln1448">            }</a>
<a name="ln1449"> </a>
<a name="ln1450">            if (keyin == '*' || keyin == '?' || keyin == ',' || keyin == 'g'</a>
<a name="ln1451">                || keyin == 'm' || keyin == CK_MOUSE_CLICK)</a>
<a name="ln1452">            {</a>
<a name="ln1453">                pickup_menu(o);</a>
<a name="ln1454">                break;</a>
<a name="ln1455">            }</a>
<a name="ln1456"> </a>
<a name="ln1457">            if (keyin == 'q' || key_is_escape(keyin))</a>
<a name="ln1458">            {</a>
<a name="ln1459">                canned_msg(MSG_OK);</a>
<a name="ln1460">                break;</a>
<a name="ln1461">            }</a>
<a name="ln1462"> </a>
<a name="ln1463">            if (keyin == 'y' || keyin == 'a')</a>
<a name="ln1464">            {</a>
<a name="ln1465">                int num_to_take = mitm[o].quantity;</a>
<a name="ln1466">                const iflags_t old_flags(mitm[o].flags);</a>
<a name="ln1467">                clear_item_pickup_flags(mitm[o]);</a>
<a name="ln1468"> </a>
<a name="ln1469">                // attempt to actually pick up the object.</a>
<a name="ln1470">                if (!move_item_to_inv(o, num_to_take))</a>
<a name="ln1471">                {</a>
<a name="ln1472">                    pickup_warning = &quot;You can't carry that many items.&quot;;</a>
<a name="ln1473">                    mitm[o].flags = old_flags;</a>
<a name="ln1474">                }</a>
<a name="ln1475">            }</a>
<a name="ln1476"> </a>
<a name="ln1477">            o = next;</a>
<a name="ln1478"> </a>
<a name="ln1479">            if (o == NON_ITEM &amp;&amp; keyin != 'y' &amp;&amp; keyin != 'a')</a>
<a name="ln1480">                canned_msg(MSG_OK);</a>
<a name="ln1481">        }</a>
<a name="ln1482"> </a>
<a name="ln1483">        // If there were no selectable items (all corpses, for example),</a>
<a name="ln1484">        // list them.</a>
<a name="ln1485">        if (!any_selectable)</a>
<a name="ln1486">        {</a>
<a name="ln1487">            for (stack_iterator si(you.pos(), true); si; ++si)</a>
<a name="ln1488">                mprf_nocap(&quot;%s&quot;, menu_colour_item_name(*si, DESC_A).c_str());</a>
<a name="ln1489">        }</a>
<a name="ln1490"> </a>
<a name="ln1491">        if (!pickup_warning.empty())</a>
<a name="ln1492">            mpr(pickup_warning);</a>
<a name="ln1493">    }</a>
<a name="ln1494">    if (you.last_pickup.empty())</a>
<a name="ln1495">        you.last_pickup = tmp_l_p;</a>
<a name="ln1496">}</a>
<a name="ln1497"> </a>
<a name="ln1498">bool is_stackable_item(const item_def &amp;item)</a>
<a name="ln1499">{</a>
<a name="ln1500">    if (!item.defined())</a>
<a name="ln1501">        return false;</a>
<a name="ln1502"> </a>
<a name="ln1503">    switch (item.base_type)</a>
<a name="ln1504">    {</a>
<a name="ln1505">        case OBJ_MISSILES:</a>
<a name="ln1506">        case OBJ_FOOD:</a>
<a name="ln1507">        case OBJ_SCROLLS:</a>
<a name="ln1508">        case OBJ_POTIONS:</a>
<a name="ln1509">        case OBJ_GOLD:</a>
<a name="ln1510">            return true;</a>
<a name="ln1511">        case OBJ_MISCELLANY:</a>
<a name="ln1512">            switch (item.sub_type)</a>
<a name="ln1513">            {</a>
<a name="ln1514">                case MISC_PHANTOM_MIRROR:</a>
<a name="ln1515">                case MISC_ZIGGURAT:</a>
<a name="ln1516">#if TAG_MAJOR_VERSION == 34</a>
<a name="ln1517">                case MISC_SACK_OF_SPIDERS:</a>
<a name="ln1518">#endif</a>
<a name="ln1519">                case MISC_BOX_OF_BEASTS:</a>
<a name="ln1520">                case MISC_TIN_OF_TREMORSTONES:</a>
<a name="ln1521">                    return true;</a>
<a name="ln1522">                default:</a>
<a name="ln1523">                    break;</a>
<a name="ln1524">            }</a>
<a name="ln1525">        default:</a>
<a name="ln1526">            break;</a>
<a name="ln1527">    }</a>
<a name="ln1528">    return false;</a>
<a name="ln1529">}</a>
<a name="ln1530"> </a>
<a name="ln1531">bool items_similar(const item_def &amp;item1, const item_def &amp;item2)</a>
<a name="ln1532">{</a>
<a name="ln1533">    // Base and sub-types must always be the same to stack.</a>
<a name="ln1534">    if (item1.base_type != item2.base_type || item1.sub_type != item2.sub_type)</a>
<a name="ln1535">        return false;</a>
<a name="ln1536"> </a>
<a name="ln1537">    if (item1.base_type == OBJ_GOLD || item1.base_type == OBJ_RUNES)</a>
<a name="ln1538">        return true;</a>
<a name="ln1539"> </a>
<a name="ln1540">    if (is_artefact(item1) != is_artefact(item2))</a>
<a name="ln1541">        return false;</a>
<a name="ln1542">    else if (is_artefact(item1)</a>
<a name="ln1543">             &amp;&amp; get_artefact_name(item1) != get_artefact_name(item2))</a>
<a name="ln1544">    {</a>
<a name="ln1545">        return false;</a>
<a name="ln1546">    }</a>
<a name="ln1547"> </a>
<a name="ln1548">    // Missiles with different egos shouldn't merge.</a>
<a name="ln1549">    if (item1.base_type == OBJ_MISSILES &amp;&amp; item1.brand != item2.brand)</a>
<a name="ln1550">        return false;</a>
<a name="ln1551"> </a>
<a name="ln1552">    // Don't merge trapping nets with other nets.</a>
<a name="ln1553">    if (item1.is_type(OBJ_MISSILES, MI_THROWING_NET)</a>
<a name="ln1554">        &amp;&amp; item1.net_placed != item2.net_placed)</a>
<a name="ln1555">    {</a>
<a name="ln1556">        return false;</a>
<a name="ln1557">    }</a>
<a name="ln1558"> </a>
<a name="ln1559">    if (item1.is_type(OBJ_FOOD, FOOD_CHUNK)</a>
<a name="ln1560">        &amp;&amp; determine_chunk_effect(item1) != determine_chunk_effect(item2))</a>
<a name="ln1561">    {</a>
<a name="ln1562">        return false;</a>
<a name="ln1563">    }</a>
<a name="ln1564"> </a>
<a name="ln1565"> </a>
<a name="ln1566">#define NO_MERGE_FLAGS (ISFLAG_MIMIC | ISFLAG_SUMMONED)</a>
<a name="ln1567">    if ((item1.flags &amp; NO_MERGE_FLAGS) != (item2.flags &amp; NO_MERGE_FLAGS))</a>
<a name="ln1568">        return false;</a>
<a name="ln1569"> </a>
<a name="ln1570">    // The inscriptions can differ if one of them is blank, but if they</a>
<a name="ln1571">    // are differing non-blank inscriptions then don't stack.</a>
<a name="ln1572">    if (item1.inscription != item2.inscription</a>
<a name="ln1573">        &amp;&amp; !item1.inscription.empty() &amp;&amp; !item2.inscription.empty())</a>
<a name="ln1574">    {</a>
<a name="ln1575">        return false;</a>
<a name="ln1576">    }</a>
<a name="ln1577"> </a>
<a name="ln1578">    return true;</a>
<a name="ln1579">}</a>
<a name="ln1580"> </a>
<a name="ln1581">bool items_stack(const item_def &amp;item1, const item_def &amp;item2)</a>
<a name="ln1582">{</a>
<a name="ln1583">    // Both items must be stackable.</a>
<a name="ln1584">    if (!is_stackable_item(item1) || !is_stackable_item(item2)</a>
<a name="ln1585">        || static_cast&lt;long long&gt;(item1.quantity) + item2.quantity</a>
<a name="ln1586">            &gt; numeric_limits&lt;decltype(item1.quantity)&gt;::max())</a>
<a name="ln1587">    {</a>
<a name="ln1588">        return false;</a>
<a name="ln1589">    }</a>
<a name="ln1590"> </a>
<a name="ln1591">    return items_similar(item1, item2)</a>
<a name="ln1592">        // Don't leak information when checking if an &quot;(unknown)&quot; shop item</a>
<a name="ln1593">        // matches an unidentified item in inventory.</a>
<a name="ln1594">        &amp;&amp; fully_identified(item1) == fully_identified(item2);</a>
<a name="ln1595">}</a>
<a name="ln1596"> </a>
<a name="ln1597">/**</a>
<a name="ln1598"> * Handles special cases involved in merging a specified number of items from</a>
<a name="ln1599"> * one stack into another.</a>
<a name="ln1600"> * Assumes that it's being called before the destination stack is incremented -</a>
<a name="ln1601"> * bugginess will occur if this order is reversed.</a>
<a name="ln1602"> * DOES NOT modify the original stack - the caller must handle any cleanup!</a>
<a name="ln1603"> *</a>
<a name="ln1604"> * @param source    The source from which items are being drawn.</a>
<a name="ln1605"> * @param dest      The stack into which items are being placed.</a>
<a name="ln1606"> * @param quant     The number of items to be added to the destination stack.</a>
<a name="ln1607"> * Defaults to the entirety of the source stack.</a>
<a name="ln1608"> */</a>
<a name="ln1609">void merge_item_stacks(const item_def &amp;source, item_def &amp;dest, int quant)</a>
<a name="ln1610">{</a>
<a name="ln1611">    if (quant == -1)</a>
<a name="ln1612">        quant = source.quantity;</a>
<a name="ln1613"> </a>
<a name="ln1614">    ASSERT_RANGE(quant, 0 + 1, source.quantity + 1);</a>
<a name="ln1615"> </a>
<a name="ln1616">    if (is_perishable_stack(source) &amp;&amp; is_perishable_stack(dest))</a>
<a name="ln1617">        merge_perishable_stacks(source, dest, quant);</a>
<a name="ln1618">}</a>
<a name="ln1619"> </a>
<a name="ln1620">static int _userdef_find_free_slot(const item_def &amp;i)</a>
<a name="ln1621">{</a>
<a name="ln1622">#ifdef CLUA_BINDINGS</a>
<a name="ln1623">    int slot = -1;</a>
<a name="ln1624">    if (!clua.callfn(&quot;c_assign_invletter&quot;, &quot;i&gt;d&quot;, &amp;i, &amp;slot))</a>
<a name="ln1625">        return -1;</a>
<a name="ln1626"> </a>
<a name="ln1627">    return slot;</a>
<a name="ln1628">#else</a>
<a name="ln1629">    return -1;</a>
<a name="ln1630">#endif</a>
<a name="ln1631">}</a>
<a name="ln1632"> </a>
<a name="ln1633">int find_free_slot(const item_def &amp;i)</a>
<a name="ln1634">{</a>
<a name="ln1635">#define slotisfree(s) \</a>
<a name="ln1636">            ((s) &gt;= 0 &amp;&amp; (s) &lt; ENDOFPACK &amp;&amp; !you.inv[s].defined())</a>
<a name="ln1637"> </a>
<a name="ln1638">    bool searchforward = false;</a>
<a name="ln1639">    // If we're doing Lua, see if there's a Lua function that can give</a>
<a name="ln1640">    // us a free slot.</a>
<a name="ln1641">    int slot = _userdef_find_free_slot(i);</a>
<a name="ln1642">    if (slot == -2 || Options.assign_item_slot == SS_FORWARD)</a>
<a name="ln1643">        searchforward = true;</a>
<a name="ln1644"> </a>
<a name="ln1645">    if (slotisfree(slot))</a>
<a name="ln1646">        return slot;</a>
<a name="ln1647"> </a>
<a name="ln1648">    // See if the item remembers where it's been. Lua code can play with</a>
<a name="ln1649">    // this field so be extra careful.</a>
<a name="ln1650">    if (isaalpha(i.slot))</a>
<a name="ln1651">        slot = letter_to_index(i.slot);</a>
<a name="ln1652"> </a>
<a name="ln1653">    if (slotisfree(slot))</a>
<a name="ln1654">        return slot;</a>
<a name="ln1655"> </a>
<a name="ln1656">    FixedBitVector&lt;ENDOFPACK&gt; disliked;</a>
<a name="ln1657">    if (i.base_type == OBJ_FOOD)</a>
<a name="ln1658">        disliked.set('e' - 'a'), disliked.set('y' - 'a');</a>
<a name="ln1659">    else if (i.base_type == OBJ_POTIONS)</a>
<a name="ln1660">        disliked.set('y' - 'a');</a>
<a name="ln1661"> </a>
<a name="ln1662">    if (!searchforward)</a>
<a name="ln1663">    {</a>
<a name="ln1664">        // This is the new default free slot search. We look for the last</a>
<a name="ln1665">        // available slot that does not leave a gap in the inventory.</a>
<a name="ln1666">        for (slot = ENDOFPACK - 1; slot &gt;= 0; --slot)</a>
<a name="ln1667">        {</a>
<a name="ln1668">            if (you.inv[slot].defined())</a>
<a name="ln1669">            {</a>
<a name="ln1670">                if (slot + 1 &lt; ENDOFPACK &amp;&amp; !you.inv[slot + 1].defined()</a>
<a name="ln1671">                    &amp;&amp; !disliked[slot + 1])</a>
<a name="ln1672">                {</a>
<a name="ln1673">                    return slot + 1;</a>
<a name="ln1674">                }</a>
<a name="ln1675">            }</a>
<a name="ln1676">            else</a>
<a name="ln1677">            {</a>
<a name="ln1678">                if (slot + 1 &lt; ENDOFPACK &amp;&amp; you.inv[slot + 1].defined()</a>
<a name="ln1679">                    &amp;&amp; !disliked[slot])</a>
<a name="ln1680">                {</a>
<a name="ln1681">                    return slot;</a>
<a name="ln1682">                }</a>
<a name="ln1683">            }</a>
<a name="ln1684">        }</a>
<a name="ln1685">    }</a>
<a name="ln1686"> </a>
<a name="ln1687">    // Either searchforward is true, or search backwards failed and</a>
<a name="ln1688">    // we re-try searching the opposite direction.</a>
<a name="ln1689"> </a>
<a name="ln1690">    int badslot = -1;</a>
<a name="ln1691">    // Return first free slot</a>
<a name="ln1692">    for (slot = 0; slot &lt; ENDOFPACK; ++slot)</a>
<a name="ln1693">        if (!you.inv[slot].defined())</a>
<a name="ln1694">        {</a>
<a name="ln1695">            if (disliked[slot])</a>
<a name="ln1696">                badslot = slot;</a>
<a name="ln1697">            else</a>
<a name="ln1698">                return slot;</a>
<a name="ln1699">        }</a>
<a name="ln1700"> </a>
<a name="ln1701">    // If the least preferred slot is the only choice, so be it.</a>
<a name="ln1702">    return badslot;</a>
<a name="ln1703">#undef slotisfree</a>
<a name="ln1704">}</a>
<a name="ln1705"> </a>
<a name="ln1706">static void _got_item(item_def&amp; item)</a>
<a name="ln1707">{</a>
<a name="ln1708">    seen_item(item);</a>
<a name="ln1709">    shopping_list.cull_identical_items(item);</a>
<a name="ln1710">    item.flags |= ISFLAG_HANDLED;</a>
<a name="ln1711"> </a>
<a name="ln1712">    if (item.props.exists(&quot;needs_autopickup&quot;))</a>
<a name="ln1713">        item.props.erase(&quot;needs_autopickup&quot;);</a>
<a name="ln1714">}</a>
<a name="ln1715"> </a>
<a name="ln1716">void get_gold(const item_def&amp; item, int quant, bool quiet)</a>
<a name="ln1717">{</a>
<a name="ln1718">    you.attribute[ATTR_GOLD_FOUND] += quant;</a>
<a name="ln1719"> </a>
<a name="ln1720">    if (you_worship(GOD_ZIN))</a>
<a name="ln1721">        quant -= zin_tithe(item, quant, quiet);</a>
<a name="ln1722">    if (quant &lt;= 0)</a>
<a name="ln1723">        return;</a>
<a name="ln1724">    you.add_gold(quant);</a>
<a name="ln1725"> </a>
<a name="ln1726">    if (!quiet)</a>
<a name="ln1727">    {</a>
<a name="ln1728">        const string gain = quant != you.gold</a>
<a name="ln1729">                            ? make_stringf(&quot; (gained %d)&quot;, quant)</a>
<a name="ln1730">                            : &quot;&quot;;</a>
<a name="ln1731"> </a>
<a name="ln1732">        mprf(&quot;You now have %d gold piece%s%s.&quot;,</a>
<a name="ln1733">             you.gold, you.gold != 1 ? &quot;s&quot; : &quot;&quot;, gain.c_str());</a>
<a name="ln1734">        learned_something_new(HINT_SEEN_GOLD);</a>
<a name="ln1735">    }</a>
<a name="ln1736">}</a>
<a name="ln1737"> </a>
<a name="ln1738">void note_inscribe_item(item_def &amp;item)</a>
<a name="ln1739">{</a>
<a name="ln1740">    _autoinscribe_item(item);</a>
<a name="ln1741">    _origin_freeze(item);</a>
<a name="ln1742">    _check_note_item(item);</a>
<a name="ln1743">}</a>
<a name="ln1744"> </a>
<a name="ln1745">static bool _put_item_in_inv(item_def&amp; it, int quant_got, bool quiet, bool&amp; put_in_inv)</a>
<a name="ln1746">{</a>
<a name="ln1747">    put_in_inv = false;</a>
<a name="ln1748">    if (item_is_stationary(it))</a>
<a name="ln1749">    {</a>
<a name="ln1750">        if (!quiet)</a>
<a name="ln1751">            mpr(&quot;You can't pick that up.&quot;);</a>
<a name="ln1752">        // Fake a successful pickup (return 1), so we can continue to</a>
<a name="ln1753">        // pick up anything else that might be on this square.</a>
<a name="ln1754">        return true;</a>
<a name="ln1755">    }</a>
<a name="ln1756"> </a>
<a name="ln1757">    // sanity</a>
<a name="ln1758">    if (quant_got &gt; it.quantity || quant_got &lt;= 0)</a>
<a name="ln1759">        quant_got = it.quantity;</a>
<a name="ln1760"> </a>
<a name="ln1761">    // attempt to put the item into your inventory.</a>
<a name="ln1762">    int inv_slot;</a>
<a name="ln1763">    if (_merge_items_into_inv(it, quant_got, inv_slot, quiet))</a>
<a name="ln1764">    {</a>
<a name="ln1765">        put_in_inv = true;</a>
<a name="ln1766">        // if you succeeded, actually reduce the number in the original stack</a>
<a name="ln1767">        if (quant_got != it.quantity &amp;&amp; is_perishable_stack(it))</a>
<a name="ln1768">            for (int i = 0; i &lt; quant_got; i++)</a>
<a name="ln1769">                remove_oldest_perishable_item(it);</a>
<a name="ln1770"> </a>
<a name="ln1771">        // cleanup items that ended up in an inventory slot (not gold, etc)</a>
<a name="ln1772">        if (inv_slot != -1)</a>
<a name="ln1773">            _got_item(you.inv[inv_slot]);</a>
<a name="ln1774">        else if (it.base_type == OBJ_BOOKS)</a>
<a name="ln1775">            _got_item(it);</a>
<a name="ln1776">        _check_note_item(inv_slot == -1 ? it : you.inv[inv_slot]);</a>
<a name="ln1777">        return true;</a>
<a name="ln1778">    }</a>
<a name="ln1779"> </a>
<a name="ln1780">    return false;</a>
<a name="ln1781">}</a>
<a name="ln1782"> </a>
<a name="ln1783"> </a>
<a name="ln1784">// Currently only used for moving shop items into inventory, since they are</a>
<a name="ln1785">// not in mitm. This doesn't work with partial pickup, because that requires</a>
<a name="ln1786">// an mitm slot...</a>
<a name="ln1787">bool move_item_to_inv(item_def&amp; item)</a>
<a name="ln1788">{</a>
<a name="ln1789">    bool junk;</a>
<a name="ln1790">    return _put_item_in_inv(item, item.quantity, false, junk);</a>
<a name="ln1791">}</a>
<a name="ln1792"> </a>
<a name="ln1793">/**</a>
<a name="ln1794"> * Move the given item and quantity to the player's inventory.</a>
<a name="ln1795"> *</a>
<a name="ln1796"> * @param obj The item index in mitm.</a>
<a name="ln1797"> * @param quant_got The quantity of this item to move.</a>
<a name="ln1798"> * @param quiet If true, most messages notifying the player of item pickup (or</a>
<a name="ln1799"> *              item pickup failure) aren't printed.</a>
<a name="ln1800"> * @returns false if items failed to be picked up because of a full inventory,</a>
<a name="ln1801"> *          true otherwise (even if nothing was picked up).</a>
<a name="ln1802">*/</a>
<a name="ln1803">bool move_item_to_inv(int obj, int quant_got, bool quiet)</a>
<a name="ln1804">{</a>
<a name="ln1805">    item_def &amp;it = mitm[obj];</a>
<a name="ln1806">    const coord_def old_item_pos = it.pos;</a>
<a name="ln1807"> </a>
<a name="ln1808">    bool actually_went_in = false;</a>
<a name="ln1809">    const bool keep_going = _put_item_in_inv(it, quant_got, quiet, actually_went_in);</a>
<a name="ln1810"> </a>
<a name="ln1811">    if ((it.base_type == OBJ_RUNES || item_is_orb(it) || in_bounds(old_item_pos))</a>
<a name="ln1812">        &amp;&amp; actually_went_in)</a>
<a name="ln1813">    {</a>
<a name="ln1814">        dungeon_events.fire_position_event(dgn_event(DET_ITEM_PICKUP,</a>
<a name="ln1815">                                                     you.pos(), 0, obj,</a>
<a name="ln1816">                                                     -1),</a>
<a name="ln1817">                                           you.pos());</a>
<a name="ln1818"> </a>
<a name="ln1819">        // XXX: Waiting until now to decrement the quantity may give Windows</a>
<a name="ln1820">        // tiles players the opportunity to close the window and duplicate the</a>
<a name="ln1821">        // item (a variant of bug #6486). However, we can't decrement the</a>
<a name="ln1822">        // quantity before firing the position event, because the latter needs</a>
<a name="ln1823">        // the object's index.</a>
<a name="ln1824">        dec_mitm_item_quantity(obj, quant_got);</a>
<a name="ln1825"> </a>
<a name="ln1826">        you.turn_is_over = true;</a>
<a name="ln1827">    }</a>
<a name="ln1828"> </a>
<a name="ln1829">    return keep_going;</a>
<a name="ln1830">}</a>
<a name="ln1831"> </a>
<a name="ln1832">static void _get_book(const item_def&amp; it, bool quiet, bool allow_auto_hide)</a>
<a name="ln1833">{</a>
<a name="ln1834">    vector&lt;spell_type&gt; spells;</a>
<a name="ln1835">    if (!quiet)</a>
<a name="ln1836">        mprf(&quot;You pick up %s and begin reading...&quot;, it.name(DESC_A).c_str());</a>
<a name="ln1837">    for (spell_type st : spells_in_book(it))</a>
<a name="ln1838">    {</a>
<a name="ln1839">        if (!you.spell_library[st])</a>
<a name="ln1840">        {</a>
<a name="ln1841">            you.spell_library.set(st, true);</a>
<a name="ln1842">            bool memorise = you_can_memorise(st);</a>
<a name="ln1843">            if (memorise)</a>
<a name="ln1844">                spells.push_back(st);</a>
<a name="ln1845">            if (!memorise || (Options.auto_hide_spells &amp;&amp; allow_auto_hide))</a>
<a name="ln1846">                you.hidden_spells.set(st, true);</a>
<a name="ln1847">        }</a>
<a name="ln1848">    }</a>
<a name="ln1849">    if (!quiet)</a>
<a name="ln1850">    {</a>
<a name="ln1851">        if (!spells.empty())</a>
<a name="ln1852">        {</a>
<a name="ln1853">            vector&lt;string&gt; spellnames(spells.size());</a>
<a name="ln1854">            transform(spells.begin(), spells.end(), spellnames.begin(), spell_title);</a>
<a name="ln1855">            mprf(&quot;You add the spell%s %s to your library.&quot;,</a>
<a name="ln1856">                 spellnames.size() &gt; 1 ? &quot;s&quot; : &quot;&quot;,</a>
<a name="ln1857">                 comma_separated_line(spellnames.begin(),</a>
<a name="ln1858">                                      spellnames.end()).c_str());</a>
<a name="ln1859">        }</a>
<a name="ln1860">        else</a>
<a name="ln1861">            mpr(&quot;Unfortunately, it added no spells to the library.&quot;);</a>
<a name="ln1862">    }</a>
<a name="ln1863">    shopping_list.spells_added_to_library(spells, quiet);</a>
<a name="ln1864">}</a>
<a name="ln1865"> </a>
<a name="ln1866">// Adds all books in the player's inventory to library.</a>
<a name="ln1867">// Declared here for use by tags to load old saves.</a>
<a name="ln1868">// Outside of loading old saves, only used at character creation.</a>
<a name="ln1869">void add_held_books_to_library()</a>
<a name="ln1870">{</a>
<a name="ln1871">    for (item_def&amp; it : you.inv)</a>
<a name="ln1872">    {</a>
<a name="ln1873">        if (it.base_type == OBJ_BOOKS &amp;&amp; it.sub_type != BOOK_MANUAL)</a>
<a name="ln1874">        {</a>
<a name="ln1875">            _get_book(it, true, false);</a>
<a name="ln1876">            destroy_item(it);</a>
<a name="ln1877">        }</a>
<a name="ln1878">    }</a>
<a name="ln1879">}</a>
<a name="ln1880"> </a>
<a name="ln1881">/**</a>
<a name="ln1882"> * Place a rune into the player's inventory.</a>
<a name="ln1883"> *</a>
<a name="ln1884"> * @param it      The item (rune) to pick up.</a>
<a name="ln1885"> * @param quiet   Whether to suppress (most?) messages.</a>
<a name="ln1886"> */</a>
<a name="ln1887">static void _get_rune(const item_def&amp; it, bool quiet)</a>
<a name="ln1888">{</a>
<a name="ln1889">    if (!you.runes[it.sub_type])</a>
<a name="ln1890">        you.runes.set(it.sub_type);</a>
<a name="ln1891"> </a>
<a name="ln1892">    if (!quiet)</a>
<a name="ln1893">    {</a>
<a name="ln1894">        flash_view_delay(UA_PICKUP, rune_colour(it.sub_type), 300);</a>
<a name="ln1895">        mprf(&quot;You pick up the %s rune and feel its power.&quot;,</a>
<a name="ln1896">             rune_type_name(it.sub_type));</a>
<a name="ln1897">        int nrunes = runes_in_pack();</a>
<a name="ln1898">        if (nrunes &gt;= you.obtainable_runes)</a>
<a name="ln1899">            mpr(&quot;You have collected all the runes! Now go and win!&quot;);</a>
<a name="ln1900">        else if (nrunes == ZOT_ENTRY_RUNES)</a>
<a name="ln1901">        {</a>
<a name="ln1902">            // might be inappropriate in new Sprints, please change it then</a>
<a name="ln1903">            mprf(&quot;%d runes! That's enough to enter the realm of Zot.&quot;,</a>
<a name="ln1904">                 nrunes);</a>
<a name="ln1905">        }</a>
<a name="ln1906">        else if (nrunes &gt; 1)</a>
<a name="ln1907">            mprf(&quot;You now have %d runes.&quot;, nrunes);</a>
<a name="ln1908"> </a>
<a name="ln1909">        mpr(&quot;Press } to see all the runes you have collected.&quot;);</a>
<a name="ln1910">    }</a>
<a name="ln1911"> </a>
<a name="ln1912">    if (it.sub_type == RUNE_ABYSSAL)</a>
<a name="ln1913">        mpr(&quot;You feel the abyssal rune guiding you out of this place.&quot;);</a>
<a name="ln1914">}</a>
<a name="ln1915"> </a>
<a name="ln1916">/**</a>
<a name="ln1917"> * Place the Orb of Zot into the player's inventory.</a>
<a name="ln1918"> */</a>
<a name="ln1919">static void _get_orb()</a>
<a name="ln1920">{</a>
<a name="ln1921">    run_animation(ANIMATION_ORB, UA_PICKUP);</a>
<a name="ln1922"> </a>
<a name="ln1923">    mprf(MSGCH_ORB, &quot;You pick up the Orb of Zot!&quot;);</a>
<a name="ln1924"> </a>
<a name="ln1925">    env.orb_pos = you.pos(); // can be wrong in wizmode</a>
<a name="ln1926">    orb_pickup_noise(you.pos(), 30);</a>
<a name="ln1927"> </a>
<a name="ln1928">    start_orb_run(CHAPTER_ESCAPING, &quot;Now all you have to do is get back out &quot;</a>
<a name="ln1929">                                    &quot;of the dungeon!&quot;);</a>
<a name="ln1930">}</a>
<a name="ln1931"> </a>
<a name="ln1932">/**</a>
<a name="ln1933"> * Attempt to merge a stackable item into an existing stack in the player's</a>
<a name="ln1934"> * inventory.</a>
<a name="ln1935"> *</a>
<a name="ln1936"> * @param it[in]            The stack to merge.</a>
<a name="ln1937"> * @param quant_got         The quantity of this item to place.</a>
<a name="ln1938"> * @param inv_slot[out]     The inventory slot the item was placed in. -1 if</a>
<a name="ln1939"> * not placed.</a>
<a name="ln1940"> * @param quiet             Whether to suppress pickup messages.</a>
<a name="ln1941"> */</a>
<a name="ln1942">static bool _merge_stackable_item_into_inv(const item_def &amp;it, int quant_got,</a>
<a name="ln1943">                                           int &amp;inv_slot, bool quiet)</a>
<a name="ln1944">{</a>
<a name="ln1945">    for (inv_slot = 0; inv_slot &lt; ENDOFPACK; inv_slot++)</a>
<a name="ln1946">    {</a>
<a name="ln1947">        if (!items_stack(you.inv[inv_slot], it))</a>
<a name="ln1948">            continue;</a>
<a name="ln1949"> </a>
<a name="ln1950">        // If the object on the ground is inscribed, but not</a>
<a name="ln1951">        // the one in inventory, then the inventory object</a>
<a name="ln1952">        // picks up the other's inscription.</a>
<a name="ln1953">        if (!(it.inscription).empty()</a>
<a name="ln1954">            &amp;&amp; you.inv[inv_slot].inscription.empty())</a>
<a name="ln1955">        {</a>
<a name="ln1956">            you.inv[inv_slot].inscription = it.inscription;</a>
<a name="ln1957">        }</a>
<a name="ln1958"> </a>
<a name="ln1959">        merge_item_stacks(it, you.inv[inv_slot], quant_got);</a>
<a name="ln1960">        inc_inv_item_quantity(inv_slot, quant_got);</a>
<a name="ln1961">        you.last_pickup[inv_slot] = quant_got;</a>
<a name="ln1962"> </a>
<a name="ln1963">        if (!quiet)</a>
<a name="ln1964">        {</a>
<a name="ln1965">#ifdef USE_SOUND</a>
<a name="ln1966">            parse_sound(PICKUP_SOUND);</a>
<a name="ln1967">#endif</a>
<a name="ln1968">            mprf_nocap(&quot;%s (gained %d)&quot;,</a>
<a name="ln1969">                        menu_colour_item_name(you.inv[inv_slot],</a>
<a name="ln1970">                                                    DESC_INVENTORY).c_str(),</a>
<a name="ln1971">                        quant_got);</a>
<a name="ln1972">        }</a>
<a name="ln1973"> </a>
<a name="ln1974">        return true;</a>
<a name="ln1975">    }</a>
<a name="ln1976"> </a>
<a name="ln1977">    inv_slot = -1;</a>
<a name="ln1978">    return false;</a>
<a name="ln1979">}</a>
<a name="ln1980"> </a>
<a name="ln1981">/**</a>
<a name="ln1982"> * Attempt to merge a wands charges into an existing wand of the same type in</a>
<a name="ln1983"> * inventory.</a>
<a name="ln1984"> *</a>
<a name="ln1985"> * @param it[in]            The wand to merge.</a>
<a name="ln1986"> * @param inv_slot[out]     The inventory slot the wand was placed in. -1 if</a>
<a name="ln1987"> * not placed.</a>
<a name="ln1988"> * @param quiet             Whether to suppress pickup messages.</a>
<a name="ln1989"> */</a>
<a name="ln1990">static bool _merge_wand_charges(const item_def &amp;it, int &amp;inv_slot, bool quiet)</a>
<a name="ln1991">{</a>
<a name="ln1992">    for (inv_slot = 0; inv_slot &lt; ENDOFPACK; inv_slot++)</a>
<a name="ln1993">    {</a>
<a name="ln1994">        if (you.inv[inv_slot].base_type != OBJ_WANDS</a>
<a name="ln1995">            || you.inv[inv_slot].sub_type != it.sub_type)</a>
<a name="ln1996">        {</a>
<a name="ln1997">            continue;</a>
<a name="ln1998">        }</a>
<a name="ln1999"> </a>
<a name="ln2000">        you.inv[inv_slot].charges += it.charges;</a>
<a name="ln2001"> </a>
<a name="ln2002">        if (!quiet)</a>
<a name="ln2003">        {</a>
<a name="ln2004">#ifdef USE_SOUND</a>
<a name="ln2005">            parse_sound(PICKUP_SOUND);</a>
<a name="ln2006">#endif</a>
<a name="ln2007">            mprf_nocap(&quot;%s (gained %d charge%s)&quot;,</a>
<a name="ln2008">                        menu_colour_item_name(you.inv[inv_slot],</a>
<a name="ln2009">                                                    DESC_INVENTORY).c_str(),</a>
<a name="ln2010">                        it.charges, it.charges == 1 ? &quot;&quot; : &quot;s&quot;);</a>
<a name="ln2011">        }</a>
<a name="ln2012"> </a>
<a name="ln2013">        return true;</a>
<a name="ln2014">    }</a>
<a name="ln2015"> </a>
<a name="ln2016">    inv_slot = -1;</a>
<a name="ln2017">    return false;</a>
<a name="ln2018">}</a>
<a name="ln2019"> </a>
<a name="ln2020">/**</a>
<a name="ln2021"> * Maybe move an item to the slot given by the item_slot option.</a>
<a name="ln2022"> *</a>
<a name="ln2023"> * @param[in] item the item to be checked. Note that any references to this</a>
<a name="ln2024"> *                 item will be invalidated by the swap_inv_slots call!</a>
<a name="ln2025"> * @returns the new location of the item if it was moved, null otherwise.</a>
<a name="ln2026"> */</a>
<a name="ln2027">item_def *auto_assign_item_slot(item_def&amp; item)</a>
<a name="ln2028">{</a>
<a name="ln2029">    if (!item.defined())</a>
<a name="ln2030">        return nullptr;</a>
<a name="ln2031">    if (!in_inventory(item))</a>
<a name="ln2032">        return nullptr;</a>
<a name="ln2033"> </a>
<a name="ln2034">    int newslot = -1;</a>
<a name="ln2035">    bool overwrite = true;</a>
<a name="ln2036">    // check to see whether we've chosen an automatic label:</a>
<a name="ln2037">    for (auto&amp; mapping : Options.auto_item_letters)</a>
<a name="ln2038">    {</a>
<a name="ln2039">        if (!mapping.first.matches(item.name(DESC_QUALNAME))</a>
<a name="ln2040">            &amp;&amp; !mapping.first.matches(item_prefix(item)</a>
<a name="ln2041">                                      + &quot; &quot; + item.name(DESC_A)))</a>
<a name="ln2042">        {</a>
<a name="ln2043">            continue;</a>
<a name="ln2044">        }</a>
<a name="ln2045">        for (char i : mapping.second)</a>
<a name="ln2046">        {</a>
<a name="ln2047">            if (i == '+')</a>
<a name="ln2048">                overwrite = true;</a>
<a name="ln2049">            else if (i == '-')</a>
<a name="ln2050">                overwrite = false;</a>
<a name="ln2051">            else if (isaalpha(i))</a>
<a name="ln2052">            {</a>
<a name="ln2053">                const int index = letter_to_index(i);</a>
<a name="ln2054">                auto &amp;iitem = you.inv[index];</a>
<a name="ln2055"> </a>
<a name="ln2056">                // Slot is empty, or overwrite is on and the rule doesn't</a>
<a name="ln2057">                // match the item already there.</a>
<a name="ln2058">                if (!iitem.defined()</a>
<a name="ln2059">                    || overwrite</a>
<a name="ln2060">                       &amp;&amp; !mapping.first.matches(iitem.name(DESC_QUALNAME))</a>
<a name="ln2061">                       &amp;&amp; !mapping.first.matches(item_prefix(iitem)</a>
<a name="ln2062">                                                 + &quot; &quot; + iitem.name(DESC_A)))</a>
<a name="ln2063">                {</a>
<a name="ln2064">                    newslot = index;</a>
<a name="ln2065">                    break;</a>
<a name="ln2066">                }</a>
<a name="ln2067">            }</a>
<a name="ln2068">        }</a>
<a name="ln2069">        if (newslot != -1 &amp;&amp; newslot != item.link)</a>
<a name="ln2070">        {</a>
<a name="ln2071">            swap_inv_slots(item.link, newslot, you.num_turns);</a>
<a name="ln2072">            return &amp;you.inv[newslot];</a>
<a name="ln2073">        }</a>
<a name="ln2074">    }</a>
<a name="ln2075">    return nullptr;</a>
<a name="ln2076">}</a>
<a name="ln2077"> </a>
<a name="ln2078">/**</a>
<a name="ln2079"> * Move the given item and quantity to a free slot in the player's inventory.</a>
<a name="ln2080"> * If the item_slot option tells us to put it in a specific slot, it will move</a>
<a name="ln2081"> * there and push out the item that was in it before instead.</a>
<a name="ln2082"> *</a>
<a name="ln2083"> * @param it[in]          The item to be placed into the player's inventory.</a>
<a name="ln2084"> * @param quant_got       The quantity of this item to place.</a>
<a name="ln2085"> * @param quiet           Suppresses pickup messages.</a>
<a name="ln2086"> * @return                The inventory slot the item was placed in.</a>
<a name="ln2087"> */</a>
<a name="ln2088">static int _place_item_in_free_slot(item_def &amp;it, int quant_got,</a>
<a name="ln2089">                                    bool quiet)</a>
<a name="ln2090">{</a>
<a name="ln2091">    int freeslot = find_free_slot(it);</a>
<a name="ln2092">    ASSERT_RANGE(freeslot, 0, ENDOFPACK);</a>
<a name="ln2093">    ASSERT(!you.inv[freeslot].defined());</a>
<a name="ln2094"> </a>
<a name="ln2095">    item_def &amp;item = you.inv[freeslot];</a>
<a name="ln2096">    // Copy item.</a>
<a name="ln2097">    item          = it;</a>
<a name="ln2098">    item.link     = freeslot;</a>
<a name="ln2099">    item.quantity = quant_got;</a>
<a name="ln2100">    item.slot     = index_to_letter(item.link);</a>
<a name="ln2101">    item.pos = ITEM_IN_INVENTORY;</a>
<a name="ln2102">    // Remove &quot;unobtainable&quot; as it was just proven false.</a>
<a name="ln2103">    item.flags &amp;= ~ISFLAG_UNOBTAINABLE;</a>
<a name="ln2104"> </a>
<a name="ln2105">    god_id_item(item);</a>
<a name="ln2106">    if (item.base_type == OBJ_WANDS)</a>
<a name="ln2107">    {</a>
<a name="ln2108">        set_ident_type(item, true);</a>
<a name="ln2109">        set_ident_flags(item, ISFLAG_KNOW_PLUSES);</a>
<a name="ln2110">    }</a>
<a name="ln2111"> </a>
<a name="ln2112">    maybe_identify_base_type(item);</a>
<a name="ln2113">    if (item.base_type == OBJ_BOOKS)</a>
<a name="ln2114">        set_ident_flags(item, ISFLAG_IDENT_MASK);</a>
<a name="ln2115"> </a>
<a name="ln2116">    // Normalize ration tile in inventory</a>
<a name="ln2117">    if (item.base_type == OBJ_FOOD &amp;&amp; item.sub_type == FOOD_RATION)</a>
<a name="ln2118">    {</a>
<a name="ln2119">        item.props[&quot;item_tile_name&quot;] = &quot;food_ration_inventory&quot;;</a>
<a name="ln2120">        bind_item_tile(item);</a>
<a name="ln2121">    }</a>
<a name="ln2122"> </a>
<a name="ln2123">    note_inscribe_item(item);</a>
<a name="ln2124"> </a>
<a name="ln2125">    // avoid blood potion timer/stack size mismatch</a>
<a name="ln2126">    if (quant_got != it.quantity &amp;&amp; is_perishable_stack(it))</a>
<a name="ln2127">        remove_newest_perishable_item(item);</a>
<a name="ln2128"> </a>
<a name="ln2129">    if (crawl_state.game_is_hints())</a>
<a name="ln2130">    {</a>
<a name="ln2131">        taken_new_item(item.base_type);</a>
<a name="ln2132">        if (is_artefact(item))</a>
<a name="ln2133">            learned_something_new(HINT_SEEN_RANDART);</a>
<a name="ln2134">    }</a>
<a name="ln2135"> </a>
<a name="ln2136">    you.m_quiver.on_inv_quantity_changed(freeslot, quant_got);</a>
<a name="ln2137">    you.last_pickup[item.link] = quant_got;</a>
<a name="ln2138">    item_skills(item, you.start_train);</a>
<a name="ln2139"> </a>
<a name="ln2140">    if (const item_def* newitem = auto_assign_item_slot(item))</a>
<a name="ln2141">        return newitem-&gt;link;</a>
<a name="ln2142">    else if (!quiet)</a>
<a name="ln2143">    {</a>
<a name="ln2144">#ifdef USE_SOUND</a>
<a name="ln2145">        parse_sound(PICKUP_SOUND);</a>
<a name="ln2146">#endif</a>
<a name="ln2147">        mprf_nocap(&quot;%s&quot;, menu_colour_item_name(item, DESC_INVENTORY).c_str());</a>
<a name="ln2148">    }</a>
<a name="ln2149"> </a>
<a name="ln2150">    return item.link;</a>
<a name="ln2151">}</a>
<a name="ln2152"> </a>
<a name="ln2153">/**</a>
<a name="ln2154"> * Move the given item and quantity to the player's inventory.</a>
<a name="ln2155"> * DOES NOT change the original item; the caller must handle any cleanup!</a>
<a name="ln2156"> *</a>
<a name="ln2157"> * @param it[in]          The item to be placed into the player's inventory.</a>
<a name="ln2158"> * @param quant_got       The quantity of this item to place.</a>
<a name="ln2159"> * @param inv_slot[out]   The inventory slot the item was placed in. -1 if</a>
<a name="ln2160"> * not placed.</a>
<a name="ln2161"> * @param quiet If true, most messages notifying the player of item pickup (or</a>
<a name="ln2162"> *              item pickup failure) aren't printed.</a>
<a name="ln2163"> * @return Whether something was successfully picked up.</a>
<a name="ln2164"> */</a>
<a name="ln2165">static bool _merge_items_into_inv(item_def &amp;it, int quant_got,</a>
<a name="ln2166">                                  int &amp;inv_slot, bool quiet)</a>
<a name="ln2167">{</a>
<a name="ln2168">    inv_slot = -1;</a>
<a name="ln2169"> </a>
<a name="ln2170">    // sanity</a>
<a name="ln2171">    if (quant_got &gt; it.quantity || quant_got &lt;= 0)</a>
<a name="ln2172">        quant_got = it.quantity;</a>
<a name="ln2173"> </a>
<a name="ln2174">    // Gold has no mass, so we handle it first.</a>
<a name="ln2175">    if (it.base_type == OBJ_GOLD)</a>
<a name="ln2176">    {</a>
<a name="ln2177">        get_gold(it, quant_got, quiet);</a>
<a name="ln2178">        return true;</a>
<a name="ln2179">    }</a>
<a name="ln2180">    if (it.base_type == OBJ_BOOKS &amp;&amp; it.sub_type != BOOK_MANUAL)</a>
<a name="ln2181">    {</a>
<a name="ln2182">        _get_book(it, quiet, true);</a>
<a name="ln2183">        return true;</a>
<a name="ln2184">    }</a>
<a name="ln2185">    // Runes are also massless.</a>
<a name="ln2186">    if (it.base_type == OBJ_RUNES)</a>
<a name="ln2187">    {</a>
<a name="ln2188">        _get_rune(it, quiet);</a>
<a name="ln2189">        return true;</a>
<a name="ln2190">    }</a>
<a name="ln2191">    // The Orb is also handled specially.</a>
<a name="ln2192">    if (item_is_orb(it))</a>
<a name="ln2193">    {</a>
<a name="ln2194">        _get_orb();</a>
<a name="ln2195">        return true;</a>
<a name="ln2196">    }</a>
<a name="ln2197"> </a>
<a name="ln2198">    // attempt to merge into an existing stack, if possible</a>
<a name="ln2199">    if (is_stackable_item(it)</a>
<a name="ln2200">        &amp;&amp; _merge_stackable_item_into_inv(it, quant_got, inv_slot, quiet))</a>
<a name="ln2201">    {</a>
<a name="ln2202">        return true;</a>
<a name="ln2203">    }</a>
<a name="ln2204"> </a>
<a name="ln2205">    // attempt to merge into an existing stack, if possible</a>
<a name="ln2206">    if (it.base_type == OBJ_WANDS</a>
<a name="ln2207">        &amp;&amp; _merge_wand_charges(it, inv_slot, quiet))</a>
<a name="ln2208">    {</a>
<a name="ln2209">        quant_got = 1;</a>
<a name="ln2210">        return true;</a>
<a name="ln2211">    }</a>
<a name="ln2212"> </a>
<a name="ln2213">    // Can't combine, check for slot space.</a>
<a name="ln2214">    if (inv_count() &gt;= ENDOFPACK)</a>
<a name="ln2215">        return false;</a>
<a name="ln2216"> </a>
<a name="ln2217">    inv_slot = _place_item_in_free_slot(it, quant_got, quiet);</a>
<a name="ln2218">    return true;</a>
<a name="ln2219">}</a>
<a name="ln2220"> </a>
<a name="ln2221">void mark_items_non_pickup_at(const coord_def &amp;pos)</a>
<a name="ln2222">{</a>
<a name="ln2223">    int item = igrd(pos);</a>
<a name="ln2224">    while (item != NON_ITEM)</a>
<a name="ln2225">    {</a>
<a name="ln2226">        mitm[item].flags |= ISFLAG_DROPPED;</a>
<a name="ln2227">        mitm[item].flags &amp;= ~ISFLAG_THROWN;</a>
<a name="ln2228">        item = mitm[item].link;</a>
<a name="ln2229">    }</a>
<a name="ln2230">}</a>
<a name="ln2231"> </a>
<a name="ln2232">void clear_item_pickup_flags(item_def &amp;item)</a>
<a name="ln2233">{</a>
<a name="ln2234">    item.flags &amp;= ~(ISFLAG_THROWN | ISFLAG_DROPPED | ISFLAG_NO_PICKUP);</a>
<a name="ln2235">}</a>
<a name="ln2236"> </a>
<a name="ln2237">// Move gold to the the top of a pile if following Gozag.</a>
<a name="ln2238">static void _gozag_move_gold_to_top(const coord_def p)</a>
<a name="ln2239">{</a>
<a name="ln2240">    if (have_passive(passive_t::detect_gold))</a>
<a name="ln2241">    {</a>
<a name="ln2242">        for (int gold = igrd(p); gold != NON_ITEM;</a>
<a name="ln2243">             gold = mitm[gold].link)</a>
<a name="ln2244">        {</a>
<a name="ln2245">            if (mitm[gold].base_type == OBJ_GOLD)</a>
<a name="ln2246">            {</a>
<a name="ln2247">                unlink_item(gold);</a>
<a name="ln2248">                move_item_to_grid(&amp;gold, p, true);</a>
<a name="ln2249">                break;</a>
<a name="ln2250">            }</a>
<a name="ln2251">        }</a>
<a name="ln2252">    }</a>
<a name="ln2253">}</a>
<a name="ln2254"> </a>
<a name="ln2255">// Moves mitm[obj] to p... will modify the value of obj to</a>
<a name="ln2256">// be the index of the final object (possibly different).</a>
<a name="ln2257">//</a>
<a name="ln2258">// Done this way in the hopes that it will be obvious from</a>
<a name="ln2259">// calling code that &quot;obj&quot; is possibly modified.</a>
<a name="ln2260">//</a>
<a name="ln2261">// Returns false on error or level full - cases where you</a>
<a name="ln2262">// keep the item.</a>
<a name="ln2263">bool move_item_to_grid(int *const obj, const coord_def&amp; p, bool silent)</a>
<a name="ln2264">{</a>
<a name="ln2265">    ASSERT_IN_BOUNDS(p);</a>
<a name="ln2266"> </a>
<a name="ln2267">    int&amp; ob(*obj);</a>
<a name="ln2268"> </a>
<a name="ln2269">    // Must be a valid reference to a valid object.</a>
<a name="ln2270">    if (ob == NON_ITEM || !mitm[ob].defined())</a>
<a name="ln2271">        return false;</a>
<a name="ln2272"> </a>
<a name="ln2273">    item_def&amp; item(mitm[ob]);</a>
<a name="ln2274">    bool move_below = item_is_stationary(item) &amp;&amp; !item_is_stationary_net(item);</a>
<a name="ln2275"> </a>
<a name="ln2276">    if (!silenced(p) &amp;&amp; !silent)</a>
<a name="ln2277">        feat_splash_noise(grd(p));</a>
<a name="ln2278"> </a>
<a name="ln2279">    if (feat_destroys_items(grd(p)))</a>
<a name="ln2280">    {</a>
<a name="ln2281">        item_was_destroyed(item);</a>
<a name="ln2282">        destroy_item(ob);</a>
<a name="ln2283">        ob = NON_ITEM;</a>
<a name="ln2284"> </a>
<a name="ln2285">        return true;</a>
<a name="ln2286">    }</a>
<a name="ln2287"> </a>
<a name="ln2288">    // If it's a stackable type or stationary item that's not a net...</a>
<a name="ln2289">    int movable_ind = -1;</a>
<a name="ln2290">    if (move_below || is_stackable_item(item))</a>
<a name="ln2291">    {</a>
<a name="ln2292">        // Look for similar item to stack:</a>
<a name="ln2293">        for (stack_iterator si(p); si; ++si)</a>
<a name="ln2294">        {</a>
<a name="ln2295">            // Check if item already linked here -- don't want to unlink it.</a>
<a name="ln2296">            if (ob == si-&gt;index())</a>
<a name="ln2297">                return false;</a>
<a name="ln2298"> </a>
<a name="ln2299">            if (items_stack(item, *si))</a>
<a name="ln2300">            {</a>
<a name="ln2301">                // Add quantity to item already here, and dispose</a>
<a name="ln2302">                // of obj, while returning the found item. -- bwr</a>
<a name="ln2303">                merge_item_stacks(item, *si);</a>
<a name="ln2304">                inc_mitm_item_quantity(si-&gt;index(), item.quantity);</a>
<a name="ln2305">                destroy_item(ob);</a>
<a name="ln2306">                ob = si-&gt;index();</a>
<a name="ln2307">                _gozag_move_gold_to_top(p);</a>
<a name="ln2308">                if (you.see_cell(p))</a>
<a name="ln2309">                {</a>
<a name="ln2310">                    // XXX: Is it actually necessary to identify when the</a>
<a name="ln2311">                    // new item merged with a stack?</a>
<a name="ln2312">                    god_id_item(*si);</a>
<a name="ln2313">                    maybe_identify_base_type(*si);</a>
<a name="ln2314">                }</a>
<a name="ln2315">                return true;</a>
<a name="ln2316">            }</a>
<a name="ln2317">            if (move_below</a>
<a name="ln2318">                &amp;&amp; (!item_is_stationary(*si) || item_is_stationary_net(*si)))</a>
<a name="ln2319">            {</a>
<a name="ln2320">                movable_ind = si-&gt;index();</a>
<a name="ln2321">            }</a>
<a name="ln2322">        }</a>
<a name="ln2323">    }</a>
<a name="ln2324">    else</a>
<a name="ln2325">        ASSERT(item.quantity == 1);</a>
<a name="ln2326"> </a>
<a name="ln2327">    ASSERT(ob != NON_ITEM);</a>
<a name="ln2328"> </a>
<a name="ln2329">    // Need to actually move object, so first unlink from old position.</a>
<a name="ln2330">    unlink_item(ob);</a>
<a name="ln2331"> </a>
<a name="ln2332">    // Move item to coord.</a>
<a name="ln2333">    item.pos = p;</a>
<a name="ln2334"> </a>
<a name="ln2335">    // Need to move this stationary item to the position in the pile</a>
<a name="ln2336">    // below the lowest non-stationary, non-net item.</a>
<a name="ln2337">    if (move_below &amp;&amp; movable_ind &gt;= 0)</a>
<a name="ln2338">    {</a>
<a name="ln2339">        item.link = mitm[movable_ind].link;</a>
<a name="ln2340">        mitm[movable_ind].link = item.index();</a>
<a name="ln2341">    }</a>
<a name="ln2342">    // Movable item or no movable items in pile, link item to top of list.</a>
<a name="ln2343">    else</a>
<a name="ln2344">    {</a>
<a name="ln2345">        item.link = igrd(p);</a>
<a name="ln2346">        igrd(p) = ob;</a>
<a name="ln2347">    }</a>
<a name="ln2348"> </a>
<a name="ln2349">    if (item_is_orb(item))</a>
<a name="ln2350">        env.orb_pos = p;</a>
<a name="ln2351"> </a>
<a name="ln2352">    if (item.base_type != OBJ_GOLD)</a>
<a name="ln2353">        _gozag_move_gold_to_top(p);</a>
<a name="ln2354"> </a>
<a name="ln2355">    if (you.see_cell(p))</a>
<a name="ln2356">    {</a>
<a name="ln2357">        god_id_item(item);</a>
<a name="ln2358">        maybe_identify_base_type(item);</a>
<a name="ln2359">    }</a>
<a name="ln2360"> </a>
<a name="ln2361">    if (p == you.pos() &amp;&amp; _id_floor_item(item))</a>
<a name="ln2362">        mprf(&quot;You see here %s.&quot;, item.name(DESC_A).c_str());</a>
<a name="ln2363"> </a>
<a name="ln2364">    return true;</a>
<a name="ln2365">}</a>
<a name="ln2366"> </a>
<a name="ln2367">void move_item_stack_to_grid(const coord_def&amp; from, const coord_def&amp; to)</a>
<a name="ln2368">{</a>
<a name="ln2369">    if (igrd(from) == NON_ITEM)</a>
<a name="ln2370">        return;</a>
<a name="ln2371"> </a>
<a name="ln2372">    // Tell all items in stack what the new coordinate is.</a>
<a name="ln2373">    for (stack_iterator si(from); si; ++si)</a>
<a name="ln2374">    {</a>
<a name="ln2375">        si-&gt;pos = to;</a>
<a name="ln2376"> </a>
<a name="ln2377">        // Link last of the stack to the top of the old stack.</a>
<a name="ln2378">        if (si-&gt;link == NON_ITEM &amp;&amp; igrd(to) != NON_ITEM)</a>
<a name="ln2379">        {</a>
<a name="ln2380">            si-&gt;link = igrd(to);</a>
<a name="ln2381">            break;</a>
<a name="ln2382">        }</a>
<a name="ln2383">    }</a>
<a name="ln2384"> </a>
<a name="ln2385">    igrd(to) = igrd(from);</a>
<a name="ln2386">    igrd(from) = NON_ITEM;</a>
<a name="ln2387">}</a>
<a name="ln2388"> </a>
<a name="ln2389">// Returns false if no items could be dropped.</a>
<a name="ln2390">bool copy_item_to_grid(item_def &amp;item, const coord_def&amp; p,</a>
<a name="ln2391">                        int quant_drop, bool mark_dropped, bool silent)</a>
<a name="ln2392">{</a>
<a name="ln2393">    ASSERT_IN_BOUNDS(p);</a>
<a name="ln2394"> </a>
<a name="ln2395">    if (quant_drop == 0)</a>
<a name="ln2396">        return false;</a>
<a name="ln2397"> </a>
<a name="ln2398">    if (!silenced(p) &amp;&amp; !silent)</a>
<a name="ln2399">        feat_splash_noise(grd(p));</a>
<a name="ln2400"> </a>
<a name="ln2401">    if (feat_destroys_items(grd(p)))</a>
<a name="ln2402">    {</a>
<a name="ln2403">        item_was_destroyed(item);</a>
<a name="ln2404">        return true;</a>
<a name="ln2405">    }</a>
<a name="ln2406"> </a>
<a name="ln2407">    // default quant_drop == -1 =&gt; drop all</a>
<a name="ln2408">    if (quant_drop &lt; 0)</a>
<a name="ln2409">        quant_drop = item.quantity;</a>
<a name="ln2410"> </a>
<a name="ln2411">    // Loop through items at current location.</a>
<a name="ln2412">    if (is_stackable_item(item))</a>
<a name="ln2413">    {</a>
<a name="ln2414">        for (stack_iterator si(p); si; ++si)</a>
<a name="ln2415">        {</a>
<a name="ln2416">            if (items_stack(item, *si))</a>
<a name="ln2417">            {</a>
<a name="ln2418">                item_def copy = item;</a>
<a name="ln2419">                merge_item_stacks(copy, *si, quant_drop);</a>
<a name="ln2420">                inc_mitm_item_quantity(si-&gt;index(), quant_drop);</a>
<a name="ln2421"> </a>
<a name="ln2422">                if (mark_dropped)</a>
<a name="ln2423">                {</a>
<a name="ln2424">                    // If the items on the floor already have a nonzero slot,</a>
<a name="ln2425">                    // leave it as such, otherwise set the slot.</a>
<a name="ln2426">                    if (!si-&gt;slot)</a>
<a name="ln2427">                        si-&gt;slot = index_to_letter(item.link);</a>
<a name="ln2428"> </a>
<a name="ln2429">                    si-&gt;flags |= ISFLAG_DROPPED;</a>
<a name="ln2430">                    si-&gt;flags &amp;= ~ISFLAG_THROWN;</a>
<a name="ln2431">                }</a>
<a name="ln2432">                return true;</a>
<a name="ln2433">            }</a>
<a name="ln2434">        }</a>
<a name="ln2435">    }</a>
<a name="ln2436"> </a>
<a name="ln2437">    // Item not found in current stack, add new item to top.</a>
<a name="ln2438">    int new_item_idx = get_mitm_slot(10);</a>
<a name="ln2439">    if (new_item_idx == NON_ITEM)</a>
<a name="ln2440">        return false;</a>
<a name="ln2441">    item_def&amp; new_item = mitm[new_item_idx];</a>
<a name="ln2442"> </a>
<a name="ln2443">    // Copy item.</a>
<a name="ln2444">    new_item = item;</a>
<a name="ln2445"> </a>
<a name="ln2446">    // Set quantity, and set the item as unlinked.</a>
<a name="ln2447">    new_item.quantity = quant_drop;</a>
<a name="ln2448">    new_item.pos.reset();</a>
<a name="ln2449">    new_item.link = NON_ITEM;</a>
<a name="ln2450"> </a>
<a name="ln2451">    if (mark_dropped)</a>
<a name="ln2452">    {</a>
<a name="ln2453">        new_item.slot   = index_to_letter(item.link);</a>
<a name="ln2454">        new_item.flags |= ISFLAG_DROPPED;</a>
<a name="ln2455">        new_item.flags &amp;= ~ISFLAG_THROWN;</a>
<a name="ln2456">        origin_set_unknown(new_item);</a>
<a name="ln2457">    }</a>
<a name="ln2458"> </a>
<a name="ln2459">    move_item_to_grid(&amp;new_item_idx, p, true);</a>
<a name="ln2460">    // In the case of a partial drop, since only the oldest items have</a>
<a name="ln2461">    // been dropped, remove the newest ones.</a>
<a name="ln2462">    if (item.quantity != quant_drop &amp;&amp; is_perishable_stack(item))</a>
<a name="ln2463">        remove_newest_perishable_item(new_item);</a>
<a name="ln2464"> </a>
<a name="ln2465">    return true;</a>
<a name="ln2466">}</a>
<a name="ln2467"> </a>
<a name="ln2468">coord_def item_pos(const item_def &amp;item)</a>
<a name="ln2469">{</a>
<a name="ln2470">    coord_def pos = item.pos;</a>
<a name="ln2471">    if (pos == ITEM_IN_MONSTER_INVENTORY)</a>
<a name="ln2472">    {</a>
<a name="ln2473">        if (const monster *mon = item.holding_monster())</a>
<a name="ln2474">            pos = mon-&gt;pos();</a>
<a name="ln2475">        else</a>
<a name="ln2476">            die(&quot;item held by an invalid monster&quot;);</a>
<a name="ln2477">    }</a>
<a name="ln2478">    else if (pos == ITEM_IN_INVENTORY)</a>
<a name="ln2479">        pos = you.pos();</a>
<a name="ln2480">    return pos;</a>
<a name="ln2481">}</a>
<a name="ln2482"> </a>
<a name="ln2483">/**</a>
<a name="ln2484"> * Move the top item of a stack to a new location.</a>
<a name="ln2485"> *</a>
<a name="ln2486"> * @param pos the location of the stack</a>
<a name="ln2487"> * @param dest the position to be moved to</a>
<a name="ln2488"> * @return whether there were any items at pos to be moved.</a>
<a name="ln2489"> */</a>
<a name="ln2490">bool move_top_item(const coord_def &amp;pos, const coord_def &amp;dest)</a>
<a name="ln2491">{</a>
<a name="ln2492">    int item = igrd(pos);</a>
<a name="ln2493">    if (item == NON_ITEM)</a>
<a name="ln2494">        return false;</a>
<a name="ln2495"> </a>
<a name="ln2496">    dungeon_events.fire_position_event(</a>
<a name="ln2497">        dgn_event(DET_ITEM_MOVED, pos, 0, item, -1, dest), pos);</a>
<a name="ln2498"> </a>
<a name="ln2499">    // Now move the item to its new position...</a>
<a name="ln2500">    move_item_to_grid(&amp;item, dest);</a>
<a name="ln2501"> </a>
<a name="ln2502">    return true;</a>
<a name="ln2503">}</a>
<a name="ln2504"> </a>
<a name="ln2505">const item_def* top_item_at(const coord_def&amp; where)</a>
<a name="ln2506">{</a>
<a name="ln2507">    const int link = you.visible_igrd(where);</a>
<a name="ln2508">    return (link == NON_ITEM) ? nullptr : &amp;mitm[link];</a>
<a name="ln2509">}</a>
<a name="ln2510"> </a>
<a name="ln2511">bool multiple_items_at(const coord_def&amp; where)</a>
<a name="ln2512">{</a>
<a name="ln2513">    int found_count = 0;</a>
<a name="ln2514"> </a>
<a name="ln2515">    for (stack_iterator si(where); si &amp;&amp; found_count &lt; 2; ++si)</a>
<a name="ln2516">        ++found_count;</a>
<a name="ln2517"> </a>
<a name="ln2518">    return found_count &gt; 1;</a>
<a name="ln2519">}</a>
<a name="ln2520"> </a>
<a name="ln2521">/**</a>
<a name="ln2522"> * Drop an item, possibly starting up a delay to do so.</a>
<a name="ln2523"> *</a>
<a name="ln2524"> * @param item_dropped the inventory index of the item to drop</a>
<a name="ln2525"> * @param quant_drop the number of items to drop, -1 to drop the whole stack.</a>
<a name="ln2526"> *</a>
<a name="ln2527"> * @return True if we took time, either because we dropped the item</a>
<a name="ln2528"> *         or because we took a preliminary step (removing a ring, etc.).</a>
<a name="ln2529"> */</a>
<a name="ln2530">bool drop_item(int item_dropped, int quant_drop)</a>
<a name="ln2531">{</a>
<a name="ln2532">    item_def &amp;item = you.inv[item_dropped];</a>
<a name="ln2533"> </a>
<a name="ln2534">    if (quant_drop &lt; 0 || quant_drop &gt; item.quantity)</a>
<a name="ln2535">        quant_drop = item.quantity;</a>
<a name="ln2536"> </a>
<a name="ln2537">    if (item_dropped == you.equip[EQ_LEFT_RING]</a>
<a name="ln2538">     || item_dropped == you.equip[EQ_RIGHT_RING]</a>
<a name="ln2539">     || item_dropped == you.equip[EQ_AMULET]</a>
<a name="ln2540">     || item_dropped == you.equip[EQ_RING_ONE]</a>
<a name="ln2541">     || item_dropped == you.equip[EQ_RING_TWO]</a>
<a name="ln2542">     || item_dropped == you.equip[EQ_RING_THREE]</a>
<a name="ln2543">     || item_dropped == you.equip[EQ_RING_FOUR]</a>
<a name="ln2544">     || item_dropped == you.equip[EQ_RING_FIVE]</a>
<a name="ln2545">     || item_dropped == you.equip[EQ_RING_SIX]</a>
<a name="ln2546">     || item_dropped == you.equip[EQ_RING_SEVEN]</a>
<a name="ln2547">     || item_dropped == you.equip[EQ_RING_EIGHT]</a>
<a name="ln2548">     || item_dropped == you.equip[EQ_RING_AMULET])</a>
<a name="ln2549">    {</a>
<a name="ln2550">        if (!Options.easy_unequip)</a>
<a name="ln2551">            mpr(&quot;You will have to take that off first.&quot;);</a>
<a name="ln2552">        else if (remove_ring(item_dropped, true))</a>
<a name="ln2553">        {</a>
<a name="ln2554">            // The delay handles the case where the item disappeared.</a>
<a name="ln2555">            start_delay&lt;DropItemDelay&gt;(1, item);</a>
<a name="ln2556">            // We didn't actually succeed yet, but remove_ring took time,</a>
<a name="ln2557">            // so return true anyway.</a>
<a name="ln2558">            return true;</a>
<a name="ln2559">        }</a>
<a name="ln2560"> </a>
<a name="ln2561">        return false;</a>
<a name="ln2562">    }</a>
<a name="ln2563"> </a>
<a name="ln2564">    if (item_dropped == you.equip[EQ_WEAPON]</a>
<a name="ln2565">        &amp;&amp; item.base_type == OBJ_WEAPONS &amp;&amp; item.cursed())</a>
<a name="ln2566">    {</a>
<a name="ln2567">        mprf(&quot;%s is stuck to you!&quot;, item.name(DESC_THE).c_str());</a>
<a name="ln2568">        return false;</a>
<a name="ln2569">    }</a>
<a name="ln2570"> </a>
<a name="ln2571">    for (int i = EQ_MIN_ARMOUR; i &lt;= EQ_MAX_ARMOUR; i++)</a>
<a name="ln2572">    {</a>
<a name="ln2573">        if (item_dropped == you.equip[i] &amp;&amp; you.equip[i] != -1)</a>
<a name="ln2574">        {</a>
<a name="ln2575">            if (!Options.easy_unequip)</a>
<a name="ln2576">                mpr(&quot;You will have to take that off first.&quot;);</a>
<a name="ln2577">            else if (check_warning_inscriptions(item, OPER_TAKEOFF))</a>
<a name="ln2578">            {</a>
<a name="ln2579">                // If we take off the item, cue up the item being dropped</a>
<a name="ln2580">                if (takeoff_armour(item_dropped))</a>
<a name="ln2581">                {</a>
<a name="ln2582">                    // The delay handles the case where the item disappeared.</a>
<a name="ln2583">                    start_delay&lt;DropItemDelay&gt;(1, item);</a>
<a name="ln2584">                    // We didn't actually succeed yet, but takeoff_armour</a>
<a name="ln2585">                    // took a turn to start up, so return true anyway.</a>
<a name="ln2586">                    return true;</a>
<a name="ln2587">                }</a>
<a name="ln2588">            }</a>
<a name="ln2589">            return false;</a>
<a name="ln2590">        }</a>
<a name="ln2591">    }</a>
<a name="ln2592"> </a>
<a name="ln2593">    // [ds] easy_unequip does not apply to weapons.</a>
<a name="ln2594">    //</a>
<a name="ln2595">    // Unwield needs to be done before copy in order to clear things</a>
<a name="ln2596">    // like temporary brands. -- bwr</a>
<a name="ln2597">    if (item_dropped == you.equip[EQ_WEAPON] &amp;&amp; quant_drop &gt;= item.quantity)</a>
<a name="ln2598">    {</a>
<a name="ln2599">        if (!wield_weapon(true, SLOT_BARE_HANDS, true, true, true, false))</a>
<a name="ln2600">            return false;</a>
<a name="ln2601">        // May have been destroyed by removal. Returning true because we took</a>
<a name="ln2602">        // time to swap away.</a>
<a name="ln2603">        else if (!item.defined())</a>
<a name="ln2604">            return true;</a>
<a name="ln2605">    }</a>
<a name="ln2606"> </a>
<a name="ln2607">    ASSERT(item.defined());</a>
<a name="ln2608"> </a>
<a name="ln2609">    if (!copy_item_to_grid(item, you.pos(), quant_drop, true, true))</a>
<a name="ln2610">    {</a>
<a name="ln2611">        mpr(&quot;Too many items on this level, not dropping the item.&quot;);</a>
<a name="ln2612">        return false;</a>
<a name="ln2613">    }</a>
<a name="ln2614"> </a>
<a name="ln2615">    mprf(&quot;You drop %s.&quot;, quant_name(item, quant_drop, DESC_A).c_str());</a>
<a name="ln2616"> </a>
<a name="ln2617">    // If you drop an item in as a merfolk, it is below the water line and</a>
<a name="ln2618">    // makes no noise falling.</a>
<a name="ln2619">    if (!you.swimming())</a>
<a name="ln2620">        feat_splash_noise(grd(you.pos()));</a>
<a name="ln2621"> </a>
<a name="ln2622">    // XP evoker has been handled in copy_item_to_grid</a>
<a name="ln2623">    if (item.quantity != quant_drop &amp;&amp; is_perishable_stack(item))</a>
<a name="ln2624">    {</a>
<a name="ln2625">        // Oldest potions have been dropped.</a>
<a name="ln2626">        for (int i = 0; i &lt; quant_drop; i++)</a>
<a name="ln2627">            remove_oldest_perishable_item(item);</a>
<a name="ln2628">    }</a>
<a name="ln2629"> </a>
<a name="ln2630">    dec_inv_item_quantity(item_dropped, quant_drop);</a>
<a name="ln2631">    you.turn_is_over = true;</a>
<a name="ln2632"> </a>
<a name="ln2633">    you.last_pickup.erase(item_dropped);</a>
<a name="ln2634">    if (you.last_unequip == item.link)</a>
<a name="ln2635">        you.last_unequip = -1;</a>
<a name="ln2636"> </a>
<a name="ln2637">    return true;</a>
<a name="ln2638">}</a>
<a name="ln2639"> </a>
<a name="ln2640">void drop_last()</a>
<a name="ln2641">{</a>
<a name="ln2642">    vector&lt;SelItem&gt; items_to_drop;</a>
<a name="ln2643"> </a>
<a name="ln2644">    for (const auto &amp;entry : you.last_pickup)</a>
<a name="ln2645">    {</a>
<a name="ln2646">        const item_def* item = &amp;you.inv[entry.first];</a>
<a name="ln2647">        if (item-&gt;quantity &gt; 0)</a>
<a name="ln2648">            items_to_drop.emplace_back(entry.first, entry.second, item);</a>
<a name="ln2649">    }</a>
<a name="ln2650"> </a>
<a name="ln2651">    if (items_to_drop.empty())</a>
<a name="ln2652">        mpr(&quot;No item to drop.&quot;);</a>
<a name="ln2653">    else</a>
<a name="ln2654">    {</a>
<a name="ln2655">        you.last_pickup.clear();</a>
<a name="ln2656">        _multidrop(items_to_drop);</a>
<a name="ln2657">    }</a>
<a name="ln2658">}</a>
<a name="ln2659"> </a>
<a name="ln2660">/** Get the equipment slot an item is equipped in. If the item is not</a>
<a name="ln2661"> * equipped by the player, return -1 instead.</a>
<a name="ln2662"> *</a>
<a name="ln2663"> * @param item The item to check.</a>
<a name="ln2664"> *</a>
<a name="ln2665"> * @returns The equipment slot (equipment_type) the item is in or -1</a>
<a name="ln2666"> * (EQ_NONE)</a>
<a name="ln2667">*/</a>
<a name="ln2668">int get_equip_slot(const item_def *item)</a>
<a name="ln2669">{</a>
<a name="ln2670">    int worn = -1;</a>
<a name="ln2671">    if (item &amp;&amp; in_inventory(*item))</a>
<a name="ln2672">    {</a>
<a name="ln2673">        for (int i = EQ_FIRST_EQUIP; i &lt; NUM_EQUIP; ++i)</a>
<a name="ln2674">        {</a>
<a name="ln2675">            if (you.equip[i] == item-&gt;link)</a>
<a name="ln2676">            {</a>
<a name="ln2677">                worn = i;</a>
<a name="ln2678">                break;</a>
<a name="ln2679">            }</a>
<a name="ln2680">        }</a>
<a name="ln2681">    }</a>
<a name="ln2682">    return worn;</a>
<a name="ln2683">}</a>
<a name="ln2684"> </a>
<a name="ln2685">mon_inv_type get_mon_equip_slot(const monster* mon, const item_def &amp;item)</a>
<a name="ln2686">{</a>
<a name="ln2687">    ASSERT(mon-&gt;alive());</a>
<a name="ln2688"> </a>
<a name="ln2689">    mon_inv_type slot = item_to_mslot(item);</a>
<a name="ln2690"> </a>
<a name="ln2691">    if (slot == NUM_MONSTER_SLOTS)</a>
<a name="ln2692">        return NUM_MONSTER_SLOTS;</a>
<a name="ln2693"> </a>
<a name="ln2694">    if (mon-&gt;mslot_item(slot) == &amp;item)</a>
<a name="ln2695">        return slot;</a>
<a name="ln2696"> </a>
<a name="ln2697">    if (slot == MSLOT_WEAPON &amp;&amp; mon-&gt;mslot_item(MSLOT_ALT_WEAPON) == &amp;item)</a>
<a name="ln2698">        return MSLOT_ALT_WEAPON;</a>
<a name="ln2699"> </a>
<a name="ln2700">    return NUM_MONSTER_SLOTS;</a>
<a name="ln2701">}</a>
<a name="ln2702"> </a>
<a name="ln2703">// This has to be of static storage class, so that the value isn't lost when a</a>
<a name="ln2704">// MultidropDelay is interrupted.</a>
<a name="ln2705">static vector&lt;SelItem&gt; items_for_multidrop;</a>
<a name="ln2706"> </a>
<a name="ln2707">// Arrange items that have been selected for multidrop so that</a>
<a name="ln2708">// equipped items are dropped after other items, and equipped items</a>
<a name="ln2709">// are dropped in the same order as their EQ_ slots are numbered.</a>
<a name="ln2710">static bool _drop_item_order(const SelItem &amp;first, const SelItem &amp;second)</a>
<a name="ln2711">{</a>
<a name="ln2712">    const item_def &amp;i1 = you.inv[first.slot];</a>
<a name="ln2713">    const item_def &amp;i2 = you.inv[second.slot];</a>
<a name="ln2714"> </a>
<a name="ln2715">    const int slot1 = get_equip_slot(&amp;i1),</a>
<a name="ln2716">              slot2 = get_equip_slot(&amp;i2);</a>
<a name="ln2717"> </a>
<a name="ln2718">    if (slot1 != -1 &amp;&amp; slot2 != -1)</a>
<a name="ln2719">        return slot1 &lt; slot2;</a>
<a name="ln2720">    else if (slot1 != -1 &amp;&amp; slot2 == -1)</a>
<a name="ln2721">        return false;</a>
<a name="ln2722">    else if (slot2 != -1 &amp;&amp; slot1 == -1)</a>
<a name="ln2723">        return true;</a>
<a name="ln2724"> </a>
<a name="ln2725">    return first.slot &lt; second.slot;</a>
<a name="ln2726">}</a>
<a name="ln2727"> </a>
<a name="ln2728">void set_item_autopickup(const item_def &amp;item, autopickup_level_type ap)</a>
<a name="ln2729">{</a>
<a name="ln2730">    you.force_autopickup[item.base_type][_autopickup_subtype(item)] = ap;</a>
<a name="ln2731">}</a>
<a name="ln2732"> </a>
<a name="ln2733">int item_autopickup_level(const item_def &amp;item)</a>
<a name="ln2734">{</a>
<a name="ln2735">    return you.force_autopickup[item.base_type][_autopickup_subtype(item)];</a>
<a name="ln2736">}</a>
<a name="ln2737"> </a>
<a name="ln2738">static void _disable_autopickup_for_starred_items(vector&lt;SelItem&gt; &amp;items)</a>
<a name="ln2739">{</a>
<a name="ln2740">    int autopickup_remove_count = 0;</a>
<a name="ln2741">    const item_def *last_touched_item;</a>
<a name="ln2742">    for (SelItem &amp;si : items)</a>
<a name="ln2743">    {</a>
<a name="ln2744">        if (si.has_star &amp;&amp; item_autopickup_level(si.item[0]) != AP_FORCE_OFF)</a>
<a name="ln2745">        {</a>
<a name="ln2746">            last_touched_item = si.item;</a>
<a name="ln2747">            ++autopickup_remove_count;</a>
<a name="ln2748">            set_item_autopickup(*last_touched_item, AP_FORCE_OFF);</a>
<a name="ln2749">        }</a>
<a name="ln2750">    }</a>
<a name="ln2751">    if (autopickup_remove_count == 1)</a>
<a name="ln2752">    {</a>
<a name="ln2753">        mprf(&quot;Autopickup disabled for %s.&quot;,</a>
<a name="ln2754">             pluralise(last_touched_item-&gt;name(DESC_DBNAME)).c_str());</a>
<a name="ln2755">    }</a>
<a name="ln2756">    else if (autopickup_remove_count &gt; 1)</a>
<a name="ln2757">        mprf(&quot;Autopickup disabled for %d items.&quot;, autopickup_remove_count);</a>
<a name="ln2758">}</a>
<a name="ln2759"> </a>
<a name="ln2760">/**</a>
<a name="ln2761"> * Prompts the user for an item to drop.</a>
<a name="ln2762"> */</a>
<a name="ln2763">void drop()</a>
<a name="ln2764">{</a>
<a name="ln2765">    if (inv_count() &lt; 1 &amp;&amp; you.gold == 0)</a>
<a name="ln2766">    {</a>
<a name="ln2767">        canned_msg(MSG_NOTHING_CARRIED);</a>
<a name="ln2768">        return;</a>
<a name="ln2769">    }</a>
<a name="ln2770"> </a>
<a name="ln2771">    vector&lt;SelItem&gt; tmp_items;</a>
<a name="ln2772"> </a>
<a name="ln2773">    tmp_items = prompt_drop_items(items_for_multidrop);</a>
<a name="ln2774"> </a>
<a name="ln2775">    if (tmp_items.empty())</a>
<a name="ln2776">    {</a>
<a name="ln2777">        canned_msg(MSG_OK);</a>
<a name="ln2778">        return;</a>
<a name="ln2779">    }</a>
<a name="ln2780"> </a>
<a name="ln2781">    _disable_autopickup_for_starred_items(tmp_items);</a>
<a name="ln2782">    _multidrop(tmp_items);</a>
<a name="ln2783">}</a>
<a name="ln2784"> </a>
<a name="ln2785">static void _multidrop(vector&lt;SelItem&gt; tmp_items)</a>
<a name="ln2786">{</a>
<a name="ln2787">    // Sort the dropped items so we don't see weird behaviour when</a>
<a name="ln2788">    // dropping a worn robe before a cloak (old behaviour: remove</a>
<a name="ln2789">    // cloak, remove robe, wear cloak, drop robe, remove cloak, drop</a>
<a name="ln2790">    // cloak).</a>
<a name="ln2791">    sort(tmp_items.begin(), tmp_items.end(), _drop_item_order);</a>
<a name="ln2792"> </a>
<a name="ln2793">    // If the user answers &quot;no&quot; to an item an with a warning inscription,</a>
<a name="ln2794">    // then remove it from the list of items to drop by not copying it</a>
<a name="ln2795">    // over to items_for_multidrop.</a>
<a name="ln2796">    items_for_multidrop.clear();</a>
<a name="ln2797">    for (SelItem&amp; si : tmp_items)</a>
<a name="ln2798">    {</a>
<a name="ln2799">        const int item_quant = si.item-&gt;quantity;</a>
<a name="ln2800"> </a>
<a name="ln2801">        // EVIL HACK: Fix item quantity to match the quantity we will drop,</a>
<a name="ln2802">        // in order to prevent misleading messages when dropping</a>
<a name="ln2803">        // 15 of 25 arrows inscribed with {!d}.</a>
<a name="ln2804">        if (si.quantity &amp;&amp; si.quantity != item_quant)</a>
<a name="ln2805">            const_cast&lt;item_def*&gt;(si.item)-&gt;quantity = si.quantity;</a>
<a name="ln2806"> </a>
<a name="ln2807">        // Check if we can add it to the multidrop list.</a>
<a name="ln2808">        bool warning_ok = check_warning_inscriptions(*(si.item), OPER_DROP);</a>
<a name="ln2809"> </a>
<a name="ln2810">        // Restore the item quantity if we mangled it.</a>
<a name="ln2811">        if (item_quant != si.item-&gt;quantity)</a>
<a name="ln2812">            const_cast&lt;item_def*&gt;(si.item)-&gt;quantity = item_quant;</a>
<a name="ln2813"> </a>
<a name="ln2814">        if (warning_ok)</a>
<a name="ln2815">            items_for_multidrop.push_back(si);</a>
<a name="ln2816">    }</a>
<a name="ln2817"> </a>
<a name="ln2818">    if (items_for_multidrop.empty()) // no items.</a>
<a name="ln2819">    {</a>
<a name="ln2820">        canned_msg(MSG_OK);</a>
<a name="ln2821">        return;</a>
<a name="ln2822">    }</a>
<a name="ln2823"> </a>
<a name="ln2824">    if (items_for_multidrop.size() == 1) // only one item</a>
<a name="ln2825">    {</a>
<a name="ln2826">        drop_item(items_for_multidrop[0].slot, items_for_multidrop[0].quantity);</a>
<a name="ln2827">        items_for_multidrop.clear();</a>
<a name="ln2828">    }</a>
<a name="ln2829">    else</a>
<a name="ln2830">        start_delay&lt;MultidropDelay&gt;(items_for_multidrop.size(), items_for_multidrop);</a>
<a name="ln2831">}</a>
<a name="ln2832"> </a>
<a name="ln2833">static void _autoinscribe_item(item_def&amp; item)</a>
<a name="ln2834">{</a>
<a name="ln2835">    // If there's an inscription already, do nothing - except</a>
<a name="ln2836">    // for automatically generated inscriptions</a>
<a name="ln2837">    if (!item.inscription.empty())</a>
<a name="ln2838">        return;</a>
<a name="ln2839">    const string old_inscription = item.inscription;</a>
<a name="ln2840">    item.inscription.clear();</a>
<a name="ln2841"> </a>
<a name="ln2842">    string iname = _autopickup_item_name(item);</a>
<a name="ln2843"> </a>
<a name="ln2844">    for (const auto &amp;ai_entry : Options.autoinscriptions)</a>
<a name="ln2845">    {</a>
<a name="ln2846">        if (ai_entry.first.matches(iname))</a>
<a name="ln2847">        {</a>
<a name="ln2848">            // Don't autoinscribe dropped items on ground with</a>
<a name="ln2849">            // &quot;=g&quot;. If the item matches a rule which adds &quot;=g&quot;,</a>
<a name="ln2850">            // &quot;=g&quot; got added to it before it was dropped, and</a>
<a name="ln2851">            // then the user explicitly removed it because they</a>
<a name="ln2852">            // don't want to autopickup it again.</a>
<a name="ln2853">            string str = ai_entry.second;</a>
<a name="ln2854">            if ((item.flags &amp; ISFLAG_DROPPED) &amp;&amp; !in_inventory(item))</a>
<a name="ln2855">                str = replace_all(str, &quot;=g&quot;, &quot;&quot;);</a>
<a name="ln2856"> </a>
<a name="ln2857">            // Note that this might cause the item inscription to</a>
<a name="ln2858">            // pass 80 characters.</a>
<a name="ln2859">            item.inscription += str;</a>
<a name="ln2860">        }</a>
<a name="ln2861">    }</a>
<a name="ln2862">    if (!old_inscription.empty())</a>
<a name="ln2863">    {</a>
<a name="ln2864">        if (item.inscription.empty())</a>
<a name="ln2865">            item.inscription = old_inscription;</a>
<a name="ln2866">        else</a>
<a name="ln2867">            item.inscription = old_inscription + &quot;, &quot; + item.inscription;</a>
<a name="ln2868">    }</a>
<a name="ln2869">}</a>
<a name="ln2870"> </a>
<a name="ln2871">static void _autoinscribe_floor_items()</a>
<a name="ln2872">{</a>
<a name="ln2873">    for (stack_iterator si(you.pos()); si; ++si)</a>
<a name="ln2874">        _autoinscribe_item(*si);</a>
<a name="ln2875">}</a>
<a name="ln2876"> </a>
<a name="ln2877">static void _autoinscribe_inventory()</a>
<a name="ln2878">{</a>
<a name="ln2879">    for (auto &amp;item : you.inv)</a>
<a name="ln2880">        if (item.defined())</a>
<a name="ln2881">            _autoinscribe_item(item);</a>
<a name="ln2882">}</a>
<a name="ln2883"> </a>
<a name="ln2884">bool need_to_autoinscribe()</a>
<a name="ln2885">{</a>
<a name="ln2886">    return will_autoinscribe;</a>
<a name="ln2887">}</a>
<a name="ln2888"> </a>
<a name="ln2889">void request_autoinscribe(bool do_inscribe)</a>
<a name="ln2890">{</a>
<a name="ln2891">    will_autoinscribe = do_inscribe;</a>
<a name="ln2892">}</a>
<a name="ln2893"> </a>
<a name="ln2894">void autoinscribe()</a>
<a name="ln2895">{</a>
<a name="ln2896">    _autoinscribe_floor_items();</a>
<a name="ln2897">    _autoinscribe_inventory();</a>
<a name="ln2898"> </a>
<a name="ln2899">    will_autoinscribe = false;</a>
<a name="ln2900">}</a>
<a name="ln2901"> </a>
<a name="ln2902">/**</a>
<a name="ln2903"> * Resolve an item's subtype to an appropriate value for autopickup.</a>
<a name="ln2904"> * @param item The item to check.</a>
<a name="ln2905"> * @returns The actual sub_type for items that either have an identified</a>
<a name="ln2906"> * sub_type or where the sub_type is always known. Otherwise the value of the</a>
<a name="ln2907"> * max subtype.</a>
<a name="ln2908">*/</a>
<a name="ln2909">static int _autopickup_subtype(const item_def &amp;item)</a>
<a name="ln2910">{</a>
<a name="ln2911">    // Sensed items.</a>
<a name="ln2912">    if (item.base_type &gt;= NUM_OBJECT_CLASSES)</a>
<a name="ln2913">        return MAX_SUBTYPES - 1;</a>
<a name="ln2914"> </a>
<a name="ln2915">    const int max_type = get_max_subtype(item.base_type);</a>
<a name="ln2916"> </a>
<a name="ln2917">    // item_infos of unknown subtype.</a>
<a name="ln2918">    if (max_type &gt; 0 &amp;&amp; item.sub_type &gt;= max_type)</a>
<a name="ln2919">        return max_type;</a>
<a name="ln2920"> </a>
<a name="ln2921">    // Only where item_type_known() refers to the subtype (as opposed to the</a>
<a name="ln2922">    // brand, for example) do we have to check it. For weapons etc. we always</a>
<a name="ln2923">    // know the subtype.</a>
<a name="ln2924">    switch (item.base_type)</a>
<a name="ln2925">    {</a>
<a name="ln2926">    case OBJ_WANDS:</a>
<a name="ln2927">    case OBJ_SCROLLS:</a>
<a name="ln2928">    case OBJ_JEWELLERY:</a>
<a name="ln2929">    case OBJ_POTIONS:</a>
<a name="ln2930">    case OBJ_STAVES:</a>
<a name="ln2931">        return item_type_known(item) ? item.sub_type : max_type;</a>
<a name="ln2932">    case OBJ_BOOKS:</a>
<a name="ln2933">        if (item.sub_type == BOOK_MANUAL || item_type_known(item))</a>
<a name="ln2934">            return item.sub_type;</a>
<a name="ln2935">        else</a>
<a name="ln2936">            return max_type;</a>
<a name="ln2937">#if TAG_MAJOR_VERSION == 34</a>
<a name="ln2938">    case OBJ_RODS:</a>
<a name="ln2939">#endif</a>
<a name="ln2940">    case OBJ_GOLD:</a>
<a name="ln2941">    case OBJ_RUNES:</a>
<a name="ln2942">        return max_type;</a>
<a name="ln2943">    default:</a>
<a name="ln2944">        return item.sub_type;</a>
<a name="ln2945">    }</a>
<a name="ln2946">}</a>
<a name="ln2947"> </a>
<a name="ln2948">static bool _is_option_autopickup(const item_def &amp;item, bool ignore_force)</a>
<a name="ln2949">{</a>
<a name="ln2950">    string iname = _autopickup_item_name(item);</a>
<a name="ln2951"> </a>
<a name="ln2952">    if (item.base_type &lt; NUM_OBJECT_CLASSES)</a>
<a name="ln2953">    {</a>
<a name="ln2954">        const int force = item_autopickup_level(item);</a>
<a name="ln2955">        if (!ignore_force &amp;&amp; force != AP_FORCE_NONE)</a>
<a name="ln2956">            return force == AP_FORCE_ON;</a>
<a name="ln2957">    }</a>
<a name="ln2958">    else</a>
<a name="ln2959">        return false;</a>
<a name="ln2960"> </a>
<a name="ln2961">#ifdef CLUA_BINDINGS</a>
<a name="ln2962">    maybe_bool res = clua.callmaybefn(&quot;ch_force_autopickup&quot;, &quot;is&quot;,</a>
<a name="ln2963">                                      &amp;item, iname.c_str());</a>
<a name="ln2964">    if (!clua.error.empty())</a>
<a name="ln2965">    {</a>
<a name="ln2966">        mprf(MSGCH_ERROR, &quot;ch_force_autopickup failed: %s&quot;,</a>
<a name="ln2967">             clua.error.c_str());</a>
<a name="ln2968">    }</a>
<a name="ln2969"> </a>
<a name="ln2970">    if (res == MB_TRUE)</a>
<a name="ln2971">        return true;</a>
<a name="ln2972"> </a>
<a name="ln2973">    if (res == MB_FALSE)</a>
<a name="ln2974">        return false;</a>
<a name="ln2975">#endif</a>
<a name="ln2976"> </a>
<a name="ln2977">    // Check for initial settings</a>
<a name="ln2978">    for (const pair&lt;text_pattern, bool&gt;&amp; option : Options.force_autopickup)</a>
<a name="ln2979">        if (option.first.matches(iname))</a>
<a name="ln2980">            return option.second;</a>
<a name="ln2981"> </a>
<a name="ln2982">    return Options.autopickups[item.base_type];</a>
<a name="ln2983">}</a>
<a name="ln2984"> </a>
<a name="ln2985">static int _get_chunk_count() {</a>
<a name="ln2986">    auto it = find_if(you.inv.begin(), you.inv.end(),</a>
<a name="ln2987">                      [](const item_def&amp; item) {</a>
<a name="ln2988">                          return item.base_type == OBJ_FOOD</a>
<a name="ln2989">                                 &amp;&amp; item.sub_type == FOOD_CHUNK</a>
<a name="ln2990">                                 &amp;&amp; !is_bad_food(item);</a>
<a name="ln2991">                      });</a>
<a name="ln2992">    return it == you.inv.end() ? 0 : it-&gt;quantity;</a>
<a name="ln2993">}</a>
<a name="ln2994"> </a>
<a name="ln2995">/// Should the player automatically butcher the given item?</a>
<a name="ln2996">static bool _should_autobutcher(const item_def &amp;item)</a>
<a name="ln2997">{</a>
<a name="ln2998">    const int max_chunks = Options.auto_butcher_max_chunks;</a>
<a name="ln2999">    return Options.auto_butcher &gt;= you.hunger_state</a>
<a name="ln3000">           &amp;&amp; item.base_type == OBJ_CORPSES</a>
<a name="ln3001">           &amp;&amp; !is_inedible(item) &amp;&amp; !is_bad_food(item)</a>
<a name="ln3002">           &amp;&amp; (max_chunks == 0 || _get_chunk_count() &lt; max_chunks);</a>
<a name="ln3003">}</a>
<a name="ln3004"> </a>
<a name="ln3005">/** Is the item something that we should try to autopickup?</a>
<a name="ln3006"> *</a>
<a name="ln3007"> * @param ignore_force If true, ignore force_autopickup settings from the</a>
<a name="ln3008"> *                     \ menu (default false).</a>
<a name="ln3009"> * @return True if the object should be picked up.</a>
<a name="ln3010"> */</a>
<a name="ln3011">bool item_needs_autopickup(const item_def &amp;item, bool ignore_force)</a>
<a name="ln3012">{</a>
<a name="ln3013">    if (in_inventory(item))</a>
<a name="ln3014">        return false;</a>
<a name="ln3015"> </a>
<a name="ln3016">    // mark autobutcher corpses for pickup so autotravel works</a>
<a name="ln3017">    if (_should_autobutcher(item))</a>
<a name="ln3018">        return true;</a>
<a name="ln3019"> </a>
<a name="ln3020">    if (item_is_stationary(item))</a>
<a name="ln3021">        return false;</a>
<a name="ln3022"> </a>
<a name="ln3023">    if (item.inscription.find(&quot;=g&quot;) != string::npos)</a>
<a name="ln3024">        return true;</a>
<a name="ln3025"> </a>
<a name="ln3026">    if ((item.flags &amp; ISFLAG_THROWN) &amp;&amp; Options.pickup_thrown)</a>
<a name="ln3027">        return true;</a>
<a name="ln3028"> </a>
<a name="ln3029">    if (item.flags &amp; ISFLAG_DROPPED)</a>
<a name="ln3030">        return false;</a>
<a name="ln3031"> </a>
<a name="ln3032">    if (item.props.exists(&quot;needs_autopickup&quot;))</a>
<a name="ln3033">        return true;</a>
<a name="ln3034"> </a>
<a name="ln3035">    return _is_option_autopickup(item, ignore_force);</a>
<a name="ln3036">}</a>
<a name="ln3037"> </a>
<a name="ln3038">bool can_autopickup()</a>
<a name="ln3039">{</a>
<a name="ln3040">    // [ds] Checking for autopickups == 0 is a bad idea because</a>
<a name="ln3041">    // autopickup is still possible with inscriptions and</a>
<a name="ln3042">    // pickup_thrown.</a>
<a name="ln3043">    if (Options.autopickup_on &lt;= 0)</a>
<a name="ln3044">        return false;</a>
<a name="ln3045"> </a>
<a name="ln3046">    if (!i_feel_safe())</a>
<a name="ln3047">        return false;</a>
<a name="ln3048"> </a>
<a name="ln3049">    return true;</a>
<a name="ln3050">}</a>
<a name="ln3051"> </a>
<a name="ln3052">typedef bool (*item_comparer)(const item_def&amp; pickup_item,</a>
<a name="ln3053">                              const item_def&amp; inv_item);</a>
<a name="ln3054"> </a>
<a name="ln3055">static bool _identical_types(const item_def&amp; pickup_item,</a>
<a name="ln3056">                             const item_def&amp; inv_item)</a>
<a name="ln3057">{</a>
<a name="ln3058">    return pickup_item.is_type(inv_item.base_type, inv_item.sub_type);</a>
<a name="ln3059">}</a>
<a name="ln3060"> </a>
<a name="ln3061">static bool _edible_food(const item_def&amp; /*pickup_item*/,</a>
<a name="ln3062">                         const item_def&amp; inv_item)</a>
<a name="ln3063">{</a>
<a name="ln3064">    return inv_item.base_type == OBJ_FOOD &amp;&amp; !is_inedible(inv_item);</a>
<a name="ln3065">}</a>
<a name="ln3066"> </a>
<a name="ln3067">static bool _similar_equip(const item_def&amp; pickup_item,</a>
<a name="ln3068">                           const item_def&amp; inv_item)</a>
<a name="ln3069">{</a>
<a name="ln3070">    const equipment_type inv_slot = get_item_slot(inv_item);</a>
<a name="ln3071"> </a>
<a name="ln3072">    if (inv_slot == EQ_NONE)</a>
<a name="ln3073">        return false;</a>
<a name="ln3074"> </a>
<a name="ln3075">    // If it's an unequipped cursed item the player might be looking</a>
<a name="ln3076">    // for a replacement.</a>
<a name="ln3077">    if (item_known_cursed(inv_item) &amp;&amp; !item_is_equipped(inv_item))</a>
<a name="ln3078">        return false;</a>
<a name="ln3079"> </a>
<a name="ln3080">    if (get_item_slot(pickup_item) != inv_slot)</a>
<a name="ln3081">        return false;</a>
<a name="ln3082"> </a>
<a name="ln3083">    // Just filling the same slot is enough for armour to be considered</a>
<a name="ln3084">    // similar.</a>
<a name="ln3085">    if (pickup_item.base_type == OBJ_ARMOUR)</a>
<a name="ln3086">        return true;</a>
<a name="ln3087"> </a>
<a name="ln3088">    return item_attack_skill(pickup_item) == item_attack_skill(inv_item)</a>
<a name="ln3089">           &amp;&amp; get_damage_type(pickup_item) == get_damage_type(inv_item);</a>
<a name="ln3090">}</a>
<a name="ln3091"> </a>
<a name="ln3092">static bool _similar_wands(const item_def&amp; pickup_item,</a>
<a name="ln3093">                           const item_def&amp; inv_item)</a>
<a name="ln3094">{</a>
<a name="ln3095">    if (inv_item.base_type != OBJ_WANDS)</a>
<a name="ln3096">        return false;</a>
<a name="ln3097"> </a>
<a name="ln3098">    if (pickup_item.sub_type != inv_item.sub_type)</a>
<a name="ln3099">        return false;</a>
<a name="ln3100">#if TAG_MAJOR_VERSION == 34</a>
<a name="ln3101">    // Not similar if wand in inventory is empty.</a>
<a name="ln3102">    return !is_known_empty_wand(inv_item);</a>
<a name="ln3103">#else</a>
<a name="ln3104">    return true;</a>
<a name="ln3105">#endif</a>
<a name="ln3106">}</a>
<a name="ln3107"> </a>
<a name="ln3108">static bool _similar_jewellery(const item_def&amp; pickup_item,</a>
<a name="ln3109">                               const item_def&amp; inv_item)</a>
<a name="ln3110">{</a>
<a name="ln3111">    if (inv_item.base_type != OBJ_JEWELLERY)</a>
<a name="ln3112">        return false;</a>
<a name="ln3113"> </a>
<a name="ln3114">    if (pickup_item.sub_type != inv_item.sub_type)</a>
<a name="ln3115">        return false;</a>
<a name="ln3116"> </a>
<a name="ln3117">    // For jewellery of the same sub-type, unidentified jewellery is</a>
<a name="ln3118">    // always considered similar, as is identified jewellery whose</a>
<a name="ln3119">    // effect doesn't stack.</a>
<a name="ln3120">    return !item_type_known(inv_item)</a>
<a name="ln3121">           || (!jewellery_is_amulet(inv_item)</a>
<a name="ln3122">               &amp;&amp; !ring_has_stackable_effect(inv_item));</a>
<a name="ln3123">}</a>
<a name="ln3124"> </a>
<a name="ln3125">static bool _item_different_than_inv(const item_def&amp; pickup_item,</a>
<a name="ln3126">                                     item_comparer comparer)</a>
<a name="ln3127">{</a>
<a name="ln3128">    return none_of(begin(you.inv), end(you.inv),</a>
<a name="ln3129">                   [&amp;] (const item_def &amp;inv_item) -&gt; bool</a>
<a name="ln3130">                   {</a>
<a name="ln3131">                       return inv_item.defined()</a>
<a name="ln3132">                           &amp;&amp; comparer(pickup_item, inv_item);</a>
<a name="ln3133">                   });</a>
<a name="ln3134">}</a>
<a name="ln3135"> </a>
<a name="ln3136">static bool _interesting_explore_pickup(const item_def&amp; item)</a>
<a name="ln3137">{</a>
<a name="ln3138">    if (!(Options.explore_stop &amp; ES_GREEDY_PICKUP_MASK))</a>
<a name="ln3139">        return false;</a>
<a name="ln3140"> </a>
<a name="ln3141">    if (item.base_type == OBJ_GOLD)</a>
<a name="ln3142">        return Options.explore_stop &amp; ES_GREEDY_PICKUP_GOLD;</a>
<a name="ln3143"> </a>
<a name="ln3144">    if ((Options.explore_stop &amp; ES_GREEDY_PICKUP_THROWN)</a>
<a name="ln3145">        &amp;&amp; (item.flags &amp; ISFLAG_THROWN))</a>
<a name="ln3146">    {</a>
<a name="ln3147">        return true;</a>
<a name="ln3148">    }</a>
<a name="ln3149"> </a>
<a name="ln3150">    vector&lt;text_pattern&gt; &amp;ignores = Options.explore_stop_pickup_ignore;</a>
<a name="ln3151">    if (!ignores.empty())</a>
<a name="ln3152">    {</a>
<a name="ln3153">        const string name = item.name(DESC_PLAIN);</a>
<a name="ln3154"> </a>
<a name="ln3155">        for (const text_pattern &amp;pat : ignores)</a>
<a name="ln3156">            if (pat.matches(name))</a>
<a name="ln3157">                return false;</a>
<a name="ln3158">    }</a>
<a name="ln3159"> </a>
<a name="ln3160">    if (!(Options.explore_stop &amp; ES_GREEDY_PICKUP_SMART))</a>
<a name="ln3161">        return true;</a>
<a name="ln3162">    // &quot;Smart&quot; code follows.</a>
<a name="ln3163"> </a>
<a name="ln3164">    // If ES_GREEDY_PICKUP_THROWN isn't set, then smart greedy pickup</a>
<a name="ln3165">    // will ignore thrown items.</a>
<a name="ln3166">    if (item.flags &amp; ISFLAG_THROWN)</a>
<a name="ln3167">        return false;</a>
<a name="ln3168"> </a>
<a name="ln3169">    if (is_artefact(item))</a>
<a name="ln3170">        return true;</a>
<a name="ln3171"> </a>
<a name="ln3172">    // Possbible ego items.</a>
<a name="ln3173">    if (!item_type_known(item) &amp;&amp; (item.flags &amp; ISFLAG_COSMETIC_MASK))</a>
<a name="ln3174">        return true;</a>
<a name="ln3175"> </a>
<a name="ln3176">    switch (item.base_type)</a>
<a name="ln3177">    {</a>
<a name="ln3178">    case OBJ_WEAPONS:</a>
<a name="ln3179">    case OBJ_MISSILES:</a>
<a name="ln3180">    case OBJ_ARMOUR:</a>
<a name="ln3181">        // Ego items.</a>
<a name="ln3182">        if (item.brand != 0)</a>
<a name="ln3183">            return true;</a>
<a name="ln3184">        break;</a>
<a name="ln3185"> </a>
<a name="ln3186">    default:</a>
<a name="ln3187">        break;</a>
<a name="ln3188">    }</a>
<a name="ln3189"> </a>
<a name="ln3190">    switch (item.base_type)</a>
<a name="ln3191">    {</a>
<a name="ln3192">    case OBJ_WEAPONS:</a>
<a name="ln3193">    case OBJ_ARMOUR:</a>
<a name="ln3194">        return _item_different_than_inv(item, _similar_equip);</a>
<a name="ln3195"> </a>
<a name="ln3196">    case OBJ_WANDS:</a>
<a name="ln3197">        return _item_different_than_inv(item, _similar_wands);</a>
<a name="ln3198"> </a>
<a name="ln3199">    case OBJ_JEWELLERY:</a>
<a name="ln3200">        return _item_different_than_inv(item, _similar_jewellery);</a>
<a name="ln3201"> </a>
<a name="ln3202">    case OBJ_FOOD:</a>
<a name="ln3203">        if (is_inedible(item))</a>
<a name="ln3204">            return false;</a>
<a name="ln3205"> </a>
<a name="ln3206">        // Interesting if we don't have any other edible food.</a>
<a name="ln3207">        return _item_different_than_inv(item, _edible_food);</a>
<a name="ln3208"> </a>
<a name="ln3209">    case OBJ_MISCELLANY:</a>
<a name="ln3210">    case OBJ_SCROLLS:</a>
<a name="ln3211">    case OBJ_POTIONS:</a>
<a name="ln3212">    case OBJ_STAVES:</a>
<a name="ln3213">        // Item is boring only if there's an identical one in inventory.</a>
<a name="ln3214">        return _item_different_than_inv(item, _identical_types);</a>
<a name="ln3215"> </a>
<a name="ln3216">    case OBJ_BOOKS:</a>
<a name="ln3217">        // Books always start out unidentified.</a>
<a name="ln3218">        return true;</a>
<a name="ln3219"> </a>
<a name="ln3220">    case OBJ_ORBS:</a>
<a name="ln3221">        // Orb is always interesting.</a>
<a name="ln3222">        return true;</a>
<a name="ln3223"> </a>
<a name="ln3224">    case OBJ_RUNES:</a>
<a name="ln3225">        // Runes are always interesting.</a>
<a name="ln3226">        return true;</a>
<a name="ln3227"> </a>
<a name="ln3228">    default:</a>
<a name="ln3229">        break;</a>
<a name="ln3230">    }</a>
<a name="ln3231"> </a>
<a name="ln3232">    return false;</a>
<a name="ln3233">}</a>
<a name="ln3234"> </a>
<a name="ln3235">static void _do_autopickup()</a>
<a name="ln3236">{</a>
<a name="ln3237">    bool did_pickup     = false;</a>
<a name="ln3238">    int  n_did_pickup   = 0;</a>
<a name="ln3239">    int  n_tried_pickup = 0;</a>
<a name="ln3240"> </a>
<a name="ln3241">    will_autopickup = false;</a>
<a name="ln3242"> </a>
<a name="ln3243">    if (!can_autopickup())</a>
<a name="ln3244">    {</a>
<a name="ln3245">        item_check();</a>
<a name="ln3246">        return;</a>
<a name="ln3247">    }</a>
<a name="ln3248"> </a>
<a name="ln3249">    // Store last_pickup in case we need to restore it.</a>
<a name="ln3250">    // Then clear it to fill with items picked up.</a>
<a name="ln3251">    map&lt;int,int&gt; tmp_l_p = you.last_pickup;</a>
<a name="ln3252">    you.last_pickup.clear();</a>
<a name="ln3253"> </a>
<a name="ln3254">    int o = you.visible_igrd(you.pos());</a>
<a name="ln3255"> </a>
<a name="ln3256">    string pickup_warning;</a>
<a name="ln3257">    while (o != NON_ITEM)</a>
<a name="ln3258">    {</a>
<a name="ln3259">        const int next = mitm[o].link;</a>
<a name="ln3260">        item_def&amp; mi = mitm[o];</a>
<a name="ln3261"> </a>
<a name="ln3262">        if (item_needs_autopickup(mi))</a>
<a name="ln3263">        {</a>
<a name="ln3264">            if (_should_autobutcher(mi))</a>
<a name="ln3265">            {</a>
<a name="ln3266">                if (you_are_delayed() &amp;&amp; current_delay()-&gt;want_autoeat())</a>
<a name="ln3267">                    butchery(&amp;mi);</a>
<a name="ln3268">                else</a>
<a name="ln3269">                    o = next;</a>
<a name="ln3270">                continue;</a>
<a name="ln3271">            }</a>
<a name="ln3272"> </a>
<a name="ln3273">            // Do this before it's picked up, otherwise the picked up</a>
<a name="ln3274">            // item will be in inventory and _interesting_explore_pickup()</a>
<a name="ln3275">            // will always return false.</a>
<a name="ln3276">            const bool interesting_pickup</a>
<a name="ln3277">                = _interesting_explore_pickup(mi);</a>
<a name="ln3278"> </a>
<a name="ln3279">            const iflags_t iflags(mi.flags);</a>
<a name="ln3280">            if ((iflags &amp; ISFLAG_THROWN))</a>
<a name="ln3281">                learned_something_new(HINT_AUTOPICKUP_THROWN);</a>
<a name="ln3282"> </a>
<a name="ln3283">            clear_item_pickup_flags(mi);</a>
<a name="ln3284"> </a>
<a name="ln3285">            const bool pickup_result = move_item_to_inv(o, mi.quantity);</a>
<a name="ln3286">            if (mi.is_type(OBJ_FOOD, FOOD_CHUNK))</a>
<a name="ln3287">                mi.flags |= ISFLAG_DROPPED;</a>
<a name="ln3288"> </a>
<a name="ln3289">            if (pickup_result)</a>
<a name="ln3290">            {</a>
<a name="ln3291">                did_pickup = true;</a>
<a name="ln3292">                if (interesting_pickup)</a>
<a name="ln3293">                    n_did_pickup++;</a>
<a name="ln3294">            }</a>
<a name="ln3295">            else</a>
<a name="ln3296">            {</a>
<a name="ln3297">                n_tried_pickup++;</a>
<a name="ln3298">                pickup_warning = &quot;Your pack is full.&quot;;</a>
<a name="ln3299">                mi.flags = iflags;</a>
<a name="ln3300">            }</a>
<a name="ln3301">        }</a>
<a name="ln3302">        o = next;</a>
<a name="ln3303">    }</a>
<a name="ln3304"> </a>
<a name="ln3305">    if (!pickup_warning.empty())</a>
<a name="ln3306">        mpr(pickup_warning);</a>
<a name="ln3307"> </a>
<a name="ln3308">    if (did_pickup)</a>
<a name="ln3309">        you.turn_is_over = true;</a>
<a name="ln3310"> </a>
<a name="ln3311">    if (you.last_pickup.empty())</a>
<a name="ln3312">        you.last_pickup = tmp_l_p;</a>
<a name="ln3313"> </a>
<a name="ln3314">    item_check();</a>
<a name="ln3315"> </a>
<a name="ln3316">    explore_pickup_event(n_did_pickup, n_tried_pickup);</a>
<a name="ln3317">}</a>
<a name="ln3318"> </a>
<a name="ln3319">void autopickup()</a>
<a name="ln3320">{</a>
<a name="ln3321">    _autoinscribe_floor_items();</a>
<a name="ln3322">    _do_autopickup();</a>
<a name="ln3323">}</a>
<a name="ln3324"> </a>
<a name="ln3325">int inv_count()</a>
<a name="ln3326">{</a>
<a name="ln3327">    return count_if(begin(you.inv), end(you.inv), mem_fn(&amp;item_def::defined));</a>
<a name="ln3328">}</a>
<a name="ln3329"> </a>
<a name="ln3330">// sub_type == -1 means look for any item of the class</a>
<a name="ln3331">item_def *find_floor_item(object_class_type cls, int sub_type)</a>
<a name="ln3332">{</a>
<a name="ln3333">    for (int y = 0; y &lt; GYM; ++y)</a>
<a name="ln3334">        for (int x = 0; x &lt; GXM; ++x)</a>
<a name="ln3335">            for (stack_iterator si(coord_def(x,y)); si; ++si)</a>
<a name="ln3336">                if (si-&gt;defined()</a>
<a name="ln3337">                    &amp;&amp; (si-&gt;is_type(cls, sub_type)</a>
<a name="ln3338">                        || si-&gt;base_type == cls &amp;&amp; sub_type == -1)</a>
<a name="ln3339">                    &amp;&amp; !(si-&gt;flags &amp; ISFLAG_MIMIC))</a>
<a name="ln3340">                {</a>
<a name="ln3341">                    return &amp;*si;</a>
<a name="ln3342">                }</a>
<a name="ln3343"> </a>
<a name="ln3344">    return nullptr;</a>
<a name="ln3345">}</a>
<a name="ln3346"> </a>
<a name="ln3347">int item_on_floor(const item_def &amp;item, const coord_def&amp; where)</a>
<a name="ln3348">{</a>
<a name="ln3349">    // Check if the item is on the floor and reachable.</a>
<a name="ln3350">    for (int link = igrd(where); link != NON_ITEM; link = mitm[link].link)</a>
<a name="ln3351">        if (&amp;mitm[link] == &amp;item)</a>
<a name="ln3352">            return link;</a>
<a name="ln3353"> </a>
<a name="ln3354">    return NON_ITEM;</a>
<a name="ln3355">}</a>
<a name="ln3356"> </a>
<a name="ln3357">int get_max_subtype(object_class_type base_type)</a>
<a name="ln3358">{</a>
<a name="ln3359">    static int max_subtype[] =</a>
<a name="ln3360">    {</a>
<a name="ln3361">        NUM_WEAPONS,</a>
<a name="ln3362">        NUM_MISSILES,</a>
<a name="ln3363">        NUM_ARMOURS,</a>
<a name="ln3364">        NUM_WANDS,</a>
<a name="ln3365">        NUM_FOODS,</a>
<a name="ln3366">        NUM_SCROLLS,</a>
<a name="ln3367">        NUM_JEWELLERY,</a>
<a name="ln3368">        NUM_POTIONS,</a>
<a name="ln3369">        NUM_BOOKS,</a>
<a name="ln3370">        NUM_STAVES,</a>
<a name="ln3371">        1,              // Orbs         -- only one</a>
<a name="ln3372">        NUM_MISCELLANY,</a>
<a name="ln3373">        -1,              // corpses     -- handled specially</a>
<a name="ln3374">        1,              // gold         -- handled specially</a>
<a name="ln3375">#if TAG_MAJOR_VERSION == 34</a>
<a name="ln3376">        NUM_RODS,</a>
<a name="ln3377">#endif</a>
<a name="ln3378">        NUM_RUNE_TYPES,</a>
<a name="ln3379">    };</a>
<a name="ln3380">    COMPILE_CHECK(ARRAYSZ(max_subtype) == NUM_OBJECT_CLASSES);</a>
<a name="ln3381"> </a>
<a name="ln3382">    ASSERT_RANGE(base_type, 0, NUM_OBJECT_CLASSES);</a>
<a name="ln3383"> </a>
<a name="ln3384">    return max_subtype[base_type];</a>
<a name="ln3385">}</a>
<a name="ln3386"> </a>
<a name="ln3387">equipment_type item_equip_slot(const item_def&amp; item)</a>
<a name="ln3388">{</a>
<a name="ln3389">    if (!in_inventory(item))</a>
<a name="ln3390">        return EQ_NONE;</a>
<a name="ln3391"> </a>
<a name="ln3392">    for (int i = EQ_FIRST_EQUIP; i &lt; NUM_EQUIP; i++)</a>
<a name="ln3393">        if (item.link == you.equip[i])</a>
<a name="ln3394">            return static_cast&lt;equipment_type&gt;(i);</a>
<a name="ln3395"> </a>
<a name="ln3396">    return EQ_NONE;</a>
<a name="ln3397">}</a>
<a name="ln3398"> </a>
<a name="ln3399">// Includes melded items.</a>
<a name="ln3400">bool item_is_equipped(const item_def &amp;item, bool quiver_too)</a>
<a name="ln3401">{</a>
<a name="ln3402">    return item_equip_slot(item) != EQ_NONE</a>
<a name="ln3403">           || quiver_too &amp;&amp; item_is_quivered(item);</a>
<a name="ln3404">}</a>
<a name="ln3405"> </a>
<a name="ln3406">bool item_is_melded(const item_def&amp; item)</a>
<a name="ln3407">{</a>
<a name="ln3408">    equipment_type eq = item_equip_slot(item);</a>
<a name="ln3409">    return eq != EQ_NONE &amp;&amp; you.melded[eq];</a>
<a name="ln3410">}</a>
<a name="ln3411"> </a>
<a name="ln3412">////////////////////////////////////////////////////////////////////////</a>
<a name="ln3413">// item_def functions.</a>
<a name="ln3414"> </a>
<a name="ln3415">bool item_def::has_spells() const</a>
<a name="ln3416">{</a>
<a name="ln3417">    return item_is_spellbook(*this) &amp;&amp; item_type_known(*this);</a>
<a name="ln3418">}</a>
<a name="ln3419"> </a>
<a name="ln3420">bool item_def::cursed() const</a>
<a name="ln3421">{</a>
<a name="ln3422">    return flags &amp; ISFLAG_CURSED;</a>
<a name="ln3423">}</a>
<a name="ln3424"> </a>
<a name="ln3425">bool item_def::launched_by(const item_def &amp;launcher) const</a>
<a name="ln3426">{</a>
<a name="ln3427">    if (base_type != OBJ_MISSILES)</a>
<a name="ln3428">        return false;</a>
<a name="ln3429">    const missile_type mt = fires_ammo_type(launcher);</a>
<a name="ln3430">    return sub_type == mt || (mt == MI_STONE &amp;&amp; sub_type == MI_SLING_BULLET);</a>
<a name="ln3431">}</a>
<a name="ln3432"> </a>
<a name="ln3433">int item_def::index() const</a>
<a name="ln3434">{</a>
<a name="ln3435">    return this - mitm.buffer();</a>
<a name="ln3436">}</a>
<a name="ln3437"> </a>
<a name="ln3438">int item_def::armour_rating() const</a>
<a name="ln3439">{</a>
<a name="ln3440">    if (!defined() || base_type != OBJ_ARMOUR)</a>
<a name="ln3441">        return 0;</a>
<a name="ln3442"> </a>
<a name="ln3443">    return property(*this, PARM_AC) + plus;</a>
<a name="ln3444">}</a>
<a name="ln3445"> </a>
<a name="ln3446">monster* item_def::holding_monster() const</a>
<a name="ln3447">{</a>
<a name="ln3448">    if (pos != ITEM_IN_MONSTER_INVENTORY)</a>
<a name="ln3449">        return nullptr;</a>
<a name="ln3450">    const int midx = link - NON_ITEM - 1;</a>
<a name="ln3451">    if (invalid_monster_index(midx))</a>
<a name="ln3452">        return nullptr;</a>
<a name="ln3453"> </a>
<a name="ln3454">    return &amp;menv[midx];</a>
<a name="ln3455">}</a>
<a name="ln3456"> </a>
<a name="ln3457">void item_def::set_holding_monster(const monster&amp; mon)</a>
<a name="ln3458">{</a>
<a name="ln3459">    pos = ITEM_IN_MONSTER_INVENTORY;</a>
<a name="ln3460">    link = NON_ITEM + 1 + mon.mindex();</a>
<a name="ln3461">}</a>
<a name="ln3462"> </a>
<a name="ln3463">// Note: should not check menv, since it may be called by link_items() from</a>
<a name="ln3464">// tags.cc before monsters are unmarshalled.</a>
<a name="ln3465">bool item_def::held_by_monster() const</a>
<a name="ln3466">{</a>
<a name="ln3467">    return pos == ITEM_IN_MONSTER_INVENTORY</a>
<a name="ln3468">             &amp;&amp; !invalid_monster_index(link - NON_ITEM - 1);</a>
<a name="ln3469">}</a>
<a name="ln3470"> </a>
<a name="ln3471">// Note:  This function is to isolate all the checks to see if</a>
<a name="ln3472">//        an item is valid (often just checking the quantity).</a>
<a name="ln3473">//</a>
<a name="ln3474">//        It shouldn't be used a a substitute for those cases</a>
<a name="ln3475">//        which actually want to check the quantity (as the</a>
<a name="ln3476">//        rules for unused objects might change).</a>
<a name="ln3477">bool item_def::defined() const</a>
<a name="ln3478">{</a>
<a name="ln3479">    return base_type != OBJ_UNASSIGNED &amp;&amp; quantity &gt; 0;</a>
<a name="ln3480">}</a>
<a name="ln3481">/**</a>
<a name="ln3482"> * Has this item's appearance been initialized?</a>
<a name="ln3483"> */</a>
<a name="ln3484">bool item_def::appearance_initialized() const</a>
<a name="ln3485">{</a>
<a name="ln3486">    return rnd != 0 || is_unrandom_artefact(*this);</a>
<a name="ln3487">}</a>
<a name="ln3488"> </a>
<a name="ln3489"> </a>
<a name="ln3490">/**</a>
<a name="ln3491"> * Assuming this item is a randart weapon/armour, what colour is it?</a>
<a name="ln3492"> */</a>
<a name="ln3493">colour_t item_def::randart_colour() const</a>
<a name="ln3494">{</a>
<a name="ln3495">    ASSERT(is_artefact(*this));</a>
<a name="ln3496">    static colour_t colours[] = { YELLOW, LIGHTGREEN, LIGHTRED, LIGHTMAGENTA };</a>
<a name="ln3497">    return colours[rnd % ARRAYSZ(colours)];</a>
<a name="ln3498">}</a>
<a name="ln3499"> </a>
<a name="ln3500">/**</a>
<a name="ln3501"> * Assuming this item is a weapon, what colour is it?</a>
<a name="ln3502"> */</a>
<a name="ln3503">colour_t item_def::weapon_colour() const</a>
<a name="ln3504">{</a>
<a name="ln3505">    ASSERT(base_type == OBJ_WEAPONS);</a>
<a name="ln3506"> </a>
<a name="ln3507">    // random artefact</a>
<a name="ln3508">    if (is_artefact(*this))</a>
<a name="ln3509">        return randart_colour();</a>
<a name="ln3510"> </a>
<a name="ln3511">    if (is_demonic(*this))</a>
<a name="ln3512">        return LIGHTRED;</a>
<a name="ln3513"> </a>
<a name="ln3514">    switch (item_attack_skill(*this))</a>
<a name="ln3515">    {</a>
<a name="ln3516">        case SK_BOWS:</a>
<a name="ln3517">            return BLUE;</a>
<a name="ln3518">        case SK_CROSSBOWS:</a>
<a name="ln3519">            return LIGHTBLUE;</a>
<a name="ln3520">        case SK_THROWING:</a>
<a name="ln3521">            return WHITE;</a>
<a name="ln3522">        case SK_SLINGS:</a>
<a name="ln3523">            return BROWN;</a>
<a name="ln3524">        case SK_SHORT_BLADES:</a>
<a name="ln3525">            return CYAN;</a>
<a name="ln3526">        case SK_LONG_BLADES:</a>
<a name="ln3527">            return LIGHTCYAN;</a>
<a name="ln3528">        case SK_AXES:</a>
<a name="ln3529">            return MAGENTA;</a>
<a name="ln3530">        case SK_MACES_FLAILS:</a>
<a name="ln3531">            return LIGHTGREY;</a>
<a name="ln3532">        case SK_POLEARMS:</a>
<a name="ln3533">            return RED;</a>
<a name="ln3534">        case SK_STAVES:</a>
<a name="ln3535">            return GREEN;</a>
<a name="ln3536">        default:</a>
<a name="ln3537">            die(&quot;Unknown weapon attack skill %d&quot;, item_attack_skill(*this));</a>
<a name="ln3538">            // XXX: give more info!</a>
<a name="ln3539">    }</a>
<a name="ln3540">}</a>
<a name="ln3541"> </a>
<a name="ln3542">/**</a>
<a name="ln3543"> * Assuming this item is a missile (stone/arrow/bolt/etc), what colour is it?</a>
<a name="ln3544"> */</a>
<a name="ln3545">colour_t item_def::missile_colour() const</a>
<a name="ln3546">{</a>
<a name="ln3547">    ASSERT(base_type == OBJ_MISSILES);</a>
<a name="ln3548"> </a>
<a name="ln3549">    // TODO: move this into item-prop.cc</a>
<a name="ln3550">    switch (sub_type)</a>
<a name="ln3551">    {</a>
<a name="ln3552">        case MI_STONE:</a>
<a name="ln3553">            return BROWN;</a>
<a name="ln3554">        case MI_SLING_BULLET:</a>
<a name="ln3555">            return CYAN;</a>
<a name="ln3556">        case MI_LARGE_ROCK:</a>
<a name="ln3557">            return LIGHTGREY;</a>
<a name="ln3558">        case MI_ARROW:</a>
<a name="ln3559">            return BLUE;</a>
<a name="ln3560">#if TAG_MAJOR_VERSION == 34</a>
<a name="ln3561">        case MI_NEEDLE:</a>
<a name="ln3562">#endif</a>
<a name="ln3563">        case MI_DART:</a>
<a name="ln3564">            return WHITE;</a>
<a name="ln3565">        case MI_BOLT:</a>
<a name="ln3566">            return LIGHTBLUE;</a>
<a name="ln3567">        case MI_JAVELIN:</a>
<a name="ln3568">            return RED;</a>
<a name="ln3569">        case MI_THROWING_NET:</a>
<a name="ln3570">            return MAGENTA;</a>
<a name="ln3571">        case MI_BOOMERANG:</a>
<a name="ln3572">            return GREEN;</a>
<a name="ln3573">        case NUM_SPECIAL_MISSILES:</a>
<a name="ln3574">        default:</a>
<a name="ln3575">            die(&quot;invalid missile type&quot;);</a>
<a name="ln3576">    }</a>
<a name="ln3577">}</a>
<a name="ln3578"> </a>
<a name="ln3579">/**</a>
<a name="ln3580"> * Assuming this item is a piece of armour, what colour is it?</a>
<a name="ln3581"> */</a>
<a name="ln3582">colour_t item_def::armour_colour() const</a>
<a name="ln3583">{</a>
<a name="ln3584">    ASSERT(base_type == OBJ_ARMOUR);</a>
<a name="ln3585"> </a>
<a name="ln3586">    if (is_artefact(*this))</a>
<a name="ln3587">        return randart_colour();</a>
<a name="ln3588"> </a>
<a name="ln3589">    if (armour_type_is_hide((armour_type)sub_type))</a>
<a name="ln3590">        return mons_class_colour(monster_for_hide((armour_type)sub_type));</a>
<a name="ln3591"> </a>
<a name="ln3592"> </a>
<a name="ln3593">    // TODO: move (some of?) this into item-prop.cc</a>
<a name="ln3594">    switch (sub_type)</a>
<a name="ln3595">    {</a>
<a name="ln3596">        case ARM_CLOAK:</a>
<a name="ln3597">        case ARM_SCARF:</a>
<a name="ln3598">            return WHITE;</a>
<a name="ln3599">        case ARM_NAGA_BARDING:</a>
<a name="ln3600">        case ARM_CENTAUR_BARDING:</a>
<a name="ln3601">            return GREEN;</a>
<a name="ln3602">        case ARM_ROBE:</a>
<a name="ln3603">            return RED;</a>
<a name="ln3604">#if TAG_MAJOR_VERSION == 34</a>
<a name="ln3605">        case ARM_CAP:</a>
<a name="ln3606">#endif</a>
<a name="ln3607">        case ARM_HAT:</a>
<a name="ln3608">        case ARM_HELMET:</a>
<a name="ln3609">            return MAGENTA;</a>
<a name="ln3610">        case ARM_BOOTS:</a>
<a name="ln3611">            return BLUE;</a>
<a name="ln3612">        case ARM_GLOVES:</a>
<a name="ln3613">            return LIGHTBLUE;</a>
<a name="ln3614">        case ARM_LEATHER_ARMOUR:</a>
<a name="ln3615">            return BROWN;</a>
<a name="ln3616">        case ARM_ANIMAL_SKIN:</a>
<a name="ln3617">            return LIGHTGREY;</a>
<a name="ln3618">        case ARM_CRYSTAL_PLATE_ARMOUR:</a>
<a name="ln3619">            return WHITE;</a>
<a name="ln3620">        case ARM_KITE_SHIELD:</a>
<a name="ln3621">        case ARM_TOWER_SHIELD:</a>
<a name="ln3622">        case ARM_BUCKLER:</a>
<a name="ln3623">            return CYAN;</a>
<a name="ln3624">        default:</a>
<a name="ln3625">            return LIGHTCYAN;</a>
<a name="ln3626">    }</a>
<a name="ln3627">}</a>
<a name="ln3628"> </a>
<a name="ln3629">/**</a>
<a name="ln3630"> * Assuming this item is a wand, what colour is it?</a>
<a name="ln3631"> */</a>
<a name="ln3632">colour_t item_def::wand_colour() const</a>
<a name="ln3633">{</a>
<a name="ln3634">    ASSERT(base_type == OBJ_WANDS);</a>
<a name="ln3635"> </a>
<a name="ln3636">    // this is very odd... a linleyism?</a>
<a name="ln3637">    // TODO: associate colours directly with names</a>
<a name="ln3638">    // (use an array of [name, colour] tuples/structs)</a>
<a name="ln3639">    switch (subtype_rnd % NDSC_WAND_PRI)</a>
<a name="ln3640">    {</a>
<a name="ln3641">        case 0:         //&quot;iron wand&quot;</a>
<a name="ln3642">            return CYAN;</a>
<a name="ln3643">        case 1:         //&quot;brass wand&quot;</a>
<a name="ln3644">        case 5:         //&quot;gold wand&quot;</a>
<a name="ln3645">            return YELLOW;</a>
<a name="ln3646">        case 3:         //&quot;wooden wand&quot;</a>
<a name="ln3647">        case 4:         //&quot;copper wand&quot;</a>
<a name="ln3648">        case 7:         //&quot;bronze wand&quot;</a>
<a name="ln3649">            return BROWN;</a>
<a name="ln3650">        case 6:         //&quot;silver wand&quot;</a>
<a name="ln3651">            return WHITE;</a>
<a name="ln3652">        case 11:        //&quot;fluorescent wand&quot;</a>
<a name="ln3653">            return LIGHTGREEN;</a>
<a name="ln3654">        case 2:         //&quot;bone wand&quot;</a>
<a name="ln3655">        case 8:         //&quot;ivory wand&quot;</a>
<a name="ln3656">        case 9:         //&quot;glass wand&quot;</a>
<a name="ln3657">        case 10:        //&quot;lead wand&quot;</a>
<a name="ln3658">        default:</a>
<a name="ln3659">            return LIGHTGREY;</a>
<a name="ln3660">    }</a>
<a name="ln3661">}</a>
<a name="ln3662"> </a>
<a name="ln3663">/**</a>
<a name="ln3664"> * Assuming this item is a potion, what colour is it?</a>
<a name="ln3665"> */</a>
<a name="ln3666">colour_t item_def::potion_colour() const</a>
<a name="ln3667">{</a>
<a name="ln3668">    ASSERT(base_type == OBJ_POTIONS);</a>
<a name="ln3669"> </a>
<a name="ln3670">    // TODO: associate colours directly with names</a>
<a name="ln3671">    // (use an array of [name, colour] tuples/structs)</a>
<a name="ln3672">    static const COLOURS potion_colours[] =</a>
<a name="ln3673">    {</a>
<a name="ln3674">#if TAG_MAJOR_VERSION == 34</a>
<a name="ln3675">        // clear</a>
<a name="ln3676">        LIGHTGREY,</a>
<a name="ln3677">#endif</a>
<a name="ln3678">        // blue, black, silvery, cyan, purple, orange</a>
<a name="ln3679">        BLUE, LIGHTGREY, WHITE, CYAN, MAGENTA, LIGHTRED,</a>
<a name="ln3680">        // inky, red, yellow, green, brown, pink, white</a>
<a name="ln3681">        BLUE, RED, YELLOW, GREEN, BROWN, LIGHTMAGENTA, WHITE,</a>
<a name="ln3682">        // emerald, grey, pink, copper, gold, dark, puce</a>
<a name="ln3683">        LIGHTGREEN, LIGHTGREY, LIGHTRED, YELLOW, YELLOW, BROWN, BROWN,</a>
<a name="ln3684">        // amethyst, sapphire</a>
<a name="ln3685">        MAGENTA, BLUE</a>
<a name="ln3686">    };</a>
<a name="ln3687">    COMPILE_CHECK(ARRAYSZ(potion_colours) == NDSC_POT_PRI);</a>
<a name="ln3688">    return potion_colours[subtype_rnd % NDSC_POT_PRI];</a>
<a name="ln3689">}</a>
<a name="ln3690"> </a>
<a name="ln3691">/**</a>
<a name="ln3692"> * Assuming this item is a piece of food, what colour is it?</a>
<a name="ln3693"> */</a>
<a name="ln3694">colour_t item_def::food_colour() const</a>
<a name="ln3695">{</a>
<a name="ln3696">    ASSERT(base_type == OBJ_FOOD);</a>
<a name="ln3697"> </a>
<a name="ln3698">    switch (sub_type)</a>
<a name="ln3699">    {</a>
<a name="ln3700">        case FOOD_CHUNK:</a>
<a name="ln3701">            return LIGHTRED;</a>
<a name="ln3702">        case FOOD_RATION:</a>
<a name="ln3703">        default:</a>
<a name="ln3704">            return BROWN;</a>
<a name="ln3705">    }</a>
<a name="ln3706">}</a>
<a name="ln3707"> </a>
<a name="ln3708">/**</a>
<a name="ln3709"> * Assuming this item is a ring, what colour is it?</a>
<a name="ln3710"> */</a>
<a name="ln3711">colour_t item_def::ring_colour() const</a>
<a name="ln3712">{</a>
<a name="ln3713">    ASSERT(!jewellery_is_amulet(*this));</a>
<a name="ln3714">    // jewellery_is_amulet asserts base type</a>
<a name="ln3715"> </a>
<a name="ln3716">    // TODO: associate colours directly with names</a>
<a name="ln3717">    // (use an array of [name, colour] tuples/structs)</a>
<a name="ln3718">    switch (subtype_rnd % NDSC_JEWEL_PRI)</a>
<a name="ln3719">    {</a>
<a name="ln3720">        case 1:                 // &quot;silver ring&quot;</a>
<a name="ln3721">        case 8:                 // &quot;granite ring&quot;</a>
<a name="ln3722">        case 9:                 // &quot;ivory ring&quot;</a>
<a name="ln3723">        case 15:                // &quot;bone ring&quot;</a>
<a name="ln3724">        case 16:                // &quot;diamond ring&quot;</a>
<a name="ln3725">        case 20:                // &quot;opal ring&quot;</a>
<a name="ln3726">        case 21:                // &quot;pearl ring&quot;</a>
<a name="ln3727">        case 26:                // &quot;onyx ring&quot;</a>
<a name="ln3728">            return LIGHTGREY;</a>
<a name="ln3729">        case 3:                 // &quot;iron ring&quot;</a>
<a name="ln3730">        case 4:                 // &quot;steel ring&quot;</a>
<a name="ln3731">        case 13:                // &quot;glass ring&quot;</a>
<a name="ln3732">            return CYAN;</a>
<a name="ln3733">        case 5:                 // &quot;tourmaline ring&quot;</a>
<a name="ln3734">        case 22:                // &quot;coral ring&quot;</a>
<a name="ln3735">            return MAGENTA;</a>
<a name="ln3736">        case 10:                // &quot;ruby ring&quot;</a>
<a name="ln3737">        case 19:                // &quot;garnet ring&quot;</a>
<a name="ln3738">            return RED;</a>
<a name="ln3739">        case 11:                // &quot;marble ring&quot;</a>
<a name="ln3740">        case 12:                // &quot;jade ring&quot;</a>
<a name="ln3741">        case 14:                // &quot;agate ring&quot;</a>
<a name="ln3742">        case 17:                // &quot;emerald ring&quot;</a>
<a name="ln3743">        case 18:                // &quot;peridot ring&quot;</a>
<a name="ln3744">            return GREEN;</a>
<a name="ln3745">        case 23:                // &quot;sapphire ring&quot;</a>
<a name="ln3746">        case 24:                // &quot;cabochon ring&quot;</a>
<a name="ln3747">        case 28:                // &quot;moonstone ring&quot;</a>
<a name="ln3748">            return BLUE;</a>
<a name="ln3749">        case 0:                 // &quot;wooden ring&quot;</a>
<a name="ln3750">        case 2:                 // &quot;golden ring&quot;</a>
<a name="ln3751">        case 6:                 // &quot;brass ring&quot;</a>
<a name="ln3752">        case 7:                 // &quot;copper ring&quot;</a>
<a name="ln3753">        case 25:                // &quot;gilded ring&quot;</a>
<a name="ln3754">        case 27:                // &quot;bronze ring&quot;</a>
<a name="ln3755">        default:</a>
<a name="ln3756">            return BROWN;</a>
<a name="ln3757">    }</a>
<a name="ln3758">}</a>
<a name="ln3759"> </a>
<a name="ln3760">/**</a>
<a name="ln3761"> * Assuming this item is an amulet, what colour is it?</a>
<a name="ln3762"> */</a>
<a name="ln3763">colour_t item_def::amulet_colour() const</a>
<a name="ln3764">{</a>
<a name="ln3765">    ASSERT(jewellery_is_amulet(*this));</a>
<a name="ln3766">    // jewellery_is_amulet asserts base type</a>
<a name="ln3767"> </a>
<a name="ln3768">    // TODO: associate colours directly with names</a>
<a name="ln3769">    // (use an array of [name, colour] tuples/structs)</a>
<a name="ln3770">    switch (subtype_rnd % NDSC_JEWEL_PRI)</a>
<a name="ln3771">    {</a>
<a name="ln3772">        case 1:             // &quot;zirconium amulet&quot;</a>
<a name="ln3773">        case 10:            // &quot;bone amulet&quot;</a>
<a name="ln3774">        case 11:            // &quot;platinum amulet&quot;</a>
<a name="ln3775">        case 16:            // &quot;pearl amulet&quot;</a>
<a name="ln3776">        case 20:            // &quot;diamond amulet&quot;</a>
<a name="ln3777">            return LIGHTGREY;</a>
<a name="ln3778">        case 0:             // &quot;sapphire amulet&quot;</a>
<a name="ln3779">        case 17:            // &quot;blue amulet&quot;</a>
<a name="ln3780">        case 26:            // &quot;lapis lazuli amulet&quot;</a>
<a name="ln3781">            return BLUE;</a>
<a name="ln3782">        case 3:             // &quot;emerald amulet&quot;</a>
<a name="ln3783">        case 12:            // &quot;jade amulet&quot;</a>
<a name="ln3784">        case 18:            // &quot;peridot amulet&quot;</a>
<a name="ln3785">        case 21:            // &quot;malachite amulet&quot;</a>
<a name="ln3786">        case 25:            // &quot;soapstone amulet&quot;</a>
<a name="ln3787">        case 28:            // &quot;beryl amulet&quot;</a>
<a name="ln3788">            return GREEN;</a>
<a name="ln3789">        case 4:             // &quot;garnet amulet&quot;</a>
<a name="ln3790">        case 8:             // &quot;ruby amulet&quot;</a>
<a name="ln3791">        case 19:            // &quot;jasper amulet&quot;</a>
<a name="ln3792">        case 15:            // &quot;cameo amulet&quot;</a>
<a name="ln3793">            return RED;</a>
<a name="ln3794">        case 22:            // &quot;steel amulet&quot;</a>
<a name="ln3795">        case 24:            // &quot;silver amulet&quot;</a>
<a name="ln3796">        case 27:            // &quot;filigree amulet&quot;</a>
<a name="ln3797">            return CYAN;</a>
<a name="ln3798">        case 13:            // &quot;fluorescent amulet&quot;</a>
<a name="ln3799">        case 14:            // &quot;amethyst amulet&quot;</a>
<a name="ln3800">        case 23:            // &quot;cabochon amulet&quot;</a>
<a name="ln3801">            return MAGENTA;</a>
<a name="ln3802">        case 2:             // &quot;golden amulet&quot;</a>
<a name="ln3803">        case 5:             // &quot;bronze amulet&quot;</a>
<a name="ln3804">        case 6:             // &quot;brass amulet&quot;</a>
<a name="ln3805">        case 7:             // &quot;copper amulet&quot;</a>
<a name="ln3806">        case 9:             // &quot;citrine amulet&quot;</a>
<a name="ln3807">        default:</a>
<a name="ln3808">            return BROWN;</a>
<a name="ln3809">    }</a>
<a name="ln3810">}</a>
<a name="ln3811"> </a>
<a name="ln3812">/**</a>
<a name="ln3813"> * Assuming this is a piece of jewellery (ring or amulet), what colour is it?</a>
<a name="ln3814"> */</a>
<a name="ln3815">colour_t item_def::jewellery_colour() const</a>
<a name="ln3816">{</a>
<a name="ln3817">    ASSERT(base_type == OBJ_JEWELLERY);</a>
<a name="ln3818"> </a>
<a name="ln3819">    //randarts are bright, normal jewellery is dark</a>
<a name="ln3820">    if (is_random_artefact(*this))</a>
<a name="ln3821">        return LIGHTGREEN + (rnd % (WHITE - LIGHTGREEN + 1));</a>
<a name="ln3822"> </a>
<a name="ln3823">    if (jewellery_is_amulet(*this))</a>
<a name="ln3824">        return amulet_colour();</a>
<a name="ln3825">    return ring_colour();</a>
<a name="ln3826">}</a>
<a name="ln3827"> </a>
<a name="ln3828">/**</a>
<a name="ln3829"> * Assuming this item is a book, what colour is it?</a>
<a name="ln3830"> */</a>
<a name="ln3831">colour_t item_def::book_colour() const</a>
<a name="ln3832">{</a>
<a name="ln3833">    ASSERT(base_type == OBJ_BOOKS);</a>
<a name="ln3834"> </a>
<a name="ln3835">    if (sub_type == BOOK_MANUAL)</a>
<a name="ln3836">        return WHITE;</a>
<a name="ln3837"> </a>
<a name="ln3838">    switch (rnd % NDSC_BOOK_PRI)</a>
<a name="ln3839">    {</a>
<a name="ln3840">        case 0:</a>
<a name="ln3841">            return BROWN;</a>
<a name="ln3842">        case 1:</a>
<a name="ln3843">            return CYAN;</a>
<a name="ln3844">        case 2:</a>
<a name="ln3845">            return LIGHTGREY;</a>
<a name="ln3846">        case 3:</a>
<a name="ln3847">        case 4:</a>
<a name="ln3848">        default:</a>
<a name="ln3849">        {</a>
<a name="ln3850">            /// everything but BLACK, WHITE (manuals), and DARKGREY (useless)</a>
<a name="ln3851">            static const colour_t colours[] = {</a>
<a name="ln3852">                BLUE, GREEN, CYAN, RED, MAGENTA, BROWN, LIGHTGREY, LIGHTBLUE,</a>
<a name="ln3853">                LIGHTGREEN, LIGHTCYAN, LIGHTRED, LIGHTMAGENTA, YELLOW</a>
<a name="ln3854">            };</a>
<a name="ln3855">            return colours[rnd % ARRAYSZ(colours)];</a>
<a name="ln3856">        }</a>
<a name="ln3857">    }</a>
<a name="ln3858">}</a>
<a name="ln3859"> </a>
<a name="ln3860">/**</a>
<a name="ln3861"> * Assuming this item is a Rune of Zot, what colour is it?</a>
<a name="ln3862"> */</a>
<a name="ln3863">colour_t item_def::rune_colour() const</a>
<a name="ln3864">{</a>
<a name="ln3865">    switch (sub_type)</a>
<a name="ln3866">    {</a>
<a name="ln3867">        case RUNE_DIS:                      // iron</a>
<a name="ln3868">            return ETC_IRON;</a>
<a name="ln3869"> </a>
<a name="ln3870">        case RUNE_COCYTUS:                  // icy</a>
<a name="ln3871">            return ETC_ICE;</a>
<a name="ln3872"> </a>
<a name="ln3873">        case RUNE_TARTARUS:                 // bone</a>
<a name="ln3874">        case RUNE_SPIDER:</a>
<a name="ln3875">            return ETC_BONE;</a>
<a name="ln3876"> </a>
<a name="ln3877">        case RUNE_SLIME:                    // slimy</a>
<a name="ln3878">            return ETC_SLIME;</a>
<a name="ln3879"> </a>
<a name="ln3880">        case RUNE_SNAKE:                    // serpentine</a>
<a name="ln3881">            return ETC_POISON;</a>
<a name="ln3882"> </a>
<a name="ln3883">        case RUNE_ELF:                      // elven</a>
<a name="ln3884">            return ETC_ELVEN;</a>
<a name="ln3885"> </a>
<a name="ln3886">        case RUNE_VAULTS:                   // silver</a>
<a name="ln3887">            return ETC_SILVER;</a>
<a name="ln3888"> </a>
<a name="ln3889">        case RUNE_TOMB:                     // golden</a>
<a name="ln3890">            return ETC_GOLD;</a>
<a name="ln3891"> </a>
<a name="ln3892">        case RUNE_SWAMP:                    // decaying</a>
<a name="ln3893">            return ETC_DECAY;</a>
<a name="ln3894"> </a>
<a name="ln3895">        case RUNE_SHOALS:                   // barnacled</a>
<a name="ln3896">            return ETC_WATER;</a>
<a name="ln3897"> </a>
<a name="ln3898">            // This one is hardly unique, but colour isn't used for</a>
<a name="ln3899">            // stacking, so we don't have to worry too much about this.</a>
<a name="ln3900">            // - bwr</a>
<a name="ln3901">        case RUNE_DEMONIC:                  // random Pandemonium lords</a>
<a name="ln3902">        {</a>
<a name="ln3903">            static const element_type types[] =</a>
<a name="ln3904">            {ETC_EARTH, ETC_ELECTRICITY, ETC_ENCHANT, ETC_HEAL, ETC_BLOOD,</a>
<a name="ln3905">             ETC_DEATH, ETC_UNHOLY, ETC_VEHUMET, ETC_BEOGH, ETC_CRYSTAL,</a>
<a name="ln3906">             ETC_SMOKE, ETC_DWARVEN, ETC_ORCISH, ETC_FLASH};</a>
<a name="ln3907"> </a>
<a name="ln3908">            return types[rnd % ARRAYSZ(types)];</a>
<a name="ln3909">        }</a>
<a name="ln3910"> </a>
<a name="ln3911">        case RUNE_ABYSSAL:</a>
<a name="ln3912">            return ETC_RANDOM;</a>
<a name="ln3913"> </a>
<a name="ln3914">        case RUNE_MNOLEG:                   // glowing</a>
<a name="ln3915">            return ETC_MUTAGENIC;</a>
<a name="ln3916"> </a>
<a name="ln3917">        case RUNE_LOM_LOBON:                // magical</a>
<a name="ln3918">            return ETC_MAGIC;</a>
<a name="ln3919"> </a>
<a name="ln3920">        case RUNE_CEREBOV:                  // fiery</a>
<a name="ln3921">            return ETC_FIRE;</a>
<a name="ln3922"> </a>
<a name="ln3923">        case RUNE_GEHENNA:                  // obsidian</a>
<a name="ln3924">        case RUNE_GLOORX_VLOQ:              // dark</a>
<a name="ln3925">        default:</a>
<a name="ln3926">            return ETC_DARK;</a>
<a name="ln3927">    }</a>
<a name="ln3928">}</a>
<a name="ln3929"> </a>
<a name="ln3930">static colour_t _zigfig_colour()</a>
<a name="ln3931">{</a>
<a name="ln3932">    const int zigs = you.zigs_completed;</a>
<a name="ln3933">    return zigs &gt;= 27 ? ETC_JEWEL :</a>
<a name="ln3934">           zigs &gt;=  9 ? ETC_FLASH :</a>
<a name="ln3935">           zigs &gt;=  3 ? ETC_MAGIC :</a>
<a name="ln3936">           zigs &gt;=  1 ? ETC_SHIMMER_BLUE :</a>
<a name="ln3937">                        ETC_BONE;</a>
<a name="ln3938">}</a>
<a name="ln3939"> </a>
<a name="ln3940">/**</a>
<a name="ln3941"> * Assuming this item is a miscellaneous item (evocations item or a rune), what</a>
<a name="ln3942"> * colour is it?</a>
<a name="ln3943"> */</a>
<a name="ln3944">colour_t item_def::miscellany_colour() const</a>
<a name="ln3945">{</a>
<a name="ln3946">    ASSERT(base_type == OBJ_MISCELLANY);</a>
<a name="ln3947"> </a>
<a name="ln3948">    switch (sub_type)</a>
<a name="ln3949">    {</a>
<a name="ln3950">#if TAG_MAJOR_VERSION == 34</a>
<a name="ln3951">        case MISC_FAN_OF_GALES:</a>
<a name="ln3952">            return CYAN;</a>
<a name="ln3953">        case MISC_BOTTLED_EFREET:</a>
<a name="ln3954">            return RED;</a>
<a name="ln3955">#endif</a>
<a name="ln3956">        case MISC_PHANTOM_MIRROR:</a>
<a name="ln3957">            return RED;</a>
<a name="ln3958">#if TAG_MAJOR_VERSION == 34</a>
<a name="ln3959">        case MISC_STONE_OF_TREMORS:</a>
<a name="ln3960">            return BROWN;</a>
<a name="ln3961">#endif</a>
<a name="ln3962">        case MISC_LIGHTNING_ROD:</a>
<a name="ln3963">            return LIGHTGREY;</a>
<a name="ln3964">        case MISC_PHIAL_OF_FLOODS:</a>
<a name="ln3965">            return LIGHTBLUE;</a>
<a name="ln3966">        case MISC_BOX_OF_BEASTS:</a>
<a name="ln3967">            return LIGHTGREEN; // ugh, but we're out of other options</a>
<a name="ln3968">#if TAG_MAJOR_VERSION == 34</a>
<a name="ln3969">        case MISC_CRYSTAL_BALL_OF_ENERGY:</a>
<a name="ln3970">            return LIGHTCYAN;</a>
<a name="ln3971">#endif</a>
<a name="ln3972">        case MISC_HORN_OF_GERYON:</a>
<a name="ln3973">            return LIGHTRED;</a>
<a name="ln3974">#if TAG_MAJOR_VERSION == 34</a>
<a name="ln3975">        case MISC_LAMP_OF_FIRE:</a>
<a name="ln3976">            return YELLOW;</a>
<a name="ln3977">        case MISC_SACK_OF_SPIDERS:</a>
<a name="ln3978">            return WHITE;</a>
<a name="ln3979">        case MISC_BUGGY_LANTERN_OF_SHADOWS:</a>
<a name="ln3980">        case MISC_BUGGY_EBONY_CASKET:</a>
<a name="ln3981">        case MISC_XOMS_CHESSBOARD:</a>
<a name="ln3982">            return DARKGREY;</a>
<a name="ln3983">#endif</a>
<a name="ln3984">        case MISC_TIN_OF_TREMORSTONES:</a>
<a name="ln3985">            return BROWN;</a>
<a name="ln3986">        case MISC_QUAD_DAMAGE:</a>
<a name="ln3987">            return ETC_DARK;</a>
<a name="ln3988">        case MISC_ZIGGURAT:</a>
<a name="ln3989">            return _zigfig_colour();</a>
<a name="ln3990">        default:</a>
<a name="ln3991">            return LIGHTGREEN;</a>
<a name="ln3992">    }</a>
<a name="ln3993">}</a>
<a name="ln3994"> </a>
<a name="ln3995">/**</a>
<a name="ln3996"> * Assuming this item is a corpse, what colour is it?</a>
<a name="ln3997"> */</a>
<a name="ln3998">colour_t item_def::corpse_colour() const</a>
<a name="ln3999">{</a>
<a name="ln4000">    ASSERT(base_type == OBJ_CORPSES);</a>
<a name="ln4001"> </a>
<a name="ln4002">    switch (sub_type)</a>
<a name="ln4003">    {</a>
<a name="ln4004">        case CORPSE_SKELETON:</a>
<a name="ln4005">            return LIGHTGREY;</a>
<a name="ln4006">        case CORPSE_BODY:</a>
<a name="ln4007">        {</a>
<a name="ln4008">            const colour_t class_colour = mons_class_colour(mon_type);</a>
<a name="ln4009">#if TAG_MAJOR_VERSION == 34</a>
<a name="ln4010">            if (class_colour == COLOUR_UNDEF)</a>
<a name="ln4011">                return LIGHTRED;</a>
<a name="ln4012">#else</a>
<a name="ln4013">            ASSERT(class_colour != COLOUR_UNDEF);</a>
<a name="ln4014">#endif</a>
<a name="ln4015">            return class_colour;</a>
<a name="ln4016">        }</a>
<a name="ln4017">        default:</a>
<a name="ln4018">            die(&quot;Unknown corpse type: %d&quot;, sub_type); // XXX: add more info</a>
<a name="ln4019">    }</a>
<a name="ln4020">}</a>
<a name="ln4021"> </a>
<a name="ln4022">/**</a>
<a name="ln4023"> * What colour is this item?</a>
<a name="ln4024"> *</a>
<a name="ln4025"> * @return The colour that the item should be displayed as.</a>
<a name="ln4026"> *         Used for console glyphs.</a>
<a name="ln4027"> */</a>
<a name="ln4028">colour_t item_def::get_colour() const</a>
<a name="ln4029">{</a>
<a name="ln4030">    // props take first priority</a>
<a name="ln4031">    if (props.exists(FORCED_ITEM_COLOUR_KEY))</a>
<a name="ln4032">    {</a>
<a name="ln4033">        const colour_t colour = props[FORCED_ITEM_COLOUR_KEY].get_int();</a>
<a name="ln4034">        ASSERT(colour);</a>
<a name="ln4035">        return colour;</a>
<a name="ln4036">    }</a>
<a name="ln4037"> </a>
<a name="ln4038">    // unrands get to override everything else (wrt colour)</a>
<a name="ln4039">    if (is_unrandom_artefact(*this))</a>
<a name="ln4040">    {</a>
<a name="ln4041">        const unrandart_entry *unrand = get_unrand_entry(</a>
<a name="ln4042">                                            find_unrandart_index(*this));</a>
<a name="ln4043">        ASSERT(unrand);</a>
<a name="ln4044">        ASSERT(unrand-&gt;colour);</a>
<a name="ln4045">        return unrand-&gt;colour;</a>
<a name="ln4046">    }</a>
<a name="ln4047"> </a>
<a name="ln4048">    switch (base_type)</a>
<a name="ln4049">    {</a>
<a name="ln4050">        case OBJ_WEAPONS:</a>
<a name="ln4051">            return weapon_colour();</a>
<a name="ln4052">        case OBJ_MISSILES:</a>
<a name="ln4053">            return missile_colour();</a>
<a name="ln4054">        case OBJ_ARMOUR:</a>
<a name="ln4055">            return armour_colour();</a>
<a name="ln4056">        case OBJ_WANDS:</a>
<a name="ln4057">            return wand_colour();</a>
<a name="ln4058">        case OBJ_POTIONS:</a>
<a name="ln4059">            return potion_colour();</a>
<a name="ln4060">        case OBJ_FOOD:</a>
<a name="ln4061">            return food_colour();</a>
<a name="ln4062">        case OBJ_JEWELLERY:</a>
<a name="ln4063">            return jewellery_colour();</a>
<a name="ln4064">        case OBJ_SCROLLS:</a>
<a name="ln4065">            return LIGHTGREY;</a>
<a name="ln4066">        case OBJ_BOOKS:</a>
<a name="ln4067">            return book_colour();</a>
<a name="ln4068">#if TAG_MAJOR_VERSION == 34</a>
<a name="ln4069">        case OBJ_RODS:</a>
<a name="ln4070">            return YELLOW;</a>
<a name="ln4071">#endif</a>
<a name="ln4072">        case OBJ_STAVES:</a>
<a name="ln4073">            return BROWN;</a>
<a name="ln4074">        case OBJ_ORBS:</a>
<a name="ln4075">            return ETC_MUTAGENIC;</a>
<a name="ln4076">        case OBJ_CORPSES:</a>
<a name="ln4077">            return corpse_colour();</a>
<a name="ln4078">        case OBJ_MISCELLANY:</a>
<a name="ln4079">            return miscellany_colour();</a>
<a name="ln4080">        case OBJ_GOLD:</a>
<a name="ln4081">            return YELLOW;</a>
<a name="ln4082">        case OBJ_RUNES:</a>
<a name="ln4083">            return rune_colour();</a>
<a name="ln4084">        case OBJ_DETECTED:</a>
<a name="ln4085">            return Options.detected_item_colour;</a>
<a name="ln4086">        case NUM_OBJECT_CLASSES:</a>
<a name="ln4087">        case OBJ_UNASSIGNED:</a>
<a name="ln4088">        case OBJ_RANDOM: // not sure what to do with these three</a>
<a name="ln4089">        default:</a>
<a name="ln4090">            return LIGHTGREY;</a>
<a name="ln4091">    }</a>
<a name="ln4092">}</a>
<a name="ln4093"> </a>
<a name="ln4094">bool item_type_has_unidentified(object_class_type base_type)</a>
<a name="ln4095">{</a>
<a name="ln4096">    return base_type == OBJ_WANDS</a>
<a name="ln4097">        || base_type == OBJ_SCROLLS</a>
<a name="ln4098">        || base_type == OBJ_JEWELLERY</a>
<a name="ln4099">        || base_type == OBJ_POTIONS</a>
<a name="ln4100">        || base_type == OBJ_BOOKS</a>
<a name="ln4101">        || base_type == OBJ_STAVES</a>
<a name="ln4102">        || base_type == OBJ_MISCELLANY</a>
<a name="ln4103">#if TAG_MAJOR_VERSION == 34</a>
<a name="ln4104">        || base_type == OBJ_RODS</a>
<a name="ln4105">#endif</a>
<a name="ln4106">        ;</a>
<a name="ln4107">}</a>
<a name="ln4108"> </a>
<a name="ln4109">// Checks whether the item is actually a good one.</a>
<a name="ln4110">// TODO: check brands, etc.</a>
<a name="ln4111">bool item_def::is_valid(bool iinfo) const</a>
<a name="ln4112">{</a>
<a name="ln4113">    if (base_type == OBJ_DETECTED)</a>
<a name="ln4114">    {</a>
<a name="ln4115">        if (!iinfo)</a>
<a name="ln4116">            dprf(&quot;weird detected item&quot;);</a>
<a name="ln4117">        return iinfo;</a>
<a name="ln4118">    }</a>
<a name="ln4119">    else if (!defined())</a>
<a name="ln4120">    {</a>
<a name="ln4121">        dprf(&quot;undefined&quot;);</a>
<a name="ln4122">        return false;</a>
<a name="ln4123">    }</a>
<a name="ln4124">    const int max_sub = get_max_subtype(base_type);</a>
<a name="ln4125">    if (max_sub != -1 &amp;&amp; sub_type &gt;= max_sub)</a>
<a name="ln4126">    {</a>
<a name="ln4127">        if (!iinfo || sub_type &gt; max_sub || !item_type_has_unidentified(base_type))</a>
<a name="ln4128">        {</a>
<a name="ln4129">            if (!iinfo)</a>
<a name="ln4130">                dprf(&quot;weird subtype and no info&quot;);</a>
<a name="ln4131">            if (sub_type &gt; max_sub)</a>
<a name="ln4132">                dprf(&quot;huge subtype&quot;);</a>
<a name="ln4133">            if (!item_type_has_unidentified(base_type))</a>
<a name="ln4134">                dprf(&quot;unided item of a type that can't be&quot;);</a>
<a name="ln4135">            return false;</a>
<a name="ln4136">        }</a>
<a name="ln4137">    }</a>
<a name="ln4138">    if (get_colour() == 0)</a>
<a name="ln4139">    {</a>
<a name="ln4140">        dprf(&quot;black item&quot;);</a>
<a name="ln4141">        return false; // No black items.</a>
<a name="ln4142">    }</a>
<a name="ln4143">    if (!appearance_initialized())</a>
<a name="ln4144">    {</a>
<a name="ln4145">        dprf(&quot;no rnd&quot;);</a>
<a name="ln4146">        return false; // no items with uninitialized rnd</a>
<a name="ln4147">    }</a>
<a name="ln4148">    return true;</a>
<a name="ln4149">}</a>
<a name="ln4150"> </a>
<a name="ln4151">// The Orb of Zot and unique runes are considered critical.</a>
<a name="ln4152">bool item_def::is_critical() const</a>
<a name="ln4153">{</a>
<a name="ln4154">    if (!defined())</a>
<a name="ln4155">        return false;</a>
<a name="ln4156"> </a>
<a name="ln4157">    if (base_type == OBJ_ORBS)</a>
<a name="ln4158">        return true;</a>
<a name="ln4159"> </a>
<a name="ln4160">    return item_is_unique_rune(*this);</a>
<a name="ln4161">}</a>
<a name="ln4162"> </a>
<a name="ln4163">// Is item something that no one would usually bother enchanting?</a>
<a name="ln4164">bool item_def::is_mundane() const</a>
<a name="ln4165">{</a>
<a name="ln4166">    switch (base_type)</a>
<a name="ln4167">    {</a>
<a name="ln4168">    case OBJ_WEAPONS:</a>
<a name="ln4169">        if (sub_type == WPN_CLUB</a>
<a name="ln4170">            || is_giant_club_type(sub_type))</a>
<a name="ln4171">        {</a>
<a name="ln4172">            return true;</a>
<a name="ln4173">        }</a>
<a name="ln4174">        break;</a>
<a name="ln4175"> </a>
<a name="ln4176">    case OBJ_ARMOUR:</a>
<a name="ln4177">        if (sub_type == ARM_ANIMAL_SKIN)</a>
<a name="ln4178">            return true;</a>
<a name="ln4179">        break;</a>
<a name="ln4180"> </a>
<a name="ln4181">    default:</a>
<a name="ln4182">        break;</a>
<a name="ln4183">    }</a>
<a name="ln4184"> </a>
<a name="ln4185">    return false;</a>
<a name="ln4186">}</a>
<a name="ln4187"> </a>
<a name="ln4188">static void _rune_from_specs(const char* _specs, item_def &amp;item)</a>
<a name="ln4189">{</a>
<a name="ln4190">    char specs[80];</a>
<a name="ln4191"> </a>
<a name="ln4192">    if (strstr(_specs, &quot;rune of zot&quot;))</a>
<a name="ln4193">    {</a>
<a name="ln4194">        strlcpy(specs, _specs, min(strlen(_specs) - strlen(&quot; of zot&quot;) + 1,</a>
<a name="ln4195">                                   sizeof(specs)));</a>
<a name="ln4196">    }</a>
<a name="ln4197">    else</a>
<a name="ln4198">        strlcpy(specs, _specs, sizeof(specs));</a>
<a name="ln4199"> </a>
<a name="ln4200">    if (strlen(specs) &gt; 4)</a>
<a name="ln4201">    {</a>
<a name="ln4202">        for (int i = 0; i &lt; NUM_RUNE_TYPES; ++i)</a>
<a name="ln4203">        {</a>
<a name="ln4204">            item.sub_type = i;</a>
<a name="ln4205"> </a>
<a name="ln4206">            if (lowercase_string(item.name(DESC_PLAIN)).find(specs) != string::npos)</a>
<a name="ln4207">                return;</a>
<a name="ln4208">        }</a>
<a name="ln4209">    }</a>
<a name="ln4210"> </a>
<a name="ln4211">    while (true)</a>
<a name="ln4212">    {</a>
<a name="ln4213">        string line;</a>
<a name="ln4214">        for (int i = 0; i &lt; NUM_RUNE_TYPES; i++)</a>
<a name="ln4215">        {</a>
<a name="ln4216">            line += make_stringf(&quot;[%c] %-10s &quot;, i + 'a', rune_type_name(i));</a>
<a name="ln4217">            if (i % 5 == 4 || i == NUM_RUNE_TYPES - 1)</a>
<a name="ln4218">            {</a>
<a name="ln4219">                mprf(MSGCH_PROMPT, &quot;%s&quot;, line.c_str());</a>
<a name="ln4220">                line.clear();</a>
<a name="ln4221">            }</a>
<a name="ln4222">        }</a>
<a name="ln4223">        mprf(MSGCH_PROMPT, &quot;Which rune (ESC to exit)? &quot;);</a>
<a name="ln4224"> </a>
<a name="ln4225">        int keyin = toalower(get_ch());</a>
<a name="ln4226"> </a>
<a name="ln4227">        if (key_is_escape(keyin) || keyin == ' '</a>
<a name="ln4228">            || keyin == '\r' || keyin == '\n')</a>
<a name="ln4229">        {</a>
<a name="ln4230">            canned_msg(MSG_OK);</a>
<a name="ln4231">            item.base_type = OBJ_UNASSIGNED;</a>
<a name="ln4232">            return;</a>
<a name="ln4233">        }</a>
<a name="ln4234"> </a>
<a name="ln4235">        if (keyin &lt; 'a' || keyin &gt;= 'a' + NUM_RUNE_TYPES)</a>
<a name="ln4236">            continue;</a>
<a name="ln4237"> </a>
<a name="ln4238">        item.sub_type = keyin - 'a';</a>
<a name="ln4239"> </a>
<a name="ln4240">        return;</a>
<a name="ln4241">    }</a>
<a name="ln4242">}</a>
<a name="ln4243"> </a>
<a name="ln4244">static bool _book_from_spell(const char* specs, item_def &amp;item)</a>
<a name="ln4245">{</a>
<a name="ln4246">    spell_type type = spell_by_name(specs, true);</a>
<a name="ln4247"> </a>
<a name="ln4248">    if (type == SPELL_NO_SPELL)</a>
<a name="ln4249">        return false;</a>
<a name="ln4250"> </a>
<a name="ln4251">    for (int i = 0; i &lt; NUM_FIXED_BOOKS; ++i)</a>
<a name="ln4252">        for (spell_type sp : spellbook_template(static_cast&lt;book_type&gt;(i)))</a>
<a name="ln4253">            if (sp == type)</a>
<a name="ln4254">            {</a>
<a name="ln4255">                item.sub_type = i;</a>
<a name="ln4256">                return true;</a>
<a name="ln4257">            }</a>
<a name="ln4258"> </a>
<a name="ln4259">    return false;</a>
<a name="ln4260">}</a>
<a name="ln4261"> </a>
<a name="ln4262">bool get_item_by_name(item_def *item, const char* specs,</a>
<a name="ln4263">                      object_class_type class_wanted, bool create_for_real)</a>
<a name="ln4264">{</a>
<a name="ln4265">    // used only for wizmode and item lookup</a>
<a name="ln4266"> </a>
<a name="ln4267">    int            type_wanted    = -1;</a>
<a name="ln4268">    int            special_wanted = 0;</a>
<a name="ln4269"> </a>
<a name="ln4270">    // In order to get the sub-type, we'll fill out the base type...</a>
<a name="ln4271">    // then we're going to iterate over all possible subtype values</a>
<a name="ln4272">    // and see if we get a winner. -- bwr</a>
<a name="ln4273">    item-&gt;base_type = class_wanted;</a>
<a name="ln4274">    item-&gt;sub_type  = 0;</a>
<a name="ln4275">    item-&gt;plus      = 0;</a>
<a name="ln4276">    item-&gt;plus2     = 0;</a>
<a name="ln4277">    item-&gt;special   = 0;</a>
<a name="ln4278">    item-&gt;flags     = 0;</a>
<a name="ln4279">    item-&gt;quantity  = 1;</a>
<a name="ln4280">    // Don't use set_ident_flags(), to avoid getting a spurious ID note.</a>
<a name="ln4281">    item-&gt;flags    |= ISFLAG_IDENT_MASK;</a>
<a name="ln4282"> </a>
<a name="ln4283">    if (class_wanted == OBJ_RUNES &amp;&amp; strstr(specs, &quot;rune&quot;))</a>
<a name="ln4284">    {</a>
<a name="ln4285">        _rune_from_specs(specs, *item);</a>
<a name="ln4286"> </a>
<a name="ln4287">        // Rune creation cancelled, clean up item-&gt;</a>
<a name="ln4288">        if (item-&gt;base_type == OBJ_UNASSIGNED)</a>
<a name="ln4289">            return false;</a>
<a name="ln4290">    }</a>
<a name="ln4291"> </a>
<a name="ln4292">    if (!item-&gt;sub_type)</a>
<a name="ln4293">    {</a>
<a name="ln4294">        type_wanted = -1;</a>
<a name="ln4295">        size_t best_index  = 10000;</a>
<a name="ln4296"> </a>
<a name="ln4297">        for (const auto i : all_item_subtypes(item-&gt;base_type))</a>
<a name="ln4298">        {</a>
<a name="ln4299">            item-&gt;sub_type = i;</a>
<a name="ln4300">            size_t pos = lowercase_string(item-&gt;name(DESC_PLAIN)).find(specs);</a>
<a name="ln4301">            if (pos != string::npos)</a>
<a name="ln4302">            {</a>
<a name="ln4303">                // Earliest match is the winner.</a>
<a name="ln4304">                if (pos &lt; best_index)</a>
<a name="ln4305">                {</a>
<a name="ln4306">                    if (create_for_real)</a>
<a name="ln4307">                        mpr(item-&gt;name(DESC_PLAIN));</a>
<a name="ln4308">                    type_wanted = i;</a>
<a name="ln4309">                    best_index = pos;</a>
<a name="ln4310">                }</a>
<a name="ln4311">            }</a>
<a name="ln4312">        }</a>
<a name="ln4313"> </a>
<a name="ln4314">        if (type_wanted != -1)</a>
<a name="ln4315">        {</a>
<a name="ln4316">            item-&gt;sub_type = type_wanted;</a>
<a name="ln4317">            if (!create_for_real)</a>
<a name="ln4318">                return true;</a>
<a name="ln4319">        }</a>
<a name="ln4320">        else</a>
<a name="ln4321">        {</a>
<a name="ln4322">            switch (class_wanted)</a>
<a name="ln4323">            {</a>
<a name="ln4324">            case OBJ_BOOKS:</a>
<a name="ln4325">                // Try if we get a match against a spell.</a>
<a name="ln4326">                if (_book_from_spell(specs, *item))</a>
<a name="ln4327">                    type_wanted = item-&gt;sub_type;</a>
<a name="ln4328">                break;</a>
<a name="ln4329"> </a>
<a name="ln4330">            // Search for a matching unrandart.</a>
<a name="ln4331">            case OBJ_WEAPONS:</a>
<a name="ln4332">            case OBJ_ARMOUR:</a>
<a name="ln4333">            case OBJ_JEWELLERY:</a>
<a name="ln4334">            {</a>
<a name="ln4335">                // XXX: if we ever allow ?/ lookup of unrands, change this,</a>
<a name="ln4336">                // since at present, it'll mark any matching unrands as</a>
<a name="ln4337">                // created &amp; prevent them from showing up in the game!</a>
<a name="ln4338">                for (int unrand = 0; unrand &lt; NUM_UNRANDARTS; ++unrand)</a>
<a name="ln4339">                {</a>
<a name="ln4340">                    int index = unrand + UNRAND_START;</a>
<a name="ln4341">                    const unrandart_entry* entry = get_unrand_entry(index);</a>
<a name="ln4342"> </a>
<a name="ln4343">                    size_t pos = lowercase_string(entry-&gt;name).find(specs);</a>
<a name="ln4344">                    if (pos != string::npos &amp;&amp; entry-&gt;base_type == class_wanted)</a>
<a name="ln4345">                    {</a>
<a name="ln4346">                        make_item_unrandart(*item, index);</a>
<a name="ln4347">                        if (create_for_real)</a>
<a name="ln4348">                        {</a>
<a name="ln4349">                            mprf(&quot;%s (%s)&quot;, entry-&gt;name,</a>
<a name="ln4350">                                 debug_art_val_str(*item).c_str());</a>
<a name="ln4351">                        }</a>
<a name="ln4352">                        return true;</a>
<a name="ln4353">                    }</a>
<a name="ln4354">                }</a>
<a name="ln4355"> </a>
<a name="ln4356">                // Reset base type to class_wanted, if nothing found.</a>
<a name="ln4357">                item-&gt;base_type = class_wanted;</a>
<a name="ln4358">                item-&gt;sub_type  = 0;</a>
<a name="ln4359">                break;</a>
<a name="ln4360">            }</a>
<a name="ln4361"> </a>
<a name="ln4362">            default:</a>
<a name="ln4363">                break;</a>
<a name="ln4364">            }</a>
<a name="ln4365">        }</a>
<a name="ln4366"> </a>
<a name="ln4367">        if (type_wanted == -1)</a>
<a name="ln4368">        {</a>
<a name="ln4369">            // ds -- If specs is a valid int, try using that.</a>
<a name="ln4370">            //       Since zero is atoi's copout, the wizard</a>
<a name="ln4371">            //       must enter (subtype + 1).</a>
<a name="ln4372">            if (!(type_wanted = atoi(specs)))</a>
<a name="ln4373">                return false;</a>
<a name="ln4374"> </a>
<a name="ln4375">            type_wanted--;</a>
<a name="ln4376"> </a>
<a name="ln4377">            item-&gt;sub_type = type_wanted;</a>
<a name="ln4378">        }</a>
<a name="ln4379">    }</a>
<a name="ln4380"> </a>
<a name="ln4381">    if (!create_for_real)</a>
<a name="ln4382">        return true;</a>
<a name="ln4383"> </a>
<a name="ln4384">    switch (item-&gt;base_type)</a>
<a name="ln4385">    {</a>
<a name="ln4386">    case OBJ_MISSILES:</a>
<a name="ln4387">        item-&gt;quantity = 30;</a>
<a name="ln4388">        // intentional fall-through</a>
<a name="ln4389">    case OBJ_WEAPONS:</a>
<a name="ln4390">    case OBJ_ARMOUR:</a>
<a name="ln4391">    {</a>
<a name="ln4392">        char buf[80];</a>
<a name="ln4393">        msgwin_get_line_autohist(&quot;What ego type? &quot;, buf, sizeof(buf));</a>
<a name="ln4394"> </a>
<a name="ln4395">        if (buf[0] != '\0')</a>
<a name="ln4396">        {</a>
<a name="ln4397">            string buf_lwr = lowercase_string(buf);</a>
<a name="ln4398">            special_wanted = 0;</a>
<a name="ln4399">            size_t best_index = 10000;</a>
<a name="ln4400"> </a>
<a name="ln4401">            for (int i = SPWPN_NORMAL + 1; i &lt; SPWPN_DEBUG_RANDART; ++i)</a>
<a name="ln4402">            {</a>
<a name="ln4403">                item-&gt;brand = i;</a>
<a name="ln4404">                size_t pos = lowercase_string(item-&gt;name(DESC_PLAIN)).find(buf_lwr);</a>
<a name="ln4405">                if (pos != string::npos)</a>
<a name="ln4406">                {</a>
<a name="ln4407">                    // earliest match is the winner</a>
<a name="ln4408">                    if (pos &lt; best_index)</a>
<a name="ln4409">                    {</a>
<a name="ln4410">                        if (create_for_real)</a>
<a name="ln4411">                            mpr(item-&gt;name(DESC_PLAIN));</a>
<a name="ln4412">                        special_wanted = i;</a>
<a name="ln4413">                        best_index = pos;</a>
<a name="ln4414">                    }</a>
<a name="ln4415">                }</a>
<a name="ln4416">            }</a>
<a name="ln4417"> </a>
<a name="ln4418">            item-&gt;brand = special_wanted;</a>
<a name="ln4419">        }</a>
<a name="ln4420">        break;</a>
<a name="ln4421">    }</a>
<a name="ln4422"> </a>
<a name="ln4423">    case OBJ_BOOKS:</a>
<a name="ln4424">        if (item-&gt;sub_type == BOOK_MANUAL)</a>
<a name="ln4425">        {</a>
<a name="ln4426">            skill_type skill =</a>
<a name="ln4427">                    debug_prompt_for_skill(&quot;A manual for which skill? &quot;);</a>
<a name="ln4428"> </a>
<a name="ln4429">            if (skill != SK_NONE)</a>
<a name="ln4430">                item-&gt;skill = skill;</a>
<a name="ln4431">            else</a>
<a name="ln4432">            {</a>
<a name="ln4433">                mpr(&quot;Sorry, no books on that skill today.&quot;);</a>
<a name="ln4434">                item-&gt;skill = SK_FIGHTING; // Was probably that anyway.</a>
<a name="ln4435">            }</a>
<a name="ln4436">            item-&gt;skill_points = random_range(2000, 3000);</a>
<a name="ln4437">        }</a>
<a name="ln4438">        else if (type_wanted == BOOK_RANDART_THEME)</a>
<a name="ln4439">            build_themed_book(*item, capped_spell_filter(20));</a>
<a name="ln4440">        else if (type_wanted == BOOK_RANDART_LEVEL)</a>
<a name="ln4441">        {</a>
<a name="ln4442">            int level = random_range(1, 9);</a>
<a name="ln4443">            make_book_level_randart(*item, level);</a>
<a name="ln4444">        }</a>
<a name="ln4445">        break;</a>
<a name="ln4446"> </a>
<a name="ln4447">    case OBJ_WANDS:</a>
<a name="ln4448">        item-&gt;plus = wand_charge_value(item-&gt;sub_type);</a>
<a name="ln4449">        break;</a>
<a name="ln4450"> </a>
<a name="ln4451">    case OBJ_POTIONS:</a>
<a name="ln4452">        item-&gt;quantity = 12;</a>
<a name="ln4453">        break;</a>
<a name="ln4454"> </a>
<a name="ln4455">    case OBJ_FOOD:</a>
<a name="ln4456">    case OBJ_SCROLLS:</a>
<a name="ln4457">        item-&gt;quantity = 12;</a>
<a name="ln4458">        break;</a>
<a name="ln4459"> </a>
<a name="ln4460">    case OBJ_JEWELLERY:</a>
<a name="ln4461">        if (jewellery_is_amulet(*item) &amp;&amp; item-&gt;sub_type != AMU_REFLECTION)</a>
<a name="ln4462">            break;</a>
<a name="ln4463"> </a>
<a name="ln4464">        switch (item-&gt;sub_type)</a>
<a name="ln4465">        {</a>
<a name="ln4466">        case RING_SLAYING:</a>
<a name="ln4467">        case RING_PROTECTION:</a>
<a name="ln4468">        case RING_EVASION:</a>
<a name="ln4469">        case RING_STRENGTH:</a>
<a name="ln4470">        case RING_DEXTERITY:</a>
<a name="ln4471">        case RING_INTELLIGENCE:</a>
<a name="ln4472">        case AMU_REFLECTION:</a>
<a name="ln4473">            item-&gt;plus = 5;</a>
<a name="ln4474">        default:</a>
<a name="ln4475">            break;</a>
<a name="ln4476">        }</a>
<a name="ln4477"> </a>
<a name="ln4478">    default:</a>
<a name="ln4479">        break;</a>
<a name="ln4480">    }</a>
<a name="ln4481"> </a>
<a name="ln4482">    item_set_appearance(*item);</a>
<a name="ln4483"> </a>
<a name="ln4484">    return true;</a>
<a name="ln4485">}</a>
<a name="ln4486"> </a>
<a name="ln4487">bool get_item_by_exact_name(item_def &amp;item, const char* name)</a>
<a name="ln4488">{</a>
<a name="ln4489">    item.clear();</a>
<a name="ln4490">    item.quantity = 1;</a>
<a name="ln4491">    // Don't use set_ident_flags(), to avoid getting a spurious ID note.</a>
<a name="ln4492">    item.flags |= ISFLAG_IDENT_MASK;</a>
<a name="ln4493"> </a>
<a name="ln4494">    string name_lc = lowercase_string(string(name));</a>
<a name="ln4495"> </a>
<a name="ln4496">    for (int i = 0; i &lt; NUM_OBJECT_CLASSES; ++i)</a>
<a name="ln4497">    {</a>
<a name="ln4498">        if (i == OBJ_RUNES) // runes aren't shown in ?/I</a>
<a name="ln4499">            continue;</a>
<a name="ln4500"> </a>
<a name="ln4501">        item.base_type = static_cast&lt;object_class_type&gt;(i);</a>
<a name="ln4502">        item.sub_type = 0;</a>
<a name="ln4503"> </a>
<a name="ln4504">        if (!item.sub_type)</a>
<a name="ln4505">        {</a>
<a name="ln4506">            for (const auto j : all_item_subtypes(item.base_type))</a>
<a name="ln4507">            {</a>
<a name="ln4508">                item.sub_type = j;</a>
<a name="ln4509">                if (lowercase_string(item.name(DESC_DBNAME)) == name_lc)</a>
<a name="ln4510">                    return true;</a>
<a name="ln4511">            }</a>
<a name="ln4512">        }</a>
<a name="ln4513">    }</a>
<a name="ln4514">    return false;</a>
<a name="ln4515">}</a>
<a name="ln4516"> </a>
<a name="ln4517">void move_items(const coord_def r, const coord_def p)</a>
<a name="ln4518">{</a>
<a name="ln4519">    ASSERT_IN_BOUNDS(r);</a>
<a name="ln4520">    ASSERT_IN_BOUNDS(p);</a>
<a name="ln4521"> </a>
<a name="ln4522">    int it = igrd(r);</a>
<a name="ln4523"> </a>
<a name="ln4524">    if (it == NON_ITEM)</a>
<a name="ln4525">        return;</a>
<a name="ln4526"> </a>
<a name="ln4527">    while (it != NON_ITEM)</a>
<a name="ln4528">    {</a>
<a name="ln4529">        mitm[it].pos.x = p.x;</a>
<a name="ln4530">        mitm[it].pos.y = p.y;</a>
<a name="ln4531">        if (mitm[it].link == NON_ITEM)</a>
<a name="ln4532">        {</a>
<a name="ln4533">            // Link to the stack on the target grid p,</a>
<a name="ln4534">            // or NON_ITEM, if empty.</a>
<a name="ln4535">            mitm[it].link = igrd(p);</a>
<a name="ln4536">            break;</a>
<a name="ln4537">        }</a>
<a name="ln4538">        it = mitm[it].link;</a>
<a name="ln4539">    }</a>
<a name="ln4540"> </a>
<a name="ln4541">    // Move entire stack over to p.</a>
<a name="ln4542">    igrd(p) = igrd(r);</a>
<a name="ln4543">    igrd(r) = NON_ITEM;</a>
<a name="ln4544">}</a>
<a name="ln4545"> </a>
<a name="ln4546">// erase everything the player doesn't know</a>
<a name="ln4547">item_info get_item_info(const item_def&amp; item)</a>
<a name="ln4548">{</a>
<a name="ln4549">    item_info ii;</a>
<a name="ln4550"> </a>
<a name="ln4551">    ii.base_type = item.base_type;</a>
<a name="ln4552">    ii.quantity = item.quantity;</a>
<a name="ln4553">    ii.inscription = item.inscription;</a>
<a name="ln4554">    ii.flags = item.flags &amp; (0</a>
<a name="ln4555">            | ISFLAG_IDENT_MASK</a>
<a name="ln4556">            | ISFLAG_ARTEFACT_MASK | ISFLAG_DROPPED | ISFLAG_THROWN</a>
<a name="ln4557">            | ISFLAG_COSMETIC_MASK);</a>
<a name="ln4558"> </a>
<a name="ln4559">    if (in_inventory(item))</a>
<a name="ln4560">    {</a>
<a name="ln4561">        ii.link = item.link;</a>
<a name="ln4562">        ii.slot = item.slot;</a>
<a name="ln4563">        ii.pos = ITEM_IN_INVENTORY;</a>
<a name="ln4564">    }</a>
<a name="ln4565">    else</a>
<a name="ln4566">        ii.pos = item.pos;</a>
<a name="ln4567"> </a>
<a name="ln4568">    ii.rnd = item.rnd; // XXX: may (?) leak cosmetic (?) info...?</a>
<a name="ln4569">    if (ii.rnd == 0)</a>
<a name="ln4570">        ii.rnd = 1; // don't leave &quot;uninitialized&quot; item infos around</a>
<a name="ln4571"> </a>
<a name="ln4572">    // keep god number</a>
<a name="ln4573">    if (item.orig_monnum &lt; 0)</a>
<a name="ln4574">        ii.orig_monnum = item.orig_monnum;</a>
<a name="ln4575"> </a>
<a name="ln4576">    if (is_unrandom_artefact(item))</a>
<a name="ln4577">    {</a>
<a name="ln4578">        // Unrandart index</a>
<a name="ln4579">        // Since the appearance of unrandarts is fixed anyway, this</a>
<a name="ln4580">        // is not an information leak.</a>
<a name="ln4581">        ii.unrand_idx = item.unrand_idx;</a>
<a name="ln4582">    }</a>
<a name="ln4583"> </a>
<a name="ln4584">    switch (item.base_type)</a>
<a name="ln4585">    {</a>
<a name="ln4586">    case OBJ_MISSILES:</a>
<a name="ln4587">        if (item_ident(ii, ISFLAG_KNOW_PLUSES))</a>
<a name="ln4588">            ii.net_placed = item.net_placed;</a>
<a name="ln4589">        // intentional fall-through</a>
<a name="ln4590">    case OBJ_WEAPONS:</a>
<a name="ln4591">        ii.sub_type = item.sub_type;</a>
<a name="ln4592">        if (item_ident(ii, ISFLAG_KNOW_PLUSES))</a>
<a name="ln4593">            ii.plus = item.plus;</a>
<a name="ln4594">        if (item_type_known(item))</a>
<a name="ln4595">            ii.brand = item.brand;</a>
<a name="ln4596">        break;</a>
<a name="ln4597">    case OBJ_ARMOUR:</a>
<a name="ln4598">        ii.sub_type = item.sub_type;</a>
<a name="ln4599">        if (item_ident(ii, ISFLAG_KNOW_PLUSES))</a>
<a name="ln4600">            ii.plus = item.plus;</a>
<a name="ln4601">        if (item_type_known(item))</a>
<a name="ln4602">            ii.brand = item.brand;</a>
<a name="ln4603">        break;</a>
<a name="ln4604">    case OBJ_WANDS:</a>
<a name="ln4605">        if (item_type_known(item))</a>
<a name="ln4606">        {</a>
<a name="ln4607">            ii.sub_type = item.sub_type;</a>
<a name="ln4608">            ii.charges = item.charges;</a>
<a name="ln4609">        }</a>
<a name="ln4610">        else</a>
<a name="ln4611">            ii.sub_type = NUM_WANDS;</a>
<a name="ln4612">        ii.subtype_rnd = item.subtype_rnd;</a>
<a name="ln4613">        break;</a>
<a name="ln4614">    case OBJ_POTIONS:</a>
<a name="ln4615">        if (item_type_known(item))</a>
<a name="ln4616">            ii.sub_type = item.sub_type;</a>
<a name="ln4617">        else</a>
<a name="ln4618">            ii.sub_type = NUM_POTIONS;</a>
<a name="ln4619">        ii.subtype_rnd = item.subtype_rnd;</a>
<a name="ln4620">        break;</a>
<a name="ln4621">    case OBJ_FOOD:</a>
<a name="ln4622">        ii.sub_type = item.sub_type;</a>
<a name="ln4623">        if (ii.sub_type == FOOD_CHUNK)</a>
<a name="ln4624">        {</a>
<a name="ln4625">            ii.mon_type = item.mon_type;</a>
<a name="ln4626">            ii.freshness = 100;</a>
<a name="ln4627">        }</a>
<a name="ln4628">        break;</a>
<a name="ln4629">    case OBJ_CORPSES:</a>
<a name="ln4630">        ii.sub_type = item.sub_type;</a>
<a name="ln4631">        ii.mon_type = item.mon_type;</a>
<a name="ln4632">        ii.freshness = 100;</a>
<a name="ln4633">        break;</a>
<a name="ln4634">    case OBJ_SCROLLS:</a>
<a name="ln4635">        if (item_type_known(item))</a>
<a name="ln4636">            ii.sub_type = item.sub_type;</a>
<a name="ln4637">        else</a>
<a name="ln4638">            ii.sub_type = NUM_SCROLLS;</a>
<a name="ln4639">        ii.subtype_rnd = item.subtype_rnd;    // name seed</a>
<a name="ln4640">        break;</a>
<a name="ln4641">    case OBJ_JEWELLERY:</a>
<a name="ln4642">        if (item_type_known(item))</a>
<a name="ln4643">            ii.sub_type = item.sub_type;</a>
<a name="ln4644">        else</a>
<a name="ln4645">            ii.sub_type = jewellery_is_amulet(item) ? NUM_JEWELLERY : NUM_RINGS;</a>
<a name="ln4646">        if (item_ident(ii, ISFLAG_KNOW_PLUSES))</a>
<a name="ln4647">            ii.plus = item.plus;   // str/dex/int/ac/ev ring plus</a>
<a name="ln4648">        ii.subtype_rnd = item.subtype_rnd;</a>
<a name="ln4649">        break;</a>
<a name="ln4650">    case OBJ_BOOKS:</a>
<a name="ln4651">        if (item_type_known(item) || !item_is_spellbook(item))</a>
<a name="ln4652">            ii.sub_type = item.sub_type;</a>
<a name="ln4653">        else</a>
<a name="ln4654">            ii.sub_type = NUM_BOOKS;</a>
<a name="ln4655">        ii.subtype_rnd = item.subtype_rnd;</a>
<a name="ln4656">        if (item.sub_type == BOOK_MANUAL &amp;&amp; item_type_known(item))</a>
<a name="ln4657">            ii.skill = item.skill; // manual skill</a>
<a name="ln4658">        break;</a>
<a name="ln4659">#if TAG_MAJOR_VERSION == 34</a>
<a name="ln4660">    case OBJ_RODS:</a>
<a name="ln4661">        ii.sub_type = NUM_RODS;</a>
<a name="ln4662">        break;</a>
<a name="ln4663">#endif</a>
<a name="ln4664">    case OBJ_STAVES:</a>
<a name="ln4665">        ii.sub_type = item_type_known(item) ? item.sub_type : int{NUM_STAVES};</a>
<a name="ln4666">        ii.subtype_rnd = item.subtype_rnd;</a>
<a name="ln4667">        break;</a>
<a name="ln4668">    case OBJ_MISCELLANY:</a>
<a name="ln4669">        if (item_type_known(item))</a>
<a name="ln4670">            ii.sub_type = item.sub_type;</a>
<a name="ln4671">        else</a>
<a name="ln4672">            ii.sub_type = item.sub_type;</a>
<a name="ln4673">        break;</a>
<a name="ln4674">    case OBJ_GOLD:</a>
<a name="ln4675">        ii.sub_type = item.sub_type;</a>
<a name="ln4676">        break;</a>
<a name="ln4677">    case OBJ_ORBS:</a>
<a name="ln4678">    case OBJ_RUNES:</a>
<a name="ln4679">    default:</a>
<a name="ln4680">        ii.sub_type = item.sub_type;</a>
<a name="ln4681">        break;</a>
<a name="ln4682">    }</a>
<a name="ln4683"> </a>
<a name="ln4684">    if (item_ident(item, ISFLAG_KNOW_CURSE))</a>
<a name="ln4685">        ii.flags |= (item.flags &amp; ISFLAG_CURSED);</a>
<a name="ln4686"> </a>
<a name="ln4687">    if (item_type_known(item))</a>
<a name="ln4688">    {</a>
<a name="ln4689">        ii.flags |= ISFLAG_KNOW_TYPE;</a>
<a name="ln4690"> </a>
<a name="ln4691">        if (item.props.exists(ARTEFACT_NAME_KEY))</a>
<a name="ln4692">            ii.props[ARTEFACT_NAME_KEY] = item.props[ARTEFACT_NAME_KEY];</a>
<a name="ln4693">    }</a>
<a name="ln4694"> </a>
<a name="ln4695">    static const char* copy_props[] =</a>
<a name="ln4696">    {</a>
<a name="ln4697">        ARTEFACT_APPEAR_KEY, KNOWN_PROPS_KEY, CORPSE_NAME_KEY,</a>
<a name="ln4698">        CORPSE_NAME_TYPE_KEY, &quot;item_tile&quot;, &quot;item_tile_name&quot;,</a>
<a name="ln4699">        &quot;worn_tile&quot;, &quot;worn_tile_name&quot;, &quot;needs_autopickup&quot;,</a>
<a name="ln4700">        FORCED_ITEM_COLOUR_KEY,</a>
<a name="ln4701">    };</a>
<a name="ln4702">    for (const char *prop : copy_props)</a>
<a name="ln4703">        if (item.props.exists(prop))</a>
<a name="ln4704">            ii.props[prop] = item.props[prop];</a>
<a name="ln4705"> </a>
<a name="ln4706">    static const char* copy_ident_props[] = {&quot;spell_list&quot;};</a>
<a name="ln4707">    if (item_ident(item, ISFLAG_KNOW_TYPE))</a>
<a name="ln4708">    {</a>
<a name="ln4709">        for (const char *prop : copy_ident_props)</a>
<a name="ln4710">            if (item.props.exists(prop))</a>
<a name="ln4711">                ii.props[prop] = item.props[prop];</a>
<a name="ln4712">    }</a>
<a name="ln4713"> </a>
<a name="ln4714">    if (item.props.exists(ARTEFACT_PROPS_KEY))</a>
<a name="ln4715">    {</a>
<a name="ln4716">        CrawlVector props = item.props[ARTEFACT_PROPS_KEY].get_vector();</a>
<a name="ln4717">        const CrawlVector &amp;known = item.props[KNOWN_PROPS_KEY].get_vector();</a>
<a name="ln4718"> </a>
<a name="ln4719">        if (!item_ident(item, ISFLAG_KNOW_PROPERTIES))</a>
<a name="ln4720">        {</a>
<a name="ln4721">            for (unsigned i = 0; i &lt; props.size(); ++i)</a>
<a name="ln4722">            {</a>
<a name="ln4723">                if (i &gt;= known.size() || !known[i].get_bool())</a>
<a name="ln4724">                    props[i] = (short)0;</a>
<a name="ln4725">            }</a>
<a name="ln4726">        }</a>
<a name="ln4727"> </a>
<a name="ln4728">        ii.props[ARTEFACT_PROPS_KEY] = props;</a>
<a name="ln4729">    }</a>
<a name="ln4730"> </a>
<a name="ln4731">    return ii;</a>
<a name="ln4732">}</a>
<a name="ln4733"> </a>
<a name="ln4734">int runes_in_pack()</a>
<a name="ln4735">{</a>
<a name="ln4736">    return static_cast&lt;int&gt;(you.runes.count());</a>
<a name="ln4737">}</a>
<a name="ln4738"> </a>
<a name="ln4739">object_class_type get_random_item_mimic_type()</a>
<a name="ln4740">{</a>
<a name="ln4741">   return random_choose(OBJ_GOLD, OBJ_WEAPONS, OBJ_ARMOUR, OBJ_SCROLLS,</a>
<a name="ln4742">                        OBJ_POTIONS, OBJ_BOOKS, OBJ_STAVES, OBJ_FOOD,</a>
<a name="ln4743">                        OBJ_MISCELLANY, OBJ_JEWELLERY);</a>
<a name="ln4744">}</a>
<a name="ln4745"> </a>
<a name="ln4746">/**</a>
<a name="ln4747"> * How many types of identifiable item exist in the same category as the</a>
<a name="ln4748"> * given item? (E.g., wands, scrolls, rings, etc.)</a>
<a name="ln4749"> *</a>
<a name="ln4750"> * @param item      The item in question.</a>
<a name="ln4751"> * @return          The number of item enums in the same category.</a>
<a name="ln4752"> *                  If the item isn't in a category of identifiable items,</a>
<a name="ln4753"> *                  returns 0.</a>
<a name="ln4754"> */</a>
<a name="ln4755">static int _items_in_category(const item_def &amp;item)</a>
<a name="ln4756">{</a>
<a name="ln4757">    switch (item.base_type)</a>
<a name="ln4758">    {</a>
<a name="ln4759">        case OBJ_WANDS:</a>
<a name="ln4760">            return NUM_WANDS;</a>
<a name="ln4761">        case OBJ_STAVES:</a>
<a name="ln4762">            return NUM_STAVES;</a>
<a name="ln4763">        case OBJ_POTIONS:</a>
<a name="ln4764">            return NUM_POTIONS;</a>
<a name="ln4765">        case OBJ_SCROLLS:</a>
<a name="ln4766">            return NUM_SCROLLS;</a>
<a name="ln4767">        case OBJ_JEWELLERY:</a>
<a name="ln4768">            if (jewellery_is_amulet(item.sub_type))</a>
<a name="ln4769">                return NUM_JEWELLERY - AMU_FIRST_AMULET;</a>
<a name="ln4770">            return NUM_RINGS - RING_FIRST_RING;</a>
<a name="ln4771">        default:</a>
<a name="ln4772">            return 0;</a>
<a name="ln4773">    }</a>
<a name="ln4774">}</a>
<a name="ln4775"> </a>
<a name="ln4776">/**</a>
<a name="ln4777"> * What's the first enum for the given item's category?</a>
<a name="ln4778"> *</a>
<a name="ln4779"> * @param item  The item in question.</a>
<a name="ln4780"> * @return      The enum value for the first item of the given type.</a>
<a name="ln4781"> */</a>
<a name="ln4782">static int _get_item_base(const item_def &amp;item)</a>
<a name="ln4783">{</a>
<a name="ln4784">    if (item.base_type != OBJ_JEWELLERY)</a>
<a name="ln4785">        return 0; // XXX: dubious</a>
<a name="ln4786">    if (jewellery_is_amulet(item))</a>
<a name="ln4787">        return AMU_FIRST_AMULET;</a>
<a name="ln4788">    return RING_FIRST_RING;</a>
<a name="ln4789">}</a>
<a name="ln4790"> </a>
<a name="ln4791">/**</a>
<a name="ln4792"> * Autoidentify the (given) last item in its category.</a>
<a name="ln4793"> *</a>
<a name="ln4794"> 8 @param item  The item to identify.</a>
<a name="ln4795"> */</a>
<a name="ln4796">static void _identify_last_item(item_def &amp;item)</a>
<a name="ln4797">{</a>
<a name="ln4798">    if (!in_inventory(item) &amp;&amp; item_needs_autopickup(item)</a>
<a name="ln4799">        &amp;&amp; (item.base_type == OBJ_STAVES</a>
<a name="ln4800">            || item.base_type == OBJ_JEWELLERY))</a>
<a name="ln4801">    {</a>
<a name="ln4802">        item.props[&quot;needs_autopickup&quot;] = true;</a>
<a name="ln4803">    }</a>
<a name="ln4804"> </a>
<a name="ln4805">    set_ident_type(item, true);</a>
<a name="ln4806"> </a>
<a name="ln4807">    if (item.props.exists(&quot;needs_autopickup&quot;) &amp;&amp; is_useless_item(item))</a>
<a name="ln4808">        item.props.erase(&quot;needs_autopickup&quot;);</a>
<a name="ln4809"> </a>
<a name="ln4810">    const string class_name = item.base_type == OBJ_JEWELLERY ?</a>
<a name="ln4811">                                    item_base_name(item) :</a>
<a name="ln4812">                                    item_class_name(item.base_type, true);</a>
<a name="ln4813">    mprf(&quot;You have identified the last %s.&quot;, class_name.c_str());</a>
<a name="ln4814"> </a>
<a name="ln4815">    if (in_inventory(item))</a>
<a name="ln4816">    {</a>
<a name="ln4817">        mprf_nocap(&quot;%s&quot;, item.name(DESC_INVENTORY_EQUIP).c_str());</a>
<a name="ln4818">        auto_assign_item_slot(item);</a>
<a name="ln4819">    }</a>
<a name="ln4820">}</a>
<a name="ln4821"> </a>
<a name="ln4822"> </a>
<a name="ln4823">/**</a>
<a name="ln4824"> * Check to see if there's only one unidentified subtype left in the given</a>
<a name="ln4825"> * item's object type. If so, automatically identify it.</a>
<a name="ln4826"> *</a>
<a name="ln4827"> * @param item  The item in question.</a>
<a name="ln4828"> * @return      Whether the item was identified.</a>
<a name="ln4829"> */</a>
<a name="ln4830">bool maybe_identify_base_type(item_def &amp;item)</a>
<a name="ln4831">{</a>
<a name="ln4832">    if (is_artefact(item))</a>
<a name="ln4833">        return false;</a>
<a name="ln4834">    if (get_ident_type(item))</a>
<a name="ln4835">        return false;</a>
<a name="ln4836"> </a>
<a name="ln4837">    const int item_count = _items_in_category(item);</a>
<a name="ln4838">    if (!item_count)</a>
<a name="ln4839">        return false;</a>
<a name="ln4840"> </a>
<a name="ln4841">    // What's the enum of the first item in the category?</a>
<a name="ln4842">    const int item_base = _get_item_base(item);</a>
<a name="ln4843"> </a>
<a name="ln4844">    int ident_count = 0;</a>
<a name="ln4845"> </a>
<a name="ln4846">    for (int i = item_base; i &lt; item_count + item_base; i++)</a>
<a name="ln4847">    {</a>
<a name="ln4848">        const bool identified = you.type_ids[item.base_type][i];</a>
<a name="ln4849">        ident_count += identified ? 1 : 0;</a>
<a name="ln4850">    }</a>
<a name="ln4851"> </a>
<a name="ln4852">    if (ident_count &lt; item_count - 1)</a>
<a name="ln4853">        return false;</a>
<a name="ln4854"> </a>
<a name="ln4855">    _identify_last_item(item);</a>
<a name="ln4856">    return true;</a>
<a name="ln4857">}</a>

</code></pre>
<div class="balloon" rel="212"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v648/" target="_blank">V648</a> Priority of the '&&' operation is higher than that of the '||' operation.</p></div>
<div class="balloon" rel="1276"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v560/" target="_blank">V560</a> A part of conditional expression is always true: iorig > GOD_NO_GOD.</p></div>
<div class="balloon" rel="2209"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v1001/" target="_blank">V1001</a> The 'quant_got' variable is assigned but is not used by the end of the function.</p></div>
<div class="balloon" rel="2862"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v547/" target="_blank">V547</a> Expression '!old_inscription.empty()' is always false.</p></div>
<div class="balloon" rel="3338"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v648/" target="_blank">V648</a> Priority of the '&&' operation is higher than that of the '||' operation.</p></div>
<div class="balloon" rel="3403"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v648/" target="_blank">V648</a> Priority of the '&&' operation is higher than that of the '||' operation.</p></div>
<div class="balloon" rel="4410"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v547/" target="_blank">V547</a> Expression 'create_for_real' is always true.</p></div>
<div class="balloon" rel="4452"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v1037/" target="_blank">V1037</a> Two or more case-branches perform the same actions. Check lines: 4452, 4457</p></div>
<div class="balloon" rel="4504"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v547/" target="_blank">V547</a> Expression '!item.sub_type' is always true.</p></div>
<div class="balloon" rel="4672"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v523/" target="_blank">V523</a> The 'then' statement is equivalent to the 'else' statement.</p></div>
<div class="balloon" rel="4675"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v1037/" target="_blank">V1037</a> Two or more case-branches perform the same actions. Check lines: 4675, 4680</p></div>
<div class="balloon" rel="4591"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v1037/" target="_blank">V1037</a> Two or more case-branches perform the same actions. Check lines: 4591, 4598</p></div>

<link rel="stylesheet" href="highlight.css">
<script src="highlight.pack.js"></script>
<script src="highlightjs-line-numbers.js"></script>
<script>hljs.initHighlightingOnLoad();</script>
<script>hljs.initLineNumbersOnLoad();</script>
<script>
  $(document).ready(function() {
      $('.balloon').each(function () {
          var bl = $(this);
          var line = bl.attr('rel');
          var text = $('a[name="ln'+line+'"]').text();

          var space_count = 0;
          for(var i = 0; i<text.length; i++){
              var char = text[i];
              if((char !== ' ')&&(char !== '\t'))break;
              if(char === '\t')space_count++;
              space_count++;
          }

          bl.css('margin-left', space_count*8);
          $('a[name="ln'+line+'"]').after(bl);
      });

      window.location = window.location;
  });
</script>
</body>
</html>
