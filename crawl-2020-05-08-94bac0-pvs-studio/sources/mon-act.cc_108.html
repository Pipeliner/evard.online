
<html>
<head>

  <meta http-equiv="Content-Type" content="text/html; charset=US-ASCII" />
  <title>mon-act.cc</title>

  <link rel="stylesheet" href="../style.css"/>
  <script src="../jquery-3.2.1.min.js"></script>
</head>
<body>

<pre><code class = "cpp">
<a name="ln1">/**</a>
<a name="ln2"> * @file</a>
<a name="ln3"> * @brief Monsters doing stuff (monsters acting).</a>
<a name="ln4">**/</a>
<a name="ln5"> </a>
<a name="ln6">#include &quot;AppHdr.h&quot;</a>
<a name="ln7"> </a>
<a name="ln8">#include &quot;mon-act.h&quot;</a>
<a name="ln9"> </a>
<a name="ln10">#include &quot;act-iter.h&quot;</a>
<a name="ln11">#include &quot;areas.h&quot;</a>
<a name="ln12">#include &quot;arena.h&quot;</a>
<a name="ln13">#include &quot;attitude-change.h&quot;</a>
<a name="ln14">#include &quot;bloodspatter.h&quot;</a>
<a name="ln15">#include &quot;cloud.h&quot;</a>
<a name="ln16">#include &quot;colour.h&quot;</a>
<a name="ln17">#include &quot;coordit.h&quot;</a>
<a name="ln18">#include &quot;dbg-scan.h&quot;</a>
<a name="ln19">#include &quot;delay.h&quot;</a>
<a name="ln20">#include &quot;directn.h&quot; // feature_description_at</a>
<a name="ln21">#include &quot;dungeon.h&quot;</a>
<a name="ln22">#include &quot;english.h&quot; // apostrophise</a>
<a name="ln23">#include &quot;fight.h&quot;</a>
<a name="ln24">#include &quot;fineff.h&quot;</a>
<a name="ln25">#include &quot;ghost.h&quot;</a>
<a name="ln26">#include &quot;god-abil.h&quot; // GOZAG_GOLD_AURA_KEY</a>
<a name="ln27">#include &quot;god-passive.h&quot;</a>
<a name="ln28">#include &quot;god-prayer.h&quot;</a>
<a name="ln29">#include &quot;hints.h&quot;</a>
<a name="ln30">#include &quot;item-name.h&quot;</a>
<a name="ln31">#include &quot;item-prop.h&quot;</a>
<a name="ln32">#include &quot;item-status-flag-type.h&quot;</a>
<a name="ln33">#include &quot;items.h&quot;</a>
<a name="ln34">#include &quot;level-state-type.h&quot;</a>
<a name="ln35">#include &quot;libutil.h&quot;</a>
<a name="ln36">#include &quot;losglobal.h&quot;</a>
<a name="ln37">#include &quot;los.h&quot;</a>
<a name="ln38">#include &quot;mapmark.h&quot;</a>
<a name="ln39">#include &quot;message.h&quot;</a>
<a name="ln40">#include &quot;mon-abil.h&quot;</a>
<a name="ln41">#include &quot;mon-behv.h&quot;</a>
<a name="ln42">#include &quot;mon-book.h&quot;</a>
<a name="ln43">#include &quot;mon-cast.h&quot;</a>
<a name="ln44">#include &quot;mon-death.h&quot;</a>
<a name="ln45">#include &quot;mon-movetarget.h&quot;</a>
<a name="ln46">#include &quot;mon-place.h&quot;</a>
<a name="ln47">#include &quot;mon-poly.h&quot;</a>
<a name="ln48">#include &quot;mon-project.h&quot;</a>
<a name="ln49">#include &quot;mon-speak.h&quot;</a>
<a name="ln50">#include &quot;mon-tentacle.h&quot;</a>
<a name="ln51">#include &quot;nearby-danger.h&quot;</a>
<a name="ln52">#include &quot;religion.h&quot;</a>
<a name="ln53">#include &quot;rot.h&quot;</a>
<a name="ln54">#include &quot;shout.h&quot;</a>
<a name="ln55">#include &quot;spl-book.h&quot;</a>
<a name="ln56">#include &quot;spl-clouds.h&quot;</a>
<a name="ln57">#include &quot;spl-damage.h&quot;</a>
<a name="ln58">#include &quot;spl-summoning.h&quot;</a>
<a name="ln59">#include &quot;spl-transloc.h&quot;</a>
<a name="ln60">#include &quot;spl-util.h&quot;</a>
<a name="ln61">#include &quot;spl-zap.h&quot;</a>
<a name="ln62">#include &quot;state.h&quot;</a>
<a name="ln63">#include &quot;stringutil.h&quot;</a>
<a name="ln64">#include &quot;target.h&quot;</a>
<a name="ln65">#include &quot;teleport.h&quot;</a>
<a name="ln66">#include &quot;terrain.h&quot;</a>
<a name="ln67">#include &quot;throw.h&quot;</a>
<a name="ln68">#include &quot;timed-effects.h&quot;</a>
<a name="ln69">#include &quot;traps.h&quot;</a>
<a name="ln70">#include &quot;viewchar.h&quot;</a>
<a name="ln71">#include &quot;view.h&quot;</a>
<a name="ln72"> </a>
<a name="ln73">static bool _handle_pickup(monster* mons);</a>
<a name="ln74">static void _mons_in_cloud(monster&amp; mons);</a>
<a name="ln75">static bool _monster_move(monster* mons);</a>
<a name="ln76"> </a>
<a name="ln77">// [dshaligram] Doesn't need to be extern.</a>
<a name="ln78">static coord_def mmov;</a>
<a name="ln79"> </a>
<a name="ln80">/**</a>
<a name="ln81"> * Get the monster's &quot;hit dice&quot;.</a>
<a name="ln82"> *</a>
<a name="ln83"> * @return          The monster's HD.</a>
<a name="ln84"> */</a>
<a name="ln85">int monster::get_hit_dice() const</a>
<a name="ln86">{</a>
<a name="ln87">    const int base_hd = get_experience_level();</a>
<a name="ln88"> </a>
<a name="ln89">    const mon_enchant drain_ench = get_ench(ENCH_DRAINED);</a>
<a name="ln90">    const int drained_hd = base_hd - drain_ench.degree;</a>
<a name="ln91"> </a>
<a name="ln92">    // temp malmuts (-25% HD)</a>
<a name="ln93">    if (has_ench(ENCH_WRETCHED))</a>
<a name="ln94">        return max(drained_hd * 3 / 4, 1);</a>
<a name="ln95">    return max(drained_hd, 1);</a>
<a name="ln96">}</a>
<a name="ln97"> </a>
<a name="ln98">/**</a>
<a name="ln99"> * Get the monster's &quot;experience level&quot; - their hit dice, unmodified by</a>
<a name="ln100"> * temporary enchantments (draining).</a>
<a name="ln101"> *</a>
<a name="ln102"> * @return          The monster's XL.</a>
<a name="ln103"> */</a>
<a name="ln104">int monster::get_experience_level() const</a>
<a name="ln105">{</a>
<a name="ln106">    return hit_dice;</a>
<a name="ln107">}</a>
<a name="ln108"> </a>
<a name="ln109">static const coord_def mon_compass[8] =</a>
<a name="ln110">{</a>
<a name="ln111">    { -1,-1 }, { 0,-1 }, {  1,-1 }, {  1,0 }, // bjnl</a>
<a name="ln112">    {  1, 1 }, { 0, 1 }, { -1, 1 }, { -1,0 }  // ukyh</a>
<a name="ln113">};</a>
<a name="ln114"> </a>
<a name="ln115">static int _compass_idx(const coord_def&amp; mov)</a>
<a name="ln116">{</a>
<a name="ln117">    for (int i = 0; i &lt; 8; i++)</a>
<a name="ln118">        if (mon_compass[i] == mov)</a>
<a name="ln119">            return i;</a>
<a name="ln120">    return -1;</a>
<a name="ln121">}</a>
<a name="ln122"> </a>
<a name="ln123">static inline bool _mons_natural_regen_roll(monster* mons)</a>
<a name="ln124">{</a>
<a name="ln125">    const int regen_rate = mons-&gt;natural_regen_rate();</a>
<a name="ln126">    return x_chance_in_y(regen_rate, 25);</a>
<a name="ln127">}</a>
<a name="ln128"> </a>
<a name="ln129">// Do natural regeneration for monster.</a>
<a name="ln130">static void _monster_regenerate(monster* mons)</a>
<a name="ln131">{</a>
<a name="ln132">    // Early bailout so that regen-based triggers don't get spammed</a>
<a name="ln133">    if (mons-&gt;hit_points == mons-&gt;max_hit_points)</a>
<a name="ln134">        return;</a>
<a name="ln135"> </a>
<a name="ln136">    if (crawl_state.disables[DIS_MON_REGEN])</a>
<a name="ln137">        return;</a>
<a name="ln138"> </a>
<a name="ln139">    if (mons-&gt;has_ench(ENCH_SICK)</a>
<a name="ln140">        || !mons_can_regenerate(*mons) &amp;&amp; !(mons-&gt;has_ench(ENCH_REGENERATION)))</a>
<a name="ln141">    {</a>
<a name="ln142">        return;</a>
<a name="ln143">    }</a>
<a name="ln144"> </a>
<a name="ln145">    // Non-land creatures out of their element cannot regenerate.</a>
<a name="ln146">    if (mons_primary_habitat(*mons) != HT_LAND</a>
<a name="ln147">        &amp;&amp; !monster_habitable_grid(mons, grd(mons-&gt;pos())))</a>
<a name="ln148">    {</a>
<a name="ln149">        return;</a>
<a name="ln150">    }</a>
<a name="ln151"> </a>
<a name="ln152">    if (mons_class_fast_regen(mons-&gt;type)</a>
<a name="ln153">        || mons-&gt;has_ench(ENCH_REGENERATION)</a>
<a name="ln154">        || _mons_natural_regen_roll(mons))</a>
<a name="ln155">    {</a>
<a name="ln156">        mons-&gt;heal(1);</a>
<a name="ln157">    }</a>
<a name="ln158"> </a>
<a name="ln159">    if (mons_is_hepliaklqana_ancestor(mons-&gt;type))</a>
<a name="ln160">    {</a>
<a name="ln161">        if (mons-&gt;hit_points == mons-&gt;max_hit_points &amp;&amp; you.can_see(*mons))</a>
<a name="ln162">            interrupt_activity(activity_interrupt::ancestor_hp);</a>
<a name="ln163">    }</a>
<a name="ln164">}</a>
<a name="ln165"> </a>
<a name="ln166">static void _escape_water_hold(monster&amp; mons)</a>
<a name="ln167">{</a>
<a name="ln168">    if (mons.has_ench(ENCH_WATER_HOLD))</a>
<a name="ln169">    {</a>
<a name="ln170">        simple_monster_message(mons, &quot; slips free of the water.&quot;);</a>
<a name="ln171">        mons.del_ench(ENCH_WATER_HOLD);</a>
<a name="ln172">    }</a>
<a name="ln173">}</a>
<a name="ln174"> </a>
<a name="ln175">static void _handle_manticore_barbs(monster&amp; mons)</a>
<a name="ln176">{</a>
<a name="ln177">    if (mons.has_ench(ENCH_BARBS))</a>
<a name="ln178">    {</a>
<a name="ln179">        mon_enchant barbs = mons.get_ench(ENCH_BARBS);</a>
<a name="ln180"> </a>
<a name="ln181">        // Save these first because hurt() might kill the monster.</a>
<a name="ln182">        const coord_def pos = mons.pos();</a>
<a name="ln183">        const monster_type type = mons.type;</a>
<a name="ln184">        mons.hurt(monster_by_mid(barbs.source),</a>
<a name="ln185">                  roll_dice(2, barbs.degree * 2 + 2));</a>
<a name="ln186">        bleed_onto_floor(pos, type, 2, false);</a>
<a name="ln187">        if (coinflip())</a>
<a name="ln188">        {</a>
<a name="ln189">            barbs.duration--;</a>
<a name="ln190">            mons.update_ench(barbs);</a>
<a name="ln191">        }</a>
<a name="ln192">    }</a>
<a name="ln193">}</a>
<a name="ln194"> </a>
<a name="ln195">static bool _swap_monsters(monster&amp; mover, monster&amp; moved)</a>
<a name="ln196">{</a>
<a name="ln197">    // Can't swap with a stationary monster.</a>
<a name="ln198">    // Although nominally stationary kraken tentacles can be swapped</a>
<a name="ln199">    // with the main body.</a>
<a name="ln200">    if (moved.is_stationary() &amp;&amp; !moved.is_child_tentacle())</a>
<a name="ln201">        return false;</a>
<a name="ln202"> </a>
<a name="ln203">    // If the target monster is constricted it is stuck</a>
<a name="ln204">    // and not eligible to be swapped with</a>
<a name="ln205">    if (moved.is_constricted())</a>
<a name="ln206">    {</a>
<a name="ln207">        dprf(&quot;%s fails to swap with %s, constricted.&quot;,</a>
<a name="ln208">            mover.name(DESC_THE).c_str(),</a>
<a name="ln209">            moved.name(DESC_THE).c_str());</a>
<a name="ln210">            return false;</a>
<a name="ln211">    }</a>
<a name="ln212"> </a>
<a name="ln213">    // Swapping is a purposeful action.</a>
<a name="ln214">    if (mover.confused())</a>
<a name="ln215">        return false;</a>
<a name="ln216"> </a>
<a name="ln217">    // Right now just happens in sanctuary.</a>
<a name="ln218">    if (!is_sanctuary(mover.pos()) || !is_sanctuary(moved.pos()))</a>
<a name="ln219">        return false;</a>
<a name="ln220"> </a>
<a name="ln221">    // A friendly or good-neutral monster moving past a fleeing hostile</a>
<a name="ln222">    // or neutral monster, or vice versa.</a>
<a name="ln223">    if (mover.wont_attack() == moved.wont_attack()</a>
<a name="ln224">        || mons_is_retreating(mover) == mons_is_retreating(moved))</a>
<a name="ln225">    {</a>
<a name="ln226">        return false;</a>
<a name="ln227">    }</a>
<a name="ln228"> </a>
<a name="ln229">    // Don't swap places if the player explicitly ordered their pet to</a>
<a name="ln230">    // attack monsters.</a>
<a name="ln231">    if ((mover.friendly() || moved.friendly())</a>
<a name="ln232">        &amp;&amp; you.pet_target != MHITYOU &amp;&amp; you.pet_target != MHITNOT)</a>
<a name="ln233">    {</a>
<a name="ln234">        return false;</a>
<a name="ln235">    }</a>
<a name="ln236"> </a>
<a name="ln237">    // Okay, we can probably do the swap.</a>
<a name="ln238">    if (!mover.swap_with(&amp;moved))</a>
<a name="ln239">        return false;</a>
<a name="ln240"> </a>
<a name="ln241">    if (you.can_see(mover) &amp;&amp; you.can_see(moved))</a>
<a name="ln242">    {</a>
<a name="ln243">        mprf(&quot;%s and %s swap places.&quot;, mover.name(DESC_THE).c_str(),</a>
<a name="ln244">             moved.name(DESC_THE).c_str());</a>
<a name="ln245">    }</a>
<a name="ln246"> </a>
<a name="ln247">    _escape_water_hold(mover);</a>
<a name="ln248"> </a>
<a name="ln249">    _handle_manticore_barbs(mover);</a>
<a name="ln250">    _handle_manticore_barbs(moved);</a>
<a name="ln251"> </a>
<a name="ln252">    if (moved.type == MONS_FOXFIRE)</a>
<a name="ln253">    {</a>
<a name="ln254">        mprf(MSGCH_GOD, &quot;By Zin's power the foxfire is contained!&quot;);</a>
<a name="ln255">        monster_die(moved, KILL_DISMISSED, NON_MONSTER, true);</a>
<a name="ln256">    }</a>
<a name="ln257"> </a>
<a name="ln258">    return true;</a>
<a name="ln259">}</a>
<a name="ln260"> </a>
<a name="ln261">static bool _do_mon_spell(monster* mons)</a>
<a name="ln262">{</a>
<a name="ln263">    if (handle_mon_spell(mons))</a>
<a name="ln264">    {</a>
<a name="ln265">        // If a Pan lord/pghost is known to be a spellcaster, it's safer</a>
<a name="ln266">        // to assume it has ranged spells too. For others, it'd just</a>
<a name="ln267">        // lead to unnecessary false positives.</a>
<a name="ln268">        if (mons_is_ghost_demon(mons-&gt;type))</a>
<a name="ln269">            mons-&gt;flags |= MF_SEEN_RANGED;</a>
<a name="ln270"> </a>
<a name="ln271">        mmov.reset();</a>
<a name="ln272">        return true;</a>
<a name="ln273">    }</a>
<a name="ln274"> </a>
<a name="ln275">    return false;</a>
<a name="ln276">}</a>
<a name="ln277"> </a>
<a name="ln278">static void _swim_or_move_energy(monster&amp; mon)</a>
<a name="ln279">{</a>
<a name="ln280">    const dungeon_feature_type feat = grd(mon.pos());</a>
<a name="ln281"> </a>
<a name="ln282">    // FIXME: Replace check with mons_is_swimming()?</a>
<a name="ln283">    mon.lose_energy(((feat_is_lava(feat) || feat_is_water(feat))</a>
<a name="ln284">                     &amp;&amp; mon.ground_level()) ? EUT_SWIM : EUT_MOVE);</a>
<a name="ln285">}</a>
<a name="ln286"> </a>
<a name="ln287">static bool _unfriendly_or_impaired(const monster&amp; mon)</a>
<a name="ln288">{</a>
<a name="ln289">    return !mon.wont_attack() || mon.has_ench(ENCH_INSANE) || mon.confused();</a>
<a name="ln290">}</a>
<a name="ln291"> </a>
<a name="ln292">// Check up to eight grids in the given direction for whether there's a</a>
<a name="ln293">// monster of the same alignment as the given monster that happens to</a>
<a name="ln294">// have a ranged attack. If this is true for the first monster encountered,</a>
<a name="ln295">// returns true. Otherwise returns false.</a>
<a name="ln296">static bool _ranged_ally_in_dir(monster* mon, coord_def p)</a>
<a name="ln297">{</a>
<a name="ln298">    coord_def pos = mon-&gt;pos();</a>
<a name="ln299"> </a>
<a name="ln300">    for (int i = 1; i &lt;= LOS_RADIUS; i++)</a>
<a name="ln301">    {</a>
<a name="ln302">        pos += p;</a>
<a name="ln303">        if (!in_bounds(pos))</a>
<a name="ln304">            break;</a>
<a name="ln305"> </a>
<a name="ln306">        const actor* ally = actor_at(pos);</a>
<a name="ln307">        if (ally == nullptr)</a>
<a name="ln308">            continue;</a>
<a name="ln309"> </a>
<a name="ln310">        if (mons_aligned(mon, ally))</a>
<a name="ln311">        {</a>
<a name="ln312">            // Hostile monsters of normal intelligence only move aside for</a>
<a name="ln313">            // monsters of the same type.</a>
<a name="ln314">            if (_unfriendly_or_impaired(*mon)</a>
<a name="ln315">                &amp;&amp; mons_genus(mon-&gt;type) != mons_genus(ally-&gt;type))</a>
<a name="ln316">            {</a>
<a name="ln317">                return false;</a>
<a name="ln318">            }</a>
<a name="ln319"> </a>
<a name="ln320">            // XXX: Always assumes the player wants a better shot.</a>
<a name="ln321">            // This isn't always true.</a>
<a name="ln322">            if (ally-&gt;is_monster())</a>
<a name="ln323">                return mons_has_ranged_attack(*(ally-&gt;as_monster()));</a>
<a name="ln324">            else if (ally-&gt;is_player())</a>
<a name="ln325">                return true;</a>
<a name="ln326">        }</a>
<a name="ln327">        break;</a>
<a name="ln328">    }</a>
<a name="ln329">    return false;</a>
<a name="ln330">}</a>
<a name="ln331"> </a>
<a name="ln332">// Check whether there's a monster of the same type and alignment adjacent</a>
<a name="ln333">// to the given monster in at least one of three given directions (relative to</a>
<a name="ln334">// the monster position).</a>
<a name="ln335">static bool _allied_monster_at(monster* mon, coord_def a, coord_def b,</a>
<a name="ln336">                               coord_def c)</a>
<a name="ln337">{</a>
<a name="ln338">    for (coord_def delta : { a, b, c })</a>
<a name="ln339">    {</a>
<a name="ln340">        coord_def pos = mon-&gt;pos() + delta;</a>
<a name="ln341">        if (!in_bounds(pos))</a>
<a name="ln342">            continue;</a>
<a name="ln343"> </a>
<a name="ln344">        const monster* ally = monster_at(pos);</a>
<a name="ln345">        if (ally == nullptr)</a>
<a name="ln346">            continue;</a>
<a name="ln347"> </a>
<a name="ln348">        if (ally-&gt;is_stationary() || ally-&gt;reach_range() &gt; REACH_NONE)</a>
<a name="ln349">            continue;</a>
<a name="ln350"> </a>
<a name="ln351">        // Hostile monsters of normal intelligence only move aside for</a>
<a name="ln352">        // monsters of the same genus.</a>
<a name="ln353">        if (_unfriendly_or_impaired(*mon)</a>
<a name="ln354">            &amp;&amp; mons_genus(mon-&gt;type) != mons_genus(ally-&gt;type))</a>
<a name="ln355">        {</a>
<a name="ln356">            continue;</a>
<a name="ln357">        }</a>
<a name="ln358"> </a>
<a name="ln359">        if (mons_aligned(mon, ally))</a>
<a name="ln360">            return true;</a>
<a name="ln361">    }</a>
<a name="ln362"> </a>
<a name="ln363">    return false;</a>
<a name="ln364">}</a>
<a name="ln365"> </a>
<a name="ln366">// Altars as well as branch entrances are considered interesting for</a>
<a name="ln367">// some monster types.</a>
<a name="ln368">static bool _mon_on_interesting_grid(monster* mon)</a>
<a name="ln369">{</a>
<a name="ln370">    const dungeon_feature_type feat = grd(mon-&gt;pos());</a>
<a name="ln371"> </a>
<a name="ln372">    switch (feat)</a>
<a name="ln373">    {</a>
<a name="ln374">    // Holy beings will tend to patrol around altars to the good gods.</a>
<a name="ln375">    case DNGN_ALTAR_ELYVILON:</a>
<a name="ln376">        if (!one_chance_in(3))</a>
<a name="ln377">            return false;</a>
<a name="ln378">        // else fall through</a>
<a name="ln379">    case DNGN_ALTAR_ZIN:</a>
<a name="ln380">    case DNGN_ALTAR_SHINING_ONE:</a>
<a name="ln381">        return mon-&gt;is_holy();</a>
<a name="ln382"> </a>
<a name="ln383">    // Orcs will tend to patrol around altars to Beogh, and guard the</a>
<a name="ln384">    // stairway from and to the Orcish Mines.</a>
<a name="ln385">    case DNGN_ALTAR_BEOGH:</a>
<a name="ln386">    case DNGN_ENTER_ORC:</a>
<a name="ln387">    case DNGN_EXIT_ORC:</a>
<a name="ln388">        return mons_is_native_in_branch(*mon, BRANCH_ORC);</a>
<a name="ln389"> </a>
<a name="ln390">    // Same for elves and the Elven Halls.</a>
<a name="ln391">    case DNGN_ENTER_ELF:</a>
<a name="ln392">    case DNGN_EXIT_ELF:</a>
<a name="ln393">        return mons_is_native_in_branch(*mon, BRANCH_ELF);</a>
<a name="ln394"> </a>
<a name="ln395">    // Spiders...</a>
<a name="ln396">    case DNGN_ENTER_SPIDER:</a>
<a name="ln397">        return mons_is_native_in_branch(*mon, BRANCH_SPIDER);</a>
<a name="ln398"> </a>
<a name="ln399">    default:</a>
<a name="ln400">        return false;</a>
<a name="ln401">    }</a>
<a name="ln402">}</a>
<a name="ln403"> </a>
<a name="ln404">// If a hostile monster finds itself on a grid of an &quot;interesting&quot; feature,</a>
<a name="ln405">// while unoccupied, it will remain in that area, and try to return to it</a>
<a name="ln406">// if it left it for fighting, seeking etc.</a>
<a name="ln407">static void _maybe_set_patrol_route(monster* mons)</a>
<a name="ln408">{</a>
<a name="ln409">    if (_mon_on_interesting_grid(mons) // Patrolling shouldn't always happen</a>
<a name="ln410">        &amp;&amp; one_chance_in(4)</a>
<a name="ln411">        &amp;&amp; mons_is_wandering(*mons)</a>
<a name="ln412">        &amp;&amp; !mons-&gt;is_patrolling()</a>
<a name="ln413">        &amp;&amp; !mons-&gt;friendly())</a>
<a name="ln414">    {</a>
<a name="ln415">        mons-&gt;patrol_point = mons-&gt;pos();</a>
<a name="ln416">    }</a>
<a name="ln417">}</a>
<a name="ln418"> </a>
<a name="ln419">static bool _mons_can_cast_dig(const monster* mons, bool random)</a>
<a name="ln420">{</a>
<a name="ln421">    if (mons-&gt;foe == MHITNOT || !mons-&gt;has_spell(SPELL_DIG) || mons-&gt;confused()</a>
<a name="ln422">        || mons-&gt;berserk_or_insane())</a>
<a name="ln423">    {</a>
<a name="ln424">        return false;</a>
<a name="ln425">    }</a>
<a name="ln426"> </a>
<a name="ln427">    const bool antimagiced = mons-&gt;has_ench(ENCH_ANTIMAGIC)</a>
<a name="ln428">                      &amp;&amp; (random</a>
<a name="ln429">                          &amp;&amp; !x_chance_in_y(4 * BASELINE_DELAY,</a>
<a name="ln430">                                            4 * BASELINE_DELAY</a>
<a name="ln431">                                            + mons-&gt;get_ench(ENCH_ANTIMAGIC).duration)</a>
<a name="ln432">                      || (!random</a>
<a name="ln433">                          &amp;&amp; mons-&gt;get_ench(ENCH_ANTIMAGIC).duration</a>
<a name="ln434">                             &gt;= 4 * BASELINE_DELAY));</a>
<a name="ln435">    const auto flags = mons-&gt;spell_slot_flags(SPELL_DIG);</a>
<a name="ln436">    return !(antimagiced &amp;&amp; flags &amp; MON_SPELL_ANTIMAGIC_MASK)</a>
<a name="ln437">            &amp;&amp; !(mons-&gt;is_silenced() &amp;&amp; flags &amp; MON_SPELL_SILENCE_MASK);</a>
<a name="ln438">}</a>
<a name="ln439"> </a>
<a name="ln440">static bool _mons_can_zap_dig(const monster* mons)</a>
<a name="ln441">{</a>
<a name="ln442">    return mons-&gt;foe != MHITNOT</a>
<a name="ln443">           &amp;&amp; !mons-&gt;asleep()</a>
<a name="ln444">           &amp;&amp; !mons-&gt;confused() // they don't get here anyway</a>
<a name="ln445">           &amp;&amp; !mons-&gt;berserk_or_insane()</a>
<a name="ln446">           &amp;&amp; !mons-&gt;submerged()</a>
<a name="ln447">           &amp;&amp; mons_itemuse(*mons) &gt;= MONUSE_STARTING_EQUIPMENT</a>
<a name="ln448">           &amp;&amp; mons-&gt;inv[MSLOT_WAND] != NON_ITEM</a>
<a name="ln449">           &amp;&amp; mitm[mons-&gt;inv[MSLOT_WAND]].is_type(OBJ_WANDS, WAND_DIGGING)</a>
<a name="ln450">           &amp;&amp; mitm[mons-&gt;inv[MSLOT_WAND]].charges &gt; 0;</a>
<a name="ln451">}</a>
<a name="ln452"> </a>
<a name="ln453">static void _set_mons_move_dir(const monster* mons,</a>
<a name="ln454">                               coord_def* dir, coord_def* delta)</a>
<a name="ln455">{</a>
<a name="ln456">    ASSERT(dir);</a>
<a name="ln457">    ASSERT(delta);</a>
<a name="ln458"> </a>
<a name="ln459">    // Some calculations.</a>
<a name="ln460">    if ((mons_class_flag(mons-&gt;type, M_BURROWS)</a>
<a name="ln461">         || _mons_can_cast_dig(mons, false))</a>
<a name="ln462">        &amp;&amp; mons-&gt;foe == MHITYOU)</a>
<a name="ln463">    {</a>
<a name="ln464">        // Digging monsters always move in a straight line in your direction.</a>
<a name="ln465">        *delta = you.pos() - mons-&gt;pos();</a>
<a name="ln466">    }</a>
<a name="ln467">    else</a>
<a name="ln468">    {</a>
<a name="ln469">        *delta = (mons-&gt;firing_pos.zero() ? mons-&gt;target : mons-&gt;firing_pos)</a>
<a name="ln470">                 - mons-&gt;pos();</a>
<a name="ln471">    }</a>
<a name="ln472"> </a>
<a name="ln473">    // Move the monster.</a>
<a name="ln474">    *dir = delta-&gt;sgn();</a>
<a name="ln475"> </a>
<a name="ln476">    if (mons_is_retreating(*mons)</a>
<a name="ln477">        &amp;&amp; (!mons-&gt;friendly() || mons-&gt;target != you.pos()))</a>
<a name="ln478">    {</a>
<a name="ln479">        *dir *= -1;</a>
<a name="ln480">    }</a>
<a name="ln481">}</a>
<a name="ln482"> </a>
<a name="ln483">typedef FixedArray&lt; bool, 3, 3 &gt; move_array;</a>
<a name="ln484"> </a>
<a name="ln485">static void _fill_good_move(const monster* mons, move_array* good_move)</a>
<a name="ln486">{</a>
<a name="ln487">    for (int count_x = 0; count_x &lt; 3; count_x++)</a>
<a name="ln488">        for (int count_y = 0; count_y &lt; 3; count_y++)</a>
<a name="ln489">        {</a>
<a name="ln490">            const int targ_x = mons-&gt;pos().x + count_x - 1;</a>
<a name="ln491">            const int targ_y = mons-&gt;pos().y + count_y - 1;</a>
<a name="ln492"> </a>
<a name="ln493">            // Bounds check: don't consider moving out of grid!</a>
<a name="ln494">            if (!in_bounds(targ_x, targ_y))</a>
<a name="ln495">            {</a>
<a name="ln496">                (*good_move)[count_x][count_y] = false;</a>
<a name="ln497">                continue;</a>
<a name="ln498">            }</a>
<a name="ln499"> </a>
<a name="ln500">            (*good_move)[count_x][count_y] =</a>
<a name="ln501">                mon_can_move_to_pos(mons, coord_def(count_x-1, count_y-1));</a>
<a name="ln502">        }</a>
<a name="ln503">}</a>
<a name="ln504"> </a>
<a name="ln505">// This only tracks movement, not whether hitting an</a>
<a name="ln506">// adjacent monster is a possible move.</a>
<a name="ln507">bool mons_can_move_towards_target(const monster* mon)</a>
<a name="ln508">{</a>
<a name="ln509">    coord_def mov, delta;</a>
<a name="ln510">    _set_mons_move_dir(mon, &amp;mov, &amp;delta);</a>
<a name="ln511"> </a>
<a name="ln512">    move_array good_move;</a>
<a name="ln513">    _fill_good_move(mon, &amp;good_move);</a>
<a name="ln514"> </a>
<a name="ln515">    int dir = _compass_idx(mov);</a>
<a name="ln516">    for (int i = -1; i &lt;= 1; ++i)</a>
<a name="ln517">    {</a>
<a name="ln518">        const int altdir = (dir + i + 8) % 8;</a>
<a name="ln519">        const coord_def p = mon_compass[altdir] + coord_def(1, 1);</a>
<a name="ln520">        if (good_move(p))</a>
<a name="ln521">            return true;</a>
<a name="ln522">    }</a>
<a name="ln523"> </a>
<a name="ln524">    return false;</a>
<a name="ln525">}</a>
<a name="ln526"> </a>
<a name="ln527">static void _handle_movement(monster* mons)</a>
<a name="ln528">{</a>
<a name="ln529">    _maybe_set_patrol_route(mons);</a>
<a name="ln530"> </a>
<a name="ln531">    if (sanctuary_exists())</a>
<a name="ln532">    {</a>
<a name="ln533">        // Monsters will try to flee out of a sanctuary.</a>
<a name="ln534">        if (is_sanctuary(mons-&gt;pos())</a>
<a name="ln535">            &amp;&amp; mons_is_influenced_by_sanctuary(*mons)</a>
<a name="ln536">            &amp;&amp; !mons_is_fleeing_sanctuary(*mons))</a>
<a name="ln537">        {</a>
<a name="ln538">            mons_start_fleeing_from_sanctuary(*mons);</a>
<a name="ln539">        }</a>
<a name="ln540">        else if (mons_is_fleeing_sanctuary(*mons)</a>
<a name="ln541">                 &amp;&amp; !is_sanctuary(mons-&gt;pos()))</a>
<a name="ln542">        {</a>
<a name="ln543">            // Once outside there's a chance they'll regain their courage.</a>
<a name="ln544">            // Nonliving and berserking monsters always stop immediately,</a>
<a name="ln545">            // since they're only being forced out rather than actually</a>
<a name="ln546">            // scared.</a>
<a name="ln547">            if (mons-&gt;is_nonliving()</a>
<a name="ln548">                || mons-&gt;berserk()</a>
<a name="ln549">                || mons-&gt;has_ench(ENCH_INSANE)</a>
<a name="ln550">                || x_chance_in_y(2, 5))</a>
<a name="ln551">            {</a>
<a name="ln552">                mons_stop_fleeing_from_sanctuary(*mons);</a>
<a name="ln553">            }</a>
<a name="ln554">        }</a>
<a name="ln555">    }</a>
<a name="ln556"> </a>
<a name="ln557">    coord_def delta;</a>
<a name="ln558">    _set_mons_move_dir(mons, &amp;mmov, &amp;delta);</a>
<a name="ln559"> </a>
<a name="ln560">    if (sanctuary_exists())</a>
<a name="ln561">    {</a>
<a name="ln562">        // Don't allow monsters to enter a sanctuary or attack you inside a</a>
<a name="ln563">        // sanctuary, even if you're right next to them.</a>
<a name="ln564">        if (is_sanctuary(mons-&gt;pos() + mmov)</a>
<a name="ln565">            &amp;&amp; (!is_sanctuary(mons-&gt;pos())</a>
<a name="ln566">                || mons-&gt;pos() + mmov == you.pos()))</a>
<a name="ln567">        {</a>
<a name="ln568">            mmov.reset();</a>
<a name="ln569">        }</a>
<a name="ln570">    }</a>
<a name="ln571"> </a>
<a name="ln572">    // Bounds check: don't let fleeing monsters try to run off the grid.</a>
<a name="ln573">    const coord_def s = mons-&gt;pos() + mmov;</a>
<a name="ln574">    if (!in_bounds_x(s.x))</a>
<a name="ln575">        mmov.x = 0;</a>
<a name="ln576">    if (!in_bounds_y(s.y))</a>
<a name="ln577">        mmov.y = 0;</a>
<a name="ln578"> </a>
<a name="ln579">    if (delta.rdist() &gt; 3)</a>
<a name="ln580">    {</a>
<a name="ln581">        // Reproduced here is some semi-legacy code that makes monsters</a>
<a name="ln582">        // move somewhat randomly along oblique paths. It is an</a>
<a name="ln583">        // exceedingly good idea, given crawl's unique line of sight</a>
<a name="ln584">        // properties.</a>
<a name="ln585">        //</a>
<a name="ln586">        // Added a check so that oblique movement paths aren't used when</a>
<a name="ln587">        // close to the target square. -- bwr</a>
<a name="ln588"> </a>
<a name="ln589">        // Sometimes we'll just move parallel the x axis.</a>
<a name="ln590">        if (abs(delta.x) &gt; abs(delta.y) &amp;&amp; coinflip())</a>
<a name="ln591">            mmov.y = 0;</a>
<a name="ln592"> </a>
<a name="ln593">        // Sometimes we'll just move parallel the y axis.</a>
<a name="ln594">        if (abs(delta.y) &gt; abs(delta.x) &amp;&amp; coinflip())</a>
<a name="ln595">            mmov.x = 0;</a>
<a name="ln596">    }</a>
<a name="ln597"> </a>
<a name="ln598">    // Now quit if we can't move.</a>
<a name="ln599">    if (mmov.origin())</a>
<a name="ln600">        return;</a>
<a name="ln601"> </a>
<a name="ln602">    const coord_def newpos(mons-&gt;pos() + mmov);</a>
<a name="ln603"> </a>
<a name="ln604">    // Filling this is relatively costly and not always needed, so be a bit</a>
<a name="ln605">    // lazy about it.</a>
<a name="ln606">    move_array good_move;</a>
<a name="ln607">    bool good_move_filled = false;</a>
<a name="ln608"> </a>
<a name="ln609">    // If the monster is moving in your direction, whether to attack or</a>
<a name="ln610">    // protect you, or towards a monster it intends to attack, check</a>
<a name="ln611">    // whether we first need to take a step to the side to make sure the</a>
<a name="ln612">    // reinforcement can follow through. Only do this with 50% chance,</a>
<a name="ln613">    // though, so it's not completely predictable.</a>
<a name="ln614"> </a>
<a name="ln615">    // First, check whether the monster is smart enough to even consider</a>
<a name="ln616">    // this.</a>
<a name="ln617">    if ((newpos == you.pos()</a>
<a name="ln618">           || monster_at(newpos) &amp;&amp; mons-&gt;foe == mgrd(newpos))</a>
<a name="ln619">        &amp;&amp; mons_intel(*mons) &gt; I_BRAINLESS</a>
<a name="ln620">        &amp;&amp; coinflip()</a>
<a name="ln621">        &amp;&amp; !mons_is_confused(*mons) &amp;&amp; !mons-&gt;caught()</a>
<a name="ln622">        &amp;&amp; !mons-&gt;berserk_or_insane())</a>
<a name="ln623">    {</a>
<a name="ln624">        _fill_good_move(mons, &amp;good_move);</a>
<a name="ln625">        good_move_filled = true;</a>
<a name="ln626">        // If the monster is moving parallel to the x or y axis, check</a>
<a name="ln627">        // if there are other unblocked grids adjacent to the target and</a>
<a name="ln628">        // whether</a>
<a name="ln629">        //</a>
<a name="ln630">        // a) the neighbouring grids are blocked and an ally is behind us,</a>
<a name="ln631">        // or</a>
<a name="ln632">        // b) we're intelligent and blocking a ranged attack</a>
<a name="ln633">        if (mmov.y == 0)</a>
<a name="ln634">        {</a>
<a name="ln635">            if ((good_move[mmov.x+1][0] || good_move[mmov.x+1][2])</a>
<a name="ln636">                &amp;&amp; (_allied_monster_at(mons, coord_def(-mmov.x, -1),</a>
<a name="ln637">                                       coord_def(-mmov.x, 0),</a>
<a name="ln638">                                       coord_def(-mmov.x, 1))</a>
<a name="ln639">                       &amp;&amp; !good_move[1][0] &amp;&amp; !good_move[1][2]</a>
<a name="ln640">                    || mons_intel(*mons) &gt;= I_HUMAN</a>
<a name="ln641">                       &amp;&amp; _ranged_ally_in_dir(mons, coord_def(-mmov.x, 0))))</a>
<a name="ln642">            {</a>
<a name="ln643">                if (good_move[mmov.x+1][0])</a>
<a name="ln644">                    mmov.y = -1;</a>
<a name="ln645">                if (good_move[mmov.x+1][2] &amp;&amp; (mmov.y == 0 || coinflip()))</a>
<a name="ln646">                    mmov.y = 1;</a>
<a name="ln647">            }</a>
<a name="ln648">        }</a>
<a name="ln649">        else if (mmov.x == 0)</a>
<a name="ln650">        {</a>
<a name="ln651">            if ((good_move[0][mmov.y+1] || good_move[2][mmov.y+1])</a>
<a name="ln652">                &amp;&amp; (_allied_monster_at(mons, coord_def(-1, -mmov.y),</a>
<a name="ln653">                                       coord_def(0, -mmov.y),</a>
<a name="ln654">                                       coord_def(1, -mmov.y))</a>
<a name="ln655">                       &amp;&amp; !good_move[0][1] &amp;&amp; !good_move[2][1]</a>
<a name="ln656">                    || mons_intel(*mons) &gt;= I_HUMAN</a>
<a name="ln657">                       &amp;&amp; _ranged_ally_in_dir(mons, coord_def(0, -mmov.y))))</a>
<a name="ln658">            {</a>
<a name="ln659">                if (good_move[0][mmov.y+1])</a>
<a name="ln660">                    mmov.x = -1;</a>
<a name="ln661">                if (good_move[2][mmov.y+1] &amp;&amp; (mmov.x == 0 || coinflip()))</a>
<a name="ln662">                    mmov.x = 1;</a>
<a name="ln663">            }</a>
<a name="ln664">        }</a>
<a name="ln665">        else // We're moving diagonally.</a>
<a name="ln666">        {</a>
<a name="ln667">            if (good_move[mmov.x+1][1])</a>
<a name="ln668">            {</a>
<a name="ln669">                if (!good_move[1][mmov.y+1]</a>
<a name="ln670">                       &amp;&amp; _allied_monster_at(mons, coord_def(-mmov.x, -1),</a>
<a name="ln671">                                           coord_def(-mmov.x, 0),</a>
<a name="ln672">                                           coord_def(-mmov.x, 1))</a>
<a name="ln673">                    || mons_intel(*mons) &gt;= I_HUMAN</a>
<a name="ln674">                       &amp;&amp; _ranged_ally_in_dir(mons, coord_def(-mmov.x, -mmov.y)))</a>
<a name="ln675">                {</a>
<a name="ln676">                    mmov.y = 0;</a>
<a name="ln677">                }</a>
<a name="ln678">            }</a>
<a name="ln679">            else if (good_move[1][mmov.y+1]</a>
<a name="ln680">                     &amp;&amp; _allied_monster_at(mons, coord_def(-1, -mmov.y),</a>
<a name="ln681">                                            coord_def(0, -mmov.y),</a>
<a name="ln682">                                            coord_def(1, -mmov.y))</a>
<a name="ln683">                         || mons_intel(*mons) &gt;= I_HUMAN</a>
<a name="ln684">                            &amp;&amp; _ranged_ally_in_dir(mons, coord_def(-mmov.x, -mmov.y)))</a>
<a name="ln685">            {</a>
<a name="ln686">                mmov.x = 0;</a>
<a name="ln687">            }</a>
<a name="ln688">        }</a>
<a name="ln689">    }</a>
<a name="ln690"> </a>
<a name="ln691">    // Now quit if we can't move.</a>
<a name="ln692">    if (mmov.origin())</a>
<a name="ln693">        return;</a>
<a name="ln694"> </a>
<a name="ln695">    // everything below here is irrelevant if the player is not in bounds, for</a>
<a name="ln696">    // example if they have stepped from time.</a>
<a name="ln697">    if (!in_bounds(you.pos()))</a>
<a name="ln698">        return;</a>
<a name="ln699"> </a>
<a name="ln700">    // Try to stay in sight of the player if we're moving towards</a>
<a name="ln701">    // him/her, in order to avoid the monster coming into view,</a>
<a name="ln702">    // shouting, and then taking a step in a path to the player which</a>
<a name="ln703">    // temporarily takes it out of view, which can lead to the player</a>
<a name="ln704">    // getting &quot;comes into view&quot; and shout messages with no monster in</a>
<a name="ln705">    // view.</a>
<a name="ln706"> </a>
<a name="ln707">    // Doesn't matter for arena mode.</a>
<a name="ln708">    if (crawl_state.game_is_arena())</a>
<a name="ln709">        return;</a>
<a name="ln710"> </a>
<a name="ln711">    // Did we just come into view?</a>
<a name="ln712">    // TODO: This doesn't seem to work right. Fix, or remove?</a>
<a name="ln713"> </a>
<a name="ln714">    if (mons-&gt;seen_context != SC_JUST_SEEN)</a>
<a name="ln715">        return;</a>
<a name="ln716">    if (testbits(mons-&gt;flags, MF_WAS_IN_VIEW))</a>
<a name="ln717">        return;</a>
<a name="ln718"> </a>
<a name="ln719">    const coord_def old_pos  = mons-&gt;pos();</a>
<a name="ln720">    const int       old_dist = grid_distance(you.pos(), old_pos);</a>
<a name="ln721"> </a>
<a name="ln722">    // We're already staying in the player's LOS.</a>
<a name="ln723">    if (you.see_cell(old_pos + mmov))</a>
<a name="ln724">        return;</a>
<a name="ln725"> </a>
<a name="ln726">    // We're not moving towards the player.</a>
<a name="ln727">    if (grid_distance(you.pos(), old_pos + mmov) &gt;= old_dist)</a>
<a name="ln728">    {</a>
<a name="ln729">        // Instead of moving out of view, we stay put.</a>
<a name="ln730">        if (you.see_cell(old_pos))</a>
<a name="ln731">            mmov.reset();</a>
<a name="ln732">        return;</a>
<a name="ln733">    }</a>
<a name="ln734"> </a>
<a name="ln735">    // Try to find a move that brings us closer to the player while</a>
<a name="ln736">    // keeping us in view.</a>
<a name="ln737">    int matches = 0;</a>
<a name="ln738">    for (int i = 0; i &lt; 3; i++)</a>
<a name="ln739">        for (int j = 0; j &lt; 3; j++)</a>
<a name="ln740">        {</a>
<a name="ln741">            if (i == 0 &amp;&amp; j == 0)</a>
<a name="ln742">                continue;</a>
<a name="ln743"> </a>
<a name="ln744">            coord_def d(i - 1, j - 1);</a>
<a name="ln745">            coord_def tmp = old_pos + d;</a>
<a name="ln746">            if (!you.see_cell(tmp))</a>
<a name="ln747">                continue;</a>
<a name="ln748"> </a>
<a name="ln749">            if (!good_move_filled)</a>
<a name="ln750">            {</a>
<a name="ln751">                _fill_good_move(mons, &amp;good_move);</a>
<a name="ln752">                good_move_filled = true;</a>
<a name="ln753">            }</a>
<a name="ln754">            if (!good_move[i][j])</a>
<a name="ln755">                continue;</a>
<a name="ln756"> </a>
<a name="ln757">            if (grid_distance(you.pos(), tmp) &lt; old_dist)</a>
<a name="ln758">            {</a>
<a name="ln759">                if (one_chance_in(++matches))</a>
<a name="ln760">                    mmov = d;</a>
<a name="ln761">                break;</a>
<a name="ln762">            }</a>
<a name="ln763">        }</a>
<a name="ln764"> </a>
<a name="ln765">    // We haven't been able to find a visible cell to move to. If previous</a>
<a name="ln766">    // position was visible, we stay put.</a>
<a name="ln767">    if (you.see_cell(old_pos) &amp;&amp; !you.see_cell(old_pos + mmov))</a>
<a name="ln768">        mmov.reset();</a>
<a name="ln769">}</a>
<a name="ln770"> </a>
<a name="ln771">static bool _handle_potion(monster&amp; mons)</a>
<a name="ln772">{</a>
<a name="ln773">    item_def* potion = mons.mslot_item(MSLOT_POTION);</a>
<a name="ln774">    if (mons.asleep()</a>
<a name="ln775">        || !potion</a>
<a name="ln776">        || !one_chance_in(3)</a>
<a name="ln777">        || mons_itemuse(mons) &lt; MONUSE_STARTING_EQUIPMENT</a>
<a name="ln778">        || potion-&gt;base_type != OBJ_POTIONS)</a>
<a name="ln779">    {</a>
<a name="ln780">        return false;</a>
<a name="ln781">    }</a>
<a name="ln782"> </a>
<a name="ln783">    bool rc = false;</a>
<a name="ln784"> </a>
<a name="ln785">    const potion_type ptype = static_cast&lt;potion_type&gt;(potion-&gt;sub_type);</a>
<a name="ln786"> </a>
<a name="ln787">    if (mons.can_drink_potion(ptype) &amp;&amp; mons.should_drink_potion(ptype))</a>
<a name="ln788">    {</a>
<a name="ln789">        const bool was_visible = you.can_see(mons);</a>
<a name="ln790"> </a>
<a name="ln791">        // XXX: this is mostly to prevent a funny message order:</a>
<a name="ln792">        // &quot;$foo drinks a potion. $foo wields a great mace. $foo goes berserk!&quot;</a>
<a name="ln793">        if (ptype == POT_BERSERK_RAGE)</a>
<a name="ln794">            mons.wield_melee_weapon();</a>
<a name="ln795"> </a>
<a name="ln796">        // Drink the potion, and identify it.</a>
<a name="ln797">        if (mons.drink_potion_effect(ptype) &amp;&amp; was_visible)</a>
<a name="ln798">            set_ident_type(OBJ_POTIONS, ptype, true);</a>
<a name="ln799"> </a>
<a name="ln800">        // Remove it from inventory.</a>
<a name="ln801">        if (dec_mitm_item_quantity(potion-&gt;index(), 1))</a>
<a name="ln802">            mons.inv[MSLOT_POTION] = NON_ITEM;</a>
<a name="ln803"> </a>
<a name="ln804">        mons.lose_energy(EUT_ITEM);</a>
<a name="ln805">        rc = true;</a>
<a name="ln806">    }</a>
<a name="ln807"> </a>
<a name="ln808">    return rc;</a>
<a name="ln809">}</a>
<a name="ln810"> </a>
<a name="ln811">static bool _handle_evoke_equipment(monster&amp; mons)</a>
<a name="ln812">{</a>
<a name="ln813">    // TODO: check non-ring, non-amulet equipment</a>
<a name="ln814">    item_def* jewel = mons.mslot_item(MSLOT_JEWELLERY);</a>
<a name="ln815">    if (mons.asleep()</a>
<a name="ln816">        || mons_is_confused(mons)</a>
<a name="ln817">        || !jewel</a>
<a name="ln818">        || !one_chance_in(3)</a>
<a name="ln819">        || mons_itemuse(mons) &lt; MONUSE_STARTING_EQUIPMENT</a>
<a name="ln820">        || jewel-&gt;base_type != OBJ_JEWELLERY)</a>
<a name="ln821">    {</a>
<a name="ln822">        return false;</a>
<a name="ln823">    }</a>
<a name="ln824"> </a>
<a name="ln825">    bool rc = false;</a>
<a name="ln826"> </a>
<a name="ln827">    const jewellery_type jtype = static_cast&lt;jewellery_type&gt;(jewel-&gt;sub_type);</a>
<a name="ln828"> </a>
<a name="ln829">    if (mons.can_evoke_jewellery(jtype) &amp;&amp; mons.should_evoke_jewellery(jtype))</a>
<a name="ln830">    {</a>
<a name="ln831">        const bool was_visible = you.can_see(mons);</a>
<a name="ln832"> </a>
<a name="ln833">        // Evoke the item, and identify it.</a>
<a name="ln834">        if (mons.evoke_jewellery_effect(jtype) &amp;&amp; was_visible)</a>
<a name="ln835">            set_ident_type(OBJ_JEWELLERY, jtype, true);</a>
<a name="ln836"> </a>
<a name="ln837">        mons.lose_energy(EUT_ITEM);</a>
<a name="ln838">        rc = true;</a>
<a name="ln839">    }</a>
<a name="ln840"> </a>
<a name="ln841">    return rc;</a>
<a name="ln842">}</a>
<a name="ln843"> </a>
<a name="ln844">/**</a>
<a name="ln845"> * Check if the monster has a swooping attack and is in a position to</a>
<a name="ln846"> * use it, and do so if they can.</a>
<a name="ln847"> *</a>
<a name="ln848"> * Specifically, this seems to try to move to the opposite side of the target</a>
<a name="ln849"> * (if there's space) and perform a melee attack, then set a cooldown for</a>
<a name="ln850"> * 4-8 turns.</a>
<a name="ln851"> *</a>
<a name="ln852"> * @param mons The monster who might be swooping.</a>
<a name="ln853"> * @return Whether they performed a swoop attack. False if the monster</a>
<a name="ln854"> *         can't swoop, the foe isn't hostile, the positioning doesn't</a>
<a name="ln855"> *         work, etc.</a>
<a name="ln856"> */</a>
<a name="ln857">static bool _handle_swoop(monster&amp; mons)</a>
<a name="ln858">{</a>
<a name="ln859">    // TODO: check for AF_SWOOP in other slots and/or make it work there?</a>
<a name="ln860">    if (mons_attack_spec(mons, 0, true).flavour != AF_SWOOP)</a>
<a name="ln861">        return false;</a>
<a name="ln862"> </a>
<a name="ln863">    actor *defender = mons.get_foe();</a>
<a name="ln864">    if (mons.confused() || !defender || !mons.can_see(*defender))</a>
<a name="ln865">        return false;</a>
<a name="ln866"> </a>
<a name="ln867">    if (mons.foe_distance() &gt;= 5 || mons.foe_distance() == 1)</a>
<a name="ln868">        return false;</a>
<a name="ln869"> </a>
<a name="ln870">    if (!one_chance_in(4))</a>
<a name="ln871">        return false;</a>
<a name="ln872"> </a>
<a name="ln873">    if (mons.props.exists(&quot;swoop_cooldown&quot;)</a>
<a name="ln874">        &amp;&amp; (you.elapsed_time &lt; mons.props[&quot;swoop_cooldown&quot;].get_int()))</a>
<a name="ln875">    {</a>
<a name="ln876">        return false;</a>
<a name="ln877">    }</a>
<a name="ln878"> </a>
<a name="ln879">    coord_def target = defender-&gt;pos();</a>
<a name="ln880"> </a>
<a name="ln881">    bolt tracer;</a>
<a name="ln882">    tracer.source = mons.pos();</a>
<a name="ln883">    tracer.target = target;</a>
<a name="ln884">    tracer.is_tracer = true;</a>
<a name="ln885">    tracer.pierce = true;</a>
<a name="ln886">    tracer.range = LOS_RADIUS;</a>
<a name="ln887">    tracer.fire();</a>
<a name="ln888"> </a>
<a name="ln889">    for (unsigned int j = 0; j &lt; tracer.path_taken.size() - 1; ++j)</a>
<a name="ln890">    {</a>
<a name="ln891">        if (tracer.path_taken[j] != target)</a>
<a name="ln892">            continue;</a>
<a name="ln893"> </a>
<a name="ln894">        if (!monster_habitable_grid(&amp;mons, grd(tracer.path_taken[j+1]))</a>
<a name="ln895">            || actor_at(tracer.path_taken[j+1]))</a>
<a name="ln896">        {</a>
<a name="ln897">            continue;</a>
<a name="ln898">        }</a>
<a name="ln899"> </a>
<a name="ln900">        if (you.can_see(mons))</a>
<a name="ln901">        {</a>
<a name="ln902">            mprf(&quot;%s swoops through the air toward %s!&quot;,</a>
<a name="ln903">                 mons.name(DESC_THE).c_str(),</a>
<a name="ln904">                 defender-&gt;name(DESC_THE).c_str());</a>
<a name="ln905">        }</a>
<a name="ln906">        mons.move_to_pos(tracer.path_taken[j+1]);</a>
<a name="ln907">        fight_melee(&amp;mons, defender);</a>
<a name="ln908">        mons.props[&quot;swoop_cooldown&quot;].get_int() = you.elapsed_time</a>
<a name="ln909">                                                  + 40 + random2(51);</a>
<a name="ln910">        return true;</a>
<a name="ln911">    }</a>
<a name="ln912"> </a>
<a name="ln913">    return false;</a>
<a name="ln914">}</a>
<a name="ln915"> </a>
<a name="ln916">/**</a>
<a name="ln917"> * Check whether this monster can make a reaching attack, and do so if</a>
<a name="ln918"> * they can.</a>
<a name="ln919"> *</a>
<a name="ln920"> * @param mons The monster who might be reaching.</a>
<a name="ln921"> * @return Whether they attempted a reaching attack. False if the monster</a>
<a name="ln922"> *         doesn't have a reaching weapon, the foe isn't hostile, the foe</a>
<a name="ln923"> *         is too near or too far, etc.</a>
<a name="ln924"> */</a>
<a name="ln925">static bool _handle_reaching(monster* mons)</a>
<a name="ln926">{</a>
<a name="ln927">    bool       ret = false;</a>
<a name="ln928">    const reach_type range = mons-&gt;reach_range();</a>
<a name="ln929">    actor *foe = mons-&gt;get_foe();</a>
<a name="ln930"> </a>
<a name="ln931">    if (mons-&gt;caught()</a>
<a name="ln932">        || mons_is_confused(*mons)</a>
<a name="ln933">        || !foe</a>
<a name="ln934">        || range &lt;= REACH_NONE</a>
<a name="ln935">        || is_sanctuary(mons-&gt;pos())</a>
<a name="ln936">        || is_sanctuary(foe-&gt;pos())</a>
<a name="ln937">        || mons-&gt;submerged()</a>
<a name="ln938">        || (mons_aligned(mons, foe) &amp;&amp; !mons-&gt;has_ench(ENCH_INSANE))</a>
<a name="ln939">        || (mons_is_fleeing(*mons)</a>
<a name="ln940">        || mons-&gt;pacified()))</a>
<a name="ln941">    {</a>
<a name="ln942">        return false;</a>
<a name="ln943">    }</a>
<a name="ln944"> </a>
<a name="ln945">    const coord_def foepos(foe-&gt;pos());</a>
<a name="ln946">    const coord_def delta(foepos - mons-&gt;pos());</a>
<a name="ln947">    const int grid_distance(delta.rdist());</a>
<a name="ln948">    const coord_def first_middle(mons-&gt;pos() + delta / 2);</a>
<a name="ln949">    const coord_def second_middle(foepos - delta / 2);</a>
<a name="ln950"> </a>
<a name="ln951">    if (grid_distance == 2</a>
<a name="ln952">        // The monster has to be attacking the correct position.</a>
<a name="ln953">        &amp;&amp; mons-&gt;target == foepos</a>
<a name="ln954">        // With a reaching attack with a large enough range:</a>
<a name="ln955">        &amp;&amp; delta.rdist() &lt;= range</a>
<a name="ln956">        // And with no dungeon furniture in the way of the reaching</a>
<a name="ln957">        // attack;</a>
<a name="ln958">        &amp;&amp; (feat_is_reachable_past(grd(first_middle))</a>
<a name="ln959">            || feat_is_reachable_past(grd(second_middle)))</a>
<a name="ln960">        // The foe should be on the map (not stepped from time).</a>
<a name="ln961">        &amp;&amp; in_bounds(foepos))</a>
<a name="ln962">    {</a>
<a name="ln963">        ret = true;</a>
<a name="ln964"> </a>
<a name="ln965">        ASSERT(foe-&gt;is_player() || foe-&gt;is_monster());</a>
<a name="ln966"> </a>
<a name="ln967">        fight_melee(mons, foe);</a>
<a name="ln968">    }</a>
<a name="ln969"> </a>
<a name="ln970">    return ret;</a>
<a name="ln971">}</a>
<a name="ln972"> </a>
<a name="ln973">static bool _handle_scroll(monster&amp; mons)</a>
<a name="ln974">{</a>
<a name="ln975">    item_def* scroll = mons.mslot_item(MSLOT_SCROLL);</a>
<a name="ln976"> </a>
<a name="ln977">    // Yes, there is a logic to this ordering {dlb}:</a>
<a name="ln978">    if (mons.asleep()</a>
<a name="ln979">        || mons_is_confused(mons)</a>
<a name="ln980">        || mons.submerged()</a>
<a name="ln981">        || !scroll</a>
<a name="ln982">        || mons.has_ench(ENCH_BLIND)</a>
<a name="ln983">        || !one_chance_in(3)</a>
<a name="ln984">        || mons_itemuse(mons) &lt; MONUSE_STARTING_EQUIPMENT</a>
<a name="ln985">        || silenced(mons.pos())</a>
<a name="ln986">        || scroll-&gt;base_type != OBJ_SCROLLS)</a>
<a name="ln987">    {</a>
<a name="ln988">        return false;</a>
<a name="ln989">    }</a>
<a name="ln990"> </a>
<a name="ln991">    bool read        = false;</a>
<a name="ln992">    bool was_visible = you.can_see(mons);</a>
<a name="ln993"> </a>
<a name="ln994">    // Notice how few cases are actually accounted for here {dlb}:</a>
<a name="ln995">    const int scroll_type = scroll-&gt;sub_type;</a>
<a name="ln996">    switch (scroll_type)</a>
<a name="ln997">    {</a>
<a name="ln998">    case SCR_TELEPORTATION:</a>
<a name="ln999">        if (!mons.has_ench(ENCH_TP) &amp;&amp; !mons.no_tele(true, false))</a>
<a name="ln1000">        {</a>
<a name="ln1001">            if (mons.caught() || mons_is_fleeing(mons) || mons.pacified())</a>
<a name="ln1002">            {</a>
<a name="ln1003">                simple_monster_message(mons, &quot; reads a scroll.&quot;);</a>
<a name="ln1004">                read = true;</a>
<a name="ln1005">                monster_teleport(&amp;mons, false);</a>
<a name="ln1006">            }</a>
<a name="ln1007">        }</a>
<a name="ln1008">        break;</a>
<a name="ln1009"> </a>
<a name="ln1010">    case SCR_BLINKING:</a>
<a name="ln1011">        if ((mons.caught() || mons_is_fleeing(mons) || mons.pacified())</a>
<a name="ln1012">            &amp;&amp; mons.can_see(you) &amp;&amp; !mons.no_tele(true, false))</a>
<a name="ln1013">        {</a>
<a name="ln1014">            simple_monster_message(mons, &quot; reads a scroll.&quot;);</a>
<a name="ln1015">            read = true;</a>
<a name="ln1016">            if (mons.caught())</a>
<a name="ln1017">                monster_blink(&amp;mons);</a>
<a name="ln1018">            else</a>
<a name="ln1019">                blink_away(&amp;mons);</a>
<a name="ln1020">        }</a>
<a name="ln1021">        break;</a>
<a name="ln1022"> </a>
<a name="ln1023">    case SCR_SUMMONING:</a>
<a name="ln1024">        if (mons.can_see(you))</a>
<a name="ln1025">        {</a>
<a name="ln1026">            simple_monster_message(mons, &quot; reads a scroll.&quot;);</a>
<a name="ln1027">            mprf(&quot;Wisps of shadow swirl around %s.&quot;, mons.name(DESC_THE).c_str());</a>
<a name="ln1028">            read = true;</a>
<a name="ln1029">            int count = roll_dice(2, 2);</a>
<a name="ln1030">            for (int i = 0; i &lt; count; ++i)</a>
<a name="ln1031">            {</a>
<a name="ln1032">                create_monster(</a>
<a name="ln1033">                    mgen_data(RANDOM_MOBILE_MONSTER, SAME_ATTITUDE((&amp;mons)),</a>
<a name="ln1034">                              mons.pos(), mons.foe)</a>
<a name="ln1035">                    .set_summoned(&amp;mons, 3, MON_SUMM_SCROLL));</a>
<a name="ln1036">            }</a>
<a name="ln1037">        }</a>
<a name="ln1038">        break;</a>
<a name="ln1039">    }</a>
<a name="ln1040"> </a>
<a name="ln1041">    if (read)</a>
<a name="ln1042">    {</a>
<a name="ln1043">        if (dec_mitm_item_quantity(mons.inv[MSLOT_SCROLL], 1))</a>
<a name="ln1044">            mons.inv[MSLOT_SCROLL] = NON_ITEM;</a>
<a name="ln1045"> </a>
<a name="ln1046">        if (was_visible)</a>
<a name="ln1047">            set_ident_type(OBJ_SCROLLS, scroll_type, true);</a>
<a name="ln1048"> </a>
<a name="ln1049">        mons.lose_energy(EUT_ITEM);</a>
<a name="ln1050">    }</a>
<a name="ln1051"> </a>
<a name="ln1052">    return read;</a>
<a name="ln1053">}</a>
<a name="ln1054"> </a>
<a name="ln1055">static void _mons_fire_wand(monster&amp; mons, item_def &amp;wand, bolt &amp;beem,</a>
<a name="ln1056">                            bool was_visible)</a>
<a name="ln1057">{</a>
<a name="ln1058">    if (!simple_monster_message(mons, &quot; zaps a wand.&quot;))</a>
<a name="ln1059">    {</a>
<a name="ln1060">        if (!silenced(you.pos()))</a>
<a name="ln1061">            mprf(MSGCH_SOUND, &quot;You hear a zap.&quot;);</a>
<a name="ln1062">    }</a>
<a name="ln1063"> </a>
<a name="ln1064">    // charge expenditure {dlb}</a>
<a name="ln1065">    wand.charges--;</a>
<a name="ln1066">    const spell_type mzap =</a>
<a name="ln1067">        spell_in_wand(static_cast&lt;wand_type&gt;(wand.sub_type));</a>
<a name="ln1068"> </a>
<a name="ln1069">    mons_cast(&amp;mons, beem, mzap, MON_SPELL_EVOKE, false);</a>
<a name="ln1070"> </a>
<a name="ln1071">    if (was_visible)</a>
<a name="ln1072">    {</a>
<a name="ln1073">        if (wand.charges &lt;= 0)</a>
<a name="ln1074">            mprf(&quot;The now-empty wand crumbles to dust.&quot;);</a>
<a name="ln1075">        else</a>
<a name="ln1076">            mons.flags |= MF_SEEN_RANGED;</a>
<a name="ln1077">    }</a>
<a name="ln1078"> </a>
<a name="ln1079">    if (wand.charges &lt;= 0)</a>
<a name="ln1080">        dec_mitm_item_quantity(wand.index(), 1);</a>
<a name="ln1081"> </a>
<a name="ln1082">    mons.lose_energy(EUT_ITEM);</a>
<a name="ln1083">}</a>
<a name="ln1084"> </a>
<a name="ln1085">static bool _handle_wand(monster&amp; mons)</a>
<a name="ln1086">{</a>
<a name="ln1087">    item_def *wand = mons.mslot_item(MSLOT_WAND);</a>
<a name="ln1088">    // Yes, there is a logic to this ordering {dlb}:</a>
<a name="ln1089">    // FIXME: monsters should be able to use wands</a>
<a name="ln1090">    //        out of sight of the player [rob]</a>
<a name="ln1091">    if (!you.see_cell(mons.pos())</a>
<a name="ln1092">        || mons.asleep()</a>
<a name="ln1093">        || mons_is_fleeing(mons)</a>
<a name="ln1094">        || mons.pacified()</a>
<a name="ln1095">        || mons.confused()</a>
<a name="ln1096">        || mons_itemuse(mons) &lt; MONUSE_STARTING_EQUIPMENT</a>
<a name="ln1097">        || mons.has_ench(ENCH_SUBMERGED)</a>
<a name="ln1098">        || x_chance_in_y(3, 4)</a>
<a name="ln1099">        || !wand</a>
<a name="ln1100">        || wand-&gt;base_type != OBJ_WANDS)</a>
<a name="ln1101">    {</a>
<a name="ln1102">        return false;</a>
<a name="ln1103">    }</a>
<a name="ln1104"> </a>
<a name="ln1105">    if (wand-&gt;charges &lt;= 0)</a>
<a name="ln1106">        return false;</a>
<a name="ln1107"> </a>
<a name="ln1108">    if (item_type_removed(wand-&gt;base_type, wand-&gt;sub_type))</a>
<a name="ln1109">        return false;</a>
<a name="ln1110"> </a>
<a name="ln1111">    // XXX: Teach monsters to use random effects</a>
<a name="ln1112">    // Digging is handled elsewhere so that sensible (wall) targets are</a>
<a name="ln1113">    // chosen.</a>
<a name="ln1114">    if (wand-&gt;sub_type == WAND_RANDOM_EFFECTS</a>
<a name="ln1115">        || wand-&gt;sub_type == WAND_DIGGING)</a>
<a name="ln1116">    {</a>
<a name="ln1117">        return false;</a>
<a name="ln1118">    }</a>
<a name="ln1119"> </a>
<a name="ln1120">    bolt beem;</a>
<a name="ln1121"> </a>
<a name="ln1122">    const spell_type mzap =</a>
<a name="ln1123">        spell_in_wand(static_cast&lt;wand_type&gt;(wand-&gt;sub_type));</a>
<a name="ln1124">    const int power = 30 + mons.get_hit_dice();</a>
<a name="ln1125"> </a>
<a name="ln1126">    if (!setup_mons_cast(&amp;mons, beem, mzap, true))</a>
<a name="ln1127">        return false;</a>
<a name="ln1128"> </a>
<a name="ln1129">    beem.source     = mons.pos();</a>
<a name="ln1130">    beem.aux_source =</a>
<a name="ln1131">        wand-&gt;name(DESC_QUALNAME, false, true, false, false);</a>
<a name="ln1132"> </a>
<a name="ln1133">    bool should_fire = false;</a>
<a name="ln1134">    const wand_type kind = (wand_type)wand-&gt;sub_type;</a>
<a name="ln1135">    switch (kind)</a>
<a name="ln1136">    {</a>
<a name="ln1137">    case WAND_SCATTERSHOT:</a>
<a name="ln1138">        should_fire = scattershot_tracer(&amp;mons, power, beem.target);</a>
<a name="ln1139">        break;</a>
<a name="ln1140"> </a>
<a name="ln1141">    case WAND_CLOUDS:</a>
<a name="ln1142">        should_fire = mons_should_cloud_cone(&amp;mons, power, beem.target);</a>
<a name="ln1143">        break;</a>
<a name="ln1144"> </a>
<a name="ln1145">    case WAND_DISINTEGRATION:</a>
<a name="ln1146">        // Dial down damage from wands of disintegration, since</a>
<a name="ln1147">        // disintegration beams can do large amounts of damage.</a>
<a name="ln1148">        beem.damage.size = beem.damage.size * 2 / 3;</a>
<a name="ln1149"> </a>
<a name="ln1150">        // Intentional fallthrough</a>
<a name="ln1151">    default:</a>
<a name="ln1152">        fire_tracer(&amp;mons, beem);</a>
<a name="ln1153">        should_fire = mons_should_fire(beem);</a>
<a name="ln1154">        break;</a>
<a name="ln1155">    }</a>
<a name="ln1156"> </a>
<a name="ln1157">    if (should_fire)</a>
<a name="ln1158">    {</a>
<a name="ln1159">        _mons_fire_wand(mons, *wand, beem, you.see_cell(mons.pos()));</a>
<a name="ln1160">        return true;</a>
<a name="ln1161">    }</a>
<a name="ln1162"> </a>
<a name="ln1163">    return false;</a>
<a name="ln1164">}</a>
<a name="ln1165"> </a>
<a name="ln1166">bool handle_throw(monster* mons, bolt &amp; beem, bool teleport, bool check_only)</a>
<a name="ln1167">{</a>
<a name="ln1168">    // Yes, there is a logic to this ordering {dlb}:</a>
<a name="ln1169">    if (mons-&gt;incapacitated()</a>
<a name="ln1170">        || mons-&gt;submerged()</a>
<a name="ln1171">        || mons-&gt;caught()</a>
<a name="ln1172">        || mons_is_confused(*mons))</a>
<a name="ln1173">    {</a>
<a name="ln1174">        return false;</a>
<a name="ln1175">    }</a>
<a name="ln1176"> </a>
<a name="ln1177">    if (mons_itemuse(*mons) &lt; MONUSE_STARTING_EQUIPMENT</a>
<a name="ln1178">        &amp;&amp; mons-&gt;type != MONS_SPECTRAL_THING)</a>
<a name="ln1179">    {</a>
<a name="ln1180">        return false;</a>
<a name="ln1181">    }</a>
<a name="ln1182"> </a>
<a name="ln1183">    const bool prefer_ranged_attack = mons_class_flag(mons-&gt;type,</a>
<a name="ln1184">                                                            M_PREFER_RANGED);</a>
<a name="ln1185">    const bool master_archer = prefer_ranged_attack &amp;&amp; mons-&gt;is_archer();</a>
<a name="ln1186">    // archers in general get a to-hit bonus and a damage bonus to ranged</a>
<a name="ln1187">    // attacks (determined elsewhere).</a>
<a name="ln1188">    // master archers will fire when adjacent, and are more likely to fire</a>
<a name="ln1189">    // over other actions.</a>
<a name="ln1190"> </a>
<a name="ln1191">    const bool liquefied = mons-&gt;liquefied_ground();</a>
<a name="ln1192"> </a>
<a name="ln1193">    // Don't allow offscreen throwing for now.</a>
<a name="ln1194">    if (mons-&gt;foe == MHITYOU &amp;&amp; !you.see_cell(mons-&gt;pos()))</a>
<a name="ln1195">        return false;</a>
<a name="ln1196"> </a>
<a name="ln1197">    // Most monsters won't shoot in melee range, largely for balance reasons.</a>
<a name="ln1198">    // Specialist archers are an exception to this rule, though most archers</a>
<a name="ln1199">    // lack the M_PREFER_RANGED flag.</a>
<a name="ln1200">    if (adjacent(beem.target, mons-&gt;pos()))</a>
<a name="ln1201">    {</a>
<a name="ln1202">        if (!prefer_ranged_attack)</a>
<a name="ln1203">            return false;</a>
<a name="ln1204">        // Monsters who only can attack with ranged still should. Keep in mind</a>
<a name="ln1205">        // that M_PREFER_RANGED only applies if the monster has ammo.</a>
<a name="ln1206">    }</a>
<a name="ln1207">    else if (!teleport &amp;&amp;</a>
<a name="ln1208">                    (liquefied &amp;&amp; !master_archer &amp;&amp; one_chance_in(9)</a>
<a name="ln1209">                     || !liquefied &amp;&amp; one_chance_in(master_archer ? 9 : 5)))</a>
<a name="ln1210">    {</a>
<a name="ln1211">        // Do we fire, or do something else?</a>
<a name="ln1212">        // Monsters that are about to teleport will always try to fire.</a>
<a name="ln1213">        // If we're standing on liquified ground, try to stand and fire.</a>
<a name="ln1214">        //    regular monsters: 8/9 chance to fire. Master archers: always.</a>
<a name="ln1215">        // Otherwise, a lower chance of firing vs doing something else.</a>
<a name="ln1216">        //    regular monsters: 4/5 chance to fire. Master archers: 8/9 chance.</a>
<a name="ln1217">        // TODO: this seems overly complicated, is 4/5 vs 8/9 even noticeable?</a>
<a name="ln1218">        return false;</a>
<a name="ln1219">    }</a>
<a name="ln1220"> </a>
<a name="ln1221">    // Don't let fleeing (or pacified creatures) stop to shoot at things</a>
<a name="ln1222">    if (mons_is_fleeing(*mons) || mons-&gt;pacified())</a>
<a name="ln1223">        return false;</a>
<a name="ln1224"> </a>
<a name="ln1225">    item_def *launcher = nullptr;</a>
<a name="ln1226">    const item_def *weapon = nullptr;</a>
<a name="ln1227">    const int mon_item = mons_usable_missile(mons, &amp;launcher);</a>
<a name="ln1228"> </a>
<a name="ln1229">    if (mon_item == NON_ITEM || !mitm[mon_item].defined())</a>
<a name="ln1230">        return false;</a>
<a name="ln1231"> </a>
<a name="ln1232">    if (player_or_mon_in_sanct(*mons))</a>
<a name="ln1233">        return false;</a>
<a name="ln1234"> </a>
<a name="ln1235">    item_def *missile = &amp;mitm[mon_item];</a>
<a name="ln1236"> </a>
<a name="ln1237">    const actor *act = actor_at(beem.target);</a>
<a name="ln1238">    ASSERT(missile-&gt;base_type == OBJ_MISSILES);</a>
<a name="ln1239">    if (act &amp;&amp; missile-&gt;sub_type == MI_THROWING_NET)</a>
<a name="ln1240">    {</a>
<a name="ln1241">        // Throwing a net at a target that is already caught would be</a>
<a name="ln1242">        // completely useless, so bail out.</a>
<a name="ln1243">        if (act-&gt;caught())</a>
<a name="ln1244">            return false;</a>
<a name="ln1245">        // Netting targets that are already permanently stuck in place</a>
<a name="ln1246">        // is similarly useless.</a>
<a name="ln1247">        if (mons_class_is_stationary(act-&gt;type))</a>
<a name="ln1248">            return false;</a>
<a name="ln1249">    }</a>
<a name="ln1250"> </a>
<a name="ln1251">    // If the attack needs a launcher that we can't wield, bail out.</a>
<a name="ln1252">    if (launcher)</a>
<a name="ln1253">    {</a>
<a name="ln1254">        weapon = mons-&gt;mslot_item(MSLOT_WEAPON);</a>
<a name="ln1255">        if (weapon &amp;&amp; weapon != launcher &amp;&amp; weapon-&gt;cursed())</a>
<a name="ln1256">            return false;</a>
<a name="ln1257">    }</a>
<a name="ln1258"> </a>
<a name="ln1259">    // Ok, we'll try it.</a>
<a name="ln1260">    setup_monster_throw_beam(mons, beem);</a>
<a name="ln1261"> </a>
<a name="ln1262">    // Set fake damage for the tracer.</a>
<a name="ln1263">    beem.damage = dice_def(10, 10);</a>
<a name="ln1264"> </a>
<a name="ln1265">    // Set item for tracer, even though it probably won't be used</a>
<a name="ln1266">    beem.item = missile;</a>
<a name="ln1267"> </a>
<a name="ln1268">    ru_interference interference = DO_NOTHING;</a>
<a name="ln1269">    // See if Ru worshippers block or redirect the attack.</a>
<a name="ln1270">    if (does_ru_wanna_redirect(mons))</a>
<a name="ln1271">    {</a>
<a name="ln1272">        interference = get_ru_attack_interference_level();</a>
<a name="ln1273">        if (interference == DO_BLOCK_ATTACK)</a>
<a name="ln1274">        {</a>
<a name="ln1275">            simple_monster_message(*mons,</a>
<a name="ln1276">                                &quot; is stunned by your will and fails to attack.&quot;,</a>
<a name="ln1277">                                MSGCH_GOD);</a>
<a name="ln1278">            return false;</a>
<a name="ln1279">        }</a>
<a name="ln1280">        else if (interference == DO_REDIRECT_ATTACK)</a>
<a name="ln1281">        {</a>
<a name="ln1282">            mprf(MSGCH_GOD, &quot;You redirect %s's attack!&quot;,</a>
<a name="ln1283">                    mons-&gt;name(DESC_THE).c_str());</a>
<a name="ln1284">            int pfound = 0;</a>
<a name="ln1285">            for (radius_iterator ri(you.pos(),</a>
<a name="ln1286">                LOS_DEFAULT); ri; ++ri)</a>
<a name="ln1287">            {</a>
<a name="ln1288">                monster* new_target = monster_at(*ri);</a>
<a name="ln1289"> </a>
<a name="ln1290">                if (new_target == nullptr</a>
<a name="ln1291">                    || mons_is_projectile(new_target-&gt;type)</a>
<a name="ln1292">                    || mons_is_firewood(*new_target)</a>
<a name="ln1293">                    || new_target-&gt;friendly())</a>
<a name="ln1294">                {</a>
<a name="ln1295">                    continue;</a>
<a name="ln1296">                }</a>
<a name="ln1297"> </a>
<a name="ln1298">                ASSERT(new_target);</a>
<a name="ln1299"> </a>
<a name="ln1300">                if (one_chance_in(++pfound))</a>
<a name="ln1301">                {</a>
<a name="ln1302">                    mons-&gt;target = new_target-&gt;pos();</a>
<a name="ln1303">                    mons-&gt;foe = new_target-&gt;mindex();</a>
<a name="ln1304">                    beem.target = mons-&gt;target;</a>
<a name="ln1305">                }</a>
<a name="ln1306">            }</a>
<a name="ln1307">        }</a>
<a name="ln1308">    }</a>
<a name="ln1309"> </a>
<a name="ln1310">    // Fire tracer.</a>
<a name="ln1311">    if (!teleport)</a>
<a name="ln1312">        fire_tracer(mons, beem);</a>
<a name="ln1313"> </a>
<a name="ln1314">    // Clear fake damage (will be set correctly in mons_throw).</a>
<a name="ln1315">    beem.damage = dice_def();</a>
<a name="ln1316"> </a>
<a name="ln1317">    // Good idea?</a>
<a name="ln1318">    if (teleport || mons_should_fire(beem) || interference != DO_NOTHING)</a>
<a name="ln1319">    {</a>
<a name="ln1320">        if (check_only)</a>
<a name="ln1321">            return true;</a>
<a name="ln1322"> </a>
<a name="ln1323">        // Monsters shouldn't shoot if fleeing, so let them &quot;turn to attack&quot;.</a>
<a name="ln1324">        make_mons_stop_fleeing(mons);</a>
<a name="ln1325"> </a>
<a name="ln1326">        if (launcher &amp;&amp; launcher != weapon)</a>
<a name="ln1327">            mons-&gt;swap_weapons();</a>
<a name="ln1328"> </a>
<a name="ln1329">        beem.name.clear();</a>
<a name="ln1330">        return mons_throw(mons, beem, mon_item, teleport);</a>
<a name="ln1331">    }</a>
<a name="ln1332"> </a>
<a name="ln1333">    return false;</a>
<a name="ln1334">}</a>
<a name="ln1335"> </a>
<a name="ln1336">// Give the monster its action energy (aka speed_increment).</a>
<a name="ln1337">static void _monster_add_energy(monster&amp; mons)</a>
<a name="ln1338">{</a>
<a name="ln1339">    if (mons.speed &gt; 0)</a>
<a name="ln1340">    {</a>
<a name="ln1341">        // Randomise to make counting off monster moves harder:</a>
<a name="ln1342">        const int energy_gained =</a>
<a name="ln1343">            max(1, div_rand_round(mons.speed * you.time_taken, 10));</a>
<a name="ln1344">        mons.speed_increment += energy_gained;</a>
<a name="ln1345">    }</a>
<a name="ln1346">}</a>
<a name="ln1347"> </a>
<a name="ln1348">#ifdef DEBUG</a>
<a name="ln1349">#    define DEBUG_ENERGY_USE(problem) \</a>
<a name="ln1350">    if (mons-&gt;speed_increment == old_energy &amp;&amp; mons-&gt;alive()) \</a>
<a name="ln1351">             mprf(MSGCH_DIAGNOSTICS, \</a>
<a name="ln1352">                  problem &quot; for monster '%s' consumed no energy&quot;, \</a>
<a name="ln1353">                  mons-&gt;name(DESC_PLAIN).c_str());</a>
<a name="ln1354">#else</a>
<a name="ln1355">#    define DEBUG_ENERGY_USE(problem) ((void) 0)</a>
<a name="ln1356">#endif</a>
<a name="ln1357"> </a>
<a name="ln1358">static void _confused_move_dir(monster *mons)</a>
<a name="ln1359">{</a>
<a name="ln1360">    mmov.reset();</a>
<a name="ln1361">    int pfound = 0;</a>
<a name="ln1362">    for (adjacent_iterator ai(mons-&gt;pos(), false); ai; ++ai)</a>
<a name="ln1363">        if (mons-&gt;can_pass_through(*ai) &amp;&amp; one_chance_in(++pfound))</a>
<a name="ln1364">            mmov = *ai - mons-&gt;pos();</a>
<a name="ln1365">}</a>
<a name="ln1366"> </a>
<a name="ln1367">static int _tentacle_move_speed(monster_type type)</a>
<a name="ln1368">{</a>
<a name="ln1369">    if (type == MONS_KRAKEN)</a>
<a name="ln1370">        return 10;</a>
<a name="ln1371">    else if (type == MONS_TENTACLED_STARSPAWN)</a>
<a name="ln1372">        return 18;</a>
<a name="ln1373">    else</a>
<a name="ln1374">        return 0;</a>
<a name="ln1375">}</a>
<a name="ln1376"> </a>
<a name="ln1377">static void _pre_monster_move(monster&amp; mons)</a>
<a name="ln1378">{</a>
<a name="ln1379">    mons.hit_points = min(mons.max_hit_points, mons.hit_points);</a>
<a name="ln1380"> </a>
<a name="ln1381">    if (mons.type == MONS_SPATIAL_MAELSTROM</a>
<a name="ln1382">        &amp;&amp; !player_in_branch(BRANCH_ABYSS)</a>
<a name="ln1383">        &amp;&amp; !player_in_branch(BRANCH_ZIGGURAT))</a>
<a name="ln1384">    {</a>
<a name="ln1385">        for (int i = 0; i &lt; you.time_taken; ++i)</a>
<a name="ln1386">        {</a>
<a name="ln1387">            if (one_chance_in(100))</a>
<a name="ln1388">            {</a>
<a name="ln1389">                mons.banish(&amp;mons);</a>
<a name="ln1390">                return;</a>
<a name="ln1391">            }</a>
<a name="ln1392">        }</a>
<a name="ln1393">    }</a>
<a name="ln1394"> </a>
<a name="ln1395">    if (mons.has_ench(ENCH_HEXED))</a>
<a name="ln1396">    {</a>
<a name="ln1397">        const actor* const agent =</a>
<a name="ln1398">            actor_by_mid(mons.get_ench(ENCH_HEXED).source);</a>
<a name="ln1399">        if (!agent || !agent-&gt;alive())</a>
<a name="ln1400">            mons.del_ench(ENCH_HEXED);</a>
<a name="ln1401">    }</a>
<a name="ln1402"> </a>
<a name="ln1403">    if (mons.type == MONS_SNAPLASHER_VINE</a>
<a name="ln1404">        &amp;&amp; mons.props.exists(&quot;vine_awakener&quot;))</a>
<a name="ln1405">    {</a>
<a name="ln1406">        monster* awakener = monster_by_mid(mons.props[&quot;vine_awakener&quot;].get_int());</a>
<a name="ln1407">        if (awakener &amp;&amp; !awakener-&gt;can_see(mons))</a>
<a name="ln1408">        {</a>
<a name="ln1409">            simple_monster_message(mons, &quot; falls limply to the ground.&quot;);</a>
<a name="ln1410">            monster_die(mons, KILL_RESET, NON_MONSTER);</a>
<a name="ln1411">            return;</a>
<a name="ln1412">        }</a>
<a name="ln1413">    }</a>
<a name="ln1414"> </a>
<a name="ln1415">    // Dissipate player ball lightnings and foxfires</a>
<a name="ln1416">    // that have left the player's sight</a>
<a name="ln1417">    // (monsters are allowed to 'cheat', as with orb of destruction)</a>
<a name="ln1418">    if ((mons.type == MONS_BALL_LIGHTNING || mons.type == MONS_FOXFIRE)</a>
<a name="ln1419">        &amp;&amp; mons.summoner == MID_PLAYER</a>
<a name="ln1420">        &amp;&amp; !cell_see_cell(you.pos(), mons.pos(), LOS_SOLID))</a>
<a name="ln1421">    {</a>
<a name="ln1422">        if (mons.type == MONS_FOXFIRE)</a>
<a name="ln1423">            check_place_cloud(CLOUD_FLAME, mons.pos(), 2, &amp;mons);</a>
<a name="ln1424">        monster_die(mons, KILL_RESET, NON_MONSTER);</a>
<a name="ln1425">        return;</a>
<a name="ln1426">    }</a>
<a name="ln1427"> </a>
<a name="ln1428">    if (mons_stores_tracking_data(mons))</a>
<a name="ln1429">    {</a>
<a name="ln1430">        actor* foe = mons.get_foe();</a>
<a name="ln1431">        if (foe)</a>
<a name="ln1432">        {</a>
<a name="ln1433">            if (!mons.props.exists(&quot;foe_pos&quot;))</a>
<a name="ln1434">                mons.props[&quot;foe_pos&quot;].get_coord() = foe-&gt;pos();</a>
<a name="ln1435">            else</a>
<a name="ln1436">            {</a>
<a name="ln1437">                if (mons.props[&quot;foe_pos&quot;].get_coord().distance_from(mons.pos())</a>
<a name="ln1438">                    &gt; foe-&gt;pos().distance_from(mons.pos()))</a>
<a name="ln1439">                {</a>
<a name="ln1440">                    mons.props[&quot;foe_approaching&quot;].get_bool() = true;</a>
<a name="ln1441">                }</a>
<a name="ln1442">                else</a>
<a name="ln1443">                    mons.props[&quot;foe_approaching&quot;].get_bool() = false;</a>
<a name="ln1444"> </a>
<a name="ln1445">                mons.props[&quot;foe_pos&quot;].get_coord() = foe-&gt;pos();</a>
<a name="ln1446">            }</a>
<a name="ln1447">        }</a>
<a name="ln1448">        else</a>
<a name="ln1449">            mons.props.erase(&quot;foe_pos&quot;);</a>
<a name="ln1450">    }</a>
<a name="ln1451"> </a>
<a name="ln1452">    reset_battlesphere(&amp;mons);</a>
<a name="ln1453">    reset_spectral_weapon(&amp;mons);</a>
<a name="ln1454"> </a>
<a name="ln1455">    fedhas_neutralise(&amp;mons);</a>
<a name="ln1456">    slime_convert(&amp;mons);</a>
<a name="ln1457"> </a>
<a name="ln1458">    // Monster just summoned (or just took stairs), skip this action.</a>
<a name="ln1459">    if (testbits(mons.flags, MF_JUST_SUMMONED))</a>
<a name="ln1460">    {</a>
<a name="ln1461">        mons.flags &amp;= ~MF_JUST_SUMMONED;</a>
<a name="ln1462">        return;</a>
<a name="ln1463">    }</a>
<a name="ln1464"> </a>
<a name="ln1465">    mon_acting mact(&amp;mons);</a>
<a name="ln1466"> </a>
<a name="ln1467">    _monster_add_energy(mons);</a>
<a name="ln1468"> </a>
<a name="ln1469">    // Handle clouds on nonmoving monsters.</a>
<a name="ln1470">    if (mons.speed == 0)</a>
<a name="ln1471">    {</a>
<a name="ln1472">        _mons_in_cloud(mons);</a>
<a name="ln1473"> </a>
<a name="ln1474">        // Update constriction durations</a>
<a name="ln1475">        mons.accum_has_constricted();</a>
<a name="ln1476"> </a>
<a name="ln1477">        if (mons.type == MONS_NO_MONSTER)</a>
<a name="ln1478">            return;</a>
<a name="ln1479">    }</a>
<a name="ln1480"> </a>
<a name="ln1481">    // Apply monster enchantments once for every normal-speed</a>
<a name="ln1482">    // player turn.</a>
<a name="ln1483">    mons.ench_countdown -= you.time_taken;</a>
<a name="ln1484">    while (mons.ench_countdown &lt; 0)</a>
<a name="ln1485">    {</a>
<a name="ln1486">        mons.ench_countdown += 10;</a>
<a name="ln1487">        mons.apply_enchantments();</a>
<a name="ln1488"> </a>
<a name="ln1489">        // If the monster *merely* died just break from the loop</a>
<a name="ln1490">        // rather than quit altogether, since we have to deal with</a>
<a name="ln1491">        // ballistomycete spores and ball lightning exploding at the end of the</a>
<a name="ln1492">        // function, but do return if the monster's data has been</a>
<a name="ln1493">        // reset, since then the monster type is invalid.</a>
<a name="ln1494">        if (mons.type == MONS_NO_MONSTER)</a>
<a name="ln1495">            return;</a>
<a name="ln1496">        else if (mons.hit_points &lt; 1)</a>
<a name="ln1497">            break;</a>
<a name="ln1498">    }</a>
<a name="ln1499"> </a>
<a name="ln1500">    // Memory is decremented here for a reason -- we only want it</a>
<a name="ln1501">    // decrementing once per monster &quot;move&quot;.</a>
<a name="ln1502">    if (mons.foe_memory &gt; 0 &amp;&amp; !you.penance[GOD_ASHENZARI])</a>
<a name="ln1503">        mons.foe_memory -= you.time_taken;</a>
<a name="ln1504"> </a>
<a name="ln1505">    // Otherwise there are potential problems with summonings.</a>
<a name="ln1506">    if (mons.type == MONS_GLOWING_SHAPESHIFTER)</a>
<a name="ln1507">        mons.add_ench(ENCH_GLOWING_SHAPESHIFTER);</a>
<a name="ln1508"> </a>
<a name="ln1509">    if (mons.type == MONS_SHAPESHIFTER)</a>
<a name="ln1510">        mons.add_ench(ENCH_SHAPESHIFTER);</a>
<a name="ln1511"> </a>
<a name="ln1512">    // We reset batty monsters from wander to seek here, instead</a>
<a name="ln1513">    // of in handle_behaviour() since that will be called with</a>
<a name="ln1514">    // every single movement, and we want these monsters to</a>
<a name="ln1515">    // hit and run. -- bwr</a>
<a name="ln1516">    if (mons.foe != MHITNOT &amp;&amp; mons_is_wandering(mons)</a>
<a name="ln1517">        &amp;&amp; mons_is_batty(mons))</a>
<a name="ln1518">    {</a>
<a name="ln1519">        mons.behaviour = BEH_SEEK;</a>
<a name="ln1520">    }</a>
<a name="ln1521"> </a>
<a name="ln1522">    mons.check_speed();</a>
<a name="ln1523"> </a>
<a name="ln1524">    // spellforged servitors lose an extra random2(16) energy per turn, often</a>
<a name="ln1525">    // causing them to skip a turn. Show this message to give the player some</a>
<a name="ln1526">    // feedback on what is going on when a servitor skips an attack due to</a>
<a name="ln1527">    // random energy loss (otherwise, it just sits there silently).</a>
<a name="ln1528">    // TODO: could this effect be implemented in some way other than energy?</a>
<a name="ln1529">    if (mons.type == MONS_SPELLFORGED_SERVITOR &amp;&amp; mons.foe != MHITNOT</a>
<a name="ln1530">        &amp;&amp; !mons.has_action_energy())</a>
<a name="ln1531">    {</a>
<a name="ln1532">        simple_monster_message(mons, &quot; hums quietly as it recharges.&quot;);</a>
<a name="ln1533">    }</a>
<a name="ln1534">}</a>
<a name="ln1535"> </a>
<a name="ln1536">void handle_monster_move(monster* mons)</a>
<a name="ln1537">{</a>
<a name="ln1538">    ASSERT(mons); // XXX: change to monster &amp;mons</a>
<a name="ln1539">    const monsterentry* entry = get_monster_data(mons-&gt;type);</a>
<a name="ln1540">    if (!entry)</a>
<a name="ln1541">        return;</a>
<a name="ln1542"> </a>
<a name="ln1543">    const bool disabled = crawl_state.disables[DIS_MON_ACT]</a>
<a name="ln1544">                          &amp;&amp; _unfriendly_or_impaired(*mons);</a>
<a name="ln1545"> </a>
<a name="ln1546">    int old_energy      = mons-&gt;speed_increment;</a>
<a name="ln1547">    int non_move_energy = min(entry-&gt;energy_usage.move,</a>
<a name="ln1548">                              entry-&gt;energy_usage.swim);</a>
<a name="ln1549"> </a>
<a name="ln1550">#ifdef DEBUG_MONS_SCAN</a>
<a name="ln1551">    bool monster_was_floating = mgrd(mons-&gt;pos()) != mons-&gt;mindex();</a>
<a name="ln1552">#endif</a>
<a name="ln1553">    coord_def old_pos = mons-&gt;pos();</a>
<a name="ln1554"> </a>
<a name="ln1555">    if (!mons-&gt;has_action_energy())</a>
<a name="ln1556">        return;</a>
<a name="ln1557"> </a>
<a name="ln1558">    if (!disabled)</a>
<a name="ln1559">        move_solo_tentacle(mons);</a>
<a name="ln1560"> </a>
<a name="ln1561">    if (!mons-&gt;alive())</a>
<a name="ln1562">        return;</a>
<a name="ln1563"> </a>
<a name="ln1564">    if (!disabled &amp;&amp; mons_is_tentacle_head(mons_base_type(*mons)))</a>
<a name="ln1565">        move_child_tentacles(mons);</a>
<a name="ln1566"> </a>
<a name="ln1567">    old_pos = mons-&gt;pos();</a>
<a name="ln1568"> </a>
<a name="ln1569">#ifdef DEBUG_MONS_SCAN</a>
<a name="ln1570">    if (!monster_was_floating</a>
<a name="ln1571">        &amp;&amp; mgrd(mons-&gt;pos()) != mons-&gt;mindex())</a>
<a name="ln1572">    {</a>
<a name="ln1573">        mprf(MSGCH_ERROR, &quot;Monster %s became detached from mgrd &quot;</a>
<a name="ln1574">                          &quot;in handle_monster_move() loop&quot;,</a>
<a name="ln1575">             mons-&gt;name(DESC_PLAIN, true).c_str());</a>
<a name="ln1576">        mprf(MSGCH_WARN, &quot;[[[[[[[[[[[[[[[[[[&quot;);</a>
<a name="ln1577">        debug_mons_scan();</a>
<a name="ln1578">        mprf(MSGCH_WARN, &quot;]]]]]]]]]]]]]]]]]]&quot;);</a>
<a name="ln1579">        monster_was_floating = true;</a>
<a name="ln1580">    }</a>
<a name="ln1581">    else if (monster_was_floating</a>
<a name="ln1582">             &amp;&amp; mgrd(mons-&gt;pos()) == mons-&gt;mindex())</a>
<a name="ln1583">    {</a>
<a name="ln1584">        mprf(MSGCH_DIAGNOSTICS, &quot;Monster %s re-attached itself to mgrd &quot;</a>
<a name="ln1585">                                &quot;in handle_monster_move() loop&quot;,</a>
<a name="ln1586">             mons-&gt;name(DESC_PLAIN, true).c_str());</a>
<a name="ln1587">        monster_was_floating = false;</a>
<a name="ln1588">    }</a>
<a name="ln1589">#endif</a>
<a name="ln1590"> </a>
<a name="ln1591">    if (mons_is_projectile(*mons))</a>
<a name="ln1592">    {</a>
<a name="ln1593">        if (iood_act(*mons))</a>
<a name="ln1594">            return;</a>
<a name="ln1595">        mons-&gt;lose_energy(EUT_MOVE);</a>
<a name="ln1596">        return;</a>
<a name="ln1597">    }</a>
<a name="ln1598"> </a>
<a name="ln1599">    if (mons-&gt;type == MONS_BATTLESPHERE)</a>
<a name="ln1600">    {</a>
<a name="ln1601">        if (fire_battlesphere(mons))</a>
<a name="ln1602">            mons-&gt;lose_energy(EUT_SPECIAL);</a>
<a name="ln1603">    }</a>
<a name="ln1604"> </a>
<a name="ln1605">    if (mons-&gt;type == MONS_FULMINANT_PRISM)</a>
<a name="ln1606">    {</a>
<a name="ln1607">        ++mons-&gt;prism_charge;</a>
<a name="ln1608">        if (mons-&gt;prism_charge == 2)</a>
<a name="ln1609">            mons-&gt;suicide();</a>
<a name="ln1610">        else</a>
<a name="ln1611">        {</a>
<a name="ln1612">            if (player_can_hear(mons-&gt;pos()))</a>
<a name="ln1613">            {</a>
<a name="ln1614">                if (you.can_see(*mons))</a>
<a name="ln1615">                {</a>
<a name="ln1616">                    simple_monster_message(*mons, &quot; crackles loudly.&quot;,</a>
<a name="ln1617">                                           MSGCH_WARN);</a>
<a name="ln1618">                }</a>
<a name="ln1619">                else</a>
<a name="ln1620">                    mprf(MSGCH_SOUND, &quot;You hear a loud crackle.&quot;);</a>
<a name="ln1621">            }</a>
<a name="ln1622">            // Done this way to keep the detonation timer predictable</a>
<a name="ln1623">            mons-&gt;speed_increment -= BASELINE_DELAY;</a>
<a name="ln1624">        }</a>
<a name="ln1625">        return;</a>
<a name="ln1626">    }</a>
<a name="ln1627"> </a>
<a name="ln1628">    if (mons-&gt;type == MONS_FOXFIRE)</a>
<a name="ln1629">    {</a>
<a name="ln1630">        if (mons-&gt;steps_remaining == 0)</a>
<a name="ln1631">        {</a>
<a name="ln1632">            check_place_cloud(CLOUD_FLAME, mons-&gt;pos(), 2, mons);</a>
<a name="ln1633">            mons-&gt;suicide();</a>
<a name="ln1634">            return;</a>
<a name="ln1635">        }</a>
<a name="ln1636">    }</a>
<a name="ln1637"> </a>
<a name="ln1638">    mons-&gt;shield_blocks = 0;</a>
<a name="ln1639"> </a>
<a name="ln1640">    _mons_in_cloud(*mons);</a>
<a name="ln1641">    actor_apply_toxic_bog(mons);</a>
<a name="ln1642"> </a>
<a name="ln1643">    if (!mons-&gt;alive())</a>
<a name="ln1644">        return;</a>
<a name="ln1645"> </a>
<a name="ln1646">    if (env.level_state &amp; LSTATE_SLIMY_WALL)</a>
<a name="ln1647">        slime_wall_damage(mons, speed_to_duration(mons-&gt;speed));</a>
<a name="ln1648"> </a>
<a name="ln1649">    if (!mons-&gt;alive())</a>
<a name="ln1650">        return;</a>
<a name="ln1651"> </a>
<a name="ln1652">    if (env.level_state &amp; LSTATE_ICY_WALL)</a>
<a name="ln1653">        ice_wall_damage(*mons, speed_to_duration(mons-&gt;speed));</a>
<a name="ln1654"> </a>
<a name="ln1655">    if (!mons-&gt;alive())</a>
<a name="ln1656">        return;</a>
<a name="ln1657"> </a>
<a name="ln1658">    if (mons-&gt;type == MONS_TIAMAT &amp;&amp; one_chance_in(3))</a>
<a name="ln1659">        draconian_change_colour(mons);</a>
<a name="ln1660"> </a>
<a name="ln1661">    _monster_regenerate(mons);</a>
<a name="ln1662"> </a>
<a name="ln1663">    // Please change _slouch_damage to match!</a>
<a name="ln1664">    if (mons-&gt;cannot_act()</a>
<a name="ln1665">        || mons-&gt;type == MONS_SIXFIRHY // these move only 8 of 24 turns</a>
<a name="ln1666">            &amp;&amp; ++mons-&gt;move_spurt / 8 % 3 != 2  // but are not helpless</a>
<a name="ln1667">        || mons-&gt;type == MONS_JIANGSHI // similarly, but more irregular (48 of 90)</a>
<a name="ln1668">            &amp;&amp; (++mons-&gt;move_spurt / 6 % 3 == 1 || mons-&gt;move_spurt / 3 % 5 == 1))</a>
<a name="ln1669">    {</a>
<a name="ln1670">        mons-&gt;speed_increment -= non_move_energy;</a>
<a name="ln1671">        return;</a>
<a name="ln1672">    }</a>
<a name="ln1673"> </a>
<a name="ln1674">    if (mons-&gt;has_ench(ENCH_DAZED) &amp;&amp; one_chance_in(4))</a>
<a name="ln1675">    {</a>
<a name="ln1676">        simple_monster_message(*mons, &quot; is lost in a daze.&quot;);</a>
<a name="ln1677">        mons-&gt;speed_increment -= non_move_energy;</a>
<a name="ln1678">        return;</a>
<a name="ln1679">    }</a>
<a name="ln1680"> </a>
<a name="ln1681">    if (mons-&gt;has_ench(ENCH_GOLD_LUST))</a>
<a name="ln1682">    {</a>
<a name="ln1683">        mons-&gt;speed_increment -= non_move_energy;</a>
<a name="ln1684">        return;</a>
<a name="ln1685">    }</a>
<a name="ln1686"> </a>
<a name="ln1687">    if (mons-&gt;has_ench(ENCH_BRILLIANCE_AURA))</a>
<a name="ln1688">        aura_of_brilliance(mons);</a>
<a name="ln1689"> </a>
<a name="ln1690">    if (you.duration[DUR_GOZAG_GOLD_AURA]</a>
<a name="ln1691">        &amp;&amp; have_passive(passive_t::gold_aura)</a>
<a name="ln1692">        &amp;&amp; you.see_cell(mons-&gt;pos())</a>
<a name="ln1693">        &amp;&amp; !mons-&gt;asleep()</a>
<a name="ln1694">        &amp;&amp; !mons_is_conjured(mons-&gt;type)</a>
<a name="ln1695">        &amp;&amp; !mons_is_tentacle_or_tentacle_segment(mons-&gt;type)</a>
<a name="ln1696">        &amp;&amp; !mons_is_firewood(*mons)</a>
<a name="ln1697">        &amp;&amp; !mons-&gt;wont_attack())</a>
<a name="ln1698">    {</a>
<a name="ln1699">        const int gold = you.props[GOZAG_GOLD_AURA_KEY].get_int();</a>
<a name="ln1700">        if (bernoulli(gold, 3.0/100.0))</a>
<a name="ln1701">        {</a>
<a name="ln1702">            if (gozag_gold_in_los(mons))</a>
<a name="ln1703">            {</a>
<a name="ln1704">                simple_monster_message(*mons,</a>
<a name="ln1705">                    &quot; becomes distracted by the nearby gold, dreaming of &quot;</a>
<a name="ln1706">                    &quot;imaginary riches.&quot;);</a>
<a name="ln1707">            }</a>
<a name="ln1708">            else if (you.gold &gt; 0)</a>
<a name="ln1709">            {</a>
<a name="ln1710">                simple_monster_message(*mons,</a>
<a name="ln1711">                    &quot; becomes distracted by your gold, dreaming of &quot;</a>
<a name="ln1712">                    &quot;imaginary riches.&quot;);</a>
<a name="ln1713">            }</a>
<a name="ln1714">            else</a>
<a name="ln1715">            {</a>
<a name="ln1716">                // Just in case!</a>
<a name="ln1717">                simple_monster_message(*mons,</a>
<a name="ln1718">                            &quot; is distracted by dreams of imaginary riches.&quot;);</a>
<a name="ln1719">            }</a>
<a name="ln1720"> </a>
<a name="ln1721">            mons-&gt;add_ench(</a>
<a name="ln1722">                mon_enchant(ENCH_GOLD_LUST, 1, nullptr,</a>
<a name="ln1723">                            random_range(1, 5) * BASELINE_DELAY));</a>
<a name="ln1724">            mons-&gt;foe = MHITNOT;</a>
<a name="ln1725">            mons-&gt;target = mons-&gt;pos();</a>
<a name="ln1726">            mons-&gt;speed_increment -= non_move_energy;</a>
<a name="ln1727">            return;</a>
<a name="ln1728">        }</a>
<a name="ln1729">    }</a>
<a name="ln1730"> </a>
<a name="ln1731">    if (disabled)</a>
<a name="ln1732">    {</a>
<a name="ln1733">        mons-&gt;speed_increment -= non_move_energy;</a>
<a name="ln1734">        return;</a>
<a name="ln1735">    }</a>
<a name="ln1736"> </a>
<a name="ln1737">    handle_behaviour(mons);</a>
<a name="ln1738"> </a>
<a name="ln1739">    // handle_behaviour() could make the monster leave the level.</a>
<a name="ln1740">    if (!mons-&gt;alive())</a>
<a name="ln1741">        return;</a>
<a name="ln1742"> </a>
<a name="ln1743">    ASSERT(!crawl_state.game_is_arena() || mons-&gt;foe != MHITYOU);</a>
<a name="ln1744">    ASSERT_IN_BOUNDS_OR_ORIGIN(mons-&gt;target);</a>
<a name="ln1745"> </a>
<a name="ln1746">    if (mons-&gt;speed &gt;= 100)</a>
<a name="ln1747">    {</a>
<a name="ln1748">        mons-&gt;speed_increment -= non_move_energy;</a>
<a name="ln1749">        return;</a>
<a name="ln1750">    }</a>
<a name="ln1751"> </a>
<a name="ln1752">    if (_handle_pickup(mons))</a>
<a name="ln1753">    {</a>
<a name="ln1754">        DEBUG_ENERGY_USE(&quot;handle_pickup()&quot;);</a>
<a name="ln1755">        return;</a>
<a name="ln1756">    }</a>
<a name="ln1757"> </a>
<a name="ln1758">    // Lurking monsters only stop lurking if their target is right</a>
<a name="ln1759">    // next to them, otherwise they just sit there.</a>
<a name="ln1760">    if (mons-&gt;has_ench(ENCH_SUBMERGED))</a>
<a name="ln1761">    {</a>
<a name="ln1762">        if (mons-&gt;foe != MHITNOT</a>
<a name="ln1763">            &amp;&amp; grid_distance(mons-&gt;target, mons-&gt;pos()) &lt;= 1)</a>
<a name="ln1764">        {</a>
<a name="ln1765">            if (mons-&gt;submerged())</a>
<a name="ln1766">            {</a>
<a name="ln1767">                if (!mons-&gt;del_ench(ENCH_SUBMERGED))</a>
<a name="ln1768">                {</a>
<a name="ln1769">                    // Couldn't unsubmerge.</a>
<a name="ln1770">                    mons-&gt;speed_increment -= non_move_energy;</a>
<a name="ln1771">                    return;</a>
<a name="ln1772">                }</a>
<a name="ln1773">            }</a>
<a name="ln1774">            mons-&gt;behaviour = BEH_SEEK;</a>
<a name="ln1775">        }</a>
<a name="ln1776">        else</a>
<a name="ln1777">        {</a>
<a name="ln1778">            mons-&gt;speed_increment -= non_move_energy;</a>
<a name="ln1779">            return;</a>
<a name="ln1780">        }</a>
<a name="ln1781">    }</a>
<a name="ln1782"> </a>
<a name="ln1783">    if (mons-&gt;caught())</a>
<a name="ln1784">    {</a>
<a name="ln1785">        // Struggling against the net takes time.</a>
<a name="ln1786">        _swim_or_move_energy(*mons);</a>
<a name="ln1787">    }</a>
<a name="ln1788">    else if (!mons-&gt;petrified())</a>
<a name="ln1789">    {</a>
<a name="ln1790">        // Calculates mmov based on monster target.</a>
<a name="ln1791">        _handle_movement(mons);</a>
<a name="ln1792"> </a>
<a name="ln1793">        // Confused monsters sometimes stumble about instead of moving with</a>
<a name="ln1794">        // purpose.</a>
<a name="ln1795">        if (mons_is_confused(*mons) &amp;&amp; !one_chance_in(3))</a>
<a name="ln1796">        {</a>
<a name="ln1797">            set_random_target(mons);</a>
<a name="ln1798">            _confused_move_dir(mons);</a>
<a name="ln1799">        }</a>
<a name="ln1800">    }</a>
<a name="ln1801">    if (!mons-&gt;asleep() &amp;&amp; !mons-&gt;submerged())</a>
<a name="ln1802">        maybe_mons_speaks(mons);</a>
<a name="ln1803"> </a>
<a name="ln1804">    if (!mons-&gt;alive())</a>
<a name="ln1805">        return;</a>
<a name="ln1806"> </a>
<a name="ln1807">    // XXX: A bit hacky, but stores where we WILL move, if we don't take</a>
<a name="ln1808">    //      another action instead (used for decision-making)</a>
<a name="ln1809">    if (mons_stores_tracking_data(*mons))</a>
<a name="ln1810">        mons-&gt;props[&quot;mmov&quot;].get_coord() = mmov;</a>
<a name="ln1811"> </a>
<a name="ln1812">    if (!mons-&gt;asleep() &amp;&amp; !mons_is_wandering(*mons)</a>
<a name="ln1813">        // Berserking monsters are limited to running up and</a>
<a name="ln1814">        // hitting their foes.</a>
<a name="ln1815">        &amp;&amp; !mons-&gt;berserk_or_insane()</a>
<a name="ln1816">        // Slime creatures can split while wandering or resting.</a>
<a name="ln1817">        || mons-&gt;type == MONS_SLIME_CREATURE)</a>
<a name="ln1818">    {</a>
<a name="ln1819">        // Prevents unfriendlies from nuking you from offscreen.</a>
<a name="ln1820">        // How nice!</a>
<a name="ln1821">        const bool friendly_or_near =</a>
<a name="ln1822">            mons-&gt;friendly() &amp;&amp; mons-&gt;foe == MHITYOU || mons-&gt;near_foe();</a>
<a name="ln1823">        if (friendly_or_near</a>
<a name="ln1824">            || mons-&gt;type == MONS_TEST_SPAWNER</a>
<a name="ln1825">            // Slime creatures can split when offscreen.</a>
<a name="ln1826">            || mons-&gt;type == MONS_SLIME_CREATURE</a>
<a name="ln1827">            // Let monsters who have Awaken Earth use it off-screen.</a>
<a name="ln1828">            || mons-&gt;has_spell(SPELL_AWAKEN_EARTH)</a>
<a name="ln1829">            )</a>
<a name="ln1830">        {</a>
<a name="ln1831">            // [ds] Special abilities shouldn't overwhelm</a>
<a name="ln1832">            // spellcasting in monsters that have both. This aims</a>
<a name="ln1833">            // to give them both roughly the same weight.</a>
<a name="ln1834">            if (coinflip() ? mon_special_ability(mons) || _do_mon_spell(mons)</a>
<a name="ln1835">                           : _do_mon_spell(mons) || mon_special_ability(mons))</a>
<a name="ln1836">            {</a>
<a name="ln1837">                DEBUG_ENERGY_USE(&quot;spell or special&quot;);</a>
<a name="ln1838">                mmov.reset();</a>
<a name="ln1839">                return;</a>
<a name="ln1840">            }</a>
<a name="ln1841">        }</a>
<a name="ln1842"> </a>
<a name="ln1843">        const bool prefer_ranged = mons_class_flag(mons-&gt;type, M_PREFER_RANGED);</a>
<a name="ln1844"> </a>
<a name="ln1845">        if (friendly_or_near)</a>
<a name="ln1846">        {</a>
<a name="ln1847">            if (_handle_potion(*mons))</a>
<a name="ln1848">            {</a>
<a name="ln1849">                DEBUG_ENERGY_USE(&quot;_handle_potion()&quot;);</a>
<a name="ln1850">                return;</a>
<a name="ln1851">            }</a>
<a name="ln1852"> </a>
<a name="ln1853">            if (_handle_scroll(*mons))</a>
<a name="ln1854">            {</a>
<a name="ln1855">                DEBUG_ENERGY_USE(&quot;_handle_scroll()&quot;);</a>
<a name="ln1856">                return;</a>
<a name="ln1857">            }</a>
<a name="ln1858"> </a>
<a name="ln1859">            if (_handle_evoke_equipment(*mons))</a>
<a name="ln1860">            {</a>
<a name="ln1861">                DEBUG_ENERGY_USE(&quot;_handle_evoke_equipment()&quot;);</a>
<a name="ln1862">                return;</a>
<a name="ln1863">            }</a>
<a name="ln1864"> </a>
<a name="ln1865">            if (_handle_wand(*mons))</a>
<a name="ln1866">            {</a>
<a name="ln1867">                DEBUG_ENERGY_USE(&quot;_handle_wand()&quot;);</a>
<a name="ln1868">                return;</a>
<a name="ln1869">            }</a>
<a name="ln1870"> </a>
<a name="ln1871">            if (_handle_swoop(*mons))</a>
<a name="ln1872">            {</a>
<a name="ln1873">                DEBUG_ENERGY_USE(&quot;_handle_swoop()&quot;);</a>
<a name="ln1874">                return;</a>
<a name="ln1875">            }</a>
<a name="ln1876"> </a>
<a name="ln1877">            // we want to let M_PREFER_RANGED monsters try their ranged attack</a>
<a name="ln1878">            // first, even if within reaching range.</a>
<a name="ln1879">            if (!prefer_ranged &amp;&amp; _handle_reaching(mons))</a>
<a name="ln1880">            {</a>
<a name="ln1881">                DEBUG_ENERGY_USE(&quot;_handle_reaching()&quot;);</a>
<a name="ln1882">                return;</a>
<a name="ln1883">            }</a>
<a name="ln1884">        }</a>
<a name="ln1885"> </a>
<a name="ln1886">        bolt beem = setup_targetting_beam(*mons);</a>
<a name="ln1887">        if (handle_throw(mons, beem, false, false))</a>
<a name="ln1888">        {</a>
<a name="ln1889">            DEBUG_ENERGY_USE(&quot;_handle_throw()&quot;);</a>
<a name="ln1890">            return;</a>
<a name="ln1891">        }</a>
<a name="ln1892"> </a>
<a name="ln1893">        if (friendly_or_near &amp;&amp; prefer_ranged &amp;&amp; _handle_reaching(mons))</a>
<a name="ln1894">        {</a>
<a name="ln1895">            DEBUG_ENERGY_USE(&quot;_handle_reaching()&quot;);</a>
<a name="ln1896">            return;</a>
<a name="ln1897">        }</a>
<a name="ln1898">    }</a>
<a name="ln1899"> </a>
<a name="ln1900">    if (!mons-&gt;caught())</a>
<a name="ln1901">    {</a>
<a name="ln1902">        if (mons-&gt;pos() + mmov == you.pos())</a>
<a name="ln1903">        {</a>
<a name="ln1904">            ASSERT(!crawl_state.game_is_arena());</a>
<a name="ln1905"> </a>
<a name="ln1906">            if (_unfriendly_or_impaired(*mons)</a>
<a name="ln1907">                &amp;&amp; !mons-&gt;has_ench(ENCH_CHARM)</a>
<a name="ln1908">                &amp;&amp; !mons-&gt;has_ench(ENCH_HEXED))</a>
<a name="ln1909">            {</a>
<a name="ln1910">                monster* new_target = 0;</a>
<a name="ln1911">                if (!mons-&gt;wont_attack())</a>
<a name="ln1912">                {</a>
<a name="ln1913">                    // Otherwise, if it steps into you, cancel other targets.</a>
<a name="ln1914">                    mons-&gt;foe = MHITYOU;</a>
<a name="ln1915">                    mons-&gt;target = you.pos();</a>
<a name="ln1916"> </a>
<a name="ln1917">                    // Check to see if your religion redirects the attack</a>
<a name="ln1918">                    if (does_ru_wanna_redirect(mons))</a>
<a name="ln1919">                    {</a>
<a name="ln1920">                        ru_interference interference =</a>
<a name="ln1921">                                get_ru_attack_interference_level();</a>
<a name="ln1922">                        if (interference == DO_BLOCK_ATTACK)</a>
<a name="ln1923">                        {</a>
<a name="ln1924">                            simple_monster_message(*mons,</a>
<a name="ln1925">                                &quot; is stunned by your will and fails to attack.&quot;,</a>
<a name="ln1926">                                MSGCH_GOD);</a>
<a name="ln1927">                            mons-&gt;speed_increment -= non_move_energy;</a>
<a name="ln1928">                            return;</a>
<a name="ln1929">                        }</a>
<a name="ln1930">                        else if (interference == DO_REDIRECT_ATTACK)</a>
<a name="ln1931">                        {</a>
<a name="ln1932">                            // get a target</a>
<a name="ln1933">                            int pfound = 0;</a>
<a name="ln1934">                            for (adjacent_iterator ai(mons-&gt;pos(), false); ai; ++ai)</a>
<a name="ln1935">                            {</a>
<a name="ln1936">                                monster* candidate = monster_at(*ai);</a>
<a name="ln1937">                                if (candidate == nullptr</a>
<a name="ln1938">                                    || mons_is_projectile(candidate-&gt;type)</a>
<a name="ln1939">                                    || mons_is_firewood(*candidate)</a>
<a name="ln1940">                                    || candidate-&gt;friendly())</a>
<a name="ln1941">                                {</a>
<a name="ln1942">                                    continue;</a>
<a name="ln1943">                                }</a>
<a name="ln1944">                                ASSERT(candidate);</a>
<a name="ln1945">                                if (one_chance_in(++pfound))</a>
<a name="ln1946">                                    new_target = candidate;</a>
<a name="ln1947">                            }</a>
<a name="ln1948">                        }</a>
<a name="ln1949">                    }</a>
<a name="ln1950">                }</a>
<a name="ln1951"> </a>
<a name="ln1952">                if (new_target)</a>
<a name="ln1953">                {</a>
<a name="ln1954">                    // attack that target</a>
<a name="ln1955">                    mons-&gt;target = new_target-&gt;pos();</a>
<a name="ln1956">                    mons-&gt;foe = new_target-&gt;mindex();</a>
<a name="ln1957">                    mprf(MSGCH_GOD, &quot;You redirect %s's attack!&quot;,</a>
<a name="ln1958">                         mons-&gt;name(DESC_THE).c_str());</a>
<a name="ln1959">                    fight_melee(mons, new_target);</a>
<a name="ln1960">                }</a>
<a name="ln1961">                else</a>
<a name="ln1962">                    fight_melee(mons, &amp;you);</a>
<a name="ln1963"> </a>
<a name="ln1964">                if (mons_is_batty(*mons))</a>
<a name="ln1965">                {</a>
<a name="ln1966">                    mons-&gt;behaviour = BEH_WANDER;</a>
<a name="ln1967">                    set_random_target(mons);</a>
<a name="ln1968">                }</a>
<a name="ln1969">                DEBUG_ENERGY_USE(&quot;fight_melee()&quot;);</a>
<a name="ln1970">                mmov.reset();</a>
<a name="ln1971">                return;</a>
<a name="ln1972">            }</a>
<a name="ln1973">        }</a>
<a name="ln1974"> </a>
<a name="ln1975">        // See if we move into (and fight) an unfriendly monster.</a>
<a name="ln1976">        monster* targ = monster_at(mons-&gt;pos() + mmov);</a>
<a name="ln1977"> </a>
<a name="ln1978">        //If a tentacle owner is attempting to move into an adjacent</a>
<a name="ln1979">        //segment, kill the segment and adjust connectivity data.</a>
<a name="ln1980">        if (targ &amp;&amp; mons_tentacle_adjacent(mons, targ))</a>
<a name="ln1981">        {</a>
<a name="ln1982">            const bool basis = targ-&gt;props.exists(&quot;outwards&quot;);</a>
<a name="ln1983">            monster* outward =  basis ? monster_by_mid(targ-&gt;props[&quot;outwards&quot;].get_int()) : nullptr;</a>
<a name="ln1984">            if (outward)</a>
<a name="ln1985">                outward-&gt;props[&quot;inwards&quot;].get_int() = mons-&gt;mid;</a>
<a name="ln1986"> </a>
<a name="ln1987">            monster_die(*targ, KILL_MISC, NON_MONSTER, true);</a>
<a name="ln1988">            targ = nullptr;</a>
<a name="ln1989">        }</a>
<a name="ln1990"> </a>
<a name="ln1991">        if (targ</a>
<a name="ln1992">            &amp;&amp; targ != mons</a>
<a name="ln1993">            &amp;&amp; mons-&gt;behaviour != BEH_WITHDRAW</a>
<a name="ln1994">            &amp;&amp; (!(mons_aligned(mons, targ) || targ-&gt;type == MONS_FOXFIRE)</a>
<a name="ln1995">                || mons-&gt;has_ench(ENCH_INSANE))</a>
<a name="ln1996">            &amp;&amp; monster_can_hit_monster(mons, targ))</a>
<a name="ln1997">        {</a>
<a name="ln1998">            // Maybe they can swap places?</a>
<a name="ln1999">            if (_swap_monsters(*mons, *targ))</a>
<a name="ln2000">            {</a>
<a name="ln2001">                _swim_or_move_energy(*mons);</a>
<a name="ln2002">                return;</a>
<a name="ln2003">            }</a>
<a name="ln2004">            // Figure out if they fight.</a>
<a name="ln2005">            else if ((!mons_is_firewood(*targ)</a>
<a name="ln2006">                      || mons-&gt;is_child_tentacle())</a>
<a name="ln2007">                          &amp;&amp; fight_melee(mons, targ))</a>
<a name="ln2008">            {</a>
<a name="ln2009">                if (mons_is_batty(*mons))</a>
<a name="ln2010">                {</a>
<a name="ln2011">                    mons-&gt;behaviour = BEH_WANDER;</a>
<a name="ln2012">                    set_random_target(mons);</a>
<a name="ln2013">                    // mons-&gt;speed_increment -= mons-&gt;speed;</a>
<a name="ln2014">                }</a>
<a name="ln2015"> </a>
<a name="ln2016">                mmov.reset();</a>
<a name="ln2017">                DEBUG_ENERGY_USE(&quot;fight_melee()&quot;);</a>
<a name="ln2018">                return;</a>
<a name="ln2019">            }</a>
<a name="ln2020">        }</a>
<a name="ln2021">        else if (mons-&gt;behaviour == BEH_WITHDRAW</a>
<a name="ln2022">                 &amp;&amp; ((targ &amp;&amp; targ != mons &amp;&amp; targ-&gt;friendly())</a>
<a name="ln2023">                      || (you.pos() == mons-&gt;pos() + mmov)))</a>
<a name="ln2024">        {</a>
<a name="ln2025">            // Don't count turns spent blocked by friendly creatures</a>
<a name="ln2026">            // (or the player) as an indication that we're stuck</a>
<a name="ln2027">            mons-&gt;props.erase(&quot;blocked_deadline&quot;);</a>
<a name="ln2028">        }</a>
<a name="ln2029"> </a>
<a name="ln2030">        if (invalid_monster(mons) || mons-&gt;is_stationary())</a>
<a name="ln2031">        {</a>
<a name="ln2032">            if (mons-&gt;speed_increment == old_energy)</a>
<a name="ln2033">                mons-&gt;speed_increment -= non_move_energy;</a>
<a name="ln2034">            return;</a>
<a name="ln2035">        }</a>
<a name="ln2036"> </a>
<a name="ln2037">        if (mons-&gt;cannot_move() || !_monster_move(mons))</a>
<a name="ln2038">            mons-&gt;speed_increment -= non_move_energy;</a>
<a name="ln2039">    }</a>
<a name="ln2040">    you.update_beholder(mons);</a>
<a name="ln2041">    you.update_fearmonger(mons);</a>
<a name="ln2042"> </a>
<a name="ln2043">    // Reevaluate behaviour, since the monster's surroundings have</a>
<a name="ln2044">    // changed (it may have moved, or died for that matter). Don't</a>
<a name="ln2045">    // bother for dead monsters.  :)</a>
<a name="ln2046">    if (mons-&gt;alive())</a>
<a name="ln2047">    {</a>
<a name="ln2048">        handle_behaviour(mons);</a>
<a name="ln2049">        ASSERT_IN_BOUNDS_OR_ORIGIN(mons-&gt;target);</a>
<a name="ln2050">    }</a>
<a name="ln2051"> </a>
<a name="ln2052">    if (mons_is_tentacle_head(mons_base_type(*mons)))</a>
<a name="ln2053">    {</a>
<a name="ln2054">        move_child_tentacles(mons);</a>
<a name="ln2055"> </a>
<a name="ln2056">        mons-&gt;move_spurt += (old_energy - mons-&gt;speed_increment)</a>
<a name="ln2057">                             * _tentacle_move_speed(mons_base_type(*mons));</a>
<a name="ln2058">        ASSERT(mons-&gt;move_spurt &gt; 0);</a>
<a name="ln2059">        while (mons-&gt;move_spurt &gt;= 100)</a>
<a name="ln2060">        {</a>
<a name="ln2061">            move_child_tentacles(mons);</a>
<a name="ln2062">            mons-&gt;move_spurt -= 100;</a>
<a name="ln2063">        }</a>
<a name="ln2064">    }</a>
<a name="ln2065">}</a>
<a name="ln2066"> </a>
<a name="ln2067">/**</a>
<a name="ln2068"> * Let trapped monsters struggle against nets, webs, etc.</a>
<a name="ln2069"> */</a>
<a name="ln2070">void monster::struggle_against_net()</a>
<a name="ln2071">{</a>
<a name="ln2072">    if (is_stationary() || cannot_act() || asleep())</a>
<a name="ln2073">        return;</a>
<a name="ln2074"> </a>
<a name="ln2075">    if (props.exists(NEWLY_TRAPPED_KEY))</a>
<a name="ln2076">    {</a>
<a name="ln2077">        props.erase(NEWLY_TRAPPED_KEY);</a>
<a name="ln2078">        return; // don't try to escape on the same turn you were trapped!</a>
<a name="ln2079">    }</a>
<a name="ln2080"> </a>
<a name="ln2081">    int net = get_trapping_net(pos(), true);</a>
<a name="ln2082"> </a>
<a name="ln2083">    if (net == NON_ITEM)</a>
<a name="ln2084">    {</a>
<a name="ln2085">        trap_def *trap = trap_at(pos());</a>
<a name="ln2086">        if (trap &amp;&amp; trap-&gt;type == TRAP_WEB)</a>
<a name="ln2087">        {</a>
<a name="ln2088">            if (coinflip())</a>
<a name="ln2089">            {</a>
<a name="ln2090">                if (you.see_cell(pos()))</a>
<a name="ln2091">                {</a>
<a name="ln2092">                    if (!visible_to(&amp;you))</a>
<a name="ln2093">                        mpr(&quot;Something you can't see is thrashing in a web.&quot;);</a>
<a name="ln2094">                    else</a>
<a name="ln2095">                        simple_monster_message(*this,</a>
<a name="ln2096">                                           &quot; struggles to get unstuck from the web.&quot;);</a>
<a name="ln2097">                }</a>
<a name="ln2098">                return;</a>
<a name="ln2099">            }</a>
<a name="ln2100">        }</a>
<a name="ln2101">        monster_web_cleanup(*this);</a>
<a name="ln2102">        del_ench(ENCH_HELD);</a>
<a name="ln2103">        return;</a>
<a name="ln2104">    }</a>
<a name="ln2105"> </a>
<a name="ln2106">    if (you.see_cell(pos()))</a>
<a name="ln2107">    {</a>
<a name="ln2108">        if (!visible_to(&amp;you))</a>
<a name="ln2109">            mpr(&quot;Something wriggles in the net.&quot;);</a>
<a name="ln2110">        else</a>
<a name="ln2111">            simple_monster_message(*this, &quot; struggles against the net.&quot;);</a>
<a name="ln2112">    }</a>
<a name="ln2113"> </a>
<a name="ln2114">    int damage = 1 + random2(2);</a>
<a name="ln2115"> </a>
<a name="ln2116">    // Faster monsters can damage the net more often per</a>
<a name="ln2117">    // time period.</a>
<a name="ln2118">    if (speed != 0)</a>
<a name="ln2119">        damage = div_rand_round(damage * speed, 10);</a>
<a name="ln2120"> </a>
<a name="ln2121">    mitm[net].net_durability -= damage;</a>
<a name="ln2122"> </a>
<a name="ln2123">    if (mitm[net].net_durability &lt; NET_MIN_DURABILITY)</a>
<a name="ln2124">    {</a>
<a name="ln2125">        if (you.see_cell(pos()))</a>
<a name="ln2126">        {</a>
<a name="ln2127">            if (visible_to(&amp;you))</a>
<a name="ln2128">            {</a>
<a name="ln2129">                mprf(&quot;The net rips apart, and %s comes free!&quot;,</a>
<a name="ln2130">                     name(DESC_THE).c_str());</a>
<a name="ln2131">            }</a>
<a name="ln2132">            else</a>
<a name="ln2133">                mpr(&quot;All of a sudden the net rips apart!&quot;);</a>
<a name="ln2134">        }</a>
<a name="ln2135">        destroy_item(net);</a>
<a name="ln2136"> </a>
<a name="ln2137">        del_ench(ENCH_HELD, true);</a>
<a name="ln2138">    }</a>
<a name="ln2139">}</a>
<a name="ln2140"> </a>
<a name="ln2141">static void _ancient_zyme_sicken(monster* mons)</a>
<a name="ln2142">{</a>
<a name="ln2143">    if (is_sanctuary(mons-&gt;pos()))</a>
<a name="ln2144">        return;</a>
<a name="ln2145"> </a>
<a name="ln2146">    if (!is_sanctuary(you.pos())</a>
<a name="ln2147">        &amp;&amp; !mons-&gt;wont_attack()</a>
<a name="ln2148">        &amp;&amp; you.res_rotting() &lt;= 0</a>
<a name="ln2149">        &amp;&amp; !you.duration[DUR_DIVINE_STAMINA]</a>
<a name="ln2150">        &amp;&amp; cell_see_cell(you.pos(), mons-&gt;pos(), LOS_SOLID_SEE))</a>
<a name="ln2151">    {</a>
<a name="ln2152">        if (!you.disease)</a>
<a name="ln2153">        {</a>
<a name="ln2154">            if (!you.duration[DUR_SICKENING])</a>
<a name="ln2155">            {</a>
<a name="ln2156">                mprf(MSGCH_WARN, &quot;You feel yourself growing ill in the &quot;</a>
<a name="ln2157">                                 &quot;presence of %s.&quot;,</a>
<a name="ln2158">                    mons-&gt;name(DESC_THE).c_str());</a>
<a name="ln2159">            }</a>
<a name="ln2160"> </a>
<a name="ln2161">            you.duration[DUR_SICKENING] += (2 + random2(4)) * BASELINE_DELAY;</a>
<a name="ln2162">            if (you.duration[DUR_SICKENING] &gt; 100)</a>
<a name="ln2163">            {</a>
<a name="ln2164">                you.sicken(40 + random2(30));</a>
<a name="ln2165">                you.duration[DUR_SICKENING] = 0;</a>
<a name="ln2166">            }</a>
<a name="ln2167">        }</a>
<a name="ln2168">        else</a>
<a name="ln2169">        {</a>
<a name="ln2170">            if (x_chance_in_y(you.time_taken, 60))</a>
<a name="ln2171">                you.sicken(15 + random2(30));</a>
<a name="ln2172">        }</a>
<a name="ln2173">    }</a>
<a name="ln2174"> </a>
<a name="ln2175">    for (radius_iterator ri(mons-&gt;pos(), LOS_RADIUS, C_SQUARE); ri; ++ri)</a>
<a name="ln2176">    {</a>
<a name="ln2177">        monster *m = monster_at(*ri);</a>
<a name="ln2178">        if (m &amp;&amp; !mons_aligned(mons, m)</a>
<a name="ln2179">            &amp;&amp; cell_see_cell(mons-&gt;pos(), *ri, LOS_SOLID_SEE)</a>
<a name="ln2180">            &amp;&amp; !is_sanctuary(*ri))</a>
<a name="ln2181">        {</a>
<a name="ln2182">            m-&gt;sicken(2 * you.time_taken);</a>
<a name="ln2183">        }</a>
<a name="ln2184">    }</a>
<a name="ln2185">}</a>
<a name="ln2186"> </a>
<a name="ln2187">/**</a>
<a name="ln2188"> * Apply the torpor snail slowing effect.</a>
<a name="ln2189"> *</a>
<a name="ln2190"> * @param mons      The snail applying the effect.</a>
<a name="ln2191"> */</a>
<a name="ln2192">static void _torpor_snail_slow(monster* mons)</a>
<a name="ln2193">{</a>
<a name="ln2194">    // XXX: might be nice to refactor together with _ancient_zyme_sicken().</a>
<a name="ln2195">    // XXX: also with torpor_slowed().... so many duplicated checks :(</a>
<a name="ln2196"> </a>
<a name="ln2197">    if (is_sanctuary(mons-&gt;pos())</a>
<a name="ln2198">        || mons-&gt;attitude != ATT_HOSTILE</a>
<a name="ln2199">        || mons-&gt;has_ench(ENCH_CHARM))</a>
<a name="ln2200">    {</a>
<a name="ln2201">        return;</a>
<a name="ln2202">    }</a>
<a name="ln2203"> </a>
<a name="ln2204">    if (!is_sanctuary(you.pos())</a>
<a name="ln2205">        &amp;&amp; !you.stasis()</a>
<a name="ln2206">        &amp;&amp; cell_see_cell(you.pos(), mons-&gt;pos(), LOS_SOLID_SEE))</a>
<a name="ln2207">    {</a>
<a name="ln2208">        if (!you.duration[DUR_SLOW])</a>
<a name="ln2209">        {</a>
<a name="ln2210">            mprf(&quot;Being near %s leaves you feeling lethargic.&quot;,</a>
<a name="ln2211">                 mons-&gt;name(DESC_THE).c_str());</a>
<a name="ln2212">        }</a>
<a name="ln2213"> </a>
<a name="ln2214">        if (you.duration[DUR_SLOW] &lt;= 1)</a>
<a name="ln2215">            you.set_duration(DUR_SLOW, 1);</a>
<a name="ln2216">        you.props[TORPOR_SLOWED_KEY] = true;</a>
<a name="ln2217">    }</a>
<a name="ln2218"> </a>
<a name="ln2219">    for (monster_near_iterator ri(mons-&gt;pos(), LOS_SOLID_SEE); ri; ++ri)</a>
<a name="ln2220">    {</a>
<a name="ln2221">        monster *m = *ri;</a>
<a name="ln2222">        if (m &amp;&amp; !mons_aligned(mons, m) &amp;&amp; !m-&gt;stasis()</a>
<a name="ln2223">            &amp;&amp; !mons_is_conjured(m-&gt;type) &amp;&amp; !m-&gt;is_stationary()</a>
<a name="ln2224">            &amp;&amp; !is_sanctuary(m-&gt;pos()))</a>
<a name="ln2225">        {</a>
<a name="ln2226">            m-&gt;add_ench(mon_enchant(ENCH_SLOW, 0, mons, 1));</a>
<a name="ln2227">            m-&gt;props[TORPOR_SLOWED_KEY] = true;</a>
<a name="ln2228">        }</a>
<a name="ln2229">    }</a>
<a name="ln2230">}</a>
<a name="ln2231"> </a>
<a name="ln2232">static void _post_monster_move(monster* mons)</a>
<a name="ln2233">{</a>
<a name="ln2234">    if (invalid_monster(mons))</a>
<a name="ln2235">        return;</a>
<a name="ln2236"> </a>
<a name="ln2237">    mons-&gt;handle_constriction();</a>
<a name="ln2238"> </a>
<a name="ln2239">    if (mons-&gt;has_ench(ENCH_HELD))</a>
<a name="ln2240">        mons-&gt;struggle_against_net();</a>
<a name="ln2241"> </a>
<a name="ln2242">    if (mons-&gt;type == MONS_ANCIENT_ZYME)</a>
<a name="ln2243">        _ancient_zyme_sicken(mons);</a>
<a name="ln2244"> </a>
<a name="ln2245">    if (mons-&gt;type == MONS_TORPOR_SNAIL)</a>
<a name="ln2246">        _torpor_snail_slow(mons);</a>
<a name="ln2247"> </a>
<a name="ln2248">    if (mons-&gt;type == MONS_ASMODEUS)</a>
<a name="ln2249">    {</a>
<a name="ln2250">        cloud_type ctype = CLOUD_FIRE;</a>
<a name="ln2251"> </a>
<a name="ln2252">        for (adjacent_iterator ai(mons-&gt;pos()); ai; ++ai)</a>
<a name="ln2253">            if (!cell_is_solid(*ai)</a>
<a name="ln2254">                &amp;&amp; (!cloud_at(*ai)</a>
<a name="ln2255">                    || cloud_at(*ai)-&gt;type == ctype))</a>
<a name="ln2256">            {</a>
<a name="ln2257">                place_cloud(ctype, *ai, 2 + random2(6), mons);</a>
<a name="ln2258">            }</a>
<a name="ln2259">    }</a>
<a name="ln2260"> </a>
<a name="ln2261">    if (mons-&gt;type == MONS_WATER_NYMPH)</a>
<a name="ln2262">    {</a>
<a name="ln2263">        for (adjacent_iterator ai(mons-&gt;pos(), false); ai; ++ai)</a>
<a name="ln2264">            if (feat_has_solid_floor(grd(*ai))</a>
<a name="ln2265">                &amp;&amp; (coinflip() || *ai == mons-&gt;pos()))</a>
<a name="ln2266">            {</a>
<a name="ln2267">                if (grd(*ai) != DNGN_SHALLOW_WATER &amp;&amp; grd(*ai) != DNGN_FLOOR</a>
<a name="ln2268">                    &amp;&amp; you.see_cell(*ai))</a>
<a name="ln2269">                {</a>
<a name="ln2270">                    mprf(&quot;%s watery aura covers %s.&quot;,</a>
<a name="ln2271">                         apostrophise(mons-&gt;name(DESC_THE)).c_str(),</a>
<a name="ln2272">                         feature_description_at(*ai, false, DESC_THE).c_str());</a>
<a name="ln2273">                }</a>
<a name="ln2274">                temp_change_terrain(*ai, DNGN_SHALLOW_WATER, random_range(50, 80),</a>
<a name="ln2275">                                    TERRAIN_CHANGE_FLOOD, mons);</a>
<a name="ln2276">            }</a>
<a name="ln2277">    }</a>
<a name="ln2278"> </a>
<a name="ln2279">    if (mons-&gt;type == MONS_GUARDIAN_GOLEM)</a>
<a name="ln2280">        guardian_golem_bond(*mons);</a>
<a name="ln2281"> </a>
<a name="ln2282">    // A rakshasa that has regained full health dismisses its emergency clones</a>
<a name="ln2283">    // (if they're somehow still alive) and regains the ability to summon new ones.</a>
<a name="ln2284">    if (mons-&gt;type == MONS_RAKSHASA &amp;&amp; mons-&gt;hit_points == mons-&gt;max_hit_points</a>
<a name="ln2285">        &amp;&amp; !mons-&gt;has_ench(ENCH_PHANTOM_MIRROR)</a>
<a name="ln2286">        &amp;&amp; mons-&gt;props.exists(&quot;emergency_clone&quot;))</a>
<a name="ln2287">    {</a>
<a name="ln2288">        mons-&gt;props.erase(&quot;emergency_clone&quot;);</a>
<a name="ln2289">        for (monster_iterator mi; mi; ++mi)</a>
<a name="ln2290">        {</a>
<a name="ln2291">            if (mi-&gt;type == MONS_RAKSHASA &amp;&amp; mi-&gt;summoner == mons-&gt;mid)</a>
<a name="ln2292">                mi-&gt;del_ench(ENCH_ABJ);</a>
<a name="ln2293">        }</a>
<a name="ln2294">    }</a>
<a name="ln2295"> </a>
<a name="ln2296">    if (mons-&gt;has_ench(ENCH_RING_OF_THUNDER))</a>
<a name="ln2297">    {</a>
<a name="ln2298">        // TODO: deduplicate with mon-ench.cc</a>
<a name="ln2299">        cloud_type ctype = CLOUD_STORM;</a>
<a name="ln2300"> </a>
<a name="ln2301">        for (adjacent_iterator ai(mons-&gt;pos()); ai; ++ai)</a>
<a name="ln2302">            if (!cell_is_solid(*ai)</a>
<a name="ln2303">                &amp;&amp; (!cloud_at(*ai)</a>
<a name="ln2304">                    || cloud_at(*ai)-&gt;type == ctype))</a>
<a name="ln2305">            {</a>
<a name="ln2306">                place_cloud(ctype, *ai, 2 + random2(3), mons);</a>
<a name="ln2307">            }</a>
<a name="ln2308">    }</a>
<a name="ln2309"> </a>
<a name="ln2310">    if (mons-&gt;type != MONS_NO_MONSTER &amp;&amp; mons-&gt;hit_points &lt; 1)</a>
<a name="ln2311">        monster_die(*mons, KILL_MISC, NON_MONSTER);</a>
<a name="ln2312">}</a>
<a name="ln2313"> </a>
<a name="ln2314">priority_queue&lt;pair&lt;monster *, int&gt;,</a>
<a name="ln2315">               vector&lt;pair&lt;monster *, int&gt; &gt;,</a>
<a name="ln2316">               MonsterActionQueueCompare&gt; monster_queue;</a>
<a name="ln2317"> </a>
<a name="ln2318">// Inserts a monster into the monster queue (needed to ensure that any monsters</a>
<a name="ln2319">// given energy or an action by a effect can actually make use of that energy</a>
<a name="ln2320">// this round)</a>
<a name="ln2321">void queue_monster_for_action(monster* mons)</a>
<a name="ln2322">{</a>
<a name="ln2323">    monster_queue.emplace(mons, mons-&gt;speed_increment);</a>
<a name="ln2324">}</a>
<a name="ln2325"> </a>
<a name="ln2326">static void _clear_monster_flags()</a>
<a name="ln2327">{</a>
<a name="ln2328">    // Clear any summoning flags so that lower indiced</a>
<a name="ln2329">    // monsters get their actions in the next round.</a>
<a name="ln2330">    // Also clear one-turn deep sleep flag.</a>
<a name="ln2331">    // XXX: MF_JUST_SLEPT only really works for player-cast hibernation.</a>
<a name="ln2332">    for (auto &amp;mons : menv_real)</a>
<a name="ln2333">        mons.flags &amp;= ~MF_JUST_SUMMONED &amp; ~MF_JUST_SLEPT;</a>
<a name="ln2334">}</a>
<a name="ln2335"> </a>
<a name="ln2336">/**</a>
<a name="ln2337">* On each monster turn, check to see if we need to update monster attitude.</a>
<a name="ln2338">* At the time of writing, it just checks for MUT_NO_LOVE from Ru Sacrifice Love.</a>
<a name="ln2339">*</a>
<a name="ln2340">* @param mon     The targeted monster</a>
<a name="ln2341">* @return        Void</a>
<a name="ln2342">**/</a>
<a name="ln2343">static void _update_monster_attitude(monster *mon)</a>
<a name="ln2344">{</a>
<a name="ln2345">    if (you.get_mutation_level(MUT_NO_LOVE)</a>
<a name="ln2346">        &amp;&amp; !mons_is_conjured(mon-&gt;type))</a>
<a name="ln2347">    {</a>
<a name="ln2348">        mon-&gt;attitude = ATT_HOSTILE;</a>
<a name="ln2349">    }</a>
<a name="ln2350">}</a>
<a name="ln2351"> </a>
<a name="ln2352">vector&lt;monster *&gt; just_seen_queue;</a>
<a name="ln2353"> </a>
<a name="ln2354">void mons_set_just_seen(monster *mon)</a>
<a name="ln2355">{</a>
<a name="ln2356">    mon-&gt;seen_context = SC_JUST_SEEN;</a>
<a name="ln2357">    just_seen_queue.push_back(mon);</a>
<a name="ln2358">}</a>
<a name="ln2359"> </a>
<a name="ln2360">void mons_reset_just_seen()</a>
<a name="ln2361">{</a>
<a name="ln2362">    // this may be called when the pointers are not valid, so don't mess with</a>
<a name="ln2363">    // seen_context.</a>
<a name="ln2364">    just_seen_queue.clear();</a>
<a name="ln2365">}</a>
<a name="ln2366"> </a>
<a name="ln2367">static void _display_just_seen()</a>
<a name="ln2368">{</a>
<a name="ln2369">    // these are monsters that were marked as SC_JUST_SEEN at some point since</a>
<a name="ln2370">    // last time this was called. We announce any that leave all at once so</a>
<a name="ln2371">    // as to handle monsters that may move multiple times per world_reacts.</a>
<a name="ln2372">    if (in_bounds(you.pos()))</a>
<a name="ln2373">    {</a>
<a name="ln2374">        for (auto m : just_seen_queue)</a>
<a name="ln2375">        {</a>
<a name="ln2376">            if (!m || invalid_monster(m) || !m-&gt;alive())</a>
<a name="ln2377">                continue;</a>
<a name="ln2378">            // can't use simple_monster_message here, because m is out of view.</a>
<a name="ln2379">            // The monster should be visible to be in this queue.</a>
<a name="ln2380">            if (in_bounds(m-&gt;pos()) &amp;&amp; !you.see_cell(m-&gt;pos()))</a>
<a name="ln2381">            {</a>
<a name="ln2382">                mprf(MSGCH_PLAIN, &quot;%s moves out of view.&quot;,</a>
<a name="ln2383">                     m-&gt;name(DESC_THE, true).c_str());</a>
<a name="ln2384">            }</a>
<a name="ln2385">        }</a>
<a name="ln2386">    }</a>
<a name="ln2387">    mons_reset_just_seen();</a>
<a name="ln2388">}</a>
<a name="ln2389"> </a>
<a name="ln2390">/**</a>
<a name="ln2391"> * Get all monsters to make an action, if they can/want to.</a>
<a name="ln2392"> *</a>
<a name="ln2393"> * @param with_noise whether to process noises after the loop.</a>
<a name="ln2394"> */</a>
<a name="ln2395">void handle_monsters(bool with_noise)</a>
<a name="ln2396">{</a>
<a name="ln2397">    for (monster_iterator mi; mi; ++mi)</a>
<a name="ln2398">    {</a>
<a name="ln2399">        _pre_monster_move(**mi);</a>
<a name="ln2400">        if (!invalid_monster(*mi) &amp;&amp; mi-&gt;alive() &amp;&amp; mi-&gt;has_action_energy())</a>
<a name="ln2401">            monster_queue.emplace(*mi, mi-&gt;speed_increment);</a>
<a name="ln2402">    }</a>
<a name="ln2403"> </a>
<a name="ln2404">    int tries = 0; // infinite loop protection, shouldn't be ever needed</a>
<a name="ln2405">    while (!monster_queue.empty())</a>
<a name="ln2406">    {</a>
<a name="ln2407">        if (tries++ &gt; 32767)</a>
<a name="ln2408">        {</a>
<a name="ln2409">            die(&quot;infinite handle_monsters() loop, mons[0 of %d] is %s&quot;,</a>
<a name="ln2410">                (int)monster_queue.size(),</a>
<a name="ln2411">                monster_queue.top().first-&gt;name(DESC_PLAIN, true).c_str());</a>
<a name="ln2412">        }</a>
<a name="ln2413"> </a>
<a name="ln2414">        monster *mon = monster_queue.top().first;</a>
<a name="ln2415">        const int oldspeed = monster_queue.top().second;</a>
<a name="ln2416">        monster_queue.pop();</a>
<a name="ln2417"> </a>
<a name="ln2418">        if (invalid_monster(mon) || !mon-&gt;alive() || !mon-&gt;has_action_energy())</a>
<a name="ln2419">            continue;</a>
<a name="ln2420"> </a>
<a name="ln2421">        _update_monster_attitude(mon);</a>
<a name="ln2422"> </a>
<a name="ln2423">        // Only move the monster if nothing else has played with its energy</a>
<a name="ln2424">        // during their turn.</a>
<a name="ln2425">        // If something's played with the energy, they get added back to</a>
<a name="ln2426">        // the queue just after this.</a>
<a name="ln2427">        if (oldspeed == mon-&gt;speed_increment)</a>
<a name="ln2428">        {</a>
<a name="ln2429">            handle_monster_move(mon);</a>
<a name="ln2430">            _post_monster_move(mon);</a>
<a name="ln2431">            fire_final_effects();</a>
<a name="ln2432">        }</a>
<a name="ln2433"> </a>
<a name="ln2434">        if (mon-&gt;has_action_energy())</a>
<a name="ln2435">            monster_queue.emplace(mon, mon-&gt;speed_increment);</a>
<a name="ln2436"> </a>
<a name="ln2437">        // If the player got banished, discard pending monster actions.</a>
<a name="ln2438">        if (you.banished)</a>
<a name="ln2439">        {</a>
<a name="ln2440">            // Clear list of mesmerising monsters.</a>
<a name="ln2441">            you.clear_beholders();</a>
<a name="ln2442">            you.clear_fearmongers();</a>
<a name="ln2443">            you.stop_constricting_all();</a>
<a name="ln2444">            you.stop_being_constricted();</a>
<a name="ln2445">            break;</a>
<a name="ln2446">        }</a>
<a name="ln2447">    }</a>
<a name="ln2448">    _display_just_seen();</a>
<a name="ln2449"> </a>
<a name="ln2450">    // Process noises now (before clearing the sleep flag).</a>
<a name="ln2451">    if (with_noise)</a>
<a name="ln2452">        apply_noises();</a>
<a name="ln2453"> </a>
<a name="ln2454">    _clear_monster_flags();</a>
<a name="ln2455">}</a>
<a name="ln2456"> </a>
<a name="ln2457">static bool _jelly_divide(monster&amp; parent)</a>
<a name="ln2458">{</a>
<a name="ln2459">    if (!mons_class_flag(parent.type, M_SPLITS))</a>
<a name="ln2460">        return false;</a>
<a name="ln2461"> </a>
<a name="ln2462">    const int reqd = max(parent.get_experience_level() * 8, 50);</a>
<a name="ln2463">    if (parent.hit_points &lt; reqd)</a>
<a name="ln2464">        return false;</a>
<a name="ln2465"> </a>
<a name="ln2466">    monster* child = nullptr;</a>
<a name="ln2467">    coord_def child_spot;</a>
<a name="ln2468">    int num_spots = 0;</a>
<a name="ln2469"> </a>
<a name="ln2470">    // First, find a suitable spot for the child {dlb}:</a>
<a name="ln2471">    for (adjacent_iterator ai(parent.pos()); ai; ++ai)</a>
<a name="ln2472">        if (actor_at(*ai) == nullptr &amp;&amp; parent.can_pass_through(*ai)</a>
<a name="ln2473">            &amp;&amp; one_chance_in(++num_spots))</a>
<a name="ln2474">        {</a>
<a name="ln2475">            child_spot = *ai;</a>
<a name="ln2476">        }</a>
<a name="ln2477"> </a>
<a name="ln2478">    if (num_spots == 0)</a>
<a name="ln2479">        return false;</a>
<a name="ln2480"> </a>
<a name="ln2481">    // Now that we have a spot, find a monster slot {dlb}:</a>
<a name="ln2482">    child = get_free_monster();</a>
<a name="ln2483">    if (!child)</a>
<a name="ln2484">        return false;</a>
<a name="ln2485"> </a>
<a name="ln2486">    // Handle impact of split on parent {dlb}:</a>
<a name="ln2487">    parent.max_hit_points /= 2;</a>
<a name="ln2488"> </a>
<a name="ln2489">    if (parent.hit_points &gt; parent.max_hit_points)</a>
<a name="ln2490">        parent.hit_points = parent.max_hit_points;</a>
<a name="ln2491"> </a>
<a name="ln2492">    parent.init_experience();</a>
<a name="ln2493">    parent.experience = parent.experience * 3 / 5 + 1;</a>
<a name="ln2494"> </a>
<a name="ln2495">    // Create child {dlb}:</a>
<a name="ln2496">    // This is terribly partial and really requires</a>
<a name="ln2497">    // more thought as to generation ... {dlb}</a>
<a name="ln2498">    *child = parent;</a>
<a name="ln2499">    child-&gt;max_hit_points  = child-&gt;hit_points;</a>
<a name="ln2500">    child-&gt;speed_increment = 70 + random2(5);</a>
<a name="ln2501">    child-&gt;set_new_monster_id();</a>
<a name="ln2502">    child-&gt;move_to_pos(child_spot);</a>
<a name="ln2503"> </a>
<a name="ln2504">    if (!simple_monster_message(parent, &quot; splits in two!&quot;)</a>
<a name="ln2505">        &amp;&amp; (player_can_hear(parent.pos()) || player_can_hear(child-&gt;pos())))</a>
<a name="ln2506">    {</a>
<a name="ln2507">        mprf(MSGCH_SOUND, &quot;You hear a squelching noise.&quot;);</a>
<a name="ln2508">    }</a>
<a name="ln2509"> </a>
<a name="ln2510">    if (crawl_state.game_is_arena())</a>
<a name="ln2511">        arena_placed_monster(child);</a>
<a name="ln2512"> </a>
<a name="ln2513">    return true;</a>
<a name="ln2514">}</a>
<a name="ln2515"> </a>
<a name="ln2516">// Only Jiyva jellies eat items.</a>
<a name="ln2517">static bool _monster_eat_item(monster* mons)</a>
<a name="ln2518">{</a>
<a name="ln2519">    if (!mons_eats_items(*mons))</a>
<a name="ln2520">        return false;</a>
<a name="ln2521"> </a>
<a name="ln2522">    // Off-limit squares are off-limit.</a>
<a name="ln2523">    if (testbits(env.pgrid(mons-&gt;pos()), FPROP_NO_JIYVA))</a>
<a name="ln2524">        return false;</a>
<a name="ln2525"> </a>
<a name="ln2526">    int hps_changed = 0;</a>
<a name="ln2527">    int max_eat = roll_dice(1, 10);</a>
<a name="ln2528">    int eaten = 0;</a>
<a name="ln2529">    bool shown_msg = false;</a>
<a name="ln2530"> </a>
<a name="ln2531">    // Jellies can swim, so don't check water</a>
<a name="ln2532">    for (stack_iterator si(mons-&gt;pos());</a>
<a name="ln2533">         si &amp;&amp; eaten &lt; max_eat &amp;&amp; hps_changed &lt; 50; ++si)</a>
<a name="ln2534">    {</a>
<a name="ln2535">        if (!item_is_jelly_edible(*si))</a>
<a name="ln2536">            continue;</a>
<a name="ln2537"> </a>
<a name="ln2538">        dprf(&quot;%s eating %s&quot;, mons-&gt;name(DESC_PLAIN, true).c_str(),</a>
<a name="ln2539">             si-&gt;name(DESC_PLAIN).c_str());</a>
<a name="ln2540"> </a>
<a name="ln2541">        int quant = si-&gt;quantity;</a>
<a name="ln2542"> </a>
<a name="ln2543">        if (si-&gt;base_type != OBJ_GOLD)</a>
<a name="ln2544">        {</a>
<a name="ln2545">            quant = min(quant, max_eat - eaten);</a>
<a name="ln2546"> </a>
<a name="ln2547">            hps_changed += quant * 3;</a>
<a name="ln2548">            eaten += quant;</a>
<a name="ln2549">        }</a>
<a name="ln2550">        else</a>
<a name="ln2551">        {</a>
<a name="ln2552">            // Shouldn't be much trouble to digest a huge pile of gold!</a>
<a name="ln2553">            if (quant &gt; 500)</a>
<a name="ln2554">                quant = 500 + roll_dice(2, (quant - 500) / 2);</a>
<a name="ln2555"> </a>
<a name="ln2556">            hps_changed += quant / 10 + 1;</a>
<a name="ln2557">            eaten++;</a>
<a name="ln2558">        }</a>
<a name="ln2559"> </a>
<a name="ln2560">        if (eaten &amp;&amp; !shown_msg &amp;&amp; player_can_hear(mons-&gt;pos()))</a>
<a name="ln2561">        {</a>
<a name="ln2562">            mprf(MSGCH_SOUND, &quot;You hear a%s slurping noise.&quot;,</a>
<a name="ln2563">                 you.see_cell(mons-&gt;pos()) ? &quot;&quot; : &quot; distant&quot;);</a>
<a name="ln2564">            shown_msg = true;</a>
<a name="ln2565">        }</a>
<a name="ln2566"> </a>
<a name="ln2567">        if (you_worship(GOD_JIYVA))</a>
<a name="ln2568">            jiyva_slurp_item_stack(*si, quant);</a>
<a name="ln2569"> </a>
<a name="ln2570">        if (quant &gt;= si-&gt;quantity)</a>
<a name="ln2571">            item_was_destroyed(*si);</a>
<a name="ln2572">        else if (is_perishable_stack(*si))</a>
<a name="ln2573">            for (int i = 0; i &lt; quant; ++i)</a>
<a name="ln2574">                remove_oldest_perishable_item(*si);</a>
<a name="ln2575">        dec_mitm_item_quantity(si.index(), quant);</a>
<a name="ln2576">    }</a>
<a name="ln2577"> </a>
<a name="ln2578">    if (eaten &gt; 0)</a>
<a name="ln2579">    {</a>
<a name="ln2580">        hps_changed = max(hps_changed, 1);</a>
<a name="ln2581">        hps_changed = min(hps_changed, 50);</a>
<a name="ln2582"> </a>
<a name="ln2583">        // This is done manually instead of using heal_monster(),</a>
<a name="ln2584">        // because that function doesn't work quite this way. - bwr</a>
<a name="ln2585">        const int avg_hp = mons_avg_hp(mons-&gt;type);</a>
<a name="ln2586">        mons-&gt;hit_points += hps_changed;</a>
<a name="ln2587">        mons-&gt;hit_points = min(MAX_MONSTER_HP,</a>
<a name="ln2588">                               min(avg_hp * 4, mons-&gt;hit_points));</a>
<a name="ln2589">        mons-&gt;max_hit_points = max(mons-&gt;hit_points, mons-&gt;max_hit_points);</a>
<a name="ln2590"> </a>
<a name="ln2591">        _jelly_divide(*mons);</a>
<a name="ln2592">    }</a>
<a name="ln2593"> </a>
<a name="ln2594">    return eaten &gt; 0;</a>
<a name="ln2595">}</a>
<a name="ln2596"> </a>
<a name="ln2597"> </a>
<a name="ln2598">static bool _handle_pickup(monster* mons)</a>
<a name="ln2599">{</a>
<a name="ln2600">    if (igrd(mons-&gt;pos()) == NON_ITEM</a>
<a name="ln2601">        // Summoned monsters never pick anything up.</a>
<a name="ln2602">        || mons-&gt;is_summoned() || mons-&gt;is_perm_summoned()</a>
<a name="ln2603">        || mons-&gt;asleep() || mons-&gt;submerged())</a>
<a name="ln2604">    {</a>
<a name="ln2605">        return false;</a>
<a name="ln2606">    }</a>
<a name="ln2607"> </a>
<a name="ln2608">    // Flying over water doesn't let you pick up stuff. This is inexact, as</a>
<a name="ln2609">    // a merfolk could be flying, but that's currently impossible except for</a>
<a name="ln2610">    // being tornadoed, and with *that* low life expectancy let's not care.</a>
<a name="ln2611">    dungeon_feature_type feat = grd(mons-&gt;pos());</a>
<a name="ln2612"> </a>
<a name="ln2613">    if ((feat == DNGN_LAVA || feat == DNGN_DEEP_WATER) &amp;&amp; mons-&gt;airborne())</a>
<a name="ln2614">        return false;</a>
<a name="ln2615"> </a>
<a name="ln2616">    int count_pickup = 0;</a>
<a name="ln2617"> </a>
<a name="ln2618">    if (mons_eats_items(*mons) &amp;&amp; _monster_eat_item(mons))</a>
<a name="ln2619">        return false;</a>
<a name="ln2620"> </a>
<a name="ln2621">    if (mons_itemuse(*mons) &lt; MONUSE_WEAPONS_ARMOUR)</a>
<a name="ln2622">        return false;</a>
<a name="ln2623"> </a>
<a name="ln2624">    // Keep neutral, charmed, and friendly monsters from</a>
<a name="ln2625">    // picking up stuff.</a>
<a name="ln2626">    const bool never_pickup</a>
<a name="ln2627">        = mons-&gt;neutral() || mons-&gt;friendly()</a>
<a name="ln2628">          || have_passive(passive_t::neutral_slimes) &amp;&amp; mons_is_slime(*mons)</a>
<a name="ln2629">          || mons-&gt;has_ench(ENCH_CHARM) || mons-&gt;has_ench(ENCH_HEXED);</a>
<a name="ln2630"> </a>
<a name="ln2631"> </a>
<a name="ln2632">    // Note: Monsters only look at stuff near the top of stacks.</a>
<a name="ln2633">    //</a>
<a name="ln2634">    // XXX: Need to put in something so that monster picks up</a>
<a name="ln2635">    // multiple items (e.g. ammunition) identical to those it's</a>
<a name="ln2636">    // carrying.</a>
<a name="ln2637">    //</a>
<a name="ln2638">    // Monsters may now pick up up to two items in the same turn.</a>
<a name="ln2639">    // (jpeg)</a>
<a name="ln2640">    for (stack_iterator si(mons-&gt;pos()); si; ++si)</a>
<a name="ln2641">    {</a>
<a name="ln2642">        if (!crawl_state.game_is_arena()</a>
<a name="ln2643">            &amp;&amp; (never_pickup</a>
<a name="ln2644">                // Monsters being able to pick up items you've seen encourages</a>
<a name="ln2645">                // tediously moving everything away from a place where they</a>
<a name="ln2646">                // could use them. Maurice being able to pick up such items</a>
<a name="ln2647">                // encourages killing Maurice, since there's just one of him.</a>
<a name="ln2648">                // Usually.</a>
<a name="ln2649">                || (testbits(si-&gt;flags, ISFLAG_SEEN)</a>
<a name="ln2650">                    &amp;&amp; !mons-&gt;has_attack_flavour(AF_STEAL)))</a>
<a name="ln2651">            // ...but it's ok if it dropped the item itself.</a>
<a name="ln2652">            &amp;&amp; !(si-&gt;props.exists(DROPPER_MID_KEY)</a>
<a name="ln2653">                 &amp;&amp; si-&gt;props[DROPPER_MID_KEY].get_int() == (int)mons-&gt;mid))</a>
<a name="ln2654">        {</a>
<a name="ln2655">            // don't pick up any items beneath one that the player's seen,</a>
<a name="ln2656">            // to prevent seemingly-buggy behavior (monsters picking up items</a>
<a name="ln2657">            // from the middle of a stack while the player is watching)</a>
<a name="ln2658">            return false;</a>
<a name="ln2659">        }</a>
<a name="ln2660"> </a>
<a name="ln2661">        if (si-&gt;flags &amp; ISFLAG_NO_PICKUP)</a>
<a name="ln2662">            continue;</a>
<a name="ln2663"> </a>
<a name="ln2664">        if (mons-&gt;pickup_item(*si, you.see_cell(mons-&gt;pos()), false))</a>
<a name="ln2665">            count_pickup++;</a>
<a name="ln2666"> </a>
<a name="ln2667">        if (count_pickup &gt; 1 || coinflip())</a>
<a name="ln2668">            break;</a>
<a name="ln2669">    }</a>
<a name="ln2670"> </a>
<a name="ln2671">    return count_pickup &gt; 0;</a>
<a name="ln2672">}</a>
<a name="ln2673"> </a>
<a name="ln2674">static void _mons_open_door(monster&amp; mons, const coord_def &amp;pos)</a>
<a name="ln2675">{</a>
<a name="ln2676">    const char *adj = &quot;&quot;, *noun = &quot;door&quot;;</a>
<a name="ln2677"> </a>
<a name="ln2678">    bool was_seen   = false;</a>
<a name="ln2679"> </a>
<a name="ln2680">    set&lt;coord_def&gt; all_door;</a>
<a name="ln2681">    find_connected_identical(pos, all_door);</a>
<a name="ln2682">    get_door_description(all_door.size(), &amp;adj, &amp;noun);</a>
<a name="ln2683"> </a>
<a name="ln2684">    for (const auto &amp;dc : all_door)</a>
<a name="ln2685">    {</a>
<a name="ln2686">        if (you.see_cell(dc))</a>
<a name="ln2687">            was_seen = true;</a>
<a name="ln2688"> </a>
<a name="ln2689">        dgn_open_door(dc);</a>
<a name="ln2690">        set_terrain_changed(dc);</a>
<a name="ln2691">    }</a>
<a name="ln2692"> </a>
<a name="ln2693">    if (was_seen)</a>
<a name="ln2694">    {</a>
<a name="ln2695">        viewwindow();</a>
<a name="ln2696"> </a>
<a name="ln2697">        string open_str = &quot;opens the &quot;;</a>
<a name="ln2698">        open_str += adj;</a>
<a name="ln2699">        open_str += noun;</a>
<a name="ln2700">        open_str += &quot;.&quot;;</a>
<a name="ln2701"> </a>
<a name="ln2702">        // Should this be conditionalized on you.can_see(mons?)</a>
<a name="ln2703">        mons.seen_context = (all_door.size() &lt;= 2) ? SC_DOOR : SC_GATE;</a>
<a name="ln2704"> </a>
<a name="ln2705">        if (!you.can_see(mons))</a>
<a name="ln2706">        {</a>
<a name="ln2707">            mprf(&quot;Something unseen %s&quot;, open_str.c_str());</a>
<a name="ln2708">            interrupt_activity(activity_interrupt::force);</a>
<a name="ln2709">        }</a>
<a name="ln2710">        else if (!you_are_delayed())</a>
<a name="ln2711">        {</a>
<a name="ln2712">            mprf(&quot;%s %s&quot;, mons.name(DESC_A).c_str(),</a>
<a name="ln2713">                 open_str.c_str());</a>
<a name="ln2714">        }</a>
<a name="ln2715">    }</a>
<a name="ln2716"> </a>
<a name="ln2717">    mons.lose_energy(EUT_MOVE);</a>
<a name="ln2718"> </a>
<a name="ln2719">    dungeon_events.fire_position_event(DET_DOOR_OPENED, pos);</a>
<a name="ln2720">}</a>
<a name="ln2721"> </a>
<a name="ln2722">static bool _no_habitable_adjacent_grids(const monster* mon)</a>
<a name="ln2723">{</a>
<a name="ln2724">    for (adjacent_iterator ai(mon-&gt;pos()); ai; ++ai)</a>
<a name="ln2725">        if (monster_habitable_grid(mon, grd(*ai)))</a>
<a name="ln2726">            return false;</a>
<a name="ln2727"> </a>
<a name="ln2728">    return true;</a>
<a name="ln2729">}</a>
<a name="ln2730"> </a>
<a name="ln2731">static bool _same_tentacle_parts(const monster* mpusher,</a>
<a name="ln2732">                               const monster* mpushee)</a>
<a name="ln2733">{</a>
<a name="ln2734">    if (!mons_is_tentacle_head(mons_base_type(*mpusher)))</a>
<a name="ln2735">        return false;</a>
<a name="ln2736"> </a>
<a name="ln2737">    if (mpushee-&gt;is_child_tentacle_of(mpusher))</a>
<a name="ln2738">        return true;</a>
<a name="ln2739"> </a>
<a name="ln2740">    if (mons_tentacle_adjacent(mpusher, mpushee))</a>
<a name="ln2741">        return true;</a>
<a name="ln2742"> </a>
<a name="ln2743">    return false;</a>
<a name="ln2744">}</a>
<a name="ln2745"> </a>
<a name="ln2746">static bool _mons_can_displace(const monster* mpusher,</a>
<a name="ln2747">                               const monster* mpushee)</a>
<a name="ln2748">{</a>
<a name="ln2749">    if (invalid_monster(mpusher) || invalid_monster(mpushee))</a>
<a name="ln2750">        return false;</a>
<a name="ln2751"> </a>
<a name="ln2752">    const int ipushee = mpushee-&gt;mindex();</a>
<a name="ln2753">    if (invalid_monster_index(ipushee))</a>
<a name="ln2754">        return false;</a>
<a name="ln2755"> </a>
<a name="ln2756">    if (mpusher-&gt;type == MONS_WANDERING_MUSHROOM</a>
<a name="ln2757">        &amp;&amp; mpushee-&gt;type == MONS_TOADSTOOL</a>
<a name="ln2758">        || mpusher-&gt;type == MONS_TOADSTOOL</a>
<a name="ln2759">           &amp;&amp; mpushee-&gt;type == MONS_WANDERING_MUSHROOM)</a>
<a name="ln2760">    {</a>
<a name="ln2761">        return true;</a>
<a name="ln2762">    }</a>
<a name="ln2763"> </a>
<a name="ln2764">    // Foxfires can always be pushed</a>
<a name="ln2765">    if (mpushee-&gt;type == MONS_FOXFIRE)</a>
<a name="ln2766">        return !mons_aligned(mpushee, mpusher); // But allies won't do it</a>
<a name="ln2767"> </a>
<a name="ln2768">    if (!mpushee-&gt;has_action_energy()</a>
<a name="ln2769">        &amp;&amp; !_same_tentacle_parts(mpusher, mpushee))</a>
<a name="ln2770">    {</a>
<a name="ln2771">        return false;</a>
<a name="ln2772">    }</a>
<a name="ln2773"> </a>
<a name="ln2774">    // Confused monsters can't be pushed past, sleeping monsters</a>
<a name="ln2775">    // can't push. Note that sleeping monsters can't be pushed</a>
<a name="ln2776">    // past, either, but they may be woken up by a crowd trying to</a>
<a name="ln2777">    // elbow past them, and the wake-up check happens downstream.</a>
<a name="ln2778">    // Monsters caught in a net also can't be pushed past.</a>
<a name="ln2779">    if (mons_is_confused(*mpusher) || mons_is_confused(*mpushee)</a>
<a name="ln2780">        || mpusher-&gt;cannot_move() || mpusher-&gt;is_stationary()</a>
<a name="ln2781">        || mpusher-&gt;is_constricted() || mpushee-&gt;is_constricted()</a>
<a name="ln2782">        || (!_same_tentacle_parts(mpusher, mpushee)</a>
<a name="ln2783">           &amp;&amp; (mpushee-&gt;cannot_move() || mpushee-&gt;is_stationary()))</a>
<a name="ln2784">        || mpusher-&gt;asleep() || mpushee-&gt;caught())</a>
<a name="ln2785">    {</a>
<a name="ln2786">        return false;</a>
<a name="ln2787">    }</a>
<a name="ln2788"> </a>
<a name="ln2789">    // OODs should crash into things, not push them around.</a>
<a name="ln2790">    if (mons_is_projectile(*mpusher) || mons_is_projectile(*mpushee))</a>
<a name="ln2791">        return false;</a>
<a name="ln2792"> </a>
<a name="ln2793">    // Fleeing monsters cannot push past other fleeing monsters</a>
<a name="ln2794">    // (This helps to prevent some traffic jams in confined spaces)</a>
<a name="ln2795">    if (mons_is_fleeing(*mpusher) &amp;&amp; mons_is_fleeing(*mpushee))</a>
<a name="ln2796">        return false;</a>
<a name="ln2797"> </a>
<a name="ln2798">    // Batty monsters are unpushable.</a>
<a name="ln2799">    if (mons_is_batty(*mpusher) || mons_is_batty(*mpushee))</a>
<a name="ln2800">        return false;</a>
<a name="ln2801"> </a>
<a name="ln2802">    // Anyone can displace a submerged monster.</a>
<a name="ln2803">    if (mpushee-&gt;submerged())</a>
<a name="ln2804">        return true;</a>
<a name="ln2805"> </a>
<a name="ln2806">    if (!monster_shover(*mpusher))</a>
<a name="ln2807">        return false;</a>
<a name="ln2808"> </a>
<a name="ln2809">    // Fleeing monsters of the same type may push past higher ranking ones.</a>
<a name="ln2810">    if (!monster_senior(*mpusher, *mpushee, mons_is_retreating(*mpusher)))</a>
<a name="ln2811">        return false;</a>
<a name="ln2812"> </a>
<a name="ln2813">    return true;</a>
<a name="ln2814">}</a>
<a name="ln2815"> </a>
<a name="ln2816">// Returns true if the monster should try to avoid that position</a>
<a name="ln2817">// because of taking damage from damaging walls.</a>
<a name="ln2818">static bool _check_damaging_walls(const monster *mon,</a>
<a name="ln2819">                                  const coord_def &amp;targ)</a>
<a name="ln2820">{</a>
<a name="ln2821">    const bool have_slimy = env.level_state &amp; LSTATE_SLIMY_WALL;</a>
<a name="ln2822">    const bool have_icy   = env.level_state &amp; LSTATE_ICY_WALL;</a>
<a name="ln2823"> </a>
<a name="ln2824">    if (!have_slimy &amp;&amp; !have_icy)</a>
<a name="ln2825">        return false;</a>
<a name="ln2826"> </a>
<a name="ln2827">    if (!have_icy &amp;&amp; actor_slime_wall_immune(mon)</a>
<a name="ln2828">        || mons_intel(*mon) &lt;= I_BRAINLESS)</a>
<a name="ln2829">    {</a>
<a name="ln2830">        return false;</a>
<a name="ln2831">    }</a>
<a name="ln2832"> </a>
<a name="ln2833">    // Monsters are only ever affected by one wall at a time, so we don't care</a>
<a name="ln2834">    // about wall counts past 1.</a>
<a name="ln2835">    const bool target_damages = count_adjacent_slime_walls(targ)</a>
<a name="ln2836">        + count_adjacent_icy_walls(targ);</a>
<a name="ln2837"> </a>
<a name="ln2838">    // Entirely safe.</a>
<a name="ln2839">    if (!target_damages)</a>
<a name="ln2840">        return false;</a>
<a name="ln2841"> </a>
<a name="ln2842">    const bool current_damages = count_adjacent_slime_walls(mon-&gt;pos())</a>
<a name="ln2843">        + count_adjacent_icy_walls(mon-&gt;pos());</a>
<a name="ln2844"> </a>
<a name="ln2845">    // We're already taking damage, so moving into damage is fine.</a>
<a name="ln2846">    if (current_damages)</a>
<a name="ln2847">        return false;</a>
<a name="ln2848"> </a>
<a name="ln2849">    // The monster needs to have a purpose to risk taking damage.</a>
<a name="ln2850">    if (!mons_is_seeking(*mon))</a>
<a name="ln2851">        return true;</a>
<a name="ln2852"> </a>
<a name="ln2853">    // With enough hit points monsters will consider moving</a>
<a name="ln2854">    // onto more dangerous squares.</a>
<a name="ln2855">    return mon-&gt;hit_points &lt; mon-&gt;max_hit_points / 2;</a>
<a name="ln2856">}</a>
<a name="ln2857"> </a>
<a name="ln2858">// Check whether a monster can move to given square (described by its relative</a>
<a name="ln2859">// coordinates to the current monster position). just_check is true only for</a>
<a name="ln2860">// calls from is_trap_safe when checking the surrounding squares of a trap.</a>
<a name="ln2861">bool mon_can_move_to_pos(const monster* mons, const coord_def&amp; delta,</a>
<a name="ln2862">                         bool just_check)</a>
<a name="ln2863">{</a>
<a name="ln2864">    const coord_def targ = mons-&gt;pos() + delta;</a>
<a name="ln2865"> </a>
<a name="ln2866">    // Bounds check: don't consider moving out of grid!</a>
<a name="ln2867">    if (!in_bounds(targ))</a>
<a name="ln2868">        return false;</a>
<a name="ln2869"> </a>
<a name="ln2870">    // Non-friendly and non-good neutral monsters won't enter</a>
<a name="ln2871">    // sanctuaries.</a>
<a name="ln2872">    if (is_sanctuary(targ)</a>
<a name="ln2873">        &amp;&amp; !is_sanctuary(mons-&gt;pos())</a>
<a name="ln2874">        &amp;&amp; !mons-&gt;wont_attack())</a>
<a name="ln2875">    {</a>
<a name="ln2876">        return false;</a>
<a name="ln2877">    }</a>
<a name="ln2878"> </a>
<a name="ln2879">    // Inside a sanctuary don't attack anything!</a>
<a name="ln2880">    if (is_sanctuary(mons-&gt;pos()) &amp;&amp; actor_at(targ))</a>
<a name="ln2881">        return false;</a>
<a name="ln2882"> </a>
<a name="ln2883">    const dungeon_feature_type target_grid = grd(targ);</a>
<a name="ln2884">    const habitat_type habitat = mons_primary_habitat(*mons);</a>
<a name="ln2885"> </a>
<a name="ln2886">    // No monster may enter the open sea.</a>
<a name="ln2887">    if (feat_is_endless(target_grid))</a>
<a name="ln2888">        return false;</a>
<a name="ln2889"> </a>
<a name="ln2890">    // A confused monster will happily go wherever it can, regardless of</a>
<a name="ln2891">    // consequences.</a>
<a name="ln2892">    if (mons-&gt;confused() &amp;&amp; mons-&gt;can_pass_through(targ))</a>
<a name="ln2893">        return true;</a>
<a name="ln2894"> </a>
<a name="ln2895">    if (mons_avoids_cloud(mons, targ))</a>
<a name="ln2896">        return false;</a>
<a name="ln2897"> </a>
<a name="ln2898">    if (_check_damaging_walls(mons, targ))</a>
<a name="ln2899">        return false;</a>
<a name="ln2900"> </a>
<a name="ln2901">    const bool digs = _mons_can_cast_dig(mons, false)</a>
<a name="ln2902">                      || _mons_can_zap_dig(mons);</a>
<a name="ln2903">    if ((target_grid == DNGN_ROCK_WALL || target_grid == DNGN_CLEAR_ROCK_WALL)</a>
<a name="ln2904">           &amp;&amp; (mons_class_flag(mons-&gt;type, M_BURROWS) || digs)</a>
<a name="ln2905">        || mons-&gt;type == MONS_SPATIAL_MAELSTROM</a>
<a name="ln2906">           &amp;&amp; feat_is_solid(target_grid) &amp;&amp; !feat_is_permarock(target_grid)</a>
<a name="ln2907">           &amp;&amp; !feat_is_critical(target_grid)</a>
<a name="ln2908">        || feat_is_tree(target_grid) &amp;&amp; mons_flattens_trees(*mons)</a>
<a name="ln2909">        || target_grid == DNGN_GRATE &amp;&amp; digs)</a>
<a name="ln2910">    {</a>
<a name="ln2911">    }</a>
<a name="ln2912">    else if (!mons_can_traverse(*mons, targ, false, false)</a>
<a name="ln2913">             &amp;&amp; !monster_habitable_grid(mons, target_grid))</a>
<a name="ln2914">    {</a>
<a name="ln2915">        // If the monster somehow ended up in this habitat (and is</a>
<a name="ln2916">        // not dead by now), give it a chance to get out again.</a>
<a name="ln2917">        if (grd(mons-&gt;pos()) == target_grid &amp;&amp; mons-&gt;ground_level()</a>
<a name="ln2918">            &amp;&amp; _no_habitable_adjacent_grids(mons))</a>
<a name="ln2919">        {</a>
<a name="ln2920">            return true;</a>
<a name="ln2921">        }</a>
<a name="ln2922"> </a>
<a name="ln2923">        return false;</a>
<a name="ln2924">    }</a>
<a name="ln2925"> </a>
<a name="ln2926">    // These monsters usually don't move while you are looking.</a>
<a name="ln2927">    if (mons-&gt;type == MONS_WANDERING_MUSHROOM</a>
<a name="ln2928">        || mons-&gt;type == MONS_DEATHCAP</a>
<a name="ln2929">        || (mons-&gt;type == MONS_LURKING_HORROR</a>
<a name="ln2930">            &amp;&amp; mons-&gt;foe_distance() &gt; random2(LOS_DEFAULT_RANGE + 1)))</a>
<a name="ln2931">    {</a>
<a name="ln2932">        if (!mons-&gt;wont_attack() &amp;&amp; is_sanctuary(mons-&gt;pos()))</a>
<a name="ln2933">            return true;</a>
<a name="ln2934"> </a>
<a name="ln2935">        if (!mons-&gt;friendly() &amp;&amp; you.see_cell(targ)</a>
<a name="ln2936">            || mon_enemies_around(mons))</a>
<a name="ln2937">        {</a>
<a name="ln2938">            return false;</a>
<a name="ln2939">        }</a>
<a name="ln2940">    }</a>
<a name="ln2941"> </a>
<a name="ln2942">    if (mons-&gt;type == MONS_MERFOLK_AVATAR)</a>
<a name="ln2943">    {</a>
<a name="ln2944">        // Don't voluntarily break LoS with a player we're mesmerising</a>
<a name="ln2945">        if (you.beheld_by(*mons) &amp;&amp; !you.see_cell(targ))</a>
<a name="ln2946">            return false;</a>
<a name="ln2947"> </a>
<a name="ln2948">        // And path around players instead of into them</a>
<a name="ln2949">        if (you.pos() == targ)</a>
<a name="ln2950">            return false;</a>
<a name="ln2951">    }</a>
<a name="ln2952"> </a>
<a name="ln2953">    // Try to avoid deliberately blocking the player's line of fire.</a>
<a name="ln2954">    if (mons-&gt;type == MONS_SPELLFORGED_SERVITOR)</a>
<a name="ln2955">    {</a>
<a name="ln2956">        const actor * const summoner = actor_by_mid(mons-&gt;summoner);</a>
<a name="ln2957"> </a>
<a name="ln2958">        if (!summoner) // XXX</a>
<a name="ln2959">            return false;</a>
<a name="ln2960"> </a>
<a name="ln2961">        // Only check if our target is something the caster could theoretically</a>
<a name="ln2962">        // be aiming at.</a>
<a name="ln2963">        if (mons-&gt;get_foe() &amp;&amp; mons-&gt;target != summoner-&gt;pos()</a>
<a name="ln2964">                            &amp;&amp; summoner-&gt;see_cell_no_trans(mons-&gt;target))</a>
<a name="ln2965">        {</a>
<a name="ln2966">            ray_def ray;</a>
<a name="ln2967">            if (find_ray(summoner-&gt;pos(), mons-&gt;target, ray, opc_immob))</a>
<a name="ln2968">            {</a>
<a name="ln2969">                while (ray.advance())</a>
<a name="ln2970">                {</a>
<a name="ln2971">                    // Either we've reached the end of the ray, or we're already</a>
<a name="ln2972">                    // (maybe) in the player's way and shouldn't care if our</a>
<a name="ln2973">                    // next step also is.</a>
<a name="ln2974">                    if (ray.pos() == mons-&gt;target || ray.pos() == mons-&gt;pos())</a>
<a name="ln2975">                        break;</a>
<a name="ln2976">                    else if (ray.pos() == targ)</a>
<a name="ln2977">                        return false;</a>
<a name="ln2978">                }</a>
<a name="ln2979">            }</a>
<a name="ln2980">        }</a>
<a name="ln2981">    }</a>
<a name="ln2982"> </a>
<a name="ln2983">    // Submerged water creatures avoid the shallows where</a>
<a name="ln2984">    // they would be forced to surface. -- bwr</a>
<a name="ln2985">    // [dshaligram] Monsters now prefer to head for deep water only if</a>
<a name="ln2986">    // they're low on hitpoints. No point in hiding if they want a</a>
<a name="ln2987">    // fight.</a>
<a name="ln2988">    if (habitat == HT_WATER</a>
<a name="ln2989">        &amp;&amp; targ != you.pos()</a>
<a name="ln2990">        &amp;&amp; target_grid != DNGN_DEEP_WATER</a>
<a name="ln2991">        &amp;&amp; grd(mons-&gt;pos()) == DNGN_DEEP_WATER</a>
<a name="ln2992">        &amp;&amp; mons-&gt;hit_points &lt; (mons-&gt;max_hit_points * 3) / 4)</a>
<a name="ln2993">    {</a>
<a name="ln2994">        return false;</a>
<a name="ln2995">    }</a>
<a name="ln2996"> </a>
<a name="ln2997">    // Smacking the player is always a good move if we're</a>
<a name="ln2998">    // hostile (even if we're heading somewhere else).</a>
<a name="ln2999">    // Also friendlies want to keep close to the player</a>
<a name="ln3000">    // so it's okay as well.</a>
<a name="ln3001"> </a>
<a name="ln3002">    // Smacking another monster is good, if the monsters</a>
<a name="ln3003">    // are aligned differently.</a>
<a name="ln3004">    if (monster* targmonster = monster_at(targ))</a>
<a name="ln3005">    {</a>
<a name="ln3006">        if (just_check)</a>
<a name="ln3007">        {</a>
<a name="ln3008">            if (targ == mons-&gt;pos())</a>
<a name="ln3009">                return true;</a>
<a name="ln3010"> </a>
<a name="ln3011">            return false; // blocks square</a>
<a name="ln3012">        }</a>
<a name="ln3013"> </a>
<a name="ln3014">        if (!summon_can_attack(mons, targ))</a>
<a name="ln3015">            return false;</a>
<a name="ln3016"> </a>
<a name="ln3017">        if (targmonster-&gt;type == MONS_TOADSTOOL</a>
<a name="ln3018">            &amp;&amp; mons-&gt;type == MONS_WANDERING_MUSHROOM)</a>
<a name="ln3019">        {</a>
<a name="ln3020">            return true;</a>
<a name="ln3021">        }</a>
<a name="ln3022"> </a>
<a name="ln3023">        // Cut down plants only when no alternative, or they're</a>
<a name="ln3024">        // our target.</a>
<a name="ln3025">        if (mons_is_firewood(*targmonster) &amp;&amp; mons-&gt;target != targ)</a>
<a name="ln3026">            return false;</a>
<a name="ln3027"> </a>
<a name="ln3028">        if ((mons_aligned(mons, targmonster)</a>
<a name="ln3029">             || targmonster-&gt;type == MONS_FOXFIRE)</a>
<a name="ln3030">            &amp;&amp; !mons-&gt;has_ench(ENCH_INSANE)</a>
<a name="ln3031">            &amp;&amp; !_mons_can_displace(mons, targmonster))</a>
<a name="ln3032">        {</a>
<a name="ln3033">            return false;</a>
<a name="ln3034">        }</a>
<a name="ln3035">        // Prefer to move past enemies instead of hit them, if we're retreating</a>
<a name="ln3036">        else if ((!mons_aligned(mons, targmonster)</a>
<a name="ln3037">                  || mons-&gt;has_ench(ENCH_INSANE))</a>
<a name="ln3038">                 &amp;&amp; mons-&gt;behaviour == BEH_WITHDRAW)</a>
<a name="ln3039">        {</a>
<a name="ln3040">            return false;</a>
<a name="ln3041">        }</a>
<a name="ln3042">    }</a>
<a name="ln3043"> </a>
<a name="ln3044">    // Friendlies shouldn't try to move onto the player's</a>
<a name="ln3045">    // location, if they are aiming for some other target.</a>
<a name="ln3046">    if (mons-&gt;foe != MHITYOU</a>
<a name="ln3047">        &amp;&amp; targ == you.pos()</a>
<a name="ln3048">        &amp;&amp; (mons-&gt;foe != MHITNOT || mons-&gt;is_patrolling())</a>
<a name="ln3049">        &amp;&amp; !_unfriendly_or_impaired(*mons))</a>
<a name="ln3050">    {</a>
<a name="ln3051">        return false;</a>
<a name="ln3052">    }</a>
<a name="ln3053"> </a>
<a name="ln3054">    // Wandering through a trap is OK if we're pretty healthy,</a>
<a name="ln3055">    // really stupid, or immune to the trap.</a>
<a name="ln3056">    if (!mons-&gt;is_trap_safe(targ, just_check))</a>
<a name="ln3057">        return false;</a>
<a name="ln3058"> </a>
<a name="ln3059">    // If we end up here the monster can safely move.</a>
<a name="ln3060">    return true;</a>
<a name="ln3061">}</a>
<a name="ln3062"> </a>
<a name="ln3063">// May mons attack targ if it's in its way, despite</a>
<a name="ln3064">// possibly aligned attitudes?</a>
<a name="ln3065">// The aim of this is to have monsters cut down plants</a>
<a name="ln3066">// to get to the player if necessary.</a>
<a name="ln3067">static bool _may_cutdown(monster* mons, monster* targ)</a>
<a name="ln3068">{</a>
<a name="ln3069">    // Save friendly plants from allies.</a>
<a name="ln3070">    // [ds] I'm deliberately making the alignment checks symmetric here.</a>
<a name="ln3071">    // The previous check involved good-neutrals never attacking friendlies</a>
<a name="ln3072">    // and friendlies never attacking anything other than hostiles.</a>
<a name="ln3073">    if ((mons-&gt;friendly() || mons-&gt;good_neutral())</a>
<a name="ln3074">         &amp;&amp; (targ-&gt;friendly() || targ-&gt;good_neutral()))</a>
<a name="ln3075">    {</a>
<a name="ln3076">        return false;</a>
<a name="ln3077">    }</a>
<a name="ln3078">    // Outside of that case, can always cut mundane plants</a>
<a name="ln3079">    // (but don't try to attack briars unless their damage will be insignificant)</a>
<a name="ln3080">    return mons_is_firewood(*targ)</a>
<a name="ln3081">        &amp;&amp; (targ-&gt;type != MONS_BRIAR_PATCH</a>
<a name="ln3082">            || (targ-&gt;friendly() &amp;&amp; !mons_aligned(mons, targ))</a>
<a name="ln3083">            || mons-&gt;type == MONS_THORN_HUNTER</a>
<a name="ln3084">            || mons-&gt;armour_class() * mons-&gt;hit_points &gt;= 400);</a>
<a name="ln3085">}</a>
<a name="ln3086"> </a>
<a name="ln3087">// Uses, and updates the global variable mmov.</a>
<a name="ln3088">static void _find_good_alternate_move(monster* mons,</a>
<a name="ln3089">                                      const move_array&amp; good_move)</a>
<a name="ln3090">{</a>
<a name="ln3091">    const coord_def target = mons-&gt;firing_pos.zero() ? mons-&gt;target</a>
<a name="ln3092">                                                     : mons-&gt;firing_pos;</a>
<a name="ln3093">    const int current_distance = distance2(mons-&gt;pos(), target);</a>
<a name="ln3094"> </a>
<a name="ln3095">    int dir = _compass_idx(mmov);</a>
<a name="ln3096"> </a>
<a name="ln3097">    // Only handle if the original move is to an adjacent square.</a>
<a name="ln3098">    if (dir == -1)</a>
<a name="ln3099">        return;</a>
<a name="ln3100"> </a>
<a name="ln3101">    int dist[2];</a>
<a name="ln3102"> </a>
<a name="ln3103">    // First 1 away, then 2 (3 is silly).</a>
<a name="ln3104">    for (int j = 1; j &lt;= 2; j++)</a>
<a name="ln3105">    {</a>
<a name="ln3106">        const int FAR_AWAY = 1000000;</a>
<a name="ln3107"> </a>
<a name="ln3108">        // Try both directions (but randomise which one is first).</a>
<a name="ln3109">        const int sdir = random_choose(j, -j);</a>
<a name="ln3110">        const int inc = -2 * sdir;</a>
<a name="ln3111"> </a>
<a name="ln3112">        for (int mod = sdir, i = 0; i &lt; 2; mod += inc, i++)</a>
<a name="ln3113">        {</a>
<a name="ln3114">            const int newdir = (dir + 8 + mod) % 8;</a>
<a name="ln3115">            if (good_move[mon_compass[newdir].x+1][mon_compass[newdir].y+1])</a>
<a name="ln3116">                dist[i] = distance2(mons-&gt;pos()+mon_compass[newdir], target);</a>
<a name="ln3117">            else</a>
<a name="ln3118">            {</a>
<a name="ln3119">                // If we can cut firewood there, it's still not a good move,</a>
<a name="ln3120">                // but update mmov so we can fall back to it.</a>
<a name="ln3121">                monster* targ = monster_at(mons-&gt;pos() + mon_compass[newdir]);</a>
<a name="ln3122">                const bool retreating = mons_is_retreating(*mons);</a>
<a name="ln3123"> </a>
<a name="ln3124">                dist[i] = (targ &amp;&amp; _may_cutdown(mons, targ))</a>
<a name="ln3125">                          ? current_distance</a>
<a name="ln3126">                          : retreating ? -FAR_AWAY : FAR_AWAY;</a>
<a name="ln3127">            }</a>
<a name="ln3128">        }</a>
<a name="ln3129"> </a>
<a name="ln3130">        const int dir0 = ((dir + 8 + sdir) % 8);</a>
<a name="ln3131">        const int dir1 = ((dir + 8 - sdir) % 8);</a>
<a name="ln3132"> </a>
<a name="ln3133">        // Now choose.</a>
<a name="ln3134">        if (dist[0] == dist[1] &amp;&amp; abs(dist[0]) == FAR_AWAY)</a>
<a name="ln3135">            continue;</a>
<a name="ln3136"> </a>
<a name="ln3137">        // Which one was better? -- depends on FLEEING or not.</a>
<a name="ln3138">        if (mons_is_retreating(*mons))</a>
<a name="ln3139">        {</a>
<a name="ln3140">            if (dist[0] &gt;= dist[1] &amp;&amp; dist[0] &gt;= current_distance)</a>
<a name="ln3141">            {</a>
<a name="ln3142">                mmov = mon_compass[dir0];</a>
<a name="ln3143">                break;</a>
<a name="ln3144">            }</a>
<a name="ln3145">            if (dist[1] &gt;= dist[0] &amp;&amp; dist[1] &gt;= current_distance)</a>
<a name="ln3146">            {</a>
<a name="ln3147">                mmov = mon_compass[dir1];</a>
<a name="ln3148">                break;</a>
<a name="ln3149">            }</a>
<a name="ln3150">        }</a>
<a name="ln3151">        else</a>
<a name="ln3152">        {</a>
<a name="ln3153">            if (dist[0] &lt;= dist[1] &amp;&amp; dist[0] &lt;= current_distance)</a>
<a name="ln3154">            {</a>
<a name="ln3155">                mmov = mon_compass[dir0];</a>
<a name="ln3156">                break;</a>
<a name="ln3157">            }</a>
<a name="ln3158">            if (dist[1] &lt;= dist[0] &amp;&amp; dist[1] &lt;= current_distance)</a>
<a name="ln3159">            {</a>
<a name="ln3160">                mmov = mon_compass[dir1];</a>
<a name="ln3161">                break;</a>
<a name="ln3162">            }</a>
<a name="ln3163">        }</a>
<a name="ln3164">    }</a>
<a name="ln3165">}</a>
<a name="ln3166"> </a>
<a name="ln3167">static void _jelly_grows(monster&amp; mons)</a>
<a name="ln3168">{</a>
<a name="ln3169">    if (player_can_hear(mons.pos()))</a>
<a name="ln3170">    {</a>
<a name="ln3171">        mprf(MSGCH_SOUND, &quot;You hear a%s slurping noise.&quot;,</a>
<a name="ln3172">             you.see_cell(mons.pos()) ? &quot;&quot; : &quot; distant&quot;);</a>
<a name="ln3173">    }</a>
<a name="ln3174"> </a>
<a name="ln3175">    const int avg_hp = mons_avg_hp(mons.type);</a>
<a name="ln3176">    mons.hit_points += 5;</a>
<a name="ln3177">    mons.hit_points = min(MAX_MONSTER_HP,</a>
<a name="ln3178">                          min(avg_hp * 4, mons.hit_points));</a>
<a name="ln3179"> </a>
<a name="ln3180">    // note here, that this makes jellies &quot;grow&quot; {dlb}:</a>
<a name="ln3181">    if (mons.hit_points &gt; mons.max_hit_points)</a>
<a name="ln3182">        mons.max_hit_points = mons.hit_points;</a>
<a name="ln3183"> </a>
<a name="ln3184">    _jelly_divide(mons);</a>
<a name="ln3185">}</a>
<a name="ln3186"> </a>
<a name="ln3187">bool monster_swaps_places(monster* mon, const coord_def&amp; delta,</a>
<a name="ln3188">                          bool takes_time, bool apply_effects)</a>
<a name="ln3189">{</a>
<a name="ln3190">    if (delta.origin())</a>
<a name="ln3191">        return false;</a>
<a name="ln3192"> </a>
<a name="ln3193">    monster* const m2 = monster_at(mon-&gt;pos() + delta);</a>
<a name="ln3194"> </a>
<a name="ln3195">    if (!m2)</a>
<a name="ln3196">        return false;</a>
<a name="ln3197"> </a>
<a name="ln3198">    if (!_mons_can_displace(mon, m2))</a>
<a name="ln3199">        return false;</a>
<a name="ln3200"> </a>
<a name="ln3201">    if (m2-&gt;asleep())</a>
<a name="ln3202">    {</a>
<a name="ln3203">        if (coinflip())</a>
<a name="ln3204">        {</a>
<a name="ln3205">            dprf(&quot;Alerting monster %s at (%d,%d)&quot;,</a>
<a name="ln3206">                 m2-&gt;name(DESC_PLAIN).c_str(), m2-&gt;pos().x, m2-&gt;pos().y);</a>
<a name="ln3207">            behaviour_event(m2, ME_ALERT);</a>
<a name="ln3208">        }</a>
<a name="ln3209">        return false;</a>
<a name="ln3210">    }</a>
<a name="ln3211"> </a>
<a name="ln3212">    if (!mon-&gt;swap_with(m2))</a>
<a name="ln3213">        return false;</a>
<a name="ln3214"> </a>
<a name="ln3215">    if (takes_time)</a>
<a name="ln3216">    {</a>
<a name="ln3217">        _swim_or_move_energy(*mon);</a>
<a name="ln3218">        _swim_or_move_energy(*m2);</a>
<a name="ln3219">    }</a>
<a name="ln3220"> </a>
<a name="ln3221">    mon-&gt;check_redraw(m2-&gt;pos(), false);</a>
<a name="ln3222">    if (apply_effects)</a>
<a name="ln3223">        mon-&gt;apply_location_effects(m2-&gt;pos());</a>
<a name="ln3224"> </a>
<a name="ln3225">    m2-&gt;check_redraw(mon-&gt;pos(), false);</a>
<a name="ln3226">    if (apply_effects)</a>
<a name="ln3227">        m2-&gt;apply_location_effects(mon-&gt;pos());</a>
<a name="ln3228"> </a>
<a name="ln3229">    // The seen context no longer applies if the monster is moving normally.</a>
<a name="ln3230">    mon-&gt;seen_context = SC_NONE;</a>
<a name="ln3231">    m2-&gt;seen_context = SC_NONE;</a>
<a name="ln3232"> </a>
<a name="ln3233">    _handle_manticore_barbs(*mon);</a>
<a name="ln3234">    _handle_manticore_barbs(*m2);</a>
<a name="ln3235"> </a>
<a name="ln3236">    // Pushing past a foxfire gets you burned regardless of alignment</a>
<a name="ln3237">    if (m2-&gt;type == MONS_FOXFIRE)</a>
<a name="ln3238">    {</a>
<a name="ln3239">        foxfire_attack(m2, mon);</a>
<a name="ln3240">        monster_die(*m2, KILL_DISMISSED, NON_MONSTER, true);</a>
<a name="ln3241">    }</a>
<a name="ln3242"> </a>
<a name="ln3243">    return false;</a>
<a name="ln3244">}</a>
<a name="ln3245"> </a>
<a name="ln3246">static bool _do_move_monster(monster&amp; mons, const coord_def&amp; delta)</a>
<a name="ln3247">{</a>
<a name="ln3248">    const coord_def f = mons.pos() + delta;</a>
<a name="ln3249"> </a>
<a name="ln3250">    if (!in_bounds(f))</a>
<a name="ln3251">        return false;</a>
<a name="ln3252"> </a>
<a name="ln3253">    if (f == you.pos())</a>
<a name="ln3254">    {</a>
<a name="ln3255">        fight_melee(&amp;mons, &amp;you);</a>
<a name="ln3256">        return true;</a>
<a name="ln3257">    }</a>
<a name="ln3258"> </a>
<a name="ln3259">    // This includes the case where the monster attacks itself.</a>
<a name="ln3260">    if (monster* def = monster_at(f))</a>
<a name="ln3261">    {</a>
<a name="ln3262">        fight_melee(&amp;mons, def);</a>
<a name="ln3263">        return true;</a>
<a name="ln3264">    }</a>
<a name="ln3265"> </a>
<a name="ln3266">    if (mons.is_constricted())</a>
<a name="ln3267">    {</a>
<a name="ln3268">        if (mons.attempt_escape())</a>
<a name="ln3269">            simple_monster_message(mons, &quot; escapes!&quot;);</a>
<a name="ln3270">        else</a>
<a name="ln3271">        {</a>
<a name="ln3272">            simple_monster_message(mons, &quot; struggles to escape constriction.&quot;);</a>
<a name="ln3273">            _swim_or_move_energy(mons);</a>
<a name="ln3274">            return true;</a>
<a name="ln3275">        }</a>
<a name="ln3276">    }</a>
<a name="ln3277"> </a>
<a name="ln3278">    ASSERT(!cell_is_runed(f)); // should be checked in mons_can_traverse</a>
<a name="ln3279"> </a>
<a name="ln3280">    if (feat_is_closed_door(grd(f)))</a>
<a name="ln3281">    {</a>
<a name="ln3282">        if (mons_can_destroy_door(mons, f))</a>
<a name="ln3283">        {</a>
<a name="ln3284">            grd(f) = DNGN_FLOOR;</a>
<a name="ln3285">            set_terrain_changed(f);</a>
<a name="ln3286"> </a>
<a name="ln3287">            if (you.see_cell(f))</a>
<a name="ln3288">            {</a>
<a name="ln3289">                viewwindow();</a>
<a name="ln3290"> </a>
<a name="ln3291">                if (!you.can_see(mons))</a>
<a name="ln3292">                {</a>
<a name="ln3293">                    mpr(&quot;The door bursts into shrapnel!&quot;);</a>
<a name="ln3294">                    interrupt_activity(activity_interrupt::force);</a>
<a name="ln3295">                }</a>
<a name="ln3296">                else</a>
<a name="ln3297">                    simple_monster_message(mons, &quot; bursts through the door, destroying it!&quot;);</a>
<a name="ln3298">            }</a>
<a name="ln3299">        }</a>
<a name="ln3300">        else if (mons_can_open_door(mons, f))</a>
<a name="ln3301">        {</a>
<a name="ln3302">            _mons_open_door(mons, f);</a>
<a name="ln3303">            return true;</a>
<a name="ln3304">        }</a>
<a name="ln3305">        else if (mons_can_eat_door(mons, f))</a>
<a name="ln3306">        {</a>
<a name="ln3307">            grd(f) = DNGN_FLOOR;</a>
<a name="ln3308">            set_terrain_changed(f);</a>
<a name="ln3309"> </a>
<a name="ln3310">            _jelly_grows(mons);</a>
<a name="ln3311"> </a>
<a name="ln3312">            if (you.see_cell(f))</a>
<a name="ln3313">            {</a>
<a name="ln3314">                viewwindow();</a>
<a name="ln3315"> </a>
<a name="ln3316">                if (!you.can_see(mons))</a>
<a name="ln3317">                {</a>
<a name="ln3318">                    mpr(&quot;The door mysteriously vanishes.&quot;);</a>
<a name="ln3319">                    interrupt_activity(activity_interrupt::force);</a>
<a name="ln3320">                }</a>
<a name="ln3321">                else</a>
<a name="ln3322">                    simple_monster_message(mons, &quot; eats the door!&quot;);</a>
<a name="ln3323">            }</a>
<a name="ln3324">        } // done door-eating jellies</a>
<a name="ln3325">    }</a>
<a name="ln3326"> </a>
<a name="ln3327">    // The monster gave a &quot;comes into view&quot; message and then immediately</a>
<a name="ln3328">    // moved back out of view, leaing the player nothing to see, so give</a>
<a name="ln3329">    // this message to avoid confusion.</a>
<a name="ln3330">    else if (crawl_state.game_is_hints() &amp;&amp; mons.flags &amp; MF_WAS_IN_VIEW</a>
<a name="ln3331">             &amp;&amp; !you.see_cell(f))</a>
<a name="ln3332">    {</a>
<a name="ln3333">        learned_something_new(HINT_MONSTER_LEFT_LOS, mons.pos());</a>
<a name="ln3334">    }</a>
<a name="ln3335"> </a>
<a name="ln3336">    // The seen context no longer applies if the monster is moving normally.</a>
<a name="ln3337">    mons.seen_context = SC_NONE;</a>
<a name="ln3338"> </a>
<a name="ln3339">    // This appears to be the real one, ie where the movement occurs:</a>
<a name="ln3340">    _swim_or_move_energy(mons);</a>
<a name="ln3341"> </a>
<a name="ln3342">    if (mons.type == MONS_FOXFIRE)</a>
<a name="ln3343">        --mons.steps_remaining;</a>
<a name="ln3344"> </a>
<a name="ln3345">    _escape_water_hold(mons);</a>
<a name="ln3346"> </a>
<a name="ln3347">    if (grd(mons.pos()) == DNGN_DEEP_WATER &amp;&amp; grd(f) != DNGN_DEEP_WATER</a>
<a name="ln3348">        &amp;&amp; !monster_habitable_grid(&amp;mons, DNGN_DEEP_WATER))</a>
<a name="ln3349">    {</a>
<a name="ln3350">        // er, what?  Seems impossible.</a>
<a name="ln3351">        mons.seen_context = SC_NONSWIMMER_SURFACES_FROM_DEEP;</a>
<a name="ln3352">    }</a>
<a name="ln3353"> </a>
<a name="ln3354">    mons.move_to_pos(f, false);</a>
<a name="ln3355"> </a>
<a name="ln3356">    // Let go of all constrictees; only stop *being* constricted if we are now</a>
<a name="ln3357">    // too far away (done in move_to_pos above).</a>
<a name="ln3358">    mons.stop_directly_constricting_all(false);</a>
<a name="ln3359"> </a>
<a name="ln3360">    mons.check_redraw(mons.pos() - delta);</a>
<a name="ln3361">    mons.apply_location_effects(mons.pos() - delta);</a>
<a name="ln3362">    if (!invalid_monster(&amp;mons) &amp;&amp; you.can_see(mons))</a>
<a name="ln3363">    {</a>
<a name="ln3364">        handle_seen_interrupt(&amp;mons);</a>
<a name="ln3365">        seen_monster(&amp;mons);</a>
<a name="ln3366">    }</a>
<a name="ln3367"> </a>
<a name="ln3368">    _handle_manticore_barbs(mons);</a>
<a name="ln3369"> </a>
<a name="ln3370">    return true;</a>
<a name="ln3371">}</a>
<a name="ln3372"> </a>
<a name="ln3373">static bool _monster_move(monster* mons)</a>
<a name="ln3374">{</a>
<a name="ln3375">    ASSERT(mons); // XXX: change to monster &amp;mons</a>
<a name="ln3376">    move_array good_move;</a>
<a name="ln3377"> </a>
<a name="ln3378">    const habitat_type habitat = mons_primary_habitat(*mons);</a>
<a name="ln3379">    bool deep_water_available = false;</a>
<a name="ln3380"> </a>
<a name="ln3381">    // Berserking monsters make a lot of racket.</a>
<a name="ln3382">    if (mons-&gt;berserk_or_insane())</a>
<a name="ln3383">    {</a>
<a name="ln3384">        int noise_level = get_shout_noise_level(mons_shouts(mons-&gt;type));</a>
<a name="ln3385">        if (noise_level &gt; 0)</a>
<a name="ln3386">        {</a>
<a name="ln3387">            if (you.can_see(*mons) &amp;&amp; mons-&gt;berserk())</a>
<a name="ln3388">            {</a>
<a name="ln3389">                if (one_chance_in(10))</a>
<a name="ln3390">                {</a>
<a name="ln3391">                    mprf(MSGCH_TALK_VISUAL, &quot;%s rages.&quot;,</a>
<a name="ln3392">                         mons-&gt;name(DESC_THE).c_str());</a>
<a name="ln3393">                }</a>
<a name="ln3394">                noisy(noise_level, mons-&gt;pos(), mons-&gt;mid);</a>
<a name="ln3395">            }</a>
<a name="ln3396">            else if (one_chance_in(5))</a>
<a name="ln3397">                monster_attempt_shout(*mons);</a>
<a name="ln3398">            else</a>
<a name="ln3399">            {</a>
<a name="ln3400">                // Just be noisy without messaging the player.</a>
<a name="ln3401">                noisy(noise_level, mons-&gt;pos(), mons-&gt;mid);</a>
<a name="ln3402">            }</a>
<a name="ln3403">        }</a>
<a name="ln3404">    }</a>
<a name="ln3405"> </a>
<a name="ln3406">    // If a water (or lava) monster is currently flopping around on land, it</a>
<a name="ln3407">    // cannot really control where it wants to move, though there's a 50%</a>
<a name="ln3408">    // chance of flopping into an adjacent water (or lava) grid.</a>
<a name="ln3409">    if (mons-&gt;has_ench(ENCH_AQUATIC_LAND))</a>
<a name="ln3410">    {</a>
<a name="ln3411">        vector&lt;coord_def&gt; adj_water;</a>
<a name="ln3412">        vector&lt;coord_def&gt; adj_move;</a>
<a name="ln3413">        for (adjacent_iterator ai(mons-&gt;pos()); ai; ++ai)</a>
<a name="ln3414">        {</a>
<a name="ln3415">            if (!cell_is_solid(*ai))</a>
<a name="ln3416">            {</a>
<a name="ln3417">                adj_move.push_back(*ai);</a>
<a name="ln3418">                if (habitat == HT_WATER &amp;&amp; feat_is_watery(grd(*ai))</a>
<a name="ln3419">                    || habitat == HT_LAVA &amp;&amp; feat_is_lava(grd(*ai)))</a>
<a name="ln3420">                {</a>
<a name="ln3421">                    adj_water.push_back(*ai);</a>
<a name="ln3422">                }</a>
<a name="ln3423">            }</a>
<a name="ln3424">        }</a>
<a name="ln3425">        if (adj_move.empty())</a>
<a name="ln3426">        {</a>
<a name="ln3427">            simple_monster_message(*mons, &quot; flops around on dry land!&quot;);</a>
<a name="ln3428">            return false;</a>
<a name="ln3429">        }</a>
<a name="ln3430"> </a>
<a name="ln3431">        vector&lt;coord_def&gt; moves = adj_water;</a>
<a name="ln3432">        if (adj_water.empty() || coinflip())</a>
<a name="ln3433">            moves = adj_move;</a>
<a name="ln3434"> </a>
<a name="ln3435">        const coord_def newpos = moves.empty() ? mons-&gt;pos()</a>
<a name="ln3436">                                               : moves[random2(moves.size())];</a>
<a name="ln3437"> </a>
<a name="ln3438">        const monster* mon2 = monster_at(newpos);</a>
<a name="ln3439">        if (!mons-&gt;has_ench(ENCH_INSANE)</a>
<a name="ln3440">            &amp;&amp; (newpos == you.pos() &amp;&amp; mons-&gt;wont_attack()</a>
<a name="ln3441">                || (mon2 &amp;&amp; mons-&gt;wont_attack() == mon2-&gt;wont_attack())))</a>
<a name="ln3442">        {</a>
<a name="ln3443">            simple_monster_message(*mons, &quot; flops around on dry land!&quot;);</a>
<a name="ln3444">            return false;</a>
<a name="ln3445">        }</a>
<a name="ln3446"> </a>
<a name="ln3447">        return _do_move_monster(*mons, newpos - mons-&gt;pos());</a>
<a name="ln3448">    }</a>
<a name="ln3449"> </a>
<a name="ln3450">    // Let's not even bother with this if mmov is zero.</a>
<a name="ln3451">    if (mmov.origin())</a>
<a name="ln3452">        return false;</a>
<a name="ln3453"> </a>
<a name="ln3454">    for (int count_x = 0; count_x &lt; 3; count_x++)</a>
<a name="ln3455">        for (int count_y = 0; count_y &lt; 3; count_y++)</a>
<a name="ln3456">        {</a>
<a name="ln3457">            const int targ_x = mons-&gt;pos().x + count_x - 1;</a>
<a name="ln3458">            const int targ_y = mons-&gt;pos().y + count_y - 1;</a>
<a name="ln3459"> </a>
<a name="ln3460">            // Bounds check: don't consider moving out of grid!</a>
<a name="ln3461">            if (!in_bounds(targ_x, targ_y))</a>
<a name="ln3462">            {</a>
<a name="ln3463">                good_move[count_x][count_y] = false;</a>
<a name="ln3464">                continue;</a>
<a name="ln3465">            }</a>
<a name="ln3466">            dungeon_feature_type target_grid = grd[targ_x][targ_y];</a>
<a name="ln3467"> </a>
<a name="ln3468">            if (target_grid == DNGN_DEEP_WATER)</a>
<a name="ln3469">                deep_water_available = true;</a>
<a name="ln3470"> </a>
<a name="ln3471">            good_move[count_x][count_y] =</a>
<a name="ln3472">                mon_can_move_to_pos(mons, coord_def(count_x-1, count_y-1));</a>
<a name="ln3473">        }</a>
<a name="ln3474"> </a>
<a name="ln3475">    // Now we know where we _can_ move.</a>
<a name="ln3476"> </a>
<a name="ln3477">    const coord_def newpos = mons-&gt;pos() + mmov;</a>
<a name="ln3478">    // Water creatures have a preference for water they can hide in -- bwr</a>
<a name="ln3479">    // [ds] Weakened the powerful attraction to deep water if the monster</a>
<a name="ln3480">    // is in good health.</a>
<a name="ln3481">    if (habitat == HT_WATER</a>
<a name="ln3482">        &amp;&amp; deep_water_available</a>
<a name="ln3483">        &amp;&amp; grd(mons-&gt;pos()) != DNGN_DEEP_WATER</a>
<a name="ln3484">        &amp;&amp; grd(newpos) != DNGN_DEEP_WATER</a>
<a name="ln3485">        &amp;&amp; newpos != you.pos()</a>
<a name="ln3486">        &amp;&amp; (one_chance_in(3)</a>
<a name="ln3487">            || mons-&gt;hit_points &lt;= (mons-&gt;max_hit_points * 3) / 4))</a>
<a name="ln3488">    {</a>
<a name="ln3489">        int count = 0;</a>
<a name="ln3490"> </a>
<a name="ln3491">        for (int cx = 0; cx &lt; 3; cx++)</a>
<a name="ln3492">            for (int cy = 0; cy &lt; 3; cy++)</a>
<a name="ln3493">            {</a>
<a name="ln3494">                if (good_move[cx][cy]</a>
<a name="ln3495">                    &amp;&amp; grd[mons-&gt;pos().x + cx - 1][mons-&gt;pos().y + cy - 1]</a>
<a name="ln3496">                            == DNGN_DEEP_WATER)</a>
<a name="ln3497">                {</a>
<a name="ln3498">                    if (one_chance_in(++count))</a>
<a name="ln3499">                    {</a>
<a name="ln3500">                        mmov.x = cx - 1;</a>
<a name="ln3501">                        mmov.y = cy - 1;</a>
<a name="ln3502">                    }</a>
<a name="ln3503">                }</a>
<a name="ln3504">            }</a>
<a name="ln3505">    }</a>
<a name="ln3506"> </a>
<a name="ln3507">    // Now, if a monster can't move in its intended direction, try</a>
<a name="ln3508">    // either side. If they're both good, move in whichever dir</a>
<a name="ln3509">    // gets it closer (farther for fleeing monsters) to its target.</a>
<a name="ln3510">    // If neither does, do nothing.</a>
<a name="ln3511">    if (good_move[mmov.x + 1][mmov.y + 1] == false)</a>
<a name="ln3512">        _find_good_alternate_move(mons, good_move);</a>
<a name="ln3513"> </a>
<a name="ln3514">    // ------------------------------------------------------------------</a>
<a name="ln3515">    // If we haven't found a good move by this point, we're not going to.</a>
<a name="ln3516">    // ------------------------------------------------------------------</a>
<a name="ln3517"> </a>
<a name="ln3518">    if (mons-&gt;type == MONS_SPATIAL_MAELSTROM)</a>
<a name="ln3519">    {</a>
<a name="ln3520">        const dungeon_feature_type feat = grd(mons-&gt;pos() + mmov);</a>
<a name="ln3521">        if (!feat_is_permarock(feat) &amp;&amp; feat_is_solid(feat))</a>
<a name="ln3522">        {</a>
<a name="ln3523">            const coord_def target(mons-&gt;pos() + mmov);</a>
<a name="ln3524">            create_monster(</a>
<a name="ln3525">                    mgen_data(MONS_SPATIAL_VORTEX, SAME_ATTITUDE(mons), target)</a>
<a name="ln3526">                    .set_summoned(mons, 2, MON_SUMM_ANIMATE, GOD_LUGONU));</a>
<a name="ln3527">            destroy_wall(target);</a>
<a name="ln3528">        }</a>
<a name="ln3529">    }</a>
<a name="ln3530"> </a>
<a name="ln3531">    const bool burrows = mons_class_flag(mons-&gt;type, M_BURROWS);</a>
<a name="ln3532">    const bool flattens_trees = mons_flattens_trees(*mons);</a>
<a name="ln3533">    const bool digs = _mons_can_cast_dig(mons, false)</a>
<a name="ln3534">                      || _mons_can_zap_dig(mons);</a>
<a name="ln3535">    // Take care of Dissolution burrowing, lerny, etc</a>
<a name="ln3536">    if (burrows || flattens_trees || digs)</a>
<a name="ln3537">    {</a>
<a name="ln3538">        const dungeon_feature_type feat = grd(mons-&gt;pos() + mmov);</a>
<a name="ln3539">        if ((feat == DNGN_ROCK_WALL || feat == DNGN_CLEAR_ROCK_WALL)</a>
<a name="ln3540">                &amp;&amp; !burrows &amp;&amp; digs</a>
<a name="ln3541">            || feat == DNGN_GRATE &amp;&amp; digs)</a>
<a name="ln3542">        {</a>
<a name="ln3543">            bolt beem;</a>
<a name="ln3544">            if (_mons_can_cast_dig(mons, true))</a>
<a name="ln3545">            {</a>
<a name="ln3546">                setup_mons_cast(mons, beem, SPELL_DIG);</a>
<a name="ln3547">                beem.target = mons-&gt;pos() + mmov;</a>
<a name="ln3548">                mons_cast(mons, beem, SPELL_DIG,</a>
<a name="ln3549">                          mons-&gt;spell_slot_flags(SPELL_DIG));</a>
<a name="ln3550">            }</a>
<a name="ln3551">            else if (_mons_can_zap_dig(mons))</a>
<a name="ln3552">            {</a>
<a name="ln3553">                ASSERT(mons-&gt;mslot_item(MSLOT_WAND));</a>
<a name="ln3554">                item_def &amp;wand = *mons-&gt;mslot_item(MSLOT_WAND);</a>
<a name="ln3555">                setup_mons_cast(mons, beem, SPELL_DIG, true);</a>
<a name="ln3556">                beem.target = mons-&gt;pos() + mmov;</a>
<a name="ln3557">                _mons_fire_wand(*mons, wand, beem, you.can_see(*mons));</a>
<a name="ln3558"> </a>
<a name="ln3559">                //_setup_wand_beam(beem, *mons, wand);</a>
<a name="ln3560">                //_mons_fire_wand(*mons, wand, beem, you.can_see(*mons), false);</a>
<a name="ln3561">            }</a>
<a name="ln3562">            else</a>
<a name="ln3563">                simple_monster_message(*mons, &quot; falters for a moment.&quot;);</a>
<a name="ln3564">            mons-&gt;lose_energy(EUT_SPELL);</a>
<a name="ln3565">            return true;</a>
<a name="ln3566">        }</a>
<a name="ln3567">        else if ((((feat == DNGN_ROCK_WALL || feat == DNGN_CLEAR_ROCK_WALL)</a>
<a name="ln3568">                  &amp;&amp; burrows)</a>
<a name="ln3569">                  || (flattens_trees &amp;&amp; feat_is_tree(feat)))</a>
<a name="ln3570">                 &amp;&amp; good_move[mmov.x + 1][mmov.y + 1] == true)</a>
<a name="ln3571">        {</a>
<a name="ln3572">            const coord_def target(mons-&gt;pos() + mmov);</a>
<a name="ln3573">            destroy_wall(target);</a>
<a name="ln3574"> </a>
<a name="ln3575">            if (flattens_trees)</a>
<a name="ln3576">            {</a>
<a name="ln3577">                // Flattening trees has a movement cost to the monster</a>
<a name="ln3578">                // - 100% over and above its normal move cost.</a>
<a name="ln3579">                _swim_or_move_energy(*mons);</a>
<a name="ln3580">                if (you.see_cell(target))</a>
<a name="ln3581">                {</a>
<a name="ln3582">                    const bool actor_visible = you.can_see(*mons);</a>
<a name="ln3583">                    mprf(&quot;%s knocks down a tree!&quot;,</a>
<a name="ln3584">                         actor_visible?</a>
<a name="ln3585">                         mons-&gt;name(DESC_THE).c_str() : &quot;Something&quot;);</a>
<a name="ln3586">                    noisy(25, target);</a>
<a name="ln3587">                }</a>
<a name="ln3588">                else</a>
<a name="ln3589">                    noisy(25, target, &quot;You hear a crashing sound.&quot;);</a>
<a name="ln3590">            }</a>
<a name="ln3591">            // Dissolution dissolves walls.</a>
<a name="ln3592">            else if (player_can_hear(mons-&gt;pos() + mmov))</a>
<a name="ln3593">                mprf(MSGCH_SOUND, &quot;You hear a sizzling sound.&quot;);</a>
<a name="ln3594">        }</a>
<a name="ln3595">    }</a>
<a name="ln3596"> </a>
<a name="ln3597">    bool ret = false;</a>
<a name="ln3598">    if (good_move[mmov.x + 1][mmov.y + 1] &amp;&amp; !mmov.origin())</a>
<a name="ln3599">    {</a>
<a name="ln3600">        // Check for attacking player.</a>
<a name="ln3601">        if (mons-&gt;pos() + mmov == you.pos())</a>
<a name="ln3602">        {</a>
<a name="ln3603">            ret = fight_melee(mons, &amp;you);</a>
<a name="ln3604">            mmov.reset();</a>
<a name="ln3605">        }</a>
<a name="ln3606"> </a>
<a name="ln3607">        // If we're following the player through stairs, the only valid</a>
<a name="ln3608">        // movement is towards the player. -- bwr</a>
<a name="ln3609">        if (testbits(mons-&gt;flags, MF_TAKING_STAIRS))</a>
<a name="ln3610">        {</a>
<a name="ln3611">            if (!player_stair_delay())</a>
<a name="ln3612">            {</a>
<a name="ln3613">                mons-&gt;flags &amp;= ~MF_TAKING_STAIRS;</a>
<a name="ln3614"> </a>
<a name="ln3615">                dprf(&quot;BUG: %s was marked as follower when not following!&quot;,</a>
<a name="ln3616">                     mons-&gt;name(DESC_PLAIN).c_str());</a>
<a name="ln3617">            }</a>
<a name="ln3618">            else</a>
<a name="ln3619">            {</a>
<a name="ln3620">                ret    = true;</a>
<a name="ln3621">                mmov.reset();</a>
<a name="ln3622"> </a>
<a name="ln3623">                dprf(&quot;%s is skipping movement in order to follow.&quot;,</a>
<a name="ln3624">                     mons-&gt;name(DESC_THE).c_str());</a>
<a name="ln3625">            }</a>
<a name="ln3626">        }</a>
<a name="ln3627"> </a>
<a name="ln3628">        // Check for attacking another monster.</a>
<a name="ln3629">        if (monster* targ = monster_at(mons-&gt;pos() + mmov))</a>
<a name="ln3630">        {</a>
<a name="ln3631">            if ((mons_aligned(mons, targ) || targ-&gt;type == MONS_FOXFIRE)</a>
<a name="ln3632">                &amp;&amp; !(mons-&gt;has_ench(ENCH_INSANE)</a>
<a name="ln3633">                     || mons-&gt;confused()))</a>
<a name="ln3634">            {</a>
<a name="ln3635">                bool takes_time = !(mons-&gt;type == MONS_WANDERING_MUSHROOM</a>
<a name="ln3636">                                    &amp;&amp; targ-&gt;type == MONS_TOADSTOOL</a>
<a name="ln3637">                                    || mons-&gt;type == MONS_TOADSTOOL</a>
<a name="ln3638">                                       &amp;&amp; targ-&gt;type == MONS_WANDERING_MUSHROOM);</a>
<a name="ln3639">                ret = monster_swaps_places(mons, mmov, takes_time);</a>
<a name="ln3640">            }</a>
<a name="ln3641">            else</a>
<a name="ln3642">            {</a>
<a name="ln3643">                fight_melee(mons, targ);</a>
<a name="ln3644">                ret = true;</a>
<a name="ln3645">            }</a>
<a name="ln3646"> </a>
<a name="ln3647">            // If the monster swapped places, the work's already done.</a>
<a name="ln3648">            mmov.reset();</a>
<a name="ln3649">        }</a>
<a name="ln3650"> </a>
<a name="ln3651">        // The monster could die after a melee attack due to a mummy</a>
<a name="ln3652">        // death curse or something.</a>
<a name="ln3653">        if (!mons-&gt;alive())</a>
<a name="ln3654">            return true;</a>
<a name="ln3655"> </a>
<a name="ln3656">        if (mons_genus(mons-&gt;type) == MONS_EFREET</a>
<a name="ln3657">            || mons-&gt;type == MONS_FIRE_ELEMENTAL)</a>
<a name="ln3658">        {</a>
<a name="ln3659">            place_cloud(CLOUD_FIRE, mons-&gt;pos(), 2 + random2(4), mons);</a>
<a name="ln3660">        }</a>
<a name="ln3661"> </a>
<a name="ln3662">        if (mons-&gt;type == MONS_FOXFIRE)</a>
<a name="ln3663">            check_place_cloud(CLOUD_FLAME, mons-&gt;pos(), 2, mons);</a>
<a name="ln3664"> </a>
<a name="ln3665">        if (mons-&gt;type == MONS_CURSE_TOE)</a>
<a name="ln3666">            place_cloud(CLOUD_MIASMA, mons-&gt;pos(), 2 + random2(3), mons);</a>
<a name="ln3667">    }</a>
<a name="ln3668">    else</a>
<a name="ln3669">    {</a>
<a name="ln3670">        monster* targ = monster_at(mons-&gt;pos() + mmov);</a>
<a name="ln3671">        if (!mmov.origin() &amp;&amp; targ &amp;&amp; _may_cutdown(mons, targ))</a>
<a name="ln3672">        {</a>
<a name="ln3673">            fight_melee(mons, targ);</a>
<a name="ln3674">            ret = true;</a>
<a name="ln3675">        }</a>
<a name="ln3676"> </a>
<a name="ln3677">        mmov.reset();</a>
<a name="ln3678"> </a>
<a name="ln3679">        // Fleeing monsters that can't move will panic and possibly</a>
<a name="ln3680">        // turn to face their attacker.</a>
<a name="ln3681">        make_mons_stop_fleeing(mons);</a>
<a name="ln3682">    }</a>
<a name="ln3683"> </a>
<a name="ln3684">    // This handles the chance for the monster to hit itself.</a>
<a name="ln3685">    if (mmov.x || mmov.y || (mons-&gt;confused() &amp;&amp; one_chance_in(6)))</a>
<a name="ln3686">        return _do_move_monster(*mons, mmov);</a>
<a name="ln3687"> </a>
<a name="ln3688">    // Battlespheres need to preserve their tracking targets after each move</a>
<a name="ln3689">    if (mons_is_wandering(*mons)</a>
<a name="ln3690">        &amp;&amp; mons-&gt;type != MONS_BATTLESPHERE)</a>
<a name="ln3691">    {</a>
<a name="ln3692">        // trigger a re-evaluation of our wander target on our next move -cao</a>
<a name="ln3693">        mons-&gt;target = mons-&gt;pos();</a>
<a name="ln3694">        if (!mons-&gt;is_patrolling())</a>
<a name="ln3695">        {</a>
<a name="ln3696">            mons-&gt;travel_target = MTRAV_NONE;</a>
<a name="ln3697">            mons-&gt;travel_path.clear();</a>
<a name="ln3698">        }</a>
<a name="ln3699">        mons-&gt;firing_pos.reset();</a>
<a name="ln3700">    }</a>
<a name="ln3701"> </a>
<a name="ln3702">    return ret;</a>
<a name="ln3703">}</a>
<a name="ln3704"> </a>
<a name="ln3705">static void _mons_in_cloud(monster&amp; mons)</a>
<a name="ln3706">{</a>
<a name="ln3707">    // Submerging in water or lava saves from clouds.</a>
<a name="ln3708">    if (mons.submerged() &amp;&amp; env.grid(mons.pos()) != DNGN_FLOOR)</a>
<a name="ln3709">        return;</a>
<a name="ln3710"> </a>
<a name="ln3711">    actor_apply_cloud(&amp;mons);</a>
<a name="ln3712">}</a>

</code></pre>
<div class="balloon" rel="140"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v648/" target="_blank">V648</a> Priority of the '&&' operation is higher than that of the '||' operation.</p></div>
<div class="balloon" rel="618"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v648/" target="_blank">V648</a> Priority of the '&&' operation is higher than that of the '||' operation.</p></div>
<div class="balloon" rel="1389"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v678/" target="_blank">V678</a> An object is used as an argument to its own method. Consider checking the first actual argument of the 'banish' function.</p></div>
<div class="balloon" rel="1665"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v648/" target="_blank">V648</a> Priority of the '&&' operation is higher than that of the '||' operation.</p></div>
<div class="balloon" rel="1834"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v583/" target="_blank">V583</a> The '?:' operator, regardless of its conditional expression, always returns one and the same value.</p></div>
<div class="balloon" rel="2628"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v648/" target="_blank">V648</a> Priority of the '&&' operation is higher than that of the '||' operation.</p></div>
<div class="balloon" rel="2835"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v601/" target="_blank">V601</a> The result of '+' operator is implicitly cast to the bool type.</p></div>
<div class="balloon" rel="2842"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v601/" target="_blank">V601</a> The result of '+' operator is implicitly cast to the bool type.</p></div>

<link rel="stylesheet" href="highlight.css">
<script src="highlight.pack.js"></script>
<script src="highlightjs-line-numbers.js"></script>
<script>hljs.initHighlightingOnLoad();</script>
<script>hljs.initLineNumbersOnLoad();</script>
<script>
  $(document).ready(function() {
      $('.balloon').each(function () {
          var bl = $(this);
          var line = bl.attr('rel');
          var text = $('a[name="ln'+line+'"]').text();

          var space_count = 0;
          for(var i = 0; i<text.length; i++){
              var char = text[i];
              if((char !== ' ')&&(char !== '\t'))break;
              if(char === '\t')space_count++;
              space_count++;
          }

          bl.css('margin-left', space_count*8);
          $('a[name="ln'+line+'"]').after(bl);
      });

      window.location = window.location;
  });
</script>
</body>
</html>
