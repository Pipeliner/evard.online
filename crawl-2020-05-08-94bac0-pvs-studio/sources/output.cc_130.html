
<html>
<head>

  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
  <title>output.cc</title>

  <link rel="stylesheet" href="../style.css"/>
  <script src="../jquery-3.2.1.min.js"></script>
</head>
<body>

<pre><code class = "cpp">
<a name="ln1">/**</a>
<a name="ln2"> * @file</a>
<a name="ln3"> * @brief Functions used to print player related info.</a>
<a name="ln4">**/</a>
<a name="ln5"> </a>
<a name="ln6">#include &quot;AppHdr.h&quot;</a>
<a name="ln7"> </a>
<a name="ln8">#include &quot;output.h&quot;</a>
<a name="ln9"> </a>
<a name="ln10">#include &lt;cmath&gt;</a>
<a name="ln11">#include &lt;cstdlib&gt;</a>
<a name="ln12">#include &lt;sstream&gt;</a>
<a name="ln13"> </a>
<a name="ln14">#include &quot;ability.h&quot;</a>
<a name="ln15">#include &quot;art-enum.h&quot;</a>
<a name="ln16">#include &quot;areas.h&quot;</a>
<a name="ln17">#include &quot;branch.h&quot;</a>
<a name="ln18">#include &quot;colour.h&quot;</a>
<a name="ln19">#include &quot;describe.h&quot;</a>
<a name="ln20">#ifndef USE_TILE_LOCAL</a>
<a name="ln21">#endif</a>
<a name="ln22">#include &quot;english.h&quot;</a>
<a name="ln23">#include &quot;env.h&quot;</a>
<a name="ln24">#include &quot;files.h&quot;</a>
<a name="ln25">#include &quot;god-passive.h&quot;</a>
<a name="ln26">#include &quot;initfile.h&quot;</a>
<a name="ln27">#include &quot;item-name.h&quot;</a>
<a name="ln28">#include &quot;item-prop.h&quot;</a>
<a name="ln29">#include &quot;jobs.h&quot;</a>
<a name="ln30">#include &quot;lang-fake.h&quot;</a>
<a name="ln31">#include &quot;libutil.h&quot;</a>
<a name="ln32">#include &quot;menu.h&quot;</a>
<a name="ln33">#include &quot;message.h&quot;</a>
<a name="ln34">#include &quot;misc.h&quot;</a>
<a name="ln35">#include &quot;mutation.h&quot;</a>
<a name="ln36">#include &quot;notes.h&quot;</a>
<a name="ln37">#include &quot;player-equip.h&quot;</a>
<a name="ln38">#include &quot;player-stats.h&quot;</a>
<a name="ln39">#include &quot;prompt.h&quot;</a>
<a name="ln40">#include &quot;religion.h&quot;</a>
<a name="ln41">#include &quot;scroller.h&quot;</a>
<a name="ln42">#include &quot;showsymb.h&quot;</a>
<a name="ln43">#include &quot;skills.h&quot;</a>
<a name="ln44">#include &quot;state.h&quot;</a>
<a name="ln45">#include &quot;status.h&quot;</a>
<a name="ln46">#include &quot;stringutil.h&quot;</a>
<a name="ln47">#include &quot;throw.h&quot;</a>
<a name="ln48">#include &quot;tiles-build-specific.h&quot;</a>
<a name="ln49">#include &quot;transform.h&quot;</a>
<a name="ln50">#include &quot;viewchar.h&quot;</a>
<a name="ln51">#include &quot;view.h&quot;</a>
<a name="ln52">#include &quot;xom.h&quot;</a>
<a name="ln53"> </a>
<a name="ln54"> </a>
<a name="ln55">#ifdef USE_TILE_LOCAL</a>
<a name="ln56"> </a>
<a name="ln57">/*</a>
<a name="ln58"> * this glorious piece of code works by:</a>
<a name="ln59">    - overriding cgotoxy and cprintf</a>
<a name="ln60">    - mapping the x,y coordinate of each part of the HUD to a</a>
<a name="ln61">      value in the touchui_states enum and storing the current value</a>
<a name="ln62">    - using the current state to decide what and where to actually</a>
<a name="ln63">      render each part of the HUD</a>
<a name="ln64"> </a>
<a name="ln65">  12345678901234567890</a>
<a name="ln66">1 Nameaname</a>
<a name="ln67">2 TrDk(Mak)</a>
<a name="ln68">3  St Dx In</a>
<a name="ln69">4  nn nn nn</a>
<a name="ln70">5  AC SH EV</a>
<a name="ln71">6  nn nn nn</a>
<a name="ln72">7 W: foobar</a>
<a name="ln73">8 Q: 20 baz</a>
<a name="ln74">9 XXXXXXXXX      status lights</a>
<a name="ln75">.</a>
<a name="ln76">y  HPP MPP</a>
<a name="ln77"> */</a>
<a name="ln78">#include &lt;stdarg.h&gt;</a>
<a name="ln79">#define CGOTOXY _cgotoxy_touchui</a>
<a name="ln80">#define CPRINTF _cprintf_touchui</a>
<a name="ln81">#define NOWRAP_EOL_CPRINTF _nowrap_eol_cprintf_touchui</a>
<a name="ln82"> </a>
<a name="ln83">enum touchui_states</a>
<a name="ln84">{</a>
<a name="ln85">    TOUCH_S_INIT  = 0x0,</a>
<a name="ln86">    TOUCH_S_NULL  = 0x1,</a>
<a name="ln87">    TOUCH_T_MP    = 0x0104,</a>
<a name="ln88">    TOUCH_T_AC    = 0x0105,</a>
<a name="ln89">    TOUCH_T_EV    = 0x0106,</a>
<a name="ln90">    TOUCH_T_SH    = 0x0107,</a>
<a name="ln91">    TOUCH_T_STR   = 0x1305,</a>
<a name="ln92">    TOUCH_T_INT   = 0x1306,</a>
<a name="ln93">    TOUCH_T_DEX   = 0x1307,</a>
<a name="ln94">    TOUCH_V_PLACE = 0x1308,</a>
<a name="ln95">    TOUCH_T_HP    = 0x0103,</a>
<a name="ln96">    TOUCH_V_HP    = 0x0203, // dummy location</a>
<a name="ln97">    TOUCH_V_MP    = 0x0904,</a>
<a name="ln98">    TOUCH_V_AC    = 0x0505,</a>
<a name="ln99">    TOUCH_V_EV    = 0x0506,</a>
<a name="ln100">    TOUCH_V_SH    = 0x0507,</a>
<a name="ln101">    TOUCH_V_STR   = 0x1805,</a>
<a name="ln102">    TOUCH_V_INT   = 0x1806,</a>
<a name="ln103">    TOUCH_V_DEX   = 0x1807,</a>
<a name="ln104">    TOUCH_V_XL    = 0x0108,</a>
<a name="ln105">    TOUCH_T_WP    = 0x0109,</a>
<a name="ln106">    TOUCH_T_QV    = 0x010A,</a>
<a name="ln107">    TOUCH_V_WP    = 0x0209, // dummy</a>
<a name="ln108">    TOUCH_V_QV    = 0x020A, // dummy</a>
<a name="ln109">    TOUCH_V_TITLE = 0x0101,</a>
<a name="ln110">    TOUCH_V_TITL2 = 0x0102,</a>
<a name="ln111">    TOUCH_V_LIGHT = 0x010B,</a>
<a name="ln112">};</a>
<a name="ln113">touchui_states TOUCH_UI_STATE = TOUCH_S_INIT;</a>
<a name="ln114">static void _cgotoxy_touchui(int x, int y, GotoRegion region = GOTO_CRT)</a>
<a name="ln115">{</a>
<a name="ln116">//    printf(&quot;go to (%d,%d): &quot;,x,y);</a>
<a name="ln117">    if (tiles.is_using_small_layout())</a>
<a name="ln118">        TOUCH_UI_STATE = (touchui_states)((x&lt;&lt;8)+y);</a>
<a name="ln119">//    printf(&quot;[%x]: &quot;,TOUCH_UI_STATE);</a>
<a name="ln120">    switch (TOUCH_UI_STATE)</a>
<a name="ln121">    {</a>
<a name="ln122">        case TOUCH_V_HP:</a>
<a name="ln123">        case TOUCH_T_MP:</a>
<a name="ln124">        case TOUCH_V_TITLE:</a>
<a name="ln125">        case TOUCH_V_TITL2:</a>
<a name="ln126">        case TOUCH_V_XL:</a>
<a name="ln127">        case TOUCH_V_PLACE:</a>
<a name="ln128">        case TOUCH_S_NULL:</a>
<a name="ln129">            // no special behaviour for these</a>
<a name="ln130">            break;</a>
<a name="ln131">        case TOUCH_T_STR:</a>
<a name="ln132">            x = 1; y = 3;</a>
<a name="ln133">            break;</a>
<a name="ln134">        case TOUCH_T_INT:</a>
<a name="ln135">            x = 4; y = 3;</a>
<a name="ln136">            break;</a>
<a name="ln137">        case TOUCH_T_DEX:</a>
<a name="ln138">            x = 7; y = 3;</a>
<a name="ln139">            break;</a>
<a name="ln140">        case TOUCH_T_AC:</a>
<a name="ln141">            x = 1; y = 5;</a>
<a name="ln142">            break;</a>
<a name="ln143">        case TOUCH_T_EV:</a>
<a name="ln144">            x = 4; y = 5;</a>
<a name="ln145">            break;</a>
<a name="ln146">        case TOUCH_T_SH:</a>
<a name="ln147">            x = 7; y = 5;</a>
<a name="ln148">            break;</a>
<a name="ln149">        case TOUCH_V_STR:</a>
<a name="ln150">            x = 1; y = 4;</a>
<a name="ln151">            break;</a>
<a name="ln152">        case TOUCH_V_INT:</a>
<a name="ln153">            x = 4; y = 4;</a>
<a name="ln154">            break;</a>
<a name="ln155">        case TOUCH_V_DEX:</a>
<a name="ln156">            x = 7; y = 4;</a>
<a name="ln157">            break;</a>
<a name="ln158">        case TOUCH_V_AC:</a>
<a name="ln159">            x = 2; y = 6;</a>
<a name="ln160">            break;</a>
<a name="ln161">        case TOUCH_V_EV:</a>
<a name="ln162">            x = 5; y = 6;</a>
<a name="ln163">            break;</a>
<a name="ln164">        case TOUCH_V_SH:</a>
<a name="ln165">            x = 8; y = 6;</a>
<a name="ln166">            break;</a>
<a name="ln167">        case TOUCH_T_WP:</a>
<a name="ln168">            x = 1; y = 7;</a>
<a name="ln169">            break;</a>
<a name="ln170">        case TOUCH_T_QV:</a>
<a name="ln171">            x = 1; y = 8;</a>
<a name="ln172">            break;</a>
<a name="ln173">        case TOUCH_V_WP:</a>
<a name="ln174">            x = 4; y = 7;</a>
<a name="ln175">            break;</a>
<a name="ln176">        case TOUCH_V_QV:</a>
<a name="ln177">            x = 4; y = 8;</a>
<a name="ln178">            break;</a>
<a name="ln179">        case TOUCH_V_LIGHT:</a>
<a name="ln180">            x = 1; y = 9;</a>
<a name="ln181">            break;</a>
<a name="ln182">        case TOUCH_T_HP:</a>
<a name="ln183">            x = 2; y = crawl_view.hudsz.y;</a>
<a name="ln184">            break;</a>
<a name="ln185">        case TOUCH_V_MP:</a>
<a name="ln186">            x = 6; y = crawl_view.hudsz.y;</a>
<a name="ln187">            break;</a>
<a name="ln188">        default:</a>
<a name="ln189">            // reset state</a>
<a name="ln190">            TOUCH_UI_STATE = TOUCH_S_INIT;</a>
<a name="ln191">    }</a>
<a name="ln192">//    printf(&quot;(%d,%d): &quot;,x,y);</a>
<a name="ln193">    cgotoxy(x,y,region);</a>
<a name="ln194">}</a>
<a name="ln195"> </a>
<a name="ln196">static void _cprintf_touchui(const char *format, ...)</a>
<a name="ln197">{</a>
<a name="ln198">    va_list args;</a>
<a name="ln199">    string  buf;</a>
<a name="ln200">    va_start(args, format);</a>
<a name="ln201">    buf = vmake_stringf(format, args);</a>
<a name="ln202"> </a>
<a name="ln203">    switch (TOUCH_UI_STATE)</a>
<a name="ln204">    {</a>
<a name="ln205">        case TOUCH_T_MP:</a>
<a name="ln206">        case TOUCH_V_TITL2:</a>
<a name="ln207">        case TOUCH_V_XL:</a>
<a name="ln208">        case TOUCH_V_PLACE:</a>
<a name="ln209">        case TOUCH_S_NULL:</a>
<a name="ln210">            // don't draw these</a>
<a name="ln211">//            printf(&quot;X! %s\n&quot;,buf.c_str());</a>
<a name="ln212">            break;</a>
<a name="ln213">        case TOUCH_T_HP:</a>
<a name="ln214">            TOUCH_UI_STATE = TOUCH_V_HP;</a>
<a name="ln215">            break;</a>
<a name="ln216">        case TOUCH_V_TITLE:</a>
<a name="ln217">            cprintf(&quot;%s&quot;, you.your_name.c_str());</a>
<a name="ln218">            break;</a>
<a name="ln219">        case TOUCH_V_HP:</a>
<a name="ln220">        case TOUCH_V_MP:</a>
<a name="ln221">            // suppress everything after initial print; rjustify</a>
<a name="ln222">            cprintf(&quot;%3s&quot;, buf.c_str());</a>
<a name="ln223">            TOUCH_UI_STATE = TOUCH_S_NULL;</a>
<a name="ln224">            break;</a>
<a name="ln225">        case TOUCH_V_STR:</a>
<a name="ln226">        case TOUCH_V_INT:</a>
<a name="ln227">        case TOUCH_V_DEX:</a>
<a name="ln228">            // rjustify to 3 chars on these</a>
<a name="ln229">            cprintf(&quot;%3s&quot;, buf.c_str());</a>
<a name="ln230">            break;</a>
<a name="ln231">        case TOUCH_T_WP:</a>
<a name="ln232">            TOUCH_UI_STATE = TOUCH_V_WP;</a>
<a name="ln233">            cprintf(&quot;%s&quot;, buf.c_str());</a>
<a name="ln234">            break;</a>
<a name="ln235">        case TOUCH_T_QV:</a>
<a name="ln236">            TOUCH_UI_STATE = TOUCH_V_QV;</a>
<a name="ln237">            cprintf(&quot;%s&quot;, buf.c_str());</a>
<a name="ln238">            break;</a>
<a name="ln239">        case TOUCH_V_WP:</a>
<a name="ln240">        case TOUCH_V_QV:</a>
<a name="ln241">            // get rid of the hotkey; somewhat pointless in a touch-screen ui :)</a>
<a name="ln242">            cprintf(buf.substr(3,10).c_str());</a>
<a name="ln243">            break;</a>
<a name="ln244"> </a>
<a name="ln245">        default:</a>
<a name="ln246">//            printf(&quot;p: %s\n&quot;,buf.c_str());</a>
<a name="ln247">            cprintf(&quot;%s&quot;, buf.c_str());</a>
<a name="ln248">    }</a>
<a name="ln249">    va_end(args);</a>
<a name="ln250">}</a>
<a name="ln251"> </a>
<a name="ln252">static void _nowrap_eol_cprintf_touchui(const char *format, ...)</a>
<a name="ln253">{</a>
<a name="ln254">    va_list args;</a>
<a name="ln255">    string  buf;</a>
<a name="ln256">    va_start(args, format);</a>
<a name="ln257">    buf = vmake_stringf(format, args);</a>
<a name="ln258"> </a>
<a name="ln259">    // N.B. this should really be factored out and merged with the other switch-case above</a>
<a name="ln260">    switch (TOUCH_UI_STATE)</a>
<a name="ln261">    {</a>
<a name="ln262">        case TOUCH_S_NULL:</a>
<a name="ln263">            // don't print these</a>
<a name="ln264">            break;</a>
<a name="ln265">        case TOUCH_V_TITL2:</a>
<a name="ln266">            cprintf(&quot;%s%s %.4s&quot;, get_species_abbrev(you.species),</a>
<a name="ln267">                                 get_job_abbrev(you.char_class),</a>
<a name="ln268">                                 god_name(you.religion).c_str());</a>
<a name="ln269">            TOUCH_UI_STATE = TOUCH_S_NULL; // suppress whatever else it was going to print</a>
<a name="ln270">            break;</a>
<a name="ln271">        default:</a>
<a name="ln272">//            printf(&quot;q: %s\n&quot;,buf.c_str());</a>
<a name="ln273">            nowrap_eol_cprintf(&quot;%s&quot;, buf.c_str());</a>
<a name="ln274">    }</a>
<a name="ln275">    va_end(args);</a>
<a name="ln276">}</a>
<a name="ln277"> </a>
<a name="ln278">#else</a>
<a name="ln279">#define CGOTOXY cgotoxy</a>
<a name="ln280">#define CPRINTF cprintf</a>
<a name="ln281">#define NOWRAP_EOL_CPRINTF nowrap_eol_cprintf</a>
<a name="ln282">#endif</a>
<a name="ln283"> </a>
<a name="ln284">static string _god_powers();</a>
<a name="ln285">static string _god_asterisks();</a>
<a name="ln286">static int _god_status_colour(int default_colour);</a>
<a name="ln287"> </a>
<a name="ln288">// Colour for captions like 'Health:', 'Str:', etc.</a>
<a name="ln289">#define HUD_CAPTION_COLOUR Options.status_caption_colour</a>
<a name="ln290"> </a>
<a name="ln291">// Colour for values, which come after captions.</a>
<a name="ln292">static const auto HUD_VALUE_COLOUR = LIGHTGREY;</a>
<a name="ln293"> </a>
<a name="ln294">// ----------------------------------------------------------------------</a>
<a name="ln295">// colour_bar</a>
<a name="ln296">// ----------------------------------------------------------------------</a>
<a name="ln297"> </a>
<a name="ln298">class colour_bar</a>
<a name="ln299">{</a>
<a name="ln300">    typedef unsigned short colour_t;</a>
<a name="ln301">public:</a>
<a name="ln302">    colour_t m_default;</a>
<a name="ln303">    colour_t m_change_pos;</a>
<a name="ln304">    colour_t m_change_neg;</a>
<a name="ln305">    colour_t m_empty;</a>
<a name="ln306">    int horiz_bar_width;</a>
<a name="ln307"> </a>
<a name="ln308">    colour_bar(colour_t default_colour,</a>
<a name="ln309">               colour_t change_pos,</a>
<a name="ln310">               colour_t change_neg,</a>
<a name="ln311">               colour_t empty)</a>
<a name="ln312">        : m_default(default_colour), m_change_pos(change_pos),</a>
<a name="ln313">          m_change_neg(change_neg), m_empty(empty),</a>
<a name="ln314">          horiz_bar_width(-1),</a>
<a name="ln315">          m_old_disp(-1),</a>
<a name="ln316">          m_request_redraw_after(0)</a>
<a name="ln317">    {</a>
<a name="ln318">        // m_old_disp &lt; 0 means it's invalid and needs to be initialised.</a>
<a name="ln319">    }</a>
<a name="ln320"> </a>
<a name="ln321">    bool wants_redraw() const</a>
<a name="ln322">    {</a>
<a name="ln323">        return m_request_redraw_after</a>
<a name="ln324">               &amp;&amp; you.num_turns &gt;= m_request_redraw_after;</a>
<a name="ln325">    }</a>
<a name="ln326"> </a>
<a name="ln327">    void draw(int ox, int oy, int val, int max_val, int sub_val = 0)</a>
<a name="ln328">    {</a>
<a name="ln329">        ASSERT(val &lt;= max_val);</a>
<a name="ln330">        if (max_val &lt;= 0)</a>
<a name="ln331">        {</a>
<a name="ln332">            m_old_disp = -1;</a>
<a name="ln333">            return;</a>
<a name="ln334">        }</a>
<a name="ln335">        const int width = (horiz_bar_width != -1) ?</a>
<a name="ln336">                                  horiz_bar_width :</a>
<a name="ln337">                                  crawl_view.hudsz.x - (ox - 1);</a>
<a name="ln338">        const int sub_disp = (width * val / max_val);</a>
<a name="ln339">        int disp  = width * max(0, val - sub_val) / max_val;</a>
<a name="ln340">        const int old_disp = (m_old_disp &lt; 0) ? sub_disp : m_old_disp;</a>
<a name="ln341">        m_old_disp = sub_disp;</a>
<a name="ln342"> </a>
<a name="ln343">        // Always show at least one sliver of the sub-bar, if it exists</a>
<a name="ln344">        if (sub_val)</a>
<a name="ln345">            disp = max(0, min(sub_disp - 1, disp));</a>
<a name="ln346"> </a>
<a name="ln347">        CGOTOXY(ox, oy, GOTO_STAT);</a>
<a name="ln348"> </a>
<a name="ln349">        textcolour(BLACK);</a>
<a name="ln350">        for (int cx = 0; cx &lt; width; cx++)</a>
<a name="ln351">        {</a>
<a name="ln352">#ifdef USE_TILE_LOCAL</a>
<a name="ln353">            // Maybe this should use textbackground too?</a>
<a name="ln354">            textcolour(BLACK + m_empty * 16);</a>
<a name="ln355"> </a>
<a name="ln356">            if (cx &lt; disp)</a>
<a name="ln357">                textcolour(BLACK + m_default * 16);</a>
<a name="ln358">            else if (cx &lt; sub_disp)</a>
<a name="ln359">                textcolour(BLACK + YELLOW * 16);</a>
<a name="ln360">            else if (old_disp &gt;= sub_disp &amp;&amp; cx &lt; old_disp)</a>
<a name="ln361">                textcolour(BLACK + m_change_neg * 16);</a>
<a name="ln362">            putwch(' ');</a>
<a name="ln363">#else</a>
<a name="ln364">            if (cx &lt; disp &amp;&amp; cx &lt; old_disp)</a>
<a name="ln365">            {</a>
<a name="ln366">                textcolour(m_default);</a>
<a name="ln367">                putwch('=');</a>
<a name="ln368">            }</a>
<a name="ln369">            else if (cx &lt; disp)</a>
<a name="ln370">            {</a>
<a name="ln371">                textcolour(m_change_pos);</a>
<a name="ln372">                putwch('=');</a>
<a name="ln373">            }</a>
<a name="ln374">            else if (cx &lt; sub_disp)</a>
<a name="ln375">            {</a>
<a name="ln376">                textcolour(YELLOW);</a>
<a name="ln377">                putwch('=');</a>
<a name="ln378">            }</a>
<a name="ln379">            else if (cx &lt; old_disp)</a>
<a name="ln380">            {</a>
<a name="ln381">                textcolour(m_change_neg);</a>
<a name="ln382">                putwch('-');</a>
<a name="ln383">            }</a>
<a name="ln384">            else</a>
<a name="ln385">            {</a>
<a name="ln386">                textcolour(m_empty);</a>
<a name="ln387">                putwch('-');</a>
<a name="ln388">            }</a>
<a name="ln389">#endif</a>
<a name="ln390"> </a>
<a name="ln391">            // If some change colour was rendered, redraw in a few</a>
<a name="ln392">            // turns to clear it out.</a>
<a name="ln393">            if (old_disp != disp)</a>
<a name="ln394">                m_request_redraw_after = you.num_turns + 4;</a>
<a name="ln395">            else</a>
<a name="ln396">                m_request_redraw_after = 0;</a>
<a name="ln397">        }</a>
<a name="ln398"> </a>
<a name="ln399">        textcolour(LIGHTGREY);</a>
<a name="ln400">        textbackground(BLACK);</a>
<a name="ln401">    }</a>
<a name="ln402"> </a>
<a name="ln403">    void vdraw(int ox, int oy, int val, int max_val)</a>
<a name="ln404">    {</a>
<a name="ln405">        // ox is width from l/h edge; oy is height from top</a>
<a name="ln406">        // bars are 3chars wide and render down to hudsz.y-1</a>
<a name="ln407">        const int bar_width = 3;</a>
<a name="ln408">        const int obase     = crawl_view.hudsz.y-1;</a>
<a name="ln409"> </a>
<a name="ln410">        ASSERT(val &lt;= max_val);</a>
<a name="ln411">        if (max_val &lt;= 0)</a>
<a name="ln412">        {</a>
<a name="ln413">            m_old_disp = -1;</a>
<a name="ln414">            return;</a>
<a name="ln415">        }</a>
<a name="ln416"> </a>
<a name="ln417">        const int height   = bar_width * (obase-oy+1);</a>
<a name="ln418">        const int disp     = height * val / max_val;</a>
<a name="ln419">        const int old_disp = (m_old_disp &lt; 0) ? disp : m_old_disp;</a>
<a name="ln420"> </a>
<a name="ln421">        CGOTOXY(ox, obase, GOTO_STAT);</a>
<a name="ln422"> </a>
<a name="ln423">        textcolour(WHITE);</a>
<a name="ln424">        for (int cx = 0; cx &lt; height; cx++)</a>
<a name="ln425">        {</a>
<a name="ln426">            // Maybe this should use textbackground too?</a>
<a name="ln427">            textcolour(BLACK + m_empty * 16);</a>
<a name="ln428"> </a>
<a name="ln429">            if (cx &lt; disp)</a>
<a name="ln430">                textcolour(BLACK + m_default * 16);</a>
<a name="ln431">            else if (old_disp &gt; disp &amp;&amp; cx &lt; old_disp)</a>
<a name="ln432">                textcolour(BLACK + m_change_neg * 16);</a>
<a name="ln433">            putwch(' ');</a>
<a name="ln434"> </a>
<a name="ln435">            // move up a line if we've drawn this bit of the bar</a>
<a name="ln436">            if ((cx+1) % bar_width == 0)</a>
<a name="ln437">                CGOTOXY(ox, obase-cx/bar_width, GOTO_STAT);</a>
<a name="ln438"> </a>
<a name="ln439">            // If some change colour was rendered, redraw in a few</a>
<a name="ln440">            // turns to clear it out.</a>
<a name="ln441">            if (old_disp != disp)</a>
<a name="ln442">                m_request_redraw_after = you.num_turns + 4;</a>
<a name="ln443">            else</a>
<a name="ln444">                m_request_redraw_after = 0;</a>
<a name="ln445">        }</a>
<a name="ln446"> </a>
<a name="ln447">        textcolour(LIGHTGREY);</a>
<a name="ln448">        textbackground(BLACK);</a>
<a name="ln449">    }</a>
<a name="ln450"> </a>
<a name="ln451">    void reset()</a>
<a name="ln452">    {</a>
<a name="ln453">        m_old_disp = -1;</a>
<a name="ln454">        m_request_redraw_after = 0;</a>
<a name="ln455">    }</a>
<a name="ln456"> </a>
<a name="ln457"> private:</a>
<a name="ln458">    int m_old_disp;</a>
<a name="ln459">    int m_request_redraw_after; // force a redraw at this turn count</a>
<a name="ln460">};</a>
<a name="ln461"> </a>
<a name="ln462">static colour_bar HP_Bar(LIGHTGREEN, GREEN, RED, DARKGREY);</a>
<a name="ln463"> </a>
<a name="ln464">#ifdef USE_TILE_LOCAL</a>
<a name="ln465">static colour_bar MP_Bar(BLUE, BLUE, LIGHTBLUE, DARKGREY);</a>
<a name="ln466">#else</a>
<a name="ln467">static colour_bar MP_Bar(LIGHTBLUE, BLUE, MAGENTA, DARKGREY);</a>
<a name="ln468">#endif</a>
<a name="ln469"> </a>
<a name="ln470">#ifdef USE_TILE_LOCAL</a>
<a name="ln471">static colour_bar Noise_Bar(WHITE, LIGHTGREY, LIGHTGREY, DARKGREY);</a>
<a name="ln472">#else</a>
<a name="ln473">static colour_bar Noise_Bar(LIGHTGREY, LIGHTGREY, MAGENTA, DARKGREY);</a>
<a name="ln474">#endif</a>
<a name="ln475"> </a>
<a name="ln476">void reset_hud()</a>
<a name="ln477">{</a>
<a name="ln478">    HP_Bar.reset();</a>
<a name="ln479">    MP_Bar.reset();</a>
<a name="ln480">    Noise_Bar.reset();</a>
<a name="ln481">}</a>
<a name="ln482"> </a>
<a name="ln483">// ----------------------------------------------------------------------</a>
<a name="ln484">// Status display</a>
<a name="ln485">// ----------------------------------------------------------------------</a>
<a name="ln486"> </a>
<a name="ln487">static bool _boosted_hp()</a>
<a name="ln488">{</a>
<a name="ln489">    return you.duration[DUR_DIVINE_VIGOUR]</a>
<a name="ln490">           || you.berserk();</a>
<a name="ln491">}</a>
<a name="ln492"> </a>
<a name="ln493">static bool _boosted_mp()</a>
<a name="ln494">{</a>
<a name="ln495">    return you.duration[DUR_DIVINE_VIGOUR];</a>
<a name="ln496">}</a>
<a name="ln497"> </a>
<a name="ln498">static bool _boosted_ac()</a>
<a name="ln499">{</a>
<a name="ln500">    return you.armour_class() &gt; you.base_ac(1);</a>
<a name="ln501">}</a>
<a name="ln502"> </a>
<a name="ln503">static bool _boosted_ev()</a>
<a name="ln504">{</a>
<a name="ln505">    return you.duration[DUR_AGILITY] || acrobat_boost_active();</a>
<a name="ln506">}</a>
<a name="ln507"> </a>
<a name="ln508">static bool _boosted_sh()</a>
<a name="ln509">{</a>
<a name="ln510">    return you.duration[DUR_DIVINE_SHIELD]</a>
<a name="ln511">           || qazlal_sh_boost() &gt; 0;</a>
<a name="ln512">}</a>
<a name="ln513"> </a>
<a name="ln514">#ifdef DGL_SIMPLE_MESSAGING</a>
<a name="ln515">void update_message_status()</a>
<a name="ln516">{</a>
<a name="ln517">    if (!SysEnv.have_messages)</a>
<a name="ln518">        return;</a>
<a name="ln519"> </a>
<a name="ln520">    static const char * const msg = &quot;(Hit _)&quot;;</a>
<a name="ln521"> </a>
<a name="ln522">    textcolour(LIGHTBLUE);</a>
<a name="ln523"> </a>
<a name="ln524">    CGOTOXY(crawl_view.hudsz.x - strwidth(msg) + 1, 1, GOTO_STAT);</a>
<a name="ln525">    CPRINTF(msg);</a>
<a name="ln526"> </a>
<a name="ln527">    textcolour(LIGHTGREY);</a>
<a name="ln528">}</a>
<a name="ln529">#endif</a>
<a name="ln530"> </a>
<a name="ln531">void update_turn_count()</a>
<a name="ln532">{</a>
<a name="ln533">    if (crawl_state.game_is_arena())</a>
<a name="ln534">        return;</a>
<a name="ln535"> </a>
<a name="ln536">    // Don't update turn counter when running/resting/traveling to</a>
<a name="ln537">    // prevent pointless screen updates.</a>
<a name="ln538">    if (mouse_control::current_mode() == MOUSE_MODE_NORMAL</a>
<a name="ln539">        &amp;&amp; (you.running &gt; 0 || you.running &lt; 0 &amp;&amp; Options.travel_delay == -1))</a>
<a name="ln540">    {</a>
<a name="ln541">        return;</a>
<a name="ln542">    }</a>
<a name="ln543"> </a>
<a name="ln544">    CGOTOXY(19+6, 9, GOTO_STAT);</a>
<a name="ln545"> </a>
<a name="ln546">    // Show the turn count starting from 1. You can still quit on turn 0.</a>
<a name="ln547">    textcolour(HUD_VALUE_COLOUR);</a>
<a name="ln548">    if (Options.show_game_time)</a>
<a name="ln549">        CPRINTF(&quot;%.1f&quot;, you.elapsed_time / 10.0);</a>
<a name="ln550">    else</a>
<a name="ln551">        CPRINTF(&quot;%d&quot;, you.num_turns);</a>
<a name="ln552"> </a>
<a name="ln553">    CPRINTF(&quot; (%.1f)%s&quot;,</a>
<a name="ln554">            (you.elapsed_time - you.elapsed_time_at_last_input) / 10.0,</a>
<a name="ln555">            // extra spaces to erase excess if previous output was longer</a>
<a name="ln556">            &quot;    &quot;);</a>
<a name="ln557">    textcolour(LIGHTGREY);</a>
<a name="ln558">}</a>
<a name="ln559"> </a>
<a name="ln560">static int _count_digits(int val)</a>
<a name="ln561">{</a>
<a name="ln562">    if (val &gt; 999)</a>
<a name="ln563">        return 4;</a>
<a name="ln564">    else if (val &gt; 99)</a>
<a name="ln565">        return 3;</a>
<a name="ln566">    else if (val &gt; 9)</a>
<a name="ln567">        return 2;</a>
<a name="ln568">    return 1;</a>
<a name="ln569">}</a>
<a name="ln570"> </a>
<a name="ln571">static const equipment_type e_order[] =</a>
<a name="ln572">{</a>
<a name="ln573">    EQ_WEAPON, EQ_SHIELD, EQ_BODY_ARMOUR, EQ_HELMET, EQ_CLOAK,</a>
<a name="ln574">    EQ_GLOVES, EQ_BOOTS, EQ_AMULET, EQ_LEFT_RING, EQ_RIGHT_RING,</a>
<a name="ln575">    EQ_RING_ONE, EQ_RING_TWO, EQ_RING_THREE, EQ_RING_FOUR,</a>
<a name="ln576">    EQ_RING_FIVE, EQ_RING_SIX, EQ_RING_SEVEN, EQ_RING_EIGHT,</a>
<a name="ln577">    EQ_RING_AMULET,</a>
<a name="ln578">};</a>
<a name="ln579"> </a>
<a name="ln580">static void _print_stats_equip(int x, int y)</a>
<a name="ln581">{</a>
<a name="ln582">    CGOTOXY(x, y, GOTO_STAT);</a>
<a name="ln583">    textcolour(HUD_CAPTION_COLOUR);</a>
<a name="ln584">    cprintf((you.species == SP_OCTOPODE) ? &quot;Eq: &quot; : &quot;Equip: &quot;);</a>
<a name="ln585">    textcolour(LIGHTGREY);</a>
<a name="ln586">    for (equipment_type eqslot : e_order)</a>
<a name="ln587">    {</a>
<a name="ln588">        if (you_can_wear(eqslot))</a>
<a name="ln589">        {</a>
<a name="ln590">            if (you.slot_item(eqslot))</a>
<a name="ln591">            {</a>
<a name="ln592">                cglyph_t g = get_item_glyph(*(you.slot_item(eqslot)));</a>
<a name="ln593">                g.col = element_colour(g.col, !Options.animate_equip_bar);</a>
<a name="ln594">                formatted_string::parse_string(glyph_to_tagstr(g)).display();</a>
<a name="ln595">            }</a>
<a name="ln596">            else if (!you_can_wear(eqslot, true))</a>
<a name="ln597">                cprintf(&quot; &quot;);</a>
<a name="ln598">            else</a>
<a name="ln599">                cprintf(&quot;.&quot;);</a>
<a name="ln600">        }</a>
<a name="ln601">    }</a>
<a name="ln602">}</a>
<a name="ln603"> </a>
<a name="ln604">/*</a>
<a name="ln605"> * Print the noise bar to the HUD with appropriate coloring.</a>
<a name="ln606"> * if in wizmode, also print the numeric noise value.</a>
<a name="ln607"> */</a>
<a name="ln608">static void _print_stats_noise(int x, int y)</a>
<a name="ln609">{</a>
<a name="ln610">    bool silence = silenced(you.pos());</a>
<a name="ln611">    int level = silence ? 0 : you.get_noise_perception(true);</a>
<a name="ln612">    CGOTOXY(x, y, GOTO_STAT);</a>
<a name="ln613">    textcolour(HUD_CAPTION_COLOUR);</a>
<a name="ln614">    cprintf(&quot;Noise: &quot;);</a>
<a name="ln615">    colour_t noisecolour;</a>
<a name="ln616"> </a>
<a name="ln617">    // This is calibrated roughly so that in an open-ish area:</a>
<a name="ln618">    //   LIGHTGREY = not very likely to carry outside of your los</a>
<a name="ln619">    //               (though it is possible depending on terrain).</a>
<a name="ln620">    //   YELLOW = likely to carry outside of your los, up to double.</a>
<a name="ln621">    //   RED = likely to carry at least 16 spaces, up to much further.</a>
<a name="ln622">    //   LIGHTMAGENTA = really f*cking loud. (Gong, etc.)</a>
<a name="ln623">    // In more enclosed areas, these values will be attenuated,</a>
<a name="ln624">    // and this isn't represented.</a>
<a name="ln625">    // See player::get_noise_perception for the mapping from internal noise</a>
<a name="ln626">    // values to this 0-1000 scale.</a>
<a name="ln627">    // NOTE: This color scheme is duplicated in player.js.</a>
<a name="ln628">    if (level &lt;= 333)</a>
<a name="ln629">        noisecolour = LIGHTGREY;</a>
<a name="ln630">    else if (level &lt;= 666)</a>
<a name="ln631">        noisecolour = YELLOW;</a>
<a name="ln632">    else if (level &lt; 1000)</a>
<a name="ln633">        noisecolour = RED;</a>
<a name="ln634">    else</a>
<a name="ln635">        noisecolour = LIGHTMAGENTA;</a>
<a name="ln636"> </a>
<a name="ln637">    int bar_position;</a>
<a name="ln638">    if (you.wizard &amp;&amp; !silence)</a>
<a name="ln639">    {</a>
<a name="ln640">        Noise_Bar.horiz_bar_width = 6;</a>
<a name="ln641">        bar_position = 10;</a>
<a name="ln642"> </a>
<a name="ln643">        // numeric noise level, basically the internal value used by noise</a>
<a name="ln644">        // propagation (see shout.cc:noisy). The exact value is too hard to</a>
<a name="ln645">        // interpret to show outside of wizmode, because noise propagation is</a>
<a name="ln646">        // very complicated.</a>
<a name="ln647">        CGOTOXY(x + bar_position - 3, y, GOTO_STAT);</a>
<a name="ln648">        textcolour(noisecolour);</a>
<a name="ln649">        CPRINTF(&quot;%2d &quot;, you.get_noise_perception(false));</a>
<a name="ln650">    }</a>
<a name="ln651">    else</a>
<a name="ln652">    {</a>
<a name="ln653">        Noise_Bar.horiz_bar_width = 9;</a>
<a name="ln654">        bar_position = 7;</a>
<a name="ln655">    }</a>
<a name="ln656"> </a>
<a name="ln657">    if (silence)</a>
<a name="ln658">    {</a>
<a name="ln659">        CGOTOXY(x + bar_position, y, GOTO_STAT);</a>
<a name="ln660">        textcolour(LIGHTMAGENTA);</a>
<a name="ln661"> </a>
<a name="ln662">        // This needs to be one extra wide in case silence happens</a>
<a name="ln663">        // immediately after super-loud (magenta) noise</a>
<a name="ln664">        CPRINTF(&quot;Silenced  &quot;);</a>
<a name="ln665">        Noise_Bar.reset(); // so it doesn't display a change bar after silence ends</a>
<a name="ln666">    }</a>
<a name="ln667">    else</a>
<a name="ln668">    {</a>
<a name="ln669">        if (level == 1000)</a>
<a name="ln670">        {</a>
<a name="ln671">            // the bar goes up to 11 for extra loud sounds! (Well, really 10.)</a>
<a name="ln672">            Noise_Bar.horiz_bar_width += 1;</a>
<a name="ln673">        }</a>
<a name="ln674">        else</a>
<a name="ln675">        {</a>
<a name="ln676">            CGOTOXY(x + 16, y, GOTO_STAT);</a>
<a name="ln677">            CPRINTF(&quot; &quot;); // clean up after the extra wide bar</a>
<a name="ln678">        }</a>
<a name="ln679">#ifndef USE_TILE_LOCAL</a>
<a name="ln680">        // use the previous color for negative change in console; there's a</a>
<a name="ln681">        // visual difference in bar width. Negative change doesn't get shown</a>
<a name="ln682">        // in local tiles.</a>
<a name="ln683">        Noise_Bar.m_change_neg = Noise_Bar.m_default;</a>
<a name="ln684">#endif</a>
<a name="ln685">        Noise_Bar.m_default = noisecolour;</a>
<a name="ln686">        Noise_Bar.m_change_pos = noisecolour;</a>
<a name="ln687">        Noise_Bar.draw(x + bar_position, y,</a>
<a name="ln688">                       div_round_up((level * Noise_Bar.horiz_bar_width), 1000),</a>
<a name="ln689">                       Noise_Bar.horiz_bar_width);</a>
<a name="ln690">    }</a>
<a name="ln691">}</a>
<a name="ln692"> </a>
<a name="ln693">static void _print_stats_gold(int x, int y)</a>
<a name="ln694">{</a>
<a name="ln695">    CGOTOXY(x, y, GOTO_STAT);</a>
<a name="ln696">    textcolour(HUD_CAPTION_COLOUR);</a>
<a name="ln697">    CPRINTF(&quot;Gold:&quot;);</a>
<a name="ln698">    CGOTOXY(x+6, y, GOTO_STAT);</a>
<a name="ln699">    if (you.duration[DUR_GOZAG_GOLD_AURA])</a>
<a name="ln700">        textcolour(LIGHTBLUE);</a>
<a name="ln701">    else</a>
<a name="ln702">        textcolour(HUD_VALUE_COLOUR);</a>
<a name="ln703">    CPRINTF(&quot;%-6d&quot;, you.gold);</a>
<a name="ln704">}</a>
<a name="ln705"> </a>
<a name="ln706">static void _print_stats_mp(int x, int y)</a>
<a name="ln707">{</a>
<a name="ln708">    // Calculate colour</a>
<a name="ln709">    short mp_colour = HUD_VALUE_COLOUR;</a>
<a name="ln710"> </a>
<a name="ln711">    const bool boosted = _boosted_mp();</a>
<a name="ln712"> </a>
<a name="ln713">    if (boosted)</a>
<a name="ln714">        mp_colour = LIGHTBLUE;</a>
<a name="ln715">    else</a>
<a name="ln716">    {</a>
<a name="ln717">        int mp_percent = (you.max_magic_points == 0</a>
<a name="ln718">                          ? 100</a>
<a name="ln719">                          : (you.magic_points * 100) / you.max_magic_points);</a>
<a name="ln720"> </a>
<a name="ln721">        for (const auto &amp;entry : Options.mp_colour)</a>
<a name="ln722">            if (mp_percent &lt;= entry.first)</a>
<a name="ln723">                mp_colour = entry.second;</a>
<a name="ln724">    }</a>
<a name="ln725"> </a>
<a name="ln726">    CGOTOXY(x, y, GOTO_STAT);</a>
<a name="ln727">    textcolour(HUD_CAPTION_COLOUR);</a>
<a name="ln728">    CPRINTF(player_rotted() ? &quot;MP: &quot; : &quot;Magic:  &quot;);</a>
<a name="ln729">    textcolour(mp_colour);</a>
<a name="ln730">    CPRINTF(&quot;%d&quot;, you.magic_points);</a>
<a name="ln731">    if (!boosted)</a>
<a name="ln732">        textcolour(HUD_VALUE_COLOUR);</a>
<a name="ln733">    CPRINTF(&quot;/%d&quot;, you.max_magic_points);</a>
<a name="ln734"> </a>
<a name="ln735">    int col = _count_digits(you.magic_points)</a>
<a name="ln736">              + _count_digits(you.max_magic_points) + 1;</a>
<a name="ln737"> </a>
<a name="ln738">    int real_mp = get_real_mp(false);</a>
<a name="ln739">    if (you.species == SP_DEEP_DWARF</a>
<a name="ln740">        &amp;&amp; real_mp != you.max_magic_points)</a>
<a name="ln741">    {</a>
<a name="ln742">        CPRINTF(&quot; (%d)&quot;, real_mp);</a>
<a name="ln743">        col += _count_digits(real_mp) + 3;</a>
<a name="ln744">    }</a>
<a name="ln745"> </a>
<a name="ln746">    if (boosted)</a>
<a name="ln747">        textcolour(HUD_VALUE_COLOUR);</a>
<a name="ln748"> </a>
<a name="ln749">    for (int i = 11-col; i &gt; 0; i--)</a>
<a name="ln750">        CPRINTF(&quot; &quot;);</a>
<a name="ln751"> </a>
<a name="ln752">#ifdef TOUCH_UI</a>
<a name="ln753">    if (tiles.is_using_small_layout())</a>
<a name="ln754">        MP_Bar.vdraw(6, 10, you.magic_points, you.max_magic_points);</a>
<a name="ln755">    else</a>
<a name="ln756">#endif</a>
<a name="ln757">    MP_Bar.draw(19, y, you.magic_points, you.max_magic_points);</a>
<a name="ln758">}</a>
<a name="ln759"> </a>
<a name="ln760">static void _print_stats_hp(int x, int y)</a>
<a name="ln761">{</a>
<a name="ln762">    int max_max_hp = get_real_hp(true, false);</a>
<a name="ln763"> </a>
<a name="ln764">    // Calculate colour</a>
<a name="ln765">    short hp_colour = HUD_VALUE_COLOUR;</a>
<a name="ln766"> </a>
<a name="ln767">    const bool boosted = _boosted_hp();</a>
<a name="ln768"> </a>
<a name="ln769">    if (boosted)</a>
<a name="ln770">        hp_colour = LIGHTBLUE;</a>
<a name="ln771">    else</a>
<a name="ln772">    {</a>
<a name="ln773">        const int hp_percent =</a>
<a name="ln774">            (you.hp * 100) / get_real_hp(true, true);</a>
<a name="ln775"> </a>
<a name="ln776">        for (const auto &amp;entry : Options.hp_colour)</a>
<a name="ln777">            if (hp_percent &lt;= entry.first)</a>
<a name="ln778">                hp_colour = entry.second;</a>
<a name="ln779">    }</a>
<a name="ln780"> </a>
<a name="ln781">    // 01234567890123456789</a>
<a name="ln782">    // Health: xxx/yyy (zzz)</a>
<a name="ln783">    CGOTOXY(x, y, GOTO_STAT);</a>
<a name="ln784">    textcolour(HUD_CAPTION_COLOUR);</a>
<a name="ln785">    CPRINTF(player_rotted() ? &quot;HP: &quot; : &quot;Health: &quot;);</a>
<a name="ln786">    textcolour(hp_colour);</a>
<a name="ln787">    CPRINTF(&quot;%d&quot;, you.hp);</a>
<a name="ln788">    if (!boosted)</a>
<a name="ln789">        textcolour(HUD_VALUE_COLOUR);</a>
<a name="ln790">    CPRINTF(&quot;/%d&quot;, you.hp_max);</a>
<a name="ln791">    if (max_max_hp != you.hp_max)</a>
<a name="ln792">        CPRINTF(&quot; (%d)&quot;, max_max_hp);</a>
<a name="ln793">    if (boosted)</a>
<a name="ln794">        textcolour(HUD_VALUE_COLOUR);</a>
<a name="ln795"> </a>
<a name="ln796">    int col = wherex() - crawl_view.hudp.x;</a>
<a name="ln797">    for (int i = 18-col; i &gt; 0; i--)</a>
<a name="ln798">        CPRINTF(&quot; &quot;);</a>
<a name="ln799"> </a>
<a name="ln800">#ifdef USE_TILE_LOCAL</a>
<a name="ln801">    if (tiles.is_using_small_layout())</a>
<a name="ln802">        HP_Bar.vdraw(2, 10, you.hp, you.hp_max);</a>
<a name="ln803">    else</a>
<a name="ln804">#endif</a>
<a name="ln805">        HP_Bar.draw(19, y, you.hp, you.hp_max, you.hp - max(0, poison_survival()));</a>
<a name="ln806">}</a>
<a name="ln807"> </a>
<a name="ln808">static short _get_stat_colour(stat_type stat)</a>
<a name="ln809">{</a>
<a name="ln810">    if (you.duration[stat_zero_duration(stat)])</a>
<a name="ln811">        return LIGHTRED;</a>
<a name="ln812"> </a>
<a name="ln813">    // Check the stat_colour option for warning thresholds.</a>
<a name="ln814">    for (const auto &amp;entry : Options.stat_colour)</a>
<a name="ln815">        if (you.stat(stat) &lt;= entry.first)</a>
<a name="ln816">            return entry.second;</a>
<a name="ln817"> </a>
<a name="ln818">    // Stat is magically increased.</a>
<a name="ln819">    if (you.duration[DUR_DIVINE_STAMINA])</a>
<a name="ln820">        return LIGHTBLUE;  // no end of effect warning</a>
<a name="ln821"> </a>
<a name="ln822">    // Stat is degenerated.</a>
<a name="ln823">    if (you.stat_loss[stat] &gt; 0)</a>
<a name="ln824">        return YELLOW;</a>
<a name="ln825"> </a>
<a name="ln826">    return HUD_VALUE_COLOUR;</a>
<a name="ln827">}</a>
<a name="ln828"> </a>
<a name="ln829">static void _print_stat(stat_type stat, int x, int y)</a>
<a name="ln830">{</a>
<a name="ln831">    CGOTOXY(x+5, y, GOTO_STAT);</a>
<a name="ln832"> </a>
<a name="ln833">    textcolour(_get_stat_colour(stat));</a>
<a name="ln834">    CPRINTF(&quot;%d&quot;, you.stat(stat, false));</a>
<a name="ln835"> </a>
<a name="ln836">    if (you.stat_loss[stat] &gt; 0)</a>
<a name="ln837">        CPRINTF(&quot; (%d)  &quot;, you.max_stat(stat));</a>
<a name="ln838">    else</a>
<a name="ln839">        CPRINTF(&quot;       &quot;);</a>
<a name="ln840">}</a>
<a name="ln841"> </a>
<a name="ln842">static void _print_stats_ac(int x, int y)</a>
<a name="ln843">{</a>
<a name="ln844">    // AC:</a>
<a name="ln845">    auto text_col = HUD_VALUE_COLOUR;</a>
<a name="ln846">    if (_boosted_ac())</a>
<a name="ln847">        text_col = LIGHTBLUE;</a>
<a name="ln848">    else if (you.duration[DUR_CORROSION])</a>
<a name="ln849">        text_col = RED;</a>
<a name="ln850"> </a>
<a name="ln851">    string ac = make_stringf(&quot;%2d &quot;, you.armour_class());</a>
<a name="ln852">#ifdef WIZARD</a>
<a name="ln853">    if (you.wizard)</a>
<a name="ln854">        ac += make_stringf(&quot;(%d%%) &quot;, you.gdr_perc());</a>
<a name="ln855">#endif</a>
<a name="ln856">    textcolour(text_col);</a>
<a name="ln857">    CGOTOXY(x+4, y, GOTO_STAT);</a>
<a name="ln858">    CPRINTF(&quot;%-12s&quot;, ac.c_str());</a>
<a name="ln859"> </a>
<a name="ln860">    // SH: (two lines lower)</a>
<a name="ln861">    text_col = HUD_VALUE_COLOUR;</a>
<a name="ln862">    if (you.incapacitated() &amp;&amp; you.shielded())</a>
<a name="ln863">        text_col = RED;</a>
<a name="ln864">    else if (_boosted_sh())</a>
<a name="ln865">        text_col = LIGHTBLUE;</a>
<a name="ln866"> </a>
<a name="ln867">    string sh = make_stringf(&quot;%2d &quot;, player_displayed_shield_class());</a>
<a name="ln868">    textcolour(text_col);</a>
<a name="ln869">    CGOTOXY(x+4, y+2, GOTO_STAT);</a>
<a name="ln870">    CPRINTF(&quot;%-12s&quot;, sh.c_str());</a>
<a name="ln871">}</a>
<a name="ln872"> </a>
<a name="ln873">static void _print_stats_ev(int x, int y)</a>
<a name="ln874">{</a>
<a name="ln875">    CGOTOXY(x+4, y, GOTO_STAT);</a>
<a name="ln876">    textcolour(you.duration[DUR_PETRIFYING]</a>
<a name="ln877">               || you.cannot_move() ? RED</a>
<a name="ln878">                                    : _boosted_ev() ? LIGHTBLUE</a>
<a name="ln879">                                                    : HUD_VALUE_COLOUR);</a>
<a name="ln880">    CPRINTF(&quot;%2d &quot;, you.evasion());</a>
<a name="ln881">}</a>
<a name="ln882"> </a>
<a name="ln883">/**</a>
<a name="ln884"> * Get the appropriate colour for the UI text describing the player's weapon.</a>
<a name="ln885"> * (Or hands/ice fists/etc, as appropriate.)</a>
<a name="ln886"> *</a>
<a name="ln887"> * @return     A colour enum for the player's weapon.</a>
<a name="ln888"> */</a>
<a name="ln889">static int _wpn_name_colour()</a>
<a name="ln890">{</a>
<a name="ln891">    if (you.duration[DUR_CORROSION])</a>
<a name="ln892">        return RED;</a>
<a name="ln893"> </a>
<a name="ln894">    if (you.weapon())</a>
<a name="ln895">    {</a>
<a name="ln896">        const item_def&amp; wpn = *you.weapon();</a>
<a name="ln897"> </a>
<a name="ln898">        const string prefix = item_prefix(wpn);</a>
<a name="ln899">        const int prefcol = menu_colour(wpn.name(DESC_INVENTORY), prefix, &quot;stats&quot;);</a>
<a name="ln900">        if (prefcol != -1)</a>
<a name="ln901">            return prefcol;</a>
<a name="ln902">        return LIGHTGREY;</a>
<a name="ln903">    }</a>
<a name="ln904"> </a>
<a name="ln905">    return get_form()-&gt;uc_colour;</a>
<a name="ln906">}</a>
<a name="ln907"> </a>
<a name="ln908">/**</a>
<a name="ln909"> * Print a description of the player's weapon (or lack thereof) to the UI.</a>
<a name="ln910"> *</a>
<a name="ln911"> * @param y     The y-coordinate to print the description at.</a>
<a name="ln912"> */</a>
<a name="ln913">static void _print_stats_wp(int y)</a>
<a name="ln914">{</a>
<a name="ln915">    string text;</a>
<a name="ln916">    if (you.weapon())</a>
<a name="ln917">    {</a>
<a name="ln918">        item_def wpn = *you.weapon(); // copy</a>
<a name="ln919"> </a>
<a name="ln920">        if (you.duration[DUR_CORROSION] &amp;&amp; wpn.base_type == OBJ_WEAPONS)</a>
<a name="ln921">            wpn.plus -= 4 * you.props[&quot;corrosion_amount&quot;].get_int();</a>
<a name="ln922"> </a>
<a name="ln923">        text = wpn.name(DESC_PLAIN, true, false, true);</a>
<a name="ln924">    }</a>
<a name="ln925">    else</a>
<a name="ln926">        text = you.unarmed_attack_name();</a>
<a name="ln927"> </a>
<a name="ln928">    CGOTOXY(1, y, GOTO_STAT);</a>
<a name="ln929">    textcolour(HUD_CAPTION_COLOUR);</a>
<a name="ln930">    const char slot_letter = you.weapon() ? index_to_letter(you.weapon()-&gt;link)</a>
<a name="ln931">                                          : '-';</a>
<a name="ln932">    const string slot_name = make_stringf(&quot;%c) &quot;, slot_letter);</a>
<a name="ln933">    CPRINTF(&quot;%s&quot;, slot_name.c_str());</a>
<a name="ln934">    textcolour(_wpn_name_colour());</a>
<a name="ln935">    const int max_name_width = crawl_view.hudsz.x - slot_name.size();</a>
<a name="ln936">    CPRINTF(&quot;%s&quot;, chop_string(text, max_name_width).c_str());</a>
<a name="ln937">    textcolour(LIGHTGREY);</a>
<a name="ln938">}</a>
<a name="ln939"> </a>
<a name="ln940">static void _print_stats_qv(int y)</a>
<a name="ln941">{</a>
<a name="ln942">    int col;</a>
<a name="ln943">    string text;</a>
<a name="ln944"> </a>
<a name="ln945">    int q = you.m_quiver.get_fire_item();</a>
<a name="ln946">    ASSERT_RANGE(q, -1, ENDOFPACK);</a>
<a name="ln947">    char hud_letter = '-';</a>
<a name="ln948">    if (q != -1 &amp;&amp; !fire_warn_if_impossible(true))</a>
<a name="ln949">    {</a>
<a name="ln950">        const item_def&amp; quiver = you.inv[q];</a>
<a name="ln951">        hud_letter = index_to_letter(quiver.link);</a>
<a name="ln952">        const string prefix = item_prefix(quiver);</a>
<a name="ln953">        const int prefcol =</a>
<a name="ln954">            menu_colour(quiver.name(DESC_PLAIN), prefix, &quot;stats&quot;);</a>
<a name="ln955">        if (prefcol != -1)</a>
<a name="ln956">            col = prefcol;</a>
<a name="ln957">        else</a>
<a name="ln958">            col = LIGHTGREY;</a>
<a name="ln959">        text = quiver.name(DESC_PLAIN, true);</a>
<a name="ln960">    }</a>
<a name="ln961">    else</a>
<a name="ln962">    {</a>
<a name="ln963">        if (fire_warn_if_impossible(true))</a>
<a name="ln964">        {</a>
<a name="ln965">            col  = DARKGREY;</a>
<a name="ln966">            text = &quot;Quiver unavailable&quot;;</a>
<a name="ln967">        }</a>
<a name="ln968">        else</a>
<a name="ln969">        {</a>
<a name="ln970">            col  = LIGHTGREY;</a>
<a name="ln971">            text = &quot;Nothing quivered&quot;;</a>
<a name="ln972">        }</a>
<a name="ln973">    }</a>
<a name="ln974">    CGOTOXY(1, y, GOTO_STAT);</a>
<a name="ln975">    textcolour(HUD_CAPTION_COLOUR);</a>
<a name="ln976">    CPRINTF(&quot;%c) &quot;, hud_letter);</a>
<a name="ln977">    textcolour(col);</a>
<a name="ln978">#ifdef USE_TILE_LOCAL</a>
<a name="ln979">    int w = crawl_view.hudsz.x - (tiles.is_using_small_layout()?0:4);</a>
<a name="ln980">    CPRINTF(&quot;%s&quot;, chop_string(text, w).c_str());</a>
<a name="ln981">#else</a>
<a name="ln982">    CPRINTF(&quot;%s&quot;, chop_string(text, crawl_view.hudsz.x-4).c_str());</a>
<a name="ln983">#endif</a>
<a name="ln984">    textcolour(LIGHTGREY);</a>
<a name="ln985">}</a>
<a name="ln986"> </a>
<a name="ln987">struct status_light</a>
<a name="ln988">{</a>
<a name="ln989">    status_light(int c, string t) : colour(c), text(t) {}</a>
<a name="ln990">    colour_t colour;</a>
<a name="ln991">    string text;</a>
<a name="ln992">};</a>
<a name="ln993"> </a>
<a name="ln994">static void _add_status_light_to_out(int i, vector&lt;status_light&gt;&amp; out)</a>
<a name="ln995">{</a>
<a name="ln996">    status_info inf;</a>
<a name="ln997"> </a>
<a name="ln998">    if (fill_status_info(i, inf) &amp;&amp; !inf.light_text.empty())</a>
<a name="ln999">    {</a>
<a name="ln1000">        status_light sl(inf.light_colour, inf.light_text);</a>
<a name="ln1001">        out.push_back(sl);</a>
<a name="ln1002">    }</a>
<a name="ln1003">}</a>
<a name="ln1004"> </a>
<a name="ln1005">// The colour scheme for these flags is currently:</a>
<a name="ln1006">//</a>
<a name="ln1007">// - yellow, &quot;orange&quot;, red      for bad conditions</a>
<a name="ln1008">// - light grey, white          for god based conditions</a>
<a name="ln1009">// - green, light green         for good conditions</a>
<a name="ln1010">// - blue, light blue           for good enchantments</a>
<a name="ln1011">// - magenta, light magenta     for &quot;better&quot; enchantments (deflect, fly)</a>
<a name="ln1012">//</a>
<a name="ln1013">// Prints hunger,</a>
<a name="ln1014">// pray, holy, teleport, regen, fly/lev, invis, silence,</a>
<a name="ln1015">//   conf. touch, sage</a>
<a name="ln1016">// confused, mesmerised, fire, poison, disease, rot, held, glow, swift,</a>
<a name="ln1017">//   fast, slow, breath</a>
<a name="ln1018">//</a>
<a name="ln1019">// Note the usage of bad_ench_colour() correspond to levels that</a>
<a name="ln1020">// can be found in player.cc, ie those that the player can tell by</a>
<a name="ln1021">// using the '@' command. Things like confusion and sticky flame</a>
<a name="ln1022">// hide their amounts and are thus always the same colour (so</a>
<a name="ln1023">// we're not really exposing any new information). --bwr</a>
<a name="ln1024">static void _get_status_lights(vector&lt;status_light&gt;&amp; out)</a>
<a name="ln1025">{</a>
<a name="ln1026">#ifdef DEBUG_DIAGNOSTICS</a>
<a name="ln1027">    {</a>
<a name="ln1028">        static char static_pos_buf[80];</a>
<a name="ln1029">        snprintf(static_pos_buf, sizeof(static_pos_buf),</a>
<a name="ln1030">                 &quot;%2d,%2d&quot;, you.pos().x, you.pos().y);</a>
<a name="ln1031">        out.emplace_back(LIGHTGREY, static_pos_buf);</a>
<a name="ln1032"> </a>
<a name="ln1033">        static char static_hunger_buf[80];</a>
<a name="ln1034">        snprintf(static_hunger_buf, sizeof(static_hunger_buf),</a>
<a name="ln1035">                 &quot;(%d:%d)&quot;, you.hunger - you.old_hunger, you.hunger);</a>
<a name="ln1036">        out.emplace_back(LIGHTGREY, static_hunger_buf);</a>
<a name="ln1037">    }</a>
<a name="ln1038">#endif</a>
<a name="ln1039"> </a>
<a name="ln1040">    // We used to have to hardcode every status, now we just hardcode the</a>
<a name="ln1041">    // statuses important enough to appear first. (Rightmost)</a>
<a name="ln1042">    const unsigned int important_statuses[] =</a>
<a name="ln1043">    {</a>
<a name="ln1044">        STATUS_ORB,</a>
<a name="ln1045">        STATUS_STR_ZERO, STATUS_INT_ZERO, STATUS_DEX_ZERO,</a>
<a name="ln1046">        STATUS_HUNGER,</a>
<a name="ln1047">        DUR_PARALYSIS,</a>
<a name="ln1048">        DUR_CONF,</a>
<a name="ln1049">        DUR_PETRIFYING,</a>
<a name="ln1050">        DUR_PETRIFIED,</a>
<a name="ln1051">        DUR_BERSERK,</a>
<a name="ln1052">        DUR_TELEPORT,</a>
<a name="ln1053">        DUR_HASTE,</a>
<a name="ln1054">        DUR_SLOW,</a>
<a name="ln1055">        STATUS_SPEED,</a>
<a name="ln1056">        DUR_DEATHS_DOOR,</a>
<a name="ln1057">        DUR_BERSERK_COOLDOWN,</a>
<a name="ln1058">        DUR_EXHAUSTED,</a>
<a name="ln1059">        DUR_DEATHS_DOOR_COOLDOWN,</a>
<a name="ln1060">        DUR_QUAD_DAMAGE,</a>
<a name="ln1061">        STATUS_SERPENTS_LASH,</a>
<a name="ln1062">    };</a>
<a name="ln1063"> </a>
<a name="ln1064">    bitset&lt;STATUS_LAST_STATUS + 1&gt; done;</a>
<a name="ln1065">    for (unsigned important : important_statuses)</a>
<a name="ln1066">    {</a>
<a name="ln1067">        _add_status_light_to_out(important, out);</a>
<a name="ln1068">        done.set(important);</a>
<a name="ln1069">    }</a>
<a name="ln1070"> </a>
<a name="ln1071">    for (unsigned status = 0; status &lt;= STATUS_LAST_STATUS ; ++status)</a>
<a name="ln1072">        if (!done[status])</a>
<a name="ln1073">            _add_status_light_to_out(status, out);</a>
<a name="ln1074">}</a>
<a name="ln1075"> </a>
<a name="ln1076">static void _print_status_lights(int y)</a>
<a name="ln1077">{</a>
<a name="ln1078">    vector&lt;status_light&gt; lights;</a>
<a name="ln1079">    static int last_number_of_lights = 0;</a>
<a name="ln1080">    _get_status_lights(lights);</a>
<a name="ln1081">    if (lights.empty() &amp;&amp; last_number_of_lights == 0)</a>
<a name="ln1082">        return;</a>
<a name="ln1083">    last_number_of_lights = lights.size();</a>
<a name="ln1084"> </a>
<a name="ln1085">    size_t line_cur = y;</a>
<a name="ln1086">    const size_t line_end = crawl_view.hudsz.y+1;</a>
<a name="ln1087"> </a>
<a name="ln1088">    CGOTOXY(1, line_cur, GOTO_STAT);</a>
<a name="ln1089">#ifdef ASSERTS</a>
<a name="ln1090">    if (wherex() != crawl_view.hudp.x)</a>
<a name="ln1091">    {</a>
<a name="ln1092">        save_game(false); // should be safe</a>
<a name="ln1093">        die(&quot;misaligned HUD (is %d, should be %d)&quot;, wherex(), crawl_view.hudp.x);</a>
<a name="ln1094">    }</a>
<a name="ln1095">#endif</a>
<a name="ln1096"> </a>
<a name="ln1097">#ifdef USE_TILE_LOCAL</a>
<a name="ln1098">    if (!tiles.is_using_small_layout())</a>
<a name="ln1099">    {</a>
<a name="ln1100">#endif</a>
<a name="ln1101">    size_t i_light = 0;</a>
<a name="ln1102">    while (true)</a>
<a name="ln1103">    {</a>
<a name="ln1104">        const int end_x = (wherex() - crawl_view.hudp.x)</a>
<a name="ln1105">                + (i_light &lt; lights.size() ? strwidth(lights[i_light].text)</a>
<a name="ln1106">                                           : 10000);</a>
<a name="ln1107"> </a>
<a name="ln1108">        if (end_x &lt;= crawl_view.hudsz.x)</a>
<a name="ln1109">        {</a>
<a name="ln1110">            textcolour(lights[i_light].colour);</a>
<a name="ln1111">            CPRINTF(&quot;%s&quot;, lights[i_light].text.c_str());</a>
<a name="ln1112">            if (end_x &lt; crawl_view.hudsz.x)</a>
<a name="ln1113">                CPRINTF(&quot; &quot;);</a>
<a name="ln1114">            ++i_light;</a>
<a name="ln1115">        }</a>
<a name="ln1116">        else</a>
<a name="ln1117">        {</a>
<a name="ln1118">            clear_to_end_of_line();</a>
<a name="ln1119">            ++line_cur;</a>
<a name="ln1120">            // Careful not to trip the )#(*$ CGOTOXY ASSERT</a>
<a name="ln1121">            if (line_cur == line_end)</a>
<a name="ln1122">                break;</a>
<a name="ln1123">            CGOTOXY(1, line_cur, GOTO_STAT);</a>
<a name="ln1124">        }</a>
<a name="ln1125">    }</a>
<a name="ln1126">#ifdef USE_TILE_LOCAL</a>
<a name="ln1127">    }</a>
<a name="ln1128">    else</a>
<a name="ln1129">    {</a>
<a name="ln1130">        size_t i_light = 0;</a>
<a name="ln1131">        if (lights.size() == 1)</a>
<a name="ln1132">        {</a>
<a name="ln1133">            textcolour(lights[0].colour);</a>
<a name="ln1134">            CPRINTF(&quot;%s&quot;, lights[0].text.c_str());</a>
<a name="ln1135">        }</a>
<a name="ln1136">        else</a>
<a name="ln1137">        {</a>
<a name="ln1138">            while (i_light &lt; lights.size() &amp;&amp; (int)i_light &lt; crawl_view.hudsz.x - 1)</a>
<a name="ln1139">            {</a>
<a name="ln1140">                textcolour(lights[i_light].colour);</a>
<a name="ln1141">                if (i_light == lights.size() - 1</a>
<a name="ln1142">                    &amp;&amp; strwidth(lights[i_light].text) &lt; crawl_view.hudsz.x - wherex())</a>
<a name="ln1143">                {</a>
<a name="ln1144">                    CPRINTF(&quot;%s&quot;,lights[i_light].text.c_str());</a>
<a name="ln1145">                }</a>
<a name="ln1146">                else if ((int)lights.size() &gt; crawl_view.hudsz.x / 2)</a>
<a name="ln1147">                    CPRINTF(&quot;%.1s&quot;,lights[i_light].text.c_str());</a>
<a name="ln1148">                else</a>
<a name="ln1149">                    CPRINTF(&quot;%.1s &quot;,lights[i_light].text.c_str());</a>
<a name="ln1150">                ++i_light;</a>
<a name="ln1151">            }</a>
<a name="ln1152">        }</a>
<a name="ln1153">        clear_to_end_of_line();</a>
<a name="ln1154">    }</a>
<a name="ln1155">#endif</a>
<a name="ln1156">}</a>
<a name="ln1157"> </a>
<a name="ln1158">#ifdef USE_TILE_LOCAL</a>
<a name="ln1159">static bool _need_stats_printed()</a>
<a name="ln1160">{</a>
<a name="ln1161">    return you.redraw_title</a>
<a name="ln1162">           || you.redraw_hit_points</a>
<a name="ln1163">           || you.redraw_magic_points</a>
<a name="ln1164">           || you.redraw_armour_class</a>
<a name="ln1165">           || you.redraw_evasion</a>
<a name="ln1166">           || you.redraw_stats[STAT_STR]</a>
<a name="ln1167">           || you.redraw_stats[STAT_INT]</a>
<a name="ln1168">           || you.redraw_stats[STAT_DEX]</a>
<a name="ln1169">           || you.redraw_experience</a>
<a name="ln1170">           || you.wield_change</a>
<a name="ln1171">           || you.redraw_quiver;</a>
<a name="ln1172">}</a>
<a name="ln1173">#endif</a>
<a name="ln1174"> </a>
<a name="ln1175">static void _draw_wizmode_flag(const char *word)</a>
<a name="ln1176">{</a>
<a name="ln1177">    textcolour(LIGHTMAGENTA);</a>
<a name="ln1178">    // 3+ for the &quot; **&quot;</a>
<a name="ln1179">    CGOTOXY(1 + crawl_view.hudsz.x - (3 + strlen(word)), 1, GOTO_STAT);</a>
<a name="ln1180">    CPRINTF(&quot; *%s*&quot;, word);</a>
<a name="ln1181">}</a>
<a name="ln1182"> </a>
<a name="ln1183">static void _redraw_title()</a>
<a name="ln1184">{</a>
<a name="ln1185">    const unsigned int WIDTH = crawl_view.hudsz.x;</a>
<a name="ln1186">    string title = you.your_name + &quot; &quot; + filtered_lang(player_title());</a>
<a name="ln1187">    const bool small_layout =</a>
<a name="ln1188">#ifdef USE_TILE_LOCAL</a>
<a name="ln1189">                              tiles.is_using_small_layout();</a>
<a name="ln1190">#else</a>
<a name="ln1191">                              false;</a>
<a name="ln1192">#endif</a>
<a name="ln1193"> </a>
<a name="ln1194">    if (small_layout)</a>
<a name="ln1195">        title = you.your_name;</a>
<a name="ln1196">    else</a>
<a name="ln1197">    {</a>
<a name="ln1198">        unsigned int in_len = strwidth(title);</a>
<a name="ln1199">        if (in_len &gt; WIDTH)</a>
<a name="ln1200">        {</a>
<a name="ln1201">            in_len -= 3;  // strwidth(&quot; the &quot;) - strwidth(&quot;, &quot;)</a>
<a name="ln1202"> </a>
<a name="ln1203">            const unsigned int name_len = strwidth(you.your_name);</a>
<a name="ln1204">            string trimmed_name = you.your_name;</a>
<a name="ln1205">            // Squeeze name if required, the &quot;- 8&quot; is to not squeeze too much.</a>
<a name="ln1206">            if (in_len &gt; WIDTH &amp;&amp; (name_len - 8) &gt; (in_len - WIDTH))</a>
<a name="ln1207">            {</a>
<a name="ln1208">                trimmed_name = chop_string(trimmed_name,</a>
<a name="ln1209">                                           name_len - (in_len - WIDTH) - 1);</a>
<a name="ln1210">            }</a>
<a name="ln1211"> </a>
<a name="ln1212">            title = trimmed_name + &quot;, &quot; + filtered_lang(player_title(false));</a>
<a name="ln1213">        }</a>
<a name="ln1214">    }</a>
<a name="ln1215"> </a>
<a name="ln1216">    // Line 1: Foo the Bar    *WIZARD*</a>
<a name="ln1217">    CGOTOXY(1, 1, GOTO_STAT);</a>
<a name="ln1218">    textcolour(small_layout &amp;&amp; you.wizard ? LIGHTMAGENTA : YELLOW);</a>
<a name="ln1219">    CPRINTF(&quot;%s&quot;, chop_string(title, WIDTH).c_str());</a>
<a name="ln1220">    if (you.wizard &amp;&amp; !small_layout)</a>
<a name="ln1221">        _draw_wizmode_flag(&quot;WIZARD&quot;);</a>
<a name="ln1222">    else if (you.suppress_wizard &amp;&amp; !small_layout)</a>
<a name="ln1223">        _draw_wizmode_flag(&quot;EX-WIZARD&quot;);</a>
<a name="ln1224">    else if (you.explore &amp;&amp; !small_layout)</a>
<a name="ln1225">        _draw_wizmode_flag(&quot;EXPLORE&quot;);</a>
<a name="ln1226">#ifdef DGL_SIMPLE_MESSAGING</a>
<a name="ln1227">    update_message_status();</a>
<a name="ln1228">#endif</a>
<a name="ln1229"> </a>
<a name="ln1230">    // Line 2:</a>
<a name="ln1231">    // Minotaur [of God] [Piety]</a>
<a name="ln1232">    textcolour(YELLOW);</a>
<a name="ln1233">    CGOTOXY(1, 2, GOTO_STAT);</a>
<a name="ln1234">    string species = species_name(you.species);</a>
<a name="ln1235">    NOWRAP_EOL_CPRINTF(&quot;%s&quot;, species.c_str());</a>
<a name="ln1236">    if (you_worship(GOD_NO_GOD))</a>
<a name="ln1237">    {</a>
<a name="ln1238">        if (you.char_class == JOB_MONK &amp;&amp; you.species != SP_DEMIGOD</a>
<a name="ln1239">            &amp;&amp; !had_gods())</a>
<a name="ln1240">        {</a>
<a name="ln1241">            string godpiety = &quot;**....&quot;;</a>
<a name="ln1242">            textcolour(DARKGREY);</a>
<a name="ln1243">            if ((unsigned int)(strwidth(species) + strwidth(godpiety) + 1) &lt;= WIDTH)</a>
<a name="ln1244">                NOWRAP_EOL_CPRINTF(&quot; %s&quot;, godpiety.c_str());</a>
<a name="ln1245">            clear_to_end_of_line();</a>
<a name="ln1246">        }</a>
<a name="ln1247">        else</a>
<a name="ln1248">        {</a>
<a name="ln1249">            // Still need to clear in case the player was excommunicated</a>
<a name="ln1250">            clear_to_end_of_line();</a>
<a name="ln1251">        }</a>
<a name="ln1252">    }</a>
<a name="ln1253">    else</a>
<a name="ln1254">    {</a>
<a name="ln1255">        string god = &quot; of &quot;;</a>
<a name="ln1256">        god += you_worship(GOD_JIYVA) ? god_name_jiyva(true)</a>
<a name="ln1257">                                      : god_name(you.religion);</a>
<a name="ln1258">        NOWRAP_EOL_CPRINTF(&quot;%s&quot;, god.c_str());</a>
<a name="ln1259"> </a>
<a name="ln1260">        string piety = _god_asterisks();</a>
<a name="ln1261">        textcolour(_god_status_colour(YELLOW));</a>
<a name="ln1262">        const unsigned int textwidth = (unsigned int)(strwidth(species) + strwidth(god) + strwidth(piety) + 1);</a>
<a name="ln1263">        if (textwidth &lt;= WIDTH)</a>
<a name="ln1264">            NOWRAP_EOL_CPRINTF(&quot; %s&quot;, piety.c_str());</a>
<a name="ln1265">        else if (textwidth == (WIDTH + 1))</a>
<a name="ln1266">        {</a>
<a name="ln1267">            //mottled draconian of TSO doesn't fit by one symbol,</a>
<a name="ln1268">            //so we remove leading space.</a>
<a name="ln1269">            NOWRAP_EOL_CPRINTF(&quot;%s&quot;, piety.c_str());</a>
<a name="ln1270">        }</a>
<a name="ln1271">        clear_to_end_of_line();</a>
<a name="ln1272">        if (you_worship(GOD_GOZAG))</a>
<a name="ln1273">        {</a>
<a name="ln1274">            // &quot;Mottled Draconian of Gozag  Gold: 99999&quot; just fits</a>
<a name="ln1275">            _print_stats_gold(textwidth + 2, 2);</a>
<a name="ln1276">        }</a>
<a name="ln1277">    }</a>
<a name="ln1278"> </a>
<a name="ln1279">    textcolour(LIGHTGREY);</a>
<a name="ln1280">}</a>
<a name="ln1281"> </a>
<a name="ln1282">void print_stats()</a>
<a name="ln1283">{</a>
<a name="ln1284">    int ac_pos = 5;</a>
<a name="ln1285">    int ev_pos = ac_pos + 1;</a>
<a name="ln1286"> </a>
<a name="ln1287">    cursor_control coff(false);</a>
<a name="ln1288">    textcolour(LIGHTGREY);</a>
<a name="ln1289"> </a>
<a name="ln1290">    // Displayed evasion is tied to dex/str.</a>
<a name="ln1291">    if (you.redraw_stats[STAT_DEX]</a>
<a name="ln1292">        || you.redraw_stats[STAT_STR])</a>
<a name="ln1293">    {</a>
<a name="ln1294">        you.redraw_evasion = true;</a>
<a name="ln1295">    }</a>
<a name="ln1296"> </a>
<a name="ln1297">    if (HP_Bar.wants_redraw())</a>
<a name="ln1298">        you.redraw_hit_points = true;</a>
<a name="ln1299">    if (MP_Bar.wants_redraw())</a>
<a name="ln1300">        you.redraw_magic_points = true;</a>
<a name="ln1301"> </a>
<a name="ln1302">    // Poison display depends on regen rate, so should be redrawn every turn.</a>
<a name="ln1303">    if (you.duration[DUR_POISONING])</a>
<a name="ln1304">    {</a>
<a name="ln1305">        you.redraw_hit_points = true;</a>
<a name="ln1306">        you.redraw_status_lights = true;</a>
<a name="ln1307">    }</a>
<a name="ln1308"> </a>
<a name="ln1309">#ifdef USE_TILE_LOCAL</a>
<a name="ln1310">    bool has_changed = _need_stats_printed();</a>
<a name="ln1311">#endif</a>
<a name="ln1312"> </a>
<a name="ln1313">    if (you.redraw_title)</a>
<a name="ln1314">    {</a>
<a name="ln1315">        you.redraw_title = false;</a>
<a name="ln1316">        _redraw_title();</a>
<a name="ln1317">    }</a>
<a name="ln1318">    if (you.redraw_hit_points)</a>
<a name="ln1319">    {</a>
<a name="ln1320">        you.redraw_hit_points = false;</a>
<a name="ln1321">        _print_stats_hp(1, 3);</a>
<a name="ln1322">    }</a>
<a name="ln1323">    if (you.redraw_magic_points)</a>
<a name="ln1324">    {</a>
<a name="ln1325">        you.redraw_magic_points = false;</a>
<a name="ln1326">        _print_stats_mp(1, 4);</a>
<a name="ln1327">    }</a>
<a name="ln1328"> </a>
<a name="ln1329">    if (you.redraw_armour_class)</a>
<a name="ln1330">    {</a>
<a name="ln1331">        you.redraw_armour_class = false;</a>
<a name="ln1332">        _print_stats_ac(1, ac_pos);</a>
<a name="ln1333">    }</a>
<a name="ln1334">    if (you.redraw_evasion)</a>
<a name="ln1335">    {</a>
<a name="ln1336">        you.redraw_evasion = false;</a>
<a name="ln1337">        _print_stats_ev(1, ev_pos);</a>
<a name="ln1338">    }</a>
<a name="ln1339"> </a>
<a name="ln1340">    for (int i = 0; i &lt; NUM_STATS; ++i)</a>
<a name="ln1341">        if (you.redraw_stats[i])</a>
<a name="ln1342">            _print_stat(static_cast&lt;stat_type&gt;(i), 19, 5 + i);</a>
<a name="ln1343">    you.redraw_stats.init(false);</a>
<a name="ln1344"> </a>
<a name="ln1345">    if (you.redraw_experience)</a>
<a name="ln1346">    {</a>
<a name="ln1347">        CGOTOXY(1, 8, GOTO_STAT);</a>
<a name="ln1348">        textcolour(Options.status_caption_colour);</a>
<a name="ln1349">        CPRINTF(&quot;XL: &quot;);</a>
<a name="ln1350">        textcolour(HUD_VALUE_COLOUR);</a>
<a name="ln1351">        CPRINTF(&quot;%2d &quot;, you.experience_level);</a>
<a name="ln1352">        if (you.experience_level &gt;= you.get_max_xl())</a>
<a name="ln1353">            CPRINTF(&quot;%10s&quot;, &quot;&quot;);</a>
<a name="ln1354">        else</a>
<a name="ln1355">        {</a>
<a name="ln1356">            textcolour(Options.status_caption_colour);</a>
<a name="ln1357">            CPRINTF(&quot;Next: &quot;);</a>
<a name="ln1358">            textcolour(HUD_VALUE_COLOUR);</a>
<a name="ln1359">            CPRINTF(&quot;%2d%% &quot;, get_exp_progress());</a>
<a name="ln1360">        }</a>
<a name="ln1361">        you.redraw_experience = false;</a>
<a name="ln1362">    }</a>
<a name="ln1363"> </a>
<a name="ln1364">    int yhack = 0;</a>
<a name="ln1365"> </a>
<a name="ln1366">    // Line 9 is Noise and Turns</a>
<a name="ln1367">#ifdef USE_TILE_LOCAL</a>
<a name="ln1368">    if (!tiles.is_using_small_layout())</a>
<a name="ln1369">#endif</a>
<a name="ln1370">    {</a>
<a name="ln1371">        yhack++;</a>
<a name="ln1372">        if (Options.equip_bar)</a>
<a name="ln1373">            _print_stats_equip(1, 8+yhack);</a>
<a name="ln1374">        else</a>
<a name="ln1375">            _print_stats_noise(1, 8+yhack);</a>
<a name="ln1376">    }</a>
<a name="ln1377"> </a>
<a name="ln1378">    if (you.wield_change)</a>
<a name="ln1379">    {</a>
<a name="ln1380">        // weapon_change is set in a billion places; probably not all</a>
<a name="ln1381">        // of them actually mean the user changed their weapon. Calling</a>
<a name="ln1382">        // on_weapon_changed redundantly is normally OK; but if the user</a>
<a name="ln1383">        // is wielding a bow and throwing javelins, the on_weapon_changed</a>
<a name="ln1384">        // will switch them back to arrows, which is annoying.</a>
<a name="ln1385">        // Perhaps there should be another bool besides wield_change</a>
<a name="ln1386">        // that's set in fewer places?</a>
<a name="ln1387">        // Also, it's a little bogus to change simulation state in</a>
<a name="ln1388">        // render code. We should find a better place for this.</a>
<a name="ln1389">        you.m_quiver.on_weapon_changed();</a>
<a name="ln1390">        _print_stats_wp(9 + yhack);</a>
<a name="ln1391">    }</a>
<a name="ln1392">    you.wield_change  = false;</a>
<a name="ln1393"> </a>
<a name="ln1394">    if (you.species == SP_FELID)</a>
<a name="ln1395">    {</a>
<a name="ln1396">        // There are no circumstances under which Felids could quiver something.</a>
<a name="ln1397">        // Reduce line counter for status display.</a>
<a name="ln1398">        yhack -= 1;</a>
<a name="ln1399">    }</a>
<a name="ln1400">    else if (you.redraw_quiver || you.wield_change)</a>
<a name="ln1401">        _print_stats_qv(10 + yhack);</a>
<a name="ln1402"> </a>
<a name="ln1403">    you.redraw_quiver = false;</a>
<a name="ln1404"> </a>
<a name="ln1405">    if (you.redraw_status_lights)</a>
<a name="ln1406">    {</a>
<a name="ln1407">        you.redraw_status_lights = false;</a>
<a name="ln1408">        _print_status_lights(11 + yhack);</a>
<a name="ln1409">    }</a>
<a name="ln1410"> </a>
<a name="ln1411">#ifdef USE_TILE_LOCAL</a>
<a name="ln1412">    if (has_changed)</a>
<a name="ln1413">        update_screen();</a>
<a name="ln1414">#else</a>
<a name="ln1415">    update_screen();</a>
<a name="ln1416">#endif</a>
<a name="ln1417">}</a>
<a name="ln1418"> </a>
<a name="ln1419">static string _level_description_string_hud()</a>
<a name="ln1420">{</a>
<a name="ln1421">    const PlaceInfo&amp; place = you.get_place_info();</a>
<a name="ln1422">    string short_name = branches[place.branch].shortname;</a>
<a name="ln1423"> </a>
<a name="ln1424">    if (brdepth[place.branch] &gt; 1)</a>
<a name="ln1425">        short_name += make_stringf(&quot;:%d&quot;, you.depth);</a>
<a name="ln1426">    // Indefinite articles</a>
<a name="ln1427">    else if (place.branch != BRANCH_PANDEMONIUM</a>
<a name="ln1428">             &amp;&amp; place.branch != BRANCH_DESOLATION</a>
<a name="ln1429">             &amp;&amp; !is_connected_branch(place.branch))</a>
<a name="ln1430">    {</a>
<a name="ln1431">        short_name = article_a(short_name);</a>
<a name="ln1432">    }</a>
<a name="ln1433">    return short_name;</a>
<a name="ln1434">}</a>
<a name="ln1435"> </a>
<a name="ln1436">void print_stats_level()</a>
<a name="ln1437">{</a>
<a name="ln1438">    int ypos = 8;</a>
<a name="ln1439">    cgotoxy(19, ypos, GOTO_STAT);</a>
<a name="ln1440">    textcolour(HUD_CAPTION_COLOUR);</a>
<a name="ln1441">    CPRINTF(&quot;Place: &quot;);</a>
<a name="ln1442"> </a>
<a name="ln1443">    textcolour(HUD_VALUE_COLOUR);</a>
<a name="ln1444">#ifdef DEBUG_DIAGNOSTICS</a>
<a name="ln1445">    CPRINTF(&quot;(%d) &quot;, env.absdepth0 + 1);</a>
<a name="ln1446">#endif</a>
<a name="ln1447">    CPRINTF(&quot;%s&quot;, _level_description_string_hud().c_str());</a>
<a name="ln1448">    clear_to_end_of_line();</a>
<a name="ln1449">}</a>
<a name="ln1450"> </a>
<a name="ln1451">void draw_border()</a>
<a name="ln1452">{</a>
<a name="ln1453">    textcolour(HUD_CAPTION_COLOUR);</a>
<a name="ln1454">    clrscr();</a>
<a name="ln1455"> </a>
<a name="ln1456">    textcolour(Options.status_caption_colour);</a>
<a name="ln1457"> </a>
<a name="ln1458">//    int hp_pos = 3;</a>
<a name="ln1459">    int mp_pos = 4;</a>
<a name="ln1460">    int ac_pos = 5;</a>
<a name="ln1461">    int ev_pos = 6;</a>
<a name="ln1462">    int sh_pos = 7;</a>
<a name="ln1463">    int str_pos = ac_pos;</a>
<a name="ln1464">    int int_pos = ev_pos;</a>
<a name="ln1465">    int dex_pos = sh_pos;</a>
<a name="ln1466"> </a>
<a name="ln1467">    //CGOTOXY(1, 3, GOTO_STAT); CPRINTF(&quot;Hp:&quot;);</a>
<a name="ln1468">    CGOTOXY(1, mp_pos, GOTO_STAT);</a>
<a name="ln1469">    CGOTOXY(1, ac_pos, GOTO_STAT); CPRINTF(&quot;AC:&quot;);</a>
<a name="ln1470">    CGOTOXY(1, ev_pos, GOTO_STAT); CPRINTF(&quot;EV:&quot;);</a>
<a name="ln1471">    CGOTOXY(1, sh_pos, GOTO_STAT); CPRINTF(&quot;SH:&quot;);</a>
<a name="ln1472"> </a>
<a name="ln1473">    CGOTOXY(19, str_pos, GOTO_STAT); CPRINTF(&quot;Str:&quot;);</a>
<a name="ln1474">    CGOTOXY(19, int_pos, GOTO_STAT); CPRINTF(&quot;Int:&quot;);</a>
<a name="ln1475">    CGOTOXY(19, dex_pos, GOTO_STAT); CPRINTF(&quot;Dex:&quot;);</a>
<a name="ln1476"> </a>
<a name="ln1477">    CGOTOXY(19, 9, GOTO_STAT);</a>
<a name="ln1478">    CPRINTF(Options.show_game_time ? &quot;Time:&quot; : &quot;Turn:&quot;);</a>
<a name="ln1479">    // Line 8 is exp pool, Level</a>
<a name="ln1480">}</a>
<a name="ln1481"> </a>
<a name="ln1482">#ifndef USE_TILE_LOCAL</a>
<a name="ln1483">void redraw_console_sidebar()</a>
<a name="ln1484">{</a>
<a name="ln1485">    // TODO: this is super hacky and merges stuff from redraw_screen and</a>
<a name="ln1486">    // viewwindow. It won't do nothing for webtiles, but should be basically</a>
<a name="ln1487">    // benign there.</a>
<a name="ln1488">    draw_border();</a>
<a name="ln1489"> </a>
<a name="ln1490">    you.redraw_title        = true;</a>
<a name="ln1491">    you.redraw_hit_points   = true;</a>
<a name="ln1492">    you.redraw_magic_points = true;</a>
<a name="ln1493">    you.redraw_stats.init(true);</a>
<a name="ln1494">    you.redraw_armour_class  = true;</a>
<a name="ln1495">    you.redraw_evasion       = true;</a>
<a name="ln1496">    you.redraw_experience    = true;</a>
<a name="ln1497">    you.wield_change         = true;</a>
<a name="ln1498">    you.redraw_quiver        = true;</a>
<a name="ln1499">    you.redraw_status_lights = true;</a>
<a name="ln1500"> </a>
<a name="ln1501">    print_stats();</a>
<a name="ln1502"> </a>
<a name="ln1503">    {</a>
<a name="ln1504">        no_notes nx;</a>
<a name="ln1505">        print_stats_level();</a>
<a name="ln1506">        update_turn_count();</a>
<a name="ln1507">    }</a>
<a name="ln1508">    puttext(crawl_view.viewp.x, crawl_view.viewp.y, crawl_view.vbuf);</a>
<a name="ln1509">    update_monster_pane();</a>
<a name="ln1510"> </a>
<a name="ln1511">    you.flash_colour = BLACK;</a>
<a name="ln1512">    you.flash_where = 0;</a>
<a name="ln1513">}</a>
<a name="ln1514">#endif</a>
<a name="ln1515"> </a>
<a name="ln1516">void redraw_screen(bool show_updates)</a>
<a name="ln1517">{</a>
<a name="ln1518">    if (!crawl_state.need_save)</a>
<a name="ln1519">    {</a>
<a name="ln1520">        // If the game hasn't started, don't do much.</a>
<a name="ln1521">        clrscr();</a>
<a name="ln1522">        return;</a>
<a name="ln1523">    }</a>
<a name="ln1524"> </a>
<a name="ln1525">#ifdef USE_TILE_WEB</a>
<a name="ln1526">    if (!ui::has_layout())</a>
<a name="ln1527">        tiles.pop_all_ui_layouts();</a>
<a name="ln1528">#endif</a>
<a name="ln1529"> </a>
<a name="ln1530">    draw_border();</a>
<a name="ln1531"> </a>
<a name="ln1532">    you.redraw_title        = true;</a>
<a name="ln1533">    you.redraw_hit_points   = true;</a>
<a name="ln1534">    you.redraw_magic_points = true;</a>
<a name="ln1535">    you.redraw_stats.init(true);</a>
<a name="ln1536">    you.redraw_armour_class  = true;</a>
<a name="ln1537">    you.redraw_evasion       = true;</a>
<a name="ln1538">    you.redraw_experience    = true;</a>
<a name="ln1539">    you.wield_change         = true;</a>
<a name="ln1540">    you.redraw_quiver        = true;</a>
<a name="ln1541">    you.redraw_status_lights = true;</a>
<a name="ln1542"> </a>
<a name="ln1543">    print_stats();</a>
<a name="ln1544"> </a>
<a name="ln1545">    {</a>
<a name="ln1546">        no_notes nx;</a>
<a name="ln1547">        print_stats_level();</a>
<a name="ln1548">#ifdef DGL_SIMPLE_MESSAGING</a>
<a name="ln1549">        update_message_status();</a>
<a name="ln1550">#endif</a>
<a name="ln1551">        update_turn_count();</a>
<a name="ln1552">    }</a>
<a name="ln1553"> </a>
<a name="ln1554">    if (Options.messages_at_top)</a>
<a name="ln1555">    {</a>
<a name="ln1556">        display_message_window();</a>
<a name="ln1557">        viewwindow(show_updates);</a>
<a name="ln1558">    }</a>
<a name="ln1559">    else</a>
<a name="ln1560">    {</a>
<a name="ln1561">        viewwindow(show_updates);</a>
<a name="ln1562">        display_message_window();</a>
<a name="ln1563">    }</a>
<a name="ln1564">    // normalize the cursor region independent of messages_at_top</a>
<a name="ln1565">    set_cursor_region(GOTO_MSG);</a>
<a name="ln1566"> </a>
<a name="ln1567">    update_screen();</a>
<a name="ln1568">}</a>
<a name="ln1569"> </a>
<a name="ln1570">// ----------------------------------------------------------------------</a>
<a name="ln1571">// Monster pane</a>
<a name="ln1572">// ----------------------------------------------------------------------</a>
<a name="ln1573"> </a>
<a name="ln1574">static string _get_monster_name(const monster_info&amp; mi, int count, bool fullname)</a>
<a name="ln1575">{</a>
<a name="ln1576">    string desc = &quot;&quot;;</a>
<a name="ln1577"> </a>
<a name="ln1578">    const char * const adj = mi.attitude == ATT_FRIENDLY ? &quot;friendly&quot;</a>
<a name="ln1579">                           : mi.attitude == ATT_HOSTILE  ? nullptr</a>
<a name="ln1580">                                                         : &quot;neutral&quot;;</a>
<a name="ln1581"> </a>
<a name="ln1582">    string monpane_desc;</a>
<a name="ln1583">    int col;</a>
<a name="ln1584">    mi.to_string(count, monpane_desc, col, fullname, adj);</a>
<a name="ln1585"> </a>
<a name="ln1586">    if (count == 1)</a>
<a name="ln1587">    {</a>
<a name="ln1588">        if (!mi.is(MB_NAME_THE))</a>
<a name="ln1589">            desc = (is_vowel(monpane_desc[0]) ? &quot;an &quot; : &quot;a &quot;) + desc;</a>
<a name="ln1590">        else if (adj || !mi.is(MB_NAME_UNQUALIFIED))</a>
<a name="ln1591">            desc = &quot;the &quot; + desc;</a>
<a name="ln1592">    }</a>
<a name="ln1593"> </a>
<a name="ln1594">    desc += monpane_desc;</a>
<a name="ln1595">    return desc;</a>
<a name="ln1596">}</a>
<a name="ln1597"> </a>
<a name="ln1598">// If past is true, the messages should be printed in the past tense</a>
<a name="ln1599">// because they're needed for the morgue dump.</a>
<a name="ln1600">string mpr_monster_list(bool past)</a>
<a name="ln1601">{</a>
<a name="ln1602">    // Get monsters via the monster_pane_info, sorted by difficulty.</a>
<a name="ln1603">    vector&lt;monster_info&gt; mons;</a>
<a name="ln1604">    get_monster_info(mons);</a>
<a name="ln1605"> </a>
<a name="ln1606">    string msg = &quot;&quot;;</a>
<a name="ln1607">    if (mons.empty())</a>
<a name="ln1608">    {</a>
<a name="ln1609">        msg  = &quot;There &quot;;</a>
<a name="ln1610">        msg += (past ? &quot;were&quot; : &quot;are&quot;);</a>
<a name="ln1611">        msg += &quot; no monsters in sight!&quot;;</a>
<a name="ln1612"> </a>
<a name="ln1613">        return msg;</a>
<a name="ln1614">    }</a>
<a name="ln1615"> </a>
<a name="ln1616">    vector&lt;string&gt; describe;</a>
<a name="ln1617"> </a>
<a name="ln1618">    int count = 0;</a>
<a name="ln1619">    for (unsigned int i = 0; i &lt; mons.size(); ++i)</a>
<a name="ln1620">    {</a>
<a name="ln1621">        if (i &gt; 0 &amp;&amp; monster_info::less_than(mons[i-1], mons[i]))</a>
<a name="ln1622">        {</a>
<a name="ln1623">            describe.push_back(_get_monster_name(mons[i-1], count, true).c_str());</a>
<a name="ln1624">            count = 0;</a>
<a name="ln1625">        }</a>
<a name="ln1626">        count++;</a>
<a name="ln1627">    }</a>
<a name="ln1628"> </a>
<a name="ln1629">    describe.push_back(_get_monster_name(mons[mons.size()-1], count, true).c_str());</a>
<a name="ln1630"> </a>
<a name="ln1631">    msg = &quot;You &quot;;</a>
<a name="ln1632">    msg += (past ? &quot;could&quot; : &quot;can&quot;);</a>
<a name="ln1633">    msg += &quot; see &quot;;</a>
<a name="ln1634"> </a>
<a name="ln1635">    if (describe.size() == 1)</a>
<a name="ln1636">        msg += describe[0];</a>
<a name="ln1637">    else</a>
<a name="ln1638">        msg += comma_separated_line(describe.begin(), describe.end());</a>
<a name="ln1639">    msg += &quot;.&quot;;</a>
<a name="ln1640"> </a>
<a name="ln1641">    return msg;</a>
<a name="ln1642">}</a>
<a name="ln1643"> </a>
<a name="ln1644">#ifndef USE_TILE_LOCAL</a>
<a name="ln1645">static void _print_next_monster_desc(const vector&lt;monster_info&gt;&amp; mons,</a>
<a name="ln1646">                                     int&amp; start, bool zombified = false)</a>
<a name="ln1647">{</a>
<a name="ln1648">    // Skip forward to past the end of the range of identical monsters.</a>
<a name="ln1649">    unsigned int end;</a>
<a name="ln1650">    for (end = start + 1; end &lt; mons.size(); ++end)</a>
<a name="ln1651">    {</a>
<a name="ln1652">        // Array is sorted, so if !(m1 &lt; m2), m1 and m2 are &quot;equal&quot;.</a>
<a name="ln1653">        if (monster_info::less_than(mons[start], mons[end], zombified, zombified))</a>
<a name="ln1654">            break;</a>
<a name="ln1655">    }</a>
<a name="ln1656">    // Postcondition: all monsters in [start, end) are &quot;equal&quot;</a>
<a name="ln1657"> </a>
<a name="ln1658">    // Print info on the monsters we've found.</a>
<a name="ln1659">    {</a>
<a name="ln1660">        int printed = 0;</a>
<a name="ln1661"> </a>
<a name="ln1662">        // One glyph for each monster.</a>
<a name="ln1663">        for (unsigned int i_mon = start; i_mon &lt; end; i_mon++)</a>
<a name="ln1664">        {</a>
<a name="ln1665">            monster_info mi = mons[i_mon];</a>
<a name="ln1666">            cglyph_t g = get_mons_glyph(mi);</a>
<a name="ln1667">            textcolour(g.col);</a>
<a name="ln1668">            CPRINTF(&quot;%s&quot;, stringize_glyph(g.ch).c_str());</a>
<a name="ln1669">            ++printed;</a>
<a name="ln1670"> </a>
<a name="ln1671">            // Printing too many looks pretty bad, though.</a>
<a name="ln1672">            if (i_mon &gt; 6)</a>
<a name="ln1673">                break;</a>
<a name="ln1674">        }</a>
<a name="ln1675">        textcolour(LIGHTGREY);</a>
<a name="ln1676"> </a>
<a name="ln1677">        const int count = (end - start);</a>
<a name="ln1678"> </a>
<a name="ln1679">        if (count == 1)  // Print an icon representing damage level.</a>
<a name="ln1680">        {</a>
<a name="ln1681">            CPRINTF(&quot; &quot;);</a>
<a name="ln1682"> </a>
<a name="ln1683">            monster_info mi = mons[start];</a>
<a name="ln1684">#ifdef TARGET_OS_WINDOWS</a>
<a name="ln1685">            textcolour(real_colour(dam_colour(mi) | COLFLAG_ITEM_HEAP));</a>
<a name="ln1686">#else</a>
<a name="ln1687">            textcolour(real_colour(dam_colour(mi) | COLFLAG_REVERSE));</a>
<a name="ln1688">#endif</a>
<a name="ln1689">            CPRINTF(&quot; &quot;);</a>
<a name="ln1690">            textbackground(BLACK);</a>
<a name="ln1691">            textcolour(LIGHTGREY);</a>
<a name="ln1692">            CPRINTF(&quot; &quot;);</a>
<a name="ln1693">            printed += 3;</a>
<a name="ln1694">        }</a>
<a name="ln1695">        else</a>
<a name="ln1696">        {</a>
<a name="ln1697">            textcolour(LIGHTGREY);</a>
<a name="ln1698">            CPRINTF(&quot;  &quot;);</a>
<a name="ln1699">            printed += 2;</a>
<a name="ln1700">        }</a>
<a name="ln1701"> </a>
<a name="ln1702">        if (printed &lt; crawl_view.mlistsz.x)</a>
<a name="ln1703">        {</a>
<a name="ln1704">            int desc_colour;</a>
<a name="ln1705">            string desc;</a>
<a name="ln1706">            mons[start].to_string(count, desc, desc_colour, zombified);</a>
<a name="ln1707">            textcolour(desc_colour);</a>
<a name="ln1708">            desc.resize(crawl_view.mlistsz.x-printed, ' ');</a>
<a name="ln1709">            CPRINTF(&quot;%s&quot;, desc.c_str());</a>
<a name="ln1710">        }</a>
<a name="ln1711">    }</a>
<a name="ln1712"> </a>
<a name="ln1713">    // Set start to the next un-described monster.</a>
<a name="ln1714">    start = end;</a>
<a name="ln1715">    textcolour(LIGHTGREY);</a>
<a name="ln1716">}</a>
<a name="ln1717">#endif</a>
<a name="ln1718"> </a>
<a name="ln1719">#ifndef USE_TILE_LOCAL</a>
<a name="ln1720">// #define BOTTOM_JUSTIFY_MONSTER_LIST</a>
<a name="ln1721">// Returns -1 if the monster list is empty, 0 if there are so many monsters</a>
<a name="ln1722">// they have to be consolidated, and 1 otherwise.</a>
<a name="ln1723">int update_monster_pane()</a>
<a name="ln1724">{</a>
<a name="ln1725">    if (!map_bounds(you.pos()) &amp;&amp; !crawl_state.game_is_arena())</a>
<a name="ln1726">        return -1;</a>
<a name="ln1727"> </a>
<a name="ln1728">    const int max_print = crawl_view.mlistsz.y;</a>
<a name="ln1729">    textbackground(BLACK);</a>
<a name="ln1730"> </a>
<a name="ln1731">    if (max_print &lt;= 0)</a>
<a name="ln1732">        return -1;</a>
<a name="ln1733"> </a>
<a name="ln1734">    vector&lt;monster_info&gt; mons;</a>
<a name="ln1735">    get_monster_info(mons);</a>
<a name="ln1736"> </a>
<a name="ln1737">    // Count how many groups of monsters there are.</a>
<a name="ln1738">    unsigned int lines_needed = mons.size();</a>
<a name="ln1739">    for (unsigned int i = 1; i &lt; mons.size(); i++)</a>
<a name="ln1740">        if (!monster_info::less_than(mons[i-1], mons[i]))</a>
<a name="ln1741">            --lines_needed;</a>
<a name="ln1742"> </a>
<a name="ln1743">    bool full_info = true;</a>
<a name="ln1744">    if (lines_needed &gt; (unsigned int) max_print)</a>
<a name="ln1745">    {</a>
<a name="ln1746">        full_info = false;</a>
<a name="ln1747"> </a>
<a name="ln1748">        // Use type names rather than full names (&quot;small zombie&quot; vs</a>
<a name="ln1749">        // &quot;rat zombie&quot;) in order to take up fewer lines.</a>
<a name="ln1750"> </a>
<a name="ln1751">        lines_needed = mons.size();</a>
<a name="ln1752">        for (unsigned int i = 1; i &lt; mons.size(); i++)</a>
<a name="ln1753">            if (!monster_info::less_than(mons[i-1], mons[i], false, false))</a>
<a name="ln1754">                --lines_needed;</a>
<a name="ln1755">    }</a>
<a name="ln1756"> </a>
<a name="ln1757">#ifdef BOTTOM_JUSTIFY_MONSTER_LIST</a>
<a name="ln1758">    const int skip_lines = max&lt;int&gt;(0, crawl_view.mlistsz.y-lines_needed);</a>
<a name="ln1759">#else</a>
<a name="ln1760">    const int skip_lines = 0;</a>
<a name="ln1761">#endif</a>
<a name="ln1762"> </a>
<a name="ln1763">    // Print the monsters!</a>
<a name="ln1764">    string blank;</a>
<a name="ln1765">    blank.resize(crawl_view.mlistsz.x, ' ');</a>
<a name="ln1766">    int i_mons = 0;</a>
<a name="ln1767">    for (int i_print = 0; i_print &lt; max_print; ++i_print)</a>
<a name="ln1768">    {</a>
<a name="ln1769">        CGOTOXY(1, 1 + i_print, GOTO_MLIST);</a>
<a name="ln1770">        // i_mons is incremented by _print_next_monster_desc</a>
<a name="ln1771">        if (i_print &gt;= skip_lines &amp;&amp; i_mons &lt; (int) mons.size())</a>
<a name="ln1772">            _print_next_monster_desc(mons, i_mons, full_info);</a>
<a name="ln1773">        else</a>
<a name="ln1774">            CPRINTF(&quot;%s&quot;, blank.c_str());</a>
<a name="ln1775">    }</a>
<a name="ln1776"> </a>
<a name="ln1777">    if (i_mons &lt; (int)mons.size())</a>
<a name="ln1778">    {</a>
<a name="ln1779">        // Didn't get to all of them.</a>
<a name="ln1780">        CGOTOXY(crawl_view.mlistsz.x - 3, crawl_view.mlistsz.y, GOTO_MLIST);</a>
<a name="ln1781">        textbackground(COLFLAG_REVERSE);</a>
<a name="ln1782">        CPRINTF(&quot;(…)&quot;);</a>
<a name="ln1783">        textbackground(BLACK);</a>
<a name="ln1784">    }</a>
<a name="ln1785"> </a>
<a name="ln1786">    if (mons.empty())</a>
<a name="ln1787">        return -1;</a>
<a name="ln1788"> </a>
<a name="ln1789">    return full_info;</a>
<a name="ln1790">}</a>
<a name="ln1791">#else</a>
<a name="ln1792">// FIXME: Implement this for Tiles!</a>
<a name="ln1793">int update_monster_pane()</a>
<a name="ln1794">{</a>
<a name="ln1795">    return false;</a>
<a name="ln1796">}</a>
<a name="ln1797">#endif</a>
<a name="ln1798"> </a>
<a name="ln1799">// Converts a numeric resistance to its symbolic counterpart.</a>
<a name="ln1800">// Can handle any maximum level. The default is for single level resistances</a>
<a name="ln1801">// (the most common case). Negative resistances are allowed.</a>
<a name="ln1802">// Resistances with a maximum of up to 4 are spaced (arbitrary choice), and</a>
<a name="ln1803">// starting at 5 levels, they are continuous.</a>
<a name="ln1804">// params:</a>
<a name="ln1805">//  level : actual resistance level</a>
<a name="ln1806">//  max : maximum number of levels of the resistance</a>
<a name="ln1807">static string _itosym(int level, int max = 1)</a>
<a name="ln1808">{</a>
<a name="ln1809">    if (max &lt; 1)</a>
<a name="ln1810">        return &quot;&quot;;</a>
<a name="ln1811"> </a>
<a name="ln1812">    string sym;</a>
<a name="ln1813">    bool spacing = (max &gt;= 5) ? false : true;</a>
<a name="ln1814"> </a>
<a name="ln1815">    while (max &gt; 0)</a>
<a name="ln1816">    {</a>
<a name="ln1817">        if (level == 0)</a>
<a name="ln1818">            sym += &quot;.&quot;;</a>
<a name="ln1819">        else if (level &gt; 0)</a>
<a name="ln1820">        {</a>
<a name="ln1821">            sym += &quot;+&quot;;</a>
<a name="ln1822">            --level;</a>
<a name="ln1823">        }</a>
<a name="ln1824">        else // negative resistance</a>
<a name="ln1825">        {</a>
<a name="ln1826">            sym += &quot;x&quot;;</a>
<a name="ln1827">            ++level;</a>
<a name="ln1828">        }</a>
<a name="ln1829">        sym += (spacing) ? &quot; &quot; : &quot;&quot;;</a>
<a name="ln1830">        --max;</a>
<a name="ln1831">    }</a>
<a name="ln1832">    return sym;</a>
<a name="ln1833">}</a>
<a name="ln1834"> </a>
<a name="ln1835">static const char *s_equip_slot_names[] =</a>
<a name="ln1836">{</a>
<a name="ln1837">    &quot;Weapon&quot;, &quot;Cloak&quot;,  &quot;Helmet&quot;, &quot;Gloves&quot;, &quot;Boots&quot;,</a>
<a name="ln1838">    &quot;Shield&quot;, &quot;Armour&quot;, &quot;Left Ring&quot;, &quot;Right Ring&quot;, &quot;Amulet&quot;,</a>
<a name="ln1839">    &quot;First Ring&quot;, &quot;Second Ring&quot;, &quot;Third Ring&quot;, &quot;Fourth Ring&quot;,</a>
<a name="ln1840">    &quot;Fifth Ring&quot;, &quot;Sixth Ring&quot;, &quot;Seventh Ring&quot;, &quot;Eighth Ring&quot;,</a>
<a name="ln1841">    &quot;Amulet Ring&quot;</a>
<a name="ln1842">};</a>
<a name="ln1843"> </a>
<a name="ln1844">const char *equip_slot_to_name(int equip)</a>
<a name="ln1845">{</a>
<a name="ln1846">    COMPILE_CHECK(ARRAYSZ(s_equip_slot_names) == NUM_EQUIP);</a>
<a name="ln1847"> </a>
<a name="ln1848">    if (equip == EQ_RINGS</a>
<a name="ln1849">        || equip &gt;= EQ_FIRST_JEWELLERY &amp;&amp; equip &lt;= EQ_LAST_JEWELLERY &amp;&amp; equip != EQ_AMULET)</a>
<a name="ln1850">    {</a>
<a name="ln1851">        return &quot;Ring&quot;;</a>
<a name="ln1852">    }</a>
<a name="ln1853"> </a>
<a name="ln1854">    if (equip == EQ_BOOTS</a>
<a name="ln1855">        &amp;&amp; (you.species == SP_CENTAUR || you.species == SP_NAGA))</a>
<a name="ln1856">    {</a>
<a name="ln1857">        return &quot;Barding&quot;;</a>
<a name="ln1858">    }</a>
<a name="ln1859"> </a>
<a name="ln1860">    if (equip &lt; EQ_FIRST_EQUIP || equip &gt;= NUM_EQUIP)</a>
<a name="ln1861">        return &quot;&quot;;</a>
<a name="ln1862"> </a>
<a name="ln1863">    return s_equip_slot_names[equip];</a>
<a name="ln1864">}</a>
<a name="ln1865"> </a>
<a name="ln1866">int equip_name_to_slot(const char *s)</a>
<a name="ln1867">{</a>
<a name="ln1868">    for (int i = EQ_FIRST_EQUIP; i &lt; NUM_EQUIP; ++i)</a>
<a name="ln1869">        if (!strcasecmp(s_equip_slot_names[i], s))</a>
<a name="ln1870">            return i;</a>
<a name="ln1871"> </a>
<a name="ln1872">    return -1;</a>
<a name="ln1873">}</a>
<a name="ln1874"> </a>
<a name="ln1875">// Colour the string according to the level of an ability/resistance.</a>
<a name="ln1876">// Take maximum possible level into account.</a>
<a name="ln1877">static const char* _determine_colour_string(int level, int max_level)</a>
<a name="ln1878">{</a>
<a name="ln1879">    // No colouring for larger bars.</a>
<a name="ln1880">    if (max_level &gt; 3)</a>
<a name="ln1881">        return &quot;&lt;lightgrey&gt;&quot;;</a>
<a name="ln1882"> </a>
<a name="ln1883">    switch (level)</a>
<a name="ln1884">    {</a>
<a name="ln1885">    case 3:</a>
<a name="ln1886">    case 2:</a>
<a name="ln1887">        if (max_level &gt; 1)</a>
<a name="ln1888">            return &quot;&lt;lightgreen&gt;&quot;;</a>
<a name="ln1889">        // else fall-through</a>
<a name="ln1890">    case 1:</a>
<a name="ln1891">        return &quot;&lt;green&gt;&quot;;</a>
<a name="ln1892">    case -2:</a>
<a name="ln1893">    case -3:</a>
<a name="ln1894">        if (max_level &gt; 1)</a>
<a name="ln1895">            return &quot;&lt;lightred&gt;&quot;;</a>
<a name="ln1896">        // else fall-through</a>
<a name="ln1897">    case -1:</a>
<a name="ln1898">        return &quot;&lt;red&gt;&quot;;</a>
<a name="ln1899">    default:</a>
<a name="ln1900">        return &quot;&lt;lightgrey&gt;&quot;;</a>
<a name="ln1901">    }</a>
<a name="ln1902">}</a>
<a name="ln1903"> </a>
<a name="ln1904">int stealth_breakpoint(int stealth)</a>
<a name="ln1905">{</a>
<a name="ln1906">    if (stealth == 0)</a>
<a name="ln1907">        return 0;</a>
<a name="ln1908">    else if (stealth &gt;= 500)</a>
<a name="ln1909">        return 10;</a>
<a name="ln1910">    else if (stealth &gt;= 450)</a>
<a name="ln1911">        return 9;</a>
<a name="ln1912">    else</a>
<a name="ln1913">        return 1 + stealth / STEALTH_PIP;</a>
<a name="ln1914">}</a>
<a name="ln1915"> </a>
<a name="ln1916">static string _stealth_bar(int sw)</a>
<a name="ln1917">{</a>
<a name="ln1918">    string bar;</a>
<a name="ln1919">    //no colouring</a>
<a name="ln1920">    bar += _determine_colour_string(0, 5);</a>
<a name="ln1921">    bar += &quot;Stlth    &quot;;</a>
<a name="ln1922">    const int stealth_num = stealth_breakpoint(player_stealth());</a>
<a name="ln1923">    for (int i = 0; i &lt; stealth_num; i++)</a>
<a name="ln1924">        bar += &quot;+&quot;;</a>
<a name="ln1925">    for (int i = 0; i &lt; 10 - stealth_num; i++)</a>
<a name="ln1926">        bar += &quot;.&quot;;</a>
<a name="ln1927">    bar += &quot;\n&quot;;</a>
<a name="ln1928">    linebreak_string(bar, sw);</a>
<a name="ln1929">    return bar;</a>
<a name="ln1930">}</a>
<a name="ln1931">static string _status_mut_rune_list(int sw);</a>
<a name="ln1932"> </a>
<a name="ln1933">// helper for print_overview_screen</a>
<a name="ln1934">static void _print_overview_screen_equip(column_composer&amp; cols,</a>
<a name="ln1935">                                         vector&lt;char&gt;&amp; equip_chars,</a>
<a name="ln1936">                                         int sw)</a>
<a name="ln1937">{</a>
<a name="ln1938">    sw = min(max(sw, 79), 640);</a>
<a name="ln1939"> </a>
<a name="ln1940">    for (equipment_type eqslot : e_order)</a>
<a name="ln1941">    {</a>
<a name="ln1942">        if (you.species == SP_OCTOPODE</a>
<a name="ln1943">            &amp;&amp; eqslot != EQ_WEAPON</a>
<a name="ln1944">            &amp;&amp; !you_can_wear(eqslot))</a>
<a name="ln1945">        {</a>
<a name="ln1946">            continue;</a>
<a name="ln1947">        }</a>
<a name="ln1948"> </a>
<a name="ln1949">        if (you.species != SP_OCTOPODE</a>
<a name="ln1950">            &amp;&amp; eqslot &gt;= EQ_RING_ONE &amp;&amp; eqslot &lt;= EQ_RING_EIGHT)</a>
<a name="ln1951">        {</a>
<a name="ln1952">            continue;</a>
<a name="ln1953">        }</a>
<a name="ln1954"> </a>
<a name="ln1955">        if (eqslot == EQ_RING_AMULET &amp;&amp; !you_can_wear(eqslot))</a>
<a name="ln1956">            continue;</a>
<a name="ln1957"> </a>
<a name="ln1958">        const string slot_name_lwr = lowercase_string(equip_slot_to_name(eqslot));</a>
<a name="ln1959"> </a>
<a name="ln1960">        string str;</a>
<a name="ln1961"> </a>
<a name="ln1962">        if (you.slot_item(eqslot))</a>
<a name="ln1963">        {</a>
<a name="ln1964">            // The player has something equipped.</a>
<a name="ln1965">            const item_def&amp; item = *you.slot_item(eqslot);</a>
<a name="ln1966">            const bool melded    = you.melded[eqslot];</a>
<a name="ln1967">            const string prefix = item_prefix(item);</a>
<a name="ln1968">            const int prefcol = menu_colour(item.name(DESC_INVENTORY), prefix);</a>
<a name="ln1969">            const int col = prefcol == -1 ? LIGHTGREY : prefcol;</a>
<a name="ln1970"> </a>
<a name="ln1971">            // Colour melded equipment dark grey.</a>
<a name="ln1972">            string colname = melded ? &quot;darkgrey&quot; : colour_to_str(col);</a>
<a name="ln1973"> </a>
<a name="ln1974">            const int item_idx   = you.equip[eqslot];</a>
<a name="ln1975">            const char equip_char = index_to_letter(item_idx);</a>
<a name="ln1976"> </a>
<a name="ln1977">            str = make_stringf(</a>
<a name="ln1978">                     &quot;&lt;w&gt;%c&lt;/w&gt; - &lt;%s&gt;%s%s&lt;/%s&gt;&quot;,</a>
<a name="ln1979">                     equip_char,</a>
<a name="ln1980">                     colname.c_str(),</a>
<a name="ln1981">                     melded ? &quot;melded &quot; : &quot;&quot;,</a>
<a name="ln1982">                     chop_string(item.name(DESC_PLAIN, true),</a>
<a name="ln1983">                                 melded ? sw - 43 : sw - 36, false).c_str(),</a>
<a name="ln1984">                     colname.c_str());</a>
<a name="ln1985">            equip_chars.push_back(equip_char);</a>
<a name="ln1986">        }</a>
<a name="ln1987">        else if (eqslot == EQ_WEAPON</a>
<a name="ln1988">                 &amp;&amp; you.skill(SK_UNARMED_COMBAT))</a>
<a name="ln1989">        {</a>
<a name="ln1990">            str = &quot;  - Unarmed&quot;;</a>
<a name="ln1991">        }</a>
<a name="ln1992">        else if (eqslot == EQ_WEAPON</a>
<a name="ln1993">                 &amp;&amp; you.form == transformation::blade_hands)</a>
<a name="ln1994">        {</a>
<a name="ln1995">            const bool plural = !you.get_mutation_level(MUT_MISSING_HAND);</a>
<a name="ln1996">            str = string(&quot;  - Blade Hand&quot;) + (plural ? &quot;s&quot; : &quot;&quot;);</a>
<a name="ln1997">        }</a>
<a name="ln1998">        else if (eqslot == EQ_BOOTS</a>
<a name="ln1999">                 &amp;&amp; (you.species == SP_NAGA || you.species == SP_CENTAUR))</a>
<a name="ln2000">        {</a>
<a name="ln2001">            str = &quot;&lt;darkgrey&gt;(no &quot; + slot_name_lwr + &quot;)&lt;/darkgrey&gt;&quot;;</a>
<a name="ln2002">        }</a>
<a name="ln2003">        else if (!you_can_wear(eqslot))</a>
<a name="ln2004">            str = &quot;&lt;darkgrey&gt;(&quot; + slot_name_lwr + &quot; unavailable)&lt;/darkgrey&gt;&quot;;</a>
<a name="ln2005">        else if (!you_can_wear(eqslot, true))</a>
<a name="ln2006">        {</a>
<a name="ln2007">            str = &quot;&lt;darkgrey&gt;(&quot; + slot_name_lwr +</a>
<a name="ln2008">                               &quot; currently unavailable)&lt;/darkgrey&gt;&quot;;</a>
<a name="ln2009">        }</a>
<a name="ln2010">        else if (you_can_wear(eqslot) == MB_MAYBE)</a>
<a name="ln2011">            str = &quot;&lt;darkgrey&gt;(&quot; + slot_name_lwr + &quot; restricted)&lt;/darkgrey&gt;&quot;;</a>
<a name="ln2012">        else</a>
<a name="ln2013">            str = &quot;&lt;darkgrey&gt;(no &quot; + slot_name_lwr + &quot;)&lt;/darkgrey&gt;&quot;;</a>
<a name="ln2014">        cols.add_formatted(2, str.c_str(), false);</a>
<a name="ln2015">    }</a>
<a name="ln2016">}</a>
<a name="ln2017"> </a>
<a name="ln2018">static string _overview_screen_title(int sw)</a>
<a name="ln2019">{</a>
<a name="ln2020">    string title = make_stringf(&quot; %s &quot;, player_title().c_str());</a>
<a name="ln2021"> </a>
<a name="ln2022">    string species_job = make_stringf(&quot;(%s %s)&quot;,</a>
<a name="ln2023">                                      species_name(you.species).c_str(),</a>
<a name="ln2024">                                      get_job_name(you.char_class));</a>
<a name="ln2025"> </a>
<a name="ln2026">    handle_real_time();</a>
<a name="ln2027">    string time_turns = make_stringf(&quot; Turns: %d, Time: &quot;, you.num_turns)</a>
<a name="ln2028">                      + make_time_string(you.real_time(), true);</a>
<a name="ln2029"> </a>
<a name="ln2030">    const int char_width = strwidth(species_job);</a>
<a name="ln2031">    const int title_width = strwidth(title);</a>
<a name="ln2032"> </a>
<a name="ln2033">    int linelength = strwidth(you.your_name) + title_width</a>
<a name="ln2034">                   + char_width + strwidth(time_turns);</a>
<a name="ln2035"> </a>
<a name="ln2036">    if (linelength &gt;= sw)</a>
<a name="ln2037">    {</a>
<a name="ln2038">        species_job = make_stringf(&quot;(%s%s)&quot;, get_species_abbrev(you.species),</a>
<a name="ln2039">                                             get_job_abbrev(you.char_class));</a>
<a name="ln2040">        linelength -= (char_width - strwidth(species_job));</a>
<a name="ln2041">    }</a>
<a name="ln2042"> </a>
<a name="ln2043">    // Still not enough?</a>
<a name="ln2044">    if (linelength &gt;= sw)</a>
<a name="ln2045">    {</a>
<a name="ln2046">        title = &quot; &quot;;</a>
<a name="ln2047">        linelength -= (title_width - 1);</a>
<a name="ln2048">    }</a>
<a name="ln2049"> </a>
<a name="ln2050">    string text;</a>
<a name="ln2051">    text = &quot;&lt;yellow&gt;&quot;;</a>
<a name="ln2052">    text += you.your_name;</a>
<a name="ln2053">    text += title;</a>
<a name="ln2054">    text += species_job;</a>
<a name="ln2055"> </a>
<a name="ln2056">    const int num_spaces = sw - linelength - 1;</a>
<a name="ln2057">    if (num_spaces &gt; 0)</a>
<a name="ln2058">        text += string(num_spaces, ' ');</a>
<a name="ln2059"> </a>
<a name="ln2060">    text += time_turns;</a>
<a name="ln2061">    text += &quot;&lt;/yellow&gt;\n&quot;;</a>
<a name="ln2062"> </a>
<a name="ln2063">    return text;</a>
<a name="ln2064">}</a>
<a name="ln2065"> </a>
<a name="ln2066">#ifdef WIZARD</a>
<a name="ln2067">static string _wiz_god_powers()</a>
<a name="ln2068">{</a>
<a name="ln2069">    string godpowers = god_name(you.religion);</a>
<a name="ln2070">    return make_stringf(&quot;%s %d (%d)&quot;, god_name(you.religion).c_str(),</a>
<a name="ln2071">                                      you.piety,</a>
<a name="ln2072">                                      you.duration[DUR_PIETY_POOL]);</a>
<a name="ln2073">}</a>
<a name="ln2074">#endif</a>
<a name="ln2075"> </a>
<a name="ln2076">static string _god_powers()</a>
<a name="ln2077">{</a>
<a name="ln2078">    if (you_worship(GOD_NO_GOD))</a>
<a name="ln2079">        return &quot;&quot;;</a>
<a name="ln2080"> </a>
<a name="ln2081">    const string name = god_name(you.religion);</a>
<a name="ln2082">    if (you_worship(GOD_GOZAG))</a>
<a name="ln2083">        return colour_string(name, _god_status_colour(god_colour(you.religion)));</a>
<a name="ln2084"> </a>
<a name="ln2085">    return colour_string(chop_string(name, 20, false)</a>
<a name="ln2086">              + &quot; [&quot; + _god_asterisks() + &quot;]&quot;,</a>
<a name="ln2087">              _god_status_colour(god_colour(you.religion)));</a>
<a name="ln2088">}</a>
<a name="ln2089"> </a>
<a name="ln2090">static string _god_asterisks()</a>
<a name="ln2091">{</a>
<a name="ln2092">    if (you_worship(GOD_NO_GOD))</a>
<a name="ln2093">        return &quot;&quot;;</a>
<a name="ln2094"> </a>
<a name="ln2095">    if (player_under_penance())</a>
<a name="ln2096">        return &quot;*&quot;;</a>
<a name="ln2097"> </a>
<a name="ln2098">    if (you_worship(GOD_GOZAG))</a>
<a name="ln2099">        return &quot;&quot;;</a>
<a name="ln2100"> </a>
<a name="ln2101">    if (you_worship(GOD_XOM))</a>
<a name="ln2102">    {</a>
<a name="ln2103">        const int p_rank = xom_favour_rank() - 1;</a>
<a name="ln2104">        if (p_rank &gt;= 0)</a>
<a name="ln2105">        {</a>
<a name="ln2106">            return string(p_rank, '.') + &quot;*&quot;</a>
<a name="ln2107">                   + string(NUM_PIETY_STARS - 1 - p_rank, '.');</a>
<a name="ln2108">        }</a>
<a name="ln2109">        else</a>
<a name="ln2110">            return string(NUM_PIETY_STARS, '.'); // very special plaything</a>
<a name="ln2111">    }</a>
<a name="ln2112">    else</a>
<a name="ln2113">    {</a>
<a name="ln2114">        const int prank = piety_rank();</a>
<a name="ln2115">        return string(prank, '*') + string(NUM_PIETY_STARS - prank, '.');</a>
<a name="ln2116">    }</a>
<a name="ln2117">}</a>
<a name="ln2118"> </a>
<a name="ln2119">/**</a>
<a name="ln2120"> * What colour should the god status display be?</a>
<a name="ln2121"> *</a>
<a name="ln2122"> * @param default_colour   The default colour, if not under penance or boredom.</a>
<a name="ln2123"> * @return                 A colour for the god status display.</a>
<a name="ln2124"> */</a>
<a name="ln2125">static int _god_status_colour(int default_colour)</a>
<a name="ln2126">{</a>
<a name="ln2127">    if (player_under_penance())</a>
<a name="ln2128">        return RED;</a>
<a name="ln2129"> </a>
<a name="ln2130">    if (you_worship(GOD_XOM) &amp;&amp; you.gift_timeout &lt;= 1)</a>
<a name="ln2131">        return you.gift_timeout ? RED : LIGHTRED;</a>
<a name="ln2132"> </a>
<a name="ln2133">    return default_colour;</a>
<a name="ln2134">}</a>
<a name="ln2135"> </a>
<a name="ln2136">static bool _player_statrotted()</a>
<a name="ln2137">{</a>
<a name="ln2138">    return you.strength(false) != you.max_strength()</a>
<a name="ln2139">        || you.intel(false) != you.max_intel()</a>
<a name="ln2140">        || you.dex(false) != you.max_dex();</a>
<a name="ln2141">}</a>
<a name="ln2142"> </a>
<a name="ln2143">static vector&lt;formatted_string&gt; _get_overview_stats()</a>
<a name="ln2144">{</a>
<a name="ln2145">    formatted_string entry;</a>
<a name="ln2146"> </a>
<a name="ln2147">    // 4 columns</a>
<a name="ln2148">    int col1 = 20;</a>
<a name="ln2149">    int col2 = 10;</a>
<a name="ln2150">    int col3 = 11;</a>
<a name="ln2151"> </a>
<a name="ln2152">    if (player_rotted())</a>
<a name="ln2153">        col1 += 1;</a>
<a name="ln2154"> </a>
<a name="ln2155">    if (_player_statrotted())</a>
<a name="ln2156">        col3 += 2;</a>
<a name="ln2157"> </a>
<a name="ln2158">    column_composer cols(4, col1, col1 + col2, col1 + col2 + col3);</a>
<a name="ln2159"> </a>
<a name="ln2160">    entry.textcolour(HUD_CAPTION_COLOUR);</a>
<a name="ln2161">    if (player_rotted())</a>
<a name="ln2162">        entry.cprintf(&quot;HP:   &quot;);</a>
<a name="ln2163">    else</a>
<a name="ln2164">        entry.cprintf(&quot;Health: &quot;);</a>
<a name="ln2165"> </a>
<a name="ln2166">    if (_boosted_hp())</a>
<a name="ln2167">        entry.textcolour(LIGHTBLUE);</a>
<a name="ln2168">    else</a>
<a name="ln2169">        entry.textcolour(HUD_VALUE_COLOUR);</a>
<a name="ln2170"> </a>
<a name="ln2171">    entry.cprintf(&quot;%d/%d&quot;, you.hp, you.hp_max);</a>
<a name="ln2172">    if (player_rotted())</a>
<a name="ln2173">        entry.cprintf(&quot; (%d)&quot;, get_real_hp(true, false));</a>
<a name="ln2174"> </a>
<a name="ln2175">    cols.add_formatted(0, entry.to_colour_string(), false);</a>
<a name="ln2176">    entry.clear();</a>
<a name="ln2177"> </a>
<a name="ln2178">    entry.textcolour(HUD_CAPTION_COLOUR);</a>
<a name="ln2179">    if (player_rotted())</a>
<a name="ln2180">        entry.cprintf(&quot;MP:   &quot;);</a>
<a name="ln2181">    else</a>
<a name="ln2182">        entry.cprintf(&quot;Magic:  &quot;);</a>
<a name="ln2183"> </a>
<a name="ln2184">    if (_boosted_mp())</a>
<a name="ln2185">        entry.textcolour(LIGHTBLUE);</a>
<a name="ln2186">    else</a>
<a name="ln2187">        entry.textcolour(HUD_VALUE_COLOUR);</a>
<a name="ln2188"> </a>
<a name="ln2189">    entry.cprintf(&quot;%d/%d&quot;, you.magic_points, you.max_magic_points);</a>
<a name="ln2190">    if (you.species == SP_DEEP_DWARF</a>
<a name="ln2191">        &amp;&amp; get_real_mp(false) != you.max_magic_points)</a>
<a name="ln2192">    {</a>
<a name="ln2193">        entry.cprintf(&quot; (%d)&quot;, get_real_mp(false));</a>
<a name="ln2194">    }</a>
<a name="ln2195"> </a>
<a name="ln2196">    cols.add_formatted(0, entry.to_colour_string(), false);</a>
<a name="ln2197">    entry.clear();</a>
<a name="ln2198"> </a>
<a name="ln2199">    entry.textcolour(HUD_CAPTION_COLOUR);</a>
<a name="ln2200">    if (player_rotted())</a>
<a name="ln2201">        entry.cprintf(&quot;Gold: &quot;);</a>
<a name="ln2202">    else</a>
<a name="ln2203">        entry.cprintf(&quot;Gold:   &quot;);</a>
<a name="ln2204"> </a>
<a name="ln2205">    entry.textcolour(HUD_VALUE_COLOUR);</a>
<a name="ln2206"> </a>
<a name="ln2207">    entry.cprintf(&quot;%d&quot;, you.gold);</a>
<a name="ln2208"> </a>
<a name="ln2209">    cols.add_formatted(0, entry.to_colour_string(), false);</a>
<a name="ln2210">    entry.clear();</a>
<a name="ln2211"> </a>
<a name="ln2212">    entry.textcolour(HUD_CAPTION_COLOUR);</a>
<a name="ln2213">    entry.cprintf(&quot;AC: &quot;);</a>
<a name="ln2214"> </a>
<a name="ln2215">    if (_boosted_ac())</a>
<a name="ln2216">        entry.textcolour(LIGHTBLUE);</a>
<a name="ln2217">    else</a>
<a name="ln2218">        entry.textcolour(HUD_VALUE_COLOUR);</a>
<a name="ln2219"> </a>
<a name="ln2220">    entry.cprintf(&quot;%2d&quot;, you.armour_class());</a>
<a name="ln2221"> </a>
<a name="ln2222">    cols.add_formatted(1, entry.to_colour_string(), false);</a>
<a name="ln2223">    entry.clear();</a>
<a name="ln2224"> </a>
<a name="ln2225">    entry.textcolour(HUD_CAPTION_COLOUR);</a>
<a name="ln2226">    entry.cprintf(&quot;EV: &quot;);</a>
<a name="ln2227"> </a>
<a name="ln2228">    if (_boosted_ev())</a>
<a name="ln2229">        entry.textcolour(LIGHTBLUE);</a>
<a name="ln2230">    else</a>
<a name="ln2231">        entry.textcolour(HUD_VALUE_COLOUR);</a>
<a name="ln2232"> </a>
<a name="ln2233">    entry.cprintf(&quot;%2d&quot;, you.evasion());</a>
<a name="ln2234"> </a>
<a name="ln2235">    cols.add_formatted(1, entry.to_colour_string(), false);</a>
<a name="ln2236">    entry.clear();</a>
<a name="ln2237"> </a>
<a name="ln2238">    entry.textcolour(HUD_CAPTION_COLOUR);</a>
<a name="ln2239">    entry.cprintf(&quot;SH: &quot;);</a>
<a name="ln2240"> </a>
<a name="ln2241">    if (_boosted_sh())</a>
<a name="ln2242">        entry.textcolour(LIGHTBLUE);</a>
<a name="ln2243">    else</a>
<a name="ln2244">        entry.textcolour(HUD_VALUE_COLOUR);</a>
<a name="ln2245"> </a>
<a name="ln2246">    entry.cprintf(&quot;%2d&quot;, player_displayed_shield_class());</a>
<a name="ln2247"> </a>
<a name="ln2248">    cols.add_formatted(1, entry.to_colour_string(), false);</a>
<a name="ln2249">    entry.clear();</a>
<a name="ln2250"> </a>
<a name="ln2251">    entry.textcolour(HUD_CAPTION_COLOUR);</a>
<a name="ln2252">    entry.cprintf(&quot;Str: &quot;);</a>
<a name="ln2253"> </a>
<a name="ln2254">    entry.textcolour(_get_stat_colour(STAT_STR));</a>
<a name="ln2255"> </a>
<a name="ln2256">    entry.cprintf(&quot;%2d&quot;, you.strength(false));</a>
<a name="ln2257">    if (you.strength(false) != you.max_strength())</a>
<a name="ln2258">        entry.cprintf(&quot; (%d)&quot;, you.max_strength());</a>
<a name="ln2259"> </a>
<a name="ln2260">    cols.add_formatted(2, entry.to_colour_string(), false);</a>
<a name="ln2261">    entry.clear();</a>
<a name="ln2262"> </a>
<a name="ln2263">    entry.textcolour(HUD_CAPTION_COLOUR);</a>
<a name="ln2264">    entry.cprintf(&quot;Int: &quot;);</a>
<a name="ln2265"> </a>
<a name="ln2266">    entry.textcolour(_get_stat_colour(STAT_INT));</a>
<a name="ln2267"> </a>
<a name="ln2268">    entry.cprintf(&quot;%2d&quot;, you.intel(false));</a>
<a name="ln2269">    if (you.intel(false) != you.max_intel())</a>
<a name="ln2270">        entry.cprintf(&quot; (%d)&quot;, you.max_intel());</a>
<a name="ln2271"> </a>
<a name="ln2272">    cols.add_formatted(2, entry.to_colour_string(), false);</a>
<a name="ln2273">    entry.clear();</a>
<a name="ln2274"> </a>
<a name="ln2275">    entry.textcolour(HUD_CAPTION_COLOUR);</a>
<a name="ln2276">    entry.cprintf(&quot;Dex: &quot;);</a>
<a name="ln2277"> </a>
<a name="ln2278">    entry.textcolour(_get_stat_colour(STAT_DEX));</a>
<a name="ln2279"> </a>
<a name="ln2280">    entry.cprintf(&quot;%2d&quot;, you.dex(false));</a>
<a name="ln2281">    if (you.dex(false) != you.max_dex())</a>
<a name="ln2282">        entry.cprintf(&quot; (%d)&quot;, you.max_dex());</a>
<a name="ln2283"> </a>
<a name="ln2284">    cols.add_formatted(2, entry.to_colour_string(), false);</a>
<a name="ln2285">    entry.clear();</a>
<a name="ln2286"> </a>
<a name="ln2287">    entry.textcolour(HUD_CAPTION_COLOUR);</a>
<a name="ln2288">    entry.cprintf(&quot;XL:     &quot;);</a>
<a name="ln2289"> </a>
<a name="ln2290">    entry.textcolour(HUD_VALUE_COLOUR);</a>
<a name="ln2291">    entry.cprintf(&quot;%d&quot;, you.experience_level);</a>
<a name="ln2292"> </a>
<a name="ln2293">    if (you.experience_level &lt; you.get_max_xl())</a>
<a name="ln2294">    {</a>
<a name="ln2295">        entry.textcolour(HUD_CAPTION_COLOUR);</a>
<a name="ln2296">        entry.cprintf(&quot;   Next: &quot;);</a>
<a name="ln2297"> </a>
<a name="ln2298">        entry.textcolour(HUD_VALUE_COLOUR);</a>
<a name="ln2299">        entry.cprintf(&quot;%d%%&quot;, get_exp_progress());</a>
<a name="ln2300">    }</a>
<a name="ln2301"> </a>
<a name="ln2302">    cols.add_formatted(3, entry.to_colour_string(), false);</a>
<a name="ln2303">    entry.clear();</a>
<a name="ln2304"> </a>
<a name="ln2305">    entry.textcolour(HUD_CAPTION_COLOUR);</a>
<a name="ln2306">    entry.cprintf(&quot;God:    &quot;);</a>
<a name="ln2307"> </a>
<a name="ln2308">    entry.textcolour(HUD_VALUE_COLOUR);</a>
<a name="ln2309"> </a>
<a name="ln2310">    string godpowers = _god_powers();</a>
<a name="ln2311">#ifdef WIZARD</a>
<a name="ln2312">    if (you.wizard)</a>
<a name="ln2313">        godpowers = _wiz_god_powers();</a>
<a name="ln2314">#endif</a>
<a name="ln2315">    entry += formatted_string::parse_string(godpowers);</a>
<a name="ln2316"> </a>
<a name="ln2317">    cols.add_formatted(3, entry.to_colour_string(), false);</a>
<a name="ln2318">    entry.clear();</a>
<a name="ln2319"> </a>
<a name="ln2320">    entry.textcolour(HUD_CAPTION_COLOUR);</a>
<a name="ln2321">    entry.cprintf(&quot;Spells: &quot;);</a>
<a name="ln2322"> </a>
<a name="ln2323">    entry.textcolour(HUD_VALUE_COLOUR);</a>
<a name="ln2324">    entry.cprintf(&quot;%d/%d levels left&quot;,</a>
<a name="ln2325">                  player_spell_levels(), player_total_spell_levels());</a>
<a name="ln2326"> </a>
<a name="ln2327">    cols.add_formatted(3, entry.to_colour_string(), false);</a>
<a name="ln2328">    entry.clear();</a>
<a name="ln2329"> </a>
<a name="ln2330">    if (you.species == SP_FELID)</a>
<a name="ln2331">    {</a>
<a name="ln2332">        entry.textcolour(HUD_CAPTION_COLOUR);</a>
<a name="ln2333">        entry.cprintf(&quot;Lives:  &quot;);</a>
<a name="ln2334"> </a>
<a name="ln2335">        entry.textcolour(HUD_VALUE_COLOUR);</a>
<a name="ln2336">        entry.cprintf(&quot;%d&quot;, you.lives);</a>
<a name="ln2337"> </a>
<a name="ln2338">        entry.textcolour(HUD_CAPTION_COLOUR);</a>
<a name="ln2339">        entry.cprintf(&quot;   Deaths: &quot;);</a>
<a name="ln2340"> </a>
<a name="ln2341">        entry.textcolour(HUD_VALUE_COLOUR);</a>
<a name="ln2342">        entry.cprintf(&quot;%d&quot;, you.deaths);</a>
<a name="ln2343"> </a>
<a name="ln2344">        cols.add_formatted(3, entry.to_colour_string(), false);</a>
<a name="ln2345">        entry.clear();</a>
<a name="ln2346">    }</a>
<a name="ln2347"> </a>
<a name="ln2348">    return cols.formatted_lines();</a>
<a name="ln2349">}</a>
<a name="ln2350"> </a>
<a name="ln2351">// generator of resistance strings:</a>
<a name="ln2352">// params :</a>
<a name="ln2353">//      name : name of the resist, correct spacing is handled here</a>
<a name="ln2354">//      spacing : width of the name column</a>
<a name="ln2355">//      value : actual value of the resistance (can be negative)</a>
<a name="ln2356">//      max : maximum value of the resistance (for colour AND representation),</a>
<a name="ln2357">//          default is the most common case (1)</a>
<a name="ln2358">//      pos_resist : false for &quot;bad&quot; resistances (no tele, random tele, *Rage),</a>
<a name="ln2359">//          inverts the value for the colour choice</a>
<a name="ln2360">static string _resist_composer(</a>
<a name="ln2361">    const char * name, int spacing, int value, int max = 1, bool pos_resist = true)</a>
<a name="ln2362">{</a>
<a name="ln2363">    string out;</a>
<a name="ln2364">    out += _determine_colour_string(pos_resist ? value : -value, max);</a>
<a name="ln2365">    out += chop_string(name, spacing);</a>
<a name="ln2366">    out += _itosym(value, max);</a>
<a name="ln2367"> </a>
<a name="ln2368">    return out;</a>
<a name="ln2369">}</a>
<a name="ln2370"> </a>
<a name="ln2371">static vector&lt;formatted_string&gt; _get_overview_resistances(</a>
<a name="ln2372">    vector&lt;char&gt; &amp;equip_chars, bool calc_unid, int sw)</a>
<a name="ln2373">{</a>
<a name="ln2374">    // 3 columns, splits at columns 20, 33</a>
<a name="ln2375">    column_composer cols(3, 20, 33);</a>
<a name="ln2376">    // First column, resist name is up to 9 chars</a>
<a name="ln2377">    int cwidth = 9;</a>
<a name="ln2378">    string out;</a>
<a name="ln2379"> </a>
<a name="ln2380">    const int rfire = player_res_fire(calc_unid);</a>
<a name="ln2381">    out += _resist_composer(&quot;rFire&quot;, cwidth, rfire, 3) + &quot;\n&quot;;</a>
<a name="ln2382"> </a>
<a name="ln2383">    const int rcold = player_res_cold(calc_unid);</a>
<a name="ln2384">    out += _resist_composer(&quot;rCold&quot;, cwidth, rcold, 3) + &quot;\n&quot;;</a>
<a name="ln2385"> </a>
<a name="ln2386">    const int rlife = player_prot_life(calc_unid);</a>
<a name="ln2387">    out += _resist_composer(&quot;rNeg&quot;, cwidth, rlife, 3) + &quot;\n&quot;;</a>
<a name="ln2388"> </a>
<a name="ln2389">    const int rpois = player_res_poison(calc_unid);</a>
<a name="ln2390">    string rpois_string = _resist_composer(&quot;rPois&quot;, cwidth, rpois) + &quot;\n&quot;;</a>
<a name="ln2391">    //XXX</a>
<a name="ln2392">    if (rpois == 3)</a>
<a name="ln2393">    {</a>
<a name="ln2394">        rpois_string = replace_all(rpois_string, &quot;+&quot;, &quot;∞&quot;);</a>
<a name="ln2395">        rpois_string = replace_all(rpois_string, &quot;green&quot;, &quot;lightgreen&quot;);</a>
<a name="ln2396">    }</a>
<a name="ln2397">    out += rpois_string;</a>
<a name="ln2398"> </a>
<a name="ln2399">    const int relec = player_res_electricity(calc_unid);</a>
<a name="ln2400">    out += _resist_composer(&quot;rElec&quot;, cwidth, relec) + &quot;\n&quot;;</a>
<a name="ln2401"> </a>
<a name="ln2402">    const int rcorr = you.res_corr(calc_unid);</a>
<a name="ln2403">    out += _resist_composer(&quot;rCorr&quot;, cwidth, rcorr) + &quot;\n&quot;;</a>
<a name="ln2404"> </a>
<a name="ln2405">    const int rmuta = (you.rmut_from_item(calc_unid)</a>
<a name="ln2406">                       || you.get_mutation_level(MUT_MUTATION_RESISTANCE) == 3);</a>
<a name="ln2407">    if (rmuta)</a>
<a name="ln2408">        out += _resist_composer(&quot;rMut&quot;, cwidth, rmuta) + &quot;\n&quot;;</a>
<a name="ln2409"> </a>
<a name="ln2410">    const int rmagi = player_res_magic(calc_unid) / MR_PIP;</a>
<a name="ln2411">    out += _resist_composer(&quot;MR&quot;, cwidth, rmagi, 5) + &quot;\n&quot;;</a>
<a name="ln2412"> </a>
<a name="ln2413">    out += _stealth_bar(20) + &quot;\n&quot;;</a>
<a name="ln2414"> </a>
<a name="ln2415">    const int regen = player_regen(); // round up</a>
<a name="ln2416">    out += make_stringf(&quot;HPRegen  %d.%d%d/turn\n&quot;, regen/100, regen/10%10, regen%10);</a>
<a name="ln2417"> </a>
<a name="ln2418">#if TAG_MAJOR_VERSION == 34</a>
<a name="ln2419">    const bool etheric = player_equip_unrand(UNRAND_ETHERIC_CAGE);</a>
<a name="ln2420">    const int mp_regen = player_mp_regen() //round up</a>
<a name="ln2421">                         + (etheric ? 50 : 0); // on average</a>
<a name="ln2422">    out += make_stringf(&quot;MPRegen  %d.%02d/turn%s\n&quot;,</a>
<a name="ln2423">                        mp_regen / 100, mp_regen % 100,</a>
<a name="ln2424">                        etheric ? &quot;*&quot; : &quot;&quot;);</a>
<a name="ln2425">#else</a>
<a name="ln2426">    const int mp_regen = player_mp_regen(); // round up</a>
<a name="ln2427">    out += make_stringf(&quot;MPRegen  %d.%02d/turn\n&quot;,</a>
<a name="ln2428">                        mp_regen / 100, mp_regen % 100);</a>
<a name="ln2429">#endif</a>
<a name="ln2430"> </a>
<a name="ln2431">    cols.add_formatted(0, out, false);</a>
<a name="ln2432"> </a>
<a name="ln2433">    // Second column, resist name is 9 chars</a>
<a name="ln2434">    out.clear();</a>
<a name="ln2435">    cwidth = 9;</a>
<a name="ln2436">    const int rinvi = you.can_see_invisible(calc_unid);</a>
<a name="ln2437">    out += _resist_composer(&quot;SeeInvis&quot;, cwidth, rinvi) + &quot;\n&quot;;</a>
<a name="ln2438"> </a>
<a name="ln2439">    const int gourmand = you.gourmand(calc_unid);</a>
<a name="ln2440">    out += _resist_composer(&quot;Gourm&quot;, cwidth, gourmand, 1) + &quot;\n&quot;;</a>
<a name="ln2441"> </a>
<a name="ln2442">    const int faith = you.faith(calc_unid);</a>
<a name="ln2443">    out += _resist_composer(&quot;Faith&quot;, cwidth, faith) + &quot;\n&quot;;</a>
<a name="ln2444"> </a>
<a name="ln2445">    const int rspir = you.spirit_shield(calc_unid);</a>
<a name="ln2446">    out += _resist_composer(&quot;Spirit&quot;, cwidth, rspir) + &quot;\n&quot;;</a>
<a name="ln2447"> </a>
<a name="ln2448">    const item_def *sh = you.shield();</a>
<a name="ln2449">    const int reflect = you.reflection(calc_unid)</a>
<a name="ln2450">                        || sh &amp;&amp; shield_reflects(*sh);</a>
<a name="ln2451">    out += _resist_composer(&quot;Reflect&quot;, cwidth, reflect) + &quot;\n&quot;;</a>
<a name="ln2452"> </a>
<a name="ln2453">    const int harm = you.extra_harm(calc_unid);</a>
<a name="ln2454">    out += _resist_composer(&quot;Harm&quot;, cwidth, harm) + &quot;\n&quot;;</a>
<a name="ln2455"> </a>
<a name="ln2456">    const int rclar = you.clarity(calc_unid);</a>
<a name="ln2457">    const int stasis = you.stasis();</a>
<a name="ln2458">    // TODO: what about different levels of anger/berserkitis?</a>
<a name="ln2459">    const bool show_angry = (you.angry(calc_unid)</a>
<a name="ln2460">                             || you.get_mutation_level(MUT_BERSERK))</a>
<a name="ln2461">                            &amp;&amp; !rclar &amp;&amp; !stasis</a>
<a name="ln2462">                            &amp;&amp; !you.is_lifeless_undead();</a>
<a name="ln2463">    if (show_angry || rclar)</a>
<a name="ln2464">    {</a>
<a name="ln2465">        out += show_angry ? _resist_composer(&quot;Rnd*Rage&quot;, cwidth, 1, 1, false)</a>
<a name="ln2466">                            + &quot;\n&quot;</a>
<a name="ln2467">                          : _resist_composer(&quot;Clarity&quot;, cwidth, rclar) + &quot;\n&quot;;</a>
<a name="ln2468">    }</a>
<a name="ln2469"> </a>
<a name="ln2470">    // Fo don't need a reminder that they can't teleport</a>
<a name="ln2471">    if (!you.stasis())</a>
<a name="ln2472">    {</a>
<a name="ln2473">        if (you.no_tele(calc_unid))</a>
<a name="ln2474">            out += _resist_composer(&quot;NoTele&quot;, cwidth, 1, 1, false) + &quot;\n&quot;;</a>
<a name="ln2475">        else if (player_teleport(calc_unid))</a>
<a name="ln2476">            out += _resist_composer(&quot;Rnd*Tele&quot;, cwidth, 1, 1, false) + &quot;\n&quot;;</a>
<a name="ln2477">    }</a>
<a name="ln2478"> </a>
<a name="ln2479">    const int no_cast = you.no_cast(calc_unid);</a>
<a name="ln2480">    if (no_cast)</a>
<a name="ln2481">        out += _resist_composer(&quot;NoCast&quot;, cwidth, 1, 1, false);</a>
<a name="ln2482"> </a>
<a name="ln2483">    cols.add_formatted(1, out, false);</a>
<a name="ln2484"> </a>
<a name="ln2485">    _print_overview_screen_equip(cols, equip_chars, sw);</a>
<a name="ln2486"> </a>
<a name="ln2487">    return cols.formatted_lines();</a>
<a name="ln2488">}</a>
<a name="ln2489"> </a>
<a name="ln2490">class overview_popup : public formatted_scroller</a>
<a name="ln2491">{</a>
<a name="ln2492">public:</a>
<a name="ln2493">    overview_popup() {};</a>
<a name="ln2494">    vector&lt;char&gt; equip_chars;</a>
<a name="ln2495">private:</a>
<a name="ln2496">    bool process_key(int ch) override</a>
<a name="ln2497">    {</a>
<a name="ln2498">        if (find(equip_chars.begin(), equip_chars.end(), ch) != equip_chars.end())</a>
<a name="ln2499">        {</a>
<a name="ln2500">            item_def&amp; item = you.inv[letter_to_index(ch)];</a>
<a name="ln2501">            if (!describe_item(item))</a>
<a name="ln2502">                return false;</a>
<a name="ln2503">            return true;</a>
<a name="ln2504">        }</a>
<a name="ln2505">        return formatted_scroller::process_key(ch);</a>
<a name="ln2506">    };</a>
<a name="ln2507">};</a>
<a name="ln2508"> </a>
<a name="ln2509">void print_overview_screen()</a>
<a name="ln2510">{</a>
<a name="ln2511">    // TODO: this should handle window resizes</a>
<a name="ln2512">    constexpr int num_cols = 80;</a>
<a name="ln2513">    bool calc_unid = false;</a>
<a name="ln2514">    overview_popup overview;</a>
<a name="ln2515"> </a>
<a name="ln2516">    overview.set_more();</a>
<a name="ln2517">    overview.set_tag(&quot;resists&quot;);</a>
<a name="ln2518"> </a>
<a name="ln2519">    overview.add_text(_overview_screen_title(num_cols));</a>
<a name="ln2520"> </a>
<a name="ln2521">    for (const formatted_string &amp;bline : _get_overview_stats())</a>
<a name="ln2522">        overview.add_formatted_string(bline, true);</a>
<a name="ln2523">    overview.add_text(&quot;\n&quot;);</a>
<a name="ln2524"> </a>
<a name="ln2525">    {</a>
<a name="ln2526">        vector&lt;formatted_string&gt; blines =</a>
<a name="ln2527">            _get_overview_resistances(overview.equip_chars, calc_unid, num_cols);</a>
<a name="ln2528"> </a>
<a name="ln2529">        for (unsigned int i = 0; i &lt; blines.size(); ++i)</a>
<a name="ln2530">            overview.add_text(blines[i].to_colour_string() + &quot;\n&quot;);</a>
<a name="ln2531">    }</a>
<a name="ln2532"> </a>
<a name="ln2533">    overview.add_text(&quot;\n&quot;);</a>
<a name="ln2534">    overview.add_text(_status_mut_rune_list(num_cols));</a>
<a name="ln2535">    overview.show();</a>
<a name="ln2536">}</a>
<a name="ln2537"> </a>
<a name="ln2538">string dump_overview_screen(bool full_id)</a>
<a name="ln2539">{</a>
<a name="ln2540">    string text = formatted_string::parse_string(_overview_screen_title(80));</a>
<a name="ln2541">    text += &quot;\n&quot;;</a>
<a name="ln2542"> </a>
<a name="ln2543">    for (const formatted_string &amp;bline : _get_overview_stats())</a>
<a name="ln2544">    {</a>
<a name="ln2545">        text += bline;</a>
<a name="ln2546">        text += &quot;\n&quot;;</a>
<a name="ln2547">    }</a>
<a name="ln2548">    text += &quot;\n&quot;;</a>
<a name="ln2549"> </a>
<a name="ln2550">    vector&lt;char&gt; equip_chars;</a>
<a name="ln2551">    for (const formatted_string &amp;bline</a>
<a name="ln2552">            : _get_overview_resistances(equip_chars, full_id, 640))</a>
<a name="ln2553">    {</a>
<a name="ln2554">        text += bline;</a>
<a name="ln2555">        text += &quot;\n&quot;;</a>
<a name="ln2556">    }</a>
<a name="ln2557">    text += &quot;\n&quot;;</a>
<a name="ln2558"> </a>
<a name="ln2559">    text += formatted_string::parse_string(_status_mut_rune_list(80));</a>
<a name="ln2560"> </a>
<a name="ln2561">    string ability_list = formatted_string::parse_string(print_abilities());</a>
<a name="ln2562">    linebreak_string(ability_list, 80);</a>
<a name="ln2563">    text += ability_list;</a>
<a name="ln2564"> </a>
<a name="ln2565">    text += &quot;\n&quot;;</a>
<a name="ln2566"> </a>
<a name="ln2567">    return text;</a>
<a name="ln2568">}</a>
<a name="ln2569"> </a>
<a name="ln2570">static string _annotate_form_based(string desc, bool suppressed)</a>
<a name="ln2571">{</a>
<a name="ln2572">    if (suppressed)</a>
<a name="ln2573">        return &quot;&lt;darkgrey&gt;(&quot; + desc + &quot;)&lt;/darkgrey&gt;&quot;;</a>
<a name="ln2574">    else</a>
<a name="ln2575">        return desc;</a>
<a name="ln2576">}</a>
<a name="ln2577"> </a>
<a name="ln2578">static string _dragon_abil(string desc)</a>
<a name="ln2579">{</a>
<a name="ln2580">    const bool supp = form_changed_physiology()</a>
<a name="ln2581">                      &amp;&amp; you.form != transformation::dragon;</a>
<a name="ln2582">    return _annotate_form_based(desc, supp);</a>
<a name="ln2583">}</a>
<a name="ln2584"> </a>
<a name="ln2585">string mutation_overview()</a>
<a name="ln2586">{</a>
<a name="ln2587">    string mtext;</a>
<a name="ln2588">    vector&lt;string&gt; mutations;</a>
<a name="ln2589"> </a>
<a name="ln2590">    const char* size_adjective = get_size_adj(you.body_size(PSIZE_BODY), true);</a>
<a name="ln2591">    if (size_adjective)</a>
<a name="ln2592">        mutations.emplace_back(size_adjective);</a>
<a name="ln2593"> </a>
<a name="ln2594">    for (const string&amp; str : fake_mutations(you.species, true))</a>
<a name="ln2595">    {</a>
<a name="ln2596">        if (species_is_draconian(you.species))</a>
<a name="ln2597">            mutations.push_back(_dragon_abil(str));</a>
<a name="ln2598">        else if (you.species == SP_MERFOLK)</a>
<a name="ln2599">        {</a>
<a name="ln2600">            mutations.push_back(</a>
<a name="ln2601">                _annotate_form_based(str, form_changed_physiology()));</a>
<a name="ln2602">        }</a>
<a name="ln2603">        else if (you.species == SP_MINOTAUR)</a>
<a name="ln2604">        {</a>
<a name="ln2605">            mutations.push_back(</a>
<a name="ln2606">                _annotate_form_based(str, !form_keeps_mutations()));</a>
<a name="ln2607">        }</a>
<a name="ln2608">        else</a>
<a name="ln2609">            mutations.push_back(str);</a>
<a name="ln2610">    }</a>
<a name="ln2611"> </a>
<a name="ln2612">    // a bit more stuff</a>
<a name="ln2613">    if (you.species == SP_OGRE || you.species == SP_TROLL</a>
<a name="ln2614">        || species_is_draconian(you.species) || you.species == SP_SPRIGGAN)</a>
<a name="ln2615">    {</a>
<a name="ln2616">        mutations.emplace_back(&quot;unfitting armour&quot;);</a>
<a name="ln2617">    }</a>
<a name="ln2618"> </a>
<a name="ln2619">    if (you.species == SP_OCTOPODE)</a>
<a name="ln2620">    {</a>
<a name="ln2621">        mutations.push_back(_annotate_form_based(&quot;amphibious&quot;,</a>
<a name="ln2622">                                                 !form_likes_water()));</a>
<a name="ln2623">        mutations.push_back(_annotate_form_based(</a>
<a name="ln2624">            make_stringf(&quot;%d rings&quot;, you.has_tentacles(false)),</a>
<a name="ln2625">            !get_form()-&gt;slot_available(EQ_RING_EIGHT)));</a>
<a name="ln2626">        mutations.push_back(_annotate_form_based(</a>
<a name="ln2627">            make_stringf(&quot;constrict %d&quot;, you.has_tentacles(false)),</a>
<a name="ln2628">            !form_keeps_mutations()));</a>
<a name="ln2629">    }</a>
<a name="ln2630"> </a>
<a name="ln2631">    if (you.can_water_walk())</a>
<a name="ln2632">        mutations.emplace_back(&quot;walk on water&quot;);</a>
<a name="ln2633"> </a>
<a name="ln2634">    if (have_passive(passive_t::frail) || player_under_penance(GOD_HEPLIAKLQANA))</a>
<a name="ln2635">        mutations.emplace_back(&quot;reduced essence&quot;);</a>
<a name="ln2636"> </a>
<a name="ln2637">    string current;</a>
<a name="ln2638">    for (unsigned i = 0; i &lt; NUM_MUTATIONS; ++i)</a>
<a name="ln2639">    {</a>
<a name="ln2640">        const mutation_type mut = static_cast&lt;mutation_type&gt;(i);</a>
<a name="ln2641">        if (!you.has_mutation(mut))</a>
<a name="ln2642">            continue;</a>
<a name="ln2643"> </a>
<a name="ln2644">        const int current_level = you.get_mutation_level(mut);</a>
<a name="ln2645">        const int base_level = you.get_base_mutation_level(mut);</a>
<a name="ln2646">        const bool lowered = current_level &lt; base_level;</a>
<a name="ln2647">        const int temp_levels = you.get_base_mutation_level(mut, false, true, false); // only temp levels</a>
<a name="ln2648">        const int ordinary_levels = you.get_base_mutation_level(mut, true, false, true); // excluding temp levels</a>
<a name="ln2649"> </a>
<a name="ln2650">        const int max_levels = mutation_max_levels(mut);</a>
<a name="ln2651"> </a>
<a name="ln2652">        current = mutation_name(mut);</a>
<a name="ln2653"> </a>
<a name="ln2654">        if (max_levels &gt; 1)</a>
<a name="ln2655">        {</a>
<a name="ln2656">            // add on any numeric levels</a>
<a name="ln2657">            ostringstream ostr;</a>
<a name="ln2658">            ostr &lt;&lt; &quot; &quot;;</a>
<a name="ln2659">            if (ordinary_levels == 0) // only temporary levels are present</a>
<a name="ln2660">                ostr &lt;&lt; temp_levels;</a>
<a name="ln2661">            else</a>
<a name="ln2662">            {</a>
<a name="ln2663">                // at least some non-temporary levels</a>
<a name="ln2664">                ostr &lt;&lt; ordinary_levels;</a>
<a name="ln2665">                if (temp_levels)</a>
<a name="ln2666">                    ostr &lt;&lt; &quot;[+&quot; &lt;&lt; temp_levels &lt;&lt; &quot;]&quot;;</a>
<a name="ln2667">            }</a>
<a name="ln2668">            current += ostr.str();</a>
<a name="ln2669">        }</a>
<a name="ln2670"> </a>
<a name="ln2671">        // bracket the whole thing</a>
<a name="ln2672">        if (ordinary_levels == 0)</a>
<a name="ln2673">            current = &quot;[&quot; + current + &quot;]&quot;;</a>
<a name="ln2674"> </a>
<a name="ln2675">        if (!current.empty())</a>
<a name="ln2676">        {</a>
<a name="ln2677">            if (current_level == 0) // suppressed by form</a>
<a name="ln2678">                current = &quot;(&quot; + current + &quot;)&quot;;</a>
<a name="ln2679">            if (lowered)</a>
<a name="ln2680">                current = &quot;&lt;darkgrey&gt;&quot; + current + &quot;&lt;/darkgrey&gt;&quot;;</a>
<a name="ln2681">            mutations.push_back(current);</a>
<a name="ln2682">        }</a>
<a name="ln2683">    }</a>
<a name="ln2684"> </a>
<a name="ln2685">    if (you.racial_ac(false))</a>
<a name="ln2686">        mutations.push_back(&quot;AC +&quot; + to_string(you.racial_ac(false) / 100));</a>
<a name="ln2687"> </a>
<a name="ln2688">    if (mutations.empty())</a>
<a name="ln2689">        mtext += &quot;no striking features&quot;;</a>
<a name="ln2690">    else</a>
<a name="ln2691">    {</a>
<a name="ln2692">        mtext += comma_separated_line(mutations.begin(), mutations.end(),</a>
<a name="ln2693">                                     &quot;, &quot;, &quot;, &quot;);</a>
<a name="ln2694">    }</a>
<a name="ln2695">    return mtext;</a>
<a name="ln2696">}</a>
<a name="ln2697"> </a>
<a name="ln2698">/// Creates rows of short descriptions for current status effects, mutations,</a>
<a name="ln2699">/// and runes/Orbs of Zot.</a>
<a name="ln2700">string _status_mut_rune_list(int sw)</a>
<a name="ln2701">{</a>
<a name="ln2702">    // print status information</a>
<a name="ln2703">    string text = &quot;&lt;w&gt;@:&lt;/w&gt; &quot;;</a>
<a name="ln2704">    vector&lt;string&gt; status;</a>
<a name="ln2705"> </a>
<a name="ln2706">    status_info inf;</a>
<a name="ln2707">    for (unsigned i = 0; i &lt;= STATUS_LAST_STATUS; ++i)</a>
<a name="ln2708">    {</a>
<a name="ln2709">        if (fill_status_info(i, inf) &amp;&amp; !inf.short_text.empty())</a>
<a name="ln2710">            status.emplace_back(inf.short_text);</a>
<a name="ln2711">    }</a>
<a name="ln2712"> </a>
<a name="ln2713">    int move_cost = (player_speed() * player_movement_speed()) / 10;</a>
<a name="ln2714">    if (move_cost != 10)</a>
<a name="ln2715">    {</a>
<a name="ln2716">        const char *help = (move_cost &lt;   8) ? &quot;very quick&quot; :</a>
<a name="ln2717">                           (move_cost &lt;  10) ? &quot;quick&quot; :</a>
<a name="ln2718">                           (move_cost &lt;  13) ? &quot;slow&quot;</a>
<a name="ln2719">                                             : &quot;very slow&quot;;</a>
<a name="ln2720">        status.emplace_back(help);</a>
<a name="ln2721">    }</a>
<a name="ln2722"> </a>
<a name="ln2723">    if (status.empty())</a>
<a name="ln2724">        text += &quot;no status effects&quot;;</a>
<a name="ln2725">    else</a>
<a name="ln2726">        text += comma_separated_line(status.begin(), status.end(), &quot;, &quot;, &quot;, &quot;);</a>
<a name="ln2727">    text += &quot;\n&quot;;</a>
<a name="ln2728"> </a>
<a name="ln2729">    // print mutation information</a>
<a name="ln2730">    text += &quot;&lt;w&gt;A:&lt;/w&gt; &quot;;</a>
<a name="ln2731"> </a>
<a name="ln2732">    text += mutation_overview();</a>
<a name="ln2733"> </a>
<a name="ln2734">    // print the Orb</a>
<a name="ln2735">    if (player_has_orb())</a>
<a name="ln2736">        text += &quot;\n&lt;w&gt;0:&lt;/w&gt; Orb of Zot&quot;;</a>
<a name="ln2737"> </a>
<a name="ln2738">    // print runes</a>
<a name="ln2739">    vector&lt;string&gt; runes;</a>
<a name="ln2740">    for (int i = 0; i &lt; NUM_RUNE_TYPES; i++)</a>
<a name="ln2741">        if (you.runes[i])</a>
<a name="ln2742">            runes.emplace_back(rune_type_name(i));</a>
<a name="ln2743">    if (!runes.empty())</a>
<a name="ln2744">    {</a>
<a name="ln2745">        text += make_stringf(&quot;\n&lt;w&gt;%s:&lt;/w&gt; %d/%d rune%s: %s&quot;,</a>
<a name="ln2746">                    stringize_glyph(get_item_symbol(SHOW_ITEM_MISCELLANY)).c_str(),</a>
<a name="ln2747">                    (int)runes.size(), you.obtainable_runes,</a>
<a name="ln2748">                    you.obtainable_runes == 1 ? &quot;&quot; : &quot;s&quot;,</a>
<a name="ln2749">                    comma_separated_line(runes.begin(), runes.end(),</a>
<a name="ln2750">                                         &quot;, &quot;, &quot;, &quot;).c_str());</a>
<a name="ln2751">    }</a>
<a name="ln2752"> </a>
<a name="ln2753">    linebreak_string(text, sw);</a>
<a name="ln2754"> </a>
<a name="ln2755">    return text;</a>
<a name="ln2756">}</a>

</code></pre>
<div class="balloon" rel="242"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v618/" target="_blank">V618</a> It's dangerous to call the 'cprintf' function in such a manner, as the line being passed could contain format specification. The example of the safe code: printf("%s", str);</p></div>
<div class="balloon" rel="1400"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v560/" target="_blank">V560</a> A part of conditional expression is always false: you.wield_change.</p></div>

<link rel="stylesheet" href="highlight.css">
<script src="highlight.pack.js"></script>
<script src="highlightjs-line-numbers.js"></script>
<script>hljs.initHighlightingOnLoad();</script>
<script>hljs.initLineNumbersOnLoad();</script>
<script>
  $(document).ready(function() {
      $('.balloon').each(function () {
          var bl = $(this);
          var line = bl.attr('rel');
          var text = $('a[name="ln'+line+'"]').text();

          var space_count = 0;
          for(var i = 0; i<text.length; i++){
              var char = text[i];
              if((char !== ' ')&&(char !== '\t'))break;
              if(char === '\t')space_count++;
              space_count++;
          }

          bl.css('margin-left', space_count*8);
          $('a[name="ln'+line+'"]').after(bl);
      });

      window.location = window.location;
  });
</script>
</body>
</html>
