
<html>
<head>

  <meta http-equiv="Content-Type" content="text/html; charset=US-ASCII" />
  <title>dbg-asrt.cc</title>

  <link rel="stylesheet" href="../style.css"/>
  <script src="../jquery-3.2.1.min.js"></script>
</head>
<body>

<pre><code class = "cpp">
<a name="ln1">/**</a>
<a name="ln2"> * @file</a>
<a name="ln3"> * @brief Assertions and crashing.</a>
<a name="ln4">**/</a>
<a name="ln5"> </a>
<a name="ln6">#include &quot;AppHdr.h&quot;</a>
<a name="ln7"> </a>
<a name="ln8">#include &lt;cerrno&gt;</a>
<a name="ln9">#include &lt;csignal&gt;</a>
<a name="ln10"> </a>
<a name="ln11">#include &quot;abyss.h&quot;</a>
<a name="ln12">#include &quot;chardump.h&quot;</a>
<a name="ln13">#include &quot;coordit.h&quot;</a>
<a name="ln14">#include &quot;crash.h&quot;</a>
<a name="ln15">#include &quot;dbg-scan.h&quot;</a>
<a name="ln16">#include &quot;dbg-util.h&quot;</a>
<a name="ln17">#include &quot;delay.h&quot;</a>
<a name="ln18">#include &quot;directn.h&quot;</a>
<a name="ln19">#include &quot;dlua.h&quot;</a>
<a name="ln20">#include &quot;env.h&quot;</a>
<a name="ln21">#include &quot;files.h&quot;</a>
<a name="ln22">#include &quot;hiscores.h&quot;</a>
<a name="ln23">#include &quot;initfile.h&quot;</a>
<a name="ln24">#include &quot;item-name.h&quot;</a>
<a name="ln25">#include &quot;jobs.h&quot;</a>
<a name="ln26">#include &quot;mapmark.h&quot;</a>
<a name="ln27">#include &quot;message.h&quot;</a>
<a name="ln28">#include &quot;misc.h&quot;</a>
<a name="ln29">#include &quot;mutation.h&quot;</a>
<a name="ln30">#include &quot;religion.h&quot;</a>
<a name="ln31">#include &quot;skills.h&quot;</a>
<a name="ln32">#include &quot;spl-util.h&quot;</a>
<a name="ln33">#include &quot;state.h&quot;</a>
<a name="ln34">#include &quot;stringutil.h&quot;</a>
<a name="ln35">#include &quot;tiles-build-specific.h&quot;</a>
<a name="ln36">#include &quot;travel.h&quot;</a>
<a name="ln37">#include &quot;version.h&quot;</a>
<a name="ln38">#include &quot;view.h&quot;</a>
<a name="ln39">#</a>
<a name="ln40">#if defined(TARGET_OS_WINDOWS) || defined(TARGET_COMPILER_MINGW)</a>
<a name="ln41">#define NOCOMM            /* Comm driver APIs and definitions */</a>
<a name="ln42">#define NOLOGERROR        /* LogError() and related definitions */</a>
<a name="ln43">#define NOPROFILER        /* Profiler APIs */</a>
<a name="ln44">#define NOLFILEIO         /* _l* file I/O routines */</a>
<a name="ln45">#define NOOPENFILE        /* OpenFile and related definitions */</a>
<a name="ln46">#define NORESOURCE        /* Resource management */</a>
<a name="ln47">#define NOATOM            /* Atom management */</a>
<a name="ln48">#define NOLANGUAGE        /* Character test routines */</a>
<a name="ln49">#define NOLSTRING         /* lstr* string management routines */</a>
<a name="ln50">#define NODBCS            /* Double-byte character set routines */</a>
<a name="ln51">#define NOKEYBOARDINFO    /* Keyboard driver routines */</a>
<a name="ln52">#define NOCOLOR           /* COLOR_* colour values */</a>
<a name="ln53">#define NODRAWTEXT        /* DrawText() and related definitions */</a>
<a name="ln54">#define NOSCALABLEFONT    /* Truetype scalable font support */</a>
<a name="ln55">#define NOMETAFILE        /* Metafile support */</a>
<a name="ln56">#define NOSYSTEMPARAMSINFO /* SystemParametersInfo() and SPI_* definitions */</a>
<a name="ln57">#define NODEFERWINDOWPOS  /* DeferWindowPos and related definitions */</a>
<a name="ln58">#define NOKEYSTATES       /* MK_* message key state flags */</a>
<a name="ln59">#define NOWH              /* SetWindowsHook and related WH_* definitions */</a>
<a name="ln60">#define NOCLIPBOARD       /* Clipboard APIs and definitions */</a>
<a name="ln61">#define NOICONS           /* IDI_* icon IDs */</a>
<a name="ln62">#define NOMDI             /* MDI support */</a>
<a name="ln63">#define NOCTLMGR          /* Control management and controls */</a>
<a name="ln64">#define NOHELP            /* Help support */</a>
<a name="ln65">#define WIN32_LEAN_AND_MEAN /* No cryptography etc */</a>
<a name="ln66">#define NONLS             /* All NLS defines and routines */</a>
<a name="ln67">#define NOSERVICE         /* All Service Controller routines, SERVICE_ equates, etc. */</a>
<a name="ln68">#define NOKANJI           /* Kanji support stuff. */</a>
<a name="ln69">#define NOMCX             /* Modem Configuration Extensions */</a>
<a name="ln70">#include &lt;windows.h&gt;</a>
<a name="ln71">#undef max</a>
<a name="ln72"> </a>
<a name="ln73">#ifdef USE_TILE_LOCAL</a>
<a name="ln74">#ifdef TARGET_COMPILER_VC</a>
<a name="ln75"># include &lt;SDL_syswm.h&gt;</a>
<a name="ln76">#else</a>
<a name="ln77"># include &lt;SDL2/SDL_syswm.h&gt;</a>
<a name="ln78">#endif</a>
<a name="ln79">#endif</a>
<a name="ln80">#endif</a>
<a name="ln81"> </a>
<a name="ln82">#ifdef __ANDROID__</a>
<a name="ln83"># include &lt;android/log.h&gt;</a>
<a name="ln84">#endif</a>
<a name="ln85"> </a>
<a name="ln86">static string _assert_msg;</a>
<a name="ln87"> </a>
<a name="ln88">static void _dump_compilation_info(FILE* file)</a>
<a name="ln89">{</a>
<a name="ln90">    fprintf(file, &quot;Compilation info:\n&quot;);</a>
<a name="ln91">    fprintf(file, &quot;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;\n&quot;);</a>
<a name="ln92">    fprintf(file, &quot;%s&quot;, compilation_info);</a>
<a name="ln93">    fprintf(file, &quot;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;\n\n&quot;);</a>
<a name="ln94">}</a>
<a name="ln95"> </a>
<a name="ln96">extern abyss_state abyssal_state;</a>
<a name="ln97"> </a>
<a name="ln98">static void _dump_level_info(FILE* file)</a>
<a name="ln99">{</a>
<a name="ln100">    fprintf(file, &quot;Place info:\n&quot;);</a>
<a name="ln101"> </a>
<a name="ln102">    fprintf(file, &quot;branch = %d, depth = %d\n\n&quot;,</a>
<a name="ln103">            (int)you.where_are_you, you.depth);</a>
<a name="ln104"> </a>
<a name="ln105">    string place = level_id::current().describe();</a>
<a name="ln106"> </a>
<a name="ln107">    fprintf(file, &quot;Level id: %s\n&quot;, place.c_str());</a>
<a name="ln108">    if (player_in_branch(BRANCH_ABYSS))</a>
<a name="ln109">    {</a>
<a name="ln110">        fprintf(file, &quot;Abyssal state:\n&quot;</a>
<a name="ln111">                      &quot;    major_coord = (%d,%d)\n&quot;</a>
<a name="ln112">                      &quot;    seed = 0x%&quot; PRIx32 &quot;\n&quot;</a>
<a name="ln113">                      &quot;    depth = %&quot; PRIu32 &quot;\n&quot;</a>
<a name="ln114">                      &quot;    phase = %g\n&quot;</a>
<a name="ln115">                      &quot;    destroy_all_terrain = %d\n&quot;</a>
<a name="ln116">                      &quot;    level = (%d : %d)\n&quot;,</a>
<a name="ln117">                abyssal_state.major_coord.x, abyssal_state.major_coord.y,</a>
<a name="ln118">                abyssal_state.seed, abyssal_state.depth, abyssal_state.phase,</a>
<a name="ln119">                abyssal_state.destroy_all_terrain,</a>
<a name="ln120">                abyssal_state.level.branch, abyssal_state.level.depth);</a>
<a name="ln121">    }</a>
<a name="ln122"> </a>
<a name="ln123">    debug_dump_levgen();</a>
<a name="ln124">}</a>
<a name="ln125"> </a>
<a name="ln126">static void _dump_player(FILE *file)</a>
<a name="ln127">{</a>
<a name="ln128">    // Only dump player info during arena mode if the player is likely</a>
<a name="ln129">    // the cause of the crash.</a>
<a name="ln130">    if ((crawl_state.game_is_arena() || crawl_state.arena_suspended)</a>
<a name="ln131">        &amp;&amp; !in_bounds(you.pos()) &amp;&amp; you.hp &gt; 0 &amp;&amp; you.hp_max &gt; 0</a>
<a name="ln132">        &amp;&amp; you.strength() &gt; 0 &amp;&amp; you.intel() &gt; 0 &amp;&amp; you.dex() &gt; 0)</a>
<a name="ln133">    {</a>
<a name="ln134">        // Arena mode can change behaviour of the rest of the code and/or lead</a>
<a name="ln135">        // to asserts.</a>
<a name="ln136">        crawl_state.type            = GAME_TYPE_NORMAL;</a>
<a name="ln137">        crawl_state.arena_suspended = false;</a>
<a name="ln138">        return;</a>
<a name="ln139">    }</a>
<a name="ln140"> </a>
<a name="ln141">    // Arena mode can change behaviour of the rest of the code and/or lead</a>
<a name="ln142">    // to asserts.</a>
<a name="ln143">    crawl_state.arena_suspended = false;</a>
<a name="ln144"> </a>
<a name="ln145">    fprintf(file, &quot;Player:\n&quot;);</a>
<a name="ln146">    fprintf(file, &quot;{{{{{{{{{{{\n&quot;);</a>
<a name="ln147"> </a>
<a name="ln148">    fprintf(file, &quot;Name:    [%s]\n&quot;, you.your_name.c_str());</a>
<a name="ln149">    fprintf(file, &quot;Species: %s\n&quot;, species_name(you.species).c_str());</a>
<a name="ln150">    fprintf(file, &quot;Job:     %s\n\n&quot;, get_job_name(you.char_class));</a>
<a name="ln151"> </a>
<a name="ln152">    fprintf(file, &quot;HP: %d/%d; mods: %d/%d\n&quot;, you.hp, you.hp_max,</a>
<a name="ln153">            you.hp_max_adj_temp, you.hp_max_adj_perm);</a>
<a name="ln154">    fprintf(file, &quot;MP: %d/%d; mod: %d\n&quot;,</a>
<a name="ln155">            you.magic_points, you.max_magic_points,</a>
<a name="ln156">            you.mp_max_adj);</a>
<a name="ln157">    fprintf(file, &quot;Stats: %d (%d) %d (%d) %d (%d)\n&quot;,</a>
<a name="ln158">            you.strength(false), you.max_strength(),</a>
<a name="ln159">            you.intel(false), you.max_intel(),</a>
<a name="ln160">            you.dex(false), you.max_dex());</a>
<a name="ln161">    fprintf(file, &quot;Position: %s, god: %s (%d), turn_is_over: %d, &quot;</a>
<a name="ln162">                  &quot;banished: %d\n&quot;,</a>
<a name="ln163">            debug_coord_str(you.pos()).c_str(),</a>
<a name="ln164">            god_name(you.religion).c_str(), (int) you.religion,</a>
<a name="ln165">            (int) you.turn_is_over, (int) you.banished);</a>
<a name="ln166"> </a>
<a name="ln167">    if (in_bounds(you.pos()))</a>
<a name="ln168">    {</a>
<a name="ln169">        fprintf(file, &quot;Standing on/in/over feature: %s\n&quot;,</a>
<a name="ln170">                raw_feature_description(you.pos()).c_str());</a>
<a name="ln171">    }</a>
<a name="ln172"> </a>
<a name="ln173">    debug_dump_constriction(&amp;you);</a>
<a name="ln174">    fprintf(file, &quot;\n&quot;);</a>
<a name="ln175"> </a>
<a name="ln176">    if (you.running.runmode != RMODE_NOT_RUNNING)</a>
<a name="ln177">    {</a>
<a name="ln178">        fprintf(file, &quot;Runrest:\n&quot;);</a>
<a name="ln179">        fprintf(file, &quot;    mode: %d\n&quot;, you.running.runmode);</a>
<a name="ln180">        fprintf(file, &quot;      mp: %d\n&quot;, you.running.mp);</a>
<a name="ln181">        fprintf(file, &quot;      hp: %d\n&quot;, you.running.hp);</a>
<a name="ln182">        fprintf(file, &quot;     pos: %s\n\n&quot;,</a>
<a name="ln183">                debug_coord_str(you.running.pos).c_str());</a>
<a name="ln184">    }</a>
<a name="ln185"> </a>
<a name="ln186">    if (!you.delay_queue.empty())</a>
<a name="ln187">    {</a>
<a name="ln188">        fprintf(file, &quot;Delayed (%u):\n&quot;,</a>
<a name="ln189">                (unsigned int)you.delay_queue.size());</a>
<a name="ln190">        for (const auto delay : you.delay_queue)</a>
<a name="ln191">        {</a>
<a name="ln192">            fprintf(file, &quot;    type:     %s&quot;, delay-&gt;name());</a>
<a name="ln193">            fprintf(file, &quot;\n&quot;);</a>
<a name="ln194">            fprintf(file, &quot;    duration: %d\n&quot;, delay-&gt;duration);</a>
<a name="ln195">        }</a>
<a name="ln196">        fprintf(file, &quot;\n&quot;);</a>
<a name="ln197">    }</a>
<a name="ln198"> </a>
<a name="ln199">    fprintf(file, &quot;Skills (mode: %s)\n&quot;, you.auto_training ? &quot;auto&quot; : &quot;manual&quot;);</a>
<a name="ln200">    fprintf(file, &quot;Name            | can_currently_train | train | training |&quot;</a>
<a name="ln201">                  &quot; level | points | progress\n&quot;);</a>
<a name="ln202">    for (size_t i = 0; i &lt; NUM_SKILLS; ++i)</a>
<a name="ln203">    {</a>
<a name="ln204">        const skill_type sk = skill_type(i);</a>
<a name="ln205">        if (is_useless_skill(sk))</a>
<a name="ln206">            continue;</a>
<a name="ln207"> </a>
<a name="ln208">        int needed_min = 0, needed_max = 0;</a>
<a name="ln209">        if (sk &gt;= 0 &amp;&amp; you.skills[sk] &lt;= 27)</a>
<a name="ln210">            needed_min = skill_exp_needed(you.skills[sk], sk);</a>
<a name="ln211">        if (sk &gt;= 0 &amp;&amp; you.skills[sk] &lt; 27)</a>
<a name="ln212">            needed_max = skill_exp_needed(you.skills[sk] + 1, sk);</a>
<a name="ln213"> </a>
<a name="ln214">        fprintf(file, &quot;%-16s|          %c          |   %u   |   %3u    |   %2d  | %6d | %d/%d\n&quot;,</a>
<a name="ln215">                skill_name(sk),</a>
<a name="ln216">                you.can_currently_train[sk] ? 'X' : ' ',</a>
<a name="ln217">                you.train[sk],</a>
<a name="ln218">                you.training[sk],</a>
<a name="ln219">                you.skills[sk],</a>
<a name="ln220">                you.skill_points[sk],</a>
<a name="ln221">                you.skill_points[sk] - needed_min,</a>
<a name="ln222">                max(needed_max - needed_min, 0));</a>
<a name="ln223">    }</a>
<a name="ln224">    fprintf(file, &quot;\n&quot;);</a>
<a name="ln225"> </a>
<a name="ln226">    fprintf(file, &quot;Spell bugs:\n&quot;);</a>
<a name="ln227">    for (size_t i = 0; i &lt; you.spells.size(); ++i)</a>
<a name="ln228">    {</a>
<a name="ln229">        const spell_type spell = you.spells[i];</a>
<a name="ln230"> </a>
<a name="ln231">        if (spell == SPELL_NO_SPELL)</a>
<a name="ln232">            continue;</a>
<a name="ln233"> </a>
<a name="ln234">        if (!is_valid_spell(spell))</a>
<a name="ln235">        {</a>
<a name="ln236">            fprintf(file, &quot;    spell slot #%d: invalid spell #%d\n&quot;,</a>
<a name="ln237">                    (int)i, (int)spell);</a>
<a name="ln238">            continue;</a>
<a name="ln239">        }</a>
<a name="ln240"> </a>
<a name="ln241">        const spell_flags flags = get_spell_flags(spell);</a>
<a name="ln242"> </a>
<a name="ln243">        if (flags &amp; spflag::monster)</a>
<a name="ln244">        {</a>
<a name="ln245">            fprintf(file, &quot;    spell slot #%d: monster only spell %s\n&quot;,</a>
<a name="ln246">                    (int)i, spell_title(spell));</a>
<a name="ln247">        }</a>
<a name="ln248">        else if (flags &amp; spflag::testing)</a>
<a name="ln249">            fprintf(file, &quot;    spell slot #%d: testing spell %s\n&quot;,</a>
<a name="ln250">                    (int)i, spell_title(spell));</a>
<a name="ln251">        else if (count_bits(get_spell_disciplines(spell)) == 0)</a>
<a name="ln252">            fprintf(file, &quot;    spell slot #%d: school-less spell %s\n&quot;,</a>
<a name="ln253">                    (int)i, spell_title(spell));</a>
<a name="ln254">    }</a>
<a name="ln255">    fprintf(file, &quot;\n&quot;);</a>
<a name="ln256"> </a>
<a name="ln257">    fprintf(file, &quot;Durations:\n&quot;);</a>
<a name="ln258">    for (int i = 0; i &lt; NUM_DURATIONS; ++i)</a>
<a name="ln259">        if (you.duration[i] != 0)</a>
<a name="ln260">            fprintf(file, &quot;    #%d: %d\n&quot;, i, you.duration[i]);</a>
<a name="ln261"> </a>
<a name="ln262">    fprintf(file, &quot;\n&quot;);</a>
<a name="ln263"> </a>
<a name="ln264">    fprintf(file, &quot;Attributes:\n&quot;);</a>
<a name="ln265">    for (int i = 0; i &lt; NUM_ATTRIBUTES; ++i)</a>
<a name="ln266">        if (you.attribute[i] != 0)</a>
<a name="ln267">            fprintf(file, &quot;    #%d: %d\n&quot;, i, you.attribute[i]);</a>
<a name="ln268"> </a>
<a name="ln269">    fprintf(file, &quot;\n&quot;);</a>
<a name="ln270"> </a>
<a name="ln271">    fprintf(file, &quot;Mutations:\n&quot;);</a>
<a name="ln272">    for (int i = 0; i &lt; NUM_MUTATIONS; ++i)</a>
<a name="ln273">    {</a>
<a name="ln274">        mutation_type mut = static_cast&lt;mutation_type&gt;(i);</a>
<a name="ln275">        int normal = you.mutation[i];</a>
<a name="ln276">        int innate = you.innate_mutation[i];</a>
<a name="ln277">        int temp   = you.temp_mutation[i];</a>
<a name="ln278"> </a>
<a name="ln279">        // Normally innate and temp imply normal, but a crash handler should</a>
<a name="ln280">        // expect the spanish^Wunexpected.</a>
<a name="ln281">        if (!normal &amp;&amp; !innate &amp;&amp; !temp)</a>
<a name="ln282">            continue;</a>
<a name="ln283"> </a>
<a name="ln284">        if (const char* name = mutation_name(mut))</a>
<a name="ln285">            fprintf(file, &quot;    %s: %d&quot;, name, normal);</a>
<a name="ln286">        else</a>
<a name="ln287">            fprintf(file, &quot;    unknown #%d: %d&quot;, i, normal);</a>
<a name="ln288"> </a>
<a name="ln289">        if (innate)</a>
<a name="ln290">        {</a>
<a name="ln291">            if (innate == normal)</a>
<a name="ln292">                fprintf(file, &quot; (innate)&quot;);</a>
<a name="ln293">            else</a>
<a name="ln294">                fprintf(file, &quot; (%d innate)&quot;, innate);</a>
<a name="ln295">        }</a>
<a name="ln296"> </a>
<a name="ln297">        if (temp)</a>
<a name="ln298">        {</a>
<a name="ln299">            if (temp == normal)</a>
<a name="ln300">                fprintf(file, &quot; (temporary)&quot;);</a>
<a name="ln301">            else</a>
<a name="ln302">                fprintf(file, &quot; (%d temporary)&quot;, temp);</a>
<a name="ln303">        }</a>
<a name="ln304"> </a>
<a name="ln305">        fprintf(file, &quot;\n&quot;);</a>
<a name="ln306">    }</a>
<a name="ln307"> </a>
<a name="ln308">    fprintf(file, &quot;\n&quot;);</a>
<a name="ln309"> </a>
<a name="ln310">    fprintf(file, &quot;Inventory bugs:\n&quot;);</a>
<a name="ln311">    for (int i = 0; i &lt; ENDOFPACK; ++i)</a>
<a name="ln312">    {</a>
<a name="ln313">        item_def &amp;item(you.inv[i]);</a>
<a name="ln314"> </a>
<a name="ln315">        if (item.base_type == OBJ_UNASSIGNED &amp;&amp; item.quantity != 0)</a>
<a name="ln316">        {</a>
<a name="ln317">            fprintf(file, &quot;    slot #%d: unassigned item has quant %d\n&quot;,</a>
<a name="ln318">                    i, item.quantity);</a>
<a name="ln319">            continue;</a>
<a name="ln320">        }</a>
<a name="ln321">        else if (item.base_type != OBJ_UNASSIGNED &amp;&amp; item.quantity &lt; 1)</a>
<a name="ln322">        {</a>
<a name="ln323">            const int orig_quant = item.quantity;</a>
<a name="ln324">            item.quantity = 1;</a>
<a name="ln325"> </a>
<a name="ln326">            fprintf(file, &quot;    slot #%d: otherwise valid item '%s' has &quot;</a>
<a name="ln327">                          &quot;invalid quantity %d\n&quot;,</a>
<a name="ln328">                    i, item.name(DESC_PLAIN, false, true).c_str(),</a>
<a name="ln329">                    orig_quant);</a>
<a name="ln330">            item.quantity = orig_quant;</a>
<a name="ln331">            continue;</a>
<a name="ln332">        }</a>
<a name="ln333">        else if (!item.defined())</a>
<a name="ln334">            continue;</a>
<a name="ln335"> </a>
<a name="ln336">        const string name = item.name(DESC_PLAIN, false, true);</a>
<a name="ln337"> </a>
<a name="ln338">        if (item.link != i)</a>
<a name="ln339">        {</a>
<a name="ln340">            fprintf(file, &quot;    slot #%d: item '%s' has invalid link %d\n&quot;,</a>
<a name="ln341">                    i, name.c_str(), item.link);</a>
<a name="ln342">        }</a>
<a name="ln343"> </a>
<a name="ln344">        if (item.slot &lt; 0 || item.slot &gt; 127)</a>
<a name="ln345">        {</a>
<a name="ln346">            fprintf(file, &quot;    slot #%d: item '%s' has invalid slot %d\n&quot;,</a>
<a name="ln347">                    i, name.c_str(), item.slot);</a>
<a name="ln348">        }</a>
<a name="ln349"> </a>
<a name="ln350">        if (!item.pos.equals(-1, -1))</a>
<a name="ln351">        {</a>
<a name="ln352">            fprintf(file, &quot;    slot #%d: item '%s' has invalid pos %s\n&quot;,</a>
<a name="ln353">                    i, name.c_str(), debug_coord_str(item.pos).c_str());</a>
<a name="ln354">        }</a>
<a name="ln355">    }</a>
<a name="ln356">    fprintf(file, &quot;\n&quot;);</a>
<a name="ln357"> </a>
<a name="ln358">    fprintf(file, &quot;Equipment:\n&quot;);</a>
<a name="ln359">    for (int i = EQ_FIRST_EQUIP; i &lt; NUM_EQUIP; ++i)</a>
<a name="ln360">    {</a>
<a name="ln361">        int8_t eq = you.equip[i];</a>
<a name="ln362"> </a>
<a name="ln363">        if (eq == -1)</a>
<a name="ln364">            continue;</a>
<a name="ln365"> </a>
<a name="ln366">        fprintf(file, &quot;    eq slot #%d, inv slot #%d&quot;, i, (int) eq);</a>
<a name="ln367">        if (eq &lt; 0 || eq &gt;= ENDOFPACK)</a>
<a name="ln368">        {</a>
<a name="ln369">            fprintf(file, &quot; &lt;invalid&gt;\n&quot;);</a>
<a name="ln370">            continue;</a>
<a name="ln371">        }</a>
<a name="ln372">        const bool unknown = !item_type_known(you.inv[eq]);</a>
<a name="ln373">        const bool melded  = you.melded[i];</a>
<a name="ln374">        string suffix = &quot;&quot;;</a>
<a name="ln375">        if (unknown || melded)</a>
<a name="ln376">        {</a>
<a name="ln377">            suffix = &quot; (&quot;;</a>
<a name="ln378">            if (unknown)</a>
<a name="ln379">            {</a>
<a name="ln380">                suffix += &quot;unknown&quot;;</a>
<a name="ln381">                if (melded)</a>
<a name="ln382">                    suffix += &quot;, &quot;;</a>
<a name="ln383">            }</a>
<a name="ln384">            if (melded)</a>
<a name="ln385">                suffix += &quot;melded&quot;;</a>
<a name="ln386">            suffix += &quot;)&quot;;</a>
<a name="ln387">        }</a>
<a name="ln388">        fprintf(file, &quot;: %s%s\n&quot;,</a>
<a name="ln389">                you.inv[eq].name(DESC_PLAIN, false, true).c_str(), suffix.c_str());</a>
<a name="ln390">    }</a>
<a name="ln391">    fprintf(file, &quot;\n&quot;);</a>
<a name="ln392"> </a>
<a name="ln393">    if (in_bounds(you.pos()) &amp;&amp; monster_at(you.pos()))</a>
<a name="ln394">    {</a>
<a name="ln395">        fprintf(file, &quot;Standing on same square as: &quot;);</a>
<a name="ln396">        const unsigned short midx = mgrd(you.pos());</a>
<a name="ln397"> </a>
<a name="ln398">        if (invalid_monster_index(midx))</a>
<a name="ln399">            fprintf(file, &quot;invalid monster index %d\n&quot;, (int) midx);</a>
<a name="ln400">        else</a>
<a name="ln401">        {</a>
<a name="ln402">            const monster* mon = &amp;menv[midx];</a>
<a name="ln403">            fprintf(file, &quot;%s:\n&quot;, debug_mon_str(mon).c_str());</a>
<a name="ln404">            debug_dump_mon(mon, true);</a>
<a name="ln405">        }</a>
<a name="ln406">        fprintf(file, &quot;\n&quot;);</a>
<a name="ln407">    }</a>
<a name="ln408"> </a>
<a name="ln409">    fprintf(file, &quot;}}}}}}}}}}}\n\n&quot;);</a>
<a name="ln410">}</a>
<a name="ln411"> </a>
<a name="ln412">static void _debug_marker_scan()</a>
<a name="ln413">{</a>
<a name="ln414">    vector&lt;map_marker*&gt; markers = env.markers.get_all();</a>
<a name="ln415"> </a>
<a name="ln416">    for (unsigned int i = 0; i &lt; markers.size(); ++i)</a>
<a name="ln417">    {</a>
<a name="ln418">        map_marker* marker = markers[i];</a>
<a name="ln419"> </a>
<a name="ln420">        if (marker == nullptr)</a>
<a name="ln421">        {</a>
<a name="ln422">            mprf(MSGCH_ERROR, &quot;Marker #%d is nullptr&quot;, i);</a>
<a name="ln423">            continue;</a>
<a name="ln424">        }</a>
<a name="ln425"> </a>
<a name="ln426">        map_marker_type type = marker-&gt;get_type();</a>
<a name="ln427"> </a>
<a name="ln428">        if (type &lt; MAT_FEATURE || type &gt;= NUM_MAP_MARKER_TYPES)</a>
<a name="ln429">        {</a>
<a name="ln430">            mprf(MSGCH_ERROR, &quot;Marker #%d at (%d, %d) has invalid type %d&quot;,</a>
<a name="ln431">                 i, marker-&gt;pos.x, marker-&gt;pos.y, (int) type);</a>
<a name="ln432">        }</a>
<a name="ln433"> </a>
<a name="ln434">        if (!in_bounds(marker-&gt;pos))</a>
<a name="ln435">        {</a>
<a name="ln436">            mprf(MSGCH_ERROR, &quot;Marker #%d, type %d at (%d, %d) out of bounds&quot;,</a>
<a name="ln437">                 i, (int) type, marker-&gt;pos.x, marker-&gt;pos.y);</a>
<a name="ln438">            continue;</a>
<a name="ln439">        }</a>
<a name="ln440"> </a>
<a name="ln441">        vector&lt;map_marker*&gt; at_pos = env.markers.get_markers_at(marker-&gt;pos);</a>
<a name="ln442">        if (find(begin(at_pos), end(at_pos), marker) == end(at_pos))</a>
<a name="ln443">        {</a>
<a name="ln444">            mprf(MSGCH_ERROR, &quot;Marker #%d, type %d at (%d, %d) unlinked&quot;,</a>
<a name="ln445">                 i, (int) type, marker-&gt;pos.x, marker-&gt;pos.y);</a>
<a name="ln446">        }</a>
<a name="ln447">    }</a>
<a name="ln448"> </a>
<a name="ln449">    const coord_def start(MAPGEN_BORDER, MAPGEN_BORDER);</a>
<a name="ln450">    const coord_def   end(GXM - MAPGEN_BORDER - 2, GYM - MAPGEN_BORDER - 2);</a>
<a name="ln451">    for (rectangle_iterator ri(start, end); ri; ++ri)</a>
<a name="ln452">    {</a>
<a name="ln453">        vector&lt;map_marker*&gt; at_pos = env.markers.get_markers_at(*ri);</a>
<a name="ln454"> </a>
<a name="ln455">        for (unsigned int i = 0; i &lt; at_pos.size(); ++i)</a>
<a name="ln456">        {</a>
<a name="ln457">            map_marker *marker = at_pos[i];</a>
<a name="ln458"> </a>
<a name="ln459">            if (marker == nullptr)</a>
<a name="ln460">            {</a>
<a name="ln461">                mprf(MSGCH_ERROR, &quot;Marker #%d at (%d, %d) nullptr&quot;,</a>
<a name="ln462">                     i, ri-&gt;x, ri-&gt;y);</a>
<a name="ln463">                continue;</a>
<a name="ln464">            }</a>
<a name="ln465">            if (marker-&gt;pos != *ri)</a>
<a name="ln466">            {</a>
<a name="ln467">                mprf(MSGCH_ERROR, &quot;Marker #%d, type %d at (%d, %d) &quot;</a>
<a name="ln468">                                  &quot;thinks it's at (%d, %d)&quot;,</a>
<a name="ln469">                     i, (int) marker-&gt;get_type(), ri-&gt;x, ri-&gt;y,</a>
<a name="ln470">                     marker-&gt;pos.x, marker-&gt;pos.y);</a>
<a name="ln471"> </a>
<a name="ln472">                if (!in_bounds(marker-&gt;pos))</a>
<a name="ln473">                    mprf(MSGCH_ERROR, &quot;Further, it thinks it's out of bounds.&quot;);</a>
<a name="ln474">            }</a>
<a name="ln475">        }</a>
<a name="ln476">    }</a>
<a name="ln477">} // _debug_marker_scan()</a>
<a name="ln478"> </a>
<a name="ln479">static void _debug_dump_markers()</a>
<a name="ln480">{</a>
<a name="ln481">    vector&lt;map_marker*&gt; markers = env.markers.get_all();</a>
<a name="ln482"> </a>
<a name="ln483">    for (unsigned int i = 0; i &lt; markers.size(); ++i)</a>
<a name="ln484">    {</a>
<a name="ln485">        map_marker* marker = markers[i];</a>
<a name="ln486"> </a>
<a name="ln487">        if (marker == nullptr || marker-&gt;get_type() == MAT_LUA_MARKER)</a>
<a name="ln488">            continue;</a>
<a name="ln489"> </a>
<a name="ln490">        mprf(MSGCH_DIAGNOSTICS, &quot;Marker #%d, type %d at (%d, %d): %s&quot;,</a>
<a name="ln491">             i, marker-&gt;get_type(),</a>
<a name="ln492">             marker-&gt;pos.x, marker-&gt;pos.y,</a>
<a name="ln493">             marker-&gt;debug_describe().c_str());</a>
<a name="ln494">    }</a>
<a name="ln495">}</a>
<a name="ln496"> </a>
<a name="ln497">static void _debug_dump_lua_markers(FILE *file)</a>
<a name="ln498">{</a>
<a name="ln499">    vector&lt;map_marker*&gt; markers = env.markers.get_all();</a>
<a name="ln500"> </a>
<a name="ln501">    for (unsigned int i = 0; i &lt; markers.size(); ++i)</a>
<a name="ln502">    {</a>
<a name="ln503">        map_marker* marker = markers[i];</a>
<a name="ln504"> </a>
<a name="ln505">        if (marker == nullptr || marker-&gt;get_type() != MAT_LUA_MARKER)</a>
<a name="ln506">            continue;</a>
<a name="ln507"> </a>
<a name="ln508">        map_lua_marker* lua_marker = dynamic_cast&lt;map_lua_marker*&gt;(marker);</a>
<a name="ln509"> </a>
<a name="ln510">        string result = lua_marker-&gt;debug_to_string();</a>
<a name="ln511"> </a>
<a name="ln512">        if (!result.empty() &amp;&amp; result[result.size() - 1] == '\n')</a>
<a name="ln513">            result = result.substr(0, result.size() - 1);</a>
<a name="ln514"> </a>
<a name="ln515">        fprintf(file, &quot;Lua marker %u at (%d, %d):\n&quot;,</a>
<a name="ln516">                i, marker-&gt;pos.x, marker-&gt;pos.y);</a>
<a name="ln517">        fprintf(file, &quot;{{{{\n&quot;);</a>
<a name="ln518">        fprintf(file, &quot;%s&quot;, result.c_str());</a>
<a name="ln519">        fprintf(file, &quot;}}}}\n&quot;);</a>
<a name="ln520">    }</a>
<a name="ln521">}</a>
<a name="ln522"> </a>
<a name="ln523">static void _debug_dump_lua_persist(FILE* file)</a>
<a name="ln524">{</a>
<a name="ln525">    lua_stack_cleaner cln(dlua);</a>
<a name="ln526"> </a>
<a name="ln527">    string result;</a>
<a name="ln528">    if (!dlua.callfn(&quot;persist_to_string&quot;, 0, 1))</a>
<a name="ln529">    {</a>
<a name="ln530">        result = make_stringf(&quot;error (persist_to_string): %s&quot;,</a>
<a name="ln531">                              dlua.error.c_str());</a>
<a name="ln532">    }</a>
<a name="ln533">    else if (lua_isstring(dlua, -1))</a>
<a name="ln534">        result = lua_tostring(dlua, -1);</a>
<a name="ln535">    else</a>
<a name="ln536">        result = &quot;persist_to_string() returned nothing&quot;;</a>
<a name="ln537"> </a>
<a name="ln538">    fprintf(file, &quot;%s&quot;, result.c_str());</a>
<a name="ln539">}</a>
<a name="ln540"> </a>
<a name="ln541">static void _dump_ver_stuff(FILE* file)</a>
<a name="ln542">{</a>
<a name="ln543">    fprintf(file, &quot;Version: %s %s\n&quot;, CRAWL, Version::Long);</a>
<a name="ln544">#if defined(UNIX)</a>
<a name="ln545">    fprintf(file, &quot;Platform: unix&quot;);</a>
<a name="ln546">#   if defined(TARGET_OS_MACOSX)</a>
<a name="ln547">    fprintf(file, &quot; (OS X)&quot;);</a>
<a name="ln548">#   endif</a>
<a name="ln549">    fprintf(file, &quot;\n&quot;);</a>
<a name="ln550">#elif defined(TARGET_OS_WINDOWS)</a>
<a name="ln551">    fprintf(file, &quot;Platform: Windows\n&quot;);</a>
<a name="ln552">#elif defined(TARGET_OS_DOS)</a>
<a name="ln553">    fprintf(file, &quot;Platform: DOS\n&quot;);</a>
<a name="ln554">#endif // UNIX</a>
<a name="ln555"> </a>
<a name="ln556">    fprintf(file, &quot;Bits: %d\n&quot;, (int)sizeof(void*)*8);</a>
<a name="ln557">    fprintf(file, &quot;Game mode: %s\n&quot;,</a>
<a name="ln558">            gametype_to_str(crawl_state.type).c_str());</a>
<a name="ln559"> </a>
<a name="ln560">#if defined(USE_TILE_LOCAL)</a>
<a name="ln561">    fprintf(file, &quot;Tiles: yes\n\n&quot;);</a>
<a name="ln562">#elif defined(USE_TILE_WEB)</a>
<a name="ln563">    fprintf(file, &quot;Tiles: online\n\n&quot;);</a>
<a name="ln564">#else</a>
<a name="ln565">    fprintf(file, &quot;Tiles: no\n\n&quot;);</a>
<a name="ln566">#endif</a>
<a name="ln567">    if (you.fully_seeded)</a>
<a name="ln568">    {</a>
<a name="ln569">        fprintf(file, &quot;Seed: %&quot; PRIu64 &quot;, deterministic pregen: %d\n&quot;,</a>
<a name="ln570">            crawl_state.seed, (int) you.deterministic_levelgen);</a>
<a name="ln571">    }</a>
<a name="ln572">    if (Version::history_size() &gt; 1)</a>
<a name="ln573">        fprintf(file, &quot;Version history:\n%s\n\n&quot;, Version::history().c_str());</a>
<a name="ln574">}</a>
<a name="ln575"> </a>
<a name="ln576">static void _dump_command_line(FILE *file)</a>
<a name="ln577">{</a>
<a name="ln578">    fprintf(file, &quot;Command line:&quot;);</a>
<a name="ln579">    for (const string&amp; str : crawl_state.command_line_arguments)</a>
<a name="ln580">        fprintf(file, &quot; %s&quot;, str.c_str());</a>
<a name="ln581">    if (crawl_state.command_line_arguments.empty())</a>
<a name="ln582">        fprintf(file, &quot; (unknown)&quot;);</a>
<a name="ln583">    fprintf(file, &quot;\n\n&quot;);</a>
<a name="ln584">}</a>
<a name="ln585"> </a>
<a name="ln586">// Dump any game options that could affect stability.</a>
<a name="ln587">static void _dump_options(FILE *file)</a>
<a name="ln588">{</a>
<a name="ln589">    fprintf(file, &quot;RC options:\n&quot;);</a>
<a name="ln590">    fprintf(file, &quot;restart_after_game = %s\n&quot;,</a>
<a name="ln591">            maybe_to_string(Options.restart_after_game).c_str());</a>
<a name="ln592">    fprintf(file, &quot;\n\n&quot;);</a>
<a name="ln593">}</a>
<a name="ln594"> </a>
<a name="ln595">// Defined in end.cc. Not a part of crawl_state, since that's a</a>
<a name="ln596">// global C++ instance which is free'd by exit() hooks when exit()</a>
<a name="ln597">// is called, and we don't want to reference free'd memory.</a>
<a name="ln598">extern bool CrawlIsExiting;</a>
<a name="ln599"> </a>
<a name="ln600">void do_crash_dump()</a>
<a name="ln601">{</a>
<a name="ln602">    if (CrawlIsExiting)</a>
<a name="ln603">    {</a>
<a name="ln604">        // We crashed during exit() callbacks, so it's likely that</a>
<a name="ln605">        // any global C++ instances we could reference would be</a>
<a name="ln606">        // free'd and invalid, plus their content likely wouldn't help</a>
<a name="ln607">        // tracking it down anyway. Thus, just do the bare bones</a>
<a name="ln608">        // info to stderr and quit.</a>
<a name="ln609">        fprintf(stderr, &quot;Crashed while calling exit()!!!!\n&quot;);</a>
<a name="ln610"> </a>
<a name="ln611">        _dump_ver_stuff(stderr);</a>
<a name="ln612"> </a>
<a name="ln613">        fprintf(stderr, &quot;%s\n\n&quot;, crash_signal_info().c_str());</a>
<a name="ln614">        write_stack_trace(stderr);</a>
<a name="ln615">        call_gdb(stderr);</a>
<a name="ln616"> </a>
<a name="ln617">        return;</a>
<a name="ln618">    }</a>
<a name="ln619"> </a>
<a name="ln620">    // Want same time for file name and crash milestone.</a>
<a name="ln621">    const time_t t = time(nullptr);</a>
<a name="ln622"> </a>
<a name="ln623">    string dir = (!Options.morgue_dir.empty() ? Options.morgue_dir :</a>
<a name="ln624">                  !SysEnv.crawl_dir.empty()   ? SysEnv.crawl_dir</a>
<a name="ln625">                                              : &quot;&quot;);</a>
<a name="ln626"> </a>
<a name="ln627">    if (!dir.empty() &amp;&amp; dir[dir.length() - 1] != FILE_SEPARATOR)</a>
<a name="ln628">        dir += FILE_SEPARATOR;</a>
<a name="ln629"> </a>
<a name="ln630">    char name[180] = {};</a>
<a name="ln631"> </a>
<a name="ln632">    snprintf(name, sizeof(name), &quot;%scrash-%s-%s.txt&quot;, dir.c_str(),</a>
<a name="ln633">            you.your_name.c_str(), make_file_time(t).c_str());</a>
<a name="ln634"> </a>
<a name="ln635">    const string signal_info = crash_signal_info();</a>
<a name="ln636">    const string cause_msg = _assert_msg.empty() ? signal_info : _assert_msg;</a>
<a name="ln637"> </a>
<a name="ln638">    if (!crawl_state.test &amp;&amp; !cause_msg.empty())</a>
<a name="ln639">        fprintf(stderr, &quot;\n%s&quot;, cause_msg.c_str());</a>
<a name="ln640">    // This message is parsed by the WebTiles server.</a>
<a name="ln641">    fprintf(stderr,</a>
<a name="ln642">            &quot;\n\nWe crashed! This is likely due to a bug in Crawl. &quot;</a>
<a name="ln643">            &quot;\nPlease submit a bug report at https://crawl.develz.org/mantis/ &quot;</a>
<a name="ln644">            &quot;and include:&quot;</a>
<a name="ln645">            &quot;\n- The crash report: %s&quot;</a>
<a name="ln646">            &quot;\n- Your save file: %s&quot;</a>
<a name="ln647">            &quot;\n- A description of what you were doing when this crash occurred.\n\n&quot;,</a>
<a name="ln648">            name, get_savedir_filename(you.your_name).c_str());</a>
<a name="ln649">    errno = 0;</a>
<a name="ln650">    FILE* file = crawl_state.test ? stderr : freopen(name, &quot;a+&quot;, stderr);</a>
<a name="ln651"> </a>
<a name="ln652">    // The errno values are only relevant when the function in</a>
<a name="ln653">    // question has returned a value indicating (possible) failure, so</a>
<a name="ln654">    // only freak out if freopen() returned nullptr!</a>
<a name="ln655">    if (!file)</a>
<a name="ln656">    {</a>
<a name="ln657">        fprintf(stdout, &quot;\nUnable to open file '%s' for writing: %s\n&quot;,</a>
<a name="ln658">                name, strerror(errno));</a>
<a name="ln659">        file = stdout;</a>
<a name="ln660">    }</a>
<a name="ln661"> </a>
<a name="ln662">    // Unbuffer the file, since if we recursively crash buffered lines</a>
<a name="ln663">    // won't make it to the file.</a>
<a name="ln664">    setvbuf(file, nullptr, _IONBF, 0);</a>
<a name="ln665"> </a>
<a name="ln666">    set_msg_dump_file(file);</a>
<a name="ln667"> </a>
<a name="ln668">    if (!cause_msg.empty())</a>
<a name="ln669">        fprintf(file, &quot;%s\n\n&quot;, cause_msg.c_str());</a>
<a name="ln670"> </a>
<a name="ln671">    _dump_ver_stuff(file);</a>
<a name="ln672"> </a>
<a name="ln673">    _dump_command_line(file);</a>
<a name="ln674"> </a>
<a name="ln675">    _dump_options(file);</a>
<a name="ln676"> </a>
<a name="ln677">    // First get the immediate cause of the crash and the stack trace,</a>
<a name="ln678">    // since that's most important and later attempts to get more information</a>
<a name="ln679">    // might themselves cause crashes.</a>
<a name="ln680">    if (!signal_info.empty())</a>
<a name="ln681">        fprintf(file, &quot;%s\n\n&quot;, signal_info.c_str());</a>
<a name="ln682">    write_stack_trace(file);</a>
<a name="ln683">    fprintf(file, &quot;\n&quot;);</a>
<a name="ln684"> </a>
<a name="ln685">    call_gdb(file);</a>
<a name="ln686">    fprintf(file, &quot;\n&quot;);</a>
<a name="ln687"> </a>
<a name="ln688">    // Next information on how the binary was compiled</a>
<a name="ln689">    _dump_compilation_info(file);</a>
<a name="ln690"> </a>
<a name="ln691">    // Next information about the level the player is on, plus level</a>
<a name="ln692">    // generation info if the crash happened during level generation.</a>
<a name="ln693">    _dump_level_info(file);</a>
<a name="ln694"> </a>
<a name="ln695">    // Dumping information on marker inconsistancy is unlikely to crash,</a>
<a name="ln696">    // as is dumping the descriptions of non-Lua markers.</a>
<a name="ln697">    fprintf(file, &quot;Markers:\n&quot;);</a>
<a name="ln698">    fprintf(file, &quot;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;\n&quot;);</a>
<a name="ln699">    _debug_marker_scan();</a>
<a name="ln700">    _debug_dump_markers();</a>
<a name="ln701">    fprintf(file, &quot;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;\n&quot;);</a>
<a name="ln702"> </a>
<a name="ln703">    // Dumping current messages is unlikely to crash.</a>
<a name="ln704">    if (file != stdout)</a>
<a name="ln705">    {</a>
<a name="ln706">        fprintf(file, &quot;\nMessages:\n&quot;);</a>
<a name="ln707">        fprintf(file, &quot;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;\n&quot;);</a>
<a name="ln708">        string messages = get_last_messages(NUM_STORED_MESSAGES, true);</a>
<a name="ln709">        fprintf(file, &quot;%s&quot;, messages.c_str());</a>
<a name="ln710">        fprintf(file, &quot;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;\n&quot;);</a>
<a name="ln711">    }</a>
<a name="ln712"> </a>
<a name="ln713">    // Dumping the player state and crawl state is next least likely to cause</a>
<a name="ln714">    // another crash, so do that next.</a>
<a name="ln715">    fprintf(file, &quot;\nVersion history:\n%s\n&quot;, Version::history().c_str());</a>
<a name="ln716">    crawl_state.dump();</a>
<a name="ln717">    _dump_player(file);</a>
<a name="ln718"> </a>
<a name="ln719">    // Next item and monster scans. Any messages will be sent straight to</a>
<a name="ln720">    // the file because of set_msg_dump_file()</a>
<a name="ln721">#ifdef DEBUG_ITEM_SCAN</a>
<a name="ln722">    if (crawl_state.crash_debug_scans_safe)</a>
<a name="ln723">        debug_item_scan();</a>
<a name="ln724">    else</a>
<a name="ln725">        fprintf(file, &quot;\nCrashed while loading a save; skipping debug_item_scan.\n&quot;);</a>
<a name="ln726">#endif</a>
<a name="ln727">#ifdef DEBUG_MONS_SCAN</a>
<a name="ln728">    if (crawl_state.crash_debug_scans_safe)</a>
<a name="ln729">        debug_mons_scan();</a>
<a name="ln730">    else</a>
<a name="ln731">        fprintf(file, &quot;\nCrashed while loading a save; skipping debug_mons_scan.\n&quot;);</a>
<a name="ln732">#endif</a>
<a name="ln733"> </a>
<a name="ln734">    // Dump Webtiles message buffer.</a>
<a name="ln735">#ifdef USE_TILE_WEB</a>
<a name="ln736">    tiles.dump();</a>
<a name="ln737">#endif</a>
<a name="ln738"> </a>
<a name="ln739">    // Now a screenshot</a>
<a name="ln740">    if (crawl_state.generating_level)</a>
<a name="ln741">    {</a>
<a name="ln742">        fprintf(file, &quot;\nMap:\n&quot;);</a>
<a name="ln743">        dump_map(file, true);</a>
<a name="ln744">    }</a>
<a name="ln745">    else</a>
<a name="ln746">    {</a>
<a name="ln747">        fprintf(file, &quot;\nScreenshot:\n&quot;);</a>
<a name="ln748">        fprintf(file, &quot;%s\n&quot;, screenshot().c_str());</a>
<a name="ln749">    }</a>
<a name="ln750"> </a>
<a name="ln751">    // If anything has screwed up the Lua runtime stacks then trying to</a>
<a name="ln752">    // print those stacks will likely crash, so do this after the others.</a>
<a name="ln753">    fprintf(file, &quot;clua stack:\n&quot;);</a>
<a name="ln754">    clua.print_stack();</a>
<a name="ln755"> </a>
<a name="ln756">    fprintf(file, &quot;dlua stack:\n&quot;);</a>
<a name="ln757">    dlua.print_stack();</a>
<a name="ln758"> </a>
<a name="ln759">    // Lastly try to dump the Lua persistent data and the contents of the Lua</a>
<a name="ln760">    // markers, since actually running Lua code has the greatest chance of</a>
<a name="ln761">    // crashing.</a>
<a name="ln762">    fprintf(file, &quot;Lua persistent data:\n&quot;);</a>
<a name="ln763">    fprintf(file, &quot;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;\n&quot;);</a>
<a name="ln764">    _debug_dump_lua_persist(file);</a>
<a name="ln765">    fprintf(file, &quot;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;\n\n&quot;);</a>
<a name="ln766">    fprintf(file, &quot;Lua marker contents:\n&quot;);</a>
<a name="ln767">    fprintf(file, &quot;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;\n&quot;);</a>
<a name="ln768">    _debug_dump_lua_markers(file);</a>
<a name="ln769">    fprintf(file, &quot;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;\n&quot;);</a>
<a name="ln770"> </a>
<a name="ln771">    set_msg_dump_file(nullptr);</a>
<a name="ln772"> </a>
<a name="ln773">    mark_milestone(&quot;crash&quot;, cause_msg, &quot;&quot;, t);</a>
<a name="ln774"> </a>
<a name="ln775">    if (file != stderr)</a>
<a name="ln776">        fclose(file);</a>
<a name="ln777">}</a>
<a name="ln778"> </a>
<a name="ln779">///////////////////////////////////////////////////////////////////////</a>
<a name="ln780">///////////////////////////////////////////////////////////////////////</a>
<a name="ln781"> </a>
<a name="ln782">// Assertions and such</a>
<a name="ln783"> </a>
<a name="ln784">NORETURN static void _BreakStrToDebugger(const char *mesg, bool assert)</a>
<a name="ln785">{</a>
<a name="ln786">    UNUSED(assert);</a>
<a name="ln787">// FIXME: this needs a way to get the SDL_window in windowmanager-sdl.cc</a>
<a name="ln788">#if 0</a>
<a name="ln789">#if defined(USE_TILE_LOCAL) &amp;&amp; defined(TARGET_OS_WINDOWS)</a>
<a name="ln790">    SDL_SysWMinfo SysInfo;</a>
<a name="ln791">    SDL_VERSION(&amp;SysInfo.version);</a>
<a name="ln792">    if (SDL_GetWindowWMInfo(window, &amp;SysInfo) &gt; 0)</a>
<a name="ln793">    {</a>
<a name="ln794">        MessageBoxW(window, OUTW(mesg),</a>
<a name="ln795">                   assert ? L&quot;Assertion failed!&quot; : L&quot;Error&quot;,</a>
<a name="ln796">                   MB_OK|MB_ICONERROR);</a>
<a name="ln797">    }</a>
<a name="ln798">    // Print the message to STDERR in addition to the above message box,</a>
<a name="ln799">    // so it's in the message history if we call Crawl from a shell.</a>
<a name="ln800">#endif</a>
<a name="ln801">#endif</a>
<a name="ln802">    fprintf(stderr, &quot;%s\n&quot;, mesg);</a>
<a name="ln803"> </a>
<a name="ln804">#if defined(TARGET_OS_WINDOWS)</a>
<a name="ln805">    OutputDebugString(mesg);</a>
<a name="ln806">    if (IsDebuggerPresent())</a>
<a name="ln807">        DebugBreak();</a>
<a name="ln808">#endif</a>
<a name="ln809"> </a>
<a name="ln810">#if defined(TARGET_OS_MACOSX)</a>
<a name="ln811">// raise(SIGINT);               // this is what DebugStr() does on OS X according to Tech Note 2030</a>
<a name="ln812">    int* p = nullptr;           // but this gives us a stack crawl...</a>
<a name="ln813">    *p = 0;</a>
<a name="ln814">#endif</a>
<a name="ln815"> </a>
<a name="ln816">    // MSVCRT's abort() give's a funny message ...</a>
<a name="ln817">    raise(SIGABRT);</a>
<a name="ln818">    abort();</a>
<a name="ln819">}</a>
<a name="ln820"> </a>
<a name="ln821">#ifdef ASSERTS</a>
<a name="ln822">NORETURN void AssertFailed(const char *expr, const char *file, int line,</a>
<a name="ln823">                           const char *text, ...)</a>
<a name="ln824">{</a>
<a name="ln825">    char mesg[512];</a>
<a name="ln826">    va_list args;</a>
<a name="ln827"> </a>
<a name="ln828">    const char *fileName = file + strlen(file); // strip off path</a>
<a name="ln829"> </a>
<a name="ln830">    while (fileName &gt; file &amp;&amp; fileName[-1] != '\\')</a>
<a name="ln831">        --fileName;</a>
<a name="ln832"> </a>
<a name="ln833">    snprintf(mesg, sizeof(mesg), &quot;ASSERT(%s) in '%s' at line %d failed.&quot;,</a>
<a name="ln834">             expr, fileName, line);</a>
<a name="ln835"> </a>
<a name="ln836">    _assert_msg = mesg;</a>
<a name="ln837"> </a>
<a name="ln838">    // Compose additional information that was passed</a>
<a name="ln839">    if (text)</a>
<a name="ln840">    {</a>
<a name="ln841">        // Write the args into the format specified by text</a>
<a name="ln842">        char detail[512];</a>
<a name="ln843">        va_start(args, text);</a>
<a name="ln844">        vsnprintf(detail, sizeof(detail), text, args);</a>
<a name="ln845">        va_end(args);</a>
<a name="ln846">        // Build the final result</a>
<a name="ln847">        char final_mesg[1026];</a>
<a name="ln848">        snprintf(final_mesg, sizeof(final_mesg), &quot;%s (%s)&quot;, mesg, detail);</a>
<a name="ln849">        _assert_msg = final_mesg;</a>
<a name="ln850">        _BreakStrToDebugger(final_mesg, true);</a>
<a name="ln851">    }</a>
<a name="ln852">    else</a>
<a name="ln853">    {</a>
<a name="ln854">        _assert_msg = mesg;</a>
<a name="ln855">        _BreakStrToDebugger(mesg, true);</a>
<a name="ln856">    }</a>
<a name="ln857">}</a>
<a name="ln858">#endif</a>
<a name="ln859"> </a>
<a name="ln860">#undef die</a>
<a name="ln861">NORETURN void die(const char *file, int line, const char *format, ...)</a>
<a name="ln862">{</a>
<a name="ln863">    char tmp[2048] = {};</a>
<a name="ln864">    char mesg[2071] = {};</a>
<a name="ln865"> </a>
<a name="ln866">    va_list args;</a>
<a name="ln867"> </a>
<a name="ln868">    va_start(args, format);</a>
<a name="ln869">    vsnprintf(tmp, sizeof(tmp), format, args);</a>
<a name="ln870">    va_end(args);</a>
<a name="ln871"> </a>
<a name="ln872">    snprintf(mesg, sizeof(mesg), &quot;ERROR in '%s' at line %d: %s&quot;,</a>
<a name="ln873">             file, line, tmp);</a>
<a name="ln874"> </a>
<a name="ln875">    _assert_msg = mesg;</a>
<a name="ln876"> </a>
<a name="ln877">    _BreakStrToDebugger(mesg, false);</a>
<a name="ln878">}</a>
<a name="ln879"> </a>
<a name="ln880">NORETURN void die_noline(const char *format, ...)</a>
<a name="ln881">{</a>
<a name="ln882">    char tmp[2048] = {};</a>
<a name="ln883">    char mesg[2055] = {};</a>
<a name="ln884"> </a>
<a name="ln885">    va_list args;</a>
<a name="ln886"> </a>
<a name="ln887">    va_start(args, format);</a>
<a name="ln888">    vsnprintf(tmp, sizeof(tmp), format, args);</a>
<a name="ln889">    va_end(args);</a>
<a name="ln890"> </a>
<a name="ln891">    snprintf(mesg, sizeof(mesg), &quot;ERROR: %s&quot;, tmp);</a>
<a name="ln892"> </a>
<a name="ln893">#ifdef __ANDROID__</a>
<a name="ln894">    __android_log_print(ANDROID_LOG_INFO, &quot;Crawl&quot;, &quot;%s&quot;, mesg);</a>
<a name="ln895">#endif</a>
<a name="ln896"> </a>
<a name="ln897">    _assert_msg = mesg;</a>
<a name="ln898"> </a>
<a name="ln899">    _BreakStrToDebugger(mesg, false);</a>
<a name="ln900">}</a>

</code></pre>
<div class="balloon" rel="209"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v560/" target="_blank">V560</a> A part of conditional expression is always true: sk >= 0.</p></div>
<div class="balloon" rel="211"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v560/" target="_blank">V560</a> A part of conditional expression is always true: sk >= 0.</p></div>
<div class="balloon" rel="428"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v1016/" target="_blank">V1016</a> Expression 'type < MAT_FEATURE' is always false.</p></div>
<div class="balloon" rel="510"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v522/" target="_blank">V522</a> There might be dereferencing of a potential null pointer 'lua_marker'.</p></div>

<link rel="stylesheet" href="highlight.css">
<script src="highlight.pack.js"></script>
<script src="highlightjs-line-numbers.js"></script>
<script>hljs.initHighlightingOnLoad();</script>
<script>hljs.initLineNumbersOnLoad();</script>
<script>
  $(document).ready(function() {
      $('.balloon').each(function () {
          var bl = $(this);
          var line = bl.attr('rel');
          var text = $('a[name="ln'+line+'"]').text();

          var space_count = 0;
          for(var i = 0; i<text.length; i++){
              var char = text[i];
              if((char !== ' ')&&(char !== '\t'))break;
              if(char === '\t')space_count++;
              space_count++;
          }

          bl.css('margin-left', space_count*8);
          $('a[name="ln'+line+'"]').after(bl);
      });

      window.location = window.location;
  });
</script>
</body>
</html>
