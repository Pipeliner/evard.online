
<html>
<head>

  <meta http-equiv="Content-Type" content="text/html; charset=US-ASCII" />
  <title>spl-summoning.cc</title>

  <link rel="stylesheet" href="../style.css"/>
  <script src="../jquery-3.2.1.min.js"></script>
</head>
<body>

<pre><code class = "cpp">
<a name="ln1">/**</a>
<a name="ln2"> * @file</a>
<a name="ln3"> * @brief Summoning spells and other effects creating monsters.</a>
<a name="ln4">**/</a>
<a name="ln5"> </a>
<a name="ln6">#include &quot;AppHdr.h&quot;</a>
<a name="ln7"> </a>
<a name="ln8">#include &quot;spl-summoning.h&quot;</a>
<a name="ln9"> </a>
<a name="ln10">#include &lt;algorithm&gt;</a>
<a name="ln11">#include &lt;cmath&gt;</a>
<a name="ln12"> </a>
<a name="ln13">#include &quot;act-iter.h&quot;</a>
<a name="ln14">#include &quot;areas.h&quot;</a>
<a name="ln15">#include &quot;artefact.h&quot;</a>
<a name="ln16">#include &quot;butcher.h&quot;</a>
<a name="ln17">#include &quot;cloud.h&quot;</a>
<a name="ln18">#include &quot;colour.h&quot;</a>
<a name="ln19">#include &quot;coordit.h&quot;</a>
<a name="ln20">#include &quot;database.h&quot;</a>
<a name="ln21">#include &quot;delay.h&quot;</a>
<a name="ln22">#include &quot;directn.h&quot;</a>
<a name="ln23">#include &quot;dungeon.h&quot;</a>
<a name="ln24">#include &quot;english.h&quot;</a>
<a name="ln25">#include &quot;env.h&quot;</a>
<a name="ln26">#include &quot;fight.h&quot;</a>
<a name="ln27">#include &quot;fprop.h&quot;</a>
<a name="ln28">#include &quot;god-conduct.h&quot;</a>
<a name="ln29">#include &quot;god-item.h&quot;</a>
<a name="ln30">#include &quot;invent.h&quot;</a>
<a name="ln31">#include &quot;item-prop.h&quot;</a>
<a name="ln32">#include &quot;item-status-flag-type.h&quot;</a>
<a name="ln33">#include &quot;items.h&quot;</a>
<a name="ln34">#include &quot;libutil.h&quot;</a>
<a name="ln35">#include &quot;mapmark.h&quot;</a>
<a name="ln36">#include &quot;message.h&quot;</a>
<a name="ln37">#include &quot;mgen-data.h&quot;</a>
<a name="ln38">#include &quot;mon-abil.h&quot;</a>
<a name="ln39">#include &quot;mon-act.h&quot;</a>
<a name="ln40">#include &quot;mon-behv.h&quot;</a>
<a name="ln41">#include &quot;mon-book.h&quot; // MON_SPELL_WIZARD</a>
<a name="ln42">#include &quot;mon-cast.h&quot;</a>
<a name="ln43">#include &quot;mon-death.h&quot;</a>
<a name="ln44">#include &quot;mon-movetarget.h&quot;</a>
<a name="ln45">#include &quot;mon-place.h&quot;</a>
<a name="ln46">#include &quot;mon-speak.h&quot;</a>
<a name="ln47">#include &quot;player-equip.h&quot;</a>
<a name="ln48">#include &quot;player-stats.h&quot;</a>
<a name="ln49">#include &quot;prompt.h&quot;</a>
<a name="ln50">#include &quot;religion.h&quot;</a>
<a name="ln51">#include &quot;shout.h&quot;</a>
<a name="ln52">#include &quot;spl-util.h&quot;</a>
<a name="ln53">#include &quot;spl-wpnench.h&quot;</a>
<a name="ln54">#include &quot;spl-zap.h&quot;</a>
<a name="ln55">#include &quot;state.h&quot;</a>
<a name="ln56">#include &quot;stepdown.h&quot;</a>
<a name="ln57">#include &quot;stringutil.h&quot;</a>
<a name="ln58">#include &quot;target.h&quot;</a>
<a name="ln59">#include &quot;teleport.h&quot;</a>
<a name="ln60">#include &quot;terrain.h&quot;</a>
<a name="ln61">#include &quot;timed-effects.h&quot;</a>
<a name="ln62">#include &quot;unwind.h&quot;</a>
<a name="ln63">#include &quot;viewchar.h&quot;</a>
<a name="ln64">#include &quot;xom.h&quot;</a>
<a name="ln65"> </a>
<a name="ln66">static void _monster_greeting(monster *mons, const string &amp;key)</a>
<a name="ln67">{</a>
<a name="ln68">    string msg = getSpeakString(key);</a>
<a name="ln69">    if (msg == &quot;__NONE&quot;)</a>
<a name="ln70">        msg.clear();</a>
<a name="ln71">    mons_speaks_msg(mons, msg, MSGCH_TALK, silenced(mons-&gt;pos()));</a>
<a name="ln72">}</a>
<a name="ln73"> </a>
<a name="ln74">static mgen_data _summon_data(const actor &amp;caster, monster_type mtyp,</a>
<a name="ln75">                              int dur, god_type god, spell_type spell)</a>
<a name="ln76">{</a>
<a name="ln77">    return mgen_data(mtyp, BEH_COPY, caster.pos(),</a>
<a name="ln78">                     caster.is_player() ? int{MHITYOU}</a>
<a name="ln79">                                        : caster.as_monster()-&gt;foe,</a>
<a name="ln80">                     MG_AUTOFOE)</a>
<a name="ln81">                     .set_summoned(&amp;caster, dur, spell, god);</a>
<a name="ln82">}</a>
<a name="ln83"> </a>
<a name="ln84">static mgen_data _pal_data(monster_type pal, int dur, god_type god,</a>
<a name="ln85">                           spell_type spell)</a>
<a name="ln86">{</a>
<a name="ln87">    return _summon_data(you, pal, dur, god, spell);</a>
<a name="ln88">}</a>
<a name="ln89"> </a>
<a name="ln90">spret cast_summon_butterflies(int pow, god_type god, bool fail)</a>
<a name="ln91">{</a>
<a name="ln92">    if (otr_stop_summoning_prompt())</a>
<a name="ln93">        return spret::abort;</a>
<a name="ln94"> </a>
<a name="ln95">    fail_check();</a>
<a name="ln96">    bool success = false;</a>
<a name="ln97"> </a>
<a name="ln98">    const int how_many = min(8, 3 + random2(3) + random2(pow) / 10);</a>
<a name="ln99"> </a>
<a name="ln100">    for (int i = 0; i &lt; how_many; ++i)</a>
<a name="ln101">    {</a>
<a name="ln102">        if (create_monster(_pal_data(MONS_BUTTERFLY, 3, god,</a>
<a name="ln103">                                     SPELL_SUMMON_BUTTERFLIES)))</a>
<a name="ln104">        {</a>
<a name="ln105">            success = true;</a>
<a name="ln106">        }</a>
<a name="ln107">    }</a>
<a name="ln108"> </a>
<a name="ln109">    if (!success)</a>
<a name="ln110">        canned_msg(MSG_NOTHING_HAPPENS);</a>
<a name="ln111"> </a>
<a name="ln112">    return spret::success;</a>
<a name="ln113">}</a>
<a name="ln114"> </a>
<a name="ln115">spret cast_summon_small_mammal(int pow, god_type god, bool fail)</a>
<a name="ln116">{</a>
<a name="ln117">    if (otr_stop_summoning_prompt())</a>
<a name="ln118">        return spret::abort;</a>
<a name="ln119"> </a>
<a name="ln120">    fail_check();</a>
<a name="ln121"> </a>
<a name="ln122">    monster_type mon = MONS_PROGRAM_BUG;</a>
<a name="ln123"> </a>
<a name="ln124">    if (x_chance_in_y(10, pow + 1))</a>
<a name="ln125">        mon = random_choose(MONS_BAT, MONS_RAT);</a>
<a name="ln126">    else</a>
<a name="ln127">        mon = MONS_QUOKKA;</a>
<a name="ln128"> </a>
<a name="ln129">    if (!create_monster(_pal_data(mon, 3, god, SPELL_SUMMON_SMALL_MAMMAL)))</a>
<a name="ln130">        canned_msg(MSG_NOTHING_HAPPENS);</a>
<a name="ln131"> </a>
<a name="ln132">    return spret::success;</a>
<a name="ln133">}</a>
<a name="ln134"> </a>
<a name="ln135">spret cast_sticks_to_snakes(int pow, god_type god, bool fail)</a>
<a name="ln136">{</a>
<a name="ln137">    // The first items placed into this list will be the first</a>
<a name="ln138">    // to be converted; for players with bow skill we prefer</a>
<a name="ln139">    // plain arrows.</a>
<a name="ln140">    // For players without bow skill, we prefer arrows with the</a>
<a name="ln141">    // smallest quantity, in order to free up inventory sooner</a>
<a name="ln142">    list&lt;item_def*&gt; valid_sticks;</a>
<a name="ln143">    int num_sticks = 0;</a>
<a name="ln144">    for (item_def&amp; i : you.inv)</a>
<a name="ln145">        if (i.is_type(OBJ_MISSILES, MI_ARROW)</a>
<a name="ln146">            &amp;&amp; check_warning_inscriptions(i, OPER_DESTROY))</a>
<a name="ln147">        {</a>
<a name="ln148">            // If the player has bow skill, assume that they</a>
<a name="ln149">            // would prefer that their regular ammo would be</a>
<a name="ln150">            // used first</a>
<a name="ln151">            if (get_ammo_brand(i) == SPMSL_NORMAL)</a>
<a name="ln152">                valid_sticks.push_front(&amp;i);</a>
<a name="ln153">            else</a>
<a name="ln154">                valid_sticks.push_back(&amp;i);</a>
<a name="ln155">            num_sticks += i.quantity;</a>
<a name="ln156">        }</a>
<a name="ln157"> </a>
<a name="ln158">    if (valid_sticks.empty())</a>
<a name="ln159">    {</a>
<a name="ln160">        mpr(&quot;You don't have anything to turn into a snake.&quot;);</a>
<a name="ln161">        return spret::abort;</a>
<a name="ln162">    }</a>
<a name="ln163"> </a>
<a name="ln164">    if (otr_stop_summoning_prompt(&quot;create snakes&quot;))</a>
<a name="ln165">        return spret::abort;</a>
<a name="ln166"> </a>
<a name="ln167">    // Sort by the quantity if the player has no bow skill; this will</a>
<a name="ln168">    // put arrows with the smallest quantity first in line</a>
<a name="ln169">    // If the player has bow skill, we will already have plain arrows</a>
<a name="ln170">    // in the first element, so skip this</a>
<a name="ln171">    if (you.skills[SK_BOWS] &lt; 1)</a>
<a name="ln172">    {</a>
<a name="ln173">        valid_sticks.sort([](const item_def* a, const item_def* b) -&gt; bool</a>
<a name="ln174">                             {</a>
<a name="ln175">                                 return a-&gt;quantity &lt; b-&gt;quantity;</a>
<a name="ln176">                             }</a>
<a name="ln177">                         );</a>
<a name="ln178">    }</a>
<a name="ln179">    const int dur = min(3 + random2(pow) / 20, 5);</a>
<a name="ln180">    int how_many_max = 1 + min(6, random2(pow) / 15);</a>
<a name="ln181"> </a>
<a name="ln182">    int count = 0;</a>
<a name="ln183"> </a>
<a name="ln184">    fail_check();</a>
<a name="ln185">    if (num_sticks &lt; how_many_max)</a>
<a name="ln186">        how_many_max = num_sticks;</a>
<a name="ln187">    item_def *stick = nullptr;</a>
<a name="ln188">    for (int i = 0; i &lt; how_many_max; i++)</a>
<a name="ln189">    {</a>
<a name="ln190">        monster_type mon;</a>
<a name="ln191">        if (!stick || stick-&gt;quantity == 0)</a>
<a name="ln192">        {</a>
<a name="ln193">            stick = valid_sticks.front();</a>
<a name="ln194">            valid_sticks.pop_front();</a>
<a name="ln195">        }</a>
<a name="ln196">        if (one_chance_in(5 - min(4, div_rand_round(pow * 2, 25))))</a>
<a name="ln197">        {</a>
<a name="ln198">            mon = x_chance_in_y(pow / 3, 100) ? MONS_WATER_MOCCASIN</a>
<a name="ln199">                                              : MONS_ADDER;</a>
<a name="ln200">        }</a>
<a name="ln201">        else</a>
<a name="ln202">            mon = MONS_BALL_PYTHON;</a>
<a name="ln203">        if (monster *snake = create_monster(_pal_data(mon, 0, god,</a>
<a name="ln204">                                                      SPELL_STICKS_TO_SNAKES),</a>
<a name="ln205">                                            false))</a>
<a name="ln206">        {</a>
<a name="ln207">            count++;</a>
<a name="ln208">            dec_inv_item_quantity(letter_to_index(stick-&gt;slot), 1);</a>
<a name="ln209">            snake-&gt;add_ench(mon_enchant(ENCH_FAKE_ABJURATION, dur));</a>
<a name="ln210">        }</a>
<a name="ln211">    }</a>
<a name="ln212">    if (count)</a>
<a name="ln213">    {</a>
<a name="ln214">        int sticks_left = num_sticks - count;</a>
<a name="ln215"> </a>
<a name="ln216">        if (count &gt; 1)</a>
<a name="ln217">            mprf(&quot;You create %d snakes!&quot;, count);</a>
<a name="ln218">        else</a>
<a name="ln219">            mpr(&quot;You create a snake!&quot;);</a>
<a name="ln220"> </a>
<a name="ln221">        if (sticks_left)</a>
<a name="ln222">        {</a>
<a name="ln223">            mprf(&quot;You now have %d arrow%s.&quot;, sticks_left,</a>
<a name="ln224">                                             sticks_left &gt; 1 ? &quot;s&quot; : &quot;&quot;);</a>
<a name="ln225">        }</a>
<a name="ln226">        else</a>
<a name="ln227">            mpr(&quot;You now have no arrows remaining.&quot;);</a>
<a name="ln228">    }</a>
<a name="ln229">    else</a>
<a name="ln230">        mpr(&quot;You fail to create any snakes.&quot;);</a>
<a name="ln231"> </a>
<a name="ln232">    return spret::success;</a>
<a name="ln233">}</a>
<a name="ln234"> </a>
<a name="ln235">spret cast_call_canine_familiar(int pow, god_type god, bool fail)</a>
<a name="ln236">{</a>
<a name="ln237">    if (otr_stop_summoning_prompt())</a>
<a name="ln238">        return spret::abort;</a>
<a name="ln239"> </a>
<a name="ln240">    fail_check();</a>
<a name="ln241">    monster_type mon = MONS_PROGRAM_BUG;</a>
<a name="ln242"> </a>
<a name="ln243">    const int chance = pow + random_range(-10, 10);</a>
<a name="ln244"> </a>
<a name="ln245">    if (chance &gt; 59)</a>
<a name="ln246">        mon = MONS_WARG;</a>
<a name="ln247">    else if (chance &gt; 39)</a>
<a name="ln248">        mon = MONS_WOLF;</a>
<a name="ln249">    else</a>
<a name="ln250">        mon = MONS_HOUND;</a>
<a name="ln251"> </a>
<a name="ln252">    const int dur = min(2 + (random2(pow) / 4), 6);</a>
<a name="ln253"> </a>
<a name="ln254">    if (!create_monster(_pal_data(mon, dur, god, SPELL_CALL_CANINE_FAMILIAR)))</a>
<a name="ln255">        canned_msg(MSG_NOTHING_HAPPENS);</a>
<a name="ln256"> </a>
<a name="ln257">    return spret::success;</a>
<a name="ln258">}</a>
<a name="ln259"> </a>
<a name="ln260">spret cast_summon_ice_beast(int pow, god_type god, bool fail)</a>
<a name="ln261">{</a>
<a name="ln262">    fail_check();</a>
<a name="ln263">    const int dur = min(2 + (random2(pow) / 4), 4);</a>
<a name="ln264"> </a>
<a name="ln265">    mgen_data ice_beast = _pal_data(MONS_ICE_BEAST, dur, god,</a>
<a name="ln266">                                    SPELL_SUMMON_ICE_BEAST);</a>
<a name="ln267">    ice_beast.hd = (3 + div_rand_round(pow, 13));</a>
<a name="ln268"> </a>
<a name="ln269">    if (create_monster(ice_beast))</a>
<a name="ln270">        mpr(&quot;A chill wind blows around you.&quot;);</a>
<a name="ln271">    else</a>
<a name="ln272">        canned_msg(MSG_NOTHING_HAPPENS);</a>
<a name="ln273"> </a>
<a name="ln274">    return spret::success;</a>
<a name="ln275">}</a>
<a name="ln276"> </a>
<a name="ln277">spret cast_monstrous_menagerie(actor* caster, int pow, god_type god, bool fail)</a>
<a name="ln278">{</a>
<a name="ln279">    if (caster-&gt;is_player() &amp;&amp; otr_stop_summoning_prompt())</a>
<a name="ln280">        return spret::abort;</a>
<a name="ln281"> </a>
<a name="ln282">    fail_check();</a>
<a name="ln283">    monster_type type = MONS_PROGRAM_BUG;</a>
<a name="ln284"> </a>
<a name="ln285">    if (random2(pow) &gt; 60 &amp;&amp; coinflip())</a>
<a name="ln286">        type = MONS_SPHINX;</a>
<a name="ln287">    else</a>
<a name="ln288">        type = random_choose(MONS_HARPY, MONS_MANTICORE, MONS_LINDWURM);</a>
<a name="ln289"> </a>
<a name="ln290">    if (player_will_anger_monster(type))</a>
<a name="ln291">        type = MONS_MANTICORE;</a>
<a name="ln292"> </a>
<a name="ln293">    int num = (type == MONS_HARPY ? 1 + x_chance_in_y(pow, 80)</a>
<a name="ln294">                                      + x_chance_in_y(pow - 75, 100)</a>
<a name="ln295">                                  : 1);</a>
<a name="ln296">    const bool plural = (num &gt; 1);</a>
<a name="ln297"> </a>
<a name="ln298">    mgen_data mdata = _summon_data(*caster, type, 4, god,</a>
<a name="ln299">                                   SPELL_MONSTROUS_MENAGERIE);</a>
<a name="ln300">    mdata.flags |= MG_DONT_CAP;</a>
<a name="ln301">    if (caster-&gt;is_player())</a>
<a name="ln302">        mdata.hd = get_monster_data(type)-&gt;HD + div_rand_round(pow - 50, 25);</a>
<a name="ln303"> </a>
<a name="ln304">    bool seen = false;</a>
<a name="ln305">    bool first = true;</a>
<a name="ln306">    int mid = -1;</a>
<a name="ln307">    while (num-- &gt; 0)</a>
<a name="ln308">    {</a>
<a name="ln309">        if (monster* beast = create_monster(mdata))</a>
<a name="ln310">        {</a>
<a name="ln311">            if (you.can_see(*beast))</a>
<a name="ln312">                seen = true;</a>
<a name="ln313"> </a>
<a name="ln314">            // Link the harpies together as one entity as far as the summon</a>
<a name="ln315">            // cap is concerned.</a>
<a name="ln316">            if (type == MONS_HARPY)</a>
<a name="ln317">            {</a>
<a name="ln318">                if (mid == -1)</a>
<a name="ln319">                    mid = beast-&gt;mid;</a>
<a name="ln320"> </a>
<a name="ln321">                beast-&gt;props[&quot;summon_id&quot;].get_int() = mid;</a>
<a name="ln322">            }</a>
<a name="ln323"> </a>
<a name="ln324">            // Handle cap only for the first of the batch being summoned</a>
<a name="ln325">            if (first)</a>
<a name="ln326">                summoned_monster(beast, &amp;you, SPELL_MONSTROUS_MENAGERIE);</a>
<a name="ln327"> </a>
<a name="ln328">            first = false;</a>
<a name="ln329">        }</a>
<a name="ln330">    }</a>
<a name="ln331"> </a>
<a name="ln332">    if (seen)</a>
<a name="ln333">    {</a>
<a name="ln334">        mprf(&quot;%s %s %s %s!&quot;, caster-&gt;name(DESC_THE).c_str(),</a>
<a name="ln335">                             caster-&gt;conj_verb(&quot;summon&quot;).c_str(),</a>
<a name="ln336">                             plural ? &quot;some&quot; : &quot;a&quot;,</a>
<a name="ln337">                             plural ? pluralise_monster(mons_type_name(type, DESC_PLAIN)).c_str()</a>
<a name="ln338">                                    : mons_type_name(type, DESC_PLAIN).c_str());</a>
<a name="ln339">    }</a>
<a name="ln340">    else</a>
<a name="ln341">        canned_msg(MSG_NOTHING_HAPPENS);</a>
<a name="ln342"> </a>
<a name="ln343">    return spret::success;</a>
<a name="ln344">}</a>
<a name="ln345"> </a>
<a name="ln346">spret cast_summon_hydra(actor *caster, int pow, god_type god, bool fail)</a>
<a name="ln347">{</a>
<a name="ln348">    fail_check();</a>
<a name="ln349">    // Power determines number of heads. Minimum 4 heads, maximum 12.</a>
<a name="ln350">    // Rare to get more than 8.</a>
<a name="ln351">    const int maxheads = one_chance_in(6) ? 12 : 8;</a>
<a name="ln352">    const int heads = max(4, min(random2(pow) / 6, maxheads));</a>
<a name="ln353"> </a>
<a name="ln354">    // Duration is always very short - just 1.</a>
<a name="ln355">    mgen_data mg = _summon_data(*caster, MONS_HYDRA, 1, god,</a>
<a name="ln356">                                SPELL_SUMMON_HYDRA);</a>
<a name="ln357">    mg.props[MGEN_NUM_HEADS] = heads;</a>
<a name="ln358">    if (monster *hydra = create_monster(mg))</a>
<a name="ln359">    {</a>
<a name="ln360">        if (you.see_cell(hydra-&gt;pos()))</a>
<a name="ln361">            mprf(&quot;%s appears.&quot;, hydra-&gt;name(DESC_A).c_str());</a>
<a name="ln362">    }</a>
<a name="ln363">    else if (caster-&gt;is_player())</a>
<a name="ln364">        canned_msg(MSG_NOTHING_HAPPENS);</a>
<a name="ln365"> </a>
<a name="ln366">    return spret::success;</a>
<a name="ln367">}</a>
<a name="ln368"> </a>
<a name="ln369">static monster_type _choose_dragon_type(int pow, god_type /*god*/, bool player)</a>
<a name="ln370">{</a>
<a name="ln371">    monster_type mon = MONS_PROGRAM_BUG;</a>
<a name="ln372"> </a>
<a name="ln373">    const int chance = random2(pow);</a>
<a name="ln374"> </a>
<a name="ln375">    if (chance &gt;= 80 || one_chance_in(6))</a>
<a name="ln376">        mon = random_choose(MONS_GOLDEN_DRAGON, MONS_QUICKSILVER_DRAGON);</a>
<a name="ln377">    else if (chance &gt;= 40 || one_chance_in(6))</a>
<a name="ln378">        mon = random_choose(MONS_IRON_DRAGON, MONS_SHADOW_DRAGON, MONS_STORM_DRAGON);</a>
<a name="ln379">    else</a>
<a name="ln380">        mon = random_choose(MONS_FIRE_DRAGON, MONS_ICE_DRAGON);</a>
<a name="ln381"> </a>
<a name="ln382">    // For good gods, switch away from shadow dragons to storm/iron dragons.</a>
<a name="ln383">    if (player &amp;&amp; player_will_anger_monster(mon))</a>
<a name="ln384">        mon = random_choose(MONS_STORM_DRAGON, MONS_IRON_DRAGON);</a>
<a name="ln385"> </a>
<a name="ln386">    return mon;</a>
<a name="ln387">}</a>
<a name="ln388"> </a>
<a name="ln389">spret cast_dragon_call(int pow, bool fail)</a>
<a name="ln390">{</a>
<a name="ln391">    if (otr_stop_summoning_prompt(&quot;call dragons&quot;))</a>
<a name="ln392">        return spret::abort;</a>
<a name="ln393"> </a>
<a name="ln394">    fail_check();</a>
<a name="ln395"> </a>
<a name="ln396">    mpr(&quot;You call out to the draconic realm, and the dragon horde roars back!&quot;);</a>
<a name="ln397">    noisy(spell_effect_noise(SPELL_DRAGON_CALL), you.pos());</a>
<a name="ln398"> </a>
<a name="ln399">    you.duration[DUR_DRAGON_CALL] = (15 + pow / 5 + random2(15)) * BASELINE_DELAY;</a>
<a name="ln400"> </a>
<a name="ln401">    return spret::success;</a>
<a name="ln402">}</a>
<a name="ln403"> </a>
<a name="ln404">static void _place_dragon()</a>
<a name="ln405">{</a>
<a name="ln406">    const int pow = calc_spell_power(SPELL_DRAGON_CALL, true);</a>
<a name="ln407">    monster_type mon = _choose_dragon_type(pow, you.religion, true);</a>
<a name="ln408">    int mp_cost = random_range(2, 3);</a>
<a name="ln409"> </a>
<a name="ln410">    vector&lt;monster*&gt; targets;</a>
<a name="ln411"> </a>
<a name="ln412">    // Pick a random hostile in sight</a>
<a name="ln413">    for (monster_near_iterator mi(&amp;you, LOS_NO_TRANS); mi; ++mi)</a>
<a name="ln414">        if (!mons_aligned(&amp;you, *mi) &amp;&amp; mons_is_threatening(**mi))</a>
<a name="ln415">            targets.push_back(*mi);</a>
<a name="ln416"> </a>
<a name="ln417">    shuffle_array(targets);</a>
<a name="ln418"> </a>
<a name="ln419">    // Attempt to place adjacent to the first chosen hostile. If there is no</a>
<a name="ln420">    // valid spot, move on to the next one.</a>
<a name="ln421">    for (monster *target : targets)</a>
<a name="ln422">    {</a>
<a name="ln423">        // Chose a random viable adjacent spot to the select target</a>
<a name="ln424">        vector&lt;coord_def&gt; spots;</a>
<a name="ln425">        for (adjacent_iterator ai(target-&gt;pos()); ai; ++ai)</a>
<a name="ln426">        {</a>
<a name="ln427">            if (monster_habitable_grid(MONS_FIRE_DRAGON, grd(*ai))</a>
<a name="ln428">                &amp;&amp; !actor_at(*ai))</a>
<a name="ln429">            {</a>
<a name="ln430">                spots.push_back(*ai);</a>
<a name="ln431">            }</a>
<a name="ln432">        }</a>
<a name="ln433"> </a>
<a name="ln434">        // Now try to create the actual dragon</a>
<a name="ln435">        if (spots.size() &lt;= 0)</a>
<a name="ln436">            continue;</a>
<a name="ln437"> </a>
<a name="ln438">        // Abort if we lack sufficient MP, but the dragon call duration</a>
<a name="ln439">        // remains, as the player might soon have enough again.</a>
<a name="ln440">        if (!enough_mp(mp_cost, true))</a>
<a name="ln441">        {</a>
<a name="ln442">            mpr(&quot;A dragon tries to answer your call, but you don't have enough &quot;</a>
<a name="ln443">                &quot;magical power!&quot;);</a>
<a name="ln444">            return;</a>
<a name="ln445">        }</a>
<a name="ln446"> </a>
<a name="ln447">        const coord_def pos = spots[random2(spots.size())];</a>
<a name="ln448">        monster *dragon = create_monster(</a>
<a name="ln449">            mgen_data(mon, BEH_COPY, pos, MHITYOU, MG_FORCE_PLACE | MG_AUTOFOE)</a>
<a name="ln450">            .set_summoned(&amp;you, 2, SPELL_DRAGON_CALL));</a>
<a name="ln451">        if (!dragon)</a>
<a name="ln452">            continue;</a>
<a name="ln453"> </a>
<a name="ln454">        dec_mp(mp_cost);</a>
<a name="ln455">        if (you.see_cell(dragon-&gt;pos()))</a>
<a name="ln456">            mpr(&quot;A dragon arrives to answer your call!&quot;);</a>
<a name="ln457"> </a>
<a name="ln458">        // The dragon is allowed to act immediately here</a>
<a name="ln459">        dragon-&gt;flags &amp;= ~MF_JUST_SUMMONED;</a>
<a name="ln460">        return;</a>
<a name="ln461">    }</a>
<a name="ln462"> </a>
<a name="ln463">    return;</a>
<a name="ln464">}</a>
<a name="ln465"> </a>
<a name="ln466">void do_dragon_call(int time)</a>
<a name="ln467">{</a>
<a name="ln468">    noisy(spell_effect_noise(SPELL_DRAGON_CALL), you.pos());</a>
<a name="ln469"> </a>
<a name="ln470">    while (time &gt; you.attribute[ATTR_NEXT_DRAGON_TIME]</a>
<a name="ln471">           &amp;&amp; you.duration[DUR_DRAGON_CALL])</a>
<a name="ln472">    {</a>
<a name="ln473">        time -= you.attribute[ATTR_NEXT_DRAGON_TIME];</a>
<a name="ln474">        _place_dragon();</a>
<a name="ln475">        you.attribute[ATTR_NEXT_DRAGON_TIME] = 3 + random2(5)</a>
<a name="ln476">                                               + count_summons(&amp;you, SPELL_DRAGON_CALL) * 5;</a>
<a name="ln477">    }</a>
<a name="ln478">    you.attribute[ATTR_NEXT_DRAGON_TIME] -= time;</a>
<a name="ln479">}</a>
<a name="ln480"> </a>
<a name="ln481">/**</a>
<a name="ln482"> * Handle the Doom Howl status effect, possibly summoning hostile nasties</a>
<a name="ln483"> * around the player.</a>
<a name="ln484"> *</a>
<a name="ln485"> * @param time      The number of aut that the howling has been going on for</a>
<a name="ln486"> *                  since the last doom_howl call.</a>
<a name="ln487"> */</a>
<a name="ln488">void doom_howl(int time)</a>
<a name="ln489">{</a>
<a name="ln490">    // TODO: pull hound-count generation into a helper function</a>
<a name="ln491">    int howlcalled_count = 0;</a>
<a name="ln492">    if (!you.props.exists(NEXT_DOOM_HOUND_KEY))</a>
<a name="ln493">        you.props[NEXT_DOOM_HOUND_KEY] = random_range(20, 40);</a>
<a name="ln494">    // 1 nasty beast every 2-4 turns</a>
<a name="ln495">    while (time &gt; 0)</a>
<a name="ln496">    {</a>
<a name="ln497">        const int time_to_call = you.props[NEXT_DOOM_HOUND_KEY].get_int();</a>
<a name="ln498">        if (time_to_call &lt;= time)</a>
<a name="ln499">        {</a>
<a name="ln500">            you.props[NEXT_DOOM_HOUND_KEY] = random_range(20, 40);</a>
<a name="ln501">            ++howlcalled_count;</a>
<a name="ln502">        }</a>
<a name="ln503">        else</a>
<a name="ln504">            you.props[NEXT_DOOM_HOUND_KEY].get_int() -= time;</a>
<a name="ln505">        time -= time_to_call;</a>
<a name="ln506">    }</a>
<a name="ln507"> </a>
<a name="ln508">    if (!howlcalled_count)</a>
<a name="ln509">        return;</a>
<a name="ln510"> </a>
<a name="ln511">    const actor *target = &amp;you;</a>
<a name="ln512"> </a>
<a name="ln513">    for (int i = 0; i &lt; howlcalled_count; ++i)</a>
<a name="ln514">    {</a>
<a name="ln515">        const monster_type howlcalled = random_choose(</a>
<a name="ln516">                MONS_BONE_DRAGON, MONS_SHADOW_DRAGON, MONS_SHADOW_DEMON,</a>
<a name="ln517">                MONS_REAPER, MONS_TORMENTOR, MONS_TZITZIMITL</a>
<a name="ln518">        );</a>
<a name="ln519">        vector&lt;coord_def&gt; spots;</a>
<a name="ln520">        for (adjacent_iterator ai(target-&gt;pos()); ai; ++ai)</a>
<a name="ln521">        {</a>
<a name="ln522">            if (monster_habitable_grid(howlcalled, grd(*ai))</a>
<a name="ln523">                &amp;&amp; !actor_at(*ai))</a>
<a name="ln524">            {</a>
<a name="ln525">                spots.push_back(*ai);</a>
<a name="ln526">            }</a>
<a name="ln527">        }</a>
<a name="ln528">        if (spots.size() &lt;= 0)</a>
<a name="ln529">            continue;</a>
<a name="ln530"> </a>
<a name="ln531">        const coord_def pos = spots[random2(spots.size())];</a>
<a name="ln532"> </a>
<a name="ln533">        monster *mons = create_monster(mgen_data(howlcalled, BEH_HOSTILE,</a>
<a name="ln534">                                                 pos, target-&gt;mindex(),</a>
<a name="ln535">                                                 MG_FORCE_BEH));</a>
<a name="ln536">        if (mons)</a>
<a name="ln537">        {</a>
<a name="ln538">            mons-&gt;add_ench(mon_enchant(ENCH_HAUNTING, 1, target,</a>
<a name="ln539">                                       INFINITE_DURATION));</a>
<a name="ln540">            mons-&gt;behaviour = BEH_SEEK;</a>
<a name="ln541">            mons_add_blame(mons, &quot;called by a doom hound&quot;); // assumption!</a>
<a name="ln542">            check_place_cloud(CLOUD_BLACK_SMOKE, mons-&gt;pos(),</a>
<a name="ln543">                              random_range(1,2), mons);</a>
<a name="ln544">        }</a>
<a name="ln545">    }</a>
<a name="ln546">}</a>
<a name="ln547"> </a>
<a name="ln548">spret cast_summon_dragon(actor *caster, int pow, god_type god, bool fail)</a>
<a name="ln549">{</a>
<a name="ln550">    // Dragons are always friendly. Dragon type depends on power and</a>
<a name="ln551">    // random chance, with two low-tier dragons possible at high power.</a>
<a name="ln552">    // Duration fixed at 6.</a>
<a name="ln553"> </a>
<a name="ln554">    fail_check();</a>
<a name="ln555">    bool success = false;</a>
<a name="ln556"> </a>
<a name="ln557">    if (god == GOD_NO_GOD)</a>
<a name="ln558">        god = caster-&gt;deity();</a>
<a name="ln559"> </a>
<a name="ln560">    int how_many = 1;</a>
<a name="ln561">    monster_type mon = _choose_dragon_type(pow, god, caster-&gt;is_player());</a>
<a name="ln562"> </a>
<a name="ln563">    if (pow &gt;= 100 &amp;&amp; (mon == MONS_FIRE_DRAGON || mon == MONS_ICE_DRAGON))</a>
<a name="ln564">        how_many = 2;</a>
<a name="ln565"> </a>
<a name="ln566">    for (int i = 0; i &lt; how_many; ++i)</a>
<a name="ln567">    {</a>
<a name="ln568">        if (monster *dragon = create_monster(</a>
<a name="ln569">                _summon_data(*caster, mon, 6, god, SPELL_SUMMON_DRAGON)))</a>
<a name="ln570">        {</a>
<a name="ln571">            if (you.see_cell(dragon-&gt;pos()))</a>
<a name="ln572">                mpr(&quot;A dragon appears.&quot;);</a>
<a name="ln573">            success = true;</a>
<a name="ln574">        }</a>
<a name="ln575">    }</a>
<a name="ln576"> </a>
<a name="ln577">    if (!success &amp;&amp; caster-&gt;is_player())</a>
<a name="ln578">        canned_msg(MSG_NOTHING_HAPPENS);</a>
<a name="ln579"> </a>
<a name="ln580">    return spret::success;</a>
<a name="ln581">}</a>
<a name="ln582"> </a>
<a name="ln583">spret cast_summon_mana_viper(int pow, god_type god, bool fail)</a>
<a name="ln584">{</a>
<a name="ln585">    fail_check();</a>
<a name="ln586"> </a>
<a name="ln587">    mgen_data viper = _pal_data(MONS_MANA_VIPER, 2, god,</a>
<a name="ln588">                                SPELL_SUMMON_MANA_VIPER);</a>
<a name="ln589">    viper.hd = (5 + div_rand_round(pow, 12));</a>
<a name="ln590"> </a>
<a name="ln591">    // Don't scale hp at the same time as their antimagic power</a>
<a name="ln592">    viper.hp = hit_points(495); // avg 50</a>
<a name="ln593"> </a>
<a name="ln594">    if (create_monster(viper))</a>
<a name="ln595">        mpr(&quot;A mana viper appears with a sibilant hiss.&quot;);</a>
<a name="ln596">    else</a>
<a name="ln597">        canned_msg(MSG_NOTHING_HAPPENS);</a>
<a name="ln598"> </a>
<a name="ln599">    return spret::success;</a>
<a name="ln600">}</a>
<a name="ln601"> </a>
<a name="ln602">// This assumes that the specified monster can go berserk.</a>
<a name="ln603">static void _make_mons_berserk_summon(monster* mon)</a>
<a name="ln604">{</a>
<a name="ln605">    mon-&gt;go_berserk(false);</a>
<a name="ln606">    mon_enchant berserk = mon-&gt;get_ench(ENCH_BERSERK);</a>
<a name="ln607">    mon_enchant abj = mon-&gt;get_ench(ENCH_ABJ);</a>
<a name="ln608"> </a>
<a name="ln609">    // Let Trog's gifts berserk longer, and set the abjuration timeout</a>
<a name="ln610">    // to the berserk timeout.</a>
<a name="ln611">    berserk.duration = berserk.duration * 3 / 2;</a>
<a name="ln612">    berserk.maxduration = berserk.duration;</a>
<a name="ln613">    abj.duration = abj.maxduration = berserk.duration;</a>
<a name="ln614">    mon-&gt;update_ench(berserk);</a>
<a name="ln615">    mon-&gt;update_ench(abj);</a>
<a name="ln616">}</a>
<a name="ln617"> </a>
<a name="ln618">// This is actually one of Trog's wrath effects.</a>
<a name="ln619">bool summon_berserker(int pow, actor *caster, monster_type override_mons)</a>
<a name="ln620">{</a>
<a name="ln621">    monster_type mon = MONS_PROGRAM_BUG;</a>
<a name="ln622"> </a>
<a name="ln623">    const int dur = min(2 + (random2(pow) / 4), 6);</a>
<a name="ln624"> </a>
<a name="ln625">    if (override_mons != MONS_PROGRAM_BUG)</a>
<a name="ln626">        mon = override_mons;</a>
<a name="ln627">    else</a>
<a name="ln628">    {</a>
<a name="ln629">        if (pow &lt;= 100)</a>
<a name="ln630">        {</a>
<a name="ln631">            // bears</a>
<a name="ln632">            mon = random_choose(MONS_BLACK_BEAR, MONS_POLAR_BEAR);</a>
<a name="ln633">        }</a>
<a name="ln634">        else if (pow &lt;= 140)</a>
<a name="ln635">        {</a>
<a name="ln636">            // ogres</a>
<a name="ln637">            mon = random_choose_weighted(1, MONS_TWO_HEADED_OGRE, 2, MONS_OGRE);</a>
<a name="ln638">        }</a>
<a name="ln639">        else if (pow &lt;= 180)</a>
<a name="ln640">        {</a>
<a name="ln641">            // trolls</a>
<a name="ln642">            mon = random_choose_weighted(3, MONS_TROLL,</a>
<a name="ln643">                                         3, MONS_DEEP_TROLL,</a>
<a name="ln644">                                         2, MONS_IRON_TROLL);</a>
<a name="ln645">        }</a>
<a name="ln646">        else</a>
<a name="ln647">        {</a>
<a name="ln648">            // giants</a>
<a name="ln649">            mon = random_choose(MONS_CYCLOPS, MONS_STONE_GIANT);</a>
<a name="ln650">        }</a>
<a name="ln651">    }</a>
<a name="ln652"> </a>
<a name="ln653">    mgen_data mg(mon, caster ? BEH_COPY : BEH_HOSTILE,</a>
<a name="ln654">                 caster ? caster-&gt;pos() : you.pos(),</a>
<a name="ln655">                 (caster &amp;&amp; caster-&gt;is_monster()) ? ((monster*)caster)-&gt;foe</a>
<a name="ln656">                                                  : int{MHITYOU},</a>
<a name="ln657">                 MG_AUTOFOE);</a>
<a name="ln658">    mg.set_summoned(caster, caster ? dur : 0, SPELL_NO_SPELL, GOD_TROG);</a>
<a name="ln659"> </a>
<a name="ln660">    if (!caster)</a>
<a name="ln661">    {</a>
<a name="ln662">        mg.non_actor_summoner = &quot;the rage of &quot; + god_name(GOD_TROG, false);</a>
<a name="ln663">        mg.extra_flags |= (MF_NO_REWARD | MF_HARD_RESET);</a>
<a name="ln664">    }</a>
<a name="ln665"> </a>
<a name="ln666">    monster *mons = create_monster(mg);</a>
<a name="ln667"> </a>
<a name="ln668">    if (!mons)</a>
<a name="ln669">        return false;</a>
<a name="ln670"> </a>
<a name="ln671">    _make_mons_berserk_summon(mons);</a>
<a name="ln672">    return true;</a>
<a name="ln673">}</a>
<a name="ln674"> </a>
<a name="ln675">// Not a spell. Rather, this is TSO's doing.</a>
<a name="ln676">bool summon_holy_warrior(int pow, bool punish)</a>
<a name="ln677">{</a>
<a name="ln678">    mgen_data mg(random_choose(MONS_ANGEL, MONS_DAEVA),</a>
<a name="ln679">                 punish ? BEH_HOSTILE : BEH_FRIENDLY,</a>
<a name="ln680">                 you.pos(), MHITYOU, MG_FORCE_BEH | MG_AUTOFOE);</a>
<a name="ln681">    mg.set_summoned(punish ? 0 : &amp;you,</a>
<a name="ln682">                    punish ? 0 : min(2 + (random2(pow) / 4), 6),</a>
<a name="ln683">                    SPELL_NO_SPELL, GOD_SHINING_ONE);</a>
<a name="ln684"> </a>
<a name="ln685">    if (punish)</a>
<a name="ln686">    {</a>
<a name="ln687">        mg.extra_flags |= (MF_NO_REWARD | MF_HARD_RESET);</a>
<a name="ln688">        mg.non_actor_summoner = god_name(GOD_SHINING_ONE, false);</a>
<a name="ln689">    }</a>
<a name="ln690"> </a>
<a name="ln691">    monster *summon = create_monster(mg);</a>
<a name="ln692"> </a>
<a name="ln693">    if (!summon)</a>
<a name="ln694">        return false;</a>
<a name="ln695"> </a>
<a name="ln696">    summon-&gt;flags |= MF_ATT_CHANGE_ATTEMPT;</a>
<a name="ln697"> </a>
<a name="ln698">    if (!punish)</a>
<a name="ln699">        mpr(&quot;You are momentarily dazzled by a brilliant light.&quot;);</a>
<a name="ln700"> </a>
<a name="ln701">    player_angers_monster(summon);</a>
<a name="ln702">    return true;</a>
<a name="ln703">}</a>
<a name="ln704"> </a>
<a name="ln705">/**</a>
<a name="ln706"> * Essentially a macro to allow for a generic fail pattern to avoid leaking</a>
<a name="ln707"> * information about invisible enemies. (Not implemented as a macro because I</a>
<a name="ln708"> * find they create unreadable code.)</a>
<a name="ln709"> *</a>
<a name="ln710"> * @return spret::success</a>
<a name="ln711"> **/</a>
<a name="ln712">static bool _fail_tukimas()</a>
<a name="ln713">{</a>
<a name="ln714">    mprf(&quot;You can't see a target there!&quot;);</a>
<a name="ln715">    return false; // Waste the turn - no anti-invis tech</a>
<a name="ln716">}</a>
<a name="ln717"> </a>
<a name="ln718">/**</a>
<a name="ln719"> * Gets an item description for use in Tukima's Dance messages.</a>
<a name="ln720"> **/</a>
<a name="ln721">static string _get_item_desc(const item_def* wpn, bool target_is_player)</a>
<a name="ln722">{</a>
<a name="ln723">    return wpn-&gt;name(target_is_player ? DESC_YOUR : DESC_THE);</a>
<a name="ln724">}</a>
<a name="ln725"> </a>
<a name="ln726">/**</a>
<a name="ln727"> * Checks if Tukima's Dance can actually affect the target (and anger them)</a>
<a name="ln728"> *</a>
<a name="ln729"> * @param target  The targeted monster (or player).</a>
<a name="ln730"> * @return        Whether the target can be affected by Tukima's Dance.</a>
<a name="ln731"> **/</a>
<a name="ln732">bool tukima_affects(const actor &amp;target)</a>
<a name="ln733">{</a>
<a name="ln734">    const item_def* wpn = target.weapon();</a>
<a name="ln735">    return wpn</a>
<a name="ln736">           &amp;&amp; is_weapon(*wpn)</a>
<a name="ln737">           &amp;&amp; !is_range_weapon(*wpn)</a>
<a name="ln738">           &amp;&amp; !is_special_unrandom_artefact(*wpn)</a>
<a name="ln739">           &amp;&amp; !mons_class_is_animated_weapon(target.type)</a>
<a name="ln740">           &amp;&amp; !mons_is_hepliaklqana_ancestor(target.type);</a>
<a name="ln741">}</a>
<a name="ln742"> </a>
<a name="ln743">/**</a>
<a name="ln744"> * Checks if Tukima's Dance is being cast on a valid target.</a>
<a name="ln745"> *</a>
<a name="ln746"> * @param target     The spell's target.</a>
<a name="ln747"> * @return           Whether the target is valid.</a>
<a name="ln748"> **/</a>
<a name="ln749">static bool _check_tukima_validity(const actor *target)</a>
<a name="ln750">{</a>
<a name="ln751">    bool target_is_player = target == &amp;you;</a>
<a name="ln752">    const item_def* wpn = target-&gt;weapon();</a>
<a name="ln753">    bool can_see_target = target_is_player || target-&gt;visible_to(&amp;you);</a>
<a name="ln754"> </a>
<a name="ln755">    // See if the wielded item is appropriate.</a>
<a name="ln756">    if (!wpn)</a>
<a name="ln757">    {</a>
<a name="ln758">        if (!can_see_target)</a>
<a name="ln759">            return _fail_tukimas();</a>
<a name="ln760"> </a>
<a name="ln761">        if (target_is_player)</a>
<a name="ln762">            mpr(you.hands_act(&quot;twitch&quot;, &quot;.&quot;));</a>
<a name="ln763">        else</a>
<a name="ln764">        {</a>
<a name="ln765">            // FIXME: maybe move hands_act to class actor?</a>
<a name="ln766">            bool plural = true;</a>
<a name="ln767">            const string hand = target-&gt;hand_name(true, &amp;plural);</a>
<a name="ln768"> </a>
<a name="ln769">            mprf(&quot;%s %s %s.&quot;,</a>
<a name="ln770">                 apostrophise(target-&gt;name(DESC_THE)).c_str(),</a>
<a name="ln771">                 hand.c_str(), conjugate_verb(&quot;twitch&quot;, plural).c_str());</a>
<a name="ln772">        }</a>
<a name="ln773">        return false;</a>
<a name="ln774">    }</a>
<a name="ln775"> </a>
<a name="ln776">    if (!tukima_affects(*target))</a>
<a name="ln777">    {</a>
<a name="ln778">        if (!can_see_target)</a>
<a name="ln779">            return _fail_tukimas();</a>
<a name="ln780"> </a>
<a name="ln781">        if (mons_class_is_animated_weapon(target-&gt;type))</a>
<a name="ln782">        {</a>
<a name="ln783">            simple_monster_message(*(monster*)target,</a>
<a name="ln784">                                   &quot; is already dancing.&quot;);</a>
<a name="ln785">        }</a>
<a name="ln786">        else</a>
<a name="ln787">        {</a>
<a name="ln788">            mprf(&quot;%s vibrate%s crazily for a second.&quot;,</a>
<a name="ln789">                 _get_item_desc(wpn, target_is_player).c_str(),</a>
<a name="ln790">                 wpn-&gt;quantity &gt; 1 ? &quot;&quot; : &quot;s&quot;);</a>
<a name="ln791">        }</a>
<a name="ln792">        return false;</a>
<a name="ln793">    }</a>
<a name="ln794"> </a>
<a name="ln795">    return true;</a>
<a name="ln796">}</a>
<a name="ln797"> </a>
<a name="ln798"> </a>
<a name="ln799">/**</a>
<a name="ln800"> * Actually animates the weapon of the target creature (no checks).</a>
<a name="ln801"> *</a>
<a name="ln802"> * @param pow               Spellpower.</a>
<a name="ln803"> * @param target            The spell's target (monster or player)</a>
<a name="ln804"> **/</a>
<a name="ln805">static void _animate_weapon(int pow, actor* target)</a>
<a name="ln806">{</a>
<a name="ln807">    bool target_is_player = target == &amp;you;</a>
<a name="ln808">    item_def * const wpn = target-&gt;weapon();</a>
<a name="ln809">    ASSERT(wpn);</a>
<a name="ln810">    if (target_is_player)</a>
<a name="ln811">    {</a>
<a name="ln812">        // Clear temp branding so we don't change the brand permanently.</a>
<a name="ln813">        if (you.duration[DUR_EXCRUCIATING_WOUNDS])</a>
<a name="ln814">            end_weapon_brand(*wpn);</a>
<a name="ln815"> </a>
<a name="ln816">        // Mark weapon as &quot;thrown&quot;, so we'll autopickup it later.</a>
<a name="ln817">        wpn-&gt;flags |= ISFLAG_THROWN;</a>
<a name="ln818">    }</a>
<a name="ln819">    // If sac love, the weapon will go after you, not the target.</a>
<a name="ln820">    const bool sac_love = you.get_mutation_level(MUT_NO_LOVE);</a>
<a name="ln821">    // Self-casting haunts yourself! MUT_NO_LOVE overrides force friendly.</a>
<a name="ln822">    const bool friendly = !target_is_player &amp;&amp; !sac_love;</a>
<a name="ln823">    const int dur = min(2 + (random2(pow) / 5), 6);</a>
<a name="ln824"> </a>
<a name="ln825">    mgen_data mg(MONS_DANCING_WEAPON,</a>
<a name="ln826">                 friendly ? BEH_FRIENDLY : BEH_HOSTILE,</a>
<a name="ln827">                 target-&gt;pos(),</a>
<a name="ln828">                 (target_is_player || sac_love) ? MHITYOU : target-&gt;mindex(),</a>
<a name="ln829">                 sac_love ? MG_NONE : MG_FORCE_BEH);</a>
<a name="ln830">    mg.set_summoned(&amp;you, dur, SPELL_TUKIMAS_DANCE);</a>
<a name="ln831">    mg.props[TUKIMA_WEAPON] = *wpn;</a>
<a name="ln832">    mg.props[TUKIMA_POWER] = pow;</a>
<a name="ln833"> </a>
<a name="ln834">    monster * const mons = create_monster(mg);</a>
<a name="ln835"> </a>
<a name="ln836">    if (!mons)</a>
<a name="ln837">    {</a>
<a name="ln838">        mprf(&quot;%s twitches for a moment.&quot;,</a>
<a name="ln839">             _get_item_desc(wpn, target_is_player).c_str());</a>
<a name="ln840">        return;</a>
<a name="ln841">    }</a>
<a name="ln842"> </a>
<a name="ln843">    // Don't haunt yourself under sac love.</a>
<a name="ln844">    if (!sac_love)</a>
<a name="ln845">    {</a>
<a name="ln846">        mons-&gt;add_ench(mon_enchant(ENCH_HAUNTING, 1, target,</a>
<a name="ln847">                                   INFINITE_DURATION));</a>
<a name="ln848">        mons-&gt;foe = target-&gt;mindex();</a>
<a name="ln849">    }</a>
<a name="ln850"> </a>
<a name="ln851">    // We are successful. Unwield the weapon, removing any wield effects.</a>
<a name="ln852">    mprf(&quot;%s dances into the air!&quot;,</a>
<a name="ln853">         _get_item_desc(wpn, target_is_player).c_str());</a>
<a name="ln854">    if (target_is_player)</a>
<a name="ln855">        unwield_item();</a>
<a name="ln856">    else</a>
<a name="ln857">    {</a>
<a name="ln858">        monster * const montarget = target-&gt;as_monster();</a>
<a name="ln859">        const int primary_weap = montarget-&gt;inv[MSLOT_WEAPON];</a>
<a name="ln860">        const mon_inv_type wp_slot = (primary_weap != NON_ITEM</a>
<a name="ln861">                                      &amp;&amp; &amp;mitm[primary_weap] == wpn) ?</a>
<a name="ln862">                                         MSLOT_WEAPON : MSLOT_ALT_WEAPON;</a>
<a name="ln863">        ASSERT(montarget-&gt;inv[wp_slot] != NON_ITEM);</a>
<a name="ln864">        ASSERT(&amp;mitm[montarget-&gt;inv[wp_slot]] == wpn);</a>
<a name="ln865"> </a>
<a name="ln866">        montarget-&gt;unequip(*(montarget-&gt;mslot_item(wp_slot)), false, true);</a>
<a name="ln867">        montarget-&gt;inv[wp_slot] = NON_ITEM;</a>
<a name="ln868">    }</a>
<a name="ln869"> </a>
<a name="ln870">    // Find out what our god thinks before killing the item.</a>
<a name="ln871">    conduct_type why = god_hates_item_handling(*wpn);</a>
<a name="ln872"> </a>
<a name="ln873">    wpn-&gt;clear();</a>
<a name="ln874"> </a>
<a name="ln875">    if (why)</a>
<a name="ln876">    {</a>
<a name="ln877">        simple_god_message(&quot; booms: How dare you animate that foul thing!&quot;);</a>
<a name="ln878">        did_god_conduct(why, 10, true, mons);</a>
<a name="ln879">    }</a>
<a name="ln880">}</a>
<a name="ln881"> </a>
<a name="ln882">/**</a>
<a name="ln883"> * Casts Tukima's Dance, animating the weapon of the target creature (if valid)</a>
<a name="ln884"> *</a>
<a name="ln885"> * @param pow               Spellpower.</a>
<a name="ln886"> * @param where             The target grid.</a>
<a name="ln887"> **/</a>
<a name="ln888">void cast_tukimas_dance(int pow, actor* target)</a>
<a name="ln889">{</a>
<a name="ln890">    ASSERT(target);</a>
<a name="ln891"> </a>
<a name="ln892">    if (!_check_tukima_validity(target))</a>
<a name="ln893">        return;</a>
<a name="ln894"> </a>
<a name="ln895">    _animate_weapon(pow, target);</a>
<a name="ln896">}</a>
<a name="ln897"> </a>
<a name="ln898">spret cast_conjure_ball_lightning(int pow, god_type god, bool fail)</a>
<a name="ln899">{</a>
<a name="ln900">    fail_check();</a>
<a name="ln901">    bool success = false;</a>
<a name="ln902"> </a>
<a name="ln903">    const int how_many = min(5, 2 + pow / 100 + random2(pow / 50 + 1));</a>
<a name="ln904"> </a>
<a name="ln905">    mgen_data cbl =_pal_data(MONS_BALL_LIGHTNING, 0, god,</a>
<a name="ln906">                             SPELL_CONJURE_BALL_LIGHTNING);</a>
<a name="ln907">    cbl.hd = 5 + div_rand_round(pow, 20);</a>
<a name="ln908"> </a>
<a name="ln909">    for (int i = 0; i &lt; how_many; ++i)</a>
<a name="ln910">    {</a>
<a name="ln911">        if (monster *ball = create_monster(cbl))</a>
<a name="ln912">        {</a>
<a name="ln913">            success = true;</a>
<a name="ln914">            ball-&gt;add_ench(ENCH_SHORT_LIVED);</a>
<a name="ln915"> </a>
<a name="ln916">            // Avoid ball lightnings without targets always moving towards (0,0)</a>
<a name="ln917">            if (!(ball-&gt;get_foe() &amp;&amp; ball-&gt;get_foe()-&gt;is_monster()))</a>
<a name="ln918">                set_random_target(ball);</a>
<a name="ln919">        }</a>
<a name="ln920">    }</a>
<a name="ln921"> </a>
<a name="ln922">    if (success)</a>
<a name="ln923">        mpr(&quot;You create some ball lightning!&quot;);</a>
<a name="ln924">    else</a>
<a name="ln925">        canned_msg(MSG_NOTHING_HAPPENS);</a>
<a name="ln926"> </a>
<a name="ln927">    return spret::success;</a>
<a name="ln928">}</a>
<a name="ln929"> </a>
<a name="ln930">spret cast_summon_lightning_spire(int pow, god_type god, bool fail)</a>
<a name="ln931">{</a>
<a name="ln932">    fail_check();</a>
<a name="ln933"> </a>
<a name="ln934">    mgen_data spire = _pal_data(MONS_LIGHTNING_SPIRE, 2, god,</a>
<a name="ln935">                                SPELL_SUMMON_LIGHTNING_SPIRE);</a>
<a name="ln936">    spire.hd = max(1, div_rand_round(pow, 10));</a>
<a name="ln937"> </a>
<a name="ln938">    monster* mons = create_monster(spire);</a>
<a name="ln939"> </a>
<a name="ln940">    if (mons &amp;&amp; !silenced(mons-&gt;pos()))</a>
<a name="ln941">        mpr(&quot;An electric hum fills the air.&quot;);</a>
<a name="ln942">    else</a>
<a name="ln943">        canned_msg(MSG_NOTHING_HAPPENS);</a>
<a name="ln944"> </a>
<a name="ln945">    return spret::success;</a>
<a name="ln946">}</a>
<a name="ln947"> </a>
<a name="ln948">spret cast_summon_guardian_golem(int pow, god_type god, bool fail)</a>
<a name="ln949">{</a>
<a name="ln950">    fail_check();</a>
<a name="ln951"> </a>
<a name="ln952">    mgen_data golem = _pal_data(MONS_GUARDIAN_GOLEM, 3, god,</a>
<a name="ln953">                                SPELL_SUMMON_GUARDIAN_GOLEM);</a>
<a name="ln954">    golem.flags &amp;= ~MG_AUTOFOE; // !!!</a>
<a name="ln955">    golem.hd = 4 + div_rand_round(pow, 16);</a>
<a name="ln956"> </a>
<a name="ln957">    monster* mons = (create_monster(golem));</a>
<a name="ln958"> </a>
<a name="ln959">    if (mons)</a>
<a name="ln960">    {</a>
<a name="ln961">        // Immediately apply injury bond</a>
<a name="ln962">        guardian_golem_bond(*mons);</a>
<a name="ln963"> </a>
<a name="ln964">        mpr(&quot;A guardian golem appears, shielding your allies.&quot;);</a>
<a name="ln965">    }</a>
<a name="ln966">    else</a>
<a name="ln967">        canned_msg(MSG_NOTHING_HAPPENS);</a>
<a name="ln968"> </a>
<a name="ln969">    return spret::success;</a>
<a name="ln970">}</a>
<a name="ln971"> </a>
<a name="ln972">/**</a>
<a name="ln973"> * Choose a type of imp to summon with Call Imp.</a>
<a name="ln974"> *</a>
<a name="ln975"> * @return      An appropriate imp type.</a>
<a name="ln976"> */</a>
<a name="ln977">static monster_type _get_imp_type()</a>
<a name="ln978">{</a>
<a name="ln979">    if (x_chance_in_y(5, 18))</a>
<a name="ln980">        return MONS_WHITE_IMP;</a>
<a name="ln981"> </a>
<a name="ln982">    // 3/13 * 13/18 = 1/6 chance of one of these two.</a>
<a name="ln983">    if (x_chance_in_y(3, 13))</a>
<a name="ln984">        return one_chance_in(3) ? MONS_IRON_IMP : MONS_SHADOW_IMP;</a>
<a name="ln985"> </a>
<a name="ln986">    // 5/9 chance of getting, regrettably, a crimson imp.</a>
<a name="ln987">    return MONS_CRIMSON_IMP;</a>
<a name="ln988">}</a>
<a name="ln989"> </a>
<a name="ln990">static map&lt;monster_type, const char*&gt; _imp_summon_messages = {</a>
<a name="ln991">    { MONS_WHITE_IMP,</a>
<a name="ln992">        &quot;A beastly little devil appears in a puff of frigid air.&quot; },</a>
<a name="ln993">    { MONS_IRON_IMP, &quot;A metallic apparition takes form in the air.&quot; },</a>
<a name="ln994">    { MONS_SHADOW_IMP, &quot;A shadowy apparition takes form in the air.&quot; },</a>
<a name="ln995">    { MONS_CRIMSON_IMP, &quot;A beastly little devil appears in a puff of flame.&quot; },</a>
<a name="ln996">};</a>
<a name="ln997"> </a>
<a name="ln998">/**</a>
<a name="ln999"> * Cast the spell Call Imp, summoning a friendly imp nearby.</a>
<a name="ln1000"> *</a>
<a name="ln1001"> * @param pow   The spellpower at which the spell is being cast.</a>
<a name="ln1002"> * @param god   The god of the caster.</a>
<a name="ln1003"> * @param fail  Whether the caster (you) failed to cast the spell.</a>
<a name="ln1004"> * @return      spret::fail if fail is true; spret::success otherwise.</a>
<a name="ln1005"> */</a>
<a name="ln1006">spret cast_call_imp(int pow, god_type god, bool fail)</a>
<a name="ln1007">{</a>
<a name="ln1008">    fail_check();</a>
<a name="ln1009"> </a>
<a name="ln1010">    const monster_type imp_type = _get_imp_type();</a>
<a name="ln1011"> </a>
<a name="ln1012">    const int dur = min(2 + (random2(pow) / 4), 6);</a>
<a name="ln1013"> </a>
<a name="ln1014">    mgen_data imp_data = _pal_data(imp_type, dur, god, SPELL_CALL_IMP);</a>
<a name="ln1015">    imp_data.flags |= MG_FORCE_BEH; // disable player_angers_monster()</a>
<a name="ln1016">    if (monster *imp = create_monster(imp_data))</a>
<a name="ln1017">    {</a>
<a name="ln1018">        mpr(_imp_summon_messages[imp_type]);</a>
<a name="ln1019"> </a>
<a name="ln1020">        if (!player_angers_monster(imp))</a>
<a name="ln1021">            _monster_greeting(imp, &quot;_friendly_imp_greeting&quot;);</a>
<a name="ln1022">    }</a>
<a name="ln1023">    else</a>
<a name="ln1024">        canned_msg(MSG_NOTHING_HAPPENS);</a>
<a name="ln1025"> </a>
<a name="ln1026">    return spret::success;</a>
<a name="ln1027">}</a>
<a name="ln1028"> </a>
<a name="ln1029">static bool _summon_demon_wrapper(int pow, god_type god, int spell,</a>
<a name="ln1030">                                  monster_type mon, int dur, bool friendly,</a>
<a name="ln1031">                                  bool charmed)</a>
<a name="ln1032">{</a>
<a name="ln1033">    bool success = false;</a>
<a name="ln1034"> </a>
<a name="ln1035">    if (monster *demon = create_monster(</a>
<a name="ln1036">            mgen_data(mon,</a>
<a name="ln1037">                      friendly ? BEH_FRIENDLY :</a>
<a name="ln1038">                       charmed ? BEH_CHARMED</a>
<a name="ln1039">                               : BEH_HOSTILE,</a>
<a name="ln1040">                      you.pos(), MHITYOU, MG_FORCE_BEH | MG_AUTOFOE)</a>
<a name="ln1041">            .set_summoned(&amp;you, dur, spell, god)))</a>
<a name="ln1042">    {</a>
<a name="ln1043">        success = true;</a>
<a name="ln1044"> </a>
<a name="ln1045">        mpr(&quot;A demon appears!&quot;);</a>
<a name="ln1046"> </a>
<a name="ln1047">        if (!player_angers_monster(demon) &amp;&amp; !friendly)</a>
<a name="ln1048">        {</a>
<a name="ln1049">            mpr(charmed ? &quot;You don't feel so good about this...&quot;</a>
<a name="ln1050">                        : &quot;It doesn't seem very happy.&quot;);</a>
<a name="ln1051">        }</a>
<a name="ln1052">        else if (friendly)</a>
<a name="ln1053">        {</a>
<a name="ln1054">            if (mon == MONS_CRIMSON_IMP || mon == MONS_WHITE_IMP</a>
<a name="ln1055">                || mon == MONS_IRON_IMP || mon == MONS_SHADOW_IMP)</a>
<a name="ln1056">            {</a>
<a name="ln1057">                _monster_greeting(demon, &quot;_friendly_imp_greeting&quot;);</a>
<a name="ln1058">            }</a>
<a name="ln1059">        }</a>
<a name="ln1060"> </a>
<a name="ln1061">        if (charmed &amp;&amp; !friendly)</a>
<a name="ln1062">        {</a>
<a name="ln1063">            int charm_dur = random_range(15 + pow / 14, 27 + pow / 11)</a>
<a name="ln1064">                            * BASELINE_DELAY;</a>
<a name="ln1065"> </a>
<a name="ln1066">            mon_enchant charm = demon-&gt;get_ench(ENCH_CHARM);</a>
<a name="ln1067">            charm.duration = charm_dur;</a>
<a name="ln1068">            demon-&gt;update_ench(charm);</a>
<a name="ln1069"> </a>
<a name="ln1070">            // Ensure that temporarily-charmed demons will outlast their charm</a>
<a name="ln1071">            mon_enchant abj = demon-&gt;get_ench(ENCH_ABJ);</a>
<a name="ln1072">            if (charm.duration + 100 &gt; abj.duration)</a>
<a name="ln1073">            {</a>
<a name="ln1074">                abj.duration = charm.duration + 100;</a>
<a name="ln1075">                demon-&gt;update_ench(abj);</a>
<a name="ln1076">            }</a>
<a name="ln1077"> </a>
<a name="ln1078">            // Affects messaging, and stuns demon a turn upon charm wearing off</a>
<a name="ln1079">            demon-&gt;props[&quot;charmed_demon&quot;].get_bool() = true;</a>
<a name="ln1080">        }</a>
<a name="ln1081">    }</a>
<a name="ln1082"> </a>
<a name="ln1083">    return success;</a>
<a name="ln1084">}</a>
<a name="ln1085"> </a>
<a name="ln1086">static bool _summon_common_demon(int pow, god_type god, int spell)</a>
<a name="ln1087">{</a>
<a name="ln1088">    const int chance = 70 - (pow / 3);</a>
<a name="ln1089">    monster_type type = MONS_PROGRAM_BUG;</a>
<a name="ln1090"> </a>
<a name="ln1091">    if (x_chance_in_y(chance, 100))</a>
<a name="ln1092">        type = random_demon_by_tier(4);</a>
<a name="ln1093">    else</a>
<a name="ln1094">        type = random_demon_by_tier(3);</a>
<a name="ln1095"> </a>
<a name="ln1096">    return _summon_demon_wrapper(pow, god, spell, type,</a>
<a name="ln1097">                                 min(2 + (random2(pow) / 4), 6),</a>
<a name="ln1098">                                 random2(pow) &gt; 3, false);</a>
<a name="ln1099">}</a>
<a name="ln1100"> </a>
<a name="ln1101">static bool _summon_greater_demon(int pow, god_type god, int spell)</a>
<a name="ln1102">{</a>
<a name="ln1103">    monster_type mon = summon_any_demon(RANDOM_DEMON_GREATER);</a>
<a name="ln1104"> </a>
<a name="ln1105">    const bool charmed = (random2(pow) &gt; 5);</a>
<a name="ln1106">    const bool friendly = (charmed &amp;&amp; mons_demon_tier(mon) == 2);</a>
<a name="ln1107"> </a>
<a name="ln1108">    return _summon_demon_wrapper(pow, god, spell, mon,</a>
<a name="ln1109">                                 4, friendly, charmed);</a>
<a name="ln1110">}</a>
<a name="ln1111"> </a>
<a name="ln1112">bool summon_demon_type(monster_type mon, int pow, god_type god,</a>
<a name="ln1113">                       int spell, bool friendly)</a>
<a name="ln1114">{</a>
<a name="ln1115">    return _summon_demon_wrapper(pow, god, spell, mon,</a>
<a name="ln1116">                                 min(2 + (random2(pow) / 4), 6),</a>
<a name="ln1117">                                 friendly, false);</a>
<a name="ln1118">}</a>
<a name="ln1119"> </a>
<a name="ln1120">spret cast_summon_demon(int pow, god_type god, bool fail)</a>
<a name="ln1121">{</a>
<a name="ln1122">    // Chaos spawn, orange demons and sixfirhies are not rPois</a>
<a name="ln1123">    if (otr_stop_summoning_prompt())</a>
<a name="ln1124">        return spret::abort;</a>
<a name="ln1125"> </a>
<a name="ln1126">    fail_check();</a>
<a name="ln1127">    mpr(&quot;You open a gate to Pandemonium!&quot;);</a>
<a name="ln1128"> </a>
<a name="ln1129">    if (!_summon_common_demon(pow, god, SPELL_SUMMON_DEMON))</a>
<a name="ln1130">        canned_msg(MSG_NOTHING_HAPPENS);</a>
<a name="ln1131"> </a>
<a name="ln1132">    return spret::success;</a>
<a name="ln1133">}</a>
<a name="ln1134"> </a>
<a name="ln1135">spret cast_summon_greater_demon(int pow, god_type god, bool fail)</a>
<a name="ln1136">{</a>
<a name="ln1137">    if (otr_stop_summoning_prompt())</a>
<a name="ln1138">        return spret::abort;</a>
<a name="ln1139"> </a>
<a name="ln1140">    fail_check();</a>
<a name="ln1141">    mpr(&quot;You open a gate to Pandemonium!&quot;);</a>
<a name="ln1142"> </a>
<a name="ln1143">    if (!_summon_greater_demon(pow, god, SPELL_SUMMON_GREATER_DEMON))</a>
<a name="ln1144">        canned_msg(MSG_NOTHING_HAPPENS);</a>
<a name="ln1145"> </a>
<a name="ln1146">    return spret::success;</a>
<a name="ln1147">}</a>
<a name="ln1148"> </a>
<a name="ln1149">spret cast_shadow_creatures(int st, god_type god, level_id place,</a>
<a name="ln1150">                                 bool fail)</a>
<a name="ln1151">{</a>
<a name="ln1152">    if (otr_stop_summoning_prompt(&quot;summon&quot;))</a>
<a name="ln1153">        return spret::abort;</a>
<a name="ln1154"> </a>
<a name="ln1155">    fail_check();</a>
<a name="ln1156">    const bool scroll = (st == MON_SUMM_SCROLL);</a>
<a name="ln1157">    mpr(&quot;Wisps of shadow whirl around you...&quot;);</a>
<a name="ln1158"> </a>
<a name="ln1159">    int num = (scroll ? roll_dice(2, 2) : 1);</a>
<a name="ln1160">    int num_created = 0;</a>
<a name="ln1161"> </a>
<a name="ln1162">    for (int i = 0; i &lt; num; ++i)</a>
<a name="ln1163">    {</a>
<a name="ln1164">        if (monster *mons = create_monster(</a>
<a name="ln1165">            mgen_data(RANDOM_COMPATIBLE_MONSTER, BEH_FRIENDLY, you.pos(),</a>
<a name="ln1166">                      MHITYOU, MG_FORCE_BEH | MG_AUTOFOE | MG_NO_OOD)</a>
<a name="ln1167">                      // This duration is only used for band members.</a>
<a name="ln1168">                      .set_summoned(&amp;you, scroll ? 2 : 1, st, god)</a>
<a name="ln1169">                      .set_place(place),</a>
<a name="ln1170">            false))</a>
<a name="ln1171">        {</a>
<a name="ln1172">            // In the rare cases that a specific spell set of a monster will</a>
<a name="ln1173">            // cause anger, even if others do not, try rerolling</a>
<a name="ln1174">            int tries = 0;</a>
<a name="ln1175">            while (player_will_anger_monster(*mons) &amp;&amp; ++tries &lt;= 20)</a>
<a name="ln1176">            {</a>
<a name="ln1177">                // Save the enchantments, particularly ENCH_SUMMON etc.</a>
<a name="ln1178">                mon_enchant_list ench = mons-&gt;enchantments;</a>
<a name="ln1179">                FixedBitVector&lt;NUM_ENCHANTMENTS&gt; cache = mons-&gt;ench_cache;</a>
<a name="ln1180">                if (mons_class_is_zombified(mons-&gt;type))</a>
<a name="ln1181">                    define_zombie(mons, mons-&gt;base_monster, mons-&gt;type);</a>
<a name="ln1182">                else</a>
<a name="ln1183">                    define_monster(*mons);</a>
<a name="ln1184">                mons-&gt;enchantments = ench;</a>
<a name="ln1185">                mons-&gt;ench_cache = cache;</a>
<a name="ln1186">            }</a>
<a name="ln1187"> </a>
<a name="ln1188">            // If we didn't find a valid spell set yet, just give up</a>
<a name="ln1189">            if (tries &gt; 20)</a>
<a name="ln1190">                monster_die(*mons, KILL_RESET, NON_MONSTER);</a>
<a name="ln1191">            else</a>
<a name="ln1192">            {</a>
<a name="ln1193">                // Choose a new duration based on HD.</a>
<a name="ln1194">                int x = max(mons-&gt;get_experience_level() - 3, 1);</a>
<a name="ln1195">                int d = div_rand_round(17,x);</a>
<a name="ln1196">                if (scroll)</a>
<a name="ln1197">                    d++;</a>
<a name="ln1198">                if (d &lt; 1)</a>
<a name="ln1199">                    d = 1;</a>
<a name="ln1200">                if (d &gt; 4)</a>
<a name="ln1201">                    d = 4;</a>
<a name="ln1202">                mon_enchant me = mon_enchant(ENCH_ABJ, d);</a>
<a name="ln1203">                me.set_duration(mons, &amp;me);</a>
<a name="ln1204">                mons-&gt;update_ench(me);</a>
<a name="ln1205"> </a>
<a name="ln1206">                // Set summon ID, to share summon cap with its band members</a>
<a name="ln1207">                mons-&gt;props[&quot;summon_id&quot;].get_int() = mons-&gt;mid;</a>
<a name="ln1208">            }</a>
<a name="ln1209"> </a>
<a name="ln1210">            // Remove any band members that would turn hostile, and link their</a>
<a name="ln1211">            // summon IDs</a>
<a name="ln1212">            for (monster_iterator mi; mi; ++mi)</a>
<a name="ln1213">            {</a>
<a name="ln1214">                if (testbits(mi-&gt;flags, MF_BAND_MEMBER)</a>
<a name="ln1215">                    &amp;&amp; (mid_t) mi-&gt;props[&quot;band_leader&quot;].get_int() == mons-&gt;mid)</a>
<a name="ln1216">                {</a>
<a name="ln1217">                    if (player_will_anger_monster(**mi))</a>
<a name="ln1218">                        monster_die(**mi, KILL_RESET, NON_MONSTER);</a>
<a name="ln1219"> </a>
<a name="ln1220">                    mi-&gt;props[&quot;summon_id&quot;].get_int() = mons-&gt;mid;</a>
<a name="ln1221">                }</a>
<a name="ln1222">            }</a>
<a name="ln1223"> </a>
<a name="ln1224">            num_created++;</a>
<a name="ln1225">        }</a>
<a name="ln1226">    }</a>
<a name="ln1227"> </a>
<a name="ln1228">    if (!num_created)</a>
<a name="ln1229">        mpr(&quot;The shadows disperse without effect.&quot;);</a>
<a name="ln1230"> </a>
<a name="ln1231">    return spret::success;</a>
<a name="ln1232">}</a>
<a name="ln1233"> </a>
<a name="ln1234">bool can_cast_malign_gateway()</a>
<a name="ln1235">{</a>
<a name="ln1236">    timeout_malign_gateways(0);</a>
<a name="ln1237"> </a>
<a name="ln1238">    return count_malign_gateways() &lt; 1;</a>
<a name="ln1239">}</a>
<a name="ln1240"> </a>
<a name="ln1241">coord_def find_gateway_location(actor* caster)</a>
<a name="ln1242">{</a>
<a name="ln1243">    vector&lt;coord_def&gt; points;</a>
<a name="ln1244"> </a>
<a name="ln1245">    bool xray = you.xray_vision;</a>
<a name="ln1246">    you.xray_vision = false;</a>
<a name="ln1247"> </a>
<a name="ln1248">    for (coord_def delta : Compass)</a>
<a name="ln1249">    {</a>
<a name="ln1250">        coord_def test = coord_def(-1, -1);</a>
<a name="ln1251"> </a>
<a name="ln1252">        for (int t = 0; t &lt; 11; t++)</a>
<a name="ln1253">        {</a>
<a name="ln1254">            test = caster-&gt;pos() + (delta * (2+t));</a>
<a name="ln1255">            if (!in_bounds(test) || !feat_is_malign_gateway_suitable(grd(test))</a>
<a name="ln1256">                || actor_at(test)</a>
<a name="ln1257">                || count_neighbours_with_func(test, &amp;feat_is_solid) != 0</a>
<a name="ln1258">                || !caster-&gt;see_cell_no_trans(test))</a>
<a name="ln1259">            {</a>
<a name="ln1260">                continue;</a>
<a name="ln1261">            }</a>
<a name="ln1262"> </a>
<a name="ln1263">            points.push_back(test);</a>
<a name="ln1264">        }</a>
<a name="ln1265">    }</a>
<a name="ln1266"> </a>
<a name="ln1267">    you.xray_vision = xray;</a>
<a name="ln1268"> </a>
<a name="ln1269">    if (points.empty())</a>
<a name="ln1270">        return coord_def(0, 0);</a>
<a name="ln1271"> </a>
<a name="ln1272">    return points[random2(points.size())];</a>
<a name="ln1273">}</a>
<a name="ln1274"> </a>
<a name="ln1275">void create_malign_gateway(coord_def point, beh_type beh, string cause,</a>
<a name="ln1276">                           int pow, god_type god, bool is_player)</a>
<a name="ln1277">{</a>
<a name="ln1278">    const int malign_gateway_duration = BASELINE_DELAY * (random2(2) + 1);</a>
<a name="ln1279">    env.markers.add(new map_malign_gateway_marker(point,</a>
<a name="ln1280">                            malign_gateway_duration,</a>
<a name="ln1281">                            is_player,</a>
<a name="ln1282">                            is_player ? &quot;&quot; : cause,</a>
<a name="ln1283">                            beh,</a>
<a name="ln1284">                            god,</a>
<a name="ln1285">                            pow));</a>
<a name="ln1286">    env.markers.clear_need_activate();</a>
<a name="ln1287">    env.grid(point) = DNGN_MALIGN_GATEWAY;</a>
<a name="ln1288">    set_terrain_changed(point);</a>
<a name="ln1289"> </a>
<a name="ln1290">    noisy(spell_effect_noise(SPELL_MALIGN_GATEWAY), point);</a>
<a name="ln1291">    mprf(MSGCH_WARN, &quot;The dungeon shakes, a horrible noise fills the air, &quot;</a>
<a name="ln1292">                     &quot;and a portal to some otherworldly place is opened!&quot;);</a>
<a name="ln1293">}</a>
<a name="ln1294"> </a>
<a name="ln1295">spret cast_malign_gateway(actor * caster, int pow, god_type god, bool fail)</a>
<a name="ln1296">{</a>
<a name="ln1297">    coord_def point = find_gateway_location(caster);</a>
<a name="ln1298">    bool success = point != coord_def(0, 0);</a>
<a name="ln1299"> </a>
<a name="ln1300">    bool is_player = caster-&gt;is_player();</a>
<a name="ln1301"> </a>
<a name="ln1302">    if (success)</a>
<a name="ln1303">    {</a>
<a name="ln1304">        fail_check();</a>
<a name="ln1305"> </a>
<a name="ln1306">        create_malign_gateway(</a>
<a name="ln1307">            point,</a>
<a name="ln1308">            is_player ? BEH_FRIENDLY</a>
<a name="ln1309">                      : attitude_creation_behavior(</a>
<a name="ln1310">                          caster-&gt;as_monster()-&gt;attitude),</a>
<a name="ln1311">            is_player ? &quot;&quot;</a>
<a name="ln1312">                      : caster-&gt;as_monster()-&gt;full_name(DESC_A),</a>
<a name="ln1313">            pow,</a>
<a name="ln1314">            god,</a>
<a name="ln1315">            is_player);</a>
<a name="ln1316"> </a>
<a name="ln1317">        return spret::success;</a>
<a name="ln1318">    }</a>
<a name="ln1319"> </a>
<a name="ln1320">    // We don't care if monsters fail to cast it.</a>
<a name="ln1321">    if (is_player)</a>
<a name="ln1322">        mpr(&quot;A gateway cannot be opened in this cramped space!&quot;);</a>
<a name="ln1323"> </a>
<a name="ln1324">    return spret::abort;</a>
<a name="ln1325">}</a>
<a name="ln1326"> </a>
<a name="ln1327">spret cast_summon_horrible_things(int pow, god_type god, bool fail)</a>
<a name="ln1328">{</a>
<a name="ln1329">    fail_check();</a>
<a name="ln1330">    if (god == GOD_NO_GOD &amp;&amp; one_chance_in(5))</a>
<a name="ln1331">    {</a>
<a name="ln1332">        // if someone deletes the db, no message is ok</a>
<a name="ln1333">        mpr(getMiscString(&quot;SHT_int_loss&quot;));</a>
<a name="ln1334">        lose_stat(STAT_INT, 1);</a>
<a name="ln1335">    }</a>
<a name="ln1336"> </a>
<a name="ln1337">    int num_abominations = random_range(2, 4) + x_chance_in_y(pow, 200);</a>
<a name="ln1338">    int num_tmons = random2(pow) &gt; 120 ? 2 : random2(pow) &gt; 50 ? 1 : 0;</a>
<a name="ln1339"> </a>
<a name="ln1340">    if (num_tmons == 0)</a>
<a name="ln1341">        num_abominations++;</a>
<a name="ln1342"> </a>
<a name="ln1343">    int count = 0;</a>
<a name="ln1344"> </a>
<a name="ln1345">    while (num_abominations-- &gt; 0)</a>
<a name="ln1346">    {</a>
<a name="ln1347">        const mgen_data abom = _pal_data(MONS_ABOMINATION_LARGE, 3, god,</a>
<a name="ln1348">                                         SPELL_SUMMON_HORRIBLE_THINGS);</a>
<a name="ln1349">        if (create_monster(abom))</a>
<a name="ln1350">            ++count;</a>
<a name="ln1351">    }</a>
<a name="ln1352"> </a>
<a name="ln1353">    while (num_tmons-- &gt; 0)</a>
<a name="ln1354">    {</a>
<a name="ln1355">        const mgen_data tmons = _pal_data(MONS_TENTACLED_MONSTROSITY, 3, god,</a>
<a name="ln1356">                                          SPELL_SUMMON_HORRIBLE_THINGS);</a>
<a name="ln1357">        if (create_monster(tmons))</a>
<a name="ln1358">            ++count;</a>
<a name="ln1359">    }</a>
<a name="ln1360"> </a>
<a name="ln1361">    if (!count)</a>
<a name="ln1362">        canned_msg(MSG_NOTHING_HAPPENS);</a>
<a name="ln1363"> </a>
<a name="ln1364">    return spret::success;</a>
<a name="ln1365">}</a>
<a name="ln1366"> </a>
<a name="ln1367">static bool _water_adjacent(coord_def p)</a>
<a name="ln1368">{</a>
<a name="ln1369">    for (orth_adjacent_iterator ai(p); ai; ++ai)</a>
<a name="ln1370">    {</a>
<a name="ln1371">        if (feat_is_water(grd(*ai)))</a>
<a name="ln1372">            return true;</a>
<a name="ln1373">    }</a>
<a name="ln1374"> </a>
<a name="ln1375">    return false;</a>
<a name="ln1376">}</a>
<a name="ln1377"> </a>
<a name="ln1378">/**</a>
<a name="ln1379"> * Cast summon forest.</a>
<a name="ln1380"> *</a>
<a name="ln1381"> * @param caster The caster.</a>
<a name="ln1382"> * @param pow    The spell power.</a>
<a name="ln1383"> * @param god    The god of the summoned dryad (usually the caster's).</a>
<a name="ln1384"> * @param fail   Did this spell miscast? If true, abort the cast.</a>
<a name="ln1385"> * @return       spret::abort if a summoning area couldn't be found,</a>
<a name="ln1386"> *               spret::fail if one could be found but we miscast, and</a>
<a name="ln1387"> *               spret::success if the spell was successfully cast.</a>
<a name="ln1388">*/</a>
<a name="ln1389">spret cast_summon_forest(actor* caster, int pow, god_type god, bool fail)</a>
<a name="ln1390">{</a>
<a name="ln1391">    const int duration = random_range(120 + pow, 200 + pow * 3 / 2);</a>
<a name="ln1392"> </a>
<a name="ln1393">    // Is this area open enough to summon a forest?</a>
<a name="ln1394">    bool success = false;</a>
<a name="ln1395">    for (adjacent_iterator ai(caster-&gt;pos(), false); ai; ++ai)</a>
<a name="ln1396">    {</a>
<a name="ln1397">        if (count_neighbours_with_func(*ai, &amp;feat_is_solid) == 0)</a>
<a name="ln1398">        {</a>
<a name="ln1399">            success = true;</a>
<a name="ln1400">            break;</a>
<a name="ln1401">        }</a>
<a name="ln1402">    }</a>
<a name="ln1403"> </a>
<a name="ln1404">    if (success)</a>
<a name="ln1405">    {</a>
<a name="ln1406">        if (otr_stop_summoning_prompt(&quot;summon a forest&quot;))</a>
<a name="ln1407">            return spret::abort;</a>
<a name="ln1408"> </a>
<a name="ln1409">        fail_check();</a>
<a name="ln1410">        // Replace some rock walls with trees, then scatter a smaller number</a>
<a name="ln1411">        // of trees on unoccupied floor (such that they do not break connectivity)</a>
<a name="ln1412">        for (distance_iterator di(caster-&gt;pos(), false, true,</a>
<a name="ln1413">                                  LOS_DEFAULT_RANGE); di; ++di)</a>
<a name="ln1414">        {</a>
<a name="ln1415">            if ((feat_is_wall(grd(*di)) &amp;&amp; !feat_is_permarock(grd(*di))</a>
<a name="ln1416">                 &amp;&amp; x_chance_in_y(pow, 150))</a>
<a name="ln1417">                || (grd(*di) == DNGN_FLOOR &amp;&amp; x_chance_in_y(pow, 1250)</a>
<a name="ln1418">                    &amp;&amp; !actor_at(*di) &amp;&amp; !plant_forbidden_at(*di, true)))</a>
<a name="ln1419">            {</a>
<a name="ln1420">                temp_change_terrain(*di, DNGN_TREE, duration,</a>
<a name="ln1421">                        TERRAIN_CHANGE_FORESTED);</a>
<a name="ln1422">            }</a>
<a name="ln1423">        }</a>
<a name="ln1424"> </a>
<a name="ln1425">        // Maybe make a pond</a>
<a name="ln1426">        if (coinflip())</a>
<a name="ln1427">        {</a>
<a name="ln1428">            coord_def pond = find_gateway_location(caster);</a>
<a name="ln1429">            int num = random_range(10, 22);</a>
<a name="ln1430">            int deep = (!one_chance_in(3) ? div_rand_round(num, 3) : 0);</a>
<a name="ln1431"> </a>
<a name="ln1432">            for (distance_iterator di(pond, true, false, 4); di &amp;&amp; num &gt; 0; ++di)</a>
<a name="ln1433">            {</a>
<a name="ln1434">                if (grd(*di) == DNGN_FLOOR</a>
<a name="ln1435">                    &amp;&amp; (di.radius() == 0 || _water_adjacent(*di))</a>
<a name="ln1436">                    &amp;&amp; x_chance_in_y(4, di.radius() + 3))</a>
<a name="ln1437">                {</a>
<a name="ln1438">                    num--;</a>
<a name="ln1439">                    deep--;</a>
<a name="ln1440"> </a>
<a name="ln1441">                    dungeon_feature_type feat = DNGN_SHALLOW_WATER;</a>
<a name="ln1442">                    if (deep &gt; 0 &amp;&amp; *di != you.pos())</a>
<a name="ln1443">                    {</a>
<a name="ln1444">                        monster* mon = monster_at(*di);</a>
<a name="ln1445">                        if (!mon || mon-&gt;is_habitable_feat(DNGN_DEEP_WATER))</a>
<a name="ln1446">                            feat = DNGN_DEEP_WATER;</a>
<a name="ln1447">                    }</a>
<a name="ln1448"> </a>
<a name="ln1449">                    temp_change_terrain(*di, feat, duration, TERRAIN_CHANGE_FORESTED);</a>
<a name="ln1450">                }</a>
<a name="ln1451">            }</a>
<a name="ln1452">        }</a>
<a name="ln1453"> </a>
<a name="ln1454">        mpr(&quot;A forested plane collides here with a resounding crunch!&quot;);</a>
<a name="ln1455">        noisy(spell_effect_noise(SPELL_SUMMON_FOREST), caster-&gt;pos());</a>
<a name="ln1456"> </a>
<a name="ln1457">        mgen_data dryad_data = _pal_data(MONS_DRYAD, 1, god,</a>
<a name="ln1458">                                         SPELL_SUMMON_FOREST);</a>
<a name="ln1459">        dryad_data.hd = 5 + div_rand_round(pow, 18);</a>
<a name="ln1460"> </a>
<a name="ln1461">        if (monster *dryad = create_monster(dryad_data))</a>
<a name="ln1462">        {</a>
<a name="ln1463">            mon_enchant abj = dryad-&gt;get_ench(ENCH_ABJ);</a>
<a name="ln1464">            abj.duration = duration - 10;</a>
<a name="ln1465">            dryad-&gt;update_ench(abj);</a>
<a name="ln1466"> </a>
<a name="ln1467">            // Pre-awaken the forest just summoned.</a>
<a name="ln1468">            bolt dummy;</a>
<a name="ln1469">            mons_cast(dryad, dummy, SPELL_AWAKEN_FOREST,</a>
<a name="ln1470">                      dryad-&gt;spell_slot_flags(SPELL_AWAKEN_FOREST));</a>
<a name="ln1471">        }</a>
<a name="ln1472"> </a>
<a name="ln1473">        you.duration[DUR_FORESTED] = duration;</a>
<a name="ln1474"> </a>
<a name="ln1475">        return spret::success;</a>
<a name="ln1476">    }</a>
<a name="ln1477"> </a>
<a name="ln1478">    mpr(&quot;You need more open space to cast this spell.&quot;);</a>
<a name="ln1479">    return spret::abort;</a>
<a name="ln1480">}</a>
<a name="ln1481"> </a>
<a name="ln1482">static bool _animatable_remains(const item_def&amp; item)</a>
<a name="ln1483">{</a>
<a name="ln1484">    return item.base_type == OBJ_CORPSES</a>
<a name="ln1485">        &amp;&amp; mons_class_can_be_zombified(item.mon_type)</a>
<a name="ln1486">        // the above allows spectrals/etc</a>
<a name="ln1487">        &amp;&amp; (mons_zombifiable(item.mon_type)</a>
<a name="ln1488">            || mons_skeleton(item.mon_type));</a>
<a name="ln1489">}</a>
<a name="ln1490"> </a>
<a name="ln1491">/**</a>
<a name="ln1492"> * Equip the dearly departed with its ex-possessions.</a>
<a name="ln1493"> *</a>
<a name="ln1494"> * This excludes holy items (not wieldable by the undead, and items which were</a>
<a name="ln1495"> * dropped onto the square, so the player can't equip their undead slaves with</a>
<a name="ln1496"> * items of their choice.</a>
<a name="ln1497"> *</a>
<a name="ln1498"> * @param a      where to pull items from</a>
<a name="ln1499"> * @param corpse the corpse of the dead monster.</a>
<a name="ln1500"> * @param mon    the zombie/skeleton/etc. being reequipped.</a>
<a name="ln1501"> */</a>
<a name="ln1502">static void _equip_undead(const coord_def &amp;a, const item_def&amp; corpse, monster *mon)</a>
<a name="ln1503">{</a>
<a name="ln1504">    if (!corpse.props.exists(MONSTER_MID))</a>
<a name="ln1505">        return;</a>
<a name="ln1506">    for (stack_iterator si(a); si; ++si)</a>
<a name="ln1507">    {</a>
<a name="ln1508">        if (!si-&gt;props.exists(DROPPER_MID_KEY)</a>
<a name="ln1509">            || si-&gt;props[DROPPER_MID_KEY].get_int()</a>
<a name="ln1510">               != corpse.props[MONSTER_MID].get_int())</a>
<a name="ln1511">        {</a>
<a name="ln1512">            continue;</a>
<a name="ln1513">        }</a>
<a name="ln1514"> </a>
<a name="ln1515">        // Don't equip the undead with holy items.</a>
<a name="ln1516">        if (is_holy_item(*si))</a>
<a name="ln1517">            continue;</a>
<a name="ln1518"> </a>
<a name="ln1519">        // Stupid undead can't use most items.</a>
<a name="ln1520">        if (si-&gt;base_type != OBJ_WEAPONS</a>
<a name="ln1521">            &amp;&amp; si-&gt;base_type != OBJ_STAVES</a>
<a name="ln1522">            &amp;&amp; si-&gt;base_type != OBJ_ARMOUR</a>
<a name="ln1523">            || is_range_weapon(*si))</a>
<a name="ln1524">        {</a>
<a name="ln1525">            continue;</a>
<a name="ln1526">        }</a>
<a name="ln1527"> </a>
<a name="ln1528">        unwind_var&lt;int&gt; save_speedinc(mon-&gt;speed_increment);</a>
<a name="ln1529">        mon-&gt;pickup_item(*si, false, true);</a>
<a name="ln1530">    }</a>
<a name="ln1531">}</a>
<a name="ln1532"> </a>
<a name="ln1533">// Displays message when raising dead with Animate Skeleton or Animate Dead.</a>
<a name="ln1534">static void _display_undead_motions(int motions)</a>
<a name="ln1535">{</a>
<a name="ln1536">    vector&lt;const char *&gt; motions_list;</a>
<a name="ln1537"> </a>
<a name="ln1538">    // Check bitfield from _raise_remains for types of corpse(s) being animated.</a>
<a name="ln1539">    if (motions &amp; DEAD_ARE_WALKING)</a>
<a name="ln1540">        motions_list.push_back(&quot;walking&quot;);</a>
<a name="ln1541">    if (motions &amp; DEAD_ARE_HOPPING)</a>
<a name="ln1542">        motions_list.push_back(&quot;hopping&quot;);</a>
<a name="ln1543">    if (motions &amp; DEAD_ARE_SWIMMING)</a>
<a name="ln1544">        motions_list.push_back(&quot;swimming&quot;);</a>
<a name="ln1545">    if (motions &amp; DEAD_ARE_FLYING)</a>
<a name="ln1546">        motions_list.push_back(&quot;flying&quot;);</a>
<a name="ln1547">    if (motions &amp; DEAD_ARE_SLITHERING)</a>
<a name="ln1548">        motions_list.push_back(&quot;slithering&quot;);</a>
<a name="ln1549">    if (motions &amp; DEAD_ARE_CRAWLING)</a>
<a name="ln1550">        motions_list.push_back(&quot;crawling&quot;);</a>
<a name="ln1551"> </a>
<a name="ln1552">    // Prevents the message from getting too long and spammy.</a>
<a name="ln1553">    if (motions_list.size() &gt; 3)</a>
<a name="ln1554">        mpr(&quot;The dead have arisen!&quot;);</a>
<a name="ln1555">    else</a>
<a name="ln1556">    {</a>
<a name="ln1557">        mprf(&quot;The dead are %s!&quot;, comma_separated_line(motions_list.begin(),</a>
<a name="ln1558">             motions_list.end()).c_str());</a>
<a name="ln1559">    }</a>
<a name="ln1560">}</a>
<a name="ln1561"> </a>
<a name="ln1562">static bool _raise_remains(const coord_def &amp;pos, int corps, beh_type beha,</a>
<a name="ln1563">                           unsigned short hitting, actor *as, string nas,</a>
<a name="ln1564">                           god_type god, bool actual, bool force_beh,</a>
<a name="ln1565">                           monster **raised, int* motions_r)</a>
<a name="ln1566">{</a>
<a name="ln1567">    if (raised)</a>
<a name="ln1568">        *raised = 0;</a>
<a name="ln1569"> </a>
<a name="ln1570">    const item_def&amp; item = mitm[corps];</a>
<a name="ln1571"> </a>
<a name="ln1572">    if (!_animatable_remains(item))</a>
<a name="ln1573">        return false;</a>
<a name="ln1574"> </a>
<a name="ln1575">    if (!actual)</a>
<a name="ln1576">        return true;</a>
<a name="ln1577"> </a>
<a name="ln1578">    monster_type zombie_type = item.mon_type;</a>
<a name="ln1579">    // hack: don't re-froggify poor prince ribbit after death</a>
<a name="ln1580">    if (zombie_type == MONS_PRINCE_RIBBIT)</a>
<a name="ln1581">        zombie_type = MONS_HUMAN;</a>
<a name="ln1582"> </a>
<a name="ln1583">    const int hd = (item.props.exists(MONSTER_HIT_DICE)) ?</a>
<a name="ln1584">                    item.props[MONSTER_HIT_DICE].get_short() : 0;</a>
<a name="ln1585"> </a>
<a name="ln1586">    // Save the corpse name before because it can get destroyed if it is</a>
<a name="ln1587">    // being drained and the raising interrupts it.</a>
<a name="ln1588">    monster_flags_t name_type;</a>
<a name="ln1589">    string name;</a>
<a name="ln1590">    if (is_named_corpse(item))</a>
<a name="ln1591">        name = get_corpse_name(item, &amp;name_type);</a>
<a name="ln1592"> </a>
<a name="ln1593">    monster_type mon = item.sub_type == CORPSE_BODY ? MONS_ZOMBIE</a>
<a name="ln1594">                                                    : MONS_SKELETON;</a>
<a name="ln1595">    monster_type monnum = static_cast&lt;monster_type&gt;(item.orig_monnum);</a>
<a name="ln1596">    // hack: don't re-froggify poor prince ribbit after death</a>
<a name="ln1597">    if (monnum == MONS_PRINCE_RIBBIT)</a>
<a name="ln1598">        monnum = MONS_HUMAN;</a>
<a name="ln1599"> </a>
<a name="ln1600">    if (mon == MONS_ZOMBIE &amp;&amp; !mons_zombifiable(zombie_type))</a>
<a name="ln1601">    {</a>
<a name="ln1602">        ASSERT(mons_skeleton(zombie_type));</a>
<a name="ln1603">        if (as == &amp;you)</a>
<a name="ln1604">        {</a>
<a name="ln1605">            mpr(&quot;The flesh is too rotten for a proper zombie; &quot;</a>
<a name="ln1606">                &quot;only a skeleton remains.&quot;);</a>
<a name="ln1607">        }</a>
<a name="ln1608">        mon = MONS_SKELETON;</a>
<a name="ln1609">    }</a>
<a name="ln1610"> </a>
<a name="ln1611">    // Use the original monster type as the zombified type here, to get</a>
<a name="ln1612">    // the proper stats from it.</a>
<a name="ln1613">    mgen_data mg(mon, beha, pos, hitting,</a>
<a name="ln1614">                 MG_FORCE_BEH | MG_FORCE_PLACE | MG_AUTOFOE);</a>
<a name="ln1615">    mg.set_summoned(as, 0, 0, god);</a>
<a name="ln1616">    mg.set_base(monnum);</a>
<a name="ln1617"> </a>
<a name="ln1618">    if (item.props.exists(CORPSE_HEADS))</a>
<a name="ln1619">    {</a>
<a name="ln1620">        // Headless hydras cannot be raised, sorry.</a>
<a name="ln1621">        if (item.props[CORPSE_HEADS].get_short() == 0)</a>
<a name="ln1622">        {</a>
<a name="ln1623">            if (you.see_cell(pos))</a>
<a name="ln1624">            {</a>
<a name="ln1625">                mprf(&quot;The headless hydra %s sways and immediately collapses!&quot;,</a>
<a name="ln1626">                     item.sub_type == CORPSE_BODY ? &quot;corpse&quot; : &quot;skeleton&quot;);</a>
<a name="ln1627">            }</a>
<a name="ln1628">            return false;</a>
<a name="ln1629">        }</a>
<a name="ln1630">        mg.props[MGEN_NUM_HEADS] = item.props[CORPSE_HEADS].get_short();</a>
<a name="ln1631">    }</a>
<a name="ln1632"> </a>
<a name="ln1633">    // No experience for monsters animated by god wrath or the Sword of</a>
<a name="ln1634">    // Zonguldrok.</a>
<a name="ln1635">    if (!nas.empty())</a>
<a name="ln1636">        mg.extra_flags |= MF_NO_REWARD;</a>
<a name="ln1637"> </a>
<a name="ln1638">    mg.non_actor_summoner = nas;</a>
<a name="ln1639"> </a>
<a name="ln1640">    monster *mons = create_monster(mg);</a>
<a name="ln1641"> </a>
<a name="ln1642">    if (raised)</a>
<a name="ln1643">        *raised = mons;</a>
<a name="ln1644"> </a>
<a name="ln1645">    if (!mons)</a>
<a name="ln1646">        return false;</a>
<a name="ln1647"> </a>
<a name="ln1648">    if (god == GOD_NO_GOD) // only Yred dead-raising lasts forever.</a>
<a name="ln1649">        mons-&gt;add_ench(mon_enchant(ENCH_FAKE_ABJURATION, 6));</a>
<a name="ln1650"> </a>
<a name="ln1651">    // If the original monster has been levelled up, its HD might be different</a>
<a name="ln1652">    // from its class HD, in which case its HP should be rerolled to match.</a>
<a name="ln1653">    if (mons-&gt;get_experience_level() != hd)</a>
<a name="ln1654">    {</a>
<a name="ln1655">        mons-&gt;set_hit_dice(max(hd, 1));</a>
<a name="ln1656">        roll_zombie_hp(mons);</a>
<a name="ln1657">    }</a>
<a name="ln1658"> </a>
<a name="ln1659">    if (!name.empty()</a>
<a name="ln1660">        &amp;&amp; (!name_type || (name_type &amp; MF_NAME_MASK) == MF_NAME_REPLACE))</a>
<a name="ln1661">    {</a>
<a name="ln1662">        name_zombie(*mons, monnum, name);</a>
<a name="ln1663">    }</a>
<a name="ln1664"> </a>
<a name="ln1665">    // Re-equip the zombie.</a>
<a name="ln1666">    if (mons_class_itemuse(monnum) &gt;= MONUSE_STARTING_EQUIPMENT)</a>
<a name="ln1667">        _equip_undead(pos, item, mons);</a>
<a name="ln1668"> </a>
<a name="ln1669">    // Destroy the monster's corpse, as it's no longer needed.</a>
<a name="ln1670">    item_was_destroyed(item);</a>
<a name="ln1671">    destroy_item(corps);</a>
<a name="ln1672"> </a>
<a name="ln1673">    if (!force_beh)</a>
<a name="ln1674">        player_angers_monster(mons);</a>
<a name="ln1675"> </a>
<a name="ln1676">    // Bitfield for motions - determines text displayed when animating dead.</a>
<a name="ln1677">    // XXX: could this use monster shape in some way?</a>
<a name="ln1678">    if (mons_class_primary_habitat(zombie_type)    == HT_WATER</a>
<a name="ln1679">        || mons_class_primary_habitat(zombie_type) == HT_LAVA)</a>
<a name="ln1680">    {</a>
<a name="ln1681">        *motions_r |= DEAD_ARE_SWIMMING;</a>
<a name="ln1682">    }</a>
<a name="ln1683">    else if (mons_class_flag(zombie_type, M_FLIES))</a>
<a name="ln1684">        *motions_r |= DEAD_ARE_FLYING;</a>
<a name="ln1685">    else if (mons_genus(zombie_type)    == MONS_SNAKE</a>
<a name="ln1686">             || mons_genus(zombie_type) == MONS_NAGA</a>
<a name="ln1687">             || mons_genus(zombie_type) == MONS_SALAMANDER</a>
<a name="ln1688">             || mons_genus(zombie_type) == MONS_GUARDIAN_SERPENT</a>
<a name="ln1689">             || mons_genus(zombie_type) == MONS_ELEPHANT_SLUG</a>
<a name="ln1690">             || mons_genus(zombie_type) == MONS_TYRANT_LEECH</a>
<a name="ln1691">             || mons_genus(zombie_type) == MONS_WORM)</a>
<a name="ln1692">    {</a>
<a name="ln1693">        *motions_r |= DEAD_ARE_SLITHERING;</a>
<a name="ln1694">    }</a>
<a name="ln1695">    else if (mons_genus(zombie_type)    == MONS_FROG</a>
<a name="ln1696">             || mons_genus(zombie_type) == MONS_QUOKKA)</a>
<a name="ln1697">    {</a>
<a name="ln1698">        *motions_r |= DEAD_ARE_HOPPING;</a>
<a name="ln1699">    }</a>
<a name="ln1700">    else if (mons_genus(zombie_type)    == MONS_WORKER_ANT</a>
<a name="ln1701">             || mons_base_char(zombie_type) == 's') // many genera</a>
<a name="ln1702">    {</a>
<a name="ln1703">        *motions_r |= DEAD_ARE_CRAWLING;</a>
<a name="ln1704">    }</a>
<a name="ln1705">    else</a>
<a name="ln1706">        *motions_r |= DEAD_ARE_WALKING;</a>
<a name="ln1707"> </a>
<a name="ln1708">    return true;</a>
<a name="ln1709">}</a>
<a name="ln1710"> </a>
<a name="ln1711">// Note that quiet will *not* suppress the message about a corpse</a>
<a name="ln1712">// you are butchering being animated.</a>
<a name="ln1713">// This is called for Animate Skeleton and from animate_dead.</a>
<a name="ln1714">int animate_remains(const coord_def &amp;a, corpse_type class_allowed,</a>
<a name="ln1715">                    beh_type beha, unsigned short hitting,</a>
<a name="ln1716">                    actor *as, string nas,</a>
<a name="ln1717">                    god_type god, bool actual,</a>
<a name="ln1718">                    bool quiet, bool force_beh,</a>
<a name="ln1719">                    monster** mon, int* motions_r)</a>
<a name="ln1720">{</a>
<a name="ln1721">    if (is_sanctuary(a))</a>
<a name="ln1722">        return 0;</a>
<a name="ln1723"> </a>
<a name="ln1724">    if (grd(a) == DNGN_DEEP_WATER)</a>
<a name="ln1725">        return 0; // trapped in davy jones' locker...</a>
<a name="ln1726"> </a>
<a name="ln1727">    int number_found = 0;</a>
<a name="ln1728">    bool any_success = false;</a>
<a name="ln1729">    int motions = 0;</a>
<a name="ln1730"> </a>
<a name="ln1731">    // Search all the items on the ground for a corpse.</a>
<a name="ln1732">    for (stack_iterator si(a, true); si; ++si)</a>
<a name="ln1733">    {</a>
<a name="ln1734">        if (si-&gt;base_type != OBJ_CORPSES)</a>
<a name="ln1735">            continue;</a>
<a name="ln1736"> </a>
<a name="ln1737">        if (class_allowed != CORPSE_BODY &amp;&amp; si-&gt;sub_type != CORPSE_SKELETON)</a>
<a name="ln1738">            continue;</a>
<a name="ln1739"> </a>
<a name="ln1740">        number_found++;</a>
<a name="ln1741"> </a>
<a name="ln1742">        if (!_animatable_remains(*si))</a>
<a name="ln1743">            continue;</a>
<a name="ln1744"> </a>
<a name="ln1745">        const bool was_draining = is_being_drained(*si);</a>
<a name="ln1746">        const bool was_butchering = is_being_butchered(*si);</a>
<a name="ln1747"> </a>
<a name="ln1748">        const bool success = _raise_remains(a, si.index(), beha, hitting,</a>
<a name="ln1749">                                            as, nas, god, actual,</a>
<a name="ln1750">                                            force_beh, mon, &amp;motions);</a>
<a name="ln1751"> </a>
<a name="ln1752">        if (actual &amp;&amp; success)</a>
<a name="ln1753">        {</a>
<a name="ln1754">            // Ignore quiet.</a>
<a name="ln1755">            if (was_butchering || was_draining)</a>
<a name="ln1756">            {</a>
<a name="ln1757">                mprf(&quot;The corpse you are %s rises to %s!&quot;,</a>
<a name="ln1758">                     was_draining ? &quot;drinking from&quot;</a>
<a name="ln1759">                                  : &quot;butchering&quot;,</a>
<a name="ln1760">                     beha == BEH_FRIENDLY ? &quot;join your ranks&quot;</a>
<a name="ln1761">                                          : &quot;attack&quot;);</a>
<a name="ln1762">            }</a>
<a name="ln1763"> </a>
<a name="ln1764">            if (!quiet &amp;&amp; you.see_cell(a))</a>
<a name="ln1765">                _display_undead_motions(motions);</a>
<a name="ln1766"> </a>
<a name="ln1767">            if (was_butchering)</a>
<a name="ln1768">                xom_is_stimulated(200);</a>
<a name="ln1769">        }</a>
<a name="ln1770"> </a>
<a name="ln1771">        any_success |= success;</a>
<a name="ln1772"> </a>
<a name="ln1773">        break;</a>
<a name="ln1774">    }</a>
<a name="ln1775"> </a>
<a name="ln1776">    if (motions_r &amp;&amp; you.see_cell(a))</a>
<a name="ln1777">        *motions_r |= motions;</a>
<a name="ln1778"> </a>
<a name="ln1779">    if (number_found == 0)</a>
<a name="ln1780">        return -1;</a>
<a name="ln1781"> </a>
<a name="ln1782">    if (!any_success)</a>
<a name="ln1783">        return 0;</a>
<a name="ln1784"> </a>
<a name="ln1785">    return 1;</a>
<a name="ln1786">}</a>
<a name="ln1787"> </a>
<a name="ln1788">int animate_dead(actor *caster, int /*pow*/, beh_type beha,</a>
<a name="ln1789">                 unsigned short hitting, actor *as, string nas, god_type god,</a>
<a name="ln1790">                 bool actual)</a>
<a name="ln1791">{</a>
<a name="ln1792">    int number_raised = 0;</a>
<a name="ln1793">    int number_seen   = 0;</a>
<a name="ln1794">    int motions       = 0;</a>
<a name="ln1795"> </a>
<a name="ln1796">    for (radius_iterator ri(caster-&gt;pos(), LOS_NO_TRANS); ri; ++ri)</a>
<a name="ln1797">    {</a>
<a name="ln1798">        // There may be many corpses on the same spot.</a>
<a name="ln1799">        while (animate_remains(*ri, CORPSE_BODY, beha, hitting, as, nas, god,</a>
<a name="ln1800">                               actual, true, 0, 0, &amp;motions) &gt; 0)</a>
<a name="ln1801">        {</a>
<a name="ln1802">            number_raised++;</a>
<a name="ln1803">            if (you.see_cell(*ri))</a>
<a name="ln1804">                number_seen++;</a>
<a name="ln1805"> </a>
<a name="ln1806">            // For the tracer, we don't care about exact count (and the</a>
<a name="ln1807">            // corpse is not gone).</a>
<a name="ln1808">            if (!actual)</a>
<a name="ln1809">                break;</a>
<a name="ln1810">        }</a>
<a name="ln1811">    }</a>
<a name="ln1812"> </a>
<a name="ln1813">    if (actual &amp;&amp; number_seen &gt; 0)</a>
<a name="ln1814">        _display_undead_motions(motions);</a>
<a name="ln1815"> </a>
<a name="ln1816">    return number_raised;</a>
<a name="ln1817">}</a>
<a name="ln1818"> </a>
<a name="ln1819">spret cast_animate_skeleton(god_type god, bool fail)</a>
<a name="ln1820">{</a>
<a name="ln1821">    bool found = false;</a>
<a name="ln1822"> </a>
<a name="ln1823">    for (stack_iterator si(you.pos(), true); si; ++si)</a>
<a name="ln1824">    {</a>
<a name="ln1825">        if (si-&gt;base_type == OBJ_CORPSES</a>
<a name="ln1826">            &amp;&amp; mons_class_can_be_zombified(si-&gt;mon_type)</a>
<a name="ln1827">            &amp;&amp; mons_skeleton(si-&gt;mon_type))</a>
<a name="ln1828">        {</a>
<a name="ln1829">            found = true;</a>
<a name="ln1830">        }</a>
<a name="ln1831">    }</a>
<a name="ln1832"> </a>
<a name="ln1833">    if (!found)</a>
<a name="ln1834">    {</a>
<a name="ln1835">        mpr(&quot;There is nothing here that can be animated!&quot;);</a>
<a name="ln1836">        return spret::abort;</a>
<a name="ln1837">    }</a>
<a name="ln1838"> </a>
<a name="ln1839">    fail_check();</a>
<a name="ln1840">    canned_msg(MSG_ANIMATE_REMAINS);</a>
<a name="ln1841"> </a>
<a name="ln1842">    const char* no_space = &quot;...but the skeleton had no space to rise!&quot;;</a>
<a name="ln1843"> </a>
<a name="ln1844">    // First, we try to animate a skeleton if there is one.</a>
<a name="ln1845">    const int animate_skel_result = animate_remains(you.pos(), CORPSE_SKELETON,</a>
<a name="ln1846">                                                    BEH_FRIENDLY, MHITYOU,</a>
<a name="ln1847">                                                    &amp;you, &quot;&quot;, god);</a>
<a name="ln1848">    if (animate_skel_result != -1)</a>
<a name="ln1849">    {</a>
<a name="ln1850">        if (animate_skel_result == 0)</a>
<a name="ln1851">            mpr(no_space);</a>
<a name="ln1852">        return spret::success;</a>
<a name="ln1853">    }</a>
<a name="ln1854"> </a>
<a name="ln1855">    // If not, look for a corpse and butcher it.</a>
<a name="ln1856">    for (stack_iterator si(you.pos(), true); si; ++si)</a>
<a name="ln1857">    {</a>
<a name="ln1858">        if (si-&gt;is_type(OBJ_CORPSES, CORPSE_BODY)</a>
<a name="ln1859">            &amp;&amp; mons_skeleton(si-&gt;mon_type)</a>
<a name="ln1860">            &amp;&amp; mons_class_can_be_zombified(si-&gt;mon_type))</a>
<a name="ln1861">        {</a>
<a name="ln1862">            butcher_corpse(*si, true);</a>
<a name="ln1863">            mpr(&quot;Before your eyes, flesh is ripped from the corpse!&quot;);</a>
<a name="ln1864">            request_autopickup();</a>
<a name="ln1865">            // Only convert the top one.</a>
<a name="ln1866">            break;</a>
<a name="ln1867">        }</a>
<a name="ln1868">    }</a>
<a name="ln1869"> </a>
<a name="ln1870">    // Now we try again to animate a skeleton.</a>
<a name="ln1871">    // this return type is insanely stupid</a>
<a name="ln1872">    const int animate_result = animate_remains(you.pos(), CORPSE_SKELETON,</a>
<a name="ln1873">                                               BEH_FRIENDLY, MHITYOU, &amp;you, &quot;&quot;,</a>
<a name="ln1874">                                               god);</a>
<a name="ln1875">    dprf(&quot;result: %d&quot;, animate_result);</a>
<a name="ln1876">    switch (animate_result)</a>
<a name="ln1877">    {</a>
<a name="ln1878">        case -1:</a>
<a name="ln1879">            mpr(&quot;There is no skeleton here to animate!&quot;);</a>
<a name="ln1880">            break;</a>
<a name="ln1881">        case 0:</a>
<a name="ln1882">            mpr(no_space);</a>
<a name="ln1883">            break;</a>
<a name="ln1884">        default:</a>
<a name="ln1885">            // success, messages already printed</a>
<a name="ln1886">            break;</a>
<a name="ln1887">    }</a>
<a name="ln1888"> </a>
<a name="ln1889">    return spret::success;</a>
<a name="ln1890">}</a>
<a name="ln1891"> </a>
<a name="ln1892">spret cast_animate_dead(int pow, god_type god, bool fail)</a>
<a name="ln1893">{</a>
<a name="ln1894">    fail_check();</a>
<a name="ln1895">    canned_msg(MSG_CALL_DEAD);</a>
<a name="ln1896"> </a>
<a name="ln1897">    if (!animate_dead(&amp;you, pow + 1, BEH_FRIENDLY, MHITYOU, &amp;you, &quot;&quot;, god))</a>
<a name="ln1898">        canned_msg(MSG_NOTHING_HAPPENS);</a>
<a name="ln1899"> </a>
<a name="ln1900">    return spret::success;</a>
<a name="ln1901">}</a>
<a name="ln1902"> </a>
<a name="ln1903">/**</a>
<a name="ln1904"> * Have the player cast simulacrum.</a>
<a name="ln1905"> *</a>
<a name="ln1906"> * @param pow The spell power.</a>
<a name="ln1907"> * @param god The god casting the spell.</a>
<a name="ln1908"> * @param fail If true, return spret::fail unless the spell is aborted.</a>
<a name="ln1909"> * @return spret::abort if no viable corpse was at the player's location,</a>
<a name="ln1910"> *         otherwise spret::success or spret::fail based on fail.</a>
<a name="ln1911"> */</a>
<a name="ln1912">spret cast_simulacrum(int pow, god_type god, bool fail)</a>
<a name="ln1913">{</a>
<a name="ln1914">    bool found = false;</a>
<a name="ln1915">    int co = -1;</a>
<a name="ln1916">    for (stack_iterator si(you.pos(), true); si; ++si)</a>
<a name="ln1917">    {</a>
<a name="ln1918">        if (si-&gt;is_type(OBJ_CORPSES, CORPSE_BODY)</a>
<a name="ln1919">            &amp;&amp; mons_class_can_be_zombified(si-&gt;mon_type))</a>
<a name="ln1920">        {</a>
<a name="ln1921">            found = true;</a>
<a name="ln1922">            co = si-&gt;index();</a>
<a name="ln1923">        }</a>
<a name="ln1924">    }</a>
<a name="ln1925"> </a>
<a name="ln1926">    if (!found)</a>
<a name="ln1927">    {</a>
<a name="ln1928">        mpr(&quot;There is nothing here that can be animated!&quot;);</a>
<a name="ln1929">        return spret::abort;</a>
<a name="ln1930">    }</a>
<a name="ln1931"> </a>
<a name="ln1932">    fail_check();</a>
<a name="ln1933">    canned_msg(MSG_ANIMATE_REMAINS);</a>
<a name="ln1934"> </a>
<a name="ln1935">    item_def&amp; corpse = mitm[co];</a>
<a name="ln1936">    // How many simulacra can this particular monster give at maximum.</a>
<a name="ln1937">    int num_sim  = 1 + random2(max_corpse_chunks(corpse.mon_type));</a>
<a name="ln1938">    num_sim  = stepdown_value(num_sim, 4, 4, 12, 12);</a>
<a name="ln1939"> </a>
<a name="ln1940">    mgen_data mg = _pal_data(MONS_SIMULACRUM, 0, god, SPELL_SIMULACRUM);</a>
<a name="ln1941">    mg.set_base(corpse.mon_type);</a>
<a name="ln1942"> </a>
<a name="ln1943">    // Can't create more than the max for the monster.</a>
<a name="ln1944">    int how_many = min(8, 4 + random2(pow) / 20);</a>
<a name="ln1945">    how_many = min&lt;int&gt;(how_many, num_sim);</a>
<a name="ln1946"> </a>
<a name="ln1947">    if (corpse.props.exists(CORPSE_HEADS))</a>
<a name="ln1948">    {</a>
<a name="ln1949">        // Avoid headless hydras. Unlike Animate Dead, still consume the flesh.</a>
<a name="ln1950">        if (corpse.props[CORPSE_HEADS].get_short() == 0)</a>
<a name="ln1951">        {</a>
<a name="ln1952">            // No monster to conj_verb with :(</a>
<a name="ln1953">            mprf(&quot;The headless hydra simulacr%s immediately collapse%s into snow!&quot;,</a>
<a name="ln1954">                 how_many == 1 ? &quot;um&quot; : &quot;a&quot;, how_many == 1 ? &quot;s&quot; : &quot;&quot;);</a>
<a name="ln1955">            if (!turn_corpse_into_skeleton(corpse))</a>
<a name="ln1956">                butcher_corpse(corpse, false, false);</a>
<a name="ln1957">            return spret::success;</a>
<a name="ln1958">        }</a>
<a name="ln1959">        mg.props[MGEN_NUM_HEADS] = corpse.props[CORPSE_HEADS].get_short();</a>
<a name="ln1960">    }</a>
<a name="ln1961"> </a>
<a name="ln1962">    int count = 0;</a>
<a name="ln1963">    for (int i = 0; i &lt; how_many; ++i)</a>
<a name="ln1964">    {</a>
<a name="ln1965">        if (monster *sim = create_monster(mg))</a>
<a name="ln1966">        {</a>
<a name="ln1967">            count++;</a>
<a name="ln1968">            sim-&gt;add_ench(mon_enchant(ENCH_FAKE_ABJURATION, 4));</a>
<a name="ln1969">        }</a>
<a name="ln1970">    }</a>
<a name="ln1971"> </a>
<a name="ln1972">    if (!count)</a>
<a name="ln1973">        canned_msg(MSG_NOTHING_HAPPENS);</a>
<a name="ln1974">    else if (!turn_corpse_into_skeleton(corpse))</a>
<a name="ln1975">        butcher_corpse(corpse, false, false);</a>
<a name="ln1976"> </a>
<a name="ln1977">    return spret::success;</a>
<a name="ln1978">}</a>
<a name="ln1979"> </a>
<a name="ln1980">/**</a>
<a name="ln1981"> * Have a monster cast simulacrum.</a>
<a name="ln1982"> *</a>
<a name="ln1983"> * @param mon The monster casting the spell.</a>
<a name="ln1984"> * @param actual If false, return true if the spell would have succeeded on at</a>
<a name="ln1985"> *               least one corpse, but don't cast.</a>
<a name="ln1986"> * @returns True if at least one simulacrum was created, or if actual is true,</a>
<a name="ln1987"> *          if one would have been created.</a>
<a name="ln1988"> */</a>
<a name="ln1989">bool monster_simulacrum(monster *mon, bool actual)</a>
<a name="ln1990">{</a>
<a name="ln1991">    // You can see the spell being cast, not necessarily the caster.</a>
<a name="ln1992">    const bool cast_visible = you.see_cell(mon-&gt;pos());</a>
<a name="ln1993">    bool did_creation = false;</a>
<a name="ln1994">    int num_seen = 0;</a>
<a name="ln1995"> </a>
<a name="ln1996">    dprf(&quot;trying to cast simulacrum&quot;);</a>
<a name="ln1997">    for (radius_iterator ri(mon-&gt;pos(), LOS_NO_TRANS); ri; ++ri)</a>
<a name="ln1998">    {</a>
<a name="ln1999"> </a>
<a name="ln2000">        // Search all the items on the ground for a corpse.</a>
<a name="ln2001">        for (stack_iterator si(*ri, true); si; ++si)</a>
<a name="ln2002">        {</a>
<a name="ln2003">            if (si-&gt;base_type != OBJ_CORPSES</a>
<a name="ln2004">                || si-&gt;sub_type != CORPSE_BODY</a>
<a name="ln2005">                || !mons_class_can_be_zombified(si-&gt;mon_type))</a>
<a name="ln2006">            {</a>
<a name="ln2007">                continue;</a>
<a name="ln2008">            }</a>
<a name="ln2009"> </a>
<a name="ln2010">            mgen_data mg(MONS_SIMULACRUM, SAME_ATTITUDE(mon), *ri, mon-&gt;foe,</a>
<a name="ln2011">                         MG_FORCE_BEH</a>
<a name="ln2012">                         | (cast_visible ? MG_DONT_COME : MG_NONE));</a>
<a name="ln2013">            mg.set_base(si-&gt;mon_type);</a>
<a name="ln2014">            mg.set_summoned(mon, 0, SPELL_SIMULACRUM, mon-&gt;god);</a>
<a name="ln2015">            if (si-&gt;props.exists(CORPSE_HEADS))</a>
<a name="ln2016">            {</a>
<a name="ln2017">                if (si-&gt;props[CORPSE_HEADS].get_short() == 0)</a>
<a name="ln2018">                    continue;</a>
<a name="ln2019">                else</a>
<a name="ln2020">                    mg.props[MGEN_NUM_HEADS] = si-&gt;props[CORPSE_HEADS].get_short();</a>
<a name="ln2021">            }</a>
<a name="ln2022"> </a>
<a name="ln2023">            if (!actual)</a>
<a name="ln2024">                return true;</a>
<a name="ln2025"> </a>
<a name="ln2026">            // Create half as many as the player version.</a>
<a name="ln2027">            int how_many = 1 + random2(</a>
<a name="ln2028">                                  div_rand_round(</a>
<a name="ln2029">                                    max_corpse_chunks(si-&gt;mon_type), 2));</a>
<a name="ln2030">            how_many  = stepdown_value(how_many, 2, 2, 6, 6);</a>
<a name="ln2031">            bool was_draining = is_being_drained(*si);</a>
<a name="ln2032">            bool was_butchering = is_being_butchered(*si);</a>
<a name="ln2033">            bool was_successful = false;</a>
<a name="ln2034">            for (int i = 0; i &lt; how_many; ++i)</a>
<a name="ln2035">            {</a>
<a name="ln2036">                // Use the original monster type as the zombified type here,</a>
<a name="ln2037">                // to get the proper stats from it.</a>
<a name="ln2038">                if (monster *sim = create_monster(mg))</a>
<a name="ln2039">                {</a>
<a name="ln2040">                    was_successful = true;</a>
<a name="ln2041">                    player_angers_monster(sim);</a>
<a name="ln2042">                    sim-&gt;add_ench(mon_enchant(ENCH_FAKE_ABJURATION, 4));</a>
<a name="ln2043">                    if (you.can_see(*sim))</a>
<a name="ln2044">                        num_seen++;</a>
<a name="ln2045">                }</a>
<a name="ln2046">            }</a>
<a name="ln2047"> </a>
<a name="ln2048">            if (was_successful)</a>
<a name="ln2049">            {</a>
<a name="ln2050">                did_creation = true;</a>
<a name="ln2051">                turn_corpse_into_skeleton(*si);</a>
<a name="ln2052">                // Ignore quiet.</a>
<a name="ln2053">                if (was_butchering || was_draining)</a>
<a name="ln2054">                {</a>
<a name="ln2055">                    mprf(&quot;The flesh of the corpse you are %s vaporises!&quot;,</a>
<a name="ln2056">                         was_draining ? &quot;drinking from&quot; : &quot;butchering&quot;);</a>
<a name="ln2057">                    xom_is_stimulated(200);</a>
<a name="ln2058">                }</a>
<a name="ln2059"> </a>
<a name="ln2060">            }</a>
<a name="ln2061">        }</a>
<a name="ln2062">    }</a>
<a name="ln2063"> </a>
<a name="ln2064">    if (num_seen &gt; 1)</a>
<a name="ln2065">        mprf(&quot;Some icy apparitions appear!&quot;);</a>
<a name="ln2066">    else if (num_seen == 1)</a>
<a name="ln2067">        mprf(&quot;An icy apparition appears!&quot;);</a>
<a name="ln2068"> </a>
<a name="ln2069">    return did_creation;</a>
<a name="ln2070">}</a>
<a name="ln2071"> </a>
<a name="ln2072">// Return a definite/indefinite article for (number) things.</a>
<a name="ln2073">static const char *_count_article(int number, bool definite)</a>
<a name="ln2074">{</a>
<a name="ln2075">    if (number == 0)</a>
<a name="ln2076">        return &quot;No&quot;;</a>
<a name="ln2077">    else if (definite)</a>
<a name="ln2078">        return &quot;The&quot;;</a>
<a name="ln2079">    else if (number == 1)</a>
<a name="ln2080">        return &quot;A&quot;;</a>
<a name="ln2081">    else</a>
<a name="ln2082">        return &quot;Some&quot;;</a>
<a name="ln2083">}</a>
<a name="ln2084"> </a>
<a name="ln2085">bool twisted_resurrection(actor *caster, int pow, beh_type beha,</a>
<a name="ln2086">                          unsigned short foe, god_type god, bool actual)</a>
<a name="ln2087">{</a>
<a name="ln2088">    int num_orcs = 0;</a>
<a name="ln2089">    int num_holy = 0;</a>
<a name="ln2090"> </a>
<a name="ln2091">    // In a tracer (actual == false), num_crawlies counts the number of</a>
<a name="ln2092">    // affected corpses. When actual == true, these count the number of</a>
<a name="ln2093">    // crawling corpses, macabre masses, and lost corpses, respectively.</a>
<a name="ln2094">    int num_crawlies = 0;</a>
<a name="ln2095">    int num_masses = 0;</a>
<a name="ln2096">    int num_lost = 0;</a>
<a name="ln2097"> </a>
<a name="ln2098">    // ...and the number of each that were seen by the player.</a>
<a name="ln2099">    int seen_crawlies = 0;</a>
<a name="ln2100">    int seen_masses = 0;</a>
<a name="ln2101">    int seen_lost = 0;</a>
<a name="ln2102">    int seen_lost_piles = 0;</a>
<a name="ln2103"> </a>
<a name="ln2104">    for (radius_iterator ri(caster-&gt;pos(), LOS_NO_TRANS); ri; ++ri)</a>
<a name="ln2105">    {</a>
<a name="ln2106">        int num_corpses = 0;</a>
<a name="ln2107">        int total_max_chunks = 0;</a>
<a name="ln2108">        const bool visible = you.see_cell(*ri);</a>
<a name="ln2109"> </a>
<a name="ln2110">        // Count up number/size of corpses at this location.</a>
<a name="ln2111">        for (stack_iterator si(*ri); si; ++si)</a>
<a name="ln2112">        {</a>
<a name="ln2113">            if (si-&gt;is_type(OBJ_CORPSES, CORPSE_BODY))</a>
<a name="ln2114">            {</a>
<a name="ln2115">                if (!actual)</a>
<a name="ln2116">                {</a>
<a name="ln2117">                    ++num_crawlies;</a>
<a name="ln2118">                    continue;</a>
<a name="ln2119">                }</a>
<a name="ln2120"> </a>
<a name="ln2121">                if (mons_genus(si-&gt;mon_type) == MONS_ORC)</a>
<a name="ln2122">                    num_orcs++;</a>
<a name="ln2123">                if (mons_class_holiness(si-&gt;mon_type) &amp; MH_HOLY)</a>
<a name="ln2124">                    num_holy++;</a>
<a name="ln2125"> </a>
<a name="ln2126">                total_max_chunks += max_corpse_chunks(si-&gt;mon_type);</a>
<a name="ln2127"> </a>
<a name="ln2128">                ++num_corpses;</a>
<a name="ln2129">                item_was_destroyed(*si);</a>
<a name="ln2130">                destroy_item(si-&gt;index());</a>
<a name="ln2131">            }</a>
<a name="ln2132">        }</a>
<a name="ln2133"> </a>
<a name="ln2134">        if (!actual || num_corpses == 0)</a>
<a name="ln2135">            continue;</a>
<a name="ln2136"> </a>
<a name="ln2137">        // 3 HD per 2 max chunks at 500 power.</a>
<a name="ln2138">        int hd = div_rand_round((pow + 100) * total_max_chunks, 400);</a>
<a name="ln2139"> </a>
<a name="ln2140">        if (hd &lt;= 0)</a>
<a name="ln2141">        {</a>
<a name="ln2142">            num_lost += num_corpses;</a>
<a name="ln2143">            if (visible)</a>
<a name="ln2144">            {</a>
<a name="ln2145">                seen_lost += num_corpses;</a>
<a name="ln2146">                seen_lost_piles++;</a>
<a name="ln2147">            }</a>
<a name="ln2148">            continue;</a>
<a name="ln2149">        }</a>
<a name="ln2150"> </a>
<a name="ln2151">        // Getting a huge abomination shouldn't be too easy.</a>
<a name="ln2152">        if (hd &gt; 15)</a>
<a name="ln2153">            hd = 15 + (hd - 15) / 2;</a>
<a name="ln2154"> </a>
<a name="ln2155">        hd = min(hd, 30);</a>
<a name="ln2156"> </a>
<a name="ln2157">        monster_type montype;</a>
<a name="ln2158"> </a>
<a name="ln2159">        if (hd &gt;= 11 &amp;&amp; num_corpses &gt; 2)</a>
<a name="ln2160">            montype = MONS_ABOMINATION_LARGE;</a>
<a name="ln2161">        else if (hd &gt;= 6 &amp;&amp; num_corpses &gt; 1)</a>
<a name="ln2162">            montype = MONS_ABOMINATION_SMALL;</a>
<a name="ln2163">        else if (num_corpses &gt; 1)</a>
<a name="ln2164">            montype = MONS_MACABRE_MASS;</a>
<a name="ln2165">        else</a>
<a name="ln2166">            montype = MONS_CRAWLING_CORPSE;</a>
<a name="ln2167"> </a>
<a name="ln2168">        mgen_data mg(montype, beha, *ri, foe, MG_FORCE_BEH | MG_AUTOFOE);</a>
<a name="ln2169">        mg.set_summoned(caster, 0, 0, god);</a>
<a name="ln2170">        if (monster *mons = create_monster(mg))</a>
<a name="ln2171">        {</a>
<a name="ln2172">            // Set hit dice, AC, and HP.</a>
<a name="ln2173">            init_abomination(*mons, hd);</a>
<a name="ln2174"> </a>
<a name="ln2175">            if (num_corpses &gt; 1)</a>
<a name="ln2176">            {</a>
<a name="ln2177">                ++num_masses;</a>
<a name="ln2178">                if (visible)</a>
<a name="ln2179">                    ++seen_masses;</a>
<a name="ln2180">            }</a>
<a name="ln2181">            else</a>
<a name="ln2182">            {</a>
<a name="ln2183">                ++num_crawlies;</a>
<a name="ln2184">                if (visible)</a>
<a name="ln2185">                    ++seen_crawlies;</a>
<a name="ln2186">            }</a>
<a name="ln2187">        }</a>
<a name="ln2188">        else</a>
<a name="ln2189">        {</a>
<a name="ln2190">            num_lost += num_corpses;</a>
<a name="ln2191">            if (visible)</a>
<a name="ln2192">            {</a>
<a name="ln2193">                seen_lost += num_corpses;</a>
<a name="ln2194">                seen_lost_piles++;</a>
<a name="ln2195">            }</a>
<a name="ln2196">        }</a>
<a name="ln2197">    }</a>
<a name="ln2198"> </a>
<a name="ln2199">    // Monsters shouldn't bother casting Twisted Res for just a single corpse.</a>
<a name="ln2200">    if (!actual)</a>
<a name="ln2201">        return num_crawlies &gt;= (caster-&gt;is_player() ? 1 : 2);</a>
<a name="ln2202"> </a>
<a name="ln2203">    if (num_lost + num_crawlies + num_masses == 0)</a>
<a name="ln2204">        return false;</a>
<a name="ln2205"> </a>
<a name="ln2206">    if (seen_lost)</a>
<a name="ln2207">    {</a>
<a name="ln2208">        mprf(&quot;%s %s into %s!&quot;,</a>
<a name="ln2209">             _count_article(seen_lost, seen_crawlies + seen_masses == 0),</a>
<a name="ln2210">             seen_lost == 1 ? &quot;corpse collapses&quot; : &quot;corpses collapse&quot;,</a>
<a name="ln2211">             seen_lost_piles == 1 ? &quot;a pulpy mess&quot; : &quot;pulpy messes&quot;);</a>
<a name="ln2212">    }</a>
<a name="ln2213"> </a>
<a name="ln2214">    if (seen_crawlies &gt; 0)</a>
<a name="ln2215">    {</a>
<a name="ln2216">        mprf(&quot;%s %s to drag %s along the ground!&quot;,</a>
<a name="ln2217">             _count_article(seen_crawlies, seen_lost + seen_masses == 0),</a>
<a name="ln2218">             seen_crawlies == 1 ? &quot;corpse begins&quot; : &quot;corpses begin&quot;,</a>
<a name="ln2219">             seen_crawlies == 1 ? &quot;itself&quot; : &quot;themselves&quot;);</a>
<a name="ln2220">    }</a>
<a name="ln2221"> </a>
<a name="ln2222">    if (seen_masses &gt; 0)</a>
<a name="ln2223">    {</a>
<a name="ln2224">        mprf(&quot;%s corpses meld into %s of writhing flesh!&quot;,</a>
<a name="ln2225">             _count_article(2, seen_crawlies + seen_lost == 0),</a>
<a name="ln2226">             seen_masses == 1 ? &quot;an agglomeration&quot; : &quot;agglomerations&quot;);</a>
<a name="ln2227">    }</a>
<a name="ln2228"> </a>
<a name="ln2229">    if (num_orcs &gt; 0 &amp;&amp; caster-&gt;is_player())</a>
<a name="ln2230">        did_god_conduct(DID_DESECRATE_ORCISH_REMAINS, 2 * num_orcs);</a>
<a name="ln2231">    if (num_holy &gt; 0 &amp;&amp; caster-&gt;is_player())</a>
<a name="ln2232">        did_god_conduct(DID_DESECRATE_HOLY_REMAINS, 2 * num_holy);</a>
<a name="ln2233"> </a>
<a name="ln2234">    return true;</a>
<a name="ln2235">}</a>
<a name="ln2236"> </a>
<a name="ln2237">monster_type pick_random_wraith()</a>
<a name="ln2238">{</a>
<a name="ln2239">    return random_choose_weighted(1, MONS_PHANTOM,</a>
<a name="ln2240">                                  1, MONS_HUNGRY_GHOST,</a>
<a name="ln2241">                                  1, MONS_SHADOW_WRAITH,</a>
<a name="ln2242">                                  5, MONS_WRAITH,</a>
<a name="ln2243">                                  2, MONS_FREEZING_WRAITH,</a>
<a name="ln2244">                                  2, MONS_PHANTASMAL_WARRIOR);</a>
<a name="ln2245">}</a>
<a name="ln2246"> </a>
<a name="ln2247">spret cast_haunt(int pow, const coord_def&amp; where, god_type god, bool fail)</a>
<a name="ln2248">{</a>
<a name="ln2249">    monster* m = monster_at(where);</a>
<a name="ln2250"> </a>
<a name="ln2251">    if (m == nullptr)</a>
<a name="ln2252">    {</a>
<a name="ln2253">        fail_check();</a>
<a name="ln2254">        mpr(&quot;An evil force gathers, but it quickly dissipates.&quot;);</a>
<a name="ln2255">        return spret::success; // still losing a turn</a>
<a name="ln2256">    }</a>
<a name="ln2257">    else if (m-&gt;wont_attack())</a>
<a name="ln2258">    {</a>
<a name="ln2259">        mpr(&quot;You cannot haunt those who bear you no hostility.&quot;);</a>
<a name="ln2260">        return spret::abort;</a>
<a name="ln2261">    }</a>
<a name="ln2262"> </a>
<a name="ln2263">    int mi = m-&gt;mindex();</a>
<a name="ln2264">    ASSERT(!invalid_monster_index(mi));</a>
<a name="ln2265"> </a>
<a name="ln2266">    if (stop_attack_prompt(m, false, you.pos()))</a>
<a name="ln2267">        return spret::abort;</a>
<a name="ln2268"> </a>
<a name="ln2269">    fail_check();</a>
<a name="ln2270"> </a>
<a name="ln2271">    bool friendly = true;</a>
<a name="ln2272">    int success = 0;</a>
<a name="ln2273">    int to_summon = stepdown_value(2 + (random2(pow) / 10) + (random2(pow) / 10),</a>
<a name="ln2274">                                   2, 2, 6, -1);</a>
<a name="ln2275"> </a>
<a name="ln2276">    while (to_summon--)</a>
<a name="ln2277">    {</a>
<a name="ln2278">        const monster_type mon = pick_random_wraith();</a>
<a name="ln2279"> </a>
<a name="ln2280">        if (monster *mons = create_monster(</a>
<a name="ln2281">                mgen_data(mon, BEH_FRIENDLY, where, mi, MG_FORCE_BEH)</a>
<a name="ln2282">                .set_summoned(&amp;you, 3, SPELL_HAUNT, god)))</a>
<a name="ln2283">        {</a>
<a name="ln2284">            success++;</a>
<a name="ln2285"> </a>
<a name="ln2286">            if (player_angers_monster(mons))</a>
<a name="ln2287">                friendly = false;</a>
<a name="ln2288">            else</a>
<a name="ln2289">            {</a>
<a name="ln2290">                mons-&gt;add_ench(mon_enchant(ENCH_HAUNTING, 1, m, INFINITE_DURATION));</a>
<a name="ln2291">                mons-&gt;foe = mi;</a>
<a name="ln2292">            }</a>
<a name="ln2293">        }</a>
<a name="ln2294">    }</a>
<a name="ln2295"> </a>
<a name="ln2296">    if (success &gt; 1)</a>
<a name="ln2297">    {</a>
<a name="ln2298">        mpr(friendly ? &quot;Insubstantial figures form in the air.&quot;</a>
<a name="ln2299">                     : &quot;You sense hostile presences.&quot;);</a>
<a name="ln2300">    }</a>
<a name="ln2301">    else if (success)</a>
<a name="ln2302">    {</a>
<a name="ln2303">        mpr(friendly ? &quot;An insubstantial figure forms in the air.&quot;</a>
<a name="ln2304">                     : &quot;You sense a hostile presence.&quot;);</a>
<a name="ln2305">    }</a>
<a name="ln2306">    else</a>
<a name="ln2307">    {</a>
<a name="ln2308">        canned_msg(MSG_NOTHING_HAPPENS);</a>
<a name="ln2309">        return spret::success;</a>
<a name="ln2310">    }</a>
<a name="ln2311"> </a>
<a name="ln2312">    return spret::success;</a>
<a name="ln2313">}</a>
<a name="ln2314"> </a>
<a name="ln2315"> </a>
<a name="ln2316"> </a>
<a name="ln2317">static spell_type servitor_spells[] =</a>
<a name="ln2318">{</a>
<a name="ln2319">    // primary spells</a>
<a name="ln2320">    SPELL_LEHUDIBS_CRYSTAL_SPEAR,</a>
<a name="ln2321">    SPELL_IOOD,</a>
<a name="ln2322">    SPELL_IRON_SHOT,</a>
<a name="ln2323">    SPELL_BOLT_OF_FIRE,</a>
<a name="ln2324">    SPELL_BOLT_OF_COLD,</a>
<a name="ln2325">    SPELL_POISON_ARROW,</a>
<a name="ln2326">    SPELL_CONJURE_BALL_LIGHTNING,</a>
<a name="ln2327">    SPELL_LIGHTNING_BOLT,</a>
<a name="ln2328">    SPELL_BOLT_OF_MAGMA,</a>
<a name="ln2329">    SPELL_BOLT_OF_DRAINING,</a>
<a name="ln2330">    SPELL_VENOM_BOLT,</a>
<a name="ln2331">    SPELL_FIREBALL,</a>
<a name="ln2332">    SPELL_THROW_ICICLE,</a>
<a name="ln2333">    SPELL_STONE_ARROW,</a>
<a name="ln2334">    SPELL_LRD,</a>
<a name="ln2335">    SPELL_AIRSTRIKE,</a>
<a name="ln2336">    SPELL_FORCE_LANCE,</a>
<a name="ln2337">    // secondary spells</a>
<a name="ln2338">    SPELL_FREEZING_CLOUD,</a>
<a name="ln2339">    SPELL_POISONOUS_CLOUD,</a>
<a name="ln2340">    SPELL_MEPHITIC_CLOUD,</a>
<a name="ln2341">    // fallback spells</a>
<a name="ln2342">    SPELL_STICKY_FLAME,</a>
<a name="ln2343">    SPELL_THROW_FLAME,</a>
<a name="ln2344">    SPELL_THROW_FROST,</a>
<a name="ln2345">    SPELL_FREEZE,</a>
<a name="ln2346">    SPELL_FLAME_TONGUE,</a>
<a name="ln2347">    SPELL_STING,</a>
<a name="ln2348">    SPELL_SANDBLAST,</a>
<a name="ln2349">    SPELL_MAGIC_DART,</a>
<a name="ln2350">};</a>
<a name="ln2351"> </a>
<a name="ln2352">/**</a>
<a name="ln2353"> * Return the spell a player spellforged servitor would use, for the spell</a>
<a name="ln2354"> * description.</a>
<a name="ln2355"> *</a>
<a name="ln2356"> * @return spell_type  The spell a player servitor would use if cast now</a>
<a name="ln2357"> */</a>
<a name="ln2358">spell_type player_servitor_spell()</a>
<a name="ln2359">{</a>
<a name="ln2360">    for (const spell_type spell : servitor_spells)</a>
<a name="ln2361">        if (you.has_spell(spell) &amp;&amp; raw_spell_fail(spell) &lt; 50)</a>
<a name="ln2362">            return spell;</a>
<a name="ln2363">    return SPELL_NO_SPELL;</a>
<a name="ln2364">}</a>
<a name="ln2365"> </a>
<a name="ln2366">/**</a>
<a name="ln2367"> * Initialize the given spellforged servitor's HD and spellset, based on the</a>
<a name="ln2368"> * caster's spellpower and castable attack spells.</a>
<a name="ln2369"> *</a>
<a name="ln2370"> * @param mon       The spellforged servitor to be initialized.</a>
<a name="ln2371"> * @param caster    The entity summoning the servitor; may be the player.</a>
<a name="ln2372"> */</a>
<a name="ln2373">static void _init_servitor_monster(monster &amp;mon, const actor&amp; caster)</a>
<a name="ln2374">{</a>
<a name="ln2375">    const monster* caster_mon = caster.as_monster();</a>
<a name="ln2376">    const int pow = caster_mon ?</a>
<a name="ln2377">                        6 * caster_mon-&gt;spell_hd(SPELL_SPELLFORGED_SERVITOR) :</a>
<a name="ln2378">                        calc_spell_power(SPELL_SPELLFORGED_SERVITOR, true);</a>
<a name="ln2379"> </a>
<a name="ln2380">    mon.set_hit_dice(9 + div_rand_round(pow, 14));</a>
<a name="ln2381">    mon.max_hit_points = mon.hit_points = 60 + roll_dice(7, 5); // 67-95</a>
<a name="ln2382">                                            // mhp doesn't vary with HD</a>
<a name="ln2383">    int spell_levels = 0;</a>
<a name="ln2384"> </a>
<a name="ln2385">    for (const spell_type spell : servitor_spells)</a>
<a name="ln2386">    {</a>
<a name="ln2387">        if (caster.has_spell(spell)</a>
<a name="ln2388">            &amp;&amp; (caster_mon || raw_spell_fail(spell) &lt; 50))</a>
<a name="ln2389">        {</a>
<a name="ln2390">            mon.spells.emplace_back(spell, 0, MON_SPELL_WIZARD);</a>
<a name="ln2391">            spell_levels += spell_difficulty(spell);</a>
<a name="ln2392"> </a>
<a name="ln2393">            // Player servitors take a single spell</a>
<a name="ln2394">            if (!caster_mon)</a>
<a name="ln2395">                break;</a>
<a name="ln2396">        }</a>
<a name="ln2397">    }</a>
<a name="ln2398"> </a>
<a name="ln2399">    // Fix up frequencies now that we know the total number of spell levels.</a>
<a name="ln2400">    const int base_freq = caster_mon ? 67 : 150;</a>
<a name="ln2401">    for (auto&amp; slot : mon.spells)</a>
<a name="ln2402">    {</a>
<a name="ln2403">        slot.freq = max(1, div_rand_round(spell_difficulty(slot.spell)</a>
<a name="ln2404">                                          * base_freq,</a>
<a name="ln2405">                                          spell_levels));</a>
<a name="ln2406">    }</a>
<a name="ln2407">    mon.props[CUSTOM_SPELLS_KEY].get_bool() = true;</a>
<a name="ln2408">}</a>
<a name="ln2409"> </a>
<a name="ln2410">void init_servitor(monster* servitor, actor* caster)</a>
<a name="ln2411">{</a>
<a name="ln2412">    ASSERT(servitor); // XXX: change to monster &amp;servitor</a>
<a name="ln2413">    ASSERT(caster); // XXX: change to actor &amp;caster</a>
<a name="ln2414">    _init_servitor_monster(*servitor, *caster);</a>
<a name="ln2415"> </a>
<a name="ln2416">    if (you.can_see(*caster))</a>
<a name="ln2417">    {</a>
<a name="ln2418">        mprf(&quot;%s %s a servant imbued with %s destructive magic!&quot;,</a>
<a name="ln2419">             caster-&gt;name(DESC_THE).c_str(),</a>
<a name="ln2420">             caster-&gt;conj_verb(&quot;summon&quot;).c_str(),</a>
<a name="ln2421">             caster-&gt;pronoun(PRONOUN_POSSESSIVE).c_str());</a>
<a name="ln2422">    }</a>
<a name="ln2423">    else</a>
<a name="ln2424">        simple_monster_message(*servitor, &quot; appears!&quot;);</a>
<a name="ln2425"> </a>
<a name="ln2426">    int shortest_range = LOS_RADIUS + 1;</a>
<a name="ln2427">    for (const mon_spell_slot &amp;slot : servitor-&gt;spells)</a>
<a name="ln2428">    {</a>
<a name="ln2429">        if (slot.spell == SPELL_NO_SPELL)</a>
<a name="ln2430">            continue;</a>
<a name="ln2431"> </a>
<a name="ln2432">        int range = spell_range(slot.spell, 100, false);</a>
<a name="ln2433">        if (range &lt; shortest_range)</a>
<a name="ln2434">            shortest_range = range;</a>
<a name="ln2435">    }</a>
<a name="ln2436">    servitor-&gt;props[&quot;ideal_range&quot;].get_int() = shortest_range;</a>
<a name="ln2437">}</a>
<a name="ln2438"> </a>
<a name="ln2439">spret cast_spellforged_servitor(int /*pow*/, god_type god, bool fail)</a>
<a name="ln2440">{</a>
<a name="ln2441">    fail_check();</a>
<a name="ln2442"> </a>
<a name="ln2443">    mgen_data mdata = _pal_data(MONS_SPELLFORGED_SERVITOR, 4, god,</a>
<a name="ln2444">                                SPELL_SPELLFORGED_SERVITOR);</a>
<a name="ln2445"> </a>
<a name="ln2446">    if (monster* mon = create_monster(mdata))</a>
<a name="ln2447">        init_servitor(mon, &amp;you);</a>
<a name="ln2448">    else</a>
<a name="ln2449">        canned_msg(MSG_NOTHING_HAPPENS);</a>
<a name="ln2450"> </a>
<a name="ln2451">    return spret::success;</a>
<a name="ln2452">}</a>
<a name="ln2453"> </a>
<a name="ln2454">static int _abjuration(int pow, monster *mon)</a>
<a name="ln2455">{</a>
<a name="ln2456">    // Scale power into something comparable to summon lifetime.</a>
<a name="ln2457">    const int abjdur = pow * 12;</a>
<a name="ln2458"> </a>
<a name="ln2459">    // XXX: make this a prompt</a>
<a name="ln2460">    if (mon-&gt;wont_attack())</a>
<a name="ln2461">        return false;</a>
<a name="ln2462"> </a>
<a name="ln2463">    int duration;</a>
<a name="ln2464">    if (mon-&gt;is_summoned(&amp;duration))</a>
<a name="ln2465">    {</a>
<a name="ln2466">        int sockage = max(fuzz_value(abjdur, 60, 30), 40);</a>
<a name="ln2467">        dprf(&quot;%s abj: dur: %d, abj: %d&quot;,</a>
<a name="ln2468">             mon-&gt;name(DESC_PLAIN).c_str(), duration, sockage);</a>
<a name="ln2469"> </a>
<a name="ln2470">        bool shielded = false;</a>
<a name="ln2471">        // TSO and Trog's abjuration protection.</a>
<a name="ln2472">        if (mons_is_god_gift(*mon, GOD_SHINING_ONE))</a>
<a name="ln2473">        {</a>
<a name="ln2474">            sockage = sockage * (30 - mon-&gt;get_hit_dice()) / 45;</a>
<a name="ln2475">            if (sockage &lt; duration)</a>
<a name="ln2476">            {</a>
<a name="ln2477">                simple_god_message(&quot; protects a fellow warrior from your evil magic!&quot;,</a>
<a name="ln2478">                                   GOD_SHINING_ONE);</a>
<a name="ln2479">                shielded = true;</a>
<a name="ln2480">            }</a>
<a name="ln2481">        }</a>
<a name="ln2482">        else if (mons_is_god_gift(*mon, GOD_TROG))</a>
<a name="ln2483">        {</a>
<a name="ln2484">            sockage = sockage * 8 / 15;</a>
<a name="ln2485">            if (sockage &lt; duration)</a>
<a name="ln2486">            {</a>
<a name="ln2487">                simple_god_message(&quot; shields an ally from your puny magic!&quot;,</a>
<a name="ln2488">                                   GOD_TROG);</a>
<a name="ln2489">                shielded = true;</a>
<a name="ln2490">            }</a>
<a name="ln2491">        }</a>
<a name="ln2492"> </a>
<a name="ln2493">        mon_enchant abj = mon-&gt;get_ench(ENCH_ABJ);</a>
<a name="ln2494">        if (!mon-&gt;lose_ench_duration(abj, sockage) &amp;&amp; !shielded)</a>
<a name="ln2495">            simple_monster_message(*mon, &quot; shudders.&quot;);</a>
<a name="ln2496">    }</a>
<a name="ln2497"> </a>
<a name="ln2498">    return true;</a>
<a name="ln2499">}</a>
<a name="ln2500"> </a>
<a name="ln2501">spret cast_aura_of_abjuration(int pow, bool fail)</a>
<a name="ln2502">{</a>
<a name="ln2503">    fail_check();</a>
<a name="ln2504"> </a>
<a name="ln2505">    if (!you.duration[DUR_ABJURATION_AURA])</a>
<a name="ln2506">        mpr(&quot;You begin to abjure the creatures around you!&quot;);</a>
<a name="ln2507">    else</a>
<a name="ln2508">        mpr(&quot;You extend your aura of abjuration.&quot;);</a>
<a name="ln2509"> </a>
<a name="ln2510">    you.increase_duration(DUR_ABJURATION_AURA,  6 + roll_dice(2, pow / 12), 50);</a>
<a name="ln2511">    you.props[&quot;abj_aura_pow&quot;].get_int() = pow;</a>
<a name="ln2512"> </a>
<a name="ln2513">    return spret::success;</a>
<a name="ln2514">}</a>
<a name="ln2515"> </a>
<a name="ln2516">void do_aura_of_abjuration(int delay)</a>
<a name="ln2517">{</a>
<a name="ln2518">    const int pow = you.props[&quot;abj_aura_pow&quot;].get_int() * delay / 10;</a>
<a name="ln2519">    for (monster_near_iterator mi(you.pos(), LOS_NO_TRANS); mi; ++mi)</a>
<a name="ln2520">        _abjuration(pow / 2, *mi);</a>
<a name="ln2521">}</a>
<a name="ln2522"> </a>
<a name="ln2523">monster* find_battlesphere(const actor* agent)</a>
<a name="ln2524">{</a>
<a name="ln2525">    if (agent-&gt;props.exists(&quot;battlesphere&quot;))</a>
<a name="ln2526">        return monster_by_mid(agent-&gt;props[&quot;battlesphere&quot;].get_int());</a>
<a name="ln2527">    else</a>
<a name="ln2528">        return nullptr;</a>
<a name="ln2529">}</a>
<a name="ln2530"> </a>
<a name="ln2531">spret cast_battlesphere(actor* agent, int pow, god_type god, bool fail)</a>
<a name="ln2532">{</a>
<a name="ln2533">    fail_check();</a>
<a name="ln2534"> </a>
<a name="ln2535">    monster* battlesphere;</a>
<a name="ln2536">    if (agent-&gt;is_player() &amp;&amp; (battlesphere = find_battlesphere(&amp;you)))</a>
<a name="ln2537">    {</a>
<a name="ln2538">        bool recalled = false;</a>
<a name="ln2539">        if (!you.can_see(*battlesphere))</a>
<a name="ln2540">        {</a>
<a name="ln2541">            coord_def empty;</a>
<a name="ln2542">            if (find_habitable_spot_near(agent-&gt;pos(), MONS_BATTLESPHERE, 3, false, empty)</a>
<a name="ln2543">                &amp;&amp; battlesphere-&gt;move_to_pos(empty))</a>
<a name="ln2544">            {</a>
<a name="ln2545">                recalled = true;</a>
<a name="ln2546">            }</a>
<a name="ln2547">        }</a>
<a name="ln2548"> </a>
<a name="ln2549">        if (recalled)</a>
<a name="ln2550">        {</a>
<a name="ln2551">            mpr(&quot;You recall your battlesphere and imbue it with additional&quot;</a>
<a name="ln2552">                &quot; charge.&quot;);</a>
<a name="ln2553">        }</a>
<a name="ln2554">        else</a>
<a name="ln2555">            mpr(&quot;You imbue your battlesphere with additional charge.&quot;);</a>
<a name="ln2556"> </a>
<a name="ln2557">        battlesphere-&gt;battlecharge = min(20, (int) battlesphere-&gt;battlecharge</a>
<a name="ln2558">                                              + 4 + random2(pow + 10) / 10);</a>
<a name="ln2559"> </a>
<a name="ln2560">        // Increase duration</a>
<a name="ln2561">        mon_enchant abj = battlesphere-&gt;get_ench(ENCH_FAKE_ABJURATION);</a>
<a name="ln2562">        abj.duration = min(abj.duration + (7 + roll_dice(2, pow)) * 10, 500);</a>
<a name="ln2563">        battlesphere-&gt;update_ench(abj);</a>
<a name="ln2564">    }</a>
<a name="ln2565">    else</a>
<a name="ln2566">    {</a>
<a name="ln2567">        ASSERT(!find_battlesphere(agent));</a>
<a name="ln2568">        mgen_data mg (MONS_BATTLESPHERE,</a>
<a name="ln2569">                      agent-&gt;is_player() ? BEH_FRIENDLY</a>
<a name="ln2570">                                         : SAME_ATTITUDE(agent-&gt;as_monster()),</a>
<a name="ln2571">                      agent-&gt;pos(), agent-&gt;mindex());</a>
<a name="ln2572">        mg.set_summoned(agent, 0, SPELL_BATTLESPHERE, god);</a>
<a name="ln2573">        mg.hd = 1 + div_rand_round(pow, 11);</a>
<a name="ln2574">        battlesphere = create_monster(mg);</a>
<a name="ln2575"> </a>
<a name="ln2576">        if (battlesphere)</a>
<a name="ln2577">        {</a>
<a name="ln2578">            int dur = min((7 + roll_dice(2, pow)) * 10, 500);</a>
<a name="ln2579">            battlesphere-&gt;add_ench(mon_enchant(ENCH_FAKE_ABJURATION, 1, 0, dur));</a>
<a name="ln2580">            battlesphere-&gt;summoner = agent-&gt;mid;</a>
<a name="ln2581">            agent-&gt;props[&quot;battlesphere&quot;].get_int() = battlesphere-&gt;mid;</a>
<a name="ln2582"> </a>
<a name="ln2583">            if (agent-&gt;is_player())</a>
<a name="ln2584">                mpr(&quot;You conjure a globe of magical energy.&quot;);</a>
<a name="ln2585">            else</a>
<a name="ln2586">            {</a>
<a name="ln2587">                if (you.can_see(*agent) &amp;&amp; you.can_see(*battlesphere))</a>
<a name="ln2588">                {</a>
<a name="ln2589">                    simple_monster_message(*agent-&gt;as_monster(),</a>
<a name="ln2590">                                           &quot; conjures a globe of magical energy!&quot;);</a>
<a name="ln2591">                }</a>
<a name="ln2592">                else if (you.can_see(*battlesphere))</a>
<a name="ln2593">                    simple_monster_message(*battlesphere, &quot; appears!&quot;);</a>
<a name="ln2594">                battlesphere-&gt;props[&quot;band_leader&quot;].get_int() = agent-&gt;mid;</a>
<a name="ln2595">            }</a>
<a name="ln2596">            battlesphere-&gt;battlecharge = 4 + random2(pow + 10) / 10;</a>
<a name="ln2597">            battlesphere-&gt;foe = agent-&gt;mindex();</a>
<a name="ln2598">            battlesphere-&gt;target = agent-&gt;pos();</a>
<a name="ln2599">        }</a>
<a name="ln2600">        else if (agent-&gt;is_player() || you.can_see(*agent))</a>
<a name="ln2601">            canned_msg(MSG_NOTHING_HAPPENS);</a>
<a name="ln2602">    }</a>
<a name="ln2603"> </a>
<a name="ln2604">    return spret::success;</a>
<a name="ln2605">}</a>
<a name="ln2606"> </a>
<a name="ln2607">void end_battlesphere(monster* mons, bool killed)</a>
<a name="ln2608">{</a>
<a name="ln2609">    // Should only happen if you dismiss it in wizard mode, I think</a>
<a name="ln2610">    if (!mons)</a>
<a name="ln2611">        return;</a>
<a name="ln2612"> </a>
<a name="ln2613">    actor* agent = actor_by_mid(mons-&gt;summoner);</a>
<a name="ln2614">    if (agent)</a>
<a name="ln2615">        agent-&gt;props.erase(&quot;battlesphere&quot;);</a>
<a name="ln2616"> </a>
<a name="ln2617">    if (!killed)</a>
<a name="ln2618">    {</a>
<a name="ln2619">        if (agent &amp;&amp; agent-&gt;is_player())</a>
<a name="ln2620">        {</a>
<a name="ln2621">            if (you.can_see(*mons))</a>
<a name="ln2622">            {</a>
<a name="ln2623">                if (mons-&gt;battlecharge == 0)</a>
<a name="ln2624">                {</a>
<a name="ln2625">                    mpr(&quot;Your battlesphere expends the last of its energy&quot;</a>
<a name="ln2626">                        &quot; and dissipates.&quot;);</a>
<a name="ln2627">                }</a>
<a name="ln2628">                else</a>
<a name="ln2629">                    mpr(&quot;Your battlesphere wavers and loses cohesion.&quot;);</a>
<a name="ln2630">            }</a>
<a name="ln2631">            else</a>
<a name="ln2632">                mpr(&quot;You feel your bond with your battlesphere wane.&quot;);</a>
<a name="ln2633">        }</a>
<a name="ln2634">        else if (you.can_see(*mons))</a>
<a name="ln2635">            simple_monster_message(*mons, &quot; dissipates.&quot;);</a>
<a name="ln2636"> </a>
<a name="ln2637">        if (!cell_is_solid(mons-&gt;pos()))</a>
<a name="ln2638">            place_cloud(CLOUD_MAGIC_TRAIL, mons-&gt;pos(), 3 + random2(3), mons);</a>
<a name="ln2639"> </a>
<a name="ln2640">        monster_die(*mons, KILL_RESET, NON_MONSTER);</a>
<a name="ln2641">    }</a>
<a name="ln2642">}</a>
<a name="ln2643"> </a>
<a name="ln2644">bool battlesphere_can_mirror(spell_type spell)</a>
<a name="ln2645">{</a>
<a name="ln2646">    return (spell_typematch(spell, spschool::conjuration)</a>
<a name="ln2647">           &amp;&amp; spell_to_zap(spell) != NUM_ZAPS)</a>
<a name="ln2648">           || spell == SPELL_FREEZE</a>
<a name="ln2649">           || spell == SPELL_STICKY_FLAME</a>
<a name="ln2650">           || spell == SPELL_SANDBLAST</a>
<a name="ln2651">           || spell == SPELL_AIRSTRIKE</a>
<a name="ln2652">           || spell == SPELL_SEARING_RAY;</a>
<a name="ln2653">}</a>
<a name="ln2654"> </a>
<a name="ln2655">bool aim_battlesphere(actor* agent, spell_type spell, int powc, bolt&amp; beam)</a>
<a name="ln2656">{</a>
<a name="ln2657">    //Is this spell something that will trigger the battlesphere?</a>
<a name="ln2658">    if (battlesphere_can_mirror(spell))</a>
<a name="ln2659">    {</a>
<a name="ln2660">        monster* battlesphere = find_battlesphere(agent);</a>
<a name="ln2661"> </a>
<a name="ln2662">        // If we've somehow gotten separated from the battlesphere (ie:</a>
<a name="ln2663">        // abyss level teleport), bail out and cancel the battlesphere bond</a>
<a name="ln2664">        if (!battlesphere)</a>
<a name="ln2665">        {</a>
<a name="ln2666">            agent-&gt;props.erase(&quot;battlesphere&quot;);</a>
<a name="ln2667">            return false;</a>
<a name="ln2668">        }</a>
<a name="ln2669"> </a>
<a name="ln2670">        // In case the battlesphere was in the middle of a (failed)</a>
<a name="ln2671">        // target-seeking action, cancel it so that it can focus on a new</a>
<a name="ln2672">        // target</a>
<a name="ln2673">        reset_battlesphere(battlesphere);</a>
<a name="ln2674"> </a>
<a name="ln2675">        // Don't try to fire at ourselves</a>
<a name="ln2676">        if (beam.target == battlesphere-&gt;pos())</a>
<a name="ln2677">            return false;</a>
<a name="ln2678"> </a>
<a name="ln2679">        // If the player beam is targeted at a creature, aim at this creature.</a>
<a name="ln2680">        // Otherwise, aim at the furthest creature in the player beam path</a>
<a name="ln2681">        bolt testbeam = beam;</a>
<a name="ln2682"> </a>
<a name="ln2683">        if (agent-&gt;is_player())</a>
<a name="ln2684">            testbeam.thrower = KILL_YOU_MISSILE;</a>
<a name="ln2685">        else</a>
<a name="ln2686">        {</a>
<a name="ln2687">            testbeam.thrower = KILL_MON_MISSILE;</a>
<a name="ln2688">            testbeam.source_id = agent-&gt;mid;</a>
<a name="ln2689">        }</a>
<a name="ln2690"> </a>
<a name="ln2691">        testbeam.is_tracer = true;</a>
<a name="ln2692">        zap_type ztype = spell_to_zap(spell);</a>
<a name="ln2693"> </a>
<a name="ln2694">        // Fallback for non-standard spell zaps</a>
<a name="ln2695">        if (ztype == NUM_ZAPS)</a>
<a name="ln2696">            ztype = ZAP_MAGIC_DART;</a>
<a name="ln2697"> </a>
<a name="ln2698">        // This is so that reflection and pathing rules for the parent beam</a>
<a name="ln2699">        // will be obeyed when figuring out what is being aimed at</a>
<a name="ln2700">        zappy(ztype, powc, false, testbeam);</a>
<a name="ln2701"> </a>
<a name="ln2702">        battlesphere-&gt;props[&quot;firing_target&quot;] = beam.target;</a>
<a name="ln2703">        battlesphere-&gt;props.erase(&quot;foe&quot;);</a>
<a name="ln2704">        if (!actor_at(beam.target))</a>
<a name="ln2705">        {</a>
<a name="ln2706">            testbeam.fire();</a>
<a name="ln2707"> </a>
<a name="ln2708">            for (const coord_def c : testbeam.path_taken)</a>
<a name="ln2709">            {</a>
<a name="ln2710">                if (c != battlesphere-&gt;pos() &amp;&amp; monster_at(c))</a>
<a name="ln2711">                {</a>
<a name="ln2712">                    battlesphere-&gt;props[&quot;firing_target&quot;] = c;</a>
<a name="ln2713">                    battlesphere-&gt;foe = actor_at(c)-&gt;mindex();</a>
<a name="ln2714">                    battlesphere-&gt;props[&quot;foe&quot;] = battlesphere-&gt;foe;</a>
<a name="ln2715">                    break;</a>
<a name="ln2716">                }</a>
<a name="ln2717">            }</a>
<a name="ln2718"> </a>
<a name="ln2719">            // If we're firing at empty air, lose any prior target lock</a>
<a name="ln2720">            if (!battlesphere-&gt;props.exists(&quot;foe&quot;))</a>
<a name="ln2721">                battlesphere-&gt;foe = agent-&gt;mindex();</a>
<a name="ln2722">        }</a>
<a name="ln2723">        else</a>
<a name="ln2724">        {</a>
<a name="ln2725">            battlesphere-&gt;foe = actor_at(beam.target)-&gt;mindex();</a>
<a name="ln2726">            battlesphere-&gt;props[&quot;foe&quot;] = battlesphere-&gt;foe;</a>
<a name="ln2727">        }</a>
<a name="ln2728"> </a>
<a name="ln2729">        battlesphere-&gt;props[&quot;ready&quot;] = true;</a>
<a name="ln2730"> </a>
<a name="ln2731">        return true;</a>
<a name="ln2732">    }</a>
<a name="ln2733"> </a>
<a name="ln2734">    return false;</a>
<a name="ln2735">}</a>
<a name="ln2736"> </a>
<a name="ln2737">bool trigger_battlesphere(actor* agent, bolt&amp; beam)</a>
<a name="ln2738">{</a>
<a name="ln2739">    monster* battlesphere = find_battlesphere(agent);</a>
<a name="ln2740">    if (!battlesphere)</a>
<a name="ln2741">        return false;</a>
<a name="ln2742"> </a>
<a name="ln2743">    if (battlesphere-&gt;props.exists(&quot;ready&quot;))</a>
<a name="ln2744">    {</a>
<a name="ln2745">        // If the battlesphere is aiming at empty air but the triggering</a>
<a name="ln2746">        // conjuration is an explosion, try to find something to shoot within</a>
<a name="ln2747">        // the blast</a>
<a name="ln2748">        if (!battlesphere-&gt;props.exists(&quot;foe&quot;) &amp;&amp; beam.is_explosion)</a>
<a name="ln2749">        {</a>
<a name="ln2750">            explosion_map exp_map;</a>
<a name="ln2751">            exp_map.init(INT_MAX);</a>
<a name="ln2752">            beam.determine_affected_cells(exp_map, coord_def(), 0,</a>
<a name="ln2753">                                          beam.ex_size, true, true);</a>
<a name="ln2754"> </a>
<a name="ln2755">            for (radius_iterator ri(beam.target, beam.ex_size, C_SQUARE);</a>
<a name="ln2756">                 ri; ++ri)</a>
<a name="ln2757">            {</a>
<a name="ln2758">                if (exp_map(*ri - beam.target + coord_def(9,9)) &lt; INT_MAX)</a>
<a name="ln2759">                {</a>
<a name="ln2760">                    const actor *targ = actor_at(*ri);</a>
<a name="ln2761">                    if (targ &amp;&amp; targ != battlesphere)</a>
<a name="ln2762">                    {</a>
<a name="ln2763">                        battlesphere-&gt;props[&quot;firing_target&quot;] = *ri;</a>
<a name="ln2764">                        battlesphere-&gt;foe = targ-&gt;mindex();</a>
<a name="ln2765">                        battlesphere-&gt;props[&quot;foe&quot;] = battlesphere-&gt;foe;</a>
<a name="ln2766">                        continue;</a>
<a name="ln2767">                    }</a>
<a name="ln2768">                }</a>
<a name="ln2769">            }</a>
<a name="ln2770">        }</a>
<a name="ln2771"> </a>
<a name="ln2772">        battlesphere-&gt;props.erase(&quot;ready&quot;);</a>
<a name="ln2773">        battlesphere-&gt;props[&quot;firing&quot;] = true;</a>
<a name="ln2774"> </a>
<a name="ln2775">        // Since monsters may be acting out of sequence, give the battlesphere</a>
<a name="ln2776">        // enough energy to attempt to fire this round, and requeue if it's</a>
<a name="ln2777">        // already passed its turn</a>
<a name="ln2778">        if (agent-&gt;is_monster())</a>
<a name="ln2779">        {</a>
<a name="ln2780">            battlesphere-&gt;speed_increment = 100;</a>
<a name="ln2781">            queue_monster_for_action(battlesphere);</a>
<a name="ln2782">        }</a>
<a name="ln2783"> </a>
<a name="ln2784">        return true;</a>
<a name="ln2785">    }</a>
<a name="ln2786"> </a>
<a name="ln2787">    return false;</a>
<a name="ln2788">}</a>
<a name="ln2789"> </a>
<a name="ln2790">// Called at the start of each round. Cancels firing orders given in the</a>
<a name="ln2791">// previous round, if the battlesphere was not able to execute them fully</a>
<a name="ln2792">// before the next player action</a>
<a name="ln2793">void reset_battlesphere(monster* mons)</a>
<a name="ln2794">{</a>
<a name="ln2795">    if (!mons || mons-&gt;type != MONS_BATTLESPHERE)</a>
<a name="ln2796">        return;</a>
<a name="ln2797"> </a>
<a name="ln2798">    mons-&gt;props.erase(&quot;ready&quot;);</a>
<a name="ln2799"> </a>
<a name="ln2800">    if (mons-&gt;props.exists(&quot;tracking&quot;))</a>
<a name="ln2801">    {</a>
<a name="ln2802">        mons-&gt;props.erase(&quot;tracking&quot;);</a>
<a name="ln2803">        mons-&gt;props.erase(&quot;firing&quot;);</a>
<a name="ln2804">        if (mons-&gt;props.exists(&quot;foe&quot;))</a>
<a name="ln2805">            mons-&gt;foe = mons-&gt;props[&quot;foe&quot;].get_int();</a>
<a name="ln2806">        mons-&gt;behaviour = BEH_SEEK;</a>
<a name="ln2807">    }</a>
<a name="ln2808">}</a>
<a name="ln2809"> </a>
<a name="ln2810">bool fire_battlesphere(monster* mons)</a>
<a name="ln2811">{</a>
<a name="ln2812">    if (!mons || mons-&gt;type != MONS_BATTLESPHERE)</a>
<a name="ln2813">        return false;</a>
<a name="ln2814"> </a>
<a name="ln2815">    actor* agent = actor_by_mid(mons-&gt;summoner);</a>
<a name="ln2816"> </a>
<a name="ln2817">    if (!agent || !agent-&gt;alive())</a>
<a name="ln2818">    {</a>
<a name="ln2819">        end_battlesphere(mons, false);</a>
<a name="ln2820">        return false;</a>
<a name="ln2821">    }</a>
<a name="ln2822"> </a>
<a name="ln2823">    bool used = false;</a>
<a name="ln2824"> </a>
<a name="ln2825">    if (mons-&gt;props.exists(&quot;firing&quot;) &amp;&amp; mons-&gt;battlecharge &gt; 0)</a>
<a name="ln2826">    {</a>
<a name="ln2827">        if (mons-&gt;props.exists(&quot;tracking&quot;))</a>
<a name="ln2828">        {</a>
<a name="ln2829">            if (mons-&gt;pos() == mons-&gt;props[&quot;tracking_target&quot;].get_coord())</a>
<a name="ln2830">            {</a>
<a name="ln2831">                mons-&gt;props.erase(&quot;tracking&quot;);</a>
<a name="ln2832">                if (mons-&gt;props.exists(&quot;foe&quot;))</a>
<a name="ln2833">                    mons-&gt;foe = mons-&gt;props[&quot;foe&quot;].get_int();</a>
<a name="ln2834">                mons-&gt;behaviour = BEH_SEEK;</a>
<a name="ln2835">            }</a>
<a name="ln2836">            else // Currently tracking, but have not reached target pos</a>
<a name="ln2837">            {</a>
<a name="ln2838">                mons-&gt;target = mons-&gt;props[&quot;tracking_target&quot;].get_coord();</a>
<a name="ln2839">                return false;</a>
<a name="ln2840">            }</a>
<a name="ln2841">        }</a>
<a name="ln2842">        else</a>
<a name="ln2843">        {</a>
<a name="ln2844">            // If the battlesphere forgot its foe (due to being out of los),</a>
<a name="ln2845">            // remind it</a>
<a name="ln2846">            if (mons-&gt;props.exists(&quot;foe&quot;))</a>
<a name="ln2847">                mons-&gt;foe = mons-&gt;props[&quot;foe&quot;].get_int();</a>
<a name="ln2848">        }</a>
<a name="ln2849"> </a>
<a name="ln2850">        // Set up the beam.</a>
<a name="ln2851">        bolt beam;</a>
<a name="ln2852">        beam.source_name = &quot;battlesphere&quot;;</a>
<a name="ln2853"> </a>
<a name="ln2854">        // If we are locked onto a foe, use its current position</a>
<a name="ln2855">        if (!invalid_monster_index(mons-&gt;foe) &amp;&amp; menv[mons-&gt;foe].alive())</a>
<a name="ln2856">            beam.target = menv[mons-&gt;foe].pos();</a>
<a name="ln2857">        else</a>
<a name="ln2858">            beam.target = mons-&gt;props[&quot;firing_target&quot;].get_coord();</a>
<a name="ln2859"> </a>
<a name="ln2860">        // Sanity check: if we have somehow ended up targeting ourselves, bail</a>
<a name="ln2861">        if (beam.target == mons-&gt;pos())</a>
<a name="ln2862">        {</a>
<a name="ln2863">            mprf(MSGCH_ERROR, &quot;Battlesphere targeting itself? Fixing.&quot;);</a>
<a name="ln2864">            mons-&gt;props.erase(&quot;firing&quot;);</a>
<a name="ln2865">            mons-&gt;props.erase(&quot;firing_target&quot;);</a>
<a name="ln2866">            mons-&gt;props.erase(&quot;foe&quot;);</a>
<a name="ln2867">            return false;</a>
<a name="ln2868">        }</a>
<a name="ln2869"> </a>
<a name="ln2870">        beam.name       = &quot;barrage of energy&quot;;</a>
<a name="ln2871">        beam.range      = LOS_RADIUS;</a>
<a name="ln2872">        beam.hit        = AUTOMATIC_HIT;</a>
<a name="ln2873">        beam.damage     = dice_def(2, 5 + mons-&gt;get_hit_dice());</a>
<a name="ln2874">        beam.glyph      = dchar_glyph(DCHAR_FIRED_ZAP);</a>
<a name="ln2875">        beam.colour     = MAGENTA;</a>
<a name="ln2876">        beam.flavour    = BEAM_MMISSILE;</a>
<a name="ln2877">        beam.pierce     = false;</a>
<a name="ln2878"> </a>
<a name="ln2879">        // Fire tracer.</a>
<a name="ln2880">        fire_tracer(mons, beam);</a>
<a name="ln2881"> </a>
<a name="ln2882">        // Never fire if we would hurt the caster, and ensure that the beam</a>
<a name="ln2883">        // would hit at least SOMETHING, unless it was targeted at empty space</a>
<a name="ln2884">        // in the first place</a>
<a name="ln2885">        if (beam.friend_info.count == 0</a>
<a name="ln2886">            &amp;&amp; (monster_at(beam.target) ? beam.foe_info.count &gt; 0 :</a>
<a name="ln2887">                find(beam.path_taken.begin(), beam.path_taken.end(),</a>
<a name="ln2888">                     beam.target)</a>
<a name="ln2889">                    != beam.path_taken.end()))</a>
<a name="ln2890">        {</a>
<a name="ln2891">            beam.thrower = (agent-&gt;is_player()) ? KILL_YOU : KILL_MON;</a>
<a name="ln2892">            simple_monster_message(*mons, &quot; fires!&quot;);</a>
<a name="ln2893">            beam.fire();</a>
<a name="ln2894"> </a>
<a name="ln2895">            used = true;</a>
<a name="ln2896">            // Decrement # of volleys left and possibly expire the battlesphere.</a>
<a name="ln2897">            if (--mons-&gt;battlecharge == 0)</a>
<a name="ln2898">                end_battlesphere(mons, false);</a>
<a name="ln2899"> </a>
<a name="ln2900">            mons-&gt;props.erase(&quot;firing&quot;);</a>
<a name="ln2901">        }</a>
<a name="ln2902">        // If we are firing at something, try to find a nearby position</a>
<a name="ln2903">        // from which we could safely fire at it</a>
<a name="ln2904">        else</a>
<a name="ln2905">        {</a>
<a name="ln2906">            const bool empty_beam = (beam.foe_info.count == 0);</a>
<a name="ln2907">            for (distance_iterator di(mons-&gt;pos(), true, true, 2); di; ++di)</a>
<a name="ln2908">            {</a>
<a name="ln2909">                if (*di == beam.target || actor_at(*di)</a>
<a name="ln2910">                    || cell_is_solid(*di)</a>
<a name="ln2911">                    || !agent-&gt;see_cell(*di))</a>
<a name="ln2912">                {</a>
<a name="ln2913">                    continue;</a>
<a name="ln2914">                }</a>
<a name="ln2915"> </a>
<a name="ln2916">                beam.source = *di;</a>
<a name="ln2917">                beam.is_tracer = true;</a>
<a name="ln2918">                beam.friend_info.reset();</a>
<a name="ln2919">                beam.foe_info.reset();</a>
<a name="ln2920">                beam.fire();</a>
<a name="ln2921">                if (beam.friend_info.count == 0</a>
<a name="ln2922">                    &amp;&amp; (beam.foe_info.count &gt; 0 || empty_beam))</a>
<a name="ln2923">                {</a>
<a name="ln2924">                    if (empty_beam</a>
<a name="ln2925">                        &amp;&amp; find(beam.path_taken.begin(), beam.path_taken.end(),</a>
<a name="ln2926">                                beam.target) == beam.path_taken.end())</a>
<a name="ln2927">                    {</a>
<a name="ln2928">                        continue;</a>
<a name="ln2929">                    }</a>
<a name="ln2930"> </a>
<a name="ln2931">                    mons-&gt;firing_pos = coord_def(0, 0);</a>
<a name="ln2932">                    mons-&gt;target = *di;</a>
<a name="ln2933">                    mons-&gt;behaviour = BEH_WANDER;</a>
<a name="ln2934">                    mons-&gt;props[&quot;foe&quot;] = mons-&gt;foe;</a>
<a name="ln2935">                    mons-&gt;props[&quot;tracking&quot;] = true;</a>
<a name="ln2936">                    mons-&gt;foe = MHITNOT;</a>
<a name="ln2937">                    mons-&gt;props[&quot;tracking_target&quot;] = *di;</a>
<a name="ln2938">                    break;</a>
<a name="ln2939">                }</a>
<a name="ln2940">            }</a>
<a name="ln2941"> </a>
<a name="ln2942">            // If we didn't find a better firing position nearby, cancel firing</a>
<a name="ln2943">            if (!mons-&gt;props.exists(&quot;tracking&quot;))</a>
<a name="ln2944">                mons-&gt;props.erase(&quot;firing&quot;);</a>
<a name="ln2945">        }</a>
<a name="ln2946">    }</a>
<a name="ln2947"> </a>
<a name="ln2948">    // If our last target is dead, or the player wandered off, resume</a>
<a name="ln2949">    // following the player</a>
<a name="ln2950">    if ((mons-&gt;foe == MHITNOT || !mons-&gt;can_see(*agent)</a>
<a name="ln2951">         || (!invalid_monster_index(mons-&gt;foe)</a>
<a name="ln2952">             &amp;&amp; !agent-&gt;can_see(menv[mons-&gt;foe])))</a>
<a name="ln2953">        &amp;&amp; !mons-&gt;props.exists(&quot;tracking&quot;))</a>
<a name="ln2954">    {</a>
<a name="ln2955">        mons-&gt;foe = agent-&gt;mindex();</a>
<a name="ln2956">    }</a>
<a name="ln2957"> </a>
<a name="ln2958">    return used;</a>
<a name="ln2959">}</a>
<a name="ln2960"> </a>
<a name="ln2961">spret cast_fulminating_prism(actor* caster, int pow,</a>
<a name="ln2962">                                  const coord_def&amp; where, bool fail)</a>
<a name="ln2963">{</a>
<a name="ln2964">    if (grid_distance(where, caster-&gt;pos())</a>
<a name="ln2965">        &gt; spell_range(SPELL_FULMINANT_PRISM, pow))</a>
<a name="ln2966">    {</a>
<a name="ln2967">        if (caster-&gt;is_player())</a>
<a name="ln2968">            mpr(&quot;That's too far away.&quot;);</a>
<a name="ln2969">        return spret::abort;</a>
<a name="ln2970">    }</a>
<a name="ln2971"> </a>
<a name="ln2972">    if (cell_is_solid(where))</a>
<a name="ln2973">    {</a>
<a name="ln2974">        if (caster-&gt;is_player())</a>
<a name="ln2975">            mpr(&quot;You can't conjure that within a solid object!&quot;);</a>
<a name="ln2976">        return spret::abort;</a>
<a name="ln2977">    }</a>
<a name="ln2978"> </a>
<a name="ln2979">    actor* victim = monster_at(where);</a>
<a name="ln2980">    if (victim)</a>
<a name="ln2981">    {</a>
<a name="ln2982">        if (caster-&gt;can_see(*victim))</a>
<a name="ln2983">        {</a>
<a name="ln2984">            if (caster-&gt;is_player())</a>
<a name="ln2985">                mpr(&quot;You can't place the prism on a creature.&quot;);</a>
<a name="ln2986">            return spret::abort;</a>
<a name="ln2987">        }</a>
<a name="ln2988"> </a>
<a name="ln2989">        fail_check();</a>
<a name="ln2990"> </a>
<a name="ln2991">        // FIXME: maybe should do _paranoid_option_disable() here?</a>
<a name="ln2992">        if (caster-&gt;is_player()</a>
<a name="ln2993">            || (you.can_see(*caster) &amp;&amp; you.see_cell(where)))</a>
<a name="ln2994">        {</a>
<a name="ln2995">            if (you.can_see(*victim))</a>
<a name="ln2996">            {</a>
<a name="ln2997">                mprf(&quot;%s %s.&quot;, victim-&gt;name(DESC_THE).c_str(),</a>
<a name="ln2998">                               victim-&gt;conj_verb(&quot;twitch&quot;).c_str());</a>
<a name="ln2999">            }</a>
<a name="ln3000">            else</a>
<a name="ln3001">                canned_msg(MSG_GHOSTLY_OUTLINE);</a>
<a name="ln3002">        }</a>
<a name="ln3003">        return spret::success;      // Don't give free detection!</a>
<a name="ln3004">    }</a>
<a name="ln3005"> </a>
<a name="ln3006">    fail_check();</a>
<a name="ln3007"> </a>
<a name="ln3008">    int hd = div_rand_round(pow, 10);</a>
<a name="ln3009"> </a>
<a name="ln3010">    mgen_data prism_data = mgen_data(MONS_FULMINANT_PRISM,</a>
<a name="ln3011">                                     caster-&gt;is_player()</a>
<a name="ln3012">                                     ? BEH_FRIENDLY</a>
<a name="ln3013">                                     : SAME_ATTITUDE(caster-&gt;as_monster()),</a>
<a name="ln3014">                                     where, MHITNOT, MG_FORCE_PLACE);</a>
<a name="ln3015">    prism_data.set_summoned(caster, 0, SPELL_FULMINANT_PRISM);</a>
<a name="ln3016">    prism_data.hd = hd;</a>
<a name="ln3017">    monster *prism = create_monster(prism_data);</a>
<a name="ln3018"> </a>
<a name="ln3019">    if (prism)</a>
<a name="ln3020">    {</a>
<a name="ln3021">        if (caster-&gt;observable())</a>
<a name="ln3022">        {</a>
<a name="ln3023">            mprf(&quot;%s %s a prism of explosive energy!&quot;,</a>
<a name="ln3024">                 caster-&gt;name(DESC_THE).c_str(),</a>
<a name="ln3025">                 caster-&gt;conj_verb(&quot;conjure&quot;).c_str());</a>
<a name="ln3026">        }</a>
<a name="ln3027">        else if (you.can_see(*prism))</a>
<a name="ln3028">            mprf(&quot;A prism of explosive energy appears from nowhere!&quot;);</a>
<a name="ln3029">    }</a>
<a name="ln3030">    else if (you.can_see(*caster))</a>
<a name="ln3031">        canned_msg(MSG_NOTHING_HAPPENS);</a>
<a name="ln3032"> </a>
<a name="ln3033">    return spret::success;</a>
<a name="ln3034">}</a>
<a name="ln3035"> </a>
<a name="ln3036">monster* find_spectral_weapon(const actor* agent)</a>
<a name="ln3037">{</a>
<a name="ln3038">    if (agent-&gt;props.exists(&quot;spectral_weapon&quot;))</a>
<a name="ln3039">        return monster_by_mid(agent-&gt;props[&quot;spectral_weapon&quot;].get_int());</a>
<a name="ln3040">    else</a>
<a name="ln3041">        return nullptr;</a>
<a name="ln3042">}</a>
<a name="ln3043"> </a>
<a name="ln3044">bool weapon_can_be_spectral(const item_def *wpn)</a>
<a name="ln3045">{</a>
<a name="ln3046">    return wpn &amp;&amp; is_weapon(*wpn) &amp;&amp; !is_range_weapon(*wpn)</a>
<a name="ln3047">        &amp;&amp; !is_special_unrandom_artefact(*wpn);</a>
<a name="ln3048">}</a>
<a name="ln3049"> </a>
<a name="ln3050">spret cast_spectral_weapon(actor *agent, int pow, god_type god, bool fail)</a>
<a name="ln3051">{</a>
<a name="ln3052">    ASSERT(agent);</a>
<a name="ln3053"> </a>
<a name="ln3054">    const int dur = min(2 + random2(1 + div_rand_round(pow, 25)), 4);</a>
<a name="ln3055">    item_def* wpn = agent-&gt;weapon();</a>
<a name="ln3056"> </a>
<a name="ln3057">    // If the wielded weapon should not be cloned, abort</a>
<a name="ln3058">    if (!weapon_can_be_spectral(wpn))</a>
<a name="ln3059">    {</a>
<a name="ln3060">        if (agent-&gt;is_player())</a>
<a name="ln3061">        {</a>
<a name="ln3062">            if (wpn)</a>
<a name="ln3063">            {</a>
<a name="ln3064">                mprf(&quot;%s vibrate%s crazily for a second.&quot;,</a>
<a name="ln3065">                     wpn-&gt;name(DESC_YOUR).c_str(),</a>
<a name="ln3066">                     wpn-&gt;quantity &gt; 1 ? &quot;&quot; : &quot;s&quot;);</a>
<a name="ln3067">            }</a>
<a name="ln3068">            else</a>
<a name="ln3069">                mpr(you.hands_act(&quot;twitch&quot;, &quot;.&quot;));</a>
<a name="ln3070">        }</a>
<a name="ln3071"> </a>
<a name="ln3072">        return spret::abort;</a>
<a name="ln3073">    }</a>
<a name="ln3074"> </a>
<a name="ln3075">    fail_check();</a>
<a name="ln3076"> </a>
<a name="ln3077">    // Remove any existing spectral weapons. Only one should be alive at any</a>
<a name="ln3078">    // given time.</a>
<a name="ln3079">    monster *old_mons = find_spectral_weapon(agent);</a>
<a name="ln3080">    if (old_mons)</a>
<a name="ln3081">        end_spectral_weapon(old_mons, false);</a>
<a name="ln3082"> </a>
<a name="ln3083">    mgen_data mg(MONS_SPECTRAL_WEAPON,</a>
<a name="ln3084">                 agent-&gt;is_player() ? BEH_FRIENDLY</a>
<a name="ln3085">                                    : SAME_ATTITUDE(agent-&gt;as_monster()),</a>
<a name="ln3086">                 agent-&gt;pos(),</a>
<a name="ln3087">                 agent-&gt;mindex());</a>
<a name="ln3088">    mg.set_summoned(agent, dur, SPELL_SPECTRAL_WEAPON, god);</a>
<a name="ln3089">    mg.props[TUKIMA_WEAPON] = *wpn;</a>
<a name="ln3090">    mg.props[TUKIMA_POWER] = pow;</a>
<a name="ln3091"> </a>
<a name="ln3092">    monster *mons = create_monster(mg);</a>
<a name="ln3093">    if (!mons)</a>
<a name="ln3094">    {</a>
<a name="ln3095">        //if (agent-&gt;is_player())</a>
<a name="ln3096">            canned_msg(MSG_NOTHING_HAPPENS);</a>
<a name="ln3097"> </a>
<a name="ln3098">        return spret::success;</a>
<a name="ln3099">    }</a>
<a name="ln3100"> </a>
<a name="ln3101">    if (agent-&gt;is_player())</a>
<a name="ln3102">        mpr(&quot;You draw out your weapon's spirit!&quot;);</a>
<a name="ln3103">    else</a>
<a name="ln3104">    {</a>
<a name="ln3105">        if (you.can_see(*agent) &amp;&amp; you.can_see(*mons))</a>
<a name="ln3106">        {</a>
<a name="ln3107">            string buf = &quot; draws out &quot;;</a>
<a name="ln3108">            buf += agent-&gt;pronoun(PRONOUN_POSSESSIVE);</a>
<a name="ln3109">            buf += &quot; weapon's spirit!&quot;;</a>
<a name="ln3110">            simple_monster_message(*agent-&gt;as_monster(), buf.c_str());</a>
<a name="ln3111">        }</a>
<a name="ln3112">        else if (you.can_see(*mons))</a>
<a name="ln3113">            simple_monster_message(*mons, &quot; appears!&quot;);</a>
<a name="ln3114"> </a>
<a name="ln3115">        mons-&gt;props[&quot;band_leader&quot;].get_int() = agent-&gt;mid;</a>
<a name="ln3116">        mons-&gt;foe = agent-&gt;mindex();</a>
<a name="ln3117">        mons-&gt;target = agent-&gt;pos();</a>
<a name="ln3118">    }</a>
<a name="ln3119"> </a>
<a name="ln3120">    mons-&gt;summoner = agent-&gt;mid;</a>
<a name="ln3121">    agent-&gt;props[&quot;spectral_weapon&quot;].get_int() = mons-&gt;mid;</a>
<a name="ln3122"> </a>
<a name="ln3123">    return spret::success;</a>
<a name="ln3124">}</a>
<a name="ln3125"> </a>
<a name="ln3126">void end_spectral_weapon(monster* mons, bool killed, bool quiet)</a>
<a name="ln3127">{</a>
<a name="ln3128">    // Should only happen if you dismiss it in wizard mode, I think</a>
<a name="ln3129">    if (!mons)</a>
<a name="ln3130">        return;</a>
<a name="ln3131"> </a>
<a name="ln3132">    actor *owner = actor_by_mid(mons-&gt;summoner);</a>
<a name="ln3133"> </a>
<a name="ln3134">    if (owner)</a>
<a name="ln3135">        owner-&gt;props.erase(&quot;spectral_weapon&quot;);</a>
<a name="ln3136"> </a>
<a name="ln3137">    if (!quiet)</a>
<a name="ln3138">    {</a>
<a name="ln3139">        if (you.can_see(*mons))</a>
<a name="ln3140">        {</a>
<a name="ln3141">            simple_monster_message(*mons, &quot; fades away.&quot;,</a>
<a name="ln3142">                                   MSGCH_MONSTER_DAMAGE, MDAM_DEAD);</a>
<a name="ln3143">        }</a>
<a name="ln3144">        else if (owner &amp;&amp; owner-&gt;is_player())</a>
<a name="ln3145">            mpr(&quot;You feel your bond with your spectral weapon wane.&quot;);</a>
<a name="ln3146">    }</a>
<a name="ln3147"> </a>
<a name="ln3148">    if (!killed)</a>
<a name="ln3149">        monster_die(*mons, KILL_RESET, NON_MONSTER);</a>
<a name="ln3150">}</a>
<a name="ln3151"> </a>
<a name="ln3152">bool trigger_spectral_weapon(actor* agent, const actor* target)</a>
<a name="ln3153">{</a>
<a name="ln3154">    monster *spectral_weapon = find_spectral_weapon(agent);</a>
<a name="ln3155"> </a>
<a name="ln3156">    // Don't try to attack with a nonexistent spectral weapon</a>
<a name="ln3157">    if (!spectral_weapon || !spectral_weapon-&gt;alive())</a>
<a name="ln3158">    {</a>
<a name="ln3159">        agent-&gt;props.erase(&quot;spectral_weapon&quot;);</a>
<a name="ln3160">        return false;</a>
<a name="ln3161">    }</a>
<a name="ln3162"> </a>
<a name="ln3163">    // Likewise if the target is the spectral weapon itself</a>
<a name="ln3164">    if (target-&gt;as_monster() == spectral_weapon)</a>
<a name="ln3165">        return false;</a>
<a name="ln3166"> </a>
<a name="ln3167">    // Clear out any old orders.</a>
<a name="ln3168">    reset_spectral_weapon(spectral_weapon);</a>
<a name="ln3169"> </a>
<a name="ln3170">    spectral_weapon-&gt;props[SW_TARGET_MID].get_int() = target-&gt;mid;</a>
<a name="ln3171">    spectral_weapon-&gt;props[SW_READIED] = true;</a>
<a name="ln3172"> </a>
<a name="ln3173">    return true;</a>
<a name="ln3174">}</a>
<a name="ln3175"> </a>
<a name="ln3176">// Called at the start of each round. Cancels attack order given in the</a>
<a name="ln3177">// previous round, if the weapon was not able to execute them fully</a>
<a name="ln3178">// before the next player action</a>
<a name="ln3179">void reset_spectral_weapon(monster* mons)</a>
<a name="ln3180">{</a>
<a name="ln3181">    if (!mons || mons-&gt;type != MONS_SPECTRAL_WEAPON)</a>
<a name="ln3182">        return;</a>
<a name="ln3183"> </a>
<a name="ln3184">    if (mons-&gt;props.exists(SW_TRACKING))</a>
<a name="ln3185">    {</a>
<a name="ln3186">        mons-&gt;props.erase(SW_TRACKING);</a>
<a name="ln3187">        mons-&gt;props.erase(SW_READIED);</a>
<a name="ln3188">        mons-&gt;props.erase(SW_TARGET_MID);</a>
<a name="ln3189"> </a>
<a name="ln3190">        return;</a>
<a name="ln3191">    }</a>
<a name="ln3192"> </a>
<a name="ln3193">    // If an attack has been readied, begin tracking.</a>
<a name="ln3194">    if (mons-&gt;props.exists(SW_READIED))</a>
<a name="ln3195">        mons-&gt;props[SW_TRACKING] = true;</a>
<a name="ln3196">    else</a>
<a name="ln3197">        mons-&gt;props.erase(SW_TARGET_MID);</a>
<a name="ln3198">}</a>
<a name="ln3199"> </a>
<a name="ln3200">/* Confirms the spectral weapon can and will attack the given defender.</a>
<a name="ln3201"> *</a>
<a name="ln3202"> * Checks the target, and that we haven't attacked yet.</a>
<a name="ln3203"> * Then consumes our ready state, preventing further attacks.</a>
<a name="ln3204"> */</a>
<a name="ln3205">bool confirm_attack_spectral_weapon(monster* mons, const actor *defender)</a>
<a name="ln3206">{</a>
<a name="ln3207">    // No longer tracking towards the target.</a>
<a name="ln3208">    mons-&gt;props.erase(SW_TRACKING);</a>
<a name="ln3209"> </a>
<a name="ln3210">    // Is the defender our target?</a>
<a name="ln3211">    if (mons-&gt;props.exists(SW_TARGET_MID)</a>
<a name="ln3212">        &amp;&amp; (mid_t)mons-&gt;props[SW_TARGET_MID].get_int() == defender-&gt;mid</a>
<a name="ln3213">        &amp;&amp; mons-&gt;props.exists(SW_READIED))</a>
<a name="ln3214">    {</a>
<a name="ln3215">        // Consume our ready state and attack</a>
<a name="ln3216">        mons-&gt;props.erase(SW_READIED);</a>
<a name="ln3217">        return true;</a>
<a name="ln3218">    }</a>
<a name="ln3219"> </a>
<a name="ln3220">    // Expend the weapon's energy, as it can't attack</a>
<a name="ln3221">    int energy = mons-&gt;action_energy(EUT_ATTACK);</a>
<a name="ln3222">    ASSERT(energy &gt; 0);</a>
<a name="ln3223"> </a>
<a name="ln3224">    mons-&gt;speed_increment -= energy;</a>
<a name="ln3225"> </a>
<a name="ln3226">    return false;</a>
<a name="ln3227">}</a>
<a name="ln3228"> </a>
<a name="ln3229">static void _setup_infestation(bolt &amp;beam, int pow)</a>
<a name="ln3230">{</a>
<a name="ln3231">    beam.name         = &quot;infestation&quot;;</a>
<a name="ln3232">    beam.aux_source   = &quot;infestation&quot;;</a>
<a name="ln3233">    beam.flavour      = BEAM_INFESTATION;</a>
<a name="ln3234">    beam.glyph        = dchar_glyph(DCHAR_FIRED_BURST);</a>
<a name="ln3235">    beam.colour       = GREEN;</a>
<a name="ln3236">    beam.source_id    = MID_PLAYER;</a>
<a name="ln3237">    beam.thrower      = KILL_YOU;</a>
<a name="ln3238">    beam.is_explosion = true;</a>
<a name="ln3239">    beam.ex_size      = 2;</a>
<a name="ln3240">    beam.ench_power   = pow;</a>
<a name="ln3241">    beam.origin_spell = SPELL_INFESTATION;</a>
<a name="ln3242">}</a>
<a name="ln3243"> </a>
<a name="ln3244">spret cast_infestation(int pow, bolt &amp;beam, bool fail)</a>
<a name="ln3245">{</a>
<a name="ln3246">    if (cell_is_solid(beam.target))</a>
<a name="ln3247">    {</a>
<a name="ln3248">        canned_msg(MSG_SOMETHING_IN_WAY);</a>
<a name="ln3249">        return spret::abort;</a>
<a name="ln3250">    }</a>
<a name="ln3251"> </a>
<a name="ln3252">    fail_check();</a>
<a name="ln3253"> </a>
<a name="ln3254">    _setup_infestation(beam, pow);</a>
<a name="ln3255">    mpr(&quot;You call forth a plague of scarabs!&quot;);</a>
<a name="ln3256">    beam.explode();</a>
<a name="ln3257"> </a>
<a name="ln3258">    return spret::success;</a>
<a name="ln3259">}</a>
<a name="ln3260"> </a>
<a name="ln3261">struct summon_cap</a>
<a name="ln3262">{</a>
<a name="ln3263">    int type_cap;</a>
<a name="ln3264">    int timeout;</a>
<a name="ln3265">};</a>
<a name="ln3266"> </a>
<a name="ln3267">// spell type, cap, timeout</a>
<a name="ln3268">static const map&lt;spell_type, summon_cap&gt; summonsdata =</a>
<a name="ln3269">{</a>
<a name="ln3270">    // Beasts</a>
<a name="ln3271">    { SPELL_SUMMON_BUTTERFLIES,         { 8, 5 } },</a>
<a name="ln3272">    { SPELL_SUMMON_SMALL_MAMMAL,        { 4, 2 } },</a>
<a name="ln3273">    { SPELL_CALL_CANINE_FAMILIAR,       { 1, 2 } },</a>
<a name="ln3274">    { SPELL_SUMMON_ICE_BEAST,           { 3, 3 } },</a>
<a name="ln3275">    { SPELL_SUMMON_HYDRA,               { 3, 2 } },</a>
<a name="ln3276">    { SPELL_SUMMON_MANA_VIPER,          { 2, 2 } },</a>
<a name="ln3277">    // Demons</a>
<a name="ln3278">    { SPELL_CALL_IMP,                   { 3, 3 } },</a>
<a name="ln3279">    { SPELL_SUMMON_DEMON,               { 3, 2 } },</a>
<a name="ln3280">    { SPELL_SUMMON_GREATER_DEMON,       { 3, 2 } },</a>
<a name="ln3281">    // General monsters</a>
<a name="ln3282">    { SPELL_MONSTROUS_MENAGERIE,        { 3, 2 } },</a>
<a name="ln3283">    { SPELL_SUMMON_HORRIBLE_THINGS,     { 8, 8 } },</a>
<a name="ln3284">    { SPELL_SHADOW_CREATURES,           { 4, 2 } },</a>
<a name="ln3285">    { SPELL_SUMMON_LIGHTNING_SPIRE,     { 1, 2 } },</a>
<a name="ln3286">    { SPELL_SUMMON_GUARDIAN_GOLEM,      { 1, 2 } },</a>
<a name="ln3287">    { SPELL_SPELLFORGED_SERVITOR,       { 1, 2 } },</a>
<a name="ln3288">    // Monster spells</a>
<a name="ln3289">    { SPELL_SUMMON_UFETUBUS,            { 8, 2 } },</a>
<a name="ln3290">    { SPELL_SUMMON_HELL_BEAST,          { 8, 2 } },</a>
<a name="ln3291">    { SPELL_SUMMON_UNDEAD,              { 8, 2 } },</a>
<a name="ln3292">    { SPELL_SUMMON_DRAKES,              { 4, 2 } },</a>
<a name="ln3293">    { SPELL_SUMMON_MUSHROOMS,           { 8, 2 } },</a>
<a name="ln3294">    { SPELL_SUMMON_EYEBALLS,            { 4, 2 } },</a>
<a name="ln3295">    { SPELL_WATER_ELEMENTALS,           { 3, 2 } },</a>
<a name="ln3296">    { SPELL_FIRE_ELEMENTALS,            { 3, 2 } },</a>
<a name="ln3297">    { SPELL_EARTH_ELEMENTALS,           { 3, 2 } },</a>
<a name="ln3298">    { SPELL_AIR_ELEMENTALS,             { 3, 2 } },</a>
<a name="ln3299">    { SPELL_SUMMON_SPECTRAL_ORCS,       { 3, 2 } },</a>
<a name="ln3300">    { SPELL_FIRE_SUMMON,                { 4, 2 } },</a>
<a name="ln3301">    { SPELL_SUMMON_MINOR_DEMON,         { 3, 3 } },</a>
<a name="ln3302">    { SPELL_CALL_LOST_SOUL,             { 3, 2 } },</a>
<a name="ln3303">    { SPELL_SUMMON_VERMIN,              { 5, 2 } },</a>
<a name="ln3304">    { SPELL_FORCEFUL_INVITATION,        { 3, 1 } },</a>
<a name="ln3305">    { SPELL_PLANEREND,                  { 6, 1 } },</a>
<a name="ln3306">    { SPELL_SUMMON_DRAGON,              { 4, 8 } },</a>
<a name="ln3307">    { SPELL_PHANTOM_MIRROR,             { 4, 1 } },</a>
<a name="ln3308">    { SPELL_FAKE_MARA_SUMMON,           { 2, 1 } },</a>
<a name="ln3309">    { SPELL_SUMMON_EMPEROR_SCORPIONS,   { 6, 2 } },</a>
<a name="ln3310">    { SPELL_SUMMON_SCARABS,             { 8, 1 } },</a>
<a name="ln3311">    { SPELL_SUMMON_HOLIES,              { 4, 2 } },</a>
<a name="ln3312">    { SPELL_SUMMON_EXECUTIONERS,        { 3, 1 } },</a>
<a name="ln3313">    { SPELL_AWAKEN_EARTH,               { 9, 2 } },</a>
<a name="ln3314">    { SPELL_GREATER_SERVANT_MAKHLEB,    { 1, 2 } },</a>
<a name="ln3315">};</a>
<a name="ln3316"> </a>
<a name="ln3317">bool summons_are_capped(spell_type spell)</a>
<a name="ln3318">{</a>
<a name="ln3319">    ASSERT_RANGE(spell, 0, NUM_SPELLS);</a>
<a name="ln3320">    return summonsdata.count(spell);</a>
<a name="ln3321">}</a>
<a name="ln3322"> </a>
<a name="ln3323">int summons_limit(spell_type spell)</a>
<a name="ln3324">{</a>
<a name="ln3325">    const summon_cap *cap = map_find(summonsdata, spell);</a>
<a name="ln3326">    return cap ? cap-&gt;type_cap : 0;</a>
<a name="ln3327">}</a>
<a name="ln3328"> </a>
<a name="ln3329">static bool _spell_has_variable_cap(spell_type spell)</a>
<a name="ln3330">{</a>
<a name="ln3331">    return spell == SPELL_SHADOW_CREATURES</a>
<a name="ln3332">           || spell == SPELL_MONSTROUS_MENAGERIE;</a>
<a name="ln3333">}</a>
<a name="ln3334"> </a>
<a name="ln3335">static void _expire_capped_summon(monster* mon, int delay, bool recurse)</a>
<a name="ln3336">{</a>
<a name="ln3337">    // Timeout the summon</a>
<a name="ln3338">    mon_enchant abj = mon-&gt;get_ench(ENCH_ABJ);</a>
<a name="ln3339">    abj.duration = delay;</a>
<a name="ln3340">    mon-&gt;update_ench(abj);</a>
<a name="ln3341">    // Mark our cap abjuration so we don't keep abjuring the same</a>
<a name="ln3342">    // one if creating multiple summons (also, should show a status light).</a>
<a name="ln3343">    mon-&gt;add_ench(ENCH_SUMMON_CAPPED);</a>
<a name="ln3344"> </a>
<a name="ln3345">    if (recurse &amp;&amp; mon-&gt;props.exists(&quot;summon_id&quot;))</a>
<a name="ln3346">    {</a>
<a name="ln3347">        const int summon_id = mon-&gt;props[&quot;summon_id&quot;].get_int();</a>
<a name="ln3348">        for (monster_iterator mi; mi; ++mi)</a>
<a name="ln3349">        {</a>
<a name="ln3350">            // Summoner check should be technically unnecessary, but saves</a>
<a name="ln3351">            // scanning props for all monsters on the level.</a>
<a name="ln3352">            if (mi-&gt;summoner == mon-&gt;summoner</a>
<a name="ln3353">                &amp;&amp; mi-&gt;props.exists(&quot;summon_id&quot;)</a>
<a name="ln3354">                &amp;&amp; mi-&gt;props[&quot;summon_id&quot;].get_int() == summon_id</a>
<a name="ln3355">                &amp;&amp; !mi-&gt;has_ench(ENCH_SUMMON_CAPPED))</a>
<a name="ln3356">            {</a>
<a name="ln3357">                _expire_capped_summon(*mi, delay, false);</a>
<a name="ln3358">            }</a>
<a name="ln3359">        }</a>
<a name="ln3360">    }</a>
<a name="ln3361">}</a>
<a name="ln3362"> </a>
<a name="ln3363">// Call when a monster has been summoned, to manage this summoner's caps.</a>
<a name="ln3364">void summoned_monster(const monster *mons, const actor *caster,</a>
<a name="ln3365">                      spell_type spell)</a>
<a name="ln3366">{</a>
<a name="ln3367">    const summon_cap *cap = map_find(summonsdata, spell);</a>
<a name="ln3368">    if (!cap) // summons aren't capped</a>
<a name="ln3369">        return;</a>
<a name="ln3370"> </a>
<a name="ln3371">    int max_this_time = cap-&gt;type_cap;</a>
<a name="ln3372"> </a>
<a name="ln3373">    // Cap large abominations and tentacled monstrosities separately</a>
<a name="ln3374">    if (spell == SPELL_SUMMON_HORRIBLE_THINGS)</a>
<a name="ln3375">    {</a>
<a name="ln3376">        max_this_time = (mons-&gt;type == MONS_ABOMINATION_LARGE ? max_this_time * 3 / 4</a>
<a name="ln3377">                                                              : max_this_time * 1 / 4);</a>
<a name="ln3378">    }</a>
<a name="ln3379"> </a>
<a name="ln3380">    monster* oldest_summon = 0;</a>
<a name="ln3381">    int oldest_duration = 0;</a>
<a name="ln3382"> </a>
<a name="ln3383">    // Linked summons that have already been counted once</a>
<a name="ln3384">    set&lt;int&gt; seen_ids;</a>
<a name="ln3385"> </a>
<a name="ln3386">    int count = 1;</a>
<a name="ln3387">    for (monster_iterator mi; mi; ++mi)</a>
<a name="ln3388">    {</a>
<a name="ln3389">        if (mons == *mi)</a>
<a name="ln3390">            continue;</a>
<a name="ln3391"> </a>
<a name="ln3392">        int duration = 0;</a>
<a name="ln3393">        int stype    = 0;</a>
<a name="ln3394">        const bool summoned = mi-&gt;is_summoned(&amp;duration, &amp;stype);</a>
<a name="ln3395">        if (summoned &amp;&amp; stype == spell &amp;&amp; caster-&gt;mid == mi-&gt;summoner</a>
<a name="ln3396">            &amp;&amp; mons_aligned(caster, *mi))</a>
<a name="ln3397">        {</a>
<a name="ln3398">            // Count large abominations and tentacled monstrosities separately</a>
<a name="ln3399">            if (spell == SPELL_SUMMON_HORRIBLE_THINGS &amp;&amp; mi-&gt;type != mons-&gt;type)</a>
<a name="ln3400">                continue;</a>
<a name="ln3401"> </a>
<a name="ln3402">            if (_spell_has_variable_cap(spell) &amp;&amp; mi-&gt;props.exists(&quot;summon_id&quot;))</a>
<a name="ln3403">            {</a>
<a name="ln3404">                const int id = mi-&gt;props[&quot;summon_id&quot;].get_int();</a>
<a name="ln3405"> </a>
<a name="ln3406">                // Skip any linked summon whose set we have seen already,</a>
<a name="ln3407">                // otherwise add it to the list of seen summon IDs</a>
<a name="ln3408">                if (seen_ids.find(id) == seen_ids.end())</a>
<a name="ln3409">                    seen_ids.insert(id);</a>
<a name="ln3410">                else</a>
<a name="ln3411">                    continue;</a>
<a name="ln3412">            }</a>
<a name="ln3413"> </a>
<a name="ln3414">            count++;</a>
<a name="ln3415"> </a>
<a name="ln3416">            // If this summon is the oldest (well, the closest to expiry)</a>
<a name="ln3417">            // remember it (unless already expiring due to a cap)</a>
<a name="ln3418">            if (!mi-&gt;has_ench(ENCH_SUMMON_CAPPED)</a>
<a name="ln3419">                &amp;&amp; (!oldest_summon || duration &lt; oldest_duration))</a>
<a name="ln3420">            {</a>
<a name="ln3421">                oldest_summon = *mi;</a>
<a name="ln3422">                oldest_duration = duration;</a>
<a name="ln3423">            }</a>
<a name="ln3424">        }</a>
<a name="ln3425">    }</a>
<a name="ln3426"> </a>
<a name="ln3427">    if (oldest_summon &amp;&amp; count &gt; max_this_time)</a>
<a name="ln3428">        _expire_capped_summon(oldest_summon, cap-&gt;timeout * 5, true);</a>
<a name="ln3429">}</a>
<a name="ln3430"> </a>
<a name="ln3431">int count_summons(const actor *summoner, spell_type spell)</a>
<a name="ln3432">{</a>
<a name="ln3433">    int count = 0;</a>
<a name="ln3434">    for (monster_iterator mi; mi; ++mi)</a>
<a name="ln3435">    {</a>
<a name="ln3436">        if (summoner == *mi)</a>
<a name="ln3437">            continue;</a>
<a name="ln3438"> </a>
<a name="ln3439">        int stype    = 0;</a>
<a name="ln3440">        const bool summoned = mi-&gt;is_summoned(nullptr, &amp;stype);</a>
<a name="ln3441">        if (summoned &amp;&amp; stype == spell &amp;&amp; summoner-&gt;mid == mi-&gt;summoner</a>
<a name="ln3442">            &amp;&amp; mons_aligned(summoner, *mi))</a>
<a name="ln3443">        {</a>
<a name="ln3444">            count++;</a>
<a name="ln3445">        }</a>
<a name="ln3446">    }</a>
<a name="ln3447"> </a>
<a name="ln3448">    return count;</a>
<a name="ln3449">}</a>
<a name="ln3450"> </a>
<a name="ln3451">static bool _create_briar_patch(coord_def&amp; target)</a>
<a name="ln3452">{</a>
<a name="ln3453">    mgen_data mgen = mgen_data(MONS_BRIAR_PATCH, BEH_FRIENDLY, target,</a>
<a name="ln3454">            MHITNOT, MG_FORCE_PLACE, GOD_FEDHAS);</a>
<a name="ln3455">    mgen.hd = mons_class_hit_dice(MONS_BRIAR_PATCH) +</a>
<a name="ln3456">        you.skill_rdiv(SK_INVOCATIONS);</a>
<a name="ln3457">    mgen.set_summoned(&amp;you, min(2 + you.skill_rdiv(SK_INVOCATIONS, 1, 5), 6),</a>
<a name="ln3458">            SPELL_NO_SPELL);</a>
<a name="ln3459"> </a>
<a name="ln3460">    if (create_monster(mgen))</a>
<a name="ln3461">    {</a>
<a name="ln3462">        mpr(&quot;A briar patch grows up from the ground.&quot;);</a>
<a name="ln3463">        return true;</a>
<a name="ln3464">    }</a>
<a name="ln3465"> </a>
<a name="ln3466">    return false;</a>
<a name="ln3467">}</a>
<a name="ln3468"> </a>
<a name="ln3469">bool fedhas_wall_of_briars()</a>
<a name="ln3470">{</a>
<a name="ln3471">    // How many adjacent open spaces are there?</a>
<a name="ln3472">    vector&lt;coord_def&gt; adjacent;</a>
<a name="ln3473">    for (adjacent_iterator adj_it(you.pos()); adj_it; ++adj_it)</a>
<a name="ln3474">    {</a>
<a name="ln3475">        if (monster_habitable_grid(MONS_BRIAR_PATCH, env.grid(*adj_it))</a>
<a name="ln3476">            &amp;&amp; !actor_at(*adj_it))</a>
<a name="ln3477">        {</a>
<a name="ln3478">            adjacent.push_back(*adj_it);</a>
<a name="ln3479">        }</a>
<a name="ln3480">    }</a>
<a name="ln3481"> </a>
<a name="ln3482">    // Don't prompt if we can't do anything.</a>
<a name="ln3483">    if (adjacent.empty())</a>
<a name="ln3484">    {</a>
<a name="ln3485">        mpr(&quot;No empty adjacent squares.&quot;);</a>
<a name="ln3486">        return false;</a>
<a name="ln3487">    }</a>
<a name="ln3488"> </a>
<a name="ln3489">    int created_count = 0;</a>
<a name="ln3490">    for (auto p : adjacent)</a>
<a name="ln3491">    {</a>
<a name="ln3492">        if (_create_briar_patch(p))</a>
<a name="ln3493">            created_count++;</a>
<a name="ln3494">    }</a>
<a name="ln3495"> </a>
<a name="ln3496">    if (!created_count)</a>
<a name="ln3497">        canned_msg(MSG_NOTHING_HAPPENS);</a>
<a name="ln3498"> </a>
<a name="ln3499">    return created_count;</a>
<a name="ln3500">}</a>
<a name="ln3501"> </a>
<a name="ln3502">static void _overgrow_wall(const coord_def &amp;pos)</a>
<a name="ln3503">{</a>
<a name="ln3504">    const dungeon_feature_type feat = grd(pos);</a>
<a name="ln3505">    const string what = feature_description(feat, NUM_TRAPS, &quot;&quot;, DESC_THE);</a>
<a name="ln3506"> </a>
<a name="ln3507">    if (monster_at(pos))</a>
<a name="ln3508">    {</a>
<a name="ln3509">        mprf(&quot;Something unseen blocks growth in %s.&quot;, what.c_str());</a>
<a name="ln3510">        return;</a>
<a name="ln3511">    }</a>
<a name="ln3512"> </a>
<a name="ln3513">    destroy_wall(pos);</a>
<a name="ln3514"> </a>
<a name="ln3515">    const monster_type mon = random_choose_weighted(4, MONS_OKLOB_SAPLING,</a>
<a name="ln3516">                                                    4, MONS_BURNING_BUSH,</a>
<a name="ln3517">                                                    4, MONS_WANDERING_MUSHROOM,</a>
<a name="ln3518">                                                    1, MONS_BALLISTOMYCETE,</a>
<a name="ln3519">                                                    1, MONS_OKLOB_PLANT);</a>
<a name="ln3520">    mgen_data mgen(mon, BEH_FRIENDLY, pos, MHITYOU, MG_FORCE_PLACE);</a>
<a name="ln3521">    mgen.hd = mons_class_hit_dice(mon) + you.skill_rdiv(SK_INVOCATIONS);</a>
<a name="ln3522">    mgen.set_summoned(&amp;you, min(3 + you.skill_rdiv(SK_INVOCATIONS, 1, 5), 6),</a>
<a name="ln3523">            SPELL_NO_SPELL);</a>
<a name="ln3524">    if (const monster* const plant = create_monster(mgen))</a>
<a name="ln3525">    {</a>
<a name="ln3526">        mprf(&quot;%s is torn apart as %s grows in its place.&quot;, what.c_str(),</a>
<a name="ln3527">                plant-&gt;name(DESC_A).c_str());</a>
<a name="ln3528">    }</a>
<a name="ln3529">    // XXX: Maybe try to make this revert the terrain if a monster isn't placed.</a>
<a name="ln3530">    else</a>
<a name="ln3531">        mprf(&quot;%s falls apart, but nothing grows.&quot;, what.c_str());</a>
<a name="ln3532">}</a>
<a name="ln3533"> </a>
<a name="ln3534">bool fedhas_overgrow()</a>
<a name="ln3535">{</a>
<a name="ln3536">    targeter_overgrow tgt;</a>
<a name="ln3537">    direction_chooser_args args;</a>
<a name="ln3538">    args.hitfunc = &amp;tgt;</a>
<a name="ln3539">    args.restricts = DIR_TARGET;</a>
<a name="ln3540">    args.mode = TARG_ANY;</a>
<a name="ln3541">    args.range = LOS_RADIUS;</a>
<a name="ln3542">    args.just_looking = false;</a>
<a name="ln3543">    args.needs_path = false;</a>
<a name="ln3544">    args.top_prompt = &quot;Aiming: &lt;white&gt;Overgrow&lt;/white&gt;&quot;;</a>
<a name="ln3545">    dist sdirect;</a>
<a name="ln3546">    direction(sdirect, args);</a>
<a name="ln3547">    if (!sdirect.isValid)</a>
<a name="ln3548">        return false;</a>
<a name="ln3549"> </a>
<a name="ln3550">    for (auto site : tgt.affected_positions)</a>
<a name="ln3551">        _overgrow_wall(site);</a>
<a name="ln3552"> </a>
<a name="ln3553">    return true;</a>
<a name="ln3554">}</a>
<a name="ln3555"> </a>
<a name="ln3556">spret fedhas_grow_ballistomycete(bool fail)</a>
<a name="ln3557">{</a>
<a name="ln3558">    dist spd;</a>
<a name="ln3559">    bolt beam;</a>
<a name="ln3560">    beam.range = 2;</a>
<a name="ln3561">    direction_chooser_args args;</a>
<a name="ln3562">    args.restricts = DIR_TARGET;</a>
<a name="ln3563">    args.mode = TARG_HOSTILE;</a>
<a name="ln3564">    args.needs_path = false;</a>
<a name="ln3565">    if (!spell_direction(spd, beam, &amp;args))</a>
<a name="ln3566">        return spret::abort;</a>
<a name="ln3567"> </a>
<a name="ln3568">    if (grid_distance(beam.target, you.pos()) &gt; 2 || !in_bounds(beam.target))</a>
<a name="ln3569">    {</a>
<a name="ln3570">        mpr(&quot;That's too far away.&quot;);</a>
<a name="ln3571">        return spret::abort;</a>
<a name="ln3572">    }</a>
<a name="ln3573"> </a>
<a name="ln3574">    if (!monster_habitable_grid(MONS_BALLISTOMYCETE, grd(beam.target)))</a>
<a name="ln3575">    {</a>
<a name="ln3576">        mpr(&quot;You can't grow a ballistomycete there.&quot;);</a>
<a name="ln3577">        return spret::abort;</a>
<a name="ln3578">    }</a>
<a name="ln3579"> </a>
<a name="ln3580">    monster* mons = monster_at(beam.target);</a>
<a name="ln3581">    if (mons)</a>
<a name="ln3582">    {</a>
<a name="ln3583">        if (you.can_see(*mons))</a>
<a name="ln3584">        {</a>
<a name="ln3585">            mpr(&quot;That space is already occupied.&quot;);</a>
<a name="ln3586">            return spret::abort;</a>
<a name="ln3587">        }</a>
<a name="ln3588"> </a>
<a name="ln3589">        fail_check();</a>
<a name="ln3590"> </a>
<a name="ln3591">        // invisible monster</a>
<a name="ln3592">        mpr(&quot;Something you can't see occupies that space!&quot;);</a>
<a name="ln3593">        return spret::success;</a>
<a name="ln3594">    }</a>
<a name="ln3595"> </a>
<a name="ln3596">    fail_check();</a>
<a name="ln3597"> </a>
<a name="ln3598">    mgen_data mgen(MONS_BALLISTOMYCETE, BEH_FRIENDLY, beam.target, MHITYOU,</a>
<a name="ln3599">            MG_FORCE_BEH | MG_FORCE_PLACE | MG_AUTOFOE);</a>
<a name="ln3600">    mgen.hd = mons_class_hit_dice(MONS_BALLISTOMYCETE) +</a>
<a name="ln3601">        you.skill_rdiv(SK_INVOCATIONS);</a>
<a name="ln3602">    mgen.set_summoned(&amp;you, min(3 + you.skill_rdiv(SK_INVOCATIONS, 1, 5), 6),</a>
<a name="ln3603">            SPELL_NO_SPELL);</a>
<a name="ln3604"> </a>
<a name="ln3605">    if (create_monster(mgen))</a>
<a name="ln3606">        mpr(&quot;A ballistomycete grows from the ground.&quot;);</a>
<a name="ln3607">    else</a>
<a name="ln3608">        canned_msg(MSG_NOTHING_HAPPENS);</a>
<a name="ln3609"> </a>
<a name="ln3610">    return spret::success;</a>
<a name="ln3611">}</a>
<a name="ln3612"> </a>
<a name="ln3613">spret fedhas_grow_oklob(bool fail)</a>
<a name="ln3614">{</a>
<a name="ln3615">    dist spd;</a>
<a name="ln3616">    bolt beam;</a>
<a name="ln3617">    beam.range = 2;</a>
<a name="ln3618">    direction_chooser_args args;</a>
<a name="ln3619">    args.restricts = DIR_TARGET;</a>
<a name="ln3620">    args.mode = TARG_HOSTILE;</a>
<a name="ln3621">    args.needs_path = false;</a>
<a name="ln3622">    if (!spell_direction(spd, beam, &amp;args))</a>
<a name="ln3623">        return spret::abort;</a>
<a name="ln3624"> </a>
<a name="ln3625">    if (grid_distance(beam.target, you.pos()) &gt; 2 || !in_bounds(beam.target))</a>
<a name="ln3626">    {</a>
<a name="ln3627">        mpr(&quot;That's too far away.&quot;);</a>
<a name="ln3628">        return spret::abort;</a>
<a name="ln3629">    }</a>
<a name="ln3630"> </a>
<a name="ln3631">    if (!monster_habitable_grid(MONS_OKLOB_PLANT, grd(beam.target)))</a>
<a name="ln3632">    {</a>
<a name="ln3633">        mpr(&quot;You can't grow an oklob plant there.&quot;);</a>
<a name="ln3634">        return spret::abort;</a>
<a name="ln3635">    }</a>
<a name="ln3636"> </a>
<a name="ln3637">    monster* mons = monster_at(beam.target);</a>
<a name="ln3638">    if (mons)</a>
<a name="ln3639">    {</a>
<a name="ln3640">        if (you.can_see(*mons))</a>
<a name="ln3641">        {</a>
<a name="ln3642">            mpr(&quot;That space is already occupied.&quot;);</a>
<a name="ln3643">            return spret::abort;</a>
<a name="ln3644">        }</a>
<a name="ln3645"> </a>
<a name="ln3646">        fail_check();</a>
<a name="ln3647"> </a>
<a name="ln3648">        // invisible monster</a>
<a name="ln3649">        mpr(&quot;Something you can't see is occupying that space!&quot;);</a>
<a name="ln3650">        return spret::success;</a>
<a name="ln3651">    }</a>
<a name="ln3652"> </a>
<a name="ln3653">    fail_check();</a>
<a name="ln3654"> </a>
<a name="ln3655">    mgen_data mgen(MONS_OKLOB_PLANT, BEH_FRIENDLY, beam.target, MHITYOU,</a>
<a name="ln3656">            MG_FORCE_BEH | MG_FORCE_PLACE | MG_AUTOFOE);</a>
<a name="ln3657">    mgen.hd = mons_class_hit_dice(MONS_OKLOB_PLANT) +</a>
<a name="ln3658">        you.skill_rdiv(SK_INVOCATIONS);</a>
<a name="ln3659">    mgen.set_summoned(&amp;you, min(3 + you.skill_rdiv(SK_INVOCATIONS, 1, 5), 6),</a>
<a name="ln3660">            SPELL_NO_SPELL);</a>
<a name="ln3661"> </a>
<a name="ln3662">    if (create_monster(mgen))</a>
<a name="ln3663">        mpr(&quot;An oklob plant grows from the ground.&quot;);</a>
<a name="ln3664">    else</a>
<a name="ln3665">        canned_msg(MSG_NOTHING_HAPPENS);</a>
<a name="ln3666"> </a>
<a name="ln3667">    return spret::success;</a>
<a name="ln3668"> </a>
<a name="ln3669">}</a>
<a name="ln3670"> </a>
<a name="ln3671">spret cast_foxfire(int pow, god_type god, bool fail)</a>
<a name="ln3672">{</a>
<a name="ln3673">    fail_check();</a>
<a name="ln3674">    int created = 0;</a>
<a name="ln3675"> </a>
<a name="ln3676">    for (fair_adjacent_iterator ai(you.pos()); ai; ++ai)</a>
<a name="ln3677">    {</a>
<a name="ln3678">        mgen_data fox(MONS_FOXFIRE, BEH_FRIENDLY,</a>
<a name="ln3679">                      *ai, MHITNOT, MG_FORCE_PLACE | MG_AUTOFOE);</a>
<a name="ln3680">        fox.set_summoned(&amp;you, 0, SPELL_FOXFIRE, god);</a>
<a name="ln3681">        fox.hd = pow;</a>
<a name="ln3682">        monster *foxfire;</a>
<a name="ln3683"> </a>
<a name="ln3684">        if (!cell_is_solid(*ai) &amp;&amp; !monster_at(*ai)</a>
<a name="ln3685">            &amp;&amp; (foxfire = create_monster(fox)))</a>
<a name="ln3686">        {</a>
<a name="ln3687">            ++created;</a>
<a name="ln3688">            foxfire-&gt;add_ench(ENCH_SHORT_LIVED);</a>
<a name="ln3689">            foxfire-&gt;steps_remaining = you.current_vision + 2;</a>
<a name="ln3690"> </a>
<a name="ln3691">            // Avoid foxfire without targets always moving towards (0,0)</a>
<a name="ln3692">            if (!(foxfire-&gt;get_foe() &amp;&amp; foxfire-&gt;get_foe()-&gt;is_monster()))</a>
<a name="ln3693">                set_random_target(foxfire);</a>
<a name="ln3694">        }</a>
<a name="ln3695"> </a>
<a name="ln3696">        if (created == 2)</a>
<a name="ln3697">            break;</a>
<a name="ln3698">    }</a>
<a name="ln3699"> </a>
<a name="ln3700">    if (created)</a>
<a name="ln3701">        mpr(&quot;You conjure some foxfire!&quot;);</a>
<a name="ln3702">    else</a>
<a name="ln3703">        canned_msg(MSG_NOTHING_HAPPENS);</a>
<a name="ln3704"> </a>
<a name="ln3705">    return spret::success;</a>
<a name="ln3706">}</a>

</code></pre>
<div class="balloon" rel="290"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v768/" target="_blank">V768</a> The expression 'player_will_anger_monster(type)' is of enum type. It is odd that it is used as an expression of a Boolean-type.</p></div>
<div class="balloon" rel="383"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v768/" target="_blank">V768</a> The expression 'player_will_anger_monster(mon)' is of enum type. It is odd that it is used as an expression of a Boolean-type.</p></div>
<div class="balloon" rel="875"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v768/" target="_blank">V768</a> The variable 'why' is of enum type. It is odd that it is used as a variable of a Boolean-type.</p></div>
<div class="balloon" rel="1175"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v768/" target="_blank">V768</a> The expression 'player_will_anger_monster(* mons)' is of enum type. It is odd that it is used as an expression of a Boolean-type.</p></div>
<div class="balloon" rel="1217"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v768/" target="_blank">V768</a> The expression 'player_will_anger_monster(* * mi)' is of enum type. It is odd that it is used as an expression of a Boolean-type.</p></div>
<div class="balloon" rel="2877"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v1048/" target="_blank">V1048</a> The 'beam.pierce' variable was assigned the same value.</p></div>

<link rel="stylesheet" href="highlight.css">
<script src="highlight.pack.js"></script>
<script src="highlightjs-line-numbers.js"></script>
<script>hljs.initHighlightingOnLoad();</script>
<script>hljs.initLineNumbersOnLoad();</script>
<script>
  $(document).ready(function() {
      $('.balloon').each(function () {
          var bl = $(this);
          var line = bl.attr('rel');
          var text = $('a[name="ln'+line+'"]').text();

          var space_count = 0;
          for(var i = 0; i<text.length; i++){
              var char = text[i];
              if((char !== ' ')&&(char !== '\t'))break;
              if(char === '\t')space_count++;
              space_count++;
          }

          bl.css('margin-left', space_count*8);
          $('a[name="ln'+line+'"]').after(bl);
      });

      window.location = window.location;
  });
</script>
</body>
</html>
