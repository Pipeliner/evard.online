
<html>
<head>

  <meta http-equiv="Content-Type" content="text/html; charset=US-ASCII" />
  <title>shopping.cc</title>

  <link rel="stylesheet" href="../style.css"/>
  <script src="../jquery-3.2.1.min.js"></script>
</head>
<body>

<pre><code class = "cpp">
<a name="ln1">/**</a>
<a name="ln2"> * @file</a>
<a name="ln3"> * @brief Shop keeper functions.</a>
<a name="ln4">**/</a>
<a name="ln5"> </a>
<a name="ln6">#include &quot;AppHdr.h&quot;</a>
<a name="ln7"> </a>
<a name="ln8">#include &quot;shopping.h&quot;</a>
<a name="ln9"> </a>
<a name="ln10">#include &lt;cstdio&gt;</a>
<a name="ln11">#include &lt;cstdlib&gt;</a>
<a name="ln12">#include &lt;cstring&gt;</a>
<a name="ln13"> </a>
<a name="ln14">#include &quot;artefact.h&quot;</a>
<a name="ln15">#include &quot;branch.h&quot;</a>
<a name="ln16">#include &quot;cio.h&quot;</a>
<a name="ln17">#include &quot;colour.h&quot;</a>
<a name="ln18">#include &quot;describe.h&quot;</a>
<a name="ln19">#include &quot;dgn-overview.h&quot;</a>
<a name="ln20">#include &quot;english.h&quot;</a>
<a name="ln21">#include &quot;env.h&quot;</a>
<a name="ln22">#include &quot;files.h&quot;</a>
<a name="ln23">#include &quot;invent.h&quot;</a>
<a name="ln24">#include &quot;item-name.h&quot;</a>
<a name="ln25">#include &quot;item-prop.h&quot;</a>
<a name="ln26">#include &quot;item-status-flag-type.h&quot;</a>
<a name="ln27">#include &quot;items.h&quot;</a>
<a name="ln28">#include &quot;libutil.h&quot;</a>
<a name="ln29">#include &quot;menu.h&quot;</a>
<a name="ln30">#include &quot;message.h&quot;</a>
<a name="ln31">#include &quot;notes.h&quot;</a>
<a name="ln32">#include &quot;options.h&quot;</a>
<a name="ln33">#include &quot;output.h&quot;</a>
<a name="ln34">#include &quot;player.h&quot;</a>
<a name="ln35">#include &quot;prompt.h&quot;</a>
<a name="ln36">#include &quot;spl-book.h&quot;</a>
<a name="ln37">#include &quot;stash.h&quot;</a>
<a name="ln38">#include &quot;state.h&quot;</a>
<a name="ln39">#include &quot;stepdown.h&quot;</a>
<a name="ln40">#include &quot;stringutil.h&quot;</a>
<a name="ln41">#ifdef USE_TILE_LOCAL</a>
<a name="ln42">#include &quot;tilereg-crt.h&quot;</a>
<a name="ln43">#endif</a>
<a name="ln44">#include &quot;travel.h&quot;</a>
<a name="ln45">#include &quot;unicode.h&quot;</a>
<a name="ln46">#include &quot;unwind.h&quot;</a>
<a name="ln47"> </a>
<a name="ln48">ShoppingList shopping_list;</a>
<a name="ln49"> </a>
<a name="ln50">static int _shop_get_item_value(const item_def&amp; item, int greed, bool id)</a>
<a name="ln51">{</a>
<a name="ln52">    int result = (greed * item_value(item, id) / 10);</a>
<a name="ln53"> </a>
<a name="ln54">    return max(result, 1);</a>
<a name="ln55">}</a>
<a name="ln56"> </a>
<a name="ln57">int item_price(const item_def&amp; item, const shop_struct&amp; shop)</a>
<a name="ln58">{</a>
<a name="ln59">    return _shop_get_item_value(item, shop.greed, shoptype_identifies_stock(shop.type));</a>
<a name="ln60">}</a>
<a name="ln61"> </a>
<a name="ln62">// This probably still needs some work. Rings used to be the only</a>
<a name="ln63">// artefacts which had a change in price, and that value corresponds</a>
<a name="ln64">// to returning 50 from this function. Good artefacts will probably</a>
<a name="ln65">// be returning just over 30 right now. Note that this isn't used</a>
<a name="ln66">// as a multiple, its used in the old ring way: 7 * ret is added to</a>
<a name="ln67">// the price of the artefact. -- bwr</a>
<a name="ln68">int artefact_value(const item_def &amp;item)</a>
<a name="ln69">{</a>
<a name="ln70">    ASSERT(is_artefact(item));</a>
<a name="ln71"> </a>
<a name="ln72">    int ret = 10;</a>
<a name="ln73">    artefact_properties_t prop;</a>
<a name="ln74">    artefact_properties(item, prop);</a>
<a name="ln75"> </a>
<a name="ln76">    // Brands are already accounted for via existing ego checks</a>
<a name="ln77"> </a>
<a name="ln78">    // This should probably be more complex... but this isn't so bad:</a>
<a name="ln79">    ret += 6 * prop[ ARTP_AC ]</a>
<a name="ln80">            + 6 * prop[ ARTP_EVASION ]</a>
<a name="ln81">            + 4 * prop[ ARTP_SHIELDING ]</a>
<a name="ln82">            + 6 * prop[ ARTP_SLAYING ]</a>
<a name="ln83">            + 3 * prop[ ARTP_STRENGTH ]</a>
<a name="ln84">            + 3 * prop[ ARTP_INTELLIGENCE ]</a>
<a name="ln85">            + 3 * prop[ ARTP_DEXTERITY ]</a>
<a name="ln86">            + 4 * prop[ ARTP_HP ]</a>
<a name="ln87">            + 3 * prop[ ARTP_MAGICAL_POWER ];</a>
<a name="ln88"> </a>
<a name="ln89">    // These resistances have meaningful levels</a>
<a name="ln90">    if (prop[ ARTP_FIRE ] &gt; 0)</a>
<a name="ln91">        ret += 5 + 5 * (prop[ ARTP_FIRE ] * prop[ ARTP_FIRE ]);</a>
<a name="ln92">    else if (prop[ ARTP_FIRE ] &lt; 0)</a>
<a name="ln93">        ret -= 10;</a>
<a name="ln94"> </a>
<a name="ln95">    if (prop[ ARTP_COLD ] &gt; 0)</a>
<a name="ln96">        ret += 5 + 5 * (prop[ ARTP_COLD ] * prop[ ARTP_COLD ]);</a>
<a name="ln97">    else if (prop[ ARTP_COLD ] &lt; 0)</a>
<a name="ln98">        ret -= 10;</a>
<a name="ln99"> </a>
<a name="ln100">    if (prop[ ARTP_MAGIC_RESISTANCE ] &gt; 0)</a>
<a name="ln101">        ret += 4 + 4 * prop[ ARTP_MAGIC_RESISTANCE ];</a>
<a name="ln102">    else if (prop[ ARTP_MAGIC_RESISTANCE ] &lt; 0)</a>
<a name="ln103">        ret -= 6;</a>
<a name="ln104"> </a>
<a name="ln105">    if (prop[ ARTP_NEGATIVE_ENERGY ] &gt; 0)</a>
<a name="ln106">        ret += 3 + 3 * (prop[ARTP_NEGATIVE_ENERGY] * prop[ARTP_NEGATIVE_ENERGY]);</a>
<a name="ln107"> </a>
<a name="ln108">    // Discount Stlth-, charge for Stlth+</a>
<a name="ln109">    ret += 2 * prop[ARTP_STEALTH];</a>
<a name="ln110">    // Stlth+ costs more than Stlth- cheapens</a>
<a name="ln111">    if (prop[ARTP_STEALTH] &gt; 0)</a>
<a name="ln112">        ret += 2 * prop[ARTP_STEALTH];</a>
<a name="ln113"> </a>
<a name="ln114">    // only one meaningful level:</a>
<a name="ln115">    if (prop[ ARTP_POISON ])</a>
<a name="ln116">        ret += 6;</a>
<a name="ln117"> </a>
<a name="ln118">    // only one meaningful level (hard to get):</a>
<a name="ln119">    if (prop[ ARTP_ELECTRICITY ])</a>
<a name="ln120">        ret += 10;</a>
<a name="ln121"> </a>
<a name="ln122">    // only one meaningful level (hard to get):</a>
<a name="ln123">    if (prop[ ARTP_RCORR ])</a>
<a name="ln124">        ret += 8;</a>
<a name="ln125"> </a>
<a name="ln126">    // only one meaningful level (hard to get):</a>
<a name="ln127">    if (prop[ ARTP_RMUT ])</a>
<a name="ln128">        ret += 8;</a>
<a name="ln129"> </a>
<a name="ln130">    if (prop[ ARTP_SEE_INVISIBLE ])</a>
<a name="ln131">        ret += 6;</a>
<a name="ln132"> </a>
<a name="ln133">    // abilities:</a>
<a name="ln134">    if (prop[ ARTP_FLY ])</a>
<a name="ln135">        ret += 3;</a>
<a name="ln136"> </a>
<a name="ln137">    if (prop[ ARTP_BLINK ])</a>
<a name="ln138">        ret += 10;</a>
<a name="ln139"> </a>
<a name="ln140">    if (prop[ ARTP_BERSERK ])</a>
<a name="ln141">        ret += 5;</a>
<a name="ln142"> </a>
<a name="ln143">    if (prop[ ARTP_INVISIBLE ])</a>
<a name="ln144">        ret += 10;</a>
<a name="ln145"> </a>
<a name="ln146">    if (prop[ ARTP_ANGRY ])</a>
<a name="ln147">        ret -= 3;</a>
<a name="ln148"> </a>
<a name="ln149">    if (prop[ ARTP_CAUSE_TELEPORTATION ])</a>
<a name="ln150">        ret -= 3;</a>
<a name="ln151"> </a>
<a name="ln152">    if (prop[ ARTP_NOISE ])</a>
<a name="ln153">        ret -= 5;</a>
<a name="ln154"> </a>
<a name="ln155">    if (prop[ ARTP_PREVENT_TELEPORTATION ])</a>
<a name="ln156">        ret -= 8;</a>
<a name="ln157"> </a>
<a name="ln158">    if (prop[ ARTP_PREVENT_SPELLCASTING ])</a>
<a name="ln159">        ret -= 10;</a>
<a name="ln160"> </a>
<a name="ln161">    if (prop[ ARTP_CONTAM ])</a>
<a name="ln162">        ret -= 8;</a>
<a name="ln163"> </a>
<a name="ln164">    if (prop[ ARTP_CORRODE ])</a>
<a name="ln165">        ret -= 8;</a>
<a name="ln166"> </a>
<a name="ln167">    if (prop[ ARTP_DRAIN ])</a>
<a name="ln168">        ret -= 8;</a>
<a name="ln169"> </a>
<a name="ln170">    if (prop[ ARTP_SLOW ])</a>
<a name="ln171">        ret -= 8;</a>
<a name="ln172"> </a>
<a name="ln173">    if (prop[ ARTP_FRAGILE ])</a>
<a name="ln174">        ret -= 8;</a>
<a name="ln175"> </a>
<a name="ln176">    if (prop[ ARTP_RMSL ])</a>
<a name="ln177">        ret += 20;</a>
<a name="ln178"> </a>
<a name="ln179">    if (prop[ ARTP_CLARITY ])</a>
<a name="ln180">        ret += 20;</a>
<a name="ln181"> </a>
<a name="ln182">    return (ret &gt; 0) ? ret : 0;</a>
<a name="ln183">}</a>
<a name="ln184"> </a>
<a name="ln185">unsigned int item_value(item_def item, bool ident)</a>
<a name="ln186">{</a>
<a name="ln187">    // Note that we pass item in by value, since we want a local</a>
<a name="ln188">    // copy to mangle as necessary.</a>
<a name="ln189">    item.flags = (ident) ? (item.flags | ISFLAG_IDENT_MASK) : (item.flags);</a>
<a name="ln190"> </a>
<a name="ln191">    if (is_unrandom_artefact(item)</a>
<a name="ln192">        &amp;&amp; item_ident(item, ISFLAG_KNOW_PROPERTIES))</a>
<a name="ln193">    {</a>
<a name="ln194">        const unrandart_entry *entry = get_unrand_entry(item.unrand_idx);</a>
<a name="ln195">        if (entry-&gt;value != 0)</a>
<a name="ln196">            return entry-&gt;value;</a>
<a name="ln197">    }</a>
<a name="ln198"> </a>
<a name="ln199">    int valued = 0;</a>
<a name="ln200"> </a>
<a name="ln201">    switch (item.base_type)</a>
<a name="ln202">    {</a>
<a name="ln203">    case OBJ_WEAPONS:</a>
<a name="ln204">        valued += weapon_base_price((weapon_type)item.sub_type);</a>
<a name="ln205"> </a>
<a name="ln206">        if (item_type_known(item))</a>
<a name="ln207">        {</a>
<a name="ln208">            switch (get_weapon_brand(item))</a>
<a name="ln209">            {</a>
<a name="ln210">            case SPWPN_NORMAL:</a>
<a name="ln211">            default:            // randart</a>
<a name="ln212">                valued *= 10;</a>
<a name="ln213">                break;</a>
<a name="ln214"> </a>
<a name="ln215">            case SPWPN_SPEED:</a>
<a name="ln216">            case SPWPN_VAMPIRISM:</a>
<a name="ln217">            case SPWPN_ANTIMAGIC:</a>
<a name="ln218">                valued *= 30;</a>
<a name="ln219">                break;</a>
<a name="ln220"> </a>
<a name="ln221">            case SPWPN_DISTORTION:</a>
<a name="ln222">            case SPWPN_ELECTROCUTION:</a>
<a name="ln223">            case SPWPN_PAIN:</a>
<a name="ln224">            case SPWPN_ACID: // Unrand-only.</a>
<a name="ln225">            case SPWPN_PENETRATION: // Unrand-only.</a>
<a name="ln226">                valued *= 25;</a>
<a name="ln227">                break;</a>
<a name="ln228"> </a>
<a name="ln229">            case SPWPN_CHAOS:</a>
<a name="ln230">            case SPWPN_DRAINING:</a>
<a name="ln231">            case SPWPN_FLAMING:</a>
<a name="ln232">            case SPWPN_FREEZING:</a>
<a name="ln233">            case SPWPN_HOLY_WRATH:</a>
<a name="ln234">                valued *= 18;</a>
<a name="ln235">                break;</a>
<a name="ln236"> </a>
<a name="ln237">            case SPWPN_VORPAL:</a>
<a name="ln238">                valued *= 15;</a>
<a name="ln239">                break;</a>
<a name="ln240"> </a>
<a name="ln241">            case SPWPN_PROTECTION:</a>
<a name="ln242">            case SPWPN_VENOM:</a>
<a name="ln243">                valued *= 12;</a>
<a name="ln244">                break;</a>
<a name="ln245">            }</a>
<a name="ln246"> </a>
<a name="ln247">            valued /= 10;</a>
<a name="ln248">        }</a>
<a name="ln249"> </a>
<a name="ln250">        if (item_ident(item, ISFLAG_KNOW_PLUSES))</a>
<a name="ln251">            valued += 50 * item.plus;</a>
<a name="ln252"> </a>
<a name="ln253">        if (is_artefact(item))</a>
<a name="ln254">        {</a>
<a name="ln255">            if (item_type_known(item))</a>
<a name="ln256">                valued += (7 * artefact_value(item));</a>
<a name="ln257">            else</a>
<a name="ln258">                valued += 50;</a>
<a name="ln259">        }</a>
<a name="ln260">        else if (item_type_known(item)</a>
<a name="ln261">                 &amp;&amp; get_equip_desc(item) != 0) // ???</a>
<a name="ln262">        {</a>
<a name="ln263">            valued += 20;</a>
<a name="ln264">        }</a>
<a name="ln265">        else if (!(item.flags &amp; ISFLAG_IDENT_MASK)</a>
<a name="ln266">                 &amp;&amp; (get_equip_desc(item) != 0))</a>
<a name="ln267">        {</a>
<a name="ln268">            valued += 30; // un-id'd &quot;glowing&quot; - arbitrary added cost</a>
<a name="ln269">        }</a>
<a name="ln270"> </a>
<a name="ln271">        if (item_known_cursed(item))</a>
<a name="ln272">            valued -= 30;</a>
<a name="ln273"> </a>
<a name="ln274">        break;</a>
<a name="ln275"> </a>
<a name="ln276">    case OBJ_MISSILES:          // ammunition</a>
<a name="ln277">        valued += missile_base_price((missile_type)item.sub_type);</a>
<a name="ln278"> </a>
<a name="ln279">        if (item_type_known(item))</a>
<a name="ln280">        {</a>
<a name="ln281">            switch (get_ammo_brand(item))</a>
<a name="ln282">            {</a>
<a name="ln283">            case SPMSL_NORMAL:</a>
<a name="ln284">            default:</a>
<a name="ln285">                valued *= 10;</a>
<a name="ln286">                break;</a>
<a name="ln287"> </a>
<a name="ln288">            case SPMSL_CHAOS:</a>
<a name="ln289">                valued *= 40;</a>
<a name="ln290">                break;</a>
<a name="ln291"> </a>
<a name="ln292">            case SPMSL_CURARE:</a>
<a name="ln293">            case SPMSL_BLINDING:</a>
<a name="ln294">            case SPMSL_SILVER:</a>
<a name="ln295">#if TAG_MAJOR_VERSION == 34</a>
<a name="ln296">            case SPMSL_PARALYSIS:</a>
<a name="ln297">            case SPMSL_PENETRATION:</a>
<a name="ln298">            case SPMSL_STEEL:</a>
<a name="ln299">#endif</a>
<a name="ln300">            case SPMSL_DISPERSAL:</a>
<a name="ln301">                valued *= 30;</a>
<a name="ln302">                break;</a>
<a name="ln303"> </a>
<a name="ln304">#if TAG_MAJOR_VERSION == 34</a>
<a name="ln305">            case SPMSL_FLAME:</a>
<a name="ln306">            case SPMSL_FROST:</a>
<a name="ln307">            case SPMSL_SLEEP:</a>
<a name="ln308">            case SPMSL_CONFUSION:</a>
<a name="ln309">                valued *= 25;</a>
<a name="ln310">                break;</a>
<a name="ln311">#endif</a>
<a name="ln312"> </a>
<a name="ln313">            case SPMSL_POISONED:</a>
<a name="ln314">#if TAG_MAJOR_VERSION == 34</a>
<a name="ln315">            case SPMSL_RETURNING:</a>
<a name="ln316">            case SPMSL_EXPLODING:</a>
<a name="ln317">            case SPMSL_SLOW:</a>
<a name="ln318">            case SPMSL_SICKNESS:</a>
<a name="ln319">#endif</a>
<a name="ln320">            case SPMSL_FRENZY:</a>
<a name="ln321">                valued *= 20;</a>
<a name="ln322">                break;</a>
<a name="ln323">            }</a>
<a name="ln324"> </a>
<a name="ln325">            valued /= 10;</a>
<a name="ln326">        }</a>
<a name="ln327">        break;</a>
<a name="ln328"> </a>
<a name="ln329">    case OBJ_ARMOUR:</a>
<a name="ln330">        valued += armour_base_price((armour_type)item.sub_type);</a>
<a name="ln331"> </a>
<a name="ln332">        if (item_type_known(item))</a>
<a name="ln333">        {</a>
<a name="ln334">            const int sparm = get_armour_ego_type(item);</a>
<a name="ln335">            switch (sparm)</a>
<a name="ln336">            {</a>
<a name="ln337">            case SPARM_RUNNING:</a>
<a name="ln338">            case SPARM_ARCHMAGI:</a>
<a name="ln339">            case SPARM_RESISTANCE:</a>
<a name="ln340">                valued += 250;</a>
<a name="ln341">                break;</a>
<a name="ln342"> </a>
<a name="ln343">            case SPARM_COLD_RESISTANCE:</a>
<a name="ln344">            case SPARM_DEXTERITY:</a>
<a name="ln345">            case SPARM_FIRE_RESISTANCE:</a>
<a name="ln346">            case SPARM_SEE_INVISIBLE:</a>
<a name="ln347">            case SPARM_INTELLIGENCE:</a>
<a name="ln348">            case SPARM_FLYING:</a>
<a name="ln349">            case SPARM_STEALTH:</a>
<a name="ln350">            case SPARM_STRENGTH:</a>
<a name="ln351">            case SPARM_INVISIBILITY:</a>
<a name="ln352">            case SPARM_MAGIC_RESISTANCE:</a>
<a name="ln353">            case SPARM_PROTECTION:</a>
<a name="ln354">            case SPARM_ARCHERY:</a>
<a name="ln355">            case SPARM_REPULSION:</a>
<a name="ln356">                valued += 50;</a>
<a name="ln357">                break;</a>
<a name="ln358"> </a>
<a name="ln359">            case SPARM_POSITIVE_ENERGY:</a>
<a name="ln360">            case SPARM_POISON_RESISTANCE:</a>
<a name="ln361">            case SPARM_REFLECTION:</a>
<a name="ln362">            case SPARM_SPIRIT_SHIELD:</a>
<a name="ln363">                valued += 20;</a>
<a name="ln364">                break;</a>
<a name="ln365"> </a>
<a name="ln366">            case SPARM_PONDEROUSNESS:</a>
<a name="ln367">                valued -= 250;</a>
<a name="ln368">                break;</a>
<a name="ln369">            }</a>
<a name="ln370">        }</a>
<a name="ln371"> </a>
<a name="ln372">        if (item_ident(item, ISFLAG_KNOW_PLUSES))</a>
<a name="ln373">            valued += 50 * item.plus;</a>
<a name="ln374"> </a>
<a name="ln375">        if (is_artefact(item))</a>
<a name="ln376">        {</a>
<a name="ln377">            if (item_type_known(item))</a>
<a name="ln378">                valued += (7 * artefact_value(item));</a>
<a name="ln379">            else</a>
<a name="ln380">                valued += 50;</a>
<a name="ln381">        }</a>
<a name="ln382">        else if (item_type_known(item) &amp;&amp; get_equip_desc(item) != 0)</a>
<a name="ln383">            valued += 20;  // ???</a>
<a name="ln384">        else if (!(item.flags &amp; ISFLAG_IDENT_MASK)</a>
<a name="ln385">                 &amp;&amp; (get_equip_desc(item) != 0))</a>
<a name="ln386">        {</a>
<a name="ln387">            valued += 30; // un-id'd &quot;glowing&quot; - arbitrary added cost</a>
<a name="ln388">        }</a>
<a name="ln389"> </a>
<a name="ln390">        if (item_known_cursed(item))</a>
<a name="ln391">            valued -= 30;</a>
<a name="ln392"> </a>
<a name="ln393">        break;</a>
<a name="ln394"> </a>
<a name="ln395">    case OBJ_WANDS:</a>
<a name="ln396">        if (!item_type_known(item))</a>
<a name="ln397">            valued += 40;</a>
<a name="ln398">        else</a>
<a name="ln399">        {</a>
<a name="ln400">            // true if the wand is of a good type, a type with significant</a>
<a name="ln401">            // inherent value even when empty. Good wands are less expensive</a>
<a name="ln402">            // per charge.</a>
<a name="ln403">            bool good = false;</a>
<a name="ln404">            switch (item.sub_type)</a>
<a name="ln405">            {</a>
<a name="ln406">            case WAND_CLOUDS:</a>
<a name="ln407">            case WAND_SCATTERSHOT:</a>
<a name="ln408">                valued += 120;</a>
<a name="ln409">                good = true;</a>
<a name="ln410">                break;</a>
<a name="ln411"> </a>
<a name="ln412">            case WAND_ACID:</a>
<a name="ln413">            case WAND_DIGGING:</a>
<a name="ln414">                valued += 80;</a>
<a name="ln415">                good = true;</a>
<a name="ln416">                break;</a>
<a name="ln417"> </a>
<a name="ln418">            case WAND_ICEBLAST:</a>
<a name="ln419">            case WAND_DISINTEGRATION:</a>
<a name="ln420">                valued += 40;</a>
<a name="ln421">                good = true;</a>
<a name="ln422">                break;</a>
<a name="ln423"> </a>
<a name="ln424">            case WAND_ENSLAVEMENT:</a>
<a name="ln425">            case WAND_POLYMORPH:</a>
<a name="ln426">            case WAND_PARALYSIS:</a>
<a name="ln427">                valued += 20;</a>
<a name="ln428">                break;</a>
<a name="ln429"> </a>
<a name="ln430">            case WAND_FLAME:</a>
<a name="ln431">            case WAND_RANDOM_EFFECTS:</a>
<a name="ln432">                valued += 10;</a>
<a name="ln433">                break;</a>
<a name="ln434"> </a>
<a name="ln435">            default:</a>
<a name="ln436">                valued += 6;</a>
<a name="ln437">                break;</a>
<a name="ln438">            }</a>
<a name="ln439"> </a>
<a name="ln440">            if (item_ident(item, ISFLAG_KNOW_PLUSES))</a>
<a name="ln441">            {</a>
<a name="ln442">                if (good) valued += (valued * item.plus) / 4;</a>
<a name="ln443">                else      valued += (valued * item.plus) / 2;</a>
<a name="ln444">            }</a>
<a name="ln445">        }</a>
<a name="ln446">        break;</a>
<a name="ln447"> </a>
<a name="ln448">    case OBJ_POTIONS:</a>
<a name="ln449">        if (!item_type_known(item))</a>
<a name="ln450">            valued += 9;</a>
<a name="ln451">        else</a>
<a name="ln452">        {</a>
<a name="ln453">            switch (item.sub_type)</a>
<a name="ln454">            {</a>
<a name="ln455">            case POT_EXPERIENCE:</a>
<a name="ln456">                valued += 500;</a>
<a name="ln457">                break;</a>
<a name="ln458"> </a>
<a name="ln459">            case POT_RESISTANCE:</a>
<a name="ln460">            case POT_HASTE:</a>
<a name="ln461">                valued += 100;</a>
<a name="ln462">                break;</a>
<a name="ln463"> </a>
<a name="ln464">            case POT_MAGIC:</a>
<a name="ln465">            case POT_INVISIBILITY:</a>
<a name="ln466">            case POT_CANCELLATION:</a>
<a name="ln467">            case POT_AMBROSIA:</a>
<a name="ln468">            case POT_MUTATION:</a>
<a name="ln469">                valued += 80;</a>
<a name="ln470">                break;</a>
<a name="ln471"> </a>
<a name="ln472">            case POT_BERSERK_RAGE:</a>
<a name="ln473">            case POT_HEAL_WOUNDS:</a>
<a name="ln474">                valued += 50;</a>
<a name="ln475">                break;</a>
<a name="ln476"> </a>
<a name="ln477">            case POT_MIGHT:</a>
<a name="ln478">            case POT_STABBING:</a>
<a name="ln479">            case POT_BRILLIANCE:</a>
<a name="ln480">                valued += 40;</a>
<a name="ln481">                break;</a>
<a name="ln482"> </a>
<a name="ln483">            case POT_CURING:</a>
<a name="ln484">            case POT_LIGNIFY:</a>
<a name="ln485">            case POT_FLIGHT:</a>
<a name="ln486">                valued += 30;</a>
<a name="ln487">                break;</a>
<a name="ln488"> </a>
<a name="ln489">            case POT_DEGENERATION:</a>
<a name="ln490">                valued += 10;</a>
<a name="ln491">                break;</a>
<a name="ln492"> </a>
<a name="ln493">            CASE_REMOVED_POTIONS(item.sub_type)</a>
<a name="ln494">            }</a>
<a name="ln495">        }</a>
<a name="ln496">        break;</a>
<a name="ln497"> </a>
<a name="ln498">    case OBJ_FOOD:</a>
<a name="ln499">        switch (item.sub_type)</a>
<a name="ln500">        {</a>
<a name="ln501">        case FOOD_RATION:</a>
<a name="ln502">            valued = 50;</a>
<a name="ln503">            break;</a>
<a name="ln504"> </a>
<a name="ln505">        case FOOD_CHUNK:</a>
<a name="ln506">        default:</a>
<a name="ln507">            break;</a>
<a name="ln508">        }</a>
<a name="ln509">        break;</a>
<a name="ln510"> </a>
<a name="ln511">    case OBJ_CORPSES:</a>
<a name="ln512">        valued = max_corpse_chunks(item.mon_type) * 5;</a>
<a name="ln513"> </a>
<a name="ln514">    case OBJ_SCROLLS:</a>
<a name="ln515">        if (!item_type_known(item))</a>
<a name="ln516">            valued += 10;</a>
<a name="ln517">        else</a>
<a name="ln518">        {</a>
<a name="ln519">            switch (item.sub_type)</a>
<a name="ln520">            {</a>
<a name="ln521">            case SCR_ACQUIREMENT:</a>
<a name="ln522">                valued += 520;</a>
<a name="ln523">                break;</a>
<a name="ln524"> </a>
<a name="ln525">            case SCR_BRAND_WEAPON:</a>
<a name="ln526">                valued += 200;</a>
<a name="ln527">                break;</a>
<a name="ln528"> </a>
<a name="ln529">            case SCR_SUMMONING:</a>
<a name="ln530">                valued += 95;</a>
<a name="ln531">                break;</a>
<a name="ln532"> </a>
<a name="ln533">            case SCR_BLINKING:</a>
<a name="ln534">            case SCR_ENCHANT_ARMOUR:</a>
<a name="ln535">            case SCR_ENCHANT_WEAPON:</a>
<a name="ln536">            case SCR_TORMENT:</a>
<a name="ln537">            case SCR_HOLY_WORD:</a>
<a name="ln538">            case SCR_SILENCE:</a>
<a name="ln539">            case SCR_VULNERABILITY:</a>
<a name="ln540">                valued += 75;</a>
<a name="ln541">                break;</a>
<a name="ln542"> </a>
<a name="ln543">            case SCR_AMNESIA:</a>
<a name="ln544">            case SCR_FEAR:</a>
<a name="ln545">            case SCR_IMMOLATION:</a>
<a name="ln546">            case SCR_MAGIC_MAPPING:</a>
<a name="ln547">                valued += 35;</a>
<a name="ln548">                break;</a>
<a name="ln549"> </a>
<a name="ln550">            case SCR_REMOVE_CURSE:</a>
<a name="ln551">            case SCR_TELEPORTATION:</a>
<a name="ln552">                valued += 30;</a>
<a name="ln553">                break;</a>
<a name="ln554"> </a>
<a name="ln555">            case SCR_FOG:</a>
<a name="ln556">            case SCR_IDENTIFY:</a>
<a name="ln557">#if TAG_MAJOR_VERSION == 34</a>
<a name="ln558">            case SCR_CURSE_ARMOUR:</a>
<a name="ln559">            case SCR_CURSE_WEAPON:</a>
<a name="ln560">            case SCR_CURSE_JEWELLERY:</a>
<a name="ln561">#endif</a>
<a name="ln562">                valued += 20;</a>
<a name="ln563">                break;</a>
<a name="ln564"> </a>
<a name="ln565">            case SCR_NOISE:</a>
<a name="ln566">            case SCR_RANDOM_USELESSNESS:</a>
<a name="ln567">                valued += 10;</a>
<a name="ln568">                break;</a>
<a name="ln569">            }</a>
<a name="ln570">        }</a>
<a name="ln571">        break;</a>
<a name="ln572"> </a>
<a name="ln573">    case OBJ_JEWELLERY:</a>
<a name="ln574">        if (item_known_cursed(item))</a>
<a name="ln575">            valued -= 30;</a>
<a name="ln576"> </a>
<a name="ln577">        if (!item_type_known(item))</a>
<a name="ln578">            valued += 50;</a>
<a name="ln579">        else</a>
<a name="ln580">        {</a>
<a name="ln581">            // Variable-strength rings.</a>
<a name="ln582">            if (item_ident(item, ISFLAG_KNOW_PLUSES)</a>
<a name="ln583">                &amp;&amp; (item.sub_type == RING_PROTECTION</a>
<a name="ln584">                    || item.sub_type == RING_STRENGTH</a>
<a name="ln585">                    || item.sub_type == RING_EVASION</a>
<a name="ln586">                    || item.sub_type == RING_DEXTERITY</a>
<a name="ln587">                    || item.sub_type == RING_INTELLIGENCE</a>
<a name="ln588">                    || item.sub_type == RING_SLAYING</a>
<a name="ln589">                    || item.sub_type == AMU_REFLECTION))</a>
<a name="ln590">            {</a>
<a name="ln591">                // Formula: price = kn(n+1) / 2, where k depends on the subtype,</a>
<a name="ln592">                // n is the power. (The base variable is equal to 2n.)</a>
<a name="ln593">                int base = 0;</a>
<a name="ln594">                int coefficient = 0;</a>
<a name="ln595">                if (item.sub_type == RING_SLAYING)</a>
<a name="ln596">                    base = 3 * item.plus;</a>
<a name="ln597">                else</a>
<a name="ln598">                    base = 2 * item.plus;</a>
<a name="ln599"> </a>
<a name="ln600">                switch (item.sub_type)</a>
<a name="ln601">                {</a>
<a name="ln602">                case RING_SLAYING:</a>
<a name="ln603">                case RING_PROTECTION:</a>
<a name="ln604">                case RING_EVASION:</a>
<a name="ln605">                    coefficient = 40;</a>
<a name="ln606">                    break;</a>
<a name="ln607">                case RING_STRENGTH:</a>
<a name="ln608">                case RING_DEXTERITY:</a>
<a name="ln609">                case RING_INTELLIGENCE:</a>
<a name="ln610">                case AMU_REFLECTION:</a>
<a name="ln611">                    coefficient = 30;</a>
<a name="ln612">                    break;</a>
<a name="ln613">                default:</a>
<a name="ln614">                    break;</a>
<a name="ln615">                }</a>
<a name="ln616"> </a>
<a name="ln617">                if (base &lt;= 0)</a>
<a name="ln618">                    valued += 25 * base;</a>
<a name="ln619">                else</a>
<a name="ln620">                    valued += (coefficient * base * (base + 1)) / 8;</a>
<a name="ln621">            }</a>
<a name="ln622">            else</a>
<a name="ln623">            {</a>
<a name="ln624">                switch (item.sub_type)</a>
<a name="ln625">                {</a>
<a name="ln626">                case AMU_FAITH:</a>
<a name="ln627">                case AMU_RAGE:</a>
<a name="ln628">                    valued += 400;</a>
<a name="ln629">                    break;</a>
<a name="ln630"> </a>
<a name="ln631">                case RING_WIZARDRY:</a>
<a name="ln632">                case AMU_REGENERATION:</a>
<a name="ln633">                case AMU_GUARDIAN_SPIRIT:</a>
<a name="ln634">                case AMU_THE_GOURMAND:</a>
<a name="ln635">                case AMU_HARM:</a>
<a name="ln636">                case AMU_MANA_REGENERATION:</a>
<a name="ln637">                case AMU_ACROBAT:</a>
<a name="ln638">                    valued += 300;</a>
<a name="ln639">                    break;</a>
<a name="ln640"> </a>
<a name="ln641">                case RING_FIRE:</a>
<a name="ln642">                case RING_ICE:</a>
<a name="ln643">                case RING_PROTECTION_FROM_COLD:</a>
<a name="ln644">                case RING_PROTECTION_FROM_FIRE:</a>
<a name="ln645">                case RING_PROTECTION_FROM_MAGIC:</a>
<a name="ln646">                    valued += 250;</a>
<a name="ln647">                    break;</a>
<a name="ln648"> </a>
<a name="ln649">                case RING_MAGICAL_POWER:</a>
<a name="ln650">                case RING_LIFE_PROTECTION:</a>
<a name="ln651">                case RING_POISON_RESISTANCE:</a>
<a name="ln652">                case RING_RESIST_CORROSION:</a>
<a name="ln653">                    valued += 200;</a>
<a name="ln654">                    break;</a>
<a name="ln655"> </a>
<a name="ln656">                case RING_STEALTH:</a>
<a name="ln657">                case RING_FLIGHT:</a>
<a name="ln658">                    valued += 175;</a>
<a name="ln659">                    break;</a>
<a name="ln660"> </a>
<a name="ln661">                case RING_SEE_INVISIBLE:</a>
<a name="ln662">                    valued += 150;</a>
<a name="ln663">                    break;</a>
<a name="ln664"> </a>
<a name="ln665">                case RING_ATTENTION:</a>
<a name="ln666">                case RING_TELEPORTATION:</a>
<a name="ln667">                case AMU_NOTHING:</a>
<a name="ln668">                    valued += 75;</a>
<a name="ln669">                    break;</a>
<a name="ln670"> </a>
<a name="ln671">                case AMU_INACCURACY:</a>
<a name="ln672">                    valued -= 300;</a>
<a name="ln673">                    break;</a>
<a name="ln674">                    // got to do delusion!</a>
<a name="ln675">                }</a>
<a name="ln676">            }</a>
<a name="ln677"> </a>
<a name="ln678">            if (is_artefact(item))</a>
<a name="ln679">            {</a>
<a name="ln680">                // in this branch we're guaranteed to know</a>
<a name="ln681">                // the item type!</a>
<a name="ln682">                if (valued &lt; 0)</a>
<a name="ln683">                    valued = (artefact_value(item) - 5) * 7;</a>
<a name="ln684">                else</a>
<a name="ln685">                    valued += artefact_value(item) * 7;</a>
<a name="ln686">            }</a>
<a name="ln687"> </a>
<a name="ln688">            // Hard minimum, as it's worth 20 to ID a ring.</a>
<a name="ln689">            valued = max(20, valued);</a>
<a name="ln690">        }</a>
<a name="ln691">        break;</a>
<a name="ln692"> </a>
<a name="ln693">    case OBJ_MISCELLANY:</a>
<a name="ln694">        switch (item.sub_type)</a>
<a name="ln695">        {</a>
<a name="ln696">        case MISC_HORN_OF_GERYON:</a>
<a name="ln697">        case MISC_ZIGGURAT:</a>
<a name="ln698">            valued += 5000;</a>
<a name="ln699">            break;</a>
<a name="ln700"> </a>
<a name="ln701">        case MISC_PHIAL_OF_FLOODS:</a>
<a name="ln702">        case MISC_LIGHTNING_ROD:</a>
<a name="ln703">            valued += 400;</a>
<a name="ln704">            break;</a>
<a name="ln705"> </a>
<a name="ln706">        case MISC_PHANTOM_MIRROR:</a>
<a name="ln707">            valued += 300;</a>
<a name="ln708">            break;</a>
<a name="ln709"> </a>
<a name="ln710">        case MISC_BOX_OF_BEASTS:</a>
<a name="ln711">            valued += 200;</a>
<a name="ln712">            break;</a>
<a name="ln713"> </a>
<a name="ln714">        case MISC_TIN_OF_TREMORSTONES:</a>
<a name="ln715">            valued += 150;</a>
<a name="ln716">            break;</a>
<a name="ln717"> </a>
<a name="ln718">        default:</a>
<a name="ln719">            valued += 200;</a>
<a name="ln720">        }</a>
<a name="ln721">        break;</a>
<a name="ln722"> </a>
<a name="ln723">    case OBJ_BOOKS:</a>
<a name="ln724">    {</a>
<a name="ln725">        valued = 150;</a>
<a name="ln726">        const book_type book = static_cast&lt;book_type&gt;(item.sub_type);</a>
<a name="ln727">#if TAG_MAJOR_VERSION == 34</a>
<a name="ln728">        if (book == BOOK_BUGGY_DESTRUCTION)</a>
<a name="ln729">            break;</a>
<a name="ln730">#endif</a>
<a name="ln731"> </a>
<a name="ln732">        if (item_type_known(item))</a>
<a name="ln733">        {</a>
<a name="ln734">            double rarity = 0;</a>
<a name="ln735">            if (is_random_artefact(item))</a>
<a name="ln736">            {</a>
<a name="ln737">                const vector&lt;spell_type&gt;&amp; spells = spells_in_book(item);</a>
<a name="ln738"> </a>
<a name="ln739">                int rarest = 0;</a>
<a name="ln740">                for (spell_type spell : spells)</a>
<a name="ln741">                {</a>
<a name="ln742">                    rarity += spell_rarity(spell);</a>
<a name="ln743">                    if (spell_rarity(spell) &gt; rarest)</a>
<a name="ln744">                        rarest = spell_rarity(spell);</a>
<a name="ln745">                }</a>
<a name="ln746">                rarity += rarest * 2;</a>
<a name="ln747">                rarity /= spells.size();</a>
<a name="ln748"> </a>
<a name="ln749">                // Surcharge for large books.</a>
<a name="ln750">                if (spells.size() &gt; 6)</a>
<a name="ln751">                    rarity *= spells.size() / 6;</a>
<a name="ln752"> </a>
<a name="ln753">            }</a>
<a name="ln754">            else</a>
<a name="ln755">                rarity = book_rarity(book);</a>
<a name="ln756"> </a>
<a name="ln757">            valued += (int)(rarity * 50.0);</a>
<a name="ln758">        }</a>
<a name="ln759">        break;</a>
<a name="ln760">    }</a>
<a name="ln761"> </a>
<a name="ln762">    case OBJ_STAVES:</a>
<a name="ln763">        valued = item_type_known(item) ? 250 : 120;</a>
<a name="ln764">        break;</a>
<a name="ln765"> </a>
<a name="ln766">    case OBJ_ORBS:</a>
<a name="ln767">        valued = 250000;</a>
<a name="ln768">        break;</a>
<a name="ln769"> </a>
<a name="ln770">    case OBJ_RUNES:</a>
<a name="ln771">        valued = 10000;</a>
<a name="ln772">        break;</a>
<a name="ln773"> </a>
<a name="ln774">    default:</a>
<a name="ln775">        break;</a>
<a name="ln776">    }                           // end switch</a>
<a name="ln777"> </a>
<a name="ln778">    if (valued &lt; 1)</a>
<a name="ln779">        valued = 1;</a>
<a name="ln780"> </a>
<a name="ln781">    valued = stepdown_value(valued, 1000, 1000, 10000, 10000);</a>
<a name="ln782"> </a>
<a name="ln783">    return item.quantity * valued;</a>
<a name="ln784">}</a>
<a name="ln785"> </a>
<a name="ln786">bool is_worthless_consumable(const item_def &amp;item)</a>
<a name="ln787">{</a>
<a name="ln788">    switch (item.base_type)</a>
<a name="ln789">    {</a>
<a name="ln790">    case OBJ_POTIONS:</a>
<a name="ln791">        switch (item.sub_type)</a>
<a name="ln792">        {</a>
<a name="ln793">        // Blood potions are worthless because they are easy to make.</a>
<a name="ln794">        case POT_DEGENERATION:</a>
<a name="ln795">            return true;</a>
<a name="ln796">        default:</a>
<a name="ln797">            return false;</a>
<a name="ln798">        CASE_REMOVED_POTIONS(item.sub_type)</a>
<a name="ln799">        }</a>
<a name="ln800">    case OBJ_SCROLLS:</a>
<a name="ln801">        switch (item.sub_type)</a>
<a name="ln802">        {</a>
<a name="ln803">#if TAG_MAJOR_VERSION == 34</a>
<a name="ln804">        case SCR_CURSE_ARMOUR:</a>
<a name="ln805">        case SCR_CURSE_WEAPON:</a>
<a name="ln806">        case SCR_CURSE_JEWELLERY:</a>
<a name="ln807">#endif</a>
<a name="ln808">        case SCR_NOISE:</a>
<a name="ln809">        case SCR_RANDOM_USELESSNESS:</a>
<a name="ln810">            return true;</a>
<a name="ln811">        default:</a>
<a name="ln812">            return false;</a>
<a name="ln813">        }</a>
<a name="ln814"> </a>
<a name="ln815">    // Only consumables are worthless.</a>
<a name="ln816">    default:</a>
<a name="ln817">        return false;</a>
<a name="ln818">    }</a>
<a name="ln819">}</a>
<a name="ln820"> </a>
<a name="ln821">static int _count_identical(const vector&lt;item_def&gt;&amp; stock, const item_def&amp; item)</a>
<a name="ln822">{</a>
<a name="ln823">    int count = 0;</a>
<a name="ln824">    for (const item_def&amp; other : stock)</a>
<a name="ln825">        if (ShoppingList::items_are_same(item, other))</a>
<a name="ln826">            count++;</a>
<a name="ln827"> </a>
<a name="ln828">    return count;</a>
<a name="ln829">}</a>
<a name="ln830"> </a>
<a name="ln831">/** Buy an item from a shop!</a>
<a name="ln832"> *</a>
<a name="ln833"> *  @param shop  the shop to purchase from.</a>
<a name="ln834"> *  @param pos   where the shop is located</a>
<a name="ln835"> *  @param index the index of the item to buy in shop.stock</a>
<a name="ln836"> *  @returns true if it went in your inventory, false otherwise.</a>
<a name="ln837"> */</a>
<a name="ln838">static bool _purchase(shop_struct&amp; shop, const level_pos&amp; pos, int index)</a>
<a name="ln839">{</a>
<a name="ln840">    item_def item = shop.stock[index]; // intentional copy</a>
<a name="ln841">    const int cost = item_price(item, shop);</a>
<a name="ln842">    shop.stock.erase(shop.stock.begin() + index);</a>
<a name="ln843"> </a>
<a name="ln844">    // Remove from shopping list if it's unique</a>
<a name="ln845">    // (i.e., if the shop has multiple scrolls of</a>
<a name="ln846">    // identify, don't remove the other scrolls</a>
<a name="ln847">    // from the shopping list if there's any</a>
<a name="ln848">    // left).</a>
<a name="ln849">    if (shopping_list.is_on_list(item, &amp;pos)</a>
<a name="ln850">        &amp;&amp; _count_identical(shop.stock, item) == 0)</a>
<a name="ln851">    {</a>
<a name="ln852">        shopping_list.del_thing(item, &amp;pos);</a>
<a name="ln853">    }</a>
<a name="ln854"> </a>
<a name="ln855">    // Take a note of the purchase.</a>
<a name="ln856">    take_note(Note(NOTE_BUY_ITEM, cost, 0,</a>
<a name="ln857">                   item.name(DESC_A).c_str()));</a>
<a name="ln858"> </a>
<a name="ln859">    // But take no further similar notes.</a>
<a name="ln860">    item.flags |= ISFLAG_NOTED_GET;</a>
<a name="ln861"> </a>
<a name="ln862">    if (fully_identified(item))</a>
<a name="ln863">        item.flags |= ISFLAG_NOTED_ID;</a>
<a name="ln864"> </a>
<a name="ln865">    you.del_gold(cost);</a>
<a name="ln866"> </a>
<a name="ln867">    you.attribute[ATTR_PURCHASES] += cost;</a>
<a name="ln868"> </a>
<a name="ln869">    origin_purchased(item);</a>
<a name="ln870"> </a>
<a name="ln871">    if (shoptype_identifies_stock(shop.type))</a>
<a name="ln872">    {</a>
<a name="ln873">        // Identify the item and its type.</a>
<a name="ln874">        // This also takes the ID note if necessary.</a>
<a name="ln875">        set_ident_type(item, true);</a>
<a name="ln876">        set_ident_flags(item, ISFLAG_IDENT_MASK);</a>
<a name="ln877">    }</a>
<a name="ln878"> </a>
<a name="ln879">    // Shopkeepers will place goods you can't carry outside the shop.</a>
<a name="ln880">    if (item_is_stationary(item)</a>
<a name="ln881">        || !move_item_to_inv(item))</a>
<a name="ln882">    {</a>
<a name="ln883">        copy_item_to_grid(item, shop.pos);</a>
<a name="ln884">        return false;</a>
<a name="ln885">    }</a>
<a name="ln886">    return true;</a>
<a name="ln887">}</a>
<a name="ln888"> </a>
<a name="ln889">static string _hyphenated_letters(int how_many, char first)</a>
<a name="ln890">{</a>
<a name="ln891">    string s = &quot;&lt;w&gt;&quot;;</a>
<a name="ln892">    s += first;</a>
<a name="ln893">    s += &quot;&lt;/w&gt;&quot;;</a>
<a name="ln894">    if (how_many &gt; 1)</a>
<a name="ln895">    {</a>
<a name="ln896">        s += &quot;-&lt;w&gt;&quot;;</a>
<a name="ln897">        s += first + how_many - 1;</a>
<a name="ln898">        s += &quot;&lt;/w&gt;&quot;;</a>
<a name="ln899">    }</a>
<a name="ln900">    return s;</a>
<a name="ln901">}</a>
<a name="ln902"> </a>
<a name="ln903">enum shopping_order</a>
<a name="ln904">{</a>
<a name="ln905">    ORDER_DEFAULT,</a>
<a name="ln906">    ORDER_PRICE,</a>
<a name="ln907">    ORDER_ALPHABETICAL,</a>
<a name="ln908">    ORDER_TYPE,</a>
<a name="ln909">    NUM_ORDERS</a>
<a name="ln910">};</a>
<a name="ln911"> </a>
<a name="ln912">static const char * const shopping_order_names[NUM_ORDERS] =</a>
<a name="ln913">{</a>
<a name="ln914">    &quot;default&quot;, &quot;price&quot;, &quot;name&quot;, &quot;type&quot;</a>
<a name="ln915">};</a>
<a name="ln916"> </a>
<a name="ln917">static shopping_order operator++(shopping_order &amp;x)</a>
<a name="ln918">{</a>
<a name="ln919">    x = static_cast&lt;shopping_order&gt;(x + 1);</a>
<a name="ln920">    if (x == NUM_ORDERS)</a>
<a name="ln921">        x = ORDER_DEFAULT;</a>
<a name="ln922">    return x;</a>
<a name="ln923">}</a>
<a name="ln924"> </a>
<a name="ln925">class ShopMenu : public InvMenu</a>
<a name="ln926">{</a>
<a name="ln927">    friend class ShopEntry;</a>
<a name="ln928"> </a>
<a name="ln929">    shop_struct&amp; shop;</a>
<a name="ln930">    shopping_order order = ORDER_DEFAULT;</a>
<a name="ln931">    level_pos pos;</a>
<a name="ln932">    bool can_purchase;</a>
<a name="ln933"> </a>
<a name="ln934">    int selected_cost() const;</a>
<a name="ln935"> </a>
<a name="ln936">    void init_entries();</a>
<a name="ln937">    void update_help();</a>
<a name="ln938">    void resort();</a>
<a name="ln939">    void purchase_selected();</a>
<a name="ln940"> </a>
<a name="ln941">    virtual bool process_key(int keyin) override;</a>
<a name="ln942"> </a>
<a name="ln943">public:</a>
<a name="ln944">    bool bought_something = false;</a>
<a name="ln945"> </a>
<a name="ln946">    ShopMenu(shop_struct&amp; _shop, const level_pos&amp; _pos, bool _can_purchase);</a>
<a name="ln947">};</a>
<a name="ln948"> </a>
<a name="ln949">class ShopEntry : public InvEntry</a>
<a name="ln950">{</a>
<a name="ln951">    ShopMenu&amp; menu;</a>
<a name="ln952"> </a>
<a name="ln953">    string get_text(bool need_cursor = false) const override</a>
<a name="ln954">    {</a>
<a name="ln955">        need_cursor = need_cursor &amp;&amp; show_cursor;</a>
<a name="ln956">        const int cost = item_price(*item, menu.shop);</a>
<a name="ln957">        const int total_cost = menu.selected_cost();</a>
<a name="ln958">        const bool on_list = shopping_list.is_on_list(*item, &amp;menu.pos);</a>
<a name="ln959">        // Colour stock as follows:</a>
<a name="ln960">        //  * lightcyan, if on the shopping list and not selected.</a>
<a name="ln961">        //  * lightred, if you can't buy all you selected.</a>
<a name="ln962">        //  * lightgreen, if this item is purchasable along with your selections</a>
<a name="ln963">        //  * red, if this item is not purchasable even by itself.</a>
<a name="ln964">        //  * yellow, if this item would be purchasable if you deselected</a>
<a name="ln965">        //            something else.</a>
<a name="ln966"> </a>
<a name="ln967">        // Is this too complicated? (jpeg)</a>
<a name="ln968">        const colour_t keycol =</a>
<a name="ln969">            !selected() &amp;&amp; on_list              ? LIGHTCYAN :</a>
<a name="ln970">            selected() &amp;&amp; total_cost &gt; you.gold ? LIGHTRED  :</a>
<a name="ln971">            cost &lt;= you.gold - total_cost       ? LIGHTGREEN :</a>
<a name="ln972">            cost &gt; you.gold                     ? RED :</a>
<a name="ln973">                                                  YELLOW;</a>
<a name="ln974">        const string keystr = colour_to_str(keycol);</a>
<a name="ln975">        const string itemstr =</a>
<a name="ln976">            colour_to_str(menu_colour(text, item_prefix(*item), tag));</a>
<a name="ln977">        return make_stringf(&quot; &lt;%s&gt;%c%c%c%c&lt;/%s&gt;&lt;%s&gt;%4d gold   %s%s&lt;/%s&gt;&quot;,</a>
<a name="ln978">                            keystr.c_str(),</a>
<a name="ln979">                            hotkeys[0],</a>
<a name="ln980">                            need_cursor ? '[' : ' ',</a>
<a name="ln981">                            selected() ? '+' : on_list ? '$' : '-',</a>
<a name="ln982">                            need_cursor ? ']' : ' ',</a>
<a name="ln983">                            keystr.c_str(),</a>
<a name="ln984">                            itemstr.c_str(),</a>
<a name="ln985">                            cost,</a>
<a name="ln986">                            text.c_str(),</a>
<a name="ln987">                            shop_item_unknown(*item) ? &quot; (unknown)&quot; : &quot;&quot;,</a>
<a name="ln988">                            itemstr.c_str());</a>
<a name="ln989">    }</a>
<a name="ln990"> </a>
<a name="ln991">    virtual void select(int qty = -1) override</a>
<a name="ln992">    {</a>
<a name="ln993">        if (shopping_list.is_on_list(*item, &amp;menu.pos) &amp;&amp; qty != 0)</a>
<a name="ln994">            shopping_list.del_thing(*item, &amp;menu.pos);</a>
<a name="ln995"> </a>
<a name="ln996">        InvEntry::select(qty);</a>
<a name="ln997">    }</a>
<a name="ln998">public:</a>
<a name="ln999">    ShopEntry(const item_def&amp; i, ShopMenu&amp; m)</a>
<a name="ln1000">        : InvEntry(i),</a>
<a name="ln1001">          menu(m)</a>
<a name="ln1002">    {</a>
<a name="ln1003">        show_background = false;</a>
<a name="ln1004">    }</a>
<a name="ln1005">};</a>
<a name="ln1006"> </a>
<a name="ln1007">ShopMenu::ShopMenu(shop_struct&amp; _shop, const level_pos&amp; _pos, bool _can_purchase)</a>
<a name="ln1008">    : InvMenu(MF_MULTISELECT | MF_NO_SELECT_QTY | MF_QUIET_SELECT</a>
<a name="ln1009">               | MF_ALWAYS_SHOW_MORE | MF_ALLOW_FORMATTING),</a>
<a name="ln1010">      shop(_shop),</a>
<a name="ln1011">      pos(_pos),</a>
<a name="ln1012">      can_purchase(_can_purchase)</a>
<a name="ln1013">{</a>
<a name="ln1014">    menu_action = can_purchase ? ACT_EXECUTE : ACT_EXAMINE;</a>
<a name="ln1015">    set_flags(get_flags() &amp; ~MF_USE_TWO_COLUMNS);</a>
<a name="ln1016"> </a>
<a name="ln1017">    set_tag(&quot;shop&quot;);</a>
<a name="ln1018"> </a>
<a name="ln1019">    init_entries();</a>
<a name="ln1020"> </a>
<a name="ln1021">    update_help();</a>
<a name="ln1022"> </a>
<a name="ln1023">    set_title(&quot;Welcome to &quot; + shop_name(shop) + &quot;! What would you &quot;</a>
<a name="ln1024">              &quot;like to do?&quot;);</a>
<a name="ln1025">}</a>
<a name="ln1026"> </a>
<a name="ln1027">void ShopMenu::init_entries()</a>
<a name="ln1028">{</a>
<a name="ln1029">    menu_letter ckey = 'a';</a>
<a name="ln1030">    for (item_def&amp; item : shop.stock)</a>
<a name="ln1031">    {</a>
<a name="ln1032">        auto newentry = make_unique&lt;ShopEntry&gt;(item, *this);</a>
<a name="ln1033">        newentry-&gt;hotkeys.clear();</a>
<a name="ln1034">        newentry-&gt;add_hotkey(ckey++);</a>
<a name="ln1035">        add_entry(move(newentry));</a>
<a name="ln1036">    }</a>
<a name="ln1037">}</a>
<a name="ln1038"> </a>
<a name="ln1039">int ShopMenu::selected_cost() const</a>
<a name="ln1040">{</a>
<a name="ln1041">    int cost = 0;</a>
<a name="ln1042">    for (auto item : selected_entries())</a>
<a name="ln1043">        cost += item_price(*dynamic_cast&lt;ShopEntry*&gt;(item)-&gt;item, shop);</a>
<a name="ln1044">    return cost;</a>
<a name="ln1045">}</a>
<a name="ln1046"> </a>
<a name="ln1047">void ShopMenu::update_help()</a>
<a name="ln1048">{</a>
<a name="ln1049">    string top_line = make_stringf(&quot;&lt;yellow&gt;You have %d gold piece%s.&quot;,</a>
<a name="ln1050">                                   you.gold,</a>
<a name="ln1051">                                   you.gold != 1 ? &quot;s&quot; : &quot;&quot;);</a>
<a name="ln1052">    const int total_cost = selected_cost();</a>
<a name="ln1053">    if (total_cost &gt; you.gold)</a>
<a name="ln1054">    {</a>
<a name="ln1055">        top_line += &quot;&lt;lightred&gt;&quot;;</a>
<a name="ln1056">        top_line +=</a>
<a name="ln1057">            make_stringf(&quot; You are short %d gold piece%s for the purchase.&quot;,</a>
<a name="ln1058">                         total_cost - you.gold,</a>
<a name="ln1059">                         (total_cost - you.gold != 1) ? &quot;s&quot; : &quot;&quot;);</a>
<a name="ln1060">        top_line += &quot;&lt;/lightred&gt;&quot;;</a>
<a name="ln1061">    }</a>
<a name="ln1062">    else if (total_cost)</a>
<a name="ln1063">    {</a>
<a name="ln1064">        top_line +=</a>
<a name="ln1065">            make_stringf(&quot; After the purchase, you will have %d gold piece%s.&quot;,</a>
<a name="ln1066">                         you.gold - total_cost,</a>
<a name="ln1067">                         (you.gold - total_cost != 1) ? &quot;s&quot; : &quot;&quot;);</a>
<a name="ln1068">    }</a>
<a name="ln1069">    top_line += &quot;&lt;/yellow&gt;&quot;;</a>
<a name="ln1070"> </a>
<a name="ln1071">    // Ensure length &gt;= 80ch, which prevents the local tiles menu from resizing</a>
<a name="ln1072">    // as the player selects/deselects entries. Blegh..</a>
<a name="ln1073">    int top_line_width = strwidth(formatted_string::parse_string(top_line).tostring());</a>
<a name="ln1074">    top_line += string(max(0, 80 - top_line_width), ' ') + '\n';</a>
<a name="ln1075"> </a>
<a name="ln1076">    set_more(formatted_string::parse_string(top_line + make_stringf(</a>
<a name="ln1077">        //You have 0 gold pieces.</a>
<a name="ln1078">        //[Esc/R-Click] exit  [!] buy|examine items  [a-i] select item for purchase</a>
<a name="ln1079">        //[/] sort (default)  [Enter] make purchase  [A-I] put item on shopping list</a>
<a name="ln1080">#if defined(USE_TILE) &amp;&amp; !defined(TOUCH_UI)</a>
<a name="ln1081">        &quot;[&lt;w&gt;Esc&lt;/w&gt;/&lt;w&gt;R-Click&lt;/w&gt;] exit  &quot;</a>
<a name="ln1082">#else</a>
<a name="ln1083">        //               &quot;/R-Click&quot;</a>
<a name="ln1084">        &quot;[&lt;w&gt;Esc&lt;/w&gt;] exit          &quot;</a>
<a name="ln1085">#endif</a>
<a name="ln1086">        &quot;%s  [%s] %s\n&quot;</a>
<a name="ln1087">        &quot;[&lt;w&gt;/&lt;/w&gt;] sort (%s)%s  %s  [%s] put item on shopping list&quot;,</a>
<a name="ln1088">        !can_purchase ? &quot; &quot; &quot; &quot;  &quot;  &quot; &quot;       &quot;  &quot;          &quot; :</a>
<a name="ln1089">        menu_action == ACT_EXECUTE ? &quot;[&lt;w&gt;!&lt;/w&gt;] &lt;w&gt;buy&lt;/w&gt;|examine items&quot; :</a>
<a name="ln1090">                                     &quot;[&lt;w&gt;!&lt;/w&gt;] buy|&lt;w&gt;examine&lt;/w&gt; items&quot;,</a>
<a name="ln1091">        _hyphenated_letters(item_count(), 'a').c_str(),</a>
<a name="ln1092">        menu_action == ACT_EXECUTE ? &quot;select item for purchase&quot; : &quot;examine item&quot;,</a>
<a name="ln1093">        shopping_order_names[order],</a>
<a name="ln1094">        // strwidth(&quot;default&quot;)</a>
<a name="ln1095">        string(7 - strwidth(shopping_order_names[order]), ' ').c_str(),</a>
<a name="ln1096">        !can_purchase ? &quot; &quot; &quot;     &quot;  &quot;               &quot; :</a>
<a name="ln1097">                        &quot;[&lt;w&gt;Enter&lt;/w&gt;] make purchase&quot;,</a>
<a name="ln1098">        _hyphenated_letters(item_count(), 'A').c_str())));</a>
<a name="ln1099">}</a>
<a name="ln1100"> </a>
<a name="ln1101">void ShopMenu::purchase_selected()</a>
<a name="ln1102">{</a>
<a name="ln1103">    bool buying_from_list = false;</a>
<a name="ln1104">    vector&lt;MenuEntry*&gt; selected = selected_entries();</a>
<a name="ln1105">    int cost = selected_cost();</a>
<a name="ln1106">    if (selected.empty())</a>
<a name="ln1107">    {</a>
<a name="ln1108">        ASSERT(cost == 0);</a>
<a name="ln1109">        buying_from_list = true;</a>
<a name="ln1110">        for (auto item : items)</a>
<a name="ln1111">        {</a>
<a name="ln1112">            const item_def&amp; it = *dynamic_cast&lt;ShopEntry*&gt;(item)-&gt;item;</a>
<a name="ln1113">            if (shopping_list.is_on_list(it, &amp;pos))</a>
<a name="ln1114">            {</a>
<a name="ln1115">                selected.push_back(item);</a>
<a name="ln1116">                cost += item_price(it, shop);</a>
<a name="ln1117">            }</a>
<a name="ln1118">        }</a>
<a name="ln1119">    }</a>
<a name="ln1120">    if (selected.empty())</a>
<a name="ln1121">        return;</a>
<a name="ln1122">    const string col = colour_to_str(channel_to_colour(MSGCH_PROMPT));</a>
<a name="ln1123">    update_help();</a>
<a name="ln1124">    const formatted_string old_more = more;</a>
<a name="ln1125">    if (cost &gt; you.gold)</a>
<a name="ln1126">    {</a>
<a name="ln1127">        more = formatted_string::parse_string(make_stringf(</a>
<a name="ln1128">                   &quot;&lt;%s&gt;You don't have enough money.&lt;/%s&gt;\n&quot;,</a>
<a name="ln1129">                   col.c_str(),</a>
<a name="ln1130">                   col.c_str()));</a>
<a name="ln1131">        more += old_more;</a>
<a name="ln1132">        update_more();</a>
<a name="ln1133">        return;</a>
<a name="ln1134">    }</a>
<a name="ln1135">    more = formatted_string::parse_string(make_stringf(</a>
<a name="ln1136">               &quot;&lt;%s&gt;Purchase items%s for %d gold? (%s/N)&lt;/%s&gt;\n&quot;,</a>
<a name="ln1137">               col.c_str(),</a>
<a name="ln1138">               buying_from_list ? &quot; in shopping list&quot; : &quot;&quot;,</a>
<a name="ln1139">               cost,</a>
<a name="ln1140">               Options.easy_confirm == easy_confirm_type::none ? &quot;Y&quot; : &quot;y&quot;,</a>
<a name="ln1141">               col.c_str()));</a>
<a name="ln1142">    more += old_more;</a>
<a name="ln1143">    update_more();</a>
<a name="ln1144">    if (!yesno(nullptr, true, 'n', false, false, true))</a>
<a name="ln1145">    {</a>
<a name="ln1146">        more = old_more;</a>
<a name="ln1147">        update_more();</a>
<a name="ln1148">        return;</a>
<a name="ln1149">    }</a>
<a name="ln1150">    sort(begin(selected), end(selected),</a>
<a name="ln1151">         [](MenuEntry* a, MenuEntry* b)</a>
<a name="ln1152">         {</a>
<a name="ln1153">             return a-&gt;data &gt; b-&gt;data;</a>
<a name="ln1154">         });</a>
<a name="ln1155">    vector&lt;int&gt; bought_indices;</a>
<a name="ln1156">    int outside_items = 0;</a>
<a name="ln1157"> </a>
<a name="ln1158">    // Store last_pickup in case we need to restore it.</a>
<a name="ln1159">    // Then clear it to fill with items purchased.</a>
<a name="ln1160">    map&lt;int,int&gt; tmp_l_p = you.last_pickup;</a>
<a name="ln1161">    you.last_pickup.clear();</a>
<a name="ln1162"> </a>
<a name="ln1163">    // Will iterate backwards through the shop (because of the earlier sort).</a>
<a name="ln1164">    // This means we can erase() from shop.stock (since it only invalidates</a>
<a name="ln1165">    // pointers to later elements), but nothing else.</a>
<a name="ln1166">    for (auto entry : selected)</a>
<a name="ln1167">    {</a>
<a name="ln1168">        const int i = static_cast&lt;item_def*&gt;(entry-&gt;data) - shop.stock.data();</a>
<a name="ln1169">        item_def&amp; item(shop.stock[i]);</a>
<a name="ln1170">        // Can happen if the price changes due to id status</a>
<a name="ln1171">        if (item_price(item, shop) &gt; you.gold)</a>
<a name="ln1172">            continue;</a>
<a name="ln1173">        const int quant = item.quantity;</a>
<a name="ln1174"> </a>
<a name="ln1175">        if (!_purchase(shop, pos, i))</a>
<a name="ln1176">        {</a>
<a name="ln1177">            // The purchased item didn't fit into your</a>
<a name="ln1178">            // knapsack.</a>
<a name="ln1179">            outside_items += quant;</a>
<a name="ln1180">        }</a>
<a name="ln1181"> </a>
<a name="ln1182">        bought_indices.push_back(i);</a>
<a name="ln1183">        bought_something = true;</a>
<a name="ln1184">    }</a>
<a name="ln1185"> </a>
<a name="ln1186">    if (you.last_pickup.empty())</a>
<a name="ln1187">        you.last_pickup = tmp_l_p;</a>
<a name="ln1188"> </a>
<a name="ln1189">    // Since the old ShopEntrys may now point to past the end of shop.stock (or</a>
<a name="ln1190">    // just the wrong place in general) nuke the whole thing and start over.</a>
<a name="ln1191">    deleteAll(items);</a>
<a name="ln1192">    init_entries();</a>
<a name="ln1193">    resort();</a>
<a name="ln1194"> </a>
<a name="ln1195">    if (outside_items)</a>
<a name="ln1196">    {</a>
<a name="ln1197">        update_help();</a>
<a name="ln1198">        const formatted_string next_more = more;</a>
<a name="ln1199">        more = formatted_string::parse_string(make_stringf(</a>
<a name="ln1200">            &quot;&lt;%s&gt;I'll put %s outside for you.&lt;/%s&gt;\n&quot;,</a>
<a name="ln1201">            col.c_str(),</a>
<a name="ln1202">            bought_indices.size() == 1             ? &quot;it&quot; :</a>
<a name="ln1203">      (int) bought_indices.size() == outside_items ? &quot;them&quot;</a>
<a name="ln1204">                                                   : &quot;some of them&quot;,</a>
<a name="ln1205">            col.c_str()));</a>
<a name="ln1206">        more += next_more;</a>
<a name="ln1207">        update_more();</a>
<a name="ln1208">    }</a>
<a name="ln1209">    else</a>
<a name="ln1210">        update_help();</a>
<a name="ln1211"> </a>
<a name="ln1212">    update_menu(true);</a>
<a name="ln1213">}</a>
<a name="ln1214"> </a>
<a name="ln1215">// Doesn't handle redrawing itself.</a>
<a name="ln1216">void ShopMenu::resort()</a>
<a name="ln1217">{</a>
<a name="ln1218">    switch (order)</a>
<a name="ln1219">    {</a>
<a name="ln1220">    case ORDER_DEFAULT:</a>
<a name="ln1221">        sort(begin(items), end(items),</a>
<a name="ln1222">             [](MenuEntry* a, MenuEntry* b)</a>
<a name="ln1223">             {</a>
<a name="ln1224">                 return a-&gt;data &lt; b-&gt;data;</a>
<a name="ln1225">             });</a>
<a name="ln1226">        break;</a>
<a name="ln1227">    case ORDER_PRICE:</a>
<a name="ln1228">        sort(begin(items), end(items),</a>
<a name="ln1229">             [this](MenuEntry* a, MenuEntry* b)</a>
<a name="ln1230">             {</a>
<a name="ln1231">                 return item_price(*dynamic_cast&lt;ShopEntry*&gt;(a)-&gt;item, shop)</a>
<a name="ln1232">                        &lt; item_price(*dynamic_cast&lt;ShopEntry*&gt;(b)-&gt;item, shop);</a>
<a name="ln1233">             });</a>
<a name="ln1234">        break;</a>
<a name="ln1235">    case ORDER_ALPHABETICAL:</a>
<a name="ln1236">        sort(begin(items), end(items),</a>
<a name="ln1237">             [this](MenuEntry* a, MenuEntry* b) -&gt; bool</a>
<a name="ln1238">             {</a>
<a name="ln1239">                 const bool id = shoptype_identifies_stock(shop.type);</a>
<a name="ln1240">                 return dynamic_cast&lt;ShopEntry*&gt;(a)-&gt;item-&gt;name(DESC_PLAIN, false, id)</a>
<a name="ln1241">                        &lt; dynamic_cast&lt;ShopEntry*&gt;(b)-&gt;item-&gt;name(DESC_PLAIN, false, id);</a>
<a name="ln1242">             });</a>
<a name="ln1243">        break;</a>
<a name="ln1244">    case ORDER_TYPE:</a>
<a name="ln1245">        sort(begin(items), end(items),</a>
<a name="ln1246">             [](MenuEntry* a, MenuEntry* b) -&gt; bool</a>
<a name="ln1247">             {</a>
<a name="ln1248">                 const auto ai = dynamic_cast&lt;ShopEntry*&gt;(a)-&gt;item;</a>
<a name="ln1249">                 const auto bi = dynamic_cast&lt;ShopEntry*&gt;(b)-&gt;item;</a>
<a name="ln1250">                 if (ai-&gt;base_type == bi-&gt;base_type)</a>
<a name="ln1251">                     return ai-&gt;sub_type &lt; bi-&gt;sub_type;</a>
<a name="ln1252">                 else</a>
<a name="ln1253">                     return ai-&gt;base_type &lt; bi-&gt;base_type;</a>
<a name="ln1254">             });</a>
<a name="ln1255">        break;</a>
<a name="ln1256">    case NUM_ORDERS:</a>
<a name="ln1257">        die(&quot;invalid ordering&quot;);</a>
<a name="ln1258">    }</a>
<a name="ln1259">    for (size_t i = 0; i &lt; items.size(); ++i)</a>
<a name="ln1260">        items[i]-&gt;hotkeys[0] = index_to_letter(i);</a>
<a name="ln1261">}</a>
<a name="ln1262"> </a>
<a name="ln1263">bool ShopMenu::process_key(int keyin)</a>
<a name="ln1264">{</a>
<a name="ln1265">    switch (keyin)</a>
<a name="ln1266">    {</a>
<a name="ln1267">    case '!':</a>
<a name="ln1268">    case '?':</a>
<a name="ln1269">        if (can_purchase)</a>
<a name="ln1270">        {</a>
<a name="ln1271">            if (menu_action == ACT_EXECUTE)</a>
<a name="ln1272">                menu_action = ACT_EXAMINE;</a>
<a name="ln1273">            else</a>
<a name="ln1274">                menu_action = ACT_EXECUTE;</a>
<a name="ln1275">            update_help();</a>
<a name="ln1276">            update_more();</a>
<a name="ln1277">        }</a>
<a name="ln1278">        return true;</a>
<a name="ln1279">    case ' ':</a>
<a name="ln1280">    case CK_MOUSE_CLICK:</a>
<a name="ln1281">    case CK_ENTER:</a>
<a name="ln1282">        if (can_purchase)</a>
<a name="ln1283">            purchase_selected();</a>
<a name="ln1284">        return true;</a>
<a name="ln1285">    case '$':</a>
<a name="ln1286">    {</a>
<a name="ln1287">        const vector&lt;MenuEntry*&gt; selected = selected_entries();</a>
<a name="ln1288">        if (!selected.empty())</a>
<a name="ln1289">        {</a>
<a name="ln1290">            // Move selected to shopping list.</a>
<a name="ln1291">            for (auto entry : selected)</a>
<a name="ln1292">            {</a>
<a name="ln1293">                const item_def&amp; item = *dynamic_cast&lt;ShopEntry*&gt;(entry)-&gt;item;</a>
<a name="ln1294">                entry-&gt;selected_qty = 0;</a>
<a name="ln1295">                if (!shopping_list.is_on_list(item, &amp;pos))</a>
<a name="ln1296">                    shopping_list.add_thing(item, item_price(item, shop), &amp;pos);</a>
<a name="ln1297">            }</a>
<a name="ln1298">        }</a>
<a name="ln1299">        else</a>
<a name="ln1300">            // Move shoplist to selection.</a>
<a name="ln1301">            for (auto entry : items)</a>
<a name="ln1302">                if (shopping_list.is_on_list(*dynamic_cast&lt;ShopEntry*&gt;(entry)-&gt;item, &amp;pos))</a>
<a name="ln1303">                    entry-&gt;select(-2);</a>
<a name="ln1304">        // Move shoplist to selection.</a>
<a name="ln1305">        update_menu(true);</a>
<a name="ln1306">        return true;</a>
<a name="ln1307">    }</a>
<a name="ln1308">    case '/':</a>
<a name="ln1309">        ++order;</a>
<a name="ln1310">        resort();</a>
<a name="ln1311">        update_help();</a>
<a name="ln1312">        update_menu(true);</a>
<a name="ln1313">        return true;</a>
<a name="ln1314">    default:</a>
<a name="ln1315">        break;</a>
<a name="ln1316">    }</a>
<a name="ln1317"> </a>
<a name="ln1318">    if (keyin - 'a' &gt;= 0 &amp;&amp; keyin - 'a' &lt; (int)items.size()</a>
<a name="ln1319">        &amp;&amp; menu_action == ACT_EXAMINE)</a>
<a name="ln1320">    {</a>
<a name="ln1321">        item_def&amp; item(*const_cast&lt;item_def*&gt;(dynamic_cast&lt;ShopEntry*&gt;(</a>
<a name="ln1322">            items[letter_to_index(keyin)])-&gt;item));</a>
<a name="ln1323">        // A hack to make the description more useful.</a>
<a name="ln1324">        // In theory, the user could kill the process at this</a>
<a name="ln1325">        // point and end up with valid ID for the item.</a>
<a name="ln1326">        // That's not very useful, though, because it doesn't set</a>
<a name="ln1327">        // type-ID and once you can access the item (by buying it)</a>
<a name="ln1328">        // you have its full ID anyway. Worst case, it won't get</a>
<a name="ln1329">        // noted when you buy it.</a>
<a name="ln1330">        {</a>
<a name="ln1331">            unwind_var&lt;iflags_t&gt; old_flags(item.flags);</a>
<a name="ln1332">            if (shoptype_identifies_stock(shop.type))</a>
<a name="ln1333">            {</a>
<a name="ln1334">                item.flags |= (ISFLAG_IDENT_MASK | ISFLAG_NOTED_ID</a>
<a name="ln1335">                               | ISFLAG_NOTED_GET);</a>
<a name="ln1336">            }</a>
<a name="ln1337">            describe_item(item);</a>
<a name="ln1338">        }</a>
<a name="ln1339">        return true;</a>
<a name="ln1340">    }</a>
<a name="ln1341">    else if (keyin - 'A' &gt;= 0 &amp;&amp; keyin - 'A' &lt; (int)items.size())</a>
<a name="ln1342">    {</a>
<a name="ln1343">        const auto index = letter_to_index(keyin) % 26;</a>
<a name="ln1344">        auto entry = dynamic_cast&lt;ShopEntry*&gt;(items[index]);</a>
<a name="ln1345">        entry-&gt;selected_qty = 0;</a>
<a name="ln1346">        const item_def&amp; item(*entry-&gt;item);</a>
<a name="ln1347">        if (shopping_list.is_on_list(item, &amp;pos))</a>
<a name="ln1348">            shopping_list.del_thing(item, &amp;pos);</a>
<a name="ln1349">        else</a>
<a name="ln1350">            shopping_list.add_thing(item, item_price(item, shop), &amp;pos);</a>
<a name="ln1351">        update_menu(true);</a>
<a name="ln1352">        return true;</a>
<a name="ln1353">    }</a>
<a name="ln1354"> </a>
<a name="ln1355">    auto old_selected = selected_entries();</a>
<a name="ln1356">    bool ret = InvMenu::process_key(keyin);</a>
<a name="ln1357">    if (old_selected != selected_entries())</a>
<a name="ln1358">    {</a>
<a name="ln1359">        // Update the footer to display the new $$$ info.</a>
<a name="ln1360">        update_help();</a>
<a name="ln1361">        update_menu(true);</a>
<a name="ln1362">    }</a>
<a name="ln1363">    return ret;</a>
<a name="ln1364">}</a>
<a name="ln1365"> </a>
<a name="ln1366">void shop()</a>
<a name="ln1367">{</a>
<a name="ln1368">    if (!shop_at(you.pos()))</a>
<a name="ln1369">    {</a>
<a name="ln1370">        mprf(MSGCH_ERROR, &quot;Help! Non-existent shop.&quot;);</a>
<a name="ln1371">        return;</a>
<a name="ln1372">    }</a>
<a name="ln1373"> </a>
<a name="ln1374">    shop_struct&amp; shop = *shop_at(you.pos());</a>
<a name="ln1375">    const string shopname = shop_name(shop);</a>
<a name="ln1376"> </a>
<a name="ln1377">    // Quick out, if no inventory</a>
<a name="ln1378">    if (shop.stock.empty())</a>
<a name="ln1379">    {</a>
<a name="ln1380">        mprf(&quot;%s appears to be closed.&quot;, shopname.c_str());</a>
<a name="ln1381">        destroy_shop_at(you.pos());</a>
<a name="ln1382">        return;</a>
<a name="ln1383">    }</a>
<a name="ln1384"> </a>
<a name="ln1385">    bool culled = false;</a>
<a name="ln1386">    for (const auto&amp; item : shop.stock)</a>
<a name="ln1387">    {</a>
<a name="ln1388">        const int cost = item_price(item, shop);</a>
<a name="ln1389">        culled |= shopping_list.cull_identical_items(item, cost);</a>
<a name="ln1390">    }</a>
<a name="ln1391">    if (culled)</a>
<a name="ln1392">        more(); // make sure all messages appear before menu</a>
<a name="ln1393"> </a>
<a name="ln1394">    ShopMenu menu(shop, level_pos::current(), true);</a>
<a name="ln1395">    menu.show();</a>
<a name="ln1396"> </a>
<a name="ln1397">    StashTrack.get_shop(shop.pos) = ShopInfo(shop);</a>
<a name="ln1398">    bool any_on_list = any_of(begin(shop.stock), end(shop.stock),</a>
<a name="ln1399">                              [](const item_def&amp; item)</a>
<a name="ln1400">                              {</a>
<a name="ln1401">                                  return shopping_list.is_on_list(item);</a>
<a name="ln1402">                              });</a>
<a name="ln1403"> </a>
<a name="ln1404">    // If the shop is now empty, erase it from the overview.</a>
<a name="ln1405">    if (shop.stock.empty())</a>
<a name="ln1406">        destroy_shop_at(you.pos());</a>
<a name="ln1407">    redraw_screen();</a>
<a name="ln1408">    if (menu.bought_something)</a>
<a name="ln1409">        mprf(&quot;Thank you for shopping at %s!&quot;, shopname.c_str());</a>
<a name="ln1410">    if (any_on_list)</a>
<a name="ln1411">        mpr(&quot;You can access your shopping list by pressing '$'.&quot;);</a>
<a name="ln1412">}</a>
<a name="ln1413"> </a>
<a name="ln1414">void shop(shop_struct&amp; shop, const level_pos&amp; pos)</a>
<a name="ln1415">{</a>
<a name="ln1416">    ASSERT(shop.pos == pos.pos);</a>
<a name="ln1417">    ShopMenu(shop, pos, false).show();</a>
<a name="ln1418">}</a>
<a name="ln1419"> </a>
<a name="ln1420">void destroy_shop_at(coord_def p)</a>
<a name="ln1421">{</a>
<a name="ln1422">    if (shop_at(p))</a>
<a name="ln1423">    {</a>
<a name="ln1424">        env.shop.erase(p);</a>
<a name="ln1425">        grd(p) = DNGN_ABANDONED_SHOP;</a>
<a name="ln1426">        unnotice_feature(level_pos(level_id::current(), p));</a>
<a name="ln1427">    }</a>
<a name="ln1428">}</a>
<a name="ln1429"> </a>
<a name="ln1430">shop_struct *shop_at(const coord_def&amp; where)</a>
<a name="ln1431">{</a>
<a name="ln1432">    if (grd(where) != DNGN_ENTER_SHOP)</a>
<a name="ln1433">        return nullptr;</a>
<a name="ln1434"> </a>
<a name="ln1435">    auto it = env.shop.find(where);</a>
<a name="ln1436">    ASSERT(it != env.shop.end());</a>
<a name="ln1437">    ASSERT(it-&gt;second.pos == where);</a>
<a name="ln1438">    ASSERT(it-&gt;second.type != SHOP_UNASSIGNED);</a>
<a name="ln1439"> </a>
<a name="ln1440">    return &amp;it-&gt;second;</a>
<a name="ln1441">}</a>
<a name="ln1442"> </a>
<a name="ln1443">string shop_type_name(shop_type type)</a>
<a name="ln1444">{</a>
<a name="ln1445">    switch (type)</a>
<a name="ln1446">    {</a>
<a name="ln1447">        case SHOP_WEAPON_ANTIQUE:</a>
<a name="ln1448">            return &quot;Antique Weapon&quot;;</a>
<a name="ln1449">        case SHOP_ARMOUR_ANTIQUE:</a>
<a name="ln1450">            return &quot;Antique Armour&quot;;</a>
<a name="ln1451">        case SHOP_WEAPON:</a>
<a name="ln1452">            return &quot;Weapon&quot;;</a>
<a name="ln1453">        case SHOP_ARMOUR:</a>
<a name="ln1454">            return &quot;Armour&quot;;</a>
<a name="ln1455">        case SHOP_JEWELLERY:</a>
<a name="ln1456">            return &quot;Jewellery&quot;;</a>
<a name="ln1457">        case SHOP_EVOKABLES:</a>
<a name="ln1458">            return &quot;Gadget&quot;;</a>
<a name="ln1459">        case SHOP_BOOK:</a>
<a name="ln1460">            return &quot;Book&quot;;</a>
<a name="ln1461">        case SHOP_FOOD:</a>
<a name="ln1462">            return &quot;Food&quot;;</a>
<a name="ln1463">        case SHOP_SCROLL:</a>
<a name="ln1464">            return &quot;Magic Scroll&quot;;</a>
<a name="ln1465">        case SHOP_GENERAL_ANTIQUE:</a>
<a name="ln1466">            return &quot;Assorted Antiques&quot;;</a>
<a name="ln1467">        case SHOP_DISTILLERY:</a>
<a name="ln1468">            return &quot;Distillery&quot;;</a>
<a name="ln1469">        case SHOP_GENERAL:</a>
<a name="ln1470">            return &quot;General Store&quot;;</a>
<a name="ln1471">        default:</a>
<a name="ln1472">            return &quot;Bug&quot;;</a>
<a name="ln1473">    }</a>
<a name="ln1474">}</a>
<a name="ln1475"> </a>
<a name="ln1476">static const char *_shop_type_suffix(shop_type type, const coord_def &amp;where)</a>
<a name="ln1477">{</a>
<a name="ln1478">    if (type == SHOP_GENERAL</a>
<a name="ln1479">        || type == SHOP_GENERAL_ANTIQUE</a>
<a name="ln1480">        || type == SHOP_DISTILLERY)</a>
<a name="ln1481">    {</a>
<a name="ln1482">        return &quot;&quot;;</a>
<a name="ln1483">    }</a>
<a name="ln1484"> </a>
<a name="ln1485">    static const char * const suffixnames[] =</a>
<a name="ln1486">    {</a>
<a name="ln1487">        &quot;Shoppe&quot;, &quot;Boutique&quot;, &quot;Emporium&quot;, &quot;Shop&quot;</a>
<a name="ln1488">    };</a>
<a name="ln1489">    return suffixnames[(where.x + where.y) % ARRAYSZ(suffixnames)];</a>
<a name="ln1490">}</a>
<a name="ln1491"> </a>
<a name="ln1492">string shop_name(const shop_struct&amp; shop)</a>
<a name="ln1493">{</a>
<a name="ln1494">    const shop_type type = shop.type;</a>
<a name="ln1495"> </a>
<a name="ln1496">    string sh_name = &quot;&quot;;</a>
<a name="ln1497"> </a>
<a name="ln1498">#if TAG_MAJOR_VERSION == 34</a>
<a name="ln1499">    // xref ShopInfo::load</a>
<a name="ln1500">    if (shop.shop_name == &quot; &quot;)</a>
<a name="ln1501">        return shop.shop_type_name;</a>
<a name="ln1502">#endif</a>
<a name="ln1503">    if (!shop.shop_name.empty())</a>
<a name="ln1504">        sh_name += apostrophise(shop.shop_name) + &quot; &quot;;</a>
<a name="ln1505">    else</a>
<a name="ln1506">    {</a>
<a name="ln1507">        uint32_t seed = static_cast&lt;uint32_t&gt;(shop.keeper_name[0])</a>
<a name="ln1508">            | (static_cast&lt;uint32_t&gt;(shop.keeper_name[1]) &lt;&lt; 8)</a>
<a name="ln1509">            | (static_cast&lt;uint32_t&gt;(shop.keeper_name[1]) &lt;&lt; 16);</a>
<a name="ln1510"> </a>
<a name="ln1511">        sh_name += apostrophise(make_name(seed)) + &quot; &quot;;</a>
<a name="ln1512">    }</a>
<a name="ln1513"> </a>
<a name="ln1514">    if (!shop.shop_type_name.empty())</a>
<a name="ln1515">        sh_name += shop.shop_type_name;</a>
<a name="ln1516">    else</a>
<a name="ln1517">        sh_name += shop_type_name(type);</a>
<a name="ln1518"> </a>
<a name="ln1519">    if (!shop.shop_suffix_name.empty())</a>
<a name="ln1520">        sh_name += &quot; &quot; + shop.shop_suffix_name;</a>
<a name="ln1521">    else</a>
<a name="ln1522">    {</a>
<a name="ln1523">        string sh_suffix = _shop_type_suffix(type, shop.pos);</a>
<a name="ln1524">        if (!sh_suffix.empty())</a>
<a name="ln1525">            sh_name += &quot; &quot; + sh_suffix;</a>
<a name="ln1526">    }</a>
<a name="ln1527"> </a>
<a name="ln1528">    return sh_name;</a>
<a name="ln1529">}</a>
<a name="ln1530"> </a>
<a name="ln1531">bool is_shop_item(const item_def &amp;item)</a>
<a name="ln1532">{</a>
<a name="ln1533">    return item.link == ITEM_IN_SHOP;</a>
<a name="ln1534">}</a>
<a name="ln1535"> </a>
<a name="ln1536">bool shoptype_identifies_stock(shop_type type)</a>
<a name="ln1537">{</a>
<a name="ln1538">    return type != SHOP_WEAPON_ANTIQUE</a>
<a name="ln1539">           &amp;&amp; type != SHOP_ARMOUR_ANTIQUE</a>
<a name="ln1540">           &amp;&amp; type != SHOP_GENERAL_ANTIQUE;</a>
<a name="ln1541">}</a>
<a name="ln1542"> </a>
<a name="ln1543">bool shop_item_unknown(const item_def &amp;item)</a>
<a name="ln1544">{</a>
<a name="ln1545">    return item_type_has_ids(item.base_type)</a>
<a name="ln1546">           &amp;&amp; item_type_known(item)</a>
<a name="ln1547">           &amp;&amp; !get_ident_type(item)</a>
<a name="ln1548">           &amp;&amp; !is_artefact(item);</a>
<a name="ln1549">}</a>
<a name="ln1550"> </a>
<a name="ln1551">static const char *shop_types[] =</a>
<a name="ln1552">{</a>
<a name="ln1553">    &quot;weapon&quot;,</a>
<a name="ln1554">    &quot;armour&quot;,</a>
<a name="ln1555">    &quot;antique weapon&quot;,</a>
<a name="ln1556">    &quot;antique armour&quot;,</a>
<a name="ln1557">    &quot;antiques&quot;,</a>
<a name="ln1558">    &quot;jewellery&quot;,</a>
<a name="ln1559">    &quot;gadget&quot;,</a>
<a name="ln1560">    &quot;book&quot;,</a>
<a name="ln1561">    &quot;food&quot;,</a>
<a name="ln1562">    &quot;distillery&quot;,</a>
<a name="ln1563">    &quot;scroll&quot;,</a>
<a name="ln1564">    &quot;general&quot;,</a>
<a name="ln1565">};</a>
<a name="ln1566"> </a>
<a name="ln1567">/** What shop type is this?</a>
<a name="ln1568"> *</a>
<a name="ln1569"> *  @param s the shop type, in a string.</a>
<a name="ln1570"> *  @returns the corresponding enum, or SHOP_UNASSIGNED if none.</a>
<a name="ln1571"> */</a>
<a name="ln1572">shop_type str_to_shoptype(const string &amp;s)</a>
<a name="ln1573">{</a>
<a name="ln1574">    if (s == &quot;random&quot; || s == &quot;any&quot;)</a>
<a name="ln1575">        return SHOP_RANDOM;</a>
<a name="ln1576"> </a>
<a name="ln1577">    for (size_t i = 0; i &lt; ARRAYSZ(shop_types); ++i)</a>
<a name="ln1578">        if (s == shop_types[i])</a>
<a name="ln1579">            return static_cast&lt;shop_type&gt;(i);</a>
<a name="ln1580"> </a>
<a name="ln1581">    return SHOP_UNASSIGNED;</a>
<a name="ln1582">}</a>
<a name="ln1583"> </a>
<a name="ln1584">const char *shoptype_to_str(shop_type type)</a>
<a name="ln1585">{</a>
<a name="ln1586">    return shop_types[type];</a>
<a name="ln1587">}</a>
<a name="ln1588"> </a>
<a name="ln1589">void list_shop_types()</a>
<a name="ln1590">{</a>
<a name="ln1591">    mpr_nojoin(MSGCH_PLAIN, &quot;Available shop types: &quot;);</a>
<a name="ln1592">    for (const char *type : shop_types)</a>
<a name="ln1593">        mprf_nocap(&quot;%s&quot;, type);</a>
<a name="ln1594">}</a>
<a name="ln1595"> </a>
<a name="ln1596">////////////////////////////////////////////////////////////////////////</a>
<a name="ln1597"> </a>
<a name="ln1598">// TODO:</a>
<a name="ln1599">//   * Warn if buying something not on the shopping list would put</a>
<a name="ln1600">//     something on shopping list out of your reach.</a>
<a name="ln1601"> </a>
<a name="ln1602">#define SHOPPING_LIST_KEY       &quot;shopping_list_key&quot;</a>
<a name="ln1603">#define SHOPPING_LIST_COST_KEY  &quot;shopping_list_cost_key&quot;</a>
<a name="ln1604">#define SHOPPING_THING_COST_KEY &quot;cost_key&quot;</a>
<a name="ln1605">#define SHOPPING_THING_ITEM_KEY &quot;item_key&quot;</a>
<a name="ln1606">#define SHOPPING_THING_DESC_KEY &quot;desc_key&quot;</a>
<a name="ln1607">#define SHOPPING_THING_VERB_KEY &quot;verb_key&quot;</a>
<a name="ln1608">#define SHOPPING_THING_POS_KEY  &quot;pos_key&quot;</a>
<a name="ln1609"> </a>
<a name="ln1610">ShoppingList::ShoppingList()</a>
<a name="ln1611">    : list(nullptr), min_unbuyable_cost(0), min_unbuyable_idx(0),</a>
<a name="ln1612">      max_buyable_cost(0), max_buyable_idx(0)</a>
<a name="ln1613">{</a>
<a name="ln1614">}</a>
<a name="ln1615"> </a>
<a name="ln1616">#define SETUP_POS()                 \</a>
<a name="ln1617">    ASSERT(list); \</a>
<a name="ln1618">    level_pos pos;                  \</a>
<a name="ln1619">    if (_pos != nullptr)            \</a>
<a name="ln1620">        pos = *_pos;                \</a>
<a name="ln1621">    else                            \</a>
<a name="ln1622">        pos = level_pos::current(); \</a>
<a name="ln1623">    ASSERT(pos.is_valid());</a>
<a name="ln1624"> </a>
<a name="ln1625">bool ShoppingList::add_thing(const item_def &amp;item, int cost,</a>
<a name="ln1626">                             const level_pos* _pos)</a>
<a name="ln1627">{</a>
<a name="ln1628">    ASSERT(item.defined());</a>
<a name="ln1629">    ASSERT(cost &gt; 0);</a>
<a name="ln1630"> </a>
<a name="ln1631">    SETUP_POS();</a>
<a name="ln1632"> </a>
<a name="ln1633">    if (!find_thing(item, pos).empty()) // TODO: this check isn't working?</a>
<a name="ln1634">    {</a>
<a name="ln1635">        mprf(MSGCH_ERROR, &quot;%s is already on the shopping list.&quot;,</a>
<a name="ln1636">             item.name(DESC_THE).c_str());</a>
<a name="ln1637">        return false;</a>
<a name="ln1638">    }</a>
<a name="ln1639"> </a>
<a name="ln1640">    CrawlHashTable *thing = new CrawlHashTable();</a>
<a name="ln1641">    (*thing)[SHOPPING_THING_COST_KEY] = cost;</a>
<a name="ln1642">    (*thing)[SHOPPING_THING_POS_KEY]  = pos;</a>
<a name="ln1643">    (*thing)[SHOPPING_THING_ITEM_KEY] = item;</a>
<a name="ln1644">    list-&gt;push_back(*thing);</a>
<a name="ln1645">    refresh();</a>
<a name="ln1646"> </a>
<a name="ln1647">    return true;</a>
<a name="ln1648">}</a>
<a name="ln1649"> </a>
<a name="ln1650">bool ShoppingList::is_on_list(const item_def &amp;item, const level_pos* _pos) const</a>
<a name="ln1651">{</a>
<a name="ln1652">    SETUP_POS();</a>
<a name="ln1653"> </a>
<a name="ln1654">    return !find_thing(item, pos).empty();</a>
<a name="ln1655">}</a>
<a name="ln1656"> </a>
<a name="ln1657">bool ShoppingList::is_on_list(string desc, const level_pos* _pos) const</a>
<a name="ln1658">{</a>
<a name="ln1659">    SETUP_POS();</a>
<a name="ln1660"> </a>
<a name="ln1661">    return !find_thing(desc, pos).empty();</a>
<a name="ln1662">}</a>
<a name="ln1663"> </a>
<a name="ln1664">void ShoppingList::del_thing_at_index(int idx)</a>
<a name="ln1665">{</a>
<a name="ln1666">    ASSERT_RANGE(idx, 0, list-&gt;size());</a>
<a name="ln1667">    list-&gt;erase(idx);</a>
<a name="ln1668">    refresh();</a>
<a name="ln1669">}</a>
<a name="ln1670"> </a>
<a name="ln1671">template &lt;typename C&gt;</a>
<a name="ln1672">void ShoppingList::del_thing_at_indices(C const &amp;idxs)</a>
<a name="ln1673">{</a>
<a name="ln1674">    set&lt;int,greater&lt;int&gt;&gt; indices(idxs.begin(), idxs.end());</a>
<a name="ln1675"> </a>
<a name="ln1676">    for (auto idx : indices)</a>
<a name="ln1677">    {</a>
<a name="ln1678">        ASSERT_RANGE(idx, 0, list-&gt;size());</a>
<a name="ln1679">        list-&gt;erase(idx);</a>
<a name="ln1680">    }</a>
<a name="ln1681">    refresh();</a>
<a name="ln1682">}</a>
<a name="ln1683"> </a>
<a name="ln1684">void ShoppingList::del_things_from(const level_id &amp;lid)</a>
<a name="ln1685">{</a>
<a name="ln1686">    for (unsigned int i = 0; i &lt; list-&gt;size(); i++)</a>
<a name="ln1687">    {</a>
<a name="ln1688">        const CrawlHashTable &amp;thing = (*list)[i];</a>
<a name="ln1689"> </a>
<a name="ln1690">        if (thing_pos(thing).is_on(lid))</a>
<a name="ln1691">            list-&gt;erase(i--);</a>
<a name="ln1692">    }</a>
<a name="ln1693">    refresh();</a>
<a name="ln1694">}</a>
<a name="ln1695"> </a>
<a name="ln1696">bool ShoppingList::del_thing(const item_def &amp;item,</a>
<a name="ln1697">                             const level_pos* _pos)</a>
<a name="ln1698">{</a>
<a name="ln1699">    SETUP_POS();</a>
<a name="ln1700"> </a>
<a name="ln1701">    auto indices = find_thing(item, pos);</a>
<a name="ln1702"> </a>
<a name="ln1703">    if (indices.empty())</a>
<a name="ln1704">    {</a>
<a name="ln1705">        mprf(MSGCH_ERROR, &quot;%s isn't on shopping list, can't delete it.&quot;,</a>
<a name="ln1706">             item.name(DESC_THE).c_str());</a>
<a name="ln1707">        return false;</a>
<a name="ln1708">    }</a>
<a name="ln1709"> </a>
<a name="ln1710">    del_thing_at_indices(indices);</a>
<a name="ln1711">    return true;</a>
<a name="ln1712">}</a>
<a name="ln1713"> </a>
<a name="ln1714">bool ShoppingList::del_thing(string desc, const level_pos* _pos)</a>
<a name="ln1715">{</a>
<a name="ln1716">    SETUP_POS();</a>
<a name="ln1717"> </a>
<a name="ln1718">    auto indices = find_thing(desc, pos);</a>
<a name="ln1719"> </a>
<a name="ln1720">    if (indices.empty())</a>
<a name="ln1721">    {</a>
<a name="ln1722">        mprf(MSGCH_ERROR, &quot;%s isn't on shopping list, can't delete it.&quot;,</a>
<a name="ln1723">             desc.c_str());</a>
<a name="ln1724">        return false;</a>
<a name="ln1725">    }</a>
<a name="ln1726"> </a>
<a name="ln1727">    del_thing_at_indices(indices);</a>
<a name="ln1728">    return true;</a>
<a name="ln1729">}</a>
<a name="ln1730"> </a>
<a name="ln1731">#undef SETUP_POS</a>
<a name="ln1732"> </a>
<a name="ln1733">#define REMOVE_PROMPTED_KEY  &quot;remove_prompted_key&quot;</a>
<a name="ln1734">#define REPLACE_PROMPTED_KEY &quot;replace_prompted_key&quot;</a>
<a name="ln1735"> </a>
<a name="ln1736">// TODO:</a>
<a name="ln1737">//</a>
<a name="ln1738">// * If you get a randart which lets you turn invisible, then remove</a>
<a name="ln1739">//   any ordinary rings of invisibility from the shopping list.</a>
<a name="ln1740">//</a>
<a name="ln1741">// * If you collected enough spellbooks that all the spells in a</a>
<a name="ln1742">//   shopping list book are covered, then auto-remove it.</a>
<a name="ln1743">bool ShoppingList::cull_identical_items(const item_def&amp; item, int cost)</a>
<a name="ln1744">{</a>
<a name="ln1745">    // Dead men can't update their shopping lists.</a>
<a name="ln1746">    if (!crawl_state.need_save)</a>
<a name="ln1747">        return 0;</a>
<a name="ln1748"> </a>
<a name="ln1749">    // Can't put items in Bazaar shops in the shopping list, so</a>
<a name="ln1750">    // don't bother transferring shopping list items to Bazaar shops.</a>
<a name="ln1751">    // TODO: temporary shoplists</a>
<a name="ln1752">    if (cost != -1 &amp;&amp; !is_connected_branch(you.where_are_you))</a>
<a name="ln1753">        return 0;</a>
<a name="ln1754"> </a>
<a name="ln1755">    switch (item.base_type)</a>
<a name="ln1756">    {</a>
<a name="ln1757">    case OBJ_JEWELLERY:</a>
<a name="ln1758">    case OBJ_BOOKS:</a>
<a name="ln1759">    case OBJ_STAVES:</a>
<a name="ln1760">        // Only these are really interchangeable.</a>
<a name="ln1761">        break;</a>
<a name="ln1762">    case OBJ_MISCELLANY:</a>
<a name="ln1763">        // ... and a few of these.</a>
<a name="ln1764">        if (!is_xp_evoker(item))</a>
<a name="ln1765">            return 0;</a>
<a name="ln1766">        break;</a>
<a name="ln1767">    default:</a>
<a name="ln1768">        return 0;</a>
<a name="ln1769">    }</a>
<a name="ln1770"> </a>
<a name="ln1771">    if (!item_type_known(item) || is_artefact(item))</a>
<a name="ln1772">        return 0;</a>
<a name="ln1773"> </a>
<a name="ln1774">    // Ignore stat-modification rings which reduce a stat, since they're</a>
<a name="ln1775">    // worthless.</a>
<a name="ln1776">    if (item.base_type == OBJ_JEWELLERY &amp;&amp; item.plus &lt; 0)</a>
<a name="ln1777">        return 0;</a>
<a name="ln1778"> </a>
<a name="ln1779">    // Manuals are consumable, and interesting enough to keep on list.</a>
<a name="ln1780">    if (item.is_type(OBJ_BOOKS, BOOK_MANUAL))</a>
<a name="ln1781">        return 0;</a>
<a name="ln1782"> </a>
<a name="ln1783">    // Item is already on shopping-list.</a>
<a name="ln1784">    const bool on_list = !find_thing(item, level_pos::current()).empty();</a>
<a name="ln1785"> </a>
<a name="ln1786">    const bool do_prompt = item.base_type == OBJ_JEWELLERY</a>
<a name="ln1787">                           &amp;&amp; !jewellery_is_amulet(item)</a>
<a name="ln1788">                           &amp;&amp; ring_has_stackable_effect(item);</a>
<a name="ln1789"> </a>
<a name="ln1790">    bool add_item = false;</a>
<a name="ln1791"> </a>
<a name="ln1792">    typedef pair&lt;item_def, level_pos&gt; list_pair;</a>
<a name="ln1793">    vector&lt;list_pair&gt; to_del;</a>
<a name="ln1794"> </a>
<a name="ln1795">    // NOTE: Don't modify the shopping list while iterating over it.</a>
<a name="ln1796">    for (CrawlHashTable &amp;thing : *list)</a>
<a name="ln1797">    {</a>
<a name="ln1798">        if (!thing_is_item(thing))</a>
<a name="ln1799">            continue;</a>
<a name="ln1800"> </a>
<a name="ln1801">        const item_def&amp; list_item = get_thing_item(thing);</a>
<a name="ln1802"> </a>
<a name="ln1803">        if (list_item.base_type != item.base_type</a>
<a name="ln1804">            || list_item.sub_type != item.sub_type)</a>
<a name="ln1805">        {</a>
<a name="ln1806">            continue;</a>
<a name="ln1807">        }</a>
<a name="ln1808"> </a>
<a name="ln1809">        if (!item_type_known(list_item) || is_artefact(list_item))</a>
<a name="ln1810">            continue;</a>
<a name="ln1811"> </a>
<a name="ln1812">        // Don't prompt to remove rings with strictly better pluses</a>
<a name="ln1813">        // than the new one. Also, don't prompt to remove rings with</a>
<a name="ln1814">        // known pluses when the new ring's pluses are unknown.</a>
<a name="ln1815">        if (item.base_type == OBJ_JEWELLERY)</a>
<a name="ln1816">        {</a>
<a name="ln1817">            const bool has_plus = jewellery_has_pluses(item);</a>
<a name="ln1818">            const int delta_p = item.plus - list_item.plus;</a>
<a name="ln1819">            if (has_plus</a>
<a name="ln1820">                &amp;&amp; item_ident(list_item, ISFLAG_KNOW_PLUSES)</a>
<a name="ln1821">                &amp;&amp; (!item_ident(item, ISFLAG_KNOW_PLUSES)</a>
<a name="ln1822">                     || delta_p &lt; 0))</a>
<a name="ln1823">            {</a>
<a name="ln1824">                continue;</a>
<a name="ln1825">            }</a>
<a name="ln1826">        }</a>
<a name="ln1827"> </a>
<a name="ln1828">        // Don't prompt to remove known manuals when the new one is unknown</a>
<a name="ln1829">        // or for a different skill.</a>
<a name="ln1830">        if (item.is_type(OBJ_BOOKS, BOOK_MANUAL)</a>
<a name="ln1831">            &amp;&amp; item_type_known(list_item)</a>
<a name="ln1832">            &amp;&amp; (!item_type_known(item) || item.plus != list_item.plus))</a>
<a name="ln1833">        {</a>
<a name="ln1834">            continue;</a>
<a name="ln1835">        }</a>
<a name="ln1836"> </a>
<a name="ln1837">        list_pair listed(list_item, thing_pos(thing));</a>
<a name="ln1838"> </a>
<a name="ln1839">        // cost = -1, we just found a shop item which is cheaper than</a>
<a name="ln1840">        // one on the shopping list.</a>
<a name="ln1841">        if (cost != -1)</a>
<a name="ln1842">        {</a>
<a name="ln1843">            int list_cost = thing_cost(thing);</a>
<a name="ln1844"> </a>
<a name="ln1845">            if (cost &gt;= list_cost)</a>
<a name="ln1846">                continue;</a>
<a name="ln1847"> </a>
<a name="ln1848">            // Only prompt once.</a>
<a name="ln1849">            if (thing.exists(REPLACE_PROMPTED_KEY))</a>
<a name="ln1850">                continue;</a>
<a name="ln1851">            thing[REPLACE_PROMPTED_KEY] = (bool) true;</a>
<a name="ln1852"> </a>
<a name="ln1853">            string prompt =</a>
<a name="ln1854">                make_stringf(&quot;Shopping list: replace %dgp %s with cheaper &quot;</a>
<a name="ln1855">                             &quot;one? (Y/n)&quot;, list_cost,</a>
<a name="ln1856">                             describe_thing(thing).c_str());</a>
<a name="ln1857"> </a>
<a name="ln1858">            if (yesno(prompt.c_str(), true, 'y', false))</a>
<a name="ln1859">            {</a>
<a name="ln1860">                add_item = true;</a>
<a name="ln1861">                to_del.push_back(listed);</a>
<a name="ln1862">            }</a>
<a name="ln1863">            continue;</a>
<a name="ln1864">        }</a>
<a name="ln1865"> </a>
<a name="ln1866">        // cost == -1, we just got an item which is on the shopping list.</a>
<a name="ln1867">        if (do_prompt)</a>
<a name="ln1868">        {</a>
<a name="ln1869">            // Only prompt once.</a>
<a name="ln1870">            if (thing.exists(REMOVE_PROMPTED_KEY))</a>
<a name="ln1871">                continue;</a>
<a name="ln1872">            thing[REMOVE_PROMPTED_KEY] = (bool) true;</a>
<a name="ln1873"> </a>
<a name="ln1874">            string prompt = make_stringf(&quot;Shopping list: remove %s? (Y/n)&quot;,</a>
<a name="ln1875">                                         describe_thing(thing, DESC_A).c_str());</a>
<a name="ln1876"> </a>
<a name="ln1877">            if (yesno(prompt.c_str(), true, 'y', false))</a>
<a name="ln1878">            {</a>
<a name="ln1879">                to_del.push_back(listed);</a>
<a name="ln1880">                mprf(&quot;Shopping list: removing %s&quot;,</a>
<a name="ln1881">                     describe_thing(thing, DESC_A).c_str());</a>
<a name="ln1882">            }</a>
<a name="ln1883">            else</a>
<a name="ln1884">                canned_msg(MSG_OK);</a>
<a name="ln1885">        }</a>
<a name="ln1886">        else</a>
<a name="ln1887">        {</a>
<a name="ln1888">            mprf(&quot;Shopping list: removing %s&quot;,</a>
<a name="ln1889">                 describe_thing(thing, DESC_A).c_str());</a>
<a name="ln1890">            to_del.push_back(listed);</a>
<a name="ln1891">        }</a>
<a name="ln1892">    }</a>
<a name="ln1893"> </a>
<a name="ln1894">    for (list_pair &amp;entry : to_del)</a>
<a name="ln1895">        del_thing(entry.first, &amp;entry.second);</a>
<a name="ln1896"> </a>
<a name="ln1897">    if (add_item &amp;&amp; !on_list)</a>
<a name="ln1898">        add_thing(item, cost);</a>
<a name="ln1899"> </a>
<a name="ln1900">    return to_del.size();</a>
<a name="ln1901">}</a>
<a name="ln1902"> </a>
<a name="ln1903">void ShoppingList::item_type_identified(object_class_type base_type,</a>
<a name="ln1904">                                        int sub_type)</a>
<a name="ln1905">{</a>
<a name="ln1906">    // Dead men can't update their shopping lists.</a>
<a name="ln1907">    if (!crawl_state.need_save)</a>
<a name="ln1908">        return;</a>
<a name="ln1909"> </a>
<a name="ln1910">    // Only restore the excursion at the very end.</a>
<a name="ln1911">    level_excursion le;</a>
<a name="ln1912"> </a>
<a name="ln1913">#if TAG_MAJOR_VERSION == 34</a>
<a name="ln1914">    // Handle removed Gozag shops from old saves. Only do this once:</a>
<a name="ln1915">    // future Gozag abandonment will call remove_dead_shops itself.</a>
<a name="ln1916">    if (!you.props.exists(REMOVED_DEAD_SHOPS_KEY))</a>
<a name="ln1917">    {</a>
<a name="ln1918">        remove_dead_shops();</a>
<a name="ln1919">        you.props[REMOVED_DEAD_SHOPS_KEY] = true;</a>
<a name="ln1920">    }</a>
<a name="ln1921">#endif</a>
<a name="ln1922"> </a>
<a name="ln1923">    for (CrawlHashTable &amp;thing : *list)</a>
<a name="ln1924">    {</a>
<a name="ln1925">        if (!thing_is_item(thing))</a>
<a name="ln1926">            continue;</a>
<a name="ln1927"> </a>
<a name="ln1928">        const item_def&amp; item = get_thing_item(thing);</a>
<a name="ln1929"> </a>
<a name="ln1930">        if (item.base_type != base_type || item.sub_type != sub_type)</a>
<a name="ln1931">            continue;</a>
<a name="ln1932"> </a>
<a name="ln1933">        const level_pos place = thing_pos(thing);</a>
<a name="ln1934"> </a>
<a name="ln1935">        le.go_to(place.id);</a>
<a name="ln1936">        const shop_struct *shop = shop_at(place.pos);</a>
<a name="ln1937">        ASSERT(shop);</a>
<a name="ln1938">        if (shoptype_identifies_stock(shop-&gt;type))</a>
<a name="ln1939">            continue;</a>
<a name="ln1940"> </a>
<a name="ln1941">        thing[SHOPPING_THING_COST_KEY] =</a>
<a name="ln1942">            _shop_get_item_value(item, shop-&gt;greed, false);</a>
<a name="ln1943">    }</a>
<a name="ln1944"> </a>
<a name="ln1945">    // Prices could have changed.</a>
<a name="ln1946">    refresh();</a>
<a name="ln1947">}</a>
<a name="ln1948"> </a>
<a name="ln1949">void ShoppingList::spells_added_to_library(const vector&lt;spell_type&gt;&amp; spells, bool quiet)</a>
<a name="ln1950">{</a>
<a name="ln1951">    if (!list) /* let's not make book starts crash instantly... */</a>
<a name="ln1952">        return;</a>
<a name="ln1953"> </a>
<a name="ln1954">    unordered_set&lt;int&gt; indices_to_del;</a>
<a name="ln1955">    for (CrawlHashTable &amp;thing : *list)</a>
<a name="ln1956">    {</a>
<a name="ln1957">        if (!thing_is_item(thing)) // ???</a>
<a name="ln1958">            continue;</a>
<a name="ln1959">        const item_def&amp; book = get_thing_item(thing);</a>
<a name="ln1960">        if (book.base_type != OBJ_BOOKS || book.sub_type == BOOK_MANUAL)</a>
<a name="ln1961">            continue;</a>
<a name="ln1962"> </a>
<a name="ln1963">        const auto item_spells = spells_in_book(book);</a>
<a name="ln1964">        if (any_of(item_spells.begin(), item_spells.end(), [&amp;spells](const spell_type st) {</a>
<a name="ln1965">                    return find(spells.begin(), spells.end(), st) != spells.end();</a>
<a name="ln1966">                }) &amp;&amp; is_useless_item(book, false))</a>
<a name="ln1967">        {</a>
<a name="ln1968">            level_pos pos = thing_pos(thing); // TODO: unreliable?</a>
<a name="ln1969">            auto thing_indices = find_thing(get_thing_item(thing), pos);</a>
<a name="ln1970">            indices_to_del.insert(thing_indices.begin(), thing_indices.end());</a>
<a name="ln1971">        }</a>
<a name="ln1972">    }</a>
<a name="ln1973">    if (!quiet)</a>
<a name="ln1974">    {</a>
<a name="ln1975">        for (auto idx : indices_to_del)</a>
<a name="ln1976">        {</a>
<a name="ln1977">            ASSERT_RANGE(idx, 0, list-&gt;size());</a>
<a name="ln1978">            mprf(&quot;Shopping list: removing %s&quot;,</a>
<a name="ln1979">                describe_thing((*list)[idx], DESC_A).c_str());</a>
<a name="ln1980">        }</a>
<a name="ln1981">    }</a>
<a name="ln1982">    del_thing_at_indices(indices_to_del);</a>
<a name="ln1983">}</a>
<a name="ln1984"> </a>
<a name="ln1985">void ShoppingList::remove_dead_shops()</a>
<a name="ln1986">{</a>
<a name="ln1987">    // Only restore the excursion at the very end.</a>
<a name="ln1988">    level_excursion le;</a>
<a name="ln1989"> </a>
<a name="ln1990">    set&lt;level_pos&gt; shops_to_remove;</a>
<a name="ln1991"> </a>
<a name="ln1992">    for (CrawlHashTable &amp;thing : *list)</a>
<a name="ln1993">    {</a>
<a name="ln1994">        const level_pos place = thing_pos(thing);</a>
<a name="ln1995">        le.go_to(place.id); // thereby running DACT_REMOVE_GOZAG_SHOPS</a>
<a name="ln1996">        const shop_struct *shop = shop_at(place.pos);</a>
<a name="ln1997"> </a>
<a name="ln1998">        if (!shop)</a>
<a name="ln1999">            shops_to_remove.insert(place);</a>
<a name="ln2000">    }</a>
<a name="ln2001"> </a>
<a name="ln2002">    for (auto pos : shops_to_remove)</a>
<a name="ln2003">        forget_pos(pos);</a>
<a name="ln2004"> </a>
<a name="ln2005">    // Prices could have changed.</a>
<a name="ln2006">    refresh();</a>
<a name="ln2007">}</a>
<a name="ln2008"> </a>
<a name="ln2009">vector&lt;shoplist_entry&gt; ShoppingList::entries()</a>
<a name="ln2010">{</a>
<a name="ln2011">    ASSERT(list);</a>
<a name="ln2012"> </a>
<a name="ln2013">    vector&lt;shoplist_entry&gt; list_entries;</a>
<a name="ln2014">    for (const CrawlHashTable &amp;entry : *list)</a>
<a name="ln2015">    {</a>
<a name="ln2016">        list_entries.push_back(</a>
<a name="ln2017">            make_pair(name_thing(entry), thing_cost(entry))</a>
<a name="ln2018">        );</a>
<a name="ln2019">    }</a>
<a name="ln2020"> </a>
<a name="ln2021">    return list_entries;</a>
<a name="ln2022">}</a>
<a name="ln2023"> </a>
<a name="ln2024">int ShoppingList::size() const</a>
<a name="ln2025">{</a>
<a name="ln2026">    ASSERT(list);</a>
<a name="ln2027"> </a>
<a name="ln2028">    return list-&gt;size();</a>
<a name="ln2029">}</a>
<a name="ln2030"> </a>
<a name="ln2031">bool ShoppingList::items_are_same(const item_def&amp; item_a,</a>
<a name="ln2032">                                  const item_def&amp; item_b)</a>
<a name="ln2033">{</a>
<a name="ln2034">    return item_name_simple(item_a) == item_name_simple(item_b);</a>
<a name="ln2035">}</a>
<a name="ln2036"> </a>
<a name="ln2037">void ShoppingList::move_things(const coord_def &amp;_src, const coord_def &amp;_dst)</a>
<a name="ln2038">{</a>
<a name="ln2039">    if (crawl_state.map_stat_gen</a>
<a name="ln2040">        || crawl_state.obj_stat_gen</a>
<a name="ln2041">        || crawl_state.test)</a>
<a name="ln2042">    {</a>
<a name="ln2043">        return; // Shopping list is unitialized and uneeded.</a>
<a name="ln2044">    }</a>
<a name="ln2045"> </a>
<a name="ln2046">    const level_pos src(level_id::current(), _src);</a>
<a name="ln2047">    const level_pos dst(level_id::current(), _dst);</a>
<a name="ln2048"> </a>
<a name="ln2049">    for (CrawlHashTable &amp;thing : *list)</a>
<a name="ln2050">        if (thing_pos(thing) == src)</a>
<a name="ln2051">            thing[SHOPPING_THING_POS_KEY] = dst;</a>
<a name="ln2052">}</a>
<a name="ln2053"> </a>
<a name="ln2054">void ShoppingList::forget_pos(const level_pos &amp;pos)</a>
<a name="ln2055">{</a>
<a name="ln2056">    if (!crawl_state.need_save)</a>
<a name="ln2057">        return; // Shopping list is uninitialized and unneeded.</a>
<a name="ln2058"> </a>
<a name="ln2059">    for (unsigned int i = 0; i &lt; list-&gt;size(); i++)</a>
<a name="ln2060">    {</a>
<a name="ln2061">        const CrawlHashTable &amp;thing = (*list)[i];</a>
<a name="ln2062"> </a>
<a name="ln2063">        if (thing_pos(thing) == pos)</a>
<a name="ln2064">        {</a>
<a name="ln2065">            list-&gt;erase(i);</a>
<a name="ln2066">            i--;</a>
<a name="ln2067">        }</a>
<a name="ln2068">    }</a>
<a name="ln2069"> </a>
<a name="ln2070">    // Maybe we just forgot about a shop.</a>
<a name="ln2071">    refresh();</a>
<a name="ln2072">}</a>
<a name="ln2073"> </a>
<a name="ln2074">void ShoppingList::gold_changed(int old_amount, int new_amount)</a>
<a name="ln2075">{</a>
<a name="ln2076">    ASSERT(list);</a>
<a name="ln2077"> </a>
<a name="ln2078">    if (new_amount &gt; old_amount &amp;&amp; new_amount &gt;= min_unbuyable_cost)</a>
<a name="ln2079">    {</a>
<a name="ln2080">        ASSERT(min_unbuyable_idx &lt; list-&gt;size());</a>
<a name="ln2081"> </a>
<a name="ln2082">        vector&lt;string&gt; descs;</a>
<a name="ln2083">        for (unsigned int i = min_unbuyable_idx; i &lt; list-&gt;size(); i++)</a>
<a name="ln2084">        {</a>
<a name="ln2085">            const CrawlHashTable &amp;thing = (*list)[i];</a>
<a name="ln2086">            const int            cost   = thing_cost(thing);</a>
<a name="ln2087"> </a>
<a name="ln2088">            if (cost &gt; new_amount)</a>
<a name="ln2089">            {</a>
<a name="ln2090">                ASSERT(i &gt; (unsigned int) min_unbuyable_idx);</a>
<a name="ln2091">                break;</a>
<a name="ln2092">            }</a>
<a name="ln2093"> </a>
<a name="ln2094">            string desc;</a>
<a name="ln2095"> </a>
<a name="ln2096">            if (thing.exists(SHOPPING_THING_VERB_KEY))</a>
<a name="ln2097">                desc += thing[SHOPPING_THING_VERB_KEY].get_string();</a>
<a name="ln2098">            else</a>
<a name="ln2099">                desc = &quot;buy&quot;;</a>
<a name="ln2100">            desc += &quot; &quot;;</a>
<a name="ln2101"> </a>
<a name="ln2102">            desc += describe_thing(thing, DESC_A);</a>
<a name="ln2103"> </a>
<a name="ln2104">            descs.push_back(desc);</a>
<a name="ln2105">        }</a>
<a name="ln2106">        ASSERT(!descs.empty());</a>
<a name="ln2107"> </a>
<a name="ln2108">        mpr_comma_separated_list(&quot;You now have enough gold to &quot;, descs,</a>
<a name="ln2109">                                 &quot;, or &quot;);</a>
<a name="ln2110">        mpr(&quot;You can access your shopping list by pressing '$'.&quot;);</a>
<a name="ln2111"> </a>
<a name="ln2112">        // Our gold has changed, maybe we can buy different things now.</a>
<a name="ln2113">        refresh();</a>
<a name="ln2114">    }</a>
<a name="ln2115">    else if (new_amount &lt; old_amount &amp;&amp; new_amount &lt; max_buyable_cost)</a>
<a name="ln2116">    {</a>
<a name="ln2117">        // As above.</a>
<a name="ln2118">        refresh();</a>
<a name="ln2119">    }</a>
<a name="ln2120">}</a>
<a name="ln2121"> </a>
<a name="ln2122">class ShoppingListMenu : public Menu</a>
<a name="ln2123">{</a>
<a name="ln2124">public:</a>
<a name="ln2125">    ShoppingListMenu() : Menu(MF_MULTISELECT | MF_ALLOW_FORMATTING) {}</a>
<a name="ln2126">    bool view_only {false};</a>
<a name="ln2127"> </a>
<a name="ln2128">protected:</a>
<a name="ln2129">    virtual formatted_string calc_title() override;</a>
<a name="ln2130">};</a>
<a name="ln2131"> </a>
<a name="ln2132">formatted_string ShoppingListMenu::calc_title()</a>
<a name="ln2133">{</a>
<a name="ln2134">    formatted_string fs;</a>
<a name="ln2135">    const int total_cost = you.props[SHOPPING_LIST_COST_KEY];</a>
<a name="ln2136"> </a>
<a name="ln2137">    fs.textcolour(title-&gt;colour);</a>
<a name="ln2138">    fs.cprintf(&quot;%d %s%s, total %d gold&quot;,</a>
<a name="ln2139">                title-&gt;quantity, title-&gt;text.c_str(),</a>
<a name="ln2140">                title-&gt;quantity &gt; 1 ? &quot;s&quot; : &quot;&quot;,</a>
<a name="ln2141">                total_cost);</a>
<a name="ln2142"> </a>
<a name="ln2143">    string s = &quot;&lt;lightgrey&gt;  [&lt;w&gt;a-z&lt;/w&gt;] &quot;;</a>
<a name="ln2144"> </a>
<a name="ln2145">    if (view_only)</a>
<a name="ln2146">    {</a>
<a name="ln2147">        fs += formatted_string::parse_string(s + &quot;&lt;w&gt;examine&lt;/w&gt;&quot;);</a>
<a name="ln2148">        return fs;</a>
<a name="ln2149">    }</a>
<a name="ln2150"> </a>
<a name="ln2151">    switch (menu_action)</a>
<a name="ln2152">    {</a>
<a name="ln2153">    case ACT_EXECUTE:</a>
<a name="ln2154">        s += &quot;&lt;w&gt;travel&lt;/w&gt;|examine|delete&quot;;</a>
<a name="ln2155">        break;</a>
<a name="ln2156">    case ACT_EXAMINE:</a>
<a name="ln2157">        s += &quot;travel|&lt;w&gt;examine&lt;/w&gt;|delete&quot;;</a>
<a name="ln2158">        break;</a>
<a name="ln2159">    default:</a>
<a name="ln2160">        s += &quot;travel|examine|&lt;w&gt;delete&lt;/w&gt;&quot;;</a>
<a name="ln2161">        break;</a>
<a name="ln2162">    }</a>
<a name="ln2163"> </a>
<a name="ln2164">    s += &quot;  [&lt;w&gt;?&lt;/w&gt;/&lt;w&gt;!&lt;/w&gt;] change action&lt;/lightgrey&gt;&quot;;</a>
<a name="ln2165">    fs += formatted_string::parse_string(s);</a>
<a name="ln2166">    return fs;</a>
<a name="ln2167">}</a>
<a name="ln2168"> </a>
<a name="ln2169">/**</a>
<a name="ln2170"> * Describe the location of a given shopping list entry.</a>
<a name="ln2171"> *</a>
<a name="ln2172"> * @param thing     A shopping list entry.</a>
<a name="ln2173"> * @return          Something like [Orc:4], probably.</a>
<a name="ln2174"> */</a>
<a name="ln2175">string ShoppingList::describe_thing_pos(const CrawlHashTable &amp;thing)</a>
<a name="ln2176">{</a>
<a name="ln2177">    return make_stringf(&quot;[%s]&quot;, thing_pos(thing).id.describe().c_str());</a>
<a name="ln2178">}</a>
<a name="ln2179"> </a>
<a name="ln2180">void ShoppingList::fill_out_menu(Menu&amp; shopmenu)</a>
<a name="ln2181">{</a>
<a name="ln2182">    menu_letter hotkey;</a>
<a name="ln2183">    int longest = 0;</a>
<a name="ln2184">    // How much space does the longest entry need for proper alignment?</a>
<a name="ln2185">    for (const CrawlHashTable &amp;thing : *list)</a>
<a name="ln2186">        longest = max(longest, strwidth(describe_thing_pos(thing)));</a>
<a name="ln2187"> </a>
<a name="ln2188">    for (CrawlHashTable &amp;thing : *list)</a>
<a name="ln2189">    {</a>
<a name="ln2190">        const int cost = thing_cost(thing);</a>
<a name="ln2191">        const bool unknown = thing_is_item(thing)</a>
<a name="ln2192">                             &amp;&amp; shop_item_unknown(get_thing_item(thing));</a>
<a name="ln2193"> </a>
<a name="ln2194">        const string etitle =</a>
<a name="ln2195">            make_stringf(</a>
<a name="ln2196">                &quot;%*s%5d gold  %s%s&quot;,</a>
<a name="ln2197">                longest,</a>
<a name="ln2198">                describe_thing_pos(thing).c_str(),</a>
<a name="ln2199">                cost,</a>
<a name="ln2200">                name_thing(thing, DESC_A).c_str(),</a>
<a name="ln2201">                unknown ? &quot; (unknown)&quot; : &quot;&quot;);</a>
<a name="ln2202"> </a>
<a name="ln2203">        MenuEntry *me = new MenuEntry(etitle, MEL_ITEM, 1, hotkey);</a>
<a name="ln2204">        me-&gt;data = &amp;thing;</a>
<a name="ln2205"> </a>
<a name="ln2206">        if (thing_is_item(thing))</a>
<a name="ln2207">        {</a>
<a name="ln2208">            // Colour shopping list item according to menu colours.</a>
<a name="ln2209">            const item_def &amp;item = get_thing_item(thing);</a>
<a name="ln2210"> </a>
<a name="ln2211">            const string colprf = item_prefix(item);</a>
<a name="ln2212">            const int col = menu_colour(item.name(DESC_A),</a>
<a name="ln2213">                                        colprf, &quot;shop&quot;);</a>
<a name="ln2214"> </a>
<a name="ln2215">#ifdef USE_TILE</a>
<a name="ln2216">            vector&lt;tile_def&gt; item_tiles;</a>
<a name="ln2217">            get_tiles_for_item(item, item_tiles, true);</a>
<a name="ln2218">            for (const auto &amp;tile : item_tiles)</a>
<a name="ln2219">                me-&gt;add_tile(tile);</a>
<a name="ln2220">#endif</a>
<a name="ln2221"> </a>
<a name="ln2222">            if (col != -1)</a>
<a name="ln2223">                me-&gt;colour = col;</a>
<a name="ln2224">        }</a>
<a name="ln2225">        if (cost &gt; you.gold)</a>
<a name="ln2226">            me-&gt;colour = DARKGREY;</a>
<a name="ln2227"> </a>
<a name="ln2228">        shopmenu.add_entry(me);</a>
<a name="ln2229">        ++hotkey;</a>
<a name="ln2230">    }</a>
<a name="ln2231">}</a>
<a name="ln2232"> </a>
<a name="ln2233">void ShoppingList::display(bool view_only)</a>
<a name="ln2234">{</a>
<a name="ln2235">    if (list-&gt;empty())</a>
<a name="ln2236">        return;</a>
<a name="ln2237"> </a>
<a name="ln2238">    ShoppingListMenu shopmenu;</a>
<a name="ln2239">    shopmenu.view_only = view_only;</a>
<a name="ln2240">    shopmenu.set_tag(&quot;shop&quot;);</a>
<a name="ln2241">    shopmenu.menu_action  = view_only ? Menu::ACT_EXAMINE : Menu::ACT_EXECUTE;</a>
<a name="ln2242">    shopmenu.action_cycle = view_only ? Menu::CYCLE_NONE : Menu::CYCLE_CYCLE;</a>
<a name="ln2243">    string title          = &quot;item&quot;;</a>
<a name="ln2244"> </a>
<a name="ln2245">    MenuEntry *mtitle = new MenuEntry(title, MEL_TITLE);</a>
<a name="ln2246">    mtitle-&gt;quantity = list-&gt;size();</a>
<a name="ln2247">    shopmenu.set_title(mtitle);</a>
<a name="ln2248"> </a>
<a name="ln2249">    string more_str = make_stringf(&quot;&lt;yellow&gt;You have %d gp&lt;/yellow&gt;&quot;, you.gold);</a>
<a name="ln2250">    shopmenu.set_more(formatted_string::parse_string(more_str));</a>
<a name="ln2251"> </a>
<a name="ln2252">    shopmenu.set_flags(MF_SINGLESELECT | MF_ALWAYS_SHOW_MORE</a>
<a name="ln2253">                        | MF_ALLOW_FORMATTING);</a>
<a name="ln2254"> </a>
<a name="ln2255">    fill_out_menu(shopmenu);</a>
<a name="ln2256"> </a>
<a name="ln2257">    shopmenu.on_single_selection =</a>
<a name="ln2258">        [this, &amp;shopmenu, &amp;mtitle](const MenuEntry&amp; sel)</a>
<a name="ln2259">    {</a>
<a name="ln2260">        const CrawlHashTable* thing =</a>
<a name="ln2261">            static_cast&lt;const CrawlHashTable *&gt;(sel.data);</a>
<a name="ln2262"> </a>
<a name="ln2263">        const bool is_item = thing_is_item(*thing);</a>
<a name="ln2264"> </a>
<a name="ln2265">        if (shopmenu.menu_action == Menu::ACT_EXECUTE)</a>
<a name="ln2266">        {</a>
<a name="ln2267">            int cost = thing_cost(*thing);</a>
<a name="ln2268"> </a>
<a name="ln2269">            if (cost &gt; you.gold)</a>
<a name="ln2270">            {</a>
<a name="ln2271">                string prompt =</a>
<a name="ln2272">                   make_stringf(&quot;You cannot afford %s; travel there &quot;</a>
<a name="ln2273">                                &quot;anyway? (y/N)&quot;,</a>
<a name="ln2274">                                describe_thing(*thing, DESC_A).c_str());</a>
<a name="ln2275">                clrscr();</a>
<a name="ln2276">                if (!yesno(prompt.c_str(), true, 'n'))</a>
<a name="ln2277">                    return true;</a>
<a name="ln2278">            }</a>
<a name="ln2279"> </a>
<a name="ln2280">            const level_pos lp(thing_pos(*thing));</a>
<a name="ln2281">            start_translevel_travel(lp);</a>
<a name="ln2282">            return false;</a>
<a name="ln2283">        }</a>
<a name="ln2284">        else if (shopmenu.menu_action == Menu::ACT_EXAMINE)</a>
<a name="ln2285">        {</a>
<a name="ln2286">            if (is_item)</a>
<a name="ln2287">            {</a>
<a name="ln2288">                const item_def &amp;item = get_thing_item(*thing);</a>
<a name="ln2289">                describe_item(const_cast&lt;item_def&amp;&gt;(item));</a>
<a name="ln2290">            }</a>
<a name="ln2291">            else // not an item, so we only stored a description.</a>
<a name="ln2292">            {</a>
<a name="ln2293">                // HACK: Assume it's some kind of portal vault.</a>
<a name="ln2294">                const string info = make_stringf(</a>
<a name="ln2295">                             &quot;%s with an entry fee of %d gold pieces.&quot;,</a>
<a name="ln2296">                             describe_thing(*thing, DESC_A).c_str(),</a>
<a name="ln2297">                             (int) thing_cost(*thing));</a>
<a name="ln2298">                show_description(info.c_str());</a>
<a name="ln2299">            }</a>
<a name="ln2300">        }</a>
<a name="ln2301">        else if (shopmenu.menu_action == Menu::ACT_MISC)</a>
<a name="ln2302">        {</a>
<a name="ln2303">            const int index = shopmenu.get_entry_index(&amp;sel);</a>
<a name="ln2304">            if (index == -1)</a>
<a name="ln2305">            {</a>
<a name="ln2306">                mprf(MSGCH_ERROR, &quot;ERROR: Unable to delete thing from shopping list!&quot;);</a>
<a name="ln2307">                more();</a>
<a name="ln2308">                return true;</a>
<a name="ln2309">            }</a>
<a name="ln2310"> </a>
<a name="ln2311">            del_thing_at_index(index);</a>
<a name="ln2312">            mtitle-&gt;quantity = this-&gt;list-&gt;size();</a>
<a name="ln2313">            shopmenu.set_title(mtitle);</a>
<a name="ln2314"> </a>
<a name="ln2315">            if (this-&gt;list-&gt;empty())</a>
<a name="ln2316">            {</a>
<a name="ln2317">                mpr(&quot;Your shopping list is now empty.&quot;);</a>
<a name="ln2318">                return false;</a>
<a name="ln2319">            }</a>
<a name="ln2320"> </a>
<a name="ln2321">            shopmenu.clear();</a>
<a name="ln2322">            fill_out_menu(shopmenu);</a>
<a name="ln2323">            shopmenu.update_menu(true);</a>
<a name="ln2324">        }</a>
<a name="ln2325">        else</a>
<a name="ln2326">            die(&quot;Invalid menu action type&quot;);</a>
<a name="ln2327">        return true;</a>
<a name="ln2328">    };</a>
<a name="ln2329"> </a>
<a name="ln2330">    shopmenu.show();</a>
<a name="ln2331">    redraw_screen();</a>
<a name="ln2332">}</a>
<a name="ln2333"> </a>
<a name="ln2334">static bool _compare_shopping_things(const CrawlStoreValue&amp; a,</a>
<a name="ln2335">                                     const CrawlStoreValue&amp; b)</a>
<a name="ln2336">{</a>
<a name="ln2337">    const CrawlHashTable&amp; hash_a = a.get_table();</a>
<a name="ln2338">    const CrawlHashTable&amp; hash_b = b.get_table();</a>
<a name="ln2339"> </a>
<a name="ln2340">    const int a_cost = hash_a[SHOPPING_THING_COST_KEY];</a>
<a name="ln2341">    const int b_cost = hash_b[SHOPPING_THING_COST_KEY];</a>
<a name="ln2342"> </a>
<a name="ln2343">    const level_id id_a = hash_a[SHOPPING_THING_POS_KEY].get_level_pos().id;</a>
<a name="ln2344">    const level_id id_b = hash_b[SHOPPING_THING_POS_KEY].get_level_pos().id;</a>
<a name="ln2345"> </a>
<a name="ln2346">    // Put Bazaar items at the top of the shopping list.</a>
<a name="ln2347">    if (!player_in_branch(BRANCH_BAZAAR) || id_a.branch == id_b.branch)</a>
<a name="ln2348">        return a_cost &lt; b_cost;</a>
<a name="ln2349">    else</a>
<a name="ln2350">        return id_a.branch == BRANCH_BAZAAR;</a>
<a name="ln2351">}</a>
<a name="ln2352"> </a>
<a name="ln2353">// Reset max_buyable and min_unbuyable info. Call this anytime any of the</a>
<a name="ln2354">// player's gold, the shopping list, and the prices of the items on it</a>
<a name="ln2355">// change.</a>
<a name="ln2356">void ShoppingList::refresh()</a>
<a name="ln2357">{</a>
<a name="ln2358">    if (!you.props.exists(SHOPPING_LIST_KEY))</a>
<a name="ln2359">        you.props[SHOPPING_LIST_KEY].new_vector(SV_HASH, SFLAG_CONST_TYPE);</a>
<a name="ln2360">    list = &amp;you.props[SHOPPING_LIST_KEY].get_vector();</a>
<a name="ln2361"> </a>
<a name="ln2362">    stable_sort(list-&gt;begin(), list-&gt;end(), _compare_shopping_things);</a>
<a name="ln2363"> </a>
<a name="ln2364">    min_unbuyable_cost = INT_MAX;</a>
<a name="ln2365">    min_unbuyable_idx  = -1;</a>
<a name="ln2366">    max_buyable_cost   = -1;</a>
<a name="ln2367">    max_buyable_idx    = -1;</a>
<a name="ln2368"> </a>
<a name="ln2369">    int total_cost = 0;</a>
<a name="ln2370"> </a>
<a name="ln2371">    for (unsigned int i = 0; i &lt; list-&gt;size(); i++)</a>
<a name="ln2372">    {</a>
<a name="ln2373">        const CrawlHashTable &amp;thing = (*list)[i];</a>
<a name="ln2374"> </a>
<a name="ln2375">        const int cost = thing_cost(thing);</a>
<a name="ln2376"> </a>
<a name="ln2377">        if (cost &lt;= you.gold)</a>
<a name="ln2378">        {</a>
<a name="ln2379">            max_buyable_cost = cost;</a>
<a name="ln2380">            max_buyable_idx  = i;</a>
<a name="ln2381">        }</a>
<a name="ln2382">        else if (min_unbuyable_idx == -1)</a>
<a name="ln2383">        {</a>
<a name="ln2384">            min_unbuyable_cost = cost;</a>
<a name="ln2385">            min_unbuyable_idx  = i;</a>
<a name="ln2386">        }</a>
<a name="ln2387">        total_cost += cost;</a>
<a name="ln2388">    }</a>
<a name="ln2389">    you.props[SHOPPING_LIST_COST_KEY].get_int() = total_cost;</a>
<a name="ln2390">}</a>
<a name="ln2391"> </a>
<a name="ln2392">unordered_set&lt;int&gt; ShoppingList::find_thing(const item_def &amp;item,</a>
<a name="ln2393">                             const level_pos &amp;pos) const</a>
<a name="ln2394">{</a>
<a name="ln2395">    unordered_set&lt;int&gt; result;</a>
<a name="ln2396">    for (unsigned int i = 0; i &lt; list-&gt;size(); i++)</a>
<a name="ln2397">    {</a>
<a name="ln2398">        const CrawlHashTable &amp;thing = (*list)[i];</a>
<a name="ln2399">        const level_pos       _pos  = thing_pos(thing);</a>
<a name="ln2400"> </a>
<a name="ln2401">        if (pos != _pos) // TODO: using thing_pos above seems to make this unreliable?</a>
<a name="ln2402">            continue;</a>
<a name="ln2403"> </a>
<a name="ln2404">        if (!thing_is_item(thing))</a>
<a name="ln2405">            continue;</a>
<a name="ln2406"> </a>
<a name="ln2407">        const item_def &amp;_item = get_thing_item(thing);</a>
<a name="ln2408"> </a>
<a name="ln2409">        if (item_name_simple(item) == item_name_simple(_item))</a>
<a name="ln2410">            result.insert(i);</a>
<a name="ln2411">    }</a>
<a name="ln2412"> </a>
<a name="ln2413">    return result;</a>
<a name="ln2414">}</a>
<a name="ln2415"> </a>
<a name="ln2416">unordered_set&lt;int&gt; ShoppingList::find_thing(const string &amp;desc, const level_pos &amp;pos) const</a>
<a name="ln2417">{</a>
<a name="ln2418">    unordered_set&lt;int&gt; result;</a>
<a name="ln2419">    for (unsigned int i = 0; i &lt; list-&gt;size(); i++)</a>
<a name="ln2420">    {</a>
<a name="ln2421">        const CrawlHashTable &amp;thing = (*list)[i];</a>
<a name="ln2422">        const level_pos       _pos  = thing_pos(thing);</a>
<a name="ln2423"> </a>
<a name="ln2424">        if (pos != _pos)</a>
<a name="ln2425">            continue;</a>
<a name="ln2426"> </a>
<a name="ln2427">        if (thing_is_item(thing))</a>
<a name="ln2428">            continue;</a>
<a name="ln2429"> </a>
<a name="ln2430">        if (desc == name_thing(thing))</a>
<a name="ln2431">            result.insert(i);</a>
<a name="ln2432">    }</a>
<a name="ln2433"> </a>
<a name="ln2434">    return result;</a>
<a name="ln2435">}</a>
<a name="ln2436"> </a>
<a name="ln2437">bool ShoppingList::thing_is_item(const CrawlHashTable&amp; thing)</a>
<a name="ln2438">{</a>
<a name="ln2439">    return thing.exists(SHOPPING_THING_ITEM_KEY);</a>
<a name="ln2440">}</a>
<a name="ln2441"> </a>
<a name="ln2442">const item_def&amp; ShoppingList::get_thing_item(const CrawlHashTable&amp; thing)</a>
<a name="ln2443">{</a>
<a name="ln2444">    ASSERT(thing.exists(SHOPPING_THING_ITEM_KEY));</a>
<a name="ln2445"> </a>
<a name="ln2446">    const item_def &amp;item = thing[SHOPPING_THING_ITEM_KEY].get_item();</a>
<a name="ln2447">    ASSERT(item.defined());</a>
<a name="ln2448"> </a>
<a name="ln2449">    return item;</a>
<a name="ln2450">}</a>
<a name="ln2451"> </a>
<a name="ln2452">string ShoppingList::get_thing_desc(const CrawlHashTable&amp; thing)</a>
<a name="ln2453">{</a>
<a name="ln2454">    ASSERT(thing.exists(SHOPPING_THING_DESC_KEY));</a>
<a name="ln2455"> </a>
<a name="ln2456">    string desc = thing[SHOPPING_THING_DESC_KEY].get_string();</a>
<a name="ln2457">    return desc;</a>
<a name="ln2458">}</a>
<a name="ln2459"> </a>
<a name="ln2460">int ShoppingList::thing_cost(const CrawlHashTable&amp; thing)</a>
<a name="ln2461">{</a>
<a name="ln2462">    ASSERT(thing.exists(SHOPPING_THING_COST_KEY));</a>
<a name="ln2463">    return thing[SHOPPING_THING_COST_KEY].get_int();</a>
<a name="ln2464">}</a>
<a name="ln2465"> </a>
<a name="ln2466">level_pos ShoppingList::thing_pos(const CrawlHashTable&amp; thing)</a>
<a name="ln2467">{</a>
<a name="ln2468">    ASSERT(thing.exists(SHOPPING_THING_POS_KEY));</a>
<a name="ln2469">    return thing[SHOPPING_THING_POS_KEY].get_level_pos();</a>
<a name="ln2470">}</a>
<a name="ln2471"> </a>
<a name="ln2472">string ShoppingList::name_thing(const CrawlHashTable&amp; thing,</a>
<a name="ln2473">                                description_level_type descrip)</a>
<a name="ln2474">{</a>
<a name="ln2475">    if (thing_is_item(thing))</a>
<a name="ln2476">    {</a>
<a name="ln2477">        const item_def &amp;item = get_thing_item(thing);</a>
<a name="ln2478">        return item.name(descrip);</a>
<a name="ln2479">    }</a>
<a name="ln2480">    else</a>
<a name="ln2481">    {</a>
<a name="ln2482">        string desc = get_thing_desc(thing);</a>
<a name="ln2483">        return apply_description(descrip, desc);</a>
<a name="ln2484">    }</a>
<a name="ln2485">}</a>
<a name="ln2486"> </a>
<a name="ln2487">string ShoppingList::describe_thing(const CrawlHashTable&amp; thing,</a>
<a name="ln2488">                                    description_level_type descrip)</a>
<a name="ln2489">{</a>
<a name="ln2490">    string desc = name_thing(thing, descrip) + &quot; on &quot;;</a>
<a name="ln2491"> </a>
<a name="ln2492">    const level_pos pos = thing_pos(thing);</a>
<a name="ln2493">    if (pos.id == level_id::current())</a>
<a name="ln2494">        desc += &quot;this level&quot;;</a>
<a name="ln2495">    else</a>
<a name="ln2496">        desc += pos.id.describe();</a>
<a name="ln2497"> </a>
<a name="ln2498">    return desc;</a>
<a name="ln2499">}</a>
<a name="ln2500"> </a>
<a name="ln2501">// Item name without curse-status or inscription.</a>
<a name="ln2502">string ShoppingList::item_name_simple(const item_def&amp; item, bool ident)</a>
<a name="ln2503">{</a>
<a name="ln2504">    return item.name(DESC_PLAIN, false, ident, false, false,</a>
<a name="ln2505">                     ISFLAG_KNOW_CURSE);</a>
<a name="ln2506">}</a>

</code></pre>
<div class="balloon" rel="751"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v636/" target="_blank">V636</a> The 'spells.size() / 6' expression was implicitly cast from 'size_t' type to 'double' type. Consider utilizing an explicit type cast to avoid the loss of a fractional part. An example: double A = (double)(X) / Y;.</p></div>
<div class="balloon" rel="1043"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v522/" target="_blank">V522</a> There might be dereferencing of a potential null pointer 'dynamic_cast< ShopEntry * > (item)'.</p></div>
<div class="balloon" rel="1112"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v522/" target="_blank">V522</a> There might be dereferencing of a potential null pointer 'dynamic_cast< ShopEntry * > (item)'.</p></div>
<div class="balloon" rel="1231"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v522/" target="_blank">V522</a> There might be dereferencing of a potential null pointer 'dynamic_cast< ShopEntry * > (a)'.</p></div>
<div class="balloon" rel="1232"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v522/" target="_blank">V522</a> There might be dereferencing of a potential null pointer 'dynamic_cast< ShopEntry * > (b)'.</p></div>
<div class="balloon" rel="1240"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v522/" target="_blank">V522</a> There might be dereferencing of a potential null pointer 'dynamic_cast< ShopEntry * > (a)'.</p></div>
<div class="balloon" rel="1241"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v522/" target="_blank">V522</a> There might be dereferencing of a potential null pointer 'dynamic_cast< ShopEntry * > (b)'.</p></div>
<div class="balloon" rel="1248"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v522/" target="_blank">V522</a> There might be dereferencing of a potential null pointer 'dynamic_cast< ShopEntry * > (a)'.</p></div>
<div class="balloon" rel="1249"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v522/" target="_blank">V522</a> There might be dereferencing of a potential null pointer 'dynamic_cast< ShopEntry * > (b)'.</p></div>
<div class="balloon" rel="1293"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v522/" target="_blank">V522</a> There might be dereferencing of a potential null pointer 'dynamic_cast< ShopEntry * > (entry)'.</p></div>
<div class="balloon" rel="1302"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v522/" target="_blank">V522</a> There might be dereferencing of a potential null pointer 'dynamic_cast< ShopEntry * > (entry)'.</p></div>
<div class="balloon" rel="1321"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v522/" target="_blank">V522</a> There might be dereferencing of a potential null pointer.</p></div>
<div class="balloon" rel="1345"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v522/" target="_blank">V522</a> There might be dereferencing of a potential null pointer 'entry'.</p></div>

<link rel="stylesheet" href="highlight.css">
<script src="highlight.pack.js"></script>
<script src="highlightjs-line-numbers.js"></script>
<script>hljs.initHighlightingOnLoad();</script>
<script>hljs.initLineNumbersOnLoad();</script>
<script>
  $(document).ready(function() {
      $('.balloon').each(function () {
          var bl = $(this);
          var line = bl.attr('rel');
          var text = $('a[name="ln'+line+'"]').text();

          var space_count = 0;
          for(var i = 0; i<text.length; i++){
              var char = text[i];
              if((char !== ' ')&&(char !== '\t'))break;
              if(char === '\t')space_count++;
              space_count++;
          }

          bl.css('margin-left', space_count*8);
          $('a[name="ln'+line+'"]').after(bl);
      });

      window.location = window.location;
  });
</script>
</body>
</html>
