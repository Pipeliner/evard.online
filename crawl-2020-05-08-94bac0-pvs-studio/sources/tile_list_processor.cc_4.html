
<html>
<head>

  <meta http-equiv="Content-Type" content="text/html; charset=US-ASCII" />
  <title>tile_list_processor.cc</title>

  <link rel="stylesheet" href="../style.css"/>
  <script src="../jquery-3.2.1.min.js"></script>
</head>
<body>

<pre><code class = "cpp">
<a name="ln1">#include &quot;tile_list_processor.h&quot;</a>
<a name="ln2"> </a>
<a name="ln3">#include &lt;cassert&gt;</a>
<a name="ln4">#include &lt;cctype&gt;</a>
<a name="ln5">#include &lt;iostream&gt;</a>
<a name="ln6">#include &lt;fstream&gt;</a>
<a name="ln7">#include &lt;string.h&gt;</a>
<a name="ln8">#include &lt;stdlib.h&gt;</a>
<a name="ln9">#include &lt;map&gt;</a>
<a name="ln10">#include &lt;algorithm&gt;</a>
<a name="ln11"> </a>
<a name="ln12">using namespace std;</a>
<a name="ln13"> </a>
<a name="ln14">tile_list_processor::tile_list_processor() :</a>
<a name="ln15">    m_last_enum(0),</a>
<a name="ln16">    m_rim(false),</a>
<a name="ln17">    m_corpsify(false),</a>
<a name="ln18">    m_composing(false),</a>
<a name="ln19">    m_shrink(true),</a>
<a name="ln20">    m_prefix(&quot;TILE&quot;),</a>
<a name="ln21">    m_start_value(&quot;0&quot;),</a>
<a name="ln22">    m_start_value_module(&quot;&quot;),</a>
<a name="ln23">    m_texture(0),</a>
<a name="ln24">    m_variation_idx(-1),</a>
<a name="ln25">    m_variation_col(-1),</a>
<a name="ln26">    m_weight(1),</a>
<a name="ln27">    m_alpha(0.0),</a>
<a name="ln28">    m_domino(0)</a>
<a name="ln29">{</a>
<a name="ln30">}</a>
<a name="ln31"> </a>
<a name="ln32">tile_list_processor::~tile_list_processor()</a>
<a name="ln33">{</a>
<a name="ln34">    for (unsigned int i = 0; i &lt; m_back.size(); i++)</a>
<a name="ln35">        delete m_back[i];</a>
<a name="ln36"> </a>
<a name="ln37">    m_back.resize(0);</a>
<a name="ln38">    if (m_texture)</a>
<a name="ln39">        delete m_texture;</a>
<a name="ln40">}</a>
<a name="ln41"> </a>
<a name="ln42">bool tile_list_processor::load_image_from_tile(tile &amp;img, string filename)</a>
<a name="ln43">{</a>
<a name="ln44">    if (filename.substr(0, 5) != &quot;enum:&quot;)</a>
<a name="ln45">        return false;</a>
<a name="ln46">    const string enumname = filename.substr(5);</a>
<a name="ln47"> </a>
<a name="ln48">    int idx = m_page.find(enumname);</a>
<a name="ln49">    if (idx == -1)</a>
<a name="ln50">        return false;</a>
<a name="ln51"> </a>
<a name="ln52">    img.copy(*m_page.m_tiles[idx]);</a>
<a name="ln53">    for (int i = 0; i &lt; MAX_COLOUR; ++i)</a>
<a name="ln54">        img.add_variation(i, -1);</a>
<a name="ln55">    return true;</a>
<a name="ln56">}</a>
<a name="ln57"> </a>
<a name="ln58">bool tile_list_processor::load_image(tile &amp;img, const char *filename,</a>
<a name="ln59">                                     bool background)</a>
<a name="ln60">{</a>
<a name="ln61">    assert(filename);</a>
<a name="ln62"> </a>
<a name="ln63">    if (load_image_from_tile(img, filename))</a>
<a name="ln64">        return true;</a>
<a name="ln65"> </a>
<a name="ln66">    char temp[1024];</a>
<a name="ln67"> </a>
<a name="ln68">    const unsigned int num_ext = 3;</a>
<a name="ln69">    const char *ext[3] =</a>
<a name="ln70">    {</a>
<a name="ln71">        &quot;.png&quot;,</a>
<a name="ln72">        &quot;.bmp&quot;,</a>
<a name="ln73">        &quot;&quot;</a>
<a name="ln74">    };</a>
<a name="ln75"> </a>
<a name="ln76">    if (m_sdir != &quot;&quot; || background &amp;&amp; m_back_sdir != &quot;&quot;)</a>
<a name="ln77">    {</a>
<a name="ln78">        vector&lt;const char *&gt; dirs;</a>
<a name="ln79">        if (m_sdir != &quot;&quot;)</a>
<a name="ln80">            dirs.push_back(m_sdir.c_str());</a>
<a name="ln81">        if (background &amp;&amp; m_back_sdir != &quot;&quot;)</a>
<a name="ln82">            dirs.push_back(m_back_sdir.c_str());</a>
<a name="ln83">        for (unsigned int e = 0; e &lt; num_ext; e++)</a>
<a name="ln84">        {</a>
<a name="ln85">            for (unsigned int d = 0; d &lt; dirs.size(); d++)</a>
<a name="ln86">            {</a>
<a name="ln87">                sprintf(temp, &quot;%s/%s%s&quot;, dirs[d], filename, ext[e]);</a>
<a name="ln88">                if (img.load(temp))</a>
<a name="ln89">                {</a>
<a name="ln90">                    m_depends.push_back(temp);</a>
<a name="ln91">                    return true;</a>
<a name="ln92">                }</a>
<a name="ln93">            }</a>
<a name="ln94">        }</a>
<a name="ln95">    }</a>
<a name="ln96"> </a>
<a name="ln97">    for (unsigned int e = 0; e &lt; num_ext; e++)</a>
<a name="ln98">    {</a>
<a name="ln99">        sprintf(temp, &quot;%s%s&quot;, filename, ext[e]);</a>
<a name="ln100">        if (img.load(temp))</a>
<a name="ln101">        {</a>
<a name="ln102">            m_depends.push_back(temp);</a>
<a name="ln103">            return true;</a>
<a name="ln104">        }</a>
<a name="ln105">    }</a>
<a name="ln106"> </a>
<a name="ln107">    return false;</a>
<a name="ln108">}</a>
<a name="ln109"> </a>
<a name="ln110">bool tile_list_processor::process_list(const char *list_file)</a>
<a name="ln111">{</a>
<a name="ln112">    m_depends.push_back(list_file);</a>
<a name="ln113"> </a>
<a name="ln114">    ifstream input(list_file);</a>
<a name="ln115">    if (!input.is_open())</a>
<a name="ln116">    {</a>
<a name="ln117">        fprintf(stderr, &quot;Error: couldn't open '%s' for read.\n&quot;, list_file);</a>
<a name="ln118">        return false;</a>
<a name="ln119">    }</a>
<a name="ln120"> </a>
<a name="ln121">    const size_t bufsize = 1024;</a>
<a name="ln122">    char read_line[bufsize];</a>
<a name="ln123">    int line     = 1;</a>
<a name="ln124">    bool success = true;</a>
<a name="ln125">    while (!input.getline(read_line, bufsize).eof())</a>
<a name="ln126">        success &amp;= process_line(read_line, list_file, line++);</a>
<a name="ln127"> </a>
<a name="ln128">    return success;</a>
<a name="ln129">}</a>
<a name="ln130"> </a>
<a name="ln131">static void eat_whitespace(char *&amp;text)</a>
<a name="ln132">{</a>
<a name="ln133">    if (!text)</a>
<a name="ln134">        return;</a>
<a name="ln135"> </a>
<a name="ln136">    while (*text)</a>
<a name="ln137">    {</a>
<a name="ln138">        if (*text != ' ' &amp;&amp; *text != '\n' &amp;&amp; *text != '\r')</a>
<a name="ln139">            break;</a>
<a name="ln140">        text++;</a>
<a name="ln141">    }</a>
<a name="ln142"> </a>
<a name="ln143">    if (!*text)</a>
<a name="ln144">        return;</a>
<a name="ln145"> </a>
<a name="ln146">    char *idx = &amp;text[strlen(text) - 1];</a>
<a name="ln147">    while (*idx)</a>
<a name="ln148">    {</a>
<a name="ln149">        if (*idx != ' ' &amp;&amp; *idx != '\n' &amp;&amp; *idx != '\r')</a>
<a name="ln150">            break;</a>
<a name="ln151">        *idx = 0;</a>
<a name="ln152">        idx--;</a>
<a name="ln153">    }</a>
<a name="ln154">}</a>
<a name="ln155"> </a>
<a name="ln156">static void eat_comments(char *&amp;text)</a>
<a name="ln157">{</a>
<a name="ln158">    if (!text)</a>
<a name="ln159">        return;</a>
<a name="ln160"> </a>
<a name="ln161">    char *idx = text;</a>
<a name="ln162">    while (*idx)</a>
<a name="ln163">    {</a>
<a name="ln164">        if (idx[0] == '/' &amp;&amp; idx[1] == '*')</a>
<a name="ln165">        {</a>
<a name="ln166">            char *end = idx + 2;</a>
<a name="ln167">            bool found = false;</a>
<a name="ln168">            while (*end)</a>
<a name="ln169">            {</a>
<a name="ln170">                if (end[0] == '*' &amp;&amp; end[1] == '/')</a>
<a name="ln171">                {</a>
<a name="ln172">                    found = true;</a>
<a name="ln173"> </a>
<a name="ln174">                    end += 2;</a>
<a name="ln175">                    char *begin = idx;</a>
<a name="ln176">                    while (*end)</a>
<a name="ln177">                    {</a>
<a name="ln178">                        *begin = *end;</a>
<a name="ln179">                        begin++;</a>
<a name="ln180">                        end++;</a>
<a name="ln181">                    }</a>
<a name="ln182">                    *begin = 0;</a>
<a name="ln183">                }</a>
<a name="ln184"> </a>
<a name="ln185">                end++;</a>
<a name="ln186">            }</a>
<a name="ln187"> </a>
<a name="ln188">            if (!found)</a>
<a name="ln189">            {</a>
<a name="ln190">                *idx = 0;</a>
<a name="ln191">                break;</a>
<a name="ln192">            }</a>
<a name="ln193">        }</a>
<a name="ln194"> </a>
<a name="ln195">        idx++;</a>
<a name="ln196">    }</a>
<a name="ln197">}</a>
<a name="ln198"> </a>
<a name="ln199">static const string colour_list[16] =</a>
<a name="ln200">{</a>
<a name="ln201">    &quot;black&quot;, &quot;blue&quot;, &quot;green&quot;, &quot;cyan&quot;, &quot;red&quot;, &quot;magenta&quot;, &quot;brown&quot;,</a>
<a name="ln202">    &quot;lightgrey&quot;, &quot;darkgrey&quot;, &quot;lightblue&quot;, &quot;lightgreen&quot;, &quot;lightcyan&quot;,</a>
<a name="ln203">    &quot;lightred&quot;, &quot;lightmagenta&quot;, &quot;yellow&quot;, &quot;white&quot;</a>
<a name="ln204">};</a>
<a name="ln205"> </a>
<a name="ln206">static int str_to_colour(string colour)</a>
<a name="ln207">{</a>
<a name="ln208">    if (colour.empty())</a>
<a name="ln209">        return 0;</a>
<a name="ln210"> </a>
<a name="ln211">    for (unsigned int c = 0; c &lt; colour.size(); c++)</a>
<a name="ln212">        colour[c] = toalower(colour[c]);</a>
<a name="ln213"> </a>
<a name="ln214">    for (int i = 0; i &lt; 16; ++i)</a>
<a name="ln215">    {</a>
<a name="ln216">        if (colour == colour_list[i])</a>
<a name="ln217">            return i;</a>
<a name="ln218">    }</a>
<a name="ln219"> </a>
<a name="ln220">    // Check for alternate spellings.</a>
<a name="ln221">    if (colour == &quot;lightgray&quot;)</a>
<a name="ln222">        return 7;</a>
<a name="ln223">    else if (colour == &quot;darkgray&quot;)</a>
<a name="ln224">        return 8;</a>
<a name="ln225"> </a>
<a name="ln226">    return 0;</a>
<a name="ln227">}</a>
<a name="ln228"> </a>
<a name="ln229">void tile_list_processor::recolour(tile &amp;img)</a>
<a name="ln230">{</a>
<a name="ln231">    for (int y = 0; y &lt; img.height(); ++y)</a>
<a name="ln232">        for (int x = 0; x &lt; img.width(); ++x)</a>
<a name="ln233">        {</a>
<a name="ln234">            tile_colour &amp;col = img.get_pixel(x, y);</a>
<a name="ln235">            tile_colour orig = col;</a>
<a name="ln236">            for (palette_list::iterator iter = m_palette.begin();</a>
<a name="ln237">                 iter != m_palette.end(); ++iter)</a>
<a name="ln238">            {</a>
<a name="ln239">                if (orig == iter-&gt;first)</a>
<a name="ln240">                    col = iter-&gt;second;</a>
<a name="ln241">            }</a>
<a name="ln242"> </a>
<a name="ln243">            for (hue_list::iterator iter = m_hues.begin();</a>
<a name="ln244">                 iter != m_hues.end(); ++iter)</a>
<a name="ln245">            {</a>
<a name="ln246">                if (orig.get_hue() == iter-&gt;first)</a>
<a name="ln247">                    col.set_hue(iter-&gt;second);</a>
<a name="ln248">            }</a>
<a name="ln249"> </a>
<a name="ln250">            for (desat_list::iterator iter = m_desat.begin();</a>
<a name="ln251">                iter != m_desat.end(); ++iter)</a>
<a name="ln252">            {</a>
<a name="ln253">                if (orig.get_hue() == *iter)</a>
<a name="ln254">                    col.desaturate();</a>
<a name="ln255">            }</a>
<a name="ln256"> </a>
<a name="ln257">            for (lum_list::iterator iter = m_lum.begin();</a>
<a name="ln258">                iter != m_lum.end(); ++iter)</a>
<a name="ln259">            {</a>
<a name="ln260">                if (orig.get_hue() == iter-&gt;first)</a>
<a name="ln261">                    col.change_lum(iter-&gt;second);</a>
<a name="ln262">            }</a>
<a name="ln263"> </a>
<a name="ln264">            // Ignore 0 alpha since it'd just set the whole image transparent</a>
<a name="ln265">            if (m_alpha &gt; 0.0)</a>
<a name="ln266">                col.a = min(255.0,(double)col.a * m_alpha);</a>
<a name="ln267">        }</a>
<a name="ln268">}</a>
<a name="ln269"> </a>
<a name="ln270">bool tile_list_processor::process_line(char *read_line, const char *list_file,</a>
<a name="ln271">                                       int line)</a>
<a name="ln272">{</a>
<a name="ln273">    eat_comments(read_line);</a>
<a name="ln274"> </a>
<a name="ln275">    const char *delim = &quot; &quot;;</a>
<a name="ln276">    char *arg;</a>
<a name="ln277"> </a>
<a name="ln278">    arg = strtok(read_line, delim);</a>
<a name="ln279">    if (!arg)</a>
<a name="ln280">        return true;</a>
<a name="ln281"> </a>
<a name="ln282">    eat_whitespace(arg);</a>
<a name="ln283"> </a>
<a name="ln284">    if (!*arg)</a>
<a name="ln285">        return true;</a>
<a name="ln286"> </a>
<a name="ln287">    if (arg[0] == '#')</a>
<a name="ln288">        return true;</a>
<a name="ln289"> </a>
<a name="ln290">    vector&lt;char *&gt; m_args;</a>
<a name="ln291">    m_args.push_back(arg);</a>
<a name="ln292"> </a>
<a name="ln293">    while (char *extra = strtok(nullptr, delim))</a>
<a name="ln294">    {</a>
<a name="ln295">        eat_whitespace(extra);</a>
<a name="ln296">        if (!*extra)</a>
<a name="ln297">            continue;</a>
<a name="ln298"> </a>
<a name="ln299">        m_args.push_back(extra);</a>
<a name="ln300">    }</a>
<a name="ln301"> </a>
<a name="ln302">    if (arg[0] == '%')</a>
<a name="ln303">    {</a>
<a name="ln304">        arg++;</a>
<a name="ln305"> </a>
<a name="ln306">        #define CHECK_NO_ARG(x) \</a>
<a name="ln307">            if (m_args.size() &gt; x) \</a>
<a name="ln308">            { \</a>
<a name="ln309">                fprintf(stderr, &quot;Error (%s:%d): &quot; \</a>
<a name="ln310">                    &quot;invalid args following '%s'.\n&quot;, \</a>
<a name="ln311">                    list_file, line, arg); \</a>
<a name="ln312">                return false; \</a>
<a name="ln313">            }</a>
<a name="ln314"> </a>
<a name="ln315">        #define CHECK_ARG(x) \</a>
<a name="ln316">            if (m_args.size() &lt;= x) \</a>
<a name="ln317">            { \</a>
<a name="ln318">                fprintf(stderr, &quot;Error (%s:%d): &quot; \</a>
<a name="ln319">                    &quot;missing arg following '%s'.\n&quot;, \</a>
<a name="ln320">                    list_file, line, arg); \</a>
<a name="ln321">                return false; \</a>
<a name="ln322">            }</a>
<a name="ln323"> </a>
<a name="ln324">        if (strcmp(arg, &quot;back&quot;) == 0)</a>
<a name="ln325">        {</a>
<a name="ln326">            CHECK_ARG(1);</a>
<a name="ln327"> </a>
<a name="ln328">            for (unsigned int i = 0; i &lt; m_back.size(); i++)</a>
<a name="ln329">                delete m_back[i];</a>
<a name="ln330"> </a>
<a name="ln331">            m_back.resize(0);</a>
<a name="ln332"> </a>
<a name="ln333">            if (strcmp(m_args[1], &quot;none&quot;) == 0)</a>
<a name="ln334">            {</a>
<a name="ln335">                CHECK_NO_ARG(2);</a>
<a name="ln336">                return true;</a>
<a name="ln337">            }</a>
<a name="ln338"> </a>
<a name="ln339">            for (unsigned int i = 1; i &lt; m_args.size(); i++)</a>
<a name="ln340">            {</a>
<a name="ln341">                tile *img = new tile();</a>
<a name="ln342">                if (!load_image(*img, m_args[i], true))</a>
<a name="ln343">                {</a>
<a name="ln344">                    fprintf(stderr, &quot;Error(%s:%d): couldn't load image &quot;</a>
<a name="ln345">                                    &quot;'%s'.\n&quot;, list_file, line, m_args[i]);</a>
<a name="ln346">                    return false;</a>
<a name="ln347">                }</a>
<a name="ln348">                m_back.push_back(img);</a>
<a name="ln349">            }</a>
<a name="ln350">        }</a>
<a name="ln351">        else if (strcmp(arg, &quot;compose&quot;) == 0)</a>
<a name="ln352">        {</a>
<a name="ln353">            CHECK_ARG(1);</a>
<a name="ln354">            if (!m_composing)</a>
<a name="ln355">            {</a>
<a name="ln356">                fprintf(stderr, &quot;Error (%s:%d): not composing yet.\n&quot;,</a>
<a name="ln357">                        list_file, line);</a>
<a name="ln358">                return false;</a>
<a name="ln359">            }</a>
<a name="ln360"> </a>
<a name="ln361">            if (m_compose.valid())</a>
<a name="ln362">            {</a>
<a name="ln363">                tile img;</a>
<a name="ln364">                if (!load_image(img, m_args[1]))</a>
<a name="ln365">                {</a>
<a name="ln366">                    fprintf(stderr, &quot;Error(%s:%d): couldn't load image &quot;</a>
<a name="ln367">                                    &quot;'%s'.\n&quot;, list_file, line, m_args[1]);</a>
<a name="ln368">                    return false;</a>
<a name="ln369">                }</a>
<a name="ln370"> </a>
<a name="ln371">                if (m_rim)</a>
<a name="ln372">                    img.add_rim(tile_colour::black);</a>
<a name="ln373"> </a>
<a name="ln374">                recolour(img);</a>
<a name="ln375"> </a>
<a name="ln376">                if (!m_compose.compose(img))</a>
<a name="ln377">                {</a>
<a name="ln378">                    fprintf(stderr, &quot;Error (%s:%d): failed composing '%s'&quot;</a>
<a name="ln379">                                    &quot; onto compose image.\n&quot;,</a>
<a name="ln380">                            list_file, line, m_args[1]);</a>
<a name="ln381">                    return false;</a>
<a name="ln382">                }</a>
<a name="ln383">            }</a>
<a name="ln384">            else</a>
<a name="ln385">            {</a>
<a name="ln386">                if (!load_image(m_compose, m_args[1]))</a>
<a name="ln387">                {</a>
<a name="ln388">                    fprintf(stderr, &quot;Error(%s:%d): couldn't load image &quot;</a>
<a name="ln389">                                    &quot;'%s'.\n&quot;, list_file, line, m_args[1]);</a>
<a name="ln390">                    return false;</a>
<a name="ln391">                }</a>
<a name="ln392"> </a>
<a name="ln393">                recolour(m_compose);</a>
<a name="ln394">            }</a>
<a name="ln395">        }</a>
<a name="ln396">        else if (strcmp(arg, &quot;corpse&quot;) == 0)</a>
<a name="ln397">        {</a>
<a name="ln398">            CHECK_ARG(1);</a>
<a name="ln399">            m_corpsify = (bool)atoi(m_args[1]);</a>
<a name="ln400">        }</a>
<a name="ln401">        else if (strcmp(arg, &quot;end_ctg&quot;) == 0)</a>
<a name="ln402">        {</a>
<a name="ln403">            CHECK_NO_ARG(1);</a>
<a name="ln404"> </a>
<a name="ln405">            if (m_parts_ctg.empty())</a>
<a name="ln406">            {</a>
<a name="ln407">                fprintf(stderr, &quot;Error (%s:%d): no category to end.\n&quot;,</a>
<a name="ln408">                        list_file, line);</a>
<a name="ln409">                return false;</a>
<a name="ln410">            }</a>
<a name="ln411"> </a>
<a name="ln412">            m_parts_ctg.clear();</a>
<a name="ln413">        }</a>
<a name="ln414">        else if (strcmp(arg, &quot;finish&quot;) == 0)</a>
<a name="ln415">        {</a>
<a name="ln416">            if (!m_composing)</a>
<a name="ln417">            {</a>
<a name="ln418">                fprintf(stderr, &quot;Error (%s:%d): not composing yet.\n&quot;,</a>
<a name="ln419">                        list_file, line);</a>
<a name="ln420">                return false;</a>
<a name="ln421">            }</a>
<a name="ln422"> </a>
<a name="ln423">            if (m_corpsify)</a>
<a name="ln424">                m_compose.corpsify();</a>
<a name="ln425">            else if (m_rim)</a>
<a name="ln426">                m_compose.add_rim(tile_colour::black);</a>
<a name="ln427"> </a>
<a name="ln428">            if (m_texture)</a>
<a name="ln429">                m_compose.texture(*m_texture);</a>
<a name="ln430"> </a>
<a name="ln431">            if (!m_back.empty())</a>
<a name="ln432">            {</a>
<a name="ln433">                const unsigned int pseudo_rand = m_page.m_tiles.size() * 54321;</a>
<a name="ln434">                tile *back = m_back[pseudo_rand % m_back.size()];</a>
<a name="ln435">                tile img(*back);</a>
<a name="ln436">                if (!img.compose(m_compose))</a>
<a name="ln437">                {</a>
<a name="ln438">                    fprintf(stderr, &quot;Error (%s:%d): failed composing '%s'&quot;</a>
<a name="ln439">                                    &quot; onto back image '%s'.\n&quot;,</a>
<a name="ln440">                            list_file, line, arg, back-&gt;filename().c_str());</a>
<a name="ln441">                    return false;</a>
<a name="ln442">                }</a>
<a name="ln443">                add_image(img, m_args.size() &gt; 1 ? m_args[1] : nullptr);</a>
<a name="ln444">            }</a>
<a name="ln445">            else</a>
<a name="ln446">                add_image(m_compose, m_args.size() &gt; 1 ? m_args[1] : nullptr);</a>
<a name="ln447"> </a>
<a name="ln448">            m_compose.unload();</a>
<a name="ln449">            m_composing = false;</a>
<a name="ln450">        }</a>
<a name="ln451">        else if (strcmp(arg, &quot;texture&quot;) == 0)</a>
<a name="ln452">        {</a>
<a name="ln453">            CHECK_ARG(1);</a>
<a name="ln454"> </a>
<a name="ln455">            if (m_texture)</a>
<a name="ln456">                delete m_texture;</a>
<a name="ln457"> </a>
<a name="ln458">            if (strcmp(m_args[1], &quot;none&quot;) == 0)</a>
<a name="ln459">            {</a>
<a name="ln460">                CHECK_NO_ARG(2);</a>
<a name="ln461">                m_texture = 0;</a>
<a name="ln462">                return true;</a>
<a name="ln463">            }</a>
<a name="ln464"> </a>
<a name="ln465">            CHECK_NO_ARG(2);</a>
<a name="ln466">            tile *img = new tile();</a>
<a name="ln467">            if (!load_image(*img, m_args[1], true))</a>
<a name="ln468">            {</a>
<a name="ln469">                fprintf(stderr, &quot;Error(%s:%d): couldn't load image &quot;</a>
<a name="ln470">                                &quot;'%s'.\n&quot;, list_file, line, m_args[1]);</a>
<a name="ln471">                return false;</a>
<a name="ln472">            }</a>
<a name="ln473">            m_texture = img;</a>
<a name="ln474">        }</a>
<a name="ln475">        else if (strcmp(arg, &quot;include&quot;) == 0)</a>
<a name="ln476">        {</a>
<a name="ln477">            CHECK_ARG(1);</a>
<a name="ln478">            if (!process_list(m_args[1]))</a>
<a name="ln479">            {</a>
<a name="ln480">                fprintf(stderr, &quot;Error (%s:%d): include failed.\n&quot;,</a>
<a name="ln481">                        list_file, line);</a>
<a name="ln482">                return false;</a>
<a name="ln483">            }</a>
<a name="ln484">        }</a>
<a name="ln485">        else if (strcmp(arg, &quot;name&quot;) == 0)</a>
<a name="ln486">        {</a>
<a name="ln487">            CHECK_ARG(1);</a>
<a name="ln488"> </a>
<a name="ln489">            if (m_name != &quot;&quot;)</a>
<a name="ln490">            {</a>
<a name="ln491">                fprintf(stderr,</a>
<a name="ln492">                        &quot;Error (%s:%d): name already specified as '%s'\n&quot;,</a>
<a name="ln493">                        list_file, line, m_name.c_str());</a>
<a name="ln494">                return false;</a>
<a name="ln495">            }</a>
<a name="ln496"> </a>
<a name="ln497">            m_name = m_args[1];</a>
<a name="ln498">        }</a>
<a name="ln499">        else if (strcmp(arg, &quot;abstract&quot;) == 0)</a>
<a name="ln500">        {</a>
<a name="ln501">            CHECK_ARG(2);</a>
<a name="ln502"> </a>
<a name="ln503">            // filename / prefix pairs.</a>
<a name="ln504">            m_abstract.push_back(string_pair(m_args[1], m_args[2]));</a>
<a name="ln505">            char temp[1024];</a>
<a name="ln506">            sprintf(temp, &quot;tiledef-%s.h&quot;, m_args[1]);</a>
<a name="ln507">            m_include.push_back(temp);</a>
<a name="ln508">        }</a>
<a name="ln509">        else if (strcmp(arg, &quot;parts_ctg&quot;) == 0)</a>
<a name="ln510">        {</a>
<a name="ln511">            CHECK_ARG(1);</a>
<a name="ln512"> </a>
<a name="ln513">            for (unsigned int i = 0; i &lt; m_categories.size(); i++)</a>
<a name="ln514">            {</a>
<a name="ln515">                if (m_args[1] == m_categories[i])</a>
<a name="ln516">                {</a>
<a name="ln517">                    fprintf(stderr,</a>
<a name="ln518">                            &quot;Error (%s:%d): category '%s' already used.\n&quot;,</a>
<a name="ln519">                            list_file, line, m_args[1]);</a>
<a name="ln520">                    return false;</a>
<a name="ln521">                }</a>
<a name="ln522">            }</a>
<a name="ln523"> </a>
<a name="ln524">            m_parts_ctg = m_args[1];</a>
<a name="ln525">            m_categories.push_back(m_parts_ctg);</a>
<a name="ln526">            m_ctg_counts.push_back(0);</a>
<a name="ln527">        }</a>
<a name="ln528">        else if (strcmp(arg, &quot;prefix&quot;) == 0)</a>
<a name="ln529">        {</a>
<a name="ln530">            CHECK_ARG(1);</a>
<a name="ln531">            m_prefix = m_args[1];</a>
<a name="ln532">        }</a>
<a name="ln533">        else if (strcmp(arg, &quot;rim&quot;) == 0)</a>
<a name="ln534">        {</a>
<a name="ln535">            CHECK_ARG(1);</a>
<a name="ln536">            m_rim = (bool)atoi(m_args[1]);</a>
<a name="ln537">        }</a>
<a name="ln538">        else if (strcmp(arg, &quot;sdir&quot;) == 0)</a>
<a name="ln539">        {</a>
<a name="ln540">            CHECK_ARG(1);</a>
<a name="ln541">            m_sdir = m_args[1];</a>
<a name="ln542">        }</a>
<a name="ln543">        else if (strcmp(arg, &quot;back_sdir&quot;) == 0)</a>
<a name="ln544">        {</a>
<a name="ln545">            CHECK_ARG(1);</a>
<a name="ln546">            m_back_sdir = m_args[1];</a>
<a name="ln547">        }</a>
<a name="ln548">        else if (strcmp(arg, &quot;weight&quot;) == 0)</a>
<a name="ln549">        {</a>
<a name="ln550">            CHECK_ARG(1);</a>
<a name="ln551">            int tmp = atoi(m_args[1]);</a>
<a name="ln552"> </a>
<a name="ln553">            if (tmp &lt;= 0)</a>
<a name="ln554">            {</a>
<a name="ln555">                fprintf(stderr, &quot;Error (%s:%d): weight must be &gt;= 1.\n&quot;,</a>
<a name="ln556">                        list_file, line);</a>
<a name="ln557">                return false;</a>
<a name="ln558">            }</a>
<a name="ln559"> </a>
<a name="ln560">            m_weight = tmp;</a>
<a name="ln561">        }</a>
<a name="ln562">        else if (strcmp(arg, &quot;domino&quot;) == 0)</a>
<a name="ln563">        {</a>
<a name="ln564">            CHECK_ARG(1);</a>
<a name="ln565">            m_domino = atoi(m_args[1]);</a>
<a name="ln566">        }</a>
<a name="ln567">        else if (strcmp(arg, &quot;shrink&quot;) == 0)</a>
<a name="ln568">        {</a>
<a name="ln569">            CHECK_ARG(1);</a>
<a name="ln570">            m_shrink = (bool)atoi(m_args[1]);</a>
<a name="ln571">        }</a>
<a name="ln572">        else if (strcmp(arg, &quot;start&quot;) == 0)</a>
<a name="ln573">        {</a>
<a name="ln574">            CHECK_NO_ARG(1);</a>
<a name="ln575"> </a>
<a name="ln576">            if (m_composing)</a>
<a name="ln577">            {</a>
<a name="ln578">                fprintf(stderr, &quot;Error (%s:%d): already composing.\n&quot;,</a>
<a name="ln579">                        list_file, line);</a>
<a name="ln580">                return false;</a>
<a name="ln581">            }</a>
<a name="ln582">            m_composing = true;</a>
<a name="ln583">            m_compose.unload();</a>
<a name="ln584">        }</a>
<a name="ln585">        else if (strcmp(arg, &quot;startvalue&quot;) == 0)</a>
<a name="ln586">        {</a>
<a name="ln587">            CHECK_ARG(1);</a>
<a name="ln588">            CHECK_NO_ARG(3);</a>
<a name="ln589"> </a>
<a name="ln590">            m_start_value = m_args[1];</a>
<a name="ln591">            if (m_args.size() &gt; 2)</a>
<a name="ln592">            {</a>
<a name="ln593">                m_start_value_module = m_args[2];</a>
<a name="ln594">                char temp[1024];</a>
<a name="ln595">                sprintf(temp, &quot;tiledef-%s.h&quot;, m_args[2]);</a>
<a name="ln596">                m_include.push_back(temp);</a>
<a name="ln597">            }</a>
<a name="ln598">        }</a>
<a name="ln599">        else if (strcmp(arg, &quot;pal&quot;) == 0)</a>
<a name="ln600">        {</a>
<a name="ln601">            // rgb (optional a) = rgb (optional a)</a>
<a name="ln602">            tile_colour cols[2]  = { tile_colour::black, tile_colour::black };</a>
<a name="ln603">            int col_idx = 0;</a>
<a name="ln604">            int comp_idx = 0;</a>
<a name="ln605"> </a>
<a name="ln606">            for (size_t i = 1; i &lt; m_args.size(); ++i)</a>
<a name="ln607">            {</a>
<a name="ln608">                if (strcmp(m_args[i], &quot;=&quot;))</a>
<a name="ln609">                {</a>
<a name="ln610">                    if (comp_idx &gt; 3)</a>
<a name="ln611">                    {</a>
<a name="ln612">                        fprintf(stderr, &quot;Error (%s:%d): &quot;</a>
<a name="ln613">                                &quot;Must be R G B (A) = R G B (A).\n&quot;,</a>
<a name="ln614">                                list_file, line);</a>
<a name="ln615">                        return false;</a>
<a name="ln616">                    }</a>
<a name="ln617"> </a>
<a name="ln618">                    int val = atoi(m_args[i]);</a>
<a name="ln619">                    if (val &lt; 0 || val &gt; 255)</a>
<a name="ln620">                    {</a>
<a name="ln621">                        fprintf(stderr,</a>
<a name="ln622">                                &quot;Error (%s:%d): Arg %d must be 0-255.\n&quot;,</a>
<a name="ln623">                                list_file, line, (int)i);</a>
<a name="ln624">                    }</a>
<a name="ln625"> </a>
<a name="ln626">                    cols[col_idx][comp_idx++] = static_cast&lt;unsigned char&gt;(val);</a>
<a name="ln627">                }</a>
<a name="ln628">                else if (col_idx &gt; 0)</a>
<a name="ln629">                {</a>
<a name="ln630">                    fprintf(stderr,</a>
<a name="ln631">                            &quot;Error (%s:%d): Too many '=' characters.\n&quot;,</a>
<a name="ln632">                            list_file, line);</a>
<a name="ln633">                    return false;</a>
<a name="ln634">                }</a>
<a name="ln635">                else</a>
<a name="ln636">                {</a>
<a name="ln637">                    col_idx++;</a>
<a name="ln638">                    comp_idx = 0;</a>
<a name="ln639">                }</a>
<a name="ln640">            }</a>
<a name="ln641"> </a>
<a name="ln642">            m_palette.push_back(palette_entry(cols[0], cols[1]));</a>
<a name="ln643">        }</a>
<a name="ln644">        else if (strcmp(arg, &quot;hue&quot;) == 0)</a>
<a name="ln645">        {</a>
<a name="ln646">            CHECK_ARG(2);</a>
<a name="ln647">            m_hues.push_back(int_pair(atoi(m_args[1]), atoi(m_args[2])));</a>
<a name="ln648">        }</a>
<a name="ln649">        else if (strcmp(arg, &quot;alpha&quot;) == 0)</a>
<a name="ln650">        {</a>
<a name="ln651">            CHECK_ARG(1);</a>
<a name="ln652">            m_alpha = ((double)atoi(m_args[1]))/255.0;</a>
<a name="ln653">        }</a>
<a name="ln654">        else if (strcmp(arg, &quot;resetcol&quot;) == 0)</a>
<a name="ln655">        {</a>
<a name="ln656">            CHECK_NO_ARG(1);</a>
<a name="ln657">            m_palette.clear();</a>
<a name="ln658">            m_hues.clear();</a>
<a name="ln659">            m_desat.clear();</a>
<a name="ln660">            m_lum.clear();</a>
<a name="ln661">            m_alpha = 0.0;</a>
<a name="ln662">        }</a>
<a name="ln663">        else if (strcmp(arg, &quot;desat&quot;) == 0)</a>
<a name="ln664">        {</a>
<a name="ln665">            CHECK_ARG(1);</a>
<a name="ln666">            CHECK_NO_ARG(2);</a>
<a name="ln667"> </a>
<a name="ln668">            m_desat.push_back(atoi(m_args[1]));</a>
<a name="ln669">        }</a>
<a name="ln670">        else if (strcmp(arg, &quot;lum&quot;) == 0)</a>
<a name="ln671">        {</a>
<a name="ln672">            CHECK_ARG(2);</a>
<a name="ln673">            CHECK_NO_ARG(3);</a>
<a name="ln674"> </a>
<a name="ln675">            m_lum.push_back(int_pair(atoi(m_args[1]), atoi(m_args[2])));</a>
<a name="ln676">        }</a>
<a name="ln677">        else if (strcmp(arg, &quot;variation&quot;) == 0)</a>
<a name="ln678">        {</a>
<a name="ln679">            CHECK_ARG(2);</a>
<a name="ln680">            CHECK_NO_ARG(3);</a>
<a name="ln681"> </a>
<a name="ln682">            int idx = m_page.find(m_args[1]);</a>
<a name="ln683">            if (idx == -1)</a>
<a name="ln684">            {</a>
<a name="ln685">                fprintf(stderr, &quot;Error (%s:%d): invalid tile name '%s'\n&quot;,</a>
<a name="ln686">                        list_file, line, m_args[1]);</a>
<a name="ln687">                return false;</a>
<a name="ln688">            }</a>
<a name="ln689"> </a>
<a name="ln690">            int colour = str_to_colour(m_args[2]);</a>
<a name="ln691">            if (colour == 0)</a>
<a name="ln692">            {</a>
<a name="ln693">                fprintf(stderr, &quot;Error (%s:%d): invalid colour '%s'\n&quot;,</a>
<a name="ln694">                        list_file, line, m_args[2]);</a>
<a name="ln695">                return false;</a>
<a name="ln696">            }</a>
<a name="ln697"> </a>
<a name="ln698">            m_variation_idx = idx;</a>
<a name="ln699">            m_variation_col = colour;</a>
<a name="ln700">        }</a>
<a name="ln701">        else if (strcmp(arg, &quot;repeat&quot;) == 0)</a>
<a name="ln702">        {</a>
<a name="ln703">            CHECK_ARG(1);</a>
<a name="ln704"> </a>
<a name="ln705">            int idx = m_page.find(m_args[1]);</a>
<a name="ln706">            if (idx == -1)</a>
<a name="ln707">            {</a>
<a name="ln708">                fprintf(stderr, &quot;Error (%s:%d): invalid tile name '%s'\n&quot;,</a>
<a name="ln709">                        list_file, line, m_args[1]);</a>
<a name="ln710">                return false;</a>
<a name="ln711">            }</a>
<a name="ln712"> </a>
<a name="ln713">            int cnt = m_page.m_counts[idx];</a>
<a name="ln714"> </a>
<a name="ln715">            int old_w = 0;</a>
<a name="ln716">            for (int i = 0; i &lt; cnt; ++i)</a>
<a name="ln717">            {</a>
<a name="ln718">                tile img;</a>
<a name="ln719">                img.copy(*m_page.m_tiles[idx + i]);</a>
<a name="ln720">                recolour(img);</a>
<a name="ln721">                m_weight = m_page.m_probs[idx + i] - old_w;</a>
<a name="ln722">                old_w    = m_page.m_probs[idx + i];</a>
<a name="ln723">                add_image(img, (i == 0 &amp;&amp; m_args[2]) ? m_args[2] : nullptr);</a>
<a name="ln724">            }</a>
<a name="ln725"> </a>
<a name="ln726">            if (m_args.size() &gt; 2)</a>
<a name="ln727">            {</a>
<a name="ln728">                for (unsigned int i = 3; i &lt; m_args.size(); ++i)</a>
<a name="ln729">                {</a>
<a name="ln730">                    // Add enums for additional values.</a>
<a name="ln731">                    m_page.add_synonym(m_args[2], m_args[i]);</a>
<a name="ln732">                }</a>
<a name="ln733">            }</a>
<a name="ln734">        }</a>
<a name="ln735">        else if (strcmp(arg, &quot;syn&quot;) == 0)</a>
<a name="ln736">        {</a>
<a name="ln737">            // Add a synonym without resetting the enum count.</a>
<a name="ln738">            CHECK_ARG(1);</a>
<a name="ln739"> </a>
<a name="ln740">            for (unsigned int i = 1; i &lt; m_args.size(); ++i)</a>
<a name="ln741">                m_page.add_synonym(m_page.m_tiles.size() - 1, m_args[i]);</a>
<a name="ln742">        }</a>
<a name="ln743">        else</a>
<a name="ln744">        {</a>
<a name="ln745">            fprintf(stderr, &quot;Error (%s:%d): unknown command '%%%s'\n&quot;,</a>
<a name="ln746">                    list_file, line, arg);</a>
<a name="ln747">            return false;</a>
<a name="ln748">        }</a>
<a name="ln749">    }</a>
<a name="ln750">    else</a>
<a name="ln751">    {</a>
<a name="ln752">        if (m_composing)</a>
<a name="ln753">        {</a>
<a name="ln754">            fprintf(stderr, &quot;Error (%s:%d): can't load while composing.\n&quot;,</a>
<a name="ln755">                    list_file, line);</a>
<a name="ln756">            return false;</a>
<a name="ln757">        }</a>
<a name="ln758"> </a>
<a name="ln759">        tile img;</a>
<a name="ln760"> </a>
<a name="ln761">        if (!m_back.empty())</a>
<a name="ln762">        {</a>
<a name="ln763">            // compose</a>
<a name="ln764">            if (!load_image(m_compose, arg, true))</a>
<a name="ln765">            {</a>
<a name="ln766">                fprintf(stderr, &quot;Error (%s:%d): couldn't load image &quot;</a>
<a name="ln767">                                &quot;'%s'.\n&quot;, list_file, line, arg);</a>
<a name="ln768">                return false;</a>
<a name="ln769">            }</a>
<a name="ln770"> </a>
<a name="ln771">            if (m_corpsify)</a>
<a name="ln772">                m_compose.corpsify();</a>
<a name="ln773"> </a>
<a name="ln774">            if (m_texture)</a>
<a name="ln775">                m_compose.texture(*m_texture);</a>
<a name="ln776"> </a>
<a name="ln777">            const unsigned int pseudo_rand = m_page.m_tiles.size() * 54321;</a>
<a name="ln778">            tile *back = m_back[pseudo_rand % m_back.size()];</a>
<a name="ln779">            img.copy(*back);</a>
<a name="ln780">            if (!img.compose(m_compose))</a>
<a name="ln781">            {</a>
<a name="ln782">                fprintf(stderr, &quot;Error (%s:%d): failed composing '%s'&quot;</a>
<a name="ln783">                                &quot; onto back image '%s'.\n&quot;,</a>
<a name="ln784">                        list_file, line, arg, back-&gt;filename().c_str());</a>
<a name="ln785">                return false;</a>
<a name="ln786">            }</a>
<a name="ln787">        }</a>
<a name="ln788">        else</a>
<a name="ln789">        {</a>
<a name="ln790">            if (!load_image(img, arg))</a>
<a name="ln791">            {</a>
<a name="ln792">                fprintf(stderr, &quot;Error (%s:%d): couldn't load image &quot;</a>
<a name="ln793">                                &quot;'%s'.\n&quot;, list_file, line, arg);</a>
<a name="ln794">                return false;</a>
<a name="ln795">            }</a>
<a name="ln796"> </a>
<a name="ln797">            if (m_corpsify)</a>
<a name="ln798">                img.corpsify();</a>
<a name="ln799"> </a>
<a name="ln800">            if (m_texture)</a>
<a name="ln801">                img.texture(*m_texture);</a>
<a name="ln802">        }</a>
<a name="ln803"> </a>
<a name="ln804">        recolour(img);</a>
<a name="ln805"> </a>
<a name="ln806">        if (m_rim &amp;&amp; !m_corpsify)</a>
<a name="ln807">            img.add_rim(tile_colour::black);</a>
<a name="ln808"> </a>
<a name="ln809">        // Push tile onto tile page.</a>
<a name="ln810">        add_image(img, m_args.size() &gt; 1 ? m_args[1] : nullptr);</a>
<a name="ln811"> </a>
<a name="ln812">        for (unsigned int i = 2; i &lt; m_args.size(); ++i)</a>
<a name="ln813">        {</a>
<a name="ln814">            // Add enums for additional values.</a>
<a name="ln815">            m_page.add_synonym(m_args[1], m_args[i]);</a>
<a name="ln816">        }</a>
<a name="ln817">    }</a>
<a name="ln818"> </a>
<a name="ln819">    return true;</a>
<a name="ln820">}</a>
<a name="ln821"> </a>
<a name="ln822">void tile_list_processor::add_image(tile &amp;img, const char *enumname)</a>
<a name="ln823">{</a>
<a name="ln824">    tile *new_img = new tile(img, enumname, m_parts_ctg.c_str());</a>
<a name="ln825">    new_img-&gt;set_shrink(m_shrink);</a>
<a name="ln826"> </a>
<a name="ln827">    m_page.m_tiles.push_back(new_img);</a>
<a name="ln828">    m_page.m_counts.push_back(1);</a>
<a name="ln829"> </a>
<a name="ln830">    int weight = m_weight;</a>
<a name="ln831">    if (enumname)</a>
<a name="ln832">        m_last_enum = m_page.m_counts.size() - 1;</a>
<a name="ln833">    else if (m_last_enum &lt; m_page.m_counts.size() &amp;&amp; !m_page.m_probs.empty())</a>
<a name="ln834">    {</a>
<a name="ln835">        m_page.m_counts[m_last_enum]++;</a>
<a name="ln836">        weight += m_page.m_probs[m_page.m_probs.size() - 1];</a>
<a name="ln837">    }</a>
<a name="ln838"> </a>
<a name="ln839">    m_page.m_base_tiles.push_back(m_last_enum);</a>
<a name="ln840"> </a>
<a name="ln841">    m_page.m_probs.push_back(weight);</a>
<a name="ln842">    m_page.m_domino.push_back(m_domino);</a>
<a name="ln843"> </a>
<a name="ln844">    if (!m_categories.empty())</a>
<a name="ln845">        m_ctg_counts[m_categories.size()-1]++;</a>
<a name="ln846"> </a>
<a name="ln847">    if (m_variation_idx != -1)</a>
<a name="ln848">    {</a>
<a name="ln849">        m_page.add_variation(m_last_enum, m_variation_idx, m_variation_col);</a>
<a name="ln850">        m_variation_idx = -1;</a>
<a name="ln851">    }</a>
<a name="ln852">}</a>
<a name="ln853"> </a>
<a name="ln854">void tile_list_processor::add_abstracts(</a>
<a name="ln855">    FILE *fp,</a>
<a name="ln856">    const char *format,</a>
<a name="ln857">    const vector&lt;string&gt; &amp;lc_enum,</a>
<a name="ln858">    const vector&lt;string&gt; &amp;uc_max_enum,</a>
<a name="ln859">    bool is_js)</a>
<a name="ln860">{</a>
<a name="ln861">    assert(lc_enum.size() == uc_max_enum.size());</a>
<a name="ln862">    assert(!lc_enum.empty());</a>
<a name="ln863"> </a>
<a name="ln864">    size_t count = lc_enum.size();</a>
<a name="ln865">    if (count == 1)</a>
<a name="ln866">    {</a>
<a name="ln867">        fprintf(fp, &quot;%s&quot;, &quot;    &quot;);</a>
<a name="ln868">        fprintf(fp, format, lc_enum[0].c_str());</a>
<a name="ln869">        fprintf(fp, &quot;%s&quot;, &quot;\n&quot;);</a>
<a name="ln870">        return;</a>
<a name="ln871">    }</a>
<a name="ln872"> </a>
<a name="ln873">    for (size_t i = 0; i &lt; count; ++i)</a>
<a name="ln874">    {</a>
<a name="ln875">        if (i != count - 1)</a>
<a name="ln876">        {</a>
<a name="ln877">            fprintf(fp,</a>
<a name="ln878">                &quot;    %s (idx &lt; %s)\n&quot;</a>
<a name="ln879">                &quot;    {\n&quot;</a>
<a name="ln880">                &quot;        &quot;,</a>
<a name="ln881">                i != 0 ? &quot;else if&quot; : &quot;if&quot;, uc_max_enum[i].c_str());</a>
<a name="ln882">        }</a>
<a name="ln883">        else</a>
<a name="ln884">        {</a>
<a name="ln885">            fprintf(fp,</a>
<a name="ln886">                &quot;    else\n&quot;</a>
<a name="ln887">                &quot;    {\n&quot;</a>
<a name="ln888">                &quot;        %s(idx &lt; %s);\n&quot;</a>
<a name="ln889">                &quot;        &quot;,</a>
<a name="ln890">                is_js ? &quot;assert&quot; : &quot;ASSERT&quot;,</a>
<a name="ln891">                uc_max_enum[i].c_str());</a>
<a name="ln892">        }</a>
<a name="ln893">        fprintf(fp, format, lc_enum[i].c_str());</a>
<a name="ln894">        fprintf(fp, &quot;%s&quot;, &quot;\n    }\n&quot;);</a>
<a name="ln895">    }</a>
<a name="ln896">}</a>
<a name="ln897"> </a>
<a name="ln898">bool tile_list_processor::write_data(bool image, bool code)</a>
<a name="ln899">{</a>
<a name="ln900">    if (m_name == &quot;&quot;)</a>
<a name="ln901">    {</a>
<a name="ln902">        fprintf(stderr, &quot;%s&quot;, &quot;Error: can't write data with no %%name specified.\n&quot;);</a>
<a name="ln903">        return false;</a>
<a name="ln904">    }</a>
<a name="ln905"> </a>
<a name="ln906">    if (!m_page.m_tiles.empty() &amp;&amp; !m_abstract.empty())</a>
<a name="ln907">    {</a>
<a name="ln908">        fprintf(stderr, &quot;%s&quot;, &quot;Error: can't specify tiles when using %%abstract.\n&quot;);</a>
<a name="ln909">        return false;</a>
<a name="ln910">    }</a>
<a name="ln911"> </a>
<a name="ln912">    string lcname = m_name;</a>
<a name="ln913">    string ucname = m_name;</a>
<a name="ln914">    for (unsigned int i = 0; i &lt; m_name.size(); i++)</a>
<a name="ln915">    {</a>
<a name="ln916">        lcname[i] = toalower(m_name[i]);</a>
<a name="ln917">        ucname[i] = toaupper(m_name[i]);</a>
<a name="ln918">    }</a>
<a name="ln919">    string max = m_prefix;</a>
<a name="ln920">    max += &quot;_&quot;;</a>
<a name="ln921">    max += ucname;</a>
<a name="ln922">    max += &quot;_MAX&quot;;</a>
<a name="ln923"> </a>
<a name="ln924">    string ctg_max = m_prefix;</a>
<a name="ln925">    ctg_max += &quot;_PART_MAX&quot;;</a>
<a name="ln926"> </a>
<a name="ln927">    // Write image page.</a>
<a name="ln928">    {</a>
<a name="ln929">        if (!m_page.place_images())</a>
<a name="ln930">            return false;</a>
<a name="ln931"> </a>
<a name="ln932">        if (image)</a>
<a name="ln933">        {</a>
<a name="ln934">            char filename[1024];</a>
<a name="ln935">            sprintf(filename, &quot;%s.png&quot;, lcname.c_str());</a>
<a name="ln936">            if (m_abstract.empty())</a>
<a name="ln937">            {</a>
<a name="ln938">                if (!m_page.write_image(filename))</a>
<a name="ln939">                    return false;</a>
<a name="ln940">            }</a>
<a name="ln941">            else</a>
<a name="ln942">            {</a>
<a name="ln943">                // Write an empty file.</a>
<a name="ln944">                char filename[1024];</a>
<a name="ln945">                sprintf(filename, &quot;%s.png&quot;, lcname.c_str());</a>
<a name="ln946">                FILE *fp = fopen(filename, &quot;w&quot;);</a>
<a name="ln947">                if (!fp)</a>
<a name="ln948">                {</a>
<a name="ln949">                    fprintf(stderr, &quot;Error: couldn't open '%s' for write.\n&quot;,</a>
<a name="ln950">                            filename);</a>
<a name="ln951">                    return false;</a>
<a name="ln952">                }</a>
<a name="ln953">                fclose(fp);</a>
<a name="ln954">            }</a>
<a name="ln955">        }</a>
<a name="ln956">    }</a>
<a name="ln957"> </a>
<a name="ln958">    if (!code)</a>
<a name="ln959">        return true;</a>
<a name="ln960"> </a>
<a name="ln961">    int *part_min = nullptr;</a>
<a name="ln962"> </a>
<a name="ln963">    // Write &quot;tiledef-%name.h&quot;</a>
<a name="ln964">    {</a>
<a name="ln965">        char filename[1024];</a>
<a name="ln966">        sprintf(filename, &quot;tiledef-%s.h&quot;, lcname.c_str());</a>
<a name="ln967">        FILE *fp = fopen(filename, &quot;w&quot;);</a>
<a name="ln968"> </a>
<a name="ln969">        if (!fp)</a>
<a name="ln970">        {</a>
<a name="ln971">            fprintf(stderr, &quot;Error: couldn't open '%s' for write.\n&quot;, filename);</a>
<a name="ln972">            return false;</a>
<a name="ln973">        }</a>
<a name="ln974"> </a>
<a name="ln975">        if (!m_categories.empty())</a>
<a name="ln976">        {</a>
<a name="ln977">            part_min = new int[m_categories.size()];</a>
<a name="ln978">            memset(part_min, 0, sizeof(int) * m_categories.size());</a>
<a name="ln979">        }</a>
<a name="ln980"> </a>
<a name="ln981">        fprintf(fp, &quot;// This file has been automatically generated.\n\n&quot;);</a>
<a name="ln982">        fprintf(fp, &quot;#pragma once\n\n&quot;);</a>
<a name="ln983">        fprintf(fp, &quot;#include \&quot;tiledef_defines.h\&quot;\n\n&quot;);</a>
<a name="ln984"> </a>
<a name="ln985">        for (const auto&amp; include : m_include)</a>
<a name="ln986">            fprintf(fp, &quot;#include \&quot;%s\&quot;\n&quot;, include.c_str());</a>
<a name="ln987"> </a>
<a name="ln988">        fprintf(fp, &quot;%s&quot;, &quot;\n\n&quot;);</a>
<a name="ln989"> </a>
<a name="ln990">        fprintf(fp, &quot;enum tile_%s_type\n{\n&quot;, lcname.c_str());</a>
<a name="ln991"> </a>
<a name="ln992">        string start_val = &quot; = &quot;;</a>
<a name="ln993">        start_val += m_start_value;</a>
<a name="ln994"> </a>
<a name="ln995">        string old_enum_name = &quot;&quot;;</a>
<a name="ln996">        int count = 0;</a>
<a name="ln997">        for (unsigned int i = 0; i &lt; m_page.m_tiles.size(); i++)</a>
<a name="ln998">        {</a>
<a name="ln999">            const string &amp;parts_ctg = m_page.m_tiles[i]-&gt;parts_ctg();</a>
<a name="ln1000">            const int enumcount = m_page.m_tiles[i]-&gt;enumcount();</a>
<a name="ln1001"> </a>
<a name="ln1002">            if (enumcount == 0)</a>
<a name="ln1003">            {</a>
<a name="ln1004">                if (old_enum_name.empty())</a>
<a name="ln1005">                {</a>
<a name="ln1006">                    fprintf(fp, &quot;    %s_%s_FILLER_%d%s,\n&quot;, m_prefix.c_str(),</a>
<a name="ln1007">                            ucname.c_str(), i, start_val.c_str());</a>
<a name="ln1008">                }</a>
<a name="ln1009">                else</a>
<a name="ln1010">                {</a>
<a name="ln1011">                    fprintf(fp, &quot;    %s_%s_%d%s,\n&quot;, m_prefix.c_str(),</a>
<a name="ln1012">                            old_enum_name.c_str(), ++count, start_val.c_str());</a>
<a name="ln1013">                }</a>
<a name="ln1014">            }</a>
<a name="ln1015">            else if (parts_ctg.empty())</a>
<a name="ln1016">            {</a>
<a name="ln1017">                const string &amp;enumname = m_page.m_tiles[i]-&gt;enumname(0);</a>
<a name="ln1018">                fprintf(fp, &quot;    %s_%s%s,\n&quot;, m_prefix.c_str(),</a>
<a name="ln1019">                        enumname.c_str(), start_val.c_str());</a>
<a name="ln1020">                old_enum_name = enumname;</a>
<a name="ln1021">                count = 0;</a>
<a name="ln1022">            }</a>
<a name="ln1023">            else</a>
<a name="ln1024">            {</a>
<a name="ln1025">                const string &amp;enumname = m_page.m_tiles[i]-&gt;enumname(0);</a>
<a name="ln1026">                fprintf(fp, &quot;    %s_%s_%s%s,\n&quot;, m_prefix.c_str(),</a>
<a name="ln1027">                        parts_ctg.c_str(), enumname.c_str(), start_val.c_str());</a>
<a name="ln1028">                old_enum_name = enumname;</a>
<a name="ln1029">                count = 0;</a>
<a name="ln1030">            }</a>
<a name="ln1031"> </a>
<a name="ln1032">            for (int c = 1; c &lt; enumcount; ++c)</a>
<a name="ln1033">            {</a>
<a name="ln1034">                const string &amp;basename = m_page.m_tiles[i]-&gt;enumname(0);</a>
<a name="ln1035">                const string &amp;enumname = m_page.m_tiles[i]-&gt;enumname(c);</a>
<a name="ln1036"> </a>
<a name="ln1037">                if (parts_ctg.empty())</a>
<a name="ln1038">                {</a>
<a name="ln1039">                    fprintf(fp, &quot;    %s_%s = %s_%s,\n&quot;,</a>
<a name="ln1040">                        m_prefix.c_str(), enumname.c_str(),</a>
<a name="ln1041">                        m_prefix.c_str(), basename.c_str());</a>
<a name="ln1042">                }</a>
<a name="ln1043">                else</a>
<a name="ln1044">                {</a>
<a name="ln1045">                    fprintf(fp, &quot;    %s_%s_%s = %s_%s_%s,\n&quot;,</a>
<a name="ln1046">                        m_prefix.c_str(), parts_ctg.c_str(), enumname.c_str(),</a>
<a name="ln1047">                        m_prefix.c_str(), parts_ctg.c_str(), basename.c_str());</a>
<a name="ln1048">                }</a>
<a name="ln1049">            }</a>
<a name="ln1050"> </a>
<a name="ln1051">            start_val = &quot;&quot;;</a>
<a name="ln1052"> </a>
<a name="ln1053">            if (!parts_ctg.empty())</a>
<a name="ln1054">            {</a>
<a name="ln1055">                unsigned int idx;</a>
<a name="ln1056">                for (idx = 0; idx &lt; m_categories.size(); idx++)</a>
<a name="ln1057">                    if (parts_ctg == m_categories[idx])</a>
<a name="ln1058">                        break;</a>
<a name="ln1059"> </a>
<a name="ln1060">                assert(idx &lt; m_categories.size());</a>
<a name="ln1061">                if (part_min[idx] == 0)</a>
<a name="ln1062">                    part_min[idx] = i;</a>
<a name="ln1063">            }</a>
<a name="ln1064">        }</a>
<a name="ln1065"> </a>
<a name="ln1066">        if (m_abstract.empty())</a>
<a name="ln1067">            fprintf(fp, &quot;    %s_%s_MAX\n};\n\n&quot;, m_prefix.c_str(), ucname.c_str());</a>
<a name="ln1068">        else</a>
<a name="ln1069">        {</a>
<a name="ln1070">            size_t last_idx = m_abstract.size() - 1;</a>
<a name="ln1071">            string max_enum = m_abstract[last_idx].second;</a>
<a name="ln1072">            max_enum += &quot;_&quot;;</a>
<a name="ln1073">            max_enum += m_abstract[last_idx].first;</a>
<a name="ln1074">            max_enum += &quot;_MAX&quot;;</a>
<a name="ln1075"> </a>
<a name="ln1076">            for (char&amp; c : max_enum)</a>
<a name="ln1077">                c = toaupper(c);</a>
<a name="ln1078"> </a>
<a name="ln1079">            fprintf(fp, &quot;    %s_%s_MAX = %s\n};\n\n&quot;, m_prefix.c_str(), ucname.c_str(), max_enum.c_str());</a>
<a name="ln1080">        }</a>
<a name="ln1081"> </a>
<a name="ln1082">        fprintf(fp, &quot;unsigned int tile_%s_count(tileidx_t idx);\n&quot;, lcname.c_str());</a>
<a name="ln1083">        fprintf(fp, &quot;tileidx_t tile_%s_basetile(tileidx_t idx);\n&quot;, lcname.c_str());</a>
<a name="ln1084">        fprintf(fp, &quot;int tile_%s_probs(tileidx_t idx);\n&quot;,</a>
<a name="ln1085">                lcname.c_str());</a>
<a name="ln1086">        fprintf(fp, &quot;int tile_%s_dominoes(tileidx_t idx);\n&quot;,</a>
<a name="ln1087">                lcname.c_str());</a>
<a name="ln1088">        fprintf(fp, &quot;const char *tile_%s_name(tileidx_t idx);\n&quot;,</a>
<a name="ln1089">            lcname.c_str());</a>
<a name="ln1090">        fprintf(fp, &quot;tile_info &amp;tile_%s_info(tileidx_t idx);\n&quot;,</a>
<a name="ln1091">            lcname.c_str());</a>
<a name="ln1092">        fprintf(fp, &quot;bool tile_%s_index(const char *str, tileidx_t *idx);\n&quot;,</a>
<a name="ln1093">            lcname.c_str());</a>
<a name="ln1094">        fprintf(fp, &quot;bool tile_%s_equal(tileidx_t tile, tileidx_t idx);\n&quot;,</a>
<a name="ln1095">            lcname.c_str());</a>
<a name="ln1096">        fprintf(fp, &quot;tileidx_t tile_%s_coloured(tileidx_t idx, int col);\n&quot;,</a>
<a name="ln1097">            lcname.c_str());</a>
<a name="ln1098"> </a>
<a name="ln1099">        if (!m_categories.empty())</a>
<a name="ln1100">        {</a>
<a name="ln1101">            fprintf(fp, &quot;\nenum tile_%s_parts\n{\n&quot;, lcname.c_str());</a>
<a name="ln1102">            for (unsigned int i = 0; i &lt; m_categories.size(); i++)</a>
<a name="ln1103">            {</a>
<a name="ln1104">                fprintf(fp, &quot;    %s_PART_%s,\n&quot;, m_prefix.c_str(),</a>
<a name="ln1105">                        m_categories[i].c_str());</a>
<a name="ln1106">            }</a>
<a name="ln1107"> </a>
<a name="ln1108">            fprintf(fp, &quot;    %s\n};\n\n&quot;, ctg_max.c_str());</a>
<a name="ln1109"> </a>
<a name="ln1110">            fprintf(fp, &quot;extern unsigned int tile_%s_part_count[%s];\n&quot;,</a>
<a name="ln1111">                    lcname.c_str(), ctg_max.c_str());</a>
<a name="ln1112">            fprintf(fp, &quot;extern tileidx_t tile_%s_part_start[%s];\n&quot;,</a>
<a name="ln1113">                    lcname.c_str(), ctg_max.c_str());</a>
<a name="ln1114">        }</a>
<a name="ln1115"> </a>
<a name="ln1116">        fclose(fp);</a>
<a name="ln1117">    }</a>
<a name="ln1118"> </a>
<a name="ln1119">    // write &quot;tiledef-%name.cc&quot;</a>
<a name="ln1120">    if (m_abstract.empty())</a>
<a name="ln1121">    {</a>
<a name="ln1122">        char filename[1024];</a>
<a name="ln1123">        sprintf(filename, &quot;tiledef-%s.cc&quot;, lcname.c_str());</a>
<a name="ln1124">        FILE *fp = fopen(filename, &quot;w&quot;);</a>
<a name="ln1125"> </a>
<a name="ln1126">        if (!fp)</a>
<a name="ln1127">        {</a>
<a name="ln1128">            fprintf(stderr, &quot;Error: couldn't open '%s' for write.\n&quot;, filename);</a>
<a name="ln1129">            return false;</a>
<a name="ln1130">        }</a>
<a name="ln1131"> </a>
<a name="ln1132">        fprintf(fp, &quot;// This file has been automatically generated.\n\n&quot;);</a>
<a name="ln1133">        fprintf(fp, &quot;#include \&quot;AppHdr.h\&quot;\n&quot;);</a>
<a name="ln1134">        fprintf(fp, &quot;#include \&quot;libutil.h\&quot;\n&quot;);</a>
<a name="ln1135">        fprintf(fp, &quot;#include \&quot;tiledef-%s.h\&quot;\n\n&quot;, lcname.c_str());</a>
<a name="ln1136"> </a>
<a name="ln1137">        fprintf(fp, &quot;static unsigned int _tile_%s_count[%s - %s] =\n{\n&quot;,</a>
<a name="ln1138">                lcname.c_str(), max.c_str(), m_start_value.c_str());</a>
<a name="ln1139">        for (unsigned int i = 0; i &lt; m_page.m_counts.size(); i++)</a>
<a name="ln1140">            fprintf(fp, &quot;    %u,\n&quot;, m_page.m_counts[i]);</a>
<a name="ln1141">        fprintf(fp, &quot;};\n\n&quot;);</a>
<a name="ln1142"> </a>
<a name="ln1143">        fprintf(fp, &quot;unsigned int tile_%s_count(tileidx_t idx)\n{\n&quot;, lcname.c_str());</a>
<a name="ln1144">        fprintf(fp, &quot;    ASSERT_RANGE(idx, %s, %s);\n&quot;,</a>
<a name="ln1145">                m_start_value.c_str(), max.c_str());</a>
<a name="ln1146">        fprintf(fp, &quot;    return _tile_%s_count[idx - %s];\n&quot;,</a>
<a name="ln1147">                lcname.c_str(), m_start_value.c_str());</a>
<a name="ln1148">        fprintf(fp, &quot;}\n\n&quot;);</a>
<a name="ln1149"> </a>
<a name="ln1150">        fprintf(fp, &quot;static tileidx_t _tile_%s_basetiles[%s - %s] =\n{\n&quot;,</a>
<a name="ln1151">                lcname.c_str(), max.c_str(), m_start_value.c_str());</a>
<a name="ln1152">        for (unsigned int i = 0; i &lt; m_page.m_base_tiles.size(); i++)</a>
<a name="ln1153">            fprintf(fp, &quot;    %u,\n&quot;, m_page.m_base_tiles[i]);</a>
<a name="ln1154">        fprintf(fp, &quot;};\n\n&quot;);</a>
<a name="ln1155"> </a>
<a name="ln1156">        fprintf(fp, &quot;tileidx_t tile_%s_basetile(tileidx_t idx)\n{\n&quot;, lcname.c_str());</a>
<a name="ln1157">        fprintf(fp, &quot;    ASSERT_RANGE(idx, %s, %s);\n&quot;,</a>
<a name="ln1158">                m_start_value.c_str(), max.c_str());</a>
<a name="ln1159">        fprintf(fp, &quot;    return _tile_%s_basetiles[idx - %s] + %s;\n&quot;,</a>
<a name="ln1160">                lcname.c_str(), m_start_value.c_str(), m_start_value.c_str());</a>
<a name="ln1161">        fprintf(fp, &quot;}\n\n&quot;);</a>
<a name="ln1162"> </a>
<a name="ln1163">        fprintf(fp, &quot;static int _tile_%s_probs[%s - %s] =\n{\n&quot;,</a>
<a name="ln1164">                lcname.c_str(), max.c_str(), m_start_value.c_str());</a>
<a name="ln1165">        for (unsigned int i = 0; i &lt; m_page.m_probs.size(); i++)</a>
<a name="ln1166">            fprintf(fp, &quot;    %d,\n&quot;, m_page.m_probs[i]);</a>
<a name="ln1167">        fprintf(fp, &quot;};\n\n&quot;);</a>
<a name="ln1168"> </a>
<a name="ln1169">        fprintf(fp, &quot;int tile_%s_probs(tileidx_t idx)\n{\n&quot;,</a>
<a name="ln1170">                    lcname.c_str());</a>
<a name="ln1171">        fprintf(fp, &quot;    ASSERT_RANGE(idx, %s, %s);\n&quot;,</a>
<a name="ln1172">                m_start_value.c_str(), max.c_str());</a>
<a name="ln1173">        fprintf(fp, &quot;    return _tile_%s_probs[idx - %s];\n&quot;,</a>
<a name="ln1174">                lcname.c_str(), m_start_value.c_str());</a>
<a name="ln1175">        fprintf(fp, &quot;}\n\n&quot;);</a>
<a name="ln1176"> </a>
<a name="ln1177">        fprintf(fp, &quot;static int _tile_%s_dominoes[%s - %s] =\n{\n&quot;,</a>
<a name="ln1178">                lcname.c_str(), max.c_str(), m_start_value.c_str());</a>
<a name="ln1179">        for (unsigned int i = 0; i &lt; m_page.m_domino.size(); i++)</a>
<a name="ln1180">            fprintf(fp, &quot;    %d,\n&quot;, m_page.m_domino[i]);</a>
<a name="ln1181">        fprintf(fp, &quot;};\n\n&quot;);</a>
<a name="ln1182"> </a>
<a name="ln1183">        fprintf(fp, &quot;int tile_%s_dominoes(tileidx_t idx)\n{\n&quot;,</a>
<a name="ln1184">                    lcname.c_str());</a>
<a name="ln1185">        fprintf(fp, &quot;    ASSERT_RANGE(idx, %s, %s);\n&quot;,</a>
<a name="ln1186">                m_start_value.c_str(), max.c_str());</a>
<a name="ln1187">        fprintf(fp, &quot;    return _tile_%s_dominoes[idx - %s];\n&quot;,</a>
<a name="ln1188">                lcname.c_str(), m_start_value.c_str());</a>
<a name="ln1189">        fprintf(fp, &quot;}\n\n&quot;);</a>
<a name="ln1190"> </a>
<a name="ln1191">        fprintf(fp, &quot;static const char *_tile_%s_name[%s - %s] =\n{\n&quot;,</a>
<a name="ln1192">                lcname.c_str(), max.c_str(), m_start_value.c_str());</a>
<a name="ln1193"> </a>
<a name="ln1194">        string old_enum_name = &quot;&quot;;</a>
<a name="ln1195">        int count = 0;</a>
<a name="ln1196">        for (unsigned int i = 0; i &lt; m_page.m_tiles.size(); i++)</a>
<a name="ln1197">        {</a>
<a name="ln1198">            if (m_page.m_tiles[i]-&gt;enumcount() == 0)</a>
<a name="ln1199">            {</a>
<a name="ln1200">                if (old_enum_name.empty())</a>
<a name="ln1201">                    fprintf(fp, &quot;    \&quot;%s_FILLER_%d\&quot;,\n&quot;, ucname.c_str(), i);</a>
<a name="ln1202">                else</a>
<a name="ln1203">                {</a>
<a name="ln1204">                    fprintf(fp, &quot;    \&quot;%s_%d\&quot;,\n&quot;, old_enum_name.c_str(),</a>
<a name="ln1205">                            ++count);</a>
<a name="ln1206">                }</a>
<a name="ln1207">            }</a>
<a name="ln1208">            else</a>
<a name="ln1209">            {</a>
<a name="ln1210">                const string &amp;enumname = m_page.m_tiles[i]-&gt;enumname(0);</a>
<a name="ln1211">                fprintf(fp, &quot;    \&quot;%s\&quot;,\n&quot;, enumname.c_str());</a>
<a name="ln1212">                old_enum_name = enumname;</a>
<a name="ln1213">                count = 0;</a>
<a name="ln1214">            }</a>
<a name="ln1215">        }</a>
<a name="ln1216">        fprintf(fp, &quot;};\n\n&quot;);</a>
<a name="ln1217"> </a>
<a name="ln1218">        fprintf(fp, &quot;const char *tile_%s_name(tileidx_t idx)\n{\n&quot;,</a>
<a name="ln1219">                lcname.c_str());</a>
<a name="ln1220">        fprintf(fp, &quot;    ASSERT_RANGE(idx, %s, %s);\n&quot;,</a>
<a name="ln1221">                m_start_value.c_str(), max.c_str());</a>
<a name="ln1222">        fprintf(fp, &quot;    return _tile_%s_name[idx - %s];\n&quot;,</a>
<a name="ln1223">                lcname.c_str(), m_start_value.c_str());</a>
<a name="ln1224">        fprintf(fp, &quot;}\n\n&quot;);</a>
<a name="ln1225"> </a>
<a name="ln1226">        fprintf(fp, &quot;static tile_info _tile_%s_info[%s - %s] =\n{\n&quot;,</a>
<a name="ln1227">                lcname.c_str(), max.c_str(), m_start_value.c_str());</a>
<a name="ln1228">        for (unsigned int i = 0; i &lt; m_page.m_offsets.size(); i+=4)</a>
<a name="ln1229">        {</a>
<a name="ln1230">            fprintf(fp, &quot;    tile_info(%d, %d, %d, %d, %d, %d, %d, %d),\n&quot;,</a>
<a name="ln1231">                    m_page.m_offsets[i+2], m_page.m_offsets[i+3],</a>
<a name="ln1232">                    m_page.m_offsets[i], m_page.m_offsets[i+1],</a>
<a name="ln1233">                    m_page.m_texcoords[i], m_page.m_texcoords[i+1],</a>
<a name="ln1234">                    m_page.m_texcoords[i+2], m_page.m_texcoords[i+3]);</a>
<a name="ln1235">        }</a>
<a name="ln1236">        fprintf(fp, &quot;};\n\n&quot;);</a>
<a name="ln1237"> </a>
<a name="ln1238">        fprintf(fp, &quot;tile_info &amp;tile_%s_info(tileidx_t idx)\n{\n&quot;,</a>
<a name="ln1239">                lcname.c_str());</a>
<a name="ln1240">        fprintf(fp, &quot;    ASSERT_RANGE(idx, %s, %s);\n&quot;,</a>
<a name="ln1241">                m_start_value.c_str(), max.c_str());</a>
<a name="ln1242">        fprintf(fp, &quot;    return _tile_%s_info[idx - %s];\n&quot;,</a>
<a name="ln1243">                lcname.c_str(), m_start_value.c_str());</a>
<a name="ln1244">        fprintf(fp, &quot;}\n\n&quot;);</a>
<a name="ln1245"> </a>
<a name="ln1246">        if (!m_categories.empty())</a>
<a name="ln1247">        {</a>
<a name="ln1248">            fprintf(fp, &quot;unsigned int tile_%s_part_count[%s] =\n{\n&quot;,</a>
<a name="ln1249">                    lcname.c_str(), ctg_max.c_str());</a>
<a name="ln1250"> </a>
<a name="ln1251">            for (unsigned int i = 0; i &lt; m_ctg_counts.size(); i++)</a>
<a name="ln1252">                fprintf(fp, &quot;    %d,\n&quot;, m_ctg_counts[i]);</a>
<a name="ln1253"> </a>
<a name="ln1254">            fprintf(fp, &quot;};\n\n&quot;);</a>
<a name="ln1255"> </a>
<a name="ln1256">            fprintf(fp, &quot;tileidx_t tile_%s_part_start[%s] =\n{\n&quot;,</a>
<a name="ln1257">                    lcname.c_str(), ctg_max.c_str());</a>
<a name="ln1258"> </a>
<a name="ln1259">            for (unsigned int i = 0; i &lt; m_categories.size(); i++)</a>
<a name="ln1260">                fprintf(fp, &quot;    %u+%s,\n&quot;, part_min[i], m_start_value.c_str());</a>
<a name="ln1261"> </a>
<a name="ln1262">            fprintf(fp, &quot;};\n\n&quot;);</a>
<a name="ln1263">        }</a>
<a name="ln1264"> </a>
<a name="ln1265">        fprintf(fp, &quot;\ntypedef pair&lt;const char*, tileidx_t&gt; _name_pair;\n\n&quot;);</a>
<a name="ln1266"> </a>
<a name="ln1267">        fprintf(fp, &quot;static _name_pair %s_name_pairs[] =\n&quot;</a>
<a name="ln1268">                    &quot;{\n&quot;, lcname.c_str());</a>
<a name="ln1269"> </a>
<a name="ln1270">        typedef map&lt;string, int&gt; sort_map;</a>
<a name="ln1271">        sort_map table;</a>
<a name="ln1272"> </a>
<a name="ln1273">        for (unsigned int i = 0; i &lt; m_page.m_tiles.size(); i++)</a>
<a name="ln1274">        {</a>
<a name="ln1275">            for (int c = 0; c &lt; m_page.m_tiles[i]-&gt;enumcount(); ++c)</a>
<a name="ln1276">            {</a>
<a name="ln1277">                const string &amp;enumname = m_page.m_tiles[i]-&gt;enumname(c);</a>
<a name="ln1278"> </a>
<a name="ln1279">                string lcenum = enumname;</a>
<a name="ln1280">                for (unsigned int c = 0; c &lt; enumname.size(); c++)</a>
<a name="ln1281">                    lcenum[c] = toalower(enumname[c]);</a>
<a name="ln1282"> </a>
<a name="ln1283">                table.insert(sort_map::value_type(lcenum, i));</a>
<a name="ln1284">            }</a>
<a name="ln1285">        }</a>
<a name="ln1286"> </a>
<a name="ln1287">        sort_map::iterator itor;</a>
<a name="ln1288">        for (itor = table.begin(); itor != table.end(); itor++)</a>
<a name="ln1289">        {</a>
<a name="ln1290">            fprintf(fp, &quot;    _name_pair(\&quot;%s\&quot;, %d + %s),\n&quot;,</a>
<a name="ln1291">                    itor-&gt;first.c_str(), itor-&gt;second, m_start_value.c_str());</a>
<a name="ln1292">        }</a>
<a name="ln1293"> </a>
<a name="ln1294">        fprintf(fp, &quot;};\n\n&quot;);</a>
<a name="ln1295"> </a>
<a name="ln1296">        fprintf(fp,</a>
<a name="ln1297">            &quot;bool tile_%s_index(const char *str, tileidx_t *idx)\n&quot;</a>
<a name="ln1298">            &quot;{\n&quot;</a>
<a name="ln1299">            &quot;    ASSERT(str);\n&quot;</a>
<a name="ln1300">            &quot;    if (!str)\n&quot;</a>
<a name="ln1301">            &quot;        return false;\n&quot;</a>
<a name="ln1302">            &quot;\n&quot;</a>
<a name="ln1303">            &quot;    string lc = str;\n&quot;</a>
<a name="ln1304">            &quot;    for (unsigned int i = 0; i &lt; lc.size(); i++)\n&quot;</a>
<a name="ln1305">            &quot;        lc[i] = toalower(lc[i]);\n&quot;</a>
<a name="ln1306">            &quot;\n&quot;</a>
<a name="ln1307">            &quot;    int num_pairs = sizeof(%s_name_pairs) / sizeof(%s_name_pairs[0]);\n&quot;</a>
<a name="ln1308">            &quot;    bool result = binary_search&lt;const char *, tileidx_t&gt;(\n&quot;</a>
<a name="ln1309">            &quot;       lc.c_str(), &amp;%s_name_pairs[0], num_pairs, &amp;strcmp, idx);\n&quot;</a>
<a name="ln1310">            &quot;    return result;\n&quot;</a>
<a name="ln1311">            &quot;}\n\n&quot;,</a>
<a name="ln1312">            lcname.c_str(), lcname.c_str(), lcname.c_str(), lcname.c_str());</a>
<a name="ln1313"> </a>
<a name="ln1314">        fprintf(fp,</a>
<a name="ln1315">            &quot;bool tile_%s_equal(tileidx_t tile, tileidx_t idx)\n&quot;</a>
<a name="ln1316">            &quot;{\n&quot;</a>
<a name="ln1317">            &quot;    ASSERT_RANGE(tile, %s, %s);\n&quot;</a>
<a name="ln1318">            &quot;    return idx &gt;= tile &amp;&amp; idx &lt; tile + tile_%s_count(tile);\n&quot;</a>
<a name="ln1319">            &quot;}\n\n&quot;,</a>
<a name="ln1320">            lcname.c_str(), m_start_value.c_str(), max.c_str(), lcname.c_str());</a>
<a name="ln1321"> </a>
<a name="ln1322">        fprintf(fp, &quot;\ntypedef pair&lt;tile_variation, tileidx_t&gt; _colour_pair;\n\n&quot;);</a>
<a name="ln1323"> </a>
<a name="ln1324">        fprintf(fp,</a>
<a name="ln1325">            &quot;static _colour_pair %s_colour_pairs[] =\n&quot;</a>
<a name="ln1326">            &quot;{\n&quot;</a>
<a name="ln1327">            &quot;    _colour_pair(tile_variation(0, 0), 0),\n&quot;,</a>
<a name="ln1328">            lcname.c_str());</a>
<a name="ln1329"> </a>
<a name="ln1330">        for (unsigned int i = 0; i &lt; m_page.m_tiles.size(); i++)</a>
<a name="ln1331">        {</a>
<a name="ln1332">            for (int c = 0; c &lt; MAX_COLOUR; ++c)</a>
<a name="ln1333">            {</a>
<a name="ln1334">                int var;</a>
<a name="ln1335">                if (!m_page.m_tiles[i]-&gt;get_variation(c, var))</a>
<a name="ln1336">                    continue;</a>
<a name="ln1337"> </a>
<a name="ln1338">                fprintf(fp,</a>
<a name="ln1339">                    &quot;    _colour_pair(tile_variation(%d + %s, %d), %d + %s),\n&quot;,</a>
<a name="ln1340">                    i, m_start_value.c_str(), c, var, m_start_value.c_str());</a>
<a name="ln1341">            }</a>
<a name="ln1342">        }</a>
<a name="ln1343"> </a>
<a name="ln1344">        fprintf(fp, &quot;%s&quot;, &quot;};\n\n&quot;);</a>
<a name="ln1345"> </a>
<a name="ln1346">        fprintf(fp,</a>
<a name="ln1347">            &quot;tileidx_t tile_%s_coloured(tileidx_t idx, int col)\n&quot;</a>
<a name="ln1348">            &quot;{\n&quot;</a>
<a name="ln1349">            &quot;    int num_pairs = sizeof(%s_colour_pairs) / sizeof(%s_colour_pairs[0]);\n&quot;</a>
<a name="ln1350">            &quot;    tile_variation key(idx, col);\n&quot;</a>
<a name="ln1351">            &quot;    tileidx_t found;\n&quot;</a>
<a name="ln1352">            &quot;    bool result = binary_search&lt;tile_variation, tileidx_t&gt;(\n&quot;</a>
<a name="ln1353">            &quot;       key, &amp;%s_colour_pairs[0], num_pairs,\n&quot;</a>
<a name="ln1354">            &quot;       &amp;tile_variation::cmp, &amp;found);\n&quot;</a>
<a name="ln1355">            &quot;    return (result ? found : idx);\n&quot;</a>
<a name="ln1356">            &quot;}\n\n&quot;,</a>
<a name="ln1357">            lcname.c_str(), lcname.c_str(), lcname.c_str(), lcname.c_str());</a>
<a name="ln1358"> </a>
<a name="ln1359">        fclose(fp);</a>
<a name="ln1360">    }</a>
<a name="ln1361">    else</a>
<a name="ln1362">    {</a>
<a name="ln1363">        if (m_abstract.size() == 1)</a>
<a name="ln1364">        {</a>
<a name="ln1365">            fprintf(stderr, &quot;Error: &lt;2 abstracts currently unsupported.\n&quot;);</a>
<a name="ln1366">            return false;</a>
<a name="ln1367">        }</a>
<a name="ln1368"> </a>
<a name="ln1369">        char filename[1024];</a>
<a name="ln1370">        sprintf(filename, &quot;tiledef-%s.cc&quot;, lcname.c_str());</a>
<a name="ln1371">        FILE *fp = fopen(filename, &quot;w&quot;);</a>
<a name="ln1372"> </a>
<a name="ln1373">        if (!fp)</a>
<a name="ln1374">        {</a>
<a name="ln1375">            fprintf(stderr, &quot;Error: couldn't open '%s' for write.\n&quot;, filename);</a>
<a name="ln1376">            return false;</a>
<a name="ln1377">        }</a>
<a name="ln1378"> </a>
<a name="ln1379">        fprintf(fp, &quot;// This file has been automatically generated.\n\n&quot;);</a>
<a name="ln1380">        fprintf(fp, &quot;#include \&quot;AppHdr.h\&quot;\n&quot;);</a>
<a name="ln1381">        fprintf(fp, &quot;#include \&quot;tiledef-%s.h\&quot;\n&quot;, lcname.c_str());</a>
<a name="ln1382">        fprintf(fp, &quot;\n&quot;);</a>
<a name="ln1383"> </a>
<a name="ln1384">        vector&lt;string&gt; uc_max_enum;</a>
<a name="ln1385">        vector&lt;string&gt; lc_enum;</a>
<a name="ln1386">        for (const auto&amp; abstract : m_abstract)</a>
<a name="ln1387">        {</a>
<a name="ln1388">            string max_enum = abstract.second;</a>
<a name="ln1389">            max_enum += &quot;_&quot;;</a>
<a name="ln1390">            max_enum += abstract.first;</a>
<a name="ln1391">            max_enum += &quot;_MAX&quot;;</a>
<a name="ln1392"> </a>
<a name="ln1393">            for (char&amp; c : max_enum)</a>
<a name="ln1394">                c = toaupper(c);</a>
<a name="ln1395"> </a>
<a name="ln1396">            uc_max_enum.push_back(max_enum);</a>
<a name="ln1397"> </a>
<a name="ln1398">            lc_enum.push_back(abstract.first);</a>
<a name="ln1399">        }</a>
<a name="ln1400"> </a>
<a name="ln1401">        fprintf(fp, &quot;unsigned int tile_%s_count(tileidx_t idx)\n{\n&quot;, lcname.c_str());</a>
<a name="ln1402">        add_abstracts(fp, &quot;return (tile_%s_count(idx));&quot;, lc_enum, uc_max_enum);</a>
<a name="ln1403">        fprintf(fp, &quot;}\n\n&quot;);</a>
<a name="ln1404"> </a>
<a name="ln1405">        fprintf(fp, &quot;tileidx_t tile_%s_basetile(tileidx_t idx)\n{\n&quot;, lcname.c_str());</a>
<a name="ln1406">        add_abstracts(fp, &quot;return (tile_%s_basetile(idx));&quot;, lc_enum, uc_max_enum);</a>
<a name="ln1407">        fprintf(fp, &quot;}\n\n&quot;);</a>
<a name="ln1408"> </a>
<a name="ln1409">        fprintf(fp, &quot;int tile_%s_probs(tileidx_t idx)\n{\n&quot;,</a>
<a name="ln1410">                    lcname.c_str());</a>
<a name="ln1411">        add_abstracts(fp, &quot;return (tile_%s_probs(idx));&quot;, lc_enum, uc_max_enum);</a>
<a name="ln1412">        fprintf(fp, &quot;}\n\n&quot;);</a>
<a name="ln1413"> </a>
<a name="ln1414">        fprintf(fp, &quot;int tile_%s_dominoes(tileidx_t idx)\n{\n&quot;,</a>
<a name="ln1415">                    lcname.c_str());</a>
<a name="ln1416">        add_abstracts(fp, &quot;return (tile_%s_dominoes(idx));&quot;, lc_enum, uc_max_enum);</a>
<a name="ln1417">        fprintf(fp, &quot;}\n\n&quot;);</a>
<a name="ln1418"> </a>
<a name="ln1419">        fprintf(fp, &quot;const char *tile_%s_name(tileidx_t idx)\n{\n&quot;,</a>
<a name="ln1420">                lcname.c_str());</a>
<a name="ln1421">        add_abstracts(fp, &quot;return (tile_%s_name(idx));&quot;, lc_enum, uc_max_enum);</a>
<a name="ln1422">        fprintf(fp, &quot;}\n\n&quot;);</a>
<a name="ln1423"> </a>
<a name="ln1424">        fprintf(fp, &quot;tile_info &amp;tile_%s_info(tileidx_t idx)\n{\n&quot;,</a>
<a name="ln1425">            lcname.c_str());</a>
<a name="ln1426">        add_abstracts(fp, &quot;return (tile_%s_info(idx));&quot;, lc_enum, uc_max_enum);</a>
<a name="ln1427">        fprintf(fp, &quot;}\n\n&quot;);</a>
<a name="ln1428"> </a>
<a name="ln1429">        fprintf(fp, &quot;bool tile_%s_index(const char *str, tileidx_t *idx)\n{\n&quot;,</a>
<a name="ln1430">                lcname.c_str());</a>
<a name="ln1431">        for (const auto&amp; str : lc_enum)</a>
<a name="ln1432">        {</a>
<a name="ln1433">            fprintf(fp,</a>
<a name="ln1434">                &quot;    if (tile_%s_index(str, idx))\n&quot;</a>
<a name="ln1435">                &quot;        return true;\n&quot;,</a>
<a name="ln1436">                str.c_str());</a>
<a name="ln1437">        }</a>
<a name="ln1438">        fprintf(fp, &quot;%s&quot;,</a>
<a name="ln1439">            &quot;    return false;\n&quot;</a>
<a name="ln1440">            &quot;}\n\n&quot;);</a>
<a name="ln1441"> </a>
<a name="ln1442">        fprintf(fp, &quot;bool tile_%s_equal(tileidx_t idx, tileidx_t cmp)\n{\n&quot;,</a>
<a name="ln1443">            lcname.c_str());</a>
<a name="ln1444">        add_abstracts(fp, &quot;return (tile_%s_equal(idx, cmp));&quot;, lc_enum, uc_max_enum);</a>
<a name="ln1445">        fprintf(fp, &quot;}\n\n&quot;);</a>
<a name="ln1446"> </a>
<a name="ln1447">        fprintf(fp, &quot;tileidx_t tile_%s_coloured(tileidx_t idx, int col)\n{\n&quot;,</a>
<a name="ln1448">            lcname.c_str());</a>
<a name="ln1449">        add_abstracts(fp, &quot;return (tile_%s_coloured(idx, col));&quot;, lc_enum, uc_max_enum);</a>
<a name="ln1450">        fprintf(fp, &quot;}\n\n&quot;);</a>
<a name="ln1451"> </a>
<a name="ln1452">        fclose(fp);</a>
<a name="ln1453">    }</a>
<a name="ln1454"> </a>
<a name="ln1455">    // write &quot;tile-%name.html&quot;</a>
<a name="ln1456">    if (!m_page.m_tiles.empty())</a>
<a name="ln1457">    {</a>
<a name="ln1458">        char filename[1024];</a>
<a name="ln1459">        sprintf(filename, &quot;tile-%s.html&quot;, lcname.c_str());</a>
<a name="ln1460">        FILE *fp = fopen(filename, &quot;w&quot;);</a>
<a name="ln1461"> </a>
<a name="ln1462">        if (!fp)</a>
<a name="ln1463">        {</a>
<a name="ln1464">            fprintf(stderr, &quot;Error: couldn't open '%s' for write.\n&quot;, filename);</a>
<a name="ln1465">            return false;</a>
<a name="ln1466">        }</a>
<a name="ln1467"> </a>
<a name="ln1468">        fprintf(fp, &quot;&lt;html&gt;&lt;table&gt;\n&quot;);</a>
<a name="ln1469"> </a>
<a name="ln1470">        fprintf(fp, &quot;%s&quot;, &quot;&lt;tr&gt;&lt;td&gt;Image&lt;/td&gt;&lt;td&gt;Vault String&lt;/td&gt;&lt;td&gt;Enum&lt;/td&gt;&lt;td&gt;Path&lt;/td&gt;&lt;/tr&gt;\n&quot;);</a>
<a name="ln1471"> </a>
<a name="ln1472">        int total_prob = 0;</a>
<a name="ln1473">        for (unsigned int i = 0; i &lt; m_page.m_tiles.size(); i++)</a>
<a name="ln1474">        {</a>
<a name="ln1475">            fprintf(fp, &quot;&lt;tr&gt;&quot;);</a>
<a name="ln1476"> </a>
<a name="ln1477">            fprintf(fp, &quot;&lt;td&gt;&lt;img src=\&quot;%s\&quot;/&gt;&lt;/td&gt;&quot;,</a>
<a name="ln1478">                    m_page.m_tiles[i]-&gt;filename().c_str());</a>
<a name="ln1479"> </a>
<a name="ln1480">            if (m_page.m_tiles[i]-&gt;enumcount() == 0)</a>
<a name="ln1481">            {</a>
<a name="ln1482">                if (i == 0)</a>
<a name="ln1483">                    fprintf(fp, &quot;&lt;td&gt;&lt;/td&gt;&lt;td&gt;&lt;/td&gt;&quot;);</a>
<a name="ln1484">                else</a>
<a name="ln1485">                {</a>
<a name="ln1486">                    const float prob = m_page.m_probs[i] - m_page.m_probs[i-1];</a>
<a name="ln1487">                    const float perc = prob * 100 / (float)total_prob;</a>
<a name="ln1488">                    fprintf(fp, &quot;&lt;td&gt;(%.1f%%)&lt;/td&gt;&lt;td&gt;&lt;/td&gt;&quot;, perc);</a>
<a name="ln1489">                }</a>
<a name="ln1490">            }</a>
<a name="ln1491">            else</a>
<a name="ln1492">            {</a>
<a name="ln1493">                string lcenum = m_page.m_tiles[i]-&gt;enumname(0);</a>
<a name="ln1494">                for (unsigned int c = 0; c &lt; lcenum.size(); c++)</a>
<a name="ln1495">                    lcenum[c] = toalower(lcenum[c]);</a>
<a name="ln1496"> </a>
<a name="ln1497">                if (i == 0 || m_page.m_counts[i] == 1)</a>
<a name="ln1498">                    fprintf(fp, &quot;&lt;td&gt;%s&lt;/td&gt;&quot;, lcenum.c_str());</a>
<a name="ln1499">                else</a>
<a name="ln1500">                {</a>
<a name="ln1501">                    total_prob = m_page.m_probs[i + m_page.m_counts[i] - 1];</a>
<a name="ln1502">                    const float prob = m_page.m_probs[i];</a>
<a name="ln1503">                    const float perc = prob * 100 / (float)total_prob;</a>
<a name="ln1504">                    fprintf(fp, &quot;&lt;td&gt;%s (%.1f%%)&lt;/td&gt;&quot;, lcenum.c_str(), perc);</a>
<a name="ln1505">                }</a>
<a name="ln1506"> </a>
<a name="ln1507">                const string &amp;parts_ctg = m_page.m_tiles[i]-&gt;parts_ctg();</a>
<a name="ln1508">                if (parts_ctg.empty())</a>
<a name="ln1509">                {</a>
<a name="ln1510">                    fprintf(fp, &quot;&lt;td&gt;%s_%s&lt;/td&gt;&quot;,</a>
<a name="ln1511">                            m_prefix.c_str(),</a>
<a name="ln1512">                            m_page.m_tiles[i]-&gt;enumname(0).c_str());</a>
<a name="ln1513">                }</a>
<a name="ln1514">                else</a>
<a name="ln1515">                {</a>
<a name="ln1516">                    fprintf(fp, &quot;&lt;td&gt;%s_%s_%s&lt;/td&gt;&quot;,</a>
<a name="ln1517">                            m_prefix.c_str(),</a>
<a name="ln1518">                            parts_ctg.c_str(),</a>
<a name="ln1519">                            m_page.m_tiles[i]-&gt;enumname(0).c_str());</a>
<a name="ln1520">                }</a>
<a name="ln1521">            }</a>
<a name="ln1522"> </a>
<a name="ln1523">            fprintf(fp, &quot;&lt;td&gt;%s&lt;/td&gt;&quot;, m_page.m_tiles[i]-&gt;filename().c_str());</a>
<a name="ln1524"> </a>
<a name="ln1525">            fprintf(fp, &quot;&lt;/tr&gt;\n&quot;);</a>
<a name="ln1526">        }</a>
<a name="ln1527"> </a>
<a name="ln1528">        fprintf(fp, &quot;&lt;/table&gt;&lt;/html&gt;\n&quot;);</a>
<a name="ln1529"> </a>
<a name="ln1530">        fclose(fp);</a>
<a name="ln1531">    }</a>
<a name="ln1532"> </a>
<a name="ln1533">    delete[] part_min;</a>
<a name="ln1534"> </a>
<a name="ln1535">    // Write &quot;%name.d&quot;</a>
<a name="ln1536">    if (m_abstract.empty())</a>
<a name="ln1537">    {</a>
<a name="ln1538">        char filename[1024];</a>
<a name="ln1539">        sprintf(filename, &quot;%s.d&quot;, lcname.c_str());</a>
<a name="ln1540">        FILE *fp = fopen(filename, &quot;w&quot;);</a>
<a name="ln1541"> </a>
<a name="ln1542">        if (!fp)</a>
<a name="ln1543">        {</a>
<a name="ln1544">            fprintf(stderr, &quot;Error: couldn't open '%s' for write.\n&quot;, filename);</a>
<a name="ln1545">            return false;</a>
<a name="ln1546">        }</a>
<a name="ln1547"> </a>
<a name="ln1548">        if (!m_page.m_tiles.empty())</a>
<a name="ln1549">            fprintf(fp, &quot;%s.png: \\\n&quot;, lcname.c_str());</a>
<a name="ln1550"> </a>
<a name="ln1551">        for (const auto&amp; str : m_depends)</a>
<a name="ln1552">             fprintf(fp, &quot;  %s \\\n&quot;, str.c_str());</a>
<a name="ln1553"> </a>
<a name="ln1554">        // Also generate empty dependencies for each file.</a>
<a name="ln1555">        // This way, if a file gets removed, the dependency file</a>
<a name="ln1556">        // won't complain about not having a rule to make the non-existent file.</a>
<a name="ln1557">        fprintf(fp, &quot;%s&quot;, &quot;\n\n&quot;);</a>
<a name="ln1558"> </a>
<a name="ln1559">        for (const auto&amp; str : m_depends)</a>
<a name="ln1560">             fprintf(fp, &quot;%s:\n&quot;, str.c_str());</a>
<a name="ln1561"> </a>
<a name="ln1562">        fclose(fp);</a>
<a name="ln1563">    }</a>
<a name="ln1564"> </a>
<a name="ln1565">    // write &quot;tileinfo-%name.js&quot;</a>
<a name="ln1566">    {</a>
<a name="ln1567">        char filename[1024];</a>
<a name="ln1568">        sprintf(filename, &quot;tileinfo-%s.js&quot;, lcname.c_str());</a>
<a name="ln1569">        FILE *fp = fopen(filename, &quot;w&quot;);</a>
<a name="ln1570"> </a>
<a name="ln1571">        if (!fp)</a>
<a name="ln1572">        {</a>
<a name="ln1573">            fprintf(stderr, &quot;Error: couldn't open '%s' for write.\n&quot;, filename);</a>
<a name="ln1574">            return false;</a>
<a name="ln1575">        }</a>
<a name="ln1576"> </a>
<a name="ln1577">        if (m_abstract.size() == 0)</a>
<a name="ln1578">        {</a>
<a name="ln1579">            fprintf(fp, &quot;define([&quot;);</a>
<a name="ln1580">            if (m_start_value_module.size() &gt; 0)</a>
<a name="ln1581">                fprintf(fp, &quot;\&quot;./tileinfo-%s\&quot;&quot;, m_start_value_module.c_str());</a>
<a name="ln1582">            fprintf(fp, &quot;], function(m) {\n&quot;);</a>
<a name="ln1583">        }</a>
<a name="ln1584">        else</a>
<a name="ln1585">        {</a>
<a name="ln1586">            fprintf(fp, &quot;define([\&quot;jquery\&quot;,&quot;);</a>
<a name="ln1587">            for (const auto&amp; abstract : m_abstract)</a>
<a name="ln1588">                fprintf(fp, &quot;\&quot;./tileinfo-%s\&quot;, &quot;, abstract.first.c_str());</a>
<a name="ln1589">            fprintf(fp, &quot;],\n       function ($, &quot;);</a>
<a name="ln1590">            for (size_t i = 0; i &lt; m_abstract.size(); ++i)</a>
<a name="ln1591">            {</a>
<a name="ln1592">                if (i &lt; m_abstract.size() - 1)</a>
<a name="ln1593">                    fprintf(fp, &quot;%s, &quot;, m_abstract[i].first.c_str());</a>
<a name="ln1594">                else</a>
<a name="ln1595">                    fprintf(fp, &quot;%s&quot;, m_abstract[i].first.c_str());</a>
<a name="ln1596">            }</a>
<a name="ln1597">            fprintf(fp, &quot;) {\n&quot;);</a>
<a name="ln1598">        }</a>
<a name="ln1599">        fprintf(fp, &quot;// This file has been automatically generated.\n\n&quot;);</a>
<a name="ln1600">        fprintf(fp, &quot;var exports = {};\n&quot;);</a>
<a name="ln1601"> </a>
<a name="ln1602">        if (m_abstract.size() &gt; 0)</a>
<a name="ln1603">        {</a>
<a name="ln1604">            for (const auto&amp; abstract : m_abstract)</a>
<a name="ln1605">                fprintf(fp, &quot;$.extend(exports, %s);\n&quot;, abstract.first.c_str());</a>
<a name="ln1606">        }</a>
<a name="ln1607"> </a>
<a name="ln1608">        if (m_start_value_module.size() &gt; 0)</a>
<a name="ln1609">            fprintf(fp, &quot;\nvar val = m.%s;\n&quot;, m_start_value.c_str());</a>
<a name="ln1610">        else</a>
<a name="ln1611">            fprintf(fp, &quot;\nvar val = %s;\n&quot;, m_start_value.c_str());</a>
<a name="ln1612"> </a>
<a name="ln1613">        string old_enum_name = &quot;&quot;;</a>
<a name="ln1614">        int count = 0;</a>
<a name="ln1615">        for (unsigned int i = 0; i &lt; m_page.m_tiles.size(); i++)</a>
<a name="ln1616">        {</a>
<a name="ln1617">            const string &amp;parts_ctg = m_page.m_tiles[i]-&gt;parts_ctg();</a>
<a name="ln1618">            const int enumcount = m_page.m_tiles[i]-&gt;enumcount();</a>
<a name="ln1619"> </a>
<a name="ln1620">            if (enumcount == 0)</a>
<a name="ln1621">            {</a>
<a name="ln1622">                if (old_enum_name.empty())</a>
<a name="ln1623">                {</a>
<a name="ln1624">                    fprintf(fp, &quot;exports.%s_FILLER_%d = val++;\n&quot;,</a>
<a name="ln1625">                            ucname.c_str(), i);</a>
<a name="ln1626">                }</a>
<a name="ln1627">                else</a>
<a name="ln1628">                {</a>
<a name="ln1629">                    fprintf(fp, &quot;exports.%s_%d = val++;\n&quot;,</a>
<a name="ln1630">                            old_enum_name.c_str(), ++count);</a>
<a name="ln1631">                }</a>
<a name="ln1632">            }</a>
<a name="ln1633">            else if (parts_ctg.empty())</a>
<a name="ln1634">            {</a>
<a name="ln1635">                const string &amp;enumname = m_page.m_tiles[i]-&gt;enumname(0);</a>
<a name="ln1636">                fprintf(fp, &quot;exports.%s = val++;\n&quot;,</a>
<a name="ln1637">                        enumname.c_str());</a>
<a name="ln1638">                old_enum_name = enumname;</a>
<a name="ln1639">                count = 0;</a>
<a name="ln1640">            }</a>
<a name="ln1641">            else</a>
<a name="ln1642">            {</a>
<a name="ln1643">                const string &amp;enumname = m_page.m_tiles[i]-&gt;enumname(0);</a>
<a name="ln1644">                fprintf(fp, &quot;exports.%s_%s = val++;\n&quot;,</a>
<a name="ln1645">                        parts_ctg.c_str(), enumname.c_str());</a>
<a name="ln1646">                old_enum_name = enumname;</a>
<a name="ln1647">                count = 0;</a>
<a name="ln1648">            }</a>
<a name="ln1649"> </a>
<a name="ln1650">            for (int c = 1; c &lt; enumcount; ++c)</a>
<a name="ln1651">            {</a>
<a name="ln1652">                const string &amp;basename = m_page.m_tiles[i]-&gt;enumname(0);</a>
<a name="ln1653">                const string &amp;enumname = m_page.m_tiles[i]-&gt;enumname(c);</a>
<a name="ln1654"> </a>
<a name="ln1655">                if (parts_ctg.empty())</a>
<a name="ln1656">                {</a>
<a name="ln1657">                    fprintf(fp, &quot;val = exports.%s = exports.%s; val++;\n&quot;,</a>
<a name="ln1658">                            enumname.c_str(), basename.c_str());</a>
<a name="ln1659">                }</a>
<a name="ln1660">                else</a>
<a name="ln1661">                {</a>
<a name="ln1662">                    fprintf(fp, &quot;val = exports.%s_%s = exports.%s_%s; val++;\n&quot;,</a>
<a name="ln1663">                            parts_ctg.c_str(), enumname.c_str(),</a>
<a name="ln1664">                            parts_ctg.c_str(), basename.c_str());</a>
<a name="ln1665">                }</a>
<a name="ln1666">            }</a>
<a name="ln1667">        }</a>
<a name="ln1668"> </a>
<a name="ln1669">        if (m_abstract.size() == 0)</a>
<a name="ln1670">        {</a>
<a name="ln1671">            fprintf(fp, &quot;exports.%s_MAX = exports.%s_%s_MAX = val++;\n\n&quot;,</a>
<a name="ln1672">                    ucname.c_str(), m_prefix.c_str(), ucname.c_str());</a>
<a name="ln1673"> </a>
<a name="ln1674">            fprintf(fp, &quot;var tile_info = [\n&quot;);</a>
<a name="ln1675">            for (unsigned int i = 0; i &lt; m_page.m_offsets.size(); i+=4)</a>
<a name="ln1676">            {</a>
<a name="ln1677">                fprintf(fp, &quot;  {w: %d, h: %d, ox: %d, oy: %d, sx: %d, sy: %d, ex: %d, ey: %d},\n&quot;,</a>
<a name="ln1678">                        m_page.m_offsets[i+2], m_page.m_offsets[i+3],</a>
<a name="ln1679">                        m_page.m_offsets[i], m_page.m_offsets[i+1],</a>
<a name="ln1680">                        m_page.m_texcoords[i], m_page.m_texcoords[i+1],</a>
<a name="ln1681">                        m_page.m_texcoords[i+2], m_page.m_texcoords[i+3]);</a>
<a name="ln1682">            }</a>
<a name="ln1683">            fprintf(fp, &quot;];\n\n&quot;);</a>
<a name="ln1684"> </a>
<a name="ln1685">            fprintf(fp, &quot;exports.get_tile_info = function (idx)\n{\n&quot;);</a>
<a name="ln1686">            fprintf(fp, &quot;    return tile_info[idx - %s%s];\n&quot;,</a>
<a name="ln1687">                    m_start_value_module.size() &gt; 0 ? &quot;m.&quot; : &quot;&quot;,</a>
<a name="ln1688">                    m_start_value.c_str());</a>
<a name="ln1689">            fprintf(fp, &quot;};\n\n&quot;);</a>
<a name="ln1690"> </a>
<a name="ln1691">            fprintf(fp, &quot;var _tile_count =\n[\n&quot;);</a>
<a name="ln1692">            for (unsigned int i = 0; i &lt; m_page.m_counts.size(); i++)</a>
<a name="ln1693">                fprintf(fp, &quot;    %u,\n&quot;, m_page.m_counts[i]);</a>
<a name="ln1694">            fprintf(fp, &quot;];\n\n&quot;);</a>
<a name="ln1695"> </a>
<a name="ln1696">            fprintf(fp, &quot;exports.tile_count = function (idx)\n{\n&quot;);</a>
<a name="ln1697">            fprintf(fp, &quot;    return _tile_count[idx - %s%s];\n&quot;,</a>
<a name="ln1698">                    m_start_value_module.size() &gt; 0 ? &quot;m.&quot; : &quot;&quot;,</a>
<a name="ln1699">                    m_start_value.c_str());</a>
<a name="ln1700">            fprintf(fp, &quot;}\n\n&quot;);</a>
<a name="ln1701"> </a>
<a name="ln1702">            fprintf(fp, &quot;var _basetiles =\n[\n&quot;);</a>
<a name="ln1703">            for (unsigned int i = 0; i &lt; m_page.m_base_tiles.size(); i++)</a>
<a name="ln1704">                fprintf(fp, &quot;    %u,\n&quot;, m_page.m_base_tiles[i]);</a>
<a name="ln1705">            fprintf(fp, &quot;];\n\n&quot;);</a>
<a name="ln1706"> </a>
<a name="ln1707">            fprintf(fp, &quot;exports.basetile = function (idx)\n{\n&quot;);</a>
<a name="ln1708">            fprintf(fp, &quot;    return _basetiles[idx - %s%s] + %s%s;\n&quot;,</a>
<a name="ln1709">                    m_start_value_module.size() &gt; 0 ? &quot;m.&quot; : &quot;&quot;, m_start_value.c_str(),</a>
<a name="ln1710">                    m_start_value_module.size() &gt; 0 ? &quot;m.&quot; : &quot;&quot;, m_start_value.c_str());</a>
<a name="ln1711">            fprintf(fp, &quot;};\n\n&quot;);</a>
<a name="ln1712"> </a>
<a name="ln1713">            fprintf(fp, &quot;exports.get_img = function (idx) {\n&quot;);</a>
<a name="ln1714">            fprintf(fp, &quot;    return \&quot;%s\&quot;;\n&quot;, lcname.c_str());</a>
<a name="ln1715">            fprintf(fp, &quot;};\n\n&quot;);</a>
<a name="ln1716">        }</a>
<a name="ln1717">        else</a>
<a name="ln1718">        {</a>
<a name="ln1719">            {</a>
<a name="ln1720">                size_t last_idx = m_abstract.size() - 1;</a>
<a name="ln1721"> </a>
<a name="ln1722">                string max_enum = &quot;&quot;;</a>
<a name="ln1723">                max_enum += m_abstract[last_idx].first;</a>
<a name="ln1724">                max_enum += &quot;_MAX&quot;;</a>
<a name="ln1725"> </a>
<a name="ln1726">                for (char&amp; c : max_enum)</a>
<a name="ln1727">                    c = toaupper(c);</a>
<a name="ln1728"> </a>
<a name="ln1729">                fprintf(fp, &quot;exports.%s_MAX = window.%s_%s_MAX = %s.%s;\n\n&quot;,</a>
<a name="ln1730">                        ucname.c_str(), m_prefix.c_str(), ucname.c_str()</a>
<a name="ln1731">                        , m_abstract[last_idx].first.c_str(),</a>
<a name="ln1732">                        max_enum.c_str());</a>
<a name="ln1733">            }</a>
<a name="ln1734"> </a>
<a name="ln1735">            vector&lt;string&gt; uc_max_enum;</a>
<a name="ln1736">            vector&lt;string&gt; lc_enum;</a>
<a name="ln1737">            for (const auto&amp; abstract : m_abstract)</a>
<a name="ln1738">            {</a>
<a name="ln1739">                string max_enum = abstract.first;</a>
<a name="ln1740">                max_enum += &quot;_MAX&quot;;</a>
<a name="ln1741">                for (char&amp; c : max_enum)</a>
<a name="ln1742">                    c = toaupper(c);</a>
<a name="ln1743"> </a>
<a name="ln1744">                max_enum = abstract.first + &quot;.&quot; + max_enum;</a>
<a name="ln1745"> </a>
<a name="ln1746">                uc_max_enum.push_back(max_enum);</a>
<a name="ln1747"> </a>
<a name="ln1748">                lc_enum.push_back(abstract.first);</a>
<a name="ln1749">            }</a>
<a name="ln1750"> </a>
<a name="ln1751">            fprintf(fp, &quot;exports.get_tile_info = function (idx)\n{\n&quot;);</a>
<a name="ln1752">            add_abstracts(fp, &quot;return (%s.get_tile_info(idx));&quot;, lc_enum, uc_max_enum, true);</a>
<a name="ln1753">            fprintf(fp, &quot;};\n\n&quot;);</a>
<a name="ln1754"> </a>
<a name="ln1755">            fprintf(fp, &quot;exports.tile_count = function (idx)\n{\n&quot;);</a>
<a name="ln1756">            add_abstracts(fp, &quot;return (%s.tile_count(idx));&quot;, lc_enum, uc_max_enum, true);</a>
<a name="ln1757">            fprintf(fp, &quot;};\n\n&quot;);</a>
<a name="ln1758"> </a>
<a name="ln1759">            fprintf(fp, &quot;exports.basetile = function (idx)\n{\n&quot;);</a>
<a name="ln1760">            add_abstracts(fp, &quot;return (%s.basetile(idx));&quot;, lc_enum, uc_max_enum, true);</a>
<a name="ln1761">            fprintf(fp, &quot;};\n\n&quot;);</a>
<a name="ln1762"> </a>
<a name="ln1763">            fprintf(fp, &quot;exports.get_img = function (idx) {\n&quot;);</a>
<a name="ln1764">            add_abstracts(fp, &quot;return \&quot;%s\&quot;;&quot;, lc_enum, uc_max_enum, true);</a>
<a name="ln1765">            fprintf(fp, &quot;};\n\n&quot;);</a>
<a name="ln1766">        }</a>
<a name="ln1767"> </a>
<a name="ln1768">        fprintf(fp, &quot;return exports;\n});\n&quot;);</a>
<a name="ln1769"> </a>
<a name="ln1770">        fclose(fp);</a>
<a name="ln1771">    }</a>
<a name="ln1772"> </a>
<a name="ln1773">    return true;</a>
<a name="ln1774">}</a>

</code></pre>
<div class="balloon" rel="76"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v648/" target="_blank">V648</a> Priority of the '&&' operation is higher than that of the '||' operation.</p></div>
<div class="balloon" rel="125"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v663/" target="_blank">V663</a> Infinite loop is possible. The 'cin.eof()' condition is insufficient to break from the loop. Consider adding the 'cin.fail()' function call to the conditional expression.</p></div>
<div class="balloon" rel="1129"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v773/" target="_blank">V773</a> The function was exited without releasing the 'part_min' pointer. A memory leak is possible.</p></div>

<link rel="stylesheet" href="highlight.css">
<script src="highlight.pack.js"></script>
<script src="highlightjs-line-numbers.js"></script>
<script>hljs.initHighlightingOnLoad();</script>
<script>hljs.initLineNumbersOnLoad();</script>
<script>
  $(document).ready(function() {
      $('.balloon').each(function () {
          var bl = $(this);
          var line = bl.attr('rel');
          var text = $('a[name="ln'+line+'"]').text();

          var space_count = 0;
          for(var i = 0; i<text.length; i++){
              var char = text[i];
              if((char !== ' ')&&(char !== '\t'))break;
              if(char === '\t')space_count++;
              space_count++;
          }

          bl.css('margin-left', space_count*8);
          $('a[name="ln'+line+'"]').after(bl);
      });

      window.location = window.location;
  });
</script>
</body>
</html>
