
<html>
<head>

  <meta http-equiv="Content-Type" content="text/html; charset=US-ASCII" />
  <title>ouch.cc</title>

  <link rel="stylesheet" href="../style.css"/>
  <script src="../jquery-3.2.1.min.js"></script>
</head>
<body>

<pre><code class = "cpp">
<a name="ln1">/**</a>
<a name="ln2"> * @file</a>
<a name="ln3"> * @brief Functions used when Bad Things happen to the player.</a>
<a name="ln4">**/</a>
<a name="ln5"> </a>
<a name="ln6">#include &quot;AppHdr.h&quot;</a>
<a name="ln7"> </a>
<a name="ln8">#include &quot;ouch.h&quot;</a>
<a name="ln9"> </a>
<a name="ln10">#include &lt;cctype&gt;</a>
<a name="ln11">#include &lt;cmath&gt;</a>
<a name="ln12">#include &lt;cstdio&gt;</a>
<a name="ln13">#include &lt;cstdlib&gt;</a>
<a name="ln14">#include &lt;cstring&gt;</a>
<a name="ln15">#include &lt;iostream&gt;</a>
<a name="ln16">#include &lt;string&gt;</a>
<a name="ln17">#ifdef UNIX</a>
<a name="ln18">#include &lt;fcntl.h&gt;</a>
<a name="ln19">#include &lt;sys/types.h&gt;</a>
<a name="ln20">#include &lt;unistd.h&gt;</a>
<a name="ln21">#endif</a>
<a name="ln22"> </a>
<a name="ln23">#include &quot;artefact.h&quot;</a>
<a name="ln24">#include &quot;beam.h&quot;</a>
<a name="ln25">#include &quot;chardump.h&quot;</a>
<a name="ln26">#include &quot;colour.h&quot;</a>
<a name="ln27">#include &quot;delay.h&quot;</a>
<a name="ln28">#include &quot;dgn-event.h&quot;</a>
<a name="ln29">#include &quot;end.h&quot;</a>
<a name="ln30">#include &quot;env.h&quot;</a>
<a name="ln31">#include &quot;fight.h&quot;</a>
<a name="ln32">#include &quot;files.h&quot;</a>
<a name="ln33">#include &quot;fineff.h&quot;</a>
<a name="ln34">#include &quot;god-abil.h&quot;</a>
<a name="ln35">#include &quot;god-passive.h&quot;</a>
<a name="ln36">#include &quot;hints.h&quot;</a>
<a name="ln37">#include &quot;hiscores.h&quot;</a>
<a name="ln38">#include &quot;invent.h&quot;</a>
<a name="ln39">#include &quot;item-prop.h&quot;</a>
<a name="ln40">#include &quot;libutil.h&quot;</a>
<a name="ln41">#include &quot;message.h&quot;</a>
<a name="ln42">#include &quot;mgen-data.h&quot;</a>
<a name="ln43">#include &quot;mon-death.h&quot;</a>
<a name="ln44">#include &quot;mon-place.h&quot;</a>
<a name="ln45">#include &quot;mon-util.h&quot;</a>
<a name="ln46">#include &quot;mutation.h&quot;</a>
<a name="ln47">#include &quot;nearby-danger.h&quot;</a>
<a name="ln48">#include &quot;notes.h&quot;</a>
<a name="ln49">#include &quot;options.h&quot;</a>
<a name="ln50">#include &quot;output.h&quot;</a>
<a name="ln51">#include &quot;player.h&quot;</a>
<a name="ln52">#include &quot;player-stats.h&quot;</a>
<a name="ln53">#include &quot;potion.h&quot;</a>
<a name="ln54">#include &quot;prompt.h&quot;</a>
<a name="ln55">#include &quot;random.h&quot;</a>
<a name="ln56">#include &quot;religion.h&quot;</a>
<a name="ln57">#include &quot;shopping.h&quot;</a>
<a name="ln58">#include &quot;shout.h&quot;</a>
<a name="ln59">#include &quot;spl-clouds.h&quot;</a>
<a name="ln60">#include &quot;spl-selfench.h&quot;</a>
<a name="ln61">#include &quot;state.h&quot;</a>
<a name="ln62">#include &quot;stringutil.h&quot;</a>
<a name="ln63">#include &quot;teleport.h&quot;</a>
<a name="ln64">#include &quot;transform.h&quot;</a>
<a name="ln65">#include &quot;tutorial.h&quot;</a>
<a name="ln66">#include &quot;view.h&quot;</a>
<a name="ln67">#include &quot;xom.h&quot;</a>
<a name="ln68"> </a>
<a name="ln69">void maybe_melt_player_enchantments(beam_type flavour, int damage)</a>
<a name="ln70">{</a>
<a name="ln71">    if (flavour == BEAM_FIRE || flavour == BEAM_LAVA</a>
<a name="ln72">        || flavour == BEAM_STICKY_FLAME || flavour == BEAM_STEAM)</a>
<a name="ln73">    {</a>
<a name="ln74">        if (you.has_mutation(MUT_ICEMAIL))</a>
<a name="ln75">        {</a>
<a name="ln76">            if (!you.duration[DUR_ICEMAIL_DEPLETED])</a>
<a name="ln77">                mprf(MSGCH_DURATION, &quot;Your icy envelope dissipates!&quot;);</a>
<a name="ln78">            you.duration[DUR_ICEMAIL_DEPLETED] = ICEMAIL_TIME;</a>
<a name="ln79">            you.redraw_armour_class = true;</a>
<a name="ln80">        }</a>
<a name="ln81"> </a>
<a name="ln82">        if (you.duration[DUR_ICY_ARMOUR] &gt; 0)</a>
<a name="ln83">        {</a>
<a name="ln84">            you.duration[DUR_ICY_ARMOUR] -= damage * BASELINE_DELAY;</a>
<a name="ln85">            if (you.duration[DUR_ICY_ARMOUR] &lt;= 0)</a>
<a name="ln86">                remove_ice_armour();</a>
<a name="ln87">            else</a>
<a name="ln88">                you.props[MELT_ARMOUR_KEY] = true;</a>
<a name="ln89">        }</a>
<a name="ln90">    }</a>
<a name="ln91">}</a>
<a name="ln92"> </a>
<a name="ln93">int check_your_resists(int hurted, beam_type flavour, string source,</a>
<a name="ln94">                       bolt *beam, bool doEffects)</a>
<a name="ln95">{</a>
<a name="ln96">    int original = hurted;</a>
<a name="ln97"> </a>
<a name="ln98">    dprf(&quot;checking resistance: flavour=%d&quot;, flavour);</a>
<a name="ln99"> </a>
<a name="ln100">    string kaux = &quot;&quot;;</a>
<a name="ln101">    if (beam)</a>
<a name="ln102">    {</a>
<a name="ln103">        source = beam-&gt;get_source_name();</a>
<a name="ln104">        kaux = beam-&gt;name;</a>
<a name="ln105">    }</a>
<a name="ln106"> </a>
<a name="ln107">    if (doEffects)</a>
<a name="ln108">        maybe_melt_player_enchantments(flavour, hurted);</a>
<a name="ln109"> </a>
<a name="ln110">    switch (flavour)</a>
<a name="ln111">    {</a>
<a name="ln112">    case BEAM_WATER:</a>
<a name="ln113">        hurted = resist_adjust_damage(&amp;you, flavour, hurted);</a>
<a name="ln114">        if (!hurted &amp;&amp; doEffects)</a>
<a name="ln115">            mpr(&quot;You shrug off the wave.&quot;);</a>
<a name="ln116">        break;</a>
<a name="ln117"> </a>
<a name="ln118">    case BEAM_STEAM:</a>
<a name="ln119">        hurted = resist_adjust_damage(&amp;you, flavour, hurted);</a>
<a name="ln120">        if (hurted &lt; original &amp;&amp; doEffects)</a>
<a name="ln121">            canned_msg(MSG_YOU_RESIST);</a>
<a name="ln122">        else if (hurted &gt; original &amp;&amp; doEffects)</a>
<a name="ln123">        {</a>
<a name="ln124">            mpr(&quot;The steam scalds you terribly!&quot;);</a>
<a name="ln125">            xom_is_stimulated(200);</a>
<a name="ln126">        }</a>
<a name="ln127">        break;</a>
<a name="ln128"> </a>
<a name="ln129">    case BEAM_FIRE:</a>
<a name="ln130">        hurted = resist_adjust_damage(&amp;you, flavour, hurted);</a>
<a name="ln131">        if (hurted &lt; original &amp;&amp; doEffects)</a>
<a name="ln132">            canned_msg(MSG_YOU_RESIST);</a>
<a name="ln133">        else if (hurted &gt; original &amp;&amp; doEffects)</a>
<a name="ln134">        {</a>
<a name="ln135">            mpr(&quot;The fire burns you terribly!&quot;);</a>
<a name="ln136">            xom_is_stimulated(200);</a>
<a name="ln137">        }</a>
<a name="ln138">        break;</a>
<a name="ln139"> </a>
<a name="ln140">    case BEAM_DAMNATION:</a>
<a name="ln141">        break; // sucks to be you (:</a>
<a name="ln142"> </a>
<a name="ln143">    case BEAM_COLD:</a>
<a name="ln144">        hurted = resist_adjust_damage(&amp;you, flavour, hurted);</a>
<a name="ln145">        if (hurted &lt; original &amp;&amp; doEffects)</a>
<a name="ln146">            canned_msg(MSG_YOU_RESIST);</a>
<a name="ln147">        else if (hurted &gt; original &amp;&amp; doEffects)</a>
<a name="ln148">        {</a>
<a name="ln149">            mpr(&quot;You feel a terrible chill!&quot;);</a>
<a name="ln150">            xom_is_stimulated(200);</a>
<a name="ln151">        }</a>
<a name="ln152">        break;</a>
<a name="ln153"> </a>
<a name="ln154">    case BEAM_ELECTRICITY:</a>
<a name="ln155">        hurted = resist_adjust_damage(&amp;you, flavour, hurted);</a>
<a name="ln156"> </a>
<a name="ln157">        if (hurted &lt; original &amp;&amp; doEffects)</a>
<a name="ln158">            canned_msg(MSG_YOU_RESIST);</a>
<a name="ln159">        break;</a>
<a name="ln160"> </a>
<a name="ln161">    case BEAM_POISON:</a>
<a name="ln162">        hurted = resist_adjust_damage(&amp;you, flavour, hurted);</a>
<a name="ln163"> </a>
<a name="ln164">        if (doEffects)</a>
<a name="ln165">        {</a>
<a name="ln166">            // Ensure that we received a valid beam object before proceeding.</a>
<a name="ln167">            // See also melee-attack.cc:_print_resist_messages() which cannot be</a>
<a name="ln168">            // used with this beam type (as it does not provide a valid beam).</a>
<a name="ln169">            ASSERT(beam);</a>
<a name="ln170">            int pois = div_rand_round(beam-&gt;damage.num * beam-&gt;damage.size, 3);</a>
<a name="ln171">            pois = 3 + random_range(pois * 2 / 3, pois * 4 / 3);</a>
<a name="ln172">            poison_player(pois, source, kaux);</a>
<a name="ln173"> </a>
<a name="ln174">            if (player_res_poison() &gt; 0)</a>
<a name="ln175">                canned_msg(MSG_YOU_RESIST);</a>
<a name="ln176">        }</a>
<a name="ln177"> </a>
<a name="ln178">        break;</a>
<a name="ln179"> </a>
<a name="ln180">    case BEAM_POISON_ARROW:</a>
<a name="ln181">        if (doEffects)</a>
<a name="ln182">        {</a>
<a name="ln183">            // Ensure that we received a valid beam object before proceeding.</a>
<a name="ln184">            // See also melee-attack.cc:_print_resist_messages() which cannot be</a>
<a name="ln185">            // used with this beam type (as it does not provide a valid beam).</a>
<a name="ln186">            ASSERT(beam);</a>
<a name="ln187">            int pois = div_rand_round(beam-&gt;damage.num * beam-&gt;damage.size, 3);</a>
<a name="ln188">            pois = 3 + random_range(pois * 2 / 3, pois * 4 / 3);</a>
<a name="ln189"> </a>
<a name="ln190">            const int resist = player_res_poison();</a>
<a name="ln191">            poison_player((resist ? pois / 2 : pois), source, kaux, true);</a>
<a name="ln192">        }</a>
<a name="ln193"> </a>
<a name="ln194">        hurted = resist_adjust_damage(&amp;you, flavour, hurted);</a>
<a name="ln195">        if (hurted &lt; original &amp;&amp; doEffects)</a>
<a name="ln196">            canned_msg(MSG_YOU_PARTIALLY_RESIST);</a>
<a name="ln197">        break;</a>
<a name="ln198"> </a>
<a name="ln199">    case BEAM_NEG:</a>
<a name="ln200">        hurted = resist_adjust_damage(&amp;you, flavour, hurted);</a>
<a name="ln201"> </a>
<a name="ln202">        if (doEffects)</a>
<a name="ln203">        {</a>
<a name="ln204">            // drain_player handles the messaging here</a>
<a name="ln205">            drain_player(min(75, 35 + original * 2 / 3), true);</a>
<a name="ln206">        }</a>
<a name="ln207">        break;</a>
<a name="ln208"> </a>
<a name="ln209">    case BEAM_ICE:</a>
<a name="ln210">        hurted = resist_adjust_damage(&amp;you, flavour, hurted);</a>
<a name="ln211"> </a>
<a name="ln212">        if (hurted &lt; original &amp;&amp; doEffects)</a>
<a name="ln213">            canned_msg(MSG_YOU_PARTIALLY_RESIST);</a>
<a name="ln214">        else if (hurted &gt; original &amp;&amp; doEffects)</a>
<a name="ln215">        {</a>
<a name="ln216">            mpr(&quot;You feel a painful chill!&quot;);</a>
<a name="ln217">            xom_is_stimulated(200);</a>
<a name="ln218">        }</a>
<a name="ln219">        break;</a>
<a name="ln220"> </a>
<a name="ln221">    case BEAM_LAVA:</a>
<a name="ln222">        hurted = resist_adjust_damage(&amp;you, flavour, hurted);</a>
<a name="ln223"> </a>
<a name="ln224">        if (hurted &lt; original &amp;&amp; doEffects)</a>
<a name="ln225">            canned_msg(MSG_YOU_PARTIALLY_RESIST);</a>
<a name="ln226">        else if (hurted &gt; original &amp;&amp; doEffects)</a>
<a name="ln227">        {</a>
<a name="ln228">            mpr(&quot;The lava burns you terribly!&quot;);</a>
<a name="ln229">            xom_is_stimulated(200);</a>
<a name="ln230">        }</a>
<a name="ln231">        break;</a>
<a name="ln232"> </a>
<a name="ln233">    case BEAM_ACID:</a>
<a name="ln234">        hurted = resist_adjust_damage(&amp;you, flavour, hurted);</a>
<a name="ln235">        if (hurted &lt; original &amp;&amp; doEffects)</a>
<a name="ln236">            canned_msg(MSG_YOU_RESIST);</a>
<a name="ln237">        break;</a>
<a name="ln238"> </a>
<a name="ln239">    case BEAM_MIASMA:</a>
<a name="ln240">        if (you.res_rotting())</a>
<a name="ln241">        {</a>
<a name="ln242">            if (doEffects)</a>
<a name="ln243">                canned_msg(MSG_YOU_RESIST);</a>
<a name="ln244">            hurted = 0;</a>
<a name="ln245">        }</a>
<a name="ln246">        break;</a>
<a name="ln247"> </a>
<a name="ln248">    case BEAM_HOLY:</a>
<a name="ln249">    {</a>
<a name="ln250">        hurted = resist_adjust_damage(&amp;you, flavour, hurted);</a>
<a name="ln251">        if (hurted &lt; original &amp;&amp; doEffects)</a>
<a name="ln252">            canned_msg(MSG_YOU_RESIST);</a>
<a name="ln253">        else if (hurted &gt; original &amp;&amp; doEffects)</a>
<a name="ln254">        {</a>
<a name="ln255">            mpr(&quot;You writhe in agony!&quot;);</a>
<a name="ln256">            xom_is_stimulated(200);</a>
<a name="ln257">        }</a>
<a name="ln258">        break;</a>
<a name="ln259">    }</a>
<a name="ln260"> </a>
<a name="ln261">    case BEAM_AIR:</a>
<a name="ln262">    {</a>
<a name="ln263">        // Airstrike.</a>
<a name="ln264">        if (you.airborne())</a>
<a name="ln265">            hurted += hurted / 2;</a>
<a name="ln266">        break;</a>
<a name="ln267">    }</a>
<a name="ln268"> </a>
<a name="ln269">    default:</a>
<a name="ln270">        break;</a>
<a name="ln271">    }                           // end switch</a>
<a name="ln272"> </a>
<a name="ln273">    return hurted;</a>
<a name="ln274">}</a>
<a name="ln275"> </a>
<a name="ln276">/**</a>
<a name="ln277"> * Handle side-effects for exposure to element other than damage.</a>
<a name="ln278"> * Historically this handled item destruction, and melting meltable enchantments. Now it takes care of 3 things:</a>
<a name="ln279"> *   - triggering qazlal's elemental adaptations</a>
<a name="ln280"> *   - slowing cold-blooded players (draconians, hydra form)</a>
<a name="ln281"> *   - putting out fires</a>
<a name="ln282"> * This function should be called exactly once any time a player is exposed to the</a>
<a name="ln283"> * following elements/beam types: cold, fire, elec, water, steam, lava, BEAM_FRAG. For the sake of Qazlal's</a>
<a name="ln284"> * elemental adaptation, it should also be called (exactly once) with BEAM_MISSILE when</a>
<a name="ln285"> * receiving physical damage. Hybrid damage (brands) should call it twice with appropriate</a>
<a name="ln286"> * flavours.</a>
<a name="ln287"> *</a>
<a name="ln288"> * @param flavour The beam type.</a>
<a name="ln289"> * @param strength The strength of the attack. Used in different ways for different side-effects.</a>
<a name="ln290"> *     For qazlal_elemental_adapt: (i) it is used for the probability of triggering, and (ii) the resulting length of the effect.</a>
<a name="ln291"> * @param slow_cold_blooded If True, the beam_type is BEAM_COLD, and the player</a>
<a name="ln292"> *                          is cold-blooded and not cold-resistant, slow the</a>
<a name="ln293"> *                          player 50% of the time.</a>
<a name="ln294"> */</a>
<a name="ln295">void expose_player_to_element(beam_type flavour, int strength, bool slow_cold_blooded)</a>
<a name="ln296">{</a>
<a name="ln297">    dprf(&quot;expose_player_to_element, strength %i, flavor %i, slow_cold_blooded is %i&quot;, strength, flavour, slow_cold_blooded);</a>
<a name="ln298">    qazlal_element_adapt(flavour, strength);</a>
<a name="ln299"> </a>
<a name="ln300">    if (flavour == BEAM_COLD &amp;&amp; slow_cold_blooded</a>
<a name="ln301">        &amp;&amp; you.get_mutation_level(MUT_COLD_BLOODED)</a>
<a name="ln302">        &amp;&amp; you.res_cold() &lt;= 0 &amp;&amp; coinflip())</a>
<a name="ln303">    {</a>
<a name="ln304">        you.slow_down(0, strength);</a>
<a name="ln305">    }</a>
<a name="ln306"> </a>
<a name="ln307">    if (flavour == BEAM_WATER &amp;&amp; you.duration[DUR_LIQUID_FLAMES])</a>
<a name="ln308">    {</a>
<a name="ln309">        mprf(MSGCH_WARN, &quot;The flames go out!&quot;);</a>
<a name="ln310">        you.duration[DUR_LIQUID_FLAMES] = 0;</a>
<a name="ln311">        you.props.erase(&quot;sticky_flame_source&quot;);</a>
<a name="ln312">        you.props.erase(&quot;sticky_flame_aux&quot;);</a>
<a name="ln313">    }</a>
<a name="ln314">}</a>
<a name="ln315"> </a>
<a name="ln316">static void _lose_level_abilities()</a>
<a name="ln317">{</a>
<a name="ln318">    if (you.attribute[ATTR_PERM_FLIGHT]</a>
<a name="ln319">        &amp;&amp; !you.racial_permanent_flight()</a>
<a name="ln320">        &amp;&amp; !you.wearing_ego(EQ_ALL_ARMOUR, SPARM_FLYING))</a>
<a name="ln321">    {</a>
<a name="ln322">        you.increase_duration(DUR_FLIGHT, 50, 100);</a>
<a name="ln323">        you.attribute[ATTR_PERM_FLIGHT] = 0;</a>
<a name="ln324">        mprf(MSGCH_WARN, &quot;You feel your flight won't last long.&quot;);</a>
<a name="ln325">    }</a>
<a name="ln326">}</a>
<a name="ln327"> </a>
<a name="ln328">void lose_level()</a>
<a name="ln329">{</a>
<a name="ln330">    // Because you.experience is unsigned long, if it's going to be</a>
<a name="ln331">    // negative, must die straightaway.</a>
<a name="ln332">    if (you.experience_level == 1)</a>
<a name="ln333">    {</a>
<a name="ln334">        ouch(INSTANT_DEATH, KILLED_BY_DRAINING);</a>
<a name="ln335">        // Return in case death was cancelled via wizard mode</a>
<a name="ln336">        return;</a>
<a name="ln337">    }</a>
<a name="ln338"> </a>
<a name="ln339">    you.experience_level--;</a>
<a name="ln340"> </a>
<a name="ln341">    mprf(MSGCH_WARN,</a>
<a name="ln342">         &quot;You are now level %d!&quot;, you.experience_level);</a>
<a name="ln343"> </a>
<a name="ln344">    calc_hp();</a>
<a name="ln345">    calc_mp();</a>
<a name="ln346">    _lose_level_abilities();</a>
<a name="ln347"> </a>
<a name="ln348">    char buf[200];</a>
<a name="ln349">    sprintf(buf, &quot;HP: %d/%d MP: %d/%d&quot;,</a>
<a name="ln350">            you.hp, you.hp_max, you.magic_points, you.max_magic_points);</a>
<a name="ln351">    take_note(Note(NOTE_XP_LEVEL_CHANGE, you.experience_level, 0, buf));</a>
<a name="ln352"> </a>
<a name="ln353">    you.redraw_title = true;</a>
<a name="ln354">    you.redraw_experience = true;</a>
<a name="ln355">#ifdef USE_TILE_LOCAL</a>
<a name="ln356">    // In case of intrinsic ability changes.</a>
<a name="ln357">    tiles.layout_statcol();</a>
<a name="ln358">    redraw_screen();</a>
<a name="ln359">#endif</a>
<a name="ln360"> </a>
<a name="ln361">    xom_is_stimulated(200);</a>
<a name="ln362"> </a>
<a name="ln363">    // Kill the player if maxhp &lt;= 0. We can't just move the ouch() call past</a>
<a name="ln364">    // dec_max_hp() since it would decrease hp twice, so here's another one.</a>
<a name="ln365">    ouch(0, KILLED_BY_DRAINING);</a>
<a name="ln366">}</a>
<a name="ln367"> </a>
<a name="ln368">/**</a>
<a name="ln369"> * Drain the player.</a>
<a name="ln370"> *</a>
<a name="ln371"> * @param power             The amount by which to drain the player.</a>
<a name="ln372"> * @param announce_full     Whether to print messages even when fully resisting</a>
<a name="ln373"> *                          the drain.</a>
<a name="ln374"> * @param ignore_protection Whether to ignore the player's rN.</a>
<a name="ln375"> * @return                  Whether draining occurred.</a>
<a name="ln376"> */</a>
<a name="ln377">bool drain_player(int power, bool announce_full, bool ignore_protection)</a>
<a name="ln378">{</a>
<a name="ln379">    if (crawl_state.disables[DIS_AFFLICTIONS])</a>
<a name="ln380">        return false;</a>
<a name="ln381"> </a>
<a name="ln382">    const int protection = ignore_protection ? 0 : player_prot_life();</a>
<a name="ln383"> </a>
<a name="ln384">    if (protection == 3)</a>
<a name="ln385">    {</a>
<a name="ln386">        if (announce_full)</a>
<a name="ln387">            canned_msg(MSG_YOU_RESIST);</a>
<a name="ln388"> </a>
<a name="ln389">        return false;</a>
<a name="ln390">    }</a>
<a name="ln391"> </a>
<a name="ln392">    if (protection &gt; 0)</a>
<a name="ln393">    {</a>
<a name="ln394">        canned_msg(MSG_YOU_PARTIALLY_RESIST);</a>
<a name="ln395">        power /= (protection * 2);</a>
<a name="ln396">    }</a>
<a name="ln397"> </a>
<a name="ln398">    if (power &gt; 0)</a>
<a name="ln399">    {</a>
<a name="ln400">        mpr(&quot;You feel drained.&quot;);</a>
<a name="ln401">        xom_is_stimulated(15);</a>
<a name="ln402"> </a>
<a name="ln403">        you.attribute[ATTR_XP_DRAIN] += power;</a>
<a name="ln404">        // Losing skills may affect AC/EV.</a>
<a name="ln405">        you.redraw_armour_class = true;</a>
<a name="ln406">        you.redraw_evasion = true;</a>
<a name="ln407"> </a>
<a name="ln408">        dprf(&quot;Drained by %d points (%d total)&quot;, power, you.attribute[ATTR_XP_DRAIN]);</a>
<a name="ln409"> </a>
<a name="ln410">        return true;</a>
<a name="ln411">    }</a>
<a name="ln412"> </a>
<a name="ln413">    return false;</a>
<a name="ln414">}</a>
<a name="ln415"> </a>
<a name="ln416">static void _xom_checks_damage(kill_method_type death_type,</a>
<a name="ln417">                               int dam, mid_t death_source)</a>
<a name="ln418">{</a>
<a name="ln419">    if (you_worship(GOD_XOM))</a>
<a name="ln420">    {</a>
<a name="ln421">        if (death_type == KILLED_BY_TARGETING</a>
<a name="ln422">            || death_type == KILLED_BY_BOUNCE</a>
<a name="ln423">            || death_type == KILLED_BY_REFLECTION</a>
<a name="ln424">            || death_type == KILLED_BY_SELF_AIMED</a>
<a name="ln425">               &amp;&amp; player_in_a_dangerous_place())</a>
<a name="ln426">        {</a>
<a name="ln427">            // Xom thinks the player accidentally hurting him/herself is funny.</a>
<a name="ln428">            // Deliberate damage is only amusing if it's dangerous.</a>
<a name="ln429">            int amusement = 200 * dam / (dam + you.hp);</a>
<a name="ln430">            if (death_type == KILLED_BY_SELF_AIMED)</a>
<a name="ln431">                amusement /= 5;</a>
<a name="ln432">            xom_is_stimulated(amusement);</a>
<a name="ln433">            return;</a>
<a name="ln434">        }</a>
<a name="ln435">        else if (death_type == KILLED_BY_FALLING_DOWN_STAIRS</a>
<a name="ln436">                 || death_type == KILLED_BY_FALLING_THROUGH_GATE)</a>
<a name="ln437">        {</a>
<a name="ln438">            // Xom thinks falling down the stairs is hilarious.</a>
<a name="ln439">            xom_is_stimulated(200);</a>
<a name="ln440">            return;</a>
<a name="ln441">        }</a>
<a name="ln442">        else if (death_type == KILLED_BY_DISINT)</a>
<a name="ln443">        {</a>
<a name="ln444">            // flying chunks...</a>
<a name="ln445">            xom_is_stimulated(100);</a>
<a name="ln446">            return;</a>
<a name="ln447">        }</a>
<a name="ln448">        else if (death_type != KILLED_BY_MONSTER</a>
<a name="ln449">                    &amp;&amp; death_type != KILLED_BY_BEAM</a>
<a name="ln450">                    &amp;&amp; death_type != KILLED_BY_DISINT</a>
<a name="ln451">                 || !monster_by_mid(death_source))</a>
<a name="ln452">        {</a>
<a name="ln453">            return;</a>
<a name="ln454">        }</a>
<a name="ln455"> </a>
<a name="ln456">        int amusementvalue = 1;</a>
<a name="ln457">        const monster* mons = monster_by_mid(death_source);</a>
<a name="ln458"> </a>
<a name="ln459">        if (!mons-&gt;alive())</a>
<a name="ln460">            return;</a>
<a name="ln461"> </a>
<a name="ln462">        if (mons-&gt;wont_attack())</a>
<a name="ln463">        {</a>
<a name="ln464">            // Xom thinks collateral damage is funny.</a>
<a name="ln465">            xom_is_stimulated(200 * dam / (dam + you.hp));</a>
<a name="ln466">            return;</a>
<a name="ln467">        }</a>
<a name="ln468"> </a>
<a name="ln469">        int leveldif = mons-&gt;get_experience_level() - you.experience_level;</a>
<a name="ln470">        if (leveldif == 0)</a>
<a name="ln471">            leveldif = 1;</a>
<a name="ln472"> </a>
<a name="ln473">        // Note that Xom is amused when you are significantly hurt by a</a>
<a name="ln474">        // creature of higher level than yourself, as well as by a</a>
<a name="ln475">        // creature of lower level than yourself.</a>
<a name="ln476">        amusementvalue += leveldif * leveldif * dam;</a>
<a name="ln477"> </a>
<a name="ln478">        if (!mons-&gt;visible_to(&amp;you))</a>
<a name="ln479">            amusementvalue += 8;</a>
<a name="ln480"> </a>
<a name="ln481">        if (mons-&gt;speed &lt; 100/player_movement_speed())</a>
<a name="ln482">            amusementvalue += 7;</a>
<a name="ln483"> </a>
<a name="ln484">        if (player_in_a_dangerous_place())</a>
<a name="ln485">            amusementvalue += 2;</a>
<a name="ln486"> </a>
<a name="ln487">        amusementvalue /= (you.hp &gt; 0) ? you.hp : 1;</a>
<a name="ln488"> </a>
<a name="ln489">        xom_is_stimulated(amusementvalue);</a>
<a name="ln490">    }</a>
<a name="ln491">}</a>
<a name="ln492"> </a>
<a name="ln493">static void _yred_mirrors_injury(int dam, mid_t death_source)</a>
<a name="ln494">{</a>
<a name="ln495">    if (yred_injury_mirror())</a>
<a name="ln496">    {</a>
<a name="ln497">        // Cap damage to what was enough to kill you. Can matter if</a>
<a name="ln498">        // Yred saves your life or you have an extra kitty.</a>
<a name="ln499">        if (you.hp &lt; 0)</a>
<a name="ln500">            dam += you.hp;</a>
<a name="ln501"> </a>
<a name="ln502">        monster* mons = monster_by_mid(death_source);</a>
<a name="ln503">        if (dam &lt;= 0 || !mons)</a>
<a name="ln504">            return;</a>
<a name="ln505"> </a>
<a name="ln506">        mirror_damage_fineff::schedule(mons, &amp;you, dam);</a>
<a name="ln507">    }</a>
<a name="ln508">}</a>
<a name="ln509"> </a>
<a name="ln510">static void _maybe_ru_retribution(int dam, mid_t death_source)</a>
<a name="ln511">{</a>
<a name="ln512">    if (will_ru_retaliate())</a>
<a name="ln513">    {</a>
<a name="ln514">        // Cap damage to what was enough to kill you. Can matter if</a>
<a name="ln515">        // you have an extra kitty.</a>
<a name="ln516">        if (you.hp &lt; 0)</a>
<a name="ln517">            dam += you.hp;</a>
<a name="ln518"> </a>
<a name="ln519">        monster* mons = monster_by_mid(death_source);</a>
<a name="ln520">        if (dam &lt;= 0 || !mons)</a>
<a name="ln521">            return;</a>
<a name="ln522"> </a>
<a name="ln523">        ru_retribution_fineff::schedule(mons, &amp;you, dam);</a>
<a name="ln524">    }</a>
<a name="ln525">}</a>
<a name="ln526"> </a>
<a name="ln527">static void _maybe_spawn_monsters(int dam, kill_method_type death_type,</a>
<a name="ln528">                                  mid_t death_source)</a>
<a name="ln529">{</a>
<a name="ln530">    monster* damager = monster_by_mid(death_source);</a>
<a name="ln531">    // We need to exclude acid damage and similar things or this function</a>
<a name="ln532">    // will crash later.</a>
<a name="ln533">    if (!damager)</a>
<a name="ln534">        return;</a>
<a name="ln535"> </a>
<a name="ln536">    monster_type mon;</a>
<a name="ln537">    int how_many = 0;</a>
<a name="ln538"> </a>
<a name="ln539">    if (have_passive(passive_t::spawn_slimes_on_hit))</a>
<a name="ln540">    {</a>
<a name="ln541">        mon = royal_jelly_ejectable_monster();</a>
<a name="ln542">        if (dam &gt;= you.hp_max * 3 / 4)</a>
<a name="ln543">            how_many = random2(4) + 2;</a>
<a name="ln544">        else if (dam &gt;= you.hp_max / 2)</a>
<a name="ln545">            how_many = random2(2) + 2;</a>
<a name="ln546">        else if (dam &gt;= you.hp_max / 4)</a>
<a name="ln547">            how_many = 1;</a>
<a name="ln548">    }</a>
<a name="ln549">    else if (you_worship(GOD_XOM)</a>
<a name="ln550">             &amp;&amp; dam &gt;= you.hp_max / 4</a>
<a name="ln551">             &amp;&amp; x_chance_in_y(dam, 3 * you.hp_max))</a>
<a name="ln552">    {</a>
<a name="ln553">        mon = MONS_BUTTERFLY;</a>
<a name="ln554">        how_many = 2 + random2(5);</a>
<a name="ln555">    }</a>
<a name="ln556"> </a>
<a name="ln557">    if (how_many &gt; 0)</a>
<a name="ln558">    {</a>
<a name="ln559">        int count_created = 0;</a>
<a name="ln560">        for (int i = 0; i &lt; how_many; ++i)</a>
<a name="ln561">        {</a>
<a name="ln562">            mgen_data mg(mon, BEH_FRIENDLY, you.pos(), damager-&gt;mindex());</a>
<a name="ln563">            mg.set_summoned(&amp;you, 2, 0, you.religion);</a>
<a name="ln564"> </a>
<a name="ln565">            if (create_monster(mg))</a>
<a name="ln566">                count_created++;</a>
<a name="ln567">        }</a>
<a name="ln568"> </a>
<a name="ln569">        if (count_created &gt; 0)</a>
<a name="ln570">        {</a>
<a name="ln571">            if (mon == MONS_BUTTERFLY)</a>
<a name="ln572">            {</a>
<a name="ln573">                mprf(MSGCH_GOD, &quot;A shower of butterflies erupts from you!&quot;);</a>
<a name="ln574">                take_note(Note(NOTE_XOM_EFFECT, you.piety, -1, &quot;butterfly on damage&quot;), true);</a>
<a name="ln575">            }</a>
<a name="ln576">            else</a>
<a name="ln577">            {</a>
<a name="ln578">                mprf(&quot;You shudder from the %s and a %s!&quot;,</a>
<a name="ln579">                     death_type == KILLED_BY_MONSTER ? &quot;blow&quot; : &quot;blast&quot;,</a>
<a name="ln580">                     count_created &gt; 1 ? &quot;flood of jellies pours out from you&quot;</a>
<a name="ln581">                                       : &quot;jelly pops out&quot;);</a>
<a name="ln582">            }</a>
<a name="ln583">        }</a>
<a name="ln584">    }</a>
<a name="ln585">}</a>
<a name="ln586"> </a>
<a name="ln587">static void _powered_by_pain(int dam)</a>
<a name="ln588">{</a>
<a name="ln589">    const int level = you.get_mutation_level(MUT_POWERED_BY_PAIN);</a>
<a name="ln590"> </a>
<a name="ln591">    if (level &gt; 0</a>
<a name="ln592">        &amp;&amp; (random2(dam) &gt; 4 + div_rand_round(you.experience_level, 4)</a>
<a name="ln593">            || dam &gt;= you.hp_max / 2))</a>
<a name="ln594">    {</a>
<a name="ln595">        switch (random2(4))</a>
<a name="ln596">        {</a>
<a name="ln597">        case 0:</a>
<a name="ln598">        case 1:</a>
<a name="ln599">        {</a>
<a name="ln600">            if (you.magic_points &lt; you.max_magic_points)</a>
<a name="ln601">            {</a>
<a name="ln602">                mpr(&quot;You focus on the pain.&quot;);</a>
<a name="ln603">                int mp = roll_dice(3, 2 + 3 * level);</a>
<a name="ln604">                canned_msg(MSG_GAIN_MAGIC);</a>
<a name="ln605">                inc_mp(mp);</a>
<a name="ln606">                break;</a>
<a name="ln607">            }</a>
<a name="ln608">            break;</a>
<a name="ln609">        }</a>
<a name="ln610">        case 2:</a>
<a name="ln611">            mpr(&quot;You focus on the pain.&quot;);</a>
<a name="ln612">            potionlike_effect(POT_MIGHT, level * 20);</a>
<a name="ln613">            break;</a>
<a name="ln614">        case 3:</a>
<a name="ln615">            mpr(&quot;You focus on the pain.&quot;);</a>
<a name="ln616">            you.be_agile(level * 20);</a>
<a name="ln617">            break;</a>
<a name="ln618">        }</a>
<a name="ln619">    }</a>
<a name="ln620">}</a>
<a name="ln621"> </a>
<a name="ln622">static void _maybe_fog(int dam)</a>
<a name="ln623">{</a>
<a name="ln624">    const int minpiety = have_passive(passive_t::hit_smoke)</a>
<a name="ln625">        ? piety_breakpoint(rank_for_passive(passive_t::hit_smoke) - 1)</a>
<a name="ln626">        : piety_breakpoint(2); // Xom</a>
<a name="ln627"> </a>
<a name="ln628">    const int upper_threshold = you.hp_max / 2;</a>
<a name="ln629">    const int lower_threshold = upper_threshold</a>
<a name="ln630">                                - upper_threshold</a>
<a name="ln631">                                  * (you.piety - minpiety)</a>
<a name="ln632">                                  / (MAX_PIETY - minpiety);</a>
<a name="ln633">    if (have_passive(passive_t::hit_smoke)</a>
<a name="ln634">        &amp;&amp; (dam &gt; 0 &amp;&amp; you.form == transformation::shadow</a>
<a name="ln635">            || dam &gt;= lower_threshold</a>
<a name="ln636">               &amp;&amp; x_chance_in_y(dam - lower_threshold,</a>
<a name="ln637">                                upper_threshold - lower_threshold)))</a>
<a name="ln638">    {</a>
<a name="ln639">        mpr(&quot;You emit a cloud of dark smoke.&quot;);</a>
<a name="ln640">        big_cloud(CLOUD_BLACK_SMOKE, &amp;you, you.pos(), 50, 4 + random2(5));</a>
<a name="ln641">    }</a>
<a name="ln642">    else if (you_worship(GOD_XOM) &amp;&amp; x_chance_in_y(dam, 30 * upper_threshold))</a>
<a name="ln643">    {</a>
<a name="ln644">        mprf(MSGCH_GOD, &quot;You emit a cloud of colourful smoke!&quot;);</a>
<a name="ln645">        big_cloud(CLOUD_XOM_TRAIL, &amp;you, you.pos(), 50, 4 + random2(5), -1);</a>
<a name="ln646">        take_note(Note(NOTE_XOM_EFFECT, you.piety, -1, &quot;smoke on damage&quot;), true);</a>
<a name="ln647">    }</a>
<a name="ln648">}</a>
<a name="ln649"> </a>
<a name="ln650">static void _deteriorate(int dam)</a>
<a name="ln651">{</a>
<a name="ln652">    if (x_chance_in_y(you.get_mutation_level(MUT_DETERIORATION), 4)</a>
<a name="ln653">        &amp;&amp; dam &gt; you.hp_max / 10)</a>
<a name="ln654">    {</a>
<a name="ln655">        mprf(MSGCH_WARN, &quot;Your body deteriorates!&quot;);</a>
<a name="ln656">        lose_stat(STAT_RANDOM, 1);</a>
<a name="ln657">    }</a>
<a name="ln658">}</a>
<a name="ln659"> </a>
<a name="ln660">/**</a>
<a name="ln661"> * Maybe corrode the player after taking damage if they're wearing *Corrode.</a>
<a name="ln662"> **/</a>
<a name="ln663">static void _maybe_corrode()</a>
<a name="ln664">{</a>
<a name="ln665">    int corrosion_sources = you.scan_artefacts(ARTP_CORRODE);</a>
<a name="ln666">    int degree = binomial(corrosion_sources, 3);</a>
<a name="ln667">    if (degree &gt; 0)</a>
<a name="ln668">        you.corrode_equipment(&quot;Your corrosive artefact&quot;, degree);</a>
<a name="ln669">}</a>
<a name="ln670"> </a>
<a name="ln671">/**</a>
<a name="ln672"> * Maybe slow the player after taking damage if they're wearing *Slow.</a>
<a name="ln673"> **/</a>
<a name="ln674">static void _maybe_slow()</a>
<a name="ln675">{</a>
<a name="ln676">    int slow_sources = you.scan_artefacts(ARTP_SLOW);</a>
<a name="ln677">    if (x_chance_in_y(slow_sources, 100))</a>
<a name="ln678">        slow_player(10 + random2(5));</a>
<a name="ln679">}</a>
<a name="ln680"> </a>
<a name="ln681">static void _place_player_corpse(bool explode)</a>
<a name="ln682">{</a>
<a name="ln683">    if (!in_bounds(you.pos()))</a>
<a name="ln684">        return;</a>
<a name="ln685"> </a>
<a name="ln686">    monster dummy;</a>
<a name="ln687">    dummy.type = player_mons(false);</a>
<a name="ln688">    define_monster(dummy); // assumes player_mons is not a zombie</a>
<a name="ln689">    dummy.position = you.pos();</a>
<a name="ln690">    dummy.props[&quot;always_corpse&quot;] = true;</a>
<a name="ln691">    dummy.mname = you.your_name;</a>
<a name="ln692">    dummy.set_hit_dice(you.experience_level);</a>
<a name="ln693">    if (explode)</a>
<a name="ln694">        dummy.flags &amp;= MF_EXPLODE_KILL;</a>
<a name="ln695"> </a>
<a name="ln696">    if (you.form != transformation::none)</a>
<a name="ln697">        mpr(&quot;Your shape twists and changes as you die.&quot;);</a>
<a name="ln698"> </a>
<a name="ln699">    place_monster_corpse(dummy, false);</a>
<a name="ln700">}</a>
<a name="ln701"> </a>
<a name="ln702">#if defined(WIZARD) || defined(DEBUG)</a>
<a name="ln703">static void _wizard_restore_life()</a>
<a name="ln704">{</a>
<a name="ln705">    if (you.hp_max &lt;= 0)</a>
<a name="ln706">        unrot_hp(9999);</a>
<a name="ln707">    while (you.hp_max &lt;= 0)</a>
<a name="ln708">        you.hp_max_adj_perm++, calc_hp();</a>
<a name="ln709">    if (you.hp &lt;= 0)</a>
<a name="ln710">        set_hp(you.hp_max);</a>
<a name="ln711">}</a>
<a name="ln712">#endif</a>
<a name="ln713"> </a>
<a name="ln714">static int _apply_extra_harm(int dam, mid_t source)</a>
<a name="ln715">{</a>
<a name="ln716">    monster* damager = monster_by_mid(source);</a>
<a name="ln717">    // Don't check for monster amulet if there source isn't a monster</a>
<a name="ln718">    if (damager &amp;&amp; damager-&gt;extra_harm())</a>
<a name="ln719">        return dam * 13 / 10; // +30% damage when the opponent has harm</a>
<a name="ln720">    else if (you.extra_harm())</a>
<a name="ln721">        return dam * 6 / 5; // +20% damage when you have harm</a>
<a name="ln722"> </a>
<a name="ln723">    return dam;</a>
<a name="ln724">}</a>
<a name="ln725"> </a>
<a name="ln726">void reset_damage_counters()</a>
<a name="ln727">{</a>
<a name="ln728">    you.turn_damage = 0;</a>
<a name="ln729">    you.damage_source = NON_MONSTER;</a>
<a name="ln730">    you.source_damage = 0;</a>
<a name="ln731">}</a>
<a name="ln732"> </a>
<a name="ln733">bool can_shave_damage()</a>
<a name="ln734">{</a>
<a name="ln735">    return you.species == SP_DEEP_DWARF;</a>
<a name="ln736">}</a>
<a name="ln737"> </a>
<a name="ln738">int do_shave_damage(int dam)</a>
<a name="ln739">{</a>
<a name="ln740">    if (!can_shave_damage())</a>
<a name="ln741">        return dam;</a>
<a name="ln742"> </a>
<a name="ln743">    // Deep Dwarves get to shave any hp loss.</a>
<a name="ln744">    int shave = 1 + random2(2 + random2(1 + you.experience_level / 3));</a>
<a name="ln745">    dprf(&quot;HP shaved: %d.&quot;, shave);</a>
<a name="ln746">    dam -= shave;</a>
<a name="ln747"> </a>
<a name="ln748">    return dam;</a>
<a name="ln749">}</a>
<a name="ln750"> </a>
<a name="ln751">// Determine what's threatening for purposes of sacrifice drink and reading.</a>
<a name="ln752">// the statuses are guaranteed not to happen if the incoming damage is less</a>
<a name="ln753">// than 4% max hp. Otherwise, they scale up with damage taken and with lower</a>
<a name="ln754">// health, becoming certain at 20% max health damage or &lt;30% max health</a>
<a name="ln755">// current hp.</a>
<a name="ln756">static bool _is_damage_threatening (int damage_fraction_of_hp)</a>
<a name="ln757">{</a>
<a name="ln758">    int hp_fraction = you.hp * 100 / you.hp_max;</a>
<a name="ln759">    return damage_fraction_of_hp &gt; 5</a>
<a name="ln760">            &amp;&amp; hp_fraction &lt;= 85</a>
<a name="ln761">            &amp;&amp; (damage_fraction_of_hp + random2(20) &gt;= 20</a>
<a name="ln762">                || random2(100) &lt; hp_fraction);</a>
<a name="ln763">}</a>
<a name="ln764"> </a>
<a name="ln765">/** Hurt the player. Isn't it fun?</a>
<a name="ln766"> *</a>
<a name="ln767"> *  @param dam How much damage -- may be INSTANT_DEATH.</a>
<a name="ln768"> *  @param death_type how did you get hurt?</a>
<a name="ln769"> *  @param source who could do such a thing?</a>
<a name="ln770"> *  @param aux what did they do it with?</a>
<a name="ln771"> *  @param see_source whether the attacker was visible to you</a>
<a name="ln772"> *  @param death_source_name the attacker's name if it is already dead.</a>
<a name="ln773"> */</a>
<a name="ln774">void ouch(int dam, kill_method_type death_type, mid_t source, const char *aux,</a>
<a name="ln775">          bool see_source, const char *death_source_name)</a>
<a name="ln776">{</a>
<a name="ln777">    ASSERT(!crawl_state.game_is_arena());</a>
<a name="ln778">    if (you.duration[DUR_TIME_STEP])</a>
<a name="ln779">        return;</a>
<a name="ln780"> </a>
<a name="ln781">    if (you.pending_revival)</a>
<a name="ln782">        return;</a>
<a name="ln783"> </a>
<a name="ln784">    int drain_amount = 0;</a>
<a name="ln785"> </a>
<a name="ln786">    // Multiply damage if amulet of harm is in play</a>
<a name="ln787">    if (dam != INSTANT_DEATH)</a>
<a name="ln788">        dam = _apply_extra_harm(dam, source);</a>
<a name="ln789"> </a>
<a name="ln790">    if (can_shave_damage() &amp;&amp; dam != INSTANT_DEATH</a>
<a name="ln791">        &amp;&amp; death_type != KILLED_BY_POISON)</a>
<a name="ln792">    {</a>
<a name="ln793">        dam = max(0, do_shave_damage(dam));</a>
<a name="ln794">    }</a>
<a name="ln795"> </a>
<a name="ln796">    if (dam != INSTANT_DEATH)</a>
<a name="ln797">    {</a>
<a name="ln798">        if (you.form == transformation::shadow)</a>
<a name="ln799">        {</a>
<a name="ln800">            drain_amount = (dam - (dam / 2));</a>
<a name="ln801">            dam /= 2;</a>
<a name="ln802">        }</a>
<a name="ln803">        if (you.petrified())</a>
<a name="ln804">            dam /= 2;</a>
<a name="ln805">        else if (you.petrifying())</a>
<a name="ln806">            dam = dam * 10 / 15;</a>
<a name="ln807">    }</a>
<a name="ln808">    ait_hp_loss hpl(dam, death_type);</a>
<a name="ln809">    interrupt_activity(activity_interrupt::hp_loss, &amp;hpl);</a>
<a name="ln810"> </a>
<a name="ln811">    // Don't wake the player with fatal or poison damage.</a>
<a name="ln812">    if (dam &gt; 0 &amp;&amp; dam &lt; you.hp &amp;&amp; death_type != KILLED_BY_POISON)</a>
<a name="ln813">        you.check_awaken(500);</a>
<a name="ln814"> </a>
<a name="ln815">    const bool non_death = death_type == KILLED_BY_QUITTING</a>
<a name="ln816">                        || death_type == KILLED_BY_WINNING</a>
<a name="ln817">                        || death_type == KILLED_BY_LEAVING;</a>
<a name="ln818"> </a>
<a name="ln819">    // certain effects (e.g. drowned souls) use KILLED_BY_WATER for flavour</a>
<a name="ln820">    // reasons (morgue messages?), with regrettable consequences if we don't</a>
<a name="ln821">    // double-check.</a>
<a name="ln822">    const bool env_death = source == MID_NOBODY</a>
<a name="ln823">                           &amp;&amp; (death_type == KILLED_BY_LAVA</a>
<a name="ln824">                               || death_type == KILLED_BY_WATER);</a>
<a name="ln825"> </a>
<a name="ln826">    // death's door protects against everything but falling into water/lava,</a>
<a name="ln827">    // excessive rot, leaving the dungeon, or quitting.</a>
<a name="ln828">    if (you.duration[DUR_DEATHS_DOOR] &amp;&amp; !env_death &amp;&amp; !non_death</a>
<a name="ln829">        &amp;&amp; you.hp_max &gt; 0)</a>
<a name="ln830">    {</a>
<a name="ln831">        return;</a>
<a name="ln832">    }</a>
<a name="ln833"> </a>
<a name="ln834">    if (dam &gt; 0 &amp;&amp; death_type != KILLED_BY_POISON)</a>
<a name="ln835">    {</a>
<a name="ln836">        int damage_fraction_of_hp = dam * 100 / you.hp_max;</a>
<a name="ln837"> </a>
<a name="ln838">        // Check _is_damage_threatening separately for read and drink so they</a>
<a name="ln839">        // don't always trigger in unison when you have both.</a>
<a name="ln840">        if (you.get_mutation_level(MUT_NO_READ))</a>
<a name="ln841">        {</a>
<a name="ln842">            if (_is_damage_threatening(damage_fraction_of_hp))</a>
<a name="ln843">            {</a>
<a name="ln844">                if (!you.duration[DUR_NO_SCROLLS])</a>
<a name="ln845">                    mpr(&quot;You feel threatened and lose the ability to read scrolls!&quot;);</a>
<a name="ln846"> </a>
<a name="ln847">                you.increase_duration(DUR_NO_SCROLLS, 1 + random2(dam), 30);</a>
<a name="ln848">            }</a>
<a name="ln849">        }</a>
<a name="ln850"> </a>
<a name="ln851">        if (you.get_mutation_level(MUT_NO_DRINK))</a>
<a name="ln852">        {</a>
<a name="ln853">            if (_is_damage_threatening(damage_fraction_of_hp))</a>
<a name="ln854">            {</a>
<a name="ln855">                if (!you.duration[DUR_NO_POTIONS])</a>
<a name="ln856">                    mpr(&quot;You feel threatened and lose the ability to drink potions!&quot;);</a>
<a name="ln857"> </a>
<a name="ln858">                you.increase_duration(DUR_NO_POTIONS, 1 + random2(dam), 30);</a>
<a name="ln859">            }</a>
<a name="ln860">        }</a>
<a name="ln861">    }</a>
<a name="ln862"> </a>
<a name="ln863">    if (dam != INSTANT_DEATH)</a>
<a name="ln864">    {</a>
<a name="ln865">        if (you.spirit_shield() &amp;&amp; death_type != KILLED_BY_POISON</a>
<a name="ln866">            &amp;&amp; !(aux &amp;&amp; strstr(aux, &quot;flay_damage&quot;)))</a>
<a name="ln867">        {</a>
<a name="ln868">            // round off fairly (important for taking 1 damage at a time)</a>
<a name="ln869">            int mp = div_rand_round(dam * you.magic_points,</a>
<a name="ln870">                                    max(you.hp + you.magic_points, 1));</a>
<a name="ln871">            // but don't kill the player with round-off errors</a>
<a name="ln872">            mp = max(mp, dam + 1 - you.hp);</a>
<a name="ln873">            mp = min(mp, you.magic_points);</a>
<a name="ln874"> </a>
<a name="ln875">            dam -= mp;</a>
<a name="ln876">            dec_mp(mp);</a>
<a name="ln877"> </a>
<a name="ln878">            // Wake players who took fatal damage exactly equal to current HP,</a>
<a name="ln879">            // but had it reduced below fatal threshhold by spirit shield.</a>
<a name="ln880">            if (dam &lt; you.hp)</a>
<a name="ln881">                you.check_awaken(500);</a>
<a name="ln882"> </a>
<a name="ln883">            if (dam &lt;= 0 &amp;&amp; you.hp &gt; 0)</a>
<a name="ln884">                return;</a>
<a name="ln885">        }</a>
<a name="ln886"> </a>
<a name="ln887">        if (dam &gt;= you.hp &amp;&amp; you.hp_max &gt; 0 &amp;&amp; god_protects_from_harm())</a>
<a name="ln888">        {</a>
<a name="ln889">            simple_god_message(&quot; protects you from harm!&quot;);</a>
<a name="ln890">            // Ensure divine intervention wakes sleeping players. Necessary</a>
<a name="ln891">            // because we otherwise don't wake players who take fatal damage.</a>
<a name="ln892">            you.check_awaken(500);</a>
<a name="ln893">            return;</a>
<a name="ln894">        }</a>
<a name="ln895"> </a>
<a name="ln896">        you.turn_damage += dam;</a>
<a name="ln897">        if (you.damage_source != source)</a>
<a name="ln898">        {</a>
<a name="ln899">            you.damage_source = source;</a>
<a name="ln900">            you.source_damage = 0;</a>
<a name="ln901">        }</a>
<a name="ln902">        you.source_damage += dam;</a>
<a name="ln903"> </a>
<a name="ln904">        dec_hp(dam, true);</a>
<a name="ln905"> </a>
<a name="ln906">        // Even if we have low HP messages off, we'll still give a</a>
<a name="ln907">        // big hit warning (in this case, a hit for half our HPs) -- bwr</a>
<a name="ln908">        if (dam &gt; 0 &amp;&amp; you.hp_max &lt;= dam * 2)</a>
<a name="ln909">            mprf(MSGCH_DANGER, &quot;Ouch! That really hurt!&quot;);</a>
<a name="ln910"> </a>
<a name="ln911">        if (you.hp &gt; 0 &amp;&amp; dam &gt; 0)</a>
<a name="ln912">        {</a>
<a name="ln913">            if (Options.hp_warning</a>
<a name="ln914">                &amp;&amp; you.hp &lt;= (you.hp_max * Options.hp_warning) / 100</a>
<a name="ln915">                &amp;&amp; (death_type != KILLED_BY_POISON || poison_is_lethal()))</a>
<a name="ln916">            {</a>
<a name="ln917">                flash_view_delay(UA_HP, RED, 50);</a>
<a name="ln918">                mprf(MSGCH_DANGER, &quot;* * * LOW HITPOINT WARNING * * *&quot;);</a>
<a name="ln919">                dungeon_events.fire_event(DET_HP_WARNING);</a>
<a name="ln920">            }</a>
<a name="ln921"> </a>
<a name="ln922">            hints_healing_check();</a>
<a name="ln923"> </a>
<a name="ln924">            _xom_checks_damage(death_type, dam, source);</a>
<a name="ln925"> </a>
<a name="ln926">            // for note taking</a>
<a name="ln927">            string damage_desc;</a>
<a name="ln928">            if (!see_source)</a>
<a name="ln929">                damage_desc = make_stringf(&quot;something (%d)&quot;, dam);</a>
<a name="ln930">            else</a>
<a name="ln931">            {</a>
<a name="ln932">                damage_desc = scorefile_entry(dam, source,</a>
<a name="ln933">                                              death_type, aux, true)</a>
<a name="ln934">                    .death_description(scorefile_entry::DDV_TERSE);</a>
<a name="ln935">            }</a>
<a name="ln936"> </a>
<a name="ln937">            take_note(Note(NOTE_HP_CHANGE, you.hp, you.hp_max,</a>
<a name="ln938">                           damage_desc.c_str()));</a>
<a name="ln939"> </a>
<a name="ln940">            _deteriorate(dam);</a>
<a name="ln941">            _yred_mirrors_injury(dam, source);</a>
<a name="ln942">            _maybe_ru_retribution(dam, source);</a>
<a name="ln943">            _maybe_spawn_monsters(dam, death_type, source);</a>
<a name="ln944">            _maybe_fog(dam);</a>
<a name="ln945">            _powered_by_pain(dam);</a>
<a name="ln946">            if (sanguine_armour_valid())</a>
<a name="ln947">                activate_sanguine_armour();</a>
<a name="ln948">            if (death_type != KILLED_BY_POISON)</a>
<a name="ln949">            {</a>
<a name="ln950">                _maybe_corrode();</a>
<a name="ln951">                _maybe_slow();</a>
<a name="ln952">            }</a>
<a name="ln953">            if (drain_amount &gt; 0)</a>
<a name="ln954">                drain_player(drain_amount, true, true);</a>
<a name="ln955">        }</a>
<a name="ln956">        if (you.hp &gt; 0)</a>
<a name="ln957">          return;</a>
<a name="ln958">    }</a>
<a name="ln959"> </a>
<a name="ln960">    // Is the player being killed by a direct act of Xom?</a>
<a name="ln961">    if (crawl_state.is_god_acting()</a>
<a name="ln962">        &amp;&amp; crawl_state.which_god_acting() == GOD_XOM</a>
<a name="ln963">        &amp;&amp; crawl_state.other_gods_acting().empty())</a>
<a name="ln964">    {</a>
<a name="ln965">        you.escaped_death_cause = death_type;</a>
<a name="ln966">        you.escaped_death_aux   = aux == nullptr ? &quot;&quot; : aux;</a>
<a name="ln967"> </a>
<a name="ln968">        // Xom should only kill his worshippers if they're under penance</a>
<a name="ln969">        // or Xom is bored.</a>
<a name="ln970">        if (you_worship(GOD_XOM) &amp;&amp; !you.penance[GOD_XOM]</a>
<a name="ln971">            &amp;&amp; you.gift_timeout &gt; 0)</a>
<a name="ln972">        {</a>
<a name="ln973">            return;</a>
<a name="ln974">        }</a>
<a name="ln975"> </a>
<a name="ln976">        // Also don't kill wizards testing Xom acts.</a>
<a name="ln977">        if ((crawl_state.repeat_cmd == CMD_WIZARD</a>
<a name="ln978">                || crawl_state.prev_cmd == CMD_WIZARD)</a>
<a name="ln979">            &amp;&amp; !you_worship(GOD_XOM))</a>
<a name="ln980">        {</a>
<a name="ln981">            return;</a>
<a name="ln982">        }</a>
<a name="ln983"> </a>
<a name="ln984">        // Okay, you *didn't* escape death.</a>
<a name="ln985">        you.reset_escaped_death();</a>
<a name="ln986"> </a>
<a name="ln987">        // Ensure some minimal information about Xom's involvement.</a>
<a name="ln988">        if (aux == nullptr || !*aux)</a>
<a name="ln989">        {</a>
<a name="ln990">            if (death_type != KILLED_BY_XOM)</a>
<a name="ln991">                aux = &quot;Xom&quot;;</a>
<a name="ln992">        }</a>
<a name="ln993">        else if (strstr(aux, &quot;Xom&quot;) == nullptr)</a>
<a name="ln994">            death_type = KILLED_BY_XOM;</a>
<a name="ln995">    }</a>
<a name="ln996">    // Xom may still try to save your life.</a>
<a name="ln997">    else if (xom_saves_your_life(death_type))</a>
<a name="ln998">        return;</a>
<a name="ln999"> </a>
<a name="ln1000">#if defined(WIZARD) || defined(DEBUG)</a>
<a name="ln1001">    if (!non_death &amp;&amp; crawl_state.disables[DIS_DEATH])</a>
<a name="ln1002">    {</a>
<a name="ln1003">        _wizard_restore_life();</a>
<a name="ln1004">        return;</a>
<a name="ln1005">    }</a>
<a name="ln1006">#endif</a>
<a name="ln1007"> </a>
<a name="ln1008">    crawl_state.cancel_cmd_all();</a>
<a name="ln1009"> </a>
<a name="ln1010">    // Construct scorefile entry.</a>
<a name="ln1011">    scorefile_entry se(dam, source, death_type, aux, false,</a>
<a name="ln1012">                       death_source_name);</a>
<a name="ln1013"> </a>
<a name="ln1014">#ifdef WIZARD</a>
<a name="ln1015">    if (!non_death)</a>
<a name="ln1016">    {</a>
<a name="ln1017">        if (crawl_state.test || you.wizard || you.suppress_wizard || (you.explore &amp;&amp; !you.lives))</a>
<a name="ln1018">        {</a>
<a name="ln1019">            const string death_desc</a>
<a name="ln1020">                = se.death_description(scorefile_entry::DDV_VERBOSE);</a>
<a name="ln1021"> </a>
<a name="ln1022">            dprf(&quot;Damage: %d; Hit points: %d&quot;, dam, you.hp);</a>
<a name="ln1023"> </a>
<a name="ln1024">            if (crawl_state.test || !yesno(&quot;Die?&quot;, false, 'n'))</a>
<a name="ln1025">            {</a>
<a name="ln1026">                mpr(&quot;Thought so.&quot;);</a>
<a name="ln1027">                take_note(Note(NOTE_DEATH, you.hp, you.hp_max,</a>
<a name="ln1028">                                death_desc.c_str()), true);</a>
<a name="ln1029">                _wizard_restore_life();</a>
<a name="ln1030">                return;</a>
<a name="ln1031">            }</a>
<a name="ln1032">        }</a>
<a name="ln1033">    }</a>
<a name="ln1034">#endif  // WIZARD</a>
<a name="ln1035"> </a>
<a name="ln1036">    if (crawl_state.game_is_tutorial())</a>
<a name="ln1037">    {</a>
<a name="ln1038">        crawl_state.need_save = false;</a>
<a name="ln1039">        if (!non_death)</a>
<a name="ln1040">            tutorial_death_message();</a>
<a name="ln1041"> </a>
<a name="ln1042">        screen_end_game(&quot;&quot;);</a>
<a name="ln1043">    }</a>
<a name="ln1044"> </a>
<a name="ln1045">    // Okay, so you're dead.</a>
<a name="ln1046">    take_note(Note(NOTE_DEATH, you.hp, you.hp_max,</a>
<a name="ln1047">                    se.death_description(scorefile_entry::DDV_NORMAL).c_str()),</a>
<a name="ln1048">              true);</a>
<a name="ln1049">    if (you.lives &amp;&amp; !non_death)</a>
<a name="ln1050">    {</a>
<a name="ln1051">        mark_milestone(&quot;death&quot;, lowercase_first(se.long_kill_message()).c_str());</a>
<a name="ln1052"> </a>
<a name="ln1053">        you.deaths++;</a>
<a name="ln1054">        you.lives--;</a>
<a name="ln1055">        you.pending_revival = true;</a>
<a name="ln1056"> </a>
<a name="ln1057">        stop_delay(true);</a>
<a name="ln1058"> </a>
<a name="ln1059">        // You wouldn't want to lose this accomplishment to a crash, would you?</a>
<a name="ln1060">        // Especially if you manage to trigger one via lua somehow...</a>
<a name="ln1061">        if (!crawl_state.disables[DIS_SAVE_CHECKPOINTS])</a>
<a name="ln1062">            save_game(false);</a>
<a name="ln1063"> </a>
<a name="ln1064">        canned_msg(MSG_YOU_DIE);</a>
<a name="ln1065">        xom_death_message((kill_method_type) se.get_death_type());</a>
<a name="ln1066">        more();</a>
<a name="ln1067"> </a>
<a name="ln1068">        _place_player_corpse(death_type == KILLED_BY_DISINT);</a>
<a name="ln1069">        return;</a>
<a name="ln1070">    }</a>
<a name="ln1071"> </a>
<a name="ln1072">    // Prevent bogus notes.</a>
<a name="ln1073">    activate_notes(false);</a>
<a name="ln1074"> </a>
<a name="ln1075">    end_game(se);</a>
<a name="ln1076">}</a>
<a name="ln1077"> </a>
<a name="ln1078">string morgue_name(string char_name, time_t when_crawl_got_even)</a>
<a name="ln1079">{</a>
<a name="ln1080">    string name = &quot;morgue-&quot; + char_name;</a>
<a name="ln1081"> </a>
<a name="ln1082">    string time = make_file_time(when_crawl_got_even);</a>
<a name="ln1083">    if (!time.empty())</a>
<a name="ln1084">        name += &quot;-&quot; + time;</a>
<a name="ln1085"> </a>
<a name="ln1086">    return name;</a>
<a name="ln1087">}</a>
<a name="ln1088"> </a>
<a name="ln1089">int actor_to_death_source(const actor* agent)</a>
<a name="ln1090">{</a>
<a name="ln1091">    return agent ? agent-&gt;mindex() : NON_MONSTER;</a>
<a name="ln1092">}</a>
<a name="ln1093"> </a>
<a name="ln1094">int timescale_damage(const actor *act, int damage)</a>
<a name="ln1095">{</a>
<a name="ln1096">    if (damage &lt; 0)</a>
<a name="ln1097">        damage = 0;</a>
<a name="ln1098">    // Can we have a uniform player/monster speed system yet?</a>
<a name="ln1099">    if (act-&gt;is_player())</a>
<a name="ln1100">        return div_rand_round(damage * you.time_taken, BASELINE_DELAY);</a>
<a name="ln1101">    else</a>
<a name="ln1102">    {</a>
<a name="ln1103">        const monster *mons = act-&gt;as_monster();</a>
<a name="ln1104">        const int speed = mons-&gt;speed &gt; 0? mons-&gt;speed : BASELINE_DELAY;</a>
<a name="ln1105">        return div_rand_round(damage * BASELINE_DELAY, speed);</a>
<a name="ln1106">    }</a>
<a name="ln1107">}</a>

</code></pre>
<div class="balloon" rel="155"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v1037/" target="_blank">V1037</a> Two or more case-branches perform the same actions. Check lines: 155, 234</p></div>
<div class="balloon" rel="424"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v648/" target="_blank">V648</a> Priority of the '&&' operation is higher than that of the '||' operation.</p></div>
<div class="balloon" rel="450"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v560/" target="_blank">V560</a> A part of conditional expression is always true: death_type != KILLED_BY_DISINT.</p></div>

<link rel="stylesheet" href="highlight.css">
<script src="highlight.pack.js"></script>
<script src="highlightjs-line-numbers.js"></script>
<script>hljs.initHighlightingOnLoad();</script>
<script>hljs.initLineNumbersOnLoad();</script>
<script>
  $(document).ready(function() {
      $('.balloon').each(function () {
          var bl = $(this);
          var line = bl.attr('rel');
          var text = $('a[name="ln'+line+'"]').text();

          var space_count = 0;
          for(var i = 0; i<text.length; i++){
              var char = text[i];
              if((char !== ' ')&&(char !== '\t'))break;
              if(char === '\t')space_count++;
              space_count++;
          }

          bl.css('margin-left', space_count*8);
          $('a[name="ln'+line+'"]').after(bl);
      });

      window.location = window.location;
  });
</script>
</body>
</html>
