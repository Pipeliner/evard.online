
<html>
<head>

  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
  <title>item-name.cc</title>

  <link rel="stylesheet" href="../style.css"/>
  <script src="../jquery-3.2.1.min.js"></script>
</head>
<body>

<pre><code class = "cpp">
<a name="ln1">/**</a>
<a name="ln2"> * @file</a>
<a name="ln3"> * @brief Misc functions.</a>
<a name="ln4">**/</a>
<a name="ln5"> </a>
<a name="ln6">#include &quot;AppHdr.h&quot;</a>
<a name="ln7"> </a>
<a name="ln8">#include &quot;item-name.h&quot;</a>
<a name="ln9"> </a>
<a name="ln10">#include &lt;cctype&gt;</a>
<a name="ln11">#include &lt;cstring&gt;</a>
<a name="ln12">#include &lt;iomanip&gt;</a>
<a name="ln13">#include &lt;sstream&gt;</a>
<a name="ln14"> </a>
<a name="ln15">#include &quot;areas.h&quot;</a>
<a name="ln16">#include &quot;artefact.h&quot;</a>
<a name="ln17">#include &quot;art-enum.h&quot;</a>
<a name="ln18">#include &quot;branch.h&quot;</a>
<a name="ln19">#include &quot;cio.h&quot;</a>
<a name="ln20">#include &quot;colour.h&quot;</a>
<a name="ln21">#include &quot;decks.h&quot;</a>
<a name="ln22">#include &quot;describe.h&quot;</a>
<a name="ln23">#include &quot;dgn-overview.h&quot;</a>
<a name="ln24">#include &quot;english.h&quot;</a>
<a name="ln25">#include &quot;env.h&quot; // LSTATE_STILL_WINDS</a>
<a name="ln26">#include &quot;errors.h&quot; // sysfail</a>
<a name="ln27">#include &quot;food.h&quot;</a>
<a name="ln28">#include &quot;god-item.h&quot;</a>
<a name="ln29">#include &quot;god-passive.h&quot; // passive_t::want_curses, no_haste</a>
<a name="ln30">#include &quot;invent.h&quot;</a>
<a name="ln31">#include &quot;item-prop.h&quot;</a>
<a name="ln32">#include &quot;item-status-flag-type.h&quot;</a>
<a name="ln33">#include &quot;items.h&quot;</a>
<a name="ln34">#include &quot;item-use.h&quot;</a>
<a name="ln35">#include &quot;level-state-type.h&quot;</a>
<a name="ln36">#include &quot;libutil.h&quot;</a>
<a name="ln37">#include &quot;makeitem.h&quot;</a>
<a name="ln38">#include &quot;notes.h&quot;</a>
<a name="ln39">#include &quot;options.h&quot;</a>
<a name="ln40">#include &quot;orb-type.h&quot;</a>
<a name="ln41">#include &quot;player.h&quot;</a>
<a name="ln42">#include &quot;prompt.h&quot;</a>
<a name="ln43">#include &quot;religion.h&quot;</a>
<a name="ln44">#include &quot;shopping.h&quot;</a>
<a name="ln45">#include &quot;showsymb.h&quot;</a>
<a name="ln46">#include &quot;skills.h&quot;</a>
<a name="ln47">#include &quot;spl-book.h&quot;</a>
<a name="ln48">#include &quot;state.h&quot;</a>
<a name="ln49">#include &quot;stringutil.h&quot;</a>
<a name="ln50">#include &quot;throw.h&quot;</a>
<a name="ln51">#include &quot;transform.h&quot;</a>
<a name="ln52">#include &quot;unicode.h&quot;</a>
<a name="ln53">#include &quot;unwind.h&quot;</a>
<a name="ln54">#include &quot;viewgeom.h&quot;</a>
<a name="ln55"> </a>
<a name="ln56">static bool _is_consonant(char let);</a>
<a name="ln57">static char _random_vowel();</a>
<a name="ln58">static char _random_cons();</a>
<a name="ln59">static string _random_consonant_set(size_t seed);</a>
<a name="ln60"> </a>
<a name="ln61">static void _maybe_identify_pack_item()</a>
<a name="ln62">{</a>
<a name="ln63">    for (auto &amp;item : you.inv)</a>
<a name="ln64">        if (item.defined() &amp;&amp; !get_ident_type(item))</a>
<a name="ln65">            maybe_identify_base_type(item);</a>
<a name="ln66">}</a>
<a name="ln67"> </a>
<a name="ln68">// quant_name is useful since it prints out a different number of items</a>
<a name="ln69">// than the item actually contains.</a>
<a name="ln70">string quant_name(const item_def &amp;item, int quant,</a>
<a name="ln71">                  description_level_type des, bool terse)</a>
<a name="ln72">{</a>
<a name="ln73">    // item_name now requires a &quot;real&quot; item, so we'll mangle a tmp</a>
<a name="ln74">    item_def tmp = item;</a>
<a name="ln75">    tmp.quantity = quant;</a>
<a name="ln76"> </a>
<a name="ln77">    return tmp.name(des, terse);</a>
<a name="ln78">}</a>
<a name="ln79"> </a>
<a name="ln80">static const char* _interesting_origin(const item_def &amp;item)</a>
<a name="ln81">{</a>
<a name="ln82">    if (origin_as_god_gift(item) != GOD_NO_GOD)</a>
<a name="ln83">        return &quot;god gift&quot;;</a>
<a name="ln84"> </a>
<a name="ln85">    if (item.orig_monnum == MONS_DONALD &amp;&amp; get_equip_desc(item)</a>
<a name="ln86">        &amp;&amp; item.is_type(OBJ_ARMOUR, ARM_KITE_SHIELD))</a>
<a name="ln87">    {</a>
<a name="ln88">        return &quot;Donald&quot;;</a>
<a name="ln89">    }</a>
<a name="ln90"> </a>
<a name="ln91">    return nullptr;</a>
<a name="ln92">}</a>
<a name="ln93"> </a>
<a name="ln94">/**</a>
<a name="ln95"> * What inscription should be appended to the given item's name?</a>
<a name="ln96"> */</a>
<a name="ln97">static string _item_inscription(const item_def &amp;item)</a>
<a name="ln98">{</a>
<a name="ln99">    vector&lt;string&gt; insparts;</a>
<a name="ln100"> </a>
<a name="ln101">    if (const char *orig = _interesting_origin(item))</a>
<a name="ln102">    {</a>
<a name="ln103">        if (Options.show_god_gift == MB_TRUE</a>
<a name="ln104">            || Options.show_god_gift == MB_MAYBE &amp;&amp; !fully_identified(item))</a>
<a name="ln105">        {</a>
<a name="ln106">            insparts.push_back(orig);</a>
<a name="ln107">        }</a>
<a name="ln108">    }</a>
<a name="ln109"> </a>
<a name="ln110">    if (is_artefact(item))</a>
<a name="ln111">    {</a>
<a name="ln112">        const string part = artefact_inscription(item);</a>
<a name="ln113">        if (!part.empty())</a>
<a name="ln114">            insparts.push_back(part);</a>
<a name="ln115">    }</a>
<a name="ln116"> </a>
<a name="ln117">    if (!item.inscription.empty())</a>
<a name="ln118">        insparts.push_back(item.inscription);</a>
<a name="ln119"> </a>
<a name="ln120">    if (insparts.empty())</a>
<a name="ln121">        return &quot;&quot;;</a>
<a name="ln122"> </a>
<a name="ln123">    return make_stringf(&quot; {%s}&quot;,</a>
<a name="ln124">                        comma_separated_line(begin(insparts),</a>
<a name="ln125">                                             end(insparts),</a>
<a name="ln126">                                             &quot;, &quot;).c_str());</a>
<a name="ln127">}</a>
<a name="ln128"> </a>
<a name="ln129">string item_def::name(description_level_type descrip, bool terse, bool ident,</a>
<a name="ln130">                      bool with_inscription, bool quantity_in_words,</a>
<a name="ln131">                      iflags_t ignore_flags) const</a>
<a name="ln132">{</a>
<a name="ln133">    if (crawl_state.game_is_arena())</a>
<a name="ln134">    {</a>
<a name="ln135">        ignore_flags |= ISFLAG_KNOW_PLUSES | ISFLAG_KNOW_CURSE</a>
<a name="ln136">                        | ISFLAG_COSMETIC_MASK;</a>
<a name="ln137">    }</a>
<a name="ln138"> </a>
<a name="ln139">    if (descrip == DESC_NONE)</a>
<a name="ln140">        return &quot;&quot;;</a>
<a name="ln141"> </a>
<a name="ln142">    ostringstream buff;</a>
<a name="ln143"> </a>
<a name="ln144">    const string auxname = name_aux(descrip, terse, ident, with_inscription,</a>
<a name="ln145">                                    ignore_flags);</a>
<a name="ln146"> </a>
<a name="ln147">    const bool startvowel     = is_vowel(auxname[0]);</a>
<a name="ln148"> </a>
<a name="ln149">    if (descrip == DESC_INVENTORY_EQUIP || descrip == DESC_INVENTORY)</a>
<a name="ln150">    {</a>
<a name="ln151">        if (in_inventory(*this)) // actually in inventory</a>
<a name="ln152">        {</a>
<a name="ln153">            buff &lt;&lt; index_to_letter(link);</a>
<a name="ln154">            if (terse)</a>
<a name="ln155">                buff &lt;&lt; &quot;) &quot;;</a>
<a name="ln156">            else</a>
<a name="ln157">                buff &lt;&lt; &quot; - &quot;;</a>
<a name="ln158">        }</a>
<a name="ln159">        else</a>
<a name="ln160">            descrip = DESC_A;</a>
<a name="ln161">    }</a>
<a name="ln162"> </a>
<a name="ln163">    if (base_type == OBJ_BOOKS &amp;&amp; (ident || item_type_known(*this))</a>
<a name="ln164">        &amp;&amp; book_has_title(*this))</a>
<a name="ln165">    {</a>
<a name="ln166">        if (descrip != DESC_DBNAME)</a>
<a name="ln167">            descrip = DESC_PLAIN;</a>
<a name="ln168">    }</a>
<a name="ln169"> </a>
<a name="ln170">    if (terse &amp;&amp; descrip != DESC_DBNAME)</a>
<a name="ln171">        descrip = DESC_PLAIN;</a>
<a name="ln172"> </a>
<a name="ln173">    monster_flags_t corpse_flags;</a>
<a name="ln174"> </a>
<a name="ln175">    // no &quot;a dragon scales&quot;</a>
<a name="ln176">    const bool always_plural = armour_is_hide(*this)</a>
<a name="ln177">                               &amp;&amp; sub_type != ARM_TROLL_LEATHER_ARMOUR;</a>
<a name="ln178"> </a>
<a name="ln179">    if ((base_type == OBJ_CORPSES &amp;&amp; is_named_corpse(*this)</a>
<a name="ln180">         &amp;&amp; !(((corpse_flags.flags = props[CORPSE_NAME_TYPE_KEY].get_int64())</a>
<a name="ln181">               &amp; MF_NAME_SPECIES)</a>
<a name="ln182">              &amp;&amp; !(corpse_flags &amp; MF_NAME_DEFINITE))</a>
<a name="ln183">         &amp;&amp; !(corpse_flags &amp; MF_NAME_SUFFIX)</a>
<a name="ln184">         &amp;&amp; !starts_with(get_corpse_name(*this), &quot;shaped &quot;))</a>
<a name="ln185">        || item_is_orb(*this) || item_is_horn_of_geryon(*this)</a>
<a name="ln186">        || (ident || item_type_known(*this)) &amp;&amp; is_artefact(*this)</a>
<a name="ln187">            &amp;&amp; special != UNRAND_OCTOPUS_KING_RING)</a>
<a name="ln188">    {</a>
<a name="ln189">        // Artefacts always get &quot;the&quot; unless we just want the plain name.</a>
<a name="ln190">        switch (descrip)</a>
<a name="ln191">        {</a>
<a name="ln192">        default:</a>
<a name="ln193">            buff &lt;&lt; &quot;the &quot;;</a>
<a name="ln194">        case DESC_PLAIN:</a>
<a name="ln195">        case DESC_DBNAME:</a>
<a name="ln196">        case DESC_BASENAME:</a>
<a name="ln197">        case DESC_QUALNAME:</a>
<a name="ln198">            break;</a>
<a name="ln199">        }</a>
<a name="ln200">    }</a>
<a name="ln201">    else if (quantity &gt; 1 || always_plural)</a>
<a name="ln202">    {</a>
<a name="ln203">        switch (descrip)</a>
<a name="ln204">        {</a>
<a name="ln205">        case DESC_THE:        buff &lt;&lt; &quot;the &quot;; break;</a>
<a name="ln206">        case DESC_YOUR:       buff &lt;&lt; &quot;your &quot;; break;</a>
<a name="ln207">        case DESC_ITS:        buff &lt;&lt; &quot;its &quot;; break;</a>
<a name="ln208">        case DESC_A:</a>
<a name="ln209">        case DESC_INVENTORY_EQUIP:</a>
<a name="ln210">        case DESC_INVENTORY:</a>
<a name="ln211">        case DESC_PLAIN:</a>
<a name="ln212">        default:</a>
<a name="ln213">            break;</a>
<a name="ln214">        }</a>
<a name="ln215"> </a>
<a name="ln216">        if (descrip != DESC_BASENAME &amp;&amp; descrip != DESC_QUALNAME</a>
<a name="ln217">            &amp;&amp; descrip != DESC_DBNAME &amp;&amp; !always_plural)</a>
<a name="ln218">        {</a>
<a name="ln219">            if (quantity_in_words)</a>
<a name="ln220">                buff &lt;&lt; number_in_words(quantity) &lt;&lt; &quot; &quot;;</a>
<a name="ln221">            else</a>
<a name="ln222">                buff &lt;&lt; quantity &lt;&lt; &quot; &quot;;</a>
<a name="ln223">        }</a>
<a name="ln224">    }</a>
<a name="ln225">    else</a>
<a name="ln226">    {</a>
<a name="ln227">        switch (descrip)</a>
<a name="ln228">        {</a>
<a name="ln229">        case DESC_THE:        buff &lt;&lt; &quot;the &quot;; break;</a>
<a name="ln230">        case DESC_YOUR:       buff &lt;&lt; &quot;your &quot;; break;</a>
<a name="ln231">        case DESC_ITS:        buff &lt;&lt; &quot;its &quot;; break;</a>
<a name="ln232">        case DESC_A:</a>
<a name="ln233">        case DESC_INVENTORY_EQUIP:</a>
<a name="ln234">        case DESC_INVENTORY:</a>
<a name="ln235">                              buff &lt;&lt; (startvowel ? &quot;an &quot; : &quot;a &quot;); break;</a>
<a name="ln236">        case DESC_PLAIN:</a>
<a name="ln237">        default:</a>
<a name="ln238">            break;</a>
<a name="ln239">        }</a>
<a name="ln240">    }</a>
<a name="ln241"> </a>
<a name="ln242">    buff &lt;&lt; auxname;</a>
<a name="ln243"> </a>
<a name="ln244">    if (descrip == DESC_INVENTORY_EQUIP)</a>
<a name="ln245">    {</a>
<a name="ln246">        equipment_type eq = item_equip_slot(*this);</a>
<a name="ln247">        if (eq != EQ_NONE)</a>
<a name="ln248">        {</a>
<a name="ln249">            if (you.melded[eq])</a>
<a name="ln250">                buff &lt;&lt; &quot; (melded)&quot;;</a>
<a name="ln251">            else</a>
<a name="ln252">            {</a>
<a name="ln253">                switch (eq)</a>
<a name="ln254">                {</a>
<a name="ln255">                case EQ_WEAPON:</a>
<a name="ln256">                    if (is_weapon(*this))</a>
<a name="ln257">                        buff &lt;&lt; &quot; (weapon)&quot;;</a>
<a name="ln258">                    else if (you.species == SP_FELID)</a>
<a name="ln259">                        buff &lt;&lt; &quot; (in mouth)&quot;;</a>
<a name="ln260">                    else</a>
<a name="ln261">                        buff &lt;&lt; &quot; (in &quot; &lt;&lt; you.hand_name(false) &lt;&lt; &quot;)&quot;;</a>
<a name="ln262">                    break;</a>
<a name="ln263">                case EQ_CLOAK:</a>
<a name="ln264">                case EQ_HELMET:</a>
<a name="ln265">                case EQ_GLOVES:</a>
<a name="ln266">                case EQ_BOOTS:</a>
<a name="ln267">                case EQ_SHIELD:</a>
<a name="ln268">                case EQ_BODY_ARMOUR:</a>
<a name="ln269">                    buff &lt;&lt; &quot; (worn)&quot;;</a>
<a name="ln270">                    break;</a>
<a name="ln271">                case EQ_LEFT_RING:</a>
<a name="ln272">                case EQ_RIGHT_RING:</a>
<a name="ln273">                case EQ_RING_ONE:</a>
<a name="ln274">                case EQ_RING_TWO:</a>
<a name="ln275">                    buff &lt;&lt; &quot; (&quot;;</a>
<a name="ln276">                    buff &lt;&lt; ((eq == EQ_LEFT_RING || eq == EQ_RING_ONE)</a>
<a name="ln277">                             ? &quot;left&quot; : &quot;right&quot;);</a>
<a name="ln278">                    buff &lt;&lt; &quot; &quot;;</a>
<a name="ln279">                    buff &lt;&lt; you.hand_name(false);</a>
<a name="ln280">                    buff &lt;&lt; &quot;)&quot;;</a>
<a name="ln281">                    break;</a>
<a name="ln282">                case EQ_AMULET:</a>
<a name="ln283">                    if (you.species == SP_OCTOPODE &amp;&amp; form_keeps_mutations())</a>
<a name="ln284">                        buff &lt;&lt; &quot; (around mantle)&quot;;</a>
<a name="ln285">                    else</a>
<a name="ln286">                        buff &lt;&lt; &quot; (around neck)&quot;;</a>
<a name="ln287">                    break;</a>
<a name="ln288">                case EQ_RING_THREE:</a>
<a name="ln289">                case EQ_RING_FOUR:</a>
<a name="ln290">                case EQ_RING_FIVE:</a>
<a name="ln291">                case EQ_RING_SIX:</a>
<a name="ln292">                case EQ_RING_SEVEN:</a>
<a name="ln293">                case EQ_RING_EIGHT:</a>
<a name="ln294">                    buff &lt;&lt; &quot; (on tentacle)&quot;;</a>
<a name="ln295">                    break;</a>
<a name="ln296">                case EQ_RING_AMULET:</a>
<a name="ln297">                    buff &lt;&lt; &quot; (on amulet)&quot;;</a>
<a name="ln298">                    break;</a>
<a name="ln299">                default:</a>
<a name="ln300">                    die(&quot;Item in an invalid slot&quot;);</a>
<a name="ln301">                }</a>
<a name="ln302">            }</a>
<a name="ln303">        }</a>
<a name="ln304">        else if (item_is_quivered(*this))</a>
<a name="ln305">            buff &lt;&lt; &quot; (quivered)&quot;;</a>
<a name="ln306">    }</a>
<a name="ln307"> </a>
<a name="ln308">    if (descrip != DESC_BASENAME &amp;&amp; descrip != DESC_DBNAME &amp;&amp; with_inscription)</a>
<a name="ln309">        buff &lt;&lt; _item_inscription(*this);</a>
<a name="ln310"> </a>
<a name="ln311">    // These didn't have &quot;cursed &quot; prepended; add them here so that</a>
<a name="ln312">    // it comes after the inscription.</a>
<a name="ln313">    if (terse &amp;&amp; descrip != DESC_DBNAME &amp;&amp; descrip != DESC_BASENAME</a>
<a name="ln314">        &amp;&amp; descrip != DESC_QUALNAME</a>
<a name="ln315">        &amp;&amp; is_artefact(*this) &amp;&amp; cursed()</a>
<a name="ln316">        &amp;&amp; !testbits(ignore_flags, ISFLAG_KNOW_CURSE)</a>
<a name="ln317">        &amp;&amp; (ident || item_ident(*this, ISFLAG_KNOW_CURSE)))</a>
<a name="ln318">    {</a>
<a name="ln319">        buff &lt;&lt; &quot; (curse)&quot;;</a>
<a name="ln320">    }</a>
<a name="ln321"> </a>
<a name="ln322">    return buff.str();</a>
<a name="ln323">}</a>
<a name="ln324"> </a>
<a name="ln325">static bool _missile_brand_is_prefix(special_missile_type brand)</a>
<a name="ln326">{</a>
<a name="ln327">    switch (brand)</a>
<a name="ln328">    {</a>
<a name="ln329">    case SPMSL_POISONED:</a>
<a name="ln330">    case SPMSL_CURARE:</a>
<a name="ln331">    case SPMSL_BLINDING:</a>
<a name="ln332">    case SPMSL_FRENZY:</a>
<a name="ln333">    case SPMSL_EXPLODING:</a>
<a name="ln334">#if TAG_MAJOR_VERSION == 34</a>
<a name="ln335">    case SPMSL_STEEL:</a>
<a name="ln336">#endif</a>
<a name="ln337">    case SPMSL_SILVER:</a>
<a name="ln338">        return true;</a>
<a name="ln339">    default:</a>
<a name="ln340">        return false;</a>
<a name="ln341">    }</a>
<a name="ln342">}</a>
<a name="ln343"> </a>
<a name="ln344">static bool _missile_brand_is_postfix(special_missile_type brand)</a>
<a name="ln345">{</a>
<a name="ln346">    return brand != SPMSL_NORMAL &amp;&amp; !_missile_brand_is_prefix(brand);</a>
<a name="ln347">}</a>
<a name="ln348"> </a>
<a name="ln349">const char* missile_brand_name(const item_def &amp;item, mbn_type t)</a>
<a name="ln350">{</a>
<a name="ln351">    const special_missile_type brand</a>
<a name="ln352">        = static_cast&lt;special_missile_type&gt;(item.brand);</a>
<a name="ln353">    switch (brand)</a>
<a name="ln354">    {</a>
<a name="ln355">#if TAG_MAJOR_VERSION == 34</a>
<a name="ln356">    case SPMSL_FLAME:</a>
<a name="ln357">        return &quot;flame&quot;;</a>
<a name="ln358">    case SPMSL_FROST:</a>
<a name="ln359">        return &quot;frost&quot;;</a>
<a name="ln360">#endif</a>
<a name="ln361">    case SPMSL_POISONED:</a>
<a name="ln362">        return t == MBN_NAME ? &quot;poisoned&quot; : &quot;poison&quot;;</a>
<a name="ln363">    case SPMSL_CURARE:</a>
<a name="ln364">        return t == MBN_NAME ? &quot;curare-tipped&quot; : &quot;curare&quot;;</a>
<a name="ln365">#if TAG_MAJOR_VERSION == 34</a>
<a name="ln366">    case SPMSL_EXPLODING:</a>
<a name="ln367">        return t == MBN_TERSE ? &quot;explode&quot; : &quot;exploding&quot;;</a>
<a name="ln368">    case SPMSL_STEEL:</a>
<a name="ln369">        return &quot;steel&quot;;</a>
<a name="ln370">    case SPMSL_RETURNING:</a>
<a name="ln371">        return t == MBN_TERSE ? &quot;return&quot; : &quot;returning&quot;;</a>
<a name="ln372">    case SPMSL_PENETRATION:</a>
<a name="ln373">        return t == MBN_TERSE ? &quot;penet&quot; : &quot;penetration&quot;;</a>
<a name="ln374">#endif</a>
<a name="ln375">    case SPMSL_SILVER:</a>
<a name="ln376">        return &quot;silver&quot;;</a>
<a name="ln377">#if TAG_MAJOR_VERSION == 34</a>
<a name="ln378">    case SPMSL_PARALYSIS:</a>
<a name="ln379">        return &quot;paralysis&quot;;</a>
<a name="ln380">    case SPMSL_SLOW:</a>
<a name="ln381">        return t == MBN_TERSE ? &quot;slow&quot; : &quot;slowing&quot;;</a>
<a name="ln382">    case SPMSL_SLEEP:</a>
<a name="ln383">        return t == MBN_TERSE ? &quot;sleep&quot; : &quot;sleeping&quot;;</a>
<a name="ln384">    case SPMSL_CONFUSION:</a>
<a name="ln385">        return t == MBN_TERSE ? &quot;conf&quot; : &quot;confusion&quot;;</a>
<a name="ln386">    case SPMSL_SICKNESS:</a>
<a name="ln387">        return t == MBN_TERSE ? &quot;sick&quot; : &quot;sickness&quot;;</a>
<a name="ln388">#endif</a>
<a name="ln389">    case SPMSL_FRENZY:</a>
<a name="ln390">        return t == MBN_NAME ? &quot;datura-tipped&quot; : &quot;datura&quot;;</a>
<a name="ln391">    case SPMSL_CHAOS:</a>
<a name="ln392">        return &quot;chaos&quot;;</a>
<a name="ln393">    case SPMSL_DISPERSAL:</a>
<a name="ln394">        return t == MBN_TERSE ? &quot;disperse&quot; : &quot;dispersal&quot;;</a>
<a name="ln395">    case SPMSL_BLINDING:</a>
<a name="ln396">        return t == MBN_NAME ? &quot;atropa-tipped&quot; : &quot;atropa&quot;;</a>
<a name="ln397">    case SPMSL_NORMAL:</a>
<a name="ln398">        return &quot;&quot;;</a>
<a name="ln399">    default:</a>
<a name="ln400">        return t == MBN_TERSE ? &quot;buggy&quot; : &quot;bugginess&quot;;</a>
<a name="ln401">    }</a>
<a name="ln402">}</a>
<a name="ln403"> </a>
<a name="ln404">static const char *weapon_brands_terse[] =</a>
<a name="ln405">{</a>
<a name="ln406">    &quot;&quot;, &quot;flame&quot;, &quot;freeze&quot;, &quot;holy&quot;, &quot;elec&quot;,</a>
<a name="ln407">#if TAG_MAJOR_VERSION == 34</a>
<a name="ln408">    &quot;obsolete&quot;, &quot;obsolete&quot;,</a>
<a name="ln409">#endif</a>
<a name="ln410">    &quot;venom&quot;, &quot;protect&quot;, &quot;drain&quot;, &quot;speed&quot;, &quot;vorpal&quot;,</a>
<a name="ln411">#if TAG_MAJOR_VERSION == 34</a>
<a name="ln412">    &quot;obsolete&quot;, &quot;obsolete&quot;,</a>
<a name="ln413">#endif</a>
<a name="ln414">    &quot;vamp&quot;, &quot;pain&quot;, &quot;antimagic&quot;, &quot;distort&quot;,</a>
<a name="ln415">#if TAG_MAJOR_VERSION == 34</a>
<a name="ln416">    &quot;obsolete&quot;, &quot;obsolete&quot;,</a>
<a name="ln417">#endif</a>
<a name="ln418">    &quot;chaos&quot;,</a>
<a name="ln419">#if TAG_MAJOR_VERSION == 34</a>
<a name="ln420">    &quot;evade&quot;, &quot;confuse&quot;,</a>
<a name="ln421">#endif</a>
<a name="ln422">    &quot;penet&quot;, &quot;reap&quot;, &quot;vorpal&quot;, &quot;acid&quot;,</a>
<a name="ln423">#if TAG_MAJOR_VERSION &gt; 34</a>
<a name="ln424">    &quot;confuse&quot;,</a>
<a name="ln425">#endif</a>
<a name="ln426">    &quot;debug&quot;,</a>
<a name="ln427">};</a>
<a name="ln428"> </a>
<a name="ln429">static const char *weapon_brands_verbose[] =</a>
<a name="ln430">{</a>
<a name="ln431">    &quot;&quot;, &quot;flaming&quot;, &quot;freezing&quot;, &quot;holy wrath&quot;, &quot;electrocution&quot;,</a>
<a name="ln432">#if TAG_MAJOR_VERSION == 34</a>
<a name="ln433">    &quot;orc slaying&quot;, &quot;dragon slaying&quot;,</a>
<a name="ln434">#endif</a>
<a name="ln435">    &quot;venom&quot;, &quot;protection&quot;, &quot;draining&quot;, &quot;speed&quot;, &quot;vorpality&quot;,</a>
<a name="ln436">#if TAG_MAJOR_VERSION == 34</a>
<a name="ln437">    &quot;flame&quot;, &quot;frost&quot;,</a>
<a name="ln438">#endif</a>
<a name="ln439">    &quot;vampirism&quot;, &quot;pain&quot;, &quot;antimagic&quot;, &quot;distortion&quot;,</a>
<a name="ln440">#if TAG_MAJOR_VERSION == 34</a>
<a name="ln441">    &quot;reaching&quot;, &quot;returning&quot;,</a>
<a name="ln442">#endif</a>
<a name="ln443">    &quot;chaos&quot;,</a>
<a name="ln444">#if TAG_MAJOR_VERSION == 34</a>
<a name="ln445">    &quot;evasion&quot;, &quot;confusion&quot;,</a>
<a name="ln446">#endif</a>
<a name="ln447">    &quot;penetration&quot;, &quot;reaping&quot;, &quot;vorpal&quot;, &quot;acid&quot;,</a>
<a name="ln448">#if TAG_MAJOR_VERSION &gt; 34</a>
<a name="ln449">    &quot;confusion&quot;,</a>
<a name="ln450">#endif</a>
<a name="ln451">    &quot;debug&quot;,</a>
<a name="ln452">};</a>
<a name="ln453"> </a>
<a name="ln454">static const char *weapon_brands_adj[] =</a>
<a name="ln455">{</a>
<a name="ln456">    &quot;&quot;, &quot;flaming&quot;, &quot;freezing&quot;, &quot;holy&quot;, &quot;electric&quot;,</a>
<a name="ln457">#if TAG_MAJOR_VERSION == 34</a>
<a name="ln458">    &quot;orc-killing&quot;, &quot;dragon-slaying&quot;,</a>
<a name="ln459">#endif</a>
<a name="ln460">    &quot;venomous&quot;, &quot;protective&quot;, &quot;draining&quot;, &quot;fast&quot;, &quot;vorpal&quot;,</a>
<a name="ln461">#if TAG_MAJOR_VERSION == 34</a>
<a name="ln462">    &quot;flaming&quot;, &quot;freezing&quot;,</a>
<a name="ln463">#endif</a>
<a name="ln464">    &quot;vampiric&quot;, &quot;painful&quot;, &quot;antimagic&quot;, &quot;distorting&quot;,</a>
<a name="ln465">#if TAG_MAJOR_VERSION == 34</a>
<a name="ln466">    &quot;reaching&quot;, &quot;returning&quot;,</a>
<a name="ln467">#endif</a>
<a name="ln468">    &quot;chaotic&quot;,</a>
<a name="ln469">#if TAG_MAJOR_VERSION == 34</a>
<a name="ln470">    &quot;evasive&quot;, &quot;confusing&quot;,</a>
<a name="ln471">#endif</a>
<a name="ln472">    &quot;penetrating&quot;, &quot;reaping&quot;, &quot;vorpal&quot;, &quot;acidic&quot;,</a>
<a name="ln473">#if TAG_MAJOR_VERSION &gt; 34</a>
<a name="ln474">    &quot;confusing&quot;,</a>
<a name="ln475">#endif</a>
<a name="ln476">    &quot;debug&quot;,</a>
<a name="ln477">};</a>
<a name="ln478"> </a>
<a name="ln479">// TODO: currently only for pghosts...expand?</a>
<a name="ln480">static const set&lt;brand_type&gt; brand_prefers_adj =</a>
<a name="ln481">            { SPWPN_VAMPIRISM, SPWPN_ANTIMAGIC, SPWPN_VORPAL };</a>
<a name="ln482"> </a>
<a name="ln483">/**</a>
<a name="ln484"> * What's the name of a type of weapon brand?</a>
<a name="ln485"> *</a>
<a name="ln486"> * @param brand             The type of brand in question.</a>
<a name="ln487"> * @param bool              Whether to use a terse or verbose name.</a>
<a name="ln488"> * @return                  The name of the given brand.</a>
<a name="ln489"> */</a>
<a name="ln490">const char* brand_type_name(brand_type brand, bool terse)</a>
<a name="ln491">{</a>
<a name="ln492">    COMPILE_CHECK(ARRAYSZ(weapon_brands_terse) == NUM_SPECIAL_WEAPONS);</a>
<a name="ln493">    COMPILE_CHECK(ARRAYSZ(weapon_brands_verbose) == NUM_SPECIAL_WEAPONS);</a>
<a name="ln494"> </a>
<a name="ln495">    if (brand &lt; 0 || brand &gt;= NUM_SPECIAL_WEAPONS)</a>
<a name="ln496">        return terse ? &quot;buggy&quot; : &quot;bugginess&quot;;</a>
<a name="ln497"> </a>
<a name="ln498">    return (terse ? weapon_brands_terse : weapon_brands_verbose)[brand];</a>
<a name="ln499">}</a>
<a name="ln500"> </a>
<a name="ln501">const char* brand_type_adj(brand_type brand)</a>
<a name="ln502">{</a>
<a name="ln503">    COMPILE_CHECK(ARRAYSZ(weapon_brands_terse) == NUM_SPECIAL_WEAPONS);</a>
<a name="ln504">    COMPILE_CHECK(ARRAYSZ(weapon_brands_verbose) == NUM_SPECIAL_WEAPONS);</a>
<a name="ln505"> </a>
<a name="ln506">    if (brand &lt; 0 || brand &gt;= NUM_SPECIAL_WEAPONS)</a>
<a name="ln507">        return &quot;buggy&quot;;</a>
<a name="ln508"> </a>
<a name="ln509">    return weapon_brands_adj[brand];</a>
<a name="ln510">}</a>
<a name="ln511"> </a>
<a name="ln512">/**</a>
<a name="ln513"> * What's the name of a given weapon's brand?</a>
<a name="ln514"> *</a>
<a name="ln515"> * @param item              The weapon with the brand.</a>
<a name="ln516"> * @param bool              Whether to use a terse or verbose name.</a>
<a name="ln517"> * @return                  The name of the given item's brand.</a>
<a name="ln518"> */</a>
<a name="ln519">const char* weapon_brand_name(const item_def&amp; item, bool terse,</a>
<a name="ln520">                              brand_type override_brand)</a>
<a name="ln521">{</a>
<a name="ln522">    const brand_type brand = override_brand ? override_brand : get_weapon_brand(item);</a>
<a name="ln523"> </a>
<a name="ln524">    return brand_type_name(brand, terse);</a>
<a name="ln525">}</a>
<a name="ln526"> </a>
<a name="ln527">const char* armour_ego_name(const item_def&amp; item, bool terse)</a>
<a name="ln528">{</a>
<a name="ln529">    if (!terse)</a>
<a name="ln530">    {</a>
<a name="ln531">        switch (get_armour_ego_type(item))</a>
<a name="ln532">        {</a>
<a name="ln533">        case SPARM_NORMAL:            return &quot;&quot;;</a>
<a name="ln534">        case SPARM_RUNNING:</a>
<a name="ln535">            // &quot;naga barding of running&quot; doesn't make any sense, and yes,</a>
<a name="ln536">            // they are possible. The terse ego name for these is {run}</a>
<a name="ln537">            // still to avoid player confusion, it used to be {sslith}.</a>
<a name="ln538">            if (item.sub_type == ARM_NAGA_BARDING)</a>
<a name="ln539">                                      return &quot;speedy slithering&quot;;</a>
<a name="ln540">            else</a>
<a name="ln541">                                      return &quot;running&quot;;</a>
<a name="ln542">        case SPARM_FIRE_RESISTANCE:   return &quot;fire resistance&quot;;</a>
<a name="ln543">        case SPARM_COLD_RESISTANCE:   return &quot;cold resistance&quot;;</a>
<a name="ln544">        case SPARM_POISON_RESISTANCE: return &quot;poison resistance&quot;;</a>
<a name="ln545">        case SPARM_SEE_INVISIBLE:     return &quot;see invisible&quot;;</a>
<a name="ln546">        case SPARM_INVISIBILITY:      return &quot;invisibility&quot;;</a>
<a name="ln547">        case SPARM_STRENGTH:          return &quot;strength&quot;;</a>
<a name="ln548">        case SPARM_DEXTERITY:         return &quot;dexterity&quot;;</a>
<a name="ln549">        case SPARM_INTELLIGENCE:      return &quot;intelligence&quot;;</a>
<a name="ln550">        case SPARM_PONDEROUSNESS:     return &quot;ponderousness&quot;;</a>
<a name="ln551">        case SPARM_FLYING:            return &quot;flying&quot;;</a>
<a name="ln552"> </a>
<a name="ln553">        case SPARM_MAGIC_RESISTANCE:  return &quot;magic resistance&quot;;</a>
<a name="ln554">        case SPARM_PROTECTION:        return &quot;protection&quot;;</a>
<a name="ln555">        case SPARM_STEALTH:           return &quot;stealth&quot;;</a>
<a name="ln556">        case SPARM_RESISTANCE:        return &quot;resistance&quot;;</a>
<a name="ln557">        case SPARM_POSITIVE_ENERGY:   return &quot;positive energy&quot;;</a>
<a name="ln558">        case SPARM_ARCHMAGI:          return &quot;the Archmagi&quot;;</a>
<a name="ln559">#if TAG_MAJOR_VERSION == 34</a>
<a name="ln560">        case SPARM_JUMPING:           return &quot;jumping&quot;;</a>
<a name="ln561">        case SPARM_PRESERVATION:      return &quot;preservation&quot;;</a>
<a name="ln562">#endif</a>
<a name="ln563">        case SPARM_REFLECTION:        return &quot;reflection&quot;;</a>
<a name="ln564">        case SPARM_SPIRIT_SHIELD:     return &quot;spirit shield&quot;;</a>
<a name="ln565">        case SPARM_ARCHERY:           return &quot;archery&quot;;</a>
<a name="ln566">        case SPARM_REPULSION:         return &quot;repulsion&quot;;</a>
<a name="ln567">        case SPARM_CLOUD_IMMUNE:      return &quot;cloud immunity&quot;;</a>
<a name="ln568">        default:                      return &quot;bugginess&quot;;</a>
<a name="ln569">        }</a>
<a name="ln570">    }</a>
<a name="ln571">    else</a>
<a name="ln572">    {</a>
<a name="ln573">        switch (get_armour_ego_type(item))</a>
<a name="ln574">        {</a>
<a name="ln575">        case SPARM_NORMAL:            return &quot;&quot;;</a>
<a name="ln576">        case SPARM_RUNNING:           return &quot;run&quot;;</a>
<a name="ln577">        case SPARM_FIRE_RESISTANCE:   return &quot;rF+&quot;;</a>
<a name="ln578">        case SPARM_COLD_RESISTANCE:   return &quot;rC+&quot;;</a>
<a name="ln579">        case SPARM_POISON_RESISTANCE: return &quot;rPois&quot;;</a>
<a name="ln580">        case SPARM_SEE_INVISIBLE:     return &quot;SInv&quot;;</a>
<a name="ln581">        case SPARM_INVISIBILITY:      return &quot;+Inv&quot;;</a>
<a name="ln582">        case SPARM_STRENGTH:          return &quot;Str+3&quot;;</a>
<a name="ln583">        case SPARM_DEXTERITY:         return &quot;Dex+3&quot;;</a>
<a name="ln584">        case SPARM_INTELLIGENCE:      return &quot;Int+3&quot;;</a>
<a name="ln585">        case SPARM_PONDEROUSNESS:     return &quot;ponderous&quot;;</a>
<a name="ln586">        case SPARM_FLYING:            return &quot;Fly&quot;;</a>
<a name="ln587">        case SPARM_MAGIC_RESISTANCE:  return &quot;MR+&quot;;</a>
<a name="ln588">        case SPARM_PROTECTION:        return &quot;AC+3&quot;;</a>
<a name="ln589">        case SPARM_STEALTH:           return &quot;Stlth+&quot;;</a>
<a name="ln590">        case SPARM_RESISTANCE:        return &quot;rC+ rF+&quot;;</a>
<a name="ln591">        case SPARM_POSITIVE_ENERGY:   return &quot;rN+&quot;;</a>
<a name="ln592">        case SPARM_ARCHMAGI:          return &quot;Archmagi&quot;;</a>
<a name="ln593">#if TAG_MAJOR_VERSION == 34</a>
<a name="ln594">        case SPARM_JUMPING:           return &quot;obsolete&quot;;</a>
<a name="ln595">        case SPARM_PRESERVATION:      return &quot;obsolete&quot;;</a>
<a name="ln596">#endif</a>
<a name="ln597">        case SPARM_REFLECTION:        return &quot;reflect&quot;;</a>
<a name="ln598">        case SPARM_SPIRIT_SHIELD:     return &quot;Spirit&quot;;</a>
<a name="ln599">        case SPARM_ARCHERY:           return &quot;archery&quot;;</a>
<a name="ln600">        case SPARM_REPULSION:         return &quot;repulsion&quot;;</a>
<a name="ln601">        case SPARM_CLOUD_IMMUNE:      return &quot;cloud immunity&quot;;</a>
<a name="ln602">        default:                      return &quot;buggy&quot;;</a>
<a name="ln603">        }</a>
<a name="ln604">    }</a>
<a name="ln605">}</a>
<a name="ln606"> </a>
<a name="ln607">static const char* _wand_type_name(int wandtype)</a>
<a name="ln608">{</a>
<a name="ln609">    switch (wandtype)</a>
<a name="ln610">    {</a>
<a name="ln611">    case WAND_FLAME:           return &quot;flame&quot;;</a>
<a name="ln612">    case WAND_PARALYSIS:       return &quot;paralysis&quot;;</a>
<a name="ln613">    case WAND_DIGGING:         return &quot;digging&quot;;</a>
<a name="ln614">    case WAND_ICEBLAST:        return &quot;iceblast&quot;;</a>
<a name="ln615">    case WAND_POLYMORPH:       return &quot;polymorph&quot;;</a>
<a name="ln616">    case WAND_ENSLAVEMENT:     return &quot;enslavement&quot;;</a>
<a name="ln617">    case WAND_ACID:            return &quot;acid&quot;;</a>
<a name="ln618">    case WAND_RANDOM_EFFECTS:  return &quot;random effects&quot;;</a>
<a name="ln619">    case WAND_DISINTEGRATION:  return &quot;disintegration&quot;;</a>
<a name="ln620">    case WAND_CLOUDS:          return &quot;clouds&quot;;</a>
<a name="ln621">    case WAND_SCATTERSHOT:     return &quot;scattershot&quot;;</a>
<a name="ln622">    default:                   return item_type_removed(OBJ_WANDS, wandtype)</a>
<a name="ln623">                                    ? &quot;removedness&quot;</a>
<a name="ln624">                                    : &quot;bugginess&quot;;</a>
<a name="ln625">    }</a>
<a name="ln626">}</a>
<a name="ln627"> </a>
<a name="ln628">static const char* wand_secondary_string(uint32_t s)</a>
<a name="ln629">{</a>
<a name="ln630">    static const char* const secondary_strings[] = {</a>
<a name="ln631">        &quot;&quot;, &quot;jewelled &quot;, &quot;curved &quot;, &quot;long &quot;, &quot;short &quot;, &quot;twisted &quot;, &quot;crooked &quot;,</a>
<a name="ln632">        &quot;forked &quot;, &quot;shiny &quot;, &quot;blackened &quot;, &quot;tapered &quot;, &quot;glowing &quot;, &quot;worn &quot;,</a>
<a name="ln633">        &quot;encrusted &quot;, &quot;runed &quot;, &quot;sharpened &quot;</a>
<a name="ln634">    };</a>
<a name="ln635">    COMPILE_CHECK(ARRAYSZ(secondary_strings) == NDSC_WAND_SEC);</a>
<a name="ln636">    return secondary_strings[s % NDSC_WAND_SEC];</a>
<a name="ln637">}</a>
<a name="ln638"> </a>
<a name="ln639">static const char* wand_primary_string(uint32_t p)</a>
<a name="ln640">{</a>
<a name="ln641">    static const char* const primary_strings[] = {</a>
<a name="ln642">        &quot;iron&quot;, &quot;brass&quot;, &quot;bone&quot;, &quot;wooden&quot;, &quot;copper&quot;, &quot;gold&quot;, &quot;silver&quot;,</a>
<a name="ln643">        &quot;bronze&quot;, &quot;ivory&quot;, &quot;glass&quot;, &quot;lead&quot;, &quot;fluorescent&quot;</a>
<a name="ln644">    };</a>
<a name="ln645">    COMPILE_CHECK(ARRAYSZ(primary_strings) == NDSC_WAND_PRI);</a>
<a name="ln646">    return primary_strings[p % NDSC_WAND_PRI];</a>
<a name="ln647">}</a>
<a name="ln648"> </a>
<a name="ln649">const char* potion_type_name(int potiontype)</a>
<a name="ln650">{</a>
<a name="ln651">    switch (static_cast&lt;potion_type&gt;(potiontype))</a>
<a name="ln652">    {</a>
<a name="ln653">    case POT_CURING:            return &quot;curing&quot;;</a>
<a name="ln654">    case POT_HEAL_WOUNDS:       return &quot;heal wounds&quot;;</a>
<a name="ln655">    case POT_HASTE:             return &quot;haste&quot;;</a>
<a name="ln656">    case POT_MIGHT:             return &quot;might&quot;;</a>
<a name="ln657">    case POT_STABBING:          return &quot;stabbing&quot;;</a>
<a name="ln658">    case POT_BRILLIANCE:        return &quot;brilliance&quot;;</a>
<a name="ln659">    case POT_FLIGHT:            return &quot;flight&quot;;</a>
<a name="ln660">    case POT_CANCELLATION:      return &quot;cancellation&quot;;</a>
<a name="ln661">    case POT_AMBROSIA:          return &quot;ambrosia&quot;;</a>
<a name="ln662">    case POT_INVISIBILITY:      return &quot;invisibility&quot;;</a>
<a name="ln663">    case POT_DEGENERATION:      return &quot;degeneration&quot;;</a>
<a name="ln664">    case POT_EXPERIENCE:        return &quot;experience&quot;;</a>
<a name="ln665">    case POT_MAGIC:             return &quot;magic&quot;;</a>
<a name="ln666">    case POT_BERSERK_RAGE:      return &quot;berserk rage&quot;;</a>
<a name="ln667">    case POT_MUTATION:          return &quot;mutation&quot;;</a>
<a name="ln668">    case POT_RESISTANCE:        return &quot;resistance&quot;;</a>
<a name="ln669">    case POT_LIGNIFY:           return &quot;lignification&quot;;</a>
<a name="ln670"> </a>
<a name="ln671">    // FIXME: Remove this once known-items no longer uses this as a sentinel.</a>
<a name="ln672">    default:</a>
<a name="ln673">                                return &quot;bugginess&quot;;</a>
<a name="ln674">    CASE_REMOVED_POTIONS(potiontype);</a>
<a name="ln675">    }</a>
<a name="ln676">}</a>
<a name="ln677"> </a>
<a name="ln678">static const char* scroll_type_name(int scrolltype)</a>
<a name="ln679">{</a>
<a name="ln680">    switch (static_cast&lt;scroll_type&gt;(scrolltype))</a>
<a name="ln681">    {</a>
<a name="ln682">    case SCR_IDENTIFY:           return &quot;identify&quot;;</a>
<a name="ln683">    case SCR_TELEPORTATION:      return &quot;teleportation&quot;;</a>
<a name="ln684">    case SCR_FEAR:               return &quot;fear&quot;;</a>
<a name="ln685">    case SCR_NOISE:              return &quot;noise&quot;;</a>
<a name="ln686">    case SCR_REMOVE_CURSE:       return &quot;remove curse&quot;;</a>
<a name="ln687">    case SCR_SUMMONING:          return &quot;summoning&quot;;</a>
<a name="ln688">    case SCR_ENCHANT_WEAPON:     return &quot;enchant weapon&quot;;</a>
<a name="ln689">    case SCR_ENCHANT_ARMOUR:     return &quot;enchant armour&quot;;</a>
<a name="ln690">    case SCR_TORMENT:            return &quot;torment&quot;;</a>
<a name="ln691">    case SCR_RANDOM_USELESSNESS: return &quot;random uselessness&quot;;</a>
<a name="ln692">    case SCR_IMMOLATION:         return &quot;immolation&quot;;</a>
<a name="ln693">    case SCR_BLINKING:           return &quot;blinking&quot;;</a>
<a name="ln694">    case SCR_MAGIC_MAPPING:      return &quot;magic mapping&quot;;</a>
<a name="ln695">    case SCR_FOG:                return &quot;fog&quot;;</a>
<a name="ln696">    case SCR_ACQUIREMENT:        return &quot;acquirement&quot;;</a>
<a name="ln697">    case SCR_BRAND_WEAPON:       return &quot;brand weapon&quot;;</a>
<a name="ln698">    case SCR_HOLY_WORD:          return &quot;holy word&quot;;</a>
<a name="ln699">    case SCR_VULNERABILITY:      return &quot;vulnerability&quot;;</a>
<a name="ln700">    case SCR_SILENCE:            return &quot;silence&quot;;</a>
<a name="ln701">    case SCR_AMNESIA:            return &quot;amnesia&quot;;</a>
<a name="ln702">#if TAG_MAJOR_VERSION == 34</a>
<a name="ln703">    case SCR_CURSE_WEAPON:       return &quot;curse weapon&quot;;</a>
<a name="ln704">    case SCR_CURSE_ARMOUR:       return &quot;curse armour&quot;;</a>
<a name="ln705">    case SCR_CURSE_JEWELLERY:    return &quot;curse jewellery&quot;;</a>
<a name="ln706">#endif</a>
<a name="ln707">    default:                     return item_type_removed(OBJ_SCROLLS,</a>
<a name="ln708">                                                          scrolltype)</a>
<a name="ln709">                                     ? &quot;removedness&quot;</a>
<a name="ln710">                                     : &quot;bugginess&quot;;</a>
<a name="ln711">    }</a>
<a name="ln712">}</a>
<a name="ln713"> </a>
<a name="ln714">/**</a>
<a name="ln715"> * Get the name for the effect provided by a kind of jewellery.</a>
<a name="ln716"> *</a>
<a name="ln717"> * @param jeweltype     The jewellery_type of the item in question.</a>
<a name="ln718"> * @return              A string describing the effect of the given jewellery</a>
<a name="ln719"> *                      subtype.</a>
<a name="ln720"> */</a>
<a name="ln721">const char* jewellery_effect_name(int jeweltype, bool terse)</a>
<a name="ln722">{</a>
<a name="ln723">    if (!terse)</a>
<a name="ln724">    {</a>
<a name="ln725">        switch (static_cast&lt;jewellery_type&gt;(jeweltype))</a>
<a name="ln726">        {</a>
<a name="ln727">#if TAG_MAJOR_VERSION == 34</a>
<a name="ln728">        case RING_REGENERATION:          return &quot;obsoleteness&quot;;</a>
<a name="ln729">#endif</a>
<a name="ln730">        case RING_PROTECTION:            return &quot;protection&quot;;</a>
<a name="ln731">        case RING_PROTECTION_FROM_FIRE:  return &quot;protection from fire&quot;;</a>
<a name="ln732">        case RING_POISON_RESISTANCE:     return &quot;poison resistance&quot;;</a>
<a name="ln733">        case RING_PROTECTION_FROM_COLD:  return &quot;protection from cold&quot;;</a>
<a name="ln734">        case RING_STRENGTH:              return &quot;strength&quot;;</a>
<a name="ln735">        case RING_SLAYING:               return &quot;slaying&quot;;</a>
<a name="ln736">        case RING_SEE_INVISIBLE:         return &quot;see invisible&quot;;</a>
<a name="ln737">        case RING_RESIST_CORROSION:      return &quot;resist corrosion&quot;;</a>
<a name="ln738">        case RING_ATTENTION:             return &quot;attention&quot;;</a>
<a name="ln739">        case RING_TELEPORTATION:         return &quot;teleportation&quot;;</a>
<a name="ln740">        case RING_EVASION:               return &quot;evasion&quot;;</a>
<a name="ln741">#if TAG_MAJOR_VERSION == 34</a>
<a name="ln742">        case RING_SUSTAIN_ATTRIBUTES:    return &quot;sustain attributes&quot;;</a>
<a name="ln743">#endif</a>
<a name="ln744">        case RING_STEALTH:               return &quot;stealth&quot;;</a>
<a name="ln745">        case RING_DEXTERITY:             return &quot;dexterity&quot;;</a>
<a name="ln746">        case RING_INTELLIGENCE:          return &quot;intelligence&quot;;</a>
<a name="ln747">        case RING_WIZARDRY:              return &quot;wizardry&quot;;</a>
<a name="ln748">        case RING_MAGICAL_POWER:         return &quot;magical power&quot;;</a>
<a name="ln749">        case RING_FLIGHT:                return &quot;flight&quot;;</a>
<a name="ln750">        case RING_LIFE_PROTECTION:       return &quot;positive energy&quot;;</a>
<a name="ln751">        case RING_PROTECTION_FROM_MAGIC: return &quot;protection from magic&quot;;</a>
<a name="ln752">        case RING_FIRE:                  return &quot;fire&quot;;</a>
<a name="ln753">        case RING_ICE:                   return &quot;ice&quot;;</a>
<a name="ln754">#if TAG_MAJOR_VERSION == 34</a>
<a name="ln755">        case RING_TELEPORT_CONTROL:      return &quot;teleport control&quot;;</a>
<a name="ln756">#endif</a>
<a name="ln757">        case AMU_RAGE:              return &quot;rage&quot;;</a>
<a name="ln758">        case AMU_HARM:              return &quot;harm&quot;;</a>
<a name="ln759">        case AMU_MANA_REGENERATION: return &quot;magic regeneration&quot;;</a>
<a name="ln760">        case AMU_THE_GOURMAND:      return &quot;gourmand&quot;;</a>
<a name="ln761">        case AMU_ACROBAT:           return &quot;the acrobat&quot;;</a>
<a name="ln762">#if TAG_MAJOR_VERSION == 34</a>
<a name="ln763">        case AMU_CONSERVATION:      return &quot;conservation&quot;;</a>
<a name="ln764">        case AMU_CONTROLLED_FLIGHT: return &quot;controlled flight&quot;;</a>
<a name="ln765">#endif</a>
<a name="ln766">        case AMU_INACCURACY:        return &quot;inaccuracy&quot;;</a>
<a name="ln767">        case AMU_NOTHING:           return &quot;nothing&quot;;</a>
<a name="ln768">        case AMU_GUARDIAN_SPIRIT:   return &quot;guardian spirit&quot;;</a>
<a name="ln769">        case AMU_FAITH:             return &quot;faith&quot;;</a>
<a name="ln770">        case AMU_REFLECTION:        return &quot;reflection&quot;;</a>
<a name="ln771">        case AMU_REGENERATION:      return &quot;regeneration&quot;;</a>
<a name="ln772">        default: return &quot;buggy jewellery&quot;;</a>
<a name="ln773">        }</a>
<a name="ln774">    }</a>
<a name="ln775">    else</a>
<a name="ln776">    {</a>
<a name="ln777">        if (jewellery_base_ability_string(jeweltype)[0] != '\0')</a>
<a name="ln778">            return jewellery_base_ability_string(jeweltype);</a>
<a name="ln779">        switch (static_cast&lt;jewellery_type&gt;(jeweltype))</a>
<a name="ln780">        {</a>
<a name="ln781">#if TAG_MAJOR_VERSION == 34</a>
<a name="ln782">        case RING_REGENERATION:          return &quot;obsoleteness&quot;;</a>
<a name="ln783">#endif</a>
<a name="ln784">        case RING_PROTECTION:            return &quot;AC&quot;;</a>
<a name="ln785">        case RING_PROTECTION_FROM_FIRE:  return &quot;rF+&quot;;</a>
<a name="ln786">        case RING_POISON_RESISTANCE:     return &quot;rPois&quot;;</a>
<a name="ln787">        case RING_PROTECTION_FROM_COLD:  return &quot;rC+&quot;;</a>
<a name="ln788">        case RING_STRENGTH:              return &quot;Str&quot;;</a>
<a name="ln789">        case RING_SLAYING:               return &quot;Slay&quot;;</a>
<a name="ln790">        case RING_SEE_INVISIBLE:         return &quot;sInv&quot;;</a>
<a name="ln791">        case RING_RESIST_CORROSION:      return &quot;rCorr&quot;;</a>
<a name="ln792">        case RING_ATTENTION:             return &quot;Stlth-&quot;;</a>
<a name="ln793">        case RING_EVASION:               return &quot;EV&quot;;</a>
<a name="ln794">        case RING_STEALTH:               return &quot;Stlth+&quot;;</a>
<a name="ln795">        case RING_DEXTERITY:             return &quot;Dex&quot;;</a>
<a name="ln796">        case RING_INTELLIGENCE:          return &quot;Int&quot;;</a>
<a name="ln797">        case RING_MAGICAL_POWER:         return &quot;MP+9&quot;;</a>
<a name="ln798">        case RING_FLIGHT:                return &quot;+Fly&quot;;</a>
<a name="ln799">        case RING_LIFE_PROTECTION:       return &quot;rN+&quot;;</a>
<a name="ln800">        case RING_PROTECTION_FROM_MAGIC: return &quot;MR+&quot;;</a>
<a name="ln801">        case AMU_RAGE:                   return &quot;+Rage&quot;;</a>
<a name="ln802">        case AMU_REGENERATION:           return &quot;Regen&quot;;</a>
<a name="ln803">        case AMU_REFLECTION:             return &quot;Reflect&quot;;</a>
<a name="ln804">        case AMU_ACROBAT:                return &quot;Acrobat&quot;;</a>
<a name="ln805">        case AMU_NOTHING:                return &quot;&quot;;</a>
<a name="ln806">        default: return &quot;buggy&quot;;</a>
<a name="ln807">        }</a>
<a name="ln808">    }</a>
<a name="ln809">}</a>
<a name="ln810"> </a>
<a name="ln811">// lua doesn't want &quot;the&quot; in gourmand, but we do, so...</a>
<a name="ln812">static const char* _jewellery_effect_prefix(int jeweltype)</a>
<a name="ln813">{</a>
<a name="ln814">    switch (static_cast&lt;jewellery_type&gt;(jeweltype))</a>
<a name="ln815">    {</a>
<a name="ln816">    case AMU_THE_GOURMAND: return &quot;the &quot;;</a>
<a name="ln817">    default:               return &quot;&quot;;</a>
<a name="ln818">    }</a>
<a name="ln819">}</a>
<a name="ln820"> </a>
<a name="ln821">/**</a>
<a name="ln822"> * Get the name for the category of a type of jewellery.</a>
<a name="ln823"> *</a>
<a name="ln824"> * @param jeweltype     The jewellery_type of the item in question.</a>
<a name="ln825"> * @return              A string describing the kind of jewellery it is.</a>
<a name="ln826"> */</a>
<a name="ln827">static const char* _jewellery_class_name(int jeweltype)</a>
<a name="ln828">{</a>
<a name="ln829">#if TAG_MAJOR_VERSION == 34</a>
<a name="ln830">    if (jeweltype == RING_REGENERATION)</a>
<a name="ln831">        return &quot;ring of&quot;;</a>
<a name="ln832">#endif</a>
<a name="ln833"> </a>
<a name="ln834">    if (jeweltype &lt; RING_FIRST_RING || jeweltype &gt;= NUM_JEWELLERY</a>
<a name="ln835">        || jeweltype &gt;= NUM_RINGS &amp;&amp; jeweltype &lt; AMU_FIRST_AMULET)</a>
<a name="ln836">    {</a>
<a name="ln837">        return &quot;buggy&quot;; // &quot;buggy buggy jewellery&quot;</a>
<a name="ln838">    }</a>
<a name="ln839"> </a>
<a name="ln840">    if (jeweltype &lt; NUM_RINGS)</a>
<a name="ln841">        return &quot;ring of&quot;;</a>
<a name="ln842">    return &quot;amulet of&quot;;</a>
<a name="ln843">}</a>
<a name="ln844"> </a>
<a name="ln845">/**</a>
<a name="ln846"> * Get the name for a type of jewellery.</a>
<a name="ln847"> *</a>
<a name="ln848"> * @param jeweltype     The jewellery_type of the item in question.</a>
<a name="ln849"> * @return              The full name of the jewellery type in question.</a>
<a name="ln850"> */</a>
<a name="ln851">static string jewellery_type_name(int jeweltype)</a>
<a name="ln852">{</a>
<a name="ln853">    return make_stringf(&quot;%s %s%s&quot;, _jewellery_class_name(jeweltype),</a>
<a name="ln854">                                   _jewellery_effect_prefix(jeweltype),</a>
<a name="ln855">                                    jewellery_effect_name(jeweltype));</a>
<a name="ln856">}</a>
<a name="ln857"> </a>
<a name="ln858"> </a>
<a name="ln859">static const char* ring_secondary_string(uint32_t s)</a>
<a name="ln860">{</a>
<a name="ln861">    static const char* const secondary_strings[] = {</a>
<a name="ln862">        &quot;&quot;, &quot;encrusted &quot;, &quot;glowing &quot;, &quot;tubular &quot;, &quot;runed &quot;, &quot;blackened &quot;,</a>
<a name="ln863">        &quot;scratched &quot;, &quot;small &quot;, &quot;large &quot;, &quot;twisted &quot;, &quot;shiny &quot;, &quot;notched &quot;,</a>
<a name="ln864">        &quot;knobbly &quot;</a>
<a name="ln865">    };</a>
<a name="ln866">    COMPILE_CHECK(ARRAYSZ(secondary_strings) == NDSC_JEWEL_SEC);</a>
<a name="ln867">    return secondary_strings[s % NDSC_JEWEL_SEC];</a>
<a name="ln868">}</a>
<a name="ln869"> </a>
<a name="ln870">static const char* ring_primary_string(uint32_t p)</a>
<a name="ln871">{</a>
<a name="ln872">    static const char* const primary_strings[] = {</a>
<a name="ln873">        &quot;wooden&quot;, &quot;silver&quot;, &quot;golden&quot;, &quot;iron&quot;, &quot;steel&quot;, &quot;tourmaline&quot;, &quot;brass&quot;,</a>
<a name="ln874">        &quot;copper&quot;, &quot;granite&quot;, &quot;ivory&quot;, &quot;ruby&quot;, &quot;marble&quot;, &quot;jade&quot;, &quot;glass&quot;,</a>
<a name="ln875">        &quot;agate&quot;, &quot;bone&quot;, &quot;diamond&quot;, &quot;emerald&quot;, &quot;peridot&quot;, &quot;garnet&quot;, &quot;opal&quot;,</a>
<a name="ln876">        &quot;pearl&quot;, &quot;coral&quot;, &quot;sapphire&quot;, &quot;cabochon&quot;, &quot;gilded&quot;, &quot;onyx&quot;, &quot;bronze&quot;,</a>
<a name="ln877">        &quot;moonstone&quot;</a>
<a name="ln878">    };</a>
<a name="ln879">    COMPILE_CHECK(ARRAYSZ(primary_strings) == NDSC_JEWEL_PRI);</a>
<a name="ln880">    return primary_strings[p % NDSC_JEWEL_PRI];</a>
<a name="ln881">}</a>
<a name="ln882"> </a>
<a name="ln883">static const char* amulet_secondary_string(uint32_t s)</a>
<a name="ln884">{</a>
<a name="ln885">    static const char* const secondary_strings[] = {</a>
<a name="ln886">        &quot;dented &quot;, &quot;square &quot;, &quot;thick &quot;, &quot;thin &quot;, &quot;runed &quot;, &quot;blackened &quot;,</a>
<a name="ln887">        &quot;glowing &quot;, &quot;small &quot;, &quot;large &quot;, &quot;twisted &quot;, &quot;tiny &quot;, &quot;triangular &quot;,</a>
<a name="ln888">        &quot;lumpy &quot;</a>
<a name="ln889">    };</a>
<a name="ln890">    COMPILE_CHECK(ARRAYSZ(secondary_strings) == NDSC_JEWEL_SEC);</a>
<a name="ln891">    return secondary_strings[s % NDSC_JEWEL_SEC];</a>
<a name="ln892">}</a>
<a name="ln893"> </a>
<a name="ln894">static const char* amulet_primary_string(uint32_t p)</a>
<a name="ln895">{</a>
<a name="ln896">    static const char* const primary_strings[] = {</a>
<a name="ln897">        &quot;sapphire&quot;, &quot;zirconium&quot;, &quot;golden&quot;, &quot;emerald&quot;, &quot;garnet&quot;, &quot;bronze&quot;,</a>
<a name="ln898">        &quot;brass&quot;, &quot;copper&quot;, &quot;ruby&quot;, &quot;citrine&quot;, &quot;bone&quot;, &quot;platinum&quot;, &quot;jade&quot;,</a>
<a name="ln899">        &quot;fluorescent&quot;, &quot;amethyst&quot;, &quot;cameo&quot;, &quot;pearl&quot;, &quot;blue&quot;, &quot;peridot&quot;,</a>
<a name="ln900">        &quot;jasper&quot;, &quot;diamond&quot;, &quot;malachite&quot;, &quot;steel&quot;, &quot;cabochon&quot;, &quot;silver&quot;,</a>
<a name="ln901">        &quot;soapstone&quot;, &quot;lapis lazuli&quot;, &quot;filigree&quot;, &quot;beryl&quot;</a>
<a name="ln902">    };</a>
<a name="ln903">    COMPILE_CHECK(ARRAYSZ(primary_strings) == NDSC_JEWEL_PRI);</a>
<a name="ln904">    return primary_strings[p % NDSC_JEWEL_PRI];</a>
<a name="ln905">}</a>
<a name="ln906"> </a>
<a name="ln907">const char* rune_type_name(short p)</a>
<a name="ln908">{</a>
<a name="ln909">    switch (static_cast&lt;rune_type&gt;(p))</a>
<a name="ln910">    {</a>
<a name="ln911">    case RUNE_DIS:         return &quot;iron&quot;;</a>
<a name="ln912">    case RUNE_GEHENNA:     return &quot;obsidian&quot;;</a>
<a name="ln913">    case RUNE_COCYTUS:     return &quot;icy&quot;;</a>
<a name="ln914">    case RUNE_TARTARUS:    return &quot;bone&quot;;</a>
<a name="ln915">    case RUNE_SLIME:       return &quot;slimy&quot;;</a>
<a name="ln916">    case RUNE_VAULTS:      return &quot;silver&quot;;</a>
<a name="ln917">    case RUNE_SNAKE:       return &quot;serpentine&quot;;</a>
<a name="ln918">    case RUNE_ELF:         return &quot;elven&quot;;</a>
<a name="ln919">    case RUNE_TOMB:        return &quot;golden&quot;;</a>
<a name="ln920">    case RUNE_SWAMP:       return &quot;decaying&quot;;</a>
<a name="ln921">    case RUNE_SHOALS:      return &quot;barnacled&quot;;</a>
<a name="ln922">    case RUNE_SPIDER:      return &quot;gossamer&quot;;</a>
<a name="ln923">    case RUNE_FOREST:      return &quot;mossy&quot;;</a>
<a name="ln924"> </a>
<a name="ln925">    // pandemonium and abyss runes:</a>
<a name="ln926">    case RUNE_DEMONIC:     return &quot;demonic&quot;;</a>
<a name="ln927">    case RUNE_ABYSSAL:     return &quot;abyssal&quot;;</a>
<a name="ln928"> </a>
<a name="ln929">    // special pandemonium runes:</a>
<a name="ln930">    case RUNE_MNOLEG:      return &quot;glowing&quot;;</a>
<a name="ln931">    case RUNE_LOM_LOBON:   return &quot;magical&quot;;</a>
<a name="ln932">    case RUNE_CEREBOV:     return &quot;fiery&quot;;</a>
<a name="ln933">    case RUNE_GLOORX_VLOQ: return &quot;dark&quot;;</a>
<a name="ln934">    default:               return &quot;buggy&quot;;</a>
<a name="ln935">    }</a>
<a name="ln936">}</a>
<a name="ln937"> </a>
<a name="ln938">static string misc_type_name(int type)</a>
<a name="ln939">{</a>
<a name="ln940">#if TAG_MAJOR_VERSION == 34</a>
<a name="ln941">    if (is_deck_type(type))</a>
<a name="ln942">        return &quot;removed deck&quot;;</a>
<a name="ln943">#endif</a>
<a name="ln944"> </a>
<a name="ln945">    switch (static_cast&lt;misc_item_type&gt;(type))</a>
<a name="ln946">    {</a>
<a name="ln947">#if TAG_MAJOR_VERSION == 34</a>
<a name="ln948">    case MISC_CRYSTAL_BALL_OF_ENERGY:    return &quot;removed crystal ball&quot;;</a>
<a name="ln949">#endif</a>
<a name="ln950">    case MISC_BOX_OF_BEASTS:             return &quot;box of beasts&quot;;</a>
<a name="ln951">#if TAG_MAJOR_VERSION == 34</a>
<a name="ln952">    case MISC_BUGGY_EBONY_CASKET:        return &quot;removed ebony casket&quot;;</a>
<a name="ln953">    case MISC_FAN_OF_GALES:              return &quot;removed fan of gales&quot;;</a>
<a name="ln954">    case MISC_LAMP_OF_FIRE:              return &quot;removed lamp of fire&quot;;</a>
<a name="ln955">    case MISC_BUGGY_LANTERN_OF_SHADOWS:  return &quot;removed lantern of shadows&quot;;</a>
<a name="ln956">#endif</a>
<a name="ln957">    case MISC_HORN_OF_GERYON:            return &quot;horn of Geryon&quot;;</a>
<a name="ln958">    case MISC_LIGHTNING_ROD:             return &quot;lightning rod&quot;;</a>
<a name="ln959">#if TAG_MAJOR_VERSION == 34</a>
<a name="ln960">    case MISC_BOTTLED_EFREET:            return &quot;empty flask&quot;;</a>
<a name="ln961">    case MISC_RUNE_OF_ZOT:               return &quot;obsolete rune of zot&quot;;</a>
<a name="ln962">    case MISC_STONE_OF_TREMORS:          return &quot;removed stone of tremors&quot;;</a>
<a name="ln963">#endif</a>
<a name="ln964">    case MISC_QUAD_DAMAGE:               return &quot;quad damage&quot;;</a>
<a name="ln965">    case MISC_PHIAL_OF_FLOODS:           return &quot;phial of floods&quot;;</a>
<a name="ln966">#if TAG_MAJOR_VERSION == 34</a>
<a name="ln967">    case MISC_SACK_OF_SPIDERS:           return &quot;removed sack of spiders&quot;;</a>
<a name="ln968">#endif</a>
<a name="ln969">    case MISC_PHANTOM_MIRROR:            return &quot;phantom mirror&quot;;</a>
<a name="ln970">    case MISC_ZIGGURAT:                  return &quot;figurine of a ziggurat&quot;;</a>
<a name="ln971">#if TAG_MAJOR_VERSION == 34</a>
<a name="ln972">    case MISC_XOMS_CHESSBOARD:           return &quot;removed chess piece&quot;;</a>
<a name="ln973">#endif</a>
<a name="ln974">    case MISC_TIN_OF_TREMORSTONES:       return &quot;tin of tremorstones&quot;;</a>
<a name="ln975"> </a>
<a name="ln976">    default:</a>
<a name="ln977">        return &quot;buggy miscellaneous item&quot;;</a>
<a name="ln978">    }</a>
<a name="ln979">}</a>
<a name="ln980"> </a>
<a name="ln981">static bool _book_visually_special(uint32_t s)</a>
<a name="ln982">{</a>
<a name="ln983">    return s &amp; 128; // one in ten books; c.f. item_colour()</a>
<a name="ln984">}</a>
<a name="ln985"> </a>
<a name="ln986">static const char* book_secondary_string(uint32_t s)</a>
<a name="ln987">{</a>
<a name="ln988">    if (!_book_visually_special(s))</a>
<a name="ln989">        return &quot;&quot;;</a>
<a name="ln990"> </a>
<a name="ln991">    static const char* const secondary_strings[] = {</a>
<a name="ln992">        &quot;&quot;, &quot;chunky &quot;, &quot;thick &quot;, &quot;thin &quot;, &quot;wide &quot;, &quot;glowing &quot;,</a>
<a name="ln993">        &quot;dog-eared &quot;, &quot;oblong &quot;, &quot;runed &quot;, &quot;&quot;, &quot;&quot;, &quot;&quot;</a>
<a name="ln994">    };</a>
<a name="ln995">    return secondary_strings[(s / NDSC_BOOK_PRI) % ARRAYSZ(secondary_strings)];</a>
<a name="ln996">}</a>
<a name="ln997"> </a>
<a name="ln998">static const char* book_primary_string(uint32_t p)</a>
<a name="ln999">{</a>
<a name="ln1000">    static const char* const primary_strings[] = {</a>
<a name="ln1001">        &quot;paperback&quot;, &quot;hardcover&quot;, &quot;leatherbound&quot;, &quot;metal-bound&quot;, &quot;papyrus&quot;,</a>
<a name="ln1002">    };</a>
<a name="ln1003">    COMPILE_CHECK(NDSC_BOOK_PRI == ARRAYSZ(primary_strings));</a>
<a name="ln1004"> </a>
<a name="ln1005">    return primary_strings[p % ARRAYSZ(primary_strings)];</a>
<a name="ln1006">}</a>
<a name="ln1007"> </a>
<a name="ln1008">static const char* _book_type_name(int booktype)</a>
<a name="ln1009">{</a>
<a name="ln1010">    switch (static_cast&lt;book_type&gt;(booktype))</a>
<a name="ln1011">    {</a>
<a name="ln1012">    case BOOK_MINOR_MAGIC:            return &quot;Minor Magic&quot;;</a>
<a name="ln1013">    case BOOK_CONJURATIONS:           return &quot;Conjurations&quot;;</a>
<a name="ln1014">    case BOOK_FLAMES:                 return &quot;Flames&quot;;</a>
<a name="ln1015">    case BOOK_FROST:                  return &quot;Frost&quot;;</a>
<a name="ln1016">    case BOOK_SUMMONINGS:             return &quot;Summonings&quot;;</a>
<a name="ln1017">    case BOOK_FIRE:                   return &quot;Fire&quot;;</a>
<a name="ln1018">    case BOOK_ICE:                    return &quot;Ice&quot;;</a>
<a name="ln1019">    case BOOK_SPATIAL_TRANSLOCATIONS: return &quot;Spatial Translocations&quot;;</a>
<a name="ln1020">    case BOOK_HEXES:                  return &quot;Hexes&quot;;</a>
<a name="ln1021">    case BOOK_TEMPESTS:               return &quot;the Tempests&quot;;</a>
<a name="ln1022">    case BOOK_DEATH:                  return &quot;Death&quot;;</a>
<a name="ln1023">    case BOOK_MISFORTUNE:             return &quot;Misfortune&quot;;</a>
<a name="ln1024">    case BOOK_CHANGES:                return &quot;Changes&quot;;</a>
<a name="ln1025">    case BOOK_TRANSFIGURATIONS:       return &quot;Transfigurations&quot;;</a>
<a name="ln1026">    case BOOK_BATTLE:                 return &quot;Battle&quot;;</a>
<a name="ln1027">    case BOOK_CLOUDS:                 return &quot;Clouds&quot;;</a>
<a name="ln1028">    case BOOK_NECROMANCY:             return &quot;Necromancy&quot;;</a>
<a name="ln1029">    case BOOK_CALLINGS:               return &quot;Callings&quot;;</a>
<a name="ln1030">    case BOOK_MALEDICT:               return &quot;Maledictions&quot;;</a>
<a name="ln1031">    case BOOK_AIR:                    return &quot;Air&quot;;</a>
<a name="ln1032">    case BOOK_SKY:                    return &quot;the Sky&quot;;</a>
<a name="ln1033">    case BOOK_WARP:                   return &quot;the Warp&quot;;</a>
<a name="ln1034">#if TAG_MAJOR_VERSION == 34</a>
<a name="ln1035">    case BOOK_ENVENOMATIONS:          return &quot;Envenomations&quot;;</a>
<a name="ln1036">#endif</a>
<a name="ln1037">    case BOOK_ANNIHILATIONS:          return &quot;Annihilations&quot;;</a>
<a name="ln1038">    case BOOK_UNLIFE:                 return &quot;Unlife&quot;;</a>
<a name="ln1039">#if TAG_MAJOR_VERSION == 34</a>
<a name="ln1040">    case BOOK_CONTROL:                return &quot;Control&quot;;</a>
<a name="ln1041">#endif</a>
<a name="ln1042">    case BOOK_GEOMANCY:               return &quot;Geomancy&quot;;</a>
<a name="ln1043">    case BOOK_EARTH:                  return &quot;the Earth&quot;;</a>
<a name="ln1044">#if TAG_MAJOR_VERSION == 34</a>
<a name="ln1045">    case BOOK_WIZARDRY:               return &quot;Wizardry&quot;;</a>
<a name="ln1046">#endif</a>
<a name="ln1047">    case BOOK_POWER:                  return &quot;Power&quot;;</a>
<a name="ln1048">    case BOOK_CANTRIPS:               return &quot;Cantrips&quot;;</a>
<a name="ln1049">    case BOOK_PARTY_TRICKS:           return &quot;Party Tricks&quot;;</a>
<a name="ln1050">    case BOOK_DEBILITATION:           return &quot;Debilitation&quot;;</a>
<a name="ln1051">    case BOOK_DRAGON:                 return &quot;the Dragon&quot;;</a>
<a name="ln1052">    case BOOK_BURGLARY:               return &quot;Burglary&quot;;</a>
<a name="ln1053">    case BOOK_DREAMS:                 return &quot;Dreams&quot;;</a>
<a name="ln1054">    case BOOK_ALCHEMY:                return &quot;Alchemy&quot;;</a>
<a name="ln1055">    case BOOK_BEASTS:                 return &quot;Beasts&quot;;</a>
<a name="ln1056">    case BOOK_RANDART_LEVEL:          return &quot;Fixed Level&quot;;</a>
<a name="ln1057">    case BOOK_RANDART_THEME:          return &quot;Fixed Theme&quot;;</a>
<a name="ln1058">    default:                          return &quot;Bugginess&quot;;</a>
<a name="ln1059">    }</a>
<a name="ln1060">}</a>
<a name="ln1061"> </a>
<a name="ln1062">static const char* staff_secondary_string(uint32_t s)</a>
<a name="ln1063">{</a>
<a name="ln1064">    static const char* const secondary_strings[] = {</a>
<a name="ln1065">        &quot;crooked &quot;, &quot;knobbly &quot;, &quot;weird &quot;, &quot;gnarled &quot;, &quot;thin &quot;, &quot;curved &quot;,</a>
<a name="ln1066">        &quot;twisted &quot;, &quot;thick &quot;, &quot;long &quot;, &quot;short &quot;,</a>
<a name="ln1067">    };</a>
<a name="ln1068">    COMPILE_CHECK(NDSC_STAVE_SEC == ARRAYSZ(secondary_strings));</a>
<a name="ln1069">    return secondary_strings[s % ARRAYSZ(secondary_strings)];</a>
<a name="ln1070">}</a>
<a name="ln1071"> </a>
<a name="ln1072">static const char* staff_primary_string(uint32_t p)</a>
<a name="ln1073">{</a>
<a name="ln1074">    static const char* const primary_strings[] = {</a>
<a name="ln1075">        &quot;glowing &quot;, &quot;jewelled &quot;, &quot;runed &quot;, &quot;smoking &quot;</a>
<a name="ln1076">    };</a>
<a name="ln1077">    COMPILE_CHECK(NDSC_STAVE_PRI == ARRAYSZ(primary_strings));</a>
<a name="ln1078">    return primary_strings[p % ARRAYSZ(primary_strings)];</a>
<a name="ln1079">}</a>
<a name="ln1080"> </a>
<a name="ln1081">static const char* staff_type_name(int stafftype)</a>
<a name="ln1082">{</a>
<a name="ln1083">    switch ((stave_type)stafftype)</a>
<a name="ln1084">    {</a>
<a name="ln1085">    case STAFF_WIZARDRY:    return &quot;wizardry&quot;;</a>
<a name="ln1086">#if TAG_MAJOR_VERSION == 34</a>
<a name="ln1087">    case STAFF_POWER:       return &quot;power&quot;;</a>
<a name="ln1088">#endif</a>
<a name="ln1089">    case STAFF_FIRE:        return &quot;fire&quot;;</a>
<a name="ln1090">    case STAFF_COLD:        return &quot;cold&quot;;</a>
<a name="ln1091">    case STAFF_POISON:      return &quot;poison&quot;;</a>
<a name="ln1092">    case STAFF_ENERGY:      return &quot;energy&quot;;</a>
<a name="ln1093">    case STAFF_DEATH:       return &quot;death&quot;;</a>
<a name="ln1094">    case STAFF_CONJURATION: return &quot;conjuration&quot;;</a>
<a name="ln1095">#if TAG_MAJOR_VERSION == 34</a>
<a name="ln1096">    case STAFF_ENCHANTMENT: return &quot;enchantment&quot;;</a>
<a name="ln1097">#endif</a>
<a name="ln1098">    case STAFF_AIR:         return &quot;air&quot;;</a>
<a name="ln1099">    case STAFF_EARTH:       return &quot;earth&quot;;</a>
<a name="ln1100">    case STAFF_SUMMONING:   return &quot;summoning&quot;;</a>
<a name="ln1101">    default:                return &quot;bugginess&quot;;</a>
<a name="ln1102">    }</a>
<a name="ln1103">}</a>
<a name="ln1104"> </a>
<a name="ln1105">const char *base_type_string(const item_def &amp;item)</a>
<a name="ln1106">{</a>
<a name="ln1107">    return base_type_string(item.base_type);</a>
<a name="ln1108">}</a>
<a name="ln1109"> </a>
<a name="ln1110">const char *base_type_string(object_class_type type)</a>
<a name="ln1111">{</a>
<a name="ln1112">    switch (type)</a>
<a name="ln1113">    {</a>
<a name="ln1114">    case OBJ_WEAPONS: return &quot;weapon&quot;;</a>
<a name="ln1115">    case OBJ_MISSILES: return &quot;missile&quot;;</a>
<a name="ln1116">    case OBJ_ARMOUR: return &quot;armour&quot;;</a>
<a name="ln1117">    case OBJ_WANDS: return &quot;wand&quot;;</a>
<a name="ln1118">    case OBJ_FOOD: return &quot;food&quot;;</a>
<a name="ln1119">    case OBJ_SCROLLS: return &quot;scroll&quot;;</a>
<a name="ln1120">    case OBJ_JEWELLERY: return &quot;jewellery&quot;;</a>
<a name="ln1121">    case OBJ_POTIONS: return &quot;potion&quot;;</a>
<a name="ln1122">    case OBJ_BOOKS: return &quot;book&quot;;</a>
<a name="ln1123">    case OBJ_STAVES: return &quot;staff&quot;;</a>
<a name="ln1124">#if TAG_MAJOR_VERSION == 34</a>
<a name="ln1125">    case OBJ_RODS: return &quot;removed rod&quot;;</a>
<a name="ln1126">#endif</a>
<a name="ln1127">    case OBJ_ORBS: return &quot;orb&quot;;</a>
<a name="ln1128">    case OBJ_MISCELLANY: return &quot;miscellaneous&quot;;</a>
<a name="ln1129">    case OBJ_CORPSES: return &quot;corpse&quot;;</a>
<a name="ln1130">    case OBJ_GOLD: return &quot;gold&quot;;</a>
<a name="ln1131">    case OBJ_RUNES: return &quot;rune&quot;;</a>
<a name="ln1132">    default: return &quot;&quot;;</a>
<a name="ln1133">    }</a>
<a name="ln1134">}</a>
<a name="ln1135"> </a>
<a name="ln1136">string sub_type_string(const item_def &amp;item, bool known)</a>
<a name="ln1137">{</a>
<a name="ln1138">    const object_class_type type = item.base_type;</a>
<a name="ln1139">    const int sub_type = item.sub_type;</a>
<a name="ln1140"> </a>
<a name="ln1141">    switch (type)</a>
<a name="ln1142">    {</a>
<a name="ln1143">    case OBJ_WEAPONS:  // deliberate fall through, as XXX_prop is a local</a>
<a name="ln1144">    case OBJ_MISSILES: // variable to item-prop.cc.</a>
<a name="ln1145">    case OBJ_ARMOUR:</a>
<a name="ln1146">        return item_base_name(type, sub_type);</a>
<a name="ln1147">    case OBJ_WANDS: return _wand_type_name(sub_type);</a>
<a name="ln1148">    case OBJ_FOOD: return food_type_name(sub_type);</a>
<a name="ln1149">    case OBJ_SCROLLS: return scroll_type_name(sub_type);</a>
<a name="ln1150">    case OBJ_JEWELLERY: return jewellery_type_name(sub_type);</a>
<a name="ln1151">    case OBJ_POTIONS: return potion_type_name(sub_type);</a>
<a name="ln1152">    case OBJ_BOOKS:</a>
<a name="ln1153">    {</a>
<a name="ln1154">        if (sub_type == BOOK_MANUAL)</a>
<a name="ln1155">        {</a>
<a name="ln1156">            if (!known)</a>
<a name="ln1157">                return &quot;manual&quot;;</a>
<a name="ln1158">            string bookname = &quot;manual of &quot;;</a>
<a name="ln1159">            bookname += skill_name(static_cast&lt;skill_type&gt;(item.plus));</a>
<a name="ln1160">            return bookname;</a>
<a name="ln1161">        }</a>
<a name="ln1162">        else if (sub_type == BOOK_NECRONOMICON)</a>
<a name="ln1163">            return &quot;Necronomicon&quot;;</a>
<a name="ln1164">        else if (sub_type == BOOK_GRAND_GRIMOIRE)</a>
<a name="ln1165">            return &quot;Grand Grimoire&quot;;</a>
<a name="ln1166">#if TAG_MAJOR_VERSION == 34</a>
<a name="ln1167">        else if (sub_type == BOOK_BUGGY_DESTRUCTION)</a>
<a name="ln1168">            return &quot;tome of obsoleteness&quot;;</a>
<a name="ln1169">#endif</a>
<a name="ln1170">        else if (sub_type == BOOK_YOUNG_POISONERS)</a>
<a name="ln1171">            return &quot;Young Poisoner's Handbook&quot;;</a>
<a name="ln1172">        else if (sub_type == BOOK_FEN)</a>
<a name="ln1173">            return &quot;Fen Folio&quot;;</a>
<a name="ln1174">#if TAG_MAJOR_VERSION == 34</a>
<a name="ln1175">        else if (sub_type == BOOK_AKASHIC_RECORD)</a>
<a name="ln1176">            return &quot;Akashic Record&quot;;</a>
<a name="ln1177">#endif</a>
<a name="ln1178"> </a>
<a name="ln1179">        return string(&quot;book of &quot;) + _book_type_name(sub_type);</a>
<a name="ln1180">    }</a>
<a name="ln1181">    case OBJ_STAVES: return staff_type_name(static_cast&lt;stave_type&gt;(sub_type));</a>
<a name="ln1182">#if TAG_MAJOR_VERSION == 34</a>
<a name="ln1183">    case OBJ_RODS:   return &quot;removed rod&quot;;</a>
<a name="ln1184">#endif</a>
<a name="ln1185">    case OBJ_MISCELLANY: return misc_type_name(sub_type);</a>
<a name="ln1186">    // these repeat as base_type_string</a>
<a name="ln1187">    case OBJ_ORBS: return &quot;orb of Zot&quot;;</a>
<a name="ln1188">    case OBJ_CORPSES: return &quot;corpse&quot;;</a>
<a name="ln1189">    case OBJ_GOLD: return &quot;gold&quot;;</a>
<a name="ln1190">    case OBJ_RUNES: return &quot;rune of Zot&quot;;</a>
<a name="ln1191">    default: return &quot;&quot;;</a>
<a name="ln1192">    }</a>
<a name="ln1193">}</a>
<a name="ln1194"> </a>
<a name="ln1195">/**</a>
<a name="ln1196"> * What's the name for the weapon used by a given ghost / pan lord?</a>
<a name="ln1197"> *</a>
<a name="ln1198"> * There's no actual weapon info, just brand, so we have to improvise...</a>
<a name="ln1199"> *</a>
<a name="ln1200"> * @param brand     The brand_type used by the ghost or pan lord.</a>
<a name="ln1201"> * @param mtype     Monster type; determines whether the fake weapon is</a>
<a name="ln1202"> *                  described as a `weapon` or a `touch`.</a>
<a name="ln1203"> * @return          The name of the ghost's weapon (e.g. &quot;weapon of flaming&quot;,</a>
<a name="ln1204"> *                  &quot;antimagic weapon&quot;). SPWPN_NORMAL returns &quot;&quot;.</a>
<a name="ln1205"> */</a>
<a name="ln1206">string ghost_brand_name(brand_type brand, monster_type mtype)</a>
<a name="ln1207">{</a>
<a name="ln1208">    if (brand == SPWPN_NORMAL)</a>
<a name="ln1209">        return &quot;&quot;;</a>
<a name="ln1210">    const bool weapon = mtype != MONS_PANDEMONIUM_LORD;</a>
<a name="ln1211">    if (weapon)</a>
<a name="ln1212">    {</a>
<a name="ln1213">        // n.b. vorpal only works if it is adjectival</a>
<a name="ln1214">        if (brand_prefers_adj.count(brand))</a>
<a name="ln1215">            return make_stringf(&quot;%s weapon&quot;, brand_type_adj(brand));</a>
<a name="ln1216">        else</a>
<a name="ln1217">            return make_stringf(&quot;weapon of %s&quot;, brand_type_name(brand, false));</a>
<a name="ln1218">    }</a>
<a name="ln1219">    else</a>
<a name="ln1220">        return make_stringf(&quot;%s touch&quot;, brand_type_adj(brand));</a>
<a name="ln1221">}</a>
<a name="ln1222"> </a>
<a name="ln1223">string ego_type_string(const item_def &amp;item, bool terse)</a>
<a name="ln1224">{</a>
<a name="ln1225">    switch (item.base_type)</a>
<a name="ln1226">    {</a>
<a name="ln1227">    case OBJ_ARMOUR:</a>
<a name="ln1228">        return armour_ego_name(item, terse);</a>
<a name="ln1229">    case OBJ_WEAPONS:</a>
<a name="ln1230">        if (get_weapon_brand(item) != SPWPN_NORMAL)</a>
<a name="ln1231">            return weapon_brand_name(item, terse);</a>
<a name="ln1232">        else</a>
<a name="ln1233">            return &quot;&quot;;</a>
<a name="ln1234">    case OBJ_MISSILES:</a>
<a name="ln1235">        // HACKHACKHACK</a>
<a name="ln1236">        if (item.props.exists(DAMNATION_BOLT_KEY))</a>
<a name="ln1237">            return &quot;damnation&quot;;</a>
<a name="ln1238">        return missile_brand_name(item, terse ? MBN_TERSE : MBN_BRAND);</a>
<a name="ln1239">    case OBJ_JEWELLERY:</a>
<a name="ln1240">        return jewellery_effect_name(item.sub_type, terse);</a>
<a name="ln1241">    default:</a>
<a name="ln1242">        return &quot;&quot;;</a>
<a name="ln1243">    }</a>
<a name="ln1244">}</a>
<a name="ln1245"> </a>
<a name="ln1246">/**</a>
<a name="ln1247"> * When naming the given item, should the base name be used?</a>
<a name="ln1248"> */</a>
<a name="ln1249">static bool _use_basename(const item_def &amp;item, description_level_type desc,</a>
<a name="ln1250">                          bool ident)</a>
<a name="ln1251">{</a>
<a name="ln1252">    const bool know_type = ident || item_type_known(item);</a>
<a name="ln1253">    return desc == DESC_BASENAME</a>
<a name="ln1254">           || desc == DESC_DBNAME &amp;&amp; !know_type;</a>
<a name="ln1255">}</a>
<a name="ln1256"> </a>
<a name="ln1257">/**</a>
<a name="ln1258"> * When naming the given item, should identifiable properties be mentioned?</a>
<a name="ln1259"> */</a>
<a name="ln1260">static bool _know_any_ident(const item_def &amp;item, description_level_type desc,</a>
<a name="ln1261">                            bool ident)</a>
<a name="ln1262">{</a>
<a name="ln1263">    return desc != DESC_QUALNAME &amp;&amp; desc != DESC_DBNAME</a>
<a name="ln1264">           &amp;&amp; !_use_basename(item, desc, ident);</a>
<a name="ln1265">}</a>
<a name="ln1266"> </a>
<a name="ln1267">/**</a>
<a name="ln1268"> * When naming the given item, should the specified identifiable property be</a>
<a name="ln1269"> * mentioned?</a>
<a name="ln1270"> */</a>
<a name="ln1271">static bool _know_ident(const item_def &amp;item, description_level_type desc,</a>
<a name="ln1272">                        bool ident, iflags_t ignore_flags,</a>
<a name="ln1273">                        item_status_flag_type vprop)</a>
<a name="ln1274">{</a>
<a name="ln1275">    return _know_any_ident(item, desc, ident)</a>
<a name="ln1276">            &amp;&amp; !testbits(ignore_flags, vprop)</a>
<a name="ln1277">            &amp;&amp; (ident || item_ident(item, vprop));</a>
<a name="ln1278">}</a>
<a name="ln1279"> </a>
<a name="ln1280">/**</a>
<a name="ln1281"> * When naming the given item, should the curse be mentioned?</a>
<a name="ln1282"> */</a>
<a name="ln1283">static bool _know_curse(const item_def &amp;item, description_level_type desc,</a>
<a name="ln1284">                        bool ident, iflags_t ignore_flags)</a>
<a name="ln1285">{</a>
<a name="ln1286">    return _know_ident(item, desc, ident, ignore_flags, ISFLAG_KNOW_CURSE);</a>
<a name="ln1287">}</a>
<a name="ln1288"> </a>
<a name="ln1289">/**</a>
<a name="ln1290"> * When naming the given item, should the pluses be mentioned?</a>
<a name="ln1291"> */</a>
<a name="ln1292">static bool _know_pluses(const item_def &amp;item, description_level_type desc,</a>
<a name="ln1293">                          bool ident, iflags_t ignore_flags)</a>
<a name="ln1294">{</a>
<a name="ln1295">    return _know_ident(item, desc, ident, ignore_flags, ISFLAG_KNOW_PLUSES);</a>
<a name="ln1296">}</a>
<a name="ln1297"> </a>
<a name="ln1298">/**</a>
<a name="ln1299"> * When naming the given item, should the brand be mentioned?</a>
<a name="ln1300"> */</a>
<a name="ln1301">static bool _know_ego(const item_def &amp;item, description_level_type desc,</a>
<a name="ln1302">                         bool ident, iflags_t ignore_flags)</a>
<a name="ln1303">{</a>
<a name="ln1304">    return _know_any_ident(item, desc, ident)</a>
<a name="ln1305">           &amp;&amp; !testbits(ignore_flags, ISFLAG_KNOW_TYPE)</a>
<a name="ln1306">           &amp;&amp; (ident || item_type_known(item));</a>
<a name="ln1307">}</a>
<a name="ln1308"> </a>
<a name="ln1309">/**</a>
<a name="ln1310"> * The curse-describing prefix to a weapon's name, including trailing space if</a>
<a name="ln1311"> * appropriate. (Empty if the weapon isn't cursed, or if the curse shouldn't be</a>
<a name="ln1312"> * prefixed.)</a>
<a name="ln1313"> */</a>
<a name="ln1314">static string _curse_prefix(const item_def &amp;weap, description_level_type desc,</a>
<a name="ln1315">                            bool terse, bool ident, iflags_t ignore_flags)</a>
<a name="ln1316">{</a>
<a name="ln1317">    if (!_know_curse(weap, desc, ident, ignore_flags) || terse)</a>
<a name="ln1318">        return &quot;&quot;;</a>
<a name="ln1319"> </a>
<a name="ln1320">    if (weap.cursed())</a>
<a name="ln1321">        return &quot;cursed &quot;;</a>
<a name="ln1322"> </a>
<a name="ln1323">    // We don't bother printing &quot;uncursed&quot; if the item is identified</a>
<a name="ln1324">    // for pluses (its state should be obvious), this is so that</a>
<a name="ln1325">    // the weapon name is kept short (there isn't a lot of room</a>
<a name="ln1326">    // for the name on the main screen). If you're going to change</a>
<a name="ln1327">    // this behaviour, *please* make it so that there is an option</a>
<a name="ln1328">    // that maintains this behaviour. -- bwr</a>
<a name="ln1329">    if (_know_pluses(weap, desc, ident, ignore_flags))</a>
<a name="ln1330">        return &quot;&quot;;</a>
<a name="ln1331">    // Nor for artefacts. Again, the state should be obvious. --jpeg</a>
<a name="ln1332">    if (!ident &amp;&amp; !item_type_known(weap)</a>
<a name="ln1333">        || !is_artefact(weap))</a>
<a name="ln1334">    {</a>
<a name="ln1335">        return &quot;uncursed &quot;;</a>
<a name="ln1336">    }</a>
<a name="ln1337">    return &quot;&quot;;</a>
<a name="ln1338">}</a>
<a name="ln1339"> </a>
<a name="ln1340">/**</a>
<a name="ln1341"> * The plus-describing prefix to a weapon's name, including trailing space.</a>
<a name="ln1342"> */</a>
<a name="ln1343">static string _plus_prefix(const item_def &amp;weap)</a>
<a name="ln1344">{</a>
<a name="ln1345">    if (is_unrandom_artefact(weap, UNRAND_WOE))</a>
<a name="ln1346">        return &quot;+ &quot;;</a>
<a name="ln1347">    return make_stringf(&quot;%+d &quot;, weap.plus);</a>
<a name="ln1348">}</a>
<a name="ln1349"> </a>
<a name="ln1350">/**</a>
<a name="ln1351"> * Cosmetic text for weapons (e.g. glowing, runed). Includes trailing space,</a>
<a name="ln1352"> * if appropriate. (Empty if there is no cosmetic property, or if it's</a>
<a name="ln1353"> * marked to be ignored.)</a>
<a name="ln1354"> */</a>
<a name="ln1355">static string _cosmetic_text(const item_def &amp;weap, iflags_t ignore_flags)</a>
<a name="ln1356">{</a>
<a name="ln1357">    const iflags_t desc = get_equip_desc(weap);</a>
<a name="ln1358">    if (testbits(ignore_flags, desc))</a>
<a name="ln1359">        return &quot;&quot;;</a>
<a name="ln1360"> </a>
<a name="ln1361">    switch (desc)</a>
<a name="ln1362">    {</a>
<a name="ln1363">        case ISFLAG_RUNED:</a>
<a name="ln1364">            return &quot;runed &quot;;</a>
<a name="ln1365">        case ISFLAG_GLOWING:</a>
<a name="ln1366">            return &quot;glowing &quot;;</a>
<a name="ln1367">        default:</a>
<a name="ln1368">            return &quot;&quot;;</a>
<a name="ln1369">    }</a>
<a name="ln1370">}</a>
<a name="ln1371"> </a>
<a name="ln1372">/**</a>
<a name="ln1373"> * Surrounds a given string with the weapon's brand-describing prefix/suffix</a>
<a name="ln1374"> * as appropriate.</a>
<a name="ln1375"> */</a>
<a name="ln1376">string weapon_brand_desc(const char *body, const item_def &amp;weap,</a>
<a name="ln1377">                         bool terse, brand_type override_brand)</a>
<a name="ln1378">{</a>
<a name="ln1379"> </a>
<a name="ln1380">    const string brand_name = weapon_brand_name(weap, terse, override_brand);</a>
<a name="ln1381"> </a>
<a name="ln1382">    if (brand_name.empty())</a>
<a name="ln1383">        return body;</a>
<a name="ln1384"> </a>
<a name="ln1385">    if (terse)</a>
<a name="ln1386">        return make_stringf(&quot;%s (%s)&quot;, body, brand_name.c_str());</a>
<a name="ln1387"> </a>
<a name="ln1388">    switch (override_brand ? override_brand : get_weapon_brand(weap))</a>
<a name="ln1389">    {</a>
<a name="ln1390">        case SPWPN_VAMPIRISM:</a>
<a name="ln1391">            return make_stringf(&quot;vampiric %s&quot;, body);</a>
<a name="ln1392">        case SPWPN_ANTIMAGIC:</a>
<a name="ln1393">            return make_stringf(&quot;antimagic %s&quot;, body);</a>
<a name="ln1394">        case SPWPN_VORPAL:</a>
<a name="ln1395">            return make_stringf(&quot;vorpal %s&quot;, body);</a>
<a name="ln1396">        case SPWPN_NORMAL:</a>
<a name="ln1397">            if (get_equip_desc(weap))</a>
<a name="ln1398">                return make_stringf(&quot;enchanted %s&quot;, body);</a>
<a name="ln1399">            else</a>
<a name="ln1400">                return body;</a>
<a name="ln1401">        default:</a>
<a name="ln1402">            return make_stringf(&quot;%s of %s&quot;, body, brand_name.c_str());</a>
<a name="ln1403">    }</a>
<a name="ln1404">}</a>
<a name="ln1405"> </a>
<a name="ln1406">/**</a>
<a name="ln1407"> * Build the appropriate name for a given weapon.</a>
<a name="ln1408"> *</a>
<a name="ln1409"> * @param weap          The weapon in question.</a>
<a name="ln1410"> * @param desc          The type of name to provide. (E.g. the name to be used</a>
<a name="ln1411"> *                      in database lookups for description, or...)</a>
<a name="ln1412"> * @param terse         Whether to provide a terse version of the name for</a>
<a name="ln1413"> *                      display in the HUD.</a>
<a name="ln1414"> * @param ident         Whether the weapon should be named as if it were</a>
<a name="ln1415"> *                      identified.</a>
<a name="ln1416"> * @param inscr         Whether an inscription will be added later.</a>
<a name="ln1417"> * @param ignore_flags  Identification flags on the weapon to ignore.</a>
<a name="ln1418"> *</a>
<a name="ln1419"> * @return              A name for the weapon.</a>
<a name="ln1420"> *                      TODO: example</a>
<a name="ln1421"> */</a>
<a name="ln1422">static string _name_weapon(const item_def &amp;weap, description_level_type desc,</a>
<a name="ln1423">                           bool terse, bool ident, bool inscr,</a>
<a name="ln1424">                           iflags_t ignore_flags)</a>
<a name="ln1425">{</a>
<a name="ln1426">    const bool dbname   = (desc == DESC_DBNAME);</a>
<a name="ln1427">    const bool basename = _use_basename(weap, desc, ident);</a>
<a name="ln1428">    const bool qualname = (desc == DESC_QUALNAME);</a>
<a name="ln1429"> </a>
<a name="ln1430">    const bool know_curse =  _know_curse(weap, desc, ident, ignore_flags);</a>
<a name="ln1431">    const bool know_pluses = _know_pluses(weap, desc, ident, ignore_flags);</a>
<a name="ln1432">    const bool know_ego =    _know_ego(weap, desc, ident, ignore_flags);</a>
<a name="ln1433"> </a>
<a name="ln1434">    const string curse_prefix</a>
<a name="ln1435">        = _curse_prefix(weap, desc, terse, ident, ignore_flags);</a>
<a name="ln1436">    const string plus_text = know_pluses ? _plus_prefix(weap) : &quot;&quot;;</a>
<a name="ln1437"> </a>
<a name="ln1438">    if (is_artefact(weap) &amp;&amp; !dbname)</a>
<a name="ln1439">    {</a>
<a name="ln1440">        const string long_name = curse_prefix + plus_text</a>
<a name="ln1441">                                 + get_artefact_name(weap, ident);</a>
<a name="ln1442"> </a>
<a name="ln1443">        // crop long artefact names when not controlled by webtiles -</a>
<a name="ln1444">        // webtiles displays weapon names across multiple lines</a>
<a name="ln1445">#ifdef USE_TILE_WEB</a>
<a name="ln1446">        if (!tiles.is_controlled_from_web())</a>
<a name="ln1447">#endif</a>
<a name="ln1448">        {</a>
<a name="ln1449">            const bool has_inscript = desc != DESC_BASENAME</a>
<a name="ln1450">                                   &amp;&amp; desc != DESC_DBNAME</a>
<a name="ln1451">                                   &amp;&amp; inscr;</a>
<a name="ln1452">            const string inscription = _item_inscription(weap);</a>
<a name="ln1453"> </a>
<a name="ln1454">            const int total_length = long_name.size()</a>
<a name="ln1455">                                     + (has_inscript ? inscription.size() : 0);</a>
<a name="ln1456">            const string inv_slot_text = &quot;x) &quot;;</a>
<a name="ln1457">            const int max_length = crawl_view.hudsz.x - inv_slot_text.size();</a>
<a name="ln1458">            if (!terse || total_length &lt;= max_length)</a>
<a name="ln1459">                return long_name;</a>
<a name="ln1460">        }</a>
<a name="ln1461">#ifdef USE_TILE_WEB</a>
<a name="ln1462">        else</a>
<a name="ln1463">            return long_name;</a>
<a name="ln1464">#endif</a>
<a name="ln1465"> </a>
<a name="ln1466">        // special case: these two shouldn't ever have their base name revealed</a>
<a name="ln1467">        // (since showing 'eudaemon blade' is unhelpful in the former case, and</a>
<a name="ln1468">        // showing 'broad axe' is misleading in the latter)</a>
<a name="ln1469">        // could be a flag, but doesn't seem worthwhile for only two items</a>
<a name="ln1470">        if (is_unrandom_artefact(weap, UNRAND_ZEALOT_SWORD)</a>
<a name="ln1471">            || is_unrandom_artefact(weap, UNRAND_DEMON_AXE))</a>
<a name="ln1472">        {</a>
<a name="ln1473">            return long_name;</a>
<a name="ln1474">        }</a>
<a name="ln1475"> </a>
<a name="ln1476">        const string short_name</a>
<a name="ln1477">            = curse_prefix + plus_text + get_artefact_base_name(weap, true);</a>
<a name="ln1478">        return short_name;</a>
<a name="ln1479">    }</a>
<a name="ln1480"> </a>
<a name="ln1481">    const bool show_cosmetic = !basename &amp;&amp; !qualname &amp;&amp; !dbname</a>
<a name="ln1482">                               &amp;&amp; !know_pluses &amp;&amp; !know_ego</a>
<a name="ln1483">                               &amp;&amp; !terse</a>
<a name="ln1484">                               &amp;&amp; !(ignore_flags &amp; ISFLAG_COSMETIC_MASK);</a>
<a name="ln1485"> </a>
<a name="ln1486">    const string cosmetic_text</a>
<a name="ln1487">        = show_cosmetic ? _cosmetic_text(weap, ignore_flags) : &quot;&quot;;</a>
<a name="ln1488">    const string base_name = item_base_name(weap);</a>
<a name="ln1489">    const string name_with_ego</a>
<a name="ln1490">        = know_ego ? weapon_brand_desc(base_name.c_str(), weap, terse)</a>
<a name="ln1491">        : base_name;</a>
<a name="ln1492">    const string curse_suffix</a>
<a name="ln1493">        = know_curse &amp;&amp; weap.cursed() &amp;&amp; terse ? &quot; (curse)&quot; :  &quot;&quot;;</a>
<a name="ln1494">    return curse_prefix + plus_text + cosmetic_text</a>
<a name="ln1495">           + name_with_ego + curse_suffix;</a>
<a name="ln1496">}</a>
<a name="ln1497"> </a>
<a name="ln1498">// Note that &quot;terse&quot; is only currently used for the &quot;in hand&quot; listing on</a>
<a name="ln1499">// the game screen.</a>
<a name="ln1500">string item_def::name_aux(description_level_type desc, bool terse, bool ident,</a>
<a name="ln1501">                          bool with_inscription, iflags_t ignore_flags) const</a>
<a name="ln1502">{</a>
<a name="ln1503">    // Shortcuts</a>
<a name="ln1504">    const int item_typ   = sub_type;</a>
<a name="ln1505"> </a>
<a name="ln1506">    const bool know_type = ident || item_type_known(*this);</a>
<a name="ln1507"> </a>
<a name="ln1508">    const bool dbname   = (desc == DESC_DBNAME);</a>
<a name="ln1509">    const bool basename = _use_basename(*this, desc, ident);</a>
<a name="ln1510">    const bool qualname = (desc == DESC_QUALNAME);</a>
<a name="ln1511"> </a>
<a name="ln1512">    const bool know_curse =  _know_curse(*this, desc, ident, ignore_flags);</a>
<a name="ln1513">    const bool know_pluses = _know_pluses(*this, desc, ident, ignore_flags);</a>
<a name="ln1514">    const bool know_brand =  _know_ego(*this, desc, ident, ignore_flags);</a>
<a name="ln1515"> </a>
<a name="ln1516">    const bool know_ego = know_brand;</a>
<a name="ln1517"> </a>
<a name="ln1518">    // Display runed/glowing/embroidered etc?</a>
<a name="ln1519">    // Only display this if brand is unknown.</a>
<a name="ln1520">    const bool show_cosmetic = !know_pluses &amp;&amp; !know_brand</a>
<a name="ln1521">                               &amp;&amp; !basename &amp;&amp; !qualname &amp;&amp; !dbname</a>
<a name="ln1522">                               &amp;&amp; !terse</a>
<a name="ln1523">                               &amp;&amp; !(ignore_flags &amp; ISFLAG_COSMETIC_MASK);</a>
<a name="ln1524"> </a>
<a name="ln1525">    const bool need_plural = !basename &amp;&amp; !dbname;</a>
<a name="ln1526"> </a>
<a name="ln1527">    ostringstream buff;</a>
<a name="ln1528"> </a>
<a name="ln1529">    switch (base_type)</a>
<a name="ln1530">    {</a>
<a name="ln1531">    case OBJ_WEAPONS:</a>
<a name="ln1532">        buff &lt;&lt; _name_weapon(*this, desc, terse, ident, with_inscription,</a>
<a name="ln1533">                             ignore_flags);</a>
<a name="ln1534">        break;</a>
<a name="ln1535"> </a>
<a name="ln1536">    case OBJ_MISSILES:</a>
<a name="ln1537">    {</a>
<a name="ln1538">        special_missile_type msl_brand = get_ammo_brand(*this);</a>
<a name="ln1539"> </a>
<a name="ln1540">        if (!terse &amp;&amp; !dbname &amp;&amp; !basename)</a>
<a name="ln1541">        {</a>
<a name="ln1542">            if (props.exists(DAMNATION_BOLT_KEY)) // hack alert</a>
<a name="ln1543">                buff &lt;&lt; &quot;damnation &quot;;</a>
<a name="ln1544">            else if (_missile_brand_is_prefix(msl_brand)) // see below for postfix brands</a>
<a name="ln1545">                buff &lt;&lt; missile_brand_name(*this, MBN_NAME) &lt;&lt; ' ';</a>
<a name="ln1546">        }</a>
<a name="ln1547"> </a>
<a name="ln1548">        buff &lt;&lt; ammo_name(static_cast&lt;missile_type&gt;(item_typ));</a>
<a name="ln1549"> </a>
<a name="ln1550">        if (msl_brand != SPMSL_NORMAL</a>
<a name="ln1551">            &amp;&amp; !basename &amp;&amp; !dbname)</a>
<a name="ln1552">        {</a>
<a name="ln1553">            if (terse)</a>
<a name="ln1554">            {</a>
<a name="ln1555">                if (props.exists(DAMNATION_BOLT_KEY)) // still a hack</a>
<a name="ln1556">                    buff &lt;&lt; &quot; (damnation)&quot;;</a>
<a name="ln1557">                else</a>
<a name="ln1558">                    buff &lt;&lt; &quot; (&quot; &lt;&lt;  missile_brand_name(*this, MBN_TERSE) &lt;&lt; &quot;)&quot;;</a>
<a name="ln1559">            }</a>
<a name="ln1560">            else if (_missile_brand_is_postfix(msl_brand)) // see above for prefix brands</a>
<a name="ln1561">                buff &lt;&lt; &quot; of &quot; &lt;&lt; missile_brand_name(*this, MBN_NAME);</a>
<a name="ln1562">        }</a>
<a name="ln1563"> </a>
<a name="ln1564">        break;</a>
<a name="ln1565">    }</a>
<a name="ln1566">    case OBJ_ARMOUR:</a>
<a name="ln1567">        if (know_curse &amp;&amp; !terse)</a>
<a name="ln1568">        {</a>
<a name="ln1569">            if (cursed())</a>
<a name="ln1570">                buff &lt;&lt; &quot;cursed &quot;;</a>
<a name="ln1571">            else if (!know_pluses)</a>
<a name="ln1572">                buff &lt;&lt; &quot;uncursed &quot;;</a>
<a name="ln1573"> </a>
<a name="ln1574">        }</a>
<a name="ln1575"> </a>
<a name="ln1576">        // If we know enough to know it has *something* ('shiny' etc),</a>
<a name="ln1577">        // but we know it has no ego, it must have a plus. (or maybe a curse.)</a>
<a name="ln1578">        // If we don't know what the plus is, call it 'enchanted'.</a>
<a name="ln1579">        if (!terse &amp;&amp; know_ego &amp;&amp; get_armour_ego_type(*this) == SPARM_NORMAL &amp;&amp;</a>
<a name="ln1580">            !know_pluses &amp;&amp; !is_artefact(*this) &amp;&amp; get_equip_desc(*this))</a>
<a name="ln1581">        {</a>
<a name="ln1582">            buff &lt;&lt; &quot;enchanted &quot;;</a>
<a name="ln1583">        }</a>
<a name="ln1584"> </a>
<a name="ln1585">        // Don't list unenchantable armor as +0.</a>
<a name="ln1586">        if (know_pluses &amp;&amp; armour_is_enchantable(*this))</a>
<a name="ln1587">            buff &lt;&lt; make_stringf(&quot;%+d &quot;, plus);</a>
<a name="ln1588"> </a>
<a name="ln1589">        if (item_typ == ARM_GLOVES || item_typ == ARM_BOOTS)</a>
<a name="ln1590">            buff &lt;&lt; &quot;pair of &quot;;</a>
<a name="ln1591"> </a>
<a name="ln1592">        if (is_artefact(*this) &amp;&amp; !dbname)</a>
<a name="ln1593">        {</a>
<a name="ln1594">            buff &lt;&lt; get_artefact_name(*this);</a>
<a name="ln1595">            break;</a>
<a name="ln1596">        }</a>
<a name="ln1597"> </a>
<a name="ln1598">        if (show_cosmetic)</a>
<a name="ln1599">        {</a>
<a name="ln1600">            switch (get_equip_desc(*this))</a>
<a name="ln1601">            {</a>
<a name="ln1602">            case ISFLAG_EMBROIDERED_SHINY:</a>
<a name="ln1603">                if (testbits(ignore_flags, ISFLAG_EMBROIDERED_SHINY))</a>
<a name="ln1604">                    break;</a>
<a name="ln1605">                if (item_typ == ARM_ROBE || item_typ == ARM_CLOAK</a>
<a name="ln1606">                    || item_typ == ARM_GLOVES || item_typ == ARM_BOOTS</a>
<a name="ln1607">                    || item_typ == ARM_SCARF</a>
<a name="ln1608">                    || get_armour_slot(*this) == EQ_HELMET</a>
<a name="ln1609">                       &amp;&amp; !is_hard_helmet(*this))</a>
<a name="ln1610">                {</a>
<a name="ln1611">                    buff &lt;&lt; &quot;embroidered &quot;;</a>
<a name="ln1612">                }</a>
<a name="ln1613">                else if (item_typ != ARM_LEATHER_ARMOUR</a>
<a name="ln1614">                         &amp;&amp; item_typ != ARM_ANIMAL_SKIN)</a>
<a name="ln1615">                {</a>
<a name="ln1616">                    buff &lt;&lt; &quot;shiny &quot;;</a>
<a name="ln1617">                }</a>
<a name="ln1618">                else</a>
<a name="ln1619">                    buff &lt;&lt; &quot;dyed &quot;;</a>
<a name="ln1620">                break;</a>
<a name="ln1621"> </a>
<a name="ln1622">            case ISFLAG_RUNED:</a>
<a name="ln1623">                if (!testbits(ignore_flags, ISFLAG_RUNED))</a>
<a name="ln1624">                    buff &lt;&lt; &quot;runed &quot;;</a>
<a name="ln1625">                break;</a>
<a name="ln1626"> </a>
<a name="ln1627">            case ISFLAG_GLOWING:</a>
<a name="ln1628">                if (!testbits(ignore_flags, ISFLAG_GLOWING))</a>
<a name="ln1629">                    buff &lt;&lt; &quot;glowing &quot;;</a>
<a name="ln1630">                break;</a>
<a name="ln1631">            }</a>
<a name="ln1632">        }</a>
<a name="ln1633"> </a>
<a name="ln1634">        buff &lt;&lt; item_base_name(*this);</a>
<a name="ln1635"> </a>
<a name="ln1636">        if (know_ego &amp;&amp; !is_artefact(*this))</a>
<a name="ln1637">        {</a>
<a name="ln1638">            const special_armour_type sparm = get_armour_ego_type(*this);</a>
<a name="ln1639"> </a>
<a name="ln1640">            if (sparm != SPARM_NORMAL)</a>
<a name="ln1641">            {</a>
<a name="ln1642">                if (!terse)</a>
<a name="ln1643">                    buff &lt;&lt; &quot; of &quot;;</a>
<a name="ln1644">                else</a>
<a name="ln1645">                    buff &lt;&lt; &quot; {&quot;;</a>
<a name="ln1646">                buff &lt;&lt; armour_ego_name(*this, terse);</a>
<a name="ln1647">                if (terse)</a>
<a name="ln1648">                    buff &lt;&lt; &quot;}&quot;;</a>
<a name="ln1649">            }</a>
<a name="ln1650">        }</a>
<a name="ln1651"> </a>
<a name="ln1652">        if (know_curse &amp;&amp; cursed() &amp;&amp; terse)</a>
<a name="ln1653">            buff &lt;&lt; &quot; (curse)&quot;;</a>
<a name="ln1654">        break;</a>
<a name="ln1655"> </a>
<a name="ln1656">    case OBJ_WANDS:</a>
<a name="ln1657">        if (basename)</a>
<a name="ln1658">        {</a>
<a name="ln1659">            buff &lt;&lt; &quot;wand&quot;;</a>
<a name="ln1660">            break;</a>
<a name="ln1661">        }</a>
<a name="ln1662"> </a>
<a name="ln1663">        if (know_type)</a>
<a name="ln1664">            buff &lt;&lt; &quot;wand of &quot; &lt;&lt; _wand_type_name(item_typ);</a>
<a name="ln1665">        else</a>
<a name="ln1666">        {</a>
<a name="ln1667">            buff &lt;&lt; wand_secondary_string(subtype_rnd / NDSC_WAND_PRI)</a>
<a name="ln1668">                 &lt;&lt; wand_primary_string(subtype_rnd % NDSC_WAND_PRI)</a>
<a name="ln1669">                 &lt;&lt; &quot; wand&quot;;</a>
<a name="ln1670">        }</a>
<a name="ln1671"> </a>
<a name="ln1672">        if (dbname)</a>
<a name="ln1673">            break;</a>
<a name="ln1674"> </a>
<a name="ln1675">        if (know_type &amp;&amp; charges &gt; 0)</a>
<a name="ln1676">            buff &lt;&lt; &quot; (&quot; &lt;&lt; charges &lt;&lt; &quot;)&quot;;</a>
<a name="ln1677"> </a>
<a name="ln1678">        break;</a>
<a name="ln1679"> </a>
<a name="ln1680">    case OBJ_POTIONS:</a>
<a name="ln1681">        if (basename)</a>
<a name="ln1682">        {</a>
<a name="ln1683">            buff &lt;&lt; &quot;potion&quot;;</a>
<a name="ln1684">            break;</a>
<a name="ln1685">        }</a>
<a name="ln1686"> </a>
<a name="ln1687">        if (know_type)</a>
<a name="ln1688">            buff &lt;&lt; &quot;potion of &quot; &lt;&lt; potion_type_name(item_typ);</a>
<a name="ln1689">        else</a>
<a name="ln1690">        {</a>
<a name="ln1691">            const int pqual   = PQUAL(subtype_rnd);</a>
<a name="ln1692">            const int pcolour = PCOLOUR(subtype_rnd);</a>
<a name="ln1693"> </a>
<a name="ln1694">            static const char *potion_qualifiers[] =</a>
<a name="ln1695">            {</a>
<a name="ln1696">                &quot;&quot;,  &quot;bubbling &quot;, &quot;fuming &quot;, &quot;fizzy &quot;, &quot;viscous &quot;, &quot;lumpy &quot;,</a>
<a name="ln1697">                &quot;smoky &quot;, &quot;glowing &quot;, &quot;sedimented &quot;, &quot;metallic &quot;, &quot;murky &quot;,</a>
<a name="ln1698">                &quot;gluggy &quot;, &quot;oily &quot;, &quot;slimy &quot;, &quot;emulsified &quot;,</a>
<a name="ln1699">            };</a>
<a name="ln1700">            COMPILE_CHECK(ARRAYSZ(potion_qualifiers) == PDQ_NQUALS);</a>
<a name="ln1701"> </a>
<a name="ln1702">            static const char *potion_colours[] =</a>
<a name="ln1703">            {</a>
<a name="ln1704">#if TAG_MAJOR_VERSION == 34</a>
<a name="ln1705">                &quot;clear&quot;,</a>
<a name="ln1706">#endif</a>
<a name="ln1707">                &quot;blue&quot;, &quot;black&quot;, &quot;silvery&quot;, &quot;cyan&quot;, &quot;purple&quot;, &quot;orange&quot;,</a>
<a name="ln1708">                &quot;inky&quot;, &quot;red&quot;, &quot;yellow&quot;, &quot;green&quot;, &quot;brown&quot;, &quot;ruby&quot;, &quot;white&quot;,</a>
<a name="ln1709">                &quot;emerald&quot;, &quot;grey&quot;, &quot;pink&quot;, &quot;coppery&quot;, &quot;golden&quot;, &quot;dark&quot;, &quot;puce&quot;,</a>
<a name="ln1710">                &quot;amethyst&quot;, &quot;sapphire&quot;,</a>
<a name="ln1711">            };</a>
<a name="ln1712">            COMPILE_CHECK(ARRAYSZ(potion_colours) == PDC_NCOLOURS);</a>
<a name="ln1713"> </a>
<a name="ln1714">            const char *qualifier =</a>
<a name="ln1715">                (pqual &lt; 0 || pqual &gt;= PDQ_NQUALS) ? &quot;bug-filled &quot;</a>
<a name="ln1716">                                    : potion_qualifiers[pqual];</a>
<a name="ln1717"> </a>
<a name="ln1718">            const char *clr =  (pcolour &lt; 0 || pcolour &gt;= PDC_NCOLOURS) ?</a>
<a name="ln1719">                                   &quot;bogus&quot; : potion_colours[pcolour];</a>
<a name="ln1720"> </a>
<a name="ln1721">            buff &lt;&lt; qualifier &lt;&lt; clr &lt;&lt; &quot; potion&quot;;</a>
<a name="ln1722">        }</a>
<a name="ln1723">        break;</a>
<a name="ln1724"> </a>
<a name="ln1725">    case OBJ_FOOD:</a>
<a name="ln1726">        switch (item_typ)</a>
<a name="ln1727">        {</a>
<a name="ln1728">        case FOOD_RATION: buff &lt;&lt; &quot;ration&quot;; break;</a>
<a name="ln1729">        case FOOD_CHUNK:</a>
<a name="ln1730">            switch (determine_chunk_effect(*this))</a>
<a name="ln1731">            {</a>
<a name="ln1732">                case CE_NOXIOUS:</a>
<a name="ln1733">                    buff &lt;&lt; &quot;inedible &quot;;</a>
<a name="ln1734">                    break;</a>
<a name="ln1735">                default:</a>
<a name="ln1736">                    break;</a>
<a name="ln1737">            }</a>
<a name="ln1738"> </a>
<a name="ln1739">            buff &lt;&lt; &quot;chunk of flesh&quot;;</a>
<a name="ln1740">            break;</a>
<a name="ln1741">#if TAG_MAJOR_VERSION == 34</a>
<a name="ln1742">        default: buff &lt;&lt; &quot;removed food&quot;; break;</a>
<a name="ln1743">#endif</a>
<a name="ln1744">        }</a>
<a name="ln1745"> </a>
<a name="ln1746">        break;</a>
<a name="ln1747"> </a>
<a name="ln1748">    case OBJ_SCROLLS:</a>
<a name="ln1749">        buff &lt;&lt; &quot;scroll&quot;;</a>
<a name="ln1750">        if (basename)</a>
<a name="ln1751">            break;</a>
<a name="ln1752">        else</a>
<a name="ln1753">            buff &lt;&lt; &quot; &quot;;</a>
<a name="ln1754"> </a>
<a name="ln1755">        if (know_type)</a>
<a name="ln1756">            buff &lt;&lt; &quot;of &quot; &lt;&lt; scroll_type_name(item_typ);</a>
<a name="ln1757">        else</a>
<a name="ln1758">            buff &lt;&lt; &quot;labeled &quot; &lt;&lt; make_name(subtype_rnd, MNAME_SCROLL);</a>
<a name="ln1759">        break;</a>
<a name="ln1760"> </a>
<a name="ln1761">    case OBJ_JEWELLERY:</a>
<a name="ln1762">    {</a>
<a name="ln1763">        if (basename)</a>
<a name="ln1764">        {</a>
<a name="ln1765">            if (jewellery_is_amulet(*this))</a>
<a name="ln1766">                buff &lt;&lt; &quot;amulet&quot;;</a>
<a name="ln1767">            else</a>
<a name="ln1768">                buff &lt;&lt; &quot;ring&quot;;</a>
<a name="ln1769"> </a>
<a name="ln1770">            break;</a>
<a name="ln1771">        }</a>
<a name="ln1772"> </a>
<a name="ln1773">        const bool is_randart = is_artefact(*this);</a>
<a name="ln1774"> </a>
<a name="ln1775">        if (know_curse &amp;&amp; !terse)</a>
<a name="ln1776">        {</a>
<a name="ln1777">            if (cursed())</a>
<a name="ln1778">                buff &lt;&lt; &quot;cursed &quot;;</a>
<a name="ln1779">            else if (desc != DESC_PLAIN</a>
<a name="ln1780">                     &amp;&amp; (!is_randart || !know_type)</a>
<a name="ln1781">                     &amp;&amp; (!jewellery_has_pluses(*this) || !know_pluses)</a>
<a name="ln1782">                     // If the item is worn, its curse status is known,</a>
<a name="ln1783">                     // no need to belabour the obvious.</a>
<a name="ln1784">                     &amp;&amp; get_equip_slot(this) == -1)</a>
<a name="ln1785">            {</a>
<a name="ln1786">                buff &lt;&lt; &quot;uncursed &quot;;</a>
<a name="ln1787">            }</a>
<a name="ln1788">        }</a>
<a name="ln1789"> </a>
<a name="ln1790">        if (is_randart &amp;&amp; !dbname)</a>
<a name="ln1791">        {</a>
<a name="ln1792">            buff &lt;&lt; get_artefact_name(*this);</a>
<a name="ln1793">            break;</a>
<a name="ln1794">        }</a>
<a name="ln1795"> </a>
<a name="ln1796">        if (know_type)</a>
<a name="ln1797">        {</a>
<a name="ln1798">            if (know_pluses &amp;&amp; jewellery_has_pluses(*this))</a>
<a name="ln1799">                buff &lt;&lt; make_stringf(&quot;%+d &quot;, plus);</a>
<a name="ln1800"> </a>
<a name="ln1801">            buff &lt;&lt; jewellery_type_name(item_typ);</a>
<a name="ln1802">        }</a>
<a name="ln1803">        else</a>
<a name="ln1804">        {</a>
<a name="ln1805">            if (jewellery_is_amulet(*this))</a>
<a name="ln1806">            {</a>
<a name="ln1807">                buff &lt;&lt; amulet_secondary_string(subtype_rnd / NDSC_JEWEL_PRI)</a>
<a name="ln1808">                     &lt;&lt; amulet_primary_string(subtype_rnd % NDSC_JEWEL_PRI)</a>
<a name="ln1809">                     &lt;&lt; &quot; amulet&quot;;</a>
<a name="ln1810">            }</a>
<a name="ln1811">            else  // i.e., a ring</a>
<a name="ln1812">            {</a>
<a name="ln1813">                buff &lt;&lt; ring_secondary_string(subtype_rnd / NDSC_JEWEL_PRI)</a>
<a name="ln1814">                     &lt;&lt; ring_primary_string(subtype_rnd % NDSC_JEWEL_PRI)</a>
<a name="ln1815">                     &lt;&lt; &quot; ring&quot;;</a>
<a name="ln1816">            }</a>
<a name="ln1817">        }</a>
<a name="ln1818">        if (know_curse &amp;&amp; cursed() &amp;&amp; terse)</a>
<a name="ln1819">            buff &lt;&lt; &quot; (curse)&quot;;</a>
<a name="ln1820">        break;</a>
<a name="ln1821">    }</a>
<a name="ln1822">    case OBJ_MISCELLANY:</a>
<a name="ln1823">    {</a>
<a name="ln1824">        if (!dbname &amp;&amp; item_typ == MISC_ZIGGURAT &amp;&amp; you.zigs_completed &gt; 0)</a>
<a name="ln1825">            buff &lt;&lt; &quot;+&quot; &lt;&lt; you.zigs_completed &lt;&lt; &quot; &quot;;</a>
<a name="ln1826"> </a>
<a name="ln1827">        buff &lt;&lt; misc_type_name(item_typ);</a>
<a name="ln1828"> </a>
<a name="ln1829">        if (is_xp_evoker(*this) &amp;&amp; !dbname &amp;&amp; !evoker_charges(sub_type))</a>
<a name="ln1830">            buff &lt;&lt; &quot; (inert)&quot;;</a>
<a name="ln1831">        else if (!dbname &amp;&amp; evoker_max_charges(sub_type) &gt; 1)</a>
<a name="ln1832">        {</a>
<a name="ln1833">            buff &lt;&lt; &quot; (&quot; &lt;&lt; evoker_charges(sub_type) &lt;&lt; &quot;/&quot;</a>
<a name="ln1834">                 &lt;&lt; evoker_max_charges(sub_type) &lt;&lt; &quot;)&quot;;</a>
<a name="ln1835">        }</a>
<a name="ln1836"> </a>
<a name="ln1837">        break;</a>
<a name="ln1838">    }</a>
<a name="ln1839"> </a>
<a name="ln1840">    case OBJ_BOOKS:</a>
<a name="ln1841">        if (is_random_artefact(*this) &amp;&amp; !dbname &amp;&amp; !basename)</a>
<a name="ln1842">        {</a>
<a name="ln1843">            buff &lt;&lt; get_artefact_name(*this);</a>
<a name="ln1844">            if (!know_type)</a>
<a name="ln1845">                buff &lt;&lt; &quot;book&quot;;</a>
<a name="ln1846">            break;</a>
<a name="ln1847">        }</a>
<a name="ln1848">        if (basename)</a>
<a name="ln1849">            buff &lt;&lt; (item_typ == BOOK_MANUAL ? &quot;manual&quot; : &quot;book&quot;);</a>
<a name="ln1850">        else if (!know_type)</a>
<a name="ln1851">        {</a>
<a name="ln1852">            buff &lt;&lt; book_secondary_string(rnd)</a>
<a name="ln1853">                 &lt;&lt; book_primary_string(rnd) &lt;&lt; &quot; &quot;</a>
<a name="ln1854">                 &lt;&lt; (item_typ == BOOK_MANUAL ? &quot;manual&quot; : &quot;book&quot;);</a>
<a name="ln1855">        }</a>
<a name="ln1856">        else</a>
<a name="ln1857">            buff &lt;&lt; sub_type_string(*this, !dbname);</a>
<a name="ln1858">        break;</a>
<a name="ln1859"> </a>
<a name="ln1860">#if TAG_MAJOR_VERSION == 34</a>
<a name="ln1861">    case OBJ_RODS:</a>
<a name="ln1862">        buff &lt;&lt; &quot;removed rod&quot;;</a>
<a name="ln1863">        break;</a>
<a name="ln1864">#endif</a>
<a name="ln1865"> </a>
<a name="ln1866">    case OBJ_STAVES:</a>
<a name="ln1867">        if (know_curse &amp;&amp; !terse)</a>
<a name="ln1868">        {</a>
<a name="ln1869">            if (cursed())</a>
<a name="ln1870">                buff &lt;&lt; &quot;cursed &quot;;</a>
<a name="ln1871">            else if (desc != DESC_PLAIN</a>
<a name="ln1872">                     &amp;&amp; (!know_type || !is_artefact(*this)))</a>
<a name="ln1873">            {</a>
<a name="ln1874">                buff &lt;&lt; &quot;uncursed &quot;;</a>
<a name="ln1875">            }</a>
<a name="ln1876">        }</a>
<a name="ln1877"> </a>
<a name="ln1878">        if (!know_type)</a>
<a name="ln1879">        {</a>
<a name="ln1880">            if (!basename)</a>
<a name="ln1881">            {</a>
<a name="ln1882">                buff &lt;&lt; staff_secondary_string(subtype_rnd / NDSC_STAVE_PRI)</a>
<a name="ln1883">                     &lt;&lt; staff_primary_string(subtype_rnd % NDSC_STAVE_PRI);</a>
<a name="ln1884">            }</a>
<a name="ln1885"> </a>
<a name="ln1886">            buff &lt;&lt; &quot;staff&quot;;</a>
<a name="ln1887">        }</a>
<a name="ln1888">        else</a>
<a name="ln1889">            buff &lt;&lt; &quot;staff of &quot; &lt;&lt; staff_type_name(item_typ);</a>
<a name="ln1890"> </a>
<a name="ln1891">        if (know_curse &amp;&amp; cursed() &amp;&amp; terse)</a>
<a name="ln1892">            buff &lt;&lt; &quot; (curse)&quot;;</a>
<a name="ln1893">        break;</a>
<a name="ln1894"> </a>
<a name="ln1895">    // rearranged 15 Apr 2000 {dlb}:</a>
<a name="ln1896">    case OBJ_ORBS:</a>
<a name="ln1897">        buff.str(&quot;Orb of Zot&quot;);</a>
<a name="ln1898">        break;</a>
<a name="ln1899"> </a>
<a name="ln1900">    case OBJ_RUNES:</a>
<a name="ln1901">        if (!dbname)</a>
<a name="ln1902">            buff &lt;&lt; rune_type_name(sub_type) &lt;&lt; &quot; &quot;;</a>
<a name="ln1903">        buff &lt;&lt; &quot;rune of Zot&quot;;</a>
<a name="ln1904">        break;</a>
<a name="ln1905"> </a>
<a name="ln1906">    case OBJ_GOLD:</a>
<a name="ln1907">        buff &lt;&lt; &quot;gold piece&quot;;</a>
<a name="ln1908">        break;</a>
<a name="ln1909"> </a>
<a name="ln1910">    case OBJ_CORPSES:</a>
<a name="ln1911">    {</a>
<a name="ln1912">        if (dbname &amp;&amp; item_typ == CORPSE_SKELETON)</a>
<a name="ln1913">            return &quot;decaying skeleton&quot;;</a>
<a name="ln1914"> </a>
<a name="ln1915">        monster_flags_t name_flags;</a>
<a name="ln1916">        const string _name = get_corpse_name(*this, &amp;name_flags);</a>
<a name="ln1917">        const monster_flags_t name_type = name_flags &amp; MF_NAME_MASK;</a>
<a name="ln1918"> </a>
<a name="ln1919">        const bool shaped = starts_with(_name, &quot;shaped &quot;);</a>
<a name="ln1920"> </a>
<a name="ln1921">        if (!_name.empty() &amp;&amp; name_type == MF_NAME_ADJECTIVE)</a>
<a name="ln1922">            buff &lt;&lt; _name &lt;&lt; &quot; &quot;;</a>
<a name="ln1923"> </a>
<a name="ln1924">        if ((name_flags &amp; MF_NAME_SPECIES) &amp;&amp; name_type == MF_NAME_REPLACE)</a>
<a name="ln1925">            buff &lt;&lt; _name &lt;&lt; &quot; &quot;;</a>
<a name="ln1926">        else if (!dbname &amp;&amp; !starts_with(_name, &quot;the &quot;))</a>
<a name="ln1927">        {</a>
<a name="ln1928">            const monster_type mc = mon_type;</a>
<a name="ln1929">            if (!(mons_is_unique(mc) &amp;&amp; mons_species(mc) == mc))</a>
<a name="ln1930">                buff &lt;&lt; mons_type_name(mc, DESC_PLAIN) &lt;&lt; ' ';</a>
<a name="ln1931"> </a>
<a name="ln1932">            if (!_name.empty() &amp;&amp; shaped)</a>
<a name="ln1933">                buff &lt;&lt; _name &lt;&lt; ' ';</a>
<a name="ln1934">        }</a>
<a name="ln1935"> </a>
<a name="ln1936">        if (item_typ == CORPSE_BODY)</a>
<a name="ln1937">            buff &lt;&lt; &quot;corpse&quot;;</a>
<a name="ln1938">        else if (item_typ == CORPSE_SKELETON)</a>
<a name="ln1939">            buff &lt;&lt; &quot;skeleton&quot;;</a>
<a name="ln1940">        else</a>
<a name="ln1941">            buff &lt;&lt; &quot;corpse bug&quot;;</a>
<a name="ln1942"> </a>
<a name="ln1943">        if (!_name.empty() &amp;&amp; !shaped &amp;&amp; name_type != MF_NAME_ADJECTIVE</a>
<a name="ln1944">            &amp;&amp; !(name_flags &amp; MF_NAME_SPECIES) &amp;&amp; name_type != MF_NAME_SUFFIX</a>
<a name="ln1945">            &amp;&amp; !dbname)</a>
<a name="ln1946">        {</a>
<a name="ln1947">            buff &lt;&lt; &quot; of &quot; &lt;&lt; _name;</a>
<a name="ln1948">        }</a>
<a name="ln1949">        break;</a>
<a name="ln1950">    }</a>
<a name="ln1951"> </a>
<a name="ln1952">    default:</a>
<a name="ln1953">        buff &lt;&lt; &quot;!&quot;;</a>
<a name="ln1954">    }</a>
<a name="ln1955"> </a>
<a name="ln1956">    // One plural to rule them all.</a>
<a name="ln1957">    if (need_plural &amp;&amp; quantity &gt; 1 &amp;&amp; !basename &amp;&amp; !qualname)</a>
<a name="ln1958">        buff.str(pluralise(buff.str()));</a>
<a name="ln1959"> </a>
<a name="ln1960">    // debugging output -- oops, I probably block it above ... dang! {dlb}</a>
<a name="ln1961">    if (buff.str().length() &lt; 3)</a>
<a name="ln1962">    {</a>
<a name="ln1963">        buff &lt;&lt; &quot;bad item (cl:&quot; &lt;&lt; static_cast&lt;int&gt;(base_type)</a>
<a name="ln1964">             &lt;&lt; &quot;,ty:&quot; &lt;&lt; item_typ &lt;&lt; &quot;,pl:&quot; &lt;&lt; plus</a>
<a name="ln1965">             &lt;&lt; &quot;,pl2:&quot; &lt;&lt; plus2 &lt;&lt; &quot;,sp:&quot; &lt;&lt; special</a>
<a name="ln1966">             &lt;&lt; &quot;,qu:&quot; &lt;&lt; quantity &lt;&lt; &quot;)&quot;;</a>
<a name="ln1967">    }</a>
<a name="ln1968"> </a>
<a name="ln1969">    return buff.str();</a>
<a name="ln1970">}</a>
<a name="ln1971"> </a>
<a name="ln1972">// WARNING: You can break save compatibility if you edit this without</a>
<a name="ln1973">// amending tags.cc to properly marshall the change.</a>
<a name="ln1974">bool item_type_has_ids(object_class_type base_type)</a>
<a name="ln1975">{</a>
<a name="ln1976">    COMPILE_CHECK(NUM_WEAPONS    &lt; MAX_SUBTYPES);</a>
<a name="ln1977">    COMPILE_CHECK(NUM_MISSILES   &lt; MAX_SUBTYPES);</a>
<a name="ln1978">    COMPILE_CHECK(NUM_ARMOURS    &lt; MAX_SUBTYPES);</a>
<a name="ln1979">    COMPILE_CHECK(NUM_WANDS      &lt; MAX_SUBTYPES);</a>
<a name="ln1980">    COMPILE_CHECK(NUM_FOODS      &lt; MAX_SUBTYPES);</a>
<a name="ln1981">    COMPILE_CHECK(NUM_SCROLLS    &lt; MAX_SUBTYPES);</a>
<a name="ln1982">    COMPILE_CHECK(NUM_JEWELLERY  &lt; MAX_SUBTYPES);</a>
<a name="ln1983">    COMPILE_CHECK(NUM_POTIONS    &lt; MAX_SUBTYPES);</a>
<a name="ln1984">    COMPILE_CHECK(NUM_BOOKS      &lt; MAX_SUBTYPES);</a>
<a name="ln1985">    COMPILE_CHECK(NUM_STAVES     &lt; MAX_SUBTYPES);</a>
<a name="ln1986">    COMPILE_CHECK(NUM_MISCELLANY &lt; MAX_SUBTYPES);</a>
<a name="ln1987">#if TAG_MAJOR_VERSION == 34</a>
<a name="ln1988">    COMPILE_CHECK(NUM_RODS       &lt; MAX_SUBTYPES);</a>
<a name="ln1989">#endif</a>
<a name="ln1990"> </a>
<a name="ln1991">    return base_type == OBJ_WANDS || base_type == OBJ_SCROLLS</a>
<a name="ln1992">        || base_type == OBJ_JEWELLERY || base_type == OBJ_POTIONS</a>
<a name="ln1993">        || base_type == OBJ_STAVES || base_type == OBJ_BOOKS;</a>
<a name="ln1994">}</a>
<a name="ln1995"> </a>
<a name="ln1996">bool item_brand_known(const item_def&amp; item)</a>
<a name="ln1997">{</a>
<a name="ln1998">    return item_ident(item, ISFLAG_KNOW_TYPE)</a>
<a name="ln1999">           || is_artefact(item)</a>
<a name="ln2000">           &amp;&amp; artefact_known_property(item, ARTP_BRAND);</a>
<a name="ln2001">}</a>
<a name="ln2002"> </a>
<a name="ln2003">bool item_type_known(const item_def&amp; item)</a>
<a name="ln2004">{</a>
<a name="ln2005">    if (item_ident(item, ISFLAG_KNOW_TYPE))</a>
<a name="ln2006">        return true;</a>
<a name="ln2007"> </a>
<a name="ln2008">    // Artefacts have different descriptions from other items,</a>
<a name="ln2009">    // so we can't use general item knowledge for them.</a>
<a name="ln2010">    if (is_artefact(item))</a>
<a name="ln2011">        return false;</a>
<a name="ln2012"> </a>
<a name="ln2013">    if (item.base_type == OBJ_MISSILES)</a>
<a name="ln2014">        return true;</a>
<a name="ln2015"> </a>
<a name="ln2016">    if (item.base_type == OBJ_MISCELLANY)</a>
<a name="ln2017">        return true;</a>
<a name="ln2018"> </a>
<a name="ln2019">#if TAG_MAJOR_VERSION == 34</a>
<a name="ln2020">    if (item.is_type(OBJ_BOOKS, BOOK_BUGGY_DESTRUCTION))</a>
<a name="ln2021">        return true;</a>
<a name="ln2022">#endif</a>
<a name="ln2023"> </a>
<a name="ln2024">    if (item.is_type(OBJ_BOOKS, BOOK_MANUAL))</a>
<a name="ln2025">        return false;</a>
<a name="ln2026"> </a>
<a name="ln2027">    if (!item_type_has_ids(item.base_type))</a>
<a name="ln2028">        return false;</a>
<a name="ln2029">    return you.type_ids[item.base_type][item.sub_type];</a>
<a name="ln2030">}</a>
<a name="ln2031"> </a>
<a name="ln2032">bool item_type_unknown(const item_def&amp; item)</a>
<a name="ln2033">{</a>
<a name="ln2034">    if (item_type_known(item))</a>
<a name="ln2035">        return false;</a>
<a name="ln2036"> </a>
<a name="ln2037">    if (is_artefact(item))</a>
<a name="ln2038">        return true;</a>
<a name="ln2039"> </a>
<a name="ln2040">    return item_type_has_ids(item.base_type);</a>
<a name="ln2041">}</a>
<a name="ln2042"> </a>
<a name="ln2043">bool item_type_known(const object_class_type base_type, const int sub_type)</a>
<a name="ln2044">{</a>
<a name="ln2045">    if (!item_type_has_ids(base_type))</a>
<a name="ln2046">        return false;</a>
<a name="ln2047">    return you.type_ids[base_type][sub_type];</a>
<a name="ln2048">}</a>
<a name="ln2049"> </a>
<a name="ln2050">bool set_ident_type(item_def &amp;item, bool identify)</a>
<a name="ln2051">{</a>
<a name="ln2052">    if (is_artefact(item) || crawl_state.game_is_arena())</a>
<a name="ln2053">        return false;</a>
<a name="ln2054"> </a>
<a name="ln2055">    if (!set_ident_type(item.base_type, item.sub_type, identify))</a>
<a name="ln2056">        return false;</a>
<a name="ln2057"> </a>
<a name="ln2058">    if (in_inventory(item))</a>
<a name="ln2059">    {</a>
<a name="ln2060">        shopping_list.cull_identical_items(item);</a>
<a name="ln2061">        if (identify)</a>
<a name="ln2062">            item_skills(item, you.start_train);</a>
<a name="ln2063">    }</a>
<a name="ln2064"> </a>
<a name="ln2065">    if (identify &amp;&amp; notes_are_active()</a>
<a name="ln2066">        &amp;&amp; is_interesting_item(item)</a>
<a name="ln2067">        &amp;&amp; !(item.flags &amp; (ISFLAG_NOTED_ID | ISFLAG_NOTED_GET)))</a>
<a name="ln2068">    {</a>
<a name="ln2069">        // Make a note of it.</a>
<a name="ln2070">        take_note(Note(NOTE_ID_ITEM, 0, 0, item.name(DESC_A),</a>
<a name="ln2071">                       origin_desc(item)));</a>
<a name="ln2072"> </a>
<a name="ln2073">        // Sometimes (e.g. shops) you can ID an item before you get it;</a>
<a name="ln2074">        // don't note twice in those cases.</a>
<a name="ln2075">        item.flags |= (ISFLAG_NOTED_ID | ISFLAG_NOTED_GET);</a>
<a name="ln2076">    }</a>
<a name="ln2077"> </a>
<a name="ln2078">    return true;</a>
<a name="ln2079">}</a>
<a name="ln2080"> </a>
<a name="ln2081">bool set_ident_type(object_class_type basetype, int subtype, bool identify)</a>
<a name="ln2082">{</a>
<a name="ln2083">    preserve_quiver_slots p;</a>
<a name="ln2084"> </a>
<a name="ln2085">    if (!item_type_has_ids(basetype))</a>
<a name="ln2086">        return false;</a>
<a name="ln2087"> </a>
<a name="ln2088">    if (you.type_ids[basetype][subtype] == identify)</a>
<a name="ln2089">        return false;</a>
<a name="ln2090"> </a>
<a name="ln2091">    you.type_ids[basetype][subtype] = identify;</a>
<a name="ln2092">    request_autoinscribe();</a>
<a name="ln2093"> </a>
<a name="ln2094">    // Our item knowledge changed in a way that could possibly affect shop</a>
<a name="ln2095">    // prices.</a>
<a name="ln2096">    shopping_list.item_type_identified(basetype, subtype);</a>
<a name="ln2097"> </a>
<a name="ln2098">    // We identified something, maybe we identified other things by process of</a>
<a name="ln2099">    // elimination.</a>
<a name="ln2100">    if (identify &amp;&amp; !(you.pending_revival || crawl_state.updating_scores))</a>
<a name="ln2101">        _maybe_identify_pack_item();</a>
<a name="ln2102"> </a>
<a name="ln2103">    return true;</a>
<a name="ln2104">}</a>
<a name="ln2105"> </a>
<a name="ln2106">void pack_item_identify_message(int base_type, int sub_type)</a>
<a name="ln2107">{</a>
<a name="ln2108">    for (const auto &amp;item : you.inv)</a>
<a name="ln2109">        if (item.defined() &amp;&amp; item.is_type(base_type, sub_type))</a>
<a name="ln2110">            mprf_nocap(&quot;%s&quot;, item.name(DESC_INVENTORY_EQUIP).c_str());</a>
<a name="ln2111">}</a>
<a name="ln2112"> </a>
<a name="ln2113">bool get_ident_type(const item_def &amp;item)</a>
<a name="ln2114">{</a>
<a name="ln2115">    if (is_artefact(item))</a>
<a name="ln2116">        return false;</a>
<a name="ln2117"> </a>
<a name="ln2118">    return get_ident_type(item.base_type, item.sub_type);</a>
<a name="ln2119">}</a>
<a name="ln2120"> </a>
<a name="ln2121">bool get_ident_type(object_class_type basetype, int subtype)</a>
<a name="ln2122">{</a>
<a name="ln2123">    if (!item_type_has_ids(basetype))</a>
<a name="ln2124">        return false;</a>
<a name="ln2125">    ASSERT(subtype &lt; MAX_SUBTYPES);</a>
<a name="ln2126">    return you.type_ids[basetype][subtype];</a>
<a name="ln2127">}</a>
<a name="ln2128"> </a>
<a name="ln2129">static MenuEntry* _fixup_runeorb_entry(MenuEntry* me)</a>
<a name="ln2130">{</a>
<a name="ln2131">    auto entry = static_cast&lt;InvEntry*&gt;(me);</a>
<a name="ln2132">    ASSERT(entry);</a>
<a name="ln2133"> </a>
<a name="ln2134">    if (entry-&gt;item-&gt;base_type == OBJ_RUNES)</a>
<a name="ln2135">    {</a>
<a name="ln2136">        auto rune = static_cast&lt;rune_type&gt;(entry-&gt;item-&gt;sub_type);</a>
<a name="ln2137">        colour_t colour;</a>
<a name="ln2138">        // Make Gloorx's rune more distinguishable from uncollected runes.</a>
<a name="ln2139">        if (you.runes[rune])</a>
<a name="ln2140">        {</a>
<a name="ln2141">            colour = (rune == RUNE_GLOORX_VLOQ) ? colour_t{LIGHTGREY}</a>
<a name="ln2142">                                                : rune_colour(rune);</a>
<a name="ln2143">        }</a>
<a name="ln2144">        else</a>
<a name="ln2145">            colour = DARKGREY;</a>
<a name="ln2146"> </a>
<a name="ln2147">        string text = &quot;&lt;&quot;;</a>
<a name="ln2148">        text += colour_to_str(colour);</a>
<a name="ln2149">        text += &quot;&gt;&quot;;</a>
<a name="ln2150">        text += rune_type_name(rune);</a>
<a name="ln2151">        text += &quot; rune of Zot&quot;;</a>
<a name="ln2152">        if (!you.runes[rune])</a>
<a name="ln2153">        {</a>
<a name="ln2154">            text += &quot; (&quot;;</a>
<a name="ln2155">            text += branches[rune_location(rune)].longname;</a>
<a name="ln2156">            text += &quot;)&quot;;</a>
<a name="ln2157">        }</a>
<a name="ln2158">        text += &quot;&lt;/&quot;;</a>
<a name="ln2159">        text += colour_to_str(colour);</a>
<a name="ln2160">        text += &quot;&gt;&quot;;</a>
<a name="ln2161">        entry-&gt;text = text;</a>
<a name="ln2162">    }</a>
<a name="ln2163">    else if (entry-&gt;item-&gt;is_type(OBJ_ORBS, ORB_ZOT))</a>
<a name="ln2164">    {</a>
<a name="ln2165">        if (player_has_orb())</a>
<a name="ln2166">            entry-&gt;text = &quot;&lt;magenta&gt;The Orb of Zot&lt;/magenta&gt;&quot;;</a>
<a name="ln2167">        else</a>
<a name="ln2168">        {</a>
<a name="ln2169">            entry-&gt;text = &quot;&lt;darkgrey&gt;The Orb of Zot&quot;</a>
<a name="ln2170">                          &quot; (the Realm of Zot)&lt;/darkgrey&gt;&quot;;</a>
<a name="ln2171">        }</a>
<a name="ln2172">    }</a>
<a name="ln2173"> </a>
<a name="ln2174">    return entry;</a>
<a name="ln2175">}</a>
<a name="ln2176"> </a>
<a name="ln2177">void display_runes()</a>
<a name="ln2178">{</a>
<a name="ln2179">    auto col = runes_in_pack() &lt; ZOT_ENTRY_RUNES ?  &quot;lightgrey&quot; :</a>
<a name="ln2180">               runes_in_pack() &lt; you.obtainable_runes ? &quot;green&quot; :</a>
<a name="ln2181">                                                   &quot;lightgreen&quot;;</a>
<a name="ln2182"> </a>
<a name="ln2183">    auto title = make_stringf(&quot;&lt;white&gt;Runes of Zot (&lt;/white&gt;&quot;</a>
<a name="ln2184">                              &quot;&lt;%s&gt;%d&lt;/%s&gt;&lt;white&gt; collected) &amp; Orbs of Power&lt;/white&gt;&quot;,</a>
<a name="ln2185">                              col, runes_in_pack(), col);</a>
<a name="ln2186"> </a>
<a name="ln2187">    InvMenu menu(MF_NOSELECT | MF_ALLOW_FORMATTING);</a>
<a name="ln2188"> </a>
<a name="ln2189">    menu.set_title(title);</a>
<a name="ln2190"> </a>
<a name="ln2191">    vector&lt;item_def&gt; items;</a>
<a name="ln2192"> </a>
<a name="ln2193">    if (!crawl_state.game_is_sprint())</a>
<a name="ln2194">    {</a>
<a name="ln2195">        // Add the runes in order of challenge (semi-arbitrary).</a>
<a name="ln2196">        for (branch_iterator it(branch_iterator_type::danger); it; ++it)</a>
<a name="ln2197">        {</a>
<a name="ln2198">            const branch_type br = it-&gt;id;</a>
<a name="ln2199">            if (!connected_branch_can_exist(br))</a>
<a name="ln2200">                continue;</a>
<a name="ln2201"> </a>
<a name="ln2202">            for (auto rune : branches[br].runes)</a>
<a name="ln2203">            {</a>
<a name="ln2204">                item_def item;</a>
<a name="ln2205">                item.base_type = OBJ_RUNES;</a>
<a name="ln2206">                item.sub_type = rune;</a>
<a name="ln2207">                item.quantity = you.runes[rune] ? 1 : 0;</a>
<a name="ln2208">                item_colour(item);</a>
<a name="ln2209">                items.push_back(item);</a>
<a name="ln2210">            }</a>
<a name="ln2211">        }</a>
<a name="ln2212">    }</a>
<a name="ln2213">    else</a>
<a name="ln2214">    {</a>
<a name="ln2215">        // We don't know what runes are accessible in the sprint, so just show</a>
<a name="ln2216">        // the ones you have. We can't iterate over branches as above since the</a>
<a name="ln2217">        // elven rune and mossy rune may exist in sprint.</a>
<a name="ln2218">        for (int i = 0; i &lt; NUM_RUNE_TYPES; ++i)</a>
<a name="ln2219">        {</a>
<a name="ln2220">            if (you.runes[i])</a>
<a name="ln2221">            {</a>
<a name="ln2222">                item_def item;</a>
<a name="ln2223">                item.base_type = OBJ_RUNES;</a>
<a name="ln2224">                item.sub_type = i;</a>
<a name="ln2225">                item.quantity = 1;</a>
<a name="ln2226">                item_colour(item);</a>
<a name="ln2227">                items.push_back(item);</a>
<a name="ln2228">            }</a>
<a name="ln2229">        }</a>
<a name="ln2230">    }</a>
<a name="ln2231">    item_def item;</a>
<a name="ln2232">    item.base_type = OBJ_ORBS;</a>
<a name="ln2233">    item.sub_type = ORB_ZOT;</a>
<a name="ln2234">    item.quantity = player_has_orb() ? 1 : 0;</a>
<a name="ln2235">    items.push_back(item);</a>
<a name="ln2236"> </a>
<a name="ln2237">    // We've sorted this vector already, so disable menu sorting. Maybe we</a>
<a name="ln2238">    // could a menu entry comparator and modify InvMenu::load_items() to allow</a>
<a name="ln2239">    // passing this in instead of doing a sort ahead of time.</a>
<a name="ln2240">    menu.load_items(items, _fixup_runeorb_entry, 0, false);</a>
<a name="ln2241"> </a>
<a name="ln2242">    menu.show();</a>
<a name="ln2243">}</a>
<a name="ln2244"> </a>
<a name="ln2245">// Seed ranges for _random_consonant_set: (B)eginning and one-past-the-(E)nd</a>
<a name="ln2246">// of the (B)eginning, (E)nding, and (M)iddle cluster ranges.</a>
<a name="ln2247">const size_t RCS_BB = 0;</a>
<a name="ln2248">const size_t RCS_EB = 27;</a>
<a name="ln2249">const size_t RCS_BE = 14;</a>
<a name="ln2250">const size_t RCS_EE = 56;</a>
<a name="ln2251">const size_t RCS_BM = 0;</a>
<a name="ln2252">const size_t RCS_EM = 67;</a>
<a name="ln2253">const size_t RCS_END = RCS_EM;</a>
<a name="ln2254"> </a>
<a name="ln2255">#define ITEMNAME_SIZE 200</a>
<a name="ln2256">/**</a>
<a name="ln2257"> * Make a random name from the given seed.</a>
<a name="ln2258"> *</a>
<a name="ln2259"> * Used for: Pandemonium demonlords, shopkeepers, scrolls, random artefacts.</a>
<a name="ln2260"> *</a>
<a name="ln2261"> * This function is insane, but that might be useful.</a>
<a name="ln2262"> *</a>
<a name="ln2263"> * @param seed      The seed to generate the name from.</a>
<a name="ln2264"> *                  The same seed will always generate the same name.</a>
<a name="ln2265"> *                  By default a random number from the current RNG.</a>
<a name="ln2266"> * @param name_type The type of name to be generated.</a>
<a name="ln2267"> *                  If MNAME_SCROLL, increase length by 6 and force to allcaps.</a>
<a name="ln2268"> *                  If MNAME_JIYVA, start with J, do not generate spaces,</a>
<a name="ln2269"> *                  recurse instead of ploggifying, and cap length at 8.</a>
<a name="ln2270"> *                  Otherwise, no special behaviour.</a>
<a name="ln2271"> * @return          A randomly generated name.</a>
<a name="ln2272"> *                  E.g. &quot;Joiduir&quot;, &quot;Jays Fya&quot;, ZEFOKY WECZYXE,</a>
<a name="ln2273"> *                  THE GIAGGOSTUONO, etc.</a>
<a name="ln2274"> */</a>
<a name="ln2275">string make_name(uint32_t seed, makename_type name_type)</a>
<a name="ln2276">{</a>
<a name="ln2277">    // use the seed to select sequence, rather than seed per se. This is</a>
<a name="ln2278">    // because it is not important that the sequence be randomly distributed</a>
<a name="ln2279">    // in uint64_t.</a>
<a name="ln2280">    rng::subgenerator subgen(you.game_seed, static_cast&lt;uint64_t&gt;(seed));</a>
<a name="ln2281"> </a>
<a name="ln2282">    string name;</a>
<a name="ln2283"> </a>
<a name="ln2284">    bool has_space  = false; // Keep track of whether the name contains a space.</a>
<a name="ln2285"> </a>
<a name="ln2286">    size_t len = 3;</a>
<a name="ln2287">    len += random2(5);</a>
<a name="ln2288">    len += (random2(5) == 0) ? random2(6) : 1;</a>
<a name="ln2289"> </a>
<a name="ln2290">    if (name_type == MNAME_SCROLL)   // scrolls have longer names</a>
<a name="ln2291">        len += 6;</a>
<a name="ln2292"> </a>
<a name="ln2293">    const size_t maxlen = name_type == MNAME_JIYVA ? 8 : SIZE_MAX;</a>
<a name="ln2294">    len = min(len, maxlen);</a>
<a name="ln2295"> </a>
<a name="ln2296">    ASSERT_RANGE(len, 1, ITEMNAME_SIZE + 1);</a>
<a name="ln2297"> </a>
<a name="ln2298">    static const int MAX_ITERS = 150;</a>
<a name="ln2299">    for (int iters = 0; iters &lt; MAX_ITERS &amp;&amp; name.length() &lt; len; ++iters)</a>
<a name="ln2300">    {</a>
<a name="ln2301">        const char prev_char = name.length() ? name[name.length() - 1]</a>
<a name="ln2302">                                              : '\0';</a>
<a name="ln2303">        const char penult_char = name.length() &gt; 1 ? name[name.length() - 2]</a>
<a name="ln2304">                                                    : '\0';</a>
<a name="ln2305">        if (name.empty() &amp;&amp; name_type == MNAME_JIYVA)</a>
<a name="ln2306">        {</a>
<a name="ln2307">            // Start the name with a predefined letter.</a>
<a name="ln2308">            name += 'j';</a>
<a name="ln2309">        }</a>
<a name="ln2310">        else if (name.empty() || prev_char == ' ')</a>
<a name="ln2311">        {</a>
<a name="ln2312">            // Start the word with any letter.</a>
<a name="ln2313">            name += 'a' + random2(26);</a>
<a name="ln2314">        }</a>
<a name="ln2315">        else if (!has_space &amp;&amp; name_type != MNAME_JIYVA</a>
<a name="ln2316">                 &amp;&amp; name.length() &gt; 5 &amp;&amp; name.length() &lt; len - 4</a>
<a name="ln2317">                 &amp;&amp; random2(5) != 0) // 4/5 chance</a>
<a name="ln2318">        {</a>
<a name="ln2319">             // Hand out a space.</a>
<a name="ln2320">            name += ' ';</a>
<a name="ln2321">        }</a>
<a name="ln2322">        else if (name.length()</a>
<a name="ln2323">                 &amp;&amp; (_is_consonant(prev_char)</a>
<a name="ln2324">                     || (name.length() &gt; 1</a>
<a name="ln2325">                         &amp;&amp; !_is_consonant(prev_char)</a>
<a name="ln2326">                         &amp;&amp; _is_consonant(penult_char)</a>
<a name="ln2327">                         &amp;&amp; random2(5) &lt;= 1))) // 2/5</a>
<a name="ln2328">        {</a>
<a name="ln2329">            // Place a vowel.</a>
<a name="ln2330">            const char vowel = _random_vowel();</a>
<a name="ln2331"> </a>
<a name="ln2332">            if (vowel == ' ')</a>
<a name="ln2333">            {</a>
<a name="ln2334">                if (len &lt; 7</a>
<a name="ln2335">                         || name.length() &lt;= 2 || name.length() &gt;= len - 3</a>
<a name="ln2336">                         || prev_char == ' ' || penult_char == ' '</a>
<a name="ln2337">                         || name_type == MNAME_JIYVA</a>
<a name="ln2338">                         || name.length() &gt; 2</a>
<a name="ln2339">                            &amp;&amp; _is_consonant(prev_char)</a>
<a name="ln2340">                            &amp;&amp; _is_consonant(penult_char))</a>
<a name="ln2341">                {</a>
<a name="ln2342">                    // Replace the space with something else if ...</a>
<a name="ln2343">                    // * the name is really short</a>
<a name="ln2344">                    // * we're close to the start/end of the name</a>
<a name="ln2345">                    // * we just got a space</a>
<a name="ln2346">                    // * we're generating a jiyva name, or</a>
<a name="ln2347">                    // * the last two letters were consonants</a>
<a name="ln2348">                    continue;</a>
<a name="ln2349">                }</a>
<a name="ln2350">            }</a>
<a name="ln2351">            else if (name.length() &gt; 1</a>
<a name="ln2352">                     &amp;&amp; vowel == prev_char</a>
<a name="ln2353">                     &amp;&amp; (vowel == 'y' || vowel == 'i'</a>
<a name="ln2354">                         || random2(5) &lt;= 1))</a>
<a name="ln2355">            {</a>
<a name="ln2356">                // Replace the vowel with something else if the previous</a>
<a name="ln2357">                // letter was the same, and it's a 'y', 'i' or with 2/5 chance.</a>
<a name="ln2358">                continue;</a>
<a name="ln2359">            }</a>
<a name="ln2360"> </a>
<a name="ln2361">            name += vowel;</a>
<a name="ln2362">        }</a>
<a name="ln2363">        else // We want a consonant.</a>
<a name="ln2364">        {</a>
<a name="ln2365">            // Are we at start or end of the (sub) name?</a>
<a name="ln2366">            const bool beg = (name.empty() || prev_char == ' ');</a>
<a name="ln2367">            const bool end = (name.length() &gt;= len - 2);</a>
<a name="ln2368"> </a>
<a name="ln2369">            // Use one of number of predefined letter combinations.</a>
<a name="ln2370">            if ((len &gt; 3 || !name.empty())</a>
<a name="ln2371">                &amp;&amp; random2(7) &lt;= 1 // 2/7 chance</a>
<a name="ln2372">                &amp;&amp; (!beg || !end))</a>
<a name="ln2373">            {</a>
<a name="ln2374">                const int first = (beg ? RCS_BB : (end ? RCS_BE : RCS_BM));</a>
<a name="ln2375">                const int last  = (beg ? RCS_EB : (end ? RCS_EE : RCS_EM));</a>
<a name="ln2376"> </a>
<a name="ln2377">                const int range = last - first;</a>
<a name="ln2378"> </a>
<a name="ln2379">                const int cons_seed = random2(range) + first;</a>
<a name="ln2380"> </a>
<a name="ln2381">                const string consonant_set = _random_consonant_set(cons_seed);</a>
<a name="ln2382"> </a>
<a name="ln2383">                ASSERT(consonant_set.size() &gt; 1);</a>
<a name="ln2384">                len += consonant_set.size() - 2; // triples increase len</a>
<a name="ln2385">                name += consonant_set;</a>
<a name="ln2386">            }</a>
<a name="ln2387">            else // Place a single letter instead.</a>
<a name="ln2388">            {</a>
<a name="ln2389">                // Pick a random consonant.</a>
<a name="ln2390">                name += _random_cons();</a>
<a name="ln2391">            }</a>
<a name="ln2392">        }</a>
<a name="ln2393"> </a>
<a name="ln2394">        if (name[name.length() - 1] == ' ')</a>
<a name="ln2395">        {</a>
<a name="ln2396">            ASSERT(name_type != MNAME_JIYVA);</a>
<a name="ln2397">            has_space = true;</a>
<a name="ln2398">        }</a>
<a name="ln2399">    }</a>
<a name="ln2400"> </a>
<a name="ln2401">    // Catch early exit and try to give a final letter.</a>
<a name="ln2402">    const char last_char = name[name.length() - 1];</a>
<a name="ln2403">    if (!name.empty()</a>
<a name="ln2404">        &amp;&amp; last_char != ' '</a>
<a name="ln2405">        &amp;&amp; last_char != 'y'</a>
<a name="ln2406">        &amp;&amp; !_is_consonant(name[name.length() - 1])</a>
<a name="ln2407">        &amp;&amp; (name.length() &lt; len    // early exit</a>
<a name="ln2408">            || (len &lt; 8</a>
<a name="ln2409">                &amp;&amp; random2(3) != 0))) // 2/3 chance for other short names</a>
<a name="ln2410">    {</a>
<a name="ln2411">        // Specifically, add a consonant.</a>
<a name="ln2412">        name += _random_cons();</a>
<a name="ln2413">    }</a>
<a name="ln2414"> </a>
<a name="ln2415">    if (maxlen != SIZE_MAX)</a>
<a name="ln2416">        name = chop_string(name, maxlen);</a>
<a name="ln2417">    trim_string_right(name);</a>
<a name="ln2418"> </a>
<a name="ln2419">    // Fallback if the name was too short.</a>
<a name="ln2420">    if (name.length() &lt; 4)</a>
<a name="ln2421">    {</a>
<a name="ln2422">        // convolute &amp; recurse</a>
<a name="ln2423">        if (name_type == MNAME_JIYVA)</a>
<a name="ln2424">            return make_name(rng::get_uint32(), MNAME_JIYVA);</a>
<a name="ln2425"> </a>
<a name="ln2426">        name = &quot;plog&quot;;</a>
<a name="ln2427">    }</a>
<a name="ln2428"> </a>
<a name="ln2429">    string uppercased_name;</a>
<a name="ln2430">    for (size_t i = 0; i &lt; name.length(); i++)</a>
<a name="ln2431">    {</a>
<a name="ln2432">        if (name_type == MNAME_JIYVA)</a>
<a name="ln2433">            ASSERT(name[i] != ' ');</a>
<a name="ln2434"> </a>
<a name="ln2435">        if (name_type == MNAME_SCROLL || i == 0 || name[i - 1] == ' ')</a>
<a name="ln2436">            uppercased_name += toupper_safe(name[i]);</a>
<a name="ln2437">        else</a>
<a name="ln2438">            uppercased_name += name[i];</a>
<a name="ln2439">    }</a>
<a name="ln2440"> </a>
<a name="ln2441">    return uppercased_name;</a>
<a name="ln2442">}</a>
<a name="ln2443">#undef ITEMNAME_SIZE</a>
<a name="ln2444"> </a>
<a name="ln2445">/**</a>
<a name="ln2446"> * Is the given character a lower-case ascii consonant?</a>
<a name="ln2447"> *</a>
<a name="ln2448"> * For our purposes, y is not a consonant.</a>
<a name="ln2449"> */</a>
<a name="ln2450">static bool _is_consonant(char let)</a>
<a name="ln2451">{</a>
<a name="ln2452">    static const set&lt;char&gt; all_consonants = { 'b', 'c', 'd', 'f', 'g',</a>
<a name="ln2453">                                              'h', 'j', 'k', 'l', 'm',</a>
<a name="ln2454">                                              'n', 'p', 'q', 'r', 's',</a>
<a name="ln2455">                                              't', 'v', 'w', 'x', 'z' };</a>
<a name="ln2456">    return all_consonants.count(let);</a>
<a name="ln2457">}</a>
<a name="ln2458"> </a>
<a name="ln2459">// Returns a random vowel (a, e, i, o, u with equal probability) or space</a>
<a name="ln2460">// or 'y' with lower chances.</a>
<a name="ln2461">static char _random_vowel()</a>
<a name="ln2462">{</a>
<a name="ln2463">    static const char vowels[] = &quot;aeiouaeiouaeiouy  &quot;;</a>
<a name="ln2464">    return vowels[random2(sizeof(vowels) - 1)];</a>
<a name="ln2465">}</a>
<a name="ln2466"> </a>
<a name="ln2467">// Returns a random consonant with not quite equal probability.</a>
<a name="ln2468">// Does not include 'y'.</a>
<a name="ln2469">static char _random_cons()</a>
<a name="ln2470">{</a>
<a name="ln2471">    static const char consonants[] = &quot;bcdfghjklmnpqrstvwxzcdfghlmnrstlmnrst&quot;;</a>
<a name="ln2472">    return consonants[random2(sizeof(consonants) - 1)];</a>
<a name="ln2473">}</a>
<a name="ln2474"> </a>
<a name="ln2475">/**</a>
<a name="ln2476"> * Choose a random consonant tuple/triple, based on the given seed.</a>
<a name="ln2477"> *</a>
<a name="ln2478"> * @param seed  The index into the consonant array; different seed ranges are</a>
<a name="ln2479"> *              expected to correspond with the place in the name being</a>
<a name="ln2480"> *              generated where the consonants should be inserted.</a>
<a name="ln2481"> * @return      A random length 2 or 3 consonant set; e.g. &quot;kl&quot;, &quot;str&quot;, etc.</a>
<a name="ln2482"> *              If the seed is out of bounds, return &quot;&quot;;</a>
<a name="ln2483"> */</a>
<a name="ln2484">static string _random_consonant_set(size_t c)</a>
<a name="ln2485">{</a>
<a name="ln2486">    // Pick a random combination of consonants from the set below.</a>
<a name="ln2487">    //   begin  -&gt; [RCS_BB, RCS_EB) = [ 0, 27)</a>
<a name="ln2488">    //   middle -&gt; [RCS_BM, RCS_EM) = [ 0, 67)</a>
<a name="ln2489">    //   end    -&gt; [RCS_BE, RCS_EE) = [14, 56)</a>
<a name="ln2490"> </a>
<a name="ln2491">    static const string consonant_sets[] = {</a>
<a name="ln2492">        // 0-13: start, middle</a>
<a name="ln2493">        &quot;kl&quot;, &quot;gr&quot;, &quot;cl&quot;, &quot;cr&quot;, &quot;fr&quot;,</a>
<a name="ln2494">        &quot;pr&quot;, &quot;tr&quot;, &quot;tw&quot;, &quot;br&quot;, &quot;pl&quot;,</a>
<a name="ln2495">        &quot;bl&quot;, &quot;str&quot;, &quot;shr&quot;, &quot;thr&quot;,</a>
<a name="ln2496">        // 14-26: start, middle, end</a>
<a name="ln2497">        &quot;sm&quot;, &quot;sh&quot;, &quot;ch&quot;, &quot;th&quot;, &quot;ph&quot;,</a>
<a name="ln2498">        &quot;pn&quot;, &quot;kh&quot;, &quot;gh&quot;, &quot;mn&quot;, &quot;ps&quot;,</a>
<a name="ln2499">        &quot;st&quot;, &quot;sk&quot;, &quot;sch&quot;,</a>
<a name="ln2500">        // 27-55: middle, end</a>
<a name="ln2501">        &quot;ts&quot;, &quot;cs&quot;, &quot;xt&quot;, &quot;nt&quot;, &quot;ll&quot;,</a>
<a name="ln2502">        &quot;rr&quot;, &quot;ss&quot;, &quot;wk&quot;, &quot;wn&quot;, &quot;ng&quot;,</a>
<a name="ln2503">        &quot;cw&quot;, &quot;mp&quot;, &quot;ck&quot;, &quot;nk&quot;, &quot;dd&quot;,</a>
<a name="ln2504">        &quot;tt&quot;, &quot;bb&quot;, &quot;pp&quot;, &quot;nn&quot;, &quot;mm&quot;,</a>
<a name="ln2505">        &quot;kk&quot;, &quot;gg&quot;, &quot;ff&quot;, &quot;pt&quot;, &quot;tz&quot;,</a>
<a name="ln2506">        &quot;dgh&quot;, &quot;rgh&quot;, &quot;rph&quot;, &quot;rch&quot;,</a>
<a name="ln2507">        // 56-66: middle only</a>
<a name="ln2508">        &quot;cz&quot;, &quot;xk&quot;, &quot;zx&quot;, &quot;xz&quot;, &quot;cv&quot;,</a>
<a name="ln2509">        &quot;vv&quot;, &quot;nl&quot;, &quot;rh&quot;, &quot;dw&quot;, &quot;nw&quot;,</a>
<a name="ln2510">        &quot;khl&quot;,</a>
<a name="ln2511">    };</a>
<a name="ln2512">    COMPILE_CHECK(ARRAYSZ(consonant_sets) == RCS_END);</a>
<a name="ln2513"> </a>
<a name="ln2514">    ASSERT_RANGE(c, 0, ARRAYSZ(consonant_sets));</a>
<a name="ln2515"> </a>
<a name="ln2516">    return consonant_sets[c];</a>
<a name="ln2517">}</a>
<a name="ln2518"> </a>
<a name="ln2519">/**</a>
<a name="ln2520"> * Write all possible scroll names to the given file.</a>
<a name="ln2521"> */</a>
<a name="ln2522">static void _test_scroll_names(const string&amp; fname)</a>
<a name="ln2523">{</a>
<a name="ln2524">    FILE *f = fopen(fname.c_str(), &quot;w&quot;);</a>
<a name="ln2525">    if (!f)</a>
<a name="ln2526">        sysfail(&quot;can't write test output&quot;);</a>
<a name="ln2527"> </a>
<a name="ln2528">    string longest;</a>
<a name="ln2529">    for (int i = 0; i &lt; 151; i++)</a>
<a name="ln2530">    {</a>
<a name="ln2531">        for (int j = 0; j &lt; 151; j++)</a>
<a name="ln2532">        {</a>
<a name="ln2533">            const int seed = i | (j &lt;&lt; 8) | (OBJ_SCROLLS &lt;&lt; 16);</a>
<a name="ln2534">            const string name = make_name(seed, MNAME_SCROLL);</a>
<a name="ln2535">            if (name.length() &gt; longest.length())</a>
<a name="ln2536">                longest = name;</a>
<a name="ln2537">            fprintf(f, &quot;%s\n&quot;, name.c_str());</a>
<a name="ln2538">        }</a>
<a name="ln2539">    }</a>
<a name="ln2540"> </a>
<a name="ln2541">    fprintf(f, &quot;\nLongest: %s (%d)\n&quot;, longest.c_str(), (int)longest.length());</a>
<a name="ln2542"> </a>
<a name="ln2543">    fclose(f);</a>
<a name="ln2544">}</a>
<a name="ln2545"> </a>
<a name="ln2546">/**</a>
<a name="ln2547"> * Write one million random Jiyva names to the given file.</a>
<a name="ln2548"> */</a>
<a name="ln2549">static void _test_jiyva_names(const string&amp; fname)</a>
<a name="ln2550">{</a>
<a name="ln2551">    FILE *f = fopen(fname.c_str(), &quot;w&quot;);</a>
<a name="ln2552">    if (!f)</a>
<a name="ln2553">        sysfail(&quot;can't write test output&quot;);</a>
<a name="ln2554"> </a>
<a name="ln2555">    string longest;</a>
<a name="ln2556">    rng::seed(27);</a>
<a name="ln2557">    for (int i = 0; i &lt; 1000000; i++)</a>
<a name="ln2558">    {</a>
<a name="ln2559">        const string name = make_name(rng::get_uint32(), MNAME_JIYVA);</a>
<a name="ln2560">        ASSERT(name[0] == 'J');</a>
<a name="ln2561">        if (name.length() &gt; longest.length())</a>
<a name="ln2562">            longest = name;</a>
<a name="ln2563">        fprintf(f, &quot;%s\n&quot;, name.c_str());</a>
<a name="ln2564">    }</a>
<a name="ln2565"> </a>
<a name="ln2566">    fprintf(f, &quot;\nLongest: %s (%d)\n&quot;, longest.c_str(), (int)longest.length());</a>
<a name="ln2567"> </a>
<a name="ln2568">    fclose(f);</a>
<a name="ln2569">}</a>
<a name="ln2570"> </a>
<a name="ln2571">/**</a>
<a name="ln2572"> * Test make_name().</a>
<a name="ln2573"> *</a>
<a name="ln2574"> * Currently just a stress test iterating over all possible scroll names.</a>
<a name="ln2575"> */</a>
<a name="ln2576">void make_name_tests()</a>
<a name="ln2577">{</a>
<a name="ln2578">    _test_jiyva_names(&quot;jiyva_names.out&quot;);</a>
<a name="ln2579">    _test_scroll_names(&quot;scroll_names.out&quot;);</a>
<a name="ln2580"> </a>
<a name="ln2581">    rng::seed(27);</a>
<a name="ln2582">    for (int i = 0; i &lt; 1000000; ++i)</a>
<a name="ln2583">        make_name();</a>
<a name="ln2584">}</a>
<a name="ln2585"> </a>
<a name="ln2586">bool is_interesting_item(const item_def&amp; item)</a>
<a name="ln2587">{</a>
<a name="ln2588">    if (fully_identified(item) &amp;&amp; is_artefact(item))</a>
<a name="ln2589">        return true;</a>
<a name="ln2590"> </a>
<a name="ln2591">    const string iname = item_prefix(item, false) + &quot; &quot; + item.name(DESC_PLAIN);</a>
<a name="ln2592">    for (const text_pattern &amp;pat : Options.note_items)</a>
<a name="ln2593">        if (pat.matches(iname))</a>
<a name="ln2594">            return true;</a>
<a name="ln2595"> </a>
<a name="ln2596">    return false;</a>
<a name="ln2597">}</a>
<a name="ln2598"> </a>
<a name="ln2599">/**</a>
<a name="ln2600"> * Is an item a potentially life-saving consumable in emergency situations?</a>
<a name="ln2601"> * Unlike similar functions, this one never takes temporary conditions into</a>
<a name="ln2602"> * account. It does, however, take religion and mutations into account.</a>
<a name="ln2603"> * Permanently unusable items are in general not considered emergency items.</a>
<a name="ln2604"> *</a>
<a name="ln2605"> * @param item The item being queried.</a>
<a name="ln2606"> * @return True if the item is known to be an emergency item.</a>
<a name="ln2607"> */</a>
<a name="ln2608">bool is_emergency_item(const item_def &amp;item)</a>
<a name="ln2609">{</a>
<a name="ln2610">    if (!item_type_known(item))</a>
<a name="ln2611">        return false;</a>
<a name="ln2612"> </a>
<a name="ln2613">    switch (item.base_type)</a>
<a name="ln2614">    {</a>
<a name="ln2615">    case OBJ_SCROLLS:</a>
<a name="ln2616">        switch (item.sub_type)</a>
<a name="ln2617">        {</a>
<a name="ln2618">        case SCR_TELEPORTATION:</a>
<a name="ln2619">        case SCR_BLINKING:</a>
<a name="ln2620">            return you.species != SP_FORMICID;</a>
<a name="ln2621">        case SCR_FEAR:</a>
<a name="ln2622">        case SCR_FOG:</a>
<a name="ln2623">            return true;</a>
<a name="ln2624">        default:</a>
<a name="ln2625">            return false;</a>
<a name="ln2626">        }</a>
<a name="ln2627">    case OBJ_POTIONS:</a>
<a name="ln2628">        if (you.species == SP_MUMMY)</a>
<a name="ln2629">            return false;</a>
<a name="ln2630"> </a>
<a name="ln2631">        switch (item.sub_type)</a>
<a name="ln2632">        {</a>
<a name="ln2633">        case POT_HASTE:</a>
<a name="ln2634">            return !have_passive(passive_t::no_haste)</a>
<a name="ln2635">                &amp;&amp; you.species != SP_FORMICID;</a>
<a name="ln2636">        case POT_HEAL_WOUNDS:</a>
<a name="ln2637">            return you.can_potion_heal();</a>
<a name="ln2638">        case POT_CURING:</a>
<a name="ln2639">        case POT_RESISTANCE:</a>
<a name="ln2640">        case POT_MAGIC:</a>
<a name="ln2641">            return true;</a>
<a name="ln2642">        default:</a>
<a name="ln2643">            return false;</a>
<a name="ln2644">        }</a>
<a name="ln2645">    default:</a>
<a name="ln2646">        return false;</a>
<a name="ln2647">    }</a>
<a name="ln2648">}</a>
<a name="ln2649"> </a>
<a name="ln2650">/**</a>
<a name="ln2651"> * Is an item a particularly good consumable? Unlike similar functions,</a>
<a name="ln2652"> * this one never takes temporary conditions into account. Permanently</a>
<a name="ln2653"> * unusable items are in general not considered good.</a>
<a name="ln2654"> *</a>
<a name="ln2655"> * @param item The item being queried.</a>
<a name="ln2656"> * @return True if the item is known to be good.</a>
<a name="ln2657"> */</a>
<a name="ln2658">bool is_good_item(const item_def &amp;item)</a>
<a name="ln2659">{</a>
<a name="ln2660">    if (!item_type_known(item))</a>
<a name="ln2661">        return false;</a>
<a name="ln2662"> </a>
<a name="ln2663">    if (is_emergency_item(item))</a>
<a name="ln2664">        return true;</a>
<a name="ln2665"> </a>
<a name="ln2666">    switch (item.base_type)</a>
<a name="ln2667">    {</a>
<a name="ln2668">    case OBJ_SCROLLS:</a>
<a name="ln2669">        return item.sub_type == SCR_ACQUIREMENT;</a>
<a name="ln2670">    case OBJ_POTIONS:</a>
<a name="ln2671">        if (you.species == SP_MUMMY)</a>
<a name="ln2672">            return false;</a>
<a name="ln2673">        switch (item.sub_type)</a>
<a name="ln2674">        {</a>
<a name="ln2675">        case POT_EXPERIENCE:</a>
<a name="ln2676">            return true;</a>
<a name="ln2677">        default:</a>
<a name="ln2678">            return false;</a>
<a name="ln2679">        CASE_REMOVED_POTIONS(item.sub_type)</a>
<a name="ln2680">        }</a>
<a name="ln2681">    default:</a>
<a name="ln2682">        return false;</a>
<a name="ln2683">    }</a>
<a name="ln2684">}</a>
<a name="ln2685"> </a>
<a name="ln2686">/**</a>
<a name="ln2687"> * Is an item strictly harmful?</a>
<a name="ln2688"> *</a>
<a name="ln2689"> * @param item The item being queried.</a>
<a name="ln2690"> * @return True if the item is known to have only harmful effects.</a>
<a name="ln2691"> */</a>
<a name="ln2692">bool is_bad_item(const item_def &amp;item)</a>
<a name="ln2693">{</a>
<a name="ln2694">    if (!item_type_known(item))</a>
<a name="ln2695">        return false;</a>
<a name="ln2696"> </a>
<a name="ln2697">    switch (item.base_type)</a>
<a name="ln2698">    {</a>
<a name="ln2699">    case OBJ_SCROLLS:</a>
<a name="ln2700">        switch (item.sub_type)</a>
<a name="ln2701">        {</a>
<a name="ln2702">#if TAG_MAJOR_VERSION == 34</a>
<a name="ln2703">        case SCR_CURSE_ARMOUR:</a>
<a name="ln2704">        case SCR_CURSE_WEAPON:</a>
<a name="ln2705">            if (you.species == SP_FELID)</a>
<a name="ln2706">                return false;</a>
<a name="ln2707">        case SCR_CURSE_JEWELLERY:</a>
<a name="ln2708">            return !have_passive(passive_t::want_curses);</a>
<a name="ln2709">#endif</a>
<a name="ln2710">        case SCR_NOISE:</a>
<a name="ln2711">            return true;</a>
<a name="ln2712">        default:</a>
<a name="ln2713">            return false;</a>
<a name="ln2714">        }</a>
<a name="ln2715">    case OBJ_POTIONS:</a>
<a name="ln2716">        // Can't be bad if you can't use them.</a>
<a name="ln2717">        if (you.species == SP_MUMMY)</a>
<a name="ln2718">            return false;</a>
<a name="ln2719"> </a>
<a name="ln2720">        switch (item.sub_type)</a>
<a name="ln2721">        {</a>
<a name="ln2722">        case POT_DEGENERATION:</a>
<a name="ln2723">            return true;</a>
<a name="ln2724">        default:</a>
<a name="ln2725">            return false;</a>
<a name="ln2726">        CASE_REMOVED_POTIONS(item.sub_type);</a>
<a name="ln2727">        }</a>
<a name="ln2728">    case OBJ_JEWELLERY:</a>
<a name="ln2729">        // Potentially useful. TODO: check the properties.</a>
<a name="ln2730">        if (is_artefact(item))</a>
<a name="ln2731">            return false;</a>
<a name="ln2732"> </a>
<a name="ln2733">        switch (item.sub_type)</a>
<a name="ln2734">        {</a>
<a name="ln2735">        case AMU_INACCURACY:</a>
<a name="ln2736">        case RING_ATTENTION:</a>
<a name="ln2737">            return true;</a>
<a name="ln2738">        case RING_TELEPORTATION:</a>
<a name="ln2739">            return !(you.stasis() || crawl_state.game_is_sprint());</a>
<a name="ln2740">        case RING_EVASION:</a>
<a name="ln2741">        case RING_PROTECTION:</a>
<a name="ln2742">        case RING_STRENGTH:</a>
<a name="ln2743">        case RING_DEXTERITY:</a>
<a name="ln2744">        case RING_INTELLIGENCE:</a>
<a name="ln2745">        case RING_SLAYING:</a>
<a name="ln2746">            return item_ident(item, ISFLAG_KNOW_PLUSES) &amp;&amp; item.plus &lt;= 0;</a>
<a name="ln2747">        default:</a>
<a name="ln2748">            return false;</a>
<a name="ln2749">        }</a>
<a name="ln2750"> </a>
<a name="ln2751">    default:</a>
<a name="ln2752">        return false;</a>
<a name="ln2753">    }</a>
<a name="ln2754">}</a>
<a name="ln2755"> </a>
<a name="ln2756">/**</a>
<a name="ln2757"> * Is an item dangerous but potentially worthwhile?</a>
<a name="ln2758"> *</a>
<a name="ln2759"> * @param item The item being queried.</a>
<a name="ln2760"> * @param temp Should temporary conditions such as transformations and</a>
<a name="ln2761"> *             vampire hunger levels be taken into account?  Religion (but</a>
<a name="ln2762"> *             not its absence) is considered to be permanent here.</a>
<a name="ln2763"> * @return True if using the item is known to be risky but occasionally</a>
<a name="ln2764"> *         worthwhile.</a>
<a name="ln2765"> */</a>
<a name="ln2766">bool is_dangerous_item(const item_def &amp;item, bool temp)</a>
<a name="ln2767">{</a>
<a name="ln2768">    if (!item_type_known(item))</a>
<a name="ln2769">        return false;</a>
<a name="ln2770"> </a>
<a name="ln2771">    // useless items can hardly be dangerous.</a>
<a name="ln2772">    if (is_useless_item(item, temp))</a>
<a name="ln2773">        return false;</a>
<a name="ln2774"> </a>
<a name="ln2775">    switch (item.base_type)</a>
<a name="ln2776">    {</a>
<a name="ln2777">    case OBJ_SCROLLS:</a>
<a name="ln2778">        switch (item.sub_type)</a>
<a name="ln2779">        {</a>
<a name="ln2780">        case SCR_IMMOLATION:</a>
<a name="ln2781">        case SCR_VULNERABILITY:</a>
<a name="ln2782">            return true;</a>
<a name="ln2783">        case SCR_TORMENT:</a>
<a name="ln2784">            return !you.get_mutation_level(MUT_TORMENT_RESISTANCE)</a>
<a name="ln2785">                   || !temp &amp;&amp; you.species == SP_VAMPIRE;</a>
<a name="ln2786">        case SCR_HOLY_WORD:</a>
<a name="ln2787">            return you.undead_or_demonic();</a>
<a name="ln2788">        default:</a>
<a name="ln2789">            return false;</a>
<a name="ln2790">        }</a>
<a name="ln2791"> </a>
<a name="ln2792">    case OBJ_POTIONS:</a>
<a name="ln2793">        switch (item.sub_type)</a>
<a name="ln2794">        {</a>
<a name="ln2795">        case POT_MUTATION:</a>
<a name="ln2796">            if (have_passive(passive_t::cleanse_mut_potions))</a>
<a name="ln2797">                return false;</a>
<a name="ln2798">            // intentional fallthrough</a>
<a name="ln2799">        case POT_LIGNIFY:</a>
<a name="ln2800">            return true;</a>
<a name="ln2801">        default:</a>
<a name="ln2802">            return false;</a>
<a name="ln2803">        }</a>
<a name="ln2804"> </a>
<a name="ln2805">    case OBJ_MISCELLANY:</a>
<a name="ln2806">        // Tremorstones will blow you right up.</a>
<a name="ln2807">        return item.sub_type == MISC_TIN_OF_TREMORSTONES;</a>
<a name="ln2808"> </a>
<a name="ln2809">    default:</a>
<a name="ln2810">        return false;</a>
<a name="ln2811">    }</a>
<a name="ln2812">}</a>
<a name="ln2813"> </a>
<a name="ln2814">static bool _invisibility_is_useless(const bool temp)</a>
<a name="ln2815">{</a>
<a name="ln2816">    // If you're Corona'd or a TSO-ite, this is always useless.</a>
<a name="ln2817">    return temp ? you.backlit()</a>
<a name="ln2818">                : you.haloed() &amp;&amp; will_have_passive(passive_t::halo);</a>
<a name="ln2819">}</a>
<a name="ln2820"> </a>
<a name="ln2821">/**</a>
<a name="ln2822"> * Is an item (more or less) useless to the player? Uselessness includes</a>
<a name="ln2823"> * but is not limited to situations such as:</a>
<a name="ln2824"> * \li The item cannot be used.</a>
<a name="ln2825"> * \li Using the item would have no effect.</a>
<a name="ln2826"> * \li Using the item would have purely negative effects (&lt;tt&gt;is_bad_item&lt;/tt&gt;).</a>
<a name="ln2827"> * \li Using the item is expected to produce no benefit for a player of their</a>
<a name="ln2828"> *     religious standing. For example, magic enhancers for Trog worshippers</a>
<a name="ln2829"> *     are &quot;useless&quot;, even if the player knows a spell and therefore could</a>
<a name="ln2830"> *     benefit.</a>
<a name="ln2831"> *</a>
<a name="ln2832"> * @param item The item being queried.</a>
<a name="ln2833"> * @param temp Should temporary conditions such as transformations and</a>
<a name="ln2834"> *             vampire hunger levels be taken into account? Religion (but</a>
<a name="ln2835"> *             not its absence) is considered to be permanent here.</a>
<a name="ln2836"> * @return True if the item is known to be useless.</a>
<a name="ln2837"> */</a>
<a name="ln2838">bool is_useless_item(const item_def &amp;item, bool temp)</a>
<a name="ln2839">{</a>
<a name="ln2840">    // During game startup, no item is useless. If someone re-glyphs an item</a>
<a name="ln2841">    // based on its uselessness, the glyph-to-item cache will use the useless</a>
<a name="ln2842">    // value even if your god or species can make use of it.</a>
<a name="ln2843">    if (you.species == SP_UNKNOWN)</a>
<a name="ln2844">        return false;</a>
<a name="ln2845"> </a>
<a name="ln2846">    switch (item.base_type)</a>
<a name="ln2847">    {</a>
<a name="ln2848">    case OBJ_WEAPONS:</a>
<a name="ln2849">        if (you.species == SP_FELID)</a>
<a name="ln2850">            return true;</a>
<a name="ln2851"> </a>
<a name="ln2852">        if (!you.could_wield(item, true, !temp)</a>
<a name="ln2853">            &amp;&amp; !is_throwable(&amp;you, item))</a>
<a name="ln2854">        {</a>
<a name="ln2855">            // Weapon is too large (or small) to be wielded and cannot</a>
<a name="ln2856">            // be thrown either.</a>
<a name="ln2857">            return true;</a>
<a name="ln2858">        }</a>
<a name="ln2859"> </a>
<a name="ln2860">        if (you.undead_or_demonic() &amp;&amp; is_holy_item(item, false))</a>
<a name="ln2861">        {</a>
<a name="ln2862">            if (!temp &amp;&amp; you.form == transformation::lich</a>
<a name="ln2863">                &amp;&amp; you.species != SP_DEMONSPAWN)</a>
<a name="ln2864">            {</a>
<a name="ln2865">                return false;</a>
<a name="ln2866">            }</a>
<a name="ln2867">            return true;</a>
<a name="ln2868">        }</a>
<a name="ln2869"> </a>
<a name="ln2870">        return false;</a>
<a name="ln2871"> </a>
<a name="ln2872">    case OBJ_MISSILES:</a>
<a name="ln2873">        if ((you.has_spell(SPELL_STICKS_TO_SNAKES)</a>
<a name="ln2874">                || !you.num_turns &amp;&amp; you.char_class == JOB_TRANSMUTER)</a>
<a name="ln2875">                &amp;&amp; item.sub_type == MI_ARROW</a>
<a name="ln2876">            || (you.has_spell(SPELL_SANDBLAST)</a>
<a name="ln2877">                || !you.num_turns &amp;&amp; you.char_class == JOB_EARTH_ELEMENTALIST)</a>
<a name="ln2878">                &amp;&amp; item.sub_type == MI_STONE)</a>
<a name="ln2879">        {</a>
<a name="ln2880">            return false;</a>
<a name="ln2881">        }</a>
<a name="ln2882"> </a>
<a name="ln2883">        // Save for the above spells, all missiles are useless for felids.</a>
<a name="ln2884">        if (you.species == SP_FELID)</a>
<a name="ln2885">            return true;</a>
<a name="ln2886"> </a>
<a name="ln2887">        // These are the same checks as in is_throwable(), except that</a>
<a name="ln2888">        // we don't take launchers into account.</a>
<a name="ln2889">        switch (item.sub_type)</a>
<a name="ln2890">        {</a>
<a name="ln2891">        case MI_LARGE_ROCK:</a>
<a name="ln2892">            return !you.can_throw_large_rocks();</a>
<a name="ln2893">        case MI_JAVELIN:</a>
<a name="ln2894">            return you.body_size(PSIZE_BODY, !temp) &lt; SIZE_MEDIUM</a>
<a name="ln2895">                   &amp;&amp; !you.can_throw_large_rocks();</a>
<a name="ln2896">        }</a>
<a name="ln2897"> </a>
<a name="ln2898">        return false;</a>
<a name="ln2899"> </a>
<a name="ln2900">    case OBJ_ARMOUR:</a>
<a name="ln2901">        if (!can_wear_armour(item, false, true))</a>
<a name="ln2902">            return true;</a>
<a name="ln2903"> </a>
<a name="ln2904">        if (is_shield(item) &amp;&amp; you.get_mutation_level(MUT_MISSING_HAND))</a>
<a name="ln2905">            return true;</a>
<a name="ln2906"> </a>
<a name="ln2907">        if (is_artefact(item))</a>
<a name="ln2908">            return false;</a>
<a name="ln2909"> </a>
<a name="ln2910">        if (item.sub_type == ARM_SCARF &amp;&amp; item_type_known(item))</a>
<a name="ln2911">        {</a>
<a name="ln2912">            special_armour_type ego = get_armour_ego_type(item);</a>
<a name="ln2913">            switch (ego)</a>
<a name="ln2914">            {</a>
<a name="ln2915">            case SPARM_SPIRIT_SHIELD:</a>
<a name="ln2916">                return you.spirit_shield(false, false);</a>
<a name="ln2917">            case SPARM_CLOUD_IMMUNE:</a>
<a name="ln2918">                return have_passive(passive_t::cloud_immunity);</a>
<a name="ln2919">            case SPARM_REPULSION:</a>
<a name="ln2920">                return temp &amp;&amp; have_passive(passive_t::upgraded_storm_shield)</a>
<a name="ln2921">                       || you.get_mutation_level(MUT_DISTORTION_FIELD) == 3;</a>
<a name="ln2922">            default:</a>
<a name="ln2923">                return false;</a>
<a name="ln2924">            }</a>
<a name="ln2925">        }</a>
<a name="ln2926">        return false;</a>
<a name="ln2927"> </a>
<a name="ln2928">    case OBJ_SCROLLS:</a>
<a name="ln2929">        if (temp &amp;&amp; silenced(you.pos()))</a>
<a name="ln2930">            return true; // can't use scrolls while silenced</a>
<a name="ln2931"> </a>
<a name="ln2932">        if (!item_type_known(item))</a>
<a name="ln2933">            return false;</a>
<a name="ln2934"> </a>
<a name="ln2935">        // A bad item is always useless.</a>
<a name="ln2936">        if (is_bad_item(item))</a>
<a name="ln2937">            return true;</a>
<a name="ln2938"> </a>
<a name="ln2939">        switch (item.sub_type)</a>
<a name="ln2940">        {</a>
<a name="ln2941">        case SCR_RANDOM_USELESSNESS:</a>
<a name="ln2942">            return true;</a>
<a name="ln2943">        case SCR_TELEPORTATION:</a>
<a name="ln2944">            return you.species == SP_FORMICID</a>
<a name="ln2945">                   || crawl_state.game_is_sprint()</a>
<a name="ln2946">                   || player_in_branch(BRANCH_GAUNTLET);</a>
<a name="ln2947">        case SCR_BLINKING:</a>
<a name="ln2948">            return you.species == SP_FORMICID;</a>
<a name="ln2949">        case SCR_AMNESIA:</a>
<a name="ln2950">            return you_worship(GOD_TROG);</a>
<a name="ln2951">#if TAG_MAJOR_VERSION == 34</a>
<a name="ln2952">        case SCR_CURSE_WEAPON: // for non-Ashenzari, already handled</a>
<a name="ln2953">        case SCR_CURSE_ARMOUR:</a>
<a name="ln2954">#endif</a>
<a name="ln2955">        case SCR_ENCHANT_WEAPON:</a>
<a name="ln2956">        case SCR_ENCHANT_ARMOUR:</a>
<a name="ln2957">        case SCR_BRAND_WEAPON:</a>
<a name="ln2958">            return you.species == SP_FELID;</a>
<a name="ln2959">        case SCR_SUMMONING:</a>
<a name="ln2960">            return you.get_mutation_level(MUT_NO_LOVE) &gt; 0;</a>
<a name="ln2961">        case SCR_FOG:</a>
<a name="ln2962">            return temp &amp;&amp; (env.level_state &amp; LSTATE_STILL_WINDS);</a>
<a name="ln2963">        default:</a>
<a name="ln2964">            return false;</a>
<a name="ln2965">        }</a>
<a name="ln2966"> </a>
<a name="ln2967">    case OBJ_WANDS:</a>
<a name="ln2968">        if (you.get_mutation_level(MUT_NO_ARTIFICE))</a>
<a name="ln2969">            return true;</a>
<a name="ln2970"> </a>
<a name="ln2971">#if TAG_MAJOR_VERSION == 34</a>
<a name="ln2972">        if (is_known_empty_wand(item))</a>
<a name="ln2973">            return true;</a>
<a name="ln2974">#endif</a>
<a name="ln2975">        if (!item_type_known(item))</a>
<a name="ln2976">            return false;</a>
<a name="ln2977"> </a>
<a name="ln2978">        if (item.sub_type == WAND_ENSLAVEMENT)</a>
<a name="ln2979">            return you.get_mutation_level(MUT_NO_LOVE);</a>
<a name="ln2980"> </a>
<a name="ln2981">        if (item.sub_type == WAND_CLOUDS)</a>
<a name="ln2982">            return temp &amp;&amp; (env.level_state &amp; LSTATE_STILL_WINDS);</a>
<a name="ln2983"> </a>
<a name="ln2984">        return false;</a>
<a name="ln2985"> </a>
<a name="ln2986">    case OBJ_POTIONS:</a>
<a name="ln2987">    {</a>
<a name="ln2988">        // Mummies can't use potions.</a>
<a name="ln2989">        if (you.undead_state(temp) == US_UNDEAD)</a>
<a name="ln2990">            return true;</a>
<a name="ln2991"> </a>
<a name="ln2992">        if (!item_type_known(item))</a>
<a name="ln2993">            return false;</a>
<a name="ln2994"> </a>
<a name="ln2995">        // A bad item is always useless.</a>
<a name="ln2996">        if (is_bad_item(item))</a>
<a name="ln2997">            return true;</a>
<a name="ln2998"> </a>
<a name="ln2999">        switch (item.sub_type)</a>
<a name="ln3000">        {</a>
<a name="ln3001">        case POT_BERSERK_RAGE:</a>
<a name="ln3002">            return !you.can_go_berserk(true, true, true, nullptr, temp);</a>
<a name="ln3003">        case POT_HASTE:</a>
<a name="ln3004">            return you.stasis();</a>
<a name="ln3005">        case POT_MUTATION:</a>
<a name="ln3006">            return !you.can_safely_mutate(temp);</a>
<a name="ln3007"> </a>
<a name="ln3008">        case POT_LIGNIFY:</a>
<a name="ln3009">            return you.undead_state(temp)</a>
<a name="ln3010">                   &amp;&amp; (you.species != SP_VAMPIRE</a>
<a name="ln3011">                       || temp &amp;&amp; !you.vampire_alive);</a>
<a name="ln3012"> </a>
<a name="ln3013">        case POT_FLIGHT:</a>
<a name="ln3014">            return you.permanent_flight()</a>
<a name="ln3015">                   || you.racial_permanent_flight();</a>
<a name="ln3016">        case POT_HEAL_WOUNDS:</a>
<a name="ln3017">            return !you.can_potion_heal();</a>
<a name="ln3018">        case POT_INVISIBILITY:</a>
<a name="ln3019">            return _invisibility_is_useless(temp);</a>
<a name="ln3020">        CASE_REMOVED_POTIONS(item.sub_type)</a>
<a name="ln3021">        }</a>
<a name="ln3022"> </a>
<a name="ln3023">        return false;</a>
<a name="ln3024">    }</a>
<a name="ln3025">    case OBJ_JEWELLERY:</a>
<a name="ln3026">        if (!item_type_known(item))</a>
<a name="ln3027">            return false;</a>
<a name="ln3028"> </a>
<a name="ln3029">        // Potentially useful. TODO: check the properties.</a>
<a name="ln3030">        if (is_artefact(item))</a>
<a name="ln3031">            return false;</a>
<a name="ln3032"> </a>
<a name="ln3033">        if (is_bad_item(item))</a>
<a name="ln3034">            return true;</a>
<a name="ln3035"> </a>
<a name="ln3036">        switch (item.sub_type)</a>
<a name="ln3037">        {</a>
<a name="ln3038">        case AMU_RAGE:</a>
<a name="ln3039">            return you.undead_state(temp)</a>
<a name="ln3040">                   &amp;&amp; (you.species != SP_VAMPIRE</a>
<a name="ln3041">                       || temp &amp;&amp; !you.vampire_alive)</a>
<a name="ln3042">                   || you.species == SP_FORMICID</a>
<a name="ln3043">                   || you.get_mutation_level(MUT_NO_ARTIFICE);</a>
<a name="ln3044"> </a>
<a name="ln3045">        case RING_RESIST_CORROSION:</a>
<a name="ln3046">            return you.res_corr(false, false);</a>
<a name="ln3047"> </a>
<a name="ln3048">        case AMU_THE_GOURMAND:</a>
<a name="ln3049">            return player_likes_chunks(true)</a>
<a name="ln3050">                   || you.get_mutation_level(MUT_GOURMAND) &gt; 0</a>
<a name="ln3051">                   || you.get_mutation_level(MUT_HERBIVOROUS) &gt; 0</a>
<a name="ln3052">                   || you.undead_state(temp);</a>
<a name="ln3053"> </a>
<a name="ln3054">        case AMU_FAITH:</a>
<a name="ln3055">            return (you.species == SP_DEMIGOD &amp;&amp; !you.religion)</a>
<a name="ln3056">                    || you_worship(GOD_GOZAG)</a>
<a name="ln3057">                    || (you_worship(GOD_RU) &amp;&amp; you.piety == piety_breakpoint(5));</a>
<a name="ln3058"> </a>
<a name="ln3059">        case AMU_GUARDIAN_SPIRIT:</a>
<a name="ln3060">            return you.spirit_shield(false, false);</a>
<a name="ln3061"> </a>
<a name="ln3062">        case RING_LIFE_PROTECTION:</a>
<a name="ln3063">            return player_prot_life(false, temp, false) == 3;</a>
<a name="ln3064"> </a>
<a name="ln3065">        case AMU_REGENERATION:</a>
<a name="ln3066">            return you.get_mutation_level(MUT_NO_REGENERATION) &gt; 0</a>
<a name="ln3067">                   || (temp</a>
<a name="ln3068">                       &amp;&amp; (you.get_mutation_level(MUT_INHIBITED_REGENERATION) &gt; 0</a>
<a name="ln3069">                           || you.species == SP_VAMPIRE)</a>
<a name="ln3070">                       &amp;&amp; regeneration_is_inhibited());</a>
<a name="ln3071"> </a>
<a name="ln3072">#if TAG_MAJOR_VERSION == 34</a>
<a name="ln3073">        case AMU_MANA_REGENERATION:</a>
<a name="ln3074">            return you_worship(GOD_PAKELLAS);</a>
<a name="ln3075">#endif</a>
<a name="ln3076"> </a>
<a name="ln3077">        case RING_SEE_INVISIBLE:</a>
<a name="ln3078">            return you.innate_sinv();</a>
<a name="ln3079"> </a>
<a name="ln3080">        case RING_POISON_RESISTANCE:</a>
<a name="ln3081">            return player_res_poison(false, temp, false) &gt; 0</a>
<a name="ln3082">                   &amp;&amp; (temp || you.species != SP_VAMPIRE);</a>
<a name="ln3083"> </a>
<a name="ln3084">        case RING_WIZARDRY:</a>
<a name="ln3085">            return you_worship(GOD_TROG);</a>
<a name="ln3086"> </a>
<a name="ln3087">        case RING_TELEPORTATION:</a>
<a name="ln3088">            return !is_bad_item(item);</a>
<a name="ln3089"> </a>
<a name="ln3090">        case RING_FLIGHT:</a>
<a name="ln3091">            return you.permanent_flight()</a>
<a name="ln3092">                   || you.racial_permanent_flight()</a>
<a name="ln3093">                   || you.get_mutation_level(MUT_NO_ARTIFICE);</a>
<a name="ln3094"> </a>
<a name="ln3095">        case RING_STEALTH:</a>
<a name="ln3096">            return you.get_mutation_level(MUT_NO_STEALTH);</a>
<a name="ln3097"> </a>
<a name="ln3098">        default:</a>
<a name="ln3099">            return false;</a>
<a name="ln3100">        }</a>
<a name="ln3101"> </a>
<a name="ln3102">#if TAG_MAJOR_VERSION == 34</a>
<a name="ln3103">    case OBJ_RODS:</a>
<a name="ln3104">            return true;</a>
<a name="ln3105">#endif</a>
<a name="ln3106"> </a>
<a name="ln3107">    case OBJ_STAVES:</a>
<a name="ln3108">        if (you.species == SP_FELID)</a>
<a name="ln3109">            return true;</a>
<a name="ln3110">        if (!you.could_wield(item, true, !temp))</a>
<a name="ln3111">        {</a>
<a name="ln3112">            // Weapon is too large (or small) to be wielded and cannot</a>
<a name="ln3113">            // be thrown either.</a>
<a name="ln3114">            return true;</a>
<a name="ln3115">        }</a>
<a name="ln3116">        if (!item_type_known(item))</a>
<a name="ln3117">            return false;</a>
<a name="ln3118"> </a>
<a name="ln3119">        switch (item.sub_type)</a>
<a name="ln3120">        {</a>
<a name="ln3121">        case STAFF_WIZARDRY:</a>
<a name="ln3122">        case STAFF_CONJURATION:</a>
<a name="ln3123">        case STAFF_SUMMONING:</a>
<a name="ln3124">            return you_worship(GOD_TROG);</a>
<a name="ln3125">        }</a>
<a name="ln3126"> </a>
<a name="ln3127">        return false;</a>
<a name="ln3128"> </a>
<a name="ln3129">    case OBJ_FOOD:</a>
<a name="ln3130">        if (item.sub_type == NUM_FOODS)</a>
<a name="ln3131">            break;</a>
<a name="ln3132"> </a>
<a name="ln3133">        if (!is_inedible(item))</a>
<a name="ln3134">            return false;</a>
<a name="ln3135"> </a>
<a name="ln3136">        if (!temp &amp;&amp; you.form == transformation::lich)</a>
<a name="ln3137">        {</a>
<a name="ln3138">            // See what would happen if we were in our normal state.</a>
<a name="ln3139">            unwind_var&lt;transformation&gt; formsim(you.form, transformation::none);</a>
<a name="ln3140"> </a>
<a name="ln3141">            if (!is_inedible(item))</a>
<a name="ln3142">                return false;</a>
<a name="ln3143">        }</a>
<a name="ln3144"> </a>
<a name="ln3145">        return true;</a>
<a name="ln3146"> </a>
<a name="ln3147">    case OBJ_CORPSES:</a>
<a name="ln3148">        if (item.sub_type != CORPSE_SKELETON &amp;&amp; !you_foodless())</a>
<a name="ln3149">            return false;</a>
<a name="ln3150"> </a>
<a name="ln3151">        if (you.has_spell(SPELL_ANIMATE_DEAD)</a>
<a name="ln3152">            || you.has_spell(SPELL_ANIMATE_SKELETON)</a>
<a name="ln3153">            || you.has_spell(SPELL_SIMULACRUM)</a>
<a name="ln3154">            || you_worship(GOD_YREDELEMNUL) &amp;&amp; !you.penance[GOD_YREDELEMNUL]</a>
<a name="ln3155">               &amp;&amp; you.piety &gt;= piety_breakpoint(0))</a>
<a name="ln3156">        {</a>
<a name="ln3157">            return false;</a>
<a name="ln3158">        }</a>
<a name="ln3159"> </a>
<a name="ln3160">        return true;</a>
<a name="ln3161"> </a>
<a name="ln3162">    case OBJ_MISCELLANY:</a>
<a name="ln3163">        switch (item.sub_type)</a>
<a name="ln3164">        {</a>
<a name="ln3165">#if TAG_MAJOR_VERSION == 34</a>
<a name="ln3166">        case MISC_BUGGY_EBONY_CASKET:</a>
<a name="ln3167">            return item_type_known(item);</a>
<a name="ln3168">#endif</a>
<a name="ln3169">        // These can always be used.</a>
<a name="ln3170">#if TAG_MAJOR_VERSION == 34</a>
<a name="ln3171">        case MISC_BUGGY_LANTERN_OF_SHADOWS:</a>
<a name="ln3172">#endif</a>
<a name="ln3173">        case MISC_ZIGGURAT:</a>
<a name="ln3174">            return false;</a>
<a name="ln3175"> </a>
<a name="ln3176">        // Purely summoning misc items don't work w/ sac love</a>
<a name="ln3177">        case MISC_BOX_OF_BEASTS:</a>
<a name="ln3178">        case MISC_HORN_OF_GERYON:</a>
<a name="ln3179">        case MISC_PHANTOM_MIRROR:</a>
<a name="ln3180">            return you.get_mutation_level(MUT_NO_LOVE)</a>
<a name="ln3181">                   || you.get_mutation_level(MUT_NO_ARTIFICE);</a>
<a name="ln3182"> </a>
<a name="ln3183">        default:</a>
<a name="ln3184">            return you.get_mutation_level(MUT_NO_ARTIFICE);</a>
<a name="ln3185">        }</a>
<a name="ln3186"> </a>
<a name="ln3187">    case OBJ_BOOKS:</a>
<a name="ln3188">        if (!item_type_known(item))</a>
<a name="ln3189">            return false;</a>
<a name="ln3190">        if (item_type_known(item) &amp;&amp; item.sub_type != BOOK_MANUAL)</a>
<a name="ln3191">        {</a>
<a name="ln3192">            // Spellbooks are useless if all spells are either in the library</a>
<a name="ln3193">            // already or are uncastable.</a>
<a name="ln3194">            bool useless = true;</a>
<a name="ln3195">            for (spell_type st : spells_in_book(item))</a>
<a name="ln3196">                if (!you.spell_library[st] &amp;&amp; you_can_memorise(st))</a>
<a name="ln3197">                    useless = false;</a>
<a name="ln3198">            return useless;</a>
<a name="ln3199">        }</a>
<a name="ln3200">        // If we're here, it's a manual.</a>
<a name="ln3201">        if (you.skills[item.plus] &gt;= 27)</a>
<a name="ln3202">            return true;</a>
<a name="ln3203">        if (is_useless_skill((skill_type)item.plus))</a>
<a name="ln3204">            return true;</a>
<a name="ln3205">        return false;</a>
<a name="ln3206"> </a>
<a name="ln3207">    default:</a>
<a name="ln3208">        return false;</a>
<a name="ln3209">    }</a>
<a name="ln3210">    return false;</a>
<a name="ln3211">}</a>
<a name="ln3212"> </a>
<a name="ln3213">string item_prefix(const item_def &amp;item, bool temp)</a>
<a name="ln3214">{</a>
<a name="ln3215">    vector&lt;const char *&gt; prefixes;</a>
<a name="ln3216"> </a>
<a name="ln3217">    if (!item.defined())</a>
<a name="ln3218">        return &quot;&quot;;</a>
<a name="ln3219"> </a>
<a name="ln3220">    if (fully_identified(item))</a>
<a name="ln3221">        prefixes.push_back(&quot;identified&quot;);</a>
<a name="ln3222">    else if (item_ident(item, ISFLAG_KNOW_TYPE)</a>
<a name="ln3223">             || get_ident_type(item))</a>
<a name="ln3224">    {</a>
<a name="ln3225">        prefixes.push_back(&quot;known&quot;);</a>
<a name="ln3226">    }</a>
<a name="ln3227">    else</a>
<a name="ln3228">        prefixes.push_back(&quot;unidentified&quot;);</a>
<a name="ln3229"> </a>
<a name="ln3230">    // Sometimes this is abbreviated out of the item name.</a>
<a name="ln3231">    if (item_type_has_curses(item.base_type)</a>
<a name="ln3232">        &amp;&amp; item_ident(item, ISFLAG_KNOW_CURSE) &amp;&amp; !item.cursed())</a>
<a name="ln3233">    {</a>
<a name="ln3234">        prefixes.push_back(&quot;uncursed&quot;);</a>
<a name="ln3235">    }</a>
<a name="ln3236"> </a>
<a name="ln3237">    if (god_hates_item(item))</a>
<a name="ln3238">    {</a>
<a name="ln3239">        prefixes.push_back(&quot;evil_item&quot;);</a>
<a name="ln3240">        prefixes.push_back(&quot;forbidden&quot;);</a>
<a name="ln3241">    }</a>
<a name="ln3242"> </a>
<a name="ln3243">    if (is_emergency_item(item))</a>
<a name="ln3244">        prefixes.push_back(&quot;emergency_item&quot;);</a>
<a name="ln3245">    if (is_good_item(item))</a>
<a name="ln3246">        prefixes.push_back(&quot;good_item&quot;);</a>
<a name="ln3247">    if (is_dangerous_item(item, temp))</a>
<a name="ln3248">        prefixes.push_back(&quot;dangerous_item&quot;);</a>
<a name="ln3249">    if (is_bad_item(item))</a>
<a name="ln3250">        prefixes.push_back(&quot;bad_item&quot;);</a>
<a name="ln3251">    if (is_useless_item(item, temp))</a>
<a name="ln3252">        prefixes.push_back(&quot;useless_item&quot;);</a>
<a name="ln3253"> </a>
<a name="ln3254">    if (item_is_stationary(item))</a>
<a name="ln3255">        prefixes.push_back(&quot;stationary&quot;);</a>
<a name="ln3256"> </a>
<a name="ln3257">    switch (item.base_type)</a>
<a name="ln3258">    {</a>
<a name="ln3259">    case OBJ_CORPSES:</a>
<a name="ln3260">        // Skeletons cannot be eaten.</a>
<a name="ln3261">        if (item.sub_type == CORPSE_SKELETON)</a>
<a name="ln3262">        {</a>
<a name="ln3263">            prefixes.push_back(&quot;inedible&quot;);</a>
<a name="ln3264">            break;</a>
<a name="ln3265">        }</a>
<a name="ln3266">        // intentional fall-through</a>
<a name="ln3267">    case OBJ_FOOD:</a>
<a name="ln3268">        // this seems like a big horrible gotcha waiting to happen</a>
<a name="ln3269">        if (item.sub_type == NUM_FOODS)</a>
<a name="ln3270">            break;</a>
<a name="ln3271"> </a>
<a name="ln3272">        if (is_inedible(item))</a>
<a name="ln3273">            prefixes.push_back(&quot;inedible&quot;);</a>
<a name="ln3274">        else if (is_preferred_food(item))</a>
<a name="ln3275">            prefixes.push_back(&quot;preferred&quot;);</a>
<a name="ln3276"> </a>
<a name="ln3277">        if (is_forbidden_food(item))</a>
<a name="ln3278">            prefixes.push_back(&quot;forbidden&quot;);</a>
<a name="ln3279"> </a>
<a name="ln3280">        else if (is_noxious(item))</a>
<a name="ln3281">            prefixes.push_back(&quot;inedible&quot;);</a>
<a name="ln3282">        break;</a>
<a name="ln3283"> </a>
<a name="ln3284">    case OBJ_STAVES:</a>
<a name="ln3285">    case OBJ_WEAPONS:</a>
<a name="ln3286">        if (is_range_weapon(item))</a>
<a name="ln3287">            prefixes.push_back(&quot;ranged&quot;);</a>
<a name="ln3288">        else if (is_melee_weapon(item)) // currently redundant</a>
<a name="ln3289">            prefixes.push_back(&quot;melee&quot;);</a>
<a name="ln3290">        // fall through</a>
<a name="ln3291"> </a>
<a name="ln3292">    case OBJ_ARMOUR:</a>
<a name="ln3293">    case OBJ_JEWELLERY:</a>
<a name="ln3294">        if (is_artefact(item))</a>
<a name="ln3295">            prefixes.push_back(&quot;artefact&quot;);</a>
<a name="ln3296">        // fall through</a>
<a name="ln3297"> </a>
<a name="ln3298">    case OBJ_MISSILES:</a>
<a name="ln3299">        if (item_is_equipped(item, true))</a>
<a name="ln3300">            prefixes.push_back(&quot;equipped&quot;);</a>
<a name="ln3301">        break;</a>
<a name="ln3302"> </a>
<a name="ln3303">    case OBJ_BOOKS:</a>
<a name="ln3304">        if (item.sub_type != BOOK_MANUAL &amp;&amp; item.sub_type != NUM_BOOKS)</a>
<a name="ln3305">            prefixes.push_back(&quot;spellbook&quot;);</a>
<a name="ln3306">        break;</a>
<a name="ln3307"> </a>
<a name="ln3308">    default:</a>
<a name="ln3309">        break;</a>
<a name="ln3310">    }</a>
<a name="ln3311"> </a>
<a name="ln3312">    prefixes.push_back(item_class_name(item.base_type, true));</a>
<a name="ln3313"> </a>
<a name="ln3314">    string result = comma_separated_line(prefixes.begin(), prefixes.end(),</a>
<a name="ln3315">                                         &quot; &quot;, &quot; &quot;);</a>
<a name="ln3316"> </a>
<a name="ln3317">    return result;</a>
<a name="ln3318">}</a>
<a name="ln3319"> </a>
<a name="ln3320">/**</a>
<a name="ln3321"> * Return an item's name surrounded by colour tags, using menu colouring</a>
<a name="ln3322"> *</a>
<a name="ln3323"> * @param item The item being queried</a>
<a name="ln3324"> * @param desc The description level to use for the name string</a>
<a name="ln3325"> * @return A string containing the item's name surrounded by colour tags</a>
<a name="ln3326"> */</a>
<a name="ln3327">string menu_colour_item_name(const item_def &amp;item, description_level_type desc)</a>
<a name="ln3328">{</a>
<a name="ln3329">    const string cprf      = item_prefix(item);</a>
<a name="ln3330">    const string item_name = item.name(desc);</a>
<a name="ln3331"> </a>
<a name="ln3332">    const int col = menu_colour(item_name, cprf, &quot;pickup&quot;);</a>
<a name="ln3333">    if (col == -1)</a>
<a name="ln3334">        return item_name;</a>
<a name="ln3335"> </a>
<a name="ln3336">    const string colour = colour_to_str(col);</a>
<a name="ln3337">    const char * const colour_z = colour.c_str();</a>
<a name="ln3338">    return make_stringf(&quot;&lt;%s&gt;%s&lt;/%s&gt;&quot;, colour_z, item_name.c_str(), colour_z);</a>
<a name="ln3339">}</a>
<a name="ln3340"> </a>
<a name="ln3341">typedef map&lt;string, item_kind&gt; item_names_map;</a>
<a name="ln3342">static item_names_map item_names_cache;</a>
<a name="ln3343"> </a>
<a name="ln3344">typedef map&lt;unsigned, vector&lt;string&gt; &gt; item_names_by_glyph_map;</a>
<a name="ln3345">static item_names_by_glyph_map item_names_by_glyph_cache;</a>
<a name="ln3346"> </a>
<a name="ln3347">void init_item_name_cache()</a>
<a name="ln3348">{</a>
<a name="ln3349">    item_names_cache.clear();</a>
<a name="ln3350">    item_names_by_glyph_cache.clear();</a>
<a name="ln3351"> </a>
<a name="ln3352">    for (int i = 0; i &lt; NUM_OBJECT_CLASSES; i++)</a>
<a name="ln3353">    {</a>
<a name="ln3354">        const object_class_type base_type = static_cast&lt;object_class_type&gt;(i);</a>
<a name="ln3355"> </a>
<a name="ln3356">        for (const auto sub_type : all_item_subtypes(base_type))</a>
<a name="ln3357">        {</a>
<a name="ln3358">            if (base_type == OBJ_BOOKS)</a>
<a name="ln3359">            {</a>
<a name="ln3360">                if (sub_type == BOOK_RANDART_LEVEL</a>
<a name="ln3361">                    || sub_type == BOOK_RANDART_THEME)</a>
<a name="ln3362">                {</a>
<a name="ln3363">                    // These are randart only and have no fixed names.</a>
<a name="ln3364">                    continue;</a>
<a name="ln3365">                }</a>
<a name="ln3366">            }</a>
<a name="ln3367"> </a>
<a name="ln3368">            int npluses = 0;</a>
<a name="ln3369">            if (base_type == OBJ_BOOKS &amp;&amp; sub_type == BOOK_MANUAL)</a>
<a name="ln3370">                npluses = NUM_SKILLS;</a>
<a name="ln3371"> </a>
<a name="ln3372">            item_def item;</a>
<a name="ln3373">            item.base_type = base_type;</a>
<a name="ln3374">            item.sub_type = sub_type;</a>
<a name="ln3375">            for (int plus = 0; plus &lt;= npluses; plus++)</a>
<a name="ln3376">            {</a>
<a name="ln3377">                if (plus &gt; 0)</a>
<a name="ln3378">                    item.plus = max(0, plus - 1);</a>
<a name="ln3379">                string name = item.name(plus || item.base_type == OBJ_RUNES ? DESC_PLAIN : DESC_DBNAME,</a>
<a name="ln3380">                                        true, true);</a>
<a name="ln3381">                lowercase(name);</a>
<a name="ln3382">                cglyph_t g = get_item_glyph(item);</a>
<a name="ln3383"> </a>
<a name="ln3384">                if (base_type == OBJ_JEWELLERY &amp;&amp; sub_type &gt;= NUM_RINGS</a>
<a name="ln3385">                    &amp;&amp; sub_type &lt; AMU_FIRST_AMULET)</a>
<a name="ln3386">                {</a>
<a name="ln3387">                    continue;</a>
<a name="ln3388">                }</a>
<a name="ln3389">                else if (name.find(&quot;buggy&quot;) != string::npos)</a>
<a name="ln3390">                {</a>
<a name="ln3391">                    mprf(MSGCH_ERROR, &quot;Bad name for item name cache: %s&quot;,</a>
<a name="ln3392">                                                                name.c_str());</a>
<a name="ln3393">                    continue;</a>
<a name="ln3394">                }</a>
<a name="ln3395"> </a>
<a name="ln3396">                if (!item_names_cache.count(name))</a>
<a name="ln3397">                {</a>
<a name="ln3398">                    item_names_cache[name] = { base_type, (uint8_t)sub_type,</a>
<a name="ln3399">                                               (int8_t)item.plus, 0 };</a>
<a name="ln3400">                    if (g.ch)</a>
<a name="ln3401">                        item_names_by_glyph_cache[g.ch].push_back(name);</a>
<a name="ln3402">                }</a>
<a name="ln3403">            }</a>
<a name="ln3404">        }</a>
<a name="ln3405">    }</a>
<a name="ln3406"> </a>
<a name="ln3407">    ASSERT(!item_names_cache.empty());</a>
<a name="ln3408">}</a>
<a name="ln3409"> </a>
<a name="ln3410">item_kind item_kind_by_name(const string &amp;name)</a>
<a name="ln3411">{</a>
<a name="ln3412">    return lookup(item_names_cache, lowercase_string(name),</a>
<a name="ln3413">                  { OBJ_UNASSIGNED, 0, 0, 0 });</a>
<a name="ln3414">}</a>
<a name="ln3415"> </a>
<a name="ln3416">vector&lt;string&gt; item_name_list_for_glyph(char32_t glyph)</a>
<a name="ln3417">{</a>
<a name="ln3418">    return lookup(item_names_by_glyph_cache, glyph, {});</a>
<a name="ln3419">}</a>
<a name="ln3420"> </a>
<a name="ln3421">bool is_named_corpse(const item_def &amp;corpse)</a>
<a name="ln3422">{</a>
<a name="ln3423">    ASSERT(corpse.base_type == OBJ_CORPSES);</a>
<a name="ln3424"> </a>
<a name="ln3425">    return corpse.props.exists(CORPSE_NAME_KEY);</a>
<a name="ln3426">}</a>
<a name="ln3427"> </a>
<a name="ln3428">string get_corpse_name(const item_def &amp;corpse, monster_flags_t *name_type)</a>
<a name="ln3429">{</a>
<a name="ln3430">    ASSERT(corpse.base_type == OBJ_CORPSES);</a>
<a name="ln3431"> </a>
<a name="ln3432">    if (!corpse.props.exists(CORPSE_NAME_KEY))</a>
<a name="ln3433">        return &quot;&quot;;</a>
<a name="ln3434"> </a>
<a name="ln3435">    if (name_type != nullptr)</a>
<a name="ln3436">        name_type-&gt;flags = corpse.props[CORPSE_NAME_TYPE_KEY].get_int64();</a>
<a name="ln3437"> </a>
<a name="ln3438">    return corpse.props[CORPSE_NAME_KEY].get_string();</a>
<a name="ln3439">}</a>

</code></pre>
<div class="balloon" rel="104"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v648/" target="_blank">V648</a> Priority of the '&&' operation is higher than that of the '||' operation.</p></div>
<div class="balloon" rel="522"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v768/" target="_blank">V768</a> The variable 'override_brand' is of enum type. It is odd that it is used as a variable of a Boolean-type.</p></div>
<div class="balloon" rel="835"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v648/" target="_blank">V648</a> Priority of the '&&' operation is higher than that of the '||' operation.</p></div>
<div class="balloon" rel="1254"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v648/" target="_blank">V648</a> Priority of the '&&' operation is higher than that of the '||' operation.</p></div>
<div class="balloon" rel="1388"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v768/" target="_blank">V768</a> The variable 'override_brand' is of enum type. It is odd that it is used as a variable of a Boolean-type.</p></div>
<div class="balloon" rel="1450"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v560/" target="_blank">V560</a> A part of conditional expression is always true: desc != DESC_DBNAME.</p></div>
<div class="balloon" rel="1608"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v648/" target="_blank">V648</a> Priority of the '&&' operation is higher than that of the '||' operation.</p></div>
<div class="balloon" rel="1715"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v560/" target="_blank">V560</a> A part of conditional expression is always false: pqual < 0.</p></div>
<div class="balloon" rel="1718"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v560/" target="_blank">V560</a> A part of conditional expression is always false: pcolour < 0.</p></div>
<div class="balloon" rel="1718"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v560/" target="_blank">V560</a> A part of conditional expression is always false: pcolour >= PDC_NCOLOURS.</p></div>
<div class="balloon" rel="1957"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v560/" target="_blank">V560</a> A part of conditional expression is always true: !basename.</p></div>
<div class="balloon" rel="1999"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v648/" target="_blank">V648</a> Priority of the '&&' operation is higher than that of the '||' operation.</p></div>
<div class="balloon" rel="2336"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v560/" target="_blank">V560</a> A part of conditional expression is always false: prev_char == ' '.</p></div>
<div class="balloon" rel="2338"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v728/" target="_blank">V728</a> An excessive check can be simplified. The '||' operator is surrounded by opposite expressions 'name.length() <= 2' and 'name.length() > 2'. </p></div>
<div class="balloon" rel="2366"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v560/" target="_blank">V560</a> A part of conditional expression is always false: name.empty().</p></div>
<div class="balloon" rel="2366"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v560/" target="_blank">V560</a> A part of conditional expression is always false: prev_char == ' '.</p></div>
<div class="balloon" rel="2370"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v560/" target="_blank">V560</a> A part of conditional expression is always true: !name.empty().</p></div>
<div class="balloon" rel="2372"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v560/" target="_blank">V560</a> A part of conditional expression is always true: !beg.</p></div>
<div class="balloon" rel="2785"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v648/" target="_blank">V648</a> Priority of the '&&' operation is higher than that of the '||' operation.</p></div>
<div class="balloon" rel="2874"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v648/" target="_blank">V648</a> Priority of the '&&' operation is higher than that of the '||' operation.</p></div>
<div class="balloon" rel="2877"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v648/" target="_blank">V648</a> Priority of the '&&' operation is higher than that of the '||' operation.</p></div>
<div class="balloon" rel="3011"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v648/" target="_blank">V648</a> Priority of the '&&' operation is higher than that of the '||' operation.</p></div>
<div class="balloon" rel="3009"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v768/" target="_blank">V768</a> The expression 'you.undead_state(temp)' is of enum type. It is odd that it is used as an expression of a Boolean-type.</p></div>
<div class="balloon" rel="3041"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v648/" target="_blank">V648</a> Priority of the '&&' operation is higher than that of the '||' operation.</p></div>
<div class="balloon" rel="3039"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v768/" target="_blank">V768</a> The expression 'you.undead_state(temp)' is of enum type. It is odd that it is used as an expression of a Boolean-type.</p></div>
<div class="balloon" rel="3052"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v768/" target="_blank">V768</a> The expression 'you.undead_state(temp)' is of enum type. It is odd that it is used as an expression of a Boolean-type.</p></div>

<link rel="stylesheet" href="highlight.css">
<script src="highlight.pack.js"></script>
<script src="highlightjs-line-numbers.js"></script>
<script>hljs.initHighlightingOnLoad();</script>
<script>hljs.initLineNumbersOnLoad();</script>
<script>
  $(document).ready(function() {
      $('.balloon').each(function () {
          var bl = $(this);
          var line = bl.attr('rel');
          var text = $('a[name="ln'+line+'"]').text();

          var space_count = 0;
          for(var i = 0; i<text.length; i++){
              var char = text[i];
              if((char !== ' ')&&(char !== '\t'))break;
              if(char === '\t')space_count++;
              space_count++;
          }

          bl.css('margin-left', space_count*8);
          $('a[name="ln'+line+'"]').after(bl);
      });

      window.location = window.location;
  });
</script>
</body>
</html>
