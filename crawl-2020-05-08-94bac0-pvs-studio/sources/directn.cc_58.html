
<html>
<head>

  <meta http-equiv="Content-Type" content="text/html; charset=US-ASCII" />
  <title>directn.cc</title>

  <link rel="stylesheet" href="../style.css"/>
  <script src="../jquery-3.2.1.min.js"></script>
</head>
<body>

<pre><code class = "cpp">
<a name="ln1">/**</a>
<a name="ln2"> * @file</a>
<a name="ln3"> * @brief Functions used when picking squares.</a>
<a name="ln4">**/</a>
<a name="ln5"> </a>
<a name="ln6">#include &quot;AppHdr.h&quot;</a>
<a name="ln7"> </a>
<a name="ln8">#include &quot;directn.h&quot;</a>
<a name="ln9"> </a>
<a name="ln10">#include &lt;algorithm&gt;</a>
<a name="ln11">#include &lt;cstdarg&gt;</a>
<a name="ln12">#include &lt;cstdio&gt;</a>
<a name="ln13">#include &lt;cstdlib&gt;</a>
<a name="ln14">#include &lt;cstring&gt;</a>
<a name="ln15">#include &lt;functional&gt;</a>
<a name="ln16">#include &lt;sstream&gt;</a>
<a name="ln17"> </a>
<a name="ln18">#include &quot;act-iter.h&quot;</a>
<a name="ln19">#include &quot;areas.h&quot;</a>
<a name="ln20">#include &quot;artefact.h&quot;</a>
<a name="ln21">#include &quot;attitude-change.h&quot;</a>
<a name="ln22">#include &quot;cloud.h&quot;</a>
<a name="ln23">#include &quot;colour.h&quot;</a>
<a name="ln24">#include &quot;command.h&quot;</a>
<a name="ln25">#include &quot;coordit.h&quot;</a>
<a name="ln26">#include &quot;describe.h&quot;</a>
<a name="ln27">#include &quot;dungeon.h&quot;</a>
<a name="ln28">#include &quot;english.h&quot;</a>
<a name="ln29">#include &quot;externs.h&quot; // INVALID_COORD</a>
<a name="ln30">#include &quot;fight.h&quot; // melee_confuse_chance</a>
<a name="ln31">#include &quot;god-abil.h&quot;</a>
<a name="ln32">#include &quot;hints.h&quot;</a>
<a name="ln33">#include &quot;invent.h&quot;</a>
<a name="ln34">#include &quot;item-prop.h&quot;</a>
<a name="ln35">#include &quot;item-status-flag-type.h&quot;</a>
<a name="ln36">#include &quot;items.h&quot;</a>
<a name="ln37">#include &quot;libutil.h&quot;</a>
<a name="ln38">#include &quot;losglobal.h&quot;</a>
<a name="ln39">#include &quot;macro.h&quot;</a>
<a name="ln40">#include &quot;mapmark.h&quot;</a>
<a name="ln41">#include &quot;message.h&quot;</a>
<a name="ln42">#include &quot;mon-death.h&quot;</a>
<a name="ln43">#include &quot;mon-tentacle.h&quot;</a>
<a name="ln44">#include &quot;nearby-danger.h&quot;</a>
<a name="ln45">#include &quot;output.h&quot;</a>
<a name="ln46">#include &quot;prompt.h&quot;</a>
<a name="ln47">#include &quot;showsymb.h&quot;</a>
<a name="ln48">#include &quot;spl-goditem.h&quot;</a>
<a name="ln49">#include &quot;stash.h&quot;</a>
<a name="ln50">#include &quot;state.h&quot;</a>
<a name="ln51">#include &quot;stringutil.h&quot;</a>
<a name="ln52">#include &quot;target.h&quot;</a>
<a name="ln53">#include &quot;terrain.h&quot;</a>
<a name="ln54">#ifdef USE_TILE</a>
<a name="ln55"> #include &quot;tileview.h&quot;</a>
<a name="ln56">#endif</a>
<a name="ln57">#include &quot;traps.h&quot;</a>
<a name="ln58">#include &quot;travel.h&quot;</a>
<a name="ln59">#include &quot;viewchar.h&quot;</a>
<a name="ln60">#include &quot;view.h&quot;</a>
<a name="ln61">#include &quot;viewmap.h&quot;</a>
<a name="ln62">#include &quot;wiz-dgn.h&quot;</a>
<a name="ln63">#include &quot;wiz-mon.h&quot;</a>
<a name="ln64"> </a>
<a name="ln65">enum LOSSelect</a>
<a name="ln66">{</a>
<a name="ln67">    LS_ANY      = 0x00,</a>
<a name="ln68"> </a>
<a name="ln69">    // Check only visible squares</a>
<a name="ln70">    LS_VISIBLE  = 0x01,</a>
<a name="ln71"> </a>
<a name="ln72">    // Check only hidden squares</a>
<a name="ln73">    LS_HIDDEN   = 0x02,</a>
<a name="ln74"> </a>
<a name="ln75">    LS_VISMASK  = 0x03,</a>
<a name="ln76"> </a>
<a name="ln77">    // Flip from visible to hidden when going forward,</a>
<a name="ln78">    // or hidden to visible when going backwards.</a>
<a name="ln79">    LS_FLIPVH   = 0x20,</a>
<a name="ln80"> </a>
<a name="ln81">    // Flip from hidden to visible when going forward,</a>
<a name="ln82">    // or visible to hidden when going backwards.</a>
<a name="ln83">    LS_FLIPHV   = 0x40,</a>
<a name="ln84"> </a>
<a name="ln85">    LS_NONE     = 0xFFFF,</a>
<a name="ln86">};</a>
<a name="ln87"> </a>
<a name="ln88">#ifdef WIZARD</a>
<a name="ln89">static void _wizard_make_friendly(monster* m);</a>
<a name="ln90">#endif</a>
<a name="ln91">static dist _look_around_target(const coord_def &amp;whence);</a>
<a name="ln92">static void _describe_oos_feature(const coord_def&amp; where);</a>
<a name="ln93">static void _describe_cell(const coord_def&amp; where, bool in_range = true);</a>
<a name="ln94">static bool _print_cloud_desc(const coord_def where);</a>
<a name="ln95">static bool _print_item_desc(const coord_def where);</a>
<a name="ln96"> </a>
<a name="ln97">static bool _want_target_monster(const monster *mon, targ_mode_type mode,</a>
<a name="ln98">                                 targeter* hitfunc);</a>
<a name="ln99">static bool _find_monster(const coord_def&amp; where, targ_mode_type mode,</a>
<a name="ln100">                          bool need_path, int range, targeter *hitfunc);</a>
<a name="ln101">static bool _find_monster_expl(const coord_def&amp; where, targ_mode_type mode,</a>
<a name="ln102">                               bool need_path, int range, targeter *hitfunc,</a>
<a name="ln103">                               aff_type mon_aff, aff_type allowed_self_aff);</a>
<a name="ln104">static bool _find_shadow_step_mons(const coord_def&amp; where, targ_mode_type mode,</a>
<a name="ln105">                                   bool need_path, int range,</a>
<a name="ln106">                                   targeter *hitfunc);</a>
<a name="ln107">static bool _find_object(const coord_def&amp; where, bool need_path, int range,</a>
<a name="ln108">                         targeter *hitfunc);</a>
<a name="ln109">static bool _find_autopickup_object(const coord_def&amp; where, bool need_path,</a>
<a name="ln110">                                    int range, targeter *hitfunc);</a>
<a name="ln111"> </a>
<a name="ln112">typedef function&lt;bool (const coord_def&amp; where)&gt; target_checker;</a>
<a name="ln113">static bool _find_square_wrapper(coord_def &amp;mfp, int direction,</a>
<a name="ln114">                                 target_checker find_targ, targeter *hitfunc,</a>
<a name="ln115">                                 LOSSelect los = LS_ANY);</a>
<a name="ln116"> </a>
<a name="ln117">static int  _targeting_cmd_to_compass(command_type command);</a>
<a name="ln118">static void _describe_oos_square(const coord_def&amp; where);</a>
<a name="ln119">static void _extend_move_to_edge(dist &amp;moves);</a>
<a name="ln120">static vector&lt;string&gt; _get_monster_desc_vector(const monster_info&amp; mi);</a>
<a name="ln121">static string _get_monster_desc(const monster_info&amp; mi);</a>
<a name="ln122"> </a>
<a name="ln123">#ifdef DEBUG_DIAGNOSTICS</a>
<a name="ln124">static void _debug_describe_feature_at(const coord_def &amp;where);</a>
<a name="ln125">#endif</a>
<a name="ln126"> </a>
<a name="ln127">#ifdef WIZARD</a>
<a name="ln128">static void _wizard_make_friendly(monster* m)</a>
<a name="ln129">{</a>
<a name="ln130">    if (m == nullptr)</a>
<a name="ln131">        return;</a>
<a name="ln132"> </a>
<a name="ln133">    mon_attitude_type att = m-&gt;attitude;</a>
<a name="ln134"> </a>
<a name="ln135">    // During arena mode, skip directly from friendly to hostile.</a>
<a name="ln136">    if (crawl_state.arena_suspended &amp;&amp; att == ATT_FRIENDLY)</a>
<a name="ln137">        att = ATT_NEUTRAL;</a>
<a name="ln138"> </a>
<a name="ln139">    switch (att)</a>
<a name="ln140">    {</a>
<a name="ln141">    case ATT_FRIENDLY:</a>
<a name="ln142">        m-&gt;attitude = ATT_GOOD_NEUTRAL;</a>
<a name="ln143">        m-&gt;flags &amp;= ~MF_NO_REWARD;</a>
<a name="ln144">        m-&gt;flags |= MF_WAS_NEUTRAL;</a>
<a name="ln145">        break;</a>
<a name="ln146">    case ATT_GOOD_NEUTRAL:</a>
<a name="ln147">        m-&gt;attitude = ATT_STRICT_NEUTRAL;</a>
<a name="ln148">        break;</a>
<a name="ln149">    case ATT_STRICT_NEUTRAL:</a>
<a name="ln150">        m-&gt;attitude = ATT_NEUTRAL;</a>
<a name="ln151">        break;</a>
<a name="ln152">    case ATT_NEUTRAL:</a>
<a name="ln153">        m-&gt;attitude = ATT_HOSTILE;</a>
<a name="ln154">        m-&gt;flags &amp;= ~MF_WAS_NEUTRAL;</a>
<a name="ln155">        break;</a>
<a name="ln156">    case ATT_HOSTILE:</a>
<a name="ln157">        m-&gt;attitude = ATT_FRIENDLY;</a>
<a name="ln158">        m-&gt;flags |= MF_NO_REWARD;</a>
<a name="ln159">        break;</a>
<a name="ln160">    }</a>
<a name="ln161">    mons_att_changed(m);</a>
<a name="ln162"> </a>
<a name="ln163">    // To update visual branding of friendlies. Only seems capabable</a>
<a name="ln164">    // of adding bolding, not removing it, though.</a>
<a name="ln165">    viewwindow();</a>
<a name="ln166">}</a>
<a name="ln167">#endif</a>
<a name="ln168"> </a>
<a name="ln169">dist::dist()</a>
<a name="ln170">    : isValid(false), isTarget(false), isEndpoint(false), isCancel(true),</a>
<a name="ln171">      choseRay(false), target(), delta(), ray()</a>
<a name="ln172">{</a>
<a name="ln173">}</a>
<a name="ln174"> </a>
<a name="ln175">bool dist::isMe() const</a>
<a name="ln176">{</a>
<a name="ln177">    // We hack the decision as to whether to use delta or target by</a>
<a name="ln178">    // assuming that we use delta only if target hasn't been touched.</a>
<a name="ln179">    return isValid &amp;&amp; !isCancel</a>
<a name="ln180">           &amp;&amp; (target == you.pos()</a>
<a name="ln181">               || (target.origin() &amp;&amp; delta.origin()));</a>
<a name="ln182">}</a>
<a name="ln183"> </a>
<a name="ln184">bool direction_chooser::choose_compass()</a>
<a name="ln185">{</a>
<a name="ln186">    // Reinitialize moves.</a>
<a name="ln187">    moves.isValid       = true;</a>
<a name="ln188">    moves.isTarget      = false;</a>
<a name="ln189">    moves.isCancel      = false;</a>
<a name="ln190">    moves.delta.reset();</a>
<a name="ln191"> </a>
<a name="ln192">    mouse_control mc(MOUSE_MODE_TARGET_DIR);</a>
<a name="ln193"> </a>
<a name="ln194">    behaviour-&gt;compass = true;</a>
<a name="ln195"> </a>
<a name="ln196">    do</a>
<a name="ln197">    {</a>
<a name="ln198">        const command_type key_command = behaviour-&gt;get_command();</a>
<a name="ln199"> </a>
<a name="ln200">        if (handle_signals())</a>
<a name="ln201">            return false;</a>
<a name="ln202"> </a>
<a name="ln203">#ifdef USE_TILE</a>
<a name="ln204">        if (key_command == CMD_TARGET_MOUSE_MOVE)</a>
<a name="ln205">            continue;</a>
<a name="ln206">        else if (key_command == CMD_TARGET_MOUSE_SELECT)</a>
<a name="ln207">        {</a>
<a name="ln208">            const coord_def &amp;gc = tiles.get_cursor();</a>
<a name="ln209">            if (gc == NO_CURSOR)</a>
<a name="ln210">                continue;</a>
<a name="ln211"> </a>
<a name="ln212">            if (!map_bounds(gc))</a>
<a name="ln213">                continue;</a>
<a name="ln214"> </a>
<a name="ln215">            coord_def delta = gc - you.pos();</a>
<a name="ln216">            if (delta.rdist() &gt; 1)</a>
<a name="ln217">            {</a>
<a name="ln218">                tiles.place_cursor(CURSOR_MOUSE, gc);</a>
<a name="ln219">                delta = tiles.get_cursor() - you.pos();</a>
<a name="ln220">                ASSERT(delta.rdist() &lt;= 1);</a>
<a name="ln221">            }</a>
<a name="ln222"> </a>
<a name="ln223">            moves.delta = delta;</a>
<a name="ln224">            break;</a>
<a name="ln225">        }</a>
<a name="ln226">#endif</a>
<a name="ln227"> </a>
<a name="ln228">        if (key_command == CMD_TARGET_SELECT)</a>
<a name="ln229">        {</a>
<a name="ln230">            moves.delta.reset();</a>
<a name="ln231">            break;</a>
<a name="ln232">        }</a>
<a name="ln233"> </a>
<a name="ln234">        const int i = _targeting_cmd_to_compass(key_command);</a>
<a name="ln235">        if (i != -1)</a>
<a name="ln236">            moves.delta = Compass[i];</a>
<a name="ln237">        else if (key_command == CMD_TARGET_CANCEL)</a>
<a name="ln238">        {</a>
<a name="ln239">            moves.isCancel = true;</a>
<a name="ln240">            moves.isValid = false;</a>
<a name="ln241">        }</a>
<a name="ln242">    }</a>
<a name="ln243">    while (!moves.isCancel &amp;&amp; moves.delta.origin());</a>
<a name="ln244"> </a>
<a name="ln245">#ifdef USE_TILE</a>
<a name="ln246">    tiles.place_cursor(CURSOR_MOUSE, NO_CURSOR);</a>
<a name="ln247">#endif</a>
<a name="ln248"> </a>
<a name="ln249">    return moves.isValid;</a>
<a name="ln250">}</a>
<a name="ln251"> </a>
<a name="ln252">static int _targeting_cmd_to_compass(command_type command)</a>
<a name="ln253">{</a>
<a name="ln254">    switch (command)</a>
<a name="ln255">    {</a>
<a name="ln256">    case CMD_TARGET_UP:         case CMD_TARGET_DIR_UP:</a>
<a name="ln257">        return 0;</a>
<a name="ln258">    case CMD_TARGET_UP_RIGHT:   case CMD_TARGET_DIR_UP_RIGHT:</a>
<a name="ln259">        return 1;</a>
<a name="ln260">    case CMD_TARGET_RIGHT:      case CMD_TARGET_DIR_RIGHT:</a>
<a name="ln261">        return 2;</a>
<a name="ln262">    case CMD_TARGET_DOWN_RIGHT: case CMD_TARGET_DIR_DOWN_RIGHT:</a>
<a name="ln263">        return 3;</a>
<a name="ln264">    case CMD_TARGET_DOWN:       case CMD_TARGET_DIR_DOWN:</a>
<a name="ln265">        return 4;</a>
<a name="ln266">    case CMD_TARGET_DOWN_LEFT:  case CMD_TARGET_DIR_DOWN_LEFT:</a>
<a name="ln267">        return 5;</a>
<a name="ln268">    case CMD_TARGET_LEFT:       case CMD_TARGET_DIR_LEFT:</a>
<a name="ln269">        return 6;</a>
<a name="ln270">    case CMD_TARGET_UP_LEFT:    case CMD_TARGET_DIR_UP_LEFT:</a>
<a name="ln271">        return 7;</a>
<a name="ln272">    default:</a>
<a name="ln273">        return -1;</a>
<a name="ln274">    }</a>
<a name="ln275">}</a>
<a name="ln276"> </a>
<a name="ln277">static command_type shift_direction(command_type cmd)</a>
<a name="ln278">{</a>
<a name="ln279">    switch (cmd)</a>
<a name="ln280">    {</a>
<a name="ln281">    case CMD_TARGET_DOWN_LEFT:  return CMD_TARGET_DIR_DOWN_LEFT;</a>
<a name="ln282">    case CMD_TARGET_LEFT:       return CMD_TARGET_DIR_LEFT;</a>
<a name="ln283">    case CMD_TARGET_DOWN:       return CMD_TARGET_DIR_DOWN;</a>
<a name="ln284">    case CMD_TARGET_UP:         return CMD_TARGET_DIR_UP;</a>
<a name="ln285">    case CMD_TARGET_RIGHT:      return CMD_TARGET_DIR_RIGHT;</a>
<a name="ln286">    case CMD_TARGET_DOWN_RIGHT: return CMD_TARGET_DIR_DOWN_RIGHT;</a>
<a name="ln287">    case CMD_TARGET_UP_RIGHT:   return CMD_TARGET_DIR_UP_RIGHT;</a>
<a name="ln288">    case CMD_TARGET_UP_LEFT:    return CMD_TARGET_DIR_UP_LEFT;</a>
<a name="ln289">    default: return cmd;</a>
<a name="ln290">    }</a>
<a name="ln291">}</a>
<a name="ln292"> </a>
<a name="ln293">actor* direction_chooser::targeted_actor() const</a>
<a name="ln294">{</a>
<a name="ln295">    if (target() == you.pos())</a>
<a name="ln296">        return &amp;you;</a>
<a name="ln297">    else</a>
<a name="ln298">        return targeted_monster();</a>
<a name="ln299">}</a>
<a name="ln300"> </a>
<a name="ln301">monster* direction_chooser::targeted_monster() const</a>
<a name="ln302">{</a>
<a name="ln303">    monster* m = monster_at(target());</a>
<a name="ln304">    if (m &amp;&amp; you.can_see(*m))</a>
<a name="ln305">        return m;</a>
<a name="ln306">    else</a>
<a name="ln307">        return nullptr;</a>
<a name="ln308">}</a>
<a name="ln309"> </a>
<a name="ln310">// Return your target, if it still exists and is visible to you.</a>
<a name="ln311">static monster* _get_current_target()</a>
<a name="ln312">{</a>
<a name="ln313">    if (invalid_monster_index(you.prev_targ))</a>
<a name="ln314">        return nullptr;</a>
<a name="ln315"> </a>
<a name="ln316">    monster* mon = &amp;menv[you.prev_targ];</a>
<a name="ln317">    ASSERT(mon);</a>
<a name="ln318">    if (mon-&gt;alive() &amp;&amp; you.can_see(*mon))</a>
<a name="ln319">        return mon;</a>
<a name="ln320">    else</a>
<a name="ln321">        return nullptr;</a>
<a name="ln322">}</a>
<a name="ln323"> </a>
<a name="ln324">string direction_chooser::build_targeting_hint_string() const</a>
<a name="ln325">{</a>
<a name="ln326">    string hint_string;</a>
<a name="ln327"> </a>
<a name="ln328">    // Hint for 'p' - previous target, and for 'f' - current cell, if</a>
<a name="ln329">    // applicable.</a>
<a name="ln330">    const actor*   f_target = targeted_actor();</a>
<a name="ln331">    const monster* p_target = _get_current_target();</a>
<a name="ln332"> </a>
<a name="ln333">    if (f_target &amp;&amp; f_target == p_target)</a>
<a name="ln334">        hint_string = &quot;, f/p - &quot; + f_target-&gt;name(DESC_PLAIN);</a>
<a name="ln335">    else</a>
<a name="ln336">    {</a>
<a name="ln337">        if (f_target)</a>
<a name="ln338">            hint_string += &quot;, f - &quot; + f_target-&gt;name(DESC_PLAIN);</a>
<a name="ln339">        if (p_target)</a>
<a name="ln340">            hint_string += &quot;, p - &quot; + p_target-&gt;name(DESC_PLAIN);</a>
<a name="ln341">    }</a>
<a name="ln342"> </a>
<a name="ln343">    return hint_string;</a>
<a name="ln344">}</a>
<a name="ln345"> </a>
<a name="ln346">void direction_chooser::print_top_prompt() const</a>
<a name="ln347">{</a>
<a name="ln348">    if (!top_prompt.empty())</a>
<a name="ln349">        mprf(MSGCH_PROMPT, &quot;%s&quot;, top_prompt.c_str());</a>
<a name="ln350">}</a>
<a name="ln351"> </a>
<a name="ln352">void direction_chooser::print_key_hints() const</a>
<a name="ln353">{</a>
<a name="ln354">    string prompt = &quot;Press: ? - help&quot;;</a>
<a name="ln355"> </a>
<a name="ln356">    if (just_looking)</a>
<a name="ln357">    {</a>
<a name="ln358">        if (you.see_cell(target()))</a>
<a name="ln359">            prompt += &quot;, v - describe&quot;;</a>
<a name="ln360">        prompt += &quot;, . - travel&quot;;</a>
<a name="ln361">        if (in_bounds(target()) &amp;&amp; env.map_knowledge(target()).item())</a>
<a name="ln362">            prompt += &quot;, g - get item&quot;;</a>
<a name="ln363">    }</a>
<a name="ln364">    else</a>
<a name="ln365">    {</a>
<a name="ln366">        const string hint_string = build_targeting_hint_string();</a>
<a name="ln367">        switch (restricts)</a>
<a name="ln368">        {</a>
<a name="ln369">        case DIR_NONE:</a>
<a name="ln370">            prompt += &quot;, Shift-Dir - straight line&quot;;</a>
<a name="ln371">            prompt += hint_string;</a>
<a name="ln372">            break;</a>
<a name="ln373">        case DIR_TARGET:</a>
<a name="ln374">        case DIR_SHADOW_STEP:</a>
<a name="ln375">        case DIR_LEAP:</a>
<a name="ln376">            prompt += &quot;, Dir - move target cursor&quot;;</a>
<a name="ln377">            prompt += hint_string;</a>
<a name="ln378">            break;</a>
<a name="ln379">        case DIR_DIR:</a>
<a name="ln380">            break;</a>
<a name="ln381">        }</a>
<a name="ln382">    }</a>
<a name="ln383"> </a>
<a name="ln384">    // Display the prompt.</a>
<a name="ln385">    mprf(MSGCH_PROMPT, &quot;%s&quot;, prompt.c_str());</a>
<a name="ln386">}</a>
<a name="ln387"> </a>
<a name="ln388">bool direction_chooser::targets_objects() const</a>
<a name="ln389">{</a>
<a name="ln390">    return mode == TARG_MOVABLE_OBJECT;</a>
<a name="ln391">}</a>
<a name="ln392"> </a>
<a name="ln393">/// Are we looking for enemies?</a>
<a name="ln394">bool direction_chooser::targets_enemies() const</a>
<a name="ln395">{</a>
<a name="ln396">    switch (mode)</a>
<a name="ln397">    {</a>
<a name="ln398">        case TARG_HOSTILE:</a>
<a name="ln399">        case TARG_HOSTILE_SUBMERGED:</a>
<a name="ln400">            return true;</a>
<a name="ln401">        default:</a>
<a name="ln402">            return false;</a>
<a name="ln403">    }</a>
<a name="ln404">}</a>
<a name="ln405"> </a>
<a name="ln406">void direction_chooser::describe_cell() const</a>
<a name="ln407">{</a>
<a name="ln408">    if (!you.see_cell(target()))</a>
<a name="ln409">    {</a>
<a name="ln410">        print_top_prompt();</a>
<a name="ln411">        print_key_hints();</a>
<a name="ln412">        // FIXME: make this better integrated.</a>
<a name="ln413">        _describe_oos_square(target());</a>
<a name="ln414">    }</a>
<a name="ln415">    else</a>
<a name="ln416">    {</a>
<a name="ln417">        print_top_prompt();</a>
<a name="ln418">        print_key_hints();</a>
<a name="ln419">        bool did_cloud = false;</a>
<a name="ln420">        print_target_description(did_cloud);</a>
<a name="ln421">        if (just_looking || (show_items_once &amp;&amp; !targets_objects()))</a>
<a name="ln422">            print_items_description();</a>
<a name="ln423">        if (just_looking || show_floor_desc)</a>
<a name="ln424">        {</a>
<a name="ln425">            print_floor_description(show_boring_feats);</a>
<a name="ln426">            if (!did_cloud)</a>
<a name="ln427">                _print_cloud_desc(target());</a>
<a name="ln428">        }</a>
<a name="ln429">    }</a>
<a name="ln430"> </a>
<a name="ln431">    flush_prev_message();</a>
<a name="ln432">}</a>
<a name="ln433"> </a>
<a name="ln434">#ifndef USE_TILE_LOCAL</a>
<a name="ln435">static void _draw_ray_glyph(const coord_def &amp;pos, int colour,</a>
<a name="ln436">                            int glych, int mcol)</a>
<a name="ln437">{</a>
<a name="ln438">    if (const monster* mons = monster_at(pos))</a>
<a name="ln439">    {</a>
<a name="ln440">        if (mons-&gt;alive() &amp;&amp; mons-&gt;visible_to(&amp;you))</a>
<a name="ln441">        {</a>
<a name="ln442">            glych  = get_cell_glyph(pos).ch;</a>
<a name="ln443">            colour = mcol;</a>
<a name="ln444">        }</a>
<a name="ln445">    }</a>
<a name="ln446">    if (pos == you.pos())</a>
<a name="ln447">    {</a>
<a name="ln448">        glych = mons_char(you.symbol);</a>
<a name="ln449">        colour = mcol;</a>
<a name="ln450">    }</a>
<a name="ln451">    const coord_def vp = grid2view(pos);</a>
<a name="ln452">    cgotoxy(vp.x, vp.y, GOTO_DNGN);</a>
<a name="ln453">    textcolour(real_colour(colour));</a>
<a name="ln454">    putwch(glych);</a>
<a name="ln455">}</a>
<a name="ln456">#endif</a>
<a name="ln457"> </a>
<a name="ln458">// Unseen monsters in shallow water show a &quot;strange disturbance&quot;.</a>
<a name="ln459">// (Unless flying!)</a>
<a name="ln460">// These should match tests in show.cc's _update_monster</a>
<a name="ln461">static bool _mon_exposed_in_water(const monster* mon)</a>
<a name="ln462">{</a>
<a name="ln463">    return grd(mon-&gt;pos()) == DNGN_SHALLOW_WATER &amp;&amp; !mon-&gt;airborne()</a>
<a name="ln464">           &amp;&amp; !mon-&gt;submerged() &amp;&amp; !cloud_at(mon-&gt;pos());</a>
<a name="ln465">}</a>
<a name="ln466"> </a>
<a name="ln467">static bool _mon_exposed_in_cloud(const monster* mon)</a>
<a name="ln468">{</a>
<a name="ln469">    return cloud_at(mon-&gt;pos())</a>
<a name="ln470">           &amp;&amp; is_opaque_cloud(cloud_at(mon-&gt;pos())-&gt;type)</a>
<a name="ln471">           &amp;&amp; !mon-&gt;submerged() &amp;&amp; !mon-&gt;is_insubstantial();</a>
<a name="ln472">}</a>
<a name="ln473"> </a>
<a name="ln474">static bool _mon_exposed(const monster* mon)</a>
<a name="ln475">{</a>
<a name="ln476">    if (!mon || !you.see_cell(mon-&gt;pos()) || mon-&gt;visible_to(&amp;you))</a>
<a name="ln477">        return false;</a>
<a name="ln478"> </a>
<a name="ln479">    return _mon_exposed_in_water(mon) || _mon_exposed_in_cloud(mon);</a>
<a name="ln480">}</a>
<a name="ln481"> </a>
<a name="ln482">static bool _is_target_in_range(const coord_def&amp; where, int range,</a>
<a name="ln483">                                targeter *hitfunc)</a>
<a name="ln484">{</a>
<a name="ln485">    if (hitfunc)</a>
<a name="ln486">        return hitfunc-&gt;valid_aim(where);</a>
<a name="ln487">    // range == -1 means that range doesn't matter.</a>
<a name="ln488">    return range == -1 || grid_distance(you.pos(), where) &lt;= range;</a>
<a name="ln489">}</a>
<a name="ln490"> </a>
<a name="ln491">targeting_behaviour direction_chooser::stock_behaviour;</a>
<a name="ln492"> </a>
<a name="ln493">void direction(dist &amp;moves, const direction_chooser_args&amp; args)</a>
<a name="ln494">{</a>
<a name="ln495">    direction_chooser(moves, args).choose_direction();</a>
<a name="ln496">}</a>
<a name="ln497"> </a>
<a name="ln498">direction_chooser::direction_chooser(dist&amp; moves_,</a>
<a name="ln499">                                     const direction_chooser_args&amp; args) :</a>
<a name="ln500">    moves(moves_),</a>
<a name="ln501">    restricts(args.restricts),</a>
<a name="ln502">    mode(args.mode),</a>
<a name="ln503">    range(args.range),</a>
<a name="ln504">    just_looking(args.just_looking),</a>
<a name="ln505">    self(args.self),</a>
<a name="ln506">    target_prefix(args.target_prefix),</a>
<a name="ln507">    top_prompt(args.top_prompt),</a>
<a name="ln508">    behaviour(args.behaviour),</a>
<a name="ln509">    show_floor_desc(args.show_floor_desc),</a>
<a name="ln510">    show_boring_feats(args.show_boring_feats),</a>
<a name="ln511">    hitfunc(args.hitfunc),</a>
<a name="ln512">    default_place(args.default_place),</a>
<a name="ln513">    unrestricted(args.unrestricted),</a>
<a name="ln514">    needs_path(args.needs_path)</a>
<a name="ln515">{</a>
<a name="ln516">    if (!behaviour)</a>
<a name="ln517">        behaviour = &amp;stock_behaviour;</a>
<a name="ln518"> </a>
<a name="ln519">    behaviour-&gt;just_looking = just_looking;</a>
<a name="ln520">    behaviour-&gt;get_desc_func = args.get_desc_func;</a>
<a name="ln521">    if (unrestricted)</a>
<a name="ln522">        needs_path = false;</a>
<a name="ln523">    else if (hitfunc)</a>
<a name="ln524">        needs_path = true;</a>
<a name="ln525"> </a>
<a name="ln526">    show_beam = !just_looking &amp;&amp; needs_path;</a>
<a name="ln527">    need_viewport_redraw = show_beam;</a>
<a name="ln528">    have_beam = false;</a>
<a name="ln529"> </a>
<a name="ln530">    need_text_redraw = true;</a>
<a name="ln531">    need_cursor_redraw = true;</a>
<a name="ln532">    need_all_redraw = false;</a>
<a name="ln533"> </a>
<a name="ln534">    show_items_once = false;</a>
<a name="ln535">}</a>
<a name="ln536"> </a>
<a name="ln537">class view_desc_proc</a>
<a name="ln538">{</a>
<a name="ln539">public:</a>
<a name="ln540">    view_desc_proc()</a>
<a name="ln541">    {</a>
<a name="ln542">        // This thing seems to be starting off 1 line above where it</a>
<a name="ln543">        // should be. -cao</a>
<a name="ln544">        nextline();</a>
<a name="ln545">    }</a>
<a name="ln546">    int width() { return crawl_view.msgsz.x; }</a>
<a name="ln547">    int height() { return crawl_view.msgsz.y; }</a>
<a name="ln548">    void print(const string &amp;str) { cprintf(&quot;%s&quot;, str.c_str()); }</a>
<a name="ln549">    void nextline() { cgotoxy(1, wherey() + 1); }</a>
<a name="ln550">};</a>
<a name="ln551"> </a>
<a name="ln552">// Lists monsters, items, and some interesting features in the player's view.</a>
<a name="ln553">// TODO: Allow sorting of items lists.</a>
<a name="ln554">void full_describe_view()</a>
<a name="ln555">{</a>
<a name="ln556">    vector&lt;monster_info&gt; list_mons;</a>
<a name="ln557">    vector&lt;item_def&gt; list_items;</a>
<a name="ln558">    vector&lt;coord_def&gt; list_features;</a>
<a name="ln559"> </a>
<a name="ln560">    // Grab all items known (or thought) to be in the stashes in view.</a>
<a name="ln561">    for (radius_iterator ri(you.pos(),</a>
<a name="ln562">                            you.xray_vision ? LOS_NONE : LOS_DEFAULT); ri; ++ri)</a>
<a name="ln563">    {</a>
<a name="ln564">        if (feat_stair_direction(grd(*ri)) != CMD_NO_CMD</a>
<a name="ln565">            || (feat_is_trap(grd(*ri))))</a>
<a name="ln566">        {</a>
<a name="ln567">            list_features.push_back(*ri);</a>
<a name="ln568">        }</a>
<a name="ln569"> </a>
<a name="ln570">        const int oid = you.visible_igrd(*ri);</a>
<a name="ln571">        if (oid == NON_ITEM)</a>
<a name="ln572">            continue;</a>
<a name="ln573"> </a>
<a name="ln574">        const vector&lt;item_def&gt; items = item_list_in_stash(*ri);</a>
<a name="ln575"> </a>
<a name="ln576">#ifdef DEBUG_DIAGNOSTICS</a>
<a name="ln577">        if (items.empty())</a>
<a name="ln578">        {</a>
<a name="ln579">            mprf(MSGCH_ERROR, &quot;No items found in stash, but top item is %s&quot;,</a>
<a name="ln580">                 mitm[oid].name(DESC_PLAIN).c_str());</a>
<a name="ln581">            more();</a>
<a name="ln582">        }</a>
<a name="ln583">#endif</a>
<a name="ln584">        list_items.insert(list_items.end(), items.begin(), items.end());</a>
<a name="ln585">    }</a>
<a name="ln586"> </a>
<a name="ln587">    // Get monsters via the monster_info, sorted by difficulty.</a>
<a name="ln588">    get_monster_info(list_mons);</a>
<a name="ln589"> </a>
<a name="ln590">    if (list_mons.empty() &amp;&amp; list_items.empty() &amp;&amp; list_features.empty())</a>
<a name="ln591">    {</a>
<a name="ln592">        mpr(&quot;No monsters, items or features are visible.&quot;);</a>
<a name="ln593">        return;</a>
<a name="ln594">    }</a>
<a name="ln595"> </a>
<a name="ln596">    InvMenu desc_menu(MF_SINGLESELECT | MF_ANYPRINTABLE</a>
<a name="ln597">                        | MF_ALLOW_FORMATTING | MF_SELECT_BY_PAGE);</a>
<a name="ln598"> </a>
<a name="ln599">    string title = &quot;&quot;;</a>
<a name="ln600">    if (!list_mons.empty())</a>
<a name="ln601">        title  = &quot;Monsters&quot;;</a>
<a name="ln602">    if (!list_items.empty())</a>
<a name="ln603">    {</a>
<a name="ln604">        if (!title.empty())</a>
<a name="ln605">            title += &quot;/&quot;;</a>
<a name="ln606">        title += &quot;Items&quot;;</a>
<a name="ln607">    }</a>
<a name="ln608">    if (!list_features.empty())</a>
<a name="ln609">    {</a>
<a name="ln610">        if (!title.empty())</a>
<a name="ln611">            title += &quot;/&quot;;</a>
<a name="ln612">        title += &quot;Features&quot;;</a>
<a name="ln613">    }</a>
<a name="ln614"> </a>
<a name="ln615">    title = &quot;Visible &quot; + title;</a>
<a name="ln616">    string title1 = title + &quot; (select to target/travel, '!' to examine):&quot;;</a>
<a name="ln617">    title += &quot; (select to examine, '!' to target/travel):&quot;;</a>
<a name="ln618"> </a>
<a name="ln619">    desc_menu.set_title(new MenuEntry(title, MEL_TITLE), false);</a>
<a name="ln620">    desc_menu.set_title(new MenuEntry(title1, MEL_TITLE));</a>
<a name="ln621"> </a>
<a name="ln622">    desc_menu.set_tag(&quot;pickup&quot;);</a>
<a name="ln623">    // necessary for sorting of the item submenu</a>
<a name="ln624">    desc_menu.set_type(menu_type::pickup);</a>
<a name="ln625">    desc_menu.action_cycle = Menu::CYCLE_TOGGLE;</a>
<a name="ln626">    desc_menu.menu_action  = InvMenu::ACT_EXECUTE;</a>
<a name="ln627"> </a>
<a name="ln628">    // Start with hotkey 'a' and count from there.</a>
<a name="ln629">    menu_letter hotkey;</a>
<a name="ln630">    // Build menu entries for monsters.</a>
<a name="ln631">    if (!list_mons.empty())</a>
<a name="ln632">    {</a>
<a name="ln633">        desc_menu.add_entry(new MenuEntry(&quot;Monsters&quot;, MEL_SUBTITLE));</a>
<a name="ln634">        for (const monster_info &amp;mi : list_mons)</a>
<a name="ln635">        {</a>
<a name="ln636">            // List monsters in the form</a>
<a name="ln637">            // (A) An angel (neutral), wielding a glowing long sword</a>
<a name="ln638"> </a>
<a name="ln639">            string prefix = &quot;&quot;;</a>
<a name="ln640">#ifndef USE_TILE_LOCAL</a>
<a name="ln641">            cglyph_t g = get_mons_glyph(mi);</a>
<a name="ln642">            const string col_string = colour_to_str(g.col);</a>
<a name="ln643">            prefix = &quot;(&lt;&quot; + col_string + &quot;&gt;&quot;</a>
<a name="ln644">                     + (g.ch == '&lt;' ? &quot;&lt;&lt;&quot; : stringize_glyph(g.ch))</a>
<a name="ln645">                     + &quot;&lt;/&quot; + col_string + &quot;&gt;) &quot;;</a>
<a name="ln646">#endif</a>
<a name="ln647"> </a>
<a name="ln648">            string str = get_monster_equipment_desc(mi, DESC_FULL, DESC_A, true);</a>
<a name="ln649">            if (mi.is(MB_MESMERIZING))</a>
<a name="ln650">                str += &quot;, keeping you mesmerised&quot;;</a>
<a name="ln651"> </a>
<a name="ln652">            if (mi.dam != MDAM_OKAY)</a>
<a name="ln653">                str += &quot;, &quot; + mi.damage_desc();</a>
<a name="ln654"> </a>
<a name="ln655">            string consinfo = mi.constriction_description();</a>
<a name="ln656">            if (!consinfo.empty())</a>
<a name="ln657">                str += &quot;, &quot; + consinfo;</a>
<a name="ln658"> </a>
<a name="ln659">#ifndef USE_TILE_LOCAL</a>
<a name="ln660">            // Wraparound if the description is longer than allowed.</a>
<a name="ln661">            linebreak_string(str, get_number_of_cols() - 9);</a>
<a name="ln662">#endif</a>
<a name="ln663">            vector&lt;formatted_string&gt; fss;</a>
<a name="ln664">            formatted_string::parse_string_to_multiple(str, fss);</a>
<a name="ln665">            MenuEntry *me = nullptr;</a>
<a name="ln666">            for (unsigned int j = 0; j &lt; fss.size(); ++j)</a>
<a name="ln667">            {</a>
<a name="ln668">                if (j == 0)</a>
<a name="ln669">                    me = new MonsterMenuEntry(prefix + fss[j].tostring(), &amp;mi, hotkey++);</a>
<a name="ln670">#ifndef USE_TILE_LOCAL</a>
<a name="ln671">                else</a>
<a name="ln672">                {</a>
<a name="ln673">                    str = &quot;         &quot; + fss[j].tostring();</a>
<a name="ln674">                    me = new MenuEntry(str, MEL_ITEM, 1);</a>
<a name="ln675">                }</a>
<a name="ln676">#endif</a>
<a name="ln677">                desc_menu.add_entry(me);</a>
<a name="ln678">            }</a>
<a name="ln679">        }</a>
<a name="ln680">    }</a>
<a name="ln681"> </a>
<a name="ln682">    // Build menu entries for items.</a>
<a name="ln683">    if (!list_items.empty())</a>
<a name="ln684">    {</a>
<a name="ln685">        vector&lt;InvEntry*&gt; all_items;</a>
<a name="ln686">        for (const item_def &amp;item : list_items)</a>
<a name="ln687">            all_items.push_back(new InvEntry(item));</a>
<a name="ln688"> </a>
<a name="ln689">        const menu_sort_condition *cond = desc_menu.find_menu_sort_condition();</a>
<a name="ln690">        desc_menu.sort_menu(all_items, cond);</a>
<a name="ln691"> </a>
<a name="ln692">        desc_menu.add_entry(new MenuEntry(&quot;Items&quot;, MEL_SUBTITLE));</a>
<a name="ln693">        for (InvEntry *me : all_items)</a>
<a name="ln694">        {</a>
<a name="ln695">#ifndef USE_TILE_LOCAL</a>
<a name="ln696">            // Show glyphs only for ASCII.</a>
<a name="ln697">            me-&gt;set_show_glyph(true);</a>
<a name="ln698">#endif</a>
<a name="ln699">            me-&gt;tag = &quot;pickup&quot;;</a>
<a name="ln700">            me-&gt;hotkeys[0] = hotkey;</a>
<a name="ln701">            me-&gt;quantity = 2; // Hack to make items selectable.</a>
<a name="ln702"> </a>
<a name="ln703">            desc_menu.add_entry(me);</a>
<a name="ln704">            ++hotkey;</a>
<a name="ln705">        }</a>
<a name="ln706">    }</a>
<a name="ln707"> </a>
<a name="ln708">    if (!list_features.empty())</a>
<a name="ln709">    {</a>
<a name="ln710">        desc_menu.add_entry(new MenuEntry(&quot;Features&quot;, MEL_SUBTITLE));</a>
<a name="ln711">        for (const coord_def c : list_features)</a>
<a name="ln712">        {</a>
<a name="ln713">            string desc = &quot;&quot;;</a>
<a name="ln714">#ifndef USE_TILE_LOCAL</a>
<a name="ln715">            cglyph_t g = get_cell_glyph(c, true);</a>
<a name="ln716">            const string colour_str = colour_to_str(g.col);</a>
<a name="ln717">            desc = &quot;(&lt;&quot; + colour_str + &quot;&gt;&quot;;</a>
<a name="ln718">            desc += stringize_glyph(g.ch);</a>
<a name="ln719">            if (g.ch == '&lt;')</a>
<a name="ln720">                desc += '&lt;';</a>
<a name="ln721"> </a>
<a name="ln722">            desc += &quot;&lt;/&quot; + colour_str +&quot;&gt;) &quot;;</a>
<a name="ln723">#endif</a>
<a name="ln724">            desc += feature_description_at(c, false, DESC_A);</a>
<a name="ln725">            if (is_unknown_stair(c) || is_unknown_transporter(c))</a>
<a name="ln726">                desc += &quot; (not visited)&quot;;</a>
<a name="ln727">            FeatureMenuEntry *me = new FeatureMenuEntry(desc, c, hotkey);</a>
<a name="ln728">            me-&gt;tag        = &quot;description&quot;;</a>
<a name="ln729">            // Hack to make features selectable.</a>
<a name="ln730">            me-&gt;quantity   = c.x*100 + c.y + 3;</a>
<a name="ln731">            desc_menu.add_entry(me);</a>
<a name="ln732">            ++hotkey;</a>
<a name="ln733">        }</a>
<a name="ln734">    }</a>
<a name="ln735"> </a>
<a name="ln736">    // Select an item to read its full description, or a monster to read its</a>
<a name="ln737">    // e'x'amine description. Toggle with '!' to travel to an item's position</a>
<a name="ln738">    // or read a monster's database entry.</a>
<a name="ln739">    // (Maybe that should be reversed in the case of monsters.)</a>
<a name="ln740">    // For ASCII, the 'x' information may include short database descriptions.</a>
<a name="ln741"> </a>
<a name="ln742">    coord_def target(-1, -1);</a>
<a name="ln743"> </a>
<a name="ln744">    desc_menu.on_single_selection = [&amp;desc_menu, &amp;target](const MenuEntry&amp; sel)</a>
<a name="ln745">    {</a>
<a name="ln746">        target = coord_def(-1, -1);</a>
<a name="ln747">        // HACK: quantity == 1: monsters, quantity == 2: items</a>
<a name="ln748">        const int quant = sel.quantity;</a>
<a name="ln749">        if (quant == 1)</a>
<a name="ln750">        {</a>
<a name="ln751">            // Get selected monster.</a>
<a name="ln752">            monster_info* m = static_cast&lt;monster_info* &gt;(sel.data);</a>
<a name="ln753"> </a>
<a name="ln754">#ifdef USE_TILE</a>
<a name="ln755">            // Highlight selected monster on the screen.</a>
<a name="ln756">            const coord_def gc(m-&gt;pos);</a>
<a name="ln757">            tiles.place_cursor(CURSOR_TUTORIAL, gc);</a>
<a name="ln758">            const string &amp;desc = get_terse_square_desc(gc);</a>
<a name="ln759">            tiles.clear_text_tags(TAG_TUTORIAL);</a>
<a name="ln760">            tiles.add_text_tag(TAG_TUTORIAL, desc, gc);</a>
<a name="ln761">#endif</a>
<a name="ln762"> </a>
<a name="ln763">            if (desc_menu.menu_action == InvMenu::ACT_EXAMINE)</a>
<a name="ln764">            {</a>
<a name="ln765">                // View database entry.</a>
<a name="ln766">                describe_monsters(*m);</a>
<a name="ln767">                redraw_screen();</a>
<a name="ln768">                clear_messages();</a>
<a name="ln769">            }</a>
<a name="ln770">            else // ACT_EXECUTE -&gt; view/travel</a>
<a name="ln771">                target = m-&gt;pos;</a>
<a name="ln772">        }</a>
<a name="ln773">        else if (quant == 2)</a>
<a name="ln774">        {</a>
<a name="ln775">            // Get selected item.</a>
<a name="ln776">            item_def* i = static_cast&lt;item_def*&gt;(sel.data);</a>
<a name="ln777">            if (desc_menu.menu_action == InvMenu::ACT_EXAMINE)</a>
<a name="ln778">                describe_item(*i);</a>
<a name="ln779">            else // ACT_EXECUTE -&gt; view/travel</a>
<a name="ln780">                target = i-&gt;pos;</a>
<a name="ln781">        }</a>
<a name="ln782">        else</a>
<a name="ln783">        {</a>
<a name="ln784">            const int num = quant - 3;</a>
<a name="ln785">            const int y = num % 100;</a>
<a name="ln786">            const int x = (num - y)/100;</a>
<a name="ln787">            coord_def c(x,y);</a>
<a name="ln788"> </a>
<a name="ln789">            if (desc_menu.menu_action == InvMenu::ACT_EXAMINE)</a>
<a name="ln790">                describe_feature_wide(c);</a>
<a name="ln791">            else // ACT_EXECUTE -&gt; view/travel</a>
<a name="ln792">                target = c;</a>
<a name="ln793">        }</a>
<a name="ln794">        return desc_menu.menu_action == InvMenu::ACT_EXAMINE;</a>
<a name="ln795">    };</a>
<a name="ln796">    desc_menu.show();</a>
<a name="ln797">    redraw_screen();</a>
<a name="ln798"> </a>
<a name="ln799">    // need to do this after the menu has been closed on console,</a>
<a name="ln800">    // since do_look_around() runs its own loop</a>
<a name="ln801">    if (target != coord_def(-1, -1))</a>
<a name="ln802">        do_look_around(target);</a>
<a name="ln803"> </a>
<a name="ln804">#ifndef USE_TILE_LOCAL</a>
<a name="ln805">    if (!list_items.empty())</a>
<a name="ln806">    {</a>
<a name="ln807">        // Unset show_glyph for other menus.</a>
<a name="ln808">        InvEntry me(list_items[0]);</a>
<a name="ln809">        me.set_show_glyph(false);</a>
<a name="ln810">    }</a>
<a name="ln811">#endif</a>
<a name="ln812">#ifdef USE_TILE</a>
<a name="ln813">    // Clear cursor placement.</a>
<a name="ln814">    tiles.place_cursor(CURSOR_TUTORIAL, NO_CURSOR);</a>
<a name="ln815">    tiles.clear_text_tags(TAG_TUTORIAL);</a>
<a name="ln816">#endif</a>
<a name="ln817">}</a>
<a name="ln818"> </a>
<a name="ln819">void do_look_around(const coord_def &amp;whence)</a>
<a name="ln820">{</a>
<a name="ln821">    dist lmove = _look_around_target(you.pos() + whence);</a>
<a name="ln822">    if (lmove.isValid &amp;&amp; lmove.isTarget &amp;&amp; !lmove.isCancel</a>
<a name="ln823">        &amp;&amp; !crawl_state.arena_suspended)</a>
<a name="ln824">    {</a>
<a name="ln825">        start_travel(lmove.target);</a>
<a name="ln826">    }</a>
<a name="ln827">}</a>
<a name="ln828"> </a>
<a name="ln829">bool get_look_position(coord_def *c)</a>
<a name="ln830">{</a>
<a name="ln831">    dist lmove = _look_around_target(you.pos());</a>
<a name="ln832">    if (lmove.isCancel)</a>
<a name="ln833">        return false;</a>
<a name="ln834">    *c = lmove.target;</a>
<a name="ln835">    return true;</a>
<a name="ln836">}</a>
<a name="ln837"> </a>
<a name="ln838">static dist _look_around_target(const coord_def &amp;whence)</a>
<a name="ln839">{</a>
<a name="ln840">    dist lmove;   // Will be initialised by direction().</a>
<a name="ln841">    direction_chooser_args args;</a>
<a name="ln842">    args.restricts = DIR_TARGET;</a>
<a name="ln843">    args.just_looking = true;</a>
<a name="ln844">    args.needs_path = false;</a>
<a name="ln845">    args.target_prefix = &quot;Here&quot;;</a>
<a name="ln846">    args.default_place = whence - you.pos();</a>
<a name="ln847">    direction(lmove, args);</a>
<a name="ln848">    return lmove;</a>
<a name="ln849">}</a>
<a name="ln850"> </a>
<a name="ln851">range_view_annotator::range_view_annotator(targeter *range)</a>
<a name="ln852">{</a>
<a name="ln853">    if (range &amp;&amp; Options.darken_beyond_range)</a>
<a name="ln854">    {</a>
<a name="ln855">        crawl_state.darken_range = range;</a>
<a name="ln856">        viewwindow(false);</a>
<a name="ln857">    }</a>
<a name="ln858">}</a>
<a name="ln859"> </a>
<a name="ln860">range_view_annotator::~range_view_annotator()</a>
<a name="ln861">{</a>
<a name="ln862">    if (crawl_state.darken_range)</a>
<a name="ln863">    {</a>
<a name="ln864">        crawl_state.darken_range = nullptr;</a>
<a name="ln865">        viewwindow(false);</a>
<a name="ln866">    }</a>
<a name="ln867">}</a>
<a name="ln868"> </a>
<a name="ln869">monster_view_annotator::monster_view_annotator(vector&lt;monster *&gt; *monsters)</a>
<a name="ln870">{</a>
<a name="ln871">    if ((Options.use_animations &amp; UA_MONSTER_IN_SIGHT) &amp;&amp; monsters-&gt;size())</a>
<a name="ln872">    {</a>
<a name="ln873">        crawl_state.flash_monsters = monsters;</a>
<a name="ln874">        viewwindow(false);</a>
<a name="ln875">    }</a>
<a name="ln876">}</a>
<a name="ln877"> </a>
<a name="ln878">monster_view_annotator::~monster_view_annotator()</a>
<a name="ln879">{</a>
<a name="ln880">    if ((Options.use_animations &amp; UA_MONSTER_IN_SIGHT)</a>
<a name="ln881">        &amp;&amp; crawl_state.flash_monsters)</a>
<a name="ln882">    {</a>
<a name="ln883">        crawl_state.flash_monsters = nullptr;</a>
<a name="ln884">        viewwindow(false);</a>
<a name="ln885">    }</a>
<a name="ln886">}</a>
<a name="ln887"> </a>
<a name="ln888">bool direction_chooser::move_is_ok() const</a>
<a name="ln889">{</a>
<a name="ln890">    if (unrestricted)</a>
<a name="ln891">        return true;</a>
<a name="ln892">    if (!moves.isCancel &amp;&amp; moves.isTarget)</a>
<a name="ln893">    {</a>
<a name="ln894">        if (!cell_see_cell(you.pos(), target(), LOS_NO_TRANS))</a>
<a name="ln895">        {</a>
<a name="ln896">            if (hitfunc &amp;&amp; hitfunc-&gt;can_affect_unseen())</a>
<a name="ln897">                return true; // is this too broad?</a>
<a name="ln898">            if (you.see_cell(target()))</a>
<a name="ln899">                mprf(MSGCH_EXAMINE_FILTER, &quot;There's something in the way.&quot;);</a>
<a name="ln900">            else</a>
<a name="ln901">                mprf(MSGCH_EXAMINE_FILTER, &quot;You can't see that place.&quot;);</a>
<a name="ln902">            return false;</a>
<a name="ln903">        }</a>
<a name="ln904"> </a>
<a name="ln905">        if (looking_at_you())</a>
<a name="ln906">        {</a>
<a name="ln907">            if (!targets_objects() &amp;&amp; targets_enemies())</a>
<a name="ln908">            {</a>
<a name="ln909">                if (self == confirm_prompt_type::cancel</a>
<a name="ln910">                    || self == confirm_prompt_type::prompt</a>
<a name="ln911">                       &amp;&amp; Options.allow_self_target</a>
<a name="ln912">                              == confirm_prompt_type::cancel)</a>
<a name="ln913">                {</a>
<a name="ln914">                    mprf(MSGCH_EXAMINE_FILTER, &quot;That would be overly suicidal.&quot;);</a>
<a name="ln915">                    return false;</a>
<a name="ln916">                }</a>
<a name="ln917">                else if (self != confirm_prompt_type::none</a>
<a name="ln918">                         &amp;&amp; Options.allow_self_target</a>
<a name="ln919">                                != confirm_prompt_type::none)</a>
<a name="ln920">                {</a>
<a name="ln921">                    return yesno(&quot;Really target yourself?&quot;, false, 'n');</a>
<a name="ln922">                }</a>
<a name="ln923">            }</a>
<a name="ln924"> </a>
<a name="ln925">            if (self == confirm_prompt_type::cancel)</a>
<a name="ln926">            {</a>
<a name="ln927">                mprf(MSGCH_EXAMINE_FILTER, &quot;Sorry, you can't target yourself.&quot;);</a>
<a name="ln928">                return false;</a>
<a name="ln929">            }</a>
<a name="ln930">        }</a>
<a name="ln931">    }</a>
<a name="ln932"> </a>
<a name="ln933">    // Some odd cases</a>
<a name="ln934">    if (!moves.isValid &amp;&amp; !moves.isCancel)</a>
<a name="ln935">        return yesno(&quot;Are you sure you want to fizzle?&quot;, false, 'n');</a>
<a name="ln936"> </a>
<a name="ln937">    return true;</a>
<a name="ln938">}</a>
<a name="ln939"> </a>
<a name="ln940">// Assuming the target is in view, is line-of-fire blocked?</a>
<a name="ln941">static bool _blocked_ray(const coord_def &amp;where)</a>
<a name="ln942">{</a>
<a name="ln943">    return !exists_ray(you.pos(), where, opc_solid_see);</a>
<a name="ln944">}</a>
<a name="ln945"> </a>
<a name="ln946">// Try to find an enemy monster to target</a>
<a name="ln947">bool direction_chooser::find_default_monster_target(coord_def&amp; result) const</a>
<a name="ln948">{</a>
<a name="ln949">    // First try to pick our previous monster target.</a>
<a name="ln950">    const monster* mons_target = _get_current_target();</a>
<a name="ln951">    if (mons_target != nullptr</a>
<a name="ln952">        &amp;&amp; _want_target_monster(mons_target, mode, hitfunc)</a>
<a name="ln953">        &amp;&amp; in_range(mons_target-&gt;pos()))</a>
<a name="ln954">    {</a>
<a name="ln955">        result = mons_target-&gt;pos();</a>
<a name="ln956">        return true;</a>
<a name="ln957">    }</a>
<a name="ln958">    // If the previous targetted position is at all useful, use it.</a>
<a name="ln959">    if (!Options.simple_targeting &amp;&amp; hitfunc</a>
<a name="ln960">        &amp;&amp; _find_monster_expl(you.prev_grd_targ, mode, needs_path,</a>
<a name="ln961">                              range, hitfunc, AFF_YES, AFF_MULTIPLE))</a>
<a name="ln962">    {</a>
<a name="ln963">        result = you.prev_grd_targ;</a>
<a name="ln964">        return true;</a>
<a name="ln965">    }</a>
<a name="ln966">    // The previous target is no good. Try to find one from scratch.</a>
<a name="ln967">    bool success = false;</a>
<a name="ln968"> </a>
<a name="ln969">    if (Options.simple_targeting)</a>
<a name="ln970">    {</a>
<a name="ln971">        success = _find_square_wrapper(result, 1,</a>
<a name="ln972">                                       bind(_find_monster, placeholders::_1,</a>
<a name="ln973">                                            mode, needs_path, range, hitfunc),</a>
<a name="ln974">                                       hitfunc);</a>
<a name="ln975">    }</a>
<a name="ln976">    else</a>
<a name="ln977">    {</a>
<a name="ln978">        success = hitfunc &amp;&amp; _find_square_wrapper(result, 1,</a>
<a name="ln979">                                                  bind(_find_monster_expl,</a>
<a name="ln980">                                                       placeholders::_1, mode,</a>
<a name="ln981">                                                       needs_path, range,</a>
<a name="ln982">                                                       hitfunc,</a>
<a name="ln983">                                                       // First try to bizap</a>
<a name="ln984">                                                       AFF_MULTIPLE, AFF_YES),</a>
<a name="ln985">                                                  hitfunc)</a>
<a name="ln986">                  || _find_square_wrapper(result, 1,</a>
<a name="ln987">                                          bind(restricts == DIR_SHADOW_STEP ?</a>
<a name="ln988">                                               _find_shadow_step_mons :</a>
<a name="ln989">                                               _find_monster,</a>
<a name="ln990">                                               placeholders::_1, mode,</a>
<a name="ln991">                                               needs_path, range, hitfunc),</a>
<a name="ln992">                                          hitfunc);</a>
<a name="ln993">    }</a>
<a name="ln994"> </a>
<a name="ln995">    // This is used for three things:</a>
<a name="ln996">    // * For all LRD targetting</a>
<a name="ln997">    // * To aim explosions so they try to miss you</a>
<a name="ln998">    // * To hit monsters in LOS that are outside of normal range, but</a>
<a name="ln999">    //   inside explosion/cloud range</a>
<a name="ln1000">    if (!Options.simple_targeting &amp;&amp; hitfunc</a>
<a name="ln1001">        &amp;&amp; hitfunc-&gt;can_affect_outside_range()</a>
<a name="ln1002">        &amp;&amp; (!hitfunc-&gt;set_aim(result)</a>
<a name="ln1003">            || hitfunc-&gt;is_affected(result) &lt; AFF_YES</a>
<a name="ln1004">            || hitfunc-&gt;is_affected(you.pos()) &gt; AFF_NO))</a>
<a name="ln1005">    {</a>
<a name="ln1006">        coord_def old_result;</a>
<a name="ln1007">        if (success)</a>
<a name="ln1008">            old_result = result;</a>
<a name="ln1009">        for (aff_type mon_aff : { AFF_YES, AFF_MAYBE })</a>
<a name="ln1010">        {</a>
<a name="ln1011">            for (aff_type allowed_self_aff : { AFF_NO, AFF_MAYBE, AFF_YES })</a>
<a name="ln1012">            {</a>
<a name="ln1013">                success = _find_square_wrapper(result, 1,</a>
<a name="ln1014">                                       bind(_find_monster_expl,</a>
<a name="ln1015">                                            placeholders::_1, mode,</a>
<a name="ln1016">                                            needs_path, range, hitfunc,</a>
<a name="ln1017">                                            mon_aff, allowed_self_aff),</a>
<a name="ln1018">                                       hitfunc);</a>
<a name="ln1019">                if (success)</a>
<a name="ln1020">                {</a>
<a name="ln1021">                    // If we're hitting ourselves anyway, just target the</a>
<a name="ln1022">                    // monster's position (this looks less strange).</a>
<a name="ln1023">                    if (allowed_self_aff == AFF_YES &amp;&amp; !old_result.origin())</a>
<a name="ln1024">                        result = old_result;</a>
<a name="ln1025">                    break;</a>
<a name="ln1026">                }</a>
<a name="ln1027">            }</a>
<a name="ln1028">            if (success)</a>
<a name="ln1029">                break;</a>
<a name="ln1030">        }</a>
<a name="ln1031">    }</a>
<a name="ln1032">    if (success)</a>
<a name="ln1033">        return true;</a>
<a name="ln1034"> </a>
<a name="ln1035">    // If we couldn't, maybe it was because of line-of-fire issues.</a>
<a name="ln1036">    // Check if that's happening, and inform the user (because it's</a>
<a name="ln1037">    // pretty confusing.)</a>
<a name="ln1038">    if (needs_path</a>
<a name="ln1039">        &amp;&amp; _find_square_wrapper(result, 1,</a>
<a name="ln1040">                                bind(restricts == DIR_SHADOW_STEP ?</a>
<a name="ln1041">                                     _find_shadow_step_mons : _find_monster,</a>
<a name="ln1042">                                     placeholders::_1, mode, false,</a>
<a name="ln1043">                                     range, hitfunc),</a>
<a name="ln1044">                               hitfunc))</a>
<a name="ln1045">    {</a>
<a name="ln1046">        // Special colouring in tutorial or hints mode.</a>
<a name="ln1047">        const bool need_hint = Hints.hints_events[HINT_TARGET_NO_FOE];</a>
<a name="ln1048">        // TODO: this seems to trigger when there are no monsters in range</a>
<a name="ln1049">        // of the hitfunc, regardless of what's in the way, and it shouldn't.</a>
<a name="ln1050">        mprf(need_hint ? MSGCH_TUTORIAL : MSGCH_PROMPT,</a>
<a name="ln1051">            &quot;All monsters which could be auto-targeted are covered by &quot;</a>
<a name="ln1052">            &quot;a wall or statue which interrupts your line of fire, even &quot;</a>
<a name="ln1053">            &quot;though it doesn't interrupt your line of sight.&quot;);</a>
<a name="ln1054"> </a>
<a name="ln1055">        if (need_hint)</a>
<a name="ln1056">        {</a>
<a name="ln1057">            mprf(MSGCH_TUTORIAL, &quot;To return to the main mode, press &lt;w&gt;Escape&lt;/w&gt;.&quot;);</a>
<a name="ln1058">            Hints.hints_events[HINT_TARGET_NO_FOE] = false;</a>
<a name="ln1059">        }</a>
<a name="ln1060">    }</a>
<a name="ln1061">    return false;</a>
<a name="ln1062">}</a>
<a name="ln1063"> </a>
<a name="ln1064">// Find a good square to start targeting from.</a>
<a name="ln1065">coord_def direction_chooser::find_default_target() const</a>
<a name="ln1066">{</a>
<a name="ln1067">    coord_def result = you.pos();</a>
<a name="ln1068">    bool success = false;</a>
<a name="ln1069"> </a>
<a name="ln1070">    if (targets_objects())</a>
<a name="ln1071">    {</a>
<a name="ln1072">        // First, try to find a particularly relevant item (autopickup).</a>
<a name="ln1073">        // Barring that, just try anything.</a>
<a name="ln1074">        success = _find_square_wrapper(result, 1,</a>
<a name="ln1075">                                       bind(_find_autopickup_object,</a>
<a name="ln1076">                                            placeholders::_1,</a>
<a name="ln1077">                                            needs_path, range, hitfunc),</a>
<a name="ln1078">                                       hitfunc,</a>
<a name="ln1079">                                       LS_FLIPVH)</a>
<a name="ln1080">               || _find_square_wrapper(result, 1,</a>
<a name="ln1081">                                       bind(_find_object, placeholders::_1,</a>
<a name="ln1082">                                            needs_path, range, hitfunc),</a>
<a name="ln1083">                                       hitfunc,</a>
<a name="ln1084">                                       LS_FLIPVH);</a>
<a name="ln1085">    }</a>
<a name="ln1086">    else if ((mode != TARG_ANY &amp;&amp; mode != TARG_FRIEND)</a>
<a name="ln1087">             || self == confirm_prompt_type::cancel)</a>
<a name="ln1088">    {</a>
<a name="ln1089">        success = find_default_monster_target(result);</a>
<a name="ln1090">    }</a>
<a name="ln1091"> </a>
<a name="ln1092">    if (!success)</a>
<a name="ln1093">        result = you.pos();</a>
<a name="ln1094"> </a>
<a name="ln1095">    return result;</a>
<a name="ln1096">}</a>
<a name="ln1097"> </a>
<a name="ln1098">const coord_def&amp; direction_chooser::target() const</a>
<a name="ln1099">{</a>
<a name="ln1100">    return moves.target;</a>
<a name="ln1101">}</a>
<a name="ln1102"> </a>
<a name="ln1103">void direction_chooser::set_target(const coord_def&amp; new_target)</a>
<a name="ln1104">{</a>
<a name="ln1105">    if (restricts == DIR_SHADOW_STEP)</a>
<a name="ln1106">        valid_shadow_step = hitfunc-&gt;has_additional_sites(new_target);</a>
<a name="ln1107">    moves.target = new_target;</a>
<a name="ln1108">}</a>
<a name="ln1109"> </a>
<a name="ln1110">static void _draw_ray_cell(coord_def p, coord_def target, aff_type aff)</a>
<a name="ln1111">{</a>
<a name="ln1112">    UNUSED(target);</a>
<a name="ln1113">#ifdef USE_TILE</a>
<a name="ln1114">    tile_place_ray(p, aff);</a>
<a name="ln1115">#endif</a>
<a name="ln1116">#ifndef USE_TILE_LOCAL</a>
<a name="ln1117">    int bcol = BLACK;</a>
<a name="ln1118">    if (aff &lt; 0)</a>
<a name="ln1119">        bcol = DARKGREY;</a>
<a name="ln1120">    else if (aff &lt; AFF_YES)</a>
<a name="ln1121">        bcol = (p == target) ? RED : MAGENTA;</a>
<a name="ln1122">    else if (aff == AFF_YES)</a>
<a name="ln1123">        bcol = (p == target) ? LIGHTRED : LIGHTMAGENTA;</a>
<a name="ln1124">    else if (aff == AFF_LANDING)</a>
<a name="ln1125">        bcol = (p == target) ? LIGHTGREEN : GREEN;</a>
<a name="ln1126">    else if (aff == AFF_MULTIPLE)</a>
<a name="ln1127">        bcol = (p == target) ? LIGHTCYAN : CYAN;</a>
<a name="ln1128">    else</a>
<a name="ln1129">        die(&quot;unhandled aff %d&quot;, aff);</a>
<a name="ln1130"> </a>
<a name="ln1131">    int mbcol = (p == target) ? bcol : bcol | COLFLAG_REVERSE;</a>
<a name="ln1132">    _draw_ray_glyph(p, bcol, '*', mbcol);</a>
<a name="ln1133">#endif</a>
<a name="ln1134">}</a>
<a name="ln1135"> </a>
<a name="ln1136">void direction_chooser::draw_beam()</a>
<a name="ln1137">{</a>
<a name="ln1138">    if (!show_beam)</a>
<a name="ln1139">    {</a>
<a name="ln1140">        viewwindow(</a>
<a name="ln1141">#ifndef USE_TILE</a>
<a name="ln1142">            false</a>
<a name="ln1143">#endif</a>
<a name="ln1144">            );</a>
<a name="ln1145">        return;</a>
<a name="ln1146">    }</a>
<a name="ln1147"> </a>
<a name="ln1148">    // Clear the old beam if necessary.</a>
<a name="ln1149">    viewwindow(false);</a>
<a name="ln1150"> </a>
<a name="ln1151">    // Use the new API if implemented.</a>
<a name="ln1152">    if (hitfunc)</a>
<a name="ln1153">    {</a>
<a name="ln1154">        if (!hitfunc-&gt;set_aim(target()))</a>
<a name="ln1155">        {</a>
<a name="ln1156">#ifdef USE_TILE</a>
<a name="ln1157">            viewwindow(true, true);</a>
<a name="ln1158">#endif</a>
<a name="ln1159">            return;</a>
<a name="ln1160">        }</a>
<a name="ln1161">        const los_type los = hitfunc-&gt;can_affect_unseen()</a>
<a name="ln1162">                                            ? LOS_NONE : LOS_DEFAULT;</a>
<a name="ln1163">        for (radius_iterator ri(you.pos(), los); ri; ++ri)</a>
<a name="ln1164">            if (aff_type aff = hitfunc-&gt;is_affected(*ri))</a>
<a name="ln1165">                _draw_ray_cell(*ri, target(), aff);</a>
<a name="ln1166"> </a>
<a name="ln1167">#ifdef USE_TILE</a>
<a name="ln1168">        viewwindow(true, true);</a>
<a name="ln1169">#endif</a>
<a name="ln1170">        return;</a>
<a name="ln1171">    }</a>
<a name="ln1172"> </a>
<a name="ln1173">    // If we don't have a new beam to show, we're done.</a>
<a name="ln1174">    if (!have_beam)</a>
<a name="ln1175">    {</a>
<a name="ln1176">#ifdef USE_TILE</a>
<a name="ln1177">        // Clear the old beam if we're not drawing anything else.</a>
<a name="ln1178">        viewwindow(true, true);</a>
<a name="ln1179">#endif</a>
<a name="ln1180">        return;</a>
<a name="ln1181">    }</a>
<a name="ln1182"> </a>
<a name="ln1183">    // We shouldn't ever get a beam to an out-of-LOS target.</a>
<a name="ln1184">    ASSERT(you.see_cell(target()));</a>
<a name="ln1185"> </a>
<a name="ln1186">    // Work with a copy in order not to mangle anything.</a>
<a name="ln1187">    ray_def ray = beam;</a>
<a name="ln1188"> </a>
<a name="ln1189">    // Draw the new ray with magenta '*'s, not including your square</a>
<a name="ln1190">    // or the target square. Out-of-range cells get grey '*'s instead.</a>
<a name="ln1191">    for (; ray.pos() != target(); ray.advance())</a>
<a name="ln1192">    {</a>
<a name="ln1193">        const coord_def p = ray.pos();</a>
<a name="ln1194">        ASSERT(you.see_cell(p));</a>
<a name="ln1195"> </a>
<a name="ln1196">        if (p == you.pos())</a>
<a name="ln1197">            continue;</a>
<a name="ln1198"> </a>
<a name="ln1199">        const bool inrange = in_range(p);</a>
<a name="ln1200">#ifdef USE_TILE</a>
<a name="ln1201">        tile_place_ray(p, inrange ? AFF_YES : AFF_NO);</a>
<a name="ln1202">#endif</a>
<a name="ln1203">#ifndef USE_TILE_LOCAL</a>
<a name="ln1204">        const int bcol = inrange ? MAGENTA : DARKGREY;</a>
<a name="ln1205">        _draw_ray_glyph(p, bcol, '*', bcol | COLFLAG_REVERSE);</a>
<a name="ln1206">#endif</a>
<a name="ln1207">    }</a>
<a name="ln1208">    textcolour(LIGHTGREY);</a>
<a name="ln1209">#ifdef USE_TILE</a>
<a name="ln1210">    tile_place_ray(target(), in_range(ray.pos()) ? AFF_YES : AFF_NO);</a>
<a name="ln1211"> </a>
<a name="ln1212">    // In tiles, we need to refresh the window to get the beam drawn.</a>
<a name="ln1213">    viewwindow(true, true);</a>
<a name="ln1214">#endif</a>
<a name="ln1215">}</a>
<a name="ln1216"> </a>
<a name="ln1217">bool direction_chooser::in_range(const coord_def&amp; p) const</a>
<a name="ln1218">{</a>
<a name="ln1219">    if (hitfunc)</a>
<a name="ln1220">        return hitfunc-&gt;valid_aim(p);</a>
<a name="ln1221">    return range &lt; 0 || grid_distance(p, you.pos()) &lt;= range;</a>
<a name="ln1222">}</a>
<a name="ln1223"> </a>
<a name="ln1224">// Cycle to either the next (dir == 1) or previous (dir == -1) object</a>
<a name="ln1225">// and update output accordingly if successful.</a>
<a name="ln1226">void direction_chooser::object_cycle(int dir)</a>
<a name="ln1227">{</a>
<a name="ln1228">    if (_find_square_wrapper(objfind_pos, dir,</a>
<a name="ln1229">                             bind(_find_object, placeholders::_1, needs_path,</a>
<a name="ln1230">                                  range, hitfunc),</a>
<a name="ln1231">                             hitfunc,</a>
<a name="ln1232">                             dir &gt; 0 ? LS_FLIPVH : LS_FLIPHV))</a>
<a name="ln1233">    {</a>
<a name="ln1234">        set_target(objfind_pos);</a>
<a name="ln1235">        show_items_once = true;</a>
<a name="ln1236">    }</a>
<a name="ln1237">    else</a>
<a name="ln1238">        flush_input_buffer(FLUSH_ON_FAILURE);</a>
<a name="ln1239">}</a>
<a name="ln1240"> </a>
<a name="ln1241">void direction_chooser::monster_cycle(int dir)</a>
<a name="ln1242">{</a>
<a name="ln1243">    if (_find_square_wrapper(monsfind_pos, dir,</a>
<a name="ln1244">                             bind(_find_monster, placeholders::_1, mode,</a>
<a name="ln1245">                                  needs_path, range, hitfunc),</a>
<a name="ln1246">                             hitfunc))</a>
<a name="ln1247">    {</a>
<a name="ln1248">        set_target(monsfind_pos);</a>
<a name="ln1249">    }</a>
<a name="ln1250">    else</a>
<a name="ln1251">        flush_input_buffer(FLUSH_ON_FAILURE);</a>
<a name="ln1252">}</a>
<a name="ln1253"> </a>
<a name="ln1254">void direction_chooser::feature_cycle_forward(int feature)</a>
<a name="ln1255">{</a>
<a name="ln1256">    if (_find_square_wrapper(objfind_pos, 1,</a>
<a name="ln1257">                             [feature](const coord_def&amp; where)</a>
<a name="ln1258">                             {</a>
<a name="ln1259">                                 return map_bounds(where)</a>
<a name="ln1260">                                        &amp;&amp; (you.see_cell(where)</a>
<a name="ln1261">                                            || env.map_knowledge(where).seen())</a>
<a name="ln1262">                                        &amp;&amp; is_feature(feature, where);</a>
<a name="ln1263">                             },</a>
<a name="ln1264">                             hitfunc,</a>
<a name="ln1265">                             LS_FLIPVH))</a>
<a name="ln1266">    {</a>
<a name="ln1267">        set_target(objfind_pos);</a>
<a name="ln1268">    }</a>
<a name="ln1269">    else</a>
<a name="ln1270">        flush_input_buffer(FLUSH_ON_FAILURE);</a>
<a name="ln1271">}</a>
<a name="ln1272"> </a>
<a name="ln1273">void direction_chooser::update_previous_target() const</a>
<a name="ln1274">{</a>
<a name="ln1275">    you.prev_targ = MHITNOT;</a>
<a name="ln1276">    you.prev_grd_targ.reset();</a>
<a name="ln1277"> </a>
<a name="ln1278">    // Maybe we should except just_looking here?</a>
<a name="ln1279">    const monster* m = monster_at(target());</a>
<a name="ln1280">    if (m &amp;&amp; you.can_see(*m))</a>
<a name="ln1281">        you.prev_targ = m-&gt;mindex();</a>
<a name="ln1282">    else if (looking_at_you())</a>
<a name="ln1283">        you.prev_targ = MHITYOU;</a>
<a name="ln1284">    else</a>
<a name="ln1285">        you.prev_grd_targ = target();</a>
<a name="ln1286">}</a>
<a name="ln1287"> </a>
<a name="ln1288">bool direction_chooser::select(bool allow_out_of_range, bool endpoint)</a>
<a name="ln1289">{</a>
<a name="ln1290">    const monster* mons = monster_at(target());</a>
<a name="ln1291"> </a>
<a name="ln1292">    if (restricts == DIR_SHADOW_STEP &amp;&amp; !valid_shadow_step)</a>
<a name="ln1293">        return false;</a>
<a name="ln1294"> </a>
<a name="ln1295">    if ((restricts == DIR_LEAP</a>
<a name="ln1296">         || restricts == DIR_SHADOW_STEP</a>
<a name="ln1297">         || !allow_out_of_range)</a>
<a name="ln1298">        &amp;&amp; !in_range(target()))</a>
<a name="ln1299">    {</a>
<a name="ln1300">        mprf(MSGCH_EXAMINE_FILTER, &quot;%s&quot;,</a>
<a name="ln1301">             hitfunc? hitfunc-&gt;why_not.c_str() : &quot;That is beyond the maximum range.&quot;);</a>
<a name="ln1302">        return false;</a>
<a name="ln1303">    }</a>
<a name="ln1304">    moves.isEndpoint = endpoint || (mons &amp;&amp; _mon_exposed(mons));</a>
<a name="ln1305">    moves.isValid  = true;</a>
<a name="ln1306">    moves.isTarget = true;</a>
<a name="ln1307">    update_previous_target();</a>
<a name="ln1308">    return true;</a>
<a name="ln1309">}</a>
<a name="ln1310"> </a>
<a name="ln1311">bool direction_chooser::pickup_item()</a>
<a name="ln1312">{</a>
<a name="ln1313">    item_info *ii = 0;</a>
<a name="ln1314">    if (in_bounds(target()))</a>
<a name="ln1315">        ii = env.map_knowledge(target()).item();</a>
<a name="ln1316">    if (!ii || !ii-&gt;is_valid(true))</a>
<a name="ln1317">    {</a>
<a name="ln1318">        mprf(MSGCH_EXAMINE_FILTER, &quot;You can't see any item there.&quot;);</a>
<a name="ln1319">        return false;</a>
<a name="ln1320">    }</a>
<a name="ln1321">    ii-&gt;flags |= ISFLAG_THROWN; // make autoexplore greedy</a>
<a name="ln1322"> </a>
<a name="ln1323">    // From this point, if there's no item, we'll fake one. False info means</a>
<a name="ln1324">    // it's out of bounds and taken, or a mimic.</a>
<a name="ln1325">    item_def *item = 0;</a>
<a name="ln1326">    unsigned short it = env.igrid(target());</a>
<a name="ln1327">    if (it != NON_ITEM)</a>
<a name="ln1328">    {</a>
<a name="ln1329">        item = &amp;mitm[it];</a>
<a name="ln1330">        // Check if it appears to be the same item.</a>
<a name="ln1331">        if (!item-&gt;is_valid()</a>
<a name="ln1332">            || ii-&gt;base_type != item-&gt;base_type</a>
<a name="ln1333">            || ii-&gt;sub_type != item-&gt;sub_type</a>
<a name="ln1334">               // TODO: check for different unidentified items of the same base type</a>
<a name="ln1335">               &amp;&amp; (!item_type_has_unidentified(item-&gt;base_type)</a>
<a name="ln1336">                   || ii-&gt;sub_type == get_max_subtype(item-&gt;base_type))</a>
<a name="ln1337">            || ii-&gt;get_colour() != item-&gt;get_colour())</a>
<a name="ln1338">        {</a>
<a name="ln1339">            item = 0;</a>
<a name="ln1340">        }</a>
<a name="ln1341">    }</a>
<a name="ln1342">    if (item)</a>
<a name="ln1343">        item-&gt;flags |= ISFLAG_THROWN;</a>
<a name="ln1344"> </a>
<a name="ln1345">    if (!just_looking) // firing/casting prompt</a>
<a name="ln1346">    {</a>
<a name="ln1347">        mprf(MSGCH_EXAMINE_FILTER, &quot;Marked for pickup.&quot;);</a>
<a name="ln1348">        return false;</a>
<a name="ln1349">    }</a>
<a name="ln1350"> </a>
<a name="ln1351">    moves.isValid  = true;</a>
<a name="ln1352">    moves.isTarget = true;</a>
<a name="ln1353">    update_previous_target();</a>
<a name="ln1354">    return true;</a>
<a name="ln1355">}</a>
<a name="ln1356"> </a>
<a name="ln1357">bool direction_chooser::handle_signals()</a>
<a name="ln1358">{</a>
<a name="ln1359">    // If we've received a HUP signal then the user can't choose a</a>
<a name="ln1360">    // target.</a>
<a name="ln1361">    if (crawl_state.seen_hups)</a>
<a name="ln1362">    {</a>
<a name="ln1363">        moves.isValid  = false;</a>
<a name="ln1364">        moves.isCancel = true;</a>
<a name="ln1365"> </a>
<a name="ln1366">        mprf(MSGCH_ERROR, &quot;Targeting interrupted by HUP signal.&quot;);</a>
<a name="ln1367">        return true;</a>
<a name="ln1368">    }</a>
<a name="ln1369">    return false;</a>
<a name="ln1370">}</a>
<a name="ln1371"> </a>
<a name="ln1372">// Print out the initial prompt when targeting starts.</a>
<a name="ln1373">// Prompts might get scrolled off if you have too few lines available;</a>
<a name="ln1374">// we'll live with that.</a>
<a name="ln1375">void direction_chooser::show_initial_prompt()</a>
<a name="ln1376">{</a>
<a name="ln1377">    behaviour-&gt;update_top_prompt(&amp;top_prompt);</a>
<a name="ln1378">    describe_cell();</a>
<a name="ln1379">}</a>
<a name="ln1380"> </a>
<a name="ln1381">void direction_chooser::print_target_description(bool &amp;did_cloud) const</a>
<a name="ln1382">{</a>
<a name="ln1383">    if (targets_objects())</a>
<a name="ln1384">        print_target_object_description();</a>
<a name="ln1385">    else</a>
<a name="ln1386">        print_target_monster_description(did_cloud);</a>
<a name="ln1387"> </a>
<a name="ln1388">    if (!in_range(target()))</a>
<a name="ln1389">    {</a>
<a name="ln1390">        mprf(MSGCH_EXAMINE_FILTER, &quot;%s&quot;,</a>
<a name="ln1391">             hitfunc ? hitfunc-&gt;why_not.c_str() : &quot;Out of range.&quot;);</a>
<a name="ln1392">    }</a>
<a name="ln1393">}</a>
<a name="ln1394"> </a>
<a name="ln1395">string direction_chooser::target_interesting_terrain_description() const</a>
<a name="ln1396">{</a>
<a name="ln1397">    const dungeon_feature_type feature = grd(target());</a>
<a name="ln1398"> </a>
<a name="ln1399">    // Only features which can make you lose the item are interesting.</a>
<a name="ln1400">    // FIXME: extract the naming logic from here and use</a>
<a name="ln1401">    // feat_has_solid_floor().</a>
<a name="ln1402">    switch (feature)</a>
<a name="ln1403">    {</a>
<a name="ln1404">    case DNGN_DEEP_WATER: return &quot;water&quot;;</a>
<a name="ln1405">    case DNGN_LAVA:       return &quot;lava&quot;;</a>
<a name="ln1406">    default:              return &quot;&quot;;</a>
<a name="ln1407">    }</a>
<a name="ln1408">}</a>
<a name="ln1409"> </a>
<a name="ln1410">string direction_chooser::target_cloud_description() const</a>
<a name="ln1411">{</a>
<a name="ln1412">    if (cloud_struct* cloud = cloud_at(target()))</a>
<a name="ln1413">        return cloud-&gt;cloud_name(true);</a>
<a name="ln1414">    else</a>
<a name="ln1415">        return &quot;&quot;;</a>
<a name="ln1416">}</a>
<a name="ln1417"> </a>
<a name="ln1418">template&lt;typename C1, typename C2&gt;</a>
<a name="ln1419">static void _append_container(C1&amp; container_base, const C2&amp; container_append)</a>
<a name="ln1420">{</a>
<a name="ln1421">    container_base.insert(container_base.end(),</a>
<a name="ln1422">                          container_append.begin(), container_append.end());</a>
<a name="ln1423">}</a>
<a name="ln1424"> </a>
<a name="ln1425">string direction_chooser::target_sanctuary_description() const</a>
<a name="ln1426">{</a>
<a name="ln1427">    return is_sanctuary(target()) ? &quot;sanctuary&quot; : &quot;&quot;;</a>
<a name="ln1428">}</a>
<a name="ln1429"> </a>
<a name="ln1430">string direction_chooser::target_silence_description() const</a>
<a name="ln1431">{</a>
<a name="ln1432">    return silenced(target()) ? &quot;silenced&quot; : &quot;&quot;;</a>
<a name="ln1433">}</a>
<a name="ln1434"> </a>
<a name="ln1435">static void _push_back_if_nonempty(const string&amp; str, vector&lt;string&gt;* vec)</a>
<a name="ln1436">{</a>
<a name="ln1437">    if (!str.empty())</a>
<a name="ln1438">        vec-&gt;push_back(str);</a>
<a name="ln1439">}</a>
<a name="ln1440"> </a>
<a name="ln1441">void direction_chooser::print_target_monster_description(bool &amp;did_cloud) const</a>
<a name="ln1442">{</a>
<a name="ln1443">    // Do we see anything?</a>
<a name="ln1444">    const monster* mon = monster_at(target());</a>
<a name="ln1445">    if (!mon)</a>
<a name="ln1446">        return;</a>
<a name="ln1447"> </a>
<a name="ln1448">    const bool visible = you.can_see(*mon);</a>
<a name="ln1449">    const bool exposed = _mon_exposed(mon);</a>
<a name="ln1450">    if (!visible &amp;&amp; !exposed)</a>
<a name="ln1451">        return;</a>
<a name="ln1452"> </a>
<a name="ln1453">    // OK, now we know that we have something to describe.</a>
<a name="ln1454">    vector&lt;string&gt; suffixes;</a>
<a name="ln1455">    string text;</a>
<a name="ln1456">    // Cell features go first.</a>
<a name="ln1457">    _append_container(suffixes, target_cell_description_suffixes());</a>
<a name="ln1458">    if (visible)</a>
<a name="ln1459">    {</a>
<a name="ln1460">        monster_info mi(mon);</a>
<a name="ln1461">        // Only describe the monster if you can actually see it.</a>
<a name="ln1462">        _append_container(suffixes, monster_description_suffixes(mi));</a>
<a name="ln1463">        text = get_monster_equipment_desc(mi);</a>
<a name="ln1464">    }</a>
<a name="ln1465">    else</a>
<a name="ln1466">        text = &quot;Disturbance&quot;;</a>
<a name="ln1467"> </a>
<a name="ln1468">    // Build the final description string.</a>
<a name="ln1469">    if (!suffixes.empty())</a>
<a name="ln1470">    {</a>
<a name="ln1471">        text += &quot; (&quot;</a>
<a name="ln1472">            + comma_separated_line(suffixes.begin(), suffixes.end(), &quot;, &quot;)</a>
<a name="ln1473">            + &quot;)&quot;;</a>
<a name="ln1474">    }</a>
<a name="ln1475"> </a>
<a name="ln1476">    mprf(MSGCH_PROMPT, &quot;%s: &lt;lightgrey&gt;%s&lt;/lightgrey&gt;&quot;,</a>
<a name="ln1477">         target_prefix ? target_prefix : &quot;Aim&quot;,</a>
<a name="ln1478">         text.c_str());</a>
<a name="ln1479"> </a>
<a name="ln1480">    // If there's a cloud here, it's been described.</a>
<a name="ln1481">    did_cloud = true;</a>
<a name="ln1482">}</a>
<a name="ln1483"> </a>
<a name="ln1484">// FIXME: this should really take a cell as argument.</a>
<a name="ln1485">vector&lt;string&gt; direction_chooser::target_cell_description_suffixes() const</a>
<a name="ln1486">{</a>
<a name="ln1487">    vector&lt;string&gt; suffixes;</a>
<a name="ln1488">    // Things which describe the cell.</a>
<a name="ln1489">    _push_back_if_nonempty(target_cloud_description(), &amp;suffixes);</a>
<a name="ln1490">    _push_back_if_nonempty(target_sanctuary_description(), &amp;suffixes);</a>
<a name="ln1491">    _push_back_if_nonempty(target_silence_description(), &amp;suffixes);</a>
<a name="ln1492">    _push_back_if_nonempty(target_interesting_terrain_description(), &amp;suffixes);</a>
<a name="ln1493"> </a>
<a name="ln1494">    return suffixes;</a>
<a name="ln1495">}</a>
<a name="ln1496"> </a>
<a name="ln1497">vector&lt;string&gt; direction_chooser::monster_description_suffixes(</a>
<a name="ln1498">    const monster_info&amp; mi) const</a>
<a name="ln1499">{</a>
<a name="ln1500">    vector&lt;string&gt; suffixes;</a>
<a name="ln1501"> </a>
<a name="ln1502">    _push_back_if_nonempty(mi.wounds_description(true), &amp;suffixes);</a>
<a name="ln1503">    _push_back_if_nonempty(mi.constriction_description(), &amp;suffixes);</a>
<a name="ln1504">    _append_container(suffixes, mi.attributes());</a>
<a name="ln1505">    _append_container(suffixes, _get_monster_desc_vector(mi));</a>
<a name="ln1506">    _append_container(suffixes, behaviour-&gt;get_monster_desc(mi));</a>
<a name="ln1507"> </a>
<a name="ln1508">    return suffixes;</a>
<a name="ln1509">}</a>
<a name="ln1510"> </a>
<a name="ln1511">void direction_chooser::print_target_object_description() const</a>
<a name="ln1512">{</a>
<a name="ln1513">    if (!you.see_cell(target()))</a>
<a name="ln1514">        return;</a>
<a name="ln1515"> </a>
<a name="ln1516">    const item_def* item = top_item_at(target());</a>
<a name="ln1517">    if (!item)</a>
<a name="ln1518">        return;</a>
<a name="ln1519"> </a>
<a name="ln1520">    // FIXME: remove the duplication with print_items_description().</a>
<a name="ln1521">    mprf(MSGCH_PROMPT, &quot;%s: %s&quot;,</a>
<a name="ln1522">         target_prefix ? target_prefix : &quot;Aim&quot;,</a>
<a name="ln1523">         menu_colour_item_name(*item, DESC_A).c_str());</a>
<a name="ln1524">}</a>
<a name="ln1525"> </a>
<a name="ln1526">void direction_chooser::print_items_description() const</a>
<a name="ln1527">{</a>
<a name="ln1528">    if (!in_bounds(target()))</a>
<a name="ln1529">        return;</a>
<a name="ln1530"> </a>
<a name="ln1531">    const item_def* item = top_item_at(target());</a>
<a name="ln1532">    if (!item)</a>
<a name="ln1533">        return;</a>
<a name="ln1534"> </a>
<a name="ln1535">    // Print the first item.</a>
<a name="ln1536">    mprf(MSGCH_FLOOR_ITEMS, &quot;%s.&quot;,</a>
<a name="ln1537">         menu_colour_item_name(*item, DESC_A).c_str());</a>
<a name="ln1538"> </a>
<a name="ln1539">    if (multiple_items_at(target()))</a>
<a name="ln1540">        mprf(MSGCH_FLOOR_ITEMS, &quot;There is something else lying underneath.&quot;);</a>
<a name="ln1541">}</a>
<a name="ln1542"> </a>
<a name="ln1543">void direction_chooser::print_floor_description(bool boring_too) const</a>
<a name="ln1544">{</a>
<a name="ln1545">    const dungeon_feature_type feat = grd(target());</a>
<a name="ln1546">    if (!boring_too &amp;&amp; feat == DNGN_FLOOR)</a>
<a name="ln1547">        return;</a>
<a name="ln1548"> </a>
<a name="ln1549">#ifdef DEBUG_DIAGNOSTICS</a>
<a name="ln1550">    // [ds] Be more verbose in debug mode.</a>
<a name="ln1551">    if (you.wizard)</a>
<a name="ln1552">        _debug_describe_feature_at(target());</a>
<a name="ln1553">    else</a>
<a name="ln1554">#endif</a>
<a name="ln1555">    mprf(MSGCH_EXAMINE_FILTER, &quot;%s.&quot;,</a>
<a name="ln1556">         feature_description_at(target(), true).c_str());</a>
<a name="ln1557">}</a>
<a name="ln1558"> </a>
<a name="ln1559">void direction_chooser::reinitialize_move_flags()</a>
<a name="ln1560">{</a>
<a name="ln1561">    moves.isValid    = false;</a>
<a name="ln1562">    moves.isTarget   = false;</a>
<a name="ln1563">    moves.isCancel   = false;</a>
<a name="ln1564">    moves.isEndpoint = false;</a>
<a name="ln1565">    moves.choseRay   = false;</a>
<a name="ln1566">}</a>
<a name="ln1567"> </a>
<a name="ln1568">// Returns true if we've completed targeting.</a>
<a name="ln1569">bool direction_chooser::select_compass_direction(const coord_def&amp; delta)</a>
<a name="ln1570">{</a>
<a name="ln1571">    if (restricts != DIR_TARGET &amp;&amp; restricts != DIR_SHADOW_STEP)</a>
<a name="ln1572">    {</a>
<a name="ln1573">        // A direction is allowed, and we've selected it.</a>
<a name="ln1574">        moves.delta    = delta;</a>
<a name="ln1575">        // Needed for now...eventually shouldn't be necessary</a>
<a name="ln1576">        set_target(you.pos() + moves.delta);</a>
<a name="ln1577">        moves.isValid  = true;</a>
<a name="ln1578">        moves.isTarget = false;</a>
<a name="ln1579">        have_beam      = false;</a>
<a name="ln1580">        show_beam      = false;</a>
<a name="ln1581">        moves.choseRay = false;</a>
<a name="ln1582">        return true;</a>
<a name="ln1583">    }</a>
<a name="ln1584">    else</a>
<a name="ln1585">    {</a>
<a name="ln1586">        // Direction not allowed, so just move in that direction.</a>
<a name="ln1587">        // Maybe make this a bigger jump?</a>
<a name="ln1588">        set_target(target() + delta * 3);</a>
<a name="ln1589">        return false;</a>
<a name="ln1590">    }</a>
<a name="ln1591">}</a>
<a name="ln1592"> </a>
<a name="ln1593">void direction_chooser::toggle_beam()</a>
<a name="ln1594">{</a>
<a name="ln1595">    if (!needs_path)</a>
<a name="ln1596">    {</a>
<a name="ln1597">        mprf(MSGCH_EXAMINE_FILTER, &quot;This spell doesn't need a beam path.&quot;);</a>
<a name="ln1598">        return;</a>
<a name="ln1599">    }</a>
<a name="ln1600"> </a>
<a name="ln1601">    show_beam = !show_beam;</a>
<a name="ln1602">    need_viewport_redraw = true;</a>
<a name="ln1603"> </a>
<a name="ln1604">    if (show_beam)</a>
<a name="ln1605">    {</a>
<a name="ln1606">        have_beam = find_ray(you.pos(), target(), beam,</a>
<a name="ln1607">                             opc_solid_see, you.current_vision);</a>
<a name="ln1608">    }</a>
<a name="ln1609">}</a>
<a name="ln1610"> </a>
<a name="ln1611">bool direction_chooser::select_previous_target()</a>
<a name="ln1612">{</a>
<a name="ln1613">    if (const monster* mon_target = _get_current_target())</a>
<a name="ln1614">    {</a>
<a name="ln1615">        // We have all the information we need.</a>
<a name="ln1616">        moves.isValid  = true;</a>
<a name="ln1617">        moves.isTarget = true;</a>
<a name="ln1618">        set_target(mon_target-&gt;pos());</a>
<a name="ln1619">        if (!just_looking)</a>
<a name="ln1620">            have_beam = false;</a>
<a name="ln1621"> </a>
<a name="ln1622">        return !just_looking;</a>
<a name="ln1623">    }</a>
<a name="ln1624">    else</a>
<a name="ln1625">    {</a>
<a name="ln1626">        mprf(MSGCH_EXAMINE_FILTER, &quot;Your target is gone.&quot;);</a>
<a name="ln1627">        flush_prev_message();</a>
<a name="ln1628">        return false;</a>
<a name="ln1629">    }</a>
<a name="ln1630">}</a>
<a name="ln1631"> </a>
<a name="ln1632">bool direction_chooser::looking_at_you() const</a>
<a name="ln1633">{</a>
<a name="ln1634">    return target() == you.pos();</a>
<a name="ln1635">}</a>
<a name="ln1636"> </a>
<a name="ln1637">void direction_chooser::handle_movement_key(command_type key_command,</a>
<a name="ln1638">                                            bool* loop_done)</a>
<a name="ln1639">{</a>
<a name="ln1640">    const int compass_idx = _targeting_cmd_to_compass(key_command);</a>
<a name="ln1641">    if (compass_idx != -1)</a>
<a name="ln1642">    {</a>
<a name="ln1643">        const coord_def&amp; delta = Compass[compass_idx];</a>
<a name="ln1644">        const bool unshifted = (shift_direction(key_command) != key_command);</a>
<a name="ln1645">        if (unshifted)</a>
<a name="ln1646">            set_target(target() + delta);</a>
<a name="ln1647">        else</a>
<a name="ln1648">            *loop_done = select_compass_direction(delta);</a>
<a name="ln1649">    }</a>
<a name="ln1650">}</a>
<a name="ln1651"> </a>
<a name="ln1652">void direction_chooser::handle_wizard_command(command_type key_command,</a>
<a name="ln1653">                                              bool* loop_done)</a>
<a name="ln1654">{</a>
<a name="ln1655">#ifdef WIZARD</a>
<a name="ln1656">    if (!you.wizard)</a>
<a name="ln1657">        return;</a>
<a name="ln1658"> </a>
<a name="ln1659">    monster* const m = monster_at(target());</a>
<a name="ln1660">    string marker_result = &quot;&quot;;</a>
<a name="ln1661"> </a>
<a name="ln1662">    // These commands do something even if there's no monster there.</a>
<a name="ln1663">    switch (key_command)</a>
<a name="ln1664">    {</a>
<a name="ln1665">    case CMD_TARGET_WIZARD_MOVE:</a>
<a name="ln1666">        wizard_move_player_or_monster(target());</a>
<a name="ln1667">        *loop_done = true;</a>
<a name="ln1668">        return;</a>
<a name="ln1669"> </a>
<a name="ln1670">    case CMD_TARGET_WIZARD_MISCAST:</a>
<a name="ln1671">        if (m)</a>
<a name="ln1672">            debug_miscast(m-&gt;mindex());</a>
<a name="ln1673">        else if (looking_at_you())</a>
<a name="ln1674">            debug_miscast(NON_MONSTER);</a>
<a name="ln1675">        return;</a>
<a name="ln1676"> </a>
<a name="ln1677">    // Note that this is a wizard-only command.</a>
<a name="ln1678">    case CMD_TARGET_CYCLE_BEAM:</a>
<a name="ln1679">        show_beam = true;</a>
<a name="ln1680">        have_beam = find_ray(you.pos(), target(), beam,</a>
<a name="ln1681">                             opc_solid_see, you.current_vision, show_beam);</a>
<a name="ln1682">        need_viewport_redraw = true;</a>
<a name="ln1683">        return;</a>
<a name="ln1684"> </a>
<a name="ln1685">    case CMD_TARGET_WIZARD_DEBUG_PORTAL:</a>
<a name="ln1686">        mprf(MSGCH_DIAGNOSTICS, &quot;Trying to run portal debug at %d/%d...&quot;,</a>
<a name="ln1687">            target().x, target().y);</a>
<a name="ln1688"> </a>
<a name="ln1689">        marker_result =</a>
<a name="ln1690">            env.markers.property_at(target(), MAT_ANY, &quot;portal_debug&quot;);</a>
<a name="ln1691"> </a>
<a name="ln1692">        mprf(MSGCH_DIAGNOSTICS, &quot;Got result: %s!&quot;,</a>
<a name="ln1693">            marker_result.empty() ? &quot;nothing&quot; : marker_result.c_str());</a>
<a name="ln1694"> </a>
<a name="ln1695">        return;</a>
<a name="ln1696"> </a>
<a name="ln1697">    case CMD_TARGET_WIZARD_HURT_MONSTER:</a>
<a name="ln1698">        if (looking_at_you())</a>
<a name="ln1699">        {</a>
<a name="ln1700">            set_hp(1);</a>
<a name="ln1701">            print_stats();</a>
<a name="ln1702">        }</a>
<a name="ln1703">        break;</a>
<a name="ln1704"> </a>
<a name="ln1705">    case CMD_TARGET_WIZARD_CREATE_MIMIC:</a>
<a name="ln1706">        if (target() != you.pos())</a>
<a name="ln1707">        {</a>
<a name="ln1708">            wizard_create_feature(target());</a>
<a name="ln1709">            need_viewport_redraw = true;</a>
<a name="ln1710">        }</a>
<a name="ln1711">        return;</a>
<a name="ln1712"> </a>
<a name="ln1713">    default:</a>
<a name="ln1714">        break;</a>
<a name="ln1715">    }</a>
<a name="ln1716"> </a>
<a name="ln1717">    // Everything below here doesn't work if there's no monster.</a>
<a name="ln1718">    if (!m)</a>
<a name="ln1719">        return;</a>
<a name="ln1720"> </a>
<a name="ln1721">    const int mid = m-&gt;mindex();</a>
<a name="ln1722"> </a>
<a name="ln1723">    switch (key_command)</a>
<a name="ln1724">    {</a>
<a name="ln1725">    case CMD_TARGET_WIZARD_PATHFIND:      debug_pathfind(mid);      break;</a>
<a name="ln1726">    case CMD_TARGET_WIZARD_DEBUG_MONSTER: debug_stethoscope(mid);   break;</a>
<a name="ln1727">    case CMD_TARGET_WIZARD_MAKE_SHOUT: debug_make_monster_shout(m); break;</a>
<a name="ln1728">    case CMD_TARGET_WIZARD_MAKE_FRIENDLY:</a>
<a name="ln1729">        _wizard_make_friendly(m);</a>
<a name="ln1730">        need_text_redraw = true;</a>
<a name="ln1731">        break;</a>
<a name="ln1732"> </a>
<a name="ln1733">    case CMD_TARGET_WIZARD_GIVE_ITEM:  wizard_give_monster_item(m); break;</a>
<a name="ln1734">    case CMD_TARGET_WIZARD_POLYMORPH:  wizard_polymorph_monster(m); break;</a>
<a name="ln1735"> </a>
<a name="ln1736">    case CMD_TARGET_WIZARD_GAIN_LEVEL:</a>
<a name="ln1737">        wizard_gain_monster_level(m);</a>
<a name="ln1738">        break;</a>
<a name="ln1739"> </a>
<a name="ln1740">    case CMD_TARGET_WIZARD_BLESS_MONSTER:</a>
<a name="ln1741">        wizard_apply_monster_blessing(m);</a>
<a name="ln1742">        break;</a>
<a name="ln1743"> </a>
<a name="ln1744">    case CMD_TARGET_WIZARD_MAKE_SUMMONED:</a>
<a name="ln1745">        wizard_make_monster_summoned(m);</a>
<a name="ln1746">        break;</a>
<a name="ln1747"> </a>
<a name="ln1748">    case CMD_TARGET_WIZARD_HEAL_MONSTER:</a>
<a name="ln1749">        if (m-&gt;hit_points &lt; m-&gt;max_hit_points)</a>
<a name="ln1750">        {</a>
<a name="ln1751">            m-&gt;hit_points = m-&gt;max_hit_points;</a>
<a name="ln1752">            need_all_redraw = true;</a>
<a name="ln1753">        }</a>
<a name="ln1754">        break;</a>
<a name="ln1755"> </a>
<a name="ln1756">    case CMD_TARGET_WIZARD_HURT_MONSTER:</a>
<a name="ln1757">        m-&gt;hit_points = 1;</a>
<a name="ln1758">        mpr(&quot;Brought monster down to 1 HP.&quot;);</a>
<a name="ln1759">        flush_prev_message();</a>
<a name="ln1760">        break;</a>
<a name="ln1761"> </a>
<a name="ln1762">    case CMD_TARGET_WIZARD_BANISH_MONSTER:</a>
<a name="ln1763">        m-&gt;banish(&amp;you, &quot;&quot;, 0, true);</a>
<a name="ln1764">        break;</a>
<a name="ln1765"> </a>
<a name="ln1766">    case CMD_TARGET_WIZARD_KILL_MONSTER:</a>
<a name="ln1767">        monster_die(*m, KILL_YOU, NON_MONSTER);</a>
<a name="ln1768">        break;</a>
<a name="ln1769"> </a>
<a name="ln1770">    default:</a>
<a name="ln1771">        return;</a>
<a name="ln1772">    }</a>
<a name="ln1773">    redraw_screen();</a>
<a name="ln1774">#endif</a>
<a name="ln1775">}</a>
<a name="ln1776"> </a>
<a name="ln1777">void direction_chooser::do_redraws()</a>
<a name="ln1778">{</a>
<a name="ln1779">    if (crawl_state.invisible_targeting)</a>
<a name="ln1780">        return;</a>
<a name="ln1781"> </a>
<a name="ln1782">    // Check if our targeting behaviour forces a redraw.</a>
<a name="ln1783">    if (behaviour-&gt;should_redraw())</a>
<a name="ln1784">    {</a>
<a name="ln1785">        need_all_redraw = true;</a>
<a name="ln1786">        behaviour-&gt;clear_redraw();</a>
<a name="ln1787">    }</a>
<a name="ln1788"> </a>
<a name="ln1789">    if (need_all_redraw)</a>
<a name="ln1790">    {</a>
<a name="ln1791">        need_viewport_redraw = true;</a>
<a name="ln1792">        need_text_redraw = true;</a>
<a name="ln1793">        need_cursor_redraw = true;</a>
<a name="ln1794">        need_all_redraw = false;</a>
<a name="ln1795">    }</a>
<a name="ln1796"> </a>
<a name="ln1797">    if (need_viewport_redraw)</a>
<a name="ln1798">    {</a>
<a name="ln1799">        draw_beam();</a>
<a name="ln1800">        // draw_beam calls viewwindow(true) at least one in tiles mode, and</a>
<a name="ln1801">        // viewwindow(false) at least once in console, so the old highlight and</a>
<a name="ln1802">        // the old beam are both gone here.</a>
<a name="ln1803">        highlight_summoner();</a>
<a name="ln1804">        need_viewport_redraw = false;</a>
<a name="ln1805">    }</a>
<a name="ln1806"> </a>
<a name="ln1807">    if (need_text_redraw)</a>
<a name="ln1808">    {</a>
<a name="ln1809">        msgwin_clear_temporary();</a>
<a name="ln1810">        describe_cell();</a>
<a name="ln1811">        need_text_redraw = false;</a>
<a name="ln1812">        show_items_once = false;</a>
<a name="ln1813">    }</a>
<a name="ln1814"> </a>
<a name="ln1815">    if (need_cursor_redraw || Options.use_fake_cursor)</a>
<a name="ln1816">    {</a>
<a name="ln1817">        cursorxy(crawl_view.grid2screen(target()));</a>
<a name="ln1818">#ifdef USE_TILE_WEB</a>
<a name="ln1819">        // cursorxy doesn't place the cursor in Webtiles, we do it manually here</a>
<a name="ln1820">        // This is by design, since we don't want to use the mouse cursor for</a>
<a name="ln1821">        // the overview map.</a>
<a name="ln1822">        tiles.place_cursor(CURSOR_MOUSE, target());</a>
<a name="ln1823">#endif</a>
<a name="ln1824">        need_cursor_redraw = false;</a>
<a name="ln1825">    }</a>
<a name="ln1826">}</a>
<a name="ln1827"> </a>
<a name="ln1828">coord_def direction_chooser::find_summoner()</a>
<a name="ln1829">{</a>
<a name="ln1830">    const monster* mon = monster_at(target());</a>
<a name="ln1831"> </a>
<a name="ln1832">    // Don't leak information about rakshasa mirrored illusions.</a>
<a name="ln1833">    if (mon &amp;&amp; mon-&gt;is_summoned() &amp;&amp; !mon-&gt;has_ench(ENCH_PHANTOM_MIRROR))</a>
<a name="ln1834">        if (const monster *summ = monster_by_mid(mon-&gt;summoner))</a>
<a name="ln1835">            return summ-&gt;pos();</a>
<a name="ln1836">    return INVALID_COORD;</a>
<a name="ln1837">}</a>
<a name="ln1838"> </a>
<a name="ln1839">void direction_chooser::highlight_summoner()</a>
<a name="ln1840">{</a>
<a name="ln1841">    const coord_def summ_loc = find_summoner();</a>
<a name="ln1842"> </a>
<a name="ln1843">    if (summ_loc == INVALID_COORD || !you.see_cell(summ_loc))</a>
<a name="ln1844">        return;</a>
<a name="ln1845"> </a>
<a name="ln1846">#ifdef USE_TILE</a>
<a name="ln1847">    monster_info* summ_info = env.map_knowledge(summ_loc).monsterinfo();</a>
<a name="ln1848"> </a>
<a name="ln1849">    if (!summ_info)  // Can happen, e. g. if the summoner is invisible</a>
<a name="ln1850">        return;</a>
<a name="ln1851"> </a>
<a name="ln1852">    summ_info-&gt;mb.set(MB_HIGHLIGHTED_SUMMONER);</a>
<a name="ln1853"> </a>
<a name="ln1854">    // The first argument must be false, because otherwise viewwindow would</a>
<a name="ln1855">    // wipe any beams we might have drawn, and also reset the monster_info we</a>
<a name="ln1856">    // just altered, before it draws anything.</a>
<a name="ln1857">    viewwindow(false, true);</a>
<a name="ln1858">#endif</a>
<a name="ln1859">#if defined(USE_TILE_WEB) || !defined(USE_TILE)</a>
<a name="ln1860">    char32_t glych  = get_cell_glyph(summ_loc).ch;</a>
<a name="ln1861">    int col = CYAN;</a>
<a name="ln1862">    col |= COLFLAG_REVERSE;</a>
<a name="ln1863"> </a>
<a name="ln1864">    const coord_def vp = grid2view(summ_loc);</a>
<a name="ln1865">    cgotoxy(vp.x, vp.y, GOTO_DNGN);</a>
<a name="ln1866">    textcolour(real_colour(col));</a>
<a name="ln1867">    putwch(glych);</a>
<a name="ln1868">#endif</a>
<a name="ln1869">}</a>
<a name="ln1870"> </a>
<a name="ln1871">bool direction_chooser::tiles_update_target()</a>
<a name="ln1872">{</a>
<a name="ln1873">#ifdef USE_TILE</a>
<a name="ln1874">    const coord_def&amp; gc = tiles.get_cursor();</a>
<a name="ln1875">    if (gc != NO_CURSOR &amp;&amp; map_bounds(gc))</a>
<a name="ln1876">    {</a>
<a name="ln1877">        set_target(gc);</a>
<a name="ln1878">        return true;</a>
<a name="ln1879">    }</a>
<a name="ln1880">#endif</a>
<a name="ln1881">    return false;</a>
<a name="ln1882">}</a>
<a name="ln1883"> </a>
<a name="ln1884">void direction_chooser::move_to_you()</a>
<a name="ln1885">{</a>
<a name="ln1886">    moves.isValid  = true;</a>
<a name="ln1887">    moves.isTarget = true;</a>
<a name="ln1888">    set_target(you.pos());</a>
<a name="ln1889">    moves.delta.reset();</a>
<a name="ln1890">}</a>
<a name="ln1891"> </a>
<a name="ln1892">void direction_chooser::describe_target()</a>
<a name="ln1893">{</a>
<a name="ln1894">    if (!map_bounds(target()) || !env.map_knowledge(target()).known())</a>
<a name="ln1895">        return;</a>
<a name="ln1896">    full_describe_square(target());</a>
<a name="ln1897">    need_all_redraw = true;</a>
<a name="ln1898">}</a>
<a name="ln1899"> </a>
<a name="ln1900">void direction_chooser::show_help()</a>
<a name="ln1901">{</a>
<a name="ln1902">    show_targeting_help();</a>
<a name="ln1903">    redraw_screen();</a>
<a name="ln1904">    clear_messages(true);</a>
<a name="ln1905">    need_all_redraw = true;</a>
<a name="ln1906">}</a>
<a name="ln1907"> </a>
<a name="ln1908">// Return false if we should continue looping, true if we're done.</a>
<a name="ln1909">bool direction_chooser::do_main_loop()</a>
<a name="ln1910">{</a>
<a name="ln1911">    if (handle_signals())</a>
<a name="ln1912">        return true;</a>
<a name="ln1913"> </a>
<a name="ln1914">    // This needs to be done every loop iteration.</a>
<a name="ln1915">    reinitialize_move_flags();</a>
<a name="ln1916"> </a>
<a name="ln1917">    const coord_def old_target = target();</a>
<a name="ln1918">    const int key = behaviour-&gt;get_key();</a>
<a name="ln1919">    if (key == CK_REDRAW)</a>
<a name="ln1920">    {</a>
<a name="ln1921">        redraw_screen(false);</a>
<a name="ln1922">        return false;</a>
<a name="ln1923">    }</a>
<a name="ln1924"> </a>
<a name="ln1925">    const command_type key_command = behaviour-&gt;get_command(key);</a>
<a name="ln1926">    behaviour-&gt;update_top_prompt(&amp;top_prompt);</a>
<a name="ln1927">    bool loop_done = false;</a>
<a name="ln1928"> </a>
<a name="ln1929">    switch (key_command)</a>
<a name="ln1930">    {</a>
<a name="ln1931">    case CMD_TARGET_SHOW_PROMPT: describe_cell(); break;</a>
<a name="ln1932"> </a>
<a name="ln1933">    case CMD_TARGET_TOGGLE_BEAM:</a>
<a name="ln1934">        if (!just_looking)</a>
<a name="ln1935">            toggle_beam();</a>
<a name="ln1936">        break;</a>
<a name="ln1937"> </a>
<a name="ln1938">    case CMD_TARGET_EXCLUDE:</a>
<a name="ln1939">        if (!just_looking)</a>
<a name="ln1940">            break;</a>
<a name="ln1941"> </a>
<a name="ln1942">        if (!is_map_persistent())</a>
<a name="ln1943">            mpr(&quot;You cannot set exclusions on this level.&quot;);</a>
<a name="ln1944">        else</a>
<a name="ln1945">        {</a>
<a name="ln1946">            const bool was_excluded = is_exclude_root(target());</a>
<a name="ln1947">            cycle_exclude_radius(target());</a>
<a name="ln1948">            need_viewport_redraw   = true;</a>
<a name="ln1949">            const bool is_excluded = is_exclude_root(target());</a>
<a name="ln1950">            if (!was_excluded &amp;&amp; is_excluded)</a>
<a name="ln1951">                mpr(&quot;Placed new exclusion.&quot;);</a>
<a name="ln1952">            else if (was_excluded &amp;&amp; !is_excluded)</a>
<a name="ln1953">                mpr(&quot;Removed exclusion.&quot;);</a>
<a name="ln1954">            else</a>
<a name="ln1955">                mpr(&quot;Reduced exclusion size to a single square.&quot;);</a>
<a name="ln1956">        }</a>
<a name="ln1957"> </a>
<a name="ln1958">        need_cursor_redraw = true;</a>
<a name="ln1959">        break;</a>
<a name="ln1960"> </a>
<a name="ln1961">    case CMD_TARGET_FIND_YOU:       move_to_you(); break;</a>
<a name="ln1962">    case CMD_TARGET_FIND_TRAP:      feature_cycle_forward('^');  break;</a>
<a name="ln1963">    case CMD_TARGET_FIND_PORTAL:    feature_cycle_forward('\\'); break;</a>
<a name="ln1964">    case CMD_TARGET_FIND_ALTAR:     feature_cycle_forward('_');  break;</a>
<a name="ln1965">    case CMD_TARGET_FIND_UPSTAIR:   feature_cycle_forward('&lt;');  break;</a>
<a name="ln1966">    case CMD_TARGET_FIND_DOWNSTAIR: feature_cycle_forward('&gt;');  break;</a>
<a name="ln1967"> </a>
<a name="ln1968">    case CMD_TARGET_MAYBE_PREV_TARGET:</a>
<a name="ln1969">        loop_done = looking_at_you() ? select_previous_target()</a>
<a name="ln1970">                                     : select(false, false);</a>
<a name="ln1971">        break;</a>
<a name="ln1972"> </a>
<a name="ln1973">    case CMD_TARGET_PREV_TARGET: loop_done = select_previous_target(); break;</a>
<a name="ln1974"> </a>
<a name="ln1975">    // some modifiers to the basic selection command</a>
<a name="ln1976">    case CMD_TARGET_SELECT:          loop_done = select(false, false); break;</a>
<a name="ln1977">    case CMD_TARGET_SELECT_FORCE:    loop_done = select(true,  false); break;</a>
<a name="ln1978">    case CMD_TARGET_SELECT_ENDPOINT: loop_done = select(false, true);  break;</a>
<a name="ln1979">    case CMD_TARGET_SELECT_FORCE_ENDPOINT: loop_done = select(true,true); break;</a>
<a name="ln1980"> </a>
<a name="ln1981">#ifdef USE_TILE</a>
<a name="ln1982">    case CMD_TARGET_MOUSE_SELECT:</a>
<a name="ln1983">        if (tiles_update_target())</a>
<a name="ln1984">            loop_done = select(false, false);</a>
<a name="ln1985">        break;</a>
<a name="ln1986"> </a>
<a name="ln1987">    case CMD_TARGET_MOUSE_MOVE: tiles_update_target(); break;</a>
<a name="ln1988">#endif</a>
<a name="ln1989"> </a>
<a name="ln1990">    case CMD_TARGET_GET:             loop_done = pickup_item(); break;</a>
<a name="ln1991"> </a>
<a name="ln1992">    case CMD_TARGET_CYCLE_BACK:</a>
<a name="ln1993">        if (!targets_objects())</a>
<a name="ln1994">        {</a>
<a name="ln1995">            monster_cycle(-1);</a>
<a name="ln1996">            break;</a>
<a name="ln1997">        } // else fall-through</a>
<a name="ln1998">    case CMD_TARGET_OBJ_CYCLE_BACK:    object_cycle(-1);  break;</a>
<a name="ln1999"> </a>
<a name="ln2000">    case CMD_TARGET_CYCLE_FORWARD:</a>
<a name="ln2001">        if (!targets_objects())</a>
<a name="ln2002">        {</a>
<a name="ln2003">            monster_cycle(1);</a>
<a name="ln2004">            break;</a>
<a name="ln2005">        } // else fall-through</a>
<a name="ln2006">    case CMD_TARGET_OBJ_CYCLE_FORWARD: object_cycle(1);  break;</a>
<a name="ln2007"> </a>
<a name="ln2008">    case CMD_TARGET_CANCEL:</a>
<a name="ln2009">        loop_done = true;</a>
<a name="ln2010">        moves.isCancel = true;</a>
<a name="ln2011">        break;</a>
<a name="ln2012"> </a>
<a name="ln2013">    case CMD_TARGET_DESCRIBE: describe_target(); break;</a>
<a name="ln2014">    case CMD_TARGET_HELP:     show_help();       break;</a>
<a name="ln2015"> </a>
<a name="ln2016">    default:</a>
<a name="ln2017">        // Some blocks of keys with similar handling.</a>
<a name="ln2018">        handle_movement_key(key_command, &amp;loop_done);</a>
<a name="ln2019">        handle_wizard_command(key_command, &amp;loop_done);</a>
<a name="ln2020">        break;</a>
<a name="ln2021">    }</a>
<a name="ln2022"> </a>
<a name="ln2023">    // Don't allow going out of bounds.</a>
<a name="ln2024">    if (!crawl_view.in_viewport_g(target()))</a>
<a name="ln2025">        set_target(old_target);</a>
<a name="ln2026"> </a>
<a name="ln2027">    if (loop_done)</a>
<a name="ln2028">    {</a>
<a name="ln2029">        if (just_looking)</a>
<a name="ln2030">            return true;</a>
<a name="ln2031"> </a>
<a name="ln2032">        if (!move_is_ok())</a>
<a name="ln2033">        {</a>
<a name="ln2034">            moves.isCancel = true;</a>
<a name="ln2035">            moves.isValid = false;</a>
<a name="ln2036">        }</a>
<a name="ln2037">        return true;</a>
<a name="ln2038">    }</a>
<a name="ln2039"> </a>
<a name="ln2040">    // Redraw whatever is necessary.</a>
<a name="ln2041">    if (old_target != target())</a>
<a name="ln2042">    {</a>
<a name="ln2043">        have_beam = show_beam &amp;&amp; find_ray(you.pos(), target(), beam,</a>
<a name="ln2044">                                          opc_solid_see, you.current_vision);</a>
<a name="ln2045">        need_text_redraw   = true;</a>
<a name="ln2046">        need_viewport_redraw   = true;</a>
<a name="ln2047">        need_cursor_redraw = true;</a>
<a name="ln2048">    }</a>
<a name="ln2049">    do_redraws();</a>
<a name="ln2050"> </a>
<a name="ln2051">    // We're not done.</a>
<a name="ln2052">    return false;</a>
<a name="ln2053">}</a>
<a name="ln2054"> </a>
<a name="ln2055">void direction_chooser::finalize_moves()</a>
<a name="ln2056">{</a>
<a name="ln2057">    moves.choseRay = have_beam;</a>
<a name="ln2058">    moves.ray = beam;</a>
<a name="ln2059"> </a>
<a name="ln2060">    // We need this for directional explosions, otherwise they'll explode one</a>
<a name="ln2061">    // square away from the player.</a>
<a name="ln2062">    _extend_move_to_edge(moves);</a>
<a name="ln2063"> </a>
<a name="ln2064">#ifdef USE_TILE</a>
<a name="ln2065">    tiles.place_cursor(CURSOR_MOUSE, NO_CURSOR);</a>
<a name="ln2066">#endif</a>
<a name="ln2067">}</a>
<a name="ln2068"> </a>
<a name="ln2069">bool direction_chooser::choose_direction()</a>
<a name="ln2070">{</a>
<a name="ln2071">#ifdef USE_TILE</a>
<a name="ln2072">    ui::cutoff_point ui_cutoff_point;</a>
<a name="ln2073">#endif</a>
<a name="ln2074"> </a>
<a name="ln2075">    if (restricts == DIR_DIR)</a>
<a name="ln2076">        return choose_compass();</a>
<a name="ln2077"> </a>
<a name="ln2078">    cursor_control ccon(!Options.use_fake_cursor);</a>
<a name="ln2079">    mouse_control mc(needs_path &amp;&amp; !just_looking ? MOUSE_MODE_TARGET_PATH</a>
<a name="ln2080">                                                 : MOUSE_MODE_TARGET);</a>
<a name="ln2081">    targeter_smite legacy_range(&amp;you, range, 0, 0, true);</a>
<a name="ln2082">    range_view_annotator rva(hitfunc ? hitfunc :</a>
<a name="ln2083">                             (range &gt;= 0) ? &amp;legacy_range : nullptr);</a>
<a name="ln2084"> </a>
<a name="ln2085">    // init</a>
<a name="ln2086">    moves.delta.reset();</a>
<a name="ln2087"> </a>
<a name="ln2088">    // Find a default target.</a>
<a name="ln2089">    set_target(!default_place.origin() ? default_place</a>
<a name="ln2090">                                       : find_default_target());</a>
<a name="ln2091"> </a>
<a name="ln2092">    objfind_pos = monsfind_pos = target();</a>
<a name="ln2093"> </a>
<a name="ln2094">    // If requested, show the beam on startup.</a>
<a name="ln2095">    if (show_beam)</a>
<a name="ln2096">    {</a>
<a name="ln2097">        have_beam = find_ray(you.pos(), target(), beam,</a>
<a name="ln2098">                             opc_solid_see, you.current_vision);</a>
<a name="ln2099">        need_viewport_redraw = have_beam;</a>
<a name="ln2100">    }</a>
<a name="ln2101">    if (hitfunc)</a>
<a name="ln2102">        need_viewport_redraw = true;</a>
<a name="ln2103"> </a>
<a name="ln2104">    clear_messages();</a>
<a name="ln2105">    msgwin_set_temporary(true);</a>
<a name="ln2106">    unwind_bool save_more(crawl_state.show_more_prompt, false);</a>
<a name="ln2107">    show_initial_prompt();</a>
<a name="ln2108">    need_text_redraw = false;</a>
<a name="ln2109"> </a>
<a name="ln2110">    do_redraws();</a>
<a name="ln2111"> </a>
<a name="ln2112">    while (!do_main_loop())</a>
<a name="ln2113">        ;</a>
<a name="ln2114"> </a>
<a name="ln2115">    msgwin_set_temporary(false);</a>
<a name="ln2116">    finalize_moves();</a>
<a name="ln2117">    return moves.isValid;</a>
<a name="ln2118">}</a>
<a name="ln2119"> </a>
<a name="ln2120">string get_terse_square_desc(const coord_def &amp;gc)</a>
<a name="ln2121">{</a>
<a name="ln2122">    string desc = &quot;&quot;;</a>
<a name="ln2123">    const char *unseen_desc = &quot;[unseen terrain]&quot;;</a>
<a name="ln2124"> </a>
<a name="ln2125">    if (gc == you.pos())</a>
<a name="ln2126">        desc = you.your_name;</a>
<a name="ln2127">    else if (!map_bounds(gc))</a>
<a name="ln2128">        desc = unseen_desc;</a>
<a name="ln2129">    else if (!you.see_cell(gc))</a>
<a name="ln2130">    {</a>
<a name="ln2131">        if (env.map_knowledge(gc).seen())</a>
<a name="ln2132">        {</a>
<a name="ln2133">            desc = &quot;[&quot; + feature_description_at(gc, false, DESC_PLAIN)</a>
<a name="ln2134">                       + &quot;]&quot;;</a>
<a name="ln2135">        }</a>
<a name="ln2136">        else</a>
<a name="ln2137">            desc = unseen_desc;</a>
<a name="ln2138">    }</a>
<a name="ln2139">    else if (monster_at(gc) &amp;&amp; you.can_see(*monster_at(gc)))</a>
<a name="ln2140">            desc = monster_at(gc)-&gt;full_name(DESC_PLAIN);</a>
<a name="ln2141">    else if (you.visible_igrd(gc) != NON_ITEM)</a>
<a name="ln2142">    {</a>
<a name="ln2143">        if (mitm[you.visible_igrd(gc)].defined())</a>
<a name="ln2144">            desc = mitm[you.visible_igrd(gc)].name(DESC_PLAIN);</a>
<a name="ln2145">    }</a>
<a name="ln2146">    else</a>
<a name="ln2147">        desc = feature_description_at(gc, false, DESC_PLAIN);</a>
<a name="ln2148"> </a>
<a name="ln2149">    return desc;</a>
<a name="ln2150">}</a>
<a name="ln2151"> </a>
<a name="ln2152">void terse_describe_square(const coord_def &amp;c, bool in_range)</a>
<a name="ln2153">{</a>
<a name="ln2154">    if (!you.see_cell(c))</a>
<a name="ln2155">        _describe_oos_square(c);</a>
<a name="ln2156">    else if (in_bounds(c))</a>
<a name="ln2157">        _describe_cell(c, in_range);</a>
<a name="ln2158">}</a>
<a name="ln2159"> </a>
<a name="ln2160">void get_square_desc(const coord_def &amp;c, describe_info &amp;inf)</a>
<a name="ln2161">{</a>
<a name="ln2162">    // NOTE: Keep this function in sync with full_describe_square.</a>
<a name="ln2163"> </a>
<a name="ln2164">    const dungeon_feature_type feat = env.map_knowledge(c).feat();</a>
<a name="ln2165">    const cloud_type cloud = env.map_knowledge(c).cloud();</a>
<a name="ln2166"> </a>
<a name="ln2167">    if (const monster_info *mi = env.map_knowledge(c).monsterinfo())</a>
<a name="ln2168">    {</a>
<a name="ln2169">        // First priority: monsters.</a>
<a name="ln2170">        string desc = uppercase_first(get_monster_equipment_desc(*mi))</a>
<a name="ln2171">                    + &quot;.\n&quot;;</a>
<a name="ln2172">        const string wounds = mi-&gt;wounds_description_sentence();</a>
<a name="ln2173">        if (!wounds.empty())</a>
<a name="ln2174">            desc += uppercase_first(wounds) + &quot;\n&quot;;</a>
<a name="ln2175">        const string constrictions = mi-&gt;constriction_description();</a>
<a name="ln2176">        if (!constrictions.empty())</a>
<a name="ln2177">            desc += &quot;It is &quot; + constrictions + &quot;.\n&quot;;</a>
<a name="ln2178">        desc += _get_monster_desc(*mi);</a>
<a name="ln2179"> </a>
<a name="ln2180">        inf.title = desc;</a>
<a name="ln2181"> </a>
<a name="ln2182">        bool temp = false;</a>
<a name="ln2183">        get_monster_db_desc(*mi, inf, temp);</a>
<a name="ln2184">    }</a>
<a name="ln2185">    else if (const item_info *obj = env.map_knowledge(c).item())</a>
<a name="ln2186">    {</a>
<a name="ln2187">        // Second priority: objects.</a>
<a name="ln2188">        get_item_desc(*obj, inf);</a>
<a name="ln2189">    }</a>
<a name="ln2190">    else if (feat != DNGN_UNSEEN &amp;&amp; feat != DNGN_FLOOR</a>
<a name="ln2191">             &amp;&amp; !feat_is_wall(feat) &amp;&amp; !feat_is_tree(feat))</a>
<a name="ln2192">    {</a>
<a name="ln2193">        // Third priority: features.</a>
<a name="ln2194">        get_feature_desc(c, inf);</a>
<a name="ln2195">    }</a>
<a name="ln2196">    else // Fourth priority: clouds.</a>
<a name="ln2197">        inf.body &lt;&lt; get_cloud_desc(cloud);</a>
<a name="ln2198">}</a>
<a name="ln2199"> </a>
<a name="ln2200">void full_describe_square(const coord_def &amp;c, bool cleanup)</a>
<a name="ln2201">{</a>
<a name="ln2202">    // NOTE: Keep this function in sync with get_square_desc.</a>
<a name="ln2203"> </a>
<a name="ln2204">    if (const monster_info *mi = env.map_knowledge(c).monsterinfo())</a>
<a name="ln2205">    {</a>
<a name="ln2206">        // First priority: monsters.</a>
<a name="ln2207">        describe_monsters(*mi);</a>
<a name="ln2208">    }</a>
<a name="ln2209">    else if (item_info *obj = env.map_knowledge(c).item())</a>
<a name="ln2210">    {</a>
<a name="ln2211">        // Second priority: objects.</a>
<a name="ln2212">        describe_item(*obj);</a>
<a name="ln2213">    }</a>
<a name="ln2214">    else</a>
<a name="ln2215">    {</a>
<a name="ln2216">        // Third priority: features.</a>
<a name="ln2217">        describe_feature_wide(c);</a>
<a name="ln2218">    }</a>
<a name="ln2219"> </a>
<a name="ln2220">    if (cleanup)</a>
<a name="ln2221">    {</a>
<a name="ln2222">        redraw_screen();</a>
<a name="ln2223">        clear_messages();</a>
<a name="ln2224">    }</a>
<a name="ln2225">}</a>
<a name="ln2226"> </a>
<a name="ln2227">static void _extend_move_to_edge(dist &amp;moves)</a>
<a name="ln2228">{</a>
<a name="ln2229">    if (moves.delta.origin())</a>
<a name="ln2230">        return;</a>
<a name="ln2231"> </a>
<a name="ln2232">    // Now the tricky bit - extend the target x,y out to map edge.</a>
<a name="ln2233">    int mx = 0, my = 0;</a>
<a name="ln2234"> </a>
<a name="ln2235">    if (moves.delta.x &gt; 0)</a>
<a name="ln2236">        mx = (GXM - 1) - you.pos().x;</a>
<a name="ln2237">    if (moves.delta.x &lt; 0)</a>
<a name="ln2238">        mx = you.pos().x;</a>
<a name="ln2239"> </a>
<a name="ln2240">    if (moves.delta.y &gt; 0)</a>
<a name="ln2241">        my = (GYM - 1) - you.pos().y;</a>
<a name="ln2242">    if (moves.delta.y &lt; 0)</a>
<a name="ln2243">        my = you.pos().y;</a>
<a name="ln2244"> </a>
<a name="ln2245">    if (mx != 0 &amp;&amp; my != 0)</a>
<a name="ln2246">        mx = my = min(mx, my);</a>
<a name="ln2247"> </a>
<a name="ln2248">    moves.target.x = you.pos().x + moves.delta.x * mx;</a>
<a name="ln2249">    moves.target.y = you.pos().y + moves.delta.y * my;</a>
<a name="ln2250">}</a>
<a name="ln2251"> </a>
<a name="ln2252">// Attempts to describe a square that's not in line-of-sight. If</a>
<a name="ln2253">// there's a stash on the square, announces the top item and number</a>
<a name="ln2254">// of items, otherwise, if there's a stair that's in the travel</a>
<a name="ln2255">// cache and noted in the Dungeon (O)verview, names the stair.</a>
<a name="ln2256">static void _describe_oos_square(const coord_def&amp; where)</a>
<a name="ln2257">{</a>
<a name="ln2258">    mprf(MSGCH_EXAMINE_FILTER, &quot;You can't see that place.&quot;);</a>
<a name="ln2259"> </a>
<a name="ln2260">    if (!in_bounds(where) || !env.map_knowledge(where).seen())</a>
<a name="ln2261">    {</a>
<a name="ln2262">#ifdef DEBUG_DIAGNOSTICS</a>
<a name="ln2263">        if (!in_bounds(where))</a>
<a name="ln2264">            dprf(&quot;(out of bounds)&quot;);</a>
<a name="ln2265">        else</a>
<a name="ln2266">            dprf(&quot;(map: %x)&quot;, env.map_knowledge(where).flags);</a>
<a name="ln2267">#endif</a>
<a name="ln2268">        return;</a>
<a name="ln2269">    }</a>
<a name="ln2270"> </a>
<a name="ln2271">    describe_stash(where);</a>
<a name="ln2272">    _describe_oos_feature(where);</a>
<a name="ln2273">#ifdef DEBUG_DIAGNOSTICS</a>
<a name="ln2274">    _debug_describe_feature_at(where);</a>
<a name="ln2275">#endif</a>
<a name="ln2276">}</a>
<a name="ln2277"> </a>
<a name="ln2278">static bool _mons_is_valid_target(const monster* mon, targ_mode_type mode,</a>
<a name="ln2279">                                  int range)</a>
<a name="ln2280">{</a>
<a name="ln2281">    // Monsters that are no threat to you don't count as monsters.</a>
<a name="ln2282">    if (!mons_is_threatening(*mon))</a>
<a name="ln2283">        return false;</a>
<a name="ln2284"> </a>
<a name="ln2285">    // Don't target submerged monsters.</a>
<a name="ln2286">    if (mode != TARG_HOSTILE_SUBMERGED &amp;&amp; mon-&gt;submerged())</a>
<a name="ln2287">        return false;</a>
<a name="ln2288"> </a>
<a name="ln2289">    // Don't usually target unseen monsters...</a>
<a name="ln2290">    if (!mon-&gt;visible_to(&amp;you))</a>
<a name="ln2291">    {</a>
<a name="ln2292">        // ...unless it creates a &quot;disturbance in the water&quot;.</a>
<a name="ln2293">        // Since you can't see the monster, assume it's not a friend.</a>
<a name="ln2294">        return mode != TARG_FRIEND</a>
<a name="ln2295">               &amp;&amp; _mon_exposed(mon)</a>
<a name="ln2296">               &amp;&amp; i_feel_safe(false, false, true, true, range);</a>
<a name="ln2297">    }</a>
<a name="ln2298"> </a>
<a name="ln2299">    return true;</a>
<a name="ln2300">}</a>
<a name="ln2301"> </a>
<a name="ln2302">static bool _want_target_monster(const monster *mon, targ_mode_type mode,</a>
<a name="ln2303">                                 targeter* hitfunc)</a>
<a name="ln2304">{</a>
<a name="ln2305">    if (hitfunc &amp;&amp; !hitfunc-&gt;affects_monster(monster_info(mon)))</a>
<a name="ln2306">        return false;</a>
<a name="ln2307">    switch (mode)</a>
<a name="ln2308">    {</a>
<a name="ln2309">    case TARG_ANY:</a>
<a name="ln2310">        return true;</a>
<a name="ln2311">    case TARG_HOSTILE:</a>
<a name="ln2312">    case TARG_HOSTILE_SUBMERGED:</a>
<a name="ln2313">        return mons_attitude(*mon) == ATT_HOSTILE;</a>
<a name="ln2314">    case TARG_FRIEND:</a>
<a name="ln2315">        return mon-&gt;friendly();</a>
<a name="ln2316">    case TARG_INJURED_FRIEND:</a>
<a name="ln2317">        if (mon-&gt;friendly() &amp;&amp; mons_get_damage_level(*mon) &gt; MDAM_OKAY)</a>
<a name="ln2318">            return true;</a>
<a name="ln2319">        return !mon-&gt;wont_attack() &amp;&amp; !mon-&gt;neutral()</a>
<a name="ln2320">            &amp;&amp; unpacifiable_reason(*mon).empty();</a>
<a name="ln2321">    case TARG_BEOGH_GIFTABLE:</a>
<a name="ln2322">        return beogh_can_gift_items_to(mon);</a>
<a name="ln2323">    case TARG_MOVABLE_OBJECT:</a>
<a name="ln2324">        return false;</a>
<a name="ln2325">    case TARG_MOBILE_MONSTER:</a>
<a name="ln2326">        return !(mons_is_tentacle_or_tentacle_segment(mon-&gt;type)</a>
<a name="ln2327">                 || mon-&gt;is_stationary());</a>
<a name="ln2328">    case TARG_NUM_MODES:</a>
<a name="ln2329">        break;</a>
<a name="ln2330">    // intentionally no default</a>
<a name="ln2331">    }</a>
<a name="ln2332">    die(&quot;Unknown targeting mode!&quot;);</a>
<a name="ln2333">}</a>
<a name="ln2334"> </a>
<a name="ln2335">#ifdef CLUA_BINDINGS</a>
<a name="ln2336">static bool _tobool(maybe_bool mb)</a>
<a name="ln2337">{</a>
<a name="ln2338">    ASSERT(mb != MB_MAYBE);</a>
<a name="ln2339">    return mb == MB_TRUE;</a>
<a name="ln2340">}</a>
<a name="ln2341">#endif</a>
<a name="ln2342"> </a>
<a name="ln2343">static bool _find_monster(const coord_def&amp; where, targ_mode_type mode,</a>
<a name="ln2344">                          bool need_path, int range, targeter *hitfunc)</a>
<a name="ln2345">{</a>
<a name="ln2346">#ifdef CLUA_BINDINGS</a>
<a name="ln2347">    {</a>
<a name="ln2348">        coord_def dp = grid2player(where);</a>
<a name="ln2349">        // We could pass more info here.</a>
<a name="ln2350">        maybe_bool x = clua.callmbooleanfn(&quot;ch_target_monster&quot;, &quot;dd&quot;,</a>
<a name="ln2351">                                           dp.x, dp.y);</a>
<a name="ln2352">        if (x != MB_MAYBE)</a>
<a name="ln2353">            return _tobool(x);</a>
<a name="ln2354">    }</a>
<a name="ln2355">#endif</a>
<a name="ln2356"> </a>
<a name="ln2357">    // Target the player for friendly and general spells.</a>
<a name="ln2358">    if ((mode == TARG_FRIEND || mode == TARG_ANY) &amp;&amp; where == you.pos())</a>
<a name="ln2359">        return true;</a>
<a name="ln2360"> </a>
<a name="ln2361">    // Don't target out of range</a>
<a name="ln2362">    if (!_is_target_in_range(where, range, hitfunc))</a>
<a name="ln2363">        return false;</a>
<a name="ln2364"> </a>
<a name="ln2365">    const monster* mon = monster_at(where);</a>
<a name="ln2366"> </a>
<a name="ln2367">    // No monster or outside LOS.</a>
<a name="ln2368">    if (!mon || !cell_see_cell(you.pos(), where, LOS_DEFAULT))</a>
<a name="ln2369">        return false;</a>
<a name="ln2370"> </a>
<a name="ln2371">    // Monster in LOS but only via glass walls, so no direct path.</a>
<a name="ln2372">    if (!you.see_cell_no_trans(where))</a>
<a name="ln2373">        return false;</a>
<a name="ln2374"> </a>
<a name="ln2375">    if (!_mons_is_valid_target(mon, mode, range))</a>
<a name="ln2376">        return false;</a>
<a name="ln2377"> </a>
<a name="ln2378">    if (need_path &amp;&amp; _blocked_ray(mon-&gt;pos()))</a>
<a name="ln2379">        return false;</a>
<a name="ln2380"> </a>
<a name="ln2381">    return _want_target_monster(mon, mode, hitfunc);</a>
<a name="ln2382">}</a>
<a name="ln2383"> </a>
<a name="ln2384">static bool _find_shadow_step_mons(const coord_def&amp; where, targ_mode_type mode,</a>
<a name="ln2385">                                   bool need_path, int range,</a>
<a name="ln2386">                                   targeter *hitfunc)</a>
<a name="ln2387">{</a>
<a name="ln2388">#ifdef CLUA_BINDINGS</a>
<a name="ln2389">    {</a>
<a name="ln2390">        coord_def dp = grid2player(where);</a>
<a name="ln2391">        // We could pass more info here.</a>
<a name="ln2392">        maybe_bool x = clua.callmbooleanfn(&quot;ch_target_shadow_step&quot;, &quot;dd&quot;,</a>
<a name="ln2393">                                           dp.x, dp.y);</a>
<a name="ln2394">        if (x != MB_MAYBE)</a>
<a name="ln2395">            return _tobool(x);</a>
<a name="ln2396">    }</a>
<a name="ln2397">#endif</a>
<a name="ln2398"> </a>
<a name="ln2399">    // Need a monster to attack; this checks that the monster is a valid target.</a>
<a name="ln2400">    if (!_find_monster(where, mode, need_path, range, hitfunc))</a>
<a name="ln2401">        return false;</a>
<a name="ln2402">    // Can't step on yourself</a>
<a name="ln2403">    if (where == you.pos())</a>
<a name="ln2404">        return false;</a>
<a name="ln2405"> </a>
<a name="ln2406">    return hitfunc-&gt;has_additional_sites(where);</a>
<a name="ln2407">}</a>
<a name="ln2408"> </a>
<a name="ln2409">static bool _find_monster_expl(const coord_def&amp; where, targ_mode_type mode,</a>
<a name="ln2410">                               bool need_path, int range, targeter *hitfunc,</a>
<a name="ln2411">                               aff_type mon_aff, aff_type allowed_self_aff)</a>
<a name="ln2412">{</a>
<a name="ln2413">    ASSERT(hitfunc);</a>
<a name="ln2414"> </a>
<a name="ln2415">#ifdef CLUA_BINDINGS</a>
<a name="ln2416">    {</a>
<a name="ln2417">        coord_def dp = grid2player(where);</a>
<a name="ln2418">        // We could pass more info here.</a>
<a name="ln2419">        maybe_bool x = clua.callmbooleanfn(&quot;ch_target_monster_expl&quot;, &quot;dd&quot;,</a>
<a name="ln2420">                                           dp.x, dp.y);</a>
<a name="ln2421">        if (x != MB_MAYBE)</a>
<a name="ln2422">            return _tobool(x);</a>
<a name="ln2423">    }</a>
<a name="ln2424">#endif</a>
<a name="ln2425"> </a>
<a name="ln2426">    if (!hitfunc-&gt;valid_aim(where))</a>
<a name="ln2427">        return false;</a>
<a name="ln2428"> </a>
<a name="ln2429">    // Target is blocked by something</a>
<a name="ln2430">    if (need_path &amp;&amp; _blocked_ray(where))</a>
<a name="ln2431">        return false;</a>
<a name="ln2432"> </a>
<a name="ln2433">    if (hitfunc-&gt;set_aim(where))</a>
<a name="ln2434">    {</a>
<a name="ln2435">        if (hitfunc-&gt;is_affected(you.pos()) &gt; allowed_self_aff)</a>
<a name="ln2436">            return false;</a>
<a name="ln2437">        for (monster_near_iterator mi(&amp;you); mi; ++mi)</a>
<a name="ln2438">        {</a>
<a name="ln2439">            if (hitfunc-&gt;is_affected(mi-&gt;pos()) == mon_aff</a>
<a name="ln2440">                &amp;&amp; _mons_is_valid_target(*mi, mode, range)</a>
<a name="ln2441">                &amp;&amp; _want_target_monster(*mi, mode, hitfunc))</a>
<a name="ln2442">            {</a>
<a name="ln2443">                    return true;</a>
<a name="ln2444">            }</a>
<a name="ln2445">        }</a>
<a name="ln2446">    }</a>
<a name="ln2447">    return false;</a>
<a name="ln2448">}</a>
<a name="ln2449"> </a>
<a name="ln2450">static const item_def* _item_at(const coord_def &amp;where)</a>
<a name="ln2451">{</a>
<a name="ln2452">    // XXX: are we ever interacting with unseen items, anyway?</a>
<a name="ln2453">    return you.see_cell(where)</a>
<a name="ln2454">            ? top_item_at(where)</a>
<a name="ln2455">            : env.map_knowledge(where).item();</a>
<a name="ln2456">}</a>
<a name="ln2457"> </a>
<a name="ln2458">static bool _find_autopickup_object(const coord_def&amp; where, bool need_path,</a>
<a name="ln2459">                                    int range, targeter *hitfunc)</a>
<a name="ln2460">{</a>
<a name="ln2461">    if (!_find_object(where, need_path, range, hitfunc))</a>
<a name="ln2462">        return false;</a>
<a name="ln2463"> </a>
<a name="ln2464">    const item_def * const item = _item_at(where);</a>
<a name="ln2465">    ASSERT(item);</a>
<a name="ln2466">    return item_needs_autopickup(*item);</a>
<a name="ln2467">}</a>
<a name="ln2468"> </a>
<a name="ln2469">static bool _find_object(const coord_def&amp; where, bool need_path, int range,</a>
<a name="ln2470">                         targeter *hitfunc)</a>
<a name="ln2471">{</a>
<a name="ln2472">    // Don't target out of range.</a>
<a name="ln2473">    if (!_is_target_in_range(where, range, hitfunc))</a>
<a name="ln2474">        return false;</a>
<a name="ln2475"> </a>
<a name="ln2476">    if (need_path &amp;&amp; (!you.see_cell(where) || _blocked_ray(where)))</a>
<a name="ln2477">        return false;</a>
<a name="ln2478"> </a>
<a name="ln2479">    const item_def * const item = _item_at(where);</a>
<a name="ln2480">    return item &amp;&amp; !item_is_stationary(*item);</a>
<a name="ln2481">}</a>
<a name="ln2482"> </a>
<a name="ln2483">static int _next_los(int dir, int los, bool wrap)</a>
<a name="ln2484">{</a>
<a name="ln2485">    if (los == LS_ANY)</a>
<a name="ln2486">        return wrap? los : LS_NONE;</a>
<a name="ln2487"> </a>
<a name="ln2488">    bool vis    = los &amp; LS_VISIBLE;</a>
<a name="ln2489">    bool hidden = los &amp; LS_HIDDEN;</a>
<a name="ln2490">    bool flipvh = los &amp; LS_FLIPVH;</a>
<a name="ln2491">    bool fliphv = los &amp; LS_FLIPHV;</a>
<a name="ln2492"> </a>
<a name="ln2493">    if (!vis &amp;&amp; !hidden)</a>
<a name="ln2494">        vis = true;</a>
<a name="ln2495"> </a>
<a name="ln2496">    if (wrap)</a>
<a name="ln2497">    {</a>
<a name="ln2498">        if (!flipvh &amp;&amp; !fliphv)</a>
<a name="ln2499">            return los;</a>
<a name="ln2500"> </a>
<a name="ln2501">        // We have to invert flipvh and fliphv if we're wrapping. Here's</a>
<a name="ln2502">        // why:</a>
<a name="ln2503">        //</a>
<a name="ln2504">        //  * Say the cursor is on the last item in LOS, there are no</a>
<a name="ln2505">        //    items outside LOS, and wrap == true. flipvh is true.</a>
<a name="ln2506">        //  * We set wrap false and flip from visible to hidden, but there</a>
<a name="ln2507">        //    are no hidden items. So now we need to flip back to visible</a>
<a name="ln2508">        //    so we can go back to the first item in LOS. Unless we set</a>
<a name="ln2509">        //    fliphv, we can't flip from hidden to visible.</a>
<a name="ln2510">        //</a>
<a name="ln2511">        los = flipvh ? LS_FLIPHV : LS_FLIPVH;</a>
<a name="ln2512">    }</a>
<a name="ln2513">    else</a>
<a name="ln2514">    {</a>
<a name="ln2515">        if (!flipvh &amp;&amp; !fliphv)</a>
<a name="ln2516">            return LS_NONE;</a>
<a name="ln2517"> </a>
<a name="ln2518">        if (flipvh &amp;&amp; vis != (dir == 1))</a>
<a name="ln2519">            return LS_NONE;</a>
<a name="ln2520"> </a>
<a name="ln2521">        if (fliphv &amp;&amp; vis == (dir == 1))</a>
<a name="ln2522">            return LS_NONE;</a>
<a name="ln2523">    }</a>
<a name="ln2524"> </a>
<a name="ln2525">    return (los &amp; ~LS_VISMASK) | (vis ? LS_HIDDEN : LS_VISIBLE);</a>
<a name="ln2526">}</a>
<a name="ln2527"> </a>
<a name="ln2528">//---------------------------------------------------------------</a>
<a name="ln2529">//</a>
<a name="ln2530">// find_square</a>
<a name="ln2531">//</a>
<a name="ln2532">// Finds the next monster/object/whatever (moving in a spiral</a>
<a name="ln2533">// outwards from the player, so closer targets are chosen first;</a>
<a name="ln2534">// starts to player's left) and puts its coordinates in mfp.</a>
<a name="ln2535">// Returns 1 if it found something, zero otherwise. If direction</a>
<a name="ln2536">// is -1, goes backwards.</a>
<a name="ln2537">//</a>
<a name="ln2538">//---------------------------------------------------------------</a>
<a name="ln2539">static bool _find_square(coord_def &amp;mfp, int direction,</a>
<a name="ln2540">                         target_checker find_targ, targeter *hitfunc,</a>
<a name="ln2541">                         bool wrap, int los)</a>
<a name="ln2542">{</a>
<a name="ln2543">    int temp_xps = mfp.x;</a>
<a name="ln2544">    int temp_yps = mfp.y;</a>
<a name="ln2545">    int x_change = 0;</a>
<a name="ln2546">    int y_change = 0;</a>
<a name="ln2547"> </a>
<a name="ln2548">    bool onlyVis = false, onlyHidden = false;</a>
<a name="ln2549"> </a>
<a name="ln2550">    int i, j;</a>
<a name="ln2551"> </a>
<a name="ln2552">    if (los == LS_NONE)</a>
<a name="ln2553">        return false;</a>
<a name="ln2554"> </a>
<a name="ln2555">    if (los == LS_FLIPVH || los == LS_FLIPHV)</a>
<a name="ln2556">    {</a>
<a name="ln2557">        if (in_los_bounds_v(mfp))</a>
<a name="ln2558">        {</a>
<a name="ln2559">            // We've been told to flip between visible/hidden, so we</a>
<a name="ln2560">            // need to find what we're currently on.</a>
<a name="ln2561">            const bool vis = you.see_cell(view2grid(mfp));</a>
<a name="ln2562"> </a>
<a name="ln2563">            if (wrap &amp;&amp; (vis != (los == LS_FLIPVH)) == (direction == 1))</a>
<a name="ln2564">            {</a>
<a name="ln2565">                // We've already flipped over into the other direction,</a>
<a name="ln2566">                // so correct the flip direction if we're wrapping.</a>
<a name="ln2567">                los = (los == LS_FLIPHV ? LS_FLIPVH : LS_FLIPHV);</a>
<a name="ln2568">            }</a>
<a name="ln2569"> </a>
<a name="ln2570">            los = (los &amp; ~LS_VISMASK) | (vis ? LS_VISIBLE : LS_HIDDEN);</a>
<a name="ln2571">        }</a>
<a name="ln2572">        else</a>
<a name="ln2573">        {</a>
<a name="ln2574">            if (wrap)</a>
<a name="ln2575">                los = LS_HIDDEN | (direction &gt; 0 ? LS_FLIPHV : LS_FLIPVH);</a>
<a name="ln2576">            else</a>
<a name="ln2577">                los |= LS_HIDDEN;</a>
<a name="ln2578">        }</a>
<a name="ln2579">    }</a>
<a name="ln2580"> </a>
<a name="ln2581">    onlyVis     = (los &amp; LS_VISIBLE);</a>
<a name="ln2582">    onlyHidden  = (los &amp; LS_HIDDEN);</a>
<a name="ln2583"> </a>
<a name="ln2584">    int radius = 0;</a>
<a name="ln2585">    if (crawl_view.viewsz.x &gt; crawl_view.viewsz.y)</a>
<a name="ln2586">        radius = crawl_view.viewsz.x - LOS_RADIUS - 1;</a>
<a name="ln2587">    else</a>
<a name="ln2588">        radius = crawl_view.viewsz.y - LOS_RADIUS - 1;</a>
<a name="ln2589"> </a>
<a name="ln2590">    const coord_def vyou = grid2view(you.pos());</a>
<a name="ln2591"> </a>
<a name="ln2592">    const int minx = vyou.x - radius, maxx = vyou.x + radius,</a>
<a name="ln2593">              miny = vyou.y - radius, maxy = vyou.y + radius,</a>
<a name="ln2594">              ctrx = vyou.x, ctry = vyou.y;</a>
<a name="ln2595"> </a>
<a name="ln2596">    while (temp_xps &gt;= minx - 1 &amp;&amp; temp_xps &lt;= maxx</a>
<a name="ln2597">           &amp;&amp; temp_yps &lt;= maxy &amp;&amp; temp_yps &gt;= miny - 1)</a>
<a name="ln2598">    {</a>
<a name="ln2599">        if (direction == 1 &amp;&amp; temp_xps == minx &amp;&amp; temp_yps == maxy)</a>
<a name="ln2600">        {</a>
<a name="ln2601">            mfp = vyou;</a>
<a name="ln2602">            if (find_targ(you.pos()))</a>
<a name="ln2603">                return true;</a>
<a name="ln2604">            return _find_square(mfp, direction,</a>
<a name="ln2605">                                find_targ, hitfunc,</a>
<a name="ln2606">                                false, _next_los(direction, los, wrap));</a>
<a name="ln2607">        }</a>
<a name="ln2608">        if (direction == -1 &amp;&amp; temp_xps == ctrx &amp;&amp; temp_yps == ctry)</a>
<a name="ln2609">        {</a>
<a name="ln2610">            mfp = coord_def(minx, maxy);</a>
<a name="ln2611">            return _find_square(mfp, direction,</a>
<a name="ln2612">                                find_targ, hitfunc,</a>
<a name="ln2613">                                false, _next_los(direction, los, wrap));</a>
<a name="ln2614">        }</a>
<a name="ln2615"> </a>
<a name="ln2616">        if (direction == 1)</a>
<a name="ln2617">        {</a>
<a name="ln2618">            if (temp_xps == minx - 1)</a>
<a name="ln2619">            {</a>
<a name="ln2620">                x_change = 0;</a>
<a name="ln2621">                y_change = -1;</a>
<a name="ln2622">            }</a>
<a name="ln2623">            else if (temp_xps == ctrx &amp;&amp; temp_yps == ctry)</a>
<a name="ln2624">            {</a>
<a name="ln2625">                x_change = -1;</a>
<a name="ln2626">                y_change = 0;</a>
<a name="ln2627">            }</a>
<a name="ln2628">            else if (abs(temp_xps - ctrx) &lt;= abs(temp_yps - ctry))</a>
<a name="ln2629">            {</a>
<a name="ln2630">                if (temp_xps - ctrx &gt;= 0 &amp;&amp; temp_yps - ctry &lt;= 0)</a>
<a name="ln2631">                {</a>
<a name="ln2632">                    if (abs(temp_xps - ctrx) &gt; abs(temp_yps - ctry + 1))</a>
<a name="ln2633">                    {</a>
<a name="ln2634">                        x_change = 0;</a>
<a name="ln2635">                        y_change = -1;</a>
<a name="ln2636">                        if (temp_xps - ctrx &gt; 0)</a>
<a name="ln2637">                            y_change = 1;</a>
<a name="ln2638">                        goto finished_spiralling;</a>
<a name="ln2639">                    }</a>
<a name="ln2640">                }</a>
<a name="ln2641">                x_change = -1;</a>
<a name="ln2642">                if (temp_yps - ctry &lt; 0)</a>
<a name="ln2643">                    x_change = 1;</a>
<a name="ln2644">                y_change = 0;</a>
<a name="ln2645">            }</a>
<a name="ln2646">            else</a>
<a name="ln2647">            {</a>
<a name="ln2648">                x_change = 0;</a>
<a name="ln2649">                y_change = -1;</a>
<a name="ln2650">                if (temp_xps - ctrx &gt; 0)</a>
<a name="ln2651">                    y_change = 1;</a>
<a name="ln2652">            }</a>
<a name="ln2653">        }                       // end if (direction == 1)</a>
<a name="ln2654">        else</a>
<a name="ln2655">        {</a>
<a name="ln2656">            // This part checks all eight surrounding squares to find the</a>
<a name="ln2657">            // one that leads on to the present square.</a>
<a name="ln2658">            for (i = -1; i &lt; 2; ++i)</a>
<a name="ln2659">                for (j = -1; j &lt; 2; ++j)</a>
<a name="ln2660">                {</a>
<a name="ln2661">                    if (i == 0 &amp;&amp; j == 0)</a>
<a name="ln2662">                        continue;</a>
<a name="ln2663"> </a>
<a name="ln2664">                    if (temp_xps + i == minx - 1)</a>
<a name="ln2665">                    {</a>
<a name="ln2666">                        x_change = 0;</a>
<a name="ln2667">                        y_change = -1;</a>
<a name="ln2668">                    }</a>
<a name="ln2669">                    else if (temp_xps + i - ctrx == 0</a>
<a name="ln2670">                             &amp;&amp; temp_yps + j - ctry == 0)</a>
<a name="ln2671">                    {</a>
<a name="ln2672">                        x_change = -1;</a>
<a name="ln2673">                        y_change = 0;</a>
<a name="ln2674">                    }</a>
<a name="ln2675">                    else if (abs(temp_xps + i - ctrx) &lt;= abs(temp_yps + j - ctry))</a>
<a name="ln2676">                    {</a>
<a name="ln2677">                        const int xi = temp_xps + i - ctrx;</a>
<a name="ln2678">                        const int yj = temp_yps + j - ctry;</a>
<a name="ln2679"> </a>
<a name="ln2680">                        if (xi &gt;= 0 &amp;&amp; yj &lt;= 0</a>
<a name="ln2681">                            &amp;&amp; abs(xi) &gt; abs(yj + 1))</a>
<a name="ln2682">                        {</a>
<a name="ln2683">                            x_change = 0;</a>
<a name="ln2684">                            y_change = -1;</a>
<a name="ln2685">                            if (xi &gt; 0)</a>
<a name="ln2686">                                y_change = 1;</a>
<a name="ln2687">                            goto finished_spiralling;</a>
<a name="ln2688">                        }</a>
<a name="ln2689"> </a>
<a name="ln2690">                        x_change = -1;</a>
<a name="ln2691">                        if (yj &lt; 0)</a>
<a name="ln2692">                            x_change = 1;</a>
<a name="ln2693">                        y_change = 0;</a>
<a name="ln2694">                    }</a>
<a name="ln2695">                    else</a>
<a name="ln2696">                    {</a>
<a name="ln2697">                        x_change = 0;</a>
<a name="ln2698">                        y_change = -1;</a>
<a name="ln2699">                        if (temp_xps + i - ctrx &gt; 0)</a>
<a name="ln2700">                            y_change = 1;</a>
<a name="ln2701">                    }</a>
<a name="ln2702"> </a>
<a name="ln2703">                    if (temp_xps + i + x_change == temp_xps</a>
<a name="ln2704">                        &amp;&amp; temp_yps + j + y_change == temp_yps)</a>
<a name="ln2705">                    {</a>
<a name="ln2706">                        goto finished_spiralling;</a>
<a name="ln2707">                    }</a>
<a name="ln2708">                }</a>
<a name="ln2709">        }                       // end else</a>
<a name="ln2710"> </a>
<a name="ln2711">      finished_spiralling:</a>
<a name="ln2712">        x_change *= direction;</a>
<a name="ln2713">        y_change *= direction;</a>
<a name="ln2714"> </a>
<a name="ln2715">        temp_xps += x_change;</a>
<a name="ln2716">        if (temp_yps + y_change &lt;= maxy)  // it can wrap, unfortunately</a>
<a name="ln2717">            temp_yps += y_change;</a>
<a name="ln2718"> </a>
<a name="ln2719">        const int targ_x = you.pos().x + temp_xps - ctrx;</a>
<a name="ln2720">        const int targ_y = you.pos().y + temp_yps - ctry;</a>
<a name="ln2721">        const coord_def targ(targ_x, targ_y);</a>
<a name="ln2722"> </a>
<a name="ln2723">        if (!crawl_view.in_viewport_g(targ))</a>
<a name="ln2724">            continue;</a>
<a name="ln2725"> </a>
<a name="ln2726">        if (!map_bounds(targ))</a>
<a name="ln2727">            continue;</a>
<a name="ln2728"> </a>
<a name="ln2729">        if ((onlyVis || onlyHidden) &amp;&amp; onlyVis != you.see_cell(targ))</a>
<a name="ln2730">            continue;</a>
<a name="ln2731"> </a>
<a name="ln2732">        if (find_targ(targ))</a>
<a name="ln2733">        {</a>
<a name="ln2734">            mfp.set(temp_xps, temp_yps);</a>
<a name="ln2735">            return true;</a>
<a name="ln2736">        }</a>
<a name="ln2737">    }</a>
<a name="ln2738"> </a>
<a name="ln2739">    mfp = (direction &gt; 0 ? coord_def(ctrx, ctry) : coord_def(minx, maxy));</a>
<a name="ln2740">    return _find_square(mfp, direction,</a>
<a name="ln2741">                        find_targ, hitfunc,</a>
<a name="ln2742">                        false, _next_los(direction, los, wrap));</a>
<a name="ln2743">}</a>
<a name="ln2744"> </a>
<a name="ln2745">// XXX Unbelievably hacky. And to think that my goal was to clean up the code.</a>
<a name="ln2746">// Identical to _find_square, except that mfp is in grid coordinates</a>
<a name="ln2747">// rather than view coordinates.</a>
<a name="ln2748">static bool _find_square_wrapper(coord_def &amp;mfp, int direction,</a>
<a name="ln2749">                                 target_checker find_targ, targeter *hitfunc,</a>
<a name="ln2750">                                 LOSSelect los)</a>
<a name="ln2751">{</a>
<a name="ln2752">    mfp = grid2view(mfp);</a>
<a name="ln2753">    const bool r =  _find_square(mfp, direction, find_targ, hitfunc, true, los);</a>
<a name="ln2754">    mfp = view2grid(mfp);</a>
<a name="ln2755">    return r;</a>
<a name="ln2756">}</a>
<a name="ln2757"> </a>
<a name="ln2758">static void _describe_oos_feature(const coord_def&amp; where)</a>
<a name="ln2759">{</a>
<a name="ln2760">    if (!env.map_knowledge(where).seen())</a>
<a name="ln2761">        return;</a>
<a name="ln2762"> </a>
<a name="ln2763">    string desc = feature_description(env.map_knowledge(where).feat()) + &quot;.&quot;;</a>
<a name="ln2764"> </a>
<a name="ln2765">    if (!desc.empty())</a>
<a name="ln2766">        mprf(MSGCH_EXAMINE_FILTER, &quot;[%s]&quot;, desc.c_str());</a>
<a name="ln2767">}</a>
<a name="ln2768"> </a>
<a name="ln2769">// Returns a vector of features matching the given pattern.</a>
<a name="ln2770">vector&lt;dungeon_feature_type&gt; features_by_desc(const base_pattern &amp;pattern)</a>
<a name="ln2771">{</a>
<a name="ln2772">    vector&lt;dungeon_feature_type&gt; features;</a>
<a name="ln2773"> </a>
<a name="ln2774">    if (pattern.valid())</a>
<a name="ln2775">    {</a>
<a name="ln2776">        for (int i = 0; i &lt; NUM_FEATURES; ++i)</a>
<a name="ln2777">        {</a>
<a name="ln2778">            string fdesc =</a>
<a name="ln2779">                feature_description(static_cast&lt;dungeon_feature_type&gt;(i)) + &quot;.&quot;;</a>
<a name="ln2780"> </a>
<a name="ln2781">            if (pattern.matches(fdesc))</a>
<a name="ln2782">                features.push_back(dungeon_feature_type(i));</a>
<a name="ln2783">        }</a>
<a name="ln2784">    }</a>
<a name="ln2785">    return features;</a>
<a name="ln2786">}</a>
<a name="ln2787"> </a>
<a name="ln2788">void describe_floor()</a>
<a name="ln2789">{</a>
<a name="ln2790">    dungeon_feature_type grid = env.map_knowledge(you.pos()).feat();</a>
<a name="ln2791"> </a>
<a name="ln2792">    const char* prefix = &quot;There is &quot;;</a>
<a name="ln2793">    string feat;</a>
<a name="ln2794"> </a>
<a name="ln2795">    switch (grid)</a>
<a name="ln2796">    {</a>
<a name="ln2797">    case DNGN_FLOOR:</a>
<a name="ln2798">        return;</a>
<a name="ln2799"> </a>
<a name="ln2800">    case DNGN_ENTER_SHOP:</a>
<a name="ln2801">        prefix = &quot;There is an entrance to &quot;;</a>
<a name="ln2802">        break;</a>
<a name="ln2803"> </a>
<a name="ln2804">    default:</a>
<a name="ln2805">        break;</a>
<a name="ln2806">    }</a>
<a name="ln2807"> </a>
<a name="ln2808">    feat = feature_description_at(you.pos(), true, DESC_A);</a>
<a name="ln2809">    if (feat.empty())</a>
<a name="ln2810">        return;</a>
<a name="ln2811"> </a>
<a name="ln2812">    msg_channel_type channel = MSGCH_EXAMINE;</a>
<a name="ln2813"> </a>
<a name="ln2814">    // Messages for water/lava are too spammy use a status light instead.</a>
<a name="ln2815">    if (feat_is_water(grid) || feat_is_lava(grid))</a>
<a name="ln2816">        return;</a>
<a name="ln2817"> </a>
<a name="ln2818">    mprf(channel, &quot;%s%s here.&quot;, prefix, feat.c_str());</a>
<a name="ln2819">    if (grid == DNGN_ENTER_GAUNTLET)</a>
<a name="ln2820">        mprf(MSGCH_EXAMINE, &quot;Beware, the minotaur awaits!&quot;);</a>
<a name="ln2821">}</a>
<a name="ln2822"> </a>
<a name="ln2823">static string _base_feature_desc(dungeon_feature_type grid, trap_type trap)</a>
<a name="ln2824">{</a>
<a name="ln2825">    if (feat_is_trap(grid) &amp;&amp; trap != NUM_TRAPS)</a>
<a name="ln2826">        return full_trap_name(trap);</a>
<a name="ln2827"> </a>
<a name="ln2828">    if (grid == DNGN_ROCK_WALL &amp;&amp; player_in_branch(BRANCH_PANDEMONIUM))</a>
<a name="ln2829">        return &quot;wall of the weird stuff which makes up Pandemonium&quot;;</a>
<a name="ln2830">    else if (!is_valid_feature_type(grid))</a>
<a name="ln2831">        return &quot;&quot;;</a>
<a name="ln2832">    else</a>
<a name="ln2833">        return get_feature_def(grid).name;</a>
<a name="ln2834"> </a>
<a name="ln2835">}</a>
<a name="ln2836"> </a>
<a name="ln2837">string feature_description(dungeon_feature_type grid, trap_type trap,</a>
<a name="ln2838">                           const string &amp; cover_desc,</a>
<a name="ln2839">                           description_level_type dtype)</a>
<a name="ln2840">{</a>
<a name="ln2841">    string desc = _base_feature_desc(grid, trap);</a>
<a name="ln2842">    desc += cover_desc;</a>
<a name="ln2843"> </a>
<a name="ln2844">    if (grid == DNGN_FLOOR &amp;&amp; dtype == DESC_A)</a>
<a name="ln2845">        dtype = DESC_THE;</a>
<a name="ln2846"> </a>
<a name="ln2847">    return thing_do_grammar(dtype, desc);</a>
<a name="ln2848">}</a>
<a name="ln2849"> </a>
<a name="ln2850">string raw_feature_description(const coord_def &amp;where)</a>
<a name="ln2851">{</a>
<a name="ln2852">    dungeon_feature_type feat = grd(where);</a>
<a name="ln2853"> </a>
<a name="ln2854">    int mapi = env.level_map_ids(where);</a>
<a name="ln2855">    if (mapi != INVALID_MAP_INDEX)</a>
<a name="ln2856">    {</a>
<a name="ln2857">        const auto &amp;renames = env.level_vaults[mapi]-&gt;map.feat_renames;</a>
<a name="ln2858">        if (const string *rename = map_find(renames, feat))</a>
<a name="ln2859">            return *rename;</a>
<a name="ln2860">    }</a>
<a name="ln2861"> </a>
<a name="ln2862">    return _base_feature_desc(feat, get_trap_type(where));</a>
<a name="ln2863">}</a>
<a name="ln2864"> </a>
<a name="ln2865">#ifndef DEBUG_DIAGNOSTICS</a>
<a name="ln2866">// Is a feature interesting enough to 'v'iew it, even if a player normally</a>
<a name="ln2867">// doesn't care about descriptions, i.e. does the description hold important</a>
<a name="ln2868">// information? (Yes, this is entirely subjective. --jpeg)</a>
<a name="ln2869">static bool _interesting_feature(dungeon_feature_type feat)</a>
<a name="ln2870">{</a>
<a name="ln2871">    return get_feature_def(feat).flags &amp; FFT_EXAMINE_HINT;</a>
<a name="ln2872">}</a>
<a name="ln2873">#endif</a>
<a name="ln2874"> </a>
<a name="ln2875">string feature_description_at(const coord_def&amp; where, bool covering,</a>
<a name="ln2876">                              description_level_type dtype)</a>
<a name="ln2877">{</a>
<a name="ln2878">    dungeon_feature_type grid = env.map_knowledge(where).feat();</a>
<a name="ln2879">    trap_type trap = env.map_knowledge(where).trap();</a>
<a name="ln2880"> </a>
<a name="ln2881">    string marker_desc = env.markers.property_at(where, MAT_ANY,</a>
<a name="ln2882">                                                 &quot;feature_description&quot;);</a>
<a name="ln2883"> </a>
<a name="ln2884">    string covering_description = &quot;&quot;;</a>
<a name="ln2885"> </a>
<a name="ln2886">    if (covering &amp;&amp; you.see_cell(where) &amp;&amp; is_icecovered(where))</a>
<a name="ln2887">        covering_description = &quot;, covered with ice&quot;;</a>
<a name="ln2888"> </a>
<a name="ln2889">    if (covering &amp;&amp; you.see_cell(where) &amp;&amp; is_bloodcovered(where))</a>
<a name="ln2890">    {</a>
<a name="ln2891">        string prefix = covering_description.empty() ? &quot;, &quot; : &quot; and &quot;;</a>
<a name="ln2892">        covering_description += prefix + &quot;spattered with blood&quot;;</a>
<a name="ln2893">    }</a>
<a name="ln2894"> </a>
<a name="ln2895">    // FIXME: remove desc markers completely; only Zin walls are left.</a>
<a name="ln2896">    // They suffer, among other problems, from an information leak.</a>
<a name="ln2897">    if (!marker_desc.empty())</a>
<a name="ln2898">    {</a>
<a name="ln2899">        marker_desc += covering_description;</a>
<a name="ln2900"> </a>
<a name="ln2901">        return thing_do_grammar(dtype, marker_desc);</a>
<a name="ln2902">    }</a>
<a name="ln2903"> </a>
<a name="ln2904">    if (feat_is_door(grid))</a>
<a name="ln2905">    {</a>
<a name="ln2906">        const string door_desc_prefix =</a>
<a name="ln2907">            env.markers.property_at(where, MAT_ANY,</a>
<a name="ln2908">                                    &quot;door_description_prefix&quot;);</a>
<a name="ln2909">        const string door_desc_suffix =</a>
<a name="ln2910">            env.markers.property_at(where, MAT_ANY,</a>
<a name="ln2911">                                    &quot;door_description_suffix&quot;);</a>
<a name="ln2912">        const string door_desc_noun =</a>
<a name="ln2913">            env.markers.property_at(where, MAT_ANY,</a>
<a name="ln2914">                                    &quot;door_description_noun&quot;);</a>
<a name="ln2915">        const string door_desc_adj  =</a>
<a name="ln2916">            env.markers.property_at(where, MAT_ANY,</a>
<a name="ln2917">                                    &quot;door_description_adjective&quot;);</a>
<a name="ln2918">        const string door_desc_veto =</a>
<a name="ln2919">            env.markers.property_at(where, MAT_ANY,</a>
<a name="ln2920">                                    &quot;door_description_veto&quot;);</a>
<a name="ln2921"> </a>
<a name="ln2922">        set&lt;coord_def&gt; all_door;</a>
<a name="ln2923">        find_connected_identical(where, all_door);</a>
<a name="ln2924">        const char *adj, *noun;</a>
<a name="ln2925">        get_door_description(all_door.size(), &amp;adj, &amp;noun);</a>
<a name="ln2926"> </a>
<a name="ln2927">        string desc;</a>
<a name="ln2928">        if (!door_desc_adj.empty())</a>
<a name="ln2929">            desc += door_desc_adj;</a>
<a name="ln2930">        else</a>
<a name="ln2931">            desc += adj;</a>
<a name="ln2932"> </a>
<a name="ln2933">        if (door_desc_veto.empty() || door_desc_veto != &quot;veto&quot;)</a>
<a name="ln2934">        {</a>
<a name="ln2935">            if (grid == DNGN_OPEN_DOOR)</a>
<a name="ln2936">                desc += &quot;open &quot;;</a>
<a name="ln2937">            else if (grid == DNGN_CLOSED_CLEAR_DOOR)</a>
<a name="ln2938">                desc += &quot;closed translucent &quot;;</a>
<a name="ln2939">            else if (grid == DNGN_OPEN_CLEAR_DOOR)</a>
<a name="ln2940">                desc += &quot;open translucent &quot;;</a>
<a name="ln2941">            else if (grid == DNGN_RUNED_DOOR)</a>
<a name="ln2942">                desc += &quot;runed &quot;;</a>
<a name="ln2943">            else if (grid == DNGN_RUNED_CLEAR_DOOR)</a>
<a name="ln2944">                desc += &quot;runed translucent &quot;;</a>
<a name="ln2945">            else if (grid == DNGN_SEALED_DOOR)</a>
<a name="ln2946">                desc += &quot;sealed &quot;;</a>
<a name="ln2947">            else if (grid == DNGN_SEALED_CLEAR_DOOR)</a>
<a name="ln2948">                desc += &quot;sealed translucent &quot;;</a>
<a name="ln2949">            else</a>
<a name="ln2950">                desc += &quot;closed &quot;;</a>
<a name="ln2951">        }</a>
<a name="ln2952"> </a>
<a name="ln2953">        desc += door_desc_prefix;</a>
<a name="ln2954"> </a>
<a name="ln2955">        if (!door_desc_noun.empty())</a>
<a name="ln2956">            desc += door_desc_noun;</a>
<a name="ln2957">        else</a>
<a name="ln2958">            desc += noun;</a>
<a name="ln2959"> </a>
<a name="ln2960">        desc += door_desc_suffix;</a>
<a name="ln2961"> </a>
<a name="ln2962">        desc += covering_description;</a>
<a name="ln2963"> </a>
<a name="ln2964">        return thing_do_grammar(dtype, desc);</a>
<a name="ln2965">    }</a>
<a name="ln2966"> </a>
<a name="ln2967">    switch (grid)</a>
<a name="ln2968">    {</a>
<a name="ln2969">#if TAG_MAJOR_VERSION == 34</a>
<a name="ln2970">    case DNGN_TRAP_MECHANICAL:</a>
<a name="ln2971">#endif</a>
<a name="ln2972">    case DNGN_TRAP_ARROW:</a>
<a name="ln2973">    case DNGN_TRAP_SPEAR:</a>
<a name="ln2974">    case DNGN_TRAP_BLADE:</a>
<a name="ln2975">    case DNGN_TRAP_DART:</a>
<a name="ln2976">    case DNGN_TRAP_BOLT:</a>
<a name="ln2977">    case DNGN_TRAP_NET:</a>
<a name="ln2978">    case DNGN_TRAP_PLATE:</a>
<a name="ln2979">        return feature_description(grid, trap, covering_description, dtype);</a>
<a name="ln2980">    case DNGN_ABANDONED_SHOP:</a>
<a name="ln2981">        return thing_do_grammar(dtype, &quot;an abandoned shop&quot;);</a>
<a name="ln2982"> </a>
<a name="ln2983">    case DNGN_ENTER_SHOP:</a>
<a name="ln2984">        return shop_name(*shop_at(where));</a>
<a name="ln2985"> </a>
<a name="ln2986">#if TAG_MAJOR_VERSION == 34</a>
<a name="ln2987">    case DNGN_ENTER_PORTAL_VAULT:</a>
<a name="ln2988">        // Should have been handled at the top of the function.</a>
<a name="ln2989">        return thing_do_grammar(dtype, &quot;UNAMED PORTAL VAULT ENTRY&quot;);</a>
<a name="ln2990">#endif</a>
<a name="ln2991"> </a>
<a name="ln2992">    case DNGN_TREE:</a>
<a name="ln2993">    {</a>
<a name="ln2994">        string desc = &quot;&quot;;</a>
<a name="ln2995">        if (env.forest_awoken_until)</a>
<a name="ln2996">            desc += &quot;awoken &quot;;</a>
<a name="ln2997">        desc += grid == grd(where) ? raw_feature_description(where)</a>
<a name="ln2998">                                   : _base_feature_desc(grid, trap);</a>
<a name="ln2999">        if (is_temp_terrain(where))</a>
<a name="ln3000">            desc += &quot; (summoned)&quot;;</a>
<a name="ln3001">        desc += covering_description;</a>
<a name="ln3002">        return thing_do_grammar(dtype, desc);</a>
<a name="ln3003">    }</a>
<a name="ln3004"> </a>
<a name="ln3005">    case DNGN_FLOOR:</a>
<a name="ln3006">        if (dtype == DESC_A)</a>
<a name="ln3007">            dtype = DESC_THE;</a>
<a name="ln3008">        // fallthrough</a>
<a name="ln3009">    default:</a>
<a name="ln3010">        const string featdesc = grid == grd(where)</a>
<a name="ln3011">                              ? raw_feature_description(where)</a>
<a name="ln3012">                              : _base_feature_desc(grid, trap);</a>
<a name="ln3013">        return thing_do_grammar(dtype, featdesc + covering_description);</a>
<a name="ln3014">    }</a>
<a name="ln3015">}</a>
<a name="ln3016"> </a>
<a name="ln3017">static string _describe_monster_weapon(const monster_info&amp; mi, bool ident)</a>
<a name="ln3018">{</a>
<a name="ln3019">    string desc = &quot;&quot;;</a>
<a name="ln3020">    string name1, name2;</a>
<a name="ln3021">    const item_def *weap = mi.inv[MSLOT_WEAPON].get();</a>
<a name="ln3022">    const item_def *alt  = mi.inv[MSLOT_ALT_WEAPON].get();</a>
<a name="ln3023"> </a>
<a name="ln3024">    if (weap &amp;&amp; (!ident || item_type_known(*weap)))</a>
<a name="ln3025">    {</a>
<a name="ln3026">        name1 = weap-&gt;name(DESC_A, false, false, true,</a>
<a name="ln3027">                           false, ISFLAG_KNOW_CURSE);</a>
<a name="ln3028">    }</a>
<a name="ln3029">    if (alt &amp;&amp; (!ident || item_type_known(*alt)) &amp;&amp; mi.wields_two_weapons())</a>
<a name="ln3030">    {</a>
<a name="ln3031">        name2 = alt-&gt;name(DESC_A, false, false, true,</a>
<a name="ln3032">                          false, ISFLAG_KNOW_CURSE);</a>
<a name="ln3033">    }</a>
<a name="ln3034"> </a>
<a name="ln3035">    if (name1.empty() &amp;&amp; !name2.empty())</a>
<a name="ln3036">        name1.swap(name2);</a>
<a name="ln3037"> </a>
<a name="ln3038">    if (name1 == name2 &amp;&amp; weap &amp;&amp; !name1.empty())</a>
<a name="ln3039">    {</a>
<a name="ln3040">        item_def dup = *weap;</a>
<a name="ln3041">        ++dup.quantity;</a>
<a name="ln3042">        name1 = dup.name(DESC_A, false, false, true, true,</a>
<a name="ln3043">                         ISFLAG_KNOW_CURSE);</a>
<a name="ln3044">        name2.clear();</a>
<a name="ln3045">    }</a>
<a name="ln3046"> </a>
<a name="ln3047">    if (mi.props.exists(SPECIAL_WEAPON_KEY))</a>
<a name="ln3048">    {</a>
<a name="ln3049">        name1 = article_a(ghost_brand_name(</a>
<a name="ln3050">            (brand_type) mi.props[SPECIAL_WEAPON_KEY].get_int(), mi.type));</a>
<a name="ln3051">    }</a>
<a name="ln3052"> </a>
<a name="ln3053">    if (name1.empty())</a>
<a name="ln3054">        return desc;</a>
<a name="ln3055"> </a>
<a name="ln3056">    if (mi.type == MONS_PANDEMONIUM_LORD)</a>
<a name="ln3057">        desc += &quot; armed with &quot;;</a>
<a name="ln3058">    else if (mi.type == MONS_DANCING_WEAPON)</a>
<a name="ln3059">        desc += &quot; &quot;;</a>
<a name="ln3060">    else</a>
<a name="ln3061">        desc += &quot; wielding &quot;;</a>
<a name="ln3062">    desc += name1;</a>
<a name="ln3063"> </a>
<a name="ln3064">    if (!name2.empty())</a>
<a name="ln3065">    {</a>
<a name="ln3066">        desc += &quot; and &quot;;</a>
<a name="ln3067">        desc += name2;</a>
<a name="ln3068">    }</a>
<a name="ln3069"> </a>
<a name="ln3070">    return desc;</a>
<a name="ln3071">}</a>
<a name="ln3072"> </a>
<a name="ln3073">#ifdef DEBUG_DIAGNOSTICS</a>
<a name="ln3074">static string _stair_destination_description(const coord_def &amp;pos)</a>
<a name="ln3075">{</a>
<a name="ln3076">    if (LevelInfo *linf = travel_cache.find_level_info(level_id::current()))</a>
<a name="ln3077">    {</a>
<a name="ln3078">        const stair_info *si = linf-&gt;get_stair(pos);</a>
<a name="ln3079">        if (si)</a>
<a name="ln3080">            return &quot; &quot; + si-&gt;describe();</a>
<a name="ln3081">        else if (feat_is_stair(grd(pos)))</a>
<a name="ln3082">            return &quot; (unknown stair)&quot;;</a>
<a name="ln3083">    }</a>
<a name="ln3084">    return &quot;&quot;;</a>
<a name="ln3085">}</a>
<a name="ln3086">#endif</a>
<a name="ln3087"> </a>
<a name="ln3088">static string _mon_enchantments_string(const monster_info&amp; mi)</a>
<a name="ln3089">{</a>
<a name="ln3090">    const vector&lt;string&gt; enchant_descriptors = mi.attributes();</a>
<a name="ln3091"> </a>
<a name="ln3092">    if (!enchant_descriptors.empty())</a>
<a name="ln3093">    {</a>
<a name="ln3094">        return uppercase_first(mi.pronoun(PRONOUN_SUBJECTIVE))</a>
<a name="ln3095">            + &quot; &quot;</a>
<a name="ln3096">            + conjugate_verb(&quot;are&quot;, mi.pronoun_plurality())</a>
<a name="ln3097">            + &quot; &quot;</a>
<a name="ln3098">            + comma_separated_line(enchant_descriptors.begin(),</a>
<a name="ln3099">                                   enchant_descriptors.end())</a>
<a name="ln3100">            + &quot;.&quot;;</a>
<a name="ln3101">    }</a>
<a name="ln3102">    else</a>
<a name="ln3103">        return &quot;&quot;;</a>
<a name="ln3104">}</a>
<a name="ln3105"> </a>
<a name="ln3106">static vector&lt;string&gt; _get_monster_behaviour_vector(const monster_info&amp; mi)</a>
<a name="ln3107">{</a>
<a name="ln3108">    vector&lt;string&gt; descs;</a>
<a name="ln3109"> </a>
<a name="ln3110">    if (mi.is(MB_SLEEPING) || mi.is(MB_DORMANT))</a>
<a name="ln3111">        descs.emplace_back(mi.is(MB_CONFUSED) ? &quot;sleepwalking&quot; : &quot;resting&quot;);</a>
<a name="ln3112">    else if (mi.is(MB_FLEEING))</a>
<a name="ln3113">        descs.emplace_back(&quot;fleeing&quot;);</a>
<a name="ln3114">    else if (mi.attitude == ATT_HOSTILE &amp;&amp; (mi.is(MB_UNAWARE) || mi.is(MB_WANDERING)))</a>
<a name="ln3115">        descs.emplace_back(&quot;hasn't noticed you&quot;);</a>
<a name="ln3116"> </a>
<a name="ln3117">    return descs;</a>
<a name="ln3118">}</a>
<a name="ln3119"> </a>
<a name="ln3120">// FIXME: this duplicates _get_monster_desc(). Unite them.</a>
<a name="ln3121">static vector&lt;string&gt; _get_monster_desc_vector(const monster_info&amp; mi)</a>
<a name="ln3122">{</a>
<a name="ln3123">    vector&lt;string&gt; descs;</a>
<a name="ln3124"> </a>
<a name="ln3125">    if (mi.is(MB_MESMERIZING))</a>
<a name="ln3126">        descs.emplace_back(&quot;mesmerising&quot;);</a>
<a name="ln3127"> </a>
<a name="ln3128">    _append_container(descs, _get_monster_behaviour_vector(mi));</a>
<a name="ln3129"> </a>
<a name="ln3130">    if (you.duration[DUR_CONFUSING_TOUCH])</a>
<a name="ln3131">    {</a>
<a name="ln3132">        const int pow = you.props[&quot;confusing touch power&quot;].get_int();</a>
<a name="ln3133">        descs.emplace_back(make_stringf(&quot;chance to confuse on hit: %d%%&quot;,</a>
<a name="ln3134">                                        hex_success_chance(mi.res_magic(),</a>
<a name="ln3135">                                                           pow, 100)));</a>
<a name="ln3136">    }</a>
<a name="ln3137">    else if (you.form == transformation::fungus</a>
<a name="ln3138">             &amp;&amp; !mons_is_unbreathing(mi.type))</a>
<a name="ln3139">    {</a>
<a name="ln3140">        descs.emplace_back(make_stringf(&quot;chance to confuse on hit: %d%%&quot;,</a>
<a name="ln3141">                                        melee_confuse_chance(mi.hd)));</a>
<a name="ln3142">    }</a>
<a name="ln3143"> </a>
<a name="ln3144">    if (mi.attitude == ATT_FRIENDLY)</a>
<a name="ln3145">        descs.emplace_back(&quot;friendly&quot;);</a>
<a name="ln3146">    else if (mi.attitude == ATT_GOOD_NEUTRAL)</a>
<a name="ln3147">        descs.emplace_back(&quot;peaceful&quot;);</a>
<a name="ln3148">    else if (mi.attitude != ATT_HOSTILE &amp;&amp; !mi.is(MB_INSANE))</a>
<a name="ln3149">    {</a>
<a name="ln3150">        // don't differentiate between permanent or not</a>
<a name="ln3151">        descs.emplace_back(&quot;indifferent&quot;);</a>
<a name="ln3152">    }</a>
<a name="ln3153"> </a>
<a name="ln3154">    if (mi.is(MB_SUMMONED))</a>
<a name="ln3155">        descs.emplace_back(&quot;summoned&quot;);</a>
<a name="ln3156"> </a>
<a name="ln3157">    if (mi.is(MB_PERM_SUMMON))</a>
<a name="ln3158">        descs.emplace_back(&quot;durably summoned&quot;);</a>
<a name="ln3159"> </a>
<a name="ln3160">    if (mi.is(MB_SUMMONED_CAPPED))</a>
<a name="ln3161">        descs.emplace_back(&quot;expiring&quot;);</a>
<a name="ln3162"> </a>
<a name="ln3163">    if (mi.is(MB_HALOED))</a>
<a name="ln3164">        descs.emplace_back(&quot;haloed&quot;);</a>
<a name="ln3165"> </a>
<a name="ln3166">    if (mi.is(MB_UMBRAED))</a>
<a name="ln3167">        descs.emplace_back(&quot;umbra&quot;);</a>
<a name="ln3168"> </a>
<a name="ln3169">    if (mi.is(MB_POSSESSABLE))</a>
<a name="ln3170">        descs.emplace_back(&quot;possessable&quot;); // FIXME: better adjective</a>
<a name="ln3171">    else if (mi.is(MB_ENSLAVED))</a>
<a name="ln3172">        descs.emplace_back(&quot;disembodied soul&quot;);</a>
<a name="ln3173"> </a>
<a name="ln3174">    if (mi.is(MB_MIRROR_DAMAGE))</a>
<a name="ln3175">        descs.emplace_back(&quot;reflecting injuries&quot;);</a>
<a name="ln3176"> </a>
<a name="ln3177">    if (mi.is(MB_INNER_FLAME))</a>
<a name="ln3178">        descs.emplace_back(&quot;inner flame&quot;);</a>
<a name="ln3179"> </a>
<a name="ln3180">    if (mi.fire_blocker)</a>
<a name="ln3181">    {</a>
<a name="ln3182">        descs.push_back(&quot;fire blocked by &quot; // FIXME, renamed features</a>
<a name="ln3183">                        + feature_description(mi.fire_blocker, NUM_TRAPS, &quot;&quot;,</a>
<a name="ln3184">                                              DESC_A));</a>
<a name="ln3185">    }</a>
<a name="ln3186"> </a>
<a name="ln3187">    return descs;</a>
<a name="ln3188">}</a>
<a name="ln3189"> </a>
<a name="ln3190">// Returns the description string for a given monster, including attitude</a>
<a name="ln3191">// and enchantments but not equipment or wounds.</a>
<a name="ln3192">static string _get_monster_desc(const monster_info&amp; mi)</a>
<a name="ln3193">{</a>
<a name="ln3194">    string text    = &quot;&quot;;</a>
<a name="ln3195">    string pronoun = uppercase_first(mi.pronoun(PRONOUN_SUBJECTIVE));</a>
<a name="ln3196"> </a>
<a name="ln3197">    if (mi.is(MB_MESMERIZING))</a>
<a name="ln3198">    {</a>
<a name="ln3199">        text += string(&quot;You are mesmerised by &quot;)</a>
<a name="ln3200">                + mi.pronoun(PRONOUN_POSSESSIVE) + &quot; song.\n&quot;;</a>
<a name="ln3201">    }</a>
<a name="ln3202"> </a>
<a name="ln3203">    if (mi.is(MB_SLEEPING) || mi.is(MB_DORMANT))</a>
<a name="ln3204">    {</a>
<a name="ln3205">        text += pronoun + &quot; &quot;</a>
<a name="ln3206">                + conjugate_verb(&quot;appear&quot;, mi.pronoun_plurality()) + &quot; to be &quot;</a>
<a name="ln3207">                + (mi.is(MB_CONFUSED) ? &quot;sleepwalking&quot; : &quot;resting&quot;) + &quot;.\n&quot;;</a>
<a name="ln3208">    }</a>
<a name="ln3209">    // Applies to both friendlies and hostiles</a>
<a name="ln3210">    else if (mi.is(MB_FLEEING))</a>
<a name="ln3211">    {</a>
<a name="ln3212">        text += pronoun + &quot; &quot; + conjugate_verb(&quot;are&quot;, mi.pronoun_plurality())</a>
<a name="ln3213">                + &quot; fleeing.\n&quot;;</a>
<a name="ln3214">    }</a>
<a name="ln3215">    // hostile with target != you</a>
<a name="ln3216">    else if (mi.attitude == ATT_HOSTILE</a>
<a name="ln3217">             &amp;&amp; (mi.is(MB_UNAWARE) || mi.is(MB_WANDERING)))</a>
<a name="ln3218">    {</a>
<a name="ln3219">        text += pronoun + &quot; &quot; + conjugate_verb(&quot;have&quot;, mi.pronoun_plurality())</a>
<a name="ln3220">                + &quot; not noticed you.\n&quot;;</a>
<a name="ln3221">    }</a>
<a name="ln3222"> </a>
<a name="ln3223">    if (mi.attitude == ATT_FRIENDLY)</a>
<a name="ln3224">    {</a>
<a name="ln3225">        text += pronoun + &quot; &quot; + conjugate_verb(&quot;are&quot;, mi.pronoun_plurality())</a>
<a name="ln3226">                + &quot; friendly.\n&quot;;</a>
<a name="ln3227">    }</a>
<a name="ln3228">    else if (mi.attitude == ATT_GOOD_NEUTRAL)</a>
<a name="ln3229">    {</a>
<a name="ln3230">        text += pronoun + &quot; &quot; + conjugate_verb(&quot;seem&quot;, mi.pronoun_plurality())</a>
<a name="ln3231">                + &quot; to be peaceful towards you.\n&quot;;</a>
<a name="ln3232">    }</a>
<a name="ln3233">    else if (mi.attitude != ATT_HOSTILE &amp;&amp; !mi.is(MB_INSANE))</a>
<a name="ln3234">    {</a>
<a name="ln3235">        // don't differentiate between permanent or not</a>
<a name="ln3236">        text += pronoun + &quot; &quot; + conjugate_verb(&quot;are&quot;, mi.pronoun_plurality())</a>
<a name="ln3237">                + &quot; indifferent to you.\n&quot;;</a>
<a name="ln3238">    }</a>
<a name="ln3239"> </a>
<a name="ln3240">    if (mi.is(MB_SUMMONED) || mi.is(MB_PERM_SUMMON))</a>
<a name="ln3241">    {</a>
<a name="ln3242">        text += pronoun + &quot; &quot; + conjugate_verb(&quot;have&quot;, mi.pronoun_plurality())</a>
<a name="ln3243">                + &quot; been summoned&quot;;</a>
<a name="ln3244">        if (mi.is(MB_SUMMONED_CAPPED))</a>
<a name="ln3245">        {</a>
<a name="ln3246">            text += &quot;, and &quot; + conjugate_verb(&quot;are&quot;, mi.pronoun_plurality())</a>
<a name="ln3247">                    + &quot; expiring&quot;;</a>
<a name="ln3248">        }</a>
<a name="ln3249">        else if (mi.is(MB_PERM_SUMMON))</a>
<a name="ln3250">            text += &quot; but will not time out&quot;;</a>
<a name="ln3251">        text += &quot;.\n&quot;;</a>
<a name="ln3252">    }</a>
<a name="ln3253"> </a>
<a name="ln3254">    if (mi.is(MB_HALOED))</a>
<a name="ln3255">    {</a>
<a name="ln3256">        text += pronoun + &quot; &quot; + conjugate_verb(&quot;are&quot;, mi.pronoun_plurality())</a>
<a name="ln3257">                + &quot; illuminated by a divine halo.\n&quot;;</a>
<a name="ln3258">    }</a>
<a name="ln3259"> </a>
<a name="ln3260">    if (mi.is(MB_UMBRAED))</a>
<a name="ln3261">    {</a>
<a name="ln3262">        text += pronoun + &quot; &quot; + conjugate_verb(&quot;are&quot;, mi.pronoun_plurality())</a>
<a name="ln3263">                + &quot; wreathed by an umbra.\n&quot;;</a>
<a name="ln3264">    }</a>
<a name="ln3265"> </a>
<a name="ln3266">    if (mi.intel() &lt;= I_BRAINLESS)</a>
<a name="ln3267">    {</a>
<a name="ln3268">        text += pronoun + &quot; &quot; + conjugate_verb(&quot;are&quot;, mi.pronoun_plurality())</a>
<a name="ln3269">                + &quot; mindless.\n&quot;;</a>
<a name="ln3270">    }</a>
<a name="ln3271"> </a>
<a name="ln3272">    if (mi.is(MB_CHAOTIC))</a>
<a name="ln3273">    {</a>
<a name="ln3274">        text += pronoun + &quot; &quot; + conjugate_verb(&quot;are&quot;, mi.pronoun_plurality())</a>
<a name="ln3275">                + &quot; chaotic.\n&quot;;</a>
<a name="ln3276">    }</a>
<a name="ln3277"> </a>
<a name="ln3278">    if (mi.is(MB_POSSESSABLE))</a>
<a name="ln3279">    {</a>
<a name="ln3280">        text += string(mi.pronoun(PRONOUN_POSSESSIVE))</a>
<a name="ln3281">                + &quot; soul is ripe for the taking.\n&quot;;</a>
<a name="ln3282">    }</a>
<a name="ln3283">    else if (mi.is(MB_ENSLAVED))</a>
<a name="ln3284">    {</a>
<a name="ln3285">        text += pronoun + &quot; &quot; + conjugate_verb(&quot;are&quot;, mi.pronoun_plurality())</a>
<a name="ln3286">                + &quot; a disembodied soul.\n&quot;;</a>
<a name="ln3287">    }</a>
<a name="ln3288"> </a>
<a name="ln3289">    if (mi.is(MB_MIRROR_DAMAGE))</a>
<a name="ln3290">    {</a>
<a name="ln3291">        text += pronoun + &quot; &quot; + conjugate_verb(&quot;are&quot;, mi.pronoun_plurality())</a>
<a name="ln3292">                + &quot; reflecting injuries back at attackers.\n&quot;;</a>
<a name="ln3293">    }</a>
<a name="ln3294"> </a>
<a name="ln3295">    if (mi.is(MB_INNER_FLAME))</a>
<a name="ln3296">    {</a>
<a name="ln3297">        text += pronoun + &quot; &quot; + conjugate_verb(&quot;are&quot;, mi.pronoun_plurality())</a>
<a name="ln3298">                + &quot; filled with an inner flame.\n&quot;;</a>
<a name="ln3299">    }</a>
<a name="ln3300"> </a>
<a name="ln3301">    if (mi.fire_blocker)</a>
<a name="ln3302">    {</a>
<a name="ln3303">        text += string(&quot;Your line of fire to &quot;) + mi.pronoun(PRONOUN_OBJECTIVE)</a>
<a name="ln3304">                + &quot; is blocked by &quot; // FIXME: renamed features</a>
<a name="ln3305">                + feature_description(mi.fire_blocker, NUM_TRAPS, &quot;&quot;,</a>
<a name="ln3306">                                      DESC_A)</a>
<a name="ln3307">                + &quot;.\n&quot;;</a>
<a name="ln3308">    }</a>
<a name="ln3309"> </a>
<a name="ln3310">    text += _mon_enchantments_string(mi);</a>
<a name="ln3311">    if (!text.empty() &amp;&amp; text.back() == '\n')</a>
<a name="ln3312">        text.pop_back();</a>
<a name="ln3313">    return text;</a>
<a name="ln3314">}</a>
<a name="ln3315"> </a>
<a name="ln3316">static void _describe_monster(const monster_info&amp; mi)</a>
<a name="ln3317">{</a>
<a name="ln3318">    // First print type and equipment.</a>
<a name="ln3319">    string text = uppercase_first(get_monster_equipment_desc(mi)) + &quot;.&quot;;</a>
<a name="ln3320">    const string wounds_desc = mi.wounds_description_sentence();</a>
<a name="ln3321">    if (!wounds_desc.empty())</a>
<a name="ln3322">        text += &quot; &quot; + uppercase_first(wounds_desc);</a>
<a name="ln3323">    const string constriction_desc = mi.constriction_description();</a>
<a name="ln3324">    if (!constriction_desc.empty())</a>
<a name="ln3325">        text += &quot; It is&quot; + constriction_desc + &quot;.&quot;;</a>
<a name="ln3326">    mprf(MSGCH_EXAMINE, &quot;%s&quot;, text.c_str());</a>
<a name="ln3327"> </a>
<a name="ln3328">    // Print the rest of the description.</a>
<a name="ln3329">    text = _get_monster_desc(mi);</a>
<a name="ln3330">    if (!text.empty())</a>
<a name="ln3331">        mprf(MSGCH_EXAMINE, &quot;%s&quot;, text.c_str());</a>
<a name="ln3332">}</a>
<a name="ln3333"> </a>
<a name="ln3334">// This method is called in two cases:</a>
<a name="ln3335">// a) Monsters coming into view: &quot;An ogre comes into view. It is wielding ...&quot;</a>
<a name="ln3336">// b) Monster description via 'x': &quot;An ogre, wielding a club, and wearing ...&quot;</a>
<a name="ln3337">string get_monster_equipment_desc(const monster_info&amp; mi,</a>
<a name="ln3338">                                  mons_equip_desc_level_type level,</a>
<a name="ln3339">                                  description_level_type mondtype,</a>
<a name="ln3340">                                  bool print_attitude)</a>
<a name="ln3341">{</a>
<a name="ln3342">    string desc = &quot;&quot;;</a>
<a name="ln3343">    if (mondtype != DESC_NONE)</a>
<a name="ln3344">    {</a>
<a name="ln3345">        if (print_attitude &amp;&amp; mons_is_pghost(mi.type))</a>
<a name="ln3346">            desc = get_ghost_description(mi);</a>
<a name="ln3347">        else</a>
<a name="ln3348">            desc = mi.full_name(mondtype);</a>
<a name="ln3349"> </a>
<a name="ln3350">        if (print_attitude)</a>
<a name="ln3351">        {</a>
<a name="ln3352">            vector&lt;string&gt; attributes;</a>
<a name="ln3353">            if (mi.is(MB_CHARMED))</a>
<a name="ln3354">                attributes.emplace_back(&quot;charmed&quot;);</a>
<a name="ln3355">            else if (mi.attitude == ATT_FRIENDLY)</a>
<a name="ln3356">                attributes.emplace_back(&quot;friendly&quot;);</a>
<a name="ln3357">            else if (mi.attitude == ATT_GOOD_NEUTRAL)</a>
<a name="ln3358">                attributes.emplace_back(&quot;peaceful&quot;);</a>
<a name="ln3359">            else if (mi.is(MB_INSANE))</a>
<a name="ln3360">                attributes.emplace_back(&quot;insane&quot;);</a>
<a name="ln3361">            else if (mi.attitude != ATT_HOSTILE)</a>
<a name="ln3362">                attributes.emplace_back(&quot;neutral&quot;);</a>
<a name="ln3363"> </a>
<a name="ln3364">            if (mi.is(MB_SUMMONED))</a>
<a name="ln3365">                attributes.emplace_back(&quot;summoned&quot;);</a>
<a name="ln3366"> </a>
<a name="ln3367">            if (mi.is(MB_PERM_SUMMON))</a>
<a name="ln3368">                attributes.emplace_back(&quot;durably summoned&quot;);</a>
<a name="ln3369"> </a>
<a name="ln3370">            if (mi.is(MB_SUMMONED_CAPPED))</a>
<a name="ln3371">                attributes.emplace_back(&quot;expiring&quot;);</a>
<a name="ln3372"> </a>
<a name="ln3373">            string str = comma_separated_line(attributes.begin(),</a>
<a name="ln3374">                                              attributes.end());</a>
<a name="ln3375"> </a>
<a name="ln3376">            if (mi.type == MONS_DANCING_WEAPON</a>
<a name="ln3377">                || mi.type == MONS_PANDEMONIUM_LORD</a>
<a name="ln3378">                || mi.type == MONS_PLAYER_GHOST)</a>
<a name="ln3379">            {</a>
<a name="ln3380">                if (!str.empty())</a>
<a name="ln3381">                    str += &quot; &quot;;</a>
<a name="ln3382"> </a>
<a name="ln3383">                if (mi.type == MONS_DANCING_WEAPON)</a>
<a name="ln3384">                    str += &quot;dancing weapon&quot;;</a>
<a name="ln3385">                else if (mi.type == MONS_PANDEMONIUM_LORD)</a>
<a name="ln3386">                    str += &quot;pandemonium lord&quot;;</a>
<a name="ln3387">                else if (mi.type == MONS_PLAYER_GHOST)</a>
<a name="ln3388">                    str += &quot;ghost&quot;;</a>
<a name="ln3389">            }</a>
<a name="ln3390">            if (!str.empty())</a>
<a name="ln3391">                desc += &quot; (&quot; + str + &quot;)&quot;;</a>
<a name="ln3392">        }</a>
<a name="ln3393">    }</a>
<a name="ln3394"> </a>
<a name="ln3395">    string weap = _describe_monster_weapon(mi, level == DESC_IDENTIFIED);</a>
<a name="ln3396"> </a>
<a name="ln3397">    // Print the rest of the equipment only for full descriptions.</a>
<a name="ln3398">    if (level == DESC_WEAPON || level == DESC_WEAPON_WARNING)</a>
<a name="ln3399">        return desc + weap;</a>
<a name="ln3400"> </a>
<a name="ln3401">    item_def* mon_arm = mi.inv[MSLOT_ARMOUR].get();</a>
<a name="ln3402">    item_def* mon_shd = mi.inv[MSLOT_SHIELD].get();</a>
<a name="ln3403">    item_def* mon_qvr = mi.inv[MSLOT_MISSILE].get();</a>
<a name="ln3404">    item_def* mon_alt = mi.inv[MSLOT_ALT_WEAPON].get();</a>
<a name="ln3405">    item_def* mon_wnd = mi.inv[MSLOT_WAND].get();</a>
<a name="ln3406">    item_def* mon_rng = mi.inv[MSLOT_JEWELLERY].get();</a>
<a name="ln3407"> </a>
<a name="ln3408">#define uninteresting(x) (x &amp;&amp; !item_is_branded(*x) &amp;&amp; !is_artefact(*x))</a>
<a name="ln3409">    // For &quot;comes into view&quot; msgs, only care about branded stuff and artefacts</a>
<a name="ln3410">    if (level == DESC_IDENTIFIED)</a>
<a name="ln3411">    {</a>
<a name="ln3412">        if (uninteresting(mon_arm))</a>
<a name="ln3413">            mon_arm = nullptr;</a>
<a name="ln3414">        if (uninteresting(mon_shd))</a>
<a name="ln3415">            mon_shd = nullptr;</a>
<a name="ln3416">        if (uninteresting(mon_qvr))</a>
<a name="ln3417">            mon_qvr = nullptr;</a>
<a name="ln3418">        if (uninteresting(mon_rng))</a>
<a name="ln3419">            mon_rng = nullptr;</a>
<a name="ln3420">        if (uninteresting(mon_alt) &amp;&amp; mon_alt-&gt;base_type != OBJ_WANDS)</a>
<a name="ln3421">            mon_alt = nullptr;</a>
<a name="ln3422">    }</a>
<a name="ln3423">#undef uninteresting</a>
<a name="ln3424"> </a>
<a name="ln3425">    // _describe_monster_weapon already took care of this</a>
<a name="ln3426">    if (mi.wields_two_weapons())</a>
<a name="ln3427">        mon_alt = 0;</a>
<a name="ln3428"> </a>
<a name="ln3429">    const bool mon_has_wand = mon_wnd;</a>
<a name="ln3430">    const bool mon_carry = mon_alt || mon_has_wand;</a>
<a name="ln3431"> </a>
<a name="ln3432">    vector&lt;string&gt; item_descriptions;</a>
<a name="ln3433"> </a>
<a name="ln3434">    // Dancing weapons have all their weapon information in their full_name, so</a>
<a name="ln3435">    // we don't need to add another weapon description here (see Mantis 11887).</a>
<a name="ln3436">    if (!weap.empty()</a>
<a name="ln3437">        &amp;&amp; mi.type != MONS_DANCING_WEAPON &amp;&amp; mi.type != MONS_SPECTRAL_WEAPON)</a>
<a name="ln3438">    {</a>
<a name="ln3439">        item_descriptions.push_back(weap.substr(1)); // strip leading space</a>
<a name="ln3440">    }</a>
<a name="ln3441"> </a>
<a name="ln3442">    if (mon_arm)</a>
<a name="ln3443">    {</a>
<a name="ln3444">        const string armour_desc = make_stringf(&quot;wearing %s&quot;,</a>
<a name="ln3445">                                                mon_arm-&gt;name(DESC_A).c_str());</a>
<a name="ln3446">        item_descriptions.push_back(armour_desc);</a>
<a name="ln3447">    }</a>
<a name="ln3448"> </a>
<a name="ln3449">    if (mon_shd)</a>
<a name="ln3450">    {</a>
<a name="ln3451">        const string shield_desc = make_stringf(&quot;wearing %s&quot;,</a>
<a name="ln3452">                                                mon_shd-&gt;name(DESC_A).c_str());</a>
<a name="ln3453">        item_descriptions.push_back(shield_desc);</a>
<a name="ln3454">    }</a>
<a name="ln3455"> </a>
<a name="ln3456">    if (mon_rng)</a>
<a name="ln3457">    {</a>
<a name="ln3458">        const string rng_desc = make_stringf(&quot;wearing %s&quot;,</a>
<a name="ln3459">                                             mon_rng-&gt;name(DESC_A).c_str());</a>
<a name="ln3460">        item_descriptions.push_back(rng_desc);</a>
<a name="ln3461">    }</a>
<a name="ln3462"> </a>
<a name="ln3463">    if (mon_qvr)</a>
<a name="ln3464">    {</a>
<a name="ln3465">        const string qvr_desc = make_stringf(&quot;quivering %s&quot;,</a>
<a name="ln3466">                                             mon_qvr-&gt;name(DESC_A).c_str());</a>
<a name="ln3467">        item_descriptions.push_back(qvr_desc);</a>
<a name="ln3468">    }</a>
<a name="ln3469"> </a>
<a name="ln3470">    if (mon_carry)</a>
<a name="ln3471">    {</a>
<a name="ln3472">        string carried_desc = &quot;carrying &quot;;</a>
<a name="ln3473"> </a>
<a name="ln3474">        if (mon_alt)</a>
<a name="ln3475">        {</a>
<a name="ln3476">            carried_desc += mon_alt-&gt;name(DESC_A);</a>
<a name="ln3477">            if (mon_has_wand)</a>
<a name="ln3478">                carried_desc += &quot; and &quot;;</a>
<a name="ln3479">        }</a>
<a name="ln3480"> </a>
<a name="ln3481">        if (mon_has_wand)</a>
<a name="ln3482">            carried_desc += mon_wnd-&gt;name(DESC_A);</a>
<a name="ln3483"> </a>
<a name="ln3484">        item_descriptions.push_back(carried_desc);</a>
<a name="ln3485">    }</a>
<a name="ln3486"> </a>
<a name="ln3487">    const string item_description = comma_separated_line(</a>
<a name="ln3488">                                                item_descriptions.begin(),</a>
<a name="ln3489">                                                item_descriptions.end());</a>
<a name="ln3490"> </a>
<a name="ln3491">    if (!item_description.empty() &amp;&amp; !desc.empty())</a>
<a name="ln3492">        desc += &quot;, &quot;;</a>
<a name="ln3493">    return desc + item_description;</a>
<a name="ln3494">}</a>
<a name="ln3495"> </a>
<a name="ln3496">static bool _print_cloud_desc(const coord_def where)</a>
<a name="ln3497">{</a>
<a name="ln3498">    vector&lt;string&gt; areas;</a>
<a name="ln3499">    if (is_sanctuary(where))</a>
<a name="ln3500">        areas.emplace_back(&quot;lies inside a sanctuary&quot;);</a>
<a name="ln3501">    if (silenced(where))</a>
<a name="ln3502">        areas.emplace_back(&quot;is shrouded in silence&quot;);</a>
<a name="ln3503">    if (haloed(where) &amp;&amp; !umbraed(where))</a>
<a name="ln3504">        areas.emplace_back(&quot;is lit by a halo&quot;);</a>
<a name="ln3505">    if (umbraed(where) &amp;&amp; !haloed(where))</a>
<a name="ln3506">        areas.emplace_back(&quot;is wreathed by an umbra&quot;);</a>
<a name="ln3507">    if (liquefied(where))</a>
<a name="ln3508">        areas.emplace_back(&quot;is liquefied&quot;);</a>
<a name="ln3509">    if (orb_haloed(where) || quad_haloed(where))</a>
<a name="ln3510">        areas.emplace_back(&quot;is covered in magical glow&quot;);</a>
<a name="ln3511">    if (disjunction_haloed(where))</a>
<a name="ln3512">        areas.emplace_back(&quot;is bathed in translocational energy&quot;);</a>
<a name="ln3513">    if (!areas.empty())</a>
<a name="ln3514">    {</a>
<a name="ln3515">        mprf(&quot;This square %s.&quot;,</a>
<a name="ln3516">             comma_separated_line(areas.begin(), areas.end()).c_str());</a>
<a name="ln3517">    }</a>
<a name="ln3518"> </a>
<a name="ln3519">    if (cloud_struct* cloud = cloud_at(where))</a>
<a name="ln3520">    {</a>
<a name="ln3521">        mprf(MSGCH_EXAMINE, &quot;There is a cloud of %s here.&quot;,</a>
<a name="ln3522">             cloud-&gt;cloud_name(true).c_str());</a>
<a name="ln3523">        return true;</a>
<a name="ln3524">    }</a>
<a name="ln3525"> </a>
<a name="ln3526">    return false;</a>
<a name="ln3527">}</a>
<a name="ln3528"> </a>
<a name="ln3529">static bool _print_item_desc(const coord_def where)</a>
<a name="ln3530">{</a>
<a name="ln3531">    int targ_item = you.visible_igrd(where);</a>
<a name="ln3532"> </a>
<a name="ln3533">    if (targ_item == NON_ITEM)</a>
<a name="ln3534">        return false;</a>
<a name="ln3535"> </a>
<a name="ln3536">    string name = menu_colour_item_name(mitm[targ_item], DESC_A);</a>
<a name="ln3537">    mprf(MSGCH_FLOOR_ITEMS, &quot;You see %s here.&quot;, name.c_str());</a>
<a name="ln3538"> </a>
<a name="ln3539">    if (mitm[ targ_item ].link != NON_ITEM)</a>
<a name="ln3540">        mprf(MSGCH_FLOOR_ITEMS, &quot;There is something else lying underneath.&quot;);</a>
<a name="ln3541"> </a>
<a name="ln3542">    return true;</a>
<a name="ln3543">}</a>
<a name="ln3544"> </a>
<a name="ln3545">#ifdef DEBUG_DIAGNOSTICS</a>
<a name="ln3546">static void _debug_describe_feature_at(const coord_def &amp;where)</a>
<a name="ln3547">{</a>
<a name="ln3548">    const string feature_desc = feature_description_at(where, true);</a>
<a name="ln3549">    string marker;</a>
<a name="ln3550">    if (map_marker *mark = env.markers.find(where, MAT_ANY))</a>
<a name="ln3551">    {</a>
<a name="ln3552">        string desc = mark-&gt;debug_describe();</a>
<a name="ln3553">        if (desc.empty())</a>
<a name="ln3554">            desc = &quot;?&quot;;</a>
<a name="ln3555">        marker = &quot; (&quot; + desc + &quot;)&quot;;</a>
<a name="ln3556">    }</a>
<a name="ln3557">    const string traveldest = _stair_destination_description(where);</a>
<a name="ln3558">    string height_desc;</a>
<a name="ln3559">    if (env.heightmap)</a>
<a name="ln3560">        height_desc = make_stringf(&quot; (height: %d)&quot;, (*env.heightmap)(where));</a>
<a name="ln3561">    const dungeon_feature_type feat = grd(where);</a>
<a name="ln3562"> </a>
<a name="ln3563">    string vault;</a>
<a name="ln3564">    const int map_index = env.level_map_ids(where);</a>
<a name="ln3565">    if (map_index != INVALID_MAP_INDEX)</a>
<a name="ln3566">    {</a>
<a name="ln3567">        const vault_placement &amp;vp(*env.level_vaults[map_index]);</a>
<a name="ln3568">        const coord_def br = vp.pos + vp.size - 1;</a>
<a name="ln3569">        vault = make_stringf(&quot; [Vault: %s (%d,%d)-(%d,%d) (%dx%d)]&quot;,</a>
<a name="ln3570">                             vp.map_name_at(where).c_str(),</a>
<a name="ln3571">                             vp.pos.x, vp.pos.y,</a>
<a name="ln3572">                             br.x, br.y,</a>
<a name="ln3573">                             vp.size.x, vp.size.y);</a>
<a name="ln3574">    }</a>
<a name="ln3575"> </a>
<a name="ln3576">    char32_t ch = get_cell_glyph(where).ch;</a>
<a name="ln3577">    dprf(&quot;(%d,%d): %s - %s. (%d/%s)%s%s%s%s map: %x&quot;,</a>
<a name="ln3578">         where.x, where.y,</a>
<a name="ln3579">         ch == '&lt;' ? &quot;&lt;&lt;&quot; : stringize_glyph(ch).c_str(),</a>
<a name="ln3580">         feature_desc.c_str(),</a>
<a name="ln3581">         feat,</a>
<a name="ln3582">         dungeon_feature_name(feat),</a>
<a name="ln3583">         marker.c_str(),</a>
<a name="ln3584">         traveldest.c_str(),</a>
<a name="ln3585">         height_desc.c_str(),</a>
<a name="ln3586">         vault.c_str(),</a>
<a name="ln3587">         env.map_knowledge(where).flags);</a>
<a name="ln3588">}</a>
<a name="ln3589">#endif</a>
<a name="ln3590"> </a>
<a name="ln3591">// Describe a cell, guaranteed to be in view.</a>
<a name="ln3592">static void _describe_cell(const coord_def&amp; where, bool in_range)</a>
<a name="ln3593">{</a>
<a name="ln3594">#ifndef DEBUG_DIAGNOSTICS</a>
<a name="ln3595">    bool monster_described = false;</a>
<a name="ln3596">#endif</a>
<a name="ln3597"> </a>
<a name="ln3598">    if (where == you.pos() &amp;&amp; !crawl_state.arena_suspended)</a>
<a name="ln3599">        mprf(MSGCH_EXAMINE_FILTER, &quot;You.&quot;);</a>
<a name="ln3600"> </a>
<a name="ln3601">    if (const monster* mon = monster_at(where))</a>
<a name="ln3602">    {</a>
<a name="ln3603">#ifdef DEBUG_DIAGNOSTICS</a>
<a name="ln3604">        if (!mon-&gt;visible_to(&amp;you))</a>
<a name="ln3605">        {</a>
<a name="ln3606">            mprf(MSGCH_DIAGNOSTICS, &quot;There is a non-visible %smonster here.&quot;,</a>
<a name="ln3607">                 _mon_exposed_in_water(mon) ? &quot;exposed by water &quot; :</a>
<a name="ln3608">                 _mon_exposed_in_cloud(mon) ? &quot;exposed by cloud &quot; : &quot;&quot;);</a>
<a name="ln3609">        }</a>
<a name="ln3610">#else</a>
<a name="ln3611">        if (!mon-&gt;visible_to(&amp;you))</a>
<a name="ln3612">        {</a>
<a name="ln3613">            if (_mon_exposed_in_water(mon))</a>
<a name="ln3614">                mprf(MSGCH_EXAMINE_FILTER, &quot;There is a strange disturbance in the water here.&quot;);</a>
<a name="ln3615">            else if (_mon_exposed_in_cloud(mon))</a>
<a name="ln3616">                mprf(MSGCH_EXAMINE_FILTER, &quot;There is a strange disturbance in the cloud here.&quot;);</a>
<a name="ln3617"> </a>
<a name="ln3618">            goto look_clouds;</a>
<a name="ln3619">        }</a>
<a name="ln3620">#endif</a>
<a name="ln3621"> </a>
<a name="ln3622">        monster_info mi(mon);</a>
<a name="ln3623">        _describe_monster(mi);</a>
<a name="ln3624"> </a>
<a name="ln3625">        if (!in_range)</a>
<a name="ln3626">        {</a>
<a name="ln3627">            mprf(MSGCH_EXAMINE_FILTER, &quot;%s %s out of range.&quot;,</a>
<a name="ln3628">                 mon-&gt;pronoun(PRONOUN_SUBJECTIVE).c_str(),</a>
<a name="ln3629">                 conjugate_verb(&quot;are&quot;, mi.pronoun_plurality()).c_str());</a>
<a name="ln3630">        }</a>
<a name="ln3631">#ifndef DEBUG_DIAGNOSTICS</a>
<a name="ln3632">        monster_described = true;</a>
<a name="ln3633">#endif</a>
<a name="ln3634"> </a>
<a name="ln3635">#if defined(DEBUG_DIAGNOSTICS) &amp;&amp; defined(WIZARD)</a>
<a name="ln3636">        debug_stethoscope(mgrd(where));</a>
<a name="ln3637">#endif</a>
<a name="ln3638">        if (crawl_state.game_is_hints() &amp;&amp; hints_monster_interesting(mon))</a>
<a name="ln3639">        {</a>
<a name="ln3640">            const char *msg;</a>
<a name="ln3641">#ifdef USE_TILE_LOCAL</a>
<a name="ln3642">            msg = &quot;(&lt;w&gt;Right-click&lt;/w&gt; for more information.)&quot;;</a>
<a name="ln3643">#else</a>
<a name="ln3644">            msg = &quot;(Press &lt;w&gt;v&lt;/w&gt; for more information.)&quot;;</a>
<a name="ln3645">#endif</a>
<a name="ln3646">            mpr(msg);</a>
<a name="ln3647">        }</a>
<a name="ln3648">    }</a>
<a name="ln3649"> </a>
<a name="ln3650">#ifdef DEBUG_DIAGNOSTICS</a>
<a name="ln3651">    _print_cloud_desc(where);</a>
<a name="ln3652">    _print_item_desc(where);</a>
<a name="ln3653">    _debug_describe_feature_at(where);</a>
<a name="ln3654">#else</a>
<a name="ln3655">  // removing warning</a>
<a name="ln3656">  look_clouds:</a>
<a name="ln3657"> </a>
<a name="ln3658">    bool cloud_described = _print_cloud_desc(where);</a>
<a name="ln3659">    bool item_described = _print_item_desc(where);</a>
<a name="ln3660"> </a>
<a name="ln3661">    string feature_desc = feature_description_at(where, true);</a>
<a name="ln3662">    const bool bloody = is_bloodcovered(where);</a>
<a name="ln3663">    if (crawl_state.game_is_hints() &amp;&amp; hints_pos_interesting(where.x, where.y))</a>
<a name="ln3664">    {</a>
<a name="ln3665">#ifdef USE_TILE_LOCAL</a>
<a name="ln3666">        feature_desc += &quot; (&lt;w&gt;Right-click&lt;/w&gt; for more information.)&quot;;</a>
<a name="ln3667">#else</a>
<a name="ln3668">        feature_desc += &quot; (Press &lt;w&gt;v&lt;/w&gt; for more information.)&quot;;</a>
<a name="ln3669">#endif</a>
<a name="ln3670">        mpr(feature_desc);</a>
<a name="ln3671">    }</a>
<a name="ln3672">    else</a>
<a name="ln3673">    {</a>
<a name="ln3674">        dungeon_feature_type feat = grd(where);</a>
<a name="ln3675"> </a>
<a name="ln3676">        if (_interesting_feature(feat))</a>
<a name="ln3677">        {</a>
<a name="ln3678">#ifdef USE_TILE_LOCAL</a>
<a name="ln3679">            feature_desc += &quot; (Right-click for more information.)&quot;;</a>
<a name="ln3680">#else</a>
<a name="ln3681">            feature_desc += &quot; (Press 'v' for more information.)&quot;;</a>
<a name="ln3682">#endif</a>
<a name="ln3683">        }</a>
<a name="ln3684"> </a>
<a name="ln3685">        // Suppress &quot;Floor.&quot; if there's something on that square that we've</a>
<a name="ln3686">        // already described.</a>
<a name="ln3687">        if (feat == DNGN_FLOOR &amp;&amp; !bloody</a>
<a name="ln3688">            &amp;&amp; (monster_described || item_described || cloud_described))</a>
<a name="ln3689">        {</a>
<a name="ln3690">            return;</a>
<a name="ln3691">        }</a>
<a name="ln3692"> </a>
<a name="ln3693">        msg_channel_type channel = MSGCH_EXAMINE;</a>
<a name="ln3694">        if (feat == DNGN_FLOOR || feat_is_water(feat))</a>
<a name="ln3695">            channel = MSGCH_EXAMINE_FILTER;</a>
<a name="ln3696"> </a>
<a name="ln3697">        mprf(channel, &quot;%s&quot;, feature_desc.c_str());</a>
<a name="ln3698">    }</a>
<a name="ln3699">#endif</a>
<a name="ln3700">}</a>
<a name="ln3701"> </a>
<a name="ln3702">///////////////////////////////////////////////////////////////////////////</a>
<a name="ln3703">// targeting_behaviour</a>
<a name="ln3704"> </a>
<a name="ln3705">targeting_behaviour::targeting_behaviour(bool look_around)</a>
<a name="ln3706">    : just_looking(look_around), compass(false)</a>
<a name="ln3707">{</a>
<a name="ln3708">}</a>
<a name="ln3709"> </a>
<a name="ln3710">targeting_behaviour::~targeting_behaviour()</a>
<a name="ln3711">{</a>
<a name="ln3712">}</a>
<a name="ln3713"> </a>
<a name="ln3714">int targeting_behaviour::get_key()</a>
<a name="ln3715">{</a>
<a name="ln3716">    if (!crawl_state.is_replaying_keys())</a>
<a name="ln3717">        flush_input_buffer(FLUSH_BEFORE_COMMAND);</a>
<a name="ln3718"> </a>
<a name="ln3719">    flush_prev_message();</a>
<a name="ln3720">    msgwin_got_input();</a>
<a name="ln3721">    return unmangle_direction_keys(getchm(KMC_TARGETING), KMC_TARGETING,</a>
<a name="ln3722">                                   false);</a>
<a name="ln3723">}</a>
<a name="ln3724"> </a>
<a name="ln3725">command_type targeting_behaviour::get_command(int key)</a>
<a name="ln3726">{</a>
<a name="ln3727">    if (key == -1)</a>
<a name="ln3728">        key = get_key();</a>
<a name="ln3729"> </a>
<a name="ln3730">    command_type cmd = key_to_command(key, KMC_TARGETING);</a>
<a name="ln3731">    if (cmd &gt;= CMD_MIN_TARGET &amp;&amp; cmd &lt; CMD_TARGET_PREV_TARGET)</a>
<a name="ln3732">        return cmd;</a>
<a name="ln3733"> </a>
<a name="ln3734">    // XXX: hack</a>
<a name="ln3735">    if (cmd == CMD_TARGET_SELECT &amp;&amp; key == ' ' &amp;&amp; just_looking)</a>
<a name="ln3736">        cmd = CMD_TARGET_CANCEL;</a>
<a name="ln3737"> </a>
<a name="ln3738">    return cmd;</a>
<a name="ln3739">}</a>
<a name="ln3740"> </a>
<a name="ln3741">vector&lt;string&gt; targeting_behaviour::get_monster_desc(const monster_info&amp; mi)</a>
<a name="ln3742">{</a>
<a name="ln3743">    vector&lt;string&gt; descs;</a>
<a name="ln3744">    if (get_desc_func)</a>
<a name="ln3745">        _append_container(descs, (get_desc_func)(mi));</a>
<a name="ln3746">    return descs;</a>
<a name="ln3747">}</a>

</code></pre>
<div class="balloon" rel="910"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v648/" target="_blank">V648</a> Priority of the '&&' operation is higher than that of the '||' operation.</p></div>
<div class="balloon" rel="1333"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v648/" target="_blank">V648</a> Priority of the '&&' operation is higher than that of the '||' operation.</p></div>
<div class="balloon" rel="498"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v730/" target="_blank">V730</a> Not all members of a class are initialized inside the constructor. Consider inspecting: valid_shadow_step.</p></div>

<link rel="stylesheet" href="highlight.css">
<script src="highlight.pack.js"></script>
<script src="highlightjs-line-numbers.js"></script>
<script>hljs.initHighlightingOnLoad();</script>
<script>hljs.initLineNumbersOnLoad();</script>
<script>
  $(document).ready(function() {
      $('.balloon').each(function () {
          var bl = $(this);
          var line = bl.attr('rel');
          var text = $('a[name="ln'+line+'"]').text();

          var space_count = 0;
          for(var i = 0; i<text.length; i++){
              var char = text[i];
              if((char !== ' ')&&(char !== '\t'))break;
              if(char === '\t')space_count++;
              space_count++;
          }

          bl.css('margin-left', space_count*8);
          $('a[name="ln'+line+'"]').after(bl);
      });

      window.location = window.location;
  });
</script>
</body>
</html>
